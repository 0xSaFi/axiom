bookvolbib type inferencing for Common Lisp

Goal: Proving Axiom Correct

\index{Baker, Henry G.}
\begin{chunk}{axiom.bib}
@misc{Bake90,
  author = "Baker, Henry G.",
  title = "The Nimble Type Inferencer for Common Lisp-84",
  link = "\url{http://home.pipeline.com/~hbaker1/TInference.html}",
  year = "1990",
  abstract = 
    "We describe a framework and an algorithm for doing type inference
    analysis on programs written in full Common Lisp-84 (Common Lisp
    without the CLOS object-oriented extensions). The objective of type
    inference is to determine tight lattice upper bounds on the range of
    runtime data types for Common Lisp program variables and
    temporaries. Depending upon the lattice used, type inference can also
    provide range analysis information for numeric variables. This lattice
    upper bound information can be used by an optimizing compiler to
    choose more restrictive, and hence more efficient, representations for
    these program variables. Our analysis also produces tighter control
    flow information, which can be used to eliminate redundant tests which
    result in dead code. The overall goal of type inference is to
    mechanically extract from Common Lisp programs the same degree of
    representation information that is usually provided by the programmer
    in traditional strongly-typed languages. In this way, we can provide
    some classes of Common Lisp programs execution time efficiency
    expected only for more strongly-typed compiled languages.
    
    The Nimble type inference system follows the traditional
    lattice/algebraic data flow techniques [Kaplan80], rather than the
    logical/theorem-proving unification techniques of ML [Milner78]. It
    can handle polymorphic variables and functions in a natural way, and
    provides for ``case-based'' analysis that is quite similar to that used
    intuitively by programmers. Additionally, this inference system can
    deduce the termination of some simple loops, thus providing
    surprisingly tight upper lattice bounds for many loop variables.
    
    By using a higher resolution lattice, more precise typing of primitive
    functions, polymorphic types and case analysis, the Nimble type
    inference algorithm can often produce sharper bounds than
    unification-based type inference techniques. At the present time,
    however, our treatment of higher-order data structures and functions
    is not as elegant as that of the unification techniques."
}

\end{chunk}

