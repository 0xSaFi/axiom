books/bookvolbib COQ Program Construction papers

Goal: Proving Axiom Correct


\index{Coquand, Thierry}
\index{Huet, G\'erard}
\index{Paulin, Christine}
\begin{chunk}{axiom.bib}
@misc{COQx16,
  author = {Coquand, Thierry and Huet, G\'erard and Paulin, Christine},
  title = "The COQ Proof Assistant",
  year = "2016",
  url = "https://coq.inria.fr"
}

\index{Coquand, Thierry}
\index{Huet, G\'erard}
\index{Paulin, Christine}
\begin{chunk}{axiom.bib}
@misc{COQx16a,
  author = {Coquand, Thierry and Huet, G\'erard and Paulin, Christine},
  title = "COQ Proof Assistant Library Coq.ZArith.Znumtheory",
  year = "2016",
  url = "https://coq.inria.fr/library/Coq.ZArith.Znumtheory.html"
}

\index{Parent, Catherine}
\begin{chunk}{axiom.bib}
@techreport{Pare94,
  author = "Parent, Catherine",
  title = "Synthesizing proofs from programs in the Calculus of Inductive
           Constructions",
  year = "1994",
  institution = {Ecole Normale Sup\'erieure de Lyon},
  abstract =
    "In type theory, a proof can be represented as a typed $\lambda$-term.
    There exist methods to mark logical parts in proofs and extract their
    algorithmic contents. The result is a correct program with respect to
    a specification. This paper focuses on the inverse problem: how to 
    generate a proof from its specification. The framework is the Calculus
    of Inductive Constructions. A notion of coherence is introduced between
    a specification and a program containing types but no logical proofs.
    This notion is based on the definition of an extraction function called
    the weak extraction. Such a program can give a method to reconstruct a
    set of logical properties needed to have a proof of the initial 
    specification. This can be seen either as a method of proving programs
    or as a method of synthetically describing proofs.",
  paper = "Pare94.pdf"
}

\end{chunk}

\index{Parent-Vigouroux, Catherine}
\begin{chunk}{axiom.bib}
@article{Pare97,
  author = "Parent-Vigouroux, Catherine",
  title = "Verifying programs in the Calculus of Inductive Constructions",
  year = "1997",
  journal = "Formal Aspects of Computing",
  volume = "9",
  number = "5",
  pages = "484-517",
  abstract =
    "This paper deals with a particular approach to the verification of
    functional programs. A specification of a program can be represented
    by a logical formula. In a constructive framework, developing a program
    then corresponds to proving this formula. Given a specification and a
    program, we focus on reconstructing a proof of the specification whose
    algorithmic contents corresponds to the given program. The best we can
    hope is to generate proof obligations on atomic parts of the program 
    corresponding to logical properties to be verified. First, this paper
    studies a weak extraction of a program from a proof that keeps track
    of intermediate specifications. From such a program, we prove the
    determinism of retrieving proof obligations. Then, heuristic methods
    are proposed for retrieving the proof from a natural program containing
    only partial annotations. Finally, the implementation of this methos as
    a tactic of the {\sl Coq} proof assistant is presented.",
  paper = "Pare97.pdf"
}

\end{chunk}

\index{Parent-Vigouroux, Catherine}
\begin{chunk}{axiom.bib}
@misc{Pare96,
  author = "Parent-Vigouroux, Catherine",
  title = "Natural proofs versus programs optimization in the 
           Calculus of Inductive Constructions",
  year = "1996",
  abstract =
    "This paper presents how to automatically prove that an 'optimized'
    program is correct with respect to a set of given properties that is a
    specification. Proofs of specifications contain logical and
    computational parts. Programs can be seen as computational parts of
    proofs. They can thus be extracted from proofs and be certified to be
    correct. The inverse problem can be solved: it is possible to
    reconstruct proof obligations from a program and its specification.
    The framework is a type theory where a proof can be represented as a
    typed $\lambda$-term and, particularly, the Calculus of Inductive
    Constructions. This paper shows how programs can be simplified in
    order to be written in a much closer way to the ML one's. Indeed,
    proofs structures are often much more heavy than program structures. 
    The problem is consequently to consider natural programs (in a ML sense) 
    and see how to retrieve natural structures of proofs from them.",
  paper = "Pare96.pdf"
}

\end{chunk}

\index{Parent, Catherine}
\begin{chunk}{axiom.bib}
@inproceedings{Pare93,
  author = "Parent, Catherine",
  title = "Developing Certified Programs in the System Coq: The Program
           Tactic",
  booktitle = "Proc. Int. Workshop on Types for Proofs and Programs",
  publisher = "Springer-Verlag",
  isbn = "3-540-58085-9",
  pages = "291-312",
  year = "1993",
  abstract =
    "The system {\sl Coq} is an environment for proof development based on
    the Calculus of Constructions extended by inductive definitions. The
    specification of a program can be represented by a logical formula and
    the program itself can be extracted from the constructive proof of the
    specification. In this paper, we look at the possibility of inverting
    the specification and a program, builds the logical condition to be
    verified in order to obtain a correctness proof of the program. We
    build a proof of the specification from the program from which the
    program can be extracted. Since some information cannot automatically
    be inferred, we show how to annotate the program by specifying some of
    its parts in order to guide the search for the proof.",
  paper = "Pare93.ps"
}

\end{chunk}

\index{Coquand, Thierry}
\index{Huet, G\'erard}
\begin{chunk}{axiom.bib}
@techreport{Coqu86,
  author = {Coquand, Thierry and Huet, G\'erard},
  title = "The Calculus of Constructions",
  year = "1986",
  institution = "INRIA Centre de Rocquencourt",
  number = "530",
  url = "https://hal.inria.fr/inria-00076024/document",
  abstract = 
    "The Calculus of Constructions is a higher-order formalism for
    constructive proofs in natural deduction style. Every proof is a
    $\lambda$-expression, typed with propositions of the underlying
    logic. By removing types we get a pure $\lambda$-expression,
    expressing its associated algorithm. Computing this
    $\lambda$-expression corresponds roughly to cut-elimination. It is our
    thesis that (as already advocated by Martin-Lof) the Curry-Howard
    correspondence between propositions and types is a powerful paradigm
    for Computer Science. In the case of Constructions, we obtain the
    notion of a very high-level functional programming language, with
    complex polymorphism well-suited for modules specification. The notion
    of type encompasses the usual notioin of data type, but allows as well
    arbitrarily complex algorithmic specifications. We develop the basic
    theory of a Calculus of Constructions, and prove a strong
    normalization theorem showing that all computations terminate. 
    Finally, we suggest various extensions to stronger calculi.",
  paper = "Coqu86.pdf"
}

\end{chunk}

