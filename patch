books/bookvolbib add references

Goal: Proving Axiom Correct

\index{Maurer, D.}
\begin{chunk}{axiom.bib}
@article{Maur73,
  author = "Maurer, D.",
  title = {{Applications of Symbolic Mathematical Manipulation to 
            Algorithmic Verification (Abstract)},
  journal = "SIGSAM Bulletin",
  volume = "26",
  year = "1973",
  pages = "4"
}

\end{chunk}

\index{Waldinger, R.J.}
\index{Levitt, K.N.}
\begin{chunk}{axiom.bib}
@article{Wald74,
  author = "Waldinger, R.J. and Levitt, K.N.",
  title = {{Reasoning about Programs}},
  journal = "Artificial Intelligence",
  volume = "5",
  number = "3",
  year = "1974",
  pages = "235-316",
  abstract =
    "This paper describes a theorem prover that embodies knowledge about
    programming constructs, such as numbers, arrays, lists, and
    expressions. The program can reason about these concepts and is used
    as part of a program verification system that uses the Floyd-Naur
    explication of program semantics. It is implemented in the qa4
    language; the qa4 system allows many pieces of strategic knowledge,
    each expressed as a small program, to be coordinated so that a program
    stands forward when it is relevant to the problem at hand. The
    language allows clear, concise representation of this sort of
    knowledge. The qa4 system also has special facilities for dealing with
    commutative functions, ordering relations, and equivalence relations;
    these features are heavily used in this deductive system. The program
    interrogates the user and asks his advice in the course of a
    proof. Verifications have been found for Hoare's FIND program, a
    real-number division algorithm, and some sort programs, as well as for
    many simpler algorithms. Additional theorems have been proved about a
    pattern matcher and a version of Robinson's unification algorithm. The
    appendix contains a complete, annotated listing of the deductive
    system and annotated traces of several of the deductions performed by
    the system.",
  paper = "Wald74.pdf"
}

\end{chunk}

\index{Floyd, W.}
\begin{chunk}{axiom.bib}
@incollection{Floy86,
  author = "Floyd, W.",
  title = {{Toward Interactive Design of Correct Programs}},
  booktitle = "Reading in Artificial Intelligence and Software Engeering",
  pages = "331-334",
  year = "1986",
  isbn = "0-934613-12-5"
}

\end{chunk}

\index{Milner, R.}
\begin{chunk}{axiom.bib}
@article{Miln84,
  author = "Milner, R.",
  title = {{The Use of Machines to Assist in Rigorous Proof}},
  journal = "Philosophical Transactions of the Royal Society",
  volume = "312",
  pages = "411-422",
  number = "1522",
  year = "1984",
  abstract = 
    "A methodology for computer assisted proof is presented with an
    example. A central ingredient in the method is the presentation of
    tactics (or strategies) in an algorithmic metalanguage. Further, the
    same language is also used to express combinators, by which simple
    elementary tactics - which often correspond to the inference rules of
    the logic employed - are combined into more complex tactics, which may
    even be strategies complete for a class of problems. However, the
    emphasis is not upon completeness but upon providing a metalogical
    framework within which a user may express his insight into proof
    methods and may delegate routine (but error-prone) work to the
    computer. This method of tactic composition is presented at the start
    of the paper in the form of an elementary theory of goal-seeking. A
    second ingredient of the methodology is the stratification of
    machine-assisted proof by an ancestry graph of applied theories, and
    the example illustrates this stratification. In the final section,
    some recent developments and applications of the method are cited.",
  paper = "Miln84.pdf"
}

\end{chunk}

\index{Giunchiglia, Fausto}
\index{Pecchiari, Paolo}
\index{Talcott, Carolyn}
\begin{chunk}{axiom.bib}
@techreport{Giun94,
  author = "Giunchiglia, Fausto and Pecchiari, Paolo and Talcott, Carolyn",
  title = {{Reasoning Theories - Towards an Architecture for Open
            Mechanized Reasoning}},
  year = "1994",
  institution = "Stanford University",
  abstract =
    "Our ultimate goal is to provide a framework and a methodology which
    will allow users, and not only system developers, to construct complex
    reasoning systems by composing existing modules, or to add new modules
    to existing systems, in a "plug and play" manner. These modules and
    systems might be based on different logics; have different domain
    models; use different vocabularies and data structures; use different
    reasoning strategies; and have different interaction
    capabilities. This paper makes two main contributions towards our
    goal. First, it proposes a general architecture for a class of
    reasoning systems called Open Mechanized Reasoning Systems (OMRSs). An
    OMRS has three components: a reasoning theory component which is the
    counterpart of the logical notion of formal system, a control
    component which consists of a set of inference strategies, and an
    interaction component which provides an OMRS with the capability of
    interacting with other systems, including OMRSs and hum...",
  paper = "Giun94.pdf"
}

\end{chunk}

\index{Carette, Jacques}
\index{Farmer, William M.}
\index{Wajs, Jeremie}
\begin{chunk}{axiom.bib}
@misc{Care11b,
  author = "Carette, Jacques and Farmer, William M. and Wajs, Jeremie",
  title = {{Trustable Communication Between Mathematics Systems}},
  year = "2011",
  link = "\url{https://pdfs.semanticscholar.org/0d0b/206edf7ef1c01d7bfa1284c85b469b2fbd29.pdf}",
  abstract =
    "This paper presents a rigorous, unified framework for facilitating
    communication between mathematics systems. A mathematics system is
    given one or more interfaces which offer deductive and computational
    services to other mathematics systems. To achieve communication 
    between systems, a client interface is linked to a server interface by
    an asymmetric connection consisting of a pair of translations.
    Answers to requests are trustable in the sense that they are correct
    provided a small set of prescribed conditions are satisfied. The
    frame work is robust with respect to interface extension and can
    process requests for abstract services, where the server interface is
    not fully specified.",
  paper = "Care11b.pdf"
}

\end{chunk}

\index{Carlisle, David}
\index{Ion, Patrick}
\index{Miner, Robert}
\begin{chunk}{axiom.bib}
@misc{Carl14,
  author = "Carlisle, David and Ion, Patrick and Miner, Robert",
  title = {{Mathematical Markup Language}},
  year = "2014",
  link = "\url{https://www.w3.org/TR/MathML3/}"
}

\end{chunk}

\index{Buswell, S.}
\index{Caprotti, O.}
\index{Carlisle, D.P.}
\index{Dewar, M.C.}
\index{Gaetano, M.}
\index{Kohlhase, M.}
\begin{chunk}{axiom.bib}
@misc{Busw04,
  author = "Buswell, S. and Caprotti, O. and Carlisle, D.P. and Dewar, M.C.
            and Gaetano, M. and Kohlhase, M.",
  title = {{The OpenMath Standard}},
  year = "2004",
  link = "\url{https://www.openmath.org/standard/om20-2004-06-30/omstd20.pdf}",
  paper = "Busw04.pdf"
}

\end{chunk}

\index{Armando, Alessandro}
\index{Zini, Daniele}
\begin{chunk}{axiom.bib}
@misc{Arma00,
  author = "Armando, Alessandro and Zini, Daniele",
  title = {{Towards Interoperable Mechanized Reasoning Systems:
            The Logic Broker Architecture}},
  year = "2000",
  abstract =
    "There is a growing interest in the integration of mechanized
    reasoning systems such as automated theorem provers, computer algebra
    systems, and model checkers.  State-of-the-art reasoning systems are
    the result of many man-years of careful development and engineering,
    and usually they provide a high degree of sophistication in their
    respective domain.  Yet they often perform poorly when applied outside
    the domain they have been designed for.  The problem of integrating
    mechanized reasoning systems is therefore being perceived as an
    important issue in automated reasoning.  In this paper we present
    the Logic Broker Architecture, a framework which provides the needed
    infrastructure for making mechanized reasoning systems interoperate.
    The architecture provides location transparency, a way to forward
    requests for logical services to appropriate reasoning systems via a
    simple registration/subscription mechanism, and a translation
    mechanism which ensures the transparent and provably sound exchange of
    logical services.",
  paper = "Arma00.pdf"
}

\end{chunk}

\index{Lester, D.R.}
\begin{chunk}{axiom.bib}
@inproceedings{Lest01,
  author = "Lester, D.R.",
  title = {{Effective Continued Fractions}},
  booktitle = "15th IEEE Symp. on Computer Arithmetic",
  publisher = "IEEE Computer Society Press",
  year = "2001",
  pages = "163-170",
  abstract =
    "Only the leading seven terms of a continued fraction are needed to
    perform on-line arithmetic, provided the continued fractions are of
    the correct form.  This forms the basis of a proof that there is an
    effective representation of the computable reals as continued
    fractions: we also demonstrate that the basic arithmetic operations
    are computable using this representation.",
  paper = "Lest01.pdf"
}

\end{chunk}

\index{Vuillemin, J.}
\begin{chunk}{axiom.bib}
@techreport{Vuil87,
  author = "Vuillemin, J.",
  title = {{Exact Real Computer Arithmetic with Continued Fractions}},
  institution = "Institut National de Recherche en Informatique et en
                 Automatique",
  year = "1987",
  number = "760",
  abstract =
    "We discuss a representation of the {\sl computable real numbers} by
    continued fractions. This deals with the subtle points of undecidable
    and integer division, as well as representing the infinite
    $\infty=1/0$ and undefined $\bot=0/0$ numbers. Two general algorithms
    for performing arithmetic operations are introduced. The 
    {\sl algebraic algorithm}, which computes sums and products of
    continued fractions as a special case, basically operates in a
    positional manner, producing one term of output for each term of
    input. The {\sl transcendental algorithm} uses a general formula of
    Gauss to compute the continued fractions of exponentials, logarithms,
    trigonometric functions, as well as a wide class of special
    functions. This work has been implemented in Le\_Lisp and the
    performance of these algorithms appears to be quite good; however, no
    competing system has been available for comparison",
  paper = "Vuil87.pdf"
}

\end{chunk}

\index{Zinn, Claus}
\begin{chunk}{axiom.bib}
@phdthesis{Zinn04,
  author = "Zinn, Claus",
  title = {{Understanding Informal Mathematical Discourse}},
  school = "Universitat Erlangen Nurnberg",
  year = "2004",
  abstract =
    "Automated reasoning is one of the most established disciplines in
    informatics and artificial intelligence, and formal methods become
    increasingly employed in practical applications. However, for the most
    part, such applications seem to be limited to informatics-specific
    areas (e.g., the verification of correctness properties of software
    and hardware specifications) and areas close to informatics such as
    computational linguistics (e.g., the computation of consistence and
    informativeness properties of semantic representations). Naturally,
    there is also a potential for practical applications in the the area
    of mathematics: the generation of proofs for mathematically
    interesting and motivated theorems and, quite associated, the
    computer-supported formalisation of (parts of elementary)
    mathematics. It is a matter of fact, however, that mathematicians
    rarely use computer-support for the construction and verification of
    proofs. This is mainly caused by the “unnaturalness” of the language
    and the reasoning that such proof engines support.

    In the past, researchers in the area of automated reasoning have
    focused their work on formalisms and algorithms that allow the
    construction and verification of proofs that are written in a
    formal-logical language and that only use a limited number of
    inference rules. For the computer scientist, such formal proofs have
    the advantage of a simple and ambiguous-free syntax, which can thus be
    easily processed. Moreover, the limited number of inference rules has
    a direct impact on the complexity of the search space that needs to be
    conquered during the process of constructing proofs. The verification
    of given formal proofs is greatly facilitated by the complete
    explicitness of their logical argumentation where no reasoning step is
    left out.  For mathematicians, however, such formal proofs are usually
    hard to understand. For them, they are written in an unfamiliar and
    artificial language and much too detailed. Moreover, the sheer number
    of inference steps, while logically relevant, describe only trivial
    mathematical details and make it difficult to follow a proof’s main
    underlying argumentation line. In practise, thus, mathematicians use
    proof generation engines rather seldom, if at all. The same is true
    with regard to proof verification tools. The amount of work that is
    required to verify a mathematical proof with such tools is
    considerable, if not prohibitive. Since proof verification systems
    only accept formal proofs as input, the mathematician’s first task is
    to manually translate the mathematical proof into the formal language
    that is accepted by the verifier. This in turn includes the
    translation of the proof’s underlying mathematical argumentation into
    inference rules that are supported by the proof engine. Such
    translations and refinements are usually very time consuming, tedious,
    and prone to error themselves. Hence, how the proof verifier then
    judges the result of proof translation and proof refinement is only
    of limited relevance to the original mathematical proof. From the
    mathematician’s point of view, there is thus a need for a proof
    verification system that is capable of processing mathematical proofs
    automatically, at least with regard to translating the mathematicians’
    expert language into the system’s artificial formal language. Such a
    system would have an enormous potential in the community of
    mathematics, and this potential has been recognised early. In the
    beginning of the 1960s, John McCarthy, one of the pioneers of
    artificial intelligence, remarked that ``[c]hecking mathematical proofs
    is potentially one of the most interesting and useful applications of
    automatic computers'' [111]. More than forty years thereafter, a tool
    that supports mathematicians with the verification of mathematical
    proofs is more science fiction than reality. Its realisation is
    associated with research questions within the disciplines of automated
    reasoning and computational linguistics that are still only partially
    answered.

    This thesis aims at contributing towards the realisation of a
    verifier for mathematical proofs. It attempts to provide a general
    framework as well as an implementation for such a proof
    engine. The dissertation’s objects of study are short and simple
    proofs that were taken from textbooks on elementary number
    theory. Fig. 1 depicts a proof of the mathematical truth that
    every positive integer greater than 1 can be represented as a
    product of one or more primes. The proof consists of only a few
    lines and little mathematical knowledge is necessary to follow the
    proof author’s argumentation. It is this kind of short proof that
    we attempt to check automatically.",
  paper = "Zinn04.pdf"
}

\end{chunk}

\index{Trybulec, Andrzej}
\begin{chunk}{axiom.bib}
@misc{Tryb02,
  author = "Trybulec, Andrzej",
  title = {{Towards Practical Formalizaiton of Mathematics}},
  comment = "abstract",
  link =
  "\url{http://www.macs.hw.ac.uk/~fairouz/forest//events/automath2002/abstracts/Andrzej.abst.html}",
  abstract =
    "In sixties the opinion that mathematics cannot be practically
    formalized was well established. So the main achievement of de Bruijn,
    among many others, is the decision that the problem must be reconsider
    and probably positively solved. And I believe that 1967 will be
    treated by future historians of mathematics as a turning point.

    It is not easy to say precisely what we learnt in the meantime, if we
    learnt anything at all. I believe that the most important results are:
    \begin{enumerate}
    \item we need experiments with much more advanced mathematics than
    already done
    \item a system for practical formalization of mathematics probably will
    not be a simple system based on small number of primitive notions
    \item integration with a computer algebra systems may be necessary or at
    least a feasible system must have bigger computational power. 
    \end{enumerate}

    Still we should me more concerned with the original ideas of de
    Bruijn, the most important that eventually we have to be able to
    formalize new mathematical results, published in mathematical
    newspapers in this century."
}

\end{chunk}

\index{Hayes, Patrick J.}
\begin{chunk}{axiom.bib}
@inproceedings{Haye74,
  author = "Hayes, Patrick J.",
  title = {{Some Problems and Non-problems in Representation Theory}},
  booktitle = "AI and Simulation of Behaviour Conference",
  year = "1974",
  pages = "63-79"
}

\end{chunk}

\index{de Bruijn, N.G.}
\begin{chunk}{axiom.bib}
@incollection{Brui94a,
  author = "de Bruijn, N.G.",
  title = {{The Mathematical Vernacular, a Language for Mathematics
            with Typed Sets}},
  booktitle = "Selected Papers on Automath",
  pages = "865-935",
  year = "1994",
  publisher = "North-Holland",
  link = "\url{https://pure.tue.nl/ws/files/2073504/610209.pdf}",
  paper = "Brui94a.pdf"
}

\end{chunk}

\index{Elbers, Hugo Johannes}
\begin{chunk}{axiom.bib}
@phdthesis{Elbe98,
  author = "Elbers, Hugo Johannes",
  title = {{Connecting Informal and Formal Mathematics}},
  year = "1998",
  school = "Technische Universiteit Eindhoven",
  paper = "Elbe98.pdf"
}

\end{chunk}

\index{Bundy, Alan}
\begin{chunk}{axiom.bib}
@incollection{Bund91,
  author = "Bundy, Alan",
  title = {{A Science of Reasoning (Extended Abstract)}},
  booktitle = "Computational Logic: Essays in Honor of Alan 
               Robinson",
  year = "1991",
  publisher = "MIT Press",
  abstract = 
    "How can we understand reasoning in general and mathematical proofs
    in particular? It is argued that a high-level understanding of proofs
    is needed to complement the low-level understanding provided by
    Logic. A role for computation is proposed to provide this high-level
    understanding, namely by the association of proof plans with
    proofs. Criteria are given for assessing the association of a proof
    plan with a proof.",
  paper = "Bund91.pdf"
}

\end{chunk}

\index{Daly, Timothy}
\index{Botch, Mark}
\begin{chunk}{axiom.bib}
@misc{Daly17,
  author = "Daly, Timothy and Botch, Mark",
  title = {{Axiom Developer Website}},
  link = "\url{http://axiom-developer.org}",
  year = "2017"
}

\end{chunk}

\index{Spector-Zabusky, Antal}
\index{Breitner, Joachim}
\index{Rizkallah, Christine}
\index{Weirich, Stephanie}
\begin{chunk}{axiom.bib}
@inproceedings{Spec18,
  author = "Spector-Zabusky, Antal and Breitner, Joachim and 
            Rizkallah, Christine and Weirich, Stephanie",
  title = {{Total Haskell is Reasonable Coq}},
  booktitle = "ACM SIGPLAN Int. Conf. on Certified Programs and
               Proofs",
  publisher = "ACM",
  year = "2018",
  abstract = 
    "We would like to use the Coq proof assistant to mechanically
    verify properites of Haskell programs. To that end, we present a
    tool, named {\tt hs-to-coq}, that translates total Haskell
    programs into Coq programs via a shallow embedding. We apply our
    tool in three case studies -- a lawful {\tt Monad} instance,
    ``Hutton's razor'', and an existing data structure library -- and
    prove their correctness. These examples show that this approach is
    viable: both that {\tt hs-to-coq} applies to existing Haskell
    code, and that the output it produces is amenable to
    verification.",
  paper = "Spec18.pdf"
}

\end{chunk}
