books/bookvolbib add references

Goal: Proving Axiom Correct

\index{Hickey, Rich}
\begin{chunk}{axiom.bib}
@misc{Hick18,
  author = "Hickey, Rich",
  title = {{Effective Programs - 10 Years of Clojure}},
  link = "\url{https://www.youtube.com/watch?v=2V1FtfBDsLU}",
  year = "2018"
}

\end{chunk}

\index{Thiemann, Rene}
\index{Yamada, Akihisa}
\begin{chunk}{axiom.bib}
@article{Thie17,
  author = "Thiemann, Rene and Yamada, Akihisa",
  title = {{Polynomial Factorization: Proof Outline}},
  journal = "Archive of Formal Proofs",
  year = "2017",
  link = "\url{https://www.isa-afp.org/browser_info/current/AFP/Polynomial_Factorization/outline.pdf}",
  abstract =
    "Based on existing libraries for polynomial interpolation and
    matrices, we formalized several factorization algorihms for
    polynomials, including Kronecker's algorithm for intgeer polynomials,
    Yun's square-free factorization algorithm for field polynomials, and a
    factorization algorithm which delivers root-free polynomials.
    
    As side products, we developed division algorithms for polynomials
    over integral domains, as well as primality-testing and prime
    factorization algorithms for integers.",
  paper = "Thie17.pdf",
  keywords = "printed"
}  

\end{chunk}

\index{Thiemann, Rene}
\index{Yamada, Akihisa}
\begin{chunk}{axiom.bib}
@article{Thie17a,
  author = "Thiemann, Rene and Yamada, Akihisa",
  title = {{Polynomial Factorization: Proof Document}},
  journal = "Archive of Formal Proofs",
  year = "2017",
  link = "\url{https://www.isa-afp.org/browser_info/current/AFP/Polynomial_Factorization/document.pdf}",
  abstract =
    "Based on existing libraries for polynomial interpolation and
    matrices, we formalized several factorization algorihms for
    polynomials, including Kronecker's algorithm for intgeer polynomials,
    Yun's square-free factorization algorithm for field polynomials, and a
    factorization algorithm which delivers root-free polynomials.
    
    As side products, we developed division algorithms for polynomials
    over integral domains, as well as primality-testing and prime
    factorization algorithms for integers.",
  paper = "Thie17a.pdf"
}  

\end{chunk}

\begin{Crocker, David}
\begin{chunk}{axiom.bib}
@inproceedings{Croc14,
  author = "Crocker, David",
  title = {{Can C++ Be Made as Safe as SPARK?}},
  booktitle = "Proc 2014 HILT",
  isbn = "978-1-4503-3217-0",
  year = "2014",
  abstract =
    "SPARK offers a way to develop formally-verified software in a
    language (Ada) that is designed with safety in mind and is further
    restricted by the SPARK language subset. However, much critical
    embedded software is developed in C or C++ We look at whether and how
    benefits similar to those offered by the SPARK language subset and
    associated tools can be brought to a C++ development environment.",
  paper = "Croc14.pdf",
  keywords = "printed"
}

\end{chunk}

\index{Filliatre, Jean-Christophe}
\begin{chunk}{axiom.bib}
@article{Fill03,
  author = "Filliatre, Jean-Christophe",
  title = {{Verification of Non-Functional Programs using Interpretations
            in Type Theory}},
  journal = "J. Functional Programming",
  volume = "13",
  number = "4",
  pages = "709-745",
  year = "2003",
  abstract =
    "We study the problem of certifying programs combining imperative
    and functional features within the general framework of type
    theory. 

    Type theory is a powerful specification language, which is
    naturally suited for the proof of purely functional programs. To
    deal with imperative programs, we propose a logical interpretation
    of an annotated program as a partial proof of its
    specification. The construction of the corresponding partial proof
    term is based on a static analysis of the effects of the program
    which excludes aliases. The missing subterms in the partial proof
    term are seen as proof obligations, whose actual proofs are left
    to the user. We show that the validity of those proof obligations
    implies the total correctness of the program.
    
    This work has been implemented in the Coq proof assistant. It
    appears as a tactic taking an annotated program as argument and
    generating a set of proof obligations. Several nontrivial
    algorithms have been certified using this tactic.",
  paper = "Fill03.pdf",
  keywords = "printed"
}

\end{chunk}

\index{Garret, Ron}
\begin{chunk}{axiom.bib}
@misc{Garr14,
  author = "Garret, Ron",
  title = {{The Awesome Power of Theory}},
  link = "\url{http://www.flownet.com/ron/lambda-calculus.html}",
  year = "2014"
}

\end{chunk}

\index{Hoare, Charles Antony Richard}
\begin{chunk}{axiom.bib}
@article{Hoar71,
  author = "Hoare, Charles Antony Richard",
  title = {{Proof of a Program: FIND}},
  journal = "Communications of the ACM",
  volume = "14",
  number = "1",
  year = "1971",
  abstract =
    "A proof is given of the correctness of the algorithm 'Find.'
    First, an informal description is given of the purpose of the
    program and the method used. A systematic technique is described
    for constructing the program proof during the process of coding
    it, in such a way as to prevent the intrusion of logical
    errors. The prrof of termination is treated as a separate
    exercie. Finally, some conclusions related to general programming
    methodology are drawn.",
  paper = "Hoar71.pdf",
  keywords = "printed"
}

\end{chunk}

\index{Filliatre, Jean-Christophe}
\begin{chunk}{axiom.bib}
@article{Fill07,
  author = "Filliatre, Jean-Christophe",
  title = {{Formal Proof of a Program: FIND}},
  journal = "Science of Computer Programming",
  volume = "64",
  pages = "332-340",
  year = "2007",
  abstract =
    "In 1971, C.A.R. Hoare gave the proof of correctness and
    termination of a rather complex algorithm, in a paper entitled 
    {\sl Proof of a program: Find}. It is a handmade proof, where the
    program is given together with its formal specification and where
    each step is fully justified by mathematical reasoning. We present
    here a formal proof of the same program in the system Coq, using
    the recent tactic of the system developed to establish the total
    correctness of imperative programs. We follow Hoare's paper as
    closely as possible, keeping the same program and the same
    specification. We show that we get exactly the same proof
    obligations, which are proved in a straightforward way, following
    the original paper. We also explain how more informal aspects of
    Hoare's proof are formalized in the system Coq. This demonstrates
    the adequacy of the system Coq in the process of certifying
    imperative programs.",
  paper = "Fill07.pdf",
  keywords = "printed"
}

\end{chunk}

\index{Morris, F.L.}
\index{Jones, C.B.}
\begin{chunk}{axiom.bib}
@article{Morr84,
  author = "Morris, F.L. and Jones, C.B.",
  title = {{An Early Program Proof by Alan Turing}},
  journal = "Annals of the History of Computing",
  volume = "6",
  number = "2",
  year = "1984",
  pages = "139-143",
  abstract =
    "The paper reproduces, with typographical corrections and
    comments, a 1949 paper by Alan Turing that foreshadoes much
    subsequent work in program proving.",
  paper = "Morr84.pdf",
  keywords = "printed"
}

\end{chunk}

\index{Kovacs, Laura}
\begin{chunk}{axiom.bib}
@article{Kova16,
  author = "Kovacs, Laura",
  title = {{Symbolic Computation and Automated Reasoning for Program
            Analysis}},
  journal = "LNCS",
  volume = "9681",
  pages = "20-27",
  year = "2016",
  abstract =
    "This talk describes how a combination of symbolic computation
    techniques with first-order theorem proving can be used for solving
    some challenges of automating program analysis, in particular for
    generating and proving properties about the logically complex parts of
    software. The talk will first present how computer algebra methods,
    such as Gr√∂bner basis computation, quantifier elimination and
    algebraic recurrence solving, help us in inferring properties of
    program loops with non-trivial arithmetic. Typical properties inferred
    by our work are loop invariants and expressions bounding the number of
    loop iterations. The talk will then describe our work to generate
    first-order properties of programs with unbounded data structures,
    such as arrays. For doing so, we use saturation-based first-order
    theorem proving and extend first- order provers with support for
    program analysis. Since program analysis requires reasoning in the
    combination of first-order theories of data structures, the talk
    also discusses new features in first-order theorem proving, such as
    inductive reasoning and built-in boolean sort. These extensions allow
    us to express program properties directly in first-order logic and
    hence use further first-order theorem provers to reason about program
    properties.",
  paper = "Kova16.pdf",
  keywords = "printed"
}

\end{chunk}

\index{Avigad, Jeremy}
\begin{chunk}{axiom.bib}
@misc{Avig17a,
  author = "Avigad, Jeremy",
  title = {{Proof Theory}},
  year = "2017",
  abstract =
    "Proof theory began in the 1920's as part of Hilbert's program,
    which aimed to secrure the foundations of mathematics by modeling
    infinitary mathematics with formal axiomatic systems and proving
    those systems consistent using restricted, finitary means. The
    program thus viewed mathematics as a system of reasoning with
    precise linguistic norms, govenered by rules that can be described
    and studied in concrete terms. Today such a viewpoint has
    applications in mathematics, computer science, and the philosophy
    of mathematics.",
  paper = "Avig17a.pdf",
  keywords = "private communication"
}

\end{chunk}
