books/bookvolbib add references

Goal: Proving Axiom Correct

\begin{chunk}{axiom.bib}
@misc{SCSCP,
  author = "The SCSCP development team",
  title = {{Symbolic Computation Software Composability Protocol}},
  link = "\url{https://gap-packages.github.io/scscp/}",
  year = "2017"
}

\end{chunk}

\index{Gonthier, Georges}
\index{Mahboubi, Assia}
\index{Tassi, Enrico}
\begin{chunk}{axiom.bib}
@techreport{Gont09,
  author = "Gonthier, Georges and Mahboubi, Assia and Tassi, Enrico",
  title = {{A Small Scale Reflection Extension for the Coq System}},
  type = "technical report",
  institution = "Inria Microsoft",
  number = "RR-6455",
  year = "2009",
  abstract =
    "This is the user manual de SSReflect , a set of extensions to the
    proof scripting language of the Coq proof assistant. While these
    extensions were developed to support a particular proof methodology -
    small-scale reflection - most of them actually are of a quite general
    nature, improving the functionality of Coq in basic areas such as
    script layout and structuring, proof context management, and
    rewriting.  Consequently, and in spite of the title of this document,
    most of the extensions described here should be of interest for all
    Coq users, whether they embrace small-scale reflection or not.",
  paper = "Gont09.pdf"

}  

\end{chunk}

\index{Garillot, Francois}
\index{Gonthier, Georges}
\index{Mahboubi, Assia}
\index{Rideau, Laurence}
\begin{chunk}{axiom.bib}
@misc{Gari09,
  author = "Garillot, Francois and Gonthier, Georges and Mahboubi, Assia and
            Rideau, Laurence",
  title = {{Packaging Mathematical Structures}},
  year = "2009",
  abstract =
    "This paper proposes generic design patterns to define and combine
    algebraic structures, using dependent records, coercions and type
    inference, inside the Coq system. This alternative to telescopes in
    particular allows multiple inheritance, maximal sharing of notations
    and theories, and automated structure inference. Our methodology is
    robust enough to support a hierarchy comprising a broad variety of
    algebraic structures, from types with a choice operator to algebraically
    closed fields. Interfaces for the structures enjoy the handiness of a
    classi- cal setting, without requiring any axiom. Finally, we show how
    externally extensible some of these instances are by discussing a
    lemma seminal in defining the discrete logarithm, and a matrix
    decomposition problem.",
  paper = "Gari09.pdf"
}

\end{chunk}

\begin{chunk}{axiom.bib}
@misc{GAPx17,
  author = "The GAP Team",
  title = {{GAP -- Groups, Algorithms, Programming}},
  year = "2017",
  link = "\url{https://www.gap-system.org/}"
}

\end{chunk}

\index{Meindl, Diana}
\begin{chunk}{axiom.bib}
@mastersthesis{Mein13,
  author = "Meindl, Diana",
  title = {{Implementation of an Algorithm Computing the Greatest
            Common Divisor for Multivariate Polynomials}},
  year = "2013",
  school = "RISC Linz"
}    

\end{chunk}

\index{Neuper, Walther}
\begin{chunk}{axiom.bib}
@article{Meup13a,
  author = "Neuper, Walther",
  title = {{On the Emergence of TP-based Educational Math
            Assistants}},
  journal = "The Electronic Journal of Mathematics and Technology",
  volume = "1",
  number = "1",
  year = "2013",
  link = "\url{http://www.ist.tugraz.at/projects/isac/publ/newgen.pdf}",
  abstract =
    "Presently Computer Algebra Systems, Dynamic Geometry Systems and
    Spreadsheets cover most of e-learning in high-school mathematics and
    as well are used for education in formal parts of science.  Recently
    and largely unnoticed in public, the academic discipline of
    interactive and automated Theorem Proving (TP) has become of major
    importance for mathematics and computer science.  
    
    This paper considers the promises of TP technology for education in
    science, technology, engineering and mathematics at the full range of
    levels from high-school to university.
    
    Starting from prototypes of TP-based educational mathematics systems,
    conceptual founda- tions are considered: TP-based software which
    implements reasoning as an essential part of math- ematical thinking
    technology.  Educational objectives for the development of TP-based
    systems are discussed and concluded with some predictions on possible
    impact of TP-based educational mathematics assistants.
    
    The final conclusion suggests to announce the emergence of a new,
    TP-based generation of educational mathematics software.",
  paper = "Neup13a.pdf"
}  

\end{chunk}

\index{Maletzky, Alexander}
\begin{chunk}{axiom.bib}
@techreport{Male17,
  author = "Maletzky, Alexander",
  title = {{A New Reasoning Framework for Theorema 2.0}},
  year = "2017",
  institution = "RISC Linz",
  abstract =
    "We present a new add-on for the Theorema 2.0 proof assistant,
    consisting of a reasoning framework in the spirit of (though not
    exactly as) the well-known LCF approach to theorem proving: a small,
    trusted kernel of basic inferences complemented by an extensive
    collection of automatic and interactive proof methods that construct
    proofs solely in terms of the basic inferences. We explain why such an
    approach is desirable in the first place in Theorema (at least as a
    possible alternative to the existing paradigm), how it fits together
    with the current default set-up of the system, and how proof-checking
    with the inference kernel of the new framework proceeds. Since all
    this is heavily inspired by the Isabelle proof assistant, we in
    particular also highlight the differences between Isabelle and our
    approach.", 
  paper = "Male17.pdf"
}

\end{chunk}

\index{Neuper, Walther}
\begin{chunk}{axiom.bib}
@misc{Neup12,
  author = "Neuper, Walther",
  title = {{Automated Generation of User Guidance by Combining
            Computation and Deduction}},
  year = "2012",
  publisher = "Open Publishing Association",
  pages = "82-101",
  abstract =
    "Herewith, a fairly old concept is published for the first time and
    named ”Lucas Interpretation”. This has been implemented in a
    prototype, which has been proved useful in educational practice and
    has gained academic relevance with an emerging generation of
    educational mathematics assistants (EMA) based on Computer Theorem
    Proving (CTP).  
    
    Automated Theorem Proving (ATP), i.e.  deduction, is
    the most reliable technology used to check user input. However ATP is
    inherently weak in automatically generating solutions for arbitrary
    problems in applied mathematics. This weakness is crucial for EMAs:
    when ATP checks user input as incorrect and the learner gets stuck
    then the system should be able to suggest possible next steps.  
    
    The key idea of Lucas Interpretation is to compute the steps of a
    calculation following a pro- gram written in a novel CTP-based
    programming language, i.e. computation provides the next steps.  User
    guidance is generated by combining deduction and computation: the
    latter is performed by a specific language interpreter, which works
    like a debugger and hands over control to the learner at breakpoints,
    i.e.  tactics generating the steps of calculation.  The interpreter
    also builds up logical contexts providing ATP with the data required
    for checking user input, thus combining computation and deduction.
    
    The paper describes the concepts underlying Lucas Interpretation so
    that open questions can adequately be addressed, and prerequisites for
    further work are provided.",
  paper = "Neup12.pdf"
}

\end{chunk}

\index{Buchberger, Bruno}
\begin{chunk}{axiom.bib}
@article{Buch01,
  author = "Buchberger, Bruno",
  title = {{Theorema: A Proving System Based on Mathematica}},
  journal = "The Mathematica Journal",
  volume = "8",
  number = "2",
  pages = "247-252",
  year = "2001",
  paper = "Buch01.pdf"
}

\end{chunk}

\index{Giese, Martin}
\begin{chunk}{axiom.bib}
@inproceedings{Gies05,
  author = "Giese, Martin",
  title = {{A Calculus for Type Predicates and Type Coercion}},
  booktitle = "A Calculus for Type Predicates and Type Coercion",
  series = "LNAI",
  volume = "3702",
  pages = "123-137",
  isbn = "3540289313",
  abstract =
    "We extend classical first-order logic with subtyping by type
    predicates and type coercion. Type predicates assert that the value of
    a term belongs to a more special type than the signature guarantees,
    while type coercion allows using terms of a more general type where
    the signature calls for a more special one. These operations are
    important e.g. in the specification and verification of
    object-oriented programs. We present a tableau calculus for this logic
    and prove its completeness.",
  paper = "Gies05.pdf"
}

\end{chunk}

\index{Buchberger, Bruno}
\index{Aigner, K.}
\index{Dupre, C.}
\index{Jebelean, T.}
\index{Kriftner, F.}
\index{Marin, M.}
\index{Nakagawa, K.}
\index{Podisor, O.}
\index{Tomuta, E.}
\index{Usenko, Y.}
\index{Vasaru, D.}
\index{Windsteiger, W.}
\begin{chunk}{axiom.bib}
@misc{Buch03,
  author = "Buchberger, Bruno",
  title = {{Theorema: An Integrated System for Computation and
            Deduction in Natural Style}},
  abstract =
    "The Theorema project aims at integrating computation and deduction in
    a system that can be used by the working scientist for build- ing and
    checking mathematical models, including the design and verica- tion of
    new algorithms. Currently, the system uses the rewrite engine of the
    computer algebra system Mathematica for building and combining a
    number of automatic/interactive provers (high-order predicate-logic,
    in- duction for lists/tuples and natural numbers, etc.) in natural
    deduction style and in natural language presentation. These provers
    can be used for dening and proving properties of mathematical models
    and algorithms, while a specially provided \computing engine" can
    execute directly the logical description of these algorithms.",
  paper = "Buch03.pdf"
}

\end{chunk}

\index{Nilsson, Nils J.}
\begin{chunk}{axiom.bib}
@book{Nils76,
  author = "Nilsson, Nils J.",
  title = {{Principles of Artificial Intelligence}},
  publisher = "Morgan Kaufmann",
  year = "1976",
  abstract =
    "A classic introduction to artificial intelligence intended to bridge
    the gap between theory and practice, Principles of Artificial
    Intelligence describes fundamental AI ideas that underlie applications
    such as natural language processing, automatic programming, robotics,
    machine vision, automatic theorem proving, and intelligent data
    retrieval. Rather than focusing on the subject matter of the
    applications, the book is organized around general computational
    concepts involving the kinds of data structures used, the types of
    operations performed on the data structures, and the properties of the
    control strategies used. Principles of Artificial Intelligenceevolved
    from the author's courses and seminars at Stanford University and
    University of Massachusetts, Amherst, and is suitable for text use in
    a senior or graduate AI course, or for individual study."
}

\end{chunk}

\index{Tomuta, E.}
\begin{chunk}{axiom.bib}
@phdthesis{Tomu98,
  author = "Tomuta, E.",
  title = {{Proof Control in the Theorema Project}},
  year = "1998",
  school = "RISC Linz"
}

\end{chunk}

\index{Markov, A.A.}
\begin{chunk}{axiom.bib}
@incollection{Mark62,
  author = "Markov, A.A.",
  title = {{On Constructive Mathematics}},
  booktitle = "Problems of the Constructive Direction in Mathematics:
                Part 2 -- Constructive Mathematical Analysis",
  publisher = "Academy of Science USSR",
  comment = "In Russian",
  link = "\url{http://www.mathnet.ru/links/4fe363fcbbf9aeaad8dc9baed1c7d1c8/tm1756.pdf}",
  year = "1962"
}

\end{chunk}

\index{Kreinovich, Vladik}
\begin{chunk}{axiom.bib}
@misc{Krei14,
  author = "Kreinovich, Vladik",
  title = {{Constructive Mathematics in St. Petersburg, Russia:
            A (Somewhat Subjective) View from Within}},
  link = "\url{}",
  abstract =
    "In the 1970 and 1980s, logic and constructive mathematics were an
    important part of my life; it’s what I defended in my Master’s thesis,
    it was an important part of my PhD dissertation. I was privileged to
    work with the giants. I visited them in their homes. They were who I
    went to for advice.  And this is my story.",
  paper = "Krei14.pdf"
}

\end{chunk}

\index{Windsteiger, Wolfgang}
\begin{chunk}{axiom.bib}
@article{Wind06,
  author = "Windsteiger, Wolfgang",
  title = {{An automated prover for Zermelo-Fraenkel set theory in
            Theorema}},
  journal = "J. of Symbolic Computation",
  volume = "41",
  pages = "435-470",
  year = "2006",
  abstract =
    "This paper presents some fundamental aspects of the design and
    implementation of an automated prover for Zermelo-Fraenkel set theory
    within the Theorema system. The method applies the 
    ``Prove-Compute-Solve'' paradigm as its major strategy for generating
    proofs in a natural style for statements involving constructs from set
    theroy.",
  paper = "Wind06.pdf"
}

\end{chunk}

\index{Schreiner, Wolfgang}
\begin{chunk}{axiom.bib}
@techreport{Schr14,
  author = "Schreiner, Wolfgang",
  title = {{Some Lessons Learned on Writing Predicate Logic Proofs in
           Isabelle/Isar}},
  year = "2014",
  institution = "RISC Linz",
  abstract =
    "We describe our experience with the use of the proving assistant
    Isabelle and its proof development language Isar for formulating and
    proving formal mathematical statements. Our focus is on how to use
    classical predicate logic and well established proof principles for
    this purpose, bypassing Isabelle’s meta-logic and related technical
    aspects as much as possible.  By a small experiment on the proof of
    (part of a) verification condition for a program, we were able to
    identify a number of important patterns that arise in such proofs
    yielding to a workflow with which we feel personally comfortable; the
    resulting guidelines may serve as a starting point for a the
    application of Isabelle / Isar for the “average” mathematical user
    (i.e, a mathematical user who is not interested in Isabelle / Isar per
    se but just wants to use it as a tool for computer-supported formal
    theory development).",
  paper = "Schr14.pdf"
}

\end{chunk}

\index{Paule, Peter}
\begin{chunk}{axiom.bib}
@phdthesis{Paul14,
  author = "Paule, Peter",
  title = {{Complex Variables Visualized}},
  school = "RISC Linz",
  year = "2014",
  link =
  "\url{http://www.risc.jku.at/publications/download/risc_5011/DiplomaThesisPonweiser.pdf}",
  abstract =
    "The aim of this diploma thesis is the visualization of some
    fundamental results in the context of the theory of the modular group
    and modular functions. For this purpose the computer algebra software
    Mathematica is utilized.  

    The thesis is structured in three parts. In
    Chapter 1, we summarize some important basic concepts of group theory
    which are relevant to this work.  Moreover, we introduce obius
    transformations and study their geometric mapping properties. 

    Chapter 2 is devoted to the study of the modular group from an
    algebraic and geometric point of view. We introduce the canonical
    fundamental region which gives rise to the modular tessellation of
    the upper half-plane. Additionally, we present a general method
    for nding fundamental regions with respect to subgroups of the
    modular group based on the concepts of 2-dimensional hyperbolic
    geometry.

    In Chapter 3 we give some concrete examples how the developed results and
    methods can be exploited for the visualization of certain mathematical
    results. Besides the visualization of function graphs of modular
    functions, a particularly nice result is the connection between
    modular transformations and continued fraction expansions.",
  paper = "Paul14.pdf"
}  

\end{chunk}

\index{Khan, Muhammad Taimoor}
\begin{chunk}{axiom.bib}
@techreport{Khan13,
  author = "Khan, Muhammad Taimoor",
  title = {{On the Formal Verification of Maple Programs}},
  year = "2013",
  type = "technical report",
  number = "13-07",
  institution = "RISC Linz",
  abstract =
    "In this paper, we present an example-based demonstration of our 
    recent results on the formal verification of programs written in the
    computer algebra language (Mini)Maple (a slightly modified subset of
    Maple).  The main goal of this work is to develop a verification
    framework for behavioral analysis of MiniMaple programs.  For
    verification, we translate an annotated MiniMaple program into the
    language Why3ML of the intermediate verification tool Why3 developed
    at LRI, France.  We generate verification conditions by the
    corresponding component of Why3 and later prove the correctness of
    these conditions by various supported by the Why3 back-end automatic
    and interactive theorem provers.  We have used the verification
    framework to verify some parts of the main test example of our
    verification framework, the Maple package DifferenceDifferential 
    developed at our institute to compute bivariate difference-differential
    polynomials using relative Gr ̈obner bases.",
  paper = "Khan13.pdf"
}

\end{chunk}

\index{Kryvolap, Andrii}
\index{Nikitchenko, Mykola}
\index{Schreiner, Wolfgang}
\begin{chunk}{axiom.bib}
@inproceedings{Kryv13,
  author = "Kryvolap, Andrii and Nikitchenko, Mykola and Schreiner,
            Wolfgang",
  title = {{Extending Floyd-Hoare Logic for Partial Pre- and
            Postconditions}}, 
  booktitle = "ICTERI 2013: 9th Int. Conf. on ICT in Education,
               Research and Industrial Applications",  
  pages = "0-23",
  publisher = "Springer",
  isbn = "978-3-319-03997-8",
  year = "2014",
  abstract =
    "Traditional (classical) Floyd-Hoare logic is defined for a case of
    total pre- and postconditions while programs can be partial. In the
    chapter we propose to extend this logic for partial conditions. To
    do this we first construct and investigate special program algebras of
    partial predicates, functions, and programs. In such algebras
    program correctness assertions are presented with the help of a
    special composition called Floyd-Hoare composition.  This composition
    is monotone and continuous. Considering the class of constructed
    algebras as a semantic base we then define an extended logic – Partial
    Floyd-Hoare Logic – and investigate its properties. This logic has
    rather complicated soundness constraints for inference rules,
    therefore simpler sufficient constraints are proposed. The logic
    constructed can be used for program verification.",
  paper = "Kryv13.pdf"
}

\end{chunk}

\index{Khan, Muhammad Taimoor}
\begin{chunk}{axiom.bib}
@techreport{Khan12,
  author = "Khan, Muhammad Taimoor",
  title = {{Formal Semantics of MiniMaple}},
  year = "2012",
  type = "technical report",
  number = "12-04",
  institution = "RISC Linz",
  abstract =
    "In this paper, we give the complete definition of a formal
    denotational) semantics of a subset of the language of the
    computer algebra systems Maple which we call MiniMaple .  As a
    next step we will develop a verification calculus for this
    language.  The verification conditions generated by the calculus
    must be sound with respect to the formal semantics.",
  paper = "Khan12.pdf"
}

\end{chunk}

\index{Khan, Muhammad Taimoor}
\begin{chunk}{axiom.bib}
@techreport{Khan12a,
  author = "Khan, Muhammad Taimoor",
  title = {{Formal Semantics of a Specification Language MiniMaple}},
  year = "2012",
  type = "technical report",
  number = "12-05",
  institution = "RISC Linz",
  abstract =
    "In this paper, we give the complete definition of a formal semantics
    of a specification language for MiniMaple.  This paper is an update
    of the previously reported formal (denotational) semantics of
    MiniMaple.  As a next step we will develop a verification calculus
    for MiniMaple and its specification language.  The verification
    conditions generated by the calculus must be sound with respect to
    both the formal semantics of MiniMaple and its corresponding
    specification language.",
  paper = "Khan12a.pdf"
}

\end{chunk}

\index{Khan, Muhammad Taimoor}
\begin{chunk}{axiom.bib}
@article{Khan12b,
  author = "Khan, Muhammad Taimoor",
  title = {{Towards the Formal Semantics and Verification of Maple
            Programs}},
  journal = "LNAI",
  volume = "7362",
  pages = "231-247",
  year = "2012",
  isbn = "978-3-642-31373-8",
  abstract =
    "In this paper, we present our ongoing work and initial results on the
    formal specification and verification of MiniMaple (a substantial
    subset of Maple with slight extensions) programs. The main goal of our
    work is to find behavioral errors in such programs w.r.t. their 
    specifications by static analysis. This task is more complex for widely
    used computer algebra languages like Maple as these are fundamentally
    different from classical languages: they support non-standard types
    of objects such as symbols, unevaluated expressions and polynomials
    and require abstract computer algebraic concepts and objects such as
    rings and orderings etc. As a starting point we have defined and
    formalized a syntax, semantics, type system and specification language
    for MiniMaple.",
  paper = "Khan12b.pdf"
}

\end{chunk}

\index{Khan, Muhammad Taimoor}
\index{Schreiner, Wolfgang}
\begin{chunk}{axiom.bib}
@article{Khan12c,
  author = "Khan, Muhammad Taimoor and Schreiner, Wolfgang",
  title = {{On Formal Specification of Maple Programs}},
  journal = "LNAI",
  volume = "7362",
  pages = "442-446",
  year = "2012",
  isbn = "978-3-642-31373-8",
  abstract =
    "This paper is an example-based demonstration of our initial results
    on the formal specification of programs written in the computer
    algebra language MiniMaple (a substantial subset of Maple with slight
    extensions). The main goal of this work is to define a verification
    framework for MiniMaple. Formal specification of MiniMaple programs
    is rather complex task as it supports non-standard types of objects,
    e.g. symbols and unevaluated expressions, and additional functions
    and predicates, e.g. runtime type tests etc. We have used the
    specification language to specify various computer algebra concepts
    respective objects of the Maple package DifferenceDifferential
    developed at our institute.",
  paper = "Khan12c.pdf"
}

\end{chunk}

\index{Kutsia, Temur}
\index{Marin, Mircea}
\begin{chunk}{axiom.bib}
@techreport{Kuts12,
  author = "Kutsia, Temur and Marin, Mircea",
  title = {{Solving, Reasoning, and Programming in Common Logic}},
  type = "technical report",
  institution = "RISC Linz",
  year = "2012",
  abstract =
    "Common Logic (CL) is a recent ISO standard for exchanging logic-based
    information between disparate computer systems.  Sharing and reasoning
    upon knowledge represented in CL require equation solving over terms
    of this language. We study computationally well-behaved fragments of
    such solving problems and show how they can influence reasoning in CL
    and transformations of CL expressions.",
  paper = "Kuts12.pdf"
}

\end{chunk}

\index{Kutsia, Temur}
\index{Marin, Mircea}
\begin{chunk}{axiom.bib}
@inproceedings{Kuts12a,
  author = "Kutsia, Temur and Marin, Mircea",
  title = {{Solving, Reasoning, and Programming in Common Logic}},
  booktitle = "SYNASC '12",
  isbn = "978-0-7695-4934-7",
  pages = "119-126",
  year = "2012",
  abstract =
    "Common Logic (CL) is a recent ISO standard for exchanging logic-based
    information between disparate computer systems.  Sharing and reasoning
    upon knowledge represented in CL require equation solving over terms
    of this language. We study computationally well-behaved fragments of
    such solving problems and show how they can influence reasoning in CL
    and transformations of CL expressions.",
  paper = "Kuts12a.pdf"
}

\end{chunk}

\index{Erascu, Madalina}
\begin{chunk}{axiom.bib}
@techreport{Eras11,
  author = "Erascu, Madalina",
  title = {{Symbolic Computation and Program Verification. Proving
            Partial Correctness and Synthesizing Optimal Algorithms}}, 
  type = "technical report",
  number = "11-15",
  institution = "RISC Linz",
  year = "2011",
  abstract =
    "We present methods for checking the partial correctness of,
    respectively to optimize, imperative programs, using polynomial
    algebra methods, namely resultant computation and quantifier
    elimination (QE) by cylindrical algebraic decomposition (CAD). The
    result are very promising but also show that there is room for
    improvement of algebraic algorithms.",
  paper = "Eras11.pdf"
}

\end{chunk}

\index{Khan, Muhammad Taimoor}
\begin{chunk}{axiom.bib}
@techreport{Khan11,
  author = "Khan, Muhammad Taimoor",
  title = {{A Type Checker for MiniMaple}},
  type = "technical report",
  number = "11-05",
  year = "2011",
  abstract =
    "In this paper, we present the syntactic definition and the formal type
    system for a substantial subset of the language of the computer
    algebra system Maple, which we call MiniMaple .  The goal of the type
    system is to prevent runtime typing errors by static analysis of the
    source code of MiniMaple programs.  The type system is implemented
    by a type checker, which veries the type correctness of MiniMaple
    programs respectively reports typing errors.",
  paper = "Khan11.pdf"
}

\end{chunk}

\index{Khan, Muhammad Taimoor}
\index{Schreiner, Wolfgang}
\begin{chunk}{axiom.bib}
@inproceedings{Khan11a,
  author = "Khan, Muhammad Taimoor and Schreiner, Wolfgang",
  title = {{Towards a Behavioral Analysis of Computer Algebra
            Programs}},
  booktitle = "NWPT'11",
  pages = "42-44",
  year = "2011",
  paper = "Khan11a.pdf"
}

\end{chunk}

\index{Khan, Muhammad Taimoor}
\begin{chunk}{axiom.bib}
@techreport{Khan11b,
  author = "Khan, Muhammad Taimoor",
  title = {{Towards a Behavioral Analysis of Computer Algebra
            Programs}},
  type = "technical report",
  number = "11-13",
  year = "2011",
  abstract =
    "In this paper, we present our initial results on the behavioral
    analysis of computer algebra programs.  The main goal of our work is
    to find typing and behavioral errors in such programs by static
    analysis of the source code.  This task is more complex for widely
    used computer algebra languages (Maple and Mathematica) as these are
    fundamentally different from classical languages: for example they
    support non-standard types of objects, e.g.  symbols, unevaluated
    expressions, polynomials etc.; moreover they use type information to
    direct the flow of control in the program and have no clear
    difference between declaration and assignment.  For this purpose, we
    have defined the syntax and the formal type system for a substantial
    subset of the computer algebra language Maple, which we call MiniMaple.
    The type system is implemented by a type checker, which verifies
    the type correctness and respectively reports typing errors.  We have
    applied the type checker to the Maple package DifferenceDifferential
    developed at our institute.  Currently we are working on a formal
    specification language of MiniMaple and the specification of this
    package.  The specification language will be used to find errors in
    computer algebra programs with respect to their specifications.",
  paper = "Khan11b.pdf"
}

\end{chunk}

\index{Erascu, Madalina}
\index{Jebelean, Tudor}
\begin{chunk}{axiom.bib}
@inproceedings{Eras10,
  author = "Erascu, Madalina and Jebelean, Tudor",
  title = {{A Purely Logical Approach to Program Termination}},
  booktitle = "11th Int. Workshop on Termination",
  year = "2010",
  comment = "Extended Abstract",
  link =
  "\url{http://www.risc.jku.at/publications/download/risc_4089/ErascuJebeleanWSTFinal.pdf}",
  paper = "Eras10.pdf"
}

\end{chunk}

\index{Erascu, Madalina}
\index{Jebelean, Tudor}
\begin{chunk}{axiom.bib}
@techreport{Eras10a,
  author = "Erascu, Madalina and Jebelean, Tudor",
  title = {{A Purely Logical Approach to Imperative Program Verification}},
  year = "2010",
  institution = "RISC Linz",
  type = "technical report",
  number = "10-07",
  link =
  "\url{http://www.risc.jku.at/publications/download/risc_4088/techRep.pdf}",
  paper = "Eras10a.pdf"
}

\end{chunk}

\index{Erascu, Madalina}
\index{Jebelean, Tudor}
\begin{chunk}{axiom.bib}
@inproceedings{Eras10b,
  author = "Erascu, Madalina and Jebelean, Tudor",
  title = {{A Purely Logical Approach to Termination of Imperative Loops}},
  booktitle = "Proc. 12th Int. Symp. on SYmbolic and Numeric
               Algorithms for Scientific Computing",
  pages = "142-149",
  year = "2010",
  link = "\url{http://www.risc.jku.at/publications/download/risc_4181/synasc_postproceedings.pdf}",
  abstract =
    "We present and illustrate a method for the gen- eration of the
    termination conditions for nested loops with abrupt termination
    statements.  The conditions are (first-order) formulae obtained by
    certain transformations of the program text.  The loops are treated
    similarly to calls of recursively defined functions.  The program text
    is analyzed on all possible execution paths by forward symbolic
    execution using certain meta-level functions which define the syntax,
    the semantics, the verification conditions for the partial
    correctness, and the termination conditions. The termination
    conditions are expressed as induction principles, however, still in
    first-order logic.  

    Our approach is simpler than others because we use
    neither an additional model for program execution, nor a fixpoint
    theory for the definition of program semantics.  Because the
    meta-level functions are fully formalized in predicate logic, it is
    possible to prove in a purely logical way and at object level that the
    verification conditions are necessary and sufficient for the existence
    and uniqueness of the function implemented by the program.",
  paper = "Eras10b.pdf"
}

\end{chunk}

\index{Vajda, Robert}
\index{Jebelean, Tudor}
\index{Buchberger, Bruno}
\begin{chunk}{axiom.bib}
@article{Vajd09,
  author = "Vajda, Robert and Jebelean, Tudor and Buchberger, Bruno",
  title = {{Combining Logical and Algebraic Techniques for Matural
            Style Proving in Elementary Analysis}},
  journal = "Mathematics and Computers in SImulation",
  volume = "79",
  number = "8",
  pages = "2310-2316",
  year = "2009",
  link = 
    "\url{http://www.risc.jku.at/publications/download/risc_3320/acafin3.pdf}",
  abstract =
    "PCS (Proving-Computing-Solving) [Buchberber 2001] and S-Decomposition
    [Jebelean 2001] are strategies for handling proof problems by
    combining logic inference steps (e.g. modus ponens, Skolemization,
    instantiation) with rewriting steps (application of definitions) and
    solving procedures based on algebraic techniques (e.g. Groebner Bases,
    Cylindrical Algebraic Decomposition).
    
    If one formalizes the main notions of elementary analysis like
    continuity, convergence, etc., usually a sequence of alternating
    quantifier blocks pops up in the quantifier prefix of the
    corresponding formula. This makes the proof problems involving these
    notions not easy. S-Decomposition strategy is expecially suitable for
    property-preserving problems like continuity of sum, becuase it is
    designed for handling problems where the goal and the main assumptions
    have a similar structure. During proof deduction, existentially
    quantified goals and universal assumptions are handled by introducing
    metavariables, if no suitable ground instance is known in
    adva=nce. For finalizing proof attempts, the metavariables should be
    instantiated in such a way that they satisfy the cumulated algebraic
    constraints collected during the proof attempt. The instantiation
    problem is considered to be difficult in the logical
    calculus. Appropriate instances can be often found using quantifier
    elimination (QE) over real closed fields. In order to obtain witness
    terms we utilize the QE method based on cylindrical algebraic
    decomposition (CAD) [Collins 1975]. However, the QE method alone is
    not sufficient. One needs to pre-process the (closed, quantified)
    conjectured formula and post-process the resulting CAD-structure after
    the call of the QE algorithm.",
  paper = "Vajd09.pdf"
}

\end{chunk}

\index{Mayrhofer, Gunther}
\begin{chunk}{axiom.bib}
@phdthsis{Mayr09,
  author = "Mayrhofer, Gunther",
  title = {{Symbolic COmputation Prover with Induction}},
  year = "2009",
  link =
    "\url{http://www.risc.jku.at/publications/download/risc_3910/Thesis.pdf}",
  institution = "RISC Linz",
  abstract =
    "An important task in automated theorem proving is computing with
    "arbitrary but fixed" constants. This kind of highschool proving
    occurs in the main part of most proofs. The current master's thesis
    presents an automated prover that focuses on such computations with
    symbols. The prover uses equalities and equivalences in the knowledge
    base to rewrite a goal formula. In all formulae there may be universal
    quantifiers and some selected logical connectives. Special syntax
    elements support case distinctions and sequence variables. The prover
    uses a specialized method for proving equalities and an important
    feature is proving by cases. An extension allows induction over some
    predefined domains. Additionally to the prover implementation in
    Mathematica, there is a tracer that prints a protocol of the proof
    flow. Since the code for this tracer is separated from the prover,
    there may be more than one tracer with different output. But more
    important is that a user can inspect the code of prover without being
    confused by technical details for generating some nice output. The
    main motivation for this prover is a new extension of the Theorema
    system. The aim is an environment for defining new prover in the same
    language as theorems. The advantage is clear, existing prover may
    prove facts of a new one, for example the correctness. Using this it
    is possible to build up a hierarchy of formally checked provers. For
    such reasoning about reasoners a starting point needs induction on the
    structure of terms and formulae. A first prover in the hierarchy will
    need computations with symbols in many proof branches. This may be
    done by the current Symbolic Computation Prover.",
  paper = "Mayr09.pdf",
}

\end{chunk}

\index{Popov, Nikolaj}
\index{Jebelean, Tudor}
\begin{chunk}{axiom.bib}
@inproceedings{Popo09,
  author = "Popov, Nikolaj and Jebelean, Tudor",
  title = {{Functional Program Verification in Theorema Soundness and
           Completeness}},
  booktitle = "Proc. 15th Biennial Workshop on Programmiersprachen und
               Grundlagen der Programmierung KPS'09",
  year = "2009",
  pages = "221-229",
  link = 
    "\url{http://www.risc.jku.at/publications/download/risc_3913/PopJeb.pdf}",
  abstract =
    "We present a method for verifying recursive functional pro- grams. We
    define a Verification Condition Generator (VCG) which covers the most
    frequent types of recursive programs. These programs may op- erate on
    arbitrary domains. Soundness and Completeness of the VCG are proven on
    the meta level, and this provides a warranty that any system based on
    our results will be sound.",
  paper = "Popo09.pdf"
}

\end{chunk}

\index{Popov, Nikolaj}
\index{Jebelean, Tudor}
\begin{chunk}{axiom.bib}
@inproceedings{Popo09a,
  author = "Popov, Nikolaj and Jebelean, Tudor",
  title = {{A Complete Method for Algorithm Validation}},
  booktitle = 
    "Proc. Workshop on Automated Math Theory Exploration AUTOMATHEO'09",
  pages = "21-25",
  year = "2009",
  link = "\url{http://www.risc.jku.at/publications/download/risc_3915/PopJeb-AUTOMATHEO.pdf}",
  abstract =
    "We present some novel ideas for proving total correctness of
    recursive functional programs and we discuss how they may be used for
    algorithm validation.  As usual, correctness (validation) is
    transformed into a set of first-order predicate logic
    formulae—verification conditions.  As a distinctive feature of our
    method, these formulae are not only sufficient, but also necessary
    for the correctness. We demonstrate our method on the Nevilles
    algorithm for polynomial interpolation and show how it may be
    validated automatically. In fact, even if a small part of the
    specification is missing—in the literature this is often a case --
    the correctness cannot be proven. Furthermore, a relevant 
    counterexample may be constructed automatically.",
  paper = "Popo99a.pdf"
}

\end{chunk}

\index{Schreiner, Wolfgang}
\begin{chunk}{axiom.bib}
@techreport{Schr09,
  author = "Schreiner, Wolfgang",
  title = {{How to Write Postconditions with Nultiple Cases}},
  year = "2009",
  institution = "RISC Linz",
  abstract =
    "We investigate and compare the two major styles of writing program
    function postconditions with multiple cases: as conjunctions of
    implications or as disjunctions of conjunctions. We show that both
    styles not only have different syntax but also different semantics and
    pragmatics and give recommendations for their use.",
  paper = "Schr09.pdf"
}

\end{chunk}

\index{Buchberger,B}
\index{Craciun, A.}
\index{Jebelean, T.}
\index{Kovacs, L.}
\index{Kutsia, T.}
\index{Nakagawa, K.}
\index{Piroi, F.}
\index{Popov, N.}
\index{Robu, J.}
\index{Rosenkranz, M.}
\index{Windsteiger, W.}
\begin{chunk}{axiom.bib}
@article{Buch06,
  author = "Buchberger,B and Craciun, A. and Jebelean, T. and 
            Kovacs, L. and Kutsia, T. and Nakagawa, K. and Piroi, F.
            and Popov, N. and Robu, J. and Rosenkranz, M. and
            Windsteiger, W.",
  title = {{Theorema: Towards Computer-Aided Mathematical Theory
            Exploration}}, 
  journal = "J. of Applied Logic",
  volume = "4",
  number = "4",
  pages = "470-504",
  year = "2006",
  abstract =
    "Theorema is a project that aims at supporting the entire process of
    mathematical theory exploration within one coherent logic and software
    system. This survey paper illustrates the style of Theorema-supported
    mathematical theory exploration by a case study (the automated
    synthesis of an algorithm for the construction of Groebner Bases) and
    gives an overview on some reasoners and organizational tools for
    theory exploration developed in the Theorema project.",
  paper = "Buch06.pdf"
}

\end{chunk}

\index{Abraham, Erika}
\index{Abbott, John}
\index{Becker, Bernd}
\index{Bigatti, Anna M.}
\index{Brain, Martin}
\index{Buchberger, Bruno}
\index{Cimatti, Alessandro}
\index{Davenport, James H.}
\index{England, Matthew}
\index{Fontaine, Pascal}
\index{Forrest, Stephen}
\index{Griggio, Alberto}
\index{Kroenig, Daniel}
\index{Seiler, Werner M.}
\index{Sturm, Thomas}
\begin{chunk}{axiom.bib}
@misc{Abra16,
  author = "Abraham, Erika and Abbott, John and Becker, Bernd and
            Bigatti, Anna M. and Brain, Martin and Buchberger, Bruno
            and Cimatti, Alessandro and Davenport, James H. and
            England, Matthew and Fontaine, Pascal and Forrest, Stephen
            and Griggio, Alberto and Kroenig, Daniel and 
            Seiler, Werner M. and Sturm, Thomas",
  title = {{Satisfiability Checking meesg Symbolic Computation}},
  year = "2016",
  link = "\url{http://arxiv.org/abs/1607.08028}",
  abstract =
    "Symbolic Computation and Satisfiability Checking are two research
    areas, both having their individual scientific focus but sharing also
    common interests in the development, implementation and application of
    decision procedures for arithmetic theories. Despite their
    commonalities, the two communities are rather weakly connected. The
    aim of our newly accepted SC-square project (H2020-FETOPEN-CSA) is to
    strengthen the connection between these communities by creating common
    platforms, initiating interaction and exchange, identifying common
    challenges, and developing a common roadmap from theory along the way
    to tools and (industrial) applications. In this paper we report on the
    aims and on the first activities of this project, and formalise some
    relevant challenges for the unified SC-square community.",
  paper = "Abra16.pdf"
}

\end{chunk}

\index{Buchberger, Bruno}
\index{Jebelean, Tudor}
\index{Kutsia, Temur}
\index{Maletzky, Alexander}
\index{Windsteiger, Wolfgang}
\begin{chunk}{axiom.bib}
@article{Buch16,
  author = "Buchberger, Bruno and Jebelean, Tudor and Kutsia, Temur
           and Maletzky, Alexander and Windsteiger, Wolfgang",
  title = {{Theorema 2.0: Computer-Assisted Natural-Style Mathematics}},
  journal = "J. of Formalized Reasoning",
  volume = "9",
  number = "1",
  pages = "149-155",
  year = "2016",
  abstract =
    "The Theorema project aims at the development of a computer assistant
    for the working mathematician. Support should be given throughout all
    phases of mathematical activity, from introducing new mathematical
    concepts by definitions or axioms, through first (computational)
    experiments, the formulation of theorems, their justification by an
    exact proof, the application of a theorem as an algorithm, until to
    the dissemination of the results in form of a mathematical
    publication, the build up of bigger libraries of certified
    mathematical content and the like. This ambitious project is exactly
    along the lines of the QED manifesto issued in 1994 and it was
    initiated in the mid-1990s by Bruno Buchberger. The Theorema system is
    a computer implementation of the ideas behind the Theorema
    project. One focus lies on the natural style of system input (in form
    of definitions, theorems, algorithms, etc.), system output (mainly in
    form of mathematical proofs) and user interaction. Another focus is
    theory exploration, i.e. the development of large consistent
    mathematical theories in a formal frame, in contrast to just proving
    single isolated theorems. When using the Theorema system, a user
    should not have to follow a certain style of mathematics enforced by
    the system (e.g. basing all of mathematics on set theory or certain
    variants of type theory), rather should the system support the user in
    her preferred flavour of doing math. The new implementation of the
    system, which we refer to as Theorema 2.0, is open-source and
    available through GitHub.",
  paper = "Buch16.pdf"
}

\end{chunk}
