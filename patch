books/bookvolbib Add Nguy16 on Higher-order symbolic execution

Goal: Proving Axiom Correct

@article{Nguy16,
  author = "Nguyen, Phuc C. and Tobin-Hochstadt, Sam and van Horn, David",
  title = "Higher-order symbolic execution for contract verification and
           refutation",
  url = "http://arxiv.org/pdf/1507.04817v2.pdf",
  year = "2016",
  month = "February",
  paper = "Nguy16.pdf",
  abstract =
    "We present a new approach to automated reasoning about higher-order
    programs by endowing symbolic execution with a notion of higher-order,
    symbolic values.

    To validate our approach, we use it to develop and evaluate a system
    for verifying and refuting behavioral software contracts of components
    in a functional language, which we call {\sl soft contract
    verification}. In doing so, we discover a mutually beneficial relation
    between behavioral contracts and higher-order symbolic
    execution. Contracts aid symbolic execution by providing a rich
    language of specifications that can serve as the basis of symbolic
    higher-order values; the theory of blame enables modular verification
    and leads to the theorem that {\sl verified compnents can't be
    blamed}; and the run-time monitoring of contracts enables {\sl soft}
    verification whereby verified and unverified components can safely
    interact and verification is not an all-or-nothing
    proposition. Conversely, symbolic execution aids contracts by
    providing compile-time verification which increases assurance and
    enables optimizations; automated test-case generation for contracts
    with counter-examples; and engendering a virtuous cycle between
    verification and the gradual spread of contracts.

    Our system uses higher-order symbolic execution, leveraging contracts
    as a source of symbolic values including unknown behavioral values,
    and employs an updatable heap of contract invariants to reason about
    flow-sensitive facts. Whenever a contract is refuted, it reports a
    concrete {\sl counterexample} reproducing the error, which may involve
    solving for an unknown function. The approach is able to analyze
    first-class contracts, recursive data structures, unknown functions,
    and control-flow-sensitive refinement of values, which are all
    idiomatic in dynamic languages. It makes effective use of an
    off-the-shelf solver to decide problems without heavy encodings. Our
    counterexample search is sound and relatively complete with respect to
    a first-order solver for base type values. Therefore, it can form the
    basis of automated verification and bug-finding tools for higher-order
    programs. The approach is competitive with a wide range of existing
    tools -- including type systems, flow analyzers, and model checkers --
    on their own benchmarks. We have built a tool which analyzes programs
    written in Racket, and report on its effectiveness in verifying and
    refuting contracts."
}
