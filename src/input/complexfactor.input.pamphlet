\documentclass{article}
\usepackage{axiom}
\setlength{\textwidth}{400pt}
\begin{document}
\title{\$SPAD/src/input complexfactor.input}
\author{Timothy Daly}
\maketitle
\begin{abstract}
Example of factoring polynomials over the complex rational numbers
along with an example of modemap searching.
\end{abstract}
\eject
\tableofcontents
\eject
\begin{chunk}{*}
)set break resume
)sys rm -r complexfactor.output
)spool complexfactor.output
)set message test on
)set message auto off
)clear all
)set message bottomup on

--S 1 of 4
t1:=-7*x^6 + 10*x^4 + 24*x^3 - 14*x^2 - 27*x - 42 + _
     %i*(3*x^6 - 9*x^5 + 30*x^4 + 15*x^3 + 17*x*2 - 33*x -7)
--R 
--R
--R Function Selection for ^
--R      Arguments: (VARIABLE(x),PI) 
--R      Default target type: Polynomial(Integer) 
--R   -> no appropriate ** found in Variable(x) 
--R   -> no appropriate ** found in PositiveInteger 
--R   -> no appropriate ** found in Symbol 
--R   -> no appropriate ** found in Integer 
--R   -> no appropriate ** found in Polynomial(Integer) 
--R   -> no appropriate ** found in Variable(x) 
--R   -> no appropriate ** found in PositiveInteger 
--R   -> no appropriate ** found in Symbol 
--R   -> no appropriate ** found in Integer 
--Rcost=50000 for **: (Polynomial(Integer),NonNegativeInteger) -> Polynomial(Integer)
--Rcost=50000 for **: (Polynomial(Integer),PositiveInteger) -> Polynomial(Integer)
--R   -> no appropriate ^ found in Variable(x) 
--R   -> no appropriate ^ found in PositiveInteger 
--R   -> no appropriate ^ found in Symbol 
--R   -> no appropriate ^ found in Integer 
--R   -> no appropriate ^ found in Polynomial(Integer) 
--R   -> no appropriate ^ found in Variable(x) 
--R   -> no appropriate ^ found in PositiveInteger 
--R   -> no appropriate ^ found in Symbol 
--R   -> no appropriate ^ found in Integer 
--Rcost=50000 for ^: (Polynomial(Integer),NonNegativeInteger) -> Polynomial(Integer)
--Rcost=50000 for ^: (Polynomial(Integer),PositiveInteger) -> Polynomial(Integer)
--R 
--R [1]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [2]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R [3]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [4]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R 
--R
--R Function Selection for *
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for -
--R      Arguments: POLY(INT) 
--R 
--R [1]  signature:   POLY(INT) -> POLY(INT)
--R      implemented: slot $$ from POLY(INT)
--R 
--R
--R Function Selection for ^
--R      Arguments: (VARIABLE(x),PI) 
--R      Default target type: Polynomial(Integer) 
--R 
--R [1]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [2]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R [3]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [4]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R 
--R
--R Function Selection for *
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for +
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for ^
--R      Arguments: (VARIABLE(x),PI) 
--R      Default target type: Polynomial(Integer) 
--R 
--R [1]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [2]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R [3]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [4]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R 
--R
--R Function Selection for *
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for +
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for ^
--R      Arguments: (VARIABLE(x),PI) 
--R      Default target type: Polynomial(Integer) 
--R 
--R [1]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [2]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R [3]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [4]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R 
--R
--R Function Selection for *
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for -
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for *
--R      Arguments: (PI,VARIABLE(x)) 
--R   -> no appropriate * found in PositiveInteger 
--R   -> no appropriate * found in Variable(x) 
--R   -> no appropriate * found in Integer 
--R   -> no appropriate * found in Symbol 
--R   -> no appropriate * found in Polynomial(Integer) 
--R   -> no appropriate * found in PositiveInteger 
--R   -> no appropriate * found in Variable(x) 
--R   -> no appropriate * found in Integer 
--R   -> no appropriate * found in Symbol 
--Rcost=52300 for *: (Integer,Polynomial(Integer)) -> Polynomial(Integer)
--Rcost=52300 for *: (Integer,Polynomial(Integer)) -> Polynomial(Integer)
--Rcost=52300 for *: (NonNegativeInteger,Polynomial(Integer)) -> Polynomial(Integer)
--Rcost=92300 for *: (Polynomial(Integer),Polynomial(Integer)) -> Polynomial(Integer)
--Rcost=52300 for *: (PositiveInteger,Polynomial(Integer)) -> Polynomial(Integer)
--R 
--R [1]  signature:   (INT,POLY(INT)) -> POLY(INT)
--R      implemented: slot $(Integer)$ from POLY(INT)
--R [2]  signature:   (INT,POLY(INT)) -> POLY(INT)
--R      implemented: slot $(Integer)$ from POLY(INT)
--R [3]  signature:   (NNI,POLY(INT)) -> POLY(INT)
--R      implemented: slot $(NonNegativeInteger)$ from POLY(INT)
--R [4]  signature:   (PI,POLY(INT)) -> POLY(INT)
--R      implemented: slot $(PositiveInteger)$ from POLY(INT)
--R [5]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for -
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for -
--R      Arguments: (POLY(INT),PI) 
--R   -> no appropriate - found in Polynomial(Integer) 
--R   -> no appropriate - found in PositiveInteger 
--R   -> no appropriate - found in Integer 
--R   -> no appropriate - found in PositiveInteger 
--R   -> no appropriate - found in Integer 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for complex
--R      Arguments: (NNI,PI) 
--R   -> no appropriate complex found in NonNegativeInteger 
--R   -> no appropriate complex found in PositiveInteger 
--R   -> no appropriate complex found in Integer 
--R   -> no appropriate complex found in NonNegativeInteger 
--R   -> no appropriate complex found in PositiveInteger 
--R   -> no appropriate complex found in Integer 
--R
--R Modemaps from Associated Packages 
--R   no modemaps
--R
--R Remaining General Modemaps 
--R   [1] (D1,D1) -> D from D if D has COMPCAT(D1) and D1 has COMRING
--R 
--R [1]  signature:   (INT,INT) -> COMPLEX(INT)
--R      implemented: slot $(Integer)(Integer) from COMPLEX(INT)
--R 
--R
--R Function Selection for ^
--R      Arguments: (VARIABLE(x),PI) 
--R      Default target type: Polynomial(Integer) 
--R 
--R [1]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [2]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R [3]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [4]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R 
--R
--R Function Selection for *
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for ^
--R      Arguments: (VARIABLE(x),PI) 
--R      Default target type: Polynomial(Integer) 
--R 
--R [1]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [2]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R [3]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [4]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R 
--R
--R Function Selection for *
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for -
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for ^
--R      Arguments: (VARIABLE(x),PI) 
--R      Default target type: Polynomial(Integer) 
--R 
--R [1]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [2]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R [3]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [4]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R 
--R
--R Function Selection for *
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for +
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for ^
--R      Arguments: (VARIABLE(x),PI) 
--R      Default target type: Polynomial(Integer) 
--R 
--R [1]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [2]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R [3]  signature:   (POLY(INT),NNI) -> POLY(INT)
--R      implemented: slot $$(NonNegativeInteger) from POLY(INT)
--R [4]  signature:   (POLY(INT),PI) -> POLY(INT)
--R      implemented: slot $$(PositiveInteger) from POLY(INT)
--R 
--R
--R Function Selection for *
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for +
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for *
--R      Arguments: (PI,VARIABLE(x)) 
--R 
--R [1]  signature:   (INT,POLY(INT)) -> POLY(INT)
--R      implemented: slot $(Integer)$ from POLY(INT)
--R [2]  signature:   (INT,POLY(INT)) -> POLY(INT)
--R      implemented: slot $(Integer)$ from POLY(INT)
--R [3]  signature:   (NNI,POLY(INT)) -> POLY(INT)
--R      implemented: slot $(NonNegativeInteger)$ from POLY(INT)
--R [4]  signature:   (PI,POLY(INT)) -> POLY(INT)
--R      implemented: slot $(PositiveInteger)$ from POLY(INT)
--R [5]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for *
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for +
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for *
--R      Arguments: (PI,VARIABLE(x)) 
--R 
--R [1]  signature:   (INT,POLY(INT)) -> POLY(INT)
--R      implemented: slot $(Integer)$ from POLY(INT)
--R [2]  signature:   (INT,POLY(INT)) -> POLY(INT)
--R      implemented: slot $(Integer)$ from POLY(INT)
--R [3]  signature:   (NNI,POLY(INT)) -> POLY(INT)
--R      implemented: slot $(NonNegativeInteger)$ from POLY(INT)
--R [4]  signature:   (PI,POLY(INT)) -> POLY(INT)
--R      implemented: slot $(PositiveInteger)$ from POLY(INT)
--R [5]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for -
--R      Arguments: (POLY(INT),POLY(INT)) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for -
--R      Arguments: (POLY(INT),PI) 
--R 
--R [1]  signature:   (POLY(INT),POLY(INT)) -> POLY(INT)
--R      implemented: slot $$$ from POLY(INT)
--R 
--R
--R Function Selection for *
--R      Arguments: (COMPLEX(INT),POLY(INT)) 
--R   -> no appropriate * found in Complex(Integer) 
--R   -> no appropriate * found in Polynomial(Integer) 
--R   -> no appropriate * found in Polynomial(Complex(Integer)) 
--R   -> no appropriate * found in Complex(Integer) 
--R   -> no appropriate * found in Polynomial(Integer) 
--Rcost=43300 for *: (Complex(Integer),Polynomial(Complex(Integer))) -> Polynomial(Complex(Integer))
--Rcost=83300 for *: (Polynomial(Complex(Integer)),Polynomial(Complex(Integer))) -> Polynomial(Complex(Integer))
--R 
--R [1]  signature:   (COMPLEX(INT),POLY(COMPLEX(INT))) -> POLY(COMPLEX(INT))
--R      implemented: slot $(Complex (Integer))$ from POLY(COMPLEX(INT))
--R [2]  signature:   (POLY(COMPLEX(INT)),POLY(COMPLEX(INT))) -> POLY(COMPLEX(INT))
--R      implemented: slot $$$ from POLY(COMPLEX(INT))
--R 
--R
--R Function Selection for map by coercion facility (map) 
--R      Arguments: ((INT -> COMPLEX(INT)),POLY(INT)) 
--R      Target type: POLY(COMPLEX(INT)) 
--R   -> no appropriate map found in Polynomial(Integer) 
--R   -> no appropriate map found in Polynomial(Complex(Integer)) 
--R   -> no appropriate map found in Complex(Integer) 
--R   -> no appropriate map found in Integer 
--R   -> no appropriate map found in Complex(Integer) 
--R
--R Modemaps from Associated Packages 
--R   [1] ((D4 -> D5),D3) -> D1
--R            from UnivariatePolynomialCategoryFunctions2(D4,D3,D5,D1)
--R            if D4 has RING and D5 has RING and D1 has UPOLYC(D5) and D3
--R            has UPOLYC(D4)
--R   [2] ((D5 -> D7),UnivariatePolynomial(D4,D5)) -> UnivariatePolynomial
--R            (D6,D7)
--R            from UnivariatePolynomialFunctions2(D4,D5,D6,D7)
--R            if D4: SYMBOL and D5 has RING and D7 has RING and D6: 
--R            SYMBOL
--R   [3] ((D4 -> D5),SparseUnivariatePolynomial(D4)) -> 
--R            SparseUnivariatePolynomial(D5)
--R            from SparseUnivariatePolynomialFunctions2(D4,D5)
--R            if D4 has RING and D5 has RING
--R   [4] ((D4 -> D5),Polynomial(D4)) -> Polynomial(D5)
--R            from PolynomialFunctions2(D4,D5) if D4 has RING and D5 has 
--R            RING
--R 
--R [1]  signature:   ((INT -> COMPLEX(INT)),POLY(INT)) -> POLY(COMPLEX(INT))
--R      implemented: slot (Polynomial (Complex (Integer)))(Mapping (Complex (Integer)) (Integer))(Polynomial (Integer)) from POLY2(INT,COMPLEX(INT))
--R 
--R
--R Function Selection for +
--R      Arguments: (POLY(INT),POLY(COMPLEX(INT))) 
--R   -> no appropriate + found in Polynomial(Integer) 
--R   -> no appropriate + found in Polynomial(Complex(Integer)) 
--R   -> no appropriate + found in Polynomial(Integer) 
--R 
--R [1]  signature:   (POLY(COMPLEX(INT)),POLY(COMPLEX(INT))) -> POLY(COMPLEX(INT))
--R      implemented: slot $$$ from POLY(COMPLEX(INT))
--R 
--R
--R Function Selection for map by coercion facility (map) 
--R      Arguments: ((INT -> COMPLEX(INT)),POLY(INT)) 
--R      Target type: POLY(COMPLEX(INT)) 
--R 
--R [1]  signature:   ((INT -> COMPLEX(INT)),POLY(INT)) -> POLY(COMPLEX(INT))
--R      implemented: slot (Polynomial (Complex (Integer)))(Mapping (Complex (Integer)) (Integer))(Polynomial (Integer)) from POLY2(INT,COMPLEX(INT))
--R 
--R
--R   (1)
--R                 6        5               4               3      2
--R     (- 7 + 3%i)x  - 9%i x  + (10 + 30%i)x  + (24 + 15%i)x  - 14x
--R   + 
--R     (- 27 + %i)x - 42 - 7%i
--R                                           Type: Polynomial(Complex(Integer))
--E 1

--S 2 of 4
t2:=factor t1
--R 
--R
--R Function Selection for factor
--R      Arguments: POLY(COMPLEX(INT)) 
--R   -> no appropriate factor found in Polynomial(Complex(Integer)) 
--R   -> no appropriate factor found in Polynomial(Complex(Integer)) 
--R
--R Modemaps from Associated Packages 
--R   no modemaps
--R
--R Remaining General Modemaps 
--R   [1] D -> Factored(D) from D if D has UFD
--R   [2] D2 -> Factored(D2) from SAERationalFunctionAlgFactor(D3,D4,D2)
--R            if D3 has UPOLYC(FRAC(POLY(INT))) and D4 has Join(Field,
--R            CharacteristicZero,MonogenicAlgebra(Fraction(Polynomial(
--R            Integer)),D3)) and D2 has UPOLYC(D4)
--R   [3] D2 -> Factored(D2) from SimpleAlgebraicExtensionAlgFactor(D3,D4,
--R            D2)
--R            if D3 has UPOLYC(FRAC(INT)) and D4 has Join(Field,
--R            CharacteristicZero,MonogenicAlgebra(Fraction(Integer),D3)) 
--R            and D2 has UPOLYC(D4)
--R   [4] D2 -> Factored(D2) from RationalFunctionFactor(D2)
--R            if D2 has UPOLYC(FRAC(POLY(INT)))
--R   [5] SparseUnivariatePolynomial(D6) -> Factored(
--R            SparseUnivariatePolynomial(D6))
--R            from MultivariateFactorize(D3,D4,D5,D6)
--R            if D3 has ORDSET and D4 has OAMONS and D5 has Join(
--R            EuclideanDomain,CharacteristicZero) and D6 has POLYCAT(D5,
--R            D4,D3)
--R   [6] D2 -> Factored(D2) from MultivariateFactorize(D3,D4,D5,D2)
--R            if D3 has ORDSET and D4 has OAMONS and D5 has Join(
--R            EuclideanDomain,CharacteristicZero) and D2 has POLYCAT(D5,
--R            D4,D3)
--R   [7] D2 -> Factored(D2) from MPolyCatRationalFunctionFactorizer(D3,D4
--R            ,D5,D2)
--R            if D3 has OAMONS and D4 has OrderedSet with 
--R               convert : % -> Symboland D5 has INTDOM and D2 has 
--R            POLYCAT(FRAC(POLY(D5)),D3,D4)
--R   [8] SparseUnivariatePolynomial(D6) -> Factored(
--R            SparseUnivariatePolynomial(D6))
--R            from MultFiniteFactorize(D3,D4,D5,D6)
--R            if D3 has ORDSET and D4 has OAMONS and D5 has FFIELDC and 
--R            D6 has POLYCAT(D5,D4,D3)
--R   [9] D2 -> Factored(D2) from MultFiniteFactorize(D3,D4,D5,D2)
--R            if D3 has ORDSET and D4 has OAMONS and D5 has FFIELDC and 
--R            D2 has POLYCAT(D5,D4,D3)
--R   [10] Complex(Integer) -> Factored(Complex(Integer))
--R            from GaussianFactorizationPackage
--R   [11] D2 -> Factored(D2)
--R            from FiniteFieldFactorizationWithSizeParseBySideEffect(D3,
--R            D2)
--R            if D3 has FFIELDC and D2 has UPOLYC(D3)
--R   [12] D2 -> Factored(D2) from DistinctDegreeFactorize(D3,D2)
--R            if D3 has FFIELDC and D2 has UPOLYC(D3)
--R   [13] D2 -> Factored(D2) from ComplexFactorization(D3,D2)
--R            if D3 has EUCDOM and D2 has UPOLYC(COMPLEX(D3))
--R   [14] D2 -> Factored(D2) from AlgFactor(D2) if D2 has UPOLYC(AN)
--R   -> no appropriate map found in Complex(Integer) 
--R   -> no appropriate map found in Integer 
--R   -> no appropriate map found in Complex(Polynomial(Integer)) 
--R   -> no appropriate map found in Polynomial(Integer) 
--R   -> no appropriate map found in Integer 
--R   -> no appropriate map found in Polynomial(Integer) 
--R
--R Modemaps from Associated Packages 
--R   [1] ((D4 -> D5),Complex(D4)) -> Complex(D5) from ComplexFunctions2(
--R            D4,D5)
--R            if D4 has COMRING and D5 has COMRING
--Rcost=54500 for factor: Expression(Complex(Integer)) -> Factored(Expression(Complex(Integer)))
--Rcost=14500 for factor: Polynomial(Complex(Integer)) -> Factored(Polynomial(Complex(Integer)))
--Rcost=55500 for factor: SparseUnivariatePolynomial(Polynomial(Complex(Integer))) -> Factored(SparseUnivariatePolynomial(Polynomial(Complex(Integer))))
--R 
--R [1]  signature:   POLY(COMPLEX(INT)) -> FR(POLY(COMPLEX(INT)))
--R      implemented: slot (Factored (Polynomial (Complex (Integer))))(Polynomial (Complex (Integer))) from MULTFACT(SYMBOL,INDE(SYMBOL),COMPLEX(INT),POLY(COMPLEX(INT)))
--R [2]  signature:   EXPR(COMPLEX(INT)) -> FR(EXPR(COMPLEX(INT)))
--R      implemented: slot (Factored $)$ from EXPR(COMPLEX(INT))
--R [3]  signature:   SUP(POLY(COMPLEX(INT))) -> FR(SUP(POLY(COMPLEX(INT))))
--R      implemented: slot (Factored (SparseUnivariatePolynomial (Polynomial (Complex (Integer)))))(SparseUnivariatePolynomial (Polynomial (Complex (Integer)))) from MULTFACT(SYMBOL,INDE(SYMBOL),COMPLEX(INT),POLY(COMPLEX(INT)))
--R 
--R
--R   (2)
--R     %i
--R  *
--R                 6     5               4               3         2
--R       (3 + 7%i)x  - 9x  + (30 - 10%i)x  + (15 - 24%i)x  + 14%i x  + (1 + 27%i)x
--R     + 
--R       - 7 + 42%i
--R                                 Type: Factored(Polynomial(Complex(Integer)))
--E 2

--S 3 of 4
t3:=factors t2
--R 
--R
--R Function Selection for factors
--R      Arguments: FR(POLY(COMPLEX(INT))) 
--R 
--R [1]  signature:   FR(POLY(COMPLEX(INT))) -> LIST(Record(factor: POLY(COMPLEX(INT)),exponent: INT))
--R      implemented: slot (List (Record (: factor (Polynomial (Complex (Integer)))) (: exponent (Integer))))$ from FR(POLY(COMPLEX(INT)))
--R 
--R
--R   (3)
--R   [
--R     [
--R       factor =
--R                     6     5               4               3         2
--R           (3 + 7%i)x  - 9x  + (30 - 10%i)x  + (15 - 24%i)x  + 14%i x
--R         + 
--R           (1 + 27%i)x - 7 + 42%i
--R       ,
--R      exponent= 1]
--R     ]
--R   Type: List(Record(factor: Polynomial(Complex(Integer)),exponent: Integer))
--E 3

--S 4 of 4
t4:=unit t2
--R 
--R
--R Function Selection for unit
--R      Arguments: FR(POLY(COMPLEX(INT))) 
--R 
--R [1]  signature:   FR(POLY(COMPLEX(INT))) -> POLY(COMPLEX(INT))
--R      implemented: slot (Polynomial (Complex (Integer)))$ from FR(POLY(COMPLEX(INT)))
--R 
--R
--R   (4)  %i
--R                                           Type: Polynomial(Complex(Integer))
--E 4

)spool
)lisp (bye)
 
\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
