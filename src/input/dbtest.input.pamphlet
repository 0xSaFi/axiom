\documentclass{article}
\setlength{\textwidth}{400pt}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/input algaggr.input}
\author{Timothy Daly}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{verbatim}
Building A Query Facility

We now turn to an entirely different kind of application,
building a query language for a database.

Here is the practical problem to solve.  The hyperdoc facility of
Axiom has a database for all operations and constructors which is
stored on disk and accessed by Hyperdoc.  For our purposes here, we
regard each line of this file as having eight fields:
\begin{itemize}
\item class
\item name
\item type
\item nargs
\item exposed
\item kind
\item origin
\item condition
\end{itemize}

\begin{chunk}{*}
\getchunk{ug13.ht}
\end{chunk}

Here is an example entry:

begin{verbatim}
  o`determinant`$->R`1`x`d`Matrix(R)`has(R,commutative("*"))
end{verbatim}

In English, the entry means that the operation 
begin{verbatim}
  determinant: $ -> R 
end{verbatim}
with it 1 argument, is exposed and is exported by the domain
Matrix(R) if R has commutative("*").

Our task is to create a little query language that allows us
to get useful information from this database.

First we design a simple language for accessing information from the
database.  We have the following simple model in mind for its design.
Think of the database as a box of index cards.  There is only one
search operation---it takes the name of a field and a predicate (a
boolean-valued function) defined on the fields of the index cards.
When applied, the search operation goes through the entire box
selecting only those index cards for which the predicate is true.  The
result of a search is a new box of index cards.  This process can be
repeated again and again.

The predicates all have a particularly simple form: 
begin{verbatim}
  symbol = pattern
end{verbatim}
where symbol designates one of the fields, and pattern is a 
``search string''---a string that may contain a ``*'' as a
wildcard. Wildcards match any substring, including the empty string.
Thus the pattern ``*ma*t'' matches ``mat'', ``doormat'' and ``smart''.

To illustrate how queries are given, we give you a sneak preview
of the facility we are about to create.

Extract the database of all Axiom operations.
begin{verbatim}
  ops := getDatabase("o")
end{verbatim}

How many exposed three-argument ``map'' operations involving streams?
begin{verbatim}
  ops.(name="map").(nargs="3").(type="*Stream*")
end{verbatim}

As usual, the arguments of elt associate to the left.
The first elt produces the set of all operations with
name {\tt map}.
The second elt produces the set of all map operations
with three arguments.
The third elt produces the set of all three-argument map
operations having a type mentioning Stream.

Another thing we'd like to do is to extract one field from each of
the index cards in the box and look at the result.
Here is an example of that kind of request.

What constructors explicitly export a determinant operation?

elt(elt(elt(elt(ops,name="determinant"),origin),sort),unique)


The first elt produces the set of all index cards with
name {\tt determinant}.
The second elt extracts the {\tt origin} component from
each index card. Each origin component
is the name of a constructor which directly
exports the operation represented by the index card.
Extracting a component from each index card produces what we call
a {\it datalist}.
The third elt, {\tt sort}, causes the datalist of
origins to be sorted in alphabetic
order.
The fourth, {\tt unique}, causes duplicates to be removed.

Before giving you a more extensive demo of this facility,
we now build the necessary domains and packages to implement it.
%We will introduce a few of our minor conveniences.

\endscroll
\autobuttons
\end{page}

\begin{patch}{ugDomainsQueryLanguagePagePatch1}
\begin{paste}{ugDomainsQueryLanguagePageFull1}
{ugDomainsQueryLanguagePageEmpty1}
\pastebutton{ugDomainsQueryLanguagePageFull1}{\hidepaste}
\tab{5}\spadcommand{ops := getDatabase("o")\bound{o1 }}
\indentrel{3}begin{verbatim}
   (1)  6315
                               Type: Database IndexCard
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsQueryLanguagePageEmpty1}
\begin{paste}{ugDomainsQueryLanguagePageEmpty1}
{ugDomainsQueryLanguagePagePatch1}
\pastebutton{ugDomainsQueryLanguagePageEmpty1}{\showpaste}
\tab{5}\spadcommand{ops := getDatabase("o")\bound{o1 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsQueryLanguagePagePatch2}
\begin{paste}{ugDomainsQueryLanguagePageFull2}
{ugDomainsQueryLanguagePageEmpty2}
\pastebutton{ugDomainsQueryLanguagePageFull2}{\hidepaste}
\tab{5}
\spadcommand{ops.(name="map").(nargs="3").(type="*Stream*")
\bound{o2 }\free{o1 }}
\indentrel{3}begin{verbatim}
   (2)  3
                               Type: Database IndexCard
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsQueryLanguagePageEmpty2}
\begin{paste}{ugDomainsQueryLanguagePageEmpty2}
{ugDomainsQueryLanguagePagePatch2}
\pastebutton{ugDomainsQueryLanguagePageEmpty2}{\showpaste}
\tab{5}
\spadcommand{ops.(name="map").(nargs="3").(type="*Stream*")
\bound{o2 }\free{o1 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsQueryLanguagePagePatch3}
\begin{paste}{ugDomainsQueryLanguagePageFull3}
{ugDomainsQueryLanguagePageEmpty3}
\pastebutton{ugDomainsQueryLanguagePageFull3}{\hidepaste}
\tab{5}
\spadcommand{elt(elt(elt(elt(ops,name="determinant"),origin),sort),unique)
\free{o1 }}
\indentrel{3}begin{verbatim}
   (3)
   ["InnerMatrixLinearAlgebraFunctions",
    "MatrixCategory", "MatrixLinearAlgebraFunctions",
    "SquareMatrixCategory"]
                                  Type: DataList String
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsQueryLanguagePageEmpty3}
\begin{paste}{ugDomainsQueryLanguagePageEmpty3}
{ugDomainsQueryLanguagePagePatch3}
\pastebutton{ugDomainsQueryLanguagePageEmpty3}{\showpaste}
\tab{5}
\spadcommand{elt(elt(elt(elt(ops,name="determinant"),origin),sort),unique)
\free{o1 }}
\end{paste}\end{patch}

@
\pagehead{ugDomainsDatabaseConstructorPage}{ug13.ht}
{The Database Constructor}
\begin{chunk}{ug13.ht}
\begin{page}{ugDomainsDatabaseConstructorPage}
{13.13.2. The Database Constructor}
\beginscroll

We work from the top down. First, we define a database,
our box of index cards, as an abstract datatype.
For sake of illustration and generality,
we assume that an index card is some type S, and
that a database is a box of objects of type S.
Here is the Axiom program defining the \pspadtype{Database}
domain.

\beginImportant
  
\noindent
{\tt 1.\ \ \ PI\ ==>\ PositiveInteger}\newline
{\tt 2.\ \ \ Database(S):\ Exports\ ==\ Implementation\ where}\newline
{\tt 3.\ \ \ \ \ S:\ Object\ with\ }\newline
{\tt 4.\ \ \ \ \ \ \ elt:\ (\$,\ Symbol)\ ->\ String}\newline
{\tt 5.\ \ \ \ \ \ \ display:\ \$\ ->\ Void}\newline
{\tt 6.\ \ \ \ \ \ \ fullDisplay:\ \$\ ->\ Void}\newline
{\tt 7.\ \ \ }\newline
{\tt 8.\ \ \ \ \ Exports\ ==\ with}\newline
{\tt 9.\ \ \ \ \ \ \ elt:\ (\$,QueryEquation)\ ->\ \$}\newline
{\tt 10.\ \ \ \ \ \ elt:\ (\$,\ Symbol)\ ->\ DataList\ String}\newline
{\tt 11.\ \ \ \ \ \ "+":\ (\$,\$)\ ->\ \$}\newline
{\tt 12.\ \ \ \ \ \ "-":\ (\$,\$)\ ->\ \$}\newline
{\tt 13.\ \ \ \ \ \ display:\ \$\ ->\ Void}\newline
{\tt 14.\ \ \ \ \ \ fullDisplay:\ \$\ ->\ Void}\newline
{\tt 15.\ \ \ \ \ \ fullDisplay:\ (\$,PI,PI)\ ->\ Void}\newline
{\tt 16.\ \ \ \ \ \ coerce:\ \$\ ->\ OutputForm}\newline
{\tt 17.\ \ \ \ Implementation\ ==\ add}\newline
{\tt 18.\ \ \ \ \ \ \ \ ...}\newline
\endImportant

The domain constructor takes a parameter S, which
stands for the class of index cards.
We describe an index card later.
Here think of an index card as a string which has
the eight fields mentioned above.

First, we tell Axiom what operations we are going to require
from index cards.
We need an elt to extract the contents of a field
(such as {\tt name} and {\tt type}) as a string.
For example, c.name returns a string that is the content of the
name field on the index card c.
We need to display an index card in two ways:
\pspadfun{display} shows only the name and type of an
operation;
\pspadfun{fullDisplay} displays all fields.
The display operations return no useful information and thus have
return type Void.

Next, we tell Axiom what operations the user can apply
to the database.
This part defines our little query language.
The most important operation is
{\frenchspacing\tt db . field = pattern} which
returns a new database, consisting of all index
cards of {\tt db} such that the field part of the index
card is matched by the string pattern called pattern.
The expression {\tt field = pattern} is an object of type
QueryEquation (defined in the next section).

Another elt is needed to produce a DataList object.
Operation + is to merge two databases together;
- is used to subtract away common entries in a second
database from an initial database.
There are three display functions.
The \pspadfun{fullDisplay} function has two versions: one
that prints all the records, the other that prints only a fixed
number of records.
A coerce to OutputForm creates a display object.

The {\tt Implementation} part of Database is straightforward.
\beginImportant
  
\noindent
{\tt 1.\ \ \ \ \ Implementation\ ==\ add}\newline
{\tt 2.\ \ \ \ \ \ \ s:\ Symbol}\newline
{\tt 3.\ \ \ \ \ \ \ Rep\ :=\ List\ S}\newline
{\tt 4.\ \ \ \ \ \ \ elt(db,equation)\ ==\ ...}\newline
{\tt 5.\ \ \ \ \ \ \ 
elt(db,key)\ ==\ [x.key\ for\ x\ in\ db]::DataList(String)}\newline
{\tt 6.\ \ \ \ \ \ \ 
display(db)\ ==\ \ for\ x\ in\ db\ repeat\ display\ x}\newline
{\tt 7.\ \ \ \ \ \ \ 
fullDisplay(db)\ ==\ for\ x\ in\ db\ repeat\ fullDisplay\ x}\newline
{\tt 8.\ \ \ \ \ \ \ 
fullDisplay(db,\ n,\ m)\ ==\ for\ x\ in\ db\ for\ i\ in\ 1..m}\newline
{\tt 9.\ \ \ \ \ \ \ \ \ repeat}\newline
{\tt 10.\ \ \ \ \ \ \ \ \ \ if\ i\ >=\ n\ then\ fullDisplay\ x}\newline
{\tt 11.\ \ \ \ \ \ x+y\ ==\ removeDuplicates!\ merge(x,y)}\newline
{\tt 12.\ \ \ \ \ \ x-y\ ==\ mergeDifference(copy(x::Rep),}\newline
{\tt 13.\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
y::Rep)\$MergeThing(S)}\newline
{\tt 14.\ \ \ \ \ \ coerce(db):\ OutputForm\ ==\ (\#db)::\ OutputForm}
\newline
\endImportant

The database is represented by a list of elements of S 
(index cards).
We leave the definition of the first elt operation
(on line 4) until the next section.
The second elt collects all the strings with field name
{\it key} into a list.
The display function and first fullDisplay function
simply call the corresponding functions from S.
The second fullDisplay function provides an efficient way of
printing out a portion of a large list.
The + is defined by using the existing
\spadfunFrom{merge}{List} operation defined on lists, then
removing duplicates from the result.
The - operation requires writing a corresponding
subtraction operation.
A package MergeThing (not shown) provides this.

The coerce function converts the database to an
OutputForm by computing the number of index cards.
This is a good example of the independence of
the representation of an Axiom object from how it presents
itself to the user. We usually do not want to look at a database---but
do care how many ``hits'' we get for a given query.
So we define the output representation of a database to be simply
the number of index cards our query finds.
\endscroll
\autobuttons
\end{page}

\end{chunk}
\pagehead{ugDomainsQueryEquationsPage}{ug13.ht}{Query Equations}
\begin{chunk}{ug13.ht}
\begin{page}{ugDomainsQueryEquationsPage}{13.13.3. Query Equations}
\beginscroll

The predicate for our search is given by an object of type
\pspadtype{QueryEquation}.
Axiom does not have such an object yet so we
have to invent it.

\beginImportant
  
\noindent
{\tt 1.\ \ \ QueryEquation():\ Exports\ ==\ Implementation\ where}\newline
{\tt 2.\ \ \ \ \ Exports\ ==\ with}\newline
{\tt 3.\ \ \ \ \ \ \ equation:\ (Symbol,\ String)\ ->\ \$}\newline
{\tt 4.\ \ \ \ \ \ \ variable:\ \$\ ->\ Symbol}\newline
{\tt 5.\ \ \ \ \ \ \ value:\\ \\ \\ \\ \$\ ->\ String}\newline
{\tt 6.\ \ \ }\newline
{\tt 7.\ \ \ \ \ Implementation\ ==\ add}\newline
{\tt 8.\ \ \ \ \ \ \ Rep\ :=\ Record(var:Symbol,\ val:String)}\newline
{\tt 9.\ \ \ \ \ \ \ equation(x,\ s)\ ==\ [x,\ s]}\newline
{\tt 10.\ \ \ \ \ \ variable\ q\ ==\ q.var}\newline
{\tt 11.\ \ \ \ \ \ value\\ \\ \\ \\ q\ ==\ q.val}\newline
\endImportant

Axiom converts an input expression of the form
{\it a} = {\it b} to equation({\it a, b}}.
Our equations always have a symbol on the left and a string
on the right.
The {\tt Exports} part thus specifies an operation
equation to create a query equation, and
\pspadfun{variable} and \pspadfun{value} to select the left- and
right-hand sides.
The {\tt Implementation} part uses \pspadtype{Record} for a
space-efficient representation of an equation.

Here is the missing definition for the elt function of
\pspadtype{Database} in the last section:

\beginImportant
  
\noindent
{\tt 1.\ \ \ \ \ \ \ elt(db,eq)\ ==}\newline
{\tt 2.\ \ \ \ \ \ \ \ \ field\\ \ :=\ variable\ eq}\newline
{\tt 3.\ \ \ \ \ \ \ \ \ value\ :=\ value\ eq}\newline
{\tt 4.\ \ \ \ \ \ \ \ \ 
[x\ for\ x\ in\ db\ |\ matches?(value,x.field)]}\newline
\endImportant

Recall that a database is represented by a list.
Line 4 simply runs over that list collecting all elements
such that the pattern (that is, value)
matches the selected field of the element.

\endscroll
\autobuttons
\end{page}

\end{chunk}
\pagehead{ugDomainsDataListsPage}{ug13.ht}{DataLists}
\begin{chunk}{ug13.ht}
\begin{page}{ugDomainsDataListsPage}{13.13.4. DataLists}
\beginscroll

Type \pspadtype{DataList} is a new type invented to hold the result
of selecting one field from each of the index cards in the box.
It is useful to make datalists extensions of lists---lists that
have special elt operations defined on them for
sorting and removing duplicates.

\beginImportant
  
\noindent
{\tt 1.\ \ \ DataList(S:OrderedSet)\ :\ Exports\ ==\ 
Implementation\ where}\newline
{\tt 2.\ \ \ \ \ Exports\ ==\ ListAggregate(S)\ with}\newline
{\tt 3.\ \ \ \ \ \ \ elt:\ (\$,"unique")\ ->\ \$}\newline
{\tt 4.\ \ \ \ \ \ \ elt:\ (\$,"sort")\ ->\ \$}\newline
{\tt 5.\ \ \ \ \ \ \ elt:\ (\$,"count")\ ->\ NonNegativeInteger}\newline
{\tt 6.\ \ \ \ \ \ \ coerce:\ List\ S\ ->\ \$}\newline
{\tt 7.\ \ \ }\newline
{\tt 8.\ \ \ \ \ Implementation\ ==\ \ List(S)\ add}\newline
{\tt 9.\ \ \ \ \ \ \ Rep\ :=\ List\ S}\newline
{\tt 10.\ \ \ \ \ \ elt(x,"unique")\ ==\ removeDuplicates(x)}\newline
{\tt 11.\ \ \ \ \ \ elt(x,"sort")\ ==\ sort(x)}\newline
{\tt 12.\ \ \ \ \ \ elt(x,"count")\ ==\ \#x}\newline
{\tt 13.\ \ \ \ \ \ coerce(x:List\ S)\ ==\ x\ ::\ \$}\newline
\endImportant

The {\tt Exports} part asserts that datalists belong to the
category ListAggregate.
Therefore, you can use all the usual list operations on datalists,
such as \spadfunFrom{first}{List}, \spadfunFrom{rest}{List}, and
\spadfunFrom{concat}{List}.
In addition, datalists have four explicit operations.
Besides the three elt operations, there is a
coerce operation that creates datalists from lists.

The {\tt Implementation} part needs only to define four functions.
All the rest are obtained from List(S).

\endscroll
\autobuttons
\end{page}

\end{chunk}
\pagehead{ugDomainsDatabasePage}{ug13.ht}{Index Cards}
\begin{chunk}{ug13.ht}
\begin{page}{ugDomainsDatabasePage}{13.13.5. Index Cards}
\beginscroll

An index card comes from a file as one long string.  We define
functions that extract substrings from the long string.  Each field
has a name that is passed as a second argument to elt.

\beginImportant
  
\noindent
{\tt 1.\ \ \ IndexCard()\ ==\ Implementation\ where}\newline
{\tt 2.\ \ \ \ \ Exports\ ==\ with}\newline
{\tt 3.\ \ \ \ \ \ \ elt:\ (\$,\ Symbol)\ ->\ String}\newline
{\tt 4.\ \ \ \ \ \ \ display:\ \$\ ->\ Void}\newline
{\tt 5.\ \ \ \ \ \ \ fullDisplay:\ \$\ ->\ Void}\newline
{\tt 6.\ \ \ \ \ \ \ coerce:\ String\ ->\ \$}\newline
{\tt 7.\ \ \ \ \ Implementation\ ==\ String\ add\ ...}\newline
\endImportant

We leave the {\tt Implementation} part to the reader.
All operations involve straightforward string manipulations.

\endscroll
\autobuttons
\end{page}

\end{chunk}
\pagehead{ugDomainsCreatingPage}{ug13.ht}{Creating a Database}
\begin{chunk}{ug13.ht}
\begin{page}{ugDomainsCreatingPage}{13.13.6. Creating a Database}
\beginscroll

We must not forget one important operation: one that builds the
database in the first place!  We'll name it \pspadfun{getDatabase} and
put it in a package.  This function is implemented by calling the
\Lisp{} function getBrowseDatabase(s) to get appropriate
information from \Browse{}.  This operation takes a string indicating
which lines you want from the database: "o" gives you all
operation lines, and "k", all constructor lines.  Similarly,
"c", "d", and "p" give you all category,
domain and package lines respectively.

\beginImportant
  
\noindent
{\tt 1.\ \ \ OperationsQuery():\ Exports\ ==\ Implementation\ where}
\newline
{\tt 2.\ \ \ \ \ Exports\ ==\ with}\newline
{\tt 3.\ \ \ \ \ \ \ getDatabase:\ String\ ->\ Database(IndexCard)}
\newline
{\tt 4.\ \ \ }\newline
{\tt 5.\ \ \ \ \ Implementation\ ==\ add}\newline
{\tt 6.\ \ \ \ \ \ \ getDatabase(s)\ ==\ getBrowseDatabase(s)\$Lisp}
\newline
\endImportant

We do not bother creating a special name for databases of index
cards.
\pspadtype{Database (IndexCard)} will do.
Notice that we used the package \pspadtype{OperationsQuery} to
create, in effect,
a new kind of domain: \pspadtype{Database(IndexCard)}.

\endscroll
\autobuttons
\end{page}

\end{chunk}
\pagehead{ugDomainsPuttingPage}{ug13.ht}{Putting It All Together}
\begin{chunk}{ug13.ht}
\begin{page}{ugDomainsPuttingPage}{13.13.7. Putting It All Together}
\beginscroll

To create the database facility, you put all these constructors
into one file.\footnote{You could use separate files, but we
are putting them all together because, organizationally, that is
the logical thing to do.}
At the top of the file put \spadcmd{)abbrev} commands, giving the
constructor abbreviations you created.

\beginImportant
  
\noindent
{\tt 1.\ \ \ )abbrev\ domain\ \ ICARD\ \ \ IndexCard}\newline
{\tt 2.\ \ \ )abbrev\ domain\ \ QEQUAT\ \ QueryEquation}\newline
{\tt 3.\ \ \ )abbrev\ domain\ \ MTHING\ \ MergeThing}\newline
{\tt 4.\ \ \ )abbrev\ domain\ \ DLIST\ \ \ DataList}\newline
{\tt 5.\ \ \ )abbrev\ domain\ \ DBASE\ \ \ Database}\newline
{\tt 6.\ \ \ )abbrev\ package\ OPQUERY\ OperationsQuery}\newline
\endImportant

With all this in {\bf alql.spad}, for example, compile it using
begin{verbatim}
)compile alql
end{verbatim}
and then load each of the constructors:
begin{verbatim}
)load ICARD QEQUAT MTHING DLIST DBASE OPQUERY
end{verbatim}
You are ready to try some sample queries.

\endscroll
\autobuttons
\end{page}

\end{chunk}
\pagehead{ugDomainsExamplesPage}{ug13.ht}{Example Queries}
\begin{chunk}{ug13.ht}
\begin{page}{ugDomainsExamplesPage}{13.13.8. Example Queries}
\beginscroll

Our first set of queries give some statistics on constructors in
the current Axiom system.

\xtc{
How many constructors does Axiom have?
}{
\spadpaste{ks := getDatabase "k"\bound{q1}}
}
\xtc{
Break this down into the number of categories, domains, and packages.
}{
\spadpaste{[ks.(kind=k) for k in ["c","d","p"]]\bound{q3}\free{q1}}
}
\xtc{
What are all the domain constructors that take no parameters?
}{
\spadpaste{elt(ks.(kind="d").(nargs="0"),name)\bound{q4}\free{q1}}
}
\xtc{
How many constructors have ``Matrix'' in their name?
}{
\spadpaste{mk := ks.(name="*Matrix*")\bound{q5}\free{q1}}
}
\xtc{
What are the names of those that are domains?
}{
\spadpaste{elt(mk.(kind="d"),name)\bound{q6}\free{q5}}
}
\xtc{
How many operations are there in the library?
}{
\spadpaste{o := getDatabase "o"\bound{o1}}
}
\xtc{
Break this down into categories, domains, and packages.
}{
\spadpaste{[o.(kind=k) for k in ["c","d","p"]]\free{o1}}
}

The query language is helpful in getting information about a
particular operation you might like to apply.
While this information can be obtained with
\Browse{}, the use of the query database gives you data that you
can manipulate in the workspace.

\xtc{
How many operations have ``eigen'' in the name?
}{
\spadpaste{eigens := o.(name="*eigen*")\bound{eigens}\free{o1}}
}
\xtc{
What are their names?
}{
\spadpaste{elt(eigens,name)\free{eigens}}
}
\xtc{
Where do they come from?
}{
\spadpaste{elt(elt(elt(eigens,origin),sort),unique) \free{eigens}}
}

The operations + and - are useful for
constructing small databases and combining them.
However, remember that the only matching you can do is string
matching.
Thus a pattern such as {\tt "*Matrix*"} on the type field
matches
any type containing Matrix, MatrixCategory, SquareMatrix, and so on.

\xtc{
How many operations mention ``Matrix'' in their type?
}{
\spadpaste{tm := o.(type="*Matrix*")\bound{x10}\free{o1}}
}
\xtc{
How many operations come from constructors with ``Matrix'' in
their name?
}{
\spadpaste{fm := o.(origin="*Matrix*")\bound{x11}\free{o1}}
}
\xtc{
How many operations are in fm but not in tm?
}{
\spadpaste{fm-tm \bound{x12}\free{x10 x11}}
}
\xtc{
Display the operations that both mention ``Matrix'' in their type
and come from a constructor having ``Matrix'' in their name.
}{
\spadpaste{fullDisplay(fm-\%) \bound{x13}\free{x12}}
}
\xtc{
How many operations involve matrices?
}{
\spadpaste{m := tm+fm \bound{x14}\free{x10 x11}}
}
\xtc{
Display 4 of them.
}{
\spadpaste{fullDisplay(m, 202, 205) \free{x14}}
}
\xtc{
How many distinct names of operations involving matrices are there?
}{
\spadpaste{elt(elt(elt(m,name),unique),count) \free{x14}}
}

\endscroll
\autobuttons
\end{page}

\begin{patch}{ugDomainsExamplesPagePatch1}
\begin{paste}{ugDomainsExamplesPageFull1}{ugDomainsExamplesPageEmpty1}
\pastebutton{ugDomainsExamplesPageFull1}{\hidepaste}
\tab{5}\spadcommand{ks := getDatabase "k"\bound{q1 }}
\indentrel{3}begin{verbatim}
   (1)  1067
                               Type: Database IndexCard
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty1}
\begin{paste}{ugDomainsExamplesPageEmpty1}{ugDomainsExamplesPagePatch1}
\pastebutton{ugDomainsExamplesPageEmpty1}{\showpaste}
\tab{5}\spadcommand{ks := getDatabase "k"\bound{q1 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch2}
\begin{paste}{ugDomainsExamplesPageFull2}{ugDomainsExamplesPageEmpty2}
\pastebutton{ugDomainsExamplesPageFull2}{\hidepaste}
\tab{5}\spadcommand{[ks.(kind=k) for k in ["c","d","p"]]\bound{q3 }\free{q1 }}
\indentrel{3}begin{verbatim}
   (2)  [205,393,469]
                          Type: List Database IndexCard
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty2}
\begin{paste}{ugDomainsExamplesPageEmpty2}{ugDomainsExamplesPagePatch2}
\pastebutton{ugDomainsExamplesPageEmpty2}{\showpaste}
\tab{5}\spadcommand{[ks.(kind=k) for k in ["c","d","p"]]\bound{q3 }\free{q1 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch3}
\begin{paste}{ugDomainsExamplesPageFull3}{ugDomainsExamplesPageEmpty3}
\pastebutton{ugDomainsExamplesPageFull3}{\hidepaste}
\tab{5}\spadcommand{elt(ks.(kind="d").(nargs="0"),name)\bound{q4 }\free{q1 }}
\indentrel{3}begin{verbatim}
   (3)
   ["AlgebraicNumber", "AnonymousFunction", "Any",
    "AttributeButtons", "BasicFunctions",
    "BasicOperator", "BinaryExpansion", "BinaryFile",
    "Bits", "Boolean", "CardinalNumber",
    "CharacterClass", "Character", "Color", "Commutator",
    "DecimalExpansion", "DoubleFloat", "DrawOption",
    "Exit", "ExtAlgBasis", "FileName", "Float",
    "FortranCode", "FortranScalarType",
    "FortranTemplate", "FortranType", "GraphImage",
    "HexadecimalExpansion", "IVBaseColor", "IVBasicNode",
    "IVCoordinate3", "IVCoordinate4", "IVFaceSet",
    "IVField", "IVGroup", "IVIndexedLineSet",
    "IVNodeConnection", "IVNodeObject", "IVPointSet",
    "IVQuadMesh", "IVSeparator", "IVSimpleInnerNode",
    "IVUtilities", "IVValue", "IndexCard",
    "InnerAlgebraicNumber", "InputForm", "Integer",
    "IntegrationFunctionsTable", "InventorDataSink",
    "InventorRenderPackage", "InventorViewPort",
    "Library", "MachineComplex", "MachineFloat",
    "MachineInteger",
    "NagDiscreteFourierTransformInterfacePackage",
    "NagEigenInterfacePackage",
    "NagOptimisationInterfacePackage",
    "NagQuadratureInterfacePackage", "NagResultChecks",
    "NagSpecialFunctionsInterfacePackage",
    "NonNegativeInteger", "None",
    "NumericalIntegrationProblem", "NumericalODEProblem",
    "NumericalOptimizationProblem",
    "NumericalPDEProblem", "ODEIntensityFunctionsTable",
    "OrdSetInts", "OutputForm", "Palette", "Partition",
    "Pi", "PlaneAlgebraicCurvePlot", "Plot3D", "Plot",
    "PositiveInteger", "QueryEquation", "RenderTools",
    "Result", "RomanNumeral", "RoutinesTable",
    "SExpression", "ScriptFormulaFormat",
    "SingleInteger", "SingletonAsOrderedSet", "String",
    "SubSpaceComponentProperty", "Switch", "SymbolTable",
    "Symbol", "TexFormat", "TextFile", "TheSymbolTable",
    "ThreeDimensionalViewport", "Timer",
    "TwoDimensionalViewport", "Void",
    "d01TransformFunctionType", "d01ajfAnnaType",
    "d01akfAnnaType", "d01alfAnnaType", "d01amfAnnaType",
    "d01anfAnnaType", "d01apfAnnaType", "d01aqfAnnaType",
    "d01asfAnnaType", "d01fcfAnnaType", "d01gbfAnnaType",
    "d02bbfAnnaType", "d02bhfAnnaType", "d02cjfAnnaType",
    "d02ejfAnnaType", "d03eefAnnaType", "d03fafAnnaType",
    "e04dgfAnnaType", "e04fdfAnnaType", "e04gcfAnnaType",
    "e04jafAnnaType", "e04mbfAnnaType", "e04nafAnnaType",
    "e04ucfAnnaType"]
                                  Type: DataList String
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty3}
\begin{paste}{ugDomainsExamplesPageEmpty3}{ugDomainsExamplesPagePatch3}
\pastebutton{ugDomainsExamplesPageEmpty3}{\showpaste}
\tab{5}\spadcommand{elt(ks.(kind="d").(nargs="0"),name)\bound{q4 }\free{q1 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch4}
\begin{paste}{ugDomainsExamplesPageFull4}{ugDomainsExamplesPageEmpty4}
\pastebutton{ugDomainsExamplesPageFull4}{\hidepaste}
\tab{5}\spadcommand{mk := ks.(name="*Matrix*")\bound{q5 }\free{q1 }}
\indentrel{3}begin{verbatim}
   (4)  26
                               Type: Database IndexCard
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty4}
\begin{paste}{ugDomainsExamplesPageEmpty4}{ugDomainsExamplesPagePatch4}
\pastebutton{ugDomainsExamplesPageEmpty4}{\showpaste}
\tab{5}\spadcommand{mk := ks.(name="*Matrix*")\bound{q5 }\free{q1 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch5}
\begin{paste}{ugDomainsExamplesPageFull5}{ugDomainsExamplesPageEmpty5}
\pastebutton{ugDomainsExamplesPageFull5}{\hidepaste}
\tab{5}\spadcommand{elt(mk.(kind="d"),name)\bound{q6 }\free{q5 }}
\indentrel{3}begin{verbatim}
   (5)
   ["DenavitHartenbergMatrix",
    "DirectProductMatrixModule", "IndexedMatrix",
    "LieSquareMatrix", "Matrix", "RectangularMatrix",
    "SquareMatrix", "ThreeDimensionalMatrix"]
                                  Type: DataList String
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty5}
\begin{paste}{ugDomainsExamplesPageEmpty5}{ugDomainsExamplesPagePatch5}
\pastebutton{ugDomainsExamplesPageEmpty5}{\showpaste}
\tab{5}\spadcommand{elt(mk.(kind="d"),name)\bound{q6 }\free{q5 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch6}
\begin{paste}{ugDomainsExamplesPageFull6}{ugDomainsExamplesPageEmpty6}
\pastebutton{ugDomainsExamplesPageFull6}{\hidepaste}
\tab{5}\spadcommand{o := getDatabase "o"\bound{o1 }}
\indentrel{3}begin{verbatim}
   (6)  6315
                               Type: Database IndexCard
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty6}
\begin{paste}{ugDomainsExamplesPageEmpty6}{ugDomainsExamplesPagePatch6}
\pastebutton{ugDomainsExamplesPageEmpty6}{\showpaste}
\tab{5}\spadcommand{o := getDatabase "o"\bound{o1 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch7}
\begin{paste}{ugDomainsExamplesPageFull7}{ugDomainsExamplesPageEmpty7}
\pastebutton{ugDomainsExamplesPageFull7}{\hidepaste}
\tab{5}\spadcommand{[o.(kind=k) for k in ["c","d","p"]]\free{o1 }}
\indentrel{3}begin{verbatim}
   (7)  [1646,2040,2629]
                          Type: List Database IndexCard
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty7}
\begin{paste}{ugDomainsExamplesPageEmpty7}{ugDomainsExamplesPagePatch7}
\pastebutton{ugDomainsExamplesPageEmpty7}{\showpaste}
\tab{5}\spadcommand{[o.(kind=k) for k in ["c","d","p"]]\free{o1 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch8}
\begin{paste}{ugDomainsExamplesPageFull8}{ugDomainsExamplesPageEmpty8}
\pastebutton{ugDomainsExamplesPageFull8}{\hidepaste}
\tab{5}\spadcommand{eigens := o.(name="*eigen*")\bound{eigens }\free{o1 }}
\indentrel{3}begin{verbatim}
   (8)  4
                               Type: Database IndexCard
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty8}
\begin{paste}{ugDomainsExamplesPageEmpty8}{ugDomainsExamplesPagePatch8}
\pastebutton{ugDomainsExamplesPageEmpty8}{\showpaste}
\tab{5}\spadcommand{eigens := o.(name="*eigen*")\bound{eigens }\free{o1 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch9}
\begin{paste}{ugDomainsExamplesPageFull9}{ugDomainsExamplesPageEmpty9}
\pastebutton{ugDomainsExamplesPageFull9}{\hidepaste}
\tab{5}\spadcommand{elt(eigens,name)\free{eigens }}
\indentrel{3}begin{verbatim}
   (9)
   ["eigenMatrix", "eigenvalues", "eigenvector",
    "eigenvectors"]
                                  Type: DataList String
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty9}
\begin{paste}{ugDomainsExamplesPageEmpty9}{ugDomainsExamplesPagePatch9}
\pastebutton{ugDomainsExamplesPageEmpty9}{\showpaste}
\tab{5}\spadcommand{elt(eigens,name)\free{eigens }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch10}
\begin{paste}{ugDomainsExamplesPageFull10}{ugDomainsExamplesPageEmpty10}
\pastebutton{ugDomainsExamplesPageFull10}{\hidepaste}
\tab{5}\spadcommand{elt(elt(elt(eigens,origin),sort),unique)\free{eigens }}
\indentrel{3}begin{verbatim}
   (10)  ["EigenPackage","RadicalEigenPackage"]
                                  Type: DataList String
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty10}
\begin{paste}{ugDomainsExamplesPageEmpty10}{ugDomainsExamplesPagePatch10}
\pastebutton{ugDomainsExamplesPageEmpty10}{\showpaste}
\tab{5}\spadcommand{elt(elt(elt(eigens,origin),sort),unique)\free{eigens }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch11}
\begin{paste}{ugDomainsExamplesPageFull11}{ugDomainsExamplesPageEmpty11}
\pastebutton{ugDomainsExamplesPageFull11}{\hidepaste}
\tab{5}\spadcommand{tm := o.(type="*Matrix*")\bound{x10 }\free{o1 }}
\indentrel{3}begin{verbatim}
   (11)  353
                               Type: Database IndexCard
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty11}
\begin{paste}{ugDomainsExamplesPageEmpty11}{ugDomainsExamplesPagePatch11}
\pastebutton{ugDomainsExamplesPageEmpty11}{\showpaste}
\tab{5}\spadcommand{tm := o.(type="*Matrix*")\bound{x10 }\free{o1 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch12}
\begin{paste}{ugDomainsExamplesPageFull12}{ugDomainsExamplesPageEmpty12}
\pastebutton{ugDomainsExamplesPageFull12}{\hidepaste}
\tab{5}\spadcommand{fm := o.(origin="*Matrix*")\bound{x11 }\free{o1 }}
\indentrel{3}begin{verbatim}
   (12)  192
                               Type: Database IndexCard
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty12}
\begin{paste}{ugDomainsExamplesPageEmpty12}{ugDomainsExamplesPagePatch12}
\pastebutton{ugDomainsExamplesPageEmpty12}{\showpaste}
\tab{5}\spadcommand{fm := o.(origin="*Matrix*")\bound{x11 }\free{o1 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch13}
\begin{paste}{ugDomainsExamplesPageFull13}{ugDomainsExamplesPageEmpty13}
\pastebutton{ugDomainsExamplesPageFull13}{\hidepaste}
\tab{5}\spadcommand{fm-tm\bound{x12 }\free{x10 x11 }}
\indentrel{3}begin{verbatim}
   (13)  146
                               Type: Database IndexCard
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty13}
\begin{paste}{ugDomainsExamplesPageEmpty13}{ugDomainsExamplesPagePatch13}
\pastebutton{ugDomainsExamplesPageEmpty13}{\showpaste}
\tab{5}\spadcommand{fm-tm\bound{x12 }\free{x10 x11 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch14}
\begin{paste}{ugDomainsExamplesPageFull14}{ugDomainsExamplesPageEmpty14}
\pastebutton{ugDomainsExamplesPageFull14}{\hidepaste}
\tab{5}\spadcommand{fullDisplay(fm-\%)\bound{x13 }\free{x12 }}
\indentrel{3}begin{verbatim}
   ** : (Matrix(R),NonNegativeInteger)->Matrix(R)
      from StorageEfficientMatrixOperations(R) (unexposed)
   clearDenominator : (Matrix(Q))->Matrix(R)
      from MatrixCommonDenominator(R,Q)
   coerceP
      : (Vector(Matrix(R)))->Vector(Matrix(Polynomial(R)))
      from CoerceVectorMatrixPackage(R) (unexposed)
   coerce
      :
      (Vector(Matrix(R)))->Vector(Matrix(Fraction(Polynom
      ial(R))))
      from CoerceVectorMatrixPackage(R) (unexposed)
   coerce : (_$)->Matrix(R)
      from RectangularMatrix(m,n,R) (unexposed)
   coerce : (_$)->Matrix(R)
      from SquareMatrix(ndim,R) (unexposed)
   coerce : (Matrix(MachineFloat))->_$
      from FortranMatrixCategory
   commonDenominator : (Matrix(Q))->R
      from MatrixCommonDenominator(R,Q)
   copy! : (Matrix(R),Matrix(R))->Matrix(R)
      from StorageEfficientMatrixOperations(R) (unexposed)
   f01brf
      :
      (Integer,Integer,Integer,Integer,DoubleFloat,Boolea
      n,Boolean,List(Boolean),Matrix(DoubleFloat),Matrix(
      Integer),Matrix(Integer),Integer)->Result
      from NagMatrixOperationsPackage
   f01bsf
      :
      (Integer,Integer,Integer,Matrix(Integer),Matrix(Int
      eger),Matrix(Integer),Matrix(Integer),Boolean,Doubl
      eFloat,Boolean,Matrix(Integer),Matrix(DoubleFloat),
      Integer)->Result
      from NagMatrixOperationsPackage
   f01maf
      :
      (Integer,Integer,Integer,Integer,List(Boolean),Matr
      ix(DoubleFloat),Matrix(Integer),Matrix(Integer),Dou
      bleFloat,DoubleFloat,Integer)->Result
      from NagMatrixOperationsPackage
   f01mcf
      :
      (Integer,Matrix(DoubleFloat),Integer,Matrix(Integer
      ),Integer)->Result
      from NagMatrixOperationsPackage
   f01qcf
      :
      (Integer,Integer,Integer,Matrix(DoubleFloat),Intege
      r)->Result
      from NagMatrixOperationsPackage
   f01qdf
      :
      (String,String,Integer,Integer,Matrix(DoubleFloat),
      Integer,Matrix(DoubleFloat),Integer,Integer,Matrix(
      DoubleFloat),Integer)->Result
      from NagMatrixOperationsPackage
   f01qef
      :
      (String,Integer,Integer,Integer,Integer,Matrix(Doub
      leFloat),Matrix(DoubleFloat),Integer)->Result
      from NagMatrixOperationsPackage
   f01rcf
      :
      (Integer,Integer,Integer,Matrix(Complex(DoubleFloat
      )),Integer)->Result
      from NagMatrixOperationsPackage
   f01rdf
      :
      (String,String,Integer,Integer,Matrix(Complex(Doubl
      eFloat)),Integer,Matrix(Complex(DoubleFloat)),Integ
      er,Integer,Matrix(Complex(DoubleFloat)),Integer)->R
      esult
      from NagMatrixOperationsPackage
   f01ref
      :
      (String,Integer,Integer,Integer,Integer,Matrix(Comp
      lex(DoubleFloat)),Matrix(Complex(DoubleFloat)),Inte
      ger)->Result
      from NagMatrixOperationsPackage
   hasSolution? : (Matrix(F),Vector(F))->Boolean
      from LinearSystemMatrixPackage1(F)
   leftScalarTimes! : (Matrix(R),R,Matrix(R))->Matrix(R)
      from StorageEfficientMatrixOperations(R) (unexposed)
   minus! : (Matrix(R),Matrix(R))->Matrix(R)
      from StorageEfficientMatrixOperations(R) (unexposed)
   minus! : (Matrix(R),Matrix(R),Matrix(R))->Matrix(R)
      from StorageEfficientMatrixOperations(R) (unexposed)
   particularSolution
      : (Matrix(F),Vector(F))->Union(Vector(F),"failed")
      from LinearSystemMatrixPackage1(F)
   plus! : (Matrix(R),Matrix(R),Matrix(R))->Matrix(R)
      from StorageEfficientMatrixOperations(R) (unexposed)
   power!
      :
      (Matrix(R),Matrix(R),Matrix(R),Matrix(R),NonNegativ
      eInteger)->Matrix(R)
      from StorageEfficientMatrixOperations(R) (unexposed)
   rank : (Matrix(F),Vector(F))->NonNegativeInteger
      from LinearSystemMatrixPackage1(F)
   rectangularMatrix : (Matrix(R))->_$
      from RectangularMatrix(m,n,R) (unexposed)
   retractIfCan
      : (Matrix(Expression(Float)))->Union(_$,"failed")
      from FortranMatrixFunctionCategory
   retractIfCan
      : (Matrix(Expression(Integer)))->Union(_$,"failed")
      from FortranMatrixFunctionCategory
   retractIfCan
      :
      (Matrix(Fraction(Polynomial(Float))))->Union(_$,"fa
      iled")
      from FortranMatrixFunctionCategory
   retractIfCan
      :
      (Matrix(Fraction(Polynomial(Integer))))->Union(_$,"
      failed")
      from FortranMatrixFunctionCategory
   retractIfCan
      : (Matrix(Polynomial(Float)))->Union(_$,"failed")
      from FortranMatrixFunctionCategory
   retractIfCan
      : (Matrix(Polynomial(Integer)))->Union(_$,"failed")
      from FortranMatrixFunctionCategory
   retract : (Matrix(Expression(Float)))->_$
      from FortranMatrixFunctionCategory
   retract : (Matrix(Expression(Integer)))->_$
      from FortranMatrixFunctionCategory
   retract : (Matrix(Fraction(Polynomial(Float))))->_$
      from FortranMatrixFunctionCategory
   retract : (Matrix(Fraction(Polynomial(Integer))))->_$
      from FortranMatrixFunctionCategory
   retract : (Matrix(Polynomial(Float)))->_$
      from FortranMatrixFunctionCategory
   retract : (Matrix(Polynomial(Integer)))->_$
      from FortranMatrixFunctionCategory
   rightScalarTimes! : (Matrix(R),Matrix(R),R)->Matrix(R)
      from StorageEfficientMatrixOperations(R) (unexposed)
   solve
      :
      (Matrix(F),List(Vector(F)))->List(Record(particular
      :Union(Vector(F),"failed"),basis:List(Vector(F))))
      from LinearSystemMatrixPackage1(F)
   solve
      :
      (Matrix(F),Vector(F))->Record(particular:Union(Vect
      or(F),"failed"),basis:List(Vector(F)))
      from LinearSystemMatrixPackage1(F)
   splitDenominator
      : (Matrix(Q))->Record(num:Matrix(R),den:R)
      from MatrixCommonDenominator(R,Q)
   squareMatrix : (Matrix(R))->_$
      from SquareMatrix(ndim,R) (unexposed)
   times! : (Matrix(R),Matrix(R),Matrix(R))->Matrix(R)
      from StorageEfficientMatrixOperations(R) (unexposed)
                                             Type: Void
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty14}
\begin{paste}{ugDomainsExamplesPageEmpty14}{ugDomainsExamplesPagePatch14}
\pastebutton{ugDomainsExamplesPageEmpty14}{\showpaste}
\tab{5}\spadcommand{fullDisplay(fm-\%)\bound{x13 }\free{x12 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch15}
\begin{paste}{ugDomainsExamplesPageFull15}{ugDomainsExamplesPageEmpty15}
\pastebutton{ugDomainsExamplesPageFull15}{\hidepaste}
\tab{5}\spadcommand{m := tm+fm\bound{x14 }\free{x10 x11 }}
\indentrel{3}begin{verbatim}
   (15)  499
                               Type: Database IndexCard
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty15}
\begin{paste}{ugDomainsExamplesPageEmpty15}{ugDomainsExamplesPagePatch15}
\pastebutton{ugDomainsExamplesPageEmpty15}{\showpaste}
\tab{5}\spadcommand{m := tm+fm\bound{x14 }\free{x10 x11 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch16}
\begin{paste}{ugDomainsExamplesPageFull16}{ugDomainsExamplesPageEmpty16}
\pastebutton{ugDomainsExamplesPageFull16}{\hidepaste}
\tab{5}\spadcommand{fullDisplay(m, 202, 205)\free{x14 }}
\indentrel{3}begin{verbatim}
   elt : (_$,List(Integer),List(Integer))->_$
      from MatrixCategory(R,Row,Col)
   elt : (_$,Integer,Integer,R)->R
      from RectangularMatrixCategory(m,n,R,Row,Col)
   elt
      :
      (_$,NonNegativeInteger,NonNegativeInteger,NonNegati
      veInteger)->R
      from ThreeDimensionalMatrix(R)
   eval
      :
      (Matrix(Expression(DoubleFloat)),List(Symbol),Vecto
      r(Expression(DoubleFloat)))->Matrix(Expression(Doub
      leFloat))
      from d02AgentsPackage
                                             Type: Void
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty16}
\begin{paste}{ugDomainsExamplesPageEmpty16}{ugDomainsExamplesPagePatch16}
\pastebutton{ugDomainsExamplesPageEmpty16}{\showpaste}
\tab{5}\spadcommand{fullDisplay(m, 202, 205)\free{x14 }}
\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPagePatch17}
\begin{paste}{ugDomainsExamplesPageFull17}{ugDomainsExamplesPageEmpty17}
\pastebutton{ugDomainsExamplesPageFull17}{\hidepaste}
\tab{5}\spadcommand{elt(elt(elt(m,name),unique),count)\free{x14 }}
\indentrel{3}begin{verbatim}
   (17)  317
                                  Type: PositiveInteger
end{verbatim}
\indentrel{-3}\end{paste}\end{patch}

\begin{patch}{ugDomainsExamplesPageEmpty17}
\begin{paste}{ugDomainsExamplesPageEmpty17}{ugDomainsExamplesPagePatch17}
\pastebutton{ugDomainsExamplesPageEmpty17}{\showpaste}
\tab{5}\spadcommand{elt(elt(elt(m,name),unique),count)\free{x14 }}
\end{paste}\end{patch}
\end{verbatim}

\end{chunk}
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
