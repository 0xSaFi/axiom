\documentclass{article}
\usepackage{axiom}
\setlength{\textwidth}{400pt}
\begin{document}
\title{\$SPAD/src/input allfns.input}
\author{Timothy Daly}
\maketitle
\begin{abstract}
This is a regression test file. It calls ')display'
on every Axiom function name to check whether the
result contains ++X examples for each function from
each spad file. Functions that are complete are marked
with a ``done'' comment on the --S line.
\end{abstract}
\eject
\begin{chunk}{*}
)set break resume
)sys rm -f allfns.output
)spool allfns.output
)set message test on
)set message auto off
)clear all
 
--S 1 of 3320
)d op ^
--R 
--R
--RThere are 7 exposed functions called ^ :
--R   [1] Boolean -> Boolean from Boolean
--R   [2] D -> D from D if D has BTAGG
--R   [3] (D,Integer) -> D from D if D has DIVRING
--R   [4] (D,Integer) -> D from D if D has GROUP
--R   [5] (D,NonNegativeInteger) -> D from D if D has MONOID
--R   [6] (StochasticDifferential(D2),PositiveInteger) -> 
--R            StochasticDifferential(D2)
--R             from StochasticDifferential(D2)
--R             if D2 has Join(OrderedSet,IntegralDomain)
--R   [7] (D,PositiveInteger) -> D from D if D has SGROUP
--R
--RExamples of ^ from Boolean
--R
--R
--RExamples of ^ from BitAggregate
--R
--R
--RExamples of ^ from DivisionRing
--R
--R
--RExamples of ^ from Group
--R
--R
--RExamples of ^ from Monoid
--R
--R
--RExamples of ^ from StochasticDifferential
--R
--R
--RExamples of ^ from SemiGroup
--R
--E 1

--S 2 of 3320
)d op ~
--R 
--R
--RThere are 2 exposed functions called ~ :
--R   [1] D -> D from D if D has LOGIC
--R   [2] SingleInteger -> SingleInteger from SingleInteger
--R
--RExamples of ~ from Logic
--R
--R
--RExamples of ~ from SingleInteger
--R
--E 2

--S 3 of 3320
)d op = 
--R 
--R
--RThere are 8 exposed functions called = :
--R   [1] (ArrayStack(D2),ArrayStack(D2)) -> Boolean from ArrayStack(D2)
--R             if D2 has SETCAT and D2 has SETCAT
--R   [2] (D,D) -> Boolean from D if D has BASTYPE
--R   [3] (Dequeue(D2),Dequeue(D2)) -> Boolean from Dequeue(D2)
--R             if D2 has SETCAT and D2 has SETCAT
--R   [4] (D1,D1) -> Equation(D1) from Equation(D1) if D1 has TYPE
--R   [5] (FortranScalarType,FortranScalarType) -> Boolean from 
--R            FortranScalarType
--R   [6] (Heap(D2),Heap(D2)) -> Boolean from Heap(D2)
--R             if D2 has SETCAT and D2 has ORDSET
--R   [7] (Queue(D2),Queue(D2)) -> Boolean from Queue(D2)
--R             if D2 has SETCAT and D2 has SETCAT
--R   [8] (Stack(D2),Stack(D2)) -> Boolean from Stack(D2)
--R             if D2 has SETCAT and D2 has SETCAT
--R
--RThere are 2 unexposed functions called = :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [2] (Reference(D2),Reference(D2)) -> Boolean from Reference(D2) if 
--R            D2 has TYPE
--R
--RExamples of = from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rb:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--R(a=b)@Boolean
--R
--R
--RExamples of = from BasicType
--R
--R
--RExamples of = from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rb:Dequeue INT:= dequeue [1,2,3,4,5] 
--R(a=b)@Boolean
--R
--R
--RExamples of = from Equation
--R
--R
--RExamples of = from FortranScalarType
--R
--R
--RExamples of = from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rb:Heap INT:= heap [1,2,3,4,5] 
--R(a=b)@Boolean
--R
--R
--RExamples of = from OutputForm
--R
--R
--RExamples of = from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rb:Queue INT:= queue [1,2,3,4,5] 
--R(a=b)@Boolean
--R
--R
--RExamples of = from Reference
--R
--R
--RExamples of = from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rb:Stack INT:= stack [1,2,3,4,5] 
--R(a=b)@Boolean
--R
--E 3

--S 4 of 3320
)d op +
--R 
--R
--RThere are 15 exposed functions called + :
--R   [1] (D,D) -> D from D if D has ABELSG
--R   [2] (Color,Color) -> Color from Color
--R   [3] (Database(D1),Database(D1)) -> Database(D1) from Database(D1)
--R             if D1 has OrderedSetwith
--R               ?.? : (%,Symbol) -> String
--R               display : % -> Void
--R               fullDisplay : % -> Void
--R   [4] (Equation(D1),D1) -> Equation(D1) from Equation(D1)
--R             if D1 has ABELSG and D1 has TYPE
--R   [5] (D1,Equation(D1)) -> Equation(D1) from Equation(D1)
--R             if D1 has ABELSG and D1 has TYPE
--R   [6] (D1,D) -> D from D if D has FAMONC(D1,D2) and D1 has SETCAT and 
--R            D2 has CABMON
--R   [7] (D1,FullPartialFractionExpansion(D2,D1)) -> 
--R            FullPartialFractionExpansion(D2,D1)
--R             from FullPartialFractionExpansion(D2,D1)
--R             if D2 has Join(Field,CharacteristicZero) and D1 has UPOLYC
--R            (D2)
--R   [8] (D,D) -> D from D if D has GRMOD(D1,D2) and D1 has COMRING and 
--R            D2 has ABELMON
--R   [9] (PolynomialIdeals(D1,D2,D3,D4),PolynomialIdeals(D1,D2,D3,D4))
--R             -> PolynomialIdeals(D1,D2,D3,D4)
--R             from PolynomialIdeals(D1,D2,D3,D4)
--R             if D1 has FIELD and D2 has OAMONS and D3 has ORDSET and D4
--R             has POLYCAT(D1,D2,D3)
--R   [10] ((D2 -> D3),(D2 -> D3)) -> (D2 -> D3) from MappingPackage4(D2,
--R            D3)
--R             if D2 has SETCAT and D3 has RING
--R   [11] (D,D) -> D from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1)
--R   [12] (D,Divisor(D)) -> Divisor(D) from D
--R             if D has PLACESC(D2,D3) and D2 has FIELD and D3 has 
--R            LOCPOWC(D2)
--R   [13] (Divisor(D),D) -> Divisor(D) from D
--R             if D has PLACESC(D2,D3) and D2 has FIELD and D3 has 
--R            LOCPOWC(D2)
--R   [14] (D,D) -> Divisor(D) from D
--R             if D2 has FIELD and D3 has LOCPOWC(D2) and D has PLACESC(
--R            D2,D3)
--R   [15] (D,D) -> D from D if D has VECTCAT(D1) and D1 has TYPE and D1
--R             has ABELSG
--R
--RThere are 5 unexposed functions called + :
--R   [1] (InputForm,InputForm) -> InputForm from InputForm
--R   [2] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [3] (Pattern(D1),Pattern(D1)) -> Pattern(D1) from Pattern(D1) if D1
--R             has SETCAT
--R   [4] (Stream(D2),Stream(D2)) -> Stream(D2)
--R             from StreamTaylorSeriesOperations(D2) if D2 has RING
--R   [5] (Point(DoubleFloat),Point(DoubleFloat)) -> Point(DoubleFloat)
--R             from TubePlotTools
--R
--RExamples of + from AbelianSemiGroup
--R
--R
--RExamples of + from Color
--R
--R
--RExamples of + from Database
--R
--R
--RExamples of + from Equation
--R
--R
--RExamples of + from FreeAbelianMonoidCategory
--R
--R
--RExamples of + from FullPartialFractionExpansion
--R
--R
--RExamples of + from GradedModule
--R
--R
--RExamples of + from PolynomialIdeals
--R
--R
--RExamples of + from InputForm
--R
--R
--RExamples of + from MappingPackage4
--R
--Rf:=(x:INT):INT +-> 3*x 
--Rg:=(x:INT):INT +-> 2*x+3 
--R(f+g)(4)
--R
--R
--RExamples of + from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rm+m
--R
--R
--RExamples of + from OutputForm
--R
--R
--RExamples of + from Pattern
--R
--R
--RExamples of + from PlacesCategory
--R
--R
--RExamples of + from StreamTaylorSeriesOperations
--R
--R
--RExamples of + from TubePlotTools
--R
--R
--RExamples of + from VectorCategory
--R
--E 4

--S 5 of 3320
)d op -
--R 
--R
--RThere are 17 exposed functions called - :
--R   [1] (D,D) -> D from D if D has ABELGRP
--R   [2] D -> D from D if D has ABELGRP
--R   [3] (CardinalNumber,CardinalNumber) -> Union(CardinalNumber,"failed"
--R            )
--R             from CardinalNumber
--R   [4] (Database(D1),Database(D1)) -> Database(D1) from Database(D1)
--R             if D1 has OrderedSetwith
--R               ?.? : (%,Symbol) -> String
--R               display : % -> Void
--R               fullDisplay : % -> Void
--R   [5] (Equation(D1),D1) -> Equation(D1) from Equation(D1)
--R             if D1 has ABELGRP and D1 has TYPE
--R   [6] (D1,Equation(D1)) -> Equation(D1) from Equation(D1)
--R             if D1 has ABELGRP and D1 has TYPE
--R   [7] (D,D) -> D from D if D has GRMOD(D1,D2) and D1 has COMRING and 
--R            D2 has ABELMON
--R   [8] D -> D from D if D has GRMOD(D1,D2) and D1 has COMRING and D2
--R             has ABELMON
--R   [9] ((D2 -> D3),(D2 -> D3)) -> (D2 -> D3) from MappingPackage4(D2,D3
--R            )
--R             if D2 has SETCAT and D3 has RING
--R   [10] D -> D from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1)
--R   [11] (D,D) -> D from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1)
--R   [12] D -> Divisor(D) from D
--R             if D2 has FIELD and D3 has LOCPOWC(D2) and D has PLACESC(
--R            D2,D3)
--R   [13] (D,Divisor(D)) -> Divisor(D) from D
--R             if D has PLACESC(D2,D3) and D2 has FIELD and D3 has 
--R            LOCPOWC(D2)
--R   [14] (Divisor(D),D) -> Divisor(D) from D
--R             if D has PLACESC(D2,D3) and D2 has FIELD and D3 has 
--R            LOCPOWC(D2)
--R   [15] (D,D) -> Divisor(D) from D
--R             if D2 has FIELD and D3 has LOCPOWC(D2) and D has PLACESC(
--R            D2,D3)
--R   [16] (D,D) -> D from D if D has VECTCAT(D1) and D1 has TYPE and D1
--R             has ABELGRP
--R   [17] D -> D from D if D has VECTCAT(D1) and D1 has TYPE and D1 has 
--R            ABELGRP
--R
--RThere are 5 unexposed functions called - :
--R   [1] OutputForm -> OutputForm from OutputForm
--R   [2] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [3] (Stream(D2),Stream(D2)) -> Stream(D2)
--R             from StreamTaylorSeriesOperations(D2) if D2 has RING
--R   [4] Stream(D2) -> Stream(D2) from StreamTaylorSeriesOperations(D2)
--R             if D2 has RING
--R   [5] (Point(DoubleFloat),Point(DoubleFloat)) -> Point(DoubleFloat)
--R             from TubePlotTools
--R
--RExamples of - from AbelianGroup
--R
--R
--RExamples of - from CardinalNumber
--R
--Rc2:=2::CardinalNumber 
--Rc2-c2 
--RA1:=Aleph 1 
--RA1-c2
--R
--R
--RExamples of - from Database
--R
--R
--RExamples of - from Equation
--R
--R
--RExamples of - from GradedModule
--R
--R
--RExamples of - from MappingPackage4
--R
--Rf:=(x:INT):INT +-> 3*x 
--Rg:=(x:INT):INT +-> 2*x+3 
--R(f-g)(4)
--R
--R
--RExamples of - from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--R-m
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rm-m
--R
--R
--RExamples of - from OutputForm
--R
--R
--RExamples of - from PlacesCategory
--R
--R
--RExamples of - from StreamTaylorSeriesOperations
--R
--R
--RExamples of - from TubePlotTools
--R
--R
--RExamples of - from VectorCategory
--R
--E 5

--S 6 of 3320
)d op *
--R 
--R
--RThere are 39 exposed functions called * :
--R   [1] (Integer,D) -> D from D if D has ABELGRP
--R   [2] (NonNegativeInteger,D) -> D from D if D has ABELMON
--R   [3] (PositiveInteger,D) -> D from D if D has ABELSG
--R   [4] (CartesianTensor(D1,D2,D3),CartesianTensor(D1,D2,D3)) -> 
--R            CartesianTensor(D1,D2,D3)
--R             from CartesianTensor(D1,D2,D3) if D1: INT and D2: NNI and 
--R            D3 has COMRING
--R   [5] (DoubleFloat,Color) -> Color from Color
--R   [6] (PositiveInteger,Color) -> Color from Color
--R   [7] (DenavitHartenbergMatrix(D2),Point(D2)) -> Point(D2)
--R             from DenavitHartenbergMatrix(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory)
--R   [8] (D1,D) -> D from D if D has DIRPCAT(D2,D1) and D1 has TYPE and 
--R            D1 has MONOID
--R   [9] (D,D1) -> D from D if D has DIRPCAT(D2,D1) and D1 has TYPE and 
--R            D1 has MONOID
--R   [10] (D1,Equation(D1)) -> Equation(D1) from Equation(D1)
--R             if D1 has SGROUP and D1 has TYPE
--R   [11] (Equation(D1),D1) -> Equation(D1) from Equation(D1)
--R             if D1 has SGROUP and D1 has TYPE
--R   [12] (D1,D2) -> D from D if D has FAMONC(D2,D1) and D2 has SETCAT 
--R            and D1 has CABMON
--R   [13] (D1,D2) -> D from D if D has FMCAT(D1,D2) and D1 has RING and 
--R            D2 has SETCAT
--R   [14] (D,D1) -> D from D if D has GRMOD(D1,D2) and D1 has COMRING and
--R            D2 has ABELMON
--R   [15] (D1,D) -> D from D if D has GRMOD(D1,D2) and D1 has COMRING and
--R            D2 has ABELMON
--R   [16] (PolynomialIdeals(D1,D2,D3,D4),PolynomialIdeals(D1,D2,D3,D4))
--R             -> PolynomialIdeals(D1,D2,D3,D4)
--R             from PolynomialIdeals(D1,D2,D3,D4)
--R             if D1 has FIELD and D2 has OAMONS and D3 has ORDSET and D4
--R             has POLYCAT(D1,D2,D3)
--R   [17] (D1,D) -> D from D if D has LMODULE(D1) and D1 has RNG
--R   [18] ((D5 -> D6),(D4 -> D5)) -> (D4 -> D6) from MappingPackage3(D4,
--R            D5,D6)
--R             if D4 has SETCAT and D5 has SETCAT and D6 has SETCAT
--R   [19] ((D2 -> D3),(D2 -> D3)) -> (D2 -> D3) from MappingPackage4(D2,
--R            D3)
--R             if D2 has SETCAT and D3 has RING
--R   [20] (D1,D) -> D1 from D
--R             if D has MATCAT(D2,D1,D3) and D2 has RING and D1 has FLAGG
--R            (D2) and D3 has FLAGG(D2)
--R   [21] (D,D1) -> D1 from D
--R             if D has MATCAT(D2,D3,D1) and D2 has RING and D3 has FLAGG
--R            (D2) and D1 has FLAGG(D2)
--R   [22] (Integer,D) -> D from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [23] (D,D1) -> D from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1)
--R   [24] (D1,D) -> D from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1)
--R   [25] (D,D) -> D from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1)
--R   [26] (D,D) -> D from D if D has MONAD
--R   [27] (MyExpression(D1,D2),MyExpression(D1,D2)) -> MyExpression(D1,D2
--R            )
--R             from MyExpression(D1,D2)
--R             if D1: SYMBOL and D2 has Join(Ring,OrderedSet,
--R            IntegralDomain)
--R   [28] (Integer,D) -> Divisor(D) from D
--R             if D3 has FIELD and D4 has LOCPOWC(D3) and D has PLACESC(
--R            D3,D4)
--R   [29] (D,D1) -> D from D if D has RMODULE(D1) and D1 has RNG
--R   [30] (Matrix(Fraction(D3)),SparseEchelonMatrix(D2,D3)) -> 
--R            SparseEchelonMatrix(D2,D3)
--R             from SparseEchelonMatrix(D2,D3)
--R             if D3 has INTDOM and D3 has RING and D2 has ORDSET
--R   [31] (Matrix(D3),SparseEchelonMatrix(D2,D3)) -> SparseEchelonMatrix(
--R            D2,D3)
--R             from SparseEchelonMatrix(D2,D3) if D3 has RING and D2 has 
--R            ORDSET
--R   [32] (D,D) -> D from D if D has SGROUP
--R   [33] (D1,D) -> D1 from D
--R             if D has SMATCAT(D2,D3,D1,D4) and D3 has RING and D1 has 
--R            DIRPCAT(D2,D3) and D4 has DIRPCAT(D2,D3)
--R   [34] (D,D1) -> D1 from D
--R             if D has SMATCAT(D2,D3,D4,D1) and D3 has RING and D4 has 
--R            DIRPCAT(D2,D3) and D1 has DIRPCAT(D2,D3)
--R   [35] (D,D1) -> D from D if D has VECTCAT(D1) and D1 has TYPE and D1
--R             has MONOID
--R   [36] (D1,D) -> D from D if D has VECTCAT(D1) and D1 has TYPE and D1
--R             has MONOID
--R   [37] (Integer,D) -> D from D
--R             if D has VECTCAT(D2) and D2 has TYPE and D2 has ABELGRP
--R         
--R   [38] (D1,D) -> D from D if D has XFALG(D1,D2) and D1 has ORDSET and 
--R            D2 has RING
--R   [39] (D,D1) -> D from D if D has XFALG(D2,D1) and D2 has ORDSET and 
--R            D1 has RING
--R
--RThere are 23 unexposed functions called * :
--R   [1] (FreeGroup(D1),D1) -> FreeGroup(D1) from FreeGroup(D1) if D1
--R             has SETCAT
--R   [2] (D1,FreeGroup(D1)) -> FreeGroup(D1) from FreeGroup(D1) if D1
--R             has SETCAT
--R   [3] (D1,D2) -> FreeModule1(D2,D1) from FreeModule1(D2,D1)
--R             if D2 has RING and D1 has ORDSET
--R   [4] (FreeMonoid(D1),D1) -> FreeMonoid(D1) from FreeMonoid(D1) if D1
--R             has SETCAT
--R   [5] (D1,FreeMonoid(D1)) -> FreeMonoid(D1) from FreeMonoid(D1) if D1
--R             has SETCAT
--R   [6] (D1,GeneralModulePolynomial(D2,D3,D4,D5,D6,D1)) -> 
--R            GeneralModulePolynomial(D2,D3,D4,D5,D6,D1)
--R             from GeneralModulePolynomial(D2,D3,D4,D5,D6,D1)
--R             if D2: LIST(SYMBOL) and D3 has COMRING and D5 has DIRPCAT(
--R            #(D2),NNI) and D6: ((Record(index: D4,exponent: D5),Record(
--R            index: D4,exponent: D5)) -> Boolean) and D4 has ORDSET and 
--R            D1 has POLYCAT(D3,D5,OVAR(D2))
--R   [7] (Vector(D2),Vector(D2)) -> Vector(D2)
--R             from InnerNormalBasisFieldFunctions(D2) if D2 has FFIELDC
--R            
--R   [8] (InputForm,InputForm) -> InputForm from InputForm
--R   [9] (InnerTaylorSeries(D2),Integer) -> InnerTaylorSeries(D2)
--R             from InnerTaylorSeries(D2) if D2 has RING
--R   [10] (InnerTaylorSeries(D1),D1) -> InnerTaylorSeries(D1)
--R             from InnerTaylorSeries(D1) if D1 has RING
--R   [11] (D1,InnerTaylorSeries(D1)) -> InnerTaylorSeries(D1)
--R             from InnerTaylorSeries(D1) if D1 has RING
--R   [12] (Magma(D1),Magma(D1)) -> Magma(D1) from Magma(D1) if D1 has 
--R            ORDSET
--R   [13] (OrderedFreeMonoid(D1),D1) -> OrderedFreeMonoid(D1)
--R             from OrderedFreeMonoid(D1) if D1 has ORDSET
--R   [14] (D1,OrderedFreeMonoid(D1)) -> OrderedFreeMonoid(D1)
--R             from OrderedFreeMonoid(D1) if D1 has ORDSET
--R   [15] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [16] (Pattern(D1),Pattern(D1)) -> Pattern(D1) from Pattern(D1) if D1
--R             has SETCAT
--R   [17] (D2,Vector(D3)) -> Vector(D3) from PseudoRemainderSequence(D2,
--R            D3)
--R             if D3 has UPOLYC(D2) and D2 has INTDOM
--R   [18] (D1,SparseMultivariateTaylorSeries(D2,D3,D1)) -> 
--R            SparseMultivariateTaylorSeries(D2,D3,D1)
--R             from SparseMultivariateTaylorSeries(D2,D3,D1)
--R             if D2 has RING and D3 has ORDSET and D1 has POLYCAT(D2,
--R            INDE(D3),D3)
--R   [19] (Stream(D2),Stream(D2)) -> Stream(D2)
--R             from StreamTaylorSeriesOperations(D2) if D2 has RING
--R   [20] (D2,Stream(D2)) -> Stream(D2) from StreamTaylorSeriesOperations
--R            (D2)
--R             if D2 has RING
--R   [21] (Stream(D2),D2) -> Stream(D2) from StreamTaylorSeriesOperations
--R            (D2)
--R             if D2 has RING
--R   [22] (DoubleFloat,Point(DoubleFloat)) -> Point(DoubleFloat) from 
--R            TubePlotTools
--R   [23] (XPolynomialRing(D1,D2),D1) -> XPolynomialRing(D1,D2)
--R             from XPolynomialRing(D1,D2) if D1 has RING and D2 has 
--R            ORDMON
--R
--RExamples of * from AbelianGroup
--R
--R
--RExamples of * from AbelianMonoid
--R
--R
--RExamples of * from AbelianSemiGroup
--R
--R
--RExamples of * from CartesianTensor
--R
--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
--RTm:CartesianTensor(1,2,Integer):=m 
--Rv:DirectProduct(2,Integer):=directProduct [3,4] 
--RTv:CartesianTensor(1,2,Integer):=v 
--RTm*Tv
--R
--R
--RExamples of * from Color
--R
--R
--RExamples of * from DenavitHartenbergMatrix
--R
--Rrotatex(30)*point([1,2,3])
--R
--R
--RExamples of * from DirectProductCategory
--R
--R
--RExamples of * from Equation
--R
--R
--RExamples of * from FreeAbelianMonoidCategory
--R
--R
--RExamples of * from FreeGroup
--R
--R
--RExamples of * from FreeModule1
--R
--R
--RExamples of * from FreeModuleCat
--R
--R
--RExamples of * from FreeMonoid
--R
--R
--RExamples of * from GeneralModulePolynomial
--R
--R
--RExamples of * from GradedModule
--R
--R
--RExamples of * from PolynomialIdeals
--R
--R
--RExamples of * from InnerNormalBasisFieldFunctions
--R
--R
--RExamples of * from InputForm
--R
--R
--RExamples of * from InnerTaylorSeries
--R
--R
--RExamples of * from LeftModule
--R
--R
--RExamples of * from Magma
--R
--R
--RExamples of * from MappingPackage3
--R
--R
--RExamples of * from MappingPackage4
--R
--Rf:=(x:INT):INT +-> 3*x 
--Rg:=(x:INT):INT +-> 2*x+3 
--R(f*g)(4)
--R
--R
--RExamples of * from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rr:=transpose([1,2,3,4,5])@Matrix(INT) 
--Rr*m
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rc:=coerce([1,2,3,4,5])@Matrix(INT) 
--Rm*c
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--R3*m
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rm*1/3
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--R1/3*m
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rm*m
--R
--R
--RExamples of * from Monad
--R
--R
--RExamples of * from MyExpression
--R
--R
--RExamples of * from OrderedFreeMonoid
--R
--Rm1:=(y**3)$OFMONOID(Symbol) 
--Rm1*x
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rx*m1
--R
--R
--RExamples of * from OutputForm
--R
--R
--RExamples of * from Pattern
--R
--R
--RExamples of * from PlacesCategory
--R
--R
--RExamples of * from PseudoRemainderSequence
--R
--R
--RExamples of * from RightModule
--R
--R
--RExamples of * from SparseEchelonMatrix
--R
--R
--RExamples of * from SemiGroup
--R
--R
--RExamples of * from SquareMatrixCategory
--R
--R
--RExamples of * from SparseMultivariateTaylorSeries
--R
--R
--RExamples of * from StreamTaylorSeriesOperations
--R
--R
--RExamples of * from TubePlotTools
--R
--R
--RExamples of * from VectorCategory
--R
--R
--RExamples of * from XFreeAlgebra
--R
--R
--RExamples of * from XPolynomialRing
--R
--E 6

--S 7 of 3320
)d op /
--R 
--R
--RThere are 15 exposed functions called / :
--R   [1] (D,D1) -> D from D
--R             if D has AMR(D1,D2) and D1 has RING and D2 has OAMON and 
--R            D1 has FIELD
--R   [2] (DoubleFloat,Integer) -> DoubleFloat from DoubleFloat
--R   [3] (D,D) -> D from D
--R             if D = EQ(D1) and D1 has FIELD and D1 has TYPE or D = EQ(
--R            D1) and D1 has GROUP and D1 has TYPE
--R   [4] (D,D) -> D from D if D has FIELD
--R   [5] (Float,Integer) -> Float from Float
--R   [6] (SparseMultivariatePolynomial(D2,Kernel(D)),
--R            SparseMultivariatePolynomial(D2,Kernel(D))) -> D
--R             from D if D2 has INTDOM and D2 has ORDSET and D has FS(D2)
--R            
--R   [7] (D,D) -> D from D if D has GROUP
--R   [8] (D,D1) -> D from D if D has LIECAT(D1) and D1 has COMRING and D1
--R             has FIELD
--R   [9] ((D2 -> Expression(Integer)),(D2 -> Expression(Integer))) -> (D2
--R             -> Expression(Integer))
--R             from MappingPackage4(D2,D3) if D2 has SETCAT and D3 has 
--R            RING
--R   [10] (D,D1) -> D from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1) and D1 has FIELD
--R   [11] (MyExpression(D1,D2),MyExpression(D1,D2)) -> MyExpression(D1,D2
--R            )
--R             from MyExpression(D1,D2)
--R             if D1: SYMBOL and D2 has Join(Ring,OrderedSet,
--R            IntegralDomain)
--R   [12] (D1,D1) -> D from D if D has QFCAT(D1) and D1 has INTDOM
--R   [13] (D,D1) -> D from D
--R             if D has RMATCAT(D2,D3,D1,D4,D5) and D1 has RING and D4
--R             has DIRPCAT(D3,D1) and D5 has DIRPCAT(D2,D1) and D1 has 
--R            FIELD
--R   [14] (StochasticDifferential(D2),Expression(D2)) -> 
--R            StochasticDifferential(D2)
--R             from StochasticDifferential(D2)
--R             if D2 has Join(OrderedSet,IntegralDomain)
--R   [15] (D,D1) -> D from D if D has VSPACE(D1) and D1 has FIELD
--R
--RThere are 12 unexposed functions called / :
--R   [1] (Vector(D2),Vector(D2)) -> Vector(D2)
--R             from InnerNormalBasisFieldFunctions(D2) if D2 has FFIELDC
--R            
--R   [2] (InputForm,InputForm) -> InputForm from InputForm
--R   [3] (D1,D2) -> LocalAlgebra(D1,D3,D2) from LocalAlgebra(D1,D3,D2)
--R             if D3 has COMRING and D1 has ALGEBRA(D3) and D2 has 
--R            SubsetCategory(Monoid,D3)
--R   [4] (LocalAlgebra(D2,D3,D1),D1) -> LocalAlgebra(D2,D3,D1)
--R             from LocalAlgebra(D2,D3,D1)
--R             if D3 has COMRING and D2 has ALGEBRA(D3) and D1 has 
--R            SubsetCategory(Monoid,D3)
--R   [5] (D1,D2) -> Localize(D1,D3,D2) from Localize(D1,D3,D2)
--R             if D3 has COMRING and D1 has MODULE(D3) and D2 has 
--R            SubsetCategory(Monoid,D3)
--R   [6] (Localize(D2,D3,D1),D1) -> Localize(D2,D3,D1) from Localize(D2,
--R            D3,D1)
--R             if D3 has COMRING and D2 has MODULE(D3) and D1 has 
--R            SubsetCategory(Monoid,D3)
--R   [7] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [8] (OrdinaryWeightedPolynomials(D1,D2,D3,D4),
--R            OrdinaryWeightedPolynomials(D1,D2,D3,D4)) -> Union(
--R            OrdinaryWeightedPolynomials(D1,D2,D3,D4),"failed")
--R             from OrdinaryWeightedPolynomials(D1,D2,D3,D4)
--R             if D1 has FIELD and D1 has RING and D2: LIST(SYMBOL) and 
--R            D3: LIST(NNI) and D4: NNI
--R   [9] (Pattern(D1),Pattern(D1)) -> Pattern(D1) from Pattern(D1) if D1
--R             has SETCAT
--R   [10] (Stream(D2),Stream(D2)) -> Stream(D2)
--R             from StreamTaylorSeriesOperations(D2) if D2 has RING
--R   [11] (WeightedPolynomials(D1,D2,D3,D4,D5,D6,D7),WeightedPolynomials(
--R            D1,D2,D3,D4,D5,D6,D7)) -> Union(WeightedPolynomials(D1,D2,D3,D4,
--R            D5,D6,D7),"failed")
--R             from WeightedPolynomials(D1,D2,D3,D4,D5,D6,D7)
--R             if D1 has FIELD and D1 has RING and D2 has ORDSET and D3
--R             has OAMONS and D5: LIST(D2) and D4 has POLYCAT(D1,D3,D2) 
--R            and D6: LIST(NNI) and D7: NNI
--R   [12] (XPolynomialRing(D1,D2),D1) -> XPolynomialRing(D1,D2)
--R             from XPolynomialRing(D1,D2)
--R             if D1 has FIELD and D1 has RING and D2 has ORDMON
--R
--RExamples of / from AbelianMonoidRing
--R
--R
--RExamples of / from DoubleFloat
--R
--R
--RExamples of / from Equation
--R
--R
--RExamples of / from Field
--R
--R
--RExamples of / from Float
--R
--R
--RExamples of / from FunctionSpace
--R
--R
--RExamples of / from Group
--R
--R
--RExamples of / from InnerNormalBasisFieldFunctions
--R
--R
--RExamples of / from InputForm
--R
--R
--RExamples of / from LocalAlgebra
--R
--R
--RExamples of / from LieAlgebra
--R
--R
--RExamples of / from Localize
--R
--R
--RExamples of / from MappingPackage4
--R
--Rp:=(x:EXPR(INT)):EXPR(INT)+->3*x 
--Rq:=(x:EXPR(INT)):EXPR(INT)+->2*x+3 
--R(p/q)(4) 
--R(p/q)(x)
--R
--R
--RExamples of / from MatrixCategory
--R
--Rm:=matrix [[2**i for i in 2..4] for j in 1..5] 
--Rm/4
--R
--R
--RExamples of / from MyExpression
--R
--R
--RExamples of / from OutputForm
--R
--R
--RExamples of / from OrdinaryWeightedPolynomials
--R
--R
--RExamples of / from Pattern
--R
--R
--RExamples of / from QuotientFieldCategory
--R
--R
--RExamples of / from RectangularMatrixCategory
--R
--R
--RExamples of / from StochasticDifferential
--R
--R
--RExamples of / from StreamTaylorSeriesOperations
--R
--R
--RExamples of / from VectorSpace
--R
--R
--RExamples of / from WeightedPolynomials
--R
--R
--RExamples of / from XPolynomialRing
--R
--E 7

--S 8 of 3320
)d op **
--R 
--R
--RThere are 22 exposed functions called ** :
--R   [1] (CardinalNumber,CardinalNumber) -> CardinalNumber from 
--R            CardinalNumber
--R   [2] (DoubleFloat,DoubleFloat) -> DoubleFloat from DoubleFloat
--R   [3] (D,Integer) -> D from D if D has DIVRING
--R   [4] (D,D) -> D from D if D has ELEMFUN
--R   [5] (Float,Float) -> Float from Float
--R   [6] (D,NonNegativeInteger) -> D from D
--R             if D has FS(D2) and D2 has ORDSET and D2 has SGROUP
--R   [7] (D,Integer) -> D from D if D has GROUP
--R   [8] (PolynomialIdeals(D2,D3,D4,D5),NonNegativeInteger) -> 
--R            PolynomialIdeals(D2,D3,D4,D5)
--R             from PolynomialIdeals(D2,D3,D4,D5)
--R             if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D5
--R             has POLYCAT(D2,D3,D4)
--R   [9] ((D3 -> D3),NonNegativeInteger) -> (D3 -> D3) from 
--R            MappingPackage1(D3)
--R             if D3 has SETCAT
--R   [10] (D,Integer) -> D from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2) and D2 has FIELD
--R   [11] (D,NonNegativeInteger) -> D from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [12] (ModuleOperator(D2,D3),Integer) -> ModuleOperator(D2,D3)
--R             from ModuleOperator(D2,D3) if D2 has RING and D3 has 
--R            LMODULE(D2)
--R   [13] (BasicOperator,Integer) -> ModuleOperator(D3,D4)
--R             from ModuleOperator(D3,D4) if D3 has RING and D4 has 
--R            LMODULE(D3)
--R   [14] (D,PositiveInteger) -> D from D if D has MONAD
--R   [15] (D,NonNegativeInteger) -> D from D if D has MONADWU
--R   [16] (D,NonNegativeInteger) -> D from D if D has MONOID
--R   [17] (MyExpression(D1,D2),MyExpression(D1,D2)) -> MyExpression(D1,D2
--R            )
--R             from MyExpression(D1,D2)
--R             if D1: SYMBOL and D2 has Join(Ring,OrderedSet,
--R            IntegralDomain)
--R   [18] (D,Fraction(Integer)) -> D from D if D has RADCAT
--R   [19] (StochasticDifferential(D2),PositiveInteger) -> 
--R            StochasticDifferential(D2)
--R             from StochasticDifferential(D2)
--R             if D2 has Join(OrderedSet,IntegralDomain)
--R   [20] (D,PositiveInteger) -> D from D if D has SGROUP
--R   [21] (D,Integer) -> D from D
--R             if D has SMATCAT(D2,D3,D4,D5) and D3 has RING and D4 has 
--R            DIRPCAT(D2,D3) and D5 has DIRPCAT(D2,D3) and D3 has FIELD
--R         
--R   [22] (D,D1) -> D from D if D has UTSCAT(D1) and D1 has RING and D1
--R             has FIELD
--R
--RThere are 18 unexposed functions called ** :
--R   [1] (D1,Fraction(Integer)) -> D1 from AlgebraicFunction(D3,D1)
--R             if D3 has RETRACT(INT) and D3 has Join(OrderedSet,
--R            IntegralDomain) and D1 has FS(D3)
--R   [2] (D1,D1) -> D1 from CombinatorialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R   [3] (D1,Fraction(Integer)) -> D1
--R             from ElementaryFunctionsUnivariateLaurentSeries(D3,D4,D1)
--R             if D3 has FIELD and D3 has ALGEBRA(FRAC(INT)) and D4 has 
--R            UTSCAT(D3) and D1 has ULSCCAT(D3,D4)
--R   [4] (D1,Fraction(Integer)) -> D1
--R             from ElementaryFunctionsUnivariatePuiseuxSeries(D3,D4,D1,
--R            D5)
--R             if D3 has FIELD and D3 has ALGEBRA(FRAC(INT)) and D4 has 
--R            ULSCAT(D3) and D1 has UPXSCCA(D3,D4) and D5 has PTRANFN(D4)
--R            
--R   [5] (D1,Integer) -> FreeGroup(D1) from FreeGroup(D1) if D1 has 
--R            SETCAT
--R   [6] (D1,NonNegativeInteger) -> FreeMonoid(D1) from FreeMonoid(D1)
--R             if D1 has SETCAT
--R   [7] (Vector(D3),Integer) -> Vector(D3)
--R             from InnerNormalBasisFieldFunctions(D3) if D3 has FFIELDC
--R            
--R   [8] (InputForm,Integer) -> InputForm from InputForm
--R   [9] (InputForm,NonNegativeInteger) -> InputForm from InputForm
--R   [10] (Matrix(D3),NonNegativeInteger) -> Matrix(D3)
--R             from StorageEfficientMatrixOperations(D3) if D3 has RING
--R         
--R   [11] (D1,NonNegativeInteger) -> OrderedFreeMonoid(D1)
--R             from OrderedFreeMonoid(D1) if D1 has ORDSET
--R   [12] (Operator(D2),Integer) -> Operator(D2) from Operator(D2) if D2
--R             has RING
--R   [13] (BasicOperator,Integer) -> Operator(D3) from Operator(D3) if D3
--R             has RING
--R   [14] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [15] (Pattern(D1),Pattern(D1)) -> Pattern(D1) from Pattern(D1) if D1
--R             has SETCAT
--R   [16] (Pattern(D2),NonNegativeInteger) -> Pattern(D2) from Pattern(D2
--R            )
--R             if D2 has SETCAT
--R   [17] (Stream(D2),Stream(D2)) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [18] (Stream(D2),Stream(D2)) -> Stream(D2)
--R             from StreamTranscendentalFunctions(D2) if D2 has ALGEBRA(
--R            FRAC(INT))
--R
--RExamples of ** from AlgebraicFunction
--R
--R
--RExamples of ** from CardinalNumber
--R
--Rc2:=2::CardinalNumber 
--Rc2**c2 
--RA1:=Aleph 1 
--RA1**c2 
--RgeneralizedContinuumHypothesisAssumed true 
--RA1**A1
--R
--R
--RExamples of ** from CombinatorialFunction
--R
--R
--RExamples of ** from DoubleFloat
--R
--R
--RExamples of ** from DivisionRing
--R
--R
--RExamples of ** from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of ** from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of ** from ElementaryFunctionCategory
--R
--R
--RExamples of ** from FreeGroup
--R
--R
--RExamples of ** from Float
--R
--R
--RExamples of ** from FreeMonoid
--R
--R
--RExamples of ** from FunctionSpace
--R
--R
--RExamples of ** from Group
--R
--R
--RExamples of ** from PolynomialIdeals
--R
--R
--RExamples of ** from InnerNormalBasisFieldFunctions
--R
--R
--RExamples of ** from InputForm
--R
--R
--RExamples of ** from MappingPackage1
--R
--R
--RExamples of ** from MatrixCategory
--R
--R(matrix [[j**i for i in 0..4] for j in 1..5]) ** 2
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rm**3
--R
--R
--RExamples of ** from StorageEfficientMatrixOperations
--R
--R
--RExamples of ** from ModuleOperator
--R
--R
--RExamples of ** from Monad
--R
--R
--RExamples of ** from MonadWithUnit
--R
--R
--RExamples of ** from Monoid
--R
--R
--RExamples of ** from MyExpression
--R
--R
--RExamples of ** from OrderedFreeMonoid
--R
--Rm1:=(y**3)$OFMONOID(Symbol)
--R
--R
--RExamples of ** from Operator
--R
--R
--RExamples of ** from OutputForm
--R
--R
--RExamples of ** from Pattern
--R
--R
--RExamples of ** from RadicalCategory
--R
--R
--RExamples of ** from StochasticDifferential
--R
--R
--RExamples of ** from SemiGroup
--R
--R
--RExamples of ** from SquareMatrixCategory
--R
--R
--RExamples of ** from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of ** from StreamTranscendentalFunctions
--R
--R
--RExamples of ** from UnivariateTaylorSeriesCategory
--R
--E 8

--S 9 of 3320
)d op /\
--R 
--R
--RThere are 2 exposed functions called /\ :
--R   [1] (D,D) -> D from D if D has LOGIC
--R   [2] (SingleInteger,SingleInteger) -> SingleInteger from 
--R            SingleInteger
--R
--RExamples of /\ from Logic
--R
--R
--RExamples of /\ from SingleInteger
--R
--E 9

--S 10 of 3320
)d op \/
--R 
--R
--RThere are 2 exposed functions called \/ :
--R   [1] (D,D) -> D from D if D has LOGIC
--R   [2] (SingleInteger,SingleInteger) -> SingleInteger from 
--R            SingleInteger
--R
--RExamples of \/ from Logic
--R
--R
--RExamples of \/ from SingleInteger
--R
--E 10

--S 11 of 3320
)d op #
--R 
--R
--RThere are 7 exposed functions called # :
--R   [1] D -> NonNegativeInteger from D if D has finiteAggregate and D
--R             has AGG
--R   [2] ArrayStack(D2) -> NonNegativeInteger from ArrayStack(D2)
--R             if $ has finiteAggregate and D2 has SETCAT
--R   [3] Dequeue(D2) -> NonNegativeInteger from Dequeue(D2)
--R             if $ has finiteAggregate and D2 has SETCAT
--R   [4] Heap(D2) -> NonNegativeInteger from Heap(D2)
--R             if $ has finiteAggregate and D2 has ORDSET
--R   [5] Queue(D2) -> NonNegativeInteger from Queue(D2)
--R             if $ has finiteAggregate and D2 has SETCAT
--R   [6] D -> Integer from D
--R             if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R   [7] Stack(D2) -> NonNegativeInteger from Stack(D2)
--R             if $ has finiteAggregate and D2 has SETCAT
--R
--RThere is one unexposed function called # :
--R   [1] XPolynomialRing(D2,D3) -> NonNegativeInteger from 
--R            XPolynomialRing(D2,D3)
--R             if D2 has RING and D3 has ORDMON
--R
--RExamples of # from Aggregate
--R
--R
--RExamples of # from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--R#a
--R
--R
--RExamples of # from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--R#a
--R
--R
--RExamples of # from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--R#a
--R
--R
--RExamples of # from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--R#a
--R
--R
--RExamples of # from SExpressionCategory
--R
--R
--RExamples of # from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--R#a
--R
--R
--RExamples of # from XPolynomialRing
--R
--E 11

--S 12 of 3320
)d op ^=
--R 
--R
--RThere is one unexposed function called ^= :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of ^= from OutputForm
--R
--E 12

--S 13 of 3320
)d op ^
--R 
--R
--RThere are 7 exposed functions called ^ :
--R   [1] Boolean -> Boolean from Boolean
--R   [2] D -> D from D if D has BTAGG
--R   [3] (D,Integer) -> D from D if D has DIVRING
--R   [4] (D,Integer) -> D from D if D has GROUP
--R   [5] (D,NonNegativeInteger) -> D from D if D has MONOID
--R   [6] (StochasticDifferential(D2),PositiveInteger) -> 
--R            StochasticDifferential(D2)
--R             from StochasticDifferential(D2)
--R             if D2 has Join(OrderedSet,IntegralDomain)
--R   [7] (D,PositiveInteger) -> D from D if D has SGROUP
--R
--RExamples of ^ from Boolean
--R
--R
--RExamples of ^ from BitAggregate
--R
--R
--RExamples of ^ from DivisionRing
--R
--R
--RExamples of ^ from Group
--R
--R
--RExamples of ^ from Monoid
--R
--R
--RExamples of ^ from StochasticDifferential
--R
--R
--RExamples of ^ from SemiGroup
--R
--E 13

--S 14 of 3320
)d op ~=
--R 
--R
--RThere are 6 exposed functions called ~= :
--R   [1] (ArrayStack(D2),ArrayStack(D2)) -> Boolean from ArrayStack(D2)
--R             if D2 has SETCAT and D2 has SETCAT
--R   [2] (D,D) -> Boolean from D if D has BASTYPE
--R   [3] (Dequeue(D2),Dequeue(D2)) -> Boolean from Dequeue(D2)
--R             if D2 has SETCAT and D2 has SETCAT
--R   [4] (Heap(D2),Heap(D2)) -> Boolean from Heap(D2)
--R             if D2 has SETCAT and D2 has ORDSET
--R   [5] (Queue(D2),Queue(D2)) -> Boolean from Queue(D2)
--R             if D2 has SETCAT and D2 has SETCAT
--R   [6] (Stack(D2),Stack(D2)) -> Boolean from Stack(D2)
--R             if D2 has SETCAT and D2 has SETCAT
--R
--RExamples of ~= from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rb:=copy a 
--R(a~=b)
--R
--R
--RExamples of ~= from BasicType
--R
--R
--RExamples of ~= from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rb:=copy a 
--R(a~=b)
--R
--R
--RExamples of ~= from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rb:=copy a 
--R(a~=b)
--R
--R
--RExamples of ~= from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rb:=copy a 
--R(a~=b)
--R
--R
--RExamples of ~= from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rb:=copy a 
--R(a~=b)
--R
--E 14

--S 15 of 3320
)d op <=
--R 
--R
--RThere are 3 exposed functions called <= :
--R   [1] (D,D) -> Boolean from D if D has DIVCAT(D2) and D2 has SETCAT
--R         
--R   [2] (D,D) -> Boolean from D if D has ORDSET
--R   [3] (PermutationGroup(D2),PermutationGroup(D2)) -> Boolean
--R             from PermutationGroup(D2) if D2 has SETCAT
--R
--RThere is one unexposed function called <= :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of <= from DivisorCategory
--R
--R
--RExamples of <= from OrderedSet
--R
--R
--RExamples of <= from OutputForm
--R
--R
--RExamples of <= from PermutationGroup
--R
--E 15

--S 16 of 3320
)d op <
--R 
--R
--RThere are 4 exposed functions called < :
--R   [1] (D,D) -> Boolean from D if D has ORDSET
--R   [2] (D,D) -> Boolean from D if D has PERMCAT(D2) and D2 has SETCAT
--R         
--R   [3] (PermutationGroup(D2),PermutationGroup(D2)) -> Boolean
--R             from PermutationGroup(D2) if D2 has SETCAT
--R   [4] (D,D) -> Boolean from D if D has SETAGG(D2) and D2 has SETCAT
--R         
--R
--RThere is one unexposed function called < :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of < from OrderedSet
--R
--R
--RExamples of < from OutputForm
--R
--R
--RExamples of < from PermutationCategory
--R
--R
--RExamples of < from PermutationGroup
--R
--R
--RExamples of < from SetAggregate
--R
--E 16

--S 17 of 3320
)d op >=
--R 
--R
--RThere is one exposed function called >= :
--R   [1] (D,D) -> Boolean from D if D has ORDSET
--R
--RThere is one unexposed function called >= :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of >= from OrderedSet
--R
--R
--RExamples of >= from OutputForm
--R
--E 17

--S 18 of 3320
)d op >
--R 
--R
--RThere is one exposed function called > :
--R   [1] (D,D) -> Boolean from D if D has ORDSET
--R
--RThere is one unexposed function called > :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of > from OrderedSet
--R
--R
--RExamples of > from OutputForm
--R
--E 18

--S 19 of 3320
--R--)d op 0
--E 19

--S 20 of 3320
--R--)d op 1
--E 20

--S 21 of 3320
)d op abelianGroup
--R 
--R
--RThere is one exposed function called abelianGroup :
--R   [1] List(PositiveInteger) -> PermutationGroup(Integer)
--R             from PermutationGroupExamples
--R
--RExamples of abelianGroup from PermutationGroupExamples
--R
--E 21

--S 22 of 3320
)d op abs
--R 
--R
--RThere are 7 exposed functions called abs :
--R   [1] D -> D from D if D has COMPCAT(D1) and D1 has COMRING and D1
--R             has RNS
--R   [2] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R   [3] D -> D1 from D if D has OC(D1) and D1 has COMRING and D1 has RNS
--R            
--R   [4] D -> D from D if D has ORDRING
--R   [5] D -> D1 from D if D has QUATCAT(D1) and D1 has COMRING and D1
--R             has RNS
--R   [6] D -> D from D if D has RNS
--R   [7] D -> D from D if D has SPFCAT
--R
--RThere is one unexposed function called abs :
--R   [1] D1 -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of abs from ComplexCategory
--R
--R
--RExamples of abs from FortranExpression
--R
--R
--RExamples of abs from FunctionalSpecialFunction
--R
--R
--RExamples of abs from OctonionCategory
--R
--R
--RExamples of abs from OrderedRing
--R
--R
--RExamples of abs from QuaternionCategory
--R
--R
--RExamples of abs from RealNumberSystem
--R
--R
--RExamples of abs from SpecialFunctionCategory
--R
--E 22

--S 23 of 3320 done
)d op absolutelyIrreducible?
--R 
--R
--RThere is one exposed function called absolutelyIrreducible? :
--R   [1]  -> Boolean from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RThere is one unexposed function called absolutelyIrreducible? :
--R   [1]  -> Boolean from FunctionFieldCategory&(D2,D3,D4,D5)
--R             if D3 has UFD and D4 has UPOLYC(D3) and D5 has UPOLYC(FRAC
--R            (D4)) and D2 has FFCAT(D3,D4,D5)
--R
--RExamples of absolutelyIrreducible? from FunctionFieldCategory&
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
--RabsolutelyIrreducible?()$R2
--R
--R
--RExamples of absolutelyIrreducible? from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
--RabsolutelyIrreducible?()$R2
--R
--E 23

--S 24 of 3320
)d op accuracyIF
--R 
--R
--RThere is one exposed function called accuracyIF :
--R   [1] Record(xinit: DoubleFloat,xend: DoubleFloat,fn: Vector(
--R            Expression(DoubleFloat)),yinit: List(DoubleFloat),intvals: List(
--R            DoubleFloat),g: Expression(DoubleFloat),abserr: DoubleFloat,
--R            relerr: DoubleFloat) -> Float
--R             from d02AgentsPackage
--R
--RExamples of accuracyIF from d02AgentsPackage
--R
--E 24

--S 25 of 3320 done
)d op aColumn
--R 
--R
--RThere is one exposed function called aColumn :
--R   [1] (D1,PositiveInteger) -> D1 from MatrixManipulation(D3,D4,D5,D1)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D1 has MATCAT(D3,D4,D5)
--R
--RExamples of aColumn from MatrixManipulation
--R
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--RaColumn(M, 2)
--R
--E 25

--S 26 of 3320
)d op acos
--R 
--R
--RThere are 2 exposed functions called acos :
--R   [1] D -> D from D if D has ATRIG
--R   [2] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R
--RThere are 5 unexposed functions called acos :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of acos from ArcTrigonometricFunctionCategory
--R
--R
--RExamples of acos from ElementaryFunction
--R
--R
--RExamples of acos from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of acos from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of acos from FortranExpression
--R
--R
--RExamples of acos from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of acos from StreamTranscendentalFunctions
--R
--E 26

--S 27 of 3320
)d op acosh
--R 
--R
--RThere is one exposed function called acosh :
--R   [1] D -> D from D if D has AHYP
--R
--RThere are 5 unexposed functions called acosh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of acosh from ArcHyperbolicFunctionCategory
--R
--R
--RExamples of acosh from ElementaryFunction
--R
--R
--RExamples of acosh from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of acosh from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of acosh from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of acosh from StreamTranscendentalFunctions
--R
--E 27

--S 28 of 3320
)d op acoshIfCan
--R 
--R
--RThere is one exposed function called acoshIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of acoshIfCan from PartialTranscendentalFunctions
--R
--E 28

--S 29 of 3320
)d op acosIfCan
--R 
--R
--RThere is one exposed function called acosIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of acosIfCan from PartialTranscendentalFunctions
--R
--E 29

--S 30 of 3320
)d op acot
--R 
--R
--RThere is one exposed function called acot :
--R   [1] D -> D from D if D has ATRIG
--R
--RThere are 5 unexposed functions called acot :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of acot from ArcTrigonometricFunctionCategory
--R
--R
--RExamples of acot from ElementaryFunction
--R
--R
--RExamples of acot from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of acot from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of acot from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of acot from StreamTranscendentalFunctions
--R
--E 30

--S 31 of 3320
)d op acoth
--R 
--R
--RThere is one exposed function called acoth :
--R   [1] D -> D from D if D has AHYP
--R
--RThere are 5 unexposed functions called acoth :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of acoth from ArcHyperbolicFunctionCategory
--R
--R
--RExamples of acoth from ElementaryFunction
--R
--R
--RExamples of acoth from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of acoth from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of acoth from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of acoth from StreamTranscendentalFunctions
--R
--E 31

--S 32 of 3320
)d op acothIfCan
--R 
--R
--RThere is one exposed function called acothIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of acothIfCan from PartialTranscendentalFunctions
--R
--E 32

--S 33 of 3320
)d op acotIfCan
--R 
--R
--RThere is one exposed function called acotIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of acotIfCan from PartialTranscendentalFunctions
--R
--E 33

--S 34 of 3320
)d op acsc
--R 
--R
--RThere is one exposed function called acsc :
--R   [1] D -> D from D if D has ATRIG
--R
--RThere are 5 unexposed functions called acsc :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of acsc from ArcTrigonometricFunctionCategory
--R
--R
--RExamples of acsc from ElementaryFunction
--R
--R
--RExamples of acsc from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of acsc from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of acsc from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of acsc from StreamTranscendentalFunctions
--R
--E 34

--S 35 of 3320
)d op acsch
--R 
--R
--RThere is one exposed function called acsch :
--R   [1] D -> D from D if D has AHYP
--R
--RThere are 5 unexposed functions called acsch :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of acsch from ArcHyperbolicFunctionCategory
--R
--R
--RExamples of acsch from ElementaryFunction
--R
--R
--RExamples of acsch from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of acsch from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of acsch from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of acsch from StreamTranscendentalFunctions
--R
--E 35

--S 36 of 3320
)d op acsch 
--R 
--R
--RThere is one exposed function called acsch :
--R   [1] D -> D from D if D has AHYP
--R
--RThere are 5 unexposed functions called acsch :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of acsch from ArcHyperbolicFunctionCategory
--R
--R
--RExamples of acsch from ElementaryFunction
--R
--R
--RExamples of acsch from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of acsch from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of acsch from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of acsch from StreamTranscendentalFunctions
--R
--E 36

--S 37 of 3320
)d op acschIfCan
--R 
--R
--RThere is one exposed function called acschIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of acschIfCan from PartialTranscendentalFunctions
--R
--E 37

--S 38 of 3320
)d op acscIfCan
--R 
--R
--RThere is one exposed function called acscIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of acscIfCan from PartialTranscendentalFunctions
--R
--E 38

--S 39 of 3320
)d op actualExtensionV
--R 
--R
--RThere is one exposed function called actualExtensionV :
--R   [1] D -> D2 from D
--R             if D has INFCLCT(D2,D3,D4,D5,D6,D7,D8,D9,D1) and D4 has 
--R            POLYCAT(D2,D5,OVAR(D3)) and D5 has DIRPCAT(#(D3),NNI) and 
--R            D6 has PRSPCAT(D2) and D7 has LOCPOWC(D2) and D8 has 
--R            PLACESC(D2,D7) and D1 has BLMETCT and D2 has FIELD
--R
--RExamples of actualExtensionV from InfinitlyClosePointCategory
--R
--E 39

--S 40 of 3320
)d op aCubic
--R 
--R
--RThere is one unexposed function called aCubic :
--R   [1] (D2,D2,D2,D2) -> D2 from PolynomialSolveByFormulas(D3,D2)
--R             if D2 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D3 has UPOLYC(D2)
--R            
--R
--RExamples of aCubic from PolynomialSolveByFormulas
--R
--E 40

--S 41 of 3320
)d op adaptive
--R 
--R
--RThere are 3 exposed functions called adaptive :
--R   [1] Boolean -> DrawOption from DrawOption
--R   [2]  -> Boolean from GraphicsDefaults
--R   [3] Boolean -> Boolean from GraphicsDefaults
--R
--RThere is one unexposed function called adaptive :
--R   [1] (List(DrawOption),Boolean) -> Boolean from DrawOptionFunctions0
--R            
--R
--RExamples of adaptive from DrawOptionFunctions0
--R
--R
--RExamples of adaptive from DrawOption
--R
--R
--RExamples of adaptive from GraphicsDefaults
--R
--E 41

--S 42 of 3320
)d op adaptive?
--R 
--R
--RThere is one unexposed function called adaptive? :
--R   [1]  -> Boolean from Plot
--R
--RExamples of adaptive? from Plot
--R
--E 42

--S 43 of 3320
)d op adaptive3D?
--R 
--R
--RThere is one unexposed function called adaptive3D? :
--R   [1]  -> Boolean from Plot3D
--R
--RExamples of adaptive3D? from Plot3D
--R
--E 43

--S 44 of 3320
)d op addBadValue
--R 
--R
--RThere are 2 unexposed functions called addBadValue :
--R   [1] (Pattern(D3),D2) -> Pattern(D3) from PatternFunctions1(D3,D2)
--R             if D3 has SETCAT and D2 has TYPE
--R   [2] (Pattern(D2),Any) -> Pattern(D2) from Pattern(D2) if D2 has 
--R            SETCAT
--R
--RExamples of addBadValue from PatternFunctions1
--R
--R
--RExamples of addBadValue from Pattern
--R
--E 44

--S 45 of 3320
)d op addiag
--R 
--R
--RThere is one unexposed function called addiag :
--R   [1] Stream(Stream(D3)) -> Stream(D3) from 
--R            StreamTaylorSeriesOperations(D3)
--R             if D3 has RING
--R
--RExamples of addiag from StreamTaylorSeriesOperations
--R
--E 45

--S 46 of 3320
)d op additive?
--R 
--R
--RThere is one exposed function called additive? :
--R   [1] (DirichletRing(D3),PositiveInteger) -> Boolean from 
--R            DirichletRing(D3)
--R             if D3 has RING
--R
--RExamples of additive? from DirichletRing
--R
--E 46

--S 47 of 3320
)d op addMatch
--R 
--R
--RThere is one unexposed function called addMatch :
--R   [1] (Pattern(D3),D2,PatternMatchResult(D3,D2)) -> PatternMatchResult
--R            (D3,D2)
--R             from PatternMatchResult(D3,D2) if D3 has SETCAT and D2
--R             has SETCAT
--R
--RExamples of addMatch from PatternMatchResult
--R
--E 47

--S 48 of 3320
)d op addMatchRestricted
--R 
--R
--RThere is one unexposed function called addMatchRestricted :
--R   [1] (Pattern(D3),D2,PatternMatchResult(D3,D2),D2) -> 
--R            PatternMatchResult(D3,D2)
--R             from PatternMatchResult(D3,D2) if D3 has SETCAT and D2
--R             has SETCAT
--R
--RExamples of addMatchRestricted from PatternMatchResult
--R
--E 48

--S 49 of 3320
)d op addmod
--R 
--R
--RThere is one exposed function called addmod :
--R   [1] (D,D,D) -> D from D if D has INS
--R
--RExamples of addmod from IntegerNumberSystem
--R
--E 49

--S 50 of 3320
)d op addPoint
--R 
--R
--RThere are 3 unexposed functions called addPoint :
--R   [1] (SubSpace(D3,D4),Point(D4)) -> NonNegativeInteger from SubSpace(
--R            D3,D4)
--R             if D4 has RING and D3: PI
--R   [2] (SubSpace(D3,D4),List(NonNegativeInteger),NonNegativeInteger)
--R             -> SubSpace(D3,D4)
--R             from SubSpace(D3,D4) if D3: PI and D4 has RING
--R   [3] (SubSpace(D3,D4),List(NonNegativeInteger),Point(D4)) -> SubSpace
--R            (D3,D4)
--R             from SubSpace(D3,D4) if D4 has RING and D3: PI
--R
--RExamples of addPoint from SubSpace
--R
--E 50

--S 51 of 3320
)d op addPoint2
--R 
--R
--RThere is one unexposed function called addPoint2 :
--R   [1] (SubSpace(D2,D3),Point(D3)) -> SubSpace(D2,D3) from SubSpace(D2,
--R            D3)
--R             if D3 has RING and D2: PI
--R
--RExamples of addPoint2 from SubSpace
--R
--E 51

--S 52 of 3320
)d op addPointLast
--R 
--R
--RThere is one unexposed function called addPointLast :
--R   [1] (SubSpace(D3,D4),SubSpace(D3,D4),Point(D4),NonNegativeInteger)
--R             -> SubSpace(D3,D4)
--R             from SubSpace(D3,D4) if D4 has RING and D3: PI
--R
--RExamples of addPointLast from SubSpace
--R
--E 52

--S 53 of 3320
)d op adjoint
--R 
--R
--RThere are 4 exposed functions called adjoint :
--R   [1] D -> D from D if D has LODOCAT(D1) and D1 has RING
--R   [2] D2 -> Record(adjMat: D2,detMat: D3)
--R             from MatrixLinearAlgebraFunctions(D3,D4,D5,D2)
--R             if D3 has INTDOM and D3 has COMRING and D4 has FLAGG(D3) 
--R            and D5 has FLAGG(D3) and D2 has MATCAT(D3,D4,D5)
--R   [3] (ModuleOperator(D1,D2),ModuleOperator(D1,D2)) -> ModuleOperator(
--R            D1,D2)
--R             from ModuleOperator(D1,D2)
--R             if D1 has COMRING and D1 has RING and D2 has LMODULE(D1)
--R         
--R   [4] ModuleOperator(D1,D2) -> ModuleOperator(D1,D2) from 
--R            ModuleOperator(D1,D2)
--R             if D1 has COMRING and D1 has RING and D2 has LMODULE(D1)
--R         
--R
--RThere are 2 unexposed functions called adjoint :
--R   [1] (Operator(D1),Operator(D1)) -> Operator(D1) from Operator(D1)
--R             if D1 has COMRING and D1 has RING
--R   [2] Operator(D1) -> Operator(D1) from Operator(D1)
--R             if D1 has COMRING and D1 has RING
--R
--RExamples of adjoint from LinearOrdinaryDifferentialOperatorCategory
--R
--R
--RExamples of adjoint from MatrixLinearAlgebraFunctions
--R
--R
--RExamples of adjoint from ModuleOperator
--R
--R
--RExamples of adjoint from Operator
--R
--E 53

--S 54 of 3320
)d op adjunctionDivisor
--R 
--R
--RThere are 4 exposed functions called adjunctionDivisor :
--R   [1] D5 -> D4 from DesingTreePackage(D6,D7,D8,D9,D10,D11,D1,D4,D2,D5,
--R            D3)
--R             if D6 has FIELD and D7: LIST(SYMBOL) and D8 has POLYCAT(D6
--R            ,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI) and D10 has 
--R            PRSPCAT(D6) and D11 has LOCPOWC(D6) and D1 has PLACESC(D6,
--R            D11) and D2 has INFCLCT(D6,D7,D8,D9,D10,D11,D1,D4,D3) and 
--R            D3 has BLMETCT and D4 has DIVCAT(D1) and D5 has DSTRCAT(D2)
--R            
--R   [2]  -> D4
--R             from GeneralPackageForAlgebraicFunctionField(D5,D6,D7,D8,
--R            D9,D10,D11,D4,D1,D2,D3)
--R             if D5 has FIELD and D6: LIST(SYMBOL) and D7 has POLYCAT(D5
--R            ,D8,OVAR(D6)) and D8 has DIRPCAT(#(D6),NNI) and D9 has 
--R            PRSPCAT(D5) and D10 has LOCPOWC(D5) and D11 has PLACESC(D5,
--R            D10) and D1 has INFCLCT(D5,D6,D7,D8,D9,D10,D11,D4,D3) and 
--R            D3 has BLMETCT and D4 has DIVCAT(D11) and D2 has DSTRCAT(D1
--R            )
--R   [3]  -> Divisor(PlacesOverPseudoAlgebraicClosureOfFiniteField(D2))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [4]  -> Divisor(Places(D2)) from PackageForAlgebraicFunctionField(D2
--R            ,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R
--RExamples of adjunctionDivisor from DesingTreePackage
--R
--R
--RExamples of adjunctionDivisor from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of adjunctionDivisor from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of adjunctionDivisor from PackageForAlgebraicFunctionField
--R
--E 54

--S 55 of 3320
)d op affineAlgSet
--R 
--R
--RThere are 2 exposed functions called affineAlgSet :
--R   [1] List(D5) -> Union(List(D7),"failed",Infinite,Integer)
--R             from AffineAlgebraicSetComputeWithGroebnerBasis(D3,D4,D5,
--R            D6,D7)
--R             if D5 has POLYCAT(D3,D6,OVAR(D4)) and D6 has DIRPCAT(#(D4)
--R            ,NNI) and D3 has FIELD and D4: LIST(SYMBOL) and D7 has 
--R            PRSPCAT(D3)
--R   [2] List(D5) -> Union(List(D7),"failed",Infinite,Integer)
--R             from AffineAlgebraicSetComputeWithResultant(D3,D4,D5,D6,D7
--R            )
--R             if D5 has POLYCAT(D3,D6,OVAR(D4)) and D6 has DIRPCAT(#(D4)
--R            ,NNI) and D3 has FIELD and D4: LIST(SYMBOL) and D7 has 
--R            PRSPCAT(D3)
--R
--RExamples of affineAlgSet from AffineAlgebraicSetComputeWithGroebnerBasis
--R
--R
--RExamples of affineAlgSet from AffineAlgebraicSetComputeWithResultant
--R
--E 55

--S 56 of 3320
)d op affineAlgSetLocal
--R 
--R
--RThere is one exposed function called affineAlgSetLocal :
--R   [1] List(SparseUnivariatePolynomial(SparseUnivariatePolynomial(D3)))
--R             -> Union(List(D7),"failed",Infinite,Integer)
--R             from AffineAlgebraicSetComputeWithResultant(D3,D4,D5,D6,D7
--R            )
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D6 has DIRPCAT(#(
--R            D4),NNI) and D5 has POLYCAT(D3,D6,OVAR(D4)) and D7 has 
--R            PRSPCAT(D3)
--R
--RExamples of affineAlgSetLocal from AffineAlgebraicSetComputeWithResultant
--R
--E 56

--S 57 of 3320
)d op affinePoint
--R 
--R
--RThere is one exposed function called affinePoint :
--R   [1] List(D2) -> D from D if D2 has FIELD and D has AFSPCAT(D2)
--R
--RExamples of affinePoint from AffineSpaceCategory
--R
--E 57

--S 58 of 3320
)d op affineRationalPoints
--R 
--R
--RThere are 2 exposed functions called affineRationalPoints :
--R   [1] (D2,PositiveInteger) -> List(D7)
--R             from AffineAlgebraicSetComputeWithGroebnerBasis(D4,D5,D2,
--R            D6,D7)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D6 has DIRPCAT(#(
--R            D5),NNI) and D2 has POLYCAT(D4,D6,OVAR(D5)) and D7 has 
--R            PRSPCAT(D4)
--R   [2] (D2,PositiveInteger) -> Union(List(D7),"failed",Infinite,Integer
--R            )
--R             from AffineAlgebraicSetComputeWithResultant(D4,D5,D2,D6,D7
--R            )
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D6 has DIRPCAT(#(
--R            D5),NNI) and D2 has POLYCAT(D4,D6,OVAR(D5)) and D7 has 
--R            PRSPCAT(D4)
--R
--RExamples of affineRationalPoints from AffineAlgebraicSetComputeWithGroebnerBasis
--R
--R
--RExamples of affineRationalPoints from AffineAlgebraicSetComputeWithResultant
--R
--E 58

--S 59 of 3320
)d op affineSingularPoints
--R 
--R
--RThere are 3 exposed functions called affineSingularPoints :
--R   [1] D2 -> Union(List(D6),"failed",Infinite,Integer)
--R             from AffineAlgebraicSetComputeWithGroebnerBasis(D3,D4,D2,
--R            D5,D6)
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D5 has DIRPCAT(#(
--R            D4),NNI) and D2 has POLYCAT(D3,D5,OVAR(D4)) and D6 has 
--R            PRSPCAT(D3)
--R   [2] D2 -> Union(List(D6),"failed",Infinite,Integer)
--R             from AffineAlgebraicSetComputeWithResultant(D3,D4,D2,D5,D6
--R            )
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D5 has DIRPCAT(#(
--R            D4),NNI) and D2 has POLYCAT(D3,D5,OVAR(D4)) and D6 has 
--R            PRSPCAT(D3)
--R   [3] SparseUnivariatePolynomial(SparseUnivariatePolynomial(D3)) -> 
--R            Union(List(D7),"failed",Infinite,Integer)
--R             from AffineAlgebraicSetComputeWithResultant(D3,D4,D5,D6,D7
--R            )
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D6 has DIRPCAT(#(
--R            D4),NNI) and D5 has POLYCAT(D3,D6,OVAR(D4)) and D7 has 
--R            PRSPCAT(D3)
--R
--RExamples of affineSingularPoints from AffineAlgebraicSetComputeWithGroebnerBasis
--R
--R
--RExamples of affineSingularPoints from AffineAlgebraicSetComputeWithResultant
--R
--E 59

--S 60 of 3320
)d op airyAi
--R 
--R
--RThere are 3 exposed functions called airyAi :
--R   [1] Complex(DoubleFloat) -> Complex(DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R   [2] DoubleFloat -> DoubleFloat from DoubleFloatSpecialFunctions
--R   [3] D -> D from D if D has SPFCAT
--R
--RThere is one unexposed function called airyAi :
--R   [1] D1 -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of airyAi from DoubleFloatSpecialFunctions
--R
--R
--RExamples of airyAi from FunctionalSpecialFunction
--R
--R
--RExamples of airyAi from SpecialFunctionCategory
--R
--E 60

--S 61 of 3320
)d op airyBi
--R 
--R
--RThere are 3 exposed functions called airyBi :
--R   [1] DoubleFloat -> DoubleFloat from DoubleFloatSpecialFunctions
--R   [2] Complex(DoubleFloat) -> Complex(DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R   [3] D -> D from D if D has SPFCAT
--R
--RThere is one unexposed function called airyBi :
--R   [1] D1 -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of airyBi from DoubleFloatSpecialFunctions
--R
--R
--RExamples of airyBi from FunctionalSpecialFunction
--R
--R
--RExamples of airyBi from SpecialFunctionCategory
--R
--E 61

--S 62 of 3320 done
)d op Aleph
--R 
--R
--RThere is one exposed function called Aleph :
--R   [1] NonNegativeInteger -> CardinalNumber from CardinalNumber
--R
--RExamples of Aleph from CardinalNumber
--R
--RA0:=Aleph 0
--R
--E 62

--S 63 of 3320
)d op algDsolve
--R 
--R
--RThere is one unexposed function called algDsolve :
--R   [1] (LinearOrdinaryDifferentialOperator1(D3),D3) -> Record(
--R            particular: Union(D3,"failed"),basis: List(D3))
--R             from PureAlgebraicLODE(D4,D5,D6,D3)
--R             if D3 has FFCAT(D4,D5,D6) and D4 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer),RetractableTo(
--R            Fraction(Integer))) and D5 has UPOLYC(D4) and D6 has UPOLYC
--R            (FRAC(D5))
--R
--RExamples of algDsolve from PureAlgebraicLODE
--R
--E 63

--S 64 of 3320
)d op algebraic?
--R 
--R
--RThere are 2 exposed functions called algebraic? :
--R   [1] (D2,D) -> Boolean from D
--R             if D has TSETCAT(D3,D4,D2,D5) and D3 has INTDOM and D4
--R             has OAMONS and D2 has ORDSET and D5 has RPOLCAT(D3,D4,D2)
--R            
--R   [2] D -> Boolean from D if D has XF(D2) and D2 has FIELD
--R
--RExamples of algebraic? from TriangularSetCategory
--R
--R
--RExamples of algebraic? from ExtensionField
--R
--E 64

--S 65 of 3320
)d op algebraicCoefficients?
--R 
--R
--RThere is one exposed function called algebraicCoefficients? :
--R   [1] (D2,D) -> Boolean from D
--R             if D has RSETCAT(D3,D4,D5,D2) and D3 has GCDDOM and D4
--R             has OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R            
--R
--RExamples of algebraicCoefficients? from RegularTriangularSetCategory
--R
--E 65

--S 66 of 3320
)d op algebraicDecompose
--R 
--R
--RThere are 2 exposed functions called algebraicDecompose :
--R   [1] (D2,D3,Boolean) -> Record(done: List(D3),todo: List(Record(val: 
--R            List(D2),tower: D3)))
--R             from RegularSetDecompositionPackage(D5,D6,D7,D2,D3)
--R             if D5 has GCDDOM and D6 has OAMONS and D7 has ORDSET and 
--R            D2 has RPOLCAT(D5,D6,D7) and D3 has RSETCAT(D5,D6,D7,D2)
--R         
--R   [2] (D2,D3) -> Record(done: List(D3),todo: List(Record(val: List(D2)
--R            ,tower: D3)))
--R             from SquareFreeRegularSetDecompositionPackage(D4,D5,D6,D2,
--R            D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has SFRTCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of algebraicDecompose from RegularSetDecompositionPackage
--R
--R
--RExamples of algebraicDecompose from SquareFreeRegularSetDecompositionPackage
--R
--E 66

--S 67 of 3320
)d op algebraicOf
--R 
--R
--RThere is one exposed function called algebraicOf :
--R   [1] (RightOpenIntervalRootCharacterization(RealClosure(D3),
--R            SparseUnivariatePolynomial(RealClosure(D3))),OutputForm) -> 
--R            RealClosure(D3)
--R             from RealClosure(D3) if D3 has Join(OrderedRing,Field,
--R            RealConstant)
--R
--RExamples of algebraicOf from RealClosure
--R
--E 67

--S 68 of 3320
)d op algebraicSet
--R 
--R
--RThere is one exposed function called algebraicSet :
--R   [1] List(D5) -> List(D7) from ProjectiveAlgebraicSetPackage(D3,D4,D5
--R            ,D6,D7)
--R             if D5 has POLYCAT(D3,D6,OVAR(D4)) and D6 has DIRPCAT(#(D4)
--R            ,NNI) and D3 has FIELD and D4: LIST(SYMBOL) and D7 has 
--R            PRSPCAT(D3)
--R
--RExamples of algebraicSet from ProjectiveAlgebraicSetPackage
--R
--E 68

--S 69 of 3320
)d op algebraicSort
--R 
--R
--RThere are 2 exposed functions called algebraicSort :
--R   [1] List(D6) -> List(D6) from QuasiComponentPackage(D2,D3,D4,D5,D6)
--R             if D6 has RSETCAT(D2,D3,D4,D5) and D2 has GCDDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R   [2] List(D6) -> List(D6) from SquareFreeQuasiComponentPackage(D2,D3,
--R            D4,D5,D6)
--R             if D6 has RSETCAT(D2,D3,D4,D5) and D2 has GCDDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R
--RExamples of algebraicSort from QuasiComponentPackage
--R
--R
--RExamples of algebraicSort from SquareFreeQuasiComponentPackage
--R
--E 69

--S 70 of 3320
)d op algebraicVariables
--R 
--R
--RThere is one exposed function called algebraicVariables :
--R   [1] D -> List(D4) from D
--R             if D has TSETCAT(D2,D3,D4,D5) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R
--RExamples of algebraicVariables from TriangularSetCategory
--R
--E 70

--S 71 of 3320
)d op algint
--R 
--R
--RThere is one unexposed function called algint :
--R   [1] (D2,Kernel(D2),Kernel(D2),(SparseUnivariatePolynomial(D2) -> 
--R            SparseUnivariatePolynomial(D2))) -> IntegrationResult(D2)
--R             from AlgebraicIntegration(D5,D2)
--R             if D2 has Join(AlgebraicallyClosedField,FunctionSpace(D5))
--R            and D5 has Join(OrderedSet,IntegralDomain)
--R
--RExamples of algint from AlgebraicIntegration
--R
--E 71

--S 72 of 3320
)d op algintegrate
--R 
--R
--RThere is one unexposed function called algintegrate :
--R   [1] (D2,(D6 -> D6)) -> IntegrationResult(D2)
--R             from AlgebraicIntegrate(D4,D5,D6,D7,D2)
--R             if D6 has UPOLYC(D5) and D5 has Join(
--R            AlgebraicallyClosedField,FunctionSpace(D4)) and D4 has Join
--R            (OrderedSet,IntegralDomain,RetractableTo(Integer)) and D7
--R             has UPOLYC(FRAC(D6)) and D2 has FFCAT(D5,D6,D7)
--R
--RExamples of algintegrate from AlgebraicIntegrate
--R
--E 72

--S 73 of 3320
)d op algSplitSimple
--R 
--R
--RThere is one exposed function called algSplitSimple :
--R   [1] (D,(D4 -> D4)) -> Record(num: D,den: D4,derivden: D4,gd: D4)
--R             from D
--R             if D4 has UPOLYC(D3) and D3 has UFD and D5 has UPOLYC(FRAC
--R            (D4)) and D has FFCAT(D3,D4,D5)
--R
--RExamples of algSplitSimple from FunctionFieldCategory
--R
--E 73

--S 74 of 3320
)d op aLinear
--R 
--R
--RThere is one unexposed function called aLinear :
--R   [1] (D2,D2) -> D2 from PolynomialSolveByFormulas(D3,D2)
--R             if D2 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D3 has UPOLYC(D2)
--R            
--R
--RExamples of aLinear from PolynomialSolveByFormulas
--R
--E 74

--S 75 of 3320
)d op allDegrees
--R 
--R
--RThere is one exposed function called allDegrees :
--R   [1] Boolean -> GuessOption from GuessOption
--R
--RThere is one unexposed function called allDegrees :
--R   [1] List(GuessOption) -> Boolean from GuessOptionFunctions0
--R
--RExamples of allDegrees from GuessOptionFunctions0
--R
--R
--RExamples of allDegrees from GuessOption
--R
--E 75

--S 76 of 3320
)d op allIndices
--R 
--R
--RThere is one exposed function called allIndices :
--R   [1] SparseEchelonMatrix(D2,D3) -> List(D2) from SparseEchelonMatrix(
--R            D2,D3)
--R             if D2 has ORDSET and D3 has RING
--R
--RExamples of allIndices from SparseEchelonMatrix
--R
--E 76

--S 77 of 3320
)d op allPairsAmong
--R 
--R
--RThere is one exposed function called allPairsAmong :
--R   [1] List(SparseUnivariatePolynomial(SparseUnivariatePolynomial(D3)))
--R             -> List(List(SparseUnivariatePolynomial(
--R            SparseUnivariatePolynomial(D3))))
--R             from AffineAlgebraicSetComputeWithResultant(D3,D4,D5,D6,D7
--R            )
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D6 has DIRPCAT(#(
--R            D4),NNI) and D5 has POLYCAT(D3,D6,OVAR(D4)) and D7 has 
--R            PRSPCAT(D3)
--R
--RExamples of allPairsAmong from AffineAlgebraicSetComputeWithResultant
--R
--E 77

--S 78 of 3320
)d op allRootsOf
--R 
--R
--RThere are 7 exposed functions called allRootsOf :
--R   [1] Polynomial(Integer) -> List(D) from D if D has RCFIELD
--R   [2] Polynomial(Fraction(Integer)) -> List(D) from D if D has RCFIELD
--R            
--R   [3] Polynomial(D) -> List(D) from D if D has RCFIELD
--R   [4] SparseUnivariatePolynomial(Integer) -> List(D) from D if D has 
--R            RCFIELD
--R   [5] SparseUnivariatePolynomial(Fraction(Integer)) -> List(D) from D
--R             if D has RCFIELD
--R   [6] SparseUnivariatePolynomial(D) -> List(D) from D if D has RCFIELD
--R            
--R   [7] D2 -> List(D) from D
--R             if D3 has Join(OrderedRing,Field) and D2 has UPOLYC(D3) 
--R            and D has RRCC(D3,D2)
--R
--RExamples of allRootsOf from RealClosedField
--R
--R
--RExamples of allRootsOf from RealRootCharacterizationCategory
--R
--E 78

--S 79 of 3320
)d op allSimpleCells
--R 
--R
--RThere are 2 exposed functions called allSimpleCells :
--R   [1] (List(D5),Symbol) -> List(SimpleCell(D4,D5)) from SimpleCell(D4,
--R            D5)
--R             if D5 has UPOLYC(D4) and D4 has RCFIELD
--R   [2] (D2,Symbol) -> List(SimpleCell(D4,D2)) from SimpleCell(D4,D2)
--R             if D4 has RCFIELD and D2 has UPOLYC(D4)
--R
--RExamples of allSimpleCells from SimpleCell
--R
--E 79

--S 80 of 3320
)d op alphabetic 
--R 
--R
--RThere is one exposed function called alphabetic :
--R   [1]  -> CharacterClass from CharacterClass
--R
--RExamples of alphabetic from CharacterClass
--R
--E 80

--S 81 of 3320 done
)d op alphabetic?
--R 
--R
--RThere is one exposed function called alphabetic? :
--R   [1] Character -> Boolean from Character
--R
--RExamples of alphabetic? from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[alphabetic? c for c in chars]
--R
--E 81

--S 82 of 3320
)d op alphanumeric
--R 
--R
--RThere is one exposed function called alphanumeric :
--R   [1]  -> CharacterClass from CharacterClass
--R
--RExamples of alphanumeric from CharacterClass
--R
--E 82

--S 83 of 3320 done
)d op alphanumeric?
--R 
--R
--RThere is one exposed function called alphanumeric? :
--R   [1] Character -> Boolean from Character
--R
--RExamples of alphanumeric? from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[alphanumeric? c for c in chars]
--R
--E 83

--S 84 of 3320
)d op alterDrift!
--R 
--R
--RThere is one exposed function called alterDrift! :
--R   [1] (BasicStochasticDifferential,StochasticDifferential(D2)) -> 
--R            Union(StochasticDifferential(D2),"failed")
--R             from StochasticDifferential(D2)
--R             if D2 has Join(OrderedSet,IntegralDomain)
--R
--RExamples of alterDrift! from StochasticDifferential
--R
--E 84

--S 85 of 3320
)d op alternating
--R 
--R
--RThere is one exposed function called alternating :
--R   [1] Integer -> SymmetricPolynomial(Fraction(Integer)) from 
--R            CycleIndicators
--R
--RExamples of alternating from CycleIndicators
--R
--E 85

--S 86 of 3320
)d op alternatingGroup
--R 
--R
--RThere are 2 exposed functions called alternatingGroup :
--R   [1] PositiveInteger -> PermutationGroup(Integer)
--R             from PermutationGroupExamples
--R   [2] List(Integer) -> PermutationGroup(Integer) from 
--R            PermutationGroupExamples
--R
--RExamples of alternatingGroup from PermutationGroupExamples
--R
--E 86

--S 87 of 3320
)d op alternative?
--R 
--R
--RThere is one exposed function called alternative? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called alternative? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of alternative? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of alternative? from FiniteRankNonAssociativeAlgebra
--R
--E 87

--S 88 of 3320
)d op alterQuadVar!
--R 
--R
--RThere is one exposed function called alterQuadVar! :
--R   [1] (BasicStochasticDifferential,BasicStochasticDifferential,
--R            StochasticDifferential(D2)) -> Union(StochasticDifferential(D2),
--R            "failed")
--R             from StochasticDifferential(D2)
--R             if D2 has Join(OrderedSet,IntegralDomain)
--R
--RExamples of alterQuadVar! from StochasticDifferential
--R
--E 88

--S 89 of 3320
)d op An
--R 
--R
--RThere is one unexposed function called An :
--R   [1] ModMonic(D2,D3) -> Vector(D2) from ModMonic(D2,D3)
--R             if D2 has RING and D3 has UPOLYC(D2)
--R
--RExamples of An from ModMonic
--R
--E 89

--S 90 of 3320
)d op and
--R 
--R
--RThere are 2 exposed functions called and :
--R   [1] (Boolean,Boolean) -> Boolean from Boolean
--R   [2] (D,D) -> D from D if D has BTAGG
--R
--RThere is one unexposed function called and :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of and from Boolean
--R
--R
--RExamples of and from BitAggregate
--R
--R
--RExamples of and from OutputForm
--R
--E 90

--S 91 of 3320
)d op And
--R 
--R
--RThere is one exposed function called And :
--R   [1] (SingleInteger,SingleInteger) -> SingleInteger from 
--R            SingleInteger
--R
--RThere is one unexposed function called And :
--R   [1] (IndexedBits(D1),IndexedBits(D1)) -> IndexedBits(D1) from 
--R            IndexedBits(D1)
--R             if D1: INT
--R
--RExamples of And from IndexedBits
--R
--R
--RExamples of And from SingleInteger
--R
--E 91

--S 92 of 3320
)d op AND
--R 
--R
--RThere is one exposed function called AND :
--R   [1] (Union(I: Expression(Integer),F: Expression(Float),CF: 
--R            Expression(Complex(Float)),switch: Switch),Union(I: Expression(
--R            Integer),F: Expression(Float),CF: Expression(Complex(Float)),
--R            switch: Switch)) -> Switch
--R             from Switch
--R
--RExamples of AND from Switch
--R
--E 92

--S 93 of 3320
)d op anfactor
--R 
--R
--RThere is one unexposed function called anfactor :
--R   [1] D2 -> Union(Factored(SparseUnivariatePolynomial(AlgebraicNumber)
--R            ),"failed")
--R             from FunctionSpaceUnivariatePolynomialFactor(D3,D4,D2)
--R             if D4 has RETRACT(AN) and D3 has Join(IntegralDomain,
--R            OrderedSet,RetractableTo(Integer)) and D4 has FS(D3) and D2
--R             has UPOLYC(D4)
--R
--RExamples of anfactor from FunctionSpaceUnivariatePolynomialFactor
--R
--E 93

--S 94 of 3320
)d op antiAssociative?
--R 
--R
--RThere is one exposed function called antiAssociative? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called antiAssociative? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of antiAssociative? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of antiAssociative? from FiniteRankNonAssociativeAlgebra
--R
--E 94

--S 95 of 3320
)d op antiCommutative?
--R 
--R
--RThere is one exposed function called antiCommutative? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called antiCommutative? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of antiCommutative? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of antiCommutative? from FiniteRankNonAssociativeAlgebra
--R
--E 95

--S 96 of 3320
)d op antiCommutator
--R 
--R
--RThere is one exposed function called antiCommutator :
--R   [1] (D,D) -> D from D if D has NARNG
--R
--RExamples of antiCommutator from NonAssociativeRng
--R
--E 96

--S 97 of 3320
)d op anticoord
--R 
--R
--RThere is one unexposed function called anticoord :
--R   [1] (List(D5),DistributedMultivariatePolynomial(D4,D5),List(
--R            DistributedMultivariatePolynomial(D4,D5))) -> 
--R            DistributedMultivariatePolynomial(D4,D5)
--R             from LinGroebnerPackage(D4,D5) if D5 has GCDDOM and D4: 
--R            LIST(SYMBOL)
--R
--RExamples of anticoord from LinGroebnerPackage
--R
--E 97

--S 98 of 3320
)d op antisymmetric?
--R 
--R
--RThere are 2 exposed functions called antisymmetric? :
--R   [1] D -> Boolean from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [2] D -> Boolean from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of antisymmetric? from MatrixCategory
--R
--Rantisymmetric? matrix [[j**i for i in 0..4] for j in 1..5]
--R
--R
--RExamples of antisymmetric? from RectangularMatrixCategory
--R
--E 98

--S 99 of 3320
)d op antisymmetricTensors
--R 
--R
--RThere are 2 exposed functions called antisymmetricTensors :
--R   [1] (Matrix(D3),PositiveInteger) -> Matrix(D3)
--R             from RepresentationPackage1(D3) if D3 has commutative(*) 
--R            and D3 has RING
--R   [2] (List(Matrix(D3)),PositiveInteger) -> List(Matrix(D3))
--R             from RepresentationPackage1(D3) if D3 has commutative(*) 
--R            and D3 has RING
--R
--RExamples of antisymmetricTensors from RepresentationPackage1
--R
--E 99

--S 100 of 3320
)d op any
--R 
--R
--RThere is one exposed function called any :
--R   [1] (SExpression,None) -> Any from Any
--R
--RExamples of any from Any
--R
--E 100

--S 101 of 3320
)d op any?
--R 
--R
--RThere are 6 exposed functions called any? :
--R   [1] ((D3 -> Boolean),ArrayStack(D3)) -> Boolean from ArrayStack(D3)
--R             if $ has finiteAggregate and D3 has SETCAT
--R   [2] ((D3 -> Boolean),Dequeue(D3)) -> Boolean from Dequeue(D3)
--R             if $ has finiteAggregate and D3 has SETCAT
--R   [3] ((D3 -> Boolean),Heap(D3)) -> Boolean from Heap(D3)
--R             if $ has finiteAggregate and D3 has ORDSET
--R   [4] ((D3 -> Boolean),D) -> Boolean from D
--R             if D has finiteAggregate and D has HOAGG(D3) and D3 has 
--R            TYPE
--R   [5] ((D3 -> Boolean),Queue(D3)) -> Boolean from Queue(D3)
--R             if $ has finiteAggregate and D3 has SETCAT
--R   [6] ((D3 -> Boolean),Stack(D3)) -> Boolean from Stack(D3)
--R             if $ has finiteAggregate and D3 has SETCAT
--R
--RExamples of any? from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rany?(x+->(x=4),a)
--R
--R
--RExamples of any? from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rany?(x+->(x=4),a)
--R
--R
--RExamples of any? from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rany?(x+->(x=4),a)
--R
--R
--RExamples of any? from HomogeneousAggregate
--R
--R
--RExamples of any? from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rany?(x+->(x=4),a)
--R
--R
--RExamples of any? from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rany?(x+->(x=4),a)
--R
--E 101

--S 102 of 3320
)d op append
--R 
--R
--RThere is one exposed function called append :
--R   [1] (List(D1),List(D1)) -> List(D1) from List(D1) if D1 has TYPE
--R
--RExamples of append from List
--R
--E 102

--S 103 of 3320
)d op appendPoint
--R 
--R
--RThere is one unexposed function called appendPoint :
--R   [1] (GraphImage,Point(DoubleFloat)) -> Void from GraphImage
--R
--RExamples of appendPoint from GraphImage
--R
--E 103

--S 104 of 3320
)d op appendRow!
--R 
--R
--RThere is one exposed function called appendRow! :
--R   [1] (SparseEchelonMatrix(D3,D4),Record(Indices: List(D3),Entries: 
--R            List(D4))) -> Void
--R             from SparseEchelonMatrix(D3,D4) if D3 has ORDSET and D4
--R             has RING
--R
--RExamples of appendRow! from SparseEchelonMatrix
--R
--E 104

--S 105 of 3320
)d op apply
--R 
--R
--RThere are 2 exposed functions called apply :
--R   [1] (Matrix(D2),D) -> D from D if D has FRNAALG(D2) and D2 has 
--R            COMRING
--R   [2] (D,D1,D1) -> D1 from D if D has OREPCAT(D1) and D1 has RING
--R
--RThere are 2 unexposed functions called apply :
--R   [1] (D2,(D1 -> D1),D1) -> D1 from ApplyUnivariateSkewPolynomial(D4,
--R            D1,D2)
--R             if D1 has LMODULE(D4) and D4 has RING and D2 has OREPCAT(
--R            D4)
--R   [2] (D2,D1,D1,Automorphism(D1),(D1 -> D1)) -> D1
--R             from UnivariateSkewPolynomialCategoryOps(D1,D2)
--R             if D1 has RING and D2 has OREPCAT(D1)
--R
--RExamples of apply from ApplyUnivariateSkewPolynomial
--R
--R
--RExamples of apply from FramedNonAssociativeAlgebra
--R
--R
--RExamples of apply from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of apply from UnivariateSkewPolynomialCategoryOps
--R
--E 105

--S 106 of 3320
)d op applyQuote
--R 
--R
--RThere are 5 exposed functions called applyQuote :
--R   [1] (Symbol,List(D)) -> D from D if D has FS(D3) and D3 has ORDSET
--R         
--R   [2] (Symbol,D,D,D,D) -> D from D if D has FS(D2) and D2 has ORDSET
--R         
--R   [3] (Symbol,D,D,D) -> D from D if D has FS(D2) and D2 has ORDSET
--R   [4] (Symbol,D,D) -> D from D if D has FS(D2) and D2 has ORDSET
--R   [5] (Symbol,D) -> D from D if D has FS(D2) and D2 has ORDSET
--R
--RExamples of applyQuote from FunctionSpace
--R
--E 106

--S 107 of 3320
)d op applyRules
--R 
--R
--RThere are 2 unexposed functions called applyRules :
--R   [1] (List(RewriteRule(D3,D4,D1)),D1) -> D1 from ApplyRules(D3,D4,D1)
--R             if D3 has SETCAT and D4 has Join(Ring,PatternMatchable(D3)
--R            ,OrderedSet,ConvertibleTo(Pattern(D3))) and D1 has Join(
--R            FunctionSpace(D4),PatternMatchable(D3),ConvertibleTo(
--R            Pattern(D3)))
--R   [2] (List(RewriteRule(D4,D5,D1)),D1,PositiveInteger) -> D1
--R             from ApplyRules(D4,D5,D1)
--R             if D4 has SETCAT and D5 has Join(Ring,PatternMatchable(D4)
--R            ,OrderedSet,ConvertibleTo(Pattern(D4))) and D1 has Join(
--R            FunctionSpace(D5),PatternMatchable(D4),ConvertibleTo(
--R            Pattern(D4)))
--R
--RExamples of applyRules from ApplyRules
--R
--E 107

--S 108 of 3320
)d op applyTransform
--R 
--R
--RThere is one exposed function called applyTransform :
--R   [1] (D1,D2) -> D1 from BlowUpPackage(D3,D4,D1,D5,D2)
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D5 has DIRPCAT(#(
--R            D4),NNI) and D1 has FAMR(D3,D5) and D2 has BLMETCT
--R
--RExamples of applyTransform from BlowUpPackage
--R
--E 108

--S 109 of 3320
)d op approximants
--R 
--R
--RThere is one exposed function called approximants :
--R   [1] ContinuedFraction(D2) -> Stream(Fraction(D2)) from 
--R            ContinuedFraction(D2)
--R             if D2 has EUCDOM
--R
--RExamples of approximants from ContinuedFraction
--R
--E 109

--S 110 of 3320
)d op approximate
--R 
--R
--RThere are 4 exposed functions called approximate :
--R   [1] (D,Integer) -> Integer from D if D has PADICCT(D2)
--R   [2] (D,D) -> Fraction(Integer) from D if D has RCFIELD
--R   [3] (D2,D,D1) -> D1 from D
--R             if D has RRCC(D1,D2) and D1 has Join(OrderedRing,Field) 
--R            and D2 has UPOLYC(D1)
--R   [4] (D1,D3) -> D2 from D1
--R             if D1 has UPSCAT(D2,D3) and D3 has OAMON and D2 has D: (D2
--R            ,D3) -> D2 and D2 has coerce: Symbol -> D2 and D2 has RING
--R            
--R
--RThere are 3 unexposed functions called approximate :
--R   [1] (BalancedPAdicRational(D3),Integer) -> Fraction(Integer)
--R             from BalancedPAdicRational(D3) if D3: INT
--R   [2] (PAdicRational(D3),Integer) -> Fraction(Integer) from 
--R            PAdicRational(D3)
--R             if D3: INT
--R   [3] (PAdicRationalConstructor(D3,D4),Integer) -> Fraction(Integer)
--R             from PAdicRationalConstructor(D3,D4) if D3: INT and D4
--R             has PADICCT(D3)
--R
--RExamples of approximate from BalancedPAdicRational
--R
--R
--RExamples of approximate from PAdicIntegerCategory
--R
--R
--RExamples of approximate from PAdicRational
--R
--R
--RExamples of approximate from PAdicRationalConstructor
--R
--R
--RExamples of approximate from RealClosedField
--R
--R
--RExamples of approximate from RealRootCharacterizationCategory
--R
--R
--RExamples of approximate from UnivariatePowerSeriesCategory
--R
--E 110

--S 111 of 3320
)d op approxNthRoot
--R 
--R
--RThere is one exposed function called approxNthRoot :
--R   [1] (D1,NonNegativeInteger) -> D1 from IntegerRoots(D1) if D1 has 
--R            INS
--R
--RExamples of approxNthRoot from IntegerRoots
--R
--E 111

--S 112 of 3320
)d op approxSqrt
--R 
--R
--RThere is one exposed function called approxSqrt :
--R   [1] D1 -> D1 from IntegerRoots(D1) if D1 has INS
--R
--RExamples of approxSqrt from IntegerRoots
--R
--E 112

--S 113 of 3320
)d op aQuadratic
--R 
--R
--RThere is one unexposed function called aQuadratic :
--R   [1] (D2,D2,D2) -> D2 from PolynomialSolveByFormulas(D3,D2)
--R             if D2 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D3 has UPOLYC(D2)
--R            
--R
--RExamples of aQuadratic from PolynomialSolveByFormulas
--R
--E 113

--S 114 of 3320
)d op aQuartic
--R 
--R
--RThere is one unexposed function called aQuartic :
--R   [1] (D2,D2,D2,D2,D2) -> D2 from PolynomialSolveByFormulas(D3,D2)
--R             if D2 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D3 has UPOLYC(D2)
--R            
--R
--RExamples of aQuartic from PolynomialSolveByFormulas
--R
--E 114

--S 115 of 3320
)d op areEquivalent?
--R 
--R
--RThere are 3 exposed functions called areEquivalent? :
--R   [1] (List(Matrix(D5)),List(Matrix(D5)),Boolean,Integer) -> Matrix(D5
--R            )
--R             from RepresentationPackage2(D5) if D5 has FIELD and D5
--R             has RING
--R   [2] (List(Matrix(D3)),List(Matrix(D3))) -> Matrix(D3)
--R             from RepresentationPackage2(D3) if D3 has FIELD and D3
--R             has RING
--R   [3] (List(Matrix(D4)),List(Matrix(D4)),Integer) -> Matrix(D4)
--R             from RepresentationPackage2(D4) if D4 has FIELD and D4
--R             has RING
--R
--RExamples of areEquivalent? from RepresentationPackage2
--R
--E 115

--S 116 of 3320
)d op arg1
--R 
--R
--RThere is one unexposed function called arg1 :
--R   [1] (D1,D2) -> D1 from MappingPackageInternalHacks2(D1,D2)
--R             if D1 has SETCAT and D2 has SETCAT
--R
--RExamples of arg1 from MappingPackageInternalHacks2
--R
--E 116

--S 117 of 3320
)d op arg2
--R 
--R
--RThere is one unexposed function called arg2 :
--R   [1] (D2,D1) -> D1 from MappingPackageInternalHacks2(D2,D1)
--R             if D2 has SETCAT and D1 has SETCAT
--R
--RExamples of arg2 from MappingPackageInternalHacks2
--R
--E 117

--S 118 of 3320 done
)d op argscript
--R 
--R
--RThere is one exposed function called argscript :
--R   [1] (Symbol,List(OutputForm)) -> Symbol from Symbol
--R
--RExamples of argscript from Symbol
--R
--Rargscript(Big,[a,1])
--R
--E 118

--S 119 of 3320
)d op argument
--R 
--R
--RThere is one exposed function called argument :
--R   [1] D -> D1 from D if D has COMPCAT(D1) and D1 has COMRING and D1
--R             has TRANFUN
--R
--RThere are 2 unexposed functions called argument :
--R   [1] FourierComponent(D1) -> D1 from FourierComponent(D1) if D1 has 
--R            ORDSET
--R   [2] Kernel(D2) -> List(D2) from Kernel(D2) if D2 has ORDSET
--R
--RExamples of argument from ComplexCategory
--R
--R
--RExamples of argument from FourierComponent
--R
--R
--RExamples of argument from Kernel
--R
--E 119

--S 120 of 3320
)d op argumentList!
--R 
--R
--RThere are 3 exposed functions called argumentList! :
--R   [1] List(Symbol) -> Void from TheSymbolTable
--R   [2] (Symbol,List(Symbol)) -> Void from TheSymbolTable
--R   [3] (Symbol,List(Symbol),TheSymbolTable) -> Void from TheSymbolTable
--R            
--R
--RExamples of argumentList! from TheSymbolTable
--R
--E 120

--S 121 of 3320
)d op argumentListOf
--R 
--R
--RThere is one exposed function called argumentListOf :
--R   [1] (Symbol,TheSymbolTable) -> List(Symbol) from TheSymbolTable
--R
--RExamples of argumentListOf from TheSymbolTable
--R
--E 121

--S 122 of 3320
)d op arity
--R 
--R
--RThere is one exposed function called arity :
--R   [1] BasicOperator -> Union(NonNegativeInteger,"failed") from 
--R            BasicOperator
--R
--RExamples of arity from BasicOperator
--R
--E 122

--S 123 of 3320
)d op aromberg
--R 
--R
--RThere is one exposed function called aromberg :
--R   [1] ((Float -> Float),Float,Float,Float,Float,Integer,Integer,
--R            Integer) -> Record(value: Float,error: Float,totalpts: Integer,
--R            success: Boolean)
--R             from NumericalQuadrature
--R
--RExamples of aromberg from NumericalQuadrature
--R
--E 123

--S 124 of 3320 done
)d op aRow
--R 
--R
--RThere is one exposed function called aRow :
--R   [1] (D1,PositiveInteger) -> D1 from MatrixManipulation(D3,D4,D5,D1)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D1 has MATCAT(D3,D4,D5)
--R
--RExamples of aRow from MatrixManipulation
--R
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--RaRow(M, 1) 
--RaRow(M, 2)
--R
--E 124

--S 125 of 3320 done
)d op arrayStack
--R 
--R
--RThere is one exposed function called arrayStack :
--R   [1] List(D2) -> ArrayStack(D2) from ArrayStack(D2) if D2 has SETCAT
--R            
--R
--RExamples of arrayStack from ArrayStack
--R
--Rc:ArrayStack INT:= arrayStack [1,2,3,4,5]
--R
--E 125

--S 126 of 3320
)d op asec
--R 
--R
--RThere is one exposed function called asec :
--R   [1] D -> D from D if D has ATRIG
--R
--RThere are 5 unexposed functions called asec :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of asec from ArcTrigonometricFunctionCategory
--R
--R
--RExamples of asec from ElementaryFunction
--R
--R
--RExamples of asec from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of asec from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of asec from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of asec from StreamTranscendentalFunctions
--R
--E 126

--S 127 of 3320
)d op asech
--R 
--R
--RThere is one exposed function called asech :
--R   [1] D -> D from D if D has AHYP
--R
--RThere are 5 unexposed functions called asech :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of asech from ArcHyperbolicFunctionCategory
--R
--R
--RExamples of asech from ElementaryFunction
--R
--R
--RExamples of asech from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of asech from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of asech from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of asech from StreamTranscendentalFunctions
--R
--E 127

--S 128 of 3320
)d op asechIfCan
--R 
--R
--RThere is one exposed function called asechIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of asechIfCan from PartialTranscendentalFunctions
--R
--E 128

--S 129 of 3320
)d op asecIfCan
--R 
--R
--RThere is one exposed function called asecIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of asecIfCan from PartialTranscendentalFunctions
--R
--E 129

--S 130 of 3320
)d op asimpson
--R 
--R
--RThere is one exposed function called asimpson :
--R   [1] ((Float -> Float),Float,Float,Float,Float,Integer,Integer,
--R            Integer) -> Record(value: Float,error: Float,totalpts: Integer,
--R            success: Boolean)
--R             from NumericalQuadrature
--R
--RExamples of asimpson from NumericalQuadrature
--R
--E 130

--S 131 of 3320
)d op asin
--R 
--R
--RThere are 2 exposed functions called asin :
--R   [1] D -> D from D if D has ATRIG
--R   [2] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R
--RThere are 5 unexposed functions called asin :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of asin from ArcTrigonometricFunctionCategory
--R
--R
--RExamples of asin from ElementaryFunction
--R
--R
--RExamples of asin from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of asin from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of asin from FortranExpression
--R
--R
--RExamples of asin from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of asin from StreamTranscendentalFunctions
--R
--E 131

--S 132 of 3320
)d op asinh
--R 
--R
--RThere is one exposed function called asinh :
--R   [1] D -> D from D if D has AHYP
--R
--RThere are 5 unexposed functions called asinh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of asinh from ArcHyperbolicFunctionCategory
--R
--R
--RExamples of asinh from ElementaryFunction
--R
--R
--RExamples of asinh from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of asinh from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of asinh from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of asinh from StreamTranscendentalFunctions
--R
--E 132

--S 133 of 3320
)d op asinhIfCan
--R 
--R
--RThere is one exposed function called asinhIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of asinhIfCan from PartialTranscendentalFunctions
--R
--E 133

--S 134 of 3320
)d op asinIfCan
--R 
--R
--RThere is one exposed function called asinIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of asinIfCan from PartialTranscendentalFunctions
--R
--E 134

--S 135 of 3320
)d op aspFilename
--R 
--R
--RThere is one exposed function called aspFilename :
--R   [1] String -> String from NAGLinkSupportPackage
--R
--RExamples of aspFilename from NAGLinkSupportPackage
--R
--E 135

--S 136 of 3320
)d op assert
--R 
--R
--RThere are 3 exposed functions called assert :
--R   [1] (BasicOperator,String) -> BasicOperator from BasicOperator
--R   [2] (D1,String) -> D1 from FunctionSpaceAssertions(D3,D1)
--R             if D3 has ORDSET and D1 has FS(D3)
--R   [3] (Symbol,String) -> Expression(Integer) from 
--R            PatternMatchAssertions
--R
--RExamples of assert from BasicOperator
--R
--R
--RExamples of assert from FunctionSpaceAssertions
--R
--R
--RExamples of assert from PatternMatchAssertions
--R
--E 136

--S 137 of 3320
)d op assign
--R 
--R
--RThere are 31 exposed functions called assign :
--R   [1] (Symbol,List(Polynomial(Integer)),Expression(Complex(Float)))
--R             -> FortranCode
--R             from FortranCode
--R   [2] (Symbol,List(Polynomial(Integer)),Expression(Float)) -> 
--R            FortranCode
--R             from FortranCode
--R   [3] (Symbol,List(Polynomial(Integer)),Expression(Integer)) -> 
--R            FortranCode
--R             from FortranCode
--R   [4] (Symbol,Vector(Expression(Complex(Float)))) -> FortranCode
--R             from FortranCode
--R   [5] (Symbol,Vector(Expression(Float))) -> FortranCode from 
--R            FortranCode
--R   [6] (Symbol,Vector(Expression(Integer))) -> FortranCode from 
--R            FortranCode
--R   [7] (Symbol,Matrix(Expression(Complex(Float)))) -> FortranCode
--R             from FortranCode
--R   [8] (Symbol,Matrix(Expression(Float))) -> FortranCode from 
--R            FortranCode
--R   [9] (Symbol,Matrix(Expression(Integer))) -> FortranCode from 
--R            FortranCode
--R   [10] (Symbol,Expression(Complex(Float))) -> FortranCode from 
--R            FortranCode
--R   [11] (Symbol,Expression(Float)) -> FortranCode from FortranCode
--R   [12] (Symbol,Expression(Integer)) -> FortranCode from FortranCode
--R         
--R   [13] (Symbol,List(Polynomial(Integer)),Expression(MachineComplex))
--R             -> FortranCode
--R             from FortranCode
--R   [14] (Symbol,List(Polynomial(Integer)),Expression(MachineFloat)) -> 
--R            FortranCode
--R             from FortranCode
--R   [15] (Symbol,List(Polynomial(Integer)),Expression(MachineInteger))
--R             -> FortranCode
--R             from FortranCode
--R   [16] (Symbol,Vector(Expression(MachineComplex))) -> FortranCode
--R             from FortranCode
--R   [17] (Symbol,Vector(Expression(MachineFloat))) -> FortranCode from 
--R            FortranCode
--R   [18] (Symbol,Vector(Expression(MachineInteger))) -> FortranCode
--R             from FortranCode
--R   [19] (Symbol,Matrix(Expression(MachineComplex))) -> FortranCode
--R             from FortranCode
--R   [20] (Symbol,Matrix(Expression(MachineFloat))) -> FortranCode from 
--R            FortranCode
--R   [21] (Symbol,Matrix(Expression(MachineInteger))) -> FortranCode
--R             from FortranCode
--R   [22] (Symbol,Vector(MachineComplex)) -> FortranCode from FortranCode
--R            
--R   [23] (Symbol,Vector(MachineFloat)) -> FortranCode from FortranCode
--R         
--R   [24] (Symbol,Vector(MachineInteger)) -> FortranCode from FortranCode
--R            
--R   [25] (Symbol,Matrix(MachineComplex)) -> FortranCode from FortranCode
--R            
--R   [26] (Symbol,Matrix(MachineFloat)) -> FortranCode from FortranCode
--R         
--R   [27] (Symbol,Matrix(MachineInteger)) -> FortranCode from FortranCode
--R            
--R   [28] (Symbol,Expression(MachineComplex)) -> FortranCode from 
--R            FortranCode
--R   [29] (Symbol,Expression(MachineFloat)) -> FortranCode from 
--R            FortranCode
--R   [30] (Symbol,Expression(MachineInteger)) -> FortranCode from 
--R            FortranCode
--R   [31] (Symbol,String) -> FortranCode from FortranCode
--R
--RThere is one unexposed function called assign :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of assign from FortranCode
--R
--R
--RExamples of assign from OutputForm
--R
--E 137

--S 138 of 3320
)d op assoc
--R 
--R
--RThere is one exposed function called assoc :
--R   [1] (D2,D) -> Union(Record(key: D2,entry: D3),"failed") from D
--R             if D has ALAGG(D2,D3) and D2 has SETCAT and D3 has SETCAT
--R            
--R
--RExamples of assoc from AssociationListAggregate
--R
--E 138

--S 139 of 3320
)d op associatedEquations
--R 
--R
--RThere is one unexposed function called associatedEquations :
--R   [1] (D2,PositiveInteger) -> Record(minor: List(PositiveInteger),eq: 
--R            D2,minors: List(List(PositiveInteger)),ops: List(D2))
--R             from AssociatedEquations(D4,D2)
--R             if D4 has FIELD and D4 has INTDOM and D2 has LODOCAT(D4)
--R         
--R
--RExamples of associatedEquations from AssociatedEquations
--R
--E 139

--S 140 of 3320
)d op associatedSystem
--R 
--R
--RThere is one unexposed function called associatedSystem :
--R   [1] (D2,PositiveInteger) -> Record(mat: Matrix(D4),vec: Vector(List(
--R            PositiveInteger)))
--R             from AssociatedEquations(D4,D2) if D4 has INTDOM and D2
--R             has LODOCAT(D4)
--R
--RExamples of associatedSystem from AssociatedEquations
--R
--E 140

--S 141 of 3320
)d op associates?
--R 
--R
--RThere is one exposed function called associates? :
--R   [1] (D,D) -> Boolean from D if D has INTDOM
--R
--RExamples of associates? from IntegralDomain
--R
--E 141

--S 142 of 3320
)d op associative?
--R 
--R
--RThere is one exposed function called associative? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called associative? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of associative? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of associative? from FiniteRankNonAssociativeAlgebra
--R
--E 142

--S 143 of 3320
)d op associator
--R 
--R
--RThere is one exposed function called associator :
--R   [1] (D,D,D) -> D from D if D has NARNG
--R
--RExamples of associator from NonAssociativeRng
--R
--E 143

--S 144 of 3320
)d op associatorDependence
--R 
--R
--RThere is one exposed function called associatorDependence :
--R   [1]  -> List(Vector(D2)) from D
--R             if D has FINAALG(D2) and D2 has COMRING and D2 has INTDOM
--R            
--R
--RThere is one unexposed function called associatorDependence :
--R   [1]  -> List(Vector(D3)) from FiniteRankNonAssociativeAlgebra&(D2,D3
--R            )
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of associatorDependence from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of associatorDependence from FiniteRankNonAssociativeAlgebra
--R
--E 144

--S 145 of 3320
)d op atan
--R 
--R
--RThere are 4 exposed functions called atan :
--R   [1] D -> D from D if D has ATRIG
--R   [2] (DoubleFloat,DoubleFloat) -> DoubleFloat from DoubleFloat
--R   [3] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R   [4] (Float,Float) -> Float from Float
--R
--RThere are 5 unexposed functions called atan :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of atan from ArcTrigonometricFunctionCategory
--R
--R
--RExamples of atan from DoubleFloat
--R
--R
--RExamples of atan from ElementaryFunction
--R
--R
--RExamples of atan from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of atan from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of atan from FortranExpression
--R
--R
--RExamples of atan from Float
--R
--R
--RExamples of atan from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of atan from StreamTranscendentalFunctions
--R
--E 145

--S 146 of 3320
)d op atanh
--R 
--R
--RThere is one exposed function called atanh :
--R   [1] D -> D from D if D has AHYP
--R
--RThere are 5 unexposed functions called atanh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of atanh from ArcHyperbolicFunctionCategory
--R
--R
--RExamples of atanh from ElementaryFunction
--R
--R
--RExamples of atanh from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of atanh from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of atanh from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of atanh from StreamTranscendentalFunctions
--R
--E 146

--S 147 of 3320
)d op atanhIfCan
--R 
--R
--RThere is one exposed function called atanhIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of atanhIfCan from PartialTranscendentalFunctions
--R
--E 147

--S 148 of 3320
)d op atanIfCan
--R 
--R
--RThere is one exposed function called atanIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of atanIfCan from PartialTranscendentalFunctions
--R
--E 148

--S 149 of 3320
)d op atom?
--R 
--R
--RThere is one exposed function called atom? :
--R   [1] D -> Boolean from D
--R             if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R
--RExamples of atom? from SExpressionCategory
--R
--E 149

--S 150 of 3320
)d op atoms
--R 
--R
--RThere is one unexposed function called atoms :
--R   [1] PatternMatchListResult(D2,D3,D4) -> PatternMatchResult(D2,D3)
--R             from PatternMatchListResult(D2,D3,D4)
--R             if D3 has SETCAT and D2 has SETCAT and D4 has LSAGG(D3)
--R         
--R
--RExamples of atoms from PatternMatchListResult
--R
--E 150

--S 151 of 3320
)d op atrapezoidal
--R 
--R
--RThere is one exposed function called atrapezoidal :
--R   [1] ((Float -> Float),Float,Float,Float,Float,Integer,Integer,
--R            Integer) -> Record(value: Float,error: Float,totalpts: Integer,
--R            success: Boolean)
--R             from NumericalQuadrature
--R
--RExamples of atrapezoidal from NumericalQuadrature
--R
--E 151

--S 152 of 3320
)d op att2Result
--R 
--R
--RThere is one exposed function called att2Result :
--R   [1] Record(endPointContinuity: Union(continuous: 
--R            Continuous at the end points,lowerSingular: 
--R            There is a singularity at the lower end point,upperSingular: 
--R            There is a singularity at the upper end point,bothSingular: 
--R            There are singularities at both end points,notEvaluated: 
--R            End point continuity not yet evaluated),singularitiesStream: 
--R            Union(str: Stream(DoubleFloat),notEvaluated: 
--R            Internal singularities not yet evaluated),range: Union(finite: 
--R            The range is finite,lowerInfinite: 
--R            The bottom of range is infinite,upperInfinite: 
--R            The top of range is infinite,bothInfinite: 
--R            Both top and bottom points are infinite,notEvaluated: 
--R            Range not yet evaluated)) -> Result
--R             from ExpertSystemToolsPackage
--R
--RExamples of att2Result from ExpertSystemToolsPackage
--R
--E 152

--S 153 of 3320
)d op augment
--R 
--R
--RThere are 4 exposed functions called augment :
--R   [1] (List(D6),List(D)) -> List(D) from D
--R             if D has RSETCAT(D3,D4,D5,D6) and D3 has GCDDOM and D4
--R             has OAMONS and D5 has ORDSET and D6 has RPOLCAT(D3,D4,D5)
--R            
--R   [2] (List(D6),D) -> List(D) from D
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D has RSETCAT(D3,D4,D5,D6)
--R   [3] (D2,List(D)) -> List(D) from D
--R             if D has RSETCAT(D3,D4,D5,D2) and D3 has GCDDOM and D4
--R             has OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R            
--R   [4] (D2,D) -> List(D) from D
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5) and D has RSETCAT(D3,D4,D5,D2)
--R
--RExamples of augment from RegularTriangularSetCategory
--R
--E 153

--S 154 of 3320
)d op autoReduced?
--R 
--R
--RThere is one exposed function called autoReduced? :
--R   [1] (D,((D6,List(D6)) -> Boolean)) -> Boolean from D
--R             if D has TSETCAT(D3,D4,D5,D6) and D3 has INTDOM and D4
--R             has OAMONS and D5 has ORDSET and D6 has RPOLCAT(D3,D4,D5)
--R            
--R
--RExamples of autoReduced? from TriangularSetCategory
--R
--E 154

--S 155 of 3320
)d op axes
--R 
--R
--RThere is one exposed function called axes :
--R   [1] (ThreeDimensionalViewport,String) -> Void from 
--R            ThreeDimensionalViewport
--R
--RThere are 2 unexposed functions called axes :
--R   [1] (TwoDimensionalViewport,PositiveInteger,Palette) -> Void
--R             from TwoDimensionalViewport
--R   [2] (TwoDimensionalViewport,PositiveInteger,String) -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of axes from TwoDimensionalViewport
--R
--R
--RExamples of axes from ThreeDimensionalViewport
--R
--E 155

--S 156 of 3320
)d op axesColorDefault
--R 
--R
--RThere are 2 exposed functions called axesColorDefault :
--R   [1]  -> Palette from ViewDefaultsPackage
--R   [2] Palette -> Palette from ViewDefaultsPackage
--R
--RExamples of axesColorDefault from ViewDefaultsPackage
--R
--E 156

--S 157 of 3320
)d op axServer
--R 
--R
--RThere is one exposed function called axServer :
--R   [1] (Integer,(SExpression -> Void)) -> Void from AxiomServer
--R
--RExamples of axServer from AxiomServer
--R
--E 157

--S 158 of 3320
)d op B1solve
--R 
--R
--RThere is one unexposed function called B1solve :
--R   [1] Record(mat: Matrix(Fraction(Polynomial(D3))),vec: List(Fraction(
--R            Polynomial(D3))),rank: NonNegativeInteger,rows: List(Integer),
--R            cols: List(Integer)) -> Record(partsol: Vector(Fraction(
--R            Polynomial(D3))),basis: List(Vector(Fraction(Polynomial(D3)))))
--R             from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D4
--R             has Join(OrderedSet,ConvertibleTo(Symbol)) and D5 has 
--R            OAMONS and D6 has POLYCAT(D3,D5,D4)
--R
--RExamples of B1solve from ParametricLinearEquations
--R
--E 158

--S 159 of 3320
)d op back
--R 
--R
--RThere are 3 exposed functions called back :
--R   [1] Dequeue(D1) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [2] D -> D1 from D if D has QUAGG(D1) and D1 has TYPE
--R   [3] Queue(D1) -> D1 from Queue(D1) if D1 has SETCAT
--R
--RExamples of back from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rback a
--R
--R
--RExamples of back from QueueAggregate
--R
--R
--RExamples of back from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rback a
--R
--E 159

--S 160 of 3320
)d op backOldPos
--R 
--R
--RThere is one exposed function called backOldPos :
--R   [1] Record(mval: Matrix(D2),invmval: Matrix(D2),genIdeal: 
--R            PolynomialIdeals(D2,D3,D4,D5)) -> PolynomialIdeals(D2,D3,D4,D5)
--R             from PolynomialIdeals(D2,D3,D4,D5)
--R             if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D5
--R             has POLYCAT(D2,D3,D4)
--R
--RExamples of backOldPos from PolynomialIdeals
--R
--E 160

--S 161 of 3320
)d op badNum
--R 
--R
--RThere are 2 unexposed functions called badNum :
--R   [1] D2 -> Record(den: Integer,gcdnum: Integer)
--R             from PointsOfFiniteOrderTools(D2,D3)
--R             if D2 has UPOLYC(FRAC(INT)) and D3 has UPOLYC(FRAC(D2))
--R         
--R   [2] D2 -> Integer from PointsOfFiniteOrderTools(D3,D2)
--R             if D3 has UPOLYC(FRAC(INT)) and D2 has UPOLYC(FRAC(D3))
--R         
--R
--RExamples of badNum from PointsOfFiniteOrderTools
--R
--E 161

--S 162 of 3320
)d op badValues
--R 
--R
--RThere is one unexposed function called badValues :
--R   [1] Pattern(D3) -> List(D4) from PatternFunctions1(D3,D4)
--R             if D3 has SETCAT and D4 has TYPE
--R
--RExamples of badValues from PatternFunctions1
--R
--E 162

--S 163 of 3320
)d op bag
--R 
--R
--RThere are 6 exposed functions called bag :
--R   [1] List(D2) -> ArrayStack(D2) from ArrayStack(D2) if D2 has SETCAT
--R            
--R   [2] List(D2) -> D from D if D2 has TYPE and D has BGAGG(D2)
--R   [3] List(D2) -> Dequeue(D2) from Dequeue(D2) if D2 has SETCAT
--R   [4] List(D2) -> Heap(D2) from Heap(D2) if D2 has ORDSET
--R   [5] List(D2) -> Queue(D2) from Queue(D2) if D2 has SETCAT
--R   [6] List(D2) -> Stack(D2) from Stack(D2) if D2 has SETCAT
--R
--RExamples of bag from ArrayStack
--R
--Rbag([1,2,3,4,5])$ArrayStack(INT)
--R
--R
--RExamples of bag from BagAggregate
--R
--R
--RExamples of bag from Dequeue
--R
--Rbag([1,2,3,4,5])$Dequeue(INT)
--R
--R
--RExamples of bag from Heap
--R
--Rbag([1,2,3,4,5])$Heap(INT)
--R
--R
--RExamples of bag from Queue
--R
--Rbag([1,2,3,4,5])$Queue(INT)
--R
--R
--RExamples of bag from Stack
--R
--Rbag([1,2,3,4,5])$Stack(INT)
--R
--E 163

--S 164 of 3320
)d op balancedBinaryTree
--R 
--R
--RThere is one exposed function called balancedBinaryTree :
--R   [1] (NonNegativeInteger,D2) -> BalancedBinaryTree(D2)
--R             from BalancedBinaryTree(D2) if D2 has SETCAT
--R
--RExamples of balancedBinaryTree from BalancedBinaryTree
--R
--RbalancedBinaryTree(4, 0)
--R
--E 164

--S 165 of 3320
)d op balancedFactorisation
--R 
--R
--RThere are 2 unexposed functions called balancedFactorisation :
--R   [1] (D2,D2) -> Factored(D2) from BalancedFactorisation(D3,D2)
--R             if D3 has Join(GcdDomain,CharacteristicZero) and D2 has 
--R            UPOLYC(D3)
--R   [2] (D2,List(D2)) -> Factored(D2) from BalancedFactorisation(D4,D2)
--R             if D2 has UPOLYC(D4) and D4 has Join(GcdDomain,
--R            CharacteristicZero)
--R
--RExamples of balancedFactorisation from BalancedFactorisation
--R
--E 165

--S 166 of 3320
)d op bandedHessian
--R 
--R
--RThere is one exposed function called bandedHessian :
--R   [1] (D2,D3,NonNegativeInteger) -> Matrix(D2)
--R             from MultiVariableCalculusFunctions(D5,D2,D6,D3)
--R             if D5 has SETCAT and D2 has PDRING(D5) and D6 has FLAGG(D2
--R            ) and D3 has FiniteLinearAggregate(D5)with
--R                 finiteAggregate
--R
--RExamples of bandedHessian from MultiVariableCalculusFunctions
--R
--E 166

--S 167 of 3320
)d op bandedJacobian
--R 
--R
--RThere is one exposed function called bandedJacobian :
--R   [1] (D2,D3,NonNegativeInteger,NonNegativeInteger) -> Matrix(D6)
--R             from MultiVariableCalculusFunctions(D5,D6,D2,D3)
--R             if D5 has SETCAT and D6 has PDRING(D5) and D2 has FLAGG(D6
--R            ) and D3 has FiniteLinearAggregate(D5)with
--R                 finiteAggregate
--R
--RExamples of bandedJacobian from MultiVariableCalculusFunctions
--R
--E 167

--S 168 of 3320 done
)d op bandMatrix
--R 
--R
--RThere are 2 exposed functions called bandMatrix :
--R   [1] (D1,List(Integer)) -> D1 from MatrixManipulation(D3,D4,D5,D1)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D1 has MATCAT(D3,D4,D5)
--R   [2] (D1,Segment(Integer)) -> D1 from MatrixManipulation(D3,D4,D5,D1)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D1 has MATCAT(D3,D4,D5)
--R
--RExamples of bandMatrix from MatrixManipulation
--R
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--RbandMatrix(M, -1..1)
--R
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--RbandMatrix(M, [-1,1]) 
--RbandMatrix(M, [-1,0,1])
--R
--E 168

--S 169 of 3320
)d op base
--R 
--R
--RThere are 5 exposed functions called base :
--R   [1]  -> PositiveInteger from D if D has FPS
--R   [2]  -> D from D if D has INS
--R   [3] PositiveInteger -> PositiveInteger from MachineFloat
--R   [4]  -> PositiveInteger from MachineFloat
--R   [5] PermutationGroup(D2) -> List(D2) from PermutationGroup(D2) if D2
--R             has SETCAT
--R
--RExamples of base from FloatingPointSystem
--R
--R
--RExamples of base from IntegerNumberSystem
--R
--R
--RExamples of base from MachineFloat
--R
--R
--RExamples of base from PermutationGroup
--R
--E 169

--S 170 of 3320
)d op baseRDE
--R 
--R
--RThere is one unexposed function called baseRDE :
--R   [1] (Fraction(D4),Fraction(D4)) -> Record(ans: Fraction(D4),nosol: 
--R            Boolean)
--R             from TranscendentalRischDE(D3,D4)
--R             if D3 has Join(Field,CharacteristicZero,RetractableTo(
--R            Integer)) and D4 has UPOLYC(D3)
--R
--RExamples of baseRDE from TranscendentalRischDE
--R
--E 170

--S 171 of 3320
)d op baseRDEsys
--R 
--R
--RThere is one unexposed function called baseRDEsys :
--R   [1] (Fraction(D4),Fraction(D4),Fraction(D4)) -> Union(List(Fraction(
--R            D4)),"failed")
--R             from TranscendentalRischDESystem(D3,D4)
--R             if D3 has Join(Field,CharacteristicZero,RetractableTo(
--R            Integer)) and D4 has UPOLYC(D3)
--R
--RExamples of baseRDEsys from TranscendentalRischDESystem
--R
--E 171

--S 172 of 3320
)d op basicSet
--R 
--R
--RThere are 2 exposed functions called basicSet :
--R   [1] (List(D8),(D8 -> Boolean),((D8,D8) -> Boolean)) -> Union(Record(
--R            bas: D,top: List(D8)),"failed")
--R             from D
--R             if D8 has RPOLCAT(D5,D6,D7) and D5 has INTDOM and D6 has 
--R            OAMONS and D7 has ORDSET and D has TSETCAT(D5,D6,D7,D8)
--R   [2] (List(D7),((D7,D7) -> Boolean)) -> Union(Record(bas: D,top: List
--R            (D7)),"failed")
--R             from D
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has INTDOM and D5 has 
--R            OAMONS and D6 has ORDSET and D has TSETCAT(D4,D5,D6,D7)
--R
--RExamples of basicSet from TriangularSetCategory
--R
--E 172

--S 173 of 3320
)d op basis
--R 
--R
--RThere are 5 exposed functions called basis :
--R   [1] Vector(D3) -> Vector(D3) from AlgebraPackage(D2,D3)
--R             if D3 has FRNAALG(D2) and D2 has EUCDOM and D2 has INTDOM
--R            
--R   [2] PositiveInteger -> Vector(D) from D if D3 has FIELD and D has 
--R            FAXF(D3)
--R   [3]  -> Vector(D) from D if D2 has FIELD and D has FAXF(D2)
--R   [4]  -> Vector(D) from D
--R             if D2 has COMRING and D3 has UPOLYC(D2) and D has FRAMALG(
--R            D2,D3)
--R   [5]  -> Vector(D) from D if D2 has COMRING and D has FRNAALG(D2)
--R
--RThere are 3 unexposed functions called basis :
--R   [1] FractionalIdeal(D2,D3,D4,D5) -> Vector(D5)
--R             from FractionalIdeal(D2,D3,D4,D5)
--R             if D2 has EUCDOM and D3 has QFCAT(D2) and D4 has UPOLYC(D3
--R            ) and D5 has Join(FramedAlgebra(D3,D4),RetractableTo(D3))
--R         
--R   [2] FramedModule(D2,D3,D4,D5,D6) -> Vector(D5)
--R             from FramedModule(D2,D3,D4,D5,D6)
--R             if D2 has EUCDOM and D3 has QFCAT(D2) and D4 has UPOLYC(D3
--R            ) and D5 has FRAMALG(D3,D4) and D6: VECTOR(D5)
--R   [3] PositiveInteger -> Vector(Vector(D3))
--R             from InnerNormalBasisFieldFunctions(D3) if D3 has FFIELDC
--R            
--R
--RExamples of basis from AlgebraPackage
--R
--R
--RExamples of basis from FiniteAlgebraicExtensionField
--R
--R
--RExamples of basis from FramedAlgebra
--R
--R
--RExamples of basis from FractionalIdeal
--R
--R
--RExamples of basis from FramedModule
--R
--R
--RExamples of basis from FramedNonAssociativeAlgebra
--R
--R
--RExamples of basis from InnerNormalBasisFieldFunctions
--R
--E 173

--S 174 of 3320
)d op basisOfCenter
--R 
--R
--RThere is one exposed function called basisOfCenter :
--R   [1]  -> List(D3) from AlgebraPackage(D2,D3)
--R             if D2 has INTDOM and D3 has FRNAALG(D2)
--R
--RExamples of basisOfCenter from AlgebraPackage
--R
--E 174

--S 175 of 3320
)d op basisOfCentroid
--R 
--R
--RThere is one exposed function called basisOfCentroid :
--R   [1]  -> List(Matrix(D2)) from AlgebraPackage(D2,D3)
--R             if D2 has INTDOM and D3 has FRNAALG(D2)
--R
--RExamples of basisOfCentroid from AlgebraPackage
--R
--E 175

--S 176 of 3320
)d op basisOfCommutingElements
--R 
--R
--RThere is one exposed function called basisOfCommutingElements :
--R   [1]  -> List(D3) from AlgebraPackage(D2,D3)
--R             if D2 has INTDOM and D3 has FRNAALG(D2)
--R
--RExamples of basisOfCommutingElements from AlgebraPackage
--R
--E 176

--S 177 of 3320
)d op basisOfLeftAnnihilator
--R 
--R
--RThere is one exposed function called basisOfLeftAnnihilator :
--R   [1] D2 -> List(D2) from AlgebraPackage(D3,D2)
--R             if D3 has INTDOM and D2 has FRNAALG(D3)
--R
--RExamples of basisOfLeftAnnihilator from AlgebraPackage
--R
--E 177

--S 178 of 3320
)d op basisOfLeftNucleus
--R 
--R
--RThere is one exposed function called basisOfLeftNucleus :
--R   [1]  -> List(D3) from AlgebraPackage(D2,D3)
--R             if D2 has INTDOM and D3 has FRNAALG(D2)
--R
--RExamples of basisOfLeftNucleus from AlgebraPackage
--R
--E 178

--S 179 of 3320
)d op basisOfLeftNucloid
--R 
--R
--RThere is one exposed function called basisOfLeftNucloid :
--R   [1]  -> List(Matrix(D2)) from AlgebraPackage(D2,D3)
--R             if D2 has INTDOM and D3 has FRNAALG(D2)
--R
--RExamples of basisOfLeftNucloid from AlgebraPackage
--R
--E 179

--S 180 of 3320
)d op basisOfMiddleNucleus
--R 
--R
--RThere is one exposed function called basisOfMiddleNucleus :
--R   [1]  -> List(D3) from AlgebraPackage(D2,D3)
--R             if D2 has INTDOM and D3 has FRNAALG(D2)
--R
--RExamples of basisOfMiddleNucleus from AlgebraPackage
--R
--E 180

--S 181 of 3320
)d op basisOfNucleus
--R 
--R
--RThere is one exposed function called basisOfNucleus :
--R   [1]  -> List(D3) from AlgebraPackage(D2,D3)
--R             if D2 has INTDOM and D3 has FRNAALG(D2)
--R
--RExamples of basisOfNucleus from AlgebraPackage
--R
--E 181

--S 182 of 3320
)d op basisOfRightAnnihilator
--R 
--R
--RThere is one exposed function called basisOfRightAnnihilator :
--R   [1] D2 -> List(D2) from AlgebraPackage(D3,D2)
--R             if D3 has INTDOM and D2 has FRNAALG(D3)
--R
--RExamples of basisOfRightAnnihilator from AlgebraPackage
--R
--E 182

--S 183 of 3320
)d op basisOfRightNucleus
--R 
--R
--RThere is one exposed function called basisOfRightNucleus :
--R   [1]  -> List(D3) from AlgebraPackage(D2,D3)
--R             if D2 has INTDOM and D3 has FRNAALG(D2)
--R
--RExamples of basisOfRightNucleus from AlgebraPackage
--R
--E 183

--S 184 of 3320
)d op basisOfRightNucloid
--R 
--R
--RThere is one exposed function called basisOfRightNucloid :
--R   [1]  -> List(Matrix(D2)) from AlgebraPackage(D2,D3)
--R             if D2 has INTDOM and D3 has FRNAALG(D2)
--R
--RExamples of basisOfRightNucloid from AlgebraPackage
--R
--E 184

--S 185 of 3320
)d op bat
--R 
--R
--RThere is one unexposed function called bat :
--R   [1] Tableau(List(D3)) -> List(List(D3)) from TableauxBumpers(D3) if 
--R            D3 has ORDSET
--R
--RExamples of bat from TableauxBumpers
--R
--E 185

--S 186 of 3320
)d op bat1
--R 
--R
--RThere is one unexposed function called bat1 :
--R   [1] List(List(List(D3))) -> List(List(D3)) from TableauxBumpers(D3)
--R             if D3 has ORDSET
--R
--RExamples of bat1 from TableauxBumpers
--R
--E 186

--S 187 of 3320
)d op beauzamyBound
--R 
--R
--RThere is one unexposed function called beauzamyBound :
--R   [1] D2 -> Integer from GaloisGroupFactorizationUtilities(D3,D2,D4)
--R             if D3 has RING and D2 has UPOLYC(D3) and D4 has Join(
--R            FloatingPointSystem,RetractableTo(D3),Field,
--R            TranscendentalFunctionCategory,ElementaryFunctionCategory)
--R            
--R
--RExamples of beauzamyBound from GaloisGroupFactorizationUtilities
--R
--E 187

--S 188 of 3320
)d op belong?
--R 
--R
--RThere is one exposed function called belong? :
--R   [1] BasicOperator -> Boolean from D if D has ES
--R
--RThere are 7 unexposed functions called belong? :
--R   [1] BasicOperator -> Boolean from AlgebraicFunction(D3,D4)
--R             if D3 has Join(OrderedSet,IntegralDomain) and D4 has FS(D3
--R            )
--R   [2] BasicOperator -> Boolean from CombinatorialFunction(D3,D4)
--R             if D3 has Join(OrderedSet,IntegralDomain) and D4 has FS(D3
--R            )
--R   [3] BasicOperator -> Boolean from ElementaryFunction(D3,D4)
--R             if D3 has Join(OrderedSet,IntegralDomain) and D4 has Join(
--R            FunctionSpace(D3),RadicalCategory)
--R   [4] BasicOperator -> Boolean from ExpressionSpace&(D3) if D3 has ES
--R            
--R   [5] BasicOperator -> Boolean from FunctionSpace&(D3,D4)
--R             if D4 has ORDSET and D3 has FS(D4)
--R   [6] BasicOperator -> Boolean from FunctionalSpecialFunction(D3,D4)
--R             if D3 has Join(OrderedSet,IntegralDomain) and D4 has FS(D3
--R            )
--R   [7] BasicOperator -> Boolean from LiouvillianFunction(D3,D4)
--R             if D3 has Join(OrderedSet,IntegralDomain) and D4 has Join(
--R            FunctionSpace(D3),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R
--RExamples of belong? from AlgebraicFunction
--R
--R
--RExamples of belong? from CombinatorialFunction
--R
--R
--RExamples of belong? from ElementaryFunction
--R
--R
--RExamples of belong? from ExpressionSpace&
--R
--R
--RExamples of belong? from ExpressionSpace
--R
--R
--RExamples of belong? from FunctionSpace&
--R
--R
--RExamples of belong? from FunctionalSpecialFunction
--R
--R
--RExamples of belong? from LiouvillianFunction
--R
--E 188

--S 189 of 3320
)d op bernoulli
--R 
--R
--RThere is one exposed function called bernoulli :
--R   [1] Integer -> Fraction(Integer) from IntegerNumberTheoryFunctions
--R         
--R
--RThere is one unexposed function called bernoulli :
--R   [1] Integer -> SparseUnivariatePolynomial(Fraction(Integer))
--R             from PolynomialNumberTheoryFunctions
--R
--RExamples of bernoulli from IntegerNumberTheoryFunctions
--R
--R
--RExamples of bernoulli from PolynomialNumberTheoryFunctions
--R
--E 189

--S 190 of 3320
)d op bernoulliB
--R 
--R
--RThere is one exposed function called bernoulliB :
--R   [1] (NonNegativeInteger,D1) -> D1 from 
--R            NumberTheoreticPolynomialFunctions(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has COMRING
--R
--RExamples of bernoulliB from NumberTheoreticPolynomialFunctions
--R
--E 190

--S 191 of 3320
)d op besselI
--R 
--R
--RThere are 3 exposed functions called besselI :
--R   [1] (DoubleFloat,DoubleFloat) -> DoubleFloat from 
--R            DoubleFloatSpecialFunctions
--R   [2] (Complex(DoubleFloat),Complex(DoubleFloat)) -> Complex(
--R            DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R   [3] (D,D) -> D from D if D has SPFCAT
--R
--RThere is one unexposed function called besselI :
--R   [1] (D1,D1) -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of besselI from DoubleFloatSpecialFunctions
--R
--R
--RExamples of besselI from FunctionalSpecialFunction
--R
--R
--RExamples of besselI from SpecialFunctionCategory
--R
--E 191

--S 192 of 3320
)d op besselJ
--R 
--R
--RThere are 3 exposed functions called besselJ :
--R   [1] (DoubleFloat,DoubleFloat) -> DoubleFloat from 
--R            DoubleFloatSpecialFunctions
--R   [2] (Complex(DoubleFloat),Complex(DoubleFloat)) -> Complex(
--R            DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R   [3] (D,D) -> D from D if D has SPFCAT
--R
--RThere is one unexposed function called besselJ :
--R   [1] (D1,D1) -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of besselJ from DoubleFloatSpecialFunctions
--R
--R
--RExamples of besselJ from FunctionalSpecialFunction
--R
--R
--RExamples of besselJ from SpecialFunctionCategory
--R
--E 192

--S 193 of 3320
)d op besselK
--R 
--R
--RThere are 3 exposed functions called besselK :
--R   [1] (DoubleFloat,DoubleFloat) -> DoubleFloat from 
--R            DoubleFloatSpecialFunctions
--R   [2] (Complex(DoubleFloat),Complex(DoubleFloat)) -> Complex(
--R            DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R   [3] (D,D) -> D from D if D has SPFCAT
--R
--RThere is one unexposed function called besselK :
--R   [1] (D1,D1) -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of besselK from DoubleFloatSpecialFunctions
--R
--R
--RExamples of besselK from FunctionalSpecialFunction
--R
--R
--RExamples of besselK from SpecialFunctionCategory
--R
--E 193

--S 194 of 3320
)d op besselY
--R 
--R
--RThere are 3 exposed functions called besselY :
--R   [1] (DoubleFloat,DoubleFloat) -> DoubleFloat from 
--R            DoubleFloatSpecialFunctions
--R   [2] (Complex(DoubleFloat),Complex(DoubleFloat)) -> Complex(
--R            DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R   [3] (D,D) -> D from D if D has SPFCAT
--R
--RThere is one unexposed function called besselY :
--R   [1] (D1,D1) -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of besselY from DoubleFloatSpecialFunctions
--R
--R
--RExamples of besselY from FunctionalSpecialFunction
--R
--R
--RExamples of besselY from SpecialFunctionCategory
--R
--E 194

--S 195 of 3320
)d op Beta
--R 
--R
--RThere are 4 exposed functions called Beta :
--R   [1] (DoubleFloat,DoubleFloat) -> DoubleFloat from DoubleFloat
--R   [2] (DoubleFloat,DoubleFloat) -> DoubleFloat from 
--R            DoubleFloatSpecialFunctions
--R   [3] (Complex(DoubleFloat),Complex(DoubleFloat)) -> Complex(
--R            DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R   [4] (D,D) -> D from D if D has SPFCAT
--R
--RThere are 2 unexposed functions called Beta :
--R   [1] (D1,D1) -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R   [2] (NonNegativeInteger,NonNegativeInteger) -> (() -> Float)
--R             from RandomFloatDistributions
--R
--RExamples of Beta from DoubleFloat
--R
--R
--RExamples of Beta from DoubleFloatSpecialFunctions
--R
--R
--RExamples of Beta from FunctionalSpecialFunction
--R
--R
--RExamples of Beta from RandomFloatDistributions
--R
--R
--RExamples of Beta from SpecialFunctionCategory
--R
--E 195

--S 196 of 3320
)d op bezoutDiscriminant
--R 
--R
--RThere is one unexposed function called bezoutDiscriminant :
--R   [1] D2 -> D1 from BezoutMatrix(D1,D2,D3,D4,D5)
--R             if D1 has commutative(*) and D4 has FLAGG(D1) and D5 has 
--R            FLAGG(D1) and D1 has RING and D2 has UPOLYC(D1) and D3 has 
--R            MATCAT(D1,D4,D5)
--R
--RExamples of bezoutDiscriminant from BezoutMatrix
--R
--E 196

--S 197 of 3320
)d op bezoutMatrix
--R 
--R
--RThere is one unexposed function called bezoutMatrix :
--R   [1] (D2,D2) -> D1 from BezoutMatrix(D3,D2,D1,D4,D5)
--R             if D3 has RING and D1 has MATCAT(D3,D4,D5) and D2 has 
--R            UPOLYC(D3) and D4 has FLAGG(D3) and D5 has FLAGG(D3)
--R
--RExamples of bezoutMatrix from BezoutMatrix
--R
--E 197

--S 198 of 3320
)d op bezoutResultant
--R 
--R
--RThere is one unexposed function called bezoutResultant :
--R   [1] (D2,D2) -> D1 from BezoutMatrix(D1,D2,D3,D4,D5)
--R             if D1 has commutative(*) and D4 has FLAGG(D1) and D5 has 
--R            FLAGG(D1) and D1 has RING and D2 has UPOLYC(D1) and D3 has 
--R            MATCAT(D1,D4,D5)
--R
--RExamples of bezoutResultant from BezoutMatrix
--R
--E 198

--S 199 of 3320
)d op bfEntry
--R 
--R
--RThere is one exposed function called bfEntry :
--R   [1] Symbol -> Record(zeros: Stream(DoubleFloat),ones: Stream(
--R            DoubleFloat),singularities: Stream(DoubleFloat))
--R             from BasicFunctions
--R
--RExamples of bfEntry from BasicFunctions
--R
--E 199

--S 200 of 3320
)d op bfKeys
--R 
--R
--RThere is one exposed function called bfKeys :
--R   [1]  -> List(Symbol) from BasicFunctions
--R
--RExamples of bfKeys from BasicFunctions
--R
--E 200

--S 201 of 3320 done
)d op binary
--R 
--R
--RThere is one exposed function called binary :
--R   [1] Fraction(Integer) -> BinaryExpansion from BinaryExpansion
--R
--RThere is one unexposed function called binary :
--R   [1] (InputForm,List(InputForm)) -> InputForm from InputForm
--R
--RExamples of binary from BinaryExpansion
--R
--Rbinary(22/7)
--R
--R
--RExamples of binary from InputForm
--R
--Ra:=[1,2,3]::List(InputForm) 
--Rbinary(_+::InputForm,a)
--R
--E 201

--S 202 of 3320
)d op binaryFunction
--R 
--R
--RThere is one unexposed function called binaryFunction :
--R   [1] Symbol -> ((D4,D5) -> D6) from MakeBinaryCompiledFunction(D3,D4,
--R            D5,D6)
--R             if D3 has KONVERT(INFORM) and D4 has TYPE and D5 has TYPE 
--R            and D6 has TYPE
--R
--RExamples of binaryFunction from MakeBinaryCompiledFunction
--R
--E 202

--S 203 of 3320 done
)d op binarySearchTree
--R 
--R
--RThere is one exposed function called binarySearchTree :
--R   [1] List(D2) -> BinarySearchTree(D2) from BinarySearchTree(D2) if D2
--R             has ORDSET
--R
--RExamples of binarySearchTree from BinarySearchTree
--R
--RbinarySearchTree [1,2,3,4]
--R
--E 203

--S 204 of 3320 done
)d op binaryTournament
--R 
--R
--RThere is one exposed function called binaryTournament :
--R   [1] List(D2) -> BinaryTournament(D2) from BinaryTournament(D2) if D2
--R             has ORDSET
--R
--RExamples of binaryTournament from BinaryTournament
--R
--RbinaryTournament [1,2,3,4]
--R
--E 204

--S 205 of 3320 done
)d op binaryTree
--R 
--R
--RThere are 2 exposed functions called binaryTree :
--R   [1] (BinaryTree(D1),D1,BinaryTree(D1)) -> BinaryTree(D1) from 
--R            BinaryTree(D1)
--R             if D1 has SETCAT
--R   [2] D1 -> BinaryTree(D1) from BinaryTree(D1) if D1 has SETCAT
--R
--RExamples of binaryTree from BinaryTree
--R
--Rt1:=binaryTree([1,2,3]) 
--Rt2:=binaryTree([4,5,6]) 
--RbinaryTree(t1,[7,8,9],t2)
--R
--Rt1:=binaryTree([1,2,3])
--R
--E 205

--S 206 of 3320
)d op binomial
--R 
--R
--RThere are 2 exposed functions called binomial :
--R   [1] (D,D) -> D from D if D has CFCAT
--R   [2] (D1,D1) -> D1 from IntegerCombinatoricFunctions(D1) if D1 has 
--R            INS
--R
--RThere are 3 unexposed functions called binomial :
--R   [1] (D1,D1) -> D1 from CombinatorialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R   [2] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [3] (Integer,RationalNumber) -> (() -> Integer)
--R             from RandomIntegerDistributions
--R
--RExamples of binomial from CombinatorialFunctionCategory
--R
--R[binomial(5,i) for i in 0..5]
--R
--R
--RExamples of binomial from CombinatorialFunction
--R
--R[binomial(5,i) for i in 0..5]
--R
--R
--RExamples of binomial from IntegerCombinatoricFunctions
--R
--R[binomial(5,i) for i in 0..5]
--R
--R
--RExamples of binomial from OutputForm
--R
--R
--RExamples of binomial from RandomIntegerDistributions
--R
--E 206

--S 207 of 3320
)d op binomThmExpt
--R 
--R
--RThere is one exposed function called binomThmExpt :
--R   [1] (D,D,NonNegativeInteger) -> D from D
--R             if D has FAMR(D2,D3) and D2 has RING and D3 has OAMON and 
--R            D2 has COMRING
--R
--RExamples of binomThmExpt from FiniteAbelianMonoidRing
--R
--E 207

--S 208 of 3320
)d op bipolar
--R 
--R
--RThere is one exposed function called bipolar :
--R   [1] D2 -> (Point(D2) -> Point(D2)) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of bipolar from CoordinateSystems
--R
--E 208

--S 209 of 3320
)d op bipolarCylindrical
--R 
--R
--RThere is one exposed function called bipolarCylindrical :
--R   [1] D2 -> (Point(D2) -> Point(D2)) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of bipolarCylindrical from CoordinateSystems
--R
--E 209

--S 210 of 3320
)d op biRank
--R 
--R
--RThere is one exposed function called biRank :
--R   [1] D2 -> NonNegativeInteger from AlgebraPackage(D3,D2)
--R             if D3 has INTDOM and D2 has FRNAALG(D3)
--R
--RExamples of biRank from AlgebraPackage
--R
--E 210

--S 211 of 3320
)d op biringToPolyRing
--R 
--R
--RThere is one exposed function called biringToPolyRing :
--R   [1] (DistributedMultivariatePolynomial([construct,QUOTEX,QUOTEY],D4)
--R            ,D3) -> D1
--R             from BlowUpPackage(D4,D5,D1,D6,D3)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D1 has FAMR(D4,D6
--R            ) and D6 has DIRPCAT(#(D5),NNI) and D3 has BLMETCT
--R
--RExamples of biringToPolyRing from BlowUpPackage
--R
--E 211

--S 212 of 3320
)d op birth
--R 
--R
--RThere is one unexposed function called birth :
--R   [1] SubSpace(D1,D2) -> SubSpace(D1,D2) from SubSpace(D1,D2)
--R             if D1: PI and D2 has RING
--R
--RExamples of birth from SubSpace
--R
--E 212

--S 213 of 3320
)d op bit?
--R 
--R
--RThere is one exposed function called bit? :
--R   [1] (D,D) -> Boolean from D if D has INS
--R
--RExamples of bit? from IntegerNumberSystem
--R
--E 213

--S 214 of 3320
)d op bitCoef
--R 
--R
--RThere is one unexposed function called bitCoef :
--R   [1] (Integer,Integer) -> Integer from IntegerBits
--R
--RExamples of bitCoef from IntegerBits
--R
--E 214

--S 215 of 3320
)d op bitLength
--R 
--R
--RThere is one unexposed function called bitLength :
--R   [1] Integer -> Integer from IntegerBits
--R
--RExamples of bitLength from IntegerBits
--R
--E 215

--S 216 of 3320
)d op bits
--R 
--R
--RThere are 3 exposed functions called bits :
--R   [1] (NonNegativeInteger,Boolean) -> Bits from Bits
--R   [2] PositiveInteger -> PositiveInteger from D
--R             if D has arbitraryPrecision and D has FPS
--R   [3]  -> PositiveInteger from D if D has FPS
--R
--RExamples of bits from Bits
--R
--R
--RExamples of bits from FloatingPointSystem
--R
--E 216

--S 217 of 3320
)d op bitTruth
--R 
--R
--RThere is one unexposed function called bitTruth :
--R   [1] (Integer,Integer) -> Boolean from IntegerBits
--R
--RExamples of bitTruth from IntegerBits
--R
--E 217

--S 218 of 3320
)d op bivariate?
--R 
--R
--RThere is one unexposed function called bivariate? :
--R   [1] D2 -> Boolean from PolynomialSetUtilitiesPackage(D3,D4,D5,D2)
--R             if D3 has INTDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5)
--R
--RExamples of bivariate? from PolynomialSetUtilitiesPackage
--R
--E 218

--S 219 of 3320
)d op bivariatePolynomials
--R 
--R
--RThere is one unexposed function called bivariatePolynomials :
--R   [1] List(D6) -> Record(goodPols: List(D6),badPols: List(D6))
--R             from PolynomialSetUtilitiesPackage(D3,D4,D5,D6)
--R             if D3 has INTDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5)
--R
--RExamples of bivariatePolynomials from PolynomialSetUtilitiesPackage
--R
--E 219

--S 220 of 3320
)d op bivariateSLPEBR
--R 
--R
--RThere is one unexposed function called bivariateSLPEBR :
--R   [1] (List(SparseUnivariatePolynomial(D6)),SparseUnivariatePolynomial
--R            (D6),D3) -> Union(List(SparseUnivariatePolynomial(D6)),"failed")
--R             from PolynomialFactorizationByRecursion(D4,D5,D3,D6)
--R             if D6 has POLYCAT(D4,D5,D3) and D4 has PFECAT and D5 has 
--R            OAMONS and D3 has ORDSET
--R
--RExamples of bivariateSLPEBR from PolynomialFactorizationByRecursion
--R
--E 220

--S 221 of 3320
)d op blankSeparate
--R 
--R
--RThere is one unexposed function called blankSeparate :
--R   [1] List(OutputForm) -> OutputForm from OutputForm
--R
--RExamples of blankSeparate from OutputForm
--R
--E 221

--S 222 of 3320
)d op block
--R 
--R
--RThere is one exposed function called block :
--R   [1] List(FortranCode) -> FortranCode from FortranCode
--R
--RExamples of block from FortranCode
--R
--E 222

--S 223 of 3320 done
)d op blockConcat
--R 
--R
--RThere is one exposed function called blockConcat :
--R   [1] List(List(D1)) -> D1 from MatrixManipulation(D3,D4,D5,D1)
--R             if D3 has FIELD and D1 has MATCAT(D3,D4,D5) and D4 has 
--R            FLAGG(D3) and D5 has FLAGG(D3)
--R
--RExamples of blockConcat from MatrixManipulation
--R
--RA := matrix([[a]]) 
--RB := matrix([[b]]) 
--RC := matrix([[c]]) 
--RA11 := element(M, 3,3) 
--RA12 := horizConcat([A,B,C]) 
--RA21 := vertConcat([A,B,C]) 
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--RE := blockConcat([[A11,A12],[A21,M]]) 
--Rt1 := blockSplit(E, 4, [2,2]) 
--Rt2 := blockConcat t1 
--Rzero?(E-t2) 
--Rt3 := blockSplit(E, [1,2,1], [2,2]) 
--Rt4 := blockConcat t3 
--Rzero?(E-t4)
--R
--E 223

--S 224 of 3320 done
)d op blockSplit
--R 
--R
--RThere are 4 exposed functions called blockSplit :
--R   [1] (D2,PositiveInteger,PositiveInteger) -> List(List(D2))
--R             from MatrixManipulation(D4,D5,D6,D2)
--R             if D4 has FIELD and D5 has FLAGG(D4) and D6 has FLAGG(D4) 
--R            and D2 has MATCAT(D4,D5,D6)
--R   [2] (D2,List(PositiveInteger),PositiveInteger) -> List(List(D2))
--R             from MatrixManipulation(D5,D6,D7,D2)
--R             if D5 has FIELD and D6 has FLAGG(D5) and D7 has FLAGG(D5) 
--R            and D2 has MATCAT(D5,D6,D7)
--R   [3] (D2,PositiveInteger,List(PositiveInteger)) -> List(List(D2))
--R             from MatrixManipulation(D5,D6,D7,D2)
--R             if D5 has FIELD and D6 has FLAGG(D5) and D7 has FLAGG(D5) 
--R            and D2 has MATCAT(D5,D6,D7)
--R   [4] (D2,List(PositiveInteger),List(PositiveInteger)) -> List(List(D2
--R            ))
--R             from MatrixManipulation(D4,D5,D6,D2)
--R             if D4 has FIELD and D5 has FLAGG(D4) and D6 has FLAGG(D4) 
--R            and D2 has MATCAT(D4,D5,D6)
--R
--RExamples of blockSplit from MatrixManipulation
--R
--RE := matrix([[i,a,b,c],[a,a,b,c],[b,d,e,f],[c,g,h,i]]) 
--Rt1:= blockSplit(E, [1,2,1], [2,2])
--R
--RE := matrix([[i,a,b,c],[a,a,b,c],[b,d,e,f],[c,g,h,i]]) 
--Rt1:= blockSplit(E, 4, [2,2])
--R
--RE := matrix([[i,a,b,c],[a,a,b,c],[b,d,e,f],[c,g,h,i]]) 
--Rt1:= blockSplit(E, [2,1,1], 2)
--R
--RE := matrix([[i,a,b,c],[a,a,b,c],[b,d,e,f],[c,g,h,i]]) 
--Rt1:= blockSplit(E,2,2)
--R
--E 224

--S 225 of 3320
)d op blowUp
--R 
--R
--RThere is one exposed function called blowUp :
--R   [1] D6 -> List(D6)
--R             from DesingTreePackage(D7,D8,D9,D10,D11,D12,D1,D2,D6,D3,D4
--R            )
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D9 has POLYCAT(D7
--R            ,D10,OVAR(D8)) and D10 has DIRPCAT(#(D8),NNI) and D11 has 
--R            PRSPCAT(D7) and D12 has LOCPOWC(D7) and D1 has PLACESC(D7,
--R            D12) and D2 has DIVCAT(D1) and D6 has INFCLCT(D7,D8,D9,D10,
--R            D11,D12,D1,D2,D4) and D4 has BLMETCT and D3 has DSTRCAT(D6)
--R            
--R
--RExamples of blowUp from DesingTreePackage
--R
--E 225

--S 226 of 3320
)d op blowUpWithExcpDiv
--R 
--R
--RThere is one exposed function called blowUpWithExcpDiv :
--R   [1] D6 -> Void from DesingTreePackage(D7,D8,D9,D10,D11,D12,D1,D2,D3,
--R            D6,D4)
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D9 has POLYCAT(D7
--R            ,D10,OVAR(D8)) and D10 has DIRPCAT(#(D8),NNI) and D11 has 
--R            PRSPCAT(D7) and D12 has LOCPOWC(D7) and D1 has PLACESC(D7,
--R            D12) and D2 has DIVCAT(D1) and D3 has INFCLCT(D7,D8,D9,D10,
--R            D11,D12,D1,D2,D4) and D4 has BLMETCT and D6 has DSTRCAT(D3)
--R            
--R
--RExamples of blowUpWithExcpDiv from DesingTreePackage
--R
--E 226

--S 227 of 3320
)d op blue
--R 
--R
--RThere is one exposed function called blue :
--R   [1]  -> Color from Color
--R
--RExamples of blue from Color
--R
--E 227

--S 228 of 3320
)d op bombieriNorm
--R 
--R
--RThere are 2 unexposed functions called bombieriNorm :
--R   [1] D2 -> D1 from GaloisGroupFactorizationUtilities(D3,D2,D1)
--R             if D3 has RING and D1 has Join(FloatingPointSystem,
--R            RetractableTo(D3),Field,TranscendentalFunctionCategory,
--R            ElementaryFunctionCategory) and D2 has UPOLYC(D3)
--R   [2] (D2,PositiveInteger) -> D1
--R             from GaloisGroupFactorizationUtilities(D4,D2,D1)
--R             if D4 has RING and D1 has Join(FloatingPointSystem,
--R            RetractableTo(D4),Field,TranscendentalFunctionCategory,
--R            ElementaryFunctionCategory) and D2 has UPOLYC(D4)
--R
--RExamples of bombieriNorm from GaloisGroupFactorizationUtilities
--R
--E 228

--S 229 of 3320
)d op bottom!
--R 
--R
--RThere are 2 exposed functions called bottom! :
--R   [1] Dequeue(D1) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [2] D -> D1 from D if D has DQAGG(D1) and D1 has TYPE
--R
--RExamples of bottom! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rbottom! a 
--Ra
--R
--R
--RExamples of bottom! from DequeueAggregate
--R
--E 229

--S 230 of 3320
)d op BoundIntegerRoots
--R 
--R   BoundIntegerRoots is not a known function. Axiom will try to list 
--R      its functions which contain BoundIntegerRoots in their names. 
--R      This is the same output you would get by issuing
--R                     )what operations BoundIntegerRoots
--R
--R   There are no operations containing those patterns
--R
--E 230

--S 231 of 3320
)d op boundOfCauchy
--R 
--R
--RThere is one exposed function called boundOfCauchy :
--R   [1] D2 -> D1 from RealPolynomialUtilitiesPackage(D1,D2)
--R             if D1 has FIELD and D1 has ORDRING and D2 has UPOLYC(D1)
--R         
--R
--RExamples of boundOfCauchy from RealPolynomialUtilitiesPackage
--R
--E 231

--S 232 of 3320
)d op box
--R 
--R
--RThere are 2 exposed functions called box :
--R   [1] List(D) -> D from D if D has ES
--R   [2] D -> D from D if D has ES
--R
--RThere is one unexposed function called box :
--R   [1] OutputForm -> OutputForm from OutputForm
--R
--RExamples of box from ExpressionSpace
--R
--R
--RExamples of box from OutputForm
--R
--E 232

--S 233 of 3320
)d op brace
--R 
--R
--RThere are 2 exposed functions called brace :
--R   [1] List(D2) -> D from D if D2 has SETCAT and D has SETAGG(D2)
--R   [2]  -> D from D if D has SETAGG(D1) and D1 has SETCAT
--R
--RThere are 2 unexposed functions called brace :
--R   [1] List(OutputForm) -> OutputForm from OutputForm
--R   [2] OutputForm -> OutputForm from OutputForm
--R
--RExamples of brace from OutputForm
--R
--R
--RExamples of brace from SetAggregate
--R
--E 233

--S 234 of 3320
)d op bracket
--R 
--R
--RThere are 2 unexposed functions called bracket :
--R   [1] List(OutputForm) -> OutputForm from OutputForm
--R   [2] OutputForm -> OutputForm from OutputForm
--R
--RExamples of bracket from OutputForm
--R
--E 234

--S 235 of 3320
)d op branchIfCan
--R 
--R
--RThere are 2 exposed functions called branchIfCan :
--R   [1] (List(D8),D3,List(D8),Boolean,Boolean,Boolean,Boolean,Boolean)
--R             -> Union(Record(eq: List(D8),tower: D3,ineq: List(D8)),"failed")
--R             from QuasiComponentPackage(D5,D6,D7,D8,D3)
--R             if D5 has GCDDOM and D6 has OAMONS and D7 has ORDSET and 
--R            D8 has RPOLCAT(D5,D6,D7) and D3 has RSETCAT(D5,D6,D7,D8)
--R         
--R   [2] (List(D8),D3,List(D8),Boolean,Boolean,Boolean,Boolean,Boolean)
--R             -> Union(Record(eq: List(D8),tower: D3,ineq: List(D8)),"failed")
--R             from SquareFreeQuasiComponentPackage(D5,D6,D7,D8,D3)
--R             if D5 has GCDDOM and D6 has OAMONS and D7 has ORDSET and 
--R            D8 has RPOLCAT(D5,D6,D7) and D3 has RSETCAT(D5,D6,D7,D8)
--R         
--R
--RExamples of branchIfCan from QuasiComponentPackage
--R
--R
--RExamples of branchIfCan from SquareFreeQuasiComponentPackage
--R
--E 235

--S 236 of 3320
)d op branchPoint?
--R 
--R
--RThere are 2 exposed functions called branchPoint? :
--R   [1] D2 -> Boolean from D
--R             if D has FFCAT(D3,D2,D4) and D3 has UFD and D2 has UPOLYC(
--R            D3) and D4 has UPOLYC(FRAC(D2))
--R   [2] D2 -> Boolean from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of branchPoint? from FunctionFieldCategory
--R
--E 236

--S 237 of 3320 done
)d op branchPointAtInfinity?
--R 
--R
--RThere is one exposed function called branchPointAtInfinity? :
--R   [1]  -> Boolean from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of branchPointAtInfinity? from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RbranchPointAtInfinity?()$R 
--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
--RbranchPointAtInfinity?()$R
--R
--E 237

--S 238 of 3320
)d op bright
--R 
--R
--RThere are 3 exposed functions called bright :
--R   [1] String -> List(String) from DisplayPackage
--R   [2] List(String) -> List(String) from DisplayPackage
--R   [3] Color -> Palette from Palette
--R
--RExamples of bright from DisplayPackage
--R
--R
--RExamples of bright from Palette
--R
--E 238

--S 239 of 3320
)d op brillhartIrreducible?
--R 
--R
--RThere are 2 unexposed functions called brillhartIrreducible? :
--R   [1] D2 -> Boolean from BrillhartTests(D2) if D2 has UPOLYC(INT)
--R   [2] (D2,Boolean) -> Boolean from BrillhartTests(D2) if D2 has UPOLYC
--R            (INT)
--R
--RExamples of brillhartIrreducible? from BrillhartTests
--R
--E 239

--S 240 of 3320
)d op brillhartTrials
--R 
--R
--RThere are 2 unexposed functions called brillhartTrials :
--R   [1]  -> NonNegativeInteger from BrillhartTests(D2) if D2 has UPOLYC(
--R            INT)
--R   [2] NonNegativeInteger -> NonNegativeInteger from BrillhartTests(D2)
--R             if D2 has UPOLYC(INT)
--R
--RExamples of brillhartTrials from BrillhartTests
--R
--E 240

--S 241 of 3320
)d op bringDown
--R 
--R
--RThere are 2 unexposed functions called bringDown :
--R   [1] D2 -> Fraction(Integer) from FunctionSpaceReduce(D3,D2)
--R             if D3 has Join(OrderedSet,IntegralDomain,RetractableTo(
--R            Integer)) and D2 has FS(D3)
--R   [2] (D2,Kernel(D2)) -> SparseUnivariatePolynomial(Fraction(Integer))
--R             from FunctionSpaceReduce(D4,D2)
--R             if D2 has FS(D4) and D4 has Join(OrderedSet,IntegralDomain
--R            ,RetractableTo(Integer))
--R
--RExamples of bringDown from FunctionSpaceReduce
--R
--E 241

--S 242 of 3320
)d op bsolve
--R 
--R
--RThere is one unexposed function called bsolve :
--R   [1] (Matrix(D2),List(Fraction(Polynomial(D9))),NonNegativeInteger,
--R            String,Integer) -> Record(rgl: List(Record(eqzro: List(D2),neqzro
--R            : List(D2),wcond: List(Polynomial(D9)),bsoln: Record(partsol: 
--R            Vector(Fraction(Polynomial(D9))),basis: List(Vector(Fraction(
--R            Polynomial(D9))))))),rgsz: Integer)
--R             from ParametricLinearEquations(D9,D10,D1,D2)
--R             if D9 has Join(EuclideanDomain,CharacteristicZero) and D2
--R             has POLYCAT(D9,D1,D10) and D10 has Join(OrderedSet,
--R            ConvertibleTo(Symbol)) and D1 has OAMONS
--R
--RExamples of bsolve from ParametricLinearEquations
--R
--E 242

--S 243 of 3320
)d op btwFact
--R 
--R
--RThere is one unexposed function called btwFact :
--R   [1] (D2,Boolean,Set(NonNegativeInteger),NonNegativeInteger) -> 
--R            Record(contp: Integer,factors: List(Record(irr: D2,pow: Integer))
--R            )
--R             from GaloisGroupFactorizer(D2) if D2 has UPOLYC(INT)
--R
--RExamples of btwFact from GaloisGroupFactorizer
--R
--E 243

--S 244 of 3320
)d op bubbleSort!
--R 
--R
--RThere are 2 unexposed functions called bubbleSort! :
--R   [1] (D1,((D3,D3) -> Boolean)) -> D1 from SortPackage(D3,D1)
--R             if D3 has TYPE and D1 has IndexedAggregate(Integer,D3)with
--R                 finiteAggregate
--R                 shallowlyMutable
--R   [2] D1 -> D1 from SortPackage(D2,D1)
--R             if D2 has ORDSET and D2 has TYPE and D1 has 
--R            IndexedAggregate(Integer,D2)with
--R                 finiteAggregate
--R                 shallowlyMutable
--R
--RExamples of bubbleSort! from SortPackage
--R
--E 244

--S 245 of 3320
)d op build
--R 
--R
--RThere is one unexposed function called build :
--R   [1] (D1,D2,D3) -> GeneralModulePolynomial(D4,D1,D2,D3,D5,D6)
--R             from GeneralModulePolynomial(D4,D1,D2,D3,D5,D6)
--R             if D4: LIST(SYMBOL) and D1 has COMRING and D3 has DIRPCAT(
--R            #(D4),NNI) and D5: ((Record(index: D2,exponent: D3),Record(
--R            index: D2,exponent: D3)) -> Boolean) and D2 has ORDSET and 
--R            D6 has POLYCAT(D1,D3,OVAR(D4))
--R
--RExamples of build from GeneralModulePolynomial
--R
--E 245

--S 246 of 3320
)d op BumInSepFFE
--R 
--R
--RThere is one unexposed function called BumInSepFFE :
--R   [1] Record(flg: Union("nil","sqfr","irred","prime"),fctr: D3,xpnt: 
--R            Integer) -> Record(flg: Union("nil","sqfr","irred","prime"),fctr
--R            : D3,xpnt: Integer)
--R             from UnivariatePolynomialSquareFree(D2,D3)
--R             if D3 has Join(UnivariatePolynomialCategory(D2),
--R            IntegralDomain)with
--R               gcd : (%,%) -> %and D2 has INTDOM
--R
--RExamples of BumInSepFFE from UnivariatePolynomialSquareFree
--R
--E 246

--S 247 of 3320
)d op bumprow
--R 
--R
--RThere is one unexposed function called bumprow :
--R   [1] (((D5,D5) -> Boolean),List(D5),List(List(D5))) -> Record(fs: 
--R            Boolean,sd: List(D5),td: List(List(D5)))
--R             from TableauxBumpers(D5) if D5 has ORDSET
--R
--RExamples of bumprow from TableauxBumpers
--R
--E 247

--S 248 of 3320
)d op bumptab
--R 
--R
--RThere is one unexposed function called bumptab :
--R   [1] (((D4,D4) -> Boolean),List(D4),List(List(List(D4)))) -> List(
--R            List(List(D4)))
--R             from TableauxBumpers(D4) if D4 has ORDSET
--R
--RExamples of bumptab from TableauxBumpers
--R
--E 248

--S 249 of 3320
)d op bumptab1
--R 
--R
--RThere is one unexposed function called bumptab1 :
--R   [1] (List(D3),List(List(List(D3)))) -> List(List(List(D3)))
--R             from TableauxBumpers(D3) if D3 has ORDSET
--R
--RExamples of bumptab1 from TableauxBumpers
--R
--E 249

--S 250 of 3320
)d op BY
--R 
--R
--RThere is one exposed function called BY :
--R   [1] (D,Integer) -> D from D if D has SEGCAT(D2) and D2 has TYPE
--R
--RExamples of BY from SegmentCategory
--R
--E 250

--S 251 of 3320
)d op c02aff
--R 
--R
--RThere is one exposed function called c02aff :
--R   [1] (Matrix(DoubleFloat),Integer,Boolean,Integer) -> Result
--R             from NagPolynomialRootsPackage
--R
--RExamples of c02aff from NagPolynomialRootsPackage
--R
--E 251

--S 252 of 3320
)d op c02agf
--R 
--R
--RThere is one exposed function called c02agf :
--R   [1] (Matrix(DoubleFloat),Integer,Boolean,Integer) -> Result
--R             from NagPolynomialRootsPackage
--R
--RExamples of c02agf from NagPolynomialRootsPackage
--R
--E 252

--S 253 of 3320
)d op c05adf
--R 
--R
--RThere is one exposed function called c05adf :
--R   [1] (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,Integer,Union(
--R            fn: FileName,fp: Asp1(F))) -> Result
--R             from NagRootFindingPackage
--R
--RExamples of c05adf from NagRootFindingPackage
--R
--E 253

--S 254 of 3320
)d op c05nbf
--R 
--R
--RThere is one exposed function called c05nbf :
--R   [1] (Integer,Integer,Matrix(DoubleFloat),DoubleFloat,Integer,Union(
--R            fn: FileName,fp: Asp6(FCN))) -> Result
--R             from NagRootFindingPackage
--R
--RExamples of c05nbf from NagRootFindingPackage
--R
--E 254

--S 255 of 3320
)d op c05pbf
--R 
--R
--RThere is one exposed function called c05pbf :
--R   [1] (Integer,Integer,Integer,Matrix(DoubleFloat),DoubleFloat,Integer
--R            ,Union(fn: FileName,fp: Asp35(FCN))) -> Result
--R             from NagRootFindingPackage
--R
--RExamples of c05pbf from NagRootFindingPackage
--R
--E 255

--S 256 of 3320
)d op c06eaf
--R 
--R
--RThere is one exposed function called c06eaf :
--R   [1] (Integer,Matrix(DoubleFloat),Integer) -> Result
--R             from NagSeriesSummationPackage
--R
--RExamples of c06eaf from NagSeriesSummationPackage
--R
--E 256

--S 257 of 3320
)d op c06ebf
--R 
--R
--RThere is one exposed function called c06ebf :
--R   [1] (Integer,Matrix(DoubleFloat),Integer) -> Result
--R             from NagSeriesSummationPackage
--R
--RExamples of c06ebf from NagSeriesSummationPackage
--R
--E 257

--S 258 of 3320
)d op c06ecf
--R 
--R
--RThere is one exposed function called c06ecf :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Integer) -> 
--R            Result
--R             from NagSeriesSummationPackage
--R
--RExamples of c06ecf from NagSeriesSummationPackage
--R
--E 258

--S 259 of 3320
)d op c06ekf
--R 
--R
--RThere is one exposed function called c06ekf :
--R   [1] (Integer,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Integer
--R            ) -> Result
--R             from NagSeriesSummationPackage
--R
--RExamples of c06ekf from NagSeriesSummationPackage
--R
--E 259

--S 260 of 3320
)d op c06fpf
--R 
--R
--RThere is one exposed function called c06fpf :
--R   [1] (Integer,Integer,String,Matrix(DoubleFloat),Matrix(DoubleFloat),
--R            Integer) -> Result
--R             from NagSeriesSummationPackage
--R
--RExamples of c06fpf from NagSeriesSummationPackage
--R
--E 260

--S 261 of 3320
)d op c06fqf
--R 
--R
--RThere is one exposed function called c06fqf :
--R   [1] (Integer,Integer,String,Matrix(DoubleFloat),Matrix(DoubleFloat),
--R            Integer) -> Result
--R             from NagSeriesSummationPackage
--R
--RExamples of c06fqf from NagSeriesSummationPackage
--R
--E 261

--S 262 of 3320
)d op c06frf
--R 
--R
--RThere is one exposed function called c06frf :
--R   [1] (Integer,Integer,String,Matrix(DoubleFloat),Matrix(DoubleFloat),
--R            Matrix(DoubleFloat),Integer) -> Result
--R             from NagSeriesSummationPackage
--R
--RExamples of c06frf from NagSeriesSummationPackage
--R
--E 262

--S 263 of 3320
)d op c06fuf
--R 
--R
--RThere is one exposed function called c06fuf :
--R   [1] (Integer,Integer,String,Matrix(DoubleFloat),Matrix(DoubleFloat),
--R            Matrix(DoubleFloat),Matrix(DoubleFloat),Integer) -> Result
--R             from NagSeriesSummationPackage
--R
--RExamples of c06fuf from NagSeriesSummationPackage
--R
--E 263

--S 264 of 3320
)d op c06gbf
--R 
--R
--RThere is one exposed function called c06gbf :
--R   [1] (Integer,Matrix(DoubleFloat),Integer) -> Result
--R             from NagSeriesSummationPackage
--R
--RExamples of c06gbf from NagSeriesSummationPackage
--R
--E 264

--S 265 of 3320
)d op c06gcf
--R 
--R
--RThere is one exposed function called c06gcf :
--R   [1] (Integer,Matrix(DoubleFloat),Integer) -> Result
--R             from NagSeriesSummationPackage
--R
--RExamples of c06gcf from NagSeriesSummationPackage
--R
--E 265

--S 266 of 3320
)d op c06gqf
--R 
--R
--RThere is one exposed function called c06gqf :
--R   [1] (Integer,Integer,Matrix(DoubleFloat),Integer) -> Result
--R             from NagSeriesSummationPackage
--R
--RExamples of c06gqf from NagSeriesSummationPackage
--R
--E 266

--S 267 of 3320
)d op c06gsf
--R 
--R
--RThere is one exposed function called c06gsf :
--R   [1] (Integer,Integer,Matrix(DoubleFloat),Integer) -> Result
--R             from NagSeriesSummationPackage
--R
--RExamples of c06gsf from NagSeriesSummationPackage
--R
--E 267

--S 268 of 3320
)d op cache
--R 
--R
--RThere is one unexposed function called cache :
--R   [1]  -> List(D2) from SortedCache(D2) if D2 has CACHSET
--R
--RExamples of cache from SortedCache
--R
--E 268

--S 269 of 3320
)d op cAcos
--R 
--R
--RThere is one unexposed function called cAcos :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cAcos from InnerSparseUnivariatePowerSeries
--R
--E 269

--S 270 of 3320
)d op cAcosh
--R 
--R
--RThere is one unexposed function called cAcosh :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cAcosh from InnerSparseUnivariatePowerSeries
--R
--E 270

--S 271 of 3320
)d op cAcot
--R 
--R
--RThere is one unexposed function called cAcot :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cAcot from InnerSparseUnivariatePowerSeries
--R
--E 271

--S 272 of 3320
)d op cAcoth
--R 
--R
--RThere is one unexposed function called cAcoth :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cAcoth from InnerSparseUnivariatePowerSeries
--R
--E 272

--S 273 of 3320
)d op cAcsc
--R 
--R
--RThere is one unexposed function called cAcsc :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cAcsc from InnerSparseUnivariatePowerSeries
--R
--E 273

--S 274 of 3320
)d op cAcsch
--R 
--R
--RThere is one unexposed function called cAcsch :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cAcsch from InnerSparseUnivariatePowerSeries
--R
--E 274

--S 275 of 3320
)d op calcRanges
--R 
--R
--RThere is one unexposed function called calcRanges :
--R   [1] List(List(Point(DoubleFloat))) -> List(Segment(DoubleFloat))
--R             from PlotTools
--R
--RExamples of calcRanges from PlotTools
--R
--E 275

--S 276 of 3320
)d op call
--R 
--R
--RThere is one exposed function called call :
--R   [1] String -> FortranCode from FortranCode
--R
--RExamples of call from FortranCode
--R
--E 276

--S 277 of 3320
)d op canonicalIfCan
--R 
--R
--RThere is one exposed function called canonicalIfCan :
--R   [1] (D1,D2) -> Union(D1,"failed") from D
--R             if D has MAGCDOC(D1,D2) and D1 has TYPE and D2 has TYPE
--R         
--R
--RExamples of canonicalIfCan from ModularAlgebraicGcdOperations
--R
--E 277

--S 278 of 3320
)d op cap
--R 
--R
--RThere is one exposed function called cap :
--R   [1] (SymmetricPolynomial(Fraction(Integer)),SymmetricPolynomial(
--R            Fraction(Integer))) -> Fraction(Integer)
--R             from CycleIndicators
--R
--RExamples of cap from CycleIndicators
--R
--E 278

--S 279 of 3320
)d op car
--R 
--R
--RThere is one exposed function called car :
--R   [1] D -> D from D
--R             if D has SEXCAT(D1,D2,D3,D4,D5) and D1 has SETCAT and D2
--R             has SETCAT and D3 has SETCAT and D4 has SETCAT and D5 has 
--R            SETCAT
--R
--RExamples of car from SExpressionCategory
--R
--E 279

--S 280 of 3320
)d op cardinality
--R 
--R
--RThere is one exposed function called cardinality :
--R   [1] D -> NonNegativeInteger from D if D has FSAGG(D2) and D2 has 
--R            SETCAT
--R
--RExamples of cardinality from FiniteSetAggregate
--R
--E 280

--S 281 of 3320
)d op cartesian
--R 
--R
--RThere is one exposed function called cartesian :
--R   [1] Point(D2) -> Point(D2) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of cartesian from CoordinateSystems
--R
--E 281

--S 282 of 3320
)d op cAsec
--R 
--R
--RThere is one unexposed function called cAsec :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cAsec from InnerSparseUnivariatePowerSeries
--R
--E 282

--S 283 of 3320
)d op cAsech
--R 
--R
--RThere is one unexposed function called cAsech :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cAsech from InnerSparseUnivariatePowerSeries
--R
--E 283

--S 284 of 3320
)d op cAsin
--R 
--R
--RThere is one unexposed function called cAsin :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cAsin from InnerSparseUnivariatePowerSeries
--R
--E 284

--S 285 of 3320
)d op cAsinh
--R 
--R
--RThere is one unexposed function called cAsinh :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cAsinh from InnerSparseUnivariatePowerSeries
--R
--E 285

--S 286 of 3320
)d op cAtan
--R 
--R
--RThere is one unexposed function called cAtan :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cAtan from InnerSparseUnivariatePowerSeries
--R
--E 286

--S 287 of 3320
)d op cAtanh
--R 
--R
--RThere is one unexposed function called cAtanh :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cAtanh from InnerSparseUnivariatePowerSeries
--R
--E 287

--S 288 of 3320
)d op cCos
--R 
--R
--RThere is one unexposed function called cCos :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cCos from InnerSparseUnivariatePowerSeries
--R
--E 288

--S 289 of 3320
)d op cCosh
--R 
--R
--RThere is one unexposed function called cCosh :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cCosh from InnerSparseUnivariatePowerSeries
--R
--E 289

--S 290 of 3320
)d op cCot
--R 
--R
--RThere is one unexposed function called cCot :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cCot from InnerSparseUnivariatePowerSeries
--R
--E 290

--S 291 of 3320
)d op cCoth
--R 
--R
--RThere is one unexposed function called cCoth :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cCoth from InnerSparseUnivariatePowerSeries
--R
--E 291

--S 292 of 3320
)d op cCsc
--R 
--R
--RThere is one unexposed function called cCsc :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cCsc from InnerSparseUnivariatePowerSeries
--R
--E 292

--S 293 of 3320
)d op cCsch
--R 
--R
--RThere is one unexposed function called cCsch :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cCsch from InnerSparseUnivariatePowerSeries
--R
--E 293

--S 294 of 3320
)d op cdr
--R 
--R
--RThere is one exposed function called cdr :
--R   [1] D -> D from D
--R             if D has SEXCAT(D1,D2,D3,D4,D5) and D1 has SETCAT and D2
--R             has SETCAT and D3 has SETCAT and D4 has SETCAT and D5 has 
--R            SETCAT
--R
--RExamples of cdr from SExpressionCategory
--R
--E 294

--S 295 of 3320
)d op ceiling
--R 
--R
--RThere are 2 exposed functions called ceiling :
--R   [1] D -> D1 from D if D has QFCAT(D1) and D1 has INTDOM and D1 has 
--R            INS
--R   [2] D -> D from D if D has RNS
--R
--RExamples of ceiling from QuotientFieldCategory
--R
--R
--RExamples of ceiling from RealNumberSystem
--R
--E 295

--S 296 of 3320
)d op center
--R 
--R
--RThere are 3 exposed functions called center :
--R   [1] (String,Integer,String) -> String from DisplayPackage
--R   [2] (List(String),Integer,String) -> List(String) from 
--R            DisplayPackage
--R   [3] D -> D1 from D if D has UPSCAT(D1,D2) and D2 has OAMON and D1
--R             has RING
--R
--RThere are 2 unexposed functions called center :
--R   [1] OutputForm -> OutputForm from OutputForm
--R   [2] (OutputForm,Integer) -> OutputForm from OutputForm
--R
--RExamples of center from DisplayPackage
--R
--R
--RExamples of center from OutputForm
--R
--R
--RExamples of center from UnivariatePowerSeriesCategory
--R
--E 296

--S 297 of 3320
)d op central?
--R 
--R
--RThere is one exposed function called central? :
--R   [1] (DoubleFloat,DoubleFloat,List(Expression(DoubleFloat))) -> 
--R            Boolean
--R             from d03AgentsPackage
--R
--RExamples of central? from d03AgentsPackage
--R
--E 297

--S 298 of 3320
)d op certainlySubVariety?
--R 
--R
--RThere is one unexposed function called certainlySubVariety? :
--R   [1] (List(D6),List(D6)) -> Boolean
--R             from PolynomialSetUtilitiesPackage(D3,D4,D5,D6)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has INTDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R
--RExamples of certainlySubVariety? from PolynomialSetUtilitiesPackage
--R
--E 298

--S 299 of 3320
)d op cExp
--R 
--R
--RThere is one unexposed function called cExp :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cExp from InnerSparseUnivariatePowerSeries
--R
--E 299

--S 300 of 3320
)d op cfirst
--R 
--R
--RThere is one unexposed function called cfirst :
--R   [1] NonNegativeInteger -> (Stream(Polynomial(D3)) -> Stream(
--R            Polynomial(D3)))
--R             from WeierstrassPreparation(D3) if D3 has FIELD
--R
--RExamples of cfirst from WeierstrassPreparation
--R
--E 300

--S 301 of 3320
)d op chainSubResultants
--R 
--R
--RThere is one unexposed function called chainSubResultants :
--R   [1] (D2,D2) -> List(D2) from PseudoRemainderSequence(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of chainSubResultants from PseudoRemainderSequence
--R
--E 301

--S 302 of 3320
)d op changeBase
--R 
--R
--RThere is one exposed function called changeBase :
--R   [1] (Integer,Integer,PositiveInteger) -> MachineFloat from 
--R            MachineFloat
--R
--RThere is one unexposed function called changeBase :
--R   [1] (Matrix(D4),Matrix(D4),Automorphism(D4),(D4 -> D4)) -> Matrix(D4
--R            )
--R             from PseudoLinearNormalForm(D4) if D4 has FIELD
--R
--RExamples of changeBase from MachineFloat
--R
--R
--RExamples of changeBase from PseudoLinearNormalForm
--R
--E 302

--S 303 of 3320
)d op changeMeasure
--R 
--R
--RThere is one exposed function called changeMeasure :
--R   [1] (RoutinesTable,Symbol,Float) -> RoutinesTable from RoutinesTable
--R            
--R
--RExamples of changeMeasure from RoutinesTable
--R
--E 303

--S 304 of 3320
)d op changeName
--R 
--R
--RThere is one exposed function called changeName :
--R   [1] (Symbol,Symbol,Result) -> Result from d01AgentsPackage
--R
--RExamples of changeName from d01AgentsPackage
--R
--E 304

--S 305 of 3320
)d op changeNameToObjf
--R 
--R
--RThere is one exposed function called changeNameToObjf :
--R   [1] (Symbol,Result) -> Result from e04AgentsPackage
--R
--RExamples of changeNameToObjf from e04AgentsPackage
--R
--E 305

--S 306 of 3320
)d op changeThreshhold
--R 
--R
--RThere is one exposed function called changeThreshhold :
--R   [1] (RoutinesTable,Symbol,Float) -> RoutinesTable from RoutinesTable
--R            
--R
--RExamples of changeThreshhold from RoutinesTable
--R
--E 306

--S 307 of 3320
)d op changeVar
--R 
--R
--RThere are 2 unexposed functions called changeVar :
--R   [1] (D1,D2) -> D1 from PrimitiveRatRicDE(D3,D2,D1,D4)
--R             if D3 has Join(Field,CharacteristicZero,RetractableTo(
--R            Fraction(Integer))) and D2 has UPOLYC(D3) and D1 has 
--R            LODOCAT(D2) and D4 has LODOCAT(FRAC(D2))
--R   [2] (D1,Fraction(D4)) -> D1 from PrimitiveRatRicDE(D3,D4,D1,D5)
--R             if D3 has Join(Field,CharacteristicZero,RetractableTo(
--R            Fraction(Integer))) and D4 has UPOLYC(D3) and D1 has 
--R            LODOCAT(D4) and D5 has LODOCAT(FRAC(D4))
--R
--RExamples of changeVar from PrimitiveRatRicDE
--R
--E 307

--S 308 of 3320
)d op changeWeightLevel
--R 
--R
--RThere are 2 unexposed functions called changeWeightLevel :
--R   [1] NonNegativeInteger -> Void from OrdinaryWeightedPolynomials(D3,
--R            D4,D5,D6)
--R             if D3 has RING and D4: LIST(SYMBOL) and D5: LIST(NNI) and 
--R            D6: NNI
--R   [2] NonNegativeInteger -> Void from WeightedPolynomials(D4,D5,D6,D7,
--R            D8,D9,D1)
--R             if D4 has RING and D5 has ORDSET and D6 has OAMONS and D8
--R            : LIST(D5) and D7 has POLYCAT(D4,D6,D5) and D9: LIST(NNI) 
--R            and D1: NNI
--R
--RExamples of changeWeightLevel from OrdinaryWeightedPolynomials
--R
--R
--RExamples of changeWeightLevel from WeightedPolynomials
--R
--E 308

--S 309 of 3320 done
)d op char
--R 
--R
--RThere are 2 exposed functions called char :
--R   [1] String -> Character from Character
--R   [2] Integer -> Character from Character
--R
--RExamples of char from Character
--R
--R[char c for c in ["a","A","X","8","+"]]
--R
--R[char c for c in [97,65,88,56,43]]
--R
--E 309

--S 310 of 3320
)d op character?
--R 
--R
--RThere is one exposed function called character? :
--R   [1] FortranScalarType -> Boolean from FortranScalarType
--R
--RExamples of character? from FortranScalarType
--R
--E 310

--S 311 of 3320
)d op characteristic
--R 
--R
--RThere are 2 exposed functions called characteristic :
--R   [1]  -> NonNegativeInteger from D if D has NASRING
--R   [2]  -> NonNegativeInteger from D if D has RING
--R
--RThere are 9 unexposed functions called characteristic :
--R   [1]  -> NonNegativeInteger from ComplexCategory&(D2,D3)
--R             if D3 has COMRING and D2 has COMPCAT(D3)
--R   [2]  -> NonNegativeInteger from DirectProductCategory&(D2,D3,D4)
--R             if D3: NNI and D4 has TYPE and D2 has DIRPCAT(D3,D4)
--R   [3]  -> NonNegativeInteger from FunctionSpace&(D2,D3)
--R             if D3 has ORDSET and D2 has FS(D3)
--R   [4]  -> NonNegativeInteger from IntegerNumberSystem&(D2) if D2 has 
--R            INS
--R   [5]  -> NonNegativeInteger from OctonionCategory&(D2,D3)
--R             if D3 has COMRING and D2 has OC(D3)
--R   [6]  -> NonNegativeInteger from QuotientFieldCategory&(D2,D3)
--R             if D3 has INTDOM and D2 has QFCAT(D3)
--R   [7]  -> NonNegativeInteger from QuaternionCategory&(D2,D3)
--R             if D3 has COMRING and D2 has QUATCAT(D3)
--R   [8]  -> NonNegativeInteger from RealClosedField&(D2) if D2 has 
--R            RCFIELD
--R   [9]  -> NonNegativeInteger from RealNumberSystem&(D2) if D2 has RNS
--R            
--R
--RExamples of characteristic from ComplexCategory&
--R
--R
--RExamples of characteristic from DirectProductCategory&
--R
--R
--RExamples of characteristic from FunctionSpace&
--R
--R
--RExamples of characteristic from IntegerNumberSystem&
--R
--R
--RExamples of characteristic from NonAssociativeRing
--R
--R
--RExamples of characteristic from OctonionCategory&
--R
--R
--RExamples of characteristic from QuotientFieldCategory&
--R
--R
--RExamples of characteristic from QuaternionCategory&
--R
--R
--RExamples of characteristic from RealClosedField&
--R
--R
--RExamples of characteristic from Ring
--R
--R
--RExamples of characteristic from RealNumberSystem&
--R
--E 311

--S 312 of 3320
)d op characteristicPolynomial
--R 
--R
--RThere are 8 exposed functions called characteristicPolynomial :
--R   [1] (Matrix(D1),D1) -> D1 from CharacteristicPolynomialPackage(D1)
--R             if D1 has COMRING
--R   [2] (Matrix(Fraction(Polynomial(D4))),Symbol) -> Polynomial(D4)
--R             from EigenPackage(D4) if D4 has GCDDOM
--R   [3] Matrix(Fraction(Polynomial(D3))) -> Polynomial(D3) from 
--R            EigenPackage(D3)
--R             if D3 has GCDDOM
--R   [4] D -> D1 from D
--R             if D has FINRALG(D2,D1) and D2 has COMRING and D1 has 
--R            UPOLYC(D2)
--R   [5] Matrix(Complex(Fraction(Integer))) -> Polynomial(Complex(
--R            Fraction(Integer)))
--R             from NumericComplexEigenPackage(D3) if D3 has Join(Field,
--R            OrderedRing)
--R   [6] (Matrix(Complex(Fraction(Integer))),Symbol) -> Polynomial(
--R            Complex(Fraction(Integer)))
--R             from NumericComplexEigenPackage(D4) if D4 has Join(Field,
--R            OrderedRing)
--R   [7] Matrix(Fraction(Integer)) -> Polynomial(Fraction(Integer))
--R             from NumericRealEigenPackage(D3) if D3 has Join(Field,
--R            OrderedRing)
--R   [8] (Matrix(Fraction(Integer)),Symbol) -> Polynomial(Fraction(
--R            Integer))
--R             from NumericRealEigenPackage(D4) if D4 has Join(Field,
--R            OrderedRing)
--R
--RThere is one unexposed function called characteristicPolynomial :
--R   [1] D2 -> D1 from CharacteristicPolynomialInMonogenicalAlgebra(D3,D1
--R            ,D2)
--R             if D3 has COMRING and D1 has UPOLYC(D3) and D2 has MONOGEN
--R            (D3,D1)
--R
--RExamples of characteristicPolynomial from CharacteristicPolynomialPackage
--R
--R
--RExamples of characteristicPolynomial from CharacteristicPolynomialInMonogenicalAlgebra
--R
--R
--RExamples of characteristicPolynomial from EigenPackage
--R
--R
--RExamples of characteristicPolynomial from FiniteRankAlgebra
--R
--R
--RExamples of characteristicPolynomial from NumericComplexEigenPackage
--R
--R
--RExamples of characteristicPolynomial from NumericRealEigenPackage
--R
--E 312

--S 313 of 3320
)d op characteristicSerie
--R 
--R
--RThere are 2 exposed functions called characteristicSerie :
--R   [1] List(D6) -> List(WuWenTsunTriangularSet(D3,D4,D5,D6))
--R             from WuWenTsunTriangularSet(D3,D4,D5,D6)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has INTDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [2] (List(D8),((D8,D8) -> Boolean),((D8,D8) -> D8)) -> List(
--R            WuWenTsunTriangularSet(D5,D6,D7,D8))
--R             from WuWenTsunTriangularSet(D5,D6,D7,D8)
--R             if D8 has RPOLCAT(D5,D6,D7) and D5 has INTDOM and D6 has 
--R            OAMONS and D7 has ORDSET
--R
--RExamples of characteristicSerie from WuWenTsunTriangularSet
--R
--E 313

--S 314 of 3320
)d op characteristicSet
--R 
--R
--RThere are 2 exposed functions called characteristicSet :
--R   [1] List(D5) -> Union(WuWenTsunTriangularSet(D2,D3,D4,D5),"failed")
--R             from WuWenTsunTriangularSet(D2,D3,D4,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has INTDOM and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [2] (List(D7),((D7,D7) -> Boolean),((D7,D7) -> D7)) -> Union(
--R            WuWenTsunTriangularSet(D4,D5,D6,D7),"failed")
--R             from WuWenTsunTriangularSet(D4,D5,D6,D7)
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has INTDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R
--RExamples of characteristicSet from WuWenTsunTriangularSet
--R
--E 314

--S 315 of 3320
)d op charClass
--R 
--R
--RThere are 2 exposed functions called charClass :
--R   [1] List(Character) -> CharacterClass from CharacterClass
--R   [2] String -> CharacterClass from CharacterClass
--R
--RExamples of charClass from CharacterClass
--R
--E 315

--S 316 of 3320
)d op charpol
--R 
--R
--RThere is one unexposed function called charpol :
--R   [1] Matrix(D3) -> SparseUnivariatePolynomial(D3)
--R             from InnerNumericEigenPackage(D3,D4,D5)
--R             if D3 has FIELD and D4 has FIELD and D5 has Join(Field,
--R            OrderedRing)
--R
--RExamples of charpol from InnerNumericEigenPackage
--R
--E 316

--S 317 of 3320
)d op chartCoord
--R 
--R
--RThere is one exposed function called chartCoord :
--R   [1] D -> Integer from D if D has BLMETCT
--R
--RExamples of chartCoord from BlowUpMethodCategory
--R
--E 317

--S 318 of 3320
)d op charthRoot
--R 
--R
--RThere are 3 exposed functions called charthRoot :
--R   [1] D -> Union(D,"failed") from D if D has CHARNZ
--R   [2] D -> D from D if D has FFIELDC
--R   [3] D -> Union(D,"failed") from D if D has CHARNZ and D has PFECAT
--R         
--R
--RExamples of charthRoot from FiniteFieldCategory
--R
--R
--RExamples of charthRoot from CharacteristicNonZero
--R
--E 318

--S 319 of 3320
)d op chartV
--R 
--R
--RThere is one exposed function called chartV :
--R   [1] D -> D2 from D
--R             if D has INFCLCT(D3,D4,D5,D6,D7,D8,D9,D1,D2) and D3 has 
--R            FIELD and D5 has POLYCAT(D3,D6,OVAR(D4)) and D6 has DIRPCAT
--R            (#(D4),NNI) and D7 has PRSPCAT(D3) and D8 has LOCPOWC(D3) 
--R            and D9 has PLACESC(D3,D8) and D2 has BLMETCT
--R
--RExamples of chartV from InfinitlyClosePointCategory
--R
--E 319

--S 320 of 3320
)d op chebyshevT
--R 
--R
--RThere is one exposed function called chebyshevT :
--R   [1] (NonNegativeInteger,D1) -> D1 from OrthogonalPolynomialFunctions
--R            (D1)
--R             if D1 has COMRING
--R
--RThere is one unexposed function called chebyshevT :
--R   [1] Integer -> SparseUnivariatePolynomial(Integer)
--R             from PolynomialNumberTheoryFunctions
--R
--RExamples of chebyshevT from OrthogonalPolynomialFunctions
--R
--R
--RExamples of chebyshevT from PolynomialNumberTheoryFunctions
--R
--E 320

--S 321 of 3320
)d op chebyshevU
--R 
--R
--RThere is one exposed function called chebyshevU :
--R   [1] (NonNegativeInteger,D1) -> D1 from OrthogonalPolynomialFunctions
--R            (D1)
--R             if D1 has COMRING
--R
--RThere is one unexposed function called chebyshevU :
--R   [1] Integer -> SparseUnivariatePolynomial(Integer)
--R             from PolynomialNumberTheoryFunctions
--R
--RExamples of chebyshevU from OrthogonalPolynomialFunctions
--R
--R
--RExamples of chebyshevU from PolynomialNumberTheoryFunctions
--R
--E 321

--S 322 of 3320
)d op check
--R 
--R
--RThere are 2 exposed functions called check :
--R   [1] Union(skip,MonteCarlo,deterministic) -> GuessOption from 
--R            GuessOption
--R   [2] D -> D from D if D has SPACEC(D1) and D1 has RING
--R
--RThere are 2 unexposed functions called check :
--R   [1] List(GuessOption) -> Union(skip,MonteCarlo,deterministic)
--R             from GuessOptionFunctions0
--R   [2] (List(Record(factor: SparseUnivariatePolynomial(D5),exponent: 
--R            Integer)),List(Record(factor: SparseUnivariatePolynomial(D5),
--R            exponent: Integer))) -> Boolean
--R             from MultivariateSquareFree(D3,D4,D5,D6)
--R             if D5 has EUCDOM and D3 has OAMONS and D4 has ORDSET and 
--R            D6 has POLYCAT(D5,D3,D4)
--R
--RExamples of check from GuessOptionFunctions0
--R
--R
--RExamples of check from GuessOption
--R
--R
--RExamples of check from MultivariateSquareFree
--R
--R
--RExamples of check from ThreeSpaceCategory
--R
--E 322

--S 323 of 3320
)d op checkExtraValues
--R 
--R
--RThere is one exposed function called checkExtraValues :
--R   [1] Boolean -> GuessOption from GuessOption
--R
--RThere is one unexposed function called checkExtraValues :
--R   [1] List(GuessOption) -> Boolean from GuessOptionFunctions0
--R
--RExamples of checkExtraValues from GuessOptionFunctions0
--R
--R
--RExamples of checkExtraValues from GuessOption
--R
--E 323

--S 324 of 3320
)d op checkForZero
--R 
--R
--RThere are 2 unexposed functions called checkForZero :
--R   [1] (Polynomial(D5),Symbol,OrderedCompletion(D6),OrderedCompletion(
--R            D6),Boolean) -> Union(Boolean,"failed")
--R             from DefiniteIntegrationTools(D5,D6)
--R             if D5 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D6 has Join(
--R            TranscendentalFunctionCategory,
--R            AlgebraicallyClosedFunctionSpace(D5))
--R   [2] (SparseUnivariatePolynomial(D5),OrderedCompletion(D5),
--R            OrderedCompletion(D5),Boolean) -> Union(Boolean,"failed")
--R             from DefiniteIntegrationTools(D4,D5)
--R             if D5 has Join(TranscendentalFunctionCategory,
--R            AlgebraicallyClosedFunctionSpace(D4)) and D4 has Join(
--R            GcdDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R
--RExamples of checkForZero from DefiniteIntegrationTools
--R
--E 324

--S 325 of 3320
)d op checkOptions
--R 
--R
--RThere is one unexposed function called checkOptions :
--R   [1] List(GuessOption) -> Void from GuessOptionFunctions0
--R
--RExamples of checkOptions from GuessOptionFunctions0
--R
--E 325

--S 326 of 3320
)d op checkPrecision
--R 
--R
--RThere is one exposed function called checkPrecision :
--R   [1]  -> Boolean from NAGLinkSupportPackage
--R
--RExamples of checkPrecision from NAGLinkSupportPackage
--R
--E 326

--S 327 of 3320
)d op checkRur
--R 
--R
--RThere is one unexposed function called checkRur :
--R   [1] (D2,List(D2)) -> Boolean
--R             from InternalRationalUnivariateRepresentationPackage(D4,D5
--R            ,D6,D7,D2)
--R             if D2 has SFRTCAT(D4,D5,D6,D7) and D4 has Join(
--R            EuclideanDomain,CharacteristicZero) and D5 has OAMONS and 
--R            D6 has ORDSET and D7 has RPOLCAT(D4,D5,D6)
--R
--RExamples of checkRur from InternalRationalUnivariateRepresentationPackage
--R
--E 327

--S 328 of 3320
)d op child
--R 
--R
--RThere is one unexposed function called child :
--R   [1] (SubSpace(D2,D3),NonNegativeInteger) -> SubSpace(D2,D3)
--R             from SubSpace(D2,D3) if D2: PI and D3 has RING
--R
--RExamples of child from SubSpace
--R
--E 328

--S 329 of 3320
)d op child?
--R 
--R
--RThere is one exposed function called child? :
--R   [1] (D,D) -> Boolean from D if D has RCAGG(D2) and D2 has TYPE and 
--R            D2 has SETCAT
--R
--RExamples of child? from RecursiveAggregate
--R
--E 329

--S 330 of 3320
)d op children
--R 
--R
--RThere is one exposed function called children :
--R   [1] D -> List(D) from D if D2 has TYPE and D has RCAGG(D2)
--R
--RThere is one unexposed function called children :
--R   [1] SubSpace(D2,D3) -> List(SubSpace(D2,D3)) from SubSpace(D2,D3)
--R             if D2: PI and D3 has RING
--R
--RExamples of children from RecursiveAggregate
--R
--R
--RExamples of children from SubSpace
--R
--E 330

--S 331 of 3320
)d op chineseRemainder
--R 
--R
--RThere are 3 exposed functions called chineseRemainder :
--R   [1] (List(D1),List(D1)) -> D1 from CRApackage(D1) if D1 has EUCDOM
--R         
--R   [2] (List(List(D3)),List(D3)) -> List(D3) from CRApackage(D3) if D3
--R             has EUCDOM
--R   [3] (Integer,Integer,Integer,Integer) -> Integer
--R             from IntegerNumberTheoryFunctions
--R
--RThere is one unexposed function called chineseRemainder :
--R   [1] (List(D7),List(Record(basis: Matrix(D6),basisDen: D6,basisInv: 
--R            Matrix(D6))),NonNegativeInteger) -> Record(basis: Matrix(D6),
--R            basisDen: D6,basisInv: Matrix(D6))
--R             from ChineseRemainderToolsForIntegralBases(D5,D6,D7)
--R             if D7 has UPOLYC(D6) and D6 has UPOLYC(D5) and D5 has 
--R            FFIELDC
--R
--RExamples of chineseRemainder from CRApackage
--R
--R
--RExamples of chineseRemainder from ChineseRemainderToolsForIntegralBases
--R
--R
--RExamples of chineseRemainder from IntegerNumberTheoryFunctions
--R
--E 331

--S 332 of 3320
)d op chiSquare
--R 
--R
--RThere is one unexposed function called chiSquare :
--R   [1] NonNegativeInteger -> (() -> Float) from 
--R            RandomFloatDistributions
--R
--RExamples of chiSquare from RandomFloatDistributions
--R
--E 332

--S 333 of 3320
)d op chiSquare1
--R 
--R
--RThere is one unexposed function called chiSquare1 :
--R   [1] NonNegativeInteger -> Float from RandomFloatDistributions
--R
--RExamples of chiSquare1 from RandomFloatDistributions
--R
--E 333

--S 334 of 3320
)d op choosemon
--R 
--R
--RThere is one unexposed function called choosemon :
--R   [1] (DistributedMultivariatePolynomial(D3,D4),List(
--R            DistributedMultivariatePolynomial(D3,D4))) -> 
--R            DistributedMultivariatePolynomial(D3,D4)
--R             from LinGroebnerPackage(D3,D4) if D3: LIST(SYMBOL) and D4
--R             has GCDDOM
--R
--RExamples of choosemon from LinGroebnerPackage
--R
--E 334

--S 335 of 3320
)d op chvar
--R 
--R
--RThere is one unexposed function called chvar :
--R   [1] (D2,D2) -> Record(func: D2,poly: D2,c1: Fraction(D4),c2: 
--R            Fraction(D4),deg: NonNegativeInteger)
--R             from ChangeOfVariable(D3,D4,D2)
--R             if D3 has UFD and D4 has UPOLYC(D3) and D2 has UPOLYC(FRAC
--R            (D4))
--R
--RExamples of chvar from ChangeOfVariable
--R
--E 335

--S 336 of 3320
)d op Ci
--R 
--R
--RThere is one exposed function called Ci :
--R   [1] D -> D from D if D has LFCAT
--R
--RThere is one unexposed function called Ci :
--R   [1] D1 -> D1 from LiouvillianFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R
--RExamples of Ci from LiouvillianFunctionCategory
--R
--R
--RExamples of Ci from LiouvillianFunction
--R
--E 336

--S 337 of 3320
)d op classNumber
--R 
--R
--RThere are 3 exposed functions called classNumber :
--R   [1]  -> Integer
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R             if D6 has FINITE and D6 has FIELD and D7: LIST(SYMBOL) and
--R            D8 has POLYCAT(D6,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI
--R            ) and D10 has PRSPCAT(D6) and D11 has LOCPOWC(D6) and D12
--R             has PLACESC(D6,D11) and D1 has DIVCAT(D12) and D2 has 
--R            INFCLCT(D6,D7,D8,D9,D10,D11,D12,D1,D4) and D4 has BLMETCT 
--R            and D3 has DSTRCAT(D2)
--R   [2]  -> Integer
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if PseudoAlgebraicClosureOfFiniteField(D2) has FINITE and 
--R            D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R   [3]  -> Integer from PackageForAlgebraicFunctionField(D2,D3,D4)
--R             if D2 has FINITE and D2 has FIELD and D3: LIST(SYMBOL) and
--R            D4 has BLMETCT
--R
--RExamples of classNumber from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of classNumber from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of classNumber from PackageForAlgebraicFunctionField
--R
--E 337

--S 338 of 3320
)d op clearCache
--R 
--R
--RThere is one unexposed function called clearCache :
--R   [1]  -> Void from SortedCache(D2) if D2 has CACHSET
--R
--RExamples of clearCache from SortedCache
--R
--E 338

--S 339 of 3320
)d op clearDenominator
--R 
--R
--RThere are 3 exposed functions called clearDenominator :
--R   [1] D1 -> D1 from CommonDenominator(D2,D3,D1)
--R             if D2 has INTDOM and D3 has QFCAT(D2) and D1 has FLAGG(D3)
--R            
--R   [2] Matrix(D4) -> Matrix(D3) from MatrixCommonDenominator(D3,D4)
--R             if D4 has QFCAT(D3) and D3 has INTDOM
--R   [3] D1 -> D1 from UnivariatePolynomialCommonDenominator(D2,D3,D1)
--R             if D2 has INTDOM and D3 has QFCAT(D2) and D1 has UPOLYC(D3
--R            )
--R
--RThere is one unexposed function called clearDenominator :
--R   [1] D2 -> D1 from InnerCommonDenominator(D3,D4,D1,D2)
--R             if D3 has INTDOM and D4 has QFCAT(D3) and D1 has FLAGG(D3)
--R            and D2 has FLAGG(D4)
--R
--RExamples of clearDenominator from CommonDenominator
--R
--R
--RExamples of clearDenominator from InnerCommonDenominator
--R
--R
--RExamples of clearDenominator from MatrixCommonDenominator
--R
--R
--RExamples of clearDenominator from UnivariatePolynomialCommonDenominator
--R
--E 339

--S 340 of 3320
)d op clearFortranOutputStack
--R 
--R
--RThere is one exposed function called clearFortranOutputStack :
--R   [1]  -> Stack(String) from FortranOutputStackPackage
--R
--RExamples of clearFortranOutputStack from FortranOutputStackPackage
--R
--E 340

--S 341 of 3320
)d op clearTable!
--R 
--R
--RThere is one unexposed function called clearTable! :
--R   [1]  -> Void from TabulatedComputationPackage(D2,D3)
--R             if D2 has SETCAT and D3 has SETCAT
--R
--RExamples of clearTable! from TabulatedComputationPackage
--R
--E 341

--S 342 of 3320
)d op clearTheFTable
--R 
--R
--RThere is one exposed function called clearTheFTable :
--R   [1]  -> Void from IntegrationFunctionsTable
--R
--RExamples of clearTheFTable from IntegrationFunctionsTable
--R
--E 342

--S 343 of 3320
)d op clearTheIFTable
--R 
--R
--RThere is one exposed function called clearTheIFTable :
--R   [1]  -> Void from ODEIntensityFunctionsTable
--R
--RExamples of clearTheIFTable from ODEIntensityFunctionsTable
--R
--E 343

--S 344 of 3320
)d op clearTheSymbolTable
--R 
--R
--RThere are 2 exposed functions called clearTheSymbolTable :
--R   [1] Symbol -> Void from TheSymbolTable
--R   [2]  -> Void from TheSymbolTable
--R
--RExamples of clearTheSymbolTable from TheSymbolTable
--R
--E 344

--S 345 of 3320
)d op clikeUniv
--R 
--R
--RThere is one unexposed function called clikeUniv :
--R   [1] Symbol -> (Polynomial(D3) -> SparseUnivariatePolynomial(
--R            Polynomial(D3)))
--R             from WeierstrassPreparation(D3) if D3 has FIELD
--R
--RExamples of clikeUniv from WeierstrassPreparation
--R
--E 345

--S 346 of 3320
)d op clip
--R 
--R
--RThere are 2 exposed functions called clip :
--R   [1] List(Segment(Float)) -> DrawOption from DrawOption
--R   [2] Boolean -> DrawOption from DrawOption
--R
--RThere are 4 unexposed functions called clip :
--R   [1] Plot -> Record(brans: List(List(Point(DoubleFloat))),xValues: 
--R            Segment(DoubleFloat),yValues: Segment(DoubleFloat))
--R             from TwoDimensionalPlotClipping
--R   [2] (Plot,Fraction(Integer),Fraction(Integer)) -> Record(brans: List
--R            (List(Point(DoubleFloat))),xValues: Segment(DoubleFloat),yValues
--R            : Segment(DoubleFloat))
--R             from TwoDimensionalPlotClipping
--R   [3] List(Point(DoubleFloat)) -> Record(brans: List(List(Point(
--R            DoubleFloat))),xValues: Segment(DoubleFloat),yValues: Segment(
--R            DoubleFloat))
--R             from TwoDimensionalPlotClipping
--R   [4] List(List(Point(DoubleFloat))) -> Record(brans: List(List(Point(
--R            DoubleFloat))),xValues: Segment(DoubleFloat),yValues: Segment(
--R            DoubleFloat))
--R             from TwoDimensionalPlotClipping
--R
--RExamples of clip from TwoDimensionalPlotClipping
--R
--R
--RExamples of clip from DrawOption
--R
--E 346

--S 347 of 3320
)d op clipBoolean
--R 
--R
--RThere is one unexposed function called clipBoolean :
--R   [1] (List(DrawOption),Boolean) -> Boolean from DrawOptionFunctions0
--R            
--R
--RExamples of clipBoolean from DrawOptionFunctions0
--R
--E 347

--S 348 of 3320
)d op clipParametric
--R 
--R
--RThere are 2 unexposed functions called clipParametric :
--R   [1] Plot -> Record(brans: List(List(Point(DoubleFloat))),xValues: 
--R            Segment(DoubleFloat),yValues: Segment(DoubleFloat))
--R             from TwoDimensionalPlotClipping
--R   [2] (Plot,Fraction(Integer),Fraction(Integer)) -> Record(brans: List
--R            (List(Point(DoubleFloat))),xValues: Segment(DoubleFloat),yValues
--R            : Segment(DoubleFloat))
--R             from TwoDimensionalPlotClipping
--R
--RExamples of clipParametric from TwoDimensionalPlotClipping
--R
--E 348

--S 349 of 3320
)d op clipPointsDefault
--R 
--R
--RThere are 2 exposed functions called clipPointsDefault :
--R   [1]  -> Boolean from GraphicsDefaults
--R   [2] Boolean -> Boolean from GraphicsDefaults
--R
--RExamples of clipPointsDefault from GraphicsDefaults
--R
--E 349

--S 350 of 3320
)d op clipSurface
--R 
--R
--RThere is one exposed function called clipSurface :
--R   [1] (ThreeDimensionalViewport,String) -> Void from 
--R            ThreeDimensionalViewport
--R
--RExamples of clipSurface from ThreeDimensionalViewport
--R
--E 350

--S 351 of 3320
)d op clipWithRanges
--R 
--R
--RThere is one unexposed function called clipWithRanges :
--R   [1] (List(List(Point(DoubleFloat))),DoubleFloat,DoubleFloat,
--R            DoubleFloat,DoubleFloat) -> Record(brans: List(List(Point(
--R            DoubleFloat))),xValues: Segment(DoubleFloat),yValues: Segment(
--R            DoubleFloat))
--R             from TwoDimensionalPlotClipping
--R
--RExamples of clipWithRanges from TwoDimensionalPlotClipping
--R
--E 351

--S 352 of 3320
)d op cLog
--R 
--R
--RThere is one unexposed function called cLog :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cLog from InnerSparseUnivariatePowerSeries
--R
--E 352

--S 353 of 3320
)d op close
--R 
--R
--RThere is one exposed function called close :
--R   [1] ThreeDimensionalViewport -> Void from ThreeDimensionalViewport
--R         
--R
--RThere are 2 unexposed functions called close :
--R   [1] (SubSpaceComponentProperty,Boolean) -> Boolean
--R             from SubSpaceComponentProperty
--R   [2] TwoDimensionalViewport -> Void from TwoDimensionalViewport
--R
--RExamples of close from SubSpaceComponentProperty
--R
--R
--RExamples of close from TwoDimensionalViewport
--R
--R
--RExamples of close from ThreeDimensionalViewport
--R
--E 353

--S 354 of 3320
)d op close!
--R 
--R
--RThere are 2 exposed functions called close! :
--R   [1] D -> D from D if D has FILECAT(D1,D2) and D1 has SETCAT and D2
--R             has SETCAT
--R   [2] Library -> Library from Library
--R
--RExamples of close! from FileCategory
--R
--R
--RExamples of close! from Library
--R
--E 354

--S 355 of 3320
)d op closeComponent
--R 
--R
--RThere is one unexposed function called closeComponent :
--R   [1] (SubSpace(D3,D4),List(NonNegativeInteger),Boolean) -> SubSpace(
--R            D3,D4)
--R             from SubSpace(D3,D4) if D3: PI and D4 has RING
--R
--RExamples of closeComponent from SubSpace
--R
--E 355

--S 356 of 3320
)d op closed?
--R 
--R
--RThere are 2 unexposed functions called closed? :
--R   [1] SubSpaceComponentProperty -> Boolean from 
--R            SubSpaceComponentProperty
--R   [2] TubePlot(D2) -> Boolean from TubePlot(D2) if D2 has PSCURVE
--R
--RExamples of closed? from SubSpaceComponentProperty
--R
--R
--RExamples of closed? from TubePlot
--R
--E 356

--S 357 of 3320
)d op closedCurve
--R 
--R
--RThere are 4 exposed functions called closedCurve :
--R   [1] D -> List(Point(D2)) from D if D has SPACEC(D2) and D2 has RING
--R            
--R   [2] List(Point(D2)) -> D from D if D2 has RING and D has SPACEC(D2)
--R            
--R   [3] (D,List(List(D2))) -> D from D if D has SPACEC(D2) and D2 has 
--R            RING
--R   [4] (D,List(Point(D2))) -> D from D if D has SPACEC(D2) and D2 has 
--R            RING
--R
--RExamples of closedCurve from ThreeSpaceCategory
--R
--E 357

--S 358 of 3320
)d op closedCurve?
--R 
--R
--RThere is one exposed function called closedCurve? :
--R   [1] D -> Boolean from D if D has SPACEC(D2) and D2 has RING
--R
--RExamples of closedCurve? from ThreeSpaceCategory
--R
--E 358

--S 359 of 3320
)d op cn
--R 
--R
--RThere is one unexposed function called cn :
--R   [1] (D1,D2) -> D1 from EllipticFunctionsUnivariateTaylorSeries(D2,D1
--R            )
--R             if D2 has FIELD and D1 has UTSCAT(D2)
--R
--RExamples of cn from EllipticFunctionsUnivariateTaylorSeries
--R
--E 359

--S 360 of 3320
)d op code
--R 
--R
--RThere is one exposed function called code :
--R   [1] FortranCode -> Union(nullBranch: null,assignmentBranch: Record(
--R            var: Symbol,arrayIndex: List(Polynomial(Integer)),rand: Record(
--R            ints2Floats?: Boolean,expr: OutputForm)),arrayAssignmentBranch: 
--R            Record(var: Symbol,rand: OutputForm,ints2Floats?: Boolean),
--R            conditionalBranch: Record(switch: Switch,thenClause: FortranCode,
--R            elseClause: FortranCode),returnBranch: Record(empty?: Boolean,
--R            value: Record(ints2Floats?: Boolean,expr: OutputForm)),
--R            blockBranch: List(FortranCode),commentBranch: List(String),
--R            callBranch: String,forBranch: Record(range: SegmentBinding(
--R            Polynomial(Integer)),span: Polynomial(Integer),body: FortranCode)
--R            ,labelBranch: SingleInteger,loopBranch: Record(switch: Switch,
--R            body: FortranCode),commonBranch: Record(name: Symbol,contents: 
--R            List(Symbol)),printBranch: List(OutputForm))
--R             from FortranCode
--R
--RExamples of code from FortranCode
--R
--E 360

--S 361 of 3320
)d op coef
--R 
--R
--RThere are 3 exposed functions called coef :
--R   [1] (XRecursivePolynomial(D3,D1),D) -> D1 from D
--R             if D has FLALG(D3,D1) and D3 has ORDSET and D1 has COMRING
--R            
--R   [2] (D,D) -> D1 from D if D has XFALG(D2,D1) and D2 has ORDSET and 
--R            D1 has RING
--R   [3] (D,OrderedFreeMonoid(D3)) -> D1 from D
--R             if D has XFALG(D3,D1) and D3 has ORDSET and D1 has RING
--R         
--R
--RThere is one unexposed function called coef :
--R   [1] (XPolynomialRing(D1,D2),D2) -> D1 from XPolynomialRing(D1,D2)
--R             if D1 has RING and D2 has ORDMON
--R
--RExamples of coef from FreeLieAlgebra
--R
--R
--RExamples of coef from XFreeAlgebra
--R
--R
--RExamples of coef from XPolynomialRing
--R
--E 361

--S 362 of 3320
)d op coefChoose
--R 
--R
--RThere is one unexposed function called coefChoose :
--R   [1] (Integer,Factored(D1)) -> D1 from MultivariateSquareFree(D4,D5,
--R            D6,D1)
--R             if D1 has POLYCAT(D6,D4,D5) and D4 has OAMONS and D5 has 
--R            ORDSET and D6 has EUCDOM
--R
--RExamples of coefChoose from MultivariateSquareFree
--R
--E 362

--S 363 of 3320
)d op coefficient
--R 
--R
--RThere are 12 exposed functions called coefficient :
--R   [1] (D,D2) -> D1 from D if D has AMR(D1,D2) and D2 has OAMON and D1
--R             has RING
--R   [2] (CliffordAlgebra(D3,D1,D4),List(PositiveInteger)) -> D1
--R             from CliffordAlgebra(D3,D1,D4)
--R             if D1 has FIELD and D3: PI and D4: QFORM(D3,D1)
--R   [3] (D2,D) -> D1 from D if D has FAMONC(D2,D1) and D2 has SETCAT and
--R            D1 has CABMON
--R   [4] (D,D2) -> D1 from D if D has FMCAT(D1,D2) and D2 has SETCAT and 
--R            D1 has RING
--R   [5] (D,NonNegativeInteger) -> D1 from D if D has MLO(D1) and D1 has 
--R            RING
--R   [6] (D,List(D4),List(NonNegativeInteger)) -> D from D
--R             if D has MTSCAT(D3,D4) and D3 has RING and D4 has ORDSET
--R         
--R   [7] (D,D1,NonNegativeInteger) -> D from D
--R             if D has MTSCAT(D3,D1) and D3 has RING and D1 has ORDSET
--R         
--R   [8] (D,NonNegativeInteger) -> D1 from D if D has OREPCAT(D1) and D1
--R             has RING
--R   [9] (D,List(D5),List(NonNegativeInteger)) -> D from D
--R             if D has POLYCAT(D3,D4,D5) and D3 has RING and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [10] (D,D1,NonNegativeInteger) -> D from D
--R             if D has POLYCAT(D3,D4,D1) and D3 has RING and D4 has 
--R            OAMONS and D1 has ORDSET
--R   [11] (StochasticDifferential(D3),BasicStochasticDifferential) -> 
--R            Expression(D3)
--R             from StochasticDifferential(D3)
--R             if D3 has Join(OrderedSet,IntegralDomain)
--R   [12] (TaylorSeries(D3),NonNegativeInteger) -> Polynomial(D3)
--R             from TaylorSeries(D3) if D3 has RING
--R
--RThere are 5 unexposed functions called coefficient :
--R   [1] (AntiSymm(D1,D2),AntiSymm(D1,D2)) -> D1 from AntiSymm(D1,D2)
--R             if D1 has RING and D2: LIST(SYMBOL)
--R   [2] (DeRhamComplex(D2,D3),DeRhamComplex(D2,D3)) -> Expression(D2)
--R             from DeRhamComplex(D2,D3)
--R             if D2 has Join(Ring,OrderedSet) and D3: LIST(SYMBOL)
--R   [3] (LaurentPolynomial(D1,D3),Integer) -> D1 from LaurentPolynomial(
--R            D1,D3)
--R             if D1 has INTDOM and D3 has UPOLYC(D1)
--R   [4] (MonoidRing(D1,D2),D2) -> D1 from MonoidRing(D1,D2)
--R             if D1 has RING and D2 has MONOID
--R   [5] (SparseMultivariateTaylorSeries(D3,D4,D1),NonNegativeInteger)
--R             -> D1
--R             from SparseMultivariateTaylorSeries(D3,D4,D1)
--R             if D1 has POLYCAT(D3,INDE(D4),D4) and D3 has RING and D4
--R             has ORDSET
--R
--RExamples of coefficient from AbelianMonoidRing
--R
--R
--RExamples of coefficient from AntiSymm
--R
--R
--RExamples of coefficient from CliffordAlgebra
--R
--R
--RExamples of coefficient from DeRhamComplex
--R
--Rder := DeRhamComplex(Integer,[x,y,z]) 
--RR := Expression(Integer) 
--R[dx,dy,dz] := [generator(i)$der for i in 1..3] 
--Rf : R := x**2*y*z-5*x**3*y**2*z**5 
--Rg : R := z**2*y*cos(z)-7*sin(x**3*y**2)*z**2 
--Rh : R :=x*y*z-2*x**3*y*z**2 
--Ralpha : der := f*dx + g*dy + h*dz 
--Rbeta : der := cos(tan(x*y*z)+x*y*z)*dx + x*dy 
--Rgamma := alpha * beta 
--Rcoefficient(gamma, dx*dy)
--R
--R
--RExamples of coefficient from FreeAbelianMonoidCategory
--R
--R
--RExamples of coefficient from FreeModuleCat
--R
--R
--RExamples of coefficient from LaurentPolynomial
--R
--R
--RExamples of coefficient from MonogenicLinearOperator
--R
--R
--RExamples of coefficient from MonoidRing
--R
--R
--RExamples of coefficient from MultivariateTaylorSeriesCategory
--R
--R
--RExamples of coefficient from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of coefficient from PolynomialCategory
--R
--R
--RExamples of coefficient from StochasticDifferential
--R
--R
--RExamples of coefficient from SparseMultivariateTaylorSeries
--R
--Rxts:=x::TaylorSeries Fraction Integer 
--Rt1:=sin(xts) 
--Rcoefficient(t1,3)
--R
--R
--RExamples of coefficient from TaylorSeries
--R
--E 363

--S 364 of 3320
)d op coefficients
--R 
--R
--RThere are 4 exposed functions called coefficients :
--R   [1] D -> List(D2) from D if D has FAMR(D2,D3) and D2 has RING and D3
--R             has OAMON
--R   [2] D -> List(D2) from D if D has FMCAT(D2,D3) and D2 has RING and 
--R            D3 has SETCAT
--R   [3] D -> List(D2) from D if D has OREPCAT(D2) and D2 has RING
--R   [4] D -> Stream(D2) from D if D has UTSCAT(D2) and D2 has RING
--R
--RThere are 3 unexposed functions called coefficients :
--R   [1] InnerTaylorSeries(D2) -> Stream(D2) from InnerTaylorSeries(D2)
--R             if D2 has RING
--R   [2] MonoidRing(D2,D3) -> List(D2) from MonoidRing(D2,D3)
--R             if D2 has RING and D3 has MONOID
--R   [3] SparseMultivariateTaylorSeries(D2,D3,D4) -> Stream(D4)
--R             from SparseMultivariateTaylorSeries(D2,D3,D4)
--R             if D2 has RING and D3 has ORDSET and D4 has POLYCAT(D2,
--R            INDE(D3),D3)
--R
--RExamples of coefficients from FiniteAbelianMonoidRing
--R
--R
--RExamples of coefficients from FreeModuleCat
--R
--R
--RExamples of coefficients from InnerTaylorSeries
--R
--R
--RExamples of coefficients from MonoidRing
--R
--R
--RExamples of coefficients from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of coefficients from SparseMultivariateTaylorSeries
--R
--R
--RExamples of coefficients from UnivariateTaylorSeriesCategory
--R
--E 364

--S 365 of 3320
)d op coefficientSet
--R 
--R
--RThere is one exposed function called coefficientSet :
--R   [1] SparseUnivariatePolynomial(Polynomial(D3)) -> List(Polynomial(D3
--R            ))
--R             from CylindricalAlgebraicDecompositionPackage(D3) if D3
--R             has RCFIELD
--R
--RExamples of coefficientSet from CylindricalAlgebraicDecompositionPackage
--R
--E 365

--S 366 of 3320
)d op coefOfFirstNonZeroTerm
--R 
--R
--RThere is one exposed function called coefOfFirstNonZeroTerm :
--R   [1] D -> D1 from D if D has LOCPOWC(D1) and D1 has FIELD
--R
--RExamples of coefOfFirstNonZeroTerm from LocalPowerSeriesCategory
--R
--E 366

--S 367 of 3320
--R----------------------------------)d op coerce (System Error)
--E 367

--S 368 of 3320
)d op coerceImages
--R 
--R
--RThere is one exposed function called coerceImages :
--R   [1] List(D2) -> Permutation(D2) from Permutation(D2) if D2 has 
--R            SETCAT
--R
--RExamples of coerceImages from Permutation
--R
--E 368

--S 369 of 3320
)d op coerceL
--R 
--R
--RThere are 2 exposed functions called coerceL :
--R   [1] OutputForm -> String from HTMLFormat
--R   [2] OutputForm -> String from MathMLFormat
--R
--RExamples of coerceL from HTMLFormat
--R
--RcoerceL(sqrt(3+x)::OutputForm)$HTMLFORM
--R
--R
--RExamples of coerceL from MathMLFormat
--R
--E 369

--S 370 of 3320
)d op coerceListOfPairs
--R 
--R
--RThere is one exposed function called coerceListOfPairs :
--R   [1] List(List(D2)) -> Permutation(D2) from Permutation(D2) if D2
--R             has SETCAT
--R
--RExamples of coerceListOfPairs from Permutation
--R
--E 370

--S 371 of 3320
)d op coerceP
--R 
--R
--RThere is one unexposed function called coerceP :
--R   [1] Vector(Matrix(D3)) -> Vector(Matrix(Polynomial(D3)))
--R             from CoerceVectorMatrixPackage(D3) if D3 has COMRING
--R
--RExamples of coerceP from CoerceVectorMatrixPackage
--R
--E 371

--S 372 of 3320 done
)d op coercePreimagesImages
--R 
--R
--RThere is one exposed function called coercePreimagesImages :
--R   [1] List(List(D2)) -> Permutation(D2) from Permutation(D2) if D2
--R             has SETCAT
--R
--RExamples of coercePreimagesImages from Permutation
--R
--Rp := coercePreimagesImages([[1,2,3],[1,2,3]]) 
--Rq := coercePreimagesImages([[0,1,2,3],[3,0,2,1]])$PERM ZMOD 4
--R
--E 372

--S 373 of 3320
)d op coerceS 
--R 
--R
--RThere are 2 exposed functions called coerceS :
--R   [1] OutputForm -> String from HTMLFormat
--R   [2] OutputForm -> String from MathMLFormat
--R
--RExamples of coerceS from HTMLFormat
--R
--RcoerceS(sqrt(3+x)::OutputForm)$HTMLFORM
--R
--R
--RExamples of coerceS from MathMLFormat
--R
--E 373

--S 374 of 3320
)d op coHeight
--R 
--R
--RThere is one exposed function called coHeight :
--R   [1] D -> NonNegativeInteger from D
--R             if D has TSETCAT(D2,D3,D4,D5) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4) 
--R            and D4 has FINITE
--R
--RExamples of coHeight from TriangularSetCategory
--R
--E 374

--S 375 of 3320
)d op coleman
--R 
--R
--RThere is one exposed function called coleman :
--R   [1] (List(Integer),List(Integer),List(Integer)) -> Matrix(Integer)
--R             from SymmetricGroupCombinatoricFunctions
--R
--RExamples of coleman from SymmetricGroupCombinatoricFunctions
--R
--E 375

--S 376 of 3320
)d op collect
--R 
--R
--RThere are 2 exposed functions called collect :
--R   [1] D -> D from D if D has DIVCAT(D1) and D1 has SETCAT
--R   [2] (D,D1) -> D from D
--R             if D has PSETCAT(D2,D3,D1,D4) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET and D4 has RPOLCAT(D2,D3,D1)
--R
--RExamples of collect from DivisorCategory
--R
--R
--RExamples of collect from PolynomialSetCategory
--R
--E 376

--S 377 of 3320
)d op collectQuasiMonic
--R 
--R
--RThere is one exposed function called collectQuasiMonic :
--R   [1] D -> D from D
--R             if D has TSETCAT(D1,D2,D3,D4) and D1 has INTDOM and D2
--R             has OAMONS and D3 has ORDSET and D4 has RPOLCAT(D1,D2,D3)
--R            
--R
--RExamples of collectQuasiMonic from TriangularSetCategory
--R
--E 377

--S 378 of 3320
)d op collectUnder
--R 
--R
--RThere is one exposed function called collectUnder :
--R   [1] (D,D1) -> D from D
--R             if D has PSETCAT(D2,D3,D1,D4) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET and D4 has RPOLCAT(D2,D3,D1)
--R
--RExamples of collectUnder from PolynomialSetCategory
--R
--E 378

--S 379 of 3320
)d op collectUpper
--R 
--R
--RThere is one exposed function called collectUpper :
--R   [1] (D,D1) -> D from D
--R             if D has PSETCAT(D2,D3,D1,D4) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET and D4 has RPOLCAT(D2,D3,D1)
--R
--RExamples of collectUpper from PolynomialSetCategory
--R
--E 379

--S 380 of 3320
)d op color
--R 
--R
--RThere is one exposed function called color :
--R   [1] Integer -> Color from Color
--R
--RThere is one unexposed function called color :
--R   [1] Point(D1) -> D1 from PointPackage(D1) if D1 has RING
--R
--RExamples of color from Color
--R
--R
--RExamples of color from PointPackage
--R
--E 380

--S 381 of 3320
)d op colorDef
--R 
--R
--RThere is one exposed function called colorDef :
--R   [1] (ThreeDimensionalViewport,Color,Color) -> Void
--R             from ThreeDimensionalViewport
--R
--RExamples of colorDef from ThreeDimensionalViewport
--R
--E 381

--S 382 of 3320
)d op colorFunction
--R 
--R
--RThere are 3 exposed functions called colorFunction :
--R   [1] ((DoubleFloat,DoubleFloat,DoubleFloat) -> DoubleFloat) -> 
--R            DrawOption
--R             from DrawOption
--R   [2] ((DoubleFloat,DoubleFloat) -> DoubleFloat) -> DrawOption from 
--R            DrawOption
--R   [3] (DoubleFloat -> DoubleFloat) -> DrawOption from DrawOption
--R
--RExamples of colorFunction from DrawOption
--R
--E 382

--S 383 of 3320
)d op column
--R 
--R
--RThere are 2 exposed functions called column :
--R   [1] (D,Integer) -> D1 from D
--R             if D has ARR2CAT(D3,D4,D1) and D3 has TYPE and D4 has 
--R            FLAGG(D3) and D1 has FLAGG(D3)
--R   [2] (D,Integer) -> D1 from D
--R             if D has RMATCAT(D3,D4,D5,D6,D1) and D5 has RING and D6
--R             has DIRPCAT(D4,D5) and D1 has DIRPCAT(D3,D5)
--R
--RExamples of column from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rcolumn(arr,1)
--R
--R
--RExamples of column from RectangularMatrixCategory
--R
--E 383

--S 384 of 3320 done
)d op columns
--R 
--R
--RThere are 2 exposed functions called columns :
--R   [1] (D1,List(PositiveInteger)) -> D1 from MatrixManipulation(D3,D4,
--R            D5,D1)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D1 has MATCAT(D3,D4,D5)
--R   [2] (D1,Segment(PositiveInteger)) -> D1 from MatrixManipulation(D3,
--R            D4,D5,D1)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D1 has MATCAT(D3,D4,D5)
--R
--RExamples of columns from MatrixManipulation
--R
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--Rcolumns(M, 1..2)
--R
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--Rcolumns(M, [1,2]) 
--Rcolumns(M, [3,2])
--R
--E 384

--S 385 of 3320 done
)d op columnSpace
--R 
--R
--RThere is one exposed function called columnSpace :
--R   [1] D -> List(D4) from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2) and D2 has EUCDOM
--R
--RExamples of columnSpace from MatrixCategory
--R
--RcolumnSpace matrix [[1,2,3],[4,5,6],[7,8,9],[1,1,1]]
--R
--E 385

--S 386 of 3320
)d op combineFeatureCompatibility
--R 
--R
--RThere are 2 exposed functions called combineFeatureCompatibility :
--R   [1] (Float,Float) -> Float from d02AgentsPackage
--R   [2] (Float,List(Float)) -> Float from d02AgentsPackage
--R
--RExamples of combineFeatureCompatibility from d02AgentsPackage
--R
--E 386

--S 387 of 3320
)d op commaSeparate
--R 
--R
--RThere is one exposed function called commaSeparate :
--R   [1] List(String) -> String from d01AgentsPackage
--R
--RThere is one unexposed function called commaSeparate :
--R   [1] List(OutputForm) -> OutputForm from OutputForm
--R
--RExamples of commaSeparate from d01AgentsPackage
--R
--R
--RExamples of commaSeparate from OutputForm
--R
--E 387

--S 388 of 3320
)d op comment
--R 
--R
--RThere are 2 exposed functions called comment :
--R   [1] List(String) -> FortranCode from FortranCode
--R   [2] String -> FortranCode from FortranCode
--R
--RExamples of comment from FortranCode
--R
--E 388

--S 389 of 3320
)d op common
--R 
--R
--RThere is one exposed function called common :
--R   [1] (Symbol,List(Symbol)) -> FortranCode from FortranCode
--R
--RExamples of common from FortranCode
--R
--E 389

--S 390 of 3320
)d op commonDenominator
--R 
--R
--RThere are 3 exposed functions called commonDenominator :
--R   [1] D2 -> D1 from CommonDenominator(D1,D3,D2)
--R             if D3 has QFCAT(D1) and D1 has INTDOM and D2 has FLAGG(D3)
--R            
--R   [2] Matrix(D3) -> D1 from MatrixCommonDenominator(D1,D3)
--R             if D3 has QFCAT(D1) and D1 has INTDOM
--R   [3] D2 -> D1 from UnivariatePolynomialCommonDenominator(D1,D3,D2)
--R             if D3 has QFCAT(D1) and D1 has INTDOM and D2 has UPOLYC(D3
--R            )
--R
--RThere is one unexposed function called commonDenominator :
--R   [1] D2 -> D1 from InnerCommonDenominator(D1,D3,D4,D2)
--R             if D3 has QFCAT(D1) and D1 has INTDOM and D4 has FLAGG(D1)
--R            and D2 has FLAGG(D3)
--R
--RExamples of commonDenominator from CommonDenominator
--R
--R
--RExamples of commonDenominator from InnerCommonDenominator
--R
--R
--RExamples of commonDenominator from MatrixCommonDenominator
--R
--R
--RExamples of commonDenominator from UnivariatePolynomialCommonDenominator
--R
--E 390

--S 391 of 3320
)d op commutative?
--R 
--R
--RThere is one exposed function called commutative? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called commutative? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of commutative? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of commutative? from FiniteRankNonAssociativeAlgebra
--R
--E 391

--S 392 of 3320
)d op commutativeEquality
--R 
--R
--RThere is one unexposed function called commutativeEquality :
--R   [1] (ListMonoidOps(D2,D3,D4),ListMonoidOps(D2,D3,D4)) -> Boolean
--R             from ListMonoidOps(D2,D3,D4)
--R             if D2 has SETCAT and D3 has ABELMON and D4: D3
--R
--RExamples of commutativeEquality from ListMonoidOps
--R
--E 392

--S 393 of 3320
)d op commutator
--R 
--R
--RThere are 2 exposed functions called commutator :
--R   [1] (D,D) -> D from D if D has GROUP
--R   [2] (D,D) -> D from D if D has NARNG
--R
--RExamples of commutator from Group
--R
--R
--RExamples of commutator from NonAssociativeRng
--R
--E 393

--S 394 of 3320
)d op comp
--R 
--R
--RThere is one unexposed function called comp :
--R   [1] ((D5 -> D1),(D4 -> D5),D4) -> D1
--R             from MappingPackageInternalHacks3(D4,D5,D1)
--R             if D4 has SETCAT and D5 has SETCAT and D1 has SETCAT
--R
--RExamples of comp from MappingPackageInternalHacks3
--R
--E 394

--S 395 of 3320 done
)d op compactFraction
--R 
--R
--RThere is one exposed function called compactFraction :
--R   [1] PartialFraction(D1) -> PartialFraction(D1) from PartialFraction(
--R            D1)
--R             if D1 has EUCDOM
--R
--RExamples of compactFraction from PartialFraction
--R
--Ra:=partialFraction(1,factorial 10) 
--Rb:=padicFraction(a) 
--RcompactFraction(b)
--R
--E 395

--S 396 of 3320
)d op companionBlocks
--R 
--R
--RThere is one unexposed function called companionBlocks :
--R   [1] (Matrix(D4),Vector(D4)) -> List(Record(C: Matrix(D4),g: Vector(
--R            D4)))
--R             from PseudoLinearNormalForm(D4) if D4 has FIELD
--R
--RExamples of companionBlocks from PseudoLinearNormalForm
--R
--E 396

--S 397 of 3320
)d op comparison
--R 
--R
--RThere is one exposed function called comparison :
--R   [1] (BasicOperator,((BasicOperator,BasicOperator) -> Boolean)) -> 
--R            BasicOperator
--R             from BasicOperator
--R
--RExamples of comparison from BasicOperator
--R
--E 397

--S 398 of 3320
)d op compBound
--R 
--R
--RThere is one unexposed function called compBound :
--R   [1] (D2,List(D2)) -> NonNegativeInteger from GenExEuclid(D4,D2)
--R             if D2 has UPOLYC(D4) and D4 has EUCDOM
--R
--RExamples of compBound from GenExEuclid
--R
--E 398

--S 399 of 3320
)d op compdegd
--R 
--R
--RThere is one unexposed function called compdegd :
--R   [1] List(Record(factor: SparseUnivariatePolynomial(D5),exponent: 
--R            Integer)) -> Integer
--R             from MultivariateSquareFree(D3,D4,D5,D6)
--R             if D5 has EUCDOM and D3 has OAMONS and D4 has ORDSET and 
--R            D6 has POLYCAT(D5,D3,D4)
--R
--RExamples of compdegd from MultivariateSquareFree
--R
--E 399

--S 400 of 3320
)d op compile
--R 
--R
--RThere is one unexposed function called compile :
--R   [1] (Symbol,List(InputForm)) -> Symbol from InputForm
--R
--RExamples of compile from InputForm
--R
--E 400

--S 401 of 3320 done
)d op compiledFunction
--R 
--R
--RThere are 2 unexposed functions called compiledFunction :
--R   [1] (D2,Symbol,Symbol) -> ((D4,D5) -> D6)
--R             from MakeBinaryCompiledFunction(D2,D4,D5,D6)
--R             if D2 has KONVERT(INFORM) and D4 has TYPE and D5 has TYPE 
--R            and D6 has TYPE
--R   [2] (D2,Symbol) -> (D4 -> D5) from MakeUnaryCompiledFunction(D2,D4,
--R            D5)
--R             if D2 has KONVERT(INFORM) and D4 has TYPE and D5 has TYPE
--R            
--R
--RExamples of compiledFunction from MakeBinaryCompiledFunction
--R
--RMBCF:=MakeBinaryCompiledFunction(POLY(FRAC(INT)),FLOAT,FLOAT,FLOAT) 
--Rf:=(x+3)*(y+4) 
--Rg:=compiledFunction(f,x,y)$MBCF 
--Rg(2.0,3.0)
--R
--R
--RExamples of compiledFunction from MakeUnaryCompiledFunction
--R
--RMUCF:=MakeUnaryCompiledFunction(POLY(FRAC(INT)),FLOAT,FLOAT) 
--Rf:=(x+3)^2 
--Rg:=compiledFunction(f,x)$MUCF 
--Rg(2.0)
--R
--E 401

--S 402 of 3320
)d op complement
--R 
--R
--RThere is one exposed function called complement :
--R   [1] D -> D from D if D has FSAGG(D1) and D1 has SETCAT and D1 has 
--R            FINITE
--R
--RExamples of complement from FiniteSetAggregate
--R
--E 402

--S 403 of 3320
)d op complementaryBasis
--R 
--R
--RThere is one exposed function called complementaryBasis :
--R   [1] Vector(D) -> Vector(D) from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of complementaryBasis from FunctionFieldCategory
--R
--E 403

--S 404 of 3320
)d op complete
--R 
--R
--RThere are 5 exposed functions called complete :
--R   [1] ContinuedFraction(D1) -> ContinuedFraction(D1) from 
--R            ContinuedFraction(D1)
--R             if D1 has EUCDOM
--R   [2] Integer -> SymmetricPolynomial(Fraction(Integer)) from 
--R            CycleIndicators
--R   [3] D -> D from D if D has LZSTAGG(D1) and D1 has TYPE
--R   [4] D -> D from D if D has PADICCT(D1)
--R   [5] D -> D from D
--R             if D has PSCAT(D1,D2,D3) and D1 has RING and D2 has OAMON 
--R            and D3 has ORDSET
--R
--RExamples of complete from ContinuedFraction
--R
--R
--RExamples of complete from CycleIndicators
--R
--R
--RExamples of complete from LazyStreamAggregate
--R
--Rm:=[i for i in 1..] 
--Rn:=filterUntil(i+->i>100,m) 
--RnumberOfComputedEntries n 
--Rcomplete n 
--RnumberOfComputedEntries n
--R
--R
--RExamples of complete from PAdicIntegerCategory
--R
--R
--RExamples of complete from PowerSeriesCategory
--R
--E 404

--S 405 of 3320
)d op completeEchelonBasis
--R 
--R
--RThere is one exposed function called completeEchelonBasis :
--R   [1] Vector(Vector(D3)) -> Matrix(D3) from RepresentationPackage2(D3)
--R             if D3 has RING
--R
--RExamples of completeEchelonBasis from RepresentationPackage2
--R
--E 405

--S 406 of 3320
)d op completeEval
--R 
--R
--RThere is one unexposed function called completeEval :
--R   [1] (SparseUnivariatePolynomial(D8),List(D6),List(D7)) -> 
--R            SparseUnivariatePolynomial(D7)
--R             from FactoringUtilities(D5,D6,D7,D8)
--R             if D6 has ORDSET and D7 has RING and D8 has POLYCAT(D7,D5,
--R            D6) and D5 has OAMONS
--R
--RExamples of completeEval from FactoringUtilities
--R
--E 406

--S 407 of 3320
)d op completeHensel
--R 
--R
--RThere is one unexposed function called completeHensel :
--R   [1] (D2,List(D2),D3,PositiveInteger) -> List(D2)
--R             from GeneralHenselPackage(D3,D2) if D2 has UPOLYC(D3) and 
--R            D3 has EUCDOM
--R
--RExamples of completeHensel from GeneralHenselPackage
--R
--E 407

--S 408 of 3320
)d op completeHermite
--R 
--R
--RThere is one exposed function called completeHermite :
--R   [1] D2 -> Record(Hermite: D2,eqMat: D2) from SmithNormalForm(D3,D4,
--R            D5,D2)
--R             if D3 has EUCDOM and D4 has FLAGG(D3) and D5 has FLAGG(D3)
--R            and D2 has MATCAT(D3,D4,D5)
--R
--RExamples of completeHermite from SmithNormalForm
--R
--E 408

--S 409 of 3320
)d op completeSmith
--R 
--R
--RThere is one exposed function called completeSmith :
--R   [1] D2 -> Record(Smith: D2,leftEqMat: D2,rightEqMat: D2)
--R             from SmithNormalForm(D3,D4,D5,D2)
--R             if D3 has EUCDOM and D4 has FLAGG(D3) and D5 has FLAGG(D3)
--R            and D2 has MATCAT(D3,D4,D5)
--R
--RExamples of completeSmith from SmithNormalForm
--R
--E 409

--S 410 of 3320
)d op complex
--R 
--R
--RThere is one exposed function called complex :
--R   [1] (D1,D1) -> D from D if D has COMPCAT(D1) and D1 has COMRING
--R
--RExamples of complex from ComplexCategory
--R
--E 410

--S 411 of 3320
)d op complex?
--R 
--R
--RThere is one exposed function called complex? :
--R   [1] FortranScalarType -> Boolean from FortranScalarType
--R
--RExamples of complex? from FortranScalarType
--R
--E 411

--S 412 of 3320
)d op complexEigenvalues
--R 
--R
--RThere is one exposed function called complexEigenvalues :
--R   [1] (Matrix(Complex(Fraction(Integer))),D3) -> List(Complex(D3))
--R             from NumericComplexEigenPackage(D3) if D3 has Join(Field,
--R            OrderedRing)
--R
--RExamples of complexEigenvalues from NumericComplexEigenPackage
--R
--E 412

--S 413 of 3320
)d op complexEigenvectors
--R 
--R
--RThere is one exposed function called complexEigenvectors :
--R   [1] (Matrix(Complex(Fraction(Integer))),D3) -> List(Record(outval: 
--R            Complex(D3),outmult: Integer,outvect: List(Matrix(Complex(D3)))))
--R             from NumericComplexEigenPackage(D3) if D3 has Join(Field,
--R            OrderedRing)
--R
--RExamples of complexEigenvectors from NumericComplexEigenPackage
--R
--E 413

--S 414 of 3320
)d op complexElementary
--R 
--R
--RThere are 4 exposed functions called complexElementary :
--R   [1] D1 -> D1 from ComplexTrigonometricManipulations(D2,D1)
--R             if D2 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer)) and D1 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(Complex(D2)))
--R            
--R   [2] (D1,Symbol) -> D1 from ComplexTrigonometricManipulations(D3,D1)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer)) and D1 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(Complex(D3)))
--R            
--R   [3] D1 -> D1 from TrigonometricManipulations(D2,D1)
--R             if D2 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D1 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D2))
--R   [4] (D1,Symbol) -> D1 from TrigonometricManipulations(D3,D1)
--R             if D3 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D1 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R
--RExamples of complexElementary from ComplexTrigonometricManipulations
--R
--R
--RExamples of complexElementary from TrigonometricManipulations
--R
--E 414

--S 415 of 3320
)d op complexExpand
--R 
--R
--RThere are 2 exposed functions called complexExpand :
--R   [1] IntegrationResult(D1) -> D1 from IntegrationResultToFunction(D3,
--R            D1)
--R             if D1 has Join(AlgebraicallyClosedFunctionSpace(D3),
--R            TranscendentalFunctionCategory) and D3 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,LinearlyExplicitRingOver(
--R            Integer))
--R   [2] IntegrationResult(Fraction(Polynomial(D3))) -> Expression(D3)
--R             from IntegrationResultRFToFunction(D3)
--R             if D3 has Join(GcdDomain,RetractableTo(Integer),OrderedSet
--R            ,LinearlyExplicitRingOver(Integer))
--R
--RExamples of complexExpand from IntegrationResultToFunction
--R
--R
--RExamples of complexExpand from IntegrationResultRFToFunction
--R
--E 415

--S 416 of 3320
)d op complexForm
--R 
--R
--RThere are 2 exposed functions called complexForm :
--R   [1] D2 -> Complex(Expression(D3))
--R             from ComplexTrigonometricManipulations(D3,D2)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer)) and D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(Complex(D3)))
--R            
--R   [2] D2 -> Complex(D2) from TrigonometricManipulations(D3,D2)
--R             if D3 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R
--RExamples of complexForm from ComplexTrigonometricManipulations
--R
--R
--RExamples of complexForm from TrigonometricManipulations
--R
--E 416

--S 417 of 3320
)d op complexIntegrate
--R 
--R
--RThere are 2 exposed functions called complexIntegrate :
--R   [1] (D1,Symbol) -> D1 from FunctionSpaceComplexIntegration(D3,D1)
--R             if D3 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer)) and D1 has Join(
--R            TranscendentalFunctionCategory,
--R            AlgebraicallyClosedFunctionSpace(D3))
--R   [2] (Fraction(Polynomial(D4)),Symbol) -> Expression(D4)
--R             from IntegrationResultRFToFunction(D4)
--R             if D4 has CHARZ and D4 has Join(GcdDomain,RetractableTo(
--R            Integer),OrderedSet,LinearlyExplicitRingOver(Integer))
--R
--RExamples of complexIntegrate from FunctionSpaceComplexIntegration
--R
--R
--RExamples of complexIntegrate from IntegrationResultRFToFunction
--R
--E 417

--S 418 of 3320
)d op complexLimit
--R 
--R
--RThere are 3 exposed functions called complexLimit :
--R   [1] (D2,Equation(OnePointCompletion(D2))) -> Union(
--R            OnePointCompletion(D2),"failed")
--R             from PowerSeriesLimitPackage(D4,D2)
--R             if D4 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D4))
--R   [2] (Fraction(Polynomial(D4)),Equation(OnePointCompletion(Polynomial
--R            (D4)))) -> OnePointCompletion(Fraction(Polynomial(D4)))
--R             from RationalFunctionLimitPackage(D4) if D4 has GCDDOM
--R   [3] (Fraction(Polynomial(D4)),Equation(Fraction(Polynomial(D4))))
--R             -> OnePointCompletion(Fraction(Polynomial(D4)))
--R             from RationalFunctionLimitPackage(D4) if D4 has GCDDOM
--R
--RExamples of complexLimit from PowerSeriesLimitPackage
--R
--R
--RExamples of complexLimit from RationalFunctionLimitPackage
--R
--E 418

--S 419 of 3320
)d op complexNormalize
--R 
--R
--RThere are 4 exposed functions called complexNormalize :
--R   [1] D1 -> D1 from ComplexTrigonometricManipulations(D2,D1)
--R             if D2 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer)) and D1 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(Complex(D2)))
--R            
--R   [2] (D1,Symbol) -> D1 from ComplexTrigonometricManipulations(D3,D1)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer)) and D1 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(Complex(D3)))
--R            
--R   [3] D1 -> D1 from TrigonometricManipulations(D2,D1)
--R             if D2 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D1 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D2))
--R   [4] (D1,Symbol) -> D1 from TrigonometricManipulations(D3,D1)
--R             if D3 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D1 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R
--RExamples of complexNormalize from ComplexTrigonometricManipulations
--R
--R
--RExamples of complexNormalize from TrigonometricManipulations
--R
--E 419

--S 420 of 3320
)d op complexNumeric
--R 
--R
--RThere are 16 exposed functions called complexNumeric :
--R   [1] D2 -> Complex(Float) from Numeric(D2) if D2 has KONVERT(FLOAT)
--R         
--R   [2] (D2,PositiveInteger) -> Complex(Float) from Numeric(D2)
--R             if D2 has KONVERT(FLOAT)
--R   [3] Complex(D3) -> Complex(Float) from Numeric(D3)
--R             if D3 has COMRING and D3 has KONVERT(FLOAT)
--R   [4] (Complex(D4),PositiveInteger) -> Complex(Float) from Numeric(D4)
--R             if D4 has COMRING and D4 has KONVERT(FLOAT)
--R   [5] Polynomial(Complex(D3)) -> Complex(Float) from Numeric(D3)
--R             if D3 has COMRING and D3 has KONVERT(FLOAT)
--R   [6] (Polynomial(Complex(D4)),PositiveInteger) -> Complex(Float)
--R             from Numeric(D4) if D4 has COMRING and D4 has KONVERT(
--R            FLOAT)
--R   [7] Polynomial(D3) -> Complex(Float) from Numeric(D3)
--R             if D3 has RING and D3 has KONVERT(FLOAT)
--R   [8] (Polynomial(D4),PositiveInteger) -> Complex(Float) from Numeric(
--R            D4)
--R             if D4 has RING and D4 has KONVERT(FLOAT)
--R   [9] Fraction(Polynomial(D3)) -> Complex(Float) from Numeric(D3)
--R             if D3 has INTDOM and D3 has KONVERT(FLOAT)
--R   [10] (Fraction(Polynomial(D4)),PositiveInteger) -> Complex(Float)
--R             from Numeric(D4) if D4 has INTDOM and D4 has KONVERT(FLOAT
--R            )
--R   [11] Fraction(Polynomial(Complex(D3))) -> Complex(Float) from 
--R            Numeric(D3)
--R             if D3 has INTDOM and D3 has KONVERT(FLOAT)
--R   [12] (Fraction(Polynomial(Complex(D4))),PositiveInteger) -> Complex(
--R            Float)
--R             from Numeric(D4) if D4 has INTDOM and D4 has KONVERT(FLOAT
--R            )
--R   [13] Expression(D3) -> Complex(Float) from Numeric(D3)
--R             if D3 has INTDOM and D3 has ORDSET and D3 has KONVERT(
--R            FLOAT)
--R   [14] (Expression(D4),PositiveInteger) -> Complex(Float) from Numeric
--R            (D4)
--R             if D4 has INTDOM and D4 has ORDSET and D4 has KONVERT(
--R            FLOAT)
--R   [15] Expression(Complex(D3)) -> Complex(Float) from Numeric(D3)
--R             if D3 has INTDOM and D3 has ORDSET and D3 has KONVERT(
--R            FLOAT)
--R   [16] (Expression(Complex(D4)),PositiveInteger) -> Complex(Float)
--R             from Numeric(D4)
--R             if D4 has INTDOM and D4 has ORDSET and D4 has KONVERT(
--R            FLOAT)
--R
--RExamples of complexNumeric from Numeric
--R
--E 420

--S 421 of 3320
)d op complexNumericIfCan
--R 
--R
--RThere are 12 exposed functions called complexNumericIfCan :
--R   [1] Polynomial(Complex(D3)) -> Union(Complex(Float),"failed")
--R             from Numeric(D3) if D3 has COMRING and D3 has KONVERT(
--R            FLOAT)
--R   [2] (Polynomial(Complex(D4)),PositiveInteger) -> Union(Complex(Float
--R            ),"failed")
--R             from Numeric(D4) if D4 has COMRING and D4 has KONVERT(
--R            FLOAT)
--R   [3] Polynomial(D3) -> Union(Complex(Float),"failed") from Numeric(D3
--R            )
--R             if D3 has RING and D3 has KONVERT(FLOAT)
--R   [4] (Polynomial(D4),PositiveInteger) -> Union(Complex(Float),
--R            "failed")
--R             from Numeric(D4) if D4 has RING and D4 has KONVERT(FLOAT)
--R            
--R   [5] Fraction(Polynomial(D3)) -> Union(Complex(Float),"failed")
--R             from Numeric(D3) if D3 has INTDOM and D3 has KONVERT(FLOAT
--R            )
--R   [6] (Fraction(Polynomial(D4)),PositiveInteger) -> Union(Complex(
--R            Float),"failed")
--R             from Numeric(D4) if D4 has INTDOM and D4 has KONVERT(FLOAT
--R            )
--R   [7] Fraction(Polynomial(Complex(D3))) -> Union(Complex(Float),
--R            "failed")
--R             from Numeric(D3) if D3 has INTDOM and D3 has KONVERT(FLOAT
--R            )
--R   [8] (Fraction(Polynomial(Complex(D4))),PositiveInteger) -> Union(
--R            Complex(Float),"failed")
--R             from Numeric(D4) if D4 has INTDOM and D4 has KONVERT(FLOAT
--R            )
--R   [9] Expression(D3) -> Union(Complex(Float),"failed") from Numeric(D3
--R            )
--R             if D3 has INTDOM and D3 has ORDSET and D3 has KONVERT(
--R            FLOAT)
--R   [10] (Expression(D4),PositiveInteger) -> Union(Complex(Float),
--R            "failed")
--R             from Numeric(D4)
--R             if D4 has INTDOM and D4 has ORDSET and D4 has KONVERT(
--R            FLOAT)
--R   [11] Expression(Complex(D3)) -> Union(Complex(Float),"failed")
--R             from Numeric(D3)
--R             if D3 has INTDOM and D3 has ORDSET and D3 has KONVERT(
--R            FLOAT)
--R   [12] (Expression(Complex(D4)),PositiveInteger) -> Union(Complex(
--R            Float),"failed")
--R             from Numeric(D4)
--R             if D4 has INTDOM and D4 has ORDSET and D4 has KONVERT(
--R            FLOAT)
--R
--RExamples of complexNumericIfCan from Numeric
--R
--E 421

--S 422 of 3320
)d op complexRoots
--R 
--R
--RThere are 2 exposed functions called complexRoots :
--R   [1] (Fraction(Polynomial(Complex(Integer))),D3) -> List(Complex(D3))
--R             from FloatingComplexPackage(D3) if D3 has Join(Field,
--R            OrderedRing)
--R   [2] (List(Fraction(Polynomial(Complex(Integer)))),List(Symbol),D4)
--R             -> List(List(Complex(D4)))
--R             from FloatingComplexPackage(D4) if D4 has Join(Field,
--R            OrderedRing)
--R
--RExamples of complexRoots from FloatingComplexPackage
--R
--E 422

--S 423 of 3320
)d op complexSolve
--R 
--R
--RThere are 4 exposed functions called complexSolve :
--R   [1] (List(Fraction(Polynomial(Complex(Integer)))),D3) -> List(List(
--R            Equation(Polynomial(Complex(D3)))))
--R             from FloatingComplexPackage(D3) if D3 has Join(Field,
--R            OrderedRing)
--R   [2] (List(Equation(Fraction(Polynomial(Complex(Integer))))),D3) -> 
--R            List(List(Equation(Polynomial(Complex(D3)))))
--R             from FloatingComplexPackage(D3) if D3 has Join(Field,
--R            OrderedRing)
--R   [3] (Fraction(Polynomial(Complex(Integer))),D3) -> List(Equation(
--R            Polynomial(Complex(D3))))
--R             from FloatingComplexPackage(D3) if D3 has Join(Field,
--R            OrderedRing)
--R   [4] (Equation(Fraction(Polynomial(Complex(Integer)))),D3) -> List(
--R            Equation(Polynomial(Complex(D3))))
--R             from FloatingComplexPackage(D3) if D3 has Join(Field,
--R            OrderedRing)
--R
--RExamples of complexSolve from FloatingComplexPackage
--R
--E 423

--S 424 of 3320
)d op complexZeros
--R 
--R
--RThere is one exposed function called complexZeros :
--R   [1] (D2,D3) -> List(Complex(D3)) from ComplexRootPackage(D2,D3)
--R             if D2 has UPOLYC(COMPLEX(INT)) and D3 has Join(Field,
--R            OrderedRing)
--R
--RThere are 2 unexposed functions called complexZeros :
--R   [1] D2 -> List(Complex(D3)) from ComplexRootFindingPackage(D3,D2)
--R             if D3 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D3))
--R   [2] (D2,D3) -> List(Complex(D3)) from ComplexRootFindingPackage(D3,
--R            D2)
--R             if D3 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D3))
--R
--RExamples of complexZeros from ComplexRootPackage
--R
--R
--RExamples of complexZeros from ComplexRootFindingPackage
--R
--E 424

--S 425 of 3320
)d op component
--R 
--R
--RThere are 3 unexposed functions called component :
--R   [1] (GraphImage,Point(DoubleFloat),Palette,Palette,PositiveInteger)
--R             -> Void
--R             from GraphImage
--R   [2] (GraphImage,Point(DoubleFloat)) -> Void from GraphImage
--R   [3] (GraphImage,List(Point(DoubleFloat)),Palette,Palette,
--R            PositiveInteger) -> Void
--R             from GraphImage
--R
--RExamples of component from GraphImage
--R
--E 425

--S 426 of 3320
)d op components
--R 
--R
--RThere is one exposed function called components :
--R   [1] D -> List(D) from D if D2 has RING and D has SPACEC(D2)
--R
--RExamples of components from ThreeSpaceCategory
--R
--E 426

--S 427 of 3320
)d op compose
--R 
--R
--RThere is one exposed function called compose :
--R   [1] (D1,D1) -> D1 from PolynomialComposition(D1,D2)
--R             if D2 has RING and D1 has UPOLYC(D2)
--R
--RThere is one unexposed function called compose :
--R   [1] (Stream(D2),Stream(D2)) -> Stream(D2)
--R             from StreamTaylorSeriesOperations(D2) if D2 has RING
--R
--RExamples of compose from PolynomialComposition
--R
--R
--RExamples of compose from StreamTaylorSeriesOperations
--R
--E 427

--S 428 of 3320
)d op composite
--R 
--R
--RThere are 3 exposed functions called composite :
--R   [1] List(D) -> D from D if D has SPACEC(D2) and D2 has RING
--R   [2] (Fraction(D),D) -> Union(Fraction(D),"failed") from D
--R             if D has UPOLYC(D2) and D2 has RING and D2 has INTDOM
--R   [3] (D,D) -> Union(D,"failed") from D
--R             if D has UPOLYC(D1) and D1 has RING and D1 has INTDOM
--R
--RExamples of composite from ThreeSpaceCategory
--R
--R
--RExamples of composite from UnivariatePolynomialCategory
--R
--E 428

--S 429 of 3320
)d op composites
--R 
--R
--RThere is one exposed function called composites :
--R   [1] D -> List(D) from D if D2 has RING and D has SPACEC(D2)
--R
--RExamples of composites from ThreeSpaceCategory
--R
--E 429

--S 430 of 3320
)d op computeBasis
--R 
--R
--RThere is one unexposed function called computeBasis :
--R   [1] List(HomogeneousDistributedMultivariatePolynomial(D2,D3)) -> 
--R            List(HomogeneousDistributedMultivariatePolynomial(D2,D3))
--R             from LinGroebnerPackage(D2,D3) if D2: LIST(SYMBOL) and D3
--R             has GCDDOM
--R
--RExamples of computeBasis from LinGroebnerPackage
--R
--E 430

--S 431 of 3320 done
)d op computeCycleEntry
--R 
--R
--RThere is one unexposed function called computeCycleEntry :
--R   [1] (D1,D1) -> D1 from CyclicStreamTools(D2,D1)
--R             if D2 has TYPE and D1 has LZSTAGG(D2)
--R
--RExamples of computeCycleEntry from CyclicStreamTools
--R
--Rp:=repeating([1,2,3]) 
--Rq:=cons(4,p) 
--RcomputeCycleEntry(q,cycleElt(q))
--R
--E 431

--S 432 of 3320 done
)d op computeCycleLength
--R 
--R
--RThere is one unexposed function called computeCycleLength :
--R   [1] D2 -> NonNegativeInteger from CyclicStreamTools(D3,D2)
--R             if D3 has TYPE and D2 has LZSTAGG(D3)
--R
--RExamples of computeCycleLength from CyclicStreamTools
--R
--Rp:=repeating([1,2,3]) 
--Rq:=cons(4,p) 
--RcomputeCycleLength(cycleElt(q))
--R
--E 432

--S 433 of 3320
)d op computeInt
--R 
--R
--RThere is one unexposed function called computeInt :
--R   [1] (Kernel(D3),D3,OrderedCompletion(D3),OrderedCompletion(D3),
--R            Boolean) -> Union(OrderedCompletion(D3),"failed")
--R             from DefiniteIntegrationTools(D5,D3)
--R             if D3 has Join(TranscendentalFunctionCategory,
--R            AlgebraicallyClosedFunctionSpace(D5)) and D5 has Join(
--R            GcdDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R
--RExamples of computeInt from DefiniteIntegrationTools
--R
--E 433

--S 434 of 3320
)d op computePowers
--R 
--R
--RThere is one unexposed function called computePowers :
--R   [1]  -> PrimitiveArray(ModMonic(D2,D3)) from ModMonic(D2,D3)
--R             if D2 has RING and D3 has UPOLYC(D2)
--R
--RExamples of computePowers from ModMonic
--R
--E 434

--S 435 of 3320
)d op concat
--R 
--R
--RThere are 11 exposed functions called concat :
--R   [1] (D,D) -> D from D if D has DIVCAT(D1) and D1 has SETCAT
--R   [2] (Result,Result) -> Result from ExpertSystemToolsPackage
--R   [3] List(Result) -> Result from ExpertSystemToolsPackage
--R   [4] List(D) -> D from D if D has LNAGG(D2) and D2 has TYPE
--R   [5] (D,D) -> D from D if D has LNAGG(D1) and D1 has TYPE
--R   [6] (D1,D) -> D from D if D has LNAGG(D1) and D1 has TYPE
--R   [7] (D,D1) -> D from D if D has LNAGG(D1) and D1 has TYPE
--R   [8] (RoutinesTable,RoutinesTable) -> RoutinesTable from 
--R            RoutinesTable
--R   [9] Stream(Stream(D3)) -> Stream(D3) from StreamFunctions1(D3) if D3
--R             has TYPE
--R   [10] (D1,D) -> D from D if D has URAGG(D1) and D1 has TYPE
--R   [11] (D,D) -> D from D if D has URAGG(D1) and D1 has TYPE
--R
--RExamples of concat from DivisorCategory
--R
--R
--RExamples of concat from ExpertSystemToolsPackage
--R
--R
--RExamples of concat from LinearAggregate
--R
--R
--RExamples of concat from RoutinesTable
--R
--R
--RExamples of concat from StreamFunctions1
--R
--Rm:=[i for i in 10..] 
--Rn:=[j for j in 1.. | prime? j] 
--Rp:=[m,n]::Stream(Stream(PositiveInteger)) 
--Rconcat(p)
--R
--R
--RExamples of concat from UnaryRecursiveAggregate
--R
--Rt1:=[1,2,3] 
--Rt2:=concat(4,t1) 
--Rt1 
--Rt2
--R
--Rt1:=[1,2,3] 
--Rt2:=concat(t1,t1) 
--Rt1 
--Rt2
--R
--E 435

--S 436 of 3320
)d op concat!
--R 
--R
--RThere are 5 exposed functions called concat! :
--R   [1] (D,D) -> D from D
--R             if D has shallowlyMutable and D has DLAGG(D1) and D1 has 
--R            TYPE
--R   [2] (D,D) -> D from D if D has ELAGG(D1) and D1 has TYPE
--R   [3] (D,D1) -> D from D if D has ELAGG(D1) and D1 has TYPE
--R   [4] (D,D1) -> D from D
--R             if D has shallowlyMutable and D has URAGG(D1) and D1 has 
--R            TYPE
--R   [5] (D,D) -> D from D
--R             if D has shallowlyMutable and D has URAGG(D1) and D1 has 
--R            TYPE
--R
--RExamples of concat! from DoublyLinkedAggregate
--R
--R
--RExamples of concat! from ExtensibleLinearAggregate
--R
--R
--RExamples of concat! from UnaryRecursiveAggregate
--R
--Rt1:=[1,2,3] 
--Rconcat!(t1,7) 
--Rt1
--R
--Rt1:=[1,2,3] 
--Rt2:=[4,5,6] 
--Rconcat!(t1,t2) 
--Rt1 
--Rt2
--R
--E 436

--S 437 of 3320
)d op cond
--R 
--R
--RThere are 2 exposed functions called cond :
--R   [1] (Switch,FortranCode,FortranCode) -> FortranCode from FortranCode
--R            
--R   [2] (Switch,FortranCode) -> FortranCode from FortranCode
--R
--RExamples of cond from FortranCode
--R
--E 437

--S 438 of 3320
)d op condition
--R 
--R
--RThere is one unexposed function called condition :
--R   [1] SplittingNode(D2,D1) -> D1 from SplittingNode(D2,D1)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of condition from SplittingNode
--R
--E 438

--S 439 of 3320
)d op conditionP
--R 
--R
--RThere are 2 exposed functions called conditionP :
--R   [1] Matrix(D) -> Union(Vector(D),"failed") from D if D has FFIELDC
--R         
--R   [2] Matrix(D) -> Union(Vector(D),"failed") from D if D has CHARNZ 
--R            and D has PFECAT
--R
--RExamples of conditionP from FiniteFieldCategory
--R
--R
--RExamples of conditionP from CharacteristicNonZero
--R
--E 439

--S 440 of 3320
)d op conditions
--R 
--R
--RThere is one unexposed function called conditions :
--R   [1] SplittingTree(D2,D3) -> List(D3) from SplittingTree(D2,D3)
--R             if D2 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of conditions from SplittingTree
--R
--E 440

--S 441 of 3320
--R--------------)d op conditionsForIdempotents (System Error)
--E 441

--S 442 of 3320
)d op conical
--R 
--R
--RThere is one exposed function called conical :
--R   [1] (D2,D2) -> (Point(D2) -> Point(D2)) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of conical from CoordinateSystems
--R
--E 442

--S 443 of 3320
)d op conjug
--R 
--R
--RThere is one exposed function called conjug :
--R   [1] D1 -> D1 from ModuleOperator(D1,D2)
--R             if D1 has COMRING and D1 has RING and D2 has LMODULE(D1)
--R         
--R
--RThere is one unexposed function called conjug :
--R   [1] D1 -> D1 from Operator(D1) if D1 has COMRING and D1 has RING
--R
--RExamples of conjug from ModuleOperator
--R
--R
--RExamples of conjug from Operator
--R
--E 443

--S 444 of 3320
)d op conjugate
--R 
--R
--RThere are 10 exposed functions called conjugate :
--R   [1] D -> D from D if D has AFSPCAT(D1) and D1 has FIELD
--R   [2] (D,NonNegativeInteger) -> D from D if D has AFSPCAT(D2) and D2
--R             has FIELD
--R   [3] D -> D from D if D has COMPCAT(D1) and D1 has COMRING
--R   [4] (D,D) -> D from D if D has GROUP
--R   [5] D -> D from D if D has OC(D1) and D1 has COMRING
--R   [6] D -> D from D if D has PACPERC
--R   [7] List(Integer) -> List(Integer) from PartitionsAndPermutations
--R         
--R   [8] D -> D from D if D has PRSPCAT(D1) and D1 has FIELD
--R   [9] (D,NonNegativeInteger) -> D from D if D has PRSPCAT(D2) and D2
--R             has FIELD
--R   [10] D -> D from D if D has QUATCAT(D1) and D1 has COMRING
--R
--RThere is one unexposed function called conjugate :
--R   [1] Partition -> Partition from Partition
--R
--RExamples of conjugate from AffineSpaceCategory
--R
--R
--RExamples of conjugate from ComplexCategory
--R
--R
--RExamples of conjugate from Group
--R
--R
--RExamples of conjugate from OctonionCategory
--R
--R
--RExamples of conjugate from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--R
--RExamples of conjugate from PartitionsAndPermutations
--R
--R
--RExamples of conjugate from ProjectiveSpaceCategory
--R
--R
--RExamples of conjugate from Partition
--R
--R
--RExamples of conjugate from QuaternionCategory
--R
--E 444

--S 445 of 3320
)d op conjugates
--R 
--R
--RThere is one exposed function called conjugates :
--R   [1] Stream(List(Integer)) -> Stream(List(Integer))
--R             from PartitionsAndPermutations
--R
--RExamples of conjugates from PartitionsAndPermutations
--R
--E 445

--S 446 of 3320
)d op connect
--R 
--R
--RThere is one unexposed function called connect :
--R   [1] (TwoDimensionalViewport,PositiveInteger,String) -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of connect from TwoDimensionalViewport
--R
--E 446

--S 447 of 3320
)d op cons
--R 
--R
--RThere are 2 exposed functions called cons :
--R   [1] (D1,List(D1)) -> List(D1) from List(D1) if D1 has TYPE
--R   [2] (D1,Stream(D1)) -> Stream(D1) from Stream(D1) if D1 has TYPE
--R
--RExamples of cons from List
--R
--R
--RExamples of cons from Stream
--R
--Rm:=[1,2,3] 
--Rn:=repeating(m) 
--Rcons(4,n)
--R
--E 447

--S 448 of 3320
)d op consnewpol
--R 
--R
--RThere is one unexposed function called consnewpol :
--R   [1] (SparseUnivariatePolynomial(D8),SparseUnivariatePolynomial(D7),
--R            Integer) -> Record(pol: SparseUnivariatePolynomial(D8),polval: 
--R            SparseUnivariatePolynomial(D7))
--R             from MultivariateSquareFree(D5,D6,D7,D8)
--R             if D5 has OAMONS and D6 has ORDSET and D7 has EUCDOM and 
--R            D8 has POLYCAT(D7,D5,D6)
--R
--RExamples of consnewpol from MultivariateSquareFree
--R
--E 448

--S 449 of 3320
)d op consRow!
--R 
--R
--RThere is one exposed function called consRow! :
--R   [1] (SparseEchelonMatrix(D3,D4),Record(Indices: List(D3),Entries: 
--R            List(D4))) -> Void
--R             from SparseEchelonMatrix(D3,D4) if D3 has ORDSET and D4
--R             has RING
--R
--RExamples of consRow! from SparseEchelonMatrix
--R
--E 449

--S 450 of 3320
)d op const
--R 
--R
--RThere is one exposed function called const :
--R   [1] D2 -> (D3 -> D2) from MappingPackage2(D3,D2)
--R             if D3 has SETCAT and D2 has SETCAT
--R
--RExamples of const from MappingPackage2
--R
--E 450

--S 451 of 3320
)d op constant
--R 
--R
--RThere are 5 exposed functions called constant :
--R   [1] (() -> D4) -> (D3 -> D4) from MappingPackage2(D3,D4)
--R             if D4 has SETCAT and D3 has SETCAT
--R   [2] D2 -> D1 from PackageForPoly(D1,D2,D3,D4)
--R             if D3 has DIRPCAT(D4,NNI) and D4: NNI and D1 has RING and 
--R            D2 has FAMR(D1,D3)
--R   [3] D1 -> D1 from FunctionSpaceAssertions(D2,D1)
--R             if D2 has ORDSET and D1 has FS(D2)
--R   [4] Symbol -> Expression(Integer) from PatternMatchAssertions
--R   [5] D -> D1 from D if D has XFALG(D2,D1) and D2 has ORDSET and D1
--R             has RING
--R
--RThere is one unexposed function called constant :
--R   [1] XPolynomialRing(D1,D2) -> D1 from XPolynomialRing(D1,D2)
--R             if D1 has RING and D2 has ORDMON
--R
--RExamples of constant from MappingPackage2
--R
--R
--RExamples of constant from PackageForPoly
--R
--R
--RExamples of constant from FunctionSpaceAssertions
--R
--R
--RExamples of constant from PatternMatchAssertions
--R
--R
--RExamples of constant from XFreeAlgebra
--R
--R
--RExamples of constant from XPolynomialRing
--R
--E 451

--S 452 of 3320
)d op constant?
--R 
--R
--RThere is one exposed function called constant? :
--R   [1] D -> Boolean from D if D has XFALG(D2,D3) and D2 has ORDSET and 
--R            D3 has RING
--R
--RThere are 2 unexposed functions called constant? :
--R   [1] Pattern(D2) -> Boolean from Pattern(D2) if D2 has SETCAT
--R   [2] XPolynomialRing(D2,D3) -> Boolean from XPolynomialRing(D2,D3)
--R             if D2 has RING and D3 has ORDMON
--R
--RExamples of constant? from Pattern
--R
--R
--RExamples of constant? from XFreeAlgebra
--R
--R
--RExamples of constant? from XPolynomialRing
--R
--E 452

--S 453 of 3320
)d op constantCoefficientRicDE
--R 
--R
--RThere is one unexposed function called constantCoefficientRicDE :
--R   [1] (D2,(D5 -> List(D4))) -> List(Record(constant: D4,eq: D2))
--R             from PrimitiveRatRicDE(D4,D5,D2,D6)
--R             if D4 has Join(Field,CharacteristicZero,RetractableTo(
--R            Fraction(Integer))) and D5 has UPOLYC(D4) and D2 has 
--R            LODOCAT(D5) and D6 has LODOCAT(FRAC(D5))
--R
--RExamples of constantCoefficientRicDE from PrimitiveRatRicDE
--R
--E 453

--S 454 of 3320
)d op constantIfCan
--R 
--R
--RThere is one exposed function called constantIfCan :
--R   [1] Kernel(D3) -> Union(D1,"failed") from KernelFunctions2(D1,D3)
--R             if D3 has ORDSET and D1 has ORDSET
--R
--RExamples of constantIfCan from KernelFunctions2
--R
--E 454

--S 455 of 3320
)d op constantKernel
--R 
--R
--RThere is one exposed function called constantKernel :
--R   [1] D2 -> Kernel(D3) from KernelFunctions2(D2,D3)
--R             if D2 has ORDSET and D3 has ORDSET
--R
--RExamples of constantKernel from KernelFunctions2
--R
--E 455

--S 456 of 3320
)d op constantLeft
--R 
--R
--RThere is one exposed function called constantLeft :
--R   [1] (D4 -> D5) -> ((D3,D4) -> D5) from MappingPackage3(D3,D4,D5)
--R             if D4 has SETCAT and D5 has SETCAT and D3 has SETCAT
--R
--RExamples of constantLeft from MappingPackage3
--R
--E 456

--S 457 of 3320
)d op constantOperator
--R 
--R
--RThere is one exposed function called constantOperator :
--R   [1] D2 -> BasicOperator from BasicOperatorFunctions1(D2)
--R             if D2 has ORDSET and D2 has SETCAT
--R
--RExamples of constantOperator from BasicOperatorFunctions1
--R
--E 457

--S 458 of 3320
)d op constantOpIfCan
--R 
--R
--RThere is one exposed function called constantOpIfCan :
--R   [1] BasicOperator -> Union(D1,"failed") from BasicOperatorFunctions1
--R            (D1)
--R             if D1 has SETCAT and D1 has ORDSET
--R
--RExamples of constantOpIfCan from BasicOperatorFunctions1
--R
--E 458

--S 459 of 3320
)d op constantRight
--R 
--R
--RThere is one exposed function called constantRight :
--R   [1] (D3 -> D5) -> ((D3,D4) -> D5) from MappingPackage3(D3,D4,D5)
--R             if D3 has SETCAT and D5 has SETCAT and D4 has SETCAT
--R
--RExamples of constantRight from MappingPackage3
--R
--E 459

--S 460 of 3320
)d op constantToUnaryFunction
--R 
--R
--RThere is one unexposed function called constantToUnaryFunction :
--R   [1] DoubleFloat -> (DoubleFloat -> DoubleFloat) from 
--R            ExpressionTubePlot
--R
--RExamples of constantToUnaryFunction from ExpressionTubePlot
--R
--E 460

--S 461 of 3320
)d op constDsolve
--R 
--R
--RThere is one unexposed function called constDsolve :
--R   [1] (D2,D3,Symbol) -> Record(particular: D3,basis: List(D3))
--R             from ConstantLODE(D5,D3,D2)
--R             if D5 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero) and D3 has Join(
--R            AlgebraicallyClosedFunctionSpace(D5),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory) 
--R            and D2 has LODOCAT(D3)
--R
--RExamples of constDsolve from ConstantLODE
--R
--E 461

--S 462 of 3320
)d op construct
--R 
--R
--RThere are 7 exposed functions called construct :
--R   [1] List(D2) -> D from D if D2 has TYPE and D has CLAGG(D2)
--R   [2] List(Record(exponent: NonNegativeInteger,center: D3,num: D3))
--R             -> FullPartialFractionExpansion(D2,D3)
--R             from FullPartialFractionExpansion(D2,D3)
--R             if D3 has UPOLYC(D2) and D2 has Join(Field,
--R            CharacteristicZero)
--R   [3] (Union(fst: FortranScalarType,void: void),List(Polynomial(
--R            Integer)),Boolean) -> FortranType
--R             from FortranType
--R   [4] (Union(fst: FortranScalarType,void: void),List(Symbol),Boolean)
--R             -> FortranType
--R             from FortranType
--R   [5] InfiniteTuple(D2) -> Stream(D2) from InfiniteTuple(D2) if D2
--R             has TYPE
--R   [6] (D,D) -> D from D if D has LIECAT(D1) and D1 has COMRING
--R   [7] List(List(List(D2))) -> ThreeDimensionalMatrix(D2)
--R             from ThreeDimensionalMatrix(D2) if D2 has SETCAT
--R
--RThere are 15 unexposed functions called construct :
--R   [1] (LiePolynomial(D2,D3),LyndonWord(D2)) -> LiePolynomial(D2,D3)
--R             from LiePolynomial(D2,D3) if D2 has ORDSET and D3 has 
--R            COMRING
--R   [2] (LyndonWord(D2),LiePolynomial(D2,D3)) -> LiePolynomial(D2,D3)
--R             from LiePolynomial(D2,D3) if D2 has ORDSET and D3 has 
--R            COMRING
--R   [3] (LyndonWord(D2),LyndonWord(D2)) -> LiePolynomial(D2,D3)
--R             from LiePolynomial(D2,D3) if D2 has ORDSET and D3 has 
--R            COMRING
--R   [4] (D1,D2) -> ModuleMonomial(D1,D2,D3) from ModuleMonomial(D1,D2,D3
--R            )
--R             if D1 has ORDSET and D2 has SETCAT and D3: ((Record(index
--R            : D1,exponent: D2),Record(index: D1,exponent: D2)) -> 
--R            Boolean)
--R   [5] List(Record(key: Symbol,entry: D3)) -> PatternMatchResult(D2,D3)
--R             from PatternMatchResult(D2,D3) if D3 has SETCAT and D2
--R             has SETCAT
--R   [6] (D2,List(D4)) -> List(SplittingNode(D2,D4)) from SplittingNode(
--R            D2,D4)
--R             if D4 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R   [7] List(Record(val: D3,tower: D4)) -> List(SplittingNode(D3,D4))
--R             from SplittingNode(D3,D4)
--R             if D3 has Join(SetCategory,Aggregate) and D4 has Join(
--R            SetCategory,Aggregate)
--R   [8] Record(val: D2,tower: D3) -> SplittingNode(D2,D3)
--R             from SplittingNode(D2,D3)
--R             if D2 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R   [9] (D1,D2) -> SplittingNode(D1,D2) from SplittingNode(D1,D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R   [10] (D1,D2,Boolean) -> SplittingNode(D1,D2) from SplittingNode(D1,
--R            D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R   [11] (D1,D2,D1,List(D2)) -> SplittingTree(D1,D2) from SplittingTree(
--R            D1,D2)
--R             if D2 has Join(SetCategory,Aggregate) and D1 has Join(
--R            SetCategory,Aggregate)
--R   [12] (D1,D2,List(SplittingNode(D1,D2))) -> SplittingTree(D1,D2)
--R             from SplittingTree(D1,D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R   [13] (D1,D2,List(SplittingTree(D1,D2))) -> SplittingTree(D1,D2)
--R             from SplittingTree(D1,D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R   [14] SplittingNode(D2,D3) -> SplittingTree(D2,D3) from SplittingTree
--R            (D2,D3)
--R             if D2 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R   [15] (D1,D2) -> SuchThat(D1,D2) from SuchThat(D1,D2)
--R             if D1 has SETCAT and D2 has SETCAT
--R
--RExamples of construct from Collection
--R
--R
--RExamples of construct from FullPartialFractionExpansion
--R
--R
--RExamples of construct from FortranType
--R
--R
--RExamples of construct from InfiniteTuple
--R
--R
--RExamples of construct from LieAlgebra
--R
--R
--RExamples of construct from LiePolynomial
--R
--R
--RExamples of construct from ThreeDimensionalMatrix
--R
--R
--RExamples of construct from ModuleMonomial
--R
--R
--RExamples of construct from PatternMatchResult
--R
--R
--RExamples of construct from SplittingNode
--R
--R
--RExamples of construct from SplittingTree
--R
--R
--RExamples of construct from SuchThat
--R
--E 462

--S 463 of 3320
)d op construct
--R 
--R
--RThere are 7 exposed functions called construct :
--R   [1] List(D2) -> D from D if D2 has TYPE and D has CLAGG(D2)
--R   [2] List(Record(exponent: NonNegativeInteger,center: D3,num: D3))
--R             -> FullPartialFractionExpansion(D2,D3)
--R             from FullPartialFractionExpansion(D2,D3)
--R             if D3 has UPOLYC(D2) and D2 has Join(Field,
--R            CharacteristicZero)
--R   [3] (Union(fst: FortranScalarType,void: void),List(Polynomial(
--R            Integer)),Boolean) -> FortranType
--R             from FortranType
--R   [4] (Union(fst: FortranScalarType,void: void),List(Symbol),Boolean)
--R             -> FortranType
--R             from FortranType
--R   [5] InfiniteTuple(D2) -> Stream(D2) from InfiniteTuple(D2) if D2
--R             has TYPE
--R   [6] (D,D) -> D from D if D has LIECAT(D1) and D1 has COMRING
--R   [7] List(List(List(D2))) -> ThreeDimensionalMatrix(D2)
--R             from ThreeDimensionalMatrix(D2) if D2 has SETCAT
--R
--RThere are 15 unexposed functions called construct :
--R   [1] (LiePolynomial(D2,D3),LyndonWord(D2)) -> LiePolynomial(D2,D3)
--R             from LiePolynomial(D2,D3) if D2 has ORDSET and D3 has 
--R            COMRING
--R   [2] (LyndonWord(D2),LiePolynomial(D2,D3)) -> LiePolynomial(D2,D3)
--R             from LiePolynomial(D2,D3) if D2 has ORDSET and D3 has 
--R            COMRING
--R   [3] (LyndonWord(D2),LyndonWord(D2)) -> LiePolynomial(D2,D3)
--R             from LiePolynomial(D2,D3) if D2 has ORDSET and D3 has 
--R            COMRING
--R   [4] (D1,D2) -> ModuleMonomial(D1,D2,D3) from ModuleMonomial(D1,D2,D3
--R            )
--R             if D1 has ORDSET and D2 has SETCAT and D3: ((Record(index
--R            : D1,exponent: D2),Record(index: D1,exponent: D2)) -> 
--R            Boolean)
--R   [5] List(Record(key: Symbol,entry: D3)) -> PatternMatchResult(D2,D3)
--R             from PatternMatchResult(D2,D3) if D3 has SETCAT and D2
--R             has SETCAT
--R   [6] (D2,List(D4)) -> List(SplittingNode(D2,D4)) from SplittingNode(
--R            D2,D4)
--R             if D4 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R   [7] List(Record(val: D3,tower: D4)) -> List(SplittingNode(D3,D4))
--R             from SplittingNode(D3,D4)
--R             if D3 has Join(SetCategory,Aggregate) and D4 has Join(
--R            SetCategory,Aggregate)
--R   [8] Record(val: D2,tower: D3) -> SplittingNode(D2,D3)
--R             from SplittingNode(D2,D3)
--R             if D2 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R   [9] (D1,D2) -> SplittingNode(D1,D2) from SplittingNode(D1,D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R   [10] (D1,D2,Boolean) -> SplittingNode(D1,D2) from SplittingNode(D1,
--R            D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R   [11] (D1,D2,D1,List(D2)) -> SplittingTree(D1,D2) from SplittingTree(
--R            D1,D2)
--R             if D2 has Join(SetCategory,Aggregate) and D1 has Join(
--R            SetCategory,Aggregate)
--R   [12] (D1,D2,List(SplittingNode(D1,D2))) -> SplittingTree(D1,D2)
--R             from SplittingTree(D1,D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R   [13] (D1,D2,List(SplittingTree(D1,D2))) -> SplittingTree(D1,D2)
--R             from SplittingTree(D1,D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R   [14] SplittingNode(D2,D3) -> SplittingTree(D2,D3) from SplittingTree
--R            (D2,D3)
--R             if D2 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R   [15] (D1,D2) -> SuchThat(D1,D2) from SuchThat(D1,D2)
--R             if D1 has SETCAT and D2 has SETCAT
--R
--RExamples of construct from Collection
--R
--R
--RExamples of construct from FullPartialFractionExpansion
--R
--R
--RExamples of construct from FortranType
--R
--R
--RExamples of construct from InfiniteTuple
--R
--R
--RExamples of construct from LieAlgebra
--R
--R
--RExamples of construct from LiePolynomial
--R
--R
--RExamples of construct from ThreeDimensionalMatrix
--R
--R
--RExamples of construct from ModuleMonomial
--R
--R
--RExamples of construct from PatternMatchResult
--R
--R
--RExamples of construct from SplittingNode
--R
--R
--RExamples of construct from SplittingTree
--R
--R
--RExamples of construct from SuchThat
--R
--E 463

--S 464 of 3320
)d op contains?
--R 
--R
--RThere is one exposed function called contains? :
--R   [1] (D,D2) -> Boolean from D
--R             if D has INTCAT(D2) and D2 has Join(FloatingPointSystem,
--R            TranscendentalFunctionCategory)
--R
--RExamples of contains? from IntervalCategory
--R
--E 464

--S 465 of 3320
)d op content
--R 
--R
--RThere are 3 exposed functions called content :
--R   [1] D -> D1 from D
--R             if D has FAMR(D1,D2) and D2 has OAMON and D1 has RING and 
--R            D1 has GCDDOM
--R   [2] D -> D1 from D if D has OREPCAT(D1) and D1 has RING and D1 has 
--R            GCDDOM
--R   [3] (D,D1) -> D from D
--R             if D has POLYCAT(D2,D3,D1) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET and D2 has GCDDOM
--R
--RThere is one unexposed function called content :
--R   [1] List(D3) -> List(Integer) from HeuGcd(D3) if D3 has UPOLYC(INT)
--R            
--R
--RExamples of content from FiniteAbelianMonoidRing
--R
--R
--RExamples of content from HeuGcd
--R
--R
--RExamples of content from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of content from PolynomialCategory
--R
--E 465

--S 466 of 3320
)d op continue
--R 
--R
--RThere is one exposed function called continue :
--R   [1] SingleInteger -> FortranCode from FortranCode
--R
--RExamples of continue from FortranCode
--R
--E 466

--S 467 of 3320
)d op continuedFraction
--R 
--R
--RThere are 3 exposed functions called continuedFraction :
--R   [1] (D1,Stream(D1),Stream(D1)) -> ContinuedFraction(D1)
--R             from ContinuedFraction(D1) if D1 has EUCDOM
--R   [2] Fraction(D2) -> ContinuedFraction(D2) from ContinuedFraction(D2)
--R             if D2 has EUCDOM
--R   [3] D2 -> ContinuedFraction(Integer) from NumericContinuedFraction(
--R            D2)
--R             if D2 has FPS
--R
--RThere are 3 unexposed functions called continuedFraction :
--R   [1] BalancedPAdicRational(D2) -> ContinuedFraction(Fraction(Integer)
--R            )
--R             from BalancedPAdicRational(D2) if D2: INT
--R   [2] PAdicRational(D2) -> ContinuedFraction(Fraction(Integer))
--R             from PAdicRational(D2) if D2: INT
--R   [3] PAdicRationalConstructor(D2,D3) -> ContinuedFraction(Fraction(
--R            Integer))
--R             from PAdicRationalConstructor(D2,D3) if D2: INT and D3
--R             has PADICCT(D2)
--R
--RExamples of continuedFraction from BalancedPAdicRational
--R
--R
--RExamples of continuedFraction from ContinuedFraction
--R
--R
--RExamples of continuedFraction from NumericContinuedFraction
--R
--R
--RExamples of continuedFraction from PAdicRational
--R
--R
--RExamples of continuedFraction from PAdicRationalConstructor
--R
--E 467

--S 468 of 3320
)d op contract
--R 
--R
--RThere are 3 exposed functions called contract :
--R   [1] (CartesianTensor(D2,D3,D4),Integer,Integer) -> CartesianTensor(
--R            D2,D3,D4)
--R             from CartesianTensor(D2,D3,D4) if D2: INT and D3: NNI and 
--R            D4 has COMRING
--R   [2] (CartesianTensor(D2,D3,D4),Integer,CartesianTensor(D2,D3,D4),
--R            Integer) -> CartesianTensor(D2,D3,D4)
--R             from CartesianTensor(D2,D3,D4) if D2: INT and D3: NNI and 
--R            D4 has COMRING
--R   [3] (PolynomialIdeals(Fraction(Integer),DirectProduct(D4,
--R            NonNegativeInteger),OrderedVariableList(D3),
--R            DistributedMultivariatePolynomial(D3,Fraction(Integer))),List(
--R            OrderedVariableList(D3))) -> PolynomialIdeals(Fraction(Integer),
--R            DirectProduct(D4,NonNegativeInteger),OrderedVariableList(D3),
--R            DistributedMultivariatePolynomial(D3,Fraction(Integer)))
--R             from IdealDecompositionPackage(D3,D4) if D3: LIST(SYMBOL) 
--R            and D4: NNI
--R
--RExamples of contract from CartesianTensor
--R
--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
--RTm:CartesianTensor(1,2,Integer):=m 
--Rv:DirectProduct(2,Integer):=directProduct [3,4] 
--RTv:CartesianTensor(1,2,Integer):=v 
--RTmv:=contract(Tm,2,1)
--R
--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
--RTm:CartesianTensor(1,2,Integer):=m 
--Rv:DirectProduct(2,Integer):=directProduct [3,4] 
--RTv:CartesianTensor(1,2,Integer):=v 
--RTmv:=contract(Tm,2,Tv,1)
--R
--R
--RExamples of contract from IdealDecompositionPackage
--R
--E 468

--S 469 of 3320 done
)d op contractSolve
--R 
--R
--RThere are 2 exposed functions called contractSolve :
--R   [1] (Equation(Fraction(Polynomial(D4))),Symbol) -> SuchThat(List(
--R            Expression(D4)),List(Equation(Expression(D4))))
--R             from RadicalSolvePackage(D4)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero)
--R   [2] (Fraction(Polynomial(D4)),Symbol) -> SuchThat(List(Expression(D4
--R            )),List(Equation(Expression(D4))))
--R             from RadicalSolvePackage(D4)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero)
--R
--RExamples of contractSolve from RadicalSolvePackage
--R
--Rb:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) 
--RcontractSolve(b,x)
--R
--Rb:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) 
--RcontractSolve(b=0,x)
--R
--E 469

--S 470 of 3320
)d op controlPanel
--R 
--R
--RThere is one exposed function called controlPanel :
--R   [1] (ThreeDimensionalViewport,String) -> Void from 
--R            ThreeDimensionalViewport
--R
--RThere is one unexposed function called controlPanel :
--R   [1] (TwoDimensionalViewport,String) -> Void from 
--R            TwoDimensionalViewport
--R
--RExamples of controlPanel from TwoDimensionalViewport
--R
--R
--RExamples of controlPanel from ThreeDimensionalViewport
--R
--E 470

--S 471 of 3320
)d op convergents
--R 
--R
--RThere is one exposed function called convergents :
--R   [1] ContinuedFraction(D2) -> Stream(Fraction(D2)) from 
--R            ContinuedFraction(D2)
--R             if D2 has EUCDOM
--R
--RExamples of convergents from ContinuedFraction
--R
--E 471

--S 472 of 3320
)d op convert
--R 
--R
--RThere are 32 exposed functions called convert :
--R   [1] Symbol -> BasicStochasticDifferential from 
--R            BasicStochasticDifferential
--R   [2] List(Segment(OrderedCompletion(Float))) -> List(Segment(
--R            OrderedCompletion(DoubleFloat)))
--R             from ExpertSystemToolsPackage
--R   [3] DoubleFloat -> Float from Float
--R   [4] (OutputForm,Integer) -> ScriptFormulaFormat from 
--R            ScriptFormulaFormat
--R   [5] Vector(D2) -> D from D
--R             if D2 has COMRING and D has FRAMALG(D2,D3) and D3 has 
--R            UPOLYC(D2)
--R   [6] D -> Vector(D2) from D
--R             if D has FRAMALG(D2,D3) and D2 has COMRING and D3 has 
--R            UPOLYC(D2)
--R   [7] Vector(D2) -> D from D if D2 has COMRING and D has FRNAALG(D2)
--R         
--R   [8] D -> Vector(D2) from D if D has FRNAALG(D2) and D2 has COMRING
--R         
--R   [9] Factored(D) -> D from D if D has FS(D2) and D2 has INTDOM and D2
--R             has ORDSET
--R   [10] D -> D1 from D if D has KONVERT(D1) and D1 has TYPE
--R   [11] D1 -> D from D
--R             if D2 has COMRING and D has MONOGEN(D2,D1) and D1 has 
--R            UPOLYC(D2)
--R   [12] List(D2) -> D from D if D2 has RING and D has PTCAT(D2)
--R   [13] Symbol -> RomanNumeral from RomanNumeral
--R   [14] Polynomial(D2) -> D from D
--R             if D2 has RING and D has RPOLCAT(D2,D3,D4) and D4 has 
--R            KONVERT(SYMBOL) and D3 has OAMONS and D4 has ORDSET
--R   [15] D1 -> D from D
--R             if D1 = POLY(INT) and D has RPOLCAT(D2,D3,D4) and not(
--R            ofCategory(D2,Algebra(Fraction(Integer)))) and D2 has 
--R            ALGEBRA(INT) and D4 has KONVERT(SYMBOL) and D2 has RING and
--R            D3 has OAMONS and D4 has ORDSET or D1 = POLY(INT) and D
--R             has RPOLCAT(D2,D3,D4) and D2 has ALGEBRA(FRAC(INT)) and D4
--R             has KONVERT(SYMBOL) and D2 has RING and D3 has OAMONS and 
--R            D4 has ORDSET
--R   [16] Polynomial(Fraction(Integer)) -> D from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has ALGEBRA(FRAC(INT)) 
--R            and D4 has KONVERT(SYMBOL) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [17] Record(val: List(D6),tower: D7) -> String
--R             from RegularSetDecompositionPackage(D3,D4,D5,D6,D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D7 has RSETCAT(D3,D4,D5,D6
--R            ) and D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET
--R   [18] D1 -> D from D if D has SEGCAT(D1) and D1 has TYPE
--R   [19] D1 -> D from D
--R             if D has SEXCAT(D2,D3,D4,D5,D1) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D1 has 
--R            SETCAT
--R   [20] D1 -> D from D
--R             if D has SEXCAT(D2,D3,D4,D1,D5) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D1 has SETCAT and D5 has 
--R            SETCAT
--R   [21] D1 -> D from D
--R             if D has SEXCAT(D2,D3,D1,D4,D5) and D2 has SETCAT and D3
--R             has SETCAT and D1 has SETCAT and D4 has SETCAT and D5 has 
--R            SETCAT
--R   [22] D1 -> D from D
--R             if D has SEXCAT(D2,D1,D3,D4,D5) and D2 has SETCAT and D1
--R             has SETCAT and D3 has SETCAT and D4 has SETCAT and D5 has 
--R            SETCAT
--R   [23] D1 -> D from D
--R             if D has SEXCAT(D1,D2,D3,D4,D5) and D1 has SETCAT and D2
--R             has SETCAT and D3 has SETCAT and D4 has SETCAT and D5 has 
--R            SETCAT
--R   [24] List(D) -> D from D
--R             if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R   [25] Record(val: List(D6),tower: D7) -> String
--R             from SquareFreeRegularSetDecompositionPackage(D3,D4,D5,D6,
--R            D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D7 has SFRTCAT(D3,D4,D5,D6
--R            ) and D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET
--R   [26] (OutputForm,Integer,OutputForm) -> TexFormat from TexFormat
--R   [27] (OutputForm,Integer) -> TexFormat from TexFormat
--R   [28] NewSparseMultivariatePolynomial(D3,OrderedVariableList(D4)) -> 
--R            NewSparseMultivariatePolynomial(D3,OrderedVariableList(D5))
--R             from ZeroDimensionalSolvePackage(D3,D4,D5)
--R             if D3 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D4: LIST(SYMBOL) and 
--R            D5: LIST(SYMBOL)
--R   [29] Polynomial(D3) -> Polynomial(RealClosure(Fraction(D3)))
--R             from ZeroDimensionalSolvePackage(D3,D4,D5)
--R             if D3 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D4: LIST(SYMBOL) and 
--R            D5: LIST(SYMBOL)
--R   [30] NewSparseMultivariatePolynomial(D3,OrderedVariableList(D5)) -> 
--R            Polynomial(RealClosure(Fraction(D3)))
--R             from ZeroDimensionalSolvePackage(D3,D4,D5)
--R             if D3 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D5: LIST(SYMBOL) and 
--R            D4: LIST(SYMBOL)
--R   [31] SparseUnivariatePolynomial(D3) -> SparseUnivariatePolynomial(
--R            RealClosure(Fraction(D3)))
--R             from ZeroDimensionalSolvePackage(D3,D4,D5)
--R             if D3 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D4: LIST(SYMBOL) and 
--R            D5: LIST(SYMBOL)
--R   [32] SquareFreeRegularTriangularSet(D3,IndexedExponents(
--R            OrderedVariableList(D5)),OrderedVariableList(D5),
--R            NewSparseMultivariatePolynomial(D3,OrderedVariableList(D5))) -> 
--R            List(NewSparseMultivariatePolynomial(D3,OrderedVariableList(D5)))
--R             from ZeroDimensionalSolvePackage(D3,D4,D5)
--R             if D3 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D5: LIST(SYMBOL) and 
--R            D4: LIST(SYMBOL)
--R
--RThere are 5 unexposed functions called convert :
--R   [1] D2 -> Pattern(D3) from ComplexPattern(D3,D4,D2)
--R             if D4 has Join(ConvertibleTo(Pattern(D3)),CommutativeRing)
--R            and D3 has SETCAT and D2 has COMPCAT(D4)
--R   [2] List(D5) -> GeneralPolynomialSet(D2,D3,D4,D5)
--R             from GeneralPolynomialSet(D2,D3,D4,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [3] SExpression -> InputForm from InputForm
--R   [4] List(Pattern(D2)) -> Pattern(D2) from Pattern(D2) if D2 has 
--R            SETCAT
--R   [5] SingletonAsOrderedSet -> Symbol from SingletonAsOrderedSet
--R
--RExamples of convert from BasicStochasticDifferential
--R
--R
--RExamples of convert from ComplexPattern
--R
--R
--RExamples of convert from ExpertSystemToolsPackage
--R
--R
--RExamples of convert from Float
--R
--R
--RExamples of convert from ScriptFormulaFormat
--R
--R
--RExamples of convert from FramedAlgebra
--R
--R
--RExamples of convert from FramedNonAssociativeAlgebra
--R
--R
--RExamples of convert from FunctionSpace
--R
--R
--RExamples of convert from GeneralPolynomialSet
--R
--R
--RExamples of convert from InputForm
--R
--R
--RExamples of convert from ConvertibleTo
--R
--R
--RExamples of convert from MonogenicAlgebra
--R
--R
--RExamples of convert from Pattern
--R
--R
--RExamples of convert from PointCategory
--R
--R
--RExamples of convert from RomanNumeral
--R
--R
--RExamples of convert from RecursivePolynomialCategory
--R
--R
--RExamples of convert from RegularSetDecompositionPackage
--R
--R
--RExamples of convert from SingletonAsOrderedSet
--R
--R
--RExamples of convert from SegmentCategory
--R
--R
--RExamples of convert from SExpressionCategory
--R
--R
--RExamples of convert from SquareFreeRegularSetDecompositionPackage
--R
--R
--RExamples of convert from TexFormat
--R
--R
--RExamples of convert from ZeroDimensionalSolvePackage
--R
--E 472

--S 473 of 3320
)d op convertIfCan
--R 
--R
--RThere is one exposed function called convertIfCan :
--R   [1] Symbol -> Union(BasicStochasticDifferential,"failed")
--R             from BasicStochasticDifferential
--R
--RExamples of convertIfCan from BasicStochasticDifferential
--R
--E 473

--S 474 of 3320
)d op coord
--R 
--R
--RThere is one exposed function called coord :
--R   [1] (Point(DoubleFloat) -> Point(DoubleFloat)) -> DrawOption from 
--R            DrawOption
--R
--RThere are 2 unexposed functions called coord :
--R   [1] (List(DrawOption),(Point(DoubleFloat) -> Point(DoubleFloat)))
--R             -> (Point(DoubleFloat) -> Point(DoubleFloat))
--R             from DrawOptionFunctions0
--R   [2] (HomogeneousDistributedMultivariatePolynomial(D4,D5),List(
--R            HomogeneousDistributedMultivariatePolynomial(D4,D5))) -> Vector(
--R            D5)
--R             from LinGroebnerPackage(D4,D5) if D4: LIST(SYMBOL) and D5
--R             has GCDDOM
--R
--RExamples of coord from DrawOptionFunctions0
--R
--R
--RExamples of coord from DrawOption
--R
--R
--RExamples of coord from LinGroebnerPackage
--R
--E 474

--S 475 of 3320
)d op coordinate
--R 
--R
--RThere are 3 exposed functions called coordinate :
--R   [1] (ParametricPlaneCurve(D1),NonNegativeInteger) -> D1
--R             from ParametricPlaneCurve(D1) if D1 has TYPE
--R   [2] (ParametricSpaceCurve(D1),NonNegativeInteger) -> D1
--R             from ParametricSpaceCurve(D1) if D1 has TYPE
--R   [3] (ParametricSurface(D1),NonNegativeInteger) -> D1
--R             from ParametricSurface(D1) if D1 has TYPE
--R
--RExamples of coordinate from ParametricPlaneCurve
--R
--R
--RExamples of coordinate from ParametricSpaceCurve
--R
--R
--RExamples of coordinate from ParametricSurface
--R
--E 475

--S 476 of 3320
)d op coordinates
--R 
--R
--RThere are 12 exposed functions called coordinates :
--R   [1] (Point(DoubleFloat) -> Point(DoubleFloat)) -> DrawOption from 
--R            DrawOption
--R   [2] Vector(D) -> Matrix(D3) from D if D has FAXF(D3) and D3 has 
--R            FIELD
--R   [3] D -> Vector(D2) from D if D has FAXF(D2) and D2 has FIELD
--R   [4] (Vector(D),Vector(D)) -> Matrix(D3) from D
--R             if D has FINAALG(D3) and D3 has COMRING
--R   [5] (D,Vector(D)) -> Vector(D3) from D if D has FINAALG(D3) and D3
--R             has COMRING
--R   [6] (Vector(D),Vector(D)) -> Matrix(D3) from D
--R             if D has FINRALG(D3,D4) and D3 has COMRING and D4 has 
--R            UPOLYC(D3)
--R   [7] (D,Vector(D)) -> Vector(D3) from D
--R             if D has FINRALG(D3,D4) and D3 has COMRING and D4 has 
--R            UPOLYC(D3)
--R   [8] Vector(D) -> Matrix(D3) from D
--R             if D has FRAMALG(D3,D4) and D3 has COMRING and D4 has 
--R            UPOLYC(D3)
--R   [9] D -> Vector(D2) from D
--R             if D has FRAMALG(D2,D3) and D2 has COMRING and D3 has 
--R            UPOLYC(D2)
--R   [10] Vector(D) -> Matrix(D3) from D if D has FRNAALG(D3) and D3 has 
--R            COMRING
--R   [11] D -> Vector(D2) from D if D has FRNAALG(D2) and D2 has COMRING
--R            
--R   [12] (Matrix(D4),List(Matrix(D4))) -> Vector(D4)
--R             from StructuralConstantsPackage(D4) if D4 has FIELD
--R
--RExamples of coordinates from DrawOption
--R
--R
--RExamples of coordinates from FiniteAlgebraicExtensionField
--R
--R
--RExamples of coordinates from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of coordinates from FiniteRankAlgebra
--R
--R
--RExamples of coordinates from FramedAlgebra
--R
--R
--RExamples of coordinates from FramedNonAssociativeAlgebra
--R
--R
--RExamples of coordinates from StructuralConstantsPackage
--R
--E 476

--S 477 of 3320
)d op copies
--R 
--R
--RThere is one exposed function called copies :
--R   [1] (Integer,String) -> String from DisplayPackage
--R
--RExamples of copies from DisplayPackage
--R
--E 477

--S 478 of 3320
)d op copy
--R 
--R
--RThere are 10 exposed functions called copy :
--R   [1] D -> D from D if D has AGG
--R   [2] ArrayStack(D1) -> ArrayStack(D1) from ArrayStack(D1) if D1 has 
--R            SETCAT
--R   [3] BasicOperator -> BasicOperator from BasicOperator
--R   [4] Dequeue(D1) -> Dequeue(D1) from Dequeue(D1) if D1 has SETCAT
--R   [5] Heap(D1) -> Heap(D1) from Heap(D1) if D1 has ORDSET
--R   [6] D -> D from D if D has INS
--R   [7] Queue(D1) -> Queue(D1) from Queue(D1) if D1 has SETCAT
--R   [8] SparseEchelonMatrix(D1,D2) -> SparseEchelonMatrix(D1,D2)
--R             from SparseEchelonMatrix(D1,D2) if D1 has ORDSET and D2
--R             has RING
--R   [9] D -> D from D if D has SPACEC(D1) and D1 has RING
--R   [10] Stack(D1) -> Stack(D1) from Stack(D1) if D1 has SETCAT
--R
--RThere are 3 unexposed functions called copy :
--R   [1] SubSpaceComponentProperty -> SubSpaceComponentProperty
--R             from SubSpaceComponentProperty
--R   [2] Pattern(D1) -> Pattern(D1) from Pattern(D1) if D1 has SETCAT
--R   [3] SplittingNode(D1,D2) -> SplittingNode(D1,D2) from SplittingNode(
--R            D1,D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of copy from Aggregate
--R
--R
--RExamples of copy from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rcopy a
--R
--R
--RExamples of copy from BasicOperator
--R
--R
--RExamples of copy from SubSpaceComponentProperty
--R
--R
--RExamples of copy from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rcopy a
--R
--R
--RExamples of copy from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rcopy a
--R
--R
--RExamples of copy from IntegerNumberSystem
--R
--R
--RExamples of copy from Pattern
--R
--R
--RExamples of copy from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rcopy a
--R
--R
--RExamples of copy from SparseEchelonMatrix
--R
--R
--RExamples of copy from ThreeSpaceCategory
--R
--R
--RExamples of copy from SplittingNode
--R
--R
--RExamples of copy from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rcopy a
--R
--E 478

--S 479 of 3320
)d op copy!
--R 
--R
--RThere is one unexposed function called copy! :
--R   [1] (Matrix(D2),Matrix(D2)) -> Matrix(D2)
--R             from StorageEfficientMatrixOperations(D2) if D2 has RING
--R         
--R
--RExamples of copy! from StorageEfficientMatrixOperations
--R
--E 479

--S 480 of 3320 done
)d op copyBSD
--R 
--R
--RThere is one exposed function called copyBSD :
--R   [1]  -> List(BasicStochasticDifferential) from 
--R            BasicStochasticDifferential
--R
--RExamples of copyBSD from BasicStochasticDifferential
--R
--Rintroduce!(t,dt) -- dt is a new stochastic differential 
--RcopyBSD()
--R
--E 480

--S 481 of 3320
)d op copyDrift
--R 
--R
--RThere is one exposed function called copyDrift :
--R   [1]  -> Table(StochasticDifferential(D2),StochasticDifferential(D2))
--R             from StochasticDifferential(D2)
--R             if D2 has Join(OrderedSet,IntegralDomain)
--R
--RExamples of copyDrift from StochasticDifferential
--R
--E 481

--S 482 of 3320
)d op copy_first
--R 
--R   copy_first is not a known function. Axiom will try to list its 
--R      functions which contain copy_first in their names. This is the 
--R      same output you would get by issuing
--R                         )what operations copy_first
--R
--R   There are no operations containing those patterns
--R
--E 482

--S 483 of 3320
--R---------------------- )d op copyInto_! (fix this)
--E 483

--S 484 of 3320 done
)d op copyIto
--R 
--R
--RThere is one exposed function called copyIto :
--R   [1]  -> Table(Symbol,BasicStochasticDifferential)
--R             from BasicStochasticDifferential
--R
--RExamples of copyIto from BasicStochasticDifferential
--R
--Rintroduce!(t,dt) -- dt is a new stochastic differential 
--RcopyIto()
--R
--E 484

--S 485 of 3320
)d op copyQuadVar
--R 
--R
--RThere is one exposed function called copyQuadVar :
--R   [1]  -> Table(StochasticDifferential(D2),StochasticDifferential(D2))
--R             from StochasticDifferential(D2)
--R             if D2 has Join(OrderedSet,IntegralDomain)
--R
--RExamples of copyQuadVar from StochasticDifferential
--R
--E 485

--S 486 of 3320
--R---------------------- )d op copy_slice (fix this)
--E 486

--S 487 of 3320
)d op corrPoly
--R 
--R
--RThere is one unexposed function called corrPoly :
--R   [1] (SparseUnivariatePolynomial(D2),List(D1),List(D9),List(
--R            NonNegativeInteger),List(SparseUnivariatePolynomial(D2)),Vector(
--R            List(SparseUnivariatePolynomial(D9))),D9) -> Union(List(
--R            SparseUnivariatePolynomial(D2)),"failed")
--R             from MultivariateLifting(D10,D1,D9,D2)
--R             if D1 has ORDSET and D9 has EUCDOM and D2 has POLYCAT(D9,
--R            D10,D1) and D10 has OAMONS
--R
--RExamples of corrPoly from MultivariateLifting
--R
--E 487

--S 488 of 3320
)d op cos
--R 
--R
--RThere are 2 exposed functions called cos :
--R   [1] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R   [2] D -> D from D if D has TRIGCAT
--R
--RThere are 6 unexposed functions called cos :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] D1 -> FourierComponent(D1) from FourierComponent(D1) if D1 has 
--R            ORDSET
--R   [5] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [6] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of cos from ElementaryFunction
--R
--R
--RExamples of cos from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of cos from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of cos from FourierComponent
--R
--R
--RExamples of cos from FortranExpression
--R
--R
--RExamples of cos from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of cos from StreamTranscendentalFunctions
--R
--R
--RExamples of cos from TrigonometricFunctionCategory
--R
--E 488

--S 489 of 3320
)d op cos2sec
--R 
--R
--RThere is one exposed function called cos2sec :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of cos2sec from TranscendentalManipulations
--R
--E 489

--S 490 of 3320
)d op cosh
--R 
--R
--RThere are 2 exposed functions called cosh :
--R   [1] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R   [2] D -> D from D if D has HYPCAT
--R
--RThere are 5 unexposed functions called cosh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of cosh from ElementaryFunction
--R
--R
--RExamples of cosh from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of cosh from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of cosh from FortranExpression
--R
--R
--RExamples of cosh from HyperbolicFunctionCategory
--R
--R
--RExamples of cosh from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of cosh from StreamTranscendentalFunctions
--R
--E 490

--S 491 of 3320
)d op cosh  
--R 
--R
--RThere are 2 exposed functions called cosh :
--R   [1] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R   [2] D -> D from D if D has HYPCAT
--R
--RThere are 5 unexposed functions called cosh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of cosh from ElementaryFunction
--R
--R
--RExamples of cosh from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of cosh from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of cosh from FortranExpression
--R
--R
--RExamples of cosh from HyperbolicFunctionCategory
--R
--R
--RExamples of cosh from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of cosh from StreamTranscendentalFunctions
--R
--E 491

--S 492 of 3320
)d op cosh2sech
--R 
--R
--RThere is one exposed function called cosh2sech :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of cosh2sech from TranscendentalManipulations
--R
--E 492

--S 493 of 3320
)d op coshIfCan
--R 
--R
--RThere is one exposed function called coshIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of coshIfCan from PartialTranscendentalFunctions
--R
--E 493

--S 494 of 3320
)d op cosIfCan
--R 
--R
--RThere is one exposed function called cosIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of cosIfCan from PartialTranscendentalFunctions
--R
--E 494

--S 495 of 3320
)d op cosSinInfo
--R 
--R
--RThere is one unexposed function called cosSinInfo :
--R   [1] Integer -> List(List(DoubleFloat)) from TubePlotTools
--R
--RExamples of cosSinInfo from TubePlotTools
--R
--E 495

--S 496 of 3320
)d op cot
--R 
--R
--RThere is one exposed function called cot :
--R   [1] D -> D from D if D has TRIGCAT
--R
--RThere are 5 unexposed functions called cot :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of cot from ElementaryFunction
--R
--R
--RExamples of cot from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of cot from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of cot from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of cot from StreamTranscendentalFunctions
--R
--R
--RExamples of cot from TrigonometricFunctionCategory
--R
--E 496

--S 497 of 3320
)d op cot2tan
--R 
--R
--RThere is one exposed function called cot2tan :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of cot2tan from TranscendentalManipulations
--R
--E 497

--S 498 of 3320
)d op cot2trig
--R 
--R
--RThere is one exposed function called cot2trig :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of cot2trig from TranscendentalManipulations
--R
--E 498

--S 499 of 3320
)d op coth
--R 
--R
--RThere is one exposed function called coth :
--R   [1] D -> D from D if D has HYPCAT
--R
--RThere are 5 unexposed functions called coth :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of coth from ElementaryFunction
--R
--R
--RExamples of coth from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of coth from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of coth from HyperbolicFunctionCategory
--R
--R
--RExamples of coth from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of coth from StreamTranscendentalFunctions
--R
--E 499

--S 500 of 3320
)d op coth  
--R 
--R
--RThere is one exposed function called coth :
--R   [1] D -> D from D if D has HYPCAT
--R
--RThere are 5 unexposed functions called coth :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of coth from ElementaryFunction
--R
--R
--RExamples of coth from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of coth from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of coth from HyperbolicFunctionCategory
--R
--R
--RExamples of coth from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of coth from StreamTranscendentalFunctions
--R
--E 500

--S 501 of 3320
)d op coth2tanh
--R 
--R
--RThere is one exposed function called coth2tanh :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of coth2tanh from TranscendentalManipulations
--R
--E 501

--S 502 of 3320
)d op coth2trigh
--R 
--R
--RThere is one exposed function called coth2trigh :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of coth2trigh from TranscendentalManipulations
--R
--E 502

--S 503 of 3320
)d op cothIfCan
--R 
--R
--RThere is one exposed function called cothIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of cothIfCan from PartialTranscendentalFunctions
--R
--E 503

--S 504 of 3320
)d op cotIfCan
--R 
--R
--RThere is one exposed function called cotIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of cotIfCan from PartialTranscendentalFunctions
--R
--E 504

--S 505 of 3320
)d op count
--R 
--R
--RThere are 12 exposed functions called count :
--R   [1] (D2,ArrayStack(D2)) -> NonNegativeInteger from ArrayStack(D2)
--R             if $ has finiteAggregate and D2 has SETCAT and D2 has 
--R            SETCAT
--R   [2] ((D3 -> Boolean),ArrayStack(D3)) -> NonNegativeInteger
--R             from ArrayStack(D3) if $ has finiteAggregate and D3 has 
--R            SETCAT
--R   [3] (D2,Dequeue(D2)) -> NonNegativeInteger from Dequeue(D2)
--R             if $ has finiteAggregate and D2 has SETCAT and D2 has 
--R            SETCAT
--R   [4] ((D3 -> Boolean),Dequeue(D3)) -> NonNegativeInteger from Dequeue
--R            (D3)
--R             if $ has finiteAggregate and D3 has SETCAT
--R   [5] (D2,Heap(D2)) -> NonNegativeInteger from Heap(D2)
--R             if $ has finiteAggregate and D2 has SETCAT and D2 has 
--R            ORDSET
--R   [6] ((D3 -> Boolean),Heap(D3)) -> NonNegativeInteger from Heap(D3)
--R             if $ has finiteAggregate and D3 has ORDSET
--R   [7] (D2,D) -> NonNegativeInteger from D
--R             if D has finiteAggregate and D has HOAGG(D2) and D2 has 
--R            TYPE and D2 has SETCAT
--R   [8] ((D3 -> Boolean),D) -> NonNegativeInteger from D
--R             if D has finiteAggregate and D has HOAGG(D3) and D3 has 
--R            TYPE
--R   [9] (D2,Queue(D2)) -> NonNegativeInteger from Queue(D2)
--R             if $ has finiteAggregate and D2 has SETCAT and D2 has 
--R            SETCAT
--R   [10] ((D3 -> Boolean),Queue(D3)) -> NonNegativeInteger from Queue(D3
--R            )
--R             if $ has finiteAggregate and D3 has SETCAT
--R   [11] (D2,Stack(D2)) -> NonNegativeInteger from Stack(D2)
--R             if $ has finiteAggregate and D2 has SETCAT and D2 has 
--R            SETCAT
--R   [12] ((D3 -> Boolean),Stack(D3)) -> NonNegativeInteger from Stack(D3
--R            )
--R             if $ has finiteAggregate and D3 has SETCAT
--R
--RExamples of count from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rcount(4,a)
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rcount(x+->(x>2),a)
--R
--R
--RExamples of count from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rcount(4,a)
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rcount(x+->(x>2),a)
--R
--R
--RExamples of count from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rcount(4,a)
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rcount(x+->(x>2),a)
--R
--R
--RExamples of count from HomogeneousAggregate
--R
--R
--RExamples of count from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rcount(4,a)
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rcount(x+->(x>2),a)
--R
--R
--RExamples of count from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rcount(4,a)
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rcount(x+->(x>2),a)
--R
--E 505

--S 506 of 3320 done
)d op countable?
--R 
--R
--RThere is one exposed function called countable? :
--R   [1] CardinalNumber -> Boolean from CardinalNumber
--R
--RExamples of countable? from CardinalNumber
--R
--Rc2:=2::CardinalNumber 
--Rcountable? c2 
--RA0:=Aleph 0 
--Rcountable? A0 
--RA1:=Aleph 1 
--Rcountable? A1
--R
--E 506

--S 507 of 3320
)d op countRealRoots
--R 
--R
--RThere is one exposed function called countRealRoots :
--R   [1] UnivariatePolynomial(D4,D3) -> Integer from SturmHabichtPackage(
--R            D3,D4)
--R             if D3 has OINTDOM and D4: SYMBOL
--R
--RExamples of countRealRoots from SturmHabichtPackage
--R
--E 507

--S 508 of 3320
)d op countRealRootsMultiple
--R 
--R
--RThere is one exposed function called countRealRootsMultiple :
--R   [1] UnivariatePolynomial(D4,D3) -> Integer from SturmHabichtPackage(
--R            D3,D4)
--R             if D3 has GCDDOM and D3 has OINTDOM and D4: SYMBOL
--R
--RExamples of countRealRootsMultiple from SturmHabichtPackage
--R
--E 508

--S 509 of 3320
)d op cPower
--R 
--R
--RThere is one unexposed function called cPower :
--R   [1] (InnerSparseUnivariatePowerSeries(D1),D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cPower from InnerSparseUnivariatePowerSeries
--R
--E 509

--S 510 of 3320
)d op cRationalPower
--R 
--R
--RThere is one unexposed function called cRationalPower :
--R   [1] (InnerSparseUnivariatePowerSeries(D2),Fraction(Integer)) -> 
--R            InnerSparseUnivariatePowerSeries(D2)
--R             from InnerSparseUnivariatePowerSeries(D2)
--R             if D2 has ALGEBRA(FRAC(INT)) and D2 has RING
--R
--RExamples of cRationalPower from InnerSparseUnivariatePowerSeries
--R
--E 510

--S 511 of 3320
)d op create
--R 
--R
--RThere are 4 exposed functions called create :
--R   [1] (D2,D3) -> D from D
--R             if D4 has FIELD and D6 has DIRPCAT(#(D5),NNI) and D7 has 
--R            LOCPOWC(D4) and D has INFCLCT(D4,D5,D3,D6,D2,D7,D8,D9,D1) 
--R            and D3 has POLYCAT(D4,D6,OVAR(D5)) and D2 has PRSPCAT(D4) 
--R            and D8 has PLACESC(D4,D7) and D1 has BLMETCT
--R   [2] (D7,DistributedMultivariatePolynomial([construct,QUOTEX,QUOTEY],
--R            D13),AffinePlane(D13),NonNegativeInteger,D11,NonNegativeInteger,
--R            DIVISOR,D13,Symbol) -> D
--R             from D
--R             if D13 has FIELD and D3 has DIRPCAT(#(D1),NNI) and D4 has 
--R            LOCPOWC(D13) and D has INFCLCT(D13,D1,D2,D3,D7,D4,D5,D6,D11
--R            ) and D2 has POLYCAT(D13,D3,OVAR(D1)) and D7 has PRSPCAT(
--R            D13) and D5 has PLACESC(D13,D4) and D11 has BLMETCT
--R   [3] Symbol -> D from D
--R             if D2 has FIELD and D has PLACESC(D2,D3) and D3 has 
--R            LOCPOWC(D2)
--R   [4] List(D2) -> D from D
--R             if D2 has FIELD and D has PLACESC(D2,D3) and D3 has 
--R            LOCPOWC(D2)
--R
--RThere is one unexposed function called create :
--R   [1]  -> SingletonAsOrderedSet from SingletonAsOrderedSet
--R
--RExamples of create from InfinitlyClosePointCategory
--R
--R
--RExamples of create from PlacesCategory
--R
--R
--RExamples of create from SingletonAsOrderedSet
--R
--E 511

--S 512 of 3320
)d op create3Space
--R 
--R
--RThere are 2 exposed functions called create3Space :
--R   [1] SubSpace(3,D2) -> D from D if D2 has RING and D has SPACEC(D2)
--R         
--R   [2]  -> D from D if D has SPACEC(D1) and D1 has RING
--R
--RExamples of create3Space from ThreeSpaceCategory
--R
--E 512

--S 513 of 3320
)d op createGenericMatrix
--R 
--R
--RThere is one exposed function called createGenericMatrix :
--R   [1] NonNegativeInteger -> Matrix(Polynomial(D3))
--R             from RepresentationPackage1(D3) if D3 has RING
--R
--RExamples of createGenericMatrix from RepresentationPackage1
--R
--E 513

--S 514 of 3320
)d op createHN
--R 
--R
--RThere is one exposed function called createHN :
--R   [1] (Integer,Integer,Integer,Integer,Integer,Boolean,Union(left,
--R            center,right,vertical,horizontal)) -> D
--R             from D if D has BLMETCT
--R
--RExamples of createHN from BlowUpMethodCategory
--R
--E 514

--S 515 of 3320
)d op createIrreduciblePoly
--R 
--R
--RThere is one unexposed function called createIrreduciblePoly :
--R   [1] PositiveInteger -> SparseUnivariatePolynomial(D3)
--R             from FiniteFieldPolynomialPackage(D3) if D3 has FFIELDC
--R         
--R
--RExamples of createIrreduciblePoly from FiniteFieldPolynomialPackage
--R
--E 515

--S 516 of 3320
)d op createLowComplexityNormalBasis
--R 
--R
--RThere is one unexposed function called createLowComplexityNormalBasis :
--R   [1] PositiveInteger -> Union(SparseUnivariatePolynomial(D3),Vector(
--R            List(Record(value: D3,index: SingleInteger))))
--R             from FiniteFieldFunctions(D3) if D3 has FFIELDC
--R
--RExamples of createLowComplexityNormalBasis from FiniteFieldFunctions
--R
--E 516

--S 517 of 3320
)d op createLowComplexityTable
--R 
--R
--RThere is one unexposed function called createLowComplexityTable :
--R   [1] PositiveInteger -> Union(Vector(List(Record(value: D3,index: 
--R            SingleInteger))),"failed")
--R             from FiniteFieldFunctions(D3) if D3 has FFIELDC
--R
--RExamples of createLowComplexityTable from FiniteFieldFunctions
--R
--E 517

--S 518 of 3320
)d op createMultiplicationMatrix
--R 
--R
--RThere is one unexposed function called createMultiplicationMatrix :
--R   [1] Vector(List(Record(value: D3,index: SingleInteger))) -> Matrix(
--R            D3)
--R             from FiniteFieldFunctions(D3) if D3 has FFIELDC
--R
--RExamples of createMultiplicationMatrix from FiniteFieldFunctions
--R
--E 518

--S 519 of 3320
)d op createMultiplicationTable
--R 
--R
--RThere is one unexposed function called createMultiplicationTable :
--R   [1] SparseUnivariatePolynomial(D3) -> Vector(List(Record(value: D3,
--R            index: SingleInteger)))
--R             from FiniteFieldFunctions(D3) if D3 has FFIELDC
--R
--RExamples of createMultiplicationTable from FiniteFieldFunctions
--R
--E 519

--S 520 of 3320
)d op createNormalElement
--R 
--R
--RThere is one exposed function called createNormalElement :
--R   [1]  -> D from D if D has FAXF(D1) and D1 has FINITE and D1 has 
--R            FIELD
--R
--RExamples of createNormalElement from FiniteAlgebraicExtensionField
--R
--E 520

--S 521 of 3320
)d op createNormalPoly
--R 
--R
--RThere is one unexposed function called createNormalPoly :
--R   [1] PositiveInteger -> SparseUnivariatePolynomial(D3)
--R             from FiniteFieldPolynomialPackage(D3) if D3 has FFIELDC
--R         
--R
--RExamples of createNormalPoly from FiniteFieldPolynomialPackage
--R
--E 521

--S 522 of 3320
)d op createNormalPrimitivePoly
--R 
--R
--RThere is one unexposed function called createNormalPrimitivePoly :
--R   [1] PositiveInteger -> SparseUnivariatePolynomial(D3)
--R             from FiniteFieldPolynomialPackage(D3) if D3 has FFIELDC
--R         
--R
--RExamples of createNormalPrimitivePoly from FiniteFieldPolynomialPackage
--R
--E 522

--S 523 of 3320
)d op createPrimitiveElement
--R 
--R
--RThere is one exposed function called createPrimitiveElement :
--R   [1]  -> D from D if D has FFIELDC
--R
--RExamples of createPrimitiveElement from FiniteFieldCategory
--R
--E 523

--S 524 of 3320
)d op createPrimitiveNormalPoly
--R 
--R
--RThere is one unexposed function called createPrimitiveNormalPoly :
--R   [1] PositiveInteger -> SparseUnivariatePolynomial(D3)
--R             from FiniteFieldPolynomialPackage(D3) if D3 has FFIELDC
--R         
--R
--RExamples of createPrimitiveNormalPoly from FiniteFieldPolynomialPackage
--R
--E 524

--S 525 of 3320
)d op createPrimitivePoly
--R 
--R
--RThere is one unexposed function called createPrimitivePoly :
--R   [1] PositiveInteger -> SparseUnivariatePolynomial(D3)
--R             from FiniteFieldPolynomialPackage(D3) if D3 has FFIELDC
--R         
--R
--RExamples of createPrimitivePoly from FiniteFieldPolynomialPackage
--R
--E 525

--S 526 of 3320
)d op createRandomElement
--R 
--R
--RThere is one exposed function called createRandomElement :
--R   [1] (List(Matrix(D3)),Matrix(D3)) -> Matrix(D3)
--R             from RepresentationPackage2(D3) if D3 has RING
--R
--RExamples of createRandomElement from RepresentationPackage2
--R
--E 526

--S 527 of 3320
)d op createThreeSpace
--R 
--R
--RThere is one exposed function called createThreeSpace :
--R   [1]  -> ThreeSpace(DoubleFloat) from TopLevelThreeSpace
--R
--RExamples of createThreeSpace from TopLevelThreeSpace
--R
--E 527

--S 528 of 3320
)d op createZechTable
--R 
--R
--RThere is one unexposed function called createZechTable :
--R   [1] SparseUnivariatePolynomial(D3) -> PrimitiveArray(SingleInteger)
--R             from FiniteFieldFunctions(D3) if D3 has FFIELDC
--R
--RExamples of createZechTable from FiniteFieldFunctions
--R
--E 528

--S 529 of 3320 done
)d op credits
--R 
--R
--RThere is one exposed function called credits :
--R   [1]  -> Void from ApplicationProgramInterface
--R
--RExamples of credits from ApplicationProgramInterface
--R
--Rcredits()
--R
--E 529

--S 530 of 3320
)d op credPol
--R 
--R
--RThere is one unexposed function called credPol :
--R   [1] (D1,List(D1)) -> D1 from GroebnerInternalPackage(D3,D4,D5,D1)
--R             if D1 has POLYCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R
--RExamples of credPol from GroebnerInternalPackage
--R
--E 530

--S 531 of 3320
)d op crest
--R 
--R
--RThere is one unexposed function called crest :
--R   [1] NonNegativeInteger -> (Stream(Polynomial(D3)) -> Stream(
--R            Polynomial(D3)))
--R             from WeierstrassPreparation(D3) if D3 has FIELD
--R
--RExamples of crest from WeierstrassPreparation
--R
--E 531

--S 532 of 3320
)d op critB
--R 
--R
--RThere is one unexposed function called critB :
--R   [1] (D2,D2,D2,D2) -> Boolean from GroebnerInternalPackage(D3,D2,D4,
--R            D5)
--R             if D3 has GCDDOM and D2 has OAMONS and D4 has ORDSET and 
--R            D5 has POLYCAT(D3,D2,D4)
--R
--RExamples of critB from GroebnerInternalPackage
--R
--E 532

--S 533 of 3320
)d op critBonD
--R 
--R
--RThere is one unexposed function called critBonD :
--R   [1] (D2,List(Record(lcmfij: D4,totdeg: NonNegativeInteger,poli: D2,
--R            polj: D2))) -> List(Record(lcmfij: D4,totdeg: NonNegativeInteger,
--R            poli: D2,polj: D2))
--R             from GroebnerInternalPackage(D3,D4,D5,D2)
--R             if D4 has OAMONS and D2 has POLYCAT(D3,D4,D5) and D3 has 
--R            GCDDOM and D5 has ORDSET
--R
--RExamples of critBonD from GroebnerInternalPackage
--R
--E 533

--S 534 of 3320
)d op critM
--R 
--R
--RThere is one unexposed function called critM :
--R   [1] (D2,D2) -> Boolean from GroebnerInternalPackage(D3,D2,D4,D5)
--R             if D3 has GCDDOM and D2 has OAMONS and D4 has ORDSET and 
--R            D5 has POLYCAT(D3,D2,D4)
--R
--RExamples of critM from GroebnerInternalPackage
--R
--E 534

--S 535 of 3320
)d op critMonD1
--R 
--R
--RThere is one unexposed function called critMonD1 :
--R   [1] (D2,List(Record(lcmfij: D2,totdeg: NonNegativeInteger,poli: D5,
--R            polj: D5))) -> List(Record(lcmfij: D2,totdeg: NonNegativeInteger,
--R            poli: D5,polj: D5))
--R             from GroebnerInternalPackage(D3,D2,D4,D5)
--R             if D2 has OAMONS and D5 has POLYCAT(D3,D2,D4) and D3 has 
--R            GCDDOM and D4 has ORDSET
--R
--RExamples of critMonD1 from GroebnerInternalPackage
--R
--E 535

--S 536 of 3320
)d op critMTonD1
--R 
--R
--RThere is one unexposed function called critMTonD1 :
--R   [1] List(Record(lcmfij: D3,totdeg: NonNegativeInteger,poli: D5,polj
--R            : D5)) -> List(Record(lcmfij: D3,totdeg: NonNegativeInteger,poli
--R            : D5,polj: D5))
--R             from GroebnerInternalPackage(D2,D3,D4,D5)
--R             if D3 has OAMONS and D5 has POLYCAT(D2,D3,D4) and D2 has 
--R            GCDDOM and D4 has ORDSET
--R
--RExamples of critMTonD1 from GroebnerInternalPackage
--R
--E 536

--S 537 of 3320
)d op critpOrder
--R 
--R
--RThere is one unexposed function called critpOrder :
--R   [1] (Record(lcmfij: D4,totdeg: NonNegativeInteger,poli: D6,polj: D6)
--R            ,Record(lcmfij: D4,totdeg: NonNegativeInteger,poli: D6,polj: D6))
--R             -> Boolean
--R             from GroebnerInternalPackage(D3,D4,D5,D6)
--R             if D4 has OAMONS and D6 has POLYCAT(D3,D4,D5) and D3 has 
--R            GCDDOM and D5 has ORDSET
--R
--RExamples of critpOrder from GroebnerInternalPackage
--R
--E 537

--S 538 of 3320
)d op critT
--R 
--R
--RThere is one unexposed function called critT :
--R   [1] Record(lcmfij: D4,totdeg: NonNegativeInteger,poli: D6,polj: D6)
--R             -> Boolean
--R             from GroebnerInternalPackage(D3,D4,D5,D6)
--R             if D4 has OAMONS and D6 has POLYCAT(D3,D4,D5) and D3 has 
--R            GCDDOM and D5 has ORDSET
--R
--RExamples of critT from GroebnerInternalPackage
--R
--E 538

--S 539 of 3320
)d op cross
--R 
--R
--RThere are 2 exposed functions called cross :
--R   [1] (D,D) -> D from D if D has PTCAT(D1) and D1 has RING
--R   [2] (D,D) -> D from D if D has VECTCAT(D1) and D1 has TYPE and D1
--R             has RING
--R
--RThere is one unexposed function called cross :
--R   [1] (Point(DoubleFloat),Point(DoubleFloat)) -> Point(DoubleFloat)
--R             from TubePlotTools
--R
--RExamples of cross from PointCategory
--R
--R
--RExamples of cross from TubePlotTools
--R
--R
--RExamples of cross from VectorCategory
--R
--E 539

--S 540 of 3320
)d op crushedSet
--R 
--R
--RThere is one unexposed function called crushedSet :
--R   [1] List(D5) -> List(D5) from PolynomialSetUtilitiesPackage(D2,D3,D4
--R            ,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has INTDOM and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RExamples of crushedSet from PolynomialSetUtilitiesPackage
--R
--E 540

--S 541 of 3320
)d op csc
--R 
--R
--RThere is one exposed function called csc :
--R   [1] D -> D from D if D has TRIGCAT
--R
--RThere are 5 unexposed functions called csc :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of csc from ElementaryFunction
--R
--R
--RExamples of csc from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of csc from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of csc from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of csc from StreamTranscendentalFunctions
--R
--R
--RExamples of csc from TrigonometricFunctionCategory
--R
--E 541

--S 542 of 3320
)d op csc2sin
--R 
--R
--RThere is one exposed function called csc2sin :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of csc2sin from TranscendentalManipulations
--R
--E 542

--S 543 of 3320
)d op csch
--R 
--R
--RThere is one exposed function called csch :
--R   [1] D -> D from D if D has HYPCAT
--R
--RThere are 5 unexposed functions called csch :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of csch from ElementaryFunction
--R
--R
--RExamples of csch from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of csch from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of csch from HyperbolicFunctionCategory
--R
--R
--RExamples of csch from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of csch from StreamTranscendentalFunctions
--R
--E 543

--S 544 of 3320
)d op csch2sinh
--R 
--R
--RThere is one exposed function called csch2sinh :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of csch2sinh from TranscendentalManipulations
--R
--E 544

--S 545 of 3320
)d op cschIfCan
--R 
--R
--RThere is one exposed function called cschIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of cschIfCan from PartialTranscendentalFunctions
--R
--E 545

--S 546 of 3320
)d op cscIfCan
--R 
--R
--RThere is one exposed function called cscIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of cscIfCan from PartialTranscendentalFunctions
--R
--E 546

--S 547 of 3320
)d op cSec
--R 
--R
--RThere is one unexposed function called cSec :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cSec from InnerSparseUnivariatePowerSeries
--R
--E 547

--S 548 of 3320
)d op cSech
--R 
--R
--RThere is one unexposed function called cSech :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cSech from InnerSparseUnivariatePowerSeries
--R
--E 548

--S 549 of 3320
)d op cSin
--R 
--R
--RThere is one unexposed function called cSin :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cSin from InnerSparseUnivariatePowerSeries
--R
--E 549

--S 550 of 3320
)d op cSinh
--R 
--R
--RThere is one unexposed function called cSinh :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cSinh from InnerSparseUnivariatePowerSeries
--R
--E 550

--S 551 of 3320
)d op csubst
--R 
--R
--RThere is one unexposed function called csubst :
--R   [1] (List(D5),List(Stream(D6))) -> (D6 -> Stream(D6))
--R             from SparseMultivariateTaylorSeries(D4,D5,D6)
--R             if D5 has ORDSET and D6 has POLYCAT(D4,INDE(D5),D5) and D4
--R             has RING
--R
--RExamples of csubst from SparseMultivariateTaylorSeries
--R
--E 551

--S 552 of 3320
)d op cTan
--R 
--R
--RThere is one unexposed function called cTan :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cTan from InnerSparseUnivariatePowerSeries
--R
--E 552

--S 553 of 3320
)d op cTanh
--R 
--R
--RThere is one unexposed function called cTanh :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R
--RExamples of cTanh from InnerSparseUnivariatePowerSeries
--R
--E 553

--S 554 of 3320
)d op cubic
--R 
--R
--RThere are 2 unexposed functions called cubic :
--R   [1] D3 -> List(D4) from PolynomialSolveByFormulas(D3,D4)
--R             if D4 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D3 has UPOLYC(D4)
--R            
--R   [2] (D3,D3,D3,D3) -> List(D3) from PolynomialSolveByFormulas(D4,D3)
--R             if D3 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D4 has UPOLYC(D3)
--R            
--R
--RExamples of cubic from PolynomialSolveByFormulas
--R
--E 554

--S 555 of 3320 done
)d op cubicBezier
--R 
--R
--RThere is one exposed function called cubicBezier :
--R   [1] (List(D3),List(D3),List(D3),List(D3)) -> (D3 -> List(D3)) from 
--R            Bezier(D3)
--R             if D3 has RING
--R
--RExamples of cubicBezier from Bezier
--R
--Rn:=cubicBezier([2.0,2.0],[2.0,4.0],[6.0,4.0],[6.0,2.0]) 
--R[n(t/10.0) for t in 0..10 by 1]
--R
--E 555

--S 556 of 3320
)d op cup
--R 
--R
--RThere is one exposed function called cup :
--R   [1] (SymmetricPolynomial(Fraction(Integer)),SymmetricPolynomial(
--R            Fraction(Integer))) -> SymmetricPolynomial(Fraction(Integer))
--R             from CycleIndicators
--R
--RExamples of cup from CycleIndicators
--R
--E 556

--S 557 of 3320
)d op currentSubProgram
--R 
--R
--RThere is one exposed function called currentSubProgram :
--R   [1]  -> Symbol from TheSymbolTable
--R
--RExamples of currentSubProgram from TheSymbolTable
--R
--E 557

--S 558 of 3320
)d op curry
--R 
--R
--RThere is one exposed function called curry :
--R   [1] ((D3 -> D4),D3) -> (() -> D4) from MappingPackage2(D3,D4)
--R             if D3 has SETCAT and D4 has SETCAT
--R
--RExamples of curry from MappingPackage2
--R
--E 558

--S 559 of 3320
)d op curryLeft
--R 
--R
--RThere is one exposed function called curryLeft :
--R   [1] (((D3,D4) -> D5),D3) -> (D4 -> D5) from MappingPackage3(D3,D4,D5
--R            )
--R             if D3 has SETCAT and D4 has SETCAT and D5 has SETCAT
--R
--RExamples of curryLeft from MappingPackage3
--R
--E 559

--S 560 of 3320
)d op curryRight
--R 
--R
--RThere is one exposed function called curryRight :
--R   [1] (((D4,D3) -> D5),D3) -> (D4 -> D5) from MappingPackage3(D4,D3,D5
--R            )
--R             if D4 has SETCAT and D3 has SETCAT and D5 has SETCAT
--R
--RExamples of curryRight from MappingPackage3
--R
--E 560

--S 561 of 3320
)d op curve
--R 
--R
--RThere are 6 exposed functions called curve :
--R   [1] (D1,D1) -> ParametricPlaneCurve(D1) from ParametricPlaneCurve(D1
--R            )
--R             if D1 has TYPE
--R   [2] (D1,D1,D1) -> ParametricSpaceCurve(D1) from ParametricSpaceCurve
--R            (D1)
--R             if D1 has TYPE
--R   [3] D -> List(Point(D2)) from D if D has SPACEC(D2) and D2 has RING
--R            
--R   [4] List(Point(D2)) -> D from D if D2 has RING and D has SPACEC(D2)
--R            
--R   [5] (D,List(List(D2))) -> D from D if D has SPACEC(D2) and D2 has 
--R            RING
--R   [6] (D,List(Point(D2))) -> D from D if D has SPACEC(D2) and D2 has 
--R            RING
--R
--RExamples of curve from ParametricPlaneCurve
--R
--R
--RExamples of curve from ParametricSpaceCurve
--R
--R
--RExamples of curve from ThreeSpaceCategory
--R
--E 561

--S 562 of 3320
)d op curve?
--R 
--R
--RThere is one exposed function called curve? :
--R   [1] D -> Boolean from D if D has SPACEC(D2) and D2 has RING
--R
--RExamples of curve? from ThreeSpaceCategory
--R
--E 562

--S 563 of 3320
)d op curveColor
--R 
--R
--RThere are 2 exposed functions called curveColor :
--R   [1] Palette -> DrawOption from DrawOption
--R   [2] Float -> DrawOption from DrawOption
--R
--RExamples of curveColor from DrawOption
--R
--E 563

--S 564 of 3320
)d op curveColorPalette
--R 
--R
--RThere is one unexposed function called curveColorPalette :
--R   [1] (List(DrawOption),Palette) -> Palette from DrawOptionFunctions0
--R            
--R
--RExamples of curveColorPalette from DrawOptionFunctions0
--R
--E 564

--S 565 of 3320
)d op curveV
--R 
--R
--RThere is one exposed function called curveV :
--R   [1] D -> DistributedMultivariatePolynomial([construct,QUOTEX,QUOTEY]
--R            ,D4)
--R             from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of curveV from InfinitlyClosePointCategory
--R
--E 565

--S 566 of 3320
)d op cycle
--R 
--R
--RThere is one exposed function called cycle :
--R   [1] List(D2) -> D from D if D2 has SETCAT and D has PERMCAT(D2)
--R
--RExamples of cycle from PermutationCategory
--R
--E 566

--S 567 of 3320 done
)d op cycleElt
--R 
--R
--RThere is one unexposed function called cycleElt :
--R   [1] D1 -> Union(D1,"failed") from CyclicStreamTools(D2,D1)
--R             if D2 has TYPE and D1 has LZSTAGG(D2)
--R
--RExamples of cycleElt from CyclicStreamTools
--R
--Rp:=repeating([1,2,3]) 
--Rq:=cons(4,p) 
--RcycleElt q 
--Rr:=[1,2,3]::Stream(Integer) 
--RcycleElt r
--R
--E 567

--S 568 of 3320 done
)d op cycleEntry
--R 
--R
--RThere is one exposed function called cycleEntry :
--R   [1] D -> D from D if D has URAGG(D1) and D1 has TYPE
--R
--RExamples of cycleEntry from UnaryRecursiveAggregate
--R
--Rt1:=[1,2,3] 
--Rt2:=concat!(t1,t1) 
--RcycleEntry t2
--R
--E 568

--S 569 of 3320 done
)d op cycleLength
--R 
--R
--RThere is one exposed function called cycleLength :
--R   [1] D -> NonNegativeInteger from D if D has URAGG(D2) and D2 has 
--R            TYPE
--R
--RExamples of cycleLength from UnaryRecursiveAggregate
--R
--Rt1:=[1,2,3] 
--Rt2:=concat!(t1,t1) 
--RcycleLength t2
--R
--E 569

--S 570 of 3320
)d op cyclePartition
--R 
--R
--RThere is one exposed function called cyclePartition :
--R   [1] Permutation(D2) -> Partition from Permutation(D2) if D2 has 
--R            SETCAT
--R
--RExamples of cyclePartition from Permutation
--R
--E 570

--S 571 of 3320
)d op cycleRagits
--R 
--R
--RThere is one exposed function called cycleRagits :
--R   [1] RadixExpansion(D2) -> List(Integer) from RadixExpansion(D2) if 
--R            D2: INT
--R
--RExamples of cycleRagits from RadixExpansion
--R
--E 571

--S 572 of 3320
)d op cycles
--R 
--R
--RThere is one exposed function called cycles :
--R   [1] List(List(D2)) -> D from D if D2 has SETCAT and D has PERMCAT(D2
--R            )
--R
--RExamples of cycles from PermutationCategory
--R
--E 572

--S 573 of 3320 done
)d op cycleSplit!
--R 
--R
--RThere is one exposed function called cycleSplit! :
--R   [1] D -> D from D if D has shallowlyMutable and D has URAGG(D1) and 
--R            D1 has TYPE
--R
--RExamples of cycleSplit! from UnaryRecursiveAggregate
--R
--Rt1:=[1,2,3] 
--Rt2:=concat!(t1,t1) 
--Rt3:=[1,2,3] 
--Rt4:=concat!(t3,t2) 
--Rt5:=cycleSplit!(t4) 
--Rt4 
--Rt5
--R
--E 573

--S 574 of 3320 done
)d op cycleTail
--R 
--R
--RThere is one exposed function called cycleTail :
--R   [1] D -> D from D if D has URAGG(D1) and D1 has TYPE
--R
--RExamples of cycleTail from UnaryRecursiveAggregate
--R
--Rt1:=[1,2,3] 
--Rt2:=concat!(t1,t1) 
--RcycleTail t2
--R
--E 574

--S 575 of 3320
)d op cyclic
--R 
--R
--RThere is one exposed function called cyclic :
--R   [1] Integer -> SymmetricPolynomial(Fraction(Integer)) from 
--R            CycleIndicators
--R
--RExamples of cyclic from CycleIndicators
--R
--E 575

--S 576 of 3320
)d op cyclic?
--R 
--R
--RThere are 2 exposed functions called cyclic? :
--R   [1] D -> Boolean from D if D has RCAGG(D2) and D2 has TYPE
--R   [2] Tree(D2) -> Boolean from Tree(D2) if D2 has SETCAT
--R
--RExamples of cyclic? from RecursiveAggregate
--R
--R
--RExamples of cyclic? from Tree
--R
--Rt1:=tree [1,2,3,4] 
--Rcyclic? t1
--R
--E 576

--S 577 of 3320 done
)d op cyclicCopy
--R 
--R
--RThere is one exposed function called cyclicCopy :
--R   [1] Tree(D1) -> Tree(D1) from Tree(D1) if D1 has SETCAT
--R
--RExamples of cyclicCopy from Tree
--R
--Rt1:=tree [1,2,3,4] 
--RcyclicCopy t1
--R
--E 577

--S 578 of 3320 done
)d op cyclicEntries
--R 
--R
--RThere is one exposed function called cyclicEntries :
--R   [1] Tree(D2) -> List(Tree(D2)) from Tree(D2) if D2 has SETCAT
--R
--RExamples of cyclicEntries from Tree
--R
--Rt1:=tree [1,2,3,4] 
--RcyclicEntries t1
--R
--E 578

--S 579 of 3320 done
)d op cyclicEqual?
--R 
--R
--RThere is one exposed function called cyclicEqual? :
--R   [1] (Tree(D2),Tree(D2)) -> Boolean from Tree(D2) if D2 has SETCAT
--R         
--R
--RExamples of cyclicEqual? from Tree
--R
--Rt1:=tree [1,2,3,4] 
--Rt2:=tree [1,2,3,4] 
--RcyclicEqual?(t1,t2)
--R
--E 579

--S 580 of 3320
)d op cyclicGroup
--R 
--R
--RThere are 2 exposed functions called cyclicGroup :
--R   [1] PositiveInteger -> PermutationGroup(Integer)
--R             from PermutationGroupExamples
--R   [2] List(Integer) -> PermutationGroup(Integer) from 
--R            PermutationGroupExamples
--R
--RExamples of cyclicGroup from PermutationGroupExamples
--R
--E 580

--S 581 of 3320 done
)d op cyclicParents
--R 
--R
--RThere is one exposed function called cyclicParents :
--R   [1] Tree(D2) -> List(Tree(D2)) from Tree(D2) if D2 has SETCAT
--R
--RExamples of cyclicParents from Tree
--R
--Rt1:=tree [1,2,3,4] 
--RcyclicParents t1
--R
--E 581

--S 582 of 3320
)d op cyclicSubmodule
--R 
--R
--RThere is one exposed function called cyclicSubmodule :
--R   [1] (List(Matrix(D4)),Vector(D4)) -> Vector(Vector(D4))
--R             from RepresentationPackage2(D4) if D4 has EUCDOM and D4
--R             has RING
--R
--RExamples of cyclicSubmodule from RepresentationPackage2
--R
--E 582

--S 583 of 3320
)d op cyclotomic
--R 
--R
--RThere is one exposed function called cyclotomic :
--R   [1] (NonNegativeInteger,D1) -> D1 from 
--R            NumberTheoreticPolynomialFunctions(D1)
--R             if D1 has COMRING
--R
--RThere are 2 unexposed functions called cyclotomic :
--R   [1] Integer -> SparseUnivariatePolynomial(Integer)
--R             from CyclotomicPolynomialPackage
--R   [2] Integer -> SparseUnivariatePolynomial(Integer)
--R             from PolynomialNumberTheoryFunctions
--R
--RExamples of cyclotomic from CyclotomicPolynomialPackage
--R
--R
--RExamples of cyclotomic from NumberTheoreticPolynomialFunctions
--R
--R
--RExamples of cyclotomic from PolynomialNumberTheoryFunctions
--R
--E 583

--S 584 of 3320
)d op cyclotomicDecomposition
--R 
--R
--RThere is one unexposed function called cyclotomicDecomposition :
--R   [1] Integer -> List(SparseUnivariatePolynomial(Integer))
--R             from CyclotomicPolynomialPackage
--R
--RExamples of cyclotomicDecomposition from CyclotomicPolynomialPackage
--R
--E 584

--S 585 of 3320
)d op cyclotomicFactorization
--R 
--R
--RThere is one unexposed function called cyclotomicFactorization :
--R   [1] Integer -> Factored(SparseUnivariatePolynomial(Integer))
--R             from CyclotomicPolynomialPackage
--R
--RExamples of cyclotomicFactorization from CyclotomicPolynomialPackage
--R
--E 585

--S 586 of 3320
)d op cylindrical
--R 
--R
--RThere is one exposed function called cylindrical :
--R   [1] Point(D2) -> Point(D2) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of cylindrical from CoordinateSystems
--R
--E 586

--S 587 of 3320
)d op cylindricalDecomposition
--R 
--R
--RThere are 2 exposed functions called cylindricalDecomposition :
--R   [1] List(Polynomial(D3)) -> List(Cell(D3))
--R             from CylindricalAlgebraicDecompositionPackage(D3) if D3
--R             has RCFIELD
--R   [2] (List(Polynomial(D4)),List(Symbol)) -> List(Cell(D4))
--R             from CylindricalAlgebraicDecompositionPackage(D4) if D4
--R             has RCFIELD
--R
--RExamples of cylindricalDecomposition from CylindricalAlgebraicDecompositionPackage
--R
--E 587

--S 588 of 3320
)d op d
--R 
--R
--RThere is one exposed function called d :
--R   [1] Symbol -> Union(BasicStochasticDifferential,Integer)
--R             from BasicStochasticDifferential
--R
--RExamples of d from BasicStochasticDifferential
--R
--E 588

--S 589 of 3320
)d op D
--R 
--R
--RThere are 11 exposed functions called D :
--R   [1] (D,(D3 -> D3),NonNegativeInteger) -> D from D
--R             if D has DIFEXT(D3) and D3 has RING
--R   [2] (D,(D2 -> D2)) -> D from D if D has DIFEXT(D2) and D2 has RING
--R         
--R   [3] (D,NonNegativeInteger) -> D from D if D has DIFRING
--R   [4] D -> D from D if D has DIFRING
--R   [5] (FullPartialFractionExpansion(D2,D3),NonNegativeInteger) -> 
--R            FullPartialFractionExpansion(D2,D3)
--R             from FullPartialFractionExpansion(D2,D3)
--R             if D2 has Join(Field,CharacteristicZero) and D3 has UPOLYC
--R            (D2)
--R   [6] FullPartialFractionExpansion(D1,D2) -> 
--R            FullPartialFractionExpansion(D1,D2)
--R             from FullPartialFractionExpansion(D1,D2)
--R             if D1 has Join(Field,CharacteristicZero) and D2 has UPOLYC
--R            (D1)
--R   [7]  -> D from D if D has LODOCAT(D1) and D1 has RING
--R   [8] (D,List(D3),List(NonNegativeInteger)) -> D from D
--R             if D has PDRING(D3) and D3 has SETCAT
--R   [9] (D,D1,NonNegativeInteger) -> D from D if D has PDRING(D1) and D1
--R             has SETCAT
--R   [10] (D,List(D2)) -> D from D if D has PDRING(D2) and D2 has SETCAT
--R            
--R   [11] (D,D1) -> D from D if D has PDRING(D1) and D1 has SETCAT
--R
--RExamples of D from DifferentialExtension
--R
--R
--RExamples of D from DifferentialRing
--R
--R
--RExamples of D from FullPartialFractionExpansion
--R
--R
--RExamples of D from LinearOrdinaryDifferentialOperatorCategory
--R
--R
--RExamples of D from PartialDifferentialRing
--R
--E 589

--S 590 of 3320
)d op d01ajf
--R 
--R
--RThere is one exposed function called d01ajf :
--R   [1] (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,Integer,Integer
--R            ,Integer,Union(fn: FileName,fp: Asp1(F))) -> Result
--R             from NagIntegrationPackage
--R
--RExamples of d01ajf from NagIntegrationPackage
--R
--E 590

--S 591 of 3320
)d op d01akf
--R 
--R
--RThere is one exposed function called d01akf :
--R   [1] (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,Integer,Integer
--R            ,Integer,Union(fn: FileName,fp: Asp1(F))) -> Result
--R             from NagIntegrationPackage
--R
--RExamples of d01akf from NagIntegrationPackage
--R
--E 591

--S 592 of 3320
)d op d01alf
--R 
--R
--RThere is one exposed function called d01alf :
--R   [1] (DoubleFloat,DoubleFloat,Integer,Matrix(DoubleFloat),DoubleFloat
--R            ,DoubleFloat,Integer,Integer,Integer,Union(fn: FileName,fp: Asp1(
--R            F))) -> Result
--R             from NagIntegrationPackage
--R
--RExamples of d01alf from NagIntegrationPackage
--R
--E 592

--S 593 of 3320
)d op d01amf
--R 
--R
--RThere is one exposed function called d01amf :
--R   [1] (DoubleFloat,Integer,DoubleFloat,DoubleFloat,Integer,Integer,
--R            Integer,Union(fn: FileName,fp: Asp1(F))) -> Result
--R             from NagIntegrationPackage
--R
--RExamples of d01amf from NagIntegrationPackage
--R
--E 593

--S 594 of 3320
)d op d01anf
--R 
--R
--RThere is one exposed function called d01anf :
--R   [1] (DoubleFloat,DoubleFloat,DoubleFloat,Integer,DoubleFloat,
--R            DoubleFloat,Integer,Integer,Integer,Union(fn: FileName,fp: Asp1(G
--R            ))) -> Result
--R             from NagIntegrationPackage
--R
--RExamples of d01anf from NagIntegrationPackage
--R
--E 594

--S 595 of 3320
)d op d01apf
--R 
--R
--RThere is one exposed function called d01apf :
--R   [1] (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,Integer,
--R            DoubleFloat,DoubleFloat,Integer,Integer,Integer,Union(fn: 
--R            FileName,fp: Asp1(G))) -> Result
--R             from NagIntegrationPackage
--R
--RExamples of d01apf from NagIntegrationPackage
--R
--E 595

--S 596 of 3320
)d op d01aqf
--R 
--R
--RThere is one exposed function called d01aqf :
--R   [1] (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,
--R            Integer,Integer,Integer,Union(fn: FileName,fp: Asp1(G))) -> 
--R            Result
--R             from NagIntegrationPackage
--R
--RExamples of d01aqf from NagIntegrationPackage
--R
--E 596

--S 597 of 3320
)d op d01asf
--R 
--R
--RThere is one exposed function called d01asf :
--R   [1] (DoubleFloat,DoubleFloat,Integer,DoubleFloat,Integer,Integer,
--R            Integer,Integer,Union(fn: FileName,fp: Asp1(G))) -> Result
--R             from NagIntegrationPackage
--R
--RExamples of d01asf from NagIntegrationPackage
--R
--E 597

--S 598 of 3320
)d op d01bbf
--R 
--R
--RThere is one exposed function called d01bbf :
--R   [1] (DoubleFloat,DoubleFloat,Integer,Integer,Integer,Integer) -> 
--R            Result
--R             from NagIntegrationPackage
--R
--RExamples of d01bbf from NagIntegrationPackage
--R
--E 598

--S 599 of 3320
)d op d01fcf
--R 
--R
--RThere is one exposed function called d01fcf :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Integer,
--R            DoubleFloat,Integer,Integer,Integer,Union(fn: FileName,fp: Asp4(
--R            FUNCTN))) -> Result
--R             from NagIntegrationPackage
--R
--RExamples of d01fcf from NagIntegrationPackage
--R
--E 599

--S 600 of 3320
)d op d01gaf
--R 
--R
--RThere is one exposed function called d01gaf :
--R   [1] (Matrix(DoubleFloat),Matrix(DoubleFloat),Integer,Integer) -> 
--R            Result
--R             from NagIntegrationPackage
--R
--RExamples of d01gaf from NagIntegrationPackage
--R
--E 600

--S 601 of 3320
)d op d01gbf
--R 
--R
--RThere is one exposed function called d01gbf :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Integer,
--R            DoubleFloat,Integer,Integer,Matrix(DoubleFloat),Integer,Union(fn
--R            : FileName,fp: Asp4(FUNCTN))) -> Result
--R             from NagIntegrationPackage
--R
--RExamples of d01gbf from NagIntegrationPackage
--R
--E 601

--S 602 of 3320
)d op d02bbf
--R 
--R
--RThere is one exposed function called d02bbf :
--R   [1] (DoubleFloat,Integer,Integer,Integer,DoubleFloat,Matrix(
--R            DoubleFloat),DoubleFloat,Integer,Union(fn: FileName,fp: Asp7(FCN)
--R            ),Union(fn: FileName,fp: Asp8(OUTPUT))) -> Result
--R             from NagOrdinaryDifferentialEquationsPackage
--R
--RExamples of d02bbf from NagOrdinaryDifferentialEquationsPackage
--R
--E 602

--S 603 of 3320
)d op d02bhf
--R 
--R
--RThere is one exposed function called d02bhf :
--R   [1] (DoubleFloat,Integer,Integer,DoubleFloat,DoubleFloat,Matrix(
--R            DoubleFloat),DoubleFloat,Integer,Union(fn: FileName,fp: Asp9(G)),
--R            Union(fn: FileName,fp: Asp7(FCN))) -> Result
--R             from NagOrdinaryDifferentialEquationsPackage
--R
--RExamples of d02bhf from NagOrdinaryDifferentialEquationsPackage
--R
--E 603

--S 604 of 3320
)d op d02cjf
--R 
--R
--RThere is one exposed function called d02cjf :
--R   [1] (DoubleFloat,Integer,Integer,DoubleFloat,String,DoubleFloat,
--R            Matrix(DoubleFloat),Integer,Union(fn: FileName,fp: Asp9(G)),Union
--R            (fn: FileName,fp: Asp7(FCN)),Union(fn: FileName,fp: Asp8(OUTPUT))
--R            ) -> Result
--R             from NagOrdinaryDifferentialEquationsPackage
--R
--RExamples of d02cjf from NagOrdinaryDifferentialEquationsPackage
--R
--E 604

--S 605 of 3320
)d op d02ejf
--R 
--R
--RThere is one exposed function called d02ejf :
--R   [1] (DoubleFloat,Integer,Integer,String,Integer,DoubleFloat,Matrix(
--R            DoubleFloat),DoubleFloat,Integer,Union(fn: FileName,fp: Asp9(G)),
--R            Union(fn: FileName,fp: Asp7(FCN)),Union(fn: FileName,fp: Asp31(
--R            PEDERV)),Union(fn: FileName,fp: Asp8(OUTPUT))) -> Result
--R             from NagOrdinaryDifferentialEquationsPackage
--R
--RExamples of d02ejf from NagOrdinaryDifferentialEquationsPackage
--R
--E 605

--S 606 of 3320
)d op d02gaf
--R 
--R
--RThere is one exposed function called d02gaf :
--R   [1] (Matrix(DoubleFloat),Matrix(DoubleFloat),Integer,DoubleFloat,
--R            DoubleFloat,DoubleFloat,Integer,Integer,Integer,Matrix(
--R            DoubleFloat),Integer,Integer,Union(fn: FileName,fp: Asp7(FCN)))
--R             -> Result
--R             from NagOrdinaryDifferentialEquationsPackage
--R
--RExamples of d02gaf from NagOrdinaryDifferentialEquationsPackage
--R
--E 606

--S 607 of 3320
)d op d02gbf
--R 
--R
--RThere is one exposed function called d02gbf :
--R   [1] (DoubleFloat,DoubleFloat,Integer,DoubleFloat,Integer,Integer,
--R            Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Matrix(DoubleFloat),Integer,Integer,Union(fn: 
--R            FileName,fp: Asp77(FCNF)),Union(fn: FileName,fp: Asp78(FCNG)))
--R             -> Result
--R             from NagOrdinaryDifferentialEquationsPackage
--R
--RExamples of d02gbf from NagOrdinaryDifferentialEquationsPackage
--R
--E 607

--S 608 of 3320
)d op d02kef
--R 
--R
--RThere are 2 exposed functions called d02kef :
--R   [1] (Matrix(DoubleFloat),Integer,Integer,DoubleFloat,Integer,Integer
--R            ,DoubleFloat,DoubleFloat,Matrix(DoubleFloat),Integer,Integer,
--R            Union(fn: FileName,fp: Asp10(COEFFN)),Union(fn: FileName,fp: 
--R            Asp80(BDYVAL))) -> Result
--R             from NagOrdinaryDifferentialEquationsPackage
--R   [2] (Matrix(DoubleFloat),Integer,Integer,DoubleFloat,Integer,Integer
--R            ,DoubleFloat,DoubleFloat,Matrix(DoubleFloat),Integer,Integer,
--R            Union(fn: FileName,fp: Asp10(COEFFN)),Union(fn: FileName,fp: 
--R            Asp80(BDYVAL)),FileName,FileName) -> Result
--R             from NagOrdinaryDifferentialEquationsPackage
--R
--RExamples of d02kef from NagOrdinaryDifferentialEquationsPackage
--R
--E 608

--S 609 of 3320
)d op d02raf
--R 
--R
--RThere is one exposed function called d02raf :
--R   [1] (Integer,Integer,Integer,Integer,DoubleFloat,Integer,Integer,
--R            Integer,Integer,Integer,Integer,Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),DoubleFloat,Integer,Union(fn: FileName,fp: Asp41(FCN
--R            ,JACOBF,JACEPS)),Union(fn: FileName,fp: Asp42(G,JACOBG,JACGEP)))
--R             -> Result
--R             from NagOrdinaryDifferentialEquationsPackage
--R
--RExamples of d02raf from NagOrdinaryDifferentialEquationsPackage
--R
--E 609

--S 610 of 3320
)d op d03edf
--R 
--R
--RThere is one exposed function called d03edf :
--R   [1] (Integer,Integer,Integer,Integer,DoubleFloat,Integer,Matrix(
--R            DoubleFloat),Matrix(DoubleFloat),Matrix(DoubleFloat),Integer) -> 
--R            Result
--R             from NagPartialDifferentialEquationsPackage
--R
--RExamples of d03edf from NagPartialDifferentialEquationsPackage
--R
--E 610

--S 611 of 3320
)d op d03eef
--R 
--R
--RThere is one exposed function called d03eef :
--R   [1] (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,Integer,Integer
--R            ,Integer,String,Integer,Union(fn: FileName,fp: Asp73(PDEF)),Union
--R            (fn: FileName,fp: Asp74(BNDY))) -> Result
--R             from NagPartialDifferentialEquationsPackage
--R
--RExamples of d03eef from NagPartialDifferentialEquationsPackage
--R
--E 611

--S 612 of 3320
)d op d03faf
--R 
--R
--RThere is one exposed function called d03faf :
--R   [1] (DoubleFloat,DoubleFloat,Integer,Integer,Matrix(DoubleFloat),
--R            Matrix(DoubleFloat),DoubleFloat,DoubleFloat,Integer,Integer,
--R            Matrix(DoubleFloat),Matrix(DoubleFloat),DoubleFloat,DoubleFloat,
--R            Integer,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),
--R            DoubleFloat,Integer,Integer,Integer,ThreeDimensionalMatrix(
--R            DoubleFloat),Integer) -> Result
--R             from NagPartialDifferentialEquationsPackage
--R
--RExamples of d03faf from NagPartialDifferentialEquationsPackage
--R
--E 612

--S 613 of 3320
)d op dAndcExp
--R 
--R
--RThere is one unexposed function called dAndcExp :
--R   [1] (Vector(D4),NonNegativeInteger,SingleInteger) -> Vector(D4)
--R             from InnerNormalBasisFieldFunctions(D4) if D4 has FFIELDC
--R            
--R
--RExamples of dAndcExp from InnerNormalBasisFieldFunctions
--R
--E 613

--S 614 of 3320
)d op dark
--R 
--R
--RThere is one exposed function called dark :
--R   [1] Color -> Palette from Palette
--R
--RExamples of dark from Palette
--R
--E 614

--S 615 of 3320
)d op datalist
--R 
--R
--RThere is one exposed function called datalist :
--R   [1] List(D2) -> DataList(D2) from DataList(D2) if D2 has ORDSET
--R
--RExamples of datalist from DataList
--R
--E 615

--S 616 of 3320
)d op ddFact
--R 
--R
--RThere is one exposed function called ddFact :
--R   [1] (D2,Integer) -> List(Record(factor: D2,degree: Integer))
--R             from ModularDistinctDegreeFactorizer(D2) if D2 has UPOLYC(
--R            INT)
--R
--RExamples of ddFact from ModularDistinctDegreeFactorizer
--R
--E 616

--S 617 of 3320
)d op debug
--R 
--R
--RThere is one exposed function called debug :
--R   [1] Boolean -> GuessOption from GuessOption
--R
--RThere are 2 unexposed functions called debug :
--R   [1] List(GuessOption) -> Boolean from GuessOptionFunctions0
--R   [2] Boolean -> Boolean from Plot
--R
--RExamples of debug from GuessOptionFunctions0
--R
--R
--RExamples of debug from GuessOption
--R
--R
--RExamples of debug from Plot
--R
--E 617

--S 618 of 3320
)d op debug3D
--R 
--R
--RThere is one unexposed function called debug3D :
--R   [1] Boolean -> Boolean from Plot3D
--R
--RExamples of debug3D from Plot3D
--R
--E 618

--S 619 of 3320
)d op dec
--R 
--R
--RThere is one exposed function called dec :
--R   [1] D -> D from D if D has INS
--R
--RExamples of dec from IntegerNumberSystem
--R
--E 619

--S 620 of 3320
)d op decimal
--R 
--R
--RThere is one exposed function called decimal :
--R   [1] Fraction(Integer) -> DecimalExpansion from DecimalExpansion
--R
--RExamples of decimal from DecimalExpansion
--R
--E 620

--S 621 of 3320
)d op declare
--R 
--R
--RThere is one unexposed function called declare :
--R   [1] List(InputForm) -> Symbol from InputForm
--R
--RExamples of declare from InputForm
--R
--E 621

--S 622 of 3320
)d op declare!
--R 
--R
--RThere are 6 exposed functions called declare! :
--R   [1] (Symbol,FortranType,Symbol) -> FortranType from TheSymbolTable
--R         
--R   [2] (Symbol,FortranType) -> FortranType from TheSymbolTable
--R   [3] (List(Symbol),FortranType,Symbol,TheSymbolTable) -> FortranType
--R             from TheSymbolTable
--R   [4] (Symbol,FortranType,Symbol,TheSymbolTable) -> FortranType
--R             from TheSymbolTable
--R   [5] (Symbol,FortranType,SymbolTable) -> FortranType from SymbolTable
--R            
--R   [6] (List(Symbol),FortranType,SymbolTable) -> FortranType from 
--R            SymbolTable
--R
--RExamples of declare! from TheSymbolTable
--R
--R
--RExamples of declare! from SymbolTable
--R
--E 622

--S 623 of 3320
)d op decompose
--R 
--R
--RThere are 7 exposed functions called decompose :
--R   [1] D -> Record(id: FractionalIdeal(D3,Fraction(D3),D4,D5),
--R            principalPart: D5)
--R             from D
--R             if D has FDIVCAT(D2,D3,D4,D5) and D2 has FIELD and D3 has 
--R            UPOLYC(D2) and D4 has UPOLYC(FRAC(D3)) and D5 has FFCAT(D2,
--R            D3,D4)
--R   [2] D2 -> List(D2) from PolynomialDecomposition(D2,D3)
--R             if D3 has FIELD and D2 has UPOLYC(D3)
--R   [3] (D2,NonNegativeInteger,NonNegativeInteger) -> Union(Record(left
--R            : D2,right: D2),"failed")
--R             from PolynomialDecomposition(D2,D4)
--R             if D4 has FIELD and D2 has UPOLYC(D4)
--R   [4] (List(D7),List(D8),Boolean,Boolean) -> List(D8)
--R             from RegularSetDecompositionPackage(D4,D5,D6,D7,D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has RSETCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R   [5] (List(D7),List(D8),Boolean,Boolean,Boolean,Boolean,Boolean) -> 
--R            List(D8)
--R             from RegularSetDecompositionPackage(D4,D5,D6,D7,D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has RSETCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R   [6] (List(D7),List(D8),Boolean,Boolean) -> List(D8)
--R             from SquareFreeRegularSetDecompositionPackage(D4,D5,D6,D7,
--R            D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has SFRTCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R   [7] (List(D7),List(D8),Boolean,Boolean,Boolean,Boolean,Boolean) -> 
--R            List(D8)
--R             from SquareFreeRegularSetDecompositionPackage(D4,D5,D6,D7,
--R            D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has SFRTCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R
--RThere is one unexposed function called decompose :
--R   [1] (Fraction(D5),(D5 -> D5)) -> Record(poly: D5,normal: Fraction(D5
--R            ),special: Fraction(D5))
--R             from MonomialExtensionTools(D4,D5) if D5 has UPOLYC(D4) 
--R            and D4 has FIELD
--R
--RExamples of decompose from FiniteDivisorCategory
--R
--R
--RExamples of decompose from MonomialExtensionTools
--R
--R
--RExamples of decompose from PolynomialDecomposition
--R
--R
--RExamples of decompose from RegularSetDecompositionPackage
--R
--R
--RExamples of decompose from SquareFreeRegularSetDecompositionPackage
--R
--E 623

--S 624 of 3320
)d op decompose
--R 
--R
--RThere are 7 exposed functions called decompose :
--R   [1] D -> Record(id: FractionalIdeal(D3,Fraction(D3),D4,D5),
--R            principalPart: D5)
--R             from D
--R             if D has FDIVCAT(D2,D3,D4,D5) and D2 has FIELD and D3 has 
--R            UPOLYC(D2) and D4 has UPOLYC(FRAC(D3)) and D5 has FFCAT(D2,
--R            D3,D4)
--R   [2] D2 -> List(D2) from PolynomialDecomposition(D2,D3)
--R             if D3 has FIELD and D2 has UPOLYC(D3)
--R   [3] (D2,NonNegativeInteger,NonNegativeInteger) -> Union(Record(left
--R            : D2,right: D2),"failed")
--R             from PolynomialDecomposition(D2,D4)
--R             if D4 has FIELD and D2 has UPOLYC(D4)
--R   [4] (List(D7),List(D8),Boolean,Boolean) -> List(D8)
--R             from RegularSetDecompositionPackage(D4,D5,D6,D7,D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has RSETCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R   [5] (List(D7),List(D8),Boolean,Boolean,Boolean,Boolean,Boolean) -> 
--R            List(D8)
--R             from RegularSetDecompositionPackage(D4,D5,D6,D7,D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has RSETCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R   [6] (List(D7),List(D8),Boolean,Boolean) -> List(D8)
--R             from SquareFreeRegularSetDecompositionPackage(D4,D5,D6,D7,
--R            D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has SFRTCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R   [7] (List(D7),List(D8),Boolean,Boolean,Boolean,Boolean,Boolean) -> 
--R            List(D8)
--R             from SquareFreeRegularSetDecompositionPackage(D4,D5,D6,D7,
--R            D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has SFRTCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R
--RThere is one unexposed function called decompose :
--R   [1] (Fraction(D5),(D5 -> D5)) -> Record(poly: D5,normal: Fraction(D5
--R            ),special: Fraction(D5))
--R             from MonomialExtensionTools(D4,D5) if D5 has UPOLYC(D4) 
--R            and D4 has FIELD
--R
--RExamples of decompose from FiniteDivisorCategory
--R
--R
--RExamples of decompose from MonomialExtensionTools
--R
--R
--RExamples of decompose from PolynomialDecomposition
--R
--R
--RExamples of decompose from RegularSetDecompositionPackage
--R
--R
--RExamples of decompose from SquareFreeRegularSetDecompositionPackage
--R
--E 624

--S 625 of 3320
)d op decomposeFunc
--R 
--R
--RThere is one unexposed function called decomposeFunc :
--R   [1] (Fraction(SparseUnivariatePolynomial(Expression(D2))),Fraction(
--R            SparseUnivariatePolynomial(Expression(D2))),Fraction(
--R            SparseUnivariatePolynomial(Expression(D2)))) -> Fraction(
--R            SparseUnivariatePolynomial(Expression(D2)))
--R             from TransSolvePackageService(D2)
--R             if D2 has Join(IntegralDomain,OrderedSet)
--R
--RExamples of decomposeFunc from TransSolvePackageService
--R
--E 625

--S 626 of 3320
)d op decrease
--R 
--R
--RThere are 2 exposed functions called decrease :
--R   [1] String -> Float from AttributeButtons
--R   [2] (String,String) -> Float from AttributeButtons
--R
--RExamples of decrease from AttributeButtons
--R
--E 626

--S 627 of 3320
)d op decreasePrecision
--R 
--R
--RThere is one exposed function called decreasePrecision :
--R   [1] Integer -> PositiveInteger from D if D has arbitraryPrecision 
--R            and D has FPS
--R
--RExamples of decreasePrecision from FloatingPointSystem
--R
--E 627

--S 628 of 3320
)d op deepCopy
--R 
--R
--RThere is one unexposed function called deepCopy :
--R   [1] SubSpace(D1,D2) -> SubSpace(D1,D2) from SubSpace(D1,D2)
--R             if D1: PI and D2 has RING
--R
--RExamples of deepCopy from SubSpace
--R
--E 628

--S 629 of 3320
)d op deepestInitial
--R 
--R
--RThere is one exposed function called deepestInitial :
--R   [1] D -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R
--RExamples of deepestInitial from RecursivePolynomialCategory
--R
--E 629

--S 630 of 3320
)d op deepestTail
--R 
--R
--RThere is one exposed function called deepestTail :
--R   [1] D -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R
--RExamples of deepestTail from RecursivePolynomialCategory
--R
--E 630

--S 631 of 3320
)d op deepExpand
--R 
--R
--RThere is one exposed function called deepExpand :
--R   [1] FreeNilpotentLie(D2,D3,D4) -> OutputForm from FreeNilpotentLie(
--R            D2,D3,D4)
--R             if D2: NNI and D3: NNI and D4 has COMRING
--R
--RExamples of deepExpand from FreeNilpotentLie
--R
--E 631

--S 632 of 3320
)d op defineProperty
--R 
--R
--RThere is one unexposed function called defineProperty :
--R   [1] (SubSpace(D3,D4),List(NonNegativeInteger),
--R            SubSpaceComponentProperty) -> SubSpace(D3,D4)
--R             from SubSpace(D3,D4) if D3: PI and D4 has RING
--R
--RExamples of defineProperty from SubSpace
--R
--E 632

--S 633 of 3320
)d op definingEquations
--R 
--R
--RThere is one unexposed function called definingEquations :
--R   [1] QuasiAlgebraicSet(D2,D3,D4,D5) -> List(D5)
--R             from QuasiAlgebraicSet(D2,D3,D4,D5)
--R             if D2 has GCDDOM and D3 has ORDSET and D4 has OAMONS and 
--R            D5 has POLYCAT(D2,D4,D3)
--R
--RExamples of definingEquations from QuasiAlgebraicSet
--R
--E 633

--S 634 of 3320
)d op definingField
--R 
--R
--RThere are 2 exposed functions called definingField :
--R   [1] D -> D1 from D if D has AFSPCAT(D1) and D1 has FIELD
--R   [2] D -> D1 from D if D has PRSPCAT(D1) and D1 has FIELD
--R
--RExamples of definingField from AffineSpaceCategory
--R
--R
--RExamples of definingField from ProjectiveSpaceCategory
--R
--E 634

--S 635 of 3320
)d op definingInequation
--R 
--R
--RThere is one unexposed function called definingInequation :
--R   [1] QuasiAlgebraicSet(D2,D3,D4,D1) -> D1 from QuasiAlgebraicSet(D2,
--R            D3,D4,D1)
--R             if D1 has POLYCAT(D2,D4,D3) and D2 has GCDDOM and D3 has 
--R            ORDSET and D4 has OAMONS
--R
--RExamples of definingInequation from QuasiAlgebraicSet
--R
--E 635

--S 636 of 3320
)d op definingPolynomial
--R 
--R
--RThere are 6 exposed functions called definingPolynomial :
--R   [1] D -> D from D if D has RING and D has ES
--R   [2]  -> SparseUnivariatePolynomial(D2) from D if D has FAXF(D2) and 
--R            D2 has FIELD
--R   [3]  -> D1 from D if D has MONOGEN(D2,D1) and D2 has COMRING and D1
--R             has UPOLYC(D2)
--R   [4] D -> SparseUnivariatePolynomial(D) from D if D has PACPERC
--R   [5]  -> SparseUnivariatePolynomial(D) from D if D has PACPERC
--R   [6] D -> D1 from D
--R             if D has RRCC(D2,D1) and D2 has Join(OrderedRing,Field) 
--R            and D1 has UPOLYC(D2)
--R
--RThere are 2 unexposed functions called definingPolynomial :
--R   [1] D1 -> D1 from AlgebraicFunction(D2,D1)
--R             if D2 has RETRACT(INT) and D2 has Join(OrderedSet,
--R            IntegralDomain) and D1 has FS(D2)
--R   [2]  -> SparseUnivariatePolynomial(D3) from ComplexCategory&(D2,D3)
--R             if D3 has COMRING and D2 has COMPCAT(D3)
--R
--RExamples of definingPolynomial from AlgebraicFunction
--R
--R
--RExamples of definingPolynomial from ComplexCategory&
--R
--R
--RExamples of definingPolynomial from Ring
--R
--R
--RExamples of definingPolynomial from FiniteAlgebraicExtensionField
--R
--R
--RExamples of definingPolynomial from MonogenicAlgebra
--R
--R
--RExamples of definingPolynomial from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--R
--RExamples of definingPolynomial from RealRootCharacterizationCategory
--R
--E 636

--S 637 of 3320
)d op degOneCoef
--R 
--R
--RThere is one exposed function called degOneCoef :
--R   [1] (D2,PositiveInteger) -> D1 from PackageForPoly(D1,D2,D4,D5)
--R             if D4 has DIRPCAT(D5,NNI) and D5: NNI and D1 has RING and 
--R            D2 has FAMR(D1,D4)
--R
--RExamples of degOneCoef from PackageForPoly
--R
--E 637

--S 638 of 3320
)d op degree
--R 
--R
--RThere are 22 exposed functions called degree :
--R   [1] D -> D1 from D if D has AMR(D2,D1) and D2 has RING and D1 has 
--R            OAMON
--R   [2] D -> Integer from D if D has DIVCAT(D2) and D2 has SETCAT
--R   [3] (D,D2) -> NonNegativeInteger from D
--R             if D has DPOLCAT(D3,D2,D4,D5) and D3 has RING and D2 has 
--R            ORDSET and D4 has DVARCAT(D2) and D5 has OAMONS
--R   [4] D -> PositiveInteger from D if D has FAXF(D2) and D2 has FIELD
--R         
--R   [5] D -> NonNegativeInteger from D
--R             if D has FLALG(D2,D3) and D2 has ORDSET and D3 has COMRING
--R            
--R   [6] D -> D1 from D if D has GRMOD(D2,D1) and D2 has COMRING and D1
--R             has ABELMON
--R   [7] D2 -> Integer from D if D has MAGCDOC(D2,D3) and D2 has TYPE and
--R            D3 has TYPE
--R   [8] D -> NonNegativeInteger from D if D has MLO(D2) and D2 has RING
--R            
--R   [9] D -> NonNegativeInteger from D if D has OREPCAT(D2) and D2 has 
--R            RING
--R   [10] PermutationGroup(D2) -> NonNegativeInteger from 
--R            PermutationGroup(D2)
--R             if D2 has SETCAT
--R   [11] Permutation(D2) -> NonNegativeInteger from Permutation(D2) if 
--R            D2 has SETCAT
--R   [12] (D2,Integer) -> NonNegativeInteger from PackageForPoly(D4,D2,D5
--R            ,D6)
--R             if D4 has RING and D5 has DIRPCAT(D6,NNI) and D6: NNI and 
--R            D2 has FAMR(D4,D5)
--R   [13] (D,List(D5)) -> List(NonNegativeInteger) from D
--R             if D has POLYCAT(D3,D4,D5) and D3 has RING and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [14] (D,D2) -> NonNegativeInteger from D
--R             if D has POLYCAT(D3,D4,D2) and D3 has RING and D4 has 
--R            OAMONS and D2 has ORDSET
--R   [15] U32Vector -> Integer from U32VectorPolynomialOperations
--R   [16] D -> D1 from D
--R             if D has PSCAT(D2,D1,D3) and D2 has RING and D3 has ORDSET
--R            and D1 has OAMON
--R   [17] D -> PositiveInteger from D if D has SETCATD
--R   [18] D -> NonNegativeInteger from D
--R             if D has TSETCAT(D2,D3,D4,D5) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R   [19] D -> Integer from D
--R             if D has ULSCCAT(D2,D3) and D2 has RING and D3 has UTSCAT(
--R            D2)
--R   [20] D -> Fraction(Integer) from D
--R             if D has UPXSCCA(D2,D3) and D2 has RING and D3 has ULSCAT(
--R            D2)
--R   [21] D -> OnePointCompletion(PositiveInteger) from D
--R             if D has XF(D2) and D2 has FIELD
--R   [22] D -> NonNegativeInteger from D
--R             if D has XPOLYC(D2,D3) and D2 has ORDSET and D3 has RING
--R         
--R
--RThere are 5 unexposed functions called degree :
--R   [1] AntiSymm(D2,D3) -> NonNegativeInteger from AntiSymm(D2,D3)
--R             if D2 has RING and D3: LIST(SYMBOL)
--R   [2] DeRhamComplex(D2,D3) -> NonNegativeInteger from DeRhamComplex(D2
--R            ,D3)
--R             if D2 has Join(Ring,OrderedSet) and D3: LIST(SYMBOL)
--R   [3] ExtAlgBasis -> NonNegativeInteger from ExtAlgBasis
--R   [4] (SparseUnivariatePolynomial(D7),List(D5)) -> List(
--R            NonNegativeInteger)
--R             from FactoringUtilities(D4,D5,D6,D7)
--R             if D5 has ORDSET and D7 has POLYCAT(D6,D4,D5) and D4 has 
--R            OAMONS and D6 has RING
--R   [5] LaurentPolynomial(D2,D3) -> Integer from LaurentPolynomial(D2,D3
--R            )
--R             if D2 has INTDOM and D3 has UPOLYC(D2)
--R
--RExamples of degree from AbelianMonoidRing
--R
--R
--RExamples of degree from AntiSymm
--R
--R
--RExamples of degree from DeRhamComplex
--R
--Rder := DeRhamComplex(Integer,[x,y,z]) 
--Rt1 := generator(1)$der 
--Rf:BOP:=operator('f) 
--Rg:BOP:=operator('g) 
--Rh:BOP:=operator('h) 
--Rsigma:der:=f(x,y,z)*dx + g(x,y,z)*dy + h(x,y,z)*dz 
--Ra:BOP:=operator('a) 
--Rb:BOP:=operator('b) 
--Rc:BOP:=operator('c) 
--Rtheta:der:=a(x,y,z)*dx*dy + b(x,y,z)*dx*dz + c(x,y,z)*dy*dz 
--R[degree x for x in [sigma,theta,t1]]
--R
--R
--RExamples of degree from DivisorCategory
--R
--R
--RExamples of degree from DifferentialPolynomialCategory
--R
--R
--RExamples of degree from ExtAlgBasis
--R
--R
--RExamples of degree from FactoringUtilities
--R
--R
--RExamples of degree from FiniteAlgebraicExtensionField
--R
--R
--RExamples of degree from FreeLieAlgebra
--R
--R
--RExamples of degree from GradedModule
--R
--R
--RExamples of degree from LaurentPolynomial
--R
--R
--RExamples of degree from ModularAlgebraicGcdOperations
--R
--R
--RExamples of degree from MonogenicLinearOperator
--R
--R
--RExamples of degree from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of degree from PermutationGroup
--R
--Ry : PERM INT := [[3,5,7,9]] 
--Rz : PERM INT := [1,3,11] 
--Rg : PERMGRP INT := [ y , z ] 
--Rdegree g
--R
--R
--RExamples of degree from Permutation
--R
--R
--RExamples of degree from PackageForPoly
--R
--R
--RExamples of degree from PolynomialCategory
--R
--R
--RExamples of degree from U32VectorPolynomialOperations
--R
--R
--RExamples of degree from PowerSeriesCategory
--R
--R
--RExamples of degree from SetCategoryWithDegree
--R
--R
--RExamples of degree from TriangularSetCategory
--R
--R
--RExamples of degree from UnivariateLaurentSeriesConstructorCategory
--R
--R
--RExamples of degree from UnivariatePuiseuxSeriesConstructorCategory
--R
--R
--RExamples of degree from ExtensionField
--R
--R
--RExamples of degree from XPolynomialsCat
--R
--E 638

--S 639 of 3320
)d op degreeOfMinimalForm
--R 
--R
--RThere is one exposed function called degreeOfMinimalForm :
--R   [1] D2 -> NonNegativeInteger from PackageForPoly(D3,D2,D4,D5)
--R             if D3 has RING and D4 has DIRPCAT(D5,NNI) and D5: NNI and 
--R            D2 has FAMR(D3,D4)
--R
--RExamples of degreeOfMinimalForm from PackageForPoly
--R
--E 639

--S 640 of 3320
)d op degreePartition
--R 
--R
--RThere are 2 unexposed functions called degreePartition :
--R   [1] List(Record(factor: D3,degree: Integer)) -> Multiset(
--R            NonNegativeInteger)
--R             from GaloisGroupFactorizer(D3) if D3 has UPOLYC(INT)
--R   [2] Factored(D4) -> Multiset(NonNegativeInteger)
--R             from GaloisGroupPolynomialUtilities(D3,D4)
--R             if D4 has UPOLYC(D3) and D3 has RING
--R
--RExamples of degreePartition from GaloisGroupFactorizer
--R
--R
--RExamples of degreePartition from GaloisGroupPolynomialUtilities
--R
--E 640

--S 641 of 3320
)d op degreeSubResultant
--R 
--R
--RThere is one unexposed function called degreeSubResultant :
--R   [1] (D1,D1,NonNegativeInteger) -> D1 from PseudoRemainderSequence(D3
--R            ,D1)
--R             if D3 has INTDOM and D1 has UPOLYC(D3)
--R
--RExamples of degreeSubResultant from PseudoRemainderSequence
--R
--E 641

--S 642 of 3320
)d op degreeSubResultantEuclidean
--R 
--R
--RThere is one unexposed function called degreeSubResultantEuclidean :
--R   [1] (D2,D2,NonNegativeInteger) -> Record(coef1: D2,coef2: D2,
--R            subResultant: D2)
--R             from PseudoRemainderSequence(D4,D2)
--R             if D4 has INTDOM and D2 has UPOLYC(D4)
--R
--RExamples of degreeSubResultantEuclidean from PseudoRemainderSequence
--R
--E 642

--S 643 of 3320
)d op delay
--R 
--R
--RThere are 2 exposed functions called delay :
--R   [1] (() -> D) -> D from D if D has LOCPOWC(D2) and D2 has FIELD
--R   [2] (() -> Stream(D2)) -> Stream(D2) from Stream(D2) if D2 has TYPE
--R            
--R
--RExamples of delay from LocalPowerSeriesCategory
--R
--R
--RExamples of delay from Stream
--R
--E 643

--S 644 of 3320
)d op delete
--R 
--R
--RThere are 2 exposed functions called delete :
--R   [1] (D,UniversalSegment(Integer)) -> D from D if D has LNAGG(D2) and
--R            D2 has TYPE
--R   [2] (D,Integer) -> D from D if D has LNAGG(D2) and D2 has TYPE
--R
--RExamples of delete from LinearAggregate
--R
--E 644

--S 645 of 3320 done
)d op delete!
--R 
--R
--RThere are 2 exposed functions called delete! :
--R   [1] (D,UniversalSegment(Integer)) -> D from D if D has ELAGG(D2) and
--R            D2 has TYPE
--R   [2] (D,Integer) -> D from D if D has ELAGG(D2) and D2 has TYPE
--R
--RExamples of delete! from ExtensibleLinearAggregate
--R
--RData:=Record(age:Integer,gender:String) 
--Ra1:AssociationList(String,Data):=table() 
--Ra1."tim":=[55,"male"]$Data 
--Rdelete!(a1,1)
--R
--E 645

--S 646 of 3320
)d op deleteProperty!
--R 
--R
--RThere is one exposed function called deleteProperty! :
--R   [1] (BasicOperator,String) -> BasicOperator from BasicOperator
--R
--RExamples of deleteProperty! from BasicOperator
--R
--E 646

--S 647 of 3320
)d op deleteRoutine!
--R 
--R
--RThere is one exposed function called deleteRoutine! :
--R   [1] (RoutinesTable,Symbol) -> RoutinesTable from RoutinesTable
--R
--RExamples of deleteRoutine! from RoutinesTable
--R
--E 647

--S 648 of 3320
)d op deleteRow!
--R 
--R
--RThere is one exposed function called deleteRow! :
--R   [1] (SparseEchelonMatrix(D3,D4),Integer) -> Void
--R             from SparseEchelonMatrix(D3,D4) if D3 has ORDSET and D4
--R             has RING
--R
--RExamples of deleteRow! from SparseEchelonMatrix
--R
--E 648

--S 649 of 3320
)d op delta
--R 
--R
--RThere is one unexposed function called delta :
--R   [1] (SetOfMIntegersInOneToN(D3,D4),PositiveInteger,PositiveInteger)
--R             -> NonNegativeInteger
--R             from SetOfMIntegersInOneToN(D3,D4) if D3: PI and D4: PI
--R         
--R
--RExamples of delta from SetOfMIntegersInOneToN
--R
--E 649

--S 650 of 3320
)d op denom
--R 
--R
--RThere are 3 exposed functions called denom :
--R   [1] AlgebraicNumber -> SparseMultivariatePolynomial(Integer,Kernel(
--R            AlgebraicNumber))
--R             from AlgebraicNumber
--R   [2] D -> SparseMultivariatePolynomial(D2,Kernel(D)) from D
--R             if D2 has INTDOM and D2 has ORDSET and D has FS(D2)
--R   [3] D -> D1 from D if D has QFCAT(D1) and D1 has INTDOM
--R
--RThere are 4 unexposed functions called denom :
--R   [1] FractionalIdeal(D1,D2,D3,D4) -> D1 from FractionalIdeal(D1,D2,D3
--R            ,D4)
--R             if D2 has QFCAT(D1) and D3 has UPOLYC(D2) and D1 has 
--R            EUCDOM and D4 has Join(FramedAlgebra(D2,D3),RetractableTo(
--R            D2))
--R   [2] InnerAlgebraicNumber -> SparseMultivariatePolynomial(Integer,
--R            Kernel(InnerAlgebraicNumber))
--R             from InnerAlgebraicNumber
--R   [3] LocalAlgebra(D2,D3,D1) -> D1 from LocalAlgebra(D2,D3,D1)
--R             if D3 has COMRING and D1 has SubsetCategory(Monoid,D3) and
--R            D2 has ALGEBRA(D3)
--R   [4] Localize(D2,D3,D1) -> D1 from Localize(D2,D3,D1)
--R             if D3 has COMRING and D1 has SubsetCategory(Monoid,D3) and
--R            D2 has MODULE(D3)
--R
--RExamples of denom from AlgebraicNumber
--R
--Rt1:=sqrt(3)/sqrt(5) 
--Rdenom t1
--R
--R
--RExamples of denom from FractionalIdeal
--R
--R
--RExamples of denom from FunctionSpace
--R
--R
--RExamples of denom from InnerAlgebraicNumber
--R
--R
--RExamples of denom from LocalAlgebra
--R
--R
--RExamples of denom from Localize
--R
--R
--RExamples of denom from QuotientFieldCategory
--R
--E 650

--S 651 of 3320
)d op denominator
--R 
--R
--RThere are 3 exposed functions called denominator :
--R   [1] D -> D from D if D has FS(D1) and D1 has ORDSET and D1 has 
--R            INTDOM
--R   [2] MyExpression(D1,D2) -> MyExpression(D1,D2) from MyExpression(D1,
--R            D2)
--R             if D1: SYMBOL and D2 has Join(Ring,OrderedSet,
--R            IntegralDomain)
--R   [3] D -> D from D if D has QFCAT(D1) and D1 has INTDOM
--R
--RExamples of denominator from FunctionSpace
--R
--R
--RExamples of denominator from MyExpression
--R
--R
--RExamples of denominator from QuotientFieldCategory
--R
--E 651

--S 652 of 3320
)d op denominators
--R 
--R
--RThere is one exposed function called denominators :
--R   [1] ContinuedFraction(D2) -> Stream(D2) from ContinuedFraction(D2)
--R             if D2 has EUCDOM
--R
--RExamples of denominators from ContinuedFraction
--R
--E 652

--S 653 of 3320
)d op denomLODE
--R 
--R
--RThere are 2 unexposed functions called denomLODE :
--R   [1] (D2,Fraction(D1)) -> Union(D1,"failed") from PrimitiveRatDE(D4,
--R            D1,D2,D5)
--R             if D1 has UPOLYC(D4) and D4 has Join(Field,
--R            CharacteristicZero,RetractableTo(Fraction(Integer))) and D2
--R             has LODOCAT(D1) and D5 has LODOCAT(FRAC(D1))
--R   [2] (D2,List(Fraction(D1))) -> D1 from PrimitiveRatDE(D4,D1,D2,D5)
--R             if D1 has UPOLYC(D4) and D4 has Join(Field,
--R            CharacteristicZero,RetractableTo(Fraction(Integer))) and D2
--R             has LODOCAT(D1) and D5 has LODOCAT(FRAC(D1))
--R
--RExamples of denomLODE from PrimitiveRatDE
--R
--E 653

--S 654 of 3320
)d op denomRicDE
--R 
--R
--RThere is one unexposed function called denomRicDE :
--R   [1] D2 -> D1 from PrimitiveRatRicDE(D3,D1,D2,D4)
--R             if D1 has UPOLYC(D3) and D3 has Join(Field,
--R            CharacteristicZero,RetractableTo(Fraction(Integer))) and D2
--R             has LODOCAT(D1) and D4 has LODOCAT(FRAC(D1))
--R
--RExamples of denomRicDE from PrimitiveRatRicDE
--R
--E 654

--S 655 of 3320
)d op depth
--R 
--R
--RThere are 4 exposed functions called depth :
--R   [1] ArrayStack(D2) -> NonNegativeInteger from ArrayStack(D2) if D2
--R             has SETCAT
--R   [2] Dequeue(D2) -> NonNegativeInteger from Dequeue(D2) if D2 has 
--R            SETCAT
--R   [3] D -> NonNegativeInteger from D if D has SKAGG(D2) and D2 has 
--R            TYPE
--R   [4] Stack(D2) -> NonNegativeInteger from Stack(D2) if D2 has SETCAT
--R            
--R
--RThere is one unexposed function called depth :
--R   [1] Pattern(D2) -> NonNegativeInteger from Pattern(D2) if D2 has 
--R            SETCAT
--R
--RExamples of depth from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rdepth a
--R
--R
--RExamples of depth from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rdepth a
--R
--R
--RExamples of depth from Pattern
--R
--R
--RExamples of depth from StackAggregate
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rdepth a
--R
--R
--RExamples of depth from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rdepth a
--R
--E 655

--S 656 of 3320
)d op dequeue
--R 
--R
--RThere are 4 exposed functions called dequeue :
--R   [1] List(D2) -> Dequeue(D2) from Dequeue(D2) if D2 has SETCAT
--R   [2]  -> Dequeue(D1) from Dequeue(D1) if D1 has SETCAT
--R   [3] List(D2) -> D from D if D2 has TYPE and D has DQAGG(D2)
--R   [4]  -> D from D if D has DQAGG(D1) and D1 has TYPE
--R
--RExamples of dequeue from Dequeue
--R
--Ra:Dequeue INT:= dequeue ()
--R
--Rg:Dequeue INT:= dequeue [1,2,3,4,5]
--R
--R
--RExamples of dequeue from DequeueAggregate
--R
--E 656

--S 657 of 3320
)d op dequeue!
--R 
--R
--RThere are 3 exposed functions called dequeue! :
--R   [1] Dequeue(D1) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [2] D -> D1 from D if D has QUAGG(D1) and D1 has TYPE
--R   [3] Queue(D1) -> D1 from Queue(D1) if D1 has SETCAT
--R
--RExamples of dequeue! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rdequeue! a 
--Ra
--R
--R
--RExamples of dequeue! from QueueAggregate
--R
--R
--RExamples of dequeue! from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rdequeue! a 
--Ra
--R
--E 657

--S 658 of 3320
)d op deref
--R 
--R
--RThere is one unexposed function called deref :
--R   [1] Reference(D1) -> D1 from Reference(D1) if D1 has TYPE
--R
--RExamples of deref from Reference
--R
--E 658

--S 659 of 3320
)d op deriv
--R 
--R
--RThere is one unexposed function called deriv :
--R   [1] Stream(D2) -> Stream(D2) from StreamTaylorSeriesOperations(D2)
--R             if D2 has RING
--R
--RExamples of deriv from StreamTaylorSeriesOperations
--R
--E 659

--S 660 of 3320
)d op derivationCoordinates
--R 
--R
--RThere is one exposed function called derivationCoordinates :
--R   [1] (Vector(D),(D4 -> D4)) -> Matrix(D4) from D
--R             if D4 has FIELD and D has MONOGEN(D4,D5) and D4 has 
--R            COMRING and D5 has UPOLYC(D4)
--R
--RExamples of derivationCoordinates from MonogenicAlgebra
--R
--E 660

--S 661 of 3320
)d op derivative
--R 
--R
--RThere are 3 exposed functions called derivative :
--R   [1] (BasicOperator,List((List(D3) -> D3))) -> BasicOperator
--R             from BasicOperatorFunctions1(D3) if D3 has SETCAT
--R   [2] (BasicOperator,(D3 -> D3)) -> BasicOperator
--R             from BasicOperatorFunctions1(D3) if D3 has SETCAT
--R   [3] BasicOperator -> Union(List((List(D3) -> D3)),"failed")
--R             from BasicOperatorFunctions1(D3) if D3 has SETCAT
--R
--RExamples of derivative from BasicOperatorFunctions1
--R
--E 661

--S 662 of 3320
)d op desingTree
--R 
--R
--RThere are 4 exposed functions called desingTree :
--R   [1] D6 -> List(D3)
--R             from DesingTreePackage(D7,D8,D6,D9,D10,D11,D12,D1,D2,D3,D4
--R            )
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D6 has POLYCAT(D7
--R            ,D9,OVAR(D8)) and D9 has DIRPCAT(#(D8),NNI) and D10 has 
--R            PRSPCAT(D7) and D11 has LOCPOWC(D7) and D12 has PLACESC(D7,
--R            D11) and D1 has DIVCAT(D12) and D2 has INFCLCT(D7,D8,D6,D9,
--R            D10,D11,D12,D1,D4) and D4 has BLMETCT and D3 has DSTRCAT(D2
--R            )
--R   [2]  -> List(D3)
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R             if D6 has FIELD and D7: LIST(SYMBOL) and D8 has POLYCAT(D6
--R            ,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI) and D10 has 
--R            PRSPCAT(D6) and D11 has LOCPOWC(D6) and D12 has PLACESC(D6,
--R            D11) and D1 has DIVCAT(D12) and D2 has INFCLCT(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D4) and D4 has BLMETCT and D3 has DSTRCAT(D2
--R            )
--R   [3]  -> List(DesingTree(
--R            InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField(D2,D3,
--R            D4)))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [4]  -> List(DesingTree(InfClsPt(D2,D3,D4)))
--R             from PackageForAlgebraicFunctionField(D2,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R
--RExamples of desingTree from DesingTreePackage
--R
--R
--RExamples of desingTree from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of desingTree from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of desingTree from PackageForAlgebraicFunctionField
--R
--E 662

--S 663 of 3320
)d op desingTreeAtPoint
--R 
--R
--RThere is one exposed function called desingTreeAtPoint :
--R   [1] (D5,D6) -> D4 from DesingTreePackage(D7,D8,D6,D9,D5,D10,D11,D1,
--R            D2,D4,D3)
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D6 has POLYCAT(D7
--R            ,D9,OVAR(D8)) and D9 has DIRPCAT(#(D8),NNI) and D5 has 
--R            PRSPCAT(D7) and D10 has LOCPOWC(D7) and D11 has PLACESC(D7,
--R            D10) and D1 has DIVCAT(D11) and D3 has BLMETCT and D4 has 
--R            DSTRCAT(D2) and D2 has INFCLCT(D7,D8,D6,D9,D5,D10,D11,D1,D3
--R            )
--R
--RExamples of desingTreeAtPoint from DesingTreePackage
--R
--E 663

--S 664 of 3320
)d op desingTreeWoFullParam
--R 
--R
--RThere are 3 exposed functions called desingTreeWoFullParam :
--R   [1]  -> List(D3)
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R             if D6 has FIELD and D7: LIST(SYMBOL) and D8 has POLYCAT(D6
--R            ,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI) and D10 has 
--R            PRSPCAT(D6) and D11 has LOCPOWC(D6) and D12 has PLACESC(D6,
--R            D11) and D1 has DIVCAT(D12) and D2 has INFCLCT(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D4) and D4 has BLMETCT and D3 has DSTRCAT(D2
--R            )
--R   [2]  -> List(DesingTree(
--R            InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField(D2,D3,
--R            D4)))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [3]  -> List(DesingTree(InfClsPt(D2,D3,D4)))
--R             from PackageForAlgebraicFunctionField(D2,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R
--RExamples of desingTreeWoFullParam from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of desingTreeWoFullParam from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of desingTreeWoFullParam from PackageForAlgebraicFunctionField
--R
--E 664

--S 665 of 3320
)d op destruct
--R 
--R
--RThere is one exposed function called destruct :
--R   [1] D -> List(D) from D
--R             if D2 has SETCAT and D3 has SETCAT and D4 has SETCAT and 
--R            D5 has SETCAT and D6 has SETCAT and D has SEXCAT(D2,D3,D4,
--R            D5,D6)
--R
--RThere is one unexposed function called destruct :
--R   [1] PatternMatchResult(D2,D3) -> List(Record(key: Symbol,entry: D3))
--R             from PatternMatchResult(D2,D3) if D2 has SETCAT and D3
--R             has SETCAT
--R
--RExamples of destruct from PatternMatchResult
--R
--R
--RExamples of destruct from SExpressionCategory
--R
--E 665

--S 666 of 3320
)d op determinant
--R 
--R
--RThere are 3 exposed functions called determinant :
--R   [1] D -> D1 from D
--R             if D has MATCAT(D1,D2,D3) and D2 has FLAGG(D1) and D3 has 
--R            FLAGG(D1) and D1 has commutative(*) and D1 has RING
--R   [2] D2 -> D1 from MatrixLinearAlgebraFunctions(D1,D3,D4,D2)
--R             if D3 has FLAGG(D1) and D4 has FLAGG(D1) and D1 has 
--R            COMRING and D2 has MATCAT(D1,D3,D4)
--R   [3] D -> D1 from D
--R             if D has SMATCAT(D2,D1,D3,D4) and D3 has DIRPCAT(D2,D1) 
--R            and D4 has DIRPCAT(D2,D1) and D1 has commutative(*) and D1
--R             has RING
--R
--RThere is one unexposed function called determinant :
--R   [1] D2 -> D1 from InnerMatrixLinearAlgebraFunctions(D1,D3,D4,D2)
--R             if D3 has FLAGG(D1) and D4 has FLAGG(D1) and D1 has FIELD 
--R            and D2 has MATCAT(D1,D3,D4)
--R
--RExamples of determinant from InnerMatrixLinearAlgebraFunctions
--R
--R
--RExamples of determinant from MatrixCategory
--R
--Rdeterminant matrix [[j**i for i in 0..4] for j in 1..5]
--R
--R
--RExamples of determinant from MatrixLinearAlgebraFunctions
--R
--R
--RExamples of determinant from SquareMatrixCategory
--R
--E 666

--S 667 of 3320
)d op df2ef
--R 
--R
--RThere is one exposed function called df2ef :
--R   [1] DoubleFloat -> Expression(Float) from ExpertSystemToolsPackage
--R         
--R
--RExamples of df2ef from ExpertSystemToolsPackage
--R
--E 667

--S 668 of 3320
)d op df2fi
--R 
--R
--RThere is one exposed function called df2fi :
--R   [1] DoubleFloat -> Fraction(Integer) from ExpertSystemToolsPackage
--R         
--R
--RExamples of df2fi from ExpertSystemToolsPackage
--R
--E 668

--S 669 of 3320
)d op df2mf
--R 
--R
--RThere is one exposed function called df2mf :
--R   [1] DoubleFloat -> MachineFloat from ExpertSystemToolsPackage
--R
--RExamples of df2mf from ExpertSystemToolsPackage
--R
--E 669

--S 670 of 3320
)d op df2st
--R 
--R
--RThere are 3 exposed functions called df2st :
--R   [1] DoubleFloat -> String from d01AgentsPackage
--R   [2] DoubleFloat -> String from ExpertSystemContinuityPackage
--R   [3] DoubleFloat -> String from ExpertSystemToolsPackage
--R
--RExamples of df2st from d01AgentsPackage
--R
--R
--RExamples of df2st from ExpertSystemContinuityPackage
--R
--R
--RExamples of df2st from ExpertSystemToolsPackage
--R
--E 670

--S 671 of 3320
)d op dflist
--R 
--R
--RThere is one exposed function called dflist :
--R   [1] List(Record(left: Fraction(Integer),right: Fraction(Integer)))
--R             -> List(DoubleFloat)
--R             from ExpertSystemToolsPackage
--R
--RExamples of dflist from ExpertSystemToolsPackage
--R
--E 671

--S 672 of 3320
)d op dfRange
--R 
--R
--RThere is one exposed function called dfRange :
--R   [1] Segment(OrderedCompletion(DoubleFloat)) -> Segment(
--R            OrderedCompletion(DoubleFloat))
--R             from ExpertSystemToolsPackage
--R
--RExamples of dfRange from ExpertSystemToolsPackage
--R
--E 672

--S 673 of 3320
)d op diag
--R 
--R
--RThere is one exposed function called diag :
--R   [1] ((D3,D3) -> D4) -> (D3 -> D4) from MappingPackage2(D3,D4)
--R             if D3 has SETCAT and D4 has SETCAT
--R
--RExamples of diag from MappingPackage2
--R
--E 673

--S 674 of 3320
)d op diagonal
--R 
--R
--RThere is one exposed function called diagonal :
--R   [1] D -> D1 from D
--R             if D has SMATCAT(D2,D3,D1,D4) and D3 has RING and D4 has 
--R            DIRPCAT(D2,D3) and D1 has DIRPCAT(D2,D3)
--R
--RExamples of diagonal from SquareMatrixCategory
--R
--E 674

--S 675 of 3320
)d op diagonal?
--R 
--R
--RThere are 2 exposed functions called diagonal? :
--R   [1] D -> Boolean from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [2] D -> Boolean from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of diagonal? from MatrixCategory
--R
--Rdiagonal? matrix [[j**i for i in 0..4] for j in 1..5]
--R
--R
--RExamples of diagonal? from RectangularMatrixCategory
--R
--E 675

--S 676 of 3320
)d op diagonalMatrix
--R 
--R
--RThere are 6 exposed functions called diagonalMatrix :
--R   [1] (D1,Integer) -> D1 from MatrixManipulation(D3,D4,D5,D1)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D1 has MATCAT(D3,D4,D5)
--R   [2] D1 -> D1 from MatrixManipulation(D2,D3,D4,D1)
--R             if D2 has FIELD and D3 has FLAGG(D2) and D4 has FLAGG(D2) 
--R            and D1 has MATCAT(D2,D3,D4)
--R   [3] List(D) -> D from D
--R             if D2 has RING and D has MATCAT(D2,D3,D4) and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [4] List(D2) -> D from D
--R             if D2 has RING and D has MATCAT(D2,D3,D4) and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [5] Vector(D2) -> Matrix(D2) from Matrix(D2) if D2 has RING
--R   [6] List(D3) -> D from D
--R             if D3 has RING and D has SMATCAT(D2,D3,D4,D5) and D4 has 
--R            DIRPCAT(D2,D3) and D5 has DIRPCAT(D2,D3)
--R
--RExamples of diagonalMatrix from MatrixManipulation
--R
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--RdiagonalMatrix(M)
--R
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--RdiagonalMatrix(M, 1) 
--RdiagonalMatrix(M, 2) 
--RdiagonalMatrix(M, -1)
--R
--R
--RExamples of diagonalMatrix from MatrixCategory
--R
--RdiagonalMatrix [matrix [[1,2],[3,4]], matrix [[4,5],[6,7]]]
--R
--RdiagonalMatrix [1,2,3]
--R
--R
--RExamples of diagonalMatrix from Matrix
--R
--R
--RExamples of diagonalMatrix from SquareMatrixCategory
--R
--E 676

--S 677 of 3320
)d op diagonalProduct
--R 
--R
--RThere is one exposed function called diagonalProduct :
--R   [1] D -> D1 from D
--R             if D has SMATCAT(D2,D1,D3,D4) and D3 has DIRPCAT(D2,D1) 
--R            and D4 has DIRPCAT(D2,D1) and D1 has RING
--R
--RThere is one unexposed function called diagonalProduct :
--R   [1] Matrix(D1) -> D1 from IntegralBasisTools(D1,D3,D4)
--R             if D3 has UPOLYC(D1) and D1 has EuclideanDomainwith
--R               squareFree : % -> Factored(%)and D4 has FRAMALG(D1,
--R            D3)
--R
--RExamples of diagonalProduct from IntegralBasisTools
--R
--R
--RExamples of diagonalProduct from SquareMatrixCategory
--R
--E 677

--S 678 of 3320
)d op diagonals
--R 
--R
--RThere is one exposed function called diagonals :
--R   [1] (ThreeDimensionalViewport,String) -> Void from 
--R            ThreeDimensionalViewport
--R
--RExamples of diagonals from ThreeDimensionalViewport
--R
--E 678

--S 679 of 3320
)d op dictionary
--R 
--R
--RThere are 2 exposed functions called dictionary :
--R   [1] List(D2) -> D from D if D2 has SETCAT and D has DIOPS(D2)
--R   [2]  -> D from D if D has DIOPS(D1) and D1 has SETCAT
--R
--RExamples of dictionary from DictionaryOperations
--R
--E 679

--S 680 of 3320
)d op diff
--R 
--R
--RThere is one unexposed function called diff :
--R   [1] Symbol -> (D4 -> D4) from ODEIntegration(D3,D4)
--R             if D3 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero) and D4 has Join(
--R            AlgebraicallyClosedFunctionSpace(D3),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory)
--R         
--R
--RExamples of diff from ODEIntegration
--R
--E 680

--S 681 of 3320
)d op DiffAction
--R 
--R
--RThere is one exposed function called DiffAction :
--R   [1] (NonNegativeInteger,NonNegativeInteger,D3) -> D1
--R             from FractionFreeFastGaussian(D1,D3)
--R             if D1 has Join(IntegralDomain,GcdDomain) and D3 has AMR(D1
--R            ,NNI)
--R
--RExamples of DiffAction from FractionFreeFastGaussian
--R
--E 681

--S 682 of 3320
)d op DiffC
--R 
--R
--RThere is one exposed function called DiffC :
--R   [1] NonNegativeInteger -> List(D3) from FractionFreeFastGaussian(D3,
--R            D4)
--R             if D3 has Join(IntegralDomain,GcdDomain) and D4 has AMR(D3
--R            ,NNI)
--R
--RExamples of DiffC from FractionFreeFastGaussian
--R
--E 682

--S 683 of 3320
)d op difference
--R 
--R
--RThere are 2 exposed functions called difference :
--R   [1] (D,D1) -> D from D if D has SETAGG(D1) and D1 has SETCAT
--R   [2] (D,D) -> D from D if D has SETAGG(D1) and D1 has SETCAT
--R
--RExamples of difference from SetAggregate
--R
--E 683

--S 684 of 3320
)d op differentialVariables
--R 
--R
--RThere is one exposed function called differentialVariables :
--R   [1] D -> List(D3) from D
--R             if D has DPOLCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            ORDSET and D4 has DVARCAT(D3) and D5 has OAMONS
--R
--RExamples of differentialVariables from DifferentialPolynomialCategory
--R
--E 684

--S 685 of 3320
)d op differentiate
--R 
--R
--RThere are 19 exposed functions called differentiate :
--R   [1] (D,(D3 -> D3),NonNegativeInteger) -> D from D
--R             if D has DIFEXT(D3) and D3 has RING
--R   [2] (D,(D2 -> D2)) -> D from D if D has DIFEXT(D2) and D2 has RING
--R         
--R   [3] (D,NonNegativeInteger) -> D from D if D has DIFRING
--R   [4] D -> D from D if D has DIFRING
--R   [5] (D,NonNegativeInteger) -> D from D if D has DVARCAT(D2) and D2
--R             has ORDSET
--R   [6] D -> D from D if D has DVARCAT(D1) and D1 has ORDSET
--R   [7] (D,(D3 -> D3)) -> D from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R   [8] (FullPartialFractionExpansion(D2,D3),NonNegativeInteger) -> 
--R            FullPartialFractionExpansion(D2,D3)
--R             from FullPartialFractionExpansion(D2,D3)
--R             if D2 has Join(Field,CharacteristicZero) and D3 has UPOLYC
--R            (D2)
--R   [9] FullPartialFractionExpansion(D1,D2) -> 
--R            FullPartialFractionExpansion(D1,D2)
--R             from FullPartialFractionExpansion(D1,D2)
--R             if D1 has Join(Field,CharacteristicZero) and D2 has UPOLYC
--R            (D1)
--R   [10] (GeneralUnivariatePowerSeries(D2,D3,D4),Variable(D3)) -> 
--R            GeneralUnivariatePowerSeries(D2,D3,D4)
--R             from GeneralUnivariatePowerSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has RING and D4: D2
--R   [11] (D,List(D3),List(NonNegativeInteger)) -> D from D
--R             if D has PDRING(D3) and D3 has SETCAT
--R   [12] (D,D1,NonNegativeInteger) -> D from D if D has PDRING(D1) and 
--R            D1 has SETCAT
--R   [13] (D,List(D2)) -> D from D if D has PDRING(D2) and D2 has SETCAT
--R            
--R   [14] (D,D1) -> D from D if D has PDRING(D1) and D1 has SETCAT
--R   [15] (U32Vector,Integer) -> U32Vector from 
--R            U32VectorPolynomialOperations
--R   [16] (U32Vector,NonNegativeInteger,Integer) -> U32Vector
--R             from U32VectorPolynomialOperations
--R   [17] (UnivariateFormalPowerSeries(D2),Variable(QUOTE(x))) -> 
--R            UnivariateFormalPowerSeries(D2)
--R             from UnivariateFormalPowerSeries(D2) if D2 has RING
--R   [18] (D,(D2 -> D2),D) -> D from D if D has UPOLYC(D2) and D2 has 
--R            RING
--R   [19] (UnivariateTaylorSeriesCZero(D2,D3),Variable(D3)) -> 
--R            UnivariateTaylorSeriesCZero(D2,D3)
--R             from UnivariateTaylorSeriesCZero(D2,D3) if D3: SYMBOL and 
--R            D2 has RING
--R
--RThere are 9 unexposed functions called differentiate :
--R   [1] (IntegrationResult(D1),Symbol) -> D1 from IntegrationResult(D1)
--R             if D1 has FIELD and D1 has PDRING(SYMBOL)
--R   [2] (IntegrationResult(D1),(D1 -> D1)) -> D1 from IntegrationResult(
--R            D1)
--R             if D1 has FIELD
--R   [3] (OutputForm,NonNegativeInteger) -> OutputForm from OutputForm
--R         
--R   [4] (SparseUnivariateLaurentSeries(D2,D3,D4),Variable(D3)) -> 
--R            SparseUnivariateLaurentSeries(D2,D3,D4)
--R             from SparseUnivariateLaurentSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has RING and D4: D2
--R   [5] (SparseUnivariatePuiseuxSeries(D2,D3,D4),Variable(D3)) -> 
--R            SparseUnivariatePuiseuxSeries(D2,D3,D4)
--R             from SparseUnivariatePuiseuxSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has RING and D4: D2
--R   [6] (SparseUnivariateTaylorSeries(D2,D3,D4),Variable(D3)) -> 
--R            SparseUnivariateTaylorSeries(D2,D3,D4)
--R             from SparseUnivariateTaylorSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has RING and D4: D2
--R   [7] (UnivariateLaurentSeries(D2,D3,D4),Variable(D3)) -> 
--R            UnivariateLaurentSeries(D2,D3,D4)
--R             from UnivariateLaurentSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has RING and D4: D2
--R   [8] (UnivariatePuiseuxSeries(D2,D3,D4),Variable(D3)) -> 
--R            UnivariatePuiseuxSeries(D2,D3,D4)
--R             from UnivariatePuiseuxSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has RING and D4: D2
--R   [9] (UnivariateTaylorSeries(D2,D3,D4),Variable(D3)) -> 
--R            UnivariateTaylorSeries(D2,D3,D4)
--R             from UnivariateTaylorSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has RING and D4: D2
--R
--RExamples of differentiate from DifferentialExtension
--R
--R
--RExamples of differentiate from DifferentialRing
--R
--R
--RExamples of differentiate from DifferentialVariableCategory
--R
--R
--RExamples of differentiate from FunctionFieldCategory
--R
--R
--RExamples of differentiate from FullPartialFractionExpansion
--R
--R
--RExamples of differentiate from GeneralUnivariatePowerSeries
--R
--R
--RExamples of differentiate from IntegrationResult
--R
--R
--RExamples of differentiate from OutputForm
--R
--R
--RExamples of differentiate from PartialDifferentialRing
--R
--R
--RExamples of differentiate from U32VectorPolynomialOperations
--R
--R
--RExamples of differentiate from SparseUnivariateLaurentSeries
--R
--R
--RExamples of differentiate from SparseUnivariatePuiseuxSeries
--R
--R
--RExamples of differentiate from SparseUnivariateTaylorSeries
--R
--R
--RExamples of differentiate from UnivariateFormalPowerSeries
--R
--R
--RExamples of differentiate from UnivariateLaurentSeries
--R
--R
--RExamples of differentiate from UnivariatePolynomialCategory
--R
--R
--RExamples of differentiate from UnivariatePuiseuxSeries
--R
--R
--RExamples of differentiate from UnivariateTaylorSeries
--R
--R
--RExamples of differentiate from UnivariateTaylorSeriesCZero
--R
--E 685

--S 686 of 3320
)d op diffHP
--R 
--R
--RThere are 12 exposed functions called diffHP :
--R   [1] List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(AlgebraicNumber) -> Stream(
--R            UnivariateFormalPowerSeries(AlgebraicNumber))),degreeStream: 
--R            Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(
--R            AlgebraicNumber)) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(AlgebraicNumber)))),exprStream: ((
--R            Expression(Integer),Symbol) -> Stream(Expression(Integer))),A: ((
--R            NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(
--R            AlgebraicNumber)) -> AlgebraicNumber),AF: ((NonNegativeInteger,
--R            NonNegativeInteger,UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(AlgebraicNumber))) -> 
--R            SparseUnivariatePolynomial(AlgebraicNumber)),AX: ((
--R            NonNegativeInteger,Symbol,Expression(Integer)) -> Expression(
--R            Integer)),C: (NonNegativeInteger -> List(AlgebraicNumber)))
--R             from GuessAlgebraicNumber
--R   [2] Symbol -> (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(AlgebraicNumber) -> Stream(
--R            UnivariateFormalPowerSeries(AlgebraicNumber))),degreeStream: 
--R            Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(
--R            AlgebraicNumber)) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(AlgebraicNumber)))),exprStream: ((
--R            Expression(Integer),Symbol) -> Stream(Expression(Integer))),A: ((
--R            NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(
--R            AlgebraicNumber)) -> AlgebraicNumber),AF: ((NonNegativeInteger,
--R            NonNegativeInteger,UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(AlgebraicNumber))) -> 
--R            SparseUnivariatePolynomial(AlgebraicNumber)),AX: ((
--R            NonNegativeInteger,Symbol,Expression(Integer)) -> Expression(
--R            Integer)),C: (NonNegativeInteger -> List(AlgebraicNumber))))
--R             from GuessAlgebraicNumber if AlgebraicNumber has RETRACT(
--R            SYMBOL)
--R   [3] List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(D3) -> Stream(
--R            UnivariateFormalPowerSeries(D3))),degreeStream: Stream(
--R            NonNegativeInteger),testStream: (UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D3)) -> Stream(
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(D3)))),
--R            exprStream: ((Expression(Integer),Symbol) -> Stream(Expression(
--R            Integer))),A: ((NonNegativeInteger,NonNegativeInteger,
--R            SparseUnivariatePolynomial(D3)) -> D3),AF: ((NonNegativeInteger,
--R            NonNegativeInteger,UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D3))) -> SparseUnivariatePolynomial(D3
--R            )),AX: ((NonNegativeInteger,Symbol,Expression(Integer)) -> 
--R            Expression(Integer)),C: (NonNegativeInteger -> List(D3)))
--R             from GuessFinite(D3)
--R             if D3 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [4] Symbol -> (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(D3) -> Stream(
--R            UnivariateFormalPowerSeries(D3))),degreeStream: Stream(
--R            NonNegativeInteger),testStream: (UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D3)) -> Stream(
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(D3)))),
--R            exprStream: ((Expression(Integer),Symbol) -> Stream(Expression(
--R            Integer))),A: ((NonNegativeInteger,NonNegativeInteger,
--R            SparseUnivariatePolynomial(D3)) -> D3),AF: ((NonNegativeInteger,
--R            NonNegativeInteger,UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D3))) -> SparseUnivariatePolynomial(D3
--R            )),AX: ((NonNegativeInteger,Symbol,Expression(Integer)) -> 
--R            Expression(Integer)),C: (NonNegativeInteger -> List(D3))))
--R             from GuessFinite(D3)
--R             if D3 has RETRACT(SYMBOL) and D3 has Join(
--R            FiniteFieldCategory,ConvertibleTo(Integer))
--R   [5] List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(Fraction(Integer)) -> Stream(
--R            UnivariateFormalPowerSeries(Fraction(Integer)))),degreeStream: 
--R            Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Integer))) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(Fraction(Integer))))),exprStream: ((
--R            Expression(Integer),Symbol) -> Stream(Expression(Integer))),A: ((
--R            NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(
--R            Integer)) -> Integer),AF: ((NonNegativeInteger,NonNegativeInteger
--R            ,UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Integer)))) -> SparseUnivariatePolynomial(Fraction(Integer))),AX
--R            : ((NonNegativeInteger,Symbol,Expression(Integer)) -> Expression(
--R            Integer)),C: (NonNegativeInteger -> List(Integer)))
--R             from GuessInteger
--R   [6] Symbol -> (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(Fraction(Integer)) -> Stream(
--R            UnivariateFormalPowerSeries(Fraction(Integer)))),degreeStream: 
--R            Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Integer))) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(Fraction(Integer))))),exprStream: ((
--R            Expression(Integer),Symbol) -> Stream(Expression(Integer))),A: ((
--R            NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(
--R            Integer)) -> Integer),AF: ((NonNegativeInteger,NonNegativeInteger
--R            ,UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Integer)))) -> SparseUnivariatePolynomial(Fraction(Integer))),AX
--R            : ((NonNegativeInteger,Symbol,Expression(Integer)) -> Expression(
--R            Integer)),C: (NonNegativeInteger -> List(Integer))))
--R             from GuessInteger
--R             if Fraction(Integer) has RETRACT(SYMBOL) and Integer has 
--R            RETRACT(SYMBOL)
--R   [7] List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(D4) -> Stream(
--R            UnivariateFormalPowerSeries(D4))),degreeStream: Stream(
--R            NonNegativeInteger),testStream: (UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D4)) -> Stream(
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(D4)))),
--R            exprStream: ((D6,Symbol) -> Stream(D6)),A: ((NonNegativeInteger,
--R            NonNegativeInteger,SparseUnivariatePolynomial(D5)) -> D5),AF: ((
--R            NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries
--R            (SparseUnivariatePolynomial(D4))) -> SparseUnivariatePolynomial(
--R            D4)),AX: ((NonNegativeInteger,Symbol,D6) -> D6),C: (
--R            NonNegativeInteger -> List(D5)))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D7 has Join(OrderedSet,IntegralDomain) and D8: (D7 -> 
--R            D4) and D4 has FIELD and D5 has GCDDOM and D6 has Join(
--R            FunctionSpace(Integer),IntegralDomain,RetractableTo(D7),
--R            RetractableTo(Symbol),RetractableTo(Integer),
--R            CombinatorialOpsCategory,PartialDifferentialRing(Symbol))
--R            with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Booleanand D9: (D4 -> D6)
--R   [8] Symbol -> (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(D4) -> Stream(
--R            UnivariateFormalPowerSeries(D4))),degreeStream: Stream(
--R            NonNegativeInteger),testStream: (UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D4)) -> Stream(
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(D4)))),
--R            exprStream: ((D6,Symbol) -> Stream(D6)),A: ((NonNegativeInteger,
--R            NonNegativeInteger,SparseUnivariatePolynomial(D5)) -> D5),AF: ((
--R            NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries
--R            (SparseUnivariatePolynomial(D4))) -> SparseUnivariatePolynomial(
--R            D4)),AX: ((NonNegativeInteger,Symbol,D6) -> D6),C: (
--R            NonNegativeInteger -> List(D5))))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D7 has Join(OrderedSet,IntegralDomain) and D8: (D7 -> 
--R            D4) and D4 has RETRACT(SYMBOL) and D5 has RETRACT(SYMBOL) 
--R            and D4 has FIELD and D5 has GCDDOM and D6 has Join(
--R            FunctionSpace(Integer),IntegralDomain,RetractableTo(D7),
--R            RetractableTo(Symbol),RetractableTo(Integer),
--R            CombinatorialOpsCategory,PartialDifferentialRing(Symbol))
--R            with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Booleanand D9: (D4 -> D6)
--R   [9] List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(Fraction(Polynomial(Integer))) -> 
--R            Stream(UnivariateFormalPowerSeries(Fraction(Polynomial(Integer)))
--R            )),degreeStream: Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer)))) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(Fraction(Polynomial(Integer)))))),
--R            exprStream: ((Expression(Integer),Symbol) -> Stream(Expression(
--R            Integer))),A: ((NonNegativeInteger,NonNegativeInteger,
--R            SparseUnivariatePolynomial(Polynomial(Integer))) -> Polynomial(
--R            Integer)),AF: ((NonNegativeInteger,NonNegativeInteger,
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer))))) -> SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer)))),AX: ((NonNegativeInteger,Symbol,Expression
--R            (Integer)) -> Expression(Integer)),C: (NonNegativeInteger -> List
--R            (Polynomial(Integer))))
--R             from GuessPolynomial
--R   [10] Symbol -> (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(Fraction(Polynomial(Integer))) -> 
--R            Stream(UnivariateFormalPowerSeries(Fraction(Polynomial(Integer)))
--R            )),degreeStream: Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer)))) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(Fraction(Polynomial(Integer)))))),
--R            exprStream: ((Expression(Integer),Symbol) -> Stream(Expression(
--R            Integer))),A: ((NonNegativeInteger,NonNegativeInteger,
--R            SparseUnivariatePolynomial(Polynomial(Integer))) -> Polynomial(
--R            Integer)),AF: ((NonNegativeInteger,NonNegativeInteger,
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer))))) -> SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer)))),AX: ((NonNegativeInteger,Symbol,Expression
--R            (Integer)) -> Expression(Integer)),C: (NonNegativeInteger -> List
--R            (Polynomial(Integer)))))
--R             from GuessPolynomial
--R             if Fraction(Polynomial(Integer)) has RETRACT(SYMBOL) and 
--R            Polynomial(Integer) has RETRACT(SYMBOL)
--R   [11] List(GuessOption) -> HPSPEC from GuessUnivariatePolynomial(D3)
--R             if D3: SYMBOL
--R   [12] Symbol -> (List(GuessOption) -> HPSPEC)
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R
--RExamples of diffHP from GuessAlgebraicNumber
--R
--R
--RExamples of diffHP from GuessFinite
--R
--R
--RExamples of diffHP from GuessInteger
--R
--R
--RExamples of diffHP from Guess
--R
--R
--RExamples of diffHP from GuessPolynomial
--R
--R
--RExamples of diffHP from GuessUnivariatePolynomial
--R
--E 686

--S 687 of 3320
)d op digamma
--R 
--R
--RThere are 3 exposed functions called digamma :
--R   [1] DoubleFloat -> DoubleFloat from DoubleFloatSpecialFunctions
--R   [2] Complex(DoubleFloat) -> Complex(DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R   [3] D -> D from D if D has SPFCAT
--R
--RThere is one unexposed function called digamma :
--R   [1] D1 -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of digamma from DoubleFloatSpecialFunctions
--R
--R
--RExamples of digamma from FunctionalSpecialFunction
--R
--R
--RExamples of digamma from SpecialFunctionCategory
--R
--E 687

--S 688 of 3320
)d op digit
--R 
--R
--RThere is one exposed function called digit :
--R   [1]  -> CharacterClass from CharacterClass
--R
--RExamples of digit from CharacterClass
--R
--E 688

--S 689 of 3320 done
)d op digit?
--R 
--R
--RThere is one exposed function called digit? :
--R   [1] Character -> Boolean from Character
--R
--RExamples of digit? from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[digit? c for c in chars]
--R
--E 689

--S 690 of 3320
)d op digits
--R 
--R
--RThere are 3 exposed functions called digits :
--R   [1] PositiveInteger -> PositiveInteger from D
--R             if D has arbitraryPrecision and D has FPS
--R   [2]  -> PositiveInteger from D if D has FPS
--R   [3] D -> Stream(Integer) from D if D has PADICCT(D2)
--R
--RThere are 2 unexposed functions called digits :
--R   [1] PositiveInteger -> PositiveInteger from FloatingPointSystem&(D2)
--R             if D2 has FPS
--R   [2]  -> PositiveInteger from FloatingPointSystem&(D2) if D2 has FPS
--R            
--R
--RExamples of digits from FloatingPointSystem&
--R
--R
--RExamples of digits from FloatingPointSystem
--R
--R
--RExamples of digits from PAdicIntegerCategory
--R
--E 690

--S 691 of 3320
)d op dihedral
--R 
--R
--RThere is one exposed function called dihedral :
--R   [1] Integer -> SymmetricPolynomial(Fraction(Integer)) from 
--R            CycleIndicators
--R
--RExamples of dihedral from CycleIndicators
--R
--E 691

--S 692 of 3320
)d op dihedralGroup
--R 
--R
--RThere are 2 exposed functions called dihedralGroup :
--R   [1] PositiveInteger -> PermutationGroup(Integer)
--R             from PermutationGroupExamples
--R   [2] List(Integer) -> PermutationGroup(Integer) from 
--R            PermutationGroupExamples
--R
--RExamples of dihedralGroup from PermutationGroupExamples
--R
--E 692

--S 693 of 3320
)d op dilog
--R 
--R
--RThere is one exposed function called dilog :
--R   [1] D -> D from D if D has LFCAT
--R
--RThere is one unexposed function called dilog :
--R   [1] D1 -> D1 from LiouvillianFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R
--RExamples of dilog from LiouvillianFunctionCategory
--R
--R
--RExamples of dilog from LiouvillianFunction
--R
--E 693

--S 694 of 3320
)d op dim
--R 
--R
--RThere is one exposed function called dim :
--R   [1] Color -> Palette from Palette
--R
--RThere is one unexposed function called dim :
--R   [1] DeRhamComplex(D2,D3) -> NonNegativeInteger from DeRhamComplex(D2
--R            ,D3)
--R             if D2 has Join(Ring,OrderedSet) and D3: LIST(SYMBOL)
--R
--RExamples of dim from DeRhamComplex
--R
--Rder := DeRhamComplex(Integer,[x,y,z]) 
--Rf:BOP:=operator('f) 
--Rg:BOP:=operator('g) 
--Rh:BOP:=operator('h) 
--Rsigma:der:=f(x,y,z)*dx + g(x,y,z)*dy + h(x,y,z)*dz 
--Rdim sigma
--R
--R
--RExamples of dim from Palette
--R
--E 694

--S 695 of 3320
)d op dimension
--R 
--R
--RThere are 6 exposed functions called dimension :
--R   [1] Cell(D2) -> NonNegativeInteger from Cell(D2) if D2 has RCFIELD
--R         
--R   [2]  -> NonNegativeInteger from FreeNilpotentLie(D2,D3,D4)
--R             if D2: NNI and D3: NNI and D4 has COMRING
--R   [3] PolynomialIdeals(D2,D3,D4,D5) -> Integer
--R             from PolynomialIdeals(D2,D3,D4,D5)
--R             if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D5
--R             has POLYCAT(D2,D3,D4)
--R   [4] (PolynomialIdeals(D3,D4,D5,D6),List(D5)) -> Integer
--R             from PolynomialIdeals(D3,D4,D5,D6)
--R             if D5 has ORDSET and D3 has FIELD and D4 has OAMONS and D6
--R             has POLYCAT(D3,D4,D5)
--R   [5] D -> PositiveInteger from D if D has PTCAT(D2) and D2 has RING
--R         
--R   [6]  -> CardinalNumber from D if D has VSPACE(D2) and D2 has FIELD
--R         
--R
--RThere are 2 unexposed functions called dimension :
--R   [1]  -> CardinalNumber from DirectProductCategory&(D2,D3,D4)
--R             if D3: NNI and D4 has TYPE and D2 has DIRPCAT(D3,D4)
--R   [2]  -> CardinalNumber from FiniteAlgebraicExtensionField&(D2,D3)
--R             if D3 has FIELD and D2 has FAXF(D3)
--R
--RExamples of dimension from Cell
--R
--R
--RExamples of dimension from DirectProductCategory&
--R
--R
--RExamples of dimension from FiniteAlgebraicExtensionField&
--R
--R
--RExamples of dimension from FreeNilpotentLie
--R
--R
--RExamples of dimension from PolynomialIdeals
--R
--R
--RExamples of dimension from PointCategory
--R
--R
--RExamples of dimension from VectorSpace
--R
--E 695

--S 696 of 3320
)d op dimensionOfIrreducibleRepresentation
--R 
--R
--RThere is one exposed function called dimensionOfIrreducibleRepresentation :
--R   [1] List(Integer) -> NonNegativeInteger from IrrRepSymNatPackage
--R
--RExamples of dimensionOfIrreducibleRepresentation from IrrRepSymNatPackage
--R
--E 696

--S 697 of 3320
)d op dimensions
--R 
--R
--RThere is one exposed function called dimensions :
--R   [1] (ThreeDimensionalViewport,NonNegativeInteger,NonNegativeInteger,
--R            PositiveInteger,PositiveInteger) -> Void
--R             from ThreeDimensionalViewport
--R
--RThere is one unexposed function called dimensions :
--R   [1] (TwoDimensionalViewport,NonNegativeInteger,NonNegativeInteger,
--R            PositiveInteger,PositiveInteger) -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of dimensions from TwoDimensionalViewport
--R
--R
--RExamples of dimensions from ThreeDimensionalViewport
--R
--E 697

--S 698 of 3320
)d op dimensionsOf
--R 
--R
--RThere are 3 exposed functions called dimensionsOf :
--R   [1] FortranType -> List(Polynomial(Integer)) from FortranType
--R   [2] (Symbol,Matrix(DoubleFloat)) -> SExpression from 
--R            NAGLinkSupportPackage
--R   [3] (Symbol,Matrix(Integer)) -> SExpression from 
--R            NAGLinkSupportPackage
--R
--RExamples of dimensionsOf from FortranType
--R
--R
--RExamples of dimensionsOf from NAGLinkSupportPackage
--R
--E 698

--S 699 of 3320
)d op diophantineSystem
--R 
--R
--RThere is one exposed function called diophantineSystem :
--R   [1] (D2,D3) -> Record(particular: Union(D3,"failed"),basis: List(D3)
--R            )
--R             from SmithNormalForm(D4,D5,D3,D2)
--R             if D4 has EUCDOM and D5 has FLAGG(D4) and D3 has FLAGG(D4)
--R            and D2 has MATCAT(D4,D5,D3)
--R
--RExamples of diophantineSystem from SmithNormalForm
--R
--E 699

--S 700 of 3320
)d op dioSolve
--R 
--R
--RThere is one exposed function called dioSolve :
--R   [1] Equation(Polynomial(Integer)) -> Record(varOrder: List(Symbol),
--R            inhom: Union(List(Vector(NonNegativeInteger)),"failed"),hom: List
--R            (Vector(NonNegativeInteger)))
--R             from DiophantineSolutionPackage
--R
--RExamples of dioSolve from DiophantineSolutionPackage
--R
--E 700

--S 701 of 3320
)d op direction
--R 
--R
--RThere is one unexposed function called direction :
--R   [1] String -> Integer from ToolsForSign(D3) if D3 has RING
--R
--RExamples of direction from ToolsForSign
--R
--E 701

--S 702 of 3320
)d op directory
--R 
--R
--RThere is one exposed function called directory :
--R   [1] D -> String from D if D has FNCAT
--R
--RExamples of directory from FileNameCategory
--R
--E 702

--S 703 of 3320
)d op directProduct
--R 
--R
--RThere is one exposed function called directProduct :
--R   [1] Vector(D3) -> D from D if D3 has TYPE and D has DIRPCAT(D2,D3)
--R         
--R
--RExamples of directProduct from DirectProductCategory
--R
--E 703

--S 704 of 3320
)d op directSum
--R 
--R
--RThere is one exposed function called directSum :
--R   [1] (D,D) -> D from D if D has LODOCAT(D1) and D1 has RING and D1
--R             has FIELD
--R
--RThere is one unexposed function called directSum :
--R   [1] (D1,D1,(D3 -> D3)) -> D1
--R             from LinearOrdinaryDifferentialOperatorsOps(D3,D1)
--R             if D3 has FIELD and D1 has LODOCAT(D3)
--R
--RExamples of directSum from LinearOrdinaryDifferentialOperatorCategory
--R
--R
--RExamples of directSum from LinearOrdinaryDifferentialOperatorsOps
--R
--E 704

--S 705 of 3320
)d op discreteLog
--R 
--R
--RThere are 2 exposed functions called discreteLog :
--R   [1] D -> NonNegativeInteger from D if D has FFIELDC
--R   [2] (D,D) -> Union(NonNegativeInteger,"failed") from D if D has FPC
--R            
--R
--RExamples of discreteLog from FiniteFieldCategory
--R
--R
--RExamples of discreteLog from FieldOfPrimeCharacteristic
--R
--E 705

--S 706 of 3320
)d op discriminant
--R 
--R
--RThere are 4 exposed functions called discriminant :
--R   [1] Vector(D) -> D1 from D
--R             if D has FINRALG(D1,D3) and D3 has UPOLYC(D1) and D1 has 
--R            COMRING
--R   [2]  -> D1 from D if D has FRAMALG(D1,D2) and D2 has UPOLYC(D1) and 
--R            D1 has COMRING
--R   [3] (D,D1) -> D from D
--R             if D has POLYCAT(D2,D3,D1) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET and D2 has COMRING
--R   [4] D -> D1 from D if D has UPOLYC(D1) and D1 has RING and D1 has 
--R            COMRING
--R
--RThere are 4 unexposed functions called discriminant :
--R   [1]  -> D1 from ComplexCategory&(D2,D1) if D1 has COMRING and D2
--R             has COMPCAT(D1)
--R   [2]  -> D1 from FramedAlgebra&(D2,D1,D3)
--R             if D3 has UPOLYC(D1) and D1 has COMRING and D2 has FRAMALG
--R            (D1,D3)
--R   [3]  -> Integer from NumberFieldIntegralBasis(D2,D3)
--R             if D2 has UPOLYC(INT) and D3 has FRAMALG(INT,D2)
--R   [4] D2 -> D1 from PseudoRemainderSequence(D1,D2)
--R             if D1 has INTDOM and D2 has UPOLYC(D1)
--R
--RExamples of discriminant from ComplexCategory&
--R
--R
--RExamples of discriminant from FiniteRankAlgebra
--R
--R
--RExamples of discriminant from FramedAlgebra&
--R
--R
--RExamples of discriminant from FramedAlgebra
--R
--R
--RExamples of discriminant from NumberFieldIntegralBasis
--R
--R
--RExamples of discriminant from PolynomialCategory
--R
--R
--RExamples of discriminant from PseudoRemainderSequence
--R
--R
--RExamples of discriminant from UnivariatePolynomialCategory
--R
--E 706

--S 707 of 3320
)d op discriminantEuclidean
--R 
--R
--RThere is one unexposed function called discriminantEuclidean :
--R   [1] D2 -> Record(coef1: D2,coef2: D2,discriminant: D3)
--R             from PseudoRemainderSequence(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of discriminantEuclidean from PseudoRemainderSequence
--R
--E 707

--S 708 of 3320
)d op discriminantSet
--R 
--R
--RThere is one exposed function called discriminantSet :
--R   [1] List(SparseUnivariatePolynomial(Polynomial(D3))) -> List(
--R            Polynomial(D3))
--R             from CylindricalAlgebraicDecompositionPackage(D3) if D3
--R             has RCFIELD
--R
--RExamples of discriminantSet from CylindricalAlgebraicDecompositionPackage
--R
--E 708

--S 709 of 3320
)d op display
--R 
--R
--RThere are 11 exposed functions called display :
--R   [1] (BasicOperator,(OutputForm -> OutputForm)) -> BasicOperator
--R             from BasicOperator
--R   [2] (BasicOperator,(List(OutputForm) -> OutputForm)) -> 
--R            BasicOperator
--R             from BasicOperator
--R   [3] BasicOperator -> Union((List(OutputForm) -> OutputForm),"failed"
--R            )
--R             from BasicOperator
--R   [4] Database(D2) -> Void from Database(D2)
--R             if D2 has OrderedSetwith
--R               ?.? : (%,Symbol) -> String
--R               display : % -> Void
--R               fullDisplay : % -> Void
--R   [5] ScriptFormulaFormat -> Void from ScriptFormulaFormat
--R   [6] (ScriptFormulaFormat,Integer) -> Void from ScriptFormulaFormat
--R         
--R   [7] String -> Void from HTMLFormat
--R   [8] IndexCard -> Void from IndexCard
--R   [9] String -> Void from MathMLFormat
--R   [10] TexFormat -> Void from TexFormat
--R   [11] (TexFormat,Integer) -> Void from TexFormat
--R
--RExamples of display from BasicOperator
--R
--R
--RExamples of display from Database
--R
--R
--RExamples of display from ScriptFormulaFormat
--R
--R
--RExamples of display from HTMLFormat
--R
--Rdisplay(coerce(sqrt(3+x)::OutputForm)$HTMLFORM)$HTMLFORM
--R
--R
--RExamples of display from IndexCard
--R
--R
--RExamples of display from MathMLFormat
--R
--R
--RExamples of display from TexFormat
--R
--E 709

--S 710 of 3320
)d op displayAsGF
--R 
--R
--RThere is one unexposed function called displayAsGF :
--R   [1] List(GuessOption) -> Boolean from GuessOptionFunctions0
--R
--RExamples of displayAsGF from GuessOptionFunctions0
--R
--E 710

--S 711 of 3320
)d op displayKind
--R 
--R
--RThere is one exposed function called displayKind :
--R   [1] Symbol -> GuessOption from GuessOption
--R
--RExamples of displayKind from GuessOption
--R
--E 711

--S 712 of 3320
)d op distance
--R 
--R
--RThere is one exposed function called distance :
--R   [1] (D,D) -> Integer from D if D has RCAGG(D2) and D2 has TYPE
--R
--RExamples of distance from RecursiveAggregate
--R
--E 712

--S 713 of 3320
)d op distdfact
--R 
--R
--RThere is one exposed function called distdfact :
--R   [1] (D2,Boolean) -> Record(cont: D4,factors: List(Record(irr: D2,pow
--R            : Integer)))
--R             from DistinctDegreeFactorize(D4,D2)
--R             if D4 has FFIELDC and D2 has UPOLYC(D4)
--R
--RExamples of distdfact from DistinctDegreeFactorize
--R
--E 713

--S 714 of 3320
)d op distFact
--R 
--R
--RThere is one unexposed function called distFact :
--R   [1] (D3,List(SparseUnivariatePolynomial(D3)),Record(contp: D3,
--R            factors: List(Record(irr: D1,pow: Integer))),List(D3),List(D8),
--R            List(D3)) -> Union(Record(polfac: List(D1),correct: D3,corrfact: 
--R            List(SparseUnivariatePolynomial(D3))),"failed")
--R             from LeadingCoefDetermination(D8,D9,D3,D1)
--R             if D8 has ORDSET and D3 has EUCDOM and D1 has POLYCAT(D3,
--R            D9,D8) and D9 has OAMONS
--R
--RExamples of distFact from LeadingCoefDetermination
--R
--E 714

--S 715 of 3320
)d op distinguishedCommonRootsOf
--R 
--R
--RThere is one exposed function called distinguishedCommonRootsOf :
--R   [1] (List(SparseUnivariatePolynomial(D3)),D3) -> Record(zeros: List(
--R            D3),extDegree: Integer)
--R             from RootsFindingPackage(D3) if D3 has FIELD
--R
--RExamples of distinguishedCommonRootsOf from RootsFindingPackage
--R
--E 715

--S 716 of 3320
)d op distinguishedRootsOf
--R 
--R
--RThere are 2 exposed functions called distinguishedRootsOf :
--R   [1] (SparseUnivariatePolynomial(D),D) -> List(D) from D if D has 
--R            PACPERC
--R   [2] (SparseUnivariatePolynomial(D3),D3) -> Record(zeros: List(D3),
--R            extDegree: Integer)
--R             from RootsFindingPackage(D3) if D3 has FIELD
--R
--RExamples of distinguishedRootsOf from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--R
--RExamples of distinguishedRootsOf from RootsFindingPackage
--R
--E 716

--S 717 of 3320
)d op distribute
--R 
--R
--RThere are 2 exposed functions called distribute :
--R   [1] (D,D) -> D from D if D has ES
--R   [2] D -> D from D if D has ES
--R
--RExamples of distribute from ExpressionSpace
--R
--E 717

--S 718 of 3320
)d op div
--R 
--R
--RThere is one unexposed function called div :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of div from OutputForm
--R
--E 718

--S 719 of 3320
)d op divergence
--R 
--R
--RThere is one exposed function called divergence :
--R   [1] (D2,D3) -> D1 from MultiVariableCalculusFunctions(D4,D1,D2,D3)
--R             if D4 has SETCAT and D1 has PDRING(D4) and D2 has FLAGG(D1
--R            ) and D3 has FiniteLinearAggregate(D4)with
--R                 finiteAggregate
--R
--RExamples of divergence from MultiVariableCalculusFunctions
--R
--E 719

--S 720 of 3320
)d op divide
--R 
--R
--RThere are 2 exposed functions called divide :
--R   [1] (D,D) -> Record(quotient: D,remainder: D) from D if D has EUCDOM
--R            
--R   [2] (NonNegativeInteger,NonNegativeInteger) -> Record(quotient: 
--R            NonNegativeInteger,remainder: NonNegativeInteger)
--R             from NonNegativeInteger
--R
--RThere are 3 unexposed functions called divide :
--R   [1] (FreeMonoid(D2),FreeMonoid(D2)) -> Union(Record(lm: FreeMonoid(
--R            D2),rm: FreeMonoid(D2)),"failed")
--R             from FreeMonoid(D2) if D2 has SETCAT
--R   [2] (OrderedFreeMonoid(D2),OrderedFreeMonoid(D2)) -> Union(Record(lm
--R            : Union(OrderedFreeMonoid(D2),"failed"),rm: Union(
--R            OrderedFreeMonoid(D2),"failed")),"failed")
--R             from OrderedFreeMonoid(D2) if D2 has ORDSET
--R   [3] (D2,D2) -> Record(quotient: D2,remainder: D2)
--R             from PseudoRemainderSequence(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of divide from EuclideanDomain
--R
--R
--RExamples of divide from FreeMonoid
--R
--R
--RExamples of divide from NonNegativeInteger
--R
--R
--RExamples of divide from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rm2:=(x*y)$OFMONOID(Symbol) 
--Rdivide(m1,m2)
--R
--R
--RExamples of divide from PseudoRemainderSequence
--R
--E 720

--S 721 of 3320
)d op divide!
--R 
--R
--RThere is one exposed function called divide! :
--R   [1] (U32Vector,U32Vector,U32Vector,Integer) -> Void
--R             from U32VectorPolynomialOperations
--R
--RExamples of divide! from U32VectorPolynomialOperations
--R
--E 721

--S 722 of 3320
)d op divideExponents
--R 
--R
--RThere is one exposed function called divideExponents :
--R   [1] (D,NonNegativeInteger) -> Union(D,"failed") from D
--R             if D has UPOLYC(D2) and D2 has RING
--R
--RExamples of divideExponents from UnivariatePolynomialCategory
--R
--E 722

--S 723 of 3320
)d op divideIfCan
--R 
--R
--RThere is one unexposed function called divideIfCan :
--R   [1] (D2,D2) -> Union(Record(quotient: D2,remainder: D2),"failed")
--R             from UnivariatePolynomialDivisionPackage(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of divideIfCan from UnivariatePolynomialDivisionPackage
--R
--E 723

--S 724 of 3320
)d op divideIfCan_!
--R 
--R   divideIfCan_! is not a known function. Axiom will try to list its 
--R      functions which contain divideIfCan_! in their names. This is the
--R      same output you would get by issuing
--R                       )what operations divideIfCan_!
--R
--R   There are no operations containing those patterns
--R
--E 724

--S 725 of 3320
)d op divisor
--R 
--R
--RThere are 5 exposed functions called divisor :
--R   [1] (D1,D2,D2,D2,D3) -> D from D
--R             if D3 has FIELD and D2 has UPOLYC(D3) and D4 has UPOLYC(
--R            FRAC(D2)) and D has FDIVCAT(D3,D2,D4,D1) and D1 has FFCAT(
--R            D3,D2,D4)
--R   [2] (D1,D1,Integer) -> D from D
--R             if D1 has FIELD and D3 has UPOLYC(D1) and D4 has UPOLYC(
--R            FRAC(D3)) and D has FDIVCAT(D1,D3,D4,D5) and D5 has FFCAT(
--R            D1,D3,D4)
--R   [3] (D1,D1) -> D from D
--R             if D1 has FIELD and D2 has UPOLYC(D1) and D3 has UPOLYC(
--R            FRAC(D2)) and D has FDIVCAT(D1,D2,D3,D4) and D4 has FFCAT(
--R            D1,D2,D3)
--R   [4] D1 -> D from D
--R             if D2 has FIELD and D3 has UPOLYC(D2) and D4 has UPOLYC(
--R            FRAC(D3)) and D has FDIVCAT(D2,D3,D4,D1) and D1 has FFCAT(
--R            D2,D3,D4)
--R   [5] FractionalIdeal(D3,Fraction(D3),D4,D5) -> D from D
--R             if D3 has UPOLYC(D2) and D4 has UPOLYC(FRAC(D3)) and D5
--R             has FFCAT(D2,D3,D4) and D2 has FIELD and D has FDIVCAT(D2,
--R            D3,D4,D5)
--R
--RExamples of divisor from FiniteDivisorCategory
--R
--E 725

--S 726 of 3320
)d op divisorAtDesingTree
--R 
--R
--RThere is one exposed function called divisorAtDesingTree :
--R   [1] (D5,D6) -> D4 from DesingTreePackage(D7,D8,D5,D9,D10,D11,D1,D4,
--R            D2,D6,D3)
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D5 has POLYCAT(D7
--R            ,D9,OVAR(D8)) and D9 has DIRPCAT(#(D8),NNI) and D10 has 
--R            PRSPCAT(D7) and D11 has LOCPOWC(D7) and D1 has PLACESC(D7,
--R            D11) and D2 has INFCLCT(D7,D8,D5,D9,D10,D11,D1,D4,D3) and 
--R            D3 has BLMETCT and D4 has DIVCAT(D1) and D6 has DSTRCAT(D2)
--R            
--R
--RExamples of divisorAtDesingTree from DesingTreePackage
--R
--E 726

--S 727 of 3320
)d op divisorCascade
--R 
--R
--RThere are 2 unexposed functions called divisorCascade :
--R   [1] (D2,D2,Boolean) -> List(Record(factors: List(D2),error: D4))
--R             from ComplexRootFindingPackage(D4,D2)
--R             if D4 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D4))
--R   [2] (D2,D2) -> List(Record(factors: List(D2),error: D3))
--R             from ComplexRootFindingPackage(D3,D2)
--R             if D3 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D3))
--R
--RExamples of divisorCascade from ComplexRootFindingPackage
--R
--E 727

--S 728 of 3320
)d op divisors
--R 
--R
--RThere is one exposed function called divisors :
--R   [1] Integer -> List(Integer) from IntegerNumberTheoryFunctions
--R
--RExamples of divisors from IntegerNumberTheoryFunctions
--R
--E 728

--S 729 of 3320
)d op divOfPole
--R 
--R
--RThere is one exposed function called divOfPole :
--R   [1] D -> D from D if D has DIVCAT(D1) and D1 has SETCAT
--R
--RExamples of divOfPole from DivisorCategory
--R
--E 729

--S 730 of 3320
)d op divOfZero
--R 
--R
--RThere is one exposed function called divOfZero :
--R   [1] D -> D from D if D has DIVCAT(D1) and D1 has SETCAT
--R
--RExamples of divOfZero from DivisorCategory
--R
--E 730

--S 731 of 3320
)d op dmp2rfi
--R 
--R
--RThere are 3 unexposed functions called dmp2rfi :
--R   [1] D2 -> Fraction(Polynomial(D3))
--R             from ParametricLinearEquations(D3,D4,D5,D2)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D4
--R             has Join(OrderedSet,ConvertibleTo(Symbol)) and D5 has 
--R            OAMONS and D2 has POLYCAT(D3,D5,D4)
--R   [2] Matrix(D6) -> Matrix(Fraction(Polynomial(D3)))
--R             from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D5,D4) and D3 has Join(
--R            EuclideanDomain,CharacteristicZero) and D4 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D5 has OAMONS
--R   [3] List(D6) -> List(Fraction(Polynomial(D3)))
--R             from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D5,D4) and D3 has Join(
--R            EuclideanDomain,CharacteristicZero) and D4 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D5 has OAMONS
--R
--RExamples of dmp2rfi from ParametricLinearEquations
--R
--E 731

--S 732 of 3320
)d op dmpToHdmp
--R 
--R
--RThere is one unexposed function called dmpToHdmp :
--R   [1] DistributedMultivariatePolynomial(D3,D4) -> 
--R            HomogeneousDistributedMultivariatePolynomial(D3,D4)
--R             from PolToPol(D3,D4) if D3: LIST(SYMBOL) and D4 has RING
--R         
--R
--RExamples of dmpToHdmp from PolToPol
--R
--E 732

--S 733 of 3320
)d op dmpToP
--R 
--R
--RThere is one unexposed function called dmpToP :
--R   [1] DistributedMultivariatePolynomial(D3,D4) -> Polynomial(D4)
--R             from PolToPol(D3,D4) if D3: LIST(SYMBOL) and D4 has RING
--R         
--R
--RExamples of dmpToP from PolToPol
--R
--E 733

--S 734 of 3320
)d op dn
--R 
--R
--RThere is one unexposed function called dn :
--R   [1] (D1,D2) -> D1 from EllipticFunctionsUnivariateTaylorSeries(D2,D1
--R            )
--R             if D2 has FIELD and D1 has UTSCAT(D2)
--R
--RExamples of dn from EllipticFunctionsUnivariateTaylorSeries
--R
--E 734

--S 735 of 3320
)d op dom
--R 
--R
--RThere is one exposed function called dom :
--R   [1] Any -> SExpression from Any
--R
--RExamples of dom from Any
--R
--E 735

--S 736 of 3320
)d op domainOf
--R 
--R
--RThere is one exposed function called domainOf :
--R   [1] Any -> OutputForm from Any
--R
--RExamples of domainOf from Any
--R
--E 736

--S 737 of 3320
)d op dominantTerm
--R 
--R
--RThere is one unexposed function called dominantTerm :
--R   [1] UnivariatePuiseuxSeriesWithExponentialSingularity(D2,D3,D4,D5)
--R             -> Union(Record(%term: Record(%coef: UnivariatePuiseuxSeries(D3,
--R            D4,D5),%expon: ExponentialOfUnivariatePuiseuxSeries(D3,D4,D5),
--R            %expTerms: List(Record(k: Fraction(Integer),c: D3))),%type: 
--R            String),"failed")
--R             from UnivariatePuiseuxSeriesWithExponentialSingularity(D2,
--R            D3,D4,D5)
--R             if D2 has Join(OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer),GcdDomain) and D3 has 
--R            Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D2)) and D4: 
--R            SYMBOL and D5: D3
--R
--RExamples of dominantTerm from UnivariatePuiseuxSeriesWithExponentialSingularity
--R
--E 737

--S 738 of 3320
)d op dot
--R 
--R
--RThere are 2 exposed functions called dot :
--R   [1] (D,D) -> D1 from D if D has DIRPCAT(D2,D1) and D1 has TYPE and 
--R            D1 has RING
--R   [2] (D,D) -> D1 from D if D has VECTCAT(D1) and D1 has TYPE and D1
--R             has RING
--R
--RThere are 4 unexposed functions called dot :
--R   [1] (DeRhamComplex(D3,D4),DeRhamComplex(D3,D4),SquareMatrix(#(D4),
--R            Expression(D3))) -> Expression(D3)
--R             from DeRhamComplex(D3,D4)
--R             if D4: LIST(SYMBOL) and D3 has Join(Ring,OrderedSet)
--R   [2] (OutputForm,NonNegativeInteger) -> OutputForm from OutputForm
--R         
--R   [3] OutputForm -> OutputForm from OutputForm
--R   [4] (Point(DoubleFloat),Point(DoubleFloat)) -> DoubleFloat from 
--R            TubePlotTools
--R
--RExamples of dot from DeRhamComplex
--R
--Rder := DeRhamComplex(Integer,[x,y,z]) 
--Rf:BOP:=operator('f) 
--Rg:BOP:=operator('g) 
--Rh:BOP:=operator('h) 
--Rsigma:der:=f(x,y,z)*dx + g(x,y,z)*dy + h(x,y,z)*dz 
--RG:SquareMatrix(3,Integer):=diagonalMatrix([1,1,1]) 
--Rdot(sigma,sigma,G)
--R
--R
--RExamples of dot from DirectProductCategory
--R
--R
--RExamples of dot from OutputForm
--R
--R
--RExamples of dot from TubePlotTools
--R
--R
--RExamples of dot from VectorCategory
--R
--E 738

--S 739 of 3320 done
)d op dot2eps
--R 
--R
--RThere is one exposed function called dot2eps :
--R   [1] String -> Void from Graphviz
--R
--RExamples of dot2eps from Graphviz
--R
--Rdot2eps "NeuralNet"
--R
--E 739

--S 740 of 33 done20
)d op dotview
--R 
--R
--RThere is one exposed function called dotview :
--R   [1] (String,String) -> Void from Graphviz
--R
--RExamples of dotview from Graphviz
--R
--Rdotview("evince","NeuralNet") -- on Linux 
--Rdotview("gv","NeuralNet") -- on MAC 
--Rdotview("firefox","NeuralNet") -- most places
--R
--E 740

--S 741 of 3320
)d op double
--R 
--R
--RThere is one unexposed function called double :
--R   [1] (PositiveInteger,D1) -> D1 from RepeatedDoubling(D1)
--R             if D1 has SetCategorywith
--R               ?+? : (%,%) -> %
--R
--RExamples of double from RepeatedDoubling
--R
--E 741

--S 742 of 3320
)d op double?
--R 
--R
--RThere is one exposed function called double? :
--R   [1] FortranScalarType -> Boolean from FortranScalarType
--R
--RExamples of double? from FortranScalarType
--R
--E 742

--S 743 of 3320
)d op doubleComplex?
--R 
--R
--RThere is one exposed function called doubleComplex? :
--R   [1] FortranScalarType -> Boolean from FortranScalarType
--R
--RExamples of doubleComplex? from FortranScalarType
--R
--E 743

--S 744 of 3320
)d op doubleDisc
--R 
--R
--RThere is one unexposed function called doubleDisc :
--R   [1] D2 -> Integer from PointsOfFiniteOrderTools(D3,D2)
--R             if D3 has UPOLYC(FRAC(INT)) and D2 has UPOLYC(FRAC(D3))
--R         
--R
--RExamples of doubleDisc from PointsOfFiniteOrderTools
--R
--E 744

--S 745 of 3320
)d op doubleFloatFormat
--R 
--R
--RThere is one exposed function called doubleFloatFormat :
--R   [1] String -> String from DoubleFloat
--R
--RExamples of doubleFloatFormat from DoubleFloat
--R
--E 745

--S 746 of 3320
)d op doubleRank
--R 
--R
--RThere is one exposed function called doubleRank :
--R   [1] D2 -> NonNegativeInteger from AlgebraPackage(D3,D2)
--R             if D3 has INTDOM and D2 has FRNAALG(D3)
--R
--RExamples of doubleRank from AlgebraPackage
--R
--E 746

--S 747 of 3320
)d op doubleResultant
--R 
--R
--RThere is one unexposed function called doubleResultant :
--R   [1] (D2,(D1 -> D1)) -> D1 from DoubleResultantPackage(D4,D1,D5,D2)
--R             if D4 has FIELD and D5 has UPOLYC(FRAC(D1)) and D1 has 
--R            UPOLYC(D4) and D2 has FFCAT(D4,D1,D5)
--R
--RExamples of doubleResultant from DoubleResultantPackage
--R
--E 747

--S 748 of 3320
)d op doublyTransitive?
--R 
--R
--RThere is one exposed function called doublyTransitive? :
--R   [1] D2 -> Boolean from AlgFactor(D2) if D2 has UPOLYC(AN)
--R
--RExamples of doublyTransitive? from AlgFactor
--R
--E 748

--S 749 of 3320
)d op draw
--R 
--R
--RThere are 31 exposed functions called draw :
--R   [1] ((DoubleFloat -> DoubleFloat),Segment(Float),List(DrawOption))
--R             -> TwoDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [2] ((DoubleFloat -> DoubleFloat),Segment(Float)) -> 
--R            TwoDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [3] (ParametricPlaneCurve((DoubleFloat -> DoubleFloat)),Segment(
--R            Float),List(DrawOption)) -> TwoDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [4] (ParametricPlaneCurve((DoubleFloat -> DoubleFloat)),Segment(
--R            Float)) -> TwoDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [5] (ParametricSpaceCurve((DoubleFloat -> DoubleFloat)),Segment(
--R            Float),List(DrawOption)) -> ThreeDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [6] (ParametricSpaceCurve((DoubleFloat -> DoubleFloat)),Segment(
--R            Float)) -> ThreeDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [7] ((DoubleFloat -> Point(DoubleFloat)),Segment(Float),List(
--R            DrawOption)) -> ThreeDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [8] ((DoubleFloat -> Point(DoubleFloat)),Segment(Float)) -> 
--R            ThreeDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [9] (((DoubleFloat,DoubleFloat) -> DoubleFloat),Segment(Float),
--R            Segment(Float),List(DrawOption)) -> ThreeDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [10] (((DoubleFloat,DoubleFloat) -> DoubleFloat),Segment(Float),
--R            Segment(Float)) -> ThreeDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [11] (((DoubleFloat,DoubleFloat) -> Point(DoubleFloat)),Segment(
--R            Float),Segment(Float),List(DrawOption)) -> 
--R            ThreeDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [12] (((DoubleFloat,DoubleFloat) -> Point(DoubleFloat)),Segment(
--R            Float),Segment(Float)) -> ThreeDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [13] (ParametricSurface(((DoubleFloat,DoubleFloat) -> DoubleFloat)),
--R            Segment(Float),Segment(Float),List(DrawOption)) -> 
--R            ThreeDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [14] (ParametricSurface(((DoubleFloat,DoubleFloat) -> DoubleFloat)),
--R            Segment(Float),Segment(Float)) -> ThreeDimensionalViewport
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [15] (Equation(D6),Symbol,Symbol,List(DrawOption)) -> 
--R            TwoDimensionalViewport
--R             from TopLevelDrawFunctionsForAlgebraicCurves(D5,D6)
--R             if D6 has FS(D5) and D5 has Join(IntegralDomain,OrderedSet
--R            ,RetractableTo(Integer))
--R   [16] (D2,SegmentBinding(Float),List(DrawOption)) -> 
--R            TwoDimensionalViewport
--R             from TopLevelDrawFunctions(D2)
--R             if D2 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [17] (D2,SegmentBinding(Float)) -> TwoDimensionalViewport
--R             from TopLevelDrawFunctions(D2)
--R             if D2 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [18] (ParametricPlaneCurve(D5),SegmentBinding(Float),List(DrawOption
--R            )) -> TwoDimensionalViewport
--R             from TopLevelDrawFunctions(D5)
--R             if D5 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [19] (ParametricPlaneCurve(D4),SegmentBinding(Float)) -> 
--R            TwoDimensionalViewport
--R             from TopLevelDrawFunctions(D4)
--R             if D4 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [20] (ParametricSpaceCurve(D5),SegmentBinding(Float),List(DrawOption
--R            )) -> ThreeDimensionalViewport
--R             from TopLevelDrawFunctions(D5)
--R             if D5 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [21] (ParametricSpaceCurve(D4),SegmentBinding(Float)) -> 
--R            ThreeDimensionalViewport
--R             from TopLevelDrawFunctions(D4)
--R             if D4 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [22] (D2,SegmentBinding(Float),SegmentBinding(Float),List(DrawOption
--R            )) -> ThreeDimensionalViewport
--R             from TopLevelDrawFunctions(D2)
--R             if D2 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [23] (D2,SegmentBinding(Float),SegmentBinding(Float)) -> 
--R            ThreeDimensionalViewport
--R             from TopLevelDrawFunctions(D2)
--R             if D2 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [24] (ParametricSurface(D5),SegmentBinding(Float),SegmentBinding(
--R            Float),List(DrawOption)) -> ThreeDimensionalViewport
--R             from TopLevelDrawFunctions(D5)
--R             if D5 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [25] (ParametricSurface(D4),SegmentBinding(Float),SegmentBinding(
--R            Float)) -> ThreeDimensionalViewport
--R             from TopLevelDrawFunctions(D4)
--R             if D4 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [26] (List(DoubleFloat),List(DoubleFloat)) -> TwoDimensionalViewport
--R             from TopLevelDrawFunctionsForPoints
--R   [27] (List(DoubleFloat),List(DoubleFloat),List(DrawOption)) -> 
--R            TwoDimensionalViewport
--R             from TopLevelDrawFunctionsForPoints
--R   [28] List(Point(DoubleFloat)) -> TwoDimensionalViewport
--R             from TopLevelDrawFunctionsForPoints
--R   [29] (List(Point(DoubleFloat)),List(DrawOption)) -> 
--R            TwoDimensionalViewport
--R             from TopLevelDrawFunctionsForPoints
--R   [30] (List(DoubleFloat),List(DoubleFloat),List(DoubleFloat)) -> 
--R            ThreeDimensionalViewport
--R             from TopLevelDrawFunctionsForPoints
--R   [31] (List(DoubleFloat),List(DoubleFloat),List(DoubleFloat),List(
--R            DrawOption)) -> ThreeDimensionalViewport
--R             from TopLevelDrawFunctionsForPoints
--R
--RExamples of draw from TopLevelDrawFunctionsForCompiledFunctions
--R
--R
--RExamples of draw from TopLevelDrawFunctionsForAlgebraicCurves
--R
--R
--RExamples of draw from TopLevelDrawFunctions
--R
--R
--RExamples of draw from TopLevelDrawFunctionsForPoints
--R
--E 749

--S 750 of 3320
)d op drawComplex
--R 
--R
--RThere is one exposed function called drawComplex :
--R   [1] ((Complex(DoubleFloat) -> Complex(DoubleFloat)),Segment(
--R            DoubleFloat),Segment(DoubleFloat),Boolean) -> 
--R            ThreeDimensionalViewport
--R             from DrawComplex
--R
--RExamples of drawComplex from DrawComplex
--R
--E 750

--S 751 of 3320
)d op drawComplexVectorField
--R 
--R
--RThere is one exposed function called drawComplexVectorField :
--R   [1] ((Complex(DoubleFloat) -> Complex(DoubleFloat)),Segment(
--R            DoubleFloat),Segment(DoubleFloat)) -> ThreeDimensionalViewport
--R             from DrawComplex
--R
--RExamples of drawComplexVectorField from DrawComplex
--R
--E 751

--S 752 of 3320
)d op drawCurves
--R 
--R
--RThere are 2 unexposed functions called drawCurves :
--R   [1] (List(List(Point(DoubleFloat))),Palette,Palette,PositiveInteger,
--R            List(DrawOption)) -> TwoDimensionalViewport
--R             from ViewportPackage
--R   [2] (List(List(Point(DoubleFloat))),List(DrawOption)) -> 
--R            TwoDimensionalViewport
--R             from ViewportPackage
--R
--RExamples of drawCurves from ViewportPackage
--R
--E 752

--S 753 of 3320
)d op drawStyle
--R 
--R
--RThere is one exposed function called drawStyle :
--R   [1] (ThreeDimensionalViewport,String) -> Void from 
--R            ThreeDimensionalViewport
--R
--RExamples of drawStyle from ThreeDimensionalViewport
--R
--E 753

--S 754 of 3320
)d op drawToScale
--R 
--R
--RThere are 2 exposed functions called drawToScale :
--R   [1]  -> Boolean from GraphicsDefaults
--R   [2] Boolean -> Boolean from GraphicsDefaults
--R
--RExamples of drawToScale from GraphicsDefaults
--R
--E 754

--S 755 of 3320
)d op drift
--R 
--R
--RThere is one exposed function called drift :
--R   [1] StochasticDifferential(D1) -> StochasticDifferential(D1)
--R             from StochasticDifferential(D1)
--R             if D1 has Join(OrderedSet,IntegralDomain)
--R
--RExamples of drift from StochasticDifferential
--R
--E 755

--S 756 of 3320
)d op droot
--R 
--R
--RThere is one unexposed function called droot :
--R   [1] List(D4) -> OutputForm from AlgebraicFunction(D3,D4)
--R             if D4 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of droot from AlgebraicFunction
--R
--E 756

--S 757 of 3320
)d op duplicates
--R 
--R
--RThere is one exposed function called duplicates :
--R   [1] D -> List(Record(entry: D2,count: NonNegativeInteger)) from D
--R             if D has MDAGG(D2) and D2 has SETCAT
--R
--RExamples of duplicates from MultiDictionary
--R
--E 757

--S 758 of 3320
)d op duplicates?
--R 
--R
--RThere is one unexposed function called duplicates? :
--R   [1] ListMultiDictionary(D2) -> Boolean from ListMultiDictionary(D2)
--R             if D2 has SETCAT
--R
--RExamples of duplicates? from ListMultiDictionary
--R
--E 758

--S 759 of 3320
)d op e
--R 
--R
--RThere is one exposed function called e :
--R   [1] PositiveInteger -> CliffordAlgebra(D2,D3,D4)
--R             from CliffordAlgebra(D2,D3,D4)
--R             if D2: PI and D3 has FIELD and D4: QFORM(D2,D3)
--R
--RExamples of e from CliffordAlgebra
--R
--E 759

--S 760 of 3320
)d op e01baf
--R 
--R
--RThere is one exposed function called e01baf :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Integer,Integer
--R            ,Integer) -> Result
--R             from NagInterpolationPackage
--R
--RExamples of e01baf from NagInterpolationPackage
--R
--E 760

--S 761 of 3320
)d op e01bef
--R 
--R
--RThere is one exposed function called e01bef :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Integer) -> 
--R            Result
--R             from NagInterpolationPackage
--R
--RExamples of e01bef from NagInterpolationPackage
--R
--E 761

--S 762 of 3320
)d op e01bff
--R 
--R
--RThere is one exposed function called e01bff :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Integer,Matrix(DoubleFloat),Integer) -> Result
--R             from NagInterpolationPackage
--R
--RExamples of e01bff from NagInterpolationPackage
--R
--E 762

--S 763 of 3320
)d op e01bgf
--R 
--R
--RThere is one exposed function called e01bgf :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Integer,Matrix(DoubleFloat),Integer) -> Result
--R             from NagInterpolationPackage
--R
--RExamples of e01bgf from NagInterpolationPackage
--R
--E 763

--S 764 of 3320
)d op e01bhf
--R 
--R
--RThere is one exposed function called e01bhf :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),DoubleFloat,DoubleFloat,Integer) -> Result
--R             from NagInterpolationPackage
--R
--RExamples of e01bhf from NagInterpolationPackage
--R
--E 764

--S 765 of 3320
)d op e01daf
--R 
--R
--RThere is one exposed function called e01daf :
--R   [1] (Integer,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Integer) -> Result
--R             from NagInterpolationPackage
--R
--RExamples of e01daf from NagInterpolationPackage
--R
--E 765

--S 766 of 3320
)d op e01saf
--R 
--R
--RThere is one exposed function called e01saf :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Integer) -> Result
--R             from NagInterpolationPackage
--R
--RExamples of e01saf from NagInterpolationPackage
--R
--E 766

--S 767 of 3320
)d op e01sbf
--R 
--R
--RThere is one exposed function called e01sbf :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Matrix(Integer),Matrix(DoubleFloat),DoubleFloat,
--R            DoubleFloat,Integer) -> Result
--R             from NagInterpolationPackage
--R
--RExamples of e01sbf from NagInterpolationPackage
--R
--E 767

--S 768 of 3320
)d op e01sef
--R 
--R
--RThere is one exposed function called e01sef :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Integer,Integer,DoubleFloat,DoubleFloat,Integer) -> 
--R            Result
--R             from NagInterpolationPackage
--R
--RExamples of e01sef from NagInterpolationPackage
--R
--E 768

--S 769 of 3320
)d op e01sff
--R 
--R
--RThere is one exposed function called e01sff :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),DoubleFloat,Matrix(DoubleFloat),DoubleFloat,
--R            DoubleFloat,Integer) -> Result
--R             from NagInterpolationPackage
--R
--RExamples of e01sff from NagInterpolationPackage
--R
--E 769

--S 770 of 3320
)d op e02adf
--R 
--R
--RThere is one exposed function called e02adf :
--R   [1] (Integer,Integer,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat)
--R            ,Matrix(DoubleFloat),Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02adf from NagFittingPackage
--R
--E 770

--S 771 of 3320
)d op e02aef
--R 
--R
--RThere is one exposed function called e02aef :
--R   [1] (Integer,Matrix(DoubleFloat),DoubleFloat,Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02aef from NagFittingPackage
--R
--E 771

--S 772 of 3320
)d op e02agf
--R 
--R
--RThere is one exposed function called e02agf :
--R   [1] (Integer,Integer,Integer,DoubleFloat,DoubleFloat,Matrix(
--R            DoubleFloat),Matrix(DoubleFloat),Matrix(DoubleFloat),Integer,
--R            Matrix(DoubleFloat),Matrix(DoubleFloat),Integer,Matrix(Integer),
--R            Integer,Integer,Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02agf from NagFittingPackage
--R
--E 772

--S 773 of 3320
)d op e02ahf
--R 
--R
--RThere is one exposed function called e02ahf :
--R   [1] (Integer,DoubleFloat,DoubleFloat,Matrix(DoubleFloat),Integer,
--R            Integer,Integer,Integer,Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02ahf from NagFittingPackage
--R
--E 773

--S 774 of 3320
)d op e02ajf
--R 
--R
--RThere is one exposed function called e02ajf :
--R   [1] (Integer,DoubleFloat,DoubleFloat,Matrix(DoubleFloat),Integer,
--R            Integer,DoubleFloat,Integer,Integer,Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02ajf from NagFittingPackage
--R
--E 774

--S 775 of 3320
)d op e02akf
--R 
--R
--RThere is one exposed function called e02akf :
--R   [1] (Integer,DoubleFloat,DoubleFloat,Matrix(DoubleFloat),Integer,
--R            Integer,DoubleFloat,Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02akf from NagFittingPackage
--R
--E 775

--S 776 of 3320
)d op e02baf
--R 
--R
--RThere is one exposed function called e02baf :
--R   [1] (Integer,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Matrix(DoubleFloat),Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02baf from NagFittingPackage
--R
--E 776

--S 777 of 3320
)d op e02bbf
--R 
--R
--RThere is one exposed function called e02bbf :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),DoubleFloat,
--R            Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02bbf from NagFittingPackage
--R
--E 777

--S 778 of 3320
)d op e02bcf
--R 
--R
--RThere is one exposed function called e02bcf :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),DoubleFloat,
--R            Integer,Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02bcf from NagFittingPackage
--R
--E 778

--S 779 of 3320
)d op e02bdf
--R 
--R
--RThere is one exposed function called e02bdf :
--R   [1] (Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Integer) -> 
--R            Result
--R             from NagFittingPackage
--R
--RExamples of e02bdf from NagFittingPackage
--R
--E 779

--S 780 of 3320
)d op e02bef
--R 
--R
--RThere is one exposed function called e02bef :
--R   [1] (String,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),DoubleFloat,Integer,Integer,Integer,Matrix(
--R            DoubleFloat),Integer,Matrix(DoubleFloat),Matrix(Integer)) -> 
--R            Result
--R             from NagFittingPackage
--R
--RExamples of e02bef from NagFittingPackage
--R
--E 780

--S 781 of 3320
)d op e02daf
--R 
--R
--RThere is one exposed function called e02daf :
--R   [1] (Integer,Integer,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat)
--R            ,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(DoubleFloat),
--R            Matrix(Integer),Integer,Integer,Integer,DoubleFloat,Matrix(
--R            DoubleFloat),Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02daf from NagFittingPackage
--R
--E 781

--S 782 of 3320
)d op e02dcf
--R 
--R
--RThere is one exposed function called e02dcf :
--R   [1] (String,Integer,Matrix(DoubleFloat),Integer,Matrix(DoubleFloat),
--R            Matrix(DoubleFloat),DoubleFloat,Integer,Integer,Integer,Integer,
--R            Integer,Matrix(DoubleFloat),Integer,Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Matrix(Integer),Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02dcf from NagFittingPackage
--R
--E 782

--S 783 of 3320
)d op e02ddf
--R 
--R
--RThere is one exposed function called e02ddf :
--R   [1] (String,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Matrix(DoubleFloat),DoubleFloat,Integer,Integer,
--R            Integer,Integer,Integer,Matrix(DoubleFloat),Integer,Matrix(
--R            DoubleFloat),Matrix(DoubleFloat),Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02ddf from NagFittingPackage
--R
--E 783

--S 784 of 3320
)d op e02def
--R 
--R
--RThere is one exposed function called e02def :
--R   [1] (Integer,Integer,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat)
--R            ,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(DoubleFloat),
--R            Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02def from NagFittingPackage
--R
--E 784

--S 785 of 3320
)d op e02dff
--R 
--R
--RThere is one exposed function called e02dff :
--R   [1] (Integer,Integer,Integer,Integer,Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Integer,Integer,Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02dff from NagFittingPackage
--R
--E 785

--S 786 of 3320
)d op e02gaf
--R 
--R
--RThere is one exposed function called e02gaf :
--R   [1] (Integer,Integer,Integer,DoubleFloat,Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Integer) -> Result
--R             from NagFittingPackage
--R
--RExamples of e02gaf from NagFittingPackage
--R
--E 786

--S 787 of 3320
)d op e02zaf
--R 
--R
--RThere is one exposed function called e02zaf :
--R   [1] (Integer,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Integer
--R            ,Matrix(DoubleFloat),Matrix(DoubleFloat),Integer,Integer,Integer)
--R             -> Result
--R             from NagFittingPackage
--R
--RExamples of e02zaf from NagFittingPackage
--R
--E 787

--S 788 of 3320
)d op e04dgf
--R 
--R
--RThere is one exposed function called e04dgf :
--R   [1] (Integer,DoubleFloat,DoubleFloat,Integer,DoubleFloat,Boolean,
--R            DoubleFloat,DoubleFloat,Integer,Integer,Integer,Integer,Matrix(
--R            DoubleFloat),Integer,Union(fn: FileName,fp: Asp49(OBJFUN))) -> 
--R            Result
--R             from NagOptimisationPackage
--R
--RExamples of e04dgf from NagOptimisationPackage
--R
--E 788

--S 789 of 3320
)d op e04fdf
--R 
--R
--RThere is one exposed function called e04fdf :
--R   [1] (Integer,Integer,Integer,Integer,Matrix(DoubleFloat),Integer,
--R            Union(fn: FileName,fp: Asp50(LSFUN1))) -> Result
--R             from NagOptimisationPackage
--R
--RExamples of e04fdf from NagOptimisationPackage
--R
--E 789

--S 790 of 3320
)d op e04gcf
--R 
--R
--RThere is one exposed function called e04gcf :
--R   [1] (Integer,Integer,Integer,Integer,Matrix(DoubleFloat),Integer,
--R            Union(fn: FileName,fp: Asp19(LSFUN2))) -> Result
--R             from NagOptimisationPackage
--R
--RExamples of e04gcf from NagOptimisationPackage
--R
--E 790

--S 791 of 3320
)d op e04jaf
--R 
--R
--RThere is one exposed function called e04jaf :
--R   [1] (Integer,Integer,Integer,Integer,Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Matrix(DoubleFloat),Integer,Union(fn: FileName,fp: 
--R            Asp24(FUNCT1))) -> Result
--R             from NagOptimisationPackage
--R
--RExamples of e04jaf from NagOptimisationPackage
--R
--E 791

--S 792 of 3320
)d op e04mbf
--R 
--R
--RThere is one exposed function called e04mbf :
--R   [1] (Integer,Integer,Integer,Integer,Integer,Integer,Matrix(
--R            DoubleFloat),Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Boolean,Integer,Integer,Matrix(DoubleFloat),Integer)
--R             -> Result
--R             from NagOptimisationPackage
--R
--RExamples of e04mbf from NagOptimisationPackage
--R
--E 792

--S 793 of 3320
)d op e04naf
--R 
--R
--RThere is one exposed function called e04naf :
--R   [1] (Integer,Integer,Integer,Integer,Integer,Integer,Integer,Integer
--R            ,DoubleFloat,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Boolean,Boolean,Boolean,Integer,Integer,Matrix(
--R            DoubleFloat),Matrix(Integer),Integer,Union(fn: FileName,fp: Asp20
--R            (QPHESS))) -> Result
--R             from NagOptimisationPackage
--R
--RExamples of e04naf from NagOptimisationPackage
--R
--E 793

--S 794 of 3320
)d op e04ucf
--R 
--R
--RThere is one exposed function called e04ucf :
--R   [1] (Integer,Integer,Integer,Integer,Integer,Integer,Matrix(
--R            DoubleFloat),Matrix(DoubleFloat),Matrix(DoubleFloat),Integer,
--R            Integer,Boolean,DoubleFloat,Integer,DoubleFloat,DoubleFloat,
--R            Boolean,DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,Boolean,
--R            Integer,Integer,Integer,Integer,Integer,DoubleFloat,DoubleFloat,
--R            DoubleFloat,Integer,Integer,Integer,Integer,Integer,Matrix(
--R            Integer),Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Matrix(DoubleFloat),Integer,Union(fn: FileName,fp: 
--R            Asp55(CONFUN)),Union(fn: FileName,fp: Asp49(OBJFUN))) -> Result
--R             from NagOptimisationPackage
--R
--RExamples of e04ucf from NagOptimisationPackage
--R
--E 794

--S 795 of 3320
)d op e04ycf
--R 
--R
--RThere is one exposed function called e04ycf :
--R   [1] (Integer,Integer,Integer,DoubleFloat,Matrix(DoubleFloat),Integer
--R            ,Matrix(DoubleFloat),Integer) -> Result
--R             from NagOptimisationPackage
--R
--RExamples of e04ycf from NagOptimisationPackage
--R
--E 795

--S 796 of 3320
)d op E1
--R 
--R
--RThere is one exposed function called E1 :
--R   [1] DoubleFloat -> OnePointCompletion(DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R
--RExamples of E1 from DoubleFloatSpecialFunctions
--R
--E 796

--S 797 of 3320
)d op edf2df
--R 
--R
--RThere is one exposed function called edf2df :
--R   [1] Expression(DoubleFloat) -> DoubleFloat from 
--R            ExpertSystemToolsPackage
--R
--RExamples of edf2df from ExpertSystemToolsPackage
--R
--E 797

--S 798 of 3320
)d op edf2ef
--R 
--R
--RThere is one exposed function called edf2ef :
--R   [1] Expression(DoubleFloat) -> Expression(Float)
--R             from ExpertSystemToolsPackage
--R
--RExamples of edf2ef from ExpertSystemToolsPackage
--R
--E 798

--S 799 of 3320
)d op edf2efi
--R 
--R
--RThere is one exposed function called edf2efi :
--R   [1] Expression(DoubleFloat) -> Expression(Fraction(Integer))
--R             from ExpertSystemToolsPackage
--R
--RExamples of edf2efi from ExpertSystemToolsPackage
--R
--E 799

--S 800 of 3320
)d op edf2fi
--R 
--R
--RThere is one exposed function called edf2fi :
--R   [1] Expression(DoubleFloat) -> Fraction(Integer)
--R             from ExpertSystemToolsPackage
--R
--RExamples of edf2fi from ExpertSystemToolsPackage
--R
--E 800

--S 801 of 3320
)d op ef2edf
--R 
--R
--RThere is one exposed function called ef2edf :
--R   [1] Expression(Float) -> Expression(DoubleFloat)
--R             from ExpertSystemToolsPackage
--R
--RExamples of ef2edf from ExpertSystemToolsPackage
--R
--E 801

--S 802 of 3320
)d op effective?
--R 
--R
--RThere is one exposed function called effective? :
--R   [1] D -> Boolean from D if D has DIVCAT(D2) and D2 has SETCAT
--R
--RExamples of effective? from DivisorCategory
--R
--E 802

--S 803 of 3320
)d op Ei
--R 
--R
--RThere are 2 exposed functions called Ei :
--R   [1] OnePointCompletion(DoubleFloat) -> OnePointCompletion(
--R            DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R   [2] D -> D from D if D has LFCAT
--R
--RThere is one unexposed function called Ei :
--R   [1] D1 -> D1 from LiouvillianFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R
--RExamples of Ei from DoubleFloatSpecialFunctions
--R
--R
--RExamples of Ei from LiouvillianFunctionCategory
--R
--R
--RExamples of Ei from LiouvillianFunction
--R
--E 803

--S 804 of 3320
)d op Ei1
--R 
--R
--RThere is one exposed function called Ei1 :
--R   [1] OnePointCompletion(DoubleFloat) -> OnePointCompletion(
--R            DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R
--RExamples of Ei1 from DoubleFloatSpecialFunctions
--R
--E 804

--S 805 of 3320
)d op Ei2
--R 
--R
--RThere is one exposed function called Ei2 :
--R   [1] OnePointCompletion(DoubleFloat) -> OnePointCompletion(
--R            DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R
--RExamples of Ei2 from DoubleFloatSpecialFunctions
--R
--E 805

--S 806 of 3320
)d op Ei3
--R 
--R
--RThere is one exposed function called Ei3 :
--R   [1] OnePointCompletion(DoubleFloat) -> OnePointCompletion(
--R            DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R
--RExamples of Ei3 from DoubleFloatSpecialFunctions
--R
--E 806

--S 807 of 3320
)d op Ei4
--R 
--R
--RThere is one exposed function called Ei4 :
--R   [1] OnePointCompletion(DoubleFloat) -> OnePointCompletion(
--R            DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R
--RExamples of Ei4 from DoubleFloatSpecialFunctions
--R
--E 807

--S 808 of 3320
)d op Ei5
--R 
--R
--RThere is one exposed function called Ei5 :
--R   [1] OnePointCompletion(DoubleFloat) -> OnePointCompletion(
--R            DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R
--RExamples of Ei5 from DoubleFloatSpecialFunctions
--R
--E 808

--S 809 of 3320
)d op Ei6
--R 
--R
--RThere is one exposed function called Ei6 :
--R   [1] OnePointCompletion(DoubleFloat) -> OnePointCompletion(
--R            DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R
--RExamples of Ei6 from DoubleFloatSpecialFunctions
--R
--E 809

--S 810 of 3320
)d op eigenMatrix
--R 
--R
--RThere is one exposed function called eigenMatrix :
--R   [1] Matrix(Fraction(Polynomial(Integer))) -> Union(Matrix(Expression
--R            (Integer)),"failed")
--R             from RadicalEigenPackage
--R
--RExamples of eigenMatrix from RadicalEigenPackage
--R
--E 810

--S 811 of 3320
)d op eigenvalues
--R 
--R
--RThere is one exposed function called eigenvalues :
--R   [1] Matrix(Fraction(Polynomial(D3))) -> List(Union(Fraction(
--R            Polynomial(D3)),SuchThat(Symbol,Polynomial(D3))))
--R             from EigenPackage(D3) if D3 has GCDDOM
--R
--RExamples of eigenvalues from EigenPackage
--R
--E 811

--S 812 of 3320
)d op eigenvector
--R 
--R
--RThere is one exposed function called eigenvector :
--R   [1] (Union(Fraction(Polynomial(D4)),SuchThat(Symbol,Polynomial(D4)))
--R            ,Matrix(Fraction(Polynomial(D4)))) -> List(Matrix(Fraction(
--R            Polynomial(D4))))
--R             from EigenPackage(D4) if D4 has GCDDOM
--R
--RExamples of eigenvector from EigenPackage
--R
--E 812

--S 813 of 3320
)d op eigenvectors
--R 
--R
--RThere is one exposed function called eigenvectors :
--R   [1] Matrix(Fraction(Polynomial(D3))) -> List(Record(eigval: Union(
--R            Fraction(Polynomial(D3)),SuchThat(Symbol,Polynomial(D3))),eigmult
--R            : NonNegativeInteger,eigvec: List(Matrix(Fraction(Polynomial(D3))
--R            ))))
--R             from EigenPackage(D3) if D3 has GCDDOM
--R
--RExamples of eigenvectors from EigenPackage
--R
--E 813

--S 814 of 3320
)d op eisensteinIrreducible?
--R 
--R
--RThere is one unexposed function called eisensteinIrreducible? :
--R   [1] D2 -> Boolean from GaloisGroupFactorizer(D2) if D2 has UPOLYC(
--R            INT)
--R
--RExamples of eisensteinIrreducible? from GaloisGroupFactorizer
--R
--E 814

--S 815 of 3320
)d op elColumn2!
--R 
--R
--RThere is one exposed function called elColumn2! :
--R   [1] (D1,D2,Integer,Integer) -> D1
--R             from MatrixLinearAlgebraFunctions(D2,D4,D5,D1)
--R             if D2 has COMRING and D4 has FLAGG(D2) and D5 has FLAGG(D2
--R            ) and D1 has MATCAT(D2,D4,D5)
--R
--RExamples of elColumn2! from MatrixLinearAlgebraFunctions
--R
--E 815

--S 816 of 3320
)d op elem?
--R 
--R
--RThere is one unexposed function called elem? :
--R   [1] IntegrationResult(D2) -> Boolean from IntegrationResult(D2) if 
--R            D2 has FIELD
--R
--RExamples of elem? from IntegrationResult
--R
--E 816

--S 817 of 33 done20
)d op element
--R 
--R
--RThere is one exposed function called element :
--R   [1] (D1,PositiveInteger,PositiveInteger) -> D1
--R             from MatrixManipulation(D3,D4,D5,D1)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D1 has MATCAT(D3,D4,D5)
--R
--RExamples of element from MatrixManipulation
--R
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--Relement(M,2,2)
--R
--E 817

--S 818 of 3320
)d op element?
--R 
--R
--RThere is one exposed function called element? :
--R   [1] (D2,PolynomialIdeals(D3,D4,D5,D2)) -> Boolean
--R             from PolynomialIdeals(D3,D4,D5,D2)
--R             if D3 has FIELD and D4 has OAMONS and D5 has ORDSET and D2
--R             has POLYCAT(D3,D4,D5)
--R
--RExamples of element? from PolynomialIdeals
--R
--E 818

--S 819 of 3320
)d op elementary
--R 
--R
--RThere is one exposed function called elementary :
--R   [1] Integer -> SymmetricPolynomial(Fraction(Integer)) from 
--R            CycleIndicators
--R
--RExamples of elementary from CycleIndicators
--R
--E 819

--S 820 of 3320
)d op elements
--R 
--R
--RThere is one unexposed function called elements :
--R   [1] SetOfMIntegersInOneToN(D2,D3) -> List(PositiveInteger)
--R             from SetOfMIntegersInOneToN(D2,D3) if D2: PI and D3: PI
--R         
--R
--RExamples of elements from SetOfMIntegersInOneToN
--R
--E 820

--S 821 of 3320
)d op elimZeroCols!
--R 
--R
--RThere is one exposed function called elimZeroCols! :
--R   [1] SparseEchelonMatrix(D2,D3) -> Void from SparseEchelonMatrix(D2,
--R            D3)
--R             if D2 has ORDSET and D3 has RING
--R
--RExamples of elimZeroCols! from SparseEchelonMatrix
--R
--E 821

--S 822 of 3320
)d op elliptic
--R 
--R
--RThere are 2 exposed functions called elliptic :
--R   [1] D2 -> (Point(D2) -> Point(D2)) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R   [2]  -> Union(D1,"failed") from D
--R             if D has FFCAT(D2,D1,D3) and D2 has UFD and D3 has UPOLYC(
--R            FRAC(D1)) and D1 has UPOLYC(D2)
--R
--RThere is one unexposed function called elliptic :
--R   [1]  -> Union(D1,"failed") from FunctionFieldCategory&(D2,D3,D1,D4)
--R             if D3 has UFD and D4 has UPOLYC(FRAC(D1)) and D1 has 
--R            UPOLYC(D3) and D2 has FFCAT(D3,D1,D4)
--R
--RExamples of elliptic from CoordinateSystems
--R
--R
--RExamples of elliptic from FunctionFieldCategory&
--R
--R
--RExamples of elliptic from FunctionFieldCategory
--R
--E 822

--S 823 of 3320
)d op elliptic?
--R 
--R
--RThere is one exposed function called elliptic? :
--R   [1] Record(pde: List(Expression(DoubleFloat)),constraints: List(
--R            Record(start: DoubleFloat,finish: DoubleFloat,grid: 
--R            NonNegativeInteger,boundaryType: Integer,dStart: Matrix(
--R            DoubleFloat),dFinish: Matrix(DoubleFloat))),f: List(List(
--R            Expression(DoubleFloat))),st: String,tol: DoubleFloat) -> Boolean
--R             from d03AgentsPackage
--R
--RExamples of elliptic? from d03AgentsPackage
--R
--E 823

--S 824 of 3320
)d op ellipticCylindrical
--R 
--R
--RThere is one exposed function called ellipticCylindrical :
--R   [1] D2 -> (Point(D2) -> Point(D2)) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of ellipticCylindrical from CoordinateSystems
--R
--E 824

--S 825 of 3320
)d op elRow1!
--R 
--R
--RThere is one exposed function called elRow1! :
--R   [1] (D1,Integer,Integer) -> D1 from MatrixLinearAlgebraFunctions(D3,
--R            D4,D5,D1)
--R             if D3 has COMRING and D4 has FLAGG(D3) and D5 has FLAGG(D3
--R            ) and D1 has MATCAT(D3,D4,D5)
--R
--RExamples of elRow1! from MatrixLinearAlgebraFunctions
--R
--E 825

--S 826 of 3320
)d op elRow2!
--R 
--R
--RThere is one exposed function called elRow2! :
--R   [1] (D1,D2,Integer,Integer) -> D1
--R             from MatrixLinearAlgebraFunctions(D2,D4,D5,D1)
--R             if D2 has COMRING and D4 has FLAGG(D2) and D5 has FLAGG(D2
--R            ) and D1 has MATCAT(D2,D4,D5)
--R
--RExamples of elRow2! from MatrixLinearAlgebraFunctions
--R
--E 826

--S 827 of 3320
)d op elt
--R 
--R
--RThere are 51 exposed functions called elt :
--R   [1] (D,Integer) -> D1 from D if D has AFSPCAT(D1) and D1 has FIELD
--R         
--R   [2] (D,Integer,Integer,D1) -> D1 from D
--R             if D has ARR2CAT(D1,D3,D4) and D1 has TYPE and D3 has 
--R            FLAGG(D1) and D4 has FLAGG(D1)
--R   [3] (D,Integer,Integer) -> D1 from D
--R             if D has ARR2CAT(D1,D3,D4) and D3 has FLAGG(D1) and D4
--R             has FLAGG(D1) and D1 has TYPE
--R   [4] (D,right) -> D from D if D has BRAGG(D2) and D2 has TYPE
--R   [5] (D,left) -> D from D if D has BRAGG(D2) and D2 has TYPE
--R   [6] (CartesianTensor(D3,D4,D1),List(Integer)) -> D1
--R             from CartesianTensor(D3,D4,D1) if D1 has COMRING and D3: 
--R            INT and D4: NNI
--R   [7] (CartesianTensor(D3,D4,D1),Integer,Integer,Integer,Integer) -> 
--R            D1
--R             from CartesianTensor(D3,D4,D1) if D1 has COMRING and D3: 
--R            INT and D4: NNI
--R   [8] (CartesianTensor(D3,D4,D1),Integer,Integer,Integer) -> D1
--R             from CartesianTensor(D3,D4,D1) if D1 has COMRING and D3: 
--R            INT and D4: NNI
--R   [9] (CartesianTensor(D3,D4,D1),Integer,Integer) -> D1
--R             from CartesianTensor(D3,D4,D1) if D1 has COMRING and D3: 
--R            INT and D4: NNI
--R   [10] (CartesianTensor(D3,D4,D1),Integer) -> D1 from CartesianTensor(
--R            D3,D4,D1)
--R             if D1 has COMRING and D3: INT and D4: NNI
--R   [11] CartesianTensor(D2,D3,D1) -> D1 from CartesianTensor(D2,D3,D1)
--R             if D1 has COMRING and D2: INT and D3: NNI
--R   [12] (Database(D3),Symbol) -> DataList(String) from Database(D3)
--R             if D3 has OrderedSetwith
--R               ?.? : (%,Symbol) -> String
--R               display : % -> Void
--R               fullDisplay : % -> Void
--R   [13] (Database(D2),QueryEquation) -> Database(D2) from Database(D2)
--R             if D2 has OrderedSetwith
--R               ?.? : (%,Symbol) -> String
--R               display : % -> Void
--R               fullDisplay : % -> Void
--R   [14] (DataList(D3),count) -> NonNegativeInteger from DataList(D3)
--R             if D3 has ORDSET
--R   [15] (DataList(D2),sort) -> DataList(D2) from DataList(D2) if D2
--R             has ORDSET
--R   [16] (DataList(D2),unique) -> DataList(D2) from DataList(D2) if D2
--R             has ORDSET
--R   [17] (D,D2) -> D1 from D if D has ELTAB(D2,D1) and D2 has SETCAT and
--R            D1 has TYPE
--R   [18] (D,D2,D1) -> D1 from D
--R             if D has ELTAGG(D2,D1) and D2 has SETCAT and D1 has TYPE
--R         
--R   [19] (BasicOperator,List(D)) -> D from D if D has ES
--R   [20] (BasicOperator,D,D,D,D) -> D from D if D has ES
--R   [21] (BasicOperator,D,D,D) -> D from D if D has ES
--R   [22] (BasicOperator,D,D) -> D from D if D has ES
--R   [23] (BasicOperator,D) -> D from D if D has ES
--R   [24] (D,D1,D1) -> D1 from D
--R             if D has FFCAT(D1,D2,D3) and D1 has UFD and D2 has UPOLYC(
--R            D1) and D3 has UPOLYC(FRAC(D2))
--R   [25] (D,Integer) -> D1 from D if D has FRNAALG(D1) and D1 has 
--R            COMRING
--R   [26] (IndexCard,Symbol) -> String from IndexCard
--R   [27] (Library,Symbol) -> Any from Library
--R   [28] (D,UniversalSegment(Integer)) -> D from D if D has LNAGG(D2) 
--R            and D2 has TYPE
--R   [29] (ThreeDimensionalMatrix(D1),NonNegativeInteger,
--R            NonNegativeInteger,NonNegativeInteger) -> D1
--R             from ThreeDimensionalMatrix(D1) if D1 has SETCAT
--R   [30] (D,List(Integer),List(Integer)) -> D from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [31] (D,D1) -> D1 from D if D has PERMCAT(D1) and D1 has SETCAT
--R   [32] (PermutationGroup(D3),NonNegativeInteger) -> Permutation(D3)
--R             from PermutationGroup(D3) if D3 has SETCAT
--R   [33] (D,Integer) -> D1 from D
--R             if D has PLACESC(D1,D3) and D3 has LOCPOWC(D1) and D1 has 
--R            FIELD
--R   [34] (D,Integer) -> D1 from D if D has PRSPCAT(D1) and D1 has FIELD
--R            
--R   [35] (QuadraticForm(D3,D1),DirectProduct(D3,D1)) -> D1
--R             from QuadraticForm(D3,D1) if D3: PI and D1 has FIELD
--R   [36] (D,value) -> D1 from D if D has RCAGG(D1) and D1 has TYPE
--R   [37] (D,Integer,Integer,D1) -> D1 from D
--R             if D has RMATCAT(D3,D4,D1,D5,D6) and D1 has RING and D5
--R             has DIRPCAT(D4,D1) and D6 has DIRPCAT(D3,D1)
--R   [38] (D,Integer,Integer) -> D1 from D
--R             if D has RMATCAT(D3,D4,D1,D5,D6) and D5 has DIRPCAT(D4,D1)
--R            and D6 has DIRPCAT(D3,D1) and D1 has RING
--R   [39] (RewriteRule(D3,D4,D1),D1,PositiveInteger) -> D1
--R             from RewriteRule(D3,D4,D1)
--R             if D3 has SETCAT and D4 has Join(Ring,PatternMatchable(D3)
--R            ,OrderedSet,ConvertibleTo(Pattern(D3))) and D1 has Join(
--R            FunctionSpace(D4),PatternMatchable(D3),ConvertibleTo(
--R            Pattern(D3)))
--R   [40] (Ruleset(D3,D4,D1),D1,PositiveInteger) -> D1 from Ruleset(D3,D4
--R            ,D1)
--R             if D3 has SETCAT and D4 has Join(Ring,PatternMatchable(D3)
--R            ,OrderedSet,ConvertibleTo(Pattern(D3))) and D1 has Join(
--R            FunctionSpace(D4),PatternMatchable(D3),ConvertibleTo(
--R            Pattern(D3)))
--R   [41] (SparseEchelonMatrix(D3,D1),Integer,D3) -> D1
--R             from SparseEchelonMatrix(D3,D1) if D1 has RING and D3 has 
--R            ORDSET
--R   [42] (D,List(Integer)) -> D from D
--R             if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R   [43] (D,Integer) -> D from D
--R             if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R   [44] (D,D) -> D from D if D has SRAGG
--R   [45] (Symbol,List(OutputForm)) -> Symbol from Symbol
--R   [46] (Fraction(D),D1) -> D1 from D
--R             if D has UPOLYC(D1) and D1 has RING and D1 has FIELD
--R   [47] (Fraction(D),Fraction(D)) -> Fraction(D) from D
--R             if D has UPOLYC(D2) and D2 has RING and D2 has INTDOM
--R   [48] (D,D2) -> D1 from D if D has UPSCAT(D1,D2) and D2 has OAMON and
--R            D1 has RING
--R   [49] (D,last) -> D1 from D if D has URAGG(D1) and D1 has TYPE
--R   [50] (D,rest) -> D from D if D has URAGG(D2) and D2 has TYPE
--R   [51] (D,first) -> D1 from D if D has URAGG(D1) and D1 has TYPE
--R
--RThere are 4 unexposed functions called elt :
--R   [1] (EuclideanModularRing(D2,D1,D3,D4,D5,D6),D1) -> D1
--R             from EuclideanModularRing(D2,D1,D3,D4,D5,D6)
--R             if D2 has COMRING and D1 has UPOLYC(D2) and D3 has ABELMON
--R            and D4: ((D1,D3) -> D1) and D5: ((D3,D3) -> Union(D3,
--R            "failed")) and D6: ((D1,D1,D3) -> Union(D1,"failed"))
--R   [2] (OutputForm,List(OutputForm)) -> OutputForm from OutputForm
--R   [3] (BasicOperator,List(Pattern(D3))) -> Pattern(D3) from Pattern(D3
--R            )
--R             if D3 has SETCAT
--R   [4] Reference(D1) -> D1 from Reference(D1) if D1 has TYPE
--R
--RExamples of elt from AffineSpaceCategory
--R
--R
--RExamples of elt from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Relt(arr,1,1,6) 
--Relt(arr,1,10,6)
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Relt(arr,1,1)
--R
--R
--RExamples of elt from BinaryRecursiveAggregate
--R
--R
--RExamples of elt from CartesianTensor
--R
--Rv:=[2,3] 
--Rtv:CartesianTensor(1,2,Integer):=v 
--Rtm:CartesianTensor(1,2,Integer):=[tv,tv] 
--Rtn:CartesianTensor(1,2,Integer):=[tm,tm] 
--Rtp:CartesianTensor(1,2,Integer):=[tn,tn] 
--Rtq:CartesianTensor(1,2,Integer):=[tp,tp] 
--Relt(tq,[2,2,2,2,2])
--R
--Rv:=[2,3] 
--Rtv:CartesianTensor(1,2,Integer):=v 
--Rtm:CartesianTensor(1,2,Integer):=[tv,tv] 
--Rtn:CartesianTensor(1,2,Integer):=[tm,tm] 
--Rtp:CartesianTensor(1,2,Integer):=[tn,tn] 
--Relt(tp,2,2,2,2) 
--Rtp[2,2,2,2]
--R
--Rv:=[2,3] 
--Rtv:CartesianTensor(1,2,Integer):=v 
--Rtm:CartesianTensor(1,2,Integer):=[tv,tv] 
--Rtn:CartesianTensor(1,2,Integer):=[tm,tm] 
--Relt(tn,2,2,2) 
--Rtn[2,2,2]
--R
--Rv:=[2,3] 
--Rtv:CartesianTensor(1,2,Integer):=v 
--Rtm:CartesianTensor(1,2,Integer):=[tv,tv] 
--Relt(tm,2,2) 
--Rtm[2,2]
--R
--Rv:=[2,3] 
--Rtv:CartesianTensor(1,2,Integer):=v 
--Relt(tv,2) 
--Rtv[2]
--R
--Rtv:CartesianTensor(1,2,Integer):=8 
--Relt(tv) 
--Rtv[]
--R
--R
--RExamples of elt from Database
--R
--R
--RExamples of elt from DataList
--R
--R
--RExamples of elt from Eltable
--R
--R
--RExamples of elt from EltableAggregate
--R
--R
--RExamples of elt from EuclideanModularRing
--R
--R
--RExamples of elt from ExpressionSpace
--R
--R
--RExamples of elt from FunctionFieldCategory
--R
--R
--RExamples of elt from FramedNonAssociativeAlgebra
--R
--R
--RExamples of elt from IndexCard
--R
--R
--RExamples of elt from Library
--R
--R
--RExamples of elt from LinearAggregate
--R
--R
--RExamples of elt from ThreeDimensionalMatrix
--R
--R
--RExamples of elt from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Relt(m,3,3)
--R
--R
--RExamples of elt from OutputForm
--R
--R
--RExamples of elt from Pattern
--R
--R
--RExamples of elt from PermutationCategory
--R
--R
--RExamples of elt from PermutationGroup
--R
--R
--RExamples of elt from PlacesCategory
--R
--R
--RExamples of elt from ProjectiveSpaceCategory
--R
--R
--RExamples of elt from QuadraticForm
--R
--R
--RExamples of elt from RecursiveAggregate
--R
--R
--RExamples of elt from Reference
--R
--R
--RExamples of elt from RectangularMatrixCategory
--R
--R
--RExamples of elt from RewriteRule
--R
--R
--RExamples of elt from Ruleset
--R
--R
--RExamples of elt from SparseEchelonMatrix
--R
--R
--RExamples of elt from SExpressionCategory
--R
--R
--RExamples of elt from StringAggregate
--R
--R
--RExamples of elt from Symbol
--R
--Relt(S,[a1,a2]) 
--Rs([a1,a2])
--R
--R
--RExamples of elt from UnivariatePolynomialCategory
--R
--R
--RExamples of elt from UnivariatePowerSeriesCategory
--R
--R
--RExamples of elt from UnaryRecursiveAggregate
--R
--Rt1:=[1,2,3] 
--Rt1.last
--R
--Rt1:=[1,2,3] 
--Rt1.rest
--R
--Rt1:=[1,2,3] 
--Rt1.first
--R
--E 827

--S 828 of 3320
)d op empty
--R 
--R
--RThere are 8 exposed functions called empty :
--R   [1]  -> D from D if D has AGG
--R   [2]  -> ArrayStack(D1) from ArrayStack(D1) if D1 has SETCAT
--R   [3]  -> Dequeue(D1) from Dequeue(D1) if D1 has SETCAT
--R   [4]  -> Heap(D1) from Heap(D1) if D1 has ORDSET
--R   [5]  -> Queue(D1) from Queue(D1) if D1 has SETCAT
--R   [6]  -> Stack(D1) from Stack(D1) if D1 has SETCAT
--R   [7]  -> TheSymbolTable from TheSymbolTable
--R   [8]  -> SymbolTable from SymbolTable
--R
--RThere are 3 unexposed functions called empty :
--R   [1]  -> OutputForm from OutputForm
--R   [2]  -> QuasiAlgebraicSet(D1,D2,D3,D4) from QuasiAlgebraicSet(D1,D2,
--R            D3,D4)
--R             if D1 has GCDDOM and D2 has ORDSET and D3 has OAMONS and 
--R            D4 has POLYCAT(D1,D3,D2)
--R   [3]  -> SplittingNode(D1,D2) from SplittingNode(D1,D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of empty from Aggregate
--R
--R
--RExamples of empty from ArrayStack
--R
--Rb:=empty()$(ArrayStack INT)
--R
--R
--RExamples of empty from Dequeue
--R
--Rb:=empty()$(Dequeue INT)
--R
--R
--RExamples of empty from Heap
--R
--Rb:=empty()$(Heap INT)
--R
--R
--RExamples of empty from OutputForm
--R
--R
--RExamples of empty from QuasiAlgebraicSet
--R
--R
--RExamples of empty from Queue
--R
--Rb:=empty()$(Queue INT)
--R
--R
--RExamples of empty from SplittingNode
--R
--R
--RExamples of empty from Stack
--R
--Rb:=empty()$(Stack INT)
--R
--R
--RExamples of empty from TheSymbolTable
--R
--R
--RExamples of empty from SymbolTable
--R
--E 828

--S 829 of 3320
)d op empty?
--R 
--R
--RThere are 6 exposed functions called empty? :
--R   [1] D -> Boolean from D if D has AGG
--R   [2] ArrayStack(D2) -> Boolean from ArrayStack(D2) if D2 has SETCAT
--R         
--R   [3] Dequeue(D2) -> Boolean from Dequeue(D2) if D2 has SETCAT
--R   [4] Heap(D2) -> Boolean from Heap(D2) if D2 has ORDSET
--R   [5] Queue(D2) -> Boolean from Queue(D2) if D2 has SETCAT
--R   [6] Stack(D2) -> Boolean from Stack(D2) if D2 has SETCAT
--R
--RThere are 2 unexposed functions called empty? :
--R   [1] QuasiAlgebraicSet(D2,D3,D4,D5) -> Boolean
--R             from QuasiAlgebraicSet(D2,D3,D4,D5)
--R             if D2 has GCDDOM and D3 has ORDSET and D4 has OAMONS and 
--R            D5 has POLYCAT(D2,D4,D3)
--R   [2] SplittingNode(D2,D3) -> Boolean from SplittingNode(D2,D3)
--R             if D2 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of empty? from Aggregate
--R
--R
--RExamples of empty? from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rempty? a
--R
--R
--RExamples of empty? from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rempty? a
--R
--R
--RExamples of empty? from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rempty? a
--R
--R
--RExamples of empty? from QuasiAlgebraicSet
--R
--R
--RExamples of empty? from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rempty? a
--R
--R
--RExamples of empty? from SplittingNode
--R
--R
--RExamples of empty? from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rempty? a
--R
--E 829

--S 830 of 3320
)d op En
--R 
--R
--RThere is one exposed function called En :
--R   [1] (Integer,DoubleFloat) -> OnePointCompletion(DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R
--RExamples of En from DoubleFloatSpecialFunctions
--R
--E 830

--S 831 of 3320
)d op encode
--R 
--R
--RThere is one exposed function called encode :
--R   [1] DesingTree(D2) -> String from DesingTree(D2) if D2 has SETCAT
--R         
--R
--RExamples of encode from DesingTree
--R
--E 831

--S 832 of 3320
)d op endOfFile?
--R 
--R
--RThere is one exposed function called endOfFile? :
--R   [1] TextFile -> Boolean from TextFile
--R
--RExamples of endOfFile? from TextFile
--R
--E 832

--S 833 of 3320
)d op endSubProgram
--R 
--R
--RThere is one exposed function called endSubProgram :
--R   [1]  -> Symbol from TheSymbolTable
--R
--RExamples of endSubProgram from TheSymbolTable
--R
--E 833

--S 834 of 3320
)d op enqueue!
--R 
--R
--RThere are 3 exposed functions called enqueue! :
--R   [1] (D1,Dequeue(D1)) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [2] (D1,D) -> D1 from D if D has QUAGG(D1) and D1 has TYPE
--R   [3] (D1,Queue(D1)) -> D1 from Queue(D1) if D1 has SETCAT
--R
--RExamples of enqueue! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Renqueue! (9,a) 
--Ra
--R
--R
--RExamples of enqueue! from QueueAggregate
--R
--R
--RExamples of enqueue! from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Renqueue! (9,a) 
--Ra
--R
--E 834

--S 835 of 3320
)d op enterInCache
--R 
--R
--RThere are 2 unexposed functions called enterInCache :
--R   [1] (D1,(D1 -> Boolean)) -> D1 from SortedCache(D1) if D1 has 
--R            CACHSET
--R   [2] (D1,((D1,D1) -> Integer)) -> D1 from SortedCache(D1) if D1 has 
--R            CACHSET
--R
--RExamples of enterInCache from SortedCache
--R
--E 835

--S 836 of 3320
)d op enterPointData
--R 
--R
--RThere is one exposed function called enterPointData :
--R   [1] (D,List(Point(D3))) -> NonNegativeInteger from D
--R             if D has SPACEC(D3) and D3 has RING
--R
--RExamples of enterPointData from ThreeSpaceCategory
--R
--E 836

--S 837 of 3320
)d op entries
--R 
--R
--RThere are 2 exposed functions called entries :
--R   [1] IntegrationFunctionsTable -> List(Record(key: Record(var: Symbol
--R            ,fn: Expression(DoubleFloat),range: Segment(OrderedCompletion(
--R            DoubleFloat)),abserr: DoubleFloat,relerr: DoubleFloat),entry: 
--R            Record(endPointContinuity: Union(continuous: 
--R            Continuous at the end points,lowerSingular: 
--R            There is a singularity at the lower end point,upperSingular: 
--R            There is a singularity at the upper end point,bothSingular: 
--R            There are singularities at both end points,notEvaluated: 
--R            End point continuity not yet evaluated),singularitiesStream: 
--R            Union(str: Stream(DoubleFloat),notEvaluated: 
--R            Internal singularities not yet evaluated),range: Union(finite: 
--R            The range is finite,lowerInfinite: 
--R            The bottom of range is infinite,upperInfinite: 
--R            The top of range is infinite,bothInfinite: 
--R            Both top and bottom points are infinite,notEvaluated: 
--R            Range not yet evaluated))))
--R             from IntegrationFunctionsTable
--R   [2] D -> List(D3) from D if D has IXAGG(D2,D3) and D2 has SETCAT and
--R            D3 has TYPE
--R
--RExamples of entries from IntegrationFunctionsTable
--R
--R
--RExamples of entries from IndexedAggregate
--R
--E 837

--S 838 of 3320
)d op entry
--R 
--R
--RThere is one exposed function called entry :
--R   [1] Record(var: Symbol,fn: Expression(DoubleFloat),range: Segment(
--R            OrderedCompletion(DoubleFloat)),abserr: DoubleFloat,relerr: 
--R            DoubleFloat) -> Record(endPointContinuity: Union(continuous: 
--R            Continuous at the end points,lowerSingular: 
--R            There is a singularity at the lower end point,upperSingular: 
--R            There is a singularity at the upper end point,bothSingular: 
--R            There are singularities at both end points,notEvaluated: 
--R            End point continuity not yet evaluated),singularitiesStream: 
--R            Union(str: Stream(DoubleFloat),notEvaluated: 
--R            Internal singularities not yet evaluated),range: Union(finite: 
--R            The range is finite,lowerInfinite: 
--R            The bottom of range is infinite,upperInfinite: 
--R            The top of range is infinite,bothInfinite: 
--R            Both top and bottom points are infinite,notEvaluated: 
--R            Range not yet evaluated))
--R             from IntegrationFunctionsTable
--R
--RExamples of entry from IntegrationFunctionsTable
--R
--E 838

--S 839 of 3320
)d op entry?
--R 
--R
--RThere is one exposed function called entry? :
--R   [1] (D2,D) -> Boolean from D
--R             if D has finiteAggregate and D has IXAGG(D3,D2) and D3
--R             has SETCAT and D2 has TYPE and D2 has SETCAT
--R
--RExamples of entry? from IndexedAggregate
--R
--E 839

--S 840 of 3320
)d op enumerate
--R 
--R
--RThere is one exposed function called enumerate :
--R   [1]  -> List(D) from D if D has FINITE
--R
--RThere is one unexposed function called enumerate :
--R   [1]  -> Vector(SetOfMIntegersInOneToN(D2,D3))
--R             from SetOfMIntegersInOneToN(D2,D3) if D2: PI and D3: PI
--R         
--R
--RExamples of enumerate from Finite
--R
--Renumerate()$OrderedVariableList([p,q])
--R
--R
--RExamples of enumerate from SetOfMIntegersInOneToN
--R
--E 840

--S 841 of 3320
)d op epilogue
--R 
--R
--RThere are 2 exposed functions called epilogue :
--R   [1] ScriptFormulaFormat -> List(String) from ScriptFormulaFormat
--R   [2] TexFormat -> List(String) from TexFormat
--R
--RExamples of epilogue from ScriptFormulaFormat
--R
--R
--RExamples of epilogue from TexFormat
--R
--E 841

--S 842 of 3320
)d op eq
--R 
--R
--RThere is one exposed function called eq :
--R   [1] (D,D) -> Boolean from D
--R             if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R
--RExamples of eq from SExpressionCategory
--R
--E 842

--S 843 of 3320
)d op eq?
--R 
--R
--RThere are 6 exposed functions called eq? :
--R   [1] (D,D) -> Boolean from D if D has AGG
--R   [2] (ArrayStack(D2),ArrayStack(D2)) -> Boolean from ArrayStack(D2)
--R             if D2 has SETCAT
--R   [3] (Dequeue(D2),Dequeue(D2)) -> Boolean from Dequeue(D2) if D2 has 
--R            SETCAT
--R   [4] (Heap(D2),Heap(D2)) -> Boolean from Heap(D2) if D2 has ORDSET
--R         
--R   [5] (Queue(D2),Queue(D2)) -> Boolean from Queue(D2) if D2 has SETCAT
--R            
--R   [6] (Stack(D2),Stack(D2)) -> Boolean from Stack(D2) if D2 has SETCAT
--R            
--R
--RExamples of eq? from Aggregate
--R
--R
--RExamples of eq? from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rb:=copy a 
--Req?(a,b)
--R
--R
--RExamples of eq? from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rb:=copy a 
--Req?(a,b)
--R
--R
--RExamples of eq? from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rb:=copy a 
--Req?(a,b)
--R
--R
--RExamples of eq? from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rb:=copy a 
--Req?(a,b)
--R
--R
--RExamples of eq? from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rb:=copy a 
--Req?(a,b)
--R
--E 843

--S 844 of 3320
)d op EQ
--R 
--R
--RThere is one exposed function called EQ :
--R   [1] (Union(I: Expression(Integer),F: Expression(Float),CF: 
--R            Expression(Complex(Float)),switch: Switch),Union(I: Expression(
--R            Integer),F: Expression(Float),CF: Expression(Complex(Float)),
--R            switch: Switch)) -> Switch
--R             from Switch
--R
--RExamples of EQ from Switch
--R
--E 844

--S 845 of 3320
)d op equality
--R 
--R
--RThere is one exposed function called equality :
--R   [1] (BasicOperator,((BasicOperator,BasicOperator) -> Boolean)) -> 
--R            BasicOperator
--R             from BasicOperator
--R
--RExamples of equality from BasicOperator
--R
--E 845

--S 846 of 3320
)d op equation
--R 
--R
--RThere are 5 exposed functions called equation :
--R   [1] (D1,D1) -> Equation(D1) from Equation(D1) if D1 has TYPE
--R   [2] (Symbol,String) -> QueryEquation from QueryEquation
--R   [3] (D2,StochasticDifferential(D2)) -> Union(Equation(
--R            StochasticDifferential(D2)),"failed")
--R             from StochasticDifferential(D2)
--R             if D2 has Join(OrderedSet,IntegralDomain)
--R   [4] (StochasticDifferential(D2),D2) -> Union(Equation(
--R            StochasticDifferential(D2)),"failed")
--R             from StochasticDifferential(D2)
--R             if D2 has Join(OrderedSet,IntegralDomain)
--R   [5] (Symbol,Segment(D3)) -> SegmentBinding(D3) from SegmentBinding(
--R            D3)
--R             if D3 has TYPE
--R
--RExamples of equation from Equation
--R
--R
--RExamples of equation from QueryEquation
--R
--R
--RExamples of equation from StochasticDifferential
--R
--R
--RExamples of equation from SegmentBinding
--R
--E 846

--S 847 of 3320
)d op erf
--R 
--R
--RThere is one exposed function called erf :
--R   [1] D -> D from D if D has LFCAT
--R
--RThere is one unexposed function called erf :
--R   [1] D1 -> D1 from LiouvillianFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R
--RExamples of erf from LiouvillianFunctionCategory
--R
--R
--RExamples of erf from LiouvillianFunction
--R
--E 847

--S 848 of 3320
)d op error
--R 
--R
--RThere are 4 exposed functions called error :
--R   [1] String -> Exit from ErrorFunctions
--R   [2] List(String) -> Exit from ErrorFunctions
--R   [3] (String,String) -> Exit from ErrorFunctions
--R   [4] (String,List(String)) -> Exit from ErrorFunctions
--R
--RExamples of error from ErrorFunctions
--R
--E 848

--S 849 of 3320
)d op errorInfo
--R 
--R
--RThere is one exposed function called errorInfo :
--R   [1] OpenMathError -> List(Symbol) from OpenMathError
--R
--RExamples of errorInfo from OpenMathError
--R
--E 849

--S 850 of 3320
)d op errorKind
--R 
--R
--RThere is one exposed function called errorKind :
--R   [1] OpenMathError -> OpenMathErrorKind from OpenMathError
--R
--RExamples of errorKind from OpenMathError
--R
--E 850

--S 851 of 33 done20
)d op escape
--R 
--R
--RThere is one exposed function called escape :
--R   [1]  -> Character from Character
--R
--RExamples of escape from Character
--R
--Rescape()
--R
--E 851

--S 852 of 3320 done
)d op euclideanGroebner
--R 
--R
--RThere are 3 exposed functions called euclideanGroebner :
--R   [1] List(D5) -> List(D5) from EuclideanGroebnerBasisPackage(D2,D3,D4
--R            ,D5)
--R             if D5 has POLYCAT(D2,D3,D4) and D2 has EUCDOM and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [2] (List(D6),String) -> List(D6)
--R             from EuclideanGroebnerBasisPackage(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D4,D5) and D3 has EUCDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [3] (List(D6),String,String) -> List(D6)
--R             from EuclideanGroebnerBasisPackage(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D4,D5) and D3 has EUCDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R
--RExamples of euclideanGroebner from EuclideanGroebnerBasisPackage
--R
--Ra1:DMP([y,x],INT):= (9*x**2 + 5*x - 3)+ y*(3*x**2 + 2*x + 1) 
--Ra2:DMP([y,x],INT):= (6*x**3 - 2*x**2 - 3*x +3) + y*(2*x**3 - x - 1) 
--Ra3:DMP([y,x],INT):= (3*x**3 + 2*x**2) + y*(x**3 + x**2) 
--Ran:=[a1,a2,a3] 
--ReuclideanGroebner(an,"info","redcrit")
--R
--Ra1:DMP([y,x],INT):= (9*x**2 + 5*x - 3)+ y*(3*x**2 + 2*x + 1) 
--Ra2:DMP([y,x],INT):= (6*x**3 - 2*x**2 - 3*x +3) + y*(2*x**3 - x - 1) 
--Ra3:DMP([y,x],INT):= (3*x**3 + 2*x**2) + y*(x**3 + x**2) 
--Ran:=[a1,a2,a3] 
--ReuclideanGroebner(an,"redcrit") 
--ReuclideanGroebner(an,"info")
--R
--Ra1:DMP([y,x],INT):= (9*x**2 + 5*x - 3)+ y*(3*x**2 + 2*x + 1) 
--Ra2:DMP([y,x],INT):= (6*x**3 - 2*x**2 - 3*x +3) + y*(2*x**3 - x - 1) 
--Ra3:DMP([y,x],INT):= (3*x**3 + 2*x**2) + y*(x**3 + x**2) 
--Ran:=[a1,a2,a3] 
--ReuclideanGroebner(an)
--R
--E 852

--S 853 of 3320
)d op euclideanNormalForm
--R 
--R
--RThere is one exposed function called euclideanNormalForm :
--R   [1] (D1,List(D1)) -> D1 from EuclideanGroebnerBasisPackage(D3,D4,D5,
--R            D1)
--R             if D1 has POLYCAT(D3,D4,D5) and D3 has EUCDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R
--RExamples of euclideanNormalForm from EuclideanGroebnerBasisPackage
--R
--E 853

--S 854 of 3320
)d op euclideanSize
--R 
--R
--RThere is one exposed function called euclideanSize :
--R   [1] D -> NonNegativeInteger from D if D has EUCDOM
--R
--RExamples of euclideanSize from EuclideanDomain
--R
--E 854

--S 855 of 3320
)d op euler
--R 
--R
--RThere is one exposed function called euler :
--R   [1] Integer -> Integer from IntegerNumberTheoryFunctions
--R
--RThere is one unexposed function called euler :
--R   [1] Integer -> SparseUnivariatePolynomial(Fraction(Integer))
--R             from PolynomialNumberTheoryFunctions
--R
--RExamples of euler from IntegerNumberTheoryFunctions
--R
--R
--RExamples of euler from PolynomialNumberTheoryFunctions
--R
--E 855

--S 856 of 3320
)d op eulerE
--R 
--R
--RThere is one exposed function called eulerE :
--R   [1] (NonNegativeInteger,D1) -> D1 from 
--R            NumberTheoreticPolynomialFunctions(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has COMRING
--R
--RExamples of eulerE from NumberTheoreticPolynomialFunctions
--R
--E 856

--S 857 of 3320
)d op eulerPhi
--R 
--R
--RThere is one exposed function called eulerPhi :
--R   [1] Integer -> Integer from IntegerNumberTheoryFunctions
--R
--RExamples of eulerPhi from IntegerNumberTheoryFunctions
--R
--E 857

--S 858 of 3320
)d op eval
--R 
--R
--RThere are 43 exposed functions called eval :
--R   [1] SymmetricPolynomial(Fraction(Integer)) -> Fraction(Integer)
--R             from CycleIndicators
--R   [2] (Matrix(Expression(DoubleFloat)),List(Symbol),Vector(Expression(
--R            DoubleFloat))) -> Matrix(Expression(DoubleFloat))
--R             from d02AgentsPackage
--R   [3] (Equation(D2),List(Equation(D2))) -> Equation(D2) from Equation(
--R            D2)
--R             if D2 has EVALAB(D2) and D2 has SETCAT and D2 has TYPE
--R   [4] (Equation(D1),Equation(D1)) -> Equation(D1) from Equation(D1)
--R             if D1 has EVALAB(D1) and D1 has SETCAT and D1 has TYPE
--R   [5] (D,BasicOperator,(D -> D)) -> D from D if D has ES
--R   [6] (D,BasicOperator,(List(D) -> D)) -> D from D if D has ES
--R   [7] (D,List(BasicOperator),List((List(D) -> D))) -> D from D if D
--R             has ES
--R   [8] (D,List(BasicOperator),List((D -> D))) -> D from D if D has ES
--R         
--R   [9] (D,Symbol,(D -> D)) -> D from D if D has ES
--R   [10] (D,Symbol,(List(D) -> D)) -> D from D if D has ES
--R   [11] (D,List(Symbol),List((List(D) -> D))) -> D from D if D has ES
--R         
--R   [12] (D,List(Symbol),List((D -> D))) -> D from D if D has ES
--R   [13] (D,List(Equation(D2))) -> D from D if D has EVALAB(D2) and D2
--R             has SETCAT
--R   [14] (D,Equation(D2)) -> D from D if D has EVALAB(D2) and D2 has 
--R            SETCAT
--R   [15] (D,List(D3),List(D)) -> D from D
--R             if D has FLALG(D3,D4) and D3 has ORDSET and D4 has COMRING
--R            
--R   [16] (D,D1,D) -> D from D
--R             if D has FLALG(D1,D2) and D1 has ORDSET and D2 has COMRING
--R            
--R   [17] (D,Symbol,NonNegativeInteger,(D -> D)) -> D from D
--R             if D has FS(D4) and D4 has ORDSET and D4 has RING
--R   [18] (D,Symbol,NonNegativeInteger,(List(D) -> D)) -> D from D
--R             if D has FS(D4) and D4 has ORDSET and D4 has RING
--R   [19] (D,List(Symbol),List(NonNegativeInteger),List((List(D) -> D)))
--R             -> D
--R             from D if D has FS(D4) and D4 has ORDSET and D4 has RING
--R         
--R   [20] (D,List(Symbol),List(NonNegativeInteger),List((D -> D))) -> D
--R             from D
--R             if D has FS(D4) and D4 has ORDSET and D4 has RING
--R   [21] (D,List(BasicOperator),List(D),Symbol) -> D from D
--R             if D has FS(D4) and D4 has ORDSET and D4 has KONVERT(
--R            INFORM)
--R   [22] (D,BasicOperator,D,Symbol) -> D from D
--R             if D has FS(D3) and D3 has ORDSET and D3 has KONVERT(
--R            INFORM)
--R   [23] D -> D from D if D has FS(D1) and D1 has ORDSET and D1 has 
--R            KONVERT(INFORM)
--R   [24] (D,List(Symbol)) -> D from D
--R             if D has FS(D2) and D2 has ORDSET and D2 has KONVERT(
--R            INFORM)
--R   [25] (D,Symbol) -> D from D
--R             if D has FS(D2) and D2 has ORDSET and D2 has KONVERT(
--R            INFORM)
--R   [26] (D5,D6) -> D4
--R             from GeneralPackageForAlgebraicFunctionField(D4,D7,D5,D8,
--R            D9,D10,D6,D11,D1,D2,D3)
--R             if D7: LIST(SYMBOL) and D5 has POLYCAT(D4,D8,OVAR(D7)) and
--R            D8 has DIRPCAT(#(D7),NNI) and D9 has PRSPCAT(D4) and D10
--R             has LOCPOWC(D4) and D6 has PLACESC(D4,D10) and D11 has 
--R            DIVCAT(D6) and D1 has INFCLCT(D4,D7,D5,D8,D9,D10,D6,D11,D3)
--R            and D3 has BLMETCT and D4 has FIELD and D2 has DSTRCAT(D1)
--R            
--R   [27] (D5,D5,D6) -> D4
--R             from GeneralPackageForAlgebraicFunctionField(D4,D7,D5,D8,
--R            D9,D10,D6,D11,D1,D2,D3)
--R             if D7: LIST(SYMBOL) and D5 has POLYCAT(D4,D8,OVAR(D7)) and
--R            D8 has DIRPCAT(#(D7),NNI) and D9 has PRSPCAT(D4) and D10
--R             has LOCPOWC(D4) and D6 has PLACESC(D4,D10) and D11 has 
--R            DIVCAT(D6) and D1 has INFCLCT(D4,D7,D5,D8,D9,D10,D6,D11,D3)
--R            and D3 has BLMETCT and D4 has FIELD and D2 has DSTRCAT(D1)
--R            
--R   [28] (Fraction(D9),D7) -> D5
--R             from GeneralPackageForAlgebraicFunctionField(D5,D8,D9,D10,
--R            D11,D12,D7,D1,D2,D3,D4)
--R             if D9 has POLYCAT(D5,D10,OVAR(D8)) and D10 has DIRPCAT(#(
--R            D8),NNI) and D8: LIST(SYMBOL) and D11 has PRSPCAT(D5) and 
--R            D12 has LOCPOWC(D5) and D7 has PLACESC(D5,D12) and D1 has 
--R            DIVCAT(D7) and D2 has INFCLCT(D5,D8,D9,D10,D11,D12,D7,D1,D4
--R            ) and D4 has BLMETCT and D5 has FIELD and D3 has DSTRCAT(D2
--R            )
--R   [29] (D,D1,D2) -> D from D
--R             if D has IEVALAB(D1,D2) and D1 has SETCAT and D2 has TYPE
--R            
--R   [30] (D,List(D3),List(D4)) -> D from D
--R             if D has IEVALAB(D3,D4) and D3 has SETCAT and D4 has TYPE
--R            
--R   [31] (DistributedMultivariatePolynomial(D4,D1),
--R            PlacesOverPseudoAlgebraicClosureOfFiniteField(D1)) -> D1
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D1,D4
--R            ,D5)
--R             if D4: LIST(SYMBOL) and D1 has FFIELDC and D5 has BLMETCT
--R            
--R   [32] (DistributedMultivariatePolynomial(D4,D1),
--R            DistributedMultivariatePolynomial(D4,D1),
--R            PlacesOverPseudoAlgebraicClosureOfFiniteField(D1)) -> D1
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D1,D4
--R            ,D5)
--R             if D4: LIST(SYMBOL) and D1 has FFIELDC and D5 has BLMETCT
--R            
--R   [33] (Fraction(DistributedMultivariatePolynomial(D4,D1)),
--R            PlacesOverPseudoAlgebraicClosureOfFiniteField(D1)) -> D1
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D1,D4
--R            ,D5)
--R             if D4: LIST(SYMBOL) and D1 has FFIELDC and D5 has BLMETCT
--R            
--R   [34] (DistributedMultivariatePolynomial(D4,D1),Places(D1)) -> D1
--R             from PackageForAlgebraicFunctionField(D1,D4,D5)
--R             if D4: LIST(SYMBOL) and D1 has FIELD and D5 has BLMETCT
--R         
--R   [35] (DistributedMultivariatePolynomial(D4,D1),
--R            DistributedMultivariatePolynomial(D4,D1),Places(D1)) -> D1
--R             from PackageForAlgebraicFunctionField(D1,D4,D5)
--R             if D4: LIST(SYMBOL) and D1 has FIELD and D5 has BLMETCT
--R         
--R   [36] (Fraction(DistributedMultivariatePolynomial(D4,D1)),Places(D1))
--R             -> D1
--R             from PackageForAlgebraicFunctionField(D1,D4,D5)
--R             if D4: LIST(SYMBOL) and D1 has FIELD and D5 has BLMETCT
--R         
--R   [37] (D,D1) -> D1 from D if D has PERMCAT(D1) and D1 has SETCAT
--R   [38] (D2,D3) -> D1 from PolynomialPackageForCurve(D1,D2,D4,D5,D3)
--R             if D4 has DIRPCAT(D5,NNI) and D5: NNI and D1 has FIELD and
--R            D2 has FAMR(D1,D4) and D3 has PRSPCAT(D1)
--R   [39] (Fraction(Polynomial(D3)),Symbol,Fraction(Polynomial(D3))) -> 
--R            Fraction(Polynomial(D3))
--R             from RationalFunction(D3) if D3 has INTDOM
--R   [40] (Fraction(Polynomial(D4)),List(Symbol),List(Fraction(Polynomial
--R            (D4)))) -> Fraction(Polynomial(D4))
--R             from RationalFunction(D4) if D4 has INTDOM
--R   [41] (Fraction(Polynomial(D3)),Equation(Fraction(Polynomial(D3))))
--R             -> Fraction(Polynomial(D3))
--R             from RationalFunction(D3) if D3 has INTDOM
--R   [42] (Fraction(Polynomial(D3)),List(Equation(Fraction(Polynomial(D3)
--R            )))) -> Fraction(Polynomial(D3))
--R             from RationalFunction(D3) if D3 has INTDOM
--R   [43] (D1,D3) -> Stream(D3) from D1
--R             if D1 has UPSCAT(D3,D4) and D3 has RING and D4 has OAMON 
--R            and D3 has D: (D3,D4) -> D3
--R
--RThere are 5 unexposed functions called eval :
--R   [1] (D1,Fraction(D4),Fraction(D4)) -> D1 from ChangeOfVariable(D3,D4
--R            ,D1)
--R             if D3 has UFD and D4 has UPOLYC(D3) and D1 has UPOLYC(FRAC
--R            (D4))
--R   [2] ((Integer -> D1),SymmetricPolynomial(Fraction(Integer))) -> D1
--R             from EvaluateCycleIndicators(D1) if D1 has ALGEBRA(FRAC(
--R            INT))
--R   [3] (MoebiusTransform(D2),OnePointCompletion(D2)) -> 
--R            OnePointCompletion(D2)
--R             from MoebiusTransform(D2) if D2 has FIELD
--R   [4] (MoebiusTransform(D1),D1) -> D1 from MoebiusTransform(D1) if D1
--R             has FIELD
--R   [5] (Stream(D2),D2) -> Stream(D2) from StreamTaylorSeriesOperations(
--R            D2)
--R             if D2 has RING
--R
--RExamples of eval from ChangeOfVariable
--R
--R
--RExamples of eval from CycleIndicators
--R
--R
--RExamples of eval from d02AgentsPackage
--R
--R
--RExamples of eval from Equation
--R
--R
--RExamples of eval from ExpressionSpace
--R
--R
--RExamples of eval from Evalable
--R
--R
--RExamples of eval from EvaluateCycleIndicators
--R
--R
--RExamples of eval from FreeLieAlgebra
--R
--R
--RExamples of eval from FunctionSpace
--R
--R
--RExamples of eval from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of eval from InnerEvalable
--R
--R
--RExamples of eval from MoebiusTransform
--R
--R
--RExamples of eval from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of eval from PackageForAlgebraicFunctionField
--R
--R
--RExamples of eval from PermutationCategory
--R
--R
--RExamples of eval from PolynomialPackageForCurve
--R
--R
--RExamples of eval from RationalFunction
--R
--R
--RExamples of eval from StreamTaylorSeriesOperations
--R
--R
--RExamples of eval from UnivariatePowerSeriesCategory
--R
--E 858

--S 859 of 3320
)d op evalADE
--R 
--R
--RThere is one exposed function called evalADE :
--R   [1] (BasicOperator,Symbol,D1,D1,D1,List(D1)) -> D1
--R             from RecurrenceOperator(D5,D1)
--R             if D1 has Join(FunctionSpace(D5),AbelianMonoid,
--R            RetractableTo(Integer),RetractableTo(Symbol),
--R            PartialDifferentialRing(Symbol),CombinatorialOpsCategory) 
--R            and D5 has Join(OrderedSet,IntegralDomain,ConvertibleTo(
--R            InputForm))
--R
--RExamples of evalADE from RecurrenceOperator
--R
--E 859

--S 860 of 3320
--R--------------------------- )d op eval_at (fix this)
--E 860

--S 861 of 3320
)d op evalIfCan
--R 
--R
--RThere are 9 exposed functions called evalIfCan :
--R   [1] (D5,D6) -> Union(D4,"failed")
--R             from GeneralPackageForAlgebraicFunctionField(D4,D7,D5,D8,
--R            D9,D10,D6,D11,D1,D2,D3)
--R             if D7: LIST(SYMBOL) and D5 has POLYCAT(D4,D8,OVAR(D7)) and
--R            D8 has DIRPCAT(#(D7),NNI) and D9 has PRSPCAT(D4) and D10
--R             has LOCPOWC(D4) and D6 has PLACESC(D4,D10) and D11 has 
--R            DIVCAT(D6) and D1 has INFCLCT(D4,D7,D5,D8,D9,D10,D6,D11,D3)
--R            and D3 has BLMETCT and D4 has FIELD and D2 has DSTRCAT(D1)
--R            
--R   [2] (D5,D5,D6) -> Union(D4,"failed")
--R             from GeneralPackageForAlgebraicFunctionField(D4,D7,D5,D8,
--R            D9,D10,D6,D11,D1,D2,D3)
--R             if D7: LIST(SYMBOL) and D5 has POLYCAT(D4,D8,OVAR(D7)) and
--R            D8 has DIRPCAT(#(D7),NNI) and D9 has PRSPCAT(D4) and D10
--R             has LOCPOWC(D4) and D6 has PLACESC(D4,D10) and D11 has 
--R            DIVCAT(D6) and D1 has INFCLCT(D4,D7,D5,D8,D9,D10,D6,D11,D3)
--R            and D3 has BLMETCT and D4 has FIELD and D2 has DSTRCAT(D1)
--R            
--R   [3] (Fraction(D9),D7) -> Union(D5,"failed")
--R             from GeneralPackageForAlgebraicFunctionField(D5,D8,D9,D10,
--R            D11,D12,D7,D1,D2,D3,D4)
--R             if D9 has POLYCAT(D5,D10,OVAR(D8)) and D10 has DIRPCAT(#(
--R            D8),NNI) and D8: LIST(SYMBOL) and D11 has PRSPCAT(D5) and 
--R            D12 has LOCPOWC(D5) and D7 has PLACESC(D5,D12) and D1 has 
--R            DIVCAT(D7) and D2 has INFCLCT(D5,D8,D9,D10,D11,D12,D7,D1,D4
--R            ) and D4 has BLMETCT and D5 has FIELD and D3 has DSTRCAT(D2
--R            )
--R   [4] (DistributedMultivariatePolynomial(D4,D1),
--R            PlacesOverPseudoAlgebraicClosureOfFiniteField(D1)) -> Union(D1,
--R            "failed")
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D1,D4
--R            ,D5)
--R             if D4: LIST(SYMBOL) and D1 has FFIELDC and D5 has BLMETCT
--R            
--R   [5] (DistributedMultivariatePolynomial(D4,D1),
--R            DistributedMultivariatePolynomial(D4,D1),
--R            PlacesOverPseudoAlgebraicClosureOfFiniteField(D1)) -> Union(D1,
--R            "failed")
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D1,D4
--R            ,D5)
--R             if D4: LIST(SYMBOL) and D1 has FFIELDC and D5 has BLMETCT
--R            
--R   [6] (Fraction(DistributedMultivariatePolynomial(D4,D1)),
--R            PlacesOverPseudoAlgebraicClosureOfFiniteField(D1)) -> Union(D1,
--R            "failed")
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D1,D4
--R            ,D5)
--R             if D4: LIST(SYMBOL) and D1 has FFIELDC and D5 has BLMETCT
--R            
--R   [7] (DistributedMultivariatePolynomial(D4,D1),Places(D1)) -> Union(
--R            D1,"failed")
--R             from PackageForAlgebraicFunctionField(D1,D4,D5)
--R             if D4: LIST(SYMBOL) and D1 has FIELD and D5 has BLMETCT
--R         
--R   [8] (DistributedMultivariatePolynomial(D4,D1),
--R            DistributedMultivariatePolynomial(D4,D1),Places(D1)) -> Union(D1,
--R            "failed")
--R             from PackageForAlgebraicFunctionField(D1,D4,D5)
--R             if D4: LIST(SYMBOL) and D1 has FIELD and D5 has BLMETCT
--R         
--R   [9] (Fraction(DistributedMultivariatePolynomial(D4,D1)),Places(D1))
--R             -> Union(D1,"failed")
--R             from PackageForAlgebraicFunctionField(D1,D4,D5)
--R             if D4: LIST(SYMBOL) and D1 has FIELD and D5 has BLMETCT
--R         
--R
--RExamples of evalIfCan from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of evalIfCan from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of evalIfCan from PackageForAlgebraicFunctionField
--R
--E 861

--S 862 of 3320
)d op evalRec
--R 
--R
--RThere is one exposed function called evalRec :
--R   [1] (BasicOperator,Symbol,D1,D1,D1,List(D1)) -> D1
--R             from RecurrenceOperator(D5,D1)
--R             if D1 has Join(FunctionSpace(D5),AbelianMonoid,
--R            RetractableTo(Integer),RetractableTo(Symbol),
--R            PartialDifferentialRing(Symbol),CombinatorialOpsCategory) 
--R            and D5 has Join(OrderedSet,IntegralDomain,ConvertibleTo(
--R            InputForm))
--R
--RExamples of evalRec from RecurrenceOperator
--R
--E 862

--S 863 of 3320
)d op evaluate
--R 
--R
--RThere are 5 exposed functions called evaluate :
--R   [1] (BasicOperator,List(D1)) -> Union(D1,"failed")
--R             from BasicOperatorFunctions1(D1) if D1 has SETCAT
--R   [2] (BasicOperator,(List(D3) -> D3)) -> BasicOperator
--R             from BasicOperatorFunctions1(D3) if D3 has SETCAT
--R   [3] (BasicOperator,(D3 -> D3)) -> BasicOperator
--R             from BasicOperatorFunctions1(D3) if D3 has SETCAT
--R   [4] BasicOperator -> Union((List(D3) -> D3),"failed")
--R             from BasicOperatorFunctions1(D3) if D3 has SETCAT
--R   [5] (ModuleOperator(D2,D3),(D3 -> D3)) -> ModuleOperator(D2,D3)
--R             from ModuleOperator(D2,D3) if D3 has LMODULE(D2) and D2
--R             has RING
--R
--RThere is one unexposed function called evaluate :
--R   [1] (Operator(D2),(D2 -> D2)) -> Operator(D2) from Operator(D2) if 
--R            D2 has RING
--R
--RExamples of evaluate from BasicOperatorFunctions1
--R
--R
--RExamples of evaluate from ModuleOperator
--R
--R
--RExamples of evaluate from Operator
--R
--E 863

--S 864 of 3320
)d op evaluateInverse
--R 
--R
--RThere is one exposed function called evaluateInverse :
--R   [1] (ModuleOperator(D2,D3),(D3 -> D3)) -> ModuleOperator(D2,D3)
--R             from ModuleOperator(D2,D3) if D3 has LMODULE(D2) and D2
--R             has RING
--R
--RThere is one unexposed function called evaluateInverse :
--R   [1] (Operator(D2),(D2 -> D2)) -> Operator(D2) from Operator(D2) if 
--R            D2 has RING
--R
--RExamples of evaluateInverse from ModuleOperator
--R
--R
--RExamples of evaluateInverse from Operator
--R
--E 864

--S 865 of 3320
)d op even?
--R 
--R
--RThere are 3 exposed functions called even? :
--R   [1] D -> Boolean from D if D has RETRACT(INT) and D has ES
--R   [2] D -> Boolean from D if D has INS
--R   [3] Permutation(D2) -> Boolean from Permutation(D2) if D2 has SETCAT
--R            
--R
--RExamples of even? from RetractableTo
--R
--R
--RExamples of even? from IntegerNumberSystem
--R
--R
--RExamples of even? from Permutation
--R
--Rp := coercePreimagesImages([[1,2,3],[1,2,3]]) 
--Reven? p
--R
--E 865

--S 866 of 3320
)d op evenInfiniteProduct
--R 
--R
--RThere are 3 exposed functions called evenInfiniteProduct :
--R   [1] D1 -> D1 from InfiniteProductCharacteristicZero(D2,D1)
--R             if D2 has Join(IntegralDomain,CharacteristicZero) and D1
--R             has UTSCAT(D2)
--R   [2] D1 -> D1 from InfiniteProductFiniteField(D2,D3,D4,D1)
--R             if D2 has Join(Field,Finite,ConvertibleTo(Integer)) and D3
--R             has UPOLYC(D2) and D4 has MONOGEN(D2,D3) and D1 has UTSCAT
--R            (D4)
--R   [3] D1 -> D1 from InfiniteProductPrimeField(D2,D1)
--R             if D2 has Join(Field,Finite,ConvertibleTo(Integer)) and D1
--R             has UTSCAT(D2)
--R
--RThere is one unexposed function called evenInfiniteProduct :
--R   [1] Stream(D2) -> Stream(D2) from StreamInfiniteProduct(D2)
--R             if D2 has Join(IntegralDomain,CharacteristicZero)
--R
--RExamples of evenInfiniteProduct from InfiniteProductCharacteristicZero
--R
--R
--RExamples of evenInfiniteProduct from InfiniteProductFiniteField
--R
--R
--RExamples of evenInfiniteProduct from InfiniteProductPrimeField
--R
--R
--RExamples of evenInfiniteProduct from StreamInfiniteProduct
--R
--E 866

--S 867 of 3320
)d op evenlambert
--R 
--R
--RThere are 2 exposed functions called evenlambert :
--R   [1] UnivariateFormalPowerSeries(D1) -> UnivariateFormalPowerSeries(
--R            D1)
--R             from UnivariateFormalPowerSeries(D1) if D1 has RING
--R   [2] UnivariateTaylorSeriesCZero(D1,D2) -> 
--R            UnivariateTaylorSeriesCZero(D1,D2)
--R             from UnivariateTaylorSeriesCZero(D1,D2) if D1 has RING and
--R            D2: SYMBOL
--R
--RThere are 2 unexposed functions called evenlambert :
--R   [1] Stream(D2) -> Stream(D2) from StreamTaylorSeriesOperations(D2)
--R             if D2 has RING
--R   [2] UnivariateTaylorSeries(D1,D2,D3) -> UnivariateTaylorSeries(D1,D2
--R            ,D3)
--R             from UnivariateTaylorSeries(D1,D2,D3)
--R             if D1 has RING and D2: SYMBOL and D3: D1
--R
--RExamples of evenlambert from StreamTaylorSeriesOperations
--R
--R
--RExamples of evenlambert from UnivariateFormalPowerSeries
--R
--R
--RExamples of evenlambert from UnivariateTaylorSeries
--R
--R
--RExamples of evenlambert from UnivariateTaylorSeriesCZero
--R
--E 867

--S 868 of 3320
)d op every?
--R 
--R
--RThere are 6 exposed functions called every? :
--R   [1] ((D3 -> Boolean),ArrayStack(D3)) -> Boolean from ArrayStack(D3)
--R             if $ has finiteAggregate and D3 has SETCAT
--R   [2] ((D3 -> Boolean),Dequeue(D3)) -> Boolean from Dequeue(D3)
--R             if $ has finiteAggregate and D3 has SETCAT
--R   [3] ((D3 -> Boolean),Heap(D3)) -> Boolean from Heap(D3)
--R             if $ has finiteAggregate and D3 has ORDSET
--R   [4] ((D3 -> Boolean),D) -> Boolean from D
--R             if D has finiteAggregate and D has HOAGG(D3) and D3 has 
--R            TYPE
--R   [5] ((D3 -> Boolean),Queue(D3)) -> Boolean from Queue(D3)
--R             if $ has finiteAggregate and D3 has SETCAT
--R   [6] ((D3 -> Boolean),Stack(D3)) -> Boolean from Stack(D3)
--R             if $ has finiteAggregate and D3 has SETCAT
--R
--RExamples of every? from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Revery?(x+->(x=4),a)
--R
--R
--RExamples of every? from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Revery?(x+->(x=4),a)
--R
--R
--RExamples of every? from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Revery?(x+->(x=4),a)
--R
--R
--RExamples of every? from HomogeneousAggregate
--R
--R
--RExamples of every? from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Revery?(x+->(x=4),a)
--R
--R
--RExamples of every? from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Revery?(x+->(x=4),a)
--R
--E 868

--S 869 of 3320
)d op exactQuotient
--R 
--R
--RThere are 2 exposed functions called exactQuotient :
--R   [1] (D,D) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has INTDOM
--R   [2] (D,D1) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has INTDOM
--R
--RExamples of exactQuotient from RecursivePolynomialCategory
--R
--E 869

--S 870 of 3320
)d op exactQuotient!
--R 
--R
--RThere are 2 exposed functions called exactQuotient! :
--R   [1] (D,D) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has INTDOM
--R   [2] (D,D1) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has INTDOM
--R
--RExamples of exactQuotient! from RecursivePolynomialCategory
--R
--E 870

--S 871 of 3320
)d op excepCoord
--R 
--R
--RThere is one exposed function called excepCoord :
--R   [1] D -> Integer from D if D has BLMETCT
--R
--RExamples of excepCoord from BlowUpMethodCategory
--R
--E 871

--S 872 of 3320
)d op excpDivV
--R 
--R
--RThere is one exposed function called excpDivV :
--R   [1] D -> DIVISOR from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of excpDivV from InfinitlyClosePointCategory
--R
--E 872

--S 873 of 3320
)d op exists?
--R 
--R
--RThere is one exposed function called exists? :
--R   [1] D -> Boolean from D if D has FNCAT
--R
--RExamples of exists? from FileNameCategory
--R
--E 873

--S 874 of 3320
)d op exp
--R 
--R
--RThere are 2 exposed functions called exp :
--R   [1] D -> D from D if D has ELEMFUN
--R   [2] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R
--RThere are 9 unexposed functions called exp :
--R   [1] List(Integer) -> AntiSymm(D2,D3) from AntiSymm(D2,D3)
--R             if D2 has RING and D3: LIST(SYMBOL)
--R   [2] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [4] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [5] LiePolynomial(D2,D3) -> LieExponentials(D2,D3,D4)
--R             from LieExponentials(D2,D3,D4)
--R             if D2 has ORDSET and D3 has Join(CommutativeRing,Module(
--R            Fraction(Integer))) and D4: PI
--R   [6] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [7] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [8] (D1,NonNegativeInteger) -> D1 from XExponentialPackage(D3,D4,D1)
--R             if D3 has Join(Ring,Module(Fraction(Integer))) and D4 has 
--R            ORDSET and D1 has XPOLYC(D4,D3)
--R   [9] (XPBWPolynomial(D2,D3),NonNegativeInteger) -> XPBWPolynomial(D2,
--R            D3)
--R             from XPBWPolynomial(D2,D3)
--R             if D3 has MODULE(FRAC(INT)) and D2 has ORDSET and D3 has 
--R            COMRING
--R
--RExamples of exp from AntiSymm
--R
--R
--RExamples of exp from ElementaryFunction
--R
--R
--RExamples of exp from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of exp from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of exp from ElementaryFunctionCategory
--R
--R
--RExamples of exp from FortranExpression
--R
--R
--RExamples of exp from LieExponentials
--R
--R
--RExamples of exp from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of exp from StreamTranscendentalFunctions
--R
--R
--RExamples of exp from XExponentialPackage
--R
--R
--RExamples of exp from XPBWPolynomial
--R
--E 874

--S 875 of 3320
)d op exp1
--R 
--R
--RThere are 2 exposed functions called exp1 :
--R   [1]  -> DoubleFloat from DoubleFloat
--R   [2]  -> Float from Float
--R
--RExamples of exp1 from DoubleFloat
--R
--R
--RExamples of exp1 from Float
--R
--E 875

--S 876 of 3320
)d op expand
--R 
--R
--RThere are 6 exposed functions called expand :
--R   [1] Factored(D1) -> D1 from Factored(D1) if D1 has INTDOM
--R   [2] IntegrationResult(D4) -> List(D4) from 
--R            IntegrationResultToFunction(D3,D4)
--R             if D4 has Join(AlgebraicallyClosedFunctionSpace(D3),
--R            TranscendentalFunctionCategory) and D3 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,LinearlyExplicitRingOver(
--R            Integer))
--R   [3] IntegrationResult(Fraction(Polynomial(D3))) -> List(Expression(
--R            D3))
--R             from IntegrationResultRFToFunction(D3)
--R             if D3 has Join(GcdDomain,RetractableTo(Integer),OrderedSet
--R            ,LinearlyExplicitRingOver(Integer))
--R   [4] D -> D1 from D if D has SEGXCAT(D2,D1) and D2 has ORDRING and D1
--R             has STAGG(D2)
--R   [5] List(D) -> D1 from D
--R             if D has SEGXCAT(D3,D1) and D3 has ORDRING and D1 has 
--R            STAGG(D3)
--R   [6] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RThere are 3 unexposed functions called expand :
--R   [1] (Expression(D5),PositiveInteger) -> List(Expression(D5))
--R             from DegreeReductionPackage(D4,D5)
--R             if D5 has Join(IntegralDomain,OrderedSet) and D4 has RING
--R            
--R   [2] XPolynomial(D2) -> XDistributedPolynomial(Symbol,D2) from 
--R            XPolynomial(D2)
--R             if D2 has RING
--R   [3] XRecursivePolynomial(D2,D3) -> XDistributedPolynomial(D2,D3)
--R             from XRecursivePolynomial(D2,D3) if D2 has ORDSET and D3
--R             has RING
--R
--RExamples of expand from DegreeReductionPackage
--R
--R
--RExamples of expand from Factored
--R
--Rf:=nilFactor(y-x,3) 
--Rexpand(f)
--R
--R
--RExamples of expand from IntegrationResultToFunction
--R
--R
--RExamples of expand from IntegrationResultRFToFunction
--R
--R
--RExamples of expand from SegmentExpansionCategory
--R
--R
--RExamples of expand from TranscendentalManipulations
--R
--R
--RExamples of expand from XPolynomial
--R
--R
--RExamples of expand from XRecursivePolynomial
--R
--E 876

--S 877 of 3320
)d op expandLog
--R 
--R
--RThere is one exposed function called expandLog :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of expandLog from TranscendentalManipulations
--R
--E 877

--S 878 of 3320
)d op expandPower
--R 
--R
--RThere is one exposed function called expandPower :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of expandPower from TranscendentalManipulations
--R
--E 878

--S 879 of 3320
)d op expandTrigProducts
--R 
--R
--RThere is one exposed function called expandTrigProducts :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has KONVERT(PATTERN(D2)) and D2 has PATMAB(D2) and 
--R            D2 has Join(OrderedSet,GcdDomain) and D1 has KONVERT(
--R            PATTERN(D2)) and D1 has PATMAB(D2) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of expandTrigProducts from TranscendentalManipulations
--R
--E 879

--S 880 of 3320
)d op expenseOfEvaluation
--R 
--R
--RThere are 2 exposed functions called expenseOfEvaluation :
--R   [1] Record(lfn: List(Expression(DoubleFloat)),init: List(DoubleFloat
--R            )) -> Float
--R             from e04AgentsPackage
--R   [2] Vector(Expression(DoubleFloat)) -> Float from 
--R            ExpertSystemToolsPackage
--R
--RExamples of expenseOfEvaluation from e04AgentsPackage
--R
--R
--RExamples of expenseOfEvaluation from ExpertSystemToolsPackage
--R
--E 880

--S 881 of 3320
)d op expenseOfEvaluationIF
--R 
--R
--RThere is one exposed function called expenseOfEvaluationIF :
--R   [1] Record(xinit: DoubleFloat,xend: DoubleFloat,fn: Vector(
--R            Expression(DoubleFloat)),yinit: List(DoubleFloat),intvals: List(
--R            DoubleFloat),g: Expression(DoubleFloat),abserr: DoubleFloat,
--R            relerr: DoubleFloat) -> Float
--R             from d02AgentsPackage
--R
--RExamples of expenseOfEvaluationIF from d02AgentsPackage
--R
--E 881

--S 882 of 3320
)d op expextendedint
--R 
--R
--RThere is one unexposed function called expextendedint :
--R   [1] (Fraction(D6),(D6 -> D6),((Integer,D5) -> Record(ans: D5,right: 
--R            D5,sol?: Boolean)),Fraction(D6)) -> Union(Record(answer: Fraction
--R            (D6),a0: D5),Record(ratpart: Fraction(D6),coeff: Fraction(D6)),
--R            "failed")
--R             from TranscendentalIntegration(D5,D6)
--R             if D5 has FIELD and D6 has UPOLYC(D5)
--R
--RExamples of expextendedint from TranscendentalIntegration
--R
--E 882

--S 883 of 3320
)d op expIfCan
--R 
--R
--RThere is one exposed function called expIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of expIfCan from PartialTranscendentalFunctions
--R
--E 883

--S 884 of 3320
)d op expint
--R 
--R
--RThere is one unexposed function called expint :
--R   [1] (D1,Symbol) -> D1 from ODEIntegration(D3,D1)
--R             if D3 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero) and D1 has Join(
--R            AlgebraicallyClosedFunctionSpace(D3),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory)
--R         
--R
--RExamples of expint from ODEIntegration
--R
--E 884

--S 885 of 3320
)d op expintegrate
--R 
--R
--RThere is one unexposed function called expintegrate :
--R   [1] (Fraction(D6),(D6 -> D6),((Integer,D5) -> Record(ans: D5,right: 
--R            D5,sol?: Boolean))) -> Record(answer: IntegrationResult(Fraction(
--R            D6)),a0: D5)
--R             from TranscendentalIntegration(D5,D6)
--R             if D5 has FIELD and D6 has UPOLYC(D5)
--R
--RExamples of expintegrate from TranscendentalIntegration
--R
--E 885

--S 886 of 3320
)d op expintfldpoly
--R 
--R
--RThere is one unexposed function called expintfldpoly :
--R   [1] (LaurentPolynomial(D3,D4),((Integer,D3) -> Record(ans: D3,right
--R            : D3,sol?: Boolean))) -> Union(LaurentPolynomial(D3,D4),"failed")
--R             from TranscendentalIntegration(D3,D4)
--R             if D3 has FIELD and D4 has UPOLYC(D3)
--R
--RExamples of expintfldpoly from TranscendentalIntegration
--R
--E 886

--S 887 of 3320 done
)d op explicitEntries?
--R 
--R
--RThere is one exposed function called explicitEntries? :
--R   [1] D -> Boolean from D if D has LZSTAGG(D2) and D2 has TYPE
--R
--RExamples of explicitEntries? from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--RexplicitEntries? m
--R
--E 887

--S 888 of 3320 done
)d op explicitlyEmpty?
--R 
--R
--RThere is one exposed function called explicitlyEmpty? :
--R   [1] D -> Boolean from D if D has LZSTAGG(D2) and D2 has TYPE
--R
--RExamples of explicitlyEmpty? from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--RexplicitlyEmpty? m
--R
--E 888

--S 889 of 3320
)d op explicitlyFinite?
--R 
--R
--RThere is one exposed function called explicitlyFinite? :
--R   [1] D -> Boolean from D if D has STAGG(D2) and D2 has TYPE
--R
--RExamples of explicitlyFinite? from StreamAggregate
--R
--E 889

--S 890 of 3320
)d op explimitedint
--R 
--R
--RThere is one unexposed function called explimitedint :
--R   [1] (Fraction(D7),(D7 -> D7),((Integer,D6) -> Record(ans: D6,right: 
--R            D6,sol?: Boolean)),List(Fraction(D7))) -> Union(Record(answer: 
--R            Record(mainpart: Fraction(D7),limitedlogs: List(Record(coeff: 
--R            Fraction(D7),logand: Fraction(D7)))),a0: D6),"failed")
--R             from TranscendentalIntegration(D6,D7)
--R             if D6 has FIELD and D7 has UPOLYC(D6)
--R
--RExamples of explimitedint from TranscendentalIntegration
--R
--E 890

--S 891 of 3320
)d op explogs2trigs
--R 
--R
--RThere is one unexposed function called explogs2trigs :
--R   [1] D2 -> Complex(D4) from InnerTrigonometricManipulations(D3,D4,D2)
--R             if D3 has Join(IntegralDomain,OrderedSet) and D4 has Join(
--R            FunctionSpace(D3),RadicalCategory,
--R            TranscendentalFunctionCategory) and D2 has Join(
--R            FunctionSpace(Complex(D3)),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R
--RExamples of explogs2trigs from InnerTrigonometricManipulations
--R
--E 891

--S 892 of 3320
)d op exponent
--R 
--R
--RThere are 3 exposed functions called exponent :
--R   [1] D -> Integer from D if D has FPS
--R   [2] Factored(D2) -> Integer from Factored(D2) if D2 has INTDOM
--R   [3] MachineFloat -> Integer from MachineFloat
--R
--RThere are 2 unexposed functions called exponent :
--R   [1] ExponentialOfUnivariatePuiseuxSeries(D2,D3,D4) -> 
--R            UnivariatePuiseuxSeries(D2,D3,D4)
--R             from ExponentialOfUnivariatePuiseuxSeries(D2,D3,D4)
--R             if D2 has Join(Field,OrderedSet) and D3: SYMBOL and D4: D2
--R            
--R   [2] ModuleMonomial(D2,D1,D3) -> D1 from ModuleMonomial(D2,D1,D3)
--R             if D1 has SETCAT and D2 has ORDSET and D3: ((Record(index
--R            : D2,exponent: D1),Record(index: D2,exponent: D1)) -> 
--R            Boolean)
--R
--RExamples of exponent from ExponentialOfUnivariatePuiseuxSeries
--R
--R
--RExamples of exponent from FloatingPointSystem
--R
--R
--RExamples of exponent from Factored
--R
--Rf:=nilFactor(y-x,3) 
--Rexponent(f)
--R
--R
--RExamples of exponent from MachineFloat
--R
--R
--RExamples of exponent from ModuleMonomial
--R
--E 892

--S 893 of 3320
)d op exponential
--R 
--R
--RThere are 2 unexposed functions called exponential :
--R   [1] UnivariatePuiseuxSeries(D2,D3,D4) -> 
--R            ExponentialOfUnivariatePuiseuxSeries(D2,D3,D4)
--R             from ExponentialOfUnivariatePuiseuxSeries(D2,D3,D4)
--R             if D2 has Join(Field,OrderedSet) and D3: SYMBOL and D4: D2
--R            
--R   [2] Float -> (() -> Float) from RandomFloatDistributions
--R
--RExamples of exponential from ExponentialOfUnivariatePuiseuxSeries
--R
--R
--RExamples of exponential from RandomFloatDistributions
--R
--E 893

--S 894 of 3320
)d op exponential1
--R 
--R
--RThere is one unexposed function called exponential1 :
--R   [1]  -> Float from RandomFloatDistributions
--R
--RExamples of exponential1 from RandomFloatDistributions
--R
--E 894

--S 895 of 3320
)d op exponentialOrder
--R 
--R
--RThere is one unexposed function called exponentialOrder :
--R   [1] ExponentialOfUnivariatePuiseuxSeries(D2,D3,D4) -> Fraction(
--R            Integer)
--R             from ExponentialOfUnivariatePuiseuxSeries(D2,D3,D4)
--R             if D2 has Join(Field,OrderedSet) and D3: SYMBOL and D4: D2
--R            
--R
--RExamples of exponentialOrder from ExponentialOfUnivariatePuiseuxSeries
--R
--E 895

--S 896 of 3320
)d op exponents
--R 
--R
--RThere is one unexposed function called exponents :
--R   [1] ExtAlgBasis -> List(Integer) from ExtAlgBasis
--R
--RExamples of exponents from ExtAlgBasis
--R
--E 896

--S 897 of 3320
)d op expPot
--R 
--R
--RThere is one unexposed function called expPot :
--R   [1] (Vector(D3),SingleInteger,SingleInteger) -> Vector(D3)
--R             from InnerNormalBasisFieldFunctions(D3) if D3 has FFIELDC
--R            
--R
--RExamples of expPot from InnerNormalBasisFieldFunctions
--R
--E 897

--S 898 of 3320
)d op expr
--R 
--R
--RThere is one exposed function called expr :
--R   [1] D -> D1 from D
--R             if D has SEXCAT(D2,D3,D4,D5,D1) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D1 has 
--R            SETCAT
--R
--RExamples of expr from SExpressionCategory
--R
--E 898

--S 899 of 3320
)d op expressIdealMember
--R 
--R
--RThere is one exposed function called expressIdealMember :
--R   [1] (List(D),D) -> Union(List(D),"failed") from D if D has PID
--R
--RExamples of expressIdealMember from PrincipalIdealDomain
--R
--E 899

--S 900 of 3320
)d op exprex
--R 
--R
--RThere are 2 exposed functions called exprex :
--R   [1] OutputForm -> String from HTMLFormat
--R   [2] OutputForm -> String from MathMLFormat
--R
--RExamples of exprex from HTMLFormat
--R
--Rexprex(sqrt(3+x)::OutputForm)$HTMLFORM
--R
--R
--RExamples of exprex from MathMLFormat
--R
--E 900

--S 901 of 3320
)d op exprHasAlgebraicWeight
--R 
--R
--RThere is one exposed function called exprHasAlgebraicWeight :
--R   [1] Record(var: Symbol,fn: Expression(DoubleFloat),range: Segment(
--R            OrderedCompletion(DoubleFloat)),abserr: DoubleFloat,relerr: 
--R            DoubleFloat) -> Union(List(DoubleFloat),"failed")
--R             from d01WeightsPackage
--R
--RExamples of exprHasAlgebraicWeight from d01WeightsPackage
--R
--E 901

--S 902 of 3320
)d op exprHasLogarithmicWeights
--R 
--R
--RThere is one exposed function called exprHasLogarithmicWeights :
--R   [1] Record(var: Symbol,fn: Expression(DoubleFloat),range: Segment(
--R            OrderedCompletion(DoubleFloat)),abserr: DoubleFloat,relerr: 
--R            DoubleFloat) -> Integer
--R             from d01WeightsPackage
--R
--RExamples of exprHasLogarithmicWeights from d01WeightsPackage
--R
--E 902

--S 903 of 3320
)d op exprHasWeightCosWXorSinWX
--R 
--R
--RThere is one exposed function called exprHasWeightCosWXorSinWX :
--R   [1] Record(var: Symbol,fn: Expression(DoubleFloat),range: Segment(
--R            OrderedCompletion(DoubleFloat)),abserr: DoubleFloat,relerr: 
--R            DoubleFloat) -> Union(Record(op: BasicOperator,w: DoubleFloat),
--R            "failed")
--R             from d01WeightsPackage
--R
--RExamples of exprHasWeightCosWXorSinWX from d01WeightsPackage
--R
--E 903

--S 904 of 3320
)d op exprToGenUPS
--R 
--R
--RThere is one unexposed function called exprToGenUPS :
--R   [1] (D3,Boolean,String) -> Union(%series: D8,%problem: Record(func: 
--R            String,prob: String))
--R             from FunctionSpaceToUnivariatePowerSeries(D6,D3,D7,D8,D9,
--R            D1)
--R             if D6 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D3 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D6))with
--R               coerce : D7 -> %and D7 has ORDRING and D8 has Join(
--R            UnivariatePowerSeriesCategory(D3,D7),Field,
--R            TranscendentalFunctionCategory)with
--R               differentiate : % -> %
--R               integrate : % -> %and D9 has PTRANFN(D8) and D1: 
--R            SYMBOL
--R
--RExamples of exprToGenUPS from FunctionSpaceToUnivariatePowerSeries
--R
--E 904

--S 905 of 3320
)d op exprToUPS
--R 
--R
--RThere is one unexposed function called exprToUPS :
--R   [1] (D3,Boolean,String) -> Union(%series: D8,%problem: Record(func: 
--R            String,prob: String))
--R             from FunctionSpaceToUnivariatePowerSeries(D6,D3,D7,D8,D9,
--R            D1)
--R             if D6 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D3 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D6))with
--R               coerce : D7 -> %and D7 has ORDRING and D8 has Join(
--R            UnivariatePowerSeriesCategory(D3,D7),Field,
--R            TranscendentalFunctionCategory)with
--R               differentiate : % -> %
--R               integrate : % -> %and D9 has PTRANFN(D8) and D1: 
--R            SYMBOL
--R
--RExamples of exprToUPS from FunctionSpaceToUnivariatePowerSeries
--R
--E 905

--S 906 of 3320
)d op exprToXXP
--R 
--R
--RThere is one unexposed function called exprToXXP :
--R   [1] (D2,Boolean) -> Union(%expansion: ExponentialExpansion(D4,D2,D5,
--R            D6),%problem: Record(func: String,prob: String))
--R             from FunctionSpaceToExponentialExpansion(D4,D2,D5,D6)
--R             if D4 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D4)) and D5: SYMBOL and D6: D2
--R
--RExamples of exprToXXP from FunctionSpaceToExponentialExpansion
--R
--E 906

--S 907 of 3320
)d op expt
--R 
--R
--RThere is one unexposed function called expt :
--R   [1] (D1,PositiveInteger) -> D1 from RepeatedSquaring(D1)
--R             if D1 has SetCategorywith
--R               ?*? : (%,%) -> %
--R
--RExamples of expt from RepeatedSquaring
--R
--E 907

--S 908 of 3320
)d op exptMod
--R 
--R
--RThere are 2 exposed functions called exptMod :
--R   [1] (D1,NonNegativeInteger,D1) -> D1 from DistinctDegreeFactorize(D3
--R            ,D1)
--R             if D3 has FFIELDC and D1 has UPOLYC(D3)
--R   [2] (D1,Integer,D1,Integer) -> D1 from 
--R            ModularDistinctDegreeFactorizer(D1)
--R             if D1 has UPOLYC(INT)
--R
--RExamples of exptMod from DistinctDegreeFactorize
--R
--R
--RExamples of exptMod from ModularDistinctDegreeFactorizer
--R
--E 908

--S 909 of 3320
)d op exquo
--R 
--R
--RThere are 7 exposed functions called exquo :
--R   [1] (D,D1) -> Union(D,"failed") from D
--R             if D has COMPCAT(D1) and D1 has COMRING and D1 has INTDOM
--R            
--R   [2] (D,D1) -> Union(D,"failed") from D
--R             if D has FAMR(D1,D2) and D1 has RING and D2 has OAMON and 
--R            D1 has INTDOM
--R   [3] (D,D) -> Union(D,"failed") from D if D has INTDOM
--R   [4] (D,D1) -> Union(D,"failed") from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1) and D1 has INTDOM
--R   [5] (NonNegativeInteger,NonNegativeInteger) -> Union(
--R            NonNegativeInteger,"failed")
--R             from NonNegativeInteger
--R   [6] (D,D1) -> Union(D,"failed") from D
--R             if D has OREPCAT(D1) and D1 has RING and D1 has INTDOM
--R   [7] (D,D1) -> Union(D,"failed") from D
--R             if D has RMATCAT(D2,D3,D1,D4,D5) and D1 has RING and D4
--R             has DIRPCAT(D3,D1) and D5 has DIRPCAT(D2,D1) and D1 has 
--R            INTDOM
--R
--RThere are 3 unexposed functions called exquo :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [2] (Vector(D3),D2) -> Vector(D3) from PseudoRemainderSequence(D2,D3
--R            )
--R             if D3 has UPOLYC(D2) and D2 has INTDOM
--R   [3] (Stream(D2),Stream(D2)) -> Union(Stream(D2),"failed")
--R             from StreamTaylorSeriesOperations(D2) if D2 has RING
--R
--RExamples of exquo from ComplexCategory
--R
--R
--RExamples of exquo from FiniteAbelianMonoidRing
--R
--R
--RExamples of exquo from IntegralDomain
--R
--R
--RExamples of exquo from MatrixCategory
--R
--Rm:=matrix [[2**i for i in 2..4] for j in 1..5] 
--Rexquo(m,2)
--R
--R
--RExamples of exquo from NonNegativeInteger
--R
--R
--RExamples of exquo from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of exquo from OutputForm
--R
--R
--RExamples of exquo from PseudoRemainderSequence
--R
--R
--RExamples of exquo from RectangularMatrixCategory
--R
--R
--RExamples of exquo from StreamTaylorSeriesOperations
--R
--E 909

--S 910 of 3320
)d op exQuo
--R 
--R
--RThere are 3 unexposed functions called exQuo :
--R   [1] (EuclideanModularRing(D1,D2,D3,D4,D5,D6),EuclideanModularRing(D1
--R            ,D2,D3,D4,D5,D6)) -> Union(EuclideanModularRing(D1,D2,D3,D4,D5,D6
--R            ),"failed")
--R             from EuclideanModularRing(D1,D2,D3,D4,D5,D6)
--R             if D1 has COMRING and D2 has UPOLYC(D1) and D3 has ABELMON
--R            and D4: ((D2,D3) -> D2) and D5: ((D3,D3) -> Union(D3,
--R            "failed")) and D6: ((D2,D2,D3) -> Union(D2,"failed"))
--R   [2] (ModularField(D1,D2,D3,D4,D5),ModularField(D1,D2,D3,D4,D5)) -> 
--R            Union(ModularField(D1,D2,D3,D4,D5),"failed")
--R             from ModularField(D1,D2,D3,D4,D5)
--R             if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> 
--R            D1) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1
--R            ,D2) -> Union(D1,"failed"))
--R   [3] (ModularRing(D1,D2,D3,D4,D5),ModularRing(D1,D2,D3,D4,D5)) -> 
--R            Union(ModularRing(D1,D2,D3,D4,D5),"failed")
--R             from ModularRing(D1,D2,D3,D4,D5)
--R             if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> 
--R            D1) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1
--R            ,D2) -> Union(D1,"failed"))
--R
--RExamples of exQuo from EuclideanModularRing
--R
--R
--RExamples of exQuo from ModularField
--R
--R
--RExamples of exQuo from ModularRing
--R
--E 910

--S 911 of 3320
)d op extDegree
--R 
--R
--RThere is one exposed function called extDegree :
--R   [1] D -> PositiveInteger from D if D has PACPERC
--R
--RExamples of extDegree from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--E 911

--S 912 of 3320
)d op extend
--R 
--R
--RThere are 11 exposed functions called extend :
--R   [1] (ContinuedFraction(D2),Integer) -> ContinuedFraction(D2)
--R             from ContinuedFraction(D2) if D2 has EUCDOM
--R   [2] (D,Integer) -> D from D if D has LZSTAGG(D2) and D2 has TYPE
--R   [3] (D,NonNegativeInteger) -> D from D
--R             if D has MTSCAT(D2,D3) and D2 has RING and D3 has ORDSET
--R         
--R   [4] (D,Integer) -> D from D if D has PADICCT(D2)
--R   [5] (D,List(D2)) -> D from D if D has PTCAT(D2) and D2 has RING
--R   [6] (List(D6),List(D)) -> List(D) from D
--R             if D has RSETCAT(D3,D4,D5,D6) and D3 has GCDDOM and D4
--R             has OAMONS and D5 has ORDSET and D6 has RPOLCAT(D3,D4,D5)
--R            
--R   [7] (List(D6),D) -> List(D) from D
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D has RSETCAT(D3,D4,D5,D6)
--R   [8] (D2,List(D)) -> List(D) from D
--R             if D has RSETCAT(D3,D4,D5,D2) and D3 has GCDDOM and D4
--R             has OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R            
--R   [9] (D2,D) -> List(D) from D
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5) and D has RSETCAT(D3,D4,D5,D2)
--R   [10] (D,D1) -> D from D
--R             if D has TSETCAT(D2,D3,D4,D1) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D1 has RPOLCAT(D2,D3,D4)
--R            
--R   [11] (D,D1) -> D from D if D has UPSCAT(D2,D1) and D2 has RING and 
--R            D1 has OAMON
--R
--RExamples of extend from ContinuedFraction
--R
--R
--RExamples of extend from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--RnumberOfComputedEntries m 
--Rextend(m,20) 
--RnumberOfComputedEntries m
--R
--R
--RExamples of extend from MultivariateTaylorSeriesCategory
--R
--R
--RExamples of extend from PAdicIntegerCategory
--R
--R
--RExamples of extend from PointCategory
--R
--R
--RExamples of extend from RegularTriangularSetCategory
--R
--R
--RExamples of extend from TriangularSetCategory
--R
--R
--RExamples of extend from UnivariatePowerSeriesCategory
--R
--E 912

--S 913 of 3320
)d op extendedEuclidean
--R 
--R
--RThere are 2 exposed functions called extendedEuclidean :
--R   [1] (D,D,D) -> Union(Record(coef1: D,coef2: D),"failed") from D if D
--R             has EUCDOM
--R   [2] (D,D) -> Record(coef1: D,coef2: D,generator: D) from D if D has 
--R            EUCDOM
--R
--RExamples of extendedEuclidean from EuclideanDomain
--R
--E 913

--S 914 of 3320
--R------------------- )d op extended_gcd (fix this)
--E 914

--S 915 of 3320
)d op extendedint
--R 
--R
--RThere is one unexposed function called extendedint :
--R   [1] (Fraction(D4),Fraction(D4)) -> Union(Record(ratpart: Fraction(D4
--R            ),coeff: Fraction(D4)),"failed")
--R             from RationalIntegration(D3,D4)
--R             if D3 has Join(Field,CharacteristicZero,RetractableTo(
--R            Integer)) and D4 has UPOLYC(D3)
--R
--RExamples of extendedint from RationalIntegration
--R
--E 915

--S 916 of 3320
)d op extendedIntegrate
--R 
--R
--RThere is one exposed function called extendedIntegrate :
--R   [1] (Fraction(Polynomial(D4)),Symbol,Fraction(Polynomial(D4))) -> 
--R            Union(Record(ratpart: Fraction(Polynomial(D4)),coeff: Fraction(
--R            Polynomial(D4))),"failed")
--R             from RationalFunctionIntegration(D4)
--R             if D4 has Join(IntegralDomain,RetractableTo(Integer),
--R            CharacteristicZero)
--R
--RExamples of extendedIntegrate from RationalFunctionIntegration
--R
--E 916

--S 917 of 3320
)d op extendedResultant
--R 
--R
--RThere is one unexposed function called extendedResultant :
--R   [1] (NewSparseUnivariatePolynomial(D2),NewSparseUnivariatePolynomial
--R            (D2)) -> Record(resultant: D2,coef1: 
--R            NewSparseUnivariatePolynomial(D2),coef2: 
--R            NewSparseUnivariatePolynomial(D2))
--R             from NewSparseUnivariatePolynomial(D2) if D2 has INTDOM 
--R            and D2 has RING
--R
--RExamples of extendedResultant from NewSparseUnivariatePolynomial
--R
--E 917

--S 918 of 3320
)d op extendedSubResultantGcd
--R 
--R
--RThere is one exposed function called extendedSubResultantGcd :
--R   [1] (D,D) -> Record(gcd: D,coef1: D,coef2: D) from D
--R             if D2 has INTDOM and D2 has RING and D3 has OAMONS and D4
--R             has ORDSET and D has RPOLCAT(D2,D3,D4)
--R
--RThere is one unexposed function called extendedSubResultantGcd :
--R   [1] (NewSparseUnivariatePolynomial(D2),NewSparseUnivariatePolynomial
--R            (D2)) -> Record(gcd: NewSparseUnivariatePolynomial(D2),coef1: 
--R            NewSparseUnivariatePolynomial(D2),coef2: 
--R            NewSparseUnivariatePolynomial(D2))
--R             from NewSparseUnivariatePolynomial(D2) if D2 has INTDOM 
--R            and D2 has RING
--R
--RExamples of extendedSubResultantGcd from NewSparseUnivariatePolynomial
--R
--R
--RExamples of extendedSubResultantGcd from RecursivePolynomialCategory
--R
--E 918

--S 919 of 3320
)d op extendIfCan
--R 
--R
--RThere is one exposed function called extendIfCan :
--R   [1] (D,D1) -> Union(D,"failed") from D
--R             if D has TSETCAT(D2,D3,D4,D1) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D1 has RPOLCAT(D2,D3,D4)
--R            
--R
--RExamples of extendIfCan from TriangularSetCategory
--R
--E 919

--S 920 of 3320
)d op extension
--R 
--R
--RThere is one exposed function called extension :
--R   [1] D -> String from D if D has FNCAT
--R
--RExamples of extension from FileNameCategory
--R
--E 920

--S 921 of 3320
)d op extensionDegree
--R 
--R
--RThere are 2 exposed functions called extensionDegree :
--R   [1]  -> PositiveInteger from D if D has FAXF(D2) and D2 has FIELD
--R         
--R   [2]  -> OnePointCompletion(PositiveInteger) from D
--R             if D has XF(D2) and D2 has FIELD
--R
--RThere are 2 unexposed functions called extensionDegree :
--R   [1]  -> PositiveInteger from FiniteAlgebraicExtensionField&(D2,D3)
--R             if D3 has FIELD and D2 has FAXF(D3)
--R   [2]  -> OnePointCompletion(PositiveInteger)
--R             from FiniteAlgebraicExtensionField&(D2,D3)
--R             if D3 has FIELD and D2 has FAXF(D3)
--R
--RExamples of extensionDegree from FiniteAlgebraicExtensionField&
--R
--R
--RExamples of extensionDegree from FiniteAlgebraicExtensionField
--R
--R
--RExamples of extensionDegree from ExtensionField
--R
--E 921

--S 922 of 3320 done
)d op exteriorDifferential
--R 
--R
--RThere is one unexposed function called exteriorDifferential :
--R   [1] DeRhamComplex(D1,D2) -> DeRhamComplex(D1,D2) from DeRhamComplex(
--R            D1,D2)
--R             if D1 has Join(Ring,OrderedSet) and D2: LIST(SYMBOL)
--R
--RExamples of exteriorDifferential from DeRhamComplex
--R
--Rder := DeRhamComplex(Integer,[x,y,z]) 
--RR := Expression(Integer) 
--R[dx,dy,dz] := [generator(i)$der for i in 1..3] 
--Rf : R := x**2*y*z-5*x**3*y**2*z**5 
--Rg : R := z**2*y*cos(z)-7*sin(x**3*y**2)*z**2 
--Rh : R :=x*y*z-2*x**3*y*z**2 
--Ralpha : der := f*dx + g*dy + h*dz 
--RexteriorDifferential alpha
--R
--E 922

--S 923 of 3320
)d op external?
--R 
--R
--RThere is one exposed function called external? :
--R   [1] FortranType -> Boolean from FortranType
--R
--RExamples of external? from FortranType
--R
--E 923

--S 924 of 3320
)d op externalList
--R 
--R
--RThere is one exposed function called externalList :
--R   [1] SymbolTable -> List(Symbol) from SymbolTable
--R
--RExamples of externalList from SymbolTable
--R
--E 924

--S 925 of 3320
)d op extract
--R 
--R
--RThere is one exposed function called extract :
--R   [1] (SparseEchelonMatrix(D2,D3),Integer,Integer) -> 
--R            SparseEchelonMatrix(D2,D3)
--R             from SparseEchelonMatrix(D2,D3) if D2 has ORDSET and D3
--R             has RING
--R
--RExamples of extract from SparseEchelonMatrix
--R
--E 925

--S 926 of 3320
)d op extract!
--R 
--R
--RThere are 6 exposed functions called extract! :
--R   [1] ArrayStack(D1) -> D1 from ArrayStack(D1) if D1 has SETCAT
--R   [2] D -> D1 from D if D has BGAGG(D1) and D1 has TYPE
--R   [3] Dequeue(D1) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [4] Heap(D1) -> D1 from Heap(D1) if D1 has ORDSET
--R   [5] Queue(D1) -> D1 from Queue(D1) if D1 has SETCAT
--R   [6] Stack(D1) -> D1 from Stack(D1) if D1 has SETCAT
--R
--RExamples of extract! from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rextract! a 
--Ra
--R
--R
--RExamples of extract! from BagAggregate
--R
--R
--RExamples of extract! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rextract! a 
--Ra
--R
--R
--RExamples of extract! from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rextract! a 
--Ra
--R
--R
--RExamples of extract! from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rextract! a 
--Ra
--R
--R
--RExamples of extract! from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rextract! a 
--Ra
--R
--E 926

--S 927 of 3320
)d op extractBottom!
--R 
--R
--RThere are 2 exposed functions called extractBottom! :
--R   [1] Dequeue(D1) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [2] D -> D1 from D if D has DQAGG(D1) and D1 has TYPE
--R
--RExamples of extractBottom! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--RextractBottom! a 
--Ra
--R
--R
--RExamples of extractBottom! from DequeueAggregate
--R
--E 927

--S 928 of 3320
)d op extractClosed
--R 
--R
--RThere is one unexposed function called extractClosed :
--R   [1] SubSpace(D2,D3) -> Boolean from SubSpace(D2,D3) if D2: PI and D3
--R             has RING
--R
--RExamples of extractClosed from SubSpace
--R
--E 928

--S 929 of 3320
)d op extractIfCan
--R 
--R
--RThere is one unexposed function called extractIfCan :
--R   [1] D2 -> Union(D1,"failed") from TabulatedComputationPackage(D2,D1)
--R             if D1 has SETCAT and D2 has SETCAT
--R
--RExamples of extractIfCan from TabulatedComputationPackage
--R
--E 929

--S 930 of 3320
)d op extractIndex
--R 
--R
--RThere is one unexposed function called extractIndex :
--R   [1] SubSpace(D2,D3) -> NonNegativeInteger from SubSpace(D2,D3)
--R             if D2: PI and D3 has RING
--R
--RExamples of extractIndex from SubSpace
--R
--E 930

--S 931 of 3320
)d op extractPoint
--R 
--R
--RThere is one unexposed function called extractPoint :
--R   [1] SubSpace(D2,D3) -> Point(D3) from SubSpace(D2,D3) if D2: PI and 
--R            D3 has RING
--R
--RExamples of extractPoint from SubSpace
--R
--E 931

--S 932 of 3320
)d op extractProperty
--R 
--R
--RThere is one unexposed function called extractProperty :
--R   [1] SubSpace(D2,D3) -> SubSpaceComponentProperty from SubSpace(D2,D3
--R            )
--R             if D2: PI and D3 has RING
--R
--RExamples of extractProperty from SubSpace
--R
--E 932

--S 933 of 3320
)d op extractSplittingLeaf
--R 
--R
--RThere is one unexposed function called extractSplittingLeaf :
--R   [1] SplittingTree(D1,D2) -> Union(SplittingTree(D1,D2),"failed")
--R             from SplittingTree(D1,D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of extractSplittingLeaf from SplittingTree
--R
--E 933

--S 934 of 3320
)d op extractTop!
--R 
--R
--RThere are 2 exposed functions called extractTop! :
--R   [1] Dequeue(D1) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [2] D -> D1 from D if D has DQAGG(D1) and D1 has TYPE
--R
--RExamples of extractTop! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--RextractTop! a 
--Ra
--R
--R
--RExamples of extractTop! from DequeueAggregate
--R
--E 934

--S 935 of 3320
)d op eyeDistance
--R 
--R
--RThere is one exposed function called eyeDistance :
--R   [1] (ThreeDimensionalViewport,Float) -> Void from 
--R            ThreeDimensionalViewport
--R
--RExamples of eyeDistance from ThreeDimensionalViewport
--R
--E 935

--S 936 of 3320
)d op F
--R 
--R
--RThere is one unexposed function called F :
--R   [1] (NonNegativeInteger,NonNegativeInteger) -> (() -> Float)
--R             from RandomFloatDistributions
--R
--RExamples of F from RandomFloatDistributions
--R
--E 936

--S 937 of 3320
)d op f01brf
--R 
--R
--RThere is one exposed function called f01brf :
--R   [1] (Integer,Integer,Integer,Integer,DoubleFloat,Boolean,Boolean,
--R            List(Boolean),Matrix(DoubleFloat),Matrix(Integer),Matrix(Integer)
--R            ,Integer) -> Result
--R             from NagMatrixOperationsPackage
--R
--RExamples of f01brf from NagMatrixOperationsPackage
--R
--E 937

--S 938 of 3320
)d op f01bsf
--R 
--R
--RThere is one exposed function called f01bsf :
--R   [1] (Integer,Integer,Integer,Matrix(Integer),Matrix(Integer),Matrix(
--R            Integer),Matrix(Integer),Boolean,DoubleFloat,Boolean,Matrix(
--R            Integer),Matrix(DoubleFloat),Integer) -> Result
--R             from NagMatrixOperationsPackage
--R
--RExamples of f01bsf from NagMatrixOperationsPackage
--R
--E 938

--S 939 of 3320
)d op f01maf
--R 
--R
--RThere is one exposed function called f01maf :
--R   [1] (Integer,Integer,Integer,Integer,List(Boolean),Matrix(
--R            DoubleFloat),Matrix(Integer),Matrix(Integer),DoubleFloat,
--R            DoubleFloat,Integer) -> Result
--R             from NagMatrixOperationsPackage
--R
--RExamples of f01maf from NagMatrixOperationsPackage
--R
--E 939

--S 940 of 3320
)d op f01mcf
--R 
--R
--RThere is one exposed function called f01mcf :
--R   [1] (Integer,Matrix(DoubleFloat),Integer,Matrix(Integer),Integer)
--R             -> Result
--R             from NagMatrixOperationsPackage
--R
--RExamples of f01mcf from NagMatrixOperationsPackage
--R
--E 940

--S 941 of 3320
)d op f01qcf
--R 
--R
--RThere is one exposed function called f01qcf :
--R   [1] (Integer,Integer,Integer,Matrix(DoubleFloat),Integer) -> Result
--R             from NagMatrixOperationsPackage
--R
--RExamples of f01qcf from NagMatrixOperationsPackage
--R
--E 941

--S 942 of 3320
)d op f01qdf
--R 
--R
--RThere is one exposed function called f01qdf :
--R   [1] (String,String,Integer,Integer,Matrix(DoubleFloat),Integer,
--R            Matrix(DoubleFloat),Integer,Integer,Matrix(DoubleFloat),Integer)
--R             -> Result
--R             from NagMatrixOperationsPackage
--R
--RExamples of f01qdf from NagMatrixOperationsPackage
--R
--E 942

--S 943 of 3320
)d op f01qef
--R 
--R
--RThere is one exposed function called f01qef :
--R   [1] (String,Integer,Integer,Integer,Integer,Matrix(DoubleFloat),
--R            Matrix(DoubleFloat),Integer) -> Result
--R             from NagMatrixOperationsPackage
--R
--RExamples of f01qef from NagMatrixOperationsPackage
--R
--E 943

--S 944 of 3320
)d op f01rcf
--R 
--R
--RThere is one exposed function called f01rcf :
--R   [1] (Integer,Integer,Integer,Matrix(Complex(DoubleFloat)),Integer)
--R             -> Result
--R             from NagMatrixOperationsPackage
--R
--RExamples of f01rcf from NagMatrixOperationsPackage
--R
--E 944

--S 945 of 3320
)d op f01rdf
--R 
--R
--RThere is one exposed function called f01rdf :
--R   [1] (String,String,Integer,Integer,Matrix(Complex(DoubleFloat)),
--R            Integer,Matrix(Complex(DoubleFloat)),Integer,Integer,Matrix(
--R            Complex(DoubleFloat)),Integer) -> Result
--R             from NagMatrixOperationsPackage
--R
--RExamples of f01rdf from NagMatrixOperationsPackage
--R
--E 945

--S 946 of 3320
)d op f01ref
--R 
--R
--RThere is one exposed function called f01ref :
--R   [1] (String,Integer,Integer,Integer,Integer,Matrix(Complex(
--R            DoubleFloat)),Matrix(Complex(DoubleFloat)),Integer) -> Result
--R             from NagMatrixOperationsPackage
--R
--RExamples of f01ref from NagMatrixOperationsPackage
--R
--E 946

--S 947 of 3320
)d op f02aaf
--R 
--R
--RThere is one exposed function called f02aaf :
--R   [1] (Integer,Integer,Matrix(DoubleFloat),Integer) -> Result
--R             from NagEigenPackage
--R
--RExamples of f02aaf from NagEigenPackage
--R
--E 947

--S 948 of 3320
)d op f02abf
--R 
--R
--RThere is one exposed function called f02abf :
--R   [1] (Matrix(DoubleFloat),Integer,Integer,Integer,Integer) -> Result
--R             from NagEigenPackage
--R
--RExamples of f02abf from NagEigenPackage
--R
--E 948

--S 949 of 3320
)d op f02adf
--R 
--R
--RThere is one exposed function called f02adf :
--R   [1] (Integer,Integer,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat)
--R            ,Integer) -> Result
--R             from NagEigenPackage
--R
--RExamples of f02adf from NagEigenPackage
--R
--E 949

--S 950 of 3320
)d op f02aef
--R 
--R
--RThere is one exposed function called f02aef :
--R   [1] (Integer,Integer,Integer,Integer,Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Integer) -> Result
--R             from NagEigenPackage
--R
--RExamples of f02aef from NagEigenPackage
--R
--E 950

--S 951 of 3320
)d op f02aff
--R 
--R
--RThere is one exposed function called f02aff :
--R   [1] (Integer,Integer,Matrix(DoubleFloat),Integer) -> Result
--R             from NagEigenPackage
--R
--RExamples of f02aff from NagEigenPackage
--R
--E 951

--S 952 of 3320
)d op f02agf
--R 
--R
--RThere is one exposed function called f02agf :
--R   [1] (Integer,Integer,Integer,Integer,Matrix(DoubleFloat),Integer)
--R             -> Result
--R             from NagEigenPackage
--R
--RExamples of f02agf from NagEigenPackage
--R
--E 952

--S 953 of 3320
)d op f02ajf
--R 
--R
--RThere is one exposed function called f02ajf :
--R   [1] (Integer,Integer,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat)
--R            ,Integer) -> Result
--R             from NagEigenPackage
--R
--RExamples of f02ajf from NagEigenPackage
--R
--E 953

--S 954 of 3320
)d op f02akf
--R 
--R
--RThere is one exposed function called f02akf :
--R   [1] (Integer,Integer,Integer,Integer,Integer,Matrix(DoubleFloat),
--R            Matrix(DoubleFloat),Integer) -> Result
--R             from NagEigenPackage
--R
--RExamples of f02akf from NagEigenPackage
--R
--E 954

--S 955 of 3320
)d op f02awf
--R 
--R
--RThere is one exposed function called f02awf :
--R   [1] (Integer,Integer,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat)
--R            ,Integer) -> Result
--R             from NagEigenPackage
--R
--RExamples of f02awf from NagEigenPackage
--R
--E 955

--S 956 of 3320
)d op f02axf
--R 
--R
--RThere is one exposed function called f02axf :
--R   [1] (Matrix(DoubleFloat),Integer,Matrix(DoubleFloat),Integer,Integer
--R            ,Integer,Integer,Integer) -> Result
--R             from NagEigenPackage
--R
--RExamples of f02axf from NagEigenPackage
--R
--E 956

--S 957 of 3320
)d op f02bbf
--R 
--R
--RThere is one exposed function called f02bbf :
--R   [1] (Integer,Integer,DoubleFloat,DoubleFloat,Integer,Integer,Matrix(
--R            DoubleFloat),Integer) -> Result
--R             from NagEigenPackage
--R
--RExamples of f02bbf from NagEigenPackage
--R
--E 957

--S 958 of 3320
)d op f02bjf
--R 
--R
--RThere is one exposed function called f02bjf :
--R   [1] (Integer,Integer,Integer,DoubleFloat,Boolean,Integer,Matrix(
--R            DoubleFloat),Matrix(DoubleFloat),Integer) -> Result
--R             from NagEigenPackage
--R
--RExamples of f02bjf from NagEigenPackage
--R
--E 958

--S 959 of 3320
)d op f02fjf
--R 
--R
--RThere are 2 exposed functions called f02fjf :
--R   [1] (Integer,Integer,DoubleFloat,Integer,Integer,Integer,Integer,
--R            Integer,Integer,Integer,Matrix(DoubleFloat),Integer,Union(fn: 
--R            FileName,fp: Asp27(DOT)),Union(fn: FileName,fp: Asp28(IMAGE)))
--R             -> Result
--R             from NagEigenPackage
--R   [2] (Integer,Integer,DoubleFloat,Integer,Integer,Integer,Integer,
--R            Integer,Integer,Integer,Matrix(DoubleFloat),Integer,Union(fn: 
--R            FileName,fp: Asp27(DOT)),Union(fn: FileName,fp: Asp28(IMAGE)),
--R            FileName) -> Result
--R             from NagEigenPackage
--R
--RExamples of f02fjf from NagEigenPackage
--R
--E 959

--S 960 of 3320
)d op f02wef
--R 
--R
--RThere is one exposed function called f02wef :
--R   [1] (Integer,Integer,Integer,Integer,Integer,Boolean,Integer,Boolean
--R            ,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Integer) -> 
--R            Result
--R             from NagEigenPackage
--R
--RExamples of f02wef from NagEigenPackage
--R
--E 960

--S 961 of 3320
)d op f02xef
--R 
--R
--RThere is one exposed function called f02xef :
--R   [1] (Integer,Integer,Integer,Integer,Integer,Boolean,Integer,Boolean
--R            ,Integer,Matrix(Complex(DoubleFloat)),Matrix(Complex(DoubleFloat)
--R            ),Integer) -> Result
--R             from NagEigenPackage
--R
--RExamples of f02xef from NagEigenPackage
--R
--E 961

--S 962 of 3320
)d op f04adf
--R 
--R
--RThere is one exposed function called f04adf :
--R   [1] (Integer,Matrix(Complex(DoubleFloat)),Integer,Integer,Integer,
--R            Integer,Matrix(Complex(DoubleFloat)),Integer) -> Result
--R             from NagLinearEquationSolvingPackage
--R
--RExamples of f04adf from NagLinearEquationSolvingPackage
--R
--E 962

--S 963 of 3320
)d op f04arf
--R 
--R
--RThere is one exposed function called f04arf :
--R   [1] (Integer,Matrix(DoubleFloat),Integer,Matrix(DoubleFloat),Integer
--R            ) -> Result
--R             from NagLinearEquationSolvingPackage
--R
--RExamples of f04arf from NagLinearEquationSolvingPackage
--R
--E 963

--S 964 of 3320
)d op f04asf
--R 
--R
--RThere is one exposed function called f04asf :
--R   [1] (Integer,Matrix(DoubleFloat),Integer,Matrix(DoubleFloat),Integer
--R            ) -> Result
--R             from NagLinearEquationSolvingPackage
--R
--RExamples of f04asf from NagLinearEquationSolvingPackage
--R
--E 964

--S 965 of 3320
)d op f04atf
--R 
--R
--RThere is one exposed function called f04atf :
--R   [1] (Matrix(DoubleFloat),Integer,Matrix(DoubleFloat),Integer,Integer
--R            ,Integer) -> Result
--R             from NagLinearEquationSolvingPackage
--R
--RExamples of f04atf from NagLinearEquationSolvingPackage
--R
--E 965

--S 966 of 3320
)d op f04axf
--R 
--R
--RThere is one exposed function called f04axf :
--R   [1] (Integer,Matrix(DoubleFloat),Integer,Matrix(Integer),Matrix(
--R            Integer),Integer,Matrix(Integer),Matrix(DoubleFloat)) -> Result
--R             from NagLinearEquationSolvingPackage
--R
--RExamples of f04axf from NagLinearEquationSolvingPackage
--R
--E 966

--S 967 of 3320
)d op f04faf
--R 
--R
--RThere is one exposed function called f04faf :
--R   [1] (Integer,Integer,Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            DoubleFloat),Integer) -> Result
--R             from NagLinearEquationSolvingPackage
--R
--RExamples of f04faf from NagLinearEquationSolvingPackage
--R
--E 967

--S 968 of 3320
)d op f04jgf
--R 
--R
--RThere is one exposed function called f04jgf :
--R   [1] (Integer,Integer,Integer,DoubleFloat,Integer,Matrix(DoubleFloat)
--R            ,Matrix(DoubleFloat),Integer) -> Result
--R             from NagLinearEquationSolvingPackage
--R
--RExamples of f04jgf from NagLinearEquationSolvingPackage
--R
--E 968

--S 969 of 3320
)d op f04maf
--R 
--R
--RThere is one exposed function called f04maf :
--R   [1] (Integer,Integer,Matrix(DoubleFloat),Integer,Matrix(Integer),
--R            Integer,Matrix(Integer),Matrix(DoubleFloat),Matrix(Integer),
--R            Matrix(Integer),Matrix(DoubleFloat),Matrix(DoubleFloat),Matrix(
--R            Integer),Integer) -> Result
--R             from NagLinearEquationSolvingPackage
--R
--RExamples of f04maf from NagLinearEquationSolvingPackage
--R
--E 969

--S 970 of 3320
)d op f04mbf
--R 
--R
--RThere is one exposed function called f04mbf :
--R   [1] (Integer,Matrix(DoubleFloat),Boolean,DoubleFloat,Integer,Integer
--R            ,Integer,Integer,DoubleFloat,Integer,Union(fn: FileName,fp: Asp28
--R            (APROD)),Union(fn: FileName,fp: Asp34(MSOLVE))) -> Result
--R             from NagLinearEquationSolvingPackage
--R
--RExamples of f04mbf from NagLinearEquationSolvingPackage
--R
--E 970

--S 971 of 3320
)d op f04mcf
--R 
--R
--RThere is one exposed function called f04mcf :
--R   [1] (Integer,Matrix(DoubleFloat),Integer,Matrix(DoubleFloat),Matrix(
--R            Integer),Integer,Matrix(DoubleFloat),Integer,Integer,Integer,
--R            Integer) -> Result
--R             from NagLinearEquationSolvingPackage
--R
--RExamples of f04mcf from NagLinearEquationSolvingPackage
--R
--E 971

--S 972 of 3320
)d op f04qaf
--R 
--R
--RThere is one exposed function called f04qaf :
--R   [1] (Integer,Integer,DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat
--R            ,Integer,Integer,Integer,Integer,Matrix(DoubleFloat),Integer,
--R            Union(fn: FileName,fp: Asp30(APROD))) -> Result
--R             from NagLinearEquationSolvingPackage
--R
--RExamples of f04qaf from NagLinearEquationSolvingPackage
--R
--E 972

--S 973 of 3320
)d op f07adf
--R 
--R
--RThere is one exposed function called f07adf :
--R   [1] (Integer,Integer,Integer,Matrix(DoubleFloat)) -> Result from 
--R            NagLapack
--R
--RExamples of f07adf from NagLapack
--R
--E 973

--S 974 of 3320
)d op f07aef
--R 
--R
--RThere is one exposed function called f07aef :
--R   [1] (String,Integer,Integer,Matrix(DoubleFloat),Integer,Matrix(
--R            Integer),Integer,Matrix(DoubleFloat)) -> Result
--R             from NagLapack
--R
--RExamples of f07aef from NagLapack
--R
--E 974

--S 975 of 3320
)d op f07fdf
--R 
--R
--RThere is one exposed function called f07fdf :
--R   [1] (String,Integer,Integer,Matrix(DoubleFloat)) -> Result from 
--R            NagLapack
--R
--RExamples of f07fdf from NagLapack
--R
--E 975

--S 976 of 3320
)d op f07fef
--R 
--R
--RThere is one exposed function called f07fef :
--R   [1] (String,Integer,Integer,Matrix(DoubleFloat),Integer,Integer,
--R            Matrix(DoubleFloat)) -> Result
--R             from NagLapack
--R
--RExamples of f07fef from NagLapack
--R
--E 976

--S 977 of 3320
)d op f2df
--R 
--R
--RThere is one exposed function called f2df :
--R   [1] Float -> DoubleFloat from ExpertSystemToolsPackage
--R
--RExamples of f2df from ExpertSystemToolsPackage
--R
--E 977

--S 978 of 3320
)d op F2EXPRR
--R 
--R
--RThere is one exposed function called F2EXPRR :
--R   [1] D2 -> Expression(Integer) from GuessFiniteFunctions(D2)
--R             if D2 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R
--RExamples of F2EXPRR from GuessFiniteFunctions
--R
--E 978

--S 979 of 3320
)d op F2FG
--R 
--R
--RThere is one unexposed function called F2FG :
--R   [1] D2 -> D1 from InnerTrigonometricManipulations(D3,D2,D1)
--R             if D3 has Join(IntegralDomain,OrderedSet) and D1 has Join(
--R            FunctionSpace(Complex(D3)),RadicalCategory,
--R            TranscendentalFunctionCategory) and D2 has Join(
--R            FunctionSpace(D3),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R
--RExamples of F2FG from InnerTrigonometricManipulations
--R
--E 979

--S 980 of 3320
)d op f2st
--R 
--R
--RThere is one exposed function called f2st :
--R   [1] Float -> String from ExpertSystemToolsPackage
--R
--RExamples of f2st from ExpertSystemToolsPackage
--R
--E 980

--S 981 of 3320
)d op factor
--R 
--R
--RThere are 21 exposed functions called factor :
--R   [1] (D2,List(AlgebraicNumber)) -> Factored(D2) from AlgFactor(D2)
--R             if D2 has UPOLYC(AN)
--R   [2] D2 -> Factored(D2) from AlgFactor(D2) if D2 has UPOLYC(AN)
--R   [3] (D2,List(AlgebraicNumber)) -> Factored(D2)
--R             from AlgebraicMultFact(D4,D5,D2)
--R             if D4 has ORDSET and D5 has OAMONS and D2 has POLYCAT(AN,
--R            D5,D4)
--R   [4] (SparseUnivariatePolynomial(D6),List(AlgebraicNumber)) -> 
--R            Factored(SparseUnivariatePolynomial(D6))
--R             from AlgebraicMultFact(D4,D5,D6)
--R             if D4 has ORDSET and D5 has OAMONS and D6 has POLYCAT(AN,
--R            D5,D4)
--R   [5] D2 -> Factored(D2) from ComplexFactorization(D3,D2)
--R             if D3 has EUCDOM and D2 has UPOLYC(COMPLEX(D3))
--R   [6] D2 -> Factored(D2) from DistinctDegreeFactorize(D3,D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R   [7] (SparseUnivariatePolynomial(D3),D3) -> Factored(
--R            SparseUnivariatePolynomial(D3))
--R             from 
--R            FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber
--R            (D3)
--R             if D3 has PACEXTC
--R   [8] (SparseUnivariatePolynomial(D3),D3) -> Factored(
--R            SparseUnivariatePolynomial(D3))
--R             from 
--R            FactorisationOverPseudoAlgebraicClosureOfRationalNumber(D3)
--R             if D3 has PACRATC
--R   [9] D2 -> Factored(D2) from FiniteFieldFactorization(D3,D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R   [10] D2 -> Factored(D2)
--R             from FiniteFieldFactorizationWithSizeParseBySideEffect(D3,
--R            D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R   [11] Complex(Integer) -> Factored(Complex(Integer))
--R             from GaussianFactorizationPackage
--R   [12] (D2,Integer) -> List(D2) from ModularDistinctDegreeFactorizer(
--R            D2)
--R             if D2 has UPOLYC(INT)
--R   [13] D2 -> Factored(D2) from MultFiniteFactorize(D3,D4,D5,D2)
--R             if D3 has ORDSET and D4 has OAMONS and D5 has FFIELDC and 
--R            D2 has POLYCAT(D5,D4,D3)
--R   [14] SparseUnivariatePolynomial(D6) -> Factored(
--R            SparseUnivariatePolynomial(D6))
--R             from MultFiniteFactorize(D3,D4,D5,D6)
--R             if D3 has ORDSET and D4 has OAMONS and D5 has FFIELDC and 
--R            D6 has POLYCAT(D5,D4,D3)
--R   [15] D2 -> Factored(D2) from MPolyCatRationalFunctionFactorizer(D3,
--R            D4,D5,D2)
--R             if D3 has OAMONS and D4 has OrderedSetwith
--R               convert : % -> Symboland D5 has INTDOM and D2 has 
--R            POLYCAT(FRAC(POLY(D5)),D3,D4)
--R   [16] D2 -> Factored(D2) from MultivariateFactorize(D3,D4,D5,D2)
--R             if D3 has ORDSET and D4 has OAMONS and D5 has Join(
--R            EuclideanDomain,CharacteristicZero) and D2 has POLYCAT(D5,
--R            D4,D3)
--R   [17] SparseUnivariatePolynomial(D6) -> Factored(
--R            SparseUnivariatePolynomial(D6))
--R             from MultivariateFactorize(D3,D4,D5,D6)
--R             if D3 has ORDSET and D4 has OAMONS and D5 has Join(
--R            EuclideanDomain,CharacteristicZero) and D6 has POLYCAT(D5,
--R            D4,D3)
--R   [18] D2 -> Factored(D2) from RationalFunctionFactor(D2)
--R             if D2 has UPOLYC(FRAC(POLY(INT)))
--R   [19] D2 -> Factored(D2) from SimpleAlgebraicExtensionAlgFactor(D3,D4
--R            ,D2)
--R             if D3 has UPOLYC(FRAC(INT)) and D4 has Join(Field,
--R            CharacteristicZero,MonogenicAlgebra(Fraction(Integer),D3)) 
--R            and D2 has UPOLYC(D4)
--R   [20] D2 -> Factored(D2) from SAERationalFunctionAlgFactor(D3,D4,D2)
--R             if D3 has UPOLYC(FRAC(POLY(INT))) and D4 has Join(Field,
--R            CharacteristicZero,MonogenicAlgebra(Fraction(Polynomial(
--R            Integer)),D3)) and D2 has UPOLYC(D4)
--R   [21] D -> Factored(D) from D if D has UFD
--R
--RThere are 22 unexposed functions called factor :
--R   [1] (D2,D3,Boolean) -> Factored(D2) from ComplexRootFindingPackage(
--R            D3,D2)
--R             if D3 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D3))
--R   [2] (D2,D3) -> Factored(D2) from ComplexRootFindingPackage(D3,D2)
--R             if D3 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D3))
--R   [3] D2 -> Factored(D2) from ComplexRootFindingPackage(D3,D2)
--R             if D3 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D3))
--R   [4] D2 -> Factored(D2) from GaloisGroupFactorizer(D2) if D2 has 
--R            UPOLYC(INT)
--R   [5] (D2,NonNegativeInteger) -> Factored(D2) from 
--R            GaloisGroupFactorizer(D2)
--R             if D2 has UPOLYC(INT)
--R   [6] (D2,List(NonNegativeInteger)) -> Factored(D2)
--R             from GaloisGroupFactorizer(D2) if D2 has UPOLYC(INT)
--R   [7] (D2,List(NonNegativeInteger),NonNegativeInteger) -> Factored(D2)
--R             from GaloisGroupFactorizer(D2) if D2 has UPOLYC(INT)
--R   [8] (D2,NonNegativeInteger,NonNegativeInteger) -> Factored(D2)
--R             from GaloisGroupFactorizer(D2) if D2 has UPOLYC(INT)
--R   [9] D2 -> Factored(D2) from GeneralizedMultivariateFactorize(D3,D4,
--R            D5,D6,D2)
--R             if D3 has OrderedSetwith
--R               convert : % -> Symbol
--R               variable : Symbol -> Union(%,"failed")and D4 has 
--R            OAMONS and D6 has INTDOM and D5 has INTDOM and D2 has 
--R            POLYCAT(D6,D4,D3)
--R   [10] SparseUnivariatePolynomial(D3) -> Factored(
--R            SparseUnivariatePolynomial(D3))
--R             from GenUFactorize(D3) if D3 has EUCDOM
--R   [11] (D2,(D5 -> Factored(D5))) -> Factored(D2)
--R             from InnerAlgFactor(D4,D5,D6,D2)
--R             if D5 has UPOLYC(D4) and D4 has FIELD and D6 has Join(
--R            Field,CharacteristicZero,MonogenicAlgebra(D4,D5)) and D2
--R             has UPOLYC(D6)
--R   [12] (D2,(SparseUnivariatePolynomial(D6) -> Factored(
--R            SparseUnivariatePolynomial(D6)))) -> Factored(D2)
--R             from InnerMultFact(D4,D5,D6,D2)
--R             if D6 has Join(EuclideanDomain,CharacteristicZero) and D4
--R             has ORDSET and D5 has OAMONS and D2 has POLYCAT(D6,D5,D4)
--R            
--R   [13] (SparseUnivariatePolynomial(D7),(SparseUnivariatePolynomial(D6)
--R             -> Factored(SparseUnivariatePolynomial(D6)))) -> Factored(
--R            SparseUnivariatePolynomial(D7))
--R             from InnerMultFact(D4,D5,D6,D7)
--R             if D6 has Join(EuclideanDomain,CharacteristicZero) and D4
--R             has ORDSET and D5 has OAMONS and D7 has POLYCAT(D6,D5,D4)
--R            
--R   [14] D2 -> Factored(D2) from IntegerFactorizationPackage(D2) if D2
--R             has INS
--R   [15] (LinearOrdinaryDifferentialOperator1(Fraction(D5)),(D5 -> List(
--R            D4))) -> List(LinearOrdinaryDifferentialOperator1(Fraction(D5)))
--R             from LinearOrdinaryDifferentialOperatorFactorizer(D4,D5)
--R             if D4 has Join(Field,CharacteristicZero,RetractableTo(
--R            Integer),RetractableTo(Fraction(Integer))) and D5 has 
--R            UPOLYC(D4)
--R   [16] LinearOrdinaryDifferentialOperator1(Fraction(D4)) -> List(
--R            LinearOrdinaryDifferentialOperator1(Fraction(D4)))
--R             from LinearOrdinaryDifferentialOperatorFactorizer(D3,D4)
--R             if D3 has ACF and D3 has Join(Field,CharacteristicZero,
--R            RetractableTo(Integer),RetractableTo(Fraction(Integer))) 
--R            and D4 has UPOLYC(D3)
--R   [17] OrderedFreeMonoid(D3) -> List(LyndonWord(D3)) from LyndonWord(
--R            D3)
--R             if D3 has ORDSET
--R   [18] D2 -> Factored(D2) from MPolyCatPolyFactorizer(D3,D4,D5,D2)
--R             if D3 has OAMONS and D4 has OrderedSetwith
--R               convert : % -> Symbol
--R               variable : Symbol -> Union(%,"failed")and D5 has 
--R            EUCDOM and D2 has POLYCAT(POLY(D5),D3,D4)
--R   [19] D2 -> Factored(D2) from MRationalFactorize(D3,D4,D5,D2)
--R             if D3 has OAMONS and D4 has ORDSET and D5 has Join(
--R            EuclideanDomain,CharacteristicZero) and D2 has POLYCAT(FRAC
--R            (D5),D3,D4)
--R   [20] D2 -> Factored(D2) from RationalFactorize(D2) if D2 has UPOLYC(
--R            FRAC(INT))
--R   [21] SparseUnivariatePolynomial(Fraction(D6)) -> Factored(
--R            SparseUnivariatePolynomial(Fraction(D6)))
--R             from SupFractionFactorizer(D3,D4,D5,D6)
--R             if D3 has OAMONS and D4 has ORDSET and D5 has GCDDOM and 
--R            D6 has POLYCAT(D5,D3,D4)
--R   [22] D2 -> Factored(D2) from UnivariateFactorize(D2) if D2 has 
--R            UPOLYC(INT)
--R
--RExamples of factor from AlgFactor
--R
--R
--RExamples of factor from AlgebraicMultFact
--R
--R
--RExamples of factor from ComplexFactorization
--R
--R
--RExamples of factor from ComplexRootFindingPackage
--R
--R
--RExamples of factor from DistinctDegreeFactorize
--R
--R
--RExamples of factor from FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber
--R
--R
--RExamples of factor from FactorisationOverPseudoAlgebraicClosureOfRationalNumber
--R
--R
--RExamples of factor from FiniteFieldFactorization
--R
--R
--RExamples of factor from FiniteFieldFactorizationWithSizeParseBySideEffect
--R
--R
--RExamples of factor from GaloisGroupFactorizer
--R
--R
--RExamples of factor from GaussianFactorizationPackage
--R
--R
--RExamples of factor from GeneralizedMultivariateFactorize
--R
--R
--RExamples of factor from GenUFactorize
--R
--R
--RExamples of factor from InnerAlgFactor
--R
--R
--RExamples of factor from InnerMultFact
--R
--R
--RExamples of factor from IntegerFactorizationPackage
--R
--R
--RExamples of factor from LinearOrdinaryDifferentialOperatorFactorizer
--R
--R
--RExamples of factor from LyndonWord
--R
--R
--RExamples of factor from ModularDistinctDegreeFactorizer
--R
--R
--RExamples of factor from MultFiniteFactorize
--R
--R
--RExamples of factor from MPolyCatPolyFactorizer
--R
--R
--RExamples of factor from MPolyCatRationalFunctionFactorizer
--R
--R
--RExamples of factor from MRationalFactorize
--R
--R
--RExamples of factor from MultivariateFactorize
--R
--R
--RExamples of factor from RationalFactorize
--R
--R
--RExamples of factor from RationalFunctionFactor
--R
--R
--RExamples of factor from SimpleAlgebraicExtensionAlgFactor
--R
--R
--RExamples of factor from SAERationalFunctionAlgFactor
--R
--R
--RExamples of factor from SupFractionFactorizer
--R
--R
--RExamples of factor from UniqueFactorizationDomain
--R
--R
--RExamples of factor from UnivariateFactorize
--R
--E 981

--S 982 of 3320
)d op factor1
--R 
--R
--RThere is one unexposed function called factor1 :
--R   [1] LinearOrdinaryDifferentialOperator1(Fraction(D4)) -> List(
--R            LinearOrdinaryDifferentialOperator1(Fraction(D4)))
--R             from LinearOrdinaryDifferentialOperatorFactorizer(D3,D4)
--R             if D3 has ACF and D3 has Join(Field,CharacteristicZero,
--R            RetractableTo(Integer),RetractableTo(Fraction(Integer))) 
--R            and D4 has UPOLYC(D3)
--R
--RExamples of factor1 from LinearOrdinaryDifferentialOperatorFactorizer
--R
--E 982

--S 983 of 3320
)d op factorAndSplit
--R 
--R
--RThere is one exposed function called factorAndSplit :
--R   [1] Equation(D2) -> List(Equation(D2)) from Equation(D2)
--R             if D2 has INTDOM and D2 has TYPE
--R
--RExamples of factorAndSplit from Equation
--R
--E 983

--S 984 of 3320
)d op factorByRecursion
--R 
--R
--RThere are 2 unexposed functions called factorByRecursion :
--R   [1] SparseUnivariatePolynomial(D6) -> Factored(
--R            SparseUnivariatePolynomial(D6))
--R             from PolynomialFactorizationByRecursion(D3,D4,D5,D6)
--R             if D3 has PFECAT and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has POLYCAT(D3,D4,D5)
--R   [2] SparseUnivariatePolynomial(D4) -> Factored(
--R            SparseUnivariatePolynomial(D4))
--R             from PolynomialFactorizationByRecursionUnivariate(D3,D4)
--R             if D3 has PFECAT and D4 has UPOLYC(D3)
--R
--RExamples of factorByRecursion from PolynomialFactorizationByRecursion
--R
--R
--RExamples of factorByRecursion from PolynomialFactorizationByRecursionUnivariate
--R
--E 984

--S 985 of 3320
)d op factorCantorZassenhaus
--R 
--R
--RThere are 2 exposed functions called factorCantorZassenhaus :
--R   [1] (D2,NonNegativeInteger) -> List(D2) from 
--R            FiniteFieldFactorization(D4,D2)
--R             if D4 has FFIELDC and D2 has UPOLYC(D4)
--R   [2] (D2,NonNegativeInteger) -> List(D2)
--R             from FiniteFieldFactorizationWithSizeParseBySideEffect(D4,
--R            D2)
--R             if D4 has FFIELDC and D2 has UPOLYC(D4)
--R
--RExamples of factorCantorZassenhaus from FiniteFieldFactorization
--R
--R
--RExamples of factorCantorZassenhaus from FiniteFieldFactorizationWithSizeParseBySideEffect
--R
--E 985

--S 986 of 3320
)d op factorFraction
--R 
--R
--RThere is one exposed function called factorFraction :
--R   [1] Fraction(Polynomial(D3)) -> Fraction(Factored(Polynomial(D3)))
--R             from RationalFunctionFactorizer(D3) if D3 has EUCDOM
--R
--RExamples of factorFraction from RationalFunctionFactorizer
--R
--E 986

--S 987 of 3320
)d op factorGroebnerBasis
--R 
--R
--RThere are 2 exposed functions called factorGroebnerBasis :
--R   [1] List(D6) -> List(List(D6)) from GroebnerFactorizationPackage(D3,
--R            D4,D5,D6)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D4
--R             has OAMONS and D5 has ORDSET and D6 has POLYCAT(D3,D4,D5)
--R            
--R   [2] (List(D7),Boolean) -> List(List(D7))
--R             from GroebnerFactorizationPackage(D4,D5,D6,D7)
--R             if D4 has Join(EuclideanDomain,CharacteristicZero) and D5
--R             has OAMONS and D6 has ORDSET and D7 has POLYCAT(D4,D5,D6)
--R            
--R
--RExamples of factorGroebnerBasis from GroebnerFactorizationPackage
--R
--E 987

--S 988 of 3320
)d op factorial
--R 
--R
--RThere are 2 exposed functions called factorial :
--R   [1] D -> D from D if D has CFCAT
--R   [2] D1 -> D1 from IntegerCombinatoricFunctions(D1) if D1 has INS
--R
--RThere is one unexposed function called factorial :
--R   [1] D1 -> D1 from CombinatorialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of factorial from CombinatorialFunctionCategory
--R
--R
--RExamples of factorial from CombinatorialFunction
--R
--R
--RExamples of factorial from IntegerCombinatoricFunctions
--R
--E 988

--S 989 of 3320
)d op factorials
--R 
--R
--RThere are 2 exposed functions called factorials :
--R   [1] (D,Symbol) -> D from D if D has COMBOPC
--R   [2] D -> D from D if D has COMBOPC
--R
--RThere are 2 unexposed functions called factorials :
--R   [1] D1 -> D1 from CombinatorialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R   [2] (D1,Symbol) -> D1 from CombinatorialFunction(D3,D1)
--R             if D3 has Join(OrderedSet,IntegralDomain) and D1 has FS(D3
--R            )
--R
--RExamples of factorials from CombinatorialFunction
--R
--R
--RExamples of factorials from CombinatorialOpsCategory
--R
--E 989

--S 990 of 3320
)d op factorList
--R 
--R
--RThere is one exposed function called factorList :
--R   [1] Factored(D2) -> List(Record(flg: Union("nil","sqfr","irred",
--R            "prime"),fctr: D2,xpnt: Integer))
--R             from Factored(D2) if D2 has INTDOM
--R
--RThere is one unexposed function called factorList :
--R   [1] (D2,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)
--R             -> List(SparseUnivariatePolynomial(D2))
--R             from ChineseRemainderToolsForIntegralBases(D2,D4,D5)
--R             if D2 has FFIELDC and D4 has UPOLYC(D2) and D5 has UPOLYC(
--R            D4)
--R
--RExamples of factorList from Factored
--R
--Rf:=nilFactor(x-y,3) 
--RfactorList f
--R
--R
--RExamples of factorList from ChineseRemainderToolsForIntegralBases
--R
--E 990

--S 991 of 3320
)d op factorOfDegree
--R 
--R
--RThere are 6 unexposed functions called factorOfDegree :
--R   [1] (PositiveInteger,D1) -> Union(D1,"failed") from 
--R            GaloisGroupFactorizer(D1)
--R             if D1 has UPOLYC(INT)
--R   [2] (PositiveInteger,D1,NonNegativeInteger) -> Union(D1,"failed")
--R             from GaloisGroupFactorizer(D1) if D1 has UPOLYC(INT)
--R   [3] (PositiveInteger,D1,List(NonNegativeInteger)) -> Union(D1,
--R            "failed")
--R             from GaloisGroupFactorizer(D1) if D1 has UPOLYC(INT)
--R   [4] (PositiveInteger,D1,List(NonNegativeInteger),NonNegativeInteger)
--R             -> Union(D1,"failed")
--R             from GaloisGroupFactorizer(D1) if D1 has UPOLYC(INT)
--R   [5] (PositiveInteger,D1,List(NonNegativeInteger),NonNegativeInteger,
--R            Boolean) -> Union(D1,"failed")
--R             from GaloisGroupFactorizer(D1) if D1 has UPOLYC(INT)
--R   [6] (PositiveInteger,Factored(D1)) -> D1
--R             from GaloisGroupPolynomialUtilities(D4,D1)
--R             if D1 has UPOLYC(D4) and D4 has RING
--R
--RExamples of factorOfDegree from GaloisGroupFactorizer
--R
--R
--RExamples of factorOfDegree from GaloisGroupPolynomialUtilities
--R
--E 991

--S 992 of 3320
)d op factorPolynomial
--R 
--R
--RThere are 2 exposed functions called factorPolynomial :
--R   [1] SparseUnivariatePolynomial(Expression(D3)) -> Factored(
--R            SparseUnivariatePolynomial(Expression(D3)))
--R             from Expression(D3) if D3 has GCDDOM and D3 has INTDOM and
--R            D3 has ORDSET
--R   [2] SparseUnivariatePolynomial(D) -> Factored(
--R            SparseUnivariatePolynomial(D))
--R             from D if D has PFECAT
--R
--RExamples of factorPolynomial from Expression
--R
--R
--RExamples of factorPolynomial from PolynomialFactorizationExplicit
--R
--E 992

--S 993 of 3320
)d op factors
--R 
--R
--RThere is one exposed function called factors :
--R   [1] Factored(D2) -> List(Record(factor: D2,exponent: Integer))
--R             from Factored(D2) if D2 has INTDOM
--R
--RThere are 3 unexposed functions called factors :
--R   [1] FreeGroup(D2) -> List(Record(gen: D2,exp: Integer)) from 
--R            FreeGroup(D2)
--R             if D2 has SETCAT
--R   [2] FreeMonoid(D2) -> List(Record(gen: D2,exp: NonNegativeInteger))
--R             from FreeMonoid(D2) if D2 has SETCAT
--R   [3] OrderedFreeMonoid(D2) -> List(Record(gen: D2,exp: 
--R            NonNegativeInteger))
--R             from OrderedFreeMonoid(D2) if D2 has ORDSET
--R
--RExamples of factors from FreeGroup
--R
--R
--RExamples of factors from FreeMonoid
--R
--R
--RExamples of factors from Factored
--R
--Rf:=x*y^3-3*x^2*y^2+3*x^3*y-x^4 
--Rfactors f 
--Rg:=makeFR(z,factorList f) 
--Rfactors g
--R
--R
--RExamples of factors from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rfactors m1
--R
--E 993

--S 994 of 3320
)d op factorset
--R 
--R
--RThere is one unexposed function called factorset :
--R   [1] D2 -> List(D2) from ParametricLinearEquations(D3,D4,D5,D2)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D4
--R             has Join(OrderedSet,ConvertibleTo(Symbol)) and D5 has 
--R            OAMONS and D2 has POLYCAT(D3,D5,D4)
--R
--RExamples of factorset from ParametricLinearEquations
--R
--E 994

--S 995 of 3320
)d op factorSFBRlcUnit
--R 
--R
--RThere are 2 unexposed functions called factorSFBRlcUnit :
--R   [1] (List(D6),SparseUnivariatePolynomial(D7)) -> Factored(
--R            SparseUnivariatePolynomial(D7))
--R             from PolynomialFactorizationByRecursion(D4,D5,D6,D7)
--R             if D6 has ORDSET and D4 has PFECAT and D5 has OAMONS and 
--R            D7 has POLYCAT(D4,D5,D6)
--R   [2] SparseUnivariatePolynomial(D4) -> Factored(
--R            SparseUnivariatePolynomial(D4))
--R             from PolynomialFactorizationByRecursionUnivariate(D3,D4)
--R             if D3 has PFECAT and D4 has UPOLYC(D3)
--R
--RExamples of factorSFBRlcUnit from PolynomialFactorizationByRecursion
--R
--R
--RExamples of factorSFBRlcUnit from PolynomialFactorizationByRecursionUnivariate
--R
--E 995

--S 996 of 3320
)d op factorsOfCyclicGroupSize
--R 
--R
--RThere is one exposed function called factorsOfCyclicGroupSize :
--R   [1]  -> List(Record(factor: Integer,exponent: Integer)) from D if D
--R             has FFIELDC
--R
--RExamples of factorsOfCyclicGroupSize from FiniteFieldCategory
--R
--E 996

--S 997 of 3320
)d op factorsOfDegree
--R 
--R
--RThere is one unexposed function called factorsOfDegree :
--R   [1] (PositiveInteger,Factored(D5)) -> List(D5)
--R             from GaloisGroupPolynomialUtilities(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has RING
--R
--RExamples of factorsOfDegree from GaloisGroupPolynomialUtilities
--R
--E 997

--S 998 of 3320
)d op factorSqFree
--R 
--R
--RThere are 2 exposed functions called factorSqFree :
--R   [1] (SparseUnivariatePolynomial(D3),D3) -> Factored(
--R            SparseUnivariatePolynomial(D3))
--R             from 
--R            FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber
--R            (D3)
--R             if D3 has PACEXTC
--R   [2] (SparseUnivariatePolynomial(D3),D3) -> Factored(
--R            SparseUnivariatePolynomial(D3))
--R             from 
--R            FactorisationOverPseudoAlgebraicClosureOfRationalNumber(D3)
--R             if D3 has PACRATC
--R
--RExamples of factorSqFree from FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber
--R
--R
--RExamples of factorSqFree from FactorisationOverPseudoAlgebraicClosureOfRationalNumber
--R
--E 998

--S 999 of 3320
)d op factorSquareFree
--R 
--R
--RThere are 3 exposed functions called factorSquareFree :
--R   [1] D2 -> Factored(D2) from DistinctDegreeFactorize(D3,D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R   [2] D2 -> List(D2) from FiniteFieldFactorization(D3,D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R   [3] D2 -> List(D2)
--R             from FiniteFieldFactorizationWithSizeParseBySideEffect(D3,
--R            D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R
--RThere are 7 unexposed functions called factorSquareFree :
--R   [1] D2 -> Factored(D2) from GaloisGroupFactorizer(D2) if D2 has 
--R            UPOLYC(INT)
--R   [2] (D2,NonNegativeInteger) -> Factored(D2) from 
--R            GaloisGroupFactorizer(D2)
--R             if D2 has UPOLYC(INT)
--R   [3] (D2,List(NonNegativeInteger)) -> Factored(D2)
--R             from GaloisGroupFactorizer(D2) if D2 has UPOLYC(INT)
--R   [4] (D2,List(NonNegativeInteger),NonNegativeInteger) -> Factored(D2)
--R             from GaloisGroupFactorizer(D2) if D2 has UPOLYC(INT)
--R   [5] (D2,NonNegativeInteger,NonNegativeInteger) -> Factored(D2)
--R             from GaloisGroupFactorizer(D2) if D2 has UPOLYC(INT)
--R   [6] D2 -> Factored(D2) from RationalFactorize(D2) if D2 has UPOLYC(
--R            FRAC(INT))
--R   [7] D2 -> Factored(D2) from UnivariateFactorize(D2) if D2 has UPOLYC
--R            (INT)
--R
--RExamples of factorSquareFree from DistinctDegreeFactorize
--R
--R
--RExamples of factorSquareFree from FiniteFieldFactorization
--R
--R
--RExamples of factorSquareFree from FiniteFieldFactorizationWithSizeParseBySideEffect
--R
--R
--RExamples of factorSquareFree from GaloisGroupFactorizer
--R
--R
--RExamples of factorSquareFree from RationalFactorize
--R
--R
--RExamples of factorSquareFree from UnivariateFactorize
--R
--E 999

--S 1000 of 3320
)d op factorSquareFreeByRecursion
--R 
--R
--RThere are 2 unexposed functions called factorSquareFreeByRecursion :
--R   [1] SparseUnivariatePolynomial(D6) -> Factored(
--R            SparseUnivariatePolynomial(D6))
--R             from PolynomialFactorizationByRecursion(D3,D4,D5,D6)
--R             if D3 has PFECAT and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has POLYCAT(D3,D4,D5)
--R   [2] SparseUnivariatePolynomial(D4) -> Factored(
--R            SparseUnivariatePolynomial(D4))
--R             from PolynomialFactorizationByRecursionUnivariate(D3,D4)
--R             if D3 has PFECAT and D4 has UPOLYC(D3)
--R
--RExamples of factorSquareFreeByRecursion from PolynomialFactorizationByRecursion
--R
--R
--RExamples of factorSquareFreeByRecursion from PolynomialFactorizationByRecursionUnivariate
--R
--E 1000

--S 1001 of 3320
)d op factorSquareFreePolynomial
--R 
--R
--RThere is one exposed function called factorSquareFreePolynomial :
--R   [1] SparseUnivariatePolynomial(D) -> Factored(
--R            SparseUnivariatePolynomial(D))
--R             from D if D has PFECAT
--R
--RExamples of factorSquareFreePolynomial from PolynomialFactorizationExplicit
--R
--E 1001

--S 1002 of 3320
)d op factorUsingMusser
--R 
--R
--RThere are 2 exposed functions called factorUsingMusser :
--R   [1] D2 -> Factored(D2) from FiniteFieldFactorization(D3,D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R   [2] D2 -> Factored(D2)
--R             from FiniteFieldFactorizationWithSizeParseBySideEffect(D3,
--R            D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R
--RExamples of factorUsingMusser from FiniteFieldFactorization
--R
--R
--RExamples of factorUsingMusser from FiniteFieldFactorizationWithSizeParseBySideEffect
--R
--E 1002

--S 1003 of 3320
)d op factorUsingYun
--R 
--R
--RThere are 2 exposed functions called factorUsingYun :
--R   [1] D2 -> Factored(D2) from FiniteFieldFactorization(D3,D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R   [2] D2 -> Factored(D2)
--R             from FiniteFieldFactorizationWithSizeParseBySideEffect(D3,
--R            D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R
--RExamples of factorUsingYun from FiniteFieldFactorization
--R
--R
--RExamples of factorUsingYun from FiniteFieldFactorizationWithSizeParseBySideEffect
--R
--E 1003

--S 1004 of 3320
)d op failed
--R 
--R
--RThere are 2 unexposed functions called failed :
--R   [1]  -> PatternMatchListResult(D1,D2,D3)
--R             from PatternMatchListResult(D1,D2,D3)
--R             if D2 has SETCAT and D1 has SETCAT and D3 has LSAGG(D2)
--R         
--R   [2]  -> PatternMatchResult(D1,D2) from PatternMatchResult(D1,D2)
--R             if D1 has SETCAT and D2 has SETCAT
--R
--RExamples of failed from PatternMatchListResult
--R
--R
--RExamples of failed from PatternMatchResult
--R
--E 1004

--S 1005 of 3320
)d op failed?
--R 
--R
--RThere are 2 unexposed functions called failed? :
--R   [1] PatternMatchListResult(D2,D3,D4) -> Boolean
--R             from PatternMatchListResult(D2,D3,D4)
--R             if D3 has SETCAT and D2 has SETCAT and D4 has LSAGG(D3)
--R         
--R   [2] PatternMatchResult(D2,D3) -> Boolean from PatternMatchResult(D2,
--R            D3)
--R             if D2 has SETCAT and D3 has SETCAT
--R
--RExamples of failed? from PatternMatchListResult
--R
--R
--RExamples of failed? from PatternMatchResult
--R
--E 1005

--S 1006 of 3320
)d op false
--R 
--R
--RThere is one exposed function called false :
--R   [1]  -> Boolean from Boolean
--R
--RExamples of false from Boolean
--R
--E 1006

--S 1007 of 3320
)d op ffactor
--R 
--R
--RThere is one unexposed function called ffactor :
--R   [1] D2 -> Factored(D2) from FunctionSpaceUnivariatePolynomialFactor(
--R            D3,D4,D2)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer)) and D4 has FS(D3) and D2 has UPOLYC(D4)
--R
--RExamples of ffactor from FunctionSpaceUnivariatePolynomialFactor
--R
--E 1007

--S 1008 of 3320
)d op fffg
--R 
--R
--RThere is one exposed function called fffg :
--R   [1] (List(D5),((NonNegativeInteger,Vector(SparseUnivariatePolynomial
--R            (D5))) -> D5),List(NonNegativeInteger)) -> Matrix(
--R            SparseUnivariatePolynomial(D5))
--R             from FractionFreeFastGaussian(D5,D6)
--R             if D5 has Join(IntegralDomain,GcdDomain) and D6 has AMR(D5
--R            ,NNI)
--R
--RExamples of fffg from FractionFreeFastGaussian
--R
--E 1008

--S 1009 of 3320
)d op FG2F
--R 
--R
--RThere is one unexposed function called FG2F :
--R   [1] D2 -> D1 from InnerTrigonometricManipulations(D3,D1,D2)
--R             if D3 has Join(IntegralDomain,OrderedSet) and D1 has Join(
--R            FunctionSpace(D3),RadicalCategory,
--R            TranscendentalFunctionCategory) and D2 has Join(
--R            FunctionSpace(Complex(D3)),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R
--RExamples of FG2F from InnerTrigonometricManipulations
--R
--E 1009

--S 1010 of 3320
)d op fglmIfCan
--R 
--R
--RThere are 2 unexposed functions called fglmIfCan :
--R   [1] List(Polynomial(D2)) -> Union(List(Polynomial(D2)),"failed")
--R             from FGLMIfCanPackage(D2,D3) if D2 has GCDDOM and D3: LIST
--R            (SYMBOL)
--R   [2] List(NewSparseMultivariatePolynomial(D2,OrderedVariableList(D3))
--R            ) -> Union(List(NewSparseMultivariatePolynomial(D2,
--R            OrderedVariableList(D3))),"failed")
--R             from LexTriangularPackage(D2,D3) if D2 has GCDDOM and D3: 
--R            LIST(SYMBOL)
--R
--RExamples of fglmIfCan from FGLMIfCanPackage
--R
--R
--RExamples of fglmIfCan from LexTriangularPackage
--R
--E 1010

--S 1011 of 3320
)d op fi2df
--R 
--R
--RThere is one exposed function called fi2df :
--R   [1] Fraction(Integer) -> DoubleFloat from ExpertSystemToolsPackage
--R         
--R
--RExamples of fi2df from ExpertSystemToolsPackage
--R
--E 1011

--S 1012 of 3320
)d op fibonacci
--R 
--R
--RThere is one exposed function called fibonacci :
--R   [1] Integer -> Integer from IntegerNumberTheoryFunctions
--R
--RExamples of fibonacci from IntegerNumberTheoryFunctions
--R
--E 1012

--S 1013 of 3320
)d op figureUnits
--R 
--R
--RThere is one unexposed function called figureUnits :
--R   [1] List(List(Point(DoubleFloat))) -> List(DoubleFloat) from 
--R            GraphImage
--R
--RExamples of figureUnits from GraphImage
--R
--E 1013

--S 1014 of 3320
)d op filename
--R 
--R
--RThere is one exposed function called filename :
--R   [1] (String,String,String) -> D from D if D has FNCAT
--R
--RExamples of filename from FileNameCategory
--R
--E 1014

--S 1015 of 3320
)d op fill!
--R 
--R
--RThere are 2 exposed functions called fill! :
--R   [1] (D,D1) -> D from D
--R             if D has ARR2CAT(D1,D2,D3) and D1 has TYPE and D2 has 
--R            FLAGG(D1) and D3 has FLAGG(D1)
--R   [2] (D,D1) -> D from D
--R             if D has shallowlyMutable and D has IXAGG(D2,D1) and D2
--R             has SETCAT and D1 has TYPE
--R
--RExamples of fill! from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,0) 
--Rfill!(arr,10)
--R
--R
--RExamples of fill! from IndexedAggregate
--R
--E 1015

--S 1016 of 3320
)d op fillPascalTriangle
--R 
--R
--RThere is one unexposed function called fillPascalTriangle :
--R   [1]  -> Void from GaloisGroupUtilities(D2) if D2 has RING
--R
--RExamples of fillPascalTriangle from GaloisGroupUtilities
--R
--E 1016

--S 1017 of 3320
)d op filterUntil
--R 
--R
--RThere are 2 exposed functions called filterUntil :
--R   [1] ((D2 -> Boolean),InfiniteTuple(D2)) -> InfiniteTuple(D2)
--R             from InfiniteTuple(D2) if D2 has TYPE
--R   [2] ((D2 -> Boolean),Stream(D2)) -> Stream(D2) from Stream(D2) if D2
--R             has TYPE
--R
--RExamples of filterUntil from InfiniteTuple
--R
--R
--RExamples of filterUntil from Stream
--R
--Rm:=[i for i in 1..] 
--Rf(x:PositiveInteger):Boolean == x < 5 
--RfilterUntil(f,m)
--R
--E 1017

--S 1018 of 3320
)d op filterUpTo
--R 
--R
--RThere is one exposed function called filterUpTo :
--R   [1] (D,Integer) -> D from D if D has LOCPOWC(D2) and D2 has FIELD
--R         
--R
--RExamples of filterUpTo from LocalPowerSeriesCategory
--R
--E 1018

--S 1019 of 3320
)d op filterWhile
--R 
--R
--RThere are 2 exposed functions called filterWhile :
--R   [1] ((D2 -> Boolean),InfiniteTuple(D2)) -> InfiniteTuple(D2)
--R             from InfiniteTuple(D2) if D2 has TYPE
--R   [2] ((D2 -> Boolean),Stream(D2)) -> Stream(D2) from Stream(D2) if D2
--R             has TYPE
--R
--RExamples of filterWhile from InfiniteTuple
--R
--R
--RExamples of filterWhile from Stream
--R
--Rm:=[i for i in 1..] 
--Rf(x:PositiveInteger):Boolean == x < 5 
--RfilterWhile(f,m)
--R
--E 1019

--S 1020 of 3320
)d op find
--R 
--R
--RThere is one exposed function called find :
--R   [1] ((D1 -> Boolean),D) -> Union(D1,"failed") from D
--R             if D has CLAGG(D1) and D1 has TYPE
--R
--RExamples of find from Collection
--R
--E 1020

--S 1021 of 3320
)d op findCoef
--R 
--R
--RThere is one exposed function called findCoef :
--R   [1] (D,Integer) -> D1 from D if D has LOCPOWC(D1) and D1 has FIELD
--R         
--R
--RExamples of findCoef from LocalPowerSeriesCategory
--R
--E 1021

--S 1022 of 3320 done
)d op findCycle
--R 
--R
--RThere is one exposed function called findCycle :
--R   [1] (NonNegativeInteger,Stream(D3)) -> Record(cycle?: Boolean,prefix
--R            : NonNegativeInteger,period: NonNegativeInteger)
--R             from Stream(D3) if D3 has TYPE
--R
--RExamples of findCycle from Stream
--R
--Rm:=[1,2,3] 
--Rn:=repeating(m) 
--RfindCycle(3,n) 
--RfindCycle(2,n)
--R
--E 1022

--S 1023 of 3320
)d op findOrderOfDivisor
--R 
--R
--RThere are 3 exposed functions called findOrderOfDivisor :
--R   [1] (D7,Integer,Integer) -> Record(ord: Integer,num: D11,den: D11,
--R            upTo: Integer)
--R             from GeneralPackageForAlgebraicFunctionField(D9,D10,D11,
--R            D12,D13,D1,D2,D7,D3,D4,D5)
--R             if D9 has FIELD and D10: LIST(SYMBOL) and D11 has POLYCAT(
--R            D9,D12,OVAR(D10)) and D12 has DIRPCAT(#(D10),NNI) and D13
--R             has PRSPCAT(D9) and D1 has LOCPOWC(D9) and D2 has PLACESC(
--R            D9,D1) and D7 has DIVCAT(D2) and D3 has INFCLCT(D9,D10,D11,
--R            D12,D13,D1,D2,D7,D5) and D5 has BLMETCT and D4 has DSTRCAT(
--R            D3)
--R   [2] (Divisor(PlacesOverPseudoAlgebraicClosureOfFiniteField(D4)),
--R            Integer,Integer) -> Record(ord: Integer,num: 
--R            DistributedMultivariatePolynomial(D5,D4),den: 
--R            DistributedMultivariatePolynomial(D5,D4),upTo: Integer)
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D4,D5
--R            ,D6)
--R             if D4 has FFIELDC and D5: LIST(SYMBOL) and D6 has BLMETCT
--R            
--R   [3] (Divisor(Places(D4)),Integer,Integer) -> Record(ord: Integer,num
--R            : DistributedMultivariatePolynomial(D5,D4),den: 
--R            DistributedMultivariatePolynomial(D5,D4),upTo: Integer)
--R             from PackageForAlgebraicFunctionField(D4,D5,D6)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D6 has BLMETCT
--R         
--R
--RExamples of findOrderOfDivisor from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of findOrderOfDivisor from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of findOrderOfDivisor from PackageForAlgebraicFunctionField
--R
--E 1023

--S 1024 of 3320
)d op findTerm
--R 
--R
--RThere is one exposed function called findTerm :
--R   [1] (NeitherSparseOrDensePowerSeries(D3),Integer) -> Record(k: 
--R            Integer,c: D3)
--R             from NeitherSparseOrDensePowerSeries(D3) if D3 has FIELD
--R         
--R
--RExamples of findTerm from NeitherSparseOrDensePowerSeries
--R
--E 1024

--S 1025 of 3320
)d op finite?
--R 
--R
--RThere are 3 exposed functions called finite? :
--R   [1] CardinalNumber -> Boolean from CardinalNumber
--R   [2] OnePointCompletion(D2) -> Boolean from OnePointCompletion(D2)
--R             if D2 has SETCAT
--R   [3] OrderedCompletion(D2) -> Boolean from OrderedCompletion(D2) if 
--R            D2 has SETCAT
--R
--RExamples of finite? from CardinalNumber
--R
--Rc2:=2::CardinalNumber 
--Rfinite? c2 
--RA0:=Aleph 0 
--Rfinite? A0
--R
--R
--RExamples of finite? from OnePointCompletion
--R
--R
--RExamples of finite? from OrderedCompletion
--R
--E 1025

--S 1026 of 3320
)d op finiteBasis
--R 
--R
--RThere is one unexposed function called finiteBasis :
--R   [1] FiniteDivisor(D2,D3,D4,D5) -> Vector(D5) from FiniteDivisor(D2,
--R            D3,D4,D5)
--R             if D2 has FIELD and D3 has UPOLYC(D2) and D4 has UPOLYC(
--R            FRAC(D3)) and D5 has FFCAT(D2,D3,D4)
--R
--RExamples of finiteBasis from FiniteDivisor
--R
--E 1026

--S 1027 of 3320
)d op finiteBound
--R 
--R
--RThere is one exposed function called finiteBound :
--R   [1] (List(OrderedCompletion(DoubleFloat)),DoubleFloat) -> List(
--R            DoubleFloat)
--R             from e04AgentsPackage
--R
--RExamples of finiteBound from e04AgentsPackage
--R
--E 1027

--S 1028 of 3320
)d op finiteSeries2LinSys
--R 
--R
--RThere is one exposed function called finiteSeries2LinSys :
--R   [1] (List(D5),Integer) -> Matrix(D4)
--R             from LinearSystemFromPowerSeriesPackage(D4,D5)
--R             if D5 has LOCPOWC(D4) and D4 has FIELD
--R
--RExamples of finiteSeries2LinSys from LinearSystemFromPowerSeriesPackage
--R
--E 1028

--S 1029 of 3320
)d op finiteSeries2LinSysWOVectorise
--R 
--R
--RThere is one exposed function called finiteSeries2LinSysWOVectorise :
--R   [1] (List(D5),Integer) -> Matrix(D4)
--R             from LinearSystemFromPowerSeriesPackage(D4,D5)
--R             if D5 has LOCPOWC(D4) and D4 has FIELD
--R
--RExamples of finiteSeries2LinSysWOVectorise from LinearSystemFromPowerSeriesPackage
--R
--E 1029

--S 1030 of 3320
)d op finiteSeries2Vector
--R 
--R
--RThere is one exposed function called finiteSeries2Vector :
--R   [1] (D2,Integer) -> List(D4) from LinearSystemFromPowerSeriesPackage
--R            (D4,D2)
--R             if D4 has FIELD and D2 has LOCPOWC(D4)
--R
--RExamples of finiteSeries2Vector from LinearSystemFromPowerSeriesPackage
--R
--E 1030

--S 1031 of 3320
)d op fintegrate
--R 
--R
--RThere is one exposed function called fintegrate :
--R   [1] ((() -> TaylorSeries(D3)),Symbol,D3) -> TaylorSeries(D3)
--R             from TaylorSeries(D3) if D3 has ALGEBRA(FRAC(INT)) and D3
--R             has RING
--R
--RThere is one unexposed function called fintegrate :
--R   [1] ((() -> SparseMultivariateTaylorSeries(D3,D2,D4)),D2,D3) -> 
--R            SparseMultivariateTaylorSeries(D3,D2,D4)
--R             from SparseMultivariateTaylorSeries(D3,D2,D4)
--R             if D3 has ALGEBRA(FRAC(INT)) and D3 has RING and D2 has 
--R            ORDSET and D4 has POLYCAT(D3,INDE(D2),D2)
--R
--RExamples of fintegrate from SparseMultivariateTaylorSeries
--R
--R
--RExamples of fintegrate from TaylorSeries
--R
--E 1031

--S 1032 of 3320
)d op first
--R 
--R
--RThere are 4 exposed functions called first :
--R   [1] D -> D1 from D
--R             if D has IXAGG(D2,D1) and D2 has SETCAT and D2 has ORDSET 
--R            and D1 has TYPE
--R   [2] D -> Union(D1,"failed") from D
--R             if D has TSETCAT(D2,D3,D4,D1) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D1 has RPOLCAT(D2,D3,D4)
--R            
--R   [3] (D,NonNegativeInteger) -> D from D if D has URAGG(D2) and D2
--R             has TYPE
--R   [4] D -> D1 from D if D has URAGG(D1) and D1 has TYPE
--R
--RThere are 3 unexposed functions called first :
--R   [1] Magma(D1) -> D1 from Magma(D1) if D1 has ORDSET
--R   [2] OrderedFreeMonoid(D1) -> D1 from OrderedFreeMonoid(D1) if D1
--R             has ORDSET
--R   [3] PoincareBirkhoffWittLyndonBasis(D2) -> LyndonWord(D2)
--R             from PoincareBirkhoffWittLyndonBasis(D2) if D2 has ORDSET
--R            
--R
--RExamples of first from IndexedAggregate
--R
--R
--RExamples of first from Magma
--R
--R
--RExamples of first from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rfirst m1
--R
--R
--RExamples of first from PoincareBirkhoffWittLyndonBasis
--R
--R
--RExamples of first from TriangularSetCategory
--R
--R
--RExamples of first from UnaryRecursiveAggregate
--R
--Rfirst [1,4,2,-6,0,3,5,4,2,3]
--R
--E 1032

--S 1033 of 3320 done
)d op firstDenom
--R 
--R
--RThere is one exposed function called firstDenom :
--R   [1] PartialFraction(D2) -> Factored(D2) from PartialFraction(D2) if 
--R            D2 has EUCDOM
--R
--RExamples of firstDenom from PartialFraction
--R
--Ra:=partialFraction(1,factorial 10) 
--RfirstDenom(a)
--R
--E 1033

--S 1034 of 3320
)d op firstExponent
--R 
--R
--RThere is one exposed function called firstExponent :
--R   [1] D2 -> D1 from PackageForPoly(D3,D2,D1,D4)
--R             if D3 has RING and D1 has DIRPCAT(D4,NNI) and D2 has FAMR(
--R            D3,D1) and D4: NNI
--R
--RExamples of firstExponent from PackageForPoly
--R
--E 1034

--S 1035 of 3320 done
)d op firstNumer
--R 
--R
--RThere is one exposed function called firstNumer :
--R   [1] PartialFraction(D1) -> D1 from PartialFraction(D1) if D1 has 
--R            EUCDOM
--R
--RExamples of firstNumer from PartialFraction
--R
--Ra:=partialFraction(1,factorial 10) 
--RfirstNumer(a)
--R
--E 1035

--S 1036 of 3320
)d op firstSubsetGray
--R 
--R
--RThere is one unexposed function called firstSubsetGray :
--R   [1] PositiveInteger -> Vector(Vector(Integer)) from GrayCode
--R
--RExamples of firstSubsetGray from GrayCode
--R
--E 1036

--S 1037 of 3320
)d op firstUncouplingMatrix
--R 
--R
--RThere is one unexposed function called firstUncouplingMatrix :
--R   [1] (D2,PositiveInteger) -> Union(Matrix(D4),"failed")
--R             from PrecomputedAssociatedEquations(D4,D2)
--R             if D4 has INTDOM and D2 has LODOCAT(D4)
--R
--RExamples of firstUncouplingMatrix from PrecomputedAssociatedEquations
--R
--E 1037

--S 1038 of 3320
)d op fixedDivisor
--R 
--R
--RThere is one unexposed function called fixedDivisor :
--R   [1] SparseUnivariatePolynomial(Integer) -> Integer
--R             from PolynomialNumberTheoryFunctions
--R
--RExamples of fixedDivisor from PolynomialNumberTheoryFunctions
--R
--E 1038

--S 1039 of 3320
)d op fixedPoint
--R 
--R
--RThere are 2 exposed functions called fixedPoint :
--R   [1] (D1 -> D1) -> D1 from MappingPackage1(D1) if D1 has SETCAT
--R   [2] ((List(D4) -> List(D4)),Integer) -> List(D4) from 
--R            MappingPackage1(D4)
--R             if D4 has SETCAT
--R
--RExamples of fixedPoint from MappingPackage1
--R
--E 1039

--S 1040 of 3320
)d op fixedPointExquo
--R 
--R
--RThere is one unexposed function called fixedPointExquo :
--R   [1] (D1,D1) -> D1 from UnivariateTaylorSeriesODESolver(D2,D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D1 has UTSCAT(D2)
--R
--RExamples of fixedPointExquo from UnivariateTaylorSeriesODESolver
--R
--E 1040

--S 1041 of 3320 done
)d op fixedPoints
--R 
--R
--RThere is one exposed function called fixedPoints :
--R   [1] Permutation(D2) -> Set(D2) from Permutation(D2)
--R             if D2 has FINITE and D2 has SETCAT
--R
--RExamples of fixedPoints from Permutation
--R
--Rp := coercePreimagesImages([[0,1,2,3],[3,0,2,1]])$PERM ZMOD 4 
--RfixedPoints p
--R
--E 1041

--S 1042 of 3320
)d op fixPredicate
--R 
--R
--RThere is one unexposed function called fixPredicate :
--R   [1] (D5 -> Boolean) -> (D4 -> Boolean) from PatternMatchPushDown(D3,
--R            D4,D5)
--R             if D5 has Join(SetCategory,RetractableTo(D4)) and D4 has 
--R            PATMAB(D3) and D3 has SETCAT
--R
--RExamples of fixPredicate from PatternMatchPushDown
--R
--E 1042

--S 1043 of 3320
)d op flagFactor
--R 
--R
--RThere is one exposed function called flagFactor :
--R   [1] (D1,Integer,Union("nil","sqfr","irred","prime")) -> Factored(D1)
--R             from Factored(D1) if D1 has INTDOM
--R
--RExamples of flagFactor from Factored
--R
--E 1043

--S 1044 of 3320
)d op flatten
--R 
--R
--RThere is one unexposed function called flatten :
--R   [1] InputForm -> InputForm from InputForm
--R
--RExamples of flatten from InputForm
--R
--E 1044

--S 1045 of 3320
)d op flexible?
--R 
--R
--RThere is one exposed function called flexible? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called flexible? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of flexible? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of flexible? from FiniteRankNonAssociativeAlgebra
--R
--E 1045

--S 1046 of 3320
)d op flexibleArray
--R 
--R
--RThere is one exposed function called flexibleArray :
--R   [1] List(D2) -> FlexibleArray(D2) from FlexibleArray(D2) if D2 has 
--R            TYPE
--R
--RThere is one unexposed function called flexibleArray :
--R   [1] List(D2) -> IndexedFlexibleArray(D2,D3) from 
--R            IndexedFlexibleArray(D2,D3)
--R             if D2 has TYPE and D3: INT
--R
--RExamples of flexibleArray from FlexibleArray
--R
--R
--RExamples of flexibleArray from IndexedFlexibleArray
--R
--RT1:=IndexedFlexibleArray(Integer,20) 
--RflexibleArray([i for i in 1..10])$T1
--R
--E 1046

--S 1047 of 3320
)d op float
--R 
--R
--RThere are 3 exposed functions called float :
--R   [1] (Integer,Integer,PositiveInteger) -> D from D if D has FPS
--R   [2] (Integer,Integer) -> D from D if D has FPS
--R   [3] D -> D1 from D
--R             if D has SEXCAT(D2,D3,D4,D1,D5) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D1 has 
--R            SETCAT
--R
--RExamples of float from FloatingPointSystem
--R
--R
--RExamples of float from SExpressionCategory
--R
--E 1047

--S 1048 of 3320
)d op float?
--R 
--R
--RThere is one exposed function called float? :
--R   [1] D -> Boolean from D
--R             if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R
--RExamples of float? from SExpressionCategory
--R
--E 1048

--S 1049 of 3320
)d op floor
--R 
--R
--RThere are 2 exposed functions called floor :
--R   [1] D -> D1 from D if D has QFCAT(D1) and D1 has INTDOM and D1 has 
--R            INS
--R   [2] D -> D from D if D has RNS
--R
--RExamples of floor from QuotientFieldCategory
--R
--R
--RExamples of floor from RealNumberSystem
--R
--E 1049

--S 1050 of 3320
)d op flush
--R 
--R
--RThere is one exposed function called flush :
--R   [1] D -> Void from D if D has FILECAT(D2,D3) and D2 has SETCAT and 
--R            D3 has SETCAT
--R
--RExamples of flush from FileCategory
--R
--E 1050

--S 1051 of 3320
)d op fmecg
--R 
--R
--RThere are 2 exposed functions called fmecg :
--R   [1] (MyUnivariatePolynomial(D3,D2),NonNegativeInteger,D2,
--R            MyUnivariatePolynomial(D3,D2)) -> MyUnivariatePolynomial(D3,D2)
--R             from MyUnivariatePolynomial(D3,D2) if D3: SYMBOL and D2
--R             has RING
--R   [2] (UnivariatePolynomial(D3,D2),NonNegativeInteger,D2,
--R            UnivariatePolynomial(D3,D2)) -> UnivariatePolynomial(D3,D2)
--R             from UnivariatePolynomial(D3,D2) if D3: SYMBOL and D2 has 
--R            RING
--R
--RThere are 4 unexposed functions called fmecg :
--R   [1] (NewSparseUnivariatePolynomial(D2),NonNegativeInteger,D2,
--R            NewSparseUnivariatePolynomial(D2)) -> 
--R            NewSparseUnivariatePolynomial(D2)
--R             from NewSparseUnivariatePolynomial(D2) if D2 has RING
--R   [2] (PolynomialRing(D2,D1),D1,D2,PolynomialRing(D2,D1)) -> 
--R            PolynomialRing(D2,D1)
--R             from PolynomialRing(D2,D1)
--R             if D1 has CABMON and D2 has INTDOM and D2 has RING and D1
--R             has OAMON
--R   [3] (SparseUnivariatePolynomial(D2),NonNegativeInteger,D2,
--R            SparseUnivariatePolynomial(D2)) -> SparseUnivariatePolynomial(D2)
--R             from SparseUnivariatePolynomial(D2) if D2 has RING
--R   [4] (SymmetricPolynomial(D2),Partition,D2,SymmetricPolynomial(D2))
--R             -> SymmetricPolynomial(D2)
--R             from SymmetricPolynomial(D2)
--R             if Partition has CABMON and D2 has INTDOM and D2 has RING
--R            
--R
--RExamples of fmecg from MyUnivariatePolynomial
--R
--R
--RExamples of fmecg from NewSparseUnivariatePolynomial
--R
--R
--RExamples of fmecg from PolynomialRing
--R
--R
--RExamples of fmecg from SparseUnivariatePolynomial
--R
--R
--RExamples of fmecg from SymmetricPolynomial
--R
--R
--RExamples of fmecg from UnivariatePolynomial
--R
--E 1051

--S 1052 of 3320
)d op forLoop
--R 
--R
--RThere are 2 exposed functions called forLoop :
--R   [1] (SegmentBinding(Polynomial(Integer)),Polynomial(Integer),
--R            FortranCode) -> FortranCode
--R             from FortranCode
--R   [2] (SegmentBinding(Polynomial(Integer)),FortranCode) -> FortranCode
--R             from FortranCode
--R
--RExamples of forLoop from FortranCode
--R
--E 1052

--S 1053 of 3320
)d op FormatArabic
--R 
--R
--RThere is one unexposed function called FormatArabic :
--R   [1] PositiveInteger -> String from NumberFormats
--R
--RExamples of FormatArabic from NumberFormats
--R
--E 1053

--S 1054 of 3320
)d op FormatRoman
--R 
--R
--RThere is one unexposed function called FormatRoman :
--R   [1] PositiveInteger -> String from NumberFormats
--R
--RExamples of FormatRoman from NumberFormats
--R
--E 1054

--S 1055 of 3320
)d op formula
--R 
--R
--RThere is one exposed function called formula :
--R   [1] ScriptFormulaFormat -> List(String) from ScriptFormulaFormat
--R
--RExamples of formula from ScriptFormulaFormat
--R
--E 1055

--S 1056 of 3320
)d op fortran
--R 
--R
--RThere is one exposed function called fortran :
--R   [1] (Symbol,FortranScalarType,D3) -> SimpleFortranProgram(D4,D3)
--R             from SimpleFortranProgram(D4,D3) if D4 has ORDSET and D3
--R             has FS(D4)
--R
--RExamples of fortran from SimpleFortranProgram
--R
--E 1056

--S 1057 of 3320
)d op fortranCarriageReturn
--R 
--R
--RThere is one exposed function called fortranCarriageReturn :
--R   [1]  -> Void from FortranTemplate
--R
--RExamples of fortranCarriageReturn from FortranTemplate
--R
--E 1057

--S 1058 of 3320
)d op fortranCharacter
--R 
--R
--RThere is one exposed function called fortranCharacter :
--R   [1]  -> FortranType from FortranType
--R
--RExamples of fortranCharacter from FortranType
--R
--E 1058

--S 1059 of 3320
)d op fortranCompilerName
--R 
--R
--RThere is one exposed function called fortranCompilerName :
--R   [1]  -> String from NAGLinkSupportPackage
--R
--RExamples of fortranCompilerName from NAGLinkSupportPackage
--R
--E 1059

--S 1060 of 3320
)d op fortranComplex
--R 
--R
--RThere is one exposed function called fortranComplex :
--R   [1]  -> FortranType from FortranType
--R
--RExamples of fortranComplex from FortranType
--R
--E 1060

--S 1061 of 3320
)d op fortranDouble
--R 
--R
--RThere is one exposed function called fortranDouble :
--R   [1]  -> FortranType from FortranType
--R
--RExamples of fortranDouble from FortranType
--R
--E 1061

--S 1062 of 3320
)d op fortranDoubleComplex
--R 
--R
--RThere is one exposed function called fortranDoubleComplex :
--R   [1]  -> FortranType from FortranType
--R
--RExamples of fortranDoubleComplex from FortranType
--R
--E 1062

--S 1063 of 3320
)d op fortranInteger
--R 
--R
--RThere is one exposed function called fortranInteger :
--R   [1]  -> FortranType from FortranType
--R
--RExamples of fortranInteger from FortranType
--R
--E 1063

--S 1064 of 3320
)d op fortranLinkerArgs
--R 
--R
--RThere is one exposed function called fortranLinkerArgs :
--R   [1]  -> String from NAGLinkSupportPackage
--R
--RExamples of fortranLinkerArgs from NAGLinkSupportPackage
--R
--E 1064

--S 1065 of 3320
)d op fortranLiteral
--R 
--R
--RThere is one exposed function called fortranLiteral :
--R   [1] String -> Void from FortranTemplate
--R
--RExamples of fortranLiteral from FortranTemplate
--R
--E 1065

--S 1066 of 3320
)d op fortranLiteralLine
--R 
--R
--RThere is one exposed function called fortranLiteralLine :
--R   [1] String -> Void from FortranTemplate
--R
--RExamples of fortranLiteralLine from FortranTemplate
--R
--E 1066

--S 1067 of 3320
)d op fortranLogical
--R 
--R
--RThere is one exposed function called fortranLogical :
--R   [1]  -> FortranType from FortranType
--R
--RExamples of fortranLogical from FortranType
--R
--E 1067

--S 1068 of 3320
)d op fortranReal
--R 
--R
--RThere is one exposed function called fortranReal :
--R   [1]  -> FortranType from FortranType
--R
--RExamples of fortranReal from FortranType
--R
--E 1068

--S 1069 of 3320
)d op fortranTypeOf
--R 
--R
--RThere is one exposed function called fortranTypeOf :
--R   [1] (Symbol,SymbolTable) -> FortranType from SymbolTable
--R
--RExamples of fortranTypeOf from SymbolTable
--R
--E 1069

--S 1070 of 3320
)d op foundPlaces
--R 
--R
--RThere is one exposed function called foundPlaces :
--R   [1]  -> List(D) from D
--R             if D2 has FIELD and D3 has LOCPOWC(D2) and D has PLACESC(
--R            D2,D3)
--R
--RExamples of foundPlaces from PlacesCategory
--R
--E 1070

--S 1071 of 3320
)d op foundZeroes
--R 
--R
--RThere is one exposed function called foundZeroes :
--R   [1]  -> List(D2) from RootsFindingPackage(D2) if D2 has FIELD
--R
--RExamples of foundZeroes from RootsFindingPackage
--R
--E 1071

--S 1072 of 3320
--R------------------------------)d op fp (what?)
--E 1072

--S 1073 of 3320
--R------------------------------)d op fprindINFO (what?)
--E 1073

--S 1074 of 3320
)d op fracPart
--R 
--R
--RThere is one exposed function called fracPart :
--R   [1] FullPartialFractionExpansion(D2,D3) -> List(Record(exponent: 
--R            NonNegativeInteger,center: D3,num: D3))
--R             from FullPartialFractionExpansion(D2,D3)
--R             if D2 has Join(Field,CharacteristicZero) and D3 has UPOLYC
--R            (D2)
--R
--RExamples of fracPart from FullPartialFractionExpansion
--R
--E 1074

--S 1075 of 3320
)d op fractionFreeGauss!
--R 
--R
--RThere is one exposed function called fractionFreeGauss! :
--R   [1] D1 -> D1 from MatrixLinearAlgebraFunctions(D2,D3,D4,D1)
--R             if D2 has INTDOM and D2 has COMRING and D3 has FLAGG(D2) 
--R            and D4 has FLAGG(D2) and D1 has MATCAT(D2,D3,D4)
--R
--RExamples of fractionFreeGauss! from MatrixLinearAlgebraFunctions
--R
--E 1075

--S 1076 of 3320
)d op fractionPart
--R 
--R
--RThere are 6 exposed functions called fractionPart :
--R   [1] BinaryExpansion -> Fraction(Integer) from BinaryExpansion
--R   [2] DecimalExpansion -> Fraction(Integer) from DecimalExpansion
--R   [3] HexadecimalExpansion -> Fraction(Integer) from 
--R            HexadecimalExpansion
--R   [4] D -> D from D if D has QFCAT(D1) and D1 has INTDOM and D1 has 
--R            EUCDOM
--R   [5] RadixExpansion(D2) -> Fraction(Integer) from RadixExpansion(D2)
--R             if D2: INT
--R   [6] D -> D from D if D has RNS
--R
--RExamples of fractionPart from BinaryExpansion
--R
--R
--RExamples of fractionPart from DecimalExpansion
--R
--R
--RExamples of fractionPart from HexadecimalExpansion
--R
--R
--RExamples of fractionPart from QuotientFieldCategory
--R
--R
--RExamples of fractionPart from RadixExpansion
--R
--R
--RExamples of fractionPart from RealNumberSystem
--R
--E 1076

--S 1077 of 3320
)d op fractRadix
--R 
--R
--RThere is one exposed function called fractRadix :
--R   [1] (List(Integer),List(Integer)) -> RadixExpansion(D2)
--R             from RadixExpansion(D2) if D2: INT
--R
--RExamples of fractRadix from RadixExpansion
--R
--E 1077

--S 1078 of 3320
)d op fractRagits
--R 
--R
--RThere is one exposed function called fractRagits :
--R   [1] RadixExpansion(D2) -> Stream(Integer) from RadixExpansion(D2)
--R             if D2: INT
--R
--RExamples of fractRagits from RadixExpansion
--R
--E 1078

--S 1079 of 3320
)d op freeOf?
--R 
--R
--RThere are 3 exposed functions called freeOf? :
--R   [1] (D,Symbol) -> Boolean from D if D has ES
--R   [2] (D,D) -> Boolean from D if D has ES
--R   [3] (StochasticDifferential(D3),BasicStochasticDifferential) -> 
--R            Boolean
--R             from StochasticDifferential(D3)
--R             if D3 has Join(OrderedSet,IntegralDomain)
--R
--RExamples of freeOf? from ExpressionSpace
--R
--R
--RExamples of freeOf? from StochasticDifferential
--R
--E 1079

--S 1080 of 3320
)d op fresnelC
--R 
--R
--RThere are 2 exposed functions called fresnelC :
--R   [1] Float -> Float from DoubleFloatSpecialFunctions
--R   [2] D -> D from D if D has LFCAT
--R
--RThere is one unexposed function called fresnelC :
--R   [1] D1 -> D1 from LiouvillianFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R
--RExamples of fresnelC from DoubleFloatSpecialFunctions
--R
--RfresnelC(1.5)
--R
--R
--RExamples of fresnelC from LiouvillianFunctionCategory
--R
--R
--RExamples of fresnelC from LiouvillianFunction
--R
--E 1080

--S 1081 of 3320
)d op fresnelS
--R 
--R
--RThere are 2 exposed functions called fresnelS :
--R   [1] Float -> Float from DoubleFloatSpecialFunctions
--R   [2] D -> D from D if D has LFCAT
--R
--RThere is one unexposed function called fresnelS :
--R   [1] D1 -> D1 from LiouvillianFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R
--RExamples of fresnelS from DoubleFloatSpecialFunctions
--R
--RfresnelS(1.5)
--R
--R
--RExamples of fresnelS from LiouvillianFunctionCategory
--R
--R
--RExamples of fresnelS from LiouvillianFunction
--R
--E 1081

--S 1082 of 3320
)d op frobenius
--R 
--R
--RThere is one unexposed function called frobenius :
--R   [1] ModMonic(D1,D2) -> ModMonic(D1,D2) from ModMonic(D1,D2)
--R             if D1 has FFIELDC and D1 has RING and D2 has UPOLYC(D1)
--R         
--R
--RExamples of frobenius from ModMonic
--R
--E 1082

--S 1083 of 3320
)d op Frobenius
--R 
--R
--RThere are 2 exposed functions called Frobenius :
--R   [1] (D,NonNegativeInteger) -> D from D
--R             if D has XF(D2) and D2 has FIELD and D2 has FINITE
--R   [2] D -> D from D if D has XF(D1) and D1 has FIELD and D1 has FINITE
--R            
--R
--RThere is one unexposed function called Frobenius :
--R   [1] D1 -> D1 from NormRetractPackage(D2,D3,D4,D1,D5)
--R             if D2 has FFIELDC and D3 has FAXF(D2) and D4 has UPOLYC(D3
--R            ) and D1 has UPOLYC(D4) and D5: PI
--R
--RExamples of Frobenius from NormRetractPackage
--R
--R
--RExamples of Frobenius from ExtensionField
--R
--E 1083

--S 1084 of 3320
)d op front
--R 
--R
--RThere are 3 exposed functions called front :
--R   [1] Dequeue(D1) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [2] D -> D1 from D if D has QUAGG(D1) and D1 has TYPE
--R   [3] Queue(D1) -> D1 from Queue(D1) if D1 has SETCAT
--R
--RExamples of front from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rfront a
--R
--R
--RExamples of front from QueueAggregate
--R
--R
--RExamples of front from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rfront a
--R
--E 1084

--S 1085 of 3320
)d op froot
--R 
--R
--RThere is one unexposed function called froot :
--R   [1] (D2,NonNegativeInteger) -> Record(exponent: NonNegativeInteger,
--R            coef: D2,radicand: D2)
--R             from PolynomialRoots(D4,D5,D6,D7,D2)
--R             if D6 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has INTDOM and D7 has POLYCAT(D6,D4,D5) and D2 has Field
--R            with
--R               numer : % -> D7
--R               denom : % -> D7
--R               coerce : D7 -> %
--R
--RExamples of froot from PolynomialRoots
--R
--E 1085

--S 1086 of 3320 done
)d op frst
--R 
--R
--RThere is one exposed function called frst :
--R   [1] D -> D1 from D if D has LZSTAGG(D1) and D1 has TYPE
--R
--RExamples of frst from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--Rfrst m
--R
--E 1086

--S 1087 of 3320
)d op fTable
--R 
--R
--RThere is one exposed function called fTable :
--R   [1] List(Record(key: Record(var: Symbol,fn: Expression(DoubleFloat),
--R            range: Segment(OrderedCompletion(DoubleFloat)),abserr: 
--R            DoubleFloat,relerr: DoubleFloat),entry: Record(endPointContinuity
--R            : Union(continuous: Continuous at the end points,lowerSingular: 
--R            There is a singularity at the lower end point,upperSingular: 
--R            There is a singularity at the upper end point,bothSingular: 
--R            There are singularities at both end points,notEvaluated: 
--R            End point continuity not yet evaluated),singularitiesStream: 
--R            Union(str: Stream(DoubleFloat),notEvaluated: 
--R            Internal singularities not yet evaluated),range: Union(finite: 
--R            The range is finite,lowerInfinite: 
--R            The bottom of range is infinite,upperInfinite: 
--R            The top of range is infinite,bothInfinite: 
--R            Both top and bottom points are infinite,notEvaluated: 
--R            Range not yet evaluated)))) -> IntegrationFunctionsTable
--R             from IntegrationFunctionsTable
--R
--RExamples of fTable from IntegrationFunctionsTable
--R
--E 1087

--S 1088 of 3320
)d op fullDesTree
--R 
--R
--RThere are 2 exposed functions called fullDesTree :
--R   [1]  -> Void from PackageForAlgebraicFunctionFieldOverFiniteField(D2
--R            ,D3,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [2]  -> Void from PackageForAlgebraicFunctionField(D2,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R
--RExamples of fullDesTree from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of fullDesTree from PackageForAlgebraicFunctionField
--R
--E 1088

--S 1089 of 3320
)d op fullDisplay
--R 
--R
--RThere are 3 exposed functions called fullDisplay :
--R   [1] (Database(D3),PositiveInteger,PositiveInteger) -> Void from 
--R            Database(D3)
--R             if D3 has OrderedSetwith
--R               ?.? : (%,Symbol) -> String
--R               display : % -> Void
--R               fullDisplay : % -> Void
--R   [2] Database(D2) -> Void from Database(D2)
--R             if D2 has OrderedSetwith
--R               ?.? : (%,Symbol) -> String
--R               display : % -> Void
--R               fullDisplay : % -> Void
--R   [3] IndexCard -> Void from IndexCard
--R
--RExamples of fullDisplay from Database
--R
--R
--RExamples of fullDisplay from IndexCard
--R
--E 1089

--S 1090 of 3320
)d op fullInfClsPt
--R 
--R
--RThere are 2 exposed functions called fullInfClsPt :
--R   [1]  -> Void from PackageForAlgebraicFunctionFieldOverFiniteField(D2
--R            ,D3,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [2]  -> Void from PackageForAlgebraicFunctionField(D2,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R
--RExamples of fullInfClsPt from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of fullInfClsPt from PackageForAlgebraicFunctionField
--R
--E 1090

--S 1091 of 3320
)d op fullOut
--R 
--R
--RThere are 4 exposed functions called fullOut :
--R   [1] DesingTree(D2) -> OutputForm from DesingTree(D2) if D2 has 
--R            SETCAT
--R   [2] InfClsPt(D2,D3,D4) -> OutputForm from InfClsPt(D2,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R   [3] InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField(D2,D3
--R            ,D4) -> OutputForm
--R             from 
--R            InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField(
--R            D2,D3,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [4] InfinitlyClosePoint(D4,D5,D6,D7,D8,D9,D10,D1,D2) -> OutputForm
--R             from InfinitlyClosePoint(D4,D5,D6,D7,D8,D9,D10,D1,D2)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D7 has DIRPCAT(#(
--R            D5),NNI) and D9 has LOCPOWC(D4) and D10 has PLACESC(D4,D9) 
--R            and D6 has POLYCAT(D4,D7,OVAR(D5)) and D8 has PRSPCAT(D4) 
--R            and D1 has DIVCAT(D10) and D2 has BLMETCT
--R
--RExamples of fullOut from DesingTree
--R
--R
--RExamples of fullOut from InfClsPt
--R
--R
--RExamples of fullOut from InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField
--R
--R
--RExamples of fullOut from InfinitlyClosePoint
--R
--E 1091

--S 1092 of 3320
)d op fullOutput
--R 
--R
--RThere are 12 exposed functions called fullOutput :
--R   [1]  -> Boolean from DesingTree(D2) if D2 has SETCAT
--R   [2] Boolean -> Boolean from DesingTree(D2) if D2 has SETCAT
--R   [3]  -> Boolean from InfClsPt(D2,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R   [4] Boolean -> Boolean from InfClsPt(D2,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R   [5]  -> Boolean
--R             from 
--R            InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField(
--R            D2,D3,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [6] Boolean -> Boolean
--R             from 
--R            InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField(
--R            D2,D3,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [7]  -> Boolean from InfinitlyClosePoint(D4,D5,D6,D7,D8,D9,D10,D1,D2
--R            )
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D7 has DIRPCAT(#(
--R            D5),NNI) and D9 has LOCPOWC(D4) and D10 has PLACESC(D4,D9) 
--R            and D6 has POLYCAT(D4,D7,OVAR(D5)) and D8 has PRSPCAT(D4) 
--R            and D1 has DIVCAT(D10) and D2 has BLMETCT
--R   [8] Boolean -> Boolean from InfinitlyClosePoint(D4,D5,D6,D7,D8,D9,
--R            D10,D1,D2)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D7 has DIRPCAT(#(
--R            D5),NNI) and D9 has LOCPOWC(D4) and D10 has PLACESC(D4,D9) 
--R            and D6 has POLYCAT(D4,D7,OVAR(D5)) and D8 has PRSPCAT(D4) 
--R            and D1 has DIVCAT(D10) and D2 has BLMETCT
--R   [9] PseudoAlgebraicClosureOfAlgExtOfRationalNumber(D2) -> OutputForm
--R             from PseudoAlgebraicClosureOfAlgExtOfRationalNumber(D2)
--R             if D2: PACRAT
--R   [10] PseudoAlgebraicClosureOfFiniteField(D2) -> OutputForm
--R             from PseudoAlgebraicClosureOfFiniteField(D2) if D2 has 
--R            FFIELDC
--R   [11] D -> OutputForm from D if D has PACPERC
--R   [12] PseudoAlgebraicClosureOfRationalNumber -> OutputForm
--R             from PseudoAlgebraicClosureOfRationalNumber
--R
--RExamples of fullOutput from DesingTree
--R
--R
--RExamples of fullOutput from InfClsPt
--R
--R
--RExamples of fullOutput from InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField
--R
--R
--RExamples of fullOutput from InfinitlyClosePoint
--R
--R
--RExamples of fullOutput from PseudoAlgebraicClosureOfAlgExtOfRationalNumber
--R
--R
--RExamples of fullOutput from PseudoAlgebraicClosureOfFiniteField
--R
--R
--RExamples of fullOutput from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--R
--RExamples of fullOutput from PseudoAlgebraicClosureOfRationalNumber
--R
--E 1092

--S 1093 of 3320
)d op fullParamInit
--R 
--R
--RThere is one exposed function called fullParamInit :
--R   [1] D6 -> Void from DesingTreePackage(D7,D8,D9,D10,D11,D12,D1,D2,D3,
--R            D6,D4)
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D9 has POLYCAT(D7
--R            ,D10,OVAR(D8)) and D10 has DIRPCAT(#(D8),NNI) and D11 has 
--R            PRSPCAT(D7) and D12 has LOCPOWC(D7) and D1 has PLACESC(D7,
--R            D12) and D2 has DIVCAT(D1) and D3 has INFCLCT(D7,D8,D9,D10,
--R            D11,D12,D1,D2,D4) and D4 has BLMETCT and D6 has DSTRCAT(D3)
--R            
--R
--RExamples of fullParamInit from DesingTreePackage
--R
--E 1093

--S 1094 of 3320
)d op fullPartialFraction
--R 
--R
--RThere is one exposed function called fullPartialFraction :
--R   [1] Fraction(D3) -> FullPartialFractionExpansion(D2,D3)
--R             from FullPartialFractionExpansion(D2,D3)
--R             if D3 has UPOLYC(D2) and D2 has Join(Field,
--R            CharacteristicZero)
--R
--RExamples of fullPartialFraction from FullPartialFractionExpansion
--R
--E 1094

--S 1095 of 3320
)d op function
--R 
--R
--RThere are 4 exposed functions called function :
--R   [1] (D2,Symbol) -> Symbol from MakeFunction(D2) if D2 has KONVERT(
--R            INFORM)
--R   [2] (D2,Symbol,Symbol) -> Symbol from MakeFunction(D2) if D2 has 
--R            KONVERT(INFORM)
--R   [3] (D2,Symbol,Symbol,Symbol) -> Symbol from MakeFunction(D2)
--R             if D2 has KONVERT(INFORM)
--R   [4] (D2,Symbol,List(Symbol)) -> Symbol from MakeFunction(D2)
--R             if D2 has KONVERT(INFORM)
--R
--RThere is one unexposed function called function :
--R   [1] (InputForm,List(Symbol),Symbol) -> InputForm from InputForm
--R
--RExamples of function from InputForm
--R
--R
--RExamples of function from MakeFunction
--R
--E 1095

--S 1096 of 3320
)d op functionIsContinuousAtEndPoints
--R 
--R
--RThere is one exposed function called functionIsContinuousAtEndPoints :
--R   [1] Record(var: Symbol,fn: Expression(DoubleFloat),range: Segment(
--R            OrderedCompletion(DoubleFloat)),abserr: DoubleFloat,relerr: 
--R            DoubleFloat) -> Union(continuous: Continuous at the end points,
--R            lowerSingular: There is a singularity at the lower end point,
--R            upperSingular: There is a singularity at the upper end point,
--R            bothSingular: There are singularities at both end points,
--R            notEvaluated: End point continuity not yet evaluated)
--R             from d01AgentsPackage
--R
--RExamples of functionIsContinuousAtEndPoints from d01AgentsPackage
--R
--E 1096

--S 1097 of 3320
)d op functionIsFracPolynomial?
--R 
--R
--RThere is one exposed function called functionIsFracPolynomial? :
--R   [1] Record(var: Symbol,fn: Expression(DoubleFloat),range: Segment(
--R            OrderedCompletion(DoubleFloat)),abserr: DoubleFloat,relerr: 
--R            DoubleFloat) -> Boolean
--R             from ExpertSystemContinuityPackage
--R
--RExamples of functionIsFracPolynomial? from ExpertSystemContinuityPackage
--R
--E 1097

--S 1098 of 3320
)d op functionIsOscillatory
--R 
--R
--RThere is one exposed function called functionIsOscillatory :
--R   [1] Record(var: Symbol,fn: Expression(DoubleFloat),range: Segment(
--R            OrderedCompletion(DoubleFloat)),abserr: DoubleFloat,relerr: 
--R            DoubleFloat) -> Float
--R             from d01AgentsPackage
--R
--RExamples of functionIsOscillatory from d01AgentsPackage
--R
--E 1098

--S 1099 of 3320
)d op functionName
--R 
--R
--RThere is one exposed function called functionName :
--R   [1] Symbol -> GuessOption from GuessOption
--R
--RThere is one unexposed function called functionName :
--R   [1] List(GuessOption) -> Symbol from GuessOptionFunctions0
--R
--RExamples of functionName from GuessOptionFunctions0
--R
--R
--RExamples of functionName from GuessOption
--R
--E 1099

--S 1100 of 3320
)d op functionNames
--R 
--R
--RThere is one exposed function called functionNames :
--R   [1] List(Symbol) -> GuessOption from GuessOption
--R
--RExamples of functionNames from GuessOption
--R
--E 1100

--S 1101 of 3320
)d op Gamma
--R 
--R
--RThere are 7 exposed functions called Gamma :
--R   [1] DoubleFloat -> DoubleFloat from DoubleFloat
--R   [2] DoubleFloat -> DoubleFloat from DoubleFloatSpecialFunctions
--R   [3] Complex(DoubleFloat) -> Complex(DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R   [4] Float -> Float from FloatSpecialFunctions
--R   [5] Complex(Float) -> Complex(Float) from FloatSpecialFunctions
--R   [6] D -> D from D if D has SPFCAT
--R   [7] (D,D) -> D from D if D has SPFCAT
--R
--RThere are 2 unexposed functions called Gamma :
--R   [1] D1 -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R   [2] (D1,D1) -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of Gamma from DoubleFloat
--R
--R
--RExamples of Gamma from DoubleFloatSpecialFunctions
--R
--R
--RExamples of Gamma from FloatSpecialFunctions
--R
--Ra:Complex(Float):=3.5*%i 
--RGamma(a)
--R
--RGamma(3.5)
--R
--R
--RExamples of Gamma from FunctionalSpecialFunction
--R
--R
--RExamples of Gamma from SpecialFunctionCategory
--R
--E 1101

--S 1102 of 3320
)d op gbasis
--R 
--R
--RThere is one unexposed function called gbasis :
--R   [1] (List(D6),Integer,Integer) -> List(D6)
--R             from GroebnerInternalPackage(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R
--RExamples of gbasis from GroebnerInternalPackage
--R
--E 1102

--S 1103 of 3320
)d op gcd
--R 
--R
--RThere are 8 exposed functions called gcd :
--R   [1] List(D) -> D from D if D has GCDDOM
--R   [2] (D,D) -> D from D if D has GCDDOM
--R   [3] (D1,D1,Integer) -> D1 from ModularDistinctDegreeFactorizer(D1)
--R             if D1 has UPOLYC(INT)
--R   [4] (NonNegativeInteger,NonNegativeInteger) -> NonNegativeInteger
--R             from NonNegativeInteger
--R   [5] (PositiveInteger,PositiveInteger) -> PositiveInteger from 
--R            PositiveInteger
--R   [6] (U32Vector,U32Vector,Integer) -> U32Vector
--R             from U32VectorPolynomialOperations
--R   [7] (PrimitiveArray(U32Vector),Integer,Integer,Integer) -> U32Vector
--R             from U32VectorPolynomialOperations
--R   [8] (D1,D) -> D1 from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has GCDDOM
--R
--RThere are 6 unexposed functions called gcd :
--R   [1] List(D1) -> D1 from HeuGcd(D1) if D1 has UPOLYC(INT)
--R   [2] (D1,D1) -> D1 from PolynomialGcdPackage(D2,D3,D4,D1)
--R             if D2 has OAMONS and D3 has ORDSET and D4 has EUCDOM and 
--R            D1 has POLYCAT(D4,D2,D3)
--R   [3] List(D1) -> D1 from PolynomialGcdPackage(D3,D4,D5,D1)
--R             if D1 has POLYCAT(D5,D3,D4) and D3 has OAMONS and D4 has 
--R            ORDSET and D5 has EUCDOM
--R   [4] (SparseUnivariatePolynomial(D5),SparseUnivariatePolynomial(D5))
--R             -> SparseUnivariatePolynomial(D5)
--R             from PolynomialGcdPackage(D2,D3,D4,D5)
--R             if D5 has POLYCAT(D4,D2,D3) and D2 has OAMONS and D3 has 
--R            ORDSET and D4 has EUCDOM
--R   [5] List(SparseUnivariatePolynomial(D6)) -> 
--R            SparseUnivariatePolynomial(D6)
--R             from PolynomialGcdPackage(D3,D4,D5,D6)
--R             if D3 has OAMONS and D4 has ORDSET and D5 has EUCDOM and 
--R            D6 has POLYCAT(D5,D3,D4)
--R   [6] (D1,D1) -> D1 from PseudoRemainderSequence(D2,D1)
--R             if D2 has GCDDOM and D2 has INTDOM and D1 has UPOLYC(D2)
--R         
--R
--RExamples of gcd from GcdDomain
--R
--R
--RExamples of gcd from HeuGcd
--R
--Rgcd([671*671*x^2-1,671*671*x^2+2*671*x+1]) 
--Rgcd([7*x^2+1,(7*x^2+1)^2])
--R
--R
--RExamples of gcd from ModularDistinctDegreeFactorizer
--R
--R
--RExamples of gcd from NonNegativeInteger
--R
--R
--RExamples of gcd from PolynomialGcdPackage
--R
--Rp1:=(x+1)*(x+6) 
--Rp2:=(x+1)*(x-6) 
--Rgcd(p1,p2)
--R
--R
--RExamples of gcd from PositiveInteger
--R
--R
--RExamples of gcd from U32VectorPolynomialOperations
--R
--R
--RExamples of gcd from PseudoRemainderSequence
--R
--R
--RExamples of gcd from RecursivePolynomialCategory
--R
--E 1103

--S 1104 of 3320
)d op gcdBasis
--R 
--R
--RThere is one exposed function called gcdBasis :
--R   [1] List(D3) -> List(D3)
--R             from CylindricalAlgebraicDecompositionUtilities(D2,D3)
--R             if D3 has UPOLYC(D2) and D2 has GCDDOM
--R
--RExamples of gcdBasis from CylindricalAlgebraicDecompositionUtilities
--R
--E 1104

--S 1105 of 3320
)d op gcdBasisAdd
--R 
--R
--RThere is one exposed function called gcdBasisAdd :
--R   [1] (D2,List(D2)) -> List(D2)
--R             from CylindricalAlgebraicDecompositionUtilities(D3,D2)
--R             if D2 has UPOLYC(D3) and D3 has GCDDOM
--R
--RExamples of gcdBasisAdd from CylindricalAlgebraicDecompositionUtilities
--R
--E 1105

--S 1106 of 3320
)d op gcdcofact
--R 
--R
--RThere is one unexposed function called gcdcofact :
--R   [1] List(D2) -> List(D2) from HeuGcd(D2) if D2 has UPOLYC(INT)
--R
--RExamples of gcdcofact from HeuGcd
--R
--E 1106

--S 1107 of 3320
)d op gcdcofactprim
--R 
--R
--RThere is one unexposed function called gcdcofactprim :
--R   [1] List(D2) -> List(D2) from HeuGcd(D2) if D2 has UPOLYC(INT)
--R
--RExamples of gcdcofactprim from HeuGcd
--R
--E 1107

--S 1108 of 3320
)d op gcdPolynomial
--R 
--R
--RThere are 2 exposed functions called gcdPolynomial :
--R   [1] (SparseUnivariatePolynomial(D),SparseUnivariatePolynomial(D))
--R             -> SparseUnivariatePolynomial(D)
--R             from D if D has GCDDOM
--R   [2] (SparseUnivariatePolynomial(D),SparseUnivariatePolynomial(D))
--R             -> SparseUnivariatePolynomial(D)
--R             from D if D has PFECAT
--R
--RThere is one unexposed function called gcdPolynomial :
--R   [1] (SparseUnivariatePolynomial(D5),SparseUnivariatePolynomial(D5))
--R             -> SparseUnivariatePolynomial(D5)
--R             from GeneralPolynomialGcdPackage(D2,D3,D4,D5)
--R             if D5 has POLYCAT(D4,D2,D3) and D2 has OAMONS and D3 has 
--R            ORDSET and D4 has PFECAT
--R
--RExamples of gcdPolynomial from GcdDomain
--R
--R
--RExamples of gcdPolynomial from GeneralPolynomialGcdPackage
--R
--R
--RExamples of gcdPolynomial from PolynomialFactorizationExplicit
--R
--E 1108

--S 1109 of 3320
)d op gcdprim
--R 
--R
--RThere is one unexposed function called gcdprim :
--R   [1] List(D1) -> D1 from HeuGcd(D1) if D1 has UPOLYC(INT)
--R
--RExamples of gcdprim from HeuGcd
--R
--E 1109

--S 1110 of 3320
)d op gcdPrimitive
--R 
--R
--RThere are 3 unexposed functions called gcdPrimitive :
--R   [1] (D1,D1) -> D1 from PolynomialGcdPackage(D2,D3,D4,D1)
--R             if D2 has OAMONS and D3 has ORDSET and D4 has EUCDOM and 
--R            D1 has POLYCAT(D4,D2,D3)
--R   [2] (SparseUnivariatePolynomial(D5),SparseUnivariatePolynomial(D5))
--R             -> SparseUnivariatePolynomial(D5)
--R             from PolynomialGcdPackage(D2,D3,D4,D5)
--R             if D5 has POLYCAT(D4,D2,D3) and D2 has OAMONS and D3 has 
--R            ORDSET and D4 has EUCDOM
--R   [3] List(D1) -> D1 from PolynomialGcdPackage(D3,D4,D5,D1)
--R             if D1 has POLYCAT(D5,D3,D4) and D3 has OAMONS and D4 has 
--R            ORDSET and D5 has EUCDOM
--R
--RExamples of gcdPrimitive from PolynomialGcdPackage
--R
--E 1110

--S 1111 of 3320
)d op gderiv
--R 
--R
--RThere is one unexposed function called gderiv :
--R   [1] ((Integer -> D3),Stream(D3)) -> Stream(D3)
--R             from StreamTaylorSeriesOperations(D3) if D3 has RING
--R
--RExamples of gderiv from StreamTaylorSeriesOperations
--R
--E 1111

--S 1112 of 3320
)d op GE
--R 
--R
--RThere is one exposed function called GE :
--R   [1] (Union(I: Expression(Integer),F: Expression(Float),CF: 
--R            Expression(Complex(Float)),switch: Switch),Union(I: Expression(
--R            Integer),F: Expression(Float),CF: Expression(Complex(Float)),
--R            switch: Switch)) -> Switch
--R             from Switch
--R
--RExamples of GE from Switch
--R
--E 1112

--S 1113 of 3320
)d op generalCoefficient
--R 
--R
--RThere is one exposed function called generalCoefficient :
--R   [1] (((NonNegativeInteger,NonNegativeInteger,D6) -> D1),Vector(D6),
--R            NonNegativeInteger,Vector(SparseUnivariatePolynomial(D1))) -> D1
--R             from FractionFreeFastGaussian(D1,D6)
--R             if D6 has AMR(D1,NNI) and D1 has Join(IntegralDomain,
--R            GcdDomain)
--R
--RExamples of generalCoefficient from FractionFreeFastGaussian
--R
--E 1113

--S 1114 of 3320
)d op generalInfiniteProduct
--R 
--R
--RThere are 3 exposed functions called generalInfiniteProduct :
--R   [1] (D1,Integer,Integer) -> D1 from 
--R            InfiniteProductCharacteristicZero(D3,D1)
--R             if D3 has Join(IntegralDomain,CharacteristicZero) and D1
--R             has UTSCAT(D3)
--R   [2] (D1,Integer,Integer) -> D1 from InfiniteProductFiniteField(D3,D4
--R            ,D5,D1)
--R             if D3 has Join(Field,Finite,ConvertibleTo(Integer)) and D4
--R             has UPOLYC(D3) and D5 has MONOGEN(D3,D4) and D1 has UTSCAT
--R            (D5)
--R   [3] (D1,Integer,Integer) -> D1 from InfiniteProductPrimeField(D3,D1)
--R             if D3 has Join(Field,Finite,ConvertibleTo(Integer)) and D1
--R             has UTSCAT(D3)
--R
--RThere is one unexposed function called generalInfiniteProduct :
--R   [1] (Stream(D3),Integer,Integer) -> Stream(D3) from 
--R            StreamInfiniteProduct(D3)
--R             if D3 has Join(IntegralDomain,CharacteristicZero)
--R
--RExamples of generalInfiniteProduct from InfiniteProductCharacteristicZero
--R
--R
--RExamples of generalInfiniteProduct from InfiniteProductFiniteField
--R
--R
--RExamples of generalInfiniteProduct from InfiniteProductPrimeField
--R
--R
--RExamples of generalInfiniteProduct from StreamInfiniteProduct
--R
--E 1114

--S 1115 of 3320
)d op generalInterpolation
--R 
--R
--RThere are 4 exposed functions called generalInterpolation :
--R   [1] (List(D6),((NonNegativeInteger,NonNegativeInteger,D7) -> D6),
--R            Vector(D8),List(NonNegativeInteger)) -> Matrix(
--R            SparseUnivariatePolynomial(D6))
--R             from FractionFreeFastGaussianFractions(D6,D7,D8)
--R             if D6 has Join(IntegralDomain,GcdDomain) and D7 has FAMR(
--R            D6,NNI) and D8 has FAMR(FRAC(D6),NNI)
--R   [2] (List(D6),((NonNegativeInteger,NonNegativeInteger,D7) -> D6),
--R            Vector(D8),NonNegativeInteger,NonNegativeInteger) -> Stream(
--R            Matrix(SparseUnivariatePolynomial(D6)))
--R             from FractionFreeFastGaussianFractions(D6,D7,D8)
--R             if D6 has Join(IntegralDomain,GcdDomain) and D7 has FAMR(
--R            D6,NNI) and D8 has FAMR(FRAC(D6),NNI)
--R   [3] (List(D6),((NonNegativeInteger,NonNegativeInteger,D7) -> D6),
--R            Vector(D7),List(NonNegativeInteger)) -> Matrix(
--R            SparseUnivariatePolynomial(D6))
--R             from FractionFreeFastGaussian(D6,D7)
--R             if D6 has Join(IntegralDomain,GcdDomain) and D7 has AMR(D6
--R            ,NNI)
--R   [4] (List(D6),((NonNegativeInteger,NonNegativeInteger,D7) -> D6),
--R            Vector(D7),NonNegativeInteger,NonNegativeInteger) -> Stream(
--R            Matrix(SparseUnivariatePolynomial(D6)))
--R             from FractionFreeFastGaussian(D6,D7)
--R             if D6 has Join(IntegralDomain,GcdDomain) and D7 has AMR(D6
--R            ,NNI)
--R
--RExamples of generalInterpolation from FractionFreeFastGaussianFractions
--R
--R
--RExamples of generalInterpolation from FractionFreeFastGaussian
--R
--E 1115

--S 1116 of 3320 done
)d op generalizedContinuumHypothesisAssumed
--R 
--R
--RThere is one exposed function called generalizedContinuumHypothesisAssumed :
--R   [1] Boolean -> Boolean from CardinalNumber
--R
--RExamples of generalizedContinuumHypothesisAssumed from CardinalNumber
--R
--RgeneralizedContinuumHypothesisAssumed true 
--Ra:=Aleph 0 
--Rc:=2**a 
--Rf:=2**c
--R
--E 1116

--S 1117 of 3320
)d op generalizedContinuumHypothesisAssumed?
--R 
--R
--RThere is one exposed function called generalizedContinuumHypothesisAssumed? :
--R   [1]  -> Boolean from CardinalNumber
--R
--RExamples of generalizedContinuumHypothesisAssumed? from CardinalNumber
--R
--RgeneralizedContinuumHypothesisAssumed?
--R
--E 1117

--S 1118 of 3320
)d op generalizedEigenvector
--R 
--R
--RThere are 2 exposed functions called generalizedEigenvector :
--R   [1] (Union(Fraction(Polynomial(D5)),SuchThat(Symbol,Polynomial(D5)))
--R            ,Matrix(Fraction(Polynomial(D5))),NonNegativeInteger,
--R            NonNegativeInteger) -> List(Matrix(Fraction(Polynomial(D5))))
--R             from EigenPackage(D5) if D5 has GCDDOM
--R   [2] (Record(eigval: Union(Fraction(Polynomial(D4)),SuchThat(Symbol,
--R            Polynomial(D4))),eigmult: NonNegativeInteger,eigvec: List(Matrix(
--R            Fraction(Polynomial(D4))))),Matrix(Fraction(Polynomial(D4)))) -> 
--R            List(Matrix(Fraction(Polynomial(D4))))
--R             from EigenPackage(D4) if D4 has GCDDOM
--R
--RExamples of generalizedEigenvector from EigenPackage
--R
--E 1118

--S 1119 of 3320
)d op generalizedEigenvectors
--R 
--R
--RThere is one exposed function called generalizedEigenvectors :
--R   [1] Matrix(Fraction(Polynomial(D3))) -> List(Record(eigval: Union(
--R            Fraction(Polynomial(D3)),SuchThat(Symbol,Polynomial(D3))),
--R            geneigvec: List(Matrix(Fraction(Polynomial(D3))))))
--R             from EigenPackage(D3) if D3 has GCDDOM
--R
--RExamples of generalizedEigenvectors from EigenPackage
--R
--E 1119

--S 1120 of 3320
)d op generalizedInverse
--R 
--R
--RThere is one unexposed function called generalizedInverse :
--R   [1] D1 -> D1 from InnerMatrixLinearAlgebraFunctions(D2,D3,D4,D1)
--R             if D2 has FIELD and D3 has FLAGG(D2) and D4 has FLAGG(D2) 
--R            and D1 has MATCAT(D2,D3,D4)
--R
--RExamples of generalizedInverse from InnerMatrixLinearAlgebraFunctions
--R
--E 1120

--S 1121 of 3320
)d op generalLambert
--R 
--R
--RThere are 2 exposed functions called generalLambert :
--R   [1] (UnivariateFormalPowerSeries(D2),Integer,Integer) -> 
--R            UnivariateFormalPowerSeries(D2)
--R             from UnivariateFormalPowerSeries(D2) if D2 has RING
--R   [2] (UnivariateTaylorSeriesCZero(D2,D3),Integer,Integer) -> 
--R            UnivariateTaylorSeriesCZero(D2,D3)
--R             from UnivariateTaylorSeriesCZero(D2,D3) if D2 has RING and
--R            D3: SYMBOL
--R
--RThere are 2 unexposed functions called generalLambert :
--R   [1] (Stream(D3),Integer,Integer) -> Stream(D3)
--R             from StreamTaylorSeriesOperations(D3) if D3 has RING
--R   [2] (UnivariateTaylorSeries(D2,D3,D4),Integer,Integer) -> 
--R            UnivariateTaylorSeries(D2,D3,D4)
--R             from UnivariateTaylorSeries(D2,D3,D4)
--R             if D2 has RING and D3: SYMBOL and D4: D2
--R
--RExamples of generalLambert from StreamTaylorSeriesOperations
--R
--R
--RExamples of generalLambert from UnivariateFormalPowerSeries
--R
--R
--RExamples of generalLambert from UnivariateTaylorSeries
--R
--R
--RExamples of generalLambert from UnivariateTaylorSeriesCZero
--R
--E 1121

--S 1122 of 3320
)d op generalPosition
--R 
--R
--RThere is one exposed function called generalPosition :
--R   [1] (PolynomialIdeals(D3,D4,D5,D6),List(D5)) -> Record(mval: Matrix(
--R            D3),invmval: Matrix(D3),genIdeal: PolynomialIdeals(D3,D4,D5,D6))
--R             from PolynomialIdeals(D3,D4,D5,D6)
--R             if D5 has ORDSET and D3 has FIELD and D4 has OAMONS and D6
--R             has POLYCAT(D3,D4,D5)
--R
--RExamples of generalPosition from PolynomialIdeals
--R
--E 1122

--S 1123 of 3320
)d op generalSqFr
--R 
--R
--RThere is one unexposed function called generalSqFr :
--R   [1] SparseUnivariatePolynomial(SparseUnivariatePolynomial(D3)) -> 
--R            Factored(SparseUnivariatePolynomial(SparseUnivariatePolynomial(D3
--R            )))
--R             from TwoFactorize(D3) if D3 has FFIELDC
--R
--RExamples of generalSqFr from TwoFactorize
--R
--E 1123

--S 1124 of 3320
)d op generalTwoFactor
--R 
--R
--RThere is one unexposed function called generalTwoFactor :
--R   [1] SparseUnivariatePolynomial(SparseUnivariatePolynomial(D3)) -> 
--R            Factored(SparseUnivariatePolynomial(SparseUnivariatePolynomial(D3
--R            )))
--R             from TwoFactorize(D3) if D3 has FFIELDC
--R
--RExamples of generalTwoFactor from TwoFactorize
--R
--E 1124

--S 1125 of 3320
)d op generate
--R 
--R
--RThere are 4 exposed functions called generate :
--R   [1] (NonNegativeInteger,NonNegativeInteger) -> Vector(List(Integer))
--R             from HallBasis
--R   [2] ((D2 -> D2),D2) -> InfiniteTuple(D2) from InfiniteTuple(D2) if 
--R            D2 has TYPE
--R   [3] ((D2 -> D2),D2) -> Stream(D2) from Stream(D2) if D2 has TYPE
--R   [4] (() -> D2) -> Stream(D2) from Stream(D2) if D2 has TYPE
--R
--RExamples of generate from HallBasis
--R
--R
--RExamples of generate from InfiniteTuple
--R
--R
--RExamples of generate from Stream
--R
--Rf(x:Integer):Integer == x+10 
--Rgenerate(f,10)
--R
--Rf():Integer == 1 
--Rgenerate(f)
--R
--E 1125

--S 1126 of 3320
)d op generateIrredPoly
--R 
--R
--RThere is one unexposed function called generateIrredPoly :
--R   [1] PositiveInteger -> SparseUnivariatePolynomial(D3)
--R             from IrredPolyOverFiniteField(D3) if D3 has FFIELDC
--R
--RExamples of generateIrredPoly from IrredPolyOverFiniteField
--R
--E 1126

--S 1127 of 3320
)d op generator
--R 
--R
--RThere are 4 exposed functions called generator :
--R   [1]  -> D from D if D has FAXF(D1) and D1 has FINITE and D1 has 
--R            FIELD
--R   [2] D -> Union(D1,"failed") from D
--R             if D has FDIVCAT(D2,D3,D4,D1) and D2 has FIELD and D3 has 
--R            UPOLYC(D2) and D4 has UPOLYC(FRAC(D3)) and D1 has FFCAT(D2,
--R            D3,D4)
--R   [3] NonNegativeInteger -> FreeNilpotentLie(D2,D3,D4)
--R             from FreeNilpotentLie(D2,D3,D4)
--R             if D2: NNI and D3: NNI and D4 has COMRING
--R   [4]  -> D from D if D1 has COMRING and D has MONOGEN(D1,D2) and D2
--R             has UPOLYC(D1)
--R
--RThere are 2 unexposed functions called generator :
--R   [1] NonNegativeInteger -> AntiSymm(D2,D3) from AntiSymm(D2,D3)
--R             if D2 has RING and D3: LIST(SYMBOL)
--R   [2] NonNegativeInteger -> DeRhamComplex(D2,D3) from DeRhamComplex(D2
--R            ,D3)
--R             if D2 has Join(Ring,OrderedSet) and D3: LIST(SYMBOL)
--R
--RExamples of generator from AntiSymm
--R
--RAS:=AntiSymm(Integer,[x,y,z]) 
--R[dx,dy,dz]:=[generator(i)$AS for i in 1..3]
--R
--R
--RExamples of generator from DeRhamComplex
--R
--Rder := DeRhamComplex(Integer,[x,y,z]) 
--R[dx,dy,dz] := [generator(i)$der for i in 1..3]
--R
--R
--RExamples of generator from FiniteAlgebraicExtensionField
--R
--R
--RExamples of generator from FiniteDivisorCategory
--R
--R
--RExamples of generator from FreeNilpotentLie
--R
--R
--RExamples of generator from MonogenicAlgebra
--R
--E 1127

--S 1128 of 3320
)d op generators
--R 
--R
--RThere are 2 exposed functions called generators :
--R   [1] PolynomialIdeals(D2,D3,D4,D5) -> List(D5)
--R             from PolynomialIdeals(D2,D3,D4,D5)
--R             if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D5
--R             has POLYCAT(D2,D3,D4)
--R   [2] PermutationGroup(D2) -> List(Permutation(D2)) from 
--R            PermutationGroup(D2)
--R             if D2 has SETCAT
--R
--RExamples of generators from PolynomialIdeals
--R
--R
--RExamples of generators from PermutationGroup
--R
--E 1128

--S 1129 of 3320
--R------------------------------)d op generic (System Error)
--E 1129

--S 1130 of 3320
)d op generic?
--R 
--R
--RThere is one unexposed function called generic? :
--R   [1] Pattern(D2) -> Boolean from Pattern(D2) if D2 has SETCAT
--R
--RExamples of generic? from Pattern
--R
--E 1130

--S 1131 of 3320
--R---------------------------)d op genericLeftDiscriminant (System Error)
--E 1131

--S 1132 of 3320
--R---------------------------)d op genericLeftMinimalPolynomial (System Error)
--E 1132

--S 1133 of 3320
--R---------------------------)d op genericLeftNorm (System Error)
--E 1133

--S 1134 of 3320
--R---------------------------)d op genericLeftTrace (System Error)
--E 1134

--S 1135 of 3320
--R---------------------------)d op genericLeftTraceForm (System Error)
--E 1135

--S 1136 of 3320
)d op genericPosition
--R 
--R
--RThere is one unexposed function called genericPosition :
--R   [1] (List(DistributedMultivariatePolynomial(D4,D5)),List(
--R            OrderedVariableList(D4))) -> Record(dpolys: List(
--R            DistributedMultivariatePolynomial(D4,D5)),coords: List(Integer))
--R             from GroebnerSolve(D4,D5,D6)
--R             if D4: LIST(SYMBOL) and D5 has GCDDOM and D6 has GCDDOM
--R         
--R
--RExamples of genericPosition from GroebnerSolve
--R
--E 1136

--S 1137 of 3320
--R---------------------------)d op genericRightDiscriminant (System Error)
--E 1137

--S 1138 of 3320
--R------------------------)d op genericRightMinimalPolynomial (System Error)
--E 1138

--S 1139 of 3320
--R------------------------)d op genericRightNorm (System Error)
--E 1139

--S 1140 of 3320
--R------------------------)d op genericRightTrace (System Error)
--E 1140

--S 1141 of 3320
--R------------------------)d op genericRightTraceForm (System Error)
--E 1141

--S 1142 of 3320
)d op genus
--R 
--R
--RThere are 5 exposed functions called genus :
--R   [1] D6 -> NonNegativeInteger
--R             from DesingTreePackage(D7,D8,D6,D9,D10,D11,D12,D1,D2,D3,D4
--R            )
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D6 has POLYCAT(D7
--R            ,D9,OVAR(D8)) and D9 has DIRPCAT(#(D8),NNI) and D10 has 
--R            PRSPCAT(D7) and D11 has LOCPOWC(D7) and D12 has PLACESC(D7,
--R            D11) and D1 has DIVCAT(D12) and D2 has INFCLCT(D7,D8,D6,D9,
--R            D10,D11,D12,D1,D4) and D4 has BLMETCT and D3 has DSTRCAT(D2
--R            )
--R   [2]  -> NonNegativeInteger from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R   [3]  -> NonNegativeInteger
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R             if D6 has FIELD and D7: LIST(SYMBOL) and D8 has POLYCAT(D6
--R            ,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI) and D10 has 
--R            PRSPCAT(D6) and D11 has LOCPOWC(D6) and D12 has PLACESC(D6,
--R            D11) and D1 has DIVCAT(D12) and D2 has INFCLCT(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D4) and D4 has BLMETCT and D3 has DSTRCAT(D2
--R            )
--R   [4]  -> NonNegativeInteger
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [5]  -> NonNegativeInteger from PackageForAlgebraicFunctionField(D2,
--R            D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R
--RThere is one unexposed function called genus :
--R   [1]  -> NonNegativeInteger from FunctionFieldCategory&(D2,D3,D4,D5)
--R             if D3 has UFD and D4 has UPOLYC(D3) and D5 has UPOLYC(FRAC
--R            (D4)) and D2 has FFCAT(D3,D4,D5)
--R
--RExamples of genus from DesingTreePackage
--R
--R
--RExamples of genus from FunctionFieldCategory&
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--Rgenus()$R
--R
--R
--RExamples of genus from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--Rgenus()$R
--R
--R
--RExamples of genus from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of genus from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of genus from PackageForAlgebraicFunctionField
--R
--E 1142

--S 1143 of 3320
)d op genusNeg
--R 
--R
--RThere are 4 exposed functions called genusNeg :
--R   [1] D6 -> Integer from DesingTreePackage(D7,D8,D6,D9,D10,D11,D12,D1,
--R            D2,D3,D4)
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D6 has POLYCAT(D7
--R            ,D9,OVAR(D8)) and D9 has DIRPCAT(#(D8),NNI) and D10 has 
--R            PRSPCAT(D7) and D11 has LOCPOWC(D7) and D12 has PLACESC(D7,
--R            D11) and D1 has DIVCAT(D12) and D2 has INFCLCT(D7,D8,D6,D9,
--R            D10,D11,D12,D1,D4) and D4 has BLMETCT and D3 has DSTRCAT(D2
--R            )
--R   [2]  -> Integer
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R             if D6 has FIELD and D7: LIST(SYMBOL) and D8 has POLYCAT(D6
--R            ,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI) and D10 has 
--R            PRSPCAT(D6) and D11 has LOCPOWC(D6) and D12 has PLACESC(D6,
--R            D11) and D1 has DIVCAT(D12) and D2 has INFCLCT(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D4) and D4 has BLMETCT and D3 has DSTRCAT(D2
--R            )
--R   [3]  -> Integer
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [4]  -> Integer from PackageForAlgebraicFunctionField(D2,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R
--RExamples of genusNeg from DesingTreePackage
--R
--R
--RExamples of genusNeg from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of genusNeg from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of genusNeg from PackageForAlgebraicFunctionField
--R
--E 1143

--S 1144 of 3320
)d op genusTree
--R 
--R
--RThere is one exposed function called genusTree :
--R   [1] (NonNegativeInteger,List(D4)) -> NonNegativeInteger
--R             from DesingTreePackage(D8,D9,D10,D11,D12,D13,D1,D2,D3,D4,
--R            D5)
--R             if D4 has DSTRCAT(D3) and D3 has INFCLCT(D8,D9,D10,D11,D12
--R            ,D13,D1,D2,D5) and D5 has BLMETCT and D8 has FIELD and D9: 
--R            LIST(SYMBOL) and D10 has POLYCAT(D8,D11,OVAR(D9)) and D11
--R             has DIRPCAT(#(D9),NNI) and D12 has PRSPCAT(D8) and D13
--R             has LOCPOWC(D8) and D1 has PLACESC(D8,D13) and D2 has 
--R            DIVCAT(D1)
--R
--RExamples of genusTree from DesingTreePackage
--R
--E 1144

--S 1145 of 3320
)d op genusTreeNeg
--R 
--R
--RThere is one exposed function called genusTreeNeg :
--R   [1] (NonNegativeInteger,List(D5)) -> Integer
--R             from DesingTreePackage(D10,D11,D12,D13,D14,D1,D2,D3,D4,D5,
--R            D6)
--R             if D5 has DSTRCAT(D4) and D4 has INFCLCT(D10,D11,D12,D13,
--R            D14,D1,D2,D3,D6) and D6 has BLMETCT and D10 has FIELD and 
--R            D11: LIST(SYMBOL) and D12 has POLYCAT(D10,D13,OVAR(D11)) 
--R            and D13 has DIRPCAT(#(D11),NNI) and D14 has PRSPCAT(D10) 
--R            and D1 has LOCPOWC(D10) and D2 has PLACESC(D10,D1) and D3
--R             has DIVCAT(D2)
--R
--RExamples of genusTreeNeg from DesingTreePackage
--R
--E 1145

--S 1146 of 3320
)d op geometric
--R 
--R
--RThere is one unexposed function called geometric :
--R   [1] RationalNumber -> (() -> Integer) from 
--R            RandomIntegerDistributions
--R
--RExamples of geometric from RandomIntegerDistributions
--R
--E 1146

--S 1147 of 3320 done
)d op getAncestors
--R 
--R
--RThere is one exposed function called getAncestors :
--R   [1] Symbol -> Set(Symbol) from ApplicationProgramInterface
--R
--RExamples of getAncestors from ApplicationProgramInterface
--R
--RgetAncestors 'IndexedAggregate
--R
--E 1147

--S 1148 of 3320
)d op getBadValues
--R 
--R
--RThere is one unexposed function called getBadValues :
--R   [1] Pattern(D2) -> List(Any) from Pattern(D2) if D2 has SETCAT
--R
--RExamples of getBadValues from Pattern
--R
--E 1148

--S 1149 of 3320
)d op getButtonValue
--R 
--R
--RThere is one exposed function called getButtonValue :
--R   [1] (String,String) -> Float from AttributeButtons
--R
--RExamples of getButtonValue from AttributeButtons
--R
--E 1149

--S 1150 of 3320
)d op getCode
--R 
--R
--RThere is one exposed function called getCode :
--R   [1] FortranCode -> SExpression from FortranCode
--R
--RExamples of getCode from FortranCode
--R
--E 1150

--S 1151 of 3320
)d op getCurve
--R 
--R
--RThere is one unexposed function called getCurve :
--R   [1] TubePlot(D1) -> D1 from TubePlot(D1) if D1 has PSCURVE
--R
--RExamples of getCurve from TubePlot
--R
--E 1151

--S 1152 of 3320
)d op getDatabase
--R 
--R
--RThere are 2 exposed functions called getDatabase :
--R   [1] (String,String) -> String from AxiomServer
--R   [2] String -> Database(IndexCard) from OperationsQuery
--R
--RExamples of getDatabase from AxiomServer
--R
--R
--RExamples of getDatabase from OperationsQuery
--R
--E 1152

--S 1153 of 3320 done
)d op getDomains
--R 
--R
--RThere is one exposed function called getDomains :
--R   [1] Symbol -> Set(Symbol) from ApplicationProgramInterface
--R
--RExamples of getDomains from ApplicationProgramInterface
--R
--RgetDomains 'IndexedAggregate
--R
--E 1153

--S 1154 of 3320
)d op getEq
--R 
--R
--RThere is one exposed function called getEq :
--R   [1] D1 -> D1 from RecurrenceOperator(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain,ConvertibleTo(
--R            InputForm)) and D1 has Join(FunctionSpace(D2),AbelianMonoid
--R            ,RetractableTo(Integer),RetractableTo(Symbol),
--R            PartialDifferentialRing(Symbol),CombinatorialOpsCategory)
--R         
--R
--RExamples of getEq from RecurrenceOperator
--R
--E 1154

--S 1155 of 3320
)d op getExplanations
--R 
--R
--RThere is one exposed function called getExplanations :
--R   [1] (RoutinesTable,String) -> List(String) from RoutinesTable
--R
--RExamples of getExplanations from RoutinesTable
--R
--E 1155

--S 1156 of 3320
)d op getGoodPrime
--R 
--R
--RThere is one unexposed function called getGoodPrime :
--R   [1] Integer -> PositiveInteger from PointsOfFiniteOrderTools(D3,D4)
--R             if D3 has UPOLYC(FRAC(INT)) and D4 has UPOLYC(FRAC(D3))
--R         
--R
--RExamples of getGoodPrime from PointsOfFiniteOrderTools
--R
--E 1156

--S 1157 of 3320
)d op getGraph
--R 
--R
--RThere is one unexposed function called getGraph :
--R   [1] (TwoDimensionalViewport,PositiveInteger) -> GraphImage
--R             from TwoDimensionalViewport
--R
--RExamples of getGraph from TwoDimensionalViewport
--R
--E 1157

--S 1158 of 3320
)d op gethi
--R 
--R
--RThere are 3 exposed functions called gethi :
--R   [1] Segment(OrderedCompletion(DoubleFloat)) -> DoubleFloat
--R             from d01AgentsPackage
--R   [2] Segment(OrderedCompletion(DoubleFloat)) -> DoubleFloat
--R             from ExpertSystemContinuityPackage
--R   [3] Segment(OrderedCompletion(DoubleFloat)) -> DoubleFloat
--R             from ExpertSystemToolsPackage
--R
--RExamples of gethi from d01AgentsPackage
--R
--R
--RExamples of gethi from ExpertSystemContinuityPackage
--R
--R
--RExamples of gethi from ExpertSystemToolsPackage
--R
--E 1158

--S 1159 of 3320
)d op getlo
--R 
--R
--RThere are 3 exposed functions called getlo :
--R   [1] Segment(OrderedCompletion(DoubleFloat)) -> DoubleFloat
--R             from d01AgentsPackage
--R   [2] Segment(OrderedCompletion(DoubleFloat)) -> DoubleFloat
--R             from ExpertSystemContinuityPackage
--R   [3] Segment(OrderedCompletion(DoubleFloat)) -> DoubleFloat
--R             from ExpertSystemToolsPackage
--R
--RExamples of getlo from d01AgentsPackage
--R
--R
--RExamples of getlo from ExpertSystemContinuityPackage
--R
--R
--RExamples of getlo from ExpertSystemToolsPackage
--R
--E 1159

--S 1160 of 3320
)d op getMatch
--R 
--R
--RThere is one unexposed function called getMatch :
--R   [1] (Pattern(D3),PatternMatchResult(D3,D1)) -> Union(D1,"failed")
--R             from PatternMatchResult(D3,D1) if D3 has SETCAT and D1
--R             has SETCAT
--R
--RExamples of getMatch from PatternMatchResult
--R
--E 1160

--S 1161 of 3320
)d op getMeasure
--R 
--R
--RThere is one exposed function called getMeasure :
--R   [1] (RoutinesTable,Symbol) -> Float from RoutinesTable
--R
--RExamples of getMeasure from RoutinesTable
--R
--E 1161

--S 1162 of 3320
)d op getMultiplicationMatrix
--R 
--R
--RThere is one exposed function called getMultiplicationMatrix :
--R   [1]  -> Matrix(PrimeField(D2)) from FiniteFieldNormalBasis(D2,D3)
--R             if D2: PI and D3: PI
--R
--RThere are 2 unexposed functions called getMultiplicationMatrix :
--R   [1]  -> Matrix(D2) from FiniteFieldNormalBasisExtensionByPolynomial(
--R            D2,D3)
--R             if D2 has FFIELDC and D3: Union(SUP(D2),VECTOR(LIST(
--R            Record(value: D2,index: SingleInteger))))
--R   [2]  -> Matrix(D2) from FiniteFieldNormalBasisExtension(D2,D3)
--R             if D2 has FFIELDC and D3: PI
--R
--RExamples of getMultiplicationMatrix from FiniteFieldNormalBasis
--R
--R
--RExamples of getMultiplicationMatrix from FiniteFieldNormalBasisExtensionByPolynomial
--R
--R
--RExamples of getMultiplicationMatrix from FiniteFieldNormalBasisExtension
--R
--E 1162

--S 1163 of 3320
)d op getMultiplicationTable
--R 
--R
--RThere is one exposed function called getMultiplicationTable :
--R   [1]  -> Vector(List(Record(value: PrimeField(D2),index: 
--R            SingleInteger)))
--R             from FiniteFieldNormalBasis(D2,D3) if D2: PI and D3: PI
--R         
--R
--RThere are 2 unexposed functions called getMultiplicationTable :
--R   [1]  -> Vector(List(Record(value: D2,index: SingleInteger)))
--R             from FiniteFieldNormalBasisExtensionByPolynomial(D2,D3)
--R             if D2 has FFIELDC and D3: Union(SUP(D2),VECTOR(LIST(
--R            Record(value: D2,index: SingleInteger))))
--R   [2]  -> Vector(List(Record(value: D2,index: SingleInteger)))
--R             from FiniteFieldNormalBasisExtension(D2,D3) if D2 has 
--R            FFIELDC and D3: PI
--R
--RExamples of getMultiplicationTable from FiniteFieldNormalBasis
--R
--R
--RExamples of getMultiplicationTable from FiniteFieldNormalBasisExtensionByPolynomial
--R
--R
--RExamples of getMultiplicationTable from FiniteFieldNormalBasisExtension
--R
--E 1163

--S 1164 of 3320
)d op getOp
--R 
--R
--RThere is one exposed function called getOp :
--R   [1] D2 -> BasicOperator from RecurrenceOperator(D3,D2)
--R             if D3 has Join(OrderedSet,IntegralDomain,ConvertibleTo(
--R            InputForm)) and D2 has Join(FunctionSpace(D3),AbelianMonoid
--R            ,RetractableTo(Integer),RetractableTo(Symbol),
--R            PartialDifferentialRing(Symbol),CombinatorialOpsCategory)
--R         
--R
--RExamples of getOp from RecurrenceOperator
--R
--E 1164

--S 1165 of 3320
)d op getOrder
--R 
--R
--RThere is one unexposed function called getOrder :
--R   [1]  -> Record(low: List(D2),high: List(D2))
--R             from UserDefinedPartialOrdering(D2) if D2 has SETCAT
--R
--RExamples of getOrder from UserDefinedPartialOrdering
--R
--E 1165

--S 1166 of 3320
)d op getPickedPoints
--R 
--R
--RThere is one unexposed function called getPickedPoints :
--R   [1] TwoDimensionalViewport -> List(Point(DoubleFloat))
--R             from TwoDimensionalViewport
--R
--RExamples of getPickedPoints from TwoDimensionalViewport
--R
--E 1166

--S 1167 of 3320
)d op getRef
--R 
--R
--RThere is one unexposed function called getRef :
--R   [1] InnerSparseUnivariatePowerSeries(D2) -> Reference(
--R            OrderedCompletion(Integer))
--R             from InnerSparseUnivariatePowerSeries(D2) if D2 has RING
--R         
--R
--RExamples of getRef from InnerSparseUnivariatePowerSeries
--R
--E 1167

--S 1168 of 3320
)d op getShiftRec
--R 
--R
--RThere is one exposed function called getShiftRec :
--R   [1] (BasicOperator,Kernel(D6),Symbol) -> Union(Integer,"failed")
--R             from RecurrenceOperator(D5,D6)
--R             if D6 has Join(FunctionSpace(D5),AbelianMonoid,
--R            RetractableTo(Integer),RetractableTo(Symbol),
--R            PartialDifferentialRing(Symbol),CombinatorialOpsCategory) 
--R            and D5 has RING and D5 has Join(OrderedSet,IntegralDomain,
--R            ConvertibleTo(InputForm))
--R
--RExamples of getShiftRec from RecurrenceOperator
--R
--E 1168

--S 1169 of 3320 done
)d op getSmgl
--R 
--R
--RThere is one exposed function called getSmgl :
--R   [1] BasicStochasticDifferential -> Union(Symbol,"failed")
--R             from BasicStochasticDifferential
--R
--RExamples of getSmgl from BasicStochasticDifferential
--R
--Rintroduce!(t,dt) -- dt is a new stochastic differential 
--RgetSmgl(dt::BSD)
--R
--E 1169

--S 1170 of 3320
)d op getStream
--R 
--R
--RThere is one unexposed function called getStream :
--R   [1] InnerSparseUnivariatePowerSeries(D2) -> Stream(Record(k: Integer
--R            ,c: D2))
--R             from InnerSparseUnivariatePowerSeries(D2) if D2 has RING
--R         
--R
--RExamples of getStream from InnerSparseUnivariatePowerSeries
--R
--E 1170

--S 1171 of 3320
)d op getVariableOrder
--R 
--R
--RThere is one exposed function called getVariableOrder :
--R   [1]  -> Record(high: List(Symbol),low: List(Symbol))
--R             from UserDefinedVariableOrdering
--R
--RExamples of getVariableOrder from UserDefinedVariableOrdering
--R
--E 1171

--S 1172 of 3320
)d op getZechTable
--R 
--R
--RThere is one exposed function called getZechTable :
--R   [1]  -> PrimitiveArray(SingleInteger) from FiniteFieldCyclicGroup(D2
--R            ,D3)
--R             if D2: PI and D3: PI
--R
--RThere are 2 unexposed functions called getZechTable :
--R   [1]  -> PrimitiveArray(SingleInteger)
--R             from FiniteFieldCyclicGroupExtensionByPolynomial(D2,D3)
--R             if D2 has FFIELDC and D3: SUP(D2)
--R   [2]  -> PrimitiveArray(SingleInteger)
--R             from FiniteFieldCyclicGroupExtension(D2,D3) if D2 has 
--R            FFIELDC and D3: PI
--R
--RExamples of getZechTable from FiniteFieldCyclicGroup
--R
--R
--RExamples of getZechTable from FiniteFieldCyclicGroupExtensionByPolynomial
--R
--R
--RExamples of getZechTable from FiniteFieldCyclicGroupExtension
--R
--E 1172

--S 1173 of 3320
)d op GF2FG
--R 
--R
--RThere is one unexposed function called GF2FG :
--R   [1] Complex(D4) -> D1 from InnerTrigonometricManipulations(D3,D4,D1)
--R             if D4 has Join(FunctionSpace(D3),RadicalCategory,
--R            TranscendentalFunctionCategory) and D3 has Join(
--R            IntegralDomain,OrderedSet) and D1 has Join(FunctionSpace(
--R            Complex(D3)),RadicalCategory,TranscendentalFunctionCategory
--R            )
--R
--RExamples of GF2FG from InnerTrigonometricManipulations
--R
--E 1173

--S 1174 of 3320 done
)d op gnuDraw
--R 
--R
--RThere are 4 exposed functions called gnuDraw :
--R   [1] (Expression(Float),SegmentBinding(Float),String,List(DrawOption)
--R            ) -> Void
--R             from GnuDraw
--R   [2] (Expression(Float),SegmentBinding(Float),String) -> Void from 
--R            GnuDraw
--R   [3] (Expression(Float),SegmentBinding(Float),SegmentBinding(Float),
--R            String,List(DrawOption)) -> Void
--R             from GnuDraw
--R   [4] (Expression(Float),SegmentBinding(Float),SegmentBinding(Float),
--R            String) -> Void
--R             from GnuDraw
--R
--RExamples of gnuDraw from GnuDraw
--R
--RgnuDraw(sin(x)*cos(y),x=-6..4,y=-4..6,"out3d.dat") 
--R)sys gnuplot -persist out3d.dat 
--R)sys evince out2d.dat.ps -- linux 
--R)sys open out2d.dat.ps -- mac 
--R)sys firefox out2d.dat.ps -- everywhere
--R
--RgnuDraw(sin(x)*cos(y),x=-6..4,y=-4..6,"out3d.dat",title=="out3d") 
--R)sys gnuplot -persist out3d.dat 
--R)sys evince out2d.dat.ps -- linux 
--R)sys open out2d.dat.ps -- mac 
--R)sys firefox out2d.dat.ps -- everywhere
--R
--RgnuDraw(D(cos(exp(z))/exp(z^2),z),z=-5..5,"out2d.dat") 
--R)sys gnuplot -persist out2d.dat 
--R)sys evince out2d.dat.ps -- linux 
--R)sys open out2d.dat.ps -- mac 
--R)sys firefox out2d.dat.ps -- everywhere
--R
--RgnuDraw(D(cos(exp(z))/exp(z^2),z),z=-5..5,"out2d.dat",title=="out2d") 
--R)sys gnuplot -persist out2d.dat 
--R)sys evince out2d.dat.ps -- linux 
--R)sys open out2d.dat.ps -- mac 
--R)sys firefox out2d.dat.ps -- everywhere
--R
--E 1174

--S 1175 of 3320
)d op goodnessOfFit
--R 
--R
--RThere are 2 exposed functions called goodnessOfFit :
--R   [1] NumericalOptimizationProblem -> Result
--R             from AnnaNumericalOptimizationPackage
--R   [2] (List(Expression(Float)),List(Float)) -> Result
--R             from AnnaNumericalOptimizationPackage
--R
--RExamples of goodnessOfFit from AnnaNumericalOptimizationPackage
--R
--E 1175

--S 1176 of 3320
)d op goodPoint
--R 
--R
--RThere is one unexposed function called goodPoint :
--R   [1] (D2,D2) -> D1 from ChangeOfVariable(D1,D3,D2)
--R             if D3 has UPOLYC(D1) and D1 has UFD and D2 has UPOLYC(FRAC
--R            (D3))
--R
--RExamples of goodPoint from ChangeOfVariable
--R
--E 1176

--S 1177 of 3320
)d op goppaCode
--R 
--R
--RThere are 4 exposed functions called goppaCode :
--R   [1] (Divisor(PlacesOverPseudoAlgebraicClosureOfFiniteField(D3)),
--R            Divisor(PlacesOverPseudoAlgebraicClosureOfFiniteField(D3))) -> 
--R            Matrix(D3)
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D3,D4
--R            ,D5)
--R             if D3 has FFIELDC and D4: LIST(SYMBOL) and D5 has BLMETCT
--R            
--R   [2] (Divisor(PlacesOverPseudoAlgebraicClosureOfFiniteField(D4)),List
--R            (PlacesOverPseudoAlgebraicClosureOfFiniteField(D4))) -> Matrix(D4
--R            )
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D4,D5
--R            ,D6)
--R             if D4 has FFIELDC and D5: LIST(SYMBOL) and D6 has BLMETCT
--R            
--R   [3] (Divisor(Places(D3)),Divisor(Places(D3))) -> Matrix(D3)
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D5 has BLMETCT
--R         
--R   [4] (Divisor(Places(D4)),List(Places(D4))) -> Matrix(D4)
--R             from PackageForAlgebraicFunctionField(D4,D5,D6)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D6 has BLMETCT
--R         
--R
--RExamples of goppaCode from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of goppaCode from PackageForAlgebraicFunctionField
--R
--E 1177

--S 1178 of 3320
)d op GospersMethod
--R 
--R
--RThere is one unexposed function called GospersMethod :
--R   [1] (D1,D2,(() -> D2)) -> Union(D1,"failed")
--R             from GosperSummationMethod(D4,D2,D5,D6,D1)
--R             if D2 has ORDSET and D4 has OAMONS and D5 has INTDOM and 
--R            D6 has POLYCAT(D5,D4,D2) and D1 has Join(RetractableTo(
--R            Fraction(Integer)),Field)with
--R               coerce : D6 -> %
--R               numer : % -> D6
--R               denom : % -> D6
--R
--RExamples of GospersMethod from GosperSummationMethod
--R
--E 1178

--S 1179 of 3320
)d op goto
--R 
--R
--RThere is one exposed function called goto :
--R   [1] SingleInteger -> FortranCode from FortranCode
--R
--RExamples of goto from FortranCode
--R
--E 1179

--S 1180 of 3320
)d op gradient
--R 
--R
--RThere is one exposed function called gradient :
--R   [1] (D2,D3) -> Vector(D2) from MultiVariableCalculusFunctions(D4,D2,
--R            D5,D3)
--R             if D4 has SETCAT and D2 has PDRING(D4) and D5 has FLAGG(D2
--R            ) and D3 has FiniteLinearAggregate(D4)with
--R                 finiteAggregate
--R
--RExamples of gradient from MultiVariableCalculusFunctions
--R
--E 1180

--S 1181 of 3320
)d op graeffe
--R 
--R
--RThere is one unexposed function called graeffe :
--R   [1] D1 -> D1 from ComplexRootFindingPackage(D2,D1)
--R             if D2 has Join(Field,OrderedRing) and D1 has UPOLYC(
--R            COMPLEX(D2))
--R
--RExamples of graeffe from ComplexRootFindingPackage
--R
--E 1181

--S 1182 of 3320
)d op gramschmidt
--R 
--R
--RThere is one exposed function called gramschmidt :
--R   [1] List(Matrix(Expression(Integer))) -> List(Matrix(Expression(
--R            Integer)))
--R             from RadicalEigenPackage
--R
--RExamples of gramschmidt from RadicalEigenPackage
--R
--E 1182

--S 1183 of 3320
)d op graphCurves
--R 
--R
--RThere are 3 unexposed functions called graphCurves :
--R   [1] (List(List(Point(DoubleFloat))),Palette,Palette,PositiveInteger,
--R            List(DrawOption)) -> GraphImage
--R             from ViewportPackage
--R   [2] List(List(Point(DoubleFloat))) -> GraphImage from 
--R            ViewportPackage
--R   [3] (List(List(Point(DoubleFloat))),List(DrawOption)) -> GraphImage
--R             from ViewportPackage
--R
--RExamples of graphCurves from ViewportPackage
--R
--E 1183

--S 1184 of 3320
)d op graphImage
--R 
--R
--RThere is one unexposed function called graphImage :
--R   [1]  -> GraphImage from GraphImage
--R
--RExamples of graphImage from GraphImage
--R
--E 1184

--S 1185 of 3320
)d op graphs
--R 
--R
--RThere is one exposed function called graphs :
--R   [1] Integer -> SymmetricPolynomial(Fraction(Integer)) from 
--R            CycleIndicators
--R
--RThere is one unexposed function called graphs :
--R   [1] TwoDimensionalViewport -> Vector(Union(GraphImage,undefined))
--R             from TwoDimensionalViewport
--R
--RExamples of graphs from CycleIndicators
--R
--R
--RExamples of graphs from TwoDimensionalViewport
--R
--E 1185

--S 1186 of 3320
)d op graphState
--R 
--R
--RThere is one unexposed function called graphState :
--R   [1] (TwoDimensionalViewport,PositiveInteger,DoubleFloat,DoubleFloat,
--R            DoubleFloat,DoubleFloat,Integer,Integer,Integer,Integer,Palette,
--R            Integer,Palette,Integer) -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of graphState from TwoDimensionalViewport
--R
--E 1186

--S 1187 of 3320
)d op graphStates
--R 
--R
--RThere is one unexposed function called graphStates :
--R   [1] TwoDimensionalViewport -> Vector(Record(scaleX: DoubleFloat,
--R            scaleY: DoubleFloat,deltaX: DoubleFloat,deltaY: DoubleFloat,
--R            points: Integer,connect: Integer,spline: Integer,axes: Integer,
--R            axesColor: Palette,units: Integer,unitsColor: Palette,showing: 
--R            Integer))
--R             from TwoDimensionalViewport
--R
--RExamples of graphStates from TwoDimensionalViewport
--R
--E 1187

--S 1188 of 3320
)d op green
--R 
--R
--RThere is one exposed function called green :
--R   [1]  -> Color from Color
--R
--RExamples of green from Color
--R
--E 1188

--S 1189 of 3320
)d op groebgen
--R 
--R
--RThere is one unexposed function called groebgen :
--R   [1] List(DistributedMultivariatePolynomial(D3,D4)) -> Record(glbase
--R            : List(DistributedMultivariatePolynomial(D3,D4)),glval: List(
--R            Integer))
--R             from LinGroebnerPackage(D3,D4) if D3: LIST(SYMBOL) and D4
--R             has GCDDOM
--R
--RExamples of groebgen from LinGroebnerPackage
--R
--E 1189

--S 1190 of 3320
)d op groebner
--R 
--R
--RThere are 5 exposed functions called groebner :
--R   [1] List(D5) -> List(D5) from GroebnerPackage(D2,D3,D4,D5)
--R             if D5 has POLYCAT(D2,D3,D4) and D2 has GCDDOM and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [2] (List(D6),String) -> List(D6) from GroebnerPackage(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [3] (List(D6),String,String) -> List(D6) from GroebnerPackage(D3,D4,
--R            D5,D6)
--R             if D6 has POLYCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [4] PolynomialIdeals(D1,D2,D3,D4) -> PolynomialIdeals(D1,D2,D3,D4)
--R             from PolynomialIdeals(D1,D2,D3,D4)
--R             if D1 has FIELD and D2 has OAMONS and D3 has ORDSET and D4
--R             has POLYCAT(D1,D2,D3)
--R   [5] List(D6) -> List(D6) from InterfaceGroebnerPackage(D2,D3,D4,D5,
--R            D6)
--R             if D6 has POLYCAT(D2,D4,D5) and D2 has FIELD and D4 has 
--R            OAMONS and D5 has ORDSET and D3: LIST(SYMBOL)
--R
--RThere are 2 unexposed functions called groebner :
--R   [1] List(Polynomial(D2)) -> List(Polynomial(D2)) from 
--R            FGLMIfCanPackage(D2,D3)
--R             if D2 has GCDDOM and D3: LIST(SYMBOL)
--R   [2] List(NewSparseMultivariatePolynomial(D2,OrderedVariableList(D3))
--R            ) -> List(NewSparseMultivariatePolynomial(D2,OrderedVariableList(
--R            D3)))
--R             from LexTriangularPackage(D2,D3) if D2 has GCDDOM and D3: 
--R            LIST(SYMBOL)
--R
--RExamples of groebner from FGLMIfCanPackage
--R
--R
--RExamples of groebner from GroebnerPackage
--R
--Rs1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 
--Rs2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s 
--Rs3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 
--Rs4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s 
--Rs5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3 
--Rs6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 
--Rs7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000 
--Rsn7:=[s1,s2,s3,s4,s5,s6,s7] 
--Rgroebner(sn7,"info","redcrit")
--R
--Rs1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 
--Rs2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s 
--Rs3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 
--Rs4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s 
--Rs5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3 
--Rs6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 
--Rs7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000 
--Rsn7:=[s1,s2,s3,s4,s5,s6,s7] 
--Rgroebner(sn7,"info") 
--Rgroebner(sn7,"redcrit")
--R
--Rs1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 
--Rs2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s 
--Rs3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 
--Rs4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s 
--Rs5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3 
--Rs6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 
--Rs7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000 
--Rsn7:=[s1,s2,s3,s4,s5,s6,s7] 
--Rgroebner(sn7)
--R
--R
--RExamples of groebner from PolynomialIdeals
--R
--R
--RExamples of groebner from InterfaceGroebnerPackage
--R
--R
--RExamples of groebner from LexTriangularPackage
--R
--E 1190

--S 1191 of 3320
)d op groebner?
--R 
--R
--RThere is one exposed function called groebner? :
--R   [1] PolynomialIdeals(D2,D3,D4,D5) -> Boolean
--R             from PolynomialIdeals(D2,D3,D4,D5)
--R             if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D5
--R             has POLYCAT(D2,D3,D4)
--R
--RExamples of groebner? from PolynomialIdeals
--R
--E 1191

--S 1192 of 3320 done
)d op groebnerFactorize
--R 
--R
--RThere are 4 exposed functions called groebnerFactorize :
--R   [1] (List(D6),List(D6)) -> List(List(D6))
--R             from GroebnerFactorizationPackage(D3,D4,D5,D6)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D4
--R             has OAMONS and D5 has ORDSET and D6 has POLYCAT(D3,D4,D5)
--R            
--R   [2] (List(D7),List(D7),Boolean) -> List(List(D7))
--R             from GroebnerFactorizationPackage(D4,D5,D6,D7)
--R             if D4 has Join(EuclideanDomain,CharacteristicZero) and D5
--R             has OAMONS and D6 has ORDSET and D7 has POLYCAT(D4,D5,D6)
--R            
--R   [3] List(D6) -> List(List(D6)) from GroebnerFactorizationPackage(D3,
--R            D4,D5,D6)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D4
--R             has OAMONS and D5 has ORDSET and D6 has POLYCAT(D3,D4,D5)
--R            
--R   [4] (List(D7),Boolean) -> List(List(D7))
--R             from GroebnerFactorizationPackage(D4,D5,D6,D7)
--R             if D4 has Join(EuclideanDomain,CharacteristicZero) and D5
--R             has OAMONS and D6 has ORDSET and D7 has POLYCAT(D4,D5,D6)
--R            
--R
--RExamples of groebnerFactorize from GroebnerFactorizationPackage
--R
--Rmfzn : SQMATRIX(6,DMP([x,y,z],Fraction INT)) := 
--R[ [0,1,1,1,1,1], [1,0,1,8/3,x,8/3], [1,1,0,1,8/3,y], 
--R[1,8/3,1,0,1,8/3], [1,x,8/3,1,0,1], [1,8/3,y,8/3,1,0] ] 
--Req := determinant mfzn 
--RgroebnerFactorize 
--R[eq,eval(eq, [x,y,z],[y,z,x]), eval(eq,[x,y,z],[z,x,y])]
--R
--E 1192

--S 1193 of 3320
)d op groebnerIdeal
--R 
--R
--RThere is one exposed function called groebnerIdeal :
--R   [1] List(D5) -> PolynomialIdeals(D2,D3,D4,D5)
--R             from PolynomialIdeals(D2,D3,D4,D5)
--R             if D5 has POLYCAT(D2,D3,D4) and D2 has FIELD and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RExamples of groebnerIdeal from PolynomialIdeals
--R
--E 1193

--S 1194 of 3320
)d op groebSolve
--R 
--R
--RThere is one unexposed function called groebSolve :
--R   [1] (List(DistributedMultivariatePolynomial(D4,D5)),List(
--R            OrderedVariableList(D4))) -> List(List(
--R            DistributedMultivariatePolynomial(D4,D5)))
--R             from GroebnerSolve(D4,D5,D6)
--R             if D4: LIST(SYMBOL) and D5 has GCDDOM and D6 has GCDDOM
--R         
--R
--RExamples of groebSolve from GroebnerSolve
--R
--E 1194

--S 1195 of 3320
)d op ground
--R 
--R
--RThere are 2 exposed functions called ground :
--R   [1] D -> D1 from D if D has FAMR(D1,D2) and D2 has OAMON and D1 has 
--R            RING
--R   [2] D -> D1 from D if D has FS(D1) and D1 has ORDSET
--R
--RExamples of ground from FiniteAbelianMonoidRing
--R
--R
--RExamples of ground from FunctionSpace
--R
--E 1195

--S 1196 of 3320
)d op ground?
--R 
--R
--RThere are 4 exposed functions called ground? :
--R   [1] D -> Boolean from D if D has FAMR(D2,D3) and D2 has RING and D3
--R             has OAMON
--R   [2] D -> Boolean from D if D has FS(D2) and D2 has ORDSET
--R   [3] MyExpression(D2,D3) -> Boolean from MyExpression(D2,D3)
--R             if D2: SYMBOL and D3 has Join(Ring,OrderedSet,
--R            IntegralDomain)
--R   [4] D -> Boolean from D if D has PACPERC
--R
--RExamples of ground? from FiniteAbelianMonoidRing
--R
--R
--RExamples of ground? from FunctionSpace
--R
--R
--RExamples of ground? from MyExpression
--R
--R
--RExamples of ground? from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--E 1196

--S 1197 of 3320
)d op GT
--R 
--R
--RThere is one exposed function called GT :
--R   [1] (Union(I: Expression(Integer),F: Expression(Float),CF: 
--R            Expression(Complex(Float)),switch: Switch),Union(I: Expression(
--R            Integer),F: Expression(Float),CF: Expression(Complex(Float)),
--R            switch: Switch)) -> Switch
--R             from Switch
--R
--RExamples of GT from Switch
--R
--E 1197

--S 1198 of 3320
)d op guess
--R 
--R
--RThere are 24 exposed functions called guess :
--R   [1] List(AlgebraicNumber) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [2] (List(AlgebraicNumber),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [3] (List(AlgebraicNumber),List(((List(AlgebraicNumber),List(
--R            GuessOption)) -> List(Record(function: Expression(Integer),order
--R            : NonNegativeInteger)))),List(Symbol)) -> List(Record(function: 
--R            Expression(Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [4] (List(AlgebraicNumber),List(((List(AlgebraicNumber),List(
--R            GuessOption)) -> List(Record(function: Expression(Integer),order
--R            : NonNegativeInteger)))),List(Symbol),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [5] List(D3) -> List(Record(function: Expression(Integer),order: 
--R            NonNegativeInteger))
--R             from GuessFinite(D3)
--R             if D3 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [6] (List(D4),List(GuessOption)) -> List(Record(function: Expression
--R            (Integer),order: NonNegativeInteger))
--R             from GuessFinite(D4)
--R             if D4 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [7] (List(D5),List(((List(D5),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger)))),List(
--R            Symbol)) -> List(Record(function: Expression(Integer),order: 
--R            NonNegativeInteger))
--R             from GuessFinite(D5)
--R             if D5 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [8] (List(D6),List(((List(D6),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger)))),List(
--R            Symbol),List(GuessOption)) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessFinite(D6)
--R             if D6 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [9] List(Fraction(Integer)) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [10] (List(Fraction(Integer)),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [11] (List(Fraction(Integer)),List(((List(Fraction(Integer)),List(
--R            GuessOption)) -> List(Record(function: Expression(Integer),order
--R            : NonNegativeInteger)))),List(Symbol)) -> List(Record(function: 
--R            Expression(Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [12] (List(Fraction(Integer)),List(((List(Fraction(Integer)),List(
--R            GuessOption)) -> List(Record(function: Expression(Integer),order
--R            : NonNegativeInteger)))),List(Symbol),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [13] List(D4) -> List(Record(function: D6,order: NonNegativeInteger)
--R            )
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D4 has FIELD and D9: (D4 -> D6) and D7 has Join(
--R            OrderedSet,IntegralDomain) and D8: (D7 -> D4) and D5 has 
--R            GCDDOM and D6 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D7),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [14] (List(D6),List(GuessOption)) -> List(Record(function: D8,order
--R            : NonNegativeInteger))
--R             from Guess(D6,D7,D8,D9,D10,D2)
--R             if D6 has FIELD and D2: (D6 -> D8) and D9 has Join(
--R            OrderedSet,IntegralDomain) and D10: (D9 -> D6) and D7 has 
--R            GCDDOM and D8 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D9),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [15] (List(D8),List(((List(D8),List(GuessOption)) -> List(Record(
--R            function: D10,order: NonNegativeInteger)))),List(Symbol)) -> List
--R            (Record(function: D10,order: NonNegativeInteger))
--R             from Guess(D8,D9,D10,D11,D2,D3)
--R             if D8 has FIELD and D3: (D8 -> D10) and D11 has Join(
--R            OrderedSet,IntegralDomain) and D2: (D11 -> D8) and D9 has 
--R            GCDDOM and D10 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D11),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [16] (List(D10),List(((List(D10),List(GuessOption)) -> List(Record(
--R            function: D12,order: NonNegativeInteger)))),List(Symbol),List(
--R            GuessOption)) -> List(Record(function: D12,order: 
--R            NonNegativeInteger))
--R             from Guess(D10,D11,D12,D2,D3,D4)
--R             if D10 has FIELD and D4: (D10 -> D12) and D2 has Join(
--R            OrderedSet,IntegralDomain) and D3: (D2 -> D10) and D11 has 
--R            GCDDOM and D12 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D2),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [17] List(Fraction(Polynomial(Integer))) -> List(Record(function: 
--R            Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [18] (List(Fraction(Polynomial(Integer))),List(GuessOption)) -> List
--R            (Record(function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [19] (List(Fraction(Polynomial(Integer))),List(((List(Fraction(
--R            Polynomial(Integer))),List(GuessOption)) -> List(Record(function
--R            : Expression(Integer),order: NonNegativeInteger)))),List(Symbol))
--R             -> List(Record(function: Expression(Integer),order: 
--R            NonNegativeInteger))
--R             from GuessPolynomial
--R   [20] (List(Fraction(Polynomial(Integer))),List(((List(Fraction(
--R            Polynomial(Integer))),List(GuessOption)) -> List(Record(function
--R            : Expression(Integer),order: NonNegativeInteger)))),List(Symbol),
--R            List(GuessOption)) -> List(Record(function: Expression(Integer),
--R            order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [21] List(Fraction(MyUnivariatePolynomial(D3,Integer))) -> List(
--R            Record(function: MyExpression(D3,Integer),order: 
--R            NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R   [22] (List(Fraction(MyUnivariatePolynomial(D4,Integer))),List(
--R            GuessOption)) -> List(Record(function: MyExpression(D4,Integer),
--R            order: NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D4) if D4: SYMBOL
--R   [23] (List(Fraction(MyUnivariatePolynomial(D5,Integer))),List(((List
--R            (Fraction(MyUnivariatePolynomial(D5,Integer))),List(GuessOption))
--R             -> List(Record(function: MyExpression(D5,Integer),order: 
--R            NonNegativeInteger)))),List(Symbol)) -> List(Record(function: 
--R            MyExpression(D5,Integer),order: NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D5) if D5: SYMBOL
--R   [24] (List(Fraction(MyUnivariatePolynomial(D6,Integer))),List(((List
--R            (Fraction(MyUnivariatePolynomial(D6,Integer))),List(GuessOption))
--R             -> List(Record(function: MyExpression(D6,Integer),order: 
--R            NonNegativeInteger)))),List(Symbol),List(GuessOption)) -> List(
--R            Record(function: MyExpression(D6,Integer),order: 
--R            NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D6) if D6: SYMBOL
--R
--RExamples of guess from GuessAlgebraicNumber
--R
--R
--RExamples of guess from GuessFinite
--R
--R
--RExamples of guess from GuessInteger
--R
--R
--RExamples of guess from Guess
--R
--R
--RExamples of guess from GuessPolynomial
--R
--R
--RExamples of guess from GuessUnivariatePolynomial
--R
--E 1198

--S 1199 of 3320
)d op guessADE
--R 
--R
--RThere are 18 exposed functions called guessADE :
--R   [1] List(AlgebraicNumber) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [2] (List(AlgebraicNumber),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [3] Symbol -> ((List(AlgebraicNumber),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger)))
--R             from GuessAlgebraicNumber if AlgebraicNumber has RETRACT(
--R            SYMBOL)
--R   [4] List(D3) -> List(Record(function: Expression(Integer),order: 
--R            NonNegativeInteger))
--R             from GuessFinite(D3)
--R             if D3 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [5] (List(D4),List(GuessOption)) -> List(Record(function: Expression
--R            (Integer),order: NonNegativeInteger))
--R             from GuessFinite(D4)
--R             if D4 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [6] Symbol -> ((List(D3),List(GuessOption)) -> List(Record(function
--R            : Expression(Integer),order: NonNegativeInteger)))
--R             from GuessFinite(D3)
--R             if D3 has RETRACT(SYMBOL) and D3 has Join(
--R            FiniteFieldCategory,ConvertibleTo(Integer))
--R   [7] List(Fraction(Integer)) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [8] (List(Fraction(Integer)),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [9] Symbol -> ((List(Fraction(Integer)),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger)))
--R             from GuessInteger
--R             if Fraction(Integer) has RETRACT(SYMBOL) and Integer has 
--R            RETRACT(SYMBOL)
--R   [10] List(D4) -> List(Record(function: D6,order: NonNegativeInteger)
--R            )
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D4 has FIELD and D9: (D4 -> D6) and D7 has Join(
--R            OrderedSet,IntegralDomain) and D8: (D7 -> D4) and D5 has 
--R            GCDDOM and D6 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D7),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [11] (List(D6),List(GuessOption)) -> List(Record(function: D8,order
--R            : NonNegativeInteger))
--R             from Guess(D6,D7,D8,D9,D10,D2)
--R             if D6 has FIELD and D2: (D6 -> D8) and D9 has Join(
--R            OrderedSet,IntegralDomain) and D10: (D9 -> D6) and D7 has 
--R            GCDDOM and D8 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D9),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [12] Symbol -> ((List(D4),List(GuessOption)) -> List(Record(function
--R            : D6,order: NonNegativeInteger)))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D7 has Join(OrderedSet,IntegralDomain) and D8: (D7 -> 
--R            D4) and D4 has RETRACT(SYMBOL) and D5 has RETRACT(SYMBOL) 
--R            and D4 has FIELD and D5 has GCDDOM and D6 has Join(
--R            FunctionSpace(Integer),IntegralDomain,RetractableTo(D7),
--R            RetractableTo(Symbol),RetractableTo(Integer),
--R            CombinatorialOpsCategory,PartialDifferentialRing(Symbol))
--R            with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Booleanand D9: (D4 -> D6)
--R   [13] List(Fraction(Polynomial(Integer))) -> List(Record(function: 
--R            Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [14] (List(Fraction(Polynomial(Integer))),List(GuessOption)) -> List
--R            (Record(function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [15] Symbol -> ((List(Fraction(Polynomial(Integer))),List(
--R            GuessOption)) -> List(Record(function: Expression(Integer),order
--R            : NonNegativeInteger)))
--R             from GuessPolynomial
--R             if Fraction(Polynomial(Integer)) has RETRACT(SYMBOL) and 
--R            Polynomial(Integer) has RETRACT(SYMBOL)
--R   [16] List(Fraction(MyUnivariatePolynomial(D3,Integer))) -> List(
--R            Record(function: MyExpression(D3,Integer),order: 
--R            NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R   [17] (List(Fraction(MyUnivariatePolynomial(D4,Integer))),List(
--R            GuessOption)) -> List(Record(function: MyExpression(D4,Integer),
--R            order: NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D4) if D4: SYMBOL
--R   [18] Symbol -> ((List(Fraction(MyUnivariatePolynomial(D3,Integer))),
--R            List(GuessOption)) -> List(Record(function: MyExpression(D3,
--R            Integer),order: NonNegativeInteger)))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R
--RExamples of guessADE from GuessAlgebraicNumber
--R
--R
--RExamples of guessADE from GuessFinite
--R
--R
--RExamples of guessADE from GuessInteger
--R
--R
--RExamples of guessADE from Guess
--R
--R
--RExamples of guessADE from GuessPolynomial
--R
--R
--RExamples of guessADE from GuessUnivariatePolynomial
--R
--E 1199

--S 1200 of 3320
)d op guessAlg
--R 
--R
--RThere are 12 exposed functions called guessAlg :
--R   [1] List(AlgebraicNumber) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [2] (List(AlgebraicNumber),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [3] List(D3) -> List(Record(function: Expression(Integer),order: 
--R            NonNegativeInteger))
--R             from GuessFinite(D3)
--R             if D3 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [4] (List(D4),List(GuessOption)) -> List(Record(function: Expression
--R            (Integer),order: NonNegativeInteger))
--R             from GuessFinite(D4)
--R             if D4 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [5] List(Fraction(Integer)) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [6] (List(Fraction(Integer)),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [7] List(D4) -> List(Record(function: D6,order: NonNegativeInteger))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D4 has FIELD and D9: (D4 -> D6) and D7 has Join(
--R            OrderedSet,IntegralDomain) and D8: (D7 -> D4) and D5 has 
--R            GCDDOM and D6 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D7),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [8] (List(D6),List(GuessOption)) -> List(Record(function: D8,order: 
--R            NonNegativeInteger))
--R             from Guess(D6,D7,D8,D9,D10,D2)
--R             if D6 has FIELD and D2: (D6 -> D8) and D9 has Join(
--R            OrderedSet,IntegralDomain) and D10: (D9 -> D6) and D7 has 
--R            GCDDOM and D8 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D9),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [9] List(Fraction(Polynomial(Integer))) -> List(Record(function: 
--R            Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [10] (List(Fraction(Polynomial(Integer))),List(GuessOption)) -> List
--R            (Record(function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [11] List(Fraction(MyUnivariatePolynomial(D3,Integer))) -> List(
--R            Record(function: MyExpression(D3,Integer),order: 
--R            NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R   [12] (List(Fraction(MyUnivariatePolynomial(D4,Integer))),List(
--R            GuessOption)) -> List(Record(function: MyExpression(D4,Integer),
--R            order: NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D4) if D4: SYMBOL
--R
--RExamples of guessAlg from GuessAlgebraicNumber
--R
--R
--RExamples of guessAlg from GuessFinite
--R
--R
--RExamples of guessAlg from GuessInteger
--R
--R
--RExamples of guessAlg from Guess
--R
--R
--RExamples of guessAlg from GuessPolynomial
--R
--R
--RExamples of guessAlg from GuessUnivariatePolynomial
--R
--E 1200

--S 1201 of 3320
)d op guessBinRat
--R 
--R
--RThere are 18 exposed functions called guessBinRat :
--R   [1] List(AlgebraicNumber) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [2] (List(AlgebraicNumber),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [3] Symbol -> ((List(AlgebraicNumber),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger)))
--R             from GuessAlgebraicNumber if AlgebraicNumber has RETRACT(
--R            SYMBOL)
--R   [4] List(D3) -> List(Record(function: Expression(Integer),order: 
--R            NonNegativeInteger))
--R             from GuessFinite(D3)
--R             if D3 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [5] (List(D4),List(GuessOption)) -> List(Record(function: Expression
--R            (Integer),order: NonNegativeInteger))
--R             from GuessFinite(D4)
--R             if D4 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [6] Symbol -> ((List(D3),List(GuessOption)) -> List(Record(function
--R            : Expression(Integer),order: NonNegativeInteger)))
--R             from GuessFinite(D3)
--R             if D3 has RETRACT(SYMBOL) and D3 has Join(
--R            FiniteFieldCategory,ConvertibleTo(Integer))
--R   [7] List(Fraction(Integer)) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [8] (List(Fraction(Integer)),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [9] Symbol -> ((List(Fraction(Integer)),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger)))
--R             from GuessInteger
--R             if Fraction(Integer) has RETRACT(SYMBOL) and Integer has 
--R            RETRACT(SYMBOL)
--R   [10] List(D4) -> List(Record(function: D6,order: NonNegativeInteger)
--R            )
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D4 has FIELD and D9: (D4 -> D6) and D7 has Join(
--R            OrderedSet,IntegralDomain) and D8: (D7 -> D4) and D5 has 
--R            GCDDOM and D6 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D7),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [11] (List(D6),List(GuessOption)) -> List(Record(function: D8,order
--R            : NonNegativeInteger))
--R             from Guess(D6,D7,D8,D9,D10,D2)
--R             if D6 has FIELD and D2: (D6 -> D8) and D9 has Join(
--R            OrderedSet,IntegralDomain) and D10: (D9 -> D6) and D7 has 
--R            GCDDOM and D8 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D9),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [12] Symbol -> ((List(D4),List(GuessOption)) -> List(Record(function
--R            : D6,order: NonNegativeInteger)))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D7 has Join(OrderedSet,IntegralDomain) and D8: (D7 -> 
--R            D4) and D4 has RETRACT(SYMBOL) and D5 has RETRACT(SYMBOL) 
--R            and D4 has FIELD and D5 has GCDDOM and D6 has Join(
--R            FunctionSpace(Integer),IntegralDomain,RetractableTo(D7),
--R            RetractableTo(Symbol),RetractableTo(Integer),
--R            CombinatorialOpsCategory,PartialDifferentialRing(Symbol))
--R            with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Booleanand D9: (D4 -> D6)
--R   [13] List(Fraction(Polynomial(Integer))) -> List(Record(function: 
--R            Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [14] (List(Fraction(Polynomial(Integer))),List(GuessOption)) -> List
--R            (Record(function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [15] Symbol -> ((List(Fraction(Polynomial(Integer))),List(
--R            GuessOption)) -> List(Record(function: Expression(Integer),order
--R            : NonNegativeInteger)))
--R             from GuessPolynomial
--R             if Fraction(Polynomial(Integer)) has RETRACT(SYMBOL) and 
--R            Polynomial(Integer) has RETRACT(SYMBOL)
--R   [16] List(Fraction(MyUnivariatePolynomial(D3,Integer))) -> List(
--R            Record(function: MyExpression(D3,Integer),order: 
--R            NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R   [17] (List(Fraction(MyUnivariatePolynomial(D4,Integer))),List(
--R            GuessOption)) -> List(Record(function: MyExpression(D4,Integer),
--R            order: NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D4) if D4: SYMBOL
--R   [18] Symbol -> ((List(Fraction(MyUnivariatePolynomial(D3,Integer))),
--R            List(GuessOption)) -> List(Record(function: MyExpression(D3,
--R            Integer),order: NonNegativeInteger)))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R
--RExamples of guessBinRat from GuessAlgebraicNumber
--R
--R
--RExamples of guessBinRat from GuessFinite
--R
--R
--RExamples of guessBinRat from GuessInteger
--R
--R
--RExamples of guessBinRat from Guess
--R
--R
--RExamples of guessBinRat from GuessPolynomial
--R
--R
--RExamples of guessBinRat from GuessUnivariatePolynomial
--R
--E 1201

--S 1202 of 3320
)d op guessExpRat
--R 
--R
--RThere are 18 exposed functions called guessExpRat :
--R   [1] List(AlgebraicNumber) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [2] (List(AlgebraicNumber),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [3] Symbol -> ((List(AlgebraicNumber),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger)))
--R             from GuessAlgebraicNumber if AlgebraicNumber has RETRACT(
--R            SYMBOL)
--R   [4] List(D3) -> List(Record(function: Expression(Integer),order: 
--R            NonNegativeInteger))
--R             from GuessFinite(D3)
--R             if D3 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [5] (List(D4),List(GuessOption)) -> List(Record(function: Expression
--R            (Integer),order: NonNegativeInteger))
--R             from GuessFinite(D4)
--R             if D4 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [6] Symbol -> ((List(D3),List(GuessOption)) -> List(Record(function
--R            : Expression(Integer),order: NonNegativeInteger)))
--R             from GuessFinite(D3)
--R             if D3 has RETRACT(SYMBOL) and D3 has Join(
--R            FiniteFieldCategory,ConvertibleTo(Integer))
--R   [7] List(Fraction(Integer)) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [8] (List(Fraction(Integer)),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [9] Symbol -> ((List(Fraction(Integer)),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger)))
--R             from GuessInteger
--R             if Fraction(Integer) has RETRACT(SYMBOL) and Integer has 
--R            RETRACT(SYMBOL)
--R   [10] List(D4) -> List(Record(function: D6,order: NonNegativeInteger)
--R            )
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D4 has FIELD and D9: (D4 -> D6) and D7 has Join(
--R            OrderedSet,IntegralDomain) and D8: (D7 -> D4) and D5 has 
--R            GCDDOM and D6 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D7),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [11] (List(D6),List(GuessOption)) -> List(Record(function: D8,order
--R            : NonNegativeInteger))
--R             from Guess(D6,D7,D8,D9,D10,D2)
--R             if D6 has FIELD and D2: (D6 -> D8) and D9 has Join(
--R            OrderedSet,IntegralDomain) and D10: (D9 -> D6) and D7 has 
--R            GCDDOM and D8 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D9),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [12] Symbol -> ((List(D4),List(GuessOption)) -> List(Record(function
--R            : D6,order: NonNegativeInteger)))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D7 has Join(OrderedSet,IntegralDomain) and D8: (D7 -> 
--R            D4) and D4 has RETRACT(SYMBOL) and D5 has RETRACT(SYMBOL) 
--R            and D4 has FIELD and D5 has GCDDOM and D6 has Join(
--R            FunctionSpace(Integer),IntegralDomain,RetractableTo(D7),
--R            RetractableTo(Symbol),RetractableTo(Integer),
--R            CombinatorialOpsCategory,PartialDifferentialRing(Symbol))
--R            with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Booleanand D9: (D4 -> D6)
--R   [13] List(Fraction(Polynomial(Integer))) -> List(Record(function: 
--R            Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [14] (List(Fraction(Polynomial(Integer))),List(GuessOption)) -> List
--R            (Record(function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [15] Symbol -> ((List(Fraction(Polynomial(Integer))),List(
--R            GuessOption)) -> List(Record(function: Expression(Integer),order
--R            : NonNegativeInteger)))
--R             from GuessPolynomial
--R             if Fraction(Polynomial(Integer)) has RETRACT(SYMBOL) and 
--R            Polynomial(Integer) has RETRACT(SYMBOL)
--R   [16] List(Fraction(MyUnivariatePolynomial(D3,Integer))) -> List(
--R            Record(function: MyExpression(D3,Integer),order: 
--R            NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R   [17] (List(Fraction(MyUnivariatePolynomial(D4,Integer))),List(
--R            GuessOption)) -> List(Record(function: MyExpression(D4,Integer),
--R            order: NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D4) if D4: SYMBOL
--R   [18] Symbol -> ((List(Fraction(MyUnivariatePolynomial(D3,Integer))),
--R            List(GuessOption)) -> List(Record(function: MyExpression(D3,
--R            Integer),order: NonNegativeInteger)))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R
--RExamples of guessExpRat from GuessAlgebraicNumber
--R
--R
--RExamples of guessExpRat from GuessFinite
--R
--R
--RExamples of guessExpRat from GuessInteger
--R
--R
--RExamples of guessExpRat from Guess
--R
--R
--RExamples of guessExpRat from GuessPolynomial
--R
--R
--RExamples of guessExpRat from GuessUnivariatePolynomial
--R
--E 1202

--S 1203 of 3320
)d op guessHolo
--R 
--R
--RThere are 12 exposed functions called guessHolo :
--R   [1] List(AlgebraicNumber) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [2] (List(AlgebraicNumber),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [3] List(D3) -> List(Record(function: Expression(Integer),order: 
--R            NonNegativeInteger))
--R             from GuessFinite(D3)
--R             if D3 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [4] (List(D4),List(GuessOption)) -> List(Record(function: Expression
--R            (Integer),order: NonNegativeInteger))
--R             from GuessFinite(D4)
--R             if D4 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [5] List(Fraction(Integer)) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [6] (List(Fraction(Integer)),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [7] List(D4) -> List(Record(function: D6,order: NonNegativeInteger))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D4 has FIELD and D9: (D4 -> D6) and D7 has Join(
--R            OrderedSet,IntegralDomain) and D8: (D7 -> D4) and D5 has 
--R            GCDDOM and D6 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D7),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [8] (List(D6),List(GuessOption)) -> List(Record(function: D8,order: 
--R            NonNegativeInteger))
--R             from Guess(D6,D7,D8,D9,D10,D2)
--R             if D6 has FIELD and D2: (D6 -> D8) and D9 has Join(
--R            OrderedSet,IntegralDomain) and D10: (D9 -> D6) and D7 has 
--R            GCDDOM and D8 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D9),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [9] List(Fraction(Polynomial(Integer))) -> List(Record(function: 
--R            Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [10] (List(Fraction(Polynomial(Integer))),List(GuessOption)) -> List
--R            (Record(function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [11] List(Fraction(MyUnivariatePolynomial(D3,Integer))) -> List(
--R            Record(function: MyExpression(D3,Integer),order: 
--R            NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R   [12] (List(Fraction(MyUnivariatePolynomial(D4,Integer))),List(
--R            GuessOption)) -> List(Record(function: MyExpression(D4,Integer),
--R            order: NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D4) if D4: SYMBOL
--R
--RExamples of guessHolo from GuessAlgebraicNumber
--R
--R
--RExamples of guessHolo from GuessFinite
--R
--R
--RExamples of guessHolo from GuessInteger
--R
--R
--RExamples of guessHolo from Guess
--R
--R
--RExamples of guessHolo from GuessPolynomial
--R
--R
--RExamples of guessHolo from GuessUnivariatePolynomial
--R
--E 1203

--S 1204 of 3320
)d op guessHP
--R 
--R
--RThere are 6 exposed functions called guessHP :
--R   [1] (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(AlgebraicNumber) -> Stream(
--R            UnivariateFormalPowerSeries(AlgebraicNumber))),degreeStream: 
--R            Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(
--R            AlgebraicNumber)) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(AlgebraicNumber)))),exprStream: ((
--R            Expression(Integer),Symbol) -> Stream(Expression(Integer))),A: ((
--R            NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(
--R            AlgebraicNumber)) -> AlgebraicNumber),AF: ((NonNegativeInteger,
--R            NonNegativeInteger,UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(AlgebraicNumber))) -> 
--R            SparseUnivariatePolynomial(AlgebraicNumber)),AX: ((
--R            NonNegativeInteger,Symbol,Expression(Integer)) -> Expression(
--R            Integer)),C: (NonNegativeInteger -> List(AlgebraicNumber)))) -> (
--R            (List(AlgebraicNumber),List(GuessOption)) -> List(Record(function
--R            : Expression(Integer),order: NonNegativeInteger)))
--R             from GuessAlgebraicNumber
--R   [2] (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(D3) -> Stream(
--R            UnivariateFormalPowerSeries(D3))),degreeStream: Stream(
--R            NonNegativeInteger),testStream: (UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D3)) -> Stream(
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(D3)))),
--R            exprStream: ((Expression(Integer),Symbol) -> Stream(Expression(
--R            Integer))),A: ((NonNegativeInteger,NonNegativeInteger,
--R            SparseUnivariatePolynomial(D3)) -> D3),AF: ((NonNegativeInteger,
--R            NonNegativeInteger,UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D3))) -> SparseUnivariatePolynomial(D3
--R            )),AX: ((NonNegativeInteger,Symbol,Expression(Integer)) -> 
--R            Expression(Integer)),C: (NonNegativeInteger -> List(D3)))) -> ((
--R            List(D3),List(GuessOption)) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger)))
--R             from GuessFinite(D3)
--R             if D3 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [3] (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(Fraction(Integer)) -> Stream(
--R            UnivariateFormalPowerSeries(Fraction(Integer)))),degreeStream: 
--R            Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Integer))) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(Fraction(Integer))))),exprStream: ((
--R            Expression(Integer),Symbol) -> Stream(Expression(Integer))),A: ((
--R            NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(
--R            Integer)) -> Integer),AF: ((NonNegativeInteger,NonNegativeInteger
--R            ,UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Integer)))) -> SparseUnivariatePolynomial(Fraction(Integer))),AX
--R            : ((NonNegativeInteger,Symbol,Expression(Integer)) -> Expression(
--R            Integer)),C: (NonNegativeInteger -> List(Integer)))) -> ((List(
--R            Fraction(Integer)),List(GuessOption)) -> List(Record(function: 
--R            Expression(Integer),order: NonNegativeInteger)))
--R             from GuessInteger
--R   [4] (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(D4) -> Stream(
--R            UnivariateFormalPowerSeries(D4))),degreeStream: Stream(
--R            NonNegativeInteger),testStream: (UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D4)) -> Stream(
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(D4)))),
--R            exprStream: ((D6,Symbol) -> Stream(D6)),A: ((NonNegativeInteger,
--R            NonNegativeInteger,SparseUnivariatePolynomial(D5)) -> D5),AF: ((
--R            NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries
--R            (SparseUnivariatePolynomial(D4))) -> SparseUnivariatePolynomial(
--R            D4)),AX: ((NonNegativeInteger,Symbol,D6) -> D6),C: (
--R            NonNegativeInteger -> List(D5)))) -> ((List(D4),List(GuessOption)
--R            ) -> List(Record(function: D6,order: NonNegativeInteger)))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D4 has FIELD and D5 has GCDDOM and D6 has Join(
--R            FunctionSpace(Integer),IntegralDomain,RetractableTo(D7),
--R            RetractableTo(Symbol),RetractableTo(Integer),
--R            CombinatorialOpsCategory,PartialDifferentialRing(Symbol))
--R            with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Booleanand D7 has Join(OrderedSet,
--R            IntegralDomain) and D8: (D7 -> D4) and D9: (D4 -> D6)
--R         
--R   [5] (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(Fraction(Polynomial(Integer))) -> 
--R            Stream(UnivariateFormalPowerSeries(Fraction(Polynomial(Integer)))
--R            )),degreeStream: Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer)))) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(Fraction(Polynomial(Integer)))))),
--R            exprStream: ((Expression(Integer),Symbol) -> Stream(Expression(
--R            Integer))),A: ((NonNegativeInteger,NonNegativeInteger,
--R            SparseUnivariatePolynomial(Polynomial(Integer))) -> Polynomial(
--R            Integer)),AF: ((NonNegativeInteger,NonNegativeInteger,
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer))))) -> SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer)))),AX: ((NonNegativeInteger,Symbol,Expression
--R            (Integer)) -> Expression(Integer)),C: (NonNegativeInteger -> List
--R            (Polynomial(Integer))))) -> ((List(Fraction(Polynomial(Integer)))
--R            ,List(GuessOption)) -> List(Record(function: Expression(Integer),
--R            order: NonNegativeInteger)))
--R             from GuessPolynomial
--R   [6] (List(GuessOption) -> HPSPEC) -> ((List(Fraction(
--R            MyUnivariatePolynomial(D3,Integer))),List(GuessOption)) -> List(
--R            Record(function: MyExpression(D3,Integer),order: 
--R            NonNegativeInteger)))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R
--RExamples of guessHP from GuessAlgebraicNumber
--R
--R
--RExamples of guessHP from GuessFinite
--R
--R
--RExamples of guessHP from GuessInteger
--R
--R
--RExamples of guessHP from Guess
--R
--R
--RExamples of guessHP from GuessPolynomial
--R
--R
--RExamples of guessHP from GuessUnivariatePolynomial
--R
--E 1204

--S 1205 of 3320
)d op guessPade
--R 
--R
--RThere are 12 exposed functions called guessPade :
--R   [1] (List(AlgebraicNumber),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [2] List(AlgebraicNumber) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [3] (List(D4),List(GuessOption)) -> List(Record(function: Expression
--R            (Integer),order: NonNegativeInteger))
--R             from GuessFinite(D4)
--R             if D4 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [4] List(D3) -> List(Record(function: Expression(Integer),order: 
--R            NonNegativeInteger))
--R             from GuessFinite(D3)
--R             if D3 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [5] (List(Fraction(Integer)),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [6] List(Fraction(Integer)) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [7] (List(D6),List(GuessOption)) -> List(Record(function: D8,order: 
--R            NonNegativeInteger))
--R             from Guess(D6,D7,D8,D9,D10,D2)
--R             if D6 has FIELD and D2: (D6 -> D8) and D9 has Join(
--R            OrderedSet,IntegralDomain) and D10: (D9 -> D6) and D7 has 
--R            GCDDOM and D8 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D9),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [8] List(D4) -> List(Record(function: D6,order: NonNegativeInteger))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D4 has FIELD and D9: (D4 -> D6) and D7 has Join(
--R            OrderedSet,IntegralDomain) and D8: (D7 -> D4) and D5 has 
--R            GCDDOM and D6 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D7),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [9] (List(Fraction(Polynomial(Integer))),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [10] List(Fraction(Polynomial(Integer))) -> List(Record(function: 
--R            Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [11] (List(Fraction(MyUnivariatePolynomial(D4,Integer))),List(
--R            GuessOption)) -> List(Record(function: MyExpression(D4,Integer),
--R            order: NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D4) if D4: SYMBOL
--R   [12] List(Fraction(MyUnivariatePolynomial(D3,Integer))) -> List(
--R            Record(function: MyExpression(D3,Integer),order: 
--R            NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R
--RExamples of guessPade from GuessAlgebraicNumber
--R
--R
--RExamples of guessPade from GuessFinite
--R
--R
--RExamples of guessPade from GuessInteger
--R
--R
--RExamples of guessPade from Guess
--R
--R
--RExamples of guessPade from GuessPolynomial
--R
--R
--RExamples of guessPade from GuessUnivariatePolynomial
--R
--E 1205

--S 1206 of 3320
)d op guessPRec
--R 
--R
--RThere are 18 exposed functions called guessPRec :
--R   [1] (List(AlgebraicNumber),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [2] List(AlgebraicNumber) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [3] Symbol -> ((List(AlgebraicNumber),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger)))
--R             from GuessAlgebraicNumber if AlgebraicNumber has RETRACT(
--R            SYMBOL)
--R   [4] (List(D4),List(GuessOption)) -> List(Record(function: Expression
--R            (Integer),order: NonNegativeInteger))
--R             from GuessFinite(D4)
--R             if D4 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [5] List(D3) -> List(Record(function: Expression(Integer),order: 
--R            NonNegativeInteger))
--R             from GuessFinite(D3)
--R             if D3 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [6] Symbol -> ((List(D3),List(GuessOption)) -> List(Record(function
--R            : Expression(Integer),order: NonNegativeInteger)))
--R             from GuessFinite(D3)
--R             if D3 has RETRACT(SYMBOL) and D3 has Join(
--R            FiniteFieldCategory,ConvertibleTo(Integer))
--R   [7] (List(Fraction(Integer)),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [8] List(Fraction(Integer)) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [9] Symbol -> ((List(Fraction(Integer)),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger)))
--R             from GuessInteger
--R             if Fraction(Integer) has RETRACT(SYMBOL) and Integer has 
--R            RETRACT(SYMBOL)
--R   [10] (List(D6),List(GuessOption)) -> List(Record(function: D8,order
--R            : NonNegativeInteger))
--R             from Guess(D6,D7,D8,D9,D10,D2)
--R             if D6 has FIELD and D2: (D6 -> D8) and D9 has Join(
--R            OrderedSet,IntegralDomain) and D10: (D9 -> D6) and D7 has 
--R            GCDDOM and D8 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D9),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [11] List(D4) -> List(Record(function: D6,order: NonNegativeInteger)
--R            )
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D4 has FIELD and D9: (D4 -> D6) and D7 has Join(
--R            OrderedSet,IntegralDomain) and D8: (D7 -> D4) and D5 has 
--R            GCDDOM and D6 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D7),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [12] Symbol -> ((List(D4),List(GuessOption)) -> List(Record(function
--R            : D6,order: NonNegativeInteger)))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D7 has Join(OrderedSet,IntegralDomain) and D8: (D7 -> 
--R            D4) and D4 has RETRACT(SYMBOL) and D5 has RETRACT(SYMBOL) 
--R            and D4 has FIELD and D5 has GCDDOM and D6 has Join(
--R            FunctionSpace(Integer),IntegralDomain,RetractableTo(D7),
--R            RetractableTo(Symbol),RetractableTo(Integer),
--R            CombinatorialOpsCategory,PartialDifferentialRing(Symbol))
--R            with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Booleanand D9: (D4 -> D6)
--R   [13] (List(Fraction(Polynomial(Integer))),List(GuessOption)) -> List
--R            (Record(function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [14] List(Fraction(Polynomial(Integer))) -> List(Record(function: 
--R            Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [15] Symbol -> ((List(Fraction(Polynomial(Integer))),List(
--R            GuessOption)) -> List(Record(function: Expression(Integer),order
--R            : NonNegativeInteger)))
--R             from GuessPolynomial
--R             if Fraction(Polynomial(Integer)) has RETRACT(SYMBOL) and 
--R            Polynomial(Integer) has RETRACT(SYMBOL)
--R   [16] (List(Fraction(MyUnivariatePolynomial(D4,Integer))),List(
--R            GuessOption)) -> List(Record(function: MyExpression(D4,Integer),
--R            order: NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D4) if D4: SYMBOL
--R   [17] List(Fraction(MyUnivariatePolynomial(D3,Integer))) -> List(
--R            Record(function: MyExpression(D3,Integer),order: 
--R            NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R   [18] Symbol -> ((List(Fraction(MyUnivariatePolynomial(D3,Integer))),
--R            List(GuessOption)) -> List(Record(function: MyExpression(D3,
--R            Integer),order: NonNegativeInteger)))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R
--RExamples of guessPRec from GuessAlgebraicNumber
--R
--R
--RExamples of guessPRec from GuessFinite
--R
--R
--RExamples of guessPRec from GuessInteger
--R
--R
--RExamples of guessPRec from Guess
--R
--R
--RExamples of guessPRec from GuessPolynomial
--R
--R
--RExamples of guessPRec from GuessUnivariatePolynomial
--R
--E 1206

--S 1207 of 3320
)d op guessRat
--R 
--R
--RThere are 18 exposed functions called guessRat :
--R   [1] (List(AlgebraicNumber),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [2] List(AlgebraicNumber) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [3] Symbol -> ((List(AlgebraicNumber),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger)))
--R             from GuessAlgebraicNumber if AlgebraicNumber has RETRACT(
--R            SYMBOL)
--R   [4] (List(D4),List(GuessOption)) -> List(Record(function: Expression
--R            (Integer),order: NonNegativeInteger))
--R             from GuessFinite(D4)
--R             if D4 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [5] List(D3) -> List(Record(function: Expression(Integer),order: 
--R            NonNegativeInteger))
--R             from GuessFinite(D3)
--R             if D3 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [6] Symbol -> ((List(D3),List(GuessOption)) -> List(Record(function
--R            : Expression(Integer),order: NonNegativeInteger)))
--R             from GuessFinite(D3)
--R             if D3 has RETRACT(SYMBOL) and D3 has Join(
--R            FiniteFieldCategory,ConvertibleTo(Integer))
--R   [7] (List(Fraction(Integer)),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [8] List(Fraction(Integer)) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [9] Symbol -> ((List(Fraction(Integer)),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger)))
--R             from GuessInteger
--R             if Fraction(Integer) has RETRACT(SYMBOL) and Integer has 
--R            RETRACT(SYMBOL)
--R   [10] (List(D6),List(GuessOption)) -> List(Record(function: D8,order
--R            : NonNegativeInteger))
--R             from Guess(D6,D7,D8,D9,D10,D2)
--R             if D6 has FIELD and D2: (D6 -> D8) and D9 has Join(
--R            OrderedSet,IntegralDomain) and D10: (D9 -> D6) and D7 has 
--R            GCDDOM and D8 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D9),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [11] List(D4) -> List(Record(function: D6,order: NonNegativeInteger)
--R            )
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D4 has FIELD and D9: (D4 -> D6) and D7 has Join(
--R            OrderedSet,IntegralDomain) and D8: (D7 -> D4) and D5 has 
--R            GCDDOM and D6 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D7),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [12] Symbol -> ((List(D4),List(GuessOption)) -> List(Record(function
--R            : D6,order: NonNegativeInteger)))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D7 has Join(OrderedSet,IntegralDomain) and D8: (D7 -> 
--R            D4) and D4 has RETRACT(SYMBOL) and D5 has RETRACT(SYMBOL) 
--R            and D4 has FIELD and D5 has GCDDOM and D6 has Join(
--R            FunctionSpace(Integer),IntegralDomain,RetractableTo(D7),
--R            RetractableTo(Symbol),RetractableTo(Integer),
--R            CombinatorialOpsCategory,PartialDifferentialRing(Symbol))
--R            with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Booleanand D9: (D4 -> D6)
--R   [13] (List(Fraction(Polynomial(Integer))),List(GuessOption)) -> List
--R            (Record(function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [14] List(Fraction(Polynomial(Integer))) -> List(Record(function: 
--R            Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [15] Symbol -> ((List(Fraction(Polynomial(Integer))),List(
--R            GuessOption)) -> List(Record(function: Expression(Integer),order
--R            : NonNegativeInteger)))
--R             from GuessPolynomial
--R             if Fraction(Polynomial(Integer)) has RETRACT(SYMBOL) and 
--R            Polynomial(Integer) has RETRACT(SYMBOL)
--R   [16] (List(Fraction(MyUnivariatePolynomial(D4,Integer))),List(
--R            GuessOption)) -> List(Record(function: MyExpression(D4,Integer),
--R            order: NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D4) if D4: SYMBOL
--R   [17] List(Fraction(MyUnivariatePolynomial(D3,Integer))) -> List(
--R            Record(function: MyExpression(D3,Integer),order: 
--R            NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R   [18] Symbol -> ((List(Fraction(MyUnivariatePolynomial(D3,Integer))),
--R            List(GuessOption)) -> List(Record(function: MyExpression(D3,
--R            Integer),order: NonNegativeInteger)))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R
--RExamples of guessRat from GuessAlgebraicNumber
--R
--R
--RExamples of guessRat from GuessFinite
--R
--R
--RExamples of guessRat from GuessInteger
--R
--R
--RExamples of guessRat from Guess
--R
--R
--RExamples of guessRat from GuessPolynomial
--R
--R
--RExamples of guessRat from GuessUnivariatePolynomial
--R
--E 1207

--S 1208 of 3320
)d op guessRec
--R 
--R
--RThere are 18 exposed functions called guessRec :
--R   [1] List(AlgebraicNumber) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [2] (List(AlgebraicNumber),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessAlgebraicNumber
--R   [3] Symbol -> ((List(AlgebraicNumber),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger)))
--R             from GuessAlgebraicNumber if AlgebraicNumber has RETRACT(
--R            SYMBOL)
--R   [4] List(D3) -> List(Record(function: Expression(Integer),order: 
--R            NonNegativeInteger))
--R             from GuessFinite(D3)
--R             if D3 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [5] (List(D4),List(GuessOption)) -> List(Record(function: Expression
--R            (Integer),order: NonNegativeInteger))
--R             from GuessFinite(D4)
--R             if D4 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [6] Symbol -> ((List(D3),List(GuessOption)) -> List(Record(function
--R            : Expression(Integer),order: NonNegativeInteger)))
--R             from GuessFinite(D3)
--R             if D3 has RETRACT(SYMBOL) and D3 has Join(
--R            FiniteFieldCategory,ConvertibleTo(Integer))
--R   [7] List(Fraction(Integer)) -> List(Record(function: Expression(
--R            Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [8] (List(Fraction(Integer)),List(GuessOption)) -> List(Record(
--R            function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessInteger
--R   [9] Symbol -> ((List(Fraction(Integer)),List(GuessOption)) -> List(
--R            Record(function: Expression(Integer),order: NonNegativeInteger)))
--R             from GuessInteger
--R             if Fraction(Integer) has RETRACT(SYMBOL) and Integer has 
--R            RETRACT(SYMBOL)
--R   [10] List(D4) -> List(Record(function: D6,order: NonNegativeInteger)
--R            )
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D4 has FIELD and D9: (D4 -> D6) and D7 has Join(
--R            OrderedSet,IntegralDomain) and D8: (D7 -> D4) and D5 has 
--R            GCDDOM and D6 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D7),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [11] (List(D6),List(GuessOption)) -> List(Record(function: D8,order
--R            : NonNegativeInteger))
--R             from Guess(D6,D7,D8,D9,D10,D2)
--R             if D6 has FIELD and D2: (D6 -> D8) and D9 has Join(
--R            OrderedSet,IntegralDomain) and D10: (D9 -> D6) and D7 has 
--R            GCDDOM and D8 has Join(FunctionSpace(Integer),
--R            IntegralDomain,RetractableTo(D9),RetractableTo(Symbol),
--R            RetractableTo(Integer),CombinatorialOpsCategory,
--R            PartialDifferentialRing(Symbol))with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Boolean
--R   [12] Symbol -> ((List(D4),List(GuessOption)) -> List(Record(function
--R            : D6,order: NonNegativeInteger)))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D7 has Join(OrderedSet,IntegralDomain) and D8: (D7 -> 
--R            D4) and D4 has RETRACT(SYMBOL) and D5 has RETRACT(SYMBOL) 
--R            and D4 has FIELD and D5 has GCDDOM and D6 has Join(
--R            FunctionSpace(Integer),IntegralDomain,RetractableTo(D7),
--R            RetractableTo(Symbol),RetractableTo(Integer),
--R            CombinatorialOpsCategory,PartialDifferentialRing(Symbol))
--R            with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Booleanand D9: (D4 -> D6)
--R   [13] List(Fraction(Polynomial(Integer))) -> List(Record(function: 
--R            Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [14] (List(Fraction(Polynomial(Integer))),List(GuessOption)) -> List
--R            (Record(function: Expression(Integer),order: NonNegativeInteger))
--R             from GuessPolynomial
--R   [15] Symbol -> ((List(Fraction(Polynomial(Integer))),List(
--R            GuessOption)) -> List(Record(function: Expression(Integer),order
--R            : NonNegativeInteger)))
--R             from GuessPolynomial
--R             if Fraction(Polynomial(Integer)) has RETRACT(SYMBOL) and 
--R            Polynomial(Integer) has RETRACT(SYMBOL)
--R   [16] List(Fraction(MyUnivariatePolynomial(D3,Integer))) -> List(
--R            Record(function: MyExpression(D3,Integer),order: 
--R            NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R   [17] (List(Fraction(MyUnivariatePolynomial(D4,Integer))),List(
--R            GuessOption)) -> List(Record(function: MyExpression(D4,Integer),
--R            order: NonNegativeInteger))
--R             from GuessUnivariatePolynomial(D4) if D4: SYMBOL
--R   [18] Symbol -> ((List(Fraction(MyUnivariatePolynomial(D3,Integer))),
--R            List(GuessOption)) -> List(Record(function: MyExpression(D3,
--R            Integer),order: NonNegativeInteger)))
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R
--RExamples of guessRec from GuessAlgebraicNumber
--R
--R
--RExamples of guessRec from GuessFinite
--R
--R
--RExamples of guessRec from GuessInteger
--R
--R
--RExamples of guessRec from Guess
--R
--R
--RExamples of guessRec from GuessPolynomial
--R
--R
--RExamples of guessRec from GuessUnivariatePolynomial
--R
--E 1208

--S 1209 of 3320
)d op halfExtendedResultant1
--R 
--R
--RThere is one unexposed function called halfExtendedResultant1 :
--R   [1] (NewSparseUnivariatePolynomial(D2),NewSparseUnivariatePolynomial
--R            (D2)) -> Record(resultant: D2,coef1: 
--R            NewSparseUnivariatePolynomial(D2))
--R             from NewSparseUnivariatePolynomial(D2) if D2 has INTDOM 
--R            and D2 has RING
--R
--RExamples of halfExtendedResultant1 from NewSparseUnivariatePolynomial
--R
--E 1209

--S 1210 of 3320
)d op halfExtendedResultant2
--R 
--R
--RThere is one unexposed function called halfExtendedResultant2 :
--R   [1] (NewSparseUnivariatePolynomial(D2),NewSparseUnivariatePolynomial
--R            (D2)) -> Record(resultant: D2,coef2: 
--R            NewSparseUnivariatePolynomial(D2))
--R             from NewSparseUnivariatePolynomial(D2) if D2 has INTDOM 
--R            and D2 has RING
--R
--RExamples of halfExtendedResultant2 from NewSparseUnivariatePolynomial
--R
--E 1210

--S 1211 of 3320
)d op halfExtendedSubResultantGcd1
--R 
--R
--RThere is one exposed function called halfExtendedSubResultantGcd1 :
--R   [1] (D,D) -> Record(gcd: D,coef1: D) from D
--R             if D2 has INTDOM and D2 has RING and D3 has OAMONS and D4
--R             has ORDSET and D has RPOLCAT(D2,D3,D4)
--R
--RThere is one unexposed function called halfExtendedSubResultantGcd1 :
--R   [1] (NewSparseUnivariatePolynomial(D2),NewSparseUnivariatePolynomial
--R            (D2)) -> Record(gcd: NewSparseUnivariatePolynomial(D2),coef1: 
--R            NewSparseUnivariatePolynomial(D2))
--R             from NewSparseUnivariatePolynomial(D2) if D2 has INTDOM 
--R            and D2 has RING
--R
--RExamples of halfExtendedSubResultantGcd1 from NewSparseUnivariatePolynomial
--R
--R
--RExamples of halfExtendedSubResultantGcd1 from RecursivePolynomialCategory
--R
--E 1211

--S 1212 of 3320
)d op halfExtendedSubResultantGcd2
--R 
--R
--RThere is one exposed function called halfExtendedSubResultantGcd2 :
--R   [1] (D,D) -> Record(gcd: D,coef2: D) from D
--R             if D2 has INTDOM and D2 has RING and D3 has OAMONS and D4
--R             has ORDSET and D has RPOLCAT(D2,D3,D4)
--R
--RThere is one unexposed function called halfExtendedSubResultantGcd2 :
--R   [1] (NewSparseUnivariatePolynomial(D2),NewSparseUnivariatePolynomial
--R            (D2)) -> Record(gcd: NewSparseUnivariatePolynomial(D2),coef2: 
--R            NewSparseUnivariatePolynomial(D2))
--R             from NewSparseUnivariatePolynomial(D2) if D2 has INTDOM 
--R            and D2 has RING
--R
--RExamples of halfExtendedSubResultantGcd2 from NewSparseUnivariatePolynomial
--R
--R
--RExamples of halfExtendedSubResultantGcd2 from RecursivePolynomialCategory
--R
--E 1212

--S 1213 of 3320
)d op harmonic
--R 
--R
--RThere is one exposed function called harmonic :
--R   [1] Integer -> Fraction(Integer) from IntegerNumberTheoryFunctions
--R         
--R
--RExamples of harmonic from IntegerNumberTheoryFunctions
--R
--E 1213

--S 1214 of 3320
)d op has?
--R 
--R
--RThere is one exposed function called has? :
--R   [1] (BasicOperator,String) -> Boolean from BasicOperator
--R
--RExamples of has? from BasicOperator
--R
--E 1214

--S 1215 of 3320
)d op hasDimension?
--R 
--R
--RThere are 2 exposed functions called hasDimension? :
--R   [1] (Cell(D3),Symbol) -> Boolean from Cell(D3) if D3 has RCFIELD
--R   [2] SimpleCell(D2,D3) -> Boolean from SimpleCell(D2,D3)
--R             if D2 has RCFIELD and D3 has UPOLYC(D2)
--R
--RExamples of hasDimension? from Cell
--R
--R
--RExamples of hasDimension? from SimpleCell
--R
--E 1215

--S 1216 of 3320
)d op hash
--R 
--R
--RThere are 8 exposed functions called hash :
--R   [1] ArrayStack(D2) -> SingleInteger from ArrayStack(D2)
--R             if D2 has SETCAT and D2 has SETCAT
--R   [2] Dequeue(D2) -> SingleInteger from Dequeue(D2)
--R             if D2 has SETCAT and D2 has SETCAT
--R   [3] DoubleFloat -> Integer from DoubleFloat
--R   [4] Heap(D2) -> SingleInteger from Heap(D2) if D2 has SETCAT and D2
--R             has ORDSET
--R   [5] D -> D from D if D has INS
--R   [6] Queue(D2) -> SingleInteger from Queue(D2) if D2 has SETCAT and 
--R            D2 has SETCAT
--R   [7] D -> SingleInteger from D if D has SETCAT
--R   [8] Stack(D2) -> SingleInteger from Stack(D2) if D2 has SETCAT and 
--R            D2 has SETCAT
--R
--RThere is one unexposed function called hash :
--R   [1] IndexedString(D2) -> Integer from IndexedString(D2) if D2: INT
--R         
--R
--RExamples of hash from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rhash a
--R
--R
--RExamples of hash from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rhash a
--R
--R
--RExamples of hash from DoubleFloat
--R
--R
--RExamples of hash from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rhash a
--R
--R
--RExamples of hash from IntegerNumberSystem
--R
--R
--RExamples of hash from IndexedString
--R
--R
--RExamples of hash from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rhash a
--R
--R
--RExamples of hash from SetCategory
--R
--R
--RExamples of hash from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rhash a
--R
--E 1216

--S 1217 of 3320
)d op hasHi
--R 
--R
--RThere is one exposed function called hasHi :
--R   [1] UniversalSegment(D2) -> Boolean from UniversalSegment(D2) if D2
--R             has TYPE
--R
--RExamples of hasHi from UniversalSegment
--R
--E 1217

--S 1218 of 3320
)d op hasoln
--R 
--R
--RThere is one unexposed function called hasoln :
--R   [1] (List(D6),List(D6)) -> Record(sysok: Boolean,z0: List(D6),n0: 
--R            List(D6))
--R             from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D4
--R             has Join(OrderedSet,ConvertibleTo(Symbol)) and D5 has 
--R            OAMONS and D6 has POLYCAT(D3,D5,D4)
--R
--RExamples of hasoln from ParametricLinearEquations
--R
--E 1218

--S 1219 of 3320
)d op hasPredicate?
--R 
--R
--RThere is one unexposed function called hasPredicate? :
--R   [1] Pattern(D2) -> Boolean from Pattern(D2) if D2 has SETCAT
--R
--RExamples of hasPredicate? from Pattern
--R
--E 1219

--S 1220 of 3320
)d op hasSolution?
--R 
--R
--RThere are 2 exposed functions called hasSolution? :
--R   [1] (Matrix(D4),Vector(D4)) -> Boolean from 
--R            LinearSystemMatrixPackage1(D4)
--R             if D4 has FIELD
--R   [2] (D2,D3) -> Boolean from LinearSystemMatrixPackage(D4,D5,D3,D2)
--R             if D4 has FIELD and D5 has FiniteLinearAggregate(D4)with
--R                 shallowlyMutableand D3 has FiniteLinearAggregate(D4)
--R            with
--R                 shallowlyMutableand D2 has MATCAT(D4,D5,D3)
--R
--RExamples of hasSolution? from LinearSystemMatrixPackage1
--R
--R
--RExamples of hasSolution? from LinearSystemMatrixPackage
--R
--E 1220

--S 1221 of 3320
)d op hasTopPredicate?
--R 
--R
--RThere is one unexposed function called hasTopPredicate? :
--R   [1] Pattern(D2) -> Boolean from Pattern(D2) if D2 has SETCAT
--R
--RExamples of hasTopPredicate? from Pattern
--R
--E 1221

--S 1222 of 3320
)d op Hausdorff
--R 
--R
--RThere is one unexposed function called Hausdorff :
--R   [1] (D1,D1,NonNegativeInteger) -> D1 from XExponentialPackage(D3,D4,
--R            D1)
--R             if D3 has Join(Ring,Module(Fraction(Integer))) and D4 has 
--R            ORDSET and D1 has XPOLYC(D4,D3)
--R
--RExamples of Hausdorff from XExponentialPackage
--R
--E 1222

--S 1223 of 3320
)d op hclf
--R 
--R
--RThere are 2 unexposed functions called hclf :
--R   [1] (FreeMonoid(D1),FreeMonoid(D1)) -> FreeMonoid(D1) from 
--R            FreeMonoid(D1)
--R             if D1 has SETCAT
--R   [2] (OrderedFreeMonoid(D1),OrderedFreeMonoid(D1)) -> 
--R            OrderedFreeMonoid(D1)
--R             from OrderedFreeMonoid(D1) if D1 has ORDSET
--R
--RExamples of hclf from FreeMonoid
--R
--R
--RExamples of hclf from OrderedFreeMonoid
--R
--Rm1:=(x*y*z)$OFMONOID(Symbol) 
--Rm2:=(x*y)$OFMONOID(Symbol) 
--Rhclf(m1,m2)
--R
--E 1223

--S 1224 of 3320
)d op hconcat
--R 
--R
--RThere are 2 unexposed functions called hconcat :
--R   [1] List(OutputForm) -> OutputForm from OutputForm
--R   [2] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of hconcat from OutputForm
--R
--E 1224

--S 1225 of 3320
)d op hcrf
--R 
--R
--RThere are 2 unexposed functions called hcrf :
--R   [1] (FreeMonoid(D1),FreeMonoid(D1)) -> FreeMonoid(D1) from 
--R            FreeMonoid(D1)
--R             if D1 has SETCAT
--R   [2] (OrderedFreeMonoid(D1),OrderedFreeMonoid(D1)) -> 
--R            OrderedFreeMonoid(D1)
--R             from OrderedFreeMonoid(D1) if D1 has ORDSET
--R
--RExamples of hcrf from FreeMonoid
--R
--R
--RExamples of hcrf from OrderedFreeMonoid
--R
--Rm1:=(x*y*z)$OFMONOID(Symbol) 
--Rm2:=(y*z)$OFMONOID(Symbol) 
--Rhcrf(m1,m2)
--R
--E 1225

--S 1226 of 3320
)d op hdmpToDmp
--R 
--R
--RThere is one unexposed function called hdmpToDmp :
--R   [1] HomogeneousDistributedMultivariatePolynomial(D3,D4) -> 
--R            DistributedMultivariatePolynomial(D3,D4)
--R             from PolToPol(D3,D4) if D3: LIST(SYMBOL) and D4 has RING
--R         
--R
--RExamples of hdmpToDmp from PolToPol
--R
--E 1226

--S 1227 of 3320
)d op hdmpToP
--R 
--R
--RThere is one unexposed function called hdmpToP :
--R   [1] HomogeneousDistributedMultivariatePolynomial(D3,D4) -> 
--R            Polynomial(D4)
--R             from PolToPol(D3,D4) if D3: LIST(SYMBOL) and D4 has RING
--R         
--R
--RExamples of hdmpToP from PolToPol
--R
--E 1227

--S 1228 of 3320
)d op head
--R 
--R
--RThere are 3 exposed functions called head :
--R   [1] Divisor(D2) -> Record(gen: D2,exp: Integer) from Divisor(D2) if 
--R            D2 has SETCATD
--R   [2] D -> D from D if D has DLAGG(D1) and D1 has TYPE
--R   [3] D -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R
--RExamples of head from Divisor
--R
--R
--RExamples of head from DoublyLinkedAggregate
--R
--R
--RExamples of head from RecursivePolynomialCategory
--R
--E 1228

--S 1229 of 3320
)d op headReduce
--R 
--R
--RThere are 2 exposed functions called headReduce :
--R   [1] (D,D) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R   [2] (D1,D) -> D1 from D
--R             if D has TSETCAT(D2,D3,D4,D1) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D1 has RPOLCAT(D2,D3,D4)
--R            
--R
--RExamples of headReduce from RecursivePolynomialCategory
--R
--R
--RExamples of headReduce from TriangularSetCategory
--R
--E 1229

--S 1230 of 3320
)d op headReduced?
--R 
--R
--RThere are 4 exposed functions called headReduced? :
--R   [1] (D,List(D)) -> Boolean from D
--R             if D has RPOLCAT(D3,D4,D5) and D3 has RING and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [2] (D,D) -> Boolean from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [3] D -> Boolean from D
--R             if D has TSETCAT(D2,D3,D4,D5) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R   [4] (D2,D) -> Boolean from D
--R             if D has TSETCAT(D3,D4,D5,D2) and D3 has INTDOM and D4
--R             has OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R            
--R
--RExamples of headReduced? from RecursivePolynomialCategory
--R
--R
--RExamples of headReduced? from TriangularSetCategory
--R
--E 1230

--S 1231 of 3320
)d op headRemainder
--R 
--R
--RThere is one exposed function called headRemainder :
--R   [1] (D2,D) -> Record(num: D2,den: D3) from D
--R             if D has PSETCAT(D3,D4,D5,D2) and D3 has RING and D4 has 
--R            OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5) and 
--R            D3 has INTDOM
--R
--RExamples of headRemainder from PolynomialSetCategory
--R
--E 1231

--S 1232 of 3320 done
)d op heap
--R 
--R
--RThere is one exposed function called heap :
--R   [1] List(D2) -> Heap(D2) from Heap(D2) if D2 has ORDSET
--R
--RExamples of heap from Heap
--R
--Ri:Heap INT := heap [1,6,3,7,5,2,4]
--R
--E 1232

--S 1233 of 3320
)d op heapSort
--R 
--R
--RThere is one exposed function called heapSort :
--R   [1] (((D3,D3) -> Boolean),D1) -> D1 from FiniteLinearAggregateSort(
--R            D3,D1)
--R             if D3 has TYPE and D1 has FiniteLinearAggregate(D3)with
--R                 shallowlyMutable
--R
--RExamples of heapSort from FiniteLinearAggregateSort
--R
--E 1233

--S 1234 of 3320
)d op height
--R 
--R
--RThere are 3 exposed functions called height :
--R   [1] Dequeue(D2) -> NonNegativeInteger from Dequeue(D2) if D2 has 
--R            SETCAT
--R   [2] D -> NonNegativeInteger from D if D has DQAGG(D2) and D2 has 
--R            TYPE
--R   [3] D -> NonNegativeInteger from D if D has ES
--R
--RThere are 4 unexposed functions called height :
--R   [1] D2 -> D1 from GaloisGroupFactorizationUtilities(D3,D2,D1)
--R             if D3 has RING and D1 has Join(FloatingPointSystem,
--R            RetractableTo(D3),Field,TranscendentalFunctionCategory,
--R            ElementaryFunctionCategory) and D2 has UPOLYC(D3)
--R   [2] Kernel(D2) -> NonNegativeInteger from Kernel(D2) if D2 has 
--R            ORDSET
--R   [3]  -> Integer from OutputForm
--R   [4] OutputForm -> Integer from OutputForm
--R
--RExamples of height from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rheight a
--R
--R
--RExamples of height from DequeueAggregate
--R
--R
--RExamples of height from ExpressionSpace
--R
--R
--RExamples of height from GaloisGroupFactorizationUtilities
--R
--R
--RExamples of height from Kernel
--R
--R
--RExamples of height from OutputForm
--R
--E 1234

--S 1235 of 3320
)d op henselFact
--R 
--R
--RThere are 2 unexposed functions called henselFact :
--R   [1] (D2,Boolean) -> Record(contp: Integer,factors: List(Record(irr: 
--R            D2,pow: Integer)))
--R             from GaloisGroupFactorizer(D2) if D2 has UPOLYC(INT)
--R   [2] (D2,Boolean) -> Record(contp: Integer,factors: List(Record(irr: 
--R            D2,pow: Integer)))
--R             from UnivariateFactorize(D2) if D2 has UPOLYC(INT)
--R
--RExamples of henselFact from GaloisGroupFactorizer
--R
--R
--RExamples of henselFact from UnivariateFactorize
--R
--E 1235

--S 1236 of 3320
)d op HenselLift
--R 
--R
--RThere is one unexposed function called HenselLift :
--R   [1] (D2,List(D2),D4,PositiveInteger) -> Record(plist: List(D2),
--R            modulo: D4)
--R             from GeneralHenselPackage(D4,D2) if D4 has EUCDOM and D2
--R             has UPOLYC(D4)
--R
--RExamples of HenselLift from GeneralHenselPackage
--R
--E 1236

--S 1237 of 3320
)d op hermite
--R 
--R
--RThere is one exposed function called hermite :
--R   [1] D1 -> D1 from SmithNormalForm(D2,D3,D4,D1)
--R             if D2 has EUCDOM and D3 has FLAGG(D2) and D4 has FLAGG(D2)
--R            and D1 has MATCAT(D2,D3,D4)
--R
--RThere is one unexposed function called hermite :
--R   [1] Integer -> SparseUnivariatePolynomial(Integer)
--R             from PolynomialNumberTheoryFunctions
--R
--RExamples of hermite from PolynomialNumberTheoryFunctions
--R
--R
--RExamples of hermite from SmithNormalForm
--R
--E 1237

--S 1238 of 3320
)d op hermiteH
--R 
--R
--RThere is one exposed function called hermiteH :
--R   [1] (NonNegativeInteger,D1) -> D1 from OrthogonalPolynomialFunctions
--R            (D1)
--R             if D1 has COMRING
--R
--RExamples of hermiteH from OrthogonalPolynomialFunctions
--R
--E 1238

--S 1239 of 3320
)d op HermiteIntegrate
--R 
--R
--RThere are 2 unexposed functions called HermiteIntegrate :
--R   [1] (D2,(D5 -> D5)) -> Record(answer: D2,logpart: D2)
--R             from AlgebraicHermiteIntegration(D4,D5,D6,D2)
--R             if D5 has UPOLYC(D4) and D4 has FIELD and D6 has UPOLYC(
--R            FRAC(D5)) and D2 has FFCAT(D4,D5,D6)
--R   [2] (Fraction(D5),(D5 -> D5)) -> Record(answer: Fraction(D5),logpart
--R            : Fraction(D5),specpart: Fraction(D5),polypart: D5)
--R             from TranscendentalHermiteIntegration(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has FIELD
--R
--RExamples of HermiteIntegrate from AlgebraicHermiteIntegration
--R
--R
--RExamples of HermiteIntegrate from TranscendentalHermiteIntegration
--R
--E 1239

--S 1240 of 3320
)d op hessian
--R 
--R
--RThere is one exposed function called hessian :
--R   [1] (D2,D3) -> Matrix(D2) from MultiVariableCalculusFunctions(D4,D2,
--R            D5,D3)
--R             if D4 has SETCAT and D2 has PDRING(D4) and D5 has FLAGG(D2
--R            ) and D3 has FiniteLinearAggregate(D4)with
--R                 finiteAggregate
--R
--RExamples of hessian from MultiVariableCalculusFunctions
--R
--E 1240

--S 1241 of 3320
)d op hex
--R 
--R
--RThere is one exposed function called hex :
--R   [1] Fraction(Integer) -> HexadecimalExpansion from 
--R            HexadecimalExpansion
--R
--RExamples of hex from HexadecimalExpansion
--R
--E 1241

--S 1242 of 3320
)d op hexDigit
--R 
--R
--RThere is one exposed function called hexDigit :
--R   [1]  -> CharacterClass from CharacterClass
--R
--RExamples of hexDigit from CharacterClass
--R
--E 1242

--S 1243 of 3320 done
)d op hexDigit?
--R 
--R
--RThere is one exposed function called hexDigit? :
--R   [1] Character -> Boolean from Character
--R
--RExamples of hexDigit? from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[hexDigit? c for c in chars]
--R
--E 1243

--S 1244 of 3320
)d op hi
--R 
--R
--RThere is one exposed function called hi :
--R   [1] D -> D1 from D if D has SEGCAT(D1) and D1 has TYPE
--R
--RExamples of hi from SegmentCategory
--R
--E 1244

--S 1245 of 3320
)d op high
--R 
--R
--RThere is one exposed function called high :
--R   [1] D -> D1 from D if D has SEGCAT(D1) and D1 has TYPE
--R
--RExamples of high from SegmentCategory
--R
--E 1245

--S 1246 of 3320
)d op highCommonTerms
--R 
--R
--RThere is one exposed function called highCommonTerms :
--R   [1] (D,D) -> D from D
--R             if D has FAMONC(D1,D2) and D1 has SETCAT and D2 has CABMON
--R            and D2 has OAMON
--R
--RExamples of highCommonTerms from FreeAbelianMonoidCategory
--R
--E 1246

--S 1247 of 3320
)d op hitherPlane
--R 
--R
--RThere is one exposed function called hitherPlane :
--R   [1] (ThreeDimensionalViewport,Float) -> Void from 
--R            ThreeDimensionalViewport
--R
--RExamples of hitherPlane from ThreeDimensionalViewport
--R
--E 1247

--S 1248 of 3320
)d op hMonic
--R 
--R
--RThere is one unexposed function called hMonic :
--R   [1] D1 -> D1 from GroebnerInternalPackage(D2,D3,D4,D1)
--R             if D2 has GCDDOM and D3 has OAMONS and D4 has ORDSET and 
--R            D1 has POLYCAT(D2,D3,D4)
--R
--RExamples of hMonic from GroebnerInternalPackage
--R
--E 1248

--S 1249 of 3320 done
)d op hodgeStar
--R 
--R
--RThere is one unexposed function called hodgeStar :
--R   [1] (DeRhamComplex(D2,D3),SquareMatrix(#(D3),Expression(D2))) -> 
--R            DeRhamComplex(D2,D3)
--R             from DeRhamComplex(D2,D3)
--R             if D2 has Join(Ring,OrderedSet) and D3: LIST(SYMBOL)
--R
--RExamples of hodgeStar from DeRhamComplex
--R
--Rder := DeRhamComplex(Integer,[x,y,z]) 
--Rf:BOP:=operator('f) 
--Rg:BOP:=operator('g) 
--Rh:BOP:=operator('h) 
--Rsigma:der:=f(x,y,z)*dx + g(x,y,z)*dy + h(x,y,z)*dz 
--RG:SquareMatrix(3,Integer):=diagonalMatrix([1,1,1]) 
--RhodgeStar(sigma,G)
--R
--E 1249

--S 1250 of 3320
)d op homogeneous
--R 
--R
--RThere is one exposed function called homogeneous :
--R   [1] Union(PositiveInteger,Boolean) -> GuessOption from GuessOption
--R         
--R
--RThere is one unexposed function called homogeneous :
--R   [1] List(GuessOption) -> Union(PositiveInteger,Boolean)
--R             from GuessOptionFunctions0
--R
--RExamples of homogeneous from GuessOptionFunctions0
--R
--R
--RExamples of homogeneous from GuessOption
--R
--E 1250

--S 1251 of 3320
)d op homogeneous?
--R 
--R
--RThere are 2 unexposed functions called homogeneous? :
--R   [1] AntiSymm(D2,D3) -> Boolean from AntiSymm(D2,D3)
--R             if D2 has RING and D3: LIST(SYMBOL)
--R   [2] DeRhamComplex(D2,D3) -> Boolean from DeRhamComplex(D2,D3)
--R             if D2 has Join(Ring,OrderedSet) and D3: LIST(SYMBOL)
--R
--RExamples of homogeneous? from AntiSymm
--R
--R
--RExamples of homogeneous? from DeRhamComplex
--R
--Rder:=DERHAM(Integer,[x,y,z]) 
--R[dx,dy,dz]:=[generator(i)$der for i in 1..3] 
--Rf:BOP:=operator('f) 
--Rg:BOP:=operator('g) 
--Rh:BOP:=operator('h) 
--Rsigma:=f(x,y,z)*dx + g(x,y,z)*dy + h(x,y,z)*dz 
--Rhomogeneous? sigma 
--Ra:BOP:=operator('a) 
--Rb:BOP:=operator('b) 
--Rc:BOP:=operator('c) 
--Rtheta:=a(x,y,z)*dx*dy + b(x,y,z)*dx*dz + c(x,y,z)*dy*dz 
--Rhomogeneous? (sigma+theta)
--R
--E 1251

--S 1252 of 3320
)d op homogenize
--R 
--R
--RThere are 6 exposed functions called homogenize :
--R   [1] (D5,Integer) -> D5
--R             from GeneralPackageForAlgebraicFunctionField(D7,D8,D5,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D5 has POLYCAT(D7
--R            ,D9,OVAR(D8)) and D9 has DIRPCAT(#(D8),NNI) and D10 has 
--R            PRSPCAT(D7) and D11 has LOCPOWC(D7) and D12 has PLACESC(D7,
--R            D11) and D1 has DIVCAT(D12) and D2 has INFCLCT(D7,D8,D5,D9,
--R            D10,D11,D12,D1,D4) and D4 has BLMETCT and D3 has DSTRCAT(D2
--R            )
--R   [2] (DistributedMultivariatePolynomial(D4,D3),Integer) -> 
--R            DistributedMultivariatePolynomial(D4,D3)
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D3,D4
--R            ,D5)
--R             if D3 has FFIELDC and D4: LIST(SYMBOL) and D5 has BLMETCT
--R            
--R   [3] (DistributedMultivariatePolynomial(D4,D3),Integer) -> 
--R            DistributedMultivariatePolynomial(D4,D3)
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D5 has BLMETCT
--R         
--R   [4] (D1,Integer) -> D1 from PackageForPoly(D3,D1,D4,D5)
--R             if D3 has RING and D4 has DIRPCAT(D5,NNI) and D5: NNI and 
--R            D1 has FAMR(D3,D4)
--R   [5] D -> D from D if D has PRSPCAT(D1) and D1 has FIELD
--R   [6] (D,Integer) -> D from D if D has PRSPCAT(D2) and D2 has FIELD
--R         
--R
--RExamples of homogenize from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of homogenize from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of homogenize from PackageForAlgebraicFunctionField
--R
--R
--RExamples of homogenize from PackageForPoly
--R
--R
--RExamples of homogenize from ProjectiveSpaceCategory
--R
--E 1252

--S 1253 of 3320 done
)d op horizConcat
--R 
--R
--RThere are 2 exposed functions called horizConcat :
--R   [1] List(D1) -> D1 from MatrixManipulation(D3,D4,D5,D1)
--R             if D3 has FIELD and D1 has MATCAT(D3,D4,D5) and D4 has 
--R            FLAGG(D3) and D5 has FLAGG(D3)
--R   [2] (D,D) -> D from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1)
--R
--RExamples of horizConcat from MatrixManipulation
--R
--RA := matrix([[a]]) 
--RB := matrix([[b]]) 
--RC := matrix([[c]]) 
--RA12 := horizConcat([A,B,C])
--R
--R
--RExamples of horizConcat from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--RhorizConcat(m,m)
--R
--E 1253

--S 1254 of 3320
)d op horizJoin
--R 
--R
--RThere is one exposed function called horizJoin :
--R   [1] (SparseEchelonMatrix(D1,D2),SparseEchelonMatrix(D1,D2)) -> 
--R            SparseEchelonMatrix(D1,D2)
--R             from SparseEchelonMatrix(D1,D2) if D1 has ORDSET and D2
--R             has RING
--R
--RExamples of horizJoin from SparseEchelonMatrix
--R
--E 1254

--S 1255 of 3320
)d op horizSplit
--R 
--R
--RThere are 3 exposed functions called horizSplit :
--R   [1] (D2,PositiveInteger) -> List(D2) from MatrixManipulation(D4,D5,
--R            D6,D2)
--R             if D4 has FIELD and D5 has FLAGG(D4) and D6 has FLAGG(D4) 
--R            and D2 has MATCAT(D4,D5,D6)
--R   [2] (D2,List(PositiveInteger)) -> List(D2)
--R             from MatrixManipulation(D4,D5,D6,D2)
--R             if D4 has FIELD and D5 has FLAGG(D4) and D6 has FLAGG(D4) 
--R            and D2 has MATCAT(D4,D5,D6)
--R   [3] (SparseEchelonMatrix(D2,D3),D2) -> Record(Left: 
--R            SparseEchelonMatrix(D2,D3),Right: SparseEchelonMatrix(D2,D3))
--R             from SparseEchelonMatrix(D2,D3) if D2 has ORDSET and D3
--R             has RING
--R
--RExamples of horizSplit from MatrixManipulation
--R
--RE := matrix([[i,a,b,c],[a,a,b,c],[b,d,e,f],[c,g,h,i]]) 
--Rt1:= horizSplit(E, [2,2]) 
--Rt2:= horizSplit(E, [1,2,1])
--R
--RE := matrix([[i,a,b,c],[a,a,b,c],[b,d,e,f],[c,g,h,i]]) 
--Rt1:= horizSplit(E, 2)
--R
--R
--RExamples of horizSplit from SparseEchelonMatrix
--R
--E 1255

--S 1256 of 3320
)d op hspace
--R 
--R
--RThere is one unexposed function called hspace :
--R   [1] Integer -> OutputForm from OutputForm
--R
--RExamples of hspace from OutputForm
--R
--E 1256

--S 1257 of 3320
)d op htrigs
--R 
--R
--RThere is one exposed function called htrigs :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of htrigs from TranscendentalManipulations
--R
--E 1257

--S 1258 of 3320
)d op hue
--R 
--R
--RThere are 2 exposed functions called hue :
--R   [1] Color -> Integer from Color
--R   [2] Palette -> Color from Palette
--R
--RThere is one unexposed function called hue :
--R   [1] Point(D1) -> D1 from PointPackage(D1) if D1 has RING
--R
--RExamples of hue from Color
--R
--R
--RExamples of hue from Palette
--R
--R
--RExamples of hue from PointPackage
--R
--E 1258

--S 1259 of 3320
)d op hyperelliptic
--R 
--R
--RThere is one exposed function called hyperelliptic :
--R   [1]  -> Union(D1,"failed") from D
--R             if D has FFCAT(D2,D1,D3) and D2 has UFD and D3 has UPOLYC(
--R            FRAC(D1)) and D1 has UPOLYC(D2)
--R
--RThere is one unexposed function called hyperelliptic :
--R   [1]  -> Union(D1,"failed") from FunctionFieldCategory&(D2,D3,D1,D4)
--R             if D3 has UFD and D4 has UPOLYC(FRAC(D1)) and D1 has 
--R            UPOLYC(D3) and D2 has FFCAT(D3,D1,D4)
--R
--RExamples of hyperelliptic from FunctionFieldCategory&
--R
--R
--RExamples of hyperelliptic from FunctionFieldCategory
--R
--E 1259

--S 1260 of 3320
)d op hypergeometric0F1
--R 
--R
--RThere are 2 exposed functions called hypergeometric0F1 :
--R   [1] (DoubleFloat,DoubleFloat) -> DoubleFloat from 
--R            DoubleFloatSpecialFunctions
--R   [2] (Complex(DoubleFloat),Complex(DoubleFloat)) -> Complex(
--R            DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R
--RExamples of hypergeometric0F1 from DoubleFloatSpecialFunctions
--R
--E 1260

--S 1261 of 3320
)d op iCompose
--R 
--R
--RThere is one unexposed function called iCompose :
--R   [1] (InnerSparseUnivariatePowerSeries(D1),
--R            InnerSparseUnivariatePowerSeries(D1)) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1) if D1 has RING
--R         
--R
--RExamples of iCompose from InnerSparseUnivariatePowerSeries
--R
--E 1261

--S 1262 of 3320
)d op id
--R 
--R
--RThere is one exposed function called id :
--R   [1] D1 -> D1 from MappingPackage1(D1) if D1 has SETCAT
--R
--RExamples of id from MappingPackage1
--R
--E 1262

--S 1263 of 3320
)d op ideal
--R 
--R
--RThere are 2 exposed functions called ideal :
--R   [1] D -> FractionalIdeal(D3,Fraction(D3),D4,D5) from D
--R             if D has FDIVCAT(D2,D3,D4,D5) and D2 has FIELD and D3 has 
--R            UPOLYC(D2) and D4 has UPOLYC(FRAC(D3)) and D5 has FFCAT(D2,
--R            D3,D4)
--R   [2] List(D5) -> PolynomialIdeals(D2,D3,D4,D5)
--R             from PolynomialIdeals(D2,D3,D4,D5)
--R             if D5 has POLYCAT(D2,D3,D4) and D2 has FIELD and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RThere is one unexposed function called ideal :
--R   [1] Vector(D5) -> FractionalIdeal(D2,D3,D4,D5)
--R             from FractionalIdeal(D2,D3,D4,D5)
--R             if D5 has Join(FramedAlgebra(D3,D4),RetractableTo(D3)) and
--R            D3 has QFCAT(D2) and D4 has UPOLYC(D3) and D2 has EUCDOM
--R         
--R
--RExamples of ideal from FiniteDivisorCategory
--R
--R
--RExamples of ideal from FractionalIdeal
--R
--R
--RExamples of ideal from PolynomialIdeals
--R
--E 1263

--S 1264 of 3320
)d op idealiser
--R 
--R
--RThere are 2 unexposed functions called idealiser :
--R   [1] (Matrix(D2),Matrix(D2)) -> Matrix(D2) from IntegralBasisTools(D2
--R            ,D3,D4)
--R             if D2 has EuclideanDomainwith
--R               squareFree : % -> Factored(%)and D3 has UPOLYC(D2) 
--R            and D4 has FRAMALG(D2,D3)
--R   [2] (Matrix(D2),Matrix(D2),D2) -> Matrix(D2)
--R             from IntegralBasisTools(D2,D3,D4)
--R             if D2 has EuclideanDomainwith
--R               squareFree : % -> Factored(%)and D3 has UPOLYC(D2) 
--R            and D4 has FRAMALG(D2,D3)
--R
--RExamples of idealiser from IntegralBasisTools
--R
--E 1264

--S 1265 of 3320
)d op idealiserMatrix
--R 
--R
--RThere is one unexposed function called idealiserMatrix :
--R   [1] (Matrix(D2),Matrix(D2)) -> Matrix(D2) from IntegralBasisTools(D2
--R            ,D3,D4)
--R             if D2 has EuclideanDomainwith
--R               squareFree : % -> Factored(%)and D3 has UPOLYC(D2) 
--R            and D4 has FRAMALG(D2,D3)
--R
--RExamples of idealiserMatrix from IntegralBasisTools
--R
--E 1265

--S 1266 of 3320
)d op idealSimplify
--R 
--R
--RThere is one unexposed function called idealSimplify :
--R   [1] QuasiAlgebraicSet(D1,D2,D3,D4) -> QuasiAlgebraicSet(D1,D2,D3,D4)
--R             from QuasiAlgebraicSet(D1,D2,D3,D4)
--R             if D1 has GCDDOM and D2 has ORDSET and D3 has OAMONS and 
--R            D4 has POLYCAT(D1,D3,D2)
--R
--RExamples of idealSimplify from QuasiAlgebraicSet
--R
--E 1266

--S 1267 of 3320
)d op identification
--R 
--R
--RThere is one unexposed function called identification :
--R   [1] (LieExponentials(D2,D3,D4),LieExponentials(D2,D3,D4)) -> List(
--R            Equation(D3))
--R             from LieExponentials(D2,D3,D4)
--R             if D2 has ORDSET and D3 has Join(CommutativeRing,Module(
--R            Fraction(Integer))) and D4: PI
--R
--RExamples of identification from LieExponentials
--R
--E 1267

--S 1268 of 3320
)d op identity
--R 
--R
--RThere is one exposed function called identity :
--R   [1]  -> DenavitHartenbergMatrix(D1) from DenavitHartenbergMatrix(D1)
--R             if D1 has Join(Field,TranscendentalFunctionCategory)
--R
--RExamples of identity from DenavitHartenbergMatrix
--R
--E 1268

--S 1269 of 3320
)d op identityMatrix
--R 
--R
--RThere is one exposed function called identityMatrix :
--R   [1] NonNegativeInteger -> ThreeDimensionalMatrix(D2)
--R             from ThreeDimensionalMatrix(D2) if D2 has RING and D2 has 
--R            SETCAT
--R
--RExamples of identityMatrix from ThreeDimensionalMatrix
--R
--E 1269

--S 1270 of 3320
)d op identitySquareMatrix
--R 
--R
--RThere is one exposed function called identitySquareMatrix :
--R   [1] (Symbol,Polynomial(Integer)) -> FortranCode from 
--R            FortranCodePackage1
--R
--RExamples of identitySquareMatrix from FortranCodePackage1
--R
--E 1270

--S 1271 of 3320
)d op iExquo
--R 
--R
--RThere is one unexposed function called iExquo :
--R   [1] (InnerSparseUnivariatePowerSeries(D2),
--R            InnerSparseUnivariatePowerSeries(D2),Boolean) -> Union(
--R            InnerSparseUnivariatePowerSeries(D2),"failed")
--R             from InnerSparseUnivariatePowerSeries(D2) if D2 has RING
--R         
--R
--RExamples of iExquo from InnerSparseUnivariatePowerSeries
--R
--E 1271

--S 1272 of 3320
)d op iFTable
--R 
--R
--RThere is one exposed function called iFTable :
--R   [1] List(Record(key: Record(xinit: DoubleFloat,xend: DoubleFloat,fn
--R            : Vector(Expression(DoubleFloat)),yinit: List(DoubleFloat),
--R            intvals: List(DoubleFloat),g: Expression(DoubleFloat),abserr: 
--R            DoubleFloat,relerr: DoubleFloat),entry: Record(stiffness: Float,
--R            stability: Float,expense: Float,accuracy: Float,
--R            intermediateResults: Float))) -> ODEIntensityFunctionsTable
--R             from ODEIntensityFunctionsTable
--R
--RExamples of iFTable from ODEIntensityFunctionsTable
--R
--E 1272

--S 1273 of 3320
)d op ignore?
--R 
--R
--RThere is one unexposed function called ignore? :
--R   [1] String -> Boolean from DefiniteIntegrationTools(D3,D4)
--R             if D3 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D4 has Join(
--R            TranscendentalFunctionCategory,
--R            AlgebraicallyClosedFunctionSpace(D3))
--R
--RExamples of ignore? from DefiniteIntegrationTools
--R
--E 1273

--S 1274 of 3320
)d op iiabs   
--R 
--R
--RThere is one unexposed function called iiabs :
--R   [1] D1 -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of iiabs from FunctionalSpecialFunction
--R
--E 1274

--S 1275 of 3320
)d op iiacos
--R 
--R
--RThere is one unexposed function called iiacos :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iiacos from ElementaryFunction
--R
--E 1275

--S 1276 of 3320
)d op iiacosh
--R 
--R
--RThere is one unexposed function called iiacosh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iiacosh from ElementaryFunction
--R
--E 1276

--S 1277 of 3320
)d op iiacot
--R 
--R
--RThere is one unexposed function called iiacot :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iiacot from ElementaryFunction
--R
--E 1277

--S 1278 of 3320
)d op iiacoth
--R 
--R
--RThere is one unexposed function called iiacoth :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iiacoth from ElementaryFunction
--R
--E 1278

--S 1279 of 3320
)d op iiacsc
--R 
--R
--RThere is one unexposed function called iiacsc :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iiacsc from ElementaryFunction
--R
--E 1279

--S 1280 of 3320
)d op iiacsch
--R 
--R
--RThere is one unexposed function called iiacsch :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iiacsch from ElementaryFunction
--R
--E 1280

--S 1281 of 3320
)d op iiAiryAi 
--R 
--R
--RThere is one unexposed function called iiAiryAi :
--R   [1] D1 -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of iiAiryAi from FunctionalSpecialFunction
--R
--E 1281

--S 1282 of 3320
)d op iiAiryBi 
--R 
--R
--RThere is one unexposed function called iiAiryBi :
--R   [1] D1 -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of iiAiryBi from FunctionalSpecialFunction
--R
--E 1282

--S 1283 of 3320
)d op iiasec
--R 
--R
--RThere is one unexposed function called iiasec :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iiasec from ElementaryFunction
--R
--E 1283

--S 1284 of 3320
)d op iiasech
--R 
--R
--RThere is one unexposed function called iiasech :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iiasech from ElementaryFunction
--R
--E 1284

--S 1285 of 3320
)d op iiasin
--R 
--R
--RThere is one unexposed function called iiasin :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iiasin from ElementaryFunction
--R
--E 1285

--S 1286 of 3320
)d op iiasinh
--R 
--R
--RThere is one unexposed function called iiasinh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iiasinh from ElementaryFunction
--R
--E 1286

--S 1287 of 3320
)d op iiatan
--R 
--R
--RThere is one unexposed function called iiatan :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iiatan from ElementaryFunction
--R
--E 1287

--S 1288 of 3320
)d op iiatanh
--R 
--R
--RThere is one unexposed function called iiatanh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iiatanh from ElementaryFunction
--R
--E 1288

--S 1289 of 3320
)d op iiBesselI
--R 
--R
--RThere is one unexposed function called iiBesselI :
--R   [1] List(D1) -> D1 from FunctionalSpecialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of iiBesselI from FunctionalSpecialFunction
--R
--E 1289

--S 1290 of 3320
)d op iiBesselJ
--R 
--R
--RThere is one unexposed function called iiBesselJ :
--R   [1] List(D1) -> D1 from FunctionalSpecialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of iiBesselJ from FunctionalSpecialFunction
--R
--E 1290

--S 1291 of 3320
)d op iiBesselK
--R 
--R
--RThere is one unexposed function called iiBesselK :
--R   [1] List(D1) -> D1 from FunctionalSpecialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of iiBesselK from FunctionalSpecialFunction
--R
--E 1291

--S 1292 of 3320
)d op iiBesselY
--R 
--R
--RThere is one unexposed function called iiBesselY :
--R   [1] List(D1) -> D1 from FunctionalSpecialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of iiBesselY from FunctionalSpecialFunction
--R
--E 1292

--S 1293 of 3320
)d op iiBeta   
--R 
--R
--RThere is one unexposed function called iiBeta :
--R   [1] List(D1) -> D1 from FunctionalSpecialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of iiBeta from FunctionalSpecialFunction
--R
--E 1293

--S 1294 of 3320
)d op iibinom
--R 
--R
--RThere is one unexposed function called iibinom :
--R   [1] List(D1) -> D1 from CombinatorialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of iibinom from CombinatorialFunction
--R
--E 1294

--S 1295 of 3320
)d op iicos
--R 
--R
--RThere is one unexposed function called iicos :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iicos from ElementaryFunction
--R
--E 1295

--S 1296 of 3320
)d op iicosh
--R 
--R
--RThere is one unexposed function called iicosh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iicosh from ElementaryFunction
--R
--E 1296

--S 1297 of 3320
)d op iicot
--R 
--R
--RThere is one unexposed function called iicot :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iicot from ElementaryFunction
--R
--E 1297

--S 1298 of 3320
)d op iicoth
--R 
--R
--RThere is one unexposed function called iicoth :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iicoth from ElementaryFunction
--R
--E 1298

--S 1299 of 3320
)d op iicsc
--R 
--R
--RThere is one unexposed function called iicsc :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iicsc from ElementaryFunction
--R
--E 1299

--S 1300 of 3320
)d op iicsch
--R 
--R
--RThere is one unexposed function called iicsch :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iicsch from ElementaryFunction
--R
--E 1300

--S 1301 of 3320
)d op iidigamma
--R 
--R
--RThere is one unexposed function called iidigamma :
--R   [1] D1 -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of iidigamma from FunctionalSpecialFunction
--R
--E 1301

--S 1302 of 3320
)d op iidprod
--R 
--R
--RThere is one unexposed function called iidprod :
--R   [1] List(D1) -> D1 from CombinatorialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of iidprod from CombinatorialFunction
--R
--E 1302

--S 1303 of 3320
)d op iidsum
--R 
--R
--RThere is one unexposed function called iidsum :
--R   [1] List(D1) -> D1 from CombinatorialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of iidsum from CombinatorialFunction
--R
--E 1303

--S 1304 of 3320
)d op iiexp
--R 
--R
--RThere is one unexposed function called iiexp :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iiexp from ElementaryFunction
--R
--E 1304

--S 1305 of 3320
)d op iifact
--R 
--R
--RThere is one unexposed function called iifact :
--R   [1] D1 -> D1 from CombinatorialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of iifact from CombinatorialFunction
--R
--E 1305

--S 1306 of 3320
)d op iiGamma
--R 
--R
--RThere is one unexposed function called iiGamma :
--R   [1] D1 -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of iiGamma from FunctionalSpecialFunction
--R
--E 1306

--S 1307 of 3320
)d op iilog
--R 
--R
--RThere is one unexposed function called iilog :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iilog from ElementaryFunction
--R
--E 1307

--S 1308 of 3320
)d op iiperm
--R 
--R
--RThere is one unexposed function called iiperm :
--R   [1] List(D1) -> D1 from CombinatorialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of iiperm from CombinatorialFunction
--R
--E 1308

--S 1309 of 3320
)d op iipolygamma
--R 
--R
--RThere is one unexposed function called iipolygamma :
--R   [1] List(D1) -> D1 from FunctionalSpecialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of iipolygamma from FunctionalSpecialFunction
--R
--E 1309

--S 1310 of 3320
)d op iipow
--R 
--R
--RThere is one unexposed function called iipow :
--R   [1] List(D1) -> D1 from CombinatorialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of iipow from CombinatorialFunction
--R
--E 1310

--S 1311 of 3320
)d op iisec
--R 
--R
--RThere is one unexposed function called iisec :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iisec from ElementaryFunction
--R
--E 1311

--S 1312 of 3320
)d op iisech
--R 
--R
--RThere is one unexposed function called iisech :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iisech from ElementaryFunction
--R
--E 1312

--S 1313 of 3320
)d op iisin
--R 
--R
--RThere is one unexposed function called iisin :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iisin from ElementaryFunction
--R
--E 1313

--S 1314 of 3320
)d op iisinh
--R 
--R
--RThere is one unexposed function called iisinh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iisinh from ElementaryFunction
--R
--E 1314

--S 1315 of 3320
)d op iisqrt2
--R 
--R
--RThere is one unexposed function called iisqrt2 :
--R   [1]  -> D1 from ElementaryFunction(D2,D1)
--R             if D1 has Join(FunctionSpace(D2),RadicalCategory) and D2
--R             has Join(OrderedSet,IntegralDomain)
--R
--RExamples of iisqrt2 from ElementaryFunction
--R
--E 1315

--S 1316 of 3320
)d op iisqrt3
--R 
--R
--RThere is one unexposed function called iisqrt3 :
--R   [1]  -> D1 from ElementaryFunction(D2,D1)
--R             if D1 has Join(FunctionSpace(D2),RadicalCategory) and D2
--R             has Join(OrderedSet,IntegralDomain)
--R
--RExamples of iisqrt3 from ElementaryFunction
--R
--E 1316

--S 1317 of 3320
)d op iitan
--R 
--R
--RThere is one unexposed function called iitan :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iitan from ElementaryFunction
--R
--E 1317

--S 1318 of 3320
)d op iitanh
--R 
--R
--RThere is one unexposed function called iitanh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R
--RExamples of iitanh from ElementaryFunction
--R
--E 1318

--S 1319 of 3320
)d op imag
--R 
--R
--RThere are 3 exposed functions called imag :
--R   [1] D -> D1 from D if D has COMPCAT(D1) and D1 has COMRING
--R   [2] D2 -> Expression(D3) from ComplexTrigonometricManipulations(D3,
--R            D2)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer)) and D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(Complex(D3)))
--R            
--R   [3] D1 -> D1 from TrigonometricManipulations(D2,D1)
--R             if D2 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D1 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D2))
--R
--RExamples of imag from ComplexCategory
--R
--R
--RExamples of imag from ComplexTrigonometricManipulations
--R
--R
--RExamples of imag from TrigonometricManipulations
--R
--E 1319

--S 1320 of 3320
)d op imagE
--R 
--R
--RThere is one exposed function called imagE :
--R   [1] D -> D1 from D if D has OC(D1) and D1 has COMRING
--R
--RExamples of imagE from OctonionCategory
--R
--E 1320

--S 1321 of 3320
)d op imagi
--R 
--R
--RThere is one exposed function called imagi :
--R   [1] D -> D1 from D if D has OC(D1) and D1 has COMRING
--R
--RExamples of imagi from OctonionCategory
--R
--E 1321

--S 1322 of 3320
)d op imagI
--R 
--R
--RThere are 2 exposed functions called imagI :
--R   [1] D -> D1 from D if D has OC(D1) and D1 has COMRING
--R   [2] D -> D1 from D if D has QUATCAT(D1) and D1 has COMRING
--R
--RExamples of imagI from OctonionCategory
--R
--R
--RExamples of imagI from QuaternionCategory
--R
--E 1322

--S 1323 of 3320
)d op imaginary
--R 
--R
--RThere is one exposed function called imaginary :
--R   [1]  -> D from D if D has COMPCAT(D1) and D1 has COMRING
--R
--RExamples of imaginary from ComplexCategory
--R
--E 1323

--S 1324 of 3320
)d op imagj
--R 
--R
--RThere is one exposed function called imagj :
--R   [1] D -> D1 from D if D has OC(D1) and D1 has COMRING
--R
--RExamples of imagj from OctonionCategory
--R
--E 1324

--S 1325 of 3320
)d op imagJ
--R 
--R
--RThere are 2 exposed functions called imagJ :
--R   [1] D -> D1 from D if D has OC(D1) and D1 has COMRING
--R   [2] D -> D1 from D if D has QUATCAT(D1) and D1 has COMRING
--R
--RExamples of imagJ from OctonionCategory
--R
--R
--RExamples of imagJ from QuaternionCategory
--R
--E 1325

--S 1326 of 3320
)d op imagk
--R 
--R
--RThere is one exposed function called imagk :
--R   [1] D -> D1 from D if D has OC(D1) and D1 has COMRING
--R
--RExamples of imagk from OctonionCategory
--R
--E 1326

--S 1327 of 3320
)d op imagK
--R 
--R
--RThere are 2 exposed functions called imagK :
--R   [1] D -> D1 from D if D has OC(D1) and D1 has COMRING
--R   [2] D -> D1 from D if D has QUATCAT(D1) and D1 has COMRING
--R
--RExamples of imagK from OctonionCategory
--R
--R
--RExamples of imagK from QuaternionCategory
--R
--E 1327

--S 1328 of 3320
)d op implies
--R 
--R
--RThere is one exposed function called implies :
--R   [1] (Boolean,Boolean) -> Boolean from Boolean
--R
--RExamples of implies from Boolean
--R
--E 1328

--S 1329 of 3320
)d op in?
--R 
--R
--RThere are 3 exposed functions called in? :
--R   [1] DoubleFloat -> Boolean from ExpertSystemContinuityPackage1(D3,D4
--R            )
--R             if D3: DFLOAT and D4: DFLOAT
--R   [2] (DoubleFloat,Segment(OrderedCompletion(DoubleFloat))) -> Boolean
--R             from ExpertSystemToolsPackage
--R   [3] (PolynomialIdeals(D2,D3,D4,D5),PolynomialIdeals(D2,D3,D4,D5))
--R             -> Boolean
--R             from PolynomialIdeals(D2,D3,D4,D5)
--R             if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D5
--R             has POLYCAT(D2,D3,D4)
--R
--RExamples of in? from ExpertSystemContinuityPackage1
--R
--R
--RExamples of in? from ExpertSystemToolsPackage
--R
--R
--RExamples of in? from PolynomialIdeals
--R
--E 1329

--S 1330 of 3320
)d op inBetweenExcpDiv
--R 
--R
--RThere is one exposed function called inBetweenExcpDiv :
--R   [1] D5 -> D4 from DesingTreePackage(D6,D7,D8,D9,D10,D11,D1,D4,D2,D5,
--R            D3)
--R             if D6 has FIELD and D7: LIST(SYMBOL) and D8 has POLYCAT(D6
--R            ,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI) and D10 has 
--R            PRSPCAT(D6) and D11 has LOCPOWC(D6) and D1 has PLACESC(D6,
--R            D11) and D2 has INFCLCT(D6,D7,D8,D9,D10,D11,D1,D4,D3) and 
--R            D3 has BLMETCT and D4 has DIVCAT(D1) and D5 has DSTRCAT(D2)
--R            
--R
--RExamples of inBetweenExcpDiv from DesingTreePackage
--R
--E 1330

--S 1331 of 3320
)d op inc
--R 
--R
--RThere is one exposed function called inc :
--R   [1] D -> D from D if D has INS
--R
--RExamples of inc from IntegerNumberSystem
--R
--E 1331

--S 1332 of 3320
)d op inconsistent?
--R 
--R
--RThere are 2 unexposed functions called inconsistent? :
--R   [1] List(D6) -> Boolean from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D5,D4) and D3 has Join(
--R            EuclideanDomain,CharacteristicZero) and D4 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D5 has OAMONS
--R   [2] List(Polynomial(D3)) -> Boolean
--R             from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D4
--R             has Join(OrderedSet,ConvertibleTo(Symbol)) and D5 has 
--R            OAMONS and D6 has POLYCAT(D3,D5,D4)
--R
--RExamples of inconsistent? from ParametricLinearEquations
--R
--E 1332

--S 1333 of 3320
)d op incr
--R 
--R
--RThere are 2 exposed functions called incr :
--R   [1] D -> D from D if D has DIVCAT(D1) and D1 has SETCAT
--R   [2] D -> Integer from D if D has SEGCAT(D2) and D2 has TYPE
--R
--RExamples of incr from DivisorCategory
--R
--R
--RExamples of incr from SegmentCategory
--R
--E 1333

--S 1334 of 3320
)d op increase
--R 
--R
--RThere are 2 exposed functions called increase :
--R   [1] String -> Float from AttributeButtons
--R   [2] (String,String) -> Float from AttributeButtons
--R
--RExamples of increase from AttributeButtons
--R
--E 1334

--S 1335 of 3320
)d op increasePrecision
--R 
--R
--RThere is one exposed function called increasePrecision :
--R   [1] Integer -> PositiveInteger from D if D has arbitraryPrecision 
--R            and D has FPS
--R
--RExamples of increasePrecision from FloatingPointSystem
--R
--E 1335

--S 1336 of 3320
)d op increment
--R 
--R
--RThere is one unexposed function called increment :
--R   [1]  -> (D2 -> D2) from IncrementingMaps(D2)
--R             if D2 has Join(Monoid,AbelianSemiGroup)
--R
--RExamples of increment from IncrementingMaps
--R
--E 1336

--S 1337 of 3320
)d op incrementBy
--R 
--R
--RThere is one unexposed function called incrementBy :
--R   [1] D2 -> (D2 -> D2) from IncrementingMaps(D2)
--R             if D2 has Join(Monoid,AbelianSemiGroup)
--R
--RExamples of incrementBy from IncrementingMaps
--R
--E 1337

--S 1338 of 3320
)d op incrementKthElement
--R 
--R
--RThere is one unexposed function called incrementKthElement :
--R   [1] (SetOfMIntegersInOneToN(D2,D3),PositiveInteger) -> Union(
--R            SetOfMIntegersInOneToN(D2,D3),"failed")
--R             from SetOfMIntegersInOneToN(D2,D3) if D2: PI and D3: PI
--R         
--R
--RExamples of incrementKthElement from SetOfMIntegersInOneToN
--R
--E 1338

--S 1339 of 3320
)d op index
--R 
--R
--RThere is one exposed function called index :
--R   [1] PositiveInteger -> D from D if D has FINITE
--R
--RThere are 2 unexposed functions called index :
--R   [1] (PositiveInteger,PositiveInteger) -> Vector(D3)
--R             from InnerNormalBasisFieldFunctions(D3) if D3 has FFIELDC
--R            
--R   [2] ModuleMonomial(D1,D2,D3) -> D1 from ModuleMonomial(D1,D2,D3)
--R             if D1 has ORDSET and D2 has SETCAT and D3: ((Record(index
--R            : D1,exponent: D2),Record(index: D1,exponent: D2)) -> 
--R            Boolean)
--R
--RExamples of index from Finite
--R
--R
--RExamples of index from InnerNormalBasisFieldFunctions
--R
--R
--RExamples of index from ModuleMonomial
--R
--E 1339

--S 1340 of 3320
)d op index?
--R 
--R
--RThere is one exposed function called index? :
--R   [1] (D2,D) -> Boolean from D
--R             if D has IXAGG(D2,D3) and D2 has SETCAT and D3 has TYPE
--R         
--R
--RExamples of index? from IndexedAggregate
--R
--E 1340

--S 1341 of 3320
)d op indexName
--R 
--R
--RThere is one exposed function called indexName :
--R   [1] Symbol -> GuessOption from GuessOption
--R
--RThere is one unexposed function called indexName :
--R   [1] List(GuessOption) -> Symbol from GuessOptionFunctions0
--R
--RExamples of indexName from GuessOptionFunctions0
--R
--R
--RExamples of indexName from GuessOption
--R
--E 1341

--S 1342 of 3320
)d op indices
--R 
--R
--RThere is one exposed function called indices :
--R   [1] D -> List(D2) from D if D has IXAGG(D2,D3) and D2 has SETCAT and
--R            D3 has TYPE
--R
--RExamples of indices from IndexedAggregate
--R
--E 1342

--S 1343 of 3320
)d op indiceSubResultant
--R 
--R
--RThere is one unexposed function called indiceSubResultant :
--R   [1] (D1,D1,NonNegativeInteger) -> D1 from PseudoRemainderSequence(D3
--R            ,D1)
--R             if D3 has INTDOM and D1 has UPOLYC(D3)
--R
--RExamples of indiceSubResultant from PseudoRemainderSequence
--R
--E 1343

--S 1344 of 3320
)d op indiceSubResultantEuclidean
--R 
--R
--RThere is one unexposed function called indiceSubResultantEuclidean :
--R   [1] (D2,D2,NonNegativeInteger) -> Record(coef1: D2,coef2: D2,
--R            subResultant: D2)
--R             from PseudoRemainderSequence(D4,D2)
--R             if D4 has INTDOM and D2 has UPOLYC(D4)
--R
--RExamples of indiceSubResultantEuclidean from PseudoRemainderSequence
--R
--E 1344

--S 1345 of 3320
)d op indicialEquation
--R 
--R
--RThere are 2 unexposed functions called indicialEquation :
--R   [1] (D2,D3) -> D1 from PrimitiveRatDE(D3,D1,D2,D4)
--R             if D1 has UPOLYC(D3) and D3 has Join(Field,
--R            CharacteristicZero,RetractableTo(Fraction(Integer))) and D2
--R             has LODOCAT(D1) and D4 has LODOCAT(FRAC(D1))
--R   [2] (D2,D3) -> D1 from PrimitiveRatDE(D3,D1,D4,D2)
--R             if D1 has UPOLYC(D3) and D3 has Join(Field,
--R            CharacteristicZero,RetractableTo(Fraction(Integer))) and D4
--R             has LODOCAT(D1) and D2 has LODOCAT(FRAC(D1))
--R
--RExamples of indicialEquation from PrimitiveRatDE
--R
--E 1345

--S 1346 of 3320
)d op indicialEquationAtInfinity
--R 
--R
--RThere are 2 unexposed functions called indicialEquationAtInfinity :
--R   [1] LinearOrdinaryDifferentialOperator1(Fraction(D1)) -> D1
--R             from RationalLODE(D3,D1)
--R             if D1 has UPOLYC(D3) and D3 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer),RetractableTo(
--R            Fraction(Integer)))
--R   [2] LinearOrdinaryDifferentialOperator2(D1,Fraction(D1)) -> D1
--R             from RationalLODE(D3,D1)
--R             if D1 has UPOLYC(D3) and D3 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer),RetractableTo(
--R            Fraction(Integer)))
--R
--RExamples of indicialEquationAtInfinity from RationalLODE
--R
--E 1346

--S 1347 of 3320
)d op indicialEquations
--R 
--R
--RThere are 4 unexposed functions called indicialEquations :
--R   [1] D2 -> List(Record(center: D4,equation: D4))
--R             from PrimitiveRatDE(D3,D4,D2,D5)
--R             if D3 has Join(Field,CharacteristicZero,RetractableTo(
--R            Fraction(Integer))) and D4 has UPOLYC(D3) and D2 has 
--R            LODOCAT(D4) and D5 has LODOCAT(FRAC(D4))
--R   [2] (D2,D3) -> List(Record(center: D3,equation: D3))
--R             from PrimitiveRatDE(D4,D3,D2,D5)
--R             if D4 has Join(Field,CharacteristicZero,RetractableTo(
--R            Fraction(Integer))) and D3 has UPOLYC(D4) and D2 has 
--R            LODOCAT(D3) and D5 has LODOCAT(FRAC(D3))
--R   [3] D2 -> List(Record(center: D4,equation: D4))
--R             from PrimitiveRatDE(D3,D4,D5,D2)
--R             if D3 has Join(Field,CharacteristicZero,RetractableTo(
--R            Fraction(Integer))) and D4 has UPOLYC(D3) and D5 has 
--R            LODOCAT(D4) and D2 has LODOCAT(FRAC(D4))
--R   [4] (D2,D3) -> List(Record(center: D3,equation: D3))
--R             from PrimitiveRatDE(D4,D3,D5,D2)
--R             if D4 has Join(Field,CharacteristicZero,RetractableTo(
--R            Fraction(Integer))) and D3 has UPOLYC(D4) and D5 has 
--R            LODOCAT(D3) and D2 has LODOCAT(FRAC(D3))
--R
--RExamples of indicialEquations from PrimitiveRatDE
--R
--E 1347

--S 1348 of 3320
)d op inf
--R 
--R
--RThere is one exposed function called inf :
--R   [1] D -> D1 from D
--R             if D has INTCAT(D1) and D1 has Join(FloatingPointSystem,
--R            TranscendentalFunctionCategory)
--R
--RExamples of inf from IntervalCategory
--R
--E 1348

--S 1349 of 3320
)d op infClsPt?
--R 
--R
--RThere is one exposed function called infClsPt? :
--R   [1] D -> Boolean from D if D has BLMETCT
--R
--RExamples of infClsPt? from BlowUpMethodCategory
--R
--E 1349

--S 1350 of 3320
)d op infieldint
--R 
--R
--RThere is one unexposed function called infieldint :
--R   [1] Fraction(D3) -> Union(Fraction(D3),"failed")
--R             from RationalIntegration(D2,D3)
--R             if D3 has UPOLYC(D2) and D2 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer))
--R
--RExamples of infieldint from RationalIntegration
--R
--E 1350

--S 1351 of 3320
)d op infieldIntegrate
--R 
--R
--RThere is one exposed function called infieldIntegrate :
--R   [1] (Fraction(Polynomial(D3)),Symbol) -> Union(Fraction(Polynomial(
--R            D3)),"failed")
--R             from RationalFunctionIntegration(D3)
--R             if D3 has Join(IntegralDomain,RetractableTo(Integer),
--R            CharacteristicZero)
--R
--RExamples of infieldIntegrate from RationalFunctionIntegration
--R
--E 1351

--S 1352 of 3320
)d op infinite?
--R 
--R
--RThere are 2 exposed functions called infinite? :
--R   [1] OnePointCompletion(D2) -> Boolean from OnePointCompletion(D2)
--R             if D2 has SETCAT
--R   [2] OrderedCompletion(D2) -> Boolean from OrderedCompletion(D2) if 
--R            D2 has SETCAT
--R
--RExamples of infinite? from OnePointCompletion
--R
--R
--RExamples of infinite? from OrderedCompletion
--R
--E 1352

--S 1353 of 3320
)d op infiniteProduct
--R 
--R
--RThere are 3 exposed functions called infiniteProduct :
--R   [1] D1 -> D1 from InfiniteProductCharacteristicZero(D2,D1)
--R             if D2 has Join(IntegralDomain,CharacteristicZero) and D1
--R             has UTSCAT(D2)
--R   [2] D1 -> D1 from InfiniteProductFiniteField(D2,D3,D4,D1)
--R             if D2 has Join(Field,Finite,ConvertibleTo(Integer)) and D3
--R             has UPOLYC(D2) and D4 has MONOGEN(D2,D3) and D1 has UTSCAT
--R            (D4)
--R   [3] D1 -> D1 from InfiniteProductPrimeField(D2,D1)
--R             if D2 has Join(Field,Finite,ConvertibleTo(Integer)) and D1
--R             has UTSCAT(D2)
--R
--RThere is one unexposed function called infiniteProduct :
--R   [1] Stream(D2) -> Stream(D2) from StreamInfiniteProduct(D2)
--R             if D2 has Join(IntegralDomain,CharacteristicZero)
--R
--RExamples of infiniteProduct from InfiniteProductCharacteristicZero
--R
--R
--RExamples of infiniteProduct from InfiniteProductFiniteField
--R
--R
--RExamples of infiniteProduct from InfiniteProductPrimeField
--R
--R
--RExamples of infiniteProduct from StreamInfiniteProduct
--R
--E 1353

--S 1354 of 3320
)d op infinity
--R 
--R
--RThere are 2 exposed functions called infinity :
--R   [1]  -> OnePointCompletion(Integer) from Infinity
--R   [2]  -> OnePointCompletion(D1) from OnePointCompletion(D1) if D1
--R             has SETCAT
--R
--RExamples of infinity from Infinity
--R
--R
--RExamples of infinity from OnePointCompletion
--R
--E 1354

--S 1355 of 3320
)d op infinityNorm
--R 
--R
--RThere is one unexposed function called infinityNorm :
--R   [1] D2 -> D1 from GaloisGroupFactorizationUtilities(D3,D2,D1)
--R             if D3 has RING and D1 has Join(FloatingPointSystem,
--R            RetractableTo(D3),Field,TranscendentalFunctionCategory,
--R            ElementaryFunctionCategory) and D2 has UPOLYC(D3)
--R
--RExamples of infinityNorm from GaloisGroupFactorizationUtilities
--R
--E 1355

--S 1356 of 3320
)d op infix
--R 
--R
--RThere are 2 unexposed functions called infix :
--R   [1] (OutputForm,OutputForm,OutputForm) -> OutputForm from OutputForm
--R            
--R   [2] (OutputForm,List(OutputForm)) -> OutputForm from OutputForm
--R
--RExamples of infix from OutputForm
--R
--E 1356

--S 1357 of 3320
)d op infix?
--R 
--R
--RThere is one unexposed function called infix? :
--R   [1] OutputForm -> Boolean from OutputForm
--R
--RExamples of infix? from OutputForm
--R
--E 1357

--S 1358 of 3320
)d op infLex?
--R 
--R
--RThere is one unexposed function called infLex? :
--R   [1] (SplittingNode(D4,D5),SplittingNode(D4,D5),((D4,D4) -> Boolean),
--R            ((D5,D5) -> Boolean)) -> Boolean
--R             from SplittingNode(D4,D5)
--R             if D4 has Join(SetCategory,Aggregate) and D5 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of infLex? from SplittingNode
--R
--E 1358

--S 1359 of 3320
)d op infRittWu?
--R 
--R
--RThere are 4 exposed functions called infRittWu? :
--R   [1] (List(D6),List(D6)) -> Boolean from QuasiComponentPackage(D3,D4,
--R            D5,D6,D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [2] (D,D) -> Boolean from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [3] (List(D6),List(D6)) -> Boolean
--R             from SquareFreeQuasiComponentPackage(D3,D4,D5,D6,D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [4] (D,D) -> Boolean from D
--R             if D has TSETCAT(D2,D3,D4,D5) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R
--RExamples of infRittWu? from QuasiComponentPackage
--R
--R
--RExamples of infRittWu? from RecursivePolynomialCategory
--R
--R
--RExamples of infRittWu? from SquareFreeQuasiComponentPackage
--R
--R
--RExamples of infRittWu? from TriangularSetCategory
--R
--E 1359

--S 1360 of 3320
)d op infRittWu?
--R 
--R
--RThere are 4 exposed functions called infRittWu? :
--R   [1] (List(D6),List(D6)) -> Boolean from QuasiComponentPackage(D3,D4,
--R            D5,D6,D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [2] (D,D) -> Boolean from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [3] (List(D6),List(D6)) -> Boolean
--R             from SquareFreeQuasiComponentPackage(D3,D4,D5,D6,D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [4] (D,D) -> Boolean from D
--R             if D has TSETCAT(D2,D3,D4,D5) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R
--RExamples of infRittWu? from QuasiComponentPackage
--R
--R
--RExamples of infRittWu? from RecursivePolynomialCategory
--R
--R
--RExamples of infRittWu? from SquareFreeQuasiComponentPackage
--R
--R
--RExamples of infRittWu? from TriangularSetCategory
--R
--E 1360

--S 1361 of 3320
)d op inGroundField?
--R 
--R
--RThere is one exposed function called inGroundField? :
--R   [1] D -> Boolean from D if D has XF(D2) and D2 has FIELD
--R
--RExamples of inGroundField? from ExtensionField
--R
--E 1361

--S 1362 of 3320
)d op inHallBasis?
--R 
--R
--RThere is one exposed function called inHallBasis? :
--R   [1] (Integer,Integer,Integer,Integer) -> Boolean from HallBasis
--R
--RExamples of inHallBasis? from HallBasis
--R
--E 1362

--S 1363 of 3320
)d op init
--R 
--R
--RThere are 2 exposed functions called init :
--R   [1] D -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R   [2]  -> D from D if D has STEP
--R
--RExamples of init from RecursivePolynomialCategory
--R
--R
--RExamples of init from StepThrough
--R
--E 1363

--S 1364 of 3320
)d op initial
--R 
--R
--RThere is one exposed function called initial :
--R   [1] D -> D from D
--R             if D has DPOLCAT(D1,D2,D3,D4) and D1 has RING and D2 has 
--R            ORDSET and D3 has DVARCAT(D2) and D4 has OAMONS
--R
--RExamples of initial from DifferentialPolynomialCategory
--R
--E 1364

--S 1365 of 3320
)d op initializeGroupForWordProblem
--R 
--R
--RThere are 2 exposed functions called initializeGroupForWordProblem :
--R   [1] (PermutationGroup(D3),Integer,Integer) -> Void from 
--R            PermutationGroup(D3)
--R             if D3 has SETCAT
--R   [2] PermutationGroup(D2) -> Void from PermutationGroup(D2) if D2
--R             has SETCAT
--R
--RExamples of initializeGroupForWordProblem from PermutationGroup
--R
--E 1365

--S 1366 of 3320
)d op initializeParamOfPlaces
--R 
--R
--RThere are 2 exposed functions called initializeParamOfPlaces :
--R   [1] D6 -> Void from DesingTreePackage(D7,D8,D9,D10,D11,D12,D1,D2,D3,
--R            D6,D4)
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D9 has POLYCAT(D7
--R            ,D10,OVAR(D8)) and D10 has DIRPCAT(#(D8),NNI) and D11 has 
--R            PRSPCAT(D7) and D12 has LOCPOWC(D7) and D1 has PLACESC(D7,
--R            D12) and D2 has DIVCAT(D1) and D3 has INFCLCT(D7,D8,D9,D10,
--R            D11,D12,D1,D2,D4) and D4 has BLMETCT and D6 has DSTRCAT(D3)
--R            
--R   [2] (D7,List(D11)) -> Void
--R             from DesingTreePackage(D9,D10,D11,D12,D13,D1,D2,D3,D4,D7,
--R            D5)
--R             if D11 has POLYCAT(D9,D12,OVAR(D10)) and D12 has DIRPCAT(#
--R            (D10),NNI) and D9 has FIELD and D10: LIST(SYMBOL) and D13
--R             has PRSPCAT(D9) and D1 has LOCPOWC(D9) and D2 has PLACESC(
--R            D9,D1) and D3 has DIVCAT(D2) and D4 has INFCLCT(D9,D10,D11,
--R            D12,D13,D1,D2,D3,D5) and D5 has BLMETCT and D7 has DSTRCAT(
--R            D4)
--R
--RExamples of initializeParamOfPlaces from DesingTreePackage
--R
--E 1366

--S 1367 of 3320
)d op initiallyReduce
--R 
--R
--RThere are 2 exposed functions called initiallyReduce :
--R   [1] (D,D) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R   [2] (D1,D) -> D1 from D
--R             if D has TSETCAT(D2,D3,D4,D1) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D1 has RPOLCAT(D2,D3,D4)
--R            
--R
--RExamples of initiallyReduce from RecursivePolynomialCategory
--R
--R
--RExamples of initiallyReduce from TriangularSetCategory
--R
--E 1367

--S 1368 of 3320
)d op initiallyReduced?
--R 
--R
--RThere are 4 exposed functions called initiallyReduced? :
--R   [1] (D,List(D)) -> Boolean from D
--R             if D has RPOLCAT(D3,D4,D5) and D3 has RING and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [2] (D,D) -> Boolean from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [3] D -> Boolean from D
--R             if D has TSETCAT(D2,D3,D4,D5) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R   [4] (D2,D) -> Boolean from D
--R             if D has TSETCAT(D3,D4,D5,D2) and D3 has INTDOM and D4
--R             has OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R            
--R
--RExamples of initiallyReduced? from RecursivePolynomialCategory
--R
--R
--RExamples of initiallyReduced? from TriangularSetCategory
--R
--E 1368

--S 1369 of 3320
)d op initiallyReduced?
--R 
--R
--RThere are 4 exposed functions called initiallyReduced? :
--R   [1] (D,List(D)) -> Boolean from D
--R             if D has RPOLCAT(D3,D4,D5) and D3 has RING and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [2] (D,D) -> Boolean from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [3] D -> Boolean from D
--R             if D has TSETCAT(D2,D3,D4,D5) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R   [4] (D2,D) -> Boolean from D
--R             if D has TSETCAT(D3,D4,D5,D2) and D3 has INTDOM and D4
--R             has OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R            
--R
--RExamples of initiallyReduced? from RecursivePolynomialCategory
--R
--R
--RExamples of initiallyReduced? from TriangularSetCategory
--R
--E 1369

--S 1370 of 3320
)d op initials
--R 
--R
--RThere is one exposed function called initials :
--R   [1] D -> List(D5) from D
--R             if D has TSETCAT(D2,D3,D4,D5) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R
--RExamples of initials from TriangularSetCategory
--R
--E 1370

--S 1371 of 3320
)d op initParLocLeaves
--R 
--R
--RThere is one exposed function called initParLocLeaves :
--R   [1] D6 -> Void from DesingTreePackage(D7,D8,D9,D10,D11,D12,D1,D2,D3,
--R            D6,D4)
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D9 has POLYCAT(D7
--R            ,D10,OVAR(D8)) and D10 has DIRPCAT(#(D8),NNI) and D11 has 
--R            PRSPCAT(D7) and D12 has LOCPOWC(D7) and D1 has PLACESC(D7,
--R            D12) and D2 has DIVCAT(D1) and D3 has INFCLCT(D7,D8,D9,D10,
--R            D11,D12,D1,D2,D4) and D4 has BLMETCT and D6 has DSTRCAT(D3)
--R            
--R
--RExamples of initParLocLeaves from DesingTreePackage
--R
--E 1371

--S 1372 of 3320
)d op initTable!
--R 
--R
--RThere is one unexposed function called initTable! :
--R   [1]  -> Void from TabulatedComputationPackage(D2,D3)
--R             if D2 has SETCAT and D3 has SETCAT
--R
--RExamples of initTable! from TabulatedComputationPackage
--R
--E 1372

--S 1373 of 3320
)d op innerint
--R 
--R
--RThere is one exposed function called innerint :
--R   [1] (D2,Symbol,OrderedCompletion(D2),OrderedCompletion(D2),Boolean)
--R             -> Union(f1: OrderedCompletion(D2),f2: List(OrderedCompletion(D2
--R            )),fail: failed,pole: potentialPole)
--R             from ElementaryFunctionDefiniteIntegration(D6,D2)
--R             if D6 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory,
--R            AlgebraicallyClosedFunctionSpace(D6))
--R
--RExamples of innerint from ElementaryFunctionDefiniteIntegration
--R
--E 1373

--S 1374 of 3320
)d op input
--R 
--R
--RThere are 2 exposed functions called input :
--R   [1] BasicOperator -> Union((List(InputForm) -> InputForm),"failed")
--R             from BasicOperator
--R   [2] (BasicOperator,(List(InputForm) -> InputForm)) -> BasicOperator
--R             from BasicOperator
--R
--RExamples of input from BasicOperator
--R
--E 1374

--S 1375 of 3320
)d op inR?
--R 
--R
--RThere is one unexposed function called inR? :
--R   [1] Pattern(D2) -> Boolean from Pattern(D2) if D2 has SETCAT
--R
--RExamples of inR? from Pattern
--R
--E 1375

--S 1376 of 3320
)d op inRadical?
--R 
--R
--RThere is one exposed function called inRadical? :
--R   [1] (D2,PolynomialIdeals(D3,D4,D5,D2)) -> Boolean
--R             from PolynomialIdeals(D3,D4,D5,D2)
--R             if D3 has FIELD and D4 has OAMONS and D5 has ORDSET and D2
--R             has POLYCAT(D3,D4,D5)
--R
--RExamples of inRadical? from PolynomialIdeals
--R
--E 1376

--S 1377 of 3320
)d op inrootof
--R 
--R
--RThere is one unexposed function called inrootof :
--R   [1] (SparseUnivariatePolynomial(D1),D1) -> D1 from AlgebraicFunction
--R            (D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of inrootof from AlgebraicFunction
--R
--E 1377

--S 1378 of 3320
)d op insert
--R 
--R
--RThere are 2 exposed functions called insert :
--R   [1] (D,D,Integer) -> D from D if D has LNAGG(D2) and D2 has TYPE
--R   [2] (D1,D,Integer) -> D from D if D has LNAGG(D1) and D1 has TYPE
--R         
--R
--RExamples of insert from LinearAggregate
--R
--E 1378

--S 1379 of 3320
)d op insert!
--R 
--R
--RThere are 13 exposed functions called insert! :
--R   [1] (D1,ArrayStack(D1)) -> ArrayStack(D1) from ArrayStack(D1) if D1
--R             has SETCAT
--R   [2] (D1,D) -> D from D if D has BGAGG(D1) and D1 has TYPE
--R   [3] (D1,BinarySearchTree(D1)) -> BinarySearchTree(D1)
--R             from BinarySearchTree(D1) if D1 has ORDSET
--R   [4] (D1,BinaryTournament(D1)) -> BinaryTournament(D1)
--R             from BinaryTournament(D1) if D1 has ORDSET
--R   [5] (D1,Dequeue(D1)) -> Dequeue(D1) from Dequeue(D1) if D1 has 
--R            SETCAT
--R   [6] (D,D,Integer) -> D from D if D has ELAGG(D2) and D2 has TYPE
--R   [7] (D1,D,Integer) -> D from D if D has ELAGG(D1) and D1 has TYPE
--R         
--R   [8] (D1,Heap(D1)) -> Heap(D1) from Heap(D1) if D1 has ORDSET
--R   [9] Record(key: Record(var: Symbol,fn: Expression(DoubleFloat),range
--R            : Segment(OrderedCompletion(DoubleFloat)),abserr: DoubleFloat,
--R            relerr: DoubleFloat),entry: Record(endPointContinuity: Union(
--R            continuous: Continuous at the end points,lowerSingular: 
--R            There is a singularity at the lower end point,upperSingular: 
--R            There is a singularity at the upper end point,bothSingular: 
--R            There are singularities at both end points,notEvaluated: 
--R            End point continuity not yet evaluated),singularitiesStream: 
--R            Union(str: Stream(DoubleFloat),notEvaluated: 
--R            Internal singularities not yet evaluated),range: Union(finite: 
--R            The range is finite,lowerInfinite: 
--R            The bottom of range is infinite,upperInfinite: 
--R            The top of range is infinite,bothInfinite: 
--R            Both top and bottom points are infinite,notEvaluated: 
--R            Range not yet evaluated))) -> IntegrationFunctionsTable
--R             from IntegrationFunctionsTable
--R   [10] (D1,D,NonNegativeInteger) -> D from D if D has MDAGG(D1) and D1
--R             has SETCAT
--R   [11] Record(key: Record(xinit: DoubleFloat,xend: DoubleFloat,fn: 
--R            Vector(Expression(DoubleFloat)),yinit: List(DoubleFloat),intvals
--R            : List(DoubleFloat),g: Expression(DoubleFloat),abserr: 
--R            DoubleFloat,relerr: DoubleFloat),entry: Record(stiffness: Float,
--R            stability: Float,expense: Float,accuracy: Float,
--R            intermediateResults: Float)) -> ODEIntensityFunctionsTable
--R             from ODEIntensityFunctionsTable
--R   [12] (D1,Queue(D1)) -> Queue(D1) from Queue(D1) if D1 has SETCAT
--R   [13] (D1,Stack(D1)) -> Stack(D1) from Stack(D1) if D1 has SETCAT
--R
--RThere is one unexposed function called insert! :
--R   [1] (D2,D3) -> Void from TabulatedComputationPackage(D2,D3)
--R             if D2 has SETCAT and D3 has SETCAT
--R
--RExamples of insert! from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rinsert!(8,a) 
--Ra
--R
--R
--RExamples of insert! from BagAggregate
--R
--R
--RExamples of insert! from BinarySearchTree
--R
--Rt1:=binarySearchTree [1,2,3,4] 
--Rinsert!(5,t1)
--R
--R
--RExamples of insert! from BinaryTournament
--R
--Rt1:=binaryTournament [1,2,3,4] 
--Rinsert!(5,t1) 
--Rt1
--R
--R
--RExamples of insert! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rinsert! (8,a) 
--Ra
--R
--R
--RExamples of insert! from ExtensibleLinearAggregate
--R
--R
--RExamples of insert! from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rinsert!(8,a) 
--Ra
--R
--R
--RExamples of insert! from IntegrationFunctionsTable
--R
--R
--RExamples of insert! from MultiDictionary
--R
--R
--RExamples of insert! from ODEIntensityFunctionsTable
--R
--R
--RExamples of insert! from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rinsert! (8,a) 
--Ra
--R
--R
--RExamples of insert! from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rinsert!(8,a) 
--Ra
--R
--R
--RExamples of insert! from TabulatedComputationPackage
--R
--E 1379

--S 1380 of 3320
)d op insertBottom!
--R 
--R
--RThere are 2 exposed functions called insertBottom! :
--R   [1] (D1,Dequeue(D1)) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [2] (D1,D) -> D1 from D if D has DQAGG(D1) and D1 has TYPE
--R
--RExamples of insertBottom! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--RinsertBottom! a 
--Ra
--R
--R
--RExamples of insertBottom! from DequeueAggregate
--R
--E 1380

--S 1381 of 3320
)d op insertionSort!
--R 
--R
--RThere are 2 unexposed functions called insertionSort! :
--R   [1] (D1,((D3,D3) -> Boolean)) -> D1 from SortPackage(D3,D1)
--R             if D3 has TYPE and D1 has IndexedAggregate(Integer,D3)with
--R                 finiteAggregate
--R                 shallowlyMutable
--R   [2] D1 -> D1 from SortPackage(D2,D1)
--R             if D2 has ORDSET and D2 has TYPE and D1 has 
--R            IndexedAggregate(Integer,D2)with
--R                 finiteAggregate
--R                 shallowlyMutable
--R
--RExamples of insertionSort! from SortPackage
--R
--E 1381

--S 1382 of 3320
)d op insertMatch
--R 
--R
--RThere is one unexposed function called insertMatch :
--R   [1] (Pattern(D3),D2,PatternMatchResult(D3,D2)) -> PatternMatchResult
--R            (D3,D2)
--R             from PatternMatchResult(D3,D2) if D3 has SETCAT and D2
--R             has SETCAT
--R
--RExamples of insertMatch from PatternMatchResult
--R
--E 1382

--S 1383 of 3320 done
)d op insertRoot!
--R 
--R
--RThere is one exposed function called insertRoot! :
--R   [1] (D1,BinarySearchTree(D1)) -> BinarySearchTree(D1)
--R             from BinarySearchTree(D1) if D1 has ORDSET
--R
--RExamples of insertRoot! from BinarySearchTree
--R
--Rt1:=binarySearchTree [1,2,3,4] 
--RinsertRoot!(5,t1)
--R
--E 1383

--S 1384 of 3320
)d op insertTop!
--R 
--R
--RThere are 2 exposed functions called insertTop! :
--R   [1] (D1,Dequeue(D1)) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [2] (D1,D) -> D1 from D if D has DQAGG(D1) and D1 has TYPE
--R
--RExamples of insertTop! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--RinsertTop! a 
--Ra
--R
--R
--RExamples of insertTop! from DequeueAggregate
--R
--E 1384

--S 1385 of 3320
)d op inspect
--R 
--R
--RThere are 6 exposed functions called inspect :
--R   [1] ArrayStack(D1) -> D1 from ArrayStack(D1) if D1 has SETCAT
--R   [2] D -> D1 from D if D has BGAGG(D1) and D1 has TYPE
--R   [3] Dequeue(D1) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [4] Heap(D1) -> D1 from Heap(D1) if D1 has ORDSET
--R   [5] Queue(D1) -> D1 from Queue(D1) if D1 has SETCAT
--R   [6] Stack(D1) -> D1 from Stack(D1) if D1 has SETCAT
--R
--RExamples of inspect from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rinspect a
--R
--R
--RExamples of inspect from BagAggregate
--R
--R
--RExamples of inspect from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rinspect a
--R
--R
--RExamples of inspect from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rinspect a
--R
--R
--RExamples of inspect from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rinspect a
--R
--R
--RExamples of inspect from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rinspect a
--R
--E 1385

--S 1386 of 3320
)d op int
--R 
--R
--RThere are 5 unexposed functions called int :
--R   [1] (D1,Symbol) -> D1 from ODEIntegration(D3,D1)
--R             if D3 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero) and D1 has Join(
--R            AlgebraicallyClosedFunctionSpace(D3),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory)
--R         
--R   [2] (OutputForm,OutputForm,OutputForm) -> OutputForm from OutputForm
--R            
--R   [3] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [4] OutputForm -> OutputForm from OutputForm
--R   [5] D2 -> Stream(D2) from StreamTaylorSeriesOperations(D2) if D2
--R             has RING
--R
--RExamples of int from ODEIntegration
--R
--R
--RExamples of int from OutputForm
--R
--R
--RExamples of int from StreamTaylorSeriesOperations
--R
--E 1386

--S 1387 of 3320
)d op intChoose
--R 
--R
--RThere is one unexposed function called intChoose :
--R   [1] (SparseUnivariatePolynomial(D8),List(D6),List(List(D7))) -> 
--R            Record(upol: SparseUnivariatePolynomial(D7),Lval: List(D7),Lfact
--R            : List(Record(factor: SparseUnivariatePolynomial(D7),exponent: 
--R            Integer)),ctpol: D7)
--R             from MultivariateSquareFree(D5,D6,D7,D8)
--R             if D6 has ORDSET and D7 has EUCDOM and D8 has POLYCAT(D7,
--R            D5,D6) and D5 has OAMONS
--R
--RExamples of intChoose from MultivariateSquareFree
--R
--E 1387

--S 1388 of 3320
)d op intcompBasis
--R 
--R
--RThere is one unexposed function called intcompBasis :
--R   [1] (OrderedVariableList(D3),List(
--R            HomogeneousDistributedMultivariatePolynomial(D3,D4)),List(
--R            HomogeneousDistributedMultivariatePolynomial(D3,D4))) -> List(
--R            HomogeneousDistributedMultivariatePolynomial(D3,D4))
--R             from LinGroebnerPackage(D3,D4) if D3: LIST(SYMBOL) and D4
--R             has GCDDOM
--R
--RExamples of intcompBasis from LinGroebnerPackage
--R
--E 1388

--S 1389 of 3320
)d op integer
--R 
--R
--RThere are 2 exposed functions called integer :
--R   [1] D2 -> Integer from IntegerRetractions(D2) if D2 has RETRACT(INT)
--R            
--R   [2] D -> D1 from D
--R             if D has SEXCAT(D2,D3,D1,D4,D5) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D1 has 
--R            SETCAT
--R
--RExamples of integer from IntegerRetractions
--R
--R
--RExamples of integer from SExpressionCategory
--R
--E 1389

--S 1390 of 3320
)d op integer?
--R 
--R
--RThere are 3 exposed functions called integer? :
--R   [1] FortranScalarType -> Boolean from FortranScalarType
--R   [2] D2 -> Boolean from IntegerRetractions(D2) if D2 has RETRACT(INT)
--R            
--R   [3] D -> Boolean from D
--R             if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R
--RExamples of integer? from FortranScalarType
--R
--R
--RExamples of integer? from IntegerRetractions
--R
--R
--RExamples of integer? from SExpressionCategory
--R
--E 1390

--S 1391 of 3320
)d op integers
--R 
--R
--RThere is one unexposed function called integers :
--R   [1] Integer -> Stream(Integer) from StreamTaylorSeriesOperations(D3)
--R             if D3 has RING
--R
--RExamples of integers from StreamTaylorSeriesOperations
--R
--E 1391

--S 1392 of 3320
)d op integral
--R 
--R
--RThere are 2 exposed functions called integral :
--R   [1] (D,Symbol) -> D from D if D has PRIMCAT
--R   [2] (D,SegmentBinding(D)) -> D from D if D has PRIMCAT
--R
--RThere are 4 unexposed functions called integral :
--R   [1] (D1,Symbol) -> IntegrationResult(D1) from IntegrationResult(D1)
--R             if D1 has RETRACT(SYMBOL) and D1 has FIELD
--R   [2] (D1,D1) -> IntegrationResult(D1) from IntegrationResult(D1) if 
--R            D1 has FIELD
--R   [3] (D1,Symbol) -> D1 from LiouvillianFunction(D3,D1)
--R             if D3 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D3),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R   [4] (D1,SegmentBinding(D1)) -> D1 from LiouvillianFunction(D3,D1)
--R             if D1 has Join(FunctionSpace(D3),RadicalCategory,
--R            TranscendentalFunctionCategory) and D3 has Join(OrderedSet,
--R            IntegralDomain)
--R
--RExamples of integral from IntegrationResult
--R
--R
--RExamples of integral from LiouvillianFunction
--R
--R
--RExamples of integral from PrimitiveFunctionCategory
--R
--E 1392

--S 1393 of 3320
)d op integral?
--R 
--R
--RThere are 3 exposed functions called integral? :
--R   [1] (D,D2) -> Boolean from D
--R             if D has FFCAT(D3,D2,D4) and D3 has UFD and D2 has UPOLYC(
--R            D3) and D4 has UPOLYC(FRAC(D2))
--R   [2] (D,D2) -> Boolean from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R   [3] D -> Boolean from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of integral? from FunctionFieldCategory
--R
--E 1393

--S 1394 of 3320
)d op integralAtInfinity?
--R 
--R
--RThere is one exposed function called integralAtInfinity? :
--R   [1] D -> Boolean from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of integralAtInfinity? from FunctionFieldCategory
--R
--E 1394

--S 1395 of 3320
)d op integralBasis
--R 
--R
--RThere is one exposed function called integralBasis :
--R   [1]  -> Vector(D) from D
--R             if D2 has UFD and D3 has UPOLYC(D2) and D4 has UPOLYC(FRAC
--R            (D3)) and D has FFCAT(D2,D3,D4)
--R
--RThere are 4 unexposed functions called integralBasis :
--R   [1]  -> Record(basis: Matrix(D2),basisDen: D2,basisInv: Matrix(D2))
--R             from FunctionFieldIntegralBasis(D2,D3,D4)
--R             if D2 has EuclideanDomainwith
--R               squareFree : % -> Factored(%)and D3 has UPOLYC(D2) 
--R            and D4 has FRAMALG(D2,D3)
--R   [2]  -> Record(basis: Matrix(Integer),basisDen: Integer,basisInv: 
--R            Matrix(Integer))
--R             from NumberFieldIntegralBasis(D2,D3)
--R             if D2 has UPOLYC(INT) and D3 has FRAMALG(INT,D2)
--R   [3]  -> Record(basis: Matrix(D3),basisDen: D3,basisInv: Matrix(D3))
--R             from PAdicWildFunctionFieldIntegralBasis(D2,D3,D4,D5)
--R             if D2 has FFIELDC and D3 has UPOLYC(D2) and D4 has UPOLYC(
--R            D3) and D5 has MONOGEN(D3,D4)
--R   [4]  -> Record(basis: Matrix(D3),basisDen: D3,basisInv: Matrix(D3))
--R             from WildFunctionFieldIntegralBasis(D2,D3,D4,D5)
--R             if D2 has FFIELDC and D3 has UPOLYC(D2) and D4 has UPOLYC(
--R            D3) and D5 has FRAMALG(D3,D4)
--R
--RExamples of integralBasis from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RintegralBasis()$R
--R
--R
--RExamples of integralBasis from FunctionFieldIntegralBasis
--R
--R
--RExamples of integralBasis from NumberFieldIntegralBasis
--R
--R
--RExamples of integralBasis from PAdicWildFunctionFieldIntegralBasis
--R
--R
--RExamples of integralBasis from WildFunctionFieldIntegralBasis
--R
--E 1395

--S 1396 of 3320 done
)d op integralBasisAtInfinity
--R 
--R
--RThere is one exposed function called integralBasisAtInfinity :
--R   [1]  -> Vector(D) from D
--R             if D2 has UFD and D3 has UPOLYC(D2) and D4 has UPOLYC(FRAC
--R            (D3)) and D has FFCAT(D2,D3,D4)
--R
--RExamples of integralBasisAtInfinity from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RintegralBasisAtInfinity()$R
--R
--E 1396

--S 1397 of 3320
)d op integralCoordinates
--R 
--R
--RThere is one exposed function called integralCoordinates :
--R   [1] D -> Record(num: Vector(D3),den: D3) from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of integralCoordinates from FunctionFieldCategory
--R
--E 1397

--S 1398 of 3320
)d op integralDerivationMatrix
--R 
--R
--RThere is one exposed function called integralDerivationMatrix :
--R   [1] (D4 -> D4) -> Record(num: Matrix(D4),den: D4) from D
--R             if D has FFCAT(D3,D4,D5) and D3 has UFD and D4 has UPOLYC(
--R            D3) and D5 has UPOLYC(FRAC(D4))
--R
--RExamples of integralDerivationMatrix from FunctionFieldCategory
--R
--E 1398

--S 1399 of 3320
)d op integralLastSubResultant
--R 
--R
--RThere is one exposed function called integralLastSubResultant :
--R   [1] (D2,D2,D3) -> List(Record(val: D2,tower: D3))
--R             from RegularTriangularSetGcdPackage(D4,D5,D6,D2,D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of integralLastSubResultant from RegularTriangularSetGcdPackage
--R
--E 1399

--S 1400 of 3320 done
)d op integralMatrix
--R 
--R
--RThere is one exposed function called integralMatrix :
--R   [1]  -> Matrix(Fraction(D3)) from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of integralMatrix from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RintegralMatrix()$R
--R
--E 1400

--S 1401 of 3320 done
)d op integralMatrixAtInfinity
--R 
--R
--RThere is one exposed function called integralMatrixAtInfinity :
--R   [1]  -> Matrix(Fraction(D3)) from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of integralMatrixAtInfinity from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RintegralMatrixAtInfinity()$R
--R
--E 1401

--S 1402 of 3320
)d op integralRepresents
--R 
--R
--RThere is one exposed function called integralRepresents :
--R   [1] (Vector(D2),D2) -> D from D
--R             if D2 has UPOLYC(D3) and D3 has UFD and D has FFCAT(D3,D2,
--R            D4) and D4 has UPOLYC(FRAC(D2))
--R
--RExamples of integralRepresents from FunctionFieldCategory
--R
--E 1402

--S 1403 of 3320
)d op integrate
--R 
--R
--RThere are 32 exposed functions called integrate :
--R   [1] (D2,SegmentBinding(OrderedCompletion(D2))) -> Union(f1: 
--R            OrderedCompletion(D2),f2: List(OrderedCompletion(D2)),fail: 
--R            failed,pole: potentialPole)
--R             from ElementaryFunctionDefiniteIntegration(D4,D2)
--R             if D2 has Join(TranscendentalFunctionCategory,
--R            PrimitiveFunctionCategory,AlgebraicallyClosedFunctionSpace(
--R            D4)) and D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [2] (D2,SegmentBinding(OrderedCompletion(D2)),String) -> Union(f1: 
--R            OrderedCompletion(D2),f2: List(OrderedCompletion(D2)),fail: 
--R            failed,pole: potentialPole)
--R             from ElementaryFunctionDefiniteIntegration(D5,D2)
--R             if D2 has Join(TranscendentalFunctionCategory,
--R            PrimitiveFunctionCategory,AlgebraicallyClosedFunctionSpace(
--R            D5)) and D5 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [3] (Fraction(Polynomial(D4)),SegmentBinding(OrderedCompletion(
--R            Expression(D4)))) -> Union(f1: OrderedCompletion(Expression(D4)),
--R            f2: List(OrderedCompletion(Expression(D4))),fail: failed,pole: 
--R            potentialPole)
--R             from RationalFunctionDefiniteIntegration(D4)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [4] (Fraction(Polynomial(D5)),SegmentBinding(OrderedCompletion(
--R            Expression(D5))),String) -> Union(f1: OrderedCompletion(
--R            Expression(D5)),f2: List(OrderedCompletion(Expression(D5))),fail
--R            : failed,pole: potentialPole)
--R             from RationalFunctionDefiniteIntegration(D5)
--R             if D5 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [5] (Fraction(Polynomial(D4)),SegmentBinding(OrderedCompletion(
--R            Fraction(Polynomial(D4))))) -> Union(f1: OrderedCompletion(
--R            Expression(D4)),f2: List(OrderedCompletion(Expression(D4))),fail
--R            : failed,pole: potentialPole)
--R             from RationalFunctionDefiniteIntegration(D4)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [6] (Fraction(Polynomial(D5)),SegmentBinding(OrderedCompletion(
--R            Fraction(Polynomial(D5)))),String) -> Union(f1: OrderedCompletion
--R            (Expression(D5)),f2: List(OrderedCompletion(Expression(D5))),fail
--R            : failed,pole: potentialPole)
--R             from RationalFunctionDefiniteIntegration(D5)
--R             if D5 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [7] (D2,Symbol) -> Union(D2,List(D2)) from FunctionSpaceIntegration(
--R            D4,D2)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory,
--R            AlgebraicallyClosedFunctionSpace(D4))
--R   [8] (GeneralUnivariatePowerSeries(D2,D3,D4),Variable(D3)) -> 
--R            GeneralUnivariatePowerSeries(D2,D3,D4)
--R             from GeneralUnivariatePowerSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R   [9] (Expression(Float),Segment(OrderedCompletion(Float)),Float,Float
--R            ,RoutinesTable) -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [10] NumericalIntegrationProblem -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [11] (Expression(Float),Segment(OrderedCompletion(Float)),Float,
--R            Float) -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [12] (Expression(Float),Segment(OrderedCompletion(Float)),Float) -> 
--R            Result
--R             from AnnaNumericalIntegrationPackage
--R   [13] (Expression(Float),Segment(OrderedCompletion(Float))) -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [14] (Expression(Float),List(Segment(OrderedCompletion(Float)))) -> 
--R            Result
--R             from AnnaNumericalIntegrationPackage
--R   [15] (Expression(Float),List(Segment(OrderedCompletion(Float))),
--R            Float) -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [16] (Expression(Float),List(Segment(OrderedCompletion(Float))),
--R            Float,Float) -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [17] (Expression(Float),List(Segment(OrderedCompletion(Float))),
--R            Float,Float,RoutinesTable) -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [18] (Expression(Float),SegmentBinding(OrderedCompletion(Float)),
--R            String) -> Union(Result,"failed")
--R             from AnnaNumericalIntegrationPackage
--R   [19] (Expression(Float),SegmentBinding(OrderedCompletion(Float)),
--R            Symbol) -> Union(Result,"failed")
--R             from AnnaNumericalIntegrationPackage
--R   [20] (Fraction(Polynomial(D4)),Symbol) -> Union(Expression(D4),List(
--R            Expression(D4)))
--R             from IntegrationResultRFToFunction(D4)
--R             if D4 has CHARZ and D4 has Join(GcdDomain,RetractableTo(
--R            Integer),OrderedSet,LinearlyExplicitRingOver(Integer))
--R   [21] (D,D1) -> D from D
--R             if D has MTSCAT(D2,D1) and D2 has RING and D1 has ORDSET 
--R            and D2 has ALGEBRA(FRAC(INT))
--R   [22] (Polynomial(D2),Symbol) -> Polynomial(D2) from Polynomial(D2)
--R             if D2 has ALGEBRA(FRAC(INT)) and D2 has RING
--R   [23] (TaylorSeries(D2),Symbol,D2) -> TaylorSeries(D2) from 
--R            TaylorSeries(D2)
--R             if D2 has ALGEBRA(FRAC(INT)) and D2 has RING
--R   [24] (UnivariateFormalPowerSeries(D2),Variable(QUOTE(x))) -> 
--R            UnivariateFormalPowerSeries(D2)
--R             from UnivariateFormalPowerSeries(D2)
--R             if D2 has ALGEBRA(FRAC(INT)) and D2 has RING
--R   [25] (D,D1) -> D from D
--R             if D1 = SYMBOL and D has ULSCAT(D2) and D2 has RING and D2
--R             has ACFS(INT) and D2 has PRIMCAT and D2 has TRANFUN and D2
--R             has ALGEBRA(FRAC(INT)) or D1 = SYMBOL and D has ULSCAT(D2)
--R            and D2 has RING and D2 has variables: D2 -> List(D1) and D2
--R             has integrate: (D2,D1) -> D2 and D2 has ALGEBRA(FRAC(INT))
--R            
--R   [26] D -> D from D
--R             if D has ULSCAT(D1) and D1 has RING and D1 has ALGEBRA(
--R            FRAC(INT))
--R   [27] D -> D from D
--R             if D has UPOLYC(D1) and D1 has RING and D1 has ALGEBRA(
--R            FRAC(INT))
--R   [28] (D,D1) -> D from D
--R             if D1 = SYMBOL and D has UPXSCAT(D2) and D2 has RING and 
--R            D2 has ACFS(INT) and D2 has PRIMCAT and D2 has TRANFUN and 
--R            D2 has ALGEBRA(FRAC(INT)) or D1 = SYMBOL and D has UPXSCAT(
--R            D2) and D2 has RING and D2 has variables: D2 -> List(D1) 
--R            and D2 has integrate: (D2,D1) -> D2 and D2 has ALGEBRA(FRAC
--R            (INT))
--R   [29] D -> D from D
--R             if D has UPXSCAT(D1) and D1 has RING and D1 has ALGEBRA(
--R            FRAC(INT))
--R   [30] (D,D1) -> D from D
--R             if D1 = SYMBOL and D has UTSCAT(D2) and D2 has RING and D2
--R             has ACFS(INT) and D2 has PRIMCAT and D2 has TRANFUN and D2
--R             has ALGEBRA(FRAC(INT)) or D1 = SYMBOL and D has UTSCAT(D2)
--R            and D2 has RING and D2 has variables: D2 -> List(D1) and D2
--R             has integrate: (D2,D1) -> D2 and D2 has ALGEBRA(FRAC(INT))
--R            
--R   [31] D -> D from D
--R             if D has UTSCAT(D1) and D1 has RING and D1 has ALGEBRA(
--R            FRAC(INT))
--R   [32] (UnivariateTaylorSeriesCZero(D2,D3),Variable(D3)) -> 
--R            UnivariateTaylorSeriesCZero(D2,D3)
--R             from UnivariateTaylorSeriesCZero(D2,D3)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING
--R
--RThere are 10 unexposed functions called integrate :
--R   [1] Fraction(D4) -> IntegrationResult(Fraction(D4))
--R             from RationalIntegration(D3,D4)
--R             if D3 has Join(Field,CharacteristicZero,RetractableTo(
--R            Integer)) and D4 has UPOLYC(D3)
--R   [2] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R   [3] (SparseMultivariateTaylorSeries(D2,D1,D3),D1,D2) -> 
--R            SparseMultivariateTaylorSeries(D2,D1,D3)
--R             from SparseMultivariateTaylorSeries(D2,D1,D3)
--R             if D2 has ALGEBRA(FRAC(INT)) and D2 has RING and D1 has 
--R            ORDSET and D3 has POLYCAT(D2,INDE(D1),D1)
--R   [4] (D2,Stream(D2)) -> Stream(D2) from StreamTaylorSeriesOperations(
--R            D2)
--R             if D2 has ALGEBRA(FRAC(INT)) and D2 has RING
--R   [5] (SparseUnivariateLaurentSeries(D2,D3,D4),Variable(D3)) -> 
--R            SparseUnivariateLaurentSeries(D2,D3,D4)
--R             from SparseUnivariateLaurentSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R   [6] (SparseUnivariatePuiseuxSeries(D2,D3,D4),Variable(D3)) -> 
--R            SparseUnivariatePuiseuxSeries(D2,D3,D4)
--R             from SparseUnivariatePuiseuxSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R   [7] (SparseUnivariateTaylorSeries(D2,D3,D4),Variable(D3)) -> 
--R            SparseUnivariateTaylorSeries(D2,D3,D4)
--R             from SparseUnivariateTaylorSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R   [8] (UnivariateLaurentSeries(D2,D3,D4),Variable(D3)) -> 
--R            UnivariateLaurentSeries(D2,D3,D4)
--R             from UnivariateLaurentSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R   [9] (UnivariatePuiseuxSeries(D2,D3,D4),Variable(D3)) -> 
--R            UnivariatePuiseuxSeries(D2,D3,D4)
--R             from UnivariatePuiseuxSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R   [10] (UnivariateTaylorSeries(D2,D3,D4),Variable(D3)) -> 
--R            UnivariateTaylorSeries(D2,D3,D4)
--R             from UnivariateTaylorSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R
--RExamples of integrate from ElementaryFunctionDefiniteIntegration
--R
--R
--RExamples of integrate from RationalFunctionDefiniteIntegration
--R
--R
--RExamples of integrate from FunctionSpaceIntegration
--R
--R
--RExamples of integrate from GeneralUnivariatePowerSeries
--R
--R
--RExamples of integrate from AnnaNumericalIntegrationPackage
--R
--R
--RExamples of integrate from RationalIntegration
--R
--R
--RExamples of integrate from IntegrationResultRFToFunction
--R
--R
--RExamples of integrate from InnerSparseUnivariatePowerSeries
--R
--R
--RExamples of integrate from MultivariateTaylorSeriesCategory
--R
--R
--RExamples of integrate from Polynomial
--R
--R
--RExamples of integrate from SparseMultivariateTaylorSeries
--R
--R
--RExamples of integrate from StreamTaylorSeriesOperations
--R
--R
--RExamples of integrate from SparseUnivariateLaurentSeries
--R
--R
--RExamples of integrate from SparseUnivariatePuiseuxSeries
--R
--R
--RExamples of integrate from SparseUnivariateTaylorSeries
--R
--R
--RExamples of integrate from TaylorSeries
--R
--R
--RExamples of integrate from UnivariateFormalPowerSeries
--R
--R
--RExamples of integrate from UnivariateLaurentSeriesCategory
--R
--R
--RExamples of integrate from UnivariateLaurentSeries
--R
--R
--RExamples of integrate from UnivariatePolynomialCategory
--R
--R
--RExamples of integrate from UnivariatePuiseuxSeriesCategory
--R
--R
--RExamples of integrate from UnivariatePuiseuxSeries
--R
--R
--RExamples of integrate from UnivariateTaylorSeriesCategory
--R
--R
--RExamples of integrate from UnivariateTaylorSeries
--R
--R
--RExamples of integrate from UnivariateTaylorSeriesCZero
--R
--E 1403

--S 1404 of 3320
)d op integrate
--R 
--R
--RThere are 32 exposed functions called integrate :
--R   [1] (D2,SegmentBinding(OrderedCompletion(D2))) -> Union(f1: 
--R            OrderedCompletion(D2),f2: List(OrderedCompletion(D2)),fail: 
--R            failed,pole: potentialPole)
--R             from ElementaryFunctionDefiniteIntegration(D4,D2)
--R             if D2 has Join(TranscendentalFunctionCategory,
--R            PrimitiveFunctionCategory,AlgebraicallyClosedFunctionSpace(
--R            D4)) and D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [2] (D2,SegmentBinding(OrderedCompletion(D2)),String) -> Union(f1: 
--R            OrderedCompletion(D2),f2: List(OrderedCompletion(D2)),fail: 
--R            failed,pole: potentialPole)
--R             from ElementaryFunctionDefiniteIntegration(D5,D2)
--R             if D2 has Join(TranscendentalFunctionCategory,
--R            PrimitiveFunctionCategory,AlgebraicallyClosedFunctionSpace(
--R            D5)) and D5 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [3] (Fraction(Polynomial(D4)),SegmentBinding(OrderedCompletion(
--R            Expression(D4)))) -> Union(f1: OrderedCompletion(Expression(D4)),
--R            f2: List(OrderedCompletion(Expression(D4))),fail: failed,pole: 
--R            potentialPole)
--R             from RationalFunctionDefiniteIntegration(D4)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [4] (Fraction(Polynomial(D5)),SegmentBinding(OrderedCompletion(
--R            Expression(D5))),String) -> Union(f1: OrderedCompletion(
--R            Expression(D5)),f2: List(OrderedCompletion(Expression(D5))),fail
--R            : failed,pole: potentialPole)
--R             from RationalFunctionDefiniteIntegration(D5)
--R             if D5 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [5] (Fraction(Polynomial(D4)),SegmentBinding(OrderedCompletion(
--R            Fraction(Polynomial(D4))))) -> Union(f1: OrderedCompletion(
--R            Expression(D4)),f2: List(OrderedCompletion(Expression(D4))),fail
--R            : failed,pole: potentialPole)
--R             from RationalFunctionDefiniteIntegration(D4)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [6] (Fraction(Polynomial(D5)),SegmentBinding(OrderedCompletion(
--R            Fraction(Polynomial(D5)))),String) -> Union(f1: OrderedCompletion
--R            (Expression(D5)),f2: List(OrderedCompletion(Expression(D5))),fail
--R            : failed,pole: potentialPole)
--R             from RationalFunctionDefiniteIntegration(D5)
--R             if D5 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [7] (D2,Symbol) -> Union(D2,List(D2)) from FunctionSpaceIntegration(
--R            D4,D2)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory,
--R            AlgebraicallyClosedFunctionSpace(D4))
--R   [8] (GeneralUnivariatePowerSeries(D2,D3,D4),Variable(D3)) -> 
--R            GeneralUnivariatePowerSeries(D2,D3,D4)
--R             from GeneralUnivariatePowerSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R   [9] (Expression(Float),Segment(OrderedCompletion(Float)),Float,Float
--R            ,RoutinesTable) -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [10] NumericalIntegrationProblem -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [11] (Expression(Float),Segment(OrderedCompletion(Float)),Float,
--R            Float) -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [12] (Expression(Float),Segment(OrderedCompletion(Float)),Float) -> 
--R            Result
--R             from AnnaNumericalIntegrationPackage
--R   [13] (Expression(Float),Segment(OrderedCompletion(Float))) -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [14] (Expression(Float),List(Segment(OrderedCompletion(Float)))) -> 
--R            Result
--R             from AnnaNumericalIntegrationPackage
--R   [15] (Expression(Float),List(Segment(OrderedCompletion(Float))),
--R            Float) -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [16] (Expression(Float),List(Segment(OrderedCompletion(Float))),
--R            Float,Float) -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [17] (Expression(Float),List(Segment(OrderedCompletion(Float))),
--R            Float,Float,RoutinesTable) -> Result
--R             from AnnaNumericalIntegrationPackage
--R   [18] (Expression(Float),SegmentBinding(OrderedCompletion(Float)),
--R            String) -> Union(Result,"failed")
--R             from AnnaNumericalIntegrationPackage
--R   [19] (Expression(Float),SegmentBinding(OrderedCompletion(Float)),
--R            Symbol) -> Union(Result,"failed")
--R             from AnnaNumericalIntegrationPackage
--R   [20] (Fraction(Polynomial(D4)),Symbol) -> Union(Expression(D4),List(
--R            Expression(D4)))
--R             from IntegrationResultRFToFunction(D4)
--R             if D4 has CHARZ and D4 has Join(GcdDomain,RetractableTo(
--R            Integer),OrderedSet,LinearlyExplicitRingOver(Integer))
--R   [21] (D,D1) -> D from D
--R             if D has MTSCAT(D2,D1) and D2 has RING and D1 has ORDSET 
--R            and D2 has ALGEBRA(FRAC(INT))
--R   [22] (Polynomial(D2),Symbol) -> Polynomial(D2) from Polynomial(D2)
--R             if D2 has ALGEBRA(FRAC(INT)) and D2 has RING
--R   [23] (TaylorSeries(D2),Symbol,D2) -> TaylorSeries(D2) from 
--R            TaylorSeries(D2)
--R             if D2 has ALGEBRA(FRAC(INT)) and D2 has RING
--R   [24] (UnivariateFormalPowerSeries(D2),Variable(QUOTE(x))) -> 
--R            UnivariateFormalPowerSeries(D2)
--R             from UnivariateFormalPowerSeries(D2)
--R             if D2 has ALGEBRA(FRAC(INT)) and D2 has RING
--R   [25] (D,D1) -> D from D
--R             if D1 = SYMBOL and D has ULSCAT(D2) and D2 has RING and D2
--R             has ACFS(INT) and D2 has PRIMCAT and D2 has TRANFUN and D2
--R             has ALGEBRA(FRAC(INT)) or D1 = SYMBOL and D has ULSCAT(D2)
--R            and D2 has RING and D2 has variables: D2 -> List(D1) and D2
--R             has integrate: (D2,D1) -> D2 and D2 has ALGEBRA(FRAC(INT))
--R            
--R   [26] D -> D from D
--R             if D has ULSCAT(D1) and D1 has RING and D1 has ALGEBRA(
--R            FRAC(INT))
--R   [27] D -> D from D
--R             if D has UPOLYC(D1) and D1 has RING and D1 has ALGEBRA(
--R            FRAC(INT))
--R   [28] (D,D1) -> D from D
--R             if D1 = SYMBOL and D has UPXSCAT(D2) and D2 has RING and 
--R            D2 has ACFS(INT) and D2 has PRIMCAT and D2 has TRANFUN and 
--R            D2 has ALGEBRA(FRAC(INT)) or D1 = SYMBOL and D has UPXSCAT(
--R            D2) and D2 has RING and D2 has variables: D2 -> List(D1) 
--R            and D2 has integrate: (D2,D1) -> D2 and D2 has ALGEBRA(FRAC
--R            (INT))
--R   [29] D -> D from D
--R             if D has UPXSCAT(D1) and D1 has RING and D1 has ALGEBRA(
--R            FRAC(INT))
--R   [30] (D,D1) -> D from D
--R             if D1 = SYMBOL and D has UTSCAT(D2) and D2 has RING and D2
--R             has ACFS(INT) and D2 has PRIMCAT and D2 has TRANFUN and D2
--R             has ALGEBRA(FRAC(INT)) or D1 = SYMBOL and D has UTSCAT(D2)
--R            and D2 has RING and D2 has variables: D2 -> List(D1) and D2
--R             has integrate: (D2,D1) -> D2 and D2 has ALGEBRA(FRAC(INT))
--R            
--R   [31] D -> D from D
--R             if D has UTSCAT(D1) and D1 has RING and D1 has ALGEBRA(
--R            FRAC(INT))
--R   [32] (UnivariateTaylorSeriesCZero(D2,D3),Variable(D3)) -> 
--R            UnivariateTaylorSeriesCZero(D2,D3)
--R             from UnivariateTaylorSeriesCZero(D2,D3)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING
--R
--RThere are 10 unexposed functions called integrate :
--R   [1] Fraction(D4) -> IntegrationResult(Fraction(D4))
--R             from RationalIntegration(D3,D4)
--R             if D3 has Join(Field,CharacteristicZero,RetractableTo(
--R            Integer)) and D4 has UPOLYC(D3)
--R   [2] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has RING
--R   [3] (SparseMultivariateTaylorSeries(D2,D1,D3),D1,D2) -> 
--R            SparseMultivariateTaylorSeries(D2,D1,D3)
--R             from SparseMultivariateTaylorSeries(D2,D1,D3)
--R             if D2 has ALGEBRA(FRAC(INT)) and D2 has RING and D1 has 
--R            ORDSET and D3 has POLYCAT(D2,INDE(D1),D1)
--R   [4] (D2,Stream(D2)) -> Stream(D2) from StreamTaylorSeriesOperations(
--R            D2)
--R             if D2 has ALGEBRA(FRAC(INT)) and D2 has RING
--R   [5] (SparseUnivariateLaurentSeries(D2,D3,D4),Variable(D3)) -> 
--R            SparseUnivariateLaurentSeries(D2,D3,D4)
--R             from SparseUnivariateLaurentSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R   [6] (SparseUnivariatePuiseuxSeries(D2,D3,D4),Variable(D3)) -> 
--R            SparseUnivariatePuiseuxSeries(D2,D3,D4)
--R             from SparseUnivariatePuiseuxSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R   [7] (SparseUnivariateTaylorSeries(D2,D3,D4),Variable(D3)) -> 
--R            SparseUnivariateTaylorSeries(D2,D3,D4)
--R             from SparseUnivariateTaylorSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R   [8] (UnivariateLaurentSeries(D2,D3,D4),Variable(D3)) -> 
--R            UnivariateLaurentSeries(D2,D3,D4)
--R             from UnivariateLaurentSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R   [9] (UnivariatePuiseuxSeries(D2,D3,D4),Variable(D3)) -> 
--R            UnivariatePuiseuxSeries(D2,D3,D4)
--R             from UnivariatePuiseuxSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R   [10] (UnivariateTaylorSeries(D2,D3,D4),Variable(D3)) -> 
--R            UnivariateTaylorSeries(D2,D3,D4)
--R             from UnivariateTaylorSeries(D2,D3,D4)
--R             if D3: SYMBOL and D2 has ALGEBRA(FRAC(INT)) and D2 has 
--R            RING and D4: D2
--R
--RExamples of integrate from ElementaryFunctionDefiniteIntegration
--R
--R
--RExamples of integrate from RationalFunctionDefiniteIntegration
--R
--R
--RExamples of integrate from FunctionSpaceIntegration
--R
--R
--RExamples of integrate from GeneralUnivariatePowerSeries
--R
--R
--RExamples of integrate from AnnaNumericalIntegrationPackage
--R
--R
--RExamples of integrate from RationalIntegration
--R
--R
--RExamples of integrate from IntegrationResultRFToFunction
--R
--R
--RExamples of integrate from InnerSparseUnivariatePowerSeries
--R
--R
--RExamples of integrate from MultivariateTaylorSeriesCategory
--R
--R
--RExamples of integrate from Polynomial
--R
--R
--RExamples of integrate from SparseMultivariateTaylorSeries
--R
--R
--RExamples of integrate from StreamTaylorSeriesOperations
--R
--R
--RExamples of integrate from SparseUnivariateLaurentSeries
--R
--R
--RExamples of integrate from SparseUnivariatePuiseuxSeries
--R
--R
--RExamples of integrate from SparseUnivariateTaylorSeries
--R
--R
--RExamples of integrate from TaylorSeries
--R
--R
--RExamples of integrate from UnivariateFormalPowerSeries
--R
--R
--RExamples of integrate from UnivariateLaurentSeriesCategory
--R
--R
--RExamples of integrate from UnivariateLaurentSeries
--R
--R
--RExamples of integrate from UnivariatePolynomialCategory
--R
--R
--RExamples of integrate from UnivariatePuiseuxSeriesCategory
--R
--R
--RExamples of integrate from UnivariatePuiseuxSeries
--R
--R
--RExamples of integrate from UnivariateTaylorSeriesCategory
--R
--R
--RExamples of integrate from UnivariateTaylorSeries
--R
--R
--RExamples of integrate from UnivariateTaylorSeriesCZero
--R
--E 1404

--S 1405 of 3320
)d op intensity
--R 
--R
--RThere is one exposed function called intensity :
--R   [1] (ThreeDimensionalViewport,Float) -> Void from 
--R            ThreeDimensionalViewport
--R
--RExamples of intensity from ThreeDimensionalViewport
--R
--E 1405

--S 1406 of 3320 done
)d op interiorProduct
--R 
--R
--RThere is one unexposed function called interiorProduct :
--R   [1] (Vector(Expression(D3)),DeRhamComplex(D3,D4),SquareMatrix(#(D4),
--R            Expression(D3))) -> DeRhamComplex(D3,D4)
--R             from DeRhamComplex(D3,D4)
--R             if D3 has Join(Ring,OrderedSet) and D4: LIST(SYMBOL)
--R
--RExamples of interiorProduct from DeRhamComplex
--R
--R indented{1}{with the differential form a (w.r.t. metric g)} blankline 
--RcoefRing := Integer 
--RR3 : List Symbol := [x,y,z] 
--RD := DERHAM(coefRing,R3) 
--R[dx,dy,dz] := [generator(i)$D for i in 1..3] 
--Rf : BOP := operator('f) 
--Rg : BOP := operator('g) 
--Rh : BOP := operator('h) 
--Ra : BOP := operator('a) 
--Rb : BOP := operator('b) 
--Rc : BOP := operator('c) 
--RU : BOP := operator('U) 
--RV : BOP := operator('V) 
--RW : BOP := operator('W) 
--Rv := vector[U(x,y,z),V(x,y,z),W(x,y,z)] 
--Rsigma := f(x,y,z)*dx + g(x,y,z)*dy + h(x,y,z)*dz 
--Rtheta := a(x,y,z)*dx*dy + b(x,y,z)*dx*dz + c(x,y,z)*dy*dz 
--RG := diagonalMatrix([1,1,1]) 
--RinteriorProduct(v,sigma,G) 
--RinteriorProduct(v,theta,G)
--R
--E 1406

--S 1407 of 3320
)d op intermediateResultsIF
--R 
--R
--RThere is one exposed function called intermediateResultsIF :
--R   [1] Record(xinit: DoubleFloat,xend: DoubleFloat,fn: Vector(
--R            Expression(DoubleFloat)),yinit: List(DoubleFloat),intvals: List(
--R            DoubleFloat),g: Expression(DoubleFloat),abserr: DoubleFloat,
--R            relerr: DoubleFloat) -> Float
--R             from d02AgentsPackage
--R
--RExamples of intermediateResultsIF from d02AgentsPackage
--R
--E 1407

--S 1408 of 3320
)d op internal?
--R 
--R
--RThere is one unexposed function called internal? :
--R   [1] SubSpace(D2,D3) -> Boolean from SubSpace(D2,D3) if D2: PI and D3
--R             has RING
--R
--RExamples of internal? from SubSpace
--R
--E 1408

--S 1409 of 3320
)d op internalAugment
--R 
--R
--RThere are 4 exposed functions called internalAugment :
--R   [1] (D2,RegularTriangularSet(D4,D5,D6,D2),Boolean,Boolean,Boolean,
--R            Boolean,Boolean) -> List(RegularTriangularSet(D4,D5,D6,D2))
--R             from RegularTriangularSet(D4,D5,D6,D2)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6)
--R   [2] (List(D5),D) -> D from D
--R             if D has RSETCAT(D2,D3,D4,D5) and D2 has GCDDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R   [3] (D1,D) -> D from D
--R             if D has RSETCAT(D2,D3,D4,D1) and D2 has GCDDOM and D3
--R             has OAMONS and D4 has ORDSET and D1 has RPOLCAT(D2,D3,D4)
--R            
--R   [4] (D2,SquareFreeRegularTriangularSet(D4,D5,D6,D2),Boolean,Boolean,
--R            Boolean,Boolean,Boolean) -> List(SquareFreeRegularTriangularSet(
--R            D4,D5,D6,D2))
--R             from SquareFreeRegularTriangularSet(D4,D5,D6,D2)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6)
--R
--RExamples of internalAugment from RegularTriangularSet
--R
--R
--RExamples of internalAugment from RegularTriangularSetCategory
--R
--R
--RExamples of internalAugment from SquareFreeRegularTriangularSet
--R
--E 1409

--S 1410 of 3320
)d op internalDecompose
--R 
--R
--RThere are 6 exposed functions called internalDecompose :
--R   [1] (D2,D3,NonNegativeInteger,Boolean) -> Record(done: List(D3),todo
--R            : List(Record(val: List(D2),tower: D3)))
--R             from RegularSetDecompositionPackage(D6,D7,D8,D2,D3)
--R             if D6 has GCDDOM and D7 has OAMONS and D8 has ORDSET and 
--R            D2 has RPOLCAT(D6,D7,D8) and D3 has RSETCAT(D6,D7,D8,D2)
--R         
--R   [2] (D2,D3,NonNegativeInteger) -> Record(done: List(D3),todo: List(
--R            Record(val: List(D2),tower: D3)))
--R             from RegularSetDecompositionPackage(D5,D6,D7,D2,D3)
--R             if D5 has GCDDOM and D6 has OAMONS and D7 has ORDSET and 
--R            D2 has RPOLCAT(D5,D6,D7) and D3 has RSETCAT(D5,D6,D7,D2)
--R         
--R   [3] (D2,D3) -> Record(done: List(D3),todo: List(Record(val: List(D2)
--R            ,tower: D3)))
--R             from RegularSetDecompositionPackage(D4,D5,D6,D2,D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R   [4] (D2,D3,NonNegativeInteger,Boolean) -> Record(done: List(D3),todo
--R            : List(Record(val: List(D2),tower: D3)))
--R             from SquareFreeRegularSetDecompositionPackage(D6,D7,D8,D2,
--R            D3)
--R             if D6 has GCDDOM and D7 has OAMONS and D8 has ORDSET and 
--R            D2 has RPOLCAT(D6,D7,D8) and D3 has SFRTCAT(D6,D7,D8,D2)
--R         
--R   [5] (D2,D3,NonNegativeInteger) -> Record(done: List(D3),todo: List(
--R            Record(val: List(D2),tower: D3)))
--R             from SquareFreeRegularSetDecompositionPackage(D5,D6,D7,D2,
--R            D3)
--R             if D5 has GCDDOM and D6 has OAMONS and D7 has ORDSET and 
--R            D2 has RPOLCAT(D5,D6,D7) and D3 has SFRTCAT(D5,D6,D7,D2)
--R         
--R   [6] (D2,D3) -> Record(done: List(D3),todo: List(Record(val: List(D2)
--R            ,tower: D3)))
--R             from SquareFreeRegularSetDecompositionPackage(D4,D5,D6,D2,
--R            D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has SFRTCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of internalDecompose from RegularSetDecompositionPackage
--R
--R
--RExamples of internalDecompose from SquareFreeRegularSetDecompositionPackage
--R
--E 1410

--S 1411 of 3320
)d op internalInfRittWu?
--R 
--R
--RThere are 2 exposed functions called internalInfRittWu? :
--R   [1] (List(D6),List(D6)) -> Boolean from QuasiComponentPackage(D3,D4,
--R            D5,D6,D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [2] (List(D6),List(D6)) -> Boolean
--R             from SquareFreeQuasiComponentPackage(D3,D4,D5,D6,D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R
--RExamples of internalInfRittWu? from QuasiComponentPackage
--R
--R
--RExamples of internalInfRittWu? from SquareFreeQuasiComponentPackage
--R
--E 1411

--S 1412 of 3320
)d op internalIntegrate
--R 
--R
--RThere are 2 exposed functions called internalIntegrate :
--R   [1] (D2,Symbol) -> IntegrationResult(D2)
--R             from FunctionSpaceComplexIntegration(D4,D2)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            TranscendentalFunctionCategory,
--R            AlgebraicallyClosedFunctionSpace(D4))
--R   [2] (Fraction(Polynomial(D4)),Symbol) -> IntegrationResult(Fraction(
--R            Polynomial(D4)))
--R             from RationalFunctionIntegration(D4)
--R             if D4 has Join(IntegralDomain,RetractableTo(Integer),
--R            CharacteristicZero)
--R
--RExamples of internalIntegrate from FunctionSpaceComplexIntegration
--R
--R
--RExamples of internalIntegrate from RationalFunctionIntegration
--R
--E 1412

--S 1413 of 3320
)d op internalIntegrate0
--R 
--R
--RThere is one exposed function called internalIntegrate0 :
--R   [1] (D2,Symbol) -> IntegrationResult(D2)
--R             from FunctionSpaceComplexIntegration(D4,D2)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            TranscendentalFunctionCategory,
--R            AlgebraicallyClosedFunctionSpace(D4))
--R
--RExamples of internalIntegrate0 from FunctionSpaceComplexIntegration
--R
--E 1413

--S 1414 of 3320
)d op internalLastSubResultant
--R 
--R
--RThere are 2 exposed functions called internalLastSubResultant :
--R   [1] (D2,D2,D3,Boolean,Boolean) -> List(Record(val: D2,tower: D3))
--R             from RegularTriangularSetGcdPackage(D5,D6,D7,D2,D3)
--R             if D5 has GCDDOM and D6 has OAMONS and D7 has ORDSET and 
--R            D2 has RPOLCAT(D5,D6,D7) and D3 has RSETCAT(D5,D6,D7,D2)
--R         
--R   [2] (List(Record(val: List(D7),tower: D8)),D3,Boolean) -> List(
--R            Record(val: D7,tower: D8))
--R             from RegularTriangularSetGcdPackage(D5,D6,D3,D7,D8)
--R             if D7 has RPOLCAT(D5,D6,D3) and D8 has RSETCAT(D5,D6,D3,D7
--R            ) and D5 has GCDDOM and D6 has OAMONS and D3 has ORDSET
--R
--RExamples of internalLastSubResultant from RegularTriangularSetGcdPackage
--R
--E 1414

--S 1415 of 3320
)d op internalSubPolSet?
--R 
--R
--RThere are 2 exposed functions called internalSubPolSet? :
--R   [1] (List(D6),List(D6)) -> Boolean from QuasiComponentPackage(D3,D4,
--R            D5,D6,D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [2] (List(D6),List(D6)) -> Boolean
--R             from SquareFreeQuasiComponentPackage(D3,D4,D5,D6,D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R
--RExamples of internalSubPolSet? from QuasiComponentPackage
--R
--R
--RExamples of internalSubPolSet? from SquareFreeQuasiComponentPackage
--R
--E 1415

--S 1416 of 3320
)d op internalSubQuasiComponent?
--R 
--R
--RThere are 2 exposed functions called internalSubQuasiComponent? :
--R   [1] (D2,D2) -> Union(Boolean,"failed")
--R             from QuasiComponentPackage(D3,D4,D5,D6,D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D2 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [2] (D2,D2) -> Union(Boolean,"failed")
--R             from SquareFreeQuasiComponentPackage(D3,D4,D5,D6,D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D2 has RSETCAT(D3,D4,D5,D6)
--R         
--R
--RExamples of internalSubQuasiComponent? from QuasiComponentPackage
--R
--R
--RExamples of internalSubQuasiComponent? from SquareFreeQuasiComponentPackage
--R
--E 1416

--S 1417 of 3320
)d op internalZeroSetSplit
--R 
--R
--RThere are 2 exposed functions called internalZeroSetSplit :
--R   [1] (List(D7),Boolean,Boolean,Boolean) -> List(RegularTriangularSet(
--R            D4,D5,D6,D7))
--R             from RegularTriangularSet(D4,D5,D6,D7)
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has GCDDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R   [2] (List(D7),Boolean,Boolean,Boolean) -> List(
--R            SquareFreeRegularTriangularSet(D4,D5,D6,D7))
--R             from SquareFreeRegularTriangularSet(D4,D5,D6,D7)
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has GCDDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R
--RExamples of internalZeroSetSplit from RegularTriangularSet
--R
--R
--RExamples of internalZeroSetSplit from SquareFreeRegularTriangularSet
--R
--E 1417

--S 1418 of 3320
)d op interpolate
--R 
--R
--RThere are 2 exposed functions called interpolate :
--R   [1] (List(D4),List(D4),NonNegativeInteger) -> Fraction(
--R            SparseUnivariatePolynomial(D4))
--R             from FractionFreeFastGaussian(D4,D5)
--R             if D4 has Join(IntegralDomain,GcdDomain) and D5 has AMR(D4
--R            ,NNI)
--R   [2] (List(Fraction(D4)),List(Fraction(D4)),NonNegativeInteger) -> 
--R            Fraction(SparseUnivariatePolynomial(D4))
--R             from FractionFreeFastGaussian(D4,D5)
--R             if D4 has Join(IntegralDomain,GcdDomain) and D5 has AMR(D4
--R            ,NNI)
--R
--RThere are 3 unexposed functions called interpolate :
--R   [1] (UnivariatePolynomial(D3,D4),List(D4),List(D4)) -> 
--R            UnivariatePolynomial(D3,D4)
--R             from PolynomialInterpolation(D3,D4) if D3: SYMBOL and D4
--R             has FIELD
--R   [2] (List(D4),List(D4)) -> SparseUnivariatePolynomial(D4)
--R             from PolynomialInterpolation(D3,D4) if D4 has FIELD and D3
--R            : SYMBOL
--R   [3] (List(D5),List(D5),NonNegativeInteger,NonNegativeInteger) -> 
--R            Fraction(Polynomial(D5))
--R             from RationalInterpolation(D4,D5) if D5 has FIELD and D4: 
--R            SYMBOL
--R
--RExamples of interpolate from FractionFreeFastGaussian
--R
--R
--RExamples of interpolate from PolynomialInterpolation
--R
--R
--RExamples of interpolate from RationalInterpolation
--R
--E 1418

--S 1419 of 3320
)d op interpolateForms
--R 
--R
--RThere are 4 exposed functions called interpolateForms :
--R   [1] (D7,NonNegativeInteger) -> List(D11)
--R             from GeneralPackageForAlgebraicFunctionField(D9,D10,D11,
--R            D12,D13,D1,D2,D7,D3,D4,D5)
--R             if D9 has FIELD and D10: LIST(SYMBOL) and D11 has POLYCAT(
--R            D9,D12,OVAR(D10)) and D12 has DIRPCAT(#(D10),NNI) and D13
--R             has PRSPCAT(D9) and D1 has LOCPOWC(D9) and D2 has PLACESC(
--R            D9,D1) and D7 has DIVCAT(D2) and D3 has INFCLCT(D9,D10,D11,
--R            D12,D13,D1,D2,D7,D5) and D5 has BLMETCT and D4 has DSTRCAT(
--R            D3)
--R   [2] (D4,NonNegativeInteger,D6,List(D6)) -> List(D6)
--R             from InterpolateFormsPackage(D7,D8,D6,D9,D10,D1,D2,D4)
--R             if D6 has POLYCAT(D7,D9,OVAR(D8)) and D9 has DIRPCAT(#(D8)
--R            ,NNI) and D7 has FIELD and D8: LIST(SYMBOL) and D1 has 
--R            LOCPOWC(D7) and D2 has PLACESC(D7,D1) and D10 has PRSPCAT(
--R            D7) and D4 has DIVCAT(D2)
--R   [3] (Divisor(PlacesOverPseudoAlgebraicClosureOfFiniteField(D4)),
--R            NonNegativeInteger) -> List(DistributedMultivariatePolynomial(D5,
--R            D4))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D4,D5
--R            ,D6)
--R             if D4 has FFIELDC and D5: LIST(SYMBOL) and D6 has BLMETCT
--R            
--R   [4] (Divisor(Places(D4)),NonNegativeInteger) -> List(
--R            DistributedMultivariatePolynomial(D5,D4))
--R             from PackageForAlgebraicFunctionField(D4,D5,D6)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D6 has BLMETCT
--R         
--R
--RExamples of interpolateForms from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of interpolateForms from InterpolateFormsPackage
--R
--R
--RExamples of interpolateForms from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of interpolateForms from PackageForAlgebraicFunctionField
--R
--E 1419

--S 1420 of 3320
)d op interpolateFormsForFact
--R 
--R
--RThere are 4 exposed functions called interpolateFormsForFact :
--R   [1] (D6,List(D9)) -> List(D9)
--R             from GeneralPackageForAlgebraicFunctionField(D7,D8,D9,D10,
--R            D11,D12,D1,D6,D2,D3,D4)
--R             if D9 has POLYCAT(D7,D10,OVAR(D8)) and D10 has DIRPCAT(#(
--R            D8),NNI) and D7 has FIELD and D8: LIST(SYMBOL) and D11 has 
--R            PRSPCAT(D7) and D12 has LOCPOWC(D7) and D1 has PLACESC(D7,
--R            D12) and D6 has DIVCAT(D1) and D2 has INFCLCT(D7,D8,D9,D10,
--R            D11,D12,D1,D6,D4) and D4 has BLMETCT and D3 has DSTRCAT(D2)
--R            
--R   [2] (D3,List(D6)) -> List(D6)
--R             from InterpolateFormsPackage(D4,D5,D6,D7,D8,D9,D1,D3)
--R             if D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT(#(D5)
--R            ,NNI) and D4 has FIELD and D5: LIST(SYMBOL) and D9 has 
--R            LOCPOWC(D4) and D1 has PLACESC(D4,D9) and D8 has PRSPCAT(D4
--R            ) and D3 has DIVCAT(D1)
--R   [3] (Divisor(PlacesOverPseudoAlgebraicClosureOfFiniteField(D4)),List
--R            (DistributedMultivariatePolynomial(D5,D4))) -> List(
--R            DistributedMultivariatePolynomial(D5,
--R            PseudoAlgebraicClosureOfFiniteField(D4)))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D4,D5
--R            ,D6)
--R             if D4 has FFIELDC and D5: LIST(SYMBOL) and D6 has BLMETCT
--R            
--R   [4] (Divisor(Places(D3)),List(DistributedMultivariatePolynomial(D4,
--R            D3))) -> List(DistributedMultivariatePolynomial(D4,D3))
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D5 has BLMETCT
--R         
--R
--RExamples of interpolateFormsForFact from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of interpolateFormsForFact from InterpolateFormsPackage
--R
--R
--RExamples of interpolateFormsForFact from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of interpolateFormsForFact from PackageForAlgebraicFunctionField
--R
--E 1420

--S 1421 of 3320
)d op interpret
--R 
--R
--RThere are 2 unexposed functions called interpret :
--R   [1] InputForm -> D1 from InputFormFunctions1(D1) if D1 has TYPE
--R   [2] InputForm -> Any from InputForm
--R
--RExamples of interpret from InputFormFunctions1
--R
--R
--RExamples of interpret from InputForm
--R
--E 1421

--S 1422 of 3320
)d op interpretString
--R 
--R
--RThere is one exposed function called interpretString :
--R   [1] String -> Any from TemplateUtilities
--R
--RExamples of interpretString from TemplateUtilities
--R
--E 1422

--S 1423 of 3320
)d op interReduce
--R 
--R
--RThere is one unexposed function called interReduce :
--R   [1] List(D5) -> List(D5) from PolynomialSetUtilitiesPackage(D2,D3,D4
--R            ,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has INTDOM and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RExamples of interReduce from PolynomialSetUtilitiesPackage
--R
--E 1423

--S 1424 of 3320
)d op intersect
--R 
--R
--RThere are 7 exposed functions called intersect :
--R   [1] List(PolynomialIdeals(D2,D3,D4,D5)) -> PolynomialIdeals(D2,D3,D4
--R            ,D5)
--R             from PolynomialIdeals(D2,D3,D4,D5)
--R             if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D5
--R             has POLYCAT(D2,D3,D4)
--R   [2] (PolynomialIdeals(D1,D2,D3,D4),PolynomialIdeals(D1,D2,D3,D4))
--R             -> PolynomialIdeals(D1,D2,D3,D4)
--R             from PolynomialIdeals(D1,D2,D3,D4)
--R             if D1 has FIELD and D2 has OAMONS and D3 has ORDSET and D4
--R             has POLYCAT(D1,D2,D3)
--R   [3] (D2,List(D)) -> List(D) from D
--R             if D has RSETCAT(D3,D4,D5,D2) and D3 has GCDDOM and D4
--R             has OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R            
--R   [4] (List(D6),List(D)) -> List(D) from D
--R             if D has RSETCAT(D3,D4,D5,D6) and D3 has GCDDOM and D4
--R             has OAMONS and D5 has ORDSET and D6 has RPOLCAT(D3,D4,D5)
--R            
--R   [5] (List(D6),D) -> List(D) from D
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D has RSETCAT(D3,D4,D5,D6)
--R   [6] (D2,D) -> List(D) from D
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5) and D has RSETCAT(D3,D4,D5,D2)
--R   [7] (D,D) -> D from D if D has SETAGG(D1) and D1 has SETCAT
--R
--RExamples of intersect from PolynomialIdeals
--R
--R
--RExamples of intersect from RegularTriangularSetCategory
--R
--R
--RExamples of intersect from SetAggregate
--R
--E 1424

--S 1425 of 3320
)d op intersectionDivisor
--R 
--R
--RThere are 4 exposed functions called intersectionDivisor :
--R   [1] D5 -> D4
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D5,D8,
--R            D9,D10,D11,D4,D1,D2,D3)
--R             if D6 has FIELD and D7: LIST(SYMBOL) and D5 has POLYCAT(D6
--R            ,D8,OVAR(D7)) and D8 has DIRPCAT(#(D7),NNI) and D9 has 
--R            PRSPCAT(D6) and D10 has LOCPOWC(D6) and D11 has PLACESC(D6,
--R            D10) and D1 has INFCLCT(D6,D7,D5,D8,D9,D10,D11,D4,D3) and 
--R            D3 has BLMETCT and D4 has DIVCAT(D11) and D2 has DSTRCAT(D1
--R            )
--R   [2] (D7,D7,List(D4),List(D13)) -> D6
--R             from IntersectionDivisorPackage(D10,D11,D7,D12,D13,D1,D2,
--R            D6,D3,D4,D5)
--R             if D13 has PRSPCAT(D10) and D4 has DSTRCAT(D3) and D10
--R             has FIELD and D3 has INFCLCT(D10,D11,D7,D12,D13,D1,D2,D6,
--R            D5) and D5 has BLMETCT and D11: LIST(SYMBOL) and D7 has 
--R            POLYCAT(D10,D12,OVAR(D11)) and D12 has DIRPCAT(#(D11),NNI) 
--R            and D1 has LOCPOWC(D10) and D2 has PLACESC(D10,D1) and D6
--R             has DIVCAT(D2)
--R   [3] DistributedMultivariatePolynomial(D4,D3) -> Divisor(
--R            PlacesOverPseudoAlgebraicClosureOfFiniteField(D3))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D3,D4
--R            ,D5)
--R             if D3 has FFIELDC and D4: LIST(SYMBOL) and D5 has BLMETCT
--R            
--R   [4] DistributedMultivariatePolynomial(D4,D3) -> Divisor(Places(D3))
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D5 has BLMETCT
--R         
--R
--RExamples of intersectionDivisor from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of intersectionDivisor from IntersectionDivisorPackage
--R
--R
--RExamples of intersectionDivisor from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of intersectionDivisor from PackageForAlgebraicFunctionField
--R
--E 1425

--S 1426 of 3320
)d op interval
--R 
--R
--RThere are 3 exposed functions called interval :
--R   [1] Fraction(Integer) -> D from D
--R             if D has INTCAT(D2) and D2 has Join(FloatingPointSystem,
--R            TranscendentalFunctionCategory)
--R   [2] D1 -> D from D
--R             if D has INTCAT(D1) and D1 has Join(FloatingPointSystem,
--R            TranscendentalFunctionCategory)
--R   [3] (D1,D1) -> D from D
--R             if D has INTCAT(D1) and D1 has Join(FloatingPointSystem,
--R            TranscendentalFunctionCategory)
--R
--RExamples of interval from IntervalCategory
--R
--E 1426

--S 1427 of 3320
)d op intPatternMatch
--R 
--R
--RThere is one unexposed function called intPatternMatch :
--R   [1] (D2,Symbol,((D2,Symbol) -> IntegrationResult(D2)),((D2,Symbol)
--R             -> Union(Record(special: D2,integrand: D2),"failed"))) -> 
--R            IntegrationResult(D2)
--R             from IntegrationTools(D6,D2)
--R             if D2 has ELEMFUN and D2 has LFCAT and D2 has RETRACT(
--R            SYMBOL) and D2 has FS(D6) and D6 has KONVERT(PATTERN(INT)) 
--R            and D6 has GCDDOM and D6 has PATMAB(INT) and D6 has ORDSET
--R            
--R
--RExamples of intPatternMatch from IntegrationTools
--R
--E 1427

--S 1428 of 3320 done
)d op introduce!
--R 
--R
--RThere is one exposed function called introduce! :
--R   [1] (Symbol,Symbol) -> Union(BasicStochasticDifferential,"failed")
--R             from BasicStochasticDifferential
--R
--RExamples of introduce! from BasicStochasticDifferential
--R
--Rintroduce!(t,dt) -- dt is a new stochastic differential 
--RcopyBSD()
--R
--E 1428

--S 1429 of 3320
)d op inv
--R 
--R
--RThere are 4 exposed functions called inv :
--R   [1] D -> D from D if D has DIVRING
--R   [2] D -> D from D
--R             if D = EQ(D1) and D1 has FIELD and D1 has TYPE or D = EQ(
--R            D1) and D1 has GROUP and D1 has TYPE
--R   [3] D -> D from D if D has GROUP
--R   [4] D -> D from D if D has OC(D1) and D1 has COMRING and D1 has 
--R            FIELD
--R
--RThere are 3 unexposed functions called inv :
--R   [1] EuclideanModularRing(D1,D2,D3,D4,D5,D6) -> EuclideanModularRing(
--R            D1,D2,D3,D4,D5,D6)
--R             from EuclideanModularRing(D1,D2,D3,D4,D5,D6)
--R             if D1 has COMRING and D2 has UPOLYC(D1) and D3 has ABELMON
--R            and D4: ((D2,D3) -> D2) and D5: ((D3,D3) -> Union(D3,
--R            "failed")) and D6: ((D2,D2,D3) -> Union(D2,"failed"))
--R   [2] Vector(D2) -> Vector(D2) from InnerNormalBasisFieldFunctions(D2)
--R             if D2 has FFIELDC
--R   [3] ModularRing(D1,D2,D3,D4,D5) -> ModularRing(D1,D2,D3,D4,D5)
--R             from ModularRing(D1,D2,D3,D4,D5)
--R             if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> 
--R            D1) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1
--R            ,D2) -> Union(D1,"failed"))
--R
--RExamples of inv from DivisionRing
--R
--R
--RExamples of inv from EuclideanModularRing
--R
--R
--RExamples of inv from Equation
--R
--R
--RExamples of inv from Group
--R
--R
--RExamples of inv from InnerNormalBasisFieldFunctions
--R
--R
--RExamples of inv from ModularRing
--R
--R
--RExamples of inv from OctonionCategory
--R
--E 1429

--S 1430 of 3320
)d op inverse
--R 
--R
--RThere are 4 exposed functions called inverse :
--R   [1] D -> Union(D,"failed") from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1) and D1 has FIELD
--R   [2] D1 -> Union(D1,"failed") from MatrixLinearAlgebraFunctions(D2,D3
--R            ,D4,D1)
--R             if D2 has FIELD and D2 has COMRING and D3 has FLAGG(D2) 
--R            and D4 has FLAGG(D2) and D1 has MATCAT(D2,D3,D4)
--R   [3] Matrix(D1) -> Union(Matrix(D1),"failed") from Matrix(D1)
--R             if D1 has FIELD and D1 has RING
--R   [4] D -> Union(D,"failed") from D
--R             if D has SMATCAT(D1,D2,D3,D4) and D2 has RING and D3 has 
--R            DIRPCAT(D1,D2) and D4 has DIRPCAT(D1,D2) and D2 has FIELD
--R         
--R
--RThere are 3 unexposed functions called inverse :
--R   [1] D1 -> Union(D1,"failed")
--R             from InnerMatrixLinearAlgebraFunctions(D2,D3,D4,D1)
--R             if D2 has FIELD and D3 has FLAGG(D2) and D4 has FLAGG(D2) 
--R            and D1 has MATCAT(D2,D3,D4)
--R   [2] D2 -> Union(D1,"failed")
--R             from InnerMatrixQuotientFieldFunctions(D3,D4,D5,D2,D6,D7,
--R            D8,D1)
--R             if D3 has INTDOM and D4 has FLAGG(D3) and D5 has FLAGG(D3)
--R            and D6 has QFCAT(D3) and D1 has MATCAT(D6,D7,D8) and D2
--R             has MATCAT(D3,D4,D5) and D7 has FLAGG(D6) and D8 has FLAGG
--R            (D6)
--R   [3] List(D2) -> List(D2) from TableauxBumpers(D2) if D2 has ORDSET
--R         
--R
--RExamples of inverse from InnerMatrixLinearAlgebraFunctions
--R
--R
--RExamples of inverse from InnerMatrixQuotientFieldFunctions
--R
--R
--RExamples of inverse from MatrixCategory
--R
--Rinverse matrix [[j**i for i in 0..4] for j in 1..5]
--R
--R
--RExamples of inverse from MatrixLinearAlgebraFunctions
--R
--R
--RExamples of inverse from Matrix
--R
--R
--RExamples of inverse from SquareMatrixCategory
--R
--R
--RExamples of inverse from TableauxBumpers
--R
--E 1430

--S 1431 of 3320
)d op inverseColeman
--R 
--R
--RThere is one exposed function called inverseColeman :
--R   [1] (List(Integer),List(Integer),Matrix(Integer)) -> List(Integer)
--R             from SymmetricGroupCombinatoricFunctions
--R
--RExamples of inverseColeman from SymmetricGroupCombinatoricFunctions
--R
--E 1431

--S 1432 of 3320 done
)d op inverseIntegralMatrix
--R 
--R
--RThere is one exposed function called inverseIntegralMatrix :
--R   [1]  -> Matrix(Fraction(D3)) from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of inverseIntegralMatrix from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RinverseIntegralMatrix()$R
--R
--E 1432

--S 1433 of 3320 done
)d op inverseIntegralMatrixAtInfinity
--R 
--R
--RThere is one exposed function called inverseIntegralMatrixAtInfinity :
--R   [1]  -> Matrix(Fraction(D3)) from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of inverseIntegralMatrixAtInfinity from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RinverseIntegralMatrixAtInfinity()$R
--R
--E 1433

--S 1434 of 3320
)d op inverseLaplace
--R 
--R
--RThere is one exposed function called inverseLaplace :
--R   [1] (D1,Symbol,Symbol) -> Union(D1,"failed")
--R             from InverseLaplaceTransform(D3,D1)
--R             if D3 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer)) and D1 has Join(
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory,
--R            SpecialFunctionCategory,AlgebraicallyClosedFunctionSpace(D3
--R            ))
--R
--RExamples of inverseLaplace from InverseLaplaceTransform
--R
--E 1434

--S 1435 of 3320
)d op invertible?
--R 
--R
--RThere are 2 exposed functions called invertible? :
--R   [1] (D2,D) -> Boolean from D
--R             if D has RSETCAT(D3,D4,D5,D2) and D3 has GCDDOM and D4
--R             has OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R            
--R   [2] (D2,D) -> List(Record(val: Boolean,tower: D)) from D
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5) and D has RSETCAT(D3,D4,D5,D2)
--R
--RExamples of invertible? from RegularTriangularSetCategory
--R
--E 1435

--S 1436 of 3320
)d op invertibleElseSplit?
--R 
--R
--RThere is one exposed function called invertibleElseSplit? :
--R   [1] (D2,D) -> Union(Boolean,List(D)) from D
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5) and D has RSETCAT(D3,D4,D5,D2)
--R
--RExamples of invertibleElseSplit? from RegularTriangularSetCategory
--R
--E 1436

--S 1437 of 3320
)d op invertibleSet
--R 
--R
--RThere is one exposed function called invertibleSet :
--R   [1] (D2,D) -> List(D) from D
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5) and D has RSETCAT(D3,D4,D5,D2)
--R
--RExamples of invertibleSet from RegularTriangularSetCategory
--R
--E 1437

--S 1438 of 3320
)d op invertIfCan
--R 
--R
--RThere is one exposed function called invertIfCan :
--R   [1] D1 -> Union(D1,"failed") from MatrixLinearAlgebraFunctions(D2,D3
--R            ,D4,D1)
--R             if D2 has INTDOM and D2 has COMRING and D3 has FLAGG(D2) 
--R            and D4 has FLAGG(D2) and D1 has MATCAT(D2,D3,D4)
--R
--RExamples of invertIfCan from MatrixLinearAlgebraFunctions
--R
--E 1438

--S 1439 of 3320
)d op invmod
--R 
--R
--RThere is one exposed function called invmod :
--R   [1] (D,D) -> D from D if D has INS
--R
--RExamples of invmod from IntegerNumberSystem
--R
--E 1439

--S 1440 of 3320
)d op invmultisect
--R 
--R
--RThere are 2 exposed functions called invmultisect :
--R   [1] (Integer,Integer,UnivariateFormalPowerSeries(D2)) -> 
--R            UnivariateFormalPowerSeries(D2)
--R             from UnivariateFormalPowerSeries(D2) if D2 has RING
--R   [2] (Integer,Integer,UnivariateTaylorSeriesCZero(D2,D3)) -> 
--R            UnivariateTaylorSeriesCZero(D2,D3)
--R             from UnivariateTaylorSeriesCZero(D2,D3) if D2 has RING and
--R            D3: SYMBOL
--R
--RThere are 2 unexposed functions called invmultisect :
--R   [1] (Integer,Integer,Stream(D3)) -> Stream(D3)
--R             from StreamTaylorSeriesOperations(D3) if D3 has RING
--R   [2] (Integer,Integer,UnivariateTaylorSeries(D2,D3,D4)) -> 
--R            UnivariateTaylorSeries(D2,D3,D4)
--R             from UnivariateTaylorSeries(D2,D3,D4)
--R             if D2 has RING and D3: SYMBOL and D4: D2
--R
--RExamples of invmultisect from StreamTaylorSeriesOperations
--R
--R
--RExamples of invmultisect from UnivariateFormalPowerSeries
--R
--R
--RExamples of invmultisect from UnivariateTaylorSeries
--R
--R
--RExamples of invmultisect from UnivariateTaylorSeriesCZero
--R
--E 1440

--S 1441 of 3320
)d op iomode
--R 
--R
--RThere is one exposed function called iomode :
--R   [1] D -> String from D if D has FILECAT(D2,D3) and D2 has SETCAT and
--R            D3 has SETCAT
--R
--RExamples of iomode from FileCategory
--R
--E 1441

--S 1442 of 3320
)d op ipow
--R 
--R
--RThere is one unexposed function called ipow :
--R   [1] List(D1) -> D1 from CombinatorialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of ipow from CombinatorialFunction
--R
--E 1442

--S 1443 of 3320
)d op iprint
--R 
--R
--RThere is one unexposed function called iprint :
--R   [1] String -> Void from InternalPrintPackage
--R
--RExamples of iprint from InternalPrintPackage
--R
--E 1443

--S 1444 of 3320
)d op iroot
--R 
--R
--RThere is one unexposed function called iroot :
--R   [1] (D2,Integer) -> D1 from AlgebraicFunction(D2,D1)
--R             if D1 has FS(D2) and D2 has RETRACT(INT) and D2 has Join(
--R            OrderedSet,IntegralDomain)
--R
--RExamples of iroot from AlgebraicFunction
--R
--E 1444

--S 1445 of 3320
)d op irreducible?
--R 
--R
--RThere are 3 exposed functions called irreducible? :
--R   [1] D2 -> Boolean from DistinctDegreeFactorize(D3,D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R   [2] D2 -> Boolean from FiniteFieldFactorization(D3,D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R   [3] D2 -> Boolean
--R             from FiniteFieldFactorizationWithSizeParseBySideEffect(D3,
--R            D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R
--RExamples of irreducible? from DistinctDegreeFactorize
--R
--R
--RExamples of irreducible? from FiniteFieldFactorization
--R
--R
--RExamples of irreducible? from FiniteFieldFactorizationWithSizeParseBySideEffect
--R
--E 1445

--S 1446 of 3320 done
)d op irreducibleFactor
--R 
--R
--RThere is one exposed function called irreducibleFactor :
--R   [1] (D1,Integer) -> Factored(D1) from Factored(D1) if D1 has INTDOM
--R            
--R
--RExamples of irreducibleFactor from Factored
--R
--Ra:=irreducibleFactor(3,1) 
--RnthFlag(a,1)
--R
--E 1446

--S 1447 of 3320
)d op irreducibleFactors
--R 
--R
--RThere is one unexposed function called irreducibleFactors :
--R   [1] List(D5) -> List(D5) from PolynomialSetUtilitiesPackage(D2,D3,D4
--R            ,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has CHARZ and D2 has 
--R            EUCDOM and D2 has INTDOM and D3 has OAMONS and D4 has 
--R            ORDSET
--R
--RExamples of irreducibleFactors from PolynomialSetUtilitiesPackage
--R
--E 1447

--S 1448 of 3320
)d op irreducibleRepresentation
--R 
--R
--RThere are 3 exposed functions called irreducibleRepresentation :
--R   [1] (List(Integer),Permutation(Integer)) -> Matrix(Integer)
--R             from IrrRepSymNatPackage
--R   [2] List(Integer) -> List(Matrix(Integer)) from IrrRepSymNatPackage
--R            
--R   [3] (List(Integer),List(Permutation(Integer))) -> List(Matrix(
--R            Integer))
--R             from IrrRepSymNatPackage
--R
--RExamples of irreducibleRepresentation from IrrRepSymNatPackage
--R
--E 1448

--S 1449 of 3320
)d op is?
--R 
--R
--RThere are 5 exposed functions called is? :
--R   [1] (BasicOperator,Symbol) -> Boolean from BasicOperator
--R   [2] (D,Symbol) -> Boolean from D if D has ES
--R   [3] (D,BasicOperator) -> Boolean from D if D has ES
--R   [4] (D2,D3) -> Boolean from PatternMatch(D4,D2,D3)
--R             if D4 has SETCAT and D2 has PATMAB(D4) and D3 has KONVERT(
--R            PATTERN(D4))
--R   [5] (List(D5),D3) -> Boolean from PatternMatch(D4,D5,D3)
--R             if D5 has PATMAB(D4) and D4 has SETCAT and D3 has KONVERT(
--R            PATTERN(D4))
--R
--RThere are 2 unexposed functions called is? :
--R   [1] (Kernel(D3),Symbol) -> Boolean from Kernel(D3) if D3 has ORDSET
--R            
--R   [2] (Kernel(D3),BasicOperator) -> Boolean from Kernel(D3) if D3 has 
--R            ORDSET
--R
--RExamples of is? from BasicOperator
--R
--R
--RExamples of is? from ExpressionSpace
--R
--R
--RExamples of is? from Kernel
--R
--R
--RExamples of is? from PatternMatch
--R
--E 1449

--S 1450 of 3320
)d op Is
--R 
--R
--RThere are 4 exposed functions called Is :
--R   [1] (List(D5),D3) -> PatternMatchListResult(D4,D5,List(D5))
--R             from PatternMatch(D4,D5,D3)
--R             if D4 has SETCAT and D5 has PATMAB(D4) and D3 has KONVERT(
--R            PATTERN(D4))
--R   [2] (D2,D3) -> List(Equation(D2)) from PatternMatch(D4,D2,D3)
--R             if D4 has SETCAT and D2 has RETRACT(SYMBOL) and D2 has 
--R            PATMAB(D4) and D3 has KONVERT(PATTERN(D4))
--R   [3] (D2,D3) -> List(Equation(Polynomial(D2))) from PatternMatch(D4,
--R            D2,D3)
--R             if D4 has SETCAT and D2 has RING and not(ofCategory(D2,
--R            RetractableTo(Symbol))) and D2 has PATMAB(D4) and D3 has 
--R            KONVERT(PATTERN(D4))
--R   [4] (D2,D3) -> PatternMatchResult(D4,D2) from PatternMatch(D4,D2,D3)
--R             if D4 has SETCAT and not(ofCategory(D2,RetractableTo(
--R            Symbol))) and not(ofCategory(D2,Ring)) and D2 has PATMAB(D4
--R            ) and D3 has KONVERT(PATTERN(D4))
--R
--RExamples of Is from PatternMatch
--R
--E 1450

--S 1451 of 3320
)d op isAbsolutelyIrreducible?
--R 
--R
--RThere are 2 exposed functions called isAbsolutelyIrreducible? :
--R   [1] (List(Matrix(D4)),Integer) -> Boolean from 
--R            RepresentationPackage2(D4)
--R             if D4 has FIELD and D4 has RING
--R   [2] List(Matrix(D3)) -> Boolean from RepresentationPackage2(D3)
--R             if D3 has FIELD and D3 has RING
--R
--RExamples of isAbsolutelyIrreducible? from RepresentationPackage2
--R
--E 1451

--S 1452 of 3320
)d op isExpt
--R 
--R
--RThere are 4 exposed functions called isExpt :
--R   [1] (D,Symbol) -> Union(Record(var: Kernel(D),exponent: Integer),
--R            "failed")
--R             from D if D3 has RING and D3 has ORDSET and D has FS(D3)
--R         
--R   [2] (D,BasicOperator) -> Union(Record(var: Kernel(D),exponent: 
--R            Integer),"failed")
--R             from D if D3 has RING and D3 has ORDSET and D has FS(D3)
--R         
--R   [3] D -> Union(Record(var: Kernel(D),exponent: Integer),"failed")
--R             from D
--R             if D2 has SGROUP and D2 has ORDSET and D has FS(D2)
--R   [4] D -> Union(Record(var: D4,exponent: NonNegativeInteger),"failed"
--R            ) from D
--R             if D has POLYCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RThere are 2 unexposed functions called isExpt :
--R   [1] Pattern(D2) -> Union(Record(val: Pattern(D2),exponent: 
--R            NonNegativeInteger),"failed")
--R             from Pattern(D2) if D2 has SETCAT
--R   [2] D2 -> Union(Record(var: D4,exponent: Integer),"failed")
--R             from PolynomialCategoryQuotientFunctions(D3,D4,D5,D6,D2)
--R             if D3 has OAMONS and D4 has ORDSET and D5 has RING and D6
--R             has POLYCAT(D5,D3,D4) and D2 has Fieldwith
--R               coerce : D6 -> %
--R               numer : % -> D6
--R               denom : % -> D6
--R
--RExamples of isExpt from FunctionSpace
--R
--R
--RExamples of isExpt from Pattern
--R
--R
--RExamples of isExpt from PolynomialCategory
--R
--R
--RExamples of isExpt from PolynomialCategoryQuotientFunctions
--R
--E 1452

--S 1453 of 3320
)d op isList
--R 
--R
--RThere is one unexposed function called isList :
--R   [1] Pattern(D2) -> Union(List(Pattern(D2)),"failed") from Pattern(D2
--R            )
--R             if D2 has SETCAT
--R
--RExamples of isList from Pattern
--R
--E 1453

--S 1454 of 3320
)d op isMult
--R 
--R
--RThere is one exposed function called isMult :
--R   [1] D -> Union(Record(coef: Integer,var: Kernel(D)),"failed") from D
--R             if D2 has ABELSG and D2 has ORDSET and D has FS(D2)
--R
--RExamples of isMult from FunctionSpace
--R
--E 1454

--S 1455 of 3320
)d op isobaric?
--R 
--R
--RThere is one exposed function called isobaric? :
--R   [1] D -> Boolean from D
--R             if D has DPOLCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            ORDSET and D4 has DVARCAT(D3) and D5 has OAMONS
--R
--RExamples of isobaric? from DifferentialPolynomialCategory
--R
--E 1455

--S 1456 of 3320
)d op isOp
--R 
--R
--RThere are 2 unexposed functions called isOp :
--R   [1] Pattern(D2) -> Union(Record(op: BasicOperator,arg: List(Pattern(
--R            D2))),"failed")
--R             from Pattern(D2) if D2 has SETCAT
--R   [2] (Pattern(D3),BasicOperator) -> Union(List(Pattern(D3)),"failed")
--R             from Pattern(D3) if D3 has SETCAT
--R
--RExamples of isOp from Pattern
--R
--E 1456

--S 1457 of 3320
)d op isPlus
--R 
--R
--RThere are 2 exposed functions called isPlus :
--R   [1] D -> Union(List(D),"failed") from D
--R             if D2 has ABELSG and D2 has ORDSET and D has FS(D2)
--R   [2] D -> Union(List(D),"failed") from D
--R             if D2 has RING and D3 has OAMONS and D4 has ORDSET and D
--R             has POLYCAT(D2,D3,D4)
--R
--RThere are 2 unexposed functions called isPlus :
--R   [1] Pattern(D2) -> Union(List(Pattern(D2)),"failed") from Pattern(D2
--R            )
--R             if D2 has SETCAT
--R   [2] D2 -> Union(List(D2),"failed")
--R             from PolynomialCategoryQuotientFunctions(D3,D4,D5,D6,D2)
--R             if D3 has OAMONS and D4 has ORDSET and D5 has RING and D6
--R             has POLYCAT(D5,D3,D4) and D2 has Fieldwith
--R               coerce : D6 -> %
--R               numer : % -> D6
--R               denom : % -> D6
--R
--RExamples of isPlus from FunctionSpace
--R
--R
--RExamples of isPlus from Pattern
--R
--R
--RExamples of isPlus from PolynomialCategory
--R
--R
--RExamples of isPlus from PolynomialCategoryQuotientFunctions
--R
--E 1457

--S 1458 of 3320
)d op isPower
--R 
--R
--RThere is one exposed function called isPower :
--R   [1] D -> Union(Record(val: D,exponent: Integer),"failed") from D
--R             if D2 has RING and D2 has ORDSET and D has FS(D2)
--R
--RThere are 2 unexposed functions called isPower :
--R   [1] Pattern(D2) -> Union(Record(val: Pattern(D2),exponent: Pattern(
--R            D2)),"failed")
--R             from Pattern(D2) if D2 has SETCAT
--R   [2] D2 -> Union(Record(val: D2,exponent: Integer),"failed")
--R             from PolynomialCategoryQuotientFunctions(D3,D4,D5,D6,D2)
--R             if D3 has OAMONS and D4 has ORDSET and D5 has RING and D6
--R             has POLYCAT(D5,D3,D4) and D2 has Fieldwith
--R               coerce : D6 -> %
--R               numer : % -> D6
--R               denom : % -> D6
--R
--RExamples of isPower from FunctionSpace
--R
--R
--RExamples of isPower from Pattern
--R
--R
--RExamples of isPower from PolynomialCategoryQuotientFunctions
--R
--E 1458

--S 1459 of 3320
)d op isQuotient
--R 
--R
--RThere is one exposed function called isQuotient :
--R   [1] Expression(DoubleFloat) -> Union(Expression(DoubleFloat),
--R            "failed")
--R             from ExpertSystemToolsPackage
--R
--RThere is one unexposed function called isQuotient :
--R   [1] Pattern(D2) -> Union(Record(num: Pattern(D2),den: Pattern(D2)),
--R            "failed")
--R             from Pattern(D2) if D2 has SETCAT
--R
--RExamples of isQuotient from ExpertSystemToolsPackage
--R
--R
--RExamples of isQuotient from Pattern
--R
--E 1459

--S 1460 of 3320
)d op isTimes
--R 
--R
--RThere are 2 exposed functions called isTimes :
--R   [1] D -> Union(List(D),"failed") from D
--R             if D2 has SGROUP and D2 has ORDSET and D has FS(D2)
--R   [2] D -> Union(List(D),"failed") from D
--R             if D2 has RING and D3 has OAMONS and D4 has ORDSET and D
--R             has POLYCAT(D2,D3,D4)
--R
--RThere are 2 unexposed functions called isTimes :
--R   [1] Pattern(D2) -> Union(List(Pattern(D2)),"failed") from Pattern(D2
--R            )
--R             if D2 has SETCAT
--R   [2] D2 -> Union(List(D2),"failed")
--R             from PolynomialCategoryQuotientFunctions(D3,D4,D5,D6,D2)
--R             if D3 has OAMONS and D4 has ORDSET and D5 has RING and D6
--R             has POLYCAT(D5,D3,D4) and D2 has Fieldwith
--R               coerce : D6 -> %
--R               numer : % -> D6
--R               denom : % -> D6
--R
--RExamples of isTimes from FunctionSpace
--R
--R
--RExamples of isTimes from Pattern
--R
--R
--RExamples of isTimes from PolynomialCategory
--R
--R
--RExamples of isTimes from PolynomialCategoryQuotientFunctions
--R
--E 1460

--S 1461 of 3320
)d op iter
--R 
--R
--RThere is one unexposed function called iter :
--R   [1] ((D1 -> D1),NonNegativeInteger,D1) -> D1
--R             from MappingPackageInternalHacks1(D1) if D1 has SETCAT
--R
--RExamples of iter from MappingPackageInternalHacks1
--R
--E 1461

--S 1462 of 3320
)d op iteratedInitials
--R 
--R
--RThere is one exposed function called iteratedInitials :
--R   [1] D -> List(D) from D
--R             if D2 has RING and D3 has OAMONS and D4 has ORDSET and D
--R             has RPOLCAT(D2,D3,D4)
--R
--RExamples of iteratedInitials from RecursivePolynomialCategory
--R
--E 1462

--S 1463 of 3320
)d op itsALeaf!
--R 
--R
--RThere is one exposed function called itsALeaf! :
--R   [1] D -> Void from D
--R             if D has PLACESC(D2,D3) and D2 has FIELD and D3 has 
--R            LOCPOWC(D2)
--R
--RExamples of itsALeaf! from PlacesCategory
--R
--E 1463

--S 1464 of 3320
)d op jacobi
--R 
--R
--RThere is one exposed function called jacobi :
--R   [1] (Integer,Integer) -> Integer from IntegerNumberTheoryFunctions
--R         
--R
--RExamples of jacobi from IntegerNumberTheoryFunctions
--R
--E 1464

--S 1465 of 3320
)d op jacobian
--R 
--R
--RThere are 2 exposed functions called jacobian :
--R   [1] (Vector(Expression(DoubleFloat)),List(Symbol)) -> Matrix(
--R            Expression(DoubleFloat))
--R             from d02AgentsPackage
--R   [2] (D2,D3) -> Matrix(D5) from MultiVariableCalculusFunctions(D4,D5,
--R            D2,D3)
--R             if D4 has SETCAT and D5 has PDRING(D4) and D2 has FLAGG(D5
--R            ) and D3 has FiniteLinearAggregate(D4)with
--R                 finiteAggregate
--R
--RExamples of jacobian from d02AgentsPackage
--R
--R
--RExamples of jacobian from MultiVariableCalculusFunctions
--R
--E 1465

--S 1466 of 3320
)d op jacobiIdentity?
--R 
--R
--RThere is one exposed function called jacobiIdentity? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called jacobiIdentity? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of jacobiIdentity? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of jacobiIdentity? from FiniteRankNonAssociativeAlgebra
--R
--E 1466

--S 1467 of 3320
)d op janko2
--R 
--R
--RThere are 2 exposed functions called janko2 :
--R   [1] List(Integer) -> PermutationGroup(Integer) from 
--R            PermutationGroupExamples
--R   [2]  -> PermutationGroup(Integer) from PermutationGroupExamples
--R
--RExamples of janko2 from PermutationGroupExamples
--R
--E 1467

--S 1468 of 3320
)d op join
--R 
--R
--RThere is one exposed function called join :
--R   [1] (SparseEchelonMatrix(D1,D2),SparseEchelonMatrix(D1,D2)) -> 
--R            SparseEchelonMatrix(D1,D2)
--R             from SparseEchelonMatrix(D1,D2) if D1 has ORDSET and D2
--R             has RING
--R
--RExamples of join from SparseEchelonMatrix
--R
--E 1468

--S 1469 of 3320
)d op jordanAdmissible?
--R 
--R
--RThere is one exposed function called jordanAdmissible? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called jordanAdmissible? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of jordanAdmissible? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of jordanAdmissible? from FiniteRankNonAssociativeAlgebra
--R
--E 1469

--S 1470 of 3320
)d op jordanAlgebra?
--R 
--R
--RThere is one exposed function called jordanAlgebra? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called jordanAlgebra? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of jordanAlgebra? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of jordanAlgebra? from FiniteRankNonAssociativeAlgebra
--R
--E 1470

--S 1471 of 3320
)d op karatsuba
--R 
--R
--RThere is one exposed function called karatsuba :
--R   [1] (D1,D1,NonNegativeInteger,NonNegativeInteger) -> D1
--R             from UnivariatePolynomialMultiplicationPackage(D3,D1)
--R             if D3 has RING and D1 has UPOLYC(D3)
--R
--RExamples of karatsuba from UnivariatePolynomialMultiplicationPackage
--R
--E 1471

--S 1472 of 3320
)d op karatsubaDivide
--R 
--R
--RThere is one exposed function called karatsubaDivide :
--R   [1] (D,NonNegativeInteger) -> Record(quotient: D,remainder: D) from 
--R            D
--R             if D3 has RING and D has UPOLYC(D3)
--R
--RExamples of karatsubaDivide from UnivariatePolynomialCategory
--R
--E 1472

--S 1473 of 3320
)d op karatsubaOnce
--R 
--R
--RThere is one exposed function called karatsubaOnce :
--R   [1] (D1,D1) -> D1 from UnivariatePolynomialMultiplicationPackage(D2,
--R            D1)
--R             if D2 has RING and D1 has UPOLYC(D2)
--R
--RExamples of karatsubaOnce from UnivariatePolynomialMultiplicationPackage
--R
--E 1473

--S 1474 of 3320
)d op kernel
--R 
--R
--RThere are 2 exposed functions called kernel :
--R   [1] (BasicOperator,List(D)) -> D from D if D has ES
--R   [2] (BasicOperator,D) -> D from D if D has ES
--R
--RThere are 2 unexposed functions called kernel :
--R   [1] Symbol -> Kernel(D2) from Kernel(D2) if D2 has ORDSET
--R   [2] (BasicOperator,List(D4),NonNegativeInteger) -> Kernel(D4) from 
--R            Kernel(D4)
--R             if D4 has ORDSET
--R
--RExamples of kernel from ExpressionSpace
--R
--R
--RExamples of kernel from Kernel
--R
--E 1474

--S 1475 of 3320
)d op kernels
--R 
--R
--RThere is one exposed function called kernels :
--R   [1] D -> List(Kernel(D)) from D if D has ES
--R
--RExamples of kernels from ExpressionSpace
--R
--E 1475

--S 1476 of 3320
)d op key
--R 
--R
--RThere is one exposed function called key :
--R   [1] ThreeDimensionalViewport -> Integer from 
--R            ThreeDimensionalViewport
--R
--RThere are 2 unexposed functions called key :
--R   [1] GraphImage -> Integer from GraphImage
--R   [2] TwoDimensionalViewport -> Integer from TwoDimensionalViewport
--R         
--R
--RExamples of key from GraphImage
--R
--R
--RExamples of key from TwoDimensionalViewport
--R
--R
--RExamples of key from ThreeDimensionalViewport
--R
--E 1476

--S 1477 of 3320
)d op key?
--R 
--R
--RThere is one exposed function called key? :
--R   [1] (D2,D) -> Boolean from D
--R             if D has KDAGG(D2,D3) and D2 has SETCAT and D3 has SETCAT
--R            
--R
--RExamples of key? from KeyedDictionary
--R
--E 1477

--S 1478 of 3320
)d op keys
--R 
--R
--RThere are 3 exposed functions called keys :
--R   [1] IntegrationFunctionsTable -> List(Record(var: Symbol,fn: 
--R            Expression(DoubleFloat),range: Segment(OrderedCompletion(
--R            DoubleFloat)),abserr: DoubleFloat,relerr: DoubleFloat))
--R             from IntegrationFunctionsTable
--R   [2] D -> List(D2) from D if D has KDAGG(D2,D3) and D2 has SETCAT and
--R            D3 has SETCAT
--R   [3] ODEIntensityFunctionsTable -> List(Record(xinit: DoubleFloat,
--R            xend: DoubleFloat,fn: Vector(Expression(DoubleFloat)),yinit: List
--R            (DoubleFloat),intvals: List(DoubleFloat),g: Expression(
--R            DoubleFloat),abserr: DoubleFloat,relerr: DoubleFloat))
--R             from ODEIntensityFunctionsTable
--R
--RExamples of keys from IntegrationFunctionsTable
--R
--R
--RExamples of keys from KeyedDictionary
--R
--R
--RExamples of keys from ODEIntensityFunctionsTable
--R
--E 1478

--S 1479 of 3320
)d op kmax
--R 
--R
--RThere is one unexposed function called kmax :
--R   [1] List(Kernel(D4)) -> Kernel(D4) from IntegrationTools(D3,D4)
--R             if D3 has ORDSET and D4 has FS(D3)
--R
--RExamples of kmax from IntegrationTools
--R
--E 1479

--S 1480 of 3320
)d op knownInfBasis
--R 
--R
--RThere is one unexposed function called knownInfBasis :
--R   [1] NonNegativeInteger -> Void from AlgebraicFunctionField(D3,D4,D5,
--R            D6)
--R             if D3 has FIELD and D4 has UPOLYC(D3) and D5 has UPOLYC(
--R            FRAC(D4)) and D6: D5
--R
--RExamples of knownInfBasis from AlgebraicFunctionField
--R
--E 1480

--S 1481 of 3320
)d op kovacic
--R 
--R
--RThere are 2 unexposed functions called kovacic :
--R   [1] (Fraction(D4),Fraction(D4),Fraction(D4)) -> Union(
--R            SparseUnivariatePolynomial(Fraction(D4)),"failed")
--R             from Kovacic(D3,D4)
--R             if D3 has Join(CharacteristicZero,AlgebraicallyClosedField
--R            ,RetractableTo(Integer),RetractableTo(Fraction(Integer))) 
--R            and D4 has UPOLYC(D3)
--R   [2] (Fraction(D5),Fraction(D5),Fraction(D5),(D5 -> Factored(D5)))
--R             -> Union(SparseUnivariatePolynomial(Fraction(D5)),"failed")
--R             from Kovacic(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has Join(CharacteristicZero,
--R            AlgebraicallyClosedField,RetractableTo(Integer),
--R            RetractableTo(Fraction(Integer)))
--R
--RExamples of kovacic from Kovacic
--R
--E 1481

--S 1482 of 3320 done
)d op kroneckerDelta
--R 
--R
--RThere is one exposed function called kroneckerDelta :
--R   [1]  -> CartesianTensor(D1,D2,D3) from CartesianTensor(D1,D2,D3)
--R             if D1: INT and D2: NNI and D3 has COMRING
--R
--RExamples of kroneckerDelta from CartesianTensor
--R
--Rdelta:CartesianTensor(1,2,Integer):=kroneckerDelta()
--R
--E 1482

--S 1483 of 3320
)d op KrullNumber
--R 
--R
--RThere are 2 exposed functions called KrullNumber :
--R   [1] (List(D7),List(D8)) -> NonNegativeInteger
--R             from RegularSetDecompositionPackage(D4,D5,D6,D7,D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has RSETCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R   [2] (List(D7),List(D8)) -> NonNegativeInteger
--R             from SquareFreeRegularSetDecompositionPackage(D4,D5,D6,D7,
--R            D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has SFRTCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R
--RExamples of KrullNumber from RegularSetDecompositionPackage
--R
--R
--RExamples of KrullNumber from SquareFreeRegularSetDecompositionPackage
--R
--E 1483

--S 1484 of 3320
)d op ksec
--R 
--R
--RThere is one unexposed function called ksec :
--R   [1] (Kernel(D5),List(Kernel(D5)),Symbol) -> Kernel(D5)
--R             from IntegrationTools(D4,D5) if D5 has FS(D4) and D4 has 
--R            ORDSET
--R
--RExamples of ksec from IntegrationTools
--R
--E 1484

--S 1485 of 3320
)d op label
--R 
--R
--RThere is one unexposed function called label :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of label from OutputForm
--R
--E 1485

--S 1486 of 3320
)d op lagrange
--R 
--R
--RThere are 2 exposed functions called lagrange :
--R   [1] UnivariateFormalPowerSeries(D1) -> UnivariateFormalPowerSeries(
--R            D1)
--R             from UnivariateFormalPowerSeries(D1) if D1 has RING
--R   [2] UnivariateTaylorSeriesCZero(D1,D2) -> 
--R            UnivariateTaylorSeriesCZero(D1,D2)
--R             from UnivariateTaylorSeriesCZero(D1,D2) if D1 has RING and
--R            D2: SYMBOL
--R
--RThere are 2 unexposed functions called lagrange :
--R   [1] Stream(D2) -> Stream(D2) from StreamTaylorSeriesOperations(D2)
--R             if D2 has RING
--R   [2] UnivariateTaylorSeries(D1,D2,D3) -> UnivariateTaylorSeries(D1,D2
--R            ,D3)
--R             from UnivariateTaylorSeries(D1,D2,D3)
--R             if D1 has RING and D2: SYMBOL and D3: D1
--R
--RExamples of lagrange from StreamTaylorSeriesOperations
--R
--R
--RExamples of lagrange from UnivariateFormalPowerSeries
--R
--R
--RExamples of lagrange from UnivariateTaylorSeries
--R
--R
--RExamples of lagrange from UnivariateTaylorSeriesCZero
--R
--E 1486

--S 1487 of 3320
)d op LagrangeInterpolation
--R 
--R
--RThere is one unexposed function called LagrangeInterpolation :
--R   [1] (List(D3),List(D3)) -> D1 from PolynomialInterpolationAlgorithms
--R            (D3,D1)
--R             if D3 has FIELD and D1 has UPOLYC(D3)
--R
--RExamples of LagrangeInterpolation from PolynomialInterpolationAlgorithms
--R
--E 1487

--S 1488 of 3320
)d op laguerre
--R 
--R
--RThere is one unexposed function called laguerre :
--R   [1] Integer -> SparseUnivariatePolynomial(Integer)
--R             from PolynomialNumberTheoryFunctions
--R
--RExamples of laguerre from PolynomialNumberTheoryFunctions
--R
--E 1488

--S 1489 of 3320
)d op laguerreL
--R 
--R
--RThere are 2 exposed functions called laguerreL :
--R   [1] (NonNegativeInteger,D1) -> D1 from OrthogonalPolynomialFunctions
--R            (D1)
--R             if D1 has COMRING
--R   [2] (NonNegativeInteger,NonNegativeInteger,D1) -> D1
--R             from OrthogonalPolynomialFunctions(D1) if D1 has COMRING
--R         
--R
--RExamples of laguerreL from OrthogonalPolynomialFunctions
--R
--E 1489

--S 1490 of 3320
)d op lambda
--R 
--R
--RThere is one unexposed function called lambda :
--R   [1] (InputForm,List(Symbol)) -> InputForm from InputForm
--R
--RExamples of lambda from InputForm
--R
--E 1490

--S 1491 of 3320
)d op lambert
--R 
--R
--RThere are 2 exposed functions called lambert :
--R   [1] UnivariateFormalPowerSeries(D1) -> UnivariateFormalPowerSeries(
--R            D1)
--R             from UnivariateFormalPowerSeries(D1) if D1 has RING
--R   [2] UnivariateTaylorSeriesCZero(D1,D2) -> 
--R            UnivariateTaylorSeriesCZero(D1,D2)
--R             from UnivariateTaylorSeriesCZero(D1,D2) if D1 has RING and
--R            D2: SYMBOL
--R
--RThere are 2 unexposed functions called lambert :
--R   [1] Stream(D2) -> Stream(D2) from StreamTaylorSeriesOperations(D2)
--R             if D2 has RING
--R   [2] UnivariateTaylorSeries(D1,D2,D3) -> UnivariateTaylorSeries(D1,D2
--R            ,D3)
--R             from UnivariateTaylorSeries(D1,D2,D3)
--R             if D1 has RING and D2: SYMBOL and D3: D1
--R
--RExamples of lambert from StreamTaylorSeriesOperations
--R
--R
--RExamples of lambert from UnivariateFormalPowerSeries
--R
--R
--RExamples of lambert from UnivariateTaylorSeries
--R
--R
--RExamples of lambert from UnivariateTaylorSeriesCZero
--R
--E 1491

--S 1492 of 3320
)d op laplace
--R 
--R
--RThere is one exposed function called laplace :
--R   [1] (D1,Symbol,Symbol) -> D1 from LaplaceTransform(D3,D1)
--R             if D3 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer)) and D1 has Join(
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory,
--R            AlgebraicallyClosedFunctionSpace(D3))
--R
--RExamples of laplace from LaplaceTransform
--R
--E 1492

--S 1493 of 3320
)d op laplacian
--R 
--R
--RThere is one exposed function called laplacian :
--R   [1] (D1,D2) -> D1 from MultiVariableCalculusFunctions(D3,D1,D4,D2)
--R             if D3 has SETCAT and D1 has PDRING(D3) and D4 has FLAGG(D1
--R            ) and D2 has FiniteLinearAggregate(D3)with
--R                 finiteAggregate
--R
--RExamples of laplacian from MultiVariableCalculusFunctions
--R
--E 1493

--S 1494 of 3320
)d op largest
--R 
--R
--RThere are 2 unexposed functions called largest :
--R   [1] (List(D1),((D1,D1) -> Boolean)) -> D1 from 
--R            UserDefinedPartialOrdering(D1)
--R             if D1 has SETCAT
--R   [2] List(D1) -> D1 from UserDefinedPartialOrdering(D1)
--R             if D1 has SETCAT and D1 has ORDSET
--R
--RExamples of largest from UserDefinedPartialOrdering
--R
--E 1494

--S 1495 of 3320
)d op last
--R 
--R
--RThere are 4 exposed functions called last :
--R   [1] D -> D1 from D if D has DLAGG(D1) and D1 has TYPE
--R   [2] D -> Union(D1,"failed") from D
--R             if D has TSETCAT(D2,D3,D4,D1) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D1 has RPOLCAT(D2,D3,D4)
--R            
--R   [3] (D,NonNegativeInteger) -> D from D if D has URAGG(D2) and D2
--R             has TYPE
--R   [4] D -> D1 from D if D has URAGG(D1) and D1 has TYPE
--R
--RExamples of last from DoublyLinkedAggregate
--R
--R
--RExamples of last from TriangularSetCategory
--R
--R
--RExamples of last from UnaryRecursiveAggregate
--R
--Rlast([1,4,2,-6,0,3,5,4,2,3],3)
--R
--Rlast [1,4,2,-6,0,3,5,4,2,3]
--R
--E 1495

--S 1496 of 3320
)d op lastNonNul
--R 
--R
--RThere is one exposed function called lastNonNul :
--R   [1] D -> Integer from D if D has PRSPCAT(D2) and D2 has FIELD
--R
--RExamples of lastNonNul from ProjectiveSpaceCategory
--R
--E 1496

--S 1497 of 3320
)d op lastNonNull
--R 
--R
--RThere is one exposed function called lastNonNull :
--R   [1] D -> Integer from D if D has PRSPCAT(D2) and D2 has FIELD
--R
--RExamples of lastNonNull from ProjectiveSpaceCategory
--R
--E 1497

--S 1498 of 3320
)d op lastSubResultant
--R 
--R
--RThere are 2 exposed functions called lastSubResultant :
--R   [1] (D,D) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has INTDOM
--R   [2] (D2,D2,D) -> List(Record(val: D2,tower: D)) from D
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5) and D has RSETCAT(D3,D4,D5,D2)
--R
--RThere are 2 unexposed functions called lastSubResultant :
--R   [1] (NewSparseUnivariatePolynomial(D1),NewSparseUnivariatePolynomial
--R            (D1)) -> NewSparseUnivariatePolynomial(D1)
--R             from NewSparseUnivariatePolynomial(D1) if D1 has INTDOM 
--R            and D1 has RING
--R   [2] (D1,D1) -> D1 from PseudoRemainderSequence(D2,D1)
--R             if D2 has INTDOM and D1 has UPOLYC(D2)
--R
--RExamples of lastSubResultant from NewSparseUnivariatePolynomial
--R
--R
--RExamples of lastSubResultant from PseudoRemainderSequence
--R
--R
--RExamples of lastSubResultant from RecursivePolynomialCategory
--R
--R
--RExamples of lastSubResultant from RegularTriangularSetCategory
--R
--E 1498

--S 1499 of 3320
)d op lastSubResultantElseSplit
--R 
--R
--RThere is one exposed function called lastSubResultantElseSplit :
--R   [1] (D2,D2,D) -> Union(D2,List(D)) from D
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5) and D has RSETCAT(D3,D4,D5,D2)
--R
--RExamples of lastSubResultantElseSplit from RegularTriangularSetCategory
--R
--E 1499

--S 1500 of 3320
)d op lastSubResultantEuclidean
--R 
--R
--RThere is one unexposed function called lastSubResultantEuclidean :
--R   [1] (D2,D2) -> Record(coef1: D2,coef2: D2,subResultant: D2)
--R             from PseudoRemainderSequence(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of lastSubResultantEuclidean from PseudoRemainderSequence
--R
--E 1500

--S 1501 of 3320
)d op latex
--R 
--R
--RThere are 6 exposed functions called latex :
--R   [1] ArrayStack(D2) -> String from ArrayStack(D2)
--R             if D2 has SETCAT and D2 has SETCAT
--R   [2] Dequeue(D2) -> String from Dequeue(D2) if D2 has SETCAT and D2
--R             has SETCAT
--R   [3] Heap(D2) -> String from Heap(D2) if D2 has SETCAT and D2 has 
--R            ORDSET
--R   [4] Queue(D2) -> String from Queue(D2) if D2 has SETCAT and D2 has 
--R            SETCAT
--R   [5] D -> String from D if D has SETCAT
--R   [6] Stack(D2) -> String from Stack(D2) if D2 has SETCAT and D2 has 
--R            SETCAT
--R
--RExamples of latex from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rlatex a
--R
--R
--RExamples of latex from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rlatex a
--R
--R
--RExamples of latex from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rlatex a
--R
--R
--RExamples of latex from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rlatex a
--R
--R
--RExamples of latex from SetCategory
--R
--R
--RExamples of latex from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rlatex a
--R
--E 1501

--S 1502 of 3320
)d op laurent
--R 
--R
--RThere are 9 exposed functions called laurent :
--R   [1] Symbol -> Any from ExpressionToUnivariatePowerSeries(D3,D4)
--R             if D3 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D4 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R   [2] D2 -> Any from ExpressionToUnivariatePowerSeries(D3,D2)
--R             if D3 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R   [3] (D2,Integer) -> Any from ExpressionToUnivariatePowerSeries(D4,D2
--R            )
--R             if D4 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D4))
--R   [4] (D2,Equation(D2)) -> Any from ExpressionToUnivariatePowerSeries(
--R            D4,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D4)) and D4
--R             has Join(GcdDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [5] (D2,Equation(D2),Integer) -> Any
--R             from ExpressionToUnivariatePowerSeries(D5,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D5)) and D5
--R             has Join(GcdDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [6] ((Integer -> D6),Equation(D6),UniversalSegment(Integer)) -> Any
--R             from GenerateUnivariatePowerSeries(D5,D6)
--R             if D6 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D5)) and D5
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [7] (D2,Symbol,Equation(D2),UniversalSegment(Integer)) -> Any
--R             from GenerateUnivariatePowerSeries(D6,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D6)) and D6
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [8] (Integer,D2) -> D from D
--R             if D3 has RING and D has ULSCCAT(D3,D2) and D2 has UTSCAT(
--R            D3)
--R   [9] D -> D1 from D if D has UPXSCCA(D2,D1) and D2 has RING and D1
--R             has ULSCAT(D2)
--R
--RExamples of laurent from ExpressionToUnivariatePowerSeries
--R
--R
--RExamples of laurent from GenerateUnivariatePowerSeries
--R
--R
--RExamples of laurent from UnivariateLaurentSeriesConstructorCategory
--R
--R
--RExamples of laurent from UnivariatePuiseuxSeriesConstructorCategory
--R
--E 1502

--S 1503 of 3320
)d op laurentIfCan
--R 
--R
--RThere is one exposed function called laurentIfCan :
--R   [1] D -> Union(D1,"failed") from D
--R             if D has UPXSCCA(D2,D1) and D2 has RING and D1 has ULSCAT(
--R            D2)
--R
--RExamples of laurentIfCan from UnivariatePuiseuxSeriesConstructorCategory
--R
--E 1503

--S 1504 of 3320
)d op laurentRep
--R 
--R
--RThere is one exposed function called laurentRep :
--R   [1] D -> D1 from D if D has UPXSCCA(D2,D1) and D2 has RING and D1
--R             has ULSCAT(D2)
--R
--RExamples of laurentRep from UnivariatePuiseuxSeriesConstructorCategory
--R
--E 1504

--S 1505 of 3320
)d op Lazard
--R 
--R
--RThere is one unexposed function called Lazard :
--R   [1] (D1,D1,NonNegativeInteger) -> D1 from PseudoRemainderSequence(D1
--R            ,D3)
--R             if D1 has INTDOM and D3 has UPOLYC(D1)
--R
--RExamples of Lazard from PseudoRemainderSequence
--R
--E 1505

--S 1506 of 3320
)d op Lazard2
--R 
--R
--RThere is one unexposed function called Lazard2 :
--R   [1] (D1,D2,D2,NonNegativeInteger) -> D1 from PseudoRemainderSequence
--R            (D2,D1)
--R             if D2 has INTDOM and D1 has UPOLYC(D2)
--R
--RExamples of Lazard2 from PseudoRemainderSequence
--R
--E 1506

--S 1507 of 3320
)d op LazardQuotient
--R 
--R
--RThere is one exposed function called LazardQuotient :
--R   [1] (D,D,NonNegativeInteger) -> D from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D2 has INTDOM
--R
--RExamples of LazardQuotient from RecursivePolynomialCategory
--R
--E 1507

--S 1508 of 3320
)d op LazardQuotient2
--R 
--R
--RThere is one exposed function called LazardQuotient2 :
--R   [1] (D,D,D,NonNegativeInteger) -> D from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D2 has INTDOM
--R
--RExamples of LazardQuotient2 from RecursivePolynomialCategory
--R
--E 1508

--S 1509 of 3320 done
)d op lazy?
--R 
--R
--RThere is one exposed function called lazy? :
--R   [1] D -> Boolean from D if D has LZSTAGG(D2) and D2 has TYPE
--R
--RExamples of lazy? from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--Rlazy? m
--R
--E 1509

--S 1510 of 3320
)d op lazyEvaluate
--R 
--R
--RThere is one exposed function called lazyEvaluate :
--R   [1] D -> D from D if D has LZSTAGG(D1) and D1 has TYPE
--R
--RExamples of lazyEvaluate from LazyStreamAggregate
--R
--E 1510

--S 1511 of 3320
)d op lazyGintegrate
--R 
--R
--RThere is one unexposed function called lazyGintegrate :
--R   [1] ((Integer -> D3),D3,(() -> Stream(D3))) -> Stream(D3)
--R             from StreamTaylorSeriesOperations(D3) if D3 has FIELD and 
--R            D3 has RING
--R
--RExamples of lazyGintegrate from StreamTaylorSeriesOperations
--R
--E 1511

--S 1512 of 3320
)d op lazyIntegrate
--R 
--R
--RThere is one unexposed function called lazyIntegrate :
--R   [1] (D2,(() -> Stream(D2))) -> Stream(D2)
--R             from StreamTaylorSeriesOperations(D2)
--R             if D2 has ALGEBRA(FRAC(INT)) and D2 has RING
--R
--RExamples of lazyIntegrate from StreamTaylorSeriesOperations
--R
--E 1512

--S 1513 of 3320
)d op lazyIrreducibleFactors
--R 
--R
--RThere is one unexposed function called lazyIrreducibleFactors :
--R   [1] List(D5) -> List(D5) from PolynomialSetUtilitiesPackage(D2,D3,D4
--R            ,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has CHARZ and D2 has 
--R            EUCDOM and D2 has INTDOM and D3 has OAMONS and D4 has 
--R            ORDSET
--R
--RExamples of lazyIrreducibleFactors from PolynomialSetUtilitiesPackage
--R
--E 1513

--S 1514 of 3320
)d op lazyPquo
--R 
--R
--RThere are 2 exposed functions called lazyPquo :
--R   [1] (D,D,D1) -> D from D
--R             if D has RPOLCAT(D2,D3,D1) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET
--R   [2] (D,D) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R
--RExamples of lazyPquo from RecursivePolynomialCategory
--R
--E 1514

--S 1515 of 3320
)d op lazyPrem
--R 
--R
--RThere are 2 exposed functions called lazyPrem :
--R   [1] (D,D,D1) -> D from D
--R             if D has RPOLCAT(D2,D3,D1) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET
--R   [2] (D,D) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R
--RExamples of lazyPrem from RecursivePolynomialCategory
--R
--E 1515

--S 1516 of 3320
)d op lazyPremWithDefault
--R 
--R
--RThere are 2 exposed functions called lazyPremWithDefault :
--R   [1] (D,D,D2) -> Record(coef: D,gap: NonNegativeInteger,remainder: D)
--R             from D
--R             if D3 has RING and D4 has OAMONS and D2 has ORDSET and D
--R             has RPOLCAT(D3,D4,D2)
--R   [2] (D,D) -> Record(coef: D,gap: NonNegativeInteger,remainder: D)
--R             from D
--R             if D2 has RING and D3 has OAMONS and D4 has ORDSET and D
--R             has RPOLCAT(D2,D3,D4)
--R
--RExamples of lazyPremWithDefault from RecursivePolynomialCategory
--R
--E 1516

--S 1517 of 3320
)d op lazyPseudoDivide
--R 
--R
--RThere are 2 exposed functions called lazyPseudoDivide :
--R   [1] (D,D,D2) -> Record(coef: D,gap: NonNegativeInteger,quotient: D,
--R            remainder: D)
--R             from D
--R             if D3 has RING and D4 has OAMONS and D2 has ORDSET and D
--R             has RPOLCAT(D3,D4,D2)
--R   [2] (D,D) -> Record(coef: D,gap: NonNegativeInteger,quotient: D,
--R            remainder: D)
--R             from D
--R             if D2 has RING and D3 has OAMONS and D4 has ORDSET and D
--R             has RPOLCAT(D2,D3,D4)
--R
--RThere is one unexposed function called lazyPseudoDivide :
--R   [1] (NewSparseUnivariatePolynomial(D2),NewSparseUnivariatePolynomial
--R            (D2)) -> Record(coef: D2,gap: NonNegativeInteger,quotient: 
--R            NewSparseUnivariatePolynomial(D2),remainder: 
--R            NewSparseUnivariatePolynomial(D2))
--R             from NewSparseUnivariatePolynomial(D2) if D2 has RING
--R
--RExamples of lazyPseudoDivide from NewSparseUnivariatePolynomial
--R
--R
--RExamples of lazyPseudoDivide from RecursivePolynomialCategory
--R
--E 1517

--S 1518 of 3320
)d op lazyPseudoQuotient
--R 
--R
--RThere is one unexposed function called lazyPseudoQuotient :
--R   [1] (NewSparseUnivariatePolynomial(D1),NewSparseUnivariatePolynomial
--R            (D1)) -> NewSparseUnivariatePolynomial(D1)
--R             from NewSparseUnivariatePolynomial(D1) if D1 has RING
--R
--RExamples of lazyPseudoQuotient from NewSparseUnivariatePolynomial
--R
--E 1518

--S 1519 of 3320
)d op lazyPseudoRemainder
--R 
--R
--RThere is one unexposed function called lazyPseudoRemainder :
--R   [1] (NewSparseUnivariatePolynomial(D1),NewSparseUnivariatePolynomial
--R            (D1)) -> NewSparseUnivariatePolynomial(D1)
--R             from NewSparseUnivariatePolynomial(D1) if D1 has RING
--R
--RExamples of lazyPseudoRemainder from NewSparseUnivariatePolynomial
--R
--E 1519

--S 1520 of 3320
)d op lazyResidueClass
--R 
--R
--RThere is one exposed function called lazyResidueClass :
--R   [1] (D,D) -> Record(polnum: D,polden: D,power: NonNegativeInteger)
--R             from D
--R             if D2 has RING and D3 has OAMONS and D4 has ORDSET and D
--R             has RPOLCAT(D2,D3,D4)
--R
--RThere is one unexposed function called lazyResidueClass :
--R   [1] (NewSparseUnivariatePolynomial(D2),NewSparseUnivariatePolynomial
--R            (D2)) -> Record(polnum: NewSparseUnivariatePolynomial(D2),polden
--R            : D2,power: NonNegativeInteger)
--R             from NewSparseUnivariatePolynomial(D2) if D2 has RING
--R
--RExamples of lazyResidueClass from NewSparseUnivariatePolynomial
--R
--R
--RExamples of lazyResidueClass from RecursivePolynomialCategory
--R
--E 1520

--S 1521 of 3320
)d op lazyVariations
--R 
--R
--RThere is one exposed function called lazyVariations :
--R   [1] (List(D4),Integer,Integer) -> NonNegativeInteger
--R             from RealPolynomialUtilitiesPackage(D4,D5)
--R             if D4 has ORDRING and D4 has FIELD and D5 has UPOLYC(D4)
--R         
--R
--RExamples of lazyVariations from RealPolynomialUtilitiesPackage
--R
--E 1521

--S 1522 of 3320
)d op lBasis
--R 
--R
--RThere are 5 exposed functions called lBasis :
--R   [1] D6 -> Record(num: List(D9),den: D9)
--R             from GeneralPackageForAlgebraicFunctionField(D7,D8,D9,D10,
--R            D11,D12,D1,D6,D2,D3,D4)
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D9 has POLYCAT(D7
--R            ,D10,OVAR(D8)) and D10 has DIRPCAT(#(D8),NNI) and D11 has 
--R            PRSPCAT(D7) and D12 has LOCPOWC(D7) and D1 has PLACESC(D7,
--R            D12) and D6 has DIVCAT(D1) and D2 has INFCLCT(D7,D8,D9,D10,
--R            D11,D12,D1,D6,D4) and D4 has BLMETCT and D3 has DSTRCAT(D2)
--R            
--R   [2] (Divisor(PlacesOverPseudoAlgebraicClosureOfFiniteField(D4)),
--R            NonNegativeInteger) -> List(Fraction(
--R            DistributedMultivariatePolynomial(D5,D4)))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D4,D5
--R            ,D6)
--R             if D4 has FFIELDC and D5: LIST(SYMBOL) and D6 has BLMETCT
--R            
--R   [3] Divisor(PlacesOverPseudoAlgebraicClosureOfFiniteField(D3)) -> 
--R            Record(num: List(DistributedMultivariatePolynomial(D4,D3)),den: 
--R            DistributedMultivariatePolynomial(D4,D3))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D3,D4
--R            ,D5)
--R             if D3 has FFIELDC and D4: LIST(SYMBOL) and D5 has BLMETCT
--R            
--R   [4] (Divisor(Places(D4)),NonNegativeInteger) -> List(Fraction(
--R            DistributedMultivariatePolynomial(D5,D4)))
--R             from PackageForAlgebraicFunctionField(D4,D5,D6)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D6 has BLMETCT
--R         
--R   [5] Divisor(Places(D3)) -> Record(num: List(
--R            DistributedMultivariatePolynomial(D4,D3)),den: 
--R            DistributedMultivariatePolynomial(D4,D3))
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D5 has BLMETCT
--R         
--R
--RExamples of lBasis from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of lBasis from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of lBasis from PackageForAlgebraicFunctionField
--R
--E 1522

--S 1523 of 3320
)d op lcm
--R 
--R
--RThere are 3 exposed functions called lcm :
--R   [1] List(D) -> D from D if D has GCDDOM
--R   [2] (D,D) -> D from D if D has GCDDOM
--R   [3] (PrimitiveArray(U32Vector),Integer,Integer,Integer) -> U32Vector
--R             from U32VectorPolynomialOperations
--R
--RExamples of lcm from GcdDomain
--R
--R
--RExamples of lcm from U32VectorPolynomialOperations
--R
--E 1523

--S 1524 of 3320
)d op lcmCoef
--R 
--R
--RThere is one exposed function called lcmCoef :
--R   [1] (D,D) -> Record(llcmres: D,coeff1: D,coeff2: D) from D if D has 
--R            LORER
--R
--RExamples of lcmCoef from LeftOreRing
--R
--E 1524

--S 1525 of 3320
)d op ldf2lst
--R 
--R
--RThere are 3 exposed functions called ldf2lst :
--R   [1] List(DoubleFloat) -> List(String) from d01AgentsPackage
--R   [2] List(DoubleFloat) -> List(String) from 
--R            ExpertSystemContinuityPackage
--R   [3] List(DoubleFloat) -> List(String) from ExpertSystemToolsPackage
--R            
--R
--RExamples of ldf2lst from d01AgentsPackage
--R
--R
--RExamples of ldf2lst from ExpertSystemContinuityPackage
--R
--R
--RExamples of ldf2lst from ExpertSystemToolsPackage
--R
--E 1525

--S 1526 of 3320
)d op ldf2vmf
--R 
--R
--RThere is one exposed function called ldf2vmf :
--R   [1] List(DoubleFloat) -> Vector(MachineFloat) from 
--R            ExpertSystemToolsPackage
--R
--RExamples of ldf2vmf from ExpertSystemToolsPackage
--R
--E 1526

--S 1527 of 3320
)d op LE
--R 
--R
--RThere is one exposed function called LE :
--R   [1] (Union(I: Expression(Integer),F: Expression(Float),CF: 
--R            Expression(Complex(Float)),switch: Switch),Union(I: Expression(
--R            Integer),F: Expression(Float),CF: Expression(Complex(Float)),
--R            switch: Switch)) -> Switch
--R             from Switch
--R
--RExamples of LE from Switch
--R
--E 1527

--S 1528 of 3320
)d op leader
--R 
--R
--RThere is one exposed function called leader :
--R   [1] D -> D1 from D
--R             if D has DPOLCAT(D2,D3,D1,D4) and D2 has RING and D3 has 
--R            ORDSET and D4 has OAMONS and D1 has DVARCAT(D3)
--R
--RExamples of leader from DifferentialPolynomialCategory
--R
--E 1528

--S 1529 of 3320
)d op leadingBasisTerm
--R 
--R
--RThere are 2 unexposed functions called leadingBasisTerm :
--R   [1] AntiSymm(D1,D2) -> AntiSymm(D1,D2) from AntiSymm(D1,D2)
--R             if D1 has RING and D2: LIST(SYMBOL)
--R   [2] DeRhamComplex(D1,D2) -> DeRhamComplex(D1,D2) from DeRhamComplex(
--R            D1,D2)
--R             if D1 has Join(Ring,OrderedSet) and D2: LIST(SYMBOL)
--R
--RExamples of leadingBasisTerm from AntiSymm
--R
--R
--RExamples of leadingBasisTerm from DeRhamComplex
--R
--Rder:=DERHAM(Integer,[x,y,z]) 
--R[dx,dy,dz]:=[generator(i)$der for i in 1..3] 
--Rf:BOP:=operator('f) 
--Rg:BOP:=operator('g) 
--Rh:BOP:=operator('h) 
--Rsigma:=f(x,y,z)*dx + g(x,y,z)*dy + h(x,y,z)*dz 
--RleadingBasisTerm sigma
--R
--E 1529

--S 1530 of 3320
)d op leadingCoefficient
--R 
--R
--RThere are 7 exposed functions called leadingCoefficient :
--R   [1] D -> D1 from D if D has AMR(D1,D2) and D2 has OAMON and D1 has 
--R            RING
--R   [2] D -> D1 from D if D has FMCAT(D1,D2) and D2 has SETCAT and D1
--R             has RING
--R   [3] D -> D1 from D if D has IDPC(D1,D2) and D2 has ORDSET and D1
--R             has SETCAT
--R   [4] D -> D1 from D if D has MLO(D1) and D1 has RING
--R   [5] D -> D1 from D if D has OREPCAT(D1) and D1 has RING
--R   [6] D -> D1 from D
--R             if D has PSCAT(D1,D2,D3) and D2 has OAMON and D3 has 
--R            ORDSET and D1 has RING
--R   [7] (D,D1) -> D from D
--R             if D has RPOLCAT(D2,D3,D1) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET
--R
--RThere are 5 unexposed functions called leadingCoefficient :
--R   [1] AntiSymm(D1,D2) -> D1 from AntiSymm(D1,D2) if D1 has RING and D2
--R            : LIST(SYMBOL)
--R   [2] DeRhamComplex(D2,D3) -> Expression(D2) from DeRhamComplex(D2,D3)
--R             if D2 has Join(Ring,OrderedSet) and D3: LIST(SYMBOL)
--R   [3] GeneralModulePolynomial(D2,D1,D3,D4,D5,D6) -> D1
--R             from GeneralModulePolynomial(D2,D1,D3,D4,D5,D6)
--R             if D2: LIST(SYMBOL) and D4 has DIRPCAT(#(D2),NNI) and D5: 
--R            ((Record(index: D3,exponent: D4),Record(index: D3,exponent
--R            : D4)) -> Boolean) and D1 has COMRING and D3 has ORDSET and
--R            D6 has POLYCAT(D1,D4,OVAR(D2))
--R   [4] LaurentPolynomial(D1,D2) -> D1 from LaurentPolynomial(D1,D2)
--R             if D1 has INTDOM and D2 has UPOLYC(D1)
--R   [5] MonoidRing(D1,D2) -> D1 from MonoidRing(D1,D2)
--R             if D1 has RING and D2 has ORDSET and D2 has MONOID
--R
--RExamples of leadingCoefficient from AbelianMonoidRing
--R
--R
--RExamples of leadingCoefficient from AntiSymm
--R
--R
--RExamples of leadingCoefficient from DeRhamComplex
--R
--Rder:=DERHAM(Integer,[x,y,z]) 
--R[dx,dy,dz]:=[generator(i)$der for i in 1..3] 
--Rf:BOP:=operator('f) 
--Rg:BOP:=operator('g) 
--Rh:BOP:=operator('h) 
--Rsigma:=f(x,y,z)*dx + g(x,y,z)*dy + h(x,y,z)*dz 
--RleadingCoefficient sigma
--R
--R
--RExamples of leadingCoefficient from FreeModuleCat
--R
--R
--RExamples of leadingCoefficient from GeneralModulePolynomial
--R
--R
--RExamples of leadingCoefficient from IndexedDirectProductCategory
--R
--R
--RExamples of leadingCoefficient from LaurentPolynomial
--R
--R
--RExamples of leadingCoefficient from MonogenicLinearOperator
--R
--R
--RExamples of leadingCoefficient from MonoidRing
--R
--R
--RExamples of leadingCoefficient from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of leadingCoefficient from PowerSeriesCategory
--R
--R
--RExamples of leadingCoefficient from RecursivePolynomialCategory
--R
--E 1530

--S 1531 of 3320
)d op leadingCoefficientRicDE
--R 
--R
--RThere is one unexposed function called leadingCoefficientRicDE :
--R   [1] D2 -> List(Record(deg: NonNegativeInteger,eq: D4))
--R             from PrimitiveRatRicDE(D3,D4,D2,D5)
--R             if D3 has Join(Field,CharacteristicZero,RetractableTo(
--R            Fraction(Integer))) and D4 has UPOLYC(D3) and D2 has 
--R            LODOCAT(D4) and D5 has LODOCAT(FRAC(D4))
--R
--RExamples of leadingCoefficientRicDE from PrimitiveRatRicDE
--R
--E 1531

--S 1532 of 3320
)d op leadingExponent
--R 
--R
--RThere is one unexposed function called leadingExponent :
--R   [1] GeneralModulePolynomial(D2,D3,D4,D1,D5,D6) -> D1
--R             from GeneralModulePolynomial(D2,D3,D4,D1,D5,D6)
--R             if D2: LIST(SYMBOL) and D3 has COMRING and D5: ((Record(
--R            index: D4,exponent: D1),Record(index: D4,exponent: D1)) -> 
--R            Boolean) and D1 has DIRPCAT(#(D2),NNI) and D4 has ORDSET 
--R            and D6 has POLYCAT(D3,D1,OVAR(D2))
--R
--RExamples of leadingExponent from GeneralModulePolynomial
--R
--E 1532

--S 1533 of 3320
)d op leadingIdeal
--R 
--R
--RThere is one exposed function called leadingIdeal :
--R   [1] PolynomialIdeals(D1,D2,D3,D4) -> PolynomialIdeals(D1,D2,D3,D4)
--R             from PolynomialIdeals(D1,D2,D3,D4)
--R             if D1 has FIELD and D2 has OAMONS and D3 has ORDSET and D4
--R             has POLYCAT(D1,D2,D3)
--R
--RExamples of leadingIdeal from PolynomialIdeals
--R
--E 1533

--S 1534 of 3320
)d op leadingIndex
--R 
--R
--RThere is one unexposed function called leadingIndex :
--R   [1] GeneralModulePolynomial(D2,D3,D1,D4,D5,D6) -> D1
--R             from GeneralModulePolynomial(D2,D3,D1,D4,D5,D6)
--R             if D2: LIST(SYMBOL) and D3 has COMRING and D4 has DIRPCAT(
--R            #(D2),NNI) and D5: ((Record(index: D1,exponent: D4),Record(
--R            index: D1,exponent: D4)) -> Boolean) and D1 has ORDSET and 
--R            D6 has POLYCAT(D3,D4,OVAR(D2))
--R
--RExamples of leadingIndex from GeneralModulePolynomial
--R
--E 1534

--S 1535 of 3320
)d op leadingMonomial
--R 
--R
--RThere are 3 exposed functions called leadingMonomial :
--R   [1] D -> D from D if D has AMR(D1,D2) and D1 has RING and D2 has 
--R            OAMON
--R   [2] D -> D1 from D if D has FMCAT(D2,D1) and D2 has RING and D1 has 
--R            SETCAT
--R   [3] D -> D from D
--R             if D has PSCAT(D1,D2,D3) and D1 has RING and D2 has OAMON 
--R            and D3 has ORDSET
--R
--RThere are 2 unexposed functions called leadingMonomial :
--R   [1] GeneralModulePolynomial(D2,D3,D4,D5,D6,D7) -> ModuleMonomial(D4,
--R            D5,D6)
--R             from GeneralModulePolynomial(D2,D3,D4,D5,D6,D7)
--R             if D2: LIST(SYMBOL) and D3 has COMRING and D5 has DIRPCAT(
--R            #(D2),NNI) and D6: ((Record(index: D4,exponent: D5),Record(
--R            index: D4,exponent: D5)) -> Boolean) and D4 has ORDSET and 
--R            D7 has POLYCAT(D3,D5,OVAR(D2))
--R   [2] MonoidRing(D2,D1) -> D1 from MonoidRing(D2,D1)
--R             if D1 has MONOID and D1 has ORDSET and D2 has RING
--R
--RExamples of leadingMonomial from AbelianMonoidRing
--R
--R
--RExamples of leadingMonomial from FreeModuleCat
--R
--R
--RExamples of leadingMonomial from GeneralModulePolynomial
--R
--R
--RExamples of leadingMonomial from MonoidRing
--R
--R
--RExamples of leadingMonomial from PowerSeriesCategory
--R
--E 1535

--S 1536 of 3320
)d op leadingSupport
--R 
--R
--RThere is one exposed function called leadingSupport :
--R   [1] D -> D1 from D if D has IDPC(D2,D1) and D2 has SETCAT and D1
--R             has ORDSET
--R
--RExamples of leadingSupport from IndexedDirectProductCategory
--R
--E 1536

--S 1537 of 3320
)d op leadingTerm
--R 
--R
--RThere is one exposed function called leadingTerm :
--R   [1] D -> Record(k: D3,c: D2) from D
--R             if D has FMCAT(D2,D3) and D2 has RING and D3 has SETCAT
--R         
--R
--RExamples of leadingTerm from FreeModuleCat
--R
--E 1537

--S 1538 of 3320
)d op leaf?
--R 
--R
--RThere are 2 exposed functions called leaf? :
--R   [1] D -> Boolean from D
--R             if D has PLACESC(D2,D3) and D2 has FIELD and D3 has 
--R            LOCPOWC(D2)
--R   [2] D -> Boolean from D if D has RCAGG(D2) and D2 has TYPE
--R
--RThere is one unexposed function called leaf? :
--R   [1] SubSpace(D2,D3) -> Boolean from SubSpace(D2,D3) if D2: PI and D3
--R             has RING
--R
--RExamples of leaf? from PlacesCategory
--R
--R
--RExamples of leaf? from RecursiveAggregate
--R
--R
--RExamples of leaf? from SubSpace
--R
--E 1538

--S 1539 of 3320
)d op leastAffineMultiple
--R 
--R
--RThere is one unexposed function called leastAffineMultiple :
--R   [1] SparseUnivariatePolynomial(D2) -> SparseUnivariatePolynomial(D2)
--R             from FiniteFieldPolynomialPackage(D2) if D2 has FFIELDC
--R         
--R
--RExamples of leastAffineMultiple from FiniteFieldPolynomialPackage
--R
--E 1539

--S 1540 of 3320
)d op leastMonomial
--R 
--R
--RThere is one exposed function called leastMonomial :
--R   [1] D -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R
--RExamples of leastMonomial from RecursivePolynomialCategory
--R
--E 1540

--S 1541 of 3320
)d op leastPower
--R 
--R
--RThere is one unexposed function called leastPower :
--R   [1] (NonNegativeInteger,NonNegativeInteger) -> NonNegativeInteger
--R             from IntegralBasisTools(D2,D3,D4)
--R             if D2 has EuclideanDomainwith
--R               squareFree : % -> Factored(%)and D3 has UPOLYC(D2) 
--R            and D4 has FRAMALG(D2,D3)
--R
--RExamples of leastPower from IntegralBasisTools
--R
--E 1541

--S 1542 of 3320
)d op leaves
--R 
--R
--RThere is one exposed function called leaves :
--R   [1] D -> List(D2) from D if D has RCAGG(D2) and D2 has TYPE
--R
--RExamples of leaves from RecursiveAggregate
--R
--E 1542

--S 1543 of 3320
)d op left
--R 
--R
--RThere are 2 exposed functions called left :
--R   [1] D -> D from D if D has BRAGG(D1) and D1 has TYPE
--R   [2] RightOpenIntervalRootCharacterization(D1,D2) -> D1
--R             from RightOpenIntervalRootCharacterization(D1,D2)
--R             if D1 has Join(OrderedRing,Field) and D2 has UPOLYC(D1)
--R         
--R
--RThere are 4 unexposed functions called left :
--R   [1] LyndonWord(D1) -> LyndonWord(D1) from LyndonWord(D1) if D1 has 
--R            ORDSET
--R   [2] Magma(D1) -> Magma(D1) from Magma(D1) if D1 has ORDSET
--R   [3] OutputForm -> OutputForm from OutputForm
--R   [4] (OutputForm,Integer) -> OutputForm from OutputForm
--R
--RExamples of left from BinaryRecursiveAggregate
--R
--R
--RExamples of left from LyndonWord
--R
--R
--RExamples of left from Magma
--R
--R
--RExamples of left from OutputForm
--R
--R
--RExamples of left from RightOpenIntervalRootCharacterization
--R
--E 1543

--S 1544 of 3320
)d op leftAlternative?
--R 
--R
--RThere is one exposed function called leftAlternative? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called leftAlternative? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of leftAlternative? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of leftAlternative? from FiniteRankNonAssociativeAlgebra
--R
--E 1544

--S 1545 of 3320
)d op leftCharacteristicPolynomial
--R 
--R
--RThere is one exposed function called leftCharacteristicPolynomial :
--R   [1] D -> SparseUnivariatePolynomial(D2) from D
--R             if D has FINAALG(D2) and D2 has COMRING
--R
--RExamples of leftCharacteristicPolynomial from FiniteRankNonAssociativeAlgebra
--R
--E 1545

--S 1546 of 3320
)d op leftDiscriminant
--R 
--R
--RThere are 2 exposed functions called leftDiscriminant :
--R   [1] Vector(D) -> D1 from D if D has FINAALG(D1) and D1 has COMRING
--R         
--R   [2]  -> D1 from D if D has FRNAALG(D1) and D1 has COMRING
--R
--RThere is one unexposed function called leftDiscriminant :
--R   [1]  -> D1 from FramedNonAssociativeAlgebra&(D2,D1)
--R             if D1 has COMRING and D2 has FRNAALG(D1)
--R
--RExamples of leftDiscriminant from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of leftDiscriminant from FramedNonAssociativeAlgebra&
--R
--R
--RExamples of leftDiscriminant from FramedNonAssociativeAlgebra
--R
--E 1546

--S 1547 of 3320
)d op leftDivide
--R 
--R
--RThere is one exposed function called leftDivide :
--R   [1] (D,D) -> Record(quotient: D,remainder: D) from D
--R             if D2 has FIELD and D2 has RING and D has OREPCAT(D2)
--R
--RThere are 2 unexposed functions called leftDivide :
--R   [1] (D2,D2) -> Record(quotient: D2,remainder: D2)
--R             from NonCommutativeOperatorDivision(D2,D3)
--R             if D3 has FIELD and D2 has MLO(D3)
--R   [2] (D2,D2,Automorphism(D4)) -> Record(quotient: D2,remainder: D2)
--R             from UnivariateSkewPolynomialCategoryOps(D4,D2)
--R             if D4 has FIELD and D4 has RING and D2 has OREPCAT(D4)
--R
--RExamples of leftDivide from NonCommutativeOperatorDivision
--R
--R
--RExamples of leftDivide from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of leftDivide from UnivariateSkewPolynomialCategoryOps
--R
--E 1547

--S 1548 of 3320
)d op leftExactQuotient
--R 
--R
--RThere is one exposed function called leftExactQuotient :
--R   [1] (D,D) -> Union(D,"failed") from D
--R             if D has OREPCAT(D1) and D1 has RING and D1 has FIELD
--R
--RThere is one unexposed function called leftExactQuotient :
--R   [1] (D1,D1) -> Union(D1,"failed") from 
--R            NonCommutativeOperatorDivision(D1,D2)
--R             if D2 has FIELD and D1 has MLO(D2)
--R
--RExamples of leftExactQuotient from NonCommutativeOperatorDivision
--R
--R
--RExamples of leftExactQuotient from UnivariateSkewPolynomialCategory
--R
--E 1548

--S 1549 of 3320
)d op leftExtendedGcd
--R 
--R
--RThere is one exposed function called leftExtendedGcd :
--R   [1] (D,D) -> Record(coef1: D,coef2: D,generator: D) from D
--R             if D2 has FIELD and D2 has RING and D has OREPCAT(D2)
--R
--RExamples of leftExtendedGcd from UnivariateSkewPolynomialCategory
--R
--E 1549

--S 1550 of 3320
)d op leftFactor
--R 
--R
--RThere is one exposed function called leftFactor :
--R   [1] (D1,D1) -> Union(D1,"failed") from PolynomialDecomposition(D1,D2
--R            )
--R             if D2 has FIELD and D1 has UPOLYC(D2)
--R
--RExamples of leftFactor from PolynomialDecomposition
--R
--E 1550

--S 1551 of 3320
)d op leftFactorIfCan
--R 
--R
--RThere is one unexposed function called leftFactorIfCan :
--R   [1] (D1,D1) -> Union(D1,"failed")
--R             from UnivariatePolynomialDecompositionPackage(D2,D1)
--R             if D2 has Join(IntegralDomain,CharacteristicZero) and D1
--R             has UPOLYC(D2)
--R
--RExamples of leftFactorIfCan from UnivariatePolynomialDecompositionPackage
--R
--E 1551

--S 1552 of 3320
)d op leftGcd
--R 
--R
--RThere is one exposed function called leftGcd :
--R   [1] (D,D) -> D from D if D has OREPCAT(D1) and D1 has RING and D1
--R             has FIELD
--R
--RThere is one unexposed function called leftGcd :
--R   [1] (D1,D1) -> D1 from NonCommutativeOperatorDivision(D1,D2)
--R             if D2 has FIELD and D1 has MLO(D2)
--R
--RExamples of leftGcd from NonCommutativeOperatorDivision
--R
--R
--RExamples of leftGcd from UnivariateSkewPolynomialCategory
--R
--E 1552

--S 1553 of 3320
)d op leftLcm
--R 
--R
--RThere is one exposed function called leftLcm :
--R   [1] (D,D) -> D from D if D has OREPCAT(D1) and D1 has RING and D1
--R             has FIELD
--R
--RThere is one unexposed function called leftLcm :
--R   [1] (D1,D1) -> D1 from NonCommutativeOperatorDivision(D1,D2)
--R             if D2 has FIELD and D1 has MLO(D2)
--R
--RExamples of leftLcm from NonCommutativeOperatorDivision
--R
--R
--RExamples of leftLcm from UnivariateSkewPolynomialCategory
--R
--E 1553

--S 1554 of 3320
)d op leftMinimalPolynomial
--R 
--R
--RThere is one exposed function called leftMinimalPolynomial :
--R   [1] D -> SparseUnivariatePolynomial(D2) from D
--R             if D has FINAALG(D2) and D2 has COMRING and D2 has INTDOM
--R            
--R
--RExamples of leftMinimalPolynomial from FiniteRankNonAssociativeAlgebra
--R
--E 1554

--S 1555 of 3320
)d op leftMult
--R 
--R
--RThere is one unexposed function called leftMult :
--R   [1] (D1,ListMonoidOps(D1,D2,D3)) -> ListMonoidOps(D1,D2,D3)
--R             from ListMonoidOps(D1,D2,D3)
--R             if D1 has SETCAT and D2 has ABELMON and D3: D2
--R
--RExamples of leftMult from ListMonoidOps
--R
--E 1555

--S 1556 of 3320
)d op leftNorm
--R 
--R
--RThere is one exposed function called leftNorm :
--R   [1] D -> D1 from D if D has FINAALG(D1) and D1 has COMRING
--R
--RExamples of leftNorm from FiniteRankNonAssociativeAlgebra
--R
--E 1556

--S 1557 of 3320
)d op leftOne
--R 
--R
--RThere is one exposed function called leftOne :
--R   [1] Equation(D1) -> Union(Equation(D1),"failed") from Equation(D1)
--R             if D1 has MONOID and D1 has TYPE
--R
--RExamples of leftOne from Equation
--R
--E 1557

--S 1558 of 3320
)d op leftPower
--R 
--R
--RThere are 2 exposed functions called leftPower :
--R   [1] (D,PositiveInteger) -> D from D if D has MONAD
--R   [2] (D,NonNegativeInteger) -> D from D if D has MONADWU
--R
--RExamples of leftPower from Monad
--R
--R
--RExamples of leftPower from MonadWithUnit
--R
--E 1558

--S 1559 of 3320
)d op leftQuotient
--R 
--R
--RThere is one exposed function called leftQuotient :
--R   [1] (D,D) -> D from D if D has OREPCAT(D1) and D1 has RING and D1
--R             has FIELD
--R
--RThere is one unexposed function called leftQuotient :
--R   [1] (D1,D1) -> D1 from NonCommutativeOperatorDivision(D1,D2)
--R             if D2 has FIELD and D1 has MLO(D2)
--R
--RExamples of leftQuotient from NonCommutativeOperatorDivision
--R
--R
--RExamples of leftQuotient from UnivariateSkewPolynomialCategory
--R
--E 1559

--S 1560 of 3320
)d op leftRank
--R 
--R
--RThere is one exposed function called leftRank :
--R   [1] D2 -> NonNegativeInteger from AlgebraPackage(D3,D2)
--R             if D3 has INTDOM and D2 has FRNAALG(D3)
--R
--RExamples of leftRank from AlgebraPackage
--R
--E 1560

--S 1561 of 3320
--R--------------------------)d op leftRankPolynomial (System Error)
--E 1561

--S 1562 of 3320
)d op leftRecip
--R 
--R
--RThere are 2 exposed functions called leftRecip :
--R   [1] D -> Union(D,"failed") from D
--R             if D has FINAALG(D1) and D1 has COMRING and D1 has INTDOM
--R            
--R   [2] D -> Union(D,"failed") from D if D has MONADWU
--R
--RExamples of leftRecip from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of leftRecip from MonadWithUnit
--R
--E 1562

--S 1563 of 3320
)d op leftRegularRepresentation
--R 
--R
--RThere are 2 exposed functions called leftRegularRepresentation :
--R   [1] (D,Vector(D)) -> Matrix(D3) from D if D has FINAALG(D3) and D3
--R             has COMRING
--R   [2] D -> Matrix(D2) from D if D has FRNAALG(D2) and D2 has COMRING
--R         
--R
--RExamples of leftRegularRepresentation from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of leftRegularRepresentation from FramedNonAssociativeAlgebra
--R
--E 1563

--S 1564 of 3320
)d op leftRemainder
--R 
--R
--RThere is one exposed function called leftRemainder :
--R   [1] (D,D) -> D from D if D has OREPCAT(D1) and D1 has RING and D1
--R             has FIELD
--R
--RThere is one unexposed function called leftRemainder :
--R   [1] (D1,D1) -> D1 from NonCommutativeOperatorDivision(D1,D2)
--R             if D2 has FIELD and D1 has MLO(D2)
--R
--RExamples of leftRemainder from NonCommutativeOperatorDivision
--R
--R
--RExamples of leftRemainder from UnivariateSkewPolynomialCategory
--R
--E 1564

--S 1565 of 3320
)d op leftScalarTimes!
--R 
--R
--RThere is one unexposed function called leftScalarTimes! :
--R   [1] (Matrix(D2),D2,Matrix(D2)) -> Matrix(D2)
--R             from StorageEfficientMatrixOperations(D2) if D2 has RING
--R         
--R
--RExamples of leftScalarTimes! from StorageEfficientMatrixOperations
--R
--E 1565

--S 1566 of 3320
)d op leftTrace
--R 
--R
--RThere is one exposed function called leftTrace :
--R   [1] D -> D1 from D if D has FINAALG(D1) and D1 has COMRING
--R
--RExamples of leftTrace from FiniteRankNonAssociativeAlgebra
--R
--E 1566

--S 1567 of 3320
)d op leftTraceMatrix
--R 
--R
--RThere are 2 exposed functions called leftTraceMatrix :
--R   [1] Vector(D) -> Matrix(D3) from D if D has FINAALG(D3) and D3 has 
--R            COMRING
--R   [2]  -> Matrix(D2) from D if D has FRNAALG(D2) and D2 has COMRING
--R         
--R
--RThere is one unexposed function called leftTraceMatrix :
--R   [1]  -> Matrix(D3) from FramedNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FRNAALG(D3)
--R
--RExamples of leftTraceMatrix from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of leftTraceMatrix from FramedNonAssociativeAlgebra&
--R
--R
--RExamples of leftTraceMatrix from FramedNonAssociativeAlgebra
--R
--E 1567

--S 1568 of 3320
)d op leftTrim
--R 
--R
--RThere are 2 exposed functions called leftTrim :
--R   [1] (D,CharacterClass) -> D from D if D has SRAGG
--R   [2] (D,Character) -> D from D if D has SRAGG
--R
--RExamples of leftTrim from StringAggregate
--R
--E 1568

--S 1569 of 3320
)d op leftUnit
--R 
--R
--RThere is one exposed function called leftUnit :
--R   [1]  -> Union(D,"failed") from D
--R             if D has FINAALG(D1) and D1 has INTDOM and D1 has COMRING
--R            
--R
--RExamples of leftUnit from FiniteRankNonAssociativeAlgebra
--R
--E 1569

--S 1570 of 3320
--R-------------------------)d op leftUnits (System Error)
--E 1570

--S 1571 of 3320
)d op leftZero
--R 
--R
--RThere is one exposed function called leftZero :
--R   [1] Equation(D1) -> Equation(D1) from Equation(D1)
--R             if D1 has ABELGRP and D1 has TYPE
--R
--RExamples of leftZero from Equation
--R
--E 1571

--S 1572 of 3320
)d op legendre
--R 
--R
--RThere is one exposed function called legendre :
--R   [1] (Integer,Integer) -> Integer from IntegerNumberTheoryFunctions
--R         
--R
--RThere is one unexposed function called legendre :
--R   [1] Integer -> SparseUnivariatePolynomial(Fraction(Integer))
--R             from PolynomialNumberTheoryFunctions
--R
--RExamples of legendre from IntegerNumberTheoryFunctions
--R
--R
--RExamples of legendre from PolynomialNumberTheoryFunctions
--R
--E 1572

--S 1573 of 3320
)d op legendreP
--R 
--R
--RThere is one exposed function called legendreP :
--R   [1] (NonNegativeInteger,D1) -> D1 from OrthogonalPolynomialFunctions
--R            (D1)
--R             if D1 has ALGEBRA(FRAC(INT)) and D1 has COMRING
--R
--RExamples of legendreP from OrthogonalPolynomialFunctions
--R
--E 1573

--S 1574 of 3320
)d op length
--R 
--R
--RThere are 5 exposed functions called length :
--R   [1] Dequeue(D2) -> NonNegativeInteger from Dequeue(D2) if D2 has 
--R            SETCAT
--R   [2] D -> D from D if D has INS
--R   [3] D -> NonNegativeInteger from D if D has QUAGG(D2) and D2 has 
--R            TYPE
--R   [4] Queue(D2) -> NonNegativeInteger from Queue(D2) if D2 has SETCAT
--R            
--R   [5] D -> D1 from D
--R             if D has VECTCAT(D1) and D1 has TYPE and D1 has RADCAT and
--R            D1 has RING
--R
--RThere are 6 unexposed functions called length :
--R   [1] D2 -> D1 from GaloisGroupFactorizationUtilities(D3,D2,D1)
--R             if D3 has RING and D1 has Join(FloatingPointSystem,
--R            RetractableTo(D3),Field,TranscendentalFunctionCategory,
--R            ElementaryFunctionCategory) and D2 has UPOLYC(D3)
--R   [2] LyndonWord(D2) -> PositiveInteger from LyndonWord(D2) if D2 has 
--R            ORDSET
--R   [3] Magma(D2) -> PositiveInteger from Magma(D2) if D2 has ORDSET
--R   [4] OrderedFreeMonoid(D2) -> NonNegativeInteger from 
--R            OrderedFreeMonoid(D2)
--R             if D2 has ORDSET
--R   [5] PoincareBirkhoffWittLyndonBasis(D2) -> NonNegativeInteger
--R             from PoincareBirkhoffWittLyndonBasis(D2) if D2 has ORDSET
--R            
--R   [6] Tuple(D2) -> NonNegativeInteger from Tuple(D2) if D2 has TYPE
--R         
--R
--RExamples of length from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rlength a
--R
--R
--RExamples of length from GaloisGroupFactorizationUtilities
--R
--R
--RExamples of length from IntegerNumberSystem
--R
--R
--RExamples of length from LyndonWord
--R
--R
--RExamples of length from Magma
--R
--R
--RExamples of length from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rlength m1
--R
--R
--RExamples of length from PoincareBirkhoffWittLyndonBasis
--R
--R
--RExamples of length from QueueAggregate
--R
--R
--RExamples of length from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rlength a
--R
--R
--RExamples of length from Tuple
--R
--Rt1:PrimitiveArray(Integer):= [i for i in 1..10] 
--Rt2:=coerce(t1)$Tuple(Integer) 
--Rlength(t2)
--R
--R
--RExamples of length from VectorCategory
--R
--E 1574

--S 1575 of 3320
)d op lepol
--R 
--R
--RThere is one unexposed function called lepol :
--R   [1] D2 -> Integer from GroebnerInternalPackage(D3,D4,D5,D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has POLYCAT(D3,D4,D5)
--R
--RExamples of lepol from GroebnerInternalPackage
--R
--E 1575

--S 1576 of 3320
)d op less?
--R 
--R
--RThere are 6 exposed functions called less? :
--R   [1] (D,NonNegativeInteger) -> Boolean from D if D has AGG
--R   [2] (ArrayStack(D3),NonNegativeInteger) -> Boolean from ArrayStack(
--R            D3)
--R             if D3 has SETCAT
--R   [3] (Dequeue(D3),NonNegativeInteger) -> Boolean from Dequeue(D3) if 
--R            D3 has SETCAT
--R   [4] (Heap(D3),NonNegativeInteger) -> Boolean from Heap(D3) if D3
--R             has ORDSET
--R   [5] (Queue(D3),NonNegativeInteger) -> Boolean from Queue(D3) if D3
--R             has SETCAT
--R   [6] (Stack(D3),NonNegativeInteger) -> Boolean from Stack(D3) if D3
--R             has SETCAT
--R
--RThere are 2 unexposed functions called less? :
--R   [1] (D2,D2) -> Union(Boolean,"failed") from 
--R            UserDefinedPartialOrdering(D2)
--R             if D2 has SETCAT
--R   [2] (D2,D2,((D2,D2) -> Boolean)) -> Boolean
--R             from UserDefinedPartialOrdering(D2) if D2 has SETCAT
--R
--RExamples of less? from Aggregate
--R
--R
--RExamples of less? from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rless?(a,9)
--R
--R
--RExamples of less? from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rless?(a,9)
--R
--R
--RExamples of less? from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rless?(a,9)
--R
--R
--RExamples of less? from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rless?(a,9)
--R
--R
--RExamples of less? from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rless?(a,9)
--R
--R
--RExamples of less? from UserDefinedPartialOrdering
--R
--E 1576

--S 1577 of 3320
)d op level
--R 
--R
--RThere is one unexposed function called level :
--R   [1] SubSpace(D2,D3) -> NonNegativeInteger from SubSpace(D2,D3)
--R             if D2: PI and D3 has RING
--R
--RExamples of level from SubSpace
--R
--E 1577

--S 1578 of 3320 done
)d op leviCivitaSymbol
--R 
--R
--RThere is one exposed function called leviCivitaSymbol :
--R   [1]  -> CartesianTensor(D1,D2,D3) from CartesianTensor(D1,D2,D3)
--R             if D1: INT and D2: NNI and D3 has COMRING
--R
--RExamples of leviCivitaSymbol from CartesianTensor
--R
--Rlcs:CartesianTensor(1,2,Integer):=leviCivitaSymbol()
--R
--E 1578

--S 1579 of 3320
)d op lex
--R 
--R
--RThere is one unexposed function called lex :
--R   [1] List(List(D2)) -> List(List(D2)) from TableauxBumpers(D2) if D2
--R             has ORDSET
--R
--RExamples of lex from TableauxBumpers
--R
--E 1579

--S 1580 of 3320
)d op lexGroebner
--R 
--R
--RThere is one exposed function called lexGroebner :
--R   [1] (List(Polynomial(D3)),List(Symbol)) -> List(Polynomial(D3))
--R             from PolyGroebner(D3) if D3 has GCDDOM
--R
--RExamples of lexGroebner from PolyGroebner
--R
--E 1580

--S 1581 of 3320
)d op lexico
--R 
--R
--RThere are 3 unexposed functions called lexico :
--R   [1] (LyndonWord(D2),LyndonWord(D2)) -> Boolean from LyndonWord(D2)
--R             if D2 has ORDSET
--R   [2] (Magma(D2),Magma(D2)) -> Boolean from Magma(D2) if D2 has ORDSET
--R            
--R   [3] (OrderedFreeMonoid(D2),OrderedFreeMonoid(D2)) -> Boolean
--R             from OrderedFreeMonoid(D2) if D2 has ORDSET
--R
--RExamples of lexico from LyndonWord
--R
--R
--RExamples of lexico from Magma
--R
--R
--RExamples of lexico from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rm2:=(x*y)$OFMONOID(Symbol) 
--Rlexico(m1,m2) 
--Rlexico(m2,m1)
--R
--E 1581

--S 1582 of 3320
)d op lexTriangular
--R 
--R
--RThere is one unexposed function called lexTriangular :
--R   [1] (List(NewSparseMultivariatePolynomial(D4,OrderedVariableList(D5)
--R            )),Boolean) -> List(RegularChain(D4,D5))
--R             from LexTriangularPackage(D4,D5) if D4 has GCDDOM and D5: 
--R            LIST(SYMBOL)
--R
--RExamples of lexTriangular from LexTriangularPackage
--R
--E 1582

--S 1583 of 3320
)d op lfextendedint
--R 
--R
--RThere is one unexposed function called lfextendedint :
--R   [1] (D2,Symbol,D2) -> Union(Record(ratpart: D2,coeff: D2),"failed")
--R             from ElementaryIntegration(D4,D2)
--R             if D4 has Join(GcdDomain,OrderedSet,CharacteristicZero,
--R            RetractableTo(Integer),LinearlyExplicitRingOver(Integer)) 
--R            and D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D4))
--R
--RExamples of lfextendedint from ElementaryIntegration
--R
--E 1583

--S 1584 of 3320
)d op lfextlimint
--R 
--R
--RThere is one unexposed function called lfextlimint :
--R   [1] (D2,Symbol,Kernel(D2),List(Kernel(D2))) -> Union(Record(ratpart
--R            : D2,coeff: D2),"failed")
--R             from ElementaryIntegration(D6,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D6)) and D6
--R             has Join(GcdDomain,OrderedSet,CharacteristicZero,
--R            RetractableTo(Integer),LinearlyExplicitRingOver(Integer))
--R         
--R
--RExamples of lfextlimint from ElementaryIntegration
--R
--E 1584

--S 1585 of 3320
)d op lfinfieldint
--R 
--R
--RThere is one unexposed function called lfinfieldint :
--R   [1] (D1,Symbol) -> Union(D1,"failed") from ElementaryIntegration(D3,
--R            D1)
--R             if D3 has Join(GcdDomain,OrderedSet,CharacteristicZero,
--R            RetractableTo(Integer),LinearlyExplicitRingOver(Integer)) 
--R            and D1 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D3))
--R
--RExamples of lfinfieldint from ElementaryIntegration
--R
--E 1585

--S 1586 of 3320
)d op lfintegrate
--R 
--R
--RThere is one unexposed function called lfintegrate :
--R   [1] (D2,Symbol) -> IntegrationResult(D2) from ElementaryIntegration(
--R            D4,D2)
--R             if D4 has Join(GcdDomain,OrderedSet,CharacteristicZero,
--R            RetractableTo(Integer),LinearlyExplicitRingOver(Integer)) 
--R            and D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D4))
--R
--RExamples of lfintegrate from ElementaryIntegration
--R
--E 1586

--S 1587 of 3320
)d op lflimitedint
--R 
--R
--RThere is one unexposed function called lflimitedint :
--R   [1] (D2,Symbol,List(D2)) -> Union(Record(mainpart: D2,limitedlogs: 
--R            List(Record(coeff: D2,logand: D2))),"failed")
--R             from ElementaryIntegration(D5,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D5)) and D5
--R             has Join(GcdDomain,OrderedSet,CharacteristicZero,
--R            RetractableTo(Integer),LinearlyExplicitRingOver(Integer))
--R         
--R
--RExamples of lflimitedint from ElementaryIntegration
--R
--E 1587

--S 1588 of 3320
)d op lfunc
--R 
--R
--RThere is one exposed function called lfunc :
--R   [1] (Integer,Integer) -> Integer from HallBasis
--R
--RExamples of lfunc from HallBasis
--R
--E 1588

--S 1589 of 3320
)d op lhs
--R 
--R
--RThere are 2 exposed functions called lhs :
--R   [1] Equation(D1) -> D1 from Equation(D1) if D1 has TYPE
--R   [2] RewriteRule(D2,D3,D1) -> D1 from RewriteRule(D2,D3,D1)
--R             if D2 has SETCAT and D1 has Join(FunctionSpace(D3),
--R            PatternMatchable(D2),ConvertibleTo(Pattern(D2))) and D3
--R             has Join(Ring,PatternMatchable(D2),OrderedSet,
--R            ConvertibleTo(Pattern(D2)))
--R
--RThere is one unexposed function called lhs :
--R   [1] SuchThat(D1,D2) -> D1 from SuchThat(D1,D2) if D1 has SETCAT and 
--R            D2 has SETCAT
--R
--RExamples of lhs from Equation
--R
--R
--RExamples of lhs from RewriteRule
--R
--R
--RExamples of lhs from SuchThat
--R
--E 1589

--S 1590 of 3320
)d op li
--R 
--R
--RThere is one exposed function called li :
--R   [1] D -> D from D if D has LFCAT
--R
--RThere is one unexposed function called li :
--R   [1] D1 -> D1 from LiouvillianFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R
--RExamples of li from LiouvillianFunctionCategory
--R
--R
--RExamples of li from LiouvillianFunction
--R
--E 1590

--S 1591 of 3320
)d op library
--R 
--R
--RThere is one exposed function called library :
--R   [1] FileName -> Library from Library
--R
--RExamples of library from Library
--R
--E 1591

--S 1592 of 3320
)d op lieAdmissible?
--R 
--R
--RThere is one exposed function called lieAdmissible? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called lieAdmissible? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of lieAdmissible? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of lieAdmissible? from FiniteRankNonAssociativeAlgebra
--R
--E 1592

--S 1593 of 3320
)d op lieAlgebra?
--R 
--R
--RThere is one exposed function called lieAlgebra? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called lieAlgebra? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of lieAlgebra? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of lieAlgebra? from FiniteRankNonAssociativeAlgebra
--R
--E 1593

--S 1594 of 3320 done
)d op lieDerivative
--R 
--R
--RThere is one unexposed function called lieDerivative :
--R   [1] (Vector(Expression(D3)),DeRhamComplex(D3,D4),SquareMatrix(#(D4),
--R            Expression(D3))) -> DeRhamComplex(D3,D4)
--R             from DeRhamComplex(D3,D4)
--R             if D3 has Join(Ring,OrderedSet) and D4: LIST(SYMBOL)
--R
--RExamples of lieDerivative from DeRhamComplex
--R
--R(w.r.t. metric g)} blankline 
--RcoefRing := Integer 
--RR3 : List Symbol := [x,y,z] 
--RD := DERHAM(coefRing,R3) 
--R[dx,dy,dz] := [generator(i)$D for i in 1..3] 
--Ra : BOP := operator('a) 
--Rb : BOP := operator('b) 
--Rc : BOP := operator('c) 
--RU : BOP := operator('U) 
--RV : BOP := operator('V) 
--RW : BOP := operator('W) 
--Rv := vector[U(x,y,z),V(x,y,z),W(x,y,z)] 
--Rtheta := a(x,y,z)*dx*dy + b(x,y,z)*dx*dz + c(x,y,z)*dy*dz 
--RG := diagonalMatrix([1,1,1]) 
--Reta := lieDerivative(v,theta,G)
--R
--E 1594

--S 1595 of 3320
)d op LiePoly
--R 
--R
--RThere is one exposed function called LiePoly :
--R   [1] LyndonWord(D2) -> D from D
--R             if D2 has ORDSET and D has FLALG(D2,D3) and D3 has COMRING
--R            
--R
--RExamples of LiePoly from FreeLieAlgebra
--R
--E 1595

--S 1596 of 3320
)d op LiePolyIfCan
--R 
--R
--RThere are 2 unexposed functions called LiePolyIfCan :
--R   [1] XDistributedPolynomial(D2,D3) -> Union(LiePolynomial(D2,D3),
--R            "failed")
--R             from LiePolynomial(D2,D3) if D2 has ORDSET and D3 has 
--R            COMRING
--R   [2] XPBWPolynomial(D2,D3) -> Union(LiePolynomial(D2,D3),"failed")
--R             from XPBWPolynomial(D2,D3) if D2 has ORDSET and D3 has 
--R            COMRING
--R
--RExamples of LiePolyIfCan from LiePolynomial
--R
--R
--RExamples of LiePolyIfCan from XPBWPolynomial
--R
--E 1596

--S 1597 of 3320
)d op lift
--R 
--R
--RThere are 3 exposed functions called lift :
--R   [1] D -> D1 from D
--R             if D has MONOGEN(D2,D1) and D2 has COMRING and D1 has 
--R            UPOLYC(D2)
--R   [2] (D,D) -> SparseUnivariatePolynomial(D) from D if D has PACPERC
--R         
--R   [3] D -> SparseUnivariatePolynomial(D) from D if D has PACPERC
--R
--RThere are 4 unexposed functions called lift :
--R   [1] (SparseUnivariatePolynomial(D5),Kernel(D5)) -> 
--R            SparseUnivariatePolynomial(Fraction(SparseUnivariatePolynomial(D5
--R            )))
--R             from GenusZeroIntegration(D4,D5,D6)
--R             if D5 has Join(FunctionSpace(D4),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D4 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D6 has SETCAT
--R   [2] ModMonic(D2,D1) -> D1 from ModMonic(D2,D1)
--R             if D1 has UPOLYC(D2) and D2 has RING
--R   [3] (SparseUnivariatePolynomial(D6),SparseUnivariatePolynomial(D2),
--R            SparseUnivariatePolynomial(D2),D6,List(D1),List(
--R            NonNegativeInteger),List(D2)) -> Union(List(
--R            SparseUnivariatePolynomial(D6)),"failed")
--R             from MultivariateSquareFree(D10,D1,D2,D6)
--R             if D1 has ORDSET and D2 has EUCDOM and D10 has OAMONS and 
--R            D6 has POLYCAT(D2,D10,D1)
--R   [4] ResidueRing(D2,D3,D4,D1,D5) -> D1 from ResidueRing(D2,D3,D4,D1,
--R            D5)
--R             if D1 has POLYCAT(D2,D3,D4) and D2 has FIELD and D3 has 
--R            OAMONS and D4 has ORDSET and D5: LIST(D1)
--R
--RExamples of lift from GenusZeroIntegration
--R
--R
--RExamples of lift from ModMonic
--R
--R
--RExamples of lift from MonogenicAlgebra
--R
--R
--RExamples of lift from MultivariateSquareFree
--R
--R
--RExamples of lift from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--R
--RExamples of lift from ResidueRing
--R
--E 1597

--S 1598 of 3320
)d op lifting
--R 
--R
--RThere is one unexposed function called lifting :
--R   [1] (SparseUnivariatePolynomial(D3),List(D2),List(
--R            SparseUnivariatePolynomial(D11)),List(D11),List(D3),List(
--R            NonNegativeInteger),D11) -> Union(List(SparseUnivariatePolynomial
--R            (D3)),"failed")
--R             from MultivariateLifting(D1,D2,D11,D3)
--R             if D2 has ORDSET and D11 has EUCDOM and D3 has POLYCAT(D11
--R            ,D1,D2) and D1 has OAMONS
--R
--RExamples of lifting from MultivariateLifting
--R
--E 1598

--S 1599 of 3320
)d op lifting1
--R 
--R
--RThere is one unexposed function called lifting1 :
--R   [1] (SparseUnivariatePolynomial(D4),List(D3),List(
--R            SparseUnivariatePolynomial(D4)),List(D1),List(D4),List(List(
--R            Record(expt: NonNegativeInteger,pcoef: D4))),List(
--R            NonNegativeInteger),Vector(List(SparseUnivariatePolynomial(D1))),
--R            D1) -> Union(List(SparseUnivariatePolynomial(D4)),"failed")
--R             from MultivariateLifting(D2,D3,D1,D4)
--R             if D3 has ORDSET and D1 has EUCDOM and D4 has POLYCAT(D1,
--R            D2,D3) and D2 has OAMONS
--R
--RExamples of lifting1 from MultivariateLifting
--R
--E 1599

--S 1600 of 3320
)d op light
--R 
--R
--RThere is one exposed function called light :
--R   [1] Color -> Palette from Palette
--R
--RExamples of light from Palette
--R
--E 1600

--S 1601 of 3320
)d op lighting
--R 
--R
--RThere is one exposed function called lighting :
--R   [1] (ThreeDimensionalViewport,Float,Float,Float) -> Void
--R             from ThreeDimensionalViewport
--R
--RExamples of lighting from ThreeDimensionalViewport
--R
--E 1601

--S 1602 of 3320
)d op limit
--R 
--R
--RThere are 5 exposed functions called limit :
--R   [1] (D2,Equation(OrderedCompletion(D2))) -> Union(OrderedCompletion(
--R            D2),Record(leftHandLimit: Union(OrderedCompletion(D2),"failed"),
--R            rightHandLimit: Union(OrderedCompletion(D2),"failed")),"failed")
--R             from PowerSeriesLimitPackage(D4,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D4)) and D4
--R             has Join(GcdDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [2] (D2,Equation(D2),String) -> Union(OrderedCompletion(D2),"failed"
--R            )
--R             from PowerSeriesLimitPackage(D5,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D5)) and D5
--R             has Join(GcdDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [3] (Fraction(Polynomial(D4)),Equation(OrderedCompletion(Polynomial(
--R            D4)))) -> Union(OrderedCompletion(Fraction(Polynomial(D4))),
--R            Record(leftHandLimit: Union(OrderedCompletion(Fraction(Polynomial
--R            (D4))),"failed"),rightHandLimit: Union(OrderedCompletion(Fraction
--R            (Polynomial(D4))),"failed")),"failed")
--R             from RationalFunctionLimitPackage(D4) if D4 has GCDDOM
--R   [4] (Fraction(Polynomial(D4)),Equation(Fraction(Polynomial(D4))))
--R             -> Union(OrderedCompletion(Fraction(Polynomial(D4))),Record(
--R            leftHandLimit: Union(OrderedCompletion(Fraction(Polynomial(D4))),
--R            "failed"),rightHandLimit: Union(OrderedCompletion(Fraction(
--R            Polynomial(D4))),"failed")),"failed")
--R             from RationalFunctionLimitPackage(D4) if D4 has GCDDOM
--R   [5] (Fraction(Polynomial(D5)),Equation(Fraction(Polynomial(D5))),
--R            String) -> Union(OrderedCompletion(Fraction(Polynomial(D5))),
--R            "failed")
--R             from RationalFunctionLimitPackage(D5) if D5 has GCDDOM
--R
--RExamples of limit from PowerSeriesLimitPackage
--R
--R
--RExamples of limit from RationalFunctionLimitPackage
--R
--E 1602

--S 1603 of 3320
)d op limitedint
--R 
--R
--RThere is one unexposed function called limitedint :
--R   [1] (Fraction(D5),List(Fraction(D5))) -> Union(Record(mainpart: 
--R            Fraction(D5),limitedlogs: List(Record(coeff: Fraction(D5),logand
--R            : Fraction(D5)))),"failed")
--R             from RationalIntegration(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer))
--R
--RExamples of limitedint from RationalIntegration
--R
--E 1603

--S 1604 of 3320
)d op limitedIntegrate
--R 
--R
--RThere is one exposed function called limitedIntegrate :
--R   [1] (Fraction(Polynomial(D5)),Symbol,List(Fraction(Polynomial(D5))))
--R             -> Union(Record(mainpart: Fraction(Polynomial(D5)),limitedlogs: 
--R            List(Record(coeff: Fraction(Polynomial(D5)),logand: Fraction(
--R            Polynomial(D5))))),"failed")
--R             from RationalFunctionIntegration(D5)
--R             if D5 has Join(IntegralDomain,RetractableTo(Integer),
--R            CharacteristicZero)
--R
--RExamples of limitedIntegrate from RationalFunctionIntegration
--R
--E 1604

--S 1605 of 3320
)d op limitPlus
--R 
--R
--RThere are 2 unexposed functions called limitPlus :
--R   [1] ExponentialExpansion(D2,D3,D4,D5) -> Union(OrderedCompletion(D3)
--R            ,"failed")
--R             from ExponentialExpansion(D2,D3,D4,D5)
--R             if D2 has Join(OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer),GcdDomain) and D3 has 
--R            Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D2)) and D4: 
--R            SYMBOL and D5: D3
--R   [2] UnivariatePuiseuxSeriesWithExponentialSingularity(D2,D3,D4,D5)
--R             -> Union(OrderedCompletion(D3),"failed")
--R             from UnivariatePuiseuxSeriesWithExponentialSingularity(D2,
--R            D3,D4,D5)
--R             if D2 has Join(OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer),GcdDomain) and D3 has 
--R            Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D2)) and D4: 
--R            SYMBOL and D5: D3
--R
--RExamples of limitPlus from ExponentialExpansion
--R
--R
--RExamples of limitPlus from UnivariatePuiseuxSeriesWithExponentialSingularity
--R
--E 1605

--S 1606 of 3320
)d op linear
--R 
--R
--RThere are 2 unexposed functions called linear :
--R   [1] D3 -> List(D4) from PolynomialSolveByFormulas(D3,D4)
--R             if D4 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D3 has UPOLYC(D4)
--R            
--R   [2] (D3,D3) -> List(D3) from PolynomialSolveByFormulas(D4,D3)
--R             if D3 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D4 has UPOLYC(D3)
--R            
--R
--RExamples of linear from PolynomialSolveByFormulas
--R
--E 1606

--S 1607 of 3320
)d op linear?
--R 
--R
--RThere are 2 exposed functions called linear? :
--R   [1] List(Expression(DoubleFloat)) -> Boolean from e04AgentsPackage
--R         
--R   [2] Expression(DoubleFloat) -> Boolean from e04AgentsPackage
--R
--RThere is one unexposed function called linear? :
--R   [1] D2 -> Boolean from PolynomialSetUtilitiesPackage(D3,D4,D5,D2)
--R             if D3 has INTDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5)
--R
--RExamples of linear? from e04AgentsPackage
--R
--R
--RExamples of linear? from PolynomialSetUtilitiesPackage
--R
--E 1607

--S 1608 of 3320
)d op linearAssociatedExp
--R 
--R
--RThere is one exposed function called linearAssociatedExp :
--R   [1] (D,SparseUnivariatePolynomial(D2)) -> D from D
--R             if D2 has FINITE and D has FAXF(D2) and D2 has FIELD
--R
--RExamples of linearAssociatedExp from FiniteAlgebraicExtensionField
--R
--E 1608

--S 1609 of 3320
)d op linearAssociatedLog
--R 
--R
--RThere are 2 exposed functions called linearAssociatedLog :
--R   [1] (D,D) -> Union(SparseUnivariatePolynomial(D2),"failed") from D
--R             if D has FAXF(D2) and D2 has FIELD and D2 has FINITE
--R   [2] D -> SparseUnivariatePolynomial(D2) from D
--R             if D has FAXF(D2) and D2 has FIELD and D2 has FINITE
--R
--RExamples of linearAssociatedLog from FiniteAlgebraicExtensionField
--R
--E 1609

--S 1610 of 3320
)d op linearAssociatedOrder
--R 
--R
--RThere is one exposed function called linearAssociatedOrder :
--R   [1] D -> SparseUnivariatePolynomial(D2) from D
--R             if D has FAXF(D2) and D2 has FIELD and D2 has FINITE
--R
--RExamples of linearAssociatedOrder from FiniteAlgebraicExtensionField
--R
--E 1610

--S 1611 of 3320 done
)d op linearBezier
--R 
--R
--RThere is one exposed function called linearBezier :
--R   [1] (List(D3),List(D3)) -> (D3 -> List(D3)) from Bezier(D3) if D3
--R             has RING
--R
--RExamples of linearBezier from Bezier
--R
--Rn:=linearBezier([2.0,2.0],[4.0,4.0]) 
--R[n(t/10.0) for t in 0..10 by 1]
--R
--E 1611

--S 1612 of 3320
)d op linearDependence
--R 
--R
--RThere is one unexposed function called linearDependence :
--R   [1] Vector(D4) -> Union(Vector(D3),"failed") from LinearDependence(
--R            D3,D4)
--R             if D4 has LINEXP(D3) and D3 has INTDOM
--R
--RExamples of linearDependence from LinearDependence
--R
--E 1612

--S 1613 of 3320
)d op linearDependenceOverZ
--R 
--R
--RThere is one exposed function called linearDependenceOverZ :
--R   [1] Vector(D3) -> Union(Vector(Integer),"failed")
--R             from IntegerLinearDependence(D3) if D3 has LINEXP(INT)
--R
--RExamples of linearDependenceOverZ from IntegerLinearDependence
--R
--E 1613

--S 1614 of 3320
)d op linearlyDependent?
--R 
--R
--RThere is one unexposed function called linearlyDependent? :
--R   [1] Vector(D4) -> Boolean from LinearDependence(D3,D4)
--R             if D4 has LINEXP(D3) and D3 has INTDOM
--R
--RExamples of linearlyDependent? from LinearDependence
--R
--E 1614

--S 1615 of 3320
)d op linearlyDependentOverZ?
--R 
--R
--RThere is one exposed function called linearlyDependentOverZ? :
--R   [1] Vector(D3) -> Boolean from IntegerLinearDependence(D3) if D3
--R             has LINEXP(INT)
--R
--RExamples of linearlyDependentOverZ? from IntegerLinearDependence
--R
--E 1615

--S 1616 of 3320
)d op linearMatrix
--R 
--R
--RThere is one exposed function called linearMatrix :
--R   [1] (List(Expression(DoubleFloat)),NonNegativeInteger) -> Matrix(
--R            DoubleFloat)
--R             from e04AgentsPackage
--R
--RExamples of linearMatrix from e04AgentsPackage
--R
--E 1616

--S 1617 of 3320
)d op linearPart
--R 
--R
--RThere is one exposed function called linearPart :
--R   [1] List(Expression(DoubleFloat)) -> List(Expression(DoubleFloat))
--R             from e04AgentsPackage
--R
--RExamples of linearPart from e04AgentsPackage
--R
--E 1617

--S 1618 of 3320
)d op linearPolynomials
--R 
--R
--RThere is one unexposed function called linearPolynomials :
--R   [1] List(D6) -> Record(goodPols: List(D6),badPols: List(D6))
--R             from PolynomialSetUtilitiesPackage(D3,D4,D5,D6)
--R             if D3 has INTDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5)
--R
--RExamples of linearPolynomials from PolynomialSetUtilitiesPackage
--R
--E 1618

--S 1619 of 3320
)d op linears
--R 
--R
--RThere is one exposed function called linears :
--R   [1] (D1,Integer) -> D1 from ModularDistinctDegreeFactorizer(D1)
--R             if D1 has UPOLYC(INT)
--R
--RExamples of linears from ModularDistinctDegreeFactorizer
--R
--E 1619

--S 1620 of 3320
)d op lineColorDefault
--R 
--R
--RThere are 2 exposed functions called lineColorDefault :
--R   [1]  -> Palette from ViewDefaultsPackage
--R   [2] Palette -> Palette from ViewDefaultsPackage
--R
--RExamples of lineColorDefault from ViewDefaultsPackage
--R
--E 1620

--S 1621 of 3320
)d op linGenPos
--R 
--R
--RThere is one unexposed function called linGenPos :
--R   [1] List(HomogeneousDistributedMultivariatePolynomial(D3,D4)) -> 
--R            Record(gblist: List(DistributedMultivariatePolynomial(D3,D4)),
--R            gvlist: List(Integer))
--R             from LinGroebnerPackage(D3,D4) if D3: LIST(SYMBOL) and D4
--R             has GCDDOM
--R
--RExamples of linGenPos from LinGroebnerPackage
--R
--E 1621

--S 1622 of 3320
)d op linkToFortran
--R 
--R
--RThere are 3 exposed functions called linkToFortran :
--R   [1] (Symbol,List(Union(array: List(Symbol),scalar: Symbol)),List(
--R            List(Union(array: List(Symbol),scalar: Symbol))),List(Symbol))
--R             -> SExpression
--R             from FortranPackage
--R   [2] (Symbol,List(Union(array: List(Symbol),scalar: Symbol)),List(
--R            List(Union(array: List(Symbol),scalar: Symbol))),List(Symbol),
--R            Symbol) -> SExpression
--R             from FortranPackage
--R   [3] (Symbol,List(Symbol),TheSymbolTable,List(Symbol)) -> SExpression
--R             from FortranPackage
--R
--RExamples of linkToFortran from FortranPackage
--R
--E 1622

--S 1623 of 3320
)d op linSolve
--R 
--R
--RThere is one exposed function called linSolve :
--R   [1] (List(D7),List(D6)) -> Record(particular: Union(Vector(Fraction(
--R            D7)),"failed"),basis: List(Vector(Fraction(D7))))
--R             from LinearSystemPolynomialPackage(D4,D5,D6,D7)
--R             if D6 has ORDSET and D7 has POLYCAT(D4,D5,D6) and D4 has 
--R            INTDOM and D5 has OAMONS
--R
--RExamples of linSolve from LinearSystemPolynomialPackage
--R
--E 1623

--S 1624 of 3320
)d op lintgcd
--R 
--R
--RThere is one unexposed function called lintgcd :
--R   [1] List(Integer) -> Integer from HeuGcd(D3) if D3 has UPOLYC(INT)
--R         
--R
--RExamples of lintgcd from HeuGcd
--R
--E 1624

--S 1625 of 3320
)d op list
--R 
--R
--RThere are 4 exposed functions called list :
--R   [1] D -> List(D2) from D if D has AFSPCAT(D2) and D2 has FIELD
--R   [2] D1 -> D from D if D has LSAGG(D1) and D1 has TYPE
--R   [3] D -> List(D2) from D if D has PRSPCAT(D2) and D2 has FIELD
--R   [4] Symbol -> List(Symbol) from Symbol
--R
--RExamples of list from AffineSpaceCategory
--R
--R
--RExamples of list from ListAggregate
--R
--R
--RExamples of list from ProjectiveSpaceCategory
--R
--R
--RExamples of list from Symbol
--R
--Rm:=script(Big,[[i,j],[k,1],[0,1],[2],[u,v,w]]) 
--R(list m)$Symbol
--R
--E 1625

--S 1626 of 3320
)d op list?
--R 
--R
--RThere is one exposed function called list? :
--R   [1] D -> Boolean from D
--R             if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R
--RExamples of list? from SExpressionCategory
--R
--E 1626

--S 1627 of 3320
)d op listAllMono
--R 
--R
--RThere is one exposed function called listAllMono :
--R   [1] NonNegativeInteger -> List(D4) from PackageForPoly(D3,D4,D5,D6)
--R             if D3 has RING and D5 has DIRPCAT(D6,NNI) and D6: NNI and 
--R            D4 has FAMR(D3,D5)
--R
--RExamples of listAllMono from PackageForPoly
--R
--E 1627

--S 1628 of 3320
)d op listAllMonoExp
--R 
--R
--RThere is one exposed function called listAllMonoExp :
--R   [1] Integer -> List(D5) from PackageForPoly(D3,D4,D5,D6)
--R             if D3 has RING and D5 has DIRPCAT(D6,NNI) and D6: NNI and 
--R            D4 has FAMR(D3,D5)
--R
--RExamples of listAllMonoExp from PackageForPoly
--R
--E 1628

--S 1629 of 3320
)d op listBranches
--R 
--R
--RThere are 2 exposed functions called listBranches :
--R   [1] D -> List(List(Point(DoubleFloat))) from D if D has PPCURVE
--R   [2] D -> List(List(Point(DoubleFloat))) from D if D has PSCURVE
--R
--RExamples of listBranches from PlottablePlaneCurveCategory
--R
--R
--RExamples of listBranches from PlottableSpaceCurveCategory
--R
--E 1629

--S 1630 of 3320
)d op listConjugateBases
--R 
--R
--RThere is one unexposed function called listConjugateBases :
--R   [1] (Record(basis: Matrix(D5),basisDen: D5,basisInv: Matrix(D5)),
--R            NonNegativeInteger,NonNegativeInteger) -> List(Record(basis: 
--R            Matrix(D5),basisDen: D5,basisInv: Matrix(D5)))
--R             from ChineseRemainderToolsForIntegralBases(D4,D5,D6)
--R             if D4 has FFIELDC and D5 has UPOLYC(D4) and D6 has UPOLYC(
--R            D5)
--R
--RExamples of listConjugateBases from ChineseRemainderToolsForIntegralBases
--R
--E 1630

--S 1631 of 3320
)d op listexp
--R 
--R
--RThere is one unexposed function called listexp :
--R   [1] D2 -> List(NonNegativeInteger) from NPCoef(D2,D3,D4,D5,D6)
--R             if D3 has OAMONS and D4 has ORDSET and D5 has EUCDOM and 
--R            D2 has UPOLYC(D5) and D6 has POLYCAT(D5,D3,D4)
--R
--RExamples of listexp from NPCoef
--R
--E 1631

--S 1632 of 3320
)d op listLoops
--R 
--R
--RThere is one unexposed function called listLoops :
--R   [1] TubePlot(D2) -> List(List(Point(DoubleFloat))) from TubePlot(D2)
--R             if D2 has PSCURVE
--R
--RExamples of listLoops from TubePlot
--R
--E 1632

--S 1633 of 3320
)d op listOfLists
--R 
--R
--RThere are 3 exposed functions called listOfLists :
--R   [1] D -> List(List(D2)) from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [2] D -> List(List(D4)) from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R   [3] Tableau(D2) -> List(List(D2)) from Tableau(D2) if D2 has SETCAT
--R            
--R
--RExamples of listOfLists from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--RlistOfLists m
--R
--R
--RExamples of listOfLists from RectangularMatrixCategory
--R
--R
--RExamples of listOfLists from Tableau
--R
--E 1633

--S 1634 of 3320
)d op listOfMonoms
--R 
--R
--RThere is one unexposed function called listOfMonoms :
--R   [1] ListMonoidOps(D2,D3,D4) -> List(Record(gen: D2,exp: D3))
--R             from ListMonoidOps(D2,D3,D4)
--R             if D2 has SETCAT and D3 has ABELMON and D4: D3
--R
--RExamples of listOfMonoms from ListMonoidOps
--R
--E 1634

--S 1635 of 3320
)d op listOfTerms
--R 
--R
--RThere is one exposed function called listOfTerms :
--R   [1] D -> List(Record(k: D3,c: D2)) from D
--R             if D has FMCAT(D2,D3) and D2 has RING and D3 has SETCAT
--R         
--R
--RThere are 2 unexposed functions called listOfTerms :
--R   [1] LieExponentials(D2,D3,D4) -> List(Record(k: 
--R            PoincareBirkhoffWittLyndonBasis(D2),c: D3))
--R             from LieExponentials(D2,D3,D4)
--R             if D2 has ORDSET and D3 has Join(CommutativeRing,Module(
--R            Fraction(Integer))) and D4: PI
--R   [2] PoincareBirkhoffWittLyndonBasis(D2) -> List(LyndonWord(D2))
--R             from PoincareBirkhoffWittLyndonBasis(D2) if D2 has ORDSET
--R            
--R
--RExamples of listOfTerms from FreeModuleCat
--R
--R
--RExamples of listOfTerms from LieExponentials
--R
--R
--RExamples of listOfTerms from PoincareBirkhoffWittLyndonBasis
--R
--E 1635

--S 1636 of 3320
)d op listRepresentation
--R 
--R
--RThere is one exposed function called listRepresentation :
--R   [1] Permutation(D2) -> Record(preimage: List(D2),image: List(D2))
--R             from Permutation(D2) if D2 has SETCAT
--R
--RExamples of listRepresentation from Permutation
--R
--E 1636

--S 1637 of 3320
)d op lists
--R 
--R
--RThere is one unexposed function called lists :
--R   [1] PatternMatchListResult(D2,D3,D4) -> PatternMatchResult(D2,D4)
--R             from PatternMatchListResult(D2,D3,D4)
--R             if D3 has SETCAT and D2 has SETCAT and D4 has LSAGG(D3)
--R         
--R
--RExamples of lists from PatternMatchListResult
--R
--E 1637

--S 1638 of 3320
)d op listSD
--R 
--R
--RThere is one exposed function called listSD :
--R   [1] StochasticDifferential(D2) -> List(BasicStochasticDifferential)
--R             from StochasticDifferential(D2)
--R             if D2 has Join(OrderedSet,IntegralDomain)
--R
--RExamples of listSD from StochasticDifferential
--R
--E 1638

--S 1639 of 3320
)d op listVariable
--R 
--R
--RThere is one exposed function called listVariable :
--R   [1]  -> List(D3) from PackageForPoly(D2,D3,D4,D5)
--R             if D2 has RING and D4 has DIRPCAT(D5,NNI) and D5: NNI and 
--R            D3 has FAMR(D2,D4)
--R
--RExamples of listVariable from PackageForPoly
--R
--E 1639

--S 1640 of 3320
)d op listYoungTableaus
--R 
--R
--RThere is one exposed function called listYoungTableaus :
--R   [1] List(Integer) -> List(Matrix(Integer))
--R             from SymmetricGroupCombinatoricFunctions
--R
--RExamples of listYoungTableaus from SymmetricGroupCombinatoricFunctions
--R
--E 1640

--S 1641 of 3320
)d op lllip
--R 
--R
--RThere is one exposed function called lllip :
--R   [1] D -> List(List(List(NonNegativeInteger))) from D
--R             if D has SPACEC(D2) and D2 has RING
--R
--RExamples of lllip from ThreeSpaceCategory
--R
--E 1641

--S 1642 of 3320
)d op lllp
--R 
--R
--RThere is one exposed function called lllp :
--R   [1] D -> List(List(List(Point(D2)))) from D if D has SPACEC(D2) and 
--R            D2 has RING
--R
--RExamples of lllp from ThreeSpaceCategory
--R
--E 1642

--S 1643 of 3320
)d op llprop
--R 
--R
--RThere is one exposed function called llprop :
--R   [1] D -> List(List(SubSpaceComponentProperty)) from D
--R             if D has SPACEC(D2) and D2 has RING
--R
--RExamples of llprop from ThreeSpaceCategory
--R
--E 1643

--S 1644 of 3320
)d op lo
--R 
--R
--RThere is one exposed function called lo :
--R   [1] D -> D1 from D if D has SEGCAT(D1) and D1 has TYPE
--R
--RExamples of lo from SegmentCategory
--R
--E 1644

--S 1645 of 3320
)d op localAbs
--R 
--R
--RThere are 2 unexposed functions called localAbs :
--R   [1] D1 -> D1 from FunctionSpaceToExponentialExpansion(D2,D1,D3,D4)
--R             if D2 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D1 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D2)) and D3: SYMBOL and D4: D1
--R   [2] D1 -> D1 from FunctionSpaceToUnivariatePowerSeries(D2,D1,D3,D4,
--R            D5,D6)
--R             if D2 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D1 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D2))with
--R               coerce : D3 -> %and D3 has ORDRING and D4 has Join(
--R            UnivariatePowerSeriesCategory(D1,D3),Field,
--R            TranscendentalFunctionCategory)with
--R               differentiate : % -> %
--R               integrate : % -> %and D5 has PTRANFN(D4) and D6: 
--R            SYMBOL
--R
--RExamples of localAbs from FunctionSpaceToExponentialExpansion
--R
--R
--RExamples of localAbs from FunctionSpaceToUnivariatePowerSeries
--R
--E 1645

--S 1646 of 3320
)d op localIntegralBasis
--R 
--R
--RThere are 4 unexposed functions called localIntegralBasis :
--R   [1] D2 -> Record(basis: Matrix(D2),basisDen: D2,basisInv: Matrix(D2)
--R            )
--R             from FunctionFieldIntegralBasis(D2,D3,D4)
--R             if D2 has EuclideanDomainwith
--R               squareFree : % -> Factored(%)and D3 has UPOLYC(D2) 
--R            and D4 has FRAMALG(D2,D3)
--R   [2] Integer -> Record(basis: Matrix(Integer),basisDen: Integer,
--R            basisInv: Matrix(Integer))
--R             from NumberFieldIntegralBasis(D3,D4)
--R             if D3 has UPOLYC(INT) and D4 has FRAMALG(INT,D3)
--R   [3] D2 -> Record(basis: Matrix(D2),basisDen: D2,basisInv: Matrix(D2)
--R            )
--R             from PAdicWildFunctionFieldIntegralBasis(D3,D2,D4,D5)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3) and D4 has UPOLYC(
--R            D2) and D5 has MONOGEN(D2,D4)
--R   [4] D2 -> Record(basis: Matrix(D2),basisDen: D2,basisInv: Matrix(D2)
--R            )
--R             from WildFunctionFieldIntegralBasis(D3,D2,D4,D5)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3) and D4 has UPOLYC(
--R            D2) and D5 has FRAMALG(D2,D4)
--R
--RExamples of localIntegralBasis from FunctionFieldIntegralBasis
--R
--R
--RExamples of localIntegralBasis from NumberFieldIntegralBasis
--R
--R
--RExamples of localIntegralBasis from PAdicWildFunctionFieldIntegralBasis
--R
--R
--RExamples of localIntegralBasis from WildFunctionFieldIntegralBasis
--R
--E 1646

--S 1647 of 3320
)d op localize
--R 
--R
--RThere is one exposed function called localize :
--R   [1] (D3,D4,D3,Integer) -> Record(fnc: D3,crv: D3,chart: List(Integer
--R            ))
--R             from LocalParametrizationOfSimplePointPackage(D6,D7,D3,D8,
--R            D4,D9,D1)
--R             if D6 has FIELD and D7: LIST(SYMBOL) and D8 has DIRPCAT(#(
--R            D7),NNI) and D9 has LOCPOWC(D6) and D3 has POLYCAT(D6,D8,
--R            OVAR(D7)) and D4 has PRSPCAT(D6) and D1 has PLACESC(D6,D9)
--R            
--R
--RExamples of localize from LocalParametrizationOfSimplePointPackage
--R
--E 1647

--S 1648 of 3320
)d op localParam
--R 
--R
--RThere is one exposed function called localParam :
--R   [1] D -> List(D3) from D
--R             if D has PLACESC(D2,D3) and D2 has FIELD and D3 has 
--R            LOCPOWC(D2)
--R
--RExamples of localParam from PlacesCategory
--R
--E 1648

--S 1649 of 3320
)d op localParamOfSimplePt
--R 
--R
--RThere is one exposed function called localParamOfSimplePt :
--R   [1] (D3,D4,Integer) -> List(D9)
--R             from LocalParametrizationOfSimplePointPackage(D6,D7,D4,D8,
--R            D3,D9,D1)
--R             if D6 has FIELD and D7: LIST(SYMBOL) and D8 has DIRPCAT(#(
--R            D7),NNI) and D9 has LOCPOWC(D6) and D4 has POLYCAT(D6,D8,
--R            OVAR(D7)) and D3 has PRSPCAT(D6) and D1 has PLACESC(D6,D9)
--R            
--R
--RExamples of localParamOfSimplePt from LocalParametrizationOfSimplePointPackage
--R
--E 1649

--S 1650 of 3320
)d op localParamV
--R 
--R
--RThere is one exposed function called localParamV :
--R   [1] D -> List(D9) from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of localParamV from InfinitlyClosePointCategory
--R
--E 1650

--S 1651 of 3320
)d op localPointV
--R 
--R
--RThere is one exposed function called localPointV :
--R   [1] D -> AffinePlane(D4) from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of localPointV from InfinitlyClosePointCategory
--R
--E 1651

--S 1652 of 3320
)d op localReal?
--R 
--R
--RThere is one unexposed function called localReal? :
--R   [1] D2 -> Boolean from ElementaryFunction(D3,D2)
--R             if D3 has Join(OrderedSet,IntegralDomain) and D2 has Join(
--R            FunctionSpace(D3),RadicalCategory)
--R
--RExamples of localReal? from ElementaryFunction
--R
--E 1652

--S 1653 of 3320
)d op localUnquote
--R 
--R
--RThere is one unexposed function called localUnquote :
--R   [1] (D1,List(Symbol)) -> D1 from ApplyRules(D3,D4,D1)
--R             if D3 has SETCAT and D4 has Join(Ring,PatternMatchable(D3)
--R            ,OrderedSet,ConvertibleTo(Pattern(D3))) and D1 has Join(
--R            FunctionSpace(D4),PatternMatchable(D3),ConvertibleTo(
--R            Pattern(D3)))
--R
--RExamples of localUnquote from ApplyRules
--R
--E 1653

--S 1654 of 3320
)d op LODO2FUN
--R 
--R
--RThere is one unexposed function called LODO2FUN :
--R   [1] D2 -> (List(D5) -> D5) from UTSodetools(D3,D4,D2,D5)
--R             if D3 has RING and D4 has UPOLYC(D3) and D2 has LODOCAT(D4
--R            ) and D5 has UTSCAT(D3)
--R
--RExamples of LODO2FUN from UTSodetools
--R
--E 1654

--S 1655 of 3320
)d op log
--R 
--R
--RThere are 2 exposed functions called log :
--R   [1] D -> D from D if D has ELEMFUN
--R   [2] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R
--RThere are 9 unexposed functions called log :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Factored(D3) -> List(Record(coef: NonNegativeInteger,logand: D3)
--R            )
--R             from FactoredFunctions(D3) if D3 has INTDOM
--R   [5] LieExponentials(D2,D3,D4) -> LiePolynomial(D2,D3)
--R             from LieExponentials(D2,D3,D4)
--R             if D2 has ORDSET and D3 has Join(CommutativeRing,Module(
--R            Fraction(Integer))) and D4: PI
--R   [6] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [7] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [8] (D1,NonNegativeInteger) -> D1 from XExponentialPackage(D3,D4,D1)
--R             if D3 has Join(Ring,Module(Fraction(Integer))) and D4 has 
--R            ORDSET and D1 has XPOLYC(D4,D3)
--R   [9] (XPBWPolynomial(D2,D3),NonNegativeInteger) -> XPBWPolynomial(D2,
--R            D3)
--R             from XPBWPolynomial(D2,D3)
--R             if D3 has MODULE(FRAC(INT)) and D2 has ORDSET and D3 has 
--R            COMRING
--R
--RExamples of log from ElementaryFunction
--R
--R
--RExamples of log from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of log from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of log from ElementaryFunctionCategory
--R
--R
--RExamples of log from FactoredFunctions
--R
--R
--RExamples of log from FortranExpression
--R
--R
--RExamples of log from LieExponentials
--R
--R
--RExamples of log from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of log from StreamTranscendentalFunctions
--R
--R
--RExamples of log from XExponentialPackage
--R
--R
--RExamples of log from XPBWPolynomial
--R
--E 1655

--S 1656 of 3320
)d op log10
--R 
--R
--RThere are 4 exposed functions called log10 :
--R   [1] DoubleFloat -> DoubleFloat from DoubleFloat
--R   [2] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R   [3] Float -> Float from Float
--R   [4]  -> Float from Float
--R
--RExamples of log10 from DoubleFloat
--R
--R
--RExamples of log10 from FortranExpression
--R
--R
--RExamples of log10 from Float
--R
--E 1656

--S 1657 of 3320
)d op log2
--R 
--R
--RThere are 3 exposed functions called log2 :
--R   [1] DoubleFloat -> DoubleFloat from DoubleFloat
--R   [2] Float -> Float from Float
--R   [3]  -> Float from Float
--R
--RExamples of log2 from DoubleFloat
--R
--R
--RExamples of log2 from Float
--R
--E 1657

--S 1658 of 3320 done
)d op logGamma
--R 
--R
--RThere are 4 exposed functions called logGamma :
--R   [1] DoubleFloat -> DoubleFloat from DoubleFloatSpecialFunctions
--R   [2] Complex(DoubleFloat) -> Complex(DoubleFloat)
--R             from DoubleFloatSpecialFunctions
--R   [3] Float -> Float from FloatSpecialFunctions
--R   [4] Complex(Float) -> Complex(Float) from FloatSpecialFunctions
--R
--RExamples of logGamma from DoubleFloatSpecialFunctions
--R
--Ra:Complex(DoubleFloat):=3.5*%i 
--RlogGamma(a)
--R
--Ra:DoubleFloat:=3.5 
--RlogGamma(a)
--R
--R
--RExamples of logGamma from FloatSpecialFunctions
--R
--Ra:Complex(Float):=3.5*%i 
--RlogGamma(a)
--R
--RlogGamma(3.5)
--R
--E 1658

--S 1659 of 3320
)d op logical?
--R 
--R
--RThere is one exposed function called logical? :
--R   [1] FortranScalarType -> Boolean from FortranScalarType
--R
--RExamples of logical? from FortranScalarType
--R
--E 1659

--S 1660 of 3320
)d op logIfCan
--R 
--R
--RThere is one exposed function called logIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of logIfCan from PartialTranscendentalFunctions
--R
--E 1660

--S 1661 of 3320
)d op logpart
--R 
--R
--RThere is one unexposed function called logpart :
--R   [1] IntegrationResult(D2) -> List(Record(scalar: Fraction(Integer),
--R            coeff: SparseUnivariatePolynomial(D2),logand: 
--R            SparseUnivariatePolynomial(D2)))
--R             from IntegrationResult(D2) if D2 has FIELD
--R
--RExamples of logpart from IntegrationResult
--R
--E 1661

--S 1662 of 3320
)d op lookup
--R 
--R
--RThere is one exposed function called lookup :
--R   [1] D -> PositiveInteger from D if D has FINITE
--R
--RThere is one unexposed function called lookup :
--R   [1] Vector(D3) -> PositiveInteger from 
--R            InnerNormalBasisFieldFunctions(D3)
--R             if D3 has FFIELDC
--R
--RExamples of lookup from Finite
--R
--R
--RExamples of lookup from InnerNormalBasisFieldFunctions
--R
--E 1662

--S 1663 of 3320
)d op loopPoints
--R 
--R
--RThere is one unexposed function called loopPoints :
--R   [1] (Point(DoubleFloat),Point(DoubleFloat),Point(DoubleFloat),
--R            DoubleFloat,List(List(DoubleFloat))) -> List(Point(DoubleFloat))
--R             from TubePlotTools
--R
--RExamples of loopPoints from TubePlotTools
--R
--E 1663

--S 1664 of 3320
)d op low
--R 
--R
--RThere is one exposed function called low :
--R   [1] D -> D1 from D if D has SEGCAT(D1) and D1 has TYPE
--R
--RExamples of low from SegmentCategory
--R
--E 1664

--S 1665 of 3320
)d op lowerCase
--R 
--R
--RThere are 3 exposed functions called lowerCase :
--R   [1]  -> CharacterClass from CharacterClass
--R   [2] Character -> Character from Character
--R   [3] D -> D from D if D has SRAGG
--R
--RExamples of lowerCase from CharacterClass
--R
--R
--RExamples of lowerCase from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[lowerCase c for c in chars]
--R
--R
--RExamples of lowerCase from StringAggregate
--R
--E 1665

--S 1666 of 3320
)d op lowerCase!
--R 
--R
--RThere is one exposed function called lowerCase! :
--R   [1] D -> D from D if D has SRAGG
--R
--RExamples of lowerCase! from StringAggregate
--R
--E 1666

--S 1667 of 3320 done
)d op lowerCase?
--R 
--R
--RThere is one exposed function called lowerCase? :
--R   [1] Character -> Boolean from Character
--R
--RExamples of lowerCase? from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[lowerCase? c for c in chars]
--R
--E 1667

--S 1668 of 3320
)d op lowerPolynomial
--R 
--R
--RThere is one unexposed function called lowerPolynomial :
--R   [1] SparseUnivariatePolynomial(D6) -> SparseUnivariatePolynomial(D5)
--R             from FactoringUtilities(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D5,D3,D4) and D3 has OAMONS and D4 has 
--R            ORDSET and D5 has RING
--R
--RExamples of lowerPolynomial from FactoringUtilities
--R
--E 1668

--S 1669 of 3320
)d op LowTriBddDenomInv
--R 
--R
--RThere is one unexposed function called LowTriBddDenomInv :
--R   [1] (D1,D2) -> D1 from TriangularMatrixOperations(D2,D3,D4,D1)
--R             if D2 has INTDOM and D3 has FLAGG(D2) and D4 has FLAGG(D2)
--R            and D1 has MATCAT(D2,D3,D4)
--R
--RExamples of LowTriBddDenomInv from TriangularMatrixOperations
--R
--E 1669

--S 1670 of 3320
)d op lp
--R 
--R
--RThere is one exposed function called lp :
--R   [1] D -> List(Point(D2)) from D if D has SPACEC(D2) and D2 has RING
--R            
--R
--RExamples of lp from ThreeSpaceCategory
--R
--E 1670

--S 1671 of 3320
)d op LPolynomial
--R 
--R
--RThere are 6 exposed functions called LPolynomial :
--R   [1]  -> SparseUnivariatePolynomial(Integer)
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R             if D6 has FINITE and D6 has FIELD and D7: LIST(SYMBOL) and
--R            D8 has POLYCAT(D6,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI
--R            ) and D10 has PRSPCAT(D6) and D11 has LOCPOWC(D6) and D12
--R             has PLACESC(D6,D11) and D1 has DIVCAT(D12) and D2 has 
--R            INFCLCT(D6,D7,D8,D9,D10,D11,D12,D1,D4) and D4 has BLMETCT 
--R            and D3 has DSTRCAT(D2)
--R   [2] PositiveInteger -> SparseUnivariatePolynomial(Integer)
--R             from GeneralPackageForAlgebraicFunctionField(D8,D9,D10,D11
--R            ,D12,D13,D1,D2,D3,D4,D5)
--R             if D8 has FINITE and D8 has FIELD and D9: LIST(SYMBOL) and
--R            D10 has POLYCAT(D8,D11,OVAR(D9)) and D11 has DIRPCAT(#(D9),
--R            NNI) and D12 has PRSPCAT(D8) and D13 has LOCPOWC(D8) and D1
--R             has PLACESC(D8,D13) and D2 has DIVCAT(D1) and D3 has 
--R            INFCLCT(D8,D9,D10,D11,D12,D13,D1,D2,D5) and D5 has BLMETCT 
--R            and D4 has DSTRCAT(D3)
--R   [3]  -> SparseUnivariatePolynomial(Integer)
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if PseudoAlgebraicClosureOfFiniteField(D2) has FINITE and 
--R            D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R   [4] PositiveInteger -> SparseUnivariatePolynomial(Integer)
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D3,D4
--R            ,D5)
--R             if PseudoAlgebraicClosureOfFiniteField(D3) has FINITE and 
--R            D3 has FFIELDC and D4: LIST(SYMBOL) and D5 has BLMETCT
--R   [5]  -> SparseUnivariatePolynomial(Integer)
--R             from PackageForAlgebraicFunctionField(D2,D3,D4)
--R             if D2 has FINITE and D2 has FIELD and D3: LIST(SYMBOL) and
--R            D4 has BLMETCT
--R   [6] PositiveInteger -> SparseUnivariatePolynomial(Integer)
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FINITE and D3 has FIELD and D4: LIST(SYMBOL) and
--R            D5 has BLMETCT
--R
--RExamples of LPolynomial from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of LPolynomial from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of LPolynomial from PackageForAlgebraicFunctionField
--R
--E 1671

--S 1672 of 3320
)d op lprop
--R 
--R
--RThere is one exposed function called lprop :
--R   [1] D -> List(SubSpaceComponentProperty) from D
--R             if D has SPACEC(D2) and D2 has RING
--R
--RExamples of lprop from ThreeSpaceCategory
--R
--E 1672

--S 1673 of 3320
)d op lquo
--R 
--R
--RThere are 4 exposed functions called lquo :
--R   [1] (XRecursivePolynomial(D2,D3),D) -> XRecursivePolynomial(D2,D3)
--R             from D
--R             if D has FLALG(D2,D3) and D2 has ORDSET and D3 has COMRING
--R            
--R   [2] (D,D) -> D from D if D has XFALG(D1,D2) and D1 has ORDSET and D2
--R             has RING
--R   [3] (D,OrderedFreeMonoid(D2)) -> D from D
--R             if D has XFALG(D2,D3) and D2 has ORDSET and D3 has RING
--R         
--R   [4] (D,D1) -> D from D if D has XFALG(D1,D2) and D1 has ORDSET and 
--R            D2 has RING
--R
--RThere are 3 unexposed functions called lquo :
--R   [1] (FreeMonoid(D1),FreeMonoid(D1)) -> Union(FreeMonoid(D1),"failed"
--R            )
--R             from FreeMonoid(D1) if D1 has SETCAT
--R   [2] (OrderedFreeMonoid(D1),D1) -> Union(OrderedFreeMonoid(D1),
--R            "failed")
--R             from OrderedFreeMonoid(D1) if D1 has ORDSET
--R   [3] (OrderedFreeMonoid(D1),OrderedFreeMonoid(D1)) -> Union(
--R            OrderedFreeMonoid(D1),"failed")
--R             from OrderedFreeMonoid(D1) if D1 has ORDSET
--R
--RExamples of lquo from FreeLieAlgebra
--R
--R
--RExamples of lquo from FreeMonoid
--R
--R
--RExamples of lquo from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rlquo(m1,x)
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rm2:=(x*y)$OFMONOID(Symbol) 
--Rlquo(m1,m2)
--R
--R
--RExamples of lquo from XFreeAlgebra
--R
--E 1673

--S 1674 of 3320
)d op lSpaceBasis
--R 
--R
--RThere is one unexposed function called lSpaceBasis :
--R   [1] FiniteDivisor(D2,D3,D4,D5) -> Vector(D5) from FiniteDivisor(D2,
--R            D3,D4,D5)
--R             if D2 has FIELD and D3 has UPOLYC(D2) and D4 has UPOLYC(
--R            FRAC(D3)) and D5 has FFCAT(D2,D3,D4)
--R
--RExamples of lSpaceBasis from FiniteDivisor
--R
--E 1674

--S 1675 of 3320
)d op LT
--R 
--R
--RThere is one exposed function called LT :
--R   [1] (Union(I: Expression(Integer),F: Expression(Float),CF: 
--R            Expression(Complex(Float)),switch: Switch),Union(I: Expression(
--R            Integer),F: Expression(Float),CF: Expression(Complex(Float)),
--R            switch: Switch)) -> Switch
--R             from Switch
--R
--RExamples of LT from Switch
--R
--E 1675

--S 1676 of 3320
)d op lyndon
--R 
--R
--RThere is one unexposed function called lyndon :
--R   [1] OrderedFreeMonoid(D2) -> LyndonWord(D2) from LyndonWord(D2) if 
--R            D2 has ORDSET
--R
--RExamples of lyndon from LyndonWord
--R
--E 1676

--S 1677 of 3320
)d op lyndon?
--R 
--R
--RThere is one unexposed function called lyndon? :
--R   [1] OrderedFreeMonoid(D3) -> Boolean from LyndonWord(D3) if D3 has 
--R            ORDSET
--R
--RExamples of lyndon? from LyndonWord
--R
--E 1677

--S 1678 of 3320
)d op LyndonBasis
--R 
--R
--RThere is one unexposed function called LyndonBasis :
--R   [1] List(D3) -> List(LiePolynomial(D3,D4)) from LieExponentials(D3,
--R            D4,D5)
--R             if D3 has ORDSET and D4 has Join(CommutativeRing,Module(
--R            Fraction(Integer))) and D5: PI
--R
--RExamples of LyndonBasis from LieExponentials
--R
--E 1678

--S 1679 of 3320
)d op LyndonCoordinates
--R 
--R
--RThere is one unexposed function called LyndonCoordinates :
--R   [1] LieExponentials(D2,D3,D4) -> List(Record(k: LyndonWord(D2),c: D3
--R            ))
--R             from LieExponentials(D2,D3,D4)
--R             if D2 has ORDSET and D3 has Join(CommutativeRing,Module(
--R            Fraction(Integer))) and D4: PI
--R
--RExamples of LyndonCoordinates from LieExponentials
--R
--E 1679

--S 1680 of 3320
)d op lyndonIfCan
--R 
--R
--RThere is one unexposed function called lyndonIfCan :
--R   [1] OrderedFreeMonoid(D2) -> Union(LyndonWord(D2),"failed")
--R             from LyndonWord(D2) if D2 has ORDSET
--R
--RExamples of lyndonIfCan from LyndonWord
--R
--E 1680

--S 1681 of 3320
)d op machineFraction
--R 
--R
--RThere is one exposed function called machineFraction :
--R   [1] DoubleFloat -> Fraction(Integer) from DoubleFloat
--R
--RExamples of machineFraction from DoubleFloat
--R
--Ra:DFLOAT:=-1.0/3.0 
--RmachineFraction a
--R
--E 1681

--S 1682 of 3320
)d op magnitude
--R 
--R
--RThere is one exposed function called magnitude :
--R   [1] D -> D1 from D
--R             if D has VECTCAT(D1) and D1 has TYPE and D1 has RADCAT and
--R            D1 has RING
--R
--RExamples of magnitude from VectorCategory
--R
--E 1682

--S 1683 of 3320
)d op mainCharacterization
--R 
--R
--RThere is one exposed function called mainCharacterization :
--R   [1] RealClosure(D2) -> Union(RightOpenIntervalRootCharacterization(
--R            RealClosure(D2),SparseUnivariatePolynomial(RealClosure(D2))),
--R            "failed")
--R             from RealClosure(D2) if D2 has Join(OrderedRing,Field,
--R            RealConstant)
--R
--RExamples of mainCharacterization from RealClosure
--R
--E 1683

--S 1684 of 3320
)d op mainCoefficients
--R 
--R
--RThere is one exposed function called mainCoefficients :
--R   [1] D -> List(D) from D
--R             if D2 has RING and D3 has OAMONS and D4 has ORDSET and D
--R             has RPOLCAT(D2,D3,D4)
--R
--RExamples of mainCoefficients from RecursivePolynomialCategory
--R
--E 1684

--S 1685 of 3320
)d op mainContent
--R 
--R
--RThere is one exposed function called mainContent :
--R   [1] D -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has GCDDOM
--R
--RExamples of mainContent from RecursivePolynomialCategory
--R
--E 1685

--S 1686 of 3320
)d op mainDefiningPolynomial
--R 
--R
--RThere is one exposed function called mainDefiningPolynomial :
--R   [1] D -> Union(SparseUnivariatePolynomial(D),"failed") from D if D
--R             has RCFIELD
--R
--RExamples of mainDefiningPolynomial from RealClosedField
--R
--E 1686

--S 1687 of 3320
)d op mainForm
--R 
--R
--RThere is one exposed function called mainForm :
--R   [1] D -> Union(OutputForm,"failed") from D if D has RCFIELD
--R
--RExamples of mainForm from RealClosedField
--R
--E 1687

--S 1688 of 3320
)d op mainKernel
--R 
--R
--RThere is one exposed function called mainKernel :
--R   [1] D -> Union(Kernel(D),"failed") from D if D has ES
--R
--RExamples of mainKernel from ExpressionSpace
--R
--E 1688

--S 1689 of 3320
)d op mainMonomial
--R 
--R
--RThere is one exposed function called mainMonomial :
--R   [1] D -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R
--RExamples of mainMonomial from RecursivePolynomialCategory
--R
--E 1689

--S 1690 of 3320
)d op mainMonomials
--R 
--R
--RThere is one exposed function called mainMonomials :
--R   [1] D -> List(D) from D
--R             if D2 has RING and D3 has OAMONS and D4 has ORDSET and D
--R             has RPOLCAT(D2,D3,D4)
--R
--RExamples of mainMonomials from RecursivePolynomialCategory
--R
--E 1690

--S 1691 of 3320
)d op mainPrimitivePart
--R 
--R
--RThere is one exposed function called mainPrimitivePart :
--R   [1] D -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has GCDDOM
--R
--RExamples of mainPrimitivePart from RecursivePolynomialCategory
--R
--E 1691

--S 1692 of 3320
)d op mainSquareFreePart
--R 
--R
--RThere is one exposed function called mainSquareFreePart :
--R   [1] D -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has GCDDOM
--R
--RExamples of mainSquareFreePart from RecursivePolynomialCategory
--R
--E 1692

--S 1693 of 3320
)d op mainValue
--R 
--R
--RThere is one exposed function called mainValue :
--R   [1] D -> Union(SparseUnivariatePolynomial(D),"failed") from D if D
--R             has RCFIELD
--R
--RExamples of mainValue from RealClosedField
--R
--E 1693

--S 1694 of 3320
)d op mainVariable
--R 
--R
--RThere are 2 exposed functions called mainVariable :
--R   [1] D -> Union(D1,"failed") from D
--R             if D has POLYCAT(D2,D3,D1) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET
--R   [2] Fraction(Polynomial(D3)) -> Union(Symbol,"failed")
--R             from RationalFunction(D3) if D3 has INTDOM
--R
--RThere is one unexposed function called mainVariable :
--R   [1] D2 -> Union(D1,"failed")
--R             from PolynomialCategoryQuotientFunctions(D3,D1,D4,D5,D2)
--R             if D3 has OAMONS and D4 has RING and D5 has POLYCAT(D4,D3,
--R            D1) and D1 has ORDSET and D2 has Fieldwith
--R               coerce : D5 -> %
--R               numer : % -> D5
--R               denom : % -> D5
--R
--RExamples of mainVariable from PolynomialCategory
--R
--R
--RExamples of mainVariable from PolynomialCategoryQuotientFunctions
--R
--R
--RExamples of mainVariable from RationalFunction
--R
--E 1694

--S 1695 of 3320
)d op mainVariable?
--R 
--R
--RThere is one exposed function called mainVariable? :
--R   [1] (D2,D) -> Boolean from D
--R             if D has PSETCAT(D3,D4,D2,D5) and D3 has RING and D4 has 
--R            OAMONS and D2 has ORDSET and D5 has RPOLCAT(D3,D4,D2)
--R
--RExamples of mainVariable? from PolynomialSetCategory
--R
--E 1695

--S 1696 of 3320
)d op mainVariableOf
--R 
--R
--RThere is one exposed function called mainVariableOf :
--R   [1] Cell(D2) -> Symbol from Cell(D2) if D2 has RCFIELD
--R
--RExamples of mainVariableOf from Cell
--R
--E 1696

--S 1697 of 3320
)d op mainVariables
--R 
--R
--RThere is one exposed function called mainVariables :
--R   [1] D -> List(D4) from D
--R             if D has PSETCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R
--RExamples of mainVariables from PolynomialSetCategory
--R
--E 1697

--S 1698 of 3320
)d op makeCell
--R 
--R
--RThere are 2 exposed functions called makeCell :
--R   [1] (SimpleCell(D2,SparseUnivariatePolynomial(D2)),Cell(D2)) -> Cell
--R            (D2)
--R             from Cell(D2) if D2 has RCFIELD
--R   [2] List(SimpleCell(D2,SparseUnivariatePolynomial(D2))) -> Cell(D2)
--R             from Cell(D2) if D2 has RCFIELD
--R
--RExamples of makeCell from Cell
--R
--E 1698

--S 1699 of 3320
)d op makeCos
--R 
--R
--RThere is one exposed function called makeCos :
--R   [1] (D1,D2) -> FourierSeries(D2,D1) from FourierSeries(D2,D1)
--R             if D2 has Join(CommutativeRing,Algebra(Fraction(Integer)))
--R            and D1 has Join(OrderedSet,AbelianGroup)
--R
--RExamples of makeCos from FourierSeries
--R
--E 1699

--S 1700 of 3320
)d op makeCrit
--R 
--R
--RThere is one unexposed function called makeCrit :
--R   [1] (Record(totdeg: NonNegativeInteger,pol: D3),D3,
--R            NonNegativeInteger) -> Record(lcmfij: D6,totdeg: 
--R            NonNegativeInteger,poli: D3,polj: D3)
--R             from GroebnerInternalPackage(D5,D6,D7,D3)
--R             if D3 has POLYCAT(D5,D6,D7) and D5 has GCDDOM and D6 has 
--R            OAMONS and D7 has ORDSET
--R
--RExamples of makeCrit from GroebnerInternalPackage
--R
--E 1700

--S 1701 of 3320
)d op makeEq
--R 
--R
--RThere is one unexposed function called makeEq :
--R   [1] (List(D5),List(Symbol)) -> List(Equation(Polynomial(D5)))
--R             from InnerNumericFloatSolvePackage(D4,D5,D6)
--R             if D5 has FIELD and D4 has GCDDOM and D6 has Join(Field,
--R            OrderedRing)
--R
--RExamples of makeEq from InnerNumericFloatSolvePackage
--R
--E 1701

--S 1702 of 3320
)d op makeFloatFunction
--R 
--R
--RThere are 2 exposed functions called makeFloatFunction :
--R   [1] (D2,Symbol) -> (DoubleFloat -> DoubleFloat)
--R             from MakeFloatCompiledFunction(D2) if D2 has KONVERT(
--R            INFORM)
--R   [2] (D2,Symbol,Symbol) -> ((DoubleFloat,DoubleFloat) -> DoubleFloat)
--R             from MakeFloatCompiledFunction(D2) if D2 has KONVERT(
--R            INFORM)
--R
--RExamples of makeFloatFunction from MakeFloatCompiledFunction
--R
--E 1702

--S 1703 of 3320
)d op makeFR
--R 
--R
--RThere is one exposed function called makeFR :
--R   [1] (D1,List(Record(flg: Union("nil","sqfr","irred","prime"),fctr: 
--R            D1,xpnt: Integer))) -> Factored(D1)
--R             from Factored(D1) if D1 has INTDOM
--R
--RThere is one unexposed function called makeFR :
--R   [1] Record(contp: Integer,factors: List(Record(irr: D3,pow: Integer)
--R            )) -> Factored(D3)
--R             from GaloisGroupFactorizer(D3) if D3 has UPOLYC(INT)
--R
--RExamples of makeFR from Factored
--R
--Rf:=nilFactor(x-y,3) 
--Rg:=factorList f 
--RmakeFR(z,g)
--R
--R
--RExamples of makeFR from GaloisGroupFactorizer
--R
--E 1703

--S 1704 of 3320
)d op makeGraphImage
--R 
--R
--RThere are 4 unexposed functions called makeGraphImage :
--R   [1] (List(List(Point(DoubleFloat))),List(Palette),List(Palette),List
--R            (PositiveInteger),List(DrawOption)) -> GraphImage
--R             from GraphImage
--R   [2] (List(List(Point(DoubleFloat))),List(Palette),List(Palette),List
--R            (PositiveInteger)) -> GraphImage
--R             from GraphImage
--R   [3] List(List(Point(DoubleFloat))) -> GraphImage from GraphImage
--R   [4] GraphImage -> GraphImage from GraphImage
--R
--RExamples of makeGraphImage from GraphImage
--R
--E 1704

--S 1705 of 3320
)d op makeMulti
--R 
--R
--RThere is one unexposed function called makeMulti :
--R   [1] List(Record(gen: D2,exp: D3)) -> ListMonoidOps(D2,D3,D4)
--R             from ListMonoidOps(D2,D3,D4)
--R             if D2 has SETCAT and D3 has ABELMON and D4: D3
--R
--RExamples of makeMulti from ListMonoidOps
--R
--E 1705

--S 1706 of 3320
)d op makeObject
--R 
--R
--RThere are 16 exposed functions called makeObject :
--R   [1] (ParametricSpaceCurve((DoubleFloat -> DoubleFloat)),Segment(
--R            Float),List(DrawOption)) -> ThreeSpace(DoubleFloat)
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [2] (ParametricSpaceCurve((DoubleFloat -> DoubleFloat)),Segment(
--R            Float)) -> ThreeSpace(DoubleFloat)
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [3] ((DoubleFloat -> Point(DoubleFloat)),Segment(Float),List(
--R            DrawOption)) -> ThreeSpace(DoubleFloat)
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [4] ((DoubleFloat -> Point(DoubleFloat)),Segment(Float)) -> 
--R            ThreeSpace(DoubleFloat)
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [5] (((DoubleFloat,DoubleFloat) -> DoubleFloat),Segment(Float),
--R            Segment(Float),List(DrawOption)) -> ThreeSpace(DoubleFloat)
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [6] (((DoubleFloat,DoubleFloat) -> DoubleFloat),Segment(Float),
--R            Segment(Float)) -> ThreeSpace(DoubleFloat)
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [7] (((DoubleFloat,DoubleFloat) -> Point(DoubleFloat)),Segment(Float
--R            ),Segment(Float),List(DrawOption)) -> ThreeSpace(DoubleFloat)
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [8] (((DoubleFloat,DoubleFloat) -> Point(DoubleFloat)),Segment(Float
--R            ),Segment(Float)) -> ThreeSpace(DoubleFloat)
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [9] (ParametricSurface(((DoubleFloat,DoubleFloat) -> DoubleFloat)),
--R            Segment(Float),Segment(Float),List(DrawOption)) -> ThreeSpace(
--R            DoubleFloat)
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [10] (ParametricSurface(((DoubleFloat,DoubleFloat) -> DoubleFloat)),
--R            Segment(Float),Segment(Float)) -> ThreeSpace(DoubleFloat)
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R   [11] (ParametricSpaceCurve(D5),SegmentBinding(Float),List(DrawOption
--R            )) -> ThreeSpace(DoubleFloat)
--R             from TopLevelDrawFunctions(D5)
--R             if D5 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [12] (ParametricSpaceCurve(D4),SegmentBinding(Float)) -> ThreeSpace(
--R            DoubleFloat)
--R             from TopLevelDrawFunctions(D4)
--R             if D4 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [13] (D2,SegmentBinding(Float),SegmentBinding(Float),List(DrawOption
--R            )) -> ThreeSpace(DoubleFloat)
--R             from TopLevelDrawFunctions(D2)
--R             if D2 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [14] (D2,SegmentBinding(Float),SegmentBinding(Float)) -> ThreeSpace(
--R            DoubleFloat)
--R             from TopLevelDrawFunctions(D2)
--R             if D2 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [15] (ParametricSurface(D5),SegmentBinding(Float),SegmentBinding(
--R            Float),List(DrawOption)) -> ThreeSpace(DoubleFloat)
--R             from TopLevelDrawFunctions(D5)
--R             if D5 has Join(ConvertibleTo(InputForm),SetCategory)
--R   [16] (ParametricSurface(D4),SegmentBinding(Float),SegmentBinding(
--R            Float)) -> ThreeSpace(DoubleFloat)
--R             from TopLevelDrawFunctions(D4)
--R             if D4 has Join(ConvertibleTo(InputForm),SetCategory)
--R
--RExamples of makeObject from TopLevelDrawFunctionsForCompiledFunctions
--R
--R
--RExamples of makeObject from TopLevelDrawFunctions
--R
--E 1706

--S 1707 of 3320
)d op makeop
--R 
--R
--RThere is one exposed function called makeop :
--R   [1] (D1,FreeGroup(BasicOperator)) -> ModuleOperator(D1,D3)
--R             from ModuleOperator(D1,D3) if D1 has RING and D3 has 
--R            LMODULE(D1)
--R
--RThere is one unexposed function called makeop :
--R   [1] (D1,FreeGroup(BasicOperator)) -> Operator(D1) from Operator(D1)
--R             if D1 has RING
--R
--RExamples of makeop from ModuleOperator
--R
--R
--RExamples of makeop from Operator
--R
--E 1707

--S 1708 of 3320 done
)d op makeprod
--R 
--R
--RThere is one unexposed function called makeprod :
--R   [1] (D1,D2) -> Product(D1,D2) from Product(D1,D2)
--R             if D1 has SETCAT and D2 has SETCAT
--R
--RExamples of makeprod from Product
--R
--Rf:=(x:INT):INT +-> 3*x 
--Rg:=(x:INT):INT +-> x^3 
--Rh(x:INT):Product(INT,INT) == makeprod(f x, g x) 
--Rh(3)
--R
--E 1708

--S 1709 of 3320
)d op makeRecord
--R 
--R
--RThere is one exposed function called makeRecord :
--R   [1] (D2,D3) -> Record(part1: D2,part2: D3) from MakeRecord(D2,D3)
--R             if D2 has TYPE and D3 has TYPE
--R
--RExamples of makeRecord from MakeRecord
--R
--E 1709

--S 1710 of 3320
)d op makeResult
--R 
--R
--RThere is one unexposed function called makeResult :
--R   [1] (PatternMatchResult(D3,D4),PatternMatchResult(D3,D5)) -> 
--R            PatternMatchListResult(D3,D4,D5)
--R             from PatternMatchListResult(D3,D4,D5)
--R             if D3 has SETCAT and D4 has SETCAT and D5 has LSAGG(D4)
--R         
--R
--RExamples of makeResult from PatternMatchListResult
--R
--E 1710

--S 1711 of 3320
)d op makeSeries
--R 
--R
--RThere is one unexposed function called makeSeries :
--R   [1] (Reference(OrderedCompletion(Integer)),Stream(Record(k: Integer,
--R            c: D3))) -> InnerSparseUnivariatePowerSeries(D3)
--R             from InnerSparseUnivariatePowerSeries(D3) if D3 has RING
--R         
--R
--RExamples of makeSeries from InnerSparseUnivariatePowerSeries
--R
--E 1711

--S 1712 of 3320
)d op makeSin
--R 
--R
--RThere is one exposed function called makeSin :
--R   [1] (D1,D2) -> FourierSeries(D2,D1) from FourierSeries(D2,D1)
--R             if D2 has Join(CommutativeRing,Algebra(Fraction(Integer)))
--R            and D1 has Join(OrderedSet,AbelianGroup)
--R
--RExamples of makeSin from FourierSeries
--R
--E 1712

--S 1713 of 3320 done
)d op makeSketch
--R 
--R
--RThere is one unexposed function called makeSketch :
--R   [1] (Polynomial(Integer),Symbol,Symbol,Segment(Fraction(Integer)),
--R            Segment(Fraction(Integer))) -> PlaneAlgebraicCurvePlot
--R             from PlaneAlgebraicCurvePlot
--R
--RExamples of makeSketch from PlaneAlgebraicCurvePlot
--R
--RmakeSketch(x+y,x,y,-1/2..1/2,-1/2..1/2)$ACPLOT
--R
--E 1713

--S 1714 of 3320
)d op makeSUP
--R 
--R
--RThere is one exposed function called makeSUP :
--R   [1] D -> SparseUnivariatePolynomial(D2) from D if D has UPOLYC(D2) 
--R            and D2 has RING
--R
--RExamples of makeSUP from UnivariatePolynomialCategory
--R
--E 1714

--S 1715 of 3320
)d op makeTerm
--R 
--R
--RThere is one unexposed function called makeTerm :
--R   [1] (D1,D2) -> ListMonoidOps(D1,D2,D3) from ListMonoidOps(D1,D2,D3)
--R             if D1 has SETCAT and D2 has ABELMON and D3: D2
--R
--RExamples of makeTerm from ListMonoidOps
--R
--E 1715

--S 1716 of 3320
)d op makeUnit
--R 
--R
--RThere is one unexposed function called makeUnit :
--R   [1]  -> ListMonoidOps(D1,D2,D3) from ListMonoidOps(D1,D2,D3)
--R             if D1 has SETCAT and D2 has ABELMON and D3: D2
--R
--RExamples of makeUnit from ListMonoidOps
--R
--E 1716

--S 1717 of 3320
)d op makeVariable
--R 
--R
--RThere are 3 exposed functions called makeVariable :
--R   [1] D -> (NonNegativeInteger -> D) from D
--R             if D2 has DIFRING and D2 has RING and D3 has ORDSET and D4
--R             has DVARCAT(D3) and D5 has OAMONS and D has DPOLCAT(D2,D3,
--R            D4,D5)
--R   [2] D2 -> (NonNegativeInteger -> D) from D
--R             if D3 has RING and D2 has ORDSET and D4 has DVARCAT(D2) 
--R            and D5 has OAMONS and D has DPOLCAT(D3,D2,D4,D5)
--R   [3] (D1,NonNegativeInteger) -> D from D if D has DVARCAT(D1) and D1
--R             has ORDSET
--R
--RExamples of makeVariable from DifferentialPolynomialCategory
--R
--R
--RExamples of makeVariable from DifferentialVariableCategory
--R
--E 1717

--S 1718 of 3320
)d op makeViewport2D
--R 
--R
--RThere are 2 unexposed functions called makeViewport2D :
--R   [1] (GraphImage,List(DrawOption)) -> TwoDimensionalViewport
--R             from TwoDimensionalViewport
--R   [2] TwoDimensionalViewport -> TwoDimensionalViewport
--R             from TwoDimensionalViewport
--R
--RExamples of makeViewport2D from TwoDimensionalViewport
--R
--E 1718

--S 1719 of 3320
)d op makeViewport3D
--R 
--R
--RThere are 3 exposed functions called makeViewport3D :
--R   [1] (ThreeSpace(DoubleFloat),List(DrawOption)) -> 
--R            ThreeDimensionalViewport
--R             from ThreeDimensionalViewport
--R   [2] (ThreeSpace(DoubleFloat),String) -> ThreeDimensionalViewport
--R             from ThreeDimensionalViewport
--R   [3] ThreeDimensionalViewport -> ThreeDimensionalViewport
--R             from ThreeDimensionalViewport
--R
--RExamples of makeViewport3D from ThreeDimensionalViewport
--R
--E 1719

--S 1720 of 3320
)d op makeYoungTableau
--R 
--R
--RThere is one exposed function called makeYoungTableau :
--R   [1] (List(Integer),List(Integer)) -> Matrix(Integer)
--R             from SymmetricGroupCombinatoricFunctions
--R
--RExamples of makeYoungTableau from SymmetricGroupCombinatoricFunctions
--R
--E 1720

--S 1721 of 3320
)d op makingStats?
--R 
--R
--RThere is one unexposed function called makingStats? :
--R   [1]  -> Boolean from TabulatedComputationPackage(D2,D3)
--R             if D2 has SETCAT and D3 has SETCAT
--R
--RExamples of makingStats? from TabulatedComputationPackage
--R
--E 1721

--S 1722 of 3320
)d op mantissa
--R 
--R
--RThere are 2 exposed functions called mantissa :
--R   [1] D -> Integer from D if D has FPS
--R   [2] MachineFloat -> Integer from MachineFloat
--R
--RExamples of mantissa from FloatingPointSystem
--R
--R
--RExamples of mantissa from MachineFloat
--R
--E 1722

--S 1723 of 3320
)d op map
--R 
--R
--RThere are 86 exposed functions called map :
--R   [1] ((D2 -> D2),D) -> D from D
--R             if D has AMR(D2,D3) and D2 has RING and D3 has OAMON
--R   [2] (((D2,D2) -> D2),D,D,D2) -> D from D
--R             if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has 
--R            FLAGG(D2) and D4 has FLAGG(D2)
--R   [3] (((D2,D2) -> D2),D,D) -> D from D
--R             if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has 
--R            FLAGG(D2) and D4 has FLAGG(D2)
--R   [4] ((D2 -> D2),D) -> D from D
--R             if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has 
--R            FLAGG(D2) and D4 has FLAGG(D2)
--R   [5] ((D4 -> D5),OneDimensionalArray(D4)) -> OneDimensionalArray(D5)
--R             from OneDimensionalArrayFunctions2(D4,D5) if D4 has TYPE 
--R            and D5 has TYPE
--R   [6] ((D2 -> D2),ArrayStack(D2)) -> ArrayStack(D2) from ArrayStack(D2
--R            )
--R             if D2 has SETCAT
--R   [7] ((D6 -> D7),CartesianTensor(D4,D5,D6)) -> CartesianTensor(D4,D5,
--R            D7)
--R             from CartesianTensorFunctions2(D4,D5,D6,D7)
--R             if D4: INT and D5: NNI and D6 has COMRING and D7 has 
--R            COMRING
--R   [8] ((D4 -> D5),Complex(D4)) -> Complex(D5) from ComplexFunctions2(
--R            D4,D5)
--R             if D4 has COMRING and D5 has COMRING
--R   [9] ((D2 -> D2),Dequeue(D2)) -> Dequeue(D2) from Dequeue(D2) if D2
--R             has SETCAT
--R   [10] ((D5 -> D6),DirectProduct(D4,D5)) -> DirectProduct(D4,D6)
--R             from DirectProductFunctions2(D4,D5,D6)
--R             if D4: NNI and D5 has TYPE and D6 has TYPE
--R   [11] ((D4 -> D5),Equation(D4)) -> Equation(D5) from 
--R            EquationFunctions2(D4,D5)
--R             if D4 has TYPE and D5 has TYPE
--R   [12] ((D2 -> D2),Equation(D2)) -> Equation(D2) from Equation(D2) if 
--R            D2 has TYPE
--R   [13] ((D4 -> D1),Kernel(D4)) -> D1 from ExpressionSpaceFunctions2(D4
--R            ,D1)
--R             if D4 has ES and D1 has ES
--R   [14] ((D -> D),Kernel(D)) -> D from D if D has ES
--R   [15] ((D4 -> D5),Matrix(D4)) -> Matrix(D5)
--R             from ExpertSystemToolsPackage2(D4,D5) if D4 has RING and 
--R            D5 has RING
--R   [16] ((D4 -> D5),Expression(D4)) -> Expression(D5)
--R             from ExpressionFunctions2(D4,D5) if D4 has ORDSET and D5
--R             has ORDSET
--R   [17] ((D5 -> D6),D3) -> D1
--R             from FiniteAbelianMonoidRingFunctions2(D4,D5,D3,D6,D1)
--R             if D5 has RING and D6 has RING and D4 has OAMON and D1
--R             has FAMR(D6,D4) and D3 has FAMR(D5,D4)
--R   [18] ((D7 -> D11),FiniteDivisor(D7,D8,D9,D10)) -> FiniteDivisor(D11,
--R            D1,D2,D3)
--R             from FiniteDivisorFunctions2(D7,D8,D9,D10,D11,D1,D2,D3)
--R             if D7 has FIELD and D8 has UPOLYC(D7) and D9 has UPOLYC(
--R            FRAC(D8)) and D10 has FFCAT(D7,D8,D9) and D11 has FIELD and
--R            D1 has UPOLYC(D11) and D2 has UPOLYC(FRAC(D1)) and D3 has 
--R            FFCAT(D11,D1,D2)
--R   [19] ((D2 -> D2),D) -> D from D if D has FEVALAB(D2) and D2 has 
--R            SETCAT
--R   [20] ((D5 -> D8),D4) -> D2
--R             from FunctionFieldCategoryFunctions2(D5,D6,D7,D4,D8,D9,D1,
--R            D2)
--R             if D5 has UFD and D8 has UFD and D6 has UPOLYC(D5) and D7
--R             has UPOLYC(FRAC(D6)) and D9 has UPOLYC(D8) and D2 has 
--R            FFCAT(D8,D9,D1) and D4 has FFCAT(D5,D6,D7) and D1 has 
--R            UPOLYC(FRAC(D9))
--R   [21] ((D4 -> D5),D3) -> D1 from FiniteLinearAggregateFunctions2(D4,
--R            D3,D5,D1)
--R             if D4 has TYPE and D5 has TYPE and D1 has FLAGG(D5) and D3
--R             has FLAGG(D4)
--R   [22] ((D2 -> D2),D) -> D from D
--R             if D has FMCAT(D2,D3) and D2 has RING and D3 has SETCAT
--R         
--R   [23] ((D4 -> D5),Factored(D4)) -> Factored(D5) from 
--R            FactoredFunctions2(D4,D5)
--R             if D4 has INTDOM and D5 has INTDOM
--R   [24] ((D4 -> D5),Fraction(D4)) -> Fraction(D5) from 
--R            FractionFunctions2(D4,D5)
--R             if D4 has INTDOM and D5 has INTDOM
--R   [25] ((D7 -> D11),FractionalIdeal(D7,D8,D9,D10)) -> FractionalIdeal(
--R            D11,D1,D2,D3)
--R             from FractionalIdealFunctions2(D7,D8,D9,D10,D11,D1,D2,D3)
--R             if D7 has EUCDOM and D8 has QFCAT(D7) and D9 has UPOLYC(D8
--R            ) and D10 has Join(FramedAlgebra(D8,D9),RetractableTo(D8)) 
--R            and D11 has EUCDOM and D1 has QFCAT(D11) and D2 has UPOLYC(
--R            D1) and D3 has Join(FramedAlgebra(D1,D2),RetractableTo(D1))
--R            
--R   [26] ((D4 -> D5),D3) -> D1
--R             from FramedNonAssociativeAlgebraFunctions2(D3,D4,D1,D5)
--R             if D4 has COMRING and D5 has COMRING and D1 has FRNAALG(D5
--R            ) and D3 has FRNAALG(D4)
--R   [27] ((D2 -> D2),Factored(D2)) -> Factored(D2) from Factored(D2) if 
--R            D2 has INTDOM
--R   [28] ((D4 -> D5),D3) -> D1 from FunctionSpaceFunctions2(D4,D3,D5,D1)
--R             if D4 has Join(Ring,OrderedSet) and D5 has Join(Ring,
--R            OrderedSet) and D1 has FS(D5) and D3 has FS(D4)
--R   [29] ((D4 -> D5),D3) -> D1 from FiniteSetAggregateFunctions2(D4,D3,
--R            D5,D1)
--R             if D4 has SETCAT and D5 has SETCAT and D1 has FSAGG(D5) 
--R            and D3 has FSAGG(D4)
--R   [30] ((D2 -> D2),Heap(D2)) -> Heap(D2) from Heap(D2) if D2 has 
--R            ORDSET
--R   [31] ((D2 -> D2),D) -> D from D if D has HOAGG(D2) and D2 has TYPE
--R         
--R   [32] ((D2 -> D2),D) -> D from D
--R             if D has IDPC(D2,D3) and D2 has SETCAT and D3 has ORDSET
--R         
--R   [33] ((D4 -> D5),IntegrationResult(D4)) -> IntegrationResult(D5)
--R             from IntegrationResultFunctions2(D4,D5) if D4 has FIELD 
--R            and D5 has FIELD
--R   [34] ((D4 -> D5),Union(Record(ratpart: D4,coeff: D4),"failed")) -> 
--R            Union(Record(ratpart: D5,coeff: D5),"failed")
--R             from IntegrationResultFunctions2(D4,D5) if D4 has FIELD 
--R            and D5 has FIELD
--R   [35] ((D4 -> D1),Union(D4,"failed")) -> Union(D1,"failed")
--R             from IntegrationResultFunctions2(D4,D1) if D4 has FIELD 
--R            and D1 has FIELD
--R   [36] ((D4 -> D5),Union(Record(mainpart: D4,limitedlogs: List(Record(
--R            coeff: D4,logand: D4))),"failed")) -> Union(Record(mainpart: D5,
--R            limitedlogs: List(Record(coeff: D5,logand: D5))),"failed")
--R             from IntegrationResultFunctions2(D4,D5) if D4 has FIELD 
--R            and D5 has FIELD
--R   [37] ((D4 -> D5),InfiniteTuple(D4)) -> InfiniteTuple(D5)
--R             from InfiniteTupleFunctions2(D4,D5) if D4 has TYPE and D5
--R             has TYPE
--R   [38] (((D5,D6) -> D7),InfiniteTuple(D5),InfiniteTuple(D6)) -> 
--R            InfiniteTuple(D7)
--R             from InfiniteTupleFunctions3(D5,D6,D7)
--R             if D5 has TYPE and D6 has TYPE and D7 has TYPE
--R   [39] (((D5,D6) -> D7),Stream(D5),InfiniteTuple(D6)) -> Stream(D7)
--R             from InfiniteTupleFunctions3(D5,D6,D7)
--R             if D5 has TYPE and D6 has TYPE and D7 has TYPE
--R   [40] (((D5,D6) -> D7),InfiniteTuple(D5),Stream(D6)) -> Stream(D7)
--R             from InfiniteTupleFunctions3(D5,D6,D7)
--R             if D5 has TYPE and D6 has TYPE and D7 has TYPE
--R   [41] ((D2 -> D2),InfiniteTuple(D2)) -> InfiniteTuple(D2)
--R             from InfiniteTuple(D2) if D2 has TYPE
--R   [42] ((D4 -> D5),List(D4)) -> List(D5) from ListFunctions2(D4,D5)
--R             if D4 has TYPE and D5 has TYPE
--R   [43] (((D5,D6) -> D7),List(D5),List(D6)) -> List(D7)
--R             from ListFunctions3(D5,D6,D7)
--R             if D5 has TYPE and D6 has TYPE and D7 has TYPE
--R   [44] (((D2,D2) -> D2),D,D) -> D from D if D has LNAGG(D2) and D2
--R             has TYPE
--R   [45] ((D5 -> D8),D4) -> D2
--R             from MatrixCategoryFunctions2(D5,D6,D7,D4,D8,D9,D1,D2)
--R             if D5 has RING and D8 has RING and D6 has FLAGG(D5) and D7
--R             has FLAGG(D5) and D2 has MATCAT(D8,D9,D1) and D4 has 
--R            MATCAT(D5,D6,D7) and D9 has FLAGG(D8) and D1 has FLAGG(D8)
--R            
--R   [46] ((D5 -> Union(D8,"failed")),D4) -> Union(D2,"failed")
--R             from MatrixCategoryFunctions2(D5,D6,D7,D4,D8,D9,D1,D2)
--R             if D5 has RING and D8 has RING and D6 has FLAGG(D5) and D7
--R             has FLAGG(D5) and D2 has MATCAT(D8,D9,D1) and D4 has 
--R            MATCAT(D5,D6,D7) and D9 has FLAGG(D8) and D1 has FLAGG(D8)
--R            
--R   [47] ((D7 -> D8),D3) -> D1 from MPolyCatFunctions2(D4,D5,D6,D7,D8,D3
--R            ,D1)
--R             if D7 has RING and D8 has RING and D4 has ORDSET and D5
--R             has OAMONS and D1 has POLYCAT(D8,D6,D4) and D6 has OAMONS 
--R            and D3 has POLYCAT(D7,D5,D4)
--R   [48] ((D4 -> D5),MonoidRing(D4,D6)) -> MonoidRing(D5,D6)
--R             from MonoidRingFunctions2(D4,D5,D6)
--R             if D4 has RING and D5 has RING and D6 has MONOID
--R   [49] ((D4 -> D5),D3) -> D1 from OctonionCategoryFunctions2(D3,D4,D1,
--R            D5)
--R             if D4 has COMRING and D5 has COMRING and D1 has OC(D5) and
--R            D3 has OC(D4)
--R   [50] ((D4 -> D5),OnePointCompletion(D4)) -> OnePointCompletion(D5)
--R             from OnePointCompletionFunctions2(D4,D5)
--R             if D4 has SETCAT and D5 has SETCAT
--R   [51] ((D4 -> D5),OnePointCompletion(D4),OnePointCompletion(D5)) -> 
--R            OnePointCompletion(D5)
--R             from OnePointCompletionFunctions2(D4,D5)
--R             if D4 has SETCAT and D5 has SETCAT
--R   [52] ((D4 -> D5),OrderedCompletion(D4)) -> OrderedCompletion(D5)
--R             from OrderedCompletionFunctions2(D4,D5)
--R             if D4 has SETCAT and D5 has SETCAT
--R   [53] ((D4 -> D5),OrderedCompletion(D4),OrderedCompletion(D5),
--R            OrderedCompletion(D5)) -> OrderedCompletion(D5)
--R             from OrderedCompletionFunctions2(D4,D5)
--R             if D4 has SETCAT and D5 has SETCAT
--R   [54] ((D4 -> D5),ParametricPlaneCurve(D4)) -> ParametricPlaneCurve(
--R            D5)
--R             from ParametricPlaneCurveFunctions2(D4,D5)
--R             if D4 has TYPE and D5 has TYPE
--R   [55] ((D4 -> D5),ParametricSpaceCurve(D4)) -> ParametricSpaceCurve(
--R            D5)
--R             from ParametricSpaceCurveFunctions2(D4,D5)
--R             if D4 has TYPE and D5 has TYPE
--R   [56] ((D4 -> D5),ParametricSurface(D4)) -> ParametricSurface(D5)
--R             from ParametricSurfaceFunctions2(D4,D5) if D4 has TYPE and
--R            D5 has TYPE
--R   [57] ((D5 -> D6),PatternMatchResult(D4,D5)) -> PatternMatchResult(D4
--R            ,D6)
--R             from PatternMatchResultFunctions2(D4,D5,D6)
--R             if D4 has SETCAT and D5 has SETCAT and D6 has SETCAT
--R   [58] ((D4 -> D5),Pattern(D4)) -> Pattern(D5) from PatternFunctions2(
--R            D4,D5)
--R             if D4 has SETCAT and D5 has SETCAT
--R   [59] ((D4 -> D5),Polynomial(D4)) -> Polynomial(D5)
--R             from PolynomialFunctions2(D4,D5) if D4 has RING and D5
--R             has RING
--R   [60] ((D4 -> D5),PrimitiveArray(D4)) -> PrimitiveArray(D5)
--R             from PrimitiveArrayFunctions2(D4,D5) if D4 has TYPE and D5
--R             has TYPE
--R   [61] ((D4 -> D5),Point(D4)) -> Point(D5) from PointFunctions2(D4,D5)
--R             if D4 has RING and D5 has RING
--R   [62] ((D4 -> D5),D3) -> D1 from QuotientFieldCategoryFunctions2(D4,
--R            D5,D3,D1)
--R             if D4 has INTDOM and D5 has INTDOM and D1 has QFCAT(D5) 
--R            and D3 has QFCAT(D4)
--R   [63] ((D4 -> D5),D3) -> D1 from QuaternionCategoryFunctions2(D3,D4,
--R            D1,D5)
--R             if D4 has COMRING and D5 has COMRING and D1 has QUATCAT(D5
--R            ) and D3 has QUATCAT(D4)
--R   [64] ((D2 -> D2),Queue(D2)) -> Queue(D2) from Queue(D2) if D2 has 
--R            SETCAT
--R   [65] (((D4,D4) -> D4),D,D) -> D from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R   [66] ((D4 -> D4),D) -> D from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R   [67] ((D9 -> D1),D6) -> D4
--R             from RectangularMatrixCategoryFunctions2(D7,D8,D9,D10,D11,
--R            D6,D1,D2,D3,D4)
--R             if D9 has RING and D1 has RING and D7: NNI and D8: NNI and
--R            D10 has DIRPCAT(D8,D9) and D11 has DIRPCAT(D7,D9) and D4
--R             has RMATCAT(D7,D8,D1,D2,D3) and D6 has RMATCAT(D7,D8,D9,
--R            D10,D11) and D2 has DIRPCAT(D8,D1) and D3 has DIRPCAT(D7,D1
--R            )
--R   [68] ((D4 -> D5),Segment(D4)) -> Segment(D5) from SegmentFunctions2(
--R            D4,D5)
--R             if D4 has TYPE and D5 has TYPE
--R   [69] ((D4 -> D5),Segment(D4)) -> List(D5) from SegmentFunctions2(D4,
--R            D5)
--R             if D4 has ORDRING and D4 has TYPE and D5 has TYPE
--R   [70] ((D4 -> D5),SegmentBinding(D4)) -> SegmentBinding(D5)
--R             from SegmentBindingFunctions2(D4,D5) if D4 has TYPE and D5
--R             has TYPE
--R   [71] ((D3 -> D3),D) -> D1 from D
--R             if D has SEGXCAT(D3,D1) and D3 has ORDRING and D1 has 
--R            STAGG(D3)
--R   [72] ((D2 -> D2),Stack(D2)) -> Stack(D2) from Stack(D2) if D2 has 
--R            SETCAT
--R   [73] ((D4 -> D5),Stream(D4)) -> Stream(D5) from StreamFunctions2(D4,
--R            D5)
--R             if D4 has TYPE and D5 has TYPE
--R   [74] (((D5,D6) -> D7),Stream(D5),Stream(D6)) -> Stream(D7)
--R             from StreamFunctions3(D5,D6,D7)
--R             if D5 has TYPE and D6 has TYPE and D7 has TYPE
--R   [75] ((D4 -> D5),SparseUnivariatePolynomial(D4)) -> 
--R            SparseUnivariatePolynomial(D5)
--R             from SparseUnivariatePolynomialFunctions2(D4,D5)
--R             if D4 has RING and D5 has RING
--R   [76] (((D3,D3) -> D3),D,D) -> D from D
--R             if D has TBAGG(D2,D3) and D2 has SETCAT and D3 has SETCAT
--R            
--R   [77] ((D5 -> D6),UnivariateLaurentSeries(D5,D7,D9)) -> 
--R            UnivariateLaurentSeries(D6,D8,D1)
--R             from UnivariateLaurentSeriesFunctions2(D5,D6,D7,D8,D9,D1)
--R             if D5 has RING and D6 has RING and D7: SYMBOL and D9: D5 
--R            and D1: D6 and D8: SYMBOL
--R   [78] ((D4 -> D5),UniversalSegment(D4)) -> UniversalSegment(D5)
--R             from UniversalSegmentFunctions2(D4,D5) if D4 has TYPE and 
--R            D5 has TYPE
--R   [79] ((D4 -> D5),UniversalSegment(D4)) -> Stream(D5)
--R             from UniversalSegmentFunctions2(D4,D5)
--R             if D4 has ORDRING and D4 has TYPE and D5 has TYPE
--R   [80] ((D5 -> D7),UnivariatePolynomial(D4,D5)) -> 
--R            UnivariatePolynomial(D6,D7)
--R             from UnivariatePolynomialFunctions2(D4,D5,D6,D7)
--R             if D4: SYMBOL and D5 has RING and D7 has RING and D6: 
--R            SYMBOL
--R   [81] ((D4 -> D5),D3) -> D1
--R             from UnivariatePolynomialCategoryFunctions2(D4,D3,D5,D1)
--R             if D4 has RING and D5 has RING and D1 has UPOLYC(D5) and 
--R            D3 has UPOLYC(D4)
--R   [82] ((D5 -> D6),UnivariatePuiseuxSeries(D5,D7,D9)) -> 
--R            UnivariatePuiseuxSeries(D6,D8,D1)
--R             from UnivariatePuiseuxSeriesFunctions2(D5,D6,D7,D8,D9,D1)
--R             if D5 has RING and D6 has RING and D7: SYMBOL and D9: D5 
--R            and D1: D6 and D8: SYMBOL
--R   [83] ((D4 -> D5),D3) -> D1 from UnivariateTaylorSeriesFunctions2(D4,
--R            D5,D3,D1)
--R             if D4 has RING and D5 has RING and D1 has UTSCAT(D5) and 
--R            D3 has UTSCAT(D4)
--R   [84] ((D4 -> D5),Vector(D4)) -> Vector(D5) from VectorFunctions2(D4,
--R            D5)
--R             if D4 has TYPE and D5 has TYPE
--R   [85] ((D4 -> Union(D5,"failed")),Vector(D4)) -> Union(Vector(D5),
--R            "failed")
--R             from VectorFunctions2(D4,D5) if D4 has TYPE and D5 has 
--R            TYPE
--R   [86] ((D3 -> D3),D) -> D from D
--R             if D has XFALG(D2,D3) and D2 has ORDSET and D3 has RING
--R         
--R
--RThere are 10 unexposed functions called map :
--R   [1] ((D2 -> D2),AntiSymm(D2,D3)) -> AntiSymm(D2,D3) from AntiSymm(D2
--R            ,D3)
--R             if D2 has RING and D3: LIST(SYMBOL)
--R   [2] ((Expression(D2) -> Expression(D2)),DeRhamComplex(D2,D3)) -> 
--R            DeRhamComplex(D2,D3)
--R             from DeRhamComplex(D2,D3)
--R             if D2 has Join(Ring,OrderedSet) and D3: LIST(SYMBOL)
--R   [3] ((D5 -> D1),String,Kernel(D5)) -> D1
--R             from ExpressionSpaceFunctions1(D5,D1) if D5 has ES and D1
--R             has TYPE
--R   [4] ((D4 -> D6),D3) -> D1 from MultipleMap(D4,D5,D3,D6,D7,D1)
--R             if D4 has INTDOM and D6 has INTDOM and D5 has UPOLYC(D4) 
--R            and D1 has UPOLYC(FRAC(D7)) and D3 has UPOLYC(FRAC(D5)) and
--R            D7 has UPOLYC(D6)
--R   [5] ((D4 -> D5),D3) -> D1 from MPolyCatFunctions3(D4,D5,D6,D7,D8,D3,
--R            D1)
--R             if D4 has ORDSET and D5 has ORDSET and D6 has OAMONS and 
--R            D8 has RING and D1 has POLYCAT(D8,D7,D5) and D7 has OAMONS 
--R            and D3 has POLYCAT(D8,D6,D4)
--R   [6] ((D2 -> D2),MonoidRing(D2,D3)) -> MonoidRing(D2,D3)
--R             from MonoidRing(D2,D3) if D2 has RING and D3 has MONOID
--R         
--R   [7] ((D4 -> D5),NewSparseUnivariatePolynomial(D4)) -> 
--R            NewSparseUnivariatePolynomial(D5)
--R             from NewSparseUnivariatePolynomialFunctions2(D4,D5)
--R             if D4 has RING and D5 has RING
--R   [8] ((D7 -> D2),(D8 -> D2),D5) -> D2
--R             from PolynomialCategoryLifting(D6,D7,D8,D5,D2)
--R             if D7 has ORDSET and D8 has RING and D6 has OAMONS and D2
--R             has SetCategorywith
--R               ?+? : (%,%) -> %
--R               ?*? : (%,%) -> %
--R               D : (%,NonNegativeInteger) -> %and D5 has POLYCAT(D8
--R            ,D6,D7)
--R   [9] ((Polynomial(D3) -> D1),D1) -> D1 from PushVariables(D3,D4,D5,D1
--R            )
--R             if D3 has RING and D1 has POLYCAT(POLY(D3),D4,D5) and D4
--R             has OAMONS and D5 has OrderedSetwith
--R               convert : % -> Symbol
--R               variable : Symbol -> Union(%,"failed")
--R   [10] ((D2 -> D2),XPolynomialRing(D2,D3)) -> XPolynomialRing(D2,D3)
--R             from XPolynomialRing(D2,D3) if D2 has RING and D3 has 
--R            ORDMON
--R
--RExamples of map from AbelianMonoidRing
--R
--R
--RExamples of map from AntiSymm
--R
--R
--RExamples of map from TwoDimensionalArrayCategory
--R
--Radder(a:Integer,b:Integer):Integer == a+b 
--Rarr1 : ARRAY2 INT := new(5,4,10) 
--Rarr2 : ARRAY2 INT := new(3,3,10) 
--Rmap(adder,arr1,arr2,17)
--R
--Radder(a:Integer,b:Integer):Integer == a+b 
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rmap(adder,arr,arr)
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rmap(-,arr) 
--Rmap((x +-> x + x),arr)
--R
--R
--RExamples of map from OneDimensionalArrayFunctions2
--R
--RT1:=OneDimensionalArrayFunctions2(Integer,Integer) 
--Rmap(x+->x+2,[i for i in 1..10])$T1
--R
--R
--RExamples of map from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rmap(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map from CartesianTensorFunctions2
--R
--R
--RExamples of map from ComplexFunctions2
--R
--R
--RExamples of map from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rmap(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map from DeRhamComplex
--R
--Rder := DeRhamComplex(Integer,[x,y,z]) 
--Rf:BOP:=operator('f) 
--Rg:BOP:=operator('g) 
--Rh:BOP:=operator('h) 
--Rsigma:der:=f(x,y,z)*dx + g(x,y,z)*dy + h(x,y,z)*dz 
--RR := Expression(Integer) 
--RT(x:R):R == x^2 
--Rmap(T,sigma)
--R
--R
--RExamples of map from DirectProductFunctions2
--R
--R
--RExamples of map from EquationFunctions2
--R
--R
--RExamples of map from Equation
--R
--R
--RExamples of map from ExpressionSpaceFunctions1
--R
--R
--RExamples of map from ExpressionSpaceFunctions2
--R
--R
--RExamples of map from ExpressionSpace
--R
--R
--RExamples of map from ExpertSystemToolsPackage2
--R
--R
--RExamples of map from ExpressionFunctions2
--R
--R
--RExamples of map from FiniteAbelianMonoidRingFunctions2
--R
--R
--RExamples of map from FiniteDivisorFunctions2
--R
--R
--RExamples of map from FullyEvalableOver
--R
--R
--RExamples of map from FunctionFieldCategoryFunctions2
--R
--R
--RExamples of map from FiniteLinearAggregateFunctions2
--R
--R
--RExamples of map from FreeModuleCat
--R
--R
--RExamples of map from FactoredFunctions2
--R
--R
--RExamples of map from FractionFunctions2
--R
--R
--RExamples of map from FractionalIdealFunctions2
--R
--R
--RExamples of map from FramedNonAssociativeAlgebraFunctions2
--R
--R
--RExamples of map from Factored
--R
--Rm(a:Factored Polynomial Integer):Factored Polynomial Integer == a^2 
--Rf:=x*y^3-3*x^2*y^2+3*x^3*y-x^4 
--Rmap(m,f) 
--Rg:=makeFR(z,factorList f) 
--Rmap(m,g)
--R
--R
--RExamples of map from FunctionSpaceFunctions2
--R
--R
--RExamples of map from FiniteSetAggregateFunctions2
--R
--R
--RExamples of map from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rmap(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map from HomogeneousAggregate
--R
--R
--RExamples of map from IndexedDirectProductCategory
--R
--R
--RExamples of map from IntegrationResultFunctions2
--R
--R
--RExamples of map from InfiniteTupleFunctions2
--R
--R
--RExamples of map from InfiniteTupleFunctions3
--R
--R
--RExamples of map from InfiniteTuple
--R
--R
--RExamples of map from ListFunctions2
--R
--R
--RExamples of map from ListFunctions3
--R
--R
--RExamples of map from LinearAggregate
--R
--R
--RExamples of map from MatrixCategoryFunctions2
--R
--R
--RExamples of map from MultipleMap
--R
--R
--RExamples of map from MPolyCatFunctions2
--R
--R
--RExamples of map from MPolyCatFunctions3
--R
--R
--RExamples of map from MonoidRingFunctions2
--R
--R
--RExamples of map from MonoidRing
--R
--R
--RExamples of map from NewSparseUnivariatePolynomialFunctions2
--R
--R
--RExamples of map from OctonionCategoryFunctions2
--R
--R
--RExamples of map from OnePointCompletionFunctions2
--R
--R
--RExamples of map from OrderedCompletionFunctions2
--R
--R
--RExamples of map from ParametricPlaneCurveFunctions2
--R
--R
--RExamples of map from ParametricSpaceCurveFunctions2
--R
--R
--RExamples of map from ParametricSurfaceFunctions2
--R
--R
--RExamples of map from PatternMatchResultFunctions2
--R
--R
--RExamples of map from PatternFunctions2
--R
--R
--RExamples of map from PolynomialFunctions2
--R
--R
--RExamples of map from PolynomialCategoryLifting
--R
--R
--RExamples of map from PrimitiveArrayFunctions2
--R
--RT1:=PrimitiveArrayFunctions2(Integer,Integer) 
--Rmap(x+->x+2,[i for i in 1..10])$T1
--R
--R
--RExamples of map from PointFunctions2
--R
--R
--RExamples of map from PushVariables
--R
--R
--RExamples of map from QuotientFieldCategoryFunctions2
--R
--R
--RExamples of map from QuaternionCategoryFunctions2
--R
--Rf(a:FRAC(INT)):COMPLEX(FRAC(INT)) == a::COMPLEX(FRAC(INT)) 
--Rq:=quatern(2/11,-8,3/4,1) 
--Rmap(f,q)
--R
--R
--RExamples of map from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rmap(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map from RectangularMatrixCategory
--R
--R
--RExamples of map from RectangularMatrixCategoryFunctions2
--R
--R
--RExamples of map from SegmentFunctions2
--R
--R
--RExamples of map from SegmentBindingFunctions2
--R
--R
--RExamples of map from SegmentExpansionCategory
--R
--R
--RExamples of map from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rmap(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map from StreamFunctions2
--R
--Rm:=[i for i in 1..] 
--Rf(i:PositiveInteger):PositiveInteger==i**2 
--Rmap(f,m)
--R
--R
--RExamples of map from StreamFunctions3
--R
--Rm:=[i for i in 1..]::Stream(Integer) 
--Rn:=[i for i in 1..]::Stream(Integer) 
--Rf(i:Integer,j:Integer):Integer == i+j 
--Rmap(f,m,n)
--R
--R
--RExamples of map from SparseUnivariatePolynomialFunctions2
--R
--R
--RExamples of map from TableAggregate
--R
--R
--RExamples of map from UnivariateLaurentSeriesFunctions2
--R
--R
--RExamples of map from UniversalSegmentFunctions2
--R
--R
--RExamples of map from UnivariatePolynomialFunctions2
--R
--R
--RExamples of map from UnivariatePolynomialCategoryFunctions2
--R
--R
--RExamples of map from UnivariatePuiseuxSeriesFunctions2
--R
--R
--RExamples of map from UnivariateTaylorSeriesFunctions2
--R
--R
--RExamples of map from VectorFunctions2
--R
--R
--RExamples of map from XFreeAlgebra
--R
--R
--RExamples of map from XPolynomialRing
--R
--E 1723

--S 1724 of 3320
)d op map!
--R 
--R
--RThere are 7 exposed functions called map! :
--R   [1] ((D2 -> D2),D) -> D from D
--R             if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has 
--R            FLAGG(D2) and D4 has FLAGG(D2)
--R   [2] ((D2 -> D2),ArrayStack(D2)) -> ArrayStack(D2) from ArrayStack(D2
--R            )
--R             if $ has shallowlyMutable and D2 has SETCAT
--R   [3] ((D2 -> D2),Dequeue(D2)) -> Dequeue(D2) from Dequeue(D2)
--R             if $ has shallowlyMutable and D2 has SETCAT
--R   [4] ((D2 -> D2),Heap(D2)) -> Heap(D2) from Heap(D2)
--R             if $ has shallowlyMutable and D2 has ORDSET
--R   [5] ((D2 -> D2),D) -> D from D
--R             if D has shallowlyMutable and D has HOAGG(D2) and D2 has 
--R            TYPE
--R   [6] ((D2 -> D2),Queue(D2)) -> Queue(D2) from Queue(D2)
--R             if $ has shallowlyMutable and D2 has SETCAT
--R   [7] ((D2 -> D2),Stack(D2)) -> Stack(D2) from Stack(D2)
--R             if $ has shallowlyMutable and D2 has SETCAT
--R
--RExamples of map! from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rmap!(-,arr)
--R
--R
--RExamples of map! from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rmap!(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rmap!(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map! from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rmap!(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map! from HomogeneousAggregate
--R
--R
--RExamples of map! from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rmap!(x+->x+10,a) 
--Ra
--R
--R
--RExamples of map! from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rmap!(x+->x+10,a) 
--Ra
--R
--E 1724

--S 1725 of 3320
)d op mapBivariate
--R 
--R
--RThere is one unexposed function called mapBivariate :
--R   [1] ((D4 -> D6),D3) -> SparseUnivariatePolynomial(
--R            SparseUnivariatePolynomial(D6))
--R             from IntegralBasisPolynomialTools(D4,D5,D3,D6)
--R             if D4 has RING and D6 has RING and D5 has UPOLYC(D4) and 
--R            D3 has UPOLYC(D5)
--R
--RExamples of mapBivariate from IntegralBasisPolynomialTools
--R
--E 1725

--S 1726 of 3320
)d op mapCoef
--R 
--R
--RThere is one exposed function called mapCoef :
--R   [1] ((D3 -> D3),D) -> D from D
--R             if D has FAMONC(D2,D3) and D2 has SETCAT and D3 has CABMON
--R            
--R
--RExamples of mapCoef from FreeAbelianMonoidCategory
--R
--E 1726

--S 1727 of 3320
)d op mapdiv
--R 
--R
--RThere is one unexposed function called mapdiv :
--R   [1] (Stream(D2),Stream(D2)) -> Stream(D2)
--R             from StreamTaylorSeriesOperations(D2) if D2 has FIELD and 
--R            D2 has RING
--R
--RExamples of mapdiv from StreamTaylorSeriesOperations
--R
--E 1727

--S 1728 of 3320 done
)d op mapDown!
--R 
--R
--RThere are 2 exposed functions called mapDown! :
--R   [1] (BalancedBinaryTree(D1),D1,((D1,D1,D1) -> List(D1))) -> 
--R            BalancedBinaryTree(D1)
--R             from BalancedBinaryTree(D1) if D1 has SETCAT
--R   [2] (BalancedBinaryTree(D1),D1,((D1,D1) -> D1)) -> 
--R            BalancedBinaryTree(D1)
--R             from BalancedBinaryTree(D1) if D1 has SETCAT
--R
--RExamples of mapDown! from BalancedBinaryTree
--R
--RT1:=BalancedBinaryTree Integer 
--Rt2:=balancedBinaryTree(4, 0)$T1 
--Rsetleaves!(t2,[1,2,3,4]::List(Integer)) 
--Radder3(i:Integer,j:Integer,k:Integer):List Integer == [i+j,j+k] 
--RmapDown!(t2,4::INT,adder3) 
--Rt2
--R
--RT1:=BalancedBinaryTree Integer 
--Rt2:=balancedBinaryTree(4, 0)$T1 
--Rsetleaves!(t2,[1,2,3,4]::List(Integer)) 
--Radder(i:Integer,j:Integer):Integer == i+j 
--RmapDown!(t2,4::INT,adder) 
--Rt2
--R
--E 1728

--S 1729 of 3320
)d op mapExpon
--R 
--R
--RThere are 3 unexposed functions called mapExpon :
--R   [1] ((Integer -> Integer),FreeGroup(D2)) -> FreeGroup(D2) from 
--R            FreeGroup(D2)
--R             if D2 has SETCAT
--R   [2] ((NonNegativeInteger -> NonNegativeInteger),FreeMonoid(D2)) -> 
--R            FreeMonoid(D2)
--R             from FreeMonoid(D2) if D2 has SETCAT
--R   [3] ((D3 -> D3),ListMonoidOps(D2,D3,D4)) -> ListMonoidOps(D2,D3,D4)
--R             from ListMonoidOps(D2,D3,D4)
--R             if D3 has ABELMON and D4: D3 and D2 has SETCAT
--R
--RExamples of mapExpon from FreeGroup
--R
--R
--RExamples of mapExpon from FreeMonoid
--R
--R
--RExamples of mapExpon from ListMonoidOps
--R
--E 1729

--S 1730 of 3320
)d op mapExponents
--R 
--R
--RThere are 2 exposed functions called mapExponents :
--R   [1] ((D3 -> D3),D) -> D from D
--R             if D has FAMR(D2,D3) and D2 has RING and D3 has OAMON
--R   [2] ((D4 -> D4),D1) -> D1 from PackageForPoly(D3,D1,D4,D5)
--R             if D4 has DIRPCAT(D5,NNI) and D5: NNI and D3 has RING and 
--R            D1 has FAMR(D3,D4)
--R
--RExamples of mapExponents from FiniteAbelianMonoidRing
--R
--R
--RExamples of mapExponents from PackageForPoly
--R
--E 1730

--S 1731 of 3320
)d op mapGen
--R 
--R
--RThere is one exposed function called mapGen :
--R   [1] ((D2 -> D2),D) -> D from D
--R             if D has FAMONC(D2,D3) and D2 has SETCAT and D3 has CABMON
--R            
--R
--RThere are 3 unexposed functions called mapGen :
--R   [1] ((D2 -> D2),FreeGroup(D2)) -> FreeGroup(D2) from FreeGroup(D2)
--R             if D2 has SETCAT
--R   [2] ((D2 -> D2),FreeMonoid(D2)) -> FreeMonoid(D2) from FreeMonoid(D2
--R            )
--R             if D2 has SETCAT
--R   [3] ((D2 -> D2),ListMonoidOps(D2,D3,D4)) -> ListMonoidOps(D2,D3,D4)
--R             from ListMonoidOps(D2,D3,D4)
--R             if D2 has SETCAT and D3 has ABELMON and D4: D3
--R
--RExamples of mapGen from FreeAbelianMonoidCategory
--R
--R
--RExamples of mapGen from FreeGroup
--R
--R
--RExamples of mapGen from FreeMonoid
--R
--R
--RExamples of mapGen from ListMonoidOps
--R
--E 1731

--S 1732 of 3320
)d op mapMatrixIfCan
--R 
--R
--RThere is one unexposed function called mapMatrixIfCan :
--R   [1] ((D7 -> Union(D4,"failed")),Matrix(SparseUnivariatePolynomial(D7
--R            ))) -> Union(Matrix(D5),"failed")
--R             from IntegralBasisPolynomialTools(D4,D5,D6,D7)
--R             if D4 has RING and D7 has RING and D5 has UPOLYC(D4) and 
--R            D6 has UPOLYC(D5)
--R
--RExamples of mapMatrixIfCan from IntegralBasisPolynomialTools
--R
--E 1732

--S 1733 of 3320
)d op mapmult
--R 
--R
--RThere is one unexposed function called mapmult :
--R   [1] (Stream(D2),Stream(D2)) -> Stream(D2)
--R             from StreamTaylorSeriesOperations(D2) if D2 has RING
--R
--RExamples of mapmult from StreamTaylorSeriesOperations
--R
--E 1733

--S 1734 of 3320
)d op mapSolve
--R 
--R
--RThere is one unexposed function called mapSolve :
--R   [1] (D3,(D5 -> D5)) -> Record(solns: List(D5),maps: List(Record(arg
--R            : D5,res: D5)))
--R             from PolynomialSolveByFormulas(D3,D5)
--R             if D5 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D3 has UPOLYC(D5)
--R            
--R
--RExamples of mapSolve from PolynomialSolveByFormulas
--R
--E 1734

--S 1735 of 3320
)d op mapUnivariate
--R 
--R
--RThere are 2 unexposed functions called mapUnivariate :
--R   [1] ((D6 -> D4),SparseUnivariatePolynomial(D6)) -> D1
--R             from IntegralBasisPolynomialTools(D4,D1,D5,D6)
--R             if D4 has RING and D6 has RING and D1 has UPOLYC(D4) and 
--R            D5 has UPOLYC(D1)
--R   [2] ((D4 -> D6),D3) -> SparseUnivariatePolynomial(D6)
--R             from IntegralBasisPolynomialTools(D4,D3,D5,D6)
--R             if D4 has RING and D6 has RING and D3 has UPOLYC(D4) and 
--R            D5 has UPOLYC(D3)
--R
--RExamples of mapUnivariate from IntegralBasisPolynomialTools
--R
--E 1735

--S 1736 of 3320
)d op mapUnivariateIfCan
--R 
--R
--RThere is one unexposed function called mapUnivariateIfCan :
--R   [1] ((D6 -> Union(D4,"failed")),SparseUnivariatePolynomial(D6)) -> 
--R            Union(D1,"failed")
--R             from IntegralBasisPolynomialTools(D4,D1,D5,D6)
--R             if D4 has RING and D6 has RING and D1 has UPOLYC(D4) and 
--R            D5 has UPOLYC(D1)
--R
--RExamples of mapUnivariateIfCan from IntegralBasisPolynomialTools
--R
--E 1736

--S 1737 of 3320 done
)d op mapUp!
--R 
--R
--RThere are 2 exposed functions called mapUp! :
--R   [1] (BalancedBinaryTree(D2),BalancedBinaryTree(D2),((D2,D2,D2,D2)
--R             -> D2)) -> BalancedBinaryTree(D2)
--R             from BalancedBinaryTree(D2) if D2 has SETCAT
--R   [2] (BalancedBinaryTree(D1),((D1,D1) -> D1)) -> D1
--R             from BalancedBinaryTree(D1) if D1 has SETCAT
--R
--RExamples of mapUp! from BalancedBinaryTree
--R
--RT1:=BalancedBinaryTree Integer 
--Rt2:=balancedBinaryTree(4, 0)$T1 
--Rsetleaves!(t2,[1,2,3,4]::List(Integer)) 
--Radder4(i:INT,j:INT,k:INT,l:INT):INT == i+j+k+l 
--RmapUp!(t2,t2,adder4) 
--Rt2
--R
--RT1:=BalancedBinaryTree Integer 
--Rt2:=balancedBinaryTree(4, 0)$T1 
--Rsetleaves!(t2,[1,2,3,4]::List(Integer)) 
--Radder(a:Integer,b:Integer):Integer == a+b 
--RmapUp!(t2,adder) 
--Rt2
--R
--E 1737

--S 1738 of 3320
)d op mask
--R 
--R
--RThere is one exposed function called mask :
--R   [1] D -> D from D if D has INS
--R
--RExamples of mask from IntegerNumberSystem
--R
--E 1738

--S 1739 of 3320
)d op mat
--R 
--R
--RThere is one exposed function called mat :
--R   [1] (List(DoubleFloat),NonNegativeInteger) -> Matrix(DoubleFloat)
--R             from ExpertSystemToolsPackage
--R
--RExamples of mat from ExpertSystemToolsPackage
--R
--E 1739

--S 1740 of 3320
)d op match
--R 
--R
--RThere are 7 exposed functions called match :
--R   [1] (List(D4),List(D5)) -> (D4 -> D5) from ListToMap(D4,D5)
--R             if D4 has SETCAT and D5 has TYPE
--R   [2] (List(D4),List(D1),D4) -> D1 from ListToMap(D4,D1)
--R             if D4 has SETCAT and D1 has TYPE
--R   [3] (List(D5),List(D4),D4) -> (D5 -> D4) from ListToMap(D5,D4)
--R             if D5 has SETCAT and D4 has TYPE
--R   [4] (List(D4),List(D1),D4,D1) -> D1 from ListToMap(D4,D1)
--R             if D4 has SETCAT and D1 has TYPE
--R   [5] (List(D4),List(D5),(D4 -> D5)) -> (D4 -> D5) from ListToMap(D4,
--R            D5)
--R             if D4 has SETCAT and D5 has TYPE
--R   [6] (List(D4),List(D1),D4,(D4 -> D1)) -> D1 from ListToMap(D4,D1)
--R             if D4 has SETCAT and D1 has TYPE
--R   [7] (D,D,Character) -> NonNegativeInteger from D if D has SRAGG
--R
--RExamples of match from ListToMap
--R
--R
--RExamples of match from StringAggregate
--R
--E 1740

--S 1741 of 3320
)d op match?
--R 
--R
--RThere is one exposed function called match? :
--R   [1] (D,D,Character) -> Boolean from D if D has SRAGG
--R
--RExamples of match? from StringAggregate
--R
--E 1741

--S 1742 of 3320
)d op mathieu11
--R 
--R
--RThere are 2 exposed functions called mathieu11 :
--R   [1] List(Integer) -> PermutationGroup(Integer) from 
--R            PermutationGroupExamples
--R   [2]  -> PermutationGroup(Integer) from PermutationGroupExamples
--R
--RExamples of mathieu11 from PermutationGroupExamples
--R
--E 1742

--S 1743 of 3320
)d op mathieu12
--R 
--R
--RThere are 2 exposed functions called mathieu12 :
--R   [1] List(Integer) -> PermutationGroup(Integer) from 
--R            PermutationGroupExamples
--R   [2]  -> PermutationGroup(Integer) from PermutationGroupExamples
--R
--RExamples of mathieu12 from PermutationGroupExamples
--R
--E 1743

--S 1744 of 3320
)d op mathieu22
--R 
--R
--RThere are 2 exposed functions called mathieu22 :
--R   [1] List(Integer) -> PermutationGroup(Integer) from 
--R            PermutationGroupExamples
--R   [2]  -> PermutationGroup(Integer) from PermutationGroupExamples
--R
--RExamples of mathieu22 from PermutationGroupExamples
--R
--E 1744

--S 1745 of 3320
)d op mathieu23
--R 
--R
--RThere are 2 exposed functions called mathieu23 :
--R   [1] List(Integer) -> PermutationGroup(Integer) from 
--R            PermutationGroupExamples
--R   [2]  -> PermutationGroup(Integer) from PermutationGroupExamples
--R
--RExamples of mathieu23 from PermutationGroupExamples
--R
--E 1745

--S 1746 of 3320
)d op mathieu24
--R 
--R
--RThere are 2 exposed functions called mathieu24 :
--R   [1] List(Integer) -> PermutationGroup(Integer) from 
--R            PermutationGroupExamples
--R   [2]  -> PermutationGroup(Integer) from PermutationGroupExamples
--R
--RExamples of mathieu24 from PermutationGroupExamples
--R
--E 1746

--S 1747 of 3320
)d op matrix
--R 
--R
--RThere are 4 exposed functions called matrix :
--R   [1] (NonNegativeInteger,NonNegativeInteger,((Integer,Integer) -> D3)
--R            ) -> D
--R             from D
--R             if D3 has RING and D has MATCAT(D3,D4,D5) and D4 has FLAGG
--R            (D3) and D5 has FLAGG(D3)
--R   [2] List(List(D2)) -> D from D
--R             if D2 has RING and D has MATCAT(D2,D3,D4) and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [3] QuadraticForm(D2,D3) -> SquareMatrix(D2,D3) from QuadraticForm(
--R            D2,D3)
--R             if D2: PI and D3 has FIELD
--R   [4] List(List(D4)) -> D from D
--R             if D4 has RING and D has RMATCAT(D2,D3,D4,D5,D6) and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RThere is one unexposed function called matrix :
--R   [1] List(List(OutputForm)) -> OutputForm from OutputForm
--R
--RExamples of matrix from MatrixCategory
--R
--Rf(i:INT,j:INT):INT == i+j 
--Rmatrix(3,4,f)
--R
--Rmatrix [[1,2,3],[4,5,6],[7,8,9],[1,1,1]]
--R
--R
--RExamples of matrix from OutputForm
--R
--R
--RExamples of matrix from QuadraticForm
--R
--R
--RExamples of matrix from RectangularMatrixCategory
--R
--E 1747

--S 1748 of 3320
)d op matrixConcat3D
--R 
--R
--RThere is one exposed function called matrixConcat3D :
--R   [1] (Symbol,ThreeDimensionalMatrix(D2),ThreeDimensionalMatrix(D2))
--R             -> ThreeDimensionalMatrix(D2)
--R             from ThreeDimensionalMatrix(D2) if D2 has SETCAT
--R
--RExamples of matrixConcat3D from ThreeDimensionalMatrix
--R
--E 1748

--S 1749 of 3320
)d op matrixDimensions
--R 
--R
--RThere is one exposed function called matrixDimensions :
--R   [1] ThreeDimensionalMatrix(D2) -> Vector(NonNegativeInteger)
--R             from ThreeDimensionalMatrix(D2) if D2 has SETCAT
--R
--RExamples of matrixDimensions from ThreeDimensionalMatrix
--R
--E 1749

--S 1750 of 3320
)d op matrixGcd
--R 
--R
--RThere is one unexposed function called matrixGcd :
--R   [1] (Matrix(D1),D1,NonNegativeInteger) -> D1
--R             from IntegralBasisTools(D1,D4,D5)
--R             if D1 has EuclideanDomainwith
--R               squareFree : % -> Factored(%)and D4 has UPOLYC(D1) 
--R            and D5 has FRAMALG(D1,D4)
--R
--RExamples of matrixGcd from IntegralBasisTools
--R
--E 1750

--S 1751 of 3320
)d op max
--R 
--R
--RThere are 6 exposed functions called max :
--R   [1]  -> D from D
--R             if D has FPS and not(has(D,arbitraryPrecision)) and not(
--R            has(D,arbitraryExponent))
--R   [2] D -> D1 from D if D has FSAGG(D1) and D1 has SETCAT and D1 has 
--R            ORDSET
--R   [3] Heap(D1) -> D1 from Heap(D1) if D1 has ORDSET
--R   [4] (D,D) -> D from D if D has ORDSET
--R   [5] D -> D1 from D if D has PRQAGG(D1)
--R   [6]  -> SingleInteger from SingleInteger
--R
--RExamples of max from FloatingPointSystem
--R
--R
--RExamples of max from FiniteSetAggregate
--R
--R
--RExamples of max from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rmax a
--R
--R
--RExamples of max from OrderedSet
--R
--R
--RExamples of max from PriorityQueueAggregate
--R
--R
--RExamples of max from SingleInteger
--R
--E 1751

--S 1752 of 3320
)d op maxColIndex
--R 
--R
--RThere are 2 exposed functions called maxColIndex :
--R   [1] D -> Integer from D
--R             if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has 
--R            FLAGG(D2) and D4 has FLAGG(D2)
--R   [2] D -> Integer from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of maxColIndex from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--RmaxColIndex(arr)
--R
--R
--RExamples of maxColIndex from RectangularMatrixCategory
--R
--E 1752

--S 1753 of 3320
)d op maxdeg
--R 
--R
--RThere is one exposed function called maxdeg :
--R   [1] D -> OrderedFreeMonoid(D2) from D
--R             if D has XPOLYC(D2,D3) and D2 has ORDSET and D3 has RING
--R         
--R
--RThere is one unexposed function called maxdeg :
--R   [1] XPolynomialRing(D2,D1) -> D1 from XPolynomialRing(D2,D1)
--R             if D1 has ORDMON and D2 has RING
--R
--RExamples of maxdeg from XPolynomialsCat
--R
--R
--RExamples of maxdeg from XPolynomialRing
--R
--E 1753

--S 1754 of 3320
)d op maxDegree
--R 
--R
--RThere is one exposed function called maxDegree :
--R   [1] Union(NonNegativeInteger,arbitrary) -> GuessOption from 
--R            GuessOption
--R
--RThere is one unexposed function called maxDegree :
--R   [1] List(GuessOption) -> Union(NonNegativeInteger,arbitrary)
--R             from GuessOptionFunctions0
--R
--RExamples of maxDegree from GuessOptionFunctions0
--R
--R
--RExamples of maxDegree from GuessOption
--R
--E 1754

--S 1755 of 3320
)d op maxDerivative
--R 
--R
--RThere is one exposed function called maxDerivative :
--R   [1] Union(NonNegativeInteger,arbitrary) -> GuessOption from 
--R            GuessOption
--R
--RThere is one unexposed function called maxDerivative :
--R   [1] List(GuessOption) -> Union(NonNegativeInteger,arbitrary)
--R             from GuessOptionFunctions0
--R
--RExamples of maxDerivative from GuessOptionFunctions0
--R
--R
--RExamples of maxDerivative from GuessOption
--R
--E 1755

--S 1756 of 3320
)d op maximumExponent
--R 
--R
--RThere are 2 exposed functions called maximumExponent :
--R   [1]  -> Integer from MachineFloat
--R   [2] Integer -> Integer from MachineFloat
--R
--RExamples of maximumExponent from MachineFloat
--R
--E 1756

--S 1757 of 3320
)d op maxIndex
--R 
--R
--RThere is one exposed function called maxIndex :
--R   [1] D -> D1 from D
--R             if D has IXAGG(D1,D2) and D2 has TYPE and D1 has SETCAT 
--R            and D1 has ORDSET
--R
--RExamples of maxIndex from IndexedAggregate
--R
--E 1757

--S 1758 of 3320
)d op maxint
--R 
--R
--RThere are 2 exposed functions called maxint :
--R   [1]  -> PositiveInteger from MachineInteger
--R   [2] PositiveInteger -> PositiveInteger from MachineInteger
--R
--RExamples of maxint from MachineInteger
--R
--E 1758

--S 1759 of 3320
)d op maxLevel
--R 
--R
--RThere is one exposed function called maxLevel :
--R   [1] Union(NonNegativeInteger,arbitrary) -> GuessOption from 
--R            GuessOption
--R
--RThere is one unexposed function called maxLevel :
--R   [1] List(GuessOption) -> Union(NonNegativeInteger,arbitrary)
--R             from GuessOptionFunctions0
--R
--RExamples of maxLevel from GuessOptionFunctions0
--R
--R
--RExamples of maxLevel from GuessOption
--R
--E 1759

--S 1760 of 3320
)d op maxMixedDegree
--R 
--R
--RThere is one exposed function called maxMixedDegree :
--R   [1] NonNegativeInteger -> GuessOption from GuessOption
--R
--RThere is one unexposed function called maxMixedDegree :
--R   [1] List(GuessOption) -> NonNegativeInteger from 
--R            GuessOptionFunctions0
--R
--RExamples of maxMixedDegree from GuessOptionFunctions0
--R
--R
--RExamples of maxMixedDegree from GuessOption
--R
--E 1760

--S 1761 of 3320
)d op maxPoints
--R 
--R
--RThere are 2 exposed functions called maxPoints :
--R   [1]  -> Integer from GraphicsDefaults
--R   [2] Integer -> Integer from GraphicsDefaults
--R
--RThere is one unexposed function called maxPoints :
--R   [1]  -> Integer from Plot
--R
--RExamples of maxPoints from GraphicsDefaults
--R
--R
--RExamples of maxPoints from Plot
--R
--E 1761

--S 1762 of 3320
)d op maxPoints3D
--R 
--R
--RThere is one unexposed function called maxPoints3D :
--R   [1]  -> Integer from Plot3D
--R
--RExamples of maxPoints3D from Plot3D
--R
--E 1762

--S 1763 of 3320
)d op maxPower
--R 
--R
--RThere is one exposed function called maxPower :
--R   [1] Union(PositiveInteger,arbitrary) -> GuessOption from GuessOption
--R            
--R
--RThere is one unexposed function called maxPower :
--R   [1] List(GuessOption) -> Union(PositiveInteger,arbitrary)
--R             from GuessOptionFunctions0
--R
--RExamples of maxPower from GuessOptionFunctions0
--R
--R
--RExamples of maxPower from GuessOption
--R
--E 1763

--S 1764 of 3320
)d op maxrank
--R 
--R
--RThere is one unexposed function called maxrank :
--R   [1] List(Record(rank: NonNegativeInteger,eqns: List(Record(det: D6,
--R            rows: List(Integer),cols: List(Integer))),fgb: List(D6))) -> 
--R            NonNegativeInteger
--R             from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D5,D4) and D3 has Join(
--R            EuclideanDomain,CharacteristicZero) and D4 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D5 has OAMONS
--R
--RExamples of maxrank from ParametricLinearEquations
--R
--E 1764

--S 1765 of 3320
)d op maxrow
--R 
--R
--RThere is one unexposed function called maxrow :
--R   [1] (List(D5),List(List(List(D5))),List(List(D5)),List(List(List(D5)
--R            )),List(List(List(D5))),List(List(List(D5)))) -> Record(f1: List(
--R            D5),f2: List(List(List(D5))),f3: List(List(D5)),f4: List(List(
--R            List(D5))))
--R             from TableauxBumpers(D5) if D5 has ORDSET
--R
--RExamples of maxrow from TableauxBumpers
--R
--E 1765

--S 1766 of 3320
)d op maxRowIndex
--R 
--R
--RThere are 2 exposed functions called maxRowIndex :
--R   [1] D -> Integer from D
--R             if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has 
--R            FLAGG(D2) and D4 has FLAGG(D2)
--R   [2] D -> Integer from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of maxRowIndex from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--RmaxRowIndex(arr)
--R
--R
--RExamples of maxRowIndex from RectangularMatrixCategory
--R
--E 1766

--S 1767 of 3320
)d op maxShift
--R 
--R
--RThere is one exposed function called maxShift :
--R   [1] Union(NonNegativeInteger,arbitrary) -> GuessOption from 
--R            GuessOption
--R
--RThere is one unexposed function called maxShift :
--R   [1] List(GuessOption) -> Union(NonNegativeInteger,arbitrary)
--R             from GuessOptionFunctions0
--R
--RExamples of maxShift from GuessOptionFunctions0
--R
--R
--RExamples of maxShift from GuessOption
--R
--E 1767

--S 1768 of 3320
)d op maxSubst
--R 
--R
--RThere is one exposed function called maxSubst :
--R   [1] Union(PositiveInteger,arbitrary) -> GuessOption from GuessOption
--R            
--R
--RThere is one unexposed function called maxSubst :
--R   [1] List(GuessOption) -> Union(PositiveInteger,arbitrary)
--R             from GuessOptionFunctions0
--R
--RExamples of maxSubst from GuessOptionFunctions0
--R
--R
--RExamples of maxSubst from GuessOption
--R
--E 1768

--S 1769 of 3320
)d op maxTower
--R 
--R
--RThere is one exposed function called maxTower :
--R   [1] List(D) -> D from D if D has PACPERC
--R
--RExamples of maxTower from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--E 1769

--S 1770 of 3320
)d op mdeg
--R 
--R
--RThere is one exposed function called mdeg :
--R   [1] D -> NonNegativeInteger from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RExamples of mdeg from RecursivePolynomialCategory
--R
--E 1770

--S 1771 of 3320
)d op measure
--R 
--R
--RThere are 14 exposed functions called measure :
--R   [1] NumericalIntegrationProblem -> Record(measure: Float,name: 
--R            String,explanations: List(String),extra: Result)
--R             from AnnaNumericalIntegrationPackage
--R   [2] (NumericalIntegrationProblem,RoutinesTable) -> Record(measure: 
--R            Float,name: String,explanations: List(String),extra: Result)
--R             from AnnaNumericalIntegrationPackage
--R   [3] (RoutinesTable,Record(fn: Expression(DoubleFloat),range: List(
--R            Segment(OrderedCompletion(DoubleFloat))),abserr: DoubleFloat,
--R            relerr: DoubleFloat)) -> Record(measure: Float,explanations: 
--R            String,extra: Result)
--R             from D if D has NUMINT
--R   [4] (RoutinesTable,Record(var: Symbol,fn: Expression(DoubleFloat),
--R            range: Segment(OrderedCompletion(DoubleFloat)),abserr: 
--R            DoubleFloat,relerr: DoubleFloat)) -> Record(measure: Float,
--R            explanations: String,extra: Result)
--R             from D if D has NUMINT
--R   [5] (RoutinesTable,Record(xinit: DoubleFloat,xend: DoubleFloat,fn: 
--R            Vector(Expression(DoubleFloat)),yinit: List(DoubleFloat),intvals
--R            : List(DoubleFloat),g: Expression(DoubleFloat),abserr: 
--R            DoubleFloat,relerr: DoubleFloat)) -> Record(measure: Float,
--R            explanations: String)
--R             from D if D has ODECAT
--R   [6] NumericalODEProblem -> Record(measure: Float,name: String,
--R            explanations: List(String))
--R             from AnnaOrdinaryDifferentialEquationPackage
--R   [7] (NumericalODEProblem,RoutinesTable) -> Record(measure: Float,
--R            name: String,explanations: List(String))
--R             from AnnaOrdinaryDifferentialEquationPackage
--R   [8] (RoutinesTable,Record(lfn: List(Expression(DoubleFloat)),init: 
--R            List(DoubleFloat))) -> Record(measure: Float,explanations: String
--R            )
--R             from D if D has OPTCAT
--R   [9] (RoutinesTable,Record(fn: Expression(DoubleFloat),init: List(
--R            DoubleFloat),lb: List(OrderedCompletion(DoubleFloat)),cf: List(
--R            Expression(DoubleFloat)),ub: List(OrderedCompletion(DoubleFloat))
--R            )) -> Record(measure: Float,explanations: String)
--R             from D if D has OPTCAT
--R   [10] NumericalOptimizationProblem -> Record(measure: Float,name: 
--R            String,explanations: List(String))
--R             from AnnaNumericalOptimizationPackage
--R   [11] (NumericalOptimizationProblem,RoutinesTable) -> Record(measure
--R            : Float,name: String,explanations: List(String))
--R             from AnnaNumericalOptimizationPackage
--R   [12] (RoutinesTable,Record(pde: List(Expression(DoubleFloat)),
--R            constraints: List(Record(start: DoubleFloat,finish: DoubleFloat,
--R            grid: NonNegativeInteger,boundaryType: Integer,dStart: Matrix(
--R            DoubleFloat),dFinish: Matrix(DoubleFloat))),f: List(List(
--R            Expression(DoubleFloat))),st: String,tol: DoubleFloat)) -> 
--R            Record(measure: Float,explanations: String)
--R             from D if D has PDECAT
--R   [13] NumericalPDEProblem -> Record(measure: Float,name: String,
--R            explanations: List(String))
--R             from AnnaPartialDifferentialEquationPackage
--R   [14] (NumericalPDEProblem,RoutinesTable) -> Record(measure: Float,
--R            name: String,explanations: List(String))
--R             from AnnaPartialDifferentialEquationPackage
--R
--RExamples of measure from AnnaNumericalIntegrationPackage
--R
--R
--RExamples of measure from NumericalIntegrationCategory
--R
--R
--RExamples of measure from OrdinaryDifferentialEquationsSolverCategory
--R
--R
--RExamples of measure from AnnaOrdinaryDifferentialEquationPackage
--R
--R
--RExamples of measure from NumericalOptimizationCategory
--R
--R
--RExamples of measure from AnnaNumericalOptimizationPackage
--R
--R
--RExamples of measure from PartialDifferentialEquationsSolverCategory
--R
--R
--RExamples of measure from AnnaPartialDifferentialEquationPackage
--R
--E 1771

--S 1772 of 3320
)d op measure2Result
--R 
--R
--RThere are 2 exposed functions called measure2Result :
--R   [1] Record(measure: Float,name: String,explanations: List(String))
--R             -> Result
--R             from ExpertSystemToolsPackage
--R   [2] Record(measure: Float,name: String,explanations: List(String),
--R            extra: Result) -> Result
--R             from ExpertSystemToolsPackage
--R
--RExamples of measure2Result from ExpertSystemToolsPackage
--R
--E 1772

--S 1773 of 3320
)d op meatAxe
--R 
--R
--RThere are 4 exposed functions called meatAxe :
--R   [1] (List(Matrix(D5)),Boolean,Integer,Integer) -> List(List(Matrix(
--R            D5)))
--R             from RepresentationPackage2(D5)
--R             if D5 has FIELD and D5 has FINITE and D5 has RING
--R   [2] List(Matrix(D3)) -> List(List(Matrix(D3)))
--R             from RepresentationPackage2(D3)
--R             if D3 has FIELD and D3 has FINITE and D3 has RING
--R   [3] (List(Matrix(D4)),Boolean) -> List(List(Matrix(D4)))
--R             from RepresentationPackage2(D4)
--R             if D4 has FIELD and D4 has FINITE and D4 has RING
--R   [4] (List(Matrix(D4)),PositiveInteger) -> List(List(Matrix(D4)))
--R             from RepresentationPackage2(D4)
--R             if D4 has FIELD and D4 has FINITE and D4 has RING
--R
--RExamples of meatAxe from RepresentationPackage2
--R
--E 1773

--S 1774 of 3320
)d op meatAxe
--R 
--R
--RThere are 4 exposed functions called meatAxe :
--R   [1] (List(Matrix(D5)),Boolean,Integer,Integer) -> List(List(Matrix(
--R            D5)))
--R             from RepresentationPackage2(D5)
--R             if D5 has FIELD and D5 has FINITE and D5 has RING
--R   [2] List(Matrix(D3)) -> List(List(Matrix(D3)))
--R             from RepresentationPackage2(D3)
--R             if D3 has FIELD and D3 has FINITE and D3 has RING
--R   [3] (List(Matrix(D4)),Boolean) -> List(List(Matrix(D4)))
--R             from RepresentationPackage2(D4)
--R             if D4 has FIELD and D4 has FINITE and D4 has RING
--R   [4] (List(Matrix(D4)),PositiveInteger) -> List(List(Matrix(D4)))
--R             from RepresentationPackage2(D4)
--R             if D4 has FIELD and D4 has FINITE and D4 has RING
--R
--RExamples of meatAxe from RepresentationPackage2
--R
--E 1774

--S 1775 of 3320
)d op medialSet
--R 
--R
--RThere are 2 exposed functions called medialSet :
--R   [1] List(D5) -> Union(WuWenTsunTriangularSet(D2,D3,D4,D5),"failed")
--R             from WuWenTsunTriangularSet(D2,D3,D4,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has INTDOM and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [2] (List(D7),((D7,D7) -> Boolean),((D7,D7) -> D7)) -> Union(
--R            WuWenTsunTriangularSet(D4,D5,D6,D7),"failed")
--R             from WuWenTsunTriangularSet(D4,D5,D6,D7)
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has INTDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R
--RExamples of medialSet from WuWenTsunTriangularSet
--R
--E 1775

--S 1776 of 3320
)d op member?
--R 
--R
--RThere are 7 exposed functions called member? :
--R   [1] (D2,ArrayStack(D2)) -> Boolean from ArrayStack(D2)
--R             if $ has finiteAggregate and D2 has SETCAT and D2 has 
--R            SETCAT
--R   [2] (D2,Dequeue(D2)) -> Boolean from Dequeue(D2)
--R             if $ has finiteAggregate and D2 has SETCAT and D2 has 
--R            SETCAT
--R   [3] (D2,Heap(D2)) -> Boolean from Heap(D2)
--R             if $ has finiteAggregate and D2 has SETCAT and D2 has 
--R            ORDSET
--R   [4] (D2,D) -> Boolean from D
--R             if D has finiteAggregate and D has HOAGG(D2) and D2 has 
--R            TYPE and D2 has SETCAT
--R   [5] (Permutation(D3),PermutationGroup(D3)) -> Boolean
--R             from PermutationGroup(D3) if D3 has SETCAT
--R   [6] (D2,Queue(D2)) -> Boolean from Queue(D2)
--R             if $ has finiteAggregate and D2 has SETCAT and D2 has 
--R            SETCAT
--R   [7] (D2,Stack(D2)) -> Boolean from Stack(D2)
--R             if $ has finiteAggregate and D2 has SETCAT and D2 has 
--R            SETCAT
--R
--RThere is one unexposed function called member? :
--R   [1] (PositiveInteger,SetOfMIntegersInOneToN(D3,D4)) -> Boolean
--R             from SetOfMIntegersInOneToN(D3,D4) if D3: PI and D4: PI
--R         
--R
--RExamples of member? from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rmember?(3,a)
--R
--R
--RExamples of member? from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rmember?(3,a)
--R
--R
--RExamples of member? from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rmember?(3,a)
--R
--R
--RExamples of member? from HomogeneousAggregate
--R
--R
--RExamples of member? from PermutationGroup
--R
--Rx : PERM INT := [[1,3,5],[7,11,9]] 
--Ry : PERM INT := [[3,5,7,9]] 
--Rz : PERM INT := [1,3,11] 
--Rg : PERMGRP INT := [ x , z ] 
--Rmember? ( y , g )
--R
--R
--RExamples of member? from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rmember?(3,a)
--R
--R
--RExamples of member? from SetOfMIntegersInOneToN
--R
--R
--RExamples of member? from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rmember?(3,a)
--R
--E 1776

--S 1777 of 3320
)d op members
--R 
--R
--RThere are 7 exposed functions called members :
--R   [1] ArrayStack(D2) -> List(D2) from ArrayStack(D2)
--R             if $ has finiteAggregate and D2 has SETCAT
--R   [2] Dequeue(D2) -> List(D2) from Dequeue(D2)
--R             if $ has finiteAggregate and D2 has SETCAT
--R   [3] Heap(D2) -> List(D2) from Heap(D2) if $ has finiteAggregate and 
--R            D2 has ORDSET
--R   [4] D -> List(D2) from D
--R             if D has finiteAggregate and D has HOAGG(D2) and D2 has 
--R            TYPE
--R   [5] Multiset(D2) -> List(D2) from Multiset(D2) if D2 has SETCAT
--R   [6] Queue(D2) -> List(D2) from Queue(D2)
--R             if $ has finiteAggregate and D2 has SETCAT
--R   [7] Stack(D2) -> List(D2) from Stack(D2)
--R             if $ has finiteAggregate and D2 has SETCAT
--R
--RExamples of members from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rmembers a
--R
--R
--RExamples of members from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rmembers a
--R
--R
--RExamples of members from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rmembers a
--R
--R
--RExamples of members from HomogeneousAggregate
--R
--R
--RExamples of members from Multiset
--R
--Rs := multiset [1,2,3,4,5,4,3,2,3,4,5,6,7,4,10] 
--Rmembers(s)
--R
--R
--RExamples of members from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rmembers a
--R
--R
--RExamples of members from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rmembers a
--R
--E 1777

--S 1778 of 3320
)d op merge
--R 
--R
--RThere are 6 exposed functions called merge :
--R   [1] (D,D) -> D from D if D has FLAGG(D1) and D1 has TYPE and D1 has 
--R            ORDSET
--R   [2] (((D2,D2) -> Boolean),D,D) -> D from D if D has FLAGG(D2) and D2
--R             has TYPE
--R   [3] (Heap(D1),Heap(D1)) -> Heap(D1) from Heap(D1) if D1 has ORDSET
--R         
--R   [4] (D,D) -> D from D if D has PRQAGG(D1)
--R   [5] (D,D) -> D from D if D has SPACEC(D1) and D1 has RING
--R   [6] List(D) -> D from D if D has SPACEC(D2) and D2 has RING
--R
--RThere are 2 unexposed functions called merge :
--R   [1] List(SubSpace(D2,D3)) -> SubSpace(D2,D3) from SubSpace(D2,D3)
--R             if D2: PI and D3 has RING
--R   [2] (SubSpace(D1,D2),SubSpace(D1,D2)) -> SubSpace(D1,D2) from 
--R            SubSpace(D1,D2)
--R             if D1: PI and D2 has RING
--R
--RExamples of merge from FiniteLinearAggregate
--R
--R
--RExamples of merge from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rb:Heap INT:= heap [6,7,8,9,10] 
--Rmerge(a,b)
--R
--R
--RExamples of merge from PriorityQueueAggregate
--R
--R
--RExamples of merge from ThreeSpaceCategory
--R
--R
--RExamples of merge from SubSpace
--R
--E 1778

--S 1779 of 3320
)d op merge!
--R 
--R
--RThere are 4 exposed functions called merge! :
--R   [1] (D,D) -> D from D if D has ELAGG(D1) and D1 has TYPE and D1 has 
--R            ORDSET
--R   [2] (((D2,D2) -> Boolean),D,D) -> D from D if D has ELAGG(D2) and D2
--R             has TYPE
--R   [3] (Heap(D1),Heap(D1)) -> Heap(D1) from Heap(D1) if D1 has ORDSET
--R         
--R   [4] (D,D) -> D from D if D has PRQAGG(D1)
--R
--RExamples of merge! from ExtensibleLinearAggregate
--R
--R
--RExamples of merge! from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rb:Heap INT:= heap [6,7,8,9,10] 
--Rmerge!(a,b) 
--Ra 
--Rb
--R
--R
--RExamples of merge! from PriorityQueueAggregate
--R
--E 1779

--S 1780 of 3320
)d op mergeDifference
--R 
--R
--RThere is one exposed function called mergeDifference :
--R   [1] (List(D2),List(D2)) -> List(D2) from MergeThing(D2) if D2 has 
--R            ORDSET
--R
--RExamples of mergeDifference from MergeThing
--R
--E 1780

--S 1781 of 3320
)d op mergeFactors
--R 
--R
--RThere is one unexposed function called mergeFactors :
--R   [1] (Factored(D2),Factored(D2)) -> Factored(D2)
--R             from FactoredFunctionUtilities(D2) if D2 has INTDOM
--R
--RExamples of mergeFactors from FactoredFunctionUtilities
--R
--E 1781

--S 1782 of 3320
)d op mesh
--R 
--R
--RThere are 7 exposed functions called mesh :
--R   [1] D -> List(List(Point(D2))) from D if D has SPACEC(D2) and D2
--R             has RING
--R   [2] (List(List(Point(D3))),Boolean,Boolean) -> D from D
--R             if D3 has RING and D has SPACEC(D3)
--R   [3] List(List(Point(D2))) -> D from D if D2 has RING and D has 
--R            SPACEC(D2)
--R   [4] (D,List(List(List(D3))),Boolean,Boolean) -> D from D
--R             if D has SPACEC(D3) and D3 has RING
--R   [5] (D,List(List(Point(D3))),Boolean,Boolean) -> D from D
--R             if D has SPACEC(D3) and D3 has RING
--R   [6] (D,List(List(List(D4))),List(SubSpaceComponentProperty),
--R            SubSpaceComponentProperty) -> D
--R             from D if D has SPACEC(D4) and D4 has RING
--R   [7] (D,List(List(Point(D4))),List(SubSpaceComponentProperty),
--R            SubSpaceComponentProperty) -> D
--R             from D if D has SPACEC(D4) and D4 has RING
--R
--RExamples of mesh from ThreeSpaceCategory
--R
--E 1782

--S 1783 of 3320
)d op mesh?
--R 
--R
--RThere is one exposed function called mesh? :
--R   [1] D -> Boolean from D if D has SPACEC(D2) and D2 has RING
--R
--RExamples of mesh? from ThreeSpaceCategory
--R
--E 1783

--S 1784 of 3320
)d op meshFun2Var
--R 
--R
--RThere is one unexposed function called meshFun2Var :
--R   [1] (((DoubleFloat,DoubleFloat) -> DoubleFloat),Union(((DoubleFloat,
--R            DoubleFloat,DoubleFloat) -> DoubleFloat),undefined),Segment(
--R            DoubleFloat),Segment(DoubleFloat),List(DrawOption)) -> ThreeSpace
--R            (DoubleFloat)
--R             from MeshCreationRoutinesForThreeDimensions
--R
--RExamples of meshFun2Var from MeshCreationRoutinesForThreeDimensions
--R
--E 1784

--S 1785 of 3320
)d op meshPar1Var
--R 
--R
--RThere is one unexposed function called meshPar1Var :
--R   [1] (Expression(Integer),Expression(Integer),Expression(Integer),(
--R            DoubleFloat -> DoubleFloat),Segment(DoubleFloat),List(DrawOption)
--R            ) -> ThreeSpace(DoubleFloat)
--R             from MeshCreationRoutinesForThreeDimensions
--R
--RExamples of meshPar1Var from MeshCreationRoutinesForThreeDimensions
--R
--E 1785

--S 1786 of 3320
)d op meshPar2Var
--R 
--R
--RThere are 3 unexposed functions called meshPar2Var :
--R   [1] (((DoubleFloat,DoubleFloat) -> DoubleFloat),((DoubleFloat,
--R            DoubleFloat) -> DoubleFloat),((DoubleFloat,DoubleFloat) -> 
--R            DoubleFloat),Union(((DoubleFloat,DoubleFloat,DoubleFloat) -> 
--R            DoubleFloat),undefined),Segment(DoubleFloat),Segment(DoubleFloat)
--R            ,List(DrawOption)) -> ThreeSpace(DoubleFloat)
--R             from MeshCreationRoutinesForThreeDimensions
--R   [2] (((DoubleFloat,DoubleFloat) -> Point(DoubleFloat)),Segment(
--R            DoubleFloat),Segment(DoubleFloat),List(DrawOption)) -> ThreeSpace
--R            (DoubleFloat)
--R             from MeshCreationRoutinesForThreeDimensions
--R   [3] (ThreeSpace(DoubleFloat),((DoubleFloat,DoubleFloat) -> Point(
--R            DoubleFloat)),Segment(DoubleFloat),Segment(DoubleFloat),List(
--R            DrawOption)) -> ThreeSpace(DoubleFloat)
--R             from MeshCreationRoutinesForThreeDimensions
--R
--RExamples of meshPar2Var from MeshCreationRoutinesForThreeDimensions
--R
--E 1786

--S 1787 of 3320
)d op message
--R 
--R
--RThere is one unexposed function called message :
--R   [1] String -> OutputForm from OutputForm
--R
--RExamples of message from OutputForm
--R
--E 1787

--S 1788 of 3320
)d op messagePrint
--R 
--R
--RThere is one unexposed function called messagePrint :
--R   [1] String -> Void from OutputForm
--R
--RExamples of messagePrint from OutputForm
--R
--E 1788

--S 1789 of 3320
)d op middle
--R 
--R
--RThere is one exposed function called middle :
--R   [1] RightOpenIntervalRootCharacterization(D1,D2) -> D1
--R             from RightOpenIntervalRootCharacterization(D1,D2)
--R             if D1 has Join(OrderedRing,Field) and D2 has UPOLYC(D1)
--R         
--R
--RExamples of middle from RightOpenIntervalRootCharacterization
--R
--E 1789

--S 1790 of 3320
)d op midpoint
--R 
--R
--RThere is one exposed function called midpoint :
--R   [1] Record(left: Fraction(Integer),right: Fraction(Integer)) -> 
--R            Fraction(Integer)
--R             from RealZeroPackage(D3) if D3 has UPOLYC(INT)
--R
--RExamples of midpoint from RealZeroPackage
--R
--E 1790

--S 1791 of 3320
)d op midpoints
--R 
--R
--RThere is one exposed function called midpoints :
--R   [1] List(Record(left: Fraction(Integer),right: Fraction(Integer)))
--R             -> List(Fraction(Integer))
--R             from RealZeroPackage(D3) if D3 has UPOLYC(INT)
--R
--RExamples of midpoints from RealZeroPackage
--R
--E 1791

--S 1792 of 3320
)d op mightHaveRoots
--R 
--R
--RThere is one exposed function called mightHaveRoots :
--R   [1] (D2,RightOpenIntervalRootCharacterization(D3,D2)) -> Boolean
--R             from RightOpenIntervalRootCharacterization(D3,D2)
--R             if D3 has Join(OrderedRing,Field) and D2 has UPOLYC(D3)
--R         
--R
--RExamples of mightHaveRoots from RightOpenIntervalRootCharacterization
--R
--E 1792

--S 1793 of 3320
)d op min
--R 
--R
--RThere are 5 exposed functions called min :
--R   [1]  -> D from D
--R             if D has FPS and not(has(D,arbitraryPrecision)) and not(
--R            has(D,arbitraryExponent))
--R   [2] D -> D1 from D if D has FSAGG(D1) and D1 has SETCAT and D1 has 
--R            ORDSET
--R   [3] D -> D1 from D if D has OMSAGG(D1) and D1 has ORDSET
--R   [4] (D,D) -> D from D if D has ORDSET
--R   [5]  -> SingleInteger from SingleInteger
--R
--RExamples of min from FloatingPointSystem
--R
--R
--RExamples of min from FiniteSetAggregate
--R
--R
--RExamples of min from OrderedMultisetAggregate
--R
--R
--RExamples of min from OrderedSet
--R
--R
--RExamples of min from SingleInteger
--R
--E 1793

--S 1794 of 3320
)d op minColIndex
--R 
--R
--RThere are 2 exposed functions called minColIndex :
--R   [1] D -> Integer from D
--R             if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has 
--R            FLAGG(D2) and D4 has FLAGG(D2)
--R   [2] D -> Integer from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of minColIndex from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--RminColIndex(arr)
--R
--R
--RExamples of minColIndex from RectangularMatrixCategory
--R
--E 1794

--S 1795 of 3320
)d op mindeg
--R 
--R
--RThere is one exposed function called mindeg :
--R   [1] D -> OrderedFreeMonoid(D2) from D
--R             if D has XFALG(D2,D3) and D2 has ORDSET and D3 has RING
--R         
--R
--RThere is one unexposed function called mindeg :
--R   [1] XPolynomialRing(D2,D1) -> D1 from XPolynomialRing(D2,D1)
--R             if D1 has ORDMON and D2 has RING
--R
--RExamples of mindeg from XFreeAlgebra
--R
--R
--RExamples of mindeg from XPolynomialRing
--R
--E 1795

--S 1796 of 3320
)d op mindegTerm
--R 
--R
--RThere is one exposed function called mindegTerm :
--R   [1] D -> Record(k: OrderedFreeMonoid(D2),c: D3) from D
--R             if D has XFALG(D2,D3) and D2 has ORDSET and D3 has RING
--R         
--R
--RExamples of mindegTerm from XFreeAlgebra
--R
--E 1796

--S 1797 of 3320
)d op minGbasis
--R 
--R
--RThere is one unexposed function called minGbasis :
--R   [1] List(D5) -> List(D5) from GroebnerInternalPackage(D2,D3,D4,D5)
--R             if D5 has POLYCAT(D2,D3,D4) and D2 has GCDDOM and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RExamples of minGbasis from GroebnerInternalPackage
--R
--E 1797

--S 1798 of 3320
)d op minimalForm
--R 
--R
--RThere are 3 exposed functions called minimalForm :
--R   [1] D1 -> D1 from PackageForPoly(D2,D1,D3,D4)
--R             if D2 has RING and D3 has DIRPCAT(D4,NNI) and D4: NNI and 
--R            D1 has FAMR(D2,D3)
--R   [2] (D1,D2) -> D1 from PolynomialPackageForCurve(D3,D1,D4,D5,D2)
--R             if D3 has FIELD and D4 has DIRPCAT(D5,NNI) and D5: NNI and
--R            D1 has FAMR(D3,D4) and D2 has PRSPCAT(D3)
--R   [3] (D1,D2,Integer) -> D1 from PolynomialPackageForCurve(D4,D1,D5,D6
--R            ,D2)
--R             if D4 has FIELD and D5 has DIRPCAT(D6,NNI) and D6: NNI and
--R            D1 has FAMR(D4,D5) and D2 has PRSPCAT(D4)
--R
--RExamples of minimalForm from PackageForPoly
--R
--R
--RExamples of minimalForm from PolynomialPackageForCurve
--R
--E 1798

--S 1799 of 3320
)d op minimalPolynomial
--R 
--R
--RThere are 3 exposed functions called minimalPolynomial :
--R   [1] (D,PositiveInteger) -> SparseUnivariatePolynomial(D) from D
--R             if D3 has FINITE and D3 has FIELD and D has FAXF(D3)
--R   [2] D -> SparseUnivariatePolynomial(D2) from D if D has FAXF(D2) and
--R            D2 has FIELD
--R   [3] D -> D1 from D
--R             if D has FINRALG(D2,D1) and D2 has COMRING and D2 has 
--R            FIELD and D1 has UPOLYC(D2)
--R
--RThere is one unexposed function called minimalPolynomial :
--R   [1] Vector(D3) -> SparseUnivariatePolynomial(D3)
--R             from InnerNormalBasisFieldFunctions(D3) if D3 has FFIELDC
--R            
--R
--RExamples of minimalPolynomial from FiniteAlgebraicExtensionField
--R
--R
--RExamples of minimalPolynomial from FiniteRankAlgebra
--R
--R
--RExamples of minimalPolynomial from InnerNormalBasisFieldFunctions
--R
--E 1799

--S 1800 of 3320
)d op minimize
--R 
--R
--RThere is one unexposed function called minimize :
--R   [1] FractionalIdeal(D1,D2,D3,D4) -> FractionalIdeal(D1,D2,D3,D4)
--R             from FractionalIdeal(D1,D2,D3,D4)
--R             if D1 has EUCDOM and D2 has QFCAT(D1) and D3 has UPOLYC(D2
--R            ) and D4 has Join(FramedAlgebra(D2,D3),RetractableTo(D2))
--R         
--R
--RExamples of minimize from FractionalIdeal
--R
--E 1800

--S 1801 of 3320
)d op minimumDegree
--R 
--R
--RThere are 5 exposed functions called minimumDegree :
--R   [1] D -> D1 from D if D has FAMR(D2,D1) and D2 has RING and D1 has 
--R            OAMON
--R   [2] D -> NonNegativeInteger from D if D has MLO(D2) and D2 has RING
--R            
--R   [3] D -> NonNegativeInteger from D if D has OREPCAT(D2) and D2 has 
--R            RING
--R   [4] (D,List(D5)) -> List(NonNegativeInteger) from D
--R             if D has POLYCAT(D3,D4,D5) and D3 has RING and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [5] (D,D2) -> NonNegativeInteger from D
--R             if D has POLYCAT(D3,D4,D2) and D3 has RING and D4 has 
--R            OAMONS and D2 has ORDSET
--R
--RExamples of minimumDegree from FiniteAbelianMonoidRing
--R
--R
--RExamples of minimumDegree from MonogenicLinearOperator
--R
--R
--RExamples of minimumDegree from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of minimumDegree from PolynomialCategory
--R
--E 1801

--S 1802 of 3320
)d op minimumExponent
--R 
--R
--RThere are 2 exposed functions called minimumExponent :
--R   [1]  -> Integer from MachineFloat
--R   [2] Integer -> Integer from MachineFloat
--R
--RExamples of minimumExponent from MachineFloat
--R
--E 1802

--S 1803 of 3320
)d op minIndex
--R 
--R
--RThere is one exposed function called minIndex :
--R   [1] D -> D1 from D
--R             if D has IXAGG(D1,D2) and D2 has TYPE and D1 has SETCAT 
--R            and D1 has ORDSET
--R
--RExamples of minIndex from IndexedAggregate
--R
--E 1803

--S 1804 of 3320
)d op minordet
--R 
--R
--RThere are 3 exposed functions called minordet :
--R   [1] D -> D1 from D
--R             if D has MATCAT(D1,D2,D3) and D2 has FLAGG(D1) and D3 has 
--R            FLAGG(D1) and D1 has commutative(*) and D1 has RING
--R   [2] D2 -> D1 from MatrixLinearAlgebraFunctions(D1,D3,D4,D2)
--R             if D3 has FLAGG(D1) and D4 has FLAGG(D1) and D1 has 
--R            COMRING and D2 has MATCAT(D1,D3,D4)
--R   [3] D -> D1 from D
--R             if D has SMATCAT(D2,D1,D3,D4) and D3 has DIRPCAT(D2,D1) 
--R            and D4 has DIRPCAT(D2,D1) and D1 has commutative(*) and D1
--R             has RING
--R
--RExamples of minordet from MatrixCategory
--R
--Rminordet matrix [[j**i for i in 0..4] for j in 1..5]
--R
--R
--RExamples of minordet from MatrixLinearAlgebraFunctions
--R
--R
--RExamples of minordet from SquareMatrixCategory
--R
--E 1804

--S 1805 of 3320
)d op minPoints
--R 
--R
--RThere are 2 exposed functions called minPoints :
--R   [1]  -> Integer from GraphicsDefaults
--R   [2] Integer -> Integer from GraphicsDefaults
--R
--RThere is one unexposed function called minPoints :
--R   [1]  -> Integer from Plot
--R
--RExamples of minPoints from GraphicsDefaults
--R
--R
--RExamples of minPoints from Plot
--R
--E 1805

--S 1806 of 3320
)d op minPoints3D
--R 
--R
--RThere is one unexposed function called minPoints3D :
--R   [1]  -> Integer from Plot3D
--R
--RExamples of minPoints3D from Plot3D
--R
--E 1806

--S 1807 of 3320
)d op minPol
--R 
--R
--RThere are 2 unexposed functions called minPol :
--R   [1] (List(HomogeneousDistributedMultivariatePolynomial(D4,D5)),List(
--R            HomogeneousDistributedMultivariatePolynomial(D4,D5)),
--R            OrderedVariableList(D4)) -> 
--R            HomogeneousDistributedMultivariatePolynomial(D4,D5)
--R             from LinGroebnerPackage(D4,D5) if D4: LIST(SYMBOL) and D5
--R             has GCDDOM
--R   [2] (List(HomogeneousDistributedMultivariatePolynomial(D4,D5)),
--R            OrderedVariableList(D4)) -> 
--R            HomogeneousDistributedMultivariatePolynomial(D4,D5)
--R             from LinGroebnerPackage(D4,D5) if D4: LIST(SYMBOL) and D5
--R             has GCDDOM
--R
--RExamples of minPol from LinGroebnerPackage
--R
--E 1807

--S 1808 of 3320
)d op minPoly
--R 
--R
--RThere is one exposed function called minPoly :
--R   [1] Kernel(D) -> SparseUnivariatePolynomial(D) from D if D has RING 
--R            and D has ES
--R
--RThere is one unexposed function called minPoly :
--R   [1] Kernel(D4) -> SparseUnivariatePolynomial(D4)
--R             from AlgebraicFunction(D3,D4)
--R             if D4 has FS(D3) and D3 has RETRACT(INT) and D3 has Join(
--R            OrderedSet,IntegralDomain)
--R
--RExamples of minPoly from AlgebraicFunction
--R
--R
--RExamples of minPoly from Ring
--R
--E 1808

--S 1809 of 3320
)d op minrank
--R 
--R
--RThere is one unexposed function called minrank :
--R   [1] List(Record(rank: NonNegativeInteger,eqns: List(Record(det: D6,
--R            rows: List(Integer),cols: List(Integer))),fgb: List(D6))) -> 
--R            NonNegativeInteger
--R             from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D5,D4) and D3 has Join(
--R            EuclideanDomain,CharacteristicZero) and D4 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D5 has OAMONS
--R
--RExamples of minrank from ParametricLinearEquations
--R
--E 1809

--S 1810 of 3320
)d op minRowIndex
--R 
--R
--RThere are 2 exposed functions called minRowIndex :
--R   [1] D -> Integer from D
--R             if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has 
--R            FLAGG(D2) and D4 has FLAGG(D2)
--R   [2] D -> Integer from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of minRowIndex from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--RminRowIndex(arr)
--R
--R
--RExamples of minRowIndex from RectangularMatrixCategory
--R
--E 1810

--S 1811 of 3320
)d op minset
--R 
--R
--RThere is one unexposed function called minset :
--R   [1] List(List(D5)) -> List(List(D5))
--R             from ParametricLinearEquations(D2,D3,D4,D5)
--R             if D5 has POLYCAT(D2,D4,D3) and D2 has Join(
--R            EuclideanDomain,CharacteristicZero) and D3 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D4 has OAMONS
--R
--RExamples of minset from ParametricLinearEquations
--R
--E 1811

--S 1812 of 3320
)d op minus!
--R 
--R
--RThere are 2 unexposed functions called minus! :
--R   [1] (Matrix(D2),Matrix(D2)) -> Matrix(D2)
--R             from StorageEfficientMatrixOperations(D2) if D2 has RING
--R         
--R   [2] (Matrix(D2),Matrix(D2),Matrix(D2)) -> Matrix(D2)
--R             from StorageEfficientMatrixOperations(D2) if D2 has RING
--R         
--R
--RExamples of minus! from StorageEfficientMatrixOperations
--R
--E 1812

--S 1813 of 3320
)d op minusInfinity
--R 
--R
--RThere are 2 exposed functions called minusInfinity :
--R   [1]  -> OrderedCompletion(Integer) from Infinity
--R   [2]  -> OrderedCompletion(D1) from OrderedCompletion(D1) if D1 has 
--R            SETCAT
--R
--RExamples of minusInfinity from Infinity
--R
--R
--RExamples of minusInfinity from OrderedCompletion
--R
--E 1813

--S 1814 of 3320
)d op mirror
--R 
--R
--RThere are 2 exposed functions called mirror :
--R   [1] D -> D from D if D has FLALG(D1,D2) and D1 has ORDSET and D2
--R             has COMRING
--R   [2] D -> D from D if D has XFALG(D1,D2) and D1 has ORDSET and D2
--R             has RING
--R
--RThere are 3 unexposed functions called mirror :
--R   [1] LieExponentials(D1,D2,D3) -> LieExponentials(D1,D2,D3)
--R             from LieExponentials(D1,D2,D3)
--R             if D1 has ORDSET and D2 has Join(CommutativeRing,Module(
--R            Fraction(Integer))) and D3: PI
--R   [2] Magma(D1) -> Magma(D1) from Magma(D1) if D1 has ORDSET
--R   [3] OrderedFreeMonoid(D1) -> OrderedFreeMonoid(D1) from 
--R            OrderedFreeMonoid(D1)
--R             if D1 has ORDSET
--R
--RExamples of mirror from FreeLieAlgebra
--R
--R
--RExamples of mirror from LieExponentials
--R
--R
--RExamples of mirror from Magma
--R
--R
--RExamples of mirror from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rmirror m1
--R
--R
--RExamples of mirror from XFreeAlgebra
--R
--E 1814

--S 1815 of 3320
)d op mix
--R 
--R
--RThere is one unexposed function called mix :
--R   [1] List(Record(den: Integer,gcdnum: Integer)) -> Integer
--R             from PointsOfFiniteOrderTools(D3,D4)
--R             if D3 has UPOLYC(FRAC(INT)) and D4 has UPOLYC(FRAC(D3))
--R         
--R
--RExamples of mix from PointsOfFiniteOrderTools
--R
--E 1815

--S 1816 of 3320
)d op mkAnswer
--R 
--R
--RThere is one unexposed function called mkAnswer :
--R   [1] (D1,List(Record(scalar: Fraction(Integer),coeff: 
--R            SparseUnivariatePolynomial(D1),logand: SparseUnivariatePolynomial
--R            (D1))),List(Record(integrand: D1,intvar: D1))) -> 
--R            IntegrationResult(D1)
--R             from IntegrationResult(D1) if D1 has FIELD
--R
--RExamples of mkAnswer from IntegrationResult
--R
--E 1816

--S 1817 of 3320
)d op mkcomm
--R 
--R
--RThere are 2 exposed functions called mkcomm :
--R   [1] (Commutator,Commutator) -> Commutator from Commutator
--R   [2] Integer -> Commutator from Commutator
--R
--RExamples of mkcomm from Commutator
--R
--E 1817

--S 1818 of 3320
)d op mkIntegral
--R 
--R
--RThere is one unexposed function called mkIntegral :
--R   [1] D2 -> Record(coef: Fraction(D4),poly: D2) from ChangeOfVariable(
--R            D3,D4,D2)
--R             if D3 has UFD and D4 has UPOLYC(D3) and D2 has UPOLYC(FRAC
--R            (D4))
--R
--RExamples of mkIntegral from ChangeOfVariable
--R
--E 1818

--S 1819 of 3320
)d op mkPrim
--R 
--R
--RThere is one unexposed function called mkPrim :
--R   [1] (D1,Symbol) -> D1 from IntegrationTools(D3,D1)
--R             if D3 has GCDDOM and D3 has ORDSET and D1 has ELEMFUN and 
--R            D1 has FS(D3)
--R
--RExamples of mkPrim from IntegrationTools
--R
--E 1819

--S 1820 of 3320
)d op modifyPoint
--R 
--R
--RThere are 3 unexposed functions called modifyPoint :
--R   [1] (SubSpace(D3,D4),NonNegativeInteger,Point(D4)) -> SubSpace(D3,D4
--R            )
--R             from SubSpace(D3,D4) if D4 has RING and D3: PI
--R   [2] (SubSpace(D3,D4),List(NonNegativeInteger),NonNegativeInteger)
--R             -> SubSpace(D3,D4)
--R             from SubSpace(D3,D4) if D3: PI and D4 has RING
--R   [3] (SubSpace(D3,D4),List(NonNegativeInteger),Point(D4)) -> SubSpace
--R            (D3,D4)
--R             from SubSpace(D3,D4) if D4 has RING and D3: PI
--R
--RExamples of modifyPoint from SubSpace
--R
--E 1820

--S 1821 of 3320
)d op modifyPointData
--R 
--R
--RThere are 2 exposed functions called modifyPointData :
--R   [1] (D,NonNegativeInteger,Point(D3)) -> D from D
--R             if D has SPACEC(D3) and D3 has RING
--R   [2] (ThreeDimensionalViewport,NonNegativeInteger,Point(DoubleFloat))
--R             -> Void
--R             from ThreeDimensionalViewport
--R
--RExamples of modifyPointData from ThreeSpaceCategory
--R
--R
--RExamples of modifyPointData from ThreeDimensionalViewport
--R
--E 1821

--S 1822 of 3320
)d op modTree
--R 
--R
--RThere is one exposed function called modTree :
--R   [1] (D2,List(D2)) -> List(D2) from CRApackage(D2) if D2 has EUCDOM
--R         
--R
--RExamples of modTree from CRApackage
--R
--E 1822

--S 1823 of 3320
)d op modularFactor
--R 
--R
--RThere is one unexposed function called modularFactor :
--R   [1] D2 -> Record(prime: Integer,factors: List(D2))
--R             from GaloisGroupFactorizer(D2) if D2 has UPOLYC(INT)
--R
--RExamples of modularFactor from GaloisGroupFactorizer
--R
--E 1823

--S 1824 of 3320
)d op modularGcd
--R 
--R
--RThere is one unexposed function called modularGcd :
--R   [1] List(D1) -> D1 from InnerModularGcd(D3,D1,D4,D5)
--R             if D1 has UPOLYC(D3) and D3 has EUCDOM and D4: D3 and D5: 
--R            ((D3,NonNegativeInteger) -> D3)
--R
--RExamples of modularGcd from InnerModularGcd
--R
--E 1824

--S 1825 of 3320
)d op modularGcdPrimitive
--R 
--R
--RThere is one unexposed function called modularGcdPrimitive :
--R   [1] List(D1) -> D1 from InnerModularGcd(D3,D1,D4,D5)
--R             if D1 has UPOLYC(D3) and D3 has EUCDOM and D4: D3 and D5: 
--R            ((D3,NonNegativeInteger) -> D3)
--R
--RExamples of modularGcdPrimitive from InnerModularGcd
--R
--E 1825

--S 1826 of 3320
)d op module
--R 
--R
--RThere are 2 unexposed functions called module :
--R   [1] FractionalIdeal(D2,D3,D4,D5) -> FramedModule(D2,D3,D4,D5,D6)
--R             from FramedModule(D2,D3,D4,D5,D6)
--R             if D5 has RETRACT(D3) and D2 has EUCDOM and D3 has QFCAT(
--R            D2) and D4 has UPOLYC(D3) and D5 has FRAMALG(D3,D4) and D6
--R            : VECTOR(D5)
--R   [2] Vector(D5) -> FramedModule(D2,D3,D4,D5,D6)
--R             from FramedModule(D2,D3,D4,D5,D6)
--R             if D5 has FRAMALG(D3,D4) and D3 has QFCAT(D2) and D4 has 
--R            UPOLYC(D3) and D2 has EUCDOM and D6: VECTOR(D5)
--R
--RExamples of module from FramedModule
--R
--E 1826

--S 1827 of 3320
)d op moduleSum
--R 
--R
--RThere is one unexposed function called moduleSum :
--R   [1] (Record(basis: Matrix(D2),basisDen: D2,basisInv: Matrix(D2)),
--R            Record(basis: Matrix(D2),basisDen: D2,basisInv: Matrix(D2))) -> 
--R            Record(basis: Matrix(D2),basisDen: D2,basisInv: Matrix(D2))
--R             from IntegralBasisTools(D2,D3,D4)
--R             if D2 has EuclideanDomainwith
--R               squareFree : % -> Factored(%)and D3 has UPOLYC(D2) 
--R            and D4 has FRAMALG(D2,D3)
--R
--RExamples of moduleSum from IntegralBasisTools
--R
--E 1827

--S 1828 of 3320
)d op moduloP
--R 
--R
--RThere is one exposed function called moduloP :
--R   [1] D -> Integer from D if D has PADICCT(D2)
--R
--RExamples of moduloP from PAdicIntegerCategory
--R
--E 1828

--S 1829 of 3320
)d op modulus
--R 
--R
--RThere is one exposed function called modulus :
--R   [1]  -> Integer from D if D has PADICCT(D2)
--R
--RThere are 4 unexposed functions called modulus :
--R   [1] EuclideanModularRing(D2,D3,D1,D4,D5,D6) -> D1
--R             from EuclideanModularRing(D2,D3,D1,D4,D5,D6)
--R             if D2 has COMRING and D1 has ABELMON and D3 has UPOLYC(D2)
--R            and D4: ((D3,D1) -> D3) and D5: ((D1,D1) -> Union(D1,
--R            "failed")) and D6: ((D3,D3,D1) -> Union(D3,"failed"))
--R   [2] ModularField(D2,D1,D3,D4,D5) -> D1 from ModularField(D2,D1,D3,D4
--R            ,D5)
--R             if D1 has ABELMON and D2 has COMRING and D3: ((D2,D1) -> 
--R            D2) and D4: ((D1,D1) -> Union(D1,"failed")) and D5: ((D2,D2
--R            ,D1) -> Union(D2,"failed"))
--R   [3]  -> D1 from ModMonic(D2,D1) if D1 has UPOLYC(D2) and D2 has RING
--R            
--R   [4] ModularRing(D2,D1,D3,D4,D5) -> D1 from ModularRing(D2,D1,D3,D4,
--R            D5)
--R             if D1 has ABELMON and D2 has COMRING and D3: ((D2,D1) -> 
--R            D2) and D4: ((D1,D1) -> Union(D1,"failed")) and D5: ((D2,D2
--R            ,D1) -> Union(D2,"failed"))
--R
--RExamples of modulus from EuclideanModularRing
--R
--R
--RExamples of modulus from ModularField
--R
--R
--RExamples of modulus from ModMonic
--R
--R
--RExamples of modulus from ModularRing
--R
--R
--RExamples of modulus from PAdicIntegerCategory
--R
--E 1829

--S 1830 of 3320
)d op moebius
--R 
--R
--RThere is one unexposed function called moebius :
--R   [1] (D1,D1,D1,D1) -> MoebiusTransform(D1) from MoebiusTransform(D1)
--R             if D1 has FIELD
--R
--RExamples of moebius from MoebiusTransform
--R
--E 1830

--S 1831 of 3320
)d op moebiusMu
--R 
--R
--RThere is one exposed function called moebiusMu :
--R   [1] Integer -> Integer from IntegerNumberTheoryFunctions
--R
--RExamples of moebiusMu from IntegerNumberTheoryFunctions
--R
--E 1831

--S 1832 of 3320
)d op monic?
--R 
--R
--RThere is one exposed function called monic? :
--R   [1] D -> Boolean from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RThere is one unexposed function called monic? :
--R   [1] D2 -> Boolean from GaloisGroupPolynomialUtilities(D3,D2)
--R             if D3 has RING and D2 has UPOLYC(D3)
--R
--RExamples of monic? from GaloisGroupPolynomialUtilities
--R
--R
--RExamples of monic? from RecursivePolynomialCategory
--R
--E 1832

--S 1833 of 3320
)d op monicCompleteDecompose
--R 
--R
--RThere is one unexposed function called monicCompleteDecompose :
--R   [1] D2 -> List(D2) from UnivariatePolynomialDecompositionPackage(D3,
--R            D2)
--R             if D3 has Join(IntegralDomain,CharacteristicZero) and D2
--R             has UPOLYC(D3)
--R
--RExamples of monicCompleteDecompose from UnivariatePolynomialDecompositionPackage
--R
--E 1833

--S 1834 of 3320
)d op monicDecomposeIfCan
--R 
--R
--RThere is one unexposed function called monicDecomposeIfCan :
--R   [1] D2 -> Union(Record(left: D2,right: D2),"failed")
--R             from UnivariatePolynomialDecompositionPackage(D3,D2)
--R             if D3 has Join(IntegralDomain,CharacteristicZero) and D2
--R             has UPOLYC(D3)
--R
--RExamples of monicDecomposeIfCan from UnivariatePolynomialDecompositionPackage
--R
--E 1834

--S 1835 of 3320
)d op monicDivide
--R 
--R
--RThere are 2 exposed functions called monicDivide :
--R   [1] (D,D,D2) -> Record(quotient: D,remainder: D) from D
--R             if D3 has RING and D4 has OAMONS and D2 has ORDSET and D
--R             has POLYCAT(D3,D4,D2)
--R   [2] (D,D) -> Record(quotient: D,remainder: D) from D
--R             if D2 has RING and D has UPOLYC(D2)
--R
--RExamples of monicDivide from PolynomialCategory
--R
--R
--RExamples of monicDivide from UnivariatePolynomialCategory
--R
--E 1835

--S 1836 of 3320
)d op monicLeftDivide
--R 
--R
--RThere is one exposed function called monicLeftDivide :
--R   [1] (D,D) -> Record(quotient: D,remainder: D) from D
--R             if D2 has INTDOM and D2 has RING and D has OREPCAT(D2)
--R
--RThere is one unexposed function called monicLeftDivide :
--R   [1] (D2,D2,Automorphism(D4)) -> Record(quotient: D2,remainder: D2)
--R             from UnivariateSkewPolynomialCategoryOps(D4,D2)
--R             if D4 has INTDOM and D4 has RING and D2 has OREPCAT(D4)
--R         
--R
--RExamples of monicLeftDivide from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of monicLeftDivide from UnivariateSkewPolynomialCategoryOps
--R
--E 1836

--S 1837 of 3320
)d op monicModulo
--R 
--R
--RThere is one exposed function called monicModulo :
--R   [1] (D,D) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R
--RThere is one unexposed function called monicModulo :
--R   [1] (NewSparseUnivariatePolynomial(D1),NewSparseUnivariatePolynomial
--R            (D1)) -> NewSparseUnivariatePolynomial(D1)
--R             from NewSparseUnivariatePolynomial(D1) if D1 has RING
--R
--RExamples of monicModulo from NewSparseUnivariatePolynomial
--R
--R
--RExamples of monicModulo from RecursivePolynomialCategory
--R
--E 1837

--S 1838 of 3320
)d op monicRightDivide
--R 
--R
--RThere is one exposed function called monicRightDivide :
--R   [1] (D,D) -> Record(quotient: D,remainder: D) from D
--R             if D2 has INTDOM and D2 has RING and D has OREPCAT(D2)
--R
--RThere is one unexposed function called monicRightDivide :
--R   [1] (D2,D2,Automorphism(D4)) -> Record(quotient: D2,remainder: D2)
--R             from UnivariateSkewPolynomialCategoryOps(D4,D2)
--R             if D4 has INTDOM and D4 has RING and D2 has OREPCAT(D4)
--R         
--R
--RExamples of monicRightDivide from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of monicRightDivide from UnivariateSkewPolynomialCategoryOps
--R
--E 1838

--S 1839 of 3320
)d op monicRightFactorIfCan
--R 
--R
--RThere is one unexposed function called monicRightFactorIfCan :
--R   [1] (D1,NonNegativeInteger) -> Union(D1,"failed")
--R             from UnivariatePolynomialDecompositionPackage(D3,D1)
--R             if D3 has Join(IntegralDomain,CharacteristicZero) and D1
--R             has UPOLYC(D3)
--R
--RExamples of monicRightFactorIfCan from UnivariatePolynomialDecompositionPackage
--R
--E 1839

--S 1840 of 3320
)d op monom
--R 
--R
--RThere are 2 exposed functions called monom :
--R   [1] (D1,D2) -> D from D if D has FMCAT(D2,D1) and D2 has RING and D1
--R             has SETCAT
--R   [2] (OrderedFreeMonoid(D3),D2) -> D from D
--R             if D3 has ORDSET and D has XFALG(D3,D2) and D2 has RING
--R         
--R
--RThere is one unexposed function called monom :
--R   [1] (D2,Integer) -> Stream(D2) from StreamTaylorSeriesOperations(D2)
--R             if D2 has RING
--R
--RExamples of monom from FreeModuleCat
--R
--R
--RExamples of monom from StreamTaylorSeriesOperations
--R
--R
--RExamples of monom from XFreeAlgebra
--R
--E 1840

--S 1841 of 3320
)d op monomial
--R 
--R
--RThere are 11 exposed functions called monomial :
--R   [1] (D1,D2) -> D from D if D has AMR(D1,D2) and D1 has RING and D2
--R             has OAMON
--R   [2] (D1,List(PositiveInteger)) -> CliffordAlgebra(D3,D1,D4)
--R             from CliffordAlgebra(D3,D1,D4)
--R             if D3: PI and D1 has FIELD and D4: QFORM(D3,D1)
--R   [3] (D1,D2) -> D from D if D has IDPC(D1,D2) and D1 has SETCAT and 
--R            D2 has ORDSET
--R   [4] (D1,NonNegativeInteger) -> D from D if D has MLO(D1) and D1 has 
--R            RING
--R   [5] (D,List(D4),List(NonNegativeInteger)) -> D from D
--R             if D has MTSCAT(D3,D4) and D3 has RING and D4 has ORDSET
--R         
--R   [6] (D,D1,NonNegativeInteger) -> D from D
--R             if D has MTSCAT(D3,D1) and D3 has RING and D1 has ORDSET
--R         
--R   [7] (D1,NonNegativeInteger) -> D from D if D has OREPCAT(D1) and D1
--R             has RING
--R   [8] (D,List(D5),List(NonNegativeInteger)) -> D from D
--R             if D has POLYCAT(D3,D4,D5) and D3 has RING and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [9] (D,D1,NonNegativeInteger) -> D from D
--R             if D has POLYCAT(D3,D4,D1) and D3 has RING and D4 has 
--R            OAMONS and D1 has ORDSET
--R   [10] (D,List(D5),List(D4)) -> D from D
--R             if D has PSCAT(D3,D4,D5) and D3 has RING and D4 has OAMON 
--R            and D5 has ORDSET
--R   [11] (D,D1,D2) -> D from D
--R             if D has PSCAT(D3,D2,D1) and D3 has RING and D2 has OAMON 
--R            and D1 has ORDSET
--R
--RThere are 3 unexposed functions called monomial :
--R   [1] (D1,ModuleMonomial(D4,D5,D6)) -> GeneralModulePolynomial(D3,D1,
--R            D4,D5,D6,D7)
--R             from GeneralModulePolynomial(D3,D1,D4,D5,D6,D7)
--R             if D4 has ORDSET and D5 has DIRPCAT(#(D3),NNI) and D6: ((
--R            Record(index: D4,exponent: D5),Record(index: D4,exponent: 
--R            D5)) -> Boolean) and D3: LIST(SYMBOL) and D1 has COMRING 
--R            and D7 has POLYCAT(D1,D5,OVAR(D3))
--R   [2] (D1,Integer) -> LaurentPolynomial(D1,D3) from LaurentPolynomial(
--R            D1,D3)
--R             if D1 has INTDOM and D3 has UPOLYC(D1)
--R   [3] (D1,D2) -> MonoidRing(D1,D2) from MonoidRing(D1,D2)
--R             if D1 has RING and D2 has MONOID
--R
--RExamples of monomial from AbelianMonoidRing
--R
--R
--RExamples of monomial from CliffordAlgebra
--R
--R
--RExamples of monomial from GeneralModulePolynomial
--R
--R
--RExamples of monomial from IndexedDirectProductCategory
--R
--R
--RExamples of monomial from LaurentPolynomial
--R
--R
--RExamples of monomial from MonogenicLinearOperator
--R
--R
--RExamples of monomial from MonoidRing
--R
--R
--RExamples of monomial from MultivariateTaylorSeriesCategory
--R
--R
--RExamples of monomial from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of monomial from PolynomialCategory
--R
--R
--RExamples of monomial from PowerSeriesCategory
--R
--E 1841

--S 1842 of 3320
)d op monomial?
--R 
--R
--RThere are 3 exposed functions called monomial? :
--R   [1] D -> Boolean from D if D has AMR(D2,D3) and D2 has RING and D3
--R             has OAMON
--R   [2] D -> Boolean from D if D has FMCAT(D2,D3) and D2 has RING and D3
--R             has SETCAT
--R   [3] D -> Boolean from D if D has XFALG(D2,D3) and D2 has ORDSET and 
--R            D3 has RING
--R
--RThere are 3 unexposed functions called monomial? :
--R   [1] InnerSparseUnivariatePowerSeries(D2) -> Boolean
--R             from InnerSparseUnivariatePowerSeries(D2) if D2 has RING
--R         
--R   [2] LaurentPolynomial(D2,D3) -> Boolean from LaurentPolynomial(D2,D3
--R            )
--R             if D2 has INTDOM and D3 has UPOLYC(D2)
--R   [3] MonoidRing(D2,D3) -> Boolean from MonoidRing(D2,D3)
--R             if D2 has RING and D3 has MONOID
--R
--RExamples of monomial? from AbelianMonoidRing
--R
--R
--RExamples of monomial? from FreeModuleCat
--R
--R
--RExamples of monomial? from InnerSparseUnivariatePowerSeries
--R
--R
--RExamples of monomial? from LaurentPolynomial
--R
--R
--RExamples of monomial? from MonoidRing
--R
--R
--RExamples of monomial? from XFreeAlgebra
--R
--E 1842

--S 1843 of 3320
)d op monomial2series
--R 
--R
--RThere is one exposed function called monomial2series :
--R   [1] (List(D),List(NonNegativeInteger),Integer) -> D from D
--R             if D has LOCPOWC(D4) and D4 has FIELD
--R
--RExamples of monomial2series from LocalPowerSeriesCategory
--R
--E 1843

--S 1844 of 3320
)d op monomialIntegrate
--R 
--R
--RThere is one unexposed function called monomialIntegrate :
--R   [1] (Fraction(D5),(D5 -> D5)) -> Record(ir: IntegrationResult(
--R            Fraction(D5)),specpart: Fraction(D5),polypart: D5)
--R             from TranscendentalIntegration(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has FIELD
--R
--RExamples of monomialIntegrate from TranscendentalIntegration
--R
--E 1844

--S 1845 of 3320
)d op monomialIntPoly
--R 
--R
--RThere is one unexposed function called monomialIntPoly :
--R   [1] (D2,(D2 -> D2)) -> Record(answer: D2,polypart: D2)
--R             from TranscendentalIntegration(D4,D2)
--R             if D2 has UPOLYC(D4) and D4 has FIELD
--R
--RExamples of monomialIntPoly from TranscendentalIntegration
--R
--E 1845

--S 1846 of 3320
)d op monomials
--R 
--R
--RThere are 3 exposed functions called monomials :
--R   [1] D -> List(D) from D if D2 has RING and D3 has SETCAT and D has 
--R            FMCAT(D2,D3)
--R   [2] D2 -> List(D2) from PackageForPoly(D3,D2,D4,D5)
--R             if D3 has RING and D4 has DIRPCAT(D5,NNI) and D5: NNI and 
--R            D2 has FAMR(D3,D4)
--R   [3] D -> List(D) from D
--R             if D2 has RING and D3 has OAMONS and D4 has ORDSET and D
--R             has POLYCAT(D2,D3,D4)
--R
--RThere is one unexposed function called monomials :
--R   [1] MonoidRing(D2,D3) -> List(MonoidRing(D2,D3)) from MonoidRing(D2,
--R            D3)
--R             if D2 has RING and D3 has MONOID
--R
--RExamples of monomials from FreeModuleCat
--R
--R
--RExamples of monomials from MonoidRing
--R
--R
--RExamples of monomials from PackageForPoly
--R
--R
--RExamples of monomials from PolynomialCategory
--R
--E 1846

--S 1847 of 3320
)d op monomRDE
--R 
--R
--RThere is one unexposed function called monomRDE :
--R   [1] (Fraction(D5),Fraction(D5),(D5 -> D5)) -> Union(Record(a: D5,b: 
--R            Fraction(D5),c: Fraction(D5),t: D5),"failed")
--R             from TranscendentalRischDE(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer))
--R
--RExamples of monomRDE from TranscendentalRischDE
--R
--E 1847

--S 1848 of 3320
)d op monomRDEsys
--R 
--R
--RThere is one unexposed function called monomRDEsys :
--R   [1] (Fraction(D5),Fraction(D5),Fraction(D5),(D5 -> D5)) -> Union(
--R            Record(a: D5,b: Fraction(D5),h: D5,c1: Fraction(D5),c2: Fraction(
--R            D5),t: D5),"failed")
--R             from TranscendentalRischDESystem(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer))
--R
--RExamples of monomRDEsys from TranscendentalRischDESystem
--R
--E 1848

--S 1849 of 3320
)d op more?
--R 
--R
--RThere are 6 exposed functions called more? :
--R   [1] (D,NonNegativeInteger) -> Boolean from D if D has AGG
--R   [2] (ArrayStack(D3),NonNegativeInteger) -> Boolean from ArrayStack(
--R            D3)
--R             if D3 has SETCAT
--R   [3] (Dequeue(D3),NonNegativeInteger) -> Boolean from Dequeue(D3) if 
--R            D3 has SETCAT
--R   [4] (Heap(D3),NonNegativeInteger) -> Boolean from Heap(D3) if D3
--R             has ORDSET
--R   [5] (Queue(D3),NonNegativeInteger) -> Boolean from Queue(D3) if D3
--R             has SETCAT
--R   [6] (Stack(D3),NonNegativeInteger) -> Boolean from Stack(D3) if D3
--R             has SETCAT
--R
--RThere is one unexposed function called more? :
--R   [1] (D2,D2) -> Boolean from UserDefinedPartialOrdering(D2)
--R             if D2 has ORDSET and D2 has SETCAT
--R
--RExamples of more? from Aggregate
--R
--R
--RExamples of more? from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rmore?(a,9)
--R
--R
--RExamples of more? from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rmore?(a,9)
--R
--R
--RExamples of more? from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rmore?(a,9)
--R
--R
--RExamples of more? from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rmore?(a,9)
--R
--R
--RExamples of more? from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rmore?(a,9)
--R
--R
--RExamples of more? from UserDefinedPartialOrdering
--R
--E 1849

--S 1850 of 3320
)d op moreAlgebraic?
--R 
--R
--RThere are 2 exposed functions called moreAlgebraic? :
--R   [1] (D2,D2) -> Boolean from QuasiComponentPackage(D3,D4,D5,D6,D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D2 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [2] (D2,D2) -> Boolean from SquareFreeQuasiComponentPackage(D3,D4,D5
--R            ,D6,D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D2 has RSETCAT(D3,D4,D5,D6)
--R         
--R
--RExamples of moreAlgebraic? from QuasiComponentPackage
--R
--R
--RExamples of moreAlgebraic? from SquareFreeQuasiComponentPackage
--R
--E 1850

--S 1851 of 3320
)d op morphism
--R 
--R
--RThere are 3 unexposed functions called morphism :
--R   [1] ((D2,Integer) -> D2) -> Automorphism(D2) from Automorphism(D2)
--R             if D2 has RING
--R   [2] ((D2 -> D2),(D2 -> D2)) -> Automorphism(D2) from Automorphism(D2
--R            )
--R             if D2 has RING
--R   [3] (D2 -> D2) -> Automorphism(D2) from Automorphism(D2) if D2 has 
--R            RING
--R
--RExamples of morphism from Automorphism
--R
--E 1851

--S 1852 of 3320
)d op move
--R 
--R
--RThere is one exposed function called move :
--R   [1] (ThreeDimensionalViewport,NonNegativeInteger,NonNegativeInteger)
--R             -> Void
--R             from ThreeDimensionalViewport
--R
--RThere is one unexposed function called move :
--R   [1] (TwoDimensionalViewport,NonNegativeInteger,NonNegativeInteger)
--R             -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of move from TwoDimensionalViewport
--R
--R
--RExamples of move from ThreeDimensionalViewport
--R
--E 1852

--S 1853 of 3320 done
)d op movedPoints
--R 
--R
--RThere are 2 exposed functions called movedPoints :
--R   [1] PermutationGroup(D2) -> Set(D2) from PermutationGroup(D2) if D2
--R             has SETCAT
--R   [2] Permutation(D2) -> Set(D2) from Permutation(D2) if D2 has SETCAT
--R            
--R
--RExamples of movedPoints from PermutationGroup
--R
--Rx : PERM INT := [[1,3,5],[7,11,9]] 
--Rz : PERM INT := [1,3,11] 
--Rg : PERMGRP INT := [ x , z ] 
--RmovedPoints g
--R
--R
--RExamples of movedPoints from Permutation
--R
--Rp := coercePreimagesImages([[1,2,3],[1,2,3]]) 
--RmovedPoints p
--R
--E 1853

--S 1854 of 3320
)d op mpsode
--R 
--R
--RThere is one unexposed function called mpsode :
--R   [1] (List(D4),List((List(D5) -> D5))) -> List(D5)
--R             from UnivariateTaylorSeriesODESolver(D4,D5)
--R             if D4 has ALGEBRA(FRAC(INT)) and D5 has UTSCAT(D4)
--R
--RExamples of mpsode from UnivariateTaylorSeriesODESolver
--R
--E 1854

--S 1855 of 3320
)d op MPtoMPT
--R 
--R
--RThere is one exposed function called MPtoMPT :
--R   [1] (Polynomial(Integer),Symbol,List(Symbol),D5) -> D1 from D
--R             if D has MAGCDOC(D1,D5) and D5 has TYPE and D1 has TYPE
--R         
--R
--RExamples of MPtoMPT from ModularAlgebraicGcdOperations
--R
--E 1855

--S 1856 of 3320
)d op mr
--R 
--R
--RThere is one unexposed function called mr :
--R   [1] List(List(List(D3))) -> Record(f1: List(D3),f2: List(List(List(
--R            D3))),f3: List(List(D3)),f4: List(List(List(D3))))
--R             from TableauxBumpers(D3) if D3 has ORDSET
--R
--RExamples of mr from TableauxBumpers
--R
--E 1856

--S 1857 of 3320
)d op mul
--R 
--R
--RThere is one exposed function called mul :
--R   [1] (U32Vector,U32Vector,Integer) -> U32Vector
--R             from U32VectorPolynomialOperations
--R
--RExamples of mul from U32VectorPolynomialOperations
--R
--E 1857

--S 1858 of 3320
--R--------------------)d op mul_by_binomial (fix this)
--E 1858

--S 1859 of 3320
--R--------------------)d op mul_by_scalar (fix this)
--E 1859

--S 1860 of 3320
)d op mulmod
--R 
--R
--RThere is one exposed function called mulmod :
--R   [1] (D,D,D) -> D from D if D has INS
--R
--RExamples of mulmod from IntegerNumberSystem
--R
--E 1860

--S 1861 of 3320
)d op multiEuclidean
--R 
--R
--RThere is one exposed function called multiEuclidean :
--R   [1] (List(D),D) -> Union(List(D),"failed") from D if D has EUCDOM
--R         
--R
--RExamples of multiEuclidean from EuclideanDomain
--R
--E 1861

--S 1862 of 3320
)d op multiEuclideanTree
--R 
--R
--RThere is one exposed function called multiEuclideanTree :
--R   [1] (List(D2),D2) -> List(D2) from CRApackage(D2) if D2 has EUCDOM
--R         
--R
--RExamples of multiEuclideanTree from CRApackage
--R
--E 1862

--S 1863 of 3320
)d op multinomial
--R 
--R
--RThere is one exposed function called multinomial :
--R   [1] (D1,List(D1)) -> D1 from IntegerCombinatoricFunctions(D1) if D1
--R             has INS
--R
--RExamples of multinomial from IntegerCombinatoricFunctions
--R
--E 1863

--S 1864 of 3320
)d op multiple
--R 
--R
--RThere are 2 exposed functions called multiple :
--R   [1] D1 -> D1 from FunctionSpaceAssertions(D2,D1)
--R             if D2 has ORDSET and D1 has FS(D2)
--R   [2] Symbol -> Expression(Integer) from PatternMatchAssertions
--R
--RExamples of multiple from FunctionSpaceAssertions
--R
--R
--RExamples of multiple from PatternMatchAssertions
--R
--E 1864

--S 1865 of 3320
)d op multiple?
--R 
--R
--RThere is one unexposed function called multiple? :
--R   [1] Pattern(D2) -> Boolean from Pattern(D2) if D2 has SETCAT
--R
--RExamples of multiple? from Pattern
--R
--E 1865

--S 1866 of 3320
)d op multiplicative?
--R 
--R
--RThere is one exposed function called multiplicative? :
--R   [1] (DirichletRing(D3),PositiveInteger) -> Boolean from 
--R            DirichletRing(D3)
--R             if D3 has RING
--R
--RExamples of multiplicative? from DirichletRing
--R
--E 1866

--S 1867 of 3320
)d op multiplicity
--R 
--R
--RThere are 3 exposed functions called multiplicity :
--R   [1] List(List(D4)) -> NonNegativeInteger from NewtonPolygon(D3,D4,D5
--R            ,D6)
--R             if D4 has FAMR(D3,D5) and D5 has DIRPCAT(D6,NNI) and D6: 
--R            NNI and D3 has RING
--R   [2] (D2,D3) -> NonNegativeInteger
--R             from PolynomialPackageForCurve(D4,D2,D5,D6,D3)
--R             if D4 has FIELD and D5 has DIRPCAT(D6,NNI) and D6: NNI and
--R            D2 has FAMR(D4,D5) and D3 has PRSPCAT(D4)
--R   [3] (D2,D3,Integer) -> NonNegativeInteger
--R             from PolynomialPackageForCurve(D5,D2,D6,D7,D3)
--R             if D5 has FIELD and D6 has DIRPCAT(D7,NNI) and D7: NNI and
--R            D2 has FAMR(D5,D6) and D3 has PRSPCAT(D5)
--R
--RExamples of multiplicity from NewtonPolygon
--R
--R
--RExamples of multiplicity from PolynomialPackageForCurve
--R
--E 1867

--S 1868 of 3320
)d op multiplyCoefficients
--R 
--R
--RThere are 2 exposed functions called multiplyCoefficients :
--R   [1] ((Integer -> D2),D) -> D from D if D has ULSCAT(D2) and D2 has 
--R            RING
--R   [2] ((Integer -> D2),D) -> D from D if D has UTSCAT(D2) and D2 has 
--R            RING
--R
--RThere is one unexposed function called multiplyCoefficients :
--R   [1] ((Integer -> D2),InnerSparseUnivariatePowerSeries(D2)) -> 
--R            InnerSparseUnivariatePowerSeries(D2)
--R             from InnerSparseUnivariatePowerSeries(D2) if D2 has RING
--R         
--R
--RExamples of multiplyCoefficients from InnerSparseUnivariatePowerSeries
--R
--R
--RExamples of multiplyCoefficients from UnivariateLaurentSeriesCategory
--R
--R
--RExamples of multiplyCoefficients from UnivariateTaylorSeriesCategory
--R
--E 1868

--S 1869 of 3320
)d op multiplyExponents
--R 
--R
--RThere are 3 exposed functions called multiplyExponents :
--R   [1] (D,NonNegativeInteger) -> D from D if D has UPOLYC(D2) and D2
--R             has RING
--R   [2] (D,PositiveInteger) -> D from D
--R             if D has UPSCAT(D2,D3) and D2 has RING and D3 has OAMON
--R         
--R   [3] (D,Fraction(Integer)) -> D from D if D has UPXSCAT(D2) and D2
--R             has RING
--R
--RExamples of multiplyExponents from UnivariatePolynomialCategory
--R
--R
--RExamples of multiplyExponents from UnivariatePowerSeriesCategory
--R
--R
--RExamples of multiplyExponents from UnivariatePuiseuxSeriesCategory
--R
--E 1869

--S 1870 of 3320
)d op multisect
--R 
--R
--RThere are 2 exposed functions called multisect :
--R   [1] (Integer,Integer,UnivariateFormalPowerSeries(D2)) -> 
--R            UnivariateFormalPowerSeries(D2)
--R             from UnivariateFormalPowerSeries(D2) if D2 has RING
--R   [2] (Integer,Integer,UnivariateTaylorSeriesCZero(D2,D3)) -> 
--R            UnivariateTaylorSeriesCZero(D2,D3)
--R             from UnivariateTaylorSeriesCZero(D2,D3) if D2 has RING and
--R            D3: SYMBOL
--R
--RThere are 2 unexposed functions called multisect :
--R   [1] (Integer,Integer,Stream(D3)) -> Stream(D3)
--R             from StreamTaylorSeriesOperations(D3) if D3 has RING
--R   [2] (Integer,Integer,UnivariateTaylorSeries(D2,D3,D4)) -> 
--R            UnivariateTaylorSeries(D2,D3,D4)
--R             from UnivariateTaylorSeries(D2,D3,D4)
--R             if D2 has RING and D3: SYMBOL and D4: D2
--R
--RExamples of multisect from StreamTaylorSeriesOperations
--R
--R
--RExamples of multisect from UnivariateFormalPowerSeries
--R
--R
--RExamples of multisect from UnivariateTaylorSeries
--R
--R
--RExamples of multisect from UnivariateTaylorSeriesCZero
--R
--E 1870

--S 1871 of 3320
)d op multiServ
--R 
--R
--RThere is one exposed function called multiServ :
--R   [1] SExpression -> Void from AxiomServer
--R
--RExamples of multiServ from AxiomServer
--R
--E 1871

--S 1872 of 3320 done
)d op multiset
--R 
--R
--RThere are 3 exposed functions called multiset :
--R   [1] List(D2) -> Multiset(D2) from Multiset(D2) if D2 has SETCAT
--R   [2] D1 -> Multiset(D1) from Multiset(D1) if D1 has SETCAT
--R   [3]  -> Multiset(D1) from Multiset(D1) if D1 has SETCAT
--R
--RExamples of multiset from Multiset
--R
--Rs := multiset [1,2,3,4,5,4,3,2,3,4,5,6,7,4,10]
--R
--Rmultiset(3)
--R
--Rm:=multiset()@Multiset(Integer)
--R
--E 1872

--S 1873 of 3320
)d op multivariate
--R 
--R
--RThere are 3 exposed functions called multivariate :
--R   [1] (SparseUnivariatePolynomial(D),D2) -> D from D
--R             if D has POLYCAT(D3,D4,D2) and D3 has RING and D4 has 
--R            OAMONS and D2 has ORDSET
--R   [2] (SparseUnivariatePolynomial(D3),D2) -> D from D
--R             if D3 has RING and D has POLYCAT(D3,D4,D2) and D4 has 
--R            OAMONS and D2 has ORDSET
--R   [3] (Fraction(SparseUnivariatePolynomial(Fraction(Polynomial(D4)))),
--R            Symbol) -> Fraction(Polynomial(D4))
--R             from RationalFunction(D4) if D4 has INTDOM
--R
--RThere are 2 unexposed functions called multivariate :
--R   [1] (SparseUnivariatePolynomial(Fraction(SparseUnivariatePolynomial(
--R            D1))),Kernel(D1),D1) -> D1
--R             from GenusZeroIntegration(D4,D1,D5)
--R             if D1 has Join(FunctionSpace(D4),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D4 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D5 has SETCAT
--R   [2] (Fraction(SparseUnivariatePolynomial(D1)),D3) -> D1
--R             from PolynomialCategoryQuotientFunctions(D4,D3,D5,D6,D1)
--R             if D4 has OAMONS and D3 has ORDSET and D5 has RING and D1
--R             has Fieldwith
--R               coerce : D6 -> %
--R               numer : % -> D6
--R               denom : % -> D6and D6 has POLYCAT(D5,D4,D3)
--R
--RExamples of multivariate from GenusZeroIntegration
--R
--R
--RExamples of multivariate from PolynomialCategory
--R
--R
--RExamples of multivariate from PolynomialCategoryQuotientFunctions
--R
--R
--RExamples of multivariate from RationalFunction
--R
--E 1873

--S 1874 of 3320
)d op multMonom
--R 
--R
--RThere is one unexposed function called multMonom :
--R   [1] (D1,D2,GeneralModulePolynomial(D3,D1,D4,D2,D5,D6)) -> 
--R            GeneralModulePolynomial(D3,D1,D4,D2,D5,D6)
--R             from GeneralModulePolynomial(D3,D1,D4,D2,D5,D6)
--R             if D3: LIST(SYMBOL) and D1 has COMRING and D2 has DIRPCAT(
--R            #(D3),NNI) and D5: ((Record(index: D4,exponent: D2),Record(
--R            index: D4,exponent: D2)) -> Boolean) and D4 has ORDSET and 
--R            D6 has POLYCAT(D1,D2,OVAR(D3))
--R
--RExamples of multMonom from GeneralModulePolynomial
--R
--E 1874

--S 1875 of 3320
)d op multV
--R 
--R
--RThere is one exposed function called multV :
--R   [1] D -> NonNegativeInteger from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of multV from InfinitlyClosePointCategory
--R
--E 1875

--S 1876 of 3320
)d op Musser
--R 
--R
--RThere is one exposed function called Musser :
--R   [1] D2 -> Factored(D2) from FiniteFieldSquareFreeDecomposition(D3,D2
--R            )
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R
--RExamples of Musser from FiniteFieldSquareFreeDecomposition
--R
--E 1876

--S 1877 of 3320
)d op musserTrials
--R 
--R
--RThere are 2 unexposed functions called musserTrials :
--R   [1]  -> PositiveInteger from GaloisGroupFactorizer(D2) if D2 has 
--R            UPOLYC(INT)
--R   [2] PositiveInteger -> PositiveInteger from GaloisGroupFactorizer(D2
--R            )
--R             if D2 has UPOLYC(INT)
--R
--RExamples of musserTrials from GaloisGroupFactorizer
--R
--E 1877

--S 1878 of 3320
)d op mvar
--R 
--R
--RThere are 2 exposed functions called mvar :
--R   [1] D -> D1 from D
--R             if D has PSETCAT(D2,D3,D1,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has RPOLCAT(D2,D3,D1) and D1 has ORDSET
--R   [2] D -> D1 from D
--R             if D has RPOLCAT(D2,D3,D1) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET
--R
--RExamples of mvar from PolynomialSetCategory
--R
--R
--RExamples of mvar from RecursivePolynomialCategory
--R
--E 1878

--S 1879 of 3320
)d op myDegree
--R 
--R
--RThere is one unexposed function called myDegree :
--R   [1] (SparseUnivariatePolynomial(D8),List(D6),NonNegativeInteger) -> 
--R            List(NonNegativeInteger)
--R             from MultivariateSquareFree(D5,D6,D7,D8)
--R             if D6 has ORDSET and D8 has POLYCAT(D7,D5,D6) and D5 has 
--R            OAMONS and D7 has EUCDOM
--R
--RExamples of myDegree from MultivariateSquareFree
--R
--E 1879

--S 1880 of 3320
)d op name
--R 
--R
--RThere are 4 exposed functions called name :
--R   [1] BasicOperator -> Symbol from BasicOperator
--R   [2] D -> D1 from D if D has FILECAT(D1,D2) and D2 has SETCAT and D1
--R             has SETCAT
--R   [3] D -> String from D if D has FNCAT
--R   [4] Symbol -> Symbol from Symbol
--R
--RThere are 3 unexposed functions called name :
--R   [1] FunctionCalled(D2) -> Symbol from FunctionCalled(D2) if D2: 
--R            SYMBOL
--R   [2] Kernel(D2) -> Symbol from Kernel(D2) if D2 has ORDSET
--R   [3] RuleCalled(D2) -> Symbol from RuleCalled(D2) if D2: SYMBOL
--R
--RExamples of name from BasicOperator
--R
--R
--RExamples of name from FileCategory
--R
--R
--RExamples of name from FileNameCategory
--R
--R
--RExamples of name from FunctionCalled
--R
--R
--RExamples of name from Kernel
--R
--R
--RExamples of name from RuleCalled
--R
--R
--RExamples of name from Symbol
--R
--RU:=subscript(u,[1,2]) 
--Rname(U)
--R
--E 1880

--S 1881 of 3320
)d op nand
--R 
--R
--RThere are 2 exposed functions called nand :
--R   [1] (Boolean,Boolean) -> Boolean from Boolean
--R   [2] (D,D) -> D from D if D has BTAGG
--R
--RExamples of nand from Boolean
--R
--R
--RExamples of nand from BitAggregate
--R
--E 1881

--S 1882 of 3320
)d op nary?
--R 
--R
--RThere is one exposed function called nary? :
--R   [1] BasicOperator -> Boolean from BasicOperator
--R
--RExamples of nary? from BasicOperator
--R
--E 1882

--S 1883 of 3320
)d op ncols
--R 
--R
--RThere are 3 exposed functions called ncols :
--R   [1] D -> NonNegativeInteger from D
--R             if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has 
--R            FLAGG(D2) and D4 has FLAGG(D2)
--R   [2] D -> NonNegativeInteger from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R   [3] SparseEchelonMatrix(D2,D3) -> NonNegativeInteger
--R             from SparseEchelonMatrix(D2,D3) if D2 has ORDSET and D3
--R             has RING
--R
--RExamples of ncols from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rncols(arr)
--R
--R
--RExamples of ncols from RectangularMatrixCategory
--R
--R
--RExamples of ncols from SparseEchelonMatrix
--R
--E 1883

--S 1884 of 3320
)d op negAndPosEdge
--R 
--R
--RThere is one exposed function called negAndPosEdge :
--R   [1] (D2,List(List(D2))) -> List(List(D2)) from NewtonPolygon(D3,D2,
--R            D4,D5)
--R             if D2 has FAMR(D3,D4) and D4 has DIRPCAT(D5,NNI) and D5: 
--R            NNI and D3 has RING
--R
--RExamples of negAndPosEdge from NewtonPolygon
--R
--E 1884

--S 1885 of 3320
)d op negative?
--R 
--R
--RThere are 3 exposed functions called negative? :
--R   [1] D -> Boolean from D
--R             if D has INTCAT(D2) and D2 has Join(FloatingPointSystem,
--R            TranscendentalFunctionCategory)
--R   [2] D -> Boolean from D if D has ORDRING
--R   [3] (D2,D) -> Boolean from D
--R             if D has RRCC(D3,D2) and D3 has Join(OrderedRing,Field) 
--R            and D2 has UPOLYC(D3)
--R
--RExamples of negative? from IntervalCategory
--R
--R
--RExamples of negative? from OrderedRing
--R
--R
--RExamples of negative? from RealRootCharacterizationCategory
--R
--E 1885

--S 1886 of 3320
)d op neglist
--R 
--R
--RThere is one exposed function called neglist :
--R   [1] List(D2) -> List(D2) from ExpertSystemToolsPackage1(D2) if D2
--R             has ORDRING
--R
--RExamples of neglist from ExpertSystemToolsPackage1
--R
--E 1886

--S 1887 of 3320
)d op new
--R 
--R
--RThere are 8 exposed functions called new :
--R   [1] (NonNegativeInteger,NonNegativeInteger,D2) -> D from D
--R             if D2 has TYPE and D has ARR2CAT(D2,D3,D4) and D3 has 
--R            FLAGG(D2) and D4 has FLAGG(D2)
--R   [2] (String,String,String) -> D from D if D has FNCAT
--R   [3]  -> ScriptFormulaFormat from ScriptFormulaFormat
--R   [4] (NonNegativeInteger,D2) -> D from D if D has LNAGG(D2) and D2
--R             has TYPE
--R   [5] (List(D3),Integer) -> SparseEchelonMatrix(D3,D4)
--R             from SparseEchelonMatrix(D3,D4) if D3 has ORDSET and D4
--R             has RING
--R   [6] Symbol -> Symbol from Symbol
--R   [7]  -> Symbol from Symbol
--R   [8]  -> TexFormat from TexFormat
--R
--RThere are 4 unexposed functions called new :
--R   [1]  -> SubSpaceComponentProperty from SubSpaceComponentProperty
--R   [2]  -> PatternMatchListResult(D1,D2,D3)
--R             from PatternMatchListResult(D1,D2,D3)
--R             if D2 has SETCAT and D1 has SETCAT and D3 has LSAGG(D2)
--R         
--R   [3]  -> PatternMatchResult(D1,D2) from PatternMatchResult(D1,D2)
--R             if D1 has SETCAT and D2 has SETCAT
--R   [4]  -> SubSpace(D1,D2) from SubSpace(D1,D2) if D1: PI and D2 has 
--R            RING
--R
--RExamples of new from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,0)
--R
--R
--RExamples of new from SubSpaceComponentProperty
--R
--R
--RExamples of new from FileNameCategory
--R
--R
--RExamples of new from ScriptFormulaFormat
--R
--R
--RExamples of new from LinearAggregate
--R
--R
--RExamples of new from PatternMatchListResult
--R
--R
--RExamples of new from PatternMatchResult
--R
--R
--RExamples of new from SparseEchelonMatrix
--R
--R
--RExamples of new from SubSpace
--R
--R
--RExamples of new from Symbol
--R
--Rnew("xyz")$Symbol
--R
--Rnew()$Symbol
--R
--R
--RExamples of new from TexFormat
--R
--E 1887

--S 1888 of 3320
)d op newElement
--R 
--R
--RThere are 3 exposed functions called newElement :
--R   [1] (SparseUnivariatePolynomial(D),Symbol) -> D from D if D has 
--R            PACPERC
--R   [2] (SparseUnivariatePolynomial(D),D,Symbol) -> D from D if D has 
--R            PACPERC
--R   [3] (SparseUnivariatePolynomial(
--R            PseudoAlgebraicClosureOfRationalNumber),
--R            SparseUnivariatePolynomial(PseudoAlgebraicClosureOfRationalNumber
--R            ),PositiveInteger,PseudoAlgebraicClosureOfRationalNumber,Symbol)
--R             -> PseudoAlgebraicClosureOfRationalNumber
--R             from PseudoAlgebraicClosureOfRationalNumber
--R
--RExamples of newElement from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--R
--RExamples of newElement from PseudoAlgebraicClosureOfRationalNumber
--R
--E 1888

--S 1889 of 3320
)d op newLine
--R 
--R
--RThere is one exposed function called newLine :
--R   [1]  -> String from DisplayPackage
--R
--RExamples of newLine from DisplayPackage
--R
--E 1889

--S 1890 of 3320
)d op newReduc
--R 
--R
--RThere is one unexposed function called newReduc :
--R   [1]  -> Void from FunctionSpaceReduce(D2,D3)
--R             if D2 has Join(OrderedSet,IntegralDomain,RetractableTo(
--R            Integer)) and D3 has FS(D2)
--R
--RExamples of newReduc from FunctionSpaceReduce
--R
--E 1890

--S 1891 of 3320
)d op newSubProgram
--R 
--R
--RThere is one exposed function called newSubProgram :
--R   [1] Symbol -> Void from TheSymbolTable
--R
--RExamples of newSubProgram from TheSymbolTable
--R
--E 1891

--S 1892 of 3320
)d op newton
--R 
--R
--RThere is one unexposed function called newton :
--R   [1] List(D3) -> SparseUnivariatePolynomial(D3) from 
--R            NewtonInterpolation(D3)
--R             if D3 has INTDOM
--R
--RExamples of newton from NewtonInterpolation
--R
--E 1892

--S 1893 of 3320
)d op newtonPolygon
--R 
--R
--RThere is one exposed function called newtonPolygon :
--R   [1] (D2,Integer,Integer,Union(left,center,right,vertical,horizontal)
--R            ) -> List(List(D2))
--R             from NewtonPolygon(D5,D2,D6,D7)
--R             if D5 has RING and D6 has DIRPCAT(D7,NNI) and D7: NNI and 
--R            D2 has FAMR(D5,D6)
--R
--RExamples of newtonPolygon from NewtonPolygon
--R
--E 1893

--S 1894 of 3320
)d op newtonPolySlope
--R 
--R
--RThere is one exposed function called newtonPolySlope :
--R   [1] DistributedMultivariatePolynomial([construct,QUOTEX,QUOTEY],D3)
--R             -> List(List(NonNegativeInteger))
--R             from BlowUpPackage(D3,D4,D5,D6,D7)
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D6 has DIRPCAT(#(
--R            D4),NNI) and D5 has FAMR(D3,D6) and D7 has BLMETCT
--R
--RExamples of newtonPolySlope from BlowUpPackage
--R
--E 1894

--S 1895 of 3320
)d op newTypeLists
--R 
--R
--RThere is one exposed function called newTypeLists :
--R   [1] SymbolTable -> SExpression from SymbolTable
--R
--RExamples of newTypeLists from SymbolTable
--R
--E 1895

--S 1896 of 3320
)d op next
--R 
--R
--RThere is one exposed function called next :
--R   [1] D -> D from D if D has DLAGG(D1) and D1 has TYPE
--R
--RExamples of next from DoublyLinkedAggregate
--R
--E 1896

--S 1897 of 3320
)d op nextColeman
--R 
--R
--RThere is one exposed function called nextColeman :
--R   [1] (List(Integer),List(Integer),Matrix(Integer)) -> Matrix(Integer)
--R             from SymmetricGroupCombinatoricFunctions
--R
--RExamples of nextColeman from SymmetricGroupCombinatoricFunctions
--R
--E 1897

--S 1898 of 3320
)d op nextIrreduciblePoly
--R 
--R
--RThere is one unexposed function called nextIrreduciblePoly :
--R   [1] SparseUnivariatePolynomial(D2) -> Union(
--R            SparseUnivariatePolynomial(D2),"failed")
--R             from FiniteFieldPolynomialPackage(D2) if D2 has FFIELDC
--R         
--R
--RExamples of nextIrreduciblePoly from FiniteFieldPolynomialPackage
--R
--E 1898

--S 1899 of 3320
)d op nextItem
--R 
--R
--RThere is one exposed function called nextItem :
--R   [1] D -> Union(D,"failed") from D if D has STEP
--R
--RExamples of nextItem from StepThrough
--R
--E 1899

--S 1900 of 3320
)d op nextLatticePermutation
--R 
--R
--RThere is one exposed function called nextLatticePermutation :
--R   [1] (List(Integer),List(Integer),Boolean) -> List(Integer)
--R             from SymmetricGroupCombinatoricFunctions
--R
--RExamples of nextLatticePermutation from SymmetricGroupCombinatoricFunctions
--R
--E 1900

--S 1901 of 3320
)d op nextNormalPoly
--R 
--R
--RThere is one unexposed function called nextNormalPoly :
--R   [1] SparseUnivariatePolynomial(D2) -> Union(
--R            SparseUnivariatePolynomial(D2),"failed")
--R             from FiniteFieldPolynomialPackage(D2) if D2 has FFIELDC
--R         
--R
--RExamples of nextNormalPoly from FiniteFieldPolynomialPackage
--R
--E 1901

--S 1902 of 3320
)d op nextNormalPrimitivePoly
--R 
--R
--RThere is one unexposed function called nextNormalPrimitivePoly :
--R   [1] SparseUnivariatePolynomial(D2) -> Union(
--R            SparseUnivariatePolynomial(D2),"failed")
--R             from FiniteFieldPolynomialPackage(D2) if D2 has FFIELDC
--R         
--R
--RExamples of nextNormalPrimitivePoly from FiniteFieldPolynomialPackage
--R
--E 1902

--S 1903 of 3320
)d op nextPartition
--R 
--R
--RThere are 2 exposed functions called nextPartition :
--R   [1] (Vector(Integer),Vector(Integer),Integer) -> Vector(Integer)
--R             from SymmetricGroupCombinatoricFunctions
--R   [2] (List(Integer),Vector(Integer),Integer) -> Vector(Integer)
--R             from SymmetricGroupCombinatoricFunctions
--R
--RExamples of nextPartition from SymmetricGroupCombinatoricFunctions
--R
--E 1903

--S 1904 of 3320
)d op nextPrime
--R 
--R
--RThere is one exposed function called nextPrime :
--R   [1] D1 -> D1 from IntegerPrimesPackage(D1) if D1 has INS
--R
--RExamples of nextPrime from IntegerPrimesPackage
--R
--E 1904

--S 1905 of 3320
)d op nextPrimitiveNormalPoly
--R 
--R
--RThere is one unexposed function called nextPrimitiveNormalPoly :
--R   [1] SparseUnivariatePolynomial(D2) -> Union(
--R            SparseUnivariatePolynomial(D2),"failed")
--R             from FiniteFieldPolynomialPackage(D2) if D2 has FFIELDC
--R         
--R
--RExamples of nextPrimitiveNormalPoly from FiniteFieldPolynomialPackage
--R
--E 1905

--S 1906 of 3320
)d op nextPrimitivePoly
--R 
--R
--RThere is one unexposed function called nextPrimitivePoly :
--R   [1] SparseUnivariatePolynomial(D2) -> Union(
--R            SparseUnivariatePolynomial(D2),"failed")
--R             from FiniteFieldPolynomialPackage(D2) if D2 has FFIELDC
--R         
--R
--RExamples of nextPrimitivePoly from FiniteFieldPolynomialPackage
--R
--E 1906

--S 1907 of 3320
--R-------------- )d op next_sousResultant2 (fix this)
--E 1907

--S 1908 of 3320
)d op nextSublist
--R 
--R
--RThere is one unexposed function called nextSublist :
--R   [1] (Integer,Integer) -> List(List(Integer))
--R             from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D4
--R             has Join(OrderedSet,ConvertibleTo(Symbol)) and D5 has 
--R            OAMONS and D6 has POLYCAT(D3,D5,D4)
--R
--RExamples of nextSublist from ParametricLinearEquations
--R
--E 1908

--S 1909 of 3320
--R-------------- )d op next_subResultant2 (fix this)
--E 1909

--S 1910 of 3320
)d op nextSubsetGray
--R 
--R
--RThere is one unexposed function called nextSubsetGray :
--R   [1] (Vector(Vector(Integer)),PositiveInteger) -> Vector(Vector(
--R            Integer))
--R             from GrayCode
--R
--RExamples of nextSubsetGray from GrayCode
--R
--E 1910

--S 1911 of 3320
)d op nil
--R 
--R
--RThere is one exposed function called nil :
--R   [1]  -> List(D1) from List(D1) if D1 has TYPE
--R
--RExamples of nil from List
--R
--E 1911

--S 1912 of 3320 done
)d op nilFactor
--R 
--R
--RThere is one exposed function called nilFactor :
--R   [1] (D1,Integer) -> Factored(D1) from Factored(D1) if D1 has INTDOM
--R            
--R
--RExamples of nilFactor from Factored
--R
--RnilFactor(24,2) 
--RnilFactor(x-y,3)
--R
--E 1912

--S 1913 of 3320
)d op nlde
--R 
--R
--RThere is one unexposed function called nlde :
--R   [1] Stream(Stream(D3)) -> Stream(D3) from 
--R            StreamTaylorSeriesOperations(D3)
--R             if D3 has ALGEBRA(FRAC(INT)) and D3 has RING
--R
--RExamples of nlde from StreamTaylorSeriesOperations
--R
--E 1913

--S 1914 of 3320
)d op node
--R 
--R
--RThere is one exposed function called node :
--R   [1] (D,D1,D) -> D from D if D has BTCAT(D1) and D1 has SETCAT
--R
--RExamples of node from BinaryTreeCategory
--R
--E 1914

--S 1915 of 3320
)d op node?
--R 
--R
--RThere is one exposed function called node? :
--R   [1] (D,D) -> Boolean from D if D has RCAGG(D2) and D2 has TYPE and 
--R            D2 has SETCAT
--R
--RExamples of node? from RecursiveAggregate
--R
--E 1915

--S 1916 of 3320
)d op nodeOf?
--R 
--R
--RThere is one unexposed function called nodeOf? :
--R   [1] (SplittingNode(D3,D4),SplittingTree(D3,D4)) -> Boolean
--R             from SplittingTree(D3,D4)
--R             if D3 has Join(SetCategory,Aggregate) and D4 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of nodeOf? from SplittingTree
--R
--E 1916

--S 1917 of 3320
)d op nodes
--R 
--R
--RThere is one exposed function called nodes :
--R   [1] D -> List(D) from D if D2 has TYPE and D has RCAGG(D2)
--R
--RExamples of nodes from RecursiveAggregate
--R
--E 1917

--S 1918 of 3320
)d op noKaratsuba
--R 
--R
--RThere is one exposed function called noKaratsuba :
--R   [1] (D1,D1) -> D1 from UnivariatePolynomialMultiplicationPackage(D2,
--R            D1)
--R             if D2 has RING and D1 has UPOLYC(D2)
--R
--RExamples of noKaratsuba from UnivariatePolynomialMultiplicationPackage
--R
--E 1918

--S 1919 of 3320
)d op noLinearFactor?
--R 
--R
--RThere is one unexposed function called noLinearFactor? :
--R   [1] D2 -> Boolean from BrillhartTests(D2) if D2 has UPOLYC(INT)
--R
--RExamples of noLinearFactor? from BrillhartTests
--R
--E 1919

--S 1920 of 3320
)d op noncommutativeJordanAlgebra?
--R 
--R
--RThere is one exposed function called noncommutativeJordanAlgebra? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called noncommutativeJordanAlgebra? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of noncommutativeJordanAlgebra? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of noncommutativeJordanAlgebra? from FiniteRankNonAssociativeAlgebra
--R
--E 1920

--S 1921 of 3320
)d op nonLinearPart
--R 
--R
--RThere is one exposed function called nonLinearPart :
--R   [1] List(Expression(DoubleFloat)) -> List(Expression(DoubleFloat))
--R             from e04AgentsPackage
--R
--RExamples of nonLinearPart from e04AgentsPackage
--R
--E 1921

--S 1922 of 3320
)d op nonQsign
--R 
--R
--RThere is one unexposed function called nonQsign :
--R   [1] D2 -> Union(Integer,"failed") from ToolsForSign(D2) if D2 has 
--R            RING
--R
--RExamples of nonQsign from ToolsForSign
--R
--E 1922

--S 1923 of 3320
)d op nonSingularModel
--R 
--R
--RThere is one exposed function called nonSingularModel :
--R   [1] Symbol -> List(Polynomial(D3)) from D
--R             if D has FFCAT(D3,D4,D5) and D3 has UFD and D4 has UPOLYC(
--R            D3) and D5 has UPOLYC(FRAC(D4)) and D3 has FIELD
--R
--RThere is one unexposed function called nonSingularModel :
--R   [1] Symbol -> List(Polynomial(D4)) from FunctionFieldCategory&(D3,D4
--R            ,D5,D6)
--R             if D4 has UFD and D5 has UPOLYC(D4) and D6 has UPOLYC(FRAC
--R            (D5)) and D3 has FFCAT(D4,D5,D6)
--R
--RExamples of nonSingularModel from FunctionFieldCategory&
--R
--R
--RExamples of nonSingularModel from FunctionFieldCategory
--R
--E 1923

--S 1924 of 3320
)d op nor
--R 
--R
--RThere are 2 exposed functions called nor :
--R   [1] (Boolean,Boolean) -> Boolean from Boolean
--R   [2] (D,D) -> D from D if D has BTAGG
--R
--RExamples of nor from Boolean
--R
--R
--RExamples of nor from BitAggregate
--R
--E 1924

--S 1925 of 3320
)d op norm
--R 
--R
--RThere are 12 exposed functions called norm :
--R   [1] (AlgebraicNumber,List(Kernel(AlgebraicNumber))) -> 
--R            AlgebraicNumber
--R             from AlgebraicNumber
--R   [2] (AlgebraicNumber,Kernel(AlgebraicNumber)) -> AlgebraicNumber
--R             from AlgebraicNumber
--R   [3] (SparseUnivariatePolynomial(AlgebraicNumber),List(Kernel(
--R            AlgebraicNumber))) -> SparseUnivariatePolynomial(AlgebraicNumber)
--R             from AlgebraicNumber
--R   [4] (SparseUnivariatePolynomial(AlgebraicNumber),Kernel(
--R            AlgebraicNumber)) -> SparseUnivariatePolynomial(AlgebraicNumber)
--R             from AlgebraicNumber
--R   [5] D -> D1 from D if D has COMPCAT(D1) and D1 has COMRING
--R   [6] (D,PositiveInteger) -> D from D
--R             if D has FAXF(D2) and D2 has FIELD and D2 has FINITE
--R   [7] D -> D1 from D if D has FAXF(D1) and D1 has FIELD
--R   [8] D -> D1 from D
--R             if D has FINRALG(D1,D2) and D2 has UPOLYC(D1) and D1 has 
--R            COMRING
--R   [9] D2 -> D1 from NormInMonogenicAlgebra(D3,D1,D4,D2)
--R             if D3 has GCDDOM and D4 has MONOGEN(D3,D1) and D1 has 
--R            UPOLYC(D3) and D2 has UPOLYC(D4)
--R   [10] D -> D1 from D if D has OC(D1) and D1 has COMRING
--R   [11] D -> D1 from D if D has QUATCAT(D1) and D1 has COMRING
--R   [12] D -> D from D if D has RNS
--R
--RThere are 9 unexposed functions called norm :
--R   [1] D2 -> D1 from ComplexRootFindingPackage(D1,D2)
--R             if D1 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D1))
--R   [2] FractionalIdeal(D2,D1,D3,D4) -> D1 from FractionalIdeal(D2,D1,D3
--R            ,D4)
--R             if D3 has UPOLYC(D1) and D1 has QFCAT(D2) and D2 has 
--R            EUCDOM and D4 has Join(FramedAlgebra(D1,D3),RetractableTo(
--R            D1))
--R   [3] FramedModule(D2,D1,D3,D4,D5) -> D1 from FramedModule(D2,D1,D3,D4
--R            ,D5)
--R             if D3 has UPOLYC(D1) and D1 has QFCAT(D2) and D2 has 
--R            EUCDOM and D4 has FRAMALG(D1,D3) and D5: VECTOR(D4)
--R   [4] (D2,PositiveInteger) -> D1
--R             from GaloisGroupFactorizationUtilities(D4,D2,D1)
--R             if D4 has RING and D1 has Join(FloatingPointSystem,
--R            RetractableTo(D4),Field,TranscendentalFunctionCategory,
--R            ElementaryFunctionCategory) and D2 has UPOLYC(D4)
--R   [5] (InnerAlgebraicNumber,List(Kernel(InnerAlgebraicNumber))) -> 
--R            InnerAlgebraicNumber
--R             from InnerAlgebraicNumber
--R   [6] (InnerAlgebraicNumber,Kernel(InnerAlgebraicNumber)) -> 
--R            InnerAlgebraicNumber
--R             from InnerAlgebraicNumber
--R   [7] (SparseUnivariatePolynomial(InnerAlgebraicNumber),List(Kernel(
--R            InnerAlgebraicNumber))) -> SparseUnivariatePolynomial(
--R            InnerAlgebraicNumber)
--R             from InnerAlgebraicNumber
--R   [8] (SparseUnivariatePolynomial(InnerAlgebraicNumber),Kernel(
--R            InnerAlgebraicNumber)) -> SparseUnivariatePolynomial(
--R            InnerAlgebraicNumber)
--R             from InnerAlgebraicNumber
--R   [9] (Vector(D3),PositiveInteger) -> Vector(D3)
--R             from InnerNormalBasisFieldFunctions(D3) if D3 has FFIELDC
--R            
--R
--RExamples of norm from AlgebraicNumber
--R
--R
--RExamples of norm from ComplexCategory
--R
--R
--RExamples of norm from ComplexRootFindingPackage
--R
--R
--RExamples of norm from FiniteAlgebraicExtensionField
--R
--R
--RExamples of norm from FiniteRankAlgebra
--R
--R
--RExamples of norm from FractionalIdeal
--R
--R
--RExamples of norm from FramedModule
--R
--R
--RExamples of norm from GaloisGroupFactorizationUtilities
--R
--R
--RExamples of norm from InnerAlgebraicNumber
--R
--R
--RExamples of norm from InnerNormalBasisFieldFunctions
--R
--R
--RExamples of norm from NormInMonogenicAlgebra
--R
--R
--RExamples of norm from OctonionCategory
--R
--R
--RExamples of norm from QuaternionCategory
--R
--R
--RExamples of norm from RealNumberSystem
--R
--E 1925

--S 1926 of 3320
)d op normal
--R 
--R
--RThere is one unexposed function called normal :
--R   [1] (Float,Float) -> (() -> Float) from RandomFloatDistributions
--R
--RExamples of normal from RandomFloatDistributions
--R
--E 1926

--S 1927 of 3320
)d op normal?
--R 
--R
--RThere is one exposed function called normal? :
--R   [1] D -> Boolean from D if D has FAXF(D2) and D2 has FIELD and D2
--R             has FINITE
--R
--RThere are 2 unexposed functions called normal? :
--R   [1] SparseUnivariatePolynomial(D3) -> Boolean
--R             from FiniteFieldPolynomialPackage(D3) if D3 has FFIELDC
--R         
--R   [2] Vector(D3) -> Boolean from InnerNormalBasisFieldFunctions(D3)
--R             if D3 has FFIELDC
--R
--RExamples of normal? from FiniteAlgebraicExtensionField
--R
--R
--RExamples of normal? from FiniteFieldPolynomialPackage
--R
--R
--RExamples of normal? from InnerNormalBasisFieldFunctions
--R
--E 1927

--S 1928 of 3320
)d op normal01
--R 
--R
--RThere is one unexposed function called normal01 :
--R   [1]  -> Float from RandomFloatDistributions
--R
--RExamples of normal01 from RandomFloatDistributions
--R
--E 1928

--S 1929 of 3320
)d op normalDenom
--R 
--R
--RThere is one unexposed function called normalDenom :
--R   [1] (Fraction(D1),(D1 -> D1)) -> D1 from MonomialExtensionTools(D4,
--R            D1)
--R             if D1 has UPOLYC(D4) and D4 has FIELD
--R
--RExamples of normalDenom from MonomialExtensionTools
--R
--E 1929

--S 1930 of 3320
)d op normalDeriv
--R 
--R
--RThere is one unexposed function called normalDeriv :
--R   [1] (SparseUnivariatePolynomial(D6),Integer) -> 
--R            SparseUnivariatePolynomial(D6)
--R             from FactoringUtilities(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D5,D3,D4) and D3 has OAMONS and D4 has 
--R            ORDSET and D5 has RING
--R
--RExamples of normalDeriv from FactoringUtilities
--R
--E 1930

--S 1931 of 3320
)d op normalElement
--R 
--R
--RThere is one exposed function called normalElement :
--R   [1]  -> D from D if D has FAXF(D1) and D1 has FINITE and D1 has 
--R            FIELD
--R
--RThere is one unexposed function called normalElement :
--R   [1] PositiveInteger -> Vector(D3) from 
--R            InnerNormalBasisFieldFunctions(D3)
--R             if D3 has FFIELDC
--R
--RExamples of normalElement from FiniteAlgebraicExtensionField
--R
--R
--RExamples of normalElement from InnerNormalBasisFieldFunctions
--R
--E 1931

--S 1932 of 3320
)d op normalForm
--R 
--R
--RThere is one exposed function called normalForm :
--R   [1] (D1,List(D1)) -> D1 from GroebnerPackage(D3,D4,D5,D1)
--R             if D1 has POLYCAT(D3,D4,D5) and D3 has FIELD and D3 has 
--R            GCDDOM and D4 has OAMONS and D5 has ORDSET
--R
--RThere is one unexposed function called normalForm :
--R   [1] (Matrix(D5),Automorphism(D5),(D5 -> D5)) -> Record(R: Matrix(D5)
--R            ,A: Matrix(D5),Ainv: Matrix(D5))
--R             from PseudoLinearNormalForm(D5) if D5 has FIELD
--R
--RExamples of normalForm from GroebnerPackage
--R
--R
--RExamples of normalForm from PseudoLinearNormalForm
--R
--E 1932

--S 1933 of 3320
)d op normalise
--R 
--R
--RThere is one exposed function called normalise :
--R   [1] Matrix(Expression(Integer)) -> Matrix(Expression(Integer))
--R             from RadicalEigenPackage
--R
--RExamples of normalise from RadicalEigenPackage
--R
--E 1933

--S 1934 of 3320
)d op normalize
--R 
--R
--RThere are 4 exposed functions called normalize :
--R   [1] D1 -> D1 from ElementaryFunctionStructurePackage(D2,D1)
--R             if D2 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer)) and D1 has Join
--R            (AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D2))
--R   [2] (D1,Symbol) -> D1 from ElementaryFunctionStructurePackage(D3,D1)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer)) and D1 has Join
--R            (AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R   [3] Float -> Float from Float
--R   [4] (D2,D3) -> List(Record(val: D2,tower: D3))
--R             from NormalizationPackage(D4,D5,D6,D2,D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of normalize from ElementaryFunctionStructurePackage
--R
--R
--RExamples of normalize from Float
--R
--R
--RExamples of normalize from NormalizationPackage
--R
--E 1934

--S 1935 of 3320
)d op normalizeAtInfinity
--R 
--R
--RThere is one exposed function called normalizeAtInfinity :
--R   [1] Vector(D) -> Vector(D) from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of normalizeAtInfinity from FunctionFieldCategory
--R
--E 1935

--S 1936 of 3320
)d op normalized?
--R 
--R
--RThere are 4 exposed functions called normalized? :
--R   [1] (D,List(D)) -> Boolean from D
--R             if D has RPOLCAT(D3,D4,D5) and D3 has RING and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [2] (D,D) -> Boolean from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [3] D -> Boolean from D
--R             if D has TSETCAT(D2,D3,D4,D5) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R   [4] (D2,D) -> Boolean from D
--R             if D has TSETCAT(D3,D4,D5,D2) and D3 has INTDOM and D4
--R             has OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R            
--R
--RExamples of normalized? from RecursivePolynomialCategory
--R
--R
--RExamples of normalized? from TriangularSetCategory
--R
--E 1936

--S 1937 of 3320
)d op normalizedAssociate
--R 
--R
--RThere is one exposed function called normalizedAssociate :
--R   [1] (D1,D2) -> D1 from NormalizationPackage(D3,D4,D5,D1,D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D1 has RPOLCAT(D3,D4,D5) and D2 has RSETCAT(D3,D4,D5,D1)
--R         
--R
--RExamples of normalizedAssociate from NormalizationPackage
--R
--E 1937

--S 1938 of 3320
)d op normalizedDivide
--R 
--R
--RThere is one exposed function called normalizedDivide :
--R   [1] (D2,D2) -> Record(quotient: D2,remainder: D2)
--R             from MatrixLinearAlgebraFunctions(D2,D3,D4,D5)
--R             if D2 has EUCDOM and D2 has COMRING and D3 has FLAGG(D2) 
--R            and D4 has FLAGG(D2) and D5 has MATCAT(D2,D3,D4)
--R
--RThere is one unexposed function called normalizedDivide :
--R   [1] (D2,D2) -> Record(quotient: D2,remainder: D2)
--R             from ModularHermitianRowReduction(D2) if D2 has EUCDOM
--R
--RExamples of normalizedDivide from MatrixLinearAlgebraFunctions
--R
--R
--RExamples of normalizedDivide from ModularHermitianRowReduction
--R
--E 1938

--S 1939 of 3320
)d op normalizeIfCan
--R 
--R
--RThere is one unexposed function called normalizeIfCan :
--R   [1] D1 -> D1 from LazardSetSolvingPackage(D2,D3,D4,D5,D6,D1)
--R             if D2 has GCDDOM and D3 has OAMONS and D4 has ORDSET and 
--R            D5 has RPOLCAT(D2,D3,D4) and D6 has RSETCAT(D2,D3,D4,D5) 
--R            and D1 has SFRTCAT(D2,D3,D4,D5)
--R
--RExamples of normalizeIfCan from LazardSetSolvingPackage
--R
--E 1939

--S 1940 of 3320
)d op normDeriv2
--R 
--R
--RThere is one unexposed function called normDeriv2 :
--R   [1] (SparseUnivariatePolynomial(D5),Integer) -> 
--R            SparseUnivariatePolynomial(D5)
--R             from MultivariateSquareFree(D3,D4,D5,D6)
--R             if D5 has EUCDOM and D3 has OAMONS and D4 has ORDSET and 
--R            D6 has POLYCAT(D5,D3,D4)
--R
--RExamples of normDeriv2 from MultivariateSquareFree
--R
--E 1940

--S 1941 of 3320
)d op normFactors
--R 
--R
--RThere is one unexposed function called normFactors :
--R   [1] D2 -> List(D2) from NormRetractPackage(D3,D4,D5,D2,D6)
--R             if D3 has FFIELDC and D4 has FAXF(D3) and D5 has UPOLYC(D4
--R            ) and D2 has UPOLYC(D5) and D6: PI
--R
--RExamples of normFactors from NormRetractPackage
--R
--E 1941

--S 1942 of 3320
)d op normInvertible?
--R 
--R
--RThere is one exposed function called normInvertible? :
--R   [1] (D2,D3) -> List(Record(val: Boolean,tower: D3))
--R             from NormalizationPackage(D4,D5,D6,D2,D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of normInvertible? from NormalizationPackage
--R
--E 1942

--S 1943 of 3320
)d op not
--R 
--R
--RThere are 3 exposed functions called not :
--R   [1] Boolean -> Boolean from Boolean
--R   [2] D -> D from D if D has BTAGG
--R   [3] SingleInteger -> SingleInteger from SingleInteger
--R
--RThere is one unexposed function called not :
--R   [1] OutputForm -> OutputForm from OutputForm
--R
--RExamples of not from Boolean
--R
--R
--RExamples of not from BitAggregate
--R
--R
--RExamples of not from OutputForm
--R
--R
--RExamples of not from SingleInteger
--R
--E 1943

--S 1944 of 3320
)d op Not
--R 
--R
--RThere is one exposed function called Not :
--R   [1] SingleInteger -> SingleInteger from SingleInteger
--R
--RThere is one unexposed function called Not :
--R   [1] IndexedBits(D1) -> IndexedBits(D1) from IndexedBits(D1) if D1: 
--R            INT
--R
--RExamples of Not from IndexedBits
--R
--R
--RExamples of Not from SingleInteger
--R
--E 1944

--S 1945 of 3320
)d op NOT
--R 
--R
--RThere are 2 exposed functions called NOT :
--R   [1] Switch -> Switch from Switch
--R   [2] Union(I: Expression(Integer),F: Expression(Float),CF: Expression
--R            (Complex(Float)),switch: Switch) -> Switch
--R             from Switch
--R
--RExamples of NOT from Switch
--R
--E 1945

--S 1946 of 3320
)d op notelem
--R 
--R
--RThere is one unexposed function called notelem :
--R   [1] IntegrationResult(D2) -> List(Record(integrand: D2,intvar: D2))
--R             from IntegrationResult(D2) if D2 has FIELD
--R
--RExamples of notelem from IntegrationResult
--R
--E 1946

--S 1947 of 3320
)d op npcoef
--R 
--R
--RThere is one unexposed function called npcoef :
--R   [1] (SparseUnivariatePolynomial(D1),List(D6),List(D1)) -> Record(
--R            deter: List(SparseUnivariatePolynomial(D1)),dterm: List(List(
--R            Record(expt: NonNegativeInteger,pcoef: D1))),nfacts: List(D6),
--R            nlead: List(D1))
--R             from NPCoef(D6,D7,D8,D9,D1)
--R             if D6 has UPOLYC(D9) and D7 has OAMONS and D8 has ORDSET 
--R            and D9 has EUCDOM and D1 has POLYCAT(D9,D7,D8)
--R
--RExamples of npcoef from NPCoef
--R
--E 1947

--S 1948 of 3320
)d op nrows
--R 
--R
--RThere are 3 exposed functions called nrows :
--R   [1] D -> NonNegativeInteger from D
--R             if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has 
--R            FLAGG(D2) and D4 has FLAGG(D2)
--R   [2] D -> NonNegativeInteger from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R   [3] SparseEchelonMatrix(D2,D3) -> NonNegativeInteger
--R             from SparseEchelonMatrix(D2,D3) if D2 has ORDSET and D3
--R             has RING
--R
--RExamples of nrows from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rnrows(arr)
--R
--R
--RExamples of nrows from RectangularMatrixCategory
--R
--R
--RExamples of nrows from SparseEchelonMatrix
--R
--E 1948

--S 1949 of 3320
)d op nsqfree
--R 
--R
--RThere is one unexposed function called nsqfree :
--R   [1] (SparseUnivariatePolynomial(D8),List(D6),List(List(D7))) -> 
--R            Record(unitPart: D8,suPart: List(Record(factor: 
--R            SparseUnivariatePolynomial(D8),exponent: Integer)))
--R             from MultivariateSquareFree(D5,D6,D7,D8)
--R             if D6 has ORDSET and D7 has EUCDOM and D5 has OAMONS and 
--R            D8 has POLYCAT(D7,D5,D6)
--R
--RExamples of nsqfree from MultivariateSquareFree
--R
--E 1949

--S 1950 of 3320
)d op nthCoef
--R 
--R
--RThere is one exposed function called nthCoef :
--R   [1] (D,Integer) -> D1 from D
--R             if D has FAMONC(D3,D1) and D3 has SETCAT and D1 has CABMON
--R            
--R
--RExamples of nthCoef from FreeAbelianMonoidCategory
--R
--E 1950

--S 1951 of 3320
)d op nthExpon
--R 
--R
--RThere are 4 unexposed functions called nthExpon :
--R   [1] (FreeGroup(D2),Integer) -> Integer from FreeGroup(D2) if D2 has 
--R            SETCAT
--R   [2] (FreeMonoid(D3),Integer) -> NonNegativeInteger from FreeMonoid(
--R            D3)
--R             if D3 has SETCAT
--R   [3] (ListMonoidOps(D3,D1,D4),Integer) -> D1 from ListMonoidOps(D3,D1
--R            ,D4)
--R             if D1 has ABELMON and D3 has SETCAT and D4: D1
--R   [4] (OrderedFreeMonoid(D3),Integer) -> NonNegativeInteger
--R             from OrderedFreeMonoid(D3) if D3 has ORDSET
--R
--RExamples of nthExpon from FreeGroup
--R
--R
--RExamples of nthExpon from FreeMonoid
--R
--R
--RExamples of nthExpon from ListMonoidOps
--R
--R
--RExamples of nthExpon from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--RnthExpon(m1,2)
--R
--E 1951

--S 1952 of 3320 done
)d op nthExponent
--R 
--R
--RThere is one exposed function called nthExponent :
--R   [1] (Factored(D2),Integer) -> Integer from Factored(D2) if D2 has 
--R            INTDOM
--R
--RExamples of nthExponent from Factored
--R
--Ra:=factor 9720000 
--RnthExponent(a,2)
--R
--E 1952

--S 1953 of 3320
)d op nthFactor
--R 
--R
--RThere are 2 exposed functions called nthFactor :
--R   [1] (D,Integer) -> D1 from D
--R             if D has FAMONC(D1,D3) and D3 has CABMON and D1 has SETCAT
--R            
--R   [2] (Factored(D1),Integer) -> D1 from Factored(D1) if D1 has INTDOM
--R            
--R
--RThere are 4 unexposed functions called nthFactor :
--R   [1] (FreeGroup(D1),Integer) -> D1 from FreeGroup(D1) if D1 has 
--R            SETCAT
--R   [2] (FreeMonoid(D1),Integer) -> D1 from FreeMonoid(D1) if D1 has 
--R            SETCAT
--R   [3] (ListMonoidOps(D1,D3,D4),Integer) -> D1 from ListMonoidOps(D1,D3
--R            ,D4)
--R             if D1 has SETCAT and D3 has ABELMON and D4: D3
--R   [4] (OrderedFreeMonoid(D1),Integer) -> D1 from OrderedFreeMonoid(D1)
--R             if D1 has ORDSET
--R
--RExamples of nthFactor from FreeAbelianMonoidCategory
--R
--R
--RExamples of nthFactor from FreeGroup
--R
--R
--RExamples of nthFactor from FreeMonoid
--R
--R
--RExamples of nthFactor from Factored
--R
--Ra:=factor 9720000 
--RnthFactor(a,2)
--R
--R
--RExamples of nthFactor from ListMonoidOps
--R
--R
--RExamples of nthFactor from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--RnthFactor(m1,2)
--R
--E 1953

--S 1954 of 3320 done
)d op nthFlag
--R 
--R
--RThere is one exposed function called nthFlag :
--R   [1] (Factored(D3),Integer) -> Union("nil","sqfr","irred","prime")
--R             from Factored(D3) if D3 has INTDOM
--R
--RExamples of nthFlag from Factored
--R
--Ra:=factor 9720000 
--RnthFlag(a,2)
--R
--E 1954

--S 1955 of 3320 done
)d op nthFractionalTerm
--R 
--R
--RThere is one exposed function called nthFractionalTerm :
--R   [1] (PartialFraction(D2),Integer) -> PartialFraction(D2)
--R             from PartialFraction(D2) if D2 has EUCDOM
--R
--RExamples of nthFractionalTerm from PartialFraction
--R
--Ra:=partialFraction(1,factorial 10) 
--Rb:=padicFraction(a) 
--RnthFractionalTerm(b,3)
--R
--E 1955

--S 1956 of 3320
)d op nthr
--R 
--R
--RThere is one unexposed function called nthr :
--R   [1] (D2,NonNegativeInteger) -> Record(exponent: NonNegativeInteger,
--R            coef: D2,radicand: List(D2))
--R             from PolynomialRoots(D4,D5,D6,D2,D7)
--R             if D4 has OAMONS and D5 has ORDSET and D6 has INTDOM and 
--R            D2 has POLYCAT(D6,D4,D5) and D7 has Fieldwith
--R               numer : % -> D2
--R               denom : % -> D2
--R               coerce : D2 -> %
--R
--RExamples of nthr from PolynomialRoots
--R
--E 1956

--S 1957 of 3320
)d op nthRoot
--R 
--R
--RThere is one exposed function called nthRoot :
--R   [1] (D,Integer) -> D from D if D has RADCAT
--R
--RThere is one unexposed function called nthRoot :
--R   [1] (Factored(D4),NonNegativeInteger) -> Record(exponent: 
--R            NonNegativeInteger,coef: D4,radicand: List(D4))
--R             from FactoredFunctions(D4) if D4 has INTDOM
--R
--RExamples of nthRoot from FactoredFunctions
--R
--R
--RExamples of nthRoot from RadicalCategory
--R
--E 1957

--S 1958 of 3320
)d op nthRootIfCan
--R 
--R
--RThere is one exposed function called nthRootIfCan :
--R   [1] (D1,NonNegativeInteger) -> Union(D1,"failed") from D
--R             if D has PTRANFN(D1) and D1 has TRANFUN
--R
--RExamples of nthRootIfCan from PartialTranscendentalFunctions
--R
--E 1958

--S 1959 of 3320
)d op Nul
--R 
--R
--RThere is one unexposed function called Nul :
--R   [1] NonNegativeInteger -> ExtAlgBasis from ExtAlgBasis
--R
--RExamples of Nul from ExtAlgBasis
--R
--E 1959

--S 1960 of 3320
)d op null
--R 
--R
--RThere is one exposed function called null :
--R   [1] List(D2) -> Boolean from List(D2) if D2 has TYPE
--R
--RExamples of null from List
--R
--E 1960

--S 1961 of 3320
)d op null?
--R 
--R
--RThere is one exposed function called null? :
--R   [1] D -> Boolean from D
--R             if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R
--RExamples of null? from SExpressionCategory
--R
--E 1961

--S 1962 of 3320
)d op nullary
--R 
--R
--RThere is one exposed function called nullary :
--R   [1] D2 -> (() -> D2) from MappingPackage1(D2) if D2 has SETCAT
--R
--RExamples of nullary from MappingPackage1
--R
--E 1962

--S 1963 of 3320
)d op nullary?
--R 
--R
--RThere is one exposed function called nullary? :
--R   [1] BasicOperator -> Boolean from BasicOperator
--R
--RExamples of nullary? from BasicOperator
--R
--E 1963

--S 1964 of 3320
)d op nullity
--R 
--R
--RThere are 3 exposed functions called nullity :
--R   [1] D -> NonNegativeInteger from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2) and D2 has INTDOM
--R   [2] D2 -> NonNegativeInteger from MatrixLinearAlgebraFunctions(D3,D4
--R            ,D5,D2)
--R             if D3 has INTDOM and D3 has COMRING and D4 has FLAGG(D3) 
--R            and D5 has FLAGG(D3) and D2 has MATCAT(D3,D4,D5)
--R   [3] D -> NonNegativeInteger from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4) and D4 has 
--R            INTDOM
--R
--RThere is one unexposed function called nullity :
--R   [1] D2 -> NonNegativeInteger
--R             from InnerMatrixLinearAlgebraFunctions(D3,D4,D5,D2)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D2 has MATCAT(D3,D4,D5)
--R
--RExamples of nullity from InnerMatrixLinearAlgebraFunctions
--R
--R
--RExamples of nullity from MatrixCategory
--R
--Rnullity matrix [[1,2,3],[4,5,6],[7,8,9]]
--R
--R
--RExamples of nullity from MatrixLinearAlgebraFunctions
--R
--R
--RExamples of nullity from RectangularMatrixCategory
--R
--E 1964

--S 1965 of 3320
)d op nullSpace
--R 
--R
--RThere are 3 exposed functions called nullSpace :
--R   [1] D -> List(D4) from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2) and D2 has INTDOM
--R   [2] D2 -> List(D5) from MatrixLinearAlgebraFunctions(D3,D4,D5,D2)
--R             if D3 has INTDOM and D3 has COMRING and D4 has FLAGG(D3) 
--R            and D5 has FLAGG(D3) and D2 has MATCAT(D3,D4,D5)
--R   [3] D -> List(D6) from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4) and D4 has 
--R            INTDOM
--R
--RThere are 2 unexposed functions called nullSpace :
--R   [1] D2 -> List(D5) from InnerMatrixLinearAlgebraFunctions(D3,D4,D5,
--R            D2)
--R             if D5 has shallowlyMutable and D3 has FIELD and D4 has 
--R            FLAGG(D3) and D5 has FLAGG(D3) and D2 has MATCAT(D3,D4,D5)
--R            
--R   [2] D3 -> List(D6)
--R             from InnerMatrixQuotientFieldFunctions(D4,D5,D6,D3,D7,D8,
--R            D9,D1)
--R             if D9 has shallowlyMutable and D4 has INTDOM and D5 has 
--R            FLAGG(D4) and D6 has FLAGG(D4) and D7 has QFCAT(D4) and D8
--R             has FLAGG(D7) and D9 has FLAGG(D7) and D3 has MATCAT(D4,D5
--R            ,D6) and D1 has MATCAT(D7,D8,D9)
--R
--RExamples of nullSpace from InnerMatrixLinearAlgebraFunctions
--R
--R
--RExamples of nullSpace from InnerMatrixQuotientFieldFunctions
--R
--R
--RExamples of nullSpace from MatrixCategory
--R
--RnullSpace matrix [[1,2,3],[4,5,6],[7,8,9]]
--R
--R
--RExamples of nullSpace from MatrixLinearAlgebraFunctions
--R
--R
--RExamples of nullSpace from RectangularMatrixCategory
--R
--E 1965

--S 1966 of 3320
)d op number?
--R 
--R
--RThere is one exposed function called number? :
--R   [1] Expression(D2) -> Boolean from Expression(D2)
--R             if D2 has INTDOM and D2 has ORDSET
--R
--RExamples of number? from Expression
--R
--E 1966

--S 1967 of 3320
)d op numberOfChildren
--R 
--R
--RThere is one unexposed function called numberOfChildren :
--R   [1] SubSpace(D2,D3) -> NonNegativeInteger from SubSpace(D2,D3)
--R             if D2: PI and D3 has RING
--R
--RExamples of numberOfChildren from SubSpace
--R
--E 1967

--S 1968 of 3320
)d op numberOfComponents
--R 
--R
--RThere are 2 exposed functions called numberOfComponents :
--R   [1]  -> NonNegativeInteger from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R   [2] D -> NonNegativeInteger from D if D has SPACEC(D2) and D2 has 
--R            RING
--R
--RThere is one unexposed function called numberOfComponents :
--R   [1]  -> NonNegativeInteger from FunctionFieldCategory&(D2,D3,D4,D5)
--R             if D3 has UFD and D4 has UPOLYC(D3) and D5 has UPOLYC(FRAC
--R            (D4)) and D2 has FFCAT(D3,D4,D5)
--R
--RExamples of numberOfComponents from FunctionFieldCategory&
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RnumberOfComponents()$R
--R
--R
--RExamples of numberOfComponents from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RnumberOfComponents()$R
--R
--R
--RExamples of numberOfComponents from ThreeSpaceCategory
--R
--E 1968

--S 1969 of 3320
)d op numberOfComposites
--R 
--R
--RThere is one exposed function called numberOfComposites :
--R   [1] D -> NonNegativeInteger from D if D has SPACEC(D2) and D2 has 
--R            RING
--R
--RExamples of numberOfComposites from ThreeSpaceCategory
--R
--E 1969

--S 1970 of 3320 done
)d op numberOfComputedEntries
--R 
--R
--RThere is one exposed function called numberOfComputedEntries :
--R   [1] D -> NonNegativeInteger from D if D has LZSTAGG(D2) and D2 has 
--R            TYPE
--R
--RExamples of numberOfComputedEntries from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--RnumberOfComputedEntries m
--R
--E 1970

--S 1971 of 3320
)d op numberOfCycles
--R 
--R
--RThere is one exposed function called numberOfCycles :
--R   [1] Permutation(D2) -> NonNegativeInteger from Permutation(D2) if D2
--R             has SETCAT
--R
--RExamples of numberOfCycles from Permutation
--R
--E 1971

--S 1972 of 3320
)d op numberOfDivisors
--R 
--R
--RThere is one exposed function called numberOfDivisors :
--R   [1] Integer -> Integer from IntegerNumberTheoryFunctions
--R
--RExamples of numberOfDivisors from IntegerNumberTheoryFunctions
--R
--E 1972

--S 1973 of 3320
)d op numberOfFactors
--R 
--R
--RThere is one exposed function called numberOfFactors :
--R   [1] Factored(D2) -> NonNegativeInteger from Factored(D2) if D2 has 
--R            INTDOM
--R
--RThere is one unexposed function called numberOfFactors :
--R   [1] List(Record(factor: D3,degree: Integer)) -> NonNegativeInteger
--R             from GaloisGroupFactorizer(D3) if D3 has UPOLYC(INT)
--R
--RExamples of numberOfFactors from Factored
--R
--Ra:=factor 9720000 
--RnumberOfFactors a
--R
--R
--RExamples of numberOfFactors from GaloisGroupFactorizer
--R
--E 1973

--S 1974 of 3320 done
)d op numberOfFractionalTerms
--R 
--R
--RThere is one exposed function called numberOfFractionalTerms :
--R   [1] PartialFraction(D2) -> Integer from PartialFraction(D2) if D2
--R             has EUCDOM
--R
--RExamples of numberOfFractionalTerms from PartialFraction
--R
--Ra:=partialFraction(1,factorial 10) 
--Rb:=padicFraction(a) 
--RnumberOfFractionalTerms(b)
--R
--E 1974

--S 1975 of 3320
)d op numberOfHues
--R 
--R
--RThere is one exposed function called numberOfHues :
--R   [1]  -> PositiveInteger from Color
--R
--RExamples of numberOfHues from Color
--R
--E 1975

--S 1976 of 3320
)d op numberOfImproperPartitions
--R 
--R
--RThere is one exposed function called numberOfImproperPartitions :
--R   [1] (Integer,Integer) -> Integer from 
--R            SymmetricGroupCombinatoricFunctions
--R
--RExamples of numberOfImproperPartitions from SymmetricGroupCombinatoricFunctions
--R
--E 1976

--S 1977 of 3320
)d op numberOfIrreduciblePoly
--R 
--R
--RThere is one unexposed function called numberOfIrreduciblePoly :
--R   [1] PositiveInteger -> PositiveInteger from 
--R            FiniteFieldPolynomialPackage(D2)
--R             if D2 has FFIELDC
--R
--RExamples of numberOfIrreduciblePoly from FiniteFieldPolynomialPackage
--R
--E 1977

--S 1978 of 3320
)d op numberOfMonomials
--R 
--R
--RThere are 2 exposed functions called numberOfMonomials :
--R   [1] D -> NonNegativeInteger from D
--R             if D has FAMR(D2,D3) and D2 has RING and D3 has OAMON
--R   [2] D -> NonNegativeInteger from D
--R             if D has FMCAT(D2,D3) and D2 has RING and D3 has SETCAT
--R         
--R
--RThere is one unexposed function called numberOfMonomials :
--R   [1] MonoidRing(D2,D3) -> NonNegativeInteger from MonoidRing(D2,D3)
--R             if D2 has RING and D3 has MONOID
--R
--RExamples of numberOfMonomials from FiniteAbelianMonoidRing
--R
--R
--RExamples of numberOfMonomials from FreeModuleCat
--R
--R
--RExamples of numberOfMonomials from MonoidRing
--R
--E 1978

--S 1979 of 3320
)d op numberOfNormalPoly
--R 
--R
--RThere is one unexposed function called numberOfNormalPoly :
--R   [1] PositiveInteger -> PositiveInteger from 
--R            FiniteFieldPolynomialPackage(D2)
--R             if D2 has FFIELDC
--R
--RExamples of numberOfNormalPoly from FiniteFieldPolynomialPackage
--R
--E 1979

--S 1980 of 3320
)d op numberOfOperations
--R 
--R
--RThere is one exposed function called numberOfOperations :
--R   [1] Vector(Expression(DoubleFloat)) -> Record(additions: Integer,
--R            multiplications: Integer,exponentiations: Integer,functionCalls: 
--R            Integer)
--R             from ExpertSystemToolsPackage
--R
--RExamples of numberOfOperations from ExpertSystemToolsPackage
--R
--E 1980

--S 1981 of 3320
)d op numberOfPlacesOfDegree
--R 
--R
--RThere are 3 exposed functions called numberOfPlacesOfDegree :
--R   [1] PositiveInteger -> Integer
--R             from GeneralPackageForAlgebraicFunctionField(D8,D9,D10,D11
--R            ,D12,D13,D1,D2,D3,D4,D5)
--R             if D8 has FINITE and D8 has FIELD and D9: LIST(SYMBOL) and
--R            D10 has POLYCAT(D8,D11,OVAR(D9)) and D11 has DIRPCAT(#(D9),
--R            NNI) and D12 has PRSPCAT(D8) and D13 has LOCPOWC(D8) and D1
--R             has PLACESC(D8,D13) and D2 has DIVCAT(D1) and D3 has 
--R            INFCLCT(D8,D9,D10,D11,D12,D13,D1,D2,D5) and D5 has BLMETCT 
--R            and D4 has DSTRCAT(D3)
--R   [2] PositiveInteger -> Integer
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D3,D4
--R            ,D5)
--R             if PseudoAlgebraicClosureOfFiniteField(D3) has FINITE and 
--R            D3 has FFIELDC and D4: LIST(SYMBOL) and D5 has BLMETCT
--R   [3] PositiveInteger -> Integer
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FINITE and D3 has FIELD and D4: LIST(SYMBOL) and
--R            D5 has BLMETCT
--R
--RExamples of numberOfPlacesOfDegree from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of numberOfPlacesOfDegree from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of numberOfPlacesOfDegree from PackageForAlgebraicFunctionField
--R
--E 1981

--S 1982 of 3320
)d op numberOfPrimitivePoly
--R 
--R
--RThere is one unexposed function called numberOfPrimitivePoly :
--R   [1] PositiveInteger -> PositiveInteger from 
--R            FiniteFieldPolynomialPackage(D2)
--R             if D2 has FFIELDC
--R
--RExamples of numberOfPrimitivePoly from FiniteFieldPolynomialPackage
--R
--E 1982

--S 1983 of 3320
)d op numberOfValuesNeeded
--R 
--R
--RThere is one exposed function called numberOfValuesNeeded :
--R   [1] (Integer,BasicOperator,Symbol,D4) -> Integer
--R             from RecurrenceOperator(D5,D4)
--R             if D5 has Join(OrderedSet,IntegralDomain,ConvertibleTo(
--R            InputForm)) and D4 has Join(FunctionSpace(D5),AbelianMonoid
--R            ,RetractableTo(Integer),RetractableTo(Symbol),
--R            PartialDifferentialRing(Symbol),CombinatorialOpsCategory)
--R         
--R
--RExamples of numberOfValuesNeeded from RecurrenceOperator
--R
--E 1983

--S 1984 of 3320
)d op numberOfVariables
--R 
--R
--RThere are 2 exposed functions called numberOfVariables :
--R   [1] (List(D7),List(D8)) -> NonNegativeInteger
--R             from RegularSetDecompositionPackage(D4,D5,D6,D7,D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has RSETCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R   [2] (List(D7),List(D8)) -> NonNegativeInteger
--R             from SquareFreeRegularSetDecompositionPackage(D4,D5,D6,D7,
--R            D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has SFRTCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R
--RExamples of numberOfVariables from RegularSetDecompositionPackage
--R
--R
--RExamples of numberOfVariables from SquareFreeRegularSetDecompositionPackage
--R
--E 1984

--S 1985 of 3320
)d op numberPlacesDegExtDeg
--R 
--R
--RThere are 3 exposed functions called numberPlacesDegExtDeg :
--R   [1] (PositiveInteger,PositiveInteger) -> Integer
--R             from GeneralPackageForAlgebraicFunctionField(D8,D9,D10,D11
--R            ,D12,D13,D1,D2,D3,D4,D5)
--R             if D8 has FINITE and D8 has FIELD and D9: LIST(SYMBOL) and
--R            D10 has POLYCAT(D8,D11,OVAR(D9)) and D11 has DIRPCAT(#(D9),
--R            NNI) and D12 has PRSPCAT(D8) and D13 has LOCPOWC(D8) and D1
--R             has PLACESC(D8,D13) and D2 has DIVCAT(D1) and D3 has 
--R            INFCLCT(D8,D9,D10,D11,D12,D13,D1,D2,D5) and D5 has BLMETCT 
--R            and D4 has DSTRCAT(D3)
--R   [2] (PositiveInteger,PositiveInteger) -> Integer
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D3,D4
--R            ,D5)
--R             if PseudoAlgebraicClosureOfFiniteField(D3) has FINITE and 
--R            D3 has FFIELDC and D4: LIST(SYMBOL) and D5 has BLMETCT
--R   [3] (PositiveInteger,PositiveInteger) -> Integer
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FINITE and D3 has FIELD and D4: LIST(SYMBOL) and
--R            D5 has BLMETCT
--R
--RExamples of numberPlacesDegExtDeg from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of numberPlacesDegExtDeg from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of numberPlacesDegExtDeg from PackageForAlgebraicFunctionField
--R
--E 1985

--S 1986 of 3320
)d op numberRatPlacesExtDeg
--R 
--R
--RThere are 3 exposed functions called numberRatPlacesExtDeg :
--R   [1] PositiveInteger -> Integer
--R             from GeneralPackageForAlgebraicFunctionField(D8,D9,D10,D11
--R            ,D12,D13,D1,D2,D3,D4,D5)
--R             if D8 has FINITE and D8 has FIELD and D9: LIST(SYMBOL) and
--R            D10 has POLYCAT(D8,D11,OVAR(D9)) and D11 has DIRPCAT(#(D9),
--R            NNI) and D12 has PRSPCAT(D8) and D13 has LOCPOWC(D8) and D1
--R             has PLACESC(D8,D13) and D2 has DIVCAT(D1) and D3 has 
--R            INFCLCT(D8,D9,D10,D11,D12,D13,D1,D2,D5) and D5 has BLMETCT 
--R            and D4 has DSTRCAT(D3)
--R   [2] PositiveInteger -> Integer
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D3,D4
--R            ,D5)
--R             if PseudoAlgebraicClosureOfFiniteField(D3) has FINITE and 
--R            D3 has FFIELDC and D4: LIST(SYMBOL) and D5 has BLMETCT
--R   [3] PositiveInteger -> Integer
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FINITE and D3 has FIELD and D4: LIST(SYMBOL) and
--R            D5 has BLMETCT
--R
--RExamples of numberRatPlacesExtDeg from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of numberRatPlacesExtDeg from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of numberRatPlacesExtDeg from PackageForAlgebraicFunctionField
--R
--E 1986

--S 1987 of 3320
)d op numer
--R 
--R
--RThere are 3 exposed functions called numer :
--R   [1] AlgebraicNumber -> SparseMultivariatePolynomial(Integer,Kernel(
--R            AlgebraicNumber))
--R             from AlgebraicNumber
--R   [2] D -> SparseMultivariatePolynomial(D2,Kernel(D)) from D
--R             if D2 has RING and D2 has ORDSET and D has FS(D2)
--R   [3] D -> D1 from D if D has QFCAT(D1) and D1 has INTDOM
--R
--RThere are 4 unexposed functions called numer :
--R   [1] FractionalIdeal(D2,D3,D4,D5) -> Vector(D5)
--R             from FractionalIdeal(D2,D3,D4,D5)
--R             if D2 has EUCDOM and D3 has QFCAT(D2) and D4 has UPOLYC(D3
--R            ) and D5 has Join(FramedAlgebra(D3,D4),RetractableTo(D3))
--R         
--R   [2] InnerAlgebraicNumber -> SparseMultivariatePolynomial(Integer,
--R            Kernel(InnerAlgebraicNumber))
--R             from InnerAlgebraicNumber
--R   [3] LocalAlgebra(D1,D2,D3) -> D1 from LocalAlgebra(D1,D2,D3)
--R             if D2 has COMRING and D1 has ALGEBRA(D2) and D3 has 
--R            SubsetCategory(Monoid,D2)
--R   [4] Localize(D1,D2,D3) -> D1 from Localize(D1,D2,D3)
--R             if D2 has COMRING and D1 has MODULE(D2) and D3 has 
--R            SubsetCategory(Monoid,D2)
--R
--RExamples of numer from AlgebraicNumber
--R
--Rt1:=sqrt(3)/sqrt(5) 
--Rnumer t1
--R
--R
--RExamples of numer from FractionalIdeal
--R
--R
--RExamples of numer from FunctionSpace
--R
--R
--RExamples of numer from InnerAlgebraicNumber
--R
--R
--RExamples of numer from LocalAlgebra
--R
--R
--RExamples of numer from Localize
--R
--R
--RExamples of numer from QuotientFieldCategory
--R
--E 1987

--S 1988 of 3320
)d op numerator
--R 
--R
--RThere are 3 exposed functions called numerator :
--R   [1] D -> D from D if D has FS(D1) and D1 has ORDSET and D1 has RING
--R            
--R   [2] MyExpression(D1,D2) -> MyExpression(D1,D2) from MyExpression(D1,
--R            D2)
--R             if D1: SYMBOL and D2 has Join(Ring,OrderedSet,
--R            IntegralDomain)
--R   [3] D -> D from D if D has QFCAT(D1) and D1 has INTDOM
--R
--RExamples of numerator from FunctionSpace
--R
--R
--RExamples of numerator from MyExpression
--R
--R
--RExamples of numerator from QuotientFieldCategory
--R
--E 1988

--S 1989 of 3320
)d op numerators
--R 
--R
--RThere is one exposed function called numerators :
--R   [1] ContinuedFraction(D2) -> Stream(D2) from ContinuedFraction(D2)
--R             if D2 has EUCDOM
--R
--RExamples of numerators from ContinuedFraction
--R
--E 1989

--S 1990 of 3320
)d op numeric
--R 
--R
--RThere are 8 exposed functions called numeric :
--R   [1] D2 -> Float from Numeric(D2) if D2 has KONVERT(FLOAT)
--R   [2] (D2,PositiveInteger) -> Float from Numeric(D2) if D2 has KONVERT
--R            (FLOAT)
--R   [3] Polynomial(D3) -> Float from Numeric(D3)
--R             if D3 has RING and D3 has KONVERT(FLOAT)
--R   [4] (Polynomial(D4),PositiveInteger) -> Float from Numeric(D4)
--R             if D4 has RING and D4 has KONVERT(FLOAT)
--R   [5] Fraction(Polynomial(D3)) -> Float from Numeric(D3)
--R             if D3 has INTDOM and D3 has KONVERT(FLOAT)
--R   [6] (Fraction(Polynomial(D4)),PositiveInteger) -> Float from Numeric
--R            (D4)
--R             if D4 has INTDOM and D4 has KONVERT(FLOAT)
--R   [7] Expression(D3) -> Float from Numeric(D3)
--R             if D3 has INTDOM and D3 has ORDSET and D3 has KONVERT(
--R            FLOAT)
--R   [8] (Expression(D4),PositiveInteger) -> Float from Numeric(D4)
--R             if D4 has INTDOM and D4 has ORDSET and D4 has KONVERT(
--R            FLOAT)
--R
--RExamples of numeric from Numeric
--R
--E 1990

--S 1991 of 3320
)d op numericalIntegration
--R 
--R
--RThere are 2 exposed functions called numericalIntegration :
--R   [1] (Record(fn: Expression(DoubleFloat),range: List(Segment(
--R            OrderedCompletion(DoubleFloat))),abserr: DoubleFloat,relerr: 
--R            DoubleFloat),Result) -> Result
--R             from D if D has NUMINT
--R   [2] (Record(var: Symbol,fn: Expression(DoubleFloat),range: Segment(
--R            OrderedCompletion(DoubleFloat)),abserr: DoubleFloat,relerr: 
--R            DoubleFloat),Result) -> Result
--R             from D if D has NUMINT
--R
--RExamples of numericalIntegration from NumericalIntegrationCategory
--R
--E 1991

--S 1992 of 3320
)d op numericalOptimization
--R 
--R
--RThere are 2 exposed functions called numericalOptimization :
--R   [1] Record(fn: Expression(DoubleFloat),init: List(DoubleFloat),lb: 
--R            List(OrderedCompletion(DoubleFloat)),cf: List(Expression(
--R            DoubleFloat)),ub: List(OrderedCompletion(DoubleFloat))) -> Result
--R             from D if D has OPTCAT
--R   [2] Record(lfn: List(Expression(DoubleFloat)),init: List(DoubleFloat
--R            )) -> Result
--R             from D if D has OPTCAT
--R
--RExamples of numericalOptimization from NumericalOptimizationCategory
--R
--E 1992

--S 1993 of 3320
)d op numericIfCan
--R 
--R
--RThere are 6 exposed functions called numericIfCan :
--R   [1] Polynomial(D3) -> Union(Float,"failed") from Numeric(D3)
--R             if D3 has RING and D3 has KONVERT(FLOAT)
--R   [2] (Polynomial(D4),PositiveInteger) -> Union(Float,"failed")
--R             from Numeric(D4) if D4 has RING and D4 has KONVERT(FLOAT)
--R            
--R   [3] Fraction(Polynomial(D3)) -> Union(Float,"failed") from Numeric(
--R            D3)
--R             if D3 has INTDOM and D3 has KONVERT(FLOAT)
--R   [4] (Fraction(Polynomial(D4)),PositiveInteger) -> Union(Float,
--R            "failed")
--R             from Numeric(D4) if D4 has INTDOM and D4 has KONVERT(FLOAT
--R            )
--R   [5] Expression(D3) -> Union(Float,"failed") from Numeric(D3)
--R             if D3 has INTDOM and D3 has ORDSET and D3 has KONVERT(
--R            FLOAT)
--R   [6] (Expression(D4),PositiveInteger) -> Union(Float,"failed")
--R             from Numeric(D4)
--R             if D4 has INTDOM and D4 has ORDSET and D4 has KONVERT(
--R            FLOAT)
--R
--RExamples of numericIfCan from Numeric
--R
--E 1993

--S 1994 of 3320
)d op numFunEvals
--R 
--R
--RThere is one unexposed function called numFunEvals :
--R   [1]  -> Integer from Plot
--R
--RExamples of numFunEvals from Plot
--R
--E 1994

--S 1995 of 3320
)d op numFunEvals3D
--R 
--R
--RThere is one unexposed function called numFunEvals3D :
--R   [1]  -> Integer from Plot3D
--R
--RExamples of numFunEvals3D from Plot3D
--R
--E 1995

--S 1996 of 3320
)d op obj
--R 
--R
--RThere is one exposed function called obj :
--R   [1] Any -> None from Any
--R
--RExamples of obj from Any
--R
--E 1996

--S 1997 of 3320
)d op objectOf
--R 
--R
--RThere is one exposed function called objectOf :
--R   [1] Any -> OutputForm from Any
--R
--RExamples of objectOf from Any
--R
--E 1997

--S 1998 of 3320
)d op objects
--R 
--R
--RThere is one exposed function called objects :
--R   [1] D -> Record(points: NonNegativeInteger,curves: 
--R            NonNegativeInteger,polygons: NonNegativeInteger,constructs: 
--R            NonNegativeInteger)
--R             from D if D has SPACEC(D2) and D2 has RING
--R
--RExamples of objects from ThreeSpaceCategory
--R
--E 1998

--S 1999 of 3320
)d op oblateSpheroidal
--R 
--R
--RThere is one exposed function called oblateSpheroidal :
--R   [1] D2 -> (Point(D2) -> Point(D2)) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of oblateSpheroidal from CoordinateSystems
--R
--E 1999

--S 2000 of 3320
)d op ocf2ocdf
--R 
--R
--RThere is one exposed function called ocf2ocdf :
--R   [1] OrderedCompletion(Float) -> OrderedCompletion(DoubleFloat)
--R             from ExpertSystemToolsPackage
--R
--RExamples of ocf2ocdf from ExpertSystemToolsPackage
--R
--E 2000

--S 2001 of 3320
)d op octon
--R 
--R
--RThere are 2 exposed functions called octon :
--R   [1] (D1,D1,D1,D1,D1,D1,D1,D1) -> D from D if D has OC(D1) and D1
--R             has COMRING
--R   [2] (Quaternion(D2),Quaternion(D2)) -> Octonion(D2) from Octonion(D2
--R            )
--R             if D2 has COMRING
--R
--RExamples of octon from OctonionCategory
--R
--R
--RExamples of octon from Octonion
--R
--E 2001

--S 2002 of 3320
)d op odd?
--R 
--R
--RThere are 3 exposed functions called odd? :
--R   [1] D -> Boolean from D if D has RETRACT(INT) and D has ES
--R   [2] D -> Boolean from D if D has INS
--R   [3] Permutation(D2) -> Boolean from Permutation(D2) if D2 has SETCAT
--R            
--R
--RExamples of odd? from RetractableTo
--R
--R
--RExamples of odd? from IntegerNumberSystem
--R
--R
--RExamples of odd? from Permutation
--R
--E 2002

--S 2003 of 3320
)d op oddInfiniteProduct
--R 
--R
--RThere are 3 exposed functions called oddInfiniteProduct :
--R   [1] D1 -> D1 from InfiniteProductCharacteristicZero(D2,D1)
--R             if D2 has Join(IntegralDomain,CharacteristicZero) and D1
--R             has UTSCAT(D2)
--R   [2] D1 -> D1 from InfiniteProductFiniteField(D2,D3,D4,D1)
--R             if D2 has Join(Field,Finite,ConvertibleTo(Integer)) and D3
--R             has UPOLYC(D2) and D4 has MONOGEN(D2,D3) and D1 has UTSCAT
--R            (D4)
--R   [3] D1 -> D1 from InfiniteProductPrimeField(D2,D1)
--R             if D2 has Join(Field,Finite,ConvertibleTo(Integer)) and D1
--R             has UTSCAT(D2)
--R
--RThere is one unexposed function called oddInfiniteProduct :
--R   [1] Stream(D2) -> Stream(D2) from StreamInfiniteProduct(D2)
--R             if D2 has Join(IntegralDomain,CharacteristicZero)
--R
--RExamples of oddInfiniteProduct from InfiniteProductCharacteristicZero
--R
--R
--RExamples of oddInfiniteProduct from InfiniteProductFiniteField
--R
--R
--RExamples of oddInfiniteProduct from InfiniteProductPrimeField
--R
--R
--RExamples of oddInfiniteProduct from StreamInfiniteProduct
--R
--E 2003

--S 2004 of 3320
)d op oddintegers
--R 
--R
--RThere is one unexposed function called oddintegers :
--R   [1] Integer -> Stream(Integer) from StreamTaylorSeriesOperations(D3)
--R             if D3 has RING
--R
--RExamples of oddintegers from StreamTaylorSeriesOperations
--R
--E 2004

--S 2005 of 3320
)d op oddlambert
--R 
--R
--RThere are 2 exposed functions called oddlambert :
--R   [1] UnivariateFormalPowerSeries(D1) -> UnivariateFormalPowerSeries(
--R            D1)
--R             from UnivariateFormalPowerSeries(D1) if D1 has RING
--R   [2] UnivariateTaylorSeriesCZero(D1,D2) -> 
--R            UnivariateTaylorSeriesCZero(D1,D2)
--R             from UnivariateTaylorSeriesCZero(D1,D2) if D1 has RING and
--R            D2: SYMBOL
--R
--RThere are 2 unexposed functions called oddlambert :
--R   [1] Stream(D2) -> Stream(D2) from StreamTaylorSeriesOperations(D2)
--R             if D2 has RING
--R   [2] UnivariateTaylorSeries(D1,D2,D3) -> UnivariateTaylorSeries(D1,D2
--R            ,D3)
--R             from UnivariateTaylorSeries(D1,D2,D3)
--R             if D1 has RING and D2: SYMBOL and D3: D1
--R
--RExamples of oddlambert from StreamTaylorSeriesOperations
--R
--R
--RExamples of oddlambert from UnivariateFormalPowerSeries
--R
--R
--RExamples of oddlambert from UnivariateTaylorSeries
--R
--R
--RExamples of oddlambert from UnivariateTaylorSeriesCZero
--R
--E 2005

--S 2006 of 3320
)d op ode
--R 
--R
--RThere is one unexposed function called ode :
--R   [1] ((List(D1) -> D1),List(D4)) -> D1
--R             from UnivariateTaylorSeriesODESolver(D4,D1)
--R             if D4 has ALGEBRA(FRAC(INT)) and D1 has UTSCAT(D4)
--R
--RExamples of ode from UnivariateTaylorSeriesODESolver
--R
--E 2006

--S 2007 of 3320
)d op ode1
--R 
--R
--RThere is one unexposed function called ode1 :
--R   [1] ((D1 -> D1),D3) -> D1 from UnivariateTaylorSeriesODESolver(D3,D1
--R            )
--R             if D1 has UTSCAT(D3) and D3 has ALGEBRA(FRAC(INT))
--R
--RExamples of ode1 from UnivariateTaylorSeriesODESolver
--R
--E 2007

--S 2008 of 3320
)d op ode2
--R 
--R
--RThere is one unexposed function called ode2 :
--R   [1] (((D1,D1) -> D1),D3,D3) -> D1 from 
--R            UnivariateTaylorSeriesODESolver(D3,D1)
--R             if D1 has UTSCAT(D3) and D3 has ALGEBRA(FRAC(INT))
--R
--RExamples of ode2 from UnivariateTaylorSeriesODESolver
--R
--E 2008

--S 2009 of 3320
)d op OMbindTCP
--R 
--R
--RThere is one exposed function called OMbindTCP :
--R   [1] (OpenMathConnection,SingleInteger) -> Boolean from 
--R            OpenMathConnection
--R
--RExamples of OMbindTCP from OpenMathConnection
--R
--E 2009

--S 2010 of 3320
)d op OMclose
--R 
--R
--RThere is one exposed function called OMclose :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMclose from OpenMathDevice
--R
--E 2010

--S 2011 of 3320
)d op OMcloseConn
--R 
--R
--RThere is one exposed function called OMcloseConn :
--R   [1] OpenMathConnection -> Void from OpenMathConnection
--R
--RExamples of OMcloseConn from OpenMathConnection
--R
--E 2011

--S 2012 of 3320
)d op OMconnectTCP
--R 
--R
--RThere is one exposed function called OMconnectTCP :
--R   [1] (OpenMathConnection,String,SingleInteger) -> Boolean
--R             from OpenMathConnection
--R
--RExamples of OMconnectTCP from OpenMathConnection
--R
--E 2012

--S 2013 of 3320
)d op OMconnInDevice
--R 
--R
--RThere is one exposed function called OMconnInDevice :
--R   [1] OpenMathConnection -> OpenMathDevice from OpenMathConnection
--R
--RExamples of OMconnInDevice from OpenMathConnection
--R
--E 2013

--S 2014 of 3320
)d op OMconnOutDevice
--R 
--R
--RThere is one exposed function called OMconnOutDevice :
--R   [1] OpenMathConnection -> OpenMathDevice from OpenMathConnection
--R
--RExamples of OMconnOutDevice from OpenMathConnection
--R
--E 2014

--S 2015 of 3320
)d op OMencodingBinary
--R 
--R
--RThere is one exposed function called OMencodingBinary :
--R   [1]  -> OpenMathEncoding from OpenMathEncoding
--R
--RExamples of OMencodingBinary from OpenMathEncoding
--R
--E 2015

--S 2016 of 3320
)d op OMencodingSGML
--R 
--R
--RThere is one exposed function called OMencodingSGML :
--R   [1]  -> OpenMathEncoding from OpenMathEncoding
--R
--RExamples of OMencodingSGML from OpenMathEncoding
--R
--E 2016

--S 2017 of 3320
)d op OMencodingUnknown
--R 
--R
--RThere is one exposed function called OMencodingUnknown :
--R   [1]  -> OpenMathEncoding from OpenMathEncoding
--R
--RExamples of OMencodingUnknown from OpenMathEncoding
--R
--E 2017

--S 2018 of 3320
)d op OMencodingXML
--R 
--R
--RThere is one exposed function called OMencodingXML :
--R   [1]  -> OpenMathEncoding from OpenMathEncoding
--R
--RExamples of OMencodingXML from OpenMathEncoding
--R
--E 2018

--S 2019 of 3320
)d op omError
--R 
--R
--RThere is one exposed function called omError :
--R   [1] (OpenMathErrorKind,List(Symbol)) -> OpenMathError from 
--R            OpenMathError
--R
--RExamples of omError from OpenMathError
--R
--E 2019

--S 2020 of 3320
)d op OMgetApp
--R 
--R
--RThere is one exposed function called OMgetApp :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetApp from OpenMathDevice
--R
--E 2020

--S 2021 of 3320
)d op OMgetAtp
--R 
--R
--RThere is one exposed function called OMgetAtp :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetAtp from OpenMathDevice
--R
--E 2021

--S 2022 of 3320
)d op OMgetAttr
--R 
--R
--RThere is one exposed function called OMgetAttr :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetAttr from OpenMathDevice
--R
--E 2022

--S 2023 of 3320
)d op OMgetBind
--R 
--R
--RThere is one exposed function called OMgetBind :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetBind from OpenMathDevice
--R
--E 2023

--S 2024 of 3320
)d op OMgetBVar
--R 
--R
--RThere is one exposed function called OMgetBVar :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetBVar from OpenMathDevice
--R
--E 2024

--S 2025 of 3320
)d op OMgetEndApp
--R 
--R
--RThere is one exposed function called OMgetEndApp :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetEndApp from OpenMathDevice
--R
--E 2025

--S 2026 of 3320
)d op OMgetEndAtp
--R 
--R
--RThere is one exposed function called OMgetEndAtp :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetEndAtp from OpenMathDevice
--R
--E 2026

--S 2027 of 3320
)d op OMgetEndAttr
--R 
--R
--RThere is one exposed function called OMgetEndAttr :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetEndAttr from OpenMathDevice
--R
--E 2027

--S 2028 of 3320
)d op OMgetEndBind
--R 
--R
--RThere is one exposed function called OMgetEndBind :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetEndBind from OpenMathDevice
--R
--E 2028

--S 2029 of 3320
)d op OMgetEndBVar
--R 
--R
--RThere is one exposed function called OMgetEndBVar :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetEndBVar from OpenMathDevice
--R
--E 2029

--S 2030 of 3320
)d op OMgetEndError
--R 
--R
--RThere is one exposed function called OMgetEndError :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetEndError from OpenMathDevice
--R
--E 2030

--S 2031 of 3320
)d op OMgetEndObject
--R 
--R
--RThere is one exposed function called OMgetEndObject :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetEndObject from OpenMathDevice
--R
--E 2031

--S 2032 of 3320
)d op OMgetError
--R 
--R
--RThere is one exposed function called OMgetError :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetError from OpenMathDevice
--R
--E 2032

--S 2033 of 3320
)d op OMgetFloat
--R 
--R
--RThere is one exposed function called OMgetFloat :
--R   [1] OpenMathDevice -> DoubleFloat from OpenMathDevice
--R
--RExamples of OMgetFloat from OpenMathDevice
--R
--E 2033

--S 2034 of 3320
)d op OMgetInteger
--R 
--R
--RThere is one exposed function called OMgetInteger :
--R   [1] OpenMathDevice -> Integer from OpenMathDevice
--R
--RExamples of OMgetInteger from OpenMathDevice
--R
--E 2034

--S 2035 of 3320
)d op OMgetObject
--R 
--R
--RThere is one exposed function called OMgetObject :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMgetObject from OpenMathDevice
--R
--E 2035

--S 2036 of 3320
)d op OMgetString
--R 
--R
--RThere is one exposed function called OMgetString :
--R   [1] OpenMathDevice -> String from OpenMathDevice
--R
--RExamples of OMgetString from OpenMathDevice
--R
--E 2036

--S 2037 of 3320
)d op OMgetSymbol
--R 
--R
--RThere is one exposed function called OMgetSymbol :
--R   [1] OpenMathDevice -> Record(cd: String,name: String) from 
--R            OpenMathDevice
--R
--RExamples of OMgetSymbol from OpenMathDevice
--R
--E 2037

--S 2038 of 3320
)d op OMgetType
--R 
--R
--RThere is one exposed function called OMgetType :
--R   [1] OpenMathDevice -> Symbol from OpenMathDevice
--R
--RExamples of OMgetType from OpenMathDevice
--R
--E 2038

--S 2039 of 3320
)d op OMgetVariable
--R 
--R
--RThere is one exposed function called OMgetVariable :
--R   [1] OpenMathDevice -> Symbol from OpenMathDevice
--R
--RExamples of OMgetVariable from OpenMathDevice
--R
--E 2039

--S 2040 of 3320
)d op OMlistCDs
--R 
--R
--RThere is one exposed function called OMlistCDs :
--R   [1]  -> List(String) from OpenMathPackage
--R
--RExamples of OMlistCDs from OpenMathPackage
--R
--E 2040

--S 2041 of 3320
)d op OMlistSymbols
--R 
--R
--RThere is one exposed function called OMlistSymbols :
--R   [1] String -> List(String) from OpenMathPackage
--R
--RExamples of OMlistSymbols from OpenMathPackage
--R
--E 2041

--S 2042 of 3320
)d op OMmakeConn
--R 
--R
--RThere is one exposed function called OMmakeConn :
--R   [1] SingleInteger -> OpenMathConnection from OpenMathConnection
--R
--RExamples of OMmakeConn from OpenMathConnection
--R
--E 2042

--S 2043 of 3320
)d op OMopenFile
--R 
--R
--RThere is one exposed function called OMopenFile :
--R   [1] (String,String,OpenMathEncoding) -> OpenMathDevice from 
--R            OpenMathDevice
--R
--RExamples of OMopenFile from OpenMathDevice
--R
--E 2043

--S 2044 of 3320
)d op OMopenString
--R 
--R
--RThere is one exposed function called OMopenString :
--R   [1] (String,OpenMathEncoding) -> OpenMathDevice from OpenMathDevice
--R            
--R
--RExamples of OMopenString from OpenMathDevice
--R
--E 2044

--S 2045 of 3320
)d op OMParseError?
--R 
--R
--RThere is one exposed function called OMParseError? :
--R   [1] OpenMathErrorKind -> Boolean from OpenMathErrorKind
--R
--RExamples of OMParseError? from OpenMathErrorKind
--R
--E 2045

--S 2046 of 3320
)d op OMputApp
--R 
--R
--RThere is one exposed function called OMputApp :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputApp from OpenMathDevice
--R
--E 2046

--S 2047 of 3320
)d op OMputAtp
--R 
--R
--RThere is one exposed function called OMputAtp :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputAtp from OpenMathDevice
--R
--E 2047

--S 2048 of 3320
)d op OMputAttr
--R 
--R
--RThere is one exposed function called OMputAttr :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputAttr from OpenMathDevice
--R
--E 2048

--S 2049 of 3320
)d op OMputBind
--R 
--R
--RThere is one exposed function called OMputBind :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputBind from OpenMathDevice
--R
--E 2049

--S 2050 of 3320
)d op OMputBVar
--R 
--R
--RThere is one exposed function called OMputBVar :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputBVar from OpenMathDevice
--R
--E 2050

--S 2051 of 3320
)d op OMputEndApp
--R 
--R
--RThere is one exposed function called OMputEndApp :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputEndApp from OpenMathDevice
--R
--E 2051

--S 2052 of 3320
)d op OMputEndAtp
--R 
--R
--RThere is one exposed function called OMputEndAtp :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputEndAtp from OpenMathDevice
--R
--E 2052

--S 2053 of 3320
)d op OMputEndAttr
--R 
--R
--RThere is one exposed function called OMputEndAttr :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputEndAttr from OpenMathDevice
--R
--E 2053

--S 2054 of 3320
)d op OMputEndBind
--R 
--R
--RThere is one exposed function called OMputEndBind :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputEndBind from OpenMathDevice
--R
--E 2054

--S 2055 of 3320
)d op OMputEndBVar
--R 
--R
--RThere is one exposed function called OMputEndBVar :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputEndBVar from OpenMathDevice
--R
--E 2055

--S 2056 of 3320
)d op OMputEndError
--R 
--R
--RThere is one exposed function called OMputEndError :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputEndError from OpenMathDevice
--R
--E 2056

--S 2057 of 3320
)d op OMputEndObject
--R 
--R
--RThere is one exposed function called OMputEndObject :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputEndObject from OpenMathDevice
--R
--E 2057

--S 2058 of 3320
)d op OMputError
--R 
--R
--RThere is one exposed function called OMputError :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputError from OpenMathDevice
--R
--E 2058

--S 2059 of 3320
)d op OMputFloat
--R 
--R
--RThere is one exposed function called OMputFloat :
--R   [1] (OpenMathDevice,DoubleFloat) -> Void from OpenMathDevice
--R
--RExamples of OMputFloat from OpenMathDevice
--R
--E 2059

--S 2060 of 3320
)d op OMputInteger
--R 
--R
--RThere is one exposed function called OMputInteger :
--R   [1] (OpenMathDevice,Integer) -> Void from OpenMathDevice
--R
--RExamples of OMputInteger from OpenMathDevice
--R
--E 2060

--S 2061 of 3320
)d op OMputObject
--R 
--R
--RThere is one exposed function called OMputObject :
--R   [1] OpenMathDevice -> Void from OpenMathDevice
--R
--RExamples of OMputObject from OpenMathDevice
--R
--E 2061

--S 2062 of 3320
)d op OMputString
--R 
--R
--RThere is one exposed function called OMputString :
--R   [1] (OpenMathDevice,String) -> Void from OpenMathDevice
--R
--RExamples of OMputString from OpenMathDevice
--R
--E 2062

--S 2063 of 3320
)d op OMputSymbol
--R 
--R
--RThere is one exposed function called OMputSymbol :
--R   [1] (OpenMathDevice,String,String) -> Void from OpenMathDevice
--R
--RExamples of OMputSymbol from OpenMathDevice
--R
--E 2063

--S 2064 of 3320
)d op OMputVariable
--R 
--R
--RThere is one exposed function called OMputVariable :
--R   [1] (OpenMathDevice,Symbol) -> Void from OpenMathDevice
--R
--RExamples of OMputVariable from OpenMathDevice
--R
--E 2064

--S 2065 of 3320
)d op OMread
--R 
--R
--RThere is one exposed function called OMread :
--R   [1] OpenMathDevice -> Any from OpenMathPackage
--R
--RExamples of OMread from OpenMathPackage
--R
--E 2065

--S 2066 of 3320
)d op OMReadError?
--R 
--R
--RThere is one exposed function called OMReadError? :
--R   [1] OpenMathErrorKind -> Boolean from OpenMathErrorKind
--R
--RExamples of OMReadError? from OpenMathErrorKind
--R
--E 2066

--S 2067 of 3320
)d op OMreadFile
--R 
--R
--RThere is one exposed function called OMreadFile :
--R   [1] String -> Any from OpenMathPackage
--R
--RExamples of OMreadFile from OpenMathPackage
--R
--E 2067

--S 2068 of 3320
)d op OMreadStr
--R 
--R
--RThere is one exposed function called OMreadStr :
--R   [1] String -> Any from OpenMathPackage
--R
--RExamples of OMreadStr from OpenMathPackage
--R
--E 2068

--S 2069 of 3320
)d op OMreceive
--R 
--R
--RThere is one exposed function called OMreceive :
--R   [1] OpenMathConnection -> Any from OpenMathServerPackage
--R
--RExamples of OMreceive from OpenMathServerPackage
--R
--E 2069

--S 2070 of 3320
)d op OMsend
--R 
--R
--RThere is one exposed function called OMsend :
--R   [1] (OpenMathConnection,Any) -> Void from OpenMathServerPackage
--R
--RExamples of OMsend from OpenMathServerPackage
--R
--E 2070

--S 2071 of 3320
)d op OMserve
--R 
--R
--RThere is one exposed function called OMserve :
--R   [1] (SingleInteger,SingleInteger) -> Void from OpenMathServerPackage
--R            
--R
--RExamples of OMserve from OpenMathServerPackage
--R
--E 2071

--S 2072 of 3320
)d op OMsetEncoding
--R 
--R
--RThere is one exposed function called OMsetEncoding :
--R   [1] (OpenMathDevice,OpenMathEncoding) -> Void from OpenMathDevice
--R         
--R
--RExamples of OMsetEncoding from OpenMathDevice
--R
--E 2072

--S 2073 of 3320
)d op OMsupportsCD?
--R 
--R
--RThere is one exposed function called OMsupportsCD? :
--R   [1] String -> Boolean from OpenMathPackage
--R
--RExamples of OMsupportsCD? from OpenMathPackage
--R
--E 2073

--S 2074 of 3320
)d op OMsupportsSymbol?
--R 
--R
--RThere is one exposed function called OMsupportsSymbol? :
--R   [1] (String,String) -> Boolean from OpenMathPackage
--R
--RExamples of OMsupportsSymbol? from OpenMathPackage
--R
--E 2074

--S 2075 of 3320
)d op OMunhandledSymbol
--R 
--R
--RThere is one exposed function called OMunhandledSymbol :
--R   [1] (String,String) -> Exit from OpenMathPackage
--R
--RExamples of OMunhandledSymbol from OpenMathPackage
--R
--E 2075

--S 2076 of 3320
)d op OMUnknownCD?
--R 
--R
--RThere is one exposed function called OMUnknownCD? :
--R   [1] OpenMathErrorKind -> Boolean from OpenMathErrorKind
--R
--RExamples of OMUnknownCD? from OpenMathErrorKind
--R
--E 2076

--S 2077 of 3320
)d op OMUnknownSymbol?
--R 
--R
--RThere is one exposed function called OMUnknownSymbol? :
--R   [1] OpenMathErrorKind -> Boolean from OpenMathErrorKind
--R
--RExamples of OMUnknownSymbol? from OpenMathErrorKind
--R
--E 2077

--S 2078 of 3320
)d op OMwrite
--R 
--R
--RThere are 8 exposed functions called OMwrite :
--R   [1] Expression(D3) -> String from ExpressionToOpenMath(D3)
--R             if D3 has Join(OpenMath,OrderedSet,Ring)
--R   [2] (Expression(D4),Boolean) -> String from ExpressionToOpenMath(D4)
--R             if D4 has Join(OpenMath,OrderedSet,Ring)
--R   [3] (OpenMathDevice,Expression(D4)) -> Void from 
--R            ExpressionToOpenMath(D4)
--R             if D4 has Join(OpenMath,OrderedSet,Ring)
--R   [4] (OpenMathDevice,Expression(D5),Boolean) -> Void
--R             from ExpressionToOpenMath(D5) if D5 has Join(OpenMath,
--R            OrderedSet,Ring)
--R   [5] D -> String from D if D has OM
--R   [6] (D,Boolean) -> String from D if D has OM
--R   [7] (OpenMathDevice,D) -> Void from D if D has OM
--R   [8] (OpenMathDevice,D,Boolean) -> Void from D if D has OM
--R
--RExamples of OMwrite from ExpressionToOpenMath
--R
--R
--RExamples of OMwrite from OpenMath
--R
--E 2078

--S 2079 of 3320
)d op one
--R 
--R
--RThere is one exposed function called one :
--R   [1] Boolean -> GuessOption from GuessOption
--R
--RThere is one unexposed function called one :
--R   [1] List(GuessOption) -> Boolean from GuessOptionFunctions0
--R
--RExamples of one from GuessOptionFunctions0
--R
--R
--RExamples of one from GuessOption
--R
--E 2079

--S 2080 of 3320
)d op one?
--R 
--R
--RThere are 3 exposed functions called one? :
--R   [1] PolynomialIdeals(D2,D3,D4,D5) -> Boolean
--R             from PolynomialIdeals(D2,D3,D4,D5)
--R             if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D5
--R             has POLYCAT(D2,D3,D4)
--R   [2] D -> Boolean from D if D has MONADWU
--R   [3] D -> Boolean from D if D has MONOID
--R
--RExamples of one? from PolynomialIdeals
--R
--R
--RExamples of one? from MonadWithUnit
--R
--R
--RExamples of one? from Monoid
--R
--E 2080

--S 2081 of 3320 done
)d op oneDimensionalArray
--R 
--R
--RThere are 2 exposed functions called oneDimensionalArray :
--R   [1] (NonNegativeInteger,D2) -> OneDimensionalArray(D2)
--R             from OneDimensionalArray(D2) if D2 has TYPE
--R   [2] List(D2) -> OneDimensionalArray(D2) from OneDimensionalArray(D2)
--R             if D2 has TYPE
--R
--RExamples of oneDimensionalArray from OneDimensionalArray
--R
--RoneDimensionalArray(10,0.0)
--R
--RoneDimensionalArray [i**2 for i in 1..10]
--R
--E 2081

--S 2082 of 3320
)d op op
--R 
--R
--RThere is one unexposed function called op :
--R   [1] D1 -> OppositeMonogenicLinearOperator(D1,D2)
--R             from OppositeMonogenicLinearOperator(D1,D2)
--R             if D2 has RING and D1 has MLO(D2)
--R
--RExamples of op from OppositeMonogenicLinearOperator
--R
--E 2082

--S 2083 of 3320
)d op open
--R 
--R
--RThere are 2 exposed functions called open :
--R   [1] (D1,String) -> D from D
--R             if D has FILECAT(D1,D3) and D1 has SETCAT and D3 has 
--R            SETCAT
--R   [2] D1 -> D from D if D has FILECAT(D1,D2) and D1 has SETCAT and D2
--R             has SETCAT
--R
--RExamples of open from FileCategory
--R
--E 2083

--S 2084 of 3320
)d op open?
--R 
--R
--RThere is one unexposed function called open? :
--R   [1] TubePlot(D2) -> Boolean from TubePlot(D2) if D2 has PSCURVE
--R
--RExamples of open? from TubePlot
--R
--E 2084

--S 2085 of 3320
)d op operation
--R 
--R
--RThere is one exposed function called operation :
--R   [1] FortranCode -> Union(Null: null,Assignment: assignment,
--R            Conditional: conditional,Return: return,Block: block,Comment: 
--R            comment,Call: call,For: for,While: while,Repeat: repeat,Goto: 
--R            goto,Continue: continue,ArrayAssignment: arrayAssignment,Save: 
--R            save,Stop: stop,Common: common,Print: print)
--R             from FortranCode
--R
--RExamples of operation from FortranCode
--R
--E 2085

--S 2086 of 3320
)d op operator
--R 
--R
--RThere are 3 exposed functions called operator :
--R   [1] (Symbol,NonNegativeInteger) -> BasicOperator from BasicOperator
--R            
--R   [2] Symbol -> BasicOperator from BasicOperator
--R   [3] BasicOperator -> BasicOperator from D if D has ES
--R
--RThere are 9 unexposed functions called operator :
--R   [1] BasicOperator -> BasicOperator from AlgebraicFunction(D2,D3)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D3 has FS(D2
--R            )
--R   [2] BasicOperator -> BasicOperator from CombinatorialFunction(D2,D3)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D3 has FS(D2
--R            )
--R   [3] Symbol -> BasicOperator from CommonOperators
--R   [4] BasicOperator -> BasicOperator from ElementaryFunction(D2,D3)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D3 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [5] BasicOperator -> BasicOperator from ExpressionSpace&(D2) if D2
--R             has ES
--R   [6] BasicOperator -> BasicOperator from FunctionSpace&(D2,D3)
--R             if D3 has ORDSET and D2 has FS(D3)
--R   [7] BasicOperator -> BasicOperator from FunctionalSpecialFunction(D2
--R            ,D3)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D3 has FS(D2
--R            )
--R   [8] Kernel(D2) -> BasicOperator from Kernel(D2) if D2 has ORDSET
--R   [9] BasicOperator -> BasicOperator from LiouvillianFunction(D2,D3)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D3 has Join(
--R            FunctionSpace(D2),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R
--RExamples of operator from AlgebraicFunction
--R
--R
--RExamples of operator from BasicOperator
--R
--R
--RExamples of operator from CombinatorialFunction
--R
--R
--RExamples of operator from CommonOperators
--R
--R
--RExamples of operator from ElementaryFunction
--R
--R
--RExamples of operator from ExpressionSpace&
--R
--R
--RExamples of operator from ExpressionSpace
--R
--R
--RExamples of operator from FunctionSpace&
--R
--R
--RExamples of operator from FunctionalSpecialFunction
--R
--R
--RExamples of operator from Kernel
--R
--R
--RExamples of operator from LiouvillianFunction
--R
--E 2086

--S 2087 of 3320
)d op operators
--R 
--R
--RThere is one exposed function called operators :
--R   [1] D -> List(BasicOperator) from D if D has ES
--R
--RExamples of operators from ExpressionSpace
--R
--E 2087

--S 2088 of 3320
)d op opeval
--R 
--R
--RThere is one exposed function called opeval :
--R   [1] (BasicOperator,D1) -> D1 from ModuleOperator(D3,D1)
--R             if D3 has RING and D1 has LMODULE(D3)
--R
--RThere is one unexposed function called opeval :
--R   [1] (BasicOperator,D1) -> D1 from Operator(D1) if D1 has RING
--R
--RExamples of opeval from ModuleOperator
--R
--R
--RExamples of opeval from Operator
--R
--E 2088

--S 2089 of 3320
)d op optAttributes
--R 
--R
--RThere is one exposed function called optAttributes :
--R   [1] Union(noa: Record(fn: Expression(DoubleFloat),init: List(
--R            DoubleFloat),lb: List(OrderedCompletion(DoubleFloat)),cf: List(
--R            Expression(DoubleFloat)),ub: List(OrderedCompletion(DoubleFloat))
--R            ),lsa: Record(lfn: List(Expression(DoubleFloat)),init: List(
--R            DoubleFloat))) -> List(String)
--R             from e04AgentsPackage
--R
--RExamples of optAttributes from e04AgentsPackage
--R
--E 2089

--S 2090 of 3320
)d op optimize
--R 
--R
--RThere are 6 exposed functions called optimize :
--R   [1] (NumericalOptimizationProblem,RoutinesTable) -> Result
--R             from AnnaNumericalOptimizationPackage
--R   [2] NumericalOptimizationProblem -> Result
--R             from AnnaNumericalOptimizationPackage
--R   [3] (Expression(Float),List(Float),List(OrderedCompletion(Float)),
--R            List(Expression(Float)),List(OrderedCompletion(Float))) -> Result
--R             from AnnaNumericalOptimizationPackage
--R   [4] (Expression(Float),List(Float),List(OrderedCompletion(Float)),
--R            List(OrderedCompletion(Float))) -> Result
--R             from AnnaNumericalOptimizationPackage
--R   [5] (Expression(Float),List(Float)) -> Result
--R             from AnnaNumericalOptimizationPackage
--R   [6] (List(Expression(Float)),List(Float)) -> Result
--R             from AnnaNumericalOptimizationPackage
--R
--RExamples of optimize from AnnaNumericalOptimizationPackage
--R
--E 2090

--S 2091 of 3320
)d op option
--R 
--R
--RThere are 2 exposed functions called option :
--R   [1] (List(DrawOption),Symbol) -> Union(Any,"failed") from DrawOption
--R            
--R   [2] (List(GuessOption),Symbol) -> Union(Any,"failed") from 
--R            GuessOption
--R
--RThere is one unexposed function called option :
--R   [1] (List(DrawOption),Symbol) -> Union(D1,"failed")
--R             from DrawOptionFunctions1(D1) if D1 has TYPE
--R
--RExamples of option from DrawOptionFunctions1
--R
--R
--RExamples of option from DrawOption
--R
--R
--RExamples of option from GuessOption
--R
--E 2091

--S 2092 of 3320
)d op option?
--R 
--R
--RThere is one exposed function called option? :
--R   [1] (List(DrawOption),Symbol) -> Boolean from DrawOption
--R
--RExamples of option? from DrawOption
--R
--E 2092

--S 2093 of 3320
)d op optional
--R 
--R
--RThere are 2 exposed functions called optional :
--R   [1] D1 -> D1 from FunctionSpaceAssertions(D2,D1)
--R             if D2 has ORDSET and D1 has FS(D2)
--R   [2] Symbol -> Expression(Integer) from PatternMatchAssertions
--R
--RExamples of optional from FunctionSpaceAssertions
--R
--R
--RExamples of optional from PatternMatchAssertions
--R
--E 2093

--S 2094 of 3320
)d op optional?
--R 
--R
--RThere is one unexposed function called optional? :
--R   [1] Pattern(D2) -> Boolean from Pattern(D2) if D2 has SETCAT
--R
--RExamples of optional? from Pattern
--R
--E 2094

--S 2095 of 3320
)d op options
--R 
--R
--RThere are 2 exposed functions called options :
--R   [1] (ThreeDimensionalViewport,List(DrawOption)) -> 
--R            ThreeDimensionalViewport
--R             from ThreeDimensionalViewport
--R   [2] ThreeDimensionalViewport -> List(DrawOption)
--R             from ThreeDimensionalViewport
--R
--RThere are 2 unexposed functions called options :
--R   [1] (TwoDimensionalViewport,List(DrawOption)) -> 
--R            TwoDimensionalViewport
--R             from TwoDimensionalViewport
--R   [2] TwoDimensionalViewport -> List(DrawOption) from 
--R            TwoDimensionalViewport
--R
--RExamples of options from TwoDimensionalViewport
--R
--R
--RExamples of options from ThreeDimensionalViewport
--R
--E 2095

--S 2096 of 3320
)d op optpair
--R 
--R
--RThere is one unexposed function called optpair :
--R   [1] List(Pattern(D2)) -> Union(List(Pattern(D2)),"failed") from 
--R            Pattern(D2)
--R             if D2 has SETCAT
--R
--RExamples of optpair from Pattern
--R
--E 2096

--S 2097 of 3320
)d op or
--R 
--R
--RThere are 2 exposed functions called or :
--R   [1] (Boolean,Boolean) -> Boolean from Boolean
--R   [2] (D,D) -> D from D if D has BTAGG
--R
--RThere is one unexposed function called or :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of or from Boolean
--R
--R
--RExamples of or from BitAggregate
--R
--R
--RExamples of or from OutputForm
--R
--E 2097

--S 2098 of 3320
)d op Or
--R 
--R
--RThere is one exposed function called Or :
--R   [1] (SingleInteger,SingleInteger) -> SingleInteger from 
--R            SingleInteger
--R
--RThere is one unexposed function called Or :
--R   [1] (IndexedBits(D1),IndexedBits(D1)) -> IndexedBits(D1) from 
--R            IndexedBits(D1)
--R             if D1: INT
--R
--RExamples of Or from IndexedBits
--R
--R
--RExamples of Or from SingleInteger
--R
--E 2098

--S 2099 of 3320
)d op OR
--R 
--R
--RThere is one exposed function called OR :
--R   [1] (Union(I: Expression(Integer),F: Expression(Float),CF: 
--R            Expression(Complex(Float)),switch: Switch),Union(I: Expression(
--R            Integer),F: Expression(Float),CF: Expression(Complex(Float)),
--R            switch: Switch)) -> Switch
--R             from Switch
--R
--RExamples of OR from Switch
--R
--E 2099

--S 2100 of 3320
)d op orbit
--R 
--R
--RThere are 8 exposed functions called orbit :
--R   [1] (D,NonNegativeInteger) -> List(D) from D if D3 has FIELD and D
--R             has AFSPCAT(D3)
--R   [2] D -> List(D) from D if D2 has FIELD and D has AFSPCAT(D2)
--R   [3] (D,D2) -> Set(D2) from D if D has PERMCAT(D2) and D2 has SETCAT
--R            
--R   [4] (PermutationGroup(D3),List(D3)) -> Set(List(D3))
--R             from PermutationGroup(D3) if D3 has SETCAT
--R   [5] (PermutationGroup(D3),Set(D3)) -> Set(Set(D3)) from 
--R            PermutationGroup(D3)
--R             if D3 has SETCAT
--R   [6] (PermutationGroup(D2),D2) -> Set(D2) from PermutationGroup(D2)
--R             if D2 has SETCAT
--R   [7] (D,NonNegativeInteger) -> List(D) from D if D3 has FIELD and D
--R             has PRSPCAT(D3)
--R   [8] D -> List(D) from D if D2 has FIELD and D has PRSPCAT(D2)
--R
--RExamples of orbit from AffineSpaceCategory
--R
--R
--RExamples of orbit from PermutationCategory
--R
--R
--RExamples of orbit from PermutationGroup
--R
--Rx : PERM INT := [[1,3,5],[7,11,9]] 
--Ry : PERM INT := [[3,5,7,9]] 
--Rg : PERMGRP INT := [ x , y ] 
--Rorbit(g, 3)
--R
--R
--RExamples of orbit from ProjectiveSpaceCategory
--R
--E 2100

--S 2101 of 3320 done
)d op orbits
--R 
--R
--RThere is one exposed function called orbits :
--R   [1] PermutationGroup(D2) -> Set(Set(D2)) from PermutationGroup(D2)
--R             if D2 has SETCAT
--R
--RExamples of orbits from PermutationGroup
--R
--Ry : PERM INT := [[3,5,7,9]] 
--Rz : PERM INT := [1,3,11] 
--Rg : PERMGRP INT := [ y , z ] 
--Rorbits g
--R
--E 2101

--S 2102 of 3320 done
)d op ord
--R 
--R
--RThere is one exposed function called ord :
--R   [1] Character -> Integer from Character
--R
--RExamples of ord from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[ord c for c in chars]
--R
--E 2102

--S 2103 of 3320
)d op order
--R 
--R
--RThere are 16 exposed functions called order :
--R   [1] D -> NonNegativeInteger from D
--R             if D has DPOLCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            ORDSET and D4 has DVARCAT(D3) and D5 has OAMONS
--R   [2] (D,D2) -> NonNegativeInteger from D
--R             if D has DPOLCAT(D3,D2,D4,D5) and D3 has RING and D2 has 
--R            ORDSET and D4 has DVARCAT(D2) and D5 has OAMONS
--R   [3] D -> NonNegativeInteger from D if D has DVARCAT(D2) and D2 has 
--R            ORDSET
--R   [4] D -> PositiveInteger from D if D has FFIELDC
--R   [5] D -> OnePointCompletion(PositiveInteger) from D if D has FPC
--R   [6] D -> Integer from D if D has FPS
--R   [7] D -> Integer from D if D has LOCPOWC(D2) and D2 has FIELD
--R   [8] D -> Integer from D if D has LOCPOWC(D2) and D2 has FIELD
--R   [9] (D,D2,NonNegativeInteger) -> NonNegativeInteger from D
--R             if D has MTSCAT(D3,D2) and D3 has RING and D2 has ORDSET
--R         
--R   [10] (D,D2) -> NonNegativeInteger from D
--R             if D has MTSCAT(D3,D2) and D3 has RING and D2 has ORDSET
--R         
--R   [11] D -> NonNegativeInteger from D if D has PADICCT(D2)
--R   [12] PermutationGroup(D2) -> NonNegativeInteger from 
--R            PermutationGroup(D2)
--R             if D2 has SETCAT
--R   [13] Permutation(D2) -> NonNegativeInteger from Permutation(D2) if 
--R            D2 has SETCAT
--R   [14] (D,D) -> NonNegativeInteger from D
--R             if D has UPOLYC(D2) and D2 has RING and D2 has INTDOM
--R   [15] (D,D1) -> D1 from D if D has UPSCAT(D2,D1) and D2 has RING and 
--R            D1 has OAMON
--R   [16] D -> D1 from D if D has UPSCAT(D2,D1) and D2 has RING and D1
--R             has OAMON
--R
--RThere are 7 unexposed functions called order :
--R   [1] FiniteDivisor(D3,D4,D5,D6) -> NonNegativeInteger
--R             from FindOrderFinite(D3,D4,D5,D6)
--R             if D3 has Join(Finite,Field) and D4 has UPOLYC(D3) and D5
--R             has UPOLYC(FRAC(D4)) and D6 has FFCAT(D3,D4,D5)
--R   [2] (InnerTaylorSeries(D2),NonNegativeInteger) -> NonNegativeInteger
--R             from InnerTaylorSeries(D2) if D2 has RING
--R   [3] InnerTaylorSeries(D2) -> NonNegativeInteger from 
--R            InnerTaylorSeries(D2)
--R             if D2 has RING
--R   [4] LaurentPolynomial(D2,D3) -> Integer from LaurentPolynomial(D2,D3
--R            )
--R             if D2 has INTDOM and D3 has UPOLYC(D2)
--R   [5] FiniteDivisor(D4,D5,D6,D7) -> Union(NonNegativeInteger,"failed")
--R             from PointsOfFiniteOrder(D3,D4,D5,D6,D7)
--R             if D4 has FS(D3) and D5 has UPOLYC(D4) and D6 has UPOLYC(
--R            FRAC(D5)) and D7 has FFCAT(D4,D5,D6) and D3 has Join(
--R            OrderedSet,IntegralDomain,RetractableTo(Integer))
--R   [6] FiniteDivisor(Fraction(Integer),D3,D4,D5) -> Union(
--R            NonNegativeInteger,"failed")
--R             from PointsOfFiniteOrderRational(D3,D4,D5)
--R             if D3 has UPOLYC(FRAC(INT)) and D4 has UPOLYC(FRAC(D3)) 
--R            and D5 has FFCAT(FRAC(INT),D3,D4)
--R   [7] (FiniteDivisor(D5,D6,D3,D7),D3,(D5 -> D8)) -> NonNegativeInteger
--R             from ReducedDivisor(D5,D6,D3,D7,D8)
--R             if D5 has FIELD and D6 has UPOLYC(D5) and D3 has UPOLYC(
--R            FRAC(D6)) and D7 has FFCAT(D5,D6,D3) and D8 has Join(Finite
--R            ,Field)
--R
--RExamples of order from DifferentialPolynomialCategory
--R
--R
--RExamples of order from DifferentialVariableCategory
--R
--R
--RExamples of order from FiniteFieldCategory
--R
--R
--RExamples of order from FindOrderFinite
--R
--R
--RExamples of order from FieldOfPrimeCharacteristic
--R
--R
--RExamples of order from FloatingPointSystem
--R
--R
--RExamples of order from InnerTaylorSeries
--R
--R
--RExamples of order from LaurentPolynomial
--R
--Rw:SparseUnivariateLaurentSeries(Fraction(Integer),'z,0):=0 
--Rorder(w,0)
--R
--R
--RExamples of order from LocalPowerSeriesCategory
--R
--R
--RExamples of order from MultivariateTaylorSeriesCategory
--R
--R
--RExamples of order from PAdicIntegerCategory
--R
--R
--RExamples of order from PermutationGroup
--R
--Rx : PERM INT := [[1,3,5],[7,11,9]] 
--Ry : PERM INT := [[3,5,7,9]] 
--Rg : PERMGRP INT := [ x , y ] 
--Rorder g
--R
--R
--RExamples of order from Permutation
--R
--R
--RExamples of order from PointsOfFiniteOrder
--R
--R
--RExamples of order from PointsOfFiniteOrderRational
--R
--R
--RExamples of order from ReducedDivisor
--R
--R
--RExamples of order from UnivariatePolynomialCategory
--R
--R
--RExamples of order from UnivariatePowerSeriesCategory
--R
--E 2103

--S 2104 of 3320
)d op orderIfNegative
--R 
--R
--RThere is one exposed function called orderIfNegative :
--R   [1] D -> Union(Integer,"failed") from D if D has LOCPOWC(D2) and D2
--R             has FIELD
--R
--RExamples of orderIfNegative from LocalPowerSeriesCategory
--R
--E 2104

--S 2105 of 3320
)d op origin
--R 
--R
--RThere is one exposed function called origin :
--R   [1]  -> D from D if D has AFSPCAT(D1) and D1 has FIELD
--R
--RExamples of origin from AffineSpaceCategory
--R
--E 2105

--S 2106 of 3320
)d op orthonormalBasis
--R 
--R
--RThere is one exposed function called orthonormalBasis :
--R   [1] Matrix(Fraction(Polynomial(Integer))) -> List(Matrix(Expression(
--R            Integer)))
--R             from RadicalEigenPackage
--R
--RExamples of orthonormalBasis from RadicalEigenPackage
--R
--E 2106

--S 2107 of 3320
)d op outerProduct
--R 
--R
--RThere is one exposed function called outerProduct :
--R   [1] (D,D) -> Matrix(D2) from D
--R             if D has VECTCAT(D2) and D2 has TYPE and D2 has RING
--R
--RExamples of outerProduct from VectorCategory
--R
--E 2107

--S 2108 of 3320
)d op outlineRender
--R 
--R
--RThere is one exposed function called outlineRender :
--R   [1] (ThreeDimensionalViewport,String) -> Void from 
--R            ThreeDimensionalViewport
--R
--RExamples of outlineRender from ThreeDimensionalViewport
--R
--E 2108

--S 2109 of 3320
)d op output
--R 
--R
--RThere are 4 exposed functions called output :
--R   [1] String -> Void from OutputPackage
--R   [2] OutputForm -> Void from OutputPackage
--R   [3] (String,OutputForm) -> Void from OutputPackage
--R   [4] (Integer,Stream(D3)) -> Void from Stream(D3) if D3 has SETCAT 
--R            and D3 has TYPE
--R
--RExamples of output from OutputPackage
--R
--R
--RExamples of output from Stream
--R
--Rm:=[1,2,3] 
--Rn:=repeating(m) 
--Routput(5,n)
--R
--E 2109

--S 2110 of 3320
)d op outputArgs
--R 
--R
--RThere is one exposed function called outputArgs :
--R   [1] (String,String,D3,D4) -> Void from NormalizationPackage(D5,D6,D7
--R            ,D3,D4)
--R             if D5 has GCDDOM and D6 has OAMONS and D7 has ORDSET and 
--R            D3 has RPOLCAT(D5,D6,D7) and D4 has RSETCAT(D5,D6,D7,D3)
--R         
--R
--RExamples of outputArgs from NormalizationPackage
--R
--E 2110

--S 2111 of 3320
)d op outputAsFortran
--R 
--R
--RThere are 8 exposed functions called outputAsFortran :
--R   [1]  -> Void from Asp12(D2) if D2: SYMBOL
--R   [2]  -> Void from Asp29(D2) if D2: SYMBOL
--R   [3]  -> Void from Asp33(D2) if D2: SYMBOL
--R   [4] D -> Void from D if D has FORTCAT
--R   [5] FileName -> Void from FortranPackage
--R   [6] (String,OutputForm) -> Void from SpecialOutputPackage
--R   [7] OutputForm -> Void from SpecialOutputPackage
--R   [8] List(OutputForm) -> Void from SpecialOutputPackage
--R
--RExamples of outputAsFortran from Asp12
--R
--R
--RExamples of outputAsFortran from Asp29
--R
--R
--RExamples of outputAsFortran from Asp33
--R
--R
--RExamples of outputAsFortran from FortranProgramCategory
--R
--R
--RExamples of outputAsFortran from FortranPackage
--R
--R
--RExamples of outputAsFortran from SpecialOutputPackage
--R
--E 2111

--S 2112 of 3320
)d op outputAsScript
--R 
--R
--RThere are 2 exposed functions called outputAsScript :
--R   [1] OutputForm -> Void from SpecialOutputPackage
--R   [2] List(OutputForm) -> Void from SpecialOutputPackage
--R
--RExamples of outputAsScript from SpecialOutputPackage
--R
--E 2112

--S 2113 of 3320
)d op outputAsTex
--R 
--R
--RThere are 2 exposed functions called outputAsTex :
--R   [1] OutputForm -> Void from SpecialOutputPackage
--R   [2] List(OutputForm) -> Void from SpecialOutputPackage
--R
--RExamples of outputAsTex from SpecialOutputPackage
--R
--E 2113

--S 2114 of 3320
)d op outputFixed
--R 
--R
--RThere are 2 exposed functions called outputFixed :
--R   [1] NonNegativeInteger -> Void from Float
--R   [2]  -> Void from Float
--R
--RExamples of outputFixed from Float
--R
--E 2114

--S 2115 of 3320
)d op outputFloating
--R 
--R
--RThere are 2 exposed functions called outputFloating :
--R   [1] NonNegativeInteger -> Void from Float
--R   [2]  -> Void from Float
--R
--RExamples of outputFloating from Float
--R
--E 2115

--S 2116 of 3320
)d op outputForm
--R 
--R
--RThere are 7 unexposed functions called outputForm :
--R   [1] (ListMonoidOps(D4,D5,D6),((OutputForm,OutputForm) -> OutputForm)
--R            ,((OutputForm,OutputForm) -> OutputForm),Integer) -> OutputForm
--R             from ListMonoidOps(D4,D5,D6)
--R             if D4 has SETCAT and D5 has ABELMON and D6: D5
--R   [2] (SparseUnivariateSkewPolynomial(D2,D3,D4),OutputForm) -> 
--R            OutputForm
--R             from SparseUnivariateSkewPolynomial(D2,D3,D4)
--R             if D2 has RING and D3: AUTOMOR(D2) and D4: (D2 -> D2)
--R   [3] DoubleFloat -> OutputForm from OutputForm
--R   [4] String -> OutputForm from OutputForm
--R   [5] Symbol -> OutputForm from OutputForm
--R   [6] Integer -> OutputForm from OutputForm
--R   [7] (SparseUnivariatePolynomial(D2),OutputForm) -> OutputForm
--R             from SparseUnivariatePolynomial(D2) if D2 has RING
--R
--RExamples of outputForm from ListMonoidOps
--R
--R
--RExamples of outputForm from SparseUnivariateSkewPolynomial
--R
--R
--RExamples of outputForm from OutputForm
--R
--R
--RExamples of outputForm from SparseUnivariatePolynomial
--R
--E 2116

--S 2117 of 3320
)d op outputGeneral
--R 
--R
--RThere are 2 exposed functions called outputGeneral :
--R   [1] NonNegativeInteger -> Void from Float
--R   [2]  -> Void from Float
--R
--RExamples of outputGeneral from Float
--R
--E 2117

--S 2118 of 3320
)d op outputList
--R 
--R
--RThere is one exposed function called outputList :
--R   [1] List(Any) -> Void from OutputPackage
--R
--RExamples of outputList from OutputPackage
--R
--E 2118

--S 2119 of 3320
)d op outputMeasure
--R 
--R
--RThere is one exposed function called outputMeasure :
--R   [1] Float -> String from ExpertSystemToolsPackage
--R
--RExamples of outputMeasure from ExpertSystemToolsPackage
--R
--E 2119

--S 2120 of 3320
)d op outputSpacing
--R 
--R
--RThere is one exposed function called outputSpacing :
--R   [1] NonNegativeInteger -> Void from Float
--R
--RExamples of outputSpacing from Float
--R
--E 2120

--S 2121 of 3320
)d op over
--R 
--R
--RThere is one unexposed function called over :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of over from OutputForm
--R
--E 2121

--S 2122 of 3320
)d op overbar
--R 
--R
--RThere is one unexposed function called overbar :
--R   [1] OutputForm -> OutputForm from OutputForm
--R
--RExamples of overbar from OutputForm
--R
--E 2122

--S 2123 of 3320
)d op overlabel
--R 
--R
--RThere is one unexposed function called overlabel :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of overlabel from OutputForm
--R
--E 2123

--S 2124 of 3320
)d op overlap
--R 
--R
--RThere are 2 unexposed functions called overlap :
--R   [1] (FreeMonoid(D2),FreeMonoid(D2)) -> Record(lm: FreeMonoid(D2),mm
--R            : FreeMonoid(D2),rm: FreeMonoid(D2))
--R             from FreeMonoid(D2) if D2 has SETCAT
--R   [2] (OrderedFreeMonoid(D2),OrderedFreeMonoid(D2)) -> Record(lm: 
--R            OrderedFreeMonoid(D2),mm: OrderedFreeMonoid(D2),rm: 
--R            OrderedFreeMonoid(D2))
--R             from OrderedFreeMonoid(D2) if D2 has ORDSET
--R
--RExamples of overlap from FreeMonoid
--R
--R
--RExamples of overlap from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rm2:=(x*y)$OFMONOID(Symbol) 
--Roverlap(m1,m2)
--R
--E 2124

--S 2125 of 3320
)d op overset?
--R 
--R
--RThere is one unexposed function called overset? :
--R   [1] (List(D7),List(List(D7))) -> Boolean
--R             from ParametricLinearEquations(D4,D5,D6,D7)
--R             if D7 has POLYCAT(D4,D6,D5) and D4 has Join(
--R            EuclideanDomain,CharacteristicZero) and D5 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D6 has OAMONS
--R
--RExamples of overset? from ParametricLinearEquations
--R
--E 2125

--S 2126 of 3320
)d op pack!
--R 
--R
--RThere are 2 exposed functions called pack! :
--R   [1] KeyedAccessFile(D1) -> KeyedAccessFile(D1) from KeyedAccessFile(
--R            D1)
--R             if D1 has SETCAT
--R   [2] Library -> Library from Library
--R
--RExamples of pack! from KeyedAccessFile
--R
--R
--RExamples of pack! from Library
--R
--E 2126

--S 2127 of 3320
)d op packageCall
--R 
--R
--RThere is one unexposed function called packageCall :
--R   [1] Symbol -> InputForm from InputFormFunctions1(D3) if D3 has TYPE
--R            
--R
--RExamples of packageCall from InputFormFunctions1
--R
--E 2127

--S 2128 of 3320
)d op packExps
--R 
--R
--RThere is one exposed function called packExps :
--R   [1] (Integer,Integer,D3) -> SortedExponentVector from D
--R             if D has MAGCDOC(D4,D3) and D4 has TYPE and D3 has TYPE
--R         
--R
--RExamples of packExps from ModularAlgebraicGcdOperations
--R
--E 2128

--S 2129 of 3320
)d op packModulus
--R 
--R
--RThere is one exposed function called packModulus :
--R   [1] (List(Polynomial(Integer)),List(Symbol),Integer) -> Union(D1,
--R            "failed")
--R             from D if D has MAGCDOC(D5,D1) and D5 has TYPE and D1 has 
--R            TYPE
--R
--RExamples of packModulus from ModularAlgebraicGcdOperations
--R
--E 2129

--S 2130 of 3320
)d op pade
--R 
--R
--RThere are 2 exposed functions called pade :
--R   [1] (NonNegativeInteger,NonNegativeInteger,UnivariateTaylorSeries(D4
--R            ,D5,D6),UnivariateTaylorSeries(D4,D5,D6)) -> Union(Fraction(
--R            UnivariatePolynomial(D5,D4)),"failed")
--R             from PadeApproximantPackage(D4,D5,D6)
--R             if D4 has FIELD and D5: SYMBOL and D6: D4
--R   [2] (NonNegativeInteger,NonNegativeInteger,UnivariateTaylorSeries(D4
--R            ,D5,D6)) -> Union(Fraction(UnivariatePolynomial(D5,D4)),"failed")
--R             from PadeApproximantPackage(D4,D5,D6)
--R             if D4 has FIELD and D5: SYMBOL and D6: D4
--R
--RThere is one unexposed function called pade :
--R   [1] (NonNegativeInteger,NonNegativeInteger,D3,D3) -> Union(Fraction(
--R            D5),"failed")
--R             from PadeApproximants(D4,D3,D5)
--R             if D4 has FIELD and D3 has UTSCAT(D4) and D5 has UPOLYC(D4
--R            )
--R
--RExamples of pade from PadeApproximants
--R
--R
--RExamples of pade from PadeApproximantPackage
--R
--E 2130

--S 2131 of 3320
)d op padecf
--R 
--R
--RThere is one unexposed function called padecf :
--R   [1] (NonNegativeInteger,NonNegativeInteger,D3,D3) -> Union(
--R            ContinuedFraction(D5),"failed")
--R             from PadeApproximants(D4,D3,D5)
--R             if D4 has FIELD and D3 has UTSCAT(D4) and D5 has UPOLYC(D4
--R            )
--R
--RExamples of padecf from PadeApproximants
--R
--E 2131

--S 2132 of 3320
)d op padicallyExpand
--R 
--R
--RThere is one exposed function called padicallyExpand :
--R   [1] (D2,D2) -> SparseUnivariatePolynomial(D2) from PartialFraction(
--R            D2)
--R             if D2 has EUCDOM
--R
--RExamples of padicallyExpand from PartialFraction
--R
--E 2132

--S 2133 of 3320 done
)d op padicFraction
--R 
--R
--RThere is one exposed function called padicFraction :
--R   [1] PartialFraction(D1) -> PartialFraction(D1) from PartialFraction(
--R            D1)
--R             if D1 has EUCDOM
--R
--RExamples of padicFraction from PartialFraction
--R
--Ra:=partialFraction(1,factorial 10) 
--RpadicFraction(a)
--R
--E 2133

--S 2134 of 3320
)d op pair?
--R 
--R
--RThere is one exposed function called pair? :
--R   [1] D -> Boolean from D
--R             if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R
--RExamples of pair? from SExpressionCategory
--R
--E 2134

--S 2135 of 3320
)d op palgextint
--R 
--R
--RThere is one unexposed function called palgextint :
--R   [1] (D2,Kernel(D2),Kernel(D2),D2) -> Union(Record(ratpart: D2,coeff
--R            : D2),"failed")
--R             from PureAlgebraicIntegration(D4,D2,D5)
--R             if D2 has Join(FunctionSpace(D4),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D4 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D5 has SETCAT
--R
--RExamples of palgextint from PureAlgebraicIntegration
--R
--E 2135

--S 2136 of 3320
)d op palgextint0
--R 
--R
--RThere are 2 unexposed functions called palgextint0 :
--R   [1] (D2,Kernel(D2),Kernel(D2),D2,D2,SparseUnivariatePolynomial(D2))
--R             -> Union(Record(ratpart: D2,coeff: D2),"failed")
--R             from GenusZeroIntegration(D5,D2,D6)
--R             if D2 has Join(FunctionSpace(D5),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D5 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D6 has SETCAT
--R   [2] (D2,Kernel(D2),Kernel(D2),D2,Kernel(D2),D2,Fraction(
--R            SparseUnivariatePolynomial(D2))) -> Union(Record(ratpart: D2,
--R            coeff: D2),"failed")
--R             from GenusZeroIntegration(D5,D2,D6)
--R             if D2 has Join(FunctionSpace(D5),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D5 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D6 has SETCAT
--R
--RExamples of palgextint0 from GenusZeroIntegration
--R
--E 2136

--S 2137 of 3320
)d op palginfieldint
--R 
--R
--RThere is one unexposed function called palginfieldint :
--R   [1] (D1,(D5 -> D5)) -> Union(D1,"failed")
--R             from AlgebraicIntegrate(D3,D4,D5,D6,D1)
--R             if D5 has UPOLYC(D4) and D4 has Join(
--R            AlgebraicallyClosedField,FunctionSpace(D3)) and D3 has Join
--R            (OrderedSet,IntegralDomain,RetractableTo(Integer)) and D6
--R             has UPOLYC(FRAC(D5)) and D1 has FFCAT(D4,D5,D6)
--R
--RExamples of palginfieldint from AlgebraicIntegrate
--R
--E 2137

--S 2138 of 3320
)d op palgint
--R 
--R
--RThere is one unexposed function called palgint :
--R   [1] (D2,Kernel(D2),Kernel(D2)) -> IntegrationResult(D2)
--R             from PureAlgebraicIntegration(D4,D2,D5)
--R             if D2 has Join(FunctionSpace(D4),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D4 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D5 has SETCAT
--R
--RExamples of palgint from PureAlgebraicIntegration
--R
--E 2138

--S 2139 of 3320
)d op palgint0
--R 
--R
--RThere are 2 unexposed functions called palgint0 :
--R   [1] (D2,Kernel(D2),Kernel(D2),D2,SparseUnivariatePolynomial(D2)) -> 
--R            IntegrationResult(D2)
--R             from GenusZeroIntegration(D5,D2,D6)
--R             if D2 has Join(FunctionSpace(D5),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D5 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D6 has SETCAT
--R   [2] (D2,Kernel(D2),Kernel(D2),Kernel(D2),D2,Fraction(
--R            SparseUnivariatePolynomial(D2))) -> IntegrationResult(D2)
--R             from GenusZeroIntegration(D5,D2,D6)
--R             if D2 has Join(FunctionSpace(D5),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D5 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D6 has SETCAT
--R
--RExamples of palgint0 from GenusZeroIntegration
--R
--E 2139

--S 2140 of 3320
)d op palgintegrate
--R 
--R
--RThere is one unexposed function called palgintegrate :
--R   [1] (D2,(D6 -> D6)) -> IntegrationResult(D2)
--R             from AlgebraicIntegrate(D4,D5,D6,D7,D2)
--R             if D6 has UPOLYC(D5) and D5 has Join(
--R            AlgebraicallyClosedField,FunctionSpace(D4)) and D4 has Join
--R            (OrderedSet,IntegralDomain,RetractableTo(Integer)) and D7
--R             has UPOLYC(FRAC(D6)) and D2 has FFCAT(D5,D6,D7)
--R
--RExamples of palgintegrate from AlgebraicIntegrate
--R
--E 2140

--S 2141 of 3320
)d op palglimint
--R 
--R
--RThere is one unexposed function called palglimint :
--R   [1] (D2,Kernel(D2),Kernel(D2),List(D2)) -> Union(Record(mainpart: D2
--R            ,limitedlogs: List(Record(coeff: D2,logand: D2))),"failed")
--R             from PureAlgebraicIntegration(D5,D2,D6)
--R             if D2 has Join(FunctionSpace(D5),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D5 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D6 has SETCAT
--R
--RExamples of palglimint from PureAlgebraicIntegration
--R
--E 2141

--S 2142 of 3320
)d op palglimint0
--R 
--R
--RThere are 2 unexposed functions called palglimint0 :
--R   [1] (D2,Kernel(D2),Kernel(D2),List(D2),D2,SparseUnivariatePolynomial
--R            (D2)) -> Union(Record(mainpart: D2,limitedlogs: List(Record(coeff
--R            : D2,logand: D2))),"failed")
--R             from GenusZeroIntegration(D6,D2,D7)
--R             if D2 has Join(FunctionSpace(D6),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D6 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D7 has SETCAT
--R   [2] (D2,Kernel(D2),Kernel(D2),List(D2),Kernel(D2),D2,Fraction(
--R            SparseUnivariatePolynomial(D2))) -> Union(Record(mainpart: D2,
--R            limitedlogs: List(Record(coeff: D2,logand: D2))),"failed")
--R             from GenusZeroIntegration(D6,D2,D7)
--R             if D2 has Join(FunctionSpace(D6),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D6 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D7 has SETCAT
--R
--RExamples of palglimint0 from GenusZeroIntegration
--R
--E 2142

--S 2143 of 3320
)d op palgLODE
--R 
--R
--RThere is one unexposed function called palgLODE :
--R   [1] (D2,D3,Kernel(D3),Kernel(D3),Symbol) -> Record(particular: Union
--R            (D3,"failed"),basis: List(D3))
--R             from PureAlgebraicIntegration(D6,D3,D2)
--R             if D3 has Join(FunctionSpace(D6),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D6 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D2 has LODOCAT(D3) 
--R            and D2 has SETCAT
--R
--RExamples of palgLODE from PureAlgebraicIntegration
--R
--E 2143

--S 2144 of 3320
)d op palgLODE0
--R 
--R
--RThere are 2 unexposed functions called palgLODE0 :
--R   [1] (D2,D3,Kernel(D3),Kernel(D3),D3,SparseUnivariatePolynomial(D3))
--R             -> Record(particular: Union(D3,"failed"),basis: List(D3))
--R             from GenusZeroIntegration(D6,D3,D2)
--R             if D3 has Join(FunctionSpace(D6),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D6 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D2 has LODOCAT(D3) 
--R            and D2 has SETCAT
--R   [2] (D2,D3,Kernel(D3),Kernel(D3),Kernel(D3),D3,Fraction(
--R            SparseUnivariatePolynomial(D3))) -> Record(particular: Union(D3,
--R            "failed"),basis: List(D3))
--R             from GenusZeroIntegration(D6,D3,D2)
--R             if D3 has Join(FunctionSpace(D6),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D6 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D2 has LODOCAT(D3) 
--R            and D2 has SETCAT
--R
--RExamples of palgLODE0 from GenusZeroIntegration
--R
--E 2144

--S 2145 of 3320
)d op palgRDE
--R 
--R
--RThere is one unexposed function called palgRDE :
--R   [1] (D1,D1,D1,Kernel(D1),Kernel(D1),((D1,D1,Symbol) -> Union(D1,
--R            "failed"))) -> Union(D1,"failed")
--R             from PureAlgebraicIntegration(D4,D1,D5)
--R             if D1 has Join(FunctionSpace(D4),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D4 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D5 has SETCAT
--R
--RExamples of palgRDE from PureAlgebraicIntegration
--R
--E 2145

--S 2146 of 3320
)d op palgRDE0
--R 
--R
--RThere are 2 unexposed functions called palgRDE0 :
--R   [1] (D1,D1,Kernel(D1),Kernel(D1),((D1,D1,Symbol) -> Union(D1,
--R            "failed")),D1,SparseUnivariatePolynomial(D1)) -> Union(D1,
--R            "failed")
--R             from GenusZeroIntegration(D5,D1,D6)
--R             if D1 has Join(FunctionSpace(D5),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D5 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D6 has SETCAT
--R   [2] (D1,D1,Kernel(D1),Kernel(D1),((D1,D1,Symbol) -> Union(D1,
--R            "failed")),Kernel(D1),D1,Fraction(SparseUnivariatePolynomial(D1))
--R            ) -> Union(D1,"failed")
--R             from GenusZeroIntegration(D5,D1,D6)
--R             if D1 has Join(FunctionSpace(D5),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D5 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D6 has SETCAT
--R
--RExamples of palgRDE0 from GenusZeroIntegration
--R
--E 2146

--S 2147 of 3320
)d op parabolic
--R 
--R
--RThere is one exposed function called parabolic :
--R   [1] Point(D2) -> Point(D2) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of parabolic from CoordinateSystems
--R
--E 2147

--S 2148 of 3320
)d op parabolicCylindrical
--R 
--R
--RThere is one exposed function called parabolicCylindrical :
--R   [1] Point(D2) -> Point(D2) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of parabolicCylindrical from CoordinateSystems
--R
--E 2148

--S 2149 of 3320
)d op paraboloidal
--R 
--R
--RThere is one exposed function called paraboloidal :
--R   [1] Point(D2) -> Point(D2) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of paraboloidal from CoordinateSystems
--R
--E 2149

--S 2150 of 3320
)d op parametersOf
--R 
--R
--RThere is one exposed function called parametersOf :
--R   [1] SymbolTable -> List(Symbol) from SymbolTable
--R
--RExamples of parametersOf from SymbolTable
--R
--E 2150

--S 2151 of 3320
)d op parametric?
--R 
--R
--RThere is one unexposed function called parametric? :
--R   [1] Plot -> Boolean from Plot
--R
--RExamples of parametric? from Plot
--R
--E 2151

--S 2152 of 3320
)d op parametrize
--R 
--R
--RThere are 7 exposed functions called parametrize :
--R   [1] (D5,D6) -> D4
--R             from GeneralPackageForAlgebraicFunctionField(D7,D8,D5,D9,
--R            D10,D4,D6,D11,D1,D2,D3)
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D5 has POLYCAT(D7
--R            ,D9,OVAR(D8)) and D9 has DIRPCAT(#(D8),NNI) and D10 has 
--R            PRSPCAT(D7) and D6 has PLACESC(D7,D4) and D11 has DIVCAT(D6
--R            ) and D1 has INFCLCT(D7,D8,D5,D9,D10,D4,D6,D11,D3) and D3
--R             has BLMETCT and D4 has LOCPOWC(D7) and D2 has DSTRCAT(D1)
--R            
--R   [2] (DistributedMultivariatePolynomial(D5,D4),
--R            PlacesOverPseudoAlgebraicClosureOfFiniteField(D4)) -> 
--R            NeitherSparseOrDensePowerSeries(
--R            PseudoAlgebraicClosureOfFiniteField(D4))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D4,D5
--R            ,D6)
--R             if D4 has FFIELDC and D5: LIST(SYMBOL) and D6 has BLMETCT
--R            
--R   [3] (DistributedMultivariatePolynomial(D5,D4),Places(D4)) -> 
--R            NeitherSparseOrDensePowerSeries(D4)
--R             from PackageForAlgebraicFunctionField(D4,D5,D6)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D6 has BLMETCT
--R         
--R   [4] (D2,List(D1)) -> D1 from ParametrizationPackage(D4,D5,D2,D6,D7,
--R            D1,D8)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D6 has DIRPCAT(#(
--R            D5),NNI) and D1 has LOCPOWC(D4) and D2 has POLYCAT(D4,D6,
--R            OVAR(D5)) and D7 has PRSPCAT(D4) and D8 has PLACESC(D4,D1)
--R            
--R   [5] (D2,D3) -> D1 from ParametrizationPackage(D4,D5,D2,D6,D7,D1,D3)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D6 has DIRPCAT(#(
--R            D5),NNI) and D1 has LOCPOWC(D4) and D2 has POLYCAT(D4,D6,
--R            OVAR(D5)) and D7 has PRSPCAT(D4) and D3 has PLACESC(D4,D1)
--R            
--R   [6] (D2,D2,D3) -> D1 from ParametrizationPackage(D4,D5,D2,D6,D7,D1,
--R            D3)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D6 has DIRPCAT(#(
--R            D5),NNI) and D1 has LOCPOWC(D4) and D2 has POLYCAT(D4,D6,
--R            OVAR(D5)) and D7 has PRSPCAT(D4) and D3 has PLACESC(D4,D1)
--R            
--R   [7] (D2,D3,Integer) -> D1 from ParametrizationPackage(D5,D6,D2,D7,D8
--R            ,D1,D3)
--R             if D5 has FIELD and D6: LIST(SYMBOL) and D7 has DIRPCAT(#(
--R            D6),NNI) and D1 has LOCPOWC(D5) and D2 has POLYCAT(D5,D7,
--R            OVAR(D6)) and D8 has PRSPCAT(D5) and D3 has PLACESC(D5,D1)
--R            
--R
--RExamples of parametrize from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of parametrize from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of parametrize from PackageForAlgebraicFunctionField
--R
--R
--RExamples of parametrize from ParametrizationPackage
--R
--E 2152

--S 2153 of 3320
)d op ParCond
--R 
--R
--RThere is one unexposed function called ParCond :
--R   [1] (Matrix(D7),NonNegativeInteger) -> List(Record(det: D7,rows: 
--R            List(Integer),cols: List(Integer)))
--R             from ParametricLinearEquations(D4,D5,D6,D7)
--R             if D7 has POLYCAT(D4,D6,D5) and D4 has Join(
--R            EuclideanDomain,CharacteristicZero) and D5 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D6 has OAMONS
--R
--RExamples of ParCond from ParametricLinearEquations
--R
--E 2153

--S 2154 of 3320
)d op ParCondList
--R 
--R
--RThere is one unexposed function called ParCondList :
--R   [1] (Matrix(D7),NonNegativeInteger) -> List(Record(rank: 
--R            NonNegativeInteger,eqns: List(Record(det: D7,rows: List(Integer),
--R            cols: List(Integer))),fgb: List(D7)))
--R             from ParametricLinearEquations(D4,D5,D6,D7)
--R             if D7 has POLYCAT(D4,D6,D5) and D4 has Join(
--R            EuclideanDomain,CharacteristicZero) and D5 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D6 has OAMONS
--R
--RExamples of ParCondList from ParametricLinearEquations
--R
--E 2154

--S 2155 of 3320
)d op paren
--R 
--R
--RThere are 2 exposed functions called paren :
--R   [1] List(D) -> D from D if D has ES
--R   [2] D -> D from D if D has ES
--R
--RThere are 2 unexposed functions called paren :
--R   [1] List(OutputForm) -> OutputForm from OutputForm
--R   [2] OutputForm -> OutputForm from OutputForm
--R
--RExamples of paren from ExpressionSpace
--R
--R
--RExamples of paren from OutputForm
--R
--E 2155

--S 2156 of 3320
)d op parent
--R 
--R
--RThere is one unexposed function called parent :
--R   [1] SubSpace(D1,D2) -> SubSpace(D1,D2) from SubSpace(D1,D2)
--R             if D1: PI and D2 has RING
--R
--RExamples of parent from SubSpace
--R
--E 2156

--S 2157 of 3320
)d op parse
--R 
--R
--RThere is one unexposed function called parse :
--R   [1] String -> InputForm from InputForm
--R
--RExamples of parse from InputForm
--R
--E 2157

--S 2158 of 3320
)d op partialDenominators
--R 
--R
--RThere is one exposed function called partialDenominators :
--R   [1] ContinuedFraction(D2) -> Stream(D2) from ContinuedFraction(D2)
--R             if D2 has EUCDOM
--R
--RExamples of partialDenominators from ContinuedFraction
--R
--E 2158

--S 2159 of 3320 done
)d op partialFraction
--R 
--R
--RThere is one exposed function called partialFraction :
--R   [1] (D1,Factored(D1)) -> PartialFraction(D1) from PartialFraction(D1
--R            )
--R             if D1 has EUCDOM
--R
--RThere are 2 unexposed functions called partialFraction :
--R   [1] (Fraction(Polynomial(D4)),Symbol) -> Any from 
--R            PartialFractionPackage(D4)
--R             if D4 has Join(EuclideanDomain,CharacteristicZero)
--R   [2] (Polynomial(D5),Factored(Polynomial(D5)),Symbol) -> Any
--R             from PartialFractionPackage(D5)
--R             if D5 has Join(EuclideanDomain,CharacteristicZero)
--R
--RExamples of partialFraction from PartialFraction
--R
--RpartialFraction(1,factorial 10)
--R
--R
--RExamples of partialFraction from PartialFractionPackage
--R
--Ra:=x+1/(y+1) 
--RpartialFraction(a,y)$PFRPAC(INT)
--R
--E 2159

--S 2160 of 3320
--R--------------- )d op partiallyOrderedSet (what?)
--E 2160

--S 2161 of 3320
)d op partialNumerators
--R 
--R
--RThere is one exposed function called partialNumerators :
--R   [1] ContinuedFraction(D2) -> Stream(D2) from ContinuedFraction(D2)
--R             if D2 has EUCDOM
--R
--RExamples of partialNumerators from ContinuedFraction
--R
--E 2161

--S 2162 of 3320
)d op partialQuotients
--R 
--R
--RThere is one exposed function called partialQuotients :
--R   [1] ContinuedFraction(D2) -> Stream(D2) from ContinuedFraction(D2)
--R             if D2 has EUCDOM
--R
--RExamples of partialQuotients from ContinuedFraction
--R
--E 2162

--S 2163 of 3320
)d op particularSolution
--R 
--R
--RThere are 2 exposed functions called particularSolution :
--R   [1] (Matrix(D3),Vector(D3)) -> Union(Vector(D3),"failed")
--R             from LinearSystemMatrixPackage1(D3) if D3 has FIELD
--R   [2] (D2,D1) -> Union(D1,"failed") from LinearSystemMatrixPackage(D3,
--R            D4,D1,D2)
--R             if D3 has FIELD and D4 has FiniteLinearAggregate(D3)with
--R                 shallowlyMutableand D1 has FiniteLinearAggregate(D3)
--R            with
--R                 shallowlyMutableand D2 has MATCAT(D3,D4,D1)
--R
--RThere are 2 unexposed functions called particularSolution :
--R   [1] (D2,D1,List(D1),(D1 -> D1)) -> Union(D1,"failed") from ODETools(
--R            D1,D2)
--R             if D1 has FIELD and D2 has LODOCAT(D1)
--R   [2] D3 -> D2 from PolynomialSolveByFormulas(D3,D2)
--R             if D2 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D3 has UPOLYC(D2)
--R            
--R
--RExamples of particularSolution from LinearSystemMatrixPackage1
--R
--R
--RExamples of particularSolution from LinearSystemMatrixPackage
--R
--R
--RExamples of particularSolution from ODETools
--R
--R
--RExamples of particularSolution from PolynomialSolveByFormulas
--R
--E 2163

--S 2164 of 3320
)d op partition
--R 
--R
--RThere is one exposed function called partition :
--R   [1] D1 -> D1 from IntegerCombinatoricFunctions(D1) if D1 has INS
--R
--RThere is one unexposed function called partition :
--R   [1] List(Integer) -> Partition from Partition
--R
--RExamples of partition from IntegerCombinatoricFunctions
--R
--R
--RExamples of partition from Partition
--R
--E 2164

--S 2165 of 3320
)d op partitions
--R 
--R
--RThere are 3 exposed functions called partitions :
--R   [1] (Integer,Integer,Integer) -> Stream(List(Integer))
--R             from PartitionsAndPermutations
--R   [2] Integer -> Stream(List(Integer)) from PartitionsAndPermutations
--R            
--R   [3] (Integer,Integer) -> Stream(List(Integer)) from 
--R            PartitionsAndPermutations
--R
--RExamples of partitions from PartitionsAndPermutations
--R
--E 2165

--S 2166 of 3320
)d op parts
--R 
--R
--RThere are 7 exposed functions called parts :
--R   [1] D -> List(D2) from D
--R             if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has 
--R            FLAGG(D2) and D4 has FLAGG(D2)
--R   [2] ArrayStack(D2) -> List(D2) from ArrayStack(D2)
--R             if $ has finiteAggregate and D2 has SETCAT
--R   [3] Dequeue(D2) -> List(D2) from Dequeue(D2)
--R             if $ has finiteAggregate and D2 has SETCAT
--R   [4] Heap(D2) -> List(D2) from Heap(D2) if $ has finiteAggregate and 
--R            D2 has ORDSET
--R   [5] D -> List(D2) from D
--R             if D has finiteAggregate and D has HOAGG(D2) and D2 has 
--R            TYPE
--R   [6] Queue(D2) -> List(D2) from Queue(D2)
--R             if $ has finiteAggregate and D2 has SETCAT
--R   [7] Stack(D2) -> List(D2) from Stack(D2)
--R             if $ has finiteAggregate and D2 has SETCAT
--R
--RExamples of parts from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rparts(arr)
--R
--R
--RExamples of parts from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rparts a
--R
--R
--RExamples of parts from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rparts a
--R
--R
--RExamples of parts from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rparts a
--R
--R
--RExamples of parts from HomogeneousAggregate
--R
--R
--RExamples of parts from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rparts a
--R
--R
--RExamples of parts from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rparts a
--R
--E 2166

--S 2167 of 3320
)d op pascalTriangle
--R 
--R
--RThere is one unexposed function called pascalTriangle :
--R   [1] (NonNegativeInteger,Integer) -> D1 from GaloisGroupUtilities(D1)
--R             if D1 has RING
--R
--RExamples of pascalTriangle from GaloisGroupUtilities
--R
--E 2167

--S 2168 of 3320
)d op pastel
--R 
--R
--RThere is one exposed function called pastel :
--R   [1] Color -> Palette from Palette
--R
--RExamples of pastel from Palette
--R
--E 2168

--S 2169 of 3320
)d op pattern
--R 
--R
--RThere is one exposed function called pattern :
--R   [1] RewriteRule(D2,D3,D4) -> Pattern(D2) from RewriteRule(D2,D3,D4)
--R             if D2 has SETCAT and D3 has Join(Ring,PatternMatchable(D2)
--R            ,OrderedSet,ConvertibleTo(Pattern(D2))) and D4 has Join(
--R            FunctionSpace(D3),PatternMatchable(D2),ConvertibleTo(
--R            Pattern(D2)))
--R
--RExamples of pattern from RewriteRule
--R
--E 2169

--S 2170 of 3320
)d op patternMatch
--R 
--R
--RThere is one exposed function called patternMatch :
--R   [1] (D,Pattern(D3),PatternMatchResult(D3,D)) -> PatternMatchResult(
--R            D3,D)
--R             from D if D has PATMAB(D3) and D3 has SETCAT
--R
--RThere are 11 unexposed functions called patternMatch :
--R   [1] (D2,Pattern(D4),PatternMatchResult(D4,D2)) -> PatternMatchResult
--R            (D4,D2)
--R             from ComplexPatternMatch(D4,D5,D2)
--R             if D4 has SETCAT and D2 has COMPCAT(D5) and Polynomial(D5)
--R             has PATMAB(D4) and D5 has Join(PatternMatchable(D4),
--R            CommutativeRing)
--R   [2] (D2,Pattern(D4),PatternMatchResult(D4,D5)) -> PatternMatchResult
--R            (D4,D5)
--R             from PatternMatchPushDown(D4,D2,D5)
--R             if D4 has SETCAT and D5 has Join(SetCategory,RetractableTo
--R            (D2)) and D2 has PATMAB(D4)
--R   [3] (D2,Pattern(D4),PatternMatchResult(D4,D2)) -> PatternMatchResult
--R            (D4,D2)
--R             from PatternMatchFunctionSpace(D4,D5,D2)
--R             if D4 has SETCAT and D2 has Join(FunctionSpace(D5),
--R            ConvertibleTo(Pattern(D4)),PatternMatchable(D4),
--R            RetractableTo(Kernel($))) and D5 has Join(IntegralDomain,
--R            OrderedSet,PatternMatchable(D4))
--R   [4] (D2,Pattern(Integer),PatternMatchResult(Integer,D2)) -> 
--R            PatternMatchResult(Integer,D2)
--R             from PatternMatchIntegerNumberSystem(D2) if D2 has INS
--R   [5] (Kernel(D5),Pattern(D4),PatternMatchResult(D4,D5)) -> 
--R            PatternMatchResult(D4,D5)
--R             from PatternMatchKernel(D4,D5)
--R             if D4 has SETCAT and D5 has Join(OrderedSet,RetractableTo(
--R            Kernel($)),ConvertibleTo(Pattern(D4)),PatternMatchable(D4))
--R            
--R   [6] (D2,Pattern(D4),PatternMatchListResult(D4,D5,D2)) -> 
--R            PatternMatchListResult(D4,D5,D2)
--R             from PatternMatchListAggregate(D4,D5,D2)
--R             if D4 has SETCAT and D5 has PATMAB(D4) and D2 has LSAGG(D5
--R            )
--R   [7] (D2,Pattern(D5),PatternMatchResult(D5,D2),((D7,Pattern(D5),
--R            PatternMatchResult(D5,D2)) -> PatternMatchResult(D5,D2))) -> 
--R            PatternMatchResult(D5,D2)
--R             from PatternMatchPolynomialCategory(D5,D6,D7,D8,D2)
--R             if D7 has ORDSET and D5 has SETCAT and D2 has Join(
--R            PolynomialCategory(D8,D6,D7),ConvertibleTo(Pattern(D5))) 
--R            and D6 has OAMONS and D8 has Join(Ring,OrderedSet,
--R            PatternMatchable(D5))
--R   [8] (D2,Pattern(D4),PatternMatchResult(D4,D2)) -> PatternMatchResult
--R            (D4,D2)
--R             from PatternMatchPolynomialCategory(D4,D5,D6,D7,D2)
--R             if D4 has SETCAT and D2 has Join(PolynomialCategory(D7,D5,
--R            D6),ConvertibleTo(Pattern(D4))) and D6 has PATMAB(D4) and 
--R            D5 has OAMONS and D6 has ORDSET and D7 has Join(Ring,
--R            OrderedSet,PatternMatchable(D4))
--R   [9] (D2,Pattern(D4),PatternMatchResult(D4,D2)) -> PatternMatchResult
--R            (D4,D2)
--R             from PatternMatchQuotientFieldCategory(D4,D5,D2)
--R             if D4 has SETCAT and D2 has QFCAT(D5) and D5 has Join(
--R            IntegralDomain,PatternMatchable(D4),ConvertibleTo(Pattern(
--R            D4)))
--R   [10] (Symbol,Pattern(D4),PatternMatchResult(D4,Symbol)) -> 
--R            PatternMatchResult(D4,Symbol)
--R             from PatternMatchSymbol(D4) if D4 has SETCAT
--R   [11] (List(D8),List(Pattern(D6)),(List(D8) -> D8),PatternMatchResult
--R            (D6,D8),((D8,Pattern(D6),PatternMatchResult(D6,D8)) -> 
--R            PatternMatchResult(D6,D8))) -> PatternMatchResult(D6,D8)
--R             from PatternMatchTools(D6,D7,D8)
--R             if D6 has SETCAT and D8 has Join(Ring,ConvertibleTo(
--R            Pattern(D6)),RetractableTo(D7)) and D7 has Join(Ring,
--R            OrderedSet)
--R
--RExamples of patternMatch from ComplexPatternMatch
--R
--R
--RExamples of patternMatch from PatternMatchable
--R
--R
--RExamples of patternMatch from PatternMatchPushDown
--R
--R
--RExamples of patternMatch from PatternMatchFunctionSpace
--R
--R
--RExamples of patternMatch from PatternMatchIntegerNumberSystem
--R
--R
--RExamples of patternMatch from PatternMatchKernel
--R
--R
--RExamples of patternMatch from PatternMatchListAggregate
--R
--R
--RExamples of patternMatch from PatternMatchPolynomialCategory
--R
--R
--RExamples of patternMatch from PatternMatchQuotientFieldCategory
--R
--R
--RExamples of patternMatch from PatternMatchSymbol
--R
--R
--RExamples of patternMatch from PatternMatchTools
--R
--E 2170

--S 2171 of 3320
)d op patternVariable
--R 
--R
--RThere is one unexposed function called patternVariable :
--R   [1] (Symbol,Boolean,Boolean,Boolean) -> Pattern(D3) from Pattern(D3)
--R             if D3 has SETCAT
--R
--RExamples of patternVariable from Pattern
--R
--E 2171

--S 2172 of 3320
)d op pdct
--R 
--R
--RThere is one unexposed function called pdct :
--R   [1] Partition -> Integer from Partition
--R
--RExamples of pdct from Partition
--R
--E 2172

--S 2173 of 3320
)d op PDESolve
--R 
--R
--RThere is one exposed function called PDESolve :
--R   [1] Record(pde: List(Expression(DoubleFloat)),constraints: List(
--R            Record(start: DoubleFloat,finish: DoubleFloat,grid: 
--R            NonNegativeInteger,boundaryType: Integer,dStart: Matrix(
--R            DoubleFloat),dFinish: Matrix(DoubleFloat))),f: List(List(
--R            Expression(DoubleFloat))),st: String,tol: DoubleFloat) -> Result
--R             from D if D has PDECAT
--R
--RExamples of PDESolve from PartialDifferentialEquationsSolverCategory
--R
--E 2173

--S 2174 of 3320
)d op pdf2df
--R 
--R
--RThere is one exposed function called pdf2df :
--R   [1] Polynomial(DoubleFloat) -> DoubleFloat from 
--R            ExpertSystemToolsPackage
--R
--RExamples of pdf2df from ExpertSystemToolsPackage
--R
--E 2174

--S 2175 of 3320
)d op pdf2ef
--R 
--R
--RThere is one exposed function called pdf2ef :
--R   [1] Polynomial(DoubleFloat) -> Expression(Float)
--R             from ExpertSystemToolsPackage
--R
--RExamples of pdf2ef from ExpertSystemToolsPackage
--R
--E 2175

--S 2176 of 3320
)d op perfectNthPower?
--R 
--R
--RThere is one exposed function called perfectNthPower? :
--R   [1] (D2,NonNegativeInteger) -> Boolean from IntegerRoots(D2) if D2
--R             has INS
--R
--RExamples of perfectNthPower? from IntegerRoots
--R
--E 2176

--S 2177 of 3320
)d op perfectNthRoot
--R 
--R
--RThere are 2 exposed functions called perfectNthRoot :
--R   [1] (D1,NonNegativeInteger) -> Union(D1,"failed") from IntegerRoots(
--R            D1)
--R             if D1 has INS
--R   [2] D2 -> Record(base: D2,exponent: NonNegativeInteger) from 
--R            IntegerRoots(D2)
--R             if D2 has INS
--R
--RExamples of perfectNthRoot from IntegerRoots
--R
--E 2177

--S 2178 of 3320
)d op perfectSqrt
--R 
--R
--RThere is one exposed function called perfectSqrt :
--R   [1] D1 -> Union(D1,"failed") from IntegerRoots(D1) if D1 has INS
--R
--RExamples of perfectSqrt from IntegerRoots
--R
--E 2178

--S 2179 of 3320
)d op perfectSquare?
--R 
--R
--RThere is one exposed function called perfectSquare? :
--R   [1] D2 -> Boolean from IntegerRoots(D2) if D2 has INS
--R
--RExamples of perfectSquare? from IntegerRoots
--R
--E 2179

--S 2180 of 3320
)d op permanent
--R 
--R
--RThere is one exposed function called permanent :
--R   [1] SquareMatrix(D3,D1) -> D1 from Permanent(D3,D1)
--R             if D3: PI and D1 has Ringwith
--R                 commutative("*")
--R
--RExamples of permanent from Permanent
--R
--E 2180

--S 2181 of 3320
)d op permutation
--R 
--R
--RThere are 2 exposed functions called permutation :
--R   [1] (D,D) -> D from D if D has CFCAT
--R   [2] (D1,D1) -> D1 from IntegerCombinatoricFunctions(D1) if D1 has 
--R            INS
--R
--RThere is one unexposed function called permutation :
--R   [1] (D1,D1) -> D1 from CombinatorialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of permutation from CombinatorialFunctionCategory
--R
--R
--RExamples of permutation from CombinatorialFunction
--R
--R
--RExamples of permutation from IntegerCombinatoricFunctions
--R
--E 2181

--S 2182 of 3320
)d op permutationGroup
--R 
--R
--RThere is one exposed function called permutationGroup :
--R   [1] List(Permutation(D2)) -> PermutationGroup(D2) from 
--R            PermutationGroup(D2)
--R             if D2 has SETCAT
--R
--RExamples of permutationGroup from PermutationGroup
--R
--E 2182

--S 2183 of 3320
)d op permutationRepresentation
--R 
--R
--RThere are 4 exposed functions called permutationRepresentation :
--R   [1] (Permutation(Integer),Integer) -> Matrix(Integer)
--R             from RepresentationPackage1(D4) if D4 has RING
--R   [2] List(Integer) -> Matrix(Integer) from RepresentationPackage1(D3)
--R             if D3 has RING
--R   [3] (List(Permutation(Integer)),Integer) -> List(Matrix(Integer))
--R             from RepresentationPackage1(D4) if D4 has RING
--R   [4] List(List(Integer)) -> List(Matrix(Integer))
--R             from RepresentationPackage1(D3) if D3 has RING
--R
--RExamples of permutationRepresentation from RepresentationPackage1
--R
--E 2183

--S 2184 of 3320
)d op permutations
--R 
--R
--RThere is one exposed function called permutations :
--R   [1] Integer -> Stream(List(Integer)) from PartitionsAndPermutations
--R            
--R
--RExamples of permutations from PartitionsAndPermutations
--R
--E 2184

--S 2185 of 3320
)d op perspective
--R 
--R
--RThere is one exposed function called perspective :
--R   [1] (ThreeDimensionalViewport,String) -> Void from 
--R            ThreeDimensionalViewport
--R
--RExamples of perspective from ThreeDimensionalViewport
--R
--E 2185

--S 2186 of 3320 done
)d op pfaffian
--R 
--R
--RThere is one exposed function called pfaffian :
--R   [1] D -> D1 from D
--R             if D has MATCAT(D1,D2,D3) and D2 has FLAGG(D1) and D3 has 
--R            FLAGG(D1) and D1 has RING and D1 has COMRING
--R
--RExamples of pfaffian from MatrixCategory
--R
--Rpfaffian [[0,1,0,0],[-1,0,0,0],[0,0,0,1],[0,0,-1,0]]
--R
--E 2186

--S 2187 of 3320
)d op phiCoord
--R 
--R
--RThere is one unexposed function called phiCoord :
--R   [1] Point(D1) -> D1 from PointPackage(D1) if D1 has RING
--R
--RExamples of phiCoord from PointPackage
--R
--E 2187

--S 2188 of 3320
)d op physicalLength
--R 
--R
--RThere is one exposed function called physicalLength :
--R   [1] FlexibleArray(D2) -> NonNegativeInteger from FlexibleArray(D2)
--R             if D2 has TYPE
--R
--RThere is one unexposed function called physicalLength :
--R   [1] IndexedFlexibleArray(D2,D3) -> NonNegativeInteger
--R             from IndexedFlexibleArray(D2,D3) if D2 has TYPE and D3: 
--R            INT
--R
--RExamples of physicalLength from FlexibleArray
--R
--R
--RExamples of physicalLength from IndexedFlexibleArray
--R
--RT1:=IndexedFlexibleArray(Integer,20) 
--Rt2:=flexibleArray([i for i in 1..10])$T1 
--RphysicalLength t2
--R
--E 2188

--S 2189 of 3320
)d op physicalLength!
--R 
--R
--RThere is one exposed function called physicalLength! :
--R   [1] (FlexibleArray(D2),Integer) -> FlexibleArray(D2) from 
--R            FlexibleArray(D2)
--R             if D2 has TYPE
--R
--RThere is one unexposed function called physicalLength! :
--R   [1] (IndexedFlexibleArray(D2,D3),Integer) -> IndexedFlexibleArray(D2
--R            ,D3)
--R             from IndexedFlexibleArray(D2,D3) if D2 has TYPE and D3: 
--R            INT
--R
--RExamples of physicalLength! from FlexibleArray
--R
--R
--RExamples of physicalLength! from IndexedFlexibleArray
--R
--RT1:=IndexedFlexibleArray(Integer,20) 
--Rt2:=flexibleArray([i for i in 1..10])$T1 
--RphysicalLength!(t2,15)
--R
--E 2189

--S 2190 of 3320
)d op pi
--R 
--R
--RThere are 3 exposed functions called pi :
--R   [1]  -> FortranExpression(D1,D2,D3) from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R   [2]  -> Pi from Pi
--R   [3]  -> D from D if D has TRANFUN
--R
--RThere is one unexposed function called pi :
--R   [1]  -> D1 from ElementaryFunction(D2,D1)
--R             if D1 has Join(FunctionSpace(D2),RadicalCategory) and D2
--R             has Join(OrderedSet,IntegralDomain)
--R
--RExamples of pi from ElementaryFunction
--R
--R
--RExamples of pi from FortranExpression
--R
--R
--RExamples of pi from Pi
--R
--R
--RExamples of pi from TranscendentalFunctionCategory
--R
--E 2190

--S 2191 of 3320
)d op pile
--R 
--R
--RThere is one unexposed function called pile :
--R   [1] List(OutputForm) -> OutputForm from OutputForm
--R
--RExamples of pile from OutputForm
--R
--E 2191

--S 2192 of 3320
)d op pivot
--R 
--R
--RThere is one exposed function called pivot :
--R   [1] (SparseEchelonMatrix(D3,D4),Integer) -> Record(Index: D3,Entry: 
--R            D4)
--R             from SparseEchelonMatrix(D3,D4) if D3 has ORDSET and D4
--R             has RING
--R
--RExamples of pivot from SparseEchelonMatrix
--R
--E 2192

--S 2193 of 3320
)d op pivots
--R 
--R
--RThere is one exposed function called pivots :
--R   [1] SparseEchelonMatrix(D2,D3) -> Record(Indices: List(D2),Entries: 
--R            List(D3))
--R             from SparseEchelonMatrix(D2,D3) if D2 has ORDSET and D3
--R             has RING
--R
--RExamples of pivots from SparseEchelonMatrix
--R
--E 2193

--S 2194 of 3320
)d op placesAbove
--R 
--R
--RThere are 3 exposed functions called placesAbove :
--R   [1] D6 -> List(D12)
--R             from GeneralPackageForAlgebraicFunctionField(D7,D8,D9,D10,
--R            D6,D11,D12,D1,D2,D3,D4)
--R             if D7 has FIELD and D8: LIST(SYMBOL) and D9 has POLYCAT(D7
--R            ,D10,OVAR(D8)) and D10 has DIRPCAT(#(D8),NNI) and D6 has 
--R            PRSPCAT(D7) and D11 has LOCPOWC(D7) and D12 has PLACESC(D7,
--R            D11) and D1 has DIVCAT(D12) and D2 has INFCLCT(D7,D8,D9,D10
--R            ,D6,D11,D12,D1,D4) and D4 has BLMETCT and D3 has DSTRCAT(D2
--R            )
--R   [2] ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField(D3) -> 
--R            List(PlacesOverPseudoAlgebraicClosureOfFiniteField(D3))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D3,D4
--R            ,D5)
--R             if D3 has FFIELDC and D4: LIST(SYMBOL) and D5 has BLMETCT
--R            
--R   [3] ProjectivePlane(D3) -> List(Places(D3))
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D5 has BLMETCT
--R         
--R
--RExamples of placesAbove from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of placesAbove from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of placesAbove from PackageForAlgebraicFunctionField
--R
--E 2194

--S 2195 of 3320
)d op placesOfDegree
--R 
--R
--RThere are 4 exposed functions called placesOfDegree :
--R   [1] PositiveInteger -> List(D1)
--R             from GeneralPackageForAlgebraicFunctionField(D8,D9,D10,D11
--R            ,D12,D13,D1,D2,D3,D4,D5)
--R             if D8 has FINITE and D8 has FIELD and D9: LIST(SYMBOL) and
--R            D10 has POLYCAT(D8,D11,OVAR(D9)) and D11 has DIRPCAT(#(D9),
--R            NNI) and D12 has PRSPCAT(D8) and D13 has LOCPOWC(D8) and D1
--R             has PLACESC(D8,D13) and D2 has DIVCAT(D1) and D3 has 
--R            INFCLCT(D8,D9,D10,D11,D12,D13,D1,D2,D5) and D5 has BLMETCT 
--R            and D4 has DSTRCAT(D3)
--R   [2] (PositiveInteger,D9,List(D14)) -> Void
--R             from IntersectionDivisorPackage(D11,D12,D9,D13,D14,D1,D2,
--R            D3,D4,D5,D6)
--R             if D14 has PRSPCAT(D11) and D11 has FIELD and D12: LIST(
--R            SYMBOL) and D9 has POLYCAT(D11,D13,OVAR(D12)) and D13 has 
--R            DIRPCAT(#(D12),NNI) and D1 has LOCPOWC(D11) and D2 has 
--R            PLACESC(D11,D1) and D3 has DIVCAT(D2) and D4 has INFCLCT(
--R            D11,D12,D9,D13,D14,D1,D2,D3,D6) and D6 has BLMETCT and D5
--R             has DSTRCAT(D4)
--R   [3] PositiveInteger -> List(
--R            PlacesOverPseudoAlgebraicClosureOfFiniteField(D3))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D3,D4
--R            ,D5)
--R             if PseudoAlgebraicClosureOfFiniteField(D3) has FINITE and 
--R            D3 has FFIELDC and D4: LIST(SYMBOL) and D5 has BLMETCT
--R   [4] PositiveInteger -> List(Places(D3))
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FINITE and D3 has FIELD and D4: LIST(SYMBOL) and
--R            D5 has BLMETCT
--R
--RExamples of placesOfDegree from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of placesOfDegree from IntersectionDivisorPackage
--R
--R
--RExamples of placesOfDegree from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of placesOfDegree from PackageForAlgebraicFunctionField
--R
--E 2195

--S 2196 of 3320
)d op plenaryPower
--R 
--R
--RThere is one exposed function called plenaryPower :
--R   [1] (D,PositiveInteger) -> D from D if D has NAALG(D2) and D2 has 
--R            COMRING
--R
--RExamples of plenaryPower from NonAssociativeAlgebra
--R
--E 2196

--S 2197 of 3320
)d op pleskenSplit
--R 
--R
--RThere are 2 unexposed functions called pleskenSplit :
--R   [1] (D2,D3,Boolean) -> Factored(D2) from ComplexRootFindingPackage(
--R            D3,D2)
--R             if D3 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D3))
--R   [2] (D2,D3) -> Factored(D2) from ComplexRootFindingPackage(D3,D2)
--R             if D3 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D3))
--R
--RExamples of pleskenSplit from ComplexRootFindingPackage
--R
--E 2197

--S 2198 of 3320
)d op plot
--R 
--R
--RThere are 12 unexposed functions called plot :
--R   [1] (D2,Symbol,Segment(DoubleFloat)) -> Plot from PlotFunctions1(D2)
--R             if D2 has KONVERT(INFORM)
--R   [2] (D2,D2,Symbol,Segment(DoubleFloat)) -> Plot from PlotFunctions1(
--R            D2)
--R             if D2 has KONVERT(INFORM)
--R   [3] (Plot3D,Segment(DoubleFloat)) -> Plot3D from Plot3D
--R   [4] ((DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),(
--R            DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),Segment(
--R            DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat),Segment(
--R            DoubleFloat)) -> Plot3D
--R             from Plot3D
--R   [5] ((DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),(
--R            DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),Segment(
--R            DoubleFloat)) -> Plot3D
--R             from Plot3D
--R   [6] (Plot,Segment(DoubleFloat)) -> Plot from Plot
--R   [7] ((DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),
--R            Segment(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat))
--R             -> Plot
--R             from Plot
--R   [8] ((DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),
--R            Segment(DoubleFloat)) -> Plot
--R             from Plot
--R   [9] (List((DoubleFloat -> DoubleFloat)),Segment(DoubleFloat),Segment
--R            (DoubleFloat)) -> Plot
--R             from Plot
--R   [10] (List((DoubleFloat -> DoubleFloat)),Segment(DoubleFloat)) -> 
--R            Plot
--R             from Plot
--R   [11] ((DoubleFloat -> DoubleFloat),Segment(DoubleFloat),Segment(
--R            DoubleFloat)) -> Plot
--R             from Plot
--R   [12] ((DoubleFloat -> DoubleFloat),Segment(DoubleFloat)) -> Plot
--R             from Plot
--R
--RExamples of plot from PlotFunctions1
--R
--R
--RExamples of plot from Plot3D
--R
--R
--RExamples of plot from Plot
--R
--Rfp:=(t:DFLOAT):DFLOAT +-> sin(t) 
--Rplot(fp,-1.0..1.0)$PLOT
--R
--E 2198

--S 2199 of 3320
)d op plotPolar
--R 
--R
--RThere are 4 unexposed functions called plotPolar :
--R   [1] (D2,Symbol,Segment(DoubleFloat)) -> Plot from PlotFunctions1(D2)
--R             if D2 has KONVERT(INFORM)
--R   [2] (D2,Symbol) -> Plot from PlotFunctions1(D2) if D2 has KONVERT(
--R            INFORM)
--R   [3] (DoubleFloat -> DoubleFloat) -> Plot from Plot
--R   [4] ((DoubleFloat -> DoubleFloat),Segment(DoubleFloat)) -> Plot
--R             from Plot
--R
--RExamples of plotPolar from PlotFunctions1
--R
--R
--RExamples of plotPolar from Plot
--R
--E 2199

--S 2200 of 3320
)d op plus
--R 
--R
--RThere is one exposed function called plus :
--R   [1] (ThreeDimensionalMatrix(D1),ThreeDimensionalMatrix(D1)) -> 
--R            ThreeDimensionalMatrix(D1)
--R             from ThreeDimensionalMatrix(D1) if D1 has RING and D1 has 
--R            SETCAT
--R
--RThere are 2 unexposed functions called plus :
--R   [1] (ListMonoidOps(D1,D2,D3),ListMonoidOps(D1,D2,D3)) -> 
--R            ListMonoidOps(D1,D2,D3)
--R             from ListMonoidOps(D1,D2,D3)
--R             if D1 has SETCAT and D2 has ABELMON and D3: D2
--R   [2] (D1,D2,ListMonoidOps(D1,D2,D3)) -> ListMonoidOps(D1,D2,D3)
--R             from ListMonoidOps(D1,D2,D3)
--R             if D1 has SETCAT and D2 has ABELMON and D3: D2
--R
--RExamples of plus from ListMonoidOps
--R
--R
--RExamples of plus from ThreeDimensionalMatrix
--R
--E 2200

--S 2201 of 3320
)d op plus!
--R 
--R
--RThere is one unexposed function called plus! :
--R   [1] (Matrix(D2),Matrix(D2),Matrix(D2)) -> Matrix(D2)
--R             from StorageEfficientMatrixOperations(D2) if D2 has RING
--R         
--R
--RExamples of plus! from StorageEfficientMatrixOperations
--R
--E 2201

--S 2202 of 3320
)d op plusInfinity
--R 
--R
--RThere are 2 exposed functions called plusInfinity :
--R   [1]  -> OrderedCompletion(Integer) from Infinity
--R   [2]  -> OrderedCompletion(D1) from OrderedCompletion(D1) if D1 has 
--R            SETCAT
--R
--RExamples of plusInfinity from Infinity
--R
--R
--RExamples of plusInfinity from OrderedCompletion
--R
--E 2202

--S 2203 of 3320
)d op pmComplexintegrate
--R 
--R
--RThere is one unexposed function called pmComplexintegrate :
--R   [1] (D2,Symbol) -> Union(Record(special: D2,integrand: D2),"failed")
--R             from PatternMatchIntegration(D4,D2)
--R             if D4 has KONVERT(PATTERN(INT)) and D4 has PATMAB(INT) and
--R            D4 has Join(OrderedSet,RetractableTo(Integer),GcdDomain,
--R            LinearlyExplicitRingOver(Integer)) and D2 has LFCAT and D2
--R             has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D4))
--R
--RExamples of pmComplexintegrate from PatternMatchIntegration
--R
--E 2203

--S 2204 of 3320
)d op pmintegrate
--R 
--R
--RThere are 2 unexposed functions called pmintegrate :
--R   [1] (D2,Symbol) -> Union(Record(special: D2,integrand: D2),"failed")
--R             from PatternMatchIntegration(D4,D2)
--R             if D4 has KONVERT(PATTERN(INT)) and D4 has PATMAB(INT) and
--R            D4 has Join(OrderedSet,RetractableTo(Integer),GcdDomain,
--R            LinearlyExplicitRingOver(Integer)) and D2 has LFCAT and D2
--R             has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D4))
--R   [2] (D1,Symbol,OrderedCompletion(D1),OrderedCompletion(D1)) -> Union
--R            (D1,"failed")
--R             from PatternMatchIntegration(D4,D1)
--R             if D1 has SPFCAT and D1 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D4)) and D4
--R             has KONVERT(PATTERN(INT)) and D4 has PATMAB(INT) and D4
--R             has Join(OrderedSet,RetractableTo(Integer),GcdDomain,
--R            LinearlyExplicitRingOver(Integer))
--R
--RExamples of pmintegrate from PatternMatchIntegration
--R
--E 2204

--S 2205 of 3320
)d op po
--R 
--R
--RThere is one unexposed function called po :
--R   [1] OppositeMonogenicLinearOperator(D1,D2) -> D1
--R             from OppositeMonogenicLinearOperator(D1,D2)
--R             if D1 has MLO(D2) and D2 has RING
--R
--RExamples of po from OppositeMonogenicLinearOperator
--R
--E 2205

--S 2206 of 3320
)d op point
--R 
--R
--RThere are 6 exposed functions called point :
--R   [1] List(D2) -> D from D if D2 has RING and D has PTCAT(D2)
--R   [2] D -> Point(D2) from D if D has SPACEC(D2) and D2 has RING
--R   [3] Point(D2) -> D from D if D2 has RING and D has SPACEC(D2)
--R   [4] (D,NonNegativeInteger) -> D from D if D has SPACEC(D2) and D2
--R             has RING
--R   [5] (D,List(D2)) -> D from D if D has SPACEC(D2) and D2 has RING
--R   [6] (D,Point(D2)) -> D from D if D has SPACEC(D2) and D2 has RING
--R         
--R
--RThere are 2 unexposed functions called point :
--R   [1] (GraphImage,Point(DoubleFloat),Palette) -> Void from GraphImage
--R            
--R   [2] (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat) -> Point(
--R            DoubleFloat)
--R             from TubePlotTools
--R
--RExamples of point from GraphImage
--R
--R
--RExamples of point from PointCategory
--R
--R
--RExamples of point from ThreeSpaceCategory
--R
--R
--RExamples of point from TubePlotTools
--R
--E 2206

--S 2207 of 3320
)d op point?
--R 
--R
--RThere is one exposed function called point? :
--R   [1] D -> Boolean from D if D has SPACEC(D2) and D2 has RING
--R
--RExamples of point? from ThreeSpaceCategory
--R
--E 2207

--S 2208 of 3320
)d op pointColor
--R 
--R
--RThere are 2 exposed functions called pointColor :
--R   [1] Palette -> DrawOption from DrawOption
--R   [2] Float -> DrawOption from DrawOption
--R
--RExamples of pointColor from DrawOption
--R
--E 2208

--S 2209 of 3320
)d op pointColorDefault
--R 
--R
--RThere are 2 exposed functions called pointColorDefault :
--R   [1]  -> Palette from ViewDefaultsPackage
--R   [2] Palette -> Palette from ViewDefaultsPackage
--R
--RExamples of pointColorDefault from ViewDefaultsPackage
--R
--E 2209

--S 2210 of 3320
)d op pointColorPalette
--R 
--R
--RThere is one unexposed function called pointColorPalette :
--R   [1] (List(DrawOption),Palette) -> Palette from DrawOptionFunctions0
--R            
--R
--RExamples of pointColorPalette from DrawOptionFunctions0
--R
--E 2210

--S 2211 of 3320
)d op pointData
--R 
--R
--RThere is one unexposed function called pointData :
--R   [1] SubSpace(D2,D3) -> List(Point(D3)) from SubSpace(D2,D3)
--R             if D2: PI and D3 has RING
--R
--RExamples of pointData from SubSpace
--R
--E 2211

--S 2212 of 3320
)d op pointDominateBy
--R 
--R
--RThere are 4 exposed functions called pointDominateBy :
--R   [1] D5 -> D4
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D4,D10,D5,D11,D1,D2,D3)
--R             if D6 has FIELD and D7: LIST(SYMBOL) and D8 has POLYCAT(D6
--R            ,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI) and D10 has 
--R            LOCPOWC(D6) and D5 has PLACESC(D6,D10) and D11 has DIVCAT(
--R            D5) and D1 has INFCLCT(D6,D7,D8,D9,D4,D10,D5,D11,D3) and D3
--R             has BLMETCT and D4 has PRSPCAT(D6) and D2 has DSTRCAT(D1)
--R            
--R   [2] D2 -> D1
--R             from LocalParametrizationOfSimplePointPackage(D3,D4,D5,D6,
--R            D1,D7,D2)
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D6 has DIRPCAT(#(
--R            D4),NNI) and D7 has LOCPOWC(D3) and D1 has PRSPCAT(D3) and 
--R            D5 has POLYCAT(D3,D6,OVAR(D4)) and D2 has PLACESC(D3,D7)
--R         
--R   [3] PlacesOverPseudoAlgebraicClosureOfFiniteField(D3) -> 
--R            ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField(D3)
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D3,D4
--R            ,D5)
--R             if D3 has FFIELDC and D4: LIST(SYMBOL) and D5 has BLMETCT
--R            
--R   [4] Places(D3) -> ProjectivePlane(D3)
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D5 has BLMETCT
--R         
--R
--RExamples of pointDominateBy from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of pointDominateBy from LocalParametrizationOfSimplePointPackage
--R
--R
--RExamples of pointDominateBy from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of pointDominateBy from PackageForAlgebraicFunctionField
--R
--E 2212

--S 2213 of 3320
)d op pointInIdeal?
--R 
--R
--RThere is one exposed function called pointInIdeal? :
--R   [1] (List(D5),D3) -> Boolean from PolynomialPackageForCurve(D4,D5,D6
--R            ,D7,D3)
--R             if D5 has FAMR(D4,D6) and D6 has DIRPCAT(D7,NNI) and D7: 
--R            NNI and D4 has FIELD and D3 has PRSPCAT(D4)
--R
--RExamples of pointInIdeal? from PolynomialPackageForCurve
--R
--E 2213

--S 2214 of 3320
)d op pointLists
--R 
--R
--RThere is one unexposed function called pointLists :
--R   [1] GraphImage -> List(List(Point(DoubleFloat))) from GraphImage
--R
--RExamples of pointLists from GraphImage
--R
--E 2214

--S 2215 of 3320
)d op pointPlot
--R 
--R
--RThere are 4 unexposed functions called pointPlot :
--R   [1] ((DoubleFloat -> Point(DoubleFloat)),Segment(DoubleFloat),
--R            Segment(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat))
--R             -> Plot3D
--R             from Plot3D
--R   [2] ((DoubleFloat -> Point(DoubleFloat)),Segment(DoubleFloat)) -> 
--R            Plot3D
--R             from Plot3D
--R   [3] ((DoubleFloat -> Point(DoubleFloat)),Segment(DoubleFloat),
--R            Segment(DoubleFloat),Segment(DoubleFloat)) -> Plot
--R             from Plot
--R   [4] ((DoubleFloat -> Point(DoubleFloat)),Segment(DoubleFloat)) -> 
--R            Plot
--R             from Plot
--R
--RExamples of pointPlot from Plot3D
--R
--R
--RExamples of pointPlot from Plot
--R
--E 2215

--S 2216 of 3320
)d op points
--R 
--R
--RThere is one unexposed function called points :
--R   [1] (TwoDimensionalViewport,PositiveInteger,String) -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of points from TwoDimensionalViewport
--R
--E 2216

--S 2217 of 3320
)d op pointSizeDefault
--R 
--R
--RThere are 2 exposed functions called pointSizeDefault :
--R   [1]  -> PositiveInteger from ViewDefaultsPackage
--R   [2] PositiveInteger -> PositiveInteger from ViewDefaultsPackage
--R
--RExamples of pointSizeDefault from ViewDefaultsPackage
--R
--E 2217

--S 2218 of 3320
)d op pointToCell
--R 
--R
--RThere is one exposed function called pointToCell :
--R   [1] (D1,Boolean,Symbol) -> SimpleCell(D1,D4) from SimpleCell(D1,D4)
--R             if D1 has RCFIELD and D4 has UPOLYC(D1)
--R
--RExamples of pointToCell from SimpleCell
--R
--E 2218

--S 2219 of 3320
)d op pointToPlace
--R 
--R
--RThere is one exposed function called pointToPlace :
--R   [1] (D2,D3) -> D1
--R             from LocalParametrizationOfSimplePointPackage(D4,D5,D3,D6,
--R            D2,D7,D1)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D6 has DIRPCAT(#(
--R            D5),NNI) and D1 has PLACESC(D4,D7) and D3 has POLYCAT(D4,D6
--R            ,OVAR(D5)) and D2 has PRSPCAT(D4) and D7 has LOCPOWC(D4)
--R         
--R
--RExamples of pointToPlace from LocalParametrizationOfSimplePointPackage
--R
--E 2219

--S 2220 of 3320
)d op pointV
--R 
--R
--RThere is one exposed function called pointV :
--R   [1] D -> D2 from D
--R             if D has INFCLCT(D3,D4,D5,D6,D2,D7,D8,D9,D1) and D3 has 
--R            FIELD and D5 has POLYCAT(D3,D6,OVAR(D4)) and D6 has DIRPCAT
--R            (#(D4),NNI) and D7 has LOCPOWC(D3) and D8 has PLACESC(D3,D7
--R            ) and D1 has BLMETCT and D2 has PRSPCAT(D3)
--R
--RExamples of pointV from InfinitlyClosePointCategory
--R
--E 2220

--S 2221 of 3320
)d op pointValue
--R 
--R
--RThere are 2 exposed functions called pointValue :
--R   [1] D -> List(D2) from D if D has AFSPCAT(D2) and D2 has FIELD
--R   [2] D -> List(D2) from D if D has PRSPCAT(D2) and D2 has FIELD
--R
--RExamples of pointValue from AffineSpaceCategory
--R
--R
--RExamples of pointValue from ProjectiveSpaceCategory
--R
--E 2221

--S 2222 of 3320
)d op poisson
--R 
--R
--RThere is one unexposed function called poisson :
--R   [1] RationalNumber -> (() -> Integer) from 
--R            RandomIntegerDistributions
--R
--RExamples of poisson from RandomIntegerDistributions
--R
--E 2222

--S 2223 of 3320
)d op pol
--R 
--R
--RThere is one unexposed function called pol :
--R   [1] Vector(D3) -> SparseUnivariatePolynomial(D3)
--R             from InnerNormalBasisFieldFunctions(D3) if D3 has FFIELDC
--R            
--R
--RExamples of pol from InnerNormalBasisFieldFunctions
--R
--E 2223

--S 2224 of 3320
)d op polar
--R 
--R
--RThere is one exposed function called polar :
--R   [1] Point(D2) -> Point(D2) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of polar from CoordinateSystems
--R
--E 2224

--S 2225 of 3320
)d op polarCoordinates
--R 
--R
--RThere is one exposed function called polarCoordinates :
--R   [1] D -> Record(r: D2,phi: D2) from D
--R             if D has COMPCAT(D2) and D2 has COMRING and D2 has RNS and
--R            D2 has TRANFUN
--R
--RExamples of polarCoordinates from ComplexCategory
--R
--E 2225

--S 2226 of 3320
)d op polCase
--R 
--R
--RThere is one unexposed function called polCase :
--R   [1] (D2,NonNegativeInteger,List(D2)) -> Boolean
--R             from LeadingCoefDetermination(D5,D6,D2,D7)
--R             if D2 has EUCDOM and D5 has ORDSET and D6 has OAMONS and 
--R            D7 has POLYCAT(D2,D6,D5)
--R
--RExamples of polCase from LeadingCoefDetermination
--R
--E 2226

--S 2227 of 3320
)d op pole?
--R 
--R
--RThere is one exposed function called pole? :
--R   [1] D -> Boolean from D
--R             if D has PSCAT(D2,D3,D4) and D2 has RING and D3 has OAMON 
--R            and D4 has ORDSET
--R
--RThere is one unexposed function called pole? :
--R   [1] InnerTaylorSeries(D2) -> Boolean from InnerTaylorSeries(D2) if 
--R            D2 has RING
--R
--RExamples of pole? from InnerTaylorSeries
--R
--R
--RExamples of pole? from PowerSeriesCategory
--R
--E 2227

--S 2228 of 3320
)d op PollardSmallFactor
--R 
--R
--RThere is one unexposed function called PollardSmallFactor :
--R   [1] D1 -> Union(D1,"failed") from IntegerFactorizationPackage(D1)
--R             if D1 has INS
--R
--RExamples of PollardSmallFactor from IntegerFactorizationPackage
--R
--E 2228

--S 2229 of 3320
)d op polygamma
--R 
--R
--RThere are 3 exposed functions called polygamma :
--R   [1] (NonNegativeInteger,DoubleFloat) -> DoubleFloat
--R             from DoubleFloatSpecialFunctions
--R   [2] (NonNegativeInteger,Complex(DoubleFloat)) -> Complex(DoubleFloat
--R            )
--R             from DoubleFloatSpecialFunctions
--R   [3] (D,D) -> D from D if D has SPFCAT
--R
--RThere is one unexposed function called polygamma :
--R   [1] (D1,D1) -> D1 from FunctionalSpecialFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS(D2
--R            )
--R
--RExamples of polygamma from DoubleFloatSpecialFunctions
--R
--R
--RExamples of polygamma from FunctionalSpecialFunction
--R
--R
--RExamples of polygamma from SpecialFunctionCategory
--R
--E 2229

--S 2230 of 3320
)d op polygon
--R 
--R
--RThere are 4 exposed functions called polygon :
--R   [1] D -> List(Point(D2)) from D if D has SPACEC(D2) and D2 has RING
--R            
--R   [2] List(Point(D2)) -> D from D if D2 has RING and D has SPACEC(D2)
--R            
--R   [3] (D,List(List(D2))) -> D from D if D has SPACEC(D2) and D2 has 
--R            RING
--R   [4] (D,List(Point(D2))) -> D from D if D has SPACEC(D2) and D2 has 
--R            RING
--R
--RExamples of polygon from ThreeSpaceCategory
--R
--E 2230

--S 2231 of 3320
)d op polygon?
--R 
--R
--RThere is one exposed function called polygon? :
--R   [1] D -> Boolean from D if D has SPACEC(D2) and D2 has RING
--R
--RExamples of polygon? from ThreeSpaceCategory
--R
--E 2231

--S 2232 of 3320
)d op polynomial
--R 
--R
--RThere are 4 exposed functions called polynomial :
--R   [1] (D,NonNegativeInteger,NonNegativeInteger) -> Polynomial(D3)
--R             from D
--R             if D has MTSCAT(D3,D4) and D3 has RING and D4 has ORDSET
--R         
--R   [2] (D,NonNegativeInteger) -> Polynomial(D3) from D
--R             if D has MTSCAT(D3,D4) and D3 has RING and D4 has ORDSET
--R         
--R   [3] (D,NonNegativeInteger,NonNegativeInteger) -> Polynomial(D3)
--R             from D
--R             if D has UTSCAT(D3) and D3 has RING
--R   [4] (D,NonNegativeInteger) -> Polynomial(D3) from D
--R             if D has UTSCAT(D3) and D3 has RING
--R
--RExamples of polynomial from MultivariateTaylorSeriesCategory
--R
--R
--RExamples of polynomial from UnivariateTaylorSeriesCategory
--R
--E 2232

--S 2233 of 3320
)d op polynomialZeros
--R 
--R
--RThere is one exposed function called polynomialZeros :
--R   [1] (Polynomial(Fraction(Integer)),Symbol,Segment(OrderedCompletion(
--R            DoubleFloat))) -> List(DoubleFloat)
--R             from ExpertSystemContinuityPackage
--R
--RExamples of polynomialZeros from ExpertSystemContinuityPackage
--R
--E 2233

--S 2234 of 3320
)d op polyPart
--R 
--R
--RThere is one exposed function called polyPart :
--R   [1] FullPartialFractionExpansion(D2,D1) -> D1
--R             from FullPartialFractionExpansion(D2,D1)
--R             if D1 has UPOLYC(D2) and D2 has Join(Field,
--R            CharacteristicZero)
--R
--RExamples of polyPart from FullPartialFractionExpansion
--R
--E 2234

--S 2235 of 3320
)d op polyRDE
--R 
--R
--RThere is one unexposed function called polyRDE :
--R   [1] (D2,D2,D2,Integer,(D2 -> D2)) -> Union(ans: Record(ans: D2,nosol
--R            : Boolean),eq: Record(b: D2,c: D2,m: Integer,alpha: D2,beta: D2))
--R             from TranscendentalRischDE(D5,D2)
--R             if D2 has UPOLYC(D5) and D5 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer))
--R
--RExamples of polyRDE from TranscendentalRischDE
--R
--E 2235

--S 2236 of 3320
)d op polyred
--R 
--R
--RThere is one unexposed function called polyred :
--R   [1] D1 -> D1 from PointsOfFiniteOrderTools(D2,D1)
--R             if D2 has UPOLYC(FRAC(INT)) and D1 has UPOLYC(FRAC(D2))
--R         
--R
--RExamples of polyred from PointsOfFiniteOrderTools
--R
--E 2236

--S 2237 of 3320
)d op polyRicDE
--R 
--R
--RThere are 2 unexposed functions called polyRicDE :
--R   [1] (D2,(D5 -> List(D4))) -> List(Record(poly: D5,eq: D2))
--R             from PrimitiveRatRicDE(D4,D5,D2,D6)
--R             if D4 has Join(Field,CharacteristicZero,RetractableTo(
--R            Fraction(Integer))) and D5 has UPOLYC(D4) and D2 has 
--R            LODOCAT(D5) and D6 has LODOCAT(FRAC(D5))
--R   [2] (LinearOrdinaryDifferentialOperator2(D5,Fraction(D5)),(D5 -> 
--R            List(D4))) -> List(Record(poly: D5,eq: 
--R            LinearOrdinaryDifferentialOperator2(D5,Fraction(D5))))
--R             from RationalRicDE(D4,D5)
--R             if D4 has Join(Field,CharacteristicZero,RetractableTo(
--R            Integer),RetractableTo(Fraction(Integer))) and D5 has 
--R            UPOLYC(D4)
--R
--RExamples of polyRicDE from PrimitiveRatRicDE
--R
--R
--RExamples of polyRicDE from RationalRicDE
--R
--E 2237

--S 2238 of 3320
)d op polyRing2UPUP
--R 
--R
--RThere is one exposed function called polyRing2UPUP :
--R   [1] D2 -> SparseUnivariatePolynomial(SparseUnivariatePolynomial(D3))
--R             from AffineAlgebraicSetComputeWithResultant(D3,D4,D2,D5,D6
--R            )
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D5 has DIRPCAT(#(
--R            D4),NNI) and D2 has POLYCAT(D3,D5,OVAR(D4)) and D6 has 
--R            PRSPCAT(D3)
--R
--RExamples of polyRing2UPUP from AffineAlgebraicSetComputeWithResultant
--R
--E 2238

--S 2239 of 3320
)d op polyRingToBlUpRing
--R 
--R
--RThere is one exposed function called polyRingToBlUpRing :
--R   [1] (D2,D3) -> DistributedMultivariatePolynomial([construct,QUOTEX,
--R            QUOTEY],D4)
--R             from BlowUpPackage(D4,D5,D2,D6,D3)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D6 has DIRPCAT(#(
--R            D5),NNI) and D2 has FAMR(D4,D6) and D3 has BLMETCT
--R
--RExamples of polyRingToBlUpRing from BlowUpPackage
--R
--E 2239

--S 2240 of 3320
)d op pomopo!
--R 
--R
--RThere is one exposed function called pomopo! :
--R   [1] (D,D1,D2,D) -> D from D if D has FAMR(D1,D2) and D1 has RING and
--R            D2 has OAMON
--R
--RExamples of pomopo! from FiniteAbelianMonoidRing
--R
--E 2240

--S 2241 of 3320 done
)d op pop!
--R 
--R
--RThere are 4 exposed functions called pop! :
--R   [1] ArrayStack(D1) -> D1 from ArrayStack(D1) if D1 has SETCAT
--R   [2] Dequeue(D1) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [3] D -> D1 from D if D has SKAGG(D1) and D1 has TYPE
--R   [4] Stack(D1) -> D1 from Stack(D1) if D1 has SETCAT
--R
--RExamples of pop! from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rpop! a 
--Ra
--R
--R
--RExamples of pop! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rpop! a 
--Ra
--R
--R
--RExamples of pop! from StackAggregate
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rpop! a 
--Ra
--R
--R
--RExamples of pop! from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rpop! a 
--Ra
--R
--E 2241

--S 2242 of 3320
)d op popFortranOutputStack
--R 
--R
--RThere is one exposed function called popFortranOutputStack :
--R   [1]  -> Void from FortranOutputStackPackage
--R
--RExamples of popFortranOutputStack from FortranOutputStackPackage
--R
--E 2242

--S 2243 of 3320
)d op posExpnPart
--R 
--R
--RThere is one exposed function called posExpnPart :
--R   [1] D -> D from D if D has LOCPOWC(D1) and D1 has FIELD
--R
--RExamples of posExpnPart from LocalPowerSeriesCategory
--R
--E 2243

--S 2244 of 3320
)d op position
--R 
--R
--RThere are 7 exposed functions called position :
--R   [1] BinaryFile -> SingleInteger from BinaryFile
--R   [2] D -> NonNegativeInteger from D if D has CACHSET
--R   [3] (D2,D,Integer) -> Integer from D
--R             if D has FLAGG(D2) and D2 has TYPE and D2 has SETCAT
--R   [4] (D2,D) -> Integer from D if D has FLAGG(D2) and D2 has TYPE and 
--R            D2 has SETCAT
--R   [5] ((D3 -> Boolean),D) -> Integer from D if D has FLAGG(D3) and D3
--R             has TYPE
--R   [6] (CharacterClass,D,Integer) -> Integer from D if D has SRAGG
--R   [7] (D,D,Integer) -> Integer from D if D has SRAGG
--R
--RExamples of position from BinaryFile
--R
--R
--RExamples of position from CachableSet
--R
--R
--RExamples of position from FiniteLinearAggregate
--R
--R
--RExamples of position from StringAggregate
--R
--E 2244

--S 2245 of 3320
)d op position!
--R 
--R
--RThere is one exposed function called position! :
--R   [1] (BinaryFile,SingleInteger) -> SingleInteger from BinaryFile
--R
--RExamples of position! from BinaryFile
--R
--E 2245

--S 2246 of 3320
)d op positive?
--R 
--R
--RThere are 3 exposed functions called positive? :
--R   [1] D -> Boolean from D
--R             if D has INTCAT(D2) and D2 has Join(FloatingPointSystem,
--R            TranscendentalFunctionCategory)
--R   [2] D -> Boolean from D if D has ORDRING
--R   [3] (D2,D) -> Boolean from D
--R             if D has RRCC(D3,D2) and D3 has Join(OrderedRing,Field) 
--R            and D2 has UPOLYC(D3)
--R
--RExamples of positive? from IntervalCategory
--R
--R
--RExamples of positive? from OrderedRing
--R
--R
--RExamples of positive? from RealRootCharacterizationCategory
--R
--E 2246

--S 2247 of 3320
)d op positiveRemainder
--R 
--R
--RThere is one exposed function called positiveRemainder :
--R   [1] (D,D) -> D from D if D has INS
--R
--RExamples of positiveRemainder from IntegerNumberSystem
--R
--E 2247

--S 2248 of 3320
)d op positiveSolve
--R 
--R
--RThere are 4 exposed functions called positiveSolve :
--R   [1] RegularChain(D3,D4) -> List(List(RealClosure(Fraction(D3))))
--R             from ZeroDimensionalSolvePackage(D3,D4,D5)
--R             if D3 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D4: LIST(SYMBOL) and 
--R            D5: LIST(SYMBOL)
--R   [2] (List(Polynomial(D4)),Boolean,Boolean) -> List(List(RealClosure(
--R            Fraction(D4))))
--R             from ZeroDimensionalSolvePackage(D4,D5,D6)
--R             if D4 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D5: LIST(SYMBOL) and 
--R            D6: LIST(SYMBOL)
--R   [3] (List(Polynomial(D4)),Boolean) -> List(List(RealClosure(Fraction
--R            (D4))))
--R             from ZeroDimensionalSolvePackage(D4,D5,D6)
--R             if D4 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D5: LIST(SYMBOL) and 
--R            D6: LIST(SYMBOL)
--R   [4] List(Polynomial(D3)) -> List(List(RealClosure(Fraction(D3))))
--R             from ZeroDimensionalSolvePackage(D3,D4,D5)
--R             if D3 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D4: LIST(SYMBOL) and 
--R            D5: LIST(SYMBOL)
--R
--RExamples of positiveSolve from ZeroDimensionalSolvePackage
--R
--E 2248

--S 2249 of 3320
)d op possiblyInfinite?
--R 
--R
--RThere is one exposed function called possiblyInfinite? :
--R   [1] D -> Boolean from D if D has STAGG(D2) and D2 has TYPE
--R
--RExamples of possiblyInfinite? from StreamAggregate
--R
--E 2249

--S 2250 of 3320
)d op possiblyNewVariety?
--R 
--R
--RThere is one unexposed function called possiblyNewVariety? :
--R   [1] (List(D7),List(List(D7))) -> Boolean
--R             from PolynomialSetUtilitiesPackage(D4,D5,D6,D7)
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has INTDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R
--RExamples of possiblyNewVariety? from PolynomialSetUtilitiesPackage
--R
--E 2250

--S 2251 of 3320
)d op postfix
--R 
--R
--RThere is one unexposed function called postfix :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of postfix from OutputForm
--R
--E 2251

--S 2252 of 3320
)d op pow
--R 
--R
--RThere is one exposed function called pow :
--R   [1] (U32Vector,PositiveInteger,NonNegativeInteger,Integer) -> 
--R            U32Vector
--R             from U32VectorPolynomialOperations
--R
--RThere is one unexposed function called pow :
--R   [1]  -> PrimitiveArray(ModMonic(D2,D3)) from ModMonic(D2,D3)
--R             if D2 has RING and D3 has UPOLYC(D2)
--R
--RExamples of pow from ModMonic
--R
--R
--RExamples of pow from U32VectorPolynomialOperations
--R
--E 2252

--S 2253 of 3320
)d op power
--R 
--R
--RThere is one unexposed function called power :
--R   [1] (D2,Stream(D2)) -> Stream(D2) from StreamTaylorSeriesOperations(
--R            D2)
--R             if D2 has FIELD and D2 has RING
--R
--RExamples of power from StreamTaylorSeriesOperations
--R
--E 2253

--S 2254 of 3320
)d op power!
--R 
--R
--RThere is one unexposed function called power! :
--R   [1] (Matrix(D3),Matrix(D3),Matrix(D3),Matrix(D3),NonNegativeInteger)
--R             -> Matrix(D3)
--R             from StorageEfficientMatrixOperations(D3) if D3 has RING
--R         
--R
--RExamples of power! from StorageEfficientMatrixOperations
--R
--E 2254

--S 2255 of 3320
)d op powerAssociative?
--R 
--R
--RThere is one exposed function called powerAssociative? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RExamples of powerAssociative? from FiniteRankNonAssociativeAlgebra
--R
--E 2255

--S 2256 of 3320
)d op powern
--R 
--R
--RThere is one unexposed function called powern :
--R   [1] (Fraction(Integer),Stream(D3)) -> Stream(D3)
--R             from StreamTaylorSeriesOperations(D3)
--R             if D3 has ALGEBRA(FRAC(INT)) and D3 has RING
--R
--RExamples of powern from StreamTaylorSeriesOperations
--R
--E 2256

--S 2257 of 3320
)d op powers
--R 
--R
--RThere is one unexposed function called powers :
--R   [1] List(Integer) -> List(List(Integer)) from Partition
--R
--RExamples of powers from Partition
--R
--E 2257

--S 2258 of 3320
)d op powerSum
--R 
--R
--RThere is one exposed function called powerSum :
--R   [1] Integer -> SymmetricPolynomial(Fraction(Integer)) from 
--R            CycleIndicators
--R
--RExamples of powerSum from CycleIndicators
--R
--E 2258

--S 2259 of 3320
)d op powmod
--R 
--R
--RThere is one exposed function called powmod :
--R   [1] (D,D,D) -> D from D if D has INS
--R
--RExamples of powmod from IntegerNumberSystem
--R
--E 2259

--S 2260 of 3320
)d op pquo
--R 
--R
--RThere are 2 exposed functions called pquo :
--R   [1] (D,D,D1) -> D from D
--R             if D has RPOLCAT(D2,D3,D1) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET
--R   [2] (D,D) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R
--RExamples of pquo from RecursivePolynomialCategory
--R
--E 2260

--S 2261 of 3320
)d op pr2dmp
--R 
--R
--RThere is one unexposed function called pr2dmp :
--R   [1] Polynomial(D3) -> D1 from ParametricLinearEquations(D3,D4,D5,D1)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D1
--R             has POLYCAT(D3,D5,D4) and D4 has Join(OrderedSet,
--R            ConvertibleTo(Symbol)) and D5 has OAMONS
--R
--RExamples of pr2dmp from ParametricLinearEquations
--R
--E 2261

--S 2262 of 3320
)d op precision
--R 
--R
--RThere are 4 exposed functions called precision :
--R   [1] PositiveInteger -> PositiveInteger from D
--R             if D has arbitraryPrecision and D has FPS
--R   [2]  -> PositiveInteger from D if D has FPS
--R   [3] PositiveInteger -> PositiveInteger from MachineFloat
--R   [4]  -> PositiveInteger from MachineFloat
--R
--RExamples of precision from FloatingPointSystem
--R
--R
--RExamples of precision from MachineFloat
--R
--E 2262

--S 2263 of 3320
)d op predicate
--R 
--R
--RThere is one unexposed function called predicate :
--R   [1] Pattern(D3) -> (D4 -> Boolean) from PatternFunctions1(D3,D4)
--R             if D3 has SETCAT and D4 has TYPE
--R
--RExamples of predicate from PatternFunctions1
--R
--E 2263

--S 2264 of 3320
)d op predicates
--R 
--R
--RThere is one unexposed function called predicates :
--R   [1] Pattern(D2) -> List(Any) from Pattern(D2) if D2 has SETCAT
--R
--RExamples of predicates from Pattern
--R
--E 2264

--S 2265 of 3320
)d op prefix
--R 
--R
--RThere is one unexposed function called prefix :
--R   [1] (OutputForm,List(OutputForm)) -> OutputForm from OutputForm
--R
--RExamples of prefix from OutputForm
--R
--E 2265

--S 2266 of 3320
)d op prefix?
--R 
--R
--RThere is one exposed function called prefix? :
--R   [1] (D,D) -> Boolean from D if D has SRAGG
--R
--RExamples of prefix? from StringAggregate
--R
--E 2266

--S 2267 of 3320
)d op prefixRagits
--R 
--R
--RThere is one exposed function called prefixRagits :
--R   [1] RadixExpansion(D2) -> List(Integer) from RadixExpansion(D2) if 
--R            D2: INT
--R
--RExamples of prefixRagits from RadixExpansion
--R
--E 2267

--S 2268 of 3320
)d op prem
--R 
--R
--RThere are 2 exposed functions called prem :
--R   [1] (D,D,D1) -> D from D
--R             if D has RPOLCAT(D2,D3,D1) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET
--R   [2] (D,D) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R
--RExamples of prem from RecursivePolynomialCategory
--R
--E 2268

--S 2269 of 3320
)d op prepareDecompose
--R 
--R
--RThere are 2 exposed functions called prepareDecompose :
--R   [1] (List(D9),List(D1),Boolean,Boolean) -> List(Record(eq: List(D9),
--R            tower: D1,ineq: List(D9)))
--R             from QuasiComponentPackage(D6,D7,D8,D9,D1)
--R             if D1 has RSETCAT(D6,D7,D8,D9) and D6 has GCDDOM and D7
--R             has OAMONS and D8 has ORDSET and D9 has RPOLCAT(D6,D7,D8)
--R            
--R   [2] (List(D9),List(D1),Boolean,Boolean) -> List(Record(eq: List(D9),
--R            tower: D1,ineq: List(D9)))
--R             from SquareFreeQuasiComponentPackage(D6,D7,D8,D9,D1)
--R             if D1 has RSETCAT(D6,D7,D8,D9) and D6 has GCDDOM and D7
--R             has OAMONS and D8 has ORDSET and D9 has RPOLCAT(D6,D7,D8)
--R            
--R
--RExamples of prepareDecompose from QuasiComponentPackage
--R
--R
--RExamples of prepareDecompose from SquareFreeQuasiComponentPackage
--R
--E 2269

--S 2270 of 3320
)d op prepareSubResAlgo
--R 
--R
--RThere is one exposed function called prepareSubResAlgo :
--R   [1] (D2,D2,D3) -> List(Record(val: List(D2),tower: D3))
--R             from RegularTriangularSetGcdPackage(D4,D5,D6,D2,D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of prepareSubResAlgo from RegularTriangularSetGcdPackage
--R
--E 2270

--S 2271 of 3320
--R-----------------)d op pre_process (fix this)
--E 2271

--S 2272 of 3320
)d op presub
--R 
--R
--RThere is one unexposed function called presub :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of presub from OutputForm
--R
--E 2272

--S 2273 of 3320
)d op presuper
--R 
--R
--RThere is one unexposed function called presuper :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of presuper from OutputForm
--R
--E 2273

--S 2274 of 3320
)d op previous
--R 
--R
--RThere is one exposed function called previous :
--R   [1] D -> D from D if D has DLAGG(D1) and D1 has TYPE
--R
--RExamples of previous from DoublyLinkedAggregate
--R
--E 2274

--S 2275 of 3320
)d op previousTower
--R 
--R
--RThere is one exposed function called previousTower :
--R   [1] D -> D from D if D has PACPERC
--R
--RExamples of previousTower from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--E 2275

--S 2276 of 3320
)d op prevPrime
--R 
--R
--RThere is one exposed function called prevPrime :
--R   [1] D1 -> D1 from IntegerPrimesPackage(D1) if D1 has INS
--R
--RExamples of prevPrime from IntegerPrimesPackage
--R
--E 2276

--S 2277 of 3320
)d op primaryDecomp
--R 
--R
--RThere is one exposed function called primaryDecomp :
--R   [1] PolynomialIdeals(Fraction(Integer),DirectProduct(D4,
--R            NonNegativeInteger),OrderedVariableList(D3),
--R            DistributedMultivariatePolynomial(D3,Fraction(Integer))) -> List(
--R            PolynomialIdeals(Fraction(Integer),DirectProduct(D4,
--R            NonNegativeInteger),OrderedVariableList(D3),
--R            DistributedMultivariatePolynomial(D3,Fraction(Integer))))
--R             from IdealDecompositionPackage(D3,D4) if D3: LIST(SYMBOL) 
--R            and D4: NNI
--R
--RExamples of primaryDecomp from IdealDecompositionPackage
--R
--E 2277

--S 2278 of 3320
)d op prime
--R 
--R
--RThere are 2 unexposed functions called prime :
--R   [1] (OutputForm,NonNegativeInteger) -> OutputForm from OutputForm
--R         
--R   [2] OutputForm -> OutputForm from OutputForm
--R
--RExamples of prime from OutputForm
--R
--E 2278

--S 2279 of 3320
)d op prime?
--R 
--R
--RThere are 4 exposed functions called prime? :
--R   [1] Complex(Integer) -> Boolean from GaussianFactorizationPackage
--R         
--R   [2] PolynomialIdeals(Fraction(Integer),DirectProduct(D4,
--R            NonNegativeInteger),OrderedVariableList(D3),
--R            DistributedMultivariatePolynomial(D3,Fraction(Integer))) -> 
--R            Boolean
--R             from IdealDecompositionPackage(D3,D4) if D3: LIST(SYMBOL) 
--R            and D4: NNI
--R   [3] D2 -> Boolean from IntegerPrimesPackage(D2) if D2 has INS
--R   [4] D -> Boolean from D if D has UFD
--R
--RExamples of prime? from GaussianFactorizationPackage
--R
--R
--RExamples of prime? from IdealDecompositionPackage
--R
--R
--RExamples of prime? from IntegerPrimesPackage
--R
--R
--RExamples of prime? from UniqueFactorizationDomain
--R
--E 2279

--S 2280 of 3320 done
)d op primeFactor
--R 
--R
--RThere is one exposed function called primeFactor :
--R   [1] (D1,Integer) -> Factored(D1) from Factored(D1) if D1 has INTDOM
--R            
--R
--RExamples of primeFactor from Factored
--R
--Ra:=primeFactor(3,4) 
--RnthFlag(a,1)
--R
--E 2280

--S 2281 of 3320
)d op primeFrobenius
--R 
--R
--RThere are 2 exposed functions called primeFrobenius :
--R   [1] (D,NonNegativeInteger) -> D from D if D has FPC
--R   [2] D -> D from D if D has FPC
--R
--RExamples of primeFrobenius from FieldOfPrimeCharacteristic
--R
--E 2281

--S 2282 of 3320
)d op primes
--R 
--R
--RThere is one exposed function called primes :
--R   [1] (D2,D2) -> List(D2) from IntegerPrimesPackage(D2) if D2 has INS
--R            
--R
--RExamples of primes from IntegerPrimesPackage
--R
--E 2282

--S 2283 of 3320
)d op primextendedint
--R 
--R
--RThere is one unexposed function called primextendedint :
--R   [1] (Fraction(D6),(D6 -> D6),(D5 -> Union(Record(ratpart: D5,coeff: 
--R            D5),"failed")),Fraction(D6)) -> Union(Record(answer: Fraction(D6)
--R            ,a0: D5),Record(ratpart: Fraction(D6),coeff: Fraction(D6)),
--R            "failed")
--R             from TranscendentalIntegration(D5,D6)
--R             if D5 has FIELD and D6 has UPOLYC(D5)
--R
--RExamples of primextendedint from TranscendentalIntegration
--R
--E 2283

--S 2284 of 3320
)d op primextintfrac
--R 
--R
--RThere is one unexposed function called primextintfrac :
--R   [1] (Fraction(D5),(D5 -> D5),Fraction(D5)) -> Union(Record(ratpart: 
--R            Fraction(D5),coeff: Fraction(D5)),"failed")
--R             from TranscendentalIntegration(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has FIELD
--R
--RExamples of primextintfrac from TranscendentalIntegration
--R
--E 2284

--S 2285 of 3320
)d op primintegrate
--R 
--R
--RThere is one unexposed function called primintegrate :
--R   [1] (Fraction(D6),(D6 -> D6),(D5 -> Union(Record(ratpart: D5,coeff: 
--R            D5),"failed"))) -> Record(answer: IntegrationResult(Fraction(D6))
--R            ,a0: D5)
--R             from TranscendentalIntegration(D5,D6)
--R             if D5 has FIELD and D6 has UPOLYC(D5)
--R
--RExamples of primintegrate from TranscendentalIntegration
--R
--E 2285

--S 2286 of 3320
)d op primintfldpoly
--R 
--R
--RThere is one unexposed function called primintfldpoly :
--R   [1] (D1,(D3 -> Union(Record(ratpart: D3,coeff: D3),"failed")),D3)
--R             -> Union(D1,"failed")
--R             from TranscendentalIntegration(D3,D1)
--R             if D3 has FIELD and D1 has UPOLYC(D3)
--R
--RExamples of primintfldpoly from TranscendentalIntegration
--R
--E 2286

--S 2287 of 3320
)d op primitive?
--R 
--R
--RThere is one exposed function called primitive? :
--R   [1] D -> Boolean from D if D has FFIELDC
--R
--RThere is one unexposed function called primitive? :
--R   [1] SparseUnivariatePolynomial(D3) -> Boolean
--R             from FiniteFieldPolynomialPackage(D3) if D3 has FFIELDC
--R         
--R
--RExamples of primitive? from FiniteFieldCategory
--R
--R
--RExamples of primitive? from FiniteFieldPolynomialPackage
--R
--E 2287

--S 2288 of 3320
)d op primitiveElement
--R 
--R
--RThere are 3 exposed functions called primitiveElement :
--R   [1]  -> D from D if D has FFIELDC
--R   [2] List(D4) -> Record(primelt: D4,poly: List(
--R            SparseUnivariatePolynomial(D4)),prim: SparseUnivariatePolynomial(
--R            D4))
--R             from FunctionSpacePrimitiveElement(D3,D4)
--R             if D4 has FS(D3) and D3 has Join(IntegralDomain,OrderedSet
--R            ,CharacteristicZero)
--R   [3] (D2,D2) -> Record(primelt: D2,pol1: SparseUnivariatePolynomial(
--R            D2),pol2: SparseUnivariatePolynomial(D2),prim: 
--R            SparseUnivariatePolynomial(D2))
--R             from FunctionSpacePrimitiveElement(D3,D2)
--R             if D3 has Join(IntegralDomain,OrderedSet,
--R            CharacteristicZero) and D2 has ACF and D2 has FS(D3)
--R
--RThere are 3 unexposed functions called primitiveElement :
--R   [1] (Polynomial(D4),Symbol,Polynomial(D4),Symbol) -> Record(coef1: 
--R            Integer,coef2: Integer,prim: SparseUnivariatePolynomial(D4))
--R             from PrimitiveElement(D4) if D4 has Join(Field,
--R            CharacteristicZero)
--R   [2] (List(Polynomial(D4)),List(Symbol)) -> Record(coef: List(Integer
--R            ),poly: List(SparseUnivariatePolynomial(D4)),prim: 
--R            SparseUnivariatePolynomial(D4))
--R             from PrimitiveElement(D4) if D4 has Join(Field,
--R            CharacteristicZero)
--R   [3] (List(Polynomial(D5)),List(Symbol),Symbol) -> Record(coef: List(
--R            Integer),poly: List(SparseUnivariatePolynomial(D5)),prim: 
--R            SparseUnivariatePolynomial(D5))
--R             from PrimitiveElement(D5) if D5 has Join(Field,
--R            CharacteristicZero)
--R
--RExamples of primitiveElement from FiniteFieldCategory
--R
--R
--RExamples of primitiveElement from FunctionSpacePrimitiveElement
--R
--R
--RExamples of primitiveElement from PrimitiveElement
--R
--E 2288

--S 2289 of 3320
)d op primitiveMonomials
--R 
--R
--RThere is one exposed function called primitiveMonomials :
--R   [1] D -> List(D) from D
--R             if D2 has RING and D3 has OAMONS and D4 has ORDSET and D
--R             has POLYCAT(D2,D3,D4)
--R
--RExamples of primitiveMonomials from PolynomialCategory
--R
--E 2289

--S 2290 of 3320
)d op primitivePart
--R 
--R
--RThere are 5 exposed functions called primitivePart :
--R   [1] D -> D from D
--R             if D has FAMR(D1,D2) and D1 has RING and D2 has OAMON and 
--R            D1 has GCDDOM
--R   [2] D -> D from D
--R             if D has FFCAT(D1,D2,D3) and D1 has UFD and D2 has UPOLYC(
--R            D1) and D3 has UPOLYC(FRAC(D2))
--R   [3] D -> D from D if D has OREPCAT(D1) and D1 has RING and D1 has 
--R            GCDDOM
--R   [4] (D,D1) -> D from D
--R             if D has POLYCAT(D2,D3,D1) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET and D2 has GCDDOM
--R   [5] D -> D from D
--R             if D has POLYCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has GCDDOM
--R
--RThere is one unexposed function called primitivePart :
--R   [1] (D1,D2) -> D1 from SubResultantPackage(D2,D1)
--R             if D2 has EUCDOM and D2 has INTDOM and D1 has UPOLYC(D2)
--R         
--R
--RExamples of primitivePart from FiniteAbelianMonoidRing
--R
--R
--RExamples of primitivePart from FunctionFieldCategory
--R
--R
--RExamples of primitivePart from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of primitivePart from PolynomialCategory
--R
--R
--RExamples of primitivePart from SubResultantPackage
--R
--E 2290

--S 2291 of 3320
)d op primitivePart!
--R 
--R
--RThere is one exposed function called primitivePart! :
--R   [1] D -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has GCDDOM
--R
--RExamples of primitivePart! from RecursivePolynomialCategory
--R
--E 2291

--S 2292 of 3320
)d op primitiveRowEchelon
--R 
--R
--RThere is one exposed function called primitiveRowEchelon :
--R   [1] SparseEchelonMatrix(D2,D3) -> Record(Ech: SparseEchelonMatrix(D2
--R            ,D3),Lt: Matrix(Fraction(D3)),Pivots: List(D3),Rank: 
--R            NonNegativeInteger)
--R             from SparseEchelonMatrix(D2,D3)
--R             if D3 has GCDDOM and D2 has ORDSET and D3 has RING
--R
--RExamples of primitiveRowEchelon from SparseEchelonMatrix
--R
--E 2292

--S 2293 of 3320
)d op primlimintfrac
--R 
--R
--RThere is one unexposed function called primlimintfrac :
--R   [1] (Fraction(D6),(D6 -> D6),List(Fraction(D6))) -> Union(Record(
--R            mainpart: Fraction(D6),limitedlogs: List(Record(coeff: Fraction(
--R            D6),logand: Fraction(D6)))),"failed")
--R             from TranscendentalIntegration(D5,D6)
--R             if D6 has UPOLYC(D5) and D5 has FIELD
--R
--RExamples of primlimintfrac from TranscendentalIntegration
--R
--E 2293

--S 2294 of 3320
)d op primlimitedint
--R 
--R
--RThere is one unexposed function called primlimitedint :
--R   [1] (Fraction(D7),(D7 -> D7),(D6 -> Union(Record(ratpart: D6,coeff: 
--R            D6),"failed")),List(Fraction(D7))) -> Union(Record(answer: 
--R            Record(mainpart: Fraction(D7),limitedlogs: List(Record(coeff: 
--R            Fraction(D7),logand: Fraction(D7)))),a0: D6),"failed")
--R             from TranscendentalIntegration(D6,D7)
--R             if D6 has FIELD and D7 has UPOLYC(D6)
--R
--RExamples of primlimitedint from TranscendentalIntegration
--R
--E 2294

--S 2295 of 3320
)d op primPartElseUnitCanonical
--R 
--R
--RThere is one exposed function called primPartElseUnitCanonical :
--R   [1] D -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has INTDOM
--R
--RExamples of primPartElseUnitCanonical from RecursivePolynomialCategory
--R
--E 2295

--S 2296 of 3320
)d op primPartElseUnitCanonical!
--R 
--R
--RThere is one exposed function called primPartElseUnitCanonical! :
--R   [1] D -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has INTDOM
--R
--RExamples of primPartElseUnitCanonical! from RecursivePolynomialCategory
--R
--E 2296

--S 2297 of 3320
)d op prinb
--R 
--R
--RThere is one unexposed function called prinb :
--R   [1] Integer -> Void from GroebnerInternalPackage(D3,D4,D5,D6)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has POLYCAT(D3,D4,D5)
--R
--RExamples of prinb from GroebnerInternalPackage
--R
--E 2297

--S 2298 of 3320
)d op principal?
--R 
--R
--RThere is one exposed function called principal? :
--R   [1] D -> Boolean from D
--R             if D has FDIVCAT(D2,D3,D4,D5) and D2 has FIELD and D3 has 
--R            UPOLYC(D2) and D4 has UPOLYC(FRAC(D3)) and D5 has FFCAT(D2,
--R            D3,D4)
--R
--RExamples of principal? from FiniteDivisorCategory
--R
--E 2298

--S 2299 of 3320
)d op principalIdeal
--R 
--R
--RThere is one exposed function called principalIdeal :
--R   [1] List(D) -> Record(coef: List(D),generator: D) from D if D has 
--R            PID
--R
--RExamples of principalIdeal from PrincipalIdealDomain
--R
--E 2299

--S 2300 of 3320
)d op principalSubResultantSet
--R 
--R
--RThere is one exposed function called principalSubResultantSet :
--R   [1] (SparseUnivariatePolynomial(Polynomial(D3)),
--R            SparseUnivariatePolynomial(Polynomial(D3))) -> List(Polynomial(D3
--R            ))
--R             from CylindricalAlgebraicDecompositionPackage(D3) if D3
--R             has RCFIELD
--R
--RExamples of principalSubResultantSet from CylindricalAlgebraicDecompositionPackage
--R
--E 2300

--S 2301 of 3320
)d op prindINFO
--R 
--R
--RThere is one unexposed function called prindINFO :
--R   [1] (Record(lcmfij: D5,totdeg: NonNegativeInteger,poli: D3,polj: D3)
--R            ,D3,D3,Integer,Integer,Integer) -> Integer
--R             from GroebnerInternalPackage(D4,D5,D6,D3)
--R             if D5 has OAMONS and D3 has POLYCAT(D4,D5,D6) and D4 has 
--R            GCDDOM and D6 has ORDSET
--R
--RExamples of prindINFO from GroebnerInternalPackage
--R
--E 2301

--S 2302 of 3320
)d op prinpolINFO
--R 
--R
--RThere is one unexposed function called prinpolINFO :
--R   [1] List(D6) -> Void from GroebnerInternalPackage(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R
--RExamples of prinpolINFO from GroebnerInternalPackage
--R
--E 2302

--S 2303 of 3320
)d op prinshINFO
--R 
--R
--RThere is one unexposed function called prinshINFO :
--R   [1] D2 -> Void from GroebnerInternalPackage(D3,D4,D5,D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has POLYCAT(D3,D4,D5)
--R
--RExamples of prinshINFO from GroebnerInternalPackage
--R
--E 2303

--S 2304 of 3320
)d op print
--R 
--R
--RThere is one exposed function called print :
--R   [1] OutputForm -> Void from PrintPackage
--R
--RThere is one unexposed function called print :
--R   [1] OutputForm -> Void from OutputForm
--R
--RExamples of print from OutputForm
--R
--R
--RExamples of print from PrintPackage
--R
--E 2304

--S 2305 of 3320
)d op printCode
--R 
--R
--RThere is one exposed function called printCode :
--R   [1] FortranCode -> Void from FortranCode
--R
--RExamples of printCode from FortranCode
--R
--E 2305

--S 2306 of 3320
)d op printHeader
--R 
--R
--RThere are 3 exposed functions called printHeader :
--R   [1]  -> Void from TheSymbolTable
--R   [2] Symbol -> Void from TheSymbolTable
--R   [3] (Symbol,TheSymbolTable) -> Void from TheSymbolTable
--R
--RExamples of printHeader from TheSymbolTable
--R
--E 2306

--S 2307 of 3320
)d op printInfo
--R 
--R
--RThere are 7 exposed functions called printInfo :
--R   [1] List(Boolean) -> Void
--R             from GeneralPackageForAlgebraicFunctionField(D8,D9,D10,D11
--R            ,D12,D13,D1,D2,D3,D4,D5)
--R             if D8 has FIELD and D9: LIST(SYMBOL) and D10 has POLYCAT(
--R            D8,D11,OVAR(D9)) and D11 has DIRPCAT(#(D9),NNI) and D12
--R             has PRSPCAT(D8) and D13 has LOCPOWC(D8) and D1 has PLACESC
--R            (D8,D13) and D2 has DIVCAT(D1) and D3 has INFCLCT(D8,D9,D10
--R            ,D11,D12,D13,D1,D2,D5) and D5 has BLMETCT and D4 has 
--R            DSTRCAT(D3)
--R   [2]  -> Boolean from D if D has LOCPOWC(D2) and D2 has FIELD
--R   [3] Boolean -> Boolean from D if D has LOCPOWC(D2) and D2 has FIELD
--R            
--R   [4] Boolean -> Boolean
--R             from LocalParametrizationOfSimplePointPackage(D2,D3,D4,D5,
--R            D6,D7,D8)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D5 has DIRPCAT(#(
--R            D3),NNI) and D7 has LOCPOWC(D2) and D4 has POLYCAT(D2,D5,
--R            OVAR(D3)) and D6 has PRSPCAT(D2) and D8 has PLACESC(D2,D7)
--R            
--R   [5]  -> Boolean
--R             from LocalParametrizationOfSimplePointPackage(D2,D3,D4,D5,
--R            D6,D7,D8)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D5 has DIRPCAT(#(
--R            D3),NNI) and D7 has LOCPOWC(D2) and D4 has POLYCAT(D2,D5,
--R            OVAR(D3)) and D6 has PRSPCAT(D2) and D8 has PLACESC(D2,D7)
--R            
--R   [6] (List(Record(val: List(D7),tower: D8)),NonNegativeInteger) -> 
--R            Void
--R             from RegularSetDecompositionPackage(D4,D5,D6,D7,D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has RSETCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R   [7] (List(Record(val: List(D7),tower: D8)),NonNegativeInteger) -> 
--R            Void
--R             from SquareFreeRegularSetDecompositionPackage(D4,D5,D6,D7,
--R            D8)
--R             if D7 has RPOLCAT(D4,D5,D6) and D8 has SFRTCAT(D4,D5,D6,D7
--R            ) and D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET
--R
--RExamples of printInfo from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of printInfo from LocalPowerSeriesCategory
--R
--R
--RExamples of printInfo from LocalParametrizationOfSimplePointPackage
--R
--R
--RExamples of printInfo from RegularSetDecompositionPackage
--R
--R
--RExamples of printInfo from SquareFreeRegularSetDecompositionPackage
--R
--E 2307

--S 2308 of 3320
)d op printInfo!
--R 
--R
--RThere is one unexposed function called printInfo! :
--R   [1] (String,String) -> Void from TabulatedComputationPackage(D3,D4)
--R             if D3 has SETCAT and D4 has SETCAT
--R
--RExamples of printInfo! from TabulatedComputationPackage
--R
--E 2308

--S 2309 of 3320
)d op printingInfo?
--R 
--R
--RThere is one unexposed function called printingInfo? :
--R   [1]  -> Boolean from TabulatedComputationPackage(D2,D3)
--R             if D2 has SETCAT and D3 has SETCAT
--R
--RExamples of printingInfo? from TabulatedComputationPackage
--R
--E 2309

--S 2310 of 3320
)d op printStatement
--R 
--R
--RThere is one exposed function called printStatement :
--R   [1] List(OutputForm) -> FortranCode from FortranCode
--R
--RExamples of printStatement from FortranCode
--R
--E 2310

--S 2311 of 3320
)d op printStats!
--R 
--R
--RThere is one unexposed function called printStats! :
--R   [1]  -> Void from TabulatedComputationPackage(D2,D3)
--R             if D2 has SETCAT and D3 has SETCAT
--R
--RExamples of printStats! from TabulatedComputationPackage
--R
--E 2311

--S 2312 of 3320
)d op printTypes
--R 
--R
--RThere are 2 exposed functions called printTypes :
--R   [1] Symbol -> Void from TheSymbolTable
--R   [2] SymbolTable -> Void from SymbolTable
--R
--RExamples of printTypes from TheSymbolTable
--R
--R
--RExamples of printTypes from SymbolTable
--R
--E 2312

--S 2313 of 3320
)d op probablyZeroDim?
--R 
--R
--RThere is one unexposed function called probablyZeroDim? :
--R   [1] List(D6) -> Boolean from PolynomialSetUtilitiesPackage(D3,D4,D5,
--R            D6)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has INTDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R
--RExamples of probablyZeroDim? from PolynomialSetUtilitiesPackage
--R
--E 2313

--S 2314 of 3320
)d op problemPoints
--R 
--R
--RThere are 2 exposed functions called problemPoints :
--R   [1] (Expression(DoubleFloat),Symbol,Segment(OrderedCompletion(
--R            DoubleFloat))) -> List(DoubleFloat)
--R             from d01AgentsPackage
--R   [2] (Expression(DoubleFloat),Symbol,Segment(OrderedCompletion(
--R            DoubleFloat))) -> List(DoubleFloat)
--R             from ExpertSystemContinuityPackage
--R
--RExamples of problemPoints from d01AgentsPackage
--R
--R
--RExamples of problemPoints from ExpertSystemContinuityPackage
--R
--E 2314

--S 2315 of 3320
)d op processTemplate
--R 
--R
--RThere are 2 exposed functions called processTemplate :
--R   [1] FileName -> FileName from FortranTemplate
--R   [2] (FileName,FileName) -> FileName from FortranTemplate
--R
--RExamples of processTemplate from FortranTemplate
--R
--E 2315

--S 2316 of 3320
)d op prod
--R 
--R
--RThere are 3 unexposed functions called prod :
--R   [1] (OutputForm,OutputForm,OutputForm) -> OutputForm from OutputForm
--R            
--R   [2] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [3] OutputForm -> OutputForm from OutputForm
--R
--RExamples of prod from OutputForm
--R
--E 2316

--S 2317 of 3320
)d op product
--R 
--R
--RThere are 4 exposed functions called product :
--R   [1] (CartesianTensor(D1,D2,D3),CartesianTensor(D1,D2,D3)) -> 
--R            CartesianTensor(D1,D2,D3)
--R             from CartesianTensor(D1,D2,D3) if D1: INT and D2: NNI and 
--R            D3 has COMRING
--R   [2] (D,SegmentBinding(D)) -> D from D if D has COMBOPC
--R   [3] (D,Symbol) -> D from D if D has COMBOPC
--R   [4] (D,D) -> D from D if D has GRALG(D1,D2) and D1 has COMRING and 
--R            D2 has ABELMON
--R
--RThere are 3 unexposed functions called product :
--R   [1] (D1,Symbol) -> D1 from CombinatorialFunction(D3,D1)
--R             if D3 has Join(OrderedSet,IntegralDomain) and D1 has FS(D3
--R            )
--R   [2] (D1,SegmentBinding(D1)) -> D1 from CombinatorialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R   [3] (XPBWPolynomial(D2,D3),XPBWPolynomial(D2,D3),NonNegativeInteger)
--R             -> XPBWPolynomial(D2,D3)
--R             from XPBWPolynomial(D2,D3) if D2 has ORDSET and D3 has 
--R            COMRING
--R
--RExamples of product from CartesianTensor
--R
--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
--RTm:CartesianTensor(1,2,Integer):=m 
--Rn:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] 
--RTn:CartesianTensor(1,2,Integer):=n 
--RTmn:=product(Tm,Tn)
--R
--R
--RExamples of product from CombinatorialFunction
--R
--R
--RExamples of product from CombinatorialOpsCategory
--R
--R
--RExamples of product from GradedAlgebra
--R
--R
--RExamples of product from XPBWPolynomial
--R
--E 2317

--S 2318 of 3320 done
)d op proj
--R 
--R
--RThere is one unexposed function called proj :
--R   [1] (DeRhamComplex(D2,D3),NonNegativeInteger) -> DeRhamComplex(D2,D3
--R            )
--R             from DeRhamComplex(D2,D3)
--R             if D2 has Join(Ring,OrderedSet) and D3: LIST(SYMBOL)
--R
--RExamples of proj from DeRhamComplex
--R
--RcoefRing := Integer 
--RR3 : List Symbol := [x,y,z] 
--RD := DERHAM(coefRing,R3) 
--R[dx,dy,dz] := [generator(i)$D for i in 1..3] 
--Rproj(dx+dy*dz+dx*dy*dz,2)
--R
--E 2318

--S 2319 of 3320
)d op projection
--R 
--R
--RThere is one exposed function called projection :
--R   [1] Cell(D1) -> Union(Cell(D1),"failed") from Cell(D1) if D1 has 
--R            RCFIELD
--R
--RExamples of projection from Cell
--R
--E 2319

--S 2320 of 3320
)d op projectionSet
--R 
--R
--RThere is one exposed function called projectionSet :
--R   [1] List(SparseUnivariatePolynomial(Polynomial(D3))) -> List(
--R            Polynomial(D3))
--R             from CylindricalAlgebraicDecompositionPackage(D3) if D3
--R             has RCFIELD
--R
--RExamples of projectionSet from CylindricalAlgebraicDecompositionPackage
--R
--E 2320

--S 2321 of 3320
)d op projectivePoint
--R 
--R
--RThere are 3 exposed functions called projectivePoint :
--R   [1] List(PseudoAlgebraicClosureOfFiniteField(D3)) -> 
--R            ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField(D3)
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D3,D4
--R            ,D5)
--R             if D3 has FFIELDC and D4: LIST(SYMBOL) and D5 has BLMETCT
--R            
--R   [2] List(D3) -> ProjectivePlane(D3)
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D5 has BLMETCT
--R         
--R   [3] List(D2) -> D from D if D2 has FIELD and D has PRSPCAT(D2)
--R
--RExamples of projectivePoint from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of projectivePoint from PackageForAlgebraicFunctionField
--R
--R
--RExamples of projectivePoint from ProjectiveSpaceCategory
--R
--E 2321

--S 2322 of 3320
)d op prolateSpheroidal
--R 
--R
--RThere is one exposed function called prolateSpheroidal :
--R   [1] D2 -> (Point(D2) -> Point(D2)) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of prolateSpheroidal from CoordinateSystems
--R
--E 2322

--S 2323 of 3320
)d op prologue
--R 
--R
--RThere are 2 exposed functions called prologue :
--R   [1] ScriptFormulaFormat -> List(String) from ScriptFormulaFormat
--R   [2] TexFormat -> List(String) from TexFormat
--R
--RExamples of prologue from ScriptFormulaFormat
--R
--R
--RExamples of prologue from TexFormat
--R
--E 2323

--S 2324 of 3320
)d op properties
--R 
--R
--RThere is one exposed function called properties :
--R   [1] BasicOperator -> AssociationList(String,None) from BasicOperator
--R            
--R
--RExamples of properties from BasicOperator
--R
--E 2324

--S 2325 of 3320
)d op property
--R 
--R
--RThere is one exposed function called property :
--R   [1] (BasicOperator,String) -> Union(None,"failed") from 
--R            BasicOperator
--R
--RExamples of property from BasicOperator
--R
--E 2325

--S 2326 of 3320
)d op pseudoDivide
--R 
--R
--RThere are 2 exposed functions called pseudoDivide :
--R   [1] (D,D) -> Record(quotient: D,remainder: D) from D
--R             if D2 has RING and D3 has OAMONS and D4 has ORDSET and D
--R             has RPOLCAT(D2,D3,D4)
--R   [2] (D,D) -> Record(coef: D2,quotient: D,remainder: D) from D
--R             if D2 has INTDOM and D2 has RING and D has UPOLYC(D2)
--R
--RThere is one unexposed function called pseudoDivide :
--R   [1] (D2,D2) -> Record(coef: D3,quotient: D2,remainder: D2)
--R             from PseudoRemainderSequence(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of pseudoDivide from PseudoRemainderSequence
--R
--R
--RExamples of pseudoDivide from RecursivePolynomialCategory
--R
--R
--RExamples of pseudoDivide from UnivariatePolynomialCategory
--R
--E 2326

--S 2327 of 3320
)d op pseudoQuotient
--R 
--R
--RThere is one exposed function called pseudoQuotient :
--R   [1] (D,D) -> D from D if D has UPOLYC(D1) and D1 has RING and D1
--R             has INTDOM
--R
--RExamples of pseudoQuotient from UnivariatePolynomialCategory
--R
--E 2327

--S 2328 of 3320
)d op pseudoRem
--R 
--R
--RThere is one exposed function called pseudoRem :
--R   [1] (D1,D1,D2) -> D1 from D
--R             if D has MAGCDOC(D1,D2) and D1 has TYPE and D2 has TYPE
--R         
--R
--RExamples of pseudoRem from ModularAlgebraicGcdOperations
--R
--E 2328

--S 2329 of 3320
)d op pseudoRemainder
--R 
--R
--RThere is one exposed function called pseudoRemainder :
--R   [1] (D,D) -> D from D if D has UPOLYC(D1) and D1 has RING
--R
--RExamples of pseudoRemainder from UnivariatePolynomialCategory
--R
--E 2329

--S 2330 of 3320
)d op psolve
--R 
--R
--RThere are 12 unexposed functions called psolve :
--R   [1] (Matrix(D7),List(D7)) -> List(Record(eqzro: List(D7),neqzro: 
--R            List(D7),wcond: List(Polynomial(D4)),bsoln: Record(partsol: 
--R            Vector(Fraction(Polynomial(D4))),basis: List(Vector(Fraction(
--R            Polynomial(D4)))))))
--R             from ParametricLinearEquations(D4,D5,D6,D7)
--R             if D7 has POLYCAT(D4,D6,D5) and D4 has Join(
--R            EuclideanDomain,CharacteristicZero) and D5 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D6 has OAMONS
--R   [2] (Matrix(D7),List(Symbol)) -> List(Record(eqzro: List(D7),neqzro
--R            : List(D7),wcond: List(Polynomial(D4)),bsoln: Record(partsol: 
--R            Vector(Fraction(Polynomial(D4))),basis: List(Vector(Fraction(
--R            Polynomial(D4)))))))
--R             from ParametricLinearEquations(D4,D5,D6,D7)
--R             if D7 has POLYCAT(D4,D6,D5) and D4 has Join(
--R            EuclideanDomain,CharacteristicZero) and D5 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D6 has OAMONS
--R   [3] Matrix(D6) -> List(Record(eqzro: List(D6),neqzro: List(D6),wcond
--R            : List(Polynomial(D3)),bsoln: Record(partsol: Vector(Fraction(
--R            Polynomial(D3))),basis: List(Vector(Fraction(Polynomial(D3)))))))
--R             from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D5,D4) and D3 has Join(
--R            EuclideanDomain,CharacteristicZero) and D4 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D5 has OAMONS
--R   [4] (Matrix(D8),List(D8),PositiveInteger) -> List(Record(eqzro: List
--R            (D8),neqzro: List(D8),wcond: List(Polynomial(D5)),bsoln: Record(
--R            partsol: Vector(Fraction(Polynomial(D5))),basis: List(Vector(
--R            Fraction(Polynomial(D5)))))))
--R             from ParametricLinearEquations(D5,D6,D7,D8)
--R             if D8 has POLYCAT(D5,D7,D6) and D5 has Join(
--R            EuclideanDomain,CharacteristicZero) and D6 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D7 has OAMONS
--R   [5] (Matrix(D8),List(Symbol),PositiveInteger) -> List(Record(eqzro: 
--R            List(D8),neqzro: List(D8),wcond: List(Polynomial(D5)),bsoln: 
--R            Record(partsol: Vector(Fraction(Polynomial(D5))),basis: List(
--R            Vector(Fraction(Polynomial(D5)))))))
--R             from ParametricLinearEquations(D5,D6,D7,D8)
--R             if D8 has POLYCAT(D5,D7,D6) and D5 has Join(
--R            EuclideanDomain,CharacteristicZero) and D6 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D7 has OAMONS
--R   [6] (Matrix(D7),PositiveInteger) -> List(Record(eqzro: List(D7),
--R            neqzro: List(D7),wcond: List(Polynomial(D4)),bsoln: Record(
--R            partsol: Vector(Fraction(Polynomial(D4))),basis: List(Vector(
--R            Fraction(Polynomial(D4)))))))
--R             from ParametricLinearEquations(D4,D5,D6,D7)
--R             if D7 has POLYCAT(D4,D6,D5) and D4 has Join(
--R            EuclideanDomain,CharacteristicZero) and D5 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D6 has OAMONS
--R   [7] (Matrix(D8),List(D8),String) -> Integer
--R             from ParametricLinearEquations(D5,D6,D7,D8)
--R             if D8 has POLYCAT(D5,D7,D6) and D5 has Join(
--R            EuclideanDomain,CharacteristicZero) and D6 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D7 has OAMONS
--R   [8] (Matrix(D8),List(Symbol),String) -> Integer
--R             from ParametricLinearEquations(D5,D6,D7,D8)
--R             if D8 has POLYCAT(D5,D7,D6) and D5 has Join(
--R            EuclideanDomain,CharacteristicZero) and D6 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D7 has OAMONS
--R   [9] (Matrix(D7),String) -> Integer
--R             from ParametricLinearEquations(D4,D5,D6,D7)
--R             if D7 has POLYCAT(D4,D6,D5) and D4 has Join(
--R            EuclideanDomain,CharacteristicZero) and D5 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D6 has OAMONS
--R   [10] (Matrix(D1),List(D1),PositiveInteger,String) -> Integer
--R             from ParametricLinearEquations(D7,D8,D9,D1)
--R             if D1 has POLYCAT(D7,D9,D8) and D7 has Join(
--R            EuclideanDomain,CharacteristicZero) and D8 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D9 has OAMONS
--R   [11] (Matrix(D1),List(Symbol),PositiveInteger,String) -> Integer
--R             from ParametricLinearEquations(D7,D8,D9,D1)
--R             if D1 has POLYCAT(D7,D9,D8) and D7 has Join(
--R            EuclideanDomain,CharacteristicZero) and D8 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D9 has OAMONS
--R   [12] (Matrix(D8),PositiveInteger,String) -> Integer
--R             from ParametricLinearEquations(D5,D6,D7,D8)
--R             if D8 has POLYCAT(D5,D7,D6) and D5 has Join(
--R            EuclideanDomain,CharacteristicZero) and D6 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D7 has OAMONS
--R
--RExamples of psolve from ParametricLinearEquations
--R
--E 2330

--S 2331 of 3320
)d op ptFunc
--R 
--R
--RThere is one unexposed function called ptFunc :
--R   [1] (((DoubleFloat,DoubleFloat) -> DoubleFloat),((DoubleFloat,
--R            DoubleFloat) -> DoubleFloat),((DoubleFloat,DoubleFloat) -> 
--R            DoubleFloat),((DoubleFloat,DoubleFloat,DoubleFloat) -> 
--R            DoubleFloat)) -> ((DoubleFloat,DoubleFloat) -> Point(DoubleFloat)
--R            )
--R             from MeshCreationRoutinesForThreeDimensions
--R
--RExamples of ptFunc from MeshCreationRoutinesForThreeDimensions
--R
--E 2331

--S 2332 of 3320
)d op pToDmp
--R 
--R
--RThere is one unexposed function called pToDmp :
--R   [1] Polynomial(D4) -> DistributedMultivariatePolynomial(D3,D4)
--R             from PolToPol(D3,D4) if D4 has RING and D3: LIST(SYMBOL)
--R         
--R
--RExamples of pToDmp from PolToPol
--R
--E 2332

--S 2333 of 3320
)d op pToHdmp
--R 
--R
--RThere is one unexposed function called pToHdmp :
--R   [1] Polynomial(D4) -> HomogeneousDistributedMultivariatePolynomial(
--R            D3,D4)
--R             from PolToPol(D3,D4) if D4 has RING and D3: LIST(SYMBOL)
--R         
--R
--RExamples of pToHdmp from PolToPol
--R
--E 2333

--S 2334 of 3320 done
)d op ptree
--R 
--R
--RThere are 2 exposed functions called ptree :
--R   [1] (PendantTree(D1),PendantTree(D1)) -> PendantTree(D1) from 
--R            PendantTree(D1)
--R             if D1 has SETCAT
--R   [2] D1 -> PendantTree(D1) from PendantTree(D1) if D1 has SETCAT
--R
--RExamples of ptree from PendantTree
--R
--Rt1:=ptree([1,2,3]) 
--Rptree(t1,ptree([1,2,3]))
--R
--Rt1:=ptree([1,2,3])
--R
--E 2334

--S 2335 of 3320
)d op puiseux
--R 
--R
--RThere are 8 exposed functions called puiseux :
--R   [1] Symbol -> Any from ExpressionToUnivariatePowerSeries(D3,D4)
--R             if D3 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D4 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R   [2] D2 -> Any from ExpressionToUnivariatePowerSeries(D3,D2)
--R             if D3 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R   [3] (D2,Fraction(Integer)) -> Any
--R             from ExpressionToUnivariatePowerSeries(D4,D2)
--R             if D4 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D4))
--R   [4] (D2,Equation(D2)) -> Any from ExpressionToUnivariatePowerSeries(
--R            D4,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D4)) and D4
--R             has Join(GcdDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [5] (D2,Equation(D2),Fraction(Integer)) -> Any
--R             from ExpressionToUnivariatePowerSeries(D5,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D5)) and D5
--R             has Join(GcdDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [6] ((Fraction(Integer) -> D7),Equation(D7),UniversalSegment(
--R            Fraction(Integer)),Fraction(Integer)) -> Any
--R             from GenerateUnivariatePowerSeries(D6,D7)
--R             if D7 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D6)) and D6
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [7] (D2,Symbol,Equation(D2),UniversalSegment(Fraction(Integer)),
--R            Fraction(Integer)) -> Any
--R             from GenerateUnivariatePowerSeries(D7,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D7)) and D7
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [8] (Fraction(Integer),D2) -> D from D
--R             if D3 has RING and D has UPXSCCA(D3,D2) and D2 has ULSCAT(
--R            D3)
--R
--RExamples of puiseux from ExpressionToUnivariatePowerSeries
--R
--R
--RExamples of puiseux from GenerateUnivariatePowerSeries
--R
--R
--RExamples of puiseux from UnivariatePuiseuxSeriesConstructorCategory
--R
--E 2335

--S 2336 of 3320
)d op pureLex
--R 
--R
--RThere is one unexposed function called pureLex :
--R   [1] (Vector(D4),Vector(D4)) -> Boolean from OrderingFunctions(D3,D4)
--R             if D4 has OAMON and D3: NNI
--R
--RExamples of pureLex from OrderingFunctions
--R
--E 2336

--S 2337 of 3320
)d op purelyAlgebraic?
--R 
--R
--RThere are 2 exposed functions called purelyAlgebraic? :
--R   [1] D -> Boolean from D
--R             if D has RSETCAT(D2,D3,D4,D5) and D2 has GCDDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R   [2] (D2,D) -> Boolean from D
--R             if D has RSETCAT(D3,D4,D5,D2) and D3 has GCDDOM and D4
--R             has OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R            
--R
--RExamples of purelyAlgebraic? from RegularTriangularSetCategory
--R
--E 2337

--S 2338 of 3320
)d op purelyAlgebraicLeadingMonomial?
--R 
--R
--RThere is one exposed function called purelyAlgebraicLeadingMonomial? :
--R   [1] (D2,D) -> Boolean from D
--R             if D has RSETCAT(D3,D4,D5,D2) and D3 has GCDDOM and D4
--R             has OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R            
--R
--RExamples of purelyAlgebraicLeadingMonomial? from RegularTriangularSetCategory
--R
--E 2338

--S 2339 of 3320
)d op purelyTranscendental?
--R 
--R
--RThere is one exposed function called purelyTranscendental? :
--R   [1] (D2,D) -> Boolean from D
--R             if D has RSETCAT(D3,D4,D5,D2) and D3 has GCDDOM and D4
--R             has OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R            
--R
--RExamples of purelyTranscendental? from RegularTriangularSetCategory
--R
--E 2339

--S 2340 of 3320
)d op purge!
--R 
--R
--RThere is one exposed function called purge! :
--R   [1] (SparseEchelonMatrix(D3,D4),(D3 -> Boolean)) -> Void
--R             from SparseEchelonMatrix(D3,D4) if D3 has ORDSET and D4
--R             has RING
--R
--RExamples of purge! from SparseEchelonMatrix
--R
--E 2340

--S 2341 of 3320 done
)d op push!
--R 
--R
--RThere are 4 exposed functions called push! :
--R   [1] (D1,ArrayStack(D1)) -> D1 from ArrayStack(D1) if D1 has SETCAT
--R         
--R   [2] (D1,Dequeue(D1)) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [3] (D1,D) -> D1 from D if D has SKAGG(D1) and D1 has TYPE
--R   [4] (D1,Stack(D1)) -> D1 from Stack(D1) if D1 has SETCAT
--R
--RExamples of push! from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rpush!(9,a) 
--Ra
--R
--R
--RExamples of push! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rpush! a 
--Ra
--R
--R
--RExamples of push! from StackAggregate
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rpush! a 
--Ra
--R
--R
--RExamples of push! from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rpush!(9,a) 
--Ra
--R
--E 2341

--S 2342 of 3320
)d op pushdown
--R 
--R
--RThere is one exposed function called pushdown :
--R   [1] (D1,D2) -> D1 from MPolyCatRationalFunctionFactorizer(D3,D2,D4,
--R            D1)
--R             if D3 has OAMONS and D2 has OrderedSetwith
--R               convert : % -> Symboland D4 has INTDOM and D1 has 
--R            POLYCAT(FRAC(POLY(D4)),D3,D2)
--R
--RThere are 2 unexposed functions called pushdown :
--R   [1] (D1,D2) -> D1 from PushVariables(D3,D4,D2,D1)
--R             if D3 has RING and D4 has OAMONS and D2 has OrderedSetwith
--R               convert : % -> Symbol
--R               variable : Symbol -> Union(%,"failed")and D1 has 
--R            POLYCAT(POLY(D3),D4,D2)
--R   [2] (D1,List(D5)) -> D1 from PushVariables(D3,D4,D5,D1)
--R             if D5 has OrderedSetwith
--R               convert : % -> Symbol
--R               variable : Symbol -> Union(%,"failed")and D3 has RING
--R            and D4 has OAMONS and D1 has POLYCAT(POLY(D3),D4,D5)
--R
--RExamples of pushdown from MPolyCatRationalFunctionFactorizer
--R
--R
--RExamples of pushdown from PushVariables
--R
--E 2342

--S 2343 of 3320
)d op pushdterm
--R 
--R
--RThere is one exposed function called pushdterm :
--R   [1] (SparseUnivariatePolynomial(D1),D3) -> D1
--R             from MPolyCatRationalFunctionFactorizer(D4,D3,D5,D1)
--R             if D1 has POLYCAT(FRAC(POLY(D5)),D4,D3) and D4 has OAMONS 
--R            and D3 has OrderedSetwith
--R               convert : % -> Symboland D5 has INTDOM
--R
--RExamples of pushdterm from MPolyCatRationalFunctionFactorizer
--R
--E 2343

--S 2344 of 3320
)d op pushFortranOutputStack
--R 
--R
--RThere are 2 exposed functions called pushFortranOutputStack :
--R   [1] FileName -> Void from FortranOutputStackPackage
--R   [2] String -> Void from FortranOutputStackPackage
--R
--RExamples of pushFortranOutputStack from FortranOutputStackPackage
--R
--E 2344

--S 2345 of 3320
)d op pushucoef
--R 
--R
--RThere is one exposed function called pushucoef :
--R   [1] (SparseUnivariatePolynomial(Polynomial(D5)),D3) -> D1
--R             from MPolyCatRationalFunctionFactorizer(D4,D3,D5,D1)
--R             if D5 has INTDOM and D1 has POLYCAT(FRAC(POLY(D5)),D4,D3) 
--R            and D4 has OAMONS and D3 has OrderedSetwith
--R               convert : % -> Symbol
--R
--RExamples of pushucoef from MPolyCatRationalFunctionFactorizer
--R
--E 2345

--S 2346 of 3320
)d op pushuconst
--R 
--R
--RThere is one exposed function called pushuconst :
--R   [1] (Fraction(Polynomial(D5)),D3) -> D1
--R             from MPolyCatRationalFunctionFactorizer(D4,D3,D5,D1)
--R             if D5 has INTDOM and D1 has POLYCAT(FRAC(POLY(D5)),D4,D3) 
--R            and D4 has OAMONS and D3 has OrderedSetwith
--R               convert : % -> Symbol
--R
--RExamples of pushuconst from MPolyCatRationalFunctionFactorizer
--R
--E 2346

--S 2347 of 3320
)d op pushup
--R 
--R
--RThere is one exposed function called pushup :
--R   [1] (D1,D2) -> D1 from MPolyCatRationalFunctionFactorizer(D3,D2,D4,
--R            D1)
--R             if D3 has OAMONS and D2 has OrderedSetwith
--R               convert : % -> Symboland D4 has INTDOM and D1 has 
--R            POLYCAT(FRAC(POLY(D4)),D3,D2)
--R
--RThere are 2 unexposed functions called pushup :
--R   [1] (D1,D2) -> D1 from PushVariables(D3,D4,D2,D1)
--R             if D3 has RING and D4 has OAMONS and D2 has OrderedSetwith
--R               convert : % -> Symbol
--R               variable : Symbol -> Union(%,"failed")and D1 has 
--R            POLYCAT(POLY(D3),D4,D2)
--R   [2] (D1,List(D5)) -> D1 from PushVariables(D3,D4,D5,D1)
--R             if D5 has OrderedSetwith
--R               convert : % -> Symbol
--R               variable : Symbol -> Union(%,"failed")and D3 has RING
--R            and D4 has OAMONS and D1 has POLYCAT(POLY(D3),D4,D5)
--R
--RExamples of pushup from MPolyCatRationalFunctionFactorizer
--R
--R
--RExamples of pushup from PushVariables
--R
--E 2347

--S 2348 of 3320
)d op putColorInfo
--R 
--R
--RThere is one unexposed function called putColorInfo :
--R   [1] (List(List(Point(DoubleFloat))),List(Palette)) -> List(List(
--R            Point(DoubleFloat)))
--R             from GraphImage
--R
--RExamples of putColorInfo from GraphImage
--R
--E 2348

--S 2349 of 3320
)d op putGraph
--R 
--R
--RThere is one unexposed function called putGraph :
--R   [1] (TwoDimensionalViewport,GraphImage,PositiveInteger) -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of putGraph from TwoDimensionalViewport
--R
--E 2349

--S 2350 of 3320
)d op qcoerce
--R 
--R
--RThere are 2 exposed functions called qcoerce :
--R   [1] Integer -> NonNegativeInteger from NonNegativeInteger
--R   [2] Integer -> PositiveInteger from PositiveInteger
--R
--RExamples of qcoerce from NonNegativeInteger
--R
--R
--RExamples of qcoerce from PositiveInteger
--R
--E 2350

--S 2351 of 3320
)d op qelt
--R 
--R
--RThere are 3 exposed functions called qelt :
--R   [1] (D,Integer,Integer) -> D1 from D
--R             if D has ARR2CAT(D1,D3,D4) and D3 has FLAGG(D1) and D4
--R             has FLAGG(D1) and D1 has TYPE
--R   [2] (D,D2) -> D1 from D if D has ELTAGG(D2,D1) and D2 has SETCAT and
--R            D1 has TYPE
--R   [3] (D,Integer,Integer) -> D1 from D
--R             if D has RMATCAT(D3,D4,D1,D5,D6) and D5 has DIRPCAT(D4,D1)
--R            and D6 has DIRPCAT(D3,D1) and D1 has RING
--R
--RExamples of qelt from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rqelt(arr,1,1)
--R
--R
--RExamples of qelt from EltableAggregate
--R
--R
--RExamples of qelt from RectangularMatrixCategory
--R
--E 2351

--S 2352 of 3320
)d op qfactor
--R 
--R
--RThere is one unexposed function called qfactor :
--R   [1] D2 -> Union(Factored(SparseUnivariatePolynomial(Fraction(Integer
--R            ))),"failed")
--R             from FunctionSpaceUnivariatePolynomialFactor(D3,D4,D2)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer)) and D4 has FS(D3) and D2 has UPOLYC(D4)
--R
--RExamples of qfactor from FunctionSpaceUnivariatePolynomialFactor
--R
--E 2352

--S 2353 of 3320
)d op qinterval
--R 
--R
--RThere is one exposed function called qinterval :
--R   [1] (D1,D1) -> D from D
--R             if D has INTCAT(D1) and D1 has Join(FloatingPointSystem,
--R            TranscendentalFunctionCategory)
--R
--RExamples of qinterval from IntervalCategory
--R
--E 2353

--S 2354 of 3320 done
)d op qnew
--R 
--R
--RThere are 7 exposed functions called qnew :
--R   [1] (Integer,Integer) -> ComplexDoubleFloatMatrix
--R             from ComplexDoubleFloatMatrix
--R   [2] Integer -> ComplexDoubleFloatVector from 
--R            ComplexDoubleFloatVector
--R   [3] (Integer,Integer) -> DoubleFloatMatrix from DoubleFloatMatrix
--R         
--R   [4] Integer -> DoubleFloatVector from DoubleFloatVector
--R   [5] (Integer,Integer) -> U16Matrix from U16Matrix
--R   [6] (Integer,Integer) -> U32Matrix from U32Matrix
--R   [7] (Integer,Integer) -> U8Matrix from U8Matrix
--R
--RExamples of qnew from ComplexDoubleFloatMatrix
--R
--Rt1:CDFMAT:=qnew(3,4)
--R
--R
--RExamples of qnew from ComplexDoubleFloatVector
--R
--Rt1:CDFVEC:=qnew 7
--R
--R
--RExamples of qnew from DoubleFloatMatrix
--R
--Rt1:DFMAT:=qnew(3,4)
--R
--R
--RExamples of qnew from DoubleFloatVector
--R
--Rt1:DFVEC:=qnew(7)
--R
--R
--RExamples of qnew from U16Matrix
--R
--Rqnew(3,4)$U16Matrix()
--R
--R
--RExamples of qnew from U32Matrix
--R
--Rqnew(3,4)$U32Matrix()
--R
--R
--RExamples of qnew from U8Matrix
--R
--Rqnew(3,4)$U8Matrix()
--R
--E 2354

--S 2355 of 3320
)d op qPot
--R 
--R
--RThere is one unexposed function called qPot :
--R   [1] (Vector(D3),Integer) -> Vector(D3)
--R             from InnerNormalBasisFieldFunctions(D3) if D3 has FFIELDC
--R            
--R
--RExamples of qPot from InnerNormalBasisFieldFunctions
--R
--E 2355

--S 2356 of 3320
)d op qqq
--R 
--R
--RThere is one unexposed function called qqq :
--R   [1] (NonNegativeInteger,TaylorSeries(D5),Stream(TaylorSeries(D5)))
--R             -> (Stream(TaylorSeries(D5)) -> Stream(TaylorSeries(D5)))
--R             from WeierstrassPreparation(D5) if D5 has FIELD
--R
--RExamples of qqq from WeierstrassPreparation
--R
--E 2356

--S 2357 of 3320
)d op qroot
--R 
--R
--RThere is one unexposed function called qroot :
--R   [1] (Fraction(Integer),NonNegativeInteger) -> Record(exponent: 
--R            NonNegativeInteger,coef: D8,radicand: D8)
--R             from PolynomialRoots(D4,D5,D6,D7,D8)
--R             if D4 has OAMONS and D5 has ORDSET and D6 has INTDOM and 
--R            D7 has POLYCAT(D6,D4,D5) and D8 has Fieldwith
--R               numer : % -> D7
--R               denom : % -> D7
--R               coerce : D7 -> %
--R
--RExamples of qroot from PolynomialRoots
--R
--E 2357

--S 2358 of 3320
)d op qsetelt!
--R 
--R
--RThere are 2 exposed functions called qsetelt! :
--R   [1] (D,Integer,Integer,D1) -> D1 from D
--R             if D has ARR2CAT(D1,D3,D4) and D1 has TYPE and D3 has 
--R            FLAGG(D1) and D4 has FLAGG(D1)
--R   [2] (D,D2,D1) -> D1 from D
--R             if D has shallowlyMutable and D has ELTAGG(D2,D1) and D2
--R             has SETCAT and D1 has TYPE
--R
--RExamples of qsetelt! from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,0) 
--Rqsetelt!(arr,1,1,17)
--R
--R
--RExamples of qsetelt! from EltableAggregate
--R
--E 2358

--S 2359 of 3320
)d op qShiftAction
--R 
--R
--RThere is one exposed function called qShiftAction :
--R   [1] (D1,NonNegativeInteger,NonNegativeInteger,D3) -> D1
--R             from FractionFreeFastGaussian(D1,D3)
--R             if D1 has Join(IntegralDomain,GcdDomain) and D3 has AMR(D1
--R            ,NNI)
--R
--RExamples of qShiftAction from FractionFreeFastGaussian
--R
--E 2359

--S 2360 of 3320
)d op qShiftC
--R 
--R
--RThere is one exposed function called qShiftC :
--R   [1] (D2,NonNegativeInteger) -> List(D2) from 
--R            FractionFreeFastGaussian(D2,D4)
--R             if D2 has Join(IntegralDomain,GcdDomain) and D4 has AMR(D2
--R            ,NNI)
--R
--RExamples of qShiftC from FractionFreeFastGaussian
--R
--E 2360

--S 2361 of 3320
)d op quadratic
--R 
--R
--RThere are 2 unexposed functions called quadratic :
--R   [1] D3 -> List(D4) from PolynomialSolveByFormulas(D3,D4)
--R             if D4 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D3 has UPOLYC(D4)
--R            
--R   [2] (D3,D3,D3) -> List(D3) from PolynomialSolveByFormulas(D4,D3)
--R             if D3 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D4 has UPOLYC(D3)
--R            
--R
--RExamples of quadratic from PolynomialSolveByFormulas
--R
--E 2361

--S 2362 of 3320
)d op quadratic?
--R 
--R
--RThere is one exposed function called quadratic? :
--R   [1] Expression(DoubleFloat) -> Boolean from e04AgentsPackage
--R
--RExamples of quadratic? from e04AgentsPackage
--R
--E 2362

--S 2363 of 3320 done
)d op quadraticBezier
--R 
--R
--RThere is one exposed function called quadraticBezier :
--R   [1] (List(D3),List(D3),List(D3)) -> (D3 -> List(D3)) from Bezier(D3)
--R             if D3 has RING
--R
--RExamples of quadraticBezier from Bezier
--R
--Rn:=quadraticBezier([2.0,2.0],[4.0,4.0],[6.0,2.0]) 
--R[n(t/10.0) for t in 0..10 by 1]
--R
--E 2363

--S 2364 of 3320
)d op quadraticForm
--R 
--R
--RThere is one exposed function called quadraticForm :
--R   [1] SquareMatrix(D2,D3) -> QuadraticForm(D2,D3) from QuadraticForm(
--R            D2,D3)
--R             if D2: PI and D3 has FIELD
--R
--RExamples of quadraticForm from QuadraticForm
--R
--E 2364

--S 2365 of 3320
)d op quadraticNorm
--R 
--R
--RThere is one unexposed function called quadraticNorm :
--R   [1] D2 -> D1 from GaloisGroupFactorizationUtilities(D3,D2,D1)
--R             if D3 has RING and D1 has Join(FloatingPointSystem,
--R            RetractableTo(D3),Field,TranscendentalFunctionCategory,
--R            ElementaryFunctionCategory) and D2 has UPOLYC(D3)
--R
--RExamples of quadraticNorm from GaloisGroupFactorizationUtilities
--R
--E 2365

--S 2366 of 3320
)d op quadTransform
--R 
--R
--RThere is one exposed function called quadTransform :
--R   [1] (DistributedMultivariatePolynomial([construct,QUOTEX,QUOTEY],D4)
--R            ,NonNegativeInteger,D3) -> DistributedMultivariatePolynomial([
--R            construct,QUOTEX,QUOTEY],D4)
--R             from BlowUpPackage(D4,D5,D6,D7,D3)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D7 has DIRPCAT(#(
--R            D5),NNI) and D6 has FAMR(D4,D7) and D3 has BLMETCT
--R
--RExamples of quadTransform from BlowUpPackage
--R
--E 2366

--S 2367 of 3320
)d op quartic
--R 
--R
--RThere are 2 unexposed functions called quartic :
--R   [1] D3 -> List(D4) from PolynomialSolveByFormulas(D3,D4)
--R             if D4 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D3 has UPOLYC(D4)
--R            
--R   [2] (D3,D3,D3,D3,D3) -> List(D3) from PolynomialSolveByFormulas(D4,
--R            D3)
--R             if D3 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D4 has UPOLYC(D3)
--R            
--R
--RExamples of quartic from PolynomialSolveByFormulas
--R
--E 2367

--S 2368 of 3320
)d op quasiAlgebraicSet
--R 
--R
--RThere is one unexposed function called quasiAlgebraicSet :
--R   [1] (List(D2),D2) -> QuasiAlgebraicSet(D3,D4,D5,D2)
--R             from QuasiAlgebraicSet(D3,D4,D5,D2)
--R             if D2 has POLYCAT(D3,D5,D4) and D3 has GCDDOM and D4 has 
--R            ORDSET and D5 has OAMONS
--R
--RExamples of quasiAlgebraicSet from QuasiAlgebraicSet
--R
--E 2368

--S 2369 of 3320
)d op quasiComponent
--R 
--R
--RThere is one exposed function called quasiComponent :
--R   [1] D -> Record(close: List(D5),open: List(D5)) from D
--R             if D has TSETCAT(D2,D3,D4,D5) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R
--RExamples of quasiComponent from TriangularSetCategory
--R
--E 2369

--S 2370 of 3320
)d op quasiMonic?
--R 
--R
--RThere is one exposed function called quasiMonic? :
--R   [1] D -> Boolean from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RExamples of quasiMonic? from RecursivePolynomialCategory
--R
--E 2370

--S 2371 of 3320
)d op quasiMonicPolynomials
--R 
--R
--RThere is one unexposed function called quasiMonicPolynomials :
--R   [1] List(D6) -> Record(goodPols: List(D6),badPols: List(D6))
--R             from PolynomialSetUtilitiesPackage(D3,D4,D5,D6)
--R             if D3 has INTDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5)
--R
--RExamples of quasiMonicPolynomials from PolynomialSetUtilitiesPackage
--R
--E 2371

--S 2372 of 3320
)d op quasiRegular
--R 
--R
--RThere is one exposed function called quasiRegular :
--R   [1] D -> D from D if D has XFALG(D1,D2) and D1 has ORDSET and D2
--R             has RING
--R
--RThere is one unexposed function called quasiRegular :
--R   [1] XPolynomialRing(D1,D2) -> XPolynomialRing(D1,D2)
--R             from XPolynomialRing(D1,D2) if D1 has RING and D2 has 
--R            ORDMON
--R
--RExamples of quasiRegular from XFreeAlgebra
--R
--R
--RExamples of quasiRegular from XPolynomialRing
--R
--E 2372

--S 2373 of 3320
)d op quasiRegular?
--R 
--R
--RThere is one exposed function called quasiRegular? :
--R   [1] D -> Boolean from D if D has XFALG(D2,D3) and D2 has ORDSET and 
--R            D3 has RING
--R
--RThere is one unexposed function called quasiRegular? :
--R   [1] XPolynomialRing(D2,D3) -> Boolean from XPolynomialRing(D2,D3)
--R             if D2 has RING and D3 has ORDMON
--R
--RExamples of quasiRegular? from XFreeAlgebra
--R
--R
--RExamples of quasiRegular? from XPolynomialRing
--R
--E 2373

--S 2374 of 3320
)d op quatern
--R 
--R
--RThere is one exposed function called quatern :
--R   [1] (D1,D1,D1,D1) -> D from D if D has QUATCAT(D1) and D1 has 
--R            COMRING
--R
--RExamples of quatern from QuaternionCategory
--R
--E 2374

--S 2375 of 3320 done
)d op queue
--R 
--R
--RThere is one exposed function called queue :
--R   [1] List(D2) -> Queue(D2) from Queue(D2) if D2 has SETCAT
--R
--RExamples of queue from Queue
--R
--Re:Queue INT:= queue [1,2,3,4,5]
--R
--E 2375

--S 2376 of 3320
)d op quickSort
--R 
--R
--RThere is one exposed function called quickSort :
--R   [1] (((D3,D3) -> Boolean),D1) -> D1 from FiniteLinearAggregateSort(
--R            D3,D1)
--R             if D3 has TYPE and D1 has FiniteLinearAggregate(D3)with
--R                 shallowlyMutable
--R
--RExamples of quickSort from FiniteLinearAggregateSort
--R
--E 2376

--S 2377 of 3320
)d op quo
--R 
--R
--RThere are 2 exposed functions called quo :
--R   [1] (D,D) -> D from D if D has EUCDOM
--R   [2] (NonNegativeInteger,NonNegativeInteger) -> NonNegativeInteger
--R             from NonNegativeInteger
--R
--RThere is one unexposed function called quo :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of quo from EuclideanDomain
--R
--R
--RExamples of quo from NonNegativeInteger
--R
--R
--RExamples of quo from OutputForm
--R
--E 2377

--S 2378 of 3320
)d op quoByVar
--R 
--R
--RThere is one exposed function called quoByVar :
--R   [1] D -> D from D if D has UTSCAT(D1) and D1 has RING
--R
--RExamples of quoByVar from UnivariateTaylorSeriesCategory
--R
--E 2378

--S 2379 of 3320
)d op quote
--R 
--R
--RThere is one exposed function called quote :
--R   [1]  -> Character from Character
--R
--RThere is one unexposed function called quote :
--R   [1] OutputForm -> OutputForm from OutputForm
--R
--RExamples of quote from Character
--R
--Rquote()
--R
--R
--RExamples of quote from OutputForm
--R
--E 2379

--S 2380 of 3320
)d op quoted?
--R 
--R
--RThere is one unexposed function called quoted? :
--R   [1] Pattern(D2) -> Boolean from Pattern(D2) if D2 has SETCAT
--R
--RExamples of quoted? from Pattern
--R
--E 2380

--S 2381 of 3320
)d op quotedOperators
--R 
--R
--RThere is one exposed function called quotedOperators :
--R   [1] RewriteRule(D2,D3,D4) -> List(Symbol) from RewriteRule(D2,D3,D4)
--R             if D2 has SETCAT and D3 has Join(Ring,PatternMatchable(D2)
--R            ,OrderedSet,ConvertibleTo(Pattern(D2))) and D4 has Join(
--R            FunctionSpace(D3),PatternMatchable(D2),ConvertibleTo(
--R            Pattern(D2)))
--R
--RExamples of quotedOperators from RewriteRule
--R
--E 2381

--S 2382 of 3320
)d op quotient
--R 
--R
--RThere are 2 exposed functions called quotient :
--R   [1] (PolynomialIdeals(D2,D3,D4,D1),D1) -> PolynomialIdeals(D2,D3,D4,
--R            D1)
--R             from PolynomialIdeals(D2,D3,D4,D1)
--R             if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D1
--R             has POLYCAT(D2,D3,D4)
--R   [2] (PolynomialIdeals(D1,D2,D3,D4),PolynomialIdeals(D1,D2,D3,D4))
--R             -> PolynomialIdeals(D1,D2,D3,D4)
--R             from PolynomialIdeals(D1,D2,D3,D4)
--R             if D1 has FIELD and D2 has OAMONS and D3 has ORDSET and D4
--R             has POLYCAT(D1,D2,D3)
--R
--RExamples of quotient from PolynomialIdeals
--R
--E 2382

--S 2383 of 3320
)d op quotientByP
--R 
--R
--RThere is one exposed function called quotientByP :
--R   [1] D -> D from D if D has PADICCT(D1)
--R
--RExamples of quotientByP from PAdicIntegerCategory
--R
--E 2383

--S 2384 of 3320
)d op quotValuation
--R 
--R
--RThere is one exposed function called quotValuation :
--R   [1] D -> Integer from D if D has BLMETCT
--R
--RExamples of quotValuation from BlowUpMethodCategory
--R
--E 2384

--S 2385 of 3320
)d op quotVecSpaceBasis
--R 
--R
--RThere is one exposed function called quotVecSpaceBasis :
--R   [1] (List(List(D2)),List(List(D2))) -> List(List(D2)) from 
--R            LinesOpPack(D2)
--R             if D2 has FIELD
--R
--RExamples of quotVecSpaceBasis from LinesOpPack
--R
--E 2385

--S 2386 of 3320
)d op radical
--R 
--R
--RThere is one exposed function called radical :
--R   [1] PolynomialIdeals(Fraction(Integer),DirectProduct(D3,
--R            NonNegativeInteger),OrderedVariableList(D2),
--R            DistributedMultivariatePolynomial(D2,Fraction(Integer))) -> 
--R            PolynomialIdeals(Fraction(Integer),DirectProduct(D3,
--R            NonNegativeInteger),OrderedVariableList(D2),
--R            DistributedMultivariatePolynomial(D2,Fraction(Integer)))
--R             from IdealDecompositionPackage(D2,D3) if D2: LIST(SYMBOL) 
--R            and D3: NNI
--R
--RExamples of radical from IdealDecompositionPackage
--R
--E 2386

--S 2387 of 3320
)d op radicalEigenvalues
--R 
--R
--RThere is one exposed function called radicalEigenvalues :
--R   [1] Matrix(Fraction(Polynomial(Integer))) -> List(Expression(Integer
--R            ))
--R             from RadicalEigenPackage
--R
--RExamples of radicalEigenvalues from RadicalEigenPackage
--R
--E 2387

--S 2388 of 3320
)d op radicalEigenvector
--R 
--R
--RThere is one exposed function called radicalEigenvector :
--R   [1] (Expression(Integer),Matrix(Fraction(Polynomial(Integer)))) -> 
--R            List(Matrix(Expression(Integer)))
--R             from RadicalEigenPackage
--R
--RExamples of radicalEigenvector from RadicalEigenPackage
--R
--E 2388

--S 2389 of 3320
)d op radicalEigenvectors
--R 
--R
--RThere is one exposed function called radicalEigenvectors :
--R   [1] Matrix(Fraction(Polynomial(Integer))) -> List(Record(radval: 
--R            Expression(Integer),radmult: Integer,radvect: List(Matrix(
--R            Expression(Integer)))))
--R             from RadicalEigenPackage
--R
--RExamples of radicalEigenvectors from RadicalEigenPackage
--R
--E 2389

--S 2390 of 3320
)d op radicalOfLeftTraceForm
--R 
--R
--RThere is one exposed function called radicalOfLeftTraceForm :
--R   [1]  -> List(D3) from AlgebraPackage(D2,D3)
--R             if D2 has INTDOM and D3 has FRNAALG(D2)
--R
--RExamples of radicalOfLeftTraceForm from AlgebraPackage
--R
--E 2390

--S 2391 of 3320 done
)d op radicalRoots
--R 
--R
--RThere are 2 exposed functions called radicalRoots :
--R   [1] (Fraction(Polynomial(D4)),Symbol) -> List(Expression(D4))
--R             from RadicalSolvePackage(D4)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero)
--R   [2] (List(Fraction(Polynomial(D4))),List(Symbol)) -> List(List(
--R            Expression(D4)))
--R             from RadicalSolvePackage(D4)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero)
--R
--RExamples of radicalRoots from RadicalSolvePackage
--R
--Rb:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) 
--Rc:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) 
--RradicalRoots([b,c],[x,y])
--R
--Rb:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) 
--RradicalRoots(b,x)
--R
--E 2391

--S 2392 of 3320
)d op radicalSimplify
--R 
--R
--RThere is one unexposed function called radicalSimplify :
--R   [1] QuasiAlgebraicSet(Fraction(Integer),OrderedVariableList(D2),
--R            DirectProduct(D3,NonNegativeInteger),
--R            DistributedMultivariatePolynomial(D2,Fraction(Integer))) -> 
--R            QuasiAlgebraicSet(Fraction(Integer),OrderedVariableList(D2),
--R            DirectProduct(D3,NonNegativeInteger),
--R            DistributedMultivariatePolynomial(D2,Fraction(Integer)))
--R             from QuasiAlgebraicSet2(D2,D3) if D2: LIST(SYMBOL) and D3
--R            : NNI
--R
--RExamples of radicalSimplify from QuasiAlgebraicSet2
--R
--E 2392

--S 2393 of 3320 done
)d op radicalSolve
--R 
--R
--RThere are 8 exposed functions called radicalSolve :
--R   [1] (Fraction(Polynomial(D4)),Symbol) -> List(Equation(Expression(D4
--R            )))
--R             from RadicalSolvePackage(D4)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero)
--R   [2] Fraction(Polynomial(D3)) -> List(Equation(Expression(D3)))
--R             from RadicalSolvePackage(D3)
--R             if D3 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero)
--R   [3] (Equation(Fraction(Polynomial(D4))),Symbol) -> List(Equation(
--R            Expression(D4)))
--R             from RadicalSolvePackage(D4)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero)
--R   [4] Equation(Fraction(Polynomial(D3))) -> List(Equation(Expression(
--R            D3)))
--R             from RadicalSolvePackage(D3)
--R             if D3 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero)
--R   [5] (List(Fraction(Polynomial(D4))),List(Symbol)) -> List(List(
--R            Equation(Expression(D4))))
--R             from RadicalSolvePackage(D4)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero)
--R   [6] List(Fraction(Polynomial(D3))) -> List(List(Equation(Expression(
--R            D3))))
--R             from RadicalSolvePackage(D3)
--R             if D3 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero)
--R   [7] (List(Equation(Fraction(Polynomial(D4)))),List(Symbol)) -> List(
--R            List(Equation(Expression(D4))))
--R             from RadicalSolvePackage(D4)
--R             if D4 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero)
--R   [8] List(Equation(Fraction(Polynomial(D3)))) -> List(List(Equation(
--R            Expression(D3))))
--R             from RadicalSolvePackage(D3)
--R             if D3 has Join(EuclideanDomain,OrderedSet,
--R            CharacteristicZero)
--R
--RExamples of radicalSolve from RadicalSolvePackage
--R
--Rb:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) 
--Rc:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) 
--RradicalSolve([b=0,c=0])
--R
--Rb:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) 
--Rc:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) 
--RradicalSolve([b=0,c=0],[x,y])
--R
--Rb:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) 
--Rc:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) 
--RradicalSolve([b,c])
--R
--Rb:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) 
--Rc:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) 
--RradicalSolve([b,c],[x,y])
--R
--Rb:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) 
--RradicalSolve(b=0)
--R
--Rb:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) 
--RradicalSolve(b=0,x)
--R
--Rb:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) 
--RradicalSolve(b)
--R
--Rb:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) 
--RradicalSolve(b,x)
--R
--E 2393

--S 2394 of 3320
)d op radix
--R 
--R
--RThere is one exposed function called radix :
--R   [1] (Fraction(Integer),Integer) -> Any from RadixUtilities
--R
--RExamples of radix from RadixUtilities
--R
--E 2394

--S 2395 of 3320
)d op radPoly
--R 
--R
--RThere is one unexposed function called radPoly :
--R   [1] D2 -> Union(Record(radicand: Fraction(D4),deg: 
--R            NonNegativeInteger),"failed")
--R             from ChangeOfVariable(D3,D4,D2)
--R             if D3 has UFD and D4 has UPOLYC(D3) and D2 has UPOLYC(FRAC
--R            (D4))
--R
--RExamples of radPoly from ChangeOfVariable
--R
--E 2395

--S 2396 of 3320
)d op raisePolynomial
--R 
--R
--RThere is one unexposed function called raisePolynomial :
--R   [1] SparseUnivariatePolynomial(D5) -> SparseUnivariatePolynomial(D6)
--R             from FactoringUtilities(D3,D4,D5,D6)
--R             if D5 has RING and D3 has OAMONS and D4 has ORDSET and D6
--R             has POLYCAT(D5,D3,D4)
--R
--RExamples of raisePolynomial from FactoringUtilities
--R
--E 2396

--S 2397 of 3320
)d op ramified?
--R 
--R
--RThere are 2 exposed functions called ramified? :
--R   [1] D2 -> Boolean from D
--R             if D has FFCAT(D3,D2,D4) and D3 has UFD and D2 has UPOLYC(
--R            D3) and D4 has UPOLYC(FRAC(D2))
--R   [2] D2 -> Boolean from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of ramified? from FunctionFieldCategory
--R
--E 2397

--S 2398 of 3320
)d op ramifiedAtInfinity?
--R 
--R
--RThere is one exposed function called ramifiedAtInfinity? :
--R   [1]  -> Boolean from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of ramifiedAtInfinity? from FunctionFieldCategory
--R
--E 2398

--S 2399 of 3320
)d op ramifMult
--R 
--R
--RThere is one exposed function called ramifMult :
--R   [1] D -> Integer from D if D has BLMETCT
--R
--RExamples of ramifMult from BlowUpMethodCategory
--R
--E 2399

--S 2400 of 3320
)d op ran
--R 
--R
--RThere is one unexposed function called ran :
--R   [1] Integer -> D1 from FactoringUtilities(D3,D4,D1,D5)
--R             if D3 has OAMONS and D4 has ORDSET and D1 has RING and D5
--R             has POLYCAT(D1,D3,D4)
--R
--RExamples of ran from FactoringUtilities
--R
--E 2400

--S 2401 of 3320
)d op randnum
--R 
--R
--RThere are 2 exposed functions called randnum :
--R   [1]  -> Integer from RandomNumberSource
--R   [2] Integer -> Integer from RandomNumberSource
--R
--RExamples of randnum from RandomNumberSource
--R
--E 2401

--S 2402 of 3320
)d op random
--R 
--R
--RThere are 8 exposed functions called random :
--R   [1]  -> D from D if D has FINITE
--R   [2] D -> D from D if D has INS
--R   [3]  -> D from D if D has INS
--R   [4] Integer -> Integer from Integer
--R   [5] NonNegativeInteger -> NonNegativeInteger from NonNegativeInteger
--R            
--R   [6] PermutationGroup(D2) -> Permutation(D2) from PermutationGroup(D2
--R            )
--R             if D2 has SETCAT
--R   [7] (PermutationGroup(D3),Integer) -> Permutation(D3)
--R             from PermutationGroup(D3) if D3 has SETCAT
--R   [8]  -> D from D if D has QFCAT(D1) and D1 has INS and D1 has INTDOM
--R            
--R
--RThere are 3 unexposed functions called random :
--R   [1] PositiveInteger -> SparseUnivariatePolynomial(D3)
--R             from FiniteFieldPolynomialPackage(D3) if D3 has FFIELDC
--R         
--R   [2] (PositiveInteger,PositiveInteger) -> SparseUnivariatePolynomial(
--R            D3)
--R             from FiniteFieldPolynomialPackage(D3) if D3 has FFIELDC
--R         
--R   [3] PositiveInteger -> Vector(D3) from 
--R            InnerNormalBasisFieldFunctions(D3)
--R             if D3 has FFIELDC
--R
--RExamples of random from FiniteFieldPolynomialPackage
--R
--R
--RExamples of random from Finite
--R
--R
--RExamples of random from InnerNormalBasisFieldFunctions
--R
--R
--RExamples of random from IntegerNumberSystem
--R
--R
--RExamples of random from Integer
--R
--R
--RExamples of random from NonNegativeInteger
--R
--R
--RExamples of random from PermutationGroup
--R
--R
--RExamples of random from QuotientFieldCategory
--R
--E 2402

--S 2403 of 3320
)d op randomLC
--R 
--R
--RThere is one unexposed function called randomLC :
--R   [1] (NonNegativeInteger,Vector(D1)) -> D1 from FractionalIdeal(D4,D5
--R            ,D6,D1)
--R             if D4 has EUCDOM and D5 has QFCAT(D4) and D1 has Join(
--R            FramedAlgebra(D5,D6),RetractableTo(D5)) and D6 has UPOLYC(
--R            D5)
--R
--RExamples of randomLC from FractionalIdeal
--R
--E 2403

--S 2404 of 3320
)d op randomR
--R 
--R
--RThere are 3 unexposed functions called randomR :
--R   [1]  -> D1 from GeneralPolynomialGcdPackage(D2,D3,D1,D4)
--R             if D2 has OAMONS and D3 has ORDSET and D1 has PFECAT and 
--R            D4 has POLYCAT(D1,D2,D3)
--R   [2]  -> D1 from PolynomialFactorizationByRecursion(D1,D2,D3,D4)
--R             if D2 has OAMONS and D3 has ORDSET and D1 has PFECAT and 
--R            D4 has POLYCAT(D1,D2,D3)
--R   [3]  -> D1 from PolynomialFactorizationByRecursionUnivariate(D1,D2)
--R             if D1 has PFECAT and D2 has UPOLYC(D1)
--R
--RExamples of randomR from GeneralPolynomialGcdPackage
--R
--R
--RExamples of randomR from PolynomialFactorizationByRecursion
--R
--R
--RExamples of randomR from PolynomialFactorizationByRecursionUnivariate
--R
--E 2404

--S 2405 of 3320
)d op range
--R 
--R
--RThere are 2 exposed functions called range :
--R   [1] List(Segment(Fraction(Integer))) -> DrawOption from DrawOption
--R         
--R   [2] List(Segment(Float)) -> DrawOption from DrawOption
--R
--RExamples of range from DrawOption
--R
--E 2405

--S 2406 of 3320
)d op rangeIsFinite
--R 
--R
--RThere is one exposed function called rangeIsFinite :
--R   [1] Record(var: Symbol,fn: Expression(DoubleFloat),range: Segment(
--R            OrderedCompletion(DoubleFloat)),abserr: DoubleFloat,relerr: 
--R            DoubleFloat) -> Union(finite: The range is finite,lowerInfinite: 
--R            The bottom of range is infinite,upperInfinite: 
--R            The top of range is infinite,bothInfinite: 
--R            Both top and bottom points are infinite,notEvaluated: 
--R            Range not yet evaluated)
--R             from d01AgentsPackage
--R
--RExamples of rangeIsFinite from d01AgentsPackage
--R
--E 2406

--S 2407 of 3320
)d op rangePascalTriangle
--R 
--R
--RThere are 2 unexposed functions called rangePascalTriangle :
--R   [1] NonNegativeInteger -> NonNegativeInteger from 
--R            GaloisGroupUtilities(D2)
--R             if D2 has RING
--R   [2]  -> NonNegativeInteger from GaloisGroupUtilities(D2) if D2 has 
--R            RING
--R
--RExamples of rangePascalTriangle from GaloisGroupUtilities
--R
--E 2407

--S 2408 of 3320
)d op ranges
--R 
--R
--RThere is one exposed function called ranges :
--R   [1] List(Segment(Float)) -> DrawOption from DrawOption
--R
--RThere are 3 unexposed functions called ranges :
--R   [1] (List(DrawOption),List(Segment(Float))) -> List(Segment(Float))
--R             from DrawOptionFunctions0
--R   [2] (GraphImage,List(Segment(Float))) -> List(Segment(Float)) from 
--R            GraphImage
--R   [3] GraphImage -> List(Segment(Float)) from GraphImage
--R
--RExamples of ranges from DrawOptionFunctions0
--R
--R
--RExamples of ranges from DrawOption
--R
--R
--RExamples of ranges from GraphImage
--R
--E 2408

--S 2409 of 3320
)d op rank
--R 
--R
--RThere are 8 exposed functions called rank :
--R   [1] CartesianTensor(D2,D3,D4) -> NonNegativeInteger
--R             from CartesianTensor(D2,D3,D4) if D2: INT and D3: NNI and 
--R            D4 has COMRING
--R   [2]  -> PositiveInteger from D if D has FINAALG(D2) and D2 has 
--R            COMRING
--R   [3]  -> PositiveInteger from D
--R             if D has FINRALG(D2,D3) and D2 has COMRING and D3 has 
--R            UPOLYC(D2)
--R   [4] (Matrix(D4),Vector(D4)) -> NonNegativeInteger
--R             from LinearSystemMatrixPackage1(D4) if D4 has FIELD
--R   [5] (D2,D3) -> NonNegativeInteger from LinearSystemMatrixPackage(D4,
--R            D5,D3,D2)
--R             if D4 has FIELD and D5 has FiniteLinearAggregate(D4)with
--R                 shallowlyMutableand D3 has FiniteLinearAggregate(D4)
--R            with
--R                 shallowlyMutableand D2 has MATCAT(D4,D5,D3)
--R   [6] D -> NonNegativeInteger from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2) and D2 has INTDOM
--R   [7] D2 -> NonNegativeInteger from MatrixLinearAlgebraFunctions(D3,D4
--R            ,D5,D2)
--R             if D3 has INTDOM and D3 has COMRING and D4 has FLAGG(D3) 
--R            and D5 has FLAGG(D3) and D2 has MATCAT(D3,D4,D5)
--R   [8] D -> NonNegativeInteger from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4) and D4 has 
--R            INTDOM
--R
--RThere are 2 unexposed functions called rank :
--R   [1]  -> PositiveInteger from ComplexCategory&(D2,D3)
--R             if D3 has COMRING and D2 has COMPCAT(D3)
--R   [2] D2 -> NonNegativeInteger
--R             from InnerMatrixLinearAlgebraFunctions(D3,D4,D5,D2)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D2 has MATCAT(D3,D4,D5)
--R
--RExamples of rank from CartesianTensor
--R
--RCT:=CARTEN(1,2,Integer) 
--Rt0:CT:=8 
--Rrank t0
--R
--R
--RExamples of rank from ComplexCategory&
--R
--R
--RExamples of rank from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of rank from FiniteRankAlgebra
--R
--R
--RExamples of rank from InnerMatrixLinearAlgebraFunctions
--R
--R
--RExamples of rank from LinearSystemMatrixPackage1
--R
--R
--RExamples of rank from LinearSystemMatrixPackage
--R
--R
--RExamples of rank from MatrixCategory
--R
--Rrank matrix [[1,2,3],[4,5,6],[7,8,9]]
--R
--R
--RExamples of rank from MatrixLinearAlgebraFunctions
--R
--R
--RExamples of rank from RectangularMatrixCategory
--R
--E 2409

--S 2410 of 3320
)d op rarrow
--R 
--R
--RThere is one unexposed function called rarrow :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of rarrow from OutputForm
--R
--E 2410

--S 2411 of 3320
)d op ratDenom
--R 
--R
--RThere are 4 exposed functions called ratDenom :
--R   [1] D1 -> D1 from AlgebraicManipulations(D2,D1)
--R             if D2 has INTDOM and D1 has Join(Field,ExpressionSpace)
--R            with
--R               numer : % -> SparseMultivariatePolynomial(D2,Kernel(%)
--R               )
--R               denom : % -> SparseMultivariatePolynomial(D2,Kernel(%)
--R               )
--R               coerce : SparseMultivariatePolynomial(D2,Kernel(%)) -> 
--R               %
--R   [2] (D1,D1) -> D1 from AlgebraicManipulations(D2,D1)
--R             if D2 has INTDOM and D1 has Join(Field,ExpressionSpace)
--R            with
--R               numer : % -> SparseMultivariatePolynomial(D2,Kernel(%)
--R               )
--R               denom : % -> SparseMultivariatePolynomial(D2,Kernel(%)
--R               )
--R               coerce : SparseMultivariatePolynomial(D2,Kernel(%)) -> 
--R               %
--R   [3] (D1,List(D1)) -> D1 from AlgebraicManipulations(D3,D1)
--R             if D1 has Join(Field,ExpressionSpace)with
--R               numer : % -> SparseMultivariatePolynomial(D3,Kernel(%)
--R               )
--R               denom : % -> SparseMultivariatePolynomial(D3,Kernel(%)
--R               )
--R               coerce : SparseMultivariatePolynomial(D3,Kernel(%)) -> 
--R               %and D3 has INTDOM
--R   [4] (D1,List(Kernel(D1))) -> D1 from AlgebraicManipulations(D3,D1)
--R             if D1 has Join(Field,ExpressionSpace)with
--R               numer : % -> SparseMultivariatePolynomial(D3,Kernel(%)
--R               )
--R               denom : % -> SparseMultivariatePolynomial(D3,Kernel(%)
--R               )
--R               coerce : SparseMultivariatePolynomial(D3,Kernel(%)) -> 
--R               %and D3 has INTDOM
--R
--RExamples of ratDenom from AlgebraicManipulations
--R
--E 2411

--S 2412 of 3320
)d op ratDsolve
--R 
--R
--RThere are 4 unexposed functions called ratDsolve :
--R   [1] (LinearOrdinaryDifferentialOperator1(Fraction(D5)),Fraction(D5))
--R             -> Record(particular: Union(Fraction(D5),"failed"),basis: List(
--R            Fraction(D5)))
--R             from RationalLODE(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer),RetractableTo(
--R            Fraction(Integer)))
--R   [2] (LinearOrdinaryDifferentialOperator1(Fraction(D5)),List(Fraction
--R            (D5))) -> Record(basis: List(Fraction(D5)),mat: Matrix(D4))
--R             from RationalLODE(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer),RetractableTo(
--R            Fraction(Integer)))
--R   [3] (LinearOrdinaryDifferentialOperator2(D5,Fraction(D5)),Fraction(
--R            D5)) -> Record(particular: Union(Fraction(D5),"failed"),basis: 
--R            List(Fraction(D5)))
--R             from RationalLODE(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer),RetractableTo(
--R            Fraction(Integer)))
--R   [4] (LinearOrdinaryDifferentialOperator2(D5,Fraction(D5)),List(
--R            Fraction(D5))) -> Record(basis: List(Fraction(D5)),mat: Matrix(D4
--R            ))
--R             from RationalLODE(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer),RetractableTo(
--R            Fraction(Integer)))
--R
--RExamples of ratDsolve from RationalLODE
--R
--E 2412

--S 2413 of 3320
)d op rational
--R 
--R
--RThere are 8 exposed functions called rational :
--R   [1] D -> Fraction(Integer) from D
--R             if D has COMPCAT(D2) and D2 has COMRING and D2 has INS
--R   [2] Factored(D2) -> Fraction(Integer) from Factored(D2)
--R             if D2 has INS and D2 has INTDOM
--R   [3] D -> Fraction(Integer) from D if D has INS
--R   [4] D -> Fraction(Integer) from D
--R             if D has OC(D2) and D2 has COMRING and D2 has INS
--R   [5] OnePointCompletion(D2) -> Fraction(Integer) from 
--R            OnePointCompletion(D2)
--R             if D2 has INS and D2 has SETCAT
--R   [6] OrderedCompletion(D2) -> Fraction(Integer) from 
--R            OrderedCompletion(D2)
--R             if D2 has INS and D2 has SETCAT
--R   [7] D -> Fraction(Integer) from D
--R             if D has QUATCAT(D2) and D2 has COMRING and D2 has INS
--R   [8] D2 -> Fraction(Integer) from RationalRetractions(D2)
--R             if D2 has RETRACT(FRAC(INT))
--R
--RExamples of rational from ComplexCategory
--R
--R
--RExamples of rational from Factored
--R
--R
--RExamples of rational from IntegerNumberSystem
--R
--R
--RExamples of rational from OctonionCategory
--R
--R
--RExamples of rational from OnePointCompletion
--R
--R
--RExamples of rational from OrderedCompletion
--R
--R
--RExamples of rational from QuaternionCategory
--R
--R
--RExamples of rational from RationalRetractions
--R
--E 2413

--S 2414 of 3320
)d op rational?
--R 
--R
--RThere are 12 exposed functions called rational? :
--R   [1] D -> Boolean from D if D has AFSPCAT(D2) and D2 has FIELD
--R   [2] (D,NonNegativeInteger) -> Boolean from D if D has AFSPCAT(D3) 
--R            and D3 has FIELD
--R   [3] D -> Boolean from D if D has COMPCAT(D2) and D2 has COMRING and 
--R            D2 has INS
--R   [4] Factored(D2) -> Boolean from Factored(D2) if D2 has INS and D2
--R             has INTDOM
--R   [5] D -> Boolean from D if D has INS
--R   [6] D -> Boolean from D if D has OC(D2) and D2 has COMRING and D2
--R             has INS
--R   [7] OnePointCompletion(D2) -> Boolean from OnePointCompletion(D2)
--R             if D2 has INS and D2 has SETCAT
--R   [8] OrderedCompletion(D2) -> Boolean from OrderedCompletion(D2)
--R             if D2 has INS and D2 has SETCAT
--R   [9] D -> Boolean from D if D has PRSPCAT(D2) and D2 has FIELD
--R   [10] (D,NonNegativeInteger) -> Boolean from D if D has PRSPCAT(D3) 
--R            and D3 has FIELD
--R   [11] D -> Boolean from D if D has QUATCAT(D2) and D2 has COMRING and
--R            D2 has INS
--R   [12] D2 -> Boolean from RationalRetractions(D2) if D2 has RETRACT(
--R            FRAC(INT))
--R
--RExamples of rational? from AffineSpaceCategory
--R
--R
--RExamples of rational? from ComplexCategory
--R
--R
--RExamples of rational? from Factored
--R
--R
--RExamples of rational? from IntegerNumberSystem
--R
--R
--RExamples of rational? from OctonionCategory
--R
--R
--RExamples of rational? from OnePointCompletion
--R
--R
--RExamples of rational? from OrderedCompletion
--R
--R
--RExamples of rational? from ProjectiveSpaceCategory
--R
--R
--RExamples of rational? from QuaternionCategory
--R
--R
--RExamples of rational? from RationalRetractions
--R
--E 2414

--S 2415 of 3320
)d op rationalApproximation
--R 
--R
--RThere are 4 exposed functions called rationalApproximation :
--R   [1] (DoubleFloat,NonNegativeInteger,NonNegativeInteger) -> Fraction(
--R            Integer)
--R             from DoubleFloat
--R   [2] (DoubleFloat,NonNegativeInteger) -> Fraction(Integer) from 
--R            DoubleFloat
--R   [3] (Float,NonNegativeInteger,NonNegativeInteger) -> Fraction(
--R            Integer)
--R             from Float
--R   [4] (Float,NonNegativeInteger) -> Fraction(Integer) from Float
--R
--RExamples of rationalApproximation from DoubleFloat
--R
--R
--RExamples of rationalApproximation from Float
--R
--E 2415

--S 2416 of 3320 done
)d op rationalFunction
--R 
--R
--RThere are 2 exposed functions called rationalFunction :
--R   [1] (D,Integer,Integer) -> Fraction(Polynomial(D3)) from D
--R             if D has ULSCAT(D3) and D3 has RING and D3 has INTDOM
--R   [2] (D,Integer) -> Fraction(Polynomial(D3)) from D
--R             if D has ULSCAT(D3) and D3 has RING and D3 has INTDOM
--R
--RExamples of rationalFunction from UnivariateLaurentSeriesCategory
--R
--Rw:SparseUnivariateLaurentSeries(Fraction(Integer),'z,0):=0 
--RrationalFunction(w,0)
--R
--E 2416

--S 2417 of 3320
)d op rationalIfCan
--R 
--R
--RThere are 8 exposed functions called rationalIfCan :
--R   [1] D -> Union(Fraction(Integer),"failed") from D
--R             if D has COMPCAT(D2) and D2 has COMRING and D2 has INS
--R   [2] Factored(D2) -> Union(Fraction(Integer),"failed") from Factored(
--R            D2)
--R             if D2 has INS and D2 has INTDOM
--R   [3] D -> Union(Fraction(Integer),"failed") from D if D has INS
--R   [4] D -> Union(Fraction(Integer),"failed") from D
--R             if D has OC(D2) and D2 has COMRING and D2 has INS
--R   [5] OnePointCompletion(D2) -> Union(Fraction(Integer),"failed")
--R             from OnePointCompletion(D2) if D2 has INS and D2 has 
--R            SETCAT
--R   [6] OrderedCompletion(D2) -> Union(Fraction(Integer),"failed")
--R             from OrderedCompletion(D2) if D2 has INS and D2 has SETCAT
--R            
--R   [7] D -> Union(Fraction(Integer),"failed") from D
--R             if D has QUATCAT(D2) and D2 has COMRING and D2 has INS
--R   [8] D2 -> Union(Fraction(Integer),"failed") from RationalRetractions
--R            (D2)
--R             if D2 has RETRACT(FRAC(INT))
--R
--RExamples of rationalIfCan from ComplexCategory
--R
--R
--RExamples of rationalIfCan from Factored
--R
--R
--RExamples of rationalIfCan from IntegerNumberSystem
--R
--R
--RExamples of rationalIfCan from OctonionCategory
--R
--R
--RExamples of rationalIfCan from OnePointCompletion
--R
--R
--RExamples of rationalIfCan from OrderedCompletion
--R
--R
--RExamples of rationalIfCan from QuaternionCategory
--R
--R
--RExamples of rationalIfCan from RationalRetractions
--R
--E 2417

--S 2418 of 3320
)d op rationalPlaces
--R 
--R
--RThere are 3 exposed functions called rationalPlaces :
--R   [1]  -> List(D12)
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R             if D6 has FINITE and D6 has FIELD and D7: LIST(SYMBOL) and
--R            D8 has POLYCAT(D6,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI
--R            ) and D10 has PRSPCAT(D6) and D11 has LOCPOWC(D6) and D12
--R             has PLACESC(D6,D11) and D1 has DIVCAT(D12) and D2 has 
--R            INFCLCT(D6,D7,D8,D9,D10,D11,D12,D1,D4) and D4 has BLMETCT 
--R            and D3 has DSTRCAT(D2)
--R   [2]  -> List(PlacesOverPseudoAlgebraicClosureOfFiniteField(D2))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [3]  -> List(Places(D2)) from PackageForAlgebraicFunctionField(D2,D3
--R            ,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R
--RExamples of rationalPlaces from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of rationalPlaces from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of rationalPlaces from PackageForAlgebraicFunctionField
--R
--E 2418

--S 2419 of 3320 done
)d op rationalPoint?
--R 
--R
--RThere is one exposed function called rationalPoint? :
--R   [1] (D2,D2) -> Boolean from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RThere is one unexposed function called rationalPoint? :
--R   [1] (D2,D2) -> Boolean from FunctionFieldCategory&(D3,D2,D4,D5)
--R             if D2 has UFD and D4 has UPOLYC(D2) and D5 has UPOLYC(FRAC
--R            (D4)) and D3 has FFCAT(D2,D4,D5)
--R
--RExamples of rationalPoint? from FunctionFieldCategory&
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RrationalPoint?(0,0)$R 
--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
--RrationalPoint?(0,0)$R2
--R
--R
--RExamples of rationalPoint? from FunctionFieldCategory
--R
--RP0 := UnivariatePolynomial(x, Integer) 
--RP1 := UnivariatePolynomial(y, Fraction P0) 
--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
--RrationalPoint?(0,0)$R 
--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
--RrationalPoint?(0,0)$R2
--R
--E 2419

--S 2420 of 3320
)d op rationalPoints
--R 
--R
--RThere are 5 exposed functions called rationalPoints :
--R   [1]  -> List(List(D2)) from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3)) and D2 has FINITE
--R   [2]  -> List(D10)
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R             if D6 has FINITE and D6 has FIELD and D7: LIST(SYMBOL) and
--R            D8 has POLYCAT(D6,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI
--R            ) and D10 has PRSPCAT(D6) and D11 has LOCPOWC(D6) and D12
--R             has PLACESC(D6,D11) and D1 has DIVCAT(D12) and D2 has 
--R            INFCLCT(D6,D7,D8,D9,D10,D11,D12,D1,D4) and D4 has BLMETCT 
--R            and D3 has DSTRCAT(D2)
--R   [3]  -> List(ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField(
--R            D2))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [4]  -> List(ProjectivePlane(D2))
--R             from PackageForAlgebraicFunctionField(D2,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R   [5] (D2,PositiveInteger) -> List(D7)
--R             from ProjectiveAlgebraicSetPackage(D4,D5,D2,D6,D7)
--R             if D4 has FIELD and D5: LIST(SYMBOL) and D6 has DIRPCAT(#(
--R            D5),NNI) and D2 has POLYCAT(D4,D6,OVAR(D5)) and D7 has 
--R            PRSPCAT(D4)
--R
--RThere is one unexposed function called rationalPoints :
--R   [1]  -> List(List(D3)) from FunctionFieldCategory&(D2,D3,D4,D5)
--R             if D3 has UFD and D4 has UPOLYC(D3) and D5 has UPOLYC(FRAC
--R            (D4)) and D2 has FFCAT(D3,D4,D5)
--R
--RExamples of rationalPoints from FunctionFieldCategory&
--R
--R
--RExamples of rationalPoints from FunctionFieldCategory
--R
--R
--RExamples of rationalPoints from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of rationalPoints from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of rationalPoints from PackageForAlgebraicFunctionField
--R
--R
--RExamples of rationalPoints from ProjectiveAlgebraicSetPackage
--R
--E 2420

--S 2421 of 3320
)d op rationalPower
--R 
--R
--RThere is one exposed function called rationalPower :
--R   [1] D -> Fraction(Integer) from D
--R             if D has UPXSCCA(D2,D3) and D2 has RING and D3 has ULSCAT(
--R            D2)
--R
--RExamples of rationalPower from UnivariatePuiseuxSeriesConstructorCategory
--R
--E 2421

--S 2422 of 3320
)d op ratpart
--R 
--R
--RThere is one unexposed function called ratpart :
--R   [1] IntegrationResult(D1) -> D1 from IntegrationResult(D1) if D1
--R             has FIELD
--R
--RExamples of ratpart from IntegrationResult
--R
--E 2422

--S 2423 of 3320
)d op ratPoly
--R 
--R
--RThere is one exposed function called ratPoly :
--R   [1] D2 -> SparseUnivariatePolynomial(D2) from AlgebraicManipulations
--R            (D3,D2)
--R             if D3 has INTDOM and D2 has Join(Field,ExpressionSpace)
--R            with
--R               numer : % -> SparseMultivariatePolynomial(D3,Kernel(%)
--R               )
--R               denom : % -> SparseMultivariatePolynomial(D3,Kernel(%)
--R               )
--R               coerce : SparseMultivariatePolynomial(D3,Kernel(%)) -> 
--R               %
--R
--RExamples of ratPoly from AlgebraicManipulations
--R
--E 2423

--S 2424 of 3320 done
)d op ravel
--R 
--R
--RThere is one exposed function called ravel :
--R   [1] CartesianTensor(D2,D3,D4) -> List(D4) from CartesianTensor(D2,D3
--R            ,D4)
--R             if D2: INT and D3: NNI and D4 has COMRING
--R
--RExamples of ravel from CartesianTensor
--R
--Rn:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] 
--Rtn:CartesianTensor(1,2,Integer):=n 
--Rravel tn
--R
--E 2424

--S 2425 of 3320
)d op rCoord
--R 
--R
--RThere is one unexposed function called rCoord :
--R   [1] Point(D1) -> D1 from PointPackage(D1) if D1 has RING
--R
--RExamples of rCoord from PointPackage
--R
--E 2425

--S 2426 of 3320
)d op rdHack1
--R 
--R
--RThere is one unexposed function called rdHack1 :
--R   [1] (Vector(D5),Vector(Integer),Integer) -> (() -> D5)
--R             from RandomDistributions(D5) if D5 has SETCAT
--R
--RExamples of rdHack1 from RandomDistributions
--R
--E 2426

--S 2427 of 3320
)d op rdregime
--R 
--R
--RThere is one unexposed function called rdregime :
--R   [1] String -> List(Record(eqzro: List(D6),neqzro: List(D6),wcond: 
--R            List(Polynomial(D3)),bsoln: Record(partsol: Vector(Fraction(
--R            Polynomial(D3))),basis: List(Vector(Fraction(Polynomial(D3)))))))
--R             from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D4
--R             has Join(OrderedSet,ConvertibleTo(Symbol)) and D5 has 
--R            OAMONS and D6 has POLYCAT(D3,D5,D4)
--R
--RExamples of rdregime from ParametricLinearEquations
--R
--E 2427

--S 2428 of 3320
)d op read!
--R 
--R
--RThere is one exposed function called read! :
--R   [1] D -> D1 from D if D has FILECAT(D2,D1) and D2 has SETCAT and D1
--R             has SETCAT
--R
--RExamples of read! from FileCategory
--R
--E 2428

--S 2429 of 3320
)d op readable?
--R 
--R
--RThere is one exposed function called readable? :
--R   [1] D -> Boolean from D if D has FNCAT
--R
--RExamples of readable? from FileNameCategory
--R
--E 2429

--S 2430 of 3320
)d op readIfCan!
--R 
--R
--RThere are 3 exposed functions called readIfCan! :
--R   [1] BinaryFile -> Union(SingleInteger,"failed") from BinaryFile
--R   [2] File(D1) -> Union(D1,"failed") from File(D1) if D1 has SETCAT
--R         
--R   [3] TextFile -> Union(String,"failed") from TextFile
--R
--RExamples of readIfCan! from BinaryFile
--R
--R
--RExamples of readIfCan! from File
--R
--R
--RExamples of readIfCan! from TextFile
--R
--E 2430

--S 2431 of 3320
)d op readLine!
--R 
--R
--RThere is one exposed function called readLine! :
--R   [1] TextFile -> String from TextFile
--R
--RExamples of readLine! from TextFile
--R
--E 2431

--S 2432 of 3320
)d op readLineIfCan!
--R 
--R
--RThere is one exposed function called readLineIfCan! :
--R   [1] TextFile -> Union(String,"failed") from TextFile
--R
--RExamples of readLineIfCan! from TextFile
--R
--E 2432

--S 2433 of 3320
)d op real
--R 
--R
--RThere are 5 exposed functions called real :
--R   [1] D -> D1 from D if D has COMPCAT(D1) and D1 has COMRING
--R   [2] D2 -> Expression(D3) from ComplexTrigonometricManipulations(D3,
--R            D2)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer)) and D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(Complex(D3)))
--R            
--R   [3] D -> D1 from D if D has OC(D1) and D1 has COMRING
--R   [4] D -> D1 from D if D has QUATCAT(D1) and D1 has COMRING
--R   [5] D1 -> D1 from TrigonometricManipulations(D2,D1)
--R             if D2 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D1 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D2))
--R
--RExamples of real from ComplexCategory
--R
--R
--RExamples of real from ComplexTrigonometricManipulations
--R
--R
--RExamples of real from OctonionCategory
--R
--R
--RExamples of real from QuaternionCategory
--R
--R
--RExamples of real from TrigonometricManipulations
--R
--E 2433

--S 2434 of 3320
)d op real?
--R 
--R
--RThere are 3 exposed functions called real? :
--R   [1] D2 -> Boolean from ComplexTrigonometricManipulations(D3,D2)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer)) and D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(Complex(D3)))
--R            
--R   [2] FortranScalarType -> Boolean from FortranScalarType
--R   [3] D2 -> Boolean from TrigonometricManipulations(D3,D2)
--R             if D3 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R
--RExamples of real? from ComplexTrigonometricManipulations
--R
--R
--RExamples of real? from FortranScalarType
--R
--R
--RExamples of real? from TrigonometricManipulations
--R
--E 2434

--S 2435 of 3320
)d op realEigenvalues
--R 
--R
--RThere is one exposed function called realEigenvalues :
--R   [1] (Matrix(Fraction(Integer)),D3) -> List(D3)
--R             from NumericRealEigenPackage(D3) if D3 has Join(Field,
--R            OrderedRing)
--R
--RExamples of realEigenvalues from NumericRealEigenPackage
--R
--E 2435

--S 2436 of 3320
)d op realEigenvectors
--R 
--R
--RThere is one exposed function called realEigenvectors :
--R   [1] (Matrix(Fraction(Integer)),D3) -> List(Record(outval: D3,outmult
--R            : Integer,outvect: List(Matrix(D3))))
--R             from NumericRealEigenPackage(D3) if D3 has Join(Field,
--R            OrderedRing)
--R
--RExamples of realEigenvectors from NumericRealEigenPackage
--R
--E 2436

--S 2437 of 3320
)d op realElementary
--R 
--R
--RThere are 2 exposed functions called realElementary :
--R   [1] D1 -> D1 from ElementaryFunctionStructurePackage(D2,D1)
--R             if D2 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer)) and D1 has Join
--R            (AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D2))
--R   [2] (D1,Symbol) -> D1 from ElementaryFunctionStructurePackage(D3,D1)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer)) and D1 has Join
--R            (AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R
--RExamples of realElementary from ElementaryFunctionStructurePackage
--R
--E 2437

--S 2438 of 3320
)d op realRoots
--R 
--R
--RThere are 2 exposed functions called realRoots :
--R   [1] (List(Fraction(Polynomial(Integer))),List(Symbol),D4) -> List(
--R            List(D4))
--R             from FloatingRealPackage(D4) if D4 has Join(OrderedRing,
--R            Field)
--R   [2] (Fraction(Polynomial(Integer)),D3) -> List(D3)
--R             from FloatingRealPackage(D3) if D3 has Join(OrderedRing,
--R            Field)
--R
--RExamples of realRoots from FloatingRealPackage
--R
--E 2438

--S 2439 of 3320
)d op realSolve
--R 
--R
--RThere are 5 exposed functions called realSolve :
--R   [1] RegularChain(D3,D4) -> List(List(RealClosure(Fraction(D3))))
--R             from ZeroDimensionalSolvePackage(D3,D4,D5)
--R             if D3 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D4: LIST(SYMBOL) and 
--R            D5: LIST(SYMBOL)
--R   [2] (List(Polynomial(D4)),Boolean,Boolean,Boolean) -> List(List(
--R            RealClosure(Fraction(D4))))
--R             from ZeroDimensionalSolvePackage(D4,D5,D6)
--R             if D4 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D5: LIST(SYMBOL) and 
--R            D6: LIST(SYMBOL)
--R   [3] (List(Polynomial(D4)),Boolean,Boolean) -> List(List(RealClosure(
--R            Fraction(D4))))
--R             from ZeroDimensionalSolvePackage(D4,D5,D6)
--R             if D4 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D5: LIST(SYMBOL) and 
--R            D6: LIST(SYMBOL)
--R   [4] (List(Polynomial(D4)),Boolean) -> List(List(RealClosure(Fraction
--R            (D4))))
--R             from ZeroDimensionalSolvePackage(D4,D5,D6)
--R             if D4 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D5: LIST(SYMBOL) and 
--R            D6: LIST(SYMBOL)
--R   [5] List(Polynomial(D3)) -> List(List(RealClosure(Fraction(D3))))
--R             from ZeroDimensionalSolvePackage(D3,D4,D5)
--R             if D3 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D4: LIST(SYMBOL) and 
--R            D5: LIST(SYMBOL)
--R
--RThere is one unexposed function called realSolve :
--R   [1] (List(Polynomial(Integer)),List(Symbol),Float) -> List(List(
--R            Float))
--R             from RealSolvePackage
--R
--RExamples of realSolve from RealSolvePackage
--R
--Rp1 := x**2*y*z + y*z 
--Rp2 := x**2*y**2*z + x + z 
--Rp3 := x**2*y**2*z**2 + z + 1 
--Rlp := [p1, p2, p3] 
--RrealSolve(lp,[x,y,z],0.01)
--R
--R
--RExamples of realSolve from ZeroDimensionalSolvePackage
--R
--E 2439

--S 2440 of 3320
)d op realZeros
--R 
--R
--RThere are 8 exposed functions called realZeros :
--R   [1] D2 -> List(Record(left: Fraction(Integer),right: Fraction(
--R            Integer)))
--R             from RealZeroPackage(D2) if D2 has UPOLYC(INT)
--R   [2] (D2,Record(left: Fraction(Integer),right: Fraction(Integer)))
--R             -> List(Record(left: Fraction(Integer),right: Fraction(Integer))
--R            )
--R             from RealZeroPackage(D2) if D2 has UPOLYC(INT)
--R   [3] (D2,Fraction(Integer)) -> List(Record(left: Fraction(Integer),
--R            right: Fraction(Integer)))
--R             from RealZeroPackage(D2) if D2 has UPOLYC(INT)
--R   [4] (D2,Record(left: Fraction(Integer),right: Fraction(Integer)),
--R            Fraction(Integer)) -> List(Record(left: Fraction(Integer),right: 
--R            Fraction(Integer)))
--R             from RealZeroPackage(D2) if D2 has UPOLYC(INT)
--R   [5] D2 -> List(Record(left: Fraction(Integer),right: Fraction(
--R            Integer)))
--R             from RealZeroPackageQ(D2) if D2 has UPOLYC(FRAC(INT))
--R   [6] (D2,Record(left: Fraction(Integer),right: Fraction(Integer)))
--R             -> List(Record(left: Fraction(Integer),right: Fraction(Integer))
--R            )
--R             from RealZeroPackageQ(D2) if D2 has UPOLYC(FRAC(INT))
--R   [7] (D2,Fraction(Integer)) -> List(Record(left: Fraction(Integer),
--R            right: Fraction(Integer)))
--R             from RealZeroPackageQ(D2) if D2 has UPOLYC(FRAC(INT))
--R   [8] (D2,Record(left: Fraction(Integer),right: Fraction(Integer)),
--R            Fraction(Integer)) -> List(Record(left: Fraction(Integer),right: 
--R            Fraction(Integer)))
--R             from RealZeroPackageQ(D2) if D2 has UPOLYC(FRAC(INT))
--R
--RExamples of realZeros from RealZeroPackage
--R
--R
--RExamples of realZeros from RealZeroPackageQ
--R
--E 2440

--S 2441 of 3320
)d op recip
--R 
--R
--RThere are 6 exposed functions called recip :
--R   [1] CliffordAlgebra(D1,D2,D3) -> Union(CliffordAlgebra(D1,D2,D3),
--R            "failed")
--R             from CliffordAlgebra(D1,D2,D3)
--R             if D1: PI and D2 has FIELD and D3: QFORM(D1,D2)
--R   [2] D -> Union(D,"failed") from D
--R             if D has FINAALG(D1) and D1 has COMRING and D1 has INTDOM
--R            
--R   [3] D -> Union(D,"failed") from D if D has MONADWU
--R   [4] D -> Union(D,"failed") from D if D has MONOID
--R   [5] (D2,D3) -> Record(num: D2,den: D2)
--R             from NormalizationPackage(D4,D5,D6,D2,D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R   [6] (D1,D) -> Union(D1,"failed") from D
--R             if D has RRCC(D2,D1) and D2 has Join(OrderedRing,Field) 
--R            and D1 has UPOLYC(D2)
--R
--RThere are 5 unexposed functions called recip :
--R   [1] EuclideanModularRing(D1,D2,D3,D4,D5,D6) -> Union(
--R            EuclideanModularRing(D1,D2,D3,D4,D5,D6),"failed")
--R             from EuclideanModularRing(D1,D2,D3,D4,D5,D6)
--R             if D1 has COMRING and D2 has UPOLYC(D1) and D3 has ABELMON
--R            and D4: ((D2,D3) -> D2) and D5: ((D3,D3) -> Union(D3,
--R            "failed")) and D6: ((D2,D2,D3) -> Union(D2,"failed"))
--R   [2] ModularRing(D1,D2,D3,D4,D5) -> Union(ModularRing(D1,D2,D3,D4,D5)
--R            ,"failed")
--R             from ModularRing(D1,D2,D3,D4,D5)
--R             if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> 
--R            D1) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1
--R            ,D2) -> Union(D1,"failed"))
--R   [3] MoebiusTransform(D1) -> MoebiusTransform(D1) from 
--R            MoebiusTransform(D1)
--R             if D1 has FIELD
--R   [4]  -> MoebiusTransform(D1) from MoebiusTransform(D1) if D1 has 
--R            FIELD
--R   [5] Stream(D2) -> Union(Stream(D2),"failed")
--R             from StreamTaylorSeriesOperations(D2) if D2 has RING
--R
--RExamples of recip from CliffordAlgebra
--R
--R
--RExamples of recip from EuclideanModularRing
--R
--R
--RExamples of recip from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of recip from ModularRing
--R
--R
--RExamples of recip from MoebiusTransform
--R
--R
--RExamples of recip from MonadWithUnit
--R
--R
--RExamples of recip from Monoid
--R
--R
--RExamples of recip from NormalizationPackage
--R
--R
--RExamples of recip from RealRootCharacterizationCategory
--R
--R
--RExamples of recip from StreamTaylorSeriesOperations
--R
--E 2441

--S 2442 of 3320
)d op reciprocalPolynomial
--R 
--R
--RThere is one unexposed function called reciprocalPolynomial :
--R   [1] D1 -> D1 from ComplexRootFindingPackage(D2,D1)
--R             if D2 has Join(Field,OrderedRing) and D1 has UPOLYC(
--R            COMPLEX(D2))
--R
--RExamples of reciprocalPolynomial from ComplexRootFindingPackage
--R
--E 2442

--S 2443 of 3320
)d op recolor
--R 
--R
--RThere is one exposed function called recolor :
--R   [1] (((DoubleFloat,DoubleFloat) -> Point(DoubleFloat)),((DoubleFloat
--R            ,DoubleFloat,DoubleFloat) -> DoubleFloat)) -> ((DoubleFloat,
--R            DoubleFloat) -> Point(DoubleFloat))
--R             from TopLevelDrawFunctionsForCompiledFunctions
--R
--RExamples of recolor from TopLevelDrawFunctionsForCompiledFunctions
--R
--E 2443

--S 2444 of 3320
)d op recoverAfterFail
--R 
--R
--RThere is one exposed function called recoverAfterFail :
--R   [1] (RoutinesTable,String,Integer) -> Union(String,"failed")
--R             from RoutinesTable
--R
--RExamples of recoverAfterFail from RoutinesTable
--R
--E 2444

--S 2445 of 3320
)d op rectangularMatrix
--R 
--R
--RThere is one unexposed function called rectangularMatrix :
--R   [1] Matrix(D4) -> RectangularMatrix(D2,D3,D4)
--R             from RectangularMatrix(D2,D3,D4) if D4 has RING and D2: 
--R            NNI and D3: NNI
--R
--RExamples of rectangularMatrix from RectangularMatrix
--R
--E 2445

--S 2446 of 3320
)d op recur
--R 
--R
--RThere is one exposed function called recur :
--R   [1] ((NonNegativeInteger,D2) -> D2) -> ((NonNegativeInteger,D2) -> 
--R            D2)
--R             from MappingPackage1(D2) if D2 has SETCAT
--R
--RThere is one unexposed function called recur :
--R   [1] (((NonNegativeInteger,D1) -> D1),NonNegativeInteger,D1) -> D1
--R             from MappingPackageInternalHacks1(D1) if D1 has SETCAT
--R
--RExamples of recur from MappingPackageInternalHacks1
--R
--R
--RExamples of recur from MappingPackage1
--R
--E 2446

--S 2447 of 3320
)d op red
--R 
--R
--RThere is one exposed function called red :
--R   [1]  -> Color from Color
--R
--RExamples of red from Color
--R
--E 2447

--S 2448 of 3320
)d op redmat
--R 
--R
--RThere is one unexposed function called redmat :
--R   [1] (Matrix(D6),List(D6)) -> Matrix(D6)
--R             from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D5,D4) and D3 has Join(
--R            EuclideanDomain,CharacteristicZero) and D4 has Join(
--R            OrderedSet,ConvertibleTo(Symbol)) and D5 has OAMONS
--R
--RExamples of redmat from ParametricLinearEquations
--R
--E 2448

--S 2449 of 3320
)d op redPo
--R 
--R
--RThere is one unexposed function called redPo :
--R   [1] (D2,List(D2)) -> Record(poly: D2,mult: D4)
--R             from GroebnerInternalPackage(D4,D5,D6,D2)
--R             if D2 has POLYCAT(D4,D5,D6) and D4 has GCDDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R
--RExamples of redPo from GroebnerInternalPackage
--R
--E 2449

--S 2450 of 3320
)d op redPol
--R 
--R
--RThere is one unexposed function called redPol :
--R   [1] (D1,List(D1)) -> D1 from GroebnerInternalPackage(D3,D4,D5,D1)
--R             if D1 has POLYCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R
--RExamples of redPol from GroebnerInternalPackage
--R
--E 2450

--S 2451 of 3320
)d op redpps
--R 
--R
--RThere is one unexposed function called redpps :
--R   [1] (Record(partsol: Vector(Fraction(Polynomial(D3))),basis: List(
--R            Vector(Fraction(Polynomial(D3))))),List(D6)) -> Record(partsol: 
--R            Vector(Fraction(Polynomial(D3))),basis: List(Vector(Fraction(
--R            Polynomial(D3)))))
--R             from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D6
--R             has POLYCAT(D3,D5,D4) and D4 has Join(OrderedSet,
--R            ConvertibleTo(Symbol)) and D5 has OAMONS
--R
--RExamples of redpps from ParametricLinearEquations
--R
--E 2451

--S 2452 of 3320
)d op reduce
--R 
--R
--RThere are 21 exposed functions called reduce :
--R   [1] AlgebraicNumber -> AlgebraicNumber from AlgebraicNumber
--R   [2] (((D4,D1) -> D1),OneDimensionalArray(D4),D1) -> D1
--R             from OneDimensionalArrayFunctions2(D4,D1) if D4 has TYPE 
--R            and D1 has TYPE
--R   [3] (((D1,D1) -> D1),D,D1,D1) -> D1 from D
--R             if D1 has SETCAT and D has finiteAggregate and D has CLAGG
--R            (D1) and D1 has TYPE
--R   [4] (((D1,D1) -> D1),D,D1) -> D1 from D
--R             if D has finiteAggregate and D has CLAGG(D1) and D1 has 
--R            TYPE
--R   [5] (((D1,D1) -> D1),D) -> D1 from D
--R             if D has finiteAggregate and D has CLAGG(D1) and D1 has 
--R            TYPE
--R   [6] (((D5,D1) -> D1),DirectProduct(D4,D5),D1) -> D1
--R             from DirectProductFunctions2(D4,D5,D1)
--R             if D4: NNI and D5 has TYPE and D1 has TYPE
--R   [7] Expression(D1) -> Expression(D1) from Expression(D1)
--R             if D1 has INTDOM and D1 has ORDSET
--R   [8] D -> D from D
--R             if D has FDIVCAT(D1,D2,D3,D4) and D1 has FIELD and D2 has 
--R            UPOLYC(D1) and D3 has UPOLYC(FRAC(D2)) and D4 has FFCAT(D1,
--R            D2,D3)
--R   [9] (((D4,D1) -> D1),D3,D1) -> D1
--R             from FiniteLinearAggregateFunctions2(D4,D3,D1,D5)
--R             if D4 has TYPE and D1 has TYPE and D3 has FLAGG(D4) and D5
--R             has FLAGG(D1)
--R   [10] (((D4,D1) -> D1),D3,D1) -> D1
--R             from FiniteSetAggregateFunctions2(D4,D3,D1,D5)
--R             if D4 has SETCAT and D1 has SETCAT and D3 has FSAGG(D4) 
--R            and D5 has FSAGG(D1)
--R   [11] (((D4,D1) -> D1),List(D4),D1) -> D1 from ListFunctions2(D4,D1)
--R             if D4 has TYPE and D1 has TYPE
--R   [12] (((D5,D2) -> D2),D4,D2) -> D2
--R             from MatrixCategoryFunctions2(D5,D6,D7,D4,D2,D8,D9,D1)
--R             if D5 has RING and D2 has RING and D6 has FLAGG(D5) and D7
--R             has FLAGG(D5) and D8 has FLAGG(D2) and D9 has FLAGG(D2) 
--R            and D4 has MATCAT(D5,D6,D7) and D1 has MATCAT(D2,D8,D9)
--R   [13] Fraction(D3) -> Union(D,"failed") from D
--R             if D3 has UPOLYC(D2) and D2 has FIELD and D2 has COMRING 
--R            and D has MONOGEN(D2,D3)
--R   [14] D1 -> D from D
--R             if D2 has COMRING and D has MONOGEN(D2,D1) and D1 has 
--R            UPOLYC(D2)
--R   [15] SparseUnivariatePolynomial(D) -> D from D if D has PACPERC
--R   [16] List(D) -> Divisor(D) from D
--R             if D has PLACESC(D3,D4) and D3 has FIELD and D4 has 
--R            LOCPOWC(D3)
--R   [17] (((D4,D1) -> D1),PrimitiveArray(D4),D1) -> D1
--R             from PrimitiveArrayFunctions2(D4,D1) if D4 has TYPE and D1
--R             has TYPE
--R   [18] (((D9,D4) -> D4),D6,D4) -> D4
--R             from RectangularMatrixCategoryFunctions2(D7,D8,D9,D10,D11,
--R            D6,D4,D1,D2,D3)
--R             if D9 has RING and D4 has RING and D7: NNI and D8: NNI and
--R            D10 has DIRPCAT(D8,D9) and D11 has DIRPCAT(D7,D9) and D1
--R             has DIRPCAT(D8,D4) and D2 has DIRPCAT(D7,D4) and D6 has 
--R            RMATCAT(D7,D8,D9,D10,D11) and D3 has RMATCAT(D7,D8,D4,D1,D2
--R            )
--R   [19] (D1,((D4,D1) -> D1),Stream(D4)) -> D1 from StreamFunctions2(D4,
--R            D1)
--R             if D4 has TYPE and D1 has TYPE
--R   [20] (D1,D,((D1,D1) -> D1),((D1,D1) -> Boolean)) -> D1 from D
--R             if D has TSETCAT(D4,D5,D6,D1) and D4 has INTDOM and D5
--R             has OAMONS and D6 has ORDSET and D1 has RPOLCAT(D4,D5,D6)
--R            
--R   [21] (((D4,D1) -> D1),Vector(D4),D1) -> D1 from VectorFunctions2(D4,
--R            D1)
--R             if D4 has TYPE and D1 has TYPE
--R
--RThere are 7 unexposed functions called reduce :
--R   [1] SparseUnivariatePolynomial(D3) -> Record(pol: 
--R            SparseUnivariatePolynomial(D3),deg: PositiveInteger)
--R             from DegreeReductionPackage(D3,D4)
--R             if D3 has RING and D4 has Join(IntegralDomain,OrderedSet)
--R            
--R   [2] (D1,D2) -> EuclideanModularRing(D3,D1,D2,D4,D5,D6)
--R             from EuclideanModularRing(D3,D1,D2,D4,D5,D6)
--R             if D3 has COMRING and D1 has UPOLYC(D3) and D2 has ABELMON
--R            and D4: ((D1,D2) -> D1) and D5: ((D2,D2) -> Union(D2,
--R            "failed")) and D6: ((D1,D1,D2) -> Union(D1,"failed"))
--R   [3] InnerAlgebraicNumber -> InnerAlgebraicNumber from 
--R            InnerAlgebraicNumber
--R   [4] (D1,D2) -> ModularField(D1,D2,D3,D4,D5) from ModularField(D1,D2,
--R            D3,D4,D5)
--R             if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> 
--R            D1) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1
--R            ,D2) -> Union(D1,"failed"))
--R   [5] D1 -> ModMonic(D2,D1) from ModMonic(D2,D1)
--R             if D2 has RING and D1 has UPOLYC(D2)
--R   [6] (D1,D2) -> ModularRing(D1,D2,D3,D4,D5) from ModularRing(D1,D2,D3
--R            ,D4,D5)
--R             if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> 
--R            D1) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1
--R            ,D2) -> Union(D1,"failed"))
--R   [7] D1 -> ResidueRing(D2,D3,D4,D1,D5) from ResidueRing(D2,D3,D4,D1,
--R            D5)
--R             if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D1
--R             has POLYCAT(D2,D3,D4) and D5: LIST(D1)
--R
--RExamples of reduce from AlgebraicNumber
--R
--R
--RExamples of reduce from OneDimensionalArrayFunctions2
--R
--RT1:=OneDimensionalArrayFunctions2(Integer,Integer) 
--Radder(a:Integer,b:Integer):Integer == a+b 
--Rreduce(adder,[i for i in 1..10],0)$T1
--R
--R
--RExamples of reduce from Collection
--R
--R)clear all 
--Rreduce(+,[C[i]*x**i for i in 1..5])
--R
--R
--RExamples of reduce from DegreeReductionPackage
--R
--R
--RExamples of reduce from DirectProductFunctions2
--R
--R
--RExamples of reduce from EuclideanModularRing
--R
--R
--RExamples of reduce from Expression
--R
--R
--RExamples of reduce from FiniteDivisorCategory
--R
--R
--RExamples of reduce from FiniteLinearAggregateFunctions2
--R
--R
--RExamples of reduce from FiniteSetAggregateFunctions2
--R
--R
--RExamples of reduce from InnerAlgebraicNumber
--R
--R
--RExamples of reduce from ListFunctions2
--R
--R
--RExamples of reduce from MatrixCategoryFunctions2
--R
--R
--RExamples of reduce from ModularField
--R
--R
--RExamples of reduce from ModMonic
--R
--R
--RExamples of reduce from ModularRing
--R
--R
--RExamples of reduce from MonogenicAlgebra
--R
--R
--RExamples of reduce from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--R
--RExamples of reduce from PlacesCategory
--R
--R
--RExamples of reduce from PrimitiveArrayFunctions2
--R
--RT1:=PrimitiveArrayFunctions2(Integer,Integer) 
--Radder(a:Integer,b:Integer):Integer == a+b 
--Rreduce(adder,[i for i in 1..10],0)$T1
--R
--R
--RExamples of reduce from ResidueRing
--R
--R
--RExamples of reduce from RectangularMatrixCategoryFunctions2
--R
--R
--RExamples of reduce from StreamFunctions2
--R
--Rm:=[i for i in 1..300]::Stream(Integer) 
--Rf(i:Integer,j:Integer):Integer==i+j 
--Rreduce(1,f,m)
--R
--R
--RExamples of reduce from TriangularSetCategory
--R
--R
--RExamples of reduce from VectorFunctions2
--R
--E 2452

--S 2453 of 3320
)d op reduceBasisAtInfinity
--R 
--R
--RThere is one exposed function called reduceBasisAtInfinity :
--R   [1] Vector(D) -> Vector(D) from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of reduceBasisAtInfinity from FunctionFieldCategory
--R
--E 2453

--S 2454 of 3320
)d op reduceByQuasiMonic
--R 
--R
--RThere is one exposed function called reduceByQuasiMonic :
--R   [1] (D1,D) -> D1 from D
--R             if D has TSETCAT(D2,D3,D4,D1) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D1 has RPOLCAT(D2,D3,D4)
--R            
--R
--RExamples of reduceByQuasiMonic from TriangularSetCategory
--R
--E 2454

--S 2455 of 3320
)d op reduced?
--R 
--R
--RThere are 3 exposed functions called reduced? :
--R   [1] (D,List(D)) -> Boolean from D
--R             if D has RPOLCAT(D3,D4,D5) and D3 has RING and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [2] (D,D) -> Boolean from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [3] (D2,D,((D2,D2) -> Boolean)) -> Boolean from D
--R             if D has TSETCAT(D4,D5,D6,D2) and D4 has INTDOM and D5
--R             has OAMONS and D6 has ORDSET and D2 has RPOLCAT(D4,D5,D6)
--R            
--R
--RExamples of reduced? from RecursivePolynomialCategory
--R
--R
--RExamples of reduced? from TriangularSetCategory
--R
--E 2455

--S 2456 of 3320
)d op reducedContinuedFraction
--R 
--R
--RThere is one exposed function called reducedContinuedFraction :
--R   [1] (D1,Stream(D1)) -> ContinuedFraction(D1) from ContinuedFraction(
--R            D1)
--R             if D1 has EUCDOM
--R
--RExamples of reducedContinuedFraction from ContinuedFraction
--R
--E 2456

--S 2457 of 3320
)d op reducedDiscriminant
--R 
--R
--RThere is one unexposed function called reducedDiscriminant :
--R   [1] D2 -> D1 from PAdicWildFunctionFieldIntegralBasis(D3,D1,D2,D4)
--R             if D2 has UPOLYC(D1) and D1 has UPOLYC(D3) and D3 has 
--R            FFIELDC and D4 has MONOGEN(D1,D2)
--R
--RExamples of reducedDiscriminant from PAdicWildFunctionFieldIntegralBasis
--R
--E 2457

--S 2458 of 3320
)d op reducedForm
--R 
--R
--RThere is one exposed function called reducedForm :
--R   [1] ContinuedFraction(D1) -> ContinuedFraction(D1) from 
--R            ContinuedFraction(D1)
--R             if D1 has EUCDOM
--R
--RExamples of reducedForm from ContinuedFraction
--R
--E 2458

--S 2459 of 3320
)d op reducedQPowers
--R 
--R
--RThere is one unexposed function called reducedQPowers :
--R   [1] SparseUnivariatePolynomial(D3) -> PrimitiveArray(
--R            SparseUnivariatePolynomial(D3))
--R             from FiniteFieldPolynomialPackage(D3) if D3 has FFIELDC
--R         
--R
--RExamples of reducedQPowers from FiniteFieldPolynomialPackage
--R
--E 2459

--S 2460 of 3320
)d op reducedSystem
--R 
--R
--RThere are 2 exposed functions called reducedSystem :
--R   [1] (Matrix(D),Vector(D)) -> Record(mat: Matrix(D4),vec: Vector(D4))
--R             from D
--R             if D has LINEXP(D4) and D4 has RING
--R   [2] Matrix(D) -> Matrix(D3) from D if D has LINEXP(D3) and D3 has 
--R            RING
--R
--RExamples of reducedSystem from LinearlyExplicitRingOver
--R
--E 2460

--S 2461 of 3320
)d op reduceLineOverLine
--R 
--R
--RThere is one exposed function called reduceLineOverLine :
--R   [1] (List(D2),List(D2),D2) -> List(D2) from LinesOpPack(D2) if D2
--R             has FIELD
--R
--RExamples of reduceLineOverLine from LinesOpPack
--R
--E 2461

--S 2462 of 3320
)d op reduceLODE
--R 
--R
--RThere is one unexposed function called reduceLODE :
--R   [1] (D2,D3) -> Record(mat: Matrix(D5),vec: Vector(D4))
--R             from ReduceLODE(D4,D5,D6,D3,D2)
--R             if D4 has FIELD and D6 has UPOLYC(D4) and D3 has MONOGEN(
--R            D4,D6) and D5 has LODOCAT(D4) and D2 has LODOCAT(D3)
--R
--RExamples of reduceLODE from ReduceLODE
--R
--E 2462

--S 2463 of 3320
)d op ReduceOrder
--R 
--R
--RThere are 2 unexposed functions called ReduceOrder :
--R   [1] (D1,D2) -> D1 from ReductionOfOrder(D2,D1)
--R             if D2 has FIELD and D1 has LODOCAT(D2)
--R   [2] (D2,List(D4)) -> Record(eq: D2,op: List(D4)) from 
--R            ReductionOfOrder(D4,D2)
--R             if D4 has FIELD and D2 has LODOCAT(D4)
--R
--RExamples of ReduceOrder from ReductionOfOrder
--R
--E 2463

--S 2464 of 3320
)d op reduceRow
--R 
--R
--RThere is one exposed function called reduceRow :
--R   [1] List(List(D2)) -> List(List(D2)) from LinesOpPack(D2) if D2 has 
--R            FIELD
--R
--RExamples of reduceRow from LinesOpPack
--R
--E 2464

--S 2465 of 3320
)d op reduceRowOnList
--R 
--R
--RThere is one exposed function called reduceRowOnList :
--R   [1] (List(D3),List(List(D3))) -> List(List(D3)) from LinesOpPack(D3)
--R             if D3 has FIELD
--R
--RExamples of reduceRowOnList from LinesOpPack
--R
--E 2465

--S 2466 of 3320
)d op reduction
--R 
--R
--RThere are 3 unexposed functions called reduction :
--R   [1] (D1,D2) -> D1 from GenExEuclid(D2,D1) if D2 has EUCDOM and D1
--R             has UPOLYC(D2)
--R   [2] (D1,D2) -> D1 from GeneralHenselPackage(D2,D1)
--R             if D2 has EUCDOM and D1 has UPOLYC(D2)
--R   [3] (D1,D2) -> D1 from InnerModularGcd(D2,D1,D3,D4)
--R             if D2 has EUCDOM and D3: D2 and D4: ((D2,
--R            NonNegativeInteger) -> D2) and D1 has UPOLYC(D2)
--R
--RExamples of reduction from GenExEuclid
--R
--R
--RExamples of reduction from GeneralHenselPackage
--R
--R
--RExamples of reduction from InnerModularGcd
--R
--E 2466

--S 2467 of 3320
)d op reductum
--R 
--R
--RThere are 7 exposed functions called reductum :
--R   [1] D -> D from D if D has AMR(D1,D2) and D1 has RING and D2 has 
--R            OAMON
--R   [2] Divisor(D1) -> Divisor(D1) from Divisor(D1) if D1 has SETCATD
--R         
--R   [3] D -> D from D if D has FMCAT(D1,D2) and D1 has RING and D2 has 
--R            SETCAT
--R   [4] D -> D from D if D has IDPC(D1,D2) and D1 has SETCAT and D2 has 
--R            ORDSET
--R   [5] D -> D from D if D has MLO(D1) and D1 has RING
--R   [6] D -> D from D if D has OREPCAT(D1) and D1 has RING
--R   [7] (D,D1) -> D from D
--R             if D has RPOLCAT(D2,D3,D1) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET
--R
--RThere are 6 unexposed functions called reductum :
--R   [1] AntiSymm(D1,D2) -> AntiSymm(D1,D2) from AntiSymm(D1,D2)
--R             if D1 has RING and D2: LIST(SYMBOL)
--R   [2] DeRhamComplex(D1,D2) -> DeRhamComplex(D1,D2) from DeRhamComplex(
--R            D1,D2)
--R             if D1 has Join(Ring,OrderedSet) and D2: LIST(SYMBOL)
--R   [3] GeneralModulePolynomial(D1,D2,D3,D4,D5,D6) -> 
--R            GeneralModulePolynomial(D1,D2,D3,D4,D5,D6)
--R             from GeneralModulePolynomial(D1,D2,D3,D4,D5,D6)
--R             if D1: LIST(SYMBOL) and D2 has COMRING and D4 has DIRPCAT(
--R            #(D1),NNI) and D5: ((Record(index: D3,exponent: D4),Record(
--R            index: D3,exponent: D4)) -> Boolean) and D3 has ORDSET and 
--R            D6 has POLYCAT(D2,D4,OVAR(D1))
--R   [4] LaurentPolynomial(D1,D2) -> LaurentPolynomial(D1,D2)
--R             from LaurentPolynomial(D1,D2) if D1 has INTDOM and D2 has 
--R            UPOLYC(D1)
--R   [5] MonoidRing(D1,D2) -> MonoidRing(D1,D2) from MonoidRing(D1,D2)
--R             if D2 has ORDSET and D1 has RING and D2 has MONOID
--R   [6] XPolynomialRing(D1,D2) -> XPolynomialRing(D1,D2)
--R             from XPolynomialRing(D1,D2) if D1 has RING and D2 has 
--R            ORDMON
--R
--RExamples of reductum from AbelianMonoidRing
--R
--R
--RExamples of reductum from AntiSymm
--R
--R
--RExamples of reductum from DeRhamComplex
--R
--Rder:=DERHAM(Integer,[x,y,z]) 
--R[dx,dy,dz]:=[generator(i)$der for i in 1..3] 
--Rf:BOP:=operator('f) 
--Rg:BOP:=operator('g) 
--Rh:BOP:=operator('h) 
--Rsigma:=f(x,y,z)*dx + g(x,y,z)*dy + h(x,y,z)*dz 
--Rreductum sigma
--R
--R
--RExamples of reductum from Divisor
--R
--R
--RExamples of reductum from FreeModuleCat
--R
--R
--RExamples of reductum from GeneralModulePolynomial
--R
--R
--RExamples of reductum from IndexedDirectProductCategory
--R
--R
--RExamples of reductum from LaurentPolynomial
--R
--R
--RExamples of reductum from MonogenicLinearOperator
--R
--R
--RExamples of reductum from MonoidRing
--R
--R
--RExamples of reductum from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of reductum from RecursivePolynomialCategory
--R
--R
--RExamples of reductum from XPolynomialRing
--R
--E 2467

--S 2468 of 3320
)d op ref
--R 
--R
--RThere is one unexposed function called ref :
--R   [1] D1 -> Reference(D1) from Reference(D1) if D1 has TYPE
--R
--RExamples of ref from Reference
--R
--E 2468

--S 2469 of 3320
)d op refine
--R 
--R
--RThere are 5 exposed functions called refine :
--R   [1] (D2,Record(left: Fraction(Integer),right: Fraction(Integer)),
--R            Fraction(Integer)) -> Record(left: Fraction(Integer),right: 
--R            Fraction(Integer))
--R             from RealZeroPackage(D2) if D2 has UPOLYC(INT)
--R   [2] (D2,Record(left: Fraction(Integer),right: Fraction(Integer)),
--R            Record(left: Fraction(Integer),right: Fraction(Integer))) -> 
--R            Union(Record(left: Fraction(Integer),right: Fraction(Integer)),
--R            "failed")
--R             from RealZeroPackage(D2) if D2 has UPOLYC(INT)
--R   [3] (D2,Record(left: Fraction(Integer),right: Fraction(Integer)),
--R            Fraction(Integer)) -> Record(left: Fraction(Integer),right: 
--R            Fraction(Integer))
--R             from RealZeroPackageQ(D2) if D2 has UPOLYC(FRAC(INT))
--R   [4] (D2,Record(left: Fraction(Integer),right: Fraction(Integer)),
--R            Record(left: Fraction(Integer),right: Fraction(Integer))) -> 
--R            Union(Record(left: Fraction(Integer),right: Fraction(Integer)),
--R            "failed")
--R             from RealZeroPackageQ(D2) if D2 has UPOLYC(FRAC(INT))
--R   [5] RightOpenIntervalRootCharacterization(D1,D2) -> 
--R            RightOpenIntervalRootCharacterization(D1,D2)
--R             from RightOpenIntervalRootCharacterization(D1,D2)
--R             if D1 has Join(OrderedRing,Field) and D2 has UPOLYC(D1)
--R         
--R
--RThere are 6 unexposed functions called refine :
--R   [1] (PlaneAlgebraicCurvePlot,DoubleFloat) -> PlaneAlgebraicCurvePlot
--R             from PlaneAlgebraicCurvePlot
--R   [2] (Factored(D3),(D3 -> Factored(D3))) -> Factored(D3)
--R             from FactoredFunctionUtilities(D3) if D3 has INTDOM
--R   [3] Plot3D -> Plot3D from Plot3D
--R   [4] (Plot3D,Segment(DoubleFloat)) -> Plot3D from Plot3D
--R   [5] Plot -> Plot from Plot
--R   [6] (Plot,Segment(DoubleFloat)) -> Plot from Plot
--R
--RExamples of refine from PlaneAlgebraicCurvePlot
--R
--Rsketch:=makeSketch(x+y,x,y,-1/2..1/2,-1/2..1/2)$ACPLOT 
--Rrefined:=refine(sketch,0.1)
--R
--R
--RExamples of refine from FactoredFunctionUtilities
--R
--R
--RExamples of refine from Plot3D
--R
--R
--RExamples of refine from Plot
--R
--R
--RExamples of refine from RealZeroPackage
--R
--R
--RExamples of refine from RealZeroPackageQ
--R
--R
--RExamples of refine from RightOpenIntervalRootCharacterization
--R
--E 2469

--S 2470 of 3320
)d op regime
--R 
--R
--RThere is one unexposed function called regime :
--R   [1] (Record(det: D3,rows: List(Integer),cols: List(Integer)),Matrix(
--R            D3),List(Fraction(Polynomial(D11))),List(List(D3)),
--R            NonNegativeInteger,NonNegativeInteger,Integer) -> Record(eqzro: 
--R            List(D3),neqzro: List(D3),wcond: List(Polynomial(D11)),bsoln: 
--R            Record(partsol: Vector(Fraction(Polynomial(D11))),basis: List(
--R            Vector(Fraction(Polynomial(D11))))))
--R             from ParametricLinearEquations(D11,D1,D2,D3)
--R             if D11 has Join(EuclideanDomain,CharacteristicZero) and D3
--R             has POLYCAT(D11,D2,D1) and D1 has Join(OrderedSet,
--R            ConvertibleTo(Symbol)) and D2 has OAMONS
--R
--RExamples of regime from ParametricLinearEquations
--R
--E 2470

--S 2471 of 3320
)d op region
--R 
--R
--RThere is one unexposed function called region :
--R   [1] (TwoDimensionalViewport,PositiveInteger,String) -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of region from TwoDimensionalViewport
--R
--E 2471

--S 2472 of 3320
)d op regularRepresentation
--R 
--R
--RThere are 2 exposed functions called regularRepresentation :
--R   [1] (D,Vector(D)) -> Matrix(D3) from D
--R             if D has FINRALG(D3,D4) and D3 has COMRING and D4 has 
--R            UPOLYC(D3)
--R   [2] D -> Matrix(D2) from D
--R             if D has FRAMALG(D2,D3) and D2 has COMRING and D3 has 
--R            UPOLYC(D2)
--R
--RExamples of regularRepresentation from FiniteRankAlgebra
--R
--R
--RExamples of regularRepresentation from FramedAlgebra
--R
--E 2472

--S 2473 of 3320 done
)d op reindex
--R 
--R
--RThere is one exposed function called reindex :
--R   [1] (CartesianTensor(D2,D3,D4),List(Integer)) -> CartesianTensor(D2,
--R            D3,D4)
--R             from CartesianTensor(D2,D3,D4) if D2: INT and D3: NNI and 
--R            D4 has COMRING
--R
--RExamples of reindex from CartesianTensor
--R
--Rn:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] 
--Rtn:CartesianTensor(1,2,Integer):=n 
--Rp:=product(tn,tn) 
--Rreindex(p,[4,3,2,1])
--R
--E 2473

--S 2474 of 3320
)d op relationsIdeal
--R 
--R
--RThere is one exposed function called relationsIdeal :
--R   [1] List(D6) -> SuchThat(List(Polynomial(D3)),List(Equation(
--R            Polynomial(D3))))
--R             from PolynomialIdeals(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D4,D5) and D5 has KONVERT(SYMBOL) and
--R            D3 has FIELD and D4 has OAMONS and D5 has ORDSET
--R
--RExamples of relationsIdeal from PolynomialIdeals
--R
--E 2474

--S 2475 of 3320
)d op relativeApprox
--R 
--R
--RThere are 3 exposed functions called relativeApprox :
--R   [1] (RealClosure(D2),RealClosure(D2)) -> Fraction(Integer)
--R             from RealClosure(D2) if D2 has Join(OrderedRing,Field,
--R            RealConstant)
--R   [2] (D2,RightOpenIntervalRootCharacterization(D1,D2),D1) -> D1
--R             from RightOpenIntervalRootCharacterization(D1,D2)
--R             if D1 has Join(OrderedRing,Field) and D2 has UPOLYC(D1)
--R         
--R   [3] (D2,D,D1) -> D1 from D
--R             if D has RRCC(D1,D2) and D1 has Join(OrderedRing,Field) 
--R            and D2 has UPOLYC(D1)
--R
--RExamples of relativeApprox from RealClosure
--R
--R
--RExamples of relativeApprox from RightOpenIntervalRootCharacterization
--R
--R
--RExamples of relativeApprox from RealRootCharacterizationCategory
--R
--E 2475

--S 2476 of 3320
)d op relerror
--R 
--R
--RThere is one exposed function called relerror :
--R   [1] (Float,Float) -> Integer from Float
--R
--RExamples of relerror from Float
--R
--E 2476

--S 2477 of 3320
)d op rem
--R 
--R
--RThere are 2 exposed functions called rem :
--R   [1] (D,D) -> D from D if D has EUCDOM
--R   [2] (NonNegativeInteger,NonNegativeInteger) -> NonNegativeInteger
--R             from NonNegativeInteger
--R
--RThere is one unexposed function called rem :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of rem from EuclideanDomain
--R
--R
--RExamples of rem from NonNegativeInteger
--R
--R
--RExamples of rem from OutputForm
--R
--E 2477

--S 2478 of 3320
)d op remainder
--R 
--R
--RThere is one exposed function called remainder :
--R   [1] (D2,D) -> Record(rnum: D3,polnum: D2,den: D3) from D
--R             if D has PSETCAT(D3,D4,D5,D2) and D3 has RING and D4 has 
--R            OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5) and 
--R            D3 has INTDOM
--R
--RExamples of remainder from PolynomialSetCategory
--R
--E 2478

--S 2479 of 3320
)d op remainder!
--R 
--R
--RThere is one exposed function called remainder! :
--R   [1] (U32Vector,U32Vector,Integer) -> Void from 
--R            U32VectorPolynomialOperations
--R
--RExamples of remainder! from U32VectorPolynomialOperations
--R
--E 2479

--S 2480 of 3320
)d op RemainderList
--R 
--R
--RThere are 2 unexposed functions called RemainderList :
--R   [1] XPolynomial(D2) -> List(Record(k: Symbol,c: XPolynomial(D2)))
--R             from XPolynomial(D2) if D2 has RING
--R   [2] XRecursivePolynomial(D2,D3) -> List(Record(k: D2,c: 
--R            XRecursivePolynomial(D2,D3)))
--R             from XRecursivePolynomial(D2,D3) if D2 has ORDSET and D3
--R             has RING
--R
--RExamples of RemainderList from XPolynomial
--R
--R
--RExamples of RemainderList from XRecursivePolynomial
--R
--E 2480

--S 2481 of 3320
)d op remove
--R 
--R
--RThere are 5 exposed functions called remove :
--R   [1] (D1,D) -> D from D
--R             if D has finiteAggregate and D has CLAGG(D1) and D1 has 
--R            TYPE and D1 has SETCAT
--R   [2] ((D2 -> Boolean),D) -> D from D
--R             if D has finiteAggregate and D has CLAGG(D2) and D2 has 
--R            TYPE
--R   [3] ((D2 -> Boolean),D) -> D from D if D has LZSTAGG(D2) and D2 has 
--R            TYPE
--R   [4] ((D3 -> Boolean),Multiset(D3),Integer) -> Multiset(D3) from 
--R            Multiset(D3)
--R             if D3 has SETCAT
--R   [5] (D1,Multiset(D1),Integer) -> Multiset(D1) from Multiset(D1) if 
--R            D1 has SETCAT
--R
--RThere is one unexposed function called remove :
--R   [1] (SplittingNode(D2,D3),SplittingTree(D2,D3)) -> SplittingTree(D2,
--R            D3)
--R             from SplittingTree(D2,D3)
--R             if D2 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of remove from Collection
--R
--R
--RExamples of remove from LazyStreamAggregate
--R
--Rm:=[i for i in 1..] 
--Rf(i:PositiveInteger):Boolean == even? i 
--Rremove(f,m)
--R
--R
--RExamples of remove from Multiset
--R
--Rf(x) == x < 4 
--Rs := multiset [1,2,3,4,5,4,3,2,3,4,5,6,7,4,10] 
--Rremove(f,s,2) 
--Rremove(f,s,0) 
--Rremove(f,s,-2)
--R
--Rs := multiset [1,2,3,4,5,4,3,2,3,4,5,6,7,4,10] 
--Rremove(3,s,2) 
--Rremove(3,s,0) 
--Rremove(3,s,-2)
--R
--R
--RExamples of remove from SplittingTree
--R
--E 2481

--S 2482 of 3320
)d op remove!
--R 
--R
--RThere are 7 exposed functions called remove! :
--R   [1] ((D2 -> Boolean),D) -> D from D
--R             if D has finiteAggregate and D has DIOPS(D2) and D2 has 
--R            SETCAT
--R   [2] (D1,D) -> D from D
--R             if D has finiteAggregate and D has DIOPS(D1) and D1 has 
--R            SETCAT
--R   [3] (D1,D) -> D from D if D has ELAGG(D1) and D1 has TYPE and D1
--R             has SETCAT
--R   [4] ((D2 -> Boolean),D) -> D from D if D has ELAGG(D2) and D2 has 
--R            TYPE
--R   [5] (D2,D) -> Union(D1,"failed") from D
--R             if D has KDAGG(D2,D1) and D2 has SETCAT and D1 has SETCAT
--R            
--R   [6] ((D3 -> Boolean),Multiset(D3),Integer) -> Multiset(D3) from 
--R            Multiset(D3)
--R             if D3 has SETCAT
--R   [7] (D1,Multiset(D1),Integer) -> Multiset(D1) from Multiset(D1) if 
--R            D1 has SETCAT
--R
--RThere is one unexposed function called remove! :
--R   [1] (SplittingNode(D2,D3),SplittingTree(D2,D3)) -> SplittingTree(D2,
--R            D3)
--R             from SplittingTree(D2,D3)
--R             if D2 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of remove! from DictionaryOperations
--R
--R
--RExamples of remove! from ExtensibleLinearAggregate
--R
--R
--RExamples of remove! from KeyedDictionary
--R
--R
--RExamples of remove! from Multiset
--R
--Rf(x) == x < 4 
--Rs := multiset [1,2,3,4,5,4,3,2,3,4,5,6,7,4,10] 
--Rremove!(f,s,2) 
--Rs := multiset [1,2,3,4,5,4,3,2,3,4,5,6,7,4,10] 
--Rremove!(f,s,0) 
--Rs := multiset [1,2,3,4,5,4,3,2,3,4,5,6,7,4,10] 
--Rremove!(f,s,-2)
--R
--Rs := multiset [1,2,3,4,5,4,3,2,3,4,5,6,7,4,10] 
--Rremove!(3,s,2) 
--Rs := multiset [1,2,3,4,5,4,3,2,3,4,5,6,7,4,10] 
--Rremove!(3,s,0) 
--Rs := multiset [1,2,3,4,5,4,3,2,3,4,5,6,7,4,10] 
--Rremove!(3,s,-2)
--R
--R
--RExamples of remove! from SplittingTree
--R
--E 2482

--S 2483 of 3320
)d op removeConjugate
--R 
--R
--RThere are 4 exposed functions called removeConjugate :
--R   [1] List(D) -> List(D) from D if D has AFSPCAT(D2) and D2 has FIELD
--R            
--R   [2] (List(D),NonNegativeInteger) -> List(D) from D
--R             if D has AFSPCAT(D3) and D3 has FIELD
--R   [3] List(D) -> List(D) from D if D has PRSPCAT(D2) and D2 has FIELD
--R            
--R   [4] (List(D),NonNegativeInteger) -> List(D) from D
--R             if D has PRSPCAT(D3) and D3 has FIELD
--R
--RExamples of removeConjugate from AffineSpaceCategory
--R
--R
--RExamples of removeConjugate from ProjectiveSpaceCategory
--R
--E 2483

--S 2484 of 3320
)d op removeConstantTerm
--R 
--R
--RThere is one unexposed function called removeConstantTerm :
--R   [1] (D1,Symbol) -> D1 from IntegrationTools(D3,D1)
--R             if D3 has INTDOM and D3 has ORDSET and D1 has FS(D3)
--R
--RExamples of removeConstantTerm from IntegrationTools
--R
--E 2484

--S 2485 of 3320
)d op removeCoshSq
--R 
--R
--RThere is one exposed function called removeCoshSq :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of removeCoshSq from TranscendentalManipulations
--R
--E 2485

--S 2486 of 3320
)d op removeCosSq
--R 
--R
--RThere is one exposed function called removeCosSq :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of removeCosSq from TranscendentalManipulations
--R
--E 2486

--S 2487 of 3320 done
)d op removeDuplicates
--R 
--R
--RThere is one exposed function called removeDuplicates :
--R   [1] D -> D from D
--R             if D has finiteAggregate and D has CLAGG(D1) and D1 has 
--R            TYPE and D1 has SETCAT
--R
--RExamples of removeDuplicates from Collection
--R
--RremoveDuplicates [1,4,2,-6,0,3,5,4,2,3]
--R
--E 2487

--S 2488 of 3320
)d op removeDuplicates!
--R 
--R
--RThere are 2 exposed functions called removeDuplicates! :
--R   [1] D -> D from D if D has ELAGG(D1) and D1 has TYPE and D1 has 
--R            SETCAT
--R   [2] D -> D from D if D has MDAGG(D1) and D1 has SETCAT
--R
--RExamples of removeDuplicates! from ExtensibleLinearAggregate
--R
--R
--RExamples of removeDuplicates! from MultiDictionary
--R
--E 2488

--S 2489 of 3320
)d op removeFirstZeroes
--R 
--R
--RThere is one exposed function called removeFirstZeroes :
--R   [1] D -> D from D if D has LOCPOWC(D1) and D1 has FIELD
--R
--RExamples of removeFirstZeroes from LocalPowerSeriesCategory
--R
--E 2489

--S 2490 of 3320
)d op removeIrreducibleRedundantFactors
--R 
--R
--RThere is one unexposed function called removeIrreducibleRedundantFactors :
--R   [1] (List(D5),List(D5)) -> List(D5)
--R             from PolynomialSetUtilitiesPackage(D2,D3,D4,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has CHARZ and D2 has 
--R            EUCDOM and D2 has INTDOM and D3 has OAMONS and D4 has 
--R            ORDSET
--R
--RExamples of removeIrreducibleRedundantFactors from PolynomialSetUtilitiesPackage
--R
--E 2490

--S 2491 of 3320
)d op removeRedundantFactors
--R 
--R
--RThere are 5 unexposed functions called removeRedundantFactors :
--R   [1] List(D5) -> List(D5) from PolynomialSetUtilitiesPackage(D2,D3,D4
--R            ,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has INTDOM and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [2] (D2,D2) -> List(D2) from PolynomialSetUtilitiesPackage(D3,D4,D5,
--R            D2)
--R             if D3 has INTDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5)
--R   [3] (List(D2),D2) -> List(D2) from PolynomialSetUtilitiesPackage(D3,
--R            D4,D5,D2)
--R             if D2 has RPOLCAT(D3,D4,D5) and D3 has INTDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [4] (List(D5),List(D5)) -> List(D5)
--R             from PolynomialSetUtilitiesPackage(D2,D3,D4,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has INTDOM and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [5] (List(D6),List(D6),(List(D6) -> List(D6))) -> List(D6)
--R             from PolynomialSetUtilitiesPackage(D3,D4,D5,D6)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has INTDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R
--RExamples of removeRedundantFactors from PolynomialSetUtilitiesPackage
--R
--E 2491

--S 2492 of 3320
)d op removeRedundantFactorsInContents
--R 
--R
--RThere is one unexposed function called removeRedundantFactorsInContents :
--R   [1] (List(D5),List(D5)) -> List(D5)
--R             from PolynomialSetUtilitiesPackage(D2,D3,D4,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has GCDDOM and D2 has 
--R            INTDOM and D3 has OAMONS and D4 has ORDSET
--R
--RExamples of removeRedundantFactorsInContents from PolynomialSetUtilitiesPackage
--R
--E 2492

--S 2493 of 3320
)d op removeRedundantFactorsInPols
--R 
--R
--RThere is one unexposed function called removeRedundantFactorsInPols :
--R   [1] (List(D5),List(D5)) -> List(D5)
--R             from PolynomialSetUtilitiesPackage(D2,D3,D4,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has GCDDOM and D2 has 
--R            INTDOM and D3 has OAMONS and D4 has ORDSET
--R
--RExamples of removeRedundantFactorsInPols from PolynomialSetUtilitiesPackage
--R
--E 2493

--S 2494 of 3320
)d op removeRoughlyRedundantFactorsInContents
--R 
--R
--RThere is one unexposed function called removeRoughlyRedundantFactorsInContents :
--R   [1] (List(D5),List(D5)) -> List(D5)
--R             from PolynomialSetUtilitiesPackage(D2,D3,D4,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has GCDDOM and D2 has 
--R            INTDOM and D3 has OAMONS and D4 has ORDSET
--R
--RExamples of removeRoughlyRedundantFactorsInContents from PolynomialSetUtilitiesPackage
--R
--E 2494

--S 2495 of 3320
)d op removeRoughlyRedundantFactorsInPol
--R 
--R
--RThere is one unexposed function called removeRoughlyRedundantFactorsInPol :
--R   [1] (D1,List(D1)) -> D1 from PolynomialSetUtilitiesPackage(D3,D4,D5,
--R            D1)
--R             if D1 has RPOLCAT(D3,D4,D5) and D3 has INTDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R
--RExamples of removeRoughlyRedundantFactorsInPol from PolynomialSetUtilitiesPackage
--R
--E 2495

--S 2496 of 3320
)d op removeRoughlyRedundantFactorsInPols
--R 
--R
--RThere are 2 unexposed functions called removeRoughlyRedundantFactorsInPols :
--R   [1] (List(D5),List(D5)) -> List(D5)
--R             from PolynomialSetUtilitiesPackage(D2,D3,D4,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has INTDOM and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [2] (List(D6),List(D6),Boolean) -> List(D6)
--R             from PolynomialSetUtilitiesPackage(D3,D4,D5,D6)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has INTDOM and D4 has 
--R            OAMONS and D5 has ORDSET
--R
--RExamples of removeRoughlyRedundantFactorsInPols from PolynomialSetUtilitiesPackage
--R
--E 2496

--S 2497 of 3320
)d op removeSinhSq
--R 
--R
--RThere is one exposed function called removeSinhSq :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of removeSinhSq from TranscendentalManipulations
--R
--E 2497

--S 2498 of 3320
)d op removeSinSq
--R 
--R
--RThere is one exposed function called removeSinSq :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of removeSinSq from TranscendentalManipulations
--R
--E 2498

--S 2499 of 3320
)d op removeSquaresIfCan
--R 
--R
--RThere is one unexposed function called removeSquaresIfCan :
--R   [1] List(D5) -> List(D5) from PolynomialSetUtilitiesPackage(D2,D3,D4
--R            ,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has INTDOM and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RExamples of removeSquaresIfCan from PolynomialSetUtilitiesPackage
--R
--E 2499

--S 2500 of 3320
)d op removeSuperfluousCases
--R 
--R
--RThere are 2 exposed functions called removeSuperfluousCases :
--R   [1] List(Record(val: List(D5),tower: D6)) -> List(Record(val: List(
--R            D5),tower: D6))
--R             from QuasiComponentPackage(D2,D3,D4,D5,D6)
--R             if D5 has RPOLCAT(D2,D3,D4) and D6 has RSETCAT(D2,D3,D4,D5
--R            ) and D2 has GCDDOM and D3 has OAMONS and D4 has ORDSET
--R   [2] List(Record(val: List(D5),tower: D6)) -> List(Record(val: List(
--R            D5),tower: D6))
--R             from SquareFreeQuasiComponentPackage(D2,D3,D4,D5,D6)
--R             if D5 has RPOLCAT(D2,D3,D4) and D6 has RSETCAT(D2,D3,D4,D5
--R            ) and D2 has GCDDOM and D3 has OAMONS and D4 has ORDSET
--R
--RExamples of removeSuperfluousCases from QuasiComponentPackage
--R
--R
--RExamples of removeSuperfluousCases from SquareFreeQuasiComponentPackage
--R
--E 2500

--S 2501 of 3320
)d op removeSuperfluousQuasiComponents
--R 
--R
--RThere are 2 exposed functions called removeSuperfluousQuasiComponents :
--R   [1] List(D6) -> List(D6) from QuasiComponentPackage(D2,D3,D4,D5,D6)
--R             if D6 has RSETCAT(D2,D3,D4,D5) and D2 has GCDDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R   [2] List(D6) -> List(D6) from SquareFreeQuasiComponentPackage(D2,D3,
--R            D4,D5,D6)
--R             if D6 has RSETCAT(D2,D3,D4,D5) and D2 has GCDDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R
--RExamples of removeSuperfluousQuasiComponents from QuasiComponentPackage
--R
--R
--RExamples of removeSuperfluousQuasiComponents from SquareFreeQuasiComponentPackage
--R
--E 2501

--S 2502 of 3320
)d op removeZero
--R 
--R
--RThere is one exposed function called removeZero :
--R   [1] (D1,D) -> D1 from D
--R             if D has TSETCAT(D2,D3,D4,D1) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D1 has RPOLCAT(D2,D3,D4)
--R            
--R
--RExamples of removeZero from TriangularSetCategory
--R
--E 2502

--S 2503 of 3320
)d op removeZeroes
--R 
--R
--RThere are 4 exposed functions called removeZeroes :
--R   [1] D -> D from D if D has LOCPOWC(D1) and D1 has FIELD
--R   [2] (Integer,D) -> D from D if D has LOCPOWC(D2) and D2 has FIELD
--R         
--R   [3] (Integer,D) -> D from D
--R             if D has ULSCCAT(D2,D3) and D2 has RING and D3 has UTSCAT(
--R            D2)
--R   [4] D -> D from D if D has ULSCCAT(D1,D2) and D1 has RING and D2
--R             has UTSCAT(D1)
--R
--RThere are 6 unexposed functions called removeZeroes :
--R   [1] (Integer,BalancedPAdicRational(D2)) -> BalancedPAdicRational(D2)
--R             from BalancedPAdicRational(D2) if D2: INT
--R   [2] BalancedPAdicRational(D1) -> BalancedPAdicRational(D1)
--R             from BalancedPAdicRational(D1) if D1: INT
--R   [3] (Integer,PAdicRational(D2)) -> PAdicRational(D2) from 
--R            PAdicRational(D2)
--R             if D2: INT
--R   [4] PAdicRational(D1) -> PAdicRational(D1) from PAdicRational(D1)
--R             if D1: INT
--R   [5] (Integer,PAdicRationalConstructor(D2,D3)) -> 
--R            PAdicRationalConstructor(D2,D3)
--R             from PAdicRationalConstructor(D2,D3) if D2: INT and D3
--R             has PADICCT(D2)
--R   [6] PAdicRationalConstructor(D1,D2) -> PAdicRationalConstructor(D1,
--R            D2)
--R             from PAdicRationalConstructor(D1,D2) if D1: INT and D2
--R             has PADICCT(D1)
--R
--RExamples of removeZeroes from BalancedPAdicRational
--R
--R
--RExamples of removeZeroes from LocalPowerSeriesCategory
--R
--R
--RExamples of removeZeroes from PAdicRational
--R
--R
--RExamples of removeZeroes from PAdicRationalConstructor
--R
--R
--RExamples of removeZeroes from UnivariateLaurentSeriesConstructorCategory
--R
--E 2503

--S 2504 of 3320
)d op rename
--R 
--R
--RThere is one exposed function called rename :
--R   [1] (D,OutputForm) -> D from D if D has RCFIELD
--R
--RExamples of rename from RealClosedField
--R
--E 2504

--S 2505 of 3320
)d op rename!
--R 
--R
--RThere is one exposed function called rename! :
--R   [1] (D,OutputForm) -> D from D if D has RCFIELD
--R
--RExamples of rename! from RealClosedField
--R
--E 2505

--S 2506 of 3320
)d op reopen!
--R 
--R
--RThere is one exposed function called reopen! :
--R   [1] (D,String) -> D from D
--R             if D has FILECAT(D2,D3) and D2 has SETCAT and D3 has 
--R            SETCAT
--R
--RExamples of reopen! from FileCategory
--R
--E 2506

--S 2507 of 3320
)d op reorder
--R 
--R
--RThere are 3 unexposed functions called reorder :
--R   [1] (DistributedMultivariatePolynomial(D2,D3),List(Integer)) -> 
--R            DistributedMultivariatePolynomial(D2,D3)
--R             from DistributedMultivariatePolynomial(D2,D3)
--R             if D2: LIST(SYMBOL) and D3 has RING
--R   [2] (GeneralDistributedMultivariatePolynomial(D2,D3,D4),List(Integer
--R            )) -> GeneralDistributedMultivariatePolynomial(D2,D3,D4)
--R             from GeneralDistributedMultivariatePolynomial(D2,D3,D4)
--R             if D2: LIST(SYMBOL) and D3 has RING and D4 has DIRPCAT(#(
--R            D2),NNI)
--R   [3] (HomogeneousDistributedMultivariatePolynomial(D2,D3),List(
--R            Integer)) -> HomogeneousDistributedMultivariatePolynomial(D2,D3)
--R             from HomogeneousDistributedMultivariatePolynomial(D2,D3)
--R             if D2: LIST(SYMBOL) and D3 has RING
--R
--RExamples of reorder from DistributedMultivariatePolynomial
--R
--R
--RExamples of reorder from GeneralDistributedMultivariatePolynomial
--R
--R
--RExamples of reorder from HomogeneousDistributedMultivariatePolynomial
--R
--E 2507

--S 2508 of 3320
)d op repack1
--R 
--R
--RThere is one exposed function called repack1 :
--R   [1] (D2,U32Vector,Integer,D5) -> Void from D
--R             if D has MAGCDOC(D2,D5) and D2 has TYPE and D5 has TYPE
--R         
--R
--RExamples of repack1 from ModularAlgebraicGcdOperations
--R
--E 2508

--S 2509 of 3320 done
)d op repeating
--R 
--R
--RThere is one exposed function called repeating :
--R   [1] List(D2) -> Stream(D2) from Stream(D2) if D2 has TYPE
--R
--RExamples of repeating from Stream
--R
--Rm:=repeating([-1,0,1,2,3])
--R
--E 2509

--S 2510 of 3320 done
)d op repeating?
--R 
--R
--RThere is one exposed function called repeating? :
--R   [1] (List(D3),Stream(D3)) -> Boolean from Stream(D3)
--R             if D3 has SETCAT and D3 has TYPE
--R
--RExamples of repeating? from Stream
--R
--Rm:=[1,2,3] 
--Rn:=repeating(m) 
--Rrepeating?(m,n)
--R
--E 2510

--S 2511 of 3320
)d op repeatUntilLoop
--R 
--R
--RThere is one exposed function called repeatUntilLoop :
--R   [1] (Switch,FortranCode) -> FortranCode from FortranCode
--R
--RExamples of repeatUntilLoop from FortranCode
--R
--E 2511

--S 2512 of 3320
)d op replace
--R 
--R
--RThere is one exposed function called replace :
--R   [1] (D,UniversalSegment(Integer),D) -> D from D if D has SRAGG
--R
--RExamples of replace from StringAggregate
--R
--E 2512

--S 2513 of 3320
)d op replaceDiffs
--R 
--R
--RThere is one exposed function called replaceDiffs :
--R   [1] (D1,BasicOperator,Symbol) -> D1 from ExpressionSolve(D4,D1,D5,D6
--R            )
--R             if D4 has Join(OrderedSet,IntegralDomain,ConvertibleTo(
--R            InputForm)) and D1 has FS(D4) and D5 has UTSCAT(D1) and D6
--R             has UTSCAT(SUPEXPR(D1))
--R
--RExamples of replaceDiffs from ExpressionSolve
--R
--E 2513

--S 2514 of 3320
)d op replaceKthElement
--R 
--R
--RThere is one unexposed function called replaceKthElement :
--R   [1] (SetOfMIntegersInOneToN(D2,D3),PositiveInteger,PositiveInteger)
--R             -> Union(SetOfMIntegersInOneToN(D2,D3),"failed")
--R             from SetOfMIntegersInOneToN(D2,D3) if D2: PI and D3: PI
--R         
--R
--RExamples of replaceKthElement from SetOfMIntegersInOneToN
--R
--E 2514

--S 2515 of 3320
)d op replaceVarByOne
--R 
--R
--RThere is one exposed function called replaceVarByOne :
--R   [1] (D1,Integer) -> D1 from PackageForPoly(D3,D1,D4,D5)
--R             if D3 has RING and D4 has DIRPCAT(D5,NNI) and D5: NNI and 
--R            D1 has FAMR(D3,D4)
--R
--RExamples of replaceVarByOne from PackageForPoly
--R
--E 2515

--S 2516 of 3320
)d op replaceVarByZero
--R 
--R
--RThere is one exposed function called replaceVarByZero :
--R   [1] (D1,Integer) -> D1 from PackageForPoly(D3,D1,D4,D5)
--R             if D3 has RING and D4 has DIRPCAT(D5,NNI) and D5: NNI and 
--R            D1 has FAMR(D3,D4)
--R
--RExamples of replaceVarByZero from PackageForPoly
--R
--E 2516

--S 2517 of 3320 done
)d op reportInstantiations
--R 
--R
--RThere is one exposed function called reportInstantiations :
--R   [1] Boolean -> Void from ApplicationProgramInterface
--R
--RExamples of reportInstantiations from ApplicationProgramInterface
--R
--RreportInstantiations(true) 
--R1 
--RreportInstantiations(false)
--R
--E 2517

--S 2518 of 3320
)d op representationType
--R 
--R
--RThere is one exposed function called representationType :
--R   [1]  -> Union("prime",polynomial,normal,cyclic) from D if D has 
--R            FFIELDC
--R
--RExamples of representationType from FiniteFieldCategory
--R
--E 2518

--S 2519 of 3320
)d op represents
--R 
--R
--RThere are 6 exposed functions called represents :
--R   [1] Vector(D2) -> D from D if D2 has FIELD and D has FAXF(D2)
--R   [2] (Vector(D2),D2) -> D from D
--R             if D2 has UPOLYC(D3) and D3 has UFD and D has FFCAT(D3,D2,
--R            D4) and D4 has UPOLYC(FRAC(D2))
--R   [3] (Vector(D3),Vector(D)) -> D from D if D3 has COMRING and D has 
--R            FINAALG(D3)
--R   [4] (Vector(D3),Vector(D)) -> D from D
--R             if D3 has COMRING and D has FINRALG(D3,D4) and D4 has 
--R            UPOLYC(D3)
--R   [5] Vector(D2) -> D from D
--R             if D2 has COMRING and D has FRAMALG(D2,D3) and D3 has 
--R            UPOLYC(D2)
--R   [6] Vector(D2) -> D from D if D2 has COMRING and D has FRNAALG(D2)
--R         
--R
--RExamples of represents from FiniteAlgebraicExtensionField
--R
--R
--RExamples of represents from FunctionFieldCategory
--R
--R
--RExamples of represents from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of represents from FiniteRankAlgebra
--R
--R
--RExamples of represents from FramedAlgebra
--R
--R
--RExamples of represents from FramedNonAssociativeAlgebra
--R
--E 2519

--S 2520 of 3320
)d op repSq
--R 
--R
--RThere is one unexposed function called repSq :
--R   [1] (Vector(D3),NonNegativeInteger) -> Vector(D3)
--R             from InnerNormalBasisFieldFunctions(D3) if D3 has FFIELDC
--R            
--R
--RExamples of repSq from InnerNormalBasisFieldFunctions
--R
--E 2520

--S 2521 of 3320
)d op reseed
--R 
--R
--RThere is one exposed function called reseed :
--R   [1] Integer -> Void from RandomNumberSource
--R
--RExamples of reseed from RandomNumberSource
--R
--E 2521

--S 2522 of 3320
)d op reset
--R 
--R
--RThere are 2 exposed functions called reset :
--R   [1]  -> Void
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R             if D6 has FIELD and D7: LIST(SYMBOL) and D8 has POLYCAT(D6
--R            ,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI) and D10 has 
--R            PRSPCAT(D6) and D11 has LOCPOWC(D6) and D12 has PLACESC(D6,
--R            D11) and D1 has DIVCAT(D12) and D2 has INFCLCT(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D4) and D4 has BLMETCT and D3 has DSTRCAT(D2
--R            )
--R   [2] ThreeDimensionalViewport -> Void from ThreeDimensionalViewport
--R         
--R
--RThere is one unexposed function called reset :
--R   [1] TwoDimensionalViewport -> Void from TwoDimensionalViewport
--R
--RExamples of reset from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of reset from TwoDimensionalViewport
--R
--R
--RExamples of reset from ThreeDimensionalViewport
--R
--E 2522

--S 2523 of 3320
)d op resetAttributeButtons
--R 
--R
--RThere is one exposed function called resetAttributeButtons :
--R   [1]  -> Void from AttributeButtons
--R
--RExamples of resetAttributeButtons from AttributeButtons
--R
--E 2523

--S 2524 of 3320
)d op resetBadValues
--R 
--R
--RThere is one unexposed function called resetBadValues :
--R   [1] Pattern(D1) -> Pattern(D1) from Pattern(D1) if D1 has SETCAT
--R
--RExamples of resetBadValues from Pattern
--R
--E 2524

--S 2525 of 3320 done
)d op resetNew
--R 
--R
--RThere is one exposed function called resetNew :
--R   [1]  -> Void from Symbol
--R
--RExamples of resetNew from Symbol
--R
--Rnew()$Symbol 
--Rnew()$Symbol 
--RresetNew() 
--Rnew()$Symbol
--R
--E 2525

--S 2526 of 3320
)d op resetVariableOrder
--R 
--R
--RThere is one exposed function called resetVariableOrder :
--R   [1]  -> Void from UserDefinedVariableOrdering
--R
--RExamples of resetVariableOrder from UserDefinedVariableOrdering
--R
--E 2526

--S 2527 of 3320
)d op reshape
--R 
--R
--RThere are 2 exposed functions called reshape :
--R   [1] (List(D7),CartesianTensor(D4,D5,D6)) -> CartesianTensor(D4,D5,D7
--R            )
--R             from CartesianTensorFunctions2(D4,D5,D6,D7)
--R             if D4: INT and D5: NNI and D6 has COMRING and D7 has 
--R            COMRING
--R   [2] (List(D8),D3) -> D1 from MPolyCatFunctions2(D4,D5,D6,D7,D8,D3,D1
--R            )
--R             if D8 has RING and D4 has ORDSET and D5 has OAMONS and D7
--R             has RING and D1 has POLYCAT(D8,D6,D4) and D6 has OAMONS 
--R            and D3 has POLYCAT(D7,D5,D4)
--R
--RExamples of reshape from CartesianTensorFunctions2
--R
--R
--RExamples of reshape from MPolyCatFunctions2
--R
--E 2527

--S 2528 of 3320
)d op resize
--R 
--R
--RThere is one exposed function called resize :
--R   [1] (ThreeDimensionalViewport,PositiveInteger,PositiveInteger) -> 
--R            Void
--R             from ThreeDimensionalViewport
--R
--RThere is one unexposed function called resize :
--R   [1] (TwoDimensionalViewport,PositiveInteger,PositiveInteger) -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of resize from TwoDimensionalViewport
--R
--R
--RExamples of resize from ThreeDimensionalViewport
--R
--E 2528

--S 2529 of 3320
)d op rest
--R 
--R
--RThere are 3 exposed functions called rest :
--R   [1] D -> Union(D,"failed") from D
--R             if D has TSETCAT(D1,D2,D3,D4) and D1 has INTDOM and D2
--R             has OAMONS and D3 has ORDSET and D4 has RPOLCAT(D1,D2,D3)
--R            
--R   [2] (D,NonNegativeInteger) -> D from D if D has URAGG(D2) and D2
--R             has TYPE
--R   [3] D -> D from D if D has URAGG(D1) and D1 has TYPE
--R
--RThere are 3 unexposed functions called rest :
--R   [1] Magma(D1) -> Magma(D1) from Magma(D1) if D1 has ORDSET
--R   [2] OrderedFreeMonoid(D1) -> OrderedFreeMonoid(D1) from 
--R            OrderedFreeMonoid(D1)
--R             if D1 has ORDSET
--R   [3] PoincareBirkhoffWittLyndonBasis(D1) -> 
--R            PoincareBirkhoffWittLyndonBasis(D1)
--R             from PoincareBirkhoffWittLyndonBasis(D1) if D1 has ORDSET
--R            
--R
--RExamples of rest from Magma
--R
--R
--RExamples of rest from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rrest m1
--R
--R
--RExamples of rest from PoincareBirkhoffWittLyndonBasis
--R
--R
--RExamples of rest from TriangularSetCategory
--R
--R
--RExamples of rest from UnaryRecursiveAggregate
--R
--Rrest([1,4,2,-6,0,3,5,4,2,3],3)
--R
--Rrest [1,4,2,-6,0,3,5,4,2,3]
--R
--E 2529

--S 2530 of 3320
)d op restorePrecision
--R 
--R
--RThere is one exposed function called restorePrecision :
--R   [1]  -> Void from NAGLinkSupportPackage
--R
--RExamples of restorePrecision from NAGLinkSupportPackage
--R
--E 2530

--S 2531 of 3320
)d op result
--R 
--R
--RThere is one unexposed function called result :
--R   [1] SplittingTree(D2,D3) -> List(Record(val: D2,tower: D3))
--R             from SplittingTree(D2,D3)
--R             if D2 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of result from SplittingTree
--R
--E 2531

--S 2532 of 3320
)d op resultant
--R 
--R
--RThere are 4 exposed functions called resultant :
--R   [1] (D,D,D1) -> D from D
--R             if D has POLYCAT(D2,D3,D1) and D2 has RING and D3 has 
--R            OAMONS and D1 has ORDSET and D2 has COMRING
--R   [2] (U32Vector,U32Vector,Integer) -> Integer
--R             from U32VectorPolynomialOperations
--R   [3] (D,D) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has INTDOM
--R   [4] (D,D) -> D1 from D if D has UPOLYC(D1) and D1 has RING and D1
--R             has COMRING
--R
--RThere is one unexposed function called resultant :
--R   [1] (D2,D2) -> D1 from PseudoRemainderSequence(D1,D2)
--R             if D1 has INTDOM and D2 has UPOLYC(D1)
--R
--RExamples of resultant from PolynomialCategory
--R
--R
--RExamples of resultant from U32VectorPolynomialOperations
--R
--R
--RExamples of resultant from PseudoRemainderSequence
--R
--R
--RExamples of resultant from RecursivePolynomialCategory
--R
--R
--RExamples of resultant from UnivariatePolynomialCategory
--R
--E 2532

--S 2533 of 3320
)d op resultantEuclidean
--R 
--R
--RThere is one unexposed function called resultantEuclidean :
--R   [1] (D2,D2) -> Record(coef1: D2,coef2: D2,resultant: D3)
--R             from PseudoRemainderSequence(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of resultantEuclidean from PseudoRemainderSequence
--R
--E 2533

--S 2534 of 3320
--R----------------)d op resultantEuclidean_naif (fix this)
--E 2534

--S 2535 of 3320
--R----------------)d op resultant_naif (fix this)
--E 2535

--S 2536 of 3320
)d op resultantReduit
--R 
--R
--RThere is one unexposed function called resultantReduit :
--R   [1] (D2,D2) -> D1 from PseudoRemainderSequence(D1,D2)
--R             if D1 has INTDOM and D1 has GCDDOM and D2 has UPOLYC(D1)
--R         
--R
--RExamples of resultantReduit from PseudoRemainderSequence
--R
--E 2536

--S 2537 of 3320
)d op resultantReduitEuclidean
--R 
--R
--RThere is one unexposed function called resultantReduitEuclidean :
--R   [1] (D2,D2) -> Record(coef1: D2,coef2: D2,resultantReduit: D3)
--R             from PseudoRemainderSequence(D3,D2)
--R             if D3 has GCDDOM and D3 has INTDOM and D2 has UPOLYC(D3)
--R         
--R
--RExamples of resultantReduitEuclidean from PseudoRemainderSequence
--R
--E 2537

--S 2538 of 3320
)d op resultantSet
--R 
--R
--RThere is one exposed function called resultantSet :
--R   [1] List(SparseUnivariatePolynomial(Polynomial(D3))) -> List(
--R            Polynomial(D3))
--R             from CylindricalAlgebraicDecompositionPackage(D3) if D3
--R             has RCFIELD
--R
--RExamples of resultantSet from CylindricalAlgebraicDecompositionPackage
--R
--E 2538

--S 2539 of 3320
)d op retract
--R 
--R
--RThere are 38 exposed functions called retract :
--R   [1] Any -> D1 from AnyFunctions1(D1) if D1 has TYPE
--R   [2] Polynomial(Float) -> FortranExpression(D2,D3,D4)
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has RETRACT(FLOAT) and D2: LIST(SYMBOL) and D3: LIST
--R            (SYMBOL) and D4 has FMTC
--R   [3] Fraction(Polynomial(Float)) -> FortranExpression(D2,D3,D4)
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has RETRACT(FLOAT) and D2: LIST(SYMBOL) and D3: LIST
--R            (SYMBOL) and D4 has FMTC
--R   [4] Expression(Float) -> FortranExpression(D2,D3,D4)
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has RETRACT(FLOAT) and D2: LIST(SYMBOL) and D3: LIST
--R            (SYMBOL) and D4 has FMTC
--R   [5] Polynomial(Integer) -> FortranExpression(D2,D3,D4)
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has RETRACT(INT) and D2: LIST(SYMBOL) and D3: LIST(
--R            SYMBOL) and D4 has FMTC
--R   [6] Fraction(Polynomial(Integer)) -> FortranExpression(D2,D3,D4)
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has RETRACT(INT) and D2: LIST(SYMBOL) and D3: LIST(
--R            SYMBOL) and D4 has FMTC
--R   [7] Expression(Integer) -> FortranExpression(D2,D3,D4)
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has RETRACT(INT) and D2: LIST(SYMBOL) and D3: LIST(
--R            SYMBOL) and D4 has FMTC
--R   [8] Symbol -> FortranExpression(D2,D3,D4) from FortranExpression(D2,
--R            D3,D4)
--R             if D2: LIST(SYMBOL) and D3: LIST(SYMBOL) and D4 has FMTC
--R         
--R   [9] Expression(D4) -> FortranExpression(D2,D3,D4)
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has FMTC and D2: LIST(SYMBOL) and D3: LIST(SYMBOL)
--R         
--R   [10] Matrix(Fraction(Polynomial(Integer))) -> D from D if D has 
--R            FMFUN
--R   [11] Matrix(Fraction(Polynomial(Float))) -> D from D if D has FMFUN
--R            
--R   [12] Matrix(Polynomial(Integer)) -> D from D if D has FMFUN
--R   [13] Matrix(Polynomial(Float)) -> D from D if D has FMFUN
--R   [14] Matrix(Expression(Integer)) -> D from D if D has FMFUN
--R   [15] Matrix(Expression(Float)) -> D from D if D has FMFUN
--R   [16] Fraction(Polynomial(Integer)) -> D from D if D has FORTFN
--R   [17] Fraction(Polynomial(Float)) -> D from D if D has FORTFN
--R   [18] Polynomial(Integer) -> D from D if D has FORTFN
--R   [19] Polynomial(Float) -> D from D if D has FORTFN
--R   [20] Expression(Integer) -> D from D if D has FORTFN
--R   [21] Expression(Float) -> D from D if D has FORTFN
--R   [22] Vector(Fraction(Polynomial(Integer))) -> D from D if D has 
--R            FVFUN
--R   [23] Vector(Fraction(Polynomial(Float))) -> D from D if D has FVFUN
--R            
--R   [24] Vector(Polynomial(Integer)) -> D from D if D has FVFUN
--R   [25] Vector(Polynomial(Float)) -> D from D if D has FVFUN
--R   [26] Vector(Expression(Integer)) -> D from D if D has FVFUN
--R   [27] Vector(Expression(Float)) -> D from D if D has FVFUN
--R   [28] MyExpression(D2,D3) -> Fraction(MyUnivariatePolynomial(D2,D3))
--R             from MyExpression(D2,D3)
--R             if D2: SYMBOL and D3 has Join(Ring,OrderedSet,
--R            IntegralDomain)
--R   [29] NumericalIntegrationProblem -> Union(nia: Record(var: Symbol,fn
--R            : Expression(DoubleFloat),range: Segment(OrderedCompletion(
--R            DoubleFloat)),abserr: DoubleFloat,relerr: DoubleFloat),mdnia: 
--R            Record(fn: Expression(DoubleFloat),range: List(Segment(
--R            OrderedCompletion(DoubleFloat))),abserr: DoubleFloat,relerr: 
--R            DoubleFloat))
--R             from NumericalIntegrationProblem
--R   [30] UnivariateFormalPowerSeries(D2) -> NottinghamGroup(D2)
--R             from NottinghamGroup(D2) if D2 has FFIELDC
--R   [31] NumericalODEProblem -> Record(xinit: DoubleFloat,xend: 
--R            DoubleFloat,fn: Vector(Expression(DoubleFloat)),yinit: List(
--R            DoubleFloat),intvals: List(DoubleFloat),g: Expression(DoubleFloat
--R            ),abserr: DoubleFloat,relerr: DoubleFloat)
--R             from NumericalODEProblem
--R   [32] NumericalOptimizationProblem -> Union(noa: Record(fn: 
--R            Expression(DoubleFloat),init: List(DoubleFloat),lb: List(
--R            OrderedCompletion(DoubleFloat)),cf: List(Expression(DoubleFloat))
--R            ,ub: List(OrderedCompletion(DoubleFloat))),lsa: Record(lfn: List(
--R            Expression(DoubleFloat)),init: List(DoubleFloat)))
--R             from NumericalOptimizationProblem
--R   [33] NumericalPDEProblem -> Record(pde: List(Expression(DoubleFloat)
--R            ),constraints: List(Record(start: DoubleFloat,finish: DoubleFloat
--R            ,grid: NonNegativeInteger,boundaryType: Integer,dStart: Matrix(
--R            DoubleFloat),dFinish: Matrix(DoubleFloat))),f: List(List(
--R            Expression(DoubleFloat))),st: String,tol: DoubleFloat)
--R             from NumericalPDEProblem
--R   [34] List(D5) -> D from D
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D has PSETCAT(D2,D3,D4,D5)
--R   [35] D -> D1 from D if D has RETRACT(D1) and D1 has TYPE
--R   [36] D1 -> D from D
--R             if D1 = POLY(D2) and not(ofCategory(D2,Algebra(Fraction(
--R            Integer)))) and not(ofCategory(D2,Algebra(Integer))) and D4
--R             has KONVERT(SYMBOL) and D2 has RING and D has RPOLCAT(D2,
--R            D3,D4) and D3 has OAMONS and D4 has ORDSET or D1 = POLY(D2)
--R            and not(ofCategory(D2,IntegerNumberSystem)) and not(
--R            ofCategory(D2,Algebra(Fraction(Integer)))) and D2 has 
--R            ALGEBRA(INT) and D4 has KONVERT(SYMBOL) and D2 has RING and
--R            D has RPOLCAT(D2,D3,D4) and D3 has OAMONS and D4 has ORDSET
--R            or D1 = POLY(D2) and not(ofCategory(D2,
--R            QuotientFieldCategory(Integer))) and D2 has ALGEBRA(FRAC(
--R            INT)) and D4 has KONVERT(SYMBOL) and D2 has RING and D has 
--R            RPOLCAT(D2,D3,D4) and D3 has OAMONS and D4 has ORDSET
--R   [37] D1 -> D from D
--R             if D1 = POLY(INT) and D has RPOLCAT(D2,D3,D4) and not(
--R            ofCategory(D2,Algebra(Fraction(Integer)))) and D2 has 
--R            ALGEBRA(INT) and D4 has KONVERT(SYMBOL) and D2 has RING and
--R            D3 has OAMONS and D4 has ORDSET or D1 = POLY(INT) and D
--R             has RPOLCAT(D2,D3,D4) and D2 has ALGEBRA(FRAC(INT)) and D4
--R             has KONVERT(SYMBOL) and D2 has RING and D3 has OAMONS and 
--R            D4 has ORDSET
--R   [38] Polynomial(Fraction(Integer)) -> D from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has ALGEBRA(FRAC(INT)) 
--R            and D4 has KONVERT(SYMBOL) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RExamples of retract from AnyFunctions1
--R
--R
--RExamples of retract from FortranExpression
--R
--R
--RExamples of retract from FortranMatrixFunctionCategory
--R
--R
--RExamples of retract from FortranFunctionCategory
--R
--R
--RExamples of retract from FortranVectorFunctionCategory
--R
--R
--RExamples of retract from MyExpression
--R
--R
--RExamples of retract from NumericalIntegrationProblem
--R
--R
--RExamples of retract from NottinghamGroup
--R
--R
--RExamples of retract from NumericalODEProblem
--R
--R
--RExamples of retract from NumericalOptimizationProblem
--R
--R
--RExamples of retract from NumericalPDEProblem
--R
--R
--RExamples of retract from PolynomialSetCategory
--R
--R
--RExamples of retract from RetractableTo
--R
--R
--RExamples of retract from RecursivePolynomialCategory
--R
--E 2539

--S 2540 of 3320
)d op retractable?
--R 
--R
--RThere is one exposed function called retractable? :
--R   [1] Any -> Boolean from AnyFunctions1(D3) if D3 has TYPE
--R
--RThere are 5 unexposed functions called retractable? :
--R   [1] AntiSymm(D2,D3) -> Boolean from AntiSymm(D2,D3)
--R             if D2 has RING and D3: LIST(SYMBOL)
--R   [2] DeRhamComplex(D2,D3) -> Boolean from DeRhamComplex(D2,D3)
--R             if D2 has Join(Ring,OrderedSet) and D3: LIST(SYMBOL)
--R   [3] LyndonWord(D2) -> Boolean from LyndonWord(D2) if D2 has ORDSET
--R         
--R   [4] Magma(D2) -> Boolean from Magma(D2) if D2 has ORDSET
--R   [5] PoincareBirkhoffWittLyndonBasis(D2) -> Boolean
--R             from PoincareBirkhoffWittLyndonBasis(D2) if D2 has ORDSET
--R            
--R
--RExamples of retractable? from AntiSymm
--R
--R
--RExamples of retractable? from AnyFunctions1
--R
--R
--RExamples of retractable? from DeRhamComplex
--R
--Rder:=DERHAM(Integer,[x,y,z]) 
--R[dx,dy,dz]:=[generator(i)$der for i in 1..3] 
--Rf:BOP:=operator('f) 
--Rg:BOP:=operator('g) 
--Rh:BOP:=operator('h) 
--Rsigma:=f(x,y,z)*dx + g(x,y,z)*dy + h(x,y,z)*dz 
--Rretractable? sigma
--R
--R
--RExamples of retractable? from LyndonWord
--R
--R
--RExamples of retractable? from Magma
--R
--R
--RExamples of retractable? from PoincareBirkhoffWittLyndonBasis
--R
--E 2540

--S 2541 of 3320
)d op retractIfCan
--R 
--R
--RThere are 32 exposed functions called retractIfCan :
--R   [1] Any -> Union(D1,"failed") from AnyFunctions1(D1) if D1 has TYPE
--R            
--R   [2] Polynomial(Float) -> Union(FortranExpression(D2,D3,D4),"failed")
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has RETRACT(FLOAT) and D2: LIST(SYMBOL) and D3: LIST
--R            (SYMBOL) and D4 has FMTC
--R   [3] Fraction(Polynomial(Float)) -> Union(FortranExpression(D2,D3,D4)
--R            ,"failed")
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has RETRACT(FLOAT) and D2: LIST(SYMBOL) and D3: LIST
--R            (SYMBOL) and D4 has FMTC
--R   [4] Expression(Float) -> Union(FortranExpression(D2,D3,D4),"failed")
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has RETRACT(FLOAT) and D2: LIST(SYMBOL) and D3: LIST
--R            (SYMBOL) and D4 has FMTC
--R   [5] Polynomial(Integer) -> Union(FortranExpression(D2,D3,D4),
--R            "failed")
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has RETRACT(INT) and D2: LIST(SYMBOL) and D3: LIST(
--R            SYMBOL) and D4 has FMTC
--R   [6] Fraction(Polynomial(Integer)) -> Union(FortranExpression(D2,D3,
--R            D4),"failed")
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has RETRACT(INT) and D2: LIST(SYMBOL) and D3: LIST(
--R            SYMBOL) and D4 has FMTC
--R   [7] Expression(Integer) -> Union(FortranExpression(D2,D3,D4),
--R            "failed")
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has RETRACT(INT) and D2: LIST(SYMBOL) and D3: LIST(
--R            SYMBOL) and D4 has FMTC
--R   [8] Symbol -> Union(FortranExpression(D2,D3,D4),"failed")
--R             from FortranExpression(D2,D3,D4)
--R             if D2: LIST(SYMBOL) and D3: LIST(SYMBOL) and D4 has FMTC
--R         
--R   [9] Expression(D4) -> Union(FortranExpression(D2,D3,D4),"failed")
--R             from FortranExpression(D2,D3,D4)
--R             if D4 has FMTC and D2: LIST(SYMBOL) and D3: LIST(SYMBOL)
--R         
--R   [10] Matrix(Fraction(Polynomial(Integer))) -> Union(D,"failed")
--R             from D
--R             if D has FMFUN
--R   [11] Matrix(Fraction(Polynomial(Float))) -> Union(D,"failed") from D
--R             if D has FMFUN
--R   [12] Matrix(Polynomial(Integer)) -> Union(D,"failed") from D if D
--R             has FMFUN
--R   [13] Matrix(Polynomial(Float)) -> Union(D,"failed") from D if D has 
--R            FMFUN
--R   [14] Matrix(Expression(Integer)) -> Union(D,"failed") from D if D
--R             has FMFUN
--R   [15] Matrix(Expression(Float)) -> Union(D,"failed") from D if D has 
--R            FMFUN
--R   [16] Fraction(Polynomial(Integer)) -> Union(D,"failed") from D if D
--R             has FORTFN
--R   [17] Fraction(Polynomial(Float)) -> Union(D,"failed") from D if D
--R             has FORTFN
--R   [18] Polynomial(Integer) -> Union(D,"failed") from D if D has FORTFN
--R            
--R   [19] Polynomial(Float) -> Union(D,"failed") from D if D has FORTFN
--R         
--R   [20] Expression(Integer) -> Union(D,"failed") from D if D has FORTFN
--R            
--R   [21] Expression(Float) -> Union(D,"failed") from D if D has FORTFN
--R         
--R   [22] Vector(Fraction(Polynomial(Integer))) -> Union(D,"failed")
--R             from D
--R             if D has FVFUN
--R   [23] Vector(Fraction(Polynomial(Float))) -> Union(D,"failed") from D
--R             if D has FVFUN
--R   [24] Vector(Polynomial(Integer)) -> Union(D,"failed") from D if D
--R             has FVFUN
--R   [25] Vector(Polynomial(Float)) -> Union(D,"failed") from D if D has 
--R            FVFUN
--R   [26] Vector(Expression(Integer)) -> Union(D,"failed") from D if D
--R             has FVFUN
--R   [27] Vector(Expression(Float)) -> Union(D,"failed") from D if D has 
--R            FVFUN
--R   [28] List(D5) -> Union(D,"failed") from D
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D has PSETCAT(D2,D3,D4,D5)
--R   [29] D -> Union(D1,"failed") from D if D has RETRACT(D1) and D1 has 
--R            TYPE
--R   [30] D1 -> Union(D,"failed") from D
--R             if D1 = POLY(D2) and not(ofCategory(D2,Algebra(Fraction(
--R            Integer)))) and not(ofCategory(D2,Algebra(Integer))) and D4
--R             has KONVERT(SYMBOL) and D2 has RING and D has RPOLCAT(D2,
--R            D3,D4) and D3 has OAMONS and D4 has ORDSET or D1 = POLY(D2)
--R            and not(ofCategory(D2,IntegerNumberSystem)) and not(
--R            ofCategory(D2,Algebra(Fraction(Integer)))) and D2 has 
--R            ALGEBRA(INT) and D4 has KONVERT(SYMBOL) and D2 has RING and
--R            D has RPOLCAT(D2,D3,D4) and D3 has OAMONS and D4 has ORDSET
--R            or D1 = POLY(D2) and not(ofCategory(D2,
--R            QuotientFieldCategory(Integer))) and D2 has ALGEBRA(FRAC(
--R            INT)) and D4 has KONVERT(SYMBOL) and D2 has RING and D has 
--R            RPOLCAT(D2,D3,D4) and D3 has OAMONS and D4 has ORDSET
--R   [31] D1 -> Union(D,"failed") from D
--R             if D1 = POLY(INT) and D has RPOLCAT(D2,D3,D4) and not(
--R            ofCategory(D2,Algebra(Fraction(Integer)))) and D2 has 
--R            ALGEBRA(INT) and D4 has KONVERT(SYMBOL) and D2 has RING and
--R            D3 has OAMONS and D4 has ORDSET or D1 = POLY(INT) and D
--R             has RPOLCAT(D2,D3,D4) and D2 has ALGEBRA(FRAC(INT)) and D4
--R             has KONVERT(SYMBOL) and D2 has RING and D3 has OAMONS and 
--R            D4 has ORDSET
--R   [32] Polynomial(Fraction(Integer)) -> Union(D,"failed") from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has ALGEBRA(FRAC(INT)) 
--R            and D4 has KONVERT(SYMBOL) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RThere is one unexposed function called retractIfCan :
--R   [1] D2 -> Union(SparseUnivariatePolynomial(
--R            SparseUnivariatePolynomial(D3)),"failed")
--R             from NormRetractPackage(D3,D4,D5,D2,D6)
--R             if D3 has FFIELDC and D4 has FAXF(D3) and D5 has UPOLYC(D4
--R            ) and D2 has UPOLYC(D5) and D6: PI
--R
--RExamples of retractIfCan from AnyFunctions1
--R
--R
--RExamples of retractIfCan from FortranExpression
--R
--R
--RExamples of retractIfCan from FortranMatrixFunctionCategory
--R
--R
--RExamples of retractIfCan from FortranFunctionCategory
--R
--R
--RExamples of retractIfCan from FortranVectorFunctionCategory
--R
--R
--RExamples of retractIfCan from NormRetractPackage
--R
--R
--RExamples of retractIfCan from PolynomialSetCategory
--R
--R
--RExamples of retractIfCan from RetractableTo
--R
--R
--RExamples of retractIfCan from RecursivePolynomialCategory
--R
--E 2541

--S 2542 of 3320
)d op retractToGrn
--R 
--R
--RThere is one exposed function called retractToGrn :
--R   [1] PseudoAlgebraicClosureOfAlgExtOfRationalNumber(D2) -> 
--R            PseudoAlgebraicClosureOfRationalNumber
--R             from PseudoAlgebraicClosureOfAlgExtOfRationalNumber(D2)
--R             if D2: PACRAT
--R
--RExamples of retractToGrn from PseudoAlgebraicClosureOfAlgExtOfRationalNumber
--R
--E 2542

--S 2543 of 3320
)d op returns
--R 
--R
--RThere are 7 exposed functions called returns :
--R   [1] Expression(Complex(Float)) -> FortranCode from FortranCode
--R   [2] Expression(Integer) -> FortranCode from FortranCode
--R   [3] Expression(Float) -> FortranCode from FortranCode
--R   [4] Expression(MachineComplex) -> FortranCode from FortranCode
--R   [5] Expression(MachineInteger) -> FortranCode from FortranCode
--R   [6] Expression(MachineFloat) -> FortranCode from FortranCode
--R   [7]  -> FortranCode from FortranCode
--R
--RExamples of returns from FortranCode
--R
--E 2543

--S 2544 of 3320
)d op returnType!
--R 
--R
--RThere are 3 exposed functions called returnType! :
--R   [1] Union(fst: FortranScalarType,void: void) -> Void from 
--R            TheSymbolTable
--R   [2] (Symbol,Union(fst: FortranScalarType,void: void)) -> Void
--R             from TheSymbolTable
--R   [3] (Symbol,Union(fst: FortranScalarType,void: void),TheSymbolTable)
--R             -> Void
--R             from TheSymbolTable
--R
--RExamples of returnType! from TheSymbolTable
--R
--E 2544

--S 2545 of 3320
)d op returnTypeOf
--R 
--R
--RThere is one exposed function called returnTypeOf :
--R   [1] (Symbol,TheSymbolTable) -> Union(fst: FortranScalarType,void: 
--R            void)
--R             from TheSymbolTable
--R
--RExamples of returnTypeOf from TheSymbolTable
--R
--E 2545

--S 2546 of 3320
)d op reverse
--R 
--R
--RThere is one exposed function called reverse :
--R   [1] D -> D from D if D has FLAGG(D1) and D1 has TYPE
--R
--RThere are 2 unexposed functions called reverse :
--R   [1] D1 -> D1 from GaloisGroupPolynomialUtilities(D2,D1)
--R             if D2 has RING and D1 has UPOLYC(D2)
--R   [2] ListMonoidOps(D1,D2,D3) -> ListMonoidOps(D1,D2,D3)
--R             from ListMonoidOps(D1,D2,D3)
--R             if D1 has SETCAT and D2 has ABELMON and D3: D2
--R
--RExamples of reverse from FiniteLinearAggregate
--R
--R
--RExamples of reverse from GaloisGroupPolynomialUtilities
--R
--R
--RExamples of reverse from ListMonoidOps
--R
--E 2546

--S 2547 of 3320
)d op reverse!
--R 
--R
--RThere are 3 exposed functions called reverse! :
--R   [1] Dequeue(D1) -> Dequeue(D1) from Dequeue(D1) if D1 has SETCAT
--R   [2] D -> D from D if D has DQAGG(D1) and D1 has TYPE
--R   [3] D -> D from D if D has shallowlyMutable and D has FLAGG(D1) and 
--R            D1 has TYPE
--R
--RThere is one unexposed function called reverse! :
--R   [1] ListMonoidOps(D1,D2,D3) -> ListMonoidOps(D1,D2,D3)
--R             from ListMonoidOps(D1,D2,D3)
--R             if D1 has SETCAT and D2 has ABELMON and D3: D2
--R
--RExamples of reverse! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rreverse! a 
--Ra
--R
--R
--RExamples of reverse! from DequeueAggregate
--R
--R
--RExamples of reverse! from FiniteLinearAggregate
--R
--R
--RExamples of reverse! from ListMonoidOps
--R
--E 2547

--S 2548 of 3320
)d op reverseLex
--R 
--R
--RThere is one unexposed function called reverseLex :
--R   [1] (Vector(D4),Vector(D4)) -> Boolean from OrderingFunctions(D3,D4)
--R             if D4 has OAMON and D3: NNI
--R
--RExamples of reverseLex from OrderingFunctions
--R
--E 2548

--S 2549 of 3320
)d op revert
--R 
--R
--RThere are 2 exposed functions called revert :
--R   [1] UnivariateFormalPowerSeries(D1) -> UnivariateFormalPowerSeries(
--R            D1)
--R             from UnivariateFormalPowerSeries(D1) if D1 has RING
--R   [2] UnivariateTaylorSeriesCZero(D1,D2) -> 
--R            UnivariateTaylorSeriesCZero(D1,D2)
--R             from UnivariateTaylorSeriesCZero(D1,D2) if D1 has RING and
--R            D2: SYMBOL
--R
--RThere are 2 unexposed functions called revert :
--R   [1] Stream(D2) -> Stream(D2) from StreamTaylorSeriesOperations(D2)
--R             if D2 has RING
--R   [2] UnivariateTaylorSeries(D1,D2,D3) -> UnivariateTaylorSeries(D1,D2
--R            ,D3)
--R             from UnivariateTaylorSeries(D1,D2,D3)
--R             if D1 has RING and D2: SYMBOL and D3: D1
--R
--RExamples of revert from StreamTaylorSeriesOperations
--R
--R
--RExamples of revert from UnivariateFormalPowerSeries
--R
--R
--RExamples of revert from UnivariateTaylorSeries
--R
--R
--RExamples of revert from UnivariateTaylorSeriesCZero
--R
--E 2549

--S 2550 of 3320
)d op rewriteIdealWithHeadRemainder
--R 
--R
--RThere is one exposed function called rewriteIdealWithHeadRemainder :
--R   [1] (List(D5),D) -> List(D5) from D
--R             if D has PSETCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4) and 
--R            D2 has INTDOM
--R
--RExamples of rewriteIdealWithHeadRemainder from PolynomialSetCategory
--R
--E 2550

--S 2551 of 3320
)d op rewriteIdealWithQuasiMonicGenerators
--R 
--R
--RThere is one unexposed function called rewriteIdealWithQuasiMonicGenerators :
--R   [1] (List(D7),((D7,D7) -> Boolean),((D7,D7) -> D7)) -> List(D7)
--R             from PolynomialSetUtilitiesPackage(D4,D5,D6,D7)
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has INTDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R
--RExamples of rewriteIdealWithQuasiMonicGenerators from PolynomialSetUtilitiesPackage
--R
--E 2551

--S 2552 of 3320
)d op rewriteIdealWithRemainder
--R 
--R
--RThere is one exposed function called rewriteIdealWithRemainder :
--R   [1] (List(D5),D) -> List(D5) from D
--R             if D has PSETCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4) and 
--R            D2 has INTDOM
--R
--RExamples of rewriteIdealWithRemainder from PolynomialSetCategory
--R
--E 2552

--S 2553 of 3320
)d op rewriteSetByReducingWithParticularGenerators
--R 
--R
--RThere is one unexposed function called rewriteSetByReducingWithParticularGenerators :
--R   [1] (List(D8),(D8 -> Boolean),((D8,D8) -> Boolean),((D8,D8) -> D8))
--R             -> List(D8)
--R             from PolynomialSetUtilitiesPackage(D5,D6,D7,D8)
--R             if D8 has RPOLCAT(D5,D6,D7) and D5 has INTDOM and D6 has 
--R            OAMONS and D7 has ORDSET
--R
--RExamples of rewriteSetByReducingWithParticularGenerators from PolynomialSetUtilitiesPackage
--R
--E 2553

--S 2554 of 3320
)d op rewriteSetWithReduction
--R 
--R
--RThere is one exposed function called rewriteSetWithReduction :
--R   [1] (List(D7),D,((D7,D7) -> D7),((D7,D7) -> Boolean)) -> List(D7)
--R             from D
--R             if D has TSETCAT(D4,D5,D6,D7) and D4 has INTDOM and D5
--R             has OAMONS and D6 has ORDSET and D7 has RPOLCAT(D4,D5,D6)
--R            
--R
--RExamples of rewriteSetWithReduction from TriangularSetCategory
--R
--E 2554

--S 2555 of 3320
)d op RF2UTS
--R 
--R
--RThere is one unexposed function called RF2UTS :
--R   [1] Fraction(D4) -> D1 from UTSodetools(D3,D4,D5,D1)
--R             if D4 has UPOLYC(D3) and D3 has INTDOM and D3 has RING and
--R            D1 has UTSCAT(D3) and D5 has LODOCAT(D4)
--R
--RExamples of RF2UTS from UTSodetools
--R
--E 2555

--S 2556 of 3320
)d op rhs
--R 
--R
--RThere are 2 exposed functions called rhs :
--R   [1] Equation(D1) -> D1 from Equation(D1) if D1 has TYPE
--R   [2] RewriteRule(D2,D3,D1) -> D1 from RewriteRule(D2,D3,D1)
--R             if D2 has SETCAT and D1 has Join(FunctionSpace(D3),
--R            PatternMatchable(D2),ConvertibleTo(Pattern(D2))) and D3
--R             has Join(Ring,PatternMatchable(D2),OrderedSet,
--R            ConvertibleTo(Pattern(D2)))
--R
--RThere is one unexposed function called rhs :
--R   [1] SuchThat(D2,D1) -> D1 from SuchThat(D2,D1) if D1 has SETCAT and 
--R            D2 has SETCAT
--R
--RExamples of rhs from Equation
--R
--R
--RExamples of rhs from RewriteRule
--R
--R
--RExamples of rhs from SuchThat
--R
--E 2556

--S 2557 of 3320
)d op ricDsolve
--R 
--R
--RThere are 8 unexposed functions called ricDsolve :
--R   [1] (LinearOrdinaryDifferentialOperator1(Fraction(D5)),(D5 -> List(
--R            D4))) -> List(Fraction(D5))
--R             from RationalRicDE(D4,D5)
--R             if D4 has Join(Field,CharacteristicZero,RetractableTo(
--R            Integer),RetractableTo(Fraction(Integer))) and D5 has 
--R            UPOLYC(D4)
--R   [2] (LinearOrdinaryDifferentialOperator1(Fraction(D6)),(D6 -> List(
--R            D5)),(D6 -> Factored(D6))) -> List(Fraction(D6))
--R             from RationalRicDE(D5,D6)
--R             if D5 has Join(Field,CharacteristicZero,RetractableTo(
--R            Integer),RetractableTo(Fraction(Integer))) and D6 has 
--R            UPOLYC(D5)
--R   [3] (LinearOrdinaryDifferentialOperator2(D5,Fraction(D5)),(D5 -> 
--R            List(D4))) -> List(Fraction(D5))
--R             from RationalRicDE(D4,D5)
--R             if D4 has Join(Field,CharacteristicZero,RetractableTo(
--R            Integer),RetractableTo(Fraction(Integer))) and D5 has 
--R            UPOLYC(D4)
--R   [4] (LinearOrdinaryDifferentialOperator2(D6,Fraction(D6)),(D6 -> 
--R            List(D5)),(D6 -> Factored(D6))) -> List(Fraction(D6))
--R             from RationalRicDE(D5,D6)
--R             if D5 has Join(Field,CharacteristicZero,RetractableTo(
--R            Integer),RetractableTo(Fraction(Integer))) and D6 has 
--R            UPOLYC(D5)
--R   [5] LinearOrdinaryDifferentialOperator1(Fraction(D4)) -> List(
--R            Fraction(D4))
--R             from RationalRicDE(D3,D4)
--R             if D4 has UPOLYC(D3) and D3 has ACF and D3 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer),RetractableTo(
--R            Fraction(Integer)))
--R   [6] (LinearOrdinaryDifferentialOperator1(Fraction(D5)),(D5 -> 
--R            Factored(D5))) -> List(Fraction(D5))
--R             from RationalRicDE(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has ACF and D4 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer),RetractableTo(
--R            Fraction(Integer)))
--R   [7] LinearOrdinaryDifferentialOperator2(D4,Fraction(D4)) -> List(
--R            Fraction(D4))
--R             from RationalRicDE(D3,D4)
--R             if D4 has UPOLYC(D3) and D3 has ACF and D3 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer),RetractableTo(
--R            Fraction(Integer)))
--R   [8] (LinearOrdinaryDifferentialOperator2(D5,Fraction(D5)),(D5 -> 
--R            Factored(D5))) -> List(Fraction(D5))
--R             from RationalRicDE(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has ACF and D4 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer),RetractableTo(
--R            Fraction(Integer)))
--R
--RExamples of ricDsolve from RationalRicDE
--R
--E 2557

--S 2558 of 3320
)d op ridHack1
--R 
--R
--RThere is one unexposed function called ridHack1 :
--R   [1] (Integer,Integer,Integer,Integer) -> Integer
--R             from RandomIntegerDistributions
--R
--RExamples of ridHack1 from RandomIntegerDistributions
--R
--E 2558

--S 2559 of 3320
)d op right
--R 
--R
--RThere are 2 exposed functions called right :
--R   [1] D -> D from D if D has BRAGG(D1) and D1 has TYPE
--R   [2] RightOpenIntervalRootCharacterization(D1,D2) -> D1
--R             from RightOpenIntervalRootCharacterization(D1,D2)
--R             if D1 has Join(OrderedRing,Field) and D2 has UPOLYC(D1)
--R         
--R
--RThere are 4 unexposed functions called right :
--R   [1] LyndonWord(D1) -> LyndonWord(D1) from LyndonWord(D1) if D1 has 
--R            ORDSET
--R   [2] Magma(D1) -> Magma(D1) from Magma(D1) if D1 has ORDSET
--R   [3] OutputForm -> OutputForm from OutputForm
--R   [4] (OutputForm,Integer) -> OutputForm from OutputForm
--R
--RExamples of right from BinaryRecursiveAggregate
--R
--R
--RExamples of right from LyndonWord
--R
--R
--RExamples of right from Magma
--R
--R
--RExamples of right from OutputForm
--R
--R
--RExamples of right from RightOpenIntervalRootCharacterization
--R
--E 2559

--S 2560 of 3320
)d op rightAlternative?
--R 
--R
--RThere is one exposed function called rightAlternative? :
--R   [1]  -> Boolean from D if D has FINAALG(D2) and D2 has COMRING
--R
--RThere is one unexposed function called rightAlternative? :
--R   [1]  -> Boolean from FiniteRankNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FINAALG(D3)
--R
--RExamples of rightAlternative? from FiniteRankNonAssociativeAlgebra&
--R
--R
--RExamples of rightAlternative? from FiniteRankNonAssociativeAlgebra
--R
--E 2560

--S 2561 of 3320
)d op rightCharacteristicPolynomial
--R 
--R
--RThere is one exposed function called rightCharacteristicPolynomial :
--R   [1] D -> SparseUnivariatePolynomial(D2) from D
--R             if D has FINAALG(D2) and D2 has COMRING
--R
--RExamples of rightCharacteristicPolynomial from FiniteRankNonAssociativeAlgebra
--R
--E 2561

--S 2562 of 3320
)d op rightDiscriminant
--R 
--R
--RThere are 2 exposed functions called rightDiscriminant :
--R   [1] Vector(D) -> D1 from D if D has FINAALG(D1) and D1 has COMRING
--R         
--R   [2]  -> D1 from D if D has FRNAALG(D1) and D1 has COMRING
--R
--RThere is one unexposed function called rightDiscriminant :
--R   [1]  -> D1 from FramedNonAssociativeAlgebra&(D2,D1)
--R             if D1 has COMRING and D2 has FRNAALG(D1)
--R
--RExamples of rightDiscriminant from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of rightDiscriminant from FramedNonAssociativeAlgebra&
--R
--R
--RExamples of rightDiscriminant from FramedNonAssociativeAlgebra
--R
--E 2562

--S 2563 of 3320
)d op rightDivide
--R 
--R
--RThere is one exposed function called rightDivide :
--R   [1] (D,D) -> Record(quotient: D,remainder: D) from D
--R             if D2 has FIELD and D2 has RING and D has OREPCAT(D2)
--R
--RThere is one unexposed function called rightDivide :
--R   [1] (D2,D2,Automorphism(D4)) -> Record(quotient: D2,remainder: D2)
--R             from UnivariateSkewPolynomialCategoryOps(D4,D2)
--R             if D4 has FIELD and D4 has RING and D2 has OREPCAT(D4)
--R
--RExamples of rightDivide from UnivariateSkewPolynomialCategory
--R
--R
--RExamples of rightDivide from UnivariateSkewPolynomialCategoryOps
--R
--E 2563

--S 2564 of 3320
)d op rightExactQuotient
--R 
--R
--RThere is one exposed function called rightExactQuotient :
--R   [1] (D,D) -> Union(D,"failed") from D
--R             if D has OREPCAT(D1) and D1 has RING and D1 has FIELD
--R
--RExamples of rightExactQuotient from UnivariateSkewPolynomialCategory
--R
--E 2564

--S 2565 of 3320
)d op rightExtendedGcd
--R 
--R
--RThere is one exposed function called rightExtendedGcd :
--R   [1] (D,D) -> Record(coef1: D,coef2: D,generator: D) from D
--R             if D2 has FIELD and D2 has RING and D has OREPCAT(D2)
--R
--RExamples of rightExtendedGcd from UnivariateSkewPolynomialCategory
--R
--E 2565

--S 2566 of 3320
)d op rightFactorCandidate
--R 
--R
--RThere is one exposed function called rightFactorCandidate :
--R   [1] (D1,NonNegativeInteger) -> D1 from PolynomialDecomposition(D1,D3
--R            )
--R             if D3 has FIELD and D1 has UPOLYC(D3)
--R
--RExamples of rightFactorCandidate from PolynomialDecomposition
--R
--E 2566

--S 2567 of 3320
)d op rightFactorIfCan
--R 
--R
--RThere is one unexposed function called rightFactorIfCan :
--R   [1] (D1,NonNegativeInteger,D3) -> Union(D1,"failed")
--R             from UnivariatePolynomialDecompositionPackage(D3,D1)
--R             if D3 has Join(IntegralDomain,CharacteristicZero) and D1
--R             has UPOLYC(D3)
--R
--RExamples of rightFactorIfCan from UnivariatePolynomialDecompositionPackage
--R
--E 2567

--S 2568 of 3320
)d op rightGcd
--R 
--R
--RThere is one exposed function called rightGcd :
--R   [1] (D,D) -> D from D if D has OREPCAT(D1) and D1 has RING and D1
--R             has FIELD
--R
--RExamples of rightGcd from UnivariateSkewPolynomialCategory
--R
--E 2568

--S 2569 of 3320
)d op rightLcm
--R 
--R
--RThere is one exposed function called rightLcm :
--R   [1] (D,D) -> D from D if D has OREPCAT(D1) and D1 has RING and D1
--R             has FIELD
--R
--RExamples of rightLcm from UnivariateSkewPolynomialCategory
--R
--E 2569

--S 2570 of 3320
)d op rightMinimalPolynomial
--R 
--R
--RThere is one exposed function called rightMinimalPolynomial :
--R   [1] D -> SparseUnivariatePolynomial(D2) from D
--R             if D has FINAALG(D2) and D2 has COMRING and D2 has INTDOM
--R            
--R
--RExamples of rightMinimalPolynomial from FiniteRankNonAssociativeAlgebra
--R
--E 2570

--S 2571 of 3320
)d op rightMult
--R 
--R
--RThere is one unexposed function called rightMult :
--R   [1] (ListMonoidOps(D1,D2,D3),D1) -> ListMonoidOps(D1,D2,D3)
--R             from ListMonoidOps(D1,D2,D3)
--R             if D1 has SETCAT and D2 has ABELMON and D3: D2
--R
--RExamples of rightMult from ListMonoidOps
--R
--E 2571

--S 2572 of 3320
)d op rightNorm
--R 
--R
--RThere is one exposed function called rightNorm :
--R   [1] D -> D1 from D if D has FINAALG(D1) and D1 has COMRING
--R
--RExamples of rightNorm from FiniteRankNonAssociativeAlgebra
--R
--E 2572

--S 2573 of 3320
)d op rightOne
--R 
--R
--RThere is one exposed function called rightOne :
--R   [1] Equation(D1) -> Union(Equation(D1),"failed") from Equation(D1)
--R             if D1 has MONOID and D1 has TYPE
--R
--RExamples of rightOne from Equation
--R
--E 2573

--S 2574 of 3320
)d op rightPower
--R 
--R
--RThere are 2 exposed functions called rightPower :
--R   [1] (D,PositiveInteger) -> D from D if D has MONAD
--R   [2] (D,NonNegativeInteger) -> D from D if D has MONADWU
--R
--RExamples of rightPower from Monad
--R
--R
--RExamples of rightPower from MonadWithUnit
--R
--E 2574

--S 2575 of 3320
)d op rightQuotient
--R 
--R
--RThere is one exposed function called rightQuotient :
--R   [1] (D,D) -> D from D if D has OREPCAT(D1) and D1 has RING and D1
--R             has FIELD
--R
--RExamples of rightQuotient from UnivariateSkewPolynomialCategory
--R
--E 2575

--S 2576 of 3320
)d op rightRank
--R 
--R
--RThere is one exposed function called rightRank :
--R   [1] D2 -> NonNegativeInteger from AlgebraPackage(D3,D2)
--R             if D3 has INTDOM and D2 has FRNAALG(D3)
--R
--RExamples of rightRank from AlgebraPackage
--R
--E 2576

--S 2577 of 3320
--R-----------------------)d op rightRankPolynomial (System Error)
--E 2577

--S 2578 of 3320
)d op rightRecip
--R 
--R
--RThere are 2 exposed functions called rightRecip :
--R   [1] D -> Union(D,"failed") from D
--R             if D has FINAALG(D1) and D1 has COMRING and D1 has INTDOM
--R            
--R   [2] D -> Union(D,"failed") from D if D has MONADWU
--R
--RExamples of rightRecip from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of rightRecip from MonadWithUnit
--R
--E 2578

--S 2579 of 3320
)d op rightRegularRepresentation
--R 
--R
--RThere are 2 exposed functions called rightRegularRepresentation :
--R   [1] (D,Vector(D)) -> Matrix(D3) from D if D has FINAALG(D3) and D3
--R             has COMRING
--R   [2] D -> Matrix(D2) from D if D has FRNAALG(D2) and D2 has COMRING
--R         
--R
--RExamples of rightRegularRepresentation from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of rightRegularRepresentation from FramedNonAssociativeAlgebra
--R
--E 2579

--S 2580 of 3320
)d op rightRemainder
--R 
--R
--RThere is one exposed function called rightRemainder :
--R   [1] (D,D) -> D from D if D has OREPCAT(D1) and D1 has RING and D1
--R             has FIELD
--R
--RExamples of rightRemainder from UnivariateSkewPolynomialCategory
--R
--E 2580

--S 2581 of 3320
)d op rightScalarTimes!
--R 
--R
--RThere is one unexposed function called rightScalarTimes! :
--R   [1] (Matrix(D2),Matrix(D2),D2) -> Matrix(D2)
--R             from StorageEfficientMatrixOperations(D2) if D2 has RING
--R         
--R
--RExamples of rightScalarTimes! from StorageEfficientMatrixOperations
--R
--E 2581

--S 2582 of 3320
)d op rightTrace
--R 
--R
--RThere is one exposed function called rightTrace :
--R   [1] D -> D1 from D if D has FINAALG(D1) and D1 has COMRING
--R
--RExamples of rightTrace from FiniteRankNonAssociativeAlgebra
--R
--E 2582

--S 2583 of 3320
)d op rightTraceMatrix
--R 
--R
--RThere are 2 exposed functions called rightTraceMatrix :
--R   [1] Vector(D) -> Matrix(D3) from D if D has FINAALG(D3) and D3 has 
--R            COMRING
--R   [2]  -> Matrix(D2) from D if D has FRNAALG(D2) and D2 has COMRING
--R         
--R
--RThere is one unexposed function called rightTraceMatrix :
--R   [1]  -> Matrix(D3) from FramedNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FRNAALG(D3)
--R
--RExamples of rightTraceMatrix from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of rightTraceMatrix from FramedNonAssociativeAlgebra&
--R
--R
--RExamples of rightTraceMatrix from FramedNonAssociativeAlgebra
--R
--E 2583

--S 2584 of 3320
)d op rightTrim
--R 
--R
--RThere are 2 exposed functions called rightTrim :
--R   [1] (D,CharacterClass) -> D from D if D has SRAGG
--R   [2] (D,Character) -> D from D if D has SRAGG
--R
--RExamples of rightTrim from StringAggregate
--R
--E 2584

--S 2585 of 3320
)d op rightUnit
--R 
--R
--RThere is one exposed function called rightUnit :
--R   [1]  -> Union(D,"failed") from D
--R             if D has FINAALG(D1) and D1 has INTDOM and D1 has COMRING
--R            
--R
--RExamples of rightUnit from FiniteRankNonAssociativeAlgebra
--R
--E 2585

--S 2586 of 3320
--R---------------------)d op rightUnits (System Error)
--E 2586

--S 2587 of 3320
)d op rightZero
--R 
--R
--RThere is one exposed function called rightZero :
--R   [1] Equation(D1) -> Equation(D1) from Equation(D1)
--R             if D1 has ABELGRP and D1 has TYPE
--R
--RExamples of rightZero from Equation
--R
--E 2587

--S 2588 of 3320
)d op rischDE
--R 
--R
--RThere is one unexposed function called rischDE :
--R   [1] (Integer,D3,D3,Symbol,((D3,List(D3)) -> Union(Record(mainpart: 
--R            D3,limitedlogs: List(Record(coeff: D3,logand: D3))),"failed")),((
--R            D3,D3) -> Union(Record(ratpart: D3,coeff: D3),"failed"))) -> 
--R            Record(ans: D3,right: D3,sol?: Boolean)
--R             from ElementaryRischDE(D7,D3)
--R             if D3 has Join(TranscendentalFunctionCategory,
--R            AlgebraicallyClosedField,FunctionSpace(D7)) and D7 has Join
--R            (GcdDomain,OrderedSet,CharacteristicZero,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer))
--R
--RExamples of rischDE from ElementaryRischDE
--R
--E 2588

--S 2589 of 3320
)d op rischDEsys
--R 
--R
--RThere is one unexposed function called rischDEsys :
--R   [1] (Integer,D3,D3,D3,Symbol,((D3,List(D3)) -> Union(Record(mainpart
--R            : D3,limitedlogs: List(Record(coeff: D3,logand: D3))),"failed")),
--R            ((D3,D3) -> Union(Record(ratpart: D3,coeff: D3),"failed"))) -> 
--R            Union(List(D3),"failed")
--R             from ElementaryRischDESystem(D7,D3)
--R             if D3 has Join(TranscendentalFunctionCategory,
--R            AlgebraicallyClosedField,FunctionSpace(D7)) and D7 has Join
--R            (GcdDomain,OrderedSet,CharacteristicZero,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer))
--R
--RExamples of rischDEsys from ElementaryRischDESystem
--R
--E 2589

--S 2590 of 3320
)d op rischNormalize
--R 
--R
--RThere is one exposed function called rischNormalize :
--R   [1] (D2,Symbol) -> Record(func: D2,kers: List(Kernel(D2)),vals: List
--R            (D2))
--R             from ElementaryFunctionStructurePackage(D4,D2)
--R             if D4 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer)) and D2 has Join
--R            (AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D4))
--R
--RExamples of rischNormalize from ElementaryFunctionStructurePackage
--R
--E 2590

--S 2591 of 3320
)d op RittWuCompare
--R 
--R
--RThere is one exposed function called RittWuCompare :
--R   [1] (D,D) -> Union(Boolean,"failed") from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RExamples of RittWuCompare from RecursivePolynomialCategory
--R
--E 2591

--S 2592 of 3320
)d op rk4
--R 
--R
--RThere are 2 exposed functions called rk4 :
--R   [1] (Vector(Float),Integer,Float,Float,((Vector(Float),Vector(Float)
--R            ,Float) -> Void)) -> Void
--R             from NumericalOrdinaryDifferentialEquations
--R   [2] (Vector(Float),Integer,Float,Float,((Vector(Float),Vector(Float)
--R            ,Float) -> Void),Vector(Float),Vector(Float),Vector(Float),Vector
--R            (Float)) -> Void
--R             from NumericalOrdinaryDifferentialEquations
--R
--RExamples of rk4 from NumericalOrdinaryDifferentialEquations
--R
--E 2592

--S 2593 of 3320
)d op rk4a
--R 
--R
--RThere is one exposed function called rk4a :
--R   [1] (Vector(Float),Integer,Float,Float,Float,Float,Integer,((Vector(
--R            Float),Vector(Float),Float) -> Void)) -> Void
--R             from NumericalOrdinaryDifferentialEquations
--R
--RExamples of rk4a from NumericalOrdinaryDifferentialEquations
--R
--E 2593

--S 2594 of 3320
)d op rk4f
--R 
--R
--RThere is one exposed function called rk4f :
--R   [1] (Vector(Float),Integer,Float,Float,Integer,((Vector(Float),
--R            Vector(Float),Float) -> Void)) -> Void
--R             from NumericalOrdinaryDifferentialEquations
--R
--RExamples of rk4f from NumericalOrdinaryDifferentialEquations
--R
--E 2594

--S 2595 of 3320
)d op rk4qc
--R 
--R
--RThere are 2 exposed functions called rk4qc :
--R   [1] (Vector(Float),Integer,Float,Record(try: Float,did: Float,next: 
--R            Float),Float,Vector(Float),((Vector(Float),Vector(Float),Float)
--R             -> Void)) -> Void
--R             from NumericalOrdinaryDifferentialEquations
--R   [2] (Vector(Float),Integer,Float,Record(try: Float,did: Float,next: 
--R            Float),Float,Vector(Float),((Vector(Float),Vector(Float),Float)
--R             -> Void),Vector(Float),Vector(Float),Vector(Float),Vector(Float)
--R            ,Vector(Float),Vector(Float),Vector(Float)) -> Void
--R             from NumericalOrdinaryDifferentialEquations
--R
--RExamples of rk4qc from NumericalOrdinaryDifferentialEquations
--R
--E 2595

--S 2596 of 3320
)d op roman
--R 
--R
--RThere are 2 exposed functions called roman :
--R   [1] Integer -> RomanNumeral from RomanNumeral
--R   [2] Symbol -> RomanNumeral from RomanNumeral
--R
--RExamples of roman from RomanNumeral
--R
--E 2596

--S 2597 of 3320
)d op romberg
--R 
--R
--RThere is one exposed function called romberg :
--R   [1] ((Float -> Float),Float,Float,Float,Float,Integer,Integer) -> 
--R            Record(value: Float,error: Float,totalpts: Integer,success: 
--R            Boolean)
--R             from NumericalQuadrature
--R
--RExamples of romberg from NumericalQuadrature
--R
--E 2597

--S 2598 of 3320
)d op rombergo
--R 
--R
--RThere is one exposed function called rombergo :
--R   [1] ((Float -> Float),Float,Float,Float,Float,Integer,Integer) -> 
--R            Record(value: Float,error: Float,totalpts: Integer,success: 
--R            Boolean)
--R             from NumericalQuadrature
--R
--RExamples of rombergo from NumericalQuadrature
--R
--E 2598

--S 2599 of 3320
)d op root
--R 
--R
--RThere is one exposed function called root :
--R   [1] (SparseUnivariatePolynomial(Integer),Integer) -> D from D if D
--R             has PADICCT(D3)
--R
--RThere are 2 unexposed functions called root :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [2] OutputForm -> OutputForm from OutputForm
--R
--RExamples of root from OutputForm
--R
--R
--RExamples of root from PAdicIntegerCategory
--R
--E 2599

--S 2600 of 3320
)d op root?
--R 
--R
--RThere is one unexposed function called root? :
--R   [1] SubSpace(D2,D3) -> Boolean from SubSpace(D2,D3) if D2: PI and D3
--R             has RING
--R
--RExamples of root? from SubSpace
--R
--E 2600

--S 2601 of 3320
)d op rootBound
--R 
--R
--RThere is one unexposed function called rootBound :
--R   [1] D2 -> Integer from GaloisGroupFactorizationUtilities(D3,D2,D4)
--R             if D3 has RING and D2 has UPOLYC(D3) and D4 has Join(
--R            FloatingPointSystem,RetractableTo(D3),Field,
--R            TranscendentalFunctionCategory,ElementaryFunctionCategory)
--R            
--R
--RExamples of rootBound from GaloisGroupFactorizationUtilities
--R
--E 2601

--S 2602 of 3320
)d op rootKerSimp
--R 
--R
--RThere is one exposed function called rootKerSimp :
--R   [1] (BasicOperator,D1,NonNegativeInteger) -> D1
--R             from AlgebraicManipulations(D4,D1)
--R             if D4 has GCDDOM and D4 has ORDSET and D4 has RETRACT(INT)
--R            and D4 has INTDOM and D1 has FS(D4) and D1 has Join(Field,
--R            ExpressionSpace)with
--R               numer : % -> SparseMultivariatePolynomial(D4,Kernel(%)
--R               )
--R               denom : % -> SparseMultivariatePolynomial(D4,Kernel(%)
--R               )
--R               coerce : SparseMultivariatePolynomial(D4,Kernel(%)) -> 
--R               %
--R
--RExamples of rootKerSimp from AlgebraicManipulations
--R
--E 2602

--S 2603 of 3320
)d op rootNormalize
--R 
--R
--RThere is one exposed function called rootNormalize :
--R   [1] (D1,Kernel(D1)) -> D1 from ElementaryFunctionStructurePackage(D3
--R            ,D1)
--R             if D1 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D3)) and D3
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R
--RExamples of rootNormalize from ElementaryFunctionStructurePackage
--R
--E 2603

--S 2604 of 3320
)d op rootOf
--R 
--R
--RThere are 8 exposed functions called rootOf :
--R   [1] (SparseUnivariatePolynomial(D),Symbol) -> D from D if D has ACF
--R            
--R   [2] SparseUnivariatePolynomial(D) -> D from D if D has ACF
--R   [3] Polynomial(D) -> D from D if D has ACF
--R   [4] (D,Symbol) -> D from D
--R             if D has ACFS(D2) and D2 has Join(OrderedSet,
--R            IntegralDomain)
--R   [5] D -> D from D if D has ACFS(D1) and D1 has Join(OrderedSet,
--R            IntegralDomain)
--R   [6] (SparseUnivariatePolynomial(D),PositiveInteger) -> Union(D,
--R            "failed")
--R             from D if D has RCFIELD
--R   [7] (SparseUnivariatePolynomial(D),PositiveInteger,OutputForm) -> 
--R            Union(D,"failed")
--R             from D if D has RCFIELD
--R   [8] (D1,PositiveInteger) -> Union(D,"failed") from D
--R             if D3 has Join(OrderedRing,Field) and D has RRCC(D3,D1) 
--R            and D1 has UPOLYC(D3)
--R
--RThere is one unexposed function called rootOf :
--R   [1] (SparseUnivariatePolynomial(D1),Symbol) -> D1
--R             from AlgebraicFunction(D4,D1)
--R             if D1 has FS(D4) and D4 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of rootOf from AlgebraicallyClosedField
--R
--Ra:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13 
--RrootOf(a,x)
--R
--Ra:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13 
--RrootOf(a)
--R
--Ra:Polynomial(Integer):=-3*x^3+2*x+13 
--RrootOf(a)
--R
--R
--RExamples of rootOf from AlgebraicallyClosedFunctionSpace
--R
--R
--RExamples of rootOf from AlgebraicFunction
--R
--R
--RExamples of rootOf from RealClosedField
--R
--R
--RExamples of rootOf from RealRootCharacterizationCategory
--R
--E 2604

--S 2605 of 3320
)d op rootOfIrreduciblePoly
--R 
--R
--RThere is one exposed function called rootOfIrreduciblePoly :
--R   [1] SparseUnivariatePolynomial(D3) -> D1
--R             from FiniteFieldPolynomialPackage2(D1,D3)
--R             if D3 has FFIELDC and D1 has FieldOfPrimeCharacteristic
--R            with
--R               coerce : D3 -> D1
--R               lookup : D1 -> PositiveInteger
--R               basis : PositiveInteger -> Vector(D1)
--R               Frobenius : D1 -> D1
--R
--RExamples of rootOfIrreduciblePoly from FiniteFieldPolynomialPackage2
--R
--E 2605

--S 2606 of 3320
)d op rootPoly
--R 
--R
--RThere is one unexposed function called rootPoly :
--R   [1] (Fraction(D5),NonNegativeInteger) -> Record(exponent: 
--R            NonNegativeInteger,coef: Fraction(D5),radicand: D5)
--R             from ChangeOfVariable(D4,D5,D6)
--R             if D4 has UFD and D5 has UPOLYC(D4) and D6 has UPOLYC(FRAC
--R            (D5))
--R
--RExamples of rootPoly from ChangeOfVariable
--R
--E 2606

--S 2607 of 3320
)d op rootPower
--R 
--R
--RThere is one exposed function called rootPower :
--R   [1] D1 -> D1 from AlgebraicManipulations(D2,D1)
--R             if D2 has GCDDOM and D2 has ORDSET and D2 has RETRACT(INT)
--R            and D2 has INTDOM and D1 has FS(D2) and D1 has Join(Field,
--R            ExpressionSpace)with
--R               numer : % -> SparseMultivariatePolynomial(D2,Kernel(%)
--R               )
--R               denom : % -> SparseMultivariatePolynomial(D2,Kernel(%)
--R               )
--R               coerce : SparseMultivariatePolynomial(D2,Kernel(%)) -> 
--R               %
--R
--RExamples of rootPower from AlgebraicManipulations
--R
--E 2607

--S 2608 of 3320
)d op rootProduct
--R 
--R
--RThere is one exposed function called rootProduct :
--R   [1] D1 -> D1 from AlgebraicManipulations(D2,D1)
--R             if D2 has GCDDOM and D2 has ORDSET and D2 has RETRACT(INT)
--R            and D2 has INTDOM and D1 has FS(D2) and D1 has Join(Field,
--R            ExpressionSpace)with
--R               numer : % -> SparseMultivariatePolynomial(D2,Kernel(%)
--R               )
--R               denom : % -> SparseMultivariatePolynomial(D2,Kernel(%)
--R               )
--R               coerce : SparseMultivariatePolynomial(D2,Kernel(%)) -> 
--R               %
--R
--RExamples of rootProduct from AlgebraicManipulations
--R
--E 2608

--S 2609 of 3320
)d op rootRadius
--R 
--R
--RThere are 2 unexposed functions called rootRadius :
--R   [1] (D2,D1) -> D1 from ComplexRootFindingPackage(D1,D2)
--R             if D1 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D1))
--R   [2] D2 -> D1 from ComplexRootFindingPackage(D1,D2)
--R             if D1 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D1))
--R
--RExamples of rootRadius from ComplexRootFindingPackage
--R
--E 2609

--S 2610 of 3320
)d op rootSimp
--R 
--R
--RThere is one exposed function called rootSimp :
--R   [1] D1 -> D1 from AlgebraicManipulations(D2,D1)
--R             if D2 has GCDDOM and D2 has ORDSET and D2 has RETRACT(INT)
--R            and D2 has INTDOM and D1 has FS(D2) and D1 has Join(Field,
--R            ExpressionSpace)with
--R               numer : % -> SparseMultivariatePolynomial(D2,Kernel(%)
--R               )
--R               denom : % -> SparseMultivariatePolynomial(D2,Kernel(%)
--R               )
--R               coerce : SparseMultivariatePolynomial(D2,Kernel(%)) -> 
--R               %
--R
--RExamples of rootSimp from AlgebraicManipulations
--R
--E 2610

--S 2611 of 3320
)d op rootsOf
--R 
--R
--RThere are 5 exposed functions called rootsOf :
--R   [1] (SparseUnivariatePolynomial(D),Symbol) -> List(D) from D if D
--R             has ACF
--R   [2] SparseUnivariatePolynomial(D) -> List(D) from D if D has ACF
--R   [3] Polynomial(D) -> List(D) from D if D has ACF
--R   [4] (D,Symbol) -> List(D) from D
--R             if D3 has Join(OrderedSet,IntegralDomain) and D has ACFS(
--R            D3)
--R   [5] D -> List(D) from D
--R             if D2 has Join(OrderedSet,IntegralDomain) and D has ACFS(
--R            D2)
--R
--RExamples of rootsOf from AlgebraicallyClosedField
--R
--Ra:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13 
--RrootsOf(a,x)
--R
--Ra:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13 
--RrootsOf(a)
--R
--Ra:Polynomial(Integer):=-3*x^3+2*x+13 
--RrootsOf(a)
--R
--R
--RExamples of rootsOf from AlgebraicallyClosedFunctionSpace
--R
--E 2611

--S 2612 of 3320
)d op rootSplit
--R 
--R
--RThere is one exposed function called rootSplit :
--R   [1] D1 -> D1 from AlgebraicManipulations(D2,D1)
--R             if D2 has INTDOM and D1 has Join(Field,ExpressionSpace)
--R            with
--R               numer : % -> SparseMultivariatePolynomial(D2,Kernel(%)
--R               )
--R               denom : % -> SparseMultivariatePolynomial(D2,Kernel(%)
--R               )
--R               coerce : SparseMultivariatePolynomial(D2,Kernel(%)) -> 
--R               %
--R
--RExamples of rootSplit from AlgebraicManipulations
--R
--E 2612

--S 2613 of 3320
)d op rotate
--R 
--R
--RThere are 2 exposed functions called rotate :
--R   [1] (ThreeDimensionalViewport,Integer,Integer) -> Void
--R             from ThreeDimensionalViewport
--R   [2] (ThreeDimensionalViewport,Float,Float) -> Void
--R             from ThreeDimensionalViewport
--R
--RExamples of rotate from ThreeDimensionalViewport
--R
--E 2613

--S 2614 of 3320
)d op rotate!
--R 
--R
--RThere are 3 exposed functions called rotate! :
--R   [1] Dequeue(D1) -> Dequeue(D1) from Dequeue(D1) if D1 has SETCAT
--R   [2] D -> D from D if D has QUAGG(D1) and D1 has TYPE
--R   [3] Queue(D1) -> Queue(D1) from Queue(D1) if D1 has SETCAT
--R
--RExamples of rotate! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rrotate! a
--R
--R
--RExamples of rotate! from QueueAggregate
--R
--R
--RExamples of rotate! from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rrotate! a
--R
--E 2614

--S 2615 of 3320 done
)d op rotatex
--R 
--R
--RThere is one exposed function called rotatex :
--R   [1] D1 -> DenavitHartenbergMatrix(D1) from DenavitHartenbergMatrix(
--R            D1)
--R             if D1 has Join(Field,TranscendentalFunctionCategory)
--R
--RExamples of rotatex from DenavitHartenbergMatrix
--R
--Rrotatex(30)
--R
--E 2615

--S 2616 of 3320 done
)d op rotatey
--R 
--R
--RThere is one exposed function called rotatey :
--R   [1] D1 -> DenavitHartenbergMatrix(D1) from DenavitHartenbergMatrix(
--R            D1)
--R             if D1 has Join(Field,TranscendentalFunctionCategory)
--R
--RExamples of rotatey from DenavitHartenbergMatrix
--R
--Rrotatey(30)
--R
--E 2616

--S 2617 of 3320 done
)d op rotatez
--R 
--R
--RThere is one exposed function called rotatez :
--R   [1] D1 -> DenavitHartenbergMatrix(D1) from DenavitHartenbergMatrix(
--R            D1)
--R             if D1 has Join(Field,TranscendentalFunctionCategory)
--R
--RExamples of rotatez from DenavitHartenbergMatrix
--R
--Rrotatez(30)
--R
--E 2617

--S 2618 of 3320
)d op roughBase?
--R 
--R
--RThere is one exposed function called roughBase? :
--R   [1] D -> Boolean from D
--R             if D has PSETCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4) and 
--R            D2 has INTDOM
--R
--RExamples of roughBase? from PolynomialSetCategory
--R
--E 2618

--S 2619 of 3320
)d op roughBasicSet
--R 
--R
--RThere is one unexposed function called roughBasicSet :
--R   [1] List(D6) -> Union(Record(bas: GeneralTriangularSet(D3,D4,D5,D6),
--R            top: List(D6)),"failed")
--R             from PolynomialSetUtilitiesPackage(D3,D4,D5,D6)
--R             if D3 has INTDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5)
--R
--RExamples of roughBasicSet from PolynomialSetUtilitiesPackage
--R
--E 2619

--S 2620 of 3320
)d op roughEqualIdeals?
--R 
--R
--RThere is one exposed function called roughEqualIdeals? :
--R   [1] (D,D) -> Boolean from D
--R             if D has PSETCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4) and 
--R            D2 has INTDOM
--R
--RExamples of roughEqualIdeals? from PolynomialSetCategory
--R
--E 2620

--S 2621 of 3320
)d op roughSubIdeal?
--R 
--R
--RThere is one exposed function called roughSubIdeal? :
--R   [1] (D,D) -> Boolean from D
--R             if D has PSETCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4) and 
--R            D2 has INTDOM
--R
--RExamples of roughSubIdeal? from PolynomialSetCategory
--R
--E 2621

--S 2622 of 3320
)d op roughUnitIdeal?
--R 
--R
--RThere is one exposed function called roughUnitIdeal? :
--R   [1] D -> Boolean from D
--R             if D has PSETCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4) and 
--R            D2 has INTDOM
--R
--RExamples of roughUnitIdeal? from PolynomialSetCategory
--R
--E 2622

--S 2623 of 3320
)d op round
--R 
--R
--RThere is one exposed function called round :
--R   [1] D -> D from D if D has RNS
--R
--RExamples of round from RealNumberSystem
--R
--E 2623

--S 2624 of 3320
)d op routines
--R 
--R
--RThere is one exposed function called routines :
--R   [1]  -> RoutinesTable from RoutinesTable
--R
--RExamples of routines from RoutinesTable
--R
--E 2624

--S 2625 of 3320
)d op row
--R 
--R
--RThere are 3 exposed functions called row :
--R   [1] (D,Integer) -> D1 from D
--R             if D has ARR2CAT(D3,D1,D4) and D3 has TYPE and D4 has 
--R            FLAGG(D3) and D1 has FLAGG(D3)
--R   [2] (D,Integer) -> D1 from D
--R             if D has RMATCAT(D3,D4,D5,D1,D6) and D5 has RING and D6
--R             has DIRPCAT(D3,D5) and D1 has DIRPCAT(D4,D5)
--R   [3] (SparseEchelonMatrix(D3,D4),Integer) -> Record(Indices: List(D3)
--R            ,Entries: List(D4))
--R             from SparseEchelonMatrix(D3,D4) if D3 has ORDSET and D4
--R             has RING
--R
--RExamples of row from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,10) 
--Rrow(arr,1)
--R
--R
--RExamples of row from RectangularMatrixCategory
--R
--R
--RExamples of row from SparseEchelonMatrix
--R
--E 2625

--S 2626 of 3320
)d op rowEch
--R 
--R
--RThere is one unexposed function called rowEch :
--R   [1] Matrix(D2) -> Matrix(D2) from ModularHermitianRowReduction(D2)
--R             if D2 has EUCDOM
--R
--RExamples of rowEch from ModularHermitianRowReduction
--R
--E 2626

--S 2627 of 3320
)d op rowEchelon
--R 
--R
--RThere are 4 exposed functions called rowEchelon :
--R   [1] D -> D from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1) and D1 has EUCDOM
--R   [2] D1 -> D1 from MatrixLinearAlgebraFunctions(D2,D3,D4,D1)
--R             if D2 has EUCDOM and D2 has COMRING and D3 has FLAGG(D2) 
--R            and D4 has FLAGG(D2) and D1 has MATCAT(D2,D3,D4)
--R   [3] D -> D from D
--R             if D has RMATCAT(D1,D2,D3,D4,D5) and D3 has RING and D4
--R             has DIRPCAT(D2,D3) and D5 has DIRPCAT(D1,D3) and D3 has 
--R            EUCDOM
--R   [4] SparseEchelonMatrix(D2,D3) -> Record(Ech: SparseEchelonMatrix(D2
--R            ,D3),Lt: Matrix(D3),Pivots: List(D3),Rank: NonNegativeInteger)
--R             from SparseEchelonMatrix(D2,D3) if D2 has ORDSET and D3
--R             has RING
--R
--RThere are 3 unexposed functions called rowEchelon :
--R   [1] D1 -> D1 from InnerMatrixLinearAlgebraFunctions(D2,D3,D4,D1)
--R             if D2 has FIELD and D3 has FLAGG(D2) and D4 has FLAGG(D2) 
--R            and D1 has MATCAT(D2,D3,D4)
--R   [2] D2 -> D1 from InnerMatrixQuotientFieldFunctions(D3,D4,D5,D2,D6,
--R            D7,D8,D1)
--R             if D3 has INTDOM and D4 has FLAGG(D3) and D5 has FLAGG(D3)
--R            and D6 has QFCAT(D3) and D1 has MATCAT(D6,D7,D8) and D2
--R             has MATCAT(D3,D4,D5) and D7 has FLAGG(D6) and D8 has FLAGG
--R            (D6)
--R   [3] (Matrix(D2),D2) -> Matrix(D2) from ModularHermitianRowReduction(
--R            D2)
--R             if D2 has EUCDOM
--R
--RExamples of rowEchelon from InnerMatrixLinearAlgebraFunctions
--R
--R
--RExamples of rowEchelon from InnerMatrixQuotientFieldFunctions
--R
--R
--RExamples of rowEchelon from MatrixCategory
--R
--RrowEchelon matrix [[j**i for i in 0..4] for j in 1..5]
--R
--R
--RExamples of rowEchelon from MatrixLinearAlgebraFunctions
--R
--R
--RExamples of rowEchelon from ModularHermitianRowReduction
--R
--R
--RExamples of rowEchelon from RectangularMatrixCategory
--R
--R
--RExamples of rowEchelon from SparseEchelonMatrix
--R
--E 2627

--S 2628 of 3320
)d op rowEchelonLocal
--R 
--R
--RThere is one unexposed function called rowEchelonLocal :
--R   [1] (Matrix(D2),D2,D2) -> Matrix(D2) from 
--R            ModularHermitianRowReduction(D2)
--R             if D2 has EUCDOM
--R
--RExamples of rowEchelonLocal from ModularHermitianRowReduction
--R
--E 2628

--S 2629 of 3320
)d op rowEchLocal
--R 
--R
--RThere is one unexposed function called rowEchLocal :
--R   [1] (Matrix(D2),D2) -> Matrix(D2) from ModularHermitianRowReduction(
--R            D2)
--R             if D2 has EUCDOM
--R
--RExamples of rowEchLocal from ModularHermitianRowReduction
--R
--E 2629

--S 2630 of 3320
)d op rowEchWoZeroLines
--R 
--R
--RThere is one exposed function called rowEchWoZeroLines :
--R   [1] Matrix(D2) -> Matrix(D2) from LinesOpPack(D2) if D2 has FIELD
--R         
--R
--RExamples of rowEchWoZeroLines from LinesOpPack
--R
--E 2630

--S 2631 of 3320
)d op rowEchWoZeroLinesWOVectorise
--R 
--R
--RThere is one exposed function called rowEchWoZeroLinesWOVectorise :
--R   [1] Matrix(D2) -> Matrix(D2) from LinesOpPack(D2) if D2 has FIELD
--R         
--R
--RExamples of rowEchWoZeroLinesWOVectorise from LinesOpPack
--R
--E 2631

--S 2632 of 3320 done
)d op rows
--R 
--R
--RThere are 2 exposed functions called rows :
--R   [1] (D1,List(PositiveInteger)) -> D1 from MatrixManipulation(D3,D4,
--R            D5,D1)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D1 has MATCAT(D3,D4,D5)
--R   [2] (D1,Segment(PositiveInteger)) -> D1 from MatrixManipulation(D3,
--R            D4,D5,D1)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D1 has MATCAT(D3,D4,D5)
--R
--RExamples of rows from MatrixManipulation
--R
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--Rrows(M, 2..3)
--R
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--Rrows(M, [1,2]) 
--Rrows(M, [3,2])
--R
--E 2632

--S 2633 of 3320
)d op rquo
--R 
--R
--RThere are 4 exposed functions called rquo :
--R   [1] (XRecursivePolynomial(D2,D3),D) -> XRecursivePolynomial(D2,D3)
--R             from D
--R             if D has FLALG(D2,D3) and D2 has ORDSET and D3 has COMRING
--R            
--R   [2] (D,D) -> D from D if D has XFALG(D1,D2) and D1 has ORDSET and D2
--R             has RING
--R   [3] (D,OrderedFreeMonoid(D2)) -> D from D
--R             if D has XFALG(D2,D3) and D2 has ORDSET and D3 has RING
--R         
--R   [4] (D,D1) -> D from D if D has XFALG(D1,D2) and D1 has ORDSET and 
--R            D2 has RING
--R
--RThere are 3 unexposed functions called rquo :
--R   [1] (FreeMonoid(D1),FreeMonoid(D1)) -> Union(FreeMonoid(D1),"failed"
--R            )
--R             from FreeMonoid(D1) if D1 has SETCAT
--R   [2] (OrderedFreeMonoid(D1),D1) -> Union(OrderedFreeMonoid(D1),
--R            "failed")
--R             from OrderedFreeMonoid(D1) if D1 has ORDSET
--R   [3] (OrderedFreeMonoid(D1),OrderedFreeMonoid(D1)) -> Union(
--R            OrderedFreeMonoid(D1),"failed")
--R             from OrderedFreeMonoid(D1) if D1 has ORDSET
--R
--RExamples of rquo from FreeLieAlgebra
--R
--R
--RExamples of rquo from FreeMonoid
--R
--R
--RExamples of rquo from OrderedFreeMonoid
--R
--Rm1:=(x*y)$OFMONOID(Symbol) 
--Rdiv(m1,y)
--R
--Rm1:=(q*y^3)$OFMONOID(Symbol) 
--Rm2:=(y^2)$OFMONOID(Symbol) 
--Rlquo(m1,m2)
--R
--R
--RExamples of rquo from XFreeAlgebra
--R
--E 2633

--S 2634 of 3320
)d op rroot
--R 
--R
--RThere is one unexposed function called rroot :
--R   [1] (D2,NonNegativeInteger) -> Record(exponent: NonNegativeInteger,
--R            coef: D7,radicand: D7)
--R             from PolynomialRoots(D4,D5,D2,D6,D7)
--R             if D4 has OAMONS and D5 has ORDSET and D2 has INTDOM and 
--R            D6 has POLYCAT(D2,D4,D5) and D7 has Fieldwith
--R               numer : % -> D6
--R               denom : % -> D6
--R               coerce : D6 -> %
--R
--RExamples of rroot from PolynomialRoots
--R
--E 2634

--S 2635 of 3320
)d op rspace
--R 
--R
--RThere is one unexposed function called rspace :
--R   [1] (Integer,Integer) -> OutputForm from OutputForm
--R
--RExamples of rspace from OutputForm
--R
--E 2635

--S 2636 of 3320 done
)d op rst
--R 
--R
--RThere is one exposed function called rst :
--R   [1] D -> D from D if D has LZSTAGG(D1) and D1 has TYPE
--R
--RExamples of rst from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--Rrst m
--R
--E 2636

--S 2637 of 3320
)d op rubiksGroup
--R 
--R
--RThere is one exposed function called rubiksGroup :
--R   [1]  -> PermutationGroup(Integer) from PermutationGroupExamples
--R
--RExamples of rubiksGroup from PermutationGroupExamples
--R
--E 2637

--S 2638 of 3320 done
)d op rule
--R 
--R
--RThere are 2 exposed functions called rule :
--R   [1] (D1,D1,List(Symbol)) -> RewriteRule(D3,D4,D1) from RewriteRule(
--R            D3,D4,D1)
--R             if D3 has SETCAT and D4 has Join(Ring,PatternMatchable(D3)
--R            ,OrderedSet,ConvertibleTo(Pattern(D3))) and D1 has Join(
--R            FunctionSpace(D4),PatternMatchable(D3),ConvertibleTo(
--R            Pattern(D3)))
--R   [2] (D1,D1) -> RewriteRule(D2,D3,D1) from RewriteRule(D2,D3,D1)
--R             if D2 has SETCAT and D3 has Join(Ring,PatternMatchable(D2)
--R            ,OrderedSet,ConvertibleTo(Pattern(D2))) and D1 has Join(
--R            FunctionSpace(D3),PatternMatchable(D2),ConvertibleTo(
--R            Pattern(D2)))
--R
--RExamples of rule from RewriteRule
--R
--Rlogrule := rule log(x) + log(y) == log(x*y) 
--Rf := log(sin(x)) + log(x) 
--Rlogrule f
--R
--E 2638

--S 2639 of 3320
)d op rules
--R 
--R
--RThere is one exposed function called rules :
--R   [1] Ruleset(D2,D3,D4) -> List(RewriteRule(D2,D3,D4)) from Ruleset(D2
--R            ,D3,D4)
--R             if D2 has SETCAT and D3 has Join(Ring,PatternMatchable(D2)
--R            ,OrderedSet,ConvertibleTo(Pattern(D2))) and D4 has Join(
--R            FunctionSpace(D3),PatternMatchable(D2),ConvertibleTo(
--R            Pattern(D2)))
--R
--RExamples of rules from Ruleset
--R
--E 2639

--S 2640 of 3320
)d op ruleset
--R 
--R
--RThere is one exposed function called ruleset :
--R   [1] List(RewriteRule(D2,D3,D4)) -> Ruleset(D2,D3,D4) from Ruleset(D2
--R            ,D3,D4)
--R             if D2 has SETCAT and D3 has Join(Ring,PatternMatchable(D2)
--R            ,OrderedSet,ConvertibleTo(Pattern(D2))) and D4 has Join(
--R            FunctionSpace(D3),PatternMatchable(D2),ConvertibleTo(
--R            Pattern(D2)))
--R
--RExamples of ruleset from Ruleset
--R
--E 2640

--S 2641 of 3320
)d op rur
--R 
--R
--RThere are 4 unexposed functions called rur :
--R   [1] (D2,Boolean) -> List(D2)
--R             from InternalRationalUnivariateRepresentationPackage(D4,D5
--R            ,D6,D7,D2)
--R             if D4 has Join(EuclideanDomain,CharacteristicZero) and D5
--R             has OAMONS and D6 has ORDSET and D7 has RPOLCAT(D4,D5,D6) 
--R            and D2 has SFRTCAT(D4,D5,D6,D7)
--R   [2] (List(Polynomial(D4)),Boolean) -> List(Record(complexRoots: 
--R            SparseUnivariatePolynomial(D4),coordinates: List(Polynomial(D4)))
--R            )
--R             from RationalUnivariateRepresentationPackage(D4,D5)
--R             if D4 has Join(EuclideanDomain,CharacteristicZero) and D5
--R            : LIST(SYMBOL)
--R   [3] List(Polynomial(D3)) -> List(Record(complexRoots: 
--R            SparseUnivariatePolynomial(D3),coordinates: List(Polynomial(D3)))
--R            )
--R             from RationalUnivariateRepresentationPackage(D3,D4)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D4
--R            : LIST(SYMBOL)
--R   [4] (List(Polynomial(D4)),Boolean,Boolean) -> List(Record(
--R            complexRoots: SparseUnivariatePolynomial(D4),coordinates: List(
--R            Polynomial(D4))))
--R             from RationalUnivariateRepresentationPackage(D4,D5)
--R             if D4 has Join(EuclideanDomain,CharacteristicZero) and D5
--R            : LIST(SYMBOL)
--R
--RExamples of rur from InternalRationalUnivariateRepresentationPackage
--R
--R
--RExamples of rur from RationalUnivariateRepresentationPackage
--R
--E 2641

--S 2642 of 3320
)d op s01eaf
--R 
--R
--RThere is one exposed function called s01eaf :
--R   [1] (Complex(DoubleFloat),Integer) -> Result from 
--R            NagSpecialFunctionsPackage
--R
--RExamples of s01eaf from NagSpecialFunctionsPackage
--R
--E 2642

--S 2643 of 3320
)d op s13aaf
--R 
--R
--RThere is one exposed function called s13aaf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s13aaf from NagSpecialFunctionsPackage
--R
--E 2643

--S 2644 of 3320
)d op s13acf
--R 
--R
--RThere is one exposed function called s13acf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s13acf from NagSpecialFunctionsPackage
--R
--E 2644

--S 2645 of 3320
)d op s13adf
--R 
--R
--RThere is one exposed function called s13adf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s13adf from NagSpecialFunctionsPackage
--R
--E 2645

--S 2646 of 3320
)d op s14aaf
--R 
--R
--RThere is one exposed function called s14aaf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s14aaf from NagSpecialFunctionsPackage
--R
--E 2646

--S 2647 of 3320
)d op s14abf
--R 
--R
--RThere is one exposed function called s14abf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s14abf from NagSpecialFunctionsPackage
--R
--E 2647

--S 2648 of 3320
)d op s14baf
--R 
--R
--RThere is one exposed function called s14baf :
--R   [1] (DoubleFloat,DoubleFloat,DoubleFloat,Integer) -> Result
--R             from NagSpecialFunctionsPackage
--R
--RExamples of s14baf from NagSpecialFunctionsPackage
--R
--E 2648

--S 2649 of 3320
)d op s15adf
--R 
--R
--RThere is one exposed function called s15adf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s15adf from NagSpecialFunctionsPackage
--R
--E 2649

--S 2650 of 3320
)d op s15aef
--R 
--R
--RThere is one exposed function called s15aef :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s15aef from NagSpecialFunctionsPackage
--R
--E 2650

--S 2651 of 3320
)d op s17acf
--R 
--R
--RThere is one exposed function called s17acf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s17acf from NagSpecialFunctionsPackage
--R
--E 2651

--S 2652 of 3320
)d op s17adf
--R 
--R
--RThere is one exposed function called s17adf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s17adf from NagSpecialFunctionsPackage
--R
--E 2652

--S 2653 of 3320
)d op s17aef
--R 
--R
--RThere is one exposed function called s17aef :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s17aef from NagSpecialFunctionsPackage
--R
--E 2653

--S 2654 of 3320
)d op s17aff
--R 
--R
--RThere is one exposed function called s17aff :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s17aff from NagSpecialFunctionsPackage
--R
--E 2654

--S 2655 of 3320
)d op s17agf
--R 
--R
--RThere is one exposed function called s17agf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s17agf from NagSpecialFunctionsPackage
--R
--E 2655

--S 2656 of 3320
)d op s17ahf
--R 
--R
--RThere is one exposed function called s17ahf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s17ahf from NagSpecialFunctionsPackage
--R
--E 2656

--S 2657 of 3320
)d op s17ajf
--R 
--R
--RThere is one exposed function called s17ajf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s17ajf from NagSpecialFunctionsPackage
--R
--E 2657

--S 2658 of 3320
)d op s17akf
--R 
--R
--RThere is one exposed function called s17akf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s17akf from NagSpecialFunctionsPackage
--R
--E 2658

--S 2659 of 3320
)d op s17dcf
--R 
--R
--RThere is one exposed function called s17dcf :
--R   [1] (DoubleFloat,Complex(DoubleFloat),Integer,String,Integer) -> 
--R            Result
--R             from NagSpecialFunctionsPackage
--R
--RExamples of s17dcf from NagSpecialFunctionsPackage
--R
--E 2659

--S 2660 of 3320
)d op s17def
--R 
--R
--RThere is one exposed function called s17def :
--R   [1] (DoubleFloat,Complex(DoubleFloat),Integer,String,Integer) -> 
--R            Result
--R             from NagSpecialFunctionsPackage
--R
--RExamples of s17def from NagSpecialFunctionsPackage
--R
--E 2660

--S 2661 of 3320
)d op s17dgf
--R 
--R
--RThere is one exposed function called s17dgf :
--R   [1] (String,Complex(DoubleFloat),String,Integer) -> Result
--R             from NagSpecialFunctionsPackage
--R
--RExamples of s17dgf from NagSpecialFunctionsPackage
--R
--E 2661

--S 2662 of 3320
)d op s17dhf
--R 
--R
--RThere is one exposed function called s17dhf :
--R   [1] (String,Complex(DoubleFloat),String,Integer) -> Result
--R             from NagSpecialFunctionsPackage
--R
--RExamples of s17dhf from NagSpecialFunctionsPackage
--R
--E 2662

--S 2663 of 3320
)d op s17dlf
--R 
--R
--RThere is one exposed function called s17dlf :
--R   [1] (Integer,DoubleFloat,Complex(DoubleFloat),Integer,String,Integer
--R            ) -> Result
--R             from NagSpecialFunctionsPackage
--R
--RExamples of s17dlf from NagSpecialFunctionsPackage
--R
--E 2663

--S 2664 of 3320
)d op s18acf
--R 
--R
--RThere is one exposed function called s18acf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s18acf from NagSpecialFunctionsPackage
--R
--E 2664

--S 2665 of 3320
)d op s18adf
--R 
--R
--RThere is one exposed function called s18adf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s18adf from NagSpecialFunctionsPackage
--R
--E 2665

--S 2666 of 3320
)d op s18aef
--R 
--R
--RThere is one exposed function called s18aef :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s18aef from NagSpecialFunctionsPackage
--R
--E 2666

--S 2667 of 3320
)d op s18aff
--R 
--R
--RThere is one exposed function called s18aff :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s18aff from NagSpecialFunctionsPackage
--R
--E 2667

--S 2668 of 3320
)d op s18dcf
--R 
--R
--RThere is one exposed function called s18dcf :
--R   [1] (DoubleFloat,Complex(DoubleFloat),Integer,String,Integer) -> 
--R            Result
--R             from NagSpecialFunctionsPackage
--R
--RExamples of s18dcf from NagSpecialFunctionsPackage
--R
--E 2668

--S 2669 of 3320
)d op s18def
--R 
--R
--RThere is one exposed function called s18def :
--R   [1] (DoubleFloat,Complex(DoubleFloat),Integer,String,Integer) -> 
--R            Result
--R             from NagSpecialFunctionsPackage
--R
--RExamples of s18def from NagSpecialFunctionsPackage
--R
--E 2669

--S 2670 of 3320
)d op s19aaf
--R 
--R
--RThere is one exposed function called s19aaf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s19aaf from NagSpecialFunctionsPackage
--R
--E 2670

--S 2671 of 3320
)d op s19abf
--R 
--R
--RThere is one exposed function called s19abf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s19abf from NagSpecialFunctionsPackage
--R
--E 2671

--S 2672 of 3320
)d op s19acf
--R 
--R
--RThere is one exposed function called s19acf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s19acf from NagSpecialFunctionsPackage
--R
--E 2672

--S 2673 of 3320
)d op s19adf
--R 
--R
--RThere is one exposed function called s19adf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s19adf from NagSpecialFunctionsPackage
--R
--E 2673

--S 2674 of 3320
)d op s20acf
--R 
--R
--RThere is one exposed function called s20acf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s20acf from NagSpecialFunctionsPackage
--R
--E 2674

--S 2675 of 3320
)d op s20adf
--R 
--R
--RThere is one exposed function called s20adf :
--R   [1] (DoubleFloat,Integer) -> Result from NagSpecialFunctionsPackage
--R            
--R
--RExamples of s20adf from NagSpecialFunctionsPackage
--R
--E 2675

--S 2676 of 3320
)d op s21baf
--R 
--R
--RThere is one exposed function called s21baf :
--R   [1] (DoubleFloat,DoubleFloat,Integer) -> Result
--R             from NagSpecialFunctionsPackage
--R
--RExamples of s21baf from NagSpecialFunctionsPackage
--R
--E 2676

--S 2677 of 3320
)d op s21bbf
--R 
--R
--RThere is one exposed function called s21bbf :
--R   [1] (DoubleFloat,DoubleFloat,DoubleFloat,Integer) -> Result
--R             from NagSpecialFunctionsPackage
--R
--RExamples of s21bbf from NagSpecialFunctionsPackage
--R
--E 2677

--S 2678 of 3320
)d op s21bcf
--R 
--R
--RThere is one exposed function called s21bcf :
--R   [1] (DoubleFloat,DoubleFloat,DoubleFloat,Integer) -> Result
--R             from NagSpecialFunctionsPackage
--R
--RExamples of s21bcf from NagSpecialFunctionsPackage
--R
--E 2678

--S 2679 of 3320
)d op s21bdf
--R 
--R
--RThere is one exposed function called s21bdf :
--R   [1] (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,Integer) -> 
--R            Result
--R             from NagSpecialFunctionsPackage
--R
--RExamples of s21bdf from NagSpecialFunctionsPackage
--R
--E 2679

--S 2680 of 3320
)d op safeCeiling
--R 
--R
--RThere is one unexposed function called safeCeiling :
--R   [1] D2 -> Integer from GaloisGroupUtilities(D2) if D2 has FPS and D2
--R             has RING
--R
--RExamples of safeCeiling from GaloisGroupUtilities
--R
--E 2680

--S 2681 of 3320
)d op safeFloor
--R 
--R
--RThere is one unexposed function called safeFloor :
--R   [1] D2 -> Integer from GaloisGroupUtilities(D2) if D2 has FPS and D2
--R             has RING
--R
--RExamples of safeFloor from GaloisGroupUtilities
--R
--E 2681

--S 2682 of 3320
)d op safety
--R 
--R
--RThere is one exposed function called safety :
--R   [1] NonNegativeInteger -> GuessOption from GuessOption
--R
--RThere is one unexposed function called safety :
--R   [1] List(GuessOption) -> NonNegativeInteger from 
--R            GuessOptionFunctions0
--R
--RExamples of safety from GuessOptionFunctions0
--R
--R
--RExamples of safety from GuessOption
--R
--E 2682

--S 2683 of 3320
)d op safetyMargin
--R 
--R
--RThere are 2 unexposed functions called safetyMargin :
--R   [1] NonNegativeInteger -> NonNegativeInteger from 
--R            GaloisGroupUtilities(D2)
--R             if D2 has FPS and D2 has RING
--R   [2]  -> NonNegativeInteger from GaloisGroupUtilities(D2)
--R             if D2 has FPS and D2 has RING
--R
--RExamples of safetyMargin from GaloisGroupUtilities
--R
--E 2683

--S 2684 of 3320
)d op sample
--R 
--R
--RThere are 10 exposed functions called sample :
--R   [1]  -> D from D if D has ABELMON
--R   [2]  -> D from D if D has AGG
--R   [3]  -> ArrayStack(D1) from ArrayStack(D1) if D1 has SETCAT
--R   [4]  -> CartesianTensor(D1,D2,D3) from CartesianTensor(D1,D2,D3)
--R             if D1: INT and D2: NNI and D3 has COMRING
--R   [5]  -> Dequeue(D1) from Dequeue(D1) if D1 has SETCAT
--R   [6]  -> Heap(D1) from Heap(D1) if D1 has ORDSET
--R   [7]  -> D from D if D has MONOID
--R   [8]  -> Queue(D1) from Queue(D1) if D1 has SETCAT
--R   [9]  -> Stack(D1) from Stack(D1) if D1 has SETCAT
--R   [10]  -> Symbol from Symbol
--R
--RExamples of sample from AbelianMonoid
--R
--R
--RExamples of sample from Aggregate
--R
--R
--RExamples of sample from ArrayStack
--R
--Rsample()$ArrayStack(INT)
--R
--R
--RExamples of sample from CartesianTensor
--R
--R
--RExamples of sample from Dequeue
--R
--Rsample()$Dequeue(INT)
--R
--R
--RExamples of sample from Heap
--R
--Rsample()$Heap(INT)
--R
--R
--RExamples of sample from Monoid
--R
--R
--RExamples of sample from Queue
--R
--Rsample()$Queue(INT)
--R
--R
--RExamples of sample from Stack
--R
--Rsample()$Stack(INT)
--R
--R
--RExamples of sample from Symbol
--R
--Rsample()$Symbol
--R
--E 2684

--S 2685 of 3320 done
)d op sampleDotGraph
--R 
--R
--RThere is one exposed function called sampleDotGraph :
--R   [1]  -> List(String) from Graphviz
--R
--RExamples of sampleDotGraph from Graphviz
--R
--Rgraph:=sampleDotGraph()
--R
--E 2685

--S 2686 of 3320
)d op samplePoint
--R 
--R
--RThere are 2 exposed functions called samplePoint :
--R   [1] Cell(D2) -> List(D2) from Cell(D2) if D2 has RCFIELD
--R   [2] SimpleCell(D1,D2) -> D1 from SimpleCell(D1,D2)
--R             if D1 has RCFIELD and D2 has UPOLYC(D1)
--R
--RExamples of samplePoint from Cell
--R
--R
--RExamples of samplePoint from SimpleCell
--R
--E 2686

--S 2687 of 3320
)d op satisfy?
--R 
--R
--RThere are 3 unexposed functions called satisfy? :
--R   [1] (PatternMatchResult(D3,D4),Pattern(D3)) -> Union(Boolean,
--R            "failed")
--R             from PatternMatchResult(D3,D4) if D3 has SETCAT and D4
--R             has SETCAT
--R   [2] (D2,Pattern(D4)) -> Boolean from PatternFunctions1(D4,D2)
--R             if D4 has SETCAT and D2 has TYPE
--R   [3] (List(D5),Pattern(D4)) -> Boolean from PatternFunctions1(D4,D5)
--R             if D4 has SETCAT and D5 has TYPE
--R
--RExamples of satisfy? from PatternMatchResult
--R
--R
--RExamples of satisfy? from PatternFunctions1
--R
--E 2687

--S 2688 of 3320
)d op saturate
--R 
--R
--RThere are 2 exposed functions called saturate :
--R   [1] (PolynomialIdeals(D3,D4,D5,D1),D1,List(D5)) -> PolynomialIdeals(
--R            D3,D4,D5,D1)
--R             from PolynomialIdeals(D3,D4,D5,D1)
--R             if D5 has ORDSET and D3 has FIELD and D4 has OAMONS and D1
--R             has POLYCAT(D3,D4,D5)
--R   [2] (PolynomialIdeals(D2,D3,D4,D1),D1) -> PolynomialIdeals(D2,D3,D4,
--R            D1)
--R             from PolynomialIdeals(D2,D3,D4,D1)
--R             if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D1
--R             has POLYCAT(D2,D3,D4)
--R
--RExamples of saturate from PolynomialIdeals
--R
--E 2688

--S 2689 of 3320
)d op save
--R 
--R
--RThere is one exposed function called save :
--R   [1]  -> FortranCode from FortranCode
--R
--RExamples of save from FortranCode
--R
--E 2689

--S 2690 of 3320
)d op say
--R 
--R
--RThere are 2 exposed functions called say :
--R   [1] String -> Void from DisplayPackage
--R   [2] List(String) -> Void from DisplayPackage
--R
--RExamples of say from DisplayPackage
--R
--E 2690

--S 2691 of 3320
)d op sayLength
--R 
--R
--RThere are 2 exposed functions called sayLength :
--R   [1] String -> Integer from DisplayPackage
--R   [2] List(String) -> Integer from DisplayPackage
--R
--RExamples of sayLength from DisplayPackage
--R
--E 2691

--S 2692 of 3320
)d op sbt
--R 
--R
--RThere is one exposed function called sbt :
--R   [1] (D,D) -> D from D if D has LOCPOWC(D1) and D1 has FIELD
--R
--RExamples of sbt from LocalPowerSeriesCategory
--R
--E 2692

--S 2693 of 3320
)d op scalarMatrix
--R 
--R
--RThere are 2 exposed functions called scalarMatrix :
--R   [1] (NonNegativeInteger,D2) -> D from D
--R             if D2 has RING and D has MATCAT(D2,D3,D4) and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [2] D1 -> D from D
--R             if D1 has RING and D has SMATCAT(D2,D1,D3,D4) and D3 has 
--R            DIRPCAT(D2,D1) and D4 has DIRPCAT(D2,D1)
--R
--RExamples of scalarMatrix from MatrixCategory
--R
--Rz:Matrix(INT):=scalarMatrix(3,5)
--R
--R
--RExamples of scalarMatrix from SquareMatrixCategory
--R
--E 2693

--S 2694 of 3320
)d op scalarTypeOf
--R 
--R
--RThere is one exposed function called scalarTypeOf :
--R   [1] FortranType -> Union(fst: FortranScalarType,void: void) from 
--R            FortranType
--R
--RExamples of scalarTypeOf from FortranType
--R
--E 2694

--S 2695 of 3320
)d op scale
--R 
--R
--RThere is one exposed function called scale :
--R   [1] (D1,D1,D1) -> DenavitHartenbergMatrix(D1)
--R             from DenavitHartenbergMatrix(D1)
--R             if D1 has Join(Field,TranscendentalFunctionCategory)
--R
--RThere are 3 unexposed functions called scale :
--R   [1] (MoebiusTransform(D1),D1) -> MoebiusTransform(D1)
--R             from MoebiusTransform(D1) if D1 has FIELD
--R   [2] D1 -> MoebiusTransform(D1) from MoebiusTransform(D1) if D1 has 
--R            FIELD
--R   [3] (TwoDimensionalViewport,PositiveInteger,Float,Float) -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of scale from DenavitHartenbergMatrix
--R
--Rscale(0.5,0.5,0.5)
--R
--R
--RExamples of scale from MoebiusTransform
--R
--R
--RExamples of scale from TwoDimensionalViewport
--R
--E 2695

--S 2696 of 3320
)d op scaleRoots
--R 
--R
--RThere is one unexposed function called scaleRoots :
--R   [1] (D1,D2) -> D1 from GaloisGroupPolynomialUtilities(D2,D1)
--R             if D2 has RING and D1 has UPOLYC(D2)
--R
--RExamples of scaleRoots from GaloisGroupPolynomialUtilities
--R
--E 2696

--S 2697 of 3320
)d op scan
--R 
--R
--RThere are 8 exposed functions called scan :
--R   [1] (((D5,D4) -> D4),OneDimensionalArray(D5),D4) -> 
--R            OneDimensionalArray(D4)
--R             from OneDimensionalArrayFunctions2(D5,D4) if D5 has TYPE 
--R            and D4 has TYPE
--R   [2] (((D6,D4) -> D4),DirectProduct(D5,D6),D4) -> DirectProduct(D5,D4
--R            )
--R             from DirectProductFunctions2(D5,D6,D4)
--R             if D5: NNI and D6 has TYPE and D4 has TYPE
--R   [3] (((D5,D4) -> D4),D3,D4) -> D1
--R             from FiniteLinearAggregateFunctions2(D5,D3,D4,D1)
--R             if D5 has TYPE and D4 has TYPE and D1 has FLAGG(D4) and D3
--R             has FLAGG(D5)
--R   [4] (((D5,D4) -> D4),D3,D4) -> D1
--R             from FiniteSetAggregateFunctions2(D5,D3,D4,D1)
--R             if D5 has SETCAT and D4 has SETCAT and D1 has FSAGG(D4) 
--R            and D3 has FSAGG(D5)
--R   [5] (((D5,D4) -> D4),List(D5),D4) -> List(D4) from ListFunctions2(D5
--R            ,D4)
--R             if D5 has TYPE and D4 has TYPE
--R   [6] (((D5,D4) -> D4),PrimitiveArray(D5),D4) -> PrimitiveArray(D4)
--R             from PrimitiveArrayFunctions2(D5,D4) if D5 has TYPE and D4
--R             has TYPE
--R   [7] (D2,((D5,D2) -> D2),Stream(D5)) -> Stream(D2)
--R             from StreamFunctions2(D5,D2) if D5 has TYPE and D2 has 
--R            TYPE
--R   [8] (((D5,D4) -> D4),Vector(D5),D4) -> Vector(D4)
--R             from VectorFunctions2(D5,D4) if D5 has TYPE and D4 has 
--R            TYPE
--R
--RExamples of scan from OneDimensionalArrayFunctions2
--R
--RT1:=OneDimensionalArrayFunctions2(Integer,Integer) 
--Radder(a:Integer,b:Integer):Integer == a+b 
--Rscan(adder,[i for i in 1..10],0)$T1
--R
--R
--RExamples of scan from DirectProductFunctions2
--R
--R
--RExamples of scan from FiniteLinearAggregateFunctions2
--R
--R
--RExamples of scan from FiniteSetAggregateFunctions2
--R
--R
--RExamples of scan from ListFunctions2
--R
--R
--RExamples of scan from PrimitiveArrayFunctions2
--R
--RT1:=PrimitiveArrayFunctions2(Integer,Integer) 
--Radder(a:Integer,b:Integer):Integer == a+b 
--Rscan(adder,[i for i in 1..10],0)$T1
--R
--R
--RExamples of scan from StreamFunctions2
--R
--Rm:=[i for i in 1..]::Stream(Integer) 
--Rf(i:Integer,j:Integer):Integer==i+j 
--Rscan(1,f,m)
--R
--R
--RExamples of scan from VectorFunctions2
--R
--E 2697

--S 2698 of 3320
)d op ScanArabic
--R 
--R
--RThere is one unexposed function called ScanArabic :
--R   [1] String -> PositiveInteger from NumberFormats
--R
--RExamples of ScanArabic from NumberFormats
--R
--E 2698

--S 2699 of 3320
)d op ScanFloatIgnoreSpaces
--R 
--R
--RThere is one unexposed function called ScanFloatIgnoreSpaces :
--R   [1] String -> Float from NumberFormats
--R
--RExamples of ScanFloatIgnoreSpaces from NumberFormats
--R
--E 2699

--S 2700 of 3320
)d op ScanFloatIgnoreSpacesIfCan
--R 
--R
--RThere is one unexposed function called ScanFloatIgnoreSpacesIfCan :
--R   [1] String -> Union(Float,"failed") from NumberFormats
--R
--RExamples of ScanFloatIgnoreSpacesIfCan from NumberFormats
--R
--E 2700

--S 2701 of 3320
)d op scanOneDimSubspaces
--R 
--R
--RThere is one exposed function called scanOneDimSubspaces :
--R   [1] (List(Vector(D4)),Integer) -> Vector(D4) from 
--R            RepresentationPackage2(D4)
--R             if D4 has FIELD and D4 has FINITE and D4 has RING
--R
--RExamples of scanOneDimSubspaces from RepresentationPackage2
--R
--E 2701

--S 2702 of 3320
)d op ScanRoman
--R 
--R
--RThere is one unexposed function called ScanRoman :
--R   [1] String -> PositiveInteger from NumberFormats
--R
--RExamples of ScanRoman from NumberFormats
--R
--E 2702

--S 2703 of 3320
)d op schema
--R 
--R
--RThere is one unexposed function called schema :
--R   [1] (D2,D2) -> List(NonNegativeInteger) from PseudoRemainderSequence
--R            (D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of schema from PseudoRemainderSequence
--R
--E 2703

--S 2704 of 3320
)d op schwerpunkt
--R 
--R
--RThere is one unexposed function called schwerpunkt :
--R   [1] D2 -> Complex(D3) from ComplexRootFindingPackage(D3,D2)
--R             if D3 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D3))
--R
--RExamples of schwerpunkt from ComplexRootFindingPackage
--R
--E 2704

--S 2705 of 3320
)d op screenResolution
--R 
--R
--RThere are 2 exposed functions called screenResolution :
--R   [1]  -> Integer from GraphicsDefaults
--R   [2] Integer -> Integer from GraphicsDefaults
--R
--RThere is one unexposed function called screenResolution :
--R   [1]  -> Integer from Plot
--R
--RExamples of screenResolution from GraphicsDefaults
--R
--R
--RExamples of screenResolution from Plot
--R
--E 2705

--S 2706 of 3320
)d op screenResolution3D
--R 
--R
--RThere is one unexposed function called screenResolution3D :
--R   [1]  -> Integer from Plot3D
--R
--RExamples of screenResolution3D from Plot3D
--R
--E 2706

--S 2707 of 3320 done
)d op script 
--R 
--R
--RThere are 2 exposed functions called script :
--R   [1] (Symbol,Record(sub: List(OutputForm),sup: List(OutputForm),
--R            presup: List(OutputForm),presub: List(OutputForm),args: List(
--R            OutputForm))) -> Symbol
--R             from Symbol
--R   [2] (Symbol,List(List(OutputForm))) -> Symbol from Symbol
--R
--RExamples of script from Symbol
--R
--Rm:=script(Big,[[i,j],[k,1],[0,1],[2],[u,v,w]]) 
--Rn:=scripts m 
--Rscript(Little,n)
--R
--Rm:=script(Big,[[i,j],[k,1],[0,1],[2],[u,v,w]]) 
--Rscripts m
--R
--E 2707

--S 2708 of 3320 done
)d op scripted?
--R 
--R
--RThere is one exposed function called scripted? :
--R   [1] Symbol -> Boolean from Symbol
--R
--RExamples of scripted? from Symbol
--R
--RU:=subscript(u,[1,2]) 
--Rscripted? U 
--Rscripted? W
--R
--E 2708

--S 2709 of 3320
)d op scripts
--R 
--R
--RThere is one exposed function called scripts :
--R   [1] Symbol -> Record(sub: List(OutputForm),sup: List(OutputForm),
--R            presup: List(OutputForm),presub: List(OutputForm),args: List(
--R            OutputForm))
--R             from Symbol
--R
--RThere is one unexposed function called scripts :
--R   [1] (OutputForm,List(OutputForm)) -> OutputForm from OutputForm
--R
--RExamples of scripts from OutputForm
--R
--R
--RExamples of scripts from Symbol
--R
--Rm:=script(Big,[[i,j],[k,1],[0,1],[2],[u,v,w]]) 
--Rscripts m
--R
--E 2709

--S 2710 of 3320
)d op sdf2lst
--R 
--R
--RThere are 3 exposed functions called sdf2lst :
--R   [1] Stream(DoubleFloat) -> List(String) from d01AgentsPackage
--R   [2] Stream(DoubleFloat) -> List(String) from 
--R            ExpertSystemContinuityPackage
--R   [3] Stream(DoubleFloat) -> List(String) from 
--R            ExpertSystemToolsPackage
--R
--RExamples of sdf2lst from d01AgentsPackage
--R
--R
--RExamples of sdf2lst from ExpertSystemContinuityPackage
--R
--R
--RExamples of sdf2lst from ExpertSystemToolsPackage
--R
--E 2710

--S 2711 of 3320
)d op se2rfi
--R 
--R
--RThere is one unexposed function called se2rfi :
--R   [1] List(Symbol) -> List(Fraction(Polynomial(D3)))
--R             from ParametricLinearEquations(D3,D4,D5,D6)
--R             if D3 has Join(EuclideanDomain,CharacteristicZero) and D4
--R             has Join(OrderedSet,ConvertibleTo(Symbol)) and D5 has 
--R            OAMONS and D6 has POLYCAT(D3,D5,D4)
--R
--RExamples of se2rfi from ParametricLinearEquations
--R
--E 2711

--S 2712 of 3320
)d op search
--R 
--R
--RThere is one exposed function called search :
--R   [1] (D2,D) -> Union(D1,"failed") from D
--R             if D has KDAGG(D2,D1) and D2 has SETCAT and D1 has SETCAT
--R            
--R
--RExamples of search from KeyedDictionary
--R
--E 2712

--S 2713 of 3320
)d op sec
--R 
--R
--RThere is one exposed function called sec :
--R   [1] D -> D from D if D has TRIGCAT
--R
--RThere are 5 unexposed functions called sec :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of sec from ElementaryFunction
--R
--R
--RExamples of sec from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of sec from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of sec from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of sec from StreamTranscendentalFunctions
--R
--R
--RExamples of sec from TrigonometricFunctionCategory
--R
--E 2713

--S 2714 of 3320
)d op sec2cos
--R 
--R
--RThere is one exposed function called sec2cos :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of sec2cos from TranscendentalManipulations
--R
--E 2714

--S 2715 of 3320
)d op sech
--R 
--R
--RThere is one exposed function called sech :
--R   [1] D -> D from D if D has HYPCAT
--R
--RThere are 5 unexposed functions called sech :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of sech from ElementaryFunction
--R
--R
--RExamples of sech from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of sech from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of sech from HyperbolicFunctionCategory
--R
--R
--RExamples of sech from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of sech from StreamTranscendentalFunctions
--R
--E 2715

--S 2716 of 3320
)d op sech2cosh
--R 
--R
--RThere is one exposed function called sech2cosh :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of sech2cosh from TranscendentalManipulations
--R
--E 2716

--S 2717 of 3320
)d op sechIfCan
--R 
--R
--RThere is one exposed function called sechIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of sechIfCan from PartialTranscendentalFunctions
--R
--E 2717

--S 2718 of 3320
)d op secIfCan
--R 
--R
--RThere is one exposed function called secIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of secIfCan from PartialTranscendentalFunctions
--R
--E 2718

--S 2719 of 3320 done
)d op second
--R 
--R
--RThere is one exposed function called second :
--R   [1] D -> D1 from D if D has URAGG(D1) and D1 has TYPE
--R
--RExamples of second from UnaryRecursiveAggregate
--R
--Rsecond [1,4,2,-6,0,3,5,4,2,3]
--R
--E 2719

--S 2720 of 3320
)d op seed
--R 
--R
--RThere is one exposed function called seed :
--R   [1]  -> Integer from RandomNumberSource
--R
--RExamples of seed from RandomNumberSource
--R
--E 2720

--S 2721 of 3320
)d op segment
--R 
--R
--RThere are 3 exposed functions called segment :
--R   [1] SegmentBinding(D2) -> Segment(D2) from SegmentBinding(D2) if D2
--R             has TYPE
--R   [2] (D1,D1) -> D from D if D has SEGCAT(D1) and D1 has TYPE
--R   [3] D1 -> UniversalSegment(D1) from UniversalSegment(D1) if D1 has 
--R            TYPE
--R
--RExamples of segment from SegmentBinding
--R
--R
--RExamples of segment from SegmentCategory
--R
--R
--RExamples of segment from UniversalSegment
--R
--E 2721

--S 2722 of 3320
)d op SEGMENT
--R 
--R
--RThere are 2 exposed functions called SEGMENT :
--R   [1] (D1,D1) -> D from D if D has SEGCAT(D1) and D1 has TYPE
--R   [2] D1 -> UniversalSegment(D1) from UniversalSegment(D1) if D1 has 
--R            TYPE
--R
--RThere are 2 unexposed functions called SEGMENT :
--R   [1] OutputForm -> OutputForm from OutputForm
--R   [2] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of SEGMENT from OutputForm
--R
--R
--RExamples of SEGMENT from SegmentCategory
--R
--R
--RExamples of SEGMENT from UniversalSegment
--R
--E 2722

--S 2723 of 3320
)d op select
--R 
--R
--RThere are 4 exposed functions called select :
--R   [1] ((D2 -> Boolean),D) -> D from D
--R             if D has finiteAggregate and D has CLAGG(D2) and D2 has 
--R            TYPE
--R   [2] ((D2 -> Boolean),InfiniteTuple(D2)) -> InfiniteTuple(D2)
--R             from InfiniteTuple(D2) if D2 has TYPE
--R   [3] ((D2 -> Boolean),D) -> D from D if D has LZSTAGG(D2) and D2 has 
--R            TYPE
--R   [4] (D,D2) -> Union(D1,"failed") from D
--R             if D has TSETCAT(D3,D4,D2,D1) and D3 has INTDOM and D4
--R             has OAMONS and D2 has ORDSET and D1 has RPOLCAT(D3,D4,D2)
--R            
--R
--RThere is one unexposed function called select :
--R   [1] (Tuple(D1),NonNegativeInteger) -> D1 from Tuple(D1) if D1 has 
--R            TYPE
--R
--RExamples of select from Collection
--R
--R
--RExamples of select from InfiniteTuple
--R
--R
--RExamples of select from LazyStreamAggregate
--R
--Rm:=[i for i in 0..] 
--Rselect(x+->prime? x,m)
--R
--R
--RExamples of select from TriangularSetCategory
--R
--R
--RExamples of select from Tuple
--R
--Rt1:PrimitiveArray(Integer):= [i for i in 1..10] 
--Rt2:=coerce(t1)$Tuple(Integer) 
--Rselect(t2,3)
--R
--E 2723

--S 2724 of 3320
)d op select!
--R 
--R
--RThere are 2 exposed functions called select! :
--R   [1] ((D2 -> Boolean),D) -> D from D
--R             if D has finiteAggregate and D has DIOPS(D2) and D2 has 
--R            SETCAT
--R   [2] ((D2 -> Boolean),D) -> D from D if D has ELAGG(D2) and D2 has 
--R            TYPE
--R
--RExamples of select! from DictionaryOperations
--R
--R
--RExamples of select! from ExtensibleLinearAggregate
--R
--E 2724

--S 2725 of 3320
)d op selectAndPolynomials
--R 
--R
--RThere is one unexposed function called selectAndPolynomials :
--R   [1] (List((D7 -> Boolean)),List(D7)) -> Record(goodPols: List(D7),
--R            badPols: List(D7))
--R             from PolynomialSetUtilitiesPackage(D4,D5,D6,D7)
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has INTDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R
--RExamples of selectAndPolynomials from PolynomialSetUtilitiesPackage
--R
--E 2725

--S 2726 of 3320
)d op selectFiniteRoutines
--R 
--R
--RThere is one exposed function called selectFiniteRoutines :
--R   [1] RoutinesTable -> RoutinesTable from RoutinesTable
--R
--RExamples of selectFiniteRoutines from RoutinesTable
--R
--E 2726

--S 2727 of 3320
)d op selectfirst
--R 
--R
--RThere is one unexposed function called selectfirst :
--R   [1] Product(D1,D2) -> D1 from Product(D1,D2) if D1 has SETCAT and D2
--R             has SETCAT
--R
--RExamples of selectfirst from Product
--R
--E 2727

--S 2728 of 3320
)d op selectIntegrationRoutines
--R 
--R
--RThere is one exposed function called selectIntegrationRoutines :
--R   [1] RoutinesTable -> RoutinesTable from RoutinesTable
--R
--RExamples of selectIntegrationRoutines from RoutinesTable
--R
--E 2728

--S 2729 of 3320
)d op selectMultiDimensionalRoutines
--R 
--R
--RThere is one exposed function called selectMultiDimensionalRoutines :
--R   [1] RoutinesTable -> RoutinesTable from RoutinesTable
--R
--RExamples of selectMultiDimensionalRoutines from RoutinesTable
--R
--E 2729

--S 2730 of 3320
)d op selectNonFiniteRoutines
--R 
--R
--RThere is one exposed function called selectNonFiniteRoutines :
--R   [1] RoutinesTable -> RoutinesTable from RoutinesTable
--R
--RExamples of selectNonFiniteRoutines from RoutinesTable
--R
--E 2730

--S 2731 of 3320
)d op selectODEIVPRoutines
--R 
--R
--RThere is one exposed function called selectODEIVPRoutines :
--R   [1] RoutinesTable -> RoutinesTable from RoutinesTable
--R
--RExamples of selectODEIVPRoutines from RoutinesTable
--R
--E 2731

--S 2732 of 3320
)d op selectOptimizationRoutines
--R 
--R
--RThere is one exposed function called selectOptimizationRoutines :
--R   [1] RoutinesTable -> RoutinesTable from RoutinesTable
--R
--RExamples of selectOptimizationRoutines from RoutinesTable
--R
--E 2732

--S 2733 of 3320
)d op selectOrPolynomials
--R 
--R
--RThere is one unexposed function called selectOrPolynomials :
--R   [1] (List((D7 -> Boolean)),List(D7)) -> Record(goodPols: List(D7),
--R            badPols: List(D7))
--R             from PolynomialSetUtilitiesPackage(D4,D5,D6,D7)
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has INTDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R
--RExamples of selectOrPolynomials from PolynomialSetUtilitiesPackage
--R
--E 2733

--S 2734 of 3320
)d op selectPDERoutines
--R 
--R
--RThere is one exposed function called selectPDERoutines :
--R   [1] RoutinesTable -> RoutinesTable from RoutinesTable
--R
--RExamples of selectPDERoutines from RoutinesTable
--R
--E 2734

--S 2735 of 3320
)d op selectPolynomials
--R 
--R
--RThere is one unexposed function called selectPolynomials :
--R   [1] ((D7 -> Boolean),List(D7)) -> Record(goodPols: List(D7),badPols
--R            : List(D7))
--R             from PolynomialSetUtilitiesPackage(D4,D5,D6,D7)
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has INTDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R
--RExamples of selectPolynomials from PolynomialSetUtilitiesPackage
--R
--E 2735

--S 2736 of 3320
)d op selectsecond
--R 
--R
--RThere is one unexposed function called selectsecond :
--R   [1] Product(D2,D1) -> D1 from Product(D2,D1) if D1 has SETCAT and D2
--R             has SETCAT
--R
--RExamples of selectsecond from Product
--R
--E 2736

--S 2737 of 3320
)d op selectSumOfSquaresRoutines
--R 
--R
--RThere is one exposed function called selectSumOfSquaresRoutines :
--R   [1] RoutinesTable -> RoutinesTable from RoutinesTable
--R
--RExamples of selectSumOfSquaresRoutines from RoutinesTable
--R
--E 2737

--S 2738 of 3320
)d op semicolonSeparate
--R 
--R
--RThere is one unexposed function called semicolonSeparate :
--R   [1] List(OutputForm) -> OutputForm from OutputForm
--R
--RExamples of semicolonSeparate from OutputForm
--R
--E 2738

--S 2739 of 3320
)d op semiDegreeSubResultantEuclidean
--R 
--R
--RThere is one unexposed function called semiDegreeSubResultantEuclidean :
--R   [1] (D2,D2,NonNegativeInteger) -> Record(coef2: D2,subResultant: D2)
--R             from PseudoRemainderSequence(D4,D2)
--R             if D4 has INTDOM and D2 has UPOLYC(D4)
--R
--RExamples of semiDegreeSubResultantEuclidean from PseudoRemainderSequence
--R
--E 2739

--S 2740 of 3320
)d op semiDiscriminantEuclidean
--R 
--R
--RThere is one unexposed function called semiDiscriminantEuclidean :
--R   [1] D2 -> Record(coef2: D2,discriminant: D3)
--R             from PseudoRemainderSequence(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of semiDiscriminantEuclidean from PseudoRemainderSequence
--R
--E 2740

--S 2741 of 3320
)d op semiIndiceSubResultantEuclidean
--R 
--R
--RThere is one unexposed function called semiIndiceSubResultantEuclidean :
--R   [1] (D2,D2,NonNegativeInteger) -> Record(coef2: D2,subResultant: D2)
--R             from PseudoRemainderSequence(D4,D2)
--R             if D4 has INTDOM and D2 has UPOLYC(D4)
--R
--RExamples of semiIndiceSubResultantEuclidean from PseudoRemainderSequence
--R
--E 2741

--S 2742 of 3320
)d op semiLastSubResultantEuclidean
--R 
--R
--RThere is one unexposed function called semiLastSubResultantEuclidean :
--R   [1] (D2,D2) -> Record(coef2: D2,subResultant: D2)
--R             from PseudoRemainderSequence(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of semiLastSubResultantEuclidean from PseudoRemainderSequence
--R
--E 2742

--S 2743 of 3320
)d op semiResultantEuclidean1
--R 
--R
--RThere is one unexposed function called semiResultantEuclidean1 :
--R   [1] (D2,D2) -> Record(coef1: D2,resultant: D3)
--R             from PseudoRemainderSequence(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of semiResultantEuclidean1 from PseudoRemainderSequence
--R
--E 2743

--S 2744 of 3320
)d op semiResultantEuclidean2
--R 
--R
--RThere is one unexposed function called semiResultantEuclidean2 :
--R   [1] (D2,D2) -> Record(coef2: D2,resultant: D3)
--R             from PseudoRemainderSequence(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of semiResultantEuclidean2 from PseudoRemainderSequence
--R
--E 2744

--S 2745 of 3320
--R--------------------)d op semiResultantEuclidean_naif (fix this)
--E 2745

--S 2746 of 3320
)d op semiResultantReduitEuclidean
--R 
--R
--RThere is one unexposed function called semiResultantReduitEuclidean :
--R   [1] (D2,D2) -> Record(coef2: D2,resultantReduit: D3)
--R             from PseudoRemainderSequence(D3,D2)
--R             if D3 has GCDDOM and D3 has INTDOM and D2 has UPOLYC(D3)
--R         
--R
--RExamples of semiResultantReduitEuclidean from PseudoRemainderSequence
--R
--E 2746

--S 2747 of 3320
)d op semiSubResultantGcdEuclidean1
--R 
--R
--RThere is one unexposed function called semiSubResultantGcdEuclidean1 :
--R   [1] (D2,D2) -> Record(coef1: D2,gcd: D2) from 
--R            PseudoRemainderSequence(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of semiSubResultantGcdEuclidean1 from PseudoRemainderSequence
--R
--E 2747

--S 2748 of 3320
)d op semiSubResultantGcdEuclidean2
--R 
--R
--RThere is one unexposed function called semiSubResultantGcdEuclidean2 :
--R   [1] (D2,D2) -> Record(coef2: D2,gcd: D2) from 
--R            PseudoRemainderSequence(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of semiSubResultantGcdEuclidean2 from PseudoRemainderSequence
--R
--E 2748

--S 2749 of 3320
)d op separant
--R 
--R
--RThere is one exposed function called separant :
--R   [1] D -> D from D
--R             if D has DPOLCAT(D1,D2,D3,D4) and D1 has RING and D2 has 
--R            ORDSET and D3 has DVARCAT(D2) and D4 has OAMONS
--R
--RExamples of separant from DifferentialPolynomialCategory
--R
--E 2749

--S 2750 of 3320
)d op separate
--R 
--R
--RThere is one exposed function called separate :
--R   [1] (D,D) -> Record(primePart: D,commonPart: D) from D
--R             if D2 has GCDDOM and D2 has RING and D has UPOLYC(D2)
--R
--RThere are 2 unexposed functions called separate :
--R   [1] Fraction(D4) -> Record(polyPart: LaurentPolynomial(D3,D4),
--R            fracPart: Fraction(D4))
--R             from LaurentPolynomial(D3,D4)
--R             if D3 has FIELD and D3 has INTDOM and D4 has UPOLYC(D3)
--R         
--R   [2] SubSpace(D2,D3) -> List(SubSpace(D2,D3)) from SubSpace(D2,D3)
--R             if D2: PI and D3 has RING
--R
--RExamples of separate from LaurentPolynomial
--R
--R
--RExamples of separate from SubSpace
--R
--R
--RExamples of separate from UnivariatePolynomialCategory
--R
--E 2750

--S 2751 of 3320
)d op separateDegrees
--R 
--R
--RThere is one exposed function called separateDegrees :
--R   [1] D2 -> List(Record(deg: NonNegativeInteger,prod: D2))
--R             from DistinctDegreeFactorize(D3,D2)
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R
--RExamples of separateDegrees from DistinctDegreeFactorize
--R
--E 2751

--S 2752 of 3320
)d op separateFactors
--R 
--R
--RThere are 2 exposed functions called separateFactors :
--R   [1] List(Record(deg: NonNegativeInteger,prod: D4)) -> List(D4)
--R             from DistinctDegreeFactorize(D3,D4)
--R             if D4 has UPOLYC(D3) and D3 has FFIELDC
--R   [2] (List(Record(factor: D4,degree: Integer)),Integer) -> List(D4)
--R             from ModularDistinctDegreeFactorizer(D4) if D4 has UPOLYC(
--R            INT)
--R
--RExamples of separateFactors from DistinctDegreeFactorize
--R
--R
--RExamples of separateFactors from ModularDistinctDegreeFactorizer
--R
--E 2752

--S 2753 of 3320
)d op separe
--R 
--R
--RThere is one exposed function called separe :
--R   [1] (List(D2),D2,D2) -> List(D2) from SimpleCell(D2,D3)
--R             if D2 has RCFIELD and D3 has UPOLYC(D2)
--R
--RExamples of separe from SimpleCell
--R
--E 2753

--S 2754 of 3320
)d op sequences
--R 
--R
--RThere are 2 exposed functions called sequences :
--R   [1] (List(Integer),List(Integer)) -> Stream(List(Integer))
--R             from PartitionsAndPermutations
--R   [2] List(Integer) -> Stream(List(Integer)) from 
--R            PartitionsAndPermutations
--R
--RExamples of sequences from PartitionsAndPermutations
--R
--E 2754

--S 2755 of 3320
)d op series
--R 
--R
--RThere are 16 exposed functions called series :
--R   [1] Symbol -> Any from ExpressionToUnivariatePowerSeries(D3,D4)
--R             if D3 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D4 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R   [2] D2 -> Any from ExpressionToUnivariatePowerSeries(D3,D2)
--R             if D3 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R   [3] (D2,Fraction(Integer)) -> Any
--R             from ExpressionToUnivariatePowerSeries(D4,D2)
--R             if D4 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D4))
--R   [4] (D2,Equation(D2)) -> Any from ExpressionToUnivariatePowerSeries(
--R            D4,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D4)) and D4
--R             has Join(GcdDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [5] (D2,Equation(D2),Fraction(Integer)) -> Any
--R             from ExpressionToUnivariatePowerSeries(D5,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D5)) and D5
--R             has Join(GcdDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [6] ((Integer -> D5),Equation(D5)) -> Any
--R             from GenerateUnivariatePowerSeries(D4,D5)
--R             if D5 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D4)) and D4
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [7] (D2,Symbol,Equation(D2)) -> Any from 
--R            GenerateUnivariatePowerSeries(D5,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D5)) and D5
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [8] ((Integer -> D6),Equation(D6),UniversalSegment(Integer)) -> Any
--R             from GenerateUnivariatePowerSeries(D5,D6)
--R             if D6 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D5)) and D5
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [9] (D2,Symbol,Equation(D2),UniversalSegment(Integer)) -> Any
--R             from GenerateUnivariatePowerSeries(D6,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D6)) and D6
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [10] ((Fraction(Integer) -> D7),Equation(D7),UniversalSegment(
--R            Fraction(Integer)),Fraction(Integer)) -> Any
--R             from GenerateUnivariatePowerSeries(D6,D7)
--R             if D7 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D6)) and D6
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [11] (D2,Symbol,Equation(D2),UniversalSegment(Fraction(Integer)),
--R            Fraction(Integer)) -> Any
--R             from GenerateUnivariatePowerSeries(D7,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D7)) and D7
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [12] (Integer,D2,D) -> D from D if D has LOCPOWC(D2) and D2 has 
--R            FIELD
--R   [13] Stream(Record(k: Integer,c: D2)) -> D from D
--R             if D2 has RING and D has ULSCAT(D2)
--R   [14] (NonNegativeInteger,Stream(Record(k: Fraction(Integer),c: D3)))
--R             -> D
--R             from D if D3 has RING and D has UPXSCAT(D3)
--R   [15] Stream(D2) -> D from D if D2 has RING and D has UTSCAT(D2)
--R   [16] Stream(Record(k: NonNegativeInteger,c: D2)) -> D from D
--R             if D2 has RING and D has UTSCAT(D2)
--R
--RThere are 3 unexposed functions called series :
--R   [1] Stream(Record(k: Integer,c: D2)) -> 
--R            InnerSparseUnivariatePowerSeries(D2)
--R             from InnerSparseUnivariatePowerSeries(D2) if D2 has RING
--R         
--R   [2] Stream(D2) -> InnerTaylorSeries(D2) from InnerTaylorSeries(D2)
--R             if D2 has RING
--R   [3] Stream(D4) -> SparseMultivariateTaylorSeries(D2,D3,D4)
--R             from SparseMultivariateTaylorSeries(D2,D3,D4)
--R             if D4 has POLYCAT(D2,INDE(D3),D3) and D2 has RING and D3
--R             has ORDSET
--R
--RExamples of series from ExpressionToUnivariatePowerSeries
--R
--R
--RExamples of series from GenerateUnivariatePowerSeries
--R
--R
--RExamples of series from InnerSparseUnivariatePowerSeries
--R
--R
--RExamples of series from InnerTaylorSeries
--R
--R
--RExamples of series from LocalPowerSeriesCategory
--R
--R
--RExamples of series from SparseMultivariateTaylorSeries
--R
--R
--RExamples of series from UnivariateLaurentSeriesCategory
--R
--R
--RExamples of series from UnivariatePuiseuxSeriesCategory
--R
--R
--RExamples of series from UnivariateTaylorSeriesCategory
--R
--E 2755

--S 2756 of 3320
)d op seriesSolve
--R 
--R
--RThere are 12 exposed functions called seriesSolve :
--R   [1] (Equation(D5),BasicOperator,Equation(D5),Equation(D5)) -> Any
--R             from ExpressionSpaceODESolver(D4,D5)
--R             if D5 has FS(D4) and D4 has Join(OrderedSet,IntegralDomain
--R            ,ConvertibleTo(InputForm))
--R   [2] (Equation(D6),BasicOperator,Equation(D6),List(D6)) -> Any
--R             from ExpressionSpaceODESolver(D5,D6)
--R             if D6 has FS(D5) and D5 has Join(OrderedSet,IntegralDomain
--R            ,ConvertibleTo(InputForm))
--R   [3] (List(Equation(D6)),List(BasicOperator),Equation(D6),List(
--R            Equation(D6))) -> Any
--R             from ExpressionSpaceODESolver(D5,D6)
--R             if D6 has FS(D5) and D5 has Join(OrderedSet,IntegralDomain
--R            ,ConvertibleTo(InputForm))
--R   [4] (List(Equation(D7)),List(BasicOperator),Equation(D7),List(D7))
--R             -> Any
--R             from ExpressionSpaceODESolver(D6,D7)
--R             if D7 has FS(D6) and D6 has Join(OrderedSet,IntegralDomain
--R            ,ConvertibleTo(InputForm))
--R   [5] (List(D6),List(BasicOperator),Equation(D6),List(D6)) -> Any
--R             from ExpressionSpaceODESolver(D5,D6)
--R             if D6 has FS(D5) and D5 has Join(OrderedSet,IntegralDomain
--R            ,ConvertibleTo(InputForm))
--R   [6] (List(D7),List(BasicOperator),Equation(D7),List(Equation(D7)))
--R             -> Any
--R             from ExpressionSpaceODESolver(D6,D7)
--R             if D7 has FS(D6) and D6 has Join(OrderedSet,IntegralDomain
--R            ,ConvertibleTo(InputForm))
--R   [7] (Equation(D4),BasicOperator,Equation(D4),D4) -> Any
--R             from ExpressionSpaceODESolver(D5,D4)
--R             if D4 has FS(D5) and D5 has Join(OrderedSet,IntegralDomain
--R            ,ConvertibleTo(InputForm))
--R   [8] (D2,BasicOperator,Equation(D2),D2) -> Any
--R             from ExpressionSpaceODESolver(D5,D2)
--R             if D2 has FS(D5) and D5 has Join(OrderedSet,IntegralDomain
--R            ,ConvertibleTo(InputForm))
--R   [9] (D2,BasicOperator,Equation(D2),Equation(D2)) -> Any
--R             from ExpressionSpaceODESolver(D5,D2)
--R             if D2 has FS(D5) and D5 has Join(OrderedSet,IntegralDomain
--R            ,ConvertibleTo(InputForm))
--R   [10] (D2,BasicOperator,Equation(D2),List(D2)) -> Any
--R             from ExpressionSpaceODESolver(D6,D2)
--R             if D2 has FS(D6) and D6 has Join(OrderedSet,IntegralDomain
--R            ,ConvertibleTo(InputForm))
--R   [11] (D2,BasicOperator,Symbol,List(D2)) -> D1
--R             from ExpressionSolve(D6,D2,D1,D7)
--R             if D2 has FS(D6) and D6 has Join(OrderedSet,IntegralDomain
--R            ,ConvertibleTo(InputForm)) and D1 has UTSCAT(D2) and D7
--R             has UTSCAT(SUPEXPR(D2))
--R   [12] ((D5 -> D5),List(D4)) -> D1 from TaylorSolve(D4,D1,D5)
--R             if D4 has FIELD and D5 has UTSCAT(SUPEXPR(D4)) and D1 has 
--R            UTSCAT(D4)
--R
--RExamples of seriesSolve from ExpressionSpaceODESolver
--R
--R
--RExamples of seriesSolve from ExpressionSolve
--R
--R
--RExamples of seriesSolve from TaylorSolve
--R
--E 2756

--S 2757 of 3320
)d op seriesToOutputForm
--R 
--R
--RThere is one unexposed function called seriesToOutputForm :
--R   [1] (Stream(Record(k: Integer,c: D5)),Reference(OrderedCompletion(
--R            Integer)),Symbol,D5,Fraction(Integer)) -> OutputForm
--R             from InnerSparseUnivariatePowerSeries(D5) if D5 has RING
--R         
--R
--RExamples of seriesToOutputForm from InnerSparseUnivariatePowerSeries
--R
--E 2757

--S 2758 of 3320
)d op set
--R 
--R
--RThere are 2 exposed functions called set :
--R   [1] List(D2) -> D from D if D2 has SETCAT and D has SETAGG(D2)
--R   [2]  -> D from D if D has SETAGG(D1) and D1 has SETCAT
--R
--RExamples of set from SetAggregate
--R
--E 2758

--S 2759 of 3320
)d op setAdaptive
--R 
--R
--RThere is one unexposed function called setAdaptive :
--R   [1] Boolean -> Boolean from Plot
--R
--RExamples of setAdaptive from Plot
--R
--E 2759

--S 2760 of 3320
)d op setAdaptive3D
--R 
--R
--RThere is one unexposed function called setAdaptive3D :
--R   [1] Boolean -> Boolean from Plot3D
--R
--RExamples of setAdaptive3D from Plot3D
--R
--E 2760

--S 2761 of 3320
)d op setAttributeButtonStep
--R 
--R
--RThere is one exposed function called setAttributeButtonStep :
--R   [1] Float -> Float from AttributeButtons
--R
--RExamples of setAttributeButtonStep from AttributeButtons
--R
--E 2761

--S 2762 of 3320
)d op setButtonValue
--R 
--R
--RThere are 2 exposed functions called setButtonValue :
--R   [1] (String,String,Float) -> Float from AttributeButtons
--R   [2] (String,Float) -> Float from AttributeButtons
--R
--RExamples of setButtonValue from AttributeButtons
--R
--E 2762

--S 2763 of 3320
)d op setchart!
--R 
--R
--RThere is one exposed function called setchart! :
--R   [1] (D,D2) -> D2 from D
--R             if D has INFCLCT(D3,D4,D5,D6,D7,D8,D9,D1,D2) and D3 has 
--R            FIELD and D5 has POLYCAT(D3,D6,OVAR(D4)) and D6 has DIRPCAT
--R            (#(D4),NNI) and D7 has PRSPCAT(D3) and D8 has LOCPOWC(D3) 
--R            and D9 has PLACESC(D3,D8) and D2 has BLMETCT
--R
--RExamples of setchart! from InfinitlyClosePointCategory
--R
--E 2763

--S 2764 of 3320
)d op setchildren!
--R 
--R
--RThere is one exposed function called setchildren! :
--R   [1] (D,List(D)) -> D from D
--R             if D has shallowlyMutable and D has RCAGG(D2) and D2 has 
--R            TYPE
--R
--RExamples of setchildren! from RecursiveAggregate
--R
--E 2764

--S 2765 of 3320
)d op setClipValue
--R 
--R
--RThere is one exposed function called setClipValue :
--R   [1] DoubleFloat -> DoubleFloat from DrawComplex
--R
--RExamples of setClipValue from DrawComplex
--R
--E 2765

--S 2766 of 3320
)d op setClosed
--R 
--R
--RThere is one unexposed function called setClosed :
--R   [1] (TubePlot(D2),Boolean) -> Boolean from TubePlot(D2) if D2 has 
--R            PSCURVE
--R
--RExamples of setClosed from TubePlot
--R
--E 2766

--S 2767 of 3320 done
)d op setColumn!
--R 
--R
--RThere is one exposed function called setColumn! :
--R   [1] (D,Integer,D2) -> D from D
--R             if D has ARR2CAT(D3,D4,D2) and D3 has TYPE and D4 has 
--R            FLAGG(D3) and D2 has FLAGG(D3)
--R
--RExamples of setColumn! from TwoDimensionalArrayCategory
--R
--RT1:=TwoDimensionalArray Integer 
--Rarr:T1:= new(5,4,0) 
--RT2:=OneDimensionalArray Integer 
--Racol:=construct([1,2,3,4,5]::List(INT))$T2 
--RsetColumn!(arr,1,acol)$T1
--R
--E 2767

--S 2768 of 3320
)d op setCondition!
--R 
--R
--RThere is one unexposed function called setCondition! :
--R   [1] (SplittingNode(D2,D1),D1) -> SplittingNode(D2,D1)
--R             from SplittingNode(D2,D1)
--R             if D2 has Join(SetCategory,Aggregate) and D1 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of setCondition! from SplittingNode
--R
--E 2768

--S 2769 of 3320
)d op setcurve!
--R 
--R
--RThere is one exposed function called setcurve! :
--R   [1] (D,DistributedMultivariatePolynomial([construct,QUOTEX,QUOTEY],
--R            D4)) -> DistributedMultivariatePolynomial([construct,QUOTEX,QUOTE
--R            Y],D4)
--R             from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of setcurve! from InfinitlyClosePointCategory
--R
--E 2769

--S 2770 of 3320
)d op setCurve
--R 
--R
--RThere are 3 exposed functions called setCurve :
--R   [1] D4 -> D4
--R             from GeneralPackageForAlgebraicFunctionField(D5,D6,D4,D7,
--R            D8,D9,D10,D11,D1,D2,D3)
--R             if D5 has FIELD and D6: LIST(SYMBOL) and D4 has POLYCAT(D5
--R            ,D7,OVAR(D6)) and D7 has DIRPCAT(#(D6),NNI) and D8 has 
--R            PRSPCAT(D5) and D9 has LOCPOWC(D5) and D10 has PLACESC(D5,
--R            D9) and D11 has DIVCAT(D10) and D1 has INFCLCT(D5,D6,D4,D7,
--R            D8,D9,D10,D11,D3) and D3 has BLMETCT and D2 has DSTRCAT(D1)
--R            
--R   [2] DistributedMultivariatePolynomial(D3,D2) -> 
--R            DistributedMultivariatePolynomial(D3,D2)
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [3] DistributedMultivariatePolynomial(D3,D2) -> 
--R            DistributedMultivariatePolynomial(D3,D2)
--R             from PackageForAlgebraicFunctionField(D2,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R
--RExamples of setCurve from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of setCurve from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of setCurve from PackageForAlgebraicFunctionField
--R
--E 2770

--S 2771 of 3320
)d op setDegree!
--R 
--R
--RThere is one exposed function called setDegree! :
--R   [1] (D,PositiveInteger) -> Void from D
--R             if D has PLACESC(D3,D4) and D3 has FIELD and D4 has 
--R            LOCPOWC(D3)
--R
--RExamples of setDegree! from PlacesCategory
--R
--E 2771

--S 2772 of 3320
)d op setDifference
--R 
--R
--RThere is one exposed function called setDifference :
--R   [1] (List(D1),List(D1)) -> List(D1) from List(D1) if D1 has SETCAT 
--R            and D1 has TYPE
--R
--RExamples of setDifference from List
--R
--E 2772

--S 2773 of 3320
)d op setelt
--R 
--R
--RThere are 14 exposed functions called setelt :
--R   [1] (D,Integer,D1) -> D1 from D if D has AFSPCAT(D1) and D1 has 
--R            FIELD
--R   [2] (D,Integer,Integer,D1) -> D1 from D
--R             if D has ARR2CAT(D1,D3,D4) and D1 has TYPE and D3 has 
--R            FLAGG(D1) and D4 has FLAGG(D1)
--R   [3] (D,right,D) -> D from D
--R             if D has shallowlyMutable and D has BRAGG(D2) and D2 has 
--R            TYPE
--R   [4] (D,left,D) -> D from D
--R             if D has shallowlyMutable and D has BRAGG(D2) and D2 has 
--R            TYPE
--R   [5] (D,D2,D1) -> D1 from D
--R             if D has shallowlyMutable and D has ELTAGG(D2,D1) and D2
--R             has SETCAT and D1 has TYPE
--R   [6] (Library,Symbol,Any) -> Any from Library
--R   [7] (D,UniversalSegment(Integer),D1) -> D1 from D
--R             if D has shallowlyMutable and D has LNAGG(D1) and D1 has 
--R            TYPE
--R   [8] (D,List(Integer),List(Integer),D) -> D from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [9] (D,Integer,D1) -> D1 from D if D has PRSPCAT(D1) and D1 has 
--R            FIELD
--R   [10] (D,value,D1) -> D1 from D
--R             if D has shallowlyMutable and D has RCAGG(D1) and D1 has 
--R            TYPE
--R   [11] (D,D2,D1) -> D1 from D
--R             if D has TBAGG(D2,D1) and D2 has SETCAT and D1 has SETCAT
--R            
--R   [12] (D,last,D1) -> D1 from D
--R             if D has shallowlyMutable and D has URAGG(D1) and D1 has 
--R            TYPE
--R   [13] (D,rest,D) -> D from D
--R             if D has shallowlyMutable and D has URAGG(D2) and D2 has 
--R            TYPE
--R   [14] (D,first,D1) -> D1 from D
--R             if D has shallowlyMutable and D has URAGG(D1) and D1 has 
--R            TYPE
--R
--RThere is one unexposed function called setelt :
--R   [1] (Reference(D1),D1) -> D1 from Reference(D1) if D1 has TYPE
--R
--RExamples of setelt from AffineSpaceCategory
--R
--R
--RExamples of setelt from TwoDimensionalArrayCategory
--R
--Rarr : ARRAY2 INT := new(5,4,0) 
--Rsetelt(arr,1,1,17)
--R
--R
--RExamples of setelt from BinaryRecursiveAggregate
--R
--R
--RExamples of setelt from EltableAggregate
--R
--R
--RExamples of setelt from Library
--R
--R
--RExamples of setelt from LinearAggregate
--R
--R
--RExamples of setelt from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rsetelt(m,3,3,10)
--R
--R
--RExamples of setelt from ProjectiveSpaceCategory
--R
--R
--RExamples of setelt from RecursiveAggregate
--R
--R
--RExamples of setelt from Reference
--R
--R
--RExamples of setelt from TableAggregate
--R
--R
--RExamples of setelt from UnaryRecursiveAggregate
--R
--Rt1:=[1,4,2,-6,0,3,5,4,2,3] 
--Rt1.last := 7 
--Rt1
--R
--Rt1:=[1,2,3] 
--Rt1.rest:=[4,5,6] 
--Rt1
--R
--Rt1:=[1,2,3] 
--Rt1.first:=7 
--Rt1
--R
--E 2773

--S 2774 of 3320
)d op setelt!
--R 
--R
--RThere are 2 exposed functions called setelt! :
--R   [1] (ThreeDimensionalMatrix(D1),NonNegativeInteger,
--R            NonNegativeInteger,NonNegativeInteger,D1) -> D1
--R             from ThreeDimensionalMatrix(D1) if D1 has SETCAT
--R   [2] (SparseEchelonMatrix(D3,D4),Integer,D3,D4) -> Void
--R             from SparseEchelonMatrix(D3,D4) if D3 has ORDSET and D4
--R             has RING
--R
--RExamples of setelt! from ThreeDimensionalMatrix
--R
--R
--RExamples of setelt! from SparseEchelonMatrix
--R
--E 2774

--S 2775 of 3320
)d op setEmpty!
--R 
--R
--RThere is one unexposed function called setEmpty! :
--R   [1] SplittingNode(D1,D2) -> SplittingNode(D1,D2) from SplittingNode(
--R            D1,D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of setEmpty! from SplittingNode
--R
--E 2775

--S 2776 of 3320
)d op setEpilogue!
--R 
--R
--RThere are 2 exposed functions called setEpilogue! :
--R   [1] (ScriptFormulaFormat,List(String)) -> List(String)
--R             from ScriptFormulaFormat
--R   [2] (TexFormat,List(String)) -> List(String) from TexFormat
--R
--RExamples of setEpilogue! from ScriptFormulaFormat
--R
--R
--RExamples of setEpilogue! from TexFormat
--R
--E 2776

--S 2777 of 3320
)d op setErrorBound
--R 
--R
--RThere is one unexposed function called setErrorBound :
--R   [1] D1 -> D1 from ComplexRootFindingPackage(D1,D2)
--R             if D1 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D1))
--R
--RExamples of setErrorBound from ComplexRootFindingPackage
--R
--E 2777

--S 2778 of 3320
)d op setexcpDiv!
--R 
--R
--RThere is one exposed function called setexcpDiv! :
--R   [1] (D,DIVISOR) -> DIVISOR from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of setexcpDiv! from InfinitlyClosePointCategory
--R
--E 2778

--S 2779 of 3320
)d op setFieldInfo
--R 
--R
--RThere is one unexposed function called setFieldInfo :
--R   [1] (Vector(List(Record(value: D3,index: SingleInteger))),D3) -> 
--R            Void
--R             from InnerNormalBasisFieldFunctions(D3) if D3 has FFIELDC
--R            
--R
--RExamples of setFieldInfo from InnerNormalBasisFieldFunctions
--R
--E 2779

--S 2780 of 3320 done
)d op setfirst!
--R 
--R
--RThere is one exposed function called setfirst! :
--R   [1] (D,D1) -> D1 from D
--R             if D has shallowlyMutable and D has URAGG(D1) and D1 has 
--R            TYPE
--R
--RExamples of setfirst! from UnaryRecursiveAggregate
--R
--Rt1:=[1,2,3] 
--Rsetfirst!(t1,7) 
--Rt1
--R
--E 2780

--S 2781 of 3320
)d op setFormula!
--R 
--R
--RThere is one exposed function called setFormula! :
--R   [1] (ScriptFormulaFormat,List(String)) -> List(String)
--R             from ScriptFormulaFormat
--R
--RExamples of setFormula! from ScriptFormulaFormat
--R
--E 2781

--S 2782 of 3320
)d op setFoundPlacesToEmpty
--R 
--R
--RThere is one exposed function called setFoundPlacesToEmpty :
--R   [1]  -> List(D) from D
--R             if D2 has FIELD and D3 has LOCPOWC(D2) and D has PLACESC(
--R            D2,D3)
--R
--RExamples of setFoundPlacesToEmpty from PlacesCategory
--R
--E 2782

--S 2783 of 3320
)d op setFoundZeroes
--R 
--R
--RThere is one exposed function called setFoundZeroes :
--R   [1] List(D2) -> List(D2) from RootsFindingPackage(D2) if D2 has 
--R            FIELD
--R
--RExamples of setFoundZeroes from RootsFindingPackage
--R
--E 2783

--S 2784 of 3320
)d op setGcdMode
--R 
--R
--RThere is one exposed function called setGcdMode :
--R   [1] Symbol -> Symbol from SparseEchelonMatrix(D2,D3)
--R             if D3 has GCDDOM and D2 has ORDSET and D3 has RING
--R
--RExamples of setGcdMode from SparseEchelonMatrix
--R
--E 2784

--S 2785 of 3320
)d op setImagSteps
--R 
--R
--RThere is one exposed function called setImagSteps :
--R   [1] Integer -> Integer from DrawComplex
--R
--RExamples of setImagSteps from DrawComplex
--R
--E 2785

--S 2786 of 3320
)d op setIntersection
--R 
--R
--RThere is one exposed function called setIntersection :
--R   [1] (List(D1),List(D1)) -> List(D1) from List(D1) if D1 has SETCAT 
--R            and D1 has TYPE
--R
--RExamples of setIntersection from List
--R
--E 2786

--S 2787 of 3320
)d op setLabelValue
--R 
--R
--RThere is one exposed function called setLabelValue :
--R   [1] SingleInteger -> SingleInteger from FortranCode
--R
--RExamples of setLabelValue from FortranCode
--R
--E 2787

--S 2788 of 3320 done
)d op setlast!
--R 
--R
--RThere is one exposed function called setlast! :
--R   [1] (D,D1) -> D1 from D
--R             if D has shallowlyMutable and D has URAGG(D1) and D1 has 
--R            TYPE
--R
--RExamples of setlast! from UnaryRecursiveAggregate
--R
--Rt1:=[1,4,2,-6,0,3,5,4,2,3] 
--Rsetlast!(t1,7) 
--Rt1
--R
--E 2788

--S 2789 of 3320 done
)d op setleaves!
--R 
--R
--RThere is one exposed function called setleaves! :
--R   [1] (BalancedBinaryTree(D2),List(D2)) -> BalancedBinaryTree(D2)
--R             from BalancedBinaryTree(D2) if D2 has SETCAT
--R
--RExamples of setleaves! from BalancedBinaryTree
--R
--Rt1:=balancedBinaryTree(4, 0) 
--Rsetleaves!(t1,[1,2,3,4])
--R
--E 2789

--S 2790 of 3320
)d op setleft!
--R 
--R
--RThere is one exposed function called setleft! :
--R   [1] (D,D) -> D from D
--R             if D has shallowlyMutable and D has BRAGG(D1) and D1 has 
--R            TYPE
--R
--RExamples of setleft! from BinaryRecursiveAggregate
--R
--E 2790

--S 2791 of 3320
)d op setLegalFortranSourceExtensions
--R 
--R
--RThere is one exposed function called setLegalFortranSourceExtensions :
--R   [1] List(String) -> List(String) from FortranPackage
--R
--RExamples of setLegalFortranSourceExtensions from FortranPackage
--R
--E 2791

--S 2792 of 3320
)d op setlocalParam!
--R 
--R
--RThere is one exposed function called setlocalParam! :
--R   [1] (D,List(D9)) -> List(D9) from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of setlocalParam! from InfinitlyClosePointCategory
--R
--E 2792

--S 2793 of 3320
)d op setlocalPoint!
--R 
--R
--RThere is one exposed function called setlocalPoint! :
--R   [1] (D,AffinePlane(D4)) -> AffinePlane(D4) from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of setlocalPoint! from InfinitlyClosePointCategory
--R
--E 2793

--S 2794 of 3320
)d op setMaxPoints
--R 
--R
--RThere is one unexposed function called setMaxPoints :
--R   [1] Integer -> Integer from Plot
--R
--RExamples of setMaxPoints from Plot
--R
--E 2794

--S 2795 of 3320
)d op setMaxPoints3D
--R 
--R
--RThere is one unexposed function called setMaxPoints3D :
--R   [1] Integer -> Integer from Plot3D
--R
--RExamples of setMaxPoints3D from Plot3D
--R
--E 2795

--S 2796 of 3320
)d op setMinPoints
--R 
--R
--RThere is one unexposed function called setMinPoints :
--R   [1] Integer -> Integer from Plot
--R
--RExamples of setMinPoints from Plot
--R
--E 2796

--S 2797 of 3320
)d op setMinPoints3D
--R 
--R
--RThere is one unexposed function called setMinPoints3D :
--R   [1] Integer -> Integer from Plot3D
--R
--RExamples of setMinPoints3D from Plot3D
--R
--E 2797

--S 2798 of 3320
)d op setmult!
--R 
--R
--RThere is one exposed function called setmult! :
--R   [1] (D,NonNegativeInteger) -> NonNegativeInteger from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of setmult! from InfinitlyClosePointCategory
--R
--E 2798

--S 2799 of 3320
)d op setnext!
--R 
--R
--RThere is one exposed function called setnext! :
--R   [1] (D,D) -> D from D
--R             if D has shallowlyMutable and D has DLAGG(D1) and D1 has 
--R            TYPE
--R
--RExamples of setnext! from DoublyLinkedAggregate
--R
--E 2799

--S 2800 of 3320
)d op setOfMinN
--R 
--R
--RThere is one unexposed function called setOfMinN :
--R   [1] List(PositiveInteger) -> SetOfMIntegersInOneToN(D2,D3)
--R             from SetOfMIntegersInOneToN(D2,D3) if D2: PI and D3: PI
--R         
--R
--RExamples of setOfMinN from SetOfMIntegersInOneToN
--R
--E 2800

--S 2801 of 3320
--R------------------- )d op SetOfMIntegersInOneToN (huh?)
--E 2801

--S 2802 of 3320
)d op setOrder
--R 
--R
--RThere are 2 unexposed functions called setOrder :
--R   [1] List(D3) -> Void from UserDefinedPartialOrdering(D3) if D3 has 
--R            SETCAT
--R   [2] (List(D3),List(D3)) -> Void from UserDefinedPartialOrdering(D3)
--R             if D3 has SETCAT
--R
--RExamples of setOrder from UserDefinedPartialOrdering
--R
--E 2802

--S 2803 of 3320
)d op setParam!
--R 
--R
--RThere is one exposed function called setParam! :
--R   [1] (D,List(D4)) -> Void from D
--R             if D has PLACESC(D3,D4) and D3 has FIELD and D4 has 
--R            LOCPOWC(D3)
--R
--RExamples of setParam! from PlacesCategory
--R
--E 2803

--S 2804 of 3320
)d op setpoint!
--R 
--R
--RThere is one exposed function called setpoint! :
--R   [1] (D,D2) -> D2 from D
--R             if D has INFCLCT(D3,D4,D5,D6,D2,D7,D8,D9,D1) and D3 has 
--R            FIELD and D5 has POLYCAT(D3,D6,OVAR(D4)) and D6 has DIRPCAT
--R            (#(D4),NNI) and D2 has PRSPCAT(D3) and D7 has LOCPOWC(D3) 
--R            and D8 has PLACESC(D3,D7) and D1 has BLMETCT
--R
--RExamples of setpoint! from InfinitlyClosePointCategory
--R
--E 2804

--S 2805 of 3320
)d op setPoly
--R 
--R
--RThere is one unexposed function called setPoly :
--R   [1] D1 -> D1 from ModMonic(D2,D1) if D2 has RING and D1 has UPOLYC(
--R            D2)
--R
--RExamples of setPoly from ModMonic
--R
--E 2805

--S 2806 of 3320
)d op setPosition
--R 
--R
--RThere is one exposed function called setPosition :
--R   [1] (D,NonNegativeInteger) -> Void from D if D has CACHSET
--R
--RExamples of setPosition from CachableSet
--R
--E 2806

--S 2807 of 3320
)d op setPredicates
--R 
--R
--RThere is one unexposed function called setPredicates :
--R   [1] (Pattern(D2),List(Any)) -> Pattern(D2) from Pattern(D2) if D2
--R             has SETCAT
--R
--RExamples of setPredicates from Pattern
--R
--E 2807

--S 2808 of 3320
)d op setprevious!
--R 
--R
--RThere is one exposed function called setprevious! :
--R   [1] (D,D) -> D from D
--R             if D has shallowlyMutable and D has DLAGG(D1) and D1 has 
--R            TYPE
--R
--RExamples of setprevious! from DoublyLinkedAggregate
--R
--E 2808

--S 2809 of 3320
)d op setPrologue!
--R 
--R
--RThere are 2 exposed functions called setPrologue! :
--R   [1] (ScriptFormulaFormat,List(String)) -> List(String)
--R             from ScriptFormulaFormat
--R   [2] (TexFormat,List(String)) -> List(String) from TexFormat
--R
--RExamples of setPrologue! from ScriptFormulaFormat
--R
--R
--RExamples of setPrologue! from TexFormat
--R
--E 2809

--S 2810 of 3320
)d op setProperties
--R 
--R
--RThere is one exposed function called setProperties :
--R   [1] (BasicOperator,AssociationList(String,None)) -> BasicOperator
--R             from BasicOperator
--R
--RExamples of setProperties from BasicOperator
--R
--E 2810

--S 2811 of 3320
)d op setProperty
--R 
--R
--RThere is one exposed function called setProperty :
--R   [1] (BasicOperator,String,None) -> BasicOperator from BasicOperator
--R            
--R
--RExamples of setProperty from BasicOperator
--R
--E 2811

--S 2812 of 3320
)d op setRealSteps
--R 
--R
--RThere is one exposed function called setRealSteps :
--R   [1] Integer -> Integer from DrawComplex
--R
--RExamples of setRealSteps from DrawComplex
--R
--E 2812

--S 2813 of 3320
)d op setref
--R 
--R
--RThere is one unexposed function called setref :
--R   [1] (Reference(D1),D1) -> D1 from Reference(D1) if D1 has TYPE
--R
--RExamples of setref from Reference
--R
--E 2813

--S 2814 of 3320 done
)d op setrest!
--R 
--R
--RThere are 2 exposed functions called setrest! :
--R   [1] (Stream(D2),Integer,Stream(D2)) -> Stream(D2) from Stream(D2)
--R             if D2 has TYPE
--R   [2] (D,D) -> D from D
--R             if D has shallowlyMutable and D has URAGG(D1) and D1 has 
--R            TYPE
--R
--RExamples of setrest! from Stream
--R
--Rp:=[i for i in 1..] 
--Rq:=[i for i in 9..] 
--Rsetrest!(p,4,q) 
--Rp
--R
--R
--RExamples of setrest! from UnaryRecursiveAggregate
--R
--Rt1:=[1,2,3] 
--Rsetrest!(t1,[4,5,6]) 
--Rt1
--R
--E 2814

--S 2815 of 3320
)d op setright!
--R 
--R
--RThere is one exposed function called setright! :
--R   [1] (D,D) -> D from D
--R             if D has shallowlyMutable and D has BRAGG(D1) and D1 has 
--R            TYPE
--R
--RExamples of setright! from BinaryRecursiveAggregate
--R
--E 2815

--S 2816 of 3320
)d op setRow!
--R 
--R
--RThere are 3 exposed functions called setRow! :
--R   [1] (D,Integer,D2) -> D from D
--R             if D has ARR2CAT(D3,D2,D4) and D3 has TYPE and D2 has 
--R            FLAGG(D3) and D4 has FLAGG(D3)
--R   [2] (SparseEchelonMatrix(D5,D6),Integer,List(D5),List(D6)) -> Void
--R             from SparseEchelonMatrix(D5,D6) if D5 has ORDSET and D6
--R             has RING
--R   [3] (SparseEchelonMatrix(D4,D5),Integer,Record(Indices: List(D4),
--R            Entries: List(D5))) -> Void
--R             from SparseEchelonMatrix(D4,D5) if D4 has ORDSET and D5
--R             has RING
--R
--RExamples of setRow! from TwoDimensionalArrayCategory
--R
--RT1:=TwoDimensionalArray Integer 
--Rarr:T1:= new(5,4,0) 
--RT2:=OneDimensionalArray Integer 
--Rarow:=construct([1,2,3,4]::List(INT))$T2 
--RsetRow!(arr,1,arow)$T1
--R
--R
--RExamples of setRow! from SparseEchelonMatrix
--R
--E 2816

--S 2817 of 3320
)d op setScreenResolution
--R 
--R
--RThere is one unexposed function called setScreenResolution :
--R   [1] Integer -> Integer from Plot
--R
--RExamples of setScreenResolution from Plot
--R
--E 2817

--S 2818 of 3320
)d op setScreenResolution3D
--R 
--R
--RThere is one unexposed function called setScreenResolution3D :
--R   [1] Integer -> Integer from Plot3D
--R
--RExamples of setScreenResolution3D from Plot3D
--R
--E 2818

--S 2819 of 3320
)d op setSingularPoints
--R 
--R
--RThere are 3 exposed functions called setSingularPoints :
--R   [1] List(D10) -> List(D10)
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R             if D10 has PRSPCAT(D6) and D6 has FIELD and D7: LIST(
--R            SYMBOL) and D8 has POLYCAT(D6,D9,OVAR(D7)) and D9 has 
--R            DIRPCAT(#(D7),NNI) and D11 has LOCPOWC(D6) and D12 has 
--R            PLACESC(D6,D11) and D1 has DIVCAT(D12) and D2 has INFCLCT(
--R            D6,D7,D8,D9,D10,D11,D12,D1,D4) and D4 has BLMETCT and D3
--R             has DSTRCAT(D2)
--R   [2] List(ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField(D2))
--R             -> List(ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField(
--R            D2))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [3] List(ProjectivePlane(D2)) -> List(ProjectivePlane(D2))
--R             from PackageForAlgebraicFunctionField(D2,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R
--RExamples of setSingularPoints from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of setSingularPoints from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of setSingularPoints from PackageForAlgebraicFunctionField
--R
--E 2819

--S 2820 of 3320
)d op setStatus
--R 
--R
--RThere is one unexposed function called setStatus :
--R   [1] (QuasiAlgebraicSet(D2,D3,D4,D5),Union(Boolean,"failed")) -> 
--R            QuasiAlgebraicSet(D2,D3,D4,D5)
--R             from QuasiAlgebraicSet(D2,D3,D4,D5)
--R             if D2 has GCDDOM and D3 has ORDSET and D4 has OAMONS and 
--R            D5 has POLYCAT(D2,D4,D3)
--R
--RExamples of setStatus from QuasiAlgebraicSet
--R
--E 2820

--S 2821 of 3320
)d op setStatus!
--R 
--R
--RThere is one unexposed function called setStatus! :
--R   [1] (SplittingNode(D2,D3),Boolean) -> SplittingNode(D2,D3)
--R             from SplittingNode(D2,D3)
--R             if D2 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of setStatus! from SplittingNode
--R
--E 2821

--S 2822 of 3320 done
)d op setsubMatrix!
--R 
--R
--RThere is one exposed function called setsubMatrix! :
--R   [1] (D,Integer,Integer,D) -> D from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R
--RExamples of setsubMatrix! from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--RsetsubMatrix!(m,2,2,matrix [[3,3],[3,3]])
--R
--E 2822

--S 2823 of 3320
)d op setsubmult!
--R 
--R
--RThere is one exposed function called setsubmult! :
--R   [1] (D,NonNegativeInteger) -> NonNegativeInteger from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of setsubmult! from InfinitlyClosePointCategory
--R
--E 2823

--S 2824 of 3320
)d op setsymbName!
--R 
--R
--RThere is one exposed function called setsymbName! :
--R   [1] (D,Symbol) -> Symbol from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of setsymbName! from InfinitlyClosePointCategory
--R
--E 2824

--S 2825 of 3320
)d op setTex!
--R 
--R
--RThere is one exposed function called setTex! :
--R   [1] (TexFormat,List(String)) -> List(String) from TexFormat
--R
--RExamples of setTex! from TexFormat
--R
--E 2825

--S 2826 of 3320
)d op setTopPredicate
--R 
--R
--RThere is one unexposed function called setTopPredicate :
--R   [1] (Pattern(D3),List(Symbol),Any) -> Pattern(D3) from Pattern(D3)
--R             if D3 has SETCAT
--R
--RExamples of setTopPredicate from Pattern
--R
--E 2826

--S 2827 of 3320
)d op setTower!
--R 
--R
--RThere is one exposed function called setTower! :
--R   [1] D -> Void from D if D has PACPERC
--R
--RExamples of setTower! from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--E 2827

--S 2828 of 3320
)d op setUnion
--R 
--R
--RThere is one exposed function called setUnion :
--R   [1] (List(D1),List(D1)) -> List(D1) from List(D1) if D1 has SETCAT 
--R            and D1 has TYPE
--R
--RExamples of setUnion from List
--R
--E 2828

--S 2829 of 3320
)d op setValue!
--R 
--R
--RThere is one unexposed function called setValue! :
--R   [1] (SplittingNode(D1,D2),D1) -> SplittingNode(D1,D2)
--R             from SplittingNode(D1,D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of setValue! from SplittingNode
--R
--E 2829

--S 2830 of 3320
)d op setVariableOrder
--R 
--R
--RThere are 2 exposed functions called setVariableOrder :
--R   [1] List(Symbol) -> Void from UserDefinedVariableOrdering
--R   [2] (List(Symbol),List(Symbol)) -> Void from 
--R            UserDefinedVariableOrdering
--R
--RExamples of setVariableOrder from UserDefinedVariableOrdering
--R
--E 2830

--S 2831 of 3320
)d op SFunction
--R 
--R
--RThere is one exposed function called SFunction :
--R   [1] List(Integer) -> SymmetricPolynomial(Fraction(Integer))
--R             from CycleIndicators
--R
--RExamples of SFunction from CycleIndicators
--R
--E 2831

--S 2832 of 3320
)d op sh
--R 
--R
--RThere are 2 exposed functions called sh :
--R   [1] (D,NonNegativeInteger) -> D from D
--R             if D has XFALG(D2,D3) and D2 has ORDSET and D3 has RING 
--R            and D3 has COMRING
--R   [2] (D,D) -> D from D
--R             if D has XFALG(D1,D2) and D1 has ORDSET and D2 has RING 
--R            and D2 has COMRING
--R
--RExamples of sh from XFreeAlgebra
--R
--E 2832

--S 2833 of 3320
)d op shade
--R 
--R
--RThere is one exposed function called shade :
--R   [1] Palette -> Integer from Palette
--R
--RThere is one unexposed function called shade :
--R   [1] Point(D1) -> D1 from PointPackage(D1) if D1 has RING
--R
--RExamples of shade from Palette
--R
--R
--RExamples of shade from PointPackage
--R
--E 2833

--S 2834 of 3320
)d op shallowCopy
--R 
--R
--RThere is one unexposed function called shallowCopy :
--R   [1] SubSpace(D1,D2) -> SubSpace(D1,D2) from SubSpace(D1,D2)
--R             if D1: PI and D2 has RING
--R
--RExamples of shallowCopy from SubSpace
--R
--E 2834

--S 2835 of 3320
)d op shallowExpand
--R 
--R
--RThere is one exposed function called shallowExpand :
--R   [1] FreeNilpotentLie(D2,D3,D4) -> OutputForm from FreeNilpotentLie(
--R            D2,D3,D4)
--R             if D2: NNI and D3: NNI and D4 has COMRING
--R
--RExamples of shallowExpand from FreeNilpotentLie
--R
--E 2835

--S 2836 of 3320
)d op shanksDiscLogAlgorithm
--R 
--R
--RThere is one unexposed function called shanksDiscLogAlgorithm :
--R   [1] (D3,D3,NonNegativeInteger) -> Union(NonNegativeInteger,"failed")
--R             from DiscreteLogarithmPackage(D3)
--R             if D3 has Join(Monoid,Finite)with
--R               D : (D3,Integer) -> D3
--R
--RExamples of shanksDiscLogAlgorithm from DiscreteLogarithmPackage
--R
--E 2836

--S 2837 of 3320
)d op shellSort
--R 
--R
--RThere is one exposed function called shellSort :
--R   [1] (((D3,D3) -> Boolean),D1) -> D1 from FiniteLinearAggregateSort(
--R            D3,D1)
--R             if D3 has TYPE and D1 has FiniteLinearAggregate(D3)with
--R                 shallowlyMutable
--R
--RExamples of shellSort from FiniteLinearAggregateSort
--R
--E 2837

--S 2838 of 3320
)d op shift
--R 
--R
--RThere are 4 exposed functions called shift :
--R   [1] (Float,Integer) -> Float from Float
--R   [2] (D,D) -> D from D if D has INS
--R   [3] (D,Integer) -> D from D if D has LOCPOWC(D2) and D2 has FIELD
--R         
--R   [4] (NonNegativeInteger,Integer) -> NonNegativeInteger
--R             from NonNegativeInteger
--R
--RThere are 2 unexposed functions called shift :
--R   [1] (MoebiusTransform(D1),D1) -> MoebiusTransform(D1)
--R             from MoebiusTransform(D1) if D1 has FIELD
--R   [2] D1 -> MoebiusTransform(D1) from MoebiusTransform(D1) if D1 has 
--R            FIELD
--R
--RExamples of shift from Float
--R
--R
--RExamples of shift from IntegerNumberSystem
--R
--R
--RExamples of shift from LocalPowerSeriesCategory
--R
--R
--RExamples of shift from MoebiusTransform
--R
--R
--RExamples of shift from NonNegativeInteger
--R
--E 2838

--S 2839 of 3320
)d op ShiftAction
--R 
--R
--RThere is one exposed function called ShiftAction :
--R   [1] (NonNegativeInteger,NonNegativeInteger,D3) -> D1
--R             from FractionFreeFastGaussian(D1,D3)
--R             if D1 has Join(IntegralDomain,GcdDomain) and D3 has AMR(D1
--R            ,NNI)
--R
--RExamples of ShiftAction from FractionFreeFastGaussian
--R
--E 2839

--S 2840 of 3320
)d op ShiftC
--R 
--R
--RThere is one exposed function called ShiftC :
--R   [1] NonNegativeInteger -> List(D3) from FractionFreeFastGaussian(D3,
--R            D4)
--R             if D3 has Join(IntegralDomain,GcdDomain) and D4 has AMR(D3
--R            ,NNI)
--R
--RExamples of ShiftC from FractionFreeFastGaussian
--R
--E 2840

--S 2841 of 3320
)d op shiftHP
--R 
--R
--RThere are 12 exposed functions called shiftHP :
--R   [1] List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(AlgebraicNumber) -> Stream(
--R            UnivariateFormalPowerSeries(AlgebraicNumber))),degreeStream: 
--R            Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(
--R            AlgebraicNumber)) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(AlgebraicNumber)))),exprStream: ((
--R            Expression(Integer),Symbol) -> Stream(Expression(Integer))),A: ((
--R            NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(
--R            AlgebraicNumber)) -> AlgebraicNumber),AF: ((NonNegativeInteger,
--R            NonNegativeInteger,UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(AlgebraicNumber))) -> 
--R            SparseUnivariatePolynomial(AlgebraicNumber)),AX: ((
--R            NonNegativeInteger,Symbol,Expression(Integer)) -> Expression(
--R            Integer)),C: (NonNegativeInteger -> List(AlgebraicNumber)))
--R             from GuessAlgebraicNumber
--R   [2] Symbol -> (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(AlgebraicNumber) -> Stream(
--R            UnivariateFormalPowerSeries(AlgebraicNumber))),degreeStream: 
--R            Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(
--R            AlgebraicNumber)) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(AlgebraicNumber)))),exprStream: ((
--R            Expression(Integer),Symbol) -> Stream(Expression(Integer))),A: ((
--R            NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(
--R            AlgebraicNumber)) -> AlgebraicNumber),AF: ((NonNegativeInteger,
--R            NonNegativeInteger,UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(AlgebraicNumber))) -> 
--R            SparseUnivariatePolynomial(AlgebraicNumber)),AX: ((
--R            NonNegativeInteger,Symbol,Expression(Integer)) -> Expression(
--R            Integer)),C: (NonNegativeInteger -> List(AlgebraicNumber))))
--R             from GuessAlgebraicNumber if AlgebraicNumber has RETRACT(
--R            SYMBOL)
--R   [3] List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(D3) -> Stream(
--R            UnivariateFormalPowerSeries(D3))),degreeStream: Stream(
--R            NonNegativeInteger),testStream: (UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D3)) -> Stream(
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(D3)))),
--R            exprStream: ((Expression(Integer),Symbol) -> Stream(Expression(
--R            Integer))),A: ((NonNegativeInteger,NonNegativeInteger,
--R            SparseUnivariatePolynomial(D3)) -> D3),AF: ((NonNegativeInteger,
--R            NonNegativeInteger,UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D3))) -> SparseUnivariatePolynomial(D3
--R            )),AX: ((NonNegativeInteger,Symbol,Expression(Integer)) -> 
--R            Expression(Integer)),C: (NonNegativeInteger -> List(D3)))
--R             from GuessFinite(D3)
--R             if D3 has Join(FiniteFieldCategory,ConvertibleTo(Integer))
--R            
--R   [4] Symbol -> (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(D3) -> Stream(
--R            UnivariateFormalPowerSeries(D3))),degreeStream: Stream(
--R            NonNegativeInteger),testStream: (UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D3)) -> Stream(
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(D3)))),
--R            exprStream: ((Expression(Integer),Symbol) -> Stream(Expression(
--R            Integer))),A: ((NonNegativeInteger,NonNegativeInteger,
--R            SparseUnivariatePolynomial(D3)) -> D3),AF: ((NonNegativeInteger,
--R            NonNegativeInteger,UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D3))) -> SparseUnivariatePolynomial(D3
--R            )),AX: ((NonNegativeInteger,Symbol,Expression(Integer)) -> 
--R            Expression(Integer)),C: (NonNegativeInteger -> List(D3))))
--R             from GuessFinite(D3)
--R             if D3 has RETRACT(SYMBOL) and D3 has Join(
--R            FiniteFieldCategory,ConvertibleTo(Integer))
--R   [5] List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(Fraction(Integer)) -> Stream(
--R            UnivariateFormalPowerSeries(Fraction(Integer)))),degreeStream: 
--R            Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Integer))) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(Fraction(Integer))))),exprStream: ((
--R            Expression(Integer),Symbol) -> Stream(Expression(Integer))),A: ((
--R            NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(
--R            Integer)) -> Integer),AF: ((NonNegativeInteger,NonNegativeInteger
--R            ,UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Integer)))) -> SparseUnivariatePolynomial(Fraction(Integer))),AX
--R            : ((NonNegativeInteger,Symbol,Expression(Integer)) -> Expression(
--R            Integer)),C: (NonNegativeInteger -> List(Integer)))
--R             from GuessInteger
--R   [6] Symbol -> (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(Fraction(Integer)) -> Stream(
--R            UnivariateFormalPowerSeries(Fraction(Integer)))),degreeStream: 
--R            Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Integer))) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(Fraction(Integer))))),exprStream: ((
--R            Expression(Integer),Symbol) -> Stream(Expression(Integer))),A: ((
--R            NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(
--R            Integer)) -> Integer),AF: ((NonNegativeInteger,NonNegativeInteger
--R            ,UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Integer)))) -> SparseUnivariatePolynomial(Fraction(Integer))),AX
--R            : ((NonNegativeInteger,Symbol,Expression(Integer)) -> Expression(
--R            Integer)),C: (NonNegativeInteger -> List(Integer))))
--R             from GuessInteger
--R             if Fraction(Integer) has RETRACT(SYMBOL) and Integer has 
--R            RETRACT(SYMBOL)
--R   [7] List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(D4) -> Stream(
--R            UnivariateFormalPowerSeries(D4))),degreeStream: Stream(
--R            NonNegativeInteger),testStream: (UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D4)) -> Stream(
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(D4)))),
--R            exprStream: ((D6,Symbol) -> Stream(D6)),A: ((NonNegativeInteger,
--R            NonNegativeInteger,SparseUnivariatePolynomial(D5)) -> D5),AF: ((
--R            NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries
--R            (SparseUnivariatePolynomial(D4))) -> SparseUnivariatePolynomial(
--R            D4)),AX: ((NonNegativeInteger,Symbol,D6) -> D6),C: (
--R            NonNegativeInteger -> List(D5)))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D7 has Join(OrderedSet,IntegralDomain) and D8: (D7 -> 
--R            D4) and D4 has FIELD and D5 has GCDDOM and D6 has Join(
--R            FunctionSpace(Integer),IntegralDomain,RetractableTo(D7),
--R            RetractableTo(Symbol),RetractableTo(Integer),
--R            CombinatorialOpsCategory,PartialDifferentialRing(Symbol))
--R            with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Booleanand D9: (D4 -> D6)
--R   [8] Symbol -> (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(D4) -> Stream(
--R            UnivariateFormalPowerSeries(D4))),degreeStream: Stream(
--R            NonNegativeInteger),testStream: (UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(D4)) -> Stream(
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(D4)))),
--R            exprStream: ((D6,Symbol) -> Stream(D6)),A: ((NonNegativeInteger,
--R            NonNegativeInteger,SparseUnivariatePolynomial(D5)) -> D5),AF: ((
--R            NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries
--R            (SparseUnivariatePolynomial(D4))) -> SparseUnivariatePolynomial(
--R            D4)),AX: ((NonNegativeInteger,Symbol,D6) -> D6),C: (
--R            NonNegativeInteger -> List(D5))))
--R             from Guess(D4,D5,D6,D7,D8,D9)
--R             if D7 has Join(OrderedSet,IntegralDomain) and D8: (D7 -> 
--R            D4) and D4 has RETRACT(SYMBOL) and D5 has RETRACT(SYMBOL) 
--R            and D4 has FIELD and D5 has GCDDOM and D6 has Join(
--R            FunctionSpace(Integer),IntegralDomain,RetractableTo(D7),
--R            RetractableTo(Symbol),RetractableTo(Integer),
--R            CombinatorialOpsCategory,PartialDifferentialRing(Symbol))
--R            with
--R               ?*? : (%,%) -> %
--R               ?/? : (%,%) -> %
--R               D : (%,%) -> %
--R               numerator : % -> %
--R               denominator : % -> %
--R               ground? : % -> Booleanand D9: (D4 -> D6)
--R   [9] List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(Fraction(Polynomial(Integer))) -> 
--R            Stream(UnivariateFormalPowerSeries(Fraction(Polynomial(Integer)))
--R            )),degreeStream: Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer)))) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(Fraction(Polynomial(Integer)))))),
--R            exprStream: ((Expression(Integer),Symbol) -> Stream(Expression(
--R            Integer))),A: ((NonNegativeInteger,NonNegativeInteger,
--R            SparseUnivariatePolynomial(Polynomial(Integer))) -> Polynomial(
--R            Integer)),AF: ((NonNegativeInteger,NonNegativeInteger,
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer))))) -> SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer)))),AX: ((NonNegativeInteger,Symbol,Expression
--R            (Integer)) -> Expression(Integer)),C: (NonNegativeInteger -> List
--R            (Polynomial(Integer))))
--R             from GuessPolynomial
--R   [10] Symbol -> (List(GuessOption) -> Record(guessStream: (
--R            UnivariateFormalPowerSeries(Fraction(Polynomial(Integer))) -> 
--R            Stream(UnivariateFormalPowerSeries(Fraction(Polynomial(Integer)))
--R            )),degreeStream: Stream(NonNegativeInteger),testStream: (
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer)))) -> Stream(UnivariateFormalPowerSeries(
--R            SparseUnivariatePolynomial(Fraction(Polynomial(Integer)))))),
--R            exprStream: ((Expression(Integer),Symbol) -> Stream(Expression(
--R            Integer))),A: ((NonNegativeInteger,NonNegativeInteger,
--R            SparseUnivariatePolynomial(Polynomial(Integer))) -> Polynomial(
--R            Integer)),AF: ((NonNegativeInteger,NonNegativeInteger,
--R            UnivariateFormalPowerSeries(SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer))))) -> SparseUnivariatePolynomial(Fraction(
--R            Polynomial(Integer)))),AX: ((NonNegativeInteger,Symbol,Expression
--R            (Integer)) -> Expression(Integer)),C: (NonNegativeInteger -> List
--R            (Polynomial(Integer)))))
--R             from GuessPolynomial
--R             if Fraction(Polynomial(Integer)) has RETRACT(SYMBOL) and 
--R            Polynomial(Integer) has RETRACT(SYMBOL)
--R   [11] List(GuessOption) -> HPSPEC from GuessUnivariatePolynomial(D3)
--R             if D3: SYMBOL
--R   [12] Symbol -> (List(GuessOption) -> HPSPEC)
--R             from GuessUnivariatePolynomial(D3) if D3: SYMBOL
--R
--RExamples of shiftHP from GuessAlgebraicNumber
--R
--R
--RExamples of shiftHP from GuessFinite
--R
--R
--RExamples of shiftHP from GuessInteger
--R
--R
--RExamples of shiftHP from Guess
--R
--R
--RExamples of shiftHP from GuessPolynomial
--R
--R
--RExamples of shiftHP from GuessUnivariatePolynomial
--R
--E 2841

--S 2842 of 3320
)d op shiftInfoRec
--R 
--R
--RThere is one exposed function called shiftInfoRec :
--R   [1] (BasicOperator,Symbol,D4) -> Record(max: Union(Integer,"failed")
--R            ,ord: Union(Integer,"failed"),ker: Kernel(D4))
--R             from RecurrenceOperator(D5,D4)
--R             if D5 has RING and D5 has Join(OrderedSet,IntegralDomain,
--R            ConvertibleTo(InputForm)) and D4 has Join(FunctionSpace(D5)
--R            ,AbelianMonoid,RetractableTo(Integer),RetractableTo(Symbol)
--R            ,PartialDifferentialRing(Symbol),CombinatorialOpsCategory)
--R            
--R
--RExamples of shiftInfoRec from RecurrenceOperator
--R
--E 2842

--S 2843 of 3320
)d op shiftLeft
--R 
--R
--RThere is one exposed function called shiftLeft :
--R   [1] (D,NonNegativeInteger) -> D from D if D has UPOLYC(D2) and D2
--R             has RING
--R
--RExamples of shiftLeft from UnivariatePolynomialCategory
--R
--E 2843

--S 2844 of 3320
)d op shiftRight
--R 
--R
--RThere is one exposed function called shiftRight :
--R   [1] (D,NonNegativeInteger) -> D from D if D has UPOLYC(D2) and D2
--R             has RING
--R
--RExamples of shiftRight from UnivariatePolynomialCategory
--R
--E 2844

--S 2845 of 3320
)d op shiftRoots
--R 
--R
--RThere is one unexposed function called shiftRoots :
--R   [1] (D1,D2) -> D1 from GaloisGroupPolynomialUtilities(D2,D1)
--R             if D2 has RING and D1 has UPOLYC(D2)
--R
--RExamples of shiftRoots from GaloisGroupPolynomialUtilities
--R
--E 2845

--S 2846 of 3320
)d op show
--R 
--R
--RThere is one unexposed function called show :
--R   [1] (TwoDimensionalViewport,PositiveInteger,String) -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of show from TwoDimensionalViewport
--R
--E 2846

--S 2847 of 3320
)d op showAll?
--R 
--R
--RThere is one exposed function called showAll? :
--R   [1]  -> Boolean from Stream(D2) if D2 has SETCAT and D2 has TYPE
--R
--RExamples of showAll? from Stream
--R
--E 2847

--S 2848 of 3320 done
)d op showAllElements
--R 
--R
--RThere is one exposed function called showAllElements :
--R   [1] Stream(D2) -> OutputForm from Stream(D2) if D2 has SETCAT and D2
--R             has TYPE
--R
--RExamples of showAllElements from Stream
--R
--Rm:=[1,2,3,4,5,6,7,8,9,10,11,12] 
--Rn:=m::Stream(PositiveInteger) 
--RshowAllElements n
--R
--E 2848

--S 2849 of 3320
)d op showArrayValues
--R 
--R
--RThere is one exposed function called showArrayValues :
--R   [1] Boolean -> Boolean from Result
--R
--RExamples of showArrayValues from Result
--R
--E 2849

--S 2850 of 3320
)d op showAttributes
--R 
--R
--RThere is one exposed function called showAttributes :
--R   [1] Record(var: Symbol,fn: Expression(DoubleFloat),range: Segment(
--R            OrderedCompletion(DoubleFloat)),abserr: DoubleFloat,relerr: 
--R            DoubleFloat) -> Union(Record(endPointContinuity: Union(continuous
--R            : Continuous at the end points,lowerSingular: 
--R            There is a singularity at the lower end point,upperSingular: 
--R            There is a singularity at the upper end point,bothSingular: 
--R            There are singularities at both end points,notEvaluated: 
--R            End point continuity not yet evaluated),singularitiesStream: 
--R            Union(str: Stream(DoubleFloat),notEvaluated: 
--R            Internal singularities not yet evaluated),range: Union(finite: 
--R            The range is finite,lowerInfinite: 
--R            The bottom of range is infinite,upperInfinite: 
--R            The top of range is infinite,bothInfinite: 
--R            Both top and bottom points are infinite,notEvaluated: 
--R            Range not yet evaluated)),"failed")
--R             from IntegrationFunctionsTable
--R
--RExamples of showAttributes from IntegrationFunctionsTable
--R
--E 2850

--S 2851 of 3320
)d op showClipRegion
--R 
--R
--RThere is one exposed function called showClipRegion :
--R   [1] (ThreeDimensionalViewport,String) -> Void from 
--R            ThreeDimensionalViewport
--R
--RExamples of showClipRegion from ThreeDimensionalViewport
--R
--E 2851

--S 2852 of 3320
)d op showFortranOutputStack
--R 
--R
--RThere is one exposed function called showFortranOutputStack :
--R   [1]  -> Stack(String) from FortranOutputStackPackage
--R
--RExamples of showFortranOutputStack from FortranOutputStackPackage
--R
--E 2852

--S 2853 of 3320
)d op showIntensityFunctions
--R 
--R
--RThere is one exposed function called showIntensityFunctions :
--R   [1] Record(xinit: DoubleFloat,xend: DoubleFloat,fn: Vector(
--R            Expression(DoubleFloat)),yinit: List(DoubleFloat),intvals: List(
--R            DoubleFloat),g: Expression(DoubleFloat),abserr: DoubleFloat,
--R            relerr: DoubleFloat) -> Union(Record(stiffness: Float,stability: 
--R            Float,expense: Float,accuracy: Float,intermediateResults: Float),
--R            "failed")
--R             from ODEIntensityFunctionsTable
--R
--RExamples of showIntensityFunctions from ODEIntensityFunctionsTable
--R
--E 2853

--S 2854 of 3320
)d op showRegion
--R 
--R
--RThere is one exposed function called showRegion :
--R   [1] (ThreeDimensionalViewport,String) -> Void from 
--R            ThreeDimensionalViewport
--R
--RExamples of showRegion from ThreeDimensionalViewport
--R
--E 2854

--S 2855 of 3320
)d op showScalarValues
--R 
--R
--RThere is one exposed function called showScalarValues :
--R   [1] Boolean -> Boolean from Result
--R
--RExamples of showScalarValues from Result
--R
--E 2855

--S 2856 of 3320
)d op showTheFTable
--R 
--R
--RThere is one exposed function called showTheFTable :
--R   [1]  -> IntegrationFunctionsTable from IntegrationFunctionsTable
--R
--RExamples of showTheFTable from IntegrationFunctionsTable
--R
--E 2856

--S 2857 of 3320
)d op showTheIFTable
--R 
--R
--RThere is one exposed function called showTheIFTable :
--R   [1]  -> ODEIntensityFunctionsTable from ODEIntensityFunctionsTable
--R         
--R
--RExamples of showTheIFTable from ODEIntensityFunctionsTable
--R
--E 2857

--S 2858 of 3320
)d op showTheRoutinesTable
--R 
--R
--RThere is one exposed function called showTheRoutinesTable :
--R   [1]  -> RoutinesTable from RoutinesTable
--R
--RExamples of showTheRoutinesTable from RoutinesTable
--R
--E 2858

--S 2859 of 3320
)d op showTheSymbolTable
--R 
--R
--RThere is one exposed function called showTheSymbolTable :
--R   [1]  -> TheSymbolTable from TheSymbolTable
--R
--RExamples of showTheSymbolTable from TheSymbolTable
--R
--E 2859

--S 2860 of 3320 done
)d op showTypeInOutput
--R 
--R
--RThere is one exposed function called showTypeInOutput :
--R   [1] Boolean -> String from Any
--R
--RExamples of showTypeInOutput from Any
--R
--Ru:=[1,7.2,3/2,x**2,"wally"] 
--RshowTypeInOutput(true) 
--Ru
--R
--E 2860

--S 2861 of 3320
)d op shrinkable
--R 
--R
--RThere is one exposed function called shrinkable :
--R   [1] Boolean -> Boolean from FlexibleArray(D2) if D2 has TYPE
--R
--RThere is one unexposed function called shrinkable :
--R   [1] Boolean -> Boolean from IndexedFlexibleArray(D2,D3) if D2 has 
--R            TYPE and D3: INT
--R
--RExamples of shrinkable from FlexibleArray
--R
--R
--RExamples of shrinkable from IndexedFlexibleArray
--R
--RT1:=IndexedFlexibleArray(Integer,20) 
--Rshrinkable(false)$T1
--R
--E 2861

--S 2862 of 3320
)d op shuffle
--R 
--R
--RThere is one exposed function called shuffle :
--R   [1] (List(Integer),List(Integer)) -> Stream(List(Integer))
--R             from PartitionsAndPermutations
--R
--RExamples of shuffle from PartitionsAndPermutations
--R
--E 2862

--S 2863 of 3320
)d op shufflein
--R 
--R
--RThere is one exposed function called shufflein :
--R   [1] (List(Integer),Stream(List(Integer))) -> Stream(List(Integer))
--R             from PartitionsAndPermutations
--R
--RExamples of shufflein from PartitionsAndPermutations
--R
--E 2863

--S 2864 of 3320
)d op Si
--R 
--R
--RThere is one exposed function called Si :
--R   [1] D -> D from D if D has LFCAT
--R
--RThere is one unexposed function called Si :
--R   [1] D1 -> D1 from LiouvillianFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory,
--R            TranscendentalFunctionCategory)
--R
--RExamples of Si from LiouvillianFunctionCategory
--R
--R
--RExamples of Si from LiouvillianFunction
--R
--E 2864

--S 2865 of 3320
)d op sign
--R 
--R
--RThere are 9 exposed functions called sign :
--R   [1] D -> Integer from D if D has ORDRING
--R   [2] Permutation(D2) -> Integer from Permutation(D2) if D2 has SETCAT
--R            
--R   [3] (D2,D) -> Integer from D
--R             if D has RRCC(D3,D2) and D3 has Join(OrderedRing,Field) 
--R            and D2 has UPOLYC(D3)
--R   [4] D2 -> Union(Integer,"failed") from ElementaryFunctionSign(D3,D2)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),GcdDomain) and 
--R            D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D3))
--R   [5] (D2,Symbol,OrderedCompletion(D2)) -> Union(Integer,"failed")
--R             from ElementaryFunctionSign(D5,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D5)) and D5
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer),GcdDomain)
--R   [6] (D2,Symbol,D2,String) -> Union(Integer,"failed")
--R             from ElementaryFunctionSign(D5,D2)
--R             if D5 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),GcdDomain) and 
--R            D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D5))
--R   [7] Fraction(Polynomial(D3)) -> Union(Integer,"failed")
--R             from RationalFunctionSign(D3) if D3 has GCDDOM
--R   [8] (Fraction(Polynomial(D5)),Symbol,OrderedCompletion(Fraction(
--R            Polynomial(D5)))) -> Union(Integer,"failed")
--R             from RationalFunctionSign(D5) if D5 has GCDDOM
--R   [9] (Fraction(Polynomial(D5)),Symbol,Fraction(Polynomial(D5)),String
--R            ) -> Union(Integer,"failed")
--R             from RationalFunctionSign(D5) if D5 has GCDDOM
--R
--RThere is one unexposed function called sign :
--R   [1] D2 -> Union(Integer,"failed") from ToolsForSign(D2) if D2 has 
--R            RING
--R
--RExamples of sign from OrderedRing
--R
--R
--RExamples of sign from Permutation
--R
--R
--RExamples of sign from RealRootCharacterizationCategory
--R
--R
--RExamples of sign from ElementaryFunctionSign
--R
--R
--RExamples of sign from RationalFunctionSign
--R
--R
--RExamples of sign from ToolsForSign
--R
--E 2865

--S 2866 of 3320
)d op signAround
--R 
--R
--RThere are 3 unexposed functions called signAround :
--R   [1] (D2,Integer,(D4 -> Union(Integer,"failed"))) -> Union(Integer,
--R            "failed")
--R             from InnerPolySign(D4,D2) if D4 has RING and D2 has UPOLYC
--R            (D4)
--R   [2] (D2,D3,Integer,(D3 -> Union(Integer,"failed"))) -> Union(Integer
--R            ,"failed")
--R             from InnerPolySign(D3,D2) if D3 has RING and D2 has UPOLYC
--R            (D3)
--R   [3] (D2,D3,(D3 -> Union(Integer,"failed"))) -> Union(Integer,
--R            "failed")
--R             from InnerPolySign(D3,D2) if D3 has RING and D2 has UPOLYC
--R            (D3)
--R
--RExamples of signAround from InnerPolySign
--R
--E 2866

--S 2867 of 3320
)d op simpleBounds?
--R 
--R
--RThere is one exposed function called simpleBounds? :
--R   [1] List(Expression(DoubleFloat)) -> Boolean from e04AgentsPackage
--R         
--R
--RExamples of simpleBounds? from e04AgentsPackage
--R
--E 2867

--S 2868 of 3320
)d op simplify
--R 
--R
--RThere are 2 exposed functions called simplify :
--R   [1] AlgebraicNumber -> Expression(Integer)
--R             from SimplifyAlgebraicNumberConvertPackage
--R   [2] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RThere is one unexposed function called simplify :
--R   [1] QuasiAlgebraicSet(D1,D2,D3,D4) -> QuasiAlgebraicSet(D1,D2,D3,D4)
--R             from QuasiAlgebraicSet(D1,D2,D3,D4)
--R             if D1 has CHARZ and D1 has EUCDOM and D1 has GCDDOM and D2
--R             has ORDSET and D3 has OAMONS and D4 has POLYCAT(D1,D3,D2)
--R            
--R
--RExamples of simplify from QuasiAlgebraicSet
--R
--R
--RExamples of simplify from SimplifyAlgebraicNumberConvertPackage
--R
--R
--RExamples of simplify from TranscendentalManipulations
--R
--E 2868

--S 2869 of 3320
)d op simplifyExp
--R 
--R
--RThere is one exposed function called simplifyExp :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of simplifyExp from TranscendentalManipulations
--R
--E 2869

--S 2870 of 3320
)d op simplifyLog
--R 
--R
--RThere is one exposed function called simplifyLog :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of simplifyLog from TranscendentalManipulations
--R
--E 2870

--S 2871 of 3320
)d op simplifyPower
--R 
--R
--RThere is one exposed function called simplifyPower :
--R   [1] (Expression(D2),Integer) -> Expression(D2) from Expression(D2)
--R             if D2 has INTDOM and D2 has ORDSET
--R
--RExamples of simplifyPower from Expression
--R
--E 2871

--S 2872 of 3320
)d op simpson
--R 
--R
--RThere is one exposed function called simpson :
--R   [1] ((Float -> Float),Float,Float,Float,Float,Integer,Integer) -> 
--R            Record(value: Float,error: Float,totalpts: Integer,success: 
--R            Boolean)
--R             from NumericalQuadrature
--R
--RExamples of simpson from NumericalQuadrature
--R
--E 2872

--S 2873 of 3320
)d op simpsono
--R 
--R
--RThere is one exposed function called simpsono :
--R   [1] ((Float -> Float),Float,Float,Float,Float,Integer,Integer) -> 
--R            Record(value: Float,error: Float,totalpts: Integer,success: 
--R            Boolean)
--R             from NumericalQuadrature
--R
--RExamples of simpsono from NumericalQuadrature
--R
--E 2873

--S 2874 of 3320
)d op sin
--R 
--R
--RThere are 2 exposed functions called sin :
--R   [1] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R   [2] D -> D from D if D has TRIGCAT
--R
--RThere are 6 unexposed functions called sin :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] D1 -> FourierComponent(D1) from FourierComponent(D1) if D1 has 
--R            ORDSET
--R   [5] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [6] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of sin from ElementaryFunction
--R
--R
--RExamples of sin from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of sin from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of sin from FourierComponent
--R
--R
--RExamples of sin from FortranExpression
--R
--R
--RExamples of sin from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of sin from StreamTranscendentalFunctions
--R
--R
--RExamples of sin from TrigonometricFunctionCategory
--R
--E 2874

--S 2875 of 3320
)d op sin?
--R 
--R
--RThere is one unexposed function called sin? :
--R   [1] FourierComponent(D2) -> Boolean from FourierComponent(D2) if D2
--R             has ORDSET
--R
--RExamples of sin? from FourierComponent
--R
--E 2875

--S 2876 of 3320
)d op sin2csc
--R 
--R
--RThere is one exposed function called sin2csc :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of sin2csc from TranscendentalManipulations
--R
--E 2876

--S 2877 of 3320
)d op sincos
--R 
--R
--RThere is one unexposed function called sincos :
--R   [1] Stream(D3) -> Record(sin: Stream(D3),cos: Stream(D3))
--R             from StreamTranscendentalFunctions(D3) if D3 has ALGEBRA(
--R            FRAC(INT))
--R
--RExamples of sincos from StreamTranscendentalFunctions
--R
--E 2877

--S 2878 of 3320
)d op singleFactorBound
--R 
--R
--RThere are 2 unexposed functions called singleFactorBound :
--R   [1] (D2,NonNegativeInteger) -> Integer
--R             from GaloisGroupFactorizationUtilities(D4,D2,D5)
--R             if D4 has RING and D2 has UPOLYC(D4) and D5 has Join(
--R            FloatingPointSystem,RetractableTo(D4),Field,
--R            TranscendentalFunctionCategory,ElementaryFunctionCategory)
--R            
--R   [2] D2 -> Integer from GaloisGroupFactorizationUtilities(D3,D2,D4)
--R             if D3 has RING and D2 has UPOLYC(D3) and D4 has Join(
--R            FloatingPointSystem,RetractableTo(D3),Field,
--R            TranscendentalFunctionCategory,ElementaryFunctionCategory)
--R            
--R
--RExamples of singleFactorBound from GaloisGroupFactorizationUtilities
--R
--E 2878

--S 2879 of 3320
)d op singRicDE
--R 
--R
--RThere are 2 unexposed functions called singRicDE :
--R   [1] (D2,((D6,SparseUnivariatePolynomial(D6)) -> List(D6)),(D6 -> 
--R            Factored(D6))) -> List(Record(frac: Fraction(D6),eq: D2))
--R             from PrimitiveRatRicDE(D5,D6,D2,D7)
--R             if D6 has UPOLYC(D5) and D5 has Join(Field,
--R            CharacteristicZero,RetractableTo(Fraction(Integer))) and D2
--R             has LODOCAT(D6) and D7 has LODOCAT(FRAC(D6))
--R   [2] (LinearOrdinaryDifferentialOperator2(D5,Fraction(D5)),(D5 -> 
--R            Factored(D5))) -> List(Record(frac: Fraction(D5),eq: 
--R            LinearOrdinaryDifferentialOperator2(D5,Fraction(D5))))
--R             from RationalRicDE(D4,D5)
--R             if D5 has UPOLYC(D4) and D4 has Join(Field,
--R            CharacteristicZero,RetractableTo(Integer),RetractableTo(
--R            Fraction(Integer)))
--R
--RExamples of singRicDE from PrimitiveRatRicDE
--R
--R
--RExamples of singRicDE from RationalRicDE
--R
--E 2879

--S 2880 of 3320
)d op singular?
--R 
--R
--RThere are 2 exposed functions called singular? :
--R   [1] D2 -> Boolean from D
--R             if D has FFCAT(D3,D2,D4) and D3 has UFD and D2 has UPOLYC(
--R            D3) and D4 has UPOLYC(FRAC(D2))
--R   [2] D2 -> Boolean from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of singular? from FunctionFieldCategory
--R
--E 2880

--S 2881 of 3320
)d op singularAtInfinity?
--R 
--R
--RThere is one exposed function called singularAtInfinity? :
--R   [1]  -> Boolean from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of singularAtInfinity? from FunctionFieldCategory
--R
--E 2881

--S 2882 of 3320
)d op singularitiesOf
--R 
--R
--RThere are 3 exposed functions called singularitiesOf :
--R   [1] Record(var: Symbol,fn: Expression(DoubleFloat),range: Segment(
--R            OrderedCompletion(DoubleFloat)),abserr: DoubleFloat,relerr: 
--R            DoubleFloat) -> Stream(DoubleFloat)
--R             from d01AgentsPackage
--R   [2] (Expression(DoubleFloat),List(Symbol),Segment(OrderedCompletion(
--R            DoubleFloat))) -> Stream(DoubleFloat)
--R             from ExpertSystemContinuityPackage
--R   [3] (Vector(Expression(DoubleFloat)),List(Symbol),Segment(
--R            OrderedCompletion(DoubleFloat))) -> Stream(DoubleFloat)
--R             from ExpertSystemContinuityPackage
--R
--RExamples of singularitiesOf from d01AgentsPackage
--R
--R
--RExamples of singularitiesOf from ExpertSystemContinuityPackage
--R
--E 2882

--S 2883 of 3320
)d op singularPoints
--R 
--R
--RThere are 4 exposed functions called singularPoints :
--R   [1]  -> List(D10)
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R             if D6 has FIELD and D7: LIST(SYMBOL) and D8 has POLYCAT(D6
--R            ,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI) and D10 has 
--R            PRSPCAT(D6) and D11 has LOCPOWC(D6) and D12 has PLACESC(D6,
--R            D11) and D1 has DIVCAT(D12) and D2 has INFCLCT(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D4) and D4 has BLMETCT and D3 has DSTRCAT(D2
--R            )
--R   [2]  -> List(ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField(
--R            D2))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [3]  -> List(ProjectivePlane(D2))
--R             from PackageForAlgebraicFunctionField(D2,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R   [4] D2 -> List(D6) from ProjectiveAlgebraicSetPackage(D3,D4,D2,D5,D6
--R            )
--R             if D3 has FIELD and D4: LIST(SYMBOL) and D5 has DIRPCAT(#(
--R            D4),NNI) and D2 has POLYCAT(D3,D5,OVAR(D4)) and D6 has 
--R            PRSPCAT(D3)
--R
--RExamples of singularPoints from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of singularPoints from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of singularPoints from PackageForAlgebraicFunctionField
--R
--R
--RExamples of singularPoints from ProjectiveAlgebraicSetPackage
--R
--E 2883

--S 2884 of 3320
)d op singularPointsWithRestriction
--R 
--R
--RThere is one exposed function called singularPointsWithRestriction :
--R   [1] (D2,List(D2)) -> List(D7)
--R             from ProjectiveAlgebraicSetPackage(D4,D5,D2,D6,D7)
--R             if D2 has POLYCAT(D4,D6,OVAR(D5)) and D6 has DIRPCAT(#(D5)
--R            ,NNI) and D4 has FIELD and D5: LIST(SYMBOL) and D7 has 
--R            PRSPCAT(D4)
--R
--RExamples of singularPointsWithRestriction from ProjectiveAlgebraicSetPackage
--R
--E 2884

--S 2885 of 3320
)d op sinh
--R 
--R
--RThere are 2 exposed functions called sinh :
--R   [1] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R   [2] D -> D from D if D has HYPCAT
--R
--RThere are 5 unexposed functions called sinh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of sinh from ElementaryFunction
--R
--R
--RExamples of sinh from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of sinh from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of sinh from FortranExpression
--R
--R
--RExamples of sinh from HyperbolicFunctionCategory
--R
--R
--RExamples of sinh from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of sinh from StreamTranscendentalFunctions
--R
--E 2885

--S 2886 of 3320
)d op sinh2csch
--R 
--R
--RThere is one exposed function called sinh2csch :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of sinh2csch from TranscendentalManipulations
--R
--E 2886

--S 2887 of 3320
)d op sinhcosh
--R 
--R
--RThere is one unexposed function called sinhcosh :
--R   [1] Stream(D3) -> Record(sinh: Stream(D3),cosh: Stream(D3))
--R             from StreamTranscendentalFunctions(D3) if D3 has ALGEBRA(
--R            FRAC(INT))
--R
--RExamples of sinhcosh from StreamTranscendentalFunctions
--R
--E 2887

--S 2888 of 3320
)d op sinhIfCan
--R 
--R
--RThere is one exposed function called sinhIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of sinhIfCan from PartialTranscendentalFunctions
--R
--E 2888

--S 2889 of 3320
)d op sinIfCan
--R 
--R
--RThere is one exposed function called sinIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of sinIfCan from PartialTranscendentalFunctions
--R
--E 2889

--S 2890 of 3320
)d op size
--R 
--R
--RThere are 4 exposed functions called size :
--R   [1] D -> NonNegativeInteger from D
--R             if D has FAMONC(D2,D3) and D2 has SETCAT and D3 has CABMON
--R            
--R   [2]  -> NonNegativeInteger from D if D has FINITE
--R   [3]  -> Integer from RandomNumberSource
--R   [4] RightOpenIntervalRootCharacterization(D1,D2) -> D1
--R             from RightOpenIntervalRootCharacterization(D1,D2)
--R             if D1 has Join(OrderedRing,Field) and D2 has UPOLYC(D1)
--R         
--R
--RThere are 8 unexposed functions called size :
--R   [1]  -> NonNegativeInteger from DirectProductCategory&(D2,D3,D4)
--R             if D3: NNI and D4 has TYPE and D2 has DIRPCAT(D3,D4)
--R   [2]  -> NonNegativeInteger from FiniteAlgebraicExtensionField&(D2,D3
--R            )
--R             if D3 has FIELD and D2 has FAXF(D3)
--R   [3] FreeGroup(D2) -> NonNegativeInteger from FreeGroup(D2) if D2
--R             has SETCAT
--R   [4] FreeMonoid(D2) -> NonNegativeInteger from FreeMonoid(D2) if D2
--R             has SETCAT
--R   [5]  -> NonNegativeInteger from FiniteSetAggregate&(D2,D3)
--R             if D3 has SETCAT and D2 has FSAGG(D3)
--R   [6] ListMonoidOps(D2,D3,D4) -> NonNegativeInteger
--R             from ListMonoidOps(D2,D3,D4)
--R             if D2 has SETCAT and D3 has ABELMON and D4: D3
--R   [7]  -> NonNegativeInteger from MonogenicAlgebra&(D2,D3,D4)
--R             if D3 has COMRING and D4 has UPOLYC(D3) and D2 has MONOGEN
--R            (D3,D4)
--R   [8] OrderedFreeMonoid(D2) -> NonNegativeInteger from 
--R            OrderedFreeMonoid(D2)
--R             if D2 has ORDSET
--R
--RExamples of size from DirectProductCategory&
--R
--R
--RExamples of size from FreeAbelianMonoidCategory
--R
--R
--RExamples of size from FiniteAlgebraicExtensionField&
--R
--R
--RExamples of size from FreeGroup
--R
--R
--RExamples of size from Finite
--R
--R
--RExamples of size from FreeMonoid
--R
--R
--RExamples of size from FiniteSetAggregate&
--R
--R
--RExamples of size from ListMonoidOps
--R
--R
--RExamples of size from MonogenicAlgebra&
--R
--R
--RExamples of size from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--Rsize(m1,2)
--R
--R
--RExamples of size from RandomNumberSource
--R
--R
--RExamples of size from RightOpenIntervalRootCharacterization
--R
--E 2890

--S 2891 of 3320
)d op size?
--R 
--R
--RThere are 6 exposed functions called size? :
--R   [1] (D,NonNegativeInteger) -> Boolean from D if D has AGG
--R   [2] (ArrayStack(D3),NonNegativeInteger) -> Boolean from ArrayStack(
--R            D3)
--R             if D3 has SETCAT
--R   [3] (Dequeue(D3),NonNegativeInteger) -> Boolean from Dequeue(D3) if 
--R            D3 has SETCAT
--R   [4] (Heap(D3),NonNegativeInteger) -> Boolean from Heap(D3) if D3
--R             has ORDSET
--R   [5] (Queue(D3),NonNegativeInteger) -> Boolean from Queue(D3) if D3
--R             has SETCAT
--R   [6] (Stack(D3),NonNegativeInteger) -> Boolean from Stack(D3) if D3
--R             has SETCAT
--R
--RExamples of size? from Aggregate
--R
--R
--RExamples of size? from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rsize?(a,5)
--R
--R
--RExamples of size? from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rsize?(a,5)
--R
--R
--RExamples of size? from Heap
--R
--Ra:Heap INT:= heap [1,2,3,4,5] 
--Rsize?(a,5)
--R
--R
--RExamples of size? from Queue
--R
--Ra:Queue INT:= queue [1,2,3,4,5] 
--Rsize?(a,5)
--R
--R
--RExamples of size? from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rsize?(a,5)
--R
--E 2891

--S 2892 of 3320
)d op sizeLess?
--R 
--R
--RThere is one exposed function called sizeLess? :
--R   [1] (D,D) -> Boolean from D if D has EUCDOM
--R
--RExamples of sizeLess? from EuclideanDomain
--R
--E 2892

--S 2893 of 3320
)d op sizeMultiplication
--R 
--R
--RThere is one exposed function called sizeMultiplication :
--R   [1]  -> NonNegativeInteger from FiniteFieldNormalBasis(D2,D3) if D2
--R            : PI and D3: PI
--R
--RThere are 3 unexposed functions called sizeMultiplication :
--R   [1] Vector(List(Record(value: D3,index: SingleInteger))) -> 
--R            NonNegativeInteger
--R             from FiniteFieldFunctions(D3) if D3 has FFIELDC
--R   [2]  -> NonNegativeInteger
--R             from FiniteFieldNormalBasisExtensionByPolynomial(D2,D3)
--R             if D2 has FFIELDC and D3: Union(SUP(D2),VECTOR(LIST(
--R            Record(value: D2,index: SingleInteger))))
--R   [3]  -> NonNegativeInteger from FiniteFieldNormalBasisExtension(D2,
--R            D3)
--R             if D2 has FFIELDC and D3: PI
--R
--RExamples of sizeMultiplication from FiniteFieldFunctions
--R
--R
--RExamples of sizeMultiplication from FiniteFieldNormalBasis
--R
--R
--RExamples of sizeMultiplication from FiniteFieldNormalBasisExtensionByPolynomial
--R
--R
--RExamples of sizeMultiplication from FiniteFieldNormalBasisExtension
--R
--E 2893

--S 2894 of 3320
)d op sizePascalTriangle
--R 
--R
--RThere is one unexposed function called sizePascalTriangle :
--R   [1]  -> NonNegativeInteger from GaloisGroupUtilities(D2) if D2 has 
--R            RING
--R
--RExamples of sizePascalTriangle from GaloisGroupUtilities
--R
--E 2894

--S 2895 of 3320
)d op skewSFunction
--R 
--R
--RThere is one exposed function called skewSFunction :
--R   [1] (List(Integer),List(Integer)) -> SymmetricPolynomial(Fraction(
--R            Integer))
--R             from CycleIndicators
--R
--RExamples of skewSFunction from CycleIndicators
--R
--E 2895

--S 2896 of 3320
)d op slash
--R 
--R
--RThere is one unexposed function called slash :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of slash from OutputForm
--R
--E 2896

--S 2897 of 3320
)d op slex
--R 
--R
--RThere is one unexposed function called slex :
--R   [1] List(D3) -> List(List(D3)) from TableauxBumpers(D3) if D3 has 
--R            ORDSET
--R
--RExamples of slex from TableauxBumpers
--R
--E 2897

--S 2898 of 3320
)d op slope
--R 
--R
--RThere are 2 exposed functions called slope :
--R   [1] (D2,D2) -> Record(height: Integer,base: Integer,quotient: 
--R            Integer,reste: Integer,type: Union(left,center,right,vertical,
--R            horizontal))
--R             from NewtonPolygon(D3,D2,D4,D5)
--R             if D3 has RING and D4 has DIRPCAT(D5,NNI) and D5: NNI and 
--R            D2 has FAMR(D3,D4)
--R   [2] List(D4) -> Record(height: Integer,base: Integer,quotient: 
--R            Integer,reste: Integer,type: Union(left,center,right,vertical,
--R            horizontal))
--R             from NewtonPolygon(D3,D4,D5,D6)
--R             if D4 has FAMR(D3,D5) and D5 has DIRPCAT(D6,NNI) and D6: 
--R            NNI and D3 has RING
--R
--RExamples of slope from NewtonPolygon
--R
--E 2898

--S 2899 of 3320
)d op smaller?
--R 
--R
--RThere is one exposed function called smaller? :
--R   [1] (D,D) -> Boolean from D if D has COMPAR
--R
--RExamples of smaller? from Comparable
--R
--E 2899

--S 2900 of 3320
)d op smith
--R 
--R
--RThere is one exposed function called smith :
--R   [1] D1 -> D1 from SmithNormalForm(D2,D3,D4,D1)
--R             if D2 has EUCDOM and D3 has FLAGG(D2) and D4 has FLAGG(D2)
--R            and D1 has MATCAT(D2,D3,D4)
--R
--RExamples of smith from SmithNormalForm
--R
--E 2900

--S 2901 of 3320
)d op sn
--R 
--R
--RThere is one unexposed function called sn :
--R   [1] (D1,D2) -> D1 from EllipticFunctionsUnivariateTaylorSeries(D2,D1
--R            )
--R             if D2 has FIELD and D1 has UTSCAT(D2)
--R
--RExamples of sn from EllipticFunctionsUnivariateTaylorSeries
--R
--E 2901

--S 2902 of 3320
)d op sncndn
--R 
--R
--RThere is one unexposed function called sncndn :
--R   [1] (Stream(D3),D3) -> List(Stream(D3))
--R             from EllipticFunctionsUnivariateTaylorSeries(D3,D4)
--R             if D3 has FIELD and D4 has UTSCAT(D3)
--R
--RExamples of sncndn from EllipticFunctionsUnivariateTaylorSeries
--R
--E 2902

--S 2903 of 3320
)d op socf2socdf
--R 
--R
--RThere is one exposed function called socf2socdf :
--R   [1] Segment(OrderedCompletion(Float)) -> Segment(OrderedCompletion(
--R            DoubleFloat))
--R             from ExpertSystemToolsPackage
--R
--RExamples of socf2socdf from ExpertSystemToolsPackage
--R
--E 2903

--S 2904 of 3320
)d op solid
--R 
--R
--RThere is one unexposed function called solid :
--R   [1] (SubSpaceComponentProperty,Boolean) -> Boolean
--R             from SubSpaceComponentProperty
--R
--RExamples of solid from SubSpaceComponentProperty
--R
--E 2904

--S 2905 of 3320
)d op solid?
--R 
--R
--RThere is one unexposed function called solid? :
--R   [1] SubSpaceComponentProperty -> Boolean from 
--R            SubSpaceComponentProperty
--R
--RExamples of solid? from SubSpaceComponentProperty
--R
--E 2905

--S 2906 of 3320
)d op solve
--R 
--R
--RThere are 45 exposed functions called solve :
--R   [1] (List(Fraction(Polynomial(Integer))),D3) -> List(List(Equation(
--R            Polynomial(D3))))
--R             from FloatingRealPackage(D3) if D3 has Join(OrderedRing,
--R            Field)
--R   [2] (List(Equation(Fraction(Polynomial(Integer)))),D3) -> List(List(
--R            Equation(Polynomial(D3))))
--R             from FloatingRealPackage(D3) if D3 has Join(OrderedRing,
--R            Field)
--R   [3] (Fraction(Polynomial(Integer)),D3) -> List(Equation(Polynomial(
--R            D3)))
--R             from FloatingRealPackage(D3) if D3 has Join(OrderedRing,
--R            Field)
--R   [4] (Equation(Fraction(Polynomial(Integer))),D3) -> List(Equation(
--R            Polynomial(D3)))
--R             from FloatingRealPackage(D3) if D3 has Join(OrderedRing,
--R            Field)
--R   [5] (D2,D3,Symbol) -> Union(Record(particular: D3,basis: List(D3)),
--R            "failed")
--R             from ElementaryFunctionLODESolver(D5,D3,D2)
--R             if D5 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero) and D3 has Join(
--R            AlgebraicallyClosedFunctionSpace(D5),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory) 
--R            and D2 has LODOCAT(D3)
--R   [6] (D2,D1,Symbol,D1,List(D1)) -> Union(D1,"failed")
--R             from ElementaryFunctionLODESolver(D5,D1,D2)
--R             if D1 has Join(AlgebraicallyClosedFunctionSpace(D5),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory) 
--R            and D5 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero) and D2 has LODOCAT(D1)
--R   [7] (Matrix(D4),Vector(D4)) -> Record(particular: Union(Vector(D4),
--R            "failed"),basis: List(Vector(D4)))
--R             from LinearSystemMatrixPackage1(D4) if D4 has FIELD
--R   [8] (List(List(D4)),Vector(D4)) -> Record(particular: Union(Vector(
--R            D4),"failed"),basis: List(Vector(D4)))
--R             from LinearSystemMatrixPackage1(D4) if D4 has FIELD
--R   [9] (Matrix(D4),List(Vector(D4))) -> List(Record(particular: Union(
--R            Vector(D4),"failed"),basis: List(Vector(D4))))
--R             from LinearSystemMatrixPackage1(D4) if D4 has FIELD
--R   [10] (List(List(D4)),List(Vector(D4))) -> List(Record(particular: 
--R            Union(Vector(D4),"failed"),basis: List(Vector(D4))))
--R             from LinearSystemMatrixPackage1(D4) if D4 has FIELD
--R   [11] (D2,D3) -> Record(particular: Union(D3,"failed"),basis: List(D3
--R            ))
--R             from LinearSystemMatrixPackage(D4,D5,D3,D2)
--R             if D4 has FIELD and D5 has FiniteLinearAggregate(D4)with
--R                 shallowlyMutableand D3 has FiniteLinearAggregate(D4)
--R            with
--R                 shallowlyMutableand D2 has MATCAT(D4,D5,D3)
--R   [12] (D2,List(D6)) -> List(Record(particular: Union(D6,"failed"),
--R            basis: List(D6)))
--R             from LinearSystemMatrixPackage(D4,D5,D6,D2)
--R             if D4 has FIELD and D5 has FiniteLinearAggregate(D4)with
--R                 shallowlyMutableand D6 has FiniteLinearAggregate(D4)
--R            with
--R                 shallowlyMutableand D2 has MATCAT(D4,D5,D6)
--R   [13] (Matrix(D6),Vector(D6),Symbol) -> Union(Record(particular: 
--R            Vector(D6),basis: List(Vector(D6))),"failed")
--R             from ElementaryFunctionODESolver(D5,D6)
--R             if D6 has Join(AlgebraicallyClosedFunctionSpace(D5),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory) 
--R            and D5 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero)
--R   [14] (Matrix(D5),Symbol) -> Union(List(Vector(D5)),"failed")
--R             from ElementaryFunctionODESolver(D4,D5)
--R             if D5 has Join(AlgebraicallyClosedFunctionSpace(D4),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory) 
--R            and D4 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero)
--R   [15] (List(Equation(D6)),List(BasicOperator),Symbol) -> Union(
--R            Record(particular: Vector(D6),basis: List(Vector(D6))),"failed")
--R             from ElementaryFunctionODESolver(D5,D6)
--R             if D6 has Join(AlgebraicallyClosedFunctionSpace(D5),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory) 
--R            and D5 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero)
--R   [16] (List(D6),List(BasicOperator),Symbol) -> Union(Record(
--R            particular: Vector(D6),basis: List(Vector(D6))),"failed")
--R             from ElementaryFunctionODESolver(D5,D6)
--R             if D6 has Join(AlgebraicallyClosedFunctionSpace(D5),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory) 
--R            and D5 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero)
--R   [17] (Equation(D6),BasicOperator,Symbol) -> Union(Record(particular
--R            : D6,basis: List(D6)),D6,"failed")
--R             from ElementaryFunctionODESolver(D5,D6)
--R             if D6 has Join(AlgebraicallyClosedFunctionSpace(D5),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory) 
--R            and D5 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero)
--R   [18] (D2,BasicOperator,Symbol) -> Union(Record(particular: D2,basis
--R            : List(D2)),D2,"failed")
--R             from ElementaryFunctionODESolver(D5,D2)
--R             if D5 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero) and D2 has Join(
--R            AlgebraicallyClosedFunctionSpace(D5),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory)
--R         
--R   [19] (Equation(D1),BasicOperator,Equation(D1),List(D1)) -> Union(D1,
--R            "failed")
--R             from ElementaryFunctionODESolver(D5,D1)
--R             if D1 has Join(AlgebraicallyClosedFunctionSpace(D5),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory) 
--R            and D5 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero)
--R   [20] (D1,BasicOperator,Equation(D1),List(D1)) -> Union(D1,"failed")
--R             from ElementaryFunctionODESolver(D5,D1)
--R             if D1 has Join(AlgebraicallyClosedFunctionSpace(D5),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory) 
--R            and D5 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero)
--R   [21] NumericalODEProblem -> Result
--R             from AnnaOrdinaryDifferentialEquationPackage
--R   [22] (NumericalODEProblem,RoutinesTable) -> Result
--R             from AnnaOrdinaryDifferentialEquationPackage
--R   [23] (Vector(Expression(Float)),Float,Float,List(Float)) -> Result
--R             from AnnaOrdinaryDifferentialEquationPackage
--R   [24] (Vector(Expression(Float)),Float,Float,List(Float),Float) -> 
--R            Result
--R             from AnnaOrdinaryDifferentialEquationPackage
--R   [25] (Vector(Expression(Float)),Float,Float,List(Float),Expression(
--R            Float),Float) -> Result
--R             from AnnaOrdinaryDifferentialEquationPackage
--R   [26] (Vector(Expression(Float)),Float,Float,List(Float),List(Float),
--R            Float) -> Result
--R             from AnnaOrdinaryDifferentialEquationPackage
--R   [27] (Vector(Expression(Float)),Float,Float,List(Float),Expression(
--R            Float),List(Float),Float) -> Result
--R             from AnnaOrdinaryDifferentialEquationPackage
--R   [28] (Vector(Expression(Float)),Float,Float,List(Float),Expression(
--R            Float),List(Float),Float,Float) -> Result
--R             from AnnaOrdinaryDifferentialEquationPackage
--R   [29] NumericalPDEProblem -> Result from 
--R            AnnaPartialDifferentialEquationPackage
--R   [30] (NumericalPDEProblem,RoutinesTable) -> Result
--R             from AnnaPartialDifferentialEquationPackage
--R   [31] (Float,Float,Float,Float,NonNegativeInteger,NonNegativeInteger,
--R            List(Expression(Float)),List(List(Expression(Float))),String,
--R            DoubleFloat) -> Result
--R             from AnnaPartialDifferentialEquationPackage
--R   [32] (Float,Float,Float,Float,NonNegativeInteger,NonNegativeInteger,
--R            List(Expression(Float)),List(List(Expression(Float))),String) -> 
--R            Result
--R             from AnnaPartialDifferentialEquationPackage
--R   [33] Expression(D3) -> List(Equation(Expression(D3)))
--R             from TransSolvePackage(D3)
--R             if D3 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero)
--R   [34] Equation(Expression(D3)) -> List(Equation(Expression(D3)))
--R             from TransSolvePackage(D3)
--R             if D3 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero)
--R   [35] (Equation(Expression(D4)),Symbol) -> List(Equation(Expression(
--R            D4)))
--R             from TransSolvePackage(D4)
--R             if D4 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero)
--R   [36] (Expression(D4),Symbol) -> List(Equation(Expression(D4)))
--R             from TransSolvePackage(D4)
--R             if D4 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero)
--R   [37] (List(Equation(Expression(D4))),List(Symbol)) -> List(List(
--R            Equation(Expression(D4))))
--R             from TransSolvePackage(D4)
--R             if D4 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero)
--R   [38] (List(Fraction(Polynomial(D4))),List(Symbol)) -> List(List(
--R            Equation(Fraction(Polynomial(D4)))))
--R             from SystemSolvePackage(D4) if D4 has INTDOM
--R   [39] (List(Equation(Fraction(Polynomial(D4)))),List(Symbol)) -> List
--R            (List(Equation(Fraction(Polynomial(D4)))))
--R             from SystemSolvePackage(D4) if D4 has INTDOM
--R   [40] List(Fraction(Polynomial(D3))) -> List(List(Equation(Fraction(
--R            Polynomial(D3)))))
--R             from SystemSolvePackage(D3) if D3 has INTDOM
--R   [41] List(Equation(Fraction(Polynomial(D3)))) -> List(List(Equation(
--R            Fraction(Polynomial(D3)))))
--R             from SystemSolvePackage(D3) if D3 has INTDOM
--R   [42] (Fraction(Polynomial(D4)),Symbol) -> List(Equation(Fraction(
--R            Polynomial(D4))))
--R             from SystemSolvePackage(D4) if D4 has INTDOM
--R   [43] (Equation(Fraction(Polynomial(D4))),Symbol) -> List(Equation(
--R            Fraction(Polynomial(D4))))
--R             from SystemSolvePackage(D4) if D4 has INTDOM
--R   [44] Fraction(Polynomial(D3)) -> List(Equation(Fraction(Polynomial(
--R            D3))))
--R             from SystemSolvePackage(D3) if D3 has INTDOM
--R   [45] Equation(Fraction(Polynomial(D3))) -> List(Equation(Fraction(
--R            Polynomial(D3))))
--R             from SystemSolvePackage(D3) if D3 has INTDOM
--R
--RThere are 7 unexposed functions called solve :
--R   [1] (List(Polynomial(D4)),List(Symbol)) -> List(List(Equation(
--R            Fraction(Polynomial(D4)))))
--R             from NonLinearSolvePackage(D4) if D4 has INTDOM
--R   [2] List(Polynomial(D3)) -> List(List(Equation(Fraction(Polynomial(
--R            D3)))))
--R             from NonLinearSolvePackage(D3) if D3 has INTDOM
--R   [3] (D1,D1,BasicOperator,Symbol) -> Union(D1,"failed")
--R             from NonLinearFirstOrderODESolver(D4,D1)
--R             if D4 has Join(OrderedSet,EuclideanDomain,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer),
--R            CharacteristicZero) and D1 has Join(
--R            AlgebraicallyClosedFunctionSpace(D4),
--R            TranscendentalFunctionCategory,PrimitiveFunctionCategory)
--R         
--R   [4] (Matrix(D5),Vector(D5),((D6,D5) -> Union(Record(particular: D5,
--R            basis: List(D5)),"failed"))) -> Union(Record(particular: Vector(
--R            D5),basis: Matrix(D5)),"failed")
--R             from SystemODESolver(D5,D6) if D5 has FIELD and D6 has 
--R            LODOCAT(D5)
--R   [5] (Polynomial(Fraction(Integer)),Float) -> List(Float)
--R             from RealSolvePackage
--R   [6] (Polynomial(Integer),Float) -> List(Float) from RealSolvePackage
--R            
--R   [7] D3 -> List(D4) from PolynomialSolveByFormulas(D3,D4)
--R             if D4 has Fieldwith
--R               D : (%,Fraction(Integer)) -> %and D3 has UPOLYC(D4)
--R            
--R
--RExamples of solve from FloatingRealPackage
--R
--R
--RExamples of solve from ElementaryFunctionLODESolver
--R
--R
--RExamples of solve from LinearSystemMatrixPackage1
--R
--R
--RExamples of solve from LinearSystemMatrixPackage
--R
--R
--RExamples of solve from NonLinearSolvePackage
--R
--R
--RExamples of solve from NonLinearFirstOrderODESolver
--R
--R
--RExamples of solve from ElementaryFunctionODESolver
--R
--R
--RExamples of solve from AnnaOrdinaryDifferentialEquationPackage
--R
--R
--RExamples of solve from SystemODESolver
--R
--R
--RExamples of solve from AnnaPartialDifferentialEquationPackage
--R
--R
--RExamples of solve from RealSolvePackage
--R
--Rp := 4*x^3 - 3*x^2 + 2*x - 4 
--Rsolve(p,0.01)$REALSOLV
--R
--Rp := 4*x^3 - 3*x^2 + 2*x - 4 
--Rsolve(p::POLY(FRAC(INT)),0.01)$REALSOLV
--R
--R
--RExamples of solve from PolynomialSolveByFormulas
--R
--R
--RExamples of solve from TransSolvePackage
--R
--Rsolve(1/2*v*v*cos(theta+phi)*cos(theta+phi)+g*l*cos(phi)=g*l,phi) 
--RdefiningPolynomial %phi0 
--RdefiningPolynomial %phi1
--R
--R
--RExamples of solve from SystemSolvePackage
--R
--E 2906

--S 2907 of 3320
)d op solve1
--R 
--R
--RThere is one unexposed function called solve1 :
--R   [1] (SparseUnivariatePolynomial(D4),D3) -> List(D5)
--R             from InnerNumericEigenPackage(D4,D5,D3)
--R             if D4 has FIELD and D5 has FIELD and D3 has Join(Field,
--R            OrderedRing)
--R
--RExamples of solve1 from InnerNumericEigenPackage
--R
--E 2907

--S 2908 of 3320
)d op solveid
--R 
--R
--RThere is one unexposed function called solveid :
--R   [1] (D2,D3,Vector(List(D2))) -> Union(List(D2),"failed")
--R             from GenExEuclid(D3,D2) if D3 has EUCDOM and D2 has UPOLYC
--R            (D3)
--R
--RExamples of solveid from GenExEuclid
--R
--E 2908

--S 2909 of 3320
)d op solveInField
--R 
--R
--RThere are 3 unexposed functions called solveInField :
--R   [1] (List(Polynomial(D4)),List(Symbol)) -> List(List(Equation(
--R            Fraction(Polynomial(D4)))))
--R             from NonLinearSolvePackage(D4) if D4 has INTDOM
--R   [2] List(Polynomial(D3)) -> List(List(Equation(Fraction(Polynomial(
--R            D3)))))
--R             from NonLinearSolvePackage(D3) if D3 has INTDOM
--R   [3] (Matrix(D6),Vector(D5),((D6,D5) -> Record(particular: Union(D5,
--R            "failed"),basis: List(D5)))) -> Record(particular: Union(Vector(
--R            D5),"failed"),basis: List(Vector(D5)))
--R             from SystemODESolver(D5,D6) if D5 has FIELD and D6 has 
--R            LODOCAT(D5)
--R
--RExamples of solveInField from NonLinearSolvePackage
--R
--R
--RExamples of solveInField from SystemODESolver
--R
--E 2909

--S 2910 of 3320
)d op solveLinear
--R 
--R
--RThere are 2 unexposed functions called solveLinear :
--R   [1] (Vector(D3),D3) -> Union(Vector(D4),"failed")
--R             from LinearDependence(D4,D3)
--R             if D3 has LINEXP(D4) and D4 has FIELD and D4 has INTDOM
--R         
--R   [2] (Vector(D3),D3) -> Union(Vector(Fraction(D4)),"failed")
--R             from LinearDependence(D4,D3)
--R             if D3 has LINEXP(D4) and not(ofCategory(D4,Field)) and D4
--R             has INTDOM
--R
--RExamples of solveLinear from LinearDependence
--R
--E 2910

--S 2911 of 3320
)d op solveLinearlyOverQ
--R 
--R
--RThere is one exposed function called solveLinearlyOverQ :
--R   [1] (Vector(D3),D3) -> Union(Vector(Fraction(Integer)),"failed")
--R             from IntegerLinearDependence(D3) if D3 has LINEXP(INT)
--R
--RExamples of solveLinearlyOverQ from IntegerLinearDependence
--R
--E 2911

--S 2912 of 3320
)d op solveLinearPolynomialEquation
--R 
--R
--RThere is one exposed function called solveLinearPolynomialEquation :
--R   [1] (List(SparseUnivariatePolynomial(D)),SparseUnivariatePolynomial(
--R            D)) -> Union(List(SparseUnivariatePolynomial(D)),"failed")
--R             from D if D has PFECAT
--R
--RThere are 3 unexposed functions called solveLinearPolynomialEquation :
--R   [1] (List(SparseUnivariatePolynomial(D4)),SparseUnivariatePolynomial
--R            (D4)) -> Union(List(SparseUnivariatePolynomial(D4)),"failed")
--R             from ComplexIntegerSolveLinearPolynomialEquation(D3,D4)
--R             if D4 has COMPCAT(D3) and D3 has INS
--R   [2] (List(D2),D2) -> Union(List(D2),"failed")
--R             from FiniteFieldSolveLinearPolynomialEquation(D3,D4,D2)
--R             if D2 has UPOLYC(D4) and D4 has UPOLYC(D3) and D3 has 
--R            FFIELDC
--R   [3] (List(SparseUnivariatePolynomial(Integer)),
--R            SparseUnivariatePolynomial(Integer)) -> Union(List(
--R            SparseUnivariatePolynomial(Integer)),"failed")
--R             from IntegerSolveLinearPolynomialEquation
--R
--RExamples of solveLinearPolynomialEquation from ComplexIntegerSolveLinearPolynomialEquation
--R
--R
--RExamples of solveLinearPolynomialEquation from FiniteFieldSolveLinearPolynomialEquation
--R
--R
--RExamples of solveLinearPolynomialEquation from IntegerSolveLinearPolynomialEquation
--R
--R
--RExamples of solveLinearPolynomialEquation from PolynomialFactorizationExplicit
--R
--E 2912

--S 2913 of 3320
)d op solveLinearPolynomialEquationByFractions
--R 
--R
--RThere is one unexposed function called solveLinearPolynomialEquationByFractions :
--R   [1] (List(SparseUnivariatePolynomial(D3)),SparseUnivariatePolynomial
--R            (D3)) -> Union(List(SparseUnivariatePolynomial(D3)),"failed")
--R             from LinearPolynomialEquationByFractions(D3) if D3 has 
--R            PFECAT
--R
--RExamples of solveLinearPolynomialEquationByFractions from LinearPolynomialEquationByFractions
--R
--E 2913

--S 2914 of 3320
)d op solveLinearPolynomialEquationByRecursion
--R 
--R
--RThere are 2 unexposed functions called solveLinearPolynomialEquationByRecursion :
--R   [1] (List(SparseUnivariatePolynomial(D6)),SparseUnivariatePolynomial
--R            (D6)) -> Union(List(SparseUnivariatePolynomial(D6)),"failed")
--R             from PolynomialFactorizationByRecursion(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D3,D4,D5) and D3 has PFECAT and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [2] (List(SparseUnivariatePolynomial(D4)),SparseUnivariatePolynomial
--R            (D4)) -> Union(List(SparseUnivariatePolynomial(D4)),"failed")
--R             from PolynomialFactorizationByRecursionUnivariate(D3,D4)
--R             if D4 has UPOLYC(D3) and D3 has PFECAT
--R
--RExamples of solveLinearPolynomialEquationByRecursion from PolynomialFactorizationByRecursion
--R
--R
--RExamples of solveLinearPolynomialEquationByRecursion from PolynomialFactorizationByRecursionUnivariate
--R
--E 2914

--S 2915 of 3320
)d op solveRetract
--R 
--R
--RThere is one unexposed function called solveRetract :
--R   [1] (List(Polynomial(D5)),List(Symbol)) -> List(List(Equation(
--R            Fraction(Polynomial(D5)))))
--R             from RetractSolvePackage(D4,D5)
--R             if D5 has Join(IntegralDomain,RetractableTo(D4)) and D4
--R             has INTDOM
--R
--RExamples of solveRetract from RetractSolvePackage
--R
--E 2915

--S 2916 of 3320
)d op someBasis
--R 
--R
--RThere is one exposed function called someBasis :
--R   [1]  -> Vector(D) from D if D2 has COMRING and D has FINAALG(D2)
--R
--RExamples of someBasis from FiniteRankNonAssociativeAlgebra
--R
--E 2916

--S 2917 of 3320
)d op Somos
--R 
--R
--RThere is one exposed function called Somos :
--R   [1] Union(PositiveInteger,Boolean) -> GuessOption from GuessOption
--R         
--R
--RThere is one unexposed function called Somos :
--R   [1] List(GuessOption) -> Union(PositiveInteger,Boolean)
--R             from GuessOptionFunctions0
--R
--RExamples of Somos from GuessOptionFunctions0
--R
--R
--RExamples of Somos from GuessOption
--R
--E 2917

--S 2918 of 3320
)d op sort
--R 
--R
--RThere are 4 exposed functions called sort :
--R   [1] D -> D from D if D has FLAGG(D1) and D1 has TYPE and D1 has 
--R            ORDSET
--R   [2] (((D2,D2) -> Boolean),D) -> D from D if D has FLAGG(D2) and D2
--R             has TYPE
--R   [3] List(Permutation(D2)) -> List(Permutation(D2)) from Permutation(
--R            D2)
--R             if D2 has SETCAT
--R   [4] (D,D2) -> Record(under: D,floor: D,upper: D) from D
--R             if D3 has RING and D4 has OAMONS and D2 has ORDSET and D5
--R             has RPOLCAT(D3,D4,D2) and D has PSETCAT(D3,D4,D2,D5)
--R
--RExamples of sort from FiniteLinearAggregate
--R
--R
--RExamples of sort from Permutation
--R
--R
--RExamples of sort from PolynomialSetCategory
--R
--E 2918

--S 2919 of 3320
)d op sort!
--R 
--R
--RThere are 2 exposed functions called sort! :
--R   [1] D -> D from D
--R             if D has shallowlyMutable and D has FLAGG(D1) and D1 has 
--R            TYPE and D1 has ORDSET
--R   [2] (((D2,D2) -> Boolean),D) -> D from D
--R             if D has shallowlyMutable and D has FLAGG(D2) and D2 has 
--R            TYPE
--R
--RExamples of sort! from FiniteLinearAggregate
--R
--E 2919

--S 2920 of 3320
)d op sortConstraints
--R 
--R
--RThere is one exposed function called sortConstraints :
--R   [1] Record(fn: Expression(DoubleFloat),init: List(DoubleFloat),lb: 
--R            List(OrderedCompletion(DoubleFloat)),cf: List(Expression(
--R            DoubleFloat)),ub: List(OrderedCompletion(DoubleFloat))) -> 
--R            Record(fn: Expression(DoubleFloat),init: List(DoubleFloat),lb: 
--R            List(OrderedCompletion(DoubleFloat)),cf: List(Expression(
--R            DoubleFloat)),ub: List(OrderedCompletion(DoubleFloat)))
--R             from e04AgentsPackage
--R
--RExamples of sortConstraints from e04AgentsPackage
--R
--E 2920

--S 2921 of 3320
)d op sorted?
--R 
--R
--RThere are 2 exposed functions called sorted? :
--R   [1] D -> Boolean from D if D has FLAGG(D2) and D2 has TYPE and D2
--R             has ORDSET
--R   [2] (((D3,D3) -> Boolean),D) -> Boolean from D if D has FLAGG(D3) 
--R            and D3 has TYPE
--R
--RExamples of sorted? from FiniteLinearAggregate
--R
--E 2921

--S 2922 of 3320
)d op sortedPurge!
--R 
--R
--RThere is one exposed function called sortedPurge! :
--R   [1] (SparseEchelonMatrix(D3,D4),(D3 -> Boolean)) -> Void
--R             from SparseEchelonMatrix(D3,D4) if D3 has ORDSET and D4
--R             has RING
--R
--RExamples of sortedPurge! from SparseEchelonMatrix
--R
--E 2922

--S 2923 of 3320
)d op space
--R 
--R
--RThere are 2 exposed functions called space :
--R   [1]  -> Character from Character
--R   [2] ThreeSpace(DoubleFloat) -> DrawOption from DrawOption
--R
--RThere is one unexposed function called space :
--R   [1] List(DrawOption) -> ThreeSpace(DoubleFloat) from 
--R            DrawOptionFunctions0
--R
--RExamples of space from Character
--R
--Rspace()
--R
--R
--RExamples of space from DrawOptionFunctions0
--R
--R
--RExamples of space from DrawOption
--R
--E 2923

--S 2924 of 3320
)d op sparsityIF
--R 
--R
--RThere is one exposed function called sparsityIF :
--R   [1] Matrix(Expression(DoubleFloat)) -> Float from d02AgentsPackage
--R         
--R
--RExamples of sparsityIF from d02AgentsPackage
--R
--E 2924

--S 2925 of 3320
)d op specialise
--R 
--R
--RThere is one exposed function called specialise :
--R   [1] (List(Polynomial(D4)),Cell(D4)) -> List(
--R            SparseUnivariatePolynomial(D4))
--R             from CylindricalAlgebraicDecompositionPackage(D4) if D4
--R             has RCFIELD
--R
--RExamples of specialise from CylindricalAlgebraicDecompositionPackage
--R
--E 2925

--S 2926 of 3320
)d op specialTrigs
--R 
--R
--RThere is one unexposed function called specialTrigs :
--R   [1] (D1,List(Record(func: D1,pole: Boolean))) -> Union(D1,"failed")
--R             from ElementaryFunction(D3,D1)
--R             if D1 has Join(FunctionSpace(D3),RadicalCategory) and D3
--R             has Join(OrderedSet,IntegralDomain)
--R
--RExamples of specialTrigs from ElementaryFunction
--R
--E 2926

--S 2927 of 3320
)d op spherical
--R 
--R
--RThere is one exposed function called spherical :
--R   [1] Point(D2) -> Point(D2) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of spherical from CoordinateSystems
--R
--E 2927

--S 2928 of 3320
)d op split
--R 
--R
--RThere are 9 exposed functions called split :
--R   [1] D2 -> Factored(D2) from AlgFactor(D2) if D2 has UPOLYC(AN)
--R   [2] (D2,BinarySearchTree(D2)) -> Record(less: BinarySearchTree(D2),
--R            greater: BinarySearchTree(D2))
--R             from BinarySearchTree(D2) if D2 has ORDSET
--R   [3] D -> List(D) from D if D2 has SETCAT and D has DIVCAT(D2)
--R   [4] IntegrationResult(D3) -> IntegrationResult(D3)
--R             from IntegrationResultToFunction(D2,D3)
--R             if D3 has Join(AlgebraicallyClosedFunctionSpace(D2),
--R            TranscendentalFunctionCategory) and D2 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,LinearlyExplicitRingOver(
--R            Integer))
--R   [5] IntegrationResult(Fraction(Polynomial(D2))) -> IntegrationResult
--R            (Fraction(Polynomial(D2)))
--R             from IntegrationResultRFToFunction(D2)
--R             if D2 has Join(GcdDomain,RetractableTo(Integer),OrderedSet
--R            ,LinearlyExplicitRingOver(Integer))
--R   [6] (List(Matrix(D4)),Vector(D4)) -> List(List(Matrix(D4)))
--R             from RepresentationPackage2(D4) if D4 has FIELD and D4
--R             has RING
--R   [7] (List(Matrix(D4)),Vector(Vector(D4))) -> List(List(Matrix(D4)))
--R             from RepresentationPackage2(D4) if D4 has FIELD and D4
--R             has RING
--R   [8] (D,CharacterClass) -> List(D) from D if D has SRAGG
--R   [9] (D,Character) -> List(D) from D if D has SRAGG
--R
--RThere is one unexposed function called split :
--R   [1] (D2,(D2 -> D2)) -> Record(normal: D2,special: D2)
--R             from MonomialExtensionTools(D4,D2) if D2 has UPOLYC(D4) 
--R            and D4 has FIELD
--R
--RExamples of split from AlgFactor
--R
--R
--RExamples of split from BinarySearchTree
--R
--Rt1:=binarySearchTree [1,2,3,4] 
--Rsplit(3,t1)
--R
--R
--RExamples of split from DivisorCategory
--R
--R
--RExamples of split from IntegrationResultToFunction
--R
--R
--RExamples of split from IntegrationResultRFToFunction
--R
--R
--RExamples of split from MonomialExtensionTools
--R
--R
--RExamples of split from RepresentationPackage2
--R
--R
--RExamples of split from StringAggregate
--R
--E 2928

--S 2929 of 3320 done
)d op split!
--R 
--R
--RThere is one exposed function called split! :
--R   [1] (D,Integer) -> D from D
--R             if D has shallowlyMutable and D has URAGG(D2) and D2 has 
--R            TYPE
--R
--RExamples of split! from UnaryRecursiveAggregate
--R
--Rt1:=[1,4,2,-6,0,3,5,4,2,3] 
--Rt2:=split!(t1,4) 
--Rt1 
--Rt2
--R
--E 2929

--S 2930 of 3320
)d op splitConstant
--R 
--R
--RThere is one unexposed function called splitConstant :
--R   [1] (D2,Symbol) -> Record(const: D2,nconst: D2)
--R             from PatternMatchIntegration(D4,D2)
--R             if D4 has Join(OrderedSet,RetractableTo(Integer),GcdDomain
--R            ,LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D4))
--R
--RExamples of splitConstant from PatternMatchIntegration
--R
--E 2930

--S 2931 of 3320
)d op splitDenominator
--R 
--R
--RThere are 3 exposed functions called splitDenominator :
--R   [1] D2 -> Record(num: D2,den: D3) from CommonDenominator(D3,D4,D2)
--R             if D3 has INTDOM and D4 has QFCAT(D3) and D2 has FLAGG(D4)
--R            
--R   [2] Matrix(D4) -> Record(num: Matrix(D3),den: D3)
--R             from MatrixCommonDenominator(D3,D4)
--R             if D4 has QFCAT(D3) and D3 has INTDOM
--R   [3] D2 -> Record(num: D2,den: D3)
--R             from UnivariatePolynomialCommonDenominator(D3,D4,D2)
--R             if D3 has INTDOM and D4 has QFCAT(D3) and D2 has UPOLYC(D4
--R            )
--R
--RThere are 2 unexposed functions called splitDenominator :
--R   [1] D2 -> Record(num: D5,den: D3) from InnerCommonDenominator(D3,D4,
--R            D5,D2)
--R             if D3 has INTDOM and D4 has QFCAT(D3) and D5 has FLAGG(D3)
--R            and D2 has FLAGG(D4)
--R   [2] (D2,List(Fraction(D5))) -> Record(eq: D6,rh: List(Fraction(D5)))
--R             from PrimitiveRatDE(D4,D5,D6,D2)
--R             if D4 has Join(Field,CharacteristicZero,RetractableTo(
--R            Fraction(Integer))) and D5 has UPOLYC(D4) and D6 has 
--R            LODOCAT(D5) and D2 has LODOCAT(FRAC(D5))
--R
--RExamples of splitDenominator from CommonDenominator
--R
--R
--RExamples of splitDenominator from InnerCommonDenominator
--R
--R
--RExamples of splitDenominator from MatrixCommonDenominator
--R
--R
--RExamples of splitDenominator from PrimitiveRatDE
--R
--R
--RExamples of splitDenominator from UnivariatePolynomialCommonDenominator
--R
--E 2931

--S 2932 of 3320
)d op splitLinear
--R 
--R
--RThere is one exposed function called splitLinear :
--R   [1] Expression(DoubleFloat) -> Expression(DoubleFloat) from 
--R            e04AgentsPackage
--R
--RExamples of splitLinear from e04AgentsPackage
--R
--E 2932

--S 2933 of 3320
)d op splitNodeOf!
--R 
--R
--RThere are 2 unexposed functions called splitNodeOf! :
--R   [1] (SplittingTree(D3,D4),SplittingTree(D3,D4),List(SplittingNode(D3
--R            ,D4)),((D4,D4) -> Boolean)) -> SplittingTree(D3,D4)
--R             from SplittingTree(D3,D4)
--R             if D3 has Join(SetCategory,Aggregate) and D4 has Join(
--R            SetCategory,Aggregate)
--R   [2] (SplittingTree(D2,D3),SplittingTree(D2,D3),List(SplittingNode(D2
--R            ,D3))) -> SplittingTree(D2,D3)
--R             from SplittingTree(D2,D3)
--R             if D2 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of splitNodeOf! from SplittingTree
--R
--E 2933

--S 2934 of 3320
)d op splitSquarefree
--R 
--R
--RThere is one unexposed function called splitSquarefree :
--R   [1] (D2,(D2 -> D2)) -> Record(normal: Factored(D2),special: Factored
--R            (D2))
--R             from MonomialExtensionTools(D4,D2) if D2 has UPOLYC(D4) 
--R            and D4 has FIELD
--R
--RExamples of splitSquarefree from MonomialExtensionTools
--R
--E 2934

--S 2935 of 3320
)d op sPol
--R 
--R
--RThere is one unexposed function called sPol :
--R   [1] Record(lcmfij: D4,totdeg: NonNegativeInteger,poli: D1,polj: D1)
--R             -> D1
--R             from GroebnerInternalPackage(D3,D4,D5,D1)
--R             if D4 has OAMONS and D1 has POLYCAT(D3,D4,D5) and D3 has 
--R            GCDDOM and D5 has ORDSET
--R
--RExamples of sPol from GroebnerInternalPackage
--R
--E 2935

--S 2936 of 3320
)d op sqfree
--R 
--R
--RThere is one unexposed function called sqfree :
--R   [1] D1 -> D1 from ParametricLinearEquations(D2,D3,D4,D1)
--R             if D2 has Join(EuclideanDomain,CharacteristicZero) and D3
--R             has Join(OrderedSet,ConvertibleTo(Symbol)) and D4 has 
--R            OAMONS and D1 has POLYCAT(D2,D4,D3)
--R
--RExamples of sqfree from ParametricLinearEquations
--R
--E 2936

--S 2937 of 3320 done
)d op sqfrFactor
--R 
--R
--RThere is one exposed function called sqfrFactor :
--R   [1] (D1,Integer) -> Factored(D1) from Factored(D1) if D1 has INTDOM
--R            
--R
--RExamples of sqfrFactor from Factored
--R
--Ra:=sqfrFactor(3,5) 
--RnthFlag(a,1)
--R
--E 2937

--S 2938 of 3320
)d op sqrt
--R 
--R
--RThere are 7 exposed functions called sqrt :
--R   [1] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R   [2] (D,Integer) -> D from D if D has PADICCT(D2)
--R   [3] D -> D from D if D has RADCAT
--R   [4] Integer -> D from D if D has RCFIELD
--R   [5] Fraction(Integer) -> D from D if D has RCFIELD
--R   [6] (D,NonNegativeInteger) -> D from D if D has RCFIELD
--R   [7] D -> D from D if D has RCFIELD
--R
--RExamples of sqrt from FortranExpression
--R
--R
--RExamples of sqrt from PAdicIntegerCategory
--R
--R
--RExamples of sqrt from RadicalCategory
--R
--R
--RExamples of sqrt from RealClosedField
--R
--E 2938

--S 2939 of 3320
)d op square?
--R 
--R
--RThere are 2 exposed functions called square? :
--R   [1] D -> Boolean from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [2] D -> Boolean from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of square? from MatrixCategory
--R
--Rsquare? matrix [[j**i for i in 0..4] for j in 1..5]
--R
--R
--RExamples of square? from RectangularMatrixCategory
--R
--E 2939

--S 2940 of 3320
)d op squareFree
--R 
--R
--RThere are 3 exposed functions called squareFree :
--R   [1] D -> Factored(D) from D
--R             if D2 has GCDDOM and D2 has RING and D3 has OAMONS and D4
--R             has ORDSET and D has POLYCAT(D2,D3,D4)
--R   [2] D -> Factored(D) from D if D has UFD
--R   [3] RegularChain(D3,D4) -> List(SquareFreeRegularTriangularSet(D3,
--R            IndexedExponents(OrderedVariableList(D5)),OrderedVariableList(D5)
--R            ,NewSparseMultivariatePolynomial(D3,OrderedVariableList(D5))))
--R             from ZeroDimensionalSolvePackage(D3,D4,D5)
--R             if D3 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D4: LIST(SYMBOL) and 
--R            D5: LIST(SYMBOL)
--R
--RThere are 6 unexposed functions called squareFree :
--R   [1] D2 -> Factored(D2) from IntegerFactorizationPackage(D2) if D2
--R             has INS
--R   [2] D2 -> Factored(D2) from MultivariateSquareFree(D3,D4,D5,D2)
--R             if D3 has OAMONS and D4 has ORDSET and D5 has EUCDOM and 
--R            D2 has POLYCAT(D5,D3,D4)
--R   [3] SparseUnivariatePolynomial(D6) -> Factored(
--R            SparseUnivariatePolynomial(D6))
--R             from MultivariateSquareFree(D3,D4,D5,D6)
--R             if D3 has OAMONS and D4 has ORDSET and D5 has EUCDOM and 
--R            D6 has POLYCAT(D5,D3,D4)
--R   [4] D2 -> Factored(D2) from PolynomialSquareFree(D3,D4,D5,D2)
--R             if D3 has ORDSET and D4 has OAMONS and D5 has GCDDOM and 
--R            D2 has POLYCAT(D5,D4,D3)
--R   [5] SparseUnivariatePolynomial(Fraction(D6)) -> Factored(
--R            SparseUnivariatePolynomial(Fraction(D6)))
--R             from SupFractionFactorizer(D3,D4,D5,D6)
--R             if D3 has OAMONS and D4 has ORDSET and D5 has GCDDOM and 
--R            D6 has POLYCAT(D5,D3,D4)
--R   [6] D2 -> Factored(D2) from UnivariatePolynomialSquareFree(D3,D2)
--R             if D3 has INTDOM and D2 has Join(
--R            UnivariatePolynomialCategory(D3),IntegralDomain)with
--R               gcd : (%,%) -> %
--R
--RExamples of squareFree from IntegerFactorizationPackage
--R
--R
--RExamples of squareFree from MultivariateSquareFree
--R
--R
--RExamples of squareFree from PolynomialCategory
--R
--R
--RExamples of squareFree from PolynomialSquareFree
--R
--R
--RExamples of squareFree from SupFractionFactorizer
--R
--R
--RExamples of squareFree from UniqueFactorizationDomain
--R
--R
--RExamples of squareFree from UnivariatePolynomialSquareFree
--R
--R
--RExamples of squareFree from ZeroDimensionalSolvePackage
--R
--E 2940

--S 2941 of 3320
)d op squareFreeBasis
--R 
--R
--RThere is one exposed function called squareFreeBasis :
--R   [1] List(D3) -> List(D3)
--R             from CylindricalAlgebraicDecompositionUtilities(D2,D3)
--R             if D3 has UPOLYC(D2) and D2 has GCDDOM
--R
--RExamples of squareFreeBasis from CylindricalAlgebraicDecompositionUtilities
--R
--E 2941

--S 2942 of 3320
)d op squareFreeFactors
--R 
--R
--RThere is one unexposed function called squareFreeFactors :
--R   [1] D2 -> List(D2) from PolynomialSetUtilitiesPackage(D3,D4,D5,D2)
--R             if D3 has GCDDOM and D3 has INTDOM and D4 has OAMONS and 
--R            D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R
--RExamples of squareFreeFactors from PolynomialSetUtilitiesPackage
--R
--E 2942

--S 2943 of 3320
)d op squareFreeLexTriangular
--R 
--R
--RThere is one unexposed function called squareFreeLexTriangular :
--R   [1] (List(NewSparseMultivariatePolynomial(D4,OrderedVariableList(D5)
--R            )),Boolean) -> List(SquareFreeRegularTriangularSet(D4,
--R            IndexedExponents(OrderedVariableList(D5)),OrderedVariableList(D5)
--R            ,NewSparseMultivariatePolynomial(D4,OrderedVariableList(D5))))
--R             from LexTriangularPackage(D4,D5) if D4 has GCDDOM and D5: 
--R            LIST(SYMBOL)
--R
--RExamples of squareFreeLexTriangular from LexTriangularPackage
--R
--E 2943

--S 2944 of 3320
)d op squareFreePart
--R 
--R
--RThere are 3 exposed functions called squareFreePart :
--R   [1] D -> D from D
--R             if D has POLYCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has GCDDOM
--R   [2] (D2,D) -> List(Record(val: D2,tower: D)) from D
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5) and D has RSETCAT(D3,D4,D5,D2)
--R   [3] D -> D from D if D has UFD
--R
--RThere is one unexposed function called squareFreePart :
--R   [1] D1 -> D1 from UnivariatePolynomialSquareFree(D2,D1)
--R             if D2 has INTDOM and D1 has Join(
--R            UnivariatePolynomialCategory(D2),IntegralDomain)with
--R               gcd : (%,%) -> %
--R
--RExamples of squareFreePart from PolynomialCategory
--R
--R
--RExamples of squareFreePart from RegularTriangularSetCategory
--R
--R
--RExamples of squareFreePart from UniqueFactorizationDomain
--R
--R
--RExamples of squareFreePart from UnivariatePolynomialSquareFree
--R
--E 2944

--S 2945 of 3320
)d op squareFreePolynomial
--R 
--R
--RThere are 2 exposed functions called squareFreePolynomial :
--R   [1] SparseUnivariatePolynomial(Expression(D3)) -> Factored(
--R            SparseUnivariatePolynomial(Expression(D3)))
--R             from Expression(D3) if D3 has GCDDOM and D3 has INTDOM and
--R            D3 has ORDSET
--R   [2] SparseUnivariatePolynomial(D) -> Factored(
--R            SparseUnivariatePolynomial(D))
--R             from D if D has PFECAT
--R
--RExamples of squareFreePolynomial from Expression
--R
--R
--RExamples of squareFreePolynomial from PolynomialFactorizationExplicit
--R
--E 2945

--S 2946 of 3320
)d op squareFreePrim
--R 
--R
--RThere is one unexposed function called squareFreePrim :
--R   [1] D2 -> Factored(D2) from MultivariateSquareFree(D3,D4,D5,D2)
--R             if D3 has OAMONS and D4 has ORDSET and D5 has EUCDOM and 
--R            D2 has POLYCAT(D5,D3,D4)
--R
--RExamples of squareFreePrim from MultivariateSquareFree
--R
--E 2946

--S 2947 of 3320
)d op squareMatrix
--R 
--R
--RThere is one unexposed function called squareMatrix :
--R   [1] Matrix(D3) -> SquareMatrix(D2,D3) from SquareMatrix(D2,D3)
--R             if D3 has RING and D2: NNI
--R
--RExamples of squareMatrix from SquareMatrix
--R
--E 2947

--S 2948 of 3320 done
)d op squareTop
--R 
--R
--RThere is one exposed function called squareTop :
--R   [1] D -> D from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1)
--R
--RExamples of squareTop from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..2] for j in 1..5] 
--RsquareTop m
--R
--E 2948

--S 2949 of 3320
)d op stablePol
--R 
--R
--RThere is one exposed function called stablePol :
--R   [1] SimpleCell(D2,D1) -> D1 from SimpleCell(D2,D1)
--R             if D1 has UPOLYC(D2) and D2 has RCFIELD
--R
--RExamples of stablePol from SimpleCell
--R
--E 2949

--S 2950 of 3320 done
)d op stack
--R 
--R
--RThere is one exposed function called stack :
--R   [1] List(D2) -> Stack(D2) from Stack(D2) if D2 has SETCAT
--R
--RExamples of stack from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5]
--R
--E 2950

--S 2951 of 3320
)d op standardBasisOfCyclicSubmodule
--R 
--R
--RThere is one exposed function called standardBasisOfCyclicSubmodule :
--R   [1] (List(Matrix(D4)),Vector(D4)) -> Matrix(D4)
--R             from RepresentationPackage2(D4) if D4 has EUCDOM and D4
--R             has RING
--R
--RExamples of standardBasisOfCyclicSubmodule from RepresentationPackage2
--R
--E 2951

--S 2952 of 3320
)d op standardDotHeader
--R 
--R
--RThere is one exposed function called standardDotHeader :
--R   [1]  -> List(String) from Graphviz
--R
--RExamples of standardDotHeader from Graphviz
--R
--Rheader:=standardDotHeader()
--R
--E 2952

--S 2953 of 3320
)d op startPolynomial
--R 
--R
--RThere is one unexposed function called startPolynomial :
--R   [1] D2 -> Record(start: D2,factors: Factored(D2))
--R             from ComplexRootFindingPackage(D3,D2)
--R             if D3 has Join(Field,OrderedRing) and D2 has UPOLYC(
--R            COMPLEX(D3))
--R
--RExamples of startPolynomial from ComplexRootFindingPackage
--R
--E 2953

--S 2954 of 3320
)d op startStats!
--R 
--R
--RThere is one unexposed function called startStats! :
--R   [1] String -> Void from TabulatedComputationPackage(D3,D4)
--R             if D3 has SETCAT and D4 has SETCAT
--R
--RExamples of startStats! from TabulatedComputationPackage
--R
--E 2954

--S 2955 of 3320
)d op startTable!
--R 
--R
--RThere are 2 exposed functions called startTable! :
--R   [1] (String,String,String) -> Void from QuasiComponentPackage(D3,D4,
--R            D5,D6,D7)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [2] (String,String,String) -> Void
--R             from SquareFreeQuasiComponentPackage(D3,D4,D5,D6,D7)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R
--RExamples of startTable! from QuasiComponentPackage
--R
--R
--RExamples of startTable! from SquareFreeQuasiComponentPackage
--R
--E 2955

--S 2956 of 3320
)d op startTableGcd!
--R 
--R
--RThere are 2 exposed functions called startTableGcd! :
--R   [1] (String,String,String) -> Void
--R             from RegularTriangularSetGcdPackage(D3,D4,D5,D6,D7)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [2] (String,String,String) -> Void
--R             from SquareFreeRegularTriangularSetGcdPackage(D3,D4,D5,D6,
--R            D7)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R
--RExamples of startTableGcd! from RegularTriangularSetGcdPackage
--R
--R
--RExamples of startTableGcd! from SquareFreeRegularTriangularSetGcdPackage
--R
--E 2956

--S 2957 of 3320
)d op startTableInvSet!
--R 
--R
--RThere are 2 exposed functions called startTableInvSet! :
--R   [1] (String,String,String) -> Void
--R             from RegularTriangularSetGcdPackage(D3,D4,D5,D6,D7)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [2] (String,String,String) -> Void
--R             from SquareFreeRegularTriangularSetGcdPackage(D3,D4,D5,D6,
--R            D7)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R
--RExamples of startTableInvSet! from RegularTriangularSetGcdPackage
--R
--R
--RExamples of startTableInvSet! from SquareFreeRegularTriangularSetGcdPackage
--R
--E 2957

--S 2958 of 3320
)d op status
--R 
--R
--RThere are 2 unexposed functions called status :
--R   [1] QuasiAlgebraicSet(D2,D3,D4,D5) -> Union(Boolean,"failed")
--R             from QuasiAlgebraicSet(D2,D3,D4,D5)
--R             if D2 has GCDDOM and D3 has ORDSET and D4 has OAMONS and 
--R            D5 has POLYCAT(D2,D4,D3)
--R   [2] SplittingNode(D2,D3) -> Boolean from SplittingNode(D2,D3)
--R             if D2 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of status from QuasiAlgebraicSet
--R
--R
--RExamples of status from SplittingNode
--R
--E 2958

--S 2959 of 3320 done
)d op statusIto
--R 
--R
--RThere is one exposed function called statusIto :
--R   [1]  -> OutputForm from StochasticDifferential(D2)
--R             if D2 has Join(OrderedSet,IntegralDomain)
--R
--RExamples of statusIto from StochasticDifferential
--R
--Rdt:=introduce!(t,dt) 
--RdX:=introduce!(X,dX) 
--RdY:=introduce!(Y,dY) 
--RcopyBSD() 
--RcopyIto() 
--RcopyhQuadVar() 
--RstatusIto()
--R
--E 2959

--S 2960 of 3320
)d op stepBlowUp
--R 
--R
--RThere is one exposed function called stepBlowUp :
--R   [1] (DistributedMultivariatePolynomial([construct,QUOTEX,QUOTEY],D5)
--R            ,AffinePlane(D5),D4,D5) -> Record(mult: NonNegativeInteger,
--R            subMult: NonNegativeInteger,blUpRec: List(Record(recTransStr: 
--R            DistributedMultivariatePolynomial([construct,QUOTEX,QUOTEY],D5),
--R            recPoint: AffinePlane(D5),recChart: D4,definingExtension: D5)))
--R             from BlowUpPackage(D5,D6,D7,D8,D4)
--R             if D5 has FIELD and D6: LIST(SYMBOL) and D8 has DIRPCAT(#(
--R            D6),NNI) and D7 has FAMR(D5,D8) and D4 has BLMETCT
--R
--RExamples of stepBlowUp from BlowUpPackage
--R
--E 2960

--S 2961 of 3320
)d op stFunc1
--R 
--R
--RThere is one unexposed function called stFunc1 :
--R   [1] (D4 -> D4) -> (Stream(D3) -> Stream(D3))
--R             from UnivariateTaylorSeriesODESolver(D3,D4)
--R             if D4 has UTSCAT(D3) and D3 has ALGEBRA(FRAC(INT))
--R
--RExamples of stFunc1 from UnivariateTaylorSeriesODESolver
--R
--E 2961

--S 2962 of 3320
)d op stFunc2
--R 
--R
--RThere is one unexposed function called stFunc2 :
--R   [1] ((D4,D4) -> D4) -> ((Stream(D3),Stream(D3)) -> Stream(D3))
--R             from UnivariateTaylorSeriesODESolver(D3,D4)
--R             if D4 has UTSCAT(D3) and D3 has ALGEBRA(FRAC(INT))
--R
--RExamples of stFunc2 from UnivariateTaylorSeriesODESolver
--R
--E 2962

--S 2963 of 3320
)d op stFuncN
--R 
--R
--RThere is one unexposed function called stFuncN :
--R   [1] (List(D4) -> D4) -> (List(Stream(D3)) -> Stream(D3))
--R             from UnivariateTaylorSeriesODESolver(D3,D4)
--R             if D4 has UTSCAT(D3) and D3 has ALGEBRA(FRAC(INT))
--R
--RExamples of stFuncN from UnivariateTaylorSeriesODESolver
--R
--E 2963

--S 2964 of 3320
)d op stiffnessAndStabilityFactor
--R 
--R
--RThere is one exposed function called stiffnessAndStabilityFactor :
--R   [1] Matrix(Expression(DoubleFloat)) -> Record(stiffnessFactor: Float
--R            ,stabilityFactor: Float)
--R             from d02AgentsPackage
--R
--RExamples of stiffnessAndStabilityFactor from d02AgentsPackage
--R
--E 2964

--S 2965 of 3320
)d op stiffnessAndStabilityOfODEIF
--R 
--R
--RThere is one exposed function called stiffnessAndStabilityOfODEIF :
--R   [1] Record(xinit: DoubleFloat,xend: DoubleFloat,fn: Vector(
--R            Expression(DoubleFloat)),yinit: List(DoubleFloat),intvals: List(
--R            DoubleFloat),g: Expression(DoubleFloat),abserr: DoubleFloat,
--R            relerr: DoubleFloat) -> Record(stiffnessFactor: Float,
--R            stabilityFactor: Float)
--R             from d02AgentsPackage
--R
--RExamples of stiffnessAndStabilityOfODEIF from d02AgentsPackage
--R
--E 2965

--S 2966 of 3320
)d op stirling1
--R 
--R
--RThere is one exposed function called stirling1 :
--R   [1] (D1,D1) -> D1 from IntegerCombinatoricFunctions(D1) if D1 has 
--R            INS
--R
--RExamples of stirling1 from IntegerCombinatoricFunctions
--R
--E 2966

--S 2967 of 3320
)d op stirling2
--R 
--R
--RThere is one exposed function called stirling2 :
--R   [1] (D1,D1) -> D1 from IntegerCombinatoricFunctions(D1) if D1 has 
--R            INS
--R
--RExamples of stirling2 from IntegerCombinatoricFunctions
--R
--E 2967

--S 2968 of 3320
)d op stop
--R 
--R
--RThere is one exposed function called stop :
--R   [1]  -> FortranCode from FortranCode
--R
--RExamples of stop from FortranCode
--R
--E 2968

--S 2969 of 3320
)d op stopMusserTrials
--R 
--R
--RThere are 2 unexposed functions called stopMusserTrials :
--R   [1]  -> PositiveInteger from GaloisGroupFactorizer(D2) if D2 has 
--R            UPOLYC(INT)
--R   [2] PositiveInteger -> PositiveInteger from GaloisGroupFactorizer(D2
--R            )
--R             if D2 has UPOLYC(INT)
--R
--RExamples of stopMusserTrials from GaloisGroupFactorizer
--R
--E 2969

--S 2970 of 3320
)d op stopTable!
--R 
--R
--RThere are 2 exposed functions called stopTable! :
--R   [1]  -> Void from QuasiComponentPackage(D2,D3,D4,D5,D6)
--R             if D2 has GCDDOM and D3 has OAMONS and D4 has ORDSET and 
--R            D5 has RPOLCAT(D2,D3,D4) and D6 has RSETCAT(D2,D3,D4,D5)
--R         
--R   [2]  -> Void from SquareFreeQuasiComponentPackage(D2,D3,D4,D5,D6)
--R             if D2 has GCDDOM and D3 has OAMONS and D4 has ORDSET and 
--R            D5 has RPOLCAT(D2,D3,D4) and D6 has RSETCAT(D2,D3,D4,D5)
--R         
--R
--RExamples of stopTable! from QuasiComponentPackage
--R
--R
--RExamples of stopTable! from SquareFreeQuasiComponentPackage
--R
--E 2970

--S 2971 of 3320
)d op stopTableGcd!
--R 
--R
--RThere are 2 exposed functions called stopTableGcd! :
--R   [1]  -> Void from RegularTriangularSetGcdPackage(D2,D3,D4,D5,D6)
--R             if D2 has GCDDOM and D3 has OAMONS and D4 has ORDSET and 
--R            D5 has RPOLCAT(D2,D3,D4) and D6 has RSETCAT(D2,D3,D4,D5)
--R         
--R   [2]  -> Void from SquareFreeRegularTriangularSetGcdPackage(D2,D3,D4,
--R            D5,D6)
--R             if D2 has GCDDOM and D3 has OAMONS and D4 has ORDSET and 
--R            D5 has RPOLCAT(D2,D3,D4) and D6 has RSETCAT(D2,D3,D4,D5)
--R         
--R
--RExamples of stopTableGcd! from RegularTriangularSetGcdPackage
--R
--R
--RExamples of stopTableGcd! from SquareFreeRegularTriangularSetGcdPackage
--R
--E 2971

--S 2972 of 3320
)d op stopTableInvSet!
--R 
--R
--RThere are 2 exposed functions called stopTableInvSet! :
--R   [1]  -> Void from RegularTriangularSetGcdPackage(D2,D3,D4,D5,D6)
--R             if D2 has GCDDOM and D3 has OAMONS and D4 has ORDSET and 
--R            D5 has RPOLCAT(D2,D3,D4) and D6 has RSETCAT(D2,D3,D4,D5)
--R         
--R   [2]  -> Void from SquareFreeRegularTriangularSetGcdPackage(D2,D3,D4,
--R            D5,D6)
--R             if D2 has GCDDOM and D3 has OAMONS and D4 has ORDSET and 
--R            D5 has RPOLCAT(D2,D3,D4) and D6 has RSETCAT(D2,D3,D4,D5)
--R         
--R
--RExamples of stopTableInvSet! from RegularTriangularSetGcdPackage
--R
--R
--RExamples of stopTableInvSet! from SquareFreeRegularTriangularSetGcdPackage
--R
--E 2972

--S 2973 of 3320
)d op stoseIntegralLastSubResultant
--R 
--R
--RThere is one exposed function called stoseIntegralLastSubResultant :
--R   [1] (D2,D2,D3) -> List(Record(val: D2,tower: D3))
--R             from SquareFreeRegularTriangularSetGcdPackage(D4,D5,D6,D2,
--R            D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of stoseIntegralLastSubResultant from SquareFreeRegularTriangularSetGcdPackage
--R
--E 2973

--S 2974 of 3320
)d op stoseInternalLastSubResultant
--R 
--R
--RThere are 2 exposed functions called stoseInternalLastSubResultant :
--R   [1] (D2,D2,D3,Boolean,Boolean) -> List(Record(val: D2,tower: D3))
--R             from SquareFreeRegularTriangularSetGcdPackage(D5,D6,D7,D2,
--R            D3)
--R             if D5 has GCDDOM and D6 has OAMONS and D7 has ORDSET and 
--R            D2 has RPOLCAT(D5,D6,D7) and D3 has RSETCAT(D5,D6,D7,D2)
--R         
--R   [2] (List(Record(val: List(D7),tower: D8)),D3,Boolean) -> List(
--R            Record(val: D7,tower: D8))
--R             from SquareFreeRegularTriangularSetGcdPackage(D5,D6,D3,D7,
--R            D8)
--R             if D7 has RPOLCAT(D5,D6,D3) and D8 has RSETCAT(D5,D6,D3,D7
--R            ) and D5 has GCDDOM and D6 has OAMONS and D3 has ORDSET
--R
--RExamples of stoseInternalLastSubResultant from SquareFreeRegularTriangularSetGcdPackage
--R
--E 2974

--S 2975 of 3320
)d op stoseInvertible?
--R 
--R
--RThere are 2 exposed functions called stoseInvertible? :
--R   [1] (D2,D3) -> Boolean
--R             from SquareFreeRegularTriangularSetGcdPackage(D4,D5,D6,D2,
--R            D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R   [2] (D2,D3) -> List(Record(val: Boolean,tower: D3))
--R             from SquareFreeRegularTriangularSetGcdPackage(D4,D5,D6,D2,
--R            D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of stoseInvertible? from SquareFreeRegularTriangularSetGcdPackage
--R
--E 2975

--S 2976 of 3320
--R-----------------)d op stoseInvertible?_reg (fix this)
--E 2976

--S 2977 of 3320
)d op stoseInvertibleSet
--R 
--R
--RThere is one exposed function called stoseInvertibleSet :
--R   [1] (D2,D3) -> List(D3)
--R             from SquareFreeRegularTriangularSetGcdPackage(D4,D5,D6,D2,
--R            D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of stoseInvertibleSet from SquareFreeRegularTriangularSetGcdPackage
--R
--E 2977

--S 2978 of 3320
--R-----------------)d op stoseInvertibleSet_reg (fix this)
--E 2978

--S 2979 of 3320
--R-----------------)d op stoseInvertibleSet_sqfreg (fix this)
--E 2979

--S 2980 of 3320
--R-----------------)d op stoseInvertible?_sqfreg (fix this)
--E 2980

--S 2981 of 3320
)d op stoseLastSubResultant
--R 
--R
--RThere is one exposed function called stoseLastSubResultant :
--R   [1] (D2,D2,D3) -> List(Record(val: D2,tower: D3))
--R             from SquareFreeRegularTriangularSetGcdPackage(D4,D5,D6,D2,
--R            D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of stoseLastSubResultant from SquareFreeRegularTriangularSetGcdPackage
--R
--E 2981

--S 2982 of 3320
)d op stosePrepareSubResAlgo
--R 
--R
--RThere is one exposed function called stosePrepareSubResAlgo :
--R   [1] (D2,D2,D3) -> List(Record(val: List(D2),tower: D3))
--R             from SquareFreeRegularTriangularSetGcdPackage(D4,D5,D6,D2,
--R            D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of stosePrepareSubResAlgo from SquareFreeRegularTriangularSetGcdPackage
--R
--E 2982

--S 2983 of 3320
)d op stoseSquareFreePart
--R 
--R
--RThere is one exposed function called stoseSquareFreePart :
--R   [1] (D2,D3) -> List(Record(val: D2,tower: D3))
--R             from SquareFreeRegularTriangularSetGcdPackage(D4,D5,D6,D2,
--R            D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of stoseSquareFreePart from SquareFreeRegularTriangularSetGcdPackage
--R
--E 2983

--S 2984 of 3320
)d op string
--R 
--R
--RThere are 3 exposed functions called string :
--R   [1] D -> D1 from D
--R             if D has SEXCAT(D1,D2,D3,D4,D5) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D1 has 
--R            SETCAT
--R   [2] Integer -> D from D if D has STRICAT
--R   [3] Symbol -> String from Symbol
--R
--RThere is one unexposed function called string :
--R   [1] OutputForm -> OutputForm from OutputForm
--R
--RExamples of string from OutputForm
--R
--R
--RExamples of string from SExpressionCategory
--R
--R
--RExamples of string from StringCategory
--R
--R
--RExamples of string from Symbol
--R
--RS:="Hello"::Symbol 
--Rstring S
--R
--E 2984

--S 2985 of 3320
)d op string?
--R 
--R
--RThere is one exposed function called string? :
--R   [1] D -> Boolean from D
--R             if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R
--RExamples of string? from SExpressionCategory
--R
--E 2985

--S 2986 of 3320
)d op stripCommentsAndBlanks
--R 
--R
--RThere is one exposed function called stripCommentsAndBlanks :
--R   [1] String -> String from TemplateUtilities
--R
--RExamples of stripCommentsAndBlanks from TemplateUtilities
--R
--E 2986

--S 2987 of 3320
)d op strongGenerators
--R 
--R
--RThere is one exposed function called strongGenerators :
--R   [1] PermutationGroup(D2) -> List(Permutation(D2)) from 
--R            PermutationGroup(D2)
--R             if D2 has SETCAT
--R
--RExamples of strongGenerators from PermutationGroup
--R
--E 2987

--S 2988 of 3320
)d op stronglyReduce
--R 
--R
--RThere is one exposed function called stronglyReduce :
--R   [1] (D1,D) -> D1 from D
--R             if D has TSETCAT(D2,D3,D4,D1) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D1 has RPOLCAT(D2,D3,D4)
--R            
--R
--RExamples of stronglyReduce from TriangularSetCategory
--R
--E 2988

--S 2989 of 3320
)d op stronglyReduced?
--R 
--R
--RThere are 2 exposed functions called stronglyReduced? :
--R   [1] D -> Boolean from D
--R             if D has TSETCAT(D2,D3,D4,D5) and D2 has INTDOM and D3
--R             has OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R            
--R   [2] (D2,D) -> Boolean from D
--R             if D has TSETCAT(D3,D4,D5,D2) and D3 has INTDOM and D4
--R             has OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
--R            
--R
--RExamples of stronglyReduced? from TriangularSetCategory
--R
--E 2989

--S 2990 of 3320
)d op structuralConstants
--R 
--R
--RThere are 5 exposed functions called structuralConstants :
--R   [1] Vector(D) -> Vector(Matrix(D3)) from D if D has FINAALG(D3) and 
--R            D3 has COMRING
--R   [2]  -> Vector(Matrix(D2)) from D if D has FRNAALG(D2) and D2 has 
--R            COMRING
--R   [3] (List(Symbol),Matrix(Fraction(Polynomial(D4)))) -> Vector(Matrix
--R            (Fraction(Polynomial(D4))))
--R             from StructuralConstantsPackage(D4) if D4 has FIELD
--R   [4] (List(Symbol),Matrix(Polynomial(D4))) -> Vector(Matrix(
--R            Polynomial(D4)))
--R             from StructuralConstantsPackage(D4) if D4 has FIELD
--R   [5] List(Matrix(D3)) -> Vector(Matrix(D3))
--R             from StructuralConstantsPackage(D3) if D3 has FIELD
--R
--RThere is one unexposed function called structuralConstants :
--R   [1]  -> Vector(Matrix(D3)) from FramedNonAssociativeAlgebra&(D2,D3)
--R             if D3 has COMRING and D2 has FRNAALG(D3)
--R
--RExamples of structuralConstants from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of structuralConstants from FramedNonAssociativeAlgebra&
--R
--R
--RExamples of structuralConstants from FramedNonAssociativeAlgebra
--R
--R
--RExamples of structuralConstants from StructuralConstantsPackage
--R
--E 2990

--S 2991 of 3320
)d op sts2stst
--R 
--R
--RThere is one unexposed function called sts2stst :
--R   [1] (Symbol,Stream(Polynomial(D4))) -> Stream(Stream(Polynomial(D4))
--R            )
--R             from WeierstrassPreparation(D4) if D4 has FIELD
--R
--RExamples of sts2stst from WeierstrassPreparation
--R
--E 2991

--S 2992 of 3320
)d op SturmHabicht
--R 
--R
--RThere is one exposed function called SturmHabicht :
--R   [1] (UnivariatePolynomial(D4,D3),UnivariatePolynomial(D4,D3)) -> 
--R            Integer
--R             from SturmHabichtPackage(D3,D4) if D3 has OINTDOM and D4: 
--R            SYMBOL
--R
--RExamples of SturmHabicht from SturmHabichtPackage
--R
--E 2992

--S 2993 of 3320
)d op SturmHabichtCoefficients
--R 
--R
--RThere is one exposed function called SturmHabichtCoefficients :
--R   [1] (UnivariatePolynomial(D4,D3),UnivariatePolynomial(D4,D3)) -> 
--R            List(D3)
--R             from SturmHabichtPackage(D3,D4) if D3 has OINTDOM and D4: 
--R            SYMBOL
--R
--RExamples of SturmHabichtCoefficients from SturmHabichtPackage
--R
--E 2993

--S 2994 of 3320
)d op SturmHabichtSequence
--R 
--R
--RThere is one exposed function called SturmHabichtSequence :
--R   [1] (UnivariatePolynomial(D4,D3),UnivariatePolynomial(D4,D3)) -> 
--R            List(UnivariatePolynomial(D4,D3))
--R             from SturmHabichtPackage(D3,D4) if D3 has OINTDOM and D4: 
--R            SYMBOL
--R
--RExamples of SturmHabichtSequence from SturmHabichtPackage
--R
--E 2994

--S 2995 of 3320
)d op sturmSequence
--R 
--R
--RThere is one exposed function called sturmSequence :
--R   [1] D2 -> List(D2) from RealPolynomialUtilitiesPackage(D3,D2)
--R             if D3 has FIELD and D2 has UPOLYC(D3)
--R
--RExamples of sturmSequence from RealPolynomialUtilitiesPackage
--R
--E 2995

--S 2996 of 3320
)d op sturmVariationsOf
--R 
--R
--RThere is one exposed function called sturmVariationsOf :
--R   [1] List(D3) -> NonNegativeInteger from 
--R            RealPolynomialUtilitiesPackage(D3,D4)
--R             if D3 has ORDRING and D3 has FIELD and D4 has UPOLYC(D3)
--R         
--R
--RExamples of sturmVariationsOf from RealPolynomialUtilitiesPackage
--R
--E 2996

--S 2997 of 3320
)d op style
--R 
--R
--RThere is one exposed function called style :
--R   [1] String -> DrawOption from DrawOption
--R
--RThere is one unexposed function called style :
--R   [1] (List(DrawOption),String) -> String from DrawOptionFunctions0
--R         
--R
--RExamples of style from DrawOptionFunctions0
--R
--R
--RExamples of style from DrawOption
--R
--E 2997

--S 2998 of 3320
)d op sub
--R 
--R
--RThere is one unexposed function called sub :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of sub from OutputForm
--R
--E 2998

--S 2999 of 3320
)d op subCase?
--R 
--R
--RThere are 2 exposed functions called subCase? :
--R   [1] (Record(val: List(D6),tower: D7),Record(val: List(D6),tower: D7)
--R            ) -> Boolean
--R             from QuasiComponentPackage(D3,D4,D5,D6,D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D7 has RSETCAT(D3,D4,D5,D6
--R            ) and D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET
--R   [2] (Record(val: List(D6),tower: D7),Record(val: List(D6),tower: D7)
--R            ) -> Boolean
--R             from SquareFreeQuasiComponentPackage(D3,D4,D5,D6,D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D7 has RSETCAT(D3,D4,D5,D6
--R            ) and D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET
--R
--RExamples of subCase? from QuasiComponentPackage
--R
--R
--RExamples of subCase? from SquareFreeQuasiComponentPackage
--R
--E 2999

--S 3000 of 3320
)d op subHeight
--R 
--R
--RThere is one unexposed function called subHeight :
--R   [1] OutputForm -> Integer from OutputForm
--R
--RExamples of subHeight from OutputForm
--R
--E 3000

--S 3001 of 3320 done
)d op subMatrix
--R 
--R
--RThere are 3 exposed functions called subMatrix :
--R   [1] (D1,List(PositiveInteger),List(PositiveInteger)) -> D1
--R             from MatrixManipulation(D3,D4,D5,D1)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D1 has MATCAT(D3,D4,D5)
--R   [2] (D1,Segment(PositiveInteger),Segment(PositiveInteger)) -> D1
--R             from MatrixManipulation(D3,D4,D5,D1)
--R             if D3 has FIELD and D4 has FLAGG(D3) and D5 has FLAGG(D3) 
--R            and D1 has MATCAT(D3,D4,D5)
--R   [3] (D,Integer,Integer,Integer,Integer) -> D from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R
--RExamples of subMatrix from MatrixManipulation
--R
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--RsubMatrix(M, 1..2,2..3)
--R
--RM := matrix([[a,b,c],[d,e,f],[g,h,i]]) 
--RsubMatrix(M, [1,2],[1,2]) 
--RsubMatrix(M, [1,3],[1,3])
--R
--R
--RExamples of subMatrix from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--RsubMatrix(m,1,3,2,4)
--R
--E 3001

--S 3002 of 3320
)d op submod
--R 
--R
--RThere is one exposed function called submod :
--R   [1] (D,D,D) -> D from D if D has INS
--R
--RExamples of submod from IntegerNumberSystem
--R
--E 3002

--S 3003 of 3320
)d op subMultV
--R 
--R
--RThere is one exposed function called subMultV :
--R   [1] D -> NonNegativeInteger from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of subMultV from InfinitlyClosePointCategory
--R
--E 3003

--S 3004 of 3320
)d op subNode?
--R 
--R
--RThere is one unexposed function called subNode? :
--R   [1] (SplittingNode(D3,D4),SplittingNode(D3,D4),((D4,D4) -> Boolean))
--R             -> Boolean
--R             from SplittingNode(D3,D4)
--R             if D4 has Join(SetCategory,Aggregate) and D3 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of subNode? from SplittingNode
--R
--E 3004

--S 3005 of 3320
)d op subNodeOf?
--R 
--R
--RThere is one unexposed function called subNodeOf? :
--R   [1] (SplittingNode(D4,D5),SplittingTree(D4,D5),((D5,D5) -> Boolean))
--R             -> Boolean
--R             from SplittingTree(D4,D5)
--R             if D4 has Join(SetCategory,Aggregate) and D5 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of subNodeOf? from SplittingTree
--R
--E 3005

--S 3006 of 3320
)d op subPolSet?
--R 
--R
--RThere are 2 exposed functions called subPolSet? :
--R   [1] (List(D6),List(D6)) -> Boolean from QuasiComponentPackage(D3,D4,
--R            D5,D6,D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [2] (List(D6),List(D6)) -> Boolean
--R             from SquareFreeQuasiComponentPackage(D3,D4,D5,D6,D7)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D7 has RSETCAT(D3,D4,D5,D6)
--R         
--R
--RExamples of subPolSet? from QuasiComponentPackage
--R
--R
--RExamples of subPolSet? from SquareFreeQuasiComponentPackage
--R
--E 3006

--S 3007 of 3320
)d op subQuasiComponent?
--R 
--R
--RThere are 4 exposed functions called subQuasiComponent? :
--R   [1] (D2,D2) -> Boolean from QuasiComponentPackage(D3,D4,D5,D6,D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D2 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [2] (D2,List(D2)) -> Boolean from QuasiComponentPackage(D4,D5,D6,D7,
--R            D2)
--R             if D2 has RSETCAT(D4,D5,D6,D7) and D4 has GCDDOM and D5
--R             has OAMONS and D6 has ORDSET and D7 has RPOLCAT(D4,D5,D6)
--R            
--R   [3] (D2,D2) -> Boolean from SquareFreeQuasiComponentPackage(D3,D4,D5
--R            ,D6,D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D2 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [4] (D2,List(D2)) -> Boolean
--R             from SquareFreeQuasiComponentPackage(D4,D5,D6,D7,D2)
--R             if D2 has RSETCAT(D4,D5,D6,D7) and D4 has GCDDOM and D5
--R             has OAMONS and D6 has ORDSET and D7 has RPOLCAT(D4,D5,D6)
--R            
--R
--RExamples of subQuasiComponent? from QuasiComponentPackage
--R
--R
--RExamples of subQuasiComponent? from SquareFreeQuasiComponentPackage
--R
--E 3007

--S 3008 of 3320
)d op subResultantChain
--R 
--R
--RThere is one exposed function called subResultantChain :
--R   [1] (D,D) -> List(D) from D
--R             if D2 has INTDOM and D2 has RING and D3 has OAMONS and D4
--R             has ORDSET and D has RPOLCAT(D2,D3,D4)
--R
--RExamples of subResultantChain from RecursivePolynomialCategory
--R
--E 3008

--S 3009 of 3320
)d op subResultantGcd
--R 
--R
--RThere are 2 exposed functions called subResultantGcd :
--R   [1] (D,D) -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET and D1 has INTDOM
--R   [2] (D,D) -> D from D if D has UPOLYC(D1) and D1 has RING and D1
--R             has INTDOM
--R
--RThere is one unexposed function called subResultantGcd :
--R   [1] (D1,D1) -> D1 from PseudoRemainderSequence(D2,D1)
--R             if D2 has INTDOM and D1 has UPOLYC(D2)
--R
--RExamples of subResultantGcd from PseudoRemainderSequence
--R
--R
--RExamples of subResultantGcd from RecursivePolynomialCategory
--R
--R
--RExamples of subResultantGcd from UnivariatePolynomialCategory
--R
--E 3009

--S 3010 of 3320
)d op subResultantGcdEuclidean
--R 
--R
--RThere is one unexposed function called subResultantGcdEuclidean :
--R   [1] (D2,D2) -> Record(coef1: D2,coef2: D2,gcd: D2)
--R             from PseudoRemainderSequence(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of subResultantGcdEuclidean from PseudoRemainderSequence
--R
--E 3010

--S 3011 of 3320
)d op subResultantsChain
--R 
--R
--RThere is one unexposed function called subResultantsChain :
--R   [1] (NewSparseUnivariatePolynomial(D2),NewSparseUnivariatePolynomial
--R            (D2)) -> List(NewSparseUnivariatePolynomial(D2))
--R             from NewSparseUnivariatePolynomial(D2) if D2 has INTDOM 
--R            and D2 has RING
--R
--RExamples of subResultantsChain from NewSparseUnivariatePolynomial
--R
--E 3011

--S 3012 of 3320
)d op subresultantSequence
--R 
--R
--RThere is one exposed function called subresultantSequence :
--R   [1] (UnivariatePolynomial(D4,D3),UnivariatePolynomial(D4,D3)) -> 
--R            List(UnivariatePolynomial(D4,D3))
--R             from SturmHabichtPackage(D3,D4) if D3 has OINTDOM and D4: 
--R            SYMBOL
--R
--RExamples of subresultantSequence from SturmHabichtPackage
--R
--E 3012

--S 3013 of 3320
)d op subresultantVector
--R 
--R
--RThere is one unexposed function called subresultantVector :
--R   [1] (D2,D2) -> PrimitiveArray(D2) from SubResultantPackage(D3,D2)
--R             if D3 has INTDOM and D2 has UPOLYC(D3)
--R
--RExamples of subresultantVector from SubResultantPackage
--R
--E 3013

--S 3014 of 3320
)d op subs1stVar
--R 
--R
--RThere is one exposed function called subs1stVar :
--R   [1] (D1,D1) -> D1 from PackageForPoly(D2,D1,D3,D4)
--R             if D2 has RING and D3 has DIRPCAT(D4,NNI) and D4: NNI and 
--R            D1 has FAMR(D2,D3)
--R
--RExamples of subs1stVar from PackageForPoly
--R
--E 3014

--S 3015 of 3320
)d op subs2ndVar
--R 
--R
--RThere is one exposed function called subs2ndVar :
--R   [1] (D1,D1) -> D1 from PackageForPoly(D2,D1,D3,D4)
--R             if D2 has RING and D3 has DIRPCAT(D4,NNI) and D4: NNI and 
--R            D1 has FAMR(D2,D3)
--R
--RExamples of subs2ndVar from PackageForPoly
--R
--E 3015

--S 3016 of 3320
)d op subscript
--R 
--R
--RThere is one exposed function called subscript :
--R   [1] (Symbol,List(OutputForm)) -> Symbol from Symbol
--R
--RExamples of subscript from Symbol
--R
--Rsubscript(Big,[a,1])
--R
--E 3016

--S 3017 of 3320
)d op subscriptedVariables
--R 
--R
--RThere is one exposed function called subscriptedVariables :
--R   [1] Expression(DoubleFloat) -> Expression(DoubleFloat) from 
--R            d03AgentsPackage
--R
--RExamples of subscriptedVariables from d03AgentsPackage
--R
--E 3017

--S 3018 of 3320
)d op subset?
--R 
--R
--RThere is one exposed function called subset? :
--R   [1] (D,D) -> Boolean from D if D has SETAGG(D2) and D2 has SETCAT
--R         
--R
--RExamples of subset? from SetAggregate
--R
--E 3018

--S 3019 of 3320
)d op subSet
--R 
--R
--RThere is one exposed function called subSet :
--R   [1] (Integer,Integer,Integer) -> List(Integer)
--R             from SymmetricGroupCombinatoricFunctions
--R
--RExamples of subSet from SymmetricGroupCombinatoricFunctions
--R
--E 3019

--S 3020 of 3320
)d op subsInVar
--R 
--R
--RThere is one exposed function called subsInVar :
--R   [1] (D1,D1,Integer) -> D1 from PackageForPoly(D3,D1,D4,D5)
--R             if D3 has RING and D4 has DIRPCAT(D5,NNI) and D5: NNI and 
--R            D1 has FAMR(D3,D4)
--R
--RExamples of subsInVar from PackageForPoly
--R
--E 3020

--S 3021 of 3320
)d op subspace
--R 
--R
--RThere are 3 exposed functions called subspace :
--R   [1] D -> SubSpace(3,D2) from D if D has SPACEC(D2) and D2 has RING
--R         
--R   [2] (ThreeDimensionalViewport,ThreeSpace(DoubleFloat)) -> 
--R            ThreeDimensionalViewport
--R             from ThreeDimensionalViewport
--R   [3] ThreeDimensionalViewport -> ThreeSpace(DoubleFloat)
--R             from ThreeDimensionalViewport
--R
--RThere is one unexposed function called subspace :
--R   [1]  -> SubSpace(D1,D2) from SubSpace(D1,D2) if D1: PI and D2 has 
--R            RING
--R
--RExamples of subspace from ThreeSpaceCategory
--R
--R
--RExamples of subspace from SubSpace
--R
--R
--RExamples of subspace from ThreeDimensionalViewport
--R
--E 3021

--S 3022 of 3320
)d op subst
--R 
--R
--RThere are 4 exposed functions called subst :
--R   [1] (Equation(D1),Equation(D1)) -> Equation(D1) from Equation(D1)
--R             if D1 has ES and D1 has TYPE
--R   [2] (D,List(Kernel(D)),List(D)) -> D from D if D has ES
--R   [3] (D,List(Equation(D))) -> D from D if D has ES
--R   [4] (D,Equation(D)) -> D from D if D has ES
--R
--RExamples of subst from Equation
--R
--R
--RExamples of subst from ExpressionSpace
--R
--E 3022

--S 3023 of 3320
)d op substitute
--R 
--R
--RThere is one unexposed function called substitute :
--R   [1] (D1,D1,ListMultiDictionary(D1)) -> ListMultiDictionary(D1)
--R             from ListMultiDictionary(D1) if D1 has SETCAT
--R
--RExamples of substitute from ListMultiDictionary
--R
--E 3023

--S 3024 of 3320
)d op substring?
--R 
--R
--RThere is one exposed function called substring? :
--R   [1] (D,D,Integer) -> Boolean from D if D has SRAGG
--R
--RExamples of substring? from StringAggregate
--R
--E 3024

--S 3025 of 3320
)d op subtractIfCan
--R 
--R
--RThere is one exposed function called subtractIfCan :
--R   [1] (D,D) -> Union(D,"failed") from D if D has CABMON
--R
--RExamples of subtractIfCan from CancellationAbelianMonoid
--R
--E 3025

--S 3026 of 3320
)d op subTriSet?
--R 
--R
--RThere are 2 exposed functions called subTriSet? :
--R   [1] (D2,D2) -> Boolean from QuasiComponentPackage(D3,D4,D5,D6,D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D2 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [2] (D2,D2) -> Boolean from SquareFreeQuasiComponentPackage(D3,D4,D5
--R            ,D6,D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D2 has RSETCAT(D3,D4,D5,D6)
--R         
--R
--RExamples of subTriSet? from QuasiComponentPackage
--R
--R
--RExamples of subTriSet? from SquareFreeQuasiComponentPackage
--R
--E 3026

--S 3027 of 3320
)d op suchThat
--R 
--R
--RThere are 5 exposed functions called suchThat :
--R   [1] (D1,(D4 -> Boolean)) -> D1 from FunctionSpaceAttachPredicates(D3
--R            ,D1,D4)
--R             if D4 has TYPE and D3 has ORDSET and D1 has FS(D3)
--R   [2] (D1,List((D4 -> Boolean))) -> D1
--R             from FunctionSpaceAttachPredicates(D3,D1,D4)
--R             if D4 has TYPE and D3 has ORDSET and D1 has FS(D3)
--R   [3] (Symbol,(D4 -> Boolean)) -> Expression(Integer) from 
--R            AttachPredicates(D4)
--R             if D4 has TYPE
--R   [4] (Symbol,List((D4 -> Boolean))) -> Expression(Integer)
--R             from AttachPredicates(D4) if D4 has TYPE
--R   [5] (RewriteRule(D3,D4,D5),List(Symbol),(List(D5) -> Boolean)) -> 
--R            RewriteRule(D3,D4,D5)
--R             from RewriteRule(D3,D4,D5)
--R             if D5 has Join(FunctionSpace(D4),PatternMatchable(D3),
--R            ConvertibleTo(Pattern(D3))) and D3 has SETCAT and D4 has 
--R            Join(Ring,PatternMatchable(D3),OrderedSet,ConvertibleTo(
--R            Pattern(D3)))
--R
--RThere are 3 unexposed functions called suchThat :
--R   [1] (Pattern(D3),(D4 -> Boolean)) -> Pattern(D3)
--R             from PatternFunctions1(D3,D4) if D3 has SETCAT and D4 has 
--R            TYPE
--R   [2] (Pattern(D3),List((D4 -> Boolean))) -> Pattern(D3)
--R             from PatternFunctions1(D3,D4) if D3 has SETCAT and D4 has 
--R            TYPE
--R   [3] (Pattern(D4),List(Symbol),(List(D5) -> Boolean)) -> Pattern(D4)
--R             from PatternFunctions1(D4,D5) if D4 has SETCAT and D5 has 
--R            TYPE
--R
--RExamples of suchThat from PatternFunctions1
--R
--R
--RExamples of suchThat from FunctionSpaceAttachPredicates
--R
--R
--RExamples of suchThat from AttachPredicates
--R
--R
--RExamples of suchThat from RewriteRule
--R
--E 3027

--S 3028 of 3320
)d op suffix?
--R 
--R
--RThere is one exposed function called suffix? :
--R   [1] (D,D) -> Boolean from D if D has SRAGG
--R
--RExamples of suffix? from StringAggregate
--R
--E 3028

--S 3029 of 3320
)d op sum
--R 
--R
--RThere are 6 exposed functions called sum :
--R   [1] (D1,Symbol) -> D1 from FunctionSpaceSum(D3,D1)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer)) and D1 has Join
--R            (FunctionSpace(D3),CombinatorialOpsCategory,
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory)
--R         
--R   [2] (D1,SegmentBinding(D1)) -> D1 from FunctionSpaceSum(D3,D1)
--R             if D1 has Join(FunctionSpace(D3),CombinatorialOpsCategory,
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory) 
--R            and D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer))
--R   [3] (Polynomial(D4),Symbol) -> Fraction(Polynomial(D4))
--R             from RationalFunctionSum(D4)
--R             if D4 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer))
--R   [4] (Fraction(Polynomial(D4)),Symbol) -> Union(Fraction(Polynomial(
--R            D4)),Expression(D4))
--R             from RationalFunctionSum(D4)
--R             if D4 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer))
--R   [5] (Polynomial(D4),SegmentBinding(Polynomial(D4))) -> Fraction(
--R            Polynomial(D4))
--R             from RationalFunctionSum(D4)
--R             if D4 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer))
--R   [6] (Fraction(Polynomial(D4)),SegmentBinding(Fraction(Polynomial(D4)
--R            ))) -> Union(Fraction(Polynomial(D4)),Expression(D4))
--R             from RationalFunctionSum(D4)
--R             if D4 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer))
--R
--RThere are 5 unexposed functions called sum :
--R   [1] (D2,D3,Segment(D2)) -> Record(num: D2,den: Integer)
--R             from InnerPolySum(D5,D3,D6,D2)
--R             if D2 has POLYCAT(D6,D5,D3) and D5 has OAMONS and D3 has 
--R            ORDSET and D6 has INTDOM
--R   [2] (D2,D3) -> Record(num: D2,den: Integer) from InnerPolySum(D4,D3,
--R            D5,D2)
--R             if D4 has OAMONS and D3 has ORDSET and D5 has INTDOM and 
--R            D2 has POLYCAT(D5,D4,D3)
--R   [3] (OutputForm,OutputForm,OutputForm) -> OutputForm from OutputForm
--R            
--R   [4] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R   [5] OutputForm -> OutputForm from OutputForm
--R
--RExamples of sum from InnerPolySum
--R
--R
--RExamples of sum from OutputForm
--R
--R
--RExamples of sum from FunctionSpaceSum
--R
--R
--RExamples of sum from RationalFunctionSum
--R
--Rsum(i::Fraction(Polynomial(Integer)),i=1..n)
--R
--Rsum(i,i=1..n)
--R
--Rsum(i::Fraction(Polynomial(Integer)),i::Symbol)
--R
--Rsum(i::Polynomial(Integer),variable(i=1..n))
--R
--E 3029

--S 3030 of 3320 done
)d op summary
--R 
--R
--RThere is one exposed function called summary :
--R   [1]  -> Void from ApplicationProgramInterface
--R
--RExamples of summary from ApplicationProgramInterface
--R
--Rsummary()
--R
--E 3030

--S 3031 of 3320
)d op summation
--R 
--R
--RThere are 2 exposed functions called summation :
--R   [1] (D,SegmentBinding(D)) -> D from D if D has COMBOPC
--R   [2] (D,Symbol) -> D from D if D has COMBOPC
--R
--RThere are 2 unexposed functions called summation :
--R   [1] (D1,Symbol) -> D1 from CombinatorialFunction(D3,D1)
--R             if D3 has Join(OrderedSet,IntegralDomain) and D1 has FS(D3
--R            )
--R   [2] (D1,SegmentBinding(D1)) -> D1 from CombinatorialFunction(D3,D1)
--R             if D1 has FS(D3) and D3 has Join(OrderedSet,IntegralDomain
--R            )
--R
--RExamples of summation from CombinatorialFunction
--R
--R
--RExamples of summation from CombinatorialOpsCategory
--R
--E 3031

--S 3032 of 3320
)d op sumOfDivisors
--R 
--R
--RThere is one exposed function called sumOfDivisors :
--R   [1] Integer -> Integer from IntegerNumberTheoryFunctions
--R
--RExamples of sumOfDivisors from IntegerNumberTheoryFunctions
--R
--E 3032

--S 3033 of 3320
)d op sumOfKthPowerDivisors
--R 
--R
--RThere is one exposed function called sumOfKthPowerDivisors :
--R   [1] (Integer,NonNegativeInteger) -> Integer from 
--R            IntegerNumberTheoryFunctions
--R
--RExamples of sumOfKthPowerDivisors from IntegerNumberTheoryFunctions
--R
--E 3033

--S 3034 of 3320
)d op sumOfSquares
--R 
--R
--RThere is one exposed function called sumOfSquares :
--R   [1] Expression(DoubleFloat) -> Union(Expression(DoubleFloat),
--R            "failed")
--R             from e04AgentsPackage
--R
--RExamples of sumOfSquares from e04AgentsPackage
--R
--E 3034

--S 3035 of 3320
)d op sumSquares
--R 
--R
--RThere is one exposed function called sumSquares :
--R   [1] Integer -> List(Integer) from GaussianFactorizationPackage
--R
--RExamples of sumSquares from GaussianFactorizationPackage
--R
--E 3035

--S 3036 of 3320
)d op sup
--R 
--R
--RThere are 2 exposed functions called sup :
--R   [1] D -> D1 from D
--R             if D has INTCAT(D1) and D1 has Join(FloatingPointSystem,
--R            TranscendentalFunctionCategory)
--R   [2] (D,D) -> D from D if D has OAMONS
--R
--RExamples of sup from IntervalCategory
--R
--R
--RExamples of sup from OrderedAbelianMonoidSup
--R
--E 3036

--S 3037 of 3320
)d op supDimElseRittWu?
--R 
--R
--RThere are 2 exposed functions called supDimElseRittWu? :
--R   [1] (D2,D2) -> Boolean from QuasiComponentPackage(D3,D4,D5,D6,D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D2 has RSETCAT(D3,D4,D5,D6)
--R         
--R   [2] (D2,D2) -> Boolean from SquareFreeQuasiComponentPackage(D3,D4,D5
--R            ,D6,D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D2 has RSETCAT(D3,D4,D5,D6)
--R         
--R
--RExamples of supDimElseRittWu? from QuasiComponentPackage
--R
--R
--RExamples of supDimElseRittWu? from SquareFreeQuasiComponentPackage
--R
--E 3037

--S 3038 of 3320
)d op super
--R 
--R
--RThere is one unexposed function called super :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of super from OutputForm
--R
--E 3038

--S 3039 of 3320
)d op superHeight
--R 
--R
--RThere is one unexposed function called superHeight :
--R   [1] OutputForm -> Integer from OutputForm
--R
--RExamples of superHeight from OutputForm
--R
--E 3039

--S 3040 of 3320 done
)d op superscript
--R 
--R
--RThere is one exposed function called superscript :
--R   [1] (Symbol,List(OutputForm)) -> Symbol from Symbol
--R
--RExamples of superscript from Symbol
--R
--Rsuperscript(Big,[a,1])
--R
--E 3040

--S 3041 of 3320
)d op supersub
--R 
--R
--RThere is one unexposed function called supersub :
--R   [1] (OutputForm,List(OutputForm)) -> OutputForm from OutputForm
--R
--RExamples of supersub from OutputForm
--R
--E 3041

--S 3042 of 3320
)d op supp
--R 
--R
--RThere is one exposed function called supp :
--R   [1] D -> List(D2) from D if D has DIVCAT(D2) and D2 has SETCAT
--R
--RExamples of supp from DivisorCategory
--R
--E 3042

--S 3043 of 3320
)d op suppOfPole
--R 
--R
--RThere is one exposed function called suppOfPole :
--R   [1] D -> List(D2) from D if D has DIVCAT(D2) and D2 has SETCAT
--R
--RExamples of suppOfPole from DivisorCategory
--R
--E 3043

--S 3044 of 3320
)d op suppOfZero
--R 
--R
--RThere is one exposed function called suppOfZero :
--R   [1] D -> List(D2) from D if D has DIVCAT(D2) and D2 has SETCAT
--R
--RExamples of suppOfZero from DivisorCategory
--R
--E 3044

--S 3045 of 3320
)d op supRittWu?
--R 
--R
--RThere is one exposed function called supRittWu? :
--R   [1] (D,D) -> Boolean from D
--R             if D has RPOLCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RExamples of supRittWu? from RecursivePolynomialCategory
--R
--E 3045

--S 3046 of 3320
)d op surface
--R 
--R
--RThere is one exposed function called surface :
--R   [1] (D1,D1,D1) -> ParametricSurface(D1) from ParametricSurface(D1)
--R             if D1 has TYPE
--R
--RExamples of surface from ParametricSurface
--R
--E 3046

--S 3047 of 3320
)d op swap
--R 
--R
--RThere is one exposed function called swap :
--R   [1] Equation(D1) -> Equation(D1) from Equation(D1) if D1 has TYPE
--R         
--R
--RThere is one unexposed function called swap :
--R   [1] D1 -> D1 from CommuteUnivariatePolynomialCategory(D2,D3,D1)
--R             if D2 has RING and D3 has UPOLYC(D2) and D1 has UPOLYC(D3)
--R            
--R
--RExamples of swap from CommuteUnivariatePolynomialCategory
--R
--R
--RExamples of swap from Equation
--R
--E 3047

--S 3048 of 3320
)d op swap!
--R 
--R
--RThere is one exposed function called swap! :
--R   [1] (D,D2,D2) -> Void from D
--R             if D has shallowlyMutable and D has IXAGG(D2,D3) and D2
--R             has SETCAT and D3 has TYPE
--R
--RExamples of swap! from IndexedAggregate
--R
--E 3048

--S 3049 of 3320 done
)d op swapColumns!
--R 
--R
--RThere is one exposed function called swapColumns! :
--R   [1] (D,Integer,Integer) -> D from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R
--RExamples of swapColumns! from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--RswapColumns!(m,2,4)
--R
--E 3049

--S 3050 of 3320 done
)d op swapRows!
--R 
--R
--RThere is one exposed function called swapRows! :
--R   [1] (D,Integer,Integer) -> D from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R
--RExamples of swapRows! from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--RswapRows!(m,2,4)
--R
--E 3050

--S 3051 of 3320
)d op sylvesterMatrix
--R 
--R
--RThere is one unexposed function called sylvesterMatrix :
--R   [1] (D2,D2) -> D1 from BezoutMatrix(D3,D2,D1,D4,D5)
--R             if D3 has RING and D1 has MATCAT(D3,D4,D5) and D2 has 
--R            UPOLYC(D3) and D4 has FLAGG(D3) and D5 has FLAGG(D3)
--R
--RExamples of sylvesterMatrix from BezoutMatrix
--R
--E 3051

--S 3052 of 3320
)d op sylvesterSequence
--R 
--R
--RThere is one exposed function called sylvesterSequence :
--R   [1] (D2,D2) -> List(D2) from RealPolynomialUtilitiesPackage(D3,D2)
--R             if D3 has FIELD and D2 has UPOLYC(D3)
--R
--RExamples of sylvesterSequence from RealPolynomialUtilitiesPackage
--R
--E 3052

--S 3053 of 3320
)d op symbNameV
--R 
--R
--RThere is one exposed function called symbNameV :
--R   [1] D -> Symbol from D
--R             if D has INFCLCT(D4,D5,D6,D7,D8,D9,D10,D1,D2) and D4 has 
--R            FIELD and D6 has POLYCAT(D4,D7,OVAR(D5)) and D7 has DIRPCAT
--R            (#(D5),NNI) and D8 has PRSPCAT(D4) and D9 has LOCPOWC(D4) 
--R            and D10 has PLACESC(D4,D9) and D2 has BLMETCT
--R
--RExamples of symbNameV from InfinitlyClosePointCategory
--R
--E 3053

--S 3054 of 3320
)d op symbol
--R 
--R
--RThere is one exposed function called symbol :
--R   [1] D -> D1 from D
--R             if D has SEXCAT(D2,D1,D3,D4,D5) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D1 has 
--R            SETCAT
--R
--RExamples of symbol from SExpressionCategory
--R
--E 3054

--S 3055 of 3320
)d op symbol?
--R 
--R
--RThere is one exposed function called symbol? :
--R   [1] D -> Boolean from D
--R             if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3
--R             has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
--R            SETCAT
--R
--RThere is one unexposed function called symbol? :
--R   [1] Pattern(D2) -> Boolean from Pattern(D2) if D2 has SETCAT
--R
--RExamples of symbol? from Pattern
--R
--R
--RExamples of symbol? from SExpressionCategory
--R
--E 3055

--S 3056 of 3320
)d op symbolIfCan
--R 
--R
--RThere is one unexposed function called symbolIfCan :
--R   [1] Kernel(D2) -> Union(Symbol,"failed") from Kernel(D2) if D2 has 
--R            ORDSET
--R
--RExamples of symbolIfCan from Kernel
--R
--E 3056

--S 3057 of 3320
)d op symbolTable
--R 
--R
--RThere is one exposed function called symbolTable :
--R   [1] List(Record(key: Symbol,entry: FortranType)) -> SymbolTable
--R             from SymbolTable
--R
--RExamples of symbolTable from SymbolTable
--R
--E 3057

--S 3058 of 3320
)d op symbolTableOf
--R 
--R
--RThere is one exposed function called symbolTableOf :
--R   [1] (Symbol,TheSymbolTable) -> SymbolTable from TheSymbolTable
--R
--RExamples of symbolTableOf from TheSymbolTable
--R
--E 3058

--S 3059 of 3320
)d op symFunc
--R 
--R
--RThere are 2 unexposed functions called symFunc :
--R   [1] List(D3) -> Vector(D3) from SymmetricFunctions(D3) if D3 has 
--R            RING
--R   [2] (D2,PositiveInteger) -> Vector(D2) from SymmetricFunctions(D2)
--R             if D2 has RING
--R
--RExamples of symFunc from SymmetricFunctions
--R
--E 3059

--S 3060 of 3320
)d op symmetric?
--R 
--R
--RThere are 2 exposed functions called symmetric? :
--R   [1] D -> Boolean from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [2] D -> Boolean from D
--R             if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5
--R             has DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
--R
--RExamples of symmetric? from MatrixCategory
--R
--Rsymmetric? matrix [[j**i for i in 0..4] for j in 1..5]
--R
--R
--RExamples of symmetric? from RectangularMatrixCategory
--R
--E 3060

--S 3061 of 3320
)d op symmetricDifference
--R 
--R
--RThere is one exposed function called symmetricDifference :
--R   [1] (D,D) -> D from D if D has SETAGG(D1) and D1 has SETCAT
--R
--RExamples of symmetricDifference from SetAggregate
--R
--E 3061

--S 3062 of 3320
)d op symmetricGroup
--R 
--R
--RThere are 2 exposed functions called symmetricGroup :
--R   [1] PositiveInteger -> PermutationGroup(Integer)
--R             from PermutationGroupExamples
--R   [2] List(Integer) -> PermutationGroup(Integer) from 
--R            PermutationGroupExamples
--R
--RExamples of symmetricGroup from PermutationGroupExamples
--R
--E 3062

--S 3063 of 3320
)d op symmetricPower
--R 
--R
--RThere is one exposed function called symmetricPower :
--R   [1] (D,NonNegativeInteger) -> D from D
--R             if D has LODOCAT(D2) and D2 has RING and D2 has FIELD
--R
--RThere is one unexposed function called symmetricPower :
--R   [1] (D1,NonNegativeInteger,(D4 -> D4)) -> D1
--R             from LinearOrdinaryDifferentialOperatorsOps(D4,D1)
--R             if D4 has FIELD and D1 has LODOCAT(D4)
--R
--RExamples of symmetricPower from LinearOrdinaryDifferentialOperatorCategory
--R
--R
--RExamples of symmetricPower from LinearOrdinaryDifferentialOperatorsOps
--R
--E 3063

--S 3064 of 3320
)d op symmetricProduct
--R 
--R
--RThere is one exposed function called symmetricProduct :
--R   [1] (D,D) -> D from D if D has LODOCAT(D1) and D1 has RING and D1
--R             has FIELD
--R
--RThere is one unexposed function called symmetricProduct :
--R   [1] (D1,D1,(D3 -> D3)) -> D1
--R             from LinearOrdinaryDifferentialOperatorsOps(D3,D1)
--R             if D3 has FIELD and D1 has LODOCAT(D3)
--R
--RExamples of symmetricProduct from LinearOrdinaryDifferentialOperatorCategory
--R
--R
--RExamples of symmetricProduct from LinearOrdinaryDifferentialOperatorsOps
--R
--E 3064

--S 3065 of 3320
)d op symmetricRemainder
--R 
--R
--RThere is one exposed function called symmetricRemainder :
--R   [1] (D,D) -> D from D if D has INS
--R
--RExamples of symmetricRemainder from IntegerNumberSystem
--R
--E 3065

--S 3066 of 3320
)d op symmetricSquare
--R 
--R
--RThere is one exposed function called symmetricSquare :
--R   [1] D -> D from D if D has LODOCAT(D1) and D1 has RING and D1 has 
--R            FIELD
--R
--RExamples of symmetricSquare from LinearOrdinaryDifferentialOperatorCategory
--R
--E 3066

--S 3067 of 3320
)d op symmetricTensors
--R 
--R
--RThere are 2 exposed functions called symmetricTensors :
--R   [1] (Matrix(D3),PositiveInteger) -> Matrix(D3)
--R             from RepresentationPackage1(D3) if D3 has RING
--R   [2] (List(Matrix(D3)),PositiveInteger) -> List(Matrix(D3))
--R             from RepresentationPackage1(D3) if D3 has RING
--R
--RExamples of symmetricTensors from RepresentationPackage1
--R
--E 3067

--S 3068 of 3320
)d op systemCommand
--R 
--R
--RThere is one exposed function called systemCommand :
--R   [1] String -> Void from MoreSystemCommands
--R
--RExamples of systemCommand from MoreSystemCommands
--R
--E 3068

--S 3069 of 3320
)d op systemSizeIF
--R 
--R
--RThere is one exposed function called systemSizeIF :
--R   [1] Record(xinit: DoubleFloat,xend: DoubleFloat,fn: Vector(
--R            Expression(DoubleFloat)),yinit: List(DoubleFloat),intvals: List(
--R            DoubleFloat),g: Expression(DoubleFloat),abserr: DoubleFloat,
--R            relerr: DoubleFloat) -> Float
--R             from d02AgentsPackage
--R
--RExamples of systemSizeIF from d02AgentsPackage
--R
--E 3069

--S 3070 of 3320
)d op t
--R 
--R
--RThere is one unexposed function called t :
--R   [1] NonNegativeInteger -> (() -> Float) from 
--R            RandomFloatDistributions
--R
--RExamples of t from RandomFloatDistributions
--R
--E 3070

--S 3071 of 3320
)d op tab
--R 
--R
--RThere is one unexposed function called tab :
--R   [1] List(D3) -> Tableau(List(D3)) from TableauxBumpers(D3) if D3
--R             has ORDSET
--R
--RExamples of tab from TableauxBumpers
--R
--E 3071

--S 3072 of 3320
)d op tab1
--R 
--R
--RThere is one unexposed function called tab1 :
--R   [1] List(List(D3)) -> List(List(List(D3))) from TableauxBumpers(D3)
--R             if D3 has ORDSET
--R
--RExamples of tab1 from TableauxBumpers
--R
--E 3072

--S 3073 of 3320 done
)d op table
--R 
--R
--RThere are 2 exposed functions called table :
--R   [1] List(Record(key: D2,entry: D3)) -> D from D
--R             if D2 has SETCAT and D3 has SETCAT and D has TBAGG(D2,D3)
--R            
--R   [2]  -> D from D if D has TBAGG(D1,D2) and D1 has SETCAT and D2 has 
--R            SETCAT
--R
--RExamples of table from TableAggregate
--R
--RData:=Record(age:Integer,gender:String) 
--Ra1:AssociationList(String,Data):=table() 
--Ra1."tim":=[55,"male"]$Data
--R
--E 3073

--S 3074 of 3320
)d op tableau
--R 
--R
--RThere is one exposed function called tableau :
--R   [1] List(List(D2)) -> Tableau(D2) from Tableau(D2) if D2 has SETCAT
--R            
--R
--RExamples of tableau from Tableau
--R
--E 3074

--S 3075 of 3320
)d op tableForDiscreteLogarithm
--R 
--R
--RThere is one exposed function called tableForDiscreteLogarithm :
--R   [1] Integer -> Table(PositiveInteger,NonNegativeInteger) from D if D
--R             has FFIELDC
--R
--RExamples of tableForDiscreteLogarithm from FiniteFieldCategory
--R
--E 3075

--S 3076 of 3320
)d op tablePow
--R 
--R
--RThere is one unexposed function called tablePow :
--R   [1] (NonNegativeInteger,D3,List(D5)) -> Union(Vector(List(D5)),
--R            "failed")
--R             from GenExEuclid(D3,D5) if D3 has EUCDOM and D5 has UPOLYC
--R            (D3)
--R
--RExamples of tablePow from GenExEuclid
--R
--E 3076

--S 3077 of 3320
)d op tail
--R 
--R
--RThere are 3 exposed functions called tail :
--R   [1] D -> D from D if D has DLAGG(D1) and D1 has TYPE
--R   [2] D -> D from D
--R             if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
--R            OAMONS and D3 has ORDSET
--R   [3] D -> D from D if D has URAGG(D1) and D1 has TYPE
--R
--RExamples of tail from DoublyLinkedAggregate
--R
--R
--RExamples of tail from RecursivePolynomialCategory
--R
--R
--RExamples of tail from UnaryRecursiveAggregate
--R
--Rtail [1,4,2,-6,0,3,5,4,2,3]
--R
--E 3077

--S 3078 of 3320
)d op tan
--R 
--R
--RThere are 2 exposed functions called tan :
--R   [1] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R   [2] D -> D from D if D has TRIGCAT
--R
--RThere are 5 unexposed functions called tan :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of tan from ElementaryFunction
--R
--R
--RExamples of tan from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of tan from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of tan from FortranExpression
--R
--R
--RExamples of tan from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of tan from StreamTranscendentalFunctions
--R
--R
--RExamples of tan from TrigonometricFunctionCategory
--R
--E 3078

--S 3079 of 3320
)d op tan2cot
--R 
--R
--RThere is one exposed function called tan2cot :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of tan2cot from TranscendentalManipulations
--R
--E 3079

--S 3080 of 3320
)d op tan2trig
--R 
--R
--RThere is one exposed function called tan2trig :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of tan2trig from TranscendentalManipulations
--R
--E 3080

--S 3081 of 3320
)d op tanAn
--R 
--R
--RThere is one unexposed function called tanAn :
--R   [1] (D2,PositiveInteger) -> SparseUnivariatePolynomial(D2)
--R             from TangentExpansions(D2) if D2 has FIELD
--R
--RExamples of tanAn from TangentExpansions
--R
--E 3081

--S 3082 of 3320
)d op tanh
--R 
--R
--RThere are 2 exposed functions called tanh :
--R   [1] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R   [2] D -> D from D if D has HYPCAT
--R
--RThere are 5 unexposed functions called tanh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of tanh from ElementaryFunction
--R
--R
--RExamples of tanh from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of tanh from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of tanh from FortranExpression
--R
--R
--RExamples of tanh from HyperbolicFunctionCategory
--R
--R
--RExamples of tanh from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of tanh from StreamTranscendentalFunctions
--R
--E 3082

--S 3083 of 3320
)d op tanh  
--R 
--R
--RThere are 2 exposed functions called tanh :
--R   [1] FortranExpression(D1,D2,D3) -> FortranExpression(D1,D2,D3)
--R             from FortranExpression(D1,D2,D3)
--R             if D1: LIST(SYMBOL) and D2: LIST(SYMBOL) and D3 has FMTC
--R         
--R   [2] D -> D from D if D has HYPCAT
--R
--RThere are 5 unexposed functions called tanh :
--R   [1] D1 -> D1 from ElementaryFunction(D2,D1)
--R             if D2 has Join(OrderedSet,IntegralDomain) and D1 has Join(
--R            FunctionSpace(D2),RadicalCategory)
--R   [2] D1 -> D1 from ElementaryFunctionsUnivariateLaurentSeries(D2,D3,
--R            D1)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has UTSCAT(D2) and D1
--R             has ULSCCAT(D2,D3)
--R   [3] D1 -> D1 from ElementaryFunctionsUnivariatePuiseuxSeries(D2,D3,
--R            D1,D4)
--R             if D2 has ALGEBRA(FRAC(INT)) and D3 has ULSCAT(D2) and D1
--R             has UPXSCCA(D2,D3) and D4 has PTRANFN(D3)
--R   [4] Stream(D2) -> Stream(D2)
--R             from StreamTranscendentalFunctionsNonCommutative(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R   [5] Stream(D2) -> Stream(D2) from StreamTranscendentalFunctions(D2)
--R             if D2 has ALGEBRA(FRAC(INT))
--R
--RExamples of tanh from ElementaryFunction
--R
--R
--RExamples of tanh from ElementaryFunctionsUnivariateLaurentSeries
--R
--R
--RExamples of tanh from ElementaryFunctionsUnivariatePuiseuxSeries
--R
--R
--RExamples of tanh from FortranExpression
--R
--R
--RExamples of tanh from HyperbolicFunctionCategory
--R
--R
--RExamples of tanh from StreamTranscendentalFunctionsNonCommutative
--R
--R
--RExamples of tanh from StreamTranscendentalFunctions
--R
--E 3083

--S 3084 of 3320
)d op tanh2coth
--R 
--R
--RThere is one exposed function called tanh2coth :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of tanh2coth from TranscendentalManipulations
--R
--E 3084

--S 3085 of 3320
)d op tanh2trigh
--R 
--R
--RThere is one exposed function called tanh2trigh :
--R   [1] D1 -> D1 from TranscendentalManipulations(D2,D1)
--R             if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
--R            FunctionSpace(D2),TranscendentalFunctionCategory)
--R
--RExamples of tanh2trigh from TranscendentalManipulations
--R
--E 3085

--S 3086 of 3320
)d op tanhIfCan
--R 
--R
--RThere is one exposed function called tanhIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of tanhIfCan from PartialTranscendentalFunctions
--R
--E 3086

--S 3087 of 3320
)d op tanIfCan
--R 
--R
--RThere is one exposed function called tanIfCan :
--R   [1] D1 -> Union(D1,"failed") from D if D has PTRANFN(D1) and D1 has 
--R            TRANFUN
--R
--RExamples of tanIfCan from PartialTranscendentalFunctions
--R
--E 3087

--S 3088 of 3320
)d op tanintegrate
--R 
--R
--RThere is one unexposed function called tanintegrate :
--R   [1] (Fraction(D6),(D6 -> D6),((Integer,D5,D5) -> Union(List(D5),
--R            "failed"))) -> Record(answer: IntegrationResult(Fraction(D6)),a0
--R            : D5)
--R             from TranscendentalIntegration(D5,D6)
--R             if D5 has FIELD and D6 has UPOLYC(D5)
--R
--RExamples of tanintegrate from TranscendentalIntegration
--R
--E 3088

--S 3089 of 3320
)d op tanNa
--R 
--R
--RThere is one unexposed function called tanNa :
--R   [1] (D1,Integer) -> D1 from TangentExpansions(D1) if D1 has FIELD
--R         
--R
--RExamples of tanNa from TangentExpansions
--R
--E 3089

--S 3090 of 3320
)d op tanQ
--R 
--R
--RThere is one exposed function called tanQ :
--R   [1] (Fraction(Integer),D1) -> D1
--R             from ElementaryFunctionStructurePackage(D3,D1)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer),LinearlyExplicitRingOver(Integer)) and D1 has Join
--R            (AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R
--RExamples of tanQ from ElementaryFunctionStructurePackage
--R
--E 3090

--S 3091 of 3320
)d op tanSum
--R 
--R
--RThere is one unexposed function called tanSum :
--R   [1] List(D1) -> D1 from TangentExpansions(D1) if D1 has FIELD
--R
--RExamples of tanSum from TangentExpansions
--R
--E 3091

--S 3092 of 3320
)d op taylor
--R 
--R
--RThere are 10 exposed functions called taylor :
--R   [1] Symbol -> Any from ExpressionToUnivariatePowerSeries(D3,D4)
--R             if D3 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D4 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R   [2] D2 -> Any from ExpressionToUnivariatePowerSeries(D3,D2)
--R             if D3 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D3))
--R   [3] (D2,NonNegativeInteger) -> Any
--R             from ExpressionToUnivariatePowerSeries(D4,D2)
--R             if D4 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D2 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D4))
--R   [4] (D2,Equation(D2)) -> Any from ExpressionToUnivariatePowerSeries(
--R            D4,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D4)) and D4
--R             has Join(GcdDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [5] (D2,Equation(D2),NonNegativeInteger) -> Any
--R             from ExpressionToUnivariatePowerSeries(D5,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D5)) and D5
--R             has Join(GcdDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [6] ((Integer -> D5),Equation(D5)) -> Any
--R             from GenerateUnivariatePowerSeries(D4,D5)
--R             if D5 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D4)) and D4
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [7] (D2,Symbol,Equation(D2)) -> Any from 
--R            GenerateUnivariatePowerSeries(D5,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D5)) and D5
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [8] ((Integer -> D6),Equation(D6),UniversalSegment(
--R            NonNegativeInteger)) -> Any
--R             from GenerateUnivariatePowerSeries(D5,D6)
--R             if D6 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D5)) and D5
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [9] (D2,Symbol,Equation(D2),UniversalSegment(NonNegativeInteger))
--R             -> Any
--R             from GenerateUnivariatePowerSeries(D6,D2)
--R             if D2 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D6)) and D6
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R   [10] D -> D1 from D if D has ULSCCAT(D2,D1) and D2 has RING and D1
--R             has UTSCAT(D2)
--R
--RExamples of taylor from ExpressionToUnivariatePowerSeries
--R
--R
--RExamples of taylor from GenerateUnivariatePowerSeries
--R
--R
--RExamples of taylor from UnivariateLaurentSeriesConstructorCategory
--R
--E 3092

--S 3093 of 3320
)d op taylorIfCan
--R 
--R
--RThere is one exposed function called taylorIfCan :
--R   [1] D -> Union(D1,"failed") from D
--R             if D has ULSCCAT(D2,D1) and D2 has RING and D1 has UTSCAT(
--R            D2)
--R
--RExamples of taylorIfCan from UnivariateLaurentSeriesConstructorCategory
--R
--E 3093

--S 3094 of 3320
)d op taylorQuoByVar
--R 
--R
--RThere is one unexposed function called taylorQuoByVar :
--R   [1] InnerSparseUnivariatePowerSeries(D1) -> 
--R            InnerSparseUnivariatePowerSeries(D1)
--R             from InnerSparseUnivariatePowerSeries(D1) if D1 has RING
--R         
--R
--RExamples of taylorQuoByVar from InnerSparseUnivariatePowerSeries
--R
--E 3094

--S 3095 of 3320
)d op taylorRep
--R 
--R
--RThere is one exposed function called taylorRep :
--R   [1] D -> D1 from D if D has ULSCCAT(D2,D1) and D2 has RING and D1
--R             has UTSCAT(D2)
--R
--RExamples of taylorRep from UnivariateLaurentSeriesConstructorCategory
--R
--E 3095

--S 3096 of 3320
)d op tensorMap
--R 
--R
--RThere is one exposed function called tensorMap :
--R   [1] (Stream(D3),(D3 -> List(D3))) -> Stream(D3) from StreamTensor(D3
--R            )
--R             if D3 has TYPE
--R
--RExamples of tensorMap from StreamTensor
--R
--E 3096

--S 3097 of 3320
)d op tensorProduct
--R 
--R
--RThere are 4 exposed functions called tensorProduct :
--R   [1] (Matrix(D2),Matrix(D2)) -> Matrix(D2) from 
--R            RepresentationPackage1(D2)
--R             if D2 has RING
--R   [2] (List(Matrix(D2)),List(Matrix(D2))) -> List(Matrix(D2))
--R             from RepresentationPackage1(D2) if D2 has RING
--R   [3] Matrix(D2) -> Matrix(D2) from RepresentationPackage1(D2) if D2
--R             has RING
--R   [4] List(Matrix(D2)) -> List(Matrix(D2)) from RepresentationPackage1
--R            (D2)
--R             if D2 has RING
--R
--RExamples of tensorProduct from RepresentationPackage1
--R
--E 3097

--S 3098 of 3320
)d op terms
--R 
--R
--RThere are 2 exposed functions called terms :
--R   [1] D -> List(Record(gen: D2,exp: D3)) from D
--R             if D has FAMONC(D2,D3) and D2 has SETCAT and D3 has CABMON
--R            
--R   [2] D -> Stream(Record(k: D3,c: D2)) from D
--R             if D has UPSCAT(D2,D3) and D2 has RING and D3 has OAMON
--R         
--R
--RThere is one unexposed function called terms :
--R   [1] MonoidRing(D2,D3) -> List(Record(coef: D2,monom: D3))
--R             from MonoidRing(D2,D3) if D2 has RING and D3 has MONOID
--R         
--R
--RExamples of terms from FreeAbelianMonoidCategory
--R
--R
--RExamples of terms from MonoidRing
--R
--R
--RExamples of terms from UnivariatePowerSeriesCategory
--R
--E 3098

--S 3099 of 3320
)d op test
--R 
--R
--RThere is one exposed function called test :
--R   [1] Boolean -> Boolean from Boolean
--R
--RExamples of test from Boolean
--R
--E 3099

--S 3100 of 3320
)d op testDim
--R 
--R
--RThere is one unexposed function called testDim :
--R   [1] (List(HomogeneousDistributedMultivariatePolynomial(D3,D4)),List(
--R            OrderedVariableList(D3))) -> Union(List(
--R            HomogeneousDistributedMultivariatePolynomial(D3,D4)),"failed")
--R             from GroebnerSolve(D3,D4,D5)
--R             if D3: LIST(SYMBOL) and D4 has GCDDOM and D5 has GCDDOM
--R         
--R
--RExamples of testDim from GroebnerSolve
--R
--E 3100

--S 3101 of 3320
)d op testModulus
--R 
--R
--RThere is one unexposed function called testModulus :
--R   [1] (D2,List(D4)) -> Boolean from GenExEuclid(D2,D4)
--R             if D4 has UPOLYC(D2) and D2 has EUCDOM
--R
--RExamples of testModulus from GenExEuclid
--R
--E 3101

--S 3102 of 3320
)d op tex
--R 
--R
--RThere is one exposed function called tex :
--R   [1] TexFormat -> List(String) from TexFormat
--R
--RExamples of tex from TexFormat
--R
--E 3102

--S 3103 of 3320
)d op theCurve
--R 
--R
--RThere are 3 exposed functions called theCurve :
--R   [1]  -> D4
--R             from GeneralPackageForAlgebraicFunctionField(D5,D6,D4,D7,
--R            D8,D9,D10,D11,D1,D2,D3)
--R             if D5 has FIELD and D6: LIST(SYMBOL) and D7 has DIRPCAT(#(
--R            D6),NNI) and D8 has PRSPCAT(D5) and D9 has LOCPOWC(D5) and 
--R            D10 has PLACESC(D5,D9) and D11 has DIVCAT(D10) and D1 has 
--R            INFCLCT(D5,D6,D4,D7,D8,D9,D10,D11,D3) and D3 has BLMETCT 
--R            and D4 has POLYCAT(D5,D7,OVAR(D6)) and D2 has DSTRCAT(D1)
--R         
--R   [2]  -> DistributedMultivariatePolynomial(D3,D2)
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R            
--R   [3]  -> DistributedMultivariatePolynomial(D3,D2)
--R             from PackageForAlgebraicFunctionField(D2,D3,D4)
--R             if D2 has FIELD and D3: LIST(SYMBOL) and D4 has BLMETCT
--R         
--R
--RExamples of theCurve from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of theCurve from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of theCurve from PackageForAlgebraicFunctionField
--R
--E 3103

--S 3104 of 3320
)d op thetaCoord
--R 
--R
--RThere is one unexposed function called thetaCoord :
--R   [1] Point(D1) -> D1 from PointPackage(D1) if D1 has RING
--R
--RExamples of thetaCoord from PointPackage
--R
--E 3104

--S 3105 of 3320 done
)d op third
--R 
--R
--RThere is one exposed function called third :
--R   [1] D -> D1 from D if D has URAGG(D1) and D1 has TYPE
--R
--RExamples of third from UnaryRecursiveAggregate
--R
--Rthird [1,4,2,-6,0,3,5,4,2,3]
--R
--E 3105

--S 3106 of 3320
)d op times
--R 
--R
--RThere is one unexposed function called times :
--R   [1] (D1,D1,Automorphism(D4),(D4 -> D4)) -> D1
--R             from UnivariateSkewPolynomialCategoryOps(D4,D1)
--R             if D4 has RING and D1 has OREPCAT(D4)
--R
--RExamples of times from UnivariateSkewPolynomialCategoryOps
--R
--E 3106

--S 3107 of 3320
)d op times!
--R 
--R
--RThere is one unexposed function called times! :
--R   [1] (Matrix(D2),Matrix(D2),Matrix(D2)) -> Matrix(D2)
--R             from StorageEfficientMatrixOperations(D2) if D2 has RING
--R         
--R
--RExamples of times! from StorageEfficientMatrixOperations
--R
--E 3107

--S 3108 of 3320
)d op title
--R 
--R
--RThere are 2 exposed functions called title :
--R   [1] String -> DrawOption from DrawOption
--R   [2] (ThreeDimensionalViewport,String) -> Void from 
--R            ThreeDimensionalViewport
--R
--RThere are 2 unexposed functions called title :
--R   [1] (List(DrawOption),String) -> String from DrawOptionFunctions0
--R         
--R   [2] (TwoDimensionalViewport,String) -> Void from 
--R            TwoDimensionalViewport
--R
--RExamples of title from DrawOptionFunctions0
--R
--R
--RExamples of title from DrawOption
--R
--R
--RExamples of title from TwoDimensionalViewport
--R
--R
--RExamples of title from ThreeDimensionalViewport
--R
--E 3108

--S 3109 of 3320 done
)d op toint
--R 
--R
--RThere is one exposed function called toint :
--R   [1] String -> Integer from HexadecimalExpansion
--R
--RExamples of toint from HexadecimalExpansion
--R
--Rtoint("FE") 
--Rtoint("BFD25E8C")
--R
--E 3109

--S 3110 of 3320
--R----------------------)d op to_mod_pa  (fix this)
--E 3110

--S 3111 of 3320 done
)d op top
--R 
--R
--RThere are 4 exposed functions called top :
--R   [1] ArrayStack(D1) -> D1 from ArrayStack(D1) if D1 has SETCAT
--R   [2] Dequeue(D1) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [3] D -> D1 from D if D has SKAGG(D1) and D1 has TYPE
--R   [4] Stack(D1) -> D1 from Stack(D1) if D1 has SETCAT
--R
--RExamples of top from ArrayStack
--R
--Ra:ArrayStack INT:= arrayStack [1,2,3,4,5] 
--Rtop a
--R
--R
--RExamples of top from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rtop a
--R
--R
--RExamples of top from StackAggregate
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rtop a
--R
--R
--RExamples of top from Stack
--R
--Ra:Stack INT:= stack [1,2,3,4,5] 
--Rtop a
--R
--E 3111

--S 3112 of 3320
)d op top!
--R 
--R
--RThere are 2 exposed functions called top! :
--R   [1] Dequeue(D1) -> D1 from Dequeue(D1) if D1 has SETCAT
--R   [2] D -> D1 from D if D has DQAGG(D1) and D1 has TYPE
--R
--RExamples of top! from Dequeue
--R
--Ra:Dequeue INT:= dequeue [1,2,3,4,5] 
--Rtop! a 
--Ra
--R
--R
--RExamples of top! from DequeueAggregate
--R
--E 3112

--S 3113 of 3320
)d op topFortranOutputStack
--R 
--R
--RThere is one exposed function called topFortranOutputStack :
--R   [1]  -> String from FortranOutputStackPackage
--R
--RExamples of topFortranOutputStack from FortranOutputStackPackage
--R
--E 3113

--S 3114 of 3320
)d op topPredicate
--R 
--R
--RThere is one unexposed function called topPredicate :
--R   [1] Pattern(D2) -> Record(var: List(Symbol),pred: Any) from Pattern(
--R            D2)
--R             if D2 has SETCAT
--R
--RExamples of topPredicate from Pattern
--R
--E 3114

--S 3115 of 3320
)d op toroidal
--R 
--R
--RThere is one exposed function called toroidal :
--R   [1] D2 -> (Point(D2) -> Point(D2)) from CoordinateSystems(D2)
--R             if D2 has Join(Field,TranscendentalFunctionCategory,
--R            RadicalCategory)
--R
--RExamples of toroidal from CoordinateSystems
--R
--E 3115

--S 3116 of 3320
)d op torsion?
--R 
--R
--RThere are 2 unexposed functions called torsion? :
--R   [1] FiniteDivisor(D4,D5,D6,D7) -> Boolean
--R             from PointsOfFiniteOrder(D3,D4,D5,D6,D7)
--R             if D4 has FS(D3) and D5 has UPOLYC(D4) and D6 has UPOLYC(
--R            FRAC(D5)) and D7 has FFCAT(D4,D5,D6) and D3 has Join(
--R            OrderedSet,IntegralDomain,RetractableTo(Integer))
--R   [2] FiniteDivisor(Fraction(Integer),D3,D4,D5) -> Boolean
--R             from PointsOfFiniteOrderRational(D3,D4,D5)
--R             if D3 has UPOLYC(FRAC(INT)) and D4 has UPOLYC(FRAC(D3)) 
--R            and D5 has FFCAT(FRAC(INT),D3,D4)
--R
--RExamples of torsion? from PointsOfFiniteOrder
--R
--R
--RExamples of torsion? from PointsOfFiniteOrderRational
--R
--E 3116

--S 3117 of 3320
)d op torsionIfCan
--R 
--R
--RThere are 2 unexposed functions called torsionIfCan :
--R   [1] FiniteDivisor(D4,D5,D6,D7) -> Union(Record(order: 
--R            NonNegativeInteger,function: D7),"failed")
--R             from PointsOfFiniteOrder(D3,D4,D5,D6,D7)
--R             if D4 has FS(D3) and D5 has UPOLYC(D4) and D6 has UPOLYC(
--R            FRAC(D5)) and D7 has FFCAT(D4,D5,D6) and D3 has Join(
--R            OrderedSet,IntegralDomain,RetractableTo(Integer))
--R   [2] FiniteDivisor(Fraction(Integer),D3,D4,D5) -> Union(Record(order
--R            : NonNegativeInteger,function: D5),"failed")
--R             from PointsOfFiniteOrderRational(D3,D4,D5)
--R             if D3 has UPOLYC(FRAC(INT)) and D4 has UPOLYC(FRAC(D3)) 
--R            and D5 has FFCAT(FRAC(INT),D3,D4)
--R
--RExamples of torsionIfCan from PointsOfFiniteOrder
--R
--R
--RExamples of torsionIfCan from PointsOfFiniteOrderRational
--R
--E 3117

--S 3118 of 3320
)d op toScale
--R 
--R
--RThere is one exposed function called toScale :
--R   [1] Boolean -> DrawOption from DrawOption
--R
--RThere is one unexposed function called toScale :
--R   [1] (List(DrawOption),Boolean) -> Boolean from DrawOptionFunctions0
--R            
--R
--RExamples of toScale from DrawOptionFunctions0
--R
--R
--RExamples of toScale from DrawOption
--R
--E 3118

--S 3119 of 3320
)d op toseInvertible?
--R 
--R
--RThere are 2 exposed functions called toseInvertible? :
--R   [1] (D2,D3) -> Boolean from RegularTriangularSetGcdPackage(D4,D5,D6,
--R            D2,D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R   [2] (D2,D3) -> List(Record(val: Boolean,tower: D3))
--R             from RegularTriangularSetGcdPackage(D4,D5,D6,D2,D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of toseInvertible? from RegularTriangularSetGcdPackage
--R
--E 3119

--S 3120 of 3320
)d op toseInvertibleSet
--R 
--R
--RThere is one exposed function called toseInvertibleSet :
--R   [1] (D2,D3) -> List(D3) from RegularTriangularSetGcdPackage(D4,D5,D6
--R            ,D2,D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of toseInvertibleSet from RegularTriangularSetGcdPackage
--R
--E 3120

--S 3121 of 3320
)d op toseLastSubResultant
--R 
--R
--RThere is one exposed function called toseLastSubResultant :
--R   [1] (D2,D2,D3) -> List(Record(val: D2,tower: D3))
--R             from RegularTriangularSetGcdPackage(D4,D5,D6,D2,D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of toseLastSubResultant from RegularTriangularSetGcdPackage
--R
--E 3121

--S 3122 of 3320
)d op toseSquareFreePart
--R 
--R
--RThere is one exposed function called toseSquareFreePart :
--R   [1] (D2,D3) -> List(Record(val: D2,tower: D3))
--R             from RegularTriangularSetGcdPackage(D4,D5,D6,D2,D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of toseSquareFreePart from RegularTriangularSetGcdPackage
--R
--E 3122

--S 3123 of 3320
)d op totalDegree
--R 
--R
--RThere are 3 exposed functions called totalDegree :
--R   [1] D2 -> NonNegativeInteger from PackageForPoly(D3,D2,D4,D5)
--R             if D3 has RING and D4 has DIRPCAT(D5,NNI) and D5: NNI and 
--R            D2 has FAMR(D3,D4)
--R   [2] (D,List(D5)) -> NonNegativeInteger from D
--R             if D has POLYCAT(D3,D4,D5) and D3 has RING and D4 has 
--R            OAMONS and D5 has ORDSET
--R   [3] D -> NonNegativeInteger from D
--R             if D has POLYCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R
--RExamples of totalDegree from PackageForPoly
--R
--R
--RExamples of totalDegree from PolynomialCategory
--R
--E 3123

--S 3124 of 3320 done
)d op totalDifferential
--R 
--R
--RThere is one unexposed function called totalDifferential :
--R   [1] Expression(D2) -> DeRhamComplex(D2,D3) from DeRhamComplex(D2,D3)
--R             if D2 has Join(Ring,OrderedSet) and D3: LIST(SYMBOL)
--R
--RExamples of totalDifferential from DeRhamComplex
--R
--Rder := DeRhamComplex(Integer,[x,y,z]) 
--Ra : BOP := operator('a) 
--RtotalDifferential(a(x,y,z))$der 
--RtotalDifferential(x^2+y^2+sin(x)*z^2)$der
--R
--E 3124

--S 3125 of 3320
)d op totalfract
--R 
--R
--RThere is one exposed function called totalfract :
--R   [1] D2 -> Record(sup: Polynomial(D5),inf: Polynomial(D5))
--R             from MPolyCatRationalFunctionFactorizer(D3,D4,D5,D2)
--R             if D3 has OAMONS and D4 has OrderedSetwith
--R               convert : % -> Symboland D5 has INTDOM and D2 has 
--R            POLYCAT(FRAC(POLY(D5)),D3,D4)
--R
--RExamples of totalfract from MPolyCatRationalFunctionFactorizer
--R
--E 3125

--S 3126 of 3320
)d op totalGroebner
--R 
--R
--RThere is one exposed function called totalGroebner :
--R   [1] (List(Polynomial(D3)),List(Symbol)) -> List(Polynomial(D3))
--R             from PolyGroebner(D3) if D3 has GCDDOM
--R
--RExamples of totalGroebner from PolyGroebner
--R
--E 3126

--S 3127 of 3320
)d op totalLex
--R 
--R
--RThere is one unexposed function called totalLex :
--R   [1] (Vector(D4),Vector(D4)) -> Boolean from OrderingFunctions(D3,D4)
--R             if D4 has OAMON and D3: NNI
--R
--RExamples of totalLex from OrderingFunctions
--R
--E 3127

--S 3128 of 3320
)d op totolex
--R 
--R
--RThere is one unexposed function called totolex :
--R   [1] List(HomogeneousDistributedMultivariatePolynomial(D3,D4)) -> 
--R            List(DistributedMultivariatePolynomial(D3,D4))
--R             from LinGroebnerPackage(D3,D4) if D3: LIST(SYMBOL) and D4
--R             has GCDDOM
--R
--RExamples of totolex from LinGroebnerPackage
--R
--E 3128

--S 3129 of 3320
)d op tower
--R 
--R
--RThere is one exposed function called tower :
--R   [1] D -> List(Kernel(D)) from D if D has ES
--R
--RExamples of tower from ExpressionSpace
--R
--E 3129

--S 3130 of 3320
)d op trace
--R 
--R
--RThere are 4 exposed functions called trace :
--R   [1] (D,PositiveInteger) -> D from D
--R             if D has FAXF(D2) and D2 has FIELD and D2 has FINITE
--R   [2] D -> D1 from D if D has FAXF(D1) and D1 has FIELD
--R   [3] D -> D1 from D
--R             if D has FINRALG(D1,D2) and D2 has UPOLYC(D1) and D1 has 
--R            COMRING
--R   [4] D -> D1 from D
--R             if D has SMATCAT(D2,D1,D3,D4) and D3 has DIRPCAT(D2,D1) 
--R            and D4 has DIRPCAT(D2,D1) and D1 has RING
--R
--RThere is one unexposed function called trace :
--R   [1] (Vector(D3),PositiveInteger) -> Vector(D3)
--R             from InnerNormalBasisFieldFunctions(D3) if D3 has FFIELDC
--R            
--R
--RExamples of trace from FiniteAlgebraicExtensionField
--R
--R
--RExamples of trace from FiniteRankAlgebra
--R
--R
--RExamples of trace from InnerNormalBasisFieldFunctions
--R
--R
--RExamples of trace from SquareMatrixCategory
--R
--E 3130

--S 3131 of 3320
)d op trace2PowMod
--R 
--R
--RThere is one exposed function called trace2PowMod :
--R   [1] (D1,NonNegativeInteger,D1) -> D1 from DistinctDegreeFactorize(D3
--R            ,D1)
--R             if D3 has FFIELDC and D1 has UPOLYC(D3)
--R
--RExamples of trace2PowMod from DistinctDegreeFactorize
--R
--E 3131

--S 3132 of 3320
)d op traceMatrix
--R 
--R
--RThere are 2 exposed functions called traceMatrix :
--R   [1] Vector(D) -> Matrix(D3) from D
--R             if D has FINRALG(D3,D4) and D3 has COMRING and D4 has 
--R            UPOLYC(D3)
--R   [2]  -> Matrix(D2) from D
--R             if D has FRAMALG(D2,D3) and D2 has COMRING and D3 has 
--R            UPOLYC(D2)
--R
--RThere is one unexposed function called traceMatrix :
--R   [1]  -> Matrix(D3) from FramedAlgebra&(D2,D3,D4)
--R             if D3 has COMRING and D4 has UPOLYC(D3) and D2 has FRAMALG
--R            (D3,D4)
--R
--RExamples of traceMatrix from FiniteRankAlgebra
--R
--R
--RExamples of traceMatrix from FramedAlgebra&
--R
--R
--RExamples of traceMatrix from FramedAlgebra
--R
--E 3132

--S 3133 of 3320
)d op tracePowMod
--R 
--R
--RThere is one exposed function called tracePowMod :
--R   [1] (D1,NonNegativeInteger,D1) -> D1 from DistinctDegreeFactorize(D3
--R            ,D1)
--R             if D3 has FFIELDC and D1 has UPOLYC(D3)
--R
--RExamples of tracePowMod from DistinctDegreeFactorize
--R
--E 3133

--S 3134 of 3320
)d op trailingCoefficient
--R 
--R
--RThere is one unexposed function called trailingCoefficient :
--R   [1] LaurentPolynomial(D1,D2) -> D1 from LaurentPolynomial(D1,D2)
--R             if D1 has INTDOM and D2 has UPOLYC(D1)
--R
--RExamples of trailingCoefficient from LaurentPolynomial
--R
--E 3134

--S 3135 of 3320
)d op tRange
--R 
--R
--RThere are 2 unexposed functions called tRange :
--R   [1] Plot3D -> Segment(DoubleFloat) from Plot3D
--R   [2] Plot -> Segment(DoubleFloat) from Plot
--R
--RExamples of tRange from Plot3D
--R
--R
--RExamples of tRange from Plot
--R
--E 3135

--S 3136 of 3320
)d op transcendenceDegree
--R 
--R
--RThere is one exposed function called transcendenceDegree :
--R   [1]  -> NonNegativeInteger from D if D has XF(D2) and D2 has FIELD
--R         
--R
--RThere is one unexposed function called transcendenceDegree :
--R   [1]  -> NonNegativeInteger from FiniteAlgebraicExtensionField&(D2,D3
--R            )
--R             if D3 has FIELD and D2 has FAXF(D3)
--R
--RExamples of transcendenceDegree from FiniteAlgebraicExtensionField&
--R
--R
--RExamples of transcendenceDegree from ExtensionField
--R
--E 3136

--S 3137 of 3320
)d op transcendent?
--R 
--R
--RThere is one exposed function called transcendent? :
--R   [1] D -> Boolean from D if D has XF(D2) and D2 has FIELD
--R
--RExamples of transcendent? from ExtensionField
--R
--E 3137

--S 3138 of 3320
)d op transcendentalDecompose
--R 
--R
--RThere are 4 exposed functions called transcendentalDecompose :
--R   [1] (D2,D3,NonNegativeInteger) -> Record(done: List(D3),todo: List(
--R            Record(val: List(D2),tower: D3)))
--R             from RegularSetDecompositionPackage(D5,D6,D7,D2,D3)
--R             if D5 has GCDDOM and D6 has OAMONS and D7 has ORDSET and 
--R            D2 has RPOLCAT(D5,D6,D7) and D3 has RSETCAT(D5,D6,D7,D2)
--R         
--R   [2] (D2,D3) -> Record(done: List(D3),todo: List(Record(val: List(D2)
--R            ,tower: D3)))
--R             from RegularSetDecompositionPackage(D4,D5,D6,D2,D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has RSETCAT(D4,D5,D6,D2)
--R         
--R   [3] (D2,D3,NonNegativeInteger) -> Record(done: List(D3),todo: List(
--R            Record(val: List(D2),tower: D3)))
--R             from SquareFreeRegularSetDecompositionPackage(D5,D6,D7,D2,
--R            D3)
--R             if D5 has GCDDOM and D6 has OAMONS and D7 has ORDSET and 
--R            D2 has RPOLCAT(D5,D6,D7) and D3 has SFRTCAT(D5,D6,D7,D2)
--R         
--R   [4] (D2,D3) -> Record(done: List(D3),todo: List(Record(val: List(D2)
--R            ,tower: D3)))
--R             from SquareFreeRegularSetDecompositionPackage(D4,D5,D6,D2,
--R            D3)
--R             if D4 has GCDDOM and D5 has OAMONS and D6 has ORDSET and 
--R            D2 has RPOLCAT(D4,D5,D6) and D3 has SFRTCAT(D4,D5,D6,D2)
--R         
--R
--RExamples of transcendentalDecompose from RegularSetDecompositionPackage
--R
--R
--RExamples of transcendentalDecompose from SquareFreeRegularSetDecompositionPackage
--R
--E 3138

--S 3139 of 3320
)d op transCoord
--R 
--R
--RThere is one exposed function called transCoord :
--R   [1] D -> Integer from D if D has BLMETCT
--R
--RExamples of transCoord from BlowUpMethodCategory
--R
--E 3139

--S 3140 of 3320
)d op transform
--R 
--R
--RThere is one unexposed function called transform :
--R   [1] DistributedMultivariatePolynomial(D3,D4) -> 
--R            HomogeneousDistributedMultivariatePolynomial(D3,D4)
--R             from LinGroebnerPackage(D3,D4) if D3: LIST(SYMBOL) and D4
--R             has GCDDOM
--R
--RExamples of transform from LinGroebnerPackage
--R
--E 3140

--S 3141 of 3320
)d op translate
--R 
--R
--RThere are 4 exposed functions called translate :
--R   [1] (D1,D1,D1) -> DenavitHartenbergMatrix(D1)
--R             from DenavitHartenbergMatrix(D1)
--R             if D1 has Join(Field,TranscendentalFunctionCategory)
--R   [2] (D1,List(D4),Integer) -> D1 from PackageForPoly(D4,D1,D5,D6)
--R             if D4 has RING and D5 has DIRPCAT(D6,NNI) and D6: NNI and 
--R            D1 has FAMR(D4,D5)
--R   [3] (D1,List(D3)) -> D1 from PackageForPoly(D3,D1,D4,D5)
--R             if D3 has RING and D4 has DIRPCAT(D5,NNI) and D5: NNI and 
--R            D1 has FAMR(D3,D4)
--R   [4] (ThreeDimensionalViewport,Float,Float) -> Void
--R             from ThreeDimensionalViewport
--R
--RThere is one unexposed function called translate :
--R   [1] (TwoDimensionalViewport,PositiveInteger,Float,Float) -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of translate from DenavitHartenbergMatrix
--R
--Rtranslate(1.0,2.0,3.0)
--R
--R
--RExamples of translate from PackageForPoly
--R
--R
--RExamples of translate from TwoDimensionalViewport
--R
--R
--RExamples of translate from ThreeDimensionalViewport
--R
--E 3141

--S 3142 of 3320
)d op translateToOrigin
--R 
--R
--RThere are 3 exposed functions called translateToOrigin :
--R   [1] (DistributedMultivariatePolynomial(D5,D4),
--R            ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField(D4)) -> 
--R            DistributedMultivariatePolynomial(D5,
--R            PseudoAlgebraicClosureOfFiniteField(D4))
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D4,D5
--R            ,D6)
--R             if D4 has FFIELDC and D5: LIST(SYMBOL) and D6 has BLMETCT
--R            
--R   [2] (D1,D2,Integer) -> D1 from PolynomialPackageForCurve(D4,D1,D5,D6
--R            ,D2)
--R             if D4 has FIELD and D5 has DIRPCAT(D6,NNI) and D6: NNI and
--R            D1 has FAMR(D4,D5) and D2 has PRSPCAT(D4)
--R   [3] (D1,D2) -> D1 from PolynomialPackageForCurve(D3,D1,D4,D5,D2)
--R             if D3 has FIELD and D4 has DIRPCAT(D5,NNI) and D5: NNI and
--R            D1 has FAMR(D3,D4) and D2 has PRSPCAT(D3)
--R
--RExamples of translateToOrigin from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of translateToOrigin from PolynomialPackageForCurve
--R
--E 3142

--S 3143 of 3320
)d op transpose
--R 
--R
--RThere are 4 exposed functions called transpose :
--R   [1] (CartesianTensor(D2,D3,D4),Integer,Integer) -> CartesianTensor(
--R            D2,D3,D4)
--R             from CartesianTensor(D2,D3,D4) if D2: INT and D3: NNI and 
--R            D4 has COMRING
--R   [2] CartesianTensor(D1,D2,D3) -> CartesianTensor(D1,D2,D3)
--R             from CartesianTensor(D1,D2,D3) if D1: INT and D2: NNI and 
--R            D3 has COMRING
--R   [3] D -> D from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1)
--R   [4] D1 -> D from D
--R             if D2 has RING and D has MATCAT(D2,D1,D3) and D1 has FLAGG
--R            (D2) and D3 has FLAGG(D2)
--R
--RThere is one unexposed function called transpose :
--R   [1] SquareMatrix(D1,D2) -> SquareMatrix(D1,D2) from SquareMatrix(D1,
--R            D2)
--R             if D1: NNI and D2 has RING
--R
--RExamples of transpose from CartesianTensor
--R
--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
--Rtm:CartesianTensor(1,2,Integer):=m 
--Rtn:CartesianTensor(1,2,Integer):=[tm,tm] 
--Rtranspose(tn,1,2)
--R
--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
--RTm:CartesianTensor(1,2,Integer):=m 
--Rtranspose(Tm)
--R
--R
--RExamples of transpose from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--Rtranspose m
--R
--Rtranspose([1,2,3])@Matrix(INT)
--R
--R
--RExamples of transpose from SquareMatrix
--R
--E 3143

--S 3144 of 3320
)d op trapezoidal
--R 
--R
--RThere is one exposed function called trapezoidal :
--R   [1] ((Float -> Float),Float,Float,Float,Float,Integer,Integer) -> 
--R            Record(value: Float,error: Float,totalpts: Integer,success: 
--R            Boolean)
--R             from NumericalQuadrature
--R
--RExamples of trapezoidal from NumericalQuadrature
--R
--E 3144

--S 3145 of 3320
)d op trapezoidalo
--R 
--R
--RThere is one exposed function called trapezoidalo :
--R   [1] ((Float -> Float),Float,Float,Float,Float,Integer,Integer) -> 
--R            Record(value: Float,error: Float,totalpts: Integer,success: 
--R            Boolean)
--R             from NumericalQuadrature
--R
--RExamples of trapezoidalo from NumericalQuadrature
--R
--E 3145

--S 3146 of 3320
)d op traverse
--R 
--R
--RThere is one unexposed function called traverse :
--R   [1] (SubSpace(D2,D3),List(NonNegativeInteger)) -> SubSpace(D2,D3)
--R             from SubSpace(D2,D3) if D2: PI and D3 has RING
--R
--RExamples of traverse from SubSpace
--R
--E 3146

--S 3147 of 3320
)d op tree
--R 
--R
--RThere are 6 exposed functions called tree :
--R   [1] List(D2) -> D from D if D2 has SETCAT and D has DSTRCAT(D2)
--R   [2] D1 -> D from D if D has DSTRCAT(D1) and D1 has SETCAT
--R   [3] (D1,List(D)) -> D from D if D has DSTRCAT(D1) and D1 has SETCAT
--R            
--R   [4] D1 -> Tree(D1) from Tree(D1) if D1 has SETCAT
--R   [5] List(D2) -> Tree(D2) from Tree(D2) if D2 has SETCAT
--R   [6] (D1,List(Tree(D1))) -> Tree(D1) from Tree(D1) if D1 has SETCAT
--R         
--R
--RExamples of tree from DesingTreeCategory
--R
--R
--RExamples of tree from Tree
--R
--Rtree 6
--R
--Rtree [1,2,3,4]
--R
--Rt1:=tree [1,2,3,4] 
--Rtree(5,[t1])
--R
--E 3147

--S 3148 of 3320
)d op triangSolve
--R 
--R
--RThere are 3 exposed functions called triangSolve :
--R   [1] (List(Polynomial(D4)),Boolean,Boolean) -> List(RegularChain(D4,
--R            D5))
--R             from ZeroDimensionalSolvePackage(D4,D5,D6)
--R             if D4 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D5: LIST(SYMBOL) and 
--R            D6: LIST(SYMBOL)
--R   [2] (List(Polynomial(D4)),Boolean) -> List(RegularChain(D4,D5))
--R             from ZeroDimensionalSolvePackage(D4,D5,D6)
--R             if D4 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D5: LIST(SYMBOL) and 
--R            D6: LIST(SYMBOL)
--R   [3] List(Polynomial(D3)) -> List(RegularChain(D3,D4))
--R             from ZeroDimensionalSolvePackage(D3,D4,D5)
--R             if D3 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D4: LIST(SYMBOL) and 
--R            D5: LIST(SYMBOL)
--R
--RExamples of triangSolve from ZeroDimensionalSolvePackage
--R
--E 3148

--S 3149 of 3320
)d op triangular?
--R 
--R
--RThere is one exposed function called triangular? :
--R   [1] D -> Boolean from D
--R             if D has PSETCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4) and 
--R            D2 has INTDOM
--R
--RExamples of triangular? from PolynomialSetCategory
--R
--E 3149

--S 3150 of 3320
)d op triangularSystems
--R 
--R
--RThere is one exposed function called triangularSystems :
--R   [1] (List(Fraction(Polynomial(D4))),List(Symbol)) -> List(List(
--R            Polynomial(D4)))
--R             from SystemSolvePackage(D4) if D4 has INTDOM
--R
--RExamples of triangularSystems from SystemSolvePackage
--R
--E 3150

--S 3151 of 3320
)d op triangulate
--R 
--R
--RThere are 2 unexposed functions called triangulate :
--R   [1] (Matrix(D4),Vector(D4)) -> Record(A: Matrix(D4),eqs: List(
--R            Record(C: Matrix(D4),g: Vector(D4),eq: D5,rh: D4)))
--R             from SystemODESolver(D4,D5) if D4 has FIELD and D5 has 
--R            LODOCAT(D4)
--R   [2] (Matrix(D5),Vector(D4)) -> Record(mat: Matrix(D5),vec: Vector(D4
--R            ))
--R             from SystemODESolver(D4,D5) if D4 has FIELD and D5 has 
--R            LODOCAT(D4)
--R
--RExamples of triangulate from SystemODESolver
--R
--E 3151

--S 3152 of 3320
)d op trigs
--R 
--R
--RThere are 2 exposed functions called trigs :
--R   [1] D1 -> D1 from ComplexTrigonometricManipulations(D2,D1)
--R             if D2 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer)) and D1 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(Complex(D2)))
--R            
--R   [2] D1 -> D1 from TrigonometricManipulations(D2,D1)
--R             if D2 has Join(GcdDomain,OrderedSet,RetractableTo(Integer)
--R            ,LinearlyExplicitRingOver(Integer)) and D1 has Join(
--R            AlgebraicallyClosedField,TranscendentalFunctionCategory,
--R            FunctionSpace(D2))
--R
--RExamples of trigs from ComplexTrigonometricManipulations
--R
--R
--RExamples of trigs from TrigonometricManipulations
--R
--E 3152

--S 3153 of 3320
)d op trigs2explogs
--R 
--R
--RThere is one unexposed function called trigs2explogs :
--R   [1] (D1,List(Kernel(D1)),List(Symbol)) -> D1
--R             from InnerTrigonometricManipulations(D4,D5,D1)
--R             if D1 has Join(FunctionSpace(Complex(D4)),RadicalCategory,
--R            TranscendentalFunctionCategory) and D4 has Join(
--R            IntegralDomain,OrderedSet) and D5 has Join(FunctionSpace(D4
--R            ),RadicalCategory,TranscendentalFunctionCategory)
--R
--RExamples of trigs2explogs from InnerTrigonometricManipulations
--R
--E 3153

--S 3154 of 3320
)d op trim
--R 
--R
--RThere are 2 exposed functions called trim :
--R   [1] (D,CharacterClass) -> D from D if D has SRAGG
--R   [2] (D,Character) -> D from D if D has SRAGG
--R
--RExamples of trim from StringAggregate
--R
--E 3154

--S 3155 of 3320
)d op trivialIdeal?
--R 
--R
--RThere is one exposed function called trivialIdeal? :
--R   [1] D -> Boolean from D
--R             if D has PSETCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R
--RExamples of trivialIdeal? from PolynomialSetCategory
--R
--E 3155

--S 3156 of 3320
)d op true
--R 
--R
--RThere is one exposed function called true :
--R   [1]  -> Boolean from Boolean
--R
--RExamples of true from Boolean
--R
--E 3156

--S 3157 of 3320
)d op trueEqual
--R 
--R
--RThere is one unexposed function called trueEqual :
--R   [1] (InnerAlgebraicNumber,InnerAlgebraicNumber) -> Boolean
--R             from InnerAlgebraicNumber
--R
--RExamples of trueEqual from InnerAlgebraicNumber
--R
--E 3157

--S 3158 of 3320
)d op trunc
--R 
--R
--RThere are 2 exposed functions called trunc :
--R   [1] (D,NonNegativeInteger) -> D from D
--R             if D has FLALG(D2,D3) and D2 has ORDSET and D3 has COMRING
--R            
--R   [2] (D,NonNegativeInteger) -> D from D
--R             if D has XPOLYC(D2,D3) and D2 has ORDSET and D3 has RING
--R         
--R
--RExamples of trunc from FreeLieAlgebra
--R
--R
--RExamples of trunc from XPolynomialsCat
--R
--E 3158

--S 3159 of 3320
)d op truncate
--R 
--R
--RThere are 3 exposed functions called truncate :
--R   [1] D -> D from D if D has RNS
--R   [2] (D,D1,D1) -> D from D if D has UPSCAT(D2,D1) and D2 has RING and
--R            D1 has OAMON
--R   [3] (D,D1) -> D from D if D has UPSCAT(D2,D1) and D2 has RING and D1
--R             has OAMON
--R
--RExamples of truncate from RealNumberSystem
--R
--R
--RExamples of truncate from UnivariatePowerSeriesCategory
--R
--E 3159

--S 3160 of 3320
--R---------------)d op truncated_mul_add (fix this)
--E 3160

--S 3161 of 3320
--R---------------)d op truncated_multiplication (fix this)
--E 3161

--S 3162 of 3320
)d op tryFunctionalDecomposition
--R 
--R
--RThere is one unexposed function called tryFunctionalDecomposition :
--R   [1] Boolean -> Boolean from GaloisGroupFactorizer(D2) if D2 has 
--R            UPOLYC(INT)
--R
--RExamples of tryFunctionalDecomposition from GaloisGroupFactorizer
--R
--E 3162

--S 3163 of 3320
)d op tryFunctionalDecomposition?
--R 
--R
--RThere is one unexposed function called tryFunctionalDecomposition? :
--R   [1]  -> Boolean from GaloisGroupFactorizer(D2) if D2 has UPOLYC(INT)
--R            
--R
--RExamples of tryFunctionalDecomposition? from GaloisGroupFactorizer
--R
--E 3163

--S 3164 of 3320
)d op tube
--R 
--R
--RThere are 2 unexposed functions called tube :
--R   [1] (D2,DoubleFloat,Integer) -> TubePlot(D2) from NumericTubePlot(D2
--R            )
--R             if D2 has PSCURVE
--R   [2] (D1,List(List(Point(DoubleFloat))),Boolean) -> TubePlot(D1)
--R             from TubePlot(D1) if D1 has PSCURVE
--R
--RExamples of tube from NumericTubePlot
--R
--R
--RExamples of tube from TubePlot
--R
--E 3164

--S 3165 of 3320
)d op tubePlot
--R 
--R
--RThere are 4 unexposed functions called tubePlot :
--R   [1] (Expression(Integer),Expression(Integer),Expression(Integer),(
--R            DoubleFloat -> DoubleFloat),Segment(DoubleFloat),(DoubleFloat -> 
--R            DoubleFloat),Integer) -> TubePlot(Plot3D)
--R             from ExpressionTubePlot
--R   [2] (Expression(Integer),Expression(Integer),Expression(Integer),(
--R            DoubleFloat -> DoubleFloat),Segment(DoubleFloat),(DoubleFloat -> 
--R            DoubleFloat),Integer,String) -> TubePlot(Plot3D)
--R             from ExpressionTubePlot
--R   [3] (Expression(Integer),Expression(Integer),Expression(Integer),(
--R            DoubleFloat -> DoubleFloat),Segment(DoubleFloat),DoubleFloat,
--R            Integer) -> TubePlot(Plot3D)
--R             from ExpressionTubePlot
--R   [4] (Expression(Integer),Expression(Integer),Expression(Integer),(
--R            DoubleFloat -> DoubleFloat),Segment(DoubleFloat),DoubleFloat,
--R            Integer,String) -> TubePlot(Plot3D)
--R             from ExpressionTubePlot
--R
--RExamples of tubePlot from ExpressionTubePlot
--R
--E 3165

--S 3166 of 3320
)d op tubePoints
--R 
--R
--RThere is one exposed function called tubePoints :
--R   [1] PositiveInteger -> DrawOption from DrawOption
--R
--RThere is one unexposed function called tubePoints :
--R   [1] (List(DrawOption),PositiveInteger) -> PositiveInteger
--R             from DrawOptionFunctions0
--R
--RExamples of tubePoints from DrawOptionFunctions0
--R
--R
--RExamples of tubePoints from DrawOption
--R
--E 3166

--S 3167 of 3320
)d op tubePointsDefault
--R 
--R
--RThere are 2 exposed functions called tubePointsDefault :
--R   [1] PositiveInteger -> PositiveInteger from ViewDefaultsPackage
--R   [2]  -> PositiveInteger from ViewDefaultsPackage
--R
--RExamples of tubePointsDefault from ViewDefaultsPackage
--R
--E 3167

--S 3168 of 3320
)d op tubeRadius
--R 
--R
--RThere is one exposed function called tubeRadius :
--R   [1] Float -> DrawOption from DrawOption
--R
--RThere is one unexposed function called tubeRadius :
--R   [1] (List(DrawOption),Float) -> Float from DrawOptionFunctions0
--R
--RExamples of tubeRadius from DrawOptionFunctions0
--R
--R
--RExamples of tubeRadius from DrawOption
--R
--E 3168

--S 3169 of 3320
)d op tubeRadiusDefault
--R 
--R
--RThere are 2 exposed functions called tubeRadiusDefault :
--R   [1] Float -> DoubleFloat from ViewDefaultsPackage
--R   [2]  -> DoubleFloat from ViewDefaultsPackage
--R
--RExamples of tubeRadiusDefault from ViewDefaultsPackage
--R
--E 3169

--S 3170 of 3320
)d op tValues
--R 
--R
--RThere is one unexposed function called tValues :
--R   [1] Plot3D -> List(List(DoubleFloat)) from Plot3D
--R
--RExamples of tValues from Plot3D
--R
--E 3170

--S 3171 of 3320
)d op twist
--R 
--R
--RThere is one exposed function called twist :
--R   [1] ((D3,D4) -> D5) -> ((D4,D3) -> D5) from MappingPackage3(D3,D4,D5
--R            )
--R             if D3 has SETCAT and D4 has SETCAT and D5 has SETCAT
--R
--RExamples of twist from MappingPackage3
--R
--E 3171

--S 3172 of 3320
)d op twoFactor
--R 
--R
--RThere is one unexposed function called twoFactor :
--R   [1] (SparseUnivariatePolynomial(SparseUnivariatePolynomial(D4)),
--R            Integer) -> Factored(SparseUnivariatePolynomial(
--R            SparseUnivariatePolynomial(D4)))
--R             from TwoFactorize(D4) if D4 has FFIELDC
--R
--RExamples of twoFactor from TwoFactorize
--R
--E 3172

--S 3173 of 3320
)d op type
--R 
--R
--RThere is one exposed function called type :
--R   [1] D -> Union(left,center,right,vertical,horizontal) from D if D
--R             has BLMETCT
--R
--RExamples of type from BlowUpMethodCategory
--R
--E 3173

--S 3174 of 3320
)d op typeList
--R 
--R
--RThere is one exposed function called typeList :
--R   [1] (FortranScalarType,SymbolTable) -> List(Union(name: Symbol,
--R            bounds: List(Union(S: Symbol,P: Polynomial(Integer)))))
--R             from SymbolTable
--R
--RExamples of typeList from SymbolTable
--R
--E 3174

--S 3175 of 3320
)d op typeLists
--R 
--R
--RThere is one exposed function called typeLists :
--R   [1] SymbolTable -> List(List(Union(name: Symbol,bounds: List(Union(S
--R            : Symbol,P: Polynomial(Integer))))))
--R             from SymbolTable
--R
--RExamples of typeLists from SymbolTable
--R
--E 3175

--S 3176 of 3320
)d op unary?
--R 
--R
--RThere is one exposed function called unary? :
--R   [1] BasicOperator -> Boolean from BasicOperator
--R
--RExamples of unary? from BasicOperator
--R
--E 3176

--S 3177 of 3320
)d op unaryFunction
--R 
--R
--RThere is one unexposed function called unaryFunction :
--R   [1] Symbol -> (D4 -> D5) from MakeUnaryCompiledFunction(D3,D4,D5)
--R             if D3 has KONVERT(INFORM) and D4 has TYPE and D5 has TYPE
--R            
--R
--RExamples of unaryFunction from MakeUnaryCompiledFunction
--R
--E 3177

--S 3178 of 3320
)d op uncorrelated?
--R 
--R
--RThere are 3 exposed functions called uncorrelated? :
--R   [1] List(List(StochasticDifferential(D3))) -> Boolean
--R             from StochasticDifferential(D3)
--R             if D3 has Join(OrderedSet,IntegralDomain)
--R   [2] (List(StochasticDifferential(D3)),List(StochasticDifferential(D3
--R            ))) -> Boolean
--R             from StochasticDifferential(D3)
--R             if D3 has Join(OrderedSet,IntegralDomain)
--R   [3] (StochasticDifferential(D2),StochasticDifferential(D2)) -> 
--R            Boolean
--R             from StochasticDifferential(D2)
--R             if D2 has Join(OrderedSet,IntegralDomain)
--R
--RExamples of uncorrelated? from StochasticDifferential
--R
--E 3178

--S 3179 of 3320
)d op uncouplingMatrices
--R 
--R
--RThere is one unexposed function called uncouplingMatrices :
--R   [1] Matrix(D3) -> Vector(Matrix(D3)) from AssociatedEquations(D3,D4)
--R             if D3 has INTDOM and D4 has LODOCAT(D3)
--R
--RExamples of uncouplingMatrices from AssociatedEquations
--R
--E 3179

--S 3180 of 3320
)d op unexpand
--R 
--R
--RThere are 2 unexposed functions called unexpand :
--R   [1] XDistributedPolynomial(Symbol,D2) -> XPolynomial(D2) from 
--R            XPolynomial(D2)
--R             if D2 has RING
--R   [2] XDistributedPolynomial(D2,D3) -> XRecursivePolynomial(D2,D3)
--R             from XRecursivePolynomial(D2,D3) if D2 has ORDSET and D3
--R             has RING
--R
--RExamples of unexpand from XPolynomial
--R
--R
--RExamples of unexpand from XRecursivePolynomial
--R
--E 3180

--S 3181 of 3320
)d op uniform
--R 
--R
--RThere are 3 unexposed functions called uniform :
--R   [1] Set(D3) -> (() -> D3) from RandomDistributions(D3) if D3 has 
--R            SETCAT
--R   [2] (Float,Float) -> (() -> Float) from RandomFloatDistributions
--R   [3] Segment(Integer) -> (() -> Integer) from 
--R            RandomIntegerDistributions
--R
--RExamples of uniform from RandomDistributions
--R
--R
--RExamples of uniform from RandomFloatDistributions
--R
--R
--RExamples of uniform from RandomIntegerDistributions
--R
--E 3181

--S 3182 of 3320
)d op uniform01
--R 
--R
--RThere is one unexposed function called uniform01 :
--R   [1]  -> Float from RandomFloatDistributions
--R
--RExamples of uniform01 from RandomFloatDistributions
--R
--E 3182

--S 3183 of 3320
)d op union
--R 
--R
--RThere are 3 exposed functions called union :
--R   [1] (D1,D) -> D from D if D has SETAGG(D1) and D1 has SETCAT
--R   [2] (D,D1) -> D from D if D has SETAGG(D1) and D1 has SETCAT
--R   [3] (D,D) -> D from D if D has SETAGG(D1) and D1 has SETCAT
--R
--RThere are 2 unexposed functions called union :
--R   [1] (List(Kernel(D3)),List(Kernel(D3))) -> List(Kernel(D3))
--R             from IntegrationTools(D2,D3) if D3 has FS(D2) and D2 has 
--R            ORDSET
--R   [2] (PatternMatchResult(D1,D2),PatternMatchResult(D1,D2)) -> 
--R            PatternMatchResult(D1,D2)
--R             from PatternMatchResult(D1,D2) if D1 has SETCAT and D2
--R             has SETCAT
--R
--RExamples of union from IntegrationTools
--R
--R
--RExamples of union from PatternMatchResult
--R
--R
--RExamples of union from SetAggregate
--R
--E 3183

--S 3184 of 3320
)d op unit
--R 
--R
--RThere are 3 exposed functions called unit :
--R   [1] List(Float) -> DrawOption from DrawOption
--R   [2]  -> Union(D,"failed") from D
--R             if D has FINAALG(D1) and D1 has INTDOM and D1 has COMRING
--R            
--R   [3] Factored(D1) -> D1 from Factored(D1) if D1 has INTDOM
--R
--RExamples of unit from DrawOption
--R
--R
--RExamples of unit from FiniteRankNonAssociativeAlgebra
--R
--R
--RExamples of unit from Factored
--R
--Rf:=x*y^3-3*x^2*y^2+3*x^3*y-x^4 
--Runit f 
--Rg:=makeFR(z,factorList f) 
--Runit g
--R
--E 3184

--S 3185 of 3320
)d op unit?
--R 
--R
--RThere is one exposed function called unit? :
--R   [1] D -> Boolean from D if D has INTDOM
--R
--RExamples of unit? from IntegralDomain
--R
--E 3185

--S 3186 of 3320
)d op unitCanonical
--R 
--R
--RThere is one exposed function called unitCanonical :
--R   [1] D -> D from D if D has INTDOM
--R
--RExamples of unitCanonical from IntegralDomain
--R
--E 3186

--S 3187 of 3320
)d op unitNormal
--R 
--R
--RThere is one exposed function called unitNormal :
--R   [1] D -> Record(unit: D,canonical: D,associate: D) from D if D has 
--R            INTDOM
--R
--RExamples of unitNormal from IntegralDomain
--R
--E 3187

--S 3188 of 3320
)d op unitNormalize
--R 
--R
--RThere is one exposed function called unitNormalize :
--R   [1] Factored(D1) -> Factored(D1) from Factored(D1) if D1 has INTDOM
--R            
--R
--RExamples of unitNormalize from Factored
--R
--E 3188

--S 3189 of 3320
)d op units
--R 
--R
--RThere are 5 unexposed functions called units :
--R   [1] (List(DrawOption),List(Float)) -> List(Float) from 
--R            DrawOptionFunctions0
--R   [2] (GraphImage,List(Float)) -> List(Float) from GraphImage
--R   [3] GraphImage -> List(Float) from GraphImage
--R   [4] (TwoDimensionalViewport,PositiveInteger,Palette) -> Void
--R             from TwoDimensionalViewport
--R   [5] (TwoDimensionalViewport,PositiveInteger,String) -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of units from DrawOptionFunctions0
--R
--R
--RExamples of units from GraphImage
--R
--R
--RExamples of units from TwoDimensionalViewport
--R
--E 3189

--S 3190 of 3320
)d op unitsColorDefault
--R 
--R
--RThere are 2 exposed functions called unitsColorDefault :
--R   [1]  -> Palette from ViewDefaultsPackage
--R   [2] Palette -> Palette from ViewDefaultsPackage
--R
--RExamples of unitsColorDefault from ViewDefaultsPackage
--R
--E 3190

--S 3191 of 3320
)d op unitVector
--R 
--R
--RThere is one exposed function called unitVector :
--R   [1] PositiveInteger -> D from D
--R             if D has DIRPCAT(D2,D3) and D3 has RING and D3 has TYPE
--R         
--R
--RThere are 2 unexposed functions called unitVector :
--R   [1] D1 -> GeneralModulePolynomial(D2,D3,D1,D4,D5,D6)
--R             from GeneralModulePolynomial(D2,D3,D1,D4,D5,D6)
--R             if D2: LIST(SYMBOL) and D3 has COMRING and D4 has DIRPCAT(
--R            #(D2),NNI) and D5: ((Record(index: D1,exponent: D4),Record(
--R            index: D1,exponent: D4)) -> Boolean) and D1 has ORDSET and 
--R            D6 has POLYCAT(D3,D4,OVAR(D2))
--R   [2] Point(DoubleFloat) -> Point(DoubleFloat) from TubePlotTools
--R
--RExamples of unitVector from DirectProductCategory
--R
--R
--RExamples of unitVector from GeneralModulePolynomial
--R
--R
--RExamples of unitVector from TubePlotTools
--R
--E 3191

--S 3192 of 3320
)d op univariate
--R 
--R
--RThere are 6 exposed functions called univariate :
--R   [1] (D,Kernel(D)) -> Fraction(SparseUnivariatePolynomial(D)) from D
--R             if D has FS(D3) and D3 has ORDSET and D3 has INTDOM
--R   [2] D2 -> SparseUnivariatePolynomial(D3) from PackageForPoly(D3,D2,
--R            D4,D5)
--R             if D3 has RING and D4 has DIRPCAT(D5,NNI) and D5: NNI and 
--R            D2 has FAMR(D3,D4)
--R   [3] (Polynomial(D5),Variable(D4)) -> UnivariatePolynomial(D4,
--R            Polynomial(D5))
--R             from PolynomialToUnivariatePolynomial(D4,D5)
--R             if D4: SYMBOL and D5 has RING
--R   [4] D -> SparseUnivariatePolynomial(D2) from D
--R             if D has POLYCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [5] (D,D2) -> SparseUnivariatePolynomial(D) from D
--R             if D3 has RING and D4 has OAMONS and D2 has ORDSET and D
--R             has POLYCAT(D3,D4,D2)
--R   [6] (Fraction(Polynomial(D4)),Symbol) -> Fraction(
--R            SparseUnivariatePolynomial(Fraction(Polynomial(D4))))
--R             from RationalFunction(D4) if D4 has INTDOM
--R
--RThere are 3 unexposed functions called univariate :
--R   [1] (D2,Kernel(D2),Kernel(D2),SparseUnivariatePolynomial(D2)) -> 
--R            SparseUnivariatePolynomial(Fraction(SparseUnivariatePolynomial(D2
--R            )))
--R             from GenusZeroIntegration(D5,D2,D6)
--R             if D2 has Join(FunctionSpace(D5),AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory) and D5 has Join(GcdDomain,
--R            RetractableTo(Integer),OrderedSet,CharacteristicZero,
--R            LinearlyExplicitRingOver(Integer)) and D6 has SETCAT
--R   [2] (D2,D3) -> Fraction(SparseUnivariatePolynomial(D2))
--R             from PolynomialCategoryQuotientFunctions(D4,D3,D5,D6,D2)
--R             if D4 has OAMONS and D3 has ORDSET and D5 has RING and D6
--R             has POLYCAT(D5,D4,D3) and D2 has Fieldwith
--R               coerce : D6 -> %
--R               numer : % -> D6
--R               denom : % -> D6
--R   [3] (D2,D3,SparseUnivariatePolynomial(D2)) -> 
--R            SparseUnivariatePolynomial(D2)
--R             from PolynomialCategoryQuotientFunctions(D4,D3,D5,D6,D2)
--R             if D2 has Fieldwith
--R               coerce : D6 -> %
--R               numer : % -> D6
--R               denom : % -> D6and D6 has POLYCAT(D5,D4,D3) and D4
--R             has OAMONS and D3 has ORDSET and D5 has RING
--R
--RExamples of univariate from FunctionSpace
--R
--R
--RExamples of univariate from GenusZeroIntegration
--R
--R
--RExamples of univariate from PackageForPoly
--R
--R
--RExamples of univariate from PolynomialToUnivariatePolynomial
--R
--R
--RExamples of univariate from PolynomialCategory
--R
--R
--RExamples of univariate from PolynomialCategoryQuotientFunctions
--R
--R
--RExamples of univariate from RationalFunction
--R
--E 3192

--S 3193 of 3320
)d op univariate?
--R 
--R
--RThere is one unexposed function called univariate? :
--R   [1] D2 -> Boolean from PolynomialSetUtilitiesPackage(D3,D4,D5,D2)
--R             if D3 has INTDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5)
--R
--RExamples of univariate? from PolynomialSetUtilitiesPackage
--R
--E 3193

--S 3194 of 3320
)d op univariatePolynomial
--R 
--R
--RThere are 2 exposed functions called univariatePolynomial :
--R   [1] (UnivariateFormalPowerSeries(D3),NonNegativeInteger) -> 
--R            UnivariatePolynomial(QUOTE(x),D3)
--R             from UnivariateFormalPowerSeries(D3) if D3 has RING
--R   [2] (UnivariateTaylorSeriesCZero(D3,D4),NonNegativeInteger) -> 
--R            UnivariatePolynomial(D4,D3)
--R             from UnivariateTaylorSeriesCZero(D3,D4) if D3 has RING and
--R            D4: SYMBOL
--R
--RThere are 2 unexposed functions called univariatePolynomial :
--R   [1] (SparseUnivariateTaylorSeries(D3,D4,D5),NonNegativeInteger) -> 
--R            UnivariatePolynomial(D4,D3)
--R             from SparseUnivariateTaylorSeries(D3,D4,D5)
--R             if D3 has RING and D4: SYMBOL and D5: D3
--R   [2] (UnivariateTaylorSeries(D3,D4,D5),NonNegativeInteger) -> 
--R            UnivariatePolynomial(D4,D3)
--R             from UnivariateTaylorSeries(D3,D4,D5)
--R             if D3 has RING and D4: SYMBOL and D5: D3
--R
--RExamples of univariatePolynomial from SparseUnivariateTaylorSeries
--R
--R
--RExamples of univariatePolynomial from UnivariateFormalPowerSeries
--R
--R
--RExamples of univariatePolynomial from UnivariateTaylorSeries
--R
--R
--RExamples of univariatePolynomial from UnivariateTaylorSeriesCZero
--R
--E 3194

--S 3195 of 3320
)d op univariatePolynomialsGcds
--R 
--R
--RThere are 2 unexposed functions called univariatePolynomialsGcds :
--R   [1] List(D5) -> List(D5) from PolynomialSetUtilitiesPackage(D2,D3,D4
--R            ,D5)
--R             if D5 has RPOLCAT(D2,D3,D4) and D2 has GCDDOM and D2 has 
--R            INTDOM and D3 has OAMONS and D4 has ORDSET
--R   [2] (List(D6),Boolean) -> List(D6)
--R             from PolynomialSetUtilitiesPackage(D3,D4,D5,D6)
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D3 has 
--R            INTDOM and D4 has OAMONS and D5 has ORDSET
--R
--RExamples of univariatePolynomialsGcds from PolynomialSetUtilitiesPackage
--R
--E 3195

--S 3196 of 3320
)d op univariateSolve
--R 
--R
--RThere are 5 exposed functions called univariateSolve :
--R   [1] RegularChain(D3,D4) -> List(Record(complexRoots: 
--R            SparseUnivariatePolynomial(D3),coordinates: List(Polynomial(D3)))
--R            )
--R             from ZeroDimensionalSolvePackage(D3,D4,D5)
--R             if D3 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D4: LIST(SYMBOL) and 
--R            D5: LIST(SYMBOL)
--R   [2] (List(Polynomial(D4)),Boolean,Boolean,Boolean) -> List(Record(
--R            complexRoots: SparseUnivariatePolynomial(D4),coordinates: List(
--R            Polynomial(D4))))
--R             from ZeroDimensionalSolvePackage(D4,D5,D6)
--R             if D4 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D5: LIST(SYMBOL) and 
--R            D6: LIST(SYMBOL)
--R   [3] (List(Polynomial(D4)),Boolean,Boolean) -> List(Record(
--R            complexRoots: SparseUnivariatePolynomial(D4),coordinates: List(
--R            Polynomial(D4))))
--R             from ZeroDimensionalSolvePackage(D4,D5,D6)
--R             if D4 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D5: LIST(SYMBOL) and 
--R            D6: LIST(SYMBOL)
--R   [4] (List(Polynomial(D4)),Boolean) -> List(Record(complexRoots: 
--R            SparseUnivariatePolynomial(D4),coordinates: List(Polynomial(D4)))
--R            )
--R             from ZeroDimensionalSolvePackage(D4,D5,D6)
--R             if D4 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D5: LIST(SYMBOL) and 
--R            D6: LIST(SYMBOL)
--R   [5] List(Polynomial(D3)) -> List(Record(complexRoots: 
--R            SparseUnivariatePolynomial(D3),coordinates: List(Polynomial(D3)))
--R            )
--R             from ZeroDimensionalSolvePackage(D3,D4,D5)
--R             if D3 has Join(OrderedRing,EuclideanDomain,
--R            CharacteristicZero,RealConstant) and D4: LIST(SYMBOL) and 
--R            D5: LIST(SYMBOL)
--R
--RExamples of univariateSolve from ZeroDimensionalSolvePackage
--R
--E 3196

--S 3197 of 3320
)d op univcase
--R 
--R
--RThere is one unexposed function called univcase :
--R   [1] (D2,D3) -> Factored(D2) from MultivariateSquareFree(D4,D3,D5,D2)
--R             if D4 has OAMONS and D3 has ORDSET and D5 has EUCDOM and 
--R            D2 has POLYCAT(D5,D4,D3)
--R
--RExamples of univcase from MultivariateSquareFree
--R
--E 3197

--S 3198 of 3320
)d op universe
--R 
--R
--RThere is one exposed function called universe :
--R   [1]  -> D from D if D has FSAGG(D1) and D1 has FINITE and D1 has 
--R            SETCAT
--R
--RExamples of universe from FiniteSetAggregate
--R
--E 3198

--S 3199 of 3320
)d op unmakeSUP
--R 
--R
--RThere is one exposed function called unmakeSUP :
--R   [1] SparseUnivariatePolynomial(D2) -> D from D if D2 has RING and D
--R             has UPOLYC(D2)
--R
--RExamples of unmakeSUP from UnivariatePolynomialCategory
--R
--E 3199

--S 3200 of 3320
)d op unparse
--R 
--R
--RThere is one unexposed function called unparse :
--R   [1] InputForm -> String from InputForm
--R
--RExamples of unparse from InputForm
--R
--E 3200

--S 3201 of 3320
)d op unprotectedRemoveRedundantFactors
--R 
--R
--RThere is one unexposed function called unprotectedRemoveRedundantFactors :
--R   [1] (D2,D2) -> List(D2) from PolynomialSetUtilitiesPackage(D3,D4,D5,
--R            D2)
--R             if D3 has INTDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has RPOLCAT(D3,D4,D5)
--R
--RExamples of unprotectedRemoveRedundantFactors from PolynomialSetUtilitiesPackage
--R
--E 3201

--S 3202 of 3320
)d op unrankImproperPartitions0
--R 
--R
--RThere is one exposed function called unrankImproperPartitions0 :
--R   [1] (Integer,Integer,Integer) -> List(Integer)
--R             from SymmetricGroupCombinatoricFunctions
--R
--RExamples of unrankImproperPartitions0 from SymmetricGroupCombinatoricFunctions
--R
--E 3202

--S 3203 of 3320
)d op unrankImproperPartitions1
--R 
--R
--RThere is one exposed function called unrankImproperPartitions1 :
--R   [1] (Integer,Integer,Integer) -> List(Integer)
--R             from SymmetricGroupCombinatoricFunctions
--R
--RExamples of unrankImproperPartitions1 from SymmetricGroupCombinatoricFunctions
--R
--E 3203

--S 3204 of 3320
)d op unravel
--R 
--R
--RThere is one exposed function called unravel :
--R   [1] List(D4) -> CartesianTensor(D2,D3,D4) from CartesianTensor(D2,D3
--R            ,D4)
--R             if D4 has COMRING and D2: INT and D3: NNI
--R
--RExamples of unravel from CartesianTensor
--R
--E 3204

--S 3205 of 3320
)d op untab
--R 
--R
--RThere is one unexposed function called untab :
--R   [1] (List(List(D3)),List(List(List(D3)))) -> List(List(D3))
--R             from TableauxBumpers(D3) if D3 has ORDSET
--R
--RExamples of untab from TableauxBumpers
--R
--E 3205

--S 3206 of 3320
)d op unvectorise
--R 
--R
--RThere is one exposed function called unvectorise :
--R   [1] Vector(D2) -> D from D if D2 has RING and D has UPOLYC(D2)
--R
--RThere are 2 unexposed functions called unvectorise :
--R   [1] Vector(D3) -> D1 from GaloisGroupPolynomialUtilities(D3,D1)
--R             if D3 has RING and D1 has UPOLYC(D3)
--R   [2] (Vector(Expression(D4)),Fraction(SparseUnivariatePolynomial(
--R            Expression(D4))),Integer) -> Fraction(SparseUnivariatePolynomial(
--R            Expression(D4)))
--R             from TransSolvePackageService(D4)
--R             if D4 has Join(IntegralDomain,OrderedSet)
--R
--RExamples of unvectorise from GaloisGroupPolynomialUtilities
--R
--R
--RExamples of unvectorise from TransSolvePackageService
--R
--R
--RExamples of unvectorise from UnivariatePolynomialCategory
--R
--Rt1:UP(x,FRAC(INT)):=3*x^3+4*x^2+5*x+6 
--Rt2:=vectorise(t1,4) 
--Rt3:UP(x,FRAC(INT)):=unvectorise(t2)
--R
--E 3206

--S 3207 of 3320
)d op UnVectorise
--R 
--R
--RThere is one unexposed function called UnVectorise :
--R   [1] Vector(D2) -> ModMonic(D2,D3) from ModMonic(D2,D3)
--R             if D2 has RING and D3 has UPOLYC(D2)
--R
--RExamples of UnVectorise from ModMonic
--R
--E 3207

--S 3208 of 3320
)d op UP2ifCan
--R 
--R
--RThere is one unexposed function called UP2ifCan :
--R   [1] D2 -> Union(overq: SparseUnivariatePolynomial(Fraction(Integer))
--R            ,overan: SparseUnivariatePolynomial(AlgebraicNumber),failed: 
--R            Boolean)
--R             from FunctionSpaceUnivariatePolynomialFactor(D3,D4,D2)
--R             if D3 has Join(IntegralDomain,OrderedSet,RetractableTo(
--R            Integer)) and D4 has FS(D3) and D2 has UPOLYC(D4)
--R
--RExamples of UP2ifCan from FunctionSpaceUnivariatePolynomialFactor
--R
--E 3208

--S 3209 of 3320
)d op UP2UTS
--R 
--R
--RThere is one unexposed function called UP2UTS :
--R   [1] D2 -> D1 from UTSodetools(D3,D2,D4,D1)
--R             if D3 has RING and D2 has UPOLYC(D3) and D1 has UTSCAT(D3)
--R            and D4 has LODOCAT(D2)
--R
--RExamples of UP2UTS from UTSodetools
--R
--E 3209

--S 3210 of 3320
)d op updatD
--R 
--R
--RThere is one unexposed function called updatD :
--R   [1] (List(Record(lcmfij: D3,totdeg: NonNegativeInteger,poli: D5,polj
--R            : D5)),List(Record(lcmfij: D3,totdeg: NonNegativeInteger,poli: D5
--R            ,polj: D5))) -> List(Record(lcmfij: D3,totdeg: NonNegativeInteger
--R            ,poli: D5,polj: D5))
--R             from GroebnerInternalPackage(D2,D3,D4,D5)
--R             if D3 has OAMONS and D5 has POLYCAT(D2,D3,D4) and D2 has 
--R            GCDDOM and D4 has ORDSET
--R
--RExamples of updatD from GroebnerInternalPackage
--R
--E 3210

--S 3211 of 3320
)d op update
--R 
--R
--RThere is one unexposed function called update :
--R   [1] (TwoDimensionalViewport,GraphImage,PositiveInteger) -> Void
--R             from TwoDimensionalViewport
--R
--RExamples of update from TwoDimensionalViewport
--R
--E 3211

--S 3212 of 3320
)d op upDateBranches
--R 
--R
--RThere are 2 exposed functions called upDateBranches :
--R   [1] (List(D1),List(D2),List(Record(val: List(D1),tower: D2)),Record(
--R            done: List(D2),todo: List(Record(val: List(D1),tower: D2))),
--R            NonNegativeInteger) -> List(Record(val: List(D1),tower: D2))
--R             from RegularSetDecompositionPackage(D8,D9,D10,D1,D2)
--R             if D1 has RPOLCAT(D8,D9,D10) and D2 has RSETCAT(D8,D9,D10,
--R            D1) and D8 has GCDDOM and D9 has OAMONS and D10 has ORDSET
--R            
--R   [2] (List(D1),List(D2),List(Record(val: List(D1),tower: D2)),Record(
--R            done: List(D2),todo: List(Record(val: List(D1),tower: D2))),
--R            NonNegativeInteger) -> List(Record(val: List(D1),tower: D2))
--R             from SquareFreeRegularSetDecompositionPackage(D8,D9,D10,D1
--R            ,D2)
--R             if D1 has RPOLCAT(D8,D9,D10) and D2 has SFRTCAT(D8,D9,D10,
--R            D1) and D8 has GCDDOM and D9 has OAMONS and D10 has ORDSET
--R            
--R
--RExamples of upDateBranches from RegularSetDecompositionPackage
--R
--R
--RExamples of upDateBranches from SquareFreeRegularSetDecompositionPackage
--R
--E 3212

--S 3213 of 3320
)d op updateStatus!
--R 
--R
--RThere is one unexposed function called updateStatus! :
--R   [1] SplittingTree(D1,D2) -> SplittingTree(D1,D2) from SplittingTree(
--R            D1,D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of updateStatus! from SplittingTree
--R
--E 3213

--S 3214 of 3320
)d op updatF
--R 
--R
--RThere is one unexposed function called updatF :
--R   [1] (D2,NonNegativeInteger,List(Record(totdeg: NonNegativeInteger,
--R            pol: D2))) -> List(Record(totdeg: NonNegativeInteger,pol: D2))
--R             from GroebnerInternalPackage(D4,D5,D6,D2)
--R             if D2 has POLYCAT(D4,D5,D6) and D4 has GCDDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R
--RExamples of updatF from GroebnerInternalPackage
--R
--E 3214

--S 3215 of 3320
)d op upperCase
--R 
--R
--RThere are 3 exposed functions called upperCase :
--R   [1]  -> CharacterClass from CharacterClass
--R   [2] Character -> Character from Character
--R   [3] D -> D from D if D has SRAGG
--R
--RExamples of upperCase from CharacterClass
--R
--R
--RExamples of upperCase from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[upperCase c for c in chars]
--R
--R
--RExamples of upperCase from StringAggregate
--R
--E 3215

--S 3216 of 3320
)d op upperCase!
--R 
--R
--RThere is one exposed function called upperCase! :
--R   [1] D -> D from D if D has SRAGG
--R
--RExamples of upperCase! from StringAggregate
--R
--E 3216

--S 3217 of 3320 done
)d op upperCase?
--R 
--R
--RThere is one exposed function called upperCase? :
--R   [1] Character -> Boolean from Character
--R
--RExamples of upperCase? from Character
--R
--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
--R[upperCase? c for c in chars]
--R
--E 3217

--S 3218 of 3320
)d op UpTriBddDenomInv
--R 
--R
--RThere is one unexposed function called UpTriBddDenomInv :
--R   [1] (D1,D2) -> D1 from TriangularMatrixOperations(D2,D3,D4,D1)
--R             if D2 has INTDOM and D3 has FLAGG(D2) and D4 has FLAGG(D2)
--R            and D1 has MATCAT(D2,D3,D4)
--R
--RExamples of UpTriBddDenomInv from TriangularMatrixOperations
--R
--E 3218

--S 3219 of 3320
)d op useEisensteinCriterion
--R 
--R
--RThere is one unexposed function called useEisensteinCriterion :
--R   [1] Boolean -> Boolean from GaloisGroupFactorizer(D2) if D2 has 
--R            UPOLYC(INT)
--R
--RExamples of useEisensteinCriterion from GaloisGroupFactorizer
--R
--E 3219

--S 3220 of 3320
)d op useEisensteinCriterion?
--R 
--R
--RThere is one unexposed function called useEisensteinCriterion? :
--R   [1]  -> Boolean from GaloisGroupFactorizer(D2) if D2 has UPOLYC(INT)
--R            
--R
--RExamples of useEisensteinCriterion? from GaloisGroupFactorizer
--R
--E 3220

--S 3221 of 3320
)d op useNagFunctions
--R 
--R
--RThere are 2 exposed functions called useNagFunctions :
--R   [1] Boolean -> Boolean from FortranExpression(D2,D3,D4)
--R             if D2: LIST(SYMBOL) and D3: LIST(SYMBOL) and D4 has FMTC
--R         
--R   [2]  -> Boolean from FortranExpression(D2,D3,D4)
--R             if D2: LIST(SYMBOL) and D3: LIST(SYMBOL) and D4 has FMTC
--R         
--R
--RExamples of useNagFunctions from FortranExpression
--R
--E 3221

--S 3222 of 3320
)d op userOrdered?
--R 
--R
--RThere is one unexposed function called userOrdered? :
--R   [1]  -> Boolean from UserDefinedPartialOrdering(D2) if D2 has SETCAT
--R            
--R
--RExamples of userOrdered? from UserDefinedPartialOrdering
--R
--E 3222

--S 3223 of 3320
)d op useSingleFactorBound
--R 
--R
--RThere is one unexposed function called useSingleFactorBound :
--R   [1] Boolean -> Boolean from GaloisGroupFactorizer(D2) if D2 has 
--R            UPOLYC(INT)
--R
--RExamples of useSingleFactorBound from GaloisGroupFactorizer
--R
--E 3223

--S 3224 of 3320
)d op useSingleFactorBound?
--R 
--R
--RThere is one unexposed function called useSingleFactorBound? :
--R   [1]  -> Boolean from GaloisGroupFactorizer(D2) if D2 has UPOLYC(INT)
--R            
--R
--RExamples of useSingleFactorBound? from GaloisGroupFactorizer
--R
--E 3224

--S 3225 of 3320
)d op usingTable?
--R 
--R
--RThere is one unexposed function called usingTable? :
--R   [1]  -> Boolean from TabulatedComputationPackage(D2,D3)
--R             if D2 has SETCAT and D3 has SETCAT
--R
--RExamples of usingTable? from TabulatedComputationPackage
--R
--E 3225

--S 3226 of 3320
)d op UTS2UP
--R 
--R
--RThere is one unexposed function called UTS2UP :
--R   [1] (D2,NonNegativeInteger) -> D1 from UTSodetools(D4,D1,D5,D2)
--R             if D4 has RING and D1 has UPOLYC(D4) and D5 has LODOCAT(D1
--R            ) and D2 has UTSCAT(D4)
--R
--RExamples of UTS2UP from UTSodetools
--R
--E 3226

--S 3227 of 3320
)d op validExponential
--R 
--R
--RThere is one exposed function called validExponential :
--R   [1] (List(Kernel(D1)),D1,Symbol) -> Union(D1,"failed")
--R             from ElementaryFunctionStructurePackage(D4,D1)
--R             if D1 has Join(AlgebraicallyClosedField,
--R            TranscendentalFunctionCategory,FunctionSpace(D4)) and D4
--R             has Join(IntegralDomain,OrderedSet,RetractableTo(Integer),
--R            LinearlyExplicitRingOver(Integer))
--R
--RExamples of validExponential from ElementaryFunctionStructurePackage
--R
--E 3227

--S 3228 of 3320
)d op value
--R 
--R
--RThere are 3 exposed functions called value :
--R   [1] OrdSetInts -> Integer from OrdSetInts
--R   [2] QueryEquation -> String from QueryEquation
--R   [3] D -> D1 from D if D has RCAGG(D1) and D1 has TYPE
--R
--RThere is one unexposed function called value :
--R   [1] SplittingNode(D1,D2) -> D1 from SplittingNode(D1,D2)
--R             if D1 has Join(SetCategory,Aggregate) and D2 has Join(
--R            SetCategory,Aggregate)
--R
--RExamples of value from OrdSetInts
--R
--R
--RExamples of value from QueryEquation
--R
--R
--RExamples of value from RecursiveAggregate
--R
--R
--RExamples of value from SplittingNode
--R
--E 3228

--S 3229 of 3320
)d op var1Steps
--R 
--R
--RThere is one exposed function called var1Steps :
--R   [1] PositiveInteger -> DrawOption from DrawOption
--R
--RThere is one unexposed function called var1Steps :
--R   [1] (List(DrawOption),PositiveInteger) -> PositiveInteger
--R             from DrawOptionFunctions0
--R
--RExamples of var1Steps from DrawOptionFunctions0
--R
--R
--RExamples of var1Steps from DrawOption
--R
--E 3229

--S 3230 of 3320
)d op var1StepsDefault
--R 
--R
--RThere are 2 exposed functions called var1StepsDefault :
--R   [1]  -> PositiveInteger from ViewDefaultsPackage
--R   [2] PositiveInteger -> PositiveInteger from ViewDefaultsPackage
--R
--RExamples of var1StepsDefault from ViewDefaultsPackage
--R
--E 3230

--S 3231 of 3320
)d op var2Steps
--R 
--R
--RThere is one exposed function called var2Steps :
--R   [1] PositiveInteger -> DrawOption from DrawOption
--R
--RThere is one unexposed function called var2Steps :
--R   [1] (List(DrawOption),PositiveInteger) -> PositiveInteger
--R             from DrawOptionFunctions0
--R
--RExamples of var2Steps from DrawOptionFunctions0
--R
--R
--RExamples of var2Steps from DrawOption
--R
--E 3231

--S 3232 of 3320
)d op var2StepsDefault
--R 
--R
--RThere are 2 exposed functions called var2StepsDefault :
--R   [1]  -> PositiveInteger from ViewDefaultsPackage
--R   [2] PositiveInteger -> PositiveInteger from ViewDefaultsPackage
--R
--RExamples of var2StepsDefault from ViewDefaultsPackage
--R
--E 3232

--S 3233 of 3320
)d op variable
--R 
--R
--RThere are 4 exposed functions called variable :
--R   [1] D -> D1 from D if D has DVARCAT(D1) and D1 has ORDSET
--R   [2] QueryEquation -> Symbol from QueryEquation
--R   [3] SegmentBinding(D2) -> Symbol from SegmentBinding(D2) if D2 has 
--R            TYPE
--R   [4] D -> Symbol from D if D has UPSCAT(D2,D3) and D2 has RING and D3
--R             has OAMON
--R
--RThere are 2 unexposed functions called variable :
--R   [1] Symbol -> Union(OrderedVariableList(D2),"failed")
--R             from OrderedVariableList(D2) if D2: LIST(SYMBOL)
--R   [2]  -> Symbol from Variable(D2) if D2: SYMBOL
--R
--RExamples of variable from DifferentialVariableCategory
--R
--R
--RExamples of variable from OrderedVariableList
--R
--R
--RExamples of variable from QueryEquation
--R
--R
--RExamples of variable from SegmentBinding
--R
--R
--RExamples of variable from UnivariatePowerSeriesCategory
--R
--R
--RExamples of variable from Variable
--R
--E 3233

--S 3234 of 3320
)d op variableName
--R 
--R
--RThere is one exposed function called variableName :
--R   [1] Symbol -> GuessOption from GuessOption
--R
--RThere is one unexposed function called variableName :
--R   [1] List(GuessOption) -> Symbol from GuessOptionFunctions0
--R
--RExamples of variableName from GuessOptionFunctions0
--R
--R
--RExamples of variableName from GuessOption
--R
--E 3234

--S 3235 of 3320
)d op variableOf
--R 
--R
--RThere is one exposed function called variableOf :
--R   [1] SimpleCell(D2,D3) -> Symbol from SimpleCell(D2,D3)
--R             if D2 has RCFIELD and D3 has UPOLYC(D2)
--R
--RExamples of variableOf from SimpleCell
--R
--E 3235

--S 3236 of 3320
)d op variables
--R 
--R
--RThere are 7 exposed functions called variables :
--R   [1] Record(lfn: List(Expression(DoubleFloat)),init: List(DoubleFloat
--R            )) -> List(Symbol)
--R             from e04AgentsPackage
--R   [2] FortranExpression(D2,D3,D4) -> List(Symbol)
--R             from FortranExpression(D2,D3,D4)
--R             if D2: LIST(SYMBOL) and D3: LIST(SYMBOL) and D4 has FMTC
--R         
--R   [3] D -> List(Symbol) from D if D has FS(D2) and D2 has ORDSET
--R   [4] D -> List(D4) from D
--R             if D has POLYCAT(D2,D3,D4) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET
--R   [5] D -> List(D4) from D
--R             if D has PSCAT(D2,D3,D4) and D2 has RING and D3 has OAMON 
--R            and D4 has ORDSET
--R   [6] D -> List(D4) from D
--R             if D has PSETCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            OAMONS and D4 has ORDSET and D5 has RPOLCAT(D2,D3,D4)
--R   [7] Fraction(Polynomial(D3)) -> List(Symbol) from RationalFunction(
--R            D3)
--R             if D3 has INTDOM
--R
--RThere are 3 unexposed functions called variables :
--R   [1] SparseUnivariatePolynomial(D6) -> List(D4)
--R             from FactoringUtilities(D3,D4,D5,D6)
--R             if D6 has POLYCAT(D5,D3,D4) and D3 has OAMONS and D4 has 
--R            ORDSET and D5 has RING
--R   [2] Pattern(D2) -> List(Pattern(D2)) from Pattern(D2) if D2 has 
--R            SETCAT
--R   [3] D2 -> List(D4) from PolynomialCategoryQuotientFunctions(D3,D4,D5
--R            ,D6,D2)
--R             if D3 has OAMONS and D4 has ORDSET and D5 has RING and D6
--R             has POLYCAT(D5,D3,D4) and D2 has Fieldwith
--R               coerce : D6 -> %
--R               numer : % -> D6
--R               denom : % -> D6
--R
--RExamples of variables from e04AgentsPackage
--R
--R
--RExamples of variables from FactoringUtilities
--R
--R
--RExamples of variables from FortranExpression
--R
--R
--RExamples of variables from FunctionSpace
--R
--R
--RExamples of variables from Pattern
--R
--R
--RExamples of variables from PolynomialCategory
--R
--R
--RExamples of variables from PolynomialCategoryQuotientFunctions
--R
--R
--RExamples of variables from PowerSeriesCategory
--R
--R
--RExamples of variables from PolynomialSetCategory
--R
--R
--RExamples of variables from RationalFunction
--R
--E 3236

--S 3237 of 3320
)d op variablesOf
--R 
--R
--RThere is one exposed function called variablesOf :
--R   [1] Cell(D2) -> List(Symbol) from Cell(D2) if D2 has RCFIELD
--R
--RExamples of variablesOf from Cell
--R
--E 3237

--S 3238 of 3320
)d op variationOfParameters
--R 
--R
--RThere is one unexposed function called variationOfParameters :
--R   [1] (D2,D3,List(D3)) -> Union(Vector(D3),"failed") from ODETools(D3,
--R            D2)
--R             if D3 has FIELD and D2 has LODOCAT(D3)
--R
--RExamples of variationOfParameters from ODETools
--R
--E 3238

--S 3239 of 3320
)d op vark
--R 
--R
--RThere is one unexposed function called vark :
--R   [1] (List(D5),Symbol) -> List(Kernel(D5)) from IntegrationTools(D4,
--R            D5)
--R             if D5 has FS(D4) and D4 has ORDSET
--R
--RExamples of vark from IntegrationTools
--R
--E 3239

--S 3240 of 3320
)d op varList
--R 
--R
--RThere are 4 exposed functions called varList :
--R   [1] (Symbol,NonNegativeInteger) -> List(Symbol) from 
--R            d03AgentsPackage
--R   [2] (Expression(DoubleFloat),NonNegativeInteger) -> List(Symbol)
--R             from e04AgentsPackage
--R   [3] D -> List(D2) from D
--R             if D has FLALG(D2,D3) and D2 has ORDSET and D3 has COMRING
--R            
--R   [4] D -> List(D2) from D if D has XFALG(D2,D3) and D2 has ORDSET and
--R            D3 has RING
--R
--RThere are 5 unexposed functions called varList :
--R   [1] LieExponentials(D2,D3,D4) -> List(D2) from LieExponentials(D2,D3
--R            ,D4)
--R             if D2 has ORDSET and D3 has Join(CommutativeRing,Module(
--R            Fraction(Integer))) and D4: PI
--R   [2] LyndonWord(D2) -> List(D2) from LyndonWord(D2) if D2 has ORDSET
--R            
--R   [3] Magma(D2) -> List(D2) from Magma(D2) if D2 has ORDSET
--R   [4] OrderedFreeMonoid(D2) -> List(D2) from OrderedFreeMonoid(D2) if 
--R            D2 has ORDSET
--R   [5] PoincareBirkhoffWittLyndonBasis(D2) -> List(D2)
--R             from PoincareBirkhoffWittLyndonBasis(D2) if D2 has ORDSET
--R            
--R
--RExamples of varList from d03AgentsPackage
--R
--R
--RExamples of varList from e04AgentsPackage
--R
--R
--RExamples of varList from FreeLieAlgebra
--R
--R
--RExamples of varList from LieExponentials
--R
--R
--RExamples of varList from LyndonWord
--R
--R
--RExamples of varList from Magma
--R
--R
--RExamples of varList from OrderedFreeMonoid
--R
--Rm1:=(x*y*y*z)$OFMONOID(Symbol) 
--RvarList m1
--R
--R
--RExamples of varList from PoincareBirkhoffWittLyndonBasis
--R
--R
--RExamples of varList from XFreeAlgebra
--R
--E 3240

--S 3241 of 3320
)d op varselect
--R 
--R
--RThere is one unexposed function called varselect :
--R   [1] (List(Kernel(D4)),Symbol) -> List(Kernel(D4))
--R             from IntegrationTools(D3,D4) if D4 has FS(D3) and D3 has 
--R            ORDSET
--R
--RExamples of varselect from IntegrationTools
--R
--E 3241

--S 3242 of 3320
)d op vconcat
--R 
--R
--RThere are 2 unexposed functions called vconcat :
--R   [1] List(OutputForm) -> OutputForm from OutputForm
--R   [2] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of vconcat from OutputForm
--R
--E 3242

--S 3243 of 3320
)d op vector
--R 
--R
--RThere are 2 exposed functions called vector :
--R   [1] List(Complex(DoubleFloat)) -> ComplexDoubleFloatVector
--R             from ComplexDoubleFloatVector
--R   [2] List(D2) -> Vector(D2) from Vector(D2) if D2 has TYPE
--R
--RExamples of vector from ComplexDoubleFloatVector
--R
--Rt1:List(Complex(DoubleFloat)):=[1+2*%i,3+4*%i,-5-6*%i] 
--Rt2:CDFVEC:=vector(t1)
--R
--R
--RExamples of vector from Vector
--R
--E 3243

--S 3244 of 3320
--R-----------------)d op vector_add_mul (fix this)
--E 3244

--S 3245 of 3320
--R-----------------)d op vector_combination (fix this)
--E 3245

--S 3246 of 3320
)d op vectorise
--R 
--R
--RThere are 2 exposed functions called vectorise :
--R   [1] (D,D) -> Vector(D) from D if D has PACPERC
--R   [2] (D,NonNegativeInteger) -> Vector(D3) from D
--R             if D has UPOLYC(D3) and D3 has RING
--R
--RExamples of vectorise from PseudoAlgebraicClosureOfPerfectFieldCategory
--R
--R
--RExamples of vectorise from UnivariatePolynomialCategory
--R
--Rt1:UP(x,FRAC(INT)):=3*x^3+4*x^2+5*x+6 
--Rt2:=vectorise(t1,4)
--R
--E 3246

--S 3247 of 3320
)d op Vectorise
--R 
--R
--RThere is one unexposed function called Vectorise :
--R   [1] ModMonic(D2,D3) -> Vector(D2) from ModMonic(D2,D3)
--R             if D2 has RING and D3 has UPOLYC(D2)
--R
--RExamples of Vectorise from ModMonic
--R
--E 3247

--S 3248 of 3320
)d op vedf2vef
--R 
--R
--RThere is one exposed function called vedf2vef :
--R   [1] Vector(Expression(DoubleFloat)) -> Vector(Expression(Float))
--R             from ExpertSystemToolsPackage
--R
--RExamples of vedf2vef from ExpertSystemToolsPackage
--R
--E 3248

--S 3249 of 3320 done
)d op vertConcat
--R 
--R
--RThere are 2 exposed functions called vertConcat :
--R   [1] List(D1) -> D1 from MatrixManipulation(D3,D4,D5,D1)
--R             if D3 has FIELD and D1 has MATCAT(D3,D4,D5) and D4 has 
--R            FLAGG(D3) and D5 has FLAGG(D3)
--R   [2] (D,D) -> D from D
--R             if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG
--R            (D1) and D3 has FLAGG(D1)
--R
--RExamples of vertConcat from MatrixManipulation
--R
--RA := matrix([[a]]) 
--RB := matrix([[b]]) 
--RC := matrix([[c]]) 
--RA21 := vertConcat([A,B,C])
--R
--R
--RExamples of vertConcat from MatrixCategory
--R
--Rm:=matrix [[j**i for i in 0..4] for j in 1..5] 
--RvertConcat(m,m)
--R
--E 3249

--S 3250 of 3320 done
)d op vertSplit
--R 
--R
--RThere are 2 exposed functions called vertSplit :
--R   [1] (D2,PositiveInteger) -> List(D2) from MatrixManipulation(D4,D5,
--R            D6,D2)
--R             if D4 has FIELD and D5 has FLAGG(D4) and D6 has FLAGG(D4) 
--R            and D2 has MATCAT(D4,D5,D6)
--R   [2] (D2,List(PositiveInteger)) -> List(D2)
--R             from MatrixManipulation(D4,D5,D6,D2)
--R             if D4 has FIELD and D5 has FLAGG(D4) and D6 has FLAGG(D4) 
--R            and D2 has MATCAT(D4,D5,D6)
--R
--RExamples of vertSplit from MatrixManipulation
--R
--RE := matrix([[i,a,b,c],[a,a,b,c],[b,d,e,f],[c,g,h,i]]) 
--Rt1:= vertSplit(E, [1,2,1])
--R
--RE := matrix([[i,a,b,c],[a,a,b,c],[b,d,e,f],[c,g,h,i]]) 
--Rt1:= vertSplit(E, 2)
--R
--E 3250

--S 3251 of 3320
)d op viewDefaults
--R 
--R
--RThere is one exposed function called viewDefaults :
--R   [1]  -> Void from ViewDefaultsPackage
--R
--RExamples of viewDefaults from ViewDefaultsPackage
--R
--E 3251

--S 3252 of 3320
)d op viewDeltaXDefault
--R 
--R
--RThere are 2 exposed functions called viewDeltaXDefault :
--R   [1] Float -> Float from ThreeDimensionalViewport
--R   [2]  -> Float from ThreeDimensionalViewport
--R
--RExamples of viewDeltaXDefault from ThreeDimensionalViewport
--R
--E 3252

--S 3253 of 3320
)d op viewDeltaYDefault
--R 
--R
--RThere are 2 exposed functions called viewDeltaYDefault :
--R   [1] Float -> Float from ThreeDimensionalViewport
--R   [2]  -> Float from ThreeDimensionalViewport
--R
--RExamples of viewDeltaYDefault from ThreeDimensionalViewport
--R
--E 3253

--S 3254 of 3320
)d op viewPhiDefault
--R 
--R
--RThere are 2 exposed functions called viewPhiDefault :
--R   [1] Float -> Float from ThreeDimensionalViewport
--R   [2]  -> Float from ThreeDimensionalViewport
--R
--RExamples of viewPhiDefault from ThreeDimensionalViewport
--R
--E 3254

--S 3255 of 3320
)d op viewpoint
--R 
--R
--RThere are 7 exposed functions called viewpoint :
--R   [1] Record(theta: DoubleFloat,phi: DoubleFloat,scale: DoubleFloat,
--R            scaleX: DoubleFloat,scaleY: DoubleFloat,scaleZ: DoubleFloat,
--R            deltaX: DoubleFloat,deltaY: DoubleFloat) -> DrawOption
--R             from DrawOption
--R   [2] (ThreeDimensionalViewport,Float,Float,Float) -> Void
--R             from ThreeDimensionalViewport
--R   [3] (ThreeDimensionalViewport,Float,Float) -> Void
--R             from ThreeDimensionalViewport
--R   [4] (ThreeDimensionalViewport,Integer,Integer,Float,Float,Float) -> 
--R            Void
--R             from ThreeDimensionalViewport
--R   [5] (ThreeDimensionalViewport,Record(theta: DoubleFloat,phi: 
--R            DoubleFloat,scale: DoubleFloat,scaleX: DoubleFloat,scaleY: 
--R            DoubleFloat,scaleZ: DoubleFloat,deltaX: DoubleFloat,deltaY: 
--R            DoubleFloat)) -> Void
--R             from ThreeDimensionalViewport
--R   [6] ThreeDimensionalViewport -> Record(theta: DoubleFloat,phi: 
--R            DoubleFloat,scale: DoubleFloat,scaleX: DoubleFloat,scaleY: 
--R            DoubleFloat,scaleZ: DoubleFloat,deltaX: DoubleFloat,deltaY: 
--R            DoubleFloat)
--R             from ThreeDimensionalViewport
--R   [7] (ThreeDimensionalViewport,Float,Float,Float,Float,Float) -> Void
--R             from ThreeDimensionalViewport
--R
--RThere is one unexposed function called viewpoint :
--R   [1] (List(DrawOption),Record(theta: DoubleFloat,phi: DoubleFloat,
--R            scale: DoubleFloat,scaleX: DoubleFloat,scaleY: DoubleFloat,scaleZ
--R            : DoubleFloat,deltaX: DoubleFloat,deltaY: DoubleFloat)) -> 
--R            Record(theta: DoubleFloat,phi: DoubleFloat,scale: DoubleFloat,
--R            scaleX: DoubleFloat,scaleY: DoubleFloat,scaleZ: DoubleFloat,
--R            deltaX: DoubleFloat,deltaY: DoubleFloat)
--R             from DrawOptionFunctions0
--R
--RExamples of viewpoint from DrawOptionFunctions0
--R
--R
--RExamples of viewpoint from DrawOption
--R
--R
--RExamples of viewpoint from ThreeDimensionalViewport
--R
--E 3255

--S 3256 of 3320
)d op viewport2D
--R 
--R
--RThere is one unexposed function called viewport2D :
--R   [1]  -> TwoDimensionalViewport from TwoDimensionalViewport
--R
--RExamples of viewport2D from TwoDimensionalViewport
--R
--E 3256

--S 3257 of 3320
)d op viewport3D
--R 
--R
--RThere is one exposed function called viewport3D :
--R   [1]  -> ThreeDimensionalViewport from ThreeDimensionalViewport
--R
--RExamples of viewport3D from ThreeDimensionalViewport
--R
--E 3257

--S 3258 of 3320
)d op viewPosDefault
--R 
--R
--RThere are 2 exposed functions called viewPosDefault :
--R   [1]  -> List(NonNegativeInteger) from ViewDefaultsPackage
--R   [2] List(NonNegativeInteger) -> List(NonNegativeInteger)
--R             from ViewDefaultsPackage
--R
--RExamples of viewPosDefault from ViewDefaultsPackage
--R
--E 3258

--S 3259 of 3320
)d op viewSizeDefault
--R 
--R
--RThere are 2 exposed functions called viewSizeDefault :
--R   [1]  -> List(PositiveInteger) from ViewDefaultsPackage
--R   [2] List(PositiveInteger) -> List(PositiveInteger) from 
--R            ViewDefaultsPackage
--R
--RExamples of viewSizeDefault from ViewDefaultsPackage
--R
--E 3259

--S 3260 of 3320
)d op viewThetaDefault
--R 
--R
--RThere are 2 exposed functions called viewThetaDefault :
--R   [1] Float -> Float from ThreeDimensionalViewport
--R   [2]  -> Float from ThreeDimensionalViewport
--R
--RExamples of viewThetaDefault from ThreeDimensionalViewport
--R
--E 3260

--S 3261 of 3320
)d op viewWriteAvailable
--R 
--R
--RThere is one exposed function called viewWriteAvailable :
--R   [1]  -> List(String) from ViewDefaultsPackage
--R
--RExamples of viewWriteAvailable from ViewDefaultsPackage
--R
--E 3261

--S 3262 of 3320
)d op viewWriteDefault
--R 
--R
--RThere are 2 exposed functions called viewWriteDefault :
--R   [1]  -> List(String) from ViewDefaultsPackage
--R   [2] List(String) -> List(String) from ViewDefaultsPackage
--R
--RExamples of viewWriteDefault from ViewDefaultsPackage
--R
--E 3262

--S 3263 of 3320
)d op viewZoomDefault
--R 
--R
--RThere are 2 exposed functions called viewZoomDefault :
--R   [1] Float -> Float from ThreeDimensionalViewport
--R   [2]  -> Float from ThreeDimensionalViewport
--R
--RExamples of viewZoomDefault from ThreeDimensionalViewport
--R
--E 3263

--S 3264 of 3320
)d op virtualDegree
--R 
--R
--RThere is one unexposed function called virtualDegree :
--R   [1] D2 -> NonNegativeInteger from GroebnerInternalPackage(D3,D4,D5,
--R            D2)
--R             if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D2 has POLYCAT(D3,D4,D5)
--R
--RExamples of virtualDegree from GroebnerInternalPackage
--R
--E 3264

--S 3265 of 3320
)d op void
--R 
--R
--RThere is one exposed function called void :
--R   [1]  -> Void from Void
--R
--RExamples of void from Void
--R
--E 3265

--S 3266 of 3320
)d op vspace
--R 
--R
--RThere is one unexposed function called vspace :
--R   [1] Integer -> OutputForm from OutputForm
--R
--RExamples of vspace from OutputForm
--R
--E 3266

--S 3267 of 3320
)d op weakBiRank
--R 
--R
--RThere is one exposed function called weakBiRank :
--R   [1] D2 -> NonNegativeInteger from AlgebraPackage(D3,D2)
--R             if D3 has INTDOM and D2 has FRNAALG(D3)
--R
--RExamples of weakBiRank from AlgebraPackage
--R
--E 3267

--S 3268 of 3320
)d op weierstrass
--R 
--R
--RThere is one unexposed function called weierstrass :
--R   [1] (Symbol,TaylorSeries(D4)) -> List(TaylorSeries(D4))
--R             from WeierstrassPreparation(D4) if D4 has FIELD
--R
--RExamples of weierstrass from WeierstrassPreparation
--R
--E 3268

--S 3269 of 3320
)d op weight
--R 
--R
--RThere are 5 exposed functions called weight :
--R   [1] (BasicOperator,NonNegativeInteger) -> BasicOperator from 
--R            BasicOperator
--R   [2] BasicOperator -> NonNegativeInteger from BasicOperator
--R   [3] (D,D2) -> NonNegativeInteger from D
--R             if D has DPOLCAT(D3,D2,D4,D5) and D3 has RING and D2 has 
--R            ORDSET and D4 has DVARCAT(D2) and D5 has OAMONS
--R   [4] D -> NonNegativeInteger from D
--R             if D has DPOLCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            ORDSET and D4 has DVARCAT(D3) and D5 has OAMONS
--R   [5] D -> NonNegativeInteger from D if D has DVARCAT(D2) and D2 has 
--R            ORDSET
--R
--RExamples of weight from BasicOperator
--R
--R
--RExamples of weight from DifferentialPolynomialCategory
--R
--R
--RExamples of weight from DifferentialVariableCategory
--R
--E 3269

--S 3270 of 3320
)d op weighted
--R 
--R
--RThere is one unexposed function called weighted :
--R   [1] List(Record(value: D3,weight: Integer)) -> (() -> D3)
--R             from RandomDistributions(D3) if D3 has SETCAT
--R
--RExamples of weighted from RandomDistributions
--R
--E 3270

--S 3271 of 3320
)d op weights
--R 
--R
--RThere are 2 exposed functions called weights :
--R   [1] (D,D2) -> List(NonNegativeInteger) from D
--R             if D has DPOLCAT(D3,D2,D4,D5) and D3 has RING and D2 has 
--R            ORDSET and D4 has DVARCAT(D2) and D5 has OAMONS
--R   [2] D -> List(NonNegativeInteger) from D
--R             if D has DPOLCAT(D2,D3,D4,D5) and D2 has RING and D3 has 
--R            ORDSET and D4 has DVARCAT(D3) and D5 has OAMONS
--R
--RExamples of weights from DifferentialPolynomialCategory
--R
--E 3271

--S 3272 of 3320
)d op whatInfinity
--R 
--R
--RThere is one exposed function called whatInfinity :
--R   [1] OrderedCompletion(D2) -> SingleInteger from OrderedCompletion(D2
--R            )
--R             if D2 has SETCAT
--R
--RExamples of whatInfinity from OrderedCompletion
--R
--E 3272

--S 3273 of 3320
)d op whileLoop
--R 
--R
--RThere is one exposed function called whileLoop :
--R   [1] (Switch,FortranCode) -> FortranCode from FortranCode
--R
--RExamples of whileLoop from FortranCode
--R
--E 3273

--S 3274 of 3320
)d op wholePart
--R 
--R
--RThere are 4 exposed functions called wholePart :
--R   [1] ContinuedFraction(D1) -> D1 from ContinuedFraction(D1) if D1
--R             has EUCDOM
--R   [2] PartialFraction(D1) -> D1 from PartialFraction(D1) if D1 has 
--R            EUCDOM
--R   [3] D -> D1 from D if D has QFCAT(D1) and D1 has INTDOM and D1 has 
--R            EUCDOM
--R   [4] D -> Integer from D if D has RNS
--R
--RExamples of wholePart from ContinuedFraction
--R
--R
--RExamples of wholePart from PartialFraction
--R
--Ra:=(74/13)::PFR(INT) 
--RwholePart(a)
--R
--R
--RExamples of wholePart from QuotientFieldCategory
--R
--R
--RExamples of wholePart from RealNumberSystem
--R
--E 3274

--S 3275 of 3320
)d op wholeRadix
--R 
--R
--RThere is one exposed function called wholeRadix :
--R   [1] List(Integer) -> RadixExpansion(D2) from RadixExpansion(D2) if 
--R            D2: INT
--R
--RExamples of wholeRadix from RadixExpansion
--R
--E 3275

--S 3276 of 3320
)d op wholeRagits
--R 
--R
--RThere is one exposed function called wholeRagits :
--R   [1] RadixExpansion(D2) -> List(Integer) from RadixExpansion(D2) if 
--R            D2: INT
--R
--RExamples of wholeRagits from RadixExpansion
--R
--E 3276

--S 3277 of 3320
)d op width
--R 
--R
--RThere is one exposed function called width :
--R   [1] D -> D1 from D
--R             if D has INTCAT(D1) and D1 has Join(FloatingPointSystem,
--R            TranscendentalFunctionCategory)
--R
--RThere are 2 unexposed functions called width :
--R   [1]  -> Integer from OutputForm
--R   [2] OutputForm -> Integer from OutputForm
--R
--RExamples of width from IntervalCategory
--R
--R
--RExamples of width from OutputForm
--R
--E 3277

--S 3278 of 3320
)d op withPredicates
--R 
--R
--RThere is one unexposed function called withPredicates :
--R   [1] (Pattern(D2),List(Any)) -> Pattern(D2) from Pattern(D2) if D2
--R             has SETCAT
--R
--RExamples of withPredicates from Pattern
--R
--E 3278

--S 3279 of 3320
)d op wordInGenerators
--R 
--R
--RThere is one exposed function called wordInGenerators :
--R   [1] (Permutation(D3),PermutationGroup(D3)) -> List(
--R            NonNegativeInteger)
--R             from PermutationGroup(D3) if D3 has SETCAT
--R
--RExamples of wordInGenerators from PermutationGroup
--R
--E 3279

--S 3280 of 3320
)d op wordInStrongGenerators
--R 
--R
--RThere is one exposed function called wordInStrongGenerators :
--R   [1] (Permutation(D3),PermutationGroup(D3)) -> List(
--R            NonNegativeInteger)
--R             from PermutationGroup(D3) if D3 has SETCAT
--R
--RExamples of wordInStrongGenerators from PermutationGroup
--R
--E 3280

--S 3281 of 3320
)d op wordsForStrongGenerators
--R 
--R
--RThere is one exposed function called wordsForStrongGenerators :
--R   [1] PermutationGroup(D2) -> List(List(NonNegativeInteger))
--R             from PermutationGroup(D2) if D2 has SETCAT
--R
--RExamples of wordsForStrongGenerators from PermutationGroup
--R
--E 3281

--S 3282 of 3320
)d op wreath
--R 
--R
--RThere is one exposed function called wreath :
--R   [1] (SymmetricPolynomial(Fraction(Integer)),SymmetricPolynomial(
--R            Fraction(Integer))) -> SymmetricPolynomial(Fraction(Integer))
--R             from CycleIndicators
--R
--RExamples of wreath from CycleIndicators
--R
--E 3282

--S 3283 of 3320
)d op writable?
--R 
--R
--RThere is one exposed function called writable? :
--R   [1] D -> Boolean from D if D has FNCAT
--R
--RExamples of writable? from FileNameCategory
--R
--E 3283

--S 3284 of 3320
)d op write
--R 
--R
--RThere are 3 exposed functions called write :
--R   [1] (ThreeDimensionalViewport,String,List(String)) -> String
--R             from ThreeDimensionalViewport
--R   [2] (ThreeDimensionalViewport,String,String) -> String
--R             from ThreeDimensionalViewport
--R   [3] (ThreeDimensionalViewport,String) -> String from 
--R            ThreeDimensionalViewport
--R
--RThere are 3 unexposed functions called write :
--R   [1] (TwoDimensionalViewport,String,List(String)) -> String
--R             from TwoDimensionalViewport
--R   [2] (TwoDimensionalViewport,String,String) -> String
--R             from TwoDimensionalViewport
--R   [3] (TwoDimensionalViewport,String) -> String from 
--R            TwoDimensionalViewport
--R
--RExamples of write from TwoDimensionalViewport
--R
--R
--RExamples of write from ThreeDimensionalViewport
--R
--E 3284

--S 3285 of 3320
)d op write!
--R 
--R
--RThere is one exposed function called write! :
--R   [1] (D,D1) -> D1 from D
--R             if D has FILECAT(D2,D1) and D2 has SETCAT and D1 has 
--R            SETCAT
--R
--RExamples of write! from FileCategory
--R
--E 3285

--S 3286 of 3320 done
)d op writeDotGraph
--R 
--R
--RThere is one exposed function called writeDotGraph :
--R   [1] (List(String),List(String),String) -> Void from Graphviz
--R
--RExamples of writeDotGraph from Graphviz
--R
--Rheader:=standardDotHeader() 
--Rgraph:=sampleDotGraph() 
--RwriteDotGraph(header,graph,"NeuralNet")
--R
--E 3286

--S 3287 of 3320
)d op writeLine!
--R 
--R
--RThere are 2 exposed functions called writeLine! :
--R   [1] TextFile -> String from TextFile
--R   [2] (TextFile,String) -> String from TextFile
--R
--RExamples of writeLine! from TextFile
--R
--E 3287

--S 3288 of 3320
)d op writeObj
--R 
--R
--RThere is one exposed function called writeObj :
--R   [1] (SubSpace(3,DoubleFloat),String) -> Void from Export3D
--R
--RExamples of writeObj from Export3D
--R
--E 3288

--S 3289 of 3320
)d op wronskianMatrix
--R 
--R
--RThere are 2 unexposed functions called wronskianMatrix :
--R   [1] List(D3) -> Matrix(D3) from ODETools(D3,D4)
--R             if D3 has FIELD and D4 has LODOCAT(D3)
--R   [2] (List(D4),NonNegativeInteger) -> Matrix(D4) from ODETools(D4,D5)
--R             if D4 has FIELD and D5 has LODOCAT(D4)
--R
--RExamples of wronskianMatrix from ODETools
--R
--E 3289

--S 3290 of 3320
)d op wrregime
--R 
--R
--RThere is one unexposed function called wrregime :
--R   [1] (List(Record(eqzro: List(D7),neqzro: List(D7),wcond: List(
--R            Polynomial(D4)),bsoln: Record(partsol: Vector(Fraction(Polynomial
--R            (D4))),basis: List(Vector(Fraction(Polynomial(D4))))))),String)
--R             -> Integer
--R             from ParametricLinearEquations(D4,D5,D6,D7)
--R             if D4 has Join(EuclideanDomain,CharacteristicZero) and D7
--R             has POLYCAT(D4,D6,D5) and D5 has Join(OrderedSet,
--R            ConvertibleTo(Symbol)) and D6 has OAMONS
--R
--RExamples of wrregime from ParametricLinearEquations
--R
--E 3290

--S 3291 of 3320
)d op xCoord
--R 
--R
--RThere is one unexposed function called xCoord :
--R   [1] Point(D1) -> D1 from PointPackage(D1) if D1 has RING
--R
--RExamples of xCoord from PointPackage
--R
--E 3291

--S 3292 of 3320
)d op xn
--R 
--R
--RThere is one unexposed function called xn :
--R   [1] NonNegativeInteger -> SparseUnivariatePolynomial(D3)
--R             from InnerNormalBasisFieldFunctions(D3) if D3 has FFIELDC
--R            
--R
--RExamples of xn from InnerNormalBasisFieldFunctions
--R
--E 3292

--S 3293 of 3320
)d op xor
--R 
--R
--RThere are 3 exposed functions called xor :
--R   [1] (Boolean,Boolean) -> Boolean from Boolean
--R   [2] (D,D) -> D from D if D has BTAGG
--R   [3] (SingleInteger,SingleInteger) -> SingleInteger from 
--R            SingleInteger
--R
--RExamples of xor from Boolean
--R
--R
--RExamples of xor from BitAggregate
--R
--R
--RExamples of xor from SingleInteger
--R
--E 3293

--S 3294 of 3320
)d op xRange
--R 
--R
--RThere are 2 exposed functions called xRange :
--R   [1] D -> Segment(DoubleFloat) from D if D has PPCURVE
--R   [2] D -> Segment(DoubleFloat) from D if D has PSCURVE
--R
--RExamples of xRange from PlottablePlaneCurveCategory
--R
--R
--RExamples of xRange from PlottableSpaceCurveCategory
--R
--E 3294

--S 3295 of 3320
)d op Y
--R 
--R
--RThere are 2 unexposed functions called Y :
--R   [1] (Stream(D3) -> Stream(D3)) -> Stream(D3)
--R             from ParadoxicalCombinatorsForStreams(D3) if D3 has TYPE
--R         
--R   [2] ((List(Stream(D4)) -> List(Stream(D4))),Integer) -> List(Stream(
--R            D4))
--R             from ParadoxicalCombinatorsForStreams(D4) if D4 has TYPE
--R         
--R
--RExamples of Y from ParadoxicalCombinatorsForStreams
--R
--E 3295

--S 3296 of 3320
)d op yCoord
--R 
--R
--RThere is one unexposed function called yCoord :
--R   [1] Point(D1) -> D1 from PointPackage(D1) if D1 has RING
--R
--RExamples of yCoord from PointPackage
--R
--E 3296

--S 3297 of 3320
)d op yCoordinates
--R 
--R
--RThere is one exposed function called yCoordinates :
--R   [1] D -> Record(num: Vector(D3),den: D3) from D
--R             if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC(
--R            D2) and D4 has UPOLYC(FRAC(D3))
--R
--RExamples of yCoordinates from FunctionFieldCategory
--R
--E 3297

--S 3298 of 3320
)d op yellow
--R 
--R
--RThere is one exposed function called yellow :
--R   [1]  -> Color from Color
--R
--RExamples of yellow from Color
--R
--E 3298

--S 3299 of 3320
)d op youngGroup
--R 
--R
--RThere are 2 exposed functions called youngGroup :
--R   [1] List(Integer) -> PermutationGroup(Integer) from 
--R            PermutationGroupExamples
--R   [2] Partition -> PermutationGroup(Integer) from 
--R            PermutationGroupExamples
--R
--RExamples of youngGroup from PermutationGroupExamples
--R
--E 3299

--S 3300 of 3320
)d op yRange
--R 
--R
--RThere are 2 exposed functions called yRange :
--R   [1] D -> Segment(DoubleFloat) from D if D has PPCURVE
--R   [2] D -> Segment(DoubleFloat) from D if D has PSCURVE
--R
--RExamples of yRange from PlottablePlaneCurveCategory
--R
--R
--RExamples of yRange from PlottableSpaceCurveCategory
--R
--E 3300

--S 3301 of 3320
)d op Yun
--R 
--R
--RThere is one exposed function called Yun :
--R   [1] D2 -> Factored(D2) from FiniteFieldSquareFreeDecomposition(D3,D2
--R            )
--R             if D3 has FFIELDC and D2 has UPOLYC(D3)
--R
--RExamples of Yun from FiniteFieldSquareFreeDecomposition
--R
--E 3301

--S 3302 of 3320
)d op zag
--R 
--R
--RThere is one unexposed function called zag :
--R   [1] (OutputForm,OutputForm) -> OutputForm from OutputForm
--R
--RExamples of zag from OutputForm
--R
--E 3302

--S 3303 of 3320
)d op zCoord
--R 
--R
--RThere is one unexposed function called zCoord :
--R   [1] Point(D1) -> D1 from PointPackage(D1) if D1 has RING
--R
--RExamples of zCoord from PointPackage
--R
--E 3303

--S 3304 of 3320
)d op zero
--R 
--R
--RThere are 2 exposed functions called zero :
--R   [1] (NonNegativeInteger,NonNegativeInteger) -> D from D
--R             if D2 has RING and D has MATCAT(D2,D3,D4) and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [2] NonNegativeInteger -> D from D
--R             if D has VECTCAT(D2) and D2 has ABELMON and D2 has TYPE
--R         
--R
--RExamples of zero from MatrixCategory
--R
--Rz:Matrix(INT):=zero(3,3)
--R
--R
--RExamples of zero from VectorCategory
--R
--E 3304

--S 3305 of 3320
)d op zero?
--R 
--R
--RThere are 5 exposed functions called zero? :
--R   [1] D -> Boolean from D if D has ABELMON
--R   [2] PolynomialIdeals(D2,D3,D4,D5) -> Boolean
--R             from PolynomialIdeals(D2,D3,D4,D5)
--R             if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D5
--R             has POLYCAT(D2,D3,D4)
--R   [3] D2 -> Boolean from D if D has MAGCDOC(D2,D3) and D2 has TYPE and
--R            D3 has TYPE
--R   [4] D -> Boolean from D
--R             if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG
--R            (D2) and D4 has FLAGG(D2)
--R   [5] (D2,D) -> Boolean from D
--R             if D has RRCC(D3,D2) and D3 has Join(OrderedRing,Field) 
--R            and D2 has UPOLYC(D3)
--R
--RExamples of zero? from AbelianMonoid
--R
--R
--RExamples of zero? from PolynomialIdeals
--R
--R
--RExamples of zero? from ModularAlgebraicGcdOperations
--R
--R
--RExamples of zero? from MatrixCategory
--R
--R
--RExamples of zero? from RealRootCharacterizationCategory
--R
--E 3305

--S 3306 of 3320
)d op zeroDim?
--R 
--R
--RThere are 2 exposed functions called zeroDim? :
--R   [1] PolynomialIdeals(D2,D3,D4,D5) -> Boolean
--R             from PolynomialIdeals(D2,D3,D4,D5)
--R             if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D5
--R             has POLYCAT(D2,D3,D4)
--R   [2] (PolynomialIdeals(D3,D4,D5,D6),List(D5)) -> Boolean
--R             from PolynomialIdeals(D3,D4,D5,D6)
--R             if D5 has ORDSET and D3 has FIELD and D4 has OAMONS and D6
--R             has POLYCAT(D3,D4,D5)
--R
--RExamples of zeroDim? from PolynomialIdeals
--R
--E 3306

--S 3307 of 3320
)d op zeroDimensional?
--R 
--R
--RThere are 2 unexposed functions called zeroDimensional? :
--R   [1] List(Polynomial(D3)) -> Boolean from FGLMIfCanPackage(D3,D4)
--R             if D3 has GCDDOM and D4: LIST(SYMBOL)
--R   [2] List(NewSparseMultivariatePolynomial(D3,OrderedVariableList(D4))
--R            ) -> Boolean
--R             from LexTriangularPackage(D3,D4) if D3 has GCDDOM and D4: 
--R            LIST(SYMBOL)
--R
--RExamples of zeroDimensional? from FGLMIfCanPackage
--R
--R
--RExamples of zeroDimensional? from LexTriangularPackage
--R
--E 3307

--S 3308 of 3320
)d op zeroDimPrimary?
--R 
--R
--RThere is one exposed function called zeroDimPrimary? :
--R   [1] PolynomialIdeals(Fraction(Integer),DirectProduct(D4,
--R            NonNegativeInteger),OrderedVariableList(D3),
--R            DistributedMultivariatePolynomial(D3,Fraction(Integer))) -> 
--R            Boolean
--R             from IdealDecompositionPackage(D3,D4) if D3: LIST(SYMBOL) 
--R            and D4: NNI
--R
--RExamples of zeroDimPrimary? from IdealDecompositionPackage
--R
--E 3308

--S 3309 of 3320
)d op zeroDimPrime?
--R 
--R
--RThere is one exposed function called zeroDimPrime? :
--R   [1] PolynomialIdeals(Fraction(Integer),DirectProduct(D4,
--R            NonNegativeInteger),OrderedVariableList(D3),
--R            DistributedMultivariatePolynomial(D3,Fraction(Integer))) -> 
--R            Boolean
--R             from IdealDecompositionPackage(D3,D4) if D3: LIST(SYMBOL) 
--R            and D4: NNI
--R
--RExamples of zeroDimPrime? from IdealDecompositionPackage
--R
--E 3309

--S 3310 of 3320
)d op zeroMatrix
--R 
--R
--RThere are 3 exposed functions called zeroMatrix :
--R   [1] (Symbol,Polynomial(Integer),Polynomial(Integer)) -> FortranCode
--R             from FortranCodePackage1
--R   [2] (Symbol,SegmentBinding(Polynomial(Integer)),SegmentBinding(
--R            Polynomial(Integer))) -> FortranCode
--R             from FortranCodePackage1
--R   [3] (NonNegativeInteger,NonNegativeInteger,NonNegativeInteger) -> 
--R            ThreeDimensionalMatrix(D2)
--R             from ThreeDimensionalMatrix(D2) if D2 has RING and D2 has 
--R            SETCAT
--R
--RExamples of zeroMatrix from FortranCodePackage1
--R
--R
--RExamples of zeroMatrix from ThreeDimensionalMatrix
--R
--E 3310

--S 3311 of 3320
)d op zeroOf
--R 
--R
--RThere are 5 exposed functions called zeroOf :
--R   [1] (SparseUnivariatePolynomial(D),Symbol) -> D from D if D has ACF
--R            
--R   [2] SparseUnivariatePolynomial(D) -> D from D if D has ACF
--R   [3] Polynomial(D) -> D from D if D has ACF
--R   [4] (D,Symbol) -> D from D
--R             if D has ACFS(D2) and D2 has Join(OrderedSet,
--R            IntegralDomain)
--R   [5] D -> D from D if D has ACFS(D1) and D1 has Join(OrderedSet,
--R            IntegralDomain)
--R
--RExamples of zeroOf from AlgebraicallyClosedField
--R
--Ra:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13 
--RzeroOf(a,x)
--R
--Ra:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13 
--RzeroOf(a)
--R
--Ra:Polynomial(Integer):=-3*x^2+2*x-13 
--RzeroOf(a)
--R
--R
--RExamples of zeroOf from AlgebraicallyClosedFunctionSpace
--R
--E 3311

--S 3312 of 3320
)d op zeroSetSplit
--R 
--R
--RThere are 7 exposed functions called zeroSetSplit :
--R   [1] (List(D7),Boolean,Boolean,Boolean,Boolean) -> List(
--R            RegularTriangularSet(D4,D5,D6,D7))
--R             from RegularTriangularSet(D4,D5,D6,D7)
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has GCDDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R   [2] (List(D7),Boolean,Boolean) -> List(RegularTriangularSet(D4,D5,D6
--R            ,D7))
--R             from RegularTriangularSet(D4,D5,D6,D7)
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has GCDDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R   [3] (List(NewSparseMultivariatePolynomial(D4,OrderedVariableList(D5)
--R            )),Boolean,Boolean) -> List(RegularChain(D4,D5))
--R             from RegularChain(D4,D5) if D4 has GCDDOM and D5: LIST(
--R            SYMBOL)
--R   [4] (List(D7),Boolean) -> List(D) from D
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has GCDDOM and D5 has 
--R            OAMONS and D6 has ORDSET and D has RSETCAT(D4,D5,D6,D7)
--R   [5] (List(D7),Boolean,Boolean,Boolean,Boolean) -> List(
--R            SquareFreeRegularTriangularSet(D4,D5,D6,D7))
--R             from SquareFreeRegularTriangularSet(D4,D5,D6,D7)
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has GCDDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R   [6] (List(D7),Boolean,Boolean) -> List(
--R            SquareFreeRegularTriangularSet(D4,D5,D6,D7))
--R             from SquareFreeRegularTriangularSet(D4,D5,D6,D7)
--R             if D7 has RPOLCAT(D4,D5,D6) and D4 has GCDDOM and D5 has 
--R            OAMONS and D6 has ORDSET
--R   [7] List(D6) -> List(D) from D
--R             if D6 has RPOLCAT(D3,D4,D5) and D3 has INTDOM and D4 has 
--R            OAMONS and D5 has ORDSET and D has TSETCAT(D3,D4,D5,D6)
--R
--RThere are 3 unexposed functions called zeroSetSplit :
--R   [1] (List(D8),Boolean) -> List(D1)
--R             from LazardSetSolvingPackage(D5,D6,D7,D8,D9,D1)
--R             if D8 has RPOLCAT(D5,D6,D7) and D5 has GCDDOM and D6 has 
--R            OAMONS and D7 has ORDSET and D9 has RSETCAT(D5,D6,D7,D8) 
--R            and D1 has SFRTCAT(D5,D6,D7,D8)
--R   [2] (List(NewSparseMultivariatePolynomial(D4,OrderedVariableList(D5)
--R            )),Boolean) -> List(RegularChain(D4,D5))
--R             from LexTriangularPackage(D4,D5) if D4 has GCDDOM and D5: 
--R            LIST(SYMBOL)
--R   [3] (List(NewSparseMultivariatePolynomial(D4,OrderedVariableList(D5)
--R            )),Boolean) -> List(SquareFreeRegularTriangularSet(D4,
--R            IndexedExponents(OrderedVariableList(D5)),OrderedVariableList(D5)
--R            ,NewSparseMultivariatePolynomial(D4,OrderedVariableList(D5))))
--R             from LexTriangularPackage(D4,D5) if D4 has GCDDOM and D5: 
--R            LIST(SYMBOL)
--R
--RExamples of zeroSetSplit from LazardSetSolvingPackage
--R
--R
--RExamples of zeroSetSplit from LexTriangularPackage
--R
--R
--RExamples of zeroSetSplit from RegularTriangularSet
--R
--R
--RExamples of zeroSetSplit from RegularChain
--R
--R
--RExamples of zeroSetSplit from RegularTriangularSetCategory
--R
--R
--RExamples of zeroSetSplit from SquareFreeRegularTriangularSet
--R
--R
--RExamples of zeroSetSplit from TriangularSetCategory
--R
--E 3312

--S 3313 of 3320
)d op zeroSetSplitIntoTriangularSystems
--R 
--R
--RThere is one exposed function called zeroSetSplitIntoTriangularSystems :
--R   [1] List(D6) -> List(Record(close: D,open: List(D6))) from D
--R             if D3 has INTDOM and D4 has OAMONS and D5 has ORDSET and 
--R            D6 has RPOLCAT(D3,D4,D5) and D has TSETCAT(D3,D4,D5,D6)
--R
--RExamples of zeroSetSplitIntoTriangularSystems from TriangularSetCategory
--R
--E 3313

--S 3314 of 3320
)d op zerosOf
--R 
--R
--RThere are 6 exposed functions called zerosOf :
--R   [1] (SparseUnivariatePolynomial(D),Symbol) -> List(D) from D if D
--R             has ACF
--R   [2] SparseUnivariatePolynomial(D) -> List(D) from D if D has ACF
--R   [3] Polynomial(D) -> List(D) from D if D has ACF
--R   [4] (D,Symbol) -> List(D) from D
--R             if D3 has Join(OrderedSet,IntegralDomain) and D has ACFS(
--R            D3)
--R   [5] D -> List(D) from D
--R             if D2 has Join(OrderedSet,IntegralDomain) and D has ACFS(
--R            D2)
--R   [6] (Expression(DoubleFloat),List(Symbol),Segment(OrderedCompletion(
--R            DoubleFloat))) -> Stream(DoubleFloat)
--R             from ExpertSystemContinuityPackage
--R
--RExamples of zerosOf from AlgebraicallyClosedField
--R
--Ra:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13 
--RzerosOf(a,x)
--R
--Ra:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13 
--RzerosOf(a)
--R
--Ra:Polynomial(Integer):=-3*x^2+2*x-13 
--RzerosOf(a)
--R
--R
--RExamples of zerosOf from AlgebraicallyClosedFunctionSpace
--R
--R
--RExamples of zerosOf from ExpertSystemContinuityPackage
--R
--E 3314

--S 3315 of 3320
)d op zeroSquareMatrix
--R 
--R
--RThere is one exposed function called zeroSquareMatrix :
--R   [1] (Symbol,Polynomial(Integer)) -> FortranCode from 
--R            FortranCodePackage1
--R
--RExamples of zeroSquareMatrix from FortranCodePackage1
--R
--E 3315

--S 3316 of 3320
)d op zeroVector
--R 
--R
--RThere is one exposed function called zeroVector :
--R   [1] (Symbol,Polynomial(Integer)) -> FortranCode from 
--R            FortranCodePackage1
--R
--RExamples of zeroVector from FortranCodePackage1
--R
--E 3316

--S 3317 of 3320
)d op zeta
--R 
--R
--RThere is one exposed function called zeta :
--R   [1]  -> DirichletRing(D1) from DirichletRing(D1) if D1 has RING
--R
--RExamples of zeta from DirichletRing
--R
--E 3317

--S 3318 of 3320
)d op ZetaFunction
--R 
--R
--RThere are 6 exposed functions called ZetaFunction :
--R   [1]  -> UnivariateTaylorSeriesCZero(Integer,t)
--R             from GeneralPackageForAlgebraicFunctionField(D6,D7,D8,D9,
--R            D10,D11,D12,D1,D2,D3,D4)
--R             if D6 has FINITE and D6 has FIELD and D7: LIST(SYMBOL) and
--R            D8 has POLYCAT(D6,D9,OVAR(D7)) and D9 has DIRPCAT(#(D7),NNI
--R            ) and D10 has PRSPCAT(D6) and D11 has LOCPOWC(D6) and D12
--R             has PLACESC(D6,D11) and D1 has DIVCAT(D12) and D2 has 
--R            INFCLCT(D6,D7,D8,D9,D10,D11,D12,D1,D4) and D4 has BLMETCT 
--R            and D3 has DSTRCAT(D2)
--R   [2] PositiveInteger -> UnivariateTaylorSeriesCZero(Integer,t)
--R             from GeneralPackageForAlgebraicFunctionField(D8,D9,D10,D11
--R            ,D12,D13,D1,D2,D3,D4,D5)
--R             if D8 has FINITE and D8 has FIELD and D9: LIST(SYMBOL) and
--R            D10 has POLYCAT(D8,D11,OVAR(D9)) and D11 has DIRPCAT(#(D9),
--R            NNI) and D12 has PRSPCAT(D8) and D13 has LOCPOWC(D8) and D1
--R             has PLACESC(D8,D13) and D2 has DIVCAT(D1) and D3 has 
--R            INFCLCT(D8,D9,D10,D11,D12,D13,D1,D2,D5) and D5 has BLMETCT 
--R            and D4 has DSTRCAT(D3)
--R   [3]  -> UnivariateTaylorSeriesCZero(Integer,t)
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D2,D3
--R            ,D4)
--R             if PseudoAlgebraicClosureOfFiniteField(D2) has FINITE and 
--R            D2 has FFIELDC and D3: LIST(SYMBOL) and D4 has BLMETCT
--R   [4] PositiveInteger -> UnivariateTaylorSeriesCZero(Integer,t)
--R             from PackageForAlgebraicFunctionFieldOverFiniteField(D3,D4
--R            ,D5)
--R             if PseudoAlgebraicClosureOfFiniteField(D3) has FINITE and 
--R            D3 has FFIELDC and D4: LIST(SYMBOL) and D5 has BLMETCT
--R   [5]  -> UnivariateTaylorSeriesCZero(Integer,t)
--R             from PackageForAlgebraicFunctionField(D2,D3,D4)
--R             if D2 has FINITE and D2 has FIELD and D3: LIST(SYMBOL) and
--R            D4 has BLMETCT
--R   [6] PositiveInteger -> UnivariateTaylorSeriesCZero(Integer,t)
--R             from PackageForAlgebraicFunctionField(D3,D4,D5)
--R             if D3 has FINITE and D3 has FIELD and D4: LIST(SYMBOL) and
--R            D5 has BLMETCT
--R
--RExamples of ZetaFunction from GeneralPackageForAlgebraicFunctionField
--R
--R
--RExamples of ZetaFunction from PackageForAlgebraicFunctionFieldOverFiniteField
--R
--R
--RExamples of ZetaFunction from PackageForAlgebraicFunctionField
--R
--E 3318

--S 3319 of 3320
)d op zoom
--R 
--R
--RThere are 2 exposed functions called zoom :
--R   [1] (ThreeDimensionalViewport,Float,Float,Float) -> Void
--R             from ThreeDimensionalViewport
--R   [2] (ThreeDimensionalViewport,Float) -> Void from 
--R            ThreeDimensionalViewport
--R
--RThere are 3 unexposed functions called zoom :
--R   [1] (Plot3D,Segment(DoubleFloat),Segment(DoubleFloat),Segment(
--R            DoubleFloat)) -> Plot3D
--R             from Plot3D
--R   [2] (Plot,Segment(DoubleFloat),Segment(DoubleFloat)) -> Plot from 
--R            Plot
--R   [3] (Plot,Segment(DoubleFloat)) -> Plot from Plot
--R
--RExamples of zoom from Plot3D
--R
--R
--RExamples of zoom from Plot
--R
--R
--RExamples of zoom from ThreeDimensionalViewport
--R
--E 3319

--S 3320 of 3320
)d op zRange
--R 
--R
--RThere is one exposed function called zRange :
--R   [1] D -> Segment(DoubleFloat) from D if D has PSCURVE
--R
--RExamples of zRange from PlottableSpaceCurveCategory
--R
--E 3320
 
)spool
 
)lisp (bye)
 
\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
