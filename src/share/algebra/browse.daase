
(2503905 . 3618799568)       
(|OneDimensionalArrayAggregate&| A S) 
((|constructor| (NIL "One-dimensional-array aggregates serves as models for one-dimensional arrays. Categorically, these aggregates are finite linear aggregates with the \\spadatt{shallowlyMutable} property, that is, any component of the array may be changed without affecting the identity of the overall array. Array data structures are typically represented by a fixed area in storage and cannot efficiently grow or shrink on demand as can list structures (see however \\spadtype{FlexibleArray} for a data structure which is a cross between a list and an array). Iteration over, and access to, elements of arrays is extremely fast (and often can be optimized to open-code). Insertion and deletion however is generally slow since an entirely new data structure must be created for the result."))) 
NIL 
NIL 
(|OneDimensionalArrayAggregate| S) 
((|constructor| (NIL "One-dimensional-array aggregates serves as models for one-dimensional arrays. Categorically, these aggregates are finite linear aggregates with the \\spadatt{shallowlyMutable} property, that is, any component of the array may be changed without affecting the identity of the overall array. Array data structures are typically represented by a fixed area in storage and cannot efficiently grow or shrink on demand as can list structures (see however \\spadtype{FlexibleArray} for a data structure which is a cross between a list and an array). Iteration over, and access to, elements of arrays is extremely fast (and often can be optimized to open-code). Insertion and deletion however is generally slow since an entirely new data structure must be created for the result."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|AbelianGroup&| S) 
((|constructor| (NIL "The class of abelian groups, \\spadignore{i.e.} additive monoids where each element has an additive inverse. \\blankline Axioms\\br \\tab{5}\\spad{-(-x) = x}\\br \\tab{5}\\spad{x+(-x) = 0}")) (* (($ (|Integer|) $) "\\spad{n*x} is the product of \\spad{x} by the integer \\spad{n.}")) (- (($ $ $) "\\spad{x-y} is the difference of \\spad{x} and \\spad{y} \\spadignore{i.e.} \\spad{x + (-y)}.") (($ $) "\\spad{-x} is the additive inverse of \\spad{x.}"))) 
NIL 
NIL 
(|AbelianGroup|) 
((|constructor| (NIL "The class of abelian groups, \\spadignore{i.e.} additive monoids where each element has an additive inverse. \\blankline Axioms\\br \\tab{5}\\spad{-(-x) = x}\\br \\tab{5}\\spad{x+(-x) = 0}")) (* (($ (|Integer|) $) "\\spad{n*x} is the product of \\spad{x} by the integer \\spad{n.}")) (- (($ $ $) "\\spad{x-y} is the difference of \\spad{x} and \\spad{y} \\spadignore{i.e.} \\spad{x + (-y)}.") (($ $) "\\spad{-x} is the additive inverse of \\spad{x.}"))) 
NIL 
NIL 
(|AbelianMonoid&| S) 
((|constructor| (NIL "The class of multiplicative monoids, \\spadignore{i.e.} semigroups with an additive identity element. \\blankline Axioms\\br \\tab{5}\\spad{leftIdentity(\"+\":(\\%,\\%)->\\%,0)}\\tab{5}\\spad{ 0+x=x }\\br \\tab{5}\\spad{rightIdentity(\"+\":(\\%,\\%)->\\%,0)}\\tab{4}\\spad{ x+0=x }")) (* (($ (|NonNegativeInteger|) $) "\\spad{n * \\spad{x}} is left-multiplication by a non negative integer")) (|zero?| (((|Boolean|) $) "\\spad{zero?(x)} tests if \\spad{x} is equal to 0.")) (|sample| (($) "\\spad{sample yields} a value of type \\%")) ((|Zero|) (($) "0 is the additive identity element."))) 
NIL 
NIL 
(|AbelianMonoid|) 
((|constructor| (NIL "The class of multiplicative monoids, \\spadignore{i.e.} semigroups with an additive identity element. \\blankline Axioms\\br \\tab{5}\\spad{leftIdentity(\"+\":(\\%,\\%)->\\%,0)}\\tab{5}\\spad{ 0+x=x }\\br \\tab{5}\\spad{rightIdentity(\"+\":(\\%,\\%)->\\%,0)}\\tab{4}\\spad{ x+0=x }")) (* (($ (|NonNegativeInteger|) $) "\\spad{n * \\spad{x}} is left-multiplication by a non negative integer")) (|zero?| (((|Boolean|) $) "\\spad{zero?(x)} tests if \\spad{x} is equal to 0.")) (|sample| (($) "\\spad{sample yields} a value of type \\%")) ((|Zero|) (($) "0 is the additive identity element."))) 
NIL 
NIL 
(|AbelianSemiGroup&| S) 
((|constructor| (NIL "The class of all additive (commutative) semigroups, \\spadignore{i.e.} a set with a commutative and associative operation \\spadop{+}. \\blankline Axioms\\br \\tab{5}\\spad{associative(\"+\":(\\%,\\%)->\\%)}\\tab{5}\\spad{ (x+y)+z = x+(y+z) }\\br \\tab{6}\\spad{commutative(\"+\":(\\%,\\%)->\\%)}\\tab{5}\\spad{ x+y = \\spad{y+x} }")) (* (($ (|PositiveInteger|) $) "\\spad{n*x} computes the left-multiplication of \\spad{x} by the positive integer \\spad{n.} This is equivalent to adding \\spad{x} to itself \\spad{n} times.")) (+ (($ $ $) "\\spad{x+y} computes the sum of \\spad{x} and \\spad{y.}"))) 
NIL 
NIL 
(|AbelianSemiGroup|) 
((|constructor| (NIL "The class of all additive (commutative) semigroups, \\spadignore{i.e.} a set with a commutative and associative operation \\spadop{+}. \\blankline Axioms\\br \\tab{5}\\spad{associative(\"+\":(\\%,\\%)->\\%)}\\tab{5}\\spad{ (x+y)+z = x+(y+z) }\\br \\tab{6}\\spad{commutative(\"+\":(\\%,\\%)->\\%)}\\tab{5}\\spad{ x+y = \\spad{y+x} }")) (* (($ (|PositiveInteger|) $) "\\spad{n*x} computes the left-multiplication of \\spad{x} by the positive integer \\spad{n.} This is equivalent to adding \\spad{x} to itself \\spad{n} times.")) (+ (($ $ $) "\\spad{x+y} computes the sum of \\spad{x} and \\spad{y.}"))) 
NIL 
NIL 
(|AlgebraicallyClosedField&| S) 
((|constructor| (NIL "Model for algebraically closed fields.")) (|zerosOf| (((|List| $) (|SparseUnivariatePolynomial| $) (|Symbol|)) "\\spad{zerosOf(p, \\spad{y)}} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. \\indented{1}{The yi's are expressed in radicals if possible, and otherwise} \\indented{1}{as implicit algebraic quantities} \\indented{1}{which display as \\spad{'yi}.} \\indented{1}{The returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zerosOf(a,x)") (((|List| $) (|SparseUnivariatePolynomial| $)) "\\spad{zerosOf(p)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. \\indented{1}{The yi's are expressed in radicals if possible, and otherwise} \\indented{1}{as implicit algebraic quantities.} \\indented{1}{The returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zerosOf(a)") (((|List| $) (|Polynomial| $)) "\\spad{zerosOf(p)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. \\indented{1}{The yi's are expressed in radicals if possible.} \\indented{1}{Otherwise they are implicit algebraic quantities.} \\indented{1}{The returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^2+2*x-13} \\spad{X} zerosOf(a)")) (|zeroOf| (($ (|SparseUnivariatePolynomial| $) (|Symbol|)) "\\spad{zeroOf(p, \\spad{y)}} returns \\spad{y} such that \\spad{p(y) = 0}; \\indented{1}{if possible, \\spad{y} is expressed in terms of radicals.} \\indented{1}{Otherwise it is an implicit algebraic quantity which} \\indented{1}{displays as \\spad{'y}.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zeroOf(a,x)") (($ (|SparseUnivariatePolynomial| $)) "\\spad{zeroOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}; \\indented{1}{if possible, \\spad{y} is expressed in terms of radicals.} \\indented{1}{Otherwise it is an implicit algebraic quantity.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zeroOf(a)") (($ (|Polynomial| $)) "\\spad{zeroOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. \\indented{1}{If possible, \\spad{y} is expressed in terms of radicals.} \\indented{1}{Otherwise it is an implicit algebraic quantity.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^2+2*x-13} \\spad{X} zeroOf(a)")) (|rootsOf| (((|List| $) (|SparseUnivariatePolynomial| $) (|Symbol|)) "\\spad{rootsOf(p, \\spad{y)}} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}; \\indented{1}{The returned roots display as \\spad{'y1},...,\\spad{'yn}.} \\indented{1}{Note that the returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootsOf(a,x)") (((|List| $) (|SparseUnivariatePolynomial| $)) "\\spad{rootsOf(p)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. \\indented{1}{Note that the returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootsOf(a)") (((|List| $) (|Polynomial| $)) "\\spad{rootsOf(p)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. \\indented{1}{Note that the returned symbols y1,...,yn are bound in the} \\indented{1}{interpreter to respective root values.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootsOf(a)")) (|rootOf| (($ (|SparseUnivariatePolynomial| $) (|Symbol|)) "\\spad{rootOf(p, \\spad{y)}} returns \\spad{y} such that \\spad{p(y) = 0}. \\indented{1}{The object returned displays as \\spad{'y}.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootOf(a,x)") (($ (|SparseUnivariatePolynomial| $)) "\\spad{rootOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootOf(a)") (($ (|Polynomial| $)) "\\spad{rootOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootOf(a)"))) 
NIL 
NIL 
(|AlgebraicallyClosedField|) 
((|constructor| (NIL "Model for algebraically closed fields.")) (|zerosOf| (((|List| $) (|SparseUnivariatePolynomial| $) (|Symbol|)) "\\spad{zerosOf(p, \\spad{y)}} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. \\indented{1}{The yi's are expressed in radicals if possible, and otherwise} \\indented{1}{as implicit algebraic quantities} \\indented{1}{which display as \\spad{'yi}.} \\indented{1}{The returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zerosOf(a,x)") (((|List| $) (|SparseUnivariatePolynomial| $)) "\\spad{zerosOf(p)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. \\indented{1}{The yi's are expressed in radicals if possible, and otherwise} \\indented{1}{as implicit algebraic quantities.} \\indented{1}{The returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zerosOf(a)") (((|List| $) (|Polynomial| $)) "\\spad{zerosOf(p)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. \\indented{1}{The yi's are expressed in radicals if possible.} \\indented{1}{Otherwise they are implicit algebraic quantities.} \\indented{1}{The returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^2+2*x-13} \\spad{X} zerosOf(a)")) (|zeroOf| (($ (|SparseUnivariatePolynomial| $) (|Symbol|)) "\\spad{zeroOf(p, \\spad{y)}} returns \\spad{y} such that \\spad{p(y) = 0}; \\indented{1}{if possible, \\spad{y} is expressed in terms of radicals.} \\indented{1}{Otherwise it is an implicit algebraic quantity which} \\indented{1}{displays as \\spad{'y}.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zeroOf(a,x)") (($ (|SparseUnivariatePolynomial| $)) "\\spad{zeroOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}; \\indented{1}{if possible, \\spad{y} is expressed in terms of radicals.} \\indented{1}{Otherwise it is an implicit algebraic quantity.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} zeroOf(a)") (($ (|Polynomial| $)) "\\spad{zeroOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. \\indented{1}{If possible, \\spad{y} is expressed in terms of radicals.} \\indented{1}{Otherwise it is an implicit algebraic quantity.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^2+2*x-13} \\spad{X} zeroOf(a)")) (|rootsOf| (((|List| $) (|SparseUnivariatePolynomial| $) (|Symbol|)) "\\spad{rootsOf(p, \\spad{y)}} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}; \\indented{1}{The returned roots display as \\spad{'y1},...,\\spad{'yn}.} \\indented{1}{Note that the returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootsOf(a,x)") (((|List| $) (|SparseUnivariatePolynomial| $)) "\\spad{rootsOf(p)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. \\indented{1}{Note that the returned symbols y1,...,yn are bound in the interpreter} \\indented{1}{to respective root values.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootsOf(a)") (((|List| $) (|Polynomial| $)) "\\spad{rootsOf(p)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. \\indented{1}{Note that the returned symbols y1,...,yn are bound in the} \\indented{1}{interpreter to respective root values.} \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootsOf(a)")) (|rootOf| (($ (|SparseUnivariatePolynomial| $) (|Symbol|)) "\\spad{rootOf(p, \\spad{y)}} returns \\spad{y} such that \\spad{p(y) = 0}. \\indented{1}{The object returned displays as \\spad{'y}.} \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootOf(a,x)") (($ (|SparseUnivariatePolynomial| $)) "\\spad{rootOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. \\blankline \\spad{X} \\spad{a:SparseUnivariatePolynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootOf(a)") (($ (|Polynomial| $)) "\\spad{rootOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. \\indented{1}{Error: if \\spad{p} has more than one variable \\spad{y.}} \\blankline \\spad{X} \\spad{a:Polynomial(Integer):=-3*x^3+2*x+13} \\spad{X} rootOf(a)"))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|AlgebraicallyClosedFunctionSpace&| S R) 
((|constructor| (NIL "Model for algebraically closed function spaces.")) (|zerosOf| (((|List| $) $ (|Symbol|)) "\\spad{zerosOf(p, \\spad{y)}} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. The yi's are expressed in radicals if possible, and otherwise as implicit algebraic quantities which display as \\spad{'yi}. The returned symbols y1,...,yn are bound in the interpreter to respective root values.") (((|List| $) $) "\\spad{zerosOf(p)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. The yi's are expressed in radicals if possible. The returned symbols y1,...,yn are bound in the interpreter to respective root values. Error: if \\spad{p} has more than one variable.")) (|zeroOf| (($ $ (|Symbol|)) "\\spad{zeroOf(p, \\spad{y)}} returns \\spad{y} such that \\spad{p(y) = 0}. The value \\spad{y} is expressed in terms of radicals if possible,and otherwise as an implicit algebraic quantity which displays as \\spad{'y}.") (($ $) "\\spad{zeroOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. The value \\spad{y} is expressed in terms of radicals if possible,and otherwise as an implicit algebraic quantity. Error: if \\spad{p} has more than one variable.")) (|rootsOf| (((|List| $) $ (|Symbol|)) "\\spad{rootsOf(p, \\spad{y)}} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}; The returned roots display as \\spad{'y1},...,\\spad{'yn}. Note that the returned symbols y1,...,yn are bound in the interpreter to respective root values.") (((|List| $) $) "\\spad{rootsOf(p, \\spad{y)}} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}; Note that the returned symbols y1,...,yn are bound in the interpreter to respective root values. Error: if \\spad{p} has more than one variable \\spad{y.}")) (|rootOf| (($ $ (|Symbol|)) "\\spad{rootOf(p,y)} returns \\spad{y} such that \\spad{p(y) = 0}. The object returned displays as \\spad{'y}.") (($ $) "\\spad{rootOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. Error: if \\spad{p} has more than one variable \\spad{y.}"))) 
NIL 
NIL 
(|AlgebraicallyClosedFunctionSpace| R) 
((|constructor| (NIL "Model for algebraically closed function spaces.")) (|zerosOf| (((|List| $) $ (|Symbol|)) "\\spad{zerosOf(p, \\spad{y)}} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. The yi's are expressed in radicals if possible, and otherwise as implicit algebraic quantities which display as \\spad{'yi}. The returned symbols y1,...,yn are bound in the interpreter to respective root values.") (((|List| $) $) "\\spad{zerosOf(p)} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}. The yi's are expressed in radicals if possible. The returned symbols y1,...,yn are bound in the interpreter to respective root values. Error: if \\spad{p} has more than one variable.")) (|zeroOf| (($ $ (|Symbol|)) "\\spad{zeroOf(p, \\spad{y)}} returns \\spad{y} such that \\spad{p(y) = 0}. The value \\spad{y} is expressed in terms of radicals if possible,and otherwise as an implicit algebraic quantity which displays as \\spad{'y}.") (($ $) "\\spad{zeroOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. The value \\spad{y} is expressed in terms of radicals if possible,and otherwise as an implicit algebraic quantity. Error: if \\spad{p} has more than one variable.")) (|rootsOf| (((|List| $) $ (|Symbol|)) "\\spad{rootsOf(p, \\spad{y)}} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}; The returned roots display as \\spad{'y1},...,\\spad{'yn}. Note that the returned symbols y1,...,yn are bound in the interpreter to respective root values.") (((|List| $) $) "\\spad{rootsOf(p, \\spad{y)}} returns \\spad{[y1,...,yn]} such that \\spad{p(yi) = 0}; Note that the returned symbols y1,...,yn are bound in the interpreter to respective root values. Error: if \\spad{p} has more than one variable \\spad{y.}")) (|rootOf| (($ $ (|Symbol|)) "\\spad{rootOf(p,y)} returns \\spad{y} such that \\spad{p(y) = 0}. The object returned displays as \\spad{'y}.") (($ $) "\\spad{rootOf(p)} returns \\spad{y} such that \\spad{p(y) = 0}. Error: if \\spad{p} has more than one variable \\spad{y.}"))) 
((|unitsKnown| . T) (|leftUnitary| . T) (|rightUnitary| . T) ((|commutative| "*") . T) (|noZeroDivisors| . T) (|canonicalUnitNormal| . T) (|canonicalsClosed| . T) (|nil| . T)) 
NIL 
(|PlaneAlgebraicCurvePlot|) 
((|constructor| (NIL "Plot a NON-SINGULAR plane algebraic curve p(x,y) = 0.")) (|refine| (($ $ (|DoubleFloat|)) "\\indented{1}{refine(p,x) is not documented} \\blankline \\spad{X} sketch:=makeSketch(x+y,x,y,-1/2..1/2,-1/2..1/2)$ACPLOT \\spad{X} refined:=refine(sketch,0.1)")) (|makeSketch| (($ (|Polynomial| (|Integer|)) (|Symbol|) (|Symbol|) (|Segment| (|Fraction| (|Integer|))) (|Segment| (|Fraction| (|Integer|)))) "\\indented{1}{makeSketch(p,x,y,a..b,c..d) creates an ACPLOT of the} \\indented{1}{curve \\spad{p = 0} in the region a \\spad{<=} \\spad{x} \\spad{<=} \\spad{b,} \\spad{c} \\spad{<=} \\spad{y} \\spad{<=} \\spad{d.}} \\indented{1}{More specifically, 'makeSketch' plots a non-singular algebraic curve} \\indented{1}{\\spad{p = 0} in an rectangular region xMin \\spad{<=} \\spad{x} \\spad{<=} xMax,} \\indented{1}{yMin \\spad{<=} \\spad{y} \\spad{<=} yMax. The user inputs} \\indented{1}{\\spad{makeSketch(p,x,y,xMin..xMax,yMin..yMax)}.} \\indented{1}{Here \\spad{p} is a polynomial in the variables \\spad{x} and \\spad{y} with} \\indented{1}{integer coefficients \\spad{(p} belongs to the domain} \\indented{1}{\\spad{Polynomial Integer}). The case} \\indented{1}{where \\spad{p} is a polynomial in only one of the variables is} \\indented{1}{allowed.\\space{2}The variables \\spad{x} and \\spad{y} are input to specify the} \\indented{1}{the coordinate axes.\\space{2}The horizontal axis is the x-axis and} \\indented{1}{the vertical axis is the y-axis.\\space{2}The rational numbers} \\indented{1}{xMin,...,yMax specify the boundaries of the region in} \\indented{1}{which the curve is to be plotted.} \\blankline \\spad{X} makeSketch(x+y,x,y,-1/2..1/2,-1/2..1/2)$ACPLOT"))) 
NIL 
NIL 
(|AffineAlgebraicSetComputeWithGroebnerBasis| K |symb| |PolyRing| E |ProjPt|) 
((|constructor| (NIL "The following is part of the PAFF package")) (|affineRationalPoints| (((|List| |#5|) |#3| (|PositiveInteger|)) "\\axiom{rationalPoints(f,d)} returns all points on the curve \\axiom{f} in the extension of the ground field of degree \\axiom{d}. For \\axiom{d > 1} this only works if \\axiom{K} is a \\axiomType{LocallyAlgebraicallyClosedField}"))) 
NIL 
NIL 
(|AffineAlgebraicSetComputeWithResultant| K |symb| |PolyRing| E |ProjPt|) 
((|constructor| (NIL "The following is part of the PAFF package"))) 
NIL 
NIL 
(|AffinePlane| K) 
((|constructor| (NIL "The following is all the categories and domains related to projective space and part of the PAFF package"))) 
NIL 
NIL 
(|AffinePlaneOverPseudoAlgebraicClosureOfFiniteField| K) 
((|constructor| (NIL "The following is all the categories and domains related to projective space and part of the PAFF package"))) 
NIL 
NIL 
(|AffineSpace| |dim| K) 
((|constructor| (NIL "The following is all the categories and domains related to projective space and part of the PAFF package"))) 
NIL 
NIL 
(|AlgebraicFunction| R F) 
((|constructor| (NIL "This package provides algebraic functions over an integral domain.")) (|iroot| ((|#2| |#1| (|Integer|)) "\\spad{iroot(p, \\spad{n)}} should be a non-exported function.")) (|definingPolynomial| ((|#2| |#2|) "\\spad{definingPolynomial(f)} returns the defining polynomial of \\spad{f} as an element of \\spad{F}. Error: if \\spad{f} is not a kernel.")) (|minPoly| (((|SparseUnivariatePolynomial| |#2|) (|Kernel| |#2|)) "\\spad{minPoly(k)} returns the defining polynomial of \\spad{k}.")) (** ((|#2| |#2| (|Fraction| (|Integer|))) "\\spad{x \\spad{**} \\spad{q}} is \\spad{x} raised to the rational power \\spad{q}.")) (|droot| (((|OutputForm|) (|List| |#2|)) "\\spad{droot(l)} should be a non-exported function.")) (|inrootof| ((|#2| (|SparseUnivariatePolynomial| |#2|) |#2|) "\\spad{inrootof(p, \\spad{x)}} should be a non-exported function.")) (|belong?| (((|Boolean|) (|BasicOperator|)) "\\spad{belong?(op)} is \\spad{true} if \\spad{op} is an algebraic operator, that is, an \\spad{n}th root or implicit algebraic operator.")) (|operator| (((|BasicOperator|) (|BasicOperator|)) "\\spad{operator(op)} returns a copy of \\spad{op} with the domain-dependent properties appropriate for \\spad{F}. Error: if \\spad{op} is not an algebraic operator, that is, an \\spad{n}th root or implicit algebraic operator.")) (|rootOf| ((|#2| (|SparseUnivariatePolynomial| |#2|) (|Symbol|)) "\\spad{rootOf(p, \\spad{y)}} returns \\spad{y} such that \\spad{p(y) = 0}. The object returned displays as \\spad{'y}."))) 
NIL 
((|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) 
(|AffineSpaceCategory| K) 
((|constructor| (NIL "The following is all the categories and domains related to projective space and part of the PAFF package")) (|pointValue| (((|List| |#1|) $) "\\spad{pointValue returns} the coordinates of the point or of the point of origin that represent an infinitly close point")) (|setelt| ((|#1| $ (|Integer|) |#1|) "\\spad{setelt sets} the value of a specified coordinates")) (|elt| ((|#1| $ (|Integer|)) "\\spad{elt returns} the value of a specified coordinates")) (|list| (((|List| |#1|) $) "\\spad{list returns} the list of the coordinates")) (|rational?| (((|Boolean|) $) "\\spad{rational?(p)} test if the point is rational according to the characteristic of the ground field.") (((|Boolean|) $ (|NonNegativeInteger|)) "\\spad{rational?(p,n)} test if the point is rational according to \\spad{n.}")) (|removeConjugate| (((|List| $) (|List| $)) "\\spad{removeConjugate(lp)} returns removeConjugate(lp,n) where \\spad{n} is the characteristic of the ground field.") (((|List| $) (|List| $) (|NonNegativeInteger|)) "\\spad{removeConjugate(lp,n)} returns a list of points such that no points in the list is the conjugate (according to \\spad{n)} of another point.")) (|conjugate| (($ $) "\\spad{conjugate(p)} returns conjugate(p,n) where \\spad{n} is the characteristic of the ground field.") (($ $ (|NonNegativeInteger|)) "\\spad{conjugate(p,n)} returns p**n, that is all the coordinates of \\spad{p} to the power of \\spad{n}")) (|orbit| (((|List| $) $ (|NonNegativeInteger|)) "\\spad{orbit(p,n)} returns the orbit of the point \\spad{p} according to \\spad{n,} that is orbit(p,n) = \\spad{\\{} \\spad{p,} p**n, p**(n**2), p**(n**3), ..... \\spad{\\}}") (((|List| $) $) "\\spad{orbit(p)} returns the orbit of the point \\spad{p} according to the characteristic of \\spad{K,} that is, for \\spad{q=} char \\spad{K,} orbit(p) = \\spad{\\{} \\spad{p,} p**q, p**(q**2), p**(q**3), ..... \\spad{\\}}")) (|coerce| (($ (|List| |#1|)) "\\spad{coerce a} list of \\spad{K} to a affine point.")) (|affinePoint| (($ (|List| |#1|)) "\\spad{affinePoint creates} a affine point from a list"))) 
NIL 
NIL 
(|Aggregate&| S) 
((|constructor| (NIL "The notion of aggregate serves to model any data structure aggregate, designating any collection of objects, with heterogenous or homogeneous members, with a finite or infinite number of members, explicitly or implicitly represented. An aggregate can in principle represent everything from a string of characters to abstract sets such as \"the set of \\spad{x} satisfying relation r(x)\" An attribute \"finiteAggregate\" is used to assert that a domain has a finite number of elements.")) (|#| (((|NonNegativeInteger|) $) "\\spad{# u} returns the number of items in u.")) (|sample| (($) "\\spad{sample yields} a value of type \\%")) (|size?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\spad{size?(u,n)} tests if \\spad{u} has exactly \\spad{n} elements.")) (|more?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\spad{more?(u,n)} tests if \\spad{u} has greater than \\spad{n} elements.")) (|less?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\spad{less?(u,n)} tests if \\spad{u} has less than \\spad{n} elements.")) (|empty?| (((|Boolean|) $) "\\spad{empty?(u)} tests if \\spad{u} has 0 elements.")) (|empty| (($) "\\spad{empty()}$D creates an aggregate of type \\spad{D} with 0 elements. Note that The \\spad{$D} can be dropped if understood by context, for example \\axiom{u: \\spad{D} \\spad{:=} empty()}.")) (|copy| (($ $) "\\spad{copy(u)} returns a top-level (non-recursive) copy of u. Note that for collections, \\axiom{copy(u) \\spad{==} \\spad{[x} for \\spad{x} in u]}.")) (|eq?| (((|Boolean|) $ $) "\\spad{eq?(u,v)} tests if \\spad{u} and \\spad{v} are same objects."))) 
NIL 
((|HasAttribute| |#1| (QUOTE |finiteAggregate|))) 
(|Aggregate|) 
((|constructor| (NIL "The notion of aggregate serves to model any data structure aggregate, designating any collection of objects, with heterogenous or homogeneous members, with a finite or infinite number of members, explicitly or implicitly represented. An aggregate can in principle represent everything from a string of characters to abstract sets such as \"the set of \\spad{x} satisfying relation r(x)\" An attribute \"finiteAggregate\" is used to assert that a domain has a finite number of elements.")) (|#| (((|NonNegativeInteger|) $) "\\spad{# u} returns the number of items in u.")) (|sample| (($) "\\spad{sample yields} a value of type \\%")) (|size?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\spad{size?(u,n)} tests if \\spad{u} has exactly \\spad{n} elements.")) (|more?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\spad{more?(u,n)} tests if \\spad{u} has greater than \\spad{n} elements.")) (|less?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\spad{less?(u,n)} tests if \\spad{u} has less than \\spad{n} elements.")) (|empty?| (((|Boolean|) $) "\\spad{empty?(u)} tests if \\spad{u} has 0 elements.")) (|empty| (($) "\\spad{empty()}$D creates an aggregate of type \\spad{D} with 0 elements. Note that The \\spad{$D} can be dropped if understood by context, for example \\axiom{u: \\spad{D} \\spad{:=} empty()}.")) (|copy| (($ $) "\\spad{copy(u)} returns a top-level (non-recursive) copy of u. Note that for collections, \\axiom{copy(u) \\spad{==} \\spad{[x} for \\spad{x} in u]}.")) (|eq?| (((|Boolean|) $ $) "\\spad{eq?(u,v)} tests if \\spad{u} and \\spad{v} are same objects."))) 
((|nil| . T)) 
NIL 
(|ArcHyperbolicFunctionCategory|) 
((|constructor| (NIL "Category for the inverse hyperbolic trigonometric functions.")) (|atanh| (($ $) "\\spad{atanh(x)} returns the hyperbolic arc-tangent of \\spad{x.}")) (|asinh| (($ $) "\\spad{asinh(x)} returns the hyperbolic arc-sine of \\spad{x.}")) (|asech| (($ $) "\\spad{asech(x)} returns the hyperbolic arc-secant of \\spad{x.}")) (|acsch| (($ $) "\\spad{acsch(x)} returns the hyperbolic arc-cosecant of \\spad{x.}")) (|acoth| (($ $) "\\spad{acoth(x)} returns the hyperbolic arc-cotangent of \\spad{x.}")) (|acosh| (($ $) "\\spad{acosh(x)} returns the hyperbolic arc-cosine of \\spad{x.}"))) 
NIL 
NIL 
(|AssociationListAggregate| |Key| |Entry|) 
((|constructor| (NIL "An association list is a list of key entry pairs which may be viewed as a table. It is a poor mans version of a table: searching for a key is a linear operation.")) (|assoc| (((|Union| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) "failed") |#1| $) "\\spad{assoc(k,u)} returns the element \\spad{x} in association list \\spad{u} stored with key \\spad{k,} or \"failed\" if \\spad{u} has no key \\spad{k.}"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|Algebra&| S R) 
((|constructor| (NIL "The category of associative algebras (modules which are themselves rings). \\blankline Axioms\\br \\tab{5}\\spad{(b+c)::% = (b::\\%) + (c::\\%)}\\br \\tab{5}\\spad{(b*c)::% = (b::\\%) * (c::\\%)}\\br \\tab{5}\\spad{(1::R)::% = 1::%}\\br \\tab{5}\\spad{b*x = (b::\\%)*x}\\br \\tab{5}\\spad{r*(a*b) = (r*a)*b = a*(r*b)}")) (|coerce| (($ |#2|) "\\spad{coerce(r)} maps the ring element \\spad{r} to a member of the algebra."))) 
NIL 
NIL 
(|Algebra| R) 
((|constructor| (NIL "The category of associative algebras (modules which are themselves rings). \\blankline Axioms\\br \\tab{5}\\spad{(b+c)::% = (b::\\%) + (c::\\%)}\\br \\tab{5}\\spad{(b*c)::% = (b::\\%) * (c::\\%)}\\br \\tab{5}\\spad{(1::R)::% = 1::%}\\br \\tab{5}\\spad{b*x = (b::\\%)*x}\\br \\tab{5}\\spad{r*(a*b) = (r*a)*b = a*(r*b)}")) (|coerce| (($ |#1|) "\\spad{coerce(r)} maps the ring element \\spad{r} to a member of the algebra."))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|AlgFactor| UP) 
((|constructor| (NIL "Factorization of univariate polynomials with coefficients in \\spadtype{AlgebraicNumber}.")) (|doublyTransitive?| (((|Boolean|) |#1|) "\\spad{doublyTransitive?(p)} is \\spad{true} if \\spad{p} is irreducible over over the field \\spad{K} generated by its coefficients, and if \\spad{p(X) / \\spad{(X} - a)} is irreducible over \\spad{K(a)} where \\spad{p(a) = 0}.")) (|split| (((|Factored| |#1|) |#1|) "\\spad{split(p)} returns a prime factorisation of \\spad{p} over its splitting field.")) (|factor| (((|Factored| |#1|) |#1|) "\\spad{factor(p)} returns a prime factorisation of \\spad{p} over the field generated by its coefficients.") (((|Factored| |#1|) |#1| (|List| (|AlgebraicNumber|))) "\\spad{factor(p, [a1,...,an])} returns a prime factorisation of \\spad{p} over the field generated by its coefficients and a1,...,an."))) 
NIL 
NIL 
(|AlgebraicFunctionField| F UP UPUP |modulus|) 
((|constructor| (NIL "Function field defined by f(x, \\spad{y)} = 0.")) (|knownInfBasis| (((|Void|) (|NonNegativeInteger|)) "\\spad{knownInfBasis(n)} is not documented"))) 
((|noZeroDivisors| |has| (|Fraction| |#2|) (|Field|)) (|canonicalUnitNormal| |has| (|Fraction| |#2|) (|Field|)) (|canonicalsClosed| |has| (|Fraction| |#2|) (|Field|)) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|Fraction| |#2|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|FiniteFieldCategory|))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|))) (OR (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|FiniteFieldCategory|)))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Finite|))) (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|Finite|))) (OR (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|)))) (AND (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|)))) (OR (AND (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|)))) (AND (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|FiniteFieldCategory|))))) (AND (|HasCategory| (|Fraction| |#2|) (QUOTE (|DifferentialRing|))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|)))) (OR (AND (|HasCategory| (|Fraction| |#2|) (QUOTE (|DifferentialRing|))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|)))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|FiniteFieldCategory|))))) 
(|AlgebraicManipulations| R F) 
((|constructor| (NIL "AlgebraicManipulations provides functions to simplify and expand expressions involving algebraic operators.")) (|rootKerSimp| ((|#2| (|BasicOperator|) |#2| (|NonNegativeInteger|)) "\\spad{rootKerSimp(op,f,n)} should be local but conditional.")) (|rootSimp| ((|#2| |#2|) "\\spad{rootSimp(f)} transforms every radical of the form \\spad{(a * b**(q*n+r))**(1/n)} appearing in \\spad{f} into \\spad{b**q * (a * b**r)**(1/n)}. This transformation is not in general valid for all complex numbers \\spad{b.}")) (|rootProduct| ((|#2| |#2|) "\\spad{rootProduct(f)} combines every product of the form \\spad{(a**(1/n))**m * (a**(1/s))**t} into a single power of a root of \\spad{a}, and transforms every radical power of the form \\spad{(a**(1/n))**m} into a simpler form.")) (|rootPower| ((|#2| |#2|) "\\spad{rootPower(f)} transforms every radical power of the form \\spad{(a**(1/n))**m} into a simpler form if \\spad{m} and \\spad{n} have a common factor.")) (|ratPoly| (((|SparseUnivariatePolynomial| |#2|) |#2|) "\\spad{ratPoly(f)} returns a polynomial \\spad{p} such that \\spad{p} has no algebraic coefficients, and \\spad{p(f) = 0}.")) (|ratDenom| ((|#2| |#2| (|List| (|Kernel| |#2|))) "\\spad{ratDenom(f, [a1,...,an])} removes the ai's which are algebraic from the denominators in \\spad{f.}") ((|#2| |#2| (|List| |#2|)) "\\spad{ratDenom(f, [a1,...,an])} removes the ai's which are algebraic kernels from the denominators in \\spad{f.}") ((|#2| |#2| |#2|) "\\spad{ratDenom(f, a)} removes \\spad{a} from the denominators in \\spad{f} if \\spad{a} is an algebraic kernel.") ((|#2| |#2|) "\\spad{ratDenom(f)} rationalizes the denominators appearing in \\spad{f} by moving all the algebraic quantities into the numerators.")) (|rootSplit| ((|#2| |#2|) "\\spad{rootSplit(f)} transforms every radical of the form \\spad{(a/b)**(1/n)} appearing in \\spad{f} into \\spad{a**(1/n) / b**(1/n)}. This transformation is not in general valid for all complex numbers \\spad{a} and \\spad{b.}")) (|coerce| (($ (|SparseMultivariatePolynomial| |#1| (|Kernel| $))) "\\spad{coerce(x)} \\undocumented")) (|denom| (((|SparseMultivariatePolynomial| |#1| (|Kernel| $)) $) "\\spad{denom(x)} \\undocumented")) (|numer| (((|SparseMultivariatePolynomial| |#1| (|Kernel| $)) $) "\\spad{numer(x)} \\undocumented"))) 
NIL 
((AND (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (LIST (QUOTE |FunctionSpace|) (|devaluate| |#1|))))) 
(|AlgebraicMultFact| OV E P) 
((|constructor| (NIL "This package factors multivariate polynomials over the domain of \\spadtype{AlgebraicNumber} by allowing the user to specify a list of algebraic numbers generating the particular extension to factor over.")) (|factor| (((|Factored| (|SparseUnivariatePolynomial| |#3|)) (|SparseUnivariatePolynomial| |#3|) (|List| (|AlgebraicNumber|))) "\\spad{factor(p,lan)} factors the polynomial \\spad{p} over the extension generated by the algebraic numbers given by the list lan. \\spad{p} is presented as a univariate polynomial with multivariate coefficients.") (((|Factored| |#3|) |#3| (|List| (|AlgebraicNumber|))) "\\spad{factor(p,lan)} factors the polynomial \\spad{p} over the extension generated by the algebraic numbers given by the list lan."))) 
NIL 
NIL 
(|AlgebraPackage| R A) 
((|constructor| (NIL "AlgebraPackage assembles a variety of useful functions for general algebras.")) (|basis| (((|Vector| |#2|) (|Vector| |#2|)) "\\spad{basis(va)} selects a basis from the elements of va.")) (|radicalOfLeftTraceForm| (((|List| |#2|)) "\\spad{radicalOfLeftTraceForm()} returns basis for null space of \\spad{leftTraceMatrix()}, if the algebra is associative, alternative or a Jordan algebra, then this space equals the radical (maximal nil ideal) of the algebra.")) (|basisOfCentroid| (((|List| (|Matrix| |#1|))) "\\spad{basisOfCentroid()} returns a basis of the centroid, \\spadignore{i.e.} the endomorphism ring of \\spad{A} considered as \\spad{(A,A)}-bimodule.")) (|basisOfRightNucloid| (((|List| (|Matrix| |#1|))) "\\spad{basisOfRightNucloid()} returns a basis of the space of endomorphisms of \\spad{A} as left module. Note that right nucloid coincides with right nucleus if \\spad{A} has a unit.")) (|basisOfLeftNucloid| (((|List| (|Matrix| |#1|))) "\\spad{basisOfLeftNucloid()} returns a basis of the space of endomorphisms of \\spad{A} as right module. Note that left nucloid coincides with left nucleus if \\spad{A} has a unit.")) (|basisOfCenter| (((|List| |#2|)) "\\spad{basisOfCenter()} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{commutator(x,a) = 0} and \\spad{associator(x,a,b) = associator(a,x,b) = associator(a,b,x) = 0} for all \\spad{a},b in \\spad{A}.")) (|basisOfNucleus| (((|List| |#2|)) "\\spad{basisOfNucleus()} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{associator(x,a,b) = associator(a,x,b) = associator(a,b,x) = 0} for all \\spad{a},b in \\spad{A}.")) (|basisOfMiddleNucleus| (((|List| |#2|)) "\\spad{basisOfMiddleNucleus()} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{0 = associator(a,x,b)} for all \\spad{a},b in \\spad{A}.")) (|basisOfRightNucleus| (((|List| |#2|)) "\\spad{basisOfRightNucleus()} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{0 = associator(a,b,x)} for all \\spad{a},b in \\spad{A}.")) (|basisOfLeftNucleus| (((|List| |#2|)) "\\spad{basisOfLeftNucleus()} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{0 = associator(x,a,b)} for all \\spad{a},b in \\spad{A}.")) (|basisOfRightAnnihilator| (((|List| |#2|) |#2|) "\\spad{basisOfRightAnnihilator(a)} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{0 = a*x}.")) (|basisOfLeftAnnihilator| (((|List| |#2|) |#2|) "\\spad{basisOfLeftAnnihilator(a)} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{0 = x*a}.")) (|basisOfCommutingElements| (((|List| |#2|)) "\\spad{basisOfCommutingElements()} returns a basis of the space of all \\spad{x} of \\spad{A} satisfying \\spad{0 = commutator(x,a)} for all \\spad{a} in \\spad{A}.")) (|biRank| (((|NonNegativeInteger|) |#2|) "\\spad{biRank(x)} determines the number of linearly independent elements in \\spad{x}, \\spad{x*bi}, \\spad{bi*x}, \\spad{bi*x*bj}, \\spad{i,j=1,...,n}, where \\spad{b=[b1,...,bn]} is a basis. Note that if \\spad{A} has a unit, then doubleRank, weakBiRank, and biRank coincide.")) (|weakBiRank| (((|NonNegativeInteger|) |#2|) "\\spad{weakBiRank(x)} determines the number of linearly independent elements in the \\spad{bi*x*bj}, \\spad{i,j=1,...,n}, where \\spad{b=[b1,...,bn]} is a basis.")) (|doubleRank| (((|NonNegativeInteger|) |#2|) "\\spad{doubleRank(x)} determines the number of linearly independent elements in \\spad{b1*x},...,\\spad{x*bn}, where \\spad{b=[b1,...,bn]} is a basis.")) (|rightRank| (((|NonNegativeInteger|) |#2|) "\\spad{rightRank(x)} determines the number of linearly independent elements in \\spad{b1*x},...,\\spad{bn*x}, where \\spad{b=[b1,...,bn]} is a basis.")) (|leftRank| (((|NonNegativeInteger|) |#2|) "\\spad{leftRank(x)} determines the number of linearly independent elements in \\spad{x*b1},...,\\spad{x*bn}, where \\spad{b=[b1,...,bn]} is a basis."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|EuclideanDomain|)))) 
(|AlgebraGivenByStructuralConstants| R |n| |ls| |gamma|) 
((|constructor| (NIL "AlgebraGivenByStructuralConstants implements finite rank algebras over a commutative ring, given by the structural constants \\spad{gamma} with respect to a fixed basis \\spad{[a1,..,an]}, where \\spad{gamma} is an \\spad{n}-vector of \\spad{n} by \\spad{n} matrices \\spad{[(gammaijk) for \\spad{k} in 1..rank()]} defined by \\spad{ai * aj = \\spad{gammaij1} * \\spad{a1} + \\spad{...} + gammaijn * an}. The symbols for the fixed basis have to be given as a list of symbols.")) (|coerce| (($ (|Vector| |#1|)) "\\spad{coerce(v)} converts a vector to a member of the algebra by forming a linear combination with the basis element. Note: the vector is assumed to have length equal to the dimension of the algebra."))) 
((|unitsKnown| |has| |#1| (|IntegralDomain|)) (|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) 
(|AssociationList| |Key| |Entry|) 
((|constructor| (NIL "\\spadtype{AssociationList} implements association lists. These may be viewed as lists of pairs where the first part is a key and the second is the stored value. For example, the key might be a string with a persons employee identification number and the value might be a record with personnel data."))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (OR (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (OR (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|OrderedSet|))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (AND (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (|devaluate| |#1|)) (LIST (QUOTE |:|) (QUOTE |entry|) (|devaluate| |#2|))))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (|devaluate| |#1|)) (LIST (QUOTE |:|) (QUOTE |entry|) (|devaluate| |#2|))))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|OrderedSet|)))) (AND (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (|devaluate| |#1|)) (LIST (QUOTE |:|) (QUOTE |entry|) (|devaluate| |#2|))))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|)))))) 
(|AbelianMonoidRing&| S R E) 
((|constructor| (NIL "Abelian monoid ring elements (not necessarily of finite support) of this ring are of the form formal SUM (r_i * e_i) where the r_i are coefficents and the e_i, elements of the ordered abelian monoid, are thought of as exponents or monomials. The monomials commute with each other, and with the coefficients (which themselves may or may not be commutative). See \\spadtype{FiniteAbelianMonoidRing} for the case of finite support a useful common model for polynomials and power series. Conceptually at least, only the non-zero terms are ever operated on.")) (/ (($ $ |#2|) "\\spad{p/c} divides \\spad{p} by the coefficient \\spad{c.}")) (|coefficient| ((|#2| $ |#3|) "\\spad{coefficient(p,e)} extracts the coefficient of the monomial with exponent \\spad{e} from polynomial \\spad{p,} or returns zero if exponent is not present.")) (|reductum| (($ $) "\\spad{reductum(u)} returns \\spad{u} minus its leading monomial returns zero if handed the zero element.")) (|monomial| (($ |#2| |#3|) "\\spad{monomial(r,e)} makes a term from a coefficient \\spad{r} and an exponent e.")) (|monomial?| (((|Boolean|) $) "\\spad{monomial?(p)} tests if \\spad{p} is a single monomial.")) (|map| (($ (|Mapping| |#2| |#2|) $) "\\spad{map(fn,u)} maps function \\spad{fn} onto the coefficients of the non-zero monomials of u.")) (|degree| ((|#3| $) "\\spad{degree(p)} returns the maximum of the exponents of the terms of \\spad{p.}")) (|leadingMonomial| (($ $) "\\spad{leadingMonomial(p)} returns the monomial of \\spad{p} with the highest degree.")) (|leadingCoefficient| ((|#2| $) "\\spad{leadingCoefficient(p)} returns the coefficient highest degree term of \\spad{p.}"))) 
NIL 
((|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|Field|)))) 
(|AbelianMonoidRing| R E) 
((|constructor| (NIL "Abelian monoid ring elements (not necessarily of finite support) of this ring are of the form formal SUM (r_i * e_i) where the r_i are coefficents and the e_i, elements of the ordered abelian monoid, are thought of as exponents or monomials. The monomials commute with each other, and with the coefficients (which themselves may or may not be commutative). See \\spadtype{FiniteAbelianMonoidRing} for the case of finite support a useful common model for polynomials and power series. Conceptually at least, only the non-zero terms are ever operated on.")) (/ (($ $ |#1|) "\\spad{p/c} divides \\spad{p} by the coefficient \\spad{c.}")) (|coefficient| ((|#1| $ |#2|) "\\spad{coefficient(p,e)} extracts the coefficient of the monomial with exponent \\spad{e} from polynomial \\spad{p,} or returns zero if exponent is not present.")) (|reductum| (($ $) "\\spad{reductum(u)} returns \\spad{u} minus its leading monomial returns zero if handed the zero element.")) (|monomial| (($ |#1| |#2|) "\\spad{monomial(r,e)} makes a term from a coefficient \\spad{r} and an exponent e.")) (|monomial?| (((|Boolean|) $) "\\spad{monomial?(p)} tests if \\spad{p} is a single monomial.")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\spad{map(fn,u)} maps function \\spad{fn} onto the coefficients of the non-zero monomials of u.")) (|degree| ((|#2| $) "\\spad{degree(p)} returns the maximum of the exponents of the terms of \\spad{p.}")) (|leadingMonomial| (($ $) "\\spad{leadingMonomial(p)} returns the monomial of \\spad{p} with the highest degree.")) (|leadingCoefficient| ((|#1| $) "\\spad{leadingCoefficient(p)} returns the coefficient highest degree term of \\spad{p.}"))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|AlgebraicNumber|) 
((|constructor| (NIL "Algebraic closure of the rational numbers, with mathematical =")) (|norm| (($ $ (|List| (|Kernel| $))) "\\spad{norm(f,l)} computes the norm of the algebraic number \\spad{f} with respect to the extension generated by kernels \\spad{l}") (($ $ (|Kernel| $)) "\\spad{norm(f,k)} computes the norm of the algebraic number \\spad{f} with respect to the extension generated by kernel \\spad{k}") (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|List| (|Kernel| $))) "\\spad{norm(p,l)} computes the norm of the polynomial \\spad{p} with respect to the extension generated by kernels \\spad{l}") (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|Kernel| $)) "\\spad{norm(p,k)} computes the norm of the polynomial \\spad{p} with respect to the extension generated by kernel \\spad{k}")) (|reduce| (($ $) "\\spad{reduce(f)} simplifies all the unreduced algebraic numbers present in \\spad{f} by applying their defining relations.")) (|denom| (((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $) "\\spad{denom(f)} returns the denominator of \\spad{f} viewed as a polynomial in the kernels over \\spad{Z.}")) (|numer| (((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $) "\\spad{numer(f)} returns the numerator of \\spad{f} viewed as a polynomial in the kernels over \\spad{Z.}")) (|coerce| (($ (|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $))) "\\spad{coerce(p)} returns \\spad{p} viewed as an algebraic number."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| $ (QUOTE (|Ring|))) (|HasCategory| $ (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) 
(|AnonymousFunction|) 
((|constructor| (NIL "This domain implements anonymous functions"))) 
NIL 
NIL 
(|AntiSymm| R |lVar|) 
((|constructor| (NIL "The domain of antisymmetric polynomials.")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\spad{map(f,p)} changes each coefficient of \\spad{p} by the application of \\spad{f.}")) (|degree| (((|NonNegativeInteger|) $) "\\spad{degree(p)} returns the homogeneous degree of \\spad{p.}")) (|retractable?| (((|Boolean|) $) "\\spad{retractable?(p)} tests if \\spad{p} is a 0-form, \\spadignore{i.e.} if degree(p) = 0.")) (|homogeneous?| (((|Boolean|) $) "\\spad{homogeneous?(p)} tests if all of the terms of \\spad{p} have the same degree.")) (|exp| (($ (|List| (|Integer|))) "\\spad{exp([i1,...in])} returns \\spad{u_1\\^{i_1} \\spad{...} u_n\\^{i_n}}")) (|generator| (($ (|NonNegativeInteger|)) "\\spad{generator(n)} returns the \\spad{n}th multiplicative generator, a basis term.")) (|coefficient| ((|#1| $ $) "\\spad{coefficient(p,u)} returns the coefficient of the term in \\spad{p} containing the basis term \\spad{u} if such a term exists, and 0 otherwise. Error: if the second argument \\spad{u} is not a basis element.")) (|reductum| (($ $) "\\spad{reductum(p)}, where \\spad{p} is an antisymmetric polynomial, returns \\spad{p} minus the leading term of \\spad{p} if \\spad{p} has at least two terms, and 0 otherwise.")) (|leadingBasisTerm| (($ $) "\\spad{leadingBasisTerm(p)} returns the leading basis term of antisymmetric polynomial \\spad{p.}")) (|leadingCoefficient| ((|#1| $) "\\spad{leadingCoefficient(p)} returns the leading coefficient of antisymmetric polynomial \\spad{p.}"))) 
((|unitsKnown| . T)) 
NIL 
(|AnyFunctions1| S) 
((|constructor| (NIL "\\spadtype{AnyFunctions1} implements several utility functions for working with \\spadtype{Any}. These functions are used to go back and forth between objects of \\spadtype{Any} and objects of other types.")) (|retract| ((|#1| (|Any|)) "\\spad{retract(a)} tries to convert \\spad{a} into an object of type \\spad{S}. If possible, it returns the object. Error: if no such retraction is possible.")) (|retractable?| (((|Boolean|) (|Any|)) "\\spad{retractable?(a)} tests if \\spad{a} can be converted into an object of type \\spad{S}.")) (|retractIfCan| (((|Union| |#1| "failed") (|Any|)) "\\spad{retractIfCan(a)} tries change \\spad{a} into an object of type \\spad{S}. If it can, then such an object is returned. Otherwise, \"failed\" is returned.")) (|coerce| (((|Any|) |#1|) "\\spad{coerce(s)} creates an object of \\spadtype{Any} from the object \\spad{s} of type \\spad{S}."))) 
NIL 
NIL 
(|Any|) 
((|constructor| (NIL "\\spadtype{Any} implements a type that packages up objects and their types in objects of \\spadtype{Any}. Roughly speaking that means that if \\spad{s : \\spad{S}} then when converted to \\spadtype{Any}, the new object will include both the original object and its type. This is a way of converting arbitrary objects into a single type without losing any of the original information. Any object can be converted to one of \\spadtype{Any}.")) (|showTypeInOutput| (((|String|) (|Boolean|)) "\\spad{showTypeInOutput(bool)} affects the way objects of \\spadtype{Any} are displayed. If \\spad{bool} is \\spad{true} then the type of the original object that was converted to \\spadtype{Any} will be printed. If \\spad{bool} is false, it will not be printed.")) (|obj| (((|None|) $) "\\spad{obj(a)} essentially returns the original object that was converted to \\spadtype{Any} except that the type is forced to be \\spadtype{None}.")) (|dom| (((|SExpression|) $) "\\spad{dom(a)} returns a \\spadgloss{LISP} form of the type of the original object that was converted to \\spadtype{Any}.")) (|objectOf| (((|OutputForm|) $) "\\spad{objectOf(a)} returns a printable form of the original object that was converted to \\spadtype{Any}.")) (|domainOf| (((|OutputForm|) $) "\\spad{domainOf(a)} returns a printable form of the type of the original object that was converted to \\spadtype{Any}.")) (|any| (($ (|SExpression|) (|None|)) "\\spad{any(type,object)} is a technical function for creating an \\spad{object} of \\spadtype{Any}. Arugment \\spad{type} is a \\spadgloss{LISP} form for the \\spad{type} of \\spad{object}."))) 
NIL 
NIL 
(|ApplicationProgramInterface|) 
((|constructor| (NIL "This package contains useful functions that expose Axiom system internals")) (|reportInstantiations| (((|Void|) (|Boolean|)) "\\indented{1}{A debugging tool to show instantiation information} \\blankline \\spad{X} reportInstantiations(true) \\spad{X} 1 \\spad{X} reportInstantiations(false)")) (|summary| (((|Void|)) "\\indented{1}{summary() prints a short list of useful console commands} \\blankline \\spad{X} summary()")) (|credits| (((|Void|)) "\\indented{1}{credits() prints a list of people who contributed to Axiom} \\blankline \\spad{X} credits()")) (|getAncestors| (((|Set| (|Symbol|)) (|Symbol|)) "\\indented{1}{The getAncestor(s) takes a category and returns the list of domains} \\indented{1}{that have that category as ancestors} \\blankline \\spad{X} getAncestors 'IndexedAggregate")) (|getDomains| (((|Set| (|Symbol|)) (|Symbol|)) "\\indented{1}{The getDomains(s) takes a category and returns the list of domains} \\indented{1}{that have that category} \\blankline \\spad{X} getDomains 'IndexedAggregate"))) 
NIL 
NIL 
(|ApplyUnivariateSkewPolynomial| R M P) 
((|constructor| (NIL "\\spad{ApplyUnivariateSkewPolynomial} (internal) allows univariate skew polynomials to be applied to appropriate modules.")) (|apply| ((|#2| |#3| (|Mapping| |#2| |#2|) |#2|) "\\spad{apply(p, \\spad{f,} \\spad{m)}} returns \\spad{p(m)} where the action is given by \\spad{x \\spad{m} = f(m)}. \\spad{f} must be an R-pseudo linear map on \\spad{M.}"))) 
NIL 
NIL 
(|ApplyRules| |Base| R F) 
((|constructor| (NIL "This package apply rewrite rules to expressions, calling the pattern matcher.")) (|localUnquote| ((|#3| |#3| (|List| (|Symbol|))) "\\spad{localUnquote(f,ls)} is a local function.")) (|applyRules| ((|#3| (|List| (|RewriteRule| |#1| |#2| |#3|)) |#3| (|PositiveInteger|)) "\\spad{applyRules([r1,...,rn], expr, \\spad{n)}} applies the rules r1,...,rn to \\spad{f} a most \\spad{n} times.") ((|#3| (|List| (|RewriteRule| |#1| |#2| |#3|)) |#3|) "\\spad{applyRules([r1,...,rn], expr)} applies the rules r1,...,rn to \\spad{f} an unlimited number of times, \\spadignore{i.e.} until none of r1,...,rn is applicable to the expression."))) 
NIL 
NIL 
(|TwoDimensionalArrayCategory&| S R |Row| |Col|) 
((|constructor| (NIL "Two dimensional array categories and domains")) (|map!| (($ (|Mapping| |#2| |#2|) $) "\\indented{1}{map!(f,a)\\space{2}assign \\spad{a(i,j)} to \\spad{f(a(i,j))}} \\indented{1}{for all \\spad{i, \\spad{j}}} \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} map!(-,arr)")) (|map| (($ (|Mapping| |#2| |#2| |#2|) $ $ |#2|) "\\indented{1}{map(f,a,b,r) returns \\spad{c}, where \\spad{c(i,j) = f(a(i,j),b(i,j))}} \\indented{1}{when both \\spad{a(i,j)} and \\spad{b(i,j)} exist;} \\indented{1}{else \\spad{c(i,j) = f(r, b(i,j))} when \\spad{a(i,j)} does not exist;} \\indented{1}{else \\spad{c(i,j) = f(a(i,j),r)} when \\spad{b(i,j)} does not exist;} \\indented{1}{otherwise \\spad{c(i,j) = f(r,r)}.} \\blankline \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} \\spad{arr1} : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} \\spad{arr2} : \\spad{ARRAY2} INT \\spad{:=} new(3,3,10) \\spad{X} map(adder,arr1,arr2,17)") (($ (|Mapping| |#2| |#2| |#2|) $ $) "\\indented{1}{map(f,a,b) returns \\spad{c}, where \\spad{c(i,j) = f(a(i,j),b(i,j))}} \\indented{1}{for all \\spad{i, \\spad{j}}} \\blankline \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} map(adder,arr,arr)") (($ (|Mapping| |#2| |#2|) $) "\\indented{1}{map(f,a) returns \\spad{b}, where \\spad{b(i,j) = f(a(i,j))}} \\indented{1}{for all \\spad{i, \\spad{j}}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} map(-,arr) \\spad{X} map((x \\spad{+->} \\spad{x} + x),arr)")) (|setColumn!| (($ $ (|Integer|) |#4|) "\\indented{1}{setColumn!(m,j,v) sets to \\spad{j}th column of \\spad{m} to \\spad{v}} \\blankline \\spad{X} T1:=TwoDimensionalArray Integer \\spad{X} arr:T1:= new(5,4,0) \\spad{X} T2:=OneDimensionalArray Integer \\spad{X} \\spad{acol:=construct([1,2,3,4,5]::List(INT))$T2} \\spad{X} \\spad{setColumn!(arr,1,acol)$T1}")) (|setRow!| (($ $ (|Integer|) |#3|) "\\indented{1}{setRow!(m,i,v) sets to \\spad{i}th row of \\spad{m} to \\spad{v}} \\blankline \\spad{X} T1:=TwoDimensionalArray Integer \\spad{X} arr:T1:= new(5,4,0) \\spad{X} T2:=OneDimensionalArray Integer \\spad{X} \\spad{arow:=construct([1,2,3,4]::List(INT))$T2} \\spad{X} \\spad{setRow!(arr,1,arow)$T1}")) (|qsetelt!| ((|#2| $ (|Integer|) (|Integer|) |#2|) "\\indented{1}{qsetelt!(m,i,j,r) sets the element in the \\spad{i}th row and jth} \\indented{1}{column of \\spad{m} to \\spad{r}} \\indented{1}{NO error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0) \\spad{X} qsetelt!(arr,1,1,17)")) (|setelt| ((|#2| $ (|Integer|) (|Integer|) |#2|) "\\indented{1}{setelt(m,i,j,r) sets the element in the \\spad{i}th row and jth} \\indented{1}{column of \\spad{m} to \\spad{r}} \\indented{1}{error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0) \\spad{X} setelt(arr,1,1,17)")) (|parts| (((|List| |#2|) $) "\\indented{1}{parts(m) returns a list of the elements of \\spad{m} in row major order} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} parts(arr)")) (|column| ((|#4| $ (|Integer|)) "\\indented{1}{column(m,j) returns the \\spad{j}th column of \\spad{m}} \\indented{1}{error check to determine if index is in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} column(arr,1)")) (|row| ((|#3| $ (|Integer|)) "\\indented{1}{row(m,i) returns the \\spad{i}th row of \\spad{m}} \\indented{1}{error check to determine if index is in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} row(arr,1)")) (|qelt| ((|#2| $ (|Integer|) (|Integer|)) "\\indented{1}{qelt(m,i,j) returns the element in the \\spad{i}th row and jth} \\indented{1}{column of the array \\spad{m}} \\indented{1}{NO error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} qelt(arr,1,1)")) (|elt| ((|#2| $ (|Integer|) (|Integer|) |#2|) "\\indented{1}{elt(m,i,j,r) returns the element in the \\spad{i}th row and jth} \\indented{1}{column of the array \\spad{m,} if \\spad{m} has an \\spad{i}th row and a \\spad{j}th column,} \\indented{1}{and returns \\spad{r} otherwise} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} elt(arr,1,1,6) \\spad{X} elt(arr,1,10,6)") ((|#2| $ (|Integer|) (|Integer|)) "\\indented{1}{elt(m,i,j) returns the element in the \\spad{i}th row and jth} \\indented{1}{column of the array \\spad{m}} \\indented{1}{error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} elt(arr,1,1)")) (|ncols| (((|NonNegativeInteger|) $) "\\indented{1}{ncols(m) returns the number of columns in the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} ncols(arr)")) (|nrows| (((|NonNegativeInteger|) $) "\\indented{1}{nrows(m) returns the number of rows in the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} nrows(arr)")) (|maxColIndex| (((|Integer|) $) "\\indented{1}{maxColIndex(m) returns the index of the 'last' column of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} maxColIndex(arr)")) (|minColIndex| (((|Integer|) $) "\\indented{1}{minColIndex(m) returns the index of the 'first' column of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} minColIndex(arr)")) (|maxRowIndex| (((|Integer|) $) "\\indented{1}{maxRowIndex(m) returns the index of the 'last' row of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} maxRowIndex(arr)")) (|minRowIndex| (((|Integer|) $) "\\indented{1}{minRowIndex(m) returns the index of the 'first' row of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} minRowIndex(arr)")) (|fill!| (($ $ |#2|) "\\indented{1}{fill!(m,r) fills \\spad{m} with r's} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0) \\spad{X} fill!(arr,10)")) (|new| (($ (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|) "\\indented{1}{new(m,n,r) is an m-by-n array all of whose entries are \\spad{r}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0)")) (|finiteAggregate| ((|attribute|) "two-dimensional arrays are finite")) (|shallowlyMutable| ((|attribute|) "one may destructively alter arrays"))) 
NIL 
NIL 
(|TwoDimensionalArrayCategory| R |Row| |Col|) 
((|constructor| (NIL "Two dimensional array categories and domains")) (|map!| (($ (|Mapping| |#1| |#1|) $) "\\indented{1}{map!(f,a)\\space{2}assign \\spad{a(i,j)} to \\spad{f(a(i,j))}} \\indented{1}{for all \\spad{i, \\spad{j}}} \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} map!(-,arr)")) (|map| (($ (|Mapping| |#1| |#1| |#1|) $ $ |#1|) "\\indented{1}{map(f,a,b,r) returns \\spad{c}, where \\spad{c(i,j) = f(a(i,j),b(i,j))}} \\indented{1}{when both \\spad{a(i,j)} and \\spad{b(i,j)} exist;} \\indented{1}{else \\spad{c(i,j) = f(r, b(i,j))} when \\spad{a(i,j)} does not exist;} \\indented{1}{else \\spad{c(i,j) = f(a(i,j),r)} when \\spad{b(i,j)} does not exist;} \\indented{1}{otherwise \\spad{c(i,j) = f(r,r)}.} \\blankline \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} \\spad{arr1} : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} \\spad{arr2} : \\spad{ARRAY2} INT \\spad{:=} new(3,3,10) \\spad{X} map(adder,arr1,arr2,17)") (($ (|Mapping| |#1| |#1| |#1|) $ $) "\\indented{1}{map(f,a,b) returns \\spad{c}, where \\spad{c(i,j) = f(a(i,j),b(i,j))}} \\indented{1}{for all \\spad{i, \\spad{j}}} \\blankline \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} map(adder,arr,arr)") (($ (|Mapping| |#1| |#1|) $) "\\indented{1}{map(f,a) returns \\spad{b}, where \\spad{b(i,j) = f(a(i,j))}} \\indented{1}{for all \\spad{i, \\spad{j}}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} map(-,arr) \\spad{X} map((x \\spad{+->} \\spad{x} + x),arr)")) (|setColumn!| (($ $ (|Integer|) |#3|) "\\indented{1}{setColumn!(m,j,v) sets to \\spad{j}th column of \\spad{m} to \\spad{v}} \\blankline \\spad{X} T1:=TwoDimensionalArray Integer \\spad{X} arr:T1:= new(5,4,0) \\spad{X} T2:=OneDimensionalArray Integer \\spad{X} \\spad{acol:=construct([1,2,3,4,5]::List(INT))$T2} \\spad{X} \\spad{setColumn!(arr,1,acol)$T1}")) (|setRow!| (($ $ (|Integer|) |#2|) "\\indented{1}{setRow!(m,i,v) sets to \\spad{i}th row of \\spad{m} to \\spad{v}} \\blankline \\spad{X} T1:=TwoDimensionalArray Integer \\spad{X} arr:T1:= new(5,4,0) \\spad{X} T2:=OneDimensionalArray Integer \\spad{X} \\spad{arow:=construct([1,2,3,4]::List(INT))$T2} \\spad{X} \\spad{setRow!(arr,1,arow)$T1}")) (|qsetelt!| ((|#1| $ (|Integer|) (|Integer|) |#1|) "\\indented{1}{qsetelt!(m,i,j,r) sets the element in the \\spad{i}th row and jth} \\indented{1}{column of \\spad{m} to \\spad{r}} \\indented{1}{NO error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0) \\spad{X} qsetelt!(arr,1,1,17)")) (|setelt| ((|#1| $ (|Integer|) (|Integer|) |#1|) "\\indented{1}{setelt(m,i,j,r) sets the element in the \\spad{i}th row and jth} \\indented{1}{column of \\spad{m} to \\spad{r}} \\indented{1}{error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0) \\spad{X} setelt(arr,1,1,17)")) (|parts| (((|List| |#1|) $) "\\indented{1}{parts(m) returns a list of the elements of \\spad{m} in row major order} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} parts(arr)")) (|column| ((|#3| $ (|Integer|)) "\\indented{1}{column(m,j) returns the \\spad{j}th column of \\spad{m}} \\indented{1}{error check to determine if index is in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} column(arr,1)")) (|row| ((|#2| $ (|Integer|)) "\\indented{1}{row(m,i) returns the \\spad{i}th row of \\spad{m}} \\indented{1}{error check to determine if index is in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} row(arr,1)")) (|qelt| ((|#1| $ (|Integer|) (|Integer|)) "\\indented{1}{qelt(m,i,j) returns the element in the \\spad{i}th row and jth} \\indented{1}{column of the array \\spad{m}} \\indented{1}{NO error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} qelt(arr,1,1)")) (|elt| ((|#1| $ (|Integer|) (|Integer|) |#1|) "\\indented{1}{elt(m,i,j,r) returns the element in the \\spad{i}th row and jth} \\indented{1}{column of the array \\spad{m,} if \\spad{m} has an \\spad{i}th row and a \\spad{j}th column,} \\indented{1}{and returns \\spad{r} otherwise} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} elt(arr,1,1,6) \\spad{X} elt(arr,1,10,6)") ((|#1| $ (|Integer|) (|Integer|)) "\\indented{1}{elt(m,i,j) returns the element in the \\spad{i}th row and jth} \\indented{1}{column of the array \\spad{m}} \\indented{1}{error check to determine if indices are in proper ranges} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} elt(arr,1,1)")) (|ncols| (((|NonNegativeInteger|) $) "\\indented{1}{ncols(m) returns the number of columns in the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} ncols(arr)")) (|nrows| (((|NonNegativeInteger|) $) "\\indented{1}{nrows(m) returns the number of rows in the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} nrows(arr)")) (|maxColIndex| (((|Integer|) $) "\\indented{1}{maxColIndex(m) returns the index of the 'last' column of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} maxColIndex(arr)")) (|minColIndex| (((|Integer|) $) "\\indented{1}{minColIndex(m) returns the index of the 'first' column of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} minColIndex(arr)")) (|maxRowIndex| (((|Integer|) $) "\\indented{1}{maxRowIndex(m) returns the index of the 'last' row of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} maxRowIndex(arr)")) (|minRowIndex| (((|Integer|) $) "\\indented{1}{minRowIndex(m) returns the index of the 'first' row of the array \\spad{m}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,10) \\spad{X} minRowIndex(arr)")) (|fill!| (($ $ |#1|) "\\indented{1}{fill!(m,r) fills \\spad{m} with r's} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0) \\spad{X} fill!(arr,10)")) (|new| (($ (|NonNegativeInteger|) (|NonNegativeInteger|) |#1|) "\\indented{1}{new(m,n,r) is an m-by-n array all of whose entries are \\spad{r}} \\blankline \\spad{X} arr : \\spad{ARRAY2} INT \\spad{:=} new(5,4,0)")) (|finiteAggregate| ((|attribute|) "two-dimensional arrays are finite")) (|shallowlyMutable| ((|attribute|) "one may destructively alter arrays"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|OneDimensionalArrayFunctions2| A B) 
((|constructor| (NIL "This package provides tools for operating on one-dimensional arrays with unary and binary functions involving different underlying types")) (|map| (((|OneDimensionalArray| |#2|) (|Mapping| |#2| |#1|) (|OneDimensionalArray| |#1|)) "\\indented{1}{map(f,a) applies function \\spad{f} to each member of one-dimensional array} \\indented{1}{\\spad{a} resulting in a new one-dimensional array over a} \\indented{1}{possibly different underlying domain.} \\blankline \\spad{X} T1:=OneDimensionalArrayFunctions2(Integer,Integer) \\spad{X} map(x+->x+2,[i for \\spad{i} in 1..10])$T1")) (|reduce| ((|#2| (|Mapping| |#2| |#1| |#2|) (|OneDimensionalArray| |#1|) |#2|) "\\indented{1}{reduce(f,a,r) applies function \\spad{f} to each} \\indented{1}{successive element of the} \\indented{1}{one-dimensional array \\spad{a} and an accumulant initialized to \\spad{r.}} \\indented{1}{For example, \\spad{reduce(_+$Integer,[1,2,3],0)}} \\indented{1}{does \\spad{3+(2+(1+0))}. Note that third argument \\spad{r}} \\indented{1}{may be regarded as the identity element for the function \\spad{f.}} \\blankline \\spad{X} T1:=OneDimensionalArrayFunctions2(Integer,Integer) \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} reduce(adder,[i for \\spad{i} in 1..10],0)$T1")) (|scan| (((|OneDimensionalArray| |#2|) (|Mapping| |#2| |#1| |#2|) (|OneDimensionalArray| |#1|) |#2|) "\\indented{1}{scan(f,a,r) successively applies} \\indented{1}{\\spad{reduce(f,x,r)} to more and more leading sub-arrays} \\indented{1}{x of one-dimensional array \\spad{a}.} \\indented{1}{More precisely, if \\spad{a} is \\spad{[a1,a2,...]}, then} \\indented{1}{\\spad{scan(f,a,r)} returns} \\indented{1}{\\spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.} \\blankline \\spad{X} T1:=OneDimensionalArrayFunctions2(Integer,Integer) \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} scan(adder,[i for \\spad{i} in 1..10],0)$T1"))) 
NIL 
NIL 
(|OneDimensionalArray| S) 
((|constructor| (NIL "This is the domain of 1-based one dimensional arrays")) (|oneDimensionalArray| (($ (|NonNegativeInteger|) |#1|) "\\indented{1}{oneDimensionalArray(n,s) creates an array from \\spad{n} copies of element \\spad{s}} \\blankline \\spad{X} oneDimensionalArray(10,0.0)") (($ (|List| |#1|)) "\\indented{1}{oneDimensionalArray(l) creates an array from a list of elements \\spad{l}} \\blankline \\spad{X} oneDimensionalArray \\spad{[i**2} for \\spad{i} in 1..10]"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|TwoDimensionalArray| R) 
((|constructor| (NIL "A TwoDimensionalArray is a two dimensional array with 1-based indexing for both rows and columns.")) (|shallowlyMutable| ((|attribute|) "One may destructively alter TwoDimensionalArray's."))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|Asp10| |name|) 
((|constructor| (NIL "\\spadtype{ASP10} produces Fortran for Type 10 ASPs, needed for NAG routine d02kef. This ASP computes the values of a set of functions, for example: \\blankline \\tab{5}SUBROUTINE COEFFN(P,Q,DQDL,X,ELAM,JINT)\\br \\tab{5}DOUBLE PRECISION ELAM,P,Q,X,DQDL\\br \\tab{5}INTEGER JINT\\br \\tab{5}P=1.0D0\\br \\tab{5}Q=((-1.0D0*X**3)+ELAM*X*X-2.0D0)/(X*X)\\br \\tab{5}DQDL=1.0D0\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|Vector| (|FortranExpression| (|construct| (QUOTE JINT) (QUOTE X) (QUOTE ELAM)) (|construct|) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp12| |name|) 
((|constructor| (NIL "\\spadtype{Asp12} produces Fortran for Type 12 ASPs, needed for NAG routine d02kef etc., for example: \\blankline \\tab{5}SUBROUTINE MONIT (MAXIT,IFLAG,ELAM,FINFO)\\br \\tab{5}DOUBLE PRECISION ELAM,FINFO(15)\\br \\tab{5}INTEGER MAXIT,IFLAG\\br \\tab{5}IF(MAXIT.EQ.-1)THEN\\br \\tab{7}PRINT*,\"Output from Monit\"\\br \\tab{5}ENDIF\\br \\tab{5}PRINT*,MAXIT,IFLAG,ELAM,(FINFO(I),I=1,4)\\br \\tab{5}RETURN\\br \\tab{5}END\\")) (|outputAsFortran| (((|Void|)) "\\spad{outputAsFortran()} generates the default code for \\spadtype{ASP12}."))) 
NIL 
NIL 
(|Asp19| |name|) 
((|constructor| (NIL "\\spadtype{Asp19} produces Fortran for Type 19 ASPs, evaluating a set of functions and their jacobian at a given point, for example: \\blankline \\tab{5}SUBROUTINE LSFUN2(M,N,XC,FVECC,FJACC,LJC)\\br \\tab{5}DOUBLE PRECISION FVECC(M),FJACC(LJC,N),XC(N)\\br \\tab{5}INTEGER M,N,LJC\\br \\tab{5}INTEGER I,J\\br \\tab{5}DO 25003 I=1,LJC\\br \\tab{7}DO 25004 J=1,N\\br \\tab{9}FJACC(I,J)=0.0D0\\br 25004 CONTINUE\\br 25003 CONTINUE\\br \\tab{5}FVECC(1)=((XC(1)-0.14D0)*XC(3)+(15.0D0*XC(1)-2.1D0)*XC(2)+1.0D0)/(\\br \\tab{4}&XC(3)+15.0D0*XC(2))\\br \\tab{5}FVECC(2)=((XC(1)-0.18D0)*XC(3)+(7.0D0*XC(1)-1.26D0)*XC(2)+1.0D0)/(\\br \\tab{4}&XC(3)+7.0D0*XC(2))\\br \\tab{5}FVECC(3)=((XC(1)-0.22D0)*XC(3)+(4.333333333333333D0*XC(1)-0.953333\\br \\tab{4}&3333333333D0)*XC(2)+1.0D0)/(XC(3)+4.333333333333333D0*XC(2))\\br \\tab{5}FVECC(4)=((XC(1)-0.25D0)*XC(3)+(3.0D0*XC(1)-0.75D0)*XC(2)+1.0D0)/(\\br \\tab{4}&XC(3)+3.0D0*XC(2))\\br \\tab{5}FVECC(5)=((XC(1)-0.29D0)*XC(3)+(2.2D0*XC(1)-0.6379999999999999D0)*\\br \\tab{4}&XC(2)+1.0D0)/(XC(3)+2.2D0*XC(2))\\br \\tab{5}FVECC(6)=((XC(1)-0.32D0)*XC(3)+(1.666666666666667D0*XC(1)-0.533333\\br \\tab{4}&3333333333D0)*XC(2)+1.0D0)/(XC(3)+1.666666666666667D0*XC(2))\\br \\tab{5}FVECC(7)=((XC(1)-0.35D0)*XC(3)+(1.285714285714286D0*XC(1)-0.45D0)*\\br \\tab{4}&XC(2)+1.0D0)/(XC(3)+1.285714285714286D0*XC(2))\\br \\tab{5}FVECC(8)=((XC(1)-0.39D0)*XC(3)+(XC(1)-0.39D0)*XC(2)+1.0D0)/(XC(3)+\\br \\tab{4}&XC(2))\\br \\tab{5}FVECC(9)=((XC(1)-0.37D0)*XC(3)+(XC(1)-0.37D0)*XC(2)+1.285714285714\\br \\tab{4}&286D0)/(XC(3)+XC(2))\\br \\tab{5}FVECC(10)=((XC(1)-0.58D0)*XC(3)+(XC(1)-0.58D0)*XC(2)+1.66666666666\\br \\tab{4}&6667D0)/(XC(3)+XC(2))\\br \\tab{5}FVECC(11)=((XC(1)-0.73D0)*XC(3)+(XC(1)-0.73D0)*XC(2)+2.2D0)/(XC(3)\\br \\tab{4}&+XC(2))\\br \\tab{5}FVECC(12)=((XC(1)-0.96D0)*XC(3)+(XC(1)-0.96D0)*XC(2)+3.0D0)/(XC(3)\\br \\tab{4}&+XC(2))\\br \\tab{5}FVECC(13)=((XC(1)-1.34D0)*XC(3)+(XC(1)-1.34D0)*XC(2)+4.33333333333\\br \\tab{4}&3333D0)/(XC(3)+XC(2))\\br \\tab{5}FVECC(14)=((XC(1)-2.1D0)*XC(3)+(XC(1)-2.1D0)*XC(2)+7.0D0)/(XC(3)+X\\br \\tab{4}&C(2))\\br \\tab{5}FVECC(15)=((XC(1)-4.39D0)*XC(3)+(XC(1)-4.39D0)*XC(2)+15.0D0)/(XC(3\\br \\tab{4}&)+XC(2))\\br \\tab{5}FJACC(1,1)=1.0D0\\br \\tab{5}FJACC(1,2)=-15.0D0/(XC(3)**2+30.0D0*XC(2)*XC(3)+225.0D0*XC(2)**2)\\br \\tab{5}FJACC(1,3)=-1.0D0/(XC(3)**2+30.0D0*XC(2)*XC(3)+225.0D0*XC(2)**2)\\br \\tab{5}FJACC(2,1)=1.0D0\\br \\tab{5}FJACC(2,2)=-7.0D0/(XC(3)**2+14.0D0*XC(2)*XC(3)+49.0D0*XC(2)**2)\\br \\tab{5}FJACC(2,3)=-1.0D0/(XC(3)**2+14.0D0*XC(2)*XC(3)+49.0D0*XC(2)**2)\\br \\tab{5}FJACC(3,1)=1.0D0\\br \\tab{5}FJACC(3,2)=((-0.1110223024625157D-15*XC(3))-4.333333333333333D0)/(\\br \\tab{4}&XC(3)**2+8.666666666666666D0*XC(2)*XC(3)+18.77777777777778D0*XC(2)\\br \\tab{4}&**2)\\br \\tab{5}FJACC(3,3)=(0.1110223024625157D-15*XC(2)-1.0D0)/(XC(3)**2+8.666666\\br \\tab{4}&666666666D0*XC(2)*XC(3)+18.77777777777778D0*XC(2)**2)\\br \\tab{5}FJACC(4,1)=1.0D0\\br \\tab{5}FJACC(4,2)=-3.0D0/(XC(3)**2+6.0D0*XC(2)*XC(3)+9.0D0*XC(2)**2)\\br \\tab{5}FJACC(4,3)=-1.0D0/(XC(3)**2+6.0D0*XC(2)*XC(3)+9.0D0*XC(2)**2)\\br \\tab{5}FJACC(5,1)=1.0D0\\br \\tab{5}FJACC(5,2)=((-0.1110223024625157D-15*XC(3))-2.2D0)/(XC(3)**2+4.399\\br \\tab{4}&999999999999D0*XC(2)*XC(3)+4.839999999999998D0*XC(2)**2)\\br \\tab{5}FJACC(5,3)=(0.1110223024625157D-15*XC(2)-1.0D0)/(XC(3)**2+4.399999\\br \\tab{4}&999999999D0*XC(2)*XC(3)+4.839999999999998D0*XC(2)**2)\\br \\tab{5}FJACC(6,1)=1.0D0\\br \\tab{5}FJACC(6,2)=((-0.2220446049250313D-15*XC(3))-1.666666666666667D0)/(\\br \\tab{4}&XC(3)**2+3.333333333333333D0*XC(2)*XC(3)+2.777777777777777D0*XC(2)\\br \\tab{4}&**2)\\br \\tab{5}FJACC(6,3)=(0.2220446049250313D-15*XC(2)-1.0D0)/(XC(3)**2+3.333333\\br \\tab{4}&333333333D0*XC(2)*XC(3)+2.777777777777777D0*XC(2)**2)\\br \\tab{5}FJACC(7,1)=1.0D0\\br \\tab{5}FJACC(7,2)=((-0.5551115123125783D-16*XC(3))-1.285714285714286D0)/(\\br \\tab{4}&XC(3)**2+2.571428571428571D0*XC(2)*XC(3)+1.653061224489796D0*XC(2)\\br \\tab{4}&**2)\\br \\tab{5}FJACC(7,3)=(0.5551115123125783D-16*XC(2)-1.0D0)/(XC(3)**2+2.571428\\br \\tab{4}&571428571D0*XC(2)*XC(3)+1.653061224489796D0*XC(2)**2)\\br \\tab{5}FJACC(8,1)=1.0D0\\br \\tab{5}FJACC(8,2)=-1.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)\\br \\tab{5}FJACC(8,3)=-1.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)\\br \\tab{5}FJACC(9,1)=1.0D0\\br \\tab{5}FJACC(9,2)=-1.285714285714286D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)*\\br \\tab{4}&*2)\\br \\tab{5}FJACC(9,3)=-1.285714285714286D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)*\\br \\tab{4}&*2)\\br \\tab{5}FJACC(10,1)=1.0D0\\br \\tab{5}FJACC(10,2)=-1.666666666666667D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)\\br \\tab{4}&**2)\\br \\tab{5}FJACC(10,3)=-1.666666666666667D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)\\br \\tab{4}&**2)\\br \\tab{5}FJACC(11,1)=1.0D0\\br \\tab{5}FJACC(11,2)=-2.2D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)\\br \\tab{5}FJACC(11,3)=-2.2D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)\\br \\tab{5}FJACC(12,1)=1.0D0\\br \\tab{5}FJACC(12,2)=-3.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)\\br \\tab{5}FJACC(12,3)=-3.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)\\br \\tab{5}FJACC(13,1)=1.0D0\\br \\tab{5}FJACC(13,2)=-4.333333333333333D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)\\br \\tab{4}&**2)\\br \\tab{5}FJACC(13,3)=-4.333333333333333D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)\\br \\tab{4}&**2)\\br \\tab{5}FJACC(14,1)=1.0D0\\br \\tab{5}FJACC(14,2)=-7.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)\\br \\tab{5}FJACC(14,3)=-7.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)\\br \\tab{5}FJACC(15,1)=1.0D0\\br \\tab{5}FJACC(15,2)=-15.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)\\br \\tab{5}FJACC(15,3)=-15.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|Vector| (|FortranExpression| (|construct|) (|construct| (QUOTE XC)) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp1| |name|) 
((|constructor| (NIL "\\spadtype{Asp1} produces Fortran for Type 1 ASPs, needed for various NAG routines. Type 1 ASPs take a univariate expression (in the symbol \\spad{x)} and turn it into a Fortran Function like the following: \\blankline \\tab{5}DOUBLE PRECISION FUNCTION F(X)\\br \\tab{5}DOUBLE PRECISION X\\br \\tab{5}F=DSIN(X)\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|FortranExpression| (|construct| (QUOTE X)) (|construct|) (|MachineFloat|))) "\\spad{coerce(f)} takes an object from the appropriate instantiation of \\spadtype{FortranExpression} and turns it into an ASP."))) 
NIL 
NIL 
(|Asp20| |name|) 
((|constructor| (NIL "\\spadtype{Asp20} produces Fortran for Type 20 ASPs, for example: \\blankline \\tab{5}SUBROUTINE QPHESS(N,NROWH,NCOLH,JTHCOL,HESS,X,HX)\\br \\tab{5}DOUBLE PRECISION HX(N),X(N),HESS(NROWH,NCOLH)\\br \\tab{5}INTEGER JTHCOL,N,NROWH,NCOLH\\br \\tab{5}HX(1)=2.0D0*X(1)\\br \\tab{5}HX(2)=2.0D0*X(2)\\br \\tab{5}HX(3)=2.0D0*X(4)+2.0D0*X(3)\\br \\tab{5}HX(4)=2.0D0*X(4)+2.0D0*X(3)\\br \\tab{5}HX(5)=2.0D0*X(5)\\br \\tab{5}HX(6)=(-2.0D0*X(7))+(-2.0D0*X(6))\\br \\tab{5}HX(7)=(-2.0D0*X(7))+(-2.0D0*X(6))\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|Matrix| (|FortranExpression| (|construct|) (|construct| (QUOTE X) (QUOTE HESS)) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp24| |name|) 
((|constructor| (NIL "\\spadtype{Asp24} produces Fortran for Type 24 ASPs which evaluate a multivariate function at a point (needed for NAG routine e04jaf), for example: \\blankline \\tab{5}SUBROUTINE FUNCT1(N,XC,FC)\\br \\tab{5}DOUBLE PRECISION FC,XC(N)\\br \\tab{5}INTEGER N\\br \\tab{5}FC=10.0D0*XC(4)**4+(-40.0D0*XC(1)*XC(4)**3)+(60.0D0*XC(1)**2+5\\br \\tab{4}&.0D0)*XC(4)**2+((-10.0D0*XC(3))+(-40.0D0*XC(1)**3))*XC(4)+16.0D0*X\\br \\tab{4}&C(3)**4+(-32.0D0*XC(2)*XC(3)**3)+(24.0D0*XC(2)**2+5.0D0)*XC(3)**2+\\br \\tab{4}&(-8.0D0*XC(2)**3*XC(3))+XC(2)**4+100.0D0*XC(2)**2+20.0D0*XC(1)*XC(\\br \\tab{4}&2)+10.0D0*XC(1)**4+XC(1)**2\\br \\tab{5}RETURN\\br \\tab{5}END\\br")) (|coerce| (($ (|FortranExpression| (|construct|) (|construct| (QUOTE XC)) (|MachineFloat|))) "\\spadtype{FortranExpression} and turns it into an ASP. coerce(f) takes an object from the appropriate instantiation of"))) 
NIL 
NIL 
(|Asp27| |name|) 
((|constructor| (NIL "\\spadtype{Asp27} produces Fortran for Type 27 ASPs, needed for NAG routine f02fjf ,for example: \\blankline \\tab{5}FUNCTION DOT(IFLAG,N,Z,W,RWORK,LRWORK,IWORK,LIWORK)\\br \\tab{5}DOUBLE PRECISION W(N),Z(N),RWORK(LRWORK)\\br \\tab{5}INTEGER N,LIWORK,IFLAG,LRWORK,IWORK(LIWORK)\\br \\tab{5}DOT=(W(16)+(-0.5D0*W(15)))*Z(16)+((-0.5D0*W(16))+W(15)+(-0.5D0*W(1\\br \\tab{4}&4)))*Z(15)+((-0.5D0*W(15))+W(14)+(-0.5D0*W(13)))*Z(14)+((-0.5D0*W(\\br \\tab{4}&14))+W(13)+(-0.5D0*W(12)))*Z(13)+((-0.5D0*W(13))+W(12)+(-0.5D0*W(1\\br \\tab{4}&1)))*Z(12)+((-0.5D0*W(12))+W(11)+(-0.5D0*W(10)))*Z(11)+((-0.5D0*W(\\br \\tab{4}&11))+W(10)+(-0.5D0*W(9)))*Z(10)+((-0.5D0*W(10))+W(9)+(-0.5D0*W(8))\\br \\tab{4}&)*Z(9)+((-0.5D0*W(9))+W(8)+(-0.5D0*W(7)))*Z(8)+((-0.5D0*W(8))+W(7)\\br \\tab{4}&+(-0.5D0*W(6)))*Z(7)+((-0.5D0*W(7))+W(6)+(-0.5D0*W(5)))*Z(6)+((-0.\\br \\tab{4}&5D0*W(6))+W(5)+(-0.5D0*W(4)))*Z(5)+((-0.5D0*W(5))+W(4)+(-0.5D0*W(3\\br \\tab{4}&)))*Z(4)+((-0.5D0*W(4))+W(3)+(-0.5D0*W(2)))*Z(3)+((-0.5D0*W(3))+W(\\br \\tab{4}&2)+(-0.5D0*W(1)))*Z(2)+((-0.5D0*W(2))+W(1))*Z(1)\\br \\tab{5}RETURN\\br \\tab{5}END"))) 
NIL 
NIL 
(|Asp28| |name|) 
((|constructor| (NIL "\\spadtype{Asp28} produces Fortran for Type 28 ASPs, used in NAG routine f02fjf, for example: \\blankline \\tab{5}SUBROUTINE IMAGE(IFLAG,N,Z,W,RWORK,LRWORK,IWORK,LIWORK)\\br \\tab{5}DOUBLE PRECISION Z(N),W(N),IWORK(LRWORK),RWORK(LRWORK)\\br \\tab{5}INTEGER N,LIWORK,IFLAG,LRWORK\\br \\tab{5}W(1)=0.01707454969713436D0*Z(16)+0.001747395874954051D0*Z(15)+0.00\\br \\tab{4}&2106973900813502D0*Z(14)+0.002957434991769087D0*Z(13)+(-0.00700554\\br \\tab{4}&0882865317D0*Z(12))+(-0.01219194009813166D0*Z(11))+0.0037230647365\\br \\tab{4}&3087D0*Z(10)+0.04932374658377151D0*Z(9)+(-0.03586220812223305D0*Z(\\br \\tab{4}&8))+(-0.04723268012114625D0*Z(7))+(-0.02434652144032987D0*Z(6))+0.\\br \\tab{4}&2264766947290192D0*Z(5)+(-0.1385343580686922D0*Z(4))+(-0.116530050\\br \\tab{4}&8238904D0*Z(3))+(-0.2803531651057233D0*Z(2))+1.019463911841327D0*Z\\br \\tab{4}&(1)\\br \\tab{5}W(2)=0.0227345011107737D0*Z(16)+0.008812321197398072D0*Z(15)+0.010\\br \\tab{4}&94012210519586D0*Z(14)+(-0.01764072463999744D0*Z(13))+(-0.01357136\\br \\tab{4}&72105995D0*Z(12))+0.00157466157362272D0*Z(11)+0.05258889186338282D\\br \\tab{4}&0*Z(10)+(-0.01981532388243379D0*Z(9))+(-0.06095390688679697D0*Z(8)\\br \\tab{4}&)+(-0.04153119955569051D0*Z(7))+0.2176561076571465D0*Z(6)+(-0.0532\\br \\tab{4}&5555586632358D0*Z(5))+(-0.1688977368984641D0*Z(4))+(-0.32440166056\\br \\tab{4}&67343D0*Z(3))+0.9128222941872173D0*Z(2)+(-0.2419652703415429D0*Z(1\\br \\tab{4}&))\\br \\tab{5}W(3)=0.03371198197190302D0*Z(16)+0.02021603150122265D0*Z(15)+(-0.0\\br \\tab{4}&06607305534689702D0*Z(14))+(-0.03032392238968179D0*Z(13))+0.002033\\br \\tab{4}&305231024948D0*Z(12)+0.05375944956767728D0*Z(11)+(-0.0163213312502\\br \\tab{4}&9967D0*Z(10))+(-0.05483186562035512D0*Z(9))+(-0.04901428822579872D\\br \\tab{4}&0*Z(8))+0.2091097927887612D0*Z(7)+(-0.05760560341383113D0*Z(6))+(-\\br \\tab{4}&0.1236679206156403D0*Z(5))+(-0.3523683853026259D0*Z(4))+0.88929961\\br \\tab{4}&32269974D0*Z(3)+(-0.2995429545781457D0*Z(2))+(-0.02986582812574917\\br \\tab{4}&D0*Z(1))\\br \\tab{5}W(4)=0.05141563713660119D0*Z(16)+0.005239165960779299D0*Z(15)+(-0.\\br \\tab{4}&01623427735779699D0*Z(14))+(-0.01965809746040371D0*Z(13))+0.054688\\br \\tab{4}&97337339577D0*Z(12)+(-0.014224695935687D0*Z(11))+(-0.0505181779315\\br \\tab{4}&6355D0*Z(10))+(-0.04353074206076491D0*Z(9))+0.2012230497530726D0*Z\\br \\tab{4}&(8)+(-0.06630874514535952D0*Z(7))+(-0.1280829963720053D0*Z(6))+(-0\\br \\tab{4}&.305169742604165D0*Z(5))+0.8600427128450191D0*Z(4)+(-0.32415033802\\br \\tab{4}&68184D0*Z(3))+(-0.09033531980693314D0*Z(2))+0.09089205517109111D0*\\br \\tab{4}&Z(1)\\br \\tab{5}W(5)=0.04556369767776375D0*Z(16)+(-0.001822737697581869D0*Z(15))+(\\br \\tab{4}&-0.002512226501941856D0*Z(14))+0.02947046460707379D0*Z(13)+(-0.014\\br \\tab{4}&45079632086177D0*Z(12))+(-0.05034242196614937D0*Z(11))+(-0.0376966\\br \\tab{4}&3291725935D0*Z(10))+0.2171103102175198D0*Z(9)+(-0.0824949256021352\\br \\tab{4}&4D0*Z(8))+(-0.1473995209288945D0*Z(7))+(-0.315042193418466D0*Z(6))\\br \\tab{4}&+0.9591623347824002D0*Z(5)+(-0.3852396953763045D0*Z(4))+(-0.141718\\br \\tab{4}&5427288274D0*Z(3))+(-0.03423495461011043D0*Z(2))+0.319820917706851\\br \\tab{4}&6D0*Z(1)\\br \\tab{5}W(6)=0.04015147277405744D0*Z(16)+0.01328585741341559D0*Z(15)+0.048\\br \\tab{4}&26082005465965D0*Z(14)+(-0.04319641116207706D0*Z(13))+(-0.04931323\\br \\tab{4}&319055762D0*Z(12))+(-0.03526886317505474D0*Z(11))+0.22295383396730\\br \\tab{4}&01D0*Z(10)+(-0.07375317649315155D0*Z(9))+(-0.1589391311991561D0*Z(\\br \\tab{4}&8))+(-0.328001910890377D0*Z(7))+0.952576555482747D0*Z(6)+(-0.31583\\br \\tab{4}&09975786731D0*Z(5))+(-0.1846882042225383D0*Z(4))+(-0.0703762046700\\br \\tab{4}&4427D0*Z(3))+0.2311852964327382D0*Z(2)+0.04254083491825025D0*Z(1)\\br \\tab{5}W(7)=0.06069778964023718D0*Z(16)+0.06681263884671322D0*Z(15)+(-0.0\\br \\tab{4}&2113506688615768D0*Z(14))+(-0.083996867458326D0*Z(13))+(-0.0329843\\br \\tab{4}&8523869648D0*Z(12))+0.2276878326327734D0*Z(11)+(-0.067356038933017\\br \\tab{4}&95D0*Z(10))+(-0.1559813965382218D0*Z(9))+(-0.3363262957694705D0*Z(\\br \\tab{4}&8))+0.9442791158560948D0*Z(7)+(-0.3199955249404657D0*Z(6))+(-0.136\\br \\tab{4}&2463839920727D0*Z(5))+(-0.1006185171570586D0*Z(4))+0.2057504515015\\br \\tab{4}&423D0*Z(3)+(-0.02065879269286707D0*Z(2))+0.03160990266745513D0*Z(1\\br \\tab{4}&)\\br \\tab{5}W(8)=0.126386868896738D0*Z(16)+0.002563370039476418D0*Z(15)+(-0.05\\br \\tab{4}&581757739455641D0*Z(14))+(-0.07777893205900685D0*Z(13))+0.23117338\\br \\tab{4}&45834199D0*Z(12)+(-0.06031581134427592D0*Z(11))+(-0.14805474755869\\br \\tab{4}&52D0*Z(10))+(-0.3364014128402243D0*Z(9))+0.9364014128402244D0*Z(8)\\br \\tab{4}&+(-0.3269452524413048D0*Z(7))+(-0.1396841886557241D0*Z(6))+(-0.056\\br \\tab{4}&1733845834199D0*Z(5))+0.1777789320590069D0*Z(4)+(-0.04418242260544\\br \\tab{4}&359D0*Z(3))+(-0.02756337003947642D0*Z(2))+0.07361313110326199D0*Z(\\br \\tab{4}&1)\\br \\tab{5}W(9)=0.07361313110326199D0*Z(16)+(-0.02756337003947642D0*Z(15))+(-\\br \\tab{4}&0.04418242260544359D0*Z(14))+0.1777789320590069D0*Z(13)+(-0.056173\\br \\tab{4}&3845834199D0*Z(12))+(-0.1396841886557241D0*Z(11))+(-0.326945252441\\br \\tab{4}&3048D0*Z(10))+0.9364014128402244D0*Z(9)+(-0.3364014128402243D0*Z(8\\br \\tab{4}&))+(-0.1480547475586952D0*Z(7))+(-0.06031581134427592D0*Z(6))+0.23\\br \\tab{4}&11733845834199D0*Z(5)+(-0.07777893205900685D0*Z(4))+(-0.0558175773\\br \\tab{4}&9455641D0*Z(3))+0.002563370039476418D0*Z(2)+0.126386868896738D0*Z(\\br \\tab{4}&1)\\br \\tab{5}W(10)=0.03160990266745513D0*Z(16)+(-0.02065879269286707D0*Z(15))+0\\br \\tab{4}&.2057504515015423D0*Z(14)+(-0.1006185171570586D0*Z(13))+(-0.136246\\br \\tab{4}&3839920727D0*Z(12))+(-0.3199955249404657D0*Z(11))+0.94427911585609\\br \\tab{4}&48D0*Z(10)+(-0.3363262957694705D0*Z(9))+(-0.1559813965382218D0*Z(8\\br \\tab{4}&))+(-0.06735603893301795D0*Z(7))+0.2276878326327734D0*Z(6)+(-0.032\\br \\tab{4}&98438523869648D0*Z(5))+(-0.083996867458326D0*Z(4))+(-0.02113506688\\br \\tab{4}&615768D0*Z(3))+0.06681263884671322D0*Z(2)+0.06069778964023718D0*Z(\\br \\tab{4}&1)\\br \\tab{5}W(11)=0.04254083491825025D0*Z(16)+0.2311852964327382D0*Z(15)+(-0.0\\br \\tab{4}&7037620467004427D0*Z(14))+(-0.1846882042225383D0*Z(13))+(-0.315830\\br \\tab{4}&9975786731D0*Z(12))+0.952576555482747D0*Z(11)+(-0.328001910890377D\\br \\tab{4}&0*Z(10))+(-0.1589391311991561D0*Z(9))+(-0.07375317649315155D0*Z(8)\\br \\tab{4}&)+0.2229538339673001D0*Z(7)+(-0.03526886317505474D0*Z(6))+(-0.0493\\br \\tab{4}&1323319055762D0*Z(5))+(-0.04319641116207706D0*Z(4))+0.048260820054\\br \\tab{4}&65965D0*Z(3)+0.01328585741341559D0*Z(2)+0.04015147277405744D0*Z(1)\\br \\tab{5}W(12)=0.3198209177068516D0*Z(16)+(-0.03423495461011043D0*Z(15))+(-\\br \\tab{4}&0.1417185427288274D0*Z(14))+(-0.3852396953763045D0*Z(13))+0.959162\\br \\tab{4}&3347824002D0*Z(12)+(-0.315042193418466D0*Z(11))+(-0.14739952092889\\br \\tab{4}&45D0*Z(10))+(-0.08249492560213524D0*Z(9))+0.2171103102175198D0*Z(8\\br \\tab{4}&)+(-0.03769663291725935D0*Z(7))+(-0.05034242196614937D0*Z(6))+(-0.\\br \\tab{4}&01445079632086177D0*Z(5))+0.02947046460707379D0*Z(4)+(-0.002512226\\br \\tab{4}&501941856D0*Z(3))+(-0.001822737697581869D0*Z(2))+0.045563697677763\\br \\tab{4}&75D0*Z(1)\\br \\tab{5}W(13)=0.09089205517109111D0*Z(16)+(-0.09033531980693314D0*Z(15))+(\\br \\tab{4}&-0.3241503380268184D0*Z(14))+0.8600427128450191D0*Z(13)+(-0.305169\\br \\tab{4}&742604165D0*Z(12))+(-0.1280829963720053D0*Z(11))+(-0.0663087451453\\br \\tab{4}&5952D0*Z(10))+0.2012230497530726D0*Z(9)+(-0.04353074206076491D0*Z(\\br \\tab{4}&8))+(-0.05051817793156355D0*Z(7))+(-0.014224695935687D0*Z(6))+0.05\\br \\tab{4}&468897337339577D0*Z(5)+(-0.01965809746040371D0*Z(4))+(-0.016234277\\br \\tab{4}&35779699D0*Z(3))+0.005239165960779299D0*Z(2)+0.05141563713660119D0\\br \\tab{4}&*Z(1)\\br \\tab{5}W(14)=(-0.02986582812574917D0*Z(16))+(-0.2995429545781457D0*Z(15))\\br \\tab{4}&+0.8892996132269974D0*Z(14)+(-0.3523683853026259D0*Z(13))+(-0.1236\\br \\tab{4}&679206156403D0*Z(12))+(-0.05760560341383113D0*Z(11))+0.20910979278\\br \\tab{4}&87612D0*Z(10)+(-0.04901428822579872D0*Z(9))+(-0.05483186562035512D\\br \\tab{4}&0*Z(8))+(-0.01632133125029967D0*Z(7))+0.05375944956767728D0*Z(6)+0\\br \\tab{4}&.002033305231024948D0*Z(5)+(-0.03032392238968179D0*Z(4))+(-0.00660\\br \\tab{4}&7305534689702D0*Z(3))+0.02021603150122265D0*Z(2)+0.033711981971903\\br \\tab{4}&02D0*Z(1)\\br \\tab{5}W(15)=(-0.2419652703415429D0*Z(16))+0.9128222941872173D0*Z(15)+(-0\\br \\tab{4}&.3244016605667343D0*Z(14))+(-0.1688977368984641D0*Z(13))+(-0.05325\\br \\tab{4}&555586632358D0*Z(12))+0.2176561076571465D0*Z(11)+(-0.0415311995556\\br \\tab{4}&9051D0*Z(10))+(-0.06095390688679697D0*Z(9))+(-0.01981532388243379D\\br \\tab{4}&0*Z(8))+0.05258889186338282D0*Z(7)+0.00157466157362272D0*Z(6)+(-0.\\br \\tab{4}&0135713672105995D0*Z(5))+(-0.01764072463999744D0*Z(4))+0.010940122\\br \\tab{4}&10519586D0*Z(3)+0.008812321197398072D0*Z(2)+0.0227345011107737D0*Z\\br \\tab{4}&(1)\\br \\tab{5}W(16)=1.019463911841327D0*Z(16)+(-0.2803531651057233D0*Z(15))+(-0.\\br \\tab{4}&1165300508238904D0*Z(14))+(-0.1385343580686922D0*Z(13))+0.22647669\\br \\tab{4}&47290192D0*Z(12)+(-0.02434652144032987D0*Z(11))+(-0.04723268012114\\br \\tab{4}&625D0*Z(10))+(-0.03586220812223305D0*Z(9))+0.04932374658377151D0*Z\\br \\tab{4}&(8)+0.00372306473653087D0*Z(7)+(-0.01219194009813166D0*Z(6))+(-0.0\\br \\tab{4}&07005540882865317D0*Z(5))+0.002957434991769087D0*Z(4)+0.0021069739\\br \\tab{4}&00813502D0*Z(3)+0.001747395874954051D0*Z(2)+0.01707454969713436D0*\\br \\tab{4}&Z(1)\\br \\tab{5}RETURN\\br \\tab{5}END\\br"))) 
NIL 
NIL 
(|Asp29| |name|) 
((|constructor| (NIL "\\spadtype{Asp29} produces Fortran for Type 29 ASPs, needed for NAG routine f02fjf, for example: \\blankline \\tab{5}SUBROUTINE MONIT(ISTATE,NEXTIT,NEVALS,NEVECS,K,F,D)\\br \\tab{5}DOUBLE PRECISION D(K),F(K)\\br \\tab{5}INTEGER K,NEXTIT,NEVALS,NVECS,ISTATE\\br \\tab{5}CALL F02FJZ(ISTATE,NEXTIT,NEVALS,NEVECS,K,F,D)\\br \\tab{5}RETURN\\br \\tab{5}END\\br")) (|outputAsFortran| (((|Void|)) "\\spad{outputAsFortran()} generates the default code for \\spadtype{ASP29}."))) 
NIL 
NIL 
(|Asp30| |name|) 
((|constructor| (NIL "\\spadtype{Asp30} produces Fortran for Type 30 ASPs, needed for NAG routine f04qaf, for example: \\blankline \\tab{5}SUBROUTINE APROD(MODE,M,N,X,Y,RWORK,LRWORK,IWORK,LIWORK)\\br \\tab{5}DOUBLE PRECISION X(N),Y(M),RWORK(LRWORK)\\br \\tab{5}INTEGER M,N,LIWORK,IFAIL,LRWORK,IWORK(LIWORK),MODE\\br \\tab{5}DOUBLE PRECISION A(5,5)\\br \\tab{5}EXTERNAL F06PAF\\br \\tab{5}A(1,1)=1.0D0\\br \\tab{5}A(1,2)=0.0D0\\br \\tab{5}A(1,3)=0.0D0\\br \\tab{5}A(1,4)=-1.0D0\\br \\tab{5}A(1,5)=0.0D0\\br \\tab{5}A(2,1)=0.0D0\\br \\tab{5}A(2,2)=1.0D0\\br \\tab{5}A(2,3)=0.0D0\\br \\tab{5}A(2,4)=0.0D0\\br \\tab{5}A(2,5)=-1.0D0\\br \\tab{5}A(3,1)=0.0D0\\br \\tab{5}A(3,2)=0.0D0\\br \\tab{5}A(3,3)=1.0D0\\br \\tab{5}A(3,4)=-1.0D0\\br \\tab{5}A(3,5)=0.0D0\\br \\tab{5}A(4,1)=-1.0D0\\br \\tab{5}A(4,2)=0.0D0\\br \\tab{5}A(4,3)=-1.0D0\\br \\tab{5}A(4,4)=4.0D0\\br \\tab{5}A(4,5)=-1.0D0\\br \\tab{5}A(5,1)=0.0D0\\br \\tab{5}A(5,2)=-1.0D0\\br \\tab{5}A(5,3)=0.0D0\\br \\tab{5}A(5,4)=-1.0D0\\br \\tab{5}A(5,5)=4.0D0\\br \\tab{5}IF(MODE.EQ.1)THEN\\br \\tab{7}CALL F06PAF('N',M,N,1.0D0,A,M,X,1,1.0D0,Y,1)\\br \\tab{5}ELSEIF(MODE.EQ.2)THEN\\br \\tab{7}CALL F06PAF('T',M,N,1.0D0,A,M,Y,1,1.0D0,X,1)\\br \\tab{5}ENDIF\\br \\tab{5}RETURN\\br \\tab{5}END"))) 
NIL 
NIL 
(|Asp31| |name|) 
((|constructor| (NIL "\\spadtype{Asp31} produces Fortran for Type 31 ASPs, needed for NAG routine d02ejf, for example: \\blankline \\tab{5}SUBROUTINE PEDERV(X,Y,PW)\\br \\tab{5}DOUBLE PRECISION X,Y(*)\\br \\tab{5}DOUBLE PRECISION PW(3,3)\\br \\tab{5}PW(1,1)=-0.03999999999999999D0\\br \\tab{5}PW(1,2)=10000.0D0*Y(3)\\br \\tab{5}PW(1,3)=10000.0D0*Y(2)\\br \\tab{5}PW(2,1)=0.03999999999999999D0\\br \\tab{5}PW(2,2)=(-10000.0D0*Y(3))+(-60000000.0D0*Y(2))\\br \\tab{5}PW(2,3)=-10000.0D0*Y(2)\\br \\tab{5}PW(3,1)=0.0D0\\br \\tab{5}PW(3,2)=60000000.0D0*Y(2)\\br \\tab{5}PW(3,3)=0.0D0\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|Vector| (|FortranExpression| (|construct| (QUOTE X)) (|construct| (QUOTE Y)) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp33| |name|) 
((|constructor| (NIL "\\spadtype{Asp33} produces Fortran for Type 33 ASPs, needed for NAG routine d02kef. The code is a dummy ASP: \\blankline \\tab{5}SUBROUTINE REPORT(X,V,JINT)\\br \\tab{5}DOUBLE PRECISION V(3),X\\br \\tab{5}INTEGER JINT\\br \\tab{5}RETURN\\br \\tab{5}END")) (|outputAsFortran| (((|Void|)) "\\spad{outputAsFortran()} generates the default code for \\spadtype{ASP33}."))) 
NIL 
NIL 
(|Asp34| |name|) 
((|constructor| (NIL "\\spadtype{Asp34} produces Fortran for Type 34 ASPs, needed for NAG routine f04mbf, for example: \\blankline \\tab{5}SUBROUTINE MSOLVE(IFLAG,N,X,Y,RWORK,LRWORK,IWORK,LIWORK)\\br \\tab{5}DOUBLE PRECISION RWORK(LRWORK),X(N),Y(N)\\br \\tab{5}INTEGER I,J,N,LIWORK,IFLAG,LRWORK,IWORK(LIWORK)\\br \\tab{5}DOUBLE PRECISION W1(3),W2(3),MS(3,3)\\br \\tab{5}IFLAG=-1\\br \\tab{5}MS(1,1)=2.0D0\\br \\tab{5}MS(1,2)=1.0D0\\br \\tab{5}MS(1,3)=0.0D0\\br \\tab{5}MS(2,1)=1.0D0\\br \\tab{5}MS(2,2)=2.0D0\\br \\tab{5}MS(2,3)=1.0D0\\br \\tab{5}MS(3,1)=0.0D0\\br \\tab{5}MS(3,2)=1.0D0\\br \\tab{5}MS(3,3)=2.0D0\\br \\tab{5}CALL F04ASF(MS,N,X,N,Y,W1,W2,IFLAG)\\br \\tab{5}IFLAG=-IFLAG\\br \\tab{5}RETURN\\br \\tab{5}END"))) 
NIL 
NIL 
(|Asp35| |name|) 
((|constructor| (NIL "\\spadtype{Asp35} produces Fortran for Type 35 ASPs, needed for NAG routines c05pbf, c05pcf, for example: \\blankline \\tab{5}SUBROUTINE FCN(N,X,FVEC,FJAC,LDFJAC,IFLAG)\\br \\tab{5}DOUBLE PRECISION X(N),FVEC(N),FJAC(LDFJAC,N)\\br \\tab{5}INTEGER LDFJAC,N,IFLAG\\br \\tab{5}IF(IFLAG.EQ.1)THEN\\br \\tab{7}FVEC(1)=(-1.0D0*X(2))+X(1)\\br \\tab{7}FVEC(2)=(-1.0D0*X(3))+2.0D0*X(2)\\br \\tab{7}FVEC(3)=3.0D0*X(3)\\br \\tab{5}ELSEIF(IFLAG.EQ.2)THEN\\br \\tab{7}FJAC(1,1)=1.0D0\\br \\tab{7}FJAC(1,2)=-1.0D0\\br \\tab{7}FJAC(1,3)=0.0D0\\br \\tab{7}FJAC(2,1)=0.0D0\\br \\tab{7}FJAC(2,2)=2.0D0\\br \\tab{7}FJAC(2,3)=-1.0D0\\br \\tab{7}FJAC(3,1)=0.0D0\\br \\tab{7}FJAC(3,2)=0.0D0\\br \\tab{7}FJAC(3,3)=3.0D0\\br \\tab{5}ENDIF\\br \\tab{5}END")) (|coerce| (($ (|Vector| (|FortranExpression| (|construct|) (|construct| (QUOTE X)) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp41| |nameOne| |nameTwo| |nameThree|) 
((|constructor| (NIL "\\spadtype{Asp41} produces Fortran for Type 41 ASPs, needed for NAG routines d02raf and d02saf in particular. These ASPs are in fact three Fortran routines which return a vector of functions, and their derivatives \\spad{wrt} Y(i) and also a continuation parameter EPS, for example: \\blankline \\tab{5}SUBROUTINE FCN(X,EPS,Y,F,N)\\br \\tab{5}DOUBLE PRECISION EPS,F(N),X,Y(N)\\br \\tab{5}INTEGER N\\br \\tab{5}F(1)=Y(2)\\br \\tab{5}F(2)=Y(3)\\br \\tab{5}F(3)=(-1.0D0*Y(1)*Y(3))+2.0D0*EPS*Y(2)**2+(-2.0D0*EPS)\\br \\tab{5}RETURN\\br \\tab{5}END\\br \\tab{5}SUBROUTINE JACOBF(X,EPS,Y,F,N)\\br \\tab{5}DOUBLE PRECISION EPS,F(N,N),X,Y(N)\\br \\tab{5}INTEGER N\\br \\tab{5}F(1,1)=0.0D0\\br \\tab{5}F(1,2)=1.0D0\\br \\tab{5}F(1,3)=0.0D0\\br \\tab{5}F(2,1)=0.0D0\\br \\tab{5}F(2,2)=0.0D0\\br \\tab{5}F(2,3)=1.0D0\\br \\tab{5}F(3,1)=-1.0D0*Y(3)\\br \\tab{5}F(3,2)=4.0D0*EPS*Y(2)\\br \\tab{5}F(3,3)=-1.0D0*Y(1)\\br \\tab{5}RETURN\\br \\tab{5}END\\br \\tab{5}SUBROUTINE JACEPS(X,EPS,Y,F,N)\\br \\tab{5}DOUBLE PRECISION EPS,F(N),X,Y(N)\\br \\tab{5}INTEGER N\\br \\tab{5}F(1)=0.0D0\\br \\tab{5}F(2)=0.0D0\\br \\tab{5}F(3)=2.0D0*Y(2)**2-2.0D0\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|Vector| (|FortranExpression| (|construct| (QUOTE X) (QUOTE EPS)) (|construct| (QUOTE Y)) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp42| |nameOne| |nameTwo| |nameThree|) 
((|constructor| (NIL "\\spadtype{Asp42} produces Fortran for Type 42 ASPs, needed for NAG routines d02raf and d02saf in particular. These ASPs are in fact three Fortran routines which return a vector of functions, and their derivatives \\spad{wrt} Y(i) and also a continuation parameter EPS, for example: \\blankline \\tab{5}SUBROUTINE G(EPS,YA,YB,BC,N)\\br \\tab{5}DOUBLE PRECISION EPS,YA(N),YB(N),BC(N)\\br \\tab{5}INTEGER N\\br \\tab{5}BC(1)=YA(1)\\br \\tab{5}BC(2)=YA(2)\\br \\tab{5}BC(3)=YB(2)-1.0D0\\br \\tab{5}RETURN\\br \\tab{5}END\\br \\tab{5}SUBROUTINE JACOBG(EPS,YA,YB,AJ,BJ,N)\\br \\tab{5}DOUBLE PRECISION EPS,YA(N),AJ(N,N),BJ(N,N),YB(N)\\br \\tab{5}INTEGER N\\br \\tab{5}AJ(1,1)=1.0D0\\br \\tab{5}AJ(1,2)=0.0D0\\br \\tab{5}AJ(1,3)=0.0D0\\br \\tab{5}AJ(2,1)=0.0D0\\br \\tab{5}AJ(2,2)=1.0D0\\br \\tab{5}AJ(2,3)=0.0D0\\br \\tab{5}AJ(3,1)=0.0D0\\br \\tab{5}AJ(3,2)=0.0D0\\br \\tab{5}AJ(3,3)=0.0D0\\br \\tab{5}BJ(1,1)=0.0D0\\br \\tab{5}BJ(1,2)=0.0D0\\br \\tab{5}BJ(1,3)=0.0D0\\br \\tab{5}BJ(2,1)=0.0D0\\br \\tab{5}BJ(2,2)=0.0D0\\br \\tab{5}BJ(2,3)=0.0D0\\br \\tab{5}BJ(3,1)=0.0D0\\br \\tab{5}BJ(3,2)=1.0D0\\br \\tab{5}BJ(3,3)=0.0D0\\br \\tab{5}RETURN\\br \\tab{5}END\\br \\tab{5}SUBROUTINE JACGEP(EPS,YA,YB,BCEP,N)\\br \\tab{5}DOUBLE PRECISION EPS,YA(N),YB(N),BCEP(N)\\br \\tab{5}INTEGER N\\br \\tab{5}BCEP(1)=0.0D0\\br \\tab{5}BCEP(2)=0.0D0\\br \\tab{5}BCEP(3)=0.0D0\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|Vector| (|FortranExpression| (|construct| (QUOTE EPS)) (|construct| (QUOTE YA) (QUOTE YB)) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp49| |name|) 
((|constructor| (NIL "\\spadtype{Asp49} produces Fortran for Type 49 ASPs, needed for NAG routines e04dgf, e04ucf, for example: \\blankline \\tab{5}SUBROUTINE OBJFUN(MODE,N,X,OBJF,OBJGRD,NSTATE,IUSER,USER)\\br \\tab{5}DOUBLE PRECISION X(N),OBJF,OBJGRD(N),USER(*)\\br \\tab{5}INTEGER N,IUSER(*),MODE,NSTATE\\br \\tab{5}OBJF=X(4)*X(9)+((-1.0D0*X(5))+X(3))*X(8)+((-1.0D0*X(3))+X(1))*X(7)\\br \\tab{4}&+(-1.0D0*X(2)*X(6))\\br \\tab{5}OBJGRD(1)=X(7)\\br \\tab{5}OBJGRD(2)=-1.0D0*X(6)\\br \\tab{5}OBJGRD(3)=X(8)+(-1.0D0*X(7))\\br \\tab{5}OBJGRD(4)=X(9)\\br \\tab{5}OBJGRD(5)=-1.0D0*X(8)\\br \\tab{5}OBJGRD(6)=-1.0D0*X(2)\\br \\tab{5}OBJGRD(7)=(-1.0D0*X(3))+X(1)\\br \\tab{5}OBJGRD(8)=(-1.0D0*X(5))+X(3)\\br \\tab{5}OBJGRD(9)=X(4)\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|FortranExpression| (|construct|) (|construct| (QUOTE X)) (|MachineFloat|))) "\\spad{coerce(f)} takes an object from the appropriate instantiation of \\spadtype{FortranExpression} and turns it into an ASP."))) 
NIL 
NIL 
(|Asp4| |name|) 
((|constructor| (NIL "\\spadtype{Asp4} produces Fortran for Type 4 ASPs, which take an expression in X(1) \\spad{..} X(NDIM) and produce a real function of the form: \\blankline \\tab{5}DOUBLE PRECISION FUNCTION FUNCTN(NDIM,X)\\br \\tab{5}DOUBLE PRECISION X(NDIM)\\br \\tab{5}INTEGER NDIM\\br \\tab{5}FUNCTN=(4.0D0*X(1)*X(3)**2*DEXP(2.0D0*X(1)*X(3)))/(X(4)**2+(2.0D0*\\br \\tab{4}&X(2)+2.0D0)*X(4)+X(2)**2+2.0D0*X(2)+1.0D0)\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|FortranExpression| (|construct|) (|construct| (QUOTE X)) (|MachineFloat|))) "\\spad{coerce(f)} takes an object from the appropriate instantiation of \\spadtype{FortranExpression} and turns it into an ASP."))) 
NIL 
NIL 
(|Asp50| |name|) 
((|constructor| (NIL "\\spadtype{Asp50} produces Fortran for Type 50 ASPs, needed for NAG routine e04fdf, for example: \\blankline \\tab{5}SUBROUTINE LSFUN1(M,N,XC,FVECC)\\br \\tab{5}DOUBLE PRECISION FVECC(M),XC(N)\\br \\tab{5}INTEGER I,M,N\\br \\tab{5}FVECC(1)=((XC(1)-2.4D0)*XC(3)+(15.0D0*XC(1)-36.0D0)*XC(2)+1.0D0)/(\\br \\tab{4}&XC(3)+15.0D0*XC(2))\\br \\tab{5}FVECC(2)=((XC(1)-2.8D0)*XC(3)+(7.0D0*XC(1)-19.6D0)*XC(2)+1.0D0)/(X\\br \\tab{4}&C(3)+7.0D0*XC(2))\\br \\tab{5}FVECC(3)=((XC(1)-3.2D0)*XC(3)+(4.333333333333333D0*XC(1)-13.866666\\br \\tab{4}&66666667D0)*XC(2)+1.0D0)/(XC(3)+4.333333333333333D0*XC(2))\\br \\tab{5}FVECC(4)=((XC(1)-3.5D0)*XC(3)+(3.0D0*XC(1)-10.5D0)*XC(2)+1.0D0)/(X\\br \\tab{4}&C(3)+3.0D0*XC(2))\\br \\tab{5}FVECC(5)=((XC(1)-3.9D0)*XC(3)+(2.2D0*XC(1)-8.579999999999998D0)*XC\\br \\tab{4}&(2)+1.0D0)/(XC(3)+2.2D0*XC(2))\\br \\tab{5}FVECC(6)=((XC(1)-4.199999999999999D0)*XC(3)+(1.666666666666667D0*X\\br \\tab{4}&C(1)-7.0D0)*XC(2)+1.0D0)/(XC(3)+1.666666666666667D0*XC(2))\\br \\tab{5}FVECC(7)=((XC(1)-4.5D0)*XC(3)+(1.285714285714286D0*XC(1)-5.7857142\\br \\tab{4}&85714286D0)*XC(2)+1.0D0)/(XC(3)+1.285714285714286D0*XC(2))\\br \\tab{5}FVECC(8)=((XC(1)-4.899999999999999D0)*XC(3)+(XC(1)-4.8999999999999\\br \\tab{4}&99D0)*XC(2)+1.0D0)/(XC(3)+XC(2))\\br \\tab{5}FVECC(9)=((XC(1)-4.699999999999999D0)*XC(3)+(XC(1)-4.6999999999999\\br \\tab{4}&99D0)*XC(2)+1.285714285714286D0)/(XC(3)+XC(2))\\br \\tab{5}FVECC(10)=((XC(1)-6.8D0)*XC(3)+(XC(1)-6.8D0)*XC(2)+1.6666666666666\\br \\tab{4}&67D0)/(XC(3)+XC(2))\\br \\tab{5}FVECC(11)=((XC(1)-8.299999999999999D0)*XC(3)+(XC(1)-8.299999999999\\br \\tab{4}&999D0)*XC(2)+2.2D0)/(XC(3)+XC(2))\\br \\tab{5}FVECC(12)=((XC(1)-10.6D0)*XC(3)+(XC(1)-10.6D0)*XC(2)+3.0D0)/(XC(3)\\br \\tab{4}&+XC(2))\\br \\tab{5}FVECC(13)=((XC(1)-1.34D0)*XC(3)+(XC(1)-1.34D0)*XC(2)+4.33333333333\\br \\tab{4}&3333D0)/(XC(3)+XC(2))\\br \\tab{5}FVECC(14)=((XC(1)-2.1D0)*XC(3)+(XC(1)-2.1D0)*XC(2)+7.0D0)/(XC(3)+X\\br \\tab{4}&C(2))\\br \\tab{5}FVECC(15)=((XC(1)-4.39D0)*XC(3)+(XC(1)-4.39D0)*XC(2)+15.0D0)/(XC(3\\br \\tab{4}&)+XC(2))\\br \\tab{5}END")) (|coerce| (($ (|Vector| (|FortranExpression| (|construct|) (|construct| (QUOTE XC)) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp55| |name|) 
((|constructor| (NIL "\\spadtype{Asp55} produces Fortran for Type 55 ASPs, needed for NAG routines e04dgf and e04ucf, for example: \\blankline \\tab{5}SUBROUTINE CONFUN(MODE,NCNLN,N,NROWJ,NEEDC,X,C,CJAC,NSTATE,IUSER\\br \\tab{4}&,USER)\\br \\tab{5}DOUBLE PRECISION C(NCNLN),X(N),CJAC(NROWJ,N),USER(*)\\br \\tab{5}INTEGER N,IUSER(*),NEEDC(NCNLN),NROWJ,MODE,NCNLN,NSTATE\\br \\tab{5}IF(NEEDC(1).GT.0)THEN\\br \\tab{7}C(1)=X(6)**2+X(1)**2\\br \\tab{7}CJAC(1,1)=2.0D0*X(1)\\br \\tab{7}CJAC(1,2)=0.0D0\\br \\tab{7}CJAC(1,3)=0.0D0\\br \\tab{7}CJAC(1,4)=0.0D0\\br \\tab{7}CJAC(1,5)=0.0D0\\br \\tab{7}CJAC(1,6)=2.0D0*X(6)\\br \\tab{5}ENDIF\\br \\tab{5}IF(NEEDC(2).GT.0)THEN\\br \\tab{7}C(2)=X(2)**2+(-2.0D0*X(1)*X(2))+X(1)**2\\br \\tab{7}CJAC(2,1)=(-2.0D0*X(2))+2.0D0*X(1)\\br \\tab{7}CJAC(2,2)=2.0D0*X(2)+(-2.0D0*X(1))\\br \\tab{7}CJAC(2,3)=0.0D0\\br \\tab{7}CJAC(2,4)=0.0D0\\br \\tab{7}CJAC(2,5)=0.0D0\\br \\tab{7}CJAC(2,6)=0.0D0\\br \\tab{5}ENDIF\\br \\tab{5}IF(NEEDC(3).GT.0)THEN\\br \\tab{7}C(3)=X(3)**2+(-2.0D0*X(1)*X(3))+X(2)**2+X(1)**2\\br \\tab{7}CJAC(3,1)=(-2.0D0*X(3))+2.0D0*X(1)\\br \\tab{7}CJAC(3,2)=2.0D0*X(2)\\br \\tab{7}CJAC(3,3)=2.0D0*X(3)+(-2.0D0*X(1))\\br \\tab{7}CJAC(3,4)=0.0D0\\br \\tab{7}CJAC(3,5)=0.0D0\\br \\tab{7}CJAC(3,6)=0.0D0\\br \\tab{5}ENDIF\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|Vector| (|FortranExpression| (|construct|) (|construct| (QUOTE X)) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp6| |name|) 
((|constructor| (NIL "\\spadtype{Asp6} produces Fortran for Type 6 ASPs, needed for NAG routines c05nbf, c05ncf. These represent vectors of functions of X(i) and look like: \\blankline \\tab{5}SUBROUTINE FCN(N,X,FVEC,IFLAG) \\tab{5}DOUBLE PRECISION X(N),FVEC(N) \\tab{5}INTEGER N,IFLAG \\tab{5}FVEC(1)=(-2.0D0*X(2))+(-2.0D0*X(1)**2)+3.0D0*X(1)+1.0D0 \\tab{5}FVEC(2)=(-2.0D0*X(3))+(-2.0D0*X(2)**2)+3.0D0*X(2)+(-1.0D0*X(1))+1. \\tab{4}&0D0 \\tab{5}FVEC(3)=(-2.0D0*X(4))+(-2.0D0*X(3)**2)+3.0D0*X(3)+(-1.0D0*X(2))+1. \\tab{4}&0D0 \\tab{5}FVEC(4)=(-2.0D0*X(5))+(-2.0D0*X(4)**2)+3.0D0*X(4)+(-1.0D0*X(3))+1. \\tab{4}&0D0 \\tab{5}FVEC(5)=(-2.0D0*X(6))+(-2.0D0*X(5)**2)+3.0D0*X(5)+(-1.0D0*X(4))+1. \\tab{4}&0D0 \\tab{5}FVEC(6)=(-2.0D0*X(7))+(-2.0D0*X(6)**2)+3.0D0*X(6)+(-1.0D0*X(5))+1. \\tab{4}&0D0 \\tab{5}FVEC(7)=(-2.0D0*X(8))+(-2.0D0*X(7)**2)+3.0D0*X(7)+(-1.0D0*X(6))+1. \\tab{4}&0D0 \\tab{5}FVEC(8)=(-2.0D0*X(9))+(-2.0D0*X(8)**2)+3.0D0*X(8)+(-1.0D0*X(7))+1. \\tab{4}&0D0 \\tab{5}FVEC(9)=(-2.0D0*X(9)**2)+3.0D0*X(9)+(-1.0D0*X(8))+1.0D0 \\tab{5}RETURN \\tab{5}END")) (|coerce| (($ (|Vector| (|FortranExpression| (|construct|) (|construct| (QUOTE X)) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp73| |name|) 
((|constructor| (NIL "\\spadtype{Asp73} produces Fortran for Type 73 ASPs, needed for NAG routine d03eef, for example: \\blankline \\tab{5}SUBROUTINE PDEF(X,Y,ALPHA,BETA,GAMMA,DELTA,EPSOLN,PHI,PSI)\\br \\tab{5}DOUBLE PRECISION ALPHA,EPSOLN,PHI,X,Y,BETA,DELTA,GAMMA,PSI\\br \\tab{5}ALPHA=DSIN(X)\\br \\tab{5}BETA=Y\\br \\tab{5}GAMMA=X*Y\\br \\tab{5}DELTA=DCOS(X)*DSIN(Y)\\br \\tab{5}EPSOLN=Y+X\\br \\tab{5}PHI=X\\br \\tab{5}PSI=Y\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|Vector| (|FortranExpression| (|construct| (QUOTE X) (QUOTE Y)) (|construct|) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp74| |name|) 
((|constructor| (NIL "\\spadtype{Asp74} produces Fortran for Type 74 ASPs, needed for NAG routine d03eef, for example: \\blankline \\tab{5} SUBROUTINE BNDY(X,Y,A,B,C,IBND)\\br \\tab{5} DOUBLE PRECISION A,B,C,X,Y\\br \\tab{5} INTEGER IBND\\br \\tab{5} IF(IBND.EQ.0)THEN\\br \\tab{7} A=0.0D0\\br \\tab{7} B=1.0D0\\br \\tab{7} C=-1.0D0*DSIN(X)\\br \\tab{5} ELSEIF(IBND.EQ.1)THEN\\br \\tab{7} A=1.0D0\\br \\tab{7} B=0.0D0\\br \\tab{7} C=DSIN(X)*DSIN(Y)\\br \\tab{5} ELSEIF(IBND.EQ.2)THEN\\br \\tab{7} A=1.0D0\\br \\tab{7} B=0.0D0\\br \\tab{7} C=DSIN(X)*DSIN(Y)\\br \\tab{5} ELSEIF(IBND.EQ.3)THEN\\br \\tab{7} A=0.0D0\\br \\tab{7} B=1.0D0\\br \\tab{7} C=-1.0D0*DSIN(Y)\\br \\tab{5} ENDIF\\br \\tab{5} END")) (|coerce| (($ (|Matrix| (|FortranExpression| (|construct| (QUOTE X) (QUOTE Y)) (|construct|) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp77| |name|) 
((|constructor| (NIL "\\spadtype{Asp77} produces Fortran for Type 77 ASPs, needed for NAG routine d02gbf, for example: \\blankline \\tab{5}SUBROUTINE FCNF(X,F)\\br \\tab{5}DOUBLE PRECISION X\\br \\tab{5}DOUBLE PRECISION F(2,2)\\br \\tab{5}F(1,1)=0.0D0\\br \\tab{5}F(1,2)=1.0D0\\br \\tab{5}F(2,1)=0.0D0\\br \\tab{5}F(2,2)=-10.0D0\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|Matrix| (|FortranExpression| (|construct| (QUOTE X)) (|construct|) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp78| |name|) 
((|constructor| (NIL "\\spadtype{Asp78} produces Fortran for Type 78 ASPs, needed for NAG routine d02gbf, for example: \\blankline \\tab{5}SUBROUTINE FCNG(X,G)\\br \\tab{5}DOUBLE PRECISION G(*),X\\br \\tab{5}G(1)=0.0D0\\br \\tab{5}G(2)=0.0D0\\br \\tab{5}END")) (|coerce| (($ (|Vector| (|FortranExpression| (|construct| (QUOTE X)) (|construct|) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp7| |name|) 
((|constructor| (NIL "\\spadtype{Asp7} produces Fortran for Type 7 ASPs, needed for NAG routines d02bbf, d02gaf. These represent a vector of functions of the scalar \\spad{X} and the array \\spad{Z,} and look like: \\blankline \\tab{5}SUBROUTINE FCN(X,Z,F)\\br \\tab{5}DOUBLE PRECISION F(*),X,Z(*)\\br \\tab{5}F(1)=DTAN(Z(3))\\br \\tab{5}F(2)=((-0.03199999999999999D0*DCOS(Z(3))*DTAN(Z(3)))+(-0.02D0*Z(2)\\br \\tab{4}&**2))/(Z(2)*DCOS(Z(3)))\\br \\tab{5}F(3)=-0.03199999999999999D0/(X*Z(2)**2)\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|Vector| (|FortranExpression| (|construct| (QUOTE X)) (|construct| (QUOTE Y)) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp80| |name|) 
((|constructor| (NIL "\\spadtype{Asp80} produces Fortran for Type 80 ASPs, needed for NAG routine d02kef, for example: \\blankline \\tab{5}SUBROUTINE BDYVAL(XL,XR,ELAM,YL,YR)\\br \\tab{5}DOUBLE PRECISION ELAM,XL,YL(3),XR,YR(3)\\br \\tab{5}YL(1)=XL\\br \\tab{5}YL(2)=2.0D0\\br \\tab{5}YR(1)=1.0D0\\br \\tab{5}YR(2)=-1.0D0*DSQRT(XR+(-1.0D0*ELAM))\\br \\tab{5}RETURN\\br \\tab{5}END")) (|coerce| (($ (|Matrix| (|FortranExpression| (|construct| (QUOTE XL) (QUOTE XR) (QUOTE ELAM)) (|construct|) (|MachineFloat|)))) "\\spad{coerce(f)} takes objects from the appropriate instantiation of \\spadtype{FortranExpression} and turns them into an ASP."))) 
NIL 
NIL 
(|Asp8| |name|) 
((|constructor| (NIL "\\spadtype{Asp8} produces Fortran for Type 8 ASPs, needed for NAG routine d02bbf. This ASP prints intermediate values of the computed solution of an ODE and might look like: \\blankline \\tab{5}SUBROUTINE OUTPUT(XSOL,Y,COUNT,M,N,RESULT,FORWRD)\\br \\tab{5}DOUBLE PRECISION Y(N),RESULT(M,N),XSOL\\br \\tab{5}INTEGER M,N,COUNT\\br \\tab{5}LOGICAL FORWRD\\br \\tab{5}DOUBLE PRECISION X02ALF,POINTS(8)\\br \\tab{5}EXTERNAL X02ALF\\br \\tab{5}INTEGER I\\br \\tab{5}POINTS(1)=1.0D0\\br \\tab{5}POINTS(2)=2.0D0\\br \\tab{5}POINTS(3)=3.0D0\\br \\tab{5}POINTS(4)=4.0D0\\br \\tab{5}POINTS(5)=5.0D0\\br \\tab{5}POINTS(6)=6.0D0\\br \\tab{5}POINTS(7)=7.0D0\\br \\tab{5}POINTS(8)=8.0D0\\br \\tab{5}COUNT=COUNT+1\\br \\tab{5}DO 25001 I=1,N\\br \\tab{7} RESULT(COUNT,I)=Y(I)\\br 25001 CONTINUE\\br \\tab{5}IF(COUNT.EQ.M)THEN\\br \\tab{7}IF(FORWRD)THEN\\br \\tab{9}XSOL=X02ALF()\\br \\tab{7}ELSE\\br \\tab{9}XSOL=-X02ALF()\\br \\tab{7}ENDIF\\br \\tab{5}ELSE\\br \\tab{7} XSOL=POINTS(COUNT)\\br \\tab{5}ENDIF\\br \\tab{5}END"))) 
NIL 
NIL 
(|Asp9| |name|) 
((|constructor| (NIL "\\spadtype{Asp9} produces Fortran for Type 9 ASPs, needed for NAG routines d02bhf, d02cjf, d02ejf. These ASPs represent a function of a scalar \\spad{X} and a vector \\spad{Y,} for example: \\blankline \\tab{5}DOUBLE PRECISION FUNCTION G(X,Y)\\br \\tab{5}DOUBLE PRECISION X,Y(*)\\br \\tab{5}G=X+Y(1)\\br \\tab{5}RETURN\\br \\tab{5}END \\blankline If the user provides a constant value for \\spad{G,} then extra information is added via COMMON blocks used by certain routines. This specifies that the value returned by \\spad{G} in this case is to be ignored.")) (|coerce| (($ (|FortranExpression| (|construct| (QUOTE X)) (|construct| (QUOTE Y)) (|MachineFloat|))) "\\spad{coerce(f)} takes an object from the appropriate instantiation of \\spadtype{FortranExpression} and turns it into an ASP."))) 
NIL 
NIL 
(|AssociatedEquations| R L) 
((|constructor| (NIL "\\spadtype{AssociatedEquations} provides functions to compute the associated equations needed for factoring operators")) (|associatedEquations| (((|Record| (|:| |minor| (|List| (|PositiveInteger|))) (|:| |eq| |#2|) (|:| |minors| (|List| (|List| (|PositiveInteger|)))) (|:| |ops| (|List| |#2|))) |#2| (|PositiveInteger|)) "\\spad{associatedEquations(op, \\spad{m)}} returns \\spad{[w, eq, \\spad{lw,} lop]} such that \\spad{eq(w) = 0} where \\spad{w} is the given minor, and \\spad{lw_i = lop_i(w)} for all the other minors.")) (|uncouplingMatrices| (((|Vector| (|Matrix| |#1|)) (|Matrix| |#1|)) "\\spad{uncouplingMatrices(M)} returns \\spad{[A_1,...,A_n]} such that if \\spad{y = [y_1,...,y_n]} is a solution of \\spad{y' = \\spad{M} \\spad{y},} then \\spad{[$y_j',y_j'',...,y_j^{(n)}$] = $A_j \\spad{y$}} for all j's.")) (|associatedSystem| (((|Record| (|:| |mat| (|Matrix| |#1|)) (|:| |vec| (|Vector| (|List| (|PositiveInteger|))))) |#2| (|PositiveInteger|)) "\\spad{associatedSystem(op, \\spad{m)}} returns \\spad{[M,w]} such that the \\spad{m}-th associated equation system to \\spad{L} is \\spad{w' = \\spad{M} \\spad{w}.}"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|Field|)))) 
(|ArrayStack| S) 
((|constructor| (NIL "A stack represented as a flexible array.")) (|member?| (((|Boolean|) |#1| $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} member?(3,a)")) (|members| (((|List| |#1|) $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} members a")) (|parts| (((|List| |#1|) $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} parts a")) (|#| (((|NonNegativeInteger|) $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} \\#a")) (|count| (((|NonNegativeInteger|) |#1| $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} count(4,a)") (((|NonNegativeInteger|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} count(x+->(x>2),a)")) (|any?| (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} any?(x+->(x=4),a)")) (|every?| (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} every?(x+->(x=4),a)")) (~= (((|Boolean|) $ $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} b:=copy a \\spad{X} (a~=b)")) (= (((|Boolean|) $ $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} b:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} (a=b)@Boolean")) (|coerce| (((|OutputForm|) $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} coerce a")) (|hash| (((|SingleInteger|) $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} hash a")) (|latex| (((|String|) $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} latex a")) (|map!| (($ (|Mapping| |#1| |#1|) $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} map!(x+->x+10,a) \\spad{X} a")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} map(x+->x+10,a) \\spad{X} a")) (|eq?| (((|Boolean|) $ $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} b:=copy a \\spad{X} eq?(a,b)")) (|copy| (($ $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} copy a")) (|sample| (($) "\\blankline \\spad{X} sample()$ArrayStack(INT)")) (|empty| (($) "\\blankline \\spad{X} b:=empty()$(ArrayStack INT)")) (|empty?| (((|Boolean|) $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} empty? a")) (|bag| (($ (|List| |#1|)) "\\blankline \\spad{X} bag([1,2,3,4,5])$ArrayStack(INT)")) (|size?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} size?(a,5)")) (|more?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} more?(a,9)")) (|less?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} less?(a,9)")) (|depth| (((|NonNegativeInteger|) $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} depth a")) (|top| ((|#1| $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} top a")) (|inspect| ((|#1| $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} inspect a")) (|insert!| (($ |#1| $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} insert!(8,a) \\spad{X} a")) (|push!| ((|#1| |#1| $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} push!(9,a) \\spad{X} a")) (|extract!| ((|#1| $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} extract! a \\spad{X} a")) (|pop!| ((|#1| $) "\\blankline \\spad{X} a:ArrayStack INT:= arrayStack [1,2,3,4,5] \\spad{X} pop! a \\spad{X} a")) (|arrayStack| (($ (|List| |#1|)) "\\indented{1}{arrayStack([x,y,...,z]) creates an array stack with first (top)} \\indented{1}{element \\spad{x,} second element y,...,and last element \\spad{z.}} \\blankline \\spad{E} c:ArrayStack INT:= arrayStack [1,2,3,4,5]"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|AdditiveValuationAttribute|) 
((|constructor| (NIL "The class of all euclidean domains such that \\spad{euclideanSize(a*b) = euclideanSize(a)+euclideanSize(b)}"))) 
((|nil| . T)) 
NIL 
(|ApproximateAttribute|) 
((|constructor| (NIL "An approximation to the real numbers."))) 
((|nil| . T)) 
NIL 
(|ArbitraryExponentAttribute|) 
((|constructor| (NIL "Approximate numbers with arbitrarily large exponents"))) 
((|nil| . T)) 
NIL 
(|ArbitraryPrecisionAttribute|) 
((|constructor| (NIL "Approximate numbers for which the user can set the precision for subsequent calculations."))) 
((|nil| . T)) 
NIL 
(|CanonicalClosedAttribute|) 
((|constructor| (NIL "The class of all integral domains such that \\spad{unitCanonical(a)*unitCanonical(b) = unitCanonical(a*b)}"))) 
((|nil| . T)) 
NIL 
(|CanonicalAttribute|) 
((|constructor| (NIL "The class of all domains which have canonical represenntation, that is, mathematically equal elements ahve the same data structure."))) 
((|nil| . T)) 
NIL 
(|CentralAttribute|) 
((|constructor| (NIL "Central is \\spad{true} if, given an algebra over a ring \\spad{R,} the image of \\spad{R} is the center of the algebra. For example, the set of members of the algebra which commute with all others is precisely the image of \\spad{R} in the algebra."))) 
((|nil| . T)) 
NIL 
(|CommutativeStarAttribute|) 
((|constructor| (NIL "The class of all commutative semigroups in multiplicative notation. In other words domain \\spad{D} with \\spad{\"*\": (D,D) \\spad{->} \\spad{D}} which is commutative. Typially applied to rings."))) 
((|nil| . T)) 
NIL 
(|CanonicalUnitNormalAttribute|) 
((|constructor| (NIL "The class of all integral domains such that we can choose a canonical representative for each class of associate elements. That is, \\spad{associates?(a,b)} returns \\spad{true} if and only if \\spad{unitCanonical(a)} = \\spad{unitCanonical(b)}"))) 
((|nil| . T)) 
NIL 
(|FiniteAggregateAttribute|) 
((|constructor| (NIL "The class of all aggregates with a finite number of arguments"))) 
((|nil| . T)) 
NIL 
(|JacobiIdentityAttribute|) 
((|constructor| (NIL "JacobiIdentity means that \\spad{[x,[y,z]]+[y,[z,x]]+[z,[x,y]] = 0} holds. See LieAlgebra."))) 
((|nil| . T)) 
NIL 
(|LazyRepresentationAttribute|) 
((|constructor| (NIL "The class of all domains which have a lazy representation"))) 
((|nil| . T)) 
NIL 
(|LeftUnitaryAttribute|) 
((|constructor| (NIL "LeftUnitary is \\spad{true} if \\spad{1 * \\spad{x} = \\spad{x}} for all \\spad{x.}"))) 
((|nil| . T)) 
NIL 
(|MultiplicativeValuationAttribute|) 
((|constructor| (NIL "The class of all euclidean domains such that \\spad{euclideanSize(a*b)=euclideanSize(a)*euclideanSize(b)}"))) 
((|nil| . T)) 
NIL 
(|NotherianAttribute|) 
((|constructor| (NIL "Notherian is \\spad{true} if all of its ideals are finitely generated."))) 
((|nil| . T)) 
NIL 
(|NullSquareAttribute|) 
((|constructor| (NIL "NullSquare means that \\spad{[x,x] = 0} holds. See LieAlgebra."))) 
((|nil| . T)) 
NIL 
(|NoZeroDivisorsAttribute|) 
((|constructor| (NIL "The class of all semirings such that \\spad{x * \\spad{y} \\spad{~=} 0} implies both \\spad{x} and \\spad{y} are non-zero."))) 
((|nil| . T)) 
NIL 
(|PartiallyOrderedSetAttribute|) 
((|constructor| (NIL "PartiallyOrderedSet is \\spad{true} if a set with \\spad{<} is transitive, but \\spad{not(a \\spad{<b} or a = b)}. It does not imply \\spad{b < a}"))) 
((|nil| . T)) 
NIL 
(|ArcTrigonometricFunctionCategory&| S) 
((|constructor| (NIL "Category for the inverse trigonometric functions.")) (|atan| (($ $) "\\spad{atan(x)} returns the arc-tangent of \\spad{x.}")) (|asin| (($ $) "\\spad{asin(x)} returns the arc-sine of \\spad{x.}")) (|asec| (($ $) "\\spad{asec(x)} returns the arc-secant of \\spad{x.}")) (|acsc| (($ $) "\\spad{acsc(x)} returns the arc-cosecant of \\spad{x.}")) (|acot| (($ $) "\\spad{acot(x)} returns the arc-cotangent of \\spad{x.}")) (|acos| (($ $) "\\spad{acos(x)} returns the arc-cosine of \\spad{x.}"))) 
NIL 
NIL 
(|ArcTrigonometricFunctionCategory|) 
((|constructor| (NIL "Category for the inverse trigonometric functions.")) (|atan| (($ $) "\\spad{atan(x)} returns the arc-tangent of \\spad{x.}")) (|asin| (($ $) "\\spad{asin(x)} returns the arc-sine of \\spad{x.}")) (|asec| (($ $) "\\spad{asec(x)} returns the arc-secant of \\spad{x.}")) (|acsc| (($ $) "\\spad{acsc(x)} returns the arc-cosecant of \\spad{x.}")) (|acot| (($ $) "\\spad{acot(x)} returns the arc-cotangent of \\spad{x.}")) (|acos| (($ $) "\\spad{acos(x)} returns the arc-cosine of \\spad{x.}"))) 
NIL 
NIL 
(|ShallowlyMutableAttribute|) 
((|constructor| (NIL "The class of all domains which have immediate components that are updateable in place (mutable). The properties of any component domain are irrevelant to the ShallowlyMutableAttribute."))) 
((|nil| . T)) 
NIL 
(|AttributeButtons|) 
((|constructor| (NIL "\\axiomType{AttributeButtons} implements a database and associated adjustment mechanisms for a set of attributes. \\blankline For ODEs these attributes are \"stiffness\", \"stability\" (\\spadignore{i.e.} how much affect the cosine or sine component of the solution has on the stability of the result), \"accuracy\" and \"expense\" (\\spadignore{i.e.} how expensive is the evaluation of the ODE). All these have bearing on the cost of calculating the solution given that reducing the step-length to achieve greater accuracy requires considerable number of evaluations and calculations. \\blankline The effect of each of these attributes can be altered by increasing or decreasing the button value. \\blankline For Integration there is a button for increasing and decreasing the preset number of function evaluations for each method. This is automatically used by ANNA when a method fails due to insufficient workspace or where the limit of function evaluations has been reached before the required accuracy is achieved.")) (|setButtonValue| (((|Float|) (|String|) (|String|) (|Float|)) "\\axiom{setButtonValue(attributeName,routineName,n)} sets the value of the button of attribute \\spad{attributeName} to routine \\spad{routineName} to \\spad{n}. \\spad{n} must be in the range [0..1]. \\blankline \\axiom{attributeName} should be one of the values \"stiffness\", \"stability\", \"accuracy\", \"expense\" or \"functionEvaluations\".") (((|Float|) (|String|) (|Float|)) "\\axiom{setButtonValue(attributeName,n)} sets the value of all buttons of attribute \\spad{attributeName} to \\spad{n}. \\spad{n} must be in the range [0..1]. \\blankline \\axiom{attributeName} should be one of the values \"stiffness\", \"stability\", \"accuracy\", \"expense\" or \"functionEvaluations\".")) (|setAttributeButtonStep| (((|Float|) (|Float|)) "\\axiom{setAttributeButtonStep(n)} sets the value of the steps for increasing and decreasing the button values. \\axiom{n} must be greater than 0 and less than 1. The preset value is 0.5.")) (|resetAttributeButtons| (((|Void|)) "\\axiom{resetAttributeButtons()} resets the Attribute buttons to a neutral level.")) (|getButtonValue| (((|Float|) (|String|) (|String|)) "\\axiom{getButtonValue(routineName,attributeName)} returns the current value for the effect of the attribute \\axiom{attributeName} with routine \\axiom{routineName}. \\blankline \\axiom{attributeName} should be one of the values \"stiffness\", \"stability\", \"accuracy\", \"expense\" or \"functionEvaluations\".")) (|decrease| (((|Float|) (|String|)) "\\axiom{decrease(attributeName)} decreases the value for the effect of the attribute \\axiom{attributeName} with all routines. \\blankline \\axiom{attributeName} should be one of the values \"stiffness\", \"stability\", \"accuracy\", \"expense\" or \"functionEvaluations\".") (((|Float|) (|String|) (|String|)) "\\axiom{decrease(routineName,attributeName)} decreases the value for the effect of the attribute \\axiom{attributeName} with routine \\axiom{routineName}. \\blankline \\axiom{attributeName} should be one of the values \"stiffness\", \"stability\", \"accuracy\", \"expense\" or \"functionEvaluations\".")) (|increase| (((|Float|) (|String|)) "\\axiom{increase(attributeName)} increases the value for the effect of the attribute \\axiom{attributeName} with all routines. \\blankline \\axiom{attributeName} should be one of the values \"stiffness\", \"stability\", \"accuracy\", \"expense\" or \"functionEvaluations\".") (((|Float|) (|String|) (|String|)) "\\axiom{increase(routineName,attributeName)} increases the value for the effect of the attribute \\axiom{attributeName} with routine \\axiom{routineName}. \\blankline \\axiom{attributeName} should be one of the values \"stiffness\", \"stability\", \"accuracy\", \"expense\" or \"functionEvaluations\"."))) 
((|finiteAggregate| . T)) 
NIL 
(|AttributeRegistry|) 
((|constructor| (NIL "This category exports the attributes in the AXIOM Library")) (|approximate| ((|attribute|) "\\spad{approximate} means \"is an approximation to the real numbers\".")) (|canonical| ((|attribute|) "\\spad{canonical} is \\spad{true} if and only if distinct elements have distinct data structures. For example, a domain of mathematical objects which has the \\spad{canonical} attribute means that two objects are mathematically equal if and only if their data structures are equal.")) (|multiplicativeValuation| ((|attribute|) "\\spad{multiplicativeValuation} implies \\spad{euclideanSize(a*b)=euclideanSize(a)*euclideanSize(b)}.")) (|additiveValuation| ((|attribute|) "\\spad{additiveValuation} implies \\spad{euclideanSize(a*b)=euclideanSize(a)+euclideanSize(b)}.")) (|noetherian| ((|attribute|) "\\spad{noetherian} is \\spad{true} if all of its ideals are finitely generated.")) (|central| ((|attribute|) "\\spad{central} is \\spad{true} if, given an algebra over a ring \\spad{R,} the image of \\spad{R} is the center of the algebra, For example, the set of members of the algebra which commute with all others is precisely the image of \\spad{R} in the algebra.")) (|partiallyOrderedSet| ((|attribute|) "\\spad{partiallyOrderedSet} is \\spad{true} if a set with \\spadop{<} which is transitive, but \\spad{not(a < \\spad{b} or a = \\spad{b)}} does not necessarily imply \\spad{b<a}.")) (|arbitraryPrecision| ((|attribute|) "\\spad{arbitraryPrecision} means the user can set the precision for subsequent calculations.")) (|canonicalsClosed| ((|attribute|) "\\spad{canonicalsClosed} is \\spad{true} if \\spad{unitCanonical(a)*unitCanonical(b) = unitCanonical(a*b)}.")) (|canonicalUnitNormal| ((|attribute|) "\\spad{canonicalUnitNormal} is \\spad{true} if we can choose a canonical representative for each class of associate elements, that is \\spad{associates?(a,b)} returns \\spad{true} if and only if \\spad{unitCanonical(a) = unitCanonical(b)}.")) (|noZeroDivisors| ((|attribute|) "\\spad{noZeroDivisors} is \\spad{true} if \\spad{x * \\spad{y} \\~~= 0} implies both \\spad{x} and \\spad{y} are non-zero.")) (|rightUnitary| ((|attribute|) "\\spad{rightUnitary} is \\spad{true} if \\spad{x * 1 = \\spad{x}} for all \\spad{x.}")) (|leftUnitary| ((|attribute|) "\\spad{leftUnitary} is \\spad{true} if \\spad{1 * \\spad{x} = \\spad{x}} for all \\spad{x.}")) (|unitsKnown| ((|attribute|) "\\spad{unitsKnown} is \\spad{true} if a monoid (a multiplicative semigroup with a 1) has \\spad{unitsKnown} means that the operation \\spadfun{recip} can only return \"failed\" if its argument is not a unit.")) (|shallowlyMutable| ((|attribute|) "\\spad{shallowlyMutable} is \\spad{true} if its values have immediate components that are updateable (mutable). Note that the properties of any component domain are irrevelant to the \\spad{shallowlyMutable} proper.")) (|commutative| ((|attribute| "*") "\\spad{commutative(\"*\")} is \\spad{true} if it has an operation \\spad{\"*\": (D,D) \\spad{->} \\spad{D}} which is commutative.")) (|finiteAggregate| ((|attribute|) "\\spad{finiteAggregate} is \\spad{true} if it is an aggregate with a finite number of elements."))) 
((|finiteAggregate| . T) ((|commutative| "*") . T) (|shallowlyMutable| . T) (|unitsKnown| . T) (|leftUnitary| . T) (|rightUnitary| . T) (|noZeroDivisors| . T) (|canonicalUnitNormal| . T) (|canonicalsClosed| . T) (|arbitraryPrecision| . T) (|partiallyOrderedSet| . T) (|central| . T) (|noetherian| . T) (|additiveValuation| . T) (|multiplicativeValuation| . T) (|NullSquare| . T) (|JacobiIdentity| . T) (|canonical| . T) (|approximate| . T)) 
NIL 
(|UnitsKnownAttribute|) 
((|constructor| (NIL "The class of all monoids (multiplicative semigroups with a 1) such that the operation recop can only return \"failed\" if its argument is not a unit."))) 
((|nil| . T)) 
NIL 
(|Automorphism| R) 
((|constructor| (NIL "Automorphism \\spad{R} is the multiplicative group of automorphisms of \\spad{R.}")) (|morphism| (($ (|Mapping| |#1| |#1| (|Integer|))) "\\spad{morphism(f)} returns the morphism given by \\spad{f^n(x) = f(x,n)}.") (($ (|Mapping| |#1| |#1|) (|Mapping| |#1| |#1|)) "\\spad{morphism(f, \\spad{g)}} returns the invertible morphism given by \\spad{f,} where \\spad{g} is the inverse of \\spad{f..}") (($ (|Mapping| |#1| |#1|)) "\\spad{morphism(f)} returns the non-invertible morphism given by \\spad{f.}"))) 
((|unitsKnown| . T)) 
NIL 
(|AxiomServer|) 
((|constructor| (NIL "This package provides a functions to support a web server for the new Axiom Browser functions."))) 
NIL 
NIL 
(|BalancedFactorisation| R UP) 
((|constructor| (NIL "This package provides balanced factorisations of polynomials.")) (|balancedFactorisation| (((|Factored| |#2|) |#2| (|List| |#2|)) "\\spad{balancedFactorisation(a, [b1,...,bn])} returns a factorisation \\spad{a = \\spad{p1^e1} \\spad{...} pm^em} such that each \\spad{pi} is balanced with respect to \\spad{[b1,...,bm]}.") (((|Factored| |#2|) |#2| |#2|) "\\spad{balancedFactorisation(a, \\spad{b)}} returns a factorisation \\spad{a = \\spad{p1^e1} \\spad{...} pm^em} such that each \\spad{pi} is balanced with respect to \\spad{b.}"))) 
NIL 
NIL 
(|BasicType&| S) 
((|constructor| (NIL "BasicType is the basic category for describing a collection of elements with = (equality).")) (~= (((|Boolean|) $ $) "\\spad{x~=y} tests if \\spad{x} and \\spad{y} are not equal.")) (= (((|Boolean|) $ $) "\\spad{x=y} tests if \\spad{x} and \\spad{y} are equal."))) 
NIL 
NIL 
(|BasicType|) 
((|constructor| (NIL "BasicType is the basic category for describing a collection of elements with = (equality).")) (~= (((|Boolean|) $ $) "\\spad{x~=y} tests if \\spad{x} and \\spad{y} are not equal.")) (= (((|Boolean|) $ $) "\\spad{x=y} tests if \\spad{x} and \\spad{y} are equal."))) 
NIL 
NIL 
(|BalancedBinaryTree| S) 
((|constructor| (NIL "\\spadtype{BalancedBinaryTree(S)} is the domain of balanced binary trees (bbtree). A balanced binary tree of \\spad{2**k} leaves, for some \\spad{k > 0}, is symmetric, that is, the left and right subtree of each interior node have identical shape. In general, the left and right subtree of a given node can differ by at most leaf node.")) (|mapDown!| (($ $ |#1| (|Mapping| (|List| |#1|) |#1| |#1| |#1|)) "\\indented{1}{mapDown!(t,p,f) returns \\spad{t} after traversing \\spad{t} in \"preorder\"} \\indented{1}{(node then left then right) fashion replacing the successive} \\indented{1}{interior nodes as follows. Let \\spad{l} and \\spad{r} denote the left and} \\indented{1}{right subtrees of \\spad{t.} The root value \\spad{x} of \\spad{t} is replaced by \\spad{p.}} \\indented{1}{Then f(value \\spad{l,} value \\spad{r,} \\spad{p),} where \\spad{l} and \\spad{r} denote the left} \\indented{1}{and right subtrees of \\spad{t,} is evaluated producing two values} \\indented{1}{pl and \\spad{pr.} Then \\spad{mapDown!(l,pl,f)} and \\spad{mapDown!(l,pr,f)}} \\indented{1}{are evaluated.} \\blankline \\spad{X} T1:=BalancedBinaryTree Integer \\spad{X} t2:=balancedBinaryTree(4, 0)$T1 \\spad{X} setleaves!(t2,[1,2,3,4]::List(Integer)) \\spad{X} adder3(i:Integer,j:Integer,k:Integer):List Integer \\spad{==} [i+j,j+k] \\spad{X} mapDown!(t2,4::INT,adder3) \\spad{X} \\spad{t2}") (($ $ |#1| (|Mapping| |#1| |#1| |#1|)) "\\indented{1}{mapDown!(t,p,f) returns \\spad{t} after traversing \\spad{t} in \"preorder\"} \\indented{1}{(node then left then right) fashion replacing the successive} \\indented{1}{interior nodes as follows. The root value \\spad{x} is} \\indented{1}{replaced by \\spad{q} \\spad{:=} f(p,x). The mapDown!(l,q,f) and} \\indented{1}{mapDown!(r,q,f) are evaluated for the left and right subtrees} \\indented{1}{l and \\spad{r} of \\spad{t.}} \\blankline \\spad{X} T1:=BalancedBinaryTree Integer \\spad{X} t2:=balancedBinaryTree(4, 0)$T1 \\spad{X} setleaves!(t2,[1,2,3,4]::List(Integer)) \\spad{X} adder(i:Integer,j:Integer):Integer \\spad{==} i+j \\spad{X} mapDown!(t2,4::INT,adder) \\spad{X} \\spad{t2}")) (|mapUp!| (($ $ $ (|Mapping| |#1| |#1| |#1| |#1| |#1|)) "\\indented{1}{mapUp!(t,t1,f) traverses balanced binary tree \\spad{t} in an \"endorder\"} \\indented{1}{(left then right then node) fashion returning \\spad{t} with the value} \\indented{1}{at each successive interior node of \\spad{t} replaced \\spad{by}} \\indented{1}{f(l,r,l1,r1) where \\spad{l} and \\spad{r} are the values at the immediate} \\indented{1}{left and right nodes. Values \\spad{l1} and \\spad{r1} are values at the} \\indented{1}{corresponding nodes of a balanced binary tree \\spad{t1,} of identical} \\indented{1}{shape at \\spad{t.}} \\blankline \\spad{X} T1:=BalancedBinaryTree Integer \\spad{X} t2:=balancedBinaryTree(4, 0)$T1 \\spad{X} setleaves!(t2,[1,2,3,4]::List(Integer)) \\spad{X} adder4(i:INT,j:INT,k:INT,l:INT):INT \\spad{==} i+j+k+l \\spad{X} mapUp!(t2,t2,adder4) \\spad{X} \\spad{t2}") ((|#1| $ (|Mapping| |#1| |#1| |#1|)) "\\indented{1}{mapUp!(t,f) traverses balanced binary tree \\spad{t} in an \"endorder\"} \\indented{1}{(left then right then node) fashion returning \\spad{t} with the value} \\indented{1}{at each successive interior node of \\spad{t} replaced \\spad{by}} \\indented{1}{f(l,r) where \\spad{l} and \\spad{r} are the values at the immediate} \\indented{1}{left and right nodes.} \\blankline \\spad{X} T1:=BalancedBinaryTree Integer \\spad{X} t2:=balancedBinaryTree(4, 0)$T1 \\spad{X} setleaves!(t2,[1,2,3,4]::List(Integer)) \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} mapUp!(t2,adder) \\spad{X} \\spad{t2}")) (|setleaves!| (($ $ (|List| |#1|)) "\\indented{1}{setleaves!(t, \\spad{ls)} sets the leaves of \\spad{t} in left-to-right order} \\indented{1}{to the elements of ls.} \\blankline \\spad{X} t1:=balancedBinaryTree(4, 0) \\spad{X} setleaves!(t1,[1,2,3,4])")) (|balancedBinaryTree| (($ (|NonNegativeInteger|) |#1|) "\\indented{1}{balancedBinaryTree(n, \\spad{s)} creates a balanced binary tree with} \\indented{1}{n nodes each with value \\spad{s.}} \\blankline \\spad{X} balancedBinaryTree(4, 0)"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|Bezier| R) 
((|constructor| (NIL "Provide linear, quadratic, and cubic spline bezier curves")) (|cubicBezier| (((|Mapping| (|List| |#1|) |#1|) (|List| |#1|) (|List| |#1|) (|List| |#1|) (|List| |#1|)) "\\indented{1}{A cubic Bezier curve is a simple interpolation between the} \\indented{1}{starting point, a left-middle point,, a right-middle point,} \\indented{1}{and the ending point based on a parameter \\spad{t.}} \\indented{1}{Given a start point a=[x1,y1], the left-middle point b=[x2,y2],} \\indented{1}{the right-middle point c=[x3,y3] and an endpoint d=[x4,y4]} \\indented{1}{f(t) \\spad{==} \\spad{[(1-t)^3} \\spad{x1} + 3t(1-t)^2 \\spad{x2} + 3t^2 (1-t) \\spad{x3} + \\spad{t^3} x4,} \\indented{10}{(1-t)^3 \\spad{y1} + 3t(1-t)^2 \\spad{y2} + 3t^2 (1-t) \\spad{y3} + \\spad{t^3} y4]} \\blankline \\spad{X} n:=cubicBezier([2.0,2.0],[2.0,4.0],[6.0,4.0],[6.0,2.0]) \\spad{X} [n(t/10.0) for \\spad{t} in 0..10 by 1]")) (|quadraticBezier| (((|Mapping| (|List| |#1|) |#1|) (|List| |#1|) (|List| |#1|) (|List| |#1|)) "\\indented{1}{A quadratic Bezier curve is a simple interpolation between the} \\indented{1}{starting point, a middle point, and the ending point based on} \\indented{1}{a parameter \\spad{t.}} \\indented{1}{Given a start point a=[x1,y1], a middle point b=[x2,y2],} \\indented{1}{and an endpoint c=[x3,y3]} \\indented{1}{f(t) \\spad{==} \\spad{[(1-t)^2} \\spad{x1} + 2t(1-t) \\spad{x2} + \\spad{t^2} x3,} \\indented{10}{(1-t)^2 \\spad{y1} + 2t(1-t) \\spad{y2} + \\spad{t^2} y3]} \\blankline \\spad{X} n:=quadraticBezier([2.0,2.0],[4.0,4.0],[6.0,2.0]) \\spad{X} [n(t/10.0) for \\spad{t} in 0..10 by 1]")) (|linearBezier| (((|Mapping| (|List| |#1|) |#1|) (|List| |#1|) (|List| |#1|)) "\\indented{1}{A linear Bezier curve is a simple interpolation between the} \\indented{1}{starting point and the ending point based on a parameter \\spad{t.}} \\indented{1}{Given a start point a=[x1,y1] and an endpoint b=[x2,y2]} \\indented{1}{f(t) \\spad{==} \\spad{[(1-t)*x1} + t*x2, \\spad{(1-t)*y1} + t*y2]} \\blankline \\spad{X} n:=linearBezier([2.0,2.0],[4.0,4.0]) \\spad{X} [n(t/10.0) for \\spad{t} in 0..10 by 1]"))) 
NIL 
NIL 
(|BezoutMatrix| R UP M |Row| |Col|) 
((|constructor| (NIL "\\spadtype{BezoutMatrix} contains functions for computing resultants and discriminants using Bezout matrices.")) (|bezoutDiscriminant| ((|#1| |#2|) "\\spad{bezoutDiscriminant(p)} computes the discriminant of a polynomial \\spad{p} by computing the determinant of a Bezout matrix.")) (|bezoutResultant| ((|#1| |#2| |#2|) "\\spad{bezoutResultant(p,q)} computes the resultant of the two polynomials \\spad{p} and \\spad{q} by computing the determinant of a Bezout matrix.")) (|bezoutMatrix| ((|#3| |#2| |#2|) "\\spad{bezoutMatrix(p,q)} returns the Bezout matrix for the two polynomials \\spad{p} and \\spad{q.}")) (|sylvesterMatrix| ((|#3| |#2| |#2|) "\\spad{sylvesterMatrix(p,q)} returns the Sylvester matrix for the two polynomials \\spad{p} and \\spad{q.}"))) 
NIL 
((|HasAttribute| |#1| (QUOTE (|commutative| "*")))) 
(|BasicFunctions|) 
((|constructor| (NIL "A Domain which implements a table containing details of points at which particular functions have evaluation problems.")) (|bfEntry| (((|Record| (|:| |zeros| (|Stream| (|DoubleFloat|))) (|:| |ones| (|Stream| (|DoubleFloat|))) (|:| |singularities| (|Stream| (|DoubleFloat|)))) (|Symbol|)) "\\spad{bfEntry(k)} returns the entry in the \\axiomType{BasicFunctions} table corresponding to \\spad{k}")) (|bfKeys| (((|List| (|Symbol|))) "\\spad{bfKeys()} returns the names of each function in the \\axiomType{BasicFunctions} table"))) 
((|finiteAggregate| . T)) 
NIL 
(|BagAggregate&| A S) 
((|constructor| (NIL "A bag aggregate is an aggregate for which one can insert and extract objects, and where the order in which objects are inserted determines the order of extraction. Examples of bags are stacks, queues, and dequeues.")) (|inspect| ((|#2| $) "\\spad{inspect(u)} returns an (random) element from a bag.")) (|insert!| (($ |#2| $) "\\spad{insert!(x,u)} inserts item \\spad{x} into bag u.")) (|extract!| ((|#2| $) "\\spad{extract!(u)} destructively removes a (random) item from bag u.")) (|bag| (($ (|List| |#2|)) "\\spad{bag([x,y,...,z])} creates a bag with elements x,y,...,z.")) (|shallowlyMutable| ((|attribute|) "shallowlyMutable means that elements of bags may be destructively changed."))) 
NIL 
NIL 
(|BagAggregate| S) 
((|constructor| (NIL "A bag aggregate is an aggregate for which one can insert and extract objects, and where the order in which objects are inserted determines the order of extraction. Examples of bags are stacks, queues, and dequeues.")) (|inspect| ((|#1| $) "\\spad{inspect(u)} returns an (random) element from a bag.")) (|insert!| (($ |#1| $) "\\spad{insert!(x,u)} inserts item \\spad{x} into bag u.")) (|extract!| ((|#1| $) "\\spad{extract!(u)} destructively removes a (random) item from bag u.")) (|bag| (($ (|List| |#1|)) "\\spad{bag([x,y,...,z])} creates a bag with elements x,y,...,z.")) (|shallowlyMutable| ((|attribute|) "shallowlyMutable means that elements of bags may be destructively changed."))) 
((|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|BinaryExpansion|) 
((|constructor| (NIL "This domain allows rational numbers to be presented as repeating binary expansions.")) (|binary| (($ (|Fraction| (|Integer|))) "\\indented{1}{binary(r) converts a rational number to a binary expansion.} \\blankline \\spad{X} binary(22/7)")) (|fractionPart| (((|Fraction| (|Integer|)) $) "\\spad{fractionPart(b)} returns the fractional part of a binary expansion.")) (|coerce| (((|RadixExpansion| 2) $) "\\spad{coerce(b)} converts a binary expansion to a radix expansion with base 2.") (((|Fraction| (|Integer|)) $) "\\spad{coerce(b)} converts a binary expansion to a rational number."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|Integer|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| (|Integer|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| (|Integer|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Integer|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Integer|) (QUOTE (|RealConstant|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|Integer|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|StepThrough|))) (|HasCategory| (|Integer|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| (|Integer|) (QUOTE (|DifferentialRing|))) (|HasCategory| (|Integer|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |Eltable|) (QUOTE (|Integer|)) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|Integer|) (QUOTE (|IntegerNumberSystem|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (OR (|HasCategory| (|Integer|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Integer|) (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Integer|) (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| (|Integer|) (QUOTE (|CharacteristicNonZero|))))) 
(|BinaryFile|) 
((|constructor| (NIL "This domain provides an implementation of binary files. Data is accessed one byte at a time as a small integer.")) (|position!| (((|SingleInteger|) $ (|SingleInteger|)) "\\spad{position!(f, i)} sets the current byte-position to i.")) (|position| (((|SingleInteger|) $) "\\spad{position(f)} returns the current byte-position in the file \\spad{f.}")) (|readIfCan!| (((|Union| (|SingleInteger|) "failed") $) "\\spad{readIfCan!(f)} returns a value from the file \\spad{f,} if possible. If \\spad{f} is not open for reading, or if \\spad{f} is at the end of file then \\spad{\"failed\"} is the result."))) 
NIL 
NIL 
(|Bits|) 
((|constructor| (NIL "\\spadtype{Bits} provides logical functions for Indexed Bits.")) (|bits| (($ (|NonNegativeInteger|) (|Boolean|)) "\\spad{bits(n,b)} creates bits with \\spad{n} values of \\spad{b}"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| (|Boolean|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Boolean|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Boolean|) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Boolean|) (LIST (QUOTE |Evalable|) (QUOTE (|Boolean|)))) (|HasCategory| (|Boolean|) (QUOTE (|SetCategory|))))) 
(|BlasLevelOne|) 
((|constructor| (NIL "This package provides an interface to the Blas library (level 1)")) (|zaxpy| (((|PrimitiveArray| (|Complex| (|DoubleFloat|))) (|SingleInteger|) (|Complex| (|DoubleFloat|)) (|PrimitiveArray| (|Complex| (|DoubleFloat|))) (|SingleInteger|) (|PrimitiveArray| (|Complex| (|DoubleFloat|))) (|SingleInteger|)) "\\spad{zaxpy(n,da,x,incx,y,incy)} computes a \\spad{y} = a*x + \\spad{y} for each of the chosen elements of the vectors \\spad{x} and \\spad{y} and a constant multiplier a Note that the vector \\spad{y} is modified with the results. \\blankline \\spad{X} a:PRIMARR(COMPLEX(DFLOAT)) \\spad{X} a:=[[3.+4.*\\%i, -4.+5.*\\%i, 5.+6.*%i, 7.-8.*%i, -9.-2.*\\%i]] \\spad{X} b:PRIMARR(COMPLEX(DFLOAT)) \\spad{X} b:=[[3.+4.*\\%i, -4.+5.*\\%i, 5.+6.*%i, 7.-8.*%i, -9.-2.*\\%i]] \\spad{X} zaxpy(3,2.0,a,1,b,1) \\spad{X} b:=[[3.+4.*\\%i, -4.+5.*\\%i, 5.+6.*%i, 7.-8.*%i, -9.-2.*\\%i]] \\spad{X} zaxpy(5,2.0,a,1,b,1) \\spad{X} b:=[[3.+4.*\\%i, -4.+5.*\\%i, 5.+6.*%i, 7.-8.*%i, -9.-2.*\\%i]] \\spad{X} zaxpy(3,2.0,a,3,b,3) \\spad{X} b:=[[3.+4.*\\%i, -4.+5.*\\%i, 5.+6.*%i, 7.-8.*%i, -9.-2.*\\%i]] \\spad{X} zaxpy(4,2.0,a,2,b,2)")) (|izamax| (((|Integer|) (|SingleInteger|) (|PrimitiveArray| (|Complex| (|DoubleFloat|))) (|SingleInteger|)) "\\spad{izamax computes} the largest absolute value of the elements of the array and returns the index of the first instance of the maximum. \\blankline \\spad{X} a:PRIMARR(COMPLEX(DFLOAT)) \\spad{X} a:=[[3.+4.*\\%i,-4.+5.*\\%i,5.+6.*\\%i,7.-8.*\\%i,-9.-2.*\\%i]] \\spad{X} izamax(5,a,1) \\spad{--} should be 3 \\spad{X} izamax(0,a,1) \\spad{--} should be \\spad{-1} \\spad{X} izamax(5,a,-1) \\spad{--} should be \\spad{-1} \\spad{X} izamax(3,a,1) \\spad{--} should be 2 \\spad{X} izamax(3,a,2) \\spad{--} should be 1")) (|isamax| (((|Integer|) (|Integer|) (|PrimitiveArray| (|Float|)) (|Integer|)) "\\spad{isamax computes} the largest absolute value of the elements of the array and returns the index of the first instance of the maximum. \\blankline \\spad{X} a:PRIMARR(FLOAT):=[[3.0, 4.0, -3.0, 5.0, -1.0]] \\spad{X} isamax(5,a,1) \\spad{--} should be 3 \\spad{X} isamax(3,a,1) \\spad{--} should be 1 \\spad{X} isamax(0,a,1) \\spad{--} should be \\spad{-1} \\spad{X} isamax(-5,a,1) \\spad{--} should be \\spad{-1} \\spad{X} isamax(5,a,-1) \\spad{--} should be \\spad{-1} \\spad{X} isamax(5,a,2) \\spad{--} should be 0 \\spad{X} isamax(1,a,0) \\spad{--} should be \\spad{-1} \\spad{X} isamax(1,a,-1) \\spad{--} should be \\spad{-1} \\spad{X} a:PRIMARR(FLOAT):=[[3.0, 4.0, -3.0, -5.0, -1.0]] \\spad{X} isamax(5,a,1) \\spad{--} should be 3")) (|idamax| (((|Integer|) (|Integer|) (|PrimitiveArray| (|DoubleFloat|)) (|Integer|)) "\\spad{idamax computes} the largest absolute value of the elements of the array and returns the index of the first instance of the maximum. \\blankline \\spad{X} a:PRIMARR(DFLOAT):=[[3.0, 4.0, -3.0, 5.0, -1.0]] \\spad{X} idamax(5,a,1) \\spad{--} should be 3 \\spad{X} idamax(3,a,1) \\spad{--} should be 1 \\spad{X} idamax(0,a,1) \\spad{--} should be \\spad{-1} \\spad{X} idamax(-5,a,1) \\spad{--} should be \\spad{-1} \\spad{X} idamax(5,a,-1) \\spad{--} should be \\spad{-1} \\spad{X} idamax(5,a,2) \\spad{--} should be 0 \\spad{X} idamax(1,a,0) \\spad{--} should be \\spad{-1} \\spad{X} idamax(1,a,-1) \\spad{--} should be \\spad{-1} \\spad{X} a:PRIMARR(DFLOAT):=[[3.0, 4.0, -3.0, -5.0, -1.0]] \\spad{X} idamax(5,a,1) \\spad{--} should be 3")) (|icamax| (((|Integer|) (|Integer|) (|PrimitiveArray| (|Complex| (|Float|))) (|Integer|)) "\\spad{icamax computes} the largest absolute value of the elements of the array and returns the index of the first instance of the maximum \\blankline \\spad{X} a:PRIMARR(COMPLEX(FLOAT)) \\spad{X} a:=[[3.+4.*\\%i,-4.+5.*\\%i,5.+6.*\\%i,7.-8.*\\%i,-9.-2.*\\%i]] \\spad{X} icamax(5,a,1) \\spad{--} should be 3 \\spad{X} icamax(0,a,1) \\spad{--} should be \\spad{-1} \\spad{X} icamax(5,a,-1) \\spad{--} should be \\spad{-1} \\spad{X} icamax(3,a,1) \\spad{--} should be 2 \\spad{X} icamax(3,a,2) \\spad{--} should be 1")) (|dznrm2| (((|DoubleFloat|) (|SingleInteger|) (|PrimitiveArray| (|Complex| (|DoubleFloat|))) (|SingleInteger|)) "\\spad{dznrm2 returns} the norm of a complex vector. It computes sqrt(sum(v*conjugate(v))) \\blankline \\spad{X} a:PRIMARR(COMPLEX(DFLOAT)) \\spad{X} a:=[[3.+4.*\\%i,-4.+5.*\\%i,5.+6.*\\%i,7.-8.*\\%i,-9.-2.*\\%i]] \\spad{X} dznrm2(5,a,1) \\spad{--} should be 18.028 \\spad{X} dznrm2(3,a,2) \\spad{--} should be 13.077 \\spad{X} dznrm2(3,a,1) \\spad{--} should be 11.269 \\spad{X} dznrm2(3,a,-1) \\spad{--} should be 0.0 \\spad{X} dznrm2(-3,a,-1) \\spad{--} should be 0.0 \\spad{X} dznrm2(1,a,1) \\spad{--} should be 5.0 \\spad{X} dznrm2(1,a,2) \\spad{--} should be 5.0")) (|dzasum| (((|DoubleFloat|) (|SingleInteger|) (|PrimitiveArray| (|Complex| (|DoubleFloat|))) (|SingleInteger|)) "\\spad{dzasum takes} the sum over all of the array where each element of the array sum is the sum of the absolute value of the real part and the absolute value of the imaginary part of each array element: \\indented{3}{for \\spad{i} in array do sum = sum + (real(a(i)) + imag(a(i)))} \\blankline \\spad{X} d:PRIMARR(COMPLEX(DFLOAT)):=[[1.0+2.0*\\%i,-3.0+4.0*\\%i,5.0-6.0*\\%i]] \\spad{X} dzasum(3,d,1) \\spad{--} 21.0 \\spad{X} dzasum(3,d,2) \\spad{--} 14.0 \\spad{X} dzasum(-3,d,1) \\spad{--} 0.0")) (|dswap| (((|List| (|PrimitiveArray| (|DoubleFloat|))) (|SingleInteger|) (|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|) (|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|)) "\\spad{dswap swaps} elements from the first vector with the second Note that the arrays are modified in place. \\blankline \\spad{X} dx:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dy:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dswap(5,dx,1,dy,1) \\spad{X} dx:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dy:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dswap(3,dx,2,dy,2) \\spad{X} dx:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dy:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dswap(5,dx,1,dy,-1)")) (|dscal| (((|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|) (|DoubleFloat|) (|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|)) "\\spad{dscal scales} each element of the vector by the scalar so dscal(n,da,dx,incx) = da*dx for \\spad{n} elements, incremented by incx Note that the \\spad{dx} array is modified in place. \\blankline \\spad{X} dx:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dscal(6,2.0,dx,1) \\spad{X} \\spad{dx} \\spad{X} dx:PRIMARR(DFLOAT):=[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]] \\spad{X} dscal(3,0.5,dx,1) \\spad{X} \\spad{dx}")) (|drot| (((|List| (|PrimitiveArray| (|DoubleFloat|))) (|SingleInteger|) (|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|) (|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|) (|DoubleFloat|) (|DoubleFloat|)) "\\spad{drot computes} a 2D plane Givens rotation spanned by two coordinate axes. It modifies the arrays in place. The call drot(n,dx,incx,dy,incy,c,s) has the \\spad{dx} array which contains the \\spad{y} axis locations and dy which contains the \\spad{y} axis locations. They are rotated in parallel where \\spad{c} is the cosine of the angle and \\spad{s} is the sine of the angle and \\spad{c^2+s^2} = 1 \\blankline \\spad{X} dx:PRIMARR(DFLOAT):=[[6,0, 1.0, 4.0, -1.0, -1.0]] \\spad{X} dy:PRIMARR(DFLOAT):=[[5.0, 1.0, -4.0, 4.0, -4.0]] \\spad{X} drot(5,dx,1,dy,1,0.707106781,0.707106781) \\spad{--} rotate by 45 degrees \\spad{X} \\spad{dx} \\spad{--} \\spad{dx} has been modified \\spad{X} dy \\spad{--} dy has been modified \\spad{X} drot(5,dx,1,dy,1,0.707106781,-0.707106781) \\spad{--} rotate by \\spad{-45} degrees \\spad{X} \\spad{dx} \\spad{--} \\spad{dx} has been modified \\spad{X} dy \\spad{--} dy has been modified")) (|drotg| (((|PrimitiveArray| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) "\\spad{drotg computes} a 2D plane Givens rotation spanned by two coordinate axes. \\blankline \\spad{X} a:MATRIX(DFLOAT):=[[6,5,0],[5,1,4],[0,4,3]] \\spad{X} drotg(elt(a,1,1),elt(a,1,2),0.0D0,0.0D0)")) (|dnrm2| (((|DoubleFloat|) (|SingleInteger|) (|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|)) "\\spad{dnrm2 takes} the norm of the vector, ||x|| \\blankline \\spad{X} a:PRIMARR(DFLOAT):=[[3.0, -4.0, 5.0, -7.0, 9.0]] \\spad{X} dnrm2(3,a,1) \\spad{--} 7.0710678118654755 = \\spad{sqrt(3.0^2} + \\spad{-4.0^2} + 5.0^2) \\spad{X} dnrm2(5,a,1) \\spad{--} 13.416407864998739 = sqrt(180.0) \\spad{X} dnrm2(3,a,2) \\spad{--} 10.72380529476361 = sqrt(115.0)")) (|ddot| (((|DoubleFloat|) (|SingleInteger|) (|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|) (|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|)) "\\spad{ddot(n,x,incx,y,incy)} computes the vector dot product of elements from the vector \\spad{x} and the vector \\spad{y} If the indicies are negative the elements are taken relative to the far end of the vector. \\blankline \\spad{X} x:PRIMARR(DFLOAT):=[[1.0,2.0,3.0,4.0,5.0]] \\spad{X} y:PRIMARR(DFLOAT):=[[5.0,6.0,7.0,8.0,9.0]] \\spad{X} ddot(0,a,1,b,1) \\spad{--} handle 0 elements \\spad{==>} 0 \\spad{X} ddot(3,a,1,b,1) \\spad{--} (1,2,3) * (5,6,7) \\spad{==>} 38.0 \\spad{X} ddot(3,a,1,b,2) \\spad{--} increment = 2 in \\spad{b} (1,2,3) * (5,7,9) \\spad{==>} 46.0 \\spad{X} ddot(3,a,2,b,1) \\spad{--} increment = 2 in a (1,3,5) * (5,6,7) \\spad{==>} 58.0 \\spad{X} ddot(3,a,1,b,-2) \\spad{--} increment = \\spad{-2} in \\spad{b} (1,2,3) * (9,7,5) \\spad{==>} 38.0 \\spad{X} ddot(2,a,-2,b,1) \\spad{--} increment = \\spad{-2} in a (5,3,1) * (5,6,7) \\spad{==>} 50.0 \\spad{X} ddot(3,a,-2,b,-2) \\spad{--} (5,3,1) * (9,7,5) \\spad{==>} 71.0")) (|dcopy| (((|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|) (|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|) (|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|)) "\\spad{dcopy(n,x,incx,y,incy)} copies \\spad{y} from \\spad{x} for each of the chosen elements of the vectors \\spad{x} and \\spad{y} Note that the vector \\spad{y} is modified with the results. \\blankline \\spad{X} x:PRIMARR(DFLOAT):=[[1.0,2.0,3.0,4.0,5.0,6.0]] \\spad{X} y:PRIMARR(DFLOAT):=[[0.0,0.0,0.0,0.0,0.0,0.0]] \\spad{X} dcopy(6,x,1,y,1) \\spad{X} \\spad{y} \\spad{X} m:PRIMARR(DFLOAT):=[[1.0,2.0,3.0]] \\spad{X} n:PRIMARR(DFLOAT):=[[0.0,0.0,0.0,0.0,0.0,0.0]] \\spad{X} dcopy(3,m,1,n,2) \\spad{X} \\spad{n}")) (|daxpy| (((|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|) (|DoubleFloat|) (|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|) (|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|)) "\\spad{daxpy(n,da,x,incx,y,incy)} computes a \\spad{y} = a*x + \\spad{y} for each of the chosen elements of the vectors \\spad{x} and \\spad{y} and a constant multiplier a Note that the vector \\spad{y} is modified with the results. \\blankline \\spad{X} x:PRIMARR(DFLOAT):=[[1.0,2.0,3.0,4.0,5.0,6.0]] \\spad{X} y:PRIMARR(DFLOAT):=[[1.0,2.0,3.0,4.0,5.0,6.0]] \\spad{X} daxpy(6,2.0,x,1,y,1) \\spad{X} \\spad{y} \\spad{X} m:PRIMARR(DFLOAT):=[[1.0,2.0,3.0]] \\spad{X} n:PRIMARR(DFLOAT):=[[1.0,2.0,3.0,4.0,5.0,6.0]] \\spad{X} daxpy(3,-2.0,m,1,n,2) \\spad{X} \\spad{n}")) (|dasum| (((|DoubleFloat|) (|SingleInteger|) (|PrimitiveArray| (|DoubleFloat|)) (|SingleInteger|)) "\\spad{dasum(n,array,incx)} computes the sum of \\spad{n} elements in \\spad{array} using a stride of \\spad{incx} \\blankline \\spad{X} dx:PRIMARR(DFLOAT):=[[1.0,2.0,3.0,4.0,5.0,6.0]] \\spad{X} dasum(6,dx,1) \\spad{X} dasum(3,dx,2)")) (|dcabs1| (((|DoubleFloat|) (|Complex| (|DoubleFloat|))) "\\spad{dcabs1(z)} computes \\spad{(+} (abs (realpart \\spad{z))} (abs (imagpart z))) \\blankline \\spad{X} t1:Complex DoubleFloat \\spad{:=} complex(1.0,0) \\spad{X} dcabs1(t1)"))) 
NIL 
NIL 
(|BlowUpWithHamburgerNoether|) 
((|constructor| (NIL "This domain is part of the PAFF package"))) 
((|HamburgerNoether| . T)) 
NIL 
(|BlowUpMethodCategory|) 
NIL 
NIL 
NIL 
(|BlowUpWithQuadTrans|) 
((|constructor| (NIL "This domain is part of the PAFF package"))) 
((|QuadraticTransform| . T)) 
NIL 
(|BlowUpPackage| K |symb| |PolyRing| E BLMET) 
((|constructor| (NIL "The following is part of the PAFF package")) (|stepBlowUp| (((|Record| (|:| |mult| (|NonNegativeInteger|)) (|:| |subMult| (|NonNegativeInteger|)) (|:| |blUpRec| (|List| (|Record| (|:| |recTransStr| (|DistributedMultivariatePolynomial| (|construct| (QUOTE X) (QUOTE Y)) |#1|)) (|:| |recPoint| (|AffinePlane| |#1|)) (|:| |recChart| |#5|) (|:| |definingExtension| |#1|))))) (|DistributedMultivariatePolynomial| (|construct| (QUOTE X) (QUOTE Y)) |#1|) (|AffinePlane| |#1|) |#5| |#1|) "\\spad{stepBlowUp(pol,pt,n)} blow-up the point \\spad{pt} on the curve defined by \\spad{pol} in the affine neighbourhood specified by \\spad{n.}")) (|quadTransform| (((|DistributedMultivariatePolynomial| (|construct| (QUOTE X) (QUOTE Y)) |#1|) (|DistributedMultivariatePolynomial| (|construct| (QUOTE X) (QUOTE Y)) |#1|) (|NonNegativeInteger|) |#5|) "\\spad{quadTransform(pol,n,chart)} apply the quadratique transformation to \\spad{pol} specified by \\spad{chart} has in quadTransform(pol,chart) and extract x**n to it, where \\spad{x} is the variable specified by the first integer in \\spad{chart} (blow-up exceptional coordinate).")) (|applyTransform| ((|#3| |#3| |#5|) "quadTransform(pol,chart) apply the quadratique transformation to pol specified by chart which consist of 3 integers. The last one indicates which varibles is set to 1, the first on indicates which variable remains unchange, and the second one indicates which variable oon which the transformation is applied. For example, [2,3,1] correspond to the following: \\spad{x} \\spad{->} 1, \\spad{y} \\spad{->} \\spad{y,} \\spad{z} \\spad{->} \\spad{yz} (here the variable are [x,y,z] in BlUpRing)."))) 
NIL 
NIL 
(|BiModule| R S) 
((|constructor| (NIL "A \\spadtype{BiModule} is both a left and right module with respect to potentially different rings. \\blankline Axiom\\br \\tab{5}\\spad{r*(x*s) = (r*x)*s}")) (|rightUnitary| ((|attribute|) "\\spad{x * 1 = \\spad{x}}")) (|leftUnitary| ((|attribute|) "\\spad{1 * \\spad{x} = \\spad{x}}"))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|Boolean|) 
((|constructor| (NIL "\\spadtype{Boolean} is the elementary logic with 2 values: \\spad{true} and \\spad{false}")) (|test| (((|Boolean|) $) "\\spad{test(b)} returns \\spad{b} and is provided for compatibility with the new compiler.")) (|implies| (($ $ $) "\\spad{implies(a,b)} returns the logical implication of Boolean \\spad{a} and \\spad{b.}")) (|nor| (($ $ $) "\\spad{nor(a,b)} returns the logical negation of \\spad{a} or \\spad{b.}")) (|nand| (($ $ $) "\\spad{nand(a,b)} returns the logical negation of \\spad{a} and \\spad{b.}")) (|xor| (($ $ $) "\\spad{xor(a,b)} returns the logical exclusive or of Boolean \\spad{a} and \\spad{b.}")) (|or| (($ $ $) "\\spad{a or \\spad{b}} returns the logical inclusive or of Boolean \\spad{a} and \\spad{b.}")) (|and| (($ $ $) "\\spad{a and \\spad{b}} returns the logical and of Boolean \\spad{a} and \\spad{b.}")) (|not| (($ $) "\\spad{not \\spad{n}} returns the negation of \\spad{n.}")) (^ (($ $) "\\spad{^ \\spad{n}} returns the negation of \\spad{n.}")) (|false| (($) "\\spad{false} is a logical constant.")) (|true| (($) "\\spad{true} is a logical constant."))) 
NIL 
NIL 
(|BasicOperatorFunctions1| A) 
((|constructor| (NIL "This package exports functions to set some commonly used properties of operators, including properties which contain functions.")) (|constantOpIfCan| (((|Union| |#1| "failed") (|BasicOperator|)) "\\spad{constantOpIfCan(op)} returns \\spad{a} if \\spad{op} is the constant nullary operator always returning \\spad{a}, \"failed\" otherwise.")) (|constantOperator| (((|BasicOperator|) |#1|) "\\spad{constantOperator(a)} returns a nullary operator op such that \\spad{op()} always evaluate to \\spad{a}.")) (|derivative| (((|Union| (|List| (|Mapping| |#1| (|List| |#1|))) "failed") (|BasicOperator|)) "\\spad{derivative(op)} returns the value of the \"\\%diff\" property of \\spad{op} if it has one, and \"failed\" otherwise.") (((|BasicOperator|) (|BasicOperator|) (|Mapping| |#1| |#1|)) "\\spad{derivative(op, foo)} attaches foo as the \"\\%diff\" property of op. If \\spad{op} has an \"\\%diff\" property \\spad{f,} then applying a derivation \\spad{D} to op(a) returns \\spad{f(a) * D(a)}. Argument \\spad{op} must be unary.") (((|BasicOperator|) (|BasicOperator|) (|List| (|Mapping| |#1| (|List| |#1|)))) "\\spad{derivative(op, [foo1,...,foon])} attaches [foo1,...,foon] as the \"\\%diff\" property of op. If \\spad{op} has an \"\\%diff\" property \\spad{[f1,...,fn]} then applying a derivation \\spad{D} to \\spad{op(a1,...,an)} returns \\spad{f1(a1,...,an) * D(a1) + \\spad{...} + fn(a1,...,an) * D(an)}.")) (|evaluate| (((|Union| (|Mapping| |#1| (|List| |#1|)) "failed") (|BasicOperator|)) "\\spad{evaluate(op)} returns the value of the \"\\%eval\" property of \\spad{op} if it has one, and \"failed\" otherwise.") (((|BasicOperator|) (|BasicOperator|) (|Mapping| |#1| |#1|)) "\\spad{evaluate(op, foo)} attaches foo as the \"\\%eval\" property of op. If \\spad{op} has an \"\\%eval\" property \\spad{f,} then applying \\spad{op} to a returns the result of \\spad{f(a)}. Argument \\spad{op} must be unary.") (((|BasicOperator|) (|BasicOperator|) (|Mapping| |#1| (|List| |#1|))) "\\spad{evaluate(op, foo)} attaches foo as the \"\\%eval\" property of op. If \\spad{op} has an \"\\%eval\" property \\spad{f,} then applying \\spad{op} to \\spad{(a1,...,an)} returns the result of \\spad{f(a1,...,an)}.") (((|Union| |#1| "failed") (|BasicOperator|) (|List| |#1|)) "\\spad{evaluate(op, [a1,...,an])} checks if \\spad{op} has an \"\\%eval\" property \\spad{f.} If it has, then \\spad{f(a1,...,an)} is returned, and \"failed\" otherwise."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|OrderedSet|)))) 
(|BasicOperator|) 
((|constructor| (NIL "Basic system operators. A basic operator is an object that can be applied to a list of arguments from a set, the result being a kernel over that set.")) (|setProperties| (($ $ (|AssociationList| (|String|) (|None|))) "\\spad{setProperties(op, \\spad{l)}} sets the property list of \\spad{op} to \\spad{l.} Argument \\spad{op} is modified \"in place\", \\spadignore{i.e.} no copy is made.")) (|setProperty| (($ $ (|String|) (|None|)) "\\spad{setProperty(op, \\spad{s,} \\spad{v)}} attaches property \\spad{s} to op, and sets its value to \\spad{v.} Argument \\spad{op} is modified \"in place\", \\spadignore{i.e.} no copy is made.")) (|property| (((|Union| (|None|) "failed") $ (|String|)) "\\spad{property(op, \\spad{s)}} returns the value of property \\spad{s} if it is attached to op, and \"failed\" otherwise.")) (|deleteProperty!| (($ $ (|String|)) "\\spad{deleteProperty!(op, \\spad{s)}} unattaches property \\spad{s} from op. Argument \\spad{op} is modified \"in place\", \\spadignore{i.e.} no copy is made.")) (|assert| (($ $ (|String|)) "\\spad{assert(op, \\spad{s)}} attaches property \\spad{s} to op. Argument \\spad{op} is modified \"in place\", \\spadignore{i.e.} no copy is made.")) (|has?| (((|Boolean|) $ (|String|)) "\\spad{has?(op, \\spad{s)}} tests if property \\spad{s} is attached to op.")) (|is?| (((|Boolean|) $ (|Symbol|)) "\\spad{is?(op, \\spad{s)}} tests if the name of \\spad{op} is \\spad{s.}")) (|input| (((|Union| (|Mapping| (|InputForm|) (|List| (|InputForm|))) "failed") $) "\\spad{input(op)} returns the \"\\%input\" property of \\spad{op} if it has one attached, \"failed\" otherwise.") (($ $ (|Mapping| (|InputForm|) (|List| (|InputForm|)))) "\\spad{input(op, foo)} attaches foo as the \"\\%input\" property of op. If \\spad{op} has a \"\\%input\" property \\spad{f,} then \\spad{op(a1,...,an)} gets converted to InputForm as \\spad{f(a1,...,an)}.")) (|display| (($ $ (|Mapping| (|OutputForm|) (|OutputForm|))) "\\spad{display(op, foo)} attaches foo as the \"\\%display\" property of op. If \\spad{op} has a \"\\%display\" property \\spad{f,} then \\spad{op(a)} gets converted to OutputForm as \\spad{f(a)}. Argument \\spad{op} must be unary.") (($ $ (|Mapping| (|OutputForm|) (|List| (|OutputForm|)))) "\\spad{display(op, foo)} attaches foo as the \"\\%display\" property of op. If \\spad{op} has a \"\\%display\" property \\spad{f,} then \\spad{op(a1,...,an)} gets converted to OutputForm as \\spad{f(a1,...,an)}.") (((|Union| (|Mapping| (|OutputForm|) (|List| (|OutputForm|))) "failed") $) "\\spad{display(op)} returns the \"\\%display\" property of \\spad{op} if it has one attached, and \"failed\" otherwise.")) (|comparison| (($ $ (|Mapping| (|Boolean|) $ $)) "\\spad{comparison(op, foo?)} attaches foo? as the \"\\%less?\" property to op. If \\spad{op1} and \\spad{op2} have the same name, and one of them has a \"\\%less?\" property \\spad{f,} then \\spad{f(op1, op2)} is called to decide whether \\spad{op1 < op2}.")) (|equality| (($ $ (|Mapping| (|Boolean|) $ $)) "\\spad{equality(op, foo?)} attaches foo? as the \"\\%equal?\" property to op. If \\spad{op1} and \\spad{op2} have the same name, and one of them has an \"\\%equal?\" property \\spad{f,} then \\spad{f(op1, op2)} is called to decide whether \\spad{op1} and \\spad{op2} should be considered equal.")) (|weight| (($ $ (|NonNegativeInteger|)) "\\spad{weight(op, \\spad{n)}} attaches the weight \\spad{n} to op.") (((|NonNegativeInteger|) $) "\\spad{weight(op)} returns the weight attached to op.")) (|nary?| (((|Boolean|) $) "\\spad{nary?(op)} tests if \\spad{op} has arbitrary arity.")) (|unary?| (((|Boolean|) $) "\\spad{unary?(op)} tests if \\spad{op} is unary.")) (|nullary?| (((|Boolean|) $) "\\spad{nullary?(op)} tests if \\spad{op} is nullary.")) (|arity| (((|Union| (|NonNegativeInteger|) "failed") $) "\\spad{arity(op)} returns \\spad{n} if \\spad{op} is n-ary, and \"failed\" if \\spad{op} has arbitrary arity.")) (|operator| (($ (|Symbol|) (|NonNegativeInteger|)) "\\spad{operator(f, \\spad{n)}} makes \\spad{f} into an n-ary operator.") (($ (|Symbol|)) "\\spad{operator(f)} makes \\spad{f} into an operator with arbitrary arity.")) (|copy| (($ $) "\\spad{copy(op)} returns a copy of op.")) (|properties| (((|AssociationList| (|String|) (|None|)) $) "\\spad{properties(op)} returns the list of all the properties currently attached to op.")) (|name| (((|Symbol|) $) "\\spad{name(op)} returns the name of op."))) 
NIL 
NIL 
(|BoundIntegerRoots| F UP) 
((|constructor| (NIL "\\spadtype{BoundIntegerRoots} provides functions to find lower bounds on the integer roots of a polynomial.")) (|integerBound| (((|Integer|) |#2|) "\\spad{integerBound(p)} returns a lower bound on the negative integer roots of \\spad{p,} and 0 if \\spad{p} has no negative integer roots."))) 
NIL 
NIL 
(|BalancedPAdicInteger| |p|) 
((|constructor| (NIL "Stream-based implementation of \\spad{Zp:} p-adic numbers are represented as sum(i = 0.., a[i] * p^i), where the a[i] lie in \\spad{-(p} - 1)/2,...,(p - 1)/2."))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|BalancedPAdicRational| |p|) 
((|constructor| (NIL "Stream-based implementation of \\spad{Qp:} numbers are represented as sum(i = k.., a[i] * p^i), where the a[i] lie in \\spad{-(p} - 1)/2,...,(p - 1)/2."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|RealConstant|))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|StepThrough|))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|DifferentialRing|))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (LIST (QUOTE |BalancedPAdicInteger|) (|devaluate| |#1|)))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (LIST (QUOTE |Evalable|) (LIST (QUOTE |BalancedPAdicInteger|) (|devaluate| |#1|)))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (LIST (QUOTE |Eltable|) (LIST (QUOTE |BalancedPAdicInteger|) (|devaluate| |#1|)) (LIST (QUOTE |BalancedPAdicInteger|) (|devaluate| |#1|)))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|IntegerNumberSystem|))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|OrderedSet|))) (OR (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|OrderedSet|)))) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| (|BalancedPAdicInteger| |#1|) (QUOTE (|CharacteristicNonZero|))))) 
(|BinaryRecursiveAggregate&| A S) 
((|constructor| (NIL "A binary-recursive aggregate has 0, 1 or 2 children and serves as a model for a binary tree or a doubly-linked aggregate structure")) (|setright!| (($ $ $) "\\spad{setright!(a,x)} sets the right child of \\spad{t} to be \\spad{x.}")) (|setleft!| (($ $ $) "\\spad{setleft!(a,b)} sets the left child of \\axiom{a} to be \\spad{b.}")) (|setelt| (($ $ "right" $) "\\spad{setelt(a,\"right\",b)} (also written \\axiom{b . right \\spad{:=} \\spad{b})} is equivalent to \\axiom{setright!(a,b)}.") (($ $ "left" $) "\\spad{setelt(a,\"left\",b)} (also written \\axiom{a . left \\spad{:=} \\spad{b})} is equivalent to \\axiom{setleft!(a,b)}.")) (|right| (($ $) "\\spad{right(a)} returns the right child.")) (|elt| (($ $ "right") "\\spad{elt(a,\"right\")} (also written: \\axiom{a . right}) is equivalent to \\axiom{right(a)}.") (($ $ "left") "\\spad{elt(u,\"left\")} (also written: \\axiom{a . left}) is equivalent to \\axiom{left(a)}.")) (|left| (($ $) "\\spad{left(u)} returns the left child."))) 
NIL 
((|HasAttribute| |#1| (QUOTE |shallowlyMutable|))) 
(|BinaryRecursiveAggregate| S) 
((|constructor| (NIL "A binary-recursive aggregate has 0, 1 or 2 children and serves as a model for a binary tree or a doubly-linked aggregate structure")) (|setright!| (($ $ $) "\\spad{setright!(a,x)} sets the right child of \\spad{t} to be \\spad{x.}")) (|setleft!| (($ $ $) "\\spad{setleft!(a,b)} sets the left child of \\axiom{a} to be \\spad{b.}")) (|setelt| (($ $ "right" $) "\\spad{setelt(a,\"right\",b)} (also written \\axiom{b . right \\spad{:=} \\spad{b})} is equivalent to \\axiom{setright!(a,b)}.") (($ $ "left" $) "\\spad{setelt(a,\"left\",b)} (also written \\axiom{a . left \\spad{:=} \\spad{b})} is equivalent to \\axiom{setleft!(a,b)}.")) (|right| (($ $) "\\spad{right(a)} returns the right child.")) (|elt| (($ $ "right") "\\spad{elt(a,\"right\")} (also written: \\axiom{a . right}) is equivalent to \\axiom{right(a)}.") (($ $ "left") "\\spad{elt(u,\"left\")} (also written: \\axiom{a . left}) is equivalent to \\axiom{left(a)}.")) (|left| (($ $) "\\spad{left(u)} returns the left child."))) 
((|nil| . T)) 
NIL 
(|BrillhartTests| UP) 
((|constructor| (NIL "This package has no description")) (|noLinearFactor?| (((|Boolean|) |#1|) "\\spad{noLinearFactor?(p)} returns \\spad{true} if \\spad{p} can be shown to have no linear factor by a theorem of Lehmer, \\spad{false} else. \\spad{I} insist on the fact that \\spad{false} does not mean that \\spad{p} has a linear factor.")) (|brillhartTrials| (((|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{brillhartTrials(n)} sets to \\spad{n} the number of tests in \\spadfun{brillhartIrreducible?} and returns the previous value.") (((|NonNegativeInteger|)) "\\spad{brillhartTrials()} returns the number of tests in \\spadfun{brillhartIrreducible?}.")) (|brillhartIrreducible?| (((|Boolean|) |#1| (|Boolean|)) "\\spad{brillhartIrreducible?(p,noLinears)} returns \\spad{true} if \\spad{p} can be shown to be irreducible by a remark of Brillhart, \\spad{false} else. If \\spad{noLinears} is \\spad{true}, we are being told \\spad{p} has no linear factors \\spad{false} does not mean that \\spad{p} is reducible.") (((|Boolean|) |#1|) "\\spad{brillhartIrreducible?(p)} returns \\spad{true} if \\spad{p} can be shown to be irreducible by a remark of Brillhart, \\spad{false} is inconclusive."))) 
NIL 
NIL 
(|BasicStochasticDifferential|) 
((|constructor| (NIL "Based on Symbol: a domain of symbols representing basic stochastic differentials, used in StochasticDifferential(R) in the underlying sparse multivariate polynomial representation. \\blankline We create new \\spad{BSD} only by coercion from Symbol using a special function introduce! first of all to add to a private set SDset. We allow a separate function convertIfCan which will check whether the argument has previously been declared as a BSD.")) (|getSmgl| (((|Union| (|Symbol|) "failed") $) "\\indented{1}{getSmgl(bsd) returns the semimartingale \\axiom{S} related} \\indented{1}{to the basic stochastic differential \\axiom{bsd} \\spad{by}} \\indented{1}{\\axiom{introduce!}} \\blankline \\spad{X} introduce!(t,dt) \\spad{--} \\spad{dt} is a new stochastic differential \\spad{X} getSmgl(dt::BSD)")) (|copyIto| (((|Table| (|Symbol|) $)) "\\indented{1}{copyIto() returns the table relating semimartingales} \\indented{1}{to basic stochastic differentials.} \\blankline \\spad{X} introduce!(t,dt) \\spad{--} \\spad{dt} is a new stochastic differential \\spad{X} copyIto()")) (|copyBSD| (((|List| $)) "\\indented{1}{copyBSD() returns \\axiom{setBSD} as a list of \\axiom{BSD}.} \\blankline \\spad{X} introduce!(t,dt) \\spad{--} \\spad{dt} is a new stochastic differential \\spad{X} copyBSD()")) (|d| (((|Union| $ (|Integer|)) (|Symbol|)) "\\spad{d(X)} returns \\axiom{dX} if \\axiom{tableIto(X)=dX} and otherwise returns \\axiom{0}")) (|introduce!| (((|Union| $ "failed") (|Symbol|) (|Symbol|)) "\\indented{1}{introduce!(X,dX) returns \\axiom{dX} as \\axiom{BSD} if it} \\indented{1}{isn't already in \\axiom{BSD}} \\blankline \\spad{X} introduce!(t,dt) \\spad{--} \\spad{dt} is a new stochastic differential \\spad{X} copyBSD()")) (|convert| (($ (|Symbol|)) "\\spad{convert(dX)} transforms \\axiom{dX} into a \\axiom{BSD} if possible and otherwise produces an error.")) (|convertIfCan| (((|Union| $ "failed") (|Symbol|)) "\\spad{convertIfCan(ds)} transforms \\axiom{dX} into a \\axiom{BSD} if possible (if \\axiom{introduce(X,dX)} has been invoked previously)."))) 
NIL 
NIL 
(|BinarySearchTree| S) 
((|constructor| (NIL "BinarySearchTree(S) is the domain of a binary trees where elements are ordered across the tree. A binary search tree is either empty or has a value which is an \\spad{S,} and a right and left which are both BinaryTree(S) Elements are ordered across the tree.")) (|split| (((|Record| (|:| |less| $) (|:| |greater| $)) |#1| $) "\\indented{1}{split(x,b) splits binary tree \\spad{b} into two trees, one with elements} \\indented{1}{greater than \\spad{x,} the other with elements less than \\spad{x.}} \\blankline \\spad{X} t1:=binarySearchTree [1,2,3,4] \\spad{X} split(3,t1)")) (|insertRoot!| (($ |#1| $) "\\indented{1}{insertRoot!(x,b) inserts element \\spad{x} as a root of binary search tree \\spad{b.}} \\blankline \\spad{X} t1:=binarySearchTree [1,2,3,4] \\spad{X} insertRoot!(5,t1)")) (|insert!| (($ |#1| $) "\\indented{1}{insert!(x,b) inserts element \\spad{x} as leaves into binary search tree \\spad{b.}} \\blankline \\spad{X} t1:=binarySearchTree [1,2,3,4] \\spad{X} insert!(5,t1)")) (|binarySearchTree| (($ (|List| |#1|)) "\\indented{1}{binarySearchTree(l) is not documented} \\blankline \\spad{X} binarySearchTree [1,2,3,4]"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|BitAggregate&| S) 
((|constructor| (NIL "The bit aggregate category models aggregates representing large quantities of Boolean data.")) (|xor| (($ $ $) "\\spad{xor(a,b)} returns the logical exclusive-or of bit aggregates \\axiom{a} and \\axiom{b}.")) (|or| (($ $ $) "\\spad{a or \\spad{b}} returns the logical or of bit aggregates \\axiom{a} and \\axiom{b}.")) (|and| (($ $ $) "\\spad{a and \\spad{b}} returns the logical and of bit aggregates \\axiom{a} and \\axiom{b}.")) (|nor| (($ $ $) "\\spad{nor(a,b)} returns the logical nor of bit aggregates \\axiom{a} and \\axiom{b}.")) (|nand| (($ $ $) "\\spad{nand(a,b)} returns the logical nand of bit aggregates \\axiom{a} and \\axiom{b}.")) (^ (($ $) "\\spad{^ \\spad{b}} returns the logical not of bit aggregate \\axiom{b}.")) (|not| (($ $) "\\spad{not(b)} returns the logical not of bit aggregate \\axiom{b}."))) 
NIL 
NIL 
(|BitAggregate|) 
((|constructor| (NIL "The bit aggregate category models aggregates representing large quantities of Boolean data.")) (|xor| (($ $ $) "\\spad{xor(a,b)} returns the logical exclusive-or of bit aggregates \\axiom{a} and \\axiom{b}.")) (|or| (($ $ $) "\\spad{a or \\spad{b}} returns the logical or of bit aggregates \\axiom{a} and \\axiom{b}.")) (|and| (($ $ $) "\\spad{a and \\spad{b}} returns the logical and of bit aggregates \\axiom{a} and \\axiom{b}.")) (|nor| (($ $ $) "\\spad{nor(a,b)} returns the logical nor of bit aggregates \\axiom{a} and \\axiom{b}.")) (|nand| (($ $ $) "\\spad{nand(a,b)} returns the logical nand of bit aggregates \\axiom{a} and \\axiom{b}.")) (^ (($ $) "\\spad{^ \\spad{b}} returns the logical not of bit aggregate \\axiom{b}.")) (|not| (($ $) "\\spad{not(b)} returns the logical not of bit aggregate \\axiom{b}."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|BinaryTreeCategory&| A S) 
((|constructor| (NIL "\\spadtype{BinaryTreeCategory(S)} is the category of binary trees: a tree which is either empty or else is a \\spadfun{node} consisting of a value and a \\spadfun{left} and \\spadfun{right}, both binary trees.")) (|node| (($ $ |#2| $) "\\spad{node(left,v,right)} creates a binary tree with value \\spad{v}, a binary tree \\spad{left}, and a binary tree \\spad{right}. \\blankline")) (|finiteAggregate| ((|attribute|) "Binary trees have a finite number of components")) (|shallowlyMutable| ((|attribute|) "Binary trees have updateable components"))) 
NIL 
NIL 
(|BinaryTreeCategory| S) 
((|constructor| (NIL "\\spadtype{BinaryTreeCategory(S)} is the category of binary trees: a tree which is either empty or else is a \\spadfun{node} consisting of a value and a \\spadfun{left} and \\spadfun{right}, both binary trees.")) (|node| (($ $ |#1| $) "\\spad{node(left,v,right)} creates a binary tree with value \\spad{v}, a binary tree \\spad{left}, and a binary tree \\spad{right}. \\blankline")) (|finiteAggregate| ((|attribute|) "Binary trees have a finite number of components")) (|shallowlyMutable| ((|attribute|) "Binary trees have updateable components"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|BinaryTournament| S) 
((|constructor| (NIL "BinaryTournament creates a binary tournament with the elements of \\spad{ls} as values at the nodes.")) (|insert!| (($ |#1| $) "\\indented{1}{insert!(x,b) inserts element \\spad{x} as leaves into binary tournament \\spad{b.}} \\blankline \\spad{X} t1:=binaryTournament [1,2,3,4] \\spad{X} insert!(5,t1) \\spad{X} \\spad{t1}")) (|binaryTournament| (($ (|List| |#1|)) "\\indented{1}{binaryTournament(ls) creates a binary tournament with the} \\indented{1}{elements of \\spad{ls} as values at the nodes.} \\blankline \\spad{X} binaryTournament [1,2,3,4]"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|BinaryTree| S) 
((|constructor| (NIL "\\spadtype{BinaryTree(S)} is the domain of all binary trees. A binary tree over \\spad{S} is either empty or has a \\spadfun{value} which is an \\spad{S} and a \\spadfun{right} and \\spadfun{left} which are both binary trees.")) (|binaryTree| (($ $ |#1| $) "\\indented{1}{binaryTree(l,v,r) creates a binary tree with} \\indented{1}{value \\spad{v} with left subtree \\spad{l} and right subtree \\spad{r.}} \\blankline \\spad{X} t1:=binaryTree([1,2,3]) \\spad{X} t2:=binaryTree([4,5,6]) \\spad{X} binaryTree(t1,[7,8,9],t2)") (($ |#1|) "\\indented{1}{binaryTree(v) is an non-empty binary tree} \\indented{1}{with value \\spad{v,} and left and right empty.} \\blankline \\spad{X} t1:=binaryTree([1,2,3])"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|CancellationAbelianMonoid|) 
((|constructor| (NIL "This is an \\spadtype{AbelianMonoid} with the cancellation property, \\spadignore{i.e.} \\tab{5}\\spad{ a+b = a+c \\spad{=>} \\spad{b=c} }.\\br This is formalised by the partial subtraction operator, which satisfies the Axioms\\br \\tab{5}\\spad{c = a+b \\spad{<=>} \\spad{c-b} = a}")) (|subtractIfCan| (((|Union| $ "failed") $ $) "\\spad{subtractIfCan(x, \\spad{y)}} returns an element \\spad{z} such that \\spad{z+y=x} or \"failed\" if no such element exists."))) 
NIL 
NIL 
(|CachableSet|) 
((|constructor| (NIL "A cachable set is a set whose elements keep an integer as part of their structure.")) (|setPosition| (((|Void|) $ (|NonNegativeInteger|)) "\\spad{setPosition(x, \\spad{n)}} associates the integer \\spad{n} to \\spad{x.}")) (|position| (((|NonNegativeInteger|) $) "\\spad{position(x)} returns the integer \\spad{n} associated to \\spad{x.}"))) 
NIL 
NIL 
(|CylindricalAlgebraicDecompositionPackage| |TheField|) 
NIL 
NIL 
NIL 
(|CylindricalAlgebraicDecompositionUtilities| R P) 
((|gcdBasisAdd| (((|List| |#2|) |#2| (|List| |#2|)) "add one polynomial to list of pairwise relatively prime polynomials")) (|gcdBasis| (((|List| |#2|) (|List| |#2|)) "decompose a list of polynomials into pairwise relatively prime polynomials")) (|squareFreeBasis| (((|List| |#2|) (|List| |#2|)) "\\blankline"))) 
NIL 
NIL 
(|CardinalNumber|) 
((|constructor| (NIL "Members of the domain CardinalNumber are values indicating the cardinality of sets, both finite and infinite. Arithmetic operations are defined on cardinal numbers as follows. \\blankline If \\spad{x = \\spad{#X}} and \\spad{y = \\spad{#Y}} then\\br \\tab{5}\\spad{x+y = \\#(X+Y)} \\tab{5}disjoint union\\br \\tab{5}\\spad{x-y = \\#(X-Y)} \\tab{5}relative complement\\br \\tab{5}\\spad{x*y = \\#(X*Y)} \\tab{5}cartesian product\\br \\tab{5}\\spad{x**y = \\#(X**Y)} \\tab{4}\\spad{X**Y = \\spad{g|} g:Y->X} \\blankline The non-negative integers have a natural construction as cardinals\\br \\spad{0 = \\#\\{\\}}, \\spad{1 = \\{0\\}}, \\spad{2 = \\{0, 1\\}}, ..., \\spad{n = \\{i| 0 \\spad{<=} \\spad{i} < n\\}}. \\blankline That \\spad{0} acts as a zero for the multiplication of cardinals is equivalent to the axiom of choice. \\blankline The generalized continuum hypothesis asserts \\spad{\\br} \\spad{2**Aleph \\spad{i} = Aleph(i+1)} and is independent of the axioms of set theory [Goedel 1940]. \\blankline Three commonly encountered cardinal numbers are\\br \\tab{5}\\spad{a = \\spad{#Z}} \\tab{5}countable infinity\\br \\tab{5}\\spad{c = \\spad{#R}} \\tab{5}the continuum\\br \\tab{5}\\spad{f = \\# \\spad{g} | g:[0,1]->R\\} \\blankline In this domain, these values are obtained using\\br \\tab{5}\\spad{a \\spad{:=} Aleph 0}, \\spad{c \\spad{:=} 2**a}, \\spad{f \\spad{:=} 2**c}.")) (|generalizedContinuumHypothesisAssumed| (((|Boolean|) (|Boolean|)) "\\indented{1}{generalizedContinuumHypothesisAssumed(bool)} \\indented{1}{is used to dictate whether the hypothesis is to be assumed.} \\blankline \\spad{X} generalizedContinuumHypothesisAssumed \\spad{true} \\spad{X} a:=Aleph 0 \\spad{X} c:=2**a \\spad{X} f:=2**c")) (|generalizedContinuumHypothesisAssumed?| (((|Boolean|)) "\\indented{1}{generalizedContinuumHypothesisAssumed?()} \\indented{1}{tests if the hypothesis is currently assumed.} \\blankline \\spad{X} generalizedContinuumHypothesisAssumed?")) (|countable?| (((|Boolean|) $) "\\indented{1}{countable?(\\spad{a}) determines} \\indented{1}{whether \\spad{a} is a countable cardinal,} \\indented{1}{\\spadignore{i.e.} an integer or \\spad{Aleph 0}.} \\blankline \\spad{X} c2:=2::CardinalNumber \\spad{X} countable? \\spad{c2} \\spad{X} A0:=Aleph 0 \\spad{X} countable? \\spad{A0} \\spad{X} A1:=Aleph 1 \\spad{X} countable? \\spad{A1}")) (|finite?| (((|Boolean|) $) "\\indented{1}{finite?(\\spad{a}) determines whether} \\indented{1}{\\spad{a} is a finite cardinal, \\spadignore{i.e.} an integer.} \\blankline \\spad{X} c2:=2::CardinalNumber \\spad{X} finite? \\spad{c2} \\spad{X} A0:=Aleph 0 \\spad{X} finite? \\spad{A0}")) (|Aleph| (($ (|NonNegativeInteger|)) "\\indented{1}{Aleph(n) provides the named (infinite) cardinal number.} \\blankline \\spad{X} A0:=Aleph 0")) (** (($ $ $) "\\indented{1}{\\spad{x**y} returns \\spad{\\#(X**Y)} where \\spad{X**Y} is defined} \\indented{2}{as \\spad{\\{g| g:Y->X\\}}.} \\blankline \\spad{X} c2:=2::CardinalNumber \\spad{X} \\spad{c2**c2} \\spad{X} A1:=Aleph 1 \\spad{X} \\spad{A1**c2} \\spad{X} generalizedContinuumHypothesisAssumed \\spad{true} \\spad{X} \\spad{A1**A1}")) (- (((|Union| $ "failed") $ $) "\\indented{1}{\\spad{x - \\spad{y}} returns an element \\spad{z} such that} \\indented{1}{\\spad{z+y=x} or \"failed\" if no such element exists.} \\blankline \\spad{X} c2:=2::CardinalNumber \\spad{X} \\spad{c2-c2} \\spad{X} A1:=Aleph 1 \\spad{X} \\spad{A1-c2}")) (|commutative| ((|attribute| "*") "a domain \\spad{D} has \\spad{commutative(\"*\")} if it has an operation \\spad{\"*\": (D,D) \\spad{->} \\spad{D}} which is commutative."))) 
(((|commutative| "*") . T)) 
NIL 
(|CartesianTensorFunctions2| |minix| |dim| S T$) 
((|constructor| (NIL "This package provides functions to enable conversion of tensors given conversion of the components.")) (|map| (((|CartesianTensor| |#1| |#2| |#4|) (|Mapping| |#4| |#3|) (|CartesianTensor| |#1| |#2| |#3|)) "\\spad{map(f,ts)} does a componentwise conversion of the tensor \\spad{ts} to a tensor with components of type \\spad{T.}")) (|reshape| (((|CartesianTensor| |#1| |#2| |#4|) (|List| |#4|) (|CartesianTensor| |#1| |#2| |#3|)) "\\spad{reshape(lt,ts)} organizes the list of components \\spad{lt} into a tensor with the same shape as \\spad{ts.}"))) 
NIL 
NIL 
(|CartesianTensor| |minix| |dim| R) 
((|constructor| (NIL "CartesianTensor(minix,dim,R) provides Cartesian tensors with components belonging to a commutative ring \\spad{R.} These tensors can have any number of indices. Each index takes values from \\spad{minix} to \\spad{minix + dim - 1}.")) (|sample| (($) "\\spad{sample()} returns an object of type \\spad{%.}")) (|unravel| (($ (|List| |#3|)) "\\spad{unravel(t)} produces a tensor from a list of components such that \\indented{2}{\\spad{unravel(ravel(t)) = t}.}")) (|ravel| (((|List| |#3|) $) "\\indented{1}{ravel(t) produces a list of components from a tensor such that} \\indented{3}{\\spad{unravel(ravel(t)) = t}.} \\blankline \\spad{X} n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] \\spad{X} tn:CartesianTensor(1,2,Integer):=n \\spad{X} ravel \\spad{tn}")) (|leviCivitaSymbol| (($) "\\indented{1}{leviCivitaSymbol() is the rank \\spad{dim} tensor defined \\spad{by}} \\indented{1}{\\spad{leviCivitaSymbol()(i1,...idim) = +1/0/-1}} \\indented{1}{if \\spad{i1,...,idim} is an even/is nota /is an odd permutation} \\indented{1}{of \\spad{minix,...,minix+dim-1}.} \\blankline \\spad{X} lcs:CartesianTensor(1,2,Integer):=leviCivitaSymbol()")) (|kroneckerDelta| (($) "\\indented{1}{kroneckerDelta() is the rank 2 tensor defined \\spad{by}} \\indented{4}{\\spad{kroneckerDelta()(i,j)}} \\indented{7}{\\spad{= 1\\space{2}if \\spad{i} = \\spad{j}}} \\indented{7}{\\spad{= 0 if\\space{2}i \\spad{\\^=} \\spad{j}}} \\blankline \\spad{X} delta:CartesianTensor(1,2,Integer):=kroneckerDelta()")) (|reindex| (($ $ (|List| (|Integer|))) "\\indented{1}{reindex(t,[i1,...,idim]) permutes the indices of \\spad{t.}} \\indented{1}{For example, if \\spad{r = reindex(t, [4,1,2,3])}} \\indented{1}{for a rank 4 tensor \\spad{t,}} \\indented{1}{then \\spad{r} is the rank for tensor given \\spad{by}} \\indented{5}{\\spad{r(i,j,k,l) = t(l,i,j,k)}.} \\blankline \\spad{X} n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] \\spad{X} tn:CartesianTensor(1,2,Integer):=n \\spad{X} p:=product(tn,tn) \\spad{X} reindex(p,[4,3,2,1])")) (|transpose| (($ $ (|Integer|) (|Integer|)) "\\indented{1}{transpose(t,i,j) exchanges the \\spad{i}-th and \\spad{j}-th} \\indented{1}{indices of \\spad{t.} For example, if \\spad{r = transpose(t,2,3)}} \\indented{1}{for a rank 4 tensor \\spad{t,} then \\spad{r} is the rank 4 tensor} \\indented{1}{given \\spad{by}} \\indented{5}{\\spad{r(i,j,k,l) = t(i,k,j,l)}.} \\blankline \\spad{X} m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] \\spad{X} tm:CartesianTensor(1,2,Integer):=m \\spad{X} tn:CartesianTensor(1,2,Integer):=[tm,tm] \\spad{X} transpose(tn,1,2)") (($ $) "\\indented{1}{transpose(t) exchanges the first and last indices of \\spad{t.}} \\indented{1}{For example, if \\spad{r = transpose(t)} for a rank 4} \\indented{1}{tensor \\spad{t,} then \\spad{r} is the rank 4 tensor given \\spad{by}} \\indented{5}{\\spad{r(i,j,k,l) = t(l,j,k,i)}.} \\blankline \\spad{X} m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] \\spad{X} Tm:CartesianTensor(1,2,Integer):=m \\spad{X} transpose(Tm)")) (|contract| (($ $ (|Integer|) (|Integer|)) "\\indented{1}{contract(t,i,j) is the contraction of tensor \\spad{t} which} \\indented{1}{sums along the \\spad{i}-th and \\spad{j}-th indices.} \\indented{1}{For example,\\space{2}if} \\indented{1}{\\spad{r = contract(t,1,3)} for a rank 4 tensor \\spad{t,} then} \\indented{1}{\\spad{r} is the rank 2 \\spad{(= 4 - 2)} tensor given \\spad{by}} \\indented{5}{\\spad{r(i,j) = sum(h=1..dim,t(h,i,h,j))}.} \\blankline \\spad{X} m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] \\spad{X} Tm:CartesianTensor(1,2,Integer):=m \\spad{X} v:DirectProduct(2,Integer):=directProduct [3,4] \\spad{X} Tv:CartesianTensor(1,2,Integer):=v \\spad{X} Tmv:=contract(Tm,2,1)") (($ $ (|Integer|) $ (|Integer|)) "\\indented{1}{contract(t,i,s,j) is the inner product of tenors \\spad{s} and \\spad{t}} \\indented{1}{which sums along the \\spad{k1}-th index of} \\indented{1}{t and the \\spad{k2}-th index of \\spad{s.}} \\indented{1}{For example, if \\spad{r = contract(s,2,t,1)} for rank 3 tensors} \\indented{1}{rank 3 tensors \\spad{s} and \\spad{t}, then \\spad{r} is} \\indented{1}{the rank 4 \\spad{(= 3 + 3 - 2)} tensor\\space{2}given \\spad{by}} \\indented{5}{\\spad{r(i,j,k,l) = sum(h=1..dim,s(i,h,j)*t(h,k,l))}.} \\blankline \\spad{X} m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] \\spad{X} Tm:CartesianTensor(1,2,Integer):=m \\spad{X} v:DirectProduct(2,Integer):=directProduct [3,4] \\spad{X} Tv:CartesianTensor(1,2,Integer):=v \\spad{X} Tmv:=contract(Tm,2,Tv,1)")) (* (($ $ $) "\\indented{1}{s*t is the inner product of the tensors \\spad{s} and \\spad{t} which contracts} \\indented{1}{the last index of \\spad{s} with the first index of \\spad{t,} that is,} \\indented{5}{\\spad{t*s = contract(t,rank \\spad{t,} \\spad{s,} 1)}} \\indented{5}{\\spad{t*s = sum(k=1..N, t[i1,..,iN,k]*s[k,j1,..,jM])}} \\indented{1}{This is compatible with the use of \\spad{M*v} to denote} \\indented{1}{the matrix-vector inner product.} \\blankline \\spad{X} m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] \\spad{X} Tm:CartesianTensor(1,2,Integer):=m \\spad{X} v:DirectProduct(2,Integer):=directProduct [3,4] \\spad{X} Tv:CartesianTensor(1,2,Integer):=v \\spad{X} Tm*Tv")) (|product| (($ $ $) "\\indented{1}{product(s,t) is the outer product of the tensors \\spad{s} and \\spad{t.}} \\indented{1}{For example, if \\spad{r = product(s,t)} for rank 2 tensors} \\indented{1}{s and \\spad{t,} then \\spad{r} is a rank 4 tensor given \\spad{by}} \\indented{5}{\\spad{r(i,j,k,l) = s(i,j)*t(k,l)}.} \\blankline \\spad{X} m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] \\spad{X} Tm:CartesianTensor(1,2,Integer):=m \\spad{X} n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] \\spad{X} Tn:CartesianTensor(1,2,Integer):=n \\spad{X} Tmn:=product(Tm,Tn)")) (|elt| ((|#3| $ (|List| (|Integer|))) "\\indented{1}{elt(t,[i1,...,iN]) gives a component of a rank \\spad{N} tensor.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v \\spad{X} tm:CartesianTensor(1,2,Integer):=[tv,tv] \\spad{X} tn:CartesianTensor(1,2,Integer):=[tm,tm] \\spad{X} tp:CartesianTensor(1,2,Integer):=[tn,tn] \\spad{X} tq:CartesianTensor(1,2,Integer):=[tp,tp] \\spad{X} elt(tq,[2,2,2,2,2])") ((|#3| $ (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "\\indented{1}{elt(t,i,j,k,l) gives a component of a rank 4 tensor.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v \\spad{X} tm:CartesianTensor(1,2,Integer):=[tv,tv] \\spad{X} tn:CartesianTensor(1,2,Integer):=[tm,tm] \\spad{X} tp:CartesianTensor(1,2,Integer):=[tn,tn] \\spad{X} elt(tp,2,2,2,2) \\spad{X} tp[2,2,2,2]") ((|#3| $ (|Integer|) (|Integer|) (|Integer|)) "\\indented{1}{elt(t,i,j,k) gives a component of a rank 3 tensor.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v \\spad{X} tm:CartesianTensor(1,2,Integer):=[tv,tv] \\spad{X} tn:CartesianTensor(1,2,Integer):=[tm,tm] \\spad{X} elt(tn,2,2,2) \\spad{X} tn[2,2,2]") ((|#3| $ (|Integer|) (|Integer|)) "\\indented{1}{elt(t,i,j) gives a component of a rank 2 tensor.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v \\spad{X} tm:CartesianTensor(1,2,Integer):=[tv,tv] \\spad{X} elt(tm,2,2) \\spad{X} tm[2,2]") ((|#3| $ (|Integer|)) "\\indented{1}{elt(t,i) gives a component of a rank 1 tensor.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v \\spad{X} elt(tv,2) \\spad{X} tv[2]") ((|#3| $) "\\indented{1}{elt(t) gives the component of a rank 0 tensor.} \\blankline \\spad{X} \\spad{tv:CartesianTensor(1,2,Integer):=8} \\spad{X} elt(tv) \\spad{X} tv[]")) (|rank| (((|NonNegativeInteger|) $) "\\indented{1}{rank(t) returns the tensorial rank of \\spad{t} (that is, the} \\indented{1}{number of indices).\\space{2}This is the same as the graded module} \\indented{1}{degree.} \\blankline \\spad{X} CT:=CARTEN(1,2,Integer) \\spad{X} \\spad{t0:CT:=8} \\spad{X} rank \\spad{t0}")) (|coerce| (($ (|List| $)) "\\indented{1}{coerce([t_1,...,t_dim]) allows tensors to be constructed} \\indented{1}{using lists.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v \\spad{X} tm:CartesianTensor(1,2,Integer):=[tv,tv]") (($ (|List| |#3|)) "\\indented{1}{coerce([r_1,...,r_dim]) allows tensors to be constructed} \\indented{1}{using lists.} \\blankline \\spad{X} v:=[2,3] \\spad{X} tv:CartesianTensor(1,2,Integer):=v") (($ (|SquareMatrix| |#2| |#3|)) "\\indented{1}{coerce(m) views a matrix as a rank 2 tensor.} \\blankline \\spad{X} v:SquareMatrix(2,Integer):=[[1,2],[3,4]] \\spad{X} tv:CartesianTensor(1,2,Integer):=v") (($ (|DirectProduct| |#2| |#3|)) "\\indented{1}{coerce(v) views a vector as a rank 1 tensor.} \\blankline \\spad{X} v:DirectProduct(2,Integer):=directProduct [3,4] \\spad{X} tv:CartesianTensor(1,2,Integer):=v"))) 
NIL 
NIL 
(|CharacterClass|) 
((|constructor| (NIL "This domain allows classes of characters to be defined and manipulated efficiently.")) (|alphanumeric| (($) "\\spad{alphanumeric()} returns the class of all characters for which alphanumeric? is true.")) (|alphabetic| (($) "\\spad{alphabetic()} returns the class of all characters for which alphabetic? is true.")) (|lowerCase| (($) "\\spad{lowerCase()} returns the class of all characters for which lowerCase? is true.")) (|upperCase| (($) "\\spad{upperCase()} returns the class of all characters for which upperCase? is true.")) (|hexDigit| (($) "\\spad{hexDigit()} returns the class of all characters for which hexDigit? is true.")) (|digit| (($) "\\spad{digit()} returns the class of all characters for which digit? is true.")) (|charClass| (($ (|List| (|Character|))) "\\spad{charClass(l)} creates a character class which contains exactly the characters given in the list \\spad{l.}") (($ (|String|)) "\\spad{charClass(s)} creates a character class which contains exactly the characters given in the string \\spad{s.}"))) 
((|finiteAggregate| . T) (|partiallyOrderedSet| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Character|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Character|) (QUOTE (|Finite|))) (|HasCategory| (|Character|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Character|) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Character|) (LIST (QUOTE |Evalable|) (QUOTE (|Character|)))) (|HasCategory| (|Character|) (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| (|Character|) (LIST (QUOTE |Evalable|) (QUOTE (|Character|)))) (|HasCategory| (|Character|) (QUOTE (|Finite|)))) (AND (|HasCategory| (|Character|) (LIST (QUOTE |Evalable|) (QUOTE (|Character|)))) (|HasCategory| (|Character|) (QUOTE (|SetCategory|)))))) 
(|CommonDenominator| R Q A) 
((|constructor| (NIL "CommonDenominator provides functions to compute the common denominator of a finite linear aggregate of elements of the quotient field of an integral domain.")) (|splitDenominator| (((|Record| (|:| |num| |#3|) (|:| |den| |#1|)) |#3|) "\\spad{splitDenominator([q1,...,qn])} returns \\spad{[[p1,...,pn], \\spad{d]}} such that \\spad{qi = pi/d} and \\spad{d} is a common denominator for the qi's.")) (|clearDenominator| ((|#3| |#3|) "\\spad{clearDenominator([q1,...,qn])} returns \\spad{[p1,...,pn]} such that \\spad{qi = pi/d} where \\spad{d} is a common denominator for the qi's.")) (|commonDenominator| ((|#1| |#3|) "\\spad{commonDenominator([q1,...,qn])} returns a common denominator \\spad{d} for q1,...,qn."))) 
NIL 
NIL 
(|ComplexDoubleFloatMatrix|) 
((|constructor| (NIL "This is a low-level domain which implements matrices (two dimensional arrays) of complex double precision floating point numbers. Indexing is 0 based, there is no bound checking (unless provided by lower level).")) (|qnew| (($ (|Integer|) (|Integer|)) "\\indented{1}{qnew(n, \\spad{m)} creates a new uninitialized \\spad{n} by \\spad{m} matrix.} \\blankline \\spad{X} t1:CDFMAT:=qnew(3,4)"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Complex| (|DoubleFloat|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Complex|) (QUOTE (|DoubleFloat|))))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|SetCategory|)))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|IntegralDomain|))) (|HasAttribute| (|Complex| (|DoubleFloat|)) (QUOTE (|commutative| "*"))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|CommutativeRing|))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|Field|)))) 
(|ComplexDoubleFloatVector|) 
((|constructor| (NIL "This is a low-level domain which implements vectors (one dimensional arrays) of complex double precision floating point numbers. Indexing is 0 based, there is no bound checking (unless provided by lower level).")) (|vector| (($ (|List| (|Complex| (|DoubleFloat|)))) "\\indented{1}{vector(l) converts the list \\spad{l} to a vector.} \\blankline \\spad{X} t1:List(Complex(DoubleFloat)):=[1+2*\\%i,3+4*\\%i,-5-6*\\%i] \\spad{X} t2:CDFVEC:=vector(t1)")) (|qnew| (($ (|Integer|)) "\\indented{1}{qnew(n) creates a new uninitialized vector of length \\spad{n.}} \\blankline \\spad{X} t1:CDFVEC:=qnew 7"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|SetCategory|))) (|HasCategory| (|Complex| (|DoubleFloat|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|OrderedSet|))) (OR (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|OrderedSet|))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|AbelianSemiGroup|))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|AbelianMonoid|))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|AbelianGroup|))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|Monoid|))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|Ring|))) (AND (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|RadicalCategory|))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|Ring|)))) (AND (|HasCategory| (|Complex| (|DoubleFloat|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Complex|) (QUOTE (|DoubleFloat|))))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| (|Complex| (|DoubleFloat|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Complex|) (QUOTE (|DoubleFloat|))))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|OrderedSet|)))) (AND (|HasCategory| (|Complex| (|DoubleFloat|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Complex|) (QUOTE (|DoubleFloat|))))) (|HasCategory| (|Complex| (|DoubleFloat|)) (QUOTE (|SetCategory|)))))) 
(|Cell| |TheField|) 
NIL 
NIL 
NIL 
(|CombinatorialFunctionCategory|) 
((|constructor| (NIL "Category for the usual combinatorial functions.")) (|permutation| (($ $ $) "\\spad{permutation(n, \\spad{m)}} returns the number of permutations of \\spad{n} objects taken \\spad{m} at a time. Note that \\spad{permutation(n,m) = n!/(n-m)!}.")) (|factorial| (($ $) "\\spad{factorial(n)} computes the factorial of \\spad{n} (denoted in the literature by \\spad{n!}) Note that \\spad{n! = \\spad{n} (n-1)! when \\spad{n} > 0}; also, \\spad{0! = 1}.")) (|binomial| (($ $ $) "\\indented{1}{binomial(n,r) returns the \\spad{(n,r)} binomial coefficient} \\indented{1}{(often denoted in the literature by \\spad{C(n,r)}).} \\indented{1}{Note that \\spad{C(n,r) = n!/(r!(n-r)!)} where \\spad{n \\spad{>=} \\spad{r} \\spad{>=} 0}.} \\blankline \\spad{X} [binomial(5,i) for \\spad{i} in 0..5]"))) 
NIL 
NIL 
(|Character|) 
((|constructor| (NIL "This domain provides the basic character data type.")) (|alphanumeric?| (((|Boolean|) $) "\\spad{alphanumeric?(c)} tests if \\spad{c} is either a letter or number, for example, one of 0..9, a..z or A..Z. \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [alphanumeric? \\spad{c} for \\spad{c} in chars]")) (|lowerCase?| (((|Boolean|) $) "\\spad{lowerCase?(c)} tests if \\spad{c} is an lower case letter, for example, one of a..z. \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [lowerCase? \\spad{c} for \\spad{c} in chars]")) (|upperCase?| (((|Boolean|) $) "\\spad{upperCase?(c)} tests if \\spad{c} is an upper case letter, for example, one of A..Z. \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [upperCase? \\spad{c} for \\spad{c} in chars]")) (|alphabetic?| (((|Boolean|) $) "\\spad{alphabetic?(c)} tests if \\spad{c} is a letter, for example, one of a..z or A..Z. \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [alphabetic? \\spad{c} for \\spad{c} in chars]")) (|hexDigit?| (((|Boolean|) $) "\\spad{hexDigit?(c)} tests if \\spad{c} is a hexadecimal numeral, for example, one of 0..9, a..f or A..F. \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [hexDigit? \\spad{c} for \\spad{c} in chars]")) (|digit?| (((|Boolean|) $) "\\spad{digit?(c)} tests if \\spad{c} is a digit character, for example, one of 0..9. \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [digit? \\spad{c} for \\spad{c} in chars]")) (|lowerCase| (($ $) "\\spad{lowerCase(c)} converts an upper case letter to the corresponding lower case letter. If \\spad{c} is not an upper case letter, then it is returned unchanged. \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [lowerCase \\spad{c} for \\spad{c} in chars]")) (|upperCase| (($ $) "\\spad{upperCase(c)} converts a lower case letter to the corresponding upper case letter. If \\spad{c} is not a lower case letter, then it is returned unchanged. \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [upperCase \\spad{c} for \\spad{c} in chars]")) (|escape| (($) "\\spad{escape()} provides the escape character, \\spad{_}, which is used to allow quotes and other characters within strings. \\blankline \\spad{X} escape()")) (|quote| (($) "\\spad{quote()} provides the string quote character, \\spad{\"}. \\blankline \\spad{X} quote()")) (|space| (($) "\\spad{space()} provides the blank character. \\blankline \\spad{X} space()")) (|char| (($ (|String|)) "\\spad{char(s)} provides a character from a string \\spad{s} of length one. \\blankline \\spad{X} [char \\spad{c} for \\spad{c} in [\"a\",\"A\",\"X\",\"8\",\"+\"]]") (($ (|Integer|)) "\\spad{char(i)} provides a character corresponding to the integer code i. It is always \\spad{true} that \\spad{ord char \\spad{i} = i}. \\blankline \\spad{X} [char \\spad{c} for \\spad{c} in [97,65,88,56,43]]")) (|ord| (((|Integer|) $) "\\spad{ord(c)} provides an integral code corresponding to the character \\spad{c.} It is always \\spad{true} that \\spad{char ord \\spad{c} = \\spad{c}.} \\blankline \\spad{X} chars \\spad{:=} [char \"a\", char \"A\", char \"X\", char \"8\", char \"+\"] \\spad{X} [ord \\spad{c} for \\spad{c} in chars]"))) 
NIL 
NIL 
(|CharacteristicNonZero|) 
((|constructor| (NIL "Rings of Characteristic Non Zero")) (|charthRoot| (((|Union| $ "failed") $) "\\spad{charthRoot(x)} returns the \\spad{p}th root of \\spad{x} where \\spad{p} is the characteristic of the ring."))) 
((|unitsKnown| . T)) 
NIL 
(|CharacteristicPolynomialPackage| R) 
((|constructor| (NIL "This package provides a characteristicPolynomial function for any matrix over a commutative ring.")) (|characteristicPolynomial| ((|#1| (|Matrix| |#1|) |#1|) "\\spad{characteristicPolynomial(m,r)} computes the characteristic polynomial of the matrix \\spad{m} evaluated at the point \\spad{r.} In particular, if \\spad{r} is the polynomial \\spad{'x,} then it returns the characteristic polynomial expressed as a polynomial in \\spad{'x.}"))) 
NIL 
NIL 
(|CharacteristicZero|) 
((|constructor| (NIL "Rings of Characteristic Zero."))) 
((|unitsKnown| . T)) 
NIL 
(|ChangeOfVariable| F UP UPUP) 
((|constructor| (NIL "Tools to send a point to infinity on an algebraic curve.")) (|chvar| (((|Record| (|:| |func| |#3|) (|:| |poly| |#3|) (|:| |c1| (|Fraction| |#2|)) (|:| |c2| (|Fraction| |#2|)) (|:| |deg| (|NonNegativeInteger|))) |#3| |#3|) "\\spad{chvar(f(x,y), p(x,y))} returns \\spad{[g(z,t), q(z,t), c1(z), c2(z), \\spad{n]}} such that under the change of variable \\spad{x = c1(z)}, \\spad{y = \\spad{t} * c2(z)}, one gets \\spad{f(x,y) = g(z,t)}. The algebraic relation between \\spad{x} and \\spad{y} is \\spad{p(x, \\spad{y)} = 0}. The algebraic relation between \\spad{z} and \\spad{t} is \\spad{q(z, \\spad{t)} = 0}.")) (|eval| ((|#3| |#3| (|Fraction| |#2|) (|Fraction| |#2|)) "\\spad{eval(p(x,y), f(x), g(x))} returns \\spad{p(f(x), \\spad{y} * g(x))}.")) (|goodPoint| ((|#1| |#3| |#3|) "\\spad{goodPoint(p, \\spad{q)}} returns an integer a such that a is neither a pole of \\spad{p(x,y)} nor a branch point of \\spad{q(x,y) = 0}.")) (|rootPoly| (((|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |coef| (|Fraction| |#2|)) (|:| |radicand| |#2|)) (|Fraction| |#2|) (|NonNegativeInteger|)) "\\spad{rootPoly(g, \\spad{n)}} returns \\spad{[m, \\spad{c,} \\spad{P]}} such that \\spad{c * \\spad{g} \\spad{**} (1/n) = \\spad{P} \\spad{**} (1/m)} thus if \\spad{y**n = \\spad{g},} then \\spad{z**m = \\spad{P}} where \\spad{z = \\spad{c} * \\spad{y}.}")) (|radPoly| (((|Union| (|Record| (|:| |radicand| (|Fraction| |#2|)) (|:| |deg| (|NonNegativeInteger|))) "failed") |#3|) "\\spad{radPoly(p(x, y))} returns \\spad{[c(x), \\spad{n]}} if \\spad{p} is of the form \\spad{y**n - c(x)}, \"failed\" otherwise.")) (|mkIntegral| (((|Record| (|:| |coef| (|Fraction| |#2|)) (|:| |poly| |#3|)) |#3|) "\\spad{mkIntegral(p(x,y))} returns \\spad{[c(x), q(x,z)]} such that \\spad{z = \\spad{c} * \\spad{y}} is integral. The algebraic relation between \\spad{x} and \\spad{y} is \\spad{p(x, \\spad{y)} = 0}. The algebraic relation between \\spad{x} and \\spad{z} is \\spad{q(x, \\spad{z)} = 0}."))) 
NIL 
NIL 
(|ComplexIntegerSolveLinearPolynomialEquation| R CR) 
((|constructor| (NIL "This package provides the generalized euclidean algorithm which is needed as the basic step for factoring polynomials.")) (|solveLinearPolynomialEquation| (((|Union| (|List| (|SparseUnivariatePolynomial| |#2|)) "failed") (|List| (|SparseUnivariatePolynomial| |#2|)) (|SparseUnivariatePolynomial| |#2|)) "\\spad{solveLinearPolynomialEquation([f1, ..., fn], \\spad{g)}} where (fi relatively prime to each other) returns a list of \\spad{ai} such that \\spad{g} = sum \\spad{ai} prod \\spad{fj} \\spad{(j} \\spad{\\=} i) or equivalently g/prod \\spad{fj} = sum (ai/fi) or returns \"failed\" if no such list exists"))) 
NIL 
NIL 
(|Collection&| A S) 
((|constructor| (NIL "A collection is a homogeneous aggregate which can built from list of members. The operation used to build the aggregate is generically named construct. However, each collection provides its own special function with the same name as the data type, except with an initial lower case letter, For example, list for List, flexibleArray for FlexibleArray, and so on.")) (|removeDuplicates| (($ $) "\\spad{removeDuplicates(u)} returns a copy of \\spad{u} with all duplicates removed.")) (|select| (($ (|Mapping| (|Boolean|) |#2|) $) "\\spad{select(p,u)} returns a copy of \\spad{u} containing only those elements such \\axiom{p(x)} is true. Note that \\axiom{select(p,u) \\spad{==} \\spad{[x} for \\spad{x} in \\spad{u} | p(x)]}.")) (|remove| (($ |#2| $) "\\spad{remove(x,u)} returns a copy of \\spad{u} with all elements \\axiom{y = \\spad{x}} removed. Note that \\axiom{remove(y,c) \\spad{==} \\spad{[x} for \\spad{x} in \\spad{c} | \\spad{x} \\spad{^=} y]}.") (($ (|Mapping| (|Boolean|) |#2|) $) "\\spad{remove(p,u)} returns a copy of \\spad{u} removing all elements \\spad{x} such that \\axiom{p(x)} is true. Note that \\axiom{remove(p,u) \\spad{==} \\spad{[x} for \\spad{x} in \\spad{u} | not p(x)]}.")) (|reduce| ((|#2| (|Mapping| |#2| |#2| |#2|) $ |#2| |#2|) "\\spad{reduce(f,u,x,z)} reduces the binary operation \\spad{f} across u, stopping when an \"absorbing element\" \\spad{z} is encountered. As for \\axiom{reduce(f,u,x)}, \\spad{x} is the identity operation of \\spad{f.} Same as \\axiom{reduce(f,u,x)} when \\spad{u} contains no element \\spad{z.} Thus the third argument \\spad{x} is returned when \\spad{u} is empty.") ((|#2| (|Mapping| |#2| |#2| |#2|) $ |#2|) "\\spad{reduce(f,u,x)} reduces the binary operation \\spad{f} across u, where \\spad{x} is the identity operation of \\spad{f.} Same as \\axiom{reduce(f,u)} if \\spad{u} has 2 or more elements. Returns \\axiom{f(x,y)} if \\spad{u} has one element \\spad{y,} \\spad{x} if \\spad{u} is empty. For example, \\axiom{reduce(+,u,0)} returns the sum of the elements of u.") ((|#2| (|Mapping| |#2| |#2| |#2|) $) "\\spad{reduce(f,u)} reduces the binary operation \\spad{f} across u. For example, if \\spad{u} is \\axiom{[x,y,...,z]} then \\axiom{reduce(f,u)} returns \\axiom{f(..f(f(x,y),...),z)}. Note that if \\spad{u} has one element \\spad{x,} \\axiom{reduce(f,u)} returns \\spad{x.} Error: if \\spad{u} is empty. \\blankline \\spad{C} )clear all \\spad{X} reduce(+,[C[i]*x**i for \\spad{i} in 1..5])")) (|find| (((|Union| |#2| "failed") (|Mapping| (|Boolean|) |#2|) $) "\\axiom{find(p,u)} returns the first \\spad{x} in \\spad{u} such that \\axiom{p(x)} is true, and \"failed\" otherwise.")) (|construct| (($ (|List| |#2|)) "\\axiom{construct(x,y,...,z)} returns the collection of elements \\axiom{x,y,...,z} ordered as given. Equivalently written as \\axiom{[x,y,...,z]$D}, where \\spad{D} is the domain. \\spad{D} may be omitted for those of type List."))) 
NIL 
((|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (QUOTE (|SetCategory|))) (|HasAttribute| |#1| (QUOTE |finiteAggregate|))) 
(|Collection| S) 
((|constructor| (NIL "A collection is a homogeneous aggregate which can built from list of members. The operation used to build the aggregate is generically named construct. However, each collection provides its own special function with the same name as the data type, except with an initial lower case letter, For example, list for List, flexibleArray for FlexibleArray, and so on.")) (|removeDuplicates| (($ $) "\\spad{removeDuplicates(u)} returns a copy of \\spad{u} with all duplicates removed.")) (|select| (($ (|Mapping| (|Boolean|) |#1|) $) "\\spad{select(p,u)} returns a copy of \\spad{u} containing only those elements such \\axiom{p(x)} is true. Note that \\axiom{select(p,u) \\spad{==} \\spad{[x} for \\spad{x} in \\spad{u} | p(x)]}.")) (|remove| (($ |#1| $) "\\spad{remove(x,u)} returns a copy of \\spad{u} with all elements \\axiom{y = \\spad{x}} removed. Note that \\axiom{remove(y,c) \\spad{==} \\spad{[x} for \\spad{x} in \\spad{c} | \\spad{x} \\spad{^=} y]}.") (($ (|Mapping| (|Boolean|) |#1|) $) "\\spad{remove(p,u)} returns a copy of \\spad{u} removing all elements \\spad{x} such that \\axiom{p(x)} is true. Note that \\axiom{remove(p,u) \\spad{==} \\spad{[x} for \\spad{x} in \\spad{u} | not p(x)]}.")) (|reduce| ((|#1| (|Mapping| |#1| |#1| |#1|) $ |#1| |#1|) "\\spad{reduce(f,u,x,z)} reduces the binary operation \\spad{f} across u, stopping when an \"absorbing element\" \\spad{z} is encountered. As for \\axiom{reduce(f,u,x)}, \\spad{x} is the identity operation of \\spad{f.} Same as \\axiom{reduce(f,u,x)} when \\spad{u} contains no element \\spad{z.} Thus the third argument \\spad{x} is returned when \\spad{u} is empty.") ((|#1| (|Mapping| |#1| |#1| |#1|) $ |#1|) "\\spad{reduce(f,u,x)} reduces the binary operation \\spad{f} across u, where \\spad{x} is the identity operation of \\spad{f.} Same as \\axiom{reduce(f,u)} if \\spad{u} has 2 or more elements. Returns \\axiom{f(x,y)} if \\spad{u} has one element \\spad{y,} \\spad{x} if \\spad{u} is empty. For example, \\axiom{reduce(+,u,0)} returns the sum of the elements of u.") ((|#1| (|Mapping| |#1| |#1| |#1|) $) "\\spad{reduce(f,u)} reduces the binary operation \\spad{f} across u. For example, if \\spad{u} is \\axiom{[x,y,...,z]} then \\axiom{reduce(f,u)} returns \\axiom{f(..f(f(x,y),...),z)}. Note that if \\spad{u} has one element \\spad{x,} \\axiom{reduce(f,u)} returns \\spad{x.} Error: if \\spad{u} is empty. \\blankline \\spad{C} )clear all \\spad{X} reduce(+,[C[i]*x**i for \\spad{i} in 1..5])")) (|find| (((|Union| |#1| "failed") (|Mapping| (|Boolean|) |#1|) $) "\\axiom{find(p,u)} returns the first \\spad{x} in \\spad{u} such that \\axiom{p(x)} is true, and \"failed\" otherwise.")) (|construct| (($ (|List| |#1|)) "\\axiom{construct(x,y,...,z)} returns the collection of elements \\axiom{x,y,...,z} ordered as given. Equivalently written as \\axiom{[x,y,...,z]$D}, where \\spad{D} is the domain. \\spad{D} may be omitted for those of type List."))) 
((|nil| . T)) 
NIL 
(|CliffordAlgebra| |n| K Q) 
((|constructor| (NIL "CliffordAlgebra(n, \\spad{K,} \\spad{Q)} defines a vector space of dimension \\spad{2**n} over \\spad{K,} given a quadratic form \\spad{Q} on \\spad{K**n}. \\blankline If \\spad{e[i]}, \\spad{1<=i<=n} is a basis for \\spad{K**n} then 1, \\spad{e[i]} (\\spad{1<=i<=n}), \\spad{e[i1]*e[i2]} (\\spad{1<=i1<i2<=n}),...,\\spad{e[1]*e[2]*..*e[n]} is a basis for the Clifford Algebra. \\blankline The algebra is defined by the relations\\br \\tab{5}\\spad{e[i]*e[j] = -e[j]*e[i]} (\\spad{i \\~~= j}),\\br \\tab{5}\\spad{e[i]*e[i] = Q(e[i])} \\blankline Examples of Clifford Algebras are: gaussians, quaternions, exterior algebras and spin algebras.")) (|recip| (((|Union| $ "failed") $) "\\spad{recip(x)} computes the multiplicative inverse of \\spad{x} or \"failed\" if \\spad{x} is not invertible.")) (|coefficient| ((|#2| $ (|List| (|PositiveInteger|))) "\\spad{coefficient(x,[i1,i2,...,iN])} extracts the coefficient of \\spad{e(i1)*e(i2)*...*e(iN)} in \\spad{x.}")) (|monomial| (($ |#2| (|List| (|PositiveInteger|))) "\\spad{monomial(c,[i1,i2,...,iN])} produces the value given by \\spad{c*e(i1)*e(i2)*...*e(iN)}.")) (|e| (($ (|PositiveInteger|)) "\\spad{e(n)} produces the appropriate unit element."))) 
((|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|TwoDimensionalPlotClipping|) 
((|constructor| (NIL "Automatic clipping for 2-dimensional plots The purpose of this package is to provide reasonable plots of functions with singularities.")) (|clipWithRanges| (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|))))) (|:| |xValues| (|Segment| (|DoubleFloat|))) (|:| |yValues| (|Segment| (|DoubleFloat|)))) (|List| (|List| (|Point| (|DoubleFloat|)))) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) "\\spad{clipWithRanges(pointLists,xMin,xMax,yMin,yMax)} performs clipping on a list of lists of points, \\spad{pointLists}. Clipping is done within the specified ranges of \\spad{xMin}, \\spad{xMax} and \\spad{yMin}, \\spad{yMax}. This function is used internally by the \\fakeAxiomFun{iClipParametric} subroutine in this package.")) (|clipParametric| (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|))))) (|:| |xValues| (|Segment| (|DoubleFloat|))) (|:| |yValues| (|Segment| (|DoubleFloat|)))) (|Plot|) (|Fraction| (|Integer|)) (|Fraction| (|Integer|))) "\\spad{clipParametric(p,frac,sc)} performs two-dimensional clipping on a plot, \\spad{p,} from the domain \\spadtype{Plot} for the parametric curve \\spad{x = f(t)}, \\spad{y = g(t)}; the fraction parameter is specified by \\spad{frac} and the scale parameter is specified by \\spad{sc} for use in the \\fakeAxiomFun{iClipParametric} subroutine, which is called by this function.") (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|))))) (|:| |xValues| (|Segment| (|DoubleFloat|))) (|:| |yValues| (|Segment| (|DoubleFloat|)))) (|Plot|)) "\\spad{clipParametric(p)} performs two-dimensional clipping on a plot, \\spad{p,} from the domain \\spadtype{Plot} for the parametric curve \\spad{x = f(t)}, \\spad{y = g(t)}; the default parameters \\spad{1/2} for the fraction and \\spad{5/1} for the scale are used in the \\fakeAxiomFun{iClipParametric} subroutine, which is called by this function.")) (|clip| (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|))))) (|:| |xValues| (|Segment| (|DoubleFloat|))) (|:| |yValues| (|Segment| (|DoubleFloat|)))) (|List| (|List| (|Point| (|DoubleFloat|))))) "\\spad{clip(ll)} performs two-dimensional clipping on a list of lists of points, \\spad{ll}; the default parameters \\spad{1/2} for the fraction and \\spad{5/1} for the scale are used in the \\fakeAxiomFun{iClipParametric} subroutine, which is called by this function.") (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|))))) (|:| |xValues| (|Segment| (|DoubleFloat|))) (|:| |yValues| (|Segment| (|DoubleFloat|)))) (|List| (|Point| (|DoubleFloat|)))) "\\spad{clip(l)} performs two-dimensional clipping on a curve \\spad{l,} which is a list of points; the default parameters \\spad{1/2} for the fraction and \\spad{5/1} for the scale are used in the \\fakeAxiomFun{iClipParametric} subroutine, which is called by this function.") (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|))))) (|:| |xValues| (|Segment| (|DoubleFloat|))) (|:| |yValues| (|Segment| (|DoubleFloat|)))) (|Plot|) (|Fraction| (|Integer|)) (|Fraction| (|Integer|))) "\\spad{clip(p,frac,sc)} performs two-dimensional clipping on a plot, \\spad{p,} from the domain \\spadtype{Plot} for the graph of one variable \\spad{y = f(x)}; the fraction parameter is specified by \\spad{frac} and the scale parameter is specified by \\spad{sc} for use in the \\spadfun{clip} function.") (((|Record| (|:| |brans| (|List| (|List| (|Point| (|DoubleFloat|))))) (|:| |xValues| (|Segment| (|DoubleFloat|))) (|:| |yValues| (|Segment| (|DoubleFloat|)))) (|Plot|)) "\\spad{clip(p)} performs two-dimensional clipping on a plot, \\spad{p,} from the domain \\spadtype{Plot} for the graph of one variable, \\spad{y = f(x)}; the default parameters \\spad{1/4} for the fraction and \\spad{5/1} for the scale are used in the \\spadfun{clip} function."))) 
NIL 
NIL 
(|ComplexRootPackage| UP |Par|) 
((|constructor| (NIL "This package provides functions complexZeros for finding the complex zeros of univariate polynomials with complex rational number coefficients. The results are to any user specified precision and are returned as either complex rational number or complex floating point numbers depending on the type of the second argument which specifies the precision.")) (|complexZeros| (((|List| (|Complex| |#2|)) |#1| |#2|) "\\spad{complexZeros(poly, eps)} finds the complex zeros of the univariate polynomial \\spad{poly} to precision eps with solutions returned as complex floats or rationals depending on the type of eps."))) 
NIL 
NIL 
(|Color|) 
((|constructor| (NIL "Color() specifies a domain of 27 colors provided in the Axiom system (the colors mix additively).")) (|color| (($ (|Integer|)) "\\spad{color(i)} returns a color of the indicated hue i.")) (|numberOfHues| (((|PositiveInteger|)) "\\spad{numberOfHues()} returns the number of total hues, set in totalHues.")) (|hue| (((|Integer|) $) "\\spad{hue(c)} returns the hue index of the indicated color \\spad{c.}")) (|blue| (($) "\\spad{blue()} returns the position of the blue hue from total hues.")) (|green| (($) "\\spad{green()} returns the position of the green hue from total hues.")) (|yellow| (($) "\\spad{yellow()} returns the position of the yellow hue from total hues.")) (|red| (($) "\\spad{red()} returns the position of the red hue from total hues.")) (+ (($ $ $) "\\spad{c1 + \\spad{c2}} additively mixes the two colors \\spad{c1} and \\spad{c2.}")) (* (($ (|DoubleFloat|) $) "\\spad{s * \\spad{c},} returns the color \\spad{c,} whose weighted shade has been scaled by \\spad{s.}") (($ (|PositiveInteger|) $) "\\spad{s * \\spad{c},} returns the color \\spad{c,} whose weighted shade has been scaled by \\spad{s.}"))) 
NIL 
NIL 
(|CombinatorialFunction| R F) 
((|constructor| (NIL "Provides combinatorial functions over an integral domain.")) (|ipow| ((|#2| (|List| |#2|)) "\\spad{ipow(l)} should be local but conditional.")) (|iidprod| ((|#2| (|List| |#2|)) "\\spad{iidprod(l)} should be local but conditional.")) (|iidsum| ((|#2| (|List| |#2|)) "\\spad{iidsum(l)} should be local but conditional.")) (|iipow| ((|#2| (|List| |#2|)) "\\spad{iipow(l)} should be local but conditional.")) (|iiperm| ((|#2| (|List| |#2|)) "\\spad{iiperm(l)} should be local but conditional.")) (|iibinom| ((|#2| (|List| |#2|)) "\\spad{iibinom(l)} should be local but conditional.")) (|iifact| ((|#2| |#2|) "\\spad{iifact(x)} should be local but conditional.")) (|product| ((|#2| |#2| (|SegmentBinding| |#2|)) "\\spad{product(f(n), \\spad{n} = a..b)} returns f(a) * \\spad{...} * f(b) as a formal product.") ((|#2| |#2| (|Symbol|)) "\\spad{product(f(n), \\spad{n)}} returns the formal product P(n) which verifies P(n+1)/P(n) = f(n).")) (|summation| ((|#2| |#2| (|SegmentBinding| |#2|)) "\\spad{summation(f(n), \\spad{n} = a..b)} returns f(a) + \\spad{...} + f(b) as a formal sum.") ((|#2| |#2| (|Symbol|)) "\\spad{summation(f(n), \\spad{n)}} returns the formal sum S(n) which verifies S(n+1) - S(n) = f(n).")) (|factorials| ((|#2| |#2| (|Symbol|)) "\\spad{factorials(f, \\spad{x)}} rewrites the permutations and binomials in \\spad{f} involving \\spad{x} in terms of factorials.") ((|#2| |#2|) "\\spad{factorials(f)} rewrites the permutations and binomials in \\spad{f} in terms of factorials.")) (|factorial| ((|#2| |#2|) "\\spad{factorial(n)} returns the factorial of \\spad{n,} \\spadignore{i.e.} \\spad{n!;}")) (|permutation| ((|#2| |#2| |#2|) "\\spad{permutation(n, \\spad{r)}} returns the number of permutations of \\spad{n} objects taken \\spad{r} at a time, \\spadignore{i.e.} n!/(n-r)!.")) (|binomial| ((|#2| |#2| |#2|) "\\indented{1}{binomial(n, \\spad{r)} returns the number of subsets of \\spad{r} objects} \\indented{1}{taken among \\spad{n} objects, \\spadignore{i.e.} n!/(r! * (n-r)!);} \\blankline \\spad{X} [binomial(5,i) for \\spad{i} in 0..5]")) (** ((|#2| |#2| |#2|) "\\spad{a \\spad{**} \\spad{b}} is the formal exponential a**b.")) (|operator| (((|BasicOperator|) (|BasicOperator|)) "\\spad{operator(op)} returns a copy of \\spad{op} with the domain-dependent properties appropriate for \\spad{F;} error if \\spad{op} is not a combinatorial operator.")) (|belong?| (((|Boolean|) (|BasicOperator|)) "\\spad{belong?(op)} is \\spad{true} if \\spad{op} is a combinatorial operator."))) 
NIL 
NIL 
(|IntegerCombinatoricFunctions| I) 
((|constructor| (NIL "The \\spadtype{IntegerCombinatoricFunctions} package provides some standard functions in combinatorics.")) (|stirling2| ((|#1| |#1| |#1|) "\\spad{stirling2(n,m)} returns the Stirling number of the second kind denoted \\spad{SS[n,m]}.")) (|stirling1| ((|#1| |#1| |#1|) "\\spad{stirling1(n,m)} returns the Stirling number of the first kind denoted \\spad{S[n,m]}.")) (|permutation| ((|#1| |#1| |#1|) "\\spad{permutation(n)} returns \\spad{!P(n,r) = n!/(n-r)!}. This is the number of permutations of \\spad{n} objects taken \\spad{r} at a time.")) (|partition| ((|#1| |#1|) "\\spad{partition(n)} returns the number of partitions of the integer \\spad{n.} This is the number of distinct ways that \\spad{n} can be written as a sum of positive integers.")) (|multinomial| ((|#1| |#1| (|List| |#1|)) "\\spad{multinomial(n,[m1,m2,...,mk])} returns the multinomial coefficient \\spad{n!/(m1! \\spad{m2!} \\spad{...} mk!)}.")) (|factorial| ((|#1| |#1|) "\\spad{factorial(n)} returns \\spad{n!}. this is the product of all integers between 1 and \\spad{n} (inclusive). Note that \\spad{0!} is defined to be 1.")) (|binomial| ((|#1| |#1| |#1|) "\\indented{1}{\\spad{binomial(n,r)} returns the binomial coefficient} \\indented{1}{\\spad{C(n,r) = n!/(r! (n-r)!)}, where \\spad{n \\spad{>=} \\spad{r} \\spad{>=} 0}.} \\indented{1}{This is the number of combinations of \\spad{n} objects taken \\spad{r} at a time.} \\blankline \\spad{X} [binomial(5,i) for \\spad{i} in 0..5]"))) 
NIL 
NIL 
(|CombinatorialOpsCategory|) 
((|constructor| (NIL "CombinatorialOpsCategory is the category obtaining by adjoining summations and products to the usual combinatorial operations.")) (|product| (($ $ (|SegmentBinding| $)) "\\spad{product(f(n), \\spad{n} = a..b)} returns f(a) * \\spad{...} * f(b) as a formal product.") (($ $ (|Symbol|)) "\\spad{product(f(n), \\spad{n)}} returns the formal product P(n) which verifies P(n+1)/P(n) = f(n).")) (|summation| (($ $ (|SegmentBinding| $)) "\\spad{summation(f(n), \\spad{n} = a..b)} returns f(a) + \\spad{...} + f(b) as a formal sum.") (($ $ (|Symbol|)) "\\spad{summation(f(n), \\spad{n)}} returns the formal sum S(n) which verifies S(n+1) - S(n) = f(n).")) (|factorials| (($ $ (|Symbol|)) "\\spad{factorials(f, \\spad{x)}} rewrites the permutations and binomials in \\spad{f} involving \\spad{x} in terms of factorials.") (($ $) "\\spad{factorials(f)} rewrites the permutations and binomials in \\spad{f} in terms of factorials."))) 
NIL 
NIL 
(|Commutator|) 
((|constructor| (NIL "A type for basic commutators")) (|mkcomm| (($ $ $) "\\spad{mkcomm(i,j)} is not documented") (($ (|Integer|)) "\\spad{mkcomm(i)} is not documented"))) 
NIL 
NIL 
(|CommonOperators|) 
((|constructor| (NIL "This package exports the elementary operators, with some semantics already attached to them. The semantics that is attached here is not dependent on the set in which the operators will be applied.")) (|operator| (((|BasicOperator|) (|Symbol|)) "\\spad{operator(s)} returns an operator with name \\spad{s,} with the appropriate semantics if \\spad{s} is known. If \\spad{s} is not known, the result has no semantics."))) 
NIL 
NIL 
(|CommuteUnivariatePolynomialCategory| R UP UPUP) 
((|constructor| (NIL "A package for swapping the order of two variables in a tower of two UnivariatePolynomialCategory extensions.")) (|swap| ((|#3| |#3|) "\\spad{swap(p(x,y))} returns p(y,x)."))) 
NIL 
NIL 
(|Comparable|) 
((|constructor| (NIL "The class of set equipped with possibly unnatural linear order (needed for technical reasons).")) (|smaller?| (((|Boolean|) $ $) "\\spad{smaller?(x, \\spad{y)}} is a strict total ordering on the elements of the set."))) 
NIL 
NIL 
(|ComplexCategory&| S R) 
((|constructor| (NIL "This category represents the extension of a ring by a square root of \\spad{-1.}")) (|rationalIfCan| (((|Union| (|Fraction| (|Integer|)) "failed") $) "\\spad{rationalIfCan(x)} returns \\spad{x} as a rational number, or \"failed\" if \\spad{x} is not a rational number.")) (|rational| (((|Fraction| (|Integer|)) $) "\\spad{rational(x)} returns \\spad{x} as a rational number. Error: if \\spad{x} is not a rational number.")) (|rational?| (((|Boolean|) $) "\\spad{rational?(x)} tests if \\spad{x} is a rational number.")) (|polarCoordinates| (((|Record| (|:| |r| |#2|) (|:| |phi| |#2|)) $) "\\spad{polarCoordinates(x)} returns \\spad{(r,} phi) such that \\spad{x} = \\spad{r} * exp(\\%i * phi).")) (|argument| ((|#2| $) "\\spad{argument(x)} returns the angle made by (0,1) and (0,x).")) (|abs| (($ $) "\\spad{abs(x)} returns the absolute value of \\spad{x} = sqrt(norm(x)).")) (|exquo| (((|Union| $ "failed") $ |#2|) "\\spad{exquo(x, \\spad{r)}} returns the exact quotient of \\spad{x} by \\spad{r,} or \"failed\" if \\spad{r} does not divide \\spad{x} exactly.")) (|norm| ((|#2| $) "\\spad{norm(x)} returns \\spad{x} * conjugate(x)")) (|real| ((|#2| $) "\\spad{real(x)} returns real part of \\spad{x.}")) (|imag| ((|#2| $) "\\spad{imag(x)} returns imaginary part of \\spad{x.}")) (|conjugate| (($ $) "\\spad{conjugate(x + \\spad{%i} \\spad{y)}} returns \\spad{x} - \\spad{%i} \\spad{y.}")) (|imaginary| (($) "\\spad{imaginary()} = sqrt(-1) = \\%i.")) (|complex| (($ |#2| |#2|) "\\spad{complex(x,y)} constructs \\spad{x} + \\%i*y.") ((|attribute|) "indicates that \\% has sqrt(-1)"))) 
NIL 
((|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#2| (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#2| (QUOTE (|RadicalCategory|))) (|HasCategory| |#2| (QUOTE (|TranscendentalFunctionCategory|))) (|HasCategory| |#2| (QUOTE (|RealNumberSystem|))) (|HasCategory| |#2| (QUOTE (|RealConstant|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasAttribute| |#2| (QUOTE |additiveValuation|)) (|HasAttribute| |#2| (QUOTE |multiplicativeValuation|)) (|HasCategory| |#2| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|OrderedSet|)))) 
(|ComplexCategory| R) 
((|constructor| (NIL "This category represents the extension of a ring by a square root of \\spad{-1.}")) (|rationalIfCan| (((|Union| (|Fraction| (|Integer|)) "failed") $) "\\spad{rationalIfCan(x)} returns \\spad{x} as a rational number, or \"failed\" if \\spad{x} is not a rational number.")) (|rational| (((|Fraction| (|Integer|)) $) "\\spad{rational(x)} returns \\spad{x} as a rational number. Error: if \\spad{x} is not a rational number.")) (|rational?| (((|Boolean|) $) "\\spad{rational?(x)} tests if \\spad{x} is a rational number.")) (|polarCoordinates| (((|Record| (|:| |r| |#1|) (|:| |phi| |#1|)) $) "\\spad{polarCoordinates(x)} returns \\spad{(r,} phi) such that \\spad{x} = \\spad{r} * exp(\\%i * phi).")) (|argument| ((|#1| $) "\\spad{argument(x)} returns the angle made by (0,1) and (0,x).")) (|abs| (($ $) "\\spad{abs(x)} returns the absolute value of \\spad{x} = sqrt(norm(x)).")) (|exquo| (((|Union| $ "failed") $ |#1|) "\\spad{exquo(x, \\spad{r)}} returns the exact quotient of \\spad{x} by \\spad{r,} or \"failed\" if \\spad{r} does not divide \\spad{x} exactly.")) (|norm| ((|#1| $) "\\spad{norm(x)} returns \\spad{x} * conjugate(x)")) (|real| ((|#1| $) "\\spad{real(x)} returns real part of \\spad{x.}")) (|imag| ((|#1| $) "\\spad{imag(x)} returns imaginary part of \\spad{x.}")) (|conjugate| (($ $) "\\spad{conjugate(x + \\spad{%i} \\spad{y)}} returns \\spad{x} - \\spad{%i} \\spad{y.}")) (|imaginary| (($) "\\spad{imaginary()} = sqrt(-1) = \\%i.")) (|complex| (($ |#1| |#1|) "\\spad{complex(x,y)} constructs \\spad{x} + \\%i*y.") ((|attribute|) "indicates that \\% has sqrt(-1)"))) 
((|noZeroDivisors| OR (|has| |#1| (|IntegralDomain|)) (AND (|has| |#1| (|EuclideanDomain|)) (|has| |#1| (|PolynomialFactorizationExplicit|)))) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|additiveValuation| |has| |#1| (ATTRIBUTE |additiveValuation|)) (|multiplicativeValuation| |has| |#1| (ATTRIBUTE |multiplicativeValuation|)) (|complex| . T) (|nil| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|ComplexFactorization| RR PR) 
((|constructor| (NIL "This package has no description")) (|factor| (((|Factored| |#2|) |#2|) "\\spad{factor(p)} factorizes the polynomial \\spad{p} with complex coefficients."))) 
NIL 
NIL 
(|ComplexFunctions2| R S) 
((|constructor| (NIL "This package extends maps from underlying rings to maps between complex over those rings.")) (|map| (((|Complex| |#2|) (|Mapping| |#2| |#1|) (|Complex| |#1|)) "\\spad{map(f,u)} maps \\spad{f} onto real and imaginary parts of u."))) 
NIL 
NIL 
(|Complex| R) 
((|constructor| (NIL "\\spadtype{Complex(R)} creates the domain of elements of the form \\spad{a + \\spad{b} * i} where \\spad{a} and \\spad{b} come from the ring \\spad{R,} and \\spad{i} is a new element such that \\spad{i**2 = -1}."))) 
((|noZeroDivisors| OR (|has| |#1| (|IntegralDomain|)) (AND (|has| |#1| (|EuclideanDomain|)) (|has| |#1| (|PolynomialFactorizationExplicit|)))) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|additiveValuation| |has| |#1| (ATTRIBUTE |additiveValuation|)) (|multiplicativeValuation| |has| |#1| (ATTRIBUTE |multiplicativeValuation|)) (|complex| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))) (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|))) (AND (|HasCategory| |#1| (QUOTE (|RadicalCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (|HasCategory| |#1| (QUOTE (|RealConstant|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (OR (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (OR (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (OR (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (|devaluate| |#1|))) (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (LIST (QUOTE |Eltable|) (|devaluate| |#1|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|OpenMath|))) (|HasCategory| |#1| (QUOTE (|RealNumberSystem|))) (AND (|HasCategory| |#1| (QUOTE (|RealNumberSystem|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|))) (OR (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Eltable|) (|devaluate| |#1|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (AND (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (AND (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))) (|HasCategory| |#1| (QUOTE (|Finite|)))) (AND (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (AND (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))) (|HasCategory| |#1| (QUOTE (|OpenMath|)))) (AND (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))) (|HasCategory| |#1| (QUOTE (|RealConstant|)))) (AND (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|))))) (AND (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|Field|))) (AND (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))))) (OR (AND (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))))) (OR (AND (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (OR (AND (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasAttribute| |#1| (QUOTE |additiveValuation|)) (|HasAttribute| |#1| (QUOTE |multiplicativeValuation|)) (AND (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))))) 
(|ComplexPattern| R S CS) 
((|constructor| (NIL "This package supports converting complex expressions to patterns")) (|convert| (((|Pattern| |#1|) |#3|) "\\spad{convert(cs)} converts the complex expression \\spad{cs} to a pattern"))) 
NIL 
NIL 
(|SubSpaceComponentProperty|) 
((|constructor| (NIL "This domain implements some global properties of subspaces.")) (|copy| (($ $) "\\spad{copy(x)} is not documented")) (|solid| (((|Boolean|) $ (|Boolean|)) "\\spad{solid(x,b)} is not documented")) (|close| (((|Boolean|) $ (|Boolean|)) "\\spad{close(x,b)} is not documented")) (|solid?| (((|Boolean|) $) "\\spad{solid?(x)} is not documented")) (|closed?| (((|Boolean|) $) "\\spad{closed?(x)} is not documented")) (|new| (($) "\\spad{new()} is not documented"))) 
NIL 
NIL 
(|CommutativeRing|) 
((|constructor| (NIL "The category of commutative rings with unity, \\spadignore{i.e.} rings where \\spadop{*} is commutative, and which have a multiplicative identity element.")) (|commutative| ((|attribute| "*") "multiplication is commutative."))) 
(((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|ContinuedFraction| R) 
((|constructor| (NIL "\\spadtype{ContinuedFraction} implements general continued fractions. This version is not restricted to simple, finite fractions and uses the \\spadtype{Stream} as a representation. The arithmetic functions assume that the approximants alternate below/above the convergence point. This is enforced by ensuring the partial numerators and partial denominators are greater than 0 in the Euclidean domain view of \\spad{R} (\\spadignore{i.e.} \\spad{sizeLess?(0, x)}).")) (|complete| (($ $) "\\spad{complete(x)} causes all entries in \\spadvar{x} to be computed. Normally entries are only computed as needed. If \\spadvar{x} is an infinite continued fraction, a user-initiated interrupt is necessary to stop the computation.")) (|extend| (($ $ (|Integer|)) "\\spad{extend(x,n)} causes the first \\spadvar{n} entries in the continued fraction \\spadvar{x} to be computed. Normally entries are only computed as needed.")) (|denominators| (((|Stream| |#1|) $) "\\spad{denominators(x)} returns the stream of denominators of the approximants of the continued fraction \\spadvar{x}. If the continued fraction is finite, then the stream will be finite.")) (|numerators| (((|Stream| |#1|) $) "\\spad{numerators(x)} returns the stream of numerators of the approximants of the continued fraction \\spadvar{x}. If the continued fraction is finite, then the stream will be finite.")) (|convergents| (((|Stream| (|Fraction| |#1|)) $) "\\spad{convergents(x)} returns the stream of the convergents of the continued fraction \\spadvar{x}. If the continued fraction is finite, then the stream will be finite.")) (|approximants| (((|Stream| (|Fraction| |#1|)) $) "\\spad{approximants(x)} returns the stream of approximants of the continued fraction \\spadvar{x}. If the continued fraction is finite, then the stream will be infinite and periodic with period 1.")) (|reducedForm| (($ $) "\\spad{reducedForm(x)} puts the continued fraction \\spadvar{x} in reduced form, \\spadignore{i.e.} the function returns an equivalent continued fraction of the form \\spad{continuedFraction(b0,[1,1,1,...],[b1,b2,b3,...])}.")) (|wholePart| ((|#1| $) "\\spad{wholePart(x)} extracts the whole part of \\spadvar{x}. That is, if \\spad{x = continuedFraction(b0, [a1,a2,a3,...], [b1,b2,b3,...])}, then \\spad{wholePart(x) = b0}.")) (|partialQuotients| (((|Stream| |#1|) $) "\\spad{partialQuotients(x)} extracts the partial quotients in \\spadvar{x}. That is, if \\spad{x = continuedFraction(b0, [a1,a2,a3,...], [b1,b2,b3,...])}, then \\spad{partialQuotients(x) = [b0,b1,b2,b3,...]}.")) (|partialDenominators| (((|Stream| |#1|) $) "\\spad{partialDenominators(x)} extracts the denominators in \\spadvar{x}. That is, if \\spad{x = continuedFraction(b0, [a1,a2,a3,...], [b1,b2,b3,...])}, then \\spad{partialDenominators(x) = [b1,b2,b3,...]}.")) (|partialNumerators| (((|Stream| |#1|) $) "\\spad{partialNumerators(x)} extracts the numerators in \\spadvar{x}. That is, if \\spad{x = continuedFraction(b0, [a1,a2,a3,...], [b1,b2,b3,...])}, then \\spad{partialNumerators(x) = [a1,a2,a3,...]}.")) (|reducedContinuedFraction| (($ |#1| (|Stream| |#1|)) "\\spad{reducedContinuedFraction(b0,b)} constructs a continued fraction in the following way: if \\spad{b = [b1,b2,...]} then the result is the continued fraction \\spad{b0 + 1/(b1 + 1/(b2 + ...))}. That is, the result is the same as \\spad{continuedFraction(b0,[1,1,1,...],[b1,b2,b3,...])}.")) (|continuedFraction| (($ |#1| (|Stream| |#1|) (|Stream| |#1|)) "\\spad{continuedFraction(b0,a,b)} constructs a continued fraction in the following way: if \\spad{a = [a1,a2,...]} and \\spad{b = [b1,b2,...]} then the result is the continued fraction \\spad{b0 + \\spad{a1/(b1} + \\spad{a2/(b2} + ...))}.") (($ (|Fraction| |#1|)) "\\spad{continuedFraction(r)} converts the fraction \\spadvar{r} with components of type \\spad{R} to a continued fraction over \\spad{R}."))) 
(((|commutative| "*") . T) (|noZeroDivisors| . T) (|canonicalUnitNormal| . T) (|canonicalsClosed| . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|CoordinateSystems| R) 
((|constructor| (NIL "CoordinateSystems provides coordinate transformation functions for plotting. Functions in this package return conversion functions which take points expressed in other coordinate systems and return points with the corresponding Cartesian coordinates.")) (|conical| (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1| |#1|) "\\spad{conical(a,b)} transforms from conical coordinates to Cartesian coordinates: \\spad{conical(a,b)} is a function which will map the point \\spad{(lambda,mu,nu)} to \\spad{x = lambda*mu*nu/(a*b)}, \\spad{y = lambda/a*sqrt((mu**2-a**2)*(nu**2-a**2)/(a**2-b**2))}, \\spad{z = lambda/b*sqrt((mu**2-b**2)*(nu**2-b**2)/(b**2-a**2))}.")) (|toroidal| (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|) "\\spad{toroidal(a)} transforms from toroidal coordinates to Cartesian coordinates: \\spad{toroidal(a)} is a function which will map the point \\spad{(u,v,phi)} to \\spad{x = a*sinh(v)*cos(phi)/(cosh(v)-cos(u))}, \\spad{y = a*sinh(v)*sin(phi)/(cosh(v)-cos(u))}, \\spad{z = a*sin(u)/(cosh(v)-cos(u))}.")) (|bipolarCylindrical| (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|) "\\spad{bipolarCylindrical(a)} transforms from bipolar cylindrical coordinates to Cartesian coordinates: \\spad{bipolarCylindrical(a)} is a function which will map the point \\spad{(u,v,z)} to \\spad{x = a*sinh(v)/(cosh(v)-cos(u))}, \\spad{y = a*sin(u)/(cosh(v)-cos(u))}, \\spad{z}.")) (|bipolar| (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|) "\\spad{bipolar(a)} transforms from bipolar coordinates to Cartesian coordinates: \\spad{bipolar(a)} is a function which will map the point \\spad{(u,v)} to \\spad{x = a*sinh(v)/(cosh(v)-cos(u))}, \\spad{y = a*sin(u)/(cosh(v)-cos(u))}.")) (|oblateSpheroidal| (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|) "\\spad{oblateSpheroidal(a)} transforms from oblate spheroidal coordinates to Cartesian coordinates: \\spad{oblateSpheroidal(a)} is a function which will map the point \\spad{(xi,eta,phi)} to \\spad{x = a*sinh(xi)*sin(eta)*cos(phi)}, \\spad{y = a*sinh(xi)*sin(eta)*sin(phi)}, \\spad{z = a*cosh(xi)*cos(eta)}.")) (|prolateSpheroidal| (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|) "\\spad{prolateSpheroidal(a)} transforms from prolate spheroidal coordinates to Cartesian coordinates: \\spad{prolateSpheroidal(a)} is a function which will map the point \\spad{(xi,eta,phi)} to \\spad{x = a*sinh(xi)*sin(eta)*cos(phi)}, \\spad{y = a*sinh(xi)*sin(eta)*sin(phi)}, \\spad{z = a*cosh(xi)*cos(eta)}.")) (|ellipticCylindrical| (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|) "\\spad{ellipticCylindrical(a)} transforms from elliptic cylindrical coordinates to Cartesian coordinates: \\spad{ellipticCylindrical(a)} is a function which will map the point \\spad{(u,v,z)} to \\spad{x = a*cosh(u)*cos(v)}, \\spad{y = a*sinh(u)*sin(v)}, \\spad{z}.")) (|elliptic| (((|Mapping| (|Point| |#1|) (|Point| |#1|)) |#1|) "\\spad{elliptic(a)} transforms from elliptic coordinates to Cartesian coordinates: \\spad{elliptic(a)} is a function which will map the point \\spad{(u,v)} to \\spad{x = a*cosh(u)*cos(v)}, \\spad{y = a*sinh(u)*sin(v)}.")) (|paraboloidal| (((|Point| |#1|) (|Point| |#1|)) "\\spad{paraboloidal(pt)} transforms \\spad{pt} from paraboloidal coordinates to Cartesian coordinates: the function produced will map the point \\spad{(u,v,phi)} to \\spad{x = u*v*cos(phi)}, \\spad{y = u*v*sin(phi)}, \\spad{z = 1/2 * \\spad{(u**2} - v**2)}.")) (|parabolicCylindrical| (((|Point| |#1|) (|Point| |#1|)) "\\spad{parabolicCylindrical(pt)} transforms \\spad{pt} from parabolic cylindrical coordinates to Cartesian coordinates: the function produced will map the point \\spad{(u,v,z)} to \\spad{x = 1/2*(u**2 - v**2)}, \\spad{y = u*v}, \\spad{z}.")) (|parabolic| (((|Point| |#1|) (|Point| |#1|)) "\\spad{parabolic(pt)} transforms \\spad{pt} from parabolic coordinates to Cartesian coordinates: the function produced will map the point \\spad{(u,v)} to \\spad{x = 1/2*(u**2 - v**2)}, \\spad{y = u*v}.")) (|spherical| (((|Point| |#1|) (|Point| |#1|)) "\\spad{spherical(pt)} transforms \\spad{pt} from spherical coordinates to Cartesian coordinates: the function produced will map the point \\spad{(r,theta,phi)} to \\spad{x = r*sin(phi)*cos(theta)}, \\spad{y = r*sin(phi)*sin(theta)}, \\spad{z = r*cos(phi)}.")) (|cylindrical| (((|Point| |#1|) (|Point| |#1|)) "\\spad{cylindrical(pt)} transforms \\spad{pt} from polar coordinates to Cartesian coordinates: the function produced will map the point \\spad{(r,theta,z)} to \\spad{x = \\spad{r} * cos(theta)}, \\spad{y = \\spad{r} * sin(theta)}, \\spad{z}.")) (|polar| (((|Point| |#1|) (|Point| |#1|)) "\\spad{polar(pt)} transforms \\spad{pt} from polar coordinates to Cartesian coordinates: the function produced will map the point \\spad{(r,theta)} to \\spad{x = \\spad{r} * cos(theta)} ,{} \\spad{y = \\spad{r} * sin(theta)}.")) (|cartesian| (((|Point| |#1|) (|Point| |#1|)) "\\spad{cartesian(pt)} returns the Cartesian coordinates of point \\spad{pt.}"))) 
NIL 
NIL 
(|CharacteristicPolynomialInMonogenicalAlgebra| R |PolR| E) 
((|constructor| (NIL "This package implements characteristicPolynomials for monogenic algebras using resultants")) (|characteristicPolynomial| ((|#2| |#3|) "\\spad{characteristicPolynomial(e)} returns the characteristic polynomial of \\spad{e} using resultants"))) 
NIL 
NIL 
(|ComplexPatternMatch| R S CS) 
((|constructor| (NIL "This package supports matching patterns involving complex expressions")) (|patternMatch| (((|PatternMatchResult| |#1| |#3|) |#3| (|Pattern| |#1|) (|PatternMatchResult| |#1| |#3|)) "\\spad{patternMatch(cexpr, pat, res)} matches the pattern \\spad{pat} to the complex expression cexpr. res contains the variables of \\spad{pat} which are already matched and their matches."))) 
NIL 
((|HasCategory| (|Polynomial| |#2|) (LIST (QUOTE |PatternMatchable|) (|devaluate| |#1|)))) 
(|CRApackage| R) 
((|constructor| (NIL "This package has no documentation")) (|multiEuclideanTree| (((|List| |#1|) (|List| |#1|) |#1|) "\\spad{multiEuclideanTree(l,r)} \\undocumented{}")) (|chineseRemainder| (((|List| |#1|) (|List| (|List| |#1|)) (|List| |#1|)) "\\spad{chineseRemainder(llv,lm)} returns a list of values, each of which corresponds to the Chinese remainder of the associated element of \\axiom{llv} and axiom{lm}. This is more efficient than applying chineseRemainder several times.") ((|#1| (|List| |#1|) (|List| |#1|)) "\\spad{chineseRemainder(lv,lm)} returns a value \\axiom{v} such that, if \\spad{x} is \\axiom{lv.i} modulo \\axiom{lm.i} for all \\axiom{i}, then \\spad{x} is \\axiom{v} modulo \\axiom{lm(1)*lm(2)*...*lm(n)}.")) (|modTree| (((|List| |#1|) |#1| (|List| |#1|)) "\\spad{modTree(r,l)} \\undocumented{}"))) 
NIL 
NIL 
(|ComplexRootFindingPackage| R UP) 
((|constructor| (NIL "\\spadtype{ComplexRootFindingPackage} provides functions to find all roots of a polynomial \\spad{p} over the complex number by using Plesken's idea to calculate in the polynomial ring modulo \\spad{f} and employing the Chinese Remainder Theorem. In this first version, the precision (see digits) is not increased when this is necessary to avoid rounding errors. Hence it is the user's responsibility to increase the precision if necessary. Note also, if this package is called with \\spadignore{e.g.} \\spadtype{Fraction Integer}, the precise calculations could require a lot of time. Also note that evaluating the zeros is not necessarily a good check whether the result is correct: already evaluation can cause rounding errors.")) (|startPolynomial| (((|Record| (|:| |start| |#2|) (|:| |factors| (|Factored| |#2|))) |#2|) "\\spad{startPolynomial(p)} uses the ideas of Schoenhage's variant of Graeffe's method to construct circles which separate roots to get a good start polynomial, \\spadignore{i.e.} one whose image under the Chinese Remainder Isomorphism has both entries of norm smaller and greater or equal to 1. In case the roots are found during internal calculations. The corresponding factors are in factors which are otherwise 1.")) (|setErrorBound| ((|#1| |#1|) "\\spad{setErrorBound(eps)} changes the internal error bound, by default being 10 \\spad{**} (-3) to eps, if \\spad{R} is a member in the category \\spadtype{QuotientFieldCategory Integer}. The internal globalDigits is set to \\em \\spad{ceiling(1/r)**2*10} being 10**7 by default.")) (|schwerpunkt| (((|Complex| |#1|) |#2|) "\\spad{schwerpunkt(p)} determines the 'Schwerpunkt' of the roots of the polynomial \\spad{p} of degree \\spad{n,} \\spadignore{i.e.} the center of gravity, which is coeffient of \\spad{x**(n-1)} divided by \\spad{n} times coefficient of \\spad{x**n}.")) (|rootRadius| ((|#1| |#2|) "\\spad{rootRadius(p)} calculates the root radius of \\spad{p} with a maximal error quotient of 1+globalEps, where globalEps is the internal error bound, which can be set by setErrorBound.") ((|#1| |#2| |#1|) "\\spad{rootRadius(p,errQuot)} calculates the root radius of \\spad{p} with a maximal error quotient of errQuot.")) (|reciprocalPolynomial| ((|#2| |#2|) "\\spad{reciprocalPolynomial(p)} calulates a polynomial which has exactly the inverses of the non-zero roots of \\spad{p} as roots, and the same number of 0-roots.")) (|pleskenSplit| (((|Factored| |#2|) |#2| |#1|) "\\spad{pleskenSplit(poly, eps)} determines a start polynomial start by using \"startPolynomial then it increases the exponent \\spad{n} of start \\spad{**} \\spad{n} mod \\spad{poly} to get an approximate factor of poly, in general of degree \"degree \\spad{poly} -1\". Then a divisor cascade is calculated and the best splitting is chosen, as soon as the error is small enough.") (((|Factored| |#2|) |#2| |#1| (|Boolean|)) "\\spad{pleskenSplit(poly,eps,info)} determines a start polynomial start by using \"startPolynomial then it increases the exponent \\spad{n} of start \\spad{**} \\spad{n} mod \\spad{poly} to get an approximate factor of poly, in general of degree \"degree \\spad{poly} -1\". Then a divisor cascade is calculated and the best splitting is chosen, as soon as the error is small enough. If \\spad{info} is true, then information messages are issued.")) (|norm| ((|#1| |#2|) "\\spad{norm(p)} determines sum of absolute values of coefficients Note that this function depends on abs.")) (|graeffe| ((|#2| |#2|) "\\spad{graeffe \\spad{p}} determines \\spad{q} such that \\spad{q(-z**2) = p(z)*p(-z)}. Note that the roots of \\spad{q} are the squares of the roots of \\spad{p.}")) (|factor| (((|Factored| |#2|) |#2|) "\\spad{factor(p)} tries to factor \\spad{p} into linear factors with error atmost globalEps, the internal error bound, which can be set by setErrorBound. An overall error bound \\spad{eps0} is determined and iterated tree-like calls to pleskenSplit are used to get the factorization.") (((|Factored| |#2|) |#2| |#1|) "\\spad{factor(p, eps)} tries to factor \\spad{p} into linear factors with error atmost eps. An overall error bound \\spad{eps0} is determined and iterated tree-like calls to pleskenSplit are used to get the factorization.") (((|Factored| |#2|) |#2| |#1| (|Boolean|)) "\\spad{factor(p, eps, info)} tries to factor \\spad{p} into linear factors with error atmost eps. An overall error bound \\spad{eps0} is determined and iterated tree-like calls to pleskenSplit are used to get the factorization. If info is true, then information messages are given.")) (|divisorCascade| (((|List| (|Record| (|:| |factors| (|List| |#2|)) (|:| |error| |#1|))) |#2| |#2|) "\\spad{divisorCascade(p,tp)} assumes that degree of polynomial \\spad{tp} is smaller than degree of polynomial \\spad{p,} both monic. A sequence of divisions is calculated using the remainder, made monic, as divisor for the the next division. The result contains also the error of the factorizations, \\spadignore{i.e.} the norm of the remainder polynomial.") (((|List| (|Record| (|:| |factors| (|List| |#2|)) (|:| |error| |#1|))) |#2| |#2| (|Boolean|)) "\\spad{divisorCascade(p,tp)} assumes that degree of polynomial \\spad{tp} is smaller than degree of polynomial \\spad{p,} both monic. A sequence of divisions are calculated using the remainder, made monic, as divisor for the the next division. The result contains also the error of the factorizations, \\spadignore{i.e.} the norm of the remainder polynomial. If info is true, then information messages are issued.")) (|complexZeros| (((|List| (|Complex| |#1|)) |#2| |#1|) "\\spad{complexZeros(p, eps)} tries to determine all complex zeros of the polynomial \\spad{p} with accuracy given by eps.") (((|List| (|Complex| |#1|)) |#2|) "\\spad{complexZeros(p)} tries to determine all complex zeros of the polynomial \\spad{p} with accuracy given by the package constant globalEps which you may change by setErrorBound."))) 
NIL 
NIL 
(|CyclicStreamTools| S ST) 
((|constructor| (NIL "This package provides tools for working with cyclic streams.")) (|computeCycleEntry| ((|#2| |#2| |#2|) "\\indented{1}{computeCycleEntry(x,cycElt), where cycElt is a pointer to a} \\indented{1}{node in the cyclic part of the cyclic stream \\spad{x,} returns a} \\indented{1}{pointer to the first node in the cycle} \\blankline \\spad{X} p:=repeating([1,2,3]) \\spad{X} q:=cons(4,p) \\spad{X} computeCycleEntry(q,cycleElt(q))")) (|computeCycleLength| (((|NonNegativeInteger|) |#2|) "\\indented{1}{computeCycleLength(s) returns the length of the cycle of a} \\indented{1}{cyclic stream \\spad{t,} where \\spad{s} is a pointer to a node in the} \\indented{1}{cyclic part of \\spad{t.}} \\blankline \\spad{X} p:=repeating([1,2,3]) \\spad{X} q:=cons(4,p) \\spad{X} computeCycleLength(cycleElt(q))")) (|cycleElt| (((|Union| |#2| "failed") |#2|) "\\indented{1}{cycleElt(s) returns a pointer to a node in the cycle if the stream} \\indented{1}{s is cyclic and returns \"failed\" if \\spad{s} is not cyclic} \\blankline \\spad{X} p:=repeating([1,2,3]) \\spad{X} q:=cons(4,p) \\spad{X} cycleElt \\spad{q} \\spad{X} r:=[1,2,3]::Stream(Integer) \\spad{X} cycleElt \\spad{r}"))) 
NIL 
NIL 
(|ComplexTrigonometricManipulations| R F) 
((|constructor| (NIL "\\spadtype{ComplexTrigonometricManipulations} provides function that compute the real and imaginary parts of complex functions.")) (|complexForm| (((|Complex| (|Expression| |#1|)) |#2|) "\\spad{complexForm(f)} returns \\spad{[real \\spad{f,} imag f]}.")) (|trigs| ((|#2| |#2|) "\\spad{trigs(f)} rewrites all the complex logs and exponentials appearing in \\spad{f} in terms of trigonometric functions.")) (|real?| (((|Boolean|) |#2|) "\\spad{real?(f)} returns \\spad{true} if \\spad{f = real \\spad{f}.}")) (|imag| (((|Expression| |#1|) |#2|) "\\spad{imag(f)} returns the imaginary part of \\spad{f} where \\spad{f} is a complex function.")) (|real| (((|Expression| |#1|) |#2|) "\\spad{real(f)} returns the real part of \\spad{f} where \\spad{f} is a complex function.")) (|complexElementary| ((|#2| |#2| (|Symbol|)) "\\spad{complexElementary(f, \\spad{x)}} rewrites the kernels of \\spad{f} involving \\spad{x} in terms of the 2 fundamental complex transcendental elementary functions: \\spad{log, exp}.") ((|#2| |#2|) "\\spad{complexElementary(f)} rewrites \\spad{f} in terms of the 2 fundamental complex transcendental elementary functions: \\spad{log, exp}.")) (|complexNormalize| ((|#2| |#2| (|Symbol|)) "\\spad{complexNormalize(f, \\spad{x)}} rewrites \\spad{f} using the least possible number of complex independent kernels involving \\spad{x}.") ((|#2| |#2|) "\\spad{complexNormalize(f)} rewrites \\spad{f} using the least possible number of complex independent kernels."))) 
NIL 
NIL 
(|CoerceVectorMatrixPackage| R) 
((|constructor| (NIL "CoerceVectorMatrixPackage is an unexposed, technical package for data conversions")) (|coerce| (((|Vector| (|Matrix| (|Fraction| (|Polynomial| |#1|)))) (|Vector| (|Matrix| |#1|))) "\\spad{coerce(v)} coerces a vector \\spad{v} with entries in \\spadtype{Matrix \\spad{R}} as vector over \\spadtype{Matrix Fraction Polynomial \\spad{R}}")) (|coerceP| (((|Vector| (|Matrix| (|Polynomial| |#1|))) (|Vector| (|Matrix| |#1|))) "\\spad{coerceP(v)} coerces a vector \\spad{v} with entries in \\spadtype{Matrix \\spad{R}} as vector over \\spadtype{Matrix Polynomial \\spad{R}}"))) 
NIL 
NIL 
(|CycleIndicators|) 
((|constructor| (NIL "Polya-Redfield enumeration by cycle indices.")) (|skewSFunction| (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|List| (|Integer|)) (|List| (|Integer|))) "\\spad{skewSFunction(li1,li2)} is the S-function \\indented{1}{of the partition difference \\spad{li1 - li2}} \\indented{1}{expressed in terms of power sum symmetric functions.}")) (|SFunction| (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|List| (|Integer|))) "\\spad{SFunction(li)} is the S-function of the partition \\spad{li} \\indented{1}{expressed in terms of power sum symmetric functions.}")) (|wreath| (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|SymmetricPolynomial| (|Fraction| (|Integer|))) (|SymmetricPolynomial| (|Fraction| (|Integer|)))) "\\spad{wreath(s1,s2)} is the cycle index of the wreath product \\indented{1}{of the two groups whose cycle indices are \\spad{s1} and} \\indented{1}{\\spad{s2}.}")) (|eval| (((|Fraction| (|Integer|)) (|SymmetricPolynomial| (|Fraction| (|Integer|)))) "\\spad{eval \\spad{s}} is the sum of the coefficients of a cycle index.")) (|cup| (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|SymmetricPolynomial| (|Fraction| (|Integer|))) (|SymmetricPolynomial| (|Fraction| (|Integer|)))) "\\spad{cup(s1,s2)}, introduced by Redfield, \\indented{1}{is the scalar product of two cycle indices, in which the} \\indented{1}{power sums are retained to produce a cycle index.}")) (|cap| (((|Fraction| (|Integer|)) (|SymmetricPolynomial| (|Fraction| (|Integer|))) (|SymmetricPolynomial| (|Fraction| (|Integer|)))) "\\spad{cap(s1,s2)}, introduced by Redfield, \\indented{1}{is the scalar product of two cycle indices.}")) (|graphs| (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|)) "\\spad{graphs \\spad{n}} is the cycle index of the group induced on \\indented{1}{the edges of a graph by applying the symmetric function to the} \\indented{1}{n nodes.}")) (|dihedral| (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|)) "\\spad{dihedral \\spad{n}} is the cycle index of the \\indented{1}{dihedral group of degree \\spad{n.}}")) (|cyclic| (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|)) "\\spad{cyclic \\spad{n}} is the cycle index of the \\indented{1}{cyclic group of degree \\spad{n.}}")) (|alternating| (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|)) "\\spad{alternating \\spad{n}} is the cycle index of the \\indented{1}{alternating group of degree \\spad{n.}}")) (|elementary| (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|)) "\\spad{elementary \\spad{n}} is the \\spad{n} th elementary symmetric \\indented{1}{function expressed in terms of power sums.}")) (|powerSum| (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|)) "\\spad{powerSum \\spad{n}} is the \\spad{n} th power sum symmetric \\indented{1}{function.}")) (|complete| (((|SymmetricPolynomial| (|Fraction| (|Integer|))) (|Integer|)) "\\spad{complete \\spad{n}} is the \\spad{n} th complete homogeneous \\indented{1}{symmetric function expressed in terms of power sums.} \\indented{1}{Alternatively it is the cycle index of the symmetric} \\indented{1}{group of degree \\spad{n.}}"))) 
NIL 
NIL 
(|CyclotomicPolynomialPackage|) 
((|constructor| (NIL "This package has no description")) (|cyclotomicFactorization| (((|Factored| (|SparseUnivariatePolynomial| (|Integer|))) (|Integer|)) "\\spad{cyclotomicFactorization(n)} \\undocumented{}")) (|cyclotomic| (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|)) "\\spad{cyclotomic(n)} \\undocumented{}")) (|cyclotomicDecomposition| (((|List| (|SparseUnivariatePolynomial| (|Integer|))) (|Integer|)) "\\spad{cyclotomicDecomposition(n)} \\undocumented{}"))) 
NIL 
NIL 
(|d01AgentsPackage|) 
((|constructor| (NIL "\\axiomType{d01AgentsPackage} is a package of numerical agents to be used to investigate attributes of an input function so as to decide the \\axiomFun{measure} of an appropriate numerical integration routine. It contains functions \\axiomFun{rangeIsFinite} to test the input range and \\axiomFun{functionIsContinuousAtEndPoints} to check for continuity at the end points of the range.")) (|changeName| (((|Result|) (|Symbol|) (|Symbol|) (|Result|)) "\\spad{changeName(s,t,r)} changes the name of item \\axiom{s} in \\axiom{r} to \\axiom{t}.")) (|commaSeparate| (((|String|) (|List| (|String|))) "\\spad{commaSeparate(l)} produces a comma separated string from a list of strings.")) (|sdf2lst| (((|List| (|String|)) (|Stream| (|DoubleFloat|))) "\\spad{sdf2lst(ln)} coerces a Stream of \\axiomType{DoubleFloat} to \\axiomType{List String}")) (|ldf2lst| (((|List| (|String|)) (|List| (|DoubleFloat|))) "\\spad{ldf2lst(ln)} coerces a List of \\axiomType{DoubleFloat} to \\axiomType{List String}")) (|df2st| (((|String|) (|DoubleFloat|)) "\\spad{df2st(n)} coerces a \\axiomType{DoubleFloat} to \\axiomType{String}")) (|singularitiesOf| (((|Stream| (|DoubleFloat|)) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{singularitiesOf(args)} returns a list of potential singularities of the function within the given range")) (|problemPoints| (((|List| (|DoubleFloat|)) (|Expression| (|DoubleFloat|)) (|Symbol|) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{problemPoints(f,var,range)} returns a list of possible problem points by looking at the zeros of the denominator of the function if it can be retracted to \\axiomType{Polynomial DoubleFloat}.")) (|functionIsOscillatory| (((|Float|) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{functionIsOscillatory(a)} tests whether the function \\spad{a.fn} has many zeros of its derivative.")) (|gethi| (((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{gethi(x)} gets the \\axiomType{DoubleFloat} equivalent of the second endpoint of the range \\axiom{x}")) (|getlo| (((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{getlo(x)} gets the \\axiomType{DoubleFloat} equivalent of the first endpoint of the range \\axiom{x}")) (|functionIsContinuousAtEndPoints| (((|Union| (|:| |continuous| "Continuous at the end points") (|:| |lowerSingular| "There is a singularity at the lower end point") (|:| |upperSingular| "There is a singularity at the upper end point") (|:| |bothSingular| "There are singularities at both end points") (|:| |notEvaluated| "End point continuity not yet evaluated")) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{functionIsContinuousAtEndPoints(args)} uses power series limits to check for problems at the end points of the range of \\spad{args}.")) (|rangeIsFinite| (((|Union| (|:| |finite| "The range is finite") (|:| |lowerInfinite| "The bottom of range is infinite") (|:| |upperInfinite| "The top of range is infinite") (|:| |bothInfinite| "Both top and bottom points are infinite") (|:| |notEvaluated| "Range not yet evaluated")) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{rangeIsFinite(args)} tests the endpoints of \\spad{args.range} for infinite end points."))) 
NIL 
NIL 
(|d01ajfAnnaType|) 
((|constructor| (NIL "\\axiomType{d01ajfAnnaType} is a domain of \\axiomType{NumericalIntegrationCategory} for the NAG routine D01AJF, a general numerical integration routine which can handle some singularities in the input function. The function \\axiomFun{measure} measures the usefulness of the routine D01AJF for the given problem. The function \\axiomFun{numericalIntegration} performs the integration by using \\axiomType{NagIntegrationPackage}."))) 
NIL 
NIL 
(|d01akfAnnaType|) 
((|constructor| (NIL "\\axiomType{d01akfAnnaType} is a domain of \\axiomType{NumericalIntegrationCategory} for the NAG routine D01AKF, a numerical integration routine which is is suitable for oscillating, non-singular functions. The function \\axiomFun{measure} measures the usefulness of the routine D01AKF for the given problem. The function \\axiomFun{numericalIntegration} performs the integration by using \\axiomType{NagIntegrationPackage}."))) 
NIL 
NIL 
(|d01alfAnnaType|) 
((|constructor| (NIL "\\axiomType{d01alfAnnaType} is a domain of \\axiomType{NumericalIntegrationCategory} for the NAG routine D01ALF, a general numerical integration routine which can handle a list of singularities. The function \\axiomFun{measure} measures the usefulness of the routine D01ALF for the given problem. The function \\axiomFun{numericalIntegration} performs the integration by using \\axiomType{NagIntegrationPackage}."))) 
NIL 
NIL 
(|d01amfAnnaType|) 
((|constructor| (NIL "\\axiomType{d01amfAnnaType} is a domain of \\axiomType{NumericalIntegrationCategory} for the NAG routine D01AMF, a general numerical integration routine which can handle infinite or semi-infinite range of the input function. The function \\axiomFun{measure} measures the usefulness of the routine D01AMF for the given problem. The function \\axiomFun{numericalIntegration} performs the integration by using \\axiomType{NagIntegrationPackage}."))) 
NIL 
NIL 
(|d01anfAnnaType|) 
((|constructor| (NIL "\\axiomType{d01anfAnnaType} is a domain of \\axiomType{NumericalIntegrationCategory} for the NAG routine D01ANF, a numerical integration routine which can handle weight functions of the form cos(\\omega \\spad{x)} or sin(\\omega \\spad{x).} The function \\axiomFun{measure} measures the usefulness of the routine D01ANF for the given problem. The function \\axiomFun{numericalIntegration} performs the integration by using \\axiomType{NagIntegrationPackage}."))) 
NIL 
NIL 
(|d01apfAnnaType|) 
((|constructor| (NIL "\\axiomType{d01apfAnnaType} is a domain of \\axiomType{NumericalIntegrationCategory} for the NAG routine D01APF, a general numerical integration routine which can handle end point singularities of the algebraico-logarithmic form w(x) = (x-a)^c * (b-x)^d. The function \\axiomFun{measure} measures the usefulness of the routine D01APF for the given problem. The function \\axiomFun{numericalIntegration} performs the integration by using \\axiomType{NagIntegrationPackage}."))) 
NIL 
NIL 
(|d01aqfAnnaType|) 
((|constructor| (NIL "\\axiomType{d01aqfAnnaType} is a domain of \\axiomType{NumericalIntegrationCategory} for the NAG routine D01AQF, a general numerical integration routine which can solve an integral of the form /home/bjd/Axiom/anna/hypertex/bitmaps/d01aqf.xbm The function \\axiomFun{measure} measures the usefulness of the routine D01AQF for the given problem. The function \\axiomFun{numericalIntegration} performs the integration by using \\axiomType{NagIntegrationPackage}."))) 
NIL 
NIL 
(|d01asfAnnaType|) 
((|constructor| (NIL "\\axiomType{d01asfAnnaType} is a domain of \\axiomType{NumericalIntegrationCategory} for the NAG routine D01ASF, a numerical integration routine which can handle weight functions of the form cos(\\omega \\spad{x)} or sin(\\omega \\spad{x)} on an semi-infinite range. The function \\axiomFun{measure} measures the usefulness of the routine D01ASF for the given problem. The function \\axiomFun{numericalIntegration} performs the integration by using \\axiomType{NagIntegrationPackage}."))) 
NIL 
NIL 
(|d01fcfAnnaType|) 
((|constructor| (NIL "\\axiomType{d01fcfAnnaType} is a domain of \\axiomType{NumericalIntegrationCategory} for the NAG routine D01FCF, a numerical integration routine which can handle multi-dimensional quadrature over a finite region. The function \\axiomFun{measure} measures the usefulness of the routine D01GBF for the given problem. The function \\axiomFun{numericalIntegration} performs the integration by using \\axiomType{NagIntegrationPackage}."))) 
NIL 
NIL 
(|d01gbfAnnaType|) 
((|constructor| (NIL "\\axiomType{d01gbfAnnaType} is a domain of \\axiomType{NumericalIntegrationCategory} for the NAG routine D01GBF, a numerical integration routine which can handle multi-dimensional quadrature over a finite region. The function \\axiomFun{measure} measures the usefulness of the routine D01GBF for the given problem. The function \\axiomFun{numericalIntegration} performs the integration by using \\axiomType{NagIntegrationPackage}."))) 
NIL 
NIL 
(|d01TransformFunctionType|) 
NIL 
NIL 
NIL 
(|d01WeightsPackage|) 
((|constructor| (NIL "\\axiom{d01WeightsPackage} is a package for functions used to investigate whether a function can be divided into a simpler function and a weight function. The types of weights investigated are those giving rise to end-point singularities of the algebraico-logarithmic type, and trigonometric weights.")) (|exprHasLogarithmicWeights| (((|Integer|) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\axiom{exprHasLogarithmicWeights} looks for logarithmic weights giving rise to singularities of the function at the end-points.")) (|exprHasAlgebraicWeight| (((|Union| (|List| (|DoubleFloat|)) "failed") (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\axiom{exprHasAlgebraicWeight} looks for algebraic weights giving rise to singularities of the function at the end-points.")) (|exprHasWeightCosWXorSinWX| (((|Union| (|Record| (|:| |op| (|BasicOperator|)) (|:| |w| (|DoubleFloat|))) "failed") (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\axiom{exprHasWeightCosWXorSinWX} looks for trigonometric weights in an expression of the form \\axiom{cos \\omega \\spad{x}} or \\axiom{sin \\omega \\spad{x},} returning the value of \\omega (\\notequal 1) and the operator."))) 
NIL 
NIL 
(|d02AgentsPackage|) 
((|constructor| (NIL "\\indented{1}{Author: Brian Dupee} Date Created: May 1994 Date Last Updated: January 1997 Description:")) (|intermediateResultsIF| (((|Float|) (|Record| (|:| |xinit| (|DoubleFloat|)) (|:| |xend| (|DoubleFloat|)) (|:| |fn| (|Vector| (|Expression| (|DoubleFloat|)))) (|:| |yinit| (|List| (|DoubleFloat|))) (|:| |intvals| (|List| (|DoubleFloat|))) (|:| |g| (|Expression| (|DoubleFloat|))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{intermediateResultsIF(o)} returns a value corresponding to the required number of intermediate results required and, therefore, an indication of how much this would affect the step-length of the calculation. It returns a value in the range [0,1].")) (|accuracyIF| (((|Float|) (|Record| (|:| |xinit| (|DoubleFloat|)) (|:| |xend| (|DoubleFloat|)) (|:| |fn| (|Vector| (|Expression| (|DoubleFloat|)))) (|:| |yinit| (|List| (|DoubleFloat|))) (|:| |intvals| (|List| (|DoubleFloat|))) (|:| |g| (|Expression| (|DoubleFloat|))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{accuracyIF(o)} returns the intensity value of the accuracy requirements of the input ODE. A request of accuracy of 10^-6 corresponds to the neutral intensity. It returns a value in the range [0,1].")) (|expenseOfEvaluationIF| (((|Float|) (|Record| (|:| |xinit| (|DoubleFloat|)) (|:| |xend| (|DoubleFloat|)) (|:| |fn| (|Vector| (|Expression| (|DoubleFloat|)))) (|:| |yinit| (|List| (|DoubleFloat|))) (|:| |intvals| (|List| (|DoubleFloat|))) (|:| |g| (|Expression| (|DoubleFloat|))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{expenseOfEvaluationIF(o)} returns the intensity value of the cost of evaluating the input ODE. This is in terms of the number of ``operational units''. It returns a value in the range [0,1].\\indent{20} 400 ``operation units'' \\spad{->} 0.75 200 ``operation units'' \\spad{->} 0.5 83 ``operation units'' \\spad{->} 0.25 \\indent{15} exponentiation = 4 units ,{} function calls = 10 units.")) (|systemSizeIF| (((|Float|) (|Record| (|:| |xinit| (|DoubleFloat|)) (|:| |xend| (|DoubleFloat|)) (|:| |fn| (|Vector| (|Expression| (|DoubleFloat|)))) (|:| |yinit| (|List| (|DoubleFloat|))) (|:| |intvals| (|List| (|DoubleFloat|))) (|:| |g| (|Expression| (|DoubleFloat|))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{systemSizeIF(ode)} returns the intensity value of the size of the system of ODEs. 20 equations corresponds to the neutral value. It returns a value in the range [0,1].")) (|stiffnessAndStabilityOfODEIF| (((|Record| (|:| |stiffnessFactor| (|Float|)) (|:| |stabilityFactor| (|Float|))) (|Record| (|:| |xinit| (|DoubleFloat|)) (|:| |xend| (|DoubleFloat|)) (|:| |fn| (|Vector| (|Expression| (|DoubleFloat|)))) (|:| |yinit| (|List| (|DoubleFloat|))) (|:| |intvals| (|List| (|DoubleFloat|))) (|:| |g| (|Expression| (|DoubleFloat|))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{stiffnessAndStabilityOfODEIF(ode)} calculates the intensity values of stiffness of a system of first-order differential equations (by evaluating the maximum difference in the real parts of the negative eigenvalues of the jacobian of the system for which O(10) equates to mildly stiff wheras stiffness ratios of O(10^6) are not uncommon) and whether the system is likely to show any oscillations (identified by the closeness to the imaginary axis of the complex eigenvalues of the jacobian). \\blankline It returns two values in the range [0,1].")) (|stiffnessAndStabilityFactor| (((|Record| (|:| |stiffnessFactor| (|Float|)) (|:| |stabilityFactor| (|Float|))) (|Matrix| (|Expression| (|DoubleFloat|)))) "\\spad{stiffnessAndStabilityFactor(me)} calculates the stability and stiffness factor of a system of first-order differential equations (by evaluating the maximum difference in the real parts of the negative eigenvalues of the jacobian of the system for which O(10) equates to mildly stiff wheras stiffness ratios of O(10^6) are not uncommon) and whether the system is likely to show any oscillations (identified by the closeness to the imaginary axis of the complex eigenvalues of the jacobian).")) (|eval| (((|Matrix| (|Expression| (|DoubleFloat|))) (|Matrix| (|Expression| (|DoubleFloat|))) (|List| (|Symbol|)) (|Vector| (|Expression| (|DoubleFloat|)))) "\\spad{eval(mat,symbols,values)} evaluates a multivariable matrix at given \\spad{values} for each of a list of variables")) (|jacobian| (((|Matrix| (|Expression| (|DoubleFloat|))) (|Vector| (|Expression| (|DoubleFloat|))) (|List| (|Symbol|))) "\\spad{jacobian(v,w)} is a local function to make a jacobian matrix")) (|sparsityIF| (((|Float|) (|Matrix| (|Expression| (|DoubleFloat|)))) "\\spad{sparsityIF(m)} calculates the sparsity of a jacobian matrix")) (|combineFeatureCompatibility| (((|Float|) (|Float|) (|List| (|Float|))) "\\spad{combineFeatureCompatibility(C1,L)} is for interacting attributes") (((|Float|) (|Float|) (|Float|)) "\\spad{combineFeatureCompatibility(C1,C2)} is for interacting attributes"))) 
NIL 
NIL 
(|d02bbfAnnaType|) 
((|constructor| (NIL "\\axiomType{d02bbfAnnaType} is a domain of \\axiomType{OrdinaryDifferentialEquationsInitialValueProblemSolverCategory} for the NAG routine D02BBF, a ODE routine which uses an Runge-Kutta method to solve a system of differential equations. The function \\axiomFun{measure} measures the usefulness of the routine D02BBF for the given problem. The function \\axiomFun{ODESolve} performs the integration by using \\axiomType{NagOrdinaryDifferentialEquationsPackage}."))) 
NIL 
NIL 
(|d02bhfAnnaType|) 
((|constructor| (NIL "\\axiomType{d02bhfAnnaType} is a domain of \\axiomType{OrdinaryDifferentialEquationsInitialValueProblemSolverCategory} for the NAG routine D02BHF, a ODE routine which uses an Runge-Kutta method to solve a system of differential equations. The function \\axiomFun{measure} measures the usefulness of the routine D02BHF for the given problem. The function \\axiomFun{ODESolve} performs the integration by using \\axiomType{NagOrdinaryDifferentialEquationsPackage}."))) 
NIL 
NIL 
(|d02cjfAnnaType|) 
((|constructor| (NIL "\\axiomType{d02cjfAnnaType} is a domain of \\axiomType{OrdinaryDifferentialEquationsInitialValueProblemSolverCategory} for the NAG routine D02CJF, a ODE routine which uses an Adams-Moulton-Bashworth method to solve a system of differential equations. The function \\axiomFun{measure} measures the usefulness of the routine D02CJF for the given problem. The function \\axiomFun{ODESolve} performs the integration by using \\axiomType{NagOrdinaryDifferentialEquationsPackage}."))) 
NIL 
NIL 
(|d02ejfAnnaType|) 
((|constructor| (NIL "\\axiomType{d02ejfAnnaType} is a domain of \\axiomType{OrdinaryDifferentialEquationsInitialValueProblemSolverCategory} for the NAG routine D02EJF, a ODE routine which uses a backward differentiation formulae method to handle a stiff system of differential equations. The function \\axiomFun{measure} measures the usefulness of the routine D02EJF for the given problem. The function \\axiomFun{ODESolve} performs the integration by using \\axiomType{NagOrdinaryDifferentialEquationsPackage}."))) 
NIL 
NIL 
(|d03AgentsPackage|) 
((|constructor| (NIL "\\axiom{d03AgentsPackage} contains a set of computational agents for use with Partial Differential Equation solvers.")) (|elliptic?| (((|Boolean|) (|Record| (|:| |pde| (|List| (|Expression| (|DoubleFloat|)))) (|:| |constraints| (|List| (|Record| (|:| |start| (|DoubleFloat|)) (|:| |finish| (|DoubleFloat|)) (|:| |grid| (|NonNegativeInteger|)) (|:| |boundaryType| (|Integer|)) (|:| |dStart| (|Matrix| (|DoubleFloat|))) (|:| |dFinish| (|Matrix| (|DoubleFloat|)))))) (|:| |f| (|List| (|List| (|Expression| (|DoubleFloat|))))) (|:| |st| (|String|)) (|:| |tol| (|DoubleFloat|)))) "\\spad{elliptic?(r)} \\undocumented{}")) (|central?| (((|Boolean|) (|DoubleFloat|) (|DoubleFloat|) (|List| (|Expression| (|DoubleFloat|)))) "\\spad{central?(f,g,l)} \\undocumented{}")) (|subscriptedVariables| (((|Expression| (|DoubleFloat|)) (|Expression| (|DoubleFloat|))) "\\spad{subscriptedVariables(e)} \\undocumented{}")) (|varList| (((|List| (|Symbol|)) (|Symbol|) (|NonNegativeInteger|)) "\\spad{varList(s,n)} \\undocumented{}"))) 
NIL 
NIL 
(|d03eefAnnaType|) 
((|constructor| (NIL "\\axiomType{d03eefAnnaType} is a domain of \\axiomType{PartialDifferentialEquationsSolverCategory} for the NAG routines D03EEF/D03EDF."))) 
NIL 
NIL 
(|d03fafAnnaType|) 
((|constructor| (NIL "\\axiomType{d03fafAnnaType} is a domain of \\axiomType{PartialDifferentialEquationsSolverCategory} for the NAG routine D03FAF."))) 
NIL 
NIL 
(|Database| S) 
((|constructor| (NIL "This domain implements a simple view of a database whose fields are indexed by symbols")) (|coerce| (($ (|List| |#1|)) "\\spad{coerce(l)} makes a database out of a list")) (- (($ $ $) "\\spad{db1-db2} returns the difference of databases \\spad{db1} and \\spad{db2} \\spadignore{i.e.} consisting of elements in \\spad{db1} but not in \\spad{db2}")) (+ (($ $ $) "\\spad{db1+db2} returns the merge of databases \\spad{db1} and \\spad{db2}")) (|fullDisplay| (((|Void|) $ (|PositiveInteger|) (|PositiveInteger|)) "\\spad{fullDisplay(db,start,end \\spad{)}} prints full details of entries in the range \\axiom{start..end} in \\axiom{db}.") (((|Void|) $) "\\spad{fullDisplay(db)} prints full details of each entry in \\axiom{db}.") (((|Void|) $) "\\spad{fullDisplay(x)} displays \\spad{x} in detail")) (|display| (((|Void|) $) "\\spad{display(db)} prints a summary line for each entry in \\axiom{db}.") (((|Void|) $) "\\spad{display(x)} displays \\spad{x} in some form")) (|elt| (((|DataList| (|String|)) $ (|Symbol|)) "\\spad{elt(db,s)} returns the \\axiom{s} field of each element of \\axiom{db}.") (($ $ (|QueryEquation|)) "\\spad{elt(db,q)} returns all elements of \\axiom{db} which satisfy \\axiom{q}.") (((|String|) $ (|Symbol|)) "\\spad{elt(x,s)} returns an element of \\spad{x} indexed by \\spad{s}"))) 
NIL 
NIL 
(|DoubleResultantPackage| F UP UPUP R) 
((|constructor| (NIL "This package provides functions for computing the residues of a function on an algebraic curve.")) (|doubleResultant| ((|#2| |#4| (|Mapping| |#2| |#2|)) "\\spad{doubleResultant(f, \\spad{')}} returns p(x) whose roots are rational multiples of the residues of \\spad{f} at all its finite poles. Argument ' is the derivation to use."))) 
NIL 
NIL 
(|DistinctDegreeFactorize| F FP) 
((|constructor| (NIL "Package for the factorization of a univariate polynomial with coefficients in a finite field. The algorithm used is the \"distinct degree\" algorithm of Cantor-Zassenhaus, modified to use trace instead of the norm and a table for computing Frobenius as suggested by Naudin and Quitte .")) (|irreducible?| (((|Boolean|) |#2|) "\\spad{irreducible?(p)} tests whether the polynomial \\spad{p} is irreducible.")) (|tracePowMod| ((|#2| |#2| (|NonNegativeInteger|) |#2|) "\\spad{tracePowMod(u,k,v)} produces the sum of \\spad{u**(q**i)} for \\spad{i} running and \\spad{q=} size \\spad{F}")) (|trace2PowMod| ((|#2| |#2| (|NonNegativeInteger|) |#2|) "\\spad{trace2PowMod(u,k,v)} produces the sum of u**(2**i) for \\spad{i} running from 1 to \\spad{k} all computed modulo the polynomial \\spad{v.}")) (|exptMod| ((|#2| |#2| (|NonNegativeInteger|) |#2|) "\\spad{exptMod(u,k,v)} raises the polynomial \\spad{u} to the \\spad{k}th power modulo the polynomial \\spad{v.}")) (|separateFactors| (((|List| |#2|) (|List| (|Record| (|:| |deg| (|NonNegativeInteger|)) (|:| |prod| |#2|)))) "\\spad{separateFactors(lfact)} takes the list produced by separateDegrees and produces the complete list of factors.")) (|separateDegrees| (((|List| (|Record| (|:| |deg| (|NonNegativeInteger|)) (|:| |prod| |#2|))) |#2|) "\\spad{separateDegrees(p)} splits the square free polynomial \\spad{p} into factors each of which is a product of irreducibles of the same degree.")) (|distdfact| (((|Record| (|:| |cont| |#1|) (|:| |factors| (|List| (|Record| (|:| |irr| |#2|) (|:| |pow| (|Integer|)))))) |#2| (|Boolean|)) "\\spad{distdfact(p,sqfrflag)} produces the complete factorization of the polynomial \\spad{p} returning an internal data structure. If argument \\spad{sqfrflag} is true, the polynomial is assumed square free.")) (|factorSquareFree| (((|Factored| |#2|) |#2|) "\\spad{factorSquareFree(p)} produces the complete factorization of the square free polynomial \\spad{p.}")) (|factor| (((|Factored| |#2|) |#2|) "\\spad{factor(p)} produces the complete factorization of the polynomial \\spad{p.}"))) 
NIL 
NIL 
(|DecimalExpansion|) 
((|constructor| (NIL "This domain allows rational numbers to be presented as repeating decimal expansions.")) (|decimal| (($ (|Fraction| (|Integer|))) "\\spad{decimal(r)} converts a rational number to a decimal expansion.")) (|fractionPart| (((|Fraction| (|Integer|)) $) "\\spad{fractionPart(d)} returns the fractional part of a decimal expansion.")) (|coerce| (((|RadixExpansion| 10) $) "\\spad{coerce(d)} converts a decimal expansion to a radix expansion with base 10.") (((|Fraction| (|Integer|)) $) "\\spad{coerce(d)} converts a decimal expansion to a rational number."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|Integer|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| (|Integer|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| (|Integer|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Integer|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Integer|) (QUOTE (|RealConstant|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|Integer|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|StepThrough|))) (|HasCategory| (|Integer|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| (|Integer|) (QUOTE (|DifferentialRing|))) (|HasCategory| (|Integer|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |Eltable|) (QUOTE (|Integer|)) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|Integer|) (QUOTE (|IntegerNumberSystem|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (OR (|HasCategory| (|Integer|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Integer|) (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Integer|) (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| (|Integer|) (QUOTE (|CharacteristicNonZero|))))) 
(|ElementaryFunctionDefiniteIntegration| R F) 
((|constructor| (NIL "\\spadtype{ElementaryFunctionDefiniteIntegration} provides functions to compute definite integrals of elementary functions.")) (|innerint| (((|Union| (|:| |f1| (|OrderedCompletion| |#2|)) (|:| |f2| (|List| (|OrderedCompletion| |#2|))) (|:| |fail| "failed") (|:| |pole| "potentialPole")) |#2| (|Symbol|) (|OrderedCompletion| |#2|) (|OrderedCompletion| |#2|) (|Boolean|)) "\\spad{innerint(f, \\spad{x,} a, \\spad{b,} ignore?)} should be local but conditional")) (|integrate| (((|Union| (|:| |f1| (|OrderedCompletion| |#2|)) (|:| |f2| (|List| (|OrderedCompletion| |#2|))) (|:| |fail| "failed") (|:| |pole| "potentialPole")) |#2| (|SegmentBinding| (|OrderedCompletion| |#2|)) (|String|)) "\\spad{integrate(f, \\spad{x} = a..b, \"noPole\")} returns the integral of \\spad{f(x)dx} from a to \\spad{b.} If it is not possible to check whether \\spad{f} has a pole for \\spad{x} between a and \\spad{b} (because of parameters), then this function will assume that \\spad{f} has no such pole. Error: if \\spad{f} has a pole for \\spad{x} between a and \\spad{b} or if the last argument is not \"noPole\".") (((|Union| (|:| |f1| (|OrderedCompletion| |#2|)) (|:| |f2| (|List| (|OrderedCompletion| |#2|))) (|:| |fail| "failed") (|:| |pole| "potentialPole")) |#2| (|SegmentBinding| (|OrderedCompletion| |#2|))) "\\spad{integrate(f, \\spad{x} = a..b)} returns the integral of \\spad{f(x)dx} from a to \\spad{b.} Error: if \\spad{f} has a pole for \\spad{x} between a and \\spad{b.}"))) 
NIL 
NIL 
(|RationalFunctionDefiniteIntegration| R) 
((|constructor| (NIL "Definite integration of rational functions. \\spadtype{RationalFunctionDefiniteIntegration} provides functions to compute definite integrals of rational functions.")) (|integrate| (((|Union| (|:| |f1| (|OrderedCompletion| (|Expression| |#1|))) (|:| |f2| (|List| (|OrderedCompletion| (|Expression| |#1|)))) (|:| |fail| "failed") (|:| |pole| "potentialPole")) (|Fraction| (|Polynomial| |#1|)) (|SegmentBinding| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|)))) (|String|)) "\\spad{integrate(f, \\spad{x} = a..b, \"noPole\")} returns the integral of \\spad{f(x)dx} from a to \\spad{b.} If it is not possible to check whether \\spad{f} has a pole for \\spad{x} between a and \\spad{b} (because of parameters), then this function will assume that \\spad{f} has no such pole. Error: if \\spad{f} has a pole for \\spad{x} between a and \\spad{b} or if the last argument is not \"noPole\".") (((|Union| (|:| |f1| (|OrderedCompletion| (|Expression| |#1|))) (|:| |f2| (|List| (|OrderedCompletion| (|Expression| |#1|)))) (|:| |fail| "failed") (|:| |pole| "potentialPole")) (|Fraction| (|Polynomial| |#1|)) (|SegmentBinding| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|))))) "\\spad{integrate(f, \\spad{x} = a..b)} returns the integral of \\spad{f(x)dx} from a to \\spad{b.} Error: if \\spad{f} has a pole for \\spad{x} between a and \\spad{b.}") (((|Union| (|:| |f1| (|OrderedCompletion| (|Expression| |#1|))) (|:| |f2| (|List| (|OrderedCompletion| (|Expression| |#1|)))) (|:| |fail| "failed") (|:| |pole| "potentialPole")) (|Fraction| (|Polynomial| |#1|)) (|SegmentBinding| (|OrderedCompletion| (|Expression| |#1|))) (|String|)) "\\spad{integrate(f, \\spad{x} = a..b, \"noPole\")} returns the integral of \\spad{f(x)dx} from a to \\spad{b.} If it is not possible to check whether \\spad{f} has a pole for \\spad{x} between a and \\spad{b} (because of parameters), then this function will assume that \\spad{f} has no such pole. Error: if \\spad{f} has a pole for \\spad{x} between a and \\spad{b} or if the last argument is not \"noPole\".") (((|Union| (|:| |f1| (|OrderedCompletion| (|Expression| |#1|))) (|:| |f2| (|List| (|OrderedCompletion| (|Expression| |#1|)))) (|:| |fail| "failed") (|:| |pole| "potentialPole")) (|Fraction| (|Polynomial| |#1|)) (|SegmentBinding| (|OrderedCompletion| (|Expression| |#1|)))) "\\spad{integrate(f, \\spad{x} = a..b)} returns the integral of \\spad{f(x)dx} from a to \\spad{b.} Error: if \\spad{f} has a pole for \\spad{x} between a and \\spad{b.}"))) 
NIL 
NIL 
(|DegreeReductionPackage| R1 R2) 
((|constructor| (NIL "This package has no description")) (|expand| (((|List| (|Expression| |#2|)) (|Expression| |#2|) (|PositiveInteger|)) "\\spad{expand(f,n)} \\undocumented{}")) (|reduce| (((|Record| (|:| |pol| (|SparseUnivariatePolynomial| |#1|)) (|:| |deg| (|PositiveInteger|))) (|SparseUnivariatePolynomial| |#1|)) "\\spad{reduce(p)} \\undocumented{}"))) 
NIL 
NIL 
(|Dequeue| S) 
((|constructor| (NIL "Linked list implementation of a Dequeue")) (|member?| (((|Boolean|) |#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} member?(3,a)")) (|members| (((|List| |#1|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} members a")) (|parts| (((|List| |#1|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} parts a")) (|#| (((|NonNegativeInteger|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} \\#a")) (|count| (((|NonNegativeInteger|) |#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} count(4,a)") (((|NonNegativeInteger|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} count(x+->(x>2),a)")) (|any?| (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} any?(x+->(x=4),a)")) (|every?| (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} every?(x+->(x=4),a)")) (~= (((|Boolean|) $ $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} b:=copy a \\spad{X} (a~=b)")) (= (((|Boolean|) $ $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} b:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} (a=b)@Boolean")) (|coerce| (((|OutputForm|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} coerce a")) (|hash| (((|SingleInteger|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} hash a")) (|latex| (((|String|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} latex a")) (|map!| (($ (|Mapping| |#1| |#1|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} map!(x+->x+10,a) \\spad{X} a")) (|top!| ((|#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} top! a \\spad{X} a")) (|reverse!| (($ $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} reverse! a \\spad{X} a")) (|push!| ((|#1| |#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} push! a \\spad{X} a")) (|pop!| ((|#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} pop! a \\spad{X} a")) (|insertTop!| ((|#1| |#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} insertTop! a \\spad{X} a")) (|insertBottom!| ((|#1| |#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} insertBottom! a \\spad{X} a")) (|extractTop!| ((|#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} extractTop! a \\spad{X} a")) (|extractBottom!| ((|#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} extractBottom! a \\spad{X} a")) (|bottom!| ((|#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} bottom! a \\spad{X} a")) (|top| ((|#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} top a")) (|height| (((|NonNegativeInteger|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} height a")) (|depth| (((|NonNegativeInteger|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} depth a")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} map(x+->x+10,a) \\spad{X} a")) (|eq?| (((|Boolean|) $ $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} b:=copy a \\spad{X} eq?(a,b)")) (|copy| (($ $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} copy a")) (|sample| (($) "\\blankline \\spad{X} sample()$Dequeue(INT)")) (|empty| (($) "\\blankline \\spad{X} b:=empty()$(Dequeue INT)")) (|empty?| (((|Boolean|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} empty? a")) (|bag| (($ (|List| |#1|)) "\\blankline \\spad{X} bag([1,2,3,4,5])$Dequeue(INT)")) (|size?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} size?(a,5)")) (|more?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} more?(a,9)")) (|less?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} less?(a,9)")) (|length| (((|NonNegativeInteger|) $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} length a")) (|rotate!| (($ $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} rotate! a")) (|back| ((|#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} back a")) (|front| ((|#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} front a")) (|inspect| ((|#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} inspect a")) (|insert!| (($ |#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} insert! (8,a) \\spad{X} a")) (|enqueue!| ((|#1| |#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} enqueue! (9,a) \\spad{X} a")) (|extract!| ((|#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} extract! a \\spad{X} a")) (|dequeue!| ((|#1| $) "\\blankline \\spad{X} a:Dequeue INT:= dequeue [1,2,3,4,5] \\spad{X} dequeue! a \\spad{X} a")) (|dequeue| (($) "\\blankline \\spad{X} a:Dequeue INT:= dequeue \\spad{()}") (($ (|List| |#1|)) "\\indented{1}{dequeue([x,y,...,z]) creates a dequeue with first (top or front)} \\indented{1}{element \\spad{x,} second element y,...,and last (bottom or back) element \\spad{z.}} \\blankline \\spad{E} g:Dequeue INT:= dequeue [1,2,3,4,5]"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|DeRhamComplex| |CoefRing| |listIndVar|) 
((|constructor| (NIL "The deRham complex of Euclidean space, that is, the class of differential forms of arbitary degree over a coefficient ring. See Flanders, Harley, Differential Forms, With Applications to the Physical Sciences, New York, Academic Press, 1963.")) (|exteriorDifferential| (($ $) "\\spad{exteriorDifferential(df)} returns the exterior derivative (gradient, curl, divergence, ...) of the differential form \\spad{df.}")) (|totalDifferential| (($ (|Expression| |#1|)) "\\spad{totalDifferential(x)} returns the total differential (gradient) form for element \\spad{x.}")) (|map| (($ (|Mapping| (|Expression| |#1|) (|Expression| |#1|)) $) "\\spad{map(f,df)} replaces each coefficient \\spad{x} of differential form \\spad{df} by \\spad{f(x)}.")) (|degree| (((|Integer|) $) "\\spad{degree(df)} returns the homogeneous degree of differential form \\spad{df.}")) (|retractable?| (((|Boolean|) $) "\\spad{retractable?(df)} tests if differential form \\spad{df} is a 0-form, \\spadignore{i.e.} if degree(df) = 0.")) (|homogeneous?| (((|Boolean|) $) "\\spad{homogeneous?(df)} tests if all of the terms of differential form \\spad{df} have the same degree.")) (|generator| (($ (|NonNegativeInteger|)) "\\spad{generator(n)} returns the \\spad{n}th basis term for a differential form.")) (|coefficient| (((|Expression| |#1|) $ $) "\\spad{coefficient(df,u)}, where \\spad{df} is a differential form, returns the coefficient of \\spad{df} containing the basis term \\spad{u} if such a term exists, and 0 otherwise.")) (|reductum| (($ $) "\\spad{reductum(df)}, where \\spad{df} is a differential form, returns \\spad{df} minus the leading term of \\spad{df} if \\spad{df} has two or more terms, and 0 otherwise.")) (|leadingBasisTerm| (($ $) "\\spad{leadingBasisTerm(df)} returns the leading basis term of differential form \\spad{df.}")) (|leadingCoefficient| (((|Expression| |#1|) $) "\\spad{leadingCoefficient(df)} returns the leading coefficient of differential form \\spad{df.}"))) 
((|unitsKnown| . T)) 
NIL 
(|DefiniteIntegrationTools| R F) 
((|constructor| (NIL "\\spadtype{DefiniteIntegrationTools} provides common tools used by the definite integration of both rational and elementary functions.")) (|checkForZero| (((|Union| (|Boolean|) "failed") (|SparseUnivariatePolynomial| |#2|) (|OrderedCompletion| |#2|) (|OrderedCompletion| |#2|) (|Boolean|)) "\\spad{checkForZero(p, a, \\spad{b,} incl?)} is \\spad{true} if \\spad{p} has a zero between a and \\spad{b,} \\spad{false} otherwise, \"failed\" if this cannot be determined. Check for a and \\spad{b} inclusive if incl? is true, exclusive otherwise.") (((|Union| (|Boolean|) "failed") (|Polynomial| |#1|) (|Symbol|) (|OrderedCompletion| |#2|) (|OrderedCompletion| |#2|) (|Boolean|)) "\\spad{checkForZero(p, \\spad{x,} a, \\spad{b,} incl?)} is \\spad{true} if \\spad{p} has a zero for \\spad{x} between a and \\spad{b,} \\spad{false} otherwise, \"failed\" if this cannot be determined. Check for a and \\spad{b} inclusive if incl? is true, exclusive otherwise.")) (|computeInt| (((|Union| (|OrderedCompletion| |#2|) "failed") (|Kernel| |#2|) |#2| (|OrderedCompletion| |#2|) (|OrderedCompletion| |#2|) (|Boolean|)) "\\spad{computeInt(x, \\spad{g,} a, \\spad{b,} eval?)} returns the integral of \\spad{f} for \\spad{x} between a and \\spad{b,} assuming that \\spad{g} is an indefinite integral of \\spad{f} and \\spad{f} has no pole between a and \\spad{b.} If \\spad{eval?} is true, then \\spad{g} can be evaluated safely at \\spad{a} and \\spad{b}, provided that they are finite values. Otherwise, limits must be computed.")) (|ignore?| (((|Boolean|) (|String|)) "\\spad{ignore?(s)} is \\spad{true} if \\spad{s} is the string that tells the integrator to assume that the function has no pole in the integration interval."))) 
NIL 
NIL 
(|DoubleFloat|) 
((|constructor| (NIL "\\spadtype{DoubleFloat} is intended to make accessible hardware floating point arithmetic in Axiom, either native double precision, or IEEE. On most machines, there will be hardware support for the arithmetic operations: \\spad{++} \\spad{+,} \\spad{*,} / and possibly also the sqrt operation. The operations exp, log, sin, cos, atan are normally coded in software based on minimax polynomial/rational approximations. \\blankline Some general comments about the accuracy of the operations: the operations \\spad{+,} \\spad{*,} / and sqrt are expected to be fully accurate. The operations exp, log, sin, cos and atan are not expected to be fully accurate. In particular, sin and cos will lose all precision for large arguments. \\blankline The Float domain provides an alternative to the DoubleFloat domain. It provides an arbitrary precision model of floating point arithmetic. This means that accuracy problems like those above are eliminated by increasing the working precision where necessary. \\spadtype{Float} provides some special functions such as erf, the error function in addition to the elementary functions. The disadvantage of Float is that it is much more expensive than small floats when the latter can be used.")) (|integerDecode| (((|List| (|Integer|)) $) "\\spad{integerDecode(x)} returns the multiple values of the common lisp integer-decode-float function. See Steele, ISBN 0-13-152414-3 p354. This function can be used to ensure that the results are bit-exact and do not depend on the binary-to-decimal conversions. \\blankline \\spad{X} \\spad{a:DFLOAT:=-1.0/3.0} \\spad{X} integerDecode a")) (|machineFraction| (((|Fraction| (|Integer|)) $) "\\spad{machineFraction(x)} returns a bit-exact fraction of the machine floating point number using the common lisp integer-decode-float function. See Steele, ISBN 0-13-152414-3 \\spad{p354} This function can be used to print results which do not depend on binary-to-decimal conversions \\blankline \\spad{X} \\spad{a:DFLOAT:=-1.0/3.0} \\spad{X} machineFraction a")) (|rationalApproximation| (((|Fraction| (|Integer|)) $ (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{rationalApproximation(f, \\spad{n,} \\spad{b)}} computes a rational approximation \\spad{r} to \\spad{f} with relative error \\spad{< b**(-n)} (that is, \\spad{|(r-f)/f| < b**(-n)}).") (((|Fraction| (|Integer|)) $ (|NonNegativeInteger|)) "\\spad{rationalApproximation(f, \\spad{n)}} computes a rational approximation \\spad{r} to \\spad{f} with relative error \\spad{< 10**(-n)}.")) (|doubleFloatFormat| (((|String|) (|String|)) "\\spad{doubleFloatFormat changes} the output format for doublefloats using lisp format strings")) (|Beta| (($ $ $) "\\spad{Beta(x,y)} is \\spad{Gamma(x) * Gamma(y)/Gamma(x+y)}.")) (|Gamma| (($ $) "\\spad{Gamma(x)} is the Euler Gamma function.")) (|atan| (($ $ $) "\\spad{atan(x,y)} computes the arc tangent from \\spad{x} with phase \\spad{y.}")) (|log10| (($ $) "\\spad{log10(x)} computes the logarithm with base 10 for \\spad{x.}")) (|log2| (($ $) "\\spad{log2(x)} computes the logarithm with base 2 for \\spad{x.}")) (|hash| (((|Integer|) $) "\\spad{hash(x)} returns the hash key for \\spad{x}")) (|exp1| (($) "\\spad{exp1()} returns the natural log base \\spad{2.718281828...}.")) (** (($ $ $) "\\spad{x \\spad{**} \\spad{y}} returns the \\spad{y}th power of \\spad{x} (equal to \\spad{exp(y log x)}).")) (/ (($ $ (|Integer|)) "\\spad{x / i} computes the division from \\spad{x} by an integer i."))) 
((|approximate| . T) (|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|DoubleFloatMatrix|) 
((|constructor| (NIL "This is a low-level domain which implements matrices (two dimensional arrays) of double precision floating point numbers. Indexing is 0 based, there is no bound checking (unless provided by lower level).")) (|qnew| (($ (|Integer|) (|Integer|)) "\\indented{1}{qnew(n, \\spad{m)} creates a new uninitialized \\spad{n} by \\spad{m} matrix.} \\blankline \\spad{X} t1:DFMAT:=qnew(3,4)"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|DoubleFloat|) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|DoubleFloat|) (LIST (QUOTE |Evalable|) (QUOTE (|DoubleFloat|)))) (|HasCategory| (|DoubleFloat|) (QUOTE (|SetCategory|)))) (|HasCategory| (|DoubleFloat|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|DoubleFloat|) (QUOTE (|IntegralDomain|))) (|HasAttribute| (|DoubleFloat|) (QUOTE (|commutative| "*"))) (|HasCategory| (|DoubleFloat|) (QUOTE (|CommutativeRing|))) (|HasCategory| (|DoubleFloat|) (QUOTE (|Field|)))) 
(|DoubleFloatSpecialFunctions|) 
((|constructor| (NIL "This package provides special functions for double precision real and complex floating point.")) (|fresnelC| (((|Float|) (|Float|)) "\\indented{1}{fresnelC(f) denotes the Fresnel integral \\spad{C}} \\blankline \\spad{X} fresnelC(1.5)")) (|fresnelS| (((|Float|) (|Float|)) "\\indented{1}{fresnelS(f) denotes the Fresnel integral \\spad{S}} \\blankline \\spad{X} fresnelS(1.5)")) (|hypergeometric0F1| (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))) "\\spad{hypergeometric0F1(c,z)} is the hypergeometric function \\spad{0F1(; \\spad{c;} z)}.") (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) "\\spad{hypergeometric0F1(c,z)} is the hypergeometric function \\spad{0F1(; \\spad{c;} z)}.")) (|airyBi| (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))) "\\spad{airyBi(x)} is the Airy function \\spad{Bi(x)}. This function satisfies the differential equation: \\indented{2}{\\spad{Bi''(x) - \\spad{x} * Bi(x) = 0}.}") (((|DoubleFloat|) (|DoubleFloat|)) "\\spad{airyBi(x)} is the Airy function \\spad{Bi(x)}. This function satisfies the differential equation: \\indented{2}{\\spad{Bi''(x) - \\spad{x} * Bi(x) = 0}.}")) (|airyAi| (((|DoubleFloat|) (|DoubleFloat|)) "\\spad{airyAi(x)} is the Airy function \\spad{Ai(x)}. This function satisfies the differential equation: \\indented{2}{\\spad{Ai''(x) - \\spad{x} * Ai(x) = 0}.}") (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))) "\\spad{airyAi(x)} is the Airy function \\spad{Ai(x)}. This function satisfies the differential equation: \\indented{2}{\\spad{Ai''(x) - \\spad{x} * Ai(x) = 0}.}")) (|besselK| (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))) "\\spad{besselK(v,x)} is the modified Bessel function of the second kind, \\spad{K(v,x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + \\spad{x} w'(x) - (x^2+v^2)w(x) = 0}.} Note that the default implementation uses the relation \\indented{2}{\\spad{K(v,x) = \\%pi/2*(I(-v,x) - I(v,x))/sin(v*\\%pi)}} so is not valid for integer values of \\spad{v.}") (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) "\\spad{besselK(v,x)} is the modified Bessel function of the second kind, \\spad{K(v,x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + \\spad{x} w'(x) - (x^2+v^2)w(x) = 0}.} Note that the default implementation uses the relation \\indented{2}{\\spad{K(v,x) = \\%pi/2*(I(-v,x) - I(v,x))/sin(v*\\%pi)}.} so is not valid for integer values of \\spad{v.}")) (|besselI| (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))) "\\spad{besselI(v,x)} is the modified Bessel function of the first kind, \\spad{I(v,x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + \\spad{x} w'(x) - (x^2+v^2)w(x) = 0}.}") (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) "\\spad{besselI(v,x)} is the modified Bessel function of the first kind, \\spad{I(v,x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + \\spad{x} w'(x) - (x^2+v^2)w(x) = 0}.}")) (|besselY| (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))) "\\spad{besselY(v,x)} is the Bessel function of the second kind, \\spad{Y(v,x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + \\spad{x} w'(x) + (x^2-v^2)w(x) = 0}.} Note that the default implementation uses the relation \\indented{2}{\\spad{Y(v,x) = (J(v,x) cos(v*\\%pi) - J(-v,x))/sin(v*\\%pi)}} so is not valid for integer values of \\spad{v.}") (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) "\\spad{besselY(v,x)} is the Bessel function of the second kind, \\spad{Y(v,x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + \\spad{x} w'(x) + (x^2-v^2)w(x) = 0}.} Note that the default implementation uses the relation \\indented{2}{\\spad{Y(v,x) = (J(v,x) cos(v*\\%pi) - J(-v,x))/sin(v*\\%pi)}} so is not valid for integer values of \\spad{v.}")) (|besselJ| (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))) "\\spad{besselJ(v,x)} is the Bessel function of the first kind, \\spad{J(v,x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + \\spad{x} w'(x) + (x^2-v^2)w(x) = 0}.}") (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) "\\spad{besselJ(v,x)} is the Bessel function of the first kind, \\spad{J(v,x)}. This function satisfies the differential equation: \\indented{2}{\\spad{x^2 w''(x) + \\spad{x} w'(x) + (x^2-v^2)w(x) = 0}.}")) (|polygamma| (((|Complex| (|DoubleFloat|)) (|NonNegativeInteger|) (|Complex| (|DoubleFloat|))) "\\spad{polygamma(n, \\spad{x)}} is the \\spad{n}-th derivative of \\spad{digamma(x)}.") (((|DoubleFloat|) (|NonNegativeInteger|) (|DoubleFloat|)) "\\spad{polygamma(n, \\spad{x)}} is the \\spad{n}-th derivative of \\spad{digamma(x)}.")) (|digamma| (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))) "\\spad{digamma(x)} is the function, \\spad{psi(x)}, defined by \\indented{2}{\\spad{psi(x) = Gamma'(x)/Gamma(x)}.}") (((|DoubleFloat|) (|DoubleFloat|)) "\\spad{digamma(x)} is the function, \\spad{psi(x)}, defined by \\indented{2}{\\spad{psi(x) = Gamma'(x)/Gamma(x)}.}")) (|logGamma| (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))) "\\spad{logGamma(x)} is the natural log of \\spad{Gamma(x)}. This can often be computed even if \\spad{Gamma(x)} cannot.") (((|DoubleFloat|) (|DoubleFloat|)) "\\spad{logGamma(x)} is the natural log of \\spad{Gamma(x)}. This can often be computed even if \\spad{Gamma(x)} cannot.")) (|Beta| (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))) "\\spad{Beta(x, \\spad{y)}} is the Euler beta function, \\spad{B(x,y)}, defined by \\indented{2}{\\spad{Beta(x,y) = integrate(t^(x-1)*(1-t)^(y-1), t=0..1)}.} This is related to \\spad{Gamma(x)} by \\indented{2}{\\spad{Beta(x,y) = Gamma(x)*Gamma(y) / Gamma(x + y)}.}") (((|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) "\\spad{Beta(x, \\spad{y)}} is the Euler beta function, \\spad{B(x,y)}, defined by \\indented{2}{\\spad{Beta(x,y) = integrate(t^(x-1)*(1-t)^(y-1), t=0..1)}.} This is related to \\spad{Gamma(x)} by \\indented{2}{\\spad{Beta(x,y) = Gamma(x)*Gamma(y) / Gamma(x + y)}.}")) (|Ei6| (((|OnePointCompletion| (|DoubleFloat|)) (|OnePointCompletion| (|DoubleFloat|))) "\\spad{Ei6} is the first approximation of \\spad{Ei} where the result is x*\\%e^-x*Ei(x) from 32 to infinity (preserves digits)")) (|Ei5| (((|OnePointCompletion| (|DoubleFloat|)) (|OnePointCompletion| (|DoubleFloat|))) "\\spad{Ei5} is the first approximation of \\spad{Ei} where the result is x*\\%e^-x*Ei(x) from 12 to 32 (preserves digits)")) (|Ei4| (((|OnePointCompletion| (|DoubleFloat|)) (|OnePointCompletion| (|DoubleFloat|))) "\\spad{Ei4} is the first approximation of \\spad{Ei} where the result is x*\\%e^-x*Ei(x) from 4 to 12 (preserves digits)")) (|Ei3| (((|OnePointCompletion| (|DoubleFloat|)) (|OnePointCompletion| (|DoubleFloat|))) "\\spad{Ei3} is the first approximation of \\spad{Ei} where the result is (Ei(x)-log \\spad{|x|} - gamma)/x from \\spad{-4} to 4 (preserves digits)")) (|Ei2| (((|OnePointCompletion| (|DoubleFloat|)) (|OnePointCompletion| (|DoubleFloat|))) "\\spad{Ei2} is the first approximation of \\spad{Ei} where the result is x*\\%e^-x*Ei(x) from \\spad{-10} to \\spad{-4} (preserves digits)")) (|Ei1| (((|OnePointCompletion| (|DoubleFloat|)) (|OnePointCompletion| (|DoubleFloat|))) "\\spad{Ei1} is the first approximation of \\spad{Ei} where the result is x*\\%e^-x*Ei(x) from -infinity to \\spad{-10} (preserves digits)")) (|Ei| (((|OnePointCompletion| (|DoubleFloat|)) (|OnePointCompletion| (|DoubleFloat|))) "\\spad{Ei} is the Exponential Integral function This is computed using a 6 part piecewise approximation. DoubleFloat can only preserve about 16 digits but the Chebyshev approximation used can give 30 digits.")) (|En| (((|OnePointCompletion| (|DoubleFloat|)) (|Integer|) (|DoubleFloat|)) "\\spad{En(n,x)} is the \\spad{n}th Exponential Integral Function")) (E1 (((|OnePointCompletion| (|DoubleFloat|)) (|DoubleFloat|)) "\\spad{E1(x)} is the Exponential Integral function The current implementation is a piecewise approximation involving one poly from \\spad{-4..4} and a second poly for \\spad{x} > 4")) (|Gamma| (((|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))) "\\spad{Gamma(x)} is the Euler gamma function, \\spad{Gamma(x)}, defined by \\indented{2}{\\spad{Gamma(x) = integrate(t^(x-1)*exp(-t), t=0..\\%infinity)}.}") (((|DoubleFloat|) (|DoubleFloat|)) "\\spad{Gamma(x)} is the Euler gamma function, \\spad{Gamma(x)}, defined by \\indented{2}{\\spad{Gamma(x) = integrate(t^(x-1)*exp(-t), t=0..\\%infinity)}.}"))) 
NIL 
NIL 
(|DoubleFloatVector|) 
((|constructor| (NIL "This is a low-level domain which implements vectors (one dimensional arrays) of double precision floating point numbers. Indexing is 0 based, there is no bound checking (unless provided by lower level).")) (|qnew| (($ (|Integer|)) "\\indented{1}{qnew(n) creates a new uninitialized vector of length \\spad{n.}} \\blankline \\spad{X} t1:DFVEC:=qnew(7)"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| (|DoubleFloat|) (QUOTE (|SetCategory|))) (|HasCategory| (|DoubleFloat|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|DoubleFloat|) (QUOTE (|OrderedSet|))) (OR (|HasCategory| (|DoubleFloat|) (QUOTE (|OrderedSet|))) (|HasCategory| (|DoubleFloat|) (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (|HasCategory| (|DoubleFloat|) (QUOTE (|AbelianSemiGroup|))) (|HasCategory| (|DoubleFloat|) (QUOTE (|AbelianMonoid|))) (|HasCategory| (|DoubleFloat|) (QUOTE (|AbelianGroup|))) (|HasCategory| (|DoubleFloat|) (QUOTE (|Monoid|))) (|HasCategory| (|DoubleFloat|) (QUOTE (|Ring|))) (AND (|HasCategory| (|DoubleFloat|) (QUOTE (|RadicalCategory|))) (|HasCategory| (|DoubleFloat|) (QUOTE (|Ring|)))) (AND (|HasCategory| (|DoubleFloat|) (LIST (QUOTE |Evalable|) (QUOTE (|DoubleFloat|)))) (|HasCategory| (|DoubleFloat|) (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| (|DoubleFloat|) (LIST (QUOTE |Evalable|) (QUOTE (|DoubleFloat|)))) (|HasCategory| (|DoubleFloat|) (QUOTE (|OrderedSet|)))) (AND (|HasCategory| (|DoubleFloat|) (LIST (QUOTE |Evalable|) (QUOTE (|DoubleFloat|)))) (|HasCategory| (|DoubleFloat|) (QUOTE (|SetCategory|)))))) 
(|DenavitHartenbergMatrix| R) 
((|constructor| (NIL "4x4 Matrices for coordinate transformations\\br This package contains functions to create 4x4 matrices useful for rotating and transforming coordinate systems. These matrices are useful for graphics and robotics. (Reference: Robot Manipulators Richard Paul MIT Press 1981) \\blankline A Denavit-Hartenberg Matrix is a 4x4 Matrix of the form:\\br \\tab{5}\\spad{nx ox ax px}\\br \\tab{5}\\spad{ny oy ay py}\\br \\tab{5}\\spad{nz oz az pz}\\br \\tab{5}\\spad{0 0 0 1}\\br \\spad{(n,} o, and a are the direction cosines)")) (|translate| (($ |#1| |#1| |#1|) "\\spad{translate(x,y,z)} returns a dhmatrix for translation by \\spad{x,} \\spad{y,} and \\spad{z}")) (|scale| (($ |#1| |#1| |#1|) "\\spad{scale(sx,sy,sz)} returns a dhmatrix for scaling in the \\spad{x,} \\spad{y} and \\spad{z} directions")) (|rotatez| (($ |#1|) "\\spad{rotatez(r)} returns a dhmatrix for rotation about axis \\spad{z} for \\spad{r} degrees")) (|rotatey| (($ |#1|) "\\spad{rotatey(r)} returns a dhmatrix for rotation about axis \\spad{y} for \\spad{r} degrees")) (|rotatex| (($ |#1|) "\\spad{rotatex(r)} returns a dhmatrix for rotation about axis \\spad{x} for \\spad{r} degrees")) (|identity| (($) "\\spad{identity()} create the identity dhmatrix")) (* (((|Point| |#1|) $ (|Point| |#1|)) "\\spad{t*p} applies the dhmatrix \\spad{t} to point \\spad{p}"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasAttribute| |#1| (QUOTE (|commutative| "*"))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|)))) 
(|Dictionary&| A S) 
((|constructor| (NIL "A dictionary is an aggregate in which entries can be inserted, searched for and removed. Duplicates are thrown away on insertion. This category models the usual notion of dictionary which involves large amounts of data where copying is impractical. Principal operations are thus destructive (non-copying) ones."))) 
NIL 
NIL 
(|Dictionary| S) 
((|constructor| (NIL "A dictionary is an aggregate in which entries can be inserted, searched for and removed. Duplicates are thrown away on insertion. This category models the usual notion of dictionary which involves large amounts of data where copying is impractical. Principal operations are thus destructive (non-copying) ones."))) 
((|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|DifferentialExtension&| S R) 
((|constructor| (NIL "Differential extensions of a ring \\spad{R.} Given a differentiation on \\spad{R,} extend it to a differentiation on \\spad{%.}")) (D (($ $ (|Mapping| |#2| |#2|) (|NonNegativeInteger|)) "\\spad{D(x, deriv, \\spad{n)}} differentiate \\spad{x} \\spad{n} times using a derivation which extends \\spad{deriv} on \\spad{R.}") (($ $ (|Mapping| |#2| |#2|)) "\\spad{D(x, deriv)} differentiates \\spad{x} extending the derivation deriv on \\spad{R.}")) (|differentiate| (($ $ (|Mapping| |#2| |#2|) (|NonNegativeInteger|)) "\\spad{differentiate(x, deriv, \\spad{n)}} differentiate \\spad{x} \\spad{n} times using a derivation which extends \\spad{deriv} on \\spad{R.}") (($ $ (|Mapping| |#2| |#2|)) "\\spad{differentiate(x, deriv)} differentiates \\spad{x} extending the derivation deriv on \\spad{R.}"))) 
NIL 
((|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) 
(|DifferentialExtension| R) 
((|constructor| (NIL "Differential extensions of a ring \\spad{R.} Given a differentiation on \\spad{R,} extend it to a differentiation on \\spad{%.}")) (D (($ $ (|Mapping| |#1| |#1|) (|NonNegativeInteger|)) "\\spad{D(x, deriv, \\spad{n)}} differentiate \\spad{x} \\spad{n} times using a derivation which extends \\spad{deriv} on \\spad{R.}") (($ $ (|Mapping| |#1| |#1|)) "\\spad{D(x, deriv)} differentiates \\spad{x} extending the derivation deriv on \\spad{R.}")) (|differentiate| (($ $ (|Mapping| |#1| |#1|) (|NonNegativeInteger|)) "\\spad{differentiate(x, deriv, \\spad{n)}} differentiate \\spad{x} \\spad{n} times using a derivation which extends \\spad{deriv} on \\spad{R.}") (($ $ (|Mapping| |#1| |#1|)) "\\spad{differentiate(x, deriv)} differentiates \\spad{x} extending the derivation deriv on \\spad{R.}"))) 
((|unitsKnown| . T)) 
NIL 
(|DifferentialRing&| S) 
((|constructor| (NIL "An ordinary differential ring, that is, a ring with an operation \\spadfun{differentiate}. \\blankline Axioms\\br \\tab{5}\\spad{differentiate(x+y) = differentiate(x)+differentiate(y)}\\br \\tab{5}\\spad{differentiate(x*y) = x*differentiate(y) + differentiate(x)*y}")) (D (($ $ (|NonNegativeInteger|)) "\\spad{D(x, \\spad{n)}} returns the \\spad{n}-th derivative of \\spad{x.}") (($ $) "\\spad{D(x)} returns the derivative of \\spad{x.} This function is a simple differential operator where no variable needs to be specified.")) (|differentiate| (($ $ (|NonNegativeInteger|)) "\\spad{differentiate(x, \\spad{n)}} returns the \\spad{n}-th derivative of \\spad{x.}") (($ $) "\\spad{differentiate(x)} returns the derivative of \\spad{x.} This function is a simple differential operator where no variable needs to be specified."))) 
NIL 
NIL 
(|DifferentialRing|) 
((|constructor| (NIL "An ordinary differential ring, that is, a ring with an operation \\spadfun{differentiate}. \\blankline Axioms\\br \\tab{5}\\spad{differentiate(x+y) = differentiate(x)+differentiate(y)}\\br \\tab{5}\\spad{differentiate(x*y) = x*differentiate(y) + differentiate(x)*y}")) (D (($ $ (|NonNegativeInteger|)) "\\spad{D(x, \\spad{n)}} returns the \\spad{n}-th derivative of \\spad{x.}") (($ $) "\\spad{D(x)} returns the derivative of \\spad{x.} This function is a simple differential operator where no variable needs to be specified.")) (|differentiate| (($ $ (|NonNegativeInteger|)) "\\spad{differentiate(x, \\spad{n)}} returns the \\spad{n}-th derivative of \\spad{x.}") (($ $) "\\spad{differentiate(x)} returns the derivative of \\spad{x.} This function is a simple differential operator where no variable needs to be specified."))) 
((|unitsKnown| . T)) 
NIL 
(|DictionaryOperations&| A S) 
((|constructor| (NIL "This category is a collection of operations common to both categories \\spadtype{Dictionary} and \\spadtype{MultiDictionary}")) (|select!| (($ (|Mapping| (|Boolean|) |#2|) $) "\\spad{select!(p,d)} destructively changes dictionary \\spad{d} by removing all entries \\spad{x} such that \\axiom{p(x)} is not true.")) (|remove!| (($ (|Mapping| (|Boolean|) |#2|) $) "\\spad{remove!(p,d)} destructively changes dictionary \\spad{d} by removeing all entries \\spad{x} such that \\axiom{p(x)} is true.") (($ |#2| $) "\\spad{remove!(x,d)} destructively changes dictionary \\spad{d} by removing all entries \\spad{y} such that \\axiom{y = \\spad{x}.}")) (|dictionary| (($ (|List| |#2|)) "\\spad{dictionary([x,y,...,z])} creates a dictionary consisting of entries \\axiom{x,y,...,z}.") (($) "\\spad{dictionary()}$D creates an empty dictionary of type \\spad{D.}"))) 
NIL 
((|HasAttribute| |#1| (QUOTE |finiteAggregate|))) 
(|DictionaryOperations| S) 
((|constructor| (NIL "This category is a collection of operations common to both categories \\spadtype{Dictionary} and \\spadtype{MultiDictionary}")) (|select!| (($ (|Mapping| (|Boolean|) |#1|) $) "\\spad{select!(p,d)} destructively changes dictionary \\spad{d} by removing all entries \\spad{x} such that \\axiom{p(x)} is not true.")) (|remove!| (($ (|Mapping| (|Boolean|) |#1|) $) "\\spad{remove!(p,d)} destructively changes dictionary \\spad{d} by removeing all entries \\spad{x} such that \\axiom{p(x)} is true.") (($ |#1| $) "\\spad{remove!(x,d)} destructively changes dictionary \\spad{d} by removing all entries \\spad{y} such that \\axiom{y = \\spad{x}.}")) (|dictionary| (($ (|List| |#1|)) "\\spad{dictionary([x,y,...,z])} creates a dictionary consisting of entries \\axiom{x,y,...,z}.") (($) "\\spad{dictionary()}$D creates an empty dictionary of type \\spad{D.}"))) 
((|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|DiophantineSolutionPackage|) 
((|constructor| (NIL "Any solution of a homogeneous linear Diophantine equation can be represented as a sum of minimal solutions, which form a \"basis\" (a minimal solution cannot be represented as a nontrivial sum of solutions) in the case of an inhomogeneous linear Diophantine equation, each solution is the sum of a inhomogeneous solution and any number of homogeneous solutions therefore, it suffices to compute two sets:\\br \\tab{5}1. all minimal inhomogeneous solutions\\br \\tab{5}2. all minimal homogeneous solutions\\br the algorithm implemented is a completion procedure, which enumerates all solutions in a recursive depth-first-search it can be seen as finding monotone paths in a graph for more details see Reference")) (|dioSolve| (((|Record| (|:| |varOrder| (|List| (|Symbol|))) (|:| |inhom| (|Union| (|List| (|Vector| (|NonNegativeInteger|))) "failed")) (|:| |hom| (|List| (|Vector| (|NonNegativeInteger|))))) (|Equation| (|Polynomial| (|Integer|)))) "\\spad{dioSolve(u)} computes a basis of all minimal solutions for linear homogeneous Diophantine equation u, then all minimal solutions of inhomogeneous equation"))) 
NIL 
NIL 
(|DirectProductCategory&| S |dim| R) 
((|constructor| (NIL "This category represents a finite cartesian product of a given type. Many categorical properties are preserved under this construction.")) (* (($ $ |#3|) "\\spad{y * \\spad{r}} multiplies each component of the vector \\spad{y} by the element \\spad{r.}") (($ |#3| $) "\\spad{r * \\spad{y}} multiplies the element \\spad{r} times each component of the vector \\spad{y.}")) (|dot| ((|#3| $ $) "\\spad{dot(x,y)} computes the inner product of the vectors \\spad{x} and \\spad{y.}")) (|unitVector| (($ (|PositiveInteger|)) "\\spad{unitVector(n)} produces a vector with 1 in position \\spad{n} and zero elsewhere.")) (|directProduct| (($ (|Vector| |#3|)) "\\spad{directProduct(v)} converts the vector \\spad{v} to become a direct product. Error: if the length of \\spad{v} is different from dim.")) (|finiteAggregate| ((|attribute|) "attribute to indicate an aggregate of finite size"))) 
NIL 
((|HasCategory| |#3| (QUOTE (|Field|))) (|HasCategory| |#3| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#3| (QUOTE (|OrderedRing|))) (|HasAttribute| |#3| (QUOTE |unitsKnown|)) (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|Finite|))) (|HasCategory| |#3| (QUOTE (|Monoid|))) (|HasCategory| |#3| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#3| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#3| (QUOTE (|Ring|))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))) 
(|DirectProductCategory| |dim| R) 
((|constructor| (NIL "This category represents a finite cartesian product of a given type. Many categorical properties are preserved under this construction.")) (* (($ $ |#2|) "\\spad{y * \\spad{r}} multiplies each component of the vector \\spad{y} by the element \\spad{r.}") (($ |#2| $) "\\spad{r * \\spad{y}} multiplies the element \\spad{r} times each component of the vector \\spad{y.}")) (|dot| ((|#2| $ $) "\\spad{dot(x,y)} computes the inner product of the vectors \\spad{x} and \\spad{y.}")) (|unitVector| (($ (|PositiveInteger|)) "\\spad{unitVector(n)} produces a vector with 1 in position \\spad{n} and zero elsewhere.")) (|directProduct| (($ (|Vector| |#2|)) "\\spad{directProduct(v)} converts the vector \\spad{v} to become a direct product. Error: if the length of \\spad{v} is different from dim.")) (|finiteAggregate| ((|attribute|) "attribute to indicate an aggregate of finite size"))) 
((|rightUnitary| |has| |#2| (|Ring|)) (|leftUnitary| |has| |#2| (|Ring|)) (|unitsKnown| |has| |#2| (ATTRIBUTE |unitsKnown|)) ((|commutative| "*") |has| |#2| (|CommutativeRing|)) (|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|DirectProductFunctions2| |dim| A B) 
((|constructor| (NIL "This package provides operations which all take as arguments direct products of elements of some type \\spad{A} and functions from \\spad{A} to another type \\spad{B.} The operations all iterate over their vector argument and either return a value of type \\spad{B} or a direct product over \\spad{B.}")) (|map| (((|DirectProduct| |#1| |#3|) (|Mapping| |#3| |#2|) (|DirectProduct| |#1| |#2|)) "\\spad{map(f, \\spad{v)}} applies the function \\spad{f} to every element of the vector \\spad{v} producing a new vector containing the values.")) (|reduce| ((|#3| (|Mapping| |#3| |#2| |#3|) (|DirectProduct| |#1| |#2|) |#3|) "\\spad{reduce(func,vec,ident)} combines the elements in \\spad{vec} using the binary function func. Argument \\spad{ident} is returned if the vector is empty.")) (|scan| (((|DirectProduct| |#1| |#3|) (|Mapping| |#3| |#2| |#3|) (|DirectProduct| |#1| |#2|) |#3|) "\\spad{scan(func,vec,ident)} creates a new vector whose elements are the result of applying reduce to the binary function func, increasing initial subsequences of the vector vec, and the element ident."))) 
NIL 
NIL 
(|DirectProduct| |dim| R) 
((|constructor| (NIL "This type represents the finite direct or cartesian product of an underlying component type. This contrasts with simple vectors in that the members can be viewed as having constant length. Thus many categorical properties can by lifted from the underlying component type. Component extraction operations are provided but no updating operations. Thus new direct product elements can either be created by converting vector elements using the \\spadfun{directProduct} function or by taking appropriate linear combinations of basis vectors provided by the \\spad{unitVector} operation."))) 
((|rightUnitary| |has| |#2| (|Ring|)) (|leftUnitary| |has| |#2| (|Ring|)) (|unitsKnown| |has| |#2| (ATTRIBUTE |unitsKnown|)) ((|commutative| "*") |has| |#2| (|CommutativeRing|)) (|finiteAggregate| . T)) 
((|HasCategory| |#2| (QUOTE (|SetCategory|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedRing|))) (OR (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedRing|)))) (|HasCategory| |#2| (QUOTE (|Monoid|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|Field|)))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (|HasCategory| |#2| (QUOTE (|Finite|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (|HasAttribute| |#2| (QUOTE |unitsKnown|)) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Finite|))) (|HasCategory| |#2| (QUOTE (|Monoid|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedRing|))) (|HasCategory| |#2| (QUOTE (|Ring|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Field|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Finite|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Field|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Finite|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|Field|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|Finite|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))))) 
(|DirichletRing| |Coef|) 
((|constructor| (NIL "DirichletRing is the ring of arithmetical functions with Dirichlet convolution as multiplication")) (|additive?| (((|Boolean|) $ (|PositiveInteger|)) "\\spad{additive?(a, \\spad{n)}} returns \\spad{true} if the first \\spad{n} coefficients of a are additive")) (|multiplicative?| (((|Boolean|) $ (|PositiveInteger|)) "\\spad{multiplicative?(a, \\spad{n)}} returns \\spad{true} if the first \\spad{n} coefficients of a are multiplicative")) (|zeta| (($) "\\spad{zeta()} returns the function which is constantly one"))) 
((|leftUnitary| |has| |#1| (|CommutativeRing|)) (|rightUnitary| |has| |#1| (|CommutativeRing|)) ((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|CommutativeRing|)) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|)))) 
(|DisplayPackage|) 
((|constructor| (NIL "DisplayPackage allows one to print strings in a nice manner, including highlighting substrings.")) (|sayLength| (((|Integer|) (|List| (|String|))) "\\spad{sayLength(l)} returns the length of a list of strings \\spad{l} as an integer.") (((|Integer|) (|String|)) "\\spad{sayLength(s)} returns the length of a string \\spad{s} as an integer.")) (|say| (((|Void|) (|List| (|String|))) "\\spad{say(l)} sends a list of strings \\spad{l} to output.") (((|Void|) (|String|)) "\\spad{say(s)} sends a string \\spad{s} to output.")) (|center| (((|List| (|String|)) (|List| (|String|)) (|Integer|) (|String|)) "\\spad{center(l,i,s)} takes a list of strings \\spad{l,} and centers them within a list of strings which is \\spad{i} characters long, in which the remaining spaces are filled with strings composed of as many repetitions as possible of the last string parameter \\spad{s.}") (((|String|) (|String|) (|Integer|) (|String|)) "\\spad{center(s,i,s)} takes the first string \\spad{s,} and centers it within a string of length i, in which the other elements of the string are composed of as many replications as possible of the second indicated string, \\spad{s} which must have a length greater than that of an empty string.")) (|copies| (((|String|) (|Integer|) (|String|)) "\\spad{copies(i,s)} will take a string \\spad{s} and create a new string composed of \\spad{i} copies of \\spad{s.}")) (|newLine| (((|String|)) "\\spad{newLine()} sends a new line command to output.")) (|bright| (((|List| (|String|)) (|List| (|String|))) "\\spad{bright(l)} sets the font property of a list of strings, \\spad{l,} to bold-face type.") (((|List| (|String|)) (|String|)) "\\spad{bright(s)} sets the font property of the string \\spad{s} to bold-face type."))) 
NIL 
NIL 
(|DivisorCategory| S) 
((|constructor| (NIL "This category exports the function for domains")) (|divOfPole| (($ $) "\\spad{divOfPole(d)} returns the negative part of \\spad{d.}")) (|divOfZero| (($ $) "\\spad{divOfZero(d)} returns the positive part of \\spad{d.}")) (|suppOfPole| (((|List| |#1|) $) "suppOfZero(d) returns the elements of the support of \\spad{d} that have a negative coefficient.")) (|suppOfZero| (((|List| |#1|) $) "\\spad{suppOfZero(d)} returns the elements of the support of \\spad{d} that have a positive coefficient.")) (|supp| (((|List| |#1|) $) "\\spad{supp(d)} returns the support of the divisor \\spad{d.}")) (|effective?| (((|Boolean|) $) "\\spad{effective?(d)} returns \\spad{true} if \\spad{d} \\spad{>=} 0.")) (|concat| (($ $ $) "\\spad{concat(a,b)} concats the divisor a and \\spad{b} without collecting the duplicative points.")) (|collect| (($ $) "\\spad{collect collects} the duplicative points in the divisor.")) (|split| (((|List| $) $) "\\spad{split(d)} splits the divisor \\spad{d.} For example, split( 2 \\spad{p1} + 3p2 ) returns the list [ 2 \\spad{p1,} 3 \\spad{p2} \\spad{].}")) (|degree| (((|Integer|) $) "\\spad{degree(d)} returns the degree of the divisor \\spad{d}"))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|Divisor| S) 
((|constructor| (NIL "The following is part of the PAFF package"))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| (|Integer|) (QUOTE (|OrderedAbelianMonoid|)))) 
(|DivisionRing&| S) 
((|constructor| (NIL "A division ring (sometimes called a skew field), \\spadignore{i.e.} a not necessarily commutative ring where all non-zero elements have multiplicative inverses.")) (|inv| (($ $) "\\spad{inv \\spad{x}} returns the multiplicative inverse of \\spad{x.} Error: if \\spad{x} is 0.")) (^ (($ $ (|Integer|)) "\\spad{x^n} returns \\spad{x} raised to the integer power \\spad{n.}")) (** (($ $ (|Integer|)) "\\spad{x**n} returns \\spad{x} raised to the integer power \\spad{n.}"))) 
NIL 
NIL 
(|DivisionRing|) 
((|constructor| (NIL "A division ring (sometimes called a skew field), \\spadignore{i.e.} a not necessarily commutative ring where all non-zero elements have multiplicative inverses.")) (|inv| (($ $) "\\spad{inv \\spad{x}} returns the multiplicative inverse of \\spad{x.} Error: if \\spad{x} is 0.")) (^ (($ $ (|Integer|)) "\\spad{x^n} returns \\spad{x} raised to the integer power \\spad{n.}")) (** (($ $ (|Integer|)) "\\spad{x**n} returns \\spad{x} raised to the integer power \\spad{n.}"))) 
((|noZeroDivisors| . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|DoublyLinkedAggregate| S) 
((|constructor| (NIL "A doubly-linked aggregate serves as a model for a doubly-linked list, that is, a list which can has links to both next and previous nodes and thus can be efficiently traversed in both directions.")) (|setnext!| (($ $ $) "\\spad{setnext!(u,v)} destructively sets the next node of doubly-linked aggregate \\spad{u} to \\spad{v,} returning \\spad{v.}")) (|setprevious!| (($ $ $) "\\spad{setprevious!(u,v)} destructively sets the previous node of doubly-linked aggregate \\spad{u} to \\spad{v,} returning \\spad{v.}")) (|concat!| (($ $ $) "\\spad{concat!(u,v)} destructively concatenates doubly-linked aggregate \\spad{v} to the end of doubly-linked aggregate u.")) (|next| (($ $) "\\spad{next(l)} returns the doubly-linked aggregate beginning with its next element. Error: if \\spad{l} has no next element. Note that \\axiom{next(l) = rest(l)} and \\axiom{previous(next(l)) = \\spad{l}.}")) (|previous| (($ $) "\\spad{previous(l)} returns the doubly-link list beginning with its previous element. Error: if \\spad{l} has no previous element. Note that \\axiom{next(previous(l)) = \\spad{l}.}")) (|tail| (($ $) "\\spad{tail(l)} returns the doubly-linked aggregate \\spad{l} starting at its second element. Error: if \\spad{l} is empty.")) (|head| (($ $) "\\spad{head(l)} returns the first element of a doubly-linked aggregate \\spad{l.} Error: if \\spad{l} is empty.")) (|last| ((|#1| $) "\\spad{last(l)} returns the last element of a doubly-linked aggregate \\spad{l.} Error: if \\spad{l} is empty."))) 
((|nil| . T)) 
NIL 
(|DataList| S) 
((|constructor| (NIL "This domain provides some nice functions on lists")) (|elt| (((|NonNegativeInteger|) $ "count") "\\axiom{l.\"count\"} returns the number of elements in \\axiom{l}.") (($ $ "sort") "\\axiom{l.sort} returns \\axiom{l} with elements sorted. Note: \\axiom{l.sort = sort(l)}") (($ $ "unique") "\\axiom{l.unique} returns \\axiom{l} with duplicates removed. Note: \\axiom{l.unique = removeDuplicates(l)}.")) (|datalist| (($ (|List| |#1|)) "\\spad{datalist(l)} creates a datalist from \\spad{l}")) (|coerce| (((|List| |#1|) $) "\\spad{coerce(x)} returns the list of elements in \\spad{x}") (($ (|List| |#1|)) "\\spad{coerce(l)} creates a datalist from \\spad{l}"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|DiscreteLogarithmPackage| M) 
((|constructor| (NIL "DiscreteLogarithmPackage implements help functions for discrete logarithms in monoids using small cyclic groups.")) (|shanksDiscLogAlgorithm| (((|Union| (|NonNegativeInteger|) "failed") |#1| |#1| (|NonNegativeInteger|)) "\\spad{shanksDiscLogAlgorithm(b,a,p)} computes \\spad{s} with \\spad{b**s = a} for assuming that \\spad{a} and \\spad{b} are elements in a 'small' cyclic group of order \\spad{p} by Shank's algorithm. Note that this is a subroutine of the function \\spadfun{discreteLog}.")) (** ((|#1| |#1| (|Integer|)) "\\spad{x \\spad{**} \\spad{n}} returns \\spad{x} raised to the integer power \\spad{n}"))) 
NIL 
NIL 
(|DistributedMultivariatePolynomial| |vl| R) 
((|constructor| (NIL "This type supports distributed multivariate polynomials whose variables are from a user specified list of symbols. The coefficient ring may be non commutative, but the variables are assumed to commute. The term ordering is lexicographic specified by the variable list parameter with the most significant variable first in the list.")) (|reorder| (($ $ (|List| (|Integer|))) "\\spad{reorder(p, perm)} applies the permutation perm to the variables in a polynomial and returns the new correctly ordered polynomial"))) 
(((|commutative| "*") |has| |#2| (|CommutativeRing|)) (|noZeroDivisors| |has| |#2| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#2| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#2| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Field|))) (OR (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasAttribute| |#2| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))))) 
(|DirectProductMatrixModule| |n| R M S) 
((|constructor| (NIL "This constructor provides a direct product type with a left matrix-module view."))) 
((|unitsKnown| OR (|and| (|has| |#4| (|Ring|)) (|has| |#4| (|DifferentialRing|))) (|and| (|has| |#4| (|Ring|)) (|has| |#4| (|PartialDifferentialRing| (|Symbol|)))) (|has| |#4| (ATTRIBUTE |unitsKnown|)) (|and| (|has| |#4| (|Ring|)) (|has| |#4| (|LinearlyExplicitRingOver| (|Integer|))))) (|rightUnitary| |has| |#4| (|Ring|)) (|leftUnitary| |has| |#4| (|Ring|)) ((|commutative| "*") |has| |#4| (|CommutativeRing|)) (|finiteAggregate| . T)) 
((|HasCategory| |#4| (QUOTE (|Field|))) (|HasCategory| |#4| (QUOTE (|Ring|))) (|HasCategory| |#4| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#4| (QUOTE (|OrderedRing|))) (OR (|HasCategory| |#4| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#4| (QUOTE (|OrderedRing|)))) (|HasCategory| |#4| (QUOTE (|Monoid|))) (|HasCategory| |#4| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#4| (QUOTE (|CommutativeRing|))) (|HasCategory| |#4| (QUOTE (|Field|))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (OR (|HasCategory| |#4| (QUOTE (|CommutativeRing|))) (|HasCategory| |#4| (QUOTE (|Field|)))) (OR (|HasCategory| |#4| (QUOTE (|CommutativeRing|))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (|HasCategory| |#4| (QUOTE (|Finite|))) (|HasCategory| |#4| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#4| (QUOTE (|DifferentialRing|))) (OR (|HasCategory| |#4| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#4| (QUOTE (|CommutativeRing|))) (|HasCategory| |#4| (QUOTE (|DifferentialRing|))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (|HasCategory| |#4| (QUOTE (|SetCategory|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#4| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (AND (|HasCategory| |#4| (QUOTE (|DifferentialRing|))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (OR (AND (|HasCategory| |#4| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (AND (|HasCategory| |#4| (QUOTE (|DifferentialRing|))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (|HasCategory| |#4| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#4| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#4| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|Field|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|Finite|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|SetCategory|))))) (OR (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|SetCategory|)))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#4| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#4| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#4| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#4| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#4| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#4| (QUOTE (|Field|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#4| (QUOTE (|Finite|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#4| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#4| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#4| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#4| (QUOTE (|SetCategory|))))) (OR (|HasAttribute| |#4| (QUOTE |unitsKnown|)) (AND (|HasCategory| |#4| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (AND (|HasCategory| |#4| (QUOTE (|DifferentialRing|))) (|HasCategory| |#4| (QUOTE (|Ring|))))) (|HasCategory| |#4| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#4| (QUOTE (|AbelianSemiGroup|))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|))))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|Field|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|Finite|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|Ring|)))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|SetCategory|)))))) 
(|DirectProductModule| |n| R S) 
((|constructor| (NIL "This constructor provides a direct product of R-modules with an R-module view."))) 
((|unitsKnown| OR (|and| (|has| |#3| (|Ring|)) (|has| |#3| (|DifferentialRing|))) (|and| (|has| |#3| (|Ring|)) (|has| |#3| (|PartialDifferentialRing| (|Symbol|)))) (|has| |#3| (ATTRIBUTE |unitsKnown|)) (|and| (|has| |#3| (|Ring|)) (|has| |#3| (|LinearlyExplicitRingOver| (|Integer|))))) (|rightUnitary| |has| |#3| (|Ring|)) (|leftUnitary| |has| |#3| (|Ring|)) ((|commutative| "*") |has| |#3| (|CommutativeRing|)) (|finiteAggregate| . T)) 
((|HasCategory| |#3| (QUOTE (|Field|))) (|HasCategory| |#3| (QUOTE (|Ring|))) (|HasCategory| |#3| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#3| (QUOTE (|OrderedRing|))) (OR (|HasCategory| |#3| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#3| (QUOTE (|OrderedRing|)))) (|HasCategory| |#3| (QUOTE (|Monoid|))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|Field|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (OR (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|Field|)))) (OR (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (|HasCategory| |#3| (QUOTE (|Finite|))) (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|))) (OR (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (|HasCategory| |#3| (QUOTE (|SetCategory|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (QUOTE (|DifferentialRing|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (OR (AND (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (QUOTE (|DifferentialRing|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (|HasCategory| |#3| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|Field|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|Finite|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|SetCategory|))))) (OR (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|Field|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|Finite|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|SetCategory|))))) (OR (|HasAttribute| |#3| (QUOTE |unitsKnown|)) (AND (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (QUOTE (|DifferentialRing|))) (|HasCategory| |#3| (QUOTE (|Ring|))))) (|HasCategory| |#3| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#3| (QUOTE (|AbelianSemiGroup|))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|))))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|Field|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|Finite|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))))) 
(|DifferentialPolynomialCategory&| A R S V E) 
((|constructor| (NIL "\\spadtype{DifferentialPolynomialCategory} is a category constructor specifying basic functions in an ordinary differential polynomial ring with a given ordered set of differential indeterminates. In addition, it implements defaults for the basic functions. The functions \\spadfun{order} and \\spadfun{weight} are extended from the set of derivatives of differential indeterminates to the set of differential polynomials. Other operations provided on differential polynomials are \\spadfun{leader}, \\spadfun{initial}, \\spadfun{separant}, \\spadfun{differentialVariables}, and \\spadfun{isobaric?}. Furthermore, if the ground ring is a differential ring, then evaluation (substitution of differential indeterminates by elements of the ground ring or by differential polynomials) is provided by \\spadfun{eval}. A convenient way of referencing derivatives is provided by the functions \\spadfun{makeVariable}. \\blankline To construct a domain using this constructor, one needs to provide a ground ring \\spad{R,} an ordered set \\spad{S} of differential indeterminates, a ranking \\spad{V} on the set of derivatives of the differential indeterminates, and a set \\spad{E} of exponents in bijection with the set of differential monomials in the given differential indeterminates.")) (|separant| (($ $) "\\spad{separant(p)} returns the partial derivative of the differential polynomial \\spad{p} with respect to its leader.")) (|initial| (($ $) "\\spad{initial(p)} returns the leading coefficient when the differential polynomial \\spad{p} is written as a univariate polynomial in its leader.")) (|leader| ((|#4| $) "\\spad{leader(p)} returns the derivative of the highest rank appearing in the differential polynomial \\spad{p} Note that an error occurs if \\spad{p} is in the ground ring.")) (|isobaric?| (((|Boolean|) $) "\\spad{isobaric?(p)} returns \\spad{true} if every differential monomial appearing in the differential polynomial \\spad{p} has same weight, and returns \\spad{false} otherwise.")) (|weight| (((|NonNegativeInteger|) $ |#3|) "\\spad{weight(p, \\spad{s)}} returns the maximum weight of all differential monomials appearing in the differential polynomial \\spad{p} when \\spad{p} is viewed as a differential polynomial in the differential indeterminate \\spad{s} alone.") (((|NonNegativeInteger|) $) "\\spad{weight(p)} returns the maximum weight of all differential monomials appearing in the differential polynomial \\spad{p.}")) (|weights| (((|List| (|NonNegativeInteger|)) $ |#3|) "\\spad{weights(p, \\spad{s)}} returns a list of weights of differential monomials appearing in the differential polynomial \\spad{p} when \\spad{p} is viewed as a differential polynomial in the differential indeterminate \\spad{s} alone.") (((|List| (|NonNegativeInteger|)) $) "\\spad{weights(p)} returns a list of weights of differential monomials appearing in differential polynomial \\spad{p.}")) (|degree| (((|NonNegativeInteger|) $ |#3|) "\\spad{degree(p, \\spad{s)}} returns the maximum degree of the differential polynomial \\spad{p} viewed as a differential polynomial in the differential indeterminate \\spad{s} alone.")) (|order| (((|NonNegativeInteger|) $) "\\spad{order(p)} returns the order of the differential polynomial \\spad{p,} which is the maximum number of differentiations of a differential indeterminate, among all those appearing in \\spad{p.}") (((|NonNegativeInteger|) $ |#3|) "\\spad{order(p,s)} returns the order of the differential polynomial \\spad{p} in differential indeterminate \\spad{s.}")) (|differentialVariables| (((|List| |#3|) $) "\\spad{differentialVariables(p)} returns a list of differential indeterminates occurring in a differential polynomial \\spad{p.}")) (|makeVariable| (((|Mapping| $ (|NonNegativeInteger|)) $) "\\spad{makeVariable(p)} views \\spad{p} as an element of a differential ring, in such a way that the \\spad{n}-th derivative of \\spad{p} may be simply referenced as \\spad{z.n} where \\spad{z} \\spad{:=} makeVariable(p). Note that In the interpreter, \\spad{z} is given as an internal map, which may be ignored.") (((|Mapping| $ (|NonNegativeInteger|)) |#3|) "\\spad{makeVariable(s)} views \\spad{s} as a differential indeterminate, in such a way that the \\spad{n}-th derivative of \\spad{s} may be simply referenced as \\spad{z.n} where \\spad{z} :=makeVariable(s). Note that In the interpreter, \\spad{z} is given as an internal map, which may be ignored."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) 
(|DifferentialPolynomialCategory| R S V E) 
((|constructor| (NIL "\\spadtype{DifferentialPolynomialCategory} is a category constructor specifying basic functions in an ordinary differential polynomial ring with a given ordered set of differential indeterminates. In addition, it implements defaults for the basic functions. The functions \\spadfun{order} and \\spadfun{weight} are extended from the set of derivatives of differential indeterminates to the set of differential polynomials. Other operations provided on differential polynomials are \\spadfun{leader}, \\spadfun{initial}, \\spadfun{separant}, \\spadfun{differentialVariables}, and \\spadfun{isobaric?}. Furthermore, if the ground ring is a differential ring, then evaluation (substitution of differential indeterminates by elements of the ground ring or by differential polynomials) is provided by \\spadfun{eval}. A convenient way of referencing derivatives is provided by the functions \\spadfun{makeVariable}. \\blankline To construct a domain using this constructor, one needs to provide a ground ring \\spad{R,} an ordered set \\spad{S} of differential indeterminates, a ranking \\spad{V} on the set of derivatives of the differential indeterminates, and a set \\spad{E} of exponents in bijection with the set of differential monomials in the given differential indeterminates.")) (|separant| (($ $) "\\spad{separant(p)} returns the partial derivative of the differential polynomial \\spad{p} with respect to its leader.")) (|initial| (($ $) "\\spad{initial(p)} returns the leading coefficient when the differential polynomial \\spad{p} is written as a univariate polynomial in its leader.")) (|leader| ((|#3| $) "\\spad{leader(p)} returns the derivative of the highest rank appearing in the differential polynomial \\spad{p} Note that an error occurs if \\spad{p} is in the ground ring.")) (|isobaric?| (((|Boolean|) $) "\\spad{isobaric?(p)} returns \\spad{true} if every differential monomial appearing in the differential polynomial \\spad{p} has same weight, and returns \\spad{false} otherwise.")) (|weight| (((|NonNegativeInteger|) $ |#2|) "\\spad{weight(p, \\spad{s)}} returns the maximum weight of all differential monomials appearing in the differential polynomial \\spad{p} when \\spad{p} is viewed as a differential polynomial in the differential indeterminate \\spad{s} alone.") (((|NonNegativeInteger|) $) "\\spad{weight(p)} returns the maximum weight of all differential monomials appearing in the differential polynomial \\spad{p.}")) (|weights| (((|List| (|NonNegativeInteger|)) $ |#2|) "\\spad{weights(p, \\spad{s)}} returns a list of weights of differential monomials appearing in the differential polynomial \\spad{p} when \\spad{p} is viewed as a differential polynomial in the differential indeterminate \\spad{s} alone.") (((|List| (|NonNegativeInteger|)) $) "\\spad{weights(p)} returns a list of weights of differential monomials appearing in differential polynomial \\spad{p.}")) (|degree| (((|NonNegativeInteger|) $ |#2|) "\\spad{degree(p, \\spad{s)}} returns the maximum degree of the differential polynomial \\spad{p} viewed as a differential polynomial in the differential indeterminate \\spad{s} alone.")) (|order| (((|NonNegativeInteger|) $) "\\spad{order(p)} returns the order of the differential polynomial \\spad{p,} which is the maximum number of differentiations of a differential indeterminate, among all those appearing in \\spad{p.}") (((|NonNegativeInteger|) $ |#2|) "\\spad{order(p,s)} returns the order of the differential polynomial \\spad{p} in differential indeterminate \\spad{s.}")) (|differentialVariables| (((|List| |#2|) $) "\\spad{differentialVariables(p)} returns a list of differential indeterminates occurring in a differential polynomial \\spad{p.}")) (|makeVariable| (((|Mapping| $ (|NonNegativeInteger|)) $) "\\spad{makeVariable(p)} views \\spad{p} as an element of a differential ring, in such a way that the \\spad{n}-th derivative of \\spad{p} may be simply referenced as \\spad{z.n} where \\spad{z} \\spad{:=} makeVariable(p). Note that In the interpreter, \\spad{z} is given as an internal map, which may be ignored.") (((|Mapping| $ (|NonNegativeInteger|)) |#2|) "\\spad{makeVariable(s)} views \\spad{s} as a differential indeterminate, in such a way that the \\spad{n}-th derivative of \\spad{s} may be simply referenced as \\spad{z.n} where \\spad{z} :=makeVariable(s). Note that In the interpreter, \\spad{z} is given as an internal map, which may be ignored."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|DequeueAggregate| S) 
((|constructor| (NIL "A dequeue is a doubly ended stack, that is, a bag where first items inserted are the first items extracted, at either the front or the back end of the data structure.")) (|reverse!| (($ $) "\\spad{reverse!(d)} destructively replaces \\spad{d} by its reverse dequeue, \\spadignore{i.e.} the top (front) element is now the bottom (back) element, and so on.")) (|extractBottom!| ((|#1| $) "\\spad{extractBottom!(d)} destructively extracts the bottom (back) element from the dequeue \\spad{d.} Error: if \\spad{d} is empty.")) (|extractTop!| ((|#1| $) "\\spad{extractTop!(d)} destructively extracts the top (front) element from the dequeue \\spad{d.} Error: if \\spad{d} is empty.")) (|insertBottom!| ((|#1| |#1| $) "\\spad{insertBottom!(x,d)} destructively inserts \\spad{x} into the dequeue \\spad{d} at the bottom (back) of the dequeue.")) (|insertTop!| ((|#1| |#1| $) "\\spad{insertTop!(x,d)} destructively inserts \\spad{x} into the dequeue \\spad{d,} that is, at the top (front) of the dequeue. The element previously at the top of the dequeue becomes the second in the dequeue, and so on.")) (|bottom!| ((|#1| $) "\\spad{bottom!(d)} returns the element at the bottom (back) of the dequeue.")) (|top!| ((|#1| $) "\\spad{top!(d)} returns the element at the top (front) of the dequeue.")) (|height| (((|NonNegativeInteger|) $) "\\spad{height(d)} returns the number of elements in dequeue \\spad{d.} Note that \\axiom{height(d) = \\# \\spad{d}.}")) (|dequeue| (($ (|List| |#1|)) "\\spad{dequeue([x,y,...,z])} creates a dequeue with first (top or front) element \\spad{x,} second element y,...,and last (bottom or back) element \\spad{z.}") (($) "\\spad{dequeue()}$D creates an empty dequeue of type \\spad{D.}"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|TopLevelDrawFunctionsForCompiledFunctions|) 
((|constructor| (NIL "TopLevelDrawFunctionsForCompiledFunctions provides top level functions for drawing graphics of expressions.")) (|recolor| (((|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))) "\\spad{recolor()}, uninteresting to top level user; exported in order to compile package.")) (|makeObject| (((|ThreeSpace| (|DoubleFloat|)) (|ParametricSurface| (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))) (|Segment| (|Float|)) (|Segment| (|Float|))) "\\spad{makeObject(surface(f,g,h),a..b,c..d,l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric surface \\spad{x = f(u,v)}, \\spad{y = g(u,v)}, \\spad{z = h(u,v)} as \\spad{u} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{v} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}.") (((|ThreeSpace| (|DoubleFloat|)) (|ParametricSurface| (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))) (|Segment| (|Float|)) (|Segment| (|Float|)) (|List| (|DrawOption|))) "\\spad{makeObject(surface(f,g,h),a..b,c..d,l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric surface \\spad{x = f(u,v)}, \\spad{y = g(u,v)}, \\spad{z = h(u,v)} as \\spad{u} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{v} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeSpace| (|DoubleFloat|)) (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|Float|)) (|Segment| (|Float|))) "\\spad{makeObject(f,a..b,c..d,l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric surface \\spad{f(u,v)} as \\spad{u} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{v} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}.") (((|ThreeSpace| (|DoubleFloat|)) (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|Float|)) (|Segment| (|Float|)) (|List| (|DrawOption|))) "\\spad{makeObject(f,a..b,c..d,l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric surface \\spad{f(u,v)} as \\spad{u} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{v} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}; The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeSpace| (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|Float|)) (|Segment| (|Float|))) "\\spad{makeObject(f,a..b,c..d)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of \\spad{z = f(x,y)} as \\spad{x} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{y} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}.") (((|ThreeSpace| (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|Float|)) (|Segment| (|Float|)) (|List| (|DrawOption|))) "\\spad{makeObject(f,a..b,c..d,l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of \\spad{z = f(x,y)} as \\spad{x} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{y} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}, and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeSpace| (|DoubleFloat|)) (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|)) (|Segment| (|Float|))) "\\spad{makeObject(sp,curve(f,g,h),a..b)} returns the space \\spad{sp} of the domain \\spadtype{ThreeSpace} with the addition of the graph of the parametric curve \\spad{x = f(t), \\spad{y} = g(t), \\spad{z} = h(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}.") (((|ThreeSpace| (|DoubleFloat|)) (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|)) (|Segment| (|Float|)) (|List| (|DrawOption|))) "\\spad{makeObject(curve(f,g,h),a..b,l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric curve \\spad{x = f(t), \\spad{y} = g(t), \\spad{z} = h(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeSpace| (|DoubleFloat|)) (|ParametricSpaceCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|))) (|Segment| (|Float|))) "\\spad{makeObject(sp,curve(f,g,h),a..b)} returns the space \\spad{sp} of the domain \\spadtype{ThreeSpace} with the addition of the graph of the parametric curve \\spad{x = f(t), \\spad{y} = g(t), \\spad{z} = h(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}.") (((|ThreeSpace| (|DoubleFloat|)) (|ParametricSpaceCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|))) (|Segment| (|Float|)) (|List| (|DrawOption|))) "\\spad{makeObject(curve(f,g,h),a..b,l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric curve \\spad{x = f(t), \\spad{y} = g(t), \\spad{z} = h(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}; The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")) (|draw| (((|ThreeDimensionalViewport|) (|ParametricSurface| (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))) (|Segment| (|Float|)) (|Segment| (|Float|))) "\\spad{draw(surface(f,g,h),a..b,c..d)} draws the graph of the parametric surface \\spad{x = f(u,v)}, \\spad{y = g(u,v)}, \\spad{z = h(u,v)} as \\spad{u} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{v} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}.") (((|ThreeDimensionalViewport|) (|ParametricSurface| (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))) (|Segment| (|Float|)) (|Segment| (|Float|)) (|List| (|DrawOption|))) "\\spad{draw(surface(f,g,h),a..b,c..d)} draws the graph of the parametric surface \\spad{x = f(u,v)}, \\spad{y = g(u,v)}, \\spad{z = h(u,v)} as \\spad{u} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{v} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}; The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeDimensionalViewport|) (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|Float|)) (|Segment| (|Float|))) "\\spad{draw(f,a..b,c..d)} draws the graph of the parametric surface \\spad{f(u,v)} as \\spad{u} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{v} ranges from \\spad{min(c,d)} to \\spad{max(c,d)} The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeDimensionalViewport|) (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|Float|)) (|Segment| (|Float|)) (|List| (|DrawOption|))) "\\spad{draw(f,a..b,c..d)} draws the graph of the parametric surface \\spad{f(u,v)} as \\spad{u} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{v} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeDimensionalViewport|) (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|Float|)) (|Segment| (|Float|))) "\\spad{draw(f,a..b,c..d)} draws the graph of \\spad{z = f(x,y)} as \\spad{x} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{y} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}.") (((|ThreeDimensionalViewport|) (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|Float|)) (|Segment| (|Float|)) (|List| (|DrawOption|))) "\\spad{draw(f,a..b,c..d,l)} draws the graph of \\spad{z = f(x,y)} as \\spad{x} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{y} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}. and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeDimensionalViewport|) (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|)) (|Segment| (|Float|))) "\\spad{draw(f,a..b,l)} draws the graph of the parametric curve \\spad{f} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}.") (((|ThreeDimensionalViewport|) (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|)) (|Segment| (|Float|)) (|List| (|DrawOption|))) "\\spad{draw(f,a..b,l)} draws the graph of the parametric curve \\spad{f} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeDimensionalViewport|) (|ParametricSpaceCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|))) (|Segment| (|Float|))) "\\spad{draw(curve(f,g,h),a..b,l)} draws the graph of the parametric curve \\spad{x = f(t), \\spad{y} = g(t), \\spad{z} = h(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}.") (((|ThreeDimensionalViewport|) (|ParametricSpaceCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|))) (|Segment| (|Float|)) (|List| (|DrawOption|))) "\\spad{draw(curve(f,g,h),a..b,l)} draws the graph of the parametric curve \\spad{x = f(t), \\spad{y} = g(t), \\spad{z} = h(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|TwoDimensionalViewport|) (|ParametricPlaneCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|))) (|Segment| (|Float|))) "\\spad{draw(curve(f,g),a..b)} draws the graph of the parametric curve \\spad{x = f(t), \\spad{y} = g(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}.") (((|TwoDimensionalViewport|) (|ParametricPlaneCurve| (|Mapping| (|DoubleFloat|) (|DoubleFloat|))) (|Segment| (|Float|)) (|List| (|DrawOption|))) "\\spad{draw(curve(f,g),a..b,l)} draws the graph of the parametric curve \\spad{x = f(t), \\spad{y} = g(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|TwoDimensionalViewport|) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|Float|))) "\\spad{draw(f,a..b)} draws the graph of \\spad{y = f(x)} as \\spad{x} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}.") (((|TwoDimensionalViewport|) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|Float|)) (|List| (|DrawOption|))) "\\spad{draw(f,a..b,l)} draws the graph of \\spad{y = f(x)} as \\spad{x} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied."))) 
NIL 
NIL 
(|TopLevelDrawFunctionsForAlgebraicCurves| R |Ex|) 
((|constructor| (NIL "TopLevelDrawFunctionsForAlgebraicCurves provides top level functions for drawing non-singular algebraic curves.")) (|draw| (((|TwoDimensionalViewport|) (|Equation| |#2|) (|Symbol|) (|Symbol|) (|List| (|DrawOption|))) "\\spad{draw(f(x,y) = g(x,y),x,y,l)} draws the graph of a polynomial equation. The list \\spad{l} of draw options must specify a region in the plane in which the curve is to sketched."))) 
NIL 
NIL 
(|DrawComplex|) 
((|constructor| (NIL "\\axiomType{DrawComplex} provides some facilities for drawing complex functions.")) (|setClipValue| (((|DoubleFloat|) (|DoubleFloat|)) "\\spad{setClipValue(x)} sets to \\spad{x} the maximum value to plot when drawing complex functions. Returns \\spad{x.}")) (|setImagSteps| (((|Integer|) (|Integer|)) "\\spad{setImagSteps(i)} sets to \\spad{i} the number of steps to use in the imaginary direction when drawing complex functions. Returns i.")) (|setRealSteps| (((|Integer|) (|Integer|)) "\\spad{setRealSteps(i)} sets to \\spad{i} the number of steps to use in the real direction when drawing complex functions. Returns i.")) (|drawComplexVectorField| (((|ThreeDimensionalViewport|) (|Mapping| (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{drawComplexVectorField(f,rRange,iRange)} draws a complex vector field using arrows on the \\spad{x--y} plane. These vector fields should be viewed from the top by pressing the \"XY\" translate button on the 3-d viewport control panel. Sample call: \\indented{3}{\\spad{f \\spad{z} \\spad{==} sin \\spad{z}}} \\indented{3}{\\spad{drawComplexVectorField(f, -2..2, -2..2)}} Parameter descriptions: \\indented{2}{f : the function to draw} \\indented{2}{rRange : the range of the real values} \\indented{2}{iRange : the range of the imaginary values} Call the functions \\axiomFunFrom{setRealSteps}{DrawComplex} and \\axiomFunFrom{setImagSteps}{DrawComplex} to change the number of steps used in each direction.")) (|drawComplex| (((|ThreeDimensionalViewport|) (|Mapping| (|Complex| (|DoubleFloat|)) (|Complex| (|DoubleFloat|))) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Boolean|)) "\\spad{drawComplex(f,rRange,iRange,arrows?)} draws a complex function as a height field. It uses the complex norm as the height and the complex argument as the color. It will optionally draw arrows on the surface indicating the direction of the complex value. Sample call: \\indented{2}{\\spad{f \\spad{z} \\spad{==} exp(1/z)}} \\indented{2}{\\spad{drawComplex(f, 0.3..3, 0..2*%pi, false)}} Parameter descriptions: \\indented{2}{f:\\space{2}the function to draw} \\indented{2}{rRange : the range of the real values} \\indented{2}{iRange : the range of imaginary values} \\indented{2}{arrows? : a flag indicating whether to draw the phase arrows for \\spad{f}} Call the functions \\axiomFunFrom{setRealSteps}{DrawComplex} and \\axiomFunFrom{setImagSteps}{DrawComplex} to change the number of steps used in each direction."))) 
NIL 
NIL 
(|DrawNumericHack| R) 
((|constructor| (NIL "Hack for the draw interface. DrawNumericHack provides a \"coercion\" from something of the form \\spad{x = a..b} where \\spad{a} and \\spad{b} are formal expressions to a binding of the form \\spad{x = c..d} where \\spad{c} and \\spad{d} are the numerical values of \\spad{a} and \\spad{b.} This \"coercion\" fails if \\spad{a} and \\spad{b} contains symbolic variables, but is meant for expressions involving \\%pi. Note that this package is meant for internal use only.")) (|coerce| (((|SegmentBinding| (|Float|)) (|SegmentBinding| (|Expression| |#1|))) "\\spad{coerce(x = a..b)} returns \\spad{x = c..d} where \\spad{c} and \\spad{d} are the numerical values of \\spad{a} and \\spad{b.}"))) 
NIL 
NIL 
(|TopLevelDrawFunctions| |Ex|) 
((|constructor| (NIL "TopLevelDrawFunctions provides top level functions for drawing graphics of expressions.")) (|makeObject| (((|ThreeSpace| (|DoubleFloat|)) (|ParametricSurface| |#1|) (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|))) "\\spad{makeObject(surface(f(u,v),g(u,v),h(u,v)),u = a..b,v = c..d)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric surface \\spad{x = f(u,v)}, \\spad{y = g(u,v)}, \\spad{z = h(u,v)} as \\spad{u} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{v} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}; \\spad{h(t)} is the default title.") (((|ThreeSpace| (|DoubleFloat|)) (|ParametricSurface| |#1|) (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|)) (|List| (|DrawOption|))) "\\spad{makeObject(surface(f(u,v),g(u,v),h(u,v)),u = a..b,v = c..d,l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric surface \\spad{x = f(u,v)}, \\spad{y = g(u,v)}, \\spad{z = h(u,v)} as \\spad{u} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{v} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}; \\spad{h(t)} is the default title, and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeSpace| (|DoubleFloat|)) |#1| (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|))) "\\spad{makeObject(f(x,y),x = a..b,y = c..d)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of \\spad{z = f(x,y)} as \\spad{x} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{y} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}; \\spad{f(x,y)} appears as the default title.") (((|ThreeSpace| (|DoubleFloat|)) |#1| (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|)) (|List| (|DrawOption|))) "\\spad{makeObject(f(x,y),x = a..b,y = c..d,l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of \\spad{z = f(x,y)} as \\spad{x} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{y} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}; \\spad{f(x,y)} is the default title, and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeSpace| (|DoubleFloat|)) (|ParametricSpaceCurve| |#1|) (|SegmentBinding| (|Float|))) "\\spad{makeObject(curve(f(t),g(t),h(t)),t = a..b)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric curve \\spad{x = f(t)}, \\spad{y = g(t)}, \\spad{z = h(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}; \\spad{h(t)} is the default title.") (((|ThreeSpace| (|DoubleFloat|)) (|ParametricSpaceCurve| |#1|) (|SegmentBinding| (|Float|)) (|List| (|DrawOption|))) "\\spad{makeObject(curve(f(t),g(t),h(t)),t = a..b,l)} returns a space of the domain \\spadtype{ThreeSpace} which contains the graph of the parametric curve \\spad{x = f(t)}, \\spad{y = g(t)}, \\spad{z = h(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}; \\spad{h(t)} is the default title, and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.")) (|draw| (((|ThreeDimensionalViewport|) (|ParametricSurface| |#1|) (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|))) "\\spad{draw(surface(f(u,v),g(u,v),h(u,v)),u = a..b,v = c..d)} draws the graph of the parametric surface \\spad{x = f(u,v)}, \\spad{y = g(u,v)}, \\spad{z = h(u,v)} as \\spad{u} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{v} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}; \\spad{h(t)} is the default title.") (((|ThreeDimensionalViewport|) (|ParametricSurface| |#1|) (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|)) (|List| (|DrawOption|))) "\\spad{draw(surface(f(u,v),g(u,v),h(u,v)),u = a..b,v = c..d,l)} draws the graph of the parametric surface \\spad{x = f(u,v)}, \\spad{y = g(u,v)}, \\spad{z = h(u,v)} as \\spad{u} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{v} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}; \\spad{h(t)} is the default title, and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeDimensionalViewport|) |#1| (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|))) "\\spad{draw(f(x,y),x = a..b,y = c..d)} draws the graph of \\spad{z = f(x,y)} as \\spad{x} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{y} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}; \\spad{f(x,y)} appears in the title bar.") (((|ThreeDimensionalViewport|) |#1| (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|)) (|List| (|DrawOption|))) "\\spad{draw(f(x,y),x = a..b,y = c..d,l)} draws the graph of \\spad{z = f(x,y)} as \\spad{x} ranges from \\spad{min(a,b)} to \\spad{max(a,b)} and \\spad{y} ranges from \\spad{min(c,d)} to \\spad{max(c,d)}; \\spad{f(x,y)} is the default title, and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeDimensionalViewport|) (|ParametricSpaceCurve| |#1|) (|SegmentBinding| (|Float|))) "\\spad{draw(curve(f(t),g(t),h(t)),t = a..b)} draws the graph of the parametric curve \\spad{x = f(t)}, \\spad{y = g(t)}, \\spad{z = h(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}; \\spad{h(t)} is the default title.") (((|ThreeDimensionalViewport|) (|ParametricSpaceCurve| |#1|) (|SegmentBinding| (|Float|)) (|List| (|DrawOption|))) "\\spad{draw(curve(f(t),g(t),h(t)),t = a..b,l)} draws the graph of the parametric curve \\spad{x = f(t)}, \\spad{y = g(t)}, \\spad{z = h(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}; \\spad{h(t)} is the default title, and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|TwoDimensionalViewport|) (|ParametricPlaneCurve| |#1|) (|SegmentBinding| (|Float|))) "\\spad{draw(curve(f(t),g(t)),t = a..b)} draws the graph of the parametric curve \\spad{x = f(t), \\spad{y} = g(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}; \\spad{(f(t),g(t))} appears in the title bar.") (((|TwoDimensionalViewport|) (|ParametricPlaneCurve| |#1|) (|SegmentBinding| (|Float|)) (|List| (|DrawOption|))) "\\spad{draw(curve(f(t),g(t)),t = a..b,l)} draws the graph of the parametric curve \\spad{x = f(t), \\spad{y} = g(t)} as \\spad{t} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}; \\spad{(f(t),g(t))} is the default title, and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|TwoDimensionalViewport|) |#1| (|SegmentBinding| (|Float|))) "\\spad{draw(f(x),x = a..b)} draws the graph of \\spad{y = f(x)} as \\spad{x} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}; \\spad{f(x)} appears in the title bar.") (((|TwoDimensionalViewport|) |#1| (|SegmentBinding| (|Float|)) (|List| (|DrawOption|))) "\\spad{draw(f(x),x = a..b,l)} draws the graph of \\spad{y = f(x)} as \\spad{x} ranges from \\spad{min(a,b)} to \\spad{max(a,b)}; \\spad{f(x)} is the default title, and the options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied."))) 
NIL 
NIL 
(|TopLevelDrawFunctionsForPoints|) 
((|constructor| (NIL "TopLevelDrawFunctionsForPoints provides top level functions for drawing curves and surfaces described by sets of points.")) (|draw| (((|ThreeDimensionalViewport|) (|List| (|DoubleFloat|)) (|List| (|DoubleFloat|)) (|List| (|DoubleFloat|)) (|List| (|DrawOption|))) "\\spad{draw(lx,ly,lz,l)} draws the surface constructed by projecting the values in the \\axiom{lz} list onto the rectangular grid formed by the The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|ThreeDimensionalViewport|) (|List| (|DoubleFloat|)) (|List| (|DoubleFloat|)) (|List| (|DoubleFloat|))) "\\spad{draw(lx,ly,lz)} draws the surface constructed by projecting the values in the \\axiom{lz} list onto the rectangular grid formed by the \\axiom{lx \\spad{x} ly}.") (((|TwoDimensionalViewport|) (|List| (|Point| (|DoubleFloat|))) (|List| (|DrawOption|))) "\\spad{draw(lp,l)} plots the curve constructed from the list of points \\spad{lp.} The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|TwoDimensionalViewport|) (|List| (|Point| (|DoubleFloat|)))) "\\spad{draw(lp)} plots the curve constructed from the list of points \\spad{lp.}") (((|TwoDimensionalViewport|) (|List| (|DoubleFloat|)) (|List| (|DoubleFloat|)) (|List| (|DrawOption|))) "\\spad{draw(lx,ly,l)} plots the curve constructed of points (x,y) for \\spad{x} in \\spad{lx} for \\spad{y} in \\spad{ly}. The options contained in the list \\spad{l} of the domain \\spad{DrawOption} are applied.") (((|TwoDimensionalViewport|) (|List| (|DoubleFloat|)) (|List| (|DoubleFloat|))) "\\spad{draw(lx,ly)} plots the curve constructed of points (x,y) for \\spad{x} in \\spad{lx} for \\spad{y} in \\spad{ly}."))) 
NIL 
NIL 
(|DrawOptionFunctions0|) 
((|constructor| (NIL "This package has no description")) (|units| (((|List| (|Float|)) (|List| (|DrawOption|)) (|List| (|Float|))) "\\spad{units(l,u)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{unit}. If the option does not exist the value, \\spad{u} is returned.")) (|coord| (((|Mapping| (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|))) (|List| (|DrawOption|)) (|Mapping| (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|)))) "\\spad{coord(l,p)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{coord}. If the option does not exist the value, \\spad{p} is returned.")) (|tubeRadius| (((|Float|) (|List| (|DrawOption|)) (|Float|)) "\\spad{tubeRadius(l,n)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{tubeRadius}. If the option does not exist the value, \\spad{n} is returned.")) (|tubePoints| (((|PositiveInteger|) (|List| (|DrawOption|)) (|PositiveInteger|)) "\\spad{tubePoints(l,n)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{tubePoints}. If the option does not exist the value, \\spad{n} is returned.")) (|space| (((|ThreeSpace| (|DoubleFloat|)) (|List| (|DrawOption|))) "\\spad{space(l)} takes a list of draw options, \\spad{l,} and checks to see if it contains the option \\spad{space}. If the the option doesn't exist, then an empty space is returned.")) (|var2Steps| (((|PositiveInteger|) (|List| (|DrawOption|)) (|PositiveInteger|)) "\\spad{var2Steps(l,n)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{var2Steps}. If the option does not exist the value, \\spad{n} is returned.")) (|var1Steps| (((|PositiveInteger|) (|List| (|DrawOption|)) (|PositiveInteger|)) "\\spad{var1Steps(l,n)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{var1Steps}. If the option does not exist the value, \\spad{n} is returned.")) (|ranges| (((|List| (|Segment| (|Float|))) (|List| (|DrawOption|)) (|List| (|Segment| (|Float|)))) "\\spad{ranges(l,r)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{ranges}. If the option does not exist the value, \\spad{r} is returned.")) (|curveColorPalette| (((|Palette|) (|List| (|DrawOption|)) (|Palette|)) "\\spad{curveColorPalette(l,p)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{curveColorPalette}. If the option does not exist the value, \\spad{p} is returned.")) (|pointColorPalette| (((|Palette|) (|List| (|DrawOption|)) (|Palette|)) "\\spad{pointColorPalette(l,p)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{pointColorPalette}. If the option does not exist the value, \\spad{p} is returned.")) (|toScale| (((|Boolean|) (|List| (|DrawOption|)) (|Boolean|)) "\\spad{toScale(l,b)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{toScale}. If the option does not exist the value, \\spad{b} is returned.")) (|style| (((|String|) (|List| (|DrawOption|)) (|String|)) "\\spad{style(l,s)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{style}. If the option does not exist the value, \\spad{s} is returned.")) (|title| (((|String|) (|List| (|DrawOption|)) (|String|)) "\\spad{title(l,s)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{title}. If the option does not exist the value, \\spad{s} is returned.")) (|viewpoint| (((|Record| (|:| |theta| (|DoubleFloat|)) (|:| |phi| (|DoubleFloat|)) (|:| |scale| (|DoubleFloat|)) (|:| |scaleX| (|DoubleFloat|)) (|:| |scaleY| (|DoubleFloat|)) (|:| |scaleZ| (|DoubleFloat|)) (|:| |deltaX| (|DoubleFloat|)) (|:| |deltaY| (|DoubleFloat|))) (|List| (|DrawOption|)) (|Record| (|:| |theta| (|DoubleFloat|)) (|:| |phi| (|DoubleFloat|)) (|:| |scale| (|DoubleFloat|)) (|:| |scaleX| (|DoubleFloat|)) (|:| |scaleY| (|DoubleFloat|)) (|:| |scaleZ| (|DoubleFloat|)) (|:| |deltaX| (|DoubleFloat|)) (|:| |deltaY| (|DoubleFloat|)))) "\\spad{viewpoint(l,ls)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{viewpoint}. IF the option does not exist, the value \\spad{ls} is returned.")) (|clipBoolean| (((|Boolean|) (|List| (|DrawOption|)) (|Boolean|)) "\\spad{clipBoolean(l,b)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{clipBoolean}. If the option does not exist the value, \\spad{b} is returned.")) (|adaptive| (((|Boolean|) (|List| (|DrawOption|)) (|Boolean|)) "\\spad{adaptive(l,b)} takes the list of draw options, \\spad{l,} and checks the list to see if it contains the option \\spad{adaptive}. If the option does not exist the value, \\spad{b} is returned."))) 
NIL 
NIL 
(|DrawOptionFunctions1| S) 
((|constructor| (NIL "This package has no description")) (|option| (((|Union| |#1| "failed") (|List| (|DrawOption|)) (|Symbol|)) "\\spad{option(l,s)} determines whether the indicated drawing option, \\spad{s,} is contained in the list of drawing options, \\spad{l,} which is defined by the draw command."))) 
NIL 
NIL 
(|DrawOption|) 
((|constructor| (NIL "DrawOption allows the user to specify defaults for the creation and rendering of plots.")) (|option?| (((|Boolean|) (|List| $) (|Symbol|)) "\\spad{option?()} is not to be used at the top level; option? internally returns \\spad{true} for drawing options which are indicated in a draw command, or \\spad{false} for those which are not.")) (|option| (((|Union| (|Any|) "failed") (|List| $) (|Symbol|)) "\\spad{option()} is not to be used at the top level; option determines internally which drawing options are indicated in a draw command.")) (|unit| (($ (|List| (|Float|))) "\\spad{unit(lf)} will mark off the units according to the indicated list \\spad{lf.} This option is expressed in the form \\spad{unit \\spad{==} [f1,f2]}.")) (|coord| (($ (|Mapping| (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|)))) "\\spad{coord(p)} specifies a change of coordinates of point \\spad{p.} This option is expressed in the form \\spad{coord \\spad{==} \\spad{p}.}")) (|tubePoints| (($ (|PositiveInteger|)) "\\spad{tubePoints(n)} specifies the number of points, \\spad{n,} defining the circle which creates the tube around a 3D curve, the default is 6. This option is expressed in the form \\spad{tubePoints \\spad{==} \\spad{n}.}")) (|var2Steps| (($ (|PositiveInteger|)) "\\spad{var2Steps(n)} indicates the number of subdivisions, \\spad{n,} of the second range variable. This option is expressed in the form \\spad{var2Steps \\spad{==} \\spad{n}.}")) (|var1Steps| (($ (|PositiveInteger|)) "\\spad{var1Steps(n)} indicates the number of subdivisions, \\spad{n,} of the first range variable. This option is expressed in the form \\spad{var1Steps \\spad{==} \\spad{n}.}")) (|space| (($ (|ThreeSpace| (|DoubleFloat|))) "\\spad{space specifies} the space into which we will draw. If none is given then a new space is created.")) (|ranges| (($ (|List| (|Segment| (|Float|)))) "\\spad{ranges(l)} provides a list of user-specified ranges \\spad{l.} This option is expressed in the form \\spad{ranges \\spad{==} \\spad{l}.}")) (|range| (($ (|List| (|Segment| (|Fraction| (|Integer|))))) "\\spad{range([i])} provides a user-specified range i. This option is expressed in the form \\spad{range \\spad{==} [i]}.") (($ (|List| (|Segment| (|Float|)))) "\\spad{range([l])} provides a user-specified range \\spad{l.} This option is expressed in the form \\spad{range \\spad{==} [l]}.")) (|tubeRadius| (($ (|Float|)) "\\spad{tubeRadius(r)} specifies a radius, \\spad{r,} for a tube plot around a 3D curve; is expressed in the form \\spad{tubeRadius \\spad{==} 4}.")) (|colorFunction| (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))) "\\spad{colorFunction(f(x,y,z))} specifies the color for three dimensional plots as a function of \\spad{x,} \\spad{y,} and \\spad{z} coordinates. This option is expressed in the form \\spad{colorFunction \\spad{==} f(x,y,z)}.") (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))) "\\spad{colorFunction(f(u,v))} specifies the color for three dimensional plots as a function based upon the two parametric variables. This option is expressed in the form \\spad{colorFunction \\spad{==} f(u,v)}.") (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|))) "\\spad{colorFunction(f(z))} specifies the color based upon the z-component of three dimensional plots. This option is expressed in the form \\spad{colorFunction \\spad{==} f(z)}.")) (|curveColor| (($ (|Palette|)) "\\spad{curveColor(p)} specifies a color index for 2D graph curves from the spadcolors palette \\spad{p.} This option is expressed in the form \\spad{curveColor ==p}.") (($ (|Float|)) "\\spad{curveColor(v)} specifies a color, \\spad{v,} for 2D graph curves. This option is expressed in the form \\spad{curveColor \\spad{==} \\spad{v}.}")) (|pointColor| (($ (|Palette|)) "\\spad{pointColor(p)} specifies a color index for 2D graph points from the spadcolors palette \\spad{p.} This option is expressed in the form \\spad{pointColor \\spad{==} \\spad{p}.}") (($ (|Float|)) "\\spad{pointColor(v)} specifies a color, \\spad{v,} for 2D graph points. This option is expressed in the form \\spad{pointColor \\spad{==} \\spad{v}.}")) (|coordinates| (($ (|Mapping| (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|)))) "\\spad{coordinates(p)} specifies a change of coordinate systems of point \\spad{p.} This option is expressed in the form \\spad{coordinates \\spad{==} \\spad{p}.}")) (|toScale| (($ (|Boolean|)) "\\spad{toScale(b)} specifies whether or not a plot is to be drawn to scale; if \\spad{b} is \\spad{true} it is drawn to scale, if \\spad{b} is \\spad{false} it is not. This option is expressed in the form \\spad{toScale \\spad{==} \\spad{b}.}")) (|style| (($ (|String|)) "\\spad{style(s)} specifies the drawing style in which the graph will be plotted by the indicated string \\spad{s.} This option is expressed in the form \\spad{style \\spad{==} \\spad{s}.}")) (|title| (($ (|String|)) "\\spad{title(s)} specifies a title for a plot by the indicated string \\spad{s.} This option is expressed in the form \\spad{title \\spad{==} \\spad{s}.}")) (|viewpoint| (($ (|Record| (|:| |theta| (|DoubleFloat|)) (|:| |phi| (|DoubleFloat|)) (|:| |scale| (|DoubleFloat|)) (|:| |scaleX| (|DoubleFloat|)) (|:| |scaleY| (|DoubleFloat|)) (|:| |scaleZ| (|DoubleFloat|)) (|:| |deltaX| (|DoubleFloat|)) (|:| |deltaY| (|DoubleFloat|)))) "\\spad{viewpoint(vp)} creates a viewpoint data structure corresponding to the list of values. The values are interpreted as [theta, phi, scale, scaleX, scaleY, scaleZ, deltaX, deltaY]. This option is expressed in the form \\spad{viewpoint \\spad{==} ls}.")) (|clip| (($ (|List| (|Segment| (|Float|)))) "\\spad{clip([l])} provides ranges for user-defined clipping as specified in the list \\spad{l.} This option is expressed in the form \\spad{clip \\spad{==} [l]}.") (($ (|Boolean|)) "\\spad{clip(b)} turns 2D clipping on if \\spad{b} is true, or off if \\spad{b} is false. This option is expressed in the form \\spad{clip \\spad{==} \\spad{b}.}")) (|adaptive| (($ (|Boolean|)) "\\spad{adaptive(b)} turns adaptive 2D plotting on if \\spad{b} is true, or off if \\spad{b} is false. This option is expressed in the form \\spad{adaptive \\spad{==} \\spad{b}.}"))) 
NIL 
NIL 
(|DifferentialSparseMultivariatePolynomial| R S V) 
((|constructor| (NIL "\\spadtype{DifferentialSparseMultivariatePolynomial} implements an ordinary differential polynomial ring by combining a domain belonging to the category \\spadtype{DifferentialVariableCategory} with the domain \\spadtype{SparseMultivariatePolynomial}."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#3| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#3| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#3| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))))) 
(|DesingTreeCategory| S) 
((|constructor| (NIL "This category is part of the PAFF package")) (|tree| (($ (|List| |#1|)) "\\spad{tree(l)} creates a chain tree from the list \\spad{l}") (($ |#1|) "\\spad{tree(nd)} creates a tree with value \\spad{nd,} and no children") (($ |#1| (|List| $)) "\\spad{tree(nd,ls)} creates a tree with value \\spad{nd,} and children \\spad{ls.}"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|DesingTree| S) 
((|constructor| (NIL "This category is part of the PAFF package")) (|fullOutput| (((|Boolean|)) "\\spad{fullOutput returns} the value of the flag set by fullOutput(b).") (((|Boolean|) (|Boolean|)) "\\spad{fullOutput(b)} sets a flag such that when true, a coerce to OutputForm yields the full output of \\spad{tr,} otherwise encode(tr) is output (see encode function). The default is false.")) (|fullOut| (((|OutputForm|) $) "\\spad{fullOut(tr)} yields a full output of \\spad{tr} (see function fullOutput).")) (|encode| (((|String|) $) "\\spad{encode(t)} returns a string indicating the \"shape\" of the tree"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|DesingTreePackage| K |symb| |PolyRing| E |ProjPt| PCS |Plc| DIVISOR |InfClsPoint| |DesTree| BLMET) 
((|constructor| (NIL "The following is all the categories, domains and package used for the desingularisation be means of monoidal transformation (Blowing-up)")) (|genusTreeNeg| (((|Integer|) (|NonNegativeInteger|) (|List| |#10|)) "\\spad{genusTreeNeg(n,listOfTrees)} computes the \"genus\" of a curve that may be not absolutly irreducible, where \\spad{n} is the degree of a polynomial pol defining the curve and \\spad{listOfTrees} is all the desingularisation trees at all singular points on the curve defined by pol. A \"negative\" genus means that the curve is reducible \\spad{!!.}")) (|genusTree| (((|NonNegativeInteger|) (|NonNegativeInteger|) (|List| |#10|)) "\\spad{genusTree(n,listOfTrees)} computes the genus of a curve, where \\spad{n} is the degree of a polynomial pol defining the curve and \\spad{listOfTrees} is all the desingularisation trees at all singular points on the curve defined by pol.")) (|genusNeg| (((|Integer|) |#3|) "\\spad{genusNeg(pol)} computes the \"genus\" of a curve that may be not absolutly irreducible. A \"negative\" genus means that the curve is reducible \\spad{!!.}")) (|genus| (((|NonNegativeInteger|) |#3|) "\\spad{genus(pol)} computes the genus of the curve defined by pol.")) (|initializeParamOfPlaces| (((|Void|) |#10| (|List| |#3|)) "initParLocLeaves(tr,listOfFnc) initialize the local parametrization at places corresponding to the leaves of \\spad{tr} according to the given list of functions in listOfFnc.") (((|Void|) |#10|) "initParLocLeaves(tr) initialize the local parametrization at places corresponding to the leaves of \\spad{tr.}")) (|initParLocLeaves| (((|Void|) |#10|) "\\spad{initParLocLeaves(tr)} initialize the local parametrization at simple points corresponding to the leaves of \\spad{tr.}")) (|fullParamInit| (((|Void|) |#10|) "\\spad{fullParamInit(tr)} initialize the local parametrization at all places (leaves of tr), computes the local exceptional divisor at each infinytly close points in the tree. This function is equivalent to the following called: initParLocLeaves(tr) initializeParamOfPlaces(tr) blowUpWithExcpDiv(tr)")) (|desingTree| (((|List| |#10|) |#3|) "\\spad{desingTree(pol)} returns all the desingularisation trees of all singular points on the curve defined by pol.")) (|desingTreeAtPoint| ((|#10| |#5| |#3|) "\\spad{desingTreeAtPoint(pt,pol)} computes the desingularisation tree at the point \\spad{pt} on the curve defined by pol. This function recursively compute the tree.")) (|adjunctionDivisor| ((|#8| |#10|) "\\spad{adjunctionDivisor(tr)} compute the local adjunction divisor of a desingularisation tree \\spad{tr} of a singular point.")) (|divisorAtDesingTree| ((|#8| |#3| |#10|) "\\spad{divisorAtDesingTree(f,tr)} computes the local divisor of \\spad{f} at a desingularisation tree \\spad{tr} of a singular point."))) 
NIL 
NIL 
(|DifferentialVariableCategory&| A S) 
((|constructor| (NIL "\\spadtype{DifferentialVariableCategory} constructs the set of derivatives of a given set of (ordinary) differential indeterminates. If x,...,y is an ordered set of differential indeterminates, and the prime notation is used for differentiation, then the set of derivatives (including zero-th order) of the differential indeterminates is x,\\spad{x'},\\spad{x''},..., y,\\spad{y'},\\spad{y''},... (Note that in the interpreter, the \\spad{n}-th derivative of \\spad{y} is displayed as \\spad{y} with a subscript \\spad{n.)} This set is viewed as a set of algebraic indeterminates, totally ordered in a way compatible with differentiation and the given order on the differential indeterminates. Such a total order is called a ranking of the differential indeterminates. \\blankline A domain in this category is needed to construct a differential polynomial domain. Differential polynomials are ordered by a ranking on the derivatives, and by an order (extending the ranking) on on the set of differential monomials. One may thus associate a domain in this category with a ranking of the differential indeterminates, just as one associates a domain in the category \\spadtype{OrderedAbelianMonoidSup} with an ordering of the set of monomials in a set of algebraic indeterminates. The ranking is specified through the binary relation \\spadfun{<}. For example, one may define one derivative to be less than another by lexicographically comparing first the \\spadfun{order}, then the given order of the differential indeterminates appearing in the derivatives. This is the default implementation. \\blankline The notion of weight generalizes that of degree. A polynomial domain may be made into a graded ring if a weight function is given on the set of indeterminates, Very often, a grading is the first step in ordering the set of monomials. For differential polynomial domains, this constructor provides a function \\spadfun{weight}, which allows the assignment of a non-negative number to each derivative of a differential indeterminate. For example, one may define the weight of a derivative to be simply its \\spadfun{order} (this is the default assignment). This weight function can then be extended to the set of all differential polynomials, providing a graded ring structure.")) (|coerce| (($ |#2|) "\\spad{coerce(s)} returns \\spad{s,} viewed as the zero-th order derivative of \\spad{s.}")) (|differentiate| (($ $ (|NonNegativeInteger|)) "\\spad{differentiate(v, \\spad{n)}} returns the \\spad{n}-th derivative of \\spad{v.}") (($ $) "\\spad{differentiate(v)} returns the derivative of \\spad{v.}")) (|weight| (((|NonNegativeInteger|) $) "\\spad{weight(v)} returns the weight of the derivative \\spad{v.}")) (|variable| ((|#2| $) "\\spad{variable(v)} returns \\spad{s} if \\spad{v} is any derivative of the differential indeterminate \\spad{s.}")) (|order| (((|NonNegativeInteger|) $) "\\spad{order(v)} returns \\spad{n} if \\spad{v} is the \\spad{n}-th derivative of any differential indeterminate.")) (|makeVariable| (($ |#2| (|NonNegativeInteger|)) "\\spad{makeVariable(s, \\spad{n)}} returns the \\spad{n}-th derivative of a differential indeterminate \\spad{s} as an algebraic indeterminate."))) 
NIL 
NIL 
(|DifferentialVariableCategory| S) 
((|constructor| (NIL "\\spadtype{DifferentialVariableCategory} constructs the set of derivatives of a given set of (ordinary) differential indeterminates. If x,...,y is an ordered set of differential indeterminates, and the prime notation is used for differentiation, then the set of derivatives (including zero-th order) of the differential indeterminates is x,\\spad{x'},\\spad{x''},..., y,\\spad{y'},\\spad{y''},... (Note that in the interpreter, the \\spad{n}-th derivative of \\spad{y} is displayed as \\spad{y} with a subscript \\spad{n.)} This set is viewed as a set of algebraic indeterminates, totally ordered in a way compatible with differentiation and the given order on the differential indeterminates. Such a total order is called a ranking of the differential indeterminates. \\blankline A domain in this category is needed to construct a differential polynomial domain. Differential polynomials are ordered by a ranking on the derivatives, and by an order (extending the ranking) on on the set of differential monomials. One may thus associate a domain in this category with a ranking of the differential indeterminates, just as one associates a domain in the category \\spadtype{OrderedAbelianMonoidSup} with an ordering of the set of monomials in a set of algebraic indeterminates. The ranking is specified through the binary relation \\spadfun{<}. For example, one may define one derivative to be less than another by lexicographically comparing first the \\spadfun{order}, then the given order of the differential indeterminates appearing in the derivatives. This is the default implementation. \\blankline The notion of weight generalizes that of degree. A polynomial domain may be made into a graded ring if a weight function is given on the set of indeterminates, Very often, a grading is the first step in ordering the set of monomials. For differential polynomial domains, this constructor provides a function \\spadfun{weight}, which allows the assignment of a non-negative number to each derivative of a differential indeterminate. For example, one may define the weight of a derivative to be simply its \\spadfun{order} (this is the default assignment). This weight function can then be extended to the set of all differential polynomials, providing a graded ring structure.")) (|coerce| (($ |#1|) "\\spad{coerce(s)} returns \\spad{s,} viewed as the zero-th order derivative of \\spad{s.}")) (|differentiate| (($ $ (|NonNegativeInteger|)) "\\spad{differentiate(v, \\spad{n)}} returns the \\spad{n}-th derivative of \\spad{v.}") (($ $) "\\spad{differentiate(v)} returns the derivative of \\spad{v.}")) (|weight| (((|NonNegativeInteger|) $) "\\spad{weight(v)} returns the weight of the derivative \\spad{v.}")) (|variable| ((|#1| $) "\\spad{variable(v)} returns \\spad{s} if \\spad{v} is any derivative of the differential indeterminate \\spad{s.}")) (|order| (((|NonNegativeInteger|) $) "\\spad{order(v)} returns \\spad{n} if \\spad{v} is the \\spad{n}-th derivative of any differential indeterminate.")) (|makeVariable| (($ |#1| (|NonNegativeInteger|)) "\\spad{makeVariable(s, \\spad{n)}} returns the \\spad{n}-th derivative of a differential indeterminate \\spad{s} as an algebraic indeterminate."))) 
NIL 
NIL 
(|e04AgentsPackage|) 
((|constructor| (NIL "\\axiomType{e04AgentsPackage} is a package of numerical agents to be used to investigate attributes of an input function so as to decide the \\axiomFun{measure} of an appropriate numerical optimization routine.")) (|optAttributes| (((|List| (|String|)) (|Union| (|:| |noa| (|Record| (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |init| (|List| (|DoubleFloat|))) (|:| |lb| (|List| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |cf| (|List| (|Expression| (|DoubleFloat|)))) (|:| |ub| (|List| (|OrderedCompletion| (|DoubleFloat|)))))) (|:| |lsa| (|Record| (|:| |lfn| (|List| (|Expression| (|DoubleFloat|)))) (|:| |init| (|List| (|DoubleFloat|))))))) "\\spad{optAttributes(o)} is a function for supplying a list of attributes of an optimization problem.")) (|expenseOfEvaluation| (((|Float|) (|Record| (|:| |lfn| (|List| (|Expression| (|DoubleFloat|)))) (|:| |init| (|List| (|DoubleFloat|))))) "\\spad{expenseOfEvaluation(o)} returns the intensity value of the cost of evaluating the input set of functions. This is in terms of the number of ``operational units''. It returns a value in the range [0,1].")) (|changeNameToObjf| (((|Result|) (|Symbol|) (|Result|)) "\\spad{changeNameToObjf(s,r)} changes the name of item \\axiom{s} in \\axiom{r} to objf.")) (|varList| (((|List| (|Symbol|)) (|Expression| (|DoubleFloat|)) (|NonNegativeInteger|)) "\\spad{varList(e,n)} returns a list of \\axiom{n} indexed variables with name as in \\axiom{e}.")) (|variables| (((|List| (|Symbol|)) (|Record| (|:| |lfn| (|List| (|Expression| (|DoubleFloat|)))) (|:| |init| (|List| (|DoubleFloat|))))) "\\spad{variables(args)} returns the list of variables in \\axiom{args.lfn}")) (|quadratic?| (((|Boolean|) (|Expression| (|DoubleFloat|))) "\\spad{quadratic?(e)} tests if \\axiom{e} is a quadratic function.")) (|nonLinearPart| (((|List| (|Expression| (|DoubleFloat|))) (|List| (|Expression| (|DoubleFloat|)))) "\\spad{nonLinearPart(l)} returns the list of non-linear functions of \\spad{l.}")) (|linearPart| (((|List| (|Expression| (|DoubleFloat|))) (|List| (|Expression| (|DoubleFloat|)))) "\\spad{linearPart(l)} returns the list of linear functions of \\axiom{l}.")) (|linearMatrix| (((|Matrix| (|DoubleFloat|)) (|List| (|Expression| (|DoubleFloat|))) (|NonNegativeInteger|)) "\\spad{linearMatrix(l,n)} returns a matrix of coefficients of the linear functions in \\axiom{l}. If \\spad{l} is empty, the matrix has at least one row.")) (|linear?| (((|Boolean|) (|Expression| (|DoubleFloat|))) "\\spad{linear?(e)} tests if \\axiom{e} is a linear function.") (((|Boolean|) (|List| (|Expression| (|DoubleFloat|)))) "\\spad{linear?(l)} returns \\spad{true} if all the bounds \\spad{l} are either linear or simple.")) (|simpleBounds?| (((|Boolean|) (|List| (|Expression| (|DoubleFloat|)))) "\\spad{simpleBounds?(l)} returns \\spad{true} if the list of expressions \\spad{l} are simple.")) (|splitLinear| (((|Expression| (|DoubleFloat|)) (|Expression| (|DoubleFloat|))) "\\spad{splitLinear(f)} splits the linear part from an expression which it returns.")) (|sumOfSquares| (((|Union| (|Expression| (|DoubleFloat|)) "failed") (|Expression| (|DoubleFloat|))) "\\spad{sumOfSquares(f)} returns either an expression for which the square is the original function of \"failed\".")) (|sortConstraints| (((|Record| (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |init| (|List| (|DoubleFloat|))) (|:| |lb| (|List| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |cf| (|List| (|Expression| (|DoubleFloat|)))) (|:| |ub| (|List| (|OrderedCompletion| (|DoubleFloat|))))) (|Record| (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |init| (|List| (|DoubleFloat|))) (|:| |lb| (|List| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |cf| (|List| (|Expression| (|DoubleFloat|)))) (|:| |ub| (|List| (|OrderedCompletion| (|DoubleFloat|)))))) "\\spad{sortConstraints(args)} uses a simple bubblesort on the list of constraints using the degree of the expression on which to sort. Of course, it must match the bounds to the constraints.")) (|finiteBound| (((|List| (|DoubleFloat|)) (|List| (|OrderedCompletion| (|DoubleFloat|))) (|DoubleFloat|)) "\\spad{finiteBound(l,b)} repaces all instances of an infinite entry in \\axiom{l} by a finite entry \\axiom{b} or \\axiom{-b}."))) 
NIL 
NIL 
(|e04dgfAnnaType|) 
((|constructor| (NIL "\\axiomType{e04dgfAnnaType} is a domain of \\axiomType{NumericalOptimization} for the NAG routine E04DGF, a general optimization routine which can handle some singularities in the input function. The function \\axiomFun{measure} measures the usefulness of the routine E04DGF for the given problem. The function \\axiomFun{numericalOptimization} performs the optimization by using \\axiomType{NagOptimisationPackage}."))) 
NIL 
NIL 
(|e04fdfAnnaType|) 
((|constructor| (NIL "\\axiomType{e04fdfAnnaType} is a domain of \\axiomType{NumericalOptimization} for the NAG routine E04FDF, a general optimization routine which can handle some singularities in the input function. The function \\axiomFun{measure} measures the usefulness of the routine E04FDF for the given problem. The function \\axiomFun{numericalOptimization} performs the optimization by using \\axiomType{NagOptimisationPackage}."))) 
NIL 
NIL 
(|e04gcfAnnaType|) 
((|constructor| (NIL "\\axiomType{e04gcfAnnaType} is a domain of \\axiomType{NumericalOptimization} for the NAG routine E04GCF, a general optimization routine which can handle some singularities in the input function. The function \\axiomFun{measure} measures the usefulness of the routine E04GCF for the given problem. The function \\axiomFun{numericalOptimization} performs the optimization by using \\axiomType{NagOptimisationPackage}."))) 
NIL 
NIL 
(|e04jafAnnaType|) 
((|constructor| (NIL "\\axiomType{e04jafAnnaType} is a domain of \\axiomType{NumericalOptimization} for the NAG routine E04JAF, a general optimization routine which can handle some singularities in the input function. The function \\axiomFun{measure} measures the usefulness of the routine E04JAF for the given problem. The function \\axiomFun{numericalOptimization} performs the optimization by using \\axiomType{NagOptimisationPackage}."))) 
NIL 
NIL 
(|e04mbfAnnaType|) 
((|constructor| (NIL "\\axiomType{e04mbfAnnaType} is a domain of \\axiomType{NumericalOptimization} for the NAG routine E04MBF, an optimization routine for Linear functions. The function \\axiomFun{measure} measures the usefulness of the routine E04MBF for the given problem. The function \\axiomFun{numericalOptimization} performs the optimization by using \\axiomType{NagOptimisationPackage}."))) 
NIL 
NIL 
(|e04nafAnnaType|) 
((|constructor| (NIL "\\axiomType{e04nafAnnaType} is a domain of \\axiomType{NumericalOptimization} for the NAG routine E04NAF, an optimization routine for Quadratic functions. The function \\axiomFun{measure} measures the usefulness of the routine E04NAF for the given problem. The function \\axiomFun{numericalOptimization} performs the optimization by using \\axiomType{NagOptimisationPackage}."))) 
NIL 
NIL 
(|e04ucfAnnaType|) 
((|constructor| (NIL "\\axiomType{e04ucfAnnaType} is a domain of \\axiomType{NumericalOptimization} for the NAG routine E04UCF, a general optimization routine which can handle some singularities in the input function. The function \\axiomFun{measure} measures the usefulness of the routine E04UCF for the given problem. The function \\axiomFun{numericalOptimization} performs the optimization by using \\axiomType{NagOptimisationPackage}."))) 
NIL 
NIL 
(|ExtAlgBasis|) 
((|constructor| (NIL "A domain used in the construction of the exterior algebra on a set \\spad{X} over a ring \\spad{R.} This domain represents the set of all ordered subsets of the set \\spad{X,} assumed to be in correspondance with {1,2,3, ...}. The ordered subsets are themselves ordered lexicographically and are in bijective correspondance with an ordered basis of the exterior algebra. In this domain we are dealing strictly with the exponents of basis elements which can only be 0 or 1. \\blankline The multiplicative identity element of the exterior algebra corresponds to the empty subset of \\spad{X.} A coerce from List Integer to an ordered basis element is provided to allow the convenient input of expressions. Another exported function forgets the ordered structure and simply returns the list corresponding to an ordered subset.")) (|Nul| (($ (|NonNegativeInteger|)) "\\spad{Nul()} gives the basis element 1 for the algebra generated by \\spad{n} generators.")) (|exponents| (((|List| (|Integer|)) $) "\\spad{exponents(x)} converts a domain element into a list of zeros and ones corresponding to the exponents in the basis element that \\spad{x} represents.")) (|degree| (((|NonNegativeInteger|) $) "\\spad{degree(x)} gives the numbers of 1's in \\spad{x,} \\spadignore{i.e.} the number of non-zero exponents in the basis element that \\spad{x} represents.")) (|coerce| (($ (|List| (|Integer|))) "\\spad{coerce(l)} converts a list of 0's and 1's into a basis element, where 1 (respectively 0) designates that the variable of the corresponding index of \\spad{l} is (respectively, is not) present. Error: if an element of \\spad{l} is not 0 or 1."))) 
NIL 
NIL 
(|ElementaryFunction| R F) 
((|constructor| (NIL "Provides elementary functions over an integral domain.")) (|localReal?| (((|Boolean|) |#2|) "\\spad{localReal?(x)} should be local but conditional")) (|specialTrigs| (((|Union| |#2| "failed") |#2| (|List| (|Record| (|:| |func| |#2|) (|:| |pole| (|Boolean|))))) "\\spad{specialTrigs(x,l)} should be local but conditional")) (|iiacsch| ((|#2| |#2|) "\\spad{iiacsch(x)} should be local but conditional")) (|iiasech| ((|#2| |#2|) "\\spad{iiasech(x)} should be local but conditional")) (|iiacoth| ((|#2| |#2|) "\\spad{iiacoth(x)} should be local but conditional")) (|iiatanh| ((|#2| |#2|) "\\spad{iiatanh(x)} should be local but conditional")) (|iiacosh| ((|#2| |#2|) "\\spad{iiacosh(x)} should be local but conditional")) (|iiasinh| ((|#2| |#2|) "\\spad{iiasinh(x)} should be local but conditional")) (|iicsch| ((|#2| |#2|) "\\spad{iicsch(x)} should be local but conditional")) (|iisech| ((|#2| |#2|) "\\spad{iisech(x)} should be local but conditional")) (|iicoth| ((|#2| |#2|) "\\spad{iicoth(x)} should be local but conditional")) (|iitanh| ((|#2| |#2|) "\\spad{iitanh(x)} should be local but conditional")) (|iicosh| ((|#2| |#2|) "\\spad{iicosh(x)} should be local but conditional")) (|iisinh| ((|#2| |#2|) "\\spad{iisinh(x)} should be local but conditional")) (|iiacsc| ((|#2| |#2|) "\\spad{iiacsc(x)} should be local but conditional")) (|iiasec| ((|#2| |#2|) "\\spad{iiasec(x)} should be local but conditional")) (|iiacot| ((|#2| |#2|) "\\spad{iiacot(x)} should be local but conditional")) (|iiatan| ((|#2| |#2|) "\\spad{iiatan(x)} should be local but conditional")) (|iiacos| ((|#2| |#2|) "\\spad{iiacos(x)} should be local but conditional")) (|iiasin| ((|#2| |#2|) "\\spad{iiasin(x)} should be local but conditional")) (|iicsc| ((|#2| |#2|) "\\spad{iicsc(x)} should be local but conditional")) (|iisec| ((|#2| |#2|) "\\spad{iisec(x)} should be local but conditional")) (|iicot| ((|#2| |#2|) "\\spad{iicot(x)} should be local but conditional")) (|iitan| ((|#2| |#2|) "\\spad{iitan(x)} should be local but conditional")) (|iicos| ((|#2| |#2|) "\\spad{iicos(x)} should be local but conditional")) (|iisin| ((|#2| |#2|) "\\spad{iisin(x)} should be local but conditional")) (|iilog| ((|#2| |#2|) "\\spad{iilog(x)} should be local but conditional")) (|iiexp| ((|#2| |#2|) "\\spad{iiexp(x)} should be local but conditional")) (|iisqrt3| ((|#2|) "\\spad{iisqrt3()} should be local but conditional")) (|iisqrt2| ((|#2|) "\\spad{iisqrt2()} should be local but conditional")) (|operator| (((|BasicOperator|) (|BasicOperator|)) "\\spad{operator(p)} returns an elementary operator with the same symbol as \\spad{p}")) (|belong?| (((|Boolean|) (|BasicOperator|)) "\\spad{belong?(p)} returns \\spad{true} if operator \\spad{p} is elementary")) (|pi| ((|#2|) "\\spad{pi()} returns the \\spad{pi} operator")) (|acsch| ((|#2| |#2|) "\\spad{acsch(x)} applies the inverse hyperbolic cosecant operator to \\spad{x}")) (|asech| ((|#2| |#2|) "\\spad{asech(x)} applies the inverse hyperbolic secant operator to \\spad{x}")) (|acoth| ((|#2| |#2|) "\\spad{acoth(x)} applies the inverse hyperbolic cotangent operator to \\spad{x}")) (|atanh| ((|#2| |#2|) "\\spad{atanh(x)} applies the inverse hyperbolic tangent operator to \\spad{x}")) (|acosh| ((|#2| |#2|) "\\spad{acosh(x)} applies the inverse hyperbolic cosine operator to \\spad{x}")) (|asinh| ((|#2| |#2|) "\\spad{asinh(x)} applies the inverse hyperbolic sine operator to \\spad{x}")) (|csch| ((|#2| |#2|) "\\spad{csch(x)} applies the hyperbolic cosecant operator to \\spad{x}")) (|sech| ((|#2| |#2|) "\\spad{sech(x)} applies the hyperbolic secant operator to \\spad{x}")) (|coth| ((|#2| |#2|) "\\spad{coth(x)} applies the hyperbolic cotangent operator to \\spad{x}")) (|tanh| ((|#2| |#2|) "\\spad{tanh(x)} applies the hyperbolic tangent operator to \\spad{x}")) (|cosh| ((|#2| |#2|) "\\spad{cosh(x)} applies the hyperbolic cosine operator to \\spad{x}")) (|sinh| ((|#2| |#2|) "\\spad{sinh(x)} applies the hyperbolic sine operator to \\spad{x}")) (|acsc| ((|#2| |#2|) "\\spad{acsc(x)} applies the inverse cosecant operator to \\spad{x}")) (|asec| ((|#2| |#2|) "\\spad{asec(x)} applies the inverse secant operator to \\spad{x}")) (|acot| ((|#2| |#2|) "\\spad{acot(x)} applies the inverse cotangent operator to \\spad{x}")) (|atan| ((|#2| |#2|) "\\spad{atan(x)} applies the inverse tangent operator to \\spad{x}")) (|acos| ((|#2| |#2|) "\\spad{acos(x)} applies the inverse cosine operator to \\spad{x}")) (|asin| ((|#2| |#2|) "\\spad{asin(x)} applies the inverse sine operator to \\spad{x}")) (|csc| ((|#2| |#2|) "\\spad{csc(x)} applies the cosecant operator to \\spad{x}")) (|sec| ((|#2| |#2|) "\\spad{sec(x)} applies the secant operator to \\spad{x}")) (|cot| ((|#2| |#2|) "\\spad{cot(x)} applies the cotangent operator to \\spad{x}")) (|tan| ((|#2| |#2|) "\\spad{tan(x)} applies the tangent operator to \\spad{x}")) (|cos| ((|#2| |#2|) "\\spad{cos(x)} applies the cosine operator to \\spad{x}")) (|sin| ((|#2| |#2|) "\\spad{sin(x)} applies the sine operator to \\spad{x}")) (|log| ((|#2| |#2|) "\\spad{log(x)} applies the logarithm operator to \\spad{x}")) (|exp| ((|#2| |#2|) "\\spad{exp(x)} applies the exponential operator to \\spad{x}"))) 
NIL 
NIL 
(|ElementaryFunctionStructurePackage| R F) 
((|constructor| (NIL "ElementaryFunctionStructurePackage provides functions to test the algebraic independence of various elementary functions, using the Risch structure theorem (real and complex versions). It also provides transformations on elementary functions which are not considered simplifications.")) (|tanQ| ((|#2| (|Fraction| (|Integer|)) |#2|) "\\spad{tanQ(q,a)} is a local function with a conditional implementation.")) (|rootNormalize| ((|#2| |#2| (|Kernel| |#2|)) "\\spad{rootNormalize(f, \\spad{k)}} returns \\spad{f} rewriting either \\spad{k} which must be an nth-root in terms of radicals already in \\spad{f}, or some radicals in \\spad{f} in terms of \\spad{k}.")) (|validExponential| (((|Union| |#2| "failed") (|List| (|Kernel| |#2|)) |#2| (|Symbol|)) "\\spad{validExponential([k1,...,kn],f,x)} returns \\spad{g} if \\spad{exp(f)=g} and \\spad{g} involves only \\spad{k1...kn}, and \"failed\" otherwise.")) (|realElementary| ((|#2| |#2| (|Symbol|)) "\\spad{realElementary(f,x)} rewrites the kernels of \\spad{f} involving \\spad{x} in terms of the 4 fundamental real transcendental elementary functions: \\spad{log, exp, tan, atan}.") ((|#2| |#2|) "\\spad{realElementary(f)} rewrites \\spad{f} in terms of the 4 fundamental real transcendental elementary functions: \\spad{log, exp, tan, atan}.")) (|rischNormalize| (((|Record| (|:| |func| |#2|) (|:| |kers| (|List| (|Kernel| |#2|))) (|:| |vals| (|List| |#2|))) |#2| (|Symbol|)) "\\spad{rischNormalize(f, \\spad{x)}} returns \\spad{[g, [k1,...,kn], [h1,...,hn]]} such that \\spad{g = normalize(f, \\spad{x)}} and each \\spad{ki} was rewritten as \\spad{hi} during the normalization.")) (|normalize| ((|#2| |#2| (|Symbol|)) "\\spad{normalize(f, \\spad{x)}} rewrites \\spad{f} using the least possible number of real algebraically independent kernels involving \\spad{x}.") ((|#2| |#2|) "\\spad{normalize(f)} rewrites \\spad{f} using the least possible number of real algebraically independent kernels."))) 
NIL 
NIL 
(|ElementaryFunctionsUnivariateLaurentSeries| |Coef| UTS ULS) 
((|constructor| (NIL "This domain provides elementary functions on any Laurent series domain over a field which was constructed from a Taylor series domain. These functions are implemented by calling the corresponding functions on the Taylor series domain. We also provide 'partial functions' which compute transcendental functions of Laurent series when possible and return \"failed\" when this is not possible.")) (|acsch| ((|#3| |#3|) "\\spad{acsch(z)} returns the inverse hyperbolic cosecant of Laurent series \\spad{z.}")) (|asech| ((|#3| |#3|) "\\spad{asech(z)} returns the inverse hyperbolic secant of Laurent series \\spad{z.}")) (|acoth| ((|#3| |#3|) "\\spad{acoth(z)} returns the inverse hyperbolic cotangent of Laurent series \\spad{z.}")) (|atanh| ((|#3| |#3|) "\\spad{atanh(z)} returns the inverse hyperbolic tangent of Laurent series \\spad{z.}")) (|acosh| ((|#3| |#3|) "\\spad{acosh(z)} returns the inverse hyperbolic cosine of Laurent series \\spad{z.}")) (|asinh| ((|#3| |#3|) "\\spad{asinh(z)} returns the inverse hyperbolic sine of Laurent series \\spad{z.}")) (|csch| ((|#3| |#3|) "\\spad{csch(z)} returns the hyperbolic cosecant of Laurent series \\spad{z.}")) (|sech| ((|#3| |#3|) "\\spad{sech(z)} returns the hyperbolic secant of Laurent series \\spad{z.}")) (|coth| ((|#3| |#3|) "\\spad{coth(z)} returns the hyperbolic cotangent of Laurent series \\spad{z.}")) (|tanh| ((|#3| |#3|) "\\spad{tanh(z)} returns the hyperbolic tangent of Laurent series \\spad{z.}")) (|cosh| ((|#3| |#3|) "\\spad{cosh(z)} returns the hyperbolic cosine of Laurent series \\spad{z.}")) (|sinh| ((|#3| |#3|) "\\spad{sinh(z)} returns the hyperbolic sine of Laurent series \\spad{z.}")) (|acsc| ((|#3| |#3|) "\\spad{acsc(z)} returns the arc-cosecant of Laurent series \\spad{z.}")) (|asec| ((|#3| |#3|) "\\spad{asec(z)} returns the arc-secant of Laurent series \\spad{z.}")) (|acot| ((|#3| |#3|) "\\spad{acot(z)} returns the arc-cotangent of Laurent series \\spad{z.}")) (|atan| ((|#3| |#3|) "\\spad{atan(z)} returns the arc-tangent of Laurent series \\spad{z.}")) (|acos| ((|#3| |#3|) "\\spad{acos(z)} returns the arc-cosine of Laurent series \\spad{z.}")) (|asin| ((|#3| |#3|) "\\spad{asin(z)} returns the arc-sine of Laurent series \\spad{z.}")) (|csc| ((|#3| |#3|) "\\spad{csc(z)} returns the cosecant of Laurent series \\spad{z.}")) (|sec| ((|#3| |#3|) "\\spad{sec(z)} returns the secant of Laurent series \\spad{z.}")) (|cot| ((|#3| |#3|) "\\spad{cot(z)} returns the cotangent of Laurent series \\spad{z.}")) (|tan| ((|#3| |#3|) "\\spad{tan(z)} returns the tangent of Laurent series \\spad{z.}")) (|cos| ((|#3| |#3|) "\\spad{cos(z)} returns the cosine of Laurent series \\spad{z.}")) (|sin| ((|#3| |#3|) "\\spad{sin(z)} returns the sine of Laurent series \\spad{z.}")) (|log| ((|#3| |#3|) "\\spad{log(z)} returns the logarithm of Laurent series \\spad{z.}")) (|exp| ((|#3| |#3|) "\\spad{exp(z)} returns the exponential of Laurent series \\spad{z.}")) (** ((|#3| |#3| (|Fraction| (|Integer|))) "\\spad{s \\spad{**} \\spad{r}} raises a Laurent series \\spad{s} to a rational power \\spad{r}"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|Field|)))) 
(|ElementaryFunctionsUnivariatePuiseuxSeries| |Coef| ULS UPXS EFULS) 
((|constructor| (NIL "This package provides elementary functions on any Laurent series domain over a field which was constructed from a Taylor series domain. These functions are implemented by calling the corresponding functions on the Taylor series domain. We also provide 'partial functions' which compute transcendental functions of Laurent series when possible and return \"failed\" when this is not possible.")) (|acsch| ((|#3| |#3|) "\\spad{acsch(z)} returns the inverse hyperbolic cosecant of a Puiseux series \\spad{z.}")) (|asech| ((|#3| |#3|) "\\spad{asech(z)} returns the inverse hyperbolic secant of a Puiseux series \\spad{z.}")) (|acoth| ((|#3| |#3|) "\\spad{acoth(z)} returns the inverse hyperbolic cotangent of a Puiseux series \\spad{z.}")) (|atanh| ((|#3| |#3|) "\\spad{atanh(z)} returns the inverse hyperbolic tangent of a Puiseux series \\spad{z.}")) (|acosh| ((|#3| |#3|) "\\spad{acosh(z)} returns the inverse hyperbolic cosine of a Puiseux series \\spad{z.}")) (|asinh| ((|#3| |#3|) "\\spad{asinh(z)} returns the inverse hyperbolic sine of a Puiseux series \\spad{z.}")) (|csch| ((|#3| |#3|) "\\spad{csch(z)} returns the hyperbolic cosecant of a Puiseux series \\spad{z.}")) (|sech| ((|#3| |#3|) "\\spad{sech(z)} returns the hyperbolic secant of a Puiseux series \\spad{z.}")) (|coth| ((|#3| |#3|) "\\spad{coth(z)} returns the hyperbolic cotangent of a Puiseux series \\spad{z.}")) (|tanh| ((|#3| |#3|) "\\spad{tanh(z)} returns the hyperbolic tangent of a Puiseux series \\spad{z.}")) (|cosh| ((|#3| |#3|) "\\spad{cosh(z)} returns the hyperbolic cosine of a Puiseux series \\spad{z.}")) (|sinh| ((|#3| |#3|) "\\spad{sinh(z)} returns the hyperbolic sine of a Puiseux series \\spad{z.}")) (|acsc| ((|#3| |#3|) "\\spad{acsc(z)} returns the arc-cosecant of a Puiseux series \\spad{z.}")) (|asec| ((|#3| |#3|) "\\spad{asec(z)} returns the arc-secant of a Puiseux series \\spad{z.}")) (|acot| ((|#3| |#3|) "\\spad{acot(z)} returns the arc-cotangent of a Puiseux series \\spad{z.}")) (|atan| ((|#3| |#3|) "\\spad{atan(z)} returns the arc-tangent of a Puiseux series \\spad{z.}")) (|acos| ((|#3| |#3|) "\\spad{acos(z)} returns the arc-cosine of a Puiseux series \\spad{z.}")) (|asin| ((|#3| |#3|) "\\spad{asin(z)} returns the arc-sine of a Puiseux series \\spad{z.}")) (|csc| ((|#3| |#3|) "\\spad{csc(z)} returns the cosecant of a Puiseux series \\spad{z.}")) (|sec| ((|#3| |#3|) "\\spad{sec(z)} returns the secant of a Puiseux series \\spad{z.}")) (|cot| ((|#3| |#3|) "\\spad{cot(z)} returns the cotangent of a Puiseux series \\spad{z.}")) (|tan| ((|#3| |#3|) "\\spad{tan(z)} returns the tangent of a Puiseux series \\spad{z.}")) (|cos| ((|#3| |#3|) "\\spad{cos(z)} returns the cosine of a Puiseux series \\spad{z.}")) (|sin| ((|#3| |#3|) "\\spad{sin(z)} returns the sine of a Puiseux series \\spad{z.}")) (|log| ((|#3| |#3|) "\\spad{log(z)} returns the logarithm of a Puiseux series \\spad{z.}")) (|exp| ((|#3| |#3|) "\\spad{exp(z)} returns the exponential of a Puiseux series \\spad{z.}")) (** ((|#3| |#3| (|Fraction| (|Integer|))) "\\spad{z \\spad{**} \\spad{r}} raises a Puiseaux series \\spad{z} to a rational power \\spad{r}"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|Field|)))) 
(|ExtensibleLinearAggregate&| A S) 
((|constructor| (NIL "An extensible aggregate is one which allows insertion and deletion of entries. These aggregates are models of lists and streams which are represented by linked structures so as to make insertion, deletion, and concatenation efficient. However, access to elements of these extensible aggregates is generally slow since access is made from the end. See \\spadtype{FlexibleArray} for an exception.")) (|removeDuplicates!| (($ $) "\\spad{removeDuplicates!(u)} destructively removes duplicates from u.")) (|select!| (($ (|Mapping| (|Boolean|) |#2|) $) "\\spad{select!(p,u)} destructively changes \\spad{u} by keeping only values \\spad{x} such that \\axiom{p(x)}.")) (|merge!| (($ $ $) "\\spad{merge!(u,v)} destructively merges \\spad{u} and \\spad{v} in ascending order.") (($ (|Mapping| (|Boolean|) |#2| |#2|) $ $) "\\spad{merge!(p,u,v)} destructively merges \\spad{u} and \\spad{v} using predicate \\spad{p.}")) (|insert!| (($ $ $ (|Integer|)) "\\spad{insert!(v,u,i)} destructively inserts aggregate \\spad{v} into \\spad{u} at position i.") (($ |#2| $ (|Integer|)) "\\spad{insert!(x,u,i)} destructively inserts \\spad{x} into \\spad{u} at position i.")) (|remove!| (($ |#2| $) "\\spad{remove!(x,u)} destructively removes all values \\spad{x} from u.") (($ (|Mapping| (|Boolean|) |#2|) $) "\\spad{remove!(p,u)} destructively removes all elements \\spad{x} of \\spad{u} such that \\axiom{p(x)} is true.")) (|delete!| (($ $ (|UniversalSegment| (|Integer|))) "\\spad{delete!(u,i..j)} destructively deletes elements u.i through u.j.") (($ $ (|Integer|)) "\\indented{1}{delete!(u,i) destructively deletes the \\axiom{i}th element of u.} \\blankline \\spad{E} Data:=Record(age:Integer,gender:String) \\spad{E} a1:AssociationList(String,Data):=table() \\spad{E} a1.\"tim\":=[55,\"male\"]$Data \\spad{E} delete!(a1,1)")) (|concat!| (($ $ $) "\\spad{concat!(u,v)} destructively appends \\spad{v} to the end of u. \\spad{v} is unchanged") (($ $ |#2|) "\\spad{concat!(u,x)} destructively adds element \\spad{x} to the end of u."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) 
(|ExtensibleLinearAggregate| S) 
((|constructor| (NIL "An extensible aggregate is one which allows insertion and deletion of entries. These aggregates are models of lists and streams which are represented by linked structures so as to make insertion, deletion, and concatenation efficient. However, access to elements of these extensible aggregates is generally slow since access is made from the end. See \\spadtype{FlexibleArray} for an exception.")) (|removeDuplicates!| (($ $) "\\spad{removeDuplicates!(u)} destructively removes duplicates from u.")) (|select!| (($ (|Mapping| (|Boolean|) |#1|) $) "\\spad{select!(p,u)} destructively changes \\spad{u} by keeping only values \\spad{x} such that \\axiom{p(x)}.")) (|merge!| (($ $ $) "\\spad{merge!(u,v)} destructively merges \\spad{u} and \\spad{v} in ascending order.") (($ (|Mapping| (|Boolean|) |#1| |#1|) $ $) "\\spad{merge!(p,u,v)} destructively merges \\spad{u} and \\spad{v} using predicate \\spad{p.}")) (|insert!| (($ $ $ (|Integer|)) "\\spad{insert!(v,u,i)} destructively inserts aggregate \\spad{v} into \\spad{u} at position i.") (($ |#1| $ (|Integer|)) "\\spad{insert!(x,u,i)} destructively inserts \\spad{x} into \\spad{u} at position i.")) (|remove!| (($ |#1| $) "\\spad{remove!(x,u)} destructively removes all values \\spad{x} from u.") (($ (|Mapping| (|Boolean|) |#1|) $) "\\spad{remove!(p,u)} destructively removes all elements \\spad{x} of \\spad{u} such that \\axiom{p(x)} is true.")) (|delete!| (($ $ (|UniversalSegment| (|Integer|))) "\\spad{delete!(u,i..j)} destructively deletes elements u.i through u.j.") (($ $ (|Integer|)) "\\indented{1}{delete!(u,i) destructively deletes the \\axiom{i}th element of u.} \\blankline \\spad{E} Data:=Record(age:Integer,gender:String) \\spad{E} a1:AssociationList(String,Data):=table() \\spad{E} a1.\"tim\":=[55,\"male\"]$Data \\spad{E} delete!(a1,1)")) (|concat!| (($ $ $) "\\spad{concat!(u,v)} destructively appends \\spad{v} to the end of u. \\spad{v} is unchanged") (($ $ |#1|) "\\spad{concat!(u,x)} destructively adds element \\spad{x} to the end of u."))) 
((|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|ElementaryFunctionCategory&| S) 
((|constructor| (NIL "Category for the elementary functions.")) (** (($ $ $) "\\spad{x**y} returns \\spad{x} to the power \\spad{y.}")) (|exp| (($ $) "\\spad{exp(x)} returns \\%e to the power \\spad{x.}")) (|log| (($ $) "\\spad{log(x)} returns the natural logarithm of \\spad{x.}"))) 
NIL 
NIL 
(|ElementaryFunctionCategory|) 
((|constructor| (NIL "Category for the elementary functions.")) (** (($ $ $) "\\spad{x**y} returns \\spad{x} to the power \\spad{y.}")) (|exp| (($ $) "\\spad{exp(x)} returns \\%e to the power \\spad{x.}")) (|log| (($ $) "\\spad{log(x)} returns the natural logarithm of \\spad{x.}"))) 
NIL 
NIL 
(|EllipticFunctionsUnivariateTaylorSeries| |Coef| UTS) 
((|constructor| (NIL "The elliptic functions \\spad{sn,} \\spad{sc} and \\spad{dn} are expanded as Taylor series.")) (|sncndn| (((|List| (|Stream| |#1|)) (|Stream| |#1|) |#1|) "\\spad{sncndn(s,c)} is used internally.")) (|dn| ((|#2| |#2| |#1|) "\\spad{dn(x,k)} expands the elliptic function \\spad{dn} as a Taylor \\indented{1}{series.}")) (|cn| ((|#2| |#2| |#1|) "\\spad{cn(x,k)} expands the elliptic function \\spad{cn} as a Taylor \\indented{1}{series.}")) (|sn| ((|#2| |#2| |#1|) "\\spad{sn(x,k)} expands the elliptic function \\spad{sn} as a Taylor \\indented{1}{series.}"))) 
NIL 
NIL 
(|Eltable| S |Index|) 
((|constructor| (NIL "An eltable over domains \\spad{D} and \\spad{I} is a structure which can be viewed as a function from \\spad{D} to I. Examples of eltable structures range from data structures, For example, those of type List, to algebraic structures like Polynomial.")) (|elt| ((|#2| $ |#1|) "\\spad{elt(u,i)} (also written: \\spad{u} . i) returns the element of \\spad{u} indexed by i. Error: if \\spad{i} is not an index of u."))) 
NIL 
NIL 
(|EltableAggregate&| S |Dom| |Im|) 
((|constructor| (NIL "An eltable aggregate is one which can be viewed as a function. For example, the list [1,7,4] can applied to 0,1, and 2 respectively will return the integers 1, 7, and 4; thus this list may be viewed as mapping 0 to 1, 1 to 7 and 2 to 4. In general, an aggregate can map members of a domain Dom to an image domain Im.")) (|qsetelt!| ((|#3| $ |#2| |#3|) "\\spad{qsetelt!(u,x,y)} sets the image of \\axiom{x} to be \\axiom{y} under \\axiom{u}, without checking that \\axiom{x} is in the domain of \\axiom{u}. If such a check is required use the function \\axiom{setelt}.")) (|setelt| ((|#3| $ |#2| |#3|) "\\spad{setelt(u,x,y)} sets the image of \\spad{x} to be \\spad{y} under u, assuming \\spad{x} is in the domain of u. Error: if \\spad{x} is not in the domain of u.")) (|qelt| ((|#3| $ |#2|) "\\spad{qelt(u, \\spad{x)}} applies \\axiom{u} to \\axiom{x} without checking whether \\axiom{x} is in the domain of \\axiom{u}. If \\axiom{x} is not in the domain of \\axiom{u} a memory-access violation may occur. If a check on whether \\axiom{x} is in the domain of \\axiom{u} is required, use the function \\axiom{elt}.")) (|elt| ((|#3| $ |#2| |#3|) "\\spad{elt(u, \\spad{x,} \\spad{y)}} applies \\spad{u} to \\spad{x} if \\spad{x} is in the domain of u, and returns \\spad{y} otherwise. For example, if \\spad{u} is a polynomial in \\axiom{x} over the rationals, \\axiom{elt(u,n,0)} may define the coefficient of \\axiom{x} to the power \\spad{n,} returning 0 when \\spad{n} is out of range."))) 
NIL 
((|HasAttribute| |#1| (QUOTE |shallowlyMutable|))) 
(|EltableAggregate| |Dom| |Im|) 
((|constructor| (NIL "An eltable aggregate is one which can be viewed as a function. For example, the list [1,7,4] can applied to 0,1, and 2 respectively will return the integers 1, 7, and 4; thus this list may be viewed as mapping 0 to 1, 1 to 7 and 2 to 4. In general, an aggregate can map members of a domain Dom to an image domain Im.")) (|qsetelt!| ((|#2| $ |#1| |#2|) "\\spad{qsetelt!(u,x,y)} sets the image of \\axiom{x} to be \\axiom{y} under \\axiom{u}, without checking that \\axiom{x} is in the domain of \\axiom{u}. If such a check is required use the function \\axiom{setelt}.")) (|setelt| ((|#2| $ |#1| |#2|) "\\spad{setelt(u,x,y)} sets the image of \\spad{x} to be \\spad{y} under u, assuming \\spad{x} is in the domain of u. Error: if \\spad{x} is not in the domain of u.")) (|qelt| ((|#2| $ |#1|) "\\spad{qelt(u, \\spad{x)}} applies \\axiom{u} to \\axiom{x} without checking whether \\axiom{x} is in the domain of \\axiom{u}. If \\axiom{x} is not in the domain of \\axiom{u} a memory-access violation may occur. If a check on whether \\axiom{x} is in the domain of \\axiom{u} is required, use the function \\axiom{elt}.")) (|elt| ((|#2| $ |#1| |#2|) "\\spad{elt(u, \\spad{x,} \\spad{y)}} applies \\spad{u} to \\spad{x} if \\spad{x} is in the domain of u, and returns \\spad{y} otherwise. For example, if \\spad{u} is a polynomial in \\axiom{x} over the rationals, \\axiom{elt(u,n,0)} may define the coefficient of \\axiom{x} to the power \\spad{n,} returning 0 when \\spad{n} is out of range."))) 
NIL 
NIL 
(|EuclideanModularRing| S R |Mod| |reduction| |merge| |exactQuo|) 
((|constructor| (NIL "These domains are used for the factorization and gcds of univariate polynomials over the integers in order to work modulo different primes. See \\spadtype{ModularRing}, \\spadtype{ModularField}")) (|elt| ((|#2| $ |#2|) "\\spad{elt(x,r)} or \\spad{x.r} is not documented")) (|inv| (($ $) "\\spad{inv(x)} is not documented")) (|recip| (((|Union| $ "failed") $) "\\spad{recip(x)} is not documented")) (|exQuo| (((|Union| $ "failed") $ $) "\\spad{exQuo(x,y)} is not documented")) (|reduce| (($ |#2| |#3|) "\\spad{reduce(r,m)} is not documented")) (|coerce| ((|#2| $) "\\spad{coerce(x)} is not documented")) (|modulus| ((|#3| $) "\\spad{modulus(x)} is not documented"))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|EntireRing|) 
((|constructor| (NIL "Entire Rings (non-commutative Integral Domains), \\spadignore{i.e.} a ring not necessarily commutative which has no zero divisors. \\blankline Axioms\\br \\tab{5}\\spad{ab=0 \\spad{=>} \\spad{a=0} or b=0} \\spad{--} known as noZeroDivisors\\br \\tab{5}\\spad{not(1=0)}")) (|noZeroDivisors| ((|attribute|) "if a product is zero then one of the factors must be zero."))) 
((|noZeroDivisors| . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|EigenPackage| R) 
((|constructor| (NIL "This is a package for the exact computation of eigenvalues and eigenvectors. This package can be made to work for matrices with coefficients which are rational functions over a ring where we can factor polynomials. Rational eigenvalues are always explicitly computed while the non-rational ones are expressed in terms of their minimal polynomial.")) (|eigenvectors| (((|List| (|Record| (|:| |eigval| (|Union| (|Fraction| (|Polynomial| |#1|)) (|SuchThat| (|Symbol|) (|Polynomial| |#1|)))) (|:| |eigmult| (|NonNegativeInteger|)) (|:| |eigvec| (|List| (|Matrix| (|Fraction| (|Polynomial| |#1|))))))) (|Matrix| (|Fraction| (|Polynomial| |#1|)))) "\\spad{eigenvectors(m)} returns the eigenvalues and eigenvectors for the matrix \\spad{m.} The rational eigenvalues and the correspondent eigenvectors are explicitely computed, while the non rational ones are given via their minimal polynomial and the corresponding eigenvectors are expressed in terms of a \"generic\" root of such a polynomial.")) (|generalizedEigenvectors| (((|List| (|Record| (|:| |eigval| (|Union| (|Fraction| (|Polynomial| |#1|)) (|SuchThat| (|Symbol|) (|Polynomial| |#1|)))) (|:| |geneigvec| (|List| (|Matrix| (|Fraction| (|Polynomial| |#1|))))))) (|Matrix| (|Fraction| (|Polynomial| |#1|)))) "\\spad{generalizedEigenvectors(m)} returns the generalized eigenvectors of the matrix \\spad{m.}")) (|generalizedEigenvector| (((|List| (|Matrix| (|Fraction| (|Polynomial| |#1|)))) (|Record| (|:| |eigval| (|Union| (|Fraction| (|Polynomial| |#1|)) (|SuchThat| (|Symbol|) (|Polynomial| |#1|)))) (|:| |eigmult| (|NonNegativeInteger|)) (|:| |eigvec| (|List| (|Matrix| (|Fraction| (|Polynomial| |#1|)))))) (|Matrix| (|Fraction| (|Polynomial| |#1|)))) "\\spad{generalizedEigenvector(eigen,m)} returns the generalized eigenvectors of the matrix relative to the eigenvalue eigen, as returned by the function eigenvectors.") (((|List| (|Matrix| (|Fraction| (|Polynomial| |#1|)))) (|Union| (|Fraction| (|Polynomial| |#1|)) (|SuchThat| (|Symbol|) (|Polynomial| |#1|))) (|Matrix| (|Fraction| (|Polynomial| |#1|))) (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{generalizedEigenvector(alpha,m,k,g)} returns the generalized eigenvectors of the matrix relative to the eigenvalue alpha. The integers \\spad{k} and \\spad{g} are respectively the algebraic and the geometric multiplicity of tye eigenvalue alpha. \\spad{alpha} can be either rational or not. In the seconda case apha is the minimal polynomial of the eigenvalue.")) (|eigenvector| (((|List| (|Matrix| (|Fraction| (|Polynomial| |#1|)))) (|Union| (|Fraction| (|Polynomial| |#1|)) (|SuchThat| (|Symbol|) (|Polynomial| |#1|))) (|Matrix| (|Fraction| (|Polynomial| |#1|)))) "\\spad{eigenvector(eigval,m)} returns the eigenvectors belonging to the eigenvalue \\spad{eigval} for the matrix \\spad{m.}")) (|eigenvalues| (((|List| (|Union| (|Fraction| (|Polynomial| |#1|)) (|SuchThat| (|Symbol|) (|Polynomial| |#1|)))) (|Matrix| (|Fraction| (|Polynomial| |#1|)))) "\\spad{eigenvalues(m)} returns the eigenvalues of the matrix \\spad{m} which are expressible as rational functions over the rational numbers.")) (|characteristicPolynomial| (((|Polynomial| |#1|) (|Matrix| (|Fraction| (|Polynomial| |#1|)))) "\\spad{characteristicPolynomial(m)} returns the characteristicPolynomial of the matrix \\spad{m} using a new generated symbol symbol as the main variable.") (((|Polynomial| |#1|) (|Matrix| (|Fraction| (|Polynomial| |#1|))) (|Symbol|)) "\\spad{characteristicPolynomial(m,var)} returns the characteristicPolynomial of the matrix \\spad{m} using the symbol \\spad{var} as the main variable."))) 
NIL 
NIL 
(|EquationFunctions2| S R) 
((|constructor| (NIL "This package provides operations for mapping the sides of equations.")) (|map| (((|Equation| |#2|) (|Mapping| |#2| |#1|) (|Equation| |#1|)) "\\spad{map(f,eq)} returns an equation where \\spad{f} is applied to the sides of \\spad{eq}"))) 
NIL 
NIL 
(|Equation| S) 
((|constructor| (NIL "Equations as mathematical objects. All properties of the basis domain, \\spadignore{e.g.} being an abelian group are carried over the equation domain, by performing the structural operations on the left and on the right hand side.")) (|subst| (($ $ $) "\\spad{subst(eq1,eq2)} substitutes \\spad{eq2} into both sides of \\spad{eq1} the \\spad{lhs} of \\spad{eq2} should be a kernel")) (|inv| (($ $) "\\spad{inv(x)} returns the multiplicative inverse of \\spad{x.}")) (/ (($ $ $) "\\spad{e1/e2} produces a new equation by dividing the left and right hand sides of equations \\spad{e1} and e2.")) (|factorAndSplit| (((|List| $) $) "\\spad{factorAndSplit(eq)} make the right hand side 0 and factors the new left hand side. Each factor is equated to 0 and put into the resulting list without repetitions.")) (|rightOne| (((|Union| $ "failed") $) "\\spad{rightOne(eq)} divides by the right hand side.") (((|Union| $ "failed") $) "\\spad{rightOne(eq)} divides by the right hand side, if possible.")) (|leftOne| (((|Union| $ "failed") $) "\\spad{leftOne(eq)} divides by the left hand side.") (((|Union| $ "failed") $) "\\spad{leftOne(eq)} divides by the left hand side, if possible.")) (* (($ $ |#1|) "\\spad{eqn*x} produces a new equation by multiplying both sides of equation eqn by \\spad{x.}") (($ |#1| $) "\\spad{x*eqn} produces a new equation by multiplying both sides of equation eqn by \\spad{x.}")) (- (($ $ |#1|) "\\spad{eqn-x} produces a new equation by subtracting \\spad{x} from both sides of equation eqn.") (($ |#1| $) "\\spad{x-eqn} produces a new equation by subtracting both sides of equation eqn from \\spad{x.}")) (|rightZero| (($ $) "\\spad{rightZero(eq)} subtracts the right hand side.")) (|leftZero| (($ $) "\\spad{leftZero(eq)} subtracts the left hand side.")) (+ (($ $ |#1|) "\\spad{eqn+x} produces a new equation by adding \\spad{x} to both sides of equation eqn.") (($ |#1| $) "\\spad{x+eqn} produces a new equation by adding \\spad{x} to both sides of equation eqn.")) (|eval| (($ $ (|List| $)) "\\spad{eval(eqn, [x1=v1, \\spad{...} xn=vn])} replaces \\spad{xi} by \\spad{vi} in equation eqn.") (($ $ $) "\\spad{eval(eqn, x=f)} replaces \\spad{x} by \\spad{f} in equation eqn.")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\spad{map(f,eqn)} constructs a new equation by applying \\spad{f} to both sides of eqn.")) (|rhs| ((|#1| $) "\\spad{rhs(eqn)} returns the right hand side of equation eqn.")) (|lhs| ((|#1| $) "\\spad{lhs(eqn)} returns the left hand side of equation eqn.")) (|swap| (($ $) "\\spad{swap(eq)} interchanges left and right hand side of equation eq.")) (|equation| (($ |#1| |#1|) "\\spad{equation(a,b)} creates an equation.")) (= (($ |#1| |#1|) "\\spad{a=b} creates an equation."))) 
((|unitsKnown| OR (|has| |#1| (|Ring|)) (|has| |#1| (|Group|))) (|rightUnitary| |has| |#1| (|Ring|)) (|leftUnitary| |has| |#1| (|Ring|))) 
((|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (QUOTE (|Ring|))) (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (OR (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (|HasCategory| |#1| (QUOTE (|Group|))) (|HasCategory| |#1| (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (|devaluate| |#1|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|ExpressionSpace|))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|Group|)))) (OR (|HasCategory| |#1| (QUOTE (|Group|))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|Monoid|))) (OR (|HasCategory| |#1| (QUOTE (|Group|))) (|HasCategory| |#1| (QUOTE (|Monoid|)))) (|HasCategory| |#1| (QUOTE (|SemiGroup|))) (OR (|HasCategory| |#1| (QUOTE (|Group|))) (|HasCategory| |#1| (QUOTE (|Monoid|))) (|HasCategory| |#1| (QUOTE (|SemiGroup|)))) (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (OR (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (OR (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#1| (QUOTE (|Monoid|)))) (|HasCategory| |#1| (QUOTE (|AbelianSemiGroup|))) (OR (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#1| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (OR (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#1| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|Group|))) (|HasCategory| |#1| (QUOTE (|Monoid|))) (|HasCategory| |#1| (QUOTE (|Ring|))) (|HasCategory| |#1| (QUOTE (|SemiGroup|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|EqTable| |Key| |Entry|) 
((|constructor| (NIL "This domain provides tables where the keys are compared using \\spadfun{eq?}. Thus keys are considered equal only if they are the same instance of a structure."))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (|devaluate| |#1|)) (LIST (QUOTE |:|) (QUOTE |entry|) (|devaluate| |#2|))))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))) (OR (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) 
(|ErrorFunctions|) 
((|constructor| (NIL "ErrorFunctions implements error functions callable from the system interpreter. Typically, these functions would be called in user functions. The simple forms of the functions take one argument which is either a string (an error message) or a list of strings which all together make up a message. The list can contain formatting codes (see below). The more sophisticated versions takes two arguments where the first argument is the name of the function from which the error was invoked and the second argument is either a string or a list of strings, as above. When you use the one argument version in an interpreter function, the system will automatically insert the name of the function as the new first argument. Thus in the user interpreter function\\br \\tab{5}\\spad{f \\spad{x} \\spad{==} if \\spad{x} < 0 then error \"negative argument\" else x}\\br the call to error will actually be of the form\\br \\tab{5}\\spad{error(\"f\",\"negative argument\")}\\br because the interpreter will have created a new first argument. \\blankline Formatting codes: error messages may contain the following formatting codes (they should either start or end a string or else have blanks around them):\\br \\spad{\\%l}\\tab{6}start a new line\\br \\spad{\\%b}\\tab{6}start printing in a bold font (where available)\\br \\spad{\\%d}\\tab{6}stop printing in a bold font (where available)\\br \\spad{\\%ceon}\\tab{3}start centering message lines\\br \\spad{\\%ceoff}\\tab{2}stop centering message lines\\br \\spad{\\%rjon}\\tab{3}start displaying lines \"ragged left\"\\br \\spad{\\%rjoff}\\tab{2}stop displaying lines \"ragged left\"\\br \\spad{\\%i}\\tab{6}indent following lines 3 additional spaces\\br \\spad{\\%u}\\tab{6}unindent following lines 3 additional spaces\\br \\spad{\\%xN}\\tab{5}insert \\spad{N} blanks (eg, \\spad{\\%x10} inserts 10 blanks) \\blankline")) (|error| (((|Exit|) (|String|) (|List| (|String|))) "\\spad{error(nam,lmsg)} displays error messages \\spad{lmsg} preceded by a message containing the name \\spad{nam} of the function in which the error is contained.") (((|Exit|) (|String|) (|String|)) "\\spad{error(nam,msg)} displays error message \\spad{msg} preceded by a message containing the name \\spad{nam} of the function in which the error is contained.") (((|Exit|) (|List| (|String|))) "\\spad{error(lmsg)} displays error message \\spad{lmsg} and terminates.") (((|Exit|) (|String|)) "\\spad{error(msg)} displays error message \\spad{msg} and terminates."))) 
NIL 
NIL 
(|ExpressionSpaceFunctions1| F S) 
((|constructor| (NIL "This package allows a map from any expression space into any object to be lifted to a kernel over the expression set, using a given property of the operator of the kernel.")) (|map| ((|#2| (|Mapping| |#2| |#1|) (|String|) (|Kernel| |#1|)) "\\spad{map(f, \\spad{p,} \\spad{k)}} uses the property \\spad{p} of the operator of \\spad{k,} in order to lift \\spad{f} and apply it to \\spad{k.}"))) 
NIL 
NIL 
(|ExpressionSpaceFunctions2| E F) 
((|constructor| (NIL "This package allows a mapping \\spad{E} \\spad{->} \\spad{F} to be lifted to a kernel over E; This lifting can fail if the operator of the kernel cannot be applied in \\spad{F;} Do not use this package with \\spad{E} = \\spad{F,} since this may drop some properties of the operators.")) (|map| ((|#2| (|Mapping| |#2| |#1|) (|Kernel| |#1|)) "\\spad{map(f, \\spad{k)}} returns \\spad{g = op(f(a1),...,f(an))} where \\spad{k = op(a1,...,an)}."))) 
NIL 
NIL 
(|ExpertSystemContinuityPackage1| A B) 
((|constructor| (NIL "\\spad{ExpertSystemContinuityPackage1} exports a function to check range inclusion")) (|in?| (((|Boolean|) (|DoubleFloat|)) "\\spad{in?(p)} tests whether point \\spad{p} is internal to the range [\\spad{A..B}]"))) 
NIL 
NIL 
(|ExpertSystemContinuityPackage|) 
((|constructor| (NIL "ExpertSystemContinuityPackage is a package of functions for the use of domains belonging to the category \\axiomType{NumericalIntegration}.")) (|sdf2lst| (((|List| (|String|)) (|Stream| (|DoubleFloat|))) "\\spad{sdf2lst(ln)} coerces a Stream of \\axiomType{DoubleFloat} to \\axiomType{List}(\\axiomType{String})")) (|ldf2lst| (((|List| (|String|)) (|List| (|DoubleFloat|))) "\\spad{ldf2lst(ln)} coerces a List of \\axiomType{DoubleFloat} to \\axiomType{List}(\\axiomType{String})")) (|df2st| (((|String|) (|DoubleFloat|)) "\\spad{df2st(n)} coerces a \\axiomType{DoubleFloat} to \\axiomType{String}")) (|polynomialZeros| (((|List| (|DoubleFloat|)) (|Polynomial| (|Fraction| (|Integer|))) (|Symbol|) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{polynomialZeros(fn,var,range)} calculates the real zeros of the polynomial which are contained in the given interval. It returns a list of points (\\axiomType{Doublefloat}) for which the univariate polynomial \\spad{fn} is zero.")) (|singularitiesOf| (((|Stream| (|DoubleFloat|)) (|Vector| (|Expression| (|DoubleFloat|))) (|List| (|Symbol|)) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{singularitiesOf(v,vars,range)} returns a list of points (\\axiomType{Doublefloat}) at which a NAG fortran version of \\spad{v} will most likely produce an error. This includes those points which evaluate to 0/0.") (((|Stream| (|DoubleFloat|)) (|Expression| (|DoubleFloat|)) (|List| (|Symbol|)) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{singularitiesOf(e,vars,range)} returns a list of points (\\axiomType{Doublefloat}) at which a NAG fortran version of \\spad{e} will most likely produce an error. This includes those points which evaluate to 0/0.")) (|zerosOf| (((|Stream| (|DoubleFloat|)) (|Expression| (|DoubleFloat|)) (|List| (|Symbol|)) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{zerosOf(e,vars,range)} returns a list of points (\\axiomType{Doublefloat}) at which a NAG fortran version of \\spad{e} will most likely produce an error.")) (|problemPoints| (((|List| (|DoubleFloat|)) (|Expression| (|DoubleFloat|)) (|Symbol|) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{problemPoints(f,var,range)} returns a list of possible problem points by looking at the zeros of the denominator of the function \\spad{f} if it can be retracted to \\axiomType{Polynomial(DoubleFloat)}.")) (|functionIsFracPolynomial?| (((|Boolean|) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{functionIsFracPolynomial?(args)} tests whether the function can be retracted to \\axiomType{Fraction(Polynomial(DoubleFloat))}")) (|gethi| (((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{gethi(u)} gets the \\axiomType{DoubleFloat} equivalent of the second endpoint of the range \\axiom{u}")) (|getlo| (((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{getlo(u)} gets the \\axiomType{DoubleFloat} equivalent of the first endpoint of the range \\axiom{u}"))) 
NIL 
NIL 
(|ExpressionSpace&| S) 
((|constructor| (NIL "An expression space is a set which is closed under certain operators.")) (|odd?| (((|Boolean|) $) "\\spad{odd? \\spad{x}} is \\spad{true} if \\spad{x} is an odd integer.")) (|even?| (((|Boolean|) $) "\\spad{even? \\spad{x}} is \\spad{true} if \\spad{x} is an even integer.")) (|definingPolynomial| (($ $) "\\spad{definingPolynomial(x)} returns an expression \\spad{p} such that \\spad{p(x) = 0}.")) (|minPoly| (((|SparseUnivariatePolynomial| $) (|Kernel| $)) "\\spad{minPoly(k)} returns \\spad{p} such that \\spad{p(k) = 0}.")) (|eval| (($ $ (|BasicOperator|) (|Mapping| $ $)) "\\spad{eval(x, \\spad{s,} \\spad{f)}} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.") (($ $ (|BasicOperator|) (|Mapping| $ (|List| $))) "\\spad{eval(x, \\spad{s,} \\spad{f)}} replaces every \\spad{s(a1,..,am)} in \\spad{x} by \\spad{f(a1,..,am)} for any \\spad{a1},...,\\spad{am}.") (($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ (|List| $)))) "\\spad{eval(x, [s1,...,sm], [f1,...,fm])} replaces every \\spad{si(a1,...,an)} in \\spad{x} by \\spad{fi(a1,...,an)} for any \\spad{a1},...,\\spad{an}.") (($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ $))) "\\spad{eval(x, [s1,...,sm], [f1,...,fm])} replaces every \\spad{si(a)} in \\spad{x} by \\spad{fi(a)} for any \\spad{a}.") (($ $ (|Symbol|) (|Mapping| $ $)) "\\spad{eval(x, \\spad{s,} \\spad{f)}} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.") (($ $ (|Symbol|) (|Mapping| $ (|List| $))) "\\spad{eval(x, \\spad{s,} \\spad{f)}} replaces every \\spad{s(a1,..,am)} in \\spad{x} by \\spad{f(a1,..,am)} for any \\spad{a1},...,\\spad{am}.") (($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ (|List| $)))) "\\spad{eval(x, [s1,...,sm], [f1,...,fm])} replaces every \\spad{si(a1,...,an)} in \\spad{x} by \\spad{fi(a1,...,an)} for any \\spad{a1},...,\\spad{an}.") (($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ $))) "\\spad{eval(x, [s1,...,sm], [f1,...,fm])} replaces every \\spad{si(a)} in \\spad{x} by \\spad{fi(a)} for any \\spad{a}.")) (|freeOf?| (((|Boolean|) $ (|Symbol|)) "\\spad{freeOf?(x, \\spad{s)}} tests if \\spad{x} does not contain any operator whose name is \\spad{s.}") (((|Boolean|) $ $) "\\spad{freeOf?(x, \\spad{y)}} tests if \\spad{x} does not contain any occurrence of \\spad{y,} where \\spad{y} is a single kernel.")) (|map| (($ (|Mapping| $ $) (|Kernel| $)) "\\spad{map(f, \\spad{k)}} returns \\spad{op(f(x1),...,f(xn))} where \\spad{k = op(x1,...,xn)}.")) (|kernel| (($ (|BasicOperator|) (|List| $)) "\\spad{kernel(op, [f1,...,fn])} constructs \\spad{op(f1,...,fn)} without evaluating it.") (($ (|BasicOperator|) $) "\\spad{kernel(op, \\spad{x)}} constructs op(x) without evaluating it.")) (|is?| (((|Boolean|) $ (|Symbol|)) "\\spad{is?(x, \\spad{s)}} tests if \\spad{x} is a kernel and is the name of its operator is \\spad{s.}") (((|Boolean|) $ (|BasicOperator|)) "\\spad{is?(x, op)} tests if \\spad{x} is a kernel and is its operator is op.")) (|belong?| (((|Boolean|) (|BasicOperator|)) "\\spad{belong?(op)} tests if \\% accepts \\spad{op} as applicable to its elements.")) (|operator| (((|BasicOperator|) (|BasicOperator|)) "\\spad{operator(op)} returns a copy of \\spad{op} with the domain-dependent properties appropriate for \\spad{%.}")) (|operators| (((|List| (|BasicOperator|)) $) "\\spad{operators(f)} returns all the basic operators appearing in \\spad{f,} no matter what their levels are.")) (|tower| (((|List| (|Kernel| $)) $) "\\spad{tower(f)} returns all the kernels appearing in \\spad{f,} no matter what their levels are.")) (|kernels| (((|List| (|Kernel| $)) $) "\\spad{kernels(f)} returns the list of all the top-level kernels appearing in \\spad{f,} but not the ones appearing in the arguments of the top-level kernels.")) (|mainKernel| (((|Union| (|Kernel| $) "failed") $) "\\spad{mainKernel(f)} returns a kernel of \\spad{f} with maximum nesting level, or if \\spad{f} has no kernels (\\spadignore{i.e.} \\spad{f} is a constant).")) (|height| (((|NonNegativeInteger|) $) "\\spad{height(f)} returns the highest nesting level appearing in \\spad{f.} Constants have height 0. Symbols have height 1. For any operator op and expressions f1,...,fn, \\spad{op(f1,...,fn)} has height equal to \\spad{1 + max(height(f1),...,height(fn))}.")) (|distribute| (($ $ $) "\\spad{distribute(f, \\spad{g)}} expands all the kernels in \\spad{f} that contain \\spad{g} in their arguments and that are formally enclosed by a \\spadfunFrom{box}{ExpressionSpace} or a \\spadfunFrom{paren}{ExpressionSpace} expression.") (($ $) "\\spad{distribute(f)} expands all the kernels in \\spad{f} that are formally enclosed by a \\spadfunFrom{box}{ExpressionSpace} or \\spadfunFrom{paren}{ExpressionSpace} expression.")) (|paren| (($ (|List| $)) "\\spad{paren([f1,...,fn])} returns \\spad{(f1,...,fn)}. This prevents the \\spad{fi} from being evaluated when operators are applied to them, and makes them applicable to a unary operator. For example, \\spad{atan(paren \\spad{[x,} 2])} returns the formal kernel \\spad{atan((x, 2))}.") (($ $) "\\spad{paren(f)} returns (f). This prevents \\spad{f} from being evaluated when operators are applied to it. For example, \\spad{log(1)} returns 0, but \\spad{log(paren 1)} returns the formal kernel log((1)).")) (|box| (($ (|List| $)) "\\spad{box([f1,...,fn])} returns \\spad{(f1,...,fn)} with a 'box' around them that prevents the \\spad{fi} from being evaluated when operators are applied to them, and makes them applicable to a unary operator. For example, \\spad{atan(box \\spad{[x,} 2])} returns the formal kernel \\spad{atan(x, 2)}.") (($ $) "\\spad{box(f)} returns \\spad{f} with a 'box' around it that prevents \\spad{f} from being evaluated when operators are applied to it. For example, \\spad{log(1)} returns 0, but \\spad{log(box 1)} returns the formal kernel log(1).")) (|subst| (($ $ (|List| (|Kernel| $)) (|List| $)) "\\spad{subst(f, [k1...,kn], [g1,...,gn])} replaces the kernels k1,...,kn by g1,...,gn formally in \\spad{f.}") (($ $ (|List| (|Equation| $))) "\\spad{subst(f, \\spad{[k1} = g1,...,kn = gn])} replaces the kernels k1,...,kn by g1,...,gn formally in \\spad{f.}") (($ $ (|Equation| $)) "\\spad{subst(f, \\spad{k} = \\spad{g)}} replaces the kernel \\spad{k} by \\spad{g} formally in \\spad{f.}")) (|elt| (($ (|BasicOperator|) (|List| $)) "\\spad{elt(op,[x1,...,xn])} or op([x1,...,xn]) applies the n-ary operator \\spad{op} to x1,...,xn.") (($ (|BasicOperator|) $ $ $ $) "\\spad{elt(op,x,y,z,t)} or op(x, \\spad{y,} \\spad{z,} \\spad{t)} applies the 4-ary operator \\spad{op} to \\spad{x,} \\spad{y,} \\spad{z} and \\spad{t.}") (($ (|BasicOperator|) $ $ $) "\\spad{elt(op,x,y,z)} or op(x, \\spad{y,} \\spad{z)} applies the ternary operator \\spad{op} to \\spad{x,} \\spad{y} and \\spad{z.}") (($ (|BasicOperator|) $ $) "\\spad{elt(op,x,y)} or op(x, \\spad{y)} applies the binary operator \\spad{op} to \\spad{x} and \\spad{y.}") (($ (|BasicOperator|) $) "\\spad{elt(op,x)} or op(x) applies the unary operator \\spad{op} to \\spad{x.}"))) 
NIL 
((|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Ring|)))) 
(|ExpressionSpace|) 
((|constructor| (NIL "An expression space is a set which is closed under certain operators.")) (|odd?| (((|Boolean|) $) "\\spad{odd? \\spad{x}} is \\spad{true} if \\spad{x} is an odd integer.")) (|even?| (((|Boolean|) $) "\\spad{even? \\spad{x}} is \\spad{true} if \\spad{x} is an even integer.")) (|definingPolynomial| (($ $) "\\spad{definingPolynomial(x)} returns an expression \\spad{p} such that \\spad{p(x) = 0}.")) (|minPoly| (((|SparseUnivariatePolynomial| $) (|Kernel| $)) "\\spad{minPoly(k)} returns \\spad{p} such that \\spad{p(k) = 0}.")) (|eval| (($ $ (|BasicOperator|) (|Mapping| $ $)) "\\spad{eval(x, \\spad{s,} \\spad{f)}} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.") (($ $ (|BasicOperator|) (|Mapping| $ (|List| $))) "\\spad{eval(x, \\spad{s,} \\spad{f)}} replaces every \\spad{s(a1,..,am)} in \\spad{x} by \\spad{f(a1,..,am)} for any \\spad{a1},...,\\spad{am}.") (($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ (|List| $)))) "\\spad{eval(x, [s1,...,sm], [f1,...,fm])} replaces every \\spad{si(a1,...,an)} in \\spad{x} by \\spad{fi(a1,...,an)} for any \\spad{a1},...,\\spad{an}.") (($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ $))) "\\spad{eval(x, [s1,...,sm], [f1,...,fm])} replaces every \\spad{si(a)} in \\spad{x} by \\spad{fi(a)} for any \\spad{a}.") (($ $ (|Symbol|) (|Mapping| $ $)) "\\spad{eval(x, \\spad{s,} \\spad{f)}} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.") (($ $ (|Symbol|) (|Mapping| $ (|List| $))) "\\spad{eval(x, \\spad{s,} \\spad{f)}} replaces every \\spad{s(a1,..,am)} in \\spad{x} by \\spad{f(a1,..,am)} for any \\spad{a1},...,\\spad{am}.") (($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ (|List| $)))) "\\spad{eval(x, [s1,...,sm], [f1,...,fm])} replaces every \\spad{si(a1,...,an)} in \\spad{x} by \\spad{fi(a1,...,an)} for any \\spad{a1},...,\\spad{an}.") (($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ $))) "\\spad{eval(x, [s1,...,sm], [f1,...,fm])} replaces every \\spad{si(a)} in \\spad{x} by \\spad{fi(a)} for any \\spad{a}.")) (|freeOf?| (((|Boolean|) $ (|Symbol|)) "\\spad{freeOf?(x, \\spad{s)}} tests if \\spad{x} does not contain any operator whose name is \\spad{s.}") (((|Boolean|) $ $) "\\spad{freeOf?(x, \\spad{y)}} tests if \\spad{x} does not contain any occurrence of \\spad{y,} where \\spad{y} is a single kernel.")) (|map| (($ (|Mapping| $ $) (|Kernel| $)) "\\spad{map(f, \\spad{k)}} returns \\spad{op(f(x1),...,f(xn))} where \\spad{k = op(x1,...,xn)}.")) (|kernel| (($ (|BasicOperator|) (|List| $)) "\\spad{kernel(op, [f1,...,fn])} constructs \\spad{op(f1,...,fn)} without evaluating it.") (($ (|BasicOperator|) $) "\\spad{kernel(op, \\spad{x)}} constructs op(x) without evaluating it.")) (|is?| (((|Boolean|) $ (|Symbol|)) "\\spad{is?(x, \\spad{s)}} tests if \\spad{x} is a kernel and is the name of its operator is \\spad{s.}") (((|Boolean|) $ (|BasicOperator|)) "\\spad{is?(x, op)} tests if \\spad{x} is a kernel and is its operator is op.")) (|belong?| (((|Boolean|) (|BasicOperator|)) "\\spad{belong?(op)} tests if \\% accepts \\spad{op} as applicable to its elements.")) (|operator| (((|BasicOperator|) (|BasicOperator|)) "\\spad{operator(op)} returns a copy of \\spad{op} with the domain-dependent properties appropriate for \\spad{%.}")) (|operators| (((|List| (|BasicOperator|)) $) "\\spad{operators(f)} returns all the basic operators appearing in \\spad{f,} no matter what their levels are.")) (|tower| (((|List| (|Kernel| $)) $) "\\spad{tower(f)} returns all the kernels appearing in \\spad{f,} no matter what their levels are.")) (|kernels| (((|List| (|Kernel| $)) $) "\\spad{kernels(f)} returns the list of all the top-level kernels appearing in \\spad{f,} but not the ones appearing in the arguments of the top-level kernels.")) (|mainKernel| (((|Union| (|Kernel| $) "failed") $) "\\spad{mainKernel(f)} returns a kernel of \\spad{f} with maximum nesting level, or if \\spad{f} has no kernels (\\spadignore{i.e.} \\spad{f} is a constant).")) (|height| (((|NonNegativeInteger|) $) "\\spad{height(f)} returns the highest nesting level appearing in \\spad{f.} Constants have height 0. Symbols have height 1. For any operator op and expressions f1,...,fn, \\spad{op(f1,...,fn)} has height equal to \\spad{1 + max(height(f1),...,height(fn))}.")) (|distribute| (($ $ $) "\\spad{distribute(f, \\spad{g)}} expands all the kernels in \\spad{f} that contain \\spad{g} in their arguments and that are formally enclosed by a \\spadfunFrom{box}{ExpressionSpace} or a \\spadfunFrom{paren}{ExpressionSpace} expression.") (($ $) "\\spad{distribute(f)} expands all the kernels in \\spad{f} that are formally enclosed by a \\spadfunFrom{box}{ExpressionSpace} or \\spadfunFrom{paren}{ExpressionSpace} expression.")) (|paren| (($ (|List| $)) "\\spad{paren([f1,...,fn])} returns \\spad{(f1,...,fn)}. This prevents the \\spad{fi} from being evaluated when operators are applied to them, and makes them applicable to a unary operator. For example, \\spad{atan(paren \\spad{[x,} 2])} returns the formal kernel \\spad{atan((x, 2))}.") (($ $) "\\spad{paren(f)} returns (f). This prevents \\spad{f} from being evaluated when operators are applied to it. For example, \\spad{log(1)} returns 0, but \\spad{log(paren 1)} returns the formal kernel log((1)).")) (|box| (($ (|List| $)) "\\spad{box([f1,...,fn])} returns \\spad{(f1,...,fn)} with a 'box' around them that prevents the \\spad{fi} from being evaluated when operators are applied to them, and makes them applicable to a unary operator. For example, \\spad{atan(box \\spad{[x,} 2])} returns the formal kernel \\spad{atan(x, 2)}.") (($ $) "\\spad{box(f)} returns \\spad{f} with a 'box' around it that prevents \\spad{f} from being evaluated when operators are applied to it. For example, \\spad{log(1)} returns 0, but \\spad{log(box 1)} returns the formal kernel log(1).")) (|subst| (($ $ (|List| (|Kernel| $)) (|List| $)) "\\spad{subst(f, [k1...,kn], [g1,...,gn])} replaces the kernels k1,...,kn by g1,...,gn formally in \\spad{f.}") (($ $ (|List| (|Equation| $))) "\\spad{subst(f, \\spad{[k1} = g1,...,kn = gn])} replaces the kernels k1,...,kn by g1,...,gn formally in \\spad{f.}") (($ $ (|Equation| $)) "\\spad{subst(f, \\spad{k} = \\spad{g)}} replaces the kernel \\spad{k} by \\spad{g} formally in \\spad{f.}")) (|elt| (($ (|BasicOperator|) (|List| $)) "\\spad{elt(op,[x1,...,xn])} or op([x1,...,xn]) applies the n-ary operator \\spad{op} to x1,...,xn.") (($ (|BasicOperator|) $ $ $ $) "\\spad{elt(op,x,y,z,t)} or op(x, \\spad{y,} \\spad{z,} \\spad{t)} applies the 4-ary operator \\spad{op} to \\spad{x,} \\spad{y,} \\spad{z} and \\spad{t.}") (($ (|BasicOperator|) $ $ $) "\\spad{elt(op,x,y,z)} or op(x, \\spad{y,} \\spad{z)} applies the ternary operator \\spad{op} to \\spad{x,} \\spad{y} and \\spad{z.}") (($ (|BasicOperator|) $ $) "\\spad{elt(op,x,y)} or op(x, \\spad{y)} applies the binary operator \\spad{op} to \\spad{x} and \\spad{y.}") (($ (|BasicOperator|) $) "\\spad{elt(op,x)} or op(x) applies the unary operator \\spad{op} to \\spad{x.}"))) 
NIL 
NIL 
(|ExpertSystemToolsPackage1| R1) 
((|constructor| (NIL "\\axiom{ExpertSystemToolsPackage1} contains some useful functions for use by the computational agents of Ordinary Differential Equation solvers.")) (|neglist| (((|List| |#1|) (|List| |#1|)) "\\spad{neglist(l)} returns only the negative elements of the list \\spad{l}"))) 
NIL 
NIL 
(|ExpertSystemToolsPackage2| R1 R2) 
((|constructor| (NIL "\\axiom{ExpertSystemToolsPackage2} contains some useful functions for use by the computational agents of Ordinary Differential Equation solvers.")) (|map| (((|Matrix| |#2|) (|Mapping| |#2| |#1|) (|Matrix| |#1|)) "\\spad{map(f,m)} applies a mapping \\spad{f:R1} \\spad{->} \\spad{R2} onto a matrix \\spad{m} in \\spad{R1} returning a matrix in \\spad{R2}"))) 
NIL 
NIL 
(|ExpertSystemToolsPackage|) 
((|constructor| (NIL "\\axiom{ExpertSystemToolsPackage} contains some useful functions for use by the computational agents of numerical solvers.")) (|mat| (((|Matrix| (|DoubleFloat|)) (|List| (|DoubleFloat|)) (|NonNegativeInteger|)) "\\spad{mat(a,n)} constructs a one-dimensional matrix of a.")) (|fi2df| (((|DoubleFloat|) (|Fraction| (|Integer|))) "\\spad{fi2df(f)} coerces a \\axiomType{Fraction Integer} to \\axiomType{DoubleFloat}")) (|df2ef| (((|Expression| (|Float|)) (|DoubleFloat|)) "\\spad{df2ef(a)} coerces a \\axiomType{DoubleFloat} to \\axiomType{Expression Float}")) (|pdf2df| (((|DoubleFloat|) (|Polynomial| (|DoubleFloat|))) "\\spad{pdf2df(p)} coerces a \\axiomType{Polynomial DoubleFloat} to \\axiomType{DoubleFloat}. It is an error if \\axiom{p} is not retractable to DoubleFloat.")) (|pdf2ef| (((|Expression| (|Float|)) (|Polynomial| (|DoubleFloat|))) "\\spad{pdf2ef(p)} coerces a \\axiomType{Polynomial DoubleFloat} to \\axiomType{Expression Float}")) (|iflist2Result| (((|Result|) (|Record| (|:| |stiffness| (|Float|)) (|:| |stability| (|Float|)) (|:| |expense| (|Float|)) (|:| |accuracy| (|Float|)) (|:| |intermediateResults| (|Float|)))) "\\spad{iflist2Result(m)} converts a attributes record into a \\axiomType{Result}")) (|att2Result| (((|Result|) (|Record| (|:| |endPointContinuity| (|Union| (|:| |continuous| "Continuous at the end points") (|:| |lowerSingular| "There is a singularity at the lower end point") (|:| |upperSingular| "There is a singularity at the upper end point") (|:| |bothSingular| "There are singularities at both end points") (|:| |notEvaluated| "End point continuity not yet evaluated"))) (|:| |singularitiesStream| (|Union| (|:| |str| (|Stream| (|DoubleFloat|))) (|:| |notEvaluated| "Internal singularities not yet evaluated"))) (|:| |range| (|Union| (|:| |finite| "The range is finite") (|:| |lowerInfinite| "The bottom of range is infinite") (|:| |upperInfinite| "The top of range is infinite") (|:| |bothInfinite| "Both top and bottom points are infinite") (|:| |notEvaluated| "Range not yet evaluated"))))) "\\spad{att2Result(m)} converts a attributes record into a \\axiomType{Result}")) (|measure2Result| (((|Result|) (|Record| (|:| |measure| (|Float|)) (|:| |name| (|String|)) (|:| |explanations| (|List| (|String|))) (|:| |extra| (|Result|)))) "\\spad{measure2Result(m)} converts a measure record into a \\axiomType{Result}") (((|Result|) (|Record| (|:| |measure| (|Float|)) (|:| |name| (|String|)) (|:| |explanations| (|List| (|String|))))) "\\spad{measure2Result(m)} converts a measure record into a \\axiomType{Result}")) (|outputMeasure| (((|String|) (|Float|)) "\\spad{outputMeasure(n)} rounds \\spad{n} to 3 decimal places and outputs it as a string")) (|concat| (((|Result|) (|List| (|Result|))) "\\spad{concat(l)} concatenates a list of aggregates of type \\axiomType{Result}") (((|Result|) (|Result|) (|Result|)) "\\spad{concat(a,b)} adds two aggregates of type \\axiomType{Result}.")) (|gethi| (((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{gethi(u)} gets the \\axiomType{DoubleFloat} equivalent of the second endpoint of the range \\spad{u}")) (|getlo| (((|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{getlo(u)} gets the \\axiomType{DoubleFloat} equivalent of the first endpoint of the range \\spad{u}")) (|sdf2lst| (((|List| (|String|)) (|Stream| (|DoubleFloat|))) "\\spad{sdf2lst(ln)} coerces a \\axiomType{Stream DoubleFloat} to \\axiomType{String}")) (|ldf2lst| (((|List| (|String|)) (|List| (|DoubleFloat|))) "\\spad{ldf2lst(ln)} coerces a \\axiomType{List DoubleFloat} to \\axiomType{List String}")) (|f2st| (((|String|) (|Float|)) "\\spad{f2st(n)} coerces a \\axiomType{Float} to \\axiomType{String}")) (|df2st| (((|String|) (|DoubleFloat|)) "\\spad{df2st(n)} coerces a \\axiomType{DoubleFloat} to \\axiomType{String}")) (|in?| (((|Boolean|) (|DoubleFloat|) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{in?(p,range)} tests whether point \\spad{p} is internal to the \\spad{range} \\spad{range}")) (|vedf2vef| (((|Vector| (|Expression| (|Float|))) (|Vector| (|Expression| (|DoubleFloat|)))) "\\spad{vedf2vef(v)} maps \\axiomType{Vector Expression DoubleFloat} to \\axiomType{Vector Expression Float}")) (|edf2ef| (((|Expression| (|Float|)) (|Expression| (|DoubleFloat|))) "\\spad{edf2ef(e)} maps \\axiomType{Expression DoubleFloat} to \\axiomType{Expression Float}")) (|ldf2vmf| (((|Vector| (|MachineFloat|)) (|List| (|DoubleFloat|))) "\\spad{ldf2vmf(l)} coerces a \\axiomType{List DoubleFloat} to \\axiomType{List MachineFloat}")) (|df2mf| (((|MachineFloat|) (|DoubleFloat|)) "\\spad{df2mf(n)} coerces a \\axiomType{DoubleFloat} to \\axiomType{MachineFloat}")) (|dflist| (((|List| (|DoubleFloat|)) (|List| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|)))))) "\\spad{dflist(l)} returns a list of \\axiomType{DoubleFloat} equivalents of list \\spad{l}")) (|dfRange| (((|Segment| (|OrderedCompletion| (|DoubleFloat|))) (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) "\\spad{dfRange(r)} converts a range including \\inputbitmap{\\htbmdir{}/plusminus.bitmap} \\infty to \\axiomType{DoubleFloat} equavalents.")) (|edf2efi| (((|Expression| (|Fraction| (|Integer|))) (|Expression| (|DoubleFloat|))) "\\spad{edf2efi(e)} coerces \\axiomType{Expression DoubleFloat} into \\axiomType{Expression Fraction Integer}")) (|numberOfOperations| (((|Record| (|:| |additions| (|Integer|)) (|:| |multiplications| (|Integer|)) (|:| |exponentiations| (|Integer|)) (|:| |functionCalls| (|Integer|))) (|Vector| (|Expression| (|DoubleFloat|)))) "\\spad{numberOfOperations(ode)} counts additions, multiplications, exponentiations and function calls in the input set of expressions.")) (|expenseOfEvaluation| (((|Float|) (|Vector| (|Expression| (|DoubleFloat|)))) "\\spad{expenseOfEvaluation(o)} gives an approximation of the cost of evaluating a list of expressions in terms of the number of basic operations. < 0.3 inexpensive ; 0.5 neutral ; > 0.7 very expensive 400 `operation units' \\spad{->} 0.75 200 `operation units' \\spad{->} 0.5 83 `operation units' \\spad{->} 0.25 \\spad{**} = 4 units ,{} function calls = 10 units.")) (|isQuotient| (((|Union| (|Expression| (|DoubleFloat|)) "failed") (|Expression| (|DoubleFloat|))) "\\spad{isQuotient(expr)} returns the quotient part of the input expression or \\spad{\"failed\"} if the expression is not of that form.")) (|edf2df| (((|DoubleFloat|) (|Expression| (|DoubleFloat|))) "\\spad{edf2df(n)} maps \\axiomType{Expression DoubleFloat} to \\axiomType{DoubleFloat} It is an error if \\spad{n} is not coercible to DoubleFloat")) (|edf2fi| (((|Fraction| (|Integer|)) (|Expression| (|DoubleFloat|))) "\\spad{edf2fi(n)} maps \\axiomType{Expression DoubleFloat} to \\axiomType{Fraction Integer} It is an error if \\spad{n} is not coercible to Fraction Integer")) (|df2fi| (((|Fraction| (|Integer|)) (|DoubleFloat|)) "\\spad{df2fi(n)} is a function to convert a \\axiomType{DoubleFloat} to a \\axiomType{Fraction Integer}")) (|convert| (((|List| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|List| (|Segment| (|OrderedCompletion| (|Float|))))) "\\spad{convert(l)} is a function to convert a \\axiomType{Segment OrderedCompletion Float} to a \\axiomType{Segment OrderedCompletion DoubleFloat}")) (|socf2socdf| (((|Segment| (|OrderedCompletion| (|DoubleFloat|))) (|Segment| (|OrderedCompletion| (|Float|)))) "\\spad{socf2socdf(a)} is a function to convert a \\axiomType{Segment OrderedCompletion Float} to a \\axiomType{Segment OrderedCompletion DoubleFloat}")) (|ocf2ocdf| (((|OrderedCompletion| (|DoubleFloat|)) (|OrderedCompletion| (|Float|))) "\\spad{ocf2ocdf(a)} is a function to convert an \\axiomType{OrderedCompletion Float} to an \\axiomType{OrderedCompletion DoubleFloat}")) (|ef2edf| (((|Expression| (|DoubleFloat|)) (|Expression| (|Float|))) "\\spad{ef2edf(f)} is a function to convert an \\axiomType{Expression Float} to an \\axiomType{Expression DoubleFloat}")) (|f2df| (((|DoubleFloat|) (|Float|)) "\\spad{f2df(f)} is a function to convert a \\axiomType{Float} to a \\axiomType{DoubleFloat}"))) 
NIL 
NIL 
(|EuclideanDomain&| S) 
((|constructor| (NIL "A constructive euclidean domain, \\spadignore{i.e.} one can divide producing a quotient and a remainder where the remainder is either zero or is smaller (\\spadfun{euclideanSize}) than the divisor. \\blankline Conditional attributes\\br \\tab{5}multiplicativeValuation\\tab{5}Size(a*b)=Size(a)*Size(b)\\br \\tab{5}additiveValuation\\tab{11}Size(a*b)=Size(a)+Size(b)")) (|multiEuclidean| (((|Union| (|List| $) "failed") (|List| $) $) "\\spad{multiEuclidean([f1,...,fn],z)} returns a list of coefficients \\spad{[a1, ..., an]} such that \\spad{ \\spad{z} / prod \\spad{fi} = sum aj/fj}. If no such list of coefficients exists, \"failed\" is returned.")) (|extendedEuclidean| (((|Union| (|Record| (|:| |coef1| $) (|:| |coef2| $)) "failed") $ $ $) "\\spad{extendedEuclidean(x,y,z)} either returns a record rec where \\spad{rec.coef1*x+rec.coef2*y=z} or returns \"failed\" if \\spad{z} cannot be expressed as a linear combination of \\spad{x} and \\spad{y.}") (((|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $)) $ $) "\\spad{extendedEuclidean(x,y)} returns a record rec where \\spad{rec.coef1*x+rec.coef2*y = rec.generator} and rec.generator is a \\spad{gcd} of \\spad{x} and \\spad{y.} The \\spad{gcd} is unique only up to associates if \\spadatt{canonicalUnitNormal} is not asserted. \\spadfun{principalIdeal} provides a version of this operation which accepts an arbitrary length list of arguments.")) (|rem| (($ $ $) "\\spad{x rem \\spad{y}} is the same as \\spad{divide(x,y).remainder}. See \\spadfunFrom{divide}{EuclideanDomain}.")) (|quo| (($ $ $) "\\spad{x quo \\spad{y}} is the same as \\spad{divide(x,y).quotient}. See \\spadfunFrom{divide}{EuclideanDomain}.")) (|divide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{divide(x,y)} divides \\spad{x} by \\spad{y} producing a record containing a \\spad{quotient} and \\spad{remainder}, where the remainder is smaller (see \\spadfunFrom{sizeLess?}{EuclideanDomain}) than the divisor \\spad{y.}")) (|euclideanSize| (((|NonNegativeInteger|) $) "\\spad{euclideanSize(x)} returns the euclidean size of the element \\spad{x.} Error: if \\spad{x} is zero.")) (|sizeLess?| (((|Boolean|) $ $) "\\spad{sizeLess?(x,y)} tests whether \\spad{x} is strictly smaller than \\spad{y} with respect to the \\spadfunFrom{euclideanSize}{EuclideanDomain}."))) 
NIL 
NIL 
(|EuclideanDomain|) 
((|constructor| (NIL "A constructive euclidean domain, \\spadignore{i.e.} one can divide producing a quotient and a remainder where the remainder is either zero or is smaller (\\spadfun{euclideanSize}) than the divisor. \\blankline Conditional attributes\\br \\tab{5}multiplicativeValuation\\tab{5}Size(a*b)=Size(a)*Size(b)\\br \\tab{5}additiveValuation\\tab{11}Size(a*b)=Size(a)+Size(b)")) (|multiEuclidean| (((|Union| (|List| $) "failed") (|List| $) $) "\\spad{multiEuclidean([f1,...,fn],z)} returns a list of coefficients \\spad{[a1, ..., an]} such that \\spad{ \\spad{z} / prod \\spad{fi} = sum aj/fj}. If no such list of coefficients exists, \"failed\" is returned.")) (|extendedEuclidean| (((|Union| (|Record| (|:| |coef1| $) (|:| |coef2| $)) "failed") $ $ $) "\\spad{extendedEuclidean(x,y,z)} either returns a record rec where \\spad{rec.coef1*x+rec.coef2*y=z} or returns \"failed\" if \\spad{z} cannot be expressed as a linear combination of \\spad{x} and \\spad{y.}") (((|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $)) $ $) "\\spad{extendedEuclidean(x,y)} returns a record rec where \\spad{rec.coef1*x+rec.coef2*y = rec.generator} and rec.generator is a \\spad{gcd} of \\spad{x} and \\spad{y.} The \\spad{gcd} is unique only up to associates if \\spadatt{canonicalUnitNormal} is not asserted. \\spadfun{principalIdeal} provides a version of this operation which accepts an arbitrary length list of arguments.")) (|rem| (($ $ $) "\\spad{x rem \\spad{y}} is the same as \\spad{divide(x,y).remainder}. See \\spadfunFrom{divide}{EuclideanDomain}.")) (|quo| (($ $ $) "\\spad{x quo \\spad{y}} is the same as \\spad{divide(x,y).quotient}. See \\spadfunFrom{divide}{EuclideanDomain}.")) (|divide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{divide(x,y)} divides \\spad{x} by \\spad{y} producing a record containing a \\spad{quotient} and \\spad{remainder}, where the remainder is smaller (see \\spadfunFrom{sizeLess?}{EuclideanDomain}) than the divisor \\spad{y.}")) (|euclideanSize| (((|NonNegativeInteger|) $) "\\spad{euclideanSize(x)} returns the euclidean size of the element \\spad{x.} Error: if \\spad{x} is zero.")) (|sizeLess?| (((|Boolean|) $ $) "\\spad{sizeLess?(x,y)} tests whether \\spad{x} is strictly smaller than \\spad{y} with respect to the \\spadfunFrom{euclideanSize}{EuclideanDomain}."))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|Evalable&| S R) 
((|constructor| (NIL "This category provides \\spadfun{eval} operations. A domain may belong to this category if it is possible to make ``evaluation'' substitutions.")) (|eval| (($ $ (|List| (|Equation| |#2|))) "\\spad{eval(f, \\spad{[x1} = v1,...,xn = vn])} replaces \\spad{xi} by \\spad{vi} in \\spad{f.}") (($ $ (|Equation| |#2|)) "\\spad{eval(f,x = \\spad{v)}} replaces \\spad{x} by \\spad{v} in \\spad{f.}"))) 
NIL 
NIL 
(|Evalable| R) 
((|constructor| (NIL "This category provides \\spadfun{eval} operations. A domain may belong to this category if it is possible to make ``evaluation'' substitutions.")) (|eval| (($ $ (|List| (|Equation| |#1|))) "\\spad{eval(f, \\spad{[x1} = v1,...,xn = vn])} replaces \\spad{xi} by \\spad{vi} in \\spad{f.}") (($ $ (|Equation| |#1|)) "\\spad{eval(f,x = \\spad{v)}} replaces \\spad{x} by \\spad{v} in \\spad{f.}"))) 
NIL 
NIL 
(|EvaluateCycleIndicators| F) 
((|constructor| (NIL "This package is to be used in conjuction with the CycleIndicators package. It provides an evaluation function for SymmetricPolynomials.")) (|eval| ((|#1| (|Mapping| |#1| (|Integer|)) (|SymmetricPolynomial| (|Fraction| (|Integer|)))) "\\spad{eval(f,s)} evaluates the cycle index \\spad{s} by applying \\indented{1}{the function \\spad{f} to each integer in a monomial partition,} \\indented{1}{forms their product and sums the results over all monomials.}"))) 
NIL 
NIL 
(|Exit|) 
((|constructor| (NIL "A function which does not return directly to its caller should have Exit as its return type. \\blankline Note that It is convenient to have a formal \\spad{coerce} into each type from type Exit. This allows, for example, errors to be raised in one half of a type-balanced \\spad{if}."))) 
NIL 
NIL 
(|Export3D|) 
((|writeObj| (((|Void|) (|SubSpace| 3 (|DoubleFloat|)) (|String|)) "writes 3D SubSpace to a file in Wavefront (.OBJ) format"))) 
NIL 
NIL 
(|ExponentialExpansion| R FE |var| |cen|) 
((|constructor| (NIL "UnivariatePuiseuxSeriesWithExponentialSingularity is a domain used to represent essential singularities of functions. Objects in this domain are quotients of sums, where each term in the sum is a univariate Puiseux series times the exponential of a univariate Puiseux series.")) (|coerce| (($ (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)) "\\spad{coerce(f)} converts a \\spadtype{UnivariatePuiseuxSeries} to an \\spadtype{ExponentialExpansion}.")) (|limitPlus| (((|Union| (|OrderedCompletion| |#2|) "failed") $) "\\spad{limitPlus(f(var))} returns \\spad{limit(var \\spad{->} a+,f(var))}."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|RealConstant|))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|StepThrough|))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|DifferentialRing|))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (LIST (QUOTE |UnivariatePuiseuxSeriesWithExponentialSingularity|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|) (|devaluate| |#4|)))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (LIST (QUOTE |Evalable|) (LIST (QUOTE |UnivariatePuiseuxSeriesWithExponentialSingularity|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|) (|devaluate| |#4|)))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (LIST (QUOTE |Eltable|) (LIST (QUOTE |UnivariatePuiseuxSeriesWithExponentialSingularity|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|) (|devaluate| |#4|)) (LIST (QUOTE |UnivariatePuiseuxSeriesWithExponentialSingularity|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|) (|devaluate| |#4|)))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|IntegerNumberSystem|))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|OrderedSet|))) (OR (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|OrderedSet|)))) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| (|UnivariatePuiseuxSeriesWithExponentialSingularity| |#1| |#2| |#3| |#4|) (QUOTE (|CharacteristicNonZero|))))) 
(|ExpressionFunctions2| R S) 
((|constructor| (NIL "Lifting of maps to Expressions.")) (|map| (((|Expression| |#2|) (|Mapping| |#2| |#1|) (|Expression| |#1|)) "\\spad{map(f, e)} applies \\spad{f} to all the constants appearing in e."))) 
NIL 
NIL 
(|ExpressionToUnivariatePowerSeries| R FE) 
((|constructor| (NIL "This package provides functions to convert functional expressions to power series.")) (|series| (((|Any|) |#2| (|Equation| |#2|) (|Fraction| (|Integer|))) "\\spad{series(f,x = a,n)} expands the expression \\spad{f} as a series in powers of \\spad{(x} - a); terms will be computed up to order at least \\spad{n.}") (((|Any|) |#2| (|Equation| |#2|)) "\\spad{series(f,x = a)} expands the expression \\spad{f} as a series in powers of \\spad{(x} - a).") (((|Any|) |#2| (|Fraction| (|Integer|))) "\\spad{series(f,n)} returns a series expansion of the expression \\spad{f.} Note that \\spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \\spad{n.}") (((|Any|) |#2|) "\\spad{series(f)} returns a series expansion of the expression \\spad{f.} Note that \\spad{f} should have only one variable; the series will be expanded in powers of that variable.") (((|Any|) (|Symbol|)) "\\spad{series(x)} returns \\spad{x} viewed as a series.")) (|puiseux| (((|Any|) |#2| (|Equation| |#2|) (|Fraction| (|Integer|))) "\\spad{puiseux(f,x = a,n)} expands the expression \\spad{f} as a Puiseux series in powers of \\spad{(x - a)}; terms will be computed up to order at least \\spad{n.}") (((|Any|) |#2| (|Equation| |#2|)) "\\spad{puiseux(f,x = a)} expands the expression \\spad{f} as a Puiseux series in powers of \\spad{(x - a)}.") (((|Any|) |#2| (|Fraction| (|Integer|))) "\\spad{puiseux(f,n)} returns a Puiseux expansion of the expression \\spad{f.} Note that \\spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \\spad{n.}") (((|Any|) |#2|) "\\spad{puiseux(f)} returns a Puiseux expansion of the expression \\spad{f.} Note that \\spad{f} should have only one variable; the series will be expanded in powers of that variable.") (((|Any|) (|Symbol|)) "\\spad{puiseux(x)} returns \\spad{x} viewed as a Puiseux series.")) (|laurent| (((|Any|) |#2| (|Equation| |#2|) (|Integer|)) "\\spad{laurent(f,x = a,n)} expands the expression \\spad{f} as a Laurent series in powers of \\spad{(x - a)}; terms will be computed up to order at least \\spad{n.}") (((|Any|) |#2| (|Equation| |#2|)) "\\spad{laurent(f,x = a)} expands the expression \\spad{f} as a Laurent series in powers of \\spad{(x - a)}.") (((|Any|) |#2| (|Integer|)) "\\spad{laurent(f,n)} returns a Laurent expansion of the expression \\spad{f.} Note that \\spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \\spad{n.}") (((|Any|) |#2|) "\\spad{laurent(f)} returns a Laurent expansion of the expression \\spad{f.} Note that \\spad{f} should have only one variable; the series will be expanded in powers of that variable.") (((|Any|) (|Symbol|)) "\\spad{laurent(x)} returns \\spad{x} viewed as a Laurent series.")) (|taylor| (((|Any|) |#2| (|Equation| |#2|) (|NonNegativeInteger|)) "\\spad{taylor(f,x = a)} expands the expression \\spad{f} as a Taylor series in powers of \\spad{(x - a)}; terms will be computed up to order at least \\spad{n.}") (((|Any|) |#2| (|Equation| |#2|)) "\\spad{taylor(f,x = a)} expands the expression \\spad{f} as a Taylor series in powers of \\spad{(x - a)}.") (((|Any|) |#2| (|NonNegativeInteger|)) "\\spad{taylor(f,n)} returns a Taylor expansion of the expression \\spad{f.} Note that \\spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \\spad{n.}") (((|Any|) |#2|) "\\spad{taylor(f)} returns a Taylor expansion of the expression \\spad{f.} Note that \\spad{f} should have only one variable; the series will be expanded in powers of that variable.") (((|Any|) (|Symbol|)) "\\spad{taylor(x)} returns \\spad{x} viewed as a Taylor series."))) 
NIL 
NIL 
(|Expression| R) 
((|constructor| (NIL "Top-level mathematical expressions involving symbolic functions.")) (|squareFreePolynomial| (((|Factored| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $)) "\\spad{squareFreePolynomial(p)} is not documented")) (|factorPolynomial| (((|Factored| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $)) "\\spad{factorPolynomial(p)} is not documented")) (|simplifyPower| (($ $ (|Integer|)) "simplifyPower?(f,n) is not documented")) (|number?| (((|Boolean|) $) "\\spad{number?(f)} tests if \\spad{f} is rational")) (|reduce| (($ $) "\\spad{reduce(f)} simplifies all the unreduced algebraic quantities present in \\spad{f} by applying their defining relations."))) 
((|unitsKnown| OR (|and| (|has| |#1| (|Ring|)) (|has| |#1| (|LinearlyExplicitRingOver| (|Integer|)))) (AND (|has| |#1| (|IntegralDomain|)) (OR (|and| (|has| |#1| (|Ring|)) (|has| |#1| (|LinearlyExplicitRingOver| (|Integer|)))) (|has| |#1| (|Ring|)) (|has| |#1| (|Group|)))) (|has| |#1| (|Ring|)) (|has| |#1| (|Group|))) (|leftUnitary| |has| |#1| (|CommutativeRing|)) (|rightUnitary| |has| |#1| (|CommutativeRing|)) ((|commutative| "*") |has| |#1| (|IntegralDomain|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (|IntegralDomain|)) (|canonicalsClosed| |has| |#1| (|IntegralDomain|))) 
((|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|Ring|))) (OR (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Group|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (OR (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (AND (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (OR (|HasCategory| |#1| (QUOTE (|Group|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (OR (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (OR (|HasCategory| |#1| (QUOTE (|Group|))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (OR (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (|HasCategory| |#1| (QUOTE (|AbelianGroup|)))) (|HasCategory| |#1| (QUOTE (|AbelianSemiGroup|))) (OR (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#1| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (|HasCategory| |#1| (QUOTE (|AbelianSemiGroup|)))) (|HasCategory| |#1| (QUOTE (|SemiGroup|))) (OR (|HasCategory| |#1| (QUOTE (|Group|))) (|HasCategory| |#1| (QUOTE (|SemiGroup|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (|HasCategory| |#1| (QUOTE (|SemiGroup|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (|HasCategory| |#1| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#1| (QUOTE (|SemiGroup|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (OR (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))))) (OR (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))))) (|HasCategory| $ (QUOTE (|Ring|))) (|HasCategory| $ (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) 
(|ExpressionSpaceODESolver| R F) 
((|constructor| (NIL "Taylor series solutions of explicit ODE's.")) (|seriesSolve| (((|Any|) |#2| (|BasicOperator|) (|Equation| |#2|) (|List| |#2|)) "\\spad{seriesSolve(eq, \\spad{y,} \\spad{x} = a, [b0,...,bn])} is equivalent to \\spad{seriesSolve(eq = 0, \\spad{y,} \\spad{x} = a, [b0,...,b(n-1)])}.") (((|Any|) |#2| (|BasicOperator|) (|Equation| |#2|) (|Equation| |#2|)) "\\spad{seriesSolve(eq, \\spad{y,} \\spad{x} = a, \\spad{y} a = \\spad{b)}} is equivalent to \\spad{seriesSolve(eq=0, \\spad{y,} x=a, \\spad{y} a = b)}.") (((|Any|) |#2| (|BasicOperator|) (|Equation| |#2|) |#2|) "\\spad{seriesSolve(eq, \\spad{y,} \\spad{x} = a, \\spad{b)}} is equivalent to \\spad{seriesSolve(eq = 0, \\spad{y,} \\spad{x} = a, \\spad{y} a = b)}.") (((|Any|) (|Equation| |#2|) (|BasicOperator|) (|Equation| |#2|) |#2|) "\\spad{seriesSolve(eq,y, x=a, \\spad{b)}} is equivalent to \\spad{seriesSolve(eq, \\spad{y,} x=a, \\spad{y} a = b)}.") (((|Any|) (|List| |#2|) (|List| (|BasicOperator|)) (|Equation| |#2|) (|List| (|Equation| |#2|))) "seriesSolve([eq1,...,eqn], [y1,...,yn], \\spad{x} = \\spad{a,[y1} a = b1,..., \\spad{yn} a = bn]) is equivalent to \\spad{seriesSolve([eq1=0,...,eqn=0], [y1,...,yn], \\spad{x} = a, \\spad{[y1} a = b1,..., \\spad{yn} a = bn])}.") (((|Any|) (|List| |#2|) (|List| (|BasicOperator|)) (|Equation| |#2|) (|List| |#2|)) "\\spad{seriesSolve([eq1,...,eqn], [y1,...,yn], x=a, [b1,...,bn])} is equivalent to \\spad{seriesSolve([eq1=0,...,eqn=0], [y1,...,yn], x=a, [b1,...,bn])}.") (((|Any|) (|List| (|Equation| |#2|)) (|List| (|BasicOperator|)) (|Equation| |#2|) (|List| |#2|)) "\\spad{seriesSolve([eq1,...,eqn], [y1,...,yn], x=a, [b1,...,bn])} is equivalent to \\spad{seriesSolve([eq1,...,eqn], [y1,...,yn], \\spad{x} = a, \\spad{[y1} a = b1,..., \\spad{yn} a = bn])}.") (((|Any|) (|List| (|Equation| |#2|)) (|List| (|BasicOperator|)) (|Equation| |#2|) (|List| (|Equation| |#2|))) "\\spad{seriesSolve([eq1,...,eqn],[y1,...,yn],x = \\spad{a,[y1} a = b1,...,yn a = bn])} returns a taylor series solution of \\spad{[eq1,...,eqn]} around \\spad{x = a} with initial conditions \\spad{yi(a) = bi}. Note that eqi must be of the form \\spad{fi(x, \\spad{y1} \\spad{x,} \\spad{y2} x,..., \\spad{yn} \\spad{x)} y1'(x) + gi(x, \\spad{y1} \\spad{x,} \\spad{y2} x,..., \\spad{yn} \\spad{x)} = h(x, \\spad{y1} \\spad{x,} \\spad{y2} x,..., \\spad{yn} x)}.") (((|Any|) (|Equation| |#2|) (|BasicOperator|) (|Equation| |#2|) (|List| |#2|)) "\\spad{seriesSolve(eq,y,x=a,[b0,...,b(n-1)])} returns a Taylor series solution of \\spad{eq} around \\spad{x = a} with initial conditions \\spad{y(a) = b0}, \\spad{y'(a) = b1}, \\spad{y''(a) = b2}, ...,\\spad{y(n-1)(a) = b(n-1)} \\spad{eq} must be of the form \\spad{f(x, \\spad{y} \\spad{x,} y'(x),..., y(n-1)(x)) y(n)(x) + g(x,y x,y'(x),...,y(n-1)(x)) = h(x,y \\spad{x,} y'(x),..., y(n-1)(x))}.") (((|Any|) (|Equation| |#2|) (|BasicOperator|) (|Equation| |#2|) (|Equation| |#2|)) "\\spad{seriesSolve(eq,y,x=a, \\spad{y} a = \\spad{b)}} returns a Taylor series solution of \\spad{eq} around \\spad{x} = a with initial condition \\spad{y(a) = \\spad{b}.} Note that \\spad{eq} must be of the form \\spad{f(x, \\spad{y} \\spad{x)} y'(x) + g(x, \\spad{y} \\spad{x)} = h(x, \\spad{y} x)}."))) 
NIL 
NIL 
(|ExpressionSolve| R F UTSF UTSSUPF) 
((|constructor| (NIL "This package has no description"))) 
NIL 
NIL 
(|ExpressionTubePlot|) 
((|constructor| (NIL "Package for constructing tubes around 3-dimensional parametric curves.")) (|tubePlot| (((|TubePlot| (|Plot3D|)) (|Expression| (|Integer|)) (|Expression| (|Integer|)) (|Expression| (|Integer|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|) (|String|)) "\\spad{tubePlot(f,g,h,colorFcn,a..b,r,n,s)} puts a tube of radius \\spad{r} with \\spad{n} points on each circle about the curve \\spad{x = f(t)}, \\spad{y = g(t)}, \\spad{z = h(t)} for \\spad{t} in \\spad{[a,b]}. If \\spad{s} = \"closed\", the tube is considered to be closed; if \\spad{s} = \"open\", the tube is considered to be open.") (((|TubePlot| (|Plot3D|)) (|Expression| (|Integer|)) (|Expression| (|Integer|)) (|Expression| (|Integer|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|)) "\\spad{tubePlot(f,g,h,colorFcn,a..b,r,n)} puts a tube of radius \\spad{r} with \\spad{n} points on each circle about the curve \\spad{x = f(t)}, \\spad{y = g(t)}, \\spad{z = h(t)} for \\spad{t} in \\spad{[a,b]}. The tube is considered to be open.") (((|TubePlot| (|Plot3D|)) (|Expression| (|Integer|)) (|Expression| (|Integer|)) (|Expression| (|Integer|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Integer|) (|String|)) "\\spad{tubePlot(f,g,h,colorFcn,a..b,r,n,s)} puts a tube of radius \\spad{r(t)} with \\spad{n} points on each circle about the curve \\spad{x = f(t)}, \\spad{y = g(t)}, \\spad{z = h(t)} for \\spad{t} in \\spad{[a,b]}. If \\spad{s} = \"closed\", the tube is considered to be closed; if \\spad{s} = \"open\", the tube is considered to be open.") (((|TubePlot| (|Plot3D|)) (|Expression| (|Integer|)) (|Expression| (|Integer|)) (|Expression| (|Integer|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Integer|)) "\\spad{tubePlot(f,g,h,colorFcn,a..b,r,n)} puts a tube of radius r(t) with \\spad{n} points on each circle about the curve \\spad{x = f(t)}, \\spad{y = g(t)}, \\spad{z = h(t)} for \\spad{t} in \\spad{[a,b]}. The tube is considered to be open.")) (|constantToUnaryFunction| (((|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|DoubleFloat|)) "\\spad{constantToUnaryFunction(s)} is a local function which takes the value of \\spad{s,} which may be a function of a constant, and returns a function which always returns the value \\spadtype{DoubleFloat} \\spad{s.}"))) 
NIL 
NIL 
(|ExponentialOfUnivariatePuiseuxSeries| FE |var| |cen|) 
((|constructor| (NIL "ExponentialOfUnivariatePuiseuxSeries is a domain used to represent essential singularities of functions. An object in this domain is a function of the form \\spad{exp(f(x))}, where \\spad{f(x)} is a Puiseux series with no terms of non-negative degree. Objects are ordered according to order of singularity, with functions which tend more rapidly to zero or infinity considered to be larger. Thus, if \\spad{order(f(x)) < order(g(x))}, \\spadignore{i.e.} the first non-zero term of \\spad{f(x)} has lower degree than the first non-zero term of \\spad{g(x)}, then \\spad{exp(f(x)) > exp(g(x))}. If \\spad{order(f(x)) = order(g(x))}, then the ordering is essentially random. This domain is used in computing limits involving functions with essential singularities.")) (|exponentialOrder| (((|Fraction| (|Integer|)) $) "\\spad{exponentialOrder(exp(c * \\spad{x} **(-n) + ...))} returns \\spad{-n}. exponentialOrder(0) returns \\spad{0}.")) (|exponent| (((|UnivariatePuiseuxSeries| |#1| |#2| |#3|) $) "\\spad{exponent(exp(f(x)))} returns \\spad{f(x)}")) (|exponential| (($ (|UnivariatePuiseuxSeries| |#1| |#2| |#3|)) "\\spad{exponential(f(x))} returns \\spad{exp(f(x))}. Note: the function does NOT check that \\spad{f(x)} has no non-negative terms."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))) (|devaluate| |#1|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))) (|devaluate| |#1|))))) (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|SemiGroup|))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|)))))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |AlgebraicallyClosedFunctionSpace|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|PrimitiveFunctionCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |integrate|) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Symbol|))))) (|HasSignature| |#1| (LIST (QUOTE |variables|) (LIST (LIST (QUOTE |List|) (QUOTE (|Symbol|))) (|devaluate| |#1|))))))) 
(|FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber| K) 
((|constructor| (NIL "Part of the Package for Algebraic Function Fields in one variable PAFF"))) 
NIL 
NIL 
(|FactoredFunctions| M) 
((|constructor| (NIL "computes various functions on factored arguments.")) (|log| (((|List| (|Record| (|:| |coef| (|NonNegativeInteger|)) (|:| |logand| |#1|))) (|Factored| |#1|)) "\\spad{log(f)} returns \\spad{[(a1,b1),...,(am,bm)]} such that the logarithm of \\spad{f} is equal to \\spad{a1*log(b1) + \\spad{...} + am*log(bm)}.")) (|nthRoot| (((|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |coef| |#1|) (|:| |radicand| (|List| |#1|))) (|Factored| |#1|) (|NonNegativeInteger|)) "\\spad{nthRoot(f, \\spad{n)}} returns \\spad{(p, \\spad{r,} [r1,...,rm])} such that the nth-root of \\spad{f} is equal to \\spad{r * \\spad{pth-root(r1} * \\spad{...} * rm)}, where r1,...,rm are distinct factors of \\spad{f,} each of which has an exponent smaller than \\spad{p} in \\spad{f.}"))) 
NIL 
NIL 
(|FactorisationOverPseudoAlgebraicClosureOfRationalNumber| K) 
((|constructor| (NIL "Part of the Package for Algebraic Function Fields in one variable PAFF"))) 
NIL 
NIL 
(|FactoringUtilities| E OV R P) 
((|constructor| (NIL "This package provides utilities used by the factorizers which operate on polynomials represented as univariate polynomials with multivariate coefficients.")) (|ran| ((|#3| (|Integer|)) "\\spad{ran(k)} computes a random integer between \\spad{-k} and \\spad{k} as a member of \\spad{R.}")) (|normalDeriv| (((|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#4|) (|Integer|)) "\\spad{normalDeriv(poly,i)} computes the \\spad{i}th derivative of \\spad{poly} divided by i!.")) (|raisePolynomial| (((|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#3|)) "\\spad{raisePolynomial(rpoly)} converts \\spad{rpoly} from a univariate polynomial over \\spad{r} to be a univariate polynomial with polynomial coefficients.")) (|lowerPolynomial| (((|SparseUnivariatePolynomial| |#3|) (|SparseUnivariatePolynomial| |#4|)) "\\spad{lowerPolynomial(upoly)} converts \\spad{upoly} to be a univariate polynomial over \\spad{R.} An error if the coefficients contain variables.")) (|variables| (((|List| |#2|) (|SparseUnivariatePolynomial| |#4|)) "\\spad{variables(upoly)} returns the list of variables for the coefficients of upoly.")) (|degree| (((|List| (|NonNegativeInteger|)) (|SparseUnivariatePolynomial| |#4|) (|List| |#2|)) "\\spad{degree(upoly, lvar)} returns a list containing the maximum degree for each variable in lvar.")) (|completeEval| (((|SparseUnivariatePolynomial| |#3|) (|SparseUnivariatePolynomial| |#4|) (|List| |#2|) (|List| |#3|)) "\\spad{completeEval(upoly, lvar, lval)} evaluates the polynomial \\spad{upoly} with each variable in \\spad{lvar} replaced by the corresponding value in lval. Substitutions are done for all variables in \\spad{upoly} producing a univariate polynomial over \\spad{R.}"))) 
NIL 
NIL 
(|FreeAbelianGroup| S) 
((|constructor| (NIL "Free abelian group on any set of generators The free abelian group on a set \\spad{S} is the monoid of finite sums of the form \\spad{reduce(+,[ni * si])} where the si's are in \\spad{S,} and the ni's are integers. The operation is commutative."))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedAbelianMonoid|)))) 
(|FreeAbelianMonoidCategory| S E) 
((|constructor| (NIL "A free abelian monoid on a set \\spad{S} is the monoid of finite sums of the form \\spad{reduce(+,[ni * si])} where the si's are in \\spad{S,} and the ni's are in a given abelian monoid. The operation is commutative.")) (|highCommonTerms| (($ $ $) "\\spad{highCommonTerms(e1 \\spad{a1} + \\spad{...} + en an, \\spad{f1} \\spad{b1} + \\spad{...} + \\spad{fm} bm)} returns \\spad{reduce(+,[max(ei, fi) ci])} where \\spad{ci} ranges in the intersection of \\spad{{a1,...,an}} and \\spad{{b1,...,bm}}.")) (|mapGen| (($ (|Mapping| |#1| |#1|) $) "\\spad{mapGen(f, \\spad{e1} \\spad{a1} +...+ en an)} returns \\spad{e1 f(a1) +...+ en f(an)}.")) (|mapCoef| (($ (|Mapping| |#2| |#2|) $) "\\spad{mapCoef(f, \\spad{e1} \\spad{a1} +...+ en an)} returns \\spad{f(e1) \\spad{a1} +...+ f(en) an}.")) (|coefficient| ((|#2| |#1| $) "\\spad{coefficient(s, \\spad{e1} \\spad{a1} + \\spad{...} + en an)} returns \\spad{ei} such that \\spad{ai} = \\spad{s,} or 0 if \\spad{s} is not one of the ai's.")) (|nthFactor| ((|#1| $ (|Integer|)) "\\spad{nthFactor(x, \\spad{n)}} returns the factor of the n^th term of \\spad{x.}")) (|nthCoef| ((|#2| $ (|Integer|)) "\\spad{nthCoef(x, \\spad{n)}} returns the coefficient of the n^th term of \\spad{x.}")) (|terms| (((|List| (|Record| (|:| |gen| |#1|) (|:| |exp| |#2|))) $) "\\spad{terms(e1 \\spad{a1} + \\spad{...} + en an)} returns \\spad{[[a1, e1],...,[an, en]]}.")) (|size| (((|NonNegativeInteger|) $) "\\indented{1}{size(x) returns the number of terms in \\spad{x.}} \\indented{1}{mapGen(f, \\spad{a1\\^e1} \\spad{...} an\\^en) returns} \\spad{f(a1)\\^e1 \\spad{...} f(an)\\^en}.")) (* (($ |#2| |#1|) "\\spad{e * \\spad{s}} returns \\spad{e} times \\spad{s.}")) (+ (($ |#1| $) "\\spad{s + \\spad{x}} returns the sum of \\spad{s} and \\spad{x.}"))) 
NIL 
NIL 
(|FreeAbelianMonoid| S) 
((|constructor| (NIL "Free abelian monoid on any set of generators The free abelian monoid on a set \\spad{S} is the monoid of finite sums of the form \\spad{reduce(+,[ni * si])} where the si's are in \\spad{S,} and the ni's are non-negative integers. The operation is commutative."))) 
NIL 
((|HasCategory| (|NonNegativeInteger|) (QUOTE (|OrderedAbelianMonoid|)))) 
(|FiniteAbelianMonoidRingFunctions2| E R1 A1 R2 A2) 
((|constructor| (NIL "This package provides a mapping function for \\spadtype{FiniteAbelianMonoidRing} The packages defined in this file provide fast fraction free rational interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)")) (|map| ((|#5| (|Mapping| |#4| |#2|) |#3|) "\\spad{map}(f, a) applies the map \\spad{f} to each coefficient in a. It is assumed that \\spad{f} maps 0 to 0"))) 
NIL 
NIL 
(|FiniteAbelianMonoidRing&| S R E) 
((|constructor| (NIL "This category is similar to AbelianMonoidRing, except that the sum is assumed to be finite. It is a useful model for polynomials, but is somewhat more general.")) (|primitivePart| (($ $) "\\spad{primitivePart(p)} returns the unit normalized form of polynomial \\spad{p} divided by the content of \\spad{p.}")) (|content| ((|#2| $) "\\spad{content(p)} gives the \\spad{gcd} of the coefficients of polynomial \\spad{p.}")) (|exquo| (((|Union| $ "failed") $ |#2|) "\\spad{exquo(p,r)} returns the exact quotient of polynomial \\spad{p} by \\spad{r,} or \"failed\" if none exists.")) (|binomThmExpt| (($ $ $ (|NonNegativeInteger|)) "\\spad{binomThmExpt(p,q,n)} returns \\spad{(x+y)^n} by means of the binomial theorem trick.")) (|pomopo!| (($ $ |#2| |#3| $) "\\spad{pomopo!(p1,r,e,p2)} returns \\spad{p1 + monomial(e,r) * \\spad{p2}} and may use \\spad{p1} as workspace. The constaant \\spad{r} is assumed to be nonzero.")) (|mapExponents| (($ (|Mapping| |#3| |#3|) $) "\\spad{mapExponents(fn,u)} maps function \\spad{fn} onto the exponents of the non-zero monomials of polynomial u.")) (|minimumDegree| ((|#3| $) "\\spad{minimumDegree(p)} gives the least exponent of a non-zero term of polynomial \\spad{p.} Error: if applied to 0.")) (|numberOfMonomials| (((|NonNegativeInteger|) $) "\\spad{numberOfMonomials(p)} gives the number of non-zero monomials in polynomial \\spad{p.}")) (|coefficients| (((|List| |#2|) $) "\\spad{coefficients(p)} gives the list of non-zero coefficients of polynomial \\spad{p.}")) (|ground| ((|#2| $) "\\spad{ground(p)} retracts polynomial \\spad{p} to the coefficient ring.")) (|ground?| (((|Boolean|) $) "\\spad{ground?(p)} tests if polynomial \\spad{p} is a member of the coefficient ring."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) 
(|FiniteAbelianMonoidRing| R E) 
((|constructor| (NIL "This category is similar to AbelianMonoidRing, except that the sum is assumed to be finite. It is a useful model for polynomials, but is somewhat more general.")) (|primitivePart| (($ $) "\\spad{primitivePart(p)} returns the unit normalized form of polynomial \\spad{p} divided by the content of \\spad{p.}")) (|content| ((|#1| $) "\\spad{content(p)} gives the \\spad{gcd} of the coefficients of polynomial \\spad{p.}")) (|exquo| (((|Union| $ "failed") $ |#1|) "\\spad{exquo(p,r)} returns the exact quotient of polynomial \\spad{p} by \\spad{r,} or \"failed\" if none exists.")) (|binomThmExpt| (($ $ $ (|NonNegativeInteger|)) "\\spad{binomThmExpt(p,q,n)} returns \\spad{(x+y)^n} by means of the binomial theorem trick.")) (|pomopo!| (($ $ |#1| |#2| $) "\\spad{pomopo!(p1,r,e,p2)} returns \\spad{p1 + monomial(e,r) * \\spad{p2}} and may use \\spad{p1} as workspace. The constaant \\spad{r} is assumed to be nonzero.")) (|mapExponents| (($ (|Mapping| |#2| |#2|) $) "\\spad{mapExponents(fn,u)} maps function \\spad{fn} onto the exponents of the non-zero monomials of polynomial u.")) (|minimumDegree| ((|#2| $) "\\spad{minimumDegree(p)} gives the least exponent of a non-zero term of polynomial \\spad{p.} Error: if applied to 0.")) (|numberOfMonomials| (((|NonNegativeInteger|) $) "\\spad{numberOfMonomials(p)} gives the number of non-zero monomials in polynomial \\spad{p.}")) (|coefficients| (((|List| |#1|) $) "\\spad{coefficients(p)} gives the list of non-zero coefficients of polynomial \\spad{p.}")) (|ground| ((|#1| $) "\\spad{ground(p)} retracts polynomial \\spad{p} to the coefficient ring.")) (|ground?| (((|Boolean|) $) "\\spad{ground?(p)} tests if polynomial \\spad{p} is a member of the coefficient ring."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|FlexibleArray| S) 
((|constructor| (NIL "A FlexibleArray is the notion of an array intended to allow for growth at the end only. Hence the following efficient operations \\spad{append(x,a)} meaning append item \\spad{x} at the end of the array \\spad{a} \\spad{delete(a,n)} meaning delete the last item from the array \\spad{a} Flexible arrays support the other operations inherited from \\spadtype{ExtensibleLinearAggregate}. However, these are not efficient. Flexible arrays combine the \\spad{O(1)} access time property of arrays with growing and shrinking at the end in \\spad{O(1)} (average) time. This is done by using an ordinary array which may have zero or more empty slots at the end. When the array becomes full it is copied into a new larger (50% larger) array. Conversely, when the array becomes less than 1/2 full, it is copied into a smaller array. Flexible arrays provide for an efficient implementation of many data structures in particular heaps, stacks and sets."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|FiniteAlgebraicExtensionField&| S F) 
((|constructor| (NIL "FiniteAlgebraicExtensionField \\spad{F} is the category of fields which are finite algebraic extensions of the field \\spad{F.} If \\spad{F} is finite then any finite algebraic extension of \\spad{F} is finite, too. Let \\spad{K} be a finite algebraic extension of the finite field \\spad{F.} The exponentiation of elements of \\spad{K} defines a Z-module structure on the multiplicative group of \\spad{K.} The additive group of \\spad{K} becomes a module over the ring of polynomials over \\spad{F} via the operation \\spadfun{linearAssociatedExp}(a:K,f:SparseUnivariatePolynomial \\spad{F)} which is linear over \\spad{F,} that is, for elements a from \\spad{K,} \\spad{c,d} from \\spad{F} and \\spad{f,g} univariate polynomials over \\spad{F} we have \\spadfun{linearAssociatedExp}(a,cf+dg) equals \\spad{c} times \\spadfun{linearAssociatedExp}(a,f) plus \\spad{d} times \\spadfun{linearAssociatedExp}(a,g). Therefore \\spadfun{linearAssociatedExp} is defined completely by its action on monomials from F[X]: \\spadfun{linearAssociatedExp}(a,monomial(1,k)\\$SUP(F)) is defined to be \\spadfun{Frobenius}(a,k) which is a**(q**k) where q=size()\\$F. The operations order and discreteLog associated with the multiplicative exponentiation have additive analogues associated to the operation \\spadfun{linearAssociatedExp}. These are the functions \\spadfun{linearAssociatedOrder} and \\spadfun{linearAssociatedLog}, respectively.")) (|linearAssociatedLog| (((|Union| (|SparseUnivariatePolynomial| |#2|) "failed") $ $) "\\spad{linearAssociatedLog(b,a)} returns a polynomial \\spad{g,} such that the \\spadfun{linearAssociatedExp}(b,g) equals a. If there is no such polynomial \\spad{g,} then \\spadfun{linearAssociatedLog} fails.") (((|SparseUnivariatePolynomial| |#2|) $) "\\spad{linearAssociatedLog(a)} returns a polynomial \\spad{g,} such that \\spadfun{linearAssociatedExp}(normalElement(),g) equals a.")) (|linearAssociatedOrder| (((|SparseUnivariatePolynomial| |#2|) $) "\\spad{linearAssociatedOrder(a)} retruns the monic polynomial \\spad{g} of least degree, such that \\spadfun{linearAssociatedExp}(a,g) is 0.")) (|linearAssociatedExp| (($ $ (|SparseUnivariatePolynomial| |#2|)) "\\spad{linearAssociatedExp(a,f)} is linear over \\spad{F,} that is, for elements a from \\spad{\\$,} \\spad{c,d} form \\spad{F} and \\spad{f,g} univariate polynomials over \\spad{F} we have \\spadfun{linearAssociatedExp}(a,cf+dg) equals \\spad{c} times \\spadfun{linearAssociatedExp}(a,f) plus \\spad{d} times \\spadfun{linearAssociatedExp}(a,g). Therefore \\spadfun{linearAssociatedExp} is defined completely by its action on monomials from F[X]: \\spadfun{linearAssociatedExp}(a,monomial(1,k)\\$SUP(F)) is defined to be \\spadfun{Frobenius}(a,k) which is a**(q**k), where q=size()\\$F.")) (|generator| (($) "\\spad{generator()} returns a root of the defining polynomial. This element generates the field as an algebra over the ground field.")) (|normal?| (((|Boolean|) $) "\\spad{normal?(a)} tests whether the element \\spad{a} is normal over the ground field \\spad{F,} that is, \\spad{a**(q**i), 0 \\spad{<=} \\spad{i} \\spad{<=} extensionDegree()-1} is an F-basis, where \\spad{q = size()\\$F}. Implementation according to Lidl/Niederreiter: Theorem 2.39.")) (|normalElement| (($) "\\spad{normalElement()} returns a element, normal over the ground field \\spad{F,} thus \\spad{a**(q**i), 0 \\spad{<=} \\spad{i} < extensionDegree()} is an F-basis, where \\spad{q = size()\\$F}. At the first call, the element is computed by \\spadfunFrom{createNormalElement}{FiniteAlgebraicExtensionField} then cached in a global variable. On subsequent calls, the element is retrieved by referencing the global variable.")) (|createNormalElement| (($) "\\spad{createNormalElement()} computes a normal element over the ground field \\spad{F,} that is, \\spad{a**(q**i), 0 \\spad{<=} \\spad{i} < extensionDegree()} is an F-basis, where \\spad{q = size()\\$F}. Reference: Such an element exists Lidl/Niederreiter: Theorem 2.35.")) (|trace| (($ $ (|PositiveInteger|)) "\\spad{trace(a,d)} computes the trace of \\spad{a} with respect to the field of extension degree \\spad{d} over the ground field of size \\spad{q.} Error: if \\spad{d} does not divide the extension degree of \\spad{a}. Note that \\spad{trace(a,d)=reduce(+,[a**(q**(d*i)) for \\spad{i} in 0..n/d])}.") ((|#2| $) "\\spad{trace(a)} computes the trace of \\spad{a} with respect to the field considered as an algebra with 1 over the ground field \\spad{F.}")) (|norm| (($ $ (|PositiveInteger|)) "\\spad{norm(a,d)} computes the norm of \\spad{a} with respect to the field of extension degree \\spad{d} over the ground field of size. Error: if \\spad{d} does not divide the extension degree of \\spad{a}. Note that norm(a,d) = reduce(*,[a**(q**(d*i)) for \\spad{i} in 0..n/d])") ((|#2| $) "\\spad{norm(a)} computes the norm of \\spad{a} with respect to the field considered as an algebra with 1 over the ground field \\spad{F.}")) (|degree| (((|PositiveInteger|) $) "\\spad{degree(a)} returns the degree of the minimal polynomial of an element \\spad{a} over the ground field \\spad{F.}")) (|extensionDegree| (((|PositiveInteger|)) "\\spad{extensionDegree()} returns the degree of field extension.")) (|definingPolynomial| (((|SparseUnivariatePolynomial| |#2|)) "\\spad{definingPolynomial()} returns the polynomial used to define the field extension.")) (|minimalPolynomial| (((|SparseUnivariatePolynomial| $) $ (|PositiveInteger|)) "\\spad{minimalPolynomial(x,n)} computes the minimal polynomial of \\spad{x} over the field of extension degree \\spad{n} over the ground field \\spad{F.}") (((|SparseUnivariatePolynomial| |#2|) $) "\\spad{minimalPolynomial(a)} returns the minimal polynomial of an element \\spad{a} over the ground field \\spad{F.}")) (|represents| (($ (|Vector| |#2|)) "\\spad{represents([a1,..,an])} returns \\spad{a1*v1 + \\spad{...} + an*vn}, where v1,...,vn are the elements of the fixed basis.")) (|coordinates| (((|Matrix| |#2|) (|Vector| $)) "\\spad{coordinates([v1,...,vm])} returns the coordinates of the vi's with to the fixed basis. The coordinates of \\spad{vi} are contained in the \\spad{i}th row of the matrix returned by this function.") (((|Vector| |#2|) $) "\\spad{coordinates(a)} returns the coordinates of \\spad{a} with respect to the fixed \\spad{F}-vectorspace basis.")) (|basis| (((|Vector| $) (|PositiveInteger|)) "\\spad{basis(n)} returns a fixed basis of a subfield of \\spad{\\$} as \\spad{F}-vectorspace.") (((|Vector| $)) "\\spad{basis()} returns a fixed basis of \\spad{\\$} as \\spad{F}-vectorspace."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|Finite|)))) 
(|FiniteAlgebraicExtensionField| F) 
((|constructor| (NIL "FiniteAlgebraicExtensionField \\spad{F} is the category of fields which are finite algebraic extensions of the field \\spad{F.} If \\spad{F} is finite then any finite algebraic extension of \\spad{F} is finite, too. Let \\spad{K} be a finite algebraic extension of the finite field \\spad{F.} The exponentiation of elements of \\spad{K} defines a Z-module structure on the multiplicative group of \\spad{K.} The additive group of \\spad{K} becomes a module over the ring of polynomials over \\spad{F} via the operation \\spadfun{linearAssociatedExp}(a:K,f:SparseUnivariatePolynomial \\spad{F)} which is linear over \\spad{F,} that is, for elements a from \\spad{K,} \\spad{c,d} from \\spad{F} and \\spad{f,g} univariate polynomials over \\spad{F} we have \\spadfun{linearAssociatedExp}(a,cf+dg) equals \\spad{c} times \\spadfun{linearAssociatedExp}(a,f) plus \\spad{d} times \\spadfun{linearAssociatedExp}(a,g). Therefore \\spadfun{linearAssociatedExp} is defined completely by its action on monomials from F[X]: \\spadfun{linearAssociatedExp}(a,monomial(1,k)\\$SUP(F)) is defined to be \\spadfun{Frobenius}(a,k) which is a**(q**k) where q=size()\\$F. The operations order and discreteLog associated with the multiplicative exponentiation have additive analogues associated to the operation \\spadfun{linearAssociatedExp}. These are the functions \\spadfun{linearAssociatedOrder} and \\spadfun{linearAssociatedLog}, respectively.")) (|linearAssociatedLog| (((|Union| (|SparseUnivariatePolynomial| |#1|) "failed") $ $) "\\spad{linearAssociatedLog(b,a)} returns a polynomial \\spad{g,} such that the \\spadfun{linearAssociatedExp}(b,g) equals a. If there is no such polynomial \\spad{g,} then \\spadfun{linearAssociatedLog} fails.") (((|SparseUnivariatePolynomial| |#1|) $) "\\spad{linearAssociatedLog(a)} returns a polynomial \\spad{g,} such that \\spadfun{linearAssociatedExp}(normalElement(),g) equals a.")) (|linearAssociatedOrder| (((|SparseUnivariatePolynomial| |#1|) $) "\\spad{linearAssociatedOrder(a)} retruns the monic polynomial \\spad{g} of least degree, such that \\spadfun{linearAssociatedExp}(a,g) is 0.")) (|linearAssociatedExp| (($ $ (|SparseUnivariatePolynomial| |#1|)) "\\spad{linearAssociatedExp(a,f)} is linear over \\spad{F,} that is, for elements a from \\spad{\\$,} \\spad{c,d} form \\spad{F} and \\spad{f,g} univariate polynomials over \\spad{F} we have \\spadfun{linearAssociatedExp}(a,cf+dg) equals \\spad{c} times \\spadfun{linearAssociatedExp}(a,f) plus \\spad{d} times \\spadfun{linearAssociatedExp}(a,g). Therefore \\spadfun{linearAssociatedExp} is defined completely by its action on monomials from F[X]: \\spadfun{linearAssociatedExp}(a,monomial(1,k)\\$SUP(F)) is defined to be \\spadfun{Frobenius}(a,k) which is a**(q**k), where q=size()\\$F.")) (|generator| (($) "\\spad{generator()} returns a root of the defining polynomial. This element generates the field as an algebra over the ground field.")) (|normal?| (((|Boolean|) $) "\\spad{normal?(a)} tests whether the element \\spad{a} is normal over the ground field \\spad{F,} that is, \\spad{a**(q**i), 0 \\spad{<=} \\spad{i} \\spad{<=} extensionDegree()-1} is an F-basis, where \\spad{q = size()\\$F}. Implementation according to Lidl/Niederreiter: Theorem 2.39.")) (|normalElement| (($) "\\spad{normalElement()} returns a element, normal over the ground field \\spad{F,} thus \\spad{a**(q**i), 0 \\spad{<=} \\spad{i} < extensionDegree()} is an F-basis, where \\spad{q = size()\\$F}. At the first call, the element is computed by \\spadfunFrom{createNormalElement}{FiniteAlgebraicExtensionField} then cached in a global variable. On subsequent calls, the element is retrieved by referencing the global variable.")) (|createNormalElement| (($) "\\spad{createNormalElement()} computes a normal element over the ground field \\spad{F,} that is, \\spad{a**(q**i), 0 \\spad{<=} \\spad{i} < extensionDegree()} is an F-basis, where \\spad{q = size()\\$F}. Reference: Such an element exists Lidl/Niederreiter: Theorem 2.35.")) (|trace| (($ $ (|PositiveInteger|)) "\\spad{trace(a,d)} computes the trace of \\spad{a} with respect to the field of extension degree \\spad{d} over the ground field of size \\spad{q.} Error: if \\spad{d} does not divide the extension degree of \\spad{a}. Note that \\spad{trace(a,d)=reduce(+,[a**(q**(d*i)) for \\spad{i} in 0..n/d])}.") ((|#1| $) "\\spad{trace(a)} computes the trace of \\spad{a} with respect to the field considered as an algebra with 1 over the ground field \\spad{F.}")) (|norm| (($ $ (|PositiveInteger|)) "\\spad{norm(a,d)} computes the norm of \\spad{a} with respect to the field of extension degree \\spad{d} over the ground field of size. Error: if \\spad{d} does not divide the extension degree of \\spad{a}. Note that norm(a,d) = reduce(*,[a**(q**(d*i)) for \\spad{i} in 0..n/d])") ((|#1| $) "\\spad{norm(a)} computes the norm of \\spad{a} with respect to the field considered as an algebra with 1 over the ground field \\spad{F.}")) (|degree| (((|PositiveInteger|) $) "\\spad{degree(a)} returns the degree of the minimal polynomial of an element \\spad{a} over the ground field \\spad{F.}")) (|extensionDegree| (((|PositiveInteger|)) "\\spad{extensionDegree()} returns the degree of field extension.")) (|definingPolynomial| (((|SparseUnivariatePolynomial| |#1|)) "\\spad{definingPolynomial()} returns the polynomial used to define the field extension.")) (|minimalPolynomial| (((|SparseUnivariatePolynomial| $) $ (|PositiveInteger|)) "\\spad{minimalPolynomial(x,n)} computes the minimal polynomial of \\spad{x} over the field of extension degree \\spad{n} over the ground field \\spad{F.}") (((|SparseUnivariatePolynomial| |#1|) $) "\\spad{minimalPolynomial(a)} returns the minimal polynomial of an element \\spad{a} over the ground field \\spad{F.}")) (|represents| (($ (|Vector| |#1|)) "\\spad{represents([a1,..,an])} returns \\spad{a1*v1 + \\spad{...} + an*vn}, where v1,...,vn are the elements of the fixed basis.")) (|coordinates| (((|Matrix| |#1|) (|Vector| $)) "\\spad{coordinates([v1,...,vm])} returns the coordinates of the vi's with to the fixed basis. The coordinates of \\spad{vi} are contained in the \\spad{i}th row of the matrix returned by this function.") (((|Vector| |#1|) $) "\\spad{coordinates(a)} returns the coordinates of \\spad{a} with respect to the fixed \\spad{F}-vectorspace basis.")) (|basis| (((|Vector| $) (|PositiveInteger|)) "\\spad{basis(n)} returns a fixed basis of a subfield of \\spad{\\$} as \\spad{F}-vectorspace.") (((|Vector| $)) "\\spad{basis()} returns a fixed basis of \\spad{\\$} as \\spad{F}-vectorspace."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|FortranCode|) 
((|constructor| (NIL "This domain builds representations of program code segments for use with the FortranProgram domain.")) (|setLabelValue| (((|SingleInteger|) (|SingleInteger|)) "\\spad{setLabelValue(i)} resets the counter which produces labels to \\spad{i}")) (|getCode| (((|SExpression|) $) "\\spad{getCode(f)} returns a Lisp list of strings representing \\spad{f} in Fortran notation. This is used by the FortranProgram domain.")) (|printCode| (((|Void|) $) "\\spad{printCode(f)} prints out \\spad{f} in FORTRAN notation.")) (|code| (((|Union| (|:| |nullBranch| "null") (|:| |assignmentBranch| (|Record| (|:| |var| (|Symbol|)) (|:| |arrayIndex| (|List| (|Polynomial| (|Integer|)))) (|:| |rand| (|Record| (|:| |ints2Floats?| (|Boolean|)) (|:| |expr| (|OutputForm|)))))) (|:| |arrayAssignmentBranch| (|Record| (|:| |var| (|Symbol|)) (|:| |rand| (|OutputForm|)) (|:| |ints2Floats?| (|Boolean|)))) (|:| |conditionalBranch| (|Record| (|:| |switch| (|Switch|)) (|:| |thenClause| $) (|:| |elseClause| $))) (|:| |returnBranch| (|Record| (|:| |empty?| (|Boolean|)) (|:| |value| (|Record| (|:| |ints2Floats?| (|Boolean|)) (|:| |expr| (|OutputForm|)))))) (|:| |blockBranch| (|List| $)) (|:| |commentBranch| (|List| (|String|))) (|:| |callBranch| (|String|)) (|:| |forBranch| (|Record| (|:| |range| (|SegmentBinding| (|Polynomial| (|Integer|)))) (|:| |span| (|Polynomial| (|Integer|))) (|:| |body| $))) (|:| |labelBranch| (|SingleInteger|)) (|:| |loopBranch| (|Record| (|:| |switch| (|Switch|)) (|:| |body| $))) (|:| |commonBranch| (|Record| (|:| |name| (|Symbol|)) (|:| |contents| (|List| (|Symbol|))))) (|:| |printBranch| (|List| (|OutputForm|)))) $) "\\spad{code(f)} returns the internal representation of the object represented by \\spad{f}.")) (|operation| (((|Union| (|:| |Null| "null") (|:| |Assignment| "assignment") (|:| |Conditional| "conditional") (|:| |Return| "return") (|:| |Block| "block") (|:| |Comment| "comment") (|:| |Call| "call") (|:| |For| "for") (|:| |While| "while") (|:| |Repeat| "repeat") (|:| |Goto| "goto") (|:| |Continue| "continue") (|:| |ArrayAssignment| "arrayAssignment") (|:| |Save| "save") (|:| |Stop| "stop") (|:| |Common| "common") (|:| |Print| "print")) $) "\\spad{operation(f)} returns the name of the operation represented by \\spad{f}.")) (|common| (($ (|Symbol|) (|List| (|Symbol|))) "\\spad{common(name,contents)} creates a representation a named common block.")) (|printStatement| (($ (|List| (|OutputForm|))) "\\spad{printStatement(l)} creates a representation of a PRINT statement.")) (|save| (($) "\\spad{save()} creates a representation of a SAVE statement.")) (|stop| (($) "\\spad{stop()} creates a representation of a STOP statement.")) (|block| (($ (|List| $)) "\\spad{block(l)} creates a representation of the statements in \\spad{l} as a block.")) (|assign| (($ (|Symbol|) (|List| (|Polynomial| (|Integer|))) (|Expression| (|Complex| (|Float|)))) "\\spad{assign(x,l,y)} creates a representation of the assignment of \\spad{y} to the \\spad{l}'th element of array \\spad{x} (\\spad{l} is a list of indices).") (($ (|Symbol|) (|List| (|Polynomial| (|Integer|))) (|Expression| (|Float|))) "\\spad{assign(x,l,y)} creates a representation of the assignment of \\spad{y} to the \\spad{l}'th element of array \\spad{x} (\\spad{l} is a list of indices).") (($ (|Symbol|) (|List| (|Polynomial| (|Integer|))) (|Expression| (|Integer|))) "\\spad{assign(x,l,y)} creates a representation of the assignment of \\spad{y} to the \\spad{l}'th element of array \\spad{x} (\\spad{l} is a list of indices).") (($ (|Symbol|) (|Vector| (|Expression| (|Complex| (|Float|))))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Vector| (|Expression| (|Float|)))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Vector| (|Expression| (|Integer|)))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Matrix| (|Expression| (|Complex| (|Float|))))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Matrix| (|Expression| (|Float|)))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Matrix| (|Expression| (|Integer|)))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Expression| (|Complex| (|Float|)))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Expression| (|Float|))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Expression| (|Integer|))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|List| (|Polynomial| (|Integer|))) (|Expression| (|MachineComplex|))) "\\spad{assign(x,l,y)} creates a representation of the assignment of \\spad{y} to the \\spad{l}'th element of array \\spad{x} (\\spad{l} is a list of indices).") (($ (|Symbol|) (|List| (|Polynomial| (|Integer|))) (|Expression| (|MachineFloat|))) "\\spad{assign(x,l,y)} creates a representation of the assignment of \\spad{y} to the \\spad{l}'th element of array \\spad{x} (\\spad{l} is a list of indices).") (($ (|Symbol|) (|List| (|Polynomial| (|Integer|))) (|Expression| (|MachineInteger|))) "\\spad{assign(x,l,y)} creates a representation of the assignment of \\spad{y} to the \\spad{l}'th element of array \\spad{x} (\\spad{l} is a list of indices).") (($ (|Symbol|) (|Vector| (|Expression| (|MachineComplex|)))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Vector| (|Expression| (|MachineFloat|)))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Vector| (|Expression| (|MachineInteger|)))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Matrix| (|Expression| (|MachineComplex|)))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Matrix| (|Expression| (|MachineFloat|)))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Matrix| (|Expression| (|MachineInteger|)))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Vector| (|MachineComplex|))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Vector| (|MachineFloat|))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Vector| (|MachineInteger|))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Matrix| (|MachineComplex|))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Matrix| (|MachineFloat|))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Matrix| (|MachineInteger|))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Expression| (|MachineComplex|))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Expression| (|MachineFloat|))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|Expression| (|MachineInteger|))) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.") (($ (|Symbol|) (|String|)) "\\spad{assign(x,y)} creates a representation of the FORTRAN expression x=y.")) (|cond| (($ (|Switch|) $ $) "\\spad{cond(s,e,f)} creates a representation of the FORTRAN expression IF \\spad{(s)} THEN \\spad{e} ELSE \\spad{f.}") (($ (|Switch|) $) "\\spad{cond(s,e)} creates a representation of the FORTRAN expression IF \\spad{(s)} THEN e.")) (|returns| (($ (|Expression| (|Complex| (|Float|)))) "\\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.") (($ (|Expression| (|Integer|))) "\\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.") (($ (|Expression| (|Float|))) "\\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.") (($ (|Expression| (|MachineComplex|))) "\\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.") (($ (|Expression| (|MachineInteger|))) "\\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.") (($ (|Expression| (|MachineFloat|))) "\\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.") (($) "\\spad{returns()} creates a representation of a FORTRAN RETURN statement.")) (|call| (($ (|String|)) "\\spad{call(s)} creates a representation of a FORTRAN CALL statement")) (|comment| (($ (|List| (|String|))) "\\spad{comment(s)} creates a representation of the Strings \\spad{s} as a multi-line FORTRAN comment.") (($ (|String|)) "\\spad{comment(s)} creates a representation of the String \\spad{s} as a single FORTRAN comment.")) (|continue| (($ (|SingleInteger|)) "\\spad{continue(l)} creates a representation of a FORTRAN CONTINUE labelled with \\spad{l}")) (|goto| (($ (|SingleInteger|)) "\\spad{goto(l)} creates a representation of a FORTRAN GOTO statement")) (|repeatUntilLoop| (($ (|Switch|) $) "\\spad{repeatUntilLoop(s,c)} creates a repeat \\spad{...} until loop in FORTRAN.")) (|whileLoop| (($ (|Switch|) $) "\\spad{whileLoop(s,c)} creates a while loop in FORTRAN.")) (|forLoop| (($ (|SegmentBinding| (|Polynomial| (|Integer|))) (|Polynomial| (|Integer|)) $) "\\spad{forLoop(i=1..10,n,c)} creates a representation of a FORTRAN DO loop with \\spad{i} ranging over the values 1 to 10 by \\spad{n.}") (($ (|SegmentBinding| (|Polynomial| (|Integer|))) $) "\\spad{forLoop(i=1..10,c)} creates a representation of a FORTRAN DO loop with \\spad{i} ranging over the values 1 to 10.")) (|coerce| (((|OutputForm|) $) "\\spad{coerce(f)} returns an object of type OutputForm."))) 
NIL 
NIL 
(|FourierComponent| E) 
((|constructor| (NIL "This domain creates kernels for use in Fourier series")) (|argument| ((|#1| $) "\\spad{argument(x)} returns the argument of a given sin/cos expressions")) (|sin?| (((|Boolean|) $) "\\spad{sin?(x)} returns \\spad{true} if term is a sin, otherwise \\spad{false}")) (|cos| (($ |#1|) "\\spad{cos(x)} makes a cos kernel for use in Fourier series")) (|sin| (($ |#1|) "\\spad{sin(x)} makes a sin kernel for use in Fourier series"))) 
NIL 
NIL 
(|FortranCodePackage1|) 
((|constructor| (NIL "\\spadtype{FortranCodePackage1} provides some utilities for producing useful objects in FortranCode domain. The Package may be used with the FortranCode domain and its \\spad{printCode} or possibly via an outputAsFortran. (The package provides items of use in connection with ASPs in the AXIOM-NAG link and, where appropriate, naming accords with that in IRENA.) The easy-to-use functions use Fortran loop variables I1, I2, and it is users' responsibility to check that this is sensible. The advanced functions use SegmentBinding to allow users control over Fortran loop variable names.")) (|identitySquareMatrix| (((|FortranCode|) (|Symbol|) (|Polynomial| (|Integer|))) "\\spad{identitySquareMatrix(s,p)} \\undocumented{}")) (|zeroSquareMatrix| (((|FortranCode|) (|Symbol|) (|Polynomial| (|Integer|))) "\\spad{zeroSquareMatrix(s,p)} \\undocumented{}")) (|zeroMatrix| (((|FortranCode|) (|Symbol|) (|SegmentBinding| (|Polynomial| (|Integer|))) (|SegmentBinding| (|Polynomial| (|Integer|)))) "\\spad{zeroMatrix(s,b,d)} in this version gives the user control over names of Fortran variables used in loops.") (((|FortranCode|) (|Symbol|) (|Polynomial| (|Integer|)) (|Polynomial| (|Integer|))) "\\spad{zeroMatrix(s,p,q)} uses loop variables in the Fortran, \\spad{I1} and \\spad{I2}")) (|zeroVector| (((|FortranCode|) (|Symbol|) (|Polynomial| (|Integer|))) "\\spad{zeroVector(s,p)} \\undocumented{}"))) 
NIL 
NIL 
(|FiniteDivisorFunctions2| R1 UP1 UPUP1 F1 R2 UP2 UPUP2 F2) 
((|constructor| (NIL "Lift a map to finite divisors.")) (|map| (((|FiniteDivisor| |#5| |#6| |#7| |#8|) (|Mapping| |#5| |#1|) (|FiniteDivisor| |#1| |#2| |#3| |#4|)) "\\spad{map(f,d)} \\undocumented{}"))) 
NIL 
NIL 
(|FiniteDivisorCategory&| S F UP UPUP R) 
((|constructor| (NIL "This category describes finite rational divisors on a curve, that is finite formal sums SUM(n * \\spad{P)} where the \\spad{n's} are integers and the \\spad{P's} are finite rational points on the curve.")) (|generator| (((|Union| |#5| "failed") $) "\\spad{generator(d)} returns \\spad{f} if \\spad{(f) = \\spad{d},} \"failed\" if \\spad{d} is not principal.")) (|principal?| (((|Boolean|) $) "\\spad{principal?(D)} tests if the argument is the divisor of a function.")) (|reduce| (($ $) "\\spad{reduce(D)} converts \\spad{D} to some reduced form (the reduced forms can be differents in different implementations).")) (|decompose| (((|Record| (|:| |id| (|FractionalIdeal| |#3| (|Fraction| |#3|) |#4| |#5|)) (|:| |principalPart| |#5|)) $) "\\spad{decompose(d)} returns \\spad{[id, \\spad{f]}} where \\spad{d = (id) + div(f)}.")) (|divisor| (($ |#5| |#3| |#3| |#3| |#2|) "\\spad{divisor(h, \\spad{d,} \\spad{d',} \\spad{g,} \\spad{r)}} returns the sum of all the finite points where \\spad{h/d} has residue \\spad{r}. \\spad{h} must be integral. \\spad{d} must be squarefree. \\spad{d'} is some derivative of \\spad{d} (not necessarily dd/dx). \\spad{g = gcd(d,discriminant)} contains the ramified zeros of \\spad{d}") (($ |#2| |#2| (|Integer|)) "\\spad{divisor(a, \\spad{b,} \\spad{n)}} makes the divisor \\spad{nP} where \\spad{P:} \\spad{(x = a, \\spad{y} = b)}. \\spad{P} is allowed to be singular if \\spad{n} is a multiple of the rank.") (($ |#2| |#2|) "\\spad{divisor(a, \\spad{b)}} makes the divisor \\spad{P:} \\spad{(x = a, \\spad{y} = b)}. Error: if \\spad{P} is singular.") (($ |#5|) "\\spad{divisor(g)} returns the divisor of the function \\spad{g.}") (($ (|FractionalIdeal| |#3| (|Fraction| |#3|) |#4| |#5|)) "\\spad{divisor(I)} makes a divisor \\spad{D} from an ideal I.")) (|ideal| (((|FractionalIdeal| |#3| (|Fraction| |#3|) |#4| |#5|) $) "\\spad{ideal(D)} returns the ideal corresponding to a divisor \\spad{D.}"))) 
NIL 
NIL 
(|FiniteDivisorCategory| F UP UPUP R) 
((|constructor| (NIL "This category describes finite rational divisors on a curve, that is finite formal sums SUM(n * \\spad{P)} where the \\spad{n's} are integers and the \\spad{P's} are finite rational points on the curve.")) (|generator| (((|Union| |#4| "failed") $) "\\spad{generator(d)} returns \\spad{f} if \\spad{(f) = \\spad{d},} \"failed\" if \\spad{d} is not principal.")) (|principal?| (((|Boolean|) $) "\\spad{principal?(D)} tests if the argument is the divisor of a function.")) (|reduce| (($ $) "\\spad{reduce(D)} converts \\spad{D} to some reduced form (the reduced forms can be differents in different implementations).")) (|decompose| (((|Record| (|:| |id| (|FractionalIdeal| |#2| (|Fraction| |#2|) |#3| |#4|)) (|:| |principalPart| |#4|)) $) "\\spad{decompose(d)} returns \\spad{[id, \\spad{f]}} where \\spad{d = (id) + div(f)}.")) (|divisor| (($ |#4| |#2| |#2| |#2| |#1|) "\\spad{divisor(h, \\spad{d,} \\spad{d',} \\spad{g,} \\spad{r)}} returns the sum of all the finite points where \\spad{h/d} has residue \\spad{r}. \\spad{h} must be integral. \\spad{d} must be squarefree. \\spad{d'} is some derivative of \\spad{d} (not necessarily dd/dx). \\spad{g = gcd(d,discriminant)} contains the ramified zeros of \\spad{d}") (($ |#1| |#1| (|Integer|)) "\\spad{divisor(a, \\spad{b,} \\spad{n)}} makes the divisor \\spad{nP} where \\spad{P:} \\spad{(x = a, \\spad{y} = b)}. \\spad{P} is allowed to be singular if \\spad{n} is a multiple of the rank.") (($ |#1| |#1|) "\\spad{divisor(a, \\spad{b)}} makes the divisor \\spad{P:} \\spad{(x = a, \\spad{y} = b)}. Error: if \\spad{P} is singular.") (($ |#4|) "\\spad{divisor(g)} returns the divisor of the function \\spad{g.}") (($ (|FractionalIdeal| |#2| (|Fraction| |#2|) |#3| |#4|)) "\\spad{divisor(I)} makes a divisor \\spad{D} from an ideal I.")) (|ideal| (((|FractionalIdeal| |#2| (|Fraction| |#2|) |#3| |#4|) $) "\\spad{ideal(D)} returns the ideal corresponding to a divisor \\spad{D.}"))) 
NIL 
NIL 
(|FiniteDivisor| F UP UPUP R) 
((|constructor| (NIL "This domains implements finite rational divisors on a curve, that is finite formal sums SUM(n * \\spad{P)} where the \\spad{n's} are integers and the \\spad{P's} are finite rational points on the curve.")) (|lSpaceBasis| (((|Vector| |#4|) $) "\\spad{lSpaceBasis(d)} returns a basis for \\spad{L(d) = \\spad{{f} | \\spad{(f)} \\spad{>=} -d}} as a module over \\spad{K[x]}.")) (|finiteBasis| (((|Vector| |#4|) $) "\\spad{finiteBasis(d)} returns a basis for \\spad{d} as a module over K[x]."))) 
NIL 
NIL 
(|FullyEvalableOver&| S R) 
((|constructor| (NIL "This category provides a selection of evaluation operations depending on what the argument type \\spad{R} provides.")) (|map| (($ (|Mapping| |#2| |#2|) $) "\\spad{map(f, ex)} evaluates ex, applying \\spad{f} to values of type \\spad{R} in ex."))) 
NIL 
((|HasCategory| |#2| (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |Eltable|) (|devaluate| |#2|) (|devaluate| |#2|)))) 
(|FullyEvalableOver| R) 
((|constructor| (NIL "This category provides a selection of evaluation operations depending on what the argument type \\spad{R} provides.")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\spad{map(f, ex)} evaluates ex, applying \\spad{f} to values of type \\spad{R} in ex."))) 
NIL 
NIL 
(|FortranExpression| |basicSymbols| |subscriptedSymbols| R) 
((|constructor| (NIL "A domain of expressions involving functions which can be translated into standard Fortran-77, with some extra extensions from the NAG Fortran Library.")) (|useNagFunctions| (((|Boolean|) (|Boolean|)) "\\spad{useNagFunctions(v)} sets the flag which controls whether NAG functions \\indented{1}{are being used for mathematical and machine constants.\\space{2}The previous} \\indented{1}{value is returned.}") (((|Boolean|)) "\\spad{useNagFunctions()} indicates whether NAG functions are being used \\indented{1}{for mathematical and machine constants.}")) (|variables| (((|List| (|Symbol|)) $) "\\spad{variables(e)} return a list of all the variables in \\spad{e}.")) (|pi| (($) "\\spad{pi(x)} represents the NAG Library function X01AAF which returns \\indented{1}{an approximation to the value of pi}")) (|tanh| (($ $) "\\spad{tanh(x)} represents the Fortran intrinsic function TANH")) (|cosh| (($ $) "\\spad{cosh(x)} represents the Fortran intrinsic function COSH")) (|sinh| (($ $) "\\spad{sinh(x)} represents the Fortran intrinsic function SINH")) (|atan| (($ $) "\\spad{atan(x)} represents the Fortran intrinsic function ATAN")) (|acos| (($ $) "\\spad{acos(x)} represents the Fortran intrinsic function ACOS")) (|asin| (($ $) "\\spad{asin(x)} represents the Fortran intrinsic function ASIN")) (|tan| (($ $) "\\spad{tan(x)} represents the Fortran intrinsic function TAN")) (|cos| (($ $) "\\spad{cos(x)} represents the Fortran intrinsic function COS")) (|sin| (($ $) "\\spad{sin(x)} represents the Fortran intrinsic function SIN")) (|log10| (($ $) "\\spad{log10(x)} represents the Fortran intrinsic function \\spad{LOG10}")) (|log| (($ $) "\\spad{log(x)} represents the Fortran intrinsic function LOG")) (|exp| (($ $) "\\spad{exp(x)} represents the Fortran intrinsic function EXP")) (|sqrt| (($ $) "\\spad{sqrt(x)} represents the Fortran intrinsic function SQRT")) (|abs| (($ $) "\\spad{abs(x)} represents the Fortran intrinsic function ABS")) (|coerce| (((|Expression| |#3|) $) "\\spad{coerce(x)} is not documented")) (|retractIfCan| (((|Union| $ "failed") (|Polynomial| (|Float|))) "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively.") (((|Union| $ "failed") (|Fraction| (|Polynomial| (|Float|)))) "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively.") (((|Union| $ "failed") (|Expression| (|Float|))) "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively.") (((|Union| $ "failed") (|Polynomial| (|Integer|))) "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively.") (((|Union| $ "failed") (|Fraction| (|Polynomial| (|Integer|)))) "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively.") (((|Union| $ "failed") (|Expression| (|Integer|))) "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively.") (((|Union| $ "failed") (|Symbol|)) "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a FortranExpression checking that it is one of the given basic symbols or subscripted symbols which correspond to scalar and array parameters respectively.") (((|Union| $ "failed") (|Expression| |#3|)) "\\spad{retractIfCan(e)} takes \\spad{e} and tries to transform it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively.")) (|retract| (($ (|Polynomial| (|Float|))) "\\spad{retract(e)} takes \\spad{e} and transforms it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively.") (($ (|Fraction| (|Polynomial| (|Float|)))) "\\spad{retract(e)} takes \\spad{e} and transforms it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively.") (($ (|Expression| (|Float|))) "\\spad{retract(e)} takes \\spad{e} and transforms it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively.") (($ (|Polynomial| (|Integer|))) "\\spad{retract(e)} takes \\spad{e} and transforms it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively.") (($ (|Fraction| (|Polynomial| (|Integer|)))) "\\spad{retract(e)} takes \\spad{e} and transforms it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively.") (($ (|Expression| (|Integer|))) "\\spad{retract(e)} takes \\spad{e} and transforms it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively.") (($ (|Symbol|)) "\\spad{retract(e)} takes \\spad{e} and transforms it into a FortranExpression checking that it is one of the given basic symbols or subscripted symbols which correspond to scalar and array parameters respectively.") (($ (|Expression| |#3|)) "\\spad{retract(e)} takes \\spad{e} and transforms it into a FortranExpression checking that it contains no non-Fortran functions, and that it only contains the given basic symbols and subscripted symbols which correspond to scalar and array parameters respectively."))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Float|)))) (|HasCategory| $ (QUOTE (|Ring|))) (|HasCategory| $ (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) 
(|FunctionFieldCategoryFunctions2| R1 UP1 UPUP1 F1 R2 UP2 UPUP2 F2) 
((|constructor| (NIL "Lifts a map from rings to function fields over them.")) (|map| ((|#8| (|Mapping| |#5| |#1|) |#4|) "\\spad{map(f, \\spad{p)}} lifts \\spad{f} to \\spad{F1} and applies it to \\spad{p.}"))) 
NIL 
NIL 
(|FunctionFieldCategory&| S F UP UPUP) 
((|constructor| (NIL "Function field of a curve This category is a model for the function field of a plane algebraic curve.")) (|rationalPoints| (((|List| (|List| |#2|))) "\\spad{rationalPoints()} returns the list of all the affine rational points.")) (|nonSingularModel| (((|List| (|Polynomial| |#2|)) (|Symbol|)) "\\spad{nonSingularModel(u)} returns the equations in u1,...,un of \\indented{1}{an affine non-singular model for the curve.}")) (|algSplitSimple| (((|Record| (|:| |num| $) (|:| |den| |#3|) (|:| |derivden| |#3|) (|:| |gd| |#3|)) $ (|Mapping| |#3| |#3|)) "\\spad{algSplitSimple(f, \\spad{D)}} returns \\spad{[h,d,d',g]} such that \\indented{1}{\\spad{f=h/d},} \\indented{1}{\\spad{h} is integral at all the normal places w.r.t. \\spad{D},} \\indented{1}{\\spad{d' = Dd}, \\spad{g = gcd(d, discriminant())} and \\spad{D}} \\indented{1}{is the derivation to use. \\spad{f} must have at most simple finite} \\indented{1}{poles.}")) (|hyperelliptic| (((|Union| |#3| "failed")) "\\spad{hyperelliptic()} returns \\spad{p(x)} if the curve is the \\indented{1}{hyperelliptic} \\indented{1}{defined by \\spad{y**2 = p(x)}, \"failed\" otherwise.}")) (|elliptic| (((|Union| |#3| "failed")) "\\spad{elliptic()} returns \\spad{p(x)} if the curve is the elliptic \\indented{1}{defined by \\spad{y**2 = p(x)}, \"failed\" otherwise.}")) (|elt| ((|#2| $ |#2| |#2|) "\\spad{elt(f,a,b)} or f(a, \\spad{b)} returns the value of \\spad{f} \\indented{1}{at the point \\spad{(x = a, \\spad{y} = b)}} \\indented{1}{if it is not singular.}")) (|primitivePart| (($ $) "\\spad{primitivePart(f)} removes the content of the denominator and \\indented{1}{the common content of the numerator of \\spad{f.}}")) (|differentiate| (($ $ (|Mapping| |#3| |#3|)) "\\spad{differentiate(x, \\spad{d)}} extends the derivation \\spad{d} from UP to \\$ and \\indented{1}{applies it to \\spad{x.}}")) (|integralDerivationMatrix| (((|Record| (|:| |num| (|Matrix| |#3|)) (|:| |den| |#3|)) (|Mapping| |#3| |#3|)) "\\spad{integralDerivationMatrix(d)} extends the derivation \\spad{d} from UP to \\$ \\indented{1}{and returns \\spad{(M,} \\spad{Q)} such that the i^th row of \\spad{M} divided by \\spad{Q} form} \\indented{1}{the coordinates of \\spad{d(wi)} with respect to \\spad{(w1,...,wn)}} \\indented{1}{where \\spad{(w1,...,wn)} is the integral basis returned} \\indented{1}{by integralBasis().}")) (|integralRepresents| (($ (|Vector| |#3|) |#3|) "\\spad{integralRepresents([A1,...,An], \\spad{D)}} returns \\indented{1}{\\spad{(A1 w1+...+An wn)/D}} \\indented{1}{where \\spad{(w1,...,wn)} is the integral} \\indented{1}{basis of \\spad{integralBasis()}.}")) (|integralCoordinates| (((|Record| (|:| |num| (|Vector| |#3|)) (|:| |den| |#3|)) $) "\\spad{integralCoordinates(f)} returns \\spad{[[A1,...,An], \\spad{D]}} such that \\indented{1}{\\spad{f = \\spad{(A1} \\spad{w1} +...+ An \\spad{wn)} / D}\\space{2}where \\spad{(w1,...,wn)} is the} \\indented{1}{integral basis returned by \\spad{integralBasis()}.}")) (|represents| (($ (|Vector| |#3|) |#3|) "\\spad{represents([A0,...,A(n-1)],D)} returns \\indented{1}{\\spad{(A0 + \\spad{A1} \\spad{y} +...+ A(n-1)*y**(n-1))/D}.}") (($ (|Vector| |#3|) |#3|) "\\spad{represents([A0,...,A(n-1)],D)} returns \\indented{1}{\\spad{(A0 + \\spad{A1} \\spad{y} +...+ A(n-1)*y**(n-1))/D}.}")) (|yCoordinates| (((|Record| (|:| |num| (|Vector| |#3|)) (|:| |den| |#3|)) $) "\\spad{yCoordinates(f)} returns \\spad{[[A1,...,An], \\spad{D]}} such that \\indented{1}{\\spad{f = \\spad{(A1} + \\spad{A2} \\spad{y} +...+ An y**(n-1)) / D}.}")) (|inverseIntegralMatrixAtInfinity| (((|Matrix| (|Fraction| |#3|))) "\\spad{inverseIntegralMatrixAtInfinity()} returns \\spad{M} such \\indented{1}{that \\spad{M (v1,...,vn) = \\spad{(1,} \\spad{y,} ..., y**(n-1))}} \\indented{1}{where \\spad{(v1,...,vn)} is the local integral basis at infinity} \\indented{1}{returned by \\spad{infIntBasis()}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} inverseIntegralMatrixAtInfinity()$R")) (|integralMatrixAtInfinity| (((|Matrix| (|Fraction| |#3|))) "\\spad{integralMatrixAtInfinity()} returns \\spad{M} such that \\indented{1}{\\spad{(v1,...,vn) = \\spad{M} \\spad{(1,} \\spad{y,} ..., y**(n-1))}} \\indented{1}{where \\spad{(v1,...,vn)} is the local integral basis at infinity} \\indented{1}{returned by \\spad{infIntBasis()}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralMatrixAtInfinity()$R")) (|inverseIntegralMatrix| (((|Matrix| (|Fraction| |#3|))) "\\spad{inverseIntegralMatrix()} returns \\spad{M} such that \\indented{1}{\\spad{M (w1,...,wn) = \\spad{(1,} \\spad{y,} ..., y**(n-1))}} \\indented{1}{where \\spad{(w1,...,wn)} is the integral basis of} \\indented{1}{\\spadfunFrom{integralBasis}{FunctionFieldCategory}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} inverseIntegralMatrix()$R")) (|integralMatrix| (((|Matrix| (|Fraction| |#3|))) "\\spad{integralMatrix()} returns \\spad{M} such that \\indented{1}{\\spad{(w1,...,wn) = \\spad{M} \\spad{(1,} \\spad{y,} ..., y**(n-1))},} \\indented{1}{where \\spad{(w1,...,wn)} is the integral basis of} \\indented{1}{\\spadfunFrom{integralBasis}{FunctionFieldCategory}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralMatrix()$R")) (|reduceBasisAtInfinity| (((|Vector| $) (|Vector| $)) "\\spad{reduceBasisAtInfinity(b1,...,bn)} returns \\spad{(x**i * bj)} \\indented{1}{for all i,j such that \\spad{x**i*bj} is locally integral} \\indented{1}{at infinity.}")) (|normalizeAtInfinity| (((|Vector| $) (|Vector| $)) "\\spad{normalizeAtInfinity(v)} makes \\spad{v} normal at infinity.")) (|complementaryBasis| (((|Vector| $) (|Vector| $)) "\\spad{complementaryBasis(b1,...,bn)} returns the complementary basis \\indented{1}{\\spad{(b1',...,bn')} of \\spad{(b1,...,bn)}.}")) (|integral?| (((|Boolean|) $ |#3|) "\\spad{integral?(f, \\spad{p)}} tests whether \\spad{f} is locally integral at \\indented{1}{\\spad{p(x) = 0}}") (((|Boolean|) $ |#2|) "\\spad{integral?(f, a)} tests whether \\spad{f} is locally integral at \\spad{x = a}.") (((|Boolean|) $) "\\spad{integral?()} tests if \\spad{f} is integral over \\spad{k[x]}.")) (|integralAtInfinity?| (((|Boolean|) $) "\\spad{integralAtInfinity?()} tests if \\spad{f} is locally integral at infinity.")) (|integralBasisAtInfinity| (((|Vector| $)) "\\spad{integralBasisAtInfinity()} returns the local integral basis \\indented{1}{at infinity} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralBasisAtInfinity()$R")) (|integralBasis| (((|Vector| $)) "\\spad{integralBasis()} returns the integral basis for the curve. \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralBasis()$R")) (|ramified?| (((|Boolean|) |#3|) "\\spad{ramified?(p)} tests whether \\spad{p(x) = 0} is ramified.") (((|Boolean|) |#2|) "\\spad{ramified?(a)} tests whether \\spad{x = a} is ramified.")) (|ramifiedAtInfinity?| (((|Boolean|)) "\\spad{ramifiedAtInfinity?()} tests if infinity is ramified.")) (|singular?| (((|Boolean|) |#3|) "\\spad{singular?(p)} tests whether \\spad{p(x) = 0} is singular.") (((|Boolean|) |#2|) "\\spad{singular?(a)} tests whether \\spad{x = a} is singular.")) (|singularAtInfinity?| (((|Boolean|)) "\\spad{singularAtInfinity?()} tests if there is a singularity at infinity.")) (|branchPoint?| (((|Boolean|) |#3|) "\\spad{branchPoint?(p)} tests whether \\spad{p(x) = 0} is a branch point.") (((|Boolean|) |#2|) "\\spad{branchPoint?(a)} tests whether \\spad{x = a} is a branch point.")) (|branchPointAtInfinity?| (((|Boolean|)) "\\spad{branchPointAtInfinity?()} tests if there is a branch point \\indented{1}{at infinity.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} branchPointAtInfinity?()$R \\spad{X} \\spad{R2} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 2 * x**2, 4) \\spad{X} branchPointAtInfinity?()$R")) (|rationalPoint?| (((|Boolean|) |#2| |#2|) "\\spad{rationalPoint?(a, \\spad{b)}} tests if \\spad{(x=a,y=b)} is on the curve. \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} rationalPoint?(0,0)$R \\spad{X} \\spad{R2} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 2 * x**2, 4) \\spad{X} \\spad{rationalPoint?(0,0)$R2}")) (|absolutelyIrreducible?| (((|Boolean|)) "\\spad{absolutelyIrreducible?()} tests if the curve absolutely irreducible? \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R2} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 2 * x**2, 4) \\spad{X} \\spad{absolutelyIrreducible?()$R2}")) (|genus| (((|NonNegativeInteger|)) "\\spad{genus()} returns the genus of one absolutely irreducible component \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} genus()$R")) (|numberOfComponents| (((|NonNegativeInteger|)) "\\spad{numberOfComponents()} returns the number of absolutely irreducible \\indented{1}{components.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} numberOfComponents()$R"))) 
NIL 
((|HasCategory| |#2| (QUOTE (|Finite|))) (|HasCategory| |#2| (QUOTE (|Field|)))) 
(|FunctionFieldCategory| F UP UPUP) 
((|constructor| (NIL "Function field of a curve This category is a model for the function field of a plane algebraic curve.")) (|rationalPoints| (((|List| (|List| |#1|))) "\\spad{rationalPoints()} returns the list of all the affine rational points.")) (|nonSingularModel| (((|List| (|Polynomial| |#1|)) (|Symbol|)) "\\spad{nonSingularModel(u)} returns the equations in u1,...,un of \\indented{1}{an affine non-singular model for the curve.}")) (|algSplitSimple| (((|Record| (|:| |num| $) (|:| |den| |#2|) (|:| |derivden| |#2|) (|:| |gd| |#2|)) $ (|Mapping| |#2| |#2|)) "\\spad{algSplitSimple(f, \\spad{D)}} returns \\spad{[h,d,d',g]} such that \\indented{1}{\\spad{f=h/d},} \\indented{1}{\\spad{h} is integral at all the normal places w.r.t. \\spad{D},} \\indented{1}{\\spad{d' = Dd}, \\spad{g = gcd(d, discriminant())} and \\spad{D}} \\indented{1}{is the derivation to use. \\spad{f} must have at most simple finite} \\indented{1}{poles.}")) (|hyperelliptic| (((|Union| |#2| "failed")) "\\spad{hyperelliptic()} returns \\spad{p(x)} if the curve is the \\indented{1}{hyperelliptic} \\indented{1}{defined by \\spad{y**2 = p(x)}, \"failed\" otherwise.}")) (|elliptic| (((|Union| |#2| "failed")) "\\spad{elliptic()} returns \\spad{p(x)} if the curve is the elliptic \\indented{1}{defined by \\spad{y**2 = p(x)}, \"failed\" otherwise.}")) (|elt| ((|#1| $ |#1| |#1|) "\\spad{elt(f,a,b)} or f(a, \\spad{b)} returns the value of \\spad{f} \\indented{1}{at the point \\spad{(x = a, \\spad{y} = b)}} \\indented{1}{if it is not singular.}")) (|primitivePart| (($ $) "\\spad{primitivePart(f)} removes the content of the denominator and \\indented{1}{the common content of the numerator of \\spad{f.}}")) (|differentiate| (($ $ (|Mapping| |#2| |#2|)) "\\spad{differentiate(x, \\spad{d)}} extends the derivation \\spad{d} from UP to \\$ and \\indented{1}{applies it to \\spad{x.}}")) (|integralDerivationMatrix| (((|Record| (|:| |num| (|Matrix| |#2|)) (|:| |den| |#2|)) (|Mapping| |#2| |#2|)) "\\spad{integralDerivationMatrix(d)} extends the derivation \\spad{d} from UP to \\$ \\indented{1}{and returns \\spad{(M,} \\spad{Q)} such that the i^th row of \\spad{M} divided by \\spad{Q} form} \\indented{1}{the coordinates of \\spad{d(wi)} with respect to \\spad{(w1,...,wn)}} \\indented{1}{where \\spad{(w1,...,wn)} is the integral basis returned} \\indented{1}{by integralBasis().}")) (|integralRepresents| (($ (|Vector| |#2|) |#2|) "\\spad{integralRepresents([A1,...,An], \\spad{D)}} returns \\indented{1}{\\spad{(A1 w1+...+An wn)/D}} \\indented{1}{where \\spad{(w1,...,wn)} is the integral} \\indented{1}{basis of \\spad{integralBasis()}.}")) (|integralCoordinates| (((|Record| (|:| |num| (|Vector| |#2|)) (|:| |den| |#2|)) $) "\\spad{integralCoordinates(f)} returns \\spad{[[A1,...,An], \\spad{D]}} such that \\indented{1}{\\spad{f = \\spad{(A1} \\spad{w1} +...+ An \\spad{wn)} / D}\\space{2}where \\spad{(w1,...,wn)} is the} \\indented{1}{integral basis returned by \\spad{integralBasis()}.}")) (|represents| (($ (|Vector| |#2|) |#2|) "\\spad{represents([A0,...,A(n-1)],D)} returns \\indented{1}{\\spad{(A0 + \\spad{A1} \\spad{y} +...+ A(n-1)*y**(n-1))/D}.}") (($ (|Vector| |#2|) |#2|) "\\spad{represents([A0,...,A(n-1)],D)} returns \\indented{1}{\\spad{(A0 + \\spad{A1} \\spad{y} +...+ A(n-1)*y**(n-1))/D}.}")) (|yCoordinates| (((|Record| (|:| |num| (|Vector| |#2|)) (|:| |den| |#2|)) $) "\\spad{yCoordinates(f)} returns \\spad{[[A1,...,An], \\spad{D]}} such that \\indented{1}{\\spad{f = \\spad{(A1} + \\spad{A2} \\spad{y} +...+ An y**(n-1)) / D}.}")) (|inverseIntegralMatrixAtInfinity| (((|Matrix| (|Fraction| |#2|))) "\\spad{inverseIntegralMatrixAtInfinity()} returns \\spad{M} such \\indented{1}{that \\spad{M (v1,...,vn) = \\spad{(1,} \\spad{y,} ..., y**(n-1))}} \\indented{1}{where \\spad{(v1,...,vn)} is the local integral basis at infinity} \\indented{1}{returned by \\spad{infIntBasis()}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} inverseIntegralMatrixAtInfinity()$R")) (|integralMatrixAtInfinity| (((|Matrix| (|Fraction| |#2|))) "\\spad{integralMatrixAtInfinity()} returns \\spad{M} such that \\indented{1}{\\spad{(v1,...,vn) = \\spad{M} \\spad{(1,} \\spad{y,} ..., y**(n-1))}} \\indented{1}{where \\spad{(v1,...,vn)} is the local integral basis at infinity} \\indented{1}{returned by \\spad{infIntBasis()}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralMatrixAtInfinity()$R")) (|inverseIntegralMatrix| (((|Matrix| (|Fraction| |#2|))) "\\spad{inverseIntegralMatrix()} returns \\spad{M} such that \\indented{1}{\\spad{M (w1,...,wn) = \\spad{(1,} \\spad{y,} ..., y**(n-1))}} \\indented{1}{where \\spad{(w1,...,wn)} is the integral basis of} \\indented{1}{\\spadfunFrom{integralBasis}{FunctionFieldCategory}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} inverseIntegralMatrix()$R")) (|integralMatrix| (((|Matrix| (|Fraction| |#2|))) "\\spad{integralMatrix()} returns \\spad{M} such that \\indented{1}{\\spad{(w1,...,wn) = \\spad{M} \\spad{(1,} \\spad{y,} ..., y**(n-1))},} \\indented{1}{where \\spad{(w1,...,wn)} is the integral basis of} \\indented{1}{\\spadfunFrom{integralBasis}{FunctionFieldCategory}.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralMatrix()$R")) (|reduceBasisAtInfinity| (((|Vector| $) (|Vector| $)) "\\spad{reduceBasisAtInfinity(b1,...,bn)} returns \\spad{(x**i * bj)} \\indented{1}{for all i,j such that \\spad{x**i*bj} is locally integral} \\indented{1}{at infinity.}")) (|normalizeAtInfinity| (((|Vector| $) (|Vector| $)) "\\spad{normalizeAtInfinity(v)} makes \\spad{v} normal at infinity.")) (|complementaryBasis| (((|Vector| $) (|Vector| $)) "\\spad{complementaryBasis(b1,...,bn)} returns the complementary basis \\indented{1}{\\spad{(b1',...,bn')} of \\spad{(b1,...,bn)}.}")) (|integral?| (((|Boolean|) $ |#2|) "\\spad{integral?(f, \\spad{p)}} tests whether \\spad{f} is locally integral at \\indented{1}{\\spad{p(x) = 0}}") (((|Boolean|) $ |#1|) "\\spad{integral?(f, a)} tests whether \\spad{f} is locally integral at \\spad{x = a}.") (((|Boolean|) $) "\\spad{integral?()} tests if \\spad{f} is integral over \\spad{k[x]}.")) (|integralAtInfinity?| (((|Boolean|) $) "\\spad{integralAtInfinity?()} tests if \\spad{f} is locally integral at infinity.")) (|integralBasisAtInfinity| (((|Vector| $)) "\\spad{integralBasisAtInfinity()} returns the local integral basis \\indented{1}{at infinity} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralBasisAtInfinity()$R")) (|integralBasis| (((|Vector| $)) "\\spad{integralBasis()} returns the integral basis for the curve. \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} integralBasis()$R")) (|ramified?| (((|Boolean|) |#2|) "\\spad{ramified?(p)} tests whether \\spad{p(x) = 0} is ramified.") (((|Boolean|) |#1|) "\\spad{ramified?(a)} tests whether \\spad{x = a} is ramified.")) (|ramifiedAtInfinity?| (((|Boolean|)) "\\spad{ramifiedAtInfinity?()} tests if infinity is ramified.")) (|singular?| (((|Boolean|) |#2|) "\\spad{singular?(p)} tests whether \\spad{p(x) = 0} is singular.") (((|Boolean|) |#1|) "\\spad{singular?(a)} tests whether \\spad{x = a} is singular.")) (|singularAtInfinity?| (((|Boolean|)) "\\spad{singularAtInfinity?()} tests if there is a singularity at infinity.")) (|branchPoint?| (((|Boolean|) |#2|) "\\spad{branchPoint?(p)} tests whether \\spad{p(x) = 0} is a branch point.") (((|Boolean|) |#1|) "\\spad{branchPoint?(a)} tests whether \\spad{x = a} is a branch point.")) (|branchPointAtInfinity?| (((|Boolean|)) "\\spad{branchPointAtInfinity?()} tests if there is a branch point \\indented{1}{at infinity.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} branchPointAtInfinity?()$R \\spad{X} \\spad{R2} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 2 * x**2, 4) \\spad{X} branchPointAtInfinity?()$R")) (|rationalPoint?| (((|Boolean|) |#1| |#1|) "\\spad{rationalPoint?(a, \\spad{b)}} tests if \\spad{(x=a,y=b)} is on the curve. \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} rationalPoint?(0,0)$R \\spad{X} \\spad{R2} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 2 * x**2, 4) \\spad{X} \\spad{rationalPoint?(0,0)$R2}")) (|absolutelyIrreducible?| (((|Boolean|)) "\\spad{absolutelyIrreducible?()} tests if the curve absolutely irreducible? \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R2} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 2 * x**2, 4) \\spad{X} \\spad{absolutelyIrreducible?()$R2}")) (|genus| (((|NonNegativeInteger|)) "\\spad{genus()} returns the genus of one absolutely irreducible component \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} genus()$R")) (|numberOfComponents| (((|NonNegativeInteger|)) "\\spad{numberOfComponents()} returns the number of absolutely irreducible \\indented{1}{components.} \\blankline \\spad{X} \\spad{P0} \\spad{:=} UnivariatePolynomial(x, Integer) \\spad{X} \\spad{P1} \\spad{:=} UnivariatePolynomial(y, Fraction \\spad{P0)} \\spad{X} \\spad{R} \\spad{:=} RadicalFunctionField(INT, \\spad{P0,} \\spad{P1,} 1 - x**20, 20) \\spad{X} numberOfComponents()$R"))) 
((|noZeroDivisors| |has| (|Fraction| |#2|) (|Field|)) (|canonicalUnitNormal| |has| (|Fraction| |#2|) (|Field|)) (|canonicalsClosed| |has| (|Fraction| |#2|) (|Field|)) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|FiniteFieldCyclicGroup| |p| |extdeg|) 
((|constructor| (NIL "FiniteFieldCyclicGroup(p,n) implements a finite field extension of degee \\spad{n} over the prime field with \\spad{p} elements. Its elements are represented by powers of a primitive element, \\spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial, which is created by createPrimitivePoly from \\spadtype{FiniteFieldPolynomialPackage}. The Zech logarithms are stored in a table of size half of the field size, and use \\spadtype{SingleInteger} for representing field elements, hence, there are restrictions on the size of the field.")) (|getZechTable| (((|PrimitiveArray| (|SingleInteger|))) "\\spad{getZechTable()} returns the zech logarithm table of the field. This table is used to perform additions in the field quickly."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|PrimeField| |#1|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|PrimeField| |#1|) (QUOTE (|Finite|))) (|HasCategory| (|PrimeField| |#1|) (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| (|PrimeField| |#1|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|PrimeField| |#1|) (QUOTE (|Finite|))))) 
(|FiniteFieldCyclicGroupExtensionByPolynomial| GF |defpol|) 
((|constructor| (NIL "FiniteFieldCyclicGroupExtensionByPolynomial(GF,defpol) implements a finite extension field of the ground field \\spad{GF.} Its elements are represented by powers of a primitive element, \\spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial defpol, which MUST be primitive (user responsibility). Zech logarithms are stored in a table of size half of the field size, and use \\spadtype{SingleInteger} for representing field elements, hence, there are restrictions on the size of the field.")) (|getZechTable| (((|PrimitiveArray| (|SingleInteger|))) "\\spad{getZechTable()} returns the zech logarithm table of the field it is used to perform additions in the field quickly."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|Finite|))))) 
(|FiniteFieldCyclicGroupExtension| GF |extdeg|) 
((|constructor| (NIL "FiniteFieldCyclicGroupExtension(GF,n) implements a extension of degree \\spad{n} over the ground field \\spad{GF.} Its elements are represented by powers of a primitive element, \\spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial, which is created by createPrimitivePoly from \\spadtype{FiniteFieldPolynomialPackage}. Zech logarithms are stored in a table of size half of the field size, and use \\spadtype{SingleInteger} for representing field elements, hence, there are restrictions on the size of the field.")) (|getZechTable| (((|PrimitiveArray| (|SingleInteger|))) "\\spad{getZechTable()} returns the zech logarithm table of the field. This table is used to perform additions in the field quickly."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|Finite|))))) 
(|FiniteFieldFactorization| K |PolK|) 
((|constructor| (NIL "Part of the PAFF package"))) 
NIL 
NIL 
(|FiniteFieldFactorizationWithSizeParseBySideEffect| K |PolK|) 
((|constructor| (NIL "Part of the package for Algebraic Function Fields in one variable (PAFF) It has been modified (very slitely) so that each time the \"factor\" function is used, the variable related to the size of the field over which the polynomial is factorized is reset. This is done in order to be used with a \"dynamic extension field\" which size is not fixed but set before calling the \"factor\" function and which is parse by side effect to this package via the function \"size\". See the local function \"initialize\" of this package."))) 
NIL 
NIL 
(|FractionFreeFastGaussianFractions| D V VF) 
((|constructor| (NIL "This package lifts the interpolation functions from \\spadtype{FractionFreeFastGaussian} to fractions. The packages defined in this file provide fast fraction free rational interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)")) (|generalInterpolation| (((|Stream| (|Matrix| (|SparseUnivariatePolynomial| |#1|))) (|List| |#1|) (|Mapping| |#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|) (|Vector| |#3|) (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{generalInterpolation(l, CA, \\spad{f,} sumEta, maxEta)} applies generalInterpolation(l, CA, \\spad{f,} eta) for all possible eta with maximal entry maxEta and sum of entries \\spad{sumEta}") (((|Matrix| (|SparseUnivariatePolynomial| |#1|)) (|List| |#1|) (|Mapping| |#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|) (|Vector| |#3|) (|List| (|NonNegativeInteger|))) "\\spad{generalInterpolation(l, CA, \\spad{f,} eta)} performs Hermite-Pade approximation using the given action \\spad{CA} of polynomials on the elements of \\spad{f.} The result is guaranteed to be correct up to order |eta|-1. Given that eta is a \"normal\" point, the degrees on the diagonal are given by eta. The degrees of column \\spad{i} are in this case eta + e.i - [1,1,...,1], where the degree of zero is \\spad{-1.}"))) 
NIL 
NIL 
(|FractionFreeFastGaussian| D V) 
((|constructor| (NIL "This package implements the interpolation algorithm proposed in Beckermann, Bernhard and Labahn, George, Fraction-free computation of matrix rational interpolants and matrix GCDs, SIAM Journal on Matrix Analysis and Applications 22. The packages defined in this file provide fast fraction free rational interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)")) (|qShiftC| (((|List| |#1|) |#1| (|NonNegativeInteger|)) "\\spad{qShiftC} gives the coefficients c_{k,k} in the expansion <x^k> \\spad{z} g(x) = sum_{i=0}^k c_{k,i} <x^i> g(x), where \\spad{z} acts on g(x) by shifting. In fact, the result is [1,q,q^2,...]")) (|qShiftAction| ((|#1| |#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|) "\\spad{qShiftAction(q, \\spad{k,} \\spad{l,} \\spad{g)}} gives the coefficient of \\spad{x^k} in \\spad{z^l} g(x), where z*(a+b*x+c*x^2+d*x^3+...) = (a+q*b*x+q^2*c*x^2+q^3*d*x^3+...). In terms of sequences, z*u(n)=q^n*u(n).")) (|DiffC| (((|List| |#1|) (|NonNegativeInteger|)) "\\spad{DiffC} gives the coefficients c_{k,k} in the expansion <x^k> \\spad{z} g(x) = sum_{i=0}^k c_{k,i} <x^i> g(x), where \\spad{z} acts on g(x) by shifting. In fact, the result is [0,0,0,...]")) (|DiffAction| ((|#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|) "\\spad{DiffAction(k, \\spad{l,} \\spad{g)}} gives the coefficient of \\spad{x^k} in \\spad{z^l} g(x), where z*(a+b*x+c*x^2+d*x^3+...) = (a*x+b*x^2+c*x^3+...), \\spadignore{i.e.} multiplication with \\spad{x.}")) (|ShiftC| (((|List| |#1|) (|NonNegativeInteger|)) "\\spad{ShiftC} gives the coefficients c_{k,k} in the expansion <x^k> \\spad{z} g(x) = sum_{i=0}^k c_{k,i} <x^i> g(x), where \\spad{z} acts on g(x) by shifting. In fact, the result is [0,1,2,...]")) (|ShiftAction| ((|#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|) "\\spad{ShiftAction(k, \\spad{l,} \\spad{g)}} gives the coefficient of \\spad{x^k} in \\spad{z^l} g(x), where \\spad{z*(a+b*x+c*x^2+d*x^3+...) = (b*x+2*c*x^2+3*d*x^3+...)}. In terms of sequences, z*u(n)=n*u(n).")) (|generalCoefficient| ((|#1| (|Mapping| |#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|) (|Vector| |#2|) (|NonNegativeInteger|) (|Vector| (|SparseUnivariatePolynomial| |#1|))) "\\spad{generalCoefficient(action, \\spad{f,} \\spad{k,} \\spad{p)}} gives the coefficient of \\spad{x^k} in p(z)\\dot f(x), where the \\spad{action} of \\spad{z^l} on a polynomial in \\spad{x} is given by action, \\spadignore{i.e.} action(k, \\spad{l,} \\spad{f)} should return the coefficient of \\spad{x^k} in \\spad{z^l} f(x).")) (|generalInterpolation| (((|Stream| (|Matrix| (|SparseUnivariatePolynomial| |#1|))) (|List| |#1|) (|Mapping| |#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|) (|Vector| |#2|) (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{generalInterpolation(C, CA, \\spad{f,} sumEta, maxEta)} applies \\spad{generalInterpolation(C, CA, \\spad{f,} eta)} for all possible \\spad{eta} with maximal entry \\spad{maxEta} and sum of entries at most \\spad{sumEta}. \\blankline The first argument \\spad{C} is the list of coefficients c_{k,k} in the expansion <x^k> \\spad{z} g(x) = sum_{i=0}^k c_{k,i} <x^i> g(x). \\blankline The second argument, CA(k, \\spad{l,} \\spad{f),} should return the coefficient of \\spad{x^k} in \\spad{z^l} f(x).") (((|Matrix| (|SparseUnivariatePolynomial| |#1|)) (|List| |#1|) (|Mapping| |#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#2|) (|Vector| |#2|) (|List| (|NonNegativeInteger|))) "\\spad{generalInterpolation(C, CA, \\spad{f,} eta)} performs Hermite-Pade approximation using the given action \\spad{CA} of polynomials on the elements of \\spad{f.} The result is guaranteed to be correct up to order |eta|-1. Given that eta is a \"normal\" point, the degrees on the diagonal are given by eta. The degrees of column \\spad{i} are in this case eta + e.i - [1,1,...,1], where the degree of zero is \\spad{-1.} \\blankline The first argument \\spad{C} is the list of coefficients c_{k,k} in the expansion <x^k> \\spad{z} g(x) = sum_{i=0}^k c_{k,i} <x^i> g(x). \\blankline The second argument, CA(k, \\spad{l,} \\spad{f),} should return the coefficient of \\spad{x^k} in \\spad{z^l} f(x).")) (|interpolate| (((|Fraction| (|SparseUnivariatePolynomial| |#1|)) (|List| (|Fraction| |#1|)) (|List| (|Fraction| |#1|)) (|NonNegativeInteger|)) "\\spad{interpolate(xlist, ylist, deg} returns the rational function with numerator degree \\spad{deg} that interpolates the given points using fraction free arithmetic.") (((|Fraction| (|SparseUnivariatePolynomial| |#1|)) (|List| |#1|) (|List| |#1|) (|NonNegativeInteger|)) "\\spad{interpolate(xlist, ylist, deg} returns the rational function with numerator degree at most \\spad{deg} and denominator degree at most \\spad{\\#xlist-deg-1} that interpolates the given points using fraction free arithmetic. Note that rational interpolation does not guarantee that all given points are interpolated correctly: unattainable points may make this impossible.")) (|fffg| (((|Matrix| (|SparseUnivariatePolynomial| |#1|)) (|List| |#1|) (|Mapping| |#1| (|NonNegativeInteger|) (|Vector| (|SparseUnivariatePolynomial| |#1|))) (|List| (|NonNegativeInteger|))) "\\spad{fffg} is the general algorithm as proposed by Beckermann and Labahn. \\blankline The first argument is the list of c_{i,i}. These are the only values of \\spad{C} explicitely needed in \\spad{fffg}. \\blankline The second argument \\spad{c,} computes c_k(M), \\spadignore{i.e.} c_k(.) is the dual basis of the vector space \\spad{V,} but also knows about the special multiplication rule as descibed in Equation (2). Note that the information about \\spad{f} is therefore encoded in \\spad{c.} \\blankline The third argument is the vector of degree bounds \\spad{n,} as introduced in Definition 2.1. In particular, the sum of the entries is the order of the Mahler system computed."))) 
NIL 
NIL 
(|FiniteFieldFunctions| GF) 
((|constructor| (NIL "FiniteFieldFunctions(GF) is a package with functions concerning finite extension fields of the finite ground field \\spad{GF,} \\spadignore{e.g.} Zech logarithms.")) (|createLowComplexityNormalBasis| (((|Union| (|SparseUnivariatePolynomial| |#1|) (|Vector| (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|)))))) (|PositiveInteger|)) "\\spad{createLowComplexityNormalBasis(n)} tries to find a a low complexity normal basis of degree \\spad{n} over \\spad{GF} and returns its multiplication matrix If no low complexity basis is found it calls \\axiomFunFrom{createNormalPoly}{FiniteFieldPolynomialPackage}(n) to produce a normal polynomial of degree \\spad{n} over \\spad{GF}")) (|createLowComplexityTable| (((|Union| (|Vector| (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|))))) "failed") (|PositiveInteger|)) "\\spad{createLowComplexityTable(n)} tries to find a low complexity normal basis of degree \\spad{n} over \\spad{GF} and returns its multiplication matrix Fails, if it does not find a low complexity basis")) (|sizeMultiplication| (((|NonNegativeInteger|) (|Vector| (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|)))))) "\\spad{sizeMultiplication(m)} returns the number of entries of the multiplication table \\spad{m.}")) (|createMultiplicationMatrix| (((|Matrix| |#1|) (|Vector| (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|)))))) "\\spad{createMultiplicationMatrix(m)} forms the multiplication table \\spad{m} into a matrix over the ground field.")) (|createMultiplicationTable| (((|Vector| (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|))))) (|SparseUnivariatePolynomial| |#1|)) "\\spad{createMultiplicationTable(f)} generates a multiplication table for the normal basis of the field extension determined by \\spad{f.} This is needed to perform multiplications between elements represented as coordinate vectors to this basis. See \\spadtype{FFNBP}, \\spadtype{FFNBX}.")) (|createZechTable| (((|PrimitiveArray| (|SingleInteger|)) (|SparseUnivariatePolynomial| |#1|)) "\\spad{createZechTable(f)} generates a Zech logarithm table for the cyclic group representation of a extension of the ground field by the primitive polynomial f(x), \\spadignore{i.e.} \\spad{Z(i)}, defined by x**Z(i) = 1+x**i is stored at index i. This is needed in particular to perform addition of field elements in finite fields represented in this way. See \\spadtype{FFCGP}, \\spadtype{FFCGX}."))) 
NIL 
NIL 
(|FiniteFieldHomomorphisms| F1 GF F2) 
((|constructor| (NIL "FiniteFieldHomomorphisms(F1,GF,F2) exports coercion functions of elements between the fields \\spad{F1} and \\spad{F2,} which both must be finite simple algebraic extensions of the finite ground field \\spad{GF.}")) (|coerce| ((|#1| |#3|) "\\spad{coerce(x)} is the homomorphic image of \\spad{x} from \\spad{F2} in \\spad{F1,} where coerce is a field homomorphism between the fields extensions \\spad{F2} and \\spad{F1} both over ground field \\spad{GF} (the second argument to the package). Error: if the extension degree of \\spad{F2} doesn't divide the extension degree of \\spad{F1.} Note that the other coercion function in the \\spadtype{FiniteFieldHomomorphisms} is a left inverse.") ((|#3| |#1|) "\\spad{coerce(x)} is the homomorphic image of \\spad{x} from \\spad{F1} in \\spad{F2.} Thus coerce is a field homomorphism between the fields extensions \\spad{F1} and \\spad{F2} both over ground field \\spad{GF} (the second argument to the package). Error: if the extension degree of \\spad{F1} doesn't divide the extension degree of \\spad{F2.} Note that the other coercion function in the \\spadtype{FiniteFieldHomomorphisms} is a left inverse."))) 
NIL 
NIL 
(|FiniteFieldCategory&| S) 
((|constructor| (NIL "FiniteFieldCategory is the category of finite fields")) (|representationType| (((|Union| "prime" "polynomial" "normal" "cyclic")) "\\spad{representationType()} returns the type of the representation, one of: \\spad{prime}, \\spad{polynomial}, \\spad{normal}, or \\spad{cyclic}.")) (|order| (((|PositiveInteger|) $) "\\spad{order(b)} computes the order of an element \\spad{b} in the multiplicative group of the field. Error: if \\spad{b} equals 0.")) (|discreteLog| (((|NonNegativeInteger|) $) "\\spad{discreteLog(a)} computes the discrete logarithm of \\spad{a} with respect to \\spad{primitiveElement()} of the field.")) (|primitive?| (((|Boolean|) $) "\\spad{primitive?(b)} tests whether the element \\spad{b} is a generator of the (cyclic) multiplicative group of the field, \\spadignore{i.e.} is a primitive element. Implementation Note that see ch.IX.1.3, \\spad{th.2} in \\spad{D.} Lipson.")) (|primitiveElement| (($) "\\spad{primitiveElement()} returns a primitive element stored in a global variable in the domain. At first call, the primitive element is computed by calling \\spadfun{createPrimitiveElement}.")) (|createPrimitiveElement| (($) "\\spad{createPrimitiveElement()} computes a generator of the (cyclic) multiplicative group of the field.")) (|tableForDiscreteLogarithm| (((|Table| (|PositiveInteger|) (|NonNegativeInteger|)) (|Integer|)) "\\spad{tableForDiscreteLogarithm(a,n)} returns a table of the discrete logarithms of \\spad{a**0} up to \\spad{a**(n-1)} which, called with key \\spad{lookup(a**i)} returns \\spad{i} for \\spad{i} in \\spad{0..n-1}. Error: if not called for prime divisors of order of \\indented{7}{multiplicative group.}")) (|factorsOfCyclicGroupSize| (((|List| (|Record| (|:| |factor| (|Integer|)) (|:| |exponent| (|Integer|))))) "\\spad{factorsOfCyclicGroupSize()} returns the factorization of \\spad{size()-1}")) (|conditionP| (((|Union| (|Vector| $) "failed") (|Matrix| $)) "\\spad{conditionP(mat)}, given a matrix representing a homogeneous system of equations, returns a vector whose characteristic'th powers is a non-trivial solution, or \"failed\" if no such vector exists.")) (|charthRoot| (($ $) "\\spad{charthRoot(a)} takes the characteristic'th root of a. Note that such a root is alway defined in finite fields."))) 
NIL 
NIL 
(|FiniteFieldCategory|) 
((|constructor| (NIL "FiniteFieldCategory is the category of finite fields")) (|representationType| (((|Union| "prime" "polynomial" "normal" "cyclic")) "\\spad{representationType()} returns the type of the representation, one of: \\spad{prime}, \\spad{polynomial}, \\spad{normal}, or \\spad{cyclic}.")) (|order| (((|PositiveInteger|) $) "\\spad{order(b)} computes the order of an element \\spad{b} in the multiplicative group of the field. Error: if \\spad{b} equals 0.")) (|discreteLog| (((|NonNegativeInteger|) $) "\\spad{discreteLog(a)} computes the discrete logarithm of \\spad{a} with respect to \\spad{primitiveElement()} of the field.")) (|primitive?| (((|Boolean|) $) "\\spad{primitive?(b)} tests whether the element \\spad{b} is a generator of the (cyclic) multiplicative group of the field, \\spadignore{i.e.} is a primitive element. Implementation Note that see ch.IX.1.3, \\spad{th.2} in \\spad{D.} Lipson.")) (|primitiveElement| (($) "\\spad{primitiveElement()} returns a primitive element stored in a global variable in the domain. At first call, the primitive element is computed by calling \\spadfun{createPrimitiveElement}.")) (|createPrimitiveElement| (($) "\\spad{createPrimitiveElement()} computes a generator of the (cyclic) multiplicative group of the field.")) (|tableForDiscreteLogarithm| (((|Table| (|PositiveInteger|) (|NonNegativeInteger|)) (|Integer|)) "\\spad{tableForDiscreteLogarithm(a,n)} returns a table of the discrete logarithms of \\spad{a**0} up to \\spad{a**(n-1)} which, called with key \\spad{lookup(a**i)} returns \\spad{i} for \\spad{i} in \\spad{0..n-1}. Error: if not called for prime divisors of order of \\indented{7}{multiplicative group.}")) (|factorsOfCyclicGroupSize| (((|List| (|Record| (|:| |factor| (|Integer|)) (|:| |exponent| (|Integer|))))) "\\spad{factorsOfCyclicGroupSize()} returns the factorization of \\spad{size()-1}")) (|conditionP| (((|Union| (|Vector| $) "failed") (|Matrix| $)) "\\spad{conditionP(mat)}, given a matrix representing a homogeneous system of equations, returns a vector whose characteristic'th powers is a non-trivial solution, or \"failed\" if no such vector exists.")) (|charthRoot| (($ $) "\\spad{charthRoot(a)} takes the characteristic'th root of a. Note that such a root is alway defined in finite fields."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|FunctionFieldIntegralBasis| R UP F) 
((|constructor| (NIL "Integral bases for function fields of dimension one In this package \\spad{R} is a Euclidean domain and \\spad{F} is a framed algebra over \\spad{R.} The package provides functions to compute the integral closure of \\spad{R} in the quotient field of \\spad{F.} It is assumed that \\spad{char(R/P) = char(R)} for any prime \\spad{P} of \\spad{R.} A typical instance of this is when \\spad{R = K[x]} and \\spad{F} is a function field over \\spad{R.}")) (|localIntegralBasis| (((|Record| (|:| |basis| (|Matrix| |#1|)) (|:| |basisDen| |#1|) (|:| |basisInv| (|Matrix| |#1|))) |#1|) "\\spad{integralBasis(p)} returns a record \\spad{[basis,basisDen,basisInv]} containing information regarding the local integral closure of \\spad{R} at the prime \\spad{p} in the quotient field of \\spad{F,} where \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the local integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}.")) (|integralBasis| (((|Record| (|:| |basis| (|Matrix| |#1|)) (|:| |basisDen| |#1|) (|:| |basisInv| (|Matrix| |#1|)))) "\\spad{integralBasis()} returns a record \\spad{[basis,basisDen,basisInv]} containing information regarding the integral closure of \\spad{R} in the quotient field of \\spad{F,} where \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}.")) (|squareFree| (((|Factored| $) $) "\\spad{squareFree(x)} returns a square-free factorisation of \\spad{x}"))) 
NIL 
NIL 
(|FiniteFieldNormalBasis| |p| |extdeg|) 
((|constructor| (NIL "FiniteFieldNormalBasis(p,n) implements a finite extension field of degree \\spad{n} over the prime field with \\spad{p} elements. The elements are represented by coordinate vectors with respect to a normal basis, \\spadignore{i.e.} a basis consisting of the conjugates (q-powers) of an element, in this case called normal element. This is chosen as a root of the extension polynomial created by createNormalPoly")) (|sizeMultiplication| (((|NonNegativeInteger|)) "\\spad{sizeMultiplication()} returns the number of entries in the multiplication table of the field. Note: The time of multiplication of field elements depends on this size.")) (|getMultiplicationMatrix| (((|Matrix| (|PrimeField| |#1|))) "\\spad{getMultiplicationMatrix()} returns the multiplication table in form of a matrix.")) (|getMultiplicationTable| (((|Vector| (|List| (|Record| (|:| |value| (|PrimeField| |#1|)) (|:| |index| (|SingleInteger|)))))) "\\spad{getMultiplicationTable()} returns the multiplication table for the normal basis of the field. This table is used to perform multiplications between field elements."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|PrimeField| |#1|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|PrimeField| |#1|) (QUOTE (|Finite|))) (|HasCategory| (|PrimeField| |#1|) (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| (|PrimeField| |#1|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|PrimeField| |#1|) (QUOTE (|Finite|))))) 
(|FiniteFieldNormalBasisExtensionByPolynomial| GF |uni|) 
((|constructor| (NIL "FiniteFieldNormalBasisExtensionByPolynomial(GF,uni) implements a finite extension of the ground field \\spad{GF.} The elements are represented by coordinate vectors with respect to. a normal basis, \\spadignore{i.e.} a basis consisting of the conjugates (q-powers) of an element, in this case called normal element, where \\spad{q} is the size of \\spad{GF.} The normal element is chosen as a root of the extension polynomial, which MUST be normal over \\spad{GF} (user responsibility)")) (|sizeMultiplication| (((|NonNegativeInteger|)) "\\spad{sizeMultiplication()} returns the number of entries in the multiplication table of the field. Note: the time of multiplication of field elements depends on this size.")) (|getMultiplicationMatrix| (((|Matrix| |#1|)) "\\spad{getMultiplicationMatrix()} returns the multiplication table in form of a matrix.")) (|getMultiplicationTable| (((|Vector| (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|)))))) "\\spad{getMultiplicationTable()} returns the multiplication table for the normal basis of the field. This table is used to perform multiplications between field elements."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|Finite|))))) 
(|FiniteFieldNormalBasisExtension| GF |extdeg|) 
((|constructor| (NIL "FiniteFieldNormalBasisExtensionByPolynomial(GF,n) implements a finite extension field of degree \\spad{n} over the ground field \\spad{GF.} The elements are represented by coordinate vectors with respect to a normal basis, \\spadignore{i.e.} a basis consisting of the conjugates (q-powers) of an element, in this case called normal element. This is chosen as a root of the extension polynomial, created by createNormalPoly from \\spadtype{FiniteFieldPolynomialPackage}")) (|sizeMultiplication| (((|NonNegativeInteger|)) "\\spad{sizeMultiplication()} returns the number of entries in the multiplication table of the field. Note: the time of multiplication of field elements depends on this size.")) (|getMultiplicationMatrix| (((|Matrix| |#1|)) "\\spad{getMultiplicationMatrix()} returns the multiplication table in form of a matrix.")) (|getMultiplicationTable| (((|Vector| (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|)))))) "\\spad{getMultiplicationTable()} returns the multiplication table for the normal basis of the field. This table is used to perform multiplications between field elements."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|Finite|))))) 
(|FiniteField| |p| |n|) 
((|constructor| (NIL "FiniteField(p,n) implements finite fields with p**n elements. This packages checks that \\spad{p} is prime. For a non-checking version, see \\spadtype{InnerFiniteField}."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|PrimeField| |#1|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|PrimeField| |#1|) (QUOTE (|Finite|))) (|HasCategory| (|PrimeField| |#1|) (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| (|PrimeField| |#1|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|PrimeField| |#1|) (QUOTE (|Finite|))))) 
(|FiniteFieldExtensionByPolynomial| GF |defpol|) 
((|constructor| (NIL "FiniteFieldExtensionByPolynomial(GF, defpol) implements the extension of the finite field \\spad{GF} generated by the extension polynomial defpol which MUST be irreducible."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|Finite|))))) 
(|FiniteFieldPolynomialPackage2| F GF) 
((|constructor| (NIL "FiniteFieldPolynomialPackage2(F,GF) exports some functions concerning finite fields, which depend on a finite field \\spad{GF} and an algebraic extension \\spad{F} of \\spad{GF,} \\spadignore{e.g.} a zero of a polynomial over \\spad{GF} in \\spad{F.}")) (|rootOfIrreduciblePoly| ((|#1| (|SparseUnivariatePolynomial| |#2|)) "\\spad{rootOfIrreduciblePoly(f)} computes one root of the monic, irreducible polynomial \\spad{f,} which degree must divide the extension degree of \\spad{F} over \\spad{GF,} \\spadignore{i.e.} \\spad{f} splits into linear factors over \\spad{F.}")) (|Frobenius| ((|#1| |#1|) "\\spad{Frobenius(x)} \\undocumented{}")) (|basis| (((|Vector| |#1|) (|PositiveInteger|)) "\\spad{basis(n)} \\undocumented{}")) (|lookup| (((|PositiveInteger|) |#1|) "\\spad{lookup(x)} \\undocumented{}")) (|coerce| ((|#1| |#2|) "\\spad{coerce(x)} \\undocumented{}"))) 
NIL 
NIL 
(|FiniteFieldPolynomialPackage| GF) 
((|constructor| (NIL "This package provides a number of functions for generating, counting and testing irreducible, normal, primitive, random polynomials over finite fields.")) (|reducedQPowers| (((|PrimitiveArray| (|SparseUnivariatePolynomial| |#1|)) (|SparseUnivariatePolynomial| |#1|)) "\\spad{reducedQPowers(f)} generates \\spad{[x,x**q,x**(q**2),...,x**(q**(n-1))]} reduced modulo \\spad{f} where \\spad{q = size()$GF} and \\spad{n = degree \\spad{f}.}")) (|leastAffineMultiple| (((|SparseUnivariatePolynomial| |#1|) (|SparseUnivariatePolynomial| |#1|)) "\\spad{leastAffineMultiple(f)} computes the least affine polynomial which is divisible by the polynomial \\spad{f} over the finite field \\spad{GF,} \\spadignore{i.e.} a polynomial whose exponents are 0 or a power of \\spad{q,} the size of \\spad{GF.}")) (|random| (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|) (|PositiveInteger|)) "\\spad{random(m,n)}$FFPOLY(GF) generates a random monic polynomial of degree \\spad{d} over the finite field \\spad{GF,} \\spad{d} between \\spad{m} and \\spad{n.}") (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|)) "\\spad{random(n)}$FFPOLY(GF) generates a random monic polynomial of degree \\spad{n} over the finite field \\spad{GF.}")) (|nextPrimitiveNormalPoly| (((|Union| (|SparseUnivariatePolynomial| |#1|) "failed") (|SparseUnivariatePolynomial| |#1|)) "\\spad{nextPrimitiveNormalPoly(f)} yields the next primitive normal polynomial over a finite field \\spad{GF} of the same degree as \\spad{f} in the following order, or \"failed\" if there are no greater ones. Error: if \\spad{f} has degree 0. Note that the input polynomial \\spad{f} is made monic. Also, \\spad{f < \\spad{g}} if the lookup of the constant term of \\spad{f} is less than this number for \\spad{g} or, in case these numbers are equal, if the lookup of the coefficient of the term of degree \\spad{n-1} of \\spad{f} is less than this number for \\spad{g.} If these numbers are equals, \\spad{f < \\spad{g}} if the number of monomials of \\spad{f} is less than that for \\spad{g,} or if the lists of exponents for \\spad{f} are lexicographically less than those for \\spad{g.} If these lists are also equal, the lists of coefficients are coefficients according to the lexicographic ordering induced by the ordering of the elements of \\spad{GF} given by lookup. This operation is equivalent to nextNormalPrimitivePoly(f).")) (|nextNormalPrimitivePoly| (((|Union| (|SparseUnivariatePolynomial| |#1|) "failed") (|SparseUnivariatePolynomial| |#1|)) "\\spad{nextNormalPrimitivePoly(f)} yields the next normal primitive polynomial over a finite field \\spad{GF} of the same degree as \\spad{f} in the following order, or \"failed\" if there are no greater ones. Error: if \\spad{f} has degree 0. Note that the input polynomial \\spad{f} is made monic. Also, \\spad{f < \\spad{g}} if the lookup of the constant term of \\spad{f} is less than this number for \\spad{g} or if lookup of the coefficient of the term of degree \\spad{n-1} of \\spad{f} is less than this number for \\spad{g.} Otherwise, \\spad{f < \\spad{g}} if the number of monomials of \\spad{f} is less than that for \\spad{g} or if the lists of exponents for \\spad{f} are lexicographically less than those for \\spad{g.} If these lists are also equal, the lists of coefficients are compared according to the lexicographic ordering induced by the ordering of the elements of \\spad{GF} given by lookup. This operation is equivalent to nextPrimitiveNormalPoly(f).")) (|nextNormalPoly| (((|Union| (|SparseUnivariatePolynomial| |#1|) "failed") (|SparseUnivariatePolynomial| |#1|)) "\\spad{nextNormalPoly(f)} yields the next normal polynomial over a finite field \\spad{GF} of the same degree as \\spad{f} in the following order, or \"failed\" if there are no greater ones. Error: if \\spad{f} has degree 0. Note that the input polynomial \\spad{f} is made monic. Also, \\spad{f < \\spad{g}} if the lookup of the coefficient of the term of degree \\spad{n-1} of \\spad{f} is less than that for \\spad{g.} In case these numbers are equal, \\spad{f < \\spad{g}} if if the number of monomials of \\spad{f} is less that for \\spad{g} or if the list of exponents of \\spad{f} are lexicographically less than the corresponding list for \\spad{g.} If these lists are also equal, the lists of coefficients are compared according to the lexicographic ordering induced by the ordering of the elements of \\spad{GF} given by lookup.")) (|nextPrimitivePoly| (((|Union| (|SparseUnivariatePolynomial| |#1|) "failed") (|SparseUnivariatePolynomial| |#1|)) "\\spad{nextPrimitivePoly(f)} yields the next primitive polynomial over a finite field \\spad{GF} of the same degree as \\spad{f} in the following order, or \"failed\" if there are no greater ones. Error: if \\spad{f} has degree 0. Note that the input polynomial \\spad{f} is made monic. Also, \\spad{f < \\spad{g}} if the lookup of the constant term of \\spad{f} is less than this number for \\spad{g.} If these values are equal, then \\spad{f < \\spad{g}} if if the number of monomials of \\spad{f} is less than that for \\spad{g} or if the lists of exponents of \\spad{f} are lexicographically less than the corresponding list for \\spad{g.} If these lists are also equal, the lists of coefficients are compared according to the lexicographic ordering induced by the ordering of the elements of \\spad{GF} given by lookup.")) (|nextIrreduciblePoly| (((|Union| (|SparseUnivariatePolynomial| |#1|) "failed") (|SparseUnivariatePolynomial| |#1|)) "\\spad{nextIrreduciblePoly(f)} yields the next monic irreducible polynomial over a finite field \\spad{GF} of the same degree as \\spad{f} in the following order, or \"failed\" if there are no greater ones. Error: if \\spad{f} has degree 0. Note that the input polynomial \\spad{f} is made monic. Also, \\spad{f < \\spad{g}} if the number of monomials of \\spad{f} is less than this number for \\spad{g.} If \\spad{f} and \\spad{g} have the same number of monomials, the lists of exponents are compared lexicographically. If these lists are also equal, the lists of coefficients are compared according to the lexicographic ordering induced by the ordering of the elements of \\spad{GF} given by lookup.")) (|createPrimitiveNormalPoly| (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|)) "\\spad{createPrimitiveNormalPoly(n)}$FFPOLY(GF) generates a normal and primitive polynomial of degree \\spad{n} over the field \\spad{GF.} polynomial of degree \\spad{n} over the field \\spad{GF.}")) (|createNormalPrimitivePoly| (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|)) "\\spad{createNormalPrimitivePoly(n)}$FFPOLY(GF) generates a normal and primitive polynomial of degree \\spad{n} over the field \\spad{GF.} Note that this function is equivalent to createPrimitiveNormalPoly(n)")) (|createNormalPoly| (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|)) "\\spad{createNormalPoly(n)}$FFPOLY(GF) generates a normal polynomial of degree \\spad{n} over the finite field \\spad{GF.}")) (|createPrimitivePoly| (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|)) "\\spad{createPrimitivePoly(n)}$FFPOLY(GF) generates a primitive polynomial of degree \\spad{n} over the finite field \\spad{GF.}")) (|createIrreduciblePoly| (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|)) "\\spad{createIrreduciblePoly(n)}$FFPOLY(GF) generates a monic irreducible univariate polynomial of degree \\spad{n} over the finite field \\spad{GF.}")) (|numberOfNormalPoly| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{numberOfNormalPoly(n)}$FFPOLY(GF) yields the number of normal polynomials of degree \\spad{n} over the finite field \\spad{GF.}")) (|numberOfPrimitivePoly| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{numberOfPrimitivePoly(n)}$FFPOLY(GF) yields the number of primitive polynomials of degree \\spad{n} over the finite field \\spad{GF.}")) (|numberOfIrreduciblePoly| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{numberOfIrreduciblePoly(n)}$FFPOLY(GF) yields the number of monic irreducible univariate polynomials of degree \\spad{n} over the finite field \\spad{GF.}")) (|normal?| (((|Boolean|) (|SparseUnivariatePolynomial| |#1|)) "\\spad{normal?(f)} tests whether the polynomial \\spad{f} over a finite field is normal, \\spadignore{i.e.} its roots are linearly independent over the field.")) (|primitive?| (((|Boolean|) (|SparseUnivariatePolynomial| |#1|)) "\\spad{primitive?(f)} tests whether the polynomial \\spad{f} over a finite field is primitive, \\spadignore{i.e.} all its roots are primitive."))) 
NIL 
NIL 
(|FiniteFieldSolveLinearPolynomialEquation| F FP FPP) 
((|constructor| (NIL "This package solves linear diophantine equations for Bivariate polynomials over finite fields")) (|solveLinearPolynomialEquation| (((|Union| (|List| |#3|) "failed") (|List| |#3|) |#3|) "\\spad{solveLinearPolynomialEquation([f1, ..., fn], \\spad{g)}} (where the \\spad{fi} are relatively prime to each other) returns a list of \\spad{ai} such that \\spad{g/prod \\spad{fi} = sum ai/fi} or returns \"failed\" if no such list of ai's exists."))) 
NIL 
NIL 
(|FiniteFieldSquareFreeDecomposition| K |PolK|) 
((|constructor| (NIL "Part of the package for Algebraic Function Fields in one variable (PAFF)"))) 
NIL 
NIL 
(|FiniteFieldExtension| GF |n|) 
((|constructor| (NIL "FiniteFieldExtensionByPolynomial(GF, \\spad{n)} implements an extension of the finite field \\spad{GF} of degree \\spad{n} generated by the extension polynomial constructed by createIrreduciblePoly from \\spadtype{FiniteFieldPolynomialPackage}."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|Finite|))))) 
(|FGLMIfCanPackage| R |ls|) 
((|constructor| (NIL "This is just an interface between several packages and domains. The goal is to compute lexicographical Groebner bases of sets of polynomial with type \\spadtype{Polynomial \\spad{R}} by the FGLM algorithm if this is possible (\\spadignore{i.e.} if the input system generates a zero-dimensional ideal).")) (|groebner| (((|List| (|Polynomial| |#1|)) (|List| (|Polynomial| |#1|))) "\\axiom{groebner(lq1)} returns the lexicographical Groebner basis of \\axiom{lq1}. If \\axiom{lq1} generates a zero-dimensional ideal then the FGLM strategy is used, otherwise the Sugar strategy is used.")) (|fglmIfCan| (((|Union| (|List| (|Polynomial| |#1|)) "failed") (|List| (|Polynomial| |#1|))) "\\axiom{fglmIfCan(lq1)} returns the lexicographical Groebner basis of \\axiom{lq1} by using the FGLM strategy, if \\axiom{zeroDimensional?(lq1)} holds.")) (|zeroDimensional?| (((|Boolean|) (|List| (|Polynomial| |#1|))) "\\axiom{zeroDimensional?(lq1)} returns \\spad{true} iff \\axiom{lq1} generates a zero-dimensional ideal w.r.t. the variables of \\axiom{ls}."))) 
NIL 
NIL 
(|FreeGroup| S) 
((|constructor| (NIL "Free group on any set of generators The free group on a set \\spad{S} is the group of finite products of the form \\spad{reduce(*,[si \\spad{**} ni])} where the si's are in \\spad{S,} and the ni's are integers. The multiplication is not commutative.")) (|factors| (((|List| (|Record| (|:| |gen| |#1|) (|:| |exp| (|Integer|)))) $) "\\spad{factors(a1\\^e1,...,an\\^en)} returns \\spad{[[a1, e1],...,[an, en]]}.")) (|mapGen| (($ (|Mapping| |#1| |#1|) $) "\\spad{mapGen(f, \\spad{a1\\^e1} \\spad{...} an\\^en)} returns \\spad{f(a1)\\^e1 \\spad{...} f(an)\\^en}.")) (|mapExpon| (($ (|Mapping| (|Integer|) (|Integer|)) $) "\\spad{mapExpon(f, \\spad{a1\\^e1} \\spad{...} an\\^en)} returns \\spad{a1\\^f(e1) \\spad{...} an\\^f(en)}.")) (|nthFactor| ((|#1| $ (|Integer|)) "\\spad{nthFactor(x, \\spad{n)}} returns the factor of the n^th monomial of \\spad{x.}")) (|nthExpon| (((|Integer|) $ (|Integer|)) "\\spad{nthExpon(x, \\spad{n)}} returns the exponent of the n^th monomial of \\spad{x.}")) (|size| (((|NonNegativeInteger|) $) "\\spad{size(x)} returns the number of monomials in \\spad{x.}")) (** (($ |#1| (|Integer|)) "\\spad{s \\spad{**} \\spad{n}} returns the product of \\spad{s} by itself \\spad{n} times.")) (* (($ $ |#1|) "\\spad{x * \\spad{s}} returns the product of \\spad{x} by \\spad{s} on the right.") (($ |#1| $) "\\spad{s * \\spad{x}} returns the product of \\spad{x} by \\spad{s} on the left."))) 
((|unitsKnown| . T)) 
NIL 
(|Field&| S) 
((|constructor| (NIL "The category of commutative fields, \\spadignore{i.e.} commutative rings where all non-zero elements have multiplicative inverses. The \\spadfun{factor} operation while trivial is useful to have defined. \\blankline Axioms\\br \\tab{5}\\spad{a*(b/a) = b}\\br \\tab{5}\\spad{inv(a) = 1/a}")) (|canonicalsClosed| ((|attribute|) "since \\spad{0*0=0}, \\spad{1*1=1}")) (|canonicalUnitNormal| ((|attribute|) "either 0 or 1.")) (/ (($ $ $) "\\spad{x/y} divides the element \\spad{x} by the element \\spad{y.} Error: if \\spad{y} is 0."))) 
NIL 
NIL 
(|Field|) 
((|constructor| (NIL "The category of commutative fields, \\spadignore{i.e.} commutative rings where all non-zero elements have multiplicative inverses. The \\spadfun{factor} operation while trivial is useful to have defined. \\blankline Axioms\\br \\tab{5}\\spad{a*(b/a) = b}\\br \\tab{5}\\spad{inv(a) = 1/a}")) (|canonicalsClosed| ((|attribute|) "since \\spad{0*0=0}, \\spad{1*1=1}")) (|canonicalUnitNormal| ((|attribute|) "either 0 or 1.")) (/ (($ $ $) "\\spad{x/y} divides the element \\spad{x} by the element \\spad{y.} Error: if \\spad{y} is 0."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|FileCategory| |Name| S) 
((|constructor| (NIL "This category provides an interface to operate on files in the computer's file system. The precise method of naming files is determined by the Name parameter. The type of the contents of the file is determined by \\spad{S.}")) (|flush| (((|Void|) $) "\\spad{flush(f)} makes sure that buffered data is written out")) (|write!| ((|#2| $ |#2|) "\\spad{write!(f,s)} puts the value \\spad{s} into the file \\spad{f.} The state of \\spad{f} is modified so subsequents call to \\spad{write!} will append one after another.")) (|read!| ((|#2| $) "\\spad{read!(f)} extracts a value from file \\spad{f.} The state of \\spad{f} is modified so a subsequent call to \\spadfun{read!} will return the next element.")) (|iomode| (((|String|) $) "\\spad{iomode(f)} returns the status of the file \\spad{f.} The input/output status of \\spad{f} may be \"input\", \"output\" or \"closed\" mode.")) (|name| ((|#1| $) "\\spad{name(f)} returns the external name of the file \\spad{f.}")) (|close!| (($ $) "\\spad{close!(f)} returns the file \\spad{f} closed to input and output.")) (|reopen!| (($ $ (|String|)) "\\spad{reopen!(f,mode)} returns a file \\spad{f} reopened for operation in the indicated mode: \"input\" or \"output\". \\spad{reopen!(f,\"input\")} will reopen the file \\spad{f} for input.")) (|open| (($ |#1| (|String|)) "\\spad{open(s,mode)} returns a file \\spad{s} open for operation in the indicated mode: \"input\" or \"output\".") (($ |#1|) "\\spad{open(s)} returns the file \\spad{s} open for input."))) 
NIL 
NIL 
(|File| S) 
((|constructor| (NIL "This domain provides a basic model of files to save arbitrary values. The operations provide sequential access to the contents.")) (|readIfCan!| (((|Union| |#1| "failed") $) "\\spad{readIfCan!(f)} returns a value from the file \\spad{f,} if possible. If \\spad{f} is not open for reading, or if \\spad{f} is at the end of file then \\spad{\"failed\"} is the result."))) 
NIL 
NIL 
(|FiniteRankNonAssociativeAlgebra&| S R) 
((|constructor| (NIL "A FiniteRankNonAssociativeAlgebra is a non associative algebra over a commutative ring \\spad{R} which is a free \\spad{R}-module of finite rank.")) (|unitsKnown| ((|attribute|) "unitsKnown means that \\spadfun{recip} truly yields reciprocal or \\spad{\"failed\"} if not a unit, similarly for \\spadfun{leftRecip} and \\spadfun{rightRecip}. The reason is that we use left, respectively right, minimal polynomials to decide this question.")) (|unit| (((|Union| $ "failed")) "\\spad{unit()} returns a unit of the algebra (necessarily unique), or \\spad{\"failed\"} if there is none.")) (|rightUnit| (((|Union| $ "failed")) "\\spad{rightUnit()} returns a right unit of the algebra (not necessarily unique), or \\spad{\"failed\"} if there is none.")) (|leftUnit| (((|Union| $ "failed")) "\\spad{leftUnit()} returns a left unit of the algebra (not necessarily unique), or \\spad{\"failed\"} if there is none.")) (|rightUnits| (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $))) "failed")) "\\spad{rightUnits()} returns the affine space of all right units of the algebra, or \\spad{\"failed\"} if there is none.")) (|leftUnits| (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $))) "failed")) "\\spad{leftUnits()} returns the affine space of all left units of the algebra, or \\spad{\"failed\"} if there is none.")) (|rightMinimalPolynomial| (((|SparseUnivariatePolynomial| |#2|) $) "\\spad{rightMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of right powers of \\spad{a}. Note that the polynomial never has a constant term as in general the algebra has no unit.")) (|leftMinimalPolynomial| (((|SparseUnivariatePolynomial| |#2|) $) "\\spad{leftMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of left powers of \\spad{a}. Note that the polynomial never has a constant term as in general the algebra has no unit.")) (|associatorDependence| (((|List| (|Vector| |#2|))) "\\spad{associatorDependence()} looks for the associator identities, that is, finds a basis of the solutions of the linear combinations of the six permutations of \\spad{associator(a,b,c)} which yield 0, for all \\spad{a},b,c in the algebra. The order of the permutations is \\spad{123 231 312 132 321 213}.")) (|rightRecip| (((|Union| $ "failed") $) "\\spad{rightRecip(a)} returns an element, which is a right inverse of \\spad{a}, or \\spad{\"failed\"} if there is no unit element, if such an element doesn't exist or cannot be determined (see unitsKnown).")) (|leftRecip| (((|Union| $ "failed") $) "\\spad{leftRecip(a)} returns an element, which is a left inverse of \\spad{a}, or \\spad{\"failed\"} if there is no unit element, if such an element doesn't exist or cannot be determined (see unitsKnown).")) (|recip| (((|Union| $ "failed") $) "\\spad{recip(a)} returns an element, which is both a left and a right inverse of \\spad{a}, or \\spad{\"failed\"} if there is no unit element, if such an element doesn't exist or cannot be determined (see unitsKnown).")) (|lieAlgebra?| (((|Boolean|)) "\\spad{lieAlgebra?()} tests if the algebra is anticommutative and \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \\spad{a},b,c in the algebra (Jacobi identity). Example: for every associative algebra \\spad{(A,+,@)} we can construct a Lie algebra \\spad{(A,+,*)}, where \\spad{a*b \\spad{:=} a@b-b@a}.")) (|jordanAlgebra?| (((|Boolean|)) "\\spad{jordanAlgebra?()} tests if the algebra is commutative, characteristic is not 2, and \\spad{(a*b)*a**2 - a*(b*a**2) = 0} for all \\spad{a},b,c in the algebra (Jordan identity). Example: for every associative algebra \\spad{(A,+,@)} we can construct a Jordan algebra \\spad{(A,+,*)}, where \\spad{a*b \\spad{:=} (a@b+b@a)/2}.")) (|noncommutativeJordanAlgebra?| (((|Boolean|)) "\\spad{noncommutativeJordanAlgebra?()} tests if the algebra is flexible and Jordan admissible.")) (|jordanAdmissible?| (((|Boolean|)) "\\spad{jordanAdmissible?()} tests if 2 is invertible in the coefficient domain and the multiplication defined by \\spad{(1/2)(a*b+b*a)} determines a Jordan algebra, that is, satisfies the Jordan identity. The property of \\spadatt{commutative(\"*\")} follows from by definition.")) (|lieAdmissible?| (((|Boolean|)) "\\spad{lieAdmissible?()} tests if the algebra defined by the commutators is a Lie algebra, that is, satisfies the Jacobi identity. The property of anticommutativity follows from definition.")) (|jacobiIdentity?| (((|Boolean|)) "\\spad{jacobiIdentity?()} tests if \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \\spad{a},b,c in the algebra. For example, this holds for crossed products of 3-dimensional vectors.")) (|powerAssociative?| (((|Boolean|)) "\\spad{powerAssociative?()} tests if all subalgebras generated by a single element are associative.")) (|alternative?| (((|Boolean|)) "\\spad{alternative?()} tests if \\spad{2*associator(a,a,b) = 0 = 2*associator(a,b,b)} for all \\spad{a}, \\spad{b} in the algebra. Note that we only can test this; in general we don't know whether \\spad{2*a=0} implies \\spad{a=0}.")) (|flexible?| (((|Boolean|)) "\\spad{flexible?()} tests if \\spad{2*associator(a,b,a) = 0} for all \\spad{a}, \\spad{b} in the algebra. Note that we only can test this; in general we don't know whether \\spad{2*a=0} implies \\spad{a=0}.")) (|rightAlternative?| (((|Boolean|)) "\\spad{rightAlternative?()} tests if \\spad{2*associator(a,b,b) = 0} for all \\spad{a}, \\spad{b} in the algebra. Note that we only can test this; in general we don't know whether \\spad{2*a=0} implies \\spad{a=0}.")) (|leftAlternative?| (((|Boolean|)) "\\spad{leftAlternative?()} tests if \\spad{2*associator(a,a,b) = 0} for all \\spad{a}, \\spad{b} in the algebra. Note that we only can test this; in general we don't know whether \\spad{2*a=0} implies \\spad{a=0}.")) (|antiAssociative?| (((|Boolean|)) "\\spad{antiAssociative?()} tests if multiplication in algebra is anti-associative, that is, \\spad{(a*b)*c + a*(b*c) = 0} for all \\spad{a},b,c in the algebra.")) (|associative?| (((|Boolean|)) "\\spad{associative?()} tests if multiplication in algebra is associative.")) (|antiCommutative?| (((|Boolean|)) "\\spad{antiCommutative?()} tests if \\spad{a*a = 0} for all \\spad{a} in the algebra. Note that this implies \\spad{a*b + b*a = 0} for all \\spad{a} and \\spad{b}.")) (|commutative?| (((|Boolean|)) "\\spad{commutative?()} tests if multiplication in the algebra is commutative.")) (|rightCharacteristicPolynomial| (((|SparseUnivariatePolynomial| |#2|) $) "\\spad{rightCharacteristicPolynomial(a)} returns the characteristic polynomial of the right regular representation of \\spad{a} with respect to any basis.")) (|leftCharacteristicPolynomial| (((|SparseUnivariatePolynomial| |#2|) $) "\\spad{leftCharacteristicPolynomial(a)} returns the characteristic polynomial of the left regular representation of \\spad{a} with respect to any basis.")) (|rightTraceMatrix| (((|Matrix| |#2|) (|Vector| $)) "\\spad{rightTraceMatrix([v1,...,vn])} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the right trace of the product \\spad{vi*vj}.")) (|leftTraceMatrix| (((|Matrix| |#2|) (|Vector| $)) "\\spad{leftTraceMatrix([v1,...,vn])} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the left trace of the product \\spad{vi*vj}.")) (|rightDiscriminant| ((|#2| (|Vector| $)) "\\spad{rightDiscriminant([v1,...,vn])} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the right trace of the product \\spad{vi*vj}. Note that this is the same as \\spad{determinant(rightTraceMatrix([v1,...,vn]))}.")) (|leftDiscriminant| ((|#2| (|Vector| $)) "\\spad{leftDiscriminant([v1,...,vn])} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the left trace of the product \\spad{vi*vj}. Note that this is the same as \\spad{determinant(leftTraceMatrix([v1,...,vn]))}.")) (|represents| (($ (|Vector| |#2|) (|Vector| $)) "\\spad{represents([a1,...,am],[v1,...,vm])} returns the linear combination \\spad{a1*vm + \\spad{...} + an*vm}.")) (|coordinates| (((|Matrix| |#2|) (|Vector| $) (|Vector| $)) "\\spad{coordinates([a1,...,am],[v1,...,vn])} returns a matrix whose \\spad{i}-th row is formed by the coordinates of \\spad{ai} with respect to the \\spad{R}-module basis \\spad{v1},...,\\spad{vn}.") (((|Vector| |#2|) $ (|Vector| $)) "\\spad{coordinates(a,[v1,...,vn])} returns the coordinates of \\spad{a} with respect to the \\spad{R}-module basis \\spad{v1},...,\\spad{vn}.")) (|rightNorm| ((|#2| $) "\\spad{rightNorm(a)} returns the determinant of the right regular representation of \\spad{a}.")) (|leftNorm| ((|#2| $) "\\spad{leftNorm(a)} returns the determinant of the left regular representation of \\spad{a}.")) (|rightTrace| ((|#2| $) "\\spad{rightTrace(a)} returns the trace of the right regular representation of \\spad{a}.")) (|leftTrace| ((|#2| $) "\\spad{leftTrace(a)} returns the trace of the left regular representation of \\spad{a}.")) (|rightRegularRepresentation| (((|Matrix| |#2|) $ (|Vector| $)) "\\spad{rightRegularRepresentation(a,[v1,...,vn])} returns the matrix of the linear map defined by right multiplication by \\spad{a} with respect to the \\spad{R}-module basis \\spad{[v1,...,vn]}.")) (|leftRegularRepresentation| (((|Matrix| |#2|) $ (|Vector| $)) "\\spad{leftRegularRepresentation(a,[v1,...,vn])} returns the matrix of the linear map defined by left multiplication by \\spad{a} with respect to the \\spad{R}-module basis \\spad{[v1,...,vn]}.")) (|structuralConstants| (((|Vector| (|Matrix| |#2|)) (|Vector| $)) "\\spad{structuralConstants([v1,v2,...,vm])} calculates the structural constants \\spad{[(gammaijk) for \\spad{k} in 1..m]} defined by \\spad{vi * \\spad{vj} = \\spad{gammaij1} * \\spad{v1} + \\spad{...} + gammaijm * vm}, where \\spad{[v1,...,vm]} is an \\spad{R}-module basis of a subalgebra.")) (|conditionsForIdempotents| (((|List| (|Polynomial| |#2|)) (|Vector| $)) "\\spad{conditionsForIdempotents([v1,...,vn])} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the \\spad{R}-module basis \\spad{v1},...,\\spad{vn}.")) (|rank| (((|PositiveInteger|)) "\\spad{rank()} returns the rank of the algebra as \\spad{R}-module.")) (|someBasis| (((|Vector| $)) "\\spad{someBasis()} returns some \\spad{R}-module basis."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) 
(|FiniteRankNonAssociativeAlgebra| R) 
((|constructor| (NIL "A FiniteRankNonAssociativeAlgebra is a non associative algebra over a commutative ring \\spad{R} which is a free \\spad{R}-module of finite rank.")) (|unitsKnown| ((|attribute|) "unitsKnown means that \\spadfun{recip} truly yields reciprocal or \\spad{\"failed\"} if not a unit, similarly for \\spadfun{leftRecip} and \\spadfun{rightRecip}. The reason is that we use left, respectively right, minimal polynomials to decide this question.")) (|unit| (((|Union| $ "failed")) "\\spad{unit()} returns a unit of the algebra (necessarily unique), or \\spad{\"failed\"} if there is none.")) (|rightUnit| (((|Union| $ "failed")) "\\spad{rightUnit()} returns a right unit of the algebra (not necessarily unique), or \\spad{\"failed\"} if there is none.")) (|leftUnit| (((|Union| $ "failed")) "\\spad{leftUnit()} returns a left unit of the algebra (not necessarily unique), or \\spad{\"failed\"} if there is none.")) (|rightUnits| (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $))) "failed")) "\\spad{rightUnits()} returns the affine space of all right units of the algebra, or \\spad{\"failed\"} if there is none.")) (|leftUnits| (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $))) "failed")) "\\spad{leftUnits()} returns the affine space of all left units of the algebra, or \\spad{\"failed\"} if there is none.")) (|rightMinimalPolynomial| (((|SparseUnivariatePolynomial| |#1|) $) "\\spad{rightMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of right powers of \\spad{a}. Note that the polynomial never has a constant term as in general the algebra has no unit.")) (|leftMinimalPolynomial| (((|SparseUnivariatePolynomial| |#1|) $) "\\spad{leftMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of left powers of \\spad{a}. Note that the polynomial never has a constant term as in general the algebra has no unit.")) (|associatorDependence| (((|List| (|Vector| |#1|))) "\\spad{associatorDependence()} looks for the associator identities, that is, finds a basis of the solutions of the linear combinations of the six permutations of \\spad{associator(a,b,c)} which yield 0, for all \\spad{a},b,c in the algebra. The order of the permutations is \\spad{123 231 312 132 321 213}.")) (|rightRecip| (((|Union| $ "failed") $) "\\spad{rightRecip(a)} returns an element, which is a right inverse of \\spad{a}, or \\spad{\"failed\"} if there is no unit element, if such an element doesn't exist or cannot be determined (see unitsKnown).")) (|leftRecip| (((|Union| $ "failed") $) "\\spad{leftRecip(a)} returns an element, which is a left inverse of \\spad{a}, or \\spad{\"failed\"} if there is no unit element, if such an element doesn't exist or cannot be determined (see unitsKnown).")) (|recip| (((|Union| $ "failed") $) "\\spad{recip(a)} returns an element, which is both a left and a right inverse of \\spad{a}, or \\spad{\"failed\"} if there is no unit element, if such an element doesn't exist or cannot be determined (see unitsKnown).")) (|lieAlgebra?| (((|Boolean|)) "\\spad{lieAlgebra?()} tests if the algebra is anticommutative and \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \\spad{a},b,c in the algebra (Jacobi identity). Example: for every associative algebra \\spad{(A,+,@)} we can construct a Lie algebra \\spad{(A,+,*)}, where \\spad{a*b \\spad{:=} a@b-b@a}.")) (|jordanAlgebra?| (((|Boolean|)) "\\spad{jordanAlgebra?()} tests if the algebra is commutative, characteristic is not 2, and \\spad{(a*b)*a**2 - a*(b*a**2) = 0} for all \\spad{a},b,c in the algebra (Jordan identity). Example: for every associative algebra \\spad{(A,+,@)} we can construct a Jordan algebra \\spad{(A,+,*)}, where \\spad{a*b \\spad{:=} (a@b+b@a)/2}.")) (|noncommutativeJordanAlgebra?| (((|Boolean|)) "\\spad{noncommutativeJordanAlgebra?()} tests if the algebra is flexible and Jordan admissible.")) (|jordanAdmissible?| (((|Boolean|)) "\\spad{jordanAdmissible?()} tests if 2 is invertible in the coefficient domain and the multiplication defined by \\spad{(1/2)(a*b+b*a)} determines a Jordan algebra, that is, satisfies the Jordan identity. The property of \\spadatt{commutative(\"*\")} follows from by definition.")) (|lieAdmissible?| (((|Boolean|)) "\\spad{lieAdmissible?()} tests if the algebra defined by the commutators is a Lie algebra, that is, satisfies the Jacobi identity. The property of anticommutativity follows from definition.")) (|jacobiIdentity?| (((|Boolean|)) "\\spad{jacobiIdentity?()} tests if \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \\spad{a},b,c in the algebra. For example, this holds for crossed products of 3-dimensional vectors.")) (|powerAssociative?| (((|Boolean|)) "\\spad{powerAssociative?()} tests if all subalgebras generated by a single element are associative.")) (|alternative?| (((|Boolean|)) "\\spad{alternative?()} tests if \\spad{2*associator(a,a,b) = 0 = 2*associator(a,b,b)} for all \\spad{a}, \\spad{b} in the algebra. Note that we only can test this; in general we don't know whether \\spad{2*a=0} implies \\spad{a=0}.")) (|flexible?| (((|Boolean|)) "\\spad{flexible?()} tests if \\spad{2*associator(a,b,a) = 0} for all \\spad{a}, \\spad{b} in the algebra. Note that we only can test this; in general we don't know whether \\spad{2*a=0} implies \\spad{a=0}.")) (|rightAlternative?| (((|Boolean|)) "\\spad{rightAlternative?()} tests if \\spad{2*associator(a,b,b) = 0} for all \\spad{a}, \\spad{b} in the algebra. Note that we only can test this; in general we don't know whether \\spad{2*a=0} implies \\spad{a=0}.")) (|leftAlternative?| (((|Boolean|)) "\\spad{leftAlternative?()} tests if \\spad{2*associator(a,a,b) = 0} for all \\spad{a}, \\spad{b} in the algebra. Note that we only can test this; in general we don't know whether \\spad{2*a=0} implies \\spad{a=0}.")) (|antiAssociative?| (((|Boolean|)) "\\spad{antiAssociative?()} tests if multiplication in algebra is anti-associative, that is, \\spad{(a*b)*c + a*(b*c) = 0} for all \\spad{a},b,c in the algebra.")) (|associative?| (((|Boolean|)) "\\spad{associative?()} tests if multiplication in algebra is associative.")) (|antiCommutative?| (((|Boolean|)) "\\spad{antiCommutative?()} tests if \\spad{a*a = 0} for all \\spad{a} in the algebra. Note that this implies \\spad{a*b + b*a = 0} for all \\spad{a} and \\spad{b}.")) (|commutative?| (((|Boolean|)) "\\spad{commutative?()} tests if multiplication in the algebra is commutative.")) (|rightCharacteristicPolynomial| (((|SparseUnivariatePolynomial| |#1|) $) "\\spad{rightCharacteristicPolynomial(a)} returns the characteristic polynomial of the right regular representation of \\spad{a} with respect to any basis.")) (|leftCharacteristicPolynomial| (((|SparseUnivariatePolynomial| |#1|) $) "\\spad{leftCharacteristicPolynomial(a)} returns the characteristic polynomial of the left regular representation of \\spad{a} with respect to any basis.")) (|rightTraceMatrix| (((|Matrix| |#1|) (|Vector| $)) "\\spad{rightTraceMatrix([v1,...,vn])} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the right trace of the product \\spad{vi*vj}.")) (|leftTraceMatrix| (((|Matrix| |#1|) (|Vector| $)) "\\spad{leftTraceMatrix([v1,...,vn])} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the left trace of the product \\spad{vi*vj}.")) (|rightDiscriminant| ((|#1| (|Vector| $)) "\\spad{rightDiscriminant([v1,...,vn])} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the right trace of the product \\spad{vi*vj}. Note that this is the same as \\spad{determinant(rightTraceMatrix([v1,...,vn]))}.")) (|leftDiscriminant| ((|#1| (|Vector| $)) "\\spad{leftDiscriminant([v1,...,vn])} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the left trace of the product \\spad{vi*vj}. Note that this is the same as \\spad{determinant(leftTraceMatrix([v1,...,vn]))}.")) (|represents| (($ (|Vector| |#1|) (|Vector| $)) "\\spad{represents([a1,...,am],[v1,...,vm])} returns the linear combination \\spad{a1*vm + \\spad{...} + an*vm}.")) (|coordinates| (((|Matrix| |#1|) (|Vector| $) (|Vector| $)) "\\spad{coordinates([a1,...,am],[v1,...,vn])} returns a matrix whose \\spad{i}-th row is formed by the coordinates of \\spad{ai} with respect to the \\spad{R}-module basis \\spad{v1},...,\\spad{vn}.") (((|Vector| |#1|) $ (|Vector| $)) "\\spad{coordinates(a,[v1,...,vn])} returns the coordinates of \\spad{a} with respect to the \\spad{R}-module basis \\spad{v1},...,\\spad{vn}.")) (|rightNorm| ((|#1| $) "\\spad{rightNorm(a)} returns the determinant of the right regular representation of \\spad{a}.")) (|leftNorm| ((|#1| $) "\\spad{leftNorm(a)} returns the determinant of the left regular representation of \\spad{a}.")) (|rightTrace| ((|#1| $) "\\spad{rightTrace(a)} returns the trace of the right regular representation of \\spad{a}.")) (|leftTrace| ((|#1| $) "\\spad{leftTrace(a)} returns the trace of the left regular representation of \\spad{a}.")) (|rightRegularRepresentation| (((|Matrix| |#1|) $ (|Vector| $)) "\\spad{rightRegularRepresentation(a,[v1,...,vn])} returns the matrix of the linear map defined by right multiplication by \\spad{a} with respect to the \\spad{R}-module basis \\spad{[v1,...,vn]}.")) (|leftRegularRepresentation| (((|Matrix| |#1|) $ (|Vector| $)) "\\spad{leftRegularRepresentation(a,[v1,...,vn])} returns the matrix of the linear map defined by left multiplication by \\spad{a} with respect to the \\spad{R}-module basis \\spad{[v1,...,vn]}.")) (|structuralConstants| (((|Vector| (|Matrix| |#1|)) (|Vector| $)) "\\spad{structuralConstants([v1,v2,...,vm])} calculates the structural constants \\spad{[(gammaijk) for \\spad{k} in 1..m]} defined by \\spad{vi * \\spad{vj} = \\spad{gammaij1} * \\spad{v1} + \\spad{...} + gammaijm * vm}, where \\spad{[v1,...,vm]} is an \\spad{R}-module basis of a subalgebra.")) (|conditionsForIdempotents| (((|List| (|Polynomial| |#1|)) (|Vector| $)) "\\spad{conditionsForIdempotents([v1,...,vn])} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the \\spad{R}-module basis \\spad{v1},...,\\spad{vn}.")) (|rank| (((|PositiveInteger|)) "\\spad{rank()} returns the rank of the algebra as \\spad{R}-module.")) (|someBasis| (((|Vector| $)) "\\spad{someBasis()} returns some \\spad{R}-module basis."))) 
((|unitsKnown| |has| |#1| (|IntegralDomain|)) (|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|Finite&| S) 
((|constructor| (NIL "The category of domains composed of a finite set of elements. We include the functions \\spadfun{lookup} and \\spadfun{index} to give a bijection between the finite set and an initial segment of positive integers. \\blankline")) (|enumerate| (((|List| $)) "\\indented{1}{enumerate() returns a list of elements of the set} \\blankline \\spad{X} enumerate()$OrderedVariableList([p,q])")) (|random| (($) "\\spad{random()} returns a random element from the set.")) (|lookup| (((|PositiveInteger|) $) "\\spad{lookup(x)} returns a positive integer such that \\spad{x = index lookup \\spad{x}.}")) (|index| (($ (|PositiveInteger|)) "\\spad{index(i)} takes a positive integer \\spad{i} less than or equal to \\spad{size()} and returns the \\spad{i}-th element of the set. This operation establishs a bijection between the elements of the finite set and \\spad{1..size()}.")) (|size| (((|NonNegativeInteger|)) "\\spad{size()} returns the number of elements in the set."))) 
NIL 
NIL 
(|Finite|) 
((|constructor| (NIL "The category of domains composed of a finite set of elements. We include the functions \\spadfun{lookup} and \\spadfun{index} to give a bijection between the finite set and an initial segment of positive integers. \\blankline")) (|enumerate| (((|List| $)) "\\indented{1}{enumerate() returns a list of elements of the set} \\blankline \\spad{X} enumerate()$OrderedVariableList([p,q])")) (|random| (($) "\\spad{random()} returns a random element from the set.")) (|lookup| (((|PositiveInteger|) $) "\\spad{lookup(x)} returns a positive integer such that \\spad{x = index lookup \\spad{x}.}")) (|index| (($ (|PositiveInteger|)) "\\spad{index(i)} takes a positive integer \\spad{i} less than or equal to \\spad{size()} and returns the \\spad{i}-th element of the set. This operation establishs a bijection between the elements of the finite set and \\spad{1..size()}.")) (|size| (((|NonNegativeInteger|)) "\\spad{size()} returns the number of elements in the set."))) 
NIL 
NIL 
(|FiniteRankAlgebra&| S R UP) 
((|constructor| (NIL "A FiniteRankAlgebra is an algebra over a commutative ring \\spad{R} which is a free R-module of finite rank.")) (|minimalPolynomial| ((|#3| $) "\\spad{minimalPolynomial(a)} returns the minimal polynomial of \\spad{a}.")) (|characteristicPolynomial| ((|#3| $) "\\spad{characteristicPolynomial(a)} returns the characteristic polynomial of the regular representation of \\spad{a} with respect to any basis.")) (|traceMatrix| (((|Matrix| |#2|) (|Vector| $)) "\\spad{traceMatrix([v1,..,vn])} is the n-by-n matrix ( Tr(vi * \\spad{vj)} )")) (|discriminant| ((|#2| (|Vector| $)) "\\spad{discriminant([v1,..,vn])} returns \\spad{determinant(traceMatrix([v1,..,vn]))}.")) (|represents| (($ (|Vector| |#2|) (|Vector| $)) "\\spad{represents([a1,..,an],[v1,..,vn])} returns \\spad{a1*v1+...+an*vn}.")) (|coordinates| (((|Matrix| |#2|) (|Vector| $) (|Vector| $)) "\\spad{coordinates([v1,...,vm], basis)} returns the coordinates of the vi's with to the basis \\spad{basis}. The coordinates of \\spad{vi} are contained in the \\spad{i}th row of the matrix returned by this function.") (((|Vector| |#2|) $ (|Vector| $)) "\\spad{coordinates(a,basis)} returns the coordinates of \\spad{a} with respect to the \\spad{basis} \\spad{basis}.")) (|norm| ((|#2| $) "\\spad{norm(a)} returns the determinant of the regular representation of \\spad{a} with respect to any basis.")) (|trace| ((|#2| $) "\\spad{trace(a)} returns the trace of the regular representation of \\spad{a} with respect to any basis.")) (|regularRepresentation| (((|Matrix| |#2|) $ (|Vector| $)) "\\spad{regularRepresentation(a,basis)} returns the matrix of the linear map defined by left multiplication by \\spad{a} with respect to the \\spad{basis} \\spad{basis}.")) (|rank| (((|PositiveInteger|)) "\\spad{rank()} returns the rank of the algebra."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (QUOTE (|Field|)))) 
(|FiniteRankAlgebra| R UP) 
((|constructor| (NIL "A FiniteRankAlgebra is an algebra over a commutative ring \\spad{R} which is a free R-module of finite rank.")) (|minimalPolynomial| ((|#2| $) "\\spad{minimalPolynomial(a)} returns the minimal polynomial of \\spad{a}.")) (|characteristicPolynomial| ((|#2| $) "\\spad{characteristicPolynomial(a)} returns the characteristic polynomial of the regular representation of \\spad{a} with respect to any basis.")) (|traceMatrix| (((|Matrix| |#1|) (|Vector| $)) "\\spad{traceMatrix([v1,..,vn])} is the n-by-n matrix ( Tr(vi * \\spad{vj)} )")) (|discriminant| ((|#1| (|Vector| $)) "\\spad{discriminant([v1,..,vn])} returns \\spad{determinant(traceMatrix([v1,..,vn]))}.")) (|represents| (($ (|Vector| |#1|) (|Vector| $)) "\\spad{represents([a1,..,an],[v1,..,vn])} returns \\spad{a1*v1+...+an*vn}.")) (|coordinates| (((|Matrix| |#1|) (|Vector| $) (|Vector| $)) "\\spad{coordinates([v1,...,vm], basis)} returns the coordinates of the vi's with to the basis \\spad{basis}. The coordinates of \\spad{vi} are contained in the \\spad{i}th row of the matrix returned by this function.") (((|Vector| |#1|) $ (|Vector| $)) "\\spad{coordinates(a,basis)} returns the coordinates of \\spad{a} with respect to the \\spad{basis} \\spad{basis}.")) (|norm| ((|#1| $) "\\spad{norm(a)} returns the determinant of the regular representation of \\spad{a} with respect to any basis.")) (|trace| ((|#1| $) "\\spad{trace(a)} returns the trace of the regular representation of \\spad{a} with respect to any basis.")) (|regularRepresentation| (((|Matrix| |#1|) $ (|Vector| $)) "\\spad{regularRepresentation(a,basis)} returns the matrix of the linear map defined by left multiplication by \\spad{a} with respect to the \\spad{basis} \\spad{basis}.")) (|rank| (((|PositiveInteger|)) "\\spad{rank()} returns the rank of the algebra."))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|FiniteLinearAggregateFunctions2| S A R B) 
((|constructor| (NIL "\\spad{FiniteLinearAggregateFunctions2} provides functions involving two FiniteLinearAggregates where the underlying domains might be different. An example of this might be creating a list of rational numbers by mapping a function across a list of integers where the function divides each integer by 1000.")) (|scan| ((|#4| (|Mapping| |#3| |#1| |#3|) |#2| |#3|) "\\spad{scan(f,a,r)} successively applies \\spad{reduce(f,x,r)} to more and more leading sub-aggregates \\spad{x} of aggregrate \\spad{a}. More precisely, if \\spad{a} is \\spad{[a1,a2,...]}, then \\spad{scan(f,a,r)} returns \\spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.")) (|reduce| ((|#3| (|Mapping| |#3| |#1| |#3|) |#2| |#3|) "\\spad{reduce(f,a,r)} applies function \\spad{f} to each successive element of the aggregate \\spad{a} and an accumulant initialized to \\spad{r.} For example, \\spad{reduce(_+$Integer,[1,2,3],0)} does \\spad{3+(2+(1+0))}. Note that third argument \\spad{r} may be regarded as the identity element for the function \\spad{f.}")) (|map| ((|#4| (|Mapping| |#3| |#1|) |#2|) "\\spad{map(f,a)} applies function \\spad{f} to each member of aggregate \\spad{a} resulting in a new aggregate over a possibly different underlying domain."))) 
NIL 
NIL 
(|FiniteLinearAggregate&| A S) 
((|constructor| (NIL "A finite linear aggregate is a linear aggregate of finite length. The finite property of the aggregate adds several exports to the list of exports from \\spadtype{LinearAggregate} such as \\spadfun{reverse}, \\spadfun{sort}, and so on.")) (|sort!| (($ $) "\\spad{sort!(u)} returns \\spad{u} with its elements in ascending order.") (($ (|Mapping| (|Boolean|) |#2| |#2|) $) "\\spad{sort!(p,u)} returns \\spad{u} with its elements ordered by \\spad{p.}")) (|reverse!| (($ $) "\\spad{reverse!(u)} returns \\spad{u} with its elements in reverse order.")) (|copyInto!| (($ $ $ (|Integer|)) "\\spad{copyInto!(u,v,i)} returns aggregate \\spad{u} containing a copy of \\spad{v} inserted at element i.")) (|position| (((|Integer|) |#2| $ (|Integer|)) "\\spad{position(x,a,n)} returns the index \\spad{i} of the first occurrence of \\spad{x} in \\axiom{a} where \\axiom{i \\spad{>=} \\spad{n},} and \\axiom{minIndex(a) - 1} if no such \\spad{x} is found.") (((|Integer|) |#2| $) "\\spad{position(x,a)} returns the index \\spad{i} of the first occurrence of \\spad{x} in a, and \\axiom{minIndex(a) - 1} if there is no such \\spad{x.}") (((|Integer|) (|Mapping| (|Boolean|) |#2|) $) "\\spad{position(p,a)} returns the index \\spad{i} of the first \\spad{x} in \\axiom{a} such that \\axiom{p(x)} is true, and \\axiom{minIndex(a) - 1} if there is no such \\spad{x.}")) (|sorted?| (((|Boolean|) $) "\\spad{sorted?(u)} tests if the elements of \\spad{u} are in ascending order.") (((|Boolean|) (|Mapping| (|Boolean|) |#2| |#2|) $) "\\spad{sorted?(p,a)} tests if \\axiom{a} is sorted according to predicate \\spad{p.}")) (|sort| (($ $) "\\spad{sort(u)} returns an \\spad{u} with elements in ascending order. Note that \\axiom{sort(u) = sort(<=,u)}.") (($ (|Mapping| (|Boolean|) |#2| |#2|) $) "\\spad{sort(p,a)} returns a copy of \\axiom{a} sorted using total ordering predicate \\spad{p.}")) (|reverse| (($ $) "\\spad{reverse(a)} returns a copy of \\axiom{a} with elements in reverse order.")) (|merge| (($ $ $) "\\spad{merge(u,v)} merges \\spad{u} and \\spad{v} in ascending order. Note that \\axiom{merge(u,v) = merge(<=,u,v)}.") (($ (|Mapping| (|Boolean|) |#2| |#2|) $ $) "\\spad{merge(p,a,b)} returns an aggregate \\spad{c} which merges \\axiom{a} and \\spad{b.} The result is produced by examining each element \\spad{x} of \\axiom{a} and \\spad{y} of \\spad{b} successively. If \\axiom{p(x,y)} is true, then \\spad{x} is inserted into the result; otherwise \\spad{y} is inserted. If \\spad{x} is chosen, the next element of \\axiom{a} is examined, and so on. When all the elements of one aggregate are examined, the remaining elements of the other are appended. For example, \\axiom{merge(<,[1,3],[2,7,5])} returns \\axiom{[1,2,3,7,5]}."))) 
NIL 
((|HasAttribute| |#1| (QUOTE |shallowlyMutable|)) (|HasCategory| |#2| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) 
(|FiniteLinearAggregate| S) 
((|constructor| (NIL "A finite linear aggregate is a linear aggregate of finite length. The finite property of the aggregate adds several exports to the list of exports from \\spadtype{LinearAggregate} such as \\spadfun{reverse}, \\spadfun{sort}, and so on.")) (|sort!| (($ $) "\\spad{sort!(u)} returns \\spad{u} with its elements in ascending order.") (($ (|Mapping| (|Boolean|) |#1| |#1|) $) "\\spad{sort!(p,u)} returns \\spad{u} with its elements ordered by \\spad{p.}")) (|reverse!| (($ $) "\\spad{reverse!(u)} returns \\spad{u} with its elements in reverse order.")) (|copyInto!| (($ $ $ (|Integer|)) "\\spad{copyInto!(u,v,i)} returns aggregate \\spad{u} containing a copy of \\spad{v} inserted at element i.")) (|position| (((|Integer|) |#1| $ (|Integer|)) "\\spad{position(x,a,n)} returns the index \\spad{i} of the first occurrence of \\spad{x} in \\axiom{a} where \\axiom{i \\spad{>=} \\spad{n},} and \\axiom{minIndex(a) - 1} if no such \\spad{x} is found.") (((|Integer|) |#1| $) "\\spad{position(x,a)} returns the index \\spad{i} of the first occurrence of \\spad{x} in a, and \\axiom{minIndex(a) - 1} if there is no such \\spad{x.}") (((|Integer|) (|Mapping| (|Boolean|) |#1|) $) "\\spad{position(p,a)} returns the index \\spad{i} of the first \\spad{x} in \\axiom{a} such that \\axiom{p(x)} is true, and \\axiom{minIndex(a) - 1} if there is no such \\spad{x.}")) (|sorted?| (((|Boolean|) $) "\\spad{sorted?(u)} tests if the elements of \\spad{u} are in ascending order.") (((|Boolean|) (|Mapping| (|Boolean|) |#1| |#1|) $) "\\spad{sorted?(p,a)} tests if \\axiom{a} is sorted according to predicate \\spad{p.}")) (|sort| (($ $) "\\spad{sort(u)} returns an \\spad{u} with elements in ascending order. Note that \\axiom{sort(u) = sort(<=,u)}.") (($ (|Mapping| (|Boolean|) |#1| |#1|) $) "\\spad{sort(p,a)} returns a copy of \\axiom{a} sorted using total ordering predicate \\spad{p.}")) (|reverse| (($ $) "\\spad{reverse(a)} returns a copy of \\axiom{a} with elements in reverse order.")) (|merge| (($ $ $) "\\spad{merge(u,v)} merges \\spad{u} and \\spad{v} in ascending order. Note that \\axiom{merge(u,v) = merge(<=,u,v)}.") (($ (|Mapping| (|Boolean|) |#1| |#1|) $ $) "\\spad{merge(p,a,b)} returns an aggregate \\spad{c} which merges \\axiom{a} and \\spad{b.} The result is produced by examining each element \\spad{x} of \\axiom{a} and \\spad{y} of \\spad{b} successively. If \\axiom{p(x,y)} is true, then \\spad{x} is inserted into the result; otherwise \\spad{y} is inserted. If \\spad{x} is chosen, the next element of \\axiom{a} is examined, and so on. When all the elements of one aggregate are examined, the remaining elements of the other are appended. For example, \\axiom{merge(<,[1,3],[2,7,5])} returns \\axiom{[1,2,3,7,5]}."))) 
((|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|FreeLieAlgebra| |VarSet| R) 
((|constructor| (NIL "The category of free Lie algebras. It is used by domains of non-commutative algebra: \\spadtype{LiePolynomial} and \\spadtype{XPBWPolynomial}.")) (|eval| (($ $ (|List| |#1|) (|List| $)) "\\axiom{eval(p, [x1,...,xn], [v1,...,vn])} replaces \\axiom{xi} by \\axiom{vi} in \\axiom{p}.") (($ $ |#1| $) "\\axiom{eval(p, \\spad{x,} \\spad{v)}} replaces \\axiom{x} by \\axiom{v} in \\axiom{p}.")) (|varList| (((|List| |#1|) $) "\\axiom{varList(x)} returns the list of distinct entries of \\axiom{x}.")) (|trunc| (($ $ (|NonNegativeInteger|)) "\\axiom{trunc(p,n)} returns the polynomial \\axiom{p} truncated at order \\axiom{n}.")) (|mirror| (($ $) "\\axiom{mirror(x)} returns \\axiom{Sum(r_i mirror(w_i))} if \\axiom{x} is \\axiom{Sum(r_i w_i)}.")) (|LiePoly| (($ (|LyndonWord| |#1|)) "\\axiom{LiePoly(l)} returns the bracketed form of \\axiom{l} as a Lie polynomial.")) (|rquo| (((|XRecursivePolynomial| |#1| |#2|) (|XRecursivePolynomial| |#1| |#2|) $) "\\axiom{rquo(x,y)} returns the right simplification of \\axiom{x} by \\axiom{y}.")) (|lquo| (((|XRecursivePolynomial| |#1| |#2|) (|XRecursivePolynomial| |#1| |#2|) $) "\\axiom{lquo(x,y)} returns the left simplification of \\axiom{x} by \\axiom{y}.")) (|degree| (((|NonNegativeInteger|) $) "\\axiom{degree(x)} returns the greatest length of a word in the support of \\axiom{x}.")) (|coerce| (((|XRecursivePolynomial| |#1| |#2|) $) "\\axiom{coerce(x)} returns \\axiom{x} as a recursive polynomial.") (((|XDistributedPolynomial| |#1| |#2|) $) "\\axiom{coerce(x)} returns \\axiom{x} as distributed polynomial.") (($ |#1|) "\\axiom{coerce(x)} returns \\axiom{x} as a Lie polynomial.")) (|coef| ((|#2| (|XRecursivePolynomial| |#1| |#2|) $) "\\axiom{coef(x,y)} returns the scalar product of \\axiom{x} by \\axiom{y}, the set of words being regarded as an orthogonal basis."))) 
((|JacobiIdentity| . T) (|NullSquare| . T) (|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|FiniteLinearAggregateSort| S V) 
((|constructor| (NIL "This package exports 3 sorting algorithms which work over FiniteLinearAggregates. Sort package (in-place) for shallowlyMutable Finite Linear Aggregates")) (|shellSort| ((|#2| (|Mapping| (|Boolean|) |#1| |#1|) |#2|) "\\spad{shellSort(f, agg)} sorts the aggregate agg with the ordering function \\spad{f} using the shellSort algorithm.")) (|heapSort| ((|#2| (|Mapping| (|Boolean|) |#1| |#1|) |#2|) "\\spad{heapSort(f, agg)} sorts the aggregate agg with the ordering function \\spad{f} using the heapsort algorithm.")) (|quickSort| ((|#2| (|Mapping| (|Boolean|) |#1| |#1|) |#2|) "\\spad{quickSort(f, agg)} sorts the aggregate agg with the ordering function \\spad{f} using the quicksort algorithm."))) 
NIL 
NIL 
(|FullyLinearlyExplicitRingOver&| S R) 
((|constructor| (NIL "\\spad{S} is \\spadtype{FullyLinearlyExplicitRingOver \\spad{R}} means that \\spad{S} is a \\spadtype{LinearlyExplicitRingOver \\spad{R}} and, in addition, if \\spad{R} is a \\spadtype{LinearlyExplicitRingOver Integer}, then so is \\spad{S}"))) 
NIL 
((|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|))))) 
(|FullyLinearlyExplicitRingOver| R) 
((|constructor| (NIL "\\spad{S} is \\spadtype{FullyLinearlyExplicitRingOver \\spad{R}} means that \\spad{S} is a \\spadtype{LinearlyExplicitRingOver \\spad{R}} and, in addition, if \\spad{R} is a \\spadtype{LinearlyExplicitRingOver Integer}, then so is \\spad{S}"))) 
((|unitsKnown| . T)) 
NIL 
(|FloatingComplexPackage| |Par|) 
((|constructor| (NIL "This is a package for the approximation of complex solutions for systems of equations of rational functions with complex rational coefficients. The results are expressed as either complex rational numbers or complex floats depending on the type of the precision parameter which can be either a rational number or a floating point number.")) (|complexRoots| (((|List| (|List| (|Complex| |#1|))) (|List| (|Fraction| (|Polynomial| (|Complex| (|Integer|))))) (|List| (|Symbol|)) |#1|) "\\spad{complexRoots(lrf, \\spad{lv,} eps)} finds all the complex solutions of a list of rational functions with rational number coefficients with respect the the variables appearing in \\spad{lv.} Each solution is computed to precision eps and returned as list corresponding to the order of variables in \\spad{lv.}") (((|List| (|Complex| |#1|)) (|Fraction| (|Polynomial| (|Complex| (|Integer|)))) |#1|) "\\spad{complexRoots(rf, eps)} finds all the complex solutions of a univariate rational function with rational number coefficients. The solutions are computed to precision eps.")) (|complexSolve| (((|List| (|Equation| (|Polynomial| (|Complex| |#1|)))) (|Equation| (|Fraction| (|Polynomial| (|Complex| (|Integer|))))) |#1|) "\\spad{complexSolve(eq,eps)} finds all the complex solutions of the equation \\spad{eq} of rational functions with rational rational coefficients with respect to all the variables appearing in eq, with precision eps.") (((|List| (|Equation| (|Polynomial| (|Complex| |#1|)))) (|Fraction| (|Polynomial| (|Complex| (|Integer|)))) |#1|) "\\spad{complexSolve(p,eps)} find all the complex solutions of the rational function \\spad{p} with complex rational coefficients with respect to all the variables appearing in \\spad{p,} with precision eps.") (((|List| (|List| (|Equation| (|Polynomial| (|Complex| |#1|))))) (|List| (|Equation| (|Fraction| (|Polynomial| (|Complex| (|Integer|)))))) |#1|) "\\spad{complexSolve(leq,eps)} finds all the complex solutions to precision \\spad{eps} of the system \\spad{leq} of equations of rational functions over complex rationals with respect to all the variables appearing in \\spad{lp.}") (((|List| (|List| (|Equation| (|Polynomial| (|Complex| |#1|))))) (|List| (|Fraction| (|Polynomial| (|Complex| (|Integer|))))) |#1|) "\\spad{complexSolve(lp,eps)} finds all the complex solutions to precision \\spad{eps} of the system \\spad{lp} of rational functions over the complex rationals with respect to all the variables appearing in \\spad{lp.}"))) 
NIL 
NIL 
(|Float|) 
((|outputSpacing| (((|Void|) (|NonNegativeInteger|)) "\\spad{outputSpacing(n)} inserts a space after \\spad{n} (default 10) digits on output; outputSpacing(0) means no spaces are inserted.")) (|outputGeneral| (((|Void|) (|NonNegativeInteger|)) "\\spad{outputGeneral(n)} sets the output mode to general notation with \\spad{n} significant digits displayed.") (((|Void|)) "\\spad{outputGeneral()} sets the output mode (default mode) to general notation; numbers will be displayed in either fixed or floating (scientific) notation depending on the magnitude.")) (|outputFixed| (((|Void|) (|NonNegativeInteger|)) "\\spad{outputFixed(n)} sets the output mode to fixed point notation, with \\spad{n} digits displayed after the decimal point.") (((|Void|)) "\\spad{outputFixed()} sets the output mode to fixed point notation; the output will contain a decimal point.")) (|outputFloating| (((|Void|) (|NonNegativeInteger|)) "\\spad{outputFloating(n)} sets the output mode to floating (scientific) notation with \\spad{n} significant digits displayed after the decimal point.") (((|Void|)) "\\spad{outputFloating()} sets the output mode to floating (scientific) notation, \\spadignore{i.e.} \\spad{mantissa * 10 exponent} is displayed as \\spad{0.mantissa \\spad{E} exponent}.")) (|convert| (($ (|DoubleFloat|)) "\\spad{convert(x)} converts a \\spadtype{DoubleFloat} \\spad{x} to a \\spadtype{Float}.")) (|atan| (($ $ $) "\\spad{atan(x,y)} computes the arc tangent from \\spad{x} with phase \\spad{y.}")) (|exp1| (($) "\\spad{exp1()} returns exp 1: \\spad{2.7182818284...}.")) (|log10| (($ $) "\\spad{log10(x)} computes the logarithm for \\spad{x} to base 10.") (($) "\\spad{log10()} returns \\spad{ln 10}: \\spad{2.3025809299...}.")) (|log2| (($ $) "\\spad{log2(x)} computes the logarithm for \\spad{x} to base 2.") (($) "\\spad{log2()} returns \\spad{ln 2}, \\spadignore{i.e.} \\spad{0.6931471805...}.")) (|rationalApproximation| (((|Fraction| (|Integer|)) $ (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{rationalApproximation(f, \\spad{n,} \\spad{b)}} computes a rational approximation \\spad{r} to \\spad{f} with relative error \\spad{< b**(-n)}, that is \\spad{|(r-f)/f| < b**(-n)}.") (((|Fraction| (|Integer|)) $ (|NonNegativeInteger|)) "\\spad{rationalApproximation(f, \\spad{n)}} computes a rational approximation \\spad{r} to \\spad{f} with relative error \\spad{< 10**(-n)}.")) (|shift| (($ $ (|Integer|)) "\\spad{shift(x,n)} adds \\spad{n} to the exponent of float \\spad{x.}")) (|relerror| (((|Integer|) $ $) "\\spad{relerror(x,y)} computes the absolute value of \\spad{x - \\spad{y}} divided by \\spad{y,} when \\spad{y \\spad{\\^=} 0}.")) (|normalize| (($ $) "\\spad{normalize(x)} normalizes \\spad{x} at current precision.")) (** (($ $ $) "\\spad{x \\spad{**} \\spad{y}} computes \\spad{exp(y log \\spad{x)}} where \\spad{x \\spad{>=} 0}.")) (/ (($ $ (|Integer|)) "\\spad{x / i} computes the division from \\spad{x} by an integer i."))) 
((|arbitraryExponent| . T) (|arbitraryPrecision| . T) (|approximate| . T) (|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|FloatingRealPackage| |Par|) 
((|constructor| (NIL "This is a package for the approximation of real solutions for systems of polynomial equations over the rational numbers. The results are expressed as either rational numbers or floats depending on the type of the precision parameter which can be either a rational number or a floating point number.")) (|realRoots| (((|List| |#1|) (|Fraction| (|Polynomial| (|Integer|))) |#1|) "\\spad{realRoots(rf, eps)} finds the real zeros of a univariate rational function with precision given by eps.") (((|List| (|List| |#1|)) (|List| (|Fraction| (|Polynomial| (|Integer|)))) (|List| (|Symbol|)) |#1|) "\\spad{realRoots(lp,lv,eps)} computes the list of the real solutions of the list \\spad{lp} of rational functions with rational coefficients with respect to the variables in \\spad{lv,} with precision eps. Each solution is expressed as a list of numbers in order corresponding to the variables in \\spad{lv.}")) (|solve| (((|List| (|Equation| (|Polynomial| |#1|))) (|Equation| (|Fraction| (|Polynomial| (|Integer|)))) |#1|) "\\spad{solve(eq,eps)} finds all of the real solutions of the univariate equation \\spad{eq} of rational functions with respect to the unique variables appearing in eq, with precision eps.") (((|List| (|Equation| (|Polynomial| |#1|))) (|Fraction| (|Polynomial| (|Integer|))) |#1|) "\\spad{solve(p,eps)} finds all of the real solutions of the univariate rational function \\spad{p} with rational coefficients with respect to the unique variable appearing in \\spad{p,} with precision eps.") (((|List| (|List| (|Equation| (|Polynomial| |#1|)))) (|List| (|Equation| (|Fraction| (|Polynomial| (|Integer|))))) |#1|) "\\spad{solve(leq,eps)} finds all of the real solutions of the system \\spad{leq} of equationas of rational functions with respect to all the variables appearing in \\spad{lp,} with precision eps.") (((|List| (|List| (|Equation| (|Polynomial| |#1|)))) (|List| (|Fraction| (|Polynomial| (|Integer|)))) |#1|) "\\spad{solve(lp,eps)} finds all of the real solutions of the system \\spad{lp} of rational functions over the rational numbers with respect to all the variables appearing in \\spad{lp,} with precision eps."))) 
NIL 
NIL 
(|FreeModule1| R S) 
((|constructor| (NIL "This domain implements linear combinations of elements from the domain \\spad{S} with coefficients in the domain \\spad{R} where \\spad{S} is an ordered set and \\spad{R} is a ring (which may be non-commutative). This domain is used by domains of non-commutative algebra such as: XDistributedPolynomial, XRecursivePolynomial.")) (* (($ |#2| |#1|) "\\spad{s*r} returns the product \\spad{r*s} used by \\spadtype{XRecursivePolynomial}"))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|)))) 
(|FreeModuleCat| R |Basis|) 
((|constructor| (NIL "A domain of this category implements formal linear combinations of elements from a domain \\spad{Basis} with coefficients in a domain \\spad{R}. The domain \\spad{Basis} needs only to belong to the category \\spadtype{SetCategory} and \\spad{R} to the category \\spadtype{Ring}. Thus the coefficient ring may be non-commutative. See the \\spadtype{XDistributedPolynomial} constructor for examples of domains built with the \\spadtype{FreeModuleCat} category constructor.")) (|reductum| (($ $) "\\spad{reductum(x)} returns \\spad{x} minus its leading term.")) (|leadingTerm| (((|Record| (|:| |k| |#2|) (|:| |c| |#1|)) $) "\\spad{leadingTerm(x)} returns the first term which appears in \\spad{listOfTerms(x)}.")) (|leadingCoefficient| ((|#1| $) "\\spad{leadingCoefficient(x)} returns the first coefficient which appears in \\spad{listOfTerms(x)}.")) (|leadingMonomial| ((|#2| $) "\\spad{leadingMonomial(x)} returns the first element from \\spad{Basis} which appears in \\spad{listOfTerms(x)}.")) (|numberOfMonomials| (((|NonNegativeInteger|) $) "\\spad{numberOfMonomials(x)} returns the number of monomials of \\spad{x}.")) (|monomials| (((|List| $) $) "\\spad{monomials(x)} returns the list of \\spad{r_i*b_i} whose sum is \\spad{x}.")) (|coefficients| (((|List| |#1|) $) "\\spad{coefficients(x)} returns the list of coefficients of \\spad{x}")) (|listOfTerms| (((|List| (|Record| (|:| |k| |#2|) (|:| |c| |#1|))) $) "\\spad{listOfTerms(x)} returns a list \\spad{lt} of terms with type \\spad{Record(k: Basis, \\spad{c:} \\spad{R)}} such that \\spad{x} equals \\spad{reduce(+, map(x \\spad{+->} monom(x.k, x.c), lt))}.")) (|monomial?| (((|Boolean|) $) "\\spad{monomial?(x)} returns \\spad{true} if \\spad{x} contains a single monomial.")) (|monom| (($ |#2| |#1|) "\\spad{monom(b,r)} returns the element with the single monomial \\indented{1}{\\spad{b} and coefficient \\spad{r}.}")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\spad{map(fn,u)} maps function \\spad{fn} onto the coefficients \\indented{1}{of the non-zero monomials of \\spad{u}.}")) (|coefficient| ((|#1| $ |#2|) "\\spad{coefficient(x,b)} returns the coefficient of \\spad{b} in \\spad{x}.")) (* (($ |#1| |#2|) "\\spad{r*b} returns the product of \\spad{r} by \\spad{b}."))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|FortranMatrixCategory|) 
((|constructor| (NIL "\\axiomType{FortranMatrixCategory} provides support for producing Functions and Subroutines when the input to these is an AXIOM object of type \\axiomType{Matrix} or in domains involving \\axiomType{FortranCode}.")) (|coerce| (($ (|Record| (|:| |localSymbols| (|SymbolTable|)) (|:| |code| (|List| (|FortranCode|))))) "\\spad{coerce(e)} takes the component of \\spad{e} from \\spadtype{List FortranCode} and uses it as the body of the ASP, making the declarations in the \\spadtype{SymbolTable} component.") (($ (|FortranCode|)) "\\spad{coerce(e)} takes an object from \\spadtype{FortranCode} and \\indented{1}{uses it as the body of an ASP.}") (($ (|List| (|FortranCode|))) "\\spad{coerce(e)} takes an object from \\spadtype{List FortranCode} and \\indented{1}{uses it as the body of an ASP.}") (($ (|Matrix| (|MachineFloat|))) "\\spad{coerce(v)} produces an ASP which returns the value of \\spad{v}."))) 
((|nil| . T)) 
NIL 
(|FortranMatrixFunctionCategory|) 
((|constructor| (NIL "\\axiomType{FortranMatrixFunctionCategory} provides support for producing Functions and Subroutines representing matrices of expressions.")) (|retractIfCan| (((|Union| $ "failed") (|Matrix| (|Fraction| (|Polynomial| (|Integer|))))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Matrix| (|Fraction| (|Polynomial| (|Float|))))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Matrix| (|Polynomial| (|Integer|)))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Matrix| (|Polynomial| (|Float|)))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Matrix| (|Expression| (|Integer|)))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Matrix| (|Expression| (|Float|)))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}")) (|retract| (($ (|Matrix| (|Fraction| (|Polynomial| (|Integer|))))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Matrix| (|Fraction| (|Polynomial| (|Float|))))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Matrix| (|Polynomial| (|Integer|)))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Matrix| (|Polynomial| (|Float|)))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Matrix| (|Expression| (|Integer|)))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Matrix| (|Expression| (|Float|)))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}")) (|coerce| (($ (|Record| (|:| |localSymbols| (|SymbolTable|)) (|:| |code| (|List| (|FortranCode|))))) "\\spad{coerce(e)} takes the component of \\spad{e} from \\spadtype{List FortranCode} and uses it as the body of the ASP, making the declarations in the \\spadtype{SymbolTable} component.") (($ (|FortranCode|)) "\\spad{coerce(e)} takes an object from \\spadtype{FortranCode} and \\indented{1}{uses it as the body of an ASP.}") (($ (|List| (|FortranCode|))) "\\spad{coerce(e)} takes an object from \\spadtype{List FortranCode} and \\indented{1}{uses it as the body of an ASP.}"))) 
((|nil| . T)) 
NIL 
(|FreeModule| R S) 
((|constructor| (NIL "A bi-module is a free module over a ring with generators indexed by an ordered set. Each element can be expressed as a finite linear combination of generators. Only non-zero terms are stored."))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|)))) 
(|FreeMonoid| S) 
((|constructor| (NIL "Free monoid on any set of generators The free monoid on a set \\spad{S} is the monoid of finite products of the form \\spad{reduce(*,[si \\spad{**} ni])} where the si's are in \\spad{S,} and the ni's are nonnegative integers. The multiplication is not commutative.")) (|mapGen| (($ (|Mapping| |#1| |#1|) $) "\\spad{mapGen(f, \\spad{a1\\^e1} \\spad{...} an\\^en)} returns \\spad{f(a1)\\^e1 \\spad{...} f(an)\\^en}.")) (|mapExpon| (($ (|Mapping| (|NonNegativeInteger|) (|NonNegativeInteger|)) $) "\\spad{mapExpon(f, \\spad{a1\\^e1} \\spad{...} an\\^en)} returns \\spad{a1\\^f(e1) \\spad{...} an\\^f(en)}.")) (|nthFactor| ((|#1| $ (|Integer|)) "\\spad{nthFactor(x, \\spad{n)}} returns the factor of the n^th monomial of \\spad{x.}")) (|nthExpon| (((|NonNegativeInteger|) $ (|Integer|)) "\\spad{nthExpon(x, \\spad{n)}} returns the exponent of the n^th monomial of \\spad{x.}")) (|factors| (((|List| (|Record| (|:| |gen| |#1|) (|:| |exp| (|NonNegativeInteger|)))) $) "\\spad{factors(a1\\^e1,...,an\\^en)} returns \\spad{[[a1, e1],...,[an, en]]}.")) (|size| (((|NonNegativeInteger|) $) "\\spad{size(x)} returns the number of monomials in \\spad{x.}")) (|overlap| (((|Record| (|:| |lm| $) (|:| |mm| $) (|:| |rm| $)) $ $) "\\spad{overlap(x, \\spad{y)}} returns \\spad{[l, \\spad{m,} \\spad{r]}} such that \\spad{x = \\spad{l} * \\spad{m},} \\spad{y = \\spad{m} * \\spad{r}} and \\spad{l} and \\spad{r} have no overlap, \\spadignore{i.e.} \\spad{overlap(l, \\spad{r)} = \\spad{[l,} 1, r]}.")) (|divide| (((|Union| (|Record| (|:| |lm| $) (|:| |rm| $)) "failed") $ $) "\\spad{divide(x, \\spad{y)}} returns the left and right exact quotients of \\spad{x} by \\spad{y,} \\spadignore{i.e.} \\spad{[l, \\spad{r]}} such that \\spad{x = \\spad{l} * \\spad{y} * \\spad{r},} \"failed\" if \\spad{x} is not of the form \\spad{l * \\spad{y} * \\spad{r}.}")) (|rquo| (((|Union| $ "failed") $ $) "\\spad{rquo(x, \\spad{y)}} returns the exact right quotient of \\spad{x} by \\spad{y} \\spadignore{i.e.} \\spad{q} such that \\spad{x = \\spad{q} * \\spad{y},} \"failed\" if \\spad{x} is not of the form \\spad{q * \\spad{y}.}")) (|lquo| (((|Union| $ "failed") $ $) "\\spad{lquo(x, \\spad{y)}} returns the exact left quotient of \\spad{x} by \\spad{y} \\spadignore{i.e.} \\spad{q} such that \\spad{x = \\spad{y} * \\spad{q},} \"failed\" if \\spad{x} is not of the form \\spad{y * \\spad{q}.}")) (|hcrf| (($ $ $) "\\spad{hcrf(x, \\spad{y)}} returns the highest common right factor of \\spad{x} and \\spad{y,} \\spadignore{i.e.} the largest \\spad{d} such that \\spad{x = a \\spad{d}} and \\spad{y = \\spad{b} \\spad{d}.}")) (|hclf| (($ $ $) "\\spad{hclf(x, \\spad{y)}} returns the highest common left factor of \\spad{x} and \\spad{y,} \\spadignore{i.e.} the largest \\spad{d} such that \\spad{x = \\spad{d} a} and \\spad{y = \\spad{d} \\spad{b}.}")) (** (($ |#1| (|NonNegativeInteger|)) "\\spad{s \\spad{**} \\spad{n}} returns the product of \\spad{s} by itself \\spad{n} times.")) (* (($ $ |#1|) "\\spad{x * \\spad{s}} returns the product of \\spad{x} by \\spad{s} on the right.") (($ |#1| $) "\\spad{s * \\spad{x}} returns the product of \\spad{x} by \\spad{s} on the left."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|OrderedSet|)))) 
(|FortranMachineTypeCategory|) 
((|constructor| (NIL "A category of domains which model machine arithmetic used by machines in the AXIOM-NAG link."))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|FileName|) 
((|constructor| (NIL "This domain provides an interface to names in the file system."))) 
NIL 
NIL 
(|FileNameCategory|) 
((|constructor| (NIL "This category provides an interface to names in the file system.")) (|new| (($ (|String|) (|String|) (|String|)) "\\spad{new(d,pref,e)} constructs the name of a new writable file with \\spad{d} as its directory, \\spad{pref} as a prefix of its name and \\spad{e} as its extension. When \\spad{d} or \\spad{t} is the empty string, a default is used. An error occurs if a new file cannot be written in the given directory.")) (|writable?| (((|Boolean|) $) "\\spad{writable?(f)} tests if the named file be opened for writing. The named file need not already exist.")) (|readable?| (((|Boolean|) $) "\\spad{readable?(f)} tests if the named file exist and can it be opened for reading.")) (|exists?| (((|Boolean|) $) "\\spad{exists?(f)} tests if the file exists in the file system.")) (|extension| (((|String|) $) "\\spad{extension(f)} returns the type part of the file name.")) (|name| (((|String|) $) "\\spad{name(f)} returns the name part of the file name.")) (|directory| (((|String|) $) "\\spad{directory(f)} returns the directory part of the file name.")) (|filename| (($ (|String|) (|String|) (|String|)) "\\spad{filename(d,n,e)} creates a file name with \\spad{d} as its directory, \\spad{n} as its name and \\spad{e} as its extension. This is a portable way to create file names. When \\spad{d} or \\spad{t} is the empty string, a default is used.")) (|coerce| (((|String|) $) "\\spad{coerce(fn)} produces a string for a file name according to operating system-dependent conventions.") (($ (|String|)) "\\spad{coerce(s)} converts a string to a file name according to operating system-dependent conventions."))) 
NIL 
NIL 
(|FreeNilpotentLie| |n| |class| R) 
((|constructor| (NIL "Generate the Free Lie Algebra over a ring \\spad{R} with identity; A \\spad{P.} Hall basis is generated by a package call to HallBasis.")) (|generator| (($ (|NonNegativeInteger|)) "\\spad{generator(i)} is the \\spad{i}th Hall Basis element")) (|shallowExpand| (((|OutputForm|) $) "\\spad{shallowExpand(x)} is not documented")) (|deepExpand| (((|OutputForm|) $) "\\spad{deepExpand(x)} is not documented")) (|dimension| (((|NonNegativeInteger|)) "\\spad{dimension()} is the rank of this Lie algebra"))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|FortranOutputStackPackage|) 
((|constructor| (NIL "Code to manipulate Fortran Output Stack")) (|topFortranOutputStack| (((|String|)) "\\spad{topFortranOutputStack()} returns the top element of the Fortran output stack")) (|pushFortranOutputStack| (((|Void|) (|String|)) "\\spad{pushFortranOutputStack(f)} pushes \\spad{f} onto the Fortran output stack") (((|Void|) (|FileName|)) "\\spad{pushFortranOutputStack(f)} pushes \\spad{f} onto the Fortran output stack")) (|popFortranOutputStack| (((|Void|)) "\\spad{popFortranOutputStack()} pops the Fortran output stack")) (|showFortranOutputStack| (((|Stack| (|String|))) "\\spad{showFortranOutputStack()} returns the Fortran output stack")) (|clearFortranOutputStack| (((|Stack| (|String|))) "\\spad{clearFortranOutputStack()} clears the Fortran output stack"))) 
NIL 
NIL 
(|FindOrderFinite| F UP UPUP R) 
((|constructor| (NIL "Finds the order of a divisor over a finite field")) (|order| (((|NonNegativeInteger|) (|FiniteDivisor| |#1| |#2| |#3| |#4|)) "\\spad{order(x)} \\undocumented"))) 
NIL 
NIL 
(|ScriptFormulaFormat1| S) 
((|constructor| (NIL "\\spadtype{ScriptFormulaFormat1} provides a utility coercion for changing to SCRIPT formula format anything that has a coercion to the standard output format.")) (|coerce| (((|ScriptFormulaFormat|) |#1|) "\\spad{coerce(s)} provides a direct coercion from an expression \\spad{s} of domain \\spad{S} to SCRIPT formula format. This allows the user to skip the step of first manually coercing the object to standard output format before it is coerced to SCRIPT formula format."))) 
NIL 
NIL 
(|ScriptFormulaFormat|) 
((|constructor| (NIL "\\spadtype{ScriptFormulaFormat} provides a coercion from \\spadtype{OutputForm} to IBM SCRIPT/VS Mathematical Formula Format. The basic SCRIPT formula format object consists of three parts: a prologue, a formula part and an epilogue. The functions \\spadfun{prologue}, \\spadfun{formula} and \\spadfun{epilogue} extract these parts, respectively. The central parts of the expression go into the formula part. The other parts can be set (\\spadfun{setPrologue!}, \\spadfun{setEpilogue!}) so that contain the appropriate tags for printing. For example, the prologue and epilogue might simply contain \":df.\" and \":edf.\" so that the formula section will be printed in display math mode.")) (|setPrologue!| (((|List| (|String|)) $ (|List| (|String|))) "\\spad{setPrologue!(t,strings)} sets the prologue section of a formatted object \\spad{t} to strings.")) (|setFormula!| (((|List| (|String|)) $ (|List| (|String|))) "\\spad{setFormula!(t,strings)} sets the formula section of a formatted object \\spad{t} to strings.")) (|setEpilogue!| (((|List| (|String|)) $ (|List| (|String|))) "\\spad{setEpilogue!(t,strings)} sets the epilogue section of a formatted object \\spad{t} to strings.")) (|prologue| (((|List| (|String|)) $) "\\spad{prologue(t)} extracts the prologue section of a formatted object \\spad{t.}")) (|new| (($) "\\spad{new()} create a new, empty object. Use \\spadfun{setPrologue!}, \\spadfun{setFormula!} and \\spadfun{setEpilogue!} to set the various components of this object.")) (|formula| (((|List| (|String|)) $) "\\spad{formula(t)} extracts the formula section of a formatted object \\spad{t.}")) (|epilogue| (((|List| (|String|)) $) "\\spad{epilogue(t)} extracts the epilogue section of a formatted object \\spad{t.}")) (|display| (((|Void|) $) "\\spad{display(t)} outputs the formatted code \\spad{t} so that each line has length less than or equal to the value set by the system command \\spadsyscom{set output length}.") (((|Void|) $ (|Integer|)) "\\spad{display(t,width)} outputs the formatted code \\spad{t} so that each line has length less than or equal to \\spadvar{width}.")) (|convert| (($ (|OutputForm|) (|Integer|)) "\\spad{convert(o,step)} changes \\spad{o} in standard output format to SCRIPT formula format and also adds the given \\spad{step} number. This is useful if you want to create equations with given numbers or have the equation numbers correspond to the interpreter \\spad{step} numbers.")) (|coerce| (($ (|OutputForm|)) "\\spad{coerce(o)} changes \\spad{o} in the standard output format to SCRIPT formula format."))) 
NIL 
NIL 
(|FortranProgramCategory|) 
((|constructor| (NIL "FortranProgramCategory provides various models of FORTRAN subprograms. These can be transformed into actual FORTRAN code.")) (|outputAsFortran| (((|Void|) $) "\\axiom{outputAsFortran(u)} translates \\axiom{u} into a legal FORTRAN subprogram."))) 
((|nil| . T)) 
NIL 
(|FortranFunctionCategory|) 
((|constructor| (NIL "\\axiomType{FortranFunctionCategory} is the category of arguments to NAG Library routines which return (sets of) function values.")) (|retractIfCan| (((|Union| $ "failed") (|Fraction| (|Polynomial| (|Integer|)))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Fraction| (|Polynomial| (|Float|)))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Polynomial| (|Integer|))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Polynomial| (|Float|))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Expression| (|Integer|))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Expression| (|Float|))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}")) (|retract| (($ (|Fraction| (|Polynomial| (|Integer|)))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Fraction| (|Polynomial| (|Float|)))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Polynomial| (|Integer|))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Polynomial| (|Float|))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Expression| (|Integer|))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Expression| (|Float|))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}")) (|coerce| (($ (|Record| (|:| |localSymbols| (|SymbolTable|)) (|:| |code| (|List| (|FortranCode|))))) "\\spad{coerce(e)} takes the component of \\spad{e} from \\spadtype{List FortranCode} and uses it as the body of the ASP, making the declarations in the \\spadtype{SymbolTable} component.") (($ (|FortranCode|)) "\\spad{coerce(e)} takes an object from \\spadtype{FortranCode} and \\indented{1}{uses it as the body of an ASP.}") (($ (|List| (|FortranCode|))) "\\spad{coerce(e)} takes an object from \\spadtype{List FortranCode} and \\indented{1}{uses it as the body of an ASP.}"))) 
((|nil| . T)) 
NIL 
(|FortranPackage|) 
((|constructor| (NIL "provides an interface to the boot code for calling Fortran")) (|setLegalFortranSourceExtensions| (((|List| (|String|)) (|List| (|String|))) "\\spad{setLegalFortranSourceExtensions(l)} \\undocumented{}")) (|outputAsFortran| (((|Void|) (|FileName|)) "\\spad{outputAsFortran(fn)} \\undocumented{}")) (|linkToFortran| (((|SExpression|) (|Symbol|) (|List| (|Symbol|)) (|TheSymbolTable|) (|List| (|Symbol|))) "\\spad{linkToFortran(s,l,t,lv)} \\undocumented{}") (((|SExpression|) (|Symbol|) (|List| (|Union| (|:| |array| (|List| (|Symbol|))) (|:| |scalar| (|Symbol|)))) (|List| (|List| (|Union| (|:| |array| (|List| (|Symbol|))) (|:| |scalar| (|Symbol|))))) (|List| (|Symbol|)) (|Symbol|)) "\\spad{linkToFortran(s,l,ll,lv,t)} \\undocumented{}") (((|SExpression|) (|Symbol|) (|List| (|Union| (|:| |array| (|List| (|Symbol|))) (|:| |scalar| (|Symbol|)))) (|List| (|List| (|Union| (|:| |array| (|List| (|Symbol|))) (|:| |scalar| (|Symbol|))))) (|List| (|Symbol|))) "\\spad{linkToFortran(s,l,ll,lv)} \\undocumented{}"))) 
NIL 
NIL 
(|FortranProgram| |name| |returnType| |arguments| |symbols|) 
((|constructor| (NIL "\\axiomType{FortranProgram} allows the user to build and manipulate simple models of FORTRAN subprograms. These can then be transformed into actual FORTRAN notation.")) (|coerce| (($ (|Equation| (|Expression| (|Complex| (|Float|))))) "\\spad{coerce(eq)} is not documented") (($ (|Equation| (|Expression| (|Float|)))) "\\spad{coerce(eq)} is not documented") (($ (|Equation| (|Expression| (|Integer|)))) "\\spad{coerce(eq)} is not documented") (($ (|Expression| (|Complex| (|Float|)))) "\\spad{coerce(e)} is not documented") (($ (|Expression| (|Float|))) "\\spad{coerce(e)} is not documented") (($ (|Expression| (|Integer|))) "\\spad{coerce(e)} is not documented") (($ (|Equation| (|Expression| (|MachineComplex|)))) "\\spad{coerce(eq)} is not documented") (($ (|Equation| (|Expression| (|MachineFloat|)))) "\\spad{coerce(eq)} is not documented") (($ (|Equation| (|Expression| (|MachineInteger|)))) "\\spad{coerce(eq)} is not documented") (($ (|Expression| (|MachineComplex|))) "\\spad{coerce(e)} is not documented") (($ (|Expression| (|MachineFloat|))) "\\spad{coerce(e)} is not documented") (($ (|Expression| (|MachineInteger|))) "\\spad{coerce(e)} is not documented") (($ (|Record| (|:| |localSymbols| (|SymbolTable|)) (|:| |code| (|List| (|FortranCode|))))) "\\spad{coerce(r)} is not documented") (($ (|List| (|FortranCode|))) "\\spad{coerce(lfc)} is not documented") (($ (|FortranCode|)) "\\spad{coerce(fc)} is not documented"))) 
NIL 
NIL 
(|FullPartialFractionExpansion| F UP) 
((|constructor| (NIL "Full partial fraction expansion of rational functions")) (D (($ $ (|NonNegativeInteger|)) "\\spad{D(f, \\spad{n)}} returns the \\spad{n}-th derivative of \\spad{f.}") (($ $) "\\spad{D(f)} returns the derivative of \\spad{f.}")) (|differentiate| (($ $ (|NonNegativeInteger|)) "\\spad{differentiate(f, \\spad{n)}} returns the \\spad{n}-th derivative of \\spad{f.}") (($ $) "\\spad{differentiate(f)} returns the derivative of \\spad{f.}")) (|construct| (($ (|List| (|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |center| |#2|) (|:| |num| |#2|)))) "\\spad{construct(l)} is the inverse of fracPart.")) (|fracPart| (((|List| (|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |center| |#2|) (|:| |num| |#2|))) $) "\\spad{fracPart(f)} returns the list of summands of the fractional part of \\spad{f.}")) (|polyPart| ((|#2| $) "\\spad{polyPart(f)} returns the polynomial part of \\spad{f.}")) (|fullPartialFraction| (($ (|Fraction| |#2|)) "\\spad{fullPartialFraction(f)} returns \\spad{[p, [[j, \\spad{Dj,} Hj]...]]} such that \\spad{f = p(x) + sum_{[j,Dj,Hj] in \\spad{l}} sum_{Dj(a)=0} Hj(a)/(x - a)\\^j}.")) (+ (($ |#2| $) "\\spad{p + \\spad{x}} returns the sum of \\spad{p} and \\spad{x}"))) 
NIL 
NIL 
(|FullyPatternMatchable| R) 
((|constructor| (NIL "A set \\spad{S} is PatternMatchable over \\spad{R} if \\spad{S} can lift the pattern-matching functions of \\spad{S} over the integers and float to itself (necessary for matching in towers)."))) 
((|nil| . T)) 
NIL 
(|FieldOfPrimeCharacteristic&| S) 
((|constructor| (NIL "FieldOfPrimeCharacteristic is the category of fields of prime characteristic, \\spadignore{e.g.} finite fields, algebraic closures of fields of prime characteristic, transcendental extensions of of fields of prime characteristic.")) (|primeFrobenius| (($ $ (|NonNegativeInteger|)) "\\spad{primeFrobenius(a,s)} returns \\spad{a**(p**s)} where \\spad{p} is the characteristic.") (($ $) "\\spad{primeFrobenius(a)} returns \\spad{a**p} where \\spad{p} is the characteristic.")) (|discreteLog| (((|Union| (|NonNegativeInteger|) "failed") $ $) "\\spad{discreteLog(b,a)} computes \\spad{s} with \\spad{b**s = a} if such an \\spad{s} exists.")) (|order| (((|OnePointCompletion| (|PositiveInteger|)) $) "\\spad{order(a)} computes the order of an element in the multiplicative group of the field. Error: if \\spad{a} is 0."))) 
NIL 
NIL 
(|FieldOfPrimeCharacteristic|) 
((|constructor| (NIL "FieldOfPrimeCharacteristic is the category of fields of prime characteristic, \\spadignore{e.g.} finite fields, algebraic closures of fields of prime characteristic, transcendental extensions of of fields of prime characteristic.")) (|primeFrobenius| (($ $ (|NonNegativeInteger|)) "\\spad{primeFrobenius(a,s)} returns \\spad{a**(p**s)} where \\spad{p} is the characteristic.") (($ $) "\\spad{primeFrobenius(a)} returns \\spad{a**p} where \\spad{p} is the characteristic.")) (|discreteLog| (((|Union| (|NonNegativeInteger|) "failed") $ $) "\\spad{discreteLog(b,a)} computes \\spad{s} with \\spad{b**s = a} if such an \\spad{s} exists.")) (|order| (((|OnePointCompletion| (|PositiveInteger|)) $) "\\spad{order(a)} computes the order of an element in the multiplicative group of the field. Error: if \\spad{a} is 0."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|FloatingPointSystem&| S) 
((|constructor| (NIL "This category is intended as a model for floating point systems. A floating point system is a model for the real numbers. In fact, it is an approximation in the sense that not all real numbers are exactly representable by floating point numbers. A floating point system is characterized by the following: \\blankline 1: base of the exponent where the actual implemenations are usually binary or decimal)\\br 2: precision of the mantissa (arbitrary or fixed)\\br 3: rounding error for operations \\blankline Because a Float is an approximation to the real numbers, even though it is defined to be a join of a Field and OrderedRing, some of the attributes do not hold. In particular associative(\"+\") does not hold. Algorithms defined over a field need special considerations when the field is a floating point system.")) (|max| (($) "\\spad{max()} returns the maximum floating point number.")) (|min| (($) "\\spad{min()} returns the minimum floating point number.")) (|decreasePrecision| (((|PositiveInteger|) (|Integer|)) "\\spad{decreasePrecision(n)} decreases the current \\spadfunFrom{precision}{FloatingPointSystem} precision by \\spad{n} decimal digits.")) (|increasePrecision| (((|PositiveInteger|) (|Integer|)) "\\spad{increasePrecision(n)} increases the current \\spadfunFrom{precision}{FloatingPointSystem} by \\spad{n} decimal digits.")) (|precision| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{precision(n)} set the precision in the base to \\spad{n} decimal digits.") (((|PositiveInteger|)) "\\spad{precision()} returns the precision in digits base.")) (|digits| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{digits(d)} set the \\spadfunFrom{precision}{FloatingPointSystem} to \\spad{d} digits.") (((|PositiveInteger|)) "\\spad{digits()} returns ceiling's precision in decimal digits.")) (|bits| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{bits(n)} set the \\spadfunFrom{precision}{FloatingPointSystem} to \\spad{n} bits.") (((|PositiveInteger|)) "\\spad{bits()} returns ceiling's precision in bits.")) (|mantissa| (((|Integer|) $) "\\spad{mantissa(x)} returns the mantissa part of \\spad{x.}")) (|exponent| (((|Integer|) $) "\\spad{exponent(x)} returns the \\spadfunFrom{exponent}{FloatingPointSystem} part of \\spad{x.}")) (|base| (((|PositiveInteger|)) "\\spad{base()} returns the base of the \\spadfunFrom{exponent}{FloatingPointSystem}.")) (|order| (((|Integer|) $) "\\spad{order \\spad{x}} is the order of magnitude of \\spad{x.} Note that \\spad{base \\spad{**} order \\spad{x} \\spad{<=} \\spad{|x|} < base \\spad{**} \\spad{(1} + order x)}.")) (|float| (($ (|Integer|) (|Integer|) (|PositiveInteger|)) "\\spad{float(a,e,b)} returns \\spad{a * \\spad{b} \\spad{**} e}.") (($ (|Integer|) (|Integer|)) "\\spad{float(a,e)} returns \\spad{a * base() \\spad{**} e}.")) (|approximate| ((|attribute|) "\\spad{approximate} means \"is an approximation to the real numbers\"."))) 
NIL 
((|HasAttribute| |#1| (QUOTE |arbitraryExponent|)) (|HasAttribute| |#1| (QUOTE |arbitraryPrecision|))) 
(|FloatingPointSystem|) 
((|constructor| (NIL "This category is intended as a model for floating point systems. A floating point system is a model for the real numbers. In fact, it is an approximation in the sense that not all real numbers are exactly representable by floating point numbers. A floating point system is characterized by the following: \\blankline 1: base of the exponent where the actual implemenations are usually binary or decimal)\\br 2: precision of the mantissa (arbitrary or fixed)\\br 3: rounding error for operations \\blankline Because a Float is an approximation to the real numbers, even though it is defined to be a join of a Field and OrderedRing, some of the attributes do not hold. In particular associative(\"+\") does not hold. Algorithms defined over a field need special considerations when the field is a floating point system.")) (|max| (($) "\\spad{max()} returns the maximum floating point number.")) (|min| (($) "\\spad{min()} returns the minimum floating point number.")) (|decreasePrecision| (((|PositiveInteger|) (|Integer|)) "\\spad{decreasePrecision(n)} decreases the current \\spadfunFrom{precision}{FloatingPointSystem} precision by \\spad{n} decimal digits.")) (|increasePrecision| (((|PositiveInteger|) (|Integer|)) "\\spad{increasePrecision(n)} increases the current \\spadfunFrom{precision}{FloatingPointSystem} by \\spad{n} decimal digits.")) (|precision| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{precision(n)} set the precision in the base to \\spad{n} decimal digits.") (((|PositiveInteger|)) "\\spad{precision()} returns the precision in digits base.")) (|digits| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{digits(d)} set the \\spadfunFrom{precision}{FloatingPointSystem} to \\spad{d} digits.") (((|PositiveInteger|)) "\\spad{digits()} returns ceiling's precision in decimal digits.")) (|bits| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{bits(n)} set the \\spadfunFrom{precision}{FloatingPointSystem} to \\spad{n} bits.") (((|PositiveInteger|)) "\\spad{bits()} returns ceiling's precision in bits.")) (|mantissa| (((|Integer|) $) "\\spad{mantissa(x)} returns the mantissa part of \\spad{x.}")) (|exponent| (((|Integer|) $) "\\spad{exponent(x)} returns the \\spadfunFrom{exponent}{FloatingPointSystem} part of \\spad{x.}")) (|base| (((|PositiveInteger|)) "\\spad{base()} returns the base of the \\spadfunFrom{exponent}{FloatingPointSystem}.")) (|order| (((|Integer|) $) "\\spad{order \\spad{x}} is the order of magnitude of \\spad{x.} Note that \\spad{base \\spad{**} order \\spad{x} \\spad{<=} \\spad{|x|} < base \\spad{**} \\spad{(1} + order x)}.")) (|float| (($ (|Integer|) (|Integer|) (|PositiveInteger|)) "\\spad{float(a,e,b)} returns \\spad{a * \\spad{b} \\spad{**} e}.") (($ (|Integer|) (|Integer|)) "\\spad{float(a,e)} returns \\spad{a * base() \\spad{**} e}.")) (|approximate| ((|attribute|) "\\spad{approximate} means \"is an approximation to the real numbers\"."))) 
((|approximate| . T) (|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|FactoredFunctions2| R S) 
((|constructor| (NIL "\\spadtype{FactoredFunctions2} contains functions that involve factored objects whose underlying domains may not be the same. For example, \\spadfun{map} might be used to coerce an object of type \\spadtype{Factored(Integer)} to \\spadtype{Factored(Complex(Integer))}.")) (|map| (((|Factored| |#2|) (|Mapping| |#2| |#1|) (|Factored| |#1|)) "\\spad{map(fn,u)} is used to apply the function \\userfun{fn} to every factor of \\spadvar{u}. The new factored object will have all its information flags set to \"nil\". This function is used, for example, to coerce every factor base to another type."))) 
NIL 
NIL 
(|FractionFunctions2| A B) 
((|constructor| (NIL "This package extends a map between integral domains to a map between Fractions over those domains by applying the map to the numerators and denominators.")) (|map| (((|Fraction| |#2|) (|Mapping| |#2| |#1|) (|Fraction| |#1|)) "\\spad{map(func,frac)} applies the function \\spad{func} to the numerator and denominator of the fraction frac."))) 
NIL 
NIL 
(|Fraction| S) 
((|constructor| (NIL "Fraction takes an IntegralDomain \\spad{S} and produces the domain of Fractions with numerators and denominators from \\spad{S.} If \\spad{S} is also a GcdDomain, then gcd's between numerator and denominator will be cancelled during all operations.")) (|canonical| ((|attribute|) "\\spad{canonical} means that equal elements are in fact identical."))) 
((|canonical| AND (|has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|has| |#1| (|GcdDomain|)) (|has| |#1| (ATTRIBUTE |canonical|))) (|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|RealConstant|))) (|HasCategory| |#1| (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#1| (QUOTE (|StepThrough|))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (|devaluate| |#1|))) (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (LIST (QUOTE |Eltable|) (|devaluate| |#1|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|))) (AND (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#1| (QUOTE (|OpenMath|)))) (AND (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|)) (|HasAttribute| |#1| (QUOTE |canonical|)) (|HasCategory| |#1| (QUOTE (|GcdDomain|)))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (OR (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (AND (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#1| (QUOTE (|OpenMath|))))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#1| (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (OR (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (AND (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#1| (QUOTE (|OpenMath|))))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (OR (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (AND (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#1| (QUOTE (|OpenMath|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (OR (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#1| (QUOTE (|OpenMath|))))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (OR (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (AND (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#1| (QUOTE (|OpenMath|))))) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))))) 
(|FramedAlgebra&| S R UP) 
((|constructor| (NIL "A \\spadtype{FramedAlgebra} is a \\spadtype{FiniteRankAlgebra} together with a fixed R-module basis.")) (|regularRepresentation| (((|Matrix| |#2|) $) "\\spad{regularRepresentation(a)} returns the matrix of the linear map defined by left multiplication by \\spad{a} with respect to the fixed basis.")) (|discriminant| ((|#2|) "\\spad{discriminant()} = determinant(traceMatrix()).")) (|traceMatrix| (((|Matrix| |#2|)) "\\spad{traceMatrix()} is the n-by-n matrix ( \\spad{Tr(vi * vj)} \\spad{),} where \\spad{v1,} ..., \\spad{vn} are the elements of the fixed basis.")) (|convert| (($ (|Vector| |#2|)) "\\spad{convert([a1,..,an])} returns \\spad{a1*v1 + \\spad{...} + an*vn}, where \\spad{v1,} ..., \\spad{vn} are the elements of the fixed basis.") (((|Vector| |#2|) $) "\\spad{convert(a)} returns the coordinates of \\spad{a} with respect to the fixed R-module basis.")) (|represents| (($ (|Vector| |#2|)) "\\spad{represents([a1,..,an])} returns \\spad{a1*v1 + \\spad{...} + an*vn}, where \\spad{v1,} ..., \\spad{vn} are the elements of the fixed basis.")) (|coordinates| (((|Matrix| |#2|) (|Vector| $)) "\\spad{coordinates([v1,...,vm])} returns the coordinates of the vi's with to the fixed basis. The coordinates of \\spad{vi} are contained in the \\spad{i}th row of the matrix returned by this function.") (((|Vector| |#2|) $) "\\spad{coordinates(a)} returns the coordinates of \\spad{a} with respect to the fixed R-module basis.")) (|basis| (((|Vector| $)) "\\spad{basis()} returns the fixed R-module basis."))) 
NIL 
NIL 
(|FramedAlgebra| R UP) 
((|constructor| (NIL "A \\spadtype{FramedAlgebra} is a \\spadtype{FiniteRankAlgebra} together with a fixed R-module basis.")) (|regularRepresentation| (((|Matrix| |#1|) $) "\\spad{regularRepresentation(a)} returns the matrix of the linear map defined by left multiplication by \\spad{a} with respect to the fixed basis.")) (|discriminant| ((|#1|) "\\spad{discriminant()} = determinant(traceMatrix()).")) (|traceMatrix| (((|Matrix| |#1|)) "\\spad{traceMatrix()} is the n-by-n matrix ( \\spad{Tr(vi * vj)} \\spad{),} where \\spad{v1,} ..., \\spad{vn} are the elements of the fixed basis.")) (|convert| (($ (|Vector| |#1|)) "\\spad{convert([a1,..,an])} returns \\spad{a1*v1 + \\spad{...} + an*vn}, where \\spad{v1,} ..., \\spad{vn} are the elements of the fixed basis.") (((|Vector| |#1|) $) "\\spad{convert(a)} returns the coordinates of \\spad{a} with respect to the fixed R-module basis.")) (|represents| (($ (|Vector| |#1|)) "\\spad{represents([a1,..,an])} returns \\spad{a1*v1 + \\spad{...} + an*vn}, where \\spad{v1,} ..., \\spad{vn} are the elements of the fixed basis.")) (|coordinates| (((|Matrix| |#1|) (|Vector| $)) "\\spad{coordinates([v1,...,vm])} returns the coordinates of the vi's with to the fixed basis. The coordinates of \\spad{vi} are contained in the \\spad{i}th row of the matrix returned by this function.") (((|Vector| |#1|) $) "\\spad{coordinates(a)} returns the coordinates of \\spad{a} with respect to the fixed R-module basis.")) (|basis| (((|Vector| $)) "\\spad{basis()} returns the fixed R-module basis."))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|FullyRetractableTo&| A S) 
((|constructor| (NIL "A is fully retractable to \\spad{B} means that A is retractable to \\spad{B} and if \\spad{B} is retractable to the integers or rational numbers then so is A. In particular, what we are asserting is that there are no integers (rationals) in A which don't retract into \\spad{B.}"))) 
NIL 
((|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) 
(|FullyRetractableTo| S) 
((|constructor| (NIL "A is fully retractable to \\spad{B} means that A is retractable to \\spad{B} and if \\spad{B} is retractable to the integers or rational numbers then so is A. In particular, what we are asserting is that there are no integers (rationals) in A which don't retract into \\spad{B.}"))) 
NIL 
NIL 
(|FractionalIdealFunctions2| R1 F1 U1 A1 R2 F2 U2 A2) 
((|constructor| (NIL "Lifting of morphisms to fractional ideals.")) (|map| (((|FractionalIdeal| |#5| |#6| |#7| |#8|) (|Mapping| |#5| |#1|) (|FractionalIdeal| |#1| |#2| |#3| |#4|)) "\\spad{map(f,i)} \\undocumented{}"))) 
NIL 
NIL 
(|FractionalIdeal| R F UP A) 
((|constructor| (NIL "Fractional ideals in a framed algebra.")) (|randomLC| ((|#4| (|NonNegativeInteger|) (|Vector| |#4|)) "\\spad{randomLC(n,x)} should be local but conditional.")) (|minimize| (($ $) "\\spad{minimize(I)} returns a reduced set of generators for \\spad{I}.")) (|denom| ((|#1| $) "\\spad{denom(1/d * (f1,...,fn))} returns \\spad{d.}")) (|numer| (((|Vector| |#4|) $) "\\spad{numer(1/d * (f1,...,fn))} = the vector \\spad{[f1,...,fn]}.")) (|norm| ((|#2| $) "\\spad{norm(I)} returns the norm of the ideal I.")) (|basis| (((|Vector| |#4|) $) "\\spad{basis((f1,...,fn))} returns the vector \\spad{[f1,...,fn]}.")) (|ideal| (($ (|Vector| |#4|)) "\\spad{ideal([f1,...,fn])} returns the ideal \\spad{(f1,...,fn)}."))) 
((|unitsKnown| . T)) 
NIL 
(|FramedModule| R F UP A |ibasis|) 
((|constructor| (NIL "Module representation of fractional ideals.")) (|module| (($ (|FractionalIdeal| |#1| |#2| |#3| |#4|)) "\\spad{module(I)} returns \\spad{I} viewed has a module over \\spad{R.}") (($ (|Vector| |#4|)) "\\spad{module([f1,...,fn])} = the module generated by \\spad{(f1,...,fn)} over \\spad{R.}")) (|norm| ((|#2| $) "\\spad{norm(f)} returns the norm of the module \\spad{f.}")) (|basis| (((|Vector| |#4|) $) "\\spad{basis((f1,...,fn))} = the vector \\spad{[f1,...,fn]}."))) 
NIL 
((|HasCategory| |#4| (LIST (QUOTE |RetractableTo|) (|devaluate| |#2|)))) 
(|FramedNonAssociativeAlgebraFunctions2| AR R AS S) 
((|constructor| (NIL "\\spad{FramedNonAssociativeAlgebraFunctions2} implements functions between two framed non associative algebra domains defined over different rings. The function map is used to coerce between algebras over different domains having the same structural constants.")) (|map| ((|#3| (|Mapping| |#4| |#2|) |#1|) "\\spad{map(f,u)} maps \\spad{f} onto the coordinates of \\spad{u} to get an element in \\spad{AS} via identification of the basis of \\spad{AR} as beginning part of the basis of \\spad{AS}."))) 
NIL 
NIL 
(|FramedNonAssociativeAlgebra&| S R) 
((|constructor| (NIL "FramedNonAssociativeAlgebra(R) is a \\spadtype{FiniteRankNonAssociativeAlgebra} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free \\spad{R}-module of finite rank) over a commutative ring \\spad{R} together with a fixed \\spad{R}-module basis.")) (|apply| (($ (|Matrix| |#2|) $) "\\spad{apply(m,a)} defines a left operation of \\spad{n} by \\spad{n} matrices where \\spad{n} is the rank of the algebra in terms of matrix-vector multiplication, this is a substitute for a left module structure. Error: if shape of matrix doesn't fit.")) (|rightRankPolynomial| (((|SparseUnivariatePolynomial| (|Polynomial| |#2|))) "\\spad{rightRankPolynomial()} calculates the right minimal polynomial of the generic element in the algebra, defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis.")) (|leftRankPolynomial| (((|SparseUnivariatePolynomial| (|Polynomial| |#2|))) "\\spad{leftRankPolynomial()} calculates the left minimal polynomial of the generic element in the algebra, defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis.")) (|rightRegularRepresentation| (((|Matrix| |#2|) $) "\\spad{rightRegularRepresentation(a)} returns the matrix of the linear map defined by right multiplication by \\spad{a} with respect to the fixed \\spad{R}-module basis.")) (|leftRegularRepresentation| (((|Matrix| |#2|) $) "\\spad{leftRegularRepresentation(a)} returns the matrix of the linear map defined by left multiplication by \\spad{a} with respect to the fixed \\spad{R}-module basis.")) (|rightTraceMatrix| (((|Matrix| |#2|)) "\\spad{rightTraceMatrix()} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the right trace of the product \\spad{vi*vj}, where \\spad{v1},...,\\spad{vn} are the elements of the fixed \\spad{R}-module basis.")) (|leftTraceMatrix| (((|Matrix| |#2|)) "\\spad{leftTraceMatrix()} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by left trace of the product \\spad{vi*vj}, where \\spad{v1},...,\\spad{vn} are the elements of the fixed \\spad{R}-module basis.")) (|rightDiscriminant| ((|#2|) "\\spad{rightDiscriminant()} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the right trace of the product \\spad{vi*vj}, where \\spad{v1},...,\\spad{vn} are the elements of the fixed \\spad{R}-module basis. Note that the same as \\spad{determinant(rightTraceMatrix())}.")) (|leftDiscriminant| ((|#2|) "\\spad{leftDiscriminant()} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the left trace of the product \\spad{vi*vj}, where \\spad{v1},...,\\spad{vn} are the elements of the fixed \\spad{R}-module basis. Note that the same as \\spad{determinant(leftTraceMatrix())}.")) (|convert| (($ (|Vector| |#2|)) "\\spad{convert([a1,...,an])} returns \\spad{a1*v1 + \\spad{...} + an*vn}, where \\spad{v1}, ..., \\spad{vn} are the elements of the fixed \\spad{R}-module basis.") (((|Vector| |#2|) $) "\\spad{convert(a)} returns the coordinates of \\spad{a} with respect to the fixed \\spad{R}-module basis.")) (|represents| (($ (|Vector| |#2|)) "\\spad{represents([a1,...,an])} returns \\spad{a1*v1 + \\spad{...} + an*vn}, where \\spad{v1}, ..., \\spad{vn} are the elements of the fixed \\spad{R}-module basis.")) (|conditionsForIdempotents| (((|List| (|Polynomial| |#2|))) "\\spad{conditionsForIdempotents()} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the fixed \\spad{R}-module basis.")) (|structuralConstants| (((|Vector| (|Matrix| |#2|))) "\\spad{structuralConstants()} calculates the structural constants \\spad{[(gammaijk) for \\spad{k} in 1..rank()]} defined by \\spad{vi * \\spad{vj} = \\spad{gammaij1} * \\spad{v1} + \\spad{...} + gammaijn * vn}, where \\spad{v1},...,\\spad{vn} is the fixed \\spad{R}-module basis.")) (|elt| ((|#2| $ (|Integer|)) "\\spad{elt(a,i)} returns the \\spad{i}-th coefficient of \\spad{a} with respect to the fixed \\spad{R}-module basis.")) (|coordinates| (((|Matrix| |#2|) (|Vector| $)) "\\spad{coordinates([a1,...,am])} returns a matrix whose \\spad{i}-th row is formed by the coordinates of \\spad{ai} with respect to the fixed \\spad{R}-module basis.") (((|Vector| |#2|) $) "\\spad{coordinates(a)} returns the coordinates of \\spad{a} with respect to the fixed \\spad{R}-module basis.")) (|basis| (((|Vector| $)) "\\spad{basis()} returns the fixed \\spad{R}-module basis."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|Field|)))) 
(|FramedNonAssociativeAlgebra| R) 
((|constructor| (NIL "FramedNonAssociativeAlgebra(R) is a \\spadtype{FiniteRankNonAssociativeAlgebra} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free \\spad{R}-module of finite rank) over a commutative ring \\spad{R} together with a fixed \\spad{R}-module basis.")) (|apply| (($ (|Matrix| |#1|) $) "\\spad{apply(m,a)} defines a left operation of \\spad{n} by \\spad{n} matrices where \\spad{n} is the rank of the algebra in terms of matrix-vector multiplication, this is a substitute for a left module structure. Error: if shape of matrix doesn't fit.")) (|rightRankPolynomial| (((|SparseUnivariatePolynomial| (|Polynomial| |#1|))) "\\spad{rightRankPolynomial()} calculates the right minimal polynomial of the generic element in the algebra, defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis.")) (|leftRankPolynomial| (((|SparseUnivariatePolynomial| (|Polynomial| |#1|))) "\\spad{leftRankPolynomial()} calculates the left minimal polynomial of the generic element in the algebra, defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis.")) (|rightRegularRepresentation| (((|Matrix| |#1|) $) "\\spad{rightRegularRepresentation(a)} returns the matrix of the linear map defined by right multiplication by \\spad{a} with respect to the fixed \\spad{R}-module basis.")) (|leftRegularRepresentation| (((|Matrix| |#1|) $) "\\spad{leftRegularRepresentation(a)} returns the matrix of the linear map defined by left multiplication by \\spad{a} with respect to the fixed \\spad{R}-module basis.")) (|rightTraceMatrix| (((|Matrix| |#1|)) "\\spad{rightTraceMatrix()} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the right trace of the product \\spad{vi*vj}, where \\spad{v1},...,\\spad{vn} are the elements of the fixed \\spad{R}-module basis.")) (|leftTraceMatrix| (((|Matrix| |#1|)) "\\spad{leftTraceMatrix()} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by left trace of the product \\spad{vi*vj}, where \\spad{v1},...,\\spad{vn} are the elements of the fixed \\spad{R}-module basis.")) (|rightDiscriminant| ((|#1|) "\\spad{rightDiscriminant()} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the right trace of the product \\spad{vi*vj}, where \\spad{v1},...,\\spad{vn} are the elements of the fixed \\spad{R}-module basis. Note that the same as \\spad{determinant(rightTraceMatrix())}.")) (|leftDiscriminant| ((|#1|) "\\spad{leftDiscriminant()} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}-th row and \\spad{j}-th column is given by the left trace of the product \\spad{vi*vj}, where \\spad{v1},...,\\spad{vn} are the elements of the fixed \\spad{R}-module basis. Note that the same as \\spad{determinant(leftTraceMatrix())}.")) (|convert| (($ (|Vector| |#1|)) "\\spad{convert([a1,...,an])} returns \\spad{a1*v1 + \\spad{...} + an*vn}, where \\spad{v1}, ..., \\spad{vn} are the elements of the fixed \\spad{R}-module basis.") (((|Vector| |#1|) $) "\\spad{convert(a)} returns the coordinates of \\spad{a} with respect to the fixed \\spad{R}-module basis.")) (|represents| (($ (|Vector| |#1|)) "\\spad{represents([a1,...,an])} returns \\spad{a1*v1 + \\spad{...} + an*vn}, where \\spad{v1}, ..., \\spad{vn} are the elements of the fixed \\spad{R}-module basis.")) (|conditionsForIdempotents| (((|List| (|Polynomial| |#1|))) "\\spad{conditionsForIdempotents()} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the fixed \\spad{R}-module basis.")) (|structuralConstants| (((|Vector| (|Matrix| |#1|))) "\\spad{structuralConstants()} calculates the structural constants \\spad{[(gammaijk) for \\spad{k} in 1..rank()]} defined by \\spad{vi * \\spad{vj} = \\spad{gammaij1} * \\spad{v1} + \\spad{...} + gammaijn * vn}, where \\spad{v1},...,\\spad{vn} is the fixed \\spad{R}-module basis.")) (|elt| ((|#1| $ (|Integer|)) "\\spad{elt(a,i)} returns the \\spad{i}-th coefficient of \\spad{a} with respect to the fixed \\spad{R}-module basis.")) (|coordinates| (((|Matrix| |#1|) (|Vector| $)) "\\spad{coordinates([a1,...,am])} returns a matrix whose \\spad{i}-th row is formed by the coordinates of \\spad{ai} with respect to the fixed \\spad{R}-module basis.") (((|Vector| |#1|) $) "\\spad{coordinates(a)} returns the coordinates of \\spad{a} with respect to the fixed \\spad{R}-module basis.")) (|basis| (((|Vector| $)) "\\spad{basis()} returns the fixed \\spad{R}-module basis."))) 
((|unitsKnown| |has| |#1| (|IntegralDomain|)) (|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|Factored| R) 
((|constructor| (NIL "\\spadtype{Factored} creates a domain whose objects are kept in factored form as long as possible. Thus certain operations like multiplication and \\spad{gcd} are relatively easy to do. Others, like addition require somewhat more work, and unless the argument domain provides a factor function, the result may not be completely factored. Each object consists of a unit and a list of factors, where a factor has a member of \\spad{R} (the \"base\"), and exponent and a flag indicating what is known about the base. A flag may be one of \"nil\", \"sqfr\", \"irred\" or \"prime\", which respectively mean that nothing is known about the base, it is square-free, it is irreducible, or it is prime. The current restriction to integral domains allows simplification to be performed without worrying about multiplication order.")) (|rationalIfCan| (((|Union| (|Fraction| (|Integer|)) "failed") $) "\\spad{rationalIfCan(u)} returns a rational number if \\spad{u} really is one, and \"failed\" otherwise.")) (|rational| (((|Fraction| (|Integer|)) $) "\\spad{rational(u)} assumes spadvar{u} is actually a rational number and does the conversion to rational number (see \\spadtype{Fraction Integer}).")) (|rational?| (((|Boolean|) $) "\\spad{rational?(u)} tests if \\spadvar{u} is actually a rational number (see \\spadtype{Fraction Integer}).")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\indented{1}{map(fn,u) maps the function \\userfun{fn} across the factors of} \\indented{1}{\\spadvar{u} and creates a new factored object. Note: this clears} \\indented{1}{the information flags (sets them to \"nil\") because the effect of} \\indented{1}{\\userfun{fn} is clearly not known in general.} \\blankline \\spad{X} m(a:Factored Polynomial Integer):Factored Polynomial Integer \\spad{==} \\spad{a^2} \\spad{X} \\spad{f:=x*y^3-3*x^2*y^2+3*x^3*y-x^4} \\spad{X} map(m,f) \\spad{X} g:=makeFR(z,factorList \\spad{f)} \\spad{X} map(m,g)")) (|unitNormalize| (($ $) "\\spad{unitNormalize(u)} normalizes the unit part of the factorization. For example, when working with factored integers, this operation will ensure that the bases are all positive integers.")) (|unit| ((|#1| $) "\\indented{1}{unit(u) extracts the unit part of the factorization.} \\blankline \\spad{X} \\spad{f:=x*y^3-3*x^2*y^2+3*x^3*y-x^4} \\spad{X} unit \\spad{f} \\spad{X} g:=makeFR(z,factorList \\spad{f)} \\spad{X} unit \\spad{g}")) (|flagFactor| (($ |#1| (|Integer|) (|Union| "nil" "sqfr" "irred" "prime")) "\\spad{flagFactor(base,exponent,flag)} creates a factored object with a single factor whose \\spad{base} is asserted to be properly described by the information flag.")) (|sqfrFactor| (($ |#1| (|Integer|)) "\\indented{1}{sqfrFactor(base,exponent) creates a factored object with} \\indented{1}{a single factor whose base is asserted to be square-free} \\indented{1}{(flag = \"sqfr\").} \\blankline \\spad{X} a:=sqfrFactor(3,5) \\spad{X} nthFlag(a,1)")) (|primeFactor| (($ |#1| (|Integer|)) "\\indented{1}{primeFactor(base,exponent) creates a factored object with} \\indented{1}{a single factor whose base is asserted to be prime} \\indented{1}{(flag = \"prime\").} \\blankline \\spad{X} a:=primeFactor(3,4) \\spad{X} nthFlag(a,1)")) (|numberOfFactors| (((|NonNegativeInteger|) $) "\\indented{1}{numberOfFactors(u) returns the number of factors in \\spadvar{u}.} \\blankline \\spad{X} a:=factor 9720000 \\spad{X} numberOfFactors a")) (|nthFlag| (((|Union| "nil" "sqfr" "irred" "prime") $ (|Integer|)) "\\indented{1}{nthFlag(u,n) returns the information flag of the \\spad{n}th factor of} \\indented{1}{\\spadvar{u}.\\space{2}If \\spadvar{n} is not a valid index for a factor} \\indented{1}{(for example, less than 1 or too big), \"nil\" is returned.} \\blankline \\spad{X} a:=factor 9720000 \\spad{X} nthFlag(a,2)")) (|nthFactor| ((|#1| $ (|Integer|)) "\\indented{1}{nthFactor(u,n) returns the base of the \\spad{n}th factor of} \\indented{1}{\\spadvar{u}.\\space{2}If \\spadvar{n} is not a valid index for a factor} \\indented{1}{(for example, less than 1 or too big), 1 is returned.\\space{2}If} \\indented{1}{\\spadvar{u} consists only of a unit, the unit is returned.} \\blankline \\spad{X} a:=factor 9720000 \\spad{X} nthFactor(a,2)")) (|nthExponent| (((|Integer|) $ (|Integer|)) "\\indented{1}{nthExponent(u,n) returns the exponent of the \\spad{n}th factor of} \\indented{1}{\\spadvar{u}.\\space{2}If \\spadvar{n} is not a valid index for a factor} \\indented{1}{(for example, less than 1 or too big), 0 is returned.} \\blankline \\spad{X} a:=factor 9720000 \\spad{X} nthExponent(a,2)")) (|irreducibleFactor| (($ |#1| (|Integer|)) "\\indented{1}{irreducibleFactor(base,exponent) creates a factored object with} \\indented{1}{a single factor whose base is asserted to be irreducible} \\indented{1}{(flag = \"irred\").} \\blankline \\spad{X} a:=irreducibleFactor(3,1) \\spad{X} nthFlag(a,1)")) (|factors| (((|List| (|Record| (|:| |factor| |#1|) (|:| |exponent| (|Integer|)))) $) "\\indented{1}{factors(u) returns a list of the factors in a form suitable} \\indented{1}{for iteration. That is, it returns a list where each element} \\indented{1}{is a record containing a base and exponent.\\space{2}The original} \\indented{1}{object is the product of all the factors and the unit (which} \\indented{1}{can be extracted by \\axiom{unit(u)}).} \\blankline \\spad{X} \\spad{f:=x*y^3-3*x^2*y^2+3*x^3*y-x^4} \\spad{X} factors \\spad{f} \\spad{X} g:=makeFR(z,factorList \\spad{f)} \\spad{X} factors \\spad{g}")) (|nilFactor| (($ |#1| (|Integer|)) "\\indented{1}{nilFactor(base,exponent) creates a factored object with} \\indented{1}{a single factor with no information about the kind of} \\indented{1}{base (flag = \"nil\").} \\blankline \\spad{X} nilFactor(24,2) \\spad{X} nilFactor(x-y,3)")) (|factorList| (((|List| (|Record| (|:| |flg| (|Union| "nil" "sqfr" "irred" "prime")) (|:| |fctr| |#1|) (|:| |xpnt| (|Integer|)))) $) "\\indented{1}{factorList(u) returns the list of factors with flags (for} \\indented{1}{use by factoring code).} \\blankline \\spad{X} f:=nilFactor(x-y,3) \\spad{X} factorList \\spad{f}")) (|makeFR| (($ |#1| (|List| (|Record| (|:| |flg| (|Union| "nil" "sqfr" "irred" "prime")) (|:| |fctr| |#1|) (|:| |xpnt| (|Integer|))))) "\\indented{1}{makeFR(unit,listOfFactors) creates a factored object (for} \\indented{1}{use by factoring code).} \\blankline \\spad{X} f:=nilFactor(x-y,3) \\spad{X} g:=factorList \\spad{f} \\spad{X} makeFR(z,g)")) (|exponent| (((|Integer|) $) "\\indented{1}{exponent(u) returns the exponent of the first factor of} \\indented{1}{\\spadvar{u}, or 0 if the factored form consists solely of a unit.} \\blankline \\spad{X} f:=nilFactor(y-x,3) \\spad{X} exponent(f)")) (|expand| ((|#1| $) "\\indented{1}{expand(f) multiplies the unit and factors together, yielding an} \\indented{1}{\"unfactored\" object. Note: this is purposely not called} \\indented{1}{\\spadfun{coerce} which would cause the interpreter to do this} \\indented{1}{automatically.} \\blankline \\spad{X} f:=nilFactor(y-x,3) \\spad{X} expand(f)"))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (QUOTE $))) (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (QUOTE $))) (|HasCategory| |#1| (LIST (QUOTE |Eltable|) (QUOTE $) (QUOTE $))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|UniqueFactorizationDomain|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|UniqueFactorizationDomain|)))) (|HasCategory| |#1| (QUOTE (|RealConstant|))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (|devaluate| |#1|))) (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (LIST (QUOTE |Eltable|) (|devaluate| |#1|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|)))) 
(|FactoredFunctionUtilities| R) 
((|constructor| (NIL "\\spadtype{FactoredFunctionUtilities} implements some utility functions for manipulating factored objects.")) (|mergeFactors| (((|Factored| |#1|) (|Factored| |#1|) (|Factored| |#1|)) "\\spad{mergeFactors(u,v)} is used when the factorizations of \\spadvar{u} and \\spadvar{v} are known to be disjoint, \\spadignore{e.g.} resulting from a content/primitive part split. Essentially, it creates a new factored object by multiplying the units together and appending the lists of factors.")) (|refine| (((|Factored| |#1|) (|Factored| |#1|) (|Mapping| (|Factored| |#1|) |#1|)) "\\spad{refine(u,fn)} is used to apply the function \\userfun{fn} to each factor of \\spadvar{u} and then build a new factored object from the results. For example, if \\spadvar{u} were created by calling \\spad{nilFactor(10,2)} then \\spad{refine(u,factor)} would create a factored object equal to that created by \\spad{factor(100)} or \\spad{primeFactor(2,2) * primeFactor(5,2)}."))) 
NIL 
NIL 
(|FunctionSpaceToExponentialExpansion| R FE |x| |cen|) 
((|constructor| (NIL "This package converts expressions in some function space to exponential expansions.")) (|localAbs| ((|#2| |#2|) "\\spad{localAbs(fcn)} = \\spad{abs(fcn)} or \\spad{sqrt(fcn**2)} depending on whether or not FE has a function \\spad{abs}. This should be a local function, but the compiler won't allow it.")) (|exprToXXP| (((|Union| (|:| |%expansion| (|ExponentialExpansion| |#1| |#2| |#3| |#4|)) (|:| |%problem| (|Record| (|:| |func| (|String|)) (|:| |prob| (|String|))))) |#2| (|Boolean|)) "\\spad{exprToXXP(fcn,posCheck?)} converts the expression \\spad{fcn} to an exponential expansion. If \\spad{posCheck?} is true, log's of negative numbers are not allowed nor are \\spad{n}th roots of negative numbers with \\spad{n} even. If \\spad{posCheck?} is false, these are allowed."))) 
NIL 
NIL 
(|FunctionSpaceFunctions2| R A S B) 
((|constructor| (NIL "Lifting of maps to function spaces This package allows a mapping \\spad{R} \\spad{->} \\spad{S} to be lifted to a mapping from a function space over \\spad{R} to a function space over \\spad{S;}")) (|map| ((|#4| (|Mapping| |#3| |#1|) |#2|) "\\spad{map(f, a)} applies \\spad{f} to all the constants in \\spad{R} appearing in \\spad{a}."))) 
NIL 
NIL 
(|FunctionSpaceToUnivariatePowerSeries| R FE |Expon| UPS TRAN |x|) 
((|constructor| (NIL "This package converts expressions in some function space to power series in a variable \\spad{x} with coefficients in that function space. The function \\spadfun{exprToUPS} converts expressions to power series whose coefficients do not contain the variable \\spad{x.} The function \\spadfun{exprToGenUPS} converts functional expressions to power series whose coefficients may involve functions of \\spad{log(x)}.")) (|localAbs| ((|#2| |#2|) "\\spad{localAbs(fcn)} = \\spad{abs(fcn)} or \\spad{sqrt(fcn**2)} depending on whether or not FE has a function \\spad{abs}. This should be a local function, but the compiler won't allow it.")) (|exprToGenUPS| (((|Union| (|:| |%series| |#4|) (|:| |%problem| (|Record| (|:| |func| (|String|)) (|:| |prob| (|String|))))) |#2| (|Boolean|) (|String|)) "\\spad{exprToGenUPS(fcn,posCheck?,atanFlag)} converts the expression \\spad{fcn} to a generalized power series. If \\spad{posCheck?} is true, log's of negative numbers are not allowed nor are \\spad{n}th roots of negative numbers with \\spad{n} even. If \\spad{posCheck?} is false, these are allowed. \\spad{atanFlag} determines how the case \\spad{atan(f(x))}, where \\spad{f(x)} has a pole, will be treated. The possible values of \\spad{atanFlag} are \\spad{\"complex\"}, \\spad{\"real: two sides\"}, \\spad{\"real: left side\"}, \\spad{\"real: right side\"}, and \\spad{\"just do it\"}. If \\spad{atanFlag} is \\spad{\"complex\"}, then no series expansion will be computed because, viewed as a function of a complex variable, \\spad{atan(f(x))} has an essential singularity. Otherwise, the sign of the leading coefficient of the series expansion of \\spad{f(x)} determines the constant coefficient in the series expansion of \\spad{atan(f(x))}. If this sign cannot be determined, a series expansion is computed only when \\spad{atanFlag} is \\spad{\"just do it\"}. When the leading term in the series expansion of \\spad{f(x)} is of odd degree (or is a rational degree with odd numerator), then the constant coefficient in the series expansion of \\spad{atan(f(x))} for values to the left differs from that for values to the right. If \\spad{atanFlag} is \\spad{\"real: two sides\"}, no series expansion will be computed. If \\spad{atanFlag} is \\spad{\"real: left side\"} the constant coefficient for values to the left will be used and if \\spad{atanFlag} \\spad{\"real: right side\"} the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series, we return a record containing the name of the function that caused the problem and a brief description of the problem. When expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a, the user should perform the substitution \\spad{x \\spad{->} \\spad{x} + a} before calling this function.")) (|exprToUPS| (((|Union| (|:| |%series| |#4|) (|:| |%problem| (|Record| (|:| |func| (|String|)) (|:| |prob| (|String|))))) |#2| (|Boolean|) (|String|)) "\\spad{exprToUPS(fcn,posCheck?,atanFlag)} converts the expression \\spad{fcn} to a power series. If \\spad{posCheck?} is true, log's of negative numbers are not allowed nor are \\spad{n}th roots of negative numbers with \\spad{n} even. If \\spad{posCheck?} is false, these are allowed. \\spad{atanFlag} determines how the case \\spad{atan(f(x))}, where \\spad{f(x)} has a pole, will be treated. The possible values of \\spad{atanFlag} are \\spad{\"complex\"}, \\spad{\"real: two sides\"}, \\spad{\"real: left side\"}, \\spad{\"real: right side\"}, and \\spad{\"just do it\"}. If \\spad{atanFlag} is \\spad{\"complex\"}, then no series expansion will be computed because, viewed as a function of a complex variable, \\spad{atan(f(x))} has an essential singularity. Otherwise, the sign of the leading coefficient of the series expansion of \\spad{f(x)} determines the constant coefficient in the series expansion of \\spad{atan(f(x))}. If this sign cannot be determined, a series expansion is computed only when \\spad{atanFlag} is \\spad{\"just do it\"}. When the leading term in the series expansion of \\spad{f(x)} is of odd degree (or is a rational degree with odd numerator), then the constant coefficient in the series expansion of \\spad{atan(f(x))} for values to the left differs from that for values to the right. If \\spad{atanFlag} is \\spad{\"real: two sides\"}, no series expansion will be computed. If \\spad{atanFlag} is \\spad{\"real: left side\"} the constant coefficient for values to the left will be used and if \\spad{atanFlag} \\spad{\"real: right side\"} the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series, a record containing the name of the function that caused the problem and a brief description of the problem is returned. When expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a, the user should perform the substitution \\spad{x \\spad{->} \\spad{x} + a} before calling this function.")) (|integrate| (($ $) "\\spad{integrate(x)} returns the integral of \\spad{x} since we need to be able to integrate a power series")) (|differentiate| (($ $) "\\spad{differentiate(x)} returns the derivative of \\spad{x} since we need to be able to differentiate a power series")) (|coerce| (($ |#3|) "\\spad{coerce(e)} converts an 'exponent' \\spad{e} to an 'expression'"))) 
NIL 
NIL 
(|FiniteSetAggregateFunctions2| S A R B) 
((|constructor| (NIL "\\spad{FiniteSetAggregateFunctions2} provides functions involving two finite set aggregates where the underlying domains might be different. An example of this is to create a set of rational numbers by mapping a function across a set of integers, where the function divides each integer by 1000.")) (|scan| ((|#4| (|Mapping| |#3| |#1| |#3|) |#2| |#3|) "\\spad{scan(f,a,r)} successively applies \\spad{reduce(f,x,r)} to more and more leading sub-aggregates \\spad{x} of aggregate \\spad{a}. More precisely, if \\spad{a} is \\spad{[a1,a2,...]}, then \\spad{scan(f,a,r)} returns \\spad {[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.")) (|reduce| ((|#3| (|Mapping| |#3| |#1| |#3|) |#2| |#3|) "\\spad{reduce(f,a,r)} applies function \\spad{f} to each successive element of the aggregate \\spad{a} and an accumulant initialised to \\spad{r.} For example, \\spad{reduce(_+$Integer,[1,2,3],0)} does a \\spad{3+(2+(1+0))}. Note that third argument \\spad{r} may be regarded as an identity element for the function.")) (|map| ((|#4| (|Mapping| |#3| |#1|) |#2|) "\\spad{map(f,a)} applies function \\spad{f} to each member of aggregate \\spad{a}, creating a new aggregate with a possibly different underlying domain."))) 
NIL 
NIL 
(|FiniteSetAggregate&| A S) 
((|constructor| (NIL "A finite-set aggregate models the notion of a finite set, that is, a collection of elements characterized by membership, but not by order or multiplicity. See \\spadtype{Set} for an example.")) (|min| ((|#2| $) "\\spad{min(u)} returns the smallest element of aggregate u.")) (|max| ((|#2| $) "\\spad{max(u)} returns the largest element of aggregate u.")) (|universe| (($) "\\spad{universe()}$D returns the universal set for finite set aggregate \\spad{D.}")) (|complement| (($ $) "\\spad{complement(u)} returns the complement of the set u, that is, the set of all values not in u.")) (|cardinality| (((|NonNegativeInteger|) $) "\\spad{cardinality(u)} returns the number of elements of u. Note that \\axiom{cardinality(u) = \\#u}."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|Finite|)))) 
(|FiniteSetAggregate| S) 
((|constructor| (NIL "A finite-set aggregate models the notion of a finite set, that is, a collection of elements characterized by membership, but not by order or multiplicity. See \\spadtype{Set} for an example.")) (|min| ((|#1| $) "\\spad{min(u)} returns the smallest element of aggregate u.")) (|max| ((|#1| $) "\\spad{max(u)} returns the largest element of aggregate u.")) (|universe| (($) "\\spad{universe()}$D returns the universal set for finite set aggregate \\spad{D.}")) (|complement| (($ $) "\\spad{complement(u)} returns the complement of the set u, that is, the set of all values not in u.")) (|cardinality| (((|NonNegativeInteger|) $) "\\spad{cardinality(u)} returns the number of elements of u. Note that \\axiom{cardinality(u) = \\#u}."))) 
((|finiteAggregate| . T) (|partiallyOrderedSet| . T) (|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|FunctionSpaceComplexIntegration| R F) 
((|constructor| (NIL "Top-level complex function integration \\spadtype{FunctionSpaceComplexIntegration} provides functions for the indefinite integration of complex-valued functions.")) (|complexIntegrate| ((|#2| |#2| (|Symbol|)) "\\spad{complexIntegrate(f, \\spad{x)}} returns the integral of \\spad{f(x)dx} where \\spad{x} is viewed as a complex variable.")) (|internalIntegrate0| (((|IntegrationResult| |#2|) |#2| (|Symbol|)) "\\spad{internalIntegrate0 should} be a local function, but is conditional.")) (|internalIntegrate| (((|IntegrationResult| |#2|) |#2| (|Symbol|)) "\\spad{internalIntegrate(f, \\spad{x)}} returns the integral of \\spad{f(x)dx} where \\spad{x} is viewed as a complex variable."))) 
NIL 
NIL 
(|FourierSeries| R E) 
((|constructor| (NIL "This domain converts terms into Fourier series")) (|makeCos| (($ |#2| |#1|) "\\indented{1}{makeCos(e,r) makes a sin expression with given} argument and coefficient")) (|makeSin| (($ |#2| |#1|) "\\spad{makeSin(e,r)} makes a sin expression with given argument and coefficient")) (|coerce| (($ (|FourierComponent| |#2|)) "\\spad{coerce(c)} converts sin/cos terms into Fourier Series") (($ |#1|) "\\spad{coerce(r)} converts coefficients into Fourier Series"))) 
((|canonical| AND (|has| |#1| (ATTRIBUTE |canonical|)) (|has| |#2| (ATTRIBUTE |canonical|))) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((AND (|HasAttribute| |#1| (QUOTE |canonical|)) (|HasAttribute| |#2| (QUOTE |canonical|)))) 
(|FunctionSpaceIntegration| R F) 
((|constructor| (NIL "Top-level real function integration \\spadtype{FunctionSpaceIntegration} provides functions for the indefinite integration of real-valued functions.")) (|integrate| (((|Union| |#2| (|List| |#2|)) |#2| (|Symbol|)) "\\spad{integrate(f, \\spad{x)}} returns the integral of \\spad{f(x)dx} where \\spad{x} is viewed as a real variable."))) 
NIL 
NIL 
(|FunctionSpace&| S R) 
((|constructor| (NIL "Category for formal functions A space of formal functions with arguments in an arbitrary ordered set.")) (|univariate| (((|Fraction| (|SparseUnivariatePolynomial| $)) $ (|Kernel| $)) "\\spad{univariate(f, \\spad{k)}} returns \\spad{f} viewed as a univariate fraction in \\spad{k.}")) (/ (($ (|SparseMultivariatePolynomial| |#2| (|Kernel| $)) (|SparseMultivariatePolynomial| |#2| (|Kernel| $))) "\\spad{p1/p2} returns the quotient of \\spad{p1} and \\spad{p2} as an element of \\spad{%.}")) (|denominator| (($ $) "\\spad{denominator(f)} returns the denominator of \\spad{f} converted to \\spad{%.}")) (|denom| (((|SparseMultivariatePolynomial| |#2| (|Kernel| $)) $) "\\spad{denom(f)} returns the denominator of \\spad{f} viewed as a polynomial in the kernels over \\spad{R.}")) (|convert| (($ (|Factored| $)) "\\spad{convert(f1\\^e1 \\spad{...} fm\\^em)} returns \\spad{(f1)\\^e1 \\spad{...} (fm)\\^em} as an element of \\spad{%,} using formal kernels created using a \\spadfunFrom{paren}{ExpressionSpace}.")) (|isPower| (((|Union| (|Record| (|:| |val| $) (|:| |exponent| (|Integer|))) "failed") $) "\\spad{isPower(p)} returns \\spad{[x, \\spad{n]}} if \\spad{p = x**n} and \\spad{n \\spad{<>} 0}.")) (|numerator| (($ $) "\\spad{numerator(f)} returns the numerator of \\spad{f} converted to \\spad{%.}")) (|numer| (((|SparseMultivariatePolynomial| |#2| (|Kernel| $)) $) "\\spad{numer(f)} returns the numerator of \\spad{f} viewed as a polynomial in the kernels over \\spad{R} if \\spad{R} is an integral domain. If not, then numer(f) = \\spad{f} viewed as a polynomial in the kernels over \\spad{R.}")) (|coerce| (($ (|Fraction| (|Polynomial| (|Fraction| |#2|)))) "\\spad{coerce(f)} returns \\spad{f} as an element of \\spad{%.}") (($ (|Polynomial| (|Fraction| |#2|))) "\\spad{coerce(p)} returns \\spad{p} as an element of \\spad{%.}") (($ (|Fraction| |#2|)) "\\spad{coerce(q)} returns \\spad{q} as an element of \\spad{%.}") (($ (|SparseMultivariatePolynomial| |#2| (|Kernel| $))) "\\spad{coerce(p)} returns \\spad{p} as an element of \\spad{%.}")) (|isMult| (((|Union| (|Record| (|:| |coef| (|Integer|)) (|:| |var| (|Kernel| $))) "failed") $) "\\spad{isMult(p)} returns \\spad{[n, \\spad{x]}} if \\spad{p = \\spad{n} * \\spad{x}} and \\spad{n \\spad{<>} 0}.")) (|isPlus| (((|Union| (|List| $) "failed") $) "\\spad{isPlus(p)} returns \\spad{[m1,...,mn]} if \\spad{p = \\spad{m1} +...+ \\spad{mn}} and \\spad{n > 1}.")) (|isExpt| (((|Union| (|Record| (|:| |var| (|Kernel| $)) (|:| |exponent| (|Integer|))) "failed") $ (|Symbol|)) "\\spad{isExpt(p,f)} returns \\spad{[x, \\spad{n]}} if \\spad{p = x**n} and \\spad{n \\spad{<>} 0} and \\spad{x = f(a)}.") (((|Union| (|Record| (|:| |var| (|Kernel| $)) (|:| |exponent| (|Integer|))) "failed") $ (|BasicOperator|)) "\\spad{isExpt(p,op)} returns \\spad{[x, \\spad{n]}} if \\spad{p = x**n} and \\spad{n \\spad{<>} 0} and \\spad{x = op(a)}.") (((|Union| (|Record| (|:| |var| (|Kernel| $)) (|:| |exponent| (|Integer|))) "failed") $) "\\spad{isExpt(p)} returns \\spad{[x, \\spad{n]}} if \\spad{p = x**n} and \\spad{n \\spad{<>} 0}.")) (|isTimes| (((|Union| (|List| $) "failed") $) "\\spad{isTimes(p)} returns \\spad{[a1,...,an]} if \\spad{p = a1*...*an} and \\spad{n > 1}.")) (** (($ $ (|NonNegativeInteger|)) "\\spad{x**n} returns \\spad{x} * \\spad{x} * \\spad{x} * \\spad{...} * \\spad{x} \\spad{(n} times).")) (|eval| (($ $ (|Symbol|) (|NonNegativeInteger|) (|Mapping| $ $)) "\\spad{eval(x, \\spad{s,} \\spad{n,} \\spad{f)}} replaces every \\spad{s(a)**n} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.") (($ $ (|Symbol|) (|NonNegativeInteger|) (|Mapping| $ (|List| $))) "\\spad{eval(x, \\spad{s,} \\spad{n,} \\spad{f)}} replaces every \\spad{s(a1,...,am)**n} in \\spad{x} by \\spad{f(a1,...,am)} for any a1,...,am.") (($ $ (|List| (|Symbol|)) (|List| (|NonNegativeInteger|)) (|List| (|Mapping| $ (|List| $)))) "\\spad{eval(x, [s1,...,sm], [n1,...,nm], [f1,...,fm])} replaces every \\spad{si(a1,...,an)**ni} in \\spad{x} by \\spad{fi(a1,...,an)} for any a1,...,am.") (($ $ (|List| (|Symbol|)) (|List| (|NonNegativeInteger|)) (|List| (|Mapping| $ $))) "\\spad{eval(x, [s1,...,sm], [n1,...,nm], [f1,...,fm])} replaces every \\spad{si(a)**ni} in \\spad{x} by \\spad{fi(a)} for any \\spad{a}.") (($ $ (|List| (|BasicOperator|)) (|List| $) (|Symbol|)) "\\spad{eval(x, [s1,...,sm], [f1,...,fm], \\spad{y)}} replaces every \\spad{si(a)} in \\spad{x} by \\spad{fi(y)} with \\spad{y} replaced by \\spad{a} for any \\spad{a}.") (($ $ (|BasicOperator|) $ (|Symbol|)) "\\spad{eval(x, \\spad{s,} \\spad{f,} \\spad{y)}} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(y)} with \\spad{y} replaced by \\spad{a} for any \\spad{a}.") (($ $) "\\spad{eval(f)} unquotes all the quoted operators in \\spad{f.}") (($ $ (|List| (|Symbol|))) "\\spad{eval(f, [foo1,...,foon])} unquotes all the \\spad{fooi}'s in \\spad{f.}") (($ $ (|Symbol|)) "\\spad{eval(f, foo)} unquotes all the foo's in \\spad{f.}")) (|applyQuote| (($ (|Symbol|) (|List| $)) "\\spad{applyQuote(foo, [x1,...,xn])} returns \\spad{'foo(x1,...,xn)}.") (($ (|Symbol|) $ $ $ $) "\\spad{applyQuote(foo, \\spad{x,} \\spad{y,} \\spad{z,} \\spad{t)}} returns \\spad{'foo(x,y,z,t)}.") (($ (|Symbol|) $ $ $) "\\spad{applyQuote(foo, \\spad{x,} \\spad{y,} \\spad{z)}} returns \\spad{'foo(x,y,z)}.") (($ (|Symbol|) $ $) "\\spad{applyQuote(foo, \\spad{x,} \\spad{y)}} returns \\spad{'foo(x,y)}.") (($ (|Symbol|) $) "\\spad{applyQuote(foo, \\spad{x)}} returns \\spad{'foo(x)}.")) (|variables| (((|List| (|Symbol|)) $) "\\spad{variables(f)} returns the list of all the variables of \\spad{f.}")) (|ground| ((|#2| $) "\\spad{ground(f)} returns \\spad{f} as an element of \\spad{R.} An error occurs if \\spad{f} is not an element of \\spad{R.}")) (|ground?| (((|Boolean|) $) "\\spad{ground?(f)} tests if \\spad{f} is an element of \\spad{R.}"))) 
NIL 
((|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (QUOTE (|Ring|))) (|HasCategory| |#2| (QUOTE (|AbelianGroup|))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#2| (QUOTE (|Group|))) (|HasCategory| |#2| (QUOTE (|SemiGroup|))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) 
(|FunctionSpace| R) 
((|constructor| (NIL "Category for formal functions A space of formal functions with arguments in an arbitrary ordered set.")) (|univariate| (((|Fraction| (|SparseUnivariatePolynomial| $)) $ (|Kernel| $)) "\\spad{univariate(f, \\spad{k)}} returns \\spad{f} viewed as a univariate fraction in \\spad{k.}")) (/ (($ (|SparseMultivariatePolynomial| |#1| (|Kernel| $)) (|SparseMultivariatePolynomial| |#1| (|Kernel| $))) "\\spad{p1/p2} returns the quotient of \\spad{p1} and \\spad{p2} as an element of \\spad{%.}")) (|denominator| (($ $) "\\spad{denominator(f)} returns the denominator of \\spad{f} converted to \\spad{%.}")) (|denom| (((|SparseMultivariatePolynomial| |#1| (|Kernel| $)) $) "\\spad{denom(f)} returns the denominator of \\spad{f} viewed as a polynomial in the kernels over \\spad{R.}")) (|convert| (($ (|Factored| $)) "\\spad{convert(f1\\^e1 \\spad{...} fm\\^em)} returns \\spad{(f1)\\^e1 \\spad{...} (fm)\\^em} as an element of \\spad{%,} using formal kernels created using a \\spadfunFrom{paren}{ExpressionSpace}.")) (|isPower| (((|Union| (|Record| (|:| |val| $) (|:| |exponent| (|Integer|))) "failed") $) "\\spad{isPower(p)} returns \\spad{[x, \\spad{n]}} if \\spad{p = x**n} and \\spad{n \\spad{<>} 0}.")) (|numerator| (($ $) "\\spad{numerator(f)} returns the numerator of \\spad{f} converted to \\spad{%.}")) (|numer| (((|SparseMultivariatePolynomial| |#1| (|Kernel| $)) $) "\\spad{numer(f)} returns the numerator of \\spad{f} viewed as a polynomial in the kernels over \\spad{R} if \\spad{R} is an integral domain. If not, then numer(f) = \\spad{f} viewed as a polynomial in the kernels over \\spad{R.}")) (|coerce| (($ (|Fraction| (|Polynomial| (|Fraction| |#1|)))) "\\spad{coerce(f)} returns \\spad{f} as an element of \\spad{%.}") (($ (|Polynomial| (|Fraction| |#1|))) "\\spad{coerce(p)} returns \\spad{p} as an element of \\spad{%.}") (($ (|Fraction| |#1|)) "\\spad{coerce(q)} returns \\spad{q} as an element of \\spad{%.}") (($ (|SparseMultivariatePolynomial| |#1| (|Kernel| $))) "\\spad{coerce(p)} returns \\spad{p} as an element of \\spad{%.}")) (|isMult| (((|Union| (|Record| (|:| |coef| (|Integer|)) (|:| |var| (|Kernel| $))) "failed") $) "\\spad{isMult(p)} returns \\spad{[n, \\spad{x]}} if \\spad{p = \\spad{n} * \\spad{x}} and \\spad{n \\spad{<>} 0}.")) (|isPlus| (((|Union| (|List| $) "failed") $) "\\spad{isPlus(p)} returns \\spad{[m1,...,mn]} if \\spad{p = \\spad{m1} +...+ \\spad{mn}} and \\spad{n > 1}.")) (|isExpt| (((|Union| (|Record| (|:| |var| (|Kernel| $)) (|:| |exponent| (|Integer|))) "failed") $ (|Symbol|)) "\\spad{isExpt(p,f)} returns \\spad{[x, \\spad{n]}} if \\spad{p = x**n} and \\spad{n \\spad{<>} 0} and \\spad{x = f(a)}.") (((|Union| (|Record| (|:| |var| (|Kernel| $)) (|:| |exponent| (|Integer|))) "failed") $ (|BasicOperator|)) "\\spad{isExpt(p,op)} returns \\spad{[x, \\spad{n]}} if \\spad{p = x**n} and \\spad{n \\spad{<>} 0} and \\spad{x = op(a)}.") (((|Union| (|Record| (|:| |var| (|Kernel| $)) (|:| |exponent| (|Integer|))) "failed") $) "\\spad{isExpt(p)} returns \\spad{[x, \\spad{n]}} if \\spad{p = x**n} and \\spad{n \\spad{<>} 0}.")) (|isTimes| (((|Union| (|List| $) "failed") $) "\\spad{isTimes(p)} returns \\spad{[a1,...,an]} if \\spad{p = a1*...*an} and \\spad{n > 1}.")) (** (($ $ (|NonNegativeInteger|)) "\\spad{x**n} returns \\spad{x} * \\spad{x} * \\spad{x} * \\spad{...} * \\spad{x} \\spad{(n} times).")) (|eval| (($ $ (|Symbol|) (|NonNegativeInteger|) (|Mapping| $ $)) "\\spad{eval(x, \\spad{s,} \\spad{n,} \\spad{f)}} replaces every \\spad{s(a)**n} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.") (($ $ (|Symbol|) (|NonNegativeInteger|) (|Mapping| $ (|List| $))) "\\spad{eval(x, \\spad{s,} \\spad{n,} \\spad{f)}} replaces every \\spad{s(a1,...,am)**n} in \\spad{x} by \\spad{f(a1,...,am)} for any a1,...,am.") (($ $ (|List| (|Symbol|)) (|List| (|NonNegativeInteger|)) (|List| (|Mapping| $ (|List| $)))) "\\spad{eval(x, [s1,...,sm], [n1,...,nm], [f1,...,fm])} replaces every \\spad{si(a1,...,an)**ni} in \\spad{x} by \\spad{fi(a1,...,an)} for any a1,...,am.") (($ $ (|List| (|Symbol|)) (|List| (|NonNegativeInteger|)) (|List| (|Mapping| $ $))) "\\spad{eval(x, [s1,...,sm], [n1,...,nm], [f1,...,fm])} replaces every \\spad{si(a)**ni} in \\spad{x} by \\spad{fi(a)} for any \\spad{a}.") (($ $ (|List| (|BasicOperator|)) (|List| $) (|Symbol|)) "\\spad{eval(x, [s1,...,sm], [f1,...,fm], \\spad{y)}} replaces every \\spad{si(a)} in \\spad{x} by \\spad{fi(y)} with \\spad{y} replaced by \\spad{a} for any \\spad{a}.") (($ $ (|BasicOperator|) $ (|Symbol|)) "\\spad{eval(x, \\spad{s,} \\spad{f,} \\spad{y)}} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(y)} with \\spad{y} replaced by \\spad{a} for any \\spad{a}.") (($ $) "\\spad{eval(f)} unquotes all the quoted operators in \\spad{f.}") (($ $ (|List| (|Symbol|))) "\\spad{eval(f, [foo1,...,foon])} unquotes all the \\spad{fooi}'s in \\spad{f.}") (($ $ (|Symbol|)) "\\spad{eval(f, foo)} unquotes all the foo's in \\spad{f.}")) (|applyQuote| (($ (|Symbol|) (|List| $)) "\\spad{applyQuote(foo, [x1,...,xn])} returns \\spad{'foo(x1,...,xn)}.") (($ (|Symbol|) $ $ $ $) "\\spad{applyQuote(foo, \\spad{x,} \\spad{y,} \\spad{z,} \\spad{t)}} returns \\spad{'foo(x,y,z,t)}.") (($ (|Symbol|) $ $ $) "\\spad{applyQuote(foo, \\spad{x,} \\spad{y,} \\spad{z)}} returns \\spad{'foo(x,y,z)}.") (($ (|Symbol|) $ $) "\\spad{applyQuote(foo, \\spad{x,} \\spad{y)}} returns \\spad{'foo(x,y)}.") (($ (|Symbol|) $) "\\spad{applyQuote(foo, \\spad{x)}} returns \\spad{'foo(x)}.")) (|variables| (((|List| (|Symbol|)) $) "\\spad{variables(f)} returns the list of all the variables of \\spad{f.}")) (|ground| ((|#1| $) "\\spad{ground(f)} returns \\spad{f} as an element of \\spad{R.} An error occurs if \\spad{f} is not an element of \\spad{R.}")) (|ground?| (((|Boolean|) $) "\\spad{ground?(f)} tests if \\spad{f} is an element of \\spad{R.}"))) 
((|unitsKnown| OR (|has| |#1| (|Ring|)) (|has| |#1| (|Group|))) (|leftUnitary| |has| |#1| (|CommutativeRing|)) (|rightUnitary| |has| |#1| (|CommutativeRing|)) ((|commutative| "*") |has| |#1| (|IntegralDomain|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (|IntegralDomain|)) (|canonicalsClosed| |has| |#1| (|IntegralDomain|)) (|nil| . T)) 
NIL 
(|FunctionalSpecialFunction| R F) 
((|constructor| (NIL "Provides some special functions over an integral domain.")) (|iiAiryBi| ((|#2| |#2|) "\\spad{iiAiryBi(x)} should be local but conditional.")) (|iiAiryAi| ((|#2| |#2|) "\\spad{iiAiryAi(x)} should be local but conditional.")) (|iiBesselK| ((|#2| (|List| |#2|)) "\\spad{iiBesselK(x)} should be local but conditional.")) (|iiBesselI| ((|#2| (|List| |#2|)) "\\spad{iiBesselI(x)} should be local but conditional.")) (|iiBesselY| ((|#2| (|List| |#2|)) "\\spad{iiBesselY(x)} should be local but conditional.")) (|iiBesselJ| ((|#2| (|List| |#2|)) "\\spad{iiBesselJ(x)} should be local but conditional.")) (|iipolygamma| ((|#2| (|List| |#2|)) "\\spad{iipolygamma(x)} should be local but conditional.")) (|iidigamma| ((|#2| |#2|) "\\spad{iidigamma(x)} should be local but conditional.")) (|iiBeta| ((|#2| (|List| |#2|)) "\\spad{iiBeta(x)} should be local but conditional.")) (|iiabs| ((|#2| |#2|) "\\spad{iiabs(x)} should be local but conditional.")) (|iiGamma| ((|#2| |#2|) "\\spad{iiGamma(x)} should be local but conditional.")) (|airyBi| ((|#2| |#2|) "\\spad{airyBi(x)} returns the airybi function applied to \\spad{x}")) (|airyAi| ((|#2| |#2|) "\\spad{airyAi(x)} returns the airyai function applied to \\spad{x}")) (|besselK| ((|#2| |#2| |#2|) "\\spad{besselK(x,y)} returns the besselk function applied to \\spad{x} and \\spad{y}")) (|besselI| ((|#2| |#2| |#2|) "\\spad{besselI(x,y)} returns the besseli function applied to \\spad{x} and \\spad{y}")) (|besselY| ((|#2| |#2| |#2|) "\\spad{besselY(x,y)} returns the bessely function applied to \\spad{x} and \\spad{y}")) (|besselJ| ((|#2| |#2| |#2|) "\\spad{besselJ(x,y)} returns the besselj function applied to \\spad{x} and \\spad{y}")) (|polygamma| ((|#2| |#2| |#2|) "\\spad{polygamma(x,y)} returns the polygamma function applied to \\spad{x} and \\spad{y}")) (|digamma| ((|#2| |#2|) "\\spad{digamma(x)} returns the digamma function applied to \\spad{x}")) (|Beta| ((|#2| |#2| |#2|) "\\spad{Beta(x,y)} returns the beta function applied to \\spad{x} and \\spad{y}")) (|Gamma| ((|#2| |#2| |#2|) "\\spad{Gamma(a,x)} returns the incomplete Gamma function applied to a and \\spad{x}") ((|#2| |#2|) "\\spad{Gamma(f)} returns the formal Gamma function applied to \\spad{f}")) (|abs| ((|#2| |#2|) "\\spad{abs(f)} returns the absolute value operator applied to \\spad{f}")) (|operator| (((|BasicOperator|) (|BasicOperator|)) "\\spad{operator(op)} returns a copy of \\spad{op} with the domain-dependent properties appropriate for \\spad{F;} error if \\spad{op} is not a special function operator")) (|belong?| (((|Boolean|) (|BasicOperator|)) "\\spad{belong?(op)} is \\spad{true} if \\spad{op} is a special function operator."))) 
NIL 
NIL 
(|FunctionSpacePrimitiveElement| R F) 
((|constructor| (NIL "FunctionsSpacePrimitiveElement provides functions to compute primitive elements in functions spaces.")) (|primitiveElement| (((|Record| (|:| |primelt| |#2|) (|:| |pol1| (|SparseUnivariatePolynomial| |#2|)) (|:| |pol2| (|SparseUnivariatePolynomial| |#2|)) (|:| |prim| (|SparseUnivariatePolynomial| |#2|))) |#2| |#2|) "\\spad{primitiveElement(a1, a2)} returns \\spad{[a, \\spad{q1,} \\spad{q2,} \\spad{q]}} such that \\spad{k(a1, a2) = k(a)}, \\spad{ai = qi(a)}, and \\spad{q(a) = 0}. The minimal polynomial for \\spad{a2} may involve a1, but the minimal polynomial for \\spad{a1} may not involve a2; This operations uses \\spadfun{resultant}.") (((|Record| (|:| |primelt| |#2|) (|:| |poly| (|List| (|SparseUnivariatePolynomial| |#2|))) (|:| |prim| (|SparseUnivariatePolynomial| |#2|))) (|List| |#2|)) "\\spad{primitiveElement([a1,...,an])} returns \\spad{[a, [q1,...,qn], \\spad{q]}} such that then \\spad{k(a1,...,an) = k(a)}, \\spad{ai = qi(a)}, and \\spad{q(a) = 0}. This operation uses the technique of \\spadglossSee{groebner bases}{Groebner basis}."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|AlgebraicallyClosedField|)))) 
(|FunctionSpaceReduce| R F) 
((|constructor| (NIL "Reduction from a function space to the rational numbers This package provides function which replaces transcendental kernels in a function space by random integers. The correspondence between the kernels and the integers is fixed between calls to new().")) (|newReduc| (((|Void|)) "\\spad{newReduc()} \\undocumented")) (|bringDown| (((|SparseUnivariatePolynomial| (|Fraction| (|Integer|))) |#2| (|Kernel| |#2|)) "\\spad{bringDown(f,k)} \\undocumented") (((|Fraction| (|Integer|)) |#2|) "\\spad{bringDown(f)} \\undocumented"))) 
NIL 
NIL 
(|FortranScalarType|) 
((|constructor| (NIL "Creates and manipulates objects which correspond to the basic FORTRAN data types: REAL, INTEGER, COMPLEX, LOGICAL and CHARACTER")) (= (((|Boolean|) $ $) "\\spad{x=y} tests for equality")) (|logical?| (((|Boolean|) $) "\\spad{logical?(t)} tests whether \\spad{t} is equivalent to the FORTRAN type LOGICAL.")) (|character?| (((|Boolean|) $) "\\spad{character?(t)} tests whether \\spad{t} is equivalent to the FORTRAN type CHARACTER.")) (|doubleComplex?| (((|Boolean|) $) "\\spad{doubleComplex?(t)} tests whether \\spad{t} is equivalent to the (non-standard) FORTRAN type DOUBLE COMPLEX.")) (|complex?| (((|Boolean|) $) "\\spad{complex?(t)} tests whether \\spad{t} is equivalent to the FORTRAN type COMPLEX.")) (|integer?| (((|Boolean|) $) "\\spad{integer?(t)} tests whether \\spad{t} is equivalent to the FORTRAN type INTEGER.")) (|double?| (((|Boolean|) $) "\\spad{double?(t)} tests whether \\spad{t} is equivalent to the FORTRAN type DOUBLE PRECISION")) (|real?| (((|Boolean|) $) "\\spad{real?(t)} tests whether \\spad{t} is equivalent to the FORTRAN type REAL.")) (|coerce| (((|SExpression|) $) "\\spad{coerce(x)} returns the s-expression associated with \\spad{x}") (((|Symbol|) $) "\\spad{coerce(x)} returns the symbol associated with \\spad{x}") (($ (|Symbol|)) "\\spad{coerce(s)} transforms the symbol \\spad{s} into an element of FortranScalarType provided \\spad{s} is one of real, complex,double precision, logical, integer, character, REAL, COMPLEX, LOGICAL, INTEGER, CHARACTER, DOUBLE PRECISION") (($ (|String|)) "\\spad{coerce(s)} transforms the string \\spad{s} into an element of FortranScalarType provided \\spad{s} is one of \"real\", \"double precision\", \"complex\", \"logical\", \"integer\", \"character\", \"REAL\", \"COMPLEX\", \"LOGICAL\", \"INTEGER\", \"CHARACTER\", \"DOUBLE PRECISION\""))) 
NIL 
NIL 
(|FunctionSpaceUnivariatePolynomialFactor| R F UP) 
((|constructor| (NIL "This package is used internally by IR2F")) (|anfactor| (((|Union| (|Factored| (|SparseUnivariatePolynomial| (|AlgebraicNumber|))) "failed") |#3|) "\\spad{anfactor(p)} tries to factor \\spad{p} over algebraic numbers, returning \"failed\" if it cannot")) (|UP2ifCan| (((|Union| (|:| |overq| (|SparseUnivariatePolynomial| (|Fraction| (|Integer|)))) (|:| |overan| (|SparseUnivariatePolynomial| (|AlgebraicNumber|))) (|:| |failed| (|Boolean|))) |#3|) "\\spad{UP2ifCan(x)} should be local but conditional.")) (|qfactor| (((|Union| (|Factored| (|SparseUnivariatePolynomial| (|Fraction| (|Integer|)))) "failed") |#3|) "\\spad{qfactor(p)} tries to factor \\spad{p} over fractions of integers, returning \"failed\" if it cannot")) (|ffactor| (((|Factored| |#3|) |#3|) "\\spad{ffactor(p)} tries to factor a univariate polynomial \\spad{p} over \\spad{F}"))) 
NIL 
((|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|AlgebraicNumber|))))) 
(|FortranTemplate|) 
((|constructor| (NIL "Code to manipulate Fortran templates")) (|fortranCarriageReturn| (((|Void|)) "\\spad{fortranCarriageReturn()} produces a carriage return on the current Fortran output stream")) (|fortranLiteral| (((|Void|) (|String|)) "\\spad{fortranLiteral(s)} writes \\spad{s} to the current Fortran output stream")) (|fortranLiteralLine| (((|Void|) (|String|)) "\\spad{fortranLiteralLine(s)} writes \\spad{s} to the current Fortran output stream, followed by a carriage return")) (|processTemplate| (((|FileName|) (|FileName|)) "\\spad{processTemplate(tp)} processes the template \\spad{tp,} writing the result to the current FORTRAN output stream.") (((|FileName|) (|FileName|) (|FileName|)) "\\spad{processTemplate(tp,fn)} processes the template \\spad{tp,} writing the result out to \\spad{fn.}"))) 
NIL 
NIL 
(|FortranType|) 
((|constructor| (NIL "Creates and manipulates objects which correspond to FORTRAN data types, including array dimensions.")) (|fortranCharacter| (($) "\\spad{fortranCharacter()} returns CHARACTER, an element of FortranType")) (|fortranDoubleComplex| (($) "\\spad{fortranDoubleComplex()} returns DOUBLE COMPLEX, an element of FortranType")) (|fortranComplex| (($) "\\spad{fortranComplex()} returns COMPLEX, an element of FortranType")) (|fortranLogical| (($) "\\spad{fortranLogical()} returns LOGICAL, an element of FortranType")) (|fortranInteger| (($) "\\spad{fortranInteger()} returns INTEGER, an element of FortranType")) (|fortranDouble| (($) "\\spad{fortranDouble()} returns DOUBLE PRECISION, an element of FortranType")) (|fortranReal| (($) "\\spad{fortranReal()} returns REAL, an element of FortranType")) (|construct| (($ (|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| "void")) (|List| (|Polynomial| (|Integer|))) (|Boolean|)) "\\spad{construct(type,dims)} creates an element of FortranType") (($ (|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| "void")) (|List| (|Symbol|)) (|Boolean|)) "\\spad{construct(type,dims)} creates an element of FortranType")) (|external?| (((|Boolean|) $) "\\spad{external?(u)} returns \\spad{true} if \\spad{u} is declared to be EXTERNAL")) (|dimensionsOf| (((|List| (|Polynomial| (|Integer|))) $) "\\spad{dimensionsOf(t)} returns the dimensions of \\spad{t}")) (|scalarTypeOf| (((|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| "void")) $) "\\spad{scalarTypeOf(t)} returns the FORTRAN data type of \\spad{t}")) (|coerce| (($ (|FortranScalarType|)) "\\spad{coerce(t)} creates an element from a scalar type") (((|OutputForm|) $) "\\spad{coerce(x)} provides a printable form for \\spad{x}"))) 
NIL 
NIL 
(|FunctionCalled| |f|) 
((|constructor| (NIL "This domain implements named functions")) (|name| (((|Symbol|) $) "\\spad{name(x)} returns the symbol"))) 
NIL 
NIL 
(|FortranVectorCategory|) 
((|constructor| (NIL "\\axiomType{FortranVectorCategory} provides support for producing Functions and Subroutines when the input to these is an AXIOM object of type \\axiomType{Vector} or in domains involving \\axiomType{FortranCode}.")) (|coerce| (($ (|Record| (|:| |localSymbols| (|SymbolTable|)) (|:| |code| (|List| (|FortranCode|))))) "\\spad{coerce(e)} takes the component of \\spad{e} from \\spadtype{List FortranCode} and uses it as the body of the ASP, making the declarations in the \\spadtype{SymbolTable} component.") (($ (|FortranCode|)) "\\spad{coerce(e)} takes an object from \\spadtype{FortranCode} and \\indented{1}{uses it as the body of an ASP.}") (($ (|List| (|FortranCode|))) "\\spad{coerce(e)} takes an object from \\spadtype{List FortranCode} and \\indented{1}{uses it as the body of an ASP.}") (($ (|Vector| (|MachineFloat|))) "\\spad{coerce(v)} produces an ASP which returns the value of \\spad{v}."))) 
((|nil| . T)) 
NIL 
(|FortranVectorFunctionCategory|) 
((|constructor| (NIL "\\axiomType{FortranVectorFunctionCategory} is the catagory of arguments to NAG Library routines which return the values of vectors of functions.")) (|retractIfCan| (((|Union| $ "failed") (|Vector| (|Fraction| (|Polynomial| (|Integer|))))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Vector| (|Fraction| (|Polynomial| (|Float|))))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Vector| (|Polynomial| (|Integer|)))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Vector| (|Polynomial| (|Float|)))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Vector| (|Expression| (|Integer|)))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (((|Union| $ "failed") (|Vector| (|Expression| (|Float|)))) "\\spad{retractIfCan(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}")) (|retract| (($ (|Vector| (|Fraction| (|Polynomial| (|Integer|))))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Vector| (|Fraction| (|Polynomial| (|Float|))))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Vector| (|Polynomial| (|Integer|)))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Vector| (|Polynomial| (|Float|)))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Vector| (|Expression| (|Integer|)))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}") (($ (|Vector| (|Expression| (|Float|)))) "\\spad{retract(e)} tries to convert \\spad{e} into an ASP, checking that \\indented{1}{legal \\spad{Fortran-77} is produced.}")) (|coerce| (($ (|Record| (|:| |localSymbols| (|SymbolTable|)) (|:| |code| (|List| (|FortranCode|))))) "\\spad{coerce(e)} takes the component of \\spad{e} from \\spadtype{List FortranCode} and uses it as the body of the ASP, making the declarations in the \\spadtype{SymbolTable} component.") (($ (|FortranCode|)) "\\spad{coerce(e)} takes an object from \\spadtype{FortranCode} and \\indented{1}{uses it as the body of an ASP.}") (($ (|List| (|FortranCode|))) "\\spad{coerce(e)} takes an object from \\spadtype{List FortranCode} and \\indented{1}{uses it as the body of an ASP.}"))) 
((|nil| . T)) 
NIL 
(|GaloisGroupFactorizer| UP) 
((|constructor| (NIL "\\spadtype{GaloisGroupFactorizer} provides functions to factor resolvents.")) (|btwFact| (((|Record| (|:| |contp| (|Integer|)) (|:| |factors| (|List| (|Record| (|:| |irr| |#1|) (|:| |pow| (|Integer|)))))) |#1| (|Boolean|) (|Set| (|NonNegativeInteger|)) (|NonNegativeInteger|)) "\\spad{btwFact(p,sqf,pd,r)} returns the factorization of \\spad{p,} the result is a Record such that \\spad{contp=}content \\spad{p,} \\spad{factors=}List of irreducible factors of \\spad{p} with exponent. If \\spad{sqf=true} the polynomial is assumed to be square free (\\spadignore{i.e.} without repeated factors). \\spad{pd} is the \\spadtype{Set} of possible degrees. \\spad{r} is a lower bound for the number of factors of \\spad{p.} Please do not use this function in your code because its design may change.")) (|henselFact| (((|Record| (|:| |contp| (|Integer|)) (|:| |factors| (|List| (|Record| (|:| |irr| |#1|) (|:| |pow| (|Integer|)))))) |#1| (|Boolean|)) "\\spad{henselFact(p,sqf)} returns the factorization of \\spad{p,} the result is a Record such that \\spad{contp=}content \\spad{p,} \\spad{factors=}List of irreducible factors of \\spad{p} with exponent. If \\spad{sqf=true} the polynomial is assumed to be square free (\\spadignore{i.e.} without repeated factors).")) (|factorOfDegree| (((|Union| |#1| "failed") (|PositiveInteger|) |#1| (|List| (|NonNegativeInteger|)) (|NonNegativeInteger|) (|Boolean|)) "\\spad{factorOfDegree(d,p,listOfDegrees,r,sqf)} returns a factor of \\spad{p} of degree \\spad{d} knowing that \\spad{p} has for possible splitting of its degree listOfDegrees, and that \\spad{p} has at least \\spad{r} factors. If \\spad{sqf=true} the polynomial is assumed to be square free (\\spadignore{i.e.} without repeated factors).") (((|Union| |#1| "failed") (|PositiveInteger|) |#1| (|List| (|NonNegativeInteger|)) (|NonNegativeInteger|)) "\\spad{factorOfDegree(d,p,listOfDegrees,r)} returns a factor of \\spad{p} of degree \\spad{d} knowing that \\spad{p} has for possible splitting of its degree listOfDegrees, and that \\spad{p} has at least \\spad{r} factors.") (((|Union| |#1| "failed") (|PositiveInteger|) |#1| (|List| (|NonNegativeInteger|))) "\\spad{factorOfDegree(d,p,listOfDegrees)} returns a factor of \\spad{p} of degree \\spad{d} knowing that \\spad{p} has for possible splitting of its degree listOfDegrees.") (((|Union| |#1| "failed") (|PositiveInteger|) |#1| (|NonNegativeInteger|)) "\\spad{factorOfDegree(d,p,r)} returns a factor of \\spad{p} of degree \\spad{d} knowing that \\spad{p} has at least \\spad{r} factors.") (((|Union| |#1| "failed") (|PositiveInteger|) |#1|) "\\spad{factorOfDegree(d,p)} returns a factor of \\spad{p} of degree \\spad{d.}")) (|factorSquareFree| (((|Factored| |#1|) |#1| (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{factorSquareFree(p,d,r)} factorizes the polynomial \\spad{p} using the single factor bound algorithm, knowing that \\spad{d} divides the degree of all factors of \\spad{p} and that \\spad{p} has at least \\spad{r} factors. \\spad{f} is supposed not having any repeated factor (this is not checked).") (((|Factored| |#1|) |#1| (|List| (|NonNegativeInteger|)) (|NonNegativeInteger|)) "\\spad{factorSquareFree(p,listOfDegrees,r)} factorizes the polynomial \\spad{p} using the single factor bound algorithm, knowing that \\spad{p} has for possible splitting of its degree \\spad{listOfDegrees} and that \\spad{p} has at least \\spad{r} factors. \\spad{f} is supposed not having any repeated factor (this is not checked).") (((|Factored| |#1|) |#1| (|List| (|NonNegativeInteger|))) "\\spad{factorSquareFree(p,listOfDegrees)} factorizes the polynomial \\spad{p} using the single factor bound algorithm and knowing that \\spad{p} has for possible splitting of its degree listOfDegrees. \\spad{f} is supposed not having any repeated factor (this is not checked).") (((|Factored| |#1|) |#1| (|NonNegativeInteger|)) "\\spad{factorSquareFree(p,r)} factorizes the polynomial \\spad{p} using the single factor bound algorithm and knowing that \\spad{p} has at least \\spad{r} factors. \\spad{f} is supposed not having any repeated factor (this is not checked).") (((|Factored| |#1|) |#1|) "\\spad{factorSquareFree(p)} returns the factorization of \\spad{p} which is supposed not having any repeated factor (this is not checked).")) (|factor| (((|Factored| |#1|) |#1| (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{factor(p,d,r)} factorizes the polynomial \\spad{p} using the single factor bound algorithm, knowing that \\spad{d} divides the degree of all factors of \\spad{p} and that \\spad{p} has at least \\spad{r} factors.") (((|Factored| |#1|) |#1| (|List| (|NonNegativeInteger|)) (|NonNegativeInteger|)) "\\spad{factor(p,listOfDegrees,r)} factorizes the polynomial \\spad{p} using the single factor bound algorithm, knowing that \\spad{p} has for possible splitting of its degree \\spad{listOfDegrees} and that \\spad{p} has at least \\spad{r} factors.") (((|Factored| |#1|) |#1| (|List| (|NonNegativeInteger|))) "\\spad{factor(p,listOfDegrees)} factorizes the polynomial \\spad{p} using the single factor bound algorithm and knowing that \\spad{p} has for possible splitting of its degree listOfDegrees.") (((|Factored| |#1|) |#1| (|NonNegativeInteger|)) "\\spad{factor(p,r)} factorizes the polynomial \\spad{p} using the single factor bound algorithm and knowing that \\spad{p} has at least \\spad{r} factors.") (((|Factored| |#1|) |#1|) "\\spad{factor(p)} returns the factorization of \\spad{p} over the integers.")) (|tryFunctionalDecomposition| (((|Boolean|) (|Boolean|)) "\\spad{tryFunctionalDecomposition(b)} chooses whether factorizers have to look for functional decomposition of polynomials (\\spad{true}) or not (\\spad{false}). Returns the previous value.")) (|tryFunctionalDecomposition?| (((|Boolean|)) "\\spad{tryFunctionalDecomposition?()} returns \\spad{true} if factorizers try functional decomposition of polynomials before factoring them.")) (|eisensteinIrreducible?| (((|Boolean|) |#1|) "\\spad{eisensteinIrreducible?(p)} returns \\spad{true} if \\spad{p} can be shown to be irreducible by Eisenstein's criterion, \\spad{false} is inconclusive.")) (|useEisensteinCriterion| (((|Boolean|) (|Boolean|)) "\\spad{useEisensteinCriterion(b)} chooses whether factorizers check Eisenstein's criterion before factoring: \\spad{true} for using it, \\spad{false} else. Returns the previous value.")) (|useEisensteinCriterion?| (((|Boolean|)) "\\spad{useEisensteinCriterion?()} returns \\spad{true} if factorizers check Eisenstein's criterion before factoring.")) (|useSingleFactorBound| (((|Boolean|) (|Boolean|)) "\\spad{useSingleFactorBound(b)} chooses the algorithm to be used by the factorizers: \\spad{true} for algorithm with single factor bound, \\spad{false} for algorithm with overall bound. Returns the previous value.")) (|useSingleFactorBound?| (((|Boolean|)) "\\spad{useSingleFactorBound?()} returns \\spad{true} if algorithm with single factor bound is used for factorization, \\spad{false} for algorithm with overall bound.")) (|modularFactor| (((|Record| (|:| |prime| (|Integer|)) (|:| |factors| (|List| |#1|))) |#1|) "\\spad{modularFactor(f)} chooses a \"good\" prime and returns the factorization of \\spad{f} modulo this prime in a form that may be used by completeHensel. If prime is zero it means that \\spad{f} has been proved to be irreducible over the integers or that \\spad{f} is a unit (\\spadignore{i.e.} 1 or -1). \\spad{f} shall be primitive (\\spadignore{i.e.} content(p)=1) and square free (\\spadignore{i.e.} without repeated factors).")) (|numberOfFactors| (((|NonNegativeInteger|) (|List| (|Record| (|:| |factor| |#1|) (|:| |degree| (|Integer|))))) "\\spad{numberOfFactors(ddfactorization)} returns the number of factors of the polynomial \\spad{f} modulo \\spad{p} where \\spad{ddfactorization} is the distinct degree factorization of \\spad{f} computed by ddFact for some prime \\spad{p.}")) (|stopMusserTrials| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{stopMusserTrials(n)} sets to \\spad{n} the bound on the number of factors for which \\spadfun{modularFactor} stops to look for an other prime. You will have to remember that the step of recombining the extraneous factors may take up to \\spad{2**n} trials. Returns the previous value.") (((|PositiveInteger|)) "\\spad{stopMusserTrials()} returns the bound on the number of factors for which \\spadfun{modularFactor} stops to look for an other prime. You will have to remember that the step of recombining the extraneous factors may take up to \\spad{2**stopMusserTrials()} trials.")) (|musserTrials| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{musserTrials(n)} sets to \\spad{n} the number of primes to be tried in \\spadfun{modularFactor} and returns the previous value.") (((|PositiveInteger|)) "\\spad{musserTrials()} returns the number of primes that are tried in \\spadfun{modularFactor}.")) (|degreePartition| (((|Multiset| (|NonNegativeInteger|)) (|List| (|Record| (|:| |factor| |#1|) (|:| |degree| (|Integer|))))) "\\spad{degreePartition(ddfactorization)} returns the degree partition of the polynomial \\spad{f} modulo \\spad{p} where \\spad{ddfactorization} is the distinct degree factorization of \\spad{f} computed by ddFact for some prime \\spad{p.}")) (|makeFR| (((|Factored| |#1|) (|Record| (|:| |contp| (|Integer|)) (|:| |factors| (|List| (|Record| (|:| |irr| |#1|) (|:| |pow| (|Integer|))))))) "\\spad{makeFR(flist)} turns the final factorization of henselFact into a \\spadtype{Factored} object."))) 
NIL 
NIL 
(|GaloisGroupFactorizationUtilities| R UP F) 
((|constructor| (NIL "\\spadtype{GaloisGroupFactorizationUtilities} provides functions that will be used by the factorizer.")) (|length| ((|#3| |#2|) "\\spad{length(p)} returns the sum of the absolute values of the coefficients of the polynomial \\spad{p.}")) (|height| ((|#3| |#2|) "\\spad{height(p)} returns the maximal absolute value of the coefficients of the polynomial \\spad{p.}")) (|infinityNorm| ((|#3| |#2|) "\\spad{infinityNorm(f)} returns the maximal absolute value of the coefficients of the polynomial \\spad{f.}")) (|quadraticNorm| ((|#3| |#2|) "\\spad{quadraticNorm(f)} returns the \\spad{l2} norm of the polynomial \\spad{f.}")) (|norm| ((|#3| |#2| (|PositiveInteger|)) "\\spad{norm(f,p)} returns the \\spad{lp} norm of the polynomial \\spad{f.}")) (|singleFactorBound| (((|Integer|) |#2|) "\\spad{singleFactorBound(p,r)} returns a bound on the infinite norm of the factor of \\spad{p} with smallest Bombieri's norm. \\spad{p} shall be of degree higher or equal to 2.") (((|Integer|) |#2| (|NonNegativeInteger|)) "\\spad{singleFactorBound(p,r)} returns a bound on the infinite norm of the factor of \\spad{p} with smallest Bombieri's norm. \\spad{r} is a lower bound for the number of factors of \\spad{p.} \\spad{p} shall be of degree higher or equal to 2.")) (|rootBound| (((|Integer|) |#2|) "\\spad{rootBound(p)} returns a bound on the largest norm of the complex roots of \\spad{p.}")) (|bombieriNorm| ((|#3| |#2| (|PositiveInteger|)) "\\spad{bombieriNorm(p,n)} returns the \\spad{n}th Bombieri's norm of \\spad{p.}") ((|#3| |#2|) "\\spad{bombieriNorm(p)} returns quadratic Bombieri's norm of \\spad{p.}")) (|beauzamyBound| (((|Integer|) |#2|) "\\spad{beauzamyBound(p)} returns a bound on the larger coefficient of any factor of \\spad{p.}"))) 
NIL 
NIL 
(|GaloisGroupPolynomialUtilities| R UP) 
((|constructor| (NIL "\\spadtype{GaloisGroupPolynomialUtilities} provides useful functions for univariate polynomials which should be added to \\spadtype{UnivariatePolynomialCategory} or to \\spadtype{Factored}")) (|factorsOfDegree| (((|List| |#2|) (|PositiveInteger|) (|Factored| |#2|)) "\\spad{factorsOfDegree(d,f)} returns the factors of degree \\spad{d} of the factored polynomial \\spad{f.}")) (|factorOfDegree| ((|#2| (|PositiveInteger|) (|Factored| |#2|)) "\\spad{factorOfDegree(d,f)} returns a factor of degree \\spad{d} of the factored polynomial \\spad{f.} Such a factor shall exist.")) (|degreePartition| (((|Multiset| (|NonNegativeInteger|)) (|Factored| |#2|)) "\\spad{degreePartition(f)} returns the degree partition (\\spadignore{i.e.} the multiset of the degrees of the irreducible factors) of the polynomial \\spad{f.}")) (|shiftRoots| ((|#2| |#2| |#1|) "\\spad{shiftRoots(p,c)} returns the polynomial which has for roots \\spad{c} added to the roots of \\spad{p.}")) (|scaleRoots| ((|#2| |#2| |#1|) "\\spad{scaleRoots(p,c)} returns the polynomial which has \\spad{c} times the roots of \\spad{p.}")) (|reverse| ((|#2| |#2|) "\\spad{reverse(p)} returns the reverse polynomial of \\spad{p.}")) (|unvectorise| ((|#2| (|Vector| |#1|)) "\\spad{unvectorise(v)} returns the polynomial which has for coefficients the entries of \\spad{v} in the increasing order.")) (|monic?| (((|Boolean|) |#2|) "\\spad{monic?(p)} tests if \\spad{p} is monic (\\spadignore{i.e.} leading coefficient equal to 1)."))) 
NIL 
NIL 
(|GaloisGroupUtilities| R) 
((|constructor| (NIL "\\spadtype{GaloisGroupUtilities} provides several useful functions.")) (|safetyMargin| (((|NonNegativeInteger|)) "\\spad{safetyMargin()} returns the number of low weight digits we do not trust in the floating point representation (used by \\spadfun{safeCeiling}).") (((|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{safetyMargin(n)} sets to \\spad{n} the number of low weight digits we do not trust in the floating point representation and returns the previous value (for use by \\spadfun{safeCeiling}).")) (|safeFloor| (((|Integer|) |#1|) "\\spad{safeFloor(x)} returns the integer which is lower or equal to the largest integer which has the same floating point number representation.")) (|safeCeiling| (((|Integer|) |#1|) "\\spad{safeCeiling(x)} returns the integer which is greater than any integer with the same floating point number representation.")) (|fillPascalTriangle| (((|Void|)) "\\spad{fillPascalTriangle()} fills the stored table.")) (|sizePascalTriangle| (((|NonNegativeInteger|)) "\\spad{sizePascalTriangle()} returns the number of entries currently stored in the table.")) (|rangePascalTriangle| (((|NonNegativeInteger|)) "\\spad{rangePascalTriangle()} returns the maximal number of lines stored.") (((|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{rangePascalTriangle(n)} sets the maximal number of lines which are stored and returns the previous value.")) (|pascalTriangle| ((|#1| (|NonNegativeInteger|) (|Integer|)) "\\spad{pascalTriangle(n,r)} returns the binomial coefficient \\spad{C(n,r)=n!/(r! (n-r)!)} and stores it in a table to prevent recomputation."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|FloatingPointSystem|)))) 
(|GaussianFactorizationPackage|) 
((|constructor| (NIL "Package for the factorization of complex or gaussian integers.")) (|prime?| (((|Boolean|) (|Complex| (|Integer|))) "\\spad{prime?(zi)} tests if the complex integer \\spad{zi} is prime.")) (|sumSquares| (((|List| (|Integer|)) (|Integer|)) "\\spad{sumSquares(p)} construct \\spad{a} and \\spad{b} such that \\spad{a**2+b**2} is equal to the integer prime \\spad{p,} and otherwise returns an error. It will succeed if the prime number \\spad{p} is 2 or congruent to 1 mod 4.")) (|factor| (((|Factored| (|Complex| (|Integer|))) (|Complex| (|Integer|))) "\\spad{factor(zi)} produces the complete factorization of the complex integer zi."))) 
NIL 
NIL 
(|EuclideanGroebnerBasisPackage| |Dom| |Expon| |VarSet| |Dpol|) 
((|constructor| (NIL "\\spadtype{EuclideanGroebnerBasisPackage} computes groebner bases for polynomial ideals over euclidean domains. The basic computation provides a distinguished set of generators for these ideals. This basis allows an easy test for membership: the operation \\spadfun{euclideanNormalForm} returns zero on ideal members. The string \"info\" and \"redcrit\" can be given as additional args to provide incremental information during the computation. If \"info\" is given, a computational summary is given for each s-polynomial. If \"redcrit\" is given, the reduced critical pairs are printed. The term ordering is determined by the polynomial type used. Suggested types include \\spadtype{DistributedMultivariatePolynomial}, \\spadtype{HomogeneousDistributedMultivariatePolynomial}, \\spadtype{GeneralDistributedMultivariatePolynomial}.")) (|euclideanGroebner| (((|List| |#4|) (|List| |#4|) (|String|) (|String|)) "\\indented{1}{euclideanGroebner(lp, \"info\", \"redcrit\") computes a groebner basis} \\indented{1}{for a polynomial ideal generated by the list of polynomials lp.} \\indented{1}{If the second argument is \"info\",} \\indented{1}{a summary is given of the critical pairs.} \\indented{1}{If the third argument is \"redcrit\", critical pairs are printed.} \\blankline \\spad{X} a1:DMP([y,x],INT):= \\spad{(9*x**2} + 5*x - 3)+ \\spad{y*(3*x**2} + 2*x + 1) \\spad{X} a2:DMP([y,x],INT):= \\spad{(6*x**3} - 2*x**2 - 3*x \\spad{+3)} + \\spad{y*(2*x**3} - \\spad{x} - 1) \\spad{X} a3:DMP([y,x],INT):= \\spad{(3*x**3} + 2*x**2) + \\spad{y*(x**3} + x**2) \\spad{X} an:=[a1,a2,a3] \\spad{X} euclideanGroebner(an,\"info\",\"redcrit\")") (((|List| |#4|) (|List| |#4|) (|String|)) "\\indented{1}{euclideanGroebner(lp, infoflag) computes a groebner basis} \\indented{1}{for a polynomial ideal over a euclidean domain} \\indented{1}{generated by the list of polynomials lp.} \\indented{1}{During computation, additional information is printed out} \\indented{1}{if infoflag is given as} \\indented{1}{either \"info\" (for summary information) or} \\indented{1}{\"redcrit\" (for reduced critical pairs)} \\blankline \\spad{X} a1:DMP([y,x],INT):= \\spad{(9*x**2} + 5*x - 3)+ \\spad{y*(3*x**2} + 2*x + 1) \\spad{X} a2:DMP([y,x],INT):= \\spad{(6*x**3} - 2*x**2 - 3*x \\spad{+3)} + \\spad{y*(2*x**3} - \\spad{x} - 1) \\spad{X} a3:DMP([y,x],INT):= \\spad{(3*x**3} + 2*x**2) + \\spad{y*(x**3} + x**2) \\spad{X} an:=[a1,a2,a3] \\spad{X} euclideanGroebner(an,\"redcrit\") \\spad{X} euclideanGroebner(an,\"info\")") (((|List| |#4|) (|List| |#4|)) "\\indented{1}{euclideanGroebner(lp) computes a groebner basis for a polynomial} \\indented{1}{ideal over a euclidean domain generated by the list of polys lp.} \\blankline \\spad{X} a1:DMP([y,x],INT):= \\spad{(9*x**2} + 5*x - 3)+ \\spad{y*(3*x**2} + 2*x + 1) \\spad{X} a2:DMP([y,x],INT):= \\spad{(6*x**3} - 2*x**2 - 3*x \\spad{+3)} + \\spad{y*(2*x**3} - \\spad{x} - 1) \\spad{X} a3:DMP([y,x],INT):= \\spad{(3*x**3} + 2*x**2) + \\spad{y*(x**3} + x**2) \\spad{X} an:=[a1,a2,a3] \\spad{X} euclideanGroebner(an)")) (|euclideanNormalForm| ((|#4| |#4| (|List| |#4|)) "\\spad{euclideanNormalForm(poly,gb)} reduces the polynomial \\spad{poly} modulo the precomputed groebner basis \\spad{gb} giving a canonical representative of the residue class."))) 
NIL 
NIL 
(|GroebnerFactorizationPackage| |Dom| |Expon| |VarSet| |Dpol|) 
((|constructor| (NIL "\\spadtype{GroebnerFactorizationPackage} provides the function groebnerFactor\" which uses the factorization routines of Axiom to factor each polynomial under consideration while doing the groebner basis algorithm. Then it writes the ideal as an intersection of ideals determined by the irreducible factors. Note that the whole ring may occur as well as other redundancies. We also use the fact, that from the second factor on we can assume that the preceding factors are not equal to 0 and we divide all polynomials under considerations by the elements of this list of \"nonZeroRestrictions\". The result is a list of groebner bases, whose union of solutions of the corresponding systems of equations is the solution of the system of equation corresponding to the input list. The term ordering is determined by the polynomial type used. Suggested types include \\spadtype{DistributedMultivariatePolynomial}, \\spadtype{HomogeneousDistributedMultivariatePolynomial}, \\spadtype{GeneralDistributedMultivariatePolynomial}.")) (|groebnerFactorize| (((|List| (|List| |#4|)) (|List| |#4|) (|Boolean|)) "\\spad{groebnerFactorize(listOfPolys, info)} returns a list of groebner bases. The union of their solutions is the solution of the system of equations given by listOfPolys. At each stage the polynomial \\spad{p} under consideration (either from the given basis or obtained from a reduction of the next S-polynomial) is factorized. For each irreducible factors of \\spad{p,} a new createGroebnerBasis is started doing the usual updates with the factor in place of \\spad{p.} If info is true, information is printed about partial results.") (((|List| (|List| |#4|)) (|List| |#4|)) "\\indented{1}{groebnerFactorize(listOfPolys) returns} \\indented{1}{a list of groebner bases. The union of their solutions} \\indented{1}{is the solution of the system of equations given by listOfPolys.} \\indented{1}{At each stage the polynomial \\spad{p} under consideration (either from} \\indented{1}{the given basis or obtained from a reduction of the next S-polynomial)} \\indented{1}{is factorized. For each irreducible factors of \\spad{p,} a} \\indented{1}{new createGroebnerBasis is started} \\indented{1}{doing the usual updates with the factor} \\indented{1}{in place of \\spad{p.}} \\blankline \\spad{X} mfzn : SQMATRIX(6,DMP([x,y,z],Fraction INT)) \\spad{:=} \\spad{++X} [ [0,1,1,1,1,1], [1,0,1,8/3,x,8/3], [1,1,0,1,8/3,y], \\spad{++X} [1,8/3,1,0,1,8/3], [1,x,8/3,1,0,1], [1,8/3,y,8/3,1,0] ] \\spad{X} eq \\spad{:=} determinant mfzn \\spad{X} groebnerFactorize \\spad{++X} [eq,eval(eq, [x,y,z],[y,z,x]), eval(eq,[x,y,z],[z,x,y])]") (((|List| (|List| |#4|)) (|List| |#4|) (|List| |#4|) (|Boolean|)) "\\spad{groebnerFactorize(listOfPolys, nonZeroRestrictions, info)} returns a list of groebner basis. The union of their solutions is the solution of the system of equations given by \\spad{listOfPolys} under the restriction that the polynomials of \\spad{nonZeroRestrictions} don't vanish. At each stage the polynomial \\spad{p} under consideration (either from the given basis or obtained from a reduction of the next S-polynomial) is factorized. For each irreducible factors of \\spad{p} a new createGroebnerBasis is started doing the usual updates with the factor in place of \\spad{p.} If argument info is true, information is printed about partial results.") (((|List| (|List| |#4|)) (|List| |#4|) (|List| |#4|)) "\\spad{groebnerFactorize(listOfPolys, nonZeroRestrictions)} returns a list of groebner basis. The union of their solutions is the solution of the system of equations given by \\spad{listOfPolys} under the restriction that the polynomials of nonZeroRestrictions don't vanish. At each stage the polynomial \\spad{p} under consideration (either from the given basis or obtained from a reduction of the next S-polynomial) is factorized. For each irreducible factors of \\spad{p,} a new createGroebnerBasis is started doing the usual updates with the factor in place of \\spad{p.}")) (|factorGroebnerBasis| (((|List| (|List| |#4|)) (|List| |#4|) (|Boolean|)) "\\spad{factorGroebnerBasis(basis,info)} checks whether the \\spad{basis} contains reducible polynomials and uses these to split the basis. If argument \\spad{info} is true, information is printed about partial results.") (((|List| (|List| |#4|)) (|List| |#4|)) "\\spad{factorGroebnerBasis(basis)} checks whether the \\spad{basis} contains reducible polynomials and uses these to split the basis."))) 
NIL 
NIL 
(|GroebnerInternalPackage| |Dom| |Expon| |VarSet| |Dpol|) 
((|constructor| (NIL "This package provides low level tools for Groebner basis computations")) (|virtualDegree| (((|NonNegativeInteger|) |#4|) "\\spad{virtualDegree }\\undocumented")) (|makeCrit| (((|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|)) (|Record| (|:| |totdeg| (|NonNegativeInteger|)) (|:| |pol| |#4|)) |#4| (|NonNegativeInteger|)) "\\spad{makeCrit }\\undocumented")) (|critpOrder| (((|Boolean|) (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|)) (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|))) "\\spad{critpOrder }\\undocumented")) (|prinb| (((|Void|) (|Integer|)) "\\spad{prinb }\\undocumented")) (|prinpolINFO| (((|Void|) (|List| |#4|)) "\\spad{prinpolINFO }\\undocumented")) (|fprindINFO| (((|Integer|) (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|)) |#4| |#4| (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{fprindINFO }\\undocumented")) (|prindINFO| (((|Integer|) (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|)) |#4| |#4| (|Integer|) (|Integer|) (|Integer|)) "\\spad{prindINFO }\\undocumented")) (|prinshINFO| (((|Void|) |#4|) "\\spad{prinshINFO }\\undocumented")) (|lepol| (((|Integer|) |#4|) "\\spad{lepol }\\undocumented")) (|minGbasis| (((|List| |#4|) (|List| |#4|)) "\\spad{minGbasis }\\undocumented")) (|updatD| (((|List| (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|))) (|List| (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|))) (|List| (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|)))) "\\spad{updatD }\\undocumented")) (|sPol| ((|#4| (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|))) "\\spad{sPol }\\undocumented")) (|updatF| (((|List| (|Record| (|:| |totdeg| (|NonNegativeInteger|)) (|:| |pol| |#4|))) |#4| (|NonNegativeInteger|) (|List| (|Record| (|:| |totdeg| (|NonNegativeInteger|)) (|:| |pol| |#4|)))) "\\spad{updatF }\\undocumented")) (|hMonic| ((|#4| |#4|) "\\spad{hMonic }\\undocumented")) (|redPo| (((|Record| (|:| |poly| |#4|) (|:| |mult| |#1|)) |#4| (|List| |#4|)) "\\spad{redPo }\\undocumented")) (|critMonD1| (((|List| (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|))) |#2| (|List| (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|)))) "\\spad{critMonD1 }\\undocumented")) (|critMTonD1| (((|List| (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|))) (|List| (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|)))) "\\spad{critMTonD1 }\\undocumented")) (|critBonD| (((|List| (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|))) |#4| (|List| (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|)))) "\\spad{critBonD }\\undocumented")) (|critB| (((|Boolean|) |#2| |#2| |#2| |#2|) "\\spad{critB }\\undocumented")) (|critM| (((|Boolean|) |#2| |#2|) "\\spad{critM }\\undocumented")) (|critT| (((|Boolean|) (|Record| (|:| |lcmfij| |#2|) (|:| |totdeg| (|NonNegativeInteger|)) (|:| |poli| |#4|) (|:| |polj| |#4|))) "\\spad{critT }\\undocumented")) (|gbasis| (((|List| |#4|) (|List| |#4|) (|Integer|) (|Integer|)) "\\spad{gbasis }\\undocumented")) (|redPol| ((|#4| |#4| (|List| |#4|)) "\\spad{redPol }\\undocumented")) (|credPol| ((|#4| |#4| (|List| |#4|)) "\\spad{credPol }\\undocumented"))) 
NIL 
NIL 
(|GroebnerPackage| |Dom| |Expon| |VarSet| |Dpol|) 
((|constructor| (NIL "\\spadtype{GroebnerPackage} computes groebner bases for polynomial ideals. The basic computation provides a distinguished set of generators for polynomial ideals over fields. This basis allows an easy test for membership: the operation \\spadfun{normalForm} returns zero on ideal members. When the provided coefficient domain, Dom, is not a field, the result is equivalent to considering the extended ideal with \\spadtype{Fraction(Dom)} as coefficients, but considerably more efficient since all calculations are performed in Dom. Additional argument \"info\" and \"redcrit\" can be given to provide incremental information during computation. Argument \"info\" produces a computational summary for each s-polynomial. Argument \"redcrit\" prints out the reduced critical pairs. The term ordering is determined by the polynomial type used. Suggested types include \\spadtype{DistributedMultivariatePolynomial}, \\spadtype{HomogeneousDistributedMultivariatePolynomial}, \\spadtype{GeneralDistributedMultivariatePolynomial}.")) (|normalForm| ((|#4| |#4| (|List| |#4|)) "\\spad{normalForm(poly,gb)} reduces the polynomial \\spad{poly} modulo the precomputed groebner basis \\spad{gb} giving a canonical representative of the residue class.")) (|groebner| (((|List| |#4|) (|List| |#4|) (|String|) (|String|)) "\\indented{1}{groebner(lp, \"info\", \"redcrit\") computes a groebner basis} \\indented{1}{for a polynomial ideal generated by the list of polynomials lp,} \\indented{1}{displaying both a summary of the critical pairs considered (\"info\")} \\indented{1}{and the result of reducing each critical pair (\"redcrit\").} \\indented{1}{If the second or third arguments have any other string value,} \\indented{1}{the indicated information is suppressed.} \\blankline \\spad{X} s1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 \\spad{X} s2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s \\spad{X} s3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 \\spad{X} s4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s \\spad{X} s5:DMP([w,p,z,t,s,b],FRAC(INT)):= \\spad{w*p} + 2*z*t - 11*b**3 \\spad{X} s6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 \\spad{X} s7:DMP([w,p,z,t,s,b],FRAC(INT)):= \\spad{b**2} + 33/50*b + 2673/10000 \\spad{X} sn7:=[s1,s2,s3,s4,s5,s6,s7] \\spad{X} groebner(sn7,\"info\",\"redcrit\")") (((|List| |#4|) (|List| |#4|) (|String|)) "\\indented{1}{groebner(lp, infoflag) computes a groebner basis} \\indented{1}{for a polynomial ideal} \\indented{1}{generated by the list of polynomials lp.} \\indented{1}{Argument infoflag is used to get information on the computation.} \\indented{1}{If infoflag is \"info\", then summary information} \\indented{1}{is displayed for each s-polynomial generated.} \\indented{1}{If infoflag is \"redcrit\", the reduced critical pairs are displayed.} \\indented{1}{If infoflag is any other string,} \\indented{1}{no information is printed during computation.} \\blankline \\spad{X} s1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 \\spad{X} s2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s \\spad{X} s3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 \\spad{X} s4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s \\spad{X} s5:DMP([w,p,z,t,s,b],FRAC(INT)):= \\spad{w*p} + 2*z*t - 11*b**3 \\spad{X} s6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 \\spad{X} s7:DMP([w,p,z,t,s,b],FRAC(INT)):= \\spad{b**2} + 33/50*b + 2673/10000 \\spad{X} sn7:=[s1,s2,s3,s4,s5,s6,s7] \\spad{X} groebner(sn7,\"info\") \\spad{X} groebner(sn7,\"redcrit\")") (((|List| |#4|) (|List| |#4|)) "\\indented{1}{groebner(lp) computes a groebner basis for a polynomial ideal} \\indented{1}{generated by the list of polynomials lp.} \\blankline \\spad{X} s1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 \\spad{X} s2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s \\spad{X} s3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 \\spad{X} s4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s \\spad{X} s5:DMP([w,p,z,t,s,b],FRAC(INT)):= \\spad{w*p} + 2*z*t - 11*b**3 \\spad{X} s6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 \\spad{X} s7:DMP([w,p,z,t,s,b],FRAC(INT)):= \\spad{b**2} + 33/50*b + 2673/10000 \\spad{X} sn7:=[s1,s2,s3,s4,s5,s6,s7] \\spad{X} groebner(sn7)"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|Field|)))) 
(|GcdDomain&| S) 
((|constructor| (NIL "This category describes domains where \\spadfun{gcd} can be computed but where there is no guarantee of the existence of \\spadfun{factor} operation for factorisation into irreducibles. However, if such a \\spadfun{factor} operation exist, factorization will be unique up to order and units.")) (|gcdPolynomial| (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)) "\\spad{gcdPolynomial(p,q)} returns the greatest common divisor (gcd) of univariate polynomials over the domain")) (|lcm| (($ (|List| $)) "\\spad{lcm(l)} returns the least common multiple of the elements of the list \\spad{l.}") (($ $ $) "\\spad{lcm(x,y)} returns the least common multiple of \\spad{x} and \\spad{y.}")) (|gcd| (($ (|List| $)) "\\spad{gcd(l)} returns the common \\spad{gcd} of the elements in the list \\spad{l.}") (($ $ $) "\\spad{gcd(x,y)} returns the greatest common divisor of \\spad{x} and \\spad{y.}"))) 
NIL 
NIL 
(|GcdDomain|) 
((|constructor| (NIL "This category describes domains where \\spadfun{gcd} can be computed but where there is no guarantee of the existence of \\spadfun{factor} operation for factorisation into irreducibles. However, if such a \\spadfun{factor} operation exist, factorization will be unique up to order and units.")) (|gcdPolynomial| (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)) "\\spad{gcdPolynomial(p,q)} returns the greatest common divisor (gcd) of univariate polynomials over the domain")) (|lcm| (($ (|List| $)) "\\spad{lcm(l)} returns the least common multiple of the elements of the list \\spad{l.}") (($ $ $) "\\spad{lcm(x,y)} returns the least common multiple of \\spad{x} and \\spad{y.}")) (|gcd| (($ (|List| $)) "\\spad{gcd(l)} returns the common \\spad{gcd} of the elements in the list \\spad{l.}") (($ $ $) "\\spad{gcd(x,y)} returns the greatest common divisor of \\spad{x} and \\spad{y.}"))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|GenericNonAssociativeAlgebra| R |n| |ls| |gamma|) 
((|constructor| (NIL "AlgebraGenericElementPackage allows you to create generic elements of an algebra, \\spadignore{i.e.} the scalars are extended to include symbolic coefficients")) (|conditionsForIdempotents| (((|List| (|Polynomial| |#1|))) "\\spad{conditionsForIdempotents()} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the fixed \\spad{R}-module basis") (((|List| (|Polynomial| |#1|)) (|Vector| $)) "\\spad{conditionsForIdempotents([v1,...,vn])} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the \\spad{R}-module basis \\spad{v1},...,\\spad{vn}")) (|genericRightDiscriminant| (((|Fraction| (|Polynomial| |#1|))) "\\spad{genericRightDiscriminant()} is the determinant of the generic left trace forms of all products of basis element, if the generic left trace form is associative, an algebra is separable if the generic left discriminant is invertible, if it is non-zero, there is some ring extension which makes the algebra separable")) (|genericRightTraceForm| (((|Fraction| (|Polynomial| |#1|)) $ $) "\\spad{genericRightTraceForm (a,b)} is defined to be \\spadfun{genericRightTrace (a*b)}, this defines a symmetric bilinear form on the algebra")) (|genericLeftDiscriminant| (((|Fraction| (|Polynomial| |#1|))) "\\spad{genericLeftDiscriminant()} is the determinant of the generic left trace forms of all products of basis element, if the generic left trace form is associative, an algebra is separable if the generic left discriminant is invertible, if it is non-zero, there is some ring extension which makes the algebra separable")) (|genericLeftTraceForm| (((|Fraction| (|Polynomial| |#1|)) $ $) "\\spad{genericLeftTraceForm (a,b)} is defined to be \\spad{genericLeftTrace (a*b)}, this defines a symmetric bilinear form on the algebra")) (|genericRightNorm| (((|Fraction| (|Polynomial| |#1|)) $) "\\spad{genericRightNorm(a)} substitutes the coefficients of \\spad{a} for the generic coefficients into the coefficient of the constant term in \\spadfun{rightRankPolynomial} and changes the sign if the degree of this polynomial is odd")) (|genericRightTrace| (((|Fraction| (|Polynomial| |#1|)) $) "\\spad{genericRightTrace(a)} substitutes the coefficients of \\spad{a} for the generic coefficients into the coefficient of the second highest term in \\spadfun{rightRankPolynomial} and changes the sign")) (|genericRightMinimalPolynomial| (((|SparseUnivariatePolynomial| (|Fraction| (|Polynomial| |#1|))) $) "\\spad{genericRightMinimalPolynomial(a)} substitutes the coefficients of \\spad{a} for the generic coefficients in \\spadfun{rightRankPolynomial}")) (|rightRankPolynomial| (((|SparseUnivariatePolynomial| (|Fraction| (|Polynomial| |#1|)))) "\\spad{rightRankPolynomial()} returns the right minimimal polynomial of the generic element")) (|genericLeftNorm| (((|Fraction| (|Polynomial| |#1|)) $) "\\spad{genericLeftNorm(a)} substitutes the coefficients of \\spad{a} for the generic coefficients into the coefficient of the constant term in \\spadfun{leftRankPolynomial} and changes the sign if the degree of this polynomial is odd. This is a form of degree \\spad{k}")) (|genericLeftTrace| (((|Fraction| (|Polynomial| |#1|)) $) "\\spad{genericLeftTrace(a)} substitutes the coefficients of \\spad{a} for the generic coefficients into the coefficient of the second highest term in \\spadfun{leftRankPolynomial} and changes the sign. \\indented{1}{This is a linear form}")) (|genericLeftMinimalPolynomial| (((|SparseUnivariatePolynomial| (|Fraction| (|Polynomial| |#1|))) $) "\\spad{genericLeftMinimalPolynomial(a)} substitutes the coefficients of {em a} for the generic coefficients in \\spad{leftRankPolynomial()}")) (|leftRankPolynomial| (((|SparseUnivariatePolynomial| (|Fraction| (|Polynomial| |#1|)))) "\\spad{leftRankPolynomial()} returns the left minimimal polynomial of the generic element")) (|generic| (($ (|Vector| (|Symbol|)) (|Vector| $)) "\\spad{generic(vs,ve)} returns a generic element, \\spadignore{i.e.} the linear combination of \\spad{ve} with the symbolic coefficients \\spad{vs} error, if the vector of symbols is shorter than the vector of elements") (($ (|Symbol|) (|Vector| $)) "\\spad{generic(s,v)} returns a generic element, \\spadignore{i.e.} the linear combination of \\spad{v} with the symbolic coefficients \\spad{s1,s2,..}") (($ (|Vector| $)) "\\spad{generic(ve)} returns a generic element, \\spadignore{i.e.} the linear combination of \\spad{ve} basis with the symbolic coefficients \\spad{\\%x1,\\%x2,..}") (($ (|Vector| (|Symbol|))) "\\spad{generic(vs)} returns a generic element, \\spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \\spad{vs}; error, if the vector of symbols is too short") (($ (|Symbol|)) "\\spad{generic(s)} returns a generic element, \\spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \\spad{s1,s2,..}") (($) "\\spad{generic()} returns a generic element, \\spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \\spad{\\%x1,\\%x2,..}")) (|rightUnits| (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $))) "failed")) "\\spad{rightUnits()} returns the affine space of all right units of the algebra, or \\spad{\"failed\"} if there is none")) (|leftUnits| (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $))) "failed")) "\\spad{leftUnits()} returns the affine space of all left units of the algebra, or \\spad{\"failed\"} if there is none")) (|coerce| (($ (|Vector| (|Fraction| (|Polynomial| |#1|)))) "\\spad{coerce(v)} assumes that it is called with a vector of length equal to the dimension of the algebra, then a linear combination with the basis element is formed"))) 
((|unitsKnown| |has| (|Fraction| (|Polynomial| |#1|)) (|IntegralDomain|)) (|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| (|Fraction| (|Polynomial| |#1|)) (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| (|Fraction| (|Polynomial| |#1|)) (QUOTE (|IntegralDomain|)))) 
(|GeneralDistributedMultivariatePolynomial| |vl| R E) 
((|constructor| (NIL "This type supports distributed multivariate polynomials whose variables are from a user specified list of symbols. The coefficient ring may be non commutative, but the variables are assumed to commute. The term ordering is specified by its third parameter. Suggested types which define term orderings include: \\spadtype{DirectProduct}, \\spadtype{HomogeneousDirectProduct}, \\spadtype{SplitHomogeneousDirectProduct} and finally \\spadtype{OrderedDirectProduct} which accepts an arbitrary user function to define a term ordering.")) (|reorder| (($ $ (|List| (|Integer|))) "\\spad{reorder(p, perm)} applies the permutation perm to the variables in a polynomial and returns the new correctly ordered polynomial"))) 
(((|commutative| "*") |has| |#2| (|CommutativeRing|)) (|noZeroDivisors| |has| |#2| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#2| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#2| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Field|))) (OR (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasAttribute| |#2| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))))) 
(|GnuDraw|) 
((|constructor| (NIL "This package provides support for gnuplot. These routines generate output files contain gnuplot scripts that may be processed directly by gnuplot. This is especially convenient in the axiom-wiki environment where gnuplot is called from LaTeX via gnuplottex.")) (|gnuDraw| (((|Void|) (|Expression| (|Float|)) (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|)) (|String|)) "\\indented{1}{\\spad{gnuDraw} provides 3d surface plotting, default options} \\blankline \\spad{X} gnuDraw(sin(x)*cos(y),x=-6..4,y=-4..6,\"out3d.dat\") \\spad{X} )sys gnuplot -persist out3d.dat") (((|Void|) (|Expression| (|Float|)) (|SegmentBinding| (|Float|)) (|SegmentBinding| (|Float|)) (|String|) (|List| (|DrawOption|))) "\\indented{1}{\\spad{gnuDraw} provides 3d surface plotting with options} \\blankline \\spad{X} gnuDraw(sin(x)*cos(y),x=-6..4,y=-4..6,\"out3d.dat\",title==\"out3d\") \\spad{X} )sys gnuplot -persist out3d.dat") (((|Void|) (|Expression| (|Float|)) (|SegmentBinding| (|Float|)) (|String|)) "\\indented{1}{\\spad{gnuDraw} provides 2d plotting, default options} \\blankline \\spad{X} gnuDraw(D(cos(exp(z))/exp(z^2),z),z=-5..5,\"out2d.dat\") \\spad{X} )sys gnuplot -persist out2d.dat") (((|Void|) (|Expression| (|Float|)) (|SegmentBinding| (|Float|)) (|String|) (|List| (|DrawOption|))) "\\indented{1}{\\spad{gnuDraw} provides 2d plotting with options} \\blankline \\spad{X} gnuDraw(D(cos(exp(z))/exp(z^2),z),z=-5..5,\"out2d.dat\",title==\"out2d\") \\spad{X} )sys gnuplot -persist out2d.dat"))) 
NIL 
NIL 
(|GenExEuclid| R BP) 
((|constructor| (NIL "\\indented{1}{Author : P.Gianni.} Date Created: January 1990 Description:")) (|testModulus| (((|Boolean|) |#1| (|List| |#2|)) "\\spad{testModulus(p,lp)} returns \\spad{true} if the the prime \\spad{p} is valid for the list of polynomials \\spad{lp,} \\spadignore{i.e.} preserves the degree and they remain relatively prime.")) (|solveid| (((|Union| (|List| |#2|) "failed") |#2| |#1| (|Vector| (|List| |#2|))) "\\spad{solveid(h,table)} computes the coefficients of the extended euclidean algorithm for a list of polynomials whose tablePow is \\spad{table} and with right side \\spad{h.}")) (|tablePow| (((|Union| (|Vector| (|List| |#2|)) "failed") (|NonNegativeInteger|) |#1| (|List| |#2|)) "\\spad{tablePow(maxdeg,prime,lpol)} constructs the table with the coefficients of the Extended Euclidean Algorithm for lpol. Here the right side is \\spad{x**k}, for \\spad{k} less or equal to maxdeg. The operation returns \"failed\" when the elements are not coprime modulo prime.")) (|compBound| (((|NonNegativeInteger|) |#2| (|List| |#2|)) "\\spad{compBound(p,lp)} computes a bound for the coefficients of the solution polynomials. Given a polynomial right hand side \\spad{p,} and a list \\spad{lp} of left hand side polynomials. Exported because it depends on the valuation.")) (|reduction| ((|#2| |#2| |#1|) "\\spad{reduction(p,prime)} reduces the polynomial \\spad{p} modulo \\spad{prime} of \\spad{R.} Note that this function is exported only because it's conditional."))) 
NIL 
NIL 
(|GeneralizedMultivariateFactorize| OV E S R P) 
((|constructor| (NIL "This is the top level package for doing multivariate factorization over basic domains like \\spadtype{Integer} or \\spadtype{Fraction Integer}.")) (|factor| (((|Factored| |#5|) |#5|) "\\spad{factor(p)} factors the multivariate polynomial \\spad{p} over its coefficient domain")) (|variable| (((|Union| $ "failed") (|Symbol|)) "\\spad{variable(s)} makes an element from symbol \\spad{s} or fails.")) (|convert| (((|Symbol|) $) "\\spad{convert(x)} converts \\spad{x} to a symbol"))) 
NIL 
NIL 
(|GeneralPolynomialGcdPackage| E OV R P) 
((|constructor| (NIL "Description:")) (|randomR| ((|#3|) "\\spad{randomR()} should be local but conditional")) (|gcdPolynomial| (((|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#4|)) "\\spad{gcdPolynomial(p,q)} returns the \\spad{GCD} of \\spad{p} and \\spad{q}"))) 
NIL 
NIL 
(|GenUFactorize| R) 
((|constructor| (NIL "This package provides operations for the factorization of univariate polynomials with integer coefficients. The factorization is done by \"lifting\" the finite \"berlekamp's\" factorization")) (|factor| (((|Factored| (|SparseUnivariatePolynomial| |#1|)) (|SparseUnivariatePolynomial| |#1|)) "\\spad{factor(p)} returns the factorisation of \\spad{p}"))) 
NIL 
NIL 
(|GenerateUnivariatePowerSeries| R FE) 
((|constructor| (NIL "\\spadtype{GenerateUnivariatePowerSeries} provides functions that create power series from explicit formulas for their \\spad{n}th coefficient.")) (|series| (((|Any|) |#2| (|Symbol|) (|Equation| |#2|) (|UniversalSegment| (|Fraction| (|Integer|))) (|Fraction| (|Integer|))) "\\spad{series(a(n),n,x = a,r0..,r)} returns \\spad{sum(n = \\spad{r0,r0} + \\spad{r,r0} + 2*r..., \\spad{a(n)} * \\spad{(x} - a)**n)}; \\spad{series(a(n),n,x = a,r0..r1,r)} returns \\spad{sum(n = \\spad{r0} + \\spad{k*r} while \\spad{n} \\spad{<=} \\spad{r1,} \\spad{a(n)} * \\spad{(x} - a)**n)}.") (((|Any|) (|Mapping| |#2| (|Fraction| (|Integer|))) (|Equation| |#2|) (|UniversalSegment| (|Fraction| (|Integer|))) (|Fraction| (|Integer|))) "\\spad{series(n \\spad{+->} a(n),x = a,r0..,r)} returns \\spad{sum(n = \\spad{r0,r0} + \\spad{r,r0} + 2*r..., a(n) * \\spad{(x} - a)**n)}; \\spad{series(n \\spad{+->} a(n),x = a,r0..r1,r)} returns \\spad{sum(n = \\spad{r0} + \\spad{k*r} while \\spad{n} \\spad{<=} \\spad{r1,} a(n) * \\spad{(x} - a)**n)}.") (((|Any|) |#2| (|Symbol|) (|Equation| |#2|) (|UniversalSegment| (|Integer|))) "\\spad{series(a(n),n,x=a,n0..)} returns \\spad{sum(n = n0..,a(n) * \\spad{(x} - a)**n)}; \\spad{series(a(n),n,x=a,n0..n1)} returns \\spad{sum(n = n0..n1,a(n) * \\spad{(x} - a)**n)}.") (((|Any|) (|Mapping| |#2| (|Integer|)) (|Equation| |#2|) (|UniversalSegment| (|Integer|))) "\\spad{series(n \\spad{+->} a(n),x = a,n0..)} returns \\spad{sum(n = n0..,a(n) * \\spad{(x} - a)**n)}; \\spad{series(n \\spad{+->} a(n),x = a,n0..n1)} returns \\spad{sum(n = n0..n1,a(n) * \\spad{(x} - a)**n)}.") (((|Any|) |#2| (|Symbol|) (|Equation| |#2|)) "\\spad{series(a(n),n,x = a)} returns \\spad{sum(n = 0..,a(n)*(x-a)**n)}.") (((|Any|) (|Mapping| |#2| (|Integer|)) (|Equation| |#2|)) "\\spad{series(n \\spad{+->} a(n),x = a)} returns \\spad{sum(n = 0..,a(n)*(x-a)**n)}.")) (|puiseux| (((|Any|) |#2| (|Symbol|) (|Equation| |#2|) (|UniversalSegment| (|Fraction| (|Integer|))) (|Fraction| (|Integer|))) "\\spad{puiseux(a(n),n,x = a,r0..,r)} returns \\spad{sum(n = \\spad{r0,r0} + \\spad{r,r0} + 2*r..., \\spad{a(n)} * \\spad{(x} - a)**n)}; \\spad{puiseux(a(n),n,x = a,r0..r1,r)} returns \\spad{sum(n = \\spad{r0} + \\spad{k*r} while \\spad{n} \\spad{<=} \\spad{r1,} \\spad{a(n)} * \\spad{(x} - a)**n)}.") (((|Any|) (|Mapping| |#2| (|Fraction| (|Integer|))) (|Equation| |#2|) (|UniversalSegment| (|Fraction| (|Integer|))) (|Fraction| (|Integer|))) "\\spad{puiseux(n \\spad{+->} a(n),x = a,r0..,r)} returns \\spad{sum(n = \\spad{r0,r0} + \\spad{r,r0} + 2*r..., a(n) * \\spad{(x} - a)**n)}; \\spad{puiseux(n \\spad{+->} a(n),x = a,r0..r1,r)} returns \\spad{sum(n = \\spad{r0} + \\spad{k*r} while \\spad{n} \\spad{<=} \\spad{r1,} a(n) * \\spad{(x} - a)**n)}.")) (|laurent| (((|Any|) |#2| (|Symbol|) (|Equation| |#2|) (|UniversalSegment| (|Integer|))) "\\spad{laurent(a(n),n,x=a,n0..)} returns \\spad{sum(n = n0..,a(n) * \\spad{(x} - a)**n)}; \\spad{laurent(a(n),n,x=a,n0..n1)} returns \\spad{sum(n = n0..n1,a(n) * \\spad{(x} - a)**n)}.") (((|Any|) (|Mapping| |#2| (|Integer|)) (|Equation| |#2|) (|UniversalSegment| (|Integer|))) "\\spad{laurent(n \\spad{+->} a(n),x = a,n0..)} returns \\spad{sum(n = n0..,a(n) * \\spad{(x} - a)**n)}; \\spad{laurent(n \\spad{+->} a(n),x = a,n0..n1)} returns \\spad{sum(n = n0..n1,a(n) * \\spad{(x} - a)**n)}.")) (|taylor| (((|Any|) |#2| (|Symbol|) (|Equation| |#2|) (|UniversalSegment| (|NonNegativeInteger|))) "\\spad{taylor(a(n),n,x = a,n0..)} returns \\spad{sum(n = n0..,a(n)*(x-a)**n)}; \\spad{taylor(a(n),n,x = a,n0..n1)} returns \\spad{sum(n = n0..,a(n)*(x-a)**n)}.") (((|Any|) (|Mapping| |#2| (|Integer|)) (|Equation| |#2|) (|UniversalSegment| (|NonNegativeInteger|))) "\\spad{taylor(n \\spad{+->} a(n),x = a,n0..)} returns \\spad{sum(n=n0..,a(n)*(x-a)**n)}; \\spad{taylor(n \\spad{+->} a(n),x = a,n0..n1)} returns \\spad{sum(n = n0..,a(n)*(x-a)**n)}.") (((|Any|) |#2| (|Symbol|) (|Equation| |#2|)) "\\spad{taylor(a(n),n,x = a)} returns \\spad{sum(n = 0..,a(n)*(x-a)**n)}.") (((|Any|) (|Mapping| |#2| (|Integer|)) (|Equation| |#2|)) "\\spad{taylor(n \\spad{+->} a(n),x = a)} returns \\spad{sum(n = 0..,a(n)*(x-a)**n)}."))) 
NIL 
NIL 
(|GeneralHenselPackage| RP TP) 
((|constructor| (NIL "General Hensel Lifting Used for Factorization of bivariate polynomials over a finite field.")) (|reduction| ((|#2| |#2| |#1|) "\\spad{reduction(u,pol)} computes the symmetric reduction of \\spad{u} mod \\spad{pol}")) (|completeHensel| (((|List| |#2|) |#2| (|List| |#2|) |#1| (|PositiveInteger|)) "\\spad{completeHensel(pol,lfact,prime,bound)} lifts lfact, the factorization mod \\spad{prime} of pol, to the factorization mod prime**k>bound. Factors are recombined on the way.")) (|HenselLift| (((|Record| (|:| |plist| (|List| |#2|)) (|:| |modulo| |#1|)) |#2| (|List| |#2|) |#1| (|PositiveInteger|)) "\\spad{HenselLift(pol,lfacts,prime,bound)} lifts lfacts, that are the factors of \\spad{pol} mod prime, to factors of \\spad{pol} mod prime**k > bound. No recombining is done ."))) 
NIL 
NIL 
(|GeneralModulePolynomial| |vl| R IS E |ff| P) 
((|constructor| (NIL "This package is undocumented")) (* (($ |#6| $) "\\spad{p*x} is not documented")) (|multMonom| (($ |#2| |#4| $) "\\spad{multMonom(r,e,x)} is not documented")) (|build| (($ |#2| |#3| |#4|) "\\spad{build(r,i,e)} is not documented")) (|unitVector| (($ |#3|) "\\spad{unitVector(x)} is not documented")) (|monomial| (($ |#2| (|ModuleMonomial| |#3| |#4| |#5|)) "\\spad{monomial(r,x)} is not documented")) (|reductum| (($ $) "\\spad{reductum(x)} is not documented")) (|leadingIndex| ((|#3| $) "\\spad{leadingIndex(x)} is not documented")) (|leadingExponent| ((|#4| $) "\\spad{leadingExponent(x)} is not documented")) (|leadingMonomial| (((|ModuleMonomial| |#3| |#4| |#5|) $) "\\spad{leadingMonomial(x)} is not documented")) (|leadingCoefficient| ((|#2| $) "\\spad{leadingCoefficient(x)} is not documented"))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|GuessOptionFunctions0|) 
((|constructor| (NIL "\\spad{GuessOptionFunctions0} provides operations that extract the values of options for Guess.")) (|checkOptions| (((|Void|) (|List| (|GuessOption|))) "\\spad{checkOptions checks} whether the given options are consistent, and yields an error otherwise")) (|debug| (((|Boolean|) (|List| (|GuessOption|))) "\\spad{debug returns} whether we want additional output on the progress, default being \\spad{false}")) (|displayAsGF| (((|Boolean|) (|List| (|GuessOption|))) "\\spad{displayAsGF specifies} whether the result is a generating function or a recurrence. This option should not be set by the user, but rather by the HP-specification, therefore, there is no default.")) (|indexName| (((|Symbol|) (|List| (|GuessOption|))) "\\spad{indexName returns} the name of the index variable used for the formulas, default being \\spad{n}")) (|variableName| (((|Symbol|) (|List| (|GuessOption|))) "\\spad{variableName returns} the name of the variable used in by the algebraic differential equation, default being \\spad{x}")) (|functionName| (((|Symbol|) (|List| (|GuessOption|))) "\\spad{functionName returns} the name of the function given by the algebraic differential equation, default being \\spad{f}")) (|one| (((|Boolean|) (|List| (|GuessOption|))) "\\spad{one returns} whether we need only one solution, default being true.")) (|checkExtraValues| (((|Boolean|) (|List| (|GuessOption|))) "\\spad{checkExtraValues(d)} specifies whether we want to check the solution beyond the order given by the degree bounds. The default is true.")) (|check| (((|Union| "skip" "MonteCarlo" "deterministic") (|List| (|GuessOption|))) "\\spad{check(d)} specifies how we want to check the solution. If the value is \"skip\", we return the solutions found by the interpolation routine without checking. If the value is \"MonteCarlo\", we use a probabilistic check. The default is \"deterministic\".")) (|safety| (((|NonNegativeInteger|) (|List| (|GuessOption|))) "\\spad{safety returns} the specified safety or 1 as default.")) (|allDegrees| (((|Boolean|) (|List| (|GuessOption|))) "\\spad{allDegrees returns} whether all possibilities of the degree vector should be tried, the default being false.")) (|maxMixedDegree| (((|NonNegativeInteger|) (|List| (|GuessOption|))) "\\spad{maxMixedDegree returns} the specified maxMixedDegree.")) (|maxDegree| (((|Union| (|NonNegativeInteger|) "arbitrary") (|List| (|GuessOption|))) "\\spad{maxDegree returns} the specified maxDegree.")) (|maxLevel| (((|Union| (|NonNegativeInteger|) "arbitrary") (|List| (|GuessOption|))) "\\spad{maxLevel returns} the specified maxLevel.")) (|Somos| (((|Union| (|PositiveInteger|) (|Boolean|)) (|List| (|GuessOption|))) "\\spad{Somos returns} whether we allow only Somos-like operators, default being \\spad{false}")) (|homogeneous| (((|Union| (|PositiveInteger|) (|Boolean|)) (|List| (|GuessOption|))) "\\spad{homogeneous returns} whether we allow only homogeneous algebraic differential equations, default being \\spad{false}")) (|maxPower| (((|Union| (|PositiveInteger|) "arbitrary") (|List| (|GuessOption|))) "\\spad{maxPower returns} the specified maxPower.")) (|maxSubst| (((|Union| (|PositiveInteger|) "arbitrary") (|List| (|GuessOption|))) "\\spad{maxSubst returns} the specified maxSubst.")) (|maxShift| (((|Union| (|NonNegativeInteger|) "arbitrary") (|List| (|GuessOption|))) "\\spad{maxShift returns} the specified maxShift.")) (|maxDerivative| (((|Union| (|NonNegativeInteger|) "arbitrary") (|List| (|GuessOption|))) "\\spad{maxDerivative returns} the specified maxDerivative."))) 
NIL 
NIL 
(|GuessOption|) 
((|constructor| (NIL "GuessOption is a domain whose elements are various options used by Guess.")) (|option| (((|Union| (|Any|) "failed") (|List| $) (|Symbol|)) "\\spad{option(l, option)} returns which options are given.")) (|displayKind| (($ (|Symbol|)) "\\spad{displayKind(d)} specifies kind of the result: generating function, recurrence or equation. This option should not be set by the user, but rather by the HP-specification.")) (|indexName| (($ (|Symbol|)) "\\spad{indexName(d)} specifies the index variable used for the formulas. This option is expressed in the form \\spad{indexName \\spad{==} \\spad{d}.}")) (|variableName| (($ (|Symbol|)) "\\spad{variableName(d)} specifies the variable used in by the algebraic differential equation. This option is expressed in the form \\spad{variableName \\spad{==} \\spad{d}.}")) (|functionNames| (($ (|List| (|Symbol|))) "\\spad{functionNames(d)} specifies the names for the function in algebraic dependence. This option is expressed in the form \\spad{functionNames \\spad{==} \\spad{d}.}")) (|functionName| (($ (|Symbol|)) "\\spad{functionName(d)} specifies the name of the function given by the algebraic differential equation or recurrence. This option is expressed in the form \\spad{functionName \\spad{==} \\spad{d}.}")) (|debug| (($ (|Boolean|)) "\\spad{debug(d)} specifies whether we want additional output on the progress. This option is expressed in the form \\spad{debug \\spad{==} \\spad{d}.}")) (|one| (($ (|Boolean|)) "\\spad{one(d)} specifies whether we are happy with one solution. This option is expressed in the form \\spad{one \\spad{==} \\spad{d}.}")) (|checkExtraValues| (($ (|Boolean|)) "\\spad{checkExtraValues(d)} specifies whether we want to check the solution beyond the order given by the degree bounds. This option is expressed in the form \\spad{checkExtraValues \\spad{==} \\spad{d}}")) (|check| (($ (|Union| "skip" "MonteCarlo" "deterministic")) "\\spad{check(d)} specifies how we want to check the solution. If the value is \"skip\", we return the solutions found by the interpolation routine without checking. If the value is \"MonteCarlo\", we use a probabilistic check. This option is expressed in the form \\spad{check \\spad{==} \\spad{d}}")) (|safety| (($ (|NonNegativeInteger|)) "\\spad{safety(d)} specifies the number of values reserved for testing any solutions found. This option is expressed in the form \\spad{safety \\spad{==} \\spad{d}.}")) (|allDegrees| (($ (|Boolean|)) "\\spad{allDegrees(d)} specifies whether all possibilities of the degree vector - taking into account maxDegree - should be tried. This is mainly interesting for rational interpolation. This option is expressed in the form \\spad{allDegrees \\spad{==} \\spad{d}.}")) (|maxMixedDegree| (($ (|NonNegativeInteger|)) "\\spad{maxMixedDegree(d)} specifies the maximum q-degree of the coefficient polynomials in a recurrence with polynomial coefficients, in the case of mixed shifts. Although slightly inconsistent, maxMixedDegree(0) specifies that no mixed shifts are allowed. This option is expressed in the form \\spad{maxMixedDegree \\spad{==} \\spad{d}.}")) (|maxDegree| (($ (|Union| (|NonNegativeInteger|) "arbitrary")) "\\spad{maxDegree(d)} specifies the maximum degree of the coefficient polynomials in an algebraic differential equation or a recursion with polynomial coefficients. For rational functions with an exponential term, \\spad{maxDegree} bounds the degree of the denominator polynomial. This option is expressed in the form \\spad{maxDegree \\spad{==} \\spad{d}.}")) (|maxLevel| (($ (|Union| (|NonNegativeInteger|) "arbitrary")) "\\spad{maxLevel(d)} specifies the maximum number of recursion levels operators guessProduct and guessSum will be applied. This option is expressed in the form spad{maxLevel \\spad{==} \\spad{d}.}")) (|Somos| (($ (|Union| (|PositiveInteger|) (|Boolean|))) "\\spad{Somos(d)} specifies whether we want that the total degree of the differential operators is constant, and equal to \\spad{d,} or maxDerivative if true. If true, maxDerivative must be set, too.")) (|homogeneous| (($ (|Union| (|PositiveInteger|) (|Boolean|))) "\\spad{homogeneous(d)} specifies whether we allow only homogeneous algebraic differential equations. This option is expressed in the form \\spad{homogeneous \\spad{==} \\spad{d}.} If true, then maxPower must be set, too, and ADEs with constant total degree are allowed. If a PositiveInteger is given, only ADE's with this total degree are allowed.")) (|maxPower| (($ (|Union| (|PositiveInteger|) "arbitrary")) "\\spad{maxPower(d)} specifies the maximum degree in an algebraic differential equation. For example, the degree of \\spad{(f'')^3} \\spad{f'} is 4. maxPower(-1) specifies that the maximum exponent can be arbitrary. This option is expressed in the form \\spad{maxPower \\spad{==} \\spad{d}.}")) (|maxSubst| (($ (|Union| (|PositiveInteger|) "arbitrary")) "\\spad{maxSubst(d)} specifies the maximum degree of the monomial substituted into the function we are looking for. That is, if \\spad{maxSubst \\spad{==} \\spad{d},} we look for polynomials such that $p(f(x), f(x^2), ..., f(x^d))=0$. equation. This option is expressed in the form \\spad{maxSubst \\spad{==} \\spad{d}.}")) (|maxShift| (($ (|Union| (|NonNegativeInteger|) "arbitrary")) "\\spad{maxShift(d)} specifies the maximum shift in a recurrence equation. This option is expressed in the form \\spad{maxShift \\spad{==} \\spad{d}.}")) (|maxDerivative| (($ (|Union| (|NonNegativeInteger|) "arbitrary")) "\\spad{maxDerivative(d)} specifies the maximum derivative in an algebraic differential equation. This option is expressed in the form \\spad{maxDerivative \\spad{==} \\spad{d}.}"))) 
NIL 
NIL 
(|GosperSummationMethod| E V R P Q) 
((|constructor| (NIL "Gosper's summation algorithm.")) (|GospersMethod| (((|Union| |#5| "failed") |#5| |#2| (|Mapping| |#2|)) "\\spad{GospersMethod(b, \\spad{n,} new)} returns a rational function \\spad{rf(n)} such that \\spad{a(n) * rf(n)} is the indefinite sum of \\spad{a(n)} with respect to upward difference on \\spad{n}, \\spadignore{i.e.} \\spad{a(n+1) * rf(n+1) - a(n) * rf(n) = a(n)}, where \\spad{b(n) = a(n)/a(n-1)} is a rational function. Returns \"failed\" if no such rational function \\spad{rf(n)} exists. Note that \\spad{new} is a nullary function returning a new \\spad{V} every time. The condition on \\spad{a(n)} is that \\spad{a(n)/a(n-1)} is a rational function of \\spad{n}."))) 
NIL 
NIL 
(|GeneralPackageForAlgebraicFunctionField| K |symb| |PolyRing| E |ProjPt| PCS |Plc| DIVISOR |InfClsPoint| |DesTree| BLMET) 
((|constructor| (NIL "A package that implements the Brill-Noether algorithm. Part of the PAFF package.")) (|ZetaFunction| (((|UnivariateTaylorSeriesCZero| (|Integer|) |t|) (|PositiveInteger|)) "Returns the Zeta function of the curve in constant field extension. Calculated by using the L-Polynomial") (((|UnivariateTaylorSeriesCZero| (|Integer|) |t|)) "Returns the Zeta function of the curve. Calculated by using the L-Polynomial")) (|numberPlacesDegExtDeg| (((|Integer|) (|PositiveInteger|) (|PositiveInteger|)) "numberRatPlacesExtDegExtDeg(d, \\spad{n)} returns the number of places of degree \\spad{d} in the constant field extension of degree \\spad{n}")) (|numberRatPlacesExtDeg| (((|Integer|) (|PositiveInteger|)) "\\spad{numberRatPlacesExtDeg(n)} returns the number of rational places in the constant field extenstion of degree \\spad{n}")) (|numberOfPlacesOfDegree| (((|Integer|) (|PositiveInteger|)) "returns the number of places of the given degree")) (|placesOfDegree| (((|List| |#7|) (|PositiveInteger|)) "\\spad{placesOfDegree(d)} returns all places of degree \\spad{d} of the curve.")) (|classNumber| (((|Integer|)) "Returns the class number of the curve.")) (|LPolynomial| (((|SparseUnivariatePolynomial| (|Integer|)) (|PositiveInteger|)) "\\spad{LPolynomial(d)} returns the L-Polynomial of the curve in constant field extension of degree \\spad{d.}") (((|SparseUnivariatePolynomial| (|Integer|))) "Returns the L-Polynomial of the curve.")) (|rationalPlaces| (((|List| |#7|)) "\\spad{rationalPlaces returns} all the rational places of the curve defined by the polynomial given to the package.")) (|pointDominateBy| ((|#5| |#7|) "\\spad{pointDominateBy(pl)} returns the projective point dominated by the place \\spad{pl.}")) (|adjunctionDivisor| ((|#8|) "\\spad{adjunctionDivisor computes} the adjunction divisor of the plane curve given by the polynomial crv.")) (|intersectionDivisor| ((|#8| |#3|) "\\spad{intersectionDivisor(pol)} compute the intersection divisor (the Cartier divisor) of the form \\spad{pol} with the curve. If some intersection points lie in an extension of the ground field, an error message is issued specifying the extension degree needed to find all the intersection points. (If \\spad{pol} is not homogeneous an error message is issued).")) (|evalIfCan| (((|Union| |#1| "failed") (|Fraction| |#3|) |#7|) "\\spad{evalIfCan(u,pl)} evaluate the function \\spad{u} at the place \\spad{pl} (returns \"failed\" if it is a pole).") (((|Union| |#1| "failed") |#3| |#3| |#7|) "\\spad{evalIfCan(f,g,pl)} evaluate the function \\spad{f/g} at the place \\spad{pl} (returns \"failed\" if it is a pole).") (((|Union| |#1| "failed") |#3| |#7|) "\\spad{evalIfCan(f,pl)} evaluate \\spad{f} at the place \\spad{pl} (returns \"failed\" if it is a pole).")) (|eval| ((|#1| (|Fraction| |#3|) |#7|) "\\spad{eval(u,pl)} evaluate the function \\spad{u} at the place \\spad{pl.}") ((|#1| |#3| |#3| |#7|) "\\spad{eval(f,g,pl)} evaluate the function \\spad{f/g} at the place \\spad{pl.}") ((|#1| |#3| |#7|) "\\spad{eval(f,pl)} evaluate \\spad{f} at the place \\spad{pl.}")) (|interpolateForms| (((|List| |#3|) |#8| (|NonNegativeInteger|)) "\\spad{interpolateForms(d,n)} returns a basis of the interpolate forms of degree \\spad{n} of the divisor \\spad{d.}")) (|lBasis| (((|Record| (|:| |num| (|List| |#3|)) (|:| |den| |#3|)) |#8|) "\\spad{lBasis computes} a basis associated to the specified divisor")) (|parametrize| ((|#6| |#3| |#7|) "\\spad{parametrize(f,pl)} returns a local parametrization of \\spad{f} at the place \\spad{pl.}")) (|singularPoints| (((|List| |#5|)) "rationalPoints() returns the singular points of the curve defined by the polynomial given to the package. If the singular points lie in an extension of the specified ground field an error message is issued specifying the extension degree needed to find all singular points.")) (|setSingularPoints| (((|List| |#5|) (|List| |#5|)) "\\spad{setSingularPoints(lpt)} sets the singular points to be used. Beware: no attempt is made to check if the points are singular or not, nor if all of the singular points are presents. Hence, results of some computation maybe false. It is intend to be use when one want to compute the singular points are computed by other means than to use the function singularPoints.")) (|desingTreeWoFullParam| (((|List| |#10|)) "\\spad{desingTreeWoFullParam returns} the desingularisation trees at all singular points of the curve defined by the polynomial given to the package. The local parametrizations are not computed.")) (|desingTree| (((|List| |#10|)) "\\spad{desingTree returns} the desingularisation trees at all singular points of the curve defined by the polynomial given to the package.")) (|genus| (((|NonNegativeInteger|)) "\\spad{genus returns} the genus of the curve defined by the polynomial given to the package.")) (|theCurve| ((|#3|) "\\spad{theCurve returns} the specified polynomial for the package.")) (|printInfo| (((|Void|) (|List| (|Boolean|))) "\\spad{printInfo(lbool)} prints some information comming from various package and domain used by this package."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|Finite|)))) 
(|GeneralPolynomialSet| R E |VarSet| P) 
((|constructor| (NIL "A domain for polynomial sets.")) (|convert| (($ (|List| |#4|)) "\\axiom{convert(lp)} returns the polynomial set whose members are the polynomials of \\axiom{lp}."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#4| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#4| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) 
(|GradedAlgebra&| S R E) 
((|constructor| (NIL "GradedAlgebra(R,E) denotes ``E-graded R-algebra''. A graded algebra is a graded module together with a degree preserving R-linear map, called the product. \\blankline The name ``product'' is written out in full so inner and outer products with the same mapping type can be distinguished by name.")) (|product| (($ $ $) "\\spad{product(a,b)} is the degree-preserving R-linear product: \\blankline \\spad{degree product(a,b) = degree a + degree \\spad{b}} \\spad{product(a1+a2,b) = product(a1,b) + product(a2,b)} \\spad{product(a,b1+b2) = product(a,b1) + product(a,b2)} \\spad{product(r*a,b) = product(a,r*b) = r*product(a,b)} \\spad{product(a,product(b,c)) = product(product(a,b),c)}")) ((|One|) (($) "\\spad{1} is the identity for \\spad{product}."))) 
NIL 
NIL 
(|GradedAlgebra| R E) 
((|constructor| (NIL "GradedAlgebra(R,E) denotes ``E-graded R-algebra''. A graded algebra is a graded module together with a degree preserving R-linear map, called the product. \\blankline The name ``product'' is written out in full so inner and outer products with the same mapping type can be distinguished by name.")) (|product| (($ $ $) "\\spad{product(a,b)} is the degree-preserving R-linear product: \\blankline \\spad{degree product(a,b) = degree a + degree \\spad{b}} \\spad{product(a1+a2,b) = product(a1,b) + product(a2,b)} \\spad{product(a,b1+b2) = product(a,b1) + product(a,b2)} \\spad{product(r*a,b) = product(a,r*b) = r*product(a,b)} \\spad{product(a,product(b,c)) = product(product(a,b),c)}")) ((|One|) (($) "\\spad{1} is the identity for \\spad{product}."))) 
NIL 
NIL 
(|Graphviz|) 
((|constructor| (NIL "Low level tools for creating and viewing graphs using graphviz")) (|dotview| (((|Void|) (|String|) (|String|)) "\\indented{1}{dotview runs \"viewer filename\".} \\indented{1}{A file extension of \".eps\" is added.} \\blankline \\spad{X} dotview(\"evince\",\"NeuralNet\") \\spad{--} on Linux \\spad{X} dotview(\"gv\",\"NeuralNet\") \\spad{--} on MAC \\spad{X} dotview(\"firefox\",\"NeuralNet\") \\spad{--} most places")) (|dot2eps| (((|Void|) (|String|)) "\\indented{1}{dot2eps runs dot \\spad{-T} eps filename.dot >filename.eps} \\blankline \\spad{X} dot2eps \"NeuralNet\"")) (|writeDotGraph| (((|Void|) (|List| (|String|)) (|List| (|String|)) (|String|)) "\\indented{1}{creates a graphviz dot file and writes it out} \\blankline \\spad{X} header:=standardDotHeader() \\spad{X} graph:=sampleDotGraph() \\spad{X} writeDotGraph(header,graph,\"NeuralNet\")")) (|sampleDotGraph| (((|List| (|String|))) "\\indented{1}{creates a sample graph file} \\blankline \\spad{X} graph:=sampleDotGraph()")) (|standardDotHeader| (((|List| (|String|))) "\\indented{1}{create the standard dot} \\blankline \\spad{X} header:=standardDotHeader()"))) 
NIL 
NIL 
(|GrayCode|) 
((|constructor| (NIL "GrayCode provides a function for efficiently running through all subsets of a finite set, only changing one element by another one.")) (|firstSubsetGray| (((|Vector| (|Vector| (|Integer|))) (|PositiveInteger|)) "\\spad{firstSubsetGray(n)} creates the first vector \\spad{ww} to start a loop using nextSubsetGray(ww,n)")) (|nextSubsetGray| (((|Vector| (|Vector| (|Integer|))) (|Vector| (|Vector| (|Integer|))) (|PositiveInteger|)) "\\spad{nextSubsetGray(ww,n)} returns a vector \\spad{vv} whose components have the following meanings:\\br vv.1: a vector of length \\spad{n} whose entries are 0 or 1. This can be interpreted as a code for a subset of the set 1,...,n; \\spad{vv.1} differs from \\spad{ww.1} by exactly one entry;\\br \\spad{vv.2.1} is the number of the entry of \\spad{vv.1} which will be changed next time;\\br \\spad{vv.2.1} = \\spad{n+1} means that \\spad{vv.1} is the last subset; trying to compute nextSubsetGray(vv) if \\spad{vv.2.1} = \\spad{n+1} will produce an error!\\br \\blankline The other components of \\spad{vv.2} are needed to compute nextSubsetGray efficiently. Note that this is an implementation of [Williamson, Topic II, 3.54, \\spad{p.} 112] for the special case \\spad{r1} = \\spad{r2} = \\spad{...} = \\spad{rn} = 2; Note that nextSubsetGray produces a side-effect, \\spadignore{i.e.} nextSubsetGray(vv) and \\spad{vv} \\spad{:=} nextSubsetGray(vv) will have the same effect."))) 
NIL 
NIL 
(|GraphicsDefaults|) 
((|constructor| (NIL "TwoDimensionalPlotSettings sets global flags and constants for 2-dimensional plotting.")) (|screenResolution| (((|Integer|) (|Integer|)) "\\spad{screenResolution(n)} sets the screen resolution to \\spad{n.}") (((|Integer|)) "\\spad{screenResolution()} returns the screen resolution \\spad{n.}")) (|minPoints| (((|Integer|) (|Integer|)) "\\spad{minPoints()} sets the minimum number of points in a plot.") (((|Integer|)) "\\spad{minPoints()} returns the minimum number of points in a plot.")) (|maxPoints| (((|Integer|) (|Integer|)) "\\spad{maxPoints()} sets the maximum number of points in a plot.") (((|Integer|)) "\\spad{maxPoints()} returns the maximum number of points in a plot.")) (|adaptive| (((|Boolean|) (|Boolean|)) "\\spad{adaptive(true)} turns adaptive plotting on; \\spad{adaptive(false)} turns adaptive plotting off.") (((|Boolean|)) "\\spad{adaptive()} determines whether plotting will be done adaptively.")) (|drawToScale| (((|Boolean|) (|Boolean|)) "\\spad{drawToScale(true)} causes plots to be drawn to scale. \\spad{drawToScale(false)} causes plots to be drawn so that they fill up the viewport window. The default setting is false.") (((|Boolean|)) "\\spad{drawToScale()} determines whether or not plots are to be drawn to scale.")) (|clipPointsDefault| (((|Boolean|) (|Boolean|)) "\\spad{clipPointsDefault(true)} turns on automatic clipping; \\spad{clipPointsDefault(false)} turns off automatic clipping. The default setting is true.") (((|Boolean|)) "\\spad{clipPointsDefault()} determines whether or not automatic clipping is to be done."))) 
NIL 
NIL 
(|GraphImage|) 
((|constructor| (NIL "TwoDimensionalGraph creates virtual two dimensional graphs (to be displayed on TwoDimensionalViewports).")) (|putColorInfo| (((|List| (|List| (|Point| (|DoubleFloat|)))) (|List| (|List| (|Point| (|DoubleFloat|)))) (|List| (|Palette|))) "\\spad{putColorInfo(llp,lpal)} takes a list of list of points, \\spad{llp}, and returns the points with their hue and shade components set according to the list of palette colors, \\spad{lpal}.")) (|coerce| (((|OutputForm|) $) "\\spad{coerce(gi)} returns the indicated graph, \\spad{gi}, of domain \\spadtype{GraphImage} as output of the domain \\spadtype{OutputForm}.") (($ (|List| (|List| (|Point| (|DoubleFloat|))))) "\\spad{coerce(llp)} component(gi,pt) creates and returns a graph of the domain \\spadtype{GraphImage} which is composed of the list of list of points given by \\spad{llp}, and whose point colors, line colors and point sizes are determined by the default functions \\spadfun{pointColorDefault}, \\spadfun{lineColorDefault}, and \\spadfun{pointSizeDefault}. The graph data is then sent to the viewport manager where it waits to be included in a two-dimensional viewport window.")) (|point| (((|Void|) $ (|Point| (|DoubleFloat|)) (|Palette|)) "\\spad{point(gi,pt,pal)} modifies the graph \\spad{gi} of the domain \\spadtype{GraphImage} to contain one point component, \\spad{pt} whose point color is set to be the palette color \\spad{pal}, and whose line color and point size are determined by the default functions \\spadfun{lineColorDefault} and \\spadfun{pointSizeDefault}.")) (|appendPoint| (((|Void|) $ (|Point| (|DoubleFloat|))) "\\spad{appendPoint(gi,pt)} appends the point \\spad{pt} to the end of the list of points component for the graph, \\spad{gi}, which is of the domain \\spadtype{GraphImage}.")) (|component| (((|Void|) $ (|Point| (|DoubleFloat|)) (|Palette|) (|Palette|) (|PositiveInteger|)) "\\spad{component(gi,pt,pal1,pal2,ps)} modifies the graph \\spad{gi} of the domain \\spadtype{GraphImage} to contain one point component, \\spad{pt} whose point color is set to the palette color \\spad{pal1}, line color is set to the palette color \\spad{pal2}, and point size is set to the positive integer \\spad{ps}.") (((|Void|) $ (|Point| (|DoubleFloat|))) "\\spad{component(gi,pt)} modifies the graph \\spad{gi} of the domain \\spadtype{GraphImage} to contain one point component, \\spad{pt} whose point color, line color and point size are determined by the default functions \\spadfun{pointColorDefault}, \\spadfun{lineColorDefault}, and \\spadfun{pointSizeDefault}.") (((|Void|) $ (|List| (|Point| (|DoubleFloat|))) (|Palette|) (|Palette|) (|PositiveInteger|)) "\\spad{component(gi,lp,pal1,pal2,p)} sets the components of the graph, \\spad{gi} of the domain \\spadtype{GraphImage}, to the values given. The point list for \\spad{gi} is set to the list \\spad{lp}, the color of the points in \\spad{lp} is set to the palette color \\spad{pal1}, the color of the lines which connect the points \\spad{lp} is set to the palette color \\spad{pal2}, and the size of the points in \\spad{lp} is given by the integer \\spad{p.}")) (|units| (((|List| (|Float|)) $ (|List| (|Float|))) "\\spad{units(gi,lu)} modifies the list of unit increments for the \\spad{x} and \\spad{y} axes of the given graph, \\spad{gi} of the domain \\spadtype{GraphImage}, to be that of the list of unit increments, \\spad{lu}, and returns the new list of units for \\spad{gi}.") (((|List| (|Float|)) $) "\\spad{units(gi)} returns the list of unit increments for the \\spad{x} and \\spad{y} axes of the indicated graph, \\spad{gi}, of the domain \\spadtype{GraphImage}.")) (|ranges| (((|List| (|Segment| (|Float|))) $ (|List| (|Segment| (|Float|)))) "\\spad{ranges(gi,lr)} modifies the list of ranges for the given graph, \\spad{gi} of the domain \\spadtype{GraphImage}, to be that of the list of range segments, \\spad{lr}, and returns the new range list for \\spad{gi}.") (((|List| (|Segment| (|Float|))) $) "\\spad{ranges(gi)} returns the list of ranges of the point components from the indicated graph, \\spad{gi}, of the domain \\spadtype{GraphImage}.")) (|key| (((|Integer|) $) "\\spad{key(gi)} returns the process ID of the given graph, \\spad{gi}, of the domain \\spadtype{GraphImage}.")) (|pointLists| (((|List| (|List| (|Point| (|DoubleFloat|)))) $) "\\spad{pointLists(gi)} returns the list of lists of points which compose the given graph, \\spad{gi}, of the domain \\spadtype{GraphImage}.")) (|makeGraphImage| (($ (|List| (|List| (|Point| (|DoubleFloat|)))) (|List| (|Palette|)) (|List| (|Palette|)) (|List| (|PositiveInteger|)) (|List| (|DrawOption|))) "\\spad{makeGraphImage(llp,lpal1,lpal2,lp,lopt)} returns a graph of the domain \\spadtype{GraphImage} which is composed of the points and lines from the list of lists of points, \\spad{llp}, whose point colors are indicated by the list of palette colors, \\spad{lpal1}, and whose lines are colored according to the list of palette colors, \\spad{lpal2}. The paramater \\spad{lp} is a list of integers which denote the size of the data points, and \\spad{lopt} is the list of draw command options. The graph data is then sent to the viewport manager where it waits to be included in a two-dimensional viewport window.") (($ (|List| (|List| (|Point| (|DoubleFloat|)))) (|List| (|Palette|)) (|List| (|Palette|)) (|List| (|PositiveInteger|))) "\\spad{makeGraphImage(llp,lpal1,lpal2,lp)} returns a graph of the domain \\spadtype{GraphImage} which is composed of the points and lines from the list of lists of points, \\spad{llp}, whose point colors are indicated by the list of palette colors, \\spad{lpal1}, and whose lines are colored according to the list of palette colors, \\spad{lpal2}. The paramater \\spad{lp} is a list of integers which denote the size of the data points. The graph data is then sent to the viewport manager where it waits to be included in a two-dimensional viewport window.") (($ (|List| (|List| (|Point| (|DoubleFloat|))))) "\\spad{makeGraphImage(llp)} returns a graph of the domain \\spadtype{GraphImage} which is composed of the points and lines from the list of lists of points, \\spad{llp}, with default point size and default point and line colours. The graph data is then sent to the viewport manager where it waits to be included in a two-dimensional viewport window.") (($ $) "\\spad{makeGraphImage(gi)} takes the given graph, \\spad{gi} of the domain \\spadtype{GraphImage}, and sends it's data to the viewport manager where it waits to be included in a two-dimensional viewport window. \\spad{gi} cannot be an empty graph, and it's elements must have been created using the \\spadfun{point} or \\spadfun{component} functions, not by a previous \\spadfun{makeGraphImage}.")) (|graphImage| (($) "\\spad{graphImage()} returns an empty graph with 0 point lists of the domain \\spadtype{GraphImage}. A graph image contains the graph data component of a two dimensional viewport."))) 
NIL 
NIL 
(|GradedModule&| S R E) 
((|constructor| (NIL "GradedModule(R,E) denotes ``E-graded R-module'', that is, collection of R-modules indexed by an abelian monoid E. An element \\spad{g} of \\spad{G[s]} for some specific \\spad{s} in \\spad{E} is said to be an element of \\spad{G} with degree \\spad{s}. Sums are defined in each module \\spad{G[s]} so two elements of \\spad{G} have a sum if they have the same degree. \\blankline Morphisms can be defined and composed by degree to give the mathematical category of graded modules.")) (+ (($ $ $) "\\spad{g+h} is the sum of \\spad{g} and \\spad{h} in the module of elements of the same degree as \\spad{g} and \\spad{h.} Error: if \\spad{g} and \\spad{h} have different degrees.")) (- (($ $ $) "\\spad{g-h} is the difference of \\spad{g} and \\spad{h} in the module of elements of the same degree as \\spad{g} and \\spad{h.} Error: if \\spad{g} and \\spad{h} have different degrees.") (($ $) "\\spad{-g} is the additive inverse of \\spad{g} in the module of elements of the same grade as \\spad{g.}")) (* (($ $ |#2|) "\\spad{g*r} is right module multiplication.") (($ |#2| $) "\\spad{r*g} is left module multiplication.")) ((|Zero|) (($) "\\spad{0} denotes the zero of degree 0.")) (|degree| ((|#3| $) "\\spad{degree(g)} names the degree of \\spad{g.} The set of all elements of a given degree form an R-module."))) 
NIL 
NIL 
(|GradedModule| R E) 
((|constructor| (NIL "GradedModule(R,E) denotes ``E-graded R-module'', that is, collection of R-modules indexed by an abelian monoid E. An element \\spad{g} of \\spad{G[s]} for some specific \\spad{s} in \\spad{E} is said to be an element of \\spad{G} with degree \\spad{s}. Sums are defined in each module \\spad{G[s]} so two elements of \\spad{G} have a sum if they have the same degree. \\blankline Morphisms can be defined and composed by degree to give the mathematical category of graded modules.")) (+ (($ $ $) "\\spad{g+h} is the sum of \\spad{g} and \\spad{h} in the module of elements of the same degree as \\spad{g} and \\spad{h.} Error: if \\spad{g} and \\spad{h} have different degrees.")) (- (($ $ $) "\\spad{g-h} is the difference of \\spad{g} and \\spad{h} in the module of elements of the same degree as \\spad{g} and \\spad{h.} Error: if \\spad{g} and \\spad{h} have different degrees.") (($ $) "\\spad{-g} is the additive inverse of \\spad{g} in the module of elements of the same grade as \\spad{g.}")) (* (($ $ |#1|) "\\spad{g*r} is right module multiplication.") (($ |#1| $) "\\spad{r*g} is left module multiplication.")) ((|Zero|) (($) "\\spad{0} denotes the zero of degree 0.")) (|degree| ((|#2| $) "\\spad{degree(g)} names the degree of \\spad{g.} The set of all elements of a given degree form an R-module."))) 
NIL 
NIL 
(|GroebnerSolve| |lv| F R) 
((|constructor| (NIL "Solve systems of polynomial equations using Groebner bases Total order Groebner bases are computed and then converted to lex ones This package is mostly intended for internal use.")) (|genericPosition| (((|Record| (|:| |dpolys| (|List| (|DistributedMultivariatePolynomial| |#1| |#2|))) (|:| |coords| (|List| (|Integer|)))) (|List| (|DistributedMultivariatePolynomial| |#1| |#2|)) (|List| (|OrderedVariableList| |#1|))) "\\spad{genericPosition(lp,lv)} puts a radical zero dimensional ideal in general position, for system \\spad{lp} in variables \\spad{lv.}")) (|testDim| (((|Union| (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)) "failed") (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)) (|List| (|OrderedVariableList| |#1|))) "\\spad{testDim(lp,lv)} tests if the polynomial system \\spad{lp} in variables \\spad{lv} is zero dimensional.")) (|groebSolve| (((|List| (|List| (|DistributedMultivariatePolynomial| |#1| |#2|))) (|List| (|DistributedMultivariatePolynomial| |#1| |#2|)) (|List| (|OrderedVariableList| |#1|))) "\\spad{groebSolve(lp,lv)} reduces the polynomial system \\spad{lp} in variables \\spad{lv} to triangular form. Algorithm based on groebner bases algorithm with linear algebra for change of ordering. Preprocessing for the general solver. The polynomials in input are of type \\spadtype{DMP}."))) 
NIL 
NIL 
(|Group&| S) 
((|constructor| (NIL "The class of multiplicative groups, that is, monoids with multiplicative inverses. \\blankline Axioms\\br \\tab{5}\\spad{leftInverse(\"*\":(\\%,\\%)->\\%,inv)}\\tab{5}\\spad{inv(x)*x = 1}\\br \\tab{5}\\spad{rightInverse(\"*\":(\\%,\\%)->\\%,inv)}\\tab{4}\\spad{x*inv(x) = 1}")) (|commutator| (($ $ $) "\\spad{commutator(p,q)} computes \\spad{inv(p) * inv(q) * \\spad{p} * \\spad{q}.}")) (|conjugate| (($ $ $) "\\spad{conjugate(p,q)} computes \\spad{inv(q) * \\spad{p} * \\spad{q};} this is 'right action by conjugation'.")) (|unitsKnown| ((|attribute|) "unitsKnown asserts that recip only returns \"failed\" for non-units.")) (^ (($ $ (|Integer|)) "\\spad{x^n} returns \\spad{x} raised to the integer power \\spad{n.}")) (** (($ $ (|Integer|)) "\\spad{x**n} returns \\spad{x} raised to the integer power \\spad{n.}")) (/ (($ $ $) "\\spad{x/y} is the same as \\spad{x} times the inverse of \\spad{y.}")) (|inv| (($ $) "\\spad{inv(x)} returns the inverse of \\spad{x.}"))) 
NIL 
NIL 
(|Group|) 
((|constructor| (NIL "The class of multiplicative groups, that is, monoids with multiplicative inverses. \\blankline Axioms\\br \\tab{5}\\spad{leftInverse(\"*\":(\\%,\\%)->\\%,inv)}\\tab{5}\\spad{inv(x)*x = 1}\\br \\tab{5}\\spad{rightInverse(\"*\":(\\%,\\%)->\\%,inv)}\\tab{4}\\spad{x*inv(x) = 1}")) (|commutator| (($ $ $) "\\spad{commutator(p,q)} computes \\spad{inv(p) * inv(q) * \\spad{p} * \\spad{q}.}")) (|conjugate| (($ $ $) "\\spad{conjugate(p,q)} computes \\spad{inv(q) * \\spad{p} * \\spad{q};} this is 'right action by conjugation'.")) (|unitsKnown| ((|attribute|) "unitsKnown asserts that recip only returns \"failed\" for non-units.")) (^ (($ $ (|Integer|)) "\\spad{x^n} returns \\spad{x} raised to the integer power \\spad{n.}")) (** (($ $ (|Integer|)) "\\spad{x**n} returns \\spad{x} raised to the integer power \\spad{n.}")) (/ (($ $ $) "\\spad{x/y} is the same as \\spad{x} times the inverse of \\spad{y.}")) (|inv| (($ $) "\\spad{inv(x)} returns the inverse of \\spad{x.}"))) 
((|unitsKnown| . T)) 
NIL 
(|GeneralUnivariatePowerSeries| |Coef| |var| |cen|) 
((|constructor| (NIL "This is a category of univariate Puiseux series constructed from univariate Laurent series. A Puiseux series is represented by a pair \\spad{[r,f(x)]}, where \\spad{r} is a positive rational number and \\spad{f(x)} is a Laurent series. This pair represents the Puiseux series \\spad{f(x\\^r)}.")) (|integrate| (($ $ (|Variable| |#2|)) "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.")) (|differentiate| (($ $ (|Variable| |#2|)) "\\spad{differentiate(f(x),x)} returns the derivative of \\spad{f(x)} with respect to \\spad{x}.")) (|coerce| (($ (|UnivariatePuiseuxSeries| |#1| |#2| |#3|)) "\\spad{coerce(f)} converts a Puiseux series to a general power series.") (($ (|Variable| |#2|)) "\\spad{coerce(var)} converts the series variable \\spad{var} into a Puiseux series."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))) (|devaluate| |#1|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))) (|devaluate| |#1|))))) (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|SemiGroup|))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|)))))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |AlgebraicallyClosedFunctionSpace|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|PrimitiveFunctionCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |integrate|) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Symbol|))))) (|HasSignature| |#1| (LIST (QUOTE |variables|) (LIST (LIST (QUOTE |List|) (QUOTE (|Symbol|))) (|devaluate| |#1|))))))) 
(|GeneralSparseTable| |Key| |Entry| |Tbl| |dent|) 
((|constructor| (NIL "A sparse table has a default entry, which is returned if no other value has been explicitly stored for a key."))) 
((|shallowlyMutable| . T)) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (|devaluate| |#1|)) (LIST (QUOTE |:|) (QUOTE |entry|) (|devaluate| |#2|))))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|)))) (OR (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) 
(|GeneralTriangularSet| R E V P) 
((|constructor| (NIL "A domain constructor of the category \\axiomType{TriangularSetCategory}. The only requirement for a list of polynomials to be a member of such a domain is the following: no polynomial is constant and two distinct polynomials have distinct main variables. Such a triangular set may not be auto-reduced or consistent. Triangular sets are stored as sorted lists w.r.t. the main variables of their members but they are displayed in reverse order."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#4| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#4| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#3| (QUOTE (|Finite|)))) 
(|GuessAlgebraicNumber|) 
((|constructor| (NIL "This package exports guessing of sequences of rational functions"))) 
NIL 
((|HasCategory| (|AlgebraicNumber|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|))))) 
(|GuessFiniteFunctions| F) 
((|constructor| (NIL "This package exports guessing of sequences of numbers in a finite field"))) 
NIL 
NIL 
(|GuessFinite| F) 
((|constructor| (NIL "This package exports guessing of sequences of numbers in a finite field"))) 
NIL 
((|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|))))) 
(|GuessInteger|) 
((|constructor| (NIL "This package exports guessing of sequences of rational numbers"))) 
NIL 
((AND (|HasCategory| (|Fraction| (|Integer|)) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))))) 
(|Guess| F S EXPRR R |retract| |coerce|) 
((|constructor| (NIL "This package implements guessing of sequences. Packages for the most common cases are provided as \\spadtype{GuessInteger}, \\spadtype{GuessPolynomial}, etc.")) (|shiftHP| (((|Mapping| (|Record| (|:| |guessStream| (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| |#1|)) (|UnivariateFormalPowerSeries| |#1|))) (|:| |degreeStream| (|Stream| (|NonNegativeInteger|))) (|:| |testStream| (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|))) (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|)))) (|:| |exprStream| (|Mapping| (|Stream| |#3|) |#3| (|Symbol|))) (|:| A (|Mapping| |#2| (|NonNegativeInteger|) (|NonNegativeInteger|) (|SparseUnivariatePolynomial| |#2|))) (|:| AF (|Mapping| (|SparseUnivariatePolynomial| |#1|) (|NonNegativeInteger|) (|NonNegativeInteger|) (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|)))) (|:| AX (|Mapping| |#3| (|NonNegativeInteger|) (|Symbol|) |#3|)) (|:| C (|Mapping| (|List| |#2|) (|NonNegativeInteger|)))) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{shiftHP options} returns a specification for Hermite-Pade approximation with the $q$-shift operator") (((|Record| (|:| |guessStream| (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| |#1|)) (|UnivariateFormalPowerSeries| |#1|))) (|:| |degreeStream| (|Stream| (|NonNegativeInteger|))) (|:| |testStream| (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|))) (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|)))) (|:| |exprStream| (|Mapping| (|Stream| |#3|) |#3| (|Symbol|))) (|:| A (|Mapping| |#2| (|NonNegativeInteger|) (|NonNegativeInteger|) (|SparseUnivariatePolynomial| |#2|))) (|:| AF (|Mapping| (|SparseUnivariatePolynomial| |#1|) (|NonNegativeInteger|) (|NonNegativeInteger|) (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|)))) (|:| AX (|Mapping| |#3| (|NonNegativeInteger|) (|Symbol|) |#3|)) (|:| C (|Mapping| (|List| |#2|) (|NonNegativeInteger|)))) (|List| (|GuessOption|))) "\\spad{shiftHP options} returns a specification for Hermite-Pade approximation with the shift operator")) (|diffHP| (((|Mapping| (|Record| (|:| |guessStream| (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| |#1|)) (|UnivariateFormalPowerSeries| |#1|))) (|:| |degreeStream| (|Stream| (|NonNegativeInteger|))) (|:| |testStream| (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|))) (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|)))) (|:| |exprStream| (|Mapping| (|Stream| |#3|) |#3| (|Symbol|))) (|:| A (|Mapping| |#2| (|NonNegativeInteger|) (|NonNegativeInteger|) (|SparseUnivariatePolynomial| |#2|))) (|:| AF (|Mapping| (|SparseUnivariatePolynomial| |#1|) (|NonNegativeInteger|) (|NonNegativeInteger|) (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|)))) (|:| AX (|Mapping| |#3| (|NonNegativeInteger|) (|Symbol|) |#3|)) (|:| C (|Mapping| (|List| |#2|) (|NonNegativeInteger|)))) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{diffHP options} returns a specification for Hermite-Pade approximation with the $q$-dilation operator") (((|Record| (|:| |guessStream| (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| |#1|)) (|UnivariateFormalPowerSeries| |#1|))) (|:| |degreeStream| (|Stream| (|NonNegativeInteger|))) (|:| |testStream| (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|))) (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|)))) (|:| |exprStream| (|Mapping| (|Stream| |#3|) |#3| (|Symbol|))) (|:| A (|Mapping| |#2| (|NonNegativeInteger|) (|NonNegativeInteger|) (|SparseUnivariatePolynomial| |#2|))) (|:| AF (|Mapping| (|SparseUnivariatePolynomial| |#1|) (|NonNegativeInteger|) (|NonNegativeInteger|) (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|)))) (|:| AX (|Mapping| |#3| (|NonNegativeInteger|) (|Symbol|) |#3|)) (|:| C (|Mapping| (|List| |#2|) (|NonNegativeInteger|)))) (|List| (|GuessOption|))) "\\spad{diffHP options} returns a specification for Hermite-Pade approximation with the differential operator")) (|guessRat| (((|Mapping| (|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{guessRat \\spad{q}} returns a guesser that tries to find a q-rational function whose first values are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessRec} with \\spad{(l, maxShift \\spad{==} 0, maxPower \\spad{==} 1, allDegrees \\spad{==} true)}.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|)) "\\spad{guessRat \\spad{l}} tries to find a rational function whose first values are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessRec}\\spad{(l, maxShift \\spad{==} 0, maxPower \\spad{==} 1, allDegrees \\spad{==} true)}.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) "\\spad{guessRat(l, options)} tries to find a rational function whose first values are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessRec}\\spad{(l, maxShift \\spad{==} 0, maxPower \\spad{==} 1, allDegrees \\spad{==} true)}.")) (|guessPRec| (((|Mapping| (|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{guessPRec \\spad{q}} returns a guesser that tries to find a linear q-recurrence with polynomial coefficients whose first values are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessRec}\\spad{(q)} with \\spad{maxPower \\spad{==} 1}.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|)) "\\spad{guessPRec \\spad{l}} tries to find a linear recurrence with polynomial coefficients whose first values are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessRec}\\spad{(l, maxPower \\spad{==} 1)}.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) "\\spad{guessPRec(l, options)} tries to find a linear recurrence with polynomial coefficients whose first values are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessRec}\\spad{(l, options)} with \\spad{maxPower \\spad{==} 1}.")) (|guessRec| (((|Mapping| (|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{guessRec \\spad{q}} returns a guesser that finds an ordinary q-difference equation whose first values are given by \\spad{l,} using the given options.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) "\\spad{guessRec(l, options)} tries to find an ordinary difference equation whose first values are given by \\spad{l,} using the given options.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|)) "\\spad{guessRec \\spad{l}} tries to find an ordinary difference equation whose first values are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}.")) (|guessPade| (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|)) "\\spad{guessPade(l, options)} tries to find a rational function whose first Taylor coefficients are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessADE}\\spad{(l, options)} with \\spad{maxDerivative \\spad{==} 0, maxPower \\spad{==} 1, allDegrees \\spad{==} true}.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) "\\spad{guessPade(l, options)} tries to find a rational function whose first Taylor coefficients are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessADE}\\spad{(l, maxDerivative \\spad{==} 0, maxPower \\spad{==} 1, allDegrees \\spad{==} true)}.")) (|guessHolo| (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) "\\spad{guessHolo(l, options)} tries to find an ordinary linear differential equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessADE}\\spad{(l, options)} with \\spad{maxPower \\spad{==} 1}.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|)) "\\spad{guessHolo \\spad{l}} tries to find an ordinary linear differential equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessADE}\\spad{(l, maxPower \\spad{==} 1)}.")) (|guessAlg| (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) "\\spad{guessAlg(l, options)} tries to find an algebraic equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessADE}(l, options) with \\spad{maxDerivative \\spad{==} 0}.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|)) "\\spad{guessAlg \\spad{l}} tries to find an algebraic equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessADE}(l, maxDerivative \\spad{==} 0).")) (|guessADE| (((|Mapping| (|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{guessADE \\spad{q}} returns a guesser that tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the given options.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) "\\spad{guessADE(l, options)} tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the given options.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|)) "\\spad{guessADE \\spad{l}} tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}.")) (|guessHP| (((|Mapping| (|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) (|Mapping| (|Record| (|:| |guessStream| (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| |#1|)) (|UnivariateFormalPowerSeries| |#1|))) (|:| |degreeStream| (|Stream| (|NonNegativeInteger|))) (|:| |testStream| (|Mapping| (|Stream| (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|))) (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|)))) (|:| |exprStream| (|Mapping| (|Stream| |#3|) |#3| (|Symbol|))) (|:| A (|Mapping| |#2| (|NonNegativeInteger|) (|NonNegativeInteger|) (|SparseUnivariatePolynomial| |#2|))) (|:| AF (|Mapping| (|SparseUnivariatePolynomial| |#1|) (|NonNegativeInteger|) (|NonNegativeInteger|) (|UnivariateFormalPowerSeries| (|SparseUnivariatePolynomial| |#1|)))) (|:| AX (|Mapping| |#3| (|NonNegativeInteger|) (|Symbol|) |#3|)) (|:| C (|Mapping| (|List| |#2|) (|NonNegativeInteger|)))) (|List| (|GuessOption|)))) "\\spad{guessHP \\spad{f}} constructs an operation that applies Hermite-Pade approximation to the series generated by the given function \\spad{f.}")) (|guessBinRat| (((|Mapping| (|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{guessBinRat \\spad{q}} returns a guesser that tries to find a function of the form n+->qbinomial(a+b \\spad{n,} \\spad{n)} r(n), where r(q^n) is a q-rational function, that fits \\spad{l.}") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) "\\spad{guessBinRat(l, options)} tries to find a function of the form n+->binomial(a+b \\spad{n,} \\spad{n)} r(n), where r(n) is a rational function, that fits \\spad{l.}") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|)) "\\spad{guessBinRat(l, options)} tries to find a function of the form n+->binomial(a+b \\spad{n,} \\spad{n)} r(n), where r(n) is a rational function, that fits \\spad{l.}")) (|guessExpRat| (((|Mapping| (|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{guessExpRat \\spad{q}} returns a guesser that tries to find a function of the form n+->(a+b q^n)^n r(q^n), where r(q^n) is a q-rational function, that fits \\spad{l.}") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) "\\spad{guessExpRat(l, options)} tries to find a function of the form n+->(a+b n)^n r(n), where r(n) is a rational function, that fits \\spad{l.}") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|)) "\\spad{guessExpRat \\spad{l}} tries to find a function of the form n+->(a+b n)^n r(n), where r(n) is a rational function, that fits \\spad{l.}")) (|guess| (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|Mapping| (|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|)))) (|List| (|Symbol|)) (|List| (|GuessOption|))) "\\spad{guess(l, guessers, ops)} applies recursively the given \\spad{guessers} to the successive differences if ops contains the symbol \\spad{guessSum} and quotients if ops contains the symbol \\spad{guessProduct} to the list. The given options are used.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|Mapping| (|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|)))) (|List| (|Symbol|))) "\\spad{guess(l, guessers, ops)} applies recursively the given \\spad{guessers} to the successive differences if ops contains the symbol guessSum and quotients if ops contains the symbol guessProduct to the list. Default options as described in \\spadtype{GuessOptionFunctions0} are used.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|) (|List| (|GuessOption|))) "\\spad{guess(l, options)} applies recursively \\spadfun{guessRec} and \\spadfun{guessADE} to the successive differences and quotients of the list. The given options are used.") (((|List| (|Record| (|:| |function| |#3|) (|:| |order| (|NonNegativeInteger|)))) (|List| |#1|)) "\\spad{guess \\spad{l}} applies recursively \\spadfun{guessRec} and \\spadfun{guessADE} to the successive differences and quotients of the list. Default options as described in \\spadtype{GuessOptionFunctions0} are used."))) 
NIL 
((AND (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))))) 
(|GuessPolynomial|) 
((|constructor| (NIL "This package exports guessing of sequences of rational functions"))) 
NIL 
((AND (|HasCategory| (|Fraction| (|Polynomial| (|Integer|))) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| (|Polynomial| (|Integer|)) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))))) 
(|GuessUnivariatePolynomial| |q|) 
((|constructor| (NIL "This package exports guessing of sequences of univariate rational functions")) (|shiftHP| (((|Mapping| HPSPEC (|List| (|GuessOption|))) (|Symbol|)) "\\spad{shiftHP options} returns a specification for Hermite-Pade approximation with the $q$-shift operator") ((HPSPEC (|List| (|GuessOption|))) "\\spad{shiftHP options} returns a specification for Hermite-Pade approximation with the shift operator")) (|diffHP| (((|Mapping| HPSPEC (|List| (|GuessOption|))) (|Symbol|)) "\\spad{diffHP options} returns a specification for Hermite-Pade approximation with the $q$-dilation operator") ((HPSPEC (|List| (|GuessOption|))) "\\spad{diffHP options} returns a specification for Hermite-Pade approximation with the differential operator")) (|guessRat| (((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{guessRat \\spad{q}} returns a guesser that tries to find a q-rational function whose first values are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessRec} with \\spad{(l, maxShift \\spad{==} 0, maxPower \\spad{==} 1, allDegrees \\spad{==} true)}.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|))))) "\\spad{guessRat \\spad{l}} tries to find a rational function whose first values are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessRec}\\spad{(l, maxShift \\spad{==} 0, maxPower \\spad{==} 1, allDegrees \\spad{==} true)}.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) "\\spad{guessRat(l, options)} tries to find a rational function whose first values are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessRec}\\spad{(l, maxShift \\spad{==} 0, maxPower \\spad{==} 1, allDegrees \\spad{==} true)}.")) (|guessPRec| (((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{guessPRec \\spad{q}} returns a guesser that tries to find a linear q-recurrence with polynomial coefficients whose first values are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessRec}\\spad{(q)} with \\spad{maxPower \\spad{==} 1}.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|))))) "\\spad{guessPRec \\spad{l}} tries to find a linear recurrence with polynomial coefficients whose first values are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessRec}\\spad{(l, maxPower \\spad{==} 1)}.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) "\\spad{guessPRec(l, options)} tries to find a linear recurrence with polynomial coefficients whose first values are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessRec}\\spad{(l, options)} with \\spad{maxPower \\spad{==} 1}.")) (|guessRec| (((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{guessRec \\spad{q}} returns a guesser that finds an ordinary q-difference equation whose first values are given by \\spad{l,} using the given options.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) "\\spad{guessRec(l, options)} tries to find an ordinary difference equation whose first values are given by \\spad{l,} using the given options.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|))))) "\\spad{guessRec \\spad{l}} tries to find an ordinary difference equation whose first values are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}.")) (|guessPade| (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|))))) "\\spad{guessPade(l, options)} tries to find a rational function whose first Taylor coefficients are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessADE}\\spad{(l, options)} with \\spad{maxDerivative \\spad{==} 0, maxPower \\spad{==} 1, allDegrees \\spad{==} true}.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) "\\spad{guessPade(l, options)} tries to find a rational function whose first Taylor coefficients are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessADE}\\spad{(l, maxDerivative \\spad{==} 0, maxPower \\spad{==} 1, allDegrees \\spad{==} true)}.")) (|guessHolo| (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) "\\spad{guessHolo(l, options)} tries to find an ordinary linear differential equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessADE}\\spad{(l, options)} with \\spad{maxPower \\spad{==} 1}.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|))))) "\\spad{guessHolo \\spad{l}} tries to find an ordinary linear differential equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessADE}\\spad{(l, maxPower \\spad{==} 1)}.")) (|guessAlg| (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) "\\spad{guessAlg(l, options)} tries to find an algebraic equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the given options. It is equivalent to \\spadfun{guessADE}(l, options) with \\spad{maxDerivative \\spad{==} 0}.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|))))) "\\spad{guessAlg \\spad{l}} tries to find an algebraic equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}. It is equivalent to \\spadfun{guessADE}(l, maxDerivative \\spad{==} 0).")) (|guessADE| (((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{guessADE \\spad{q}} returns a guesser that tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the given options.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) "\\spad{guessADE(l, options)} tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the given options.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|))))) "\\spad{guessADE \\spad{l}} tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by \\spad{l,} using the default options described in \\spadtype{GuessOptionFunctions0}.")) (|guessHP| (((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Mapping| HPSPEC (|List| (|GuessOption|)))) "\\spad{guessHP \\spad{f}} constructs an operation that applies Hermite-Pade approximation to the series generated by the given function \\spad{f.}")) (|guessBinRat| (((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{guessBinRat \\spad{q}} returns a guesser that tries to find a function of the form n+->qbinomial(a+b \\spad{n,} \\spad{n)} r(n), where r(q^n) is a q-rational function, that fits \\spad{l.}") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) "\\spad{guessBinRat(l, options)} tries to find a function of the form n+->binomial(a+b \\spad{n,} \\spad{n)} r(n), where r(n) is a rational function, that fits \\spad{l.}") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|))))) "\\spad{guessBinRat(l, options)} tries to find a function of the form n+->binomial(a+b \\spad{n,} \\spad{n)} r(n), where r(n) is a rational function, that fits \\spad{l.}")) (|guessExpRat| (((|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) (|Symbol|)) "\\spad{guessExpRat \\spad{q}} returns a guesser that tries to find a function of the form n+->(a+b q^n)^n r(q^n), where r(q^n) is a q-rational function, that fits \\spad{l.}") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) "\\spad{guessExpRat(l, options)} tries to find a function of the form n+->(a+b n)^n r(n), where r(n) is a rational function, that fits \\spad{l.}") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|))))) "\\spad{guessExpRat \\spad{l}} tries to find a function of the form n+->(a+b n)^n r(n), where r(n) is a rational function, that fits \\spad{l.}")) (|guess| (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (|List| (|Symbol|)) (|List| (|GuessOption|))) "\\spad{guess(l, guessers, ops)} applies recursively the given \\spad{guessers} to the successive differences if ops contains the symbol \\spad{guessSum} and quotients if ops contains the symbol \\spad{guessProduct} to the list. The given options are used.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|Mapping| (|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|)))) (|List| (|Symbol|))) "\\spad{guess(l, guessers, ops)} applies recursively the given \\spad{guessers} to the successive differences if ops contains the symbol guessSum and quotients if ops contains the symbol guessProduct to the list. Default options as described in \\spadtype{GuessOptionFunctions0} are used.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|)))) (|List| (|GuessOption|))) "\\spad{guess(l, options)} applies recursively \\spadfun{guessRec} and \\spadfun{guessADE} to the successive differences and quotients of the list. The given options are used.") (((|List| (|Record| (|:| |function| (|MyExpression| |#1| (|Integer|))) (|:| |order| (|NonNegativeInteger|)))) (|List| (|Fraction| (|MyUnivariatePolynomial| |#1| (|Integer|))))) "\\spad{guess \\spad{l}} applies recursively \\spadfun{guessRec} and \\spadfun{guessADE} to the successive differences and quotients of the list. Default options as described in \\spadtype{GuessOptionFunctions0} are used."))) 
NIL 
NIL 
(|Pi|) 
((|constructor| (NIL "Symbolic fractions in \\%pi with integer coefficients; The point for using \\spad{Pi} as the default domain for those fractions is that \\spad{Pi} is coercible to the float types, and not Expression.")) (|pi| (($) "\\spad{pi()} returns the symbolic \\%pi."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|HashTable| |Key| |Entry| |hashfn|) 
((|constructor| (NIL "This domain provides access to the underlying Lisp hash tables. By varying the hashfn parameter, tables suited for different purposes can be obtained."))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (|devaluate| |#1|)) (LIST (QUOTE |:|) (QUOTE |entry|) (|devaluate| |#2|))))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))) (OR (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) 
(|HallBasis|) 
((|constructor| (NIL "Generate a basis for the free Lie algebra on \\spad{n} generators over a ring \\spad{R} with identity up to basic commutators of length \\spad{c} using the algorithm of \\spad{P.} Hall as given in Serre's book Lie Groups \\spad{--} Lie Algebras")) (|generate| (((|Vector| (|List| (|Integer|))) (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{generate(numberOfGens, maximalWeight)} generates a vector of elements of the form [left,weight,right] which represents a \\spad{P.} Hall basis element for the free lie algebra on \\spad{numberOfGens} generators. We only generate those basis elements of weight less than or equal to maximalWeight")) (|inHallBasis?| (((|Boolean|) (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{inHallBasis?(numberOfGens, leftCandidate, rightCandidate, left)} tests to see if a new element should be added to the \\spad{P.} Hall basis being constructed. The list \\spad{[leftCandidate,wt,rightCandidate]} is included in the basis if in the unique factorization of rightCandidate, we have left factor leftOfRight, and leftOfRight \\spad{<=} \\spad{leftCandidate}")) (|lfunc| (((|Integer|) (|Integer|) (|Integer|)) "\\spad{lfunc(d,n)} computes the rank of the \\spad{n}th factor in the lower central series of the free d-generated free Lie algebra; This rank is \\spad{d} if \\spad{n} = 1 and binom(d,2) if \\spad{n} = 2"))) 
NIL 
NIL 
(|HomogeneousDistributedMultivariatePolynomial| |vl| R) 
((|constructor| (NIL "This type supports distributed multivariate polynomials whose variables are from a user specified list of symbols. The coefficient ring may be non commutative, but the variables are assumed to commute. The term ordering is total degree ordering refined by reverse lexicographic ordering with respect to the position that the variables appear in the list of variables parameter.")) (|reorder| (($ $ (|List| (|Integer|))) "\\spad{reorder(p, perm)} applies the permutation perm to the variables in a polynomial and returns the new correctly ordered polynomial"))) 
(((|commutative| "*") |has| |#2| (|CommutativeRing|)) (|noZeroDivisors| |has| |#2| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#2| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#2| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Field|))) (OR (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasAttribute| |#2| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))))) 
(|HomogeneousDirectProduct| |dim| S) 
((|constructor| (NIL "This type represents the finite direct or cartesian product of an underlying ordered component type. The vectors are ordered first by the sum of their components, and then refined using a reverse lexicographic ordering. This type is a suitable third argument for \\spadtype{GeneralDistributedMultivariatePolynomial}."))) 
((|rightUnitary| |has| |#2| (|Ring|)) (|leftUnitary| |has| |#2| (|Ring|)) (|unitsKnown| |has| |#2| (ATTRIBUTE |unitsKnown|)) ((|commutative| "*") |has| |#2| (|CommutativeRing|)) (|finiteAggregate| . T)) 
((|HasCategory| |#2| (QUOTE (|SetCategory|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedRing|))) (OR (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedRing|)))) (|HasCategory| |#2| (QUOTE (|Monoid|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|Field|)))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (|HasCategory| |#2| (QUOTE (|Finite|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (|HasAttribute| |#2| (QUOTE |unitsKnown|)) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Finite|))) (|HasCategory| |#2| (QUOTE (|Monoid|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedRing|))) (|HasCategory| |#2| (QUOTE (|Ring|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Field|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Finite|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Field|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Finite|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|Field|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|Finite|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))))) 
(|Heap| S) 
((|constructor| (NIL "Heap implemented in a flexible array to allow for insertions")) (|member?| (((|Boolean|) |#1| $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} member?(3,a)")) (|members| (((|List| |#1|) $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} members a")) (|parts| (((|List| |#1|) $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} parts a")) (|#| (((|NonNegativeInteger|) $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} \\#a")) (|count| (((|NonNegativeInteger|) |#1| $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} count(4,a)") (((|NonNegativeInteger|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} count(x+->(x>2),a)")) (|any?| (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} any?(x+->(x=4),a)")) (|every?| (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} every?(x+->(x=4),a)")) (~= (((|Boolean|) $ $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} b:=copy a \\spad{X} (a~=b)")) (= (((|Boolean|) $ $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} b:Heap INT:= heap [1,2,3,4,5] \\spad{X} (a=b)@Boolean")) (|coerce| (((|OutputForm|) $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} coerce a")) (|hash| (((|SingleInteger|) $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} hash a")) (|latex| (((|String|) $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} latex a")) (|map!| (($ (|Mapping| |#1| |#1|) $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} map!(x+->x+10,a) \\spad{X} a")) (|size?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} size?(a,5)")) (|more?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} more?(a,9)")) (|less?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} less?(a,9)")) (|sample| (($) "\\blankline \\spad{X} sample()$Heap(INT)")) (|merge!| (($ $ $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} b:Heap INT:= heap [6,7,8,9,10] \\spad{X} merge!(a,b) \\spad{X} a \\spad{X} \\spad{b}")) (|merge| (($ $ $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} b:Heap INT:= heap [6,7,8,9,10] \\spad{X} merge(a,b)")) (|max| ((|#1| $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} max a")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} map(x+->x+10,a) \\spad{X} a")) (|inspect| ((|#1| $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} inspect a")) (|insert!| (($ |#1| $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} insert!(8,a) \\spad{X} a")) (|extract!| ((|#1| $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} extract! a \\spad{X} a")) (|eq?| (((|Boolean|) $ $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} b:=copy a \\spad{X} eq?(a,b)")) (|empty| (($) "\\blankline \\spad{X} b:=empty()$(Heap INT)")) (|empty?| (((|Boolean|) $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} empty? a")) (|copy| (($ $) "\\blankline \\spad{X} a:Heap INT:= heap [1,2,3,4,5] \\spad{X} copy a")) (|bag| (($ (|List| |#1|)) "\\blankline \\spad{X} bag([1,2,3,4,5])$Heap(INT)")) (|heap| (($ (|List| |#1|)) "\\indented{1}{heap(ls) creates a heap of elements consisting of the} \\indented{1}{elements of ls.} \\blankline \\spad{E} i:Heap INT \\spad{:=} heap [1,6,3,7,5,2,4]"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|HyperellipticFiniteDivisor| F UP UPUP R) 
((|constructor| (NIL "This domains implements finite rational divisors on an hyperelliptic curve, that is finite formal sums SUM(n * \\spad{P)} where the \\spad{n's} are integers and the \\spad{P's} are finite rational points on the curve. The equation of the curve must be \\spad{y^2} = f(x) and \\spad{f} must have odd degree."))) 
NIL 
NIL 
(|HeuGcd| BP) 
((|constructor| (NIL "This package provides the functions for the heuristic integer gcd. Geddes's algorithm,for univariate polynomials with integer coefficients")) (|lintgcd| (((|Integer|) (|List| (|Integer|))) "\\spad{lintgcd([a1,..,ak])} = \\spad{gcd} of a list of integers")) (|content| (((|List| (|Integer|)) (|List| |#1|)) "\\spad{content([f1,..,fk])} = content of a list of univariate polynonials")) (|gcdcofactprim| (((|List| |#1|) (|List| |#1|)) "\\spad{gcdcofactprim([f1,..fk])} = \\spad{gcd} and cofactors of \\spad{k} primitive polynomials.")) (|gcdcofact| (((|List| |#1|) (|List| |#1|)) "\\spad{gcdcofact([f1,..fk])} = \\spad{gcd} and cofactors of \\spad{k} univariate polynomials.")) (|gcdprim| ((|#1| (|List| |#1|)) "\\spad{gcdprim([f1,..,fk])} = \\spad{gcd} of \\spad{k} PRIMITIVE univariate polynomials")) (|gcd| ((|#1| (|List| |#1|)) "\\indented{1}{gcd([f1,..,fk]) = \\spad{gcd} of the polynomials fi.} \\blankline \\spad{X} gcd([671*671*x^2-1,671*671*x^2+2*671*x+1]) \\spad{X} gcd([7*x^2+1,(7*x^2+1)^2])"))) 
NIL 
NIL 
(|HexadecimalExpansion|) 
((|constructor| (NIL "This domain allows rational numbers to be presented as repeating hexadecimal expansions.")) (|hex| (($ (|Fraction| (|Integer|))) "\\spad{hex(r)} converts a rational number to a hexadecimal expansion.")) (|fractionPart| (((|Fraction| (|Integer|)) $) "\\spad{fractionPart(h)} returns the fractional part of a hexadecimal expansion.")) (|coerce| (((|RadixExpansion| 16) $) "\\spad{coerce(h)} converts a hexadecimal expansion to a radix expansion with base 16.") (((|Fraction| (|Integer|)) $) "\\spad{coerce(h)} converts a hexadecimal expansion to a rational number."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|Integer|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| (|Integer|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| (|Integer|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Integer|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Integer|) (QUOTE (|RealConstant|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|Integer|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|StepThrough|))) (|HasCategory| (|Integer|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| (|Integer|) (QUOTE (|DifferentialRing|))) (|HasCategory| (|Integer|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |Eltable|) (QUOTE (|Integer|)) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|Integer|) (QUOTE (|IntegerNumberSystem|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (OR (|HasCategory| (|Integer|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Integer|) (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Integer|) (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| (|Integer|) (QUOTE (|CharacteristicNonZero|))))) 
(|HomogeneousAggregate&| A S) 
((|constructor| (NIL "A homogeneous aggregate is an aggregate of elements all of the same type. In the current system, all aggregates are homogeneous. Two attributes characterize classes of aggregates. Aggregates from domains with attribute \\spadatt{finiteAggregate} have a finite number of members. Those with attribute \\spadatt{shallowlyMutable} allow an element to be modified or updated without changing its overall value.")) (|member?| (((|Boolean|) |#2| $) "\\spad{member?(x,u)} tests if \\spad{x} is a member of u. For collections, \\axiom{member?(x,u) = reduce(or,[x=y for \\spad{y} in u],false)}.")) (|members| (((|List| |#2|) $) "\\spad{members(u)} returns a list of the consecutive elements of u. For collections, \\axiom{parts([x,y,...,z]) = (x,y,...,z)}.")) (|parts| (((|List| |#2|) $) "\\spad{parts(u)} returns a list of the consecutive elements of u. For collections, \\axiom{parts([x,y,...,z]) = (x,y,...,z)}.")) (|count| (((|NonNegativeInteger|) |#2| $) "\\spad{count(x,u)} returns the number of occurrences of \\spad{x} in u. For collections, \\axiom{count(x,u) = reduce(+,[x=y for \\spad{y} in u],0)}.") (((|NonNegativeInteger|) (|Mapping| (|Boolean|) |#2|) $) "\\spad{count(p,u)} returns the number of elements \\spad{x} in \\spad{u} such that \\axiom{p(x)} is true. For collections, \\axiom{count(p,u) = \\spad{reduce(+,[1} for \\spad{x} in \\spad{u} | p(x)],0)}.")) (|every?| (((|Boolean|) (|Mapping| (|Boolean|) |#2|) $) "\\spad{every?(f,u)} tests if p(x) is \\spad{true} for all elements \\spad{x} of u. Note that for collections, \\axiom{every?(p,u) = reduce(and,map(f,u),true,false)}.")) (|any?| (((|Boolean|) (|Mapping| (|Boolean|) |#2|) $) "\\spad{any?(p,u)} tests if \\axiom{p(x)} is \\spad{true} for any element \\spad{x} of u. Note that for collections, \\axiom{any?(p,u) = reduce(or,map(f,u),false,true)}.")) (|map!| (($ (|Mapping| |#2| |#2|) $) "\\spad{map!(f,u)} destructively replaces each element \\spad{x} of \\spad{u} by \\axiom{f(x)}.")) (|map| (($ (|Mapping| |#2| |#2|) $) "\\spad{map(f,u)} returns a copy of \\spad{u} with each element \\spad{x} replaced by f(x). For collections, \\axiom{map(f,u) = [f(x) for \\spad{x} in u]}."))) 
NIL 
((|HasAttribute| |#1| (QUOTE |finiteAggregate|)) (|HasAttribute| |#1| (QUOTE |shallowlyMutable|)) (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) 
(|HomogeneousAggregate| S) 
((|constructor| (NIL "A homogeneous aggregate is an aggregate of elements all of the same type. In the current system, all aggregates are homogeneous. Two attributes characterize classes of aggregates. Aggregates from domains with attribute \\spadatt{finiteAggregate} have a finite number of members. Those with attribute \\spadatt{shallowlyMutable} allow an element to be modified or updated without changing its overall value.")) (|member?| (((|Boolean|) |#1| $) "\\spad{member?(x,u)} tests if \\spad{x} is a member of u. For collections, \\axiom{member?(x,u) = reduce(or,[x=y for \\spad{y} in u],false)}.")) (|members| (((|List| |#1|) $) "\\spad{members(u)} returns a list of the consecutive elements of u. For collections, \\axiom{parts([x,y,...,z]) = (x,y,...,z)}.")) (|parts| (((|List| |#1|) $) "\\spad{parts(u)} returns a list of the consecutive elements of u. For collections, \\axiom{parts([x,y,...,z]) = (x,y,...,z)}.")) (|count| (((|NonNegativeInteger|) |#1| $) "\\spad{count(x,u)} returns the number of occurrences of \\spad{x} in u. For collections, \\axiom{count(x,u) = reduce(+,[x=y for \\spad{y} in u],0)}.") (((|NonNegativeInteger|) (|Mapping| (|Boolean|) |#1|) $) "\\spad{count(p,u)} returns the number of elements \\spad{x} in \\spad{u} such that \\axiom{p(x)} is true. For collections, \\axiom{count(p,u) = \\spad{reduce(+,[1} for \\spad{x} in \\spad{u} | p(x)],0)}.")) (|every?| (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) "\\spad{every?(f,u)} tests if p(x) is \\spad{true} for all elements \\spad{x} of u. Note that for collections, \\axiom{every?(p,u) = reduce(and,map(f,u),true,false)}.")) (|any?| (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) "\\spad{any?(p,u)} tests if \\axiom{p(x)} is \\spad{true} for any element \\spad{x} of u. Note that for collections, \\axiom{any?(p,u) = reduce(or,map(f,u),false,true)}.")) (|map!| (($ (|Mapping| |#1| |#1|) $) "\\spad{map!(f,u)} destructively replaces each element \\spad{x} of \\spad{u} by \\axiom{f(x)}.")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\spad{map(f,u)} returns a copy of \\spad{u} with each element \\spad{x} replaced by f(x). For collections, \\axiom{map(f,u) = [f(x) for \\spad{x} in u]}."))) 
((|nil| . T)) 
NIL 
(|HTMLFormat|) 
((|constructor| (NIL "HtmlFormat provides a coercion from OutputForm to html.")) (|display| (((|Void|) (|String|)) "\\indented{1}{display(o) prints the string returned by coerce.} \\blankline \\spad{X} display(coerce(sqrt(3+x)::OutputForm)$HTMLFORM)$HTMLFORM")) (|exprex| (((|String|) (|OutputForm|)) "\\indented{1}{exprex(o) coverts \\spadtype{OutputForm} to \\spadtype{String}} \\blankline \\spad{X} exprex(sqrt(3+x)::OutputForm)$HTMLFORM")) (|coerceL| (((|String|) (|OutputForm|)) "\\indented{1}{coerceL(o) changes \\spad{o} in the standard output format to html} \\indented{1}{format and displays result as one long string.} \\blankline \\spad{X} coerceL(sqrt(3+x)::OutputForm)$HTMLFORM")) (|coerceS| (((|String|) (|OutputForm|)) "\\indented{1}{coerceS(o) changes \\spad{o} in the standard output format to html} \\indented{1}{format and displays formatted result.} \\blankline \\spad{X} coerceS(sqrt(3+x)::OutputForm)$HTMLFORM")) (|coerce| (((|String|) (|OutputForm|)) "\\indented{1}{coerce(o) changes \\spad{o} in the standard output format to html format.} \\blankline \\spad{X} coerce(sqrt(3+x)::OutputForm)$HTMLFORM"))) 
NIL 
NIL 
(|HyperbolicFunctionCategory&| S) 
((|constructor| (NIL "\\indented{1}{Date Last Updated: 14 May 1991} Category for the hyperbolic trigonometric functions.")) (|tanh| (($ $) "\\spad{tanh(x)} returns the hyperbolic tangent of \\spad{x.}")) (|sinh| (($ $) "\\spad{sinh(x)} returns the hyperbolic sine of \\spad{x.}")) (|sech| (($ $) "\\spad{sech(x)} returns the hyperbolic secant of \\spad{x.}")) (|csch| (($ $) "\\spad{csch(x)} returns the hyperbolic cosecant of \\spad{x.}")) (|coth| (($ $) "\\spad{coth(x)} returns the hyperbolic cotangent of \\spad{x.}")) (|cosh| (($ $) "\\spad{cosh(x)} returns the hyperbolic cosine of \\spad{x.}"))) 
NIL 
NIL 
(|HyperbolicFunctionCategory|) 
((|constructor| (NIL "\\indented{1}{Date Last Updated: 14 May 1991} Category for the hyperbolic trigonometric functions.")) (|tanh| (($ $) "\\spad{tanh(x)} returns the hyperbolic tangent of \\spad{x.}")) (|sinh| (($ $) "\\spad{sinh(x)} returns the hyperbolic sine of \\spad{x.}")) (|sech| (($ $) "\\spad{sech(x)} returns the hyperbolic secant of \\spad{x.}")) (|csch| (($ $) "\\spad{csch(x)} returns the hyperbolic cosecant of \\spad{x.}")) (|coth| (($ $) "\\spad{coth(x)} returns the hyperbolic cotangent of \\spad{x.}")) (|cosh| (($ $) "\\spad{cosh(x)} returns the hyperbolic cosine of \\spad{x.}"))) 
NIL 
NIL 
(|InnerAlgFactor| F UP |AlExt| |AlPol|) 
((|constructor| (NIL "Factorisation in a simple algebraic extension Factorization of univariate polynomials with coefficients in an algebraic extension of a field over which we can factor UP's.")) (|factor| (((|Factored| |#4|) |#4| (|Mapping| (|Factored| |#2|) |#2|)) "\\spad{factor(p, \\spad{f)}} returns a prime factorisation of \\spad{p;} \\spad{f} is a factorisation map for elements of UP."))) 
NIL 
NIL 
(|InnerAlgebraicNumber|) 
((|constructor| (NIL "Algebraic closure of the rational numbers.")) (|norm| (($ $ (|List| (|Kernel| $))) "\\spad{norm(f,l)} computes the norm of the algebraic number \\spad{f} with respect to the extension generated by kernels \\spad{l}") (($ $ (|Kernel| $)) "\\spad{norm(f,k)} computes the norm of the algebraic number \\spad{f} with respect to the extension generated by kernel \\spad{k}") (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|List| (|Kernel| $))) "\\spad{norm(p,l)} computes the norm of the polynomial \\spad{p} with respect to the extension generated by kernels \\spad{l}") (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|Kernel| $)) "\\spad{norm(p,k)} computes the norm of the polynomial \\spad{p} with respect to the extension generated by kernel \\spad{k}")) (|trueEqual| (((|Boolean|) $ $) "\\spad{trueEqual(x,y)} tries to determine if the two numbers are equal")) (|reduce| (($ $) "\\spad{reduce(f)} simplifies all the unreduced algebraic numbers present in \\spad{f} by applying their defining relations.")) (|denom| (((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $) "\\spad{denom(f)} returns the denominator of \\spad{f} viewed as a polynomial in the kernels over \\spad{Z.}")) (|numer| (((|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $)) $) "\\spad{numer(f)} returns the numerator of \\spad{f} viewed as a polynomial in the kernels over \\spad{Z.}")) (|coerce| (($ (|SparseMultivariatePolynomial| (|Integer|) (|Kernel| $))) "\\spad{coerce(p)} returns \\spad{p} viewed as an algebraic number."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| $ (QUOTE (|Ring|))) (|HasCategory| $ (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) 
(|IndexedOneDimensionalArray| S |mn|) 
((|constructor| (NIL "This is the basic one dimensional array data type."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|IndexedTwoDimensionalArray| R |mnRow| |mnCol|) 
((|constructor| (NIL "This domain implements two dimensional arrays"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|ChineseRemainderToolsForIntegralBases| K R UP) 
((|constructor| (NIL "This package has no description")) (|chineseRemainder| (((|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|) (|:| |basisInv| (|Matrix| |#2|))) (|List| |#3|) (|List| (|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|) (|:| |basisInv| (|Matrix| |#2|)))) (|NonNegativeInteger|)) "\\spad{chineseRemainder(lu,lr,n)} \\undocumented")) (|listConjugateBases| (((|List| (|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|) (|:| |basisInv| (|Matrix| |#2|)))) (|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|) (|:| |basisInv| (|Matrix| |#2|))) (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{listConjugateBases(bas,q,n)} returns the list \\spad{[bas,bas^Frob,bas^(Frob^2),...bas^(Frob^(n-1))]}, where \\spad{Frob} raises the coefficients of all polynomials appearing in the basis \\spad{bas} to the \\spad{q}th power.")) (|factorList| (((|List| (|SparseUnivariatePolynomial| |#1|)) |#1| (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{factorList(k,n,m,j)} \\undocumented"))) 
NIL 
NIL 
(|IntegralBasisTools| R UP F) 
((|constructor| (NIL "This package contains functions used in the packages FunctionFieldIntegralBasis and NumberFieldIntegralBasis.")) (|moduleSum| (((|Record| (|:| |basis| (|Matrix| |#1|)) (|:| |basisDen| |#1|) (|:| |basisInv| (|Matrix| |#1|))) (|Record| (|:| |basis| (|Matrix| |#1|)) (|:| |basisDen| |#1|) (|:| |basisInv| (|Matrix| |#1|))) (|Record| (|:| |basis| (|Matrix| |#1|)) (|:| |basisDen| |#1|) (|:| |basisInv| (|Matrix| |#1|)))) "\\spad{moduleSum(m1,m2)} returns the sum of two modules in the framed algebra \\spad{F}. Each module \\spad{mi} is represented as follows: \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn} and \\spad{mi} is a record \\spad{[basis,basisDen,basisInv]}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then a basis \\spad{v1,...,vn} for \\spad{mi} is given by \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of 'basis' contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}.")) (|idealiserMatrix| (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|)) "\\spad{idealiserMatrix(m1, m2)} returns the matrix representing the linear conditions on the Ring associatied with an ideal defined by \\spad{m1} and \\spad{m2.}")) (|idealiser| (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) |#1|) "\\spad{idealiser(m1,m2,d)} computes the order of an ideal defined by \\spad{m1} and \\spad{m2} where \\spad{d} is the known part of the denominator") (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|)) "\\spad{idealiser(m1,m2)} computes the order of an ideal defined by \\spad{m1} and \\spad{m2}")) (|leastPower| (((|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{leastPower(p,n)} returns e, where \\spad{e} is the smallest integer such that \\spad{p **e \\spad{>=} \\spad{n}}")) (|divideIfCan!| ((|#1| (|Matrix| |#1|) (|Matrix| |#1|) |#1| (|Integer|)) "\\spad{divideIfCan!(matrix,matrixOut,prime,n)} attempts to divide the entries of \\spad{matrix} by \\spad{prime} and store the result in \\spad{matrixOut}. If it is successful, 1 is returned and if not, \\spad{prime} is returned. Here both \\spad{matrix} and \\spad{matrixOut} are \\spad{n}-by-\\spad{n} upper triangular matrices.")) (|matrixGcd| ((|#1| (|Matrix| |#1|) |#1| (|NonNegativeInteger|)) "\\spad{matrixGcd(mat,sing,n)} is \\spad{gcd(sing,g)} where \\spad{g} is the \\spad{gcd} of the entries of the \\spad{n}-by-\\spad{n} upper-triangular matrix \\spad{mat}.")) (|diagonalProduct| ((|#1| (|Matrix| |#1|)) "\\spad{diagonalProduct(m)} returns the product of the elements on the diagonal of the matrix \\spad{m}")) (|squareFree| (((|Factored| $) $) "\\spad{squareFree(x)} returns a square-free factorisation of \\spad{x}"))) 
NIL 
NIL 
(|IndexedBits| |mn|) 
((|constructor| (NIL "\\spadtype{IndexedBits} is a domain to compactly represent large quantities of Boolean data.")) (|And| (($ $ $) "\\spad{And(n,m)} returns the bit-by-bit logical And of \\spad{n} and \\spad{m.}")) (|Or| (($ $ $) "\\spad{Or(n,m)} returns the bit-by-bit logical Or of \\spad{n} and \\spad{m.}")) (|Not| (($ $) "\\spad{Not(n)} returns the bit-by-bit logical Not of \\spad{n.}"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| (|Boolean|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Boolean|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Boolean|) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Boolean|) (LIST (QUOTE |Evalable|) (QUOTE (|Boolean|)))) (|HasCategory| (|Boolean|) (QUOTE (|SetCategory|))))) 
(|IntegralBasisPolynomialTools| K R UP L) 
((|constructor| (NIL "IntegralBasisPolynomialTools provides functions for mapping functions on the coefficients of univariate and bivariate polynomials.")) (|mapBivariate| (((|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#4|)) (|Mapping| |#4| |#1|) |#3|) "\\spad{mapBivariate(f,p(x,y))} applies the function \\spad{f} to the coefficients of \\spad{p(x,y)}.")) (|mapMatrixIfCan| (((|Union| (|Matrix| |#2|) "failed") (|Mapping| (|Union| |#1| "failed") |#4|) (|Matrix| (|SparseUnivariatePolynomial| |#4|))) "\\spad{mapMatrixIfCan(f,mat)} applies the function \\spad{f} to the coefficients of the entries of \\spad{mat} if possible, and returns \\spad{\"failed\"} otherwise.")) (|mapUnivariateIfCan| (((|Union| |#2| "failed") (|Mapping| (|Union| |#1| "failed") |#4|) (|SparseUnivariatePolynomial| |#4|)) "\\spad{mapUnivariateIfCan(f,p(x))} applies the function \\spad{f} to the coefficients of \\spad{p(x)}, if possible, and returns \\spad{\"failed\"} otherwise.")) (|mapUnivariate| (((|SparseUnivariatePolynomial| |#4|) (|Mapping| |#4| |#1|) |#2|) "\\spad{mapUnivariate(f,p(x))} applies the function \\spad{f} to the coefficients of \\spad{p(x)}.") ((|#2| (|Mapping| |#1| |#4|) (|SparseUnivariatePolynomial| |#4|)) "\\spad{mapUnivariate(f,p(x))} applies the function \\spad{f} to the coefficients of \\spad{p(x)}."))) 
NIL 
NIL 
(|IndexCard|) 
((|constructor| (NIL "This domain implements a container of information about the AXIOM library")) (|coerce| (($ (|String|)) "\\spad{coerce(s)} converts \\axiom{s} into an \\axiom{IndexCard}. Warning: if \\axiom{s} is not of the right format then an error will occur")) (|fullDisplay| (((|Void|) $) "\\spad{fullDisplay(ic)} prints all of the information contained in \\axiom{ic}.")) (|display| (((|Void|) $) "\\spad{display(ic)} prints a summary of information contained in \\axiom{ic}.")) (|elt| (((|String|) $ (|Symbol|)) "\\spad{elt(ic,s)} selects a particular field from \\axiom{ic}. Valid fields are \\axiom{name, nargs, exposed, type, abbreviation, kind, origin, params, condition, doc}."))) 
NIL 
NIL 
(|InnerCommonDenominator| R Q A B) 
((|constructor| (NIL "InnerCommonDenominator provides functions to compute the common denominator of a finite linear aggregate of elements of the quotient field of an integral domain.")) (|splitDenominator| (((|Record| (|:| |num| |#3|) (|:| |den| |#1|)) |#4|) "\\spad{splitDenominator([q1,...,qn])} returns \\spad{[[p1,...,pn], \\spad{d]}} such that \\spad{qi = pi/d} and \\spad{d} is a common denominator for the qi's.")) (|clearDenominator| ((|#3| |#4|) "\\spad{clearDenominator([q1,...,qn])} returns \\spad{[p1,...,pn]} such that \\spad{qi = pi/d} where \\spad{d} is a common denominator for the qi's.")) (|commonDenominator| ((|#1| |#4|) "\\spad{commonDenominator([q1,...,qn])} returns a common denominator \\spad{d} for q1,...,qn."))) 
NIL 
NIL 
(|InfClsPt| K |symb| BLMET) 
((|constructor| (NIL "This domain is part of the PAFF package")) (|fullOutput| (((|Boolean|)) "\\spad{fullOutput returns} the value of the flag set by fullOutput(b).") (((|Boolean|) (|Boolean|)) "\\spad{fullOutput(b)} sets a flag such that when true, a coerce to OutputForm yields the full output of \\spad{tr,} otherwise encode(tr) is output (see encode function). The default is false.")) (|fullOut| (((|OutputForm|) $) "\\spad{fullOut(tr)} yields a full output of \\spad{tr} (see function fullOutput)."))) 
NIL 
NIL 
(|PolynomialIdeals| F |Expon| |VarSet| |DPoly|) 
((|constructor| (NIL "This domain represents polynomial ideals with coefficients in any field and supports the basic ideal operations, including intersection sum and quotient. An ideal is represented by a list of polynomials (the generators of the ideal) and a boolean that is \\spad{true} if the generators are a Groebner basis. The algorithms used are based on Groebner basis computations. The ordering is determined by the datatype of the input polynomials. Users may use refinements of total degree orderings.")) (|relationsIdeal| (((|SuchThat| (|List| (|Polynomial| |#1|)) (|List| (|Equation| (|Polynomial| |#1|)))) (|List| |#4|)) "\\spad{relationsIdeal(polyList)} returns the ideal of relations among the polynomials in polyList.")) (|saturate| (($ $ |#4| (|List| |#3|)) "\\spad{saturate(I,f,lvar)} is the saturation with respect to the prime principal ideal which is generated by \\spad{f} in the polynomial ring \\spad{F[lvar]}.") (($ $ |#4|) "\\spad{saturate(I,f)} is the saturation of the ideal \\spad{I} with respect to the multiplicative set generated by the polynomial \\spad{f.}")) (|coerce| (($ (|List| |#4|)) "\\spad{coerce(polyList)} converts the list of polynomials \\spad{polyList} to an ideal.")) (|generators| (((|List| |#4|) $) "\\spad{generators(I)} returns a list of generators for the ideal I.")) (|groebner?| (((|Boolean|) $) "\\spad{groebner?(I)} tests if the generators of the ideal \\spad{I} are a Groebner basis.")) (|groebnerIdeal| (($ (|List| |#4|)) "\\spad{groebnerIdeal(polyList)} constructs the ideal generated by the list of polynomials \\spad{polyList} which are assumed to be a Groebner basis. Note: this operation avoids a Groebner basis computation.")) (|ideal| (($ (|List| |#4|)) "\\spad{ideal(polyList)} constructs the ideal generated by the list of polynomials polyList.")) (|leadingIdeal| (($ $) "\\spad{leadingIdeal(I)} is the ideal generated by the leading terms of the elements of the ideal I.")) (|dimension| (((|Integer|) $) "\\spad{dimension(I)} gives the dimension of the ideal I. in the ring \\spad{F[lvar]}, where lvar are the variables appearing in \\spad{I}") (((|Integer|) $ (|List| |#3|)) "\\spad{dimension(I,lvar)} gives the dimension of the ideal I, in the ring \\spad{F[lvar]}")) (|backOldPos| (($ (|Record| (|:| |mval| (|Matrix| |#1|)) (|:| |invmval| (|Matrix| |#1|)) (|:| |genIdeal| $))) "\\spad{backOldPos(genPos)} takes the result produced by generalPosition from PolynomialIdeals and performs the inverse transformation, returning the original ideal \\spad{backOldPos(generalPosition(I,listvar))} = I.")) (|generalPosition| (((|Record| (|:| |mval| (|Matrix| |#1|)) (|:| |invmval| (|Matrix| |#1|)) (|:| |genIdeal| $)) $ (|List| |#3|)) "\\spad{generalPosition(I,listvar)} perform a random linear transformation on the variables in \\spad{listvar} and returns the transformed ideal along with the change of basis matrix.")) (|groebner| (($ $) "\\spad{groebner(I)} returns a set of generators of \\spad{I} that are a Groebner basis for I.")) (|quotient| (($ $ |#4|) "\\spad{quotient(I,f)} computes the quotient of the ideal \\spad{I} by the principal ideal generated by the polynomial \\spad{f,} \\spad{(I:(f))}.") (($ $ $) "\\spad{quotient(I,J)} computes the quotient of the ideals \\spad{I} and \\spad{J,} \\spad{(I:J)}.")) (|intersect| (($ (|List| $)) "\\spad{intersect(LI)} computes the intersection of the list of ideals LI.") (($ $ $) "\\spad{intersect(I,J)} computes the intersection of the ideals \\spad{I} and \\spad{J.}")) (|zeroDim?| (((|Boolean|) $) "\\spad{zeroDim?(I)} tests if the ideal \\spad{I} is zero dimensional, \\spadignore{i.e.} all its associated primes are maximal, in the ring \\spad{F[lvar]}, where lvar are the variables appearing in \\spad{I}") (((|Boolean|) $ (|List| |#3|)) "\\spad{zeroDim?(I,lvar)} tests if the ideal \\spad{I} is zero dimensional, \\spadignore{i.e.} all its associated primes are maximal, in the ring \\spad{F[lvar]}")) (|inRadical?| (((|Boolean|) |#4| $) "\\spad{inRadical?(f,I)} tests if some power of the polynomial \\spad{f} belongs to the ideal I.")) (|in?| (((|Boolean|) $ $) "\\spad{in?(I,J)} tests if the ideal \\spad{I} is contained in the ideal \\spad{J.}")) (|element?| (((|Boolean|) |#4| $) "\\spad{element?(f,I)} tests whether the polynomial \\spad{f} belongs to the ideal I.")) (|zero?| (((|Boolean|) $) "\\spad{zero?(I)} tests whether the ideal \\spad{I} is the zero ideal")) (|one?| (((|Boolean|) $) "\\spad{one?(I)} tests whether the ideal \\spad{I} is the unit ideal, \\spadignore{i.e.} contains 1.")) (+ (($ $ $) "\\spad{I+J} computes the ideal generated by the union of \\spad{I} and \\spad{J.}")) (** (($ $ (|NonNegativeInteger|)) "\\spad{I**n} computes the \\spad{n}th power of the ideal I.")) (* (($ $ $) "\\spad{I*J} computes the product of the ideal \\spad{I} and \\spad{J.}"))) 
NIL 
((|HasCategory| |#3| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|Symbol|))))) 
(|IdealDecompositionPackage| |vl| |nv|) 
((|constructor| (NIL "This package provides functions for the primary decomposition of polynomial ideals over the rational numbers. The ideals are members of the \\spadtype{PolynomialIdeals} domain, and the polynomial generators are required to be from the \\spadtype{DistributedMultivariatePolynomial} domain.")) (|contract| (((|PolynomialIdeals| (|Fraction| (|Integer|)) (|DirectProduct| |#2| (|NonNegativeInteger|)) (|OrderedVariableList| |#1|) (|DistributedMultivariatePolynomial| |#1| (|Fraction| (|Integer|)))) (|PolynomialIdeals| (|Fraction| (|Integer|)) (|DirectProduct| |#2| (|NonNegativeInteger|)) (|OrderedVariableList| |#1|) (|DistributedMultivariatePolynomial| |#1| (|Fraction| (|Integer|)))) (|List| (|OrderedVariableList| |#1|))) "\\spad{contract(I,lvar)} contracts the ideal \\spad{I} to the polynomial ring \\spad{F[lvar]}.")) (|primaryDecomp| (((|List| (|PolynomialIdeals| (|Fraction| (|Integer|)) (|DirectProduct| |#2| (|NonNegativeInteger|)) (|OrderedVariableList| |#1|) (|DistributedMultivariatePolynomial| |#1| (|Fraction| (|Integer|))))) (|PolynomialIdeals| (|Fraction| (|Integer|)) (|DirectProduct| |#2| (|NonNegativeInteger|)) (|OrderedVariableList| |#1|) (|DistributedMultivariatePolynomial| |#1| (|Fraction| (|Integer|))))) "\\spad{primaryDecomp(I)} returns a list of primary ideals such that their intersection is the ideal I.")) (|radical| (((|PolynomialIdeals| (|Fraction| (|Integer|)) (|DirectProduct| |#2| (|NonNegativeInteger|)) (|OrderedVariableList| |#1|) (|DistributedMultivariatePolynomial| |#1| (|Fraction| (|Integer|)))) (|PolynomialIdeals| (|Fraction| (|Integer|)) (|DirectProduct| |#2| (|NonNegativeInteger|)) (|OrderedVariableList| |#1|) (|DistributedMultivariatePolynomial| |#1| (|Fraction| (|Integer|))))) "\\spad{radical(I)} returns the radical of the ideal I.")) (|prime?| (((|Boolean|) (|PolynomialIdeals| (|Fraction| (|Integer|)) (|DirectProduct| |#2| (|NonNegativeInteger|)) (|OrderedVariableList| |#1|) (|DistributedMultivariatePolynomial| |#1| (|Fraction| (|Integer|))))) "\\spad{prime?(I)} tests if the ideal \\spad{I} is prime.")) (|zeroDimPrimary?| (((|Boolean|) (|PolynomialIdeals| (|Fraction| (|Integer|)) (|DirectProduct| |#2| (|NonNegativeInteger|)) (|OrderedVariableList| |#1|) (|DistributedMultivariatePolynomial| |#1| (|Fraction| (|Integer|))))) "\\spad{zeroDimPrimary?(I)} tests if the ideal \\spad{I} is 0-dimensional primary.")) (|zeroDimPrime?| (((|Boolean|) (|PolynomialIdeals| (|Fraction| (|Integer|)) (|DirectProduct| |#2| (|NonNegativeInteger|)) (|OrderedVariableList| |#1|) (|DistributedMultivariatePolynomial| |#1| (|Fraction| (|Integer|))))) "\\spad{zeroDimPrime?(I)} tests if the ideal \\spad{I} is a 0-dimensional prime."))) 
NIL 
NIL 
(|IndexedDirectProductAbelianGroup| A S) 
((|constructor| (NIL "Indexed direct products of abelian groups over an abelian group \\spad{A} of generators indexed by the ordered set \\spad{S.} All items have finite support: only non-zero terms are stored."))) 
NIL 
NIL 
(|IndexedDirectProductAbelianMonoid| A S) 
((|constructor| (NIL "Indexed direct products of abelian monoids over an abelian monoid \\spad{A} of generators indexed by the ordered set \\spad{S.} All items have finite support. Only non-zero terms are stored."))) 
NIL 
NIL 
(|IndexedDirectProductCategory| A S) 
((|constructor| (NIL "This category represents the direct product of some set with respect to an ordered indexing set.")) (|reductum| (($ $) "\\spad{reductum(z)} returns a new element created by removing the leading coefficient/support pair from the element \\spad{z.} Error: if \\spad{z} has no support.")) (|leadingSupport| ((|#2| $) "\\spad{leadingSupport(z)} returns the index of leading (with respect to the ordering on the indexing set) monomial of \\spad{z.} Error: if \\spad{z} has no support.")) (|leadingCoefficient| ((|#1| $) "\\spad{leadingCoefficient(z)} returns the coefficient of the leading (with respect to the ordering on the indexing set) monomial of \\spad{z.} Error: if \\spad{z} has no support.")) (|monomial| (($ |#1| |#2|) "\\spad{monomial(a,s)} constructs a direct product element with the \\spad{s} component set to \\spad{a}")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\spad{map(f,z)} returns the new element created by applying the function \\spad{f} to each component of the direct product element \\spad{z.}"))) 
NIL 
NIL 
(|IndexedDirectProductOrderedAbelianMonoid| A S) 
((|constructor| (NIL "Indexed direct products of ordered abelian monoids \\spad{A} of generators indexed by the ordered set \\spad{S.} The inherited order is lexicographical. All items have finite support: only non-zero terms are stored."))) 
NIL 
NIL 
(|IndexedDirectProductOrderedAbelianMonoidSup| A S) 
((|constructor| (NIL "Indexed direct products of ordered abelian monoid sups \\spad{A}, generators indexed by the ordered set \\spad{S.} All items have finite support: only non-zero terms are stored."))) 
NIL 
NIL 
(|IndexedDirectProductObject| A S) 
((|constructor| (NIL "Indexed direct products of objects over a set \\spad{A} of generators indexed by an ordered set \\spad{S.} All items have finite support."))) 
NIL 
NIL 
(|InnerEvalable&| S A B) 
((|constructor| (NIL "This category provides \\spadfun{eval} operations. A domain may belong to this category if it is possible to make ``evaluation'' substitutions. The difference between this and \\spadtype{Evalable} is that the operations in this category specify the substitution as a pair of arguments rather than as an equation.")) (|eval| (($ $ (|List| |#2|) (|List| |#3|)) "\\spad{eval(f, [x1,...,xn], [v1,...,vn])} replaces \\spad{xi} by \\spad{vi} in \\spad{f.}") (($ $ |#2| |#3|) "\\spad{eval(f, \\spad{x,} \\spad{v)}} replaces \\spad{x} by \\spad{v} in \\spad{f.}"))) 
NIL 
NIL 
(|InnerEvalable| A B) 
((|constructor| (NIL "This category provides \\spadfun{eval} operations. A domain may belong to this category if it is possible to make ``evaluation'' substitutions. The difference between this and \\spadtype{Evalable} is that the operations in this category specify the substitution as a pair of arguments rather than as an equation.")) (|eval| (($ $ (|List| |#1|) (|List| |#2|)) "\\spad{eval(f, [x1,...,xn], [v1,...,vn])} replaces \\spad{xi} by \\spad{vi} in \\spad{f.}") (($ $ |#1| |#2|) "\\spad{eval(f, \\spad{x,} \\spad{v)}} replaces \\spad{x} by \\spad{v} in \\spad{f.}"))) 
NIL 
NIL 
(|InnerFreeAbelianMonoid| S E |un|) 
((|constructor| (NIL "Internal implementation of a free abelian monoid on any set of generators"))) 
NIL 
((|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoid|)))) 
(|IndexedFlexibleArray| S |mn|) 
((|constructor| (NIL "A FlexibleArray is the notion of an array intended to allow for growth at the end only. Hence the following efficient operations\\br \\spad{append(x,a)} meaning append item \\spad{x} at the end of the array \\spad{a}\\br \\spad{delete(a,n)} meaning delete the last item from the array \\spad{a}\\br Flexible arrays support the other operations inherited from \\spadtype{ExtensibleLinearAggregate}. However, these are not efficient. Flexible arrays combine the \\spad{O(1)} access time property of arrays with growing and shrinking at the end in \\spad{O(1)} (average) time. This is done by using an ordinary array which may have zero or more empty slots at the end. When the array becomes full it is copied into a new larger (50% larger) array. Conversely, when the array becomes less than 1/2 full, it is copied into a smaller array. Flexible arrays provide for an efficient implementation of many data structures in particular heaps, stacks and sets.")) (|shrinkable| (((|Boolean|) (|Boolean|)) "\\indented{1}{shrinkable(b) sets the shrinkable attribute of flexible arrays to \\spad{b}} \\indented{1}{and returns the previous value} \\blankline \\spad{X} T1:=IndexedFlexibleArray(Integer,20) \\spad{X} \\spad{shrinkable(false)$T1}")) (|physicalLength!| (($ $ (|Integer|)) "\\indented{1}{physicalLength!(x,n) changes the physical length of \\spad{x} to be \\spad{n} and} \\indented{1}{returns the new array.} \\blankline \\spad{X} T1:=IndexedFlexibleArray(Integer,20) \\spad{X} t2:=flexibleArray([i for \\spad{i} in 1..10])$T1 \\spad{X} physicalLength!(t2,15)")) (|physicalLength| (((|NonNegativeInteger|) $) "\\indented{1}{physicalLength(x) returns the number of elements \\spad{x} can} \\indented{1}{accomodate before growing} \\blankline \\spad{X} T1:=IndexedFlexibleArray(Integer,20) \\spad{X} t2:=flexibleArray([i for \\spad{i} in 1..10])$T1 \\spad{X} physicalLength \\spad{t2}")) (|flexibleArray| (($ (|List| |#1|)) "\\indented{1}{flexibleArray(l) creates a flexible array from the list of elements \\spad{l}} \\blankline \\spad{X} T1:=IndexedFlexibleArray(Integer,20) \\spad{X} flexibleArray([i for \\spad{i} in 1..10])$T1"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|InnerFiniteField| |p| |n|) 
((|constructor| (NIL "InnerFiniteField(p,n) implements finite fields with \\spad{p**n} elements where \\spad{p} is assumed prime but does not check. For a version which checks that \\spad{p} is prime, see \\spadtype{FiniteField}."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|InnerPrimeField| |#1|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|InnerPrimeField| |#1|) (QUOTE (|Finite|))) (|HasCategory| (|InnerPrimeField| |#1|) (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| (|InnerPrimeField| |#1|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|InnerPrimeField| |#1|) (QUOTE (|Finite|))))) 
(|InnerIndexedTwoDimensionalArray| R |mnRow| |mnCol| |Row| |Col|) 
((|constructor| (NIL "There is no description for this domain"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|IndexedList| S |mn|) 
((|constructor| (NIL "\\spadtype{IndexedList} is a basic implementation of the functions in \\spadtype{ListAggregate}, often using functions in the underlying LISP system. The second parameter to the constructor (\\spad{mn}) is the beginning index of the list. That is, if \\spad{l} is a list, then \\spad{elt(l,mn)} is the first value. This constructor is probably best viewed as the implementation of singly-linked lists that are addressable by index rather than as a mere wrapper for LISP lists."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|InnerMatrixLinearAlgebraFunctions| R |Row| |Col| M) 
((|constructor| (NIL "\\spadtype{InnerMatrixLinearAlgebraFunctions} is an internal package which provides standard linear algebra functions on domains in \\spad{MatrixCategory}")) (|inverse| (((|Union| |#4| "failed") |#4|) "\\spad{inverse(m)} returns the inverse of the matrix \\spad{m.} If the matrix is not invertible, \"failed\" is returned. Error: if the matrix is not square.")) (|generalizedInverse| ((|#4| |#4|) "\\spad{generalizedInverse(m)} returns the generalized (Moore--Penrose) inverse of the matrix \\spad{m,} \\spadignore{i.e.} the matrix \\spad{h} such that m*h*m=h, h*m*h=m, \\spad{m*h} and \\spad{h*m} are both symmetric matrices.")) (|determinant| ((|#1| |#4|) "\\spad{determinant(m)} returns the determinant of the matrix \\spad{m.} an error message is returned if the matrix is not square.")) (|nullSpace| (((|List| |#3|) |#4|) "\\spad{nullSpace(m)} returns a basis for the null space of the matrix \\spad{m.}")) (|nullity| (((|NonNegativeInteger|) |#4|) "\\spad{nullity(m)} returns the mullity of the matrix \\spad{m.} This is the dimension of the null space of the matrix \\spad{m.}")) (|rank| (((|NonNegativeInteger|) |#4|) "\\spad{rank(m)} returns the rank of the matrix \\spad{m.}")) (|rowEchelon| ((|#4| |#4|) "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m.}"))) 
NIL 
((|HasAttribute| |#3| (QUOTE |shallowlyMutable|))) 
(|InnerMatrixQuotientFieldFunctions| R |Row| |Col| M QF |Row2| |Col2| M2) 
((|constructor| (NIL "\\spadtype{InnerMatrixQuotientFieldFunctions} provides functions on matrices over an integral domain which involve the quotient field of that integral domain. The functions rowEchelon and inverse return matrices with entries in the quotient field.")) (|nullSpace| (((|List| |#3|) |#4|) "\\spad{nullSpace(m)} returns a basis for the null space of the matrix \\spad{m.}")) (|inverse| (((|Union| |#8| "failed") |#4|) "\\spad{inverse(m)} returns the inverse of the matrix \\spad{m.} If the matrix is not invertible, \"failed\" is returned. Error: if the matrix is not square. Note that the result will have entries in the quotient field.")) (|rowEchelon| ((|#8| |#4|) "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m.} the result will have entries in the quotient field."))) 
NIL 
((|HasAttribute| |#7| (QUOTE |shallowlyMutable|))) 
(|IndexedMatrix| R |mnRow| |mnCol|) 
((|constructor| (NIL "An \\spad{IndexedMatrix} is a matrix where the minimal row and column indices are parameters of the type. The domains Row and Col are both IndexedVectors. The index of the 'first' row may be obtained by calling the function \\spadfun{minRowIndex}. The index of the 'first' column may be obtained by calling the function \\spadfun{minColIndex}. The index of the first element of a 'Row' is the same as the index of the first column in a matrix and vice versa."))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasAttribute| |#1| (QUOTE (|commutative| "*"))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|)))) 
(|InnerNormalBasisFieldFunctions| GF) 
((|constructor| (NIL "InnerNormalBasisFieldFunctions(GF) (unexposed): This package has functions used by every normal basis finite field extension domain.")) (|minimalPolynomial| (((|SparseUnivariatePolynomial| |#1|) (|Vector| |#1|)) "\\spad{minimalPolynomial(x)} \\undocumented{} See \\axiomFunFrom{minimalPolynomial}{FiniteAlgebraicExtensionField}")) (|normalElement| (((|Vector| |#1|) (|PositiveInteger|)) "\\spad{normalElement(n)} \\undocumented{} See \\axiomFunFrom{normalElement}{FiniteAlgebraicExtensionField}")) (|basis| (((|Vector| (|Vector| |#1|)) (|PositiveInteger|)) "\\spad{basis(n)} \\undocumented{} See \\axiomFunFrom{basis}{FiniteAlgebraicExtensionField}")) (|normal?| (((|Boolean|) (|Vector| |#1|)) "\\spad{normal?(x)} \\undocumented{} See \\axiomFunFrom{normal?}{FiniteAlgebraicExtensionField}")) (|lookup| (((|PositiveInteger|) (|Vector| |#1|)) "\\spad{lookup(x)} \\undocumented{} See \\axiomFunFrom{lookup}{Finite}")) (|inv| (((|Vector| |#1|) (|Vector| |#1|)) "\\spad{inv \\spad{x}} \\undocumented{} See \\axiomFunFrom{inv}{DivisionRing}")) (|trace| (((|Vector| |#1|) (|Vector| |#1|) (|PositiveInteger|)) "\\spad{trace(x,n)} \\undocumented{} See \\axiomFunFrom{trace}{FiniteAlgebraicExtensionField}")) (|norm| (((|Vector| |#1|) (|Vector| |#1|) (|PositiveInteger|)) "\\spad{norm(x,n)} \\undocumented{} See \\axiomFunFrom{norm}{FiniteAlgebraicExtensionField}")) (/ (((|Vector| |#1|) (|Vector| |#1|) (|Vector| |#1|)) "\\spad{x/y} \\undocumented{} See \\axiomFunFrom{/}{Field}")) (* (((|Vector| |#1|) (|Vector| |#1|) (|Vector| |#1|)) "\\spad{x*y} \\undocumented{} See \\axiomFunFrom{*}{SemiGroup}")) (** (((|Vector| |#1|) (|Vector| |#1|) (|Integer|)) "\\spad{x**n} \\undocumented{} See \\axiomFunFrom{**}{DivisionRing}")) (|qPot| (((|Vector| |#1|) (|Vector| |#1|) (|Integer|)) "\\spad{qPot(v,e)} computes \\spad{v**(q**e)}, interpreting \\spad{v} as an element of normal basis field, \\spad{q} the size of the ground field. This is done by a cyclic e-shift of the vector \\spad{v.}")) (|expPot| (((|Vector| |#1|) (|Vector| |#1|) (|SingleInteger|) (|SingleInteger|)) "\\spad{expPot(v,e,d)} returns the sum from \\spad{i = 0} to \\spad{e - 1} of \\spad{v**(q**i*d)}, interpreting \\spad{v} as an element of a normal basis field and where \\spad{q} is the size of the ground field. Note that for a description of the algorithm, see T.Itoh and S.Tsujii, \"A fast algorithm for computing multiplicative inverses in GF(2^m) using normal bases\", Information and Computation 78, pp.171-177, 1988.")) (|repSq| (((|Vector| |#1|) (|Vector| |#1|) (|NonNegativeInteger|)) "\\spad{repSq(v,e)} computes \\spad{v**e} by repeated squaring, interpreting \\spad{v} as an element of a normal basis field.")) (|dAndcExp| (((|Vector| |#1|) (|Vector| |#1|) (|NonNegativeInteger|) (|SingleInteger|)) "\\spad{dAndcExp(v,n,k)} computes \\spad{v**e} interpreting \\spad{v} as an element of normal basis field. A divide and conquer algorithm similar to the one from D.R.Stinson, \"Some observations on parallel Algorithms for fast exponentiation in GF(2^n)\", Siam \\spad{J.} Computation, Vol.19, No.4, pp.711-717, August 1990 is used. Argument \\spad{k} is a parameter of this algorithm.")) (|xn| (((|SparseUnivariatePolynomial| |#1|) (|NonNegativeInteger|)) "\\spad{xn(n)} returns the polynomial \\spad{x**n-1}.")) (|pol| (((|SparseUnivariatePolynomial| |#1|) (|Vector| |#1|)) "\\spad{pol(v)} turns the vector \\spad{[v0,...,vn]} into the polynomial \\spad{v0+v1*x+ \\spad{...} + vn*x**n}.")) (|index| (((|Vector| |#1|) (|PositiveInteger|) (|PositiveInteger|)) "\\spad{index(n,m)} is a index function for vectors of length \\spad{n} over the ground field.")) (|random| (((|Vector| |#1|) (|PositiveInteger|)) "\\spad{random(n)} creates a vector over the ground field with random entries.")) (|setFieldInfo| (((|Void|) (|Vector| (|List| (|Record| (|:| |value| |#1|) (|:| |index| (|SingleInteger|))))) |#1|) "\\spad{setFieldInfo(m,p)} initializes the field arithmetic, where \\spad{m} is the multiplication table and \\spad{p} is the respective normal element of the ground field \\spad{GF.}"))) 
NIL 
NIL 
(|IncrementingMaps| R) 
((|constructor| (NIL "This package provides operations to create incrementing functions.")) (|incrementBy| (((|Mapping| |#1| |#1|) |#1|) "\\spad{incrementBy(n)} produces a function which adds \\spad{n} to whatever argument it is given. For example, if \\spad{{f} \\spad{:=} increment(n)} then \\spad{f \\spad{x}} is \\spad{x+n}.")) (|increment| (((|Mapping| |#1| |#1|)) "\\spad{increment()} produces a function which adds \\spad{1} to whatever argument it is given. For example, if \\spad{{f} \\spad{:=} increment()} then \\spad{f \\spad{x}} is \\spad{x+1}."))) 
NIL 
NIL 
(|IndexedExponents| |Varset|) 
((|constructor| (NIL "converts entire exponents to OutputForm"))) 
NIL 
NIL 
(|InnerNumericEigenPackage| K F |Par|) 
((|constructor| (NIL "This package is the inner package to be used by NumericRealEigenPackage and NumericComplexEigenPackage for the computation of numeric eigenvalues and eigenvectors.")) (|innerEigenvectors| (((|List| (|Record| (|:| |outval| |#2|) (|:| |outmult| (|Integer|)) (|:| |outvect| (|List| (|Matrix| |#2|))))) (|Matrix| |#1|) |#3| (|Mapping| (|Factored| (|SparseUnivariatePolynomial| |#1|)) (|SparseUnivariatePolynomial| |#1|))) "\\spad{innerEigenvectors(m,eps,factor)} computes explicitly the eigenvalues and the correspondent eigenvectors of the matrix \\spad{m.} The parameter \\spad{eps} determines the type of the output, \\spad{factor} is the univariate factorizer to \\spad{br} used to reduce the characteristic polynomial into irreducible factors.")) (|solve1| (((|List| |#2|) (|SparseUnivariatePolynomial| |#1|) |#3|) "\\spad{solve1(pol, eps)} finds the roots of the univariate polynomial polynomial \\spad{pol} to precision eps. If \\spad{K} is \\spad{Fraction Integer} then only the real roots are returned, if \\spad{K} is \\spad{Complex Fraction Integer} then all roots are found.")) (|charpol| (((|SparseUnivariatePolynomial| |#1|) (|Matrix| |#1|)) "\\spad{charpol(m)} computes the characteristic polynomial of a matrix \\spad{m} with entries in \\spad{K.} This function returns a polynomial over \\spad{K,} while the general one (that is in EiegenPackage) returns Fraction \\spad{P} \\spad{K}"))) 
NIL 
NIL 
(|InfinitlyClosePointCategory| K |symb| |PolyRing| E |ProjPt| PCS |Plc| DIVISOR BLMET) 
((|constructor| (NIL "This category is part of the PAFF package")) (|excpDivV| ((|#8| $) "\\spad{excpDivV returns} the exceptional divisor of the infinitly close point.")) (|chartV| ((|#9| $) "chartV is the chart of the infinitly close point. The first integer correspond to variable defining the exceptional line, the last one the affine neighboorhood and the second one is the remaining integer. For example [1,2,3] means that Z=1, \\spad{X=X} and Y=XY. [2,3,1] means that X=1, \\spad{Y=Y} and Z=YZ.")) (|multV| (((|NonNegativeInteger|) $) "\\spad{multV returns} the multiplicity of the infinitly close point.")) (|localPointV| (((|AffinePlane| |#1|) $) "\\spad{localPointV returns} the coordinates of the local infinitly close point")) (|curveV| (((|DistributedMultivariatePolynomial| (|construct| (QUOTE X) (QUOTE Y)) |#1|) $) "\\spad{curveV(p)} returns the defining polynomial of the strict transform on which lies the corresponding infinitly close point.")) (|pointV| ((|#5| $) "\\spad{pointV returns} the infinitly close point.")) (|create| (($ |#5| (|DistributedMultivariatePolynomial| (|construct| (QUOTE X) (QUOTE Y)) |#1|) (|AffinePlane| |#1|) (|NonNegativeInteger|) |#9| (|NonNegativeInteger|) |#8| |#1| (|Symbol|)) "\\spad{create an} infinitly close point"))) 
NIL 
NIL 
(|InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField| K |symb| BLMET) 
((|constructor| (NIL "This domain is part of the PAFF package")) (|fullOutput| (((|Boolean|)) "\\spad{fullOutput returns} the value of the flag set by fullOutput(b).") (((|Boolean|) (|Boolean|)) "\\spad{fullOutput(b)} sets a flag such that when true, a coerce to OutputForm \\indented{1}{yields the full output of \\spad{tr,} otherwise encode(tr) is output} (see encode function). The default is false.")) (|fullOut| (((|OutputForm|) $) "\\spad{fullOut(tr)} yields a full output of \\spad{tr} (see function fullOutput)."))) 
NIL 
NIL 
(|InfinitlyClosePoint| K |symb| |PolyRing| E |ProjPt| PCS |Plc| DIVISOR BLMET) 
((|constructor| (NIL "This domain is part of the PAFF package")) (|fullOutput| (((|Boolean|)) "\\spad{fullOutput returns} the value of the flag set by fullOutput(b).") (((|Boolean|) (|Boolean|)) "\\spad{fullOutput(b)} sets a flag such that when true, a coerce to OutputForm yields the full output of \\spad{tr,} otherwise encode(tr) is output (see encode function). The default is false.")) (|fullOut| (((|OutputForm|) $) "\\spad{fullOut(tr)} yields a full output of \\spad{tr} (see function fullOutput)."))) 
NIL 
NIL 
(|Infinity|) 
((|constructor| (NIL "Top-level infinity Default infinity signatures for the interpreter.")) (|minusInfinity| (((|OrderedCompletion| (|Integer|))) "\\spad{minusInfinity()} returns minusInfinity.")) (|plusInfinity| (((|OrderedCompletion| (|Integer|))) "\\spad{plusInfinity()} returns plusIinfinity.")) (|infinity| (((|OnePointCompletion| (|Integer|))) "\\spad{infinity()} returns infinity."))) 
NIL 
NIL 
(|InputFormFunctions1| R) 
((|constructor| (NIL "Tools for manipulating input forms.")) (|interpret| ((|#1| (|InputForm|)) "\\spad{interpret(f)} passes \\spad{f} to the interpreter, and transforms the result into an object of type \\spad{R.}")) (|packageCall| (((|InputForm|) (|Symbol|)) "\\spad{packageCall(f)} returns the input form corresponding to f$R."))) 
NIL 
NIL 
(|InputForm|) 
((|constructor| (NIL "Domain of parsed forms which can be passed to the interpreter. This is also the interface between algebra code and facilities in the interpreter.")) (|compile| (((|Symbol|) (|Symbol|) (|List| $)) "\\spad{compile(f, [t1,...,tn])} forces the interpreter to compile the function \\spad{f} with signature \\spad{(t1,...,tn) \\spad{->} \\spad{?}.} returns the symbol \\spad{f} if successful. Error: if \\spad{f} was not defined beforehand in the interpreter, or if the ti's are not valid types, or if the compiler fails.")) (|declare| (((|Symbol|) (|List| $)) "\\spad{declare(t)} returns a name \\spad{f} such that \\spad{f} has been declared to the interpreter to be of type \\spad{t,} but has not been assigned a value yet. Note: \\spad{t} should be created as \\spad{devaluate(T)$Lisp} where \\spad{T} is the actual type of \\spad{f} (this hack is required for the case where \\spad{T} is a mapping type).")) (|parse| (($ (|String|)) "\\spad{parse(s)} is the inverse of unparse. It parses a string to InputForm.")) (|unparse| (((|String|) $) "\\spad{unparse(f)} returns a string \\spad{s} such that the parser would transform \\spad{s} to \\spad{f.} Error: if \\spad{f} is not the parsed form of a string.")) (|flatten| (($ $) "\\spad{flatten(s)} returns an input form corresponding to \\spad{s} with all the nested operations flattened to triples using new local variables. If \\spad{s} is a piece of code, this speeds up the compilation tremendously later on.")) ((|One|) (($) "\\spad{1} returns the input form corresponding to 1.")) ((|Zero|) (($) "\\spad{0} returns the input form corresponding to 0.")) (** (($ $ (|Integer|)) "\\spad{a \\spad{**} \\spad{b}} returns the input form corresponding to \\spad{a \\spad{**} \\spad{b}.}") (($ $ (|NonNegativeInteger|)) "\\spad{a \\spad{**} \\spad{b}} returns the input form corresponding to \\spad{a \\spad{**} \\spad{b}.}")) (/ (($ $ $) "\\spad{a / \\spad{b}} returns the input form corresponding to \\spad{a / \\spad{b}.}")) (* (($ $ $) "\\spad{a * \\spad{b}} returns the input form corresponding to \\spad{a * \\spad{b}.}")) (+ (($ $ $) "\\spad{a + \\spad{b}} returns the input form corresponding to \\spad{a + \\spad{b}.}")) (|lambda| (($ $ (|List| (|Symbol|))) "\\spad{lambda(code, [x1,...,xn])} returns the input form corresponding to \\spad{(x1,...,xn) \\spad{+->} code} if \\spad{n > 1}, or to \\spad{x1 \\spad{+->} code} if \\spad{n = 1}.")) (|function| (($ $ (|List| (|Symbol|)) (|Symbol|)) "\\spad{function(code, [x1,...,xn], \\spad{f)}} returns the input form corresponding to \\spad{f(x1,...,xn) \\spad{==} code}.")) (|binary| (($ $ (|List| $)) "\\indented{1}{\\spad{binary(op, [a1,...,an])} returns the input form} \\indented{1}{corresponding \\spad{to\\space{2}\\spad{a1} op \\spad{a2} op \\spad{...} op an}.} \\blankline \\spad{X} a:=[1,2,3]::List(InputForm) \\spad{X} binary(_+::InputForm,a)")) (|convert| (($ (|SExpression|)) "\\spad{convert(s)} makes \\spad{s} into an input form.")) (|interpret| (((|Any|) $) "\\spad{interpret(f)} passes \\spad{f} to the interpreter."))) 
NIL 
NIL 
(|InfiniteProductCharacteristicZero| |Coef| UTS) 
((|constructor| (NIL "This package computes infinite products of univariate Taylor series over an integral domain of characteristic 0.")) (|generalInfiniteProduct| ((|#2| |#2| (|Integer|) (|Integer|)) "\\spad{generalInfiniteProduct(f(x),a,d)} computes \\spad{product(n=a,a+d,a+2*d,...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1.")) (|oddInfiniteProduct| ((|#2| |#2|) "\\spad{oddInfiniteProduct(f(x))} computes \\spad{product(n=1,3,5...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1.")) (|evenInfiniteProduct| ((|#2| |#2|) "\\spad{evenInfiniteProduct(f(x))} computes \\spad{product(n=2,4,6...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1.")) (|infiniteProduct| ((|#2| |#2|) "\\spad{infiniteProduct(f(x))} computes \\spad{product(n=1,2,3...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1."))) 
NIL 
NIL 
(|InnerNumericFloatSolvePackage| K F |Par|) 
((|constructor| (NIL "This is an internal package for computing approximate solutions to systems of polynomial equations. The parameter \\spad{K} specifies the coefficient field of the input polynomials and must be either \\spad{Fraction(Integer)} or \\spad{Complex(Fraction Integer)}. The parameter \\spad{F} specifies where the solutions must lie and can be one of the following: \\spad{Float}, \\spad{Fraction(Integer)}, \\spad{Complex(Float)}, \\spad{Complex(Fraction Integer)}. The last parameter specifies the type of the precision operand and must be either \\spad{Fraction(Integer)} or \\spad{Float}.")) (|makeEq| (((|List| (|Equation| (|Polynomial| |#2|))) (|List| |#2|) (|List| (|Symbol|))) "\\spad{makeEq(lsol,lvar)} returns a list of equations formed by corresponding members of \\spad{lvar} and lsol.")) (|innerSolve| (((|List| (|List| |#2|)) (|List| (|Polynomial| |#1|)) (|List| (|Polynomial| |#1|)) (|List| (|Symbol|)) |#3|) "\\spad{innerSolve(lnum,lden,lvar,eps)} returns a list of solutions of the system of polynomials lnum, with the side condition that none of the members of \\spad{lden} vanish identically on any solution. Each solution is expressed as a list corresponding to the list of variables in \\spad{lvar} and with precision specified by eps.")) (|innerSolve1| (((|List| |#2|) (|Polynomial| |#1|) |#3|) "\\spad{innerSolve1(p,eps)} returns the list of the zeros of the polynomial \\spad{p} with precision eps.") (((|List| |#2|) (|SparseUnivariatePolynomial| |#1|) |#3|) "\\spad{innerSolve1(up,eps)} returns the list of the zeros of the univariate polynomial \\spad{up} with precision eps."))) 
NIL 
NIL 
(|InnerModularGcd| R BP |pMod| |nextMod|) 
((|constructor| (NIL "This file contains the functions for modular \\spad{gcd} algorithm for univariate polynomials with coefficients in a non-trivial euclidean domain (\\spadignore{i.e.} not a field). The package parametrised by the coefficient domain, the polynomial domain, a prime, and a function for choosing the next prime")) (|reduction| ((|#2| |#2| |#1|) "\\spad{reduction(f,p)} reduces the coefficients of the polynomial \\spad{f} modulo the prime \\spad{p.}")) (|modularGcd| ((|#2| (|List| |#2|)) "\\spad{modularGcd(listf)} computes the \\spad{gcd} of the list of polynomials \\spad{listf} by modular methods.")) (|modularGcdPrimitive| ((|#2| (|List| |#2|)) "\\spad{modularGcdPrimitive(f1,f2)} computes the \\spad{gcd} of the two polynomials \\spad{f1} and \\spad{f2} by modular methods."))) 
NIL 
NIL 
(|InnerMultFact| OV E R P) 
((|constructor| (NIL "This is an inner package for factoring multivariate polynomials over various coefficient domains in characteristic 0. The univariate factor operation is passed as a parameter. Multivariate hensel lifting is used to lift the univariate factorization")) (|factor| (((|Factored| (|SparseUnivariatePolynomial| |#4|)) (|SparseUnivariatePolynomial| |#4|) (|Mapping| (|Factored| (|SparseUnivariatePolynomial| |#3|)) (|SparseUnivariatePolynomial| |#3|))) "\\spad{factor(p,ufact)} factors the multivariate polynomial \\spad{p} by specializing variables and calling the univariate factorizer ufact. \\spad{p} is represented as a univariate polynomial with multivariate coefficients.") (((|Factored| |#4|) |#4| (|Mapping| (|Factored| (|SparseUnivariatePolynomial| |#3|)) (|SparseUnivariatePolynomial| |#3|))) "\\spad{factor(p,ufact)} factors the multivariate polynomial \\spad{p} by specializing variables and calling the univariate factorizer ufact."))) 
NIL 
NIL 
(|InfiniteProductFiniteField| K UP |Coef| UTS) 
((|constructor| (NIL "This package computes infinite products of univariate Taylor series over an arbitrary finite field.")) (|generalInfiniteProduct| ((|#4| |#4| (|Integer|) (|Integer|)) "\\spad{generalInfiniteProduct(f(x),a,d)} computes \\spad{product(n=a,a+d,a+2*d,...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1.")) (|oddInfiniteProduct| ((|#4| |#4|) "\\spad{oddInfiniteProduct(f(x))} computes \\spad{product(n=1,3,5...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1.")) (|evenInfiniteProduct| ((|#4| |#4|) "\\spad{evenInfiniteProduct(f(x))} computes \\spad{product(n=2,4,6...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1.")) (|infiniteProduct| ((|#4| |#4|) "\\spad{infiniteProduct(f(x))} computes \\spad{product(n=1,2,3...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1."))) 
NIL 
NIL 
(|InfiniteProductPrimeField| |Coef| UTS) 
((|constructor| (NIL "This package computes infinite products of univariate Taylor series over a field of prime order.")) (|generalInfiniteProduct| ((|#2| |#2| (|Integer|) (|Integer|)) "\\spad{generalInfiniteProduct(f(x),a,d)} computes \\spad{product(n=a,a+d,a+2*d,...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1.")) (|oddInfiniteProduct| ((|#2| |#2|) "\\spad{oddInfiniteProduct(f(x))} computes \\spad{product(n=1,3,5...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1.")) (|evenInfiniteProduct| ((|#2| |#2|) "\\spad{evenInfiniteProduct(f(x))} computes \\spad{product(n=2,4,6...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1.")) (|infiniteProduct| ((|#2| |#2|) "\\spad{infiniteProduct(f(x))} computes \\spad{product(n=1,2,3...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1."))) 
NIL 
NIL 
(|InnerPolySign| R UP) 
((|constructor| (NIL "Find the sign of a polynomial around a point or infinity.")) (|signAround| (((|Union| (|Integer|) "failed") |#2| |#1| (|Mapping| (|Union| (|Integer|) "failed") |#1|)) "\\spad{signAround(u,r,f)} \\undocumented") (((|Union| (|Integer|) "failed") |#2| |#1| (|Integer|) (|Mapping| (|Union| (|Integer|) "failed") |#1|)) "\\spad{signAround(u,r,i,f)} \\undocumented") (((|Union| (|Integer|) "failed") |#2| (|Integer|) (|Mapping| (|Union| (|Integer|) "failed") |#1|)) "\\spad{signAround(u,i,f)} \\undocumented"))) 
NIL 
NIL 
(|IntegerNumberSystem&| S) 
((|constructor| (NIL "An \\spad{IntegerNumberSystem} is a model for the integers.")) (|invmod| (($ $ $) "\\spad{invmod(a,b)}, \\spad{0<=a<b>1}, \\spad{(a,b)=1} means \\spad{1/a mod \\spad{b}.}")) (|powmod| (($ $ $ $) "\\spad{powmod(a,b,p)}, \\spad{0<=a,b<p>1}, means \\spad{a**b mod \\spad{p}.}")) (|mulmod| (($ $ $ $) "\\spad{mulmod(a,b,p)}, \\spad{0<=a,b<p>1}, means \\spad{a*b mod \\spad{p}.}")) (|submod| (($ $ $ $) "\\spad{submod(a,b,p)}, \\spad{0<=a,b<p>1}, means \\spad{a-b mod \\spad{p}.}")) (|addmod| (($ $ $ $) "\\spad{addmod(a,b,p)}, \\spad{0<=a,b<p>1}, means \\spad{a+b mod \\spad{p}.}")) (|mask| (($ $) "\\spad{mask(n)} returns \\spad{2**n-1} (an \\spad{n} bit mask).")) (|dec| (($ $) "\\spad{dec(x)} returns \\spad{x - 1}.")) (|inc| (($ $) "\\spad{inc(x)} returns \\spad{x + 1}.")) (|copy| (($ $) "\\spad{copy(n)} gives a copy of \\spad{n.}")) (|hash| (($ $) "\\spad{hash(n)} returns the hash code of \\spad{n.}")) (|random| (($ $) "\\spad{random(a)} creates a random element from 0 to \\spad{n-1}.") (($) "\\spad{random()} creates a random element.")) (|rationalIfCan| (((|Union| (|Fraction| (|Integer|)) "failed") $) "\\spad{rationalIfCan(n)} creates a rational number, or returns \"failed\" if this is not possible.")) (|rational| (((|Fraction| (|Integer|)) $) "\\spad{rational(n)} creates a rational number (see \\spadtype{Fraction Integer})..")) (|rational?| (((|Boolean|) $) "\\spad{rational?(n)} tests if \\spad{n} is a rational number (see \\spadtype{Fraction Integer}).")) (|symmetricRemainder| (($ $ $) "\\spad{symmetricRemainder(a,b)} (where \\spad{b > 1}) yields \\spad{r} where \\spad{ \\spad{-b/2} \\spad{<=} \\spad{r} < \\spad{b/2} \\spad{}.}")) (|positiveRemainder| (($ $ $) "\\spad{positiveRemainder(a,b)} (where \\spad{b > 1}) yields \\spad{r} where \\spad{0 \\spad{<=} \\spad{r} < \\spad{b}} and \\spad{r \\spad{==} a rem \\spad{b}.}")) (|bit?| (((|Boolean|) $ $) "\\spad{bit?(n,i)} returns \\spad{true} if and only if \\spad{i}-th bit of \\spad{n} is a 1.")) (|shift| (($ $ $) "\\spad{shift(a,i)} shift \\spad{a} by \\spad{i} digits.")) (|length| (($ $) "\\spad{length(a)} length of \\spad{a} in digits.")) (|base| (($) "\\spad{base()} returns the base for the operations of \\spad{IntegerNumberSystem}.")) (|multiplicativeValuation| ((|attribute|) "euclideanSize(a*b) returns \\spad{euclideanSize(a)*euclideanSize(b)}.")) (|even?| (((|Boolean|) $) "\\spad{even?(n)} returns \\spad{true} if and only if \\spad{n} is even.")) (|odd?| (((|Boolean|) $) "\\spad{odd?(n)} returns \\spad{true} if and only if \\spad{n} is odd."))) 
NIL 
NIL 
(|IntegerNumberSystem|) 
((|constructor| (NIL "An \\spad{IntegerNumberSystem} is a model for the integers.")) (|invmod| (($ $ $) "\\spad{invmod(a,b)}, \\spad{0<=a<b>1}, \\spad{(a,b)=1} means \\spad{1/a mod \\spad{b}.}")) (|powmod| (($ $ $ $) "\\spad{powmod(a,b,p)}, \\spad{0<=a,b<p>1}, means \\spad{a**b mod \\spad{p}.}")) (|mulmod| (($ $ $ $) "\\spad{mulmod(a,b,p)}, \\spad{0<=a,b<p>1}, means \\spad{a*b mod \\spad{p}.}")) (|submod| (($ $ $ $) "\\spad{submod(a,b,p)}, \\spad{0<=a,b<p>1}, means \\spad{a-b mod \\spad{p}.}")) (|addmod| (($ $ $ $) "\\spad{addmod(a,b,p)}, \\spad{0<=a,b<p>1}, means \\spad{a+b mod \\spad{p}.}")) (|mask| (($ $) "\\spad{mask(n)} returns \\spad{2**n-1} (an \\spad{n} bit mask).")) (|dec| (($ $) "\\spad{dec(x)} returns \\spad{x - 1}.")) (|inc| (($ $) "\\spad{inc(x)} returns \\spad{x + 1}.")) (|copy| (($ $) "\\spad{copy(n)} gives a copy of \\spad{n.}")) (|hash| (($ $) "\\spad{hash(n)} returns the hash code of \\spad{n.}")) (|random| (($ $) "\\spad{random(a)} creates a random element from 0 to \\spad{n-1}.") (($) "\\spad{random()} creates a random element.")) (|rationalIfCan| (((|Union| (|Fraction| (|Integer|)) "failed") $) "\\spad{rationalIfCan(n)} creates a rational number, or returns \"failed\" if this is not possible.")) (|rational| (((|Fraction| (|Integer|)) $) "\\spad{rational(n)} creates a rational number (see \\spadtype{Fraction Integer})..")) (|rational?| (((|Boolean|) $) "\\spad{rational?(n)} tests if \\spad{n} is a rational number (see \\spadtype{Fraction Integer}).")) (|symmetricRemainder| (($ $ $) "\\spad{symmetricRemainder(a,b)} (where \\spad{b > 1}) yields \\spad{r} where \\spad{ \\spad{-b/2} \\spad{<=} \\spad{r} < \\spad{b/2} \\spad{}.}")) (|positiveRemainder| (($ $ $) "\\spad{positiveRemainder(a,b)} (where \\spad{b > 1}) yields \\spad{r} where \\spad{0 \\spad{<=} \\spad{r} < \\spad{b}} and \\spad{r \\spad{==} a rem \\spad{b}.}")) (|bit?| (((|Boolean|) $ $) "\\spad{bit?(n,i)} returns \\spad{true} if and only if \\spad{i}-th bit of \\spad{n} is a 1.")) (|shift| (($ $ $) "\\spad{shift(a,i)} shift \\spad{a} by \\spad{i} digits.")) (|length| (($ $) "\\spad{length(a)} length of \\spad{a} in digits.")) (|base| (($) "\\spad{base()} returns the base for the operations of \\spad{IntegerNumberSystem}.")) (|multiplicativeValuation| ((|attribute|) "euclideanSize(a*b) returns \\spad{euclideanSize(a)*euclideanSize(b)}.")) (|even?| (((|Boolean|) $) "\\spad{even?(n)} returns \\spad{true} if and only if \\spad{n} is even.")) (|odd?| (((|Boolean|) $) "\\spad{odd?(n)} returns \\spad{true} if and only if \\spad{n} is odd."))) 
((|canonicalUnitNormal| . T) (|multiplicativeValuation| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|InnerTable| |Key| |Entry| |addDom|) 
((|constructor| (NIL "This domain is used to provide a conditional \"add\" domain for the implementation of \\spadtype{Table}."))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (|devaluate| |#1|)) (LIST (QUOTE |:|) (QUOTE |entry|) (|devaluate| |#2|))))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))) (OR (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) 
(|AlgebraicIntegration| R F) 
((|constructor| (NIL "This package provides functions for the integration of algebraic integrands over transcendental functions.")) (|algint| (((|IntegrationResult| |#2|) |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|Mapping| (|SparseUnivariatePolynomial| |#2|) (|SparseUnivariatePolynomial| |#2|))) "\\spad{algint(f, \\spad{x,} \\spad{y,} \\spad{d)}} returns the integral of \\spad{f(x,y)dx} where \\spad{y} is an algebraic function of \\spad{x;} \\spad{d} is the derivation to use on \\spad{k[x]}."))) 
NIL 
NIL 
(|AlgebraicIntegrate| R0 F UP UPUP R) 
((|constructor| (NIL "This package provides functions for integrating a function on an algebraic curve.")) (|palginfieldint| (((|Union| |#5| "failed") |#5| (|Mapping| |#3| |#3|)) "\\spad{palginfieldint(f, \\spad{d)}} returns an algebraic function \\spad{g} such that \\spad{dg = \\spad{f}} if such a \\spad{g} exists, \"failed\" otherwise. Argument \\spad{f} must be a pure algebraic function.")) (|palgintegrate| (((|IntegrationResult| |#5|) |#5| (|Mapping| |#3| |#3|)) "\\spad{palgintegrate(f, \\spad{d)}} integrates \\spad{f} with respect to the derivation \\spad{d.} Argument \\spad{f} must be a pure algebraic function.")) (|algintegrate| (((|IntegrationResult| |#5|) |#5| (|Mapping| |#3| |#3|)) "\\spad{algintegrate(f, \\spad{d)}} integrates \\spad{f} with respect to the derivation \\spad{d.}"))) 
NIL 
NIL 
(|IntegerBits|) 
((|constructor| (NIL "This package provides functions to lookup bits in integers")) (|bitTruth| (((|Boolean|) (|Integer|) (|Integer|)) "\\spad{bitTruth(n,m)} returns \\spad{true} if coefficient of 2**m in abs(n) is 1")) (|bitCoef| (((|Integer|) (|Integer|) (|Integer|)) "\\spad{bitCoef(n,m)} returns the coefficient of 2**m in abs(n)")) (|bitLength| (((|Integer|) (|Integer|)) "\\spad{bitLength(n)} returns the number of bits to represent abs(n)"))) 
NIL 
NIL 
(|IntervalCategory| R) 
((|constructor| (NIL "This category implements of interval arithmetic and transcendental functions over intervals.")) (|contains?| (((|Boolean|) $ |#1|) "\\spad{contains?(i,f)} returns \\spad{true} if \\axiom{f} is contained within the interval \\axiom{i}, \\spad{false} otherwise.")) (|negative?| (((|Boolean|) $) "\\spad{negative?(u)} returns \\axiom{true} if every element of \\spad{u} is negative, \\axiom{false} otherwise.")) (|positive?| (((|Boolean|) $) "\\spad{positive?(u)} returns \\axiom{true} if every element of \\spad{u} is positive, \\axiom{false} otherwise.")) (|width| ((|#1| $) "\\spad{width(u)} returns \\axiom{sup(u) - inf(u)}.")) (|sup| ((|#1| $) "\\spad{sup(u)} returns the supremum of \\axiom{u}.")) (|inf| ((|#1| $) "\\spad{inf(u)} returns the infinum of \\axiom{u}.")) (|qinterval| (($ |#1| |#1|) "\\spad{qinterval(inf,sup)} creates a new interval \\axiom{[inf,sup]}, without checking the ordering on the elements.")) (|interval| (($ (|Fraction| (|Integer|))) "\\spad{interval(f)} creates a new interval around \\spad{f.}") (($ |#1|) "\\spad{interval(f)} creates a new interval around \\spad{f.}") (($ |#1| |#1|) "\\spad{interval(inf,sup)} creates a new interval, either \\axiom{[inf,sup]} if \\axiom{inf \\spad{<=} sup} or \\axiom{[sup,in]} otherwise."))) 
((|approximate| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|IntersectionDivisorPackage| K |symb| |PolyRing| E |ProjPt| PCS |Plc| DIVISOR |InfClsPoint| |DesTree| BLMET) 
((|constructor| (NIL "The following is part of the PAFF package")) (|placesOfDegree| (((|Void|) (|PositiveInteger|) |#3| (|List| |#5|)) "\\spad{placesOfDegree(d, \\spad{f,} pts)} compute the places of degree dividing \\spad{d} of the curve \\spad{f.} \\spad{pts} should be the singular points of the curve \\spad{f.} For \\spad{d} > 1 this only works if \\spad{K} has \\axiomType{PseudoAlgebraicClosureOfFiniteFieldCategory}.")) (|intersectionDivisor| ((|#8| |#3| |#3| (|List| |#10|) (|List| |#5|)) "\\spad{intersectionDivisor(f,pol,listOfTree)} returns the intersection divisor of \\spad{f} with a curve defined by pol. \\spad{listOfTree} must contain all the desingularisation trees of all singular points on the curve \\indented{1}{defined by pol.}"))) 
NIL 
NIL 
(|IntegralDomain&| S) 
((|constructor| (NIL "The category of commutative integral domains, \\spadignore{i.e.} commutative rings with no zero divisors. \\blankline Conditional attributes\\br canonicalUnitNormal\\tab{5}the canonical field is the same for all associates\\br canonicalsClosed\\tab{5}the product of two canonicals is itself canonical")) (|unit?| (((|Boolean|) $) "\\spad{unit?(x)} tests whether \\spad{x} is a unit, \\spadignore{i.e.} is invertible.")) (|associates?| (((|Boolean|) $ $) "\\spad{associates?(x,y)} tests whether \\spad{x} and \\spad{y} are associates, \\spadignore{i.e.} differ by a unit factor.")) (|unitCanonical| (($ $) "\\spad{unitCanonical(x)} returns \\spad{unitNormal(x).canonical}.")) (|unitNormal| (((|Record| (|:| |unit| $) (|:| |canonical| $) (|:| |associate| $)) $) "\\spad{unitNormal(x)} tries to choose a canonical element from the associate class of \\spad{x.} The attribute canonicalUnitNormal, if asserted, means that the \"canonical\" element is the same across all associates of \\spad{x} if \\spad{unitNormal(x) = [u,c,a]} then \\spad{u*c = \\spad{x},} \\spad{a*u = 1}.")) (|exquo| (((|Union| $ "failed") $ $) "\\spad{exquo(a,b)} either returns an element \\spad{c} such that \\spad{c*b=a} or \"failed\" if no such element can be found."))) 
NIL 
NIL 
(|IntegralDomain|) 
((|constructor| (NIL "The category of commutative integral domains, \\spadignore{i.e.} commutative rings with no zero divisors. \\blankline Conditional attributes\\br canonicalUnitNormal\\tab{5}the canonical field is the same for all associates\\br canonicalsClosed\\tab{5}the product of two canonicals is itself canonical")) (|unit?| (((|Boolean|) $) "\\spad{unit?(x)} tests whether \\spad{x} is a unit, \\spadignore{i.e.} is invertible.")) (|associates?| (((|Boolean|) $ $) "\\spad{associates?(x,y)} tests whether \\spad{x} and \\spad{y} are associates, \\spadignore{i.e.} differ by a unit factor.")) (|unitCanonical| (($ $) "\\spad{unitCanonical(x)} returns \\spad{unitNormal(x).canonical}.")) (|unitNormal| (((|Record| (|:| |unit| $) (|:| |canonical| $) (|:| |associate| $)) $) "\\spad{unitNormal(x)} tries to choose a canonical element from the associate class of \\spad{x.} The attribute canonicalUnitNormal, if asserted, means that the \"canonical\" element is the same across all associates of \\spad{x} if \\spad{unitNormal(x) = [u,c,a]} then \\spad{u*c = \\spad{x},} \\spad{a*u = 1}.")) (|exquo| (((|Union| $ "failed") $ $) "\\spad{exquo(a,b)} either returns an element \\spad{c} such that \\spad{c*b=a} or \"failed\" if no such element can be found."))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|ElementaryIntegration| R F) 
((|constructor| (NIL "This package provides functions for integration, limited integration, extended integration and the risch differential equation for elementary functions.")) (|lfextlimint| (((|Union| (|Record| (|:| |ratpart| |#2|) (|:| |coeff| |#2|)) "failed") |#2| (|Symbol|) (|Kernel| |#2|) (|List| (|Kernel| |#2|))) "\\spad{lfextlimint(f,x,k,[k1,...,kn])} returns functions \\spad{[h, \\spad{c]}} such that \\spad{dh/dx = \\spad{f} - \\spad{c} dk/dx}. Value \\spad{h} is looked for in a field containing \\spad{f} and k1,...,kn (the ki's must be logs).")) (|lfintegrate| (((|IntegrationResult| |#2|) |#2| (|Symbol|)) "\\spad{lfintegrate(f, \\spad{x)}} = \\spad{g} such that \\spad{dg/dx = \\spad{f}.}")) (|lfinfieldint| (((|Union| |#2| "failed") |#2| (|Symbol|)) "\\spad{lfinfieldint(f, \\spad{x)}} returns a function \\spad{g} such that \\spad{dg/dx = \\spad{f}} if \\spad{g} exists, \"failed\" otherwise.")) (|lflimitedint| (((|Union| (|Record| (|:| |mainpart| |#2|) (|:| |limitedlogs| (|List| (|Record| (|:| |coeff| |#2|) (|:| |logand| |#2|))))) "failed") |#2| (|Symbol|) (|List| |#2|)) "\\spad{lflimitedint(f,x,[g1,...,gn])} returns functions \\spad{[h,[[ci, gi]]]} such that the gi's are among \\spad{[g1,...,gn]}, and \\spad{d(h+sum(ci log(gi)))/dx = \\spad{f},} if possible, \"failed\" otherwise.")) (|lfextendedint| (((|Union| (|Record| (|:| |ratpart| |#2|) (|:| |coeff| |#2|)) "failed") |#2| (|Symbol|) |#2|) "\\spad{lfextendedint(f, \\spad{x,} \\spad{g)}} returns functions \\spad{[h, \\spad{c]}} such that \\spad{dh/dx = \\spad{f} - cg}, if \\spad{(h,} \\spad{c)} exist, \"failed\" otherwise."))) 
NIL 
NIL 
(|InterfaceGroebnerPackage| K |symb| E OV R) 
((|constructor| (NIL "Part of the Package for Algebraic Function Fields in one variable PAFF"))) 
NIL 
NIL 
(|IntegerFactorizationPackage| I) 
((|constructor| (NIL "This Package contains basic methods for integer factorization. The factor operation employs trial division up to 10,000. It then tests to see if \\spad{n} is a perfect power before using Pollards rho method. Because Pollards method may fail, the result of factor may contain composite factors. We should also employ Lenstra's eliptic curve method.")) (|PollardSmallFactor| (((|Union| |#1| "failed") |#1|) "\\spad{PollardSmallFactor(n)} returns a factor of \\spad{n} or \"failed\" if no one is found")) (|BasicMethod| (((|Factored| |#1|) |#1|) "\\spad{BasicMethod(n)} returns the factorization of integer \\spad{n} by trial division")) (|squareFree| (((|Factored| |#1|) |#1|) "\\spad{squareFree(n)} returns the square free factorization of integer \\spad{n}")) (|factor| (((|Factored| |#1|) |#1|) "\\spad{factor(n)} returns the full factorization of integer \\spad{n}"))) 
NIL 
NIL 
(|InterpolateFormsPackage| K |symb| |PolyRing| E |ProjPt| PCS |Plc| DIVISOR) 
((|constructor| (NIL "The following is part of the PAFF package")) (|interpolateForms| (((|List| |#3|) |#8| (|NonNegativeInteger|) |#3| (|List| |#3|)) "\\spad{interpolateForms(D,n,pol,base)} compute the basis of the sub-vector space \\spad{W} of \\spad{V} = <base>, such that for all \\spad{G} in \\spad{W,} the divisor \\spad{(G)} \\spad{>=} \\spad{D.} All the elements in \\spad{base} must be homogeneous polynomial of degree \\spad{n.} Typicaly, \\spad{base} is the set of all monomial of degree \\spad{n:} in that case, interpolateForms(D,n,pol,base) returns the basis of the vector space of all forms of degree \\spad{d} that interpolated \\spad{D.} The argument \\spad{pol} must be the same polynomial that defined the curve form which the divisor \\spad{D} is defined."))) 
NIL 
NIL 
(|IntegrationFunctionsTable|) 
((|constructor| (NIL "There is no description for this domain")) (|entry| (((|Record| (|:| |endPointContinuity| (|Union| (|:| |continuous| "Continuous at the end points") (|:| |lowerSingular| "There is a singularity at the lower end point") (|:| |upperSingular| "There is a singularity at the upper end point") (|:| |bothSingular| "There are singularities at both end points") (|:| |notEvaluated| "End point continuity not yet evaluated"))) (|:| |singularitiesStream| (|Union| (|:| |str| (|Stream| (|DoubleFloat|))) (|:| |notEvaluated| "Internal singularities not yet evaluated"))) (|:| |range| (|Union| (|:| |finite| "The range is finite") (|:| |lowerInfinite| "The bottom of range is infinite") (|:| |upperInfinite| "The top of range is infinite") (|:| |bothInfinite| "Both top and bottom points are infinite") (|:| |notEvaluated| "Range not yet evaluated")))) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{entry(n)} is not documented")) (|entries| (((|List| (|Record| (|:| |key| (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) (|:| |entry| (|Record| (|:| |endPointContinuity| (|Union| (|:| |continuous| "Continuous at the end points") (|:| |lowerSingular| "There is a singularity at the lower end point") (|:| |upperSingular| "There is a singularity at the upper end point") (|:| |bothSingular| "There are singularities at both end points") (|:| |notEvaluated| "End point continuity not yet evaluated"))) (|:| |singularitiesStream| (|Union| (|:| |str| (|Stream| (|DoubleFloat|))) (|:| |notEvaluated| "Internal singularities not yet evaluated"))) (|:| |range| (|Union| (|:| |finite| "The range is finite") (|:| |lowerInfinite| "The bottom of range is infinite") (|:| |upperInfinite| "The top of range is infinite") (|:| |bothInfinite| "Both top and bottom points are infinite") (|:| |notEvaluated| "Range not yet evaluated"))))))) $) "\\spad{entries(x)} is not documented")) (|showAttributes| (((|Union| (|Record| (|:| |endPointContinuity| (|Union| (|:| |continuous| "Continuous at the end points") (|:| |lowerSingular| "There is a singularity at the lower end point") (|:| |upperSingular| "There is a singularity at the upper end point") (|:| |bothSingular| "There are singularities at both end points") (|:| |notEvaluated| "End point continuity not yet evaluated"))) (|:| |singularitiesStream| (|Union| (|:| |str| (|Stream| (|DoubleFloat|))) (|:| |notEvaluated| "Internal singularities not yet evaluated"))) (|:| |range| (|Union| (|:| |finite| "The range is finite") (|:| |lowerInfinite| "The bottom of range is infinite") (|:| |upperInfinite| "The top of range is infinite") (|:| |bothInfinite| "Both top and bottom points are infinite") (|:| |notEvaluated| "Range not yet evaluated")))) "failed") (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{showAttributes(x)} is not documented")) (|insert!| (($ (|Record| (|:| |key| (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) (|:| |entry| (|Record| (|:| |endPointContinuity| (|Union| (|:| |continuous| "Continuous at the end points") (|:| |lowerSingular| "There is a singularity at the lower end point") (|:| |upperSingular| "There is a singularity at the upper end point") (|:| |bothSingular| "There are singularities at both end points") (|:| |notEvaluated| "End point continuity not yet evaluated"))) (|:| |singularitiesStream| (|Union| (|:| |str| (|Stream| (|DoubleFloat|))) (|:| |notEvaluated| "Internal singularities not yet evaluated"))) (|:| |range| (|Union| (|:| |finite| "The range is finite") (|:| |lowerInfinite| "The bottom of range is infinite") (|:| |upperInfinite| "The top of range is infinite") (|:| |bothInfinite| "Both top and bottom points are infinite") (|:| |notEvaluated| "Range not yet evaluated"))))))) "\\spad{insert!(r)} inserts an entry \\spad{r} into theIFTable")) (|fTable| (($ (|List| (|Record| (|:| |key| (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) (|:| |entry| (|Record| (|:| |endPointContinuity| (|Union| (|:| |continuous| "Continuous at the end points") (|:| |lowerSingular| "There is a singularity at the lower end point") (|:| |upperSingular| "There is a singularity at the upper end point") (|:| |bothSingular| "There are singularities at both end points") (|:| |notEvaluated| "End point continuity not yet evaluated"))) (|:| |singularitiesStream| (|Union| (|:| |str| (|Stream| (|DoubleFloat|))) (|:| |notEvaluated| "Internal singularities not yet evaluated"))) (|:| |range| (|Union| (|:| |finite| "The range is finite") (|:| |lowerInfinite| "The bottom of range is infinite") (|:| |upperInfinite| "The top of range is infinite") (|:| |bothInfinite| "Both top and bottom points are infinite") (|:| |notEvaluated| "Range not yet evaluated")))))))) "\\spad{fTable(l)} creates a functions table from the elements of \\spad{l.}")) (|keys| (((|List| (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) $) "\\spad{keys(f)} returns the list of keys of \\spad{f}")) (|clearTheFTable| (((|Void|)) "\\spad{clearTheFTable()} clears the current table of functions.")) (|showTheFTable| (($) "\\spad{showTheFTable()} returns the current table of functions."))) 
NIL 
NIL 
(|GenusZeroIntegration| R F L) 
((|constructor| (NIL "Rationalization of several types of genus 0 integrands; This internal package rationalises integrands on curves of the form:\\br \\tab{5}\\spad{y\\^2 = a \\spad{x\\^2} + \\spad{b} \\spad{x} + c}\\br \\tab{5}\\spad{y\\^2 = (a \\spad{x} + \\spad{b)} / \\spad{(c} \\spad{x} + d)}\\br \\tab{5}\\spad{f(x, \\spad{y)} = 0} where \\spad{f} has degree 1 in x\\br The rationalization is done for integration, limited integration, extended integration and the risch differential equation.")) (|palgLODE0| (((|Record| (|:| |particular| (|Union| |#2| "failed")) (|:| |basis| (|List| |#2|))) |#3| |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|Kernel| |#2|) |#2| (|Fraction| (|SparseUnivariatePolynomial| |#2|))) "\\spad{palgLODE0(op,g,x,y,z,t,c)} returns the solution of \\spad{op \\spad{f} = \\spad{g}} Argument \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{f(x,y)dx = \\spad{c} f(t,y) dy}; \\spad{c} and \\spad{t} are rational functions of \\spad{y.}") (((|Record| (|:| |particular| (|Union| |#2| "failed")) (|:| |basis| (|List| |#2|))) |#3| |#2| (|Kernel| |#2|) (|Kernel| |#2|) |#2| (|SparseUnivariatePolynomial| |#2|)) "\\spad{palgLODE0(op, \\spad{g,} \\spad{x,} \\spad{y,} \\spad{d,} \\spad{p)}} returns the solution of \\spad{op \\spad{f} = \\spad{g}.} Argument \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{d(x)\\^2y(x)\\^2 = P(x)}.")) (|lift| (((|SparseUnivariatePolynomial| (|Fraction| (|SparseUnivariatePolynomial| |#2|))) (|SparseUnivariatePolynomial| |#2|) (|Kernel| |#2|)) "\\spad{lift(u,k)} \\undocumented")) (|multivariate| ((|#2| (|SparseUnivariatePolynomial| (|Fraction| (|SparseUnivariatePolynomial| |#2|))) (|Kernel| |#2|) |#2|) "\\spad{multivariate(u,k,f)} \\undocumented")) (|univariate| (((|SparseUnivariatePolynomial| (|Fraction| (|SparseUnivariatePolynomial| |#2|))) |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|SparseUnivariatePolynomial| |#2|)) "\\spad{univariate(f,k,k,p)} \\undocumented")) (|palgRDE0| (((|Union| |#2| "failed") |#2| |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|Mapping| (|Union| |#2| "failed") |#2| |#2| (|Symbol|)) (|Kernel| |#2|) |#2| (|Fraction| (|SparseUnivariatePolynomial| |#2|))) "\\spad{palgRDE0(f, \\spad{g,} \\spad{x,} \\spad{y,} foo, \\spad{t,} \\spad{c)}} returns a function \\spad{z(x,y)} such that \\spad{dz/dx + \\spad{n} * df/dx z(x,y) = g(x,y)} if such a \\spad{z} exists, and \"failed\" otherwise. Argument \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{f(x,y)dx = \\spad{c} f(t,y) dy}; \\spad{c} and \\spad{t} are rational functions of \\spad{y.} Argument \\spad{foo}, called by \\spad{foo(a, \\spad{b,} x)}, is a function that solves \\spad{du/dx + \\spad{n} * da/dx u(x) = u(x)} for an unknown \\spad{u(x)} not involving \\spad{y.}") (((|Union| |#2| "failed") |#2| |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|Mapping| (|Union| |#2| "failed") |#2| |#2| (|Symbol|)) |#2| (|SparseUnivariatePolynomial| |#2|)) "\\spad{palgRDE0(f, \\spad{g,} \\spad{x,} \\spad{y,} foo, \\spad{d,} \\spad{p)}} returns a function \\spad{z(x,y)} such that \\spad{dz/dx + \\spad{n} * df/dx z(x,y) = g(x,y)} if such a \\spad{z} exists, and \"failed\" otherwise. Argument \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{d(x)\\^2y(x)\\^2 = P(x)}. Argument foo, called by \\spad{foo(a, \\spad{b,} x)}, is a function that solves \\spad{du/dx + \\spad{n} * da/dx u(x) = u(x)} for an unknown \\spad{u(x)} not involving \\spad{y.}")) (|palglimint0| (((|Union| (|Record| (|:| |mainpart| |#2|) (|:| |limitedlogs| (|List| (|Record| (|:| |coeff| |#2|) (|:| |logand| |#2|))))) "failed") |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|List| |#2|) (|Kernel| |#2|) |#2| (|Fraction| (|SparseUnivariatePolynomial| |#2|))) "\\spad{palglimint0(f, \\spad{x,} \\spad{y,} [u1,...,un], \\spad{z,} \\spad{t,} \\spad{c)}} returns functions \\spad{[h,[[ci, ui]]]} such that the ui's are among \\spad{[u1,...,un]} and \\spad{d(h + sum(ci log(ui)))/dx = f(x,y)} if such functions exist, and \"failed\" otherwise. Argument \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{f(x,y)dx = \\spad{c} f(t,y) dy}; \\spad{c} and \\spad{t} are rational functions of \\spad{y.}") (((|Union| (|Record| (|:| |mainpart| |#2|) (|:| |limitedlogs| (|List| (|Record| (|:| |coeff| |#2|) (|:| |logand| |#2|))))) "failed") |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|List| |#2|) |#2| (|SparseUnivariatePolynomial| |#2|)) "\\spad{palglimint0(f, \\spad{x,} \\spad{y,} [u1,...,un], \\spad{d,} \\spad{p)}} returns functions \\spad{[h,[[ci, ui]]]} such that the ui's are among \\spad{[u1,...,un]} and \\spad{d(h + sum(ci log(ui)))/dx = f(x,y)} if such functions exist, and \"failed\" otherwise. Argument \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{d(x)\\^2y(x)\\^2 = P(x)}.")) (|palgextint0| (((|Union| (|Record| (|:| |ratpart| |#2|) (|:| |coeff| |#2|)) "failed") |#2| (|Kernel| |#2|) (|Kernel| |#2|) |#2| (|Kernel| |#2|) |#2| (|Fraction| (|SparseUnivariatePolynomial| |#2|))) "\\spad{palgextint0(f, \\spad{x,} \\spad{y,} \\spad{g,} \\spad{z,} \\spad{t,} \\spad{c)}} returns functions \\spad{[h, \\spad{d]}} such that \\spad{dh/dx = f(x,y) - \\spad{d} \\spad{g},} where \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{f(x,y)dx = \\spad{c} f(t,y) dy}, and \\spad{c} and \\spad{t} are rational functions of \\spad{y.} Argument \\spad{z} is a dummy variable not appearing in \\spad{f(x,y)}. The operation returns \"failed\" if no such functions exist.") (((|Union| (|Record| (|:| |ratpart| |#2|) (|:| |coeff| |#2|)) "failed") |#2| (|Kernel| |#2|) (|Kernel| |#2|) |#2| |#2| (|SparseUnivariatePolynomial| |#2|)) "\\spad{palgextint0(f, \\spad{x,} \\spad{y,} \\spad{g,} \\spad{d,} \\spad{p)}} returns functions \\spad{[h, \\spad{c]}} such that \\spad{dh/dx = f(x,y) - \\spad{c} \\spad{g},} where \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{d(x)\\^2 \\spad{y(x)\\^2} = P(x)}, or \"failed\" if no such functions exist.")) (|palgint0| (((|IntegrationResult| |#2|) |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|Kernel| |#2|) |#2| (|Fraction| (|SparseUnivariatePolynomial| |#2|))) "\\spad{palgint0(f, \\spad{x,} \\spad{y,} \\spad{z,} \\spad{t,} \\spad{c)}} returns the integral of \\spad{f(x,y)dx} where \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{f(x,y)dx = \\spad{c} f(t,y) dy}; \\spad{c} and \\spad{t} are rational functions of \\spad{y.} Argument \\spad{z} is a dummy variable not appearing in \\spad{f(x,y)}.") (((|IntegrationResult| |#2|) |#2| (|Kernel| |#2|) (|Kernel| |#2|) |#2| (|SparseUnivariatePolynomial| |#2|)) "\\spad{palgint0(f, \\spad{x,} \\spad{y,} \\spad{d,} \\spad{p)}} returns the integral of \\spad{f(x,y)dx} where \\spad{y} is an algebraic function of \\spad{x} satisfying \\spad{d(x)\\^2 \\spad{y(x)\\^2} = P(x)}."))) 
NIL 
((|HasCategory| |#3| (LIST (QUOTE |LinearOrdinaryDifferentialOperatorCategory|) (|devaluate| |#2|)))) 
(|IntegerNumberTheoryFunctions|) 
((|constructor| (NIL "This package provides various number theoretic functions on the integers.")) (|sumOfKthPowerDivisors| (((|Integer|) (|Integer|) (|NonNegativeInteger|)) "\\spad{sumOfKthPowerDivisors(n,k)} returns the sum of the \\spad{k}th powers of the integers between 1 and \\spad{n} (inclusive) which divide \\spad{n.} the sum of the \\spad{k}th powers of the divisors of \\spad{n} is often denoted by \\spad{sigma_k(n)}.")) (|sumOfDivisors| (((|Integer|) (|Integer|)) "\\spad{sumOfDivisors(n)} returns the sum of the integers between 1 and \\spad{n} (inclusive) which divide \\spad{n.} The sum of the divisors of \\spad{n} is often denoted by \\spad{sigma(n)}.")) (|numberOfDivisors| (((|Integer|) (|Integer|)) "\\spad{numberOfDivisors(n)} returns the number of integers between 1 and \\spad{n} (inclusive) which divide \\spad{n.} The number of divisors of \\spad{n} is often denoted by \\spad{tau(n)}.")) (|moebiusMu| (((|Integer|) (|Integer|)) "\\spad{moebiusMu(n)} returns the Moebius function \\spad{mu(n)}. \\spad{mu(n)} is either \\spad{-1,0} or 1 as follows: \\spad{mu(n) = 0} if \\spad{n} is divisible by a square > 1, \\spad{mu(n) = (-1)^k} if \\spad{n} is square-free and has \\spad{k} distinct prime divisors.")) (|legendre| (((|Integer|) (|Integer|) (|Integer|)) "\\spad{legendre(a,p)} returns the Legendre symbol \\spad{L(a/p)}. \\spad{L(a/p) = (-1)**((p-1)/2) mod \\spad{p}} \\spad{(p} prime), which is 0 if \\spad{a} is 0, 1 if \\spad{a} is a quadratic residue \\spad{mod \\spad{p}} and \\spad{-1} otherwise. Note that because the primality test is expensive, if it is known that \\spad{p} is prime then use \\spad{jacobi(a,p)}.")) (|jacobi| (((|Integer|) (|Integer|) (|Integer|)) "\\spad{jacobi(a,b)} returns the Jacobi symbol \\spad{J(a/b)}. When \\spad{b} is odd, \\spad{J(a/b) = product(L(a/p) for \\spad{p} in factor \\spad{b} \\spad{)}.} Note that by convention, 0 is returned if \\spad{gcd(a,b) \\spad{^=} 1}. Iterative \\spad{O(log(b)^2)} version coded by Michael Monagan June 1987.")) (|harmonic| (((|Fraction| (|Integer|)) (|Integer|)) "\\spad{harmonic(n)} returns the \\spad{n}th harmonic number. This is \\spad{H[n] = sum(1/k,k=1..n)}.")) (|fibonacci| (((|Integer|) (|Integer|)) "\\spad{fibonacci(n)} returns the \\spad{n}th Fibonacci number. the Fibonacci numbers \\spad{F[n]} are defined by \\spad{F[0] = F[1] = 1} and \\spad{F[n] = F[n-1] + F[n-2]}. The algorithm has running time \\spad{O(log(n)^3)}. Reference: Knuth, The Art of Computer Programming Vol 2, Semi-Numerical Algorithms.")) (|eulerPhi| (((|Integer|) (|Integer|)) "\\spad{eulerPhi(n)} returns the number of integers between 1 and \\spad{n} (including 1) which are relatively prime to \\spad{n.} This is the Euler phi function \\spad{\\phi(n)} is also called the totient function.")) (|euler| (((|Integer|) (|Integer|)) "\\spad{euler(n)} returns the \\spad{n}th Euler number. This is \\spad{2^n E(n,1/2)}, where \\spad{E(n,x)} is the \\spad{n}th Euler polynomial.")) (|divisors| (((|List| (|Integer|)) (|Integer|)) "\\spad{divisors(n)} returns a list of the divisors of \\spad{n.}")) (|chineseRemainder| (((|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{chineseRemainder(x1,m1,x2,m2)} returns \\spad{w,} where \\spad{w} is such that \\spad{w = \\spad{x1} mod \\spad{m1}} and \\spad{w = \\spad{x2} mod m2}. Note that \\spad{m1} and \\spad{m2} must be relatively prime.")) (|bernoulli| (((|Fraction| (|Integer|)) (|Integer|)) "\\spad{bernoulli(n)} returns the \\spad{n}th Bernoulli number. this is \\spad{B(n,0)}, where \\spad{B(n,x)} is the \\spad{n}th Bernoulli polynomial."))) 
NIL 
NIL 
(|AlgebraicHermiteIntegration| F UP UPUP R) 
((|constructor| (NIL "Algebraic Hermite reduction.")) (|HermiteIntegrate| (((|Record| (|:| |answer| |#4|) (|:| |logpart| |#4|)) |#4| (|Mapping| |#2| |#2|)) "\\spad{HermiteIntegrate(f, \\spad{')}} returns \\spad{[g,h]} such that \\spad{f = \\spad{g'} + \\spad{h}} and \\spad{h} has a only simple finite normal poles."))) 
NIL 
NIL 
(|TranscendentalHermiteIntegration| F UP) 
((|constructor| (NIL "Hermite integration, transcendental case.")) (|HermiteIntegrate| (((|Record| (|:| |answer| (|Fraction| |#2|)) (|:| |logpart| (|Fraction| |#2|)) (|:| |specpart| (|Fraction| |#2|)) (|:| |polypart| |#2|)) (|Fraction| |#2|) (|Mapping| |#2| |#2|)) "\\spad{HermiteIntegrate(f, \\spad{D)}} returns \\spad{[g, \\spad{h,} \\spad{s,} \\spad{p]}} such that \\spad{f = \\spad{Dg} + \\spad{h} + \\spad{s} + \\spad{p},} \\spad{h} has a squarefree denominator normal w.r.t. \\spad{D,} and all the squarefree factors of the denominator of \\spad{s} are special w.r.t. \\spad{D.} Furthermore, \\spad{h} and \\spad{s} have no polynomial parts. \\spad{D} is the derivation to use on \\spadtype{UP}."))) 
NIL 
NIL 
(|Integer|) 
((|constructor| (NIL "\\spadtype{Integer} provides the domain of arbitrary precision integers.")) (|infinite| ((|attribute|) "nextItem never returns \"failed\".")) (|noetherian| ((|attribute|) "ascending chain condition on ideals.")) (|canonicalsClosed| ((|attribute|) "two positives multiply to give positive.")) (|canonical| ((|attribute|) "mathematical equality is data structure equality.")) (|random| (($ $) "\\spad{random(n)} returns a random integer from 0 to \\spad{n-1}."))) 
((|infinite| . T) (|noetherian| . T) (|canonicalsClosed| . T) (|canonical| . T) (|canonicalUnitNormal| . T) (|multiplicativeValuation| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|AnnaNumericalIntegrationPackage|) 
((|constructor| (NIL "\\axiomType{AnnaNumericalIntegrationPackage} is a \\axiom{package} of functions for the \\axiom{category} \\axiomType{NumericalIntegrationCategory} with \\axiom{measure}, and \\axiom{integrate}.")) (|measure| (((|Record| (|:| |measure| (|Float|)) (|:| |name| (|String|)) (|:| |explanations| (|List| (|String|))) (|:| |extra| (|Result|))) (|NumericalIntegrationProblem|) (|RoutinesTable|)) "\\spad{measure(prob,R)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical integration problem defined by \\axiom{prob}. \\blankline It calls each \\axiom{domain} listed in \\axiom{R} of \\axiom{category} \\axiomType{NumericalIntegrationCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information.") (((|Record| (|:| |measure| (|Float|)) (|:| |name| (|String|)) (|:| |explanations| (|List| (|String|))) (|:| |extra| (|Result|))) (|NumericalIntegrationProblem|)) "\\spad{measure(prob)} is a top level ANNA function for identifying the most appropriate numerical routine for solving the numerical integration problem defined by \\axiom{prob}. \\blankline It calls each \\axiom{domain} of \\axiom{category} \\axiomType{NumericalIntegrationCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information.")) (|integrate| (((|Union| (|Result|) "failed") (|Expression| (|Float|)) (|SegmentBinding| (|OrderedCompletion| (|Float|))) (|Symbol|)) "\\spad{integrate(exp, \\spad{x} = a..b, numerical)} is a top level ANNA function to integrate an expression, {\\tt exp}, over a given range, {\\tt a} to {\\tt \\spad{b}.} \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}. \\blankline Default values for the absolute and relative error are used. \\blankline It is an error if the last argument is not {\\tt numerical}.") (((|Union| (|Result|) "failed") (|Expression| (|Float|)) (|SegmentBinding| (|OrderedCompletion| (|Float|))) (|String|)) "\\spad{integrate(exp, \\spad{x} = a..b, \"numerical\")} is a top level ANNA function to integrate an expression, {\\tt exp}, over a given range, {\\tt a} to {\\tt \\spad{b}.} \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}. \\blankline Default values for the absolute and relative error are used. \\blankline It is an error of the last argument is not {\\tt \"numerical\"}.") (((|Result|) (|Expression| (|Float|)) (|List| (|Segment| (|OrderedCompletion| (|Float|)))) (|Float|) (|Float|) (|RoutinesTable|)) "\\spad{integrate(exp, [a..b,c..d,...], epsabs, epsrel, routines)} is a top level ANNA function to integrate a multivariate expression, {\\tt exp}, over a given set of ranges to the required absolute and relative accuracy, using the routines available in the RoutinesTable provided. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}.") (((|Result|) (|Expression| (|Float|)) (|List| (|Segment| (|OrderedCompletion| (|Float|)))) (|Float|) (|Float|)) "\\spad{integrate(exp, [a..b,c..d,...], epsabs, epsrel)} is a top level ANNA function to integrate a multivariate expression, {\\tt exp}, over a given set of ranges to the required absolute and relative accuracy. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}.") (((|Result|) (|Expression| (|Float|)) (|List| (|Segment| (|OrderedCompletion| (|Float|)))) (|Float|)) "\\spad{integrate(exp, [a..b,c..d,...], epsrel)} is a top level ANNA function to integrate a multivariate expression, {\\tt exp}, over a given set of ranges to the required relative accuracy. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}. \\blankline If epsrel = 0, a default absolute accuracy is used.") (((|Result|) (|Expression| (|Float|)) (|List| (|Segment| (|OrderedCompletion| (|Float|))))) "\\spad{integrate(exp, [a..b,c..d,...])} is a top level ANNA function to integrate a multivariate expression, {\\tt exp}, over a given set of ranges. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}. \\blankline Default values for the absolute and relative error are used.") (((|Result|) (|Expression| (|Float|)) (|Segment| (|OrderedCompletion| (|Float|)))) "\\spad{integrate(exp, a..b)} is a top level ANNA function to integrate an expression, {\\tt exp}, over a given range {\\tt a} to {\\tt \\spad{b}.} \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}. \\blankline Default values for the absolute and relative error are used.") (((|Result|) (|Expression| (|Float|)) (|Segment| (|OrderedCompletion| (|Float|))) (|Float|)) "\\spad{integrate(exp, a..b, epsrel)} is a top level ANNA function to integrate an expression, {\\tt exp}, over a given range {\\tt a} to {\\tt \\spad{b}} to the required relative accuracy. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}. \\blankline If epsrel = 0, a default absolute accuracy is used.") (((|Result|) (|Expression| (|Float|)) (|Segment| (|OrderedCompletion| (|Float|))) (|Float|) (|Float|)) "\\spad{integrate(exp, a..b, epsabs, epsrel)} is a top level ANNA function to integrate an expression, {\\tt exp}, over a given range {\\tt a} to {\\tt \\spad{b}} to the required absolute and relative accuracy. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}.") (((|Result|) (|NumericalIntegrationProblem|)) "\\spad{integrate(IntegrationProblem)} is a top level ANNA function to integrate an expression over a given range or ranges to the required absolute and relative accuracy. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}.") (((|Result|) (|Expression| (|Float|)) (|Segment| (|OrderedCompletion| (|Float|))) (|Float|) (|Float|) (|RoutinesTable|)) "\\spad{integrate(exp, a..b, epsrel, routines)} is a top level ANNA function to integrate an expression, {\\tt exp}, over a given range {\\tt a} to {\\tt \\spad{b}} to the required absolute and relative accuracy using the routines available in the RoutinesTable provided. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline It then performs the integration of the given expression on that \\axiom{domain}."))) 
NIL 
NIL 
(|PureAlgebraicIntegration| R F L) 
((|constructor| (NIL "Integration of pure algebraic functions; This package provides functions for integration, limited integration, extended integration and the risch differential equation for pure algebraic integrands.")) (|palgLODE| (((|Record| (|:| |particular| (|Union| |#2| "failed")) (|:| |basis| (|List| |#2|))) |#3| |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|Symbol|)) "\\spad{palgLODE(op, \\spad{g,} \\spad{kx,} \\spad{y,} \\spad{x)}} returns the solution of \\spad{op \\spad{f} = \\spad{g}.} \\spad{y} is an algebraic function of \\spad{x.}")) (|palgRDE| (((|Union| |#2| "failed") |#2| |#2| |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|Mapping| (|Union| |#2| "failed") |#2| |#2| (|Symbol|))) "\\spad{palgRDE(nfp, \\spad{f,} \\spad{g,} \\spad{x,} \\spad{y,} foo)} returns a function \\spad{z(x,y)} such that \\spad{dz/dx + \\spad{n} * df/dx z(x,y) = g(x,y)} if such a \\spad{z} exists, \"failed\" otherwise; \\spad{y} is an algebraic function of \\spad{x;} \\spad{foo(a, \\spad{b,} \\spad{x)}} is a function that solves \\spad{du/dx + \\spad{n} * da/dx u(x) = u(x)} for an unknown \\spad{u(x)} not involving \\spad{y.} \\spad{nfp} is \\spad{n * df/dx}.")) (|palglimint| (((|Union| (|Record| (|:| |mainpart| |#2|) (|:| |limitedlogs| (|List| (|Record| (|:| |coeff| |#2|) (|:| |logand| |#2|))))) "failed") |#2| (|Kernel| |#2|) (|Kernel| |#2|) (|List| |#2|)) "\\spad{palglimint(f, \\spad{x,} \\spad{y,} [u1,...,un])} returns functions \\spad{[h,[[ci, ui]]]} such that the ui's are among \\spad{[u1,...,un]} and \\spad{d(h + sum(ci log(ui)))/dx = f(x,y)} if such functions exist, \"failed\" otherwise; \\spad{y} is an algebraic function of \\spad{x.}")) (|palgextint| (((|Union| (|Record| (|:| |ratpart| |#2|) (|:| |coeff| |#2|)) "failed") |#2| (|Kernel| |#2|) (|Kernel| |#2|) |#2|) "\\spad{palgextint(f, \\spad{x,} \\spad{y,} \\spad{g)}} returns functions \\spad{[h, \\spad{c]}} such that \\spad{dh/dx = f(x,y) - \\spad{c} \\spad{g},} where \\spad{y} is an algebraic function of \\spad{x;} returns \"failed\" if no such functions exist.")) (|palgint| (((|IntegrationResult| |#2|) |#2| (|Kernel| |#2|) (|Kernel| |#2|)) "\\spad{palgint(f, \\spad{x,} \\spad{y)}} returns the integral of \\spad{f(x,y)dx} where \\spad{y} is an algebraic function of \\spad{x.}"))) 
NIL 
((|HasCategory| |#3| (LIST (QUOTE |LinearOrdinaryDifferentialOperatorCategory|) (|devaluate| |#2|)))) 
(|PatternMatchIntegration| R F) 
((|constructor| (NIL "\\spadtype{PatternMatchIntegration} provides functions that use the pattern matcher to find some indefinite and definite integrals involving special functions and found in the litterature.")) (|pmintegrate| (((|Union| |#2| "failed") |#2| (|Symbol|) (|OrderedCompletion| |#2|) (|OrderedCompletion| |#2|)) "\\spad{pmintegrate(f, \\spad{x} = a..b)} returns the integral of \\spad{f(x)dx} from a to \\spad{b} if it can be found by the built-in pattern matching rules.") (((|Union| (|Record| (|:| |special| |#2|) (|:| |integrand| |#2|)) "failed") |#2| (|Symbol|)) "\\spad{pmintegrate(f, \\spad{x)}} returns either \"failed\" or \\spad{[g,h]} such that \\spad{integrate(f,x) = \\spad{g} + integrate(h,x)}.")) (|pmComplexintegrate| (((|Union| (|Record| (|:| |special| |#2|) (|:| |integrand| |#2|)) "failed") |#2| (|Symbol|)) "\\spad{pmComplexintegrate(f, \\spad{x)}} returns either \"failed\" or \\spad{[g,h]} such that \\spad{integrate(f,x) = \\spad{g} + integrate(h,x)}. It only looks for special complex integrals that pmintegrate does not return.")) (|splitConstant| (((|Record| (|:| |const| |#2|) (|:| |nconst| |#2|)) |#2| (|Symbol|)) "\\spad{splitConstant(f, \\spad{x)}} returns \\spad{[c, \\spad{g]}} such that \\spad{f = \\spad{c} * \\spad{g}} and \\spad{c} does not involve \\spad{t}."))) 
NIL 
((AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|SpecialFunctionCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|LiouvillianFunctionCategory|))))) 
(|RationalIntegration| F UP) 
((|constructor| (NIL "Rational function integration This package provides functions for the base case of the Risch algorithm.")) (|limitedint| (((|Union| (|Record| (|:| |mainpart| (|Fraction| |#2|)) (|:| |limitedlogs| (|List| (|Record| (|:| |coeff| (|Fraction| |#2|)) (|:| |logand| (|Fraction| |#2|)))))) "failed") (|Fraction| |#2|) (|List| (|Fraction| |#2|))) "\\spad{limitedint(f, [g1,...,gn])} returns fractions \\spad{[h,[[ci, gi]]]} such that the gi's are among \\spad{[g1,...,gn]}, \\spad{ci' = 0}, and \\spad{(h+sum(ci log(gi)))' = \\spad{f},} if possible, \"failed\" otherwise.")) (|extendedint| (((|Union| (|Record| (|:| |ratpart| (|Fraction| |#2|)) (|:| |coeff| (|Fraction| |#2|))) "failed") (|Fraction| |#2|) (|Fraction| |#2|)) "\\spad{extendedint(f, \\spad{g)}} returns fractions \\spad{[h, \\spad{c]}} such that \\spad{c' = 0} and \\spad{h' = \\spad{f} - cg}, if \\spad{(h, \\spad{c)}} exist, \"failed\" otherwise.")) (|infieldint| (((|Union| (|Fraction| |#2|) "failed") (|Fraction| |#2|)) "\\spad{infieldint(f)} returns \\spad{g} such that \\spad{g' = \\spad{f}} or \"failed\" if the integral of \\spad{f} is not a rational function.")) (|integrate| (((|IntegrationResult| (|Fraction| |#2|)) (|Fraction| |#2|)) "\\spad{integrate(f)} returns \\spad{g} such that \\spad{g' = \\spad{f}.}"))) 
NIL 
NIL 
(|IntegerRetractions| S) 
((|constructor| (NIL "Provides integer testing and retraction functions.")) (|integerIfCan| (((|Union| (|Integer|) "failed") |#1|) "\\spad{integerIfCan(x)} returns \\spad{x} as an integer, \"failed\" if \\spad{x} is not an integer.")) (|integer?| (((|Boolean|) |#1|) "\\spad{integer?(x)} is \\spad{true} if \\spad{x} is an integer, \\spad{false} otherwise.")) (|integer| (((|Integer|) |#1|) "\\spad{integer(x)} returns \\spad{x} as an integer; error if \\spad{x} is not an integer."))) 
NIL 
NIL 
(|RationalFunctionIntegration| F) 
((|constructor| (NIL "This package provides functions for the integration of rational functions.")) (|extendedIntegrate| (((|Union| (|Record| (|:| |ratpart| (|Fraction| (|Polynomial| |#1|))) (|:| |coeff| (|Fraction| (|Polynomial| |#1|)))) "failed") (|Fraction| (|Polynomial| |#1|)) (|Symbol|) (|Fraction| (|Polynomial| |#1|))) "\\spad{extendedIntegrate(f, \\spad{x,} \\spad{g)}} returns fractions \\spad{[h, \\spad{c]}} such that \\spad{dc/dx = 0} and \\spad{dh/dx = \\spad{f} - cg}, if \\spad{(h, \\spad{c)}} exist, \"failed\" otherwise.")) (|limitedIntegrate| (((|Union| (|Record| (|:| |mainpart| (|Fraction| (|Polynomial| |#1|))) (|:| |limitedlogs| (|List| (|Record| (|:| |coeff| (|Fraction| (|Polynomial| |#1|))) (|:| |logand| (|Fraction| (|Polynomial| |#1|))))))) "failed") (|Fraction| (|Polynomial| |#1|)) (|Symbol|) (|List| (|Fraction| (|Polynomial| |#1|)))) "\\spad{limitedIntegrate(f, \\spad{x,} [g1,...,gn])} returns fractions \\spad{[h, [[ci,gi]]]} such that the gi's are among \\spad{[g1,...,gn]}, \\spad{dci/dx = 0}, and \\spad{d(h + sum(ci log(gi)))/dx = \\spad{f}} if possible, \"failed\" otherwise.")) (|infieldIntegrate| (((|Union| (|Fraction| (|Polynomial| |#1|)) "failed") (|Fraction| (|Polynomial| |#1|)) (|Symbol|)) "\\spad{infieldIntegrate(f, \\spad{x)}} returns a fraction \\spad{g} such that \\spad{dg/dx = \\spad{f}} if \\spad{g} exists, \"failed\" otherwise.")) (|internalIntegrate| (((|IntegrationResult| (|Fraction| (|Polynomial| |#1|))) (|Fraction| (|Polynomial| |#1|)) (|Symbol|)) "\\spad{internalIntegrate(f, \\spad{x)}} returns \\spad{g} such that \\spad{dg/dx = \\spad{f}.}"))) 
NIL 
NIL 
(|Interval| R) 
((|constructor| (NIL "This domain is an implementation of interval arithmetic and transcendental functions over intervals."))) 
((|approximate| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|IntegerSolveLinearPolynomialEquation|) 
((|constructor| (NIL "This package provides the implementation for the \\spadfun{solveLinearPolynomialEquation} operation over the integers. It uses a lifting technique from the package GenExEuclid")) (|solveLinearPolynomialEquation| (((|Union| (|List| (|SparseUnivariatePolynomial| (|Integer|))) "failed") (|List| (|SparseUnivariatePolynomial| (|Integer|))) (|SparseUnivariatePolynomial| (|Integer|))) "\\spad{solveLinearPolynomialEquation([f1, ..., fn], \\spad{g)}} (where the \\spad{fi} are relatively prime to each other) returns a list of \\spad{ai} such that \\spad{g/prod \\spad{fi} = sum ai/fi} or returns \"failed\" if no such list of ai's exists."))) 
NIL 
NIL 
(|IntegrationTools| R F) 
((|constructor| (NIL "Tools for the integrator")) (|intPatternMatch| (((|IntegrationResult| |#2|) |#2| (|Symbol|) (|Mapping| (|IntegrationResult| |#2|) |#2| (|Symbol|)) (|Mapping| (|Union| (|Record| (|:| |special| |#2|) (|:| |integrand| |#2|)) "failed") |#2| (|Symbol|))) "\\spad{intPatternMatch(f, \\spad{x,} int, pmint)} tries to integrate \\spad{f} first by using the integration function \\spad{int}, and then by using the pattern match intetgration function \\spad{pmint} on any remaining unintegrable part.")) (|mkPrim| ((|#2| |#2| (|Symbol|)) "\\spad{mkPrim(f, \\spad{x)}} makes the logs in \\spad{f} which are linear in \\spad{x} primitive with respect to \\spad{x.}")) (|removeConstantTerm| ((|#2| |#2| (|Symbol|)) "\\spad{removeConstantTerm(f, \\spad{x)}} returns \\spad{f} minus any additive constant with respect to \\spad{x.}")) (|vark| (((|List| (|Kernel| |#2|)) (|List| |#2|) (|Symbol|)) "\\spad{vark([f1,...,fn],x)} returns the set-theoretic union of \\spad{(varselect(f1,x),...,varselect(fn,x))}.")) (|union| (((|List| (|Kernel| |#2|)) (|List| (|Kernel| |#2|)) (|List| (|Kernel| |#2|))) "\\spad{union(l1, l2)} returns set-theoretic union of \\spad{l1} and \\spad{l2.}")) (|ksec| (((|Kernel| |#2|) (|Kernel| |#2|) (|List| (|Kernel| |#2|)) (|Symbol|)) "\\spad{ksec(k, [k1,...,kn], \\spad{x)}} returns the second top-level \\spad{ki} after \\spad{k} involving \\spad{x.}")) (|kmax| (((|Kernel| |#2|) (|List| (|Kernel| |#2|))) "\\spad{kmax([k1,...,kn])} returns the top-level \\spad{ki} for integration.")) (|varselect| (((|List| (|Kernel| |#2|)) (|List| (|Kernel| |#2|)) (|Symbol|)) "\\spad{varselect([k1,...,kn], \\spad{x)}} returns the \\spad{ki} which involve \\spad{x.}"))) 
NIL 
((AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|ElementaryFunctionCategory|))) (|HasCategory| |#2| (QUOTE (|LiouvillianFunctionCategory|)))) (AND (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|ElementaryFunctionCategory|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) 
(|TranscendentalIntegration| F UP) 
((|constructor| (NIL "This package provides functions for the transcendental case of the Risch algorithm.")) (|monomialIntPoly| (((|Record| (|:| |answer| |#2|) (|:| |polypart| |#2|)) |#2| (|Mapping| |#2| |#2|)) "\\spad{monomialIntPoly(p, \\spad{')}} returns \\spad{[q,} \\spad{r]} such that \\spad{p = \\spad{q'} + \\spad{r}} and \\spad{degree(r) < degree(t')}. Error if \\spad{degree(t') < 2}.")) (|monomialIntegrate| (((|Record| (|:| |ir| (|IntegrationResult| (|Fraction| |#2|))) (|:| |specpart| (|Fraction| |#2|)) (|:| |polypart| |#2|)) (|Fraction| |#2|) (|Mapping| |#2| |#2|)) "\\spad{monomialIntegrate(f, \\spad{')}} returns \\spad{[ir, \\spad{s,} \\spad{p]}} such that \\spad{f = ir' + \\spad{s} + \\spad{p}} and all the squarefree factors of the denominator of \\spad{s} are special w.r.t the derivation \\spad{'.}")) (|expintfldpoly| (((|Union| (|LaurentPolynomial| |#1| |#2|) "failed") (|LaurentPolynomial| |#1| |#2|) (|Mapping| (|Record| (|:| |ans| |#1|) (|:| |right| |#1|) (|:| |sol?| (|Boolean|))) (|Integer|) |#1|)) "\\spad{expintfldpoly(p, foo)} returns \\spad{q} such that \\spad{p' = \\spad{q}} or \"failed\" if no such \\spad{q} exists. Argument foo is a Risch differential equation function on \\spad{F.}")) (|primintfldpoly| (((|Union| |#2| "failed") |#2| (|Mapping| (|Union| (|Record| (|:| |ratpart| |#1|) (|:| |coeff| |#1|)) "failed") |#1|) |#1|) "\\spad{primintfldpoly(p, \\spad{',} t')} returns \\spad{q} such that \\spad{p' = \\spad{q}} or \"failed\" if no such \\spad{q} exists. Argument \\spad{t'} is the derivative of the primitive generating the extension.")) (|primlimintfrac| (((|Union| (|Record| (|:| |mainpart| (|Fraction| |#2|)) (|:| |limitedlogs| (|List| (|Record| (|:| |coeff| (|Fraction| |#2|)) (|:| |logand| (|Fraction| |#2|)))))) "failed") (|Fraction| |#2|) (|Mapping| |#2| |#2|) (|List| (|Fraction| |#2|))) "\\spad{primlimintfrac(f, \\spad{',} [u1,...,un])} returns \\spad{[v, [c1,...,cn]]} such that \\spad{ci' = 0} and \\spad{f = \\spad{v'} + +/[ci * ui'/ui]}. Error: if \\spad{degree numer \\spad{f} \\spad{>=} degree denom \\spad{f}.}")) (|primextintfrac| (((|Union| (|Record| (|:| |ratpart| (|Fraction| |#2|)) (|:| |coeff| (|Fraction| |#2|))) "failed") (|Fraction| |#2|) (|Mapping| |#2| |#2|) (|Fraction| |#2|)) "\\spad{primextintfrac(f, \\spad{',} \\spad{g)}} returns \\spad{[v, \\spad{c]}} such that \\spad{f = \\spad{v'} + \\spad{c} \\spad{g}} and \\spad{c' = 0}. Error: if \\spad{degree numer \\spad{f} \\spad{>=} degree denom \\spad{f}} or if \\spad{degree numer \\spad{g} \\spad{>=} degree denom \\spad{g}} or if \\spad{denom \\spad{g}} is not squarefree.")) (|explimitedint| (((|Union| (|Record| (|:| |answer| (|Record| (|:| |mainpart| (|Fraction| |#2|)) (|:| |limitedlogs| (|List| (|Record| (|:| |coeff| (|Fraction| |#2|)) (|:| |logand| (|Fraction| |#2|))))))) (|:| |a0| |#1|)) "failed") (|Fraction| |#2|) (|Mapping| |#2| |#2|) (|Mapping| (|Record| (|:| |ans| |#1|) (|:| |right| |#1|) (|:| |sol?| (|Boolean|))) (|Integer|) |#1|) (|List| (|Fraction| |#2|))) "\\spad{explimitedint(f, \\spad{',} foo, [u1,...,un])} returns \\spad{[v, [c1,...,cn], a]} such that \\spad{ci' = 0}, \\spad{f = \\spad{v'} + a + reduce(+,[ci * ui'/ui])}, and \\spad{a = 0} or \\spad{a} has no integral in \\spad{F.} Returns \"failed\" if no such \\spad{v,} ci, a exist. Argument \\spad{foo} is a Risch differential equation function on \\spad{F.}")) (|primlimitedint| (((|Union| (|Record| (|:| |answer| (|Record| (|:| |mainpart| (|Fraction| |#2|)) (|:| |limitedlogs| (|List| (|Record| (|:| |coeff| (|Fraction| |#2|)) (|:| |logand| (|Fraction| |#2|))))))) (|:| |a0| |#1|)) "failed") (|Fraction| |#2|) (|Mapping| |#2| |#2|) (|Mapping| (|Union| (|Record| (|:| |ratpart| |#1|) (|:| |coeff| |#1|)) "failed") |#1|) (|List| (|Fraction| |#2|))) "\\spad{primlimitedint(f, \\spad{',} foo, [u1,...,un])} returns \\spad{[v, [c1,...,cn], a]} such that \\spad{ci' = 0}, \\spad{f = \\spad{v'} + a + reduce(+,[ci * ui'/ui])}, and \\spad{a = 0} or \\spad{a} has no integral in UP. Returns \"failed\" if no such \\spad{v,} ci, a exist. Argument \\spad{foo} is an extended integration function on \\spad{F.}")) (|expextendedint| (((|Union| (|Record| (|:| |answer| (|Fraction| |#2|)) (|:| |a0| |#1|)) (|Record| (|:| |ratpart| (|Fraction| |#2|)) (|:| |coeff| (|Fraction| |#2|))) "failed") (|Fraction| |#2|) (|Mapping| |#2| |#2|) (|Mapping| (|Record| (|:| |ans| |#1|) (|:| |right| |#1|) (|:| |sol?| (|Boolean|))) (|Integer|) |#1|) (|Fraction| |#2|)) "\\spad{expextendedint(f, \\spad{',} foo, \\spad{g)}} returns either \\spad{[v, \\spad{c]}} such that \\spad{f = \\spad{v'} + \\spad{c} \\spad{g}} and \\spad{c' = 0}, or \\spad{[v, a]} such that \\spad{f = \\spad{g'} + a}, and \\spad{a = 0} or \\spad{a} has no integral in \\spad{F.} Returns \"failed\" if neither case can hold. Argument \\spad{foo} is a Risch differential equation function on \\spad{F.}")) (|primextendedint| (((|Union| (|Record| (|:| |answer| (|Fraction| |#2|)) (|:| |a0| |#1|)) (|Record| (|:| |ratpart| (|Fraction| |#2|)) (|:| |coeff| (|Fraction| |#2|))) "failed") (|Fraction| |#2|) (|Mapping| |#2| |#2|) (|Mapping| (|Union| (|Record| (|:| |ratpart| |#1|) (|:| |coeff| |#1|)) "failed") |#1|) (|Fraction| |#2|)) "\\spad{primextendedint(f, \\spad{',} foo, \\spad{g)}} returns either \\spad{[v, \\spad{c]}} such that \\spad{f = \\spad{v'} + \\spad{c} \\spad{g}} and \\spad{c' = 0}, or \\spad{[v, a]} such that \\spad{f = \\spad{g'} + a}, and \\spad{a = 0} or \\spad{a} has no integral in UP. Returns \"failed\" if neither case can hold. Argument \\spad{foo} is an extended integration function on \\spad{F.}")) (|tanintegrate| (((|Record| (|:| |answer| (|IntegrationResult| (|Fraction| |#2|))) (|:| |a0| |#1|)) (|Fraction| |#2|) (|Mapping| |#2| |#2|) (|Mapping| (|Union| (|List| |#1|) "failed") (|Integer|) |#1| |#1|)) "\\spad{tanintegrate(f, \\spad{',} foo)} returns \\spad{[g, a]} such that \\spad{f = \\spad{g'} + a}, and \\spad{a = 0} or \\spad{a} has no integral in \\spad{F;} Argument foo is a Risch differential system solver on \\spad{F;}")) (|expintegrate| (((|Record| (|:| |answer| (|IntegrationResult| (|Fraction| |#2|))) (|:| |a0| |#1|)) (|Fraction| |#2|) (|Mapping| |#2| |#2|) (|Mapping| (|Record| (|:| |ans| |#1|) (|:| |right| |#1|) (|:| |sol?| (|Boolean|))) (|Integer|) |#1|)) "\\spad{expintegrate(f, \\spad{',} foo)} returns \\spad{[g, a]} such that \\spad{f = \\spad{g'} + a}, and \\spad{a = 0} or \\spad{a} has no integral in \\spad{F;} Argument foo is a Risch differential equation solver on \\spad{F;}")) (|primintegrate| (((|Record| (|:| |answer| (|IntegrationResult| (|Fraction| |#2|))) (|:| |a0| |#1|)) (|Fraction| |#2|) (|Mapping| |#2| |#2|) (|Mapping| (|Union| (|Record| (|:| |ratpart| |#1|) (|:| |coeff| |#1|)) "failed") |#1|)) "\\spad{primintegrate(f, \\spad{',} foo)} returns \\spad{[g, a]} such that \\spad{f = \\spad{g'} + a}, and \\spad{a = 0} or \\spad{a} has no integral in UP. Argument foo is an extended integration function on \\spad{F.}"))) 
NIL 
NIL 
(|InverseLaplaceTransform| R F) 
((|constructor| (NIL "This package computes the inverse Laplace Transform.")) (|inverseLaplace| (((|Union| |#2| "failed") |#2| (|Symbol|) (|Symbol|)) "\\spad{inverseLaplace(f, \\spad{s,} \\spad{t)}} returns the Inverse Laplace transform of \\spad{f(s)} using \\spad{t} as the new variable or \"failed\" if unable to find a closed form. Handles only rational \\spad{f(s)}."))) 
NIL 
NIL 
(|InnerPAdicInteger| |p| |unBalanced?|) 
((|constructor| (NIL "This domain implements \\spad{Zp,} the p-adic completion of the integers. This is an internal domain."))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|InnerPrimeField| |p|) 
((|constructor| (NIL "InnerPrimeField(p) implements the field with \\spad{p} elements."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| $ (QUOTE (|CharacteristicZero|))) (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| $ (QUOTE (|Finite|)))) 
(|InternalPrintPackage|) 
((|constructor| (NIL "A package to print strings without line-feed nor carriage-return.")) (|iprint| (((|Void|) (|String|)) "\\axiom{iprint(s)} prints \\axiom{s} at the current position of the cursor."))) 
NIL 
NIL 
(|IntegrationResultToFunction| R F) 
((|constructor| (NIL "Conversion of integration results to top-level expressions This package allows a sum of logs over the roots of a polynomial to be expressed as explicit logarithms and arc tangents, provided that the indexing polynomial can be factored into quadratics.")) (|complexExpand| ((|#2| (|IntegrationResult| |#2|)) "\\spad{complexExpand(i)} returns the expanded complex function corresponding to i.")) (|expand| (((|List| |#2|) (|IntegrationResult| |#2|)) "\\spad{expand(i)} returns the list of possible real functions corresponding to i.")) (|split| (((|IntegrationResult| |#2|) (|IntegrationResult| |#2|)) "\\spad{split(u(x) + sum_{P(a)=0} Q(a,x))} returns \\spad{u(x) + sum_{P1(a)=0} Q(a,x) + \\spad{...} + sum_{Pn(a)=0} Q(a,x)} where P1,...,Pn are the factors of \\spad{P.}"))) 
NIL 
NIL 
(|IntegrationResultFunctions2| E F) 
((|constructor| (NIL "Internally used by the integration packages")) (|map| (((|Union| (|Record| (|:| |mainpart| |#2|) (|:| |limitedlogs| (|List| (|Record| (|:| |coeff| |#2|) (|:| |logand| |#2|))))) "failed") (|Mapping| |#2| |#1|) (|Union| (|Record| (|:| |mainpart| |#1|) (|:| |limitedlogs| (|List| (|Record| (|:| |coeff| |#1|) (|:| |logand| |#1|))))) "failed")) "\\spad{map(f,ufe)} \\undocumented") (((|Union| |#2| "failed") (|Mapping| |#2| |#1|) (|Union| |#1| "failed")) "\\spad{map(f,ue)} \\undocumented") (((|Union| (|Record| (|:| |ratpart| |#2|) (|:| |coeff| |#2|)) "failed") (|Mapping| |#2| |#1|) (|Union| (|Record| (|:| |ratpart| |#1|) (|:| |coeff| |#1|)) "failed")) "\\spad{map(f,ure)} \\undocumented") (((|IntegrationResult| |#2|) (|Mapping| |#2| |#1|) (|IntegrationResult| |#1|)) "\\spad{map(f,ire)} \\undocumented"))) 
NIL 
NIL 
(|IntegrationResult| F) 
((|constructor| (NIL "The result of a transcendental integration. If a function \\spad{f} has an elementary integral \\spad{g,} then \\spad{g} can be written in the form \\spad{g = \\spad{h} + \\spad{c1} log(u1) + \\spad{c2} log(u2) + \\spad{...} + \\spad{cn} log(un)} where \\spad{h,} which is in the same field than \\spad{f,} is called the rational part of the integral, and \\spad{c1 log(u1) + \\spad{...} \\spad{cn} log(un)} is called the logarithmic part of the integral. This domain manipulates integrals represented in that form, by keeping both parts separately. The logs are not explicitly computed.")) (|differentiate| ((|#1| $ (|Symbol|)) "\\spad{differentiate(ir,x)} differentiates \\spad{ir} with respect to \\spad{x}") ((|#1| $ (|Mapping| |#1| |#1|)) "\\spad{differentiate(ir,D)} differentiates \\spad{ir} with respect to the derivation \\spad{D.}")) (|integral| (($ |#1| (|Symbol|)) "\\spad{integral(f,x)} returns the formal integral of \\spad{f} with respect to \\spad{x}") (($ |#1| |#1|) "\\spad{integral(f,x)} returns the formal integral of \\spad{f} with respect to \\spad{x}")) (|elem?| (((|Boolean|) $) "\\spad{elem?(ir)} tests if an integration result is elementary over \\spad{F?}")) (|notelem| (((|List| (|Record| (|:| |integrand| |#1|) (|:| |intvar| |#1|))) $) "\\spad{notelem(ir)} returns the non-elementary part of an integration result")) (|logpart| (((|List| (|Record| (|:| |scalar| (|Fraction| (|Integer|))) (|:| |coeff| (|SparseUnivariatePolynomial| |#1|)) (|:| |logand| (|SparseUnivariatePolynomial| |#1|)))) $) "\\spad{logpart(ir)} returns the logarithmic part of an integration result")) (|ratpart| ((|#1| $) "\\spad{ratpart(ir)} returns the rational part of an integration result")) (|mkAnswer| (($ |#1| (|List| (|Record| (|:| |scalar| (|Fraction| (|Integer|))) (|:| |coeff| (|SparseUnivariatePolynomial| |#1|)) (|:| |logand| (|SparseUnivariatePolynomial| |#1|)))) (|List| (|Record| (|:| |integrand| |#1|) (|:| |intvar| |#1|)))) "\\spad{mkAnswer(r,l,ne)} creates an integration result from a rational part \\spad{r,} a logarithmic part \\spad{l,} and a non-elementary part ne."))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|))))) 
(|IntegerRoots| I) 
((|constructor| (NIL "The \\spadtype{IntegerRoots} package computes square roots and \\spad{n}th roots of integers efficiently.")) (|approxSqrt| ((|#1| |#1|) "\\spad{approxSqrt(n)} returns an approximation \\spad{x} to \\spad{sqrt(n)} such that \\spad{-1 < \\spad{x} - sqrt(n) < 1}. Compute an approximation \\spad{s} to \\spad{sqrt(n)} such that \\indented{10}{\\spad{-1 < \\spad{s} - sqrt(n) < 1}} A variable precision Newton iteration is used. The running time is \\spad{O( \\spad{log(n)**2} \\spad{)}.}")) (|perfectSqrt| (((|Union| |#1| "failed") |#1|) "\\spad{perfectSqrt(n)} returns the square root of \\spad{n} if \\spad{n} is a perfect square and returns \"failed\" otherwise")) (|perfectSquare?| (((|Boolean|) |#1|) "\\spad{perfectSquare?(n)} returns \\spad{true} if \\spad{n} is a perfect square and \\spad{false} otherwise")) (|approxNthRoot| ((|#1| |#1| (|NonNegativeInteger|)) "\\spad{approxRoot(n,r)} returns an approximation \\spad{x} to \\spad{n**(1/r)} such that \\spad{-1 < \\spad{x} - n**(1/r) < 1}")) (|perfectNthRoot| (((|Record| (|:| |base| |#1|) (|:| |exponent| (|NonNegativeInteger|))) |#1|) "\\spad{perfectNthRoot(n)} returns \\spad{[x,r]}, where \\spad{n = x\\^r} and \\spad{r} is the largest integer such that \\spad{n} is a perfect \\spad{r}th power") (((|Union| |#1| "failed") |#1| (|NonNegativeInteger|)) "\\spad{perfectNthRoot(n,r)} returns the \\spad{r}th root of \\spad{n} if \\spad{n} is an \\spad{r}th power and returns \"failed\" otherwise")) (|perfectNthPower?| (((|Boolean|) |#1| (|NonNegativeInteger|)) "\\spad{perfectNthPower?(n,r)} returns \\spad{true} if \\spad{n} is an \\spad{r}th power and \\spad{false} otherwise"))) 
NIL 
NIL 
(|IrredPolyOverFiniteField| GF) 
((|constructor| (NIL "This package exports the function generateIrredPoly that computes a monic irreducible polynomial of degree \\spad{n} over a finite field.")) (|generateIrredPoly| (((|SparseUnivariatePolynomial| |#1|) (|PositiveInteger|)) "\\spad{generateIrredPoly(n)} generates an irreducible univariate polynomial of the given degree \\spad{n} over the finite field."))) 
NIL 
NIL 
(|IntegrationResultRFToFunction| R) 
((|constructor| (NIL "Conversion of integration results to top-level expressions. This package allows a sum of logs over the roots of a polynomial to be expressed as explicit logarithms and arc tangents, provided that the indexing polynomial can be factored into quadratics.")) (|complexIntegrate| (((|Expression| |#1|) (|Fraction| (|Polynomial| |#1|)) (|Symbol|)) "\\spad{complexIntegrate(f, \\spad{x)}} returns the integral of \\spad{f(x)dx} where \\spad{x} is viewed as a complex variable.")) (|integrate| (((|Union| (|Expression| |#1|) (|List| (|Expression| |#1|))) (|Fraction| (|Polynomial| |#1|)) (|Symbol|)) "\\spad{integrate(f, \\spad{x)}} returns the integral of \\spad{f(x)dx} where \\spad{x} is viewed as a real variable..")) (|complexExpand| (((|Expression| |#1|) (|IntegrationResult| (|Fraction| (|Polynomial| |#1|)))) "\\spad{complexExpand(i)} returns the expanded complex function corresponding to i.")) (|expand| (((|List| (|Expression| |#1|)) (|IntegrationResult| (|Fraction| (|Polynomial| |#1|)))) "\\spad{expand(i)} returns the list of possible real functions corresponding to i.")) (|split| (((|IntegrationResult| (|Fraction| (|Polynomial| |#1|))) (|IntegrationResult| (|Fraction| (|Polynomial| |#1|)))) "\\spad{split(u(x) + sum_{P(a)=0} Q(a,x))} returns \\spad{u(x) + sum_{P1(a)=0} Q(a,x) + \\spad{...} + sum_{Pn(a)=0} Q(a,x)} where P1,...,Pn are the factors of \\spad{P.}"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|CharacteristicZero|)))) 
(|IrrRepSymNatPackage|) 
((|constructor| (NIL "IrrRepSymNatPackage contains functions for computing the ordinary irreducible representations of symmetric groups on \\spad{n} letters {1,2,...,n} in Young's natural form and their dimensions. These representations can be labelled by number partitions of \\spad{n,} \\spadignore{i.e.} a weakly decreasing sequence of integers summing up to \\spad{n,} \\spadignore{e.g.} [3,3,3,1] labels an irreducible representation for \\spad{n} equals 10. Note that whenever a \\spadtype{List Integer} appears in a signature, a partition required.")) (|irreducibleRepresentation| (((|List| (|Matrix| (|Integer|))) (|List| (|Integer|)) (|List| (|Permutation| (|Integer|)))) "\\spad{irreducibleRepresentation(lambda,listOfPerm)} is the list of the irreducible representations corresponding to \\spad{lambda} in Young's natural form for the list of permutations given by listOfPerm.") (((|List| (|Matrix| (|Integer|))) (|List| (|Integer|))) "\\spad{irreducibleRepresentation(lambda)} is the list of the two irreducible representations corresponding to the partition \\spad{lambda} in Young's natural form for the following two generators of the symmetric group, whose elements permute {1,2,...,n}, namely \\spad{(1} 2) (2-cycle) and \\spad{(1} 2 \\spad{...} \\spad{n)} (n-cycle).") (((|Matrix| (|Integer|)) (|List| (|Integer|)) (|Permutation| (|Integer|))) "\\spad{irreducibleRepresentation(lambda,pi)} is the irreducible representation corresponding to partition \\spad{lambda} in Young's natural form of the permutation \\spad{pi} in the symmetric group, whose elements permute {1,2,...,n}.")) (|dimensionOfIrreducibleRepresentation| (((|NonNegativeInteger|) (|List| (|Integer|))) "\\spad{dimensionOfIrreducibleRepresentation(lambda)} is the dimension of the ordinary irreducible representation of the symmetric group corresponding to lambda. Note that the Robinson-Thrall hook formula is implemented."))) 
NIL 
NIL 
(|InternalRationalUnivariateRepresentationPackage| R E V P TS) 
((|constructor| (NIL "\\indented{1}{Author: Marc Moreno Maza} Date Created: 01/1999 Date Last Updated: 23/01/1999 References: \\indented{1}{[1] \\spad{D.} LAZARD \"Solving Zero-dimensional Algebraic Systems\"} \\indented{5}{Journal of Symbolic Computation, 1992, 13, 117-131} Description:")) (|checkRur| (((|Boolean|) |#5| (|List| |#5|)) "\\spad{checkRur(ts,lus)} returns \\spad{true} if \\spad{lus} is a rational univariate representation of \\spad{ts}.")) (|rur| (((|List| |#5|) |#5| (|Boolean|)) "\\spad{rur(ts,univ?)} returns a rational univariate representation of \\spad{ts}. This assumes that the lowest polynomial in \\spad{ts} is a variable \\spad{v} which does not occur in the other polynomials of \\spad{ts}. This variable will be used to define the simple algebraic extension over which these other polynomials will be rewritten as univariate polynomials with degree one. If \\spad{univ?} is \\spad{true} then these polynomials will have a constant initial."))) 
NIL 
NIL 
(|IndexedString| |mn|) 
((|constructor| (NIL "This domain implements low-level strings")) (|hash| (((|Integer|) $) "\\spad{hash(x)} provides a hashing function for strings"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| (|Character|) (QUOTE (|SetCategory|))) (|HasCategory| (|Character|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Character|) (QUOTE (|OrderedSet|))) (OR (|HasCategory| (|Character|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Character|) (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| (|Character|) (LIST (QUOTE |Evalable|) (QUOTE (|Character|)))) (|HasCategory| (|Character|) (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| (|Character|) (LIST (QUOTE |Evalable|) (QUOTE (|Character|)))) (|HasCategory| (|Character|) (QUOTE (|OrderedSet|)))) (AND (|HasCategory| (|Character|) (LIST (QUOTE |Evalable|) (QUOTE (|Character|)))) (|HasCategory| (|Character|) (QUOTE (|SetCategory|)))))) 
(|InnerPolySum| E V R P) 
((|constructor| (NIL "Tools for the summation packages of polynomials")) (|sum| (((|Record| (|:| |num| |#4|) (|:| |den| (|Integer|))) |#4| |#2|) "\\spad{sum(p(n), \\spad{n)}} returns \\spad{P(n)}, the indefinite sum of \\spad{p(n)} with respect to upward difference on \\spad{n,} \\spadignore{i.e.} \\spad{P(n+1) - P(n) = a(n)}.") (((|Record| (|:| |num| |#4|) (|:| |den| (|Integer|))) |#4| |#2| (|Segment| |#4|)) "\\spad{sum(p(n), \\spad{n} = a..b)} returns \\spad{p(a) + p(a+1) + \\spad{...} + p(b)}."))) 
NIL 
NIL 
(|InnerSparseUnivariatePowerSeries| |Coef|) 
((|constructor| (NIL "InnerSparseUnivariatePowerSeries is an internal domain used for creating sparse Taylor and Laurent series.")) (|cAcsch| (($ $) "\\spad{cAcsch(f)} computes the inverse hyperbolic cosecant of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cAsech| (($ $) "\\spad{cAsech(f)} computes the inverse hyperbolic secant of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cAcoth| (($ $) "\\spad{cAcoth(f)} computes the inverse hyperbolic cotangent of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cAtanh| (($ $) "\\spad{cAtanh(f)} computes the inverse hyperbolic tangent of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cAcosh| (($ $) "\\spad{cAcosh(f)} computes the inverse hyperbolic cosine of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cAsinh| (($ $) "\\spad{cAsinh(f)} computes the inverse hyperbolic sine of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cCsch| (($ $) "\\spad{cCsch(f)} computes the hyperbolic cosecant of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cSech| (($ $) "\\spad{cSech(f)} computes the hyperbolic secant of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cCoth| (($ $) "\\spad{cCoth(f)} computes the hyperbolic cotangent of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cTanh| (($ $) "\\spad{cTanh(f)} computes the hyperbolic tangent of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cCosh| (($ $) "\\spad{cCosh(f)} computes the hyperbolic cosine of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cSinh| (($ $) "\\spad{cSinh(f)} computes the hyperbolic sine of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cAcsc| (($ $) "\\spad{cAcsc(f)} computes the arccosecant of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cAsec| (($ $) "\\spad{cAsec(f)} computes the arcsecant of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cAcot| (($ $) "\\spad{cAcot(f)} computes the arccotangent of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cAtan| (($ $) "\\spad{cAtan(f)} computes the arctangent of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cAcos| (($ $) "\\spad{cAcos(f)} computes the arccosine of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cAsin| (($ $) "\\spad{cAsin(f)} computes the arcsine of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cCsc| (($ $) "\\spad{cCsc(f)} computes the cosecant of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cSec| (($ $) "\\spad{cSec(f)} computes the secant of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cCot| (($ $) "\\spad{cCot(f)} computes the cotangent of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cTan| (($ $) "\\spad{cTan(f)} computes the tangent of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cCos| (($ $) "\\spad{cCos(f)} computes the cosine of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cSin| (($ $) "\\spad{cSin(f)} computes the sine of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cLog| (($ $) "\\spad{cLog(f)} computes the logarithm of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cExp| (($ $) "\\spad{cExp(f)} computes the exponential of the power series \\spad{f.} For use when the coefficient ring is commutative.")) (|cRationalPower| (($ $ (|Fraction| (|Integer|))) "\\spad{cRationalPower(f,r)} computes \\spad{f^r}. For use when the coefficient ring is commutative.")) (|cPower| (($ $ |#1|) "\\spad{cPower(f,r)} computes \\spad{f^r}, where \\spad{f} has constant coefficient 1. For use when the coefficient ring is commutative.")) (|integrate| (($ $) "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. Warning: function does not check for a term of degree \\spad{-1.}")) (|seriesToOutputForm| (((|OutputForm|) (|Stream| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|))) (|Reference| (|OrderedCompletion| (|Integer|))) (|Symbol|) |#1| (|Fraction| (|Integer|))) "\\spad{seriesToOutputForm(st,refer,var,cen,r)} prints the series \\spad{f((var - cen)^r)}.")) (|iCompose| (($ $ $) "\\spad{iCompose(f,g)} returns \\spad{f(g(x))}. This is an internal function which should only be called for Taylor series \\spad{f(x)} and \\spad{g(x)} such that the constant coefficient of \\spad{g(x)} is zero.")) (|taylorQuoByVar| (($ $) "\\spad{taylorQuoByVar(a0 + \\spad{a1} \\spad{x} + \\spad{a2} \\spad{x**2} + ...)} returns \\spad{a1 + \\spad{a2} \\spad{x} + \\spad{a3} \\spad{x**2} + ...}")) (|iExquo| (((|Union| $ "failed") $ $ (|Boolean|)) "\\spad{iExquo(f,g,taylor?)} is the quotient of the power series \\spad{f} and \\spad{g.} If \\spad{taylor?} is \\spad{true}, then we must have \\spad{order(f) \\spad{>=} order(g)}.")) (|multiplyCoefficients| (($ (|Mapping| |#1| (|Integer|)) $) "\\spad{multiplyCoefficients(fn,f)} returns the series \\spad{sum(fn(n) * an * x^n,n = n0..)}, where \\spad{f} is the series \\spad{sum(an * x^n,n = n0..)}.")) (|monomial?| (((|Boolean|) $) "\\spad{monomial?(f)} tests if \\spad{f} is a single monomial.")) (|series| (($ (|Stream| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|)))) "\\spad{series(st)} creates a series from a stream of non-zero terms, where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents.")) (|getStream| (((|Stream| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|))) $) "\\spad{getStream(f)} returns the stream of terms representing the series \\spad{f.}")) (|getRef| (((|Reference| (|OrderedCompletion| (|Integer|))) $) "\\spad{getRef(f)} returns a reference containing the order to which the terms of \\spad{f} have been computed.")) (|makeSeries| (($ (|Reference| (|OrderedCompletion| (|Integer|))) (|Stream| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|)))) "\\spad{makeSeries(refer,str)} creates a power series from the reference \\spad{refer} and the stream \\spad{str}."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|Integer|)) (|devaluate| |#1|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|Integer|)) (|devaluate| |#1|))))) (|HasCategory| (|Integer|) (QUOTE (|SemiGroup|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Integer|))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|))))))) 
(|InnerTaylorSeries| |Coef|) 
((|constructor| (NIL "Internal package for dense Taylor series. This is an internal Taylor series type in which Taylor series are represented by a \\spadtype{Stream} of \\spadtype{Ring} elements. For univariate series, the \\spad{Stream} elements are the Taylor coefficients. For multivariate series, the \\spad{n}th Stream element is a form of degree \\spad{n} in the power series variables.")) (* (($ $ (|Integer|)) "\\spad{x*i} returns the product of integer \\spad{i} and the series \\spad{x.}") (($ $ |#1|) "\\spad{x*c} returns the product of \\spad{c} and the series \\spad{x.}") (($ |#1| $) "\\spad{c*x} returns the product of \\spad{c} and the series \\spad{x.}")) (|order| (((|NonNegativeInteger|) $ (|NonNegativeInteger|)) "\\spad{order(x,n)} returns the minimum of \\spad{n} and the order of \\spad{x.}") (((|NonNegativeInteger|) $) "\\spad{order(x)} returns the order of a power series \\spad{x,} \\indented{1}{\\spadignore{i.e.} the degree of the first non-zero term of the series.}")) (|pole?| (((|Boolean|) $) "\\spad{pole?(x)} tests if the series \\spad{x} has a pole. \\indented{1}{Note: this is \\spad{false} when \\spad{x} is a Taylor series.}")) (|series| (($ (|Stream| |#1|)) "\\spad{series(s)} creates a power series from a stream of \\indented{1}{ring elements.} \\indented{1}{For univariate series types, the stream \\spad{s} should be a stream} \\indented{1}{of Taylor coefficients. For multivariate series types, the} \\indented{1}{stream \\spad{s} should be a stream of forms the \\spad{n}th element} \\indented{1}{of which is a} \\indented{1}{form of degree \\spad{n} in the power series variables.}")) (|coefficients| (((|Stream| |#1|) $) "\\spad{coefficients(x)} returns a stream of ring elements. \\indented{1}{When \\spad{x} is a univariate series, this is a stream of Taylor} \\indented{1}{coefficients. When \\spad{x} is a multivariate series, the} \\indented{1}{\\spad{n}th element of the stream is a form of} \\indented{1}{degree \\spad{n} in the power series variables.}"))) 
((|leftUnitary| |has| |#1| (|IntegralDomain|)) (|rightUnitary| |has| |#1| (|IntegralDomain|)) ((|commutative| "*") |has| |#1| (|IntegralDomain|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) 
(|InfiniteTupleFunctions2| A B) 
((|constructor| (NIL "Functions defined on streams with entries in two sets.")) (|map| (((|InfiniteTuple| |#2|) (|Mapping| |#2| |#1|) (|InfiniteTuple| |#1|)) "\\spad{map(f,[x0,x1,x2,...])} returns \\spad{[f(x0),f(x1),f(x2),..]}."))) 
NIL 
NIL 
(|InfiniteTupleFunctions3| A B C) 
((|constructor| (NIL "Functions defined on streams with entries in two sets.")) (|map| (((|Stream| |#3|) (|Mapping| |#3| |#1| |#2|) (|InfiniteTuple| |#1|) (|Stream| |#2|)) "\\spad{map(f,a,b)} \\undocumented") (((|Stream| |#3|) (|Mapping| |#3| |#1| |#2|) (|Stream| |#1|) (|InfiniteTuple| |#2|)) "\\spad{map(f,a,b)} \\undocumented") (((|InfiniteTuple| |#3|) (|Mapping| |#3| |#1| |#2|) (|InfiniteTuple| |#1|) (|InfiniteTuple| |#2|)) "\\spad{map(f,a,b)} \\undocumented"))) 
NIL 
NIL 
(|InnerTrigonometricManipulations| R F FG) 
((|constructor| (NIL "This package provides transformations from trigonometric functions to exponentials and logarithms, and back. \\spad{F} and \\spad{FG} should be the same type of function space.")) (|trigs2explogs| ((|#3| |#3| (|List| (|Kernel| |#3|)) (|List| (|Symbol|))) "\\spad{trigs2explogs(f, [k1,...,kn], [x1,...,xm])} rewrites all the trigonometric functions appearing in \\spad{f} and involving one of the \\spad{xi's} in terms of complex logarithms and exponentials. A kernel of the form \\spad{tan(u)} is expressed using \\spad{exp(u)**2} if it is one of the \\spad{ki's}, in terms of \\spad{exp(2*u)} otherwise.")) (|explogs2trigs| (((|Complex| |#2|) |#3|) "\\spad{explogs2trigs(f)} rewrites all the complex logs and exponentials appearing in \\spad{f} in terms of trigonometric functions.")) (F2FG ((|#3| |#2|) "\\spad{F2FG(a + sqrt(-1) \\spad{b)}} returns \\spad{a + \\spad{i} \\spad{b}.}")) (FG2F ((|#2| |#3|) "\\spad{FG2F(a + \\spad{i} \\spad{b)}} returns \\spad{a + sqrt(-1) \\spad{b}.}")) (GF2FG ((|#3| (|Complex| |#2|)) "\\spad{GF2FG(a + \\spad{i} \\spad{b)}} returns \\spad{a + \\spad{i} \\spad{b}} viewed as a function with the \\spad{i} pushed down into the coefficient domain."))) 
NIL 
NIL 
(|InfiniteTuple| S) 
((|constructor| (NIL "This package implements 'infinite tuples' for the interpreter. The representation is a stream.")) (|construct| (((|Stream| |#1|) $) "\\spad{construct(t)} converts an infinite tuple to a stream.")) (|generate| (($ (|Mapping| |#1| |#1|) |#1|) "\\spad{generate(f,s)} returns \\spad{[s,f(s),f(f(s)),...]}.")) (|select| (($ (|Mapping| (|Boolean|) |#1|) $) "\\spad{select(p,t)} returns \\spad{[x for \\spad{x} in \\spad{t} | p(x)]}.")) (|filterUntil| (($ (|Mapping| (|Boolean|) |#1|) $) "\\spad{filterUntil(p,t)} returns \\spad{[x for \\spad{x} in \\spad{t} while not p(x)]}.")) (|filterWhile| (($ (|Mapping| (|Boolean|) |#1|) $) "\\spad{filterWhile(p,t)} returns \\spad{[x for \\spad{x} in \\spad{t} while p(x)]}.")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\spad{map(f,t)} replaces the tuple \\spad{t} by \\spad{[f(x) for \\spad{x} in t]}."))) 
NIL 
NIL 
(|IndexedVector| R |mn|) 
((|constructor| (NIL "This type represents vector like objects with varying lengths and a user-specified initial index."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#1| (QUOTE (|AbelianMonoid|))) (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#1| (QUOTE (|Monoid|))) (|HasCategory| |#1| (QUOTE (|Ring|))) (AND (|HasCategory| |#1| (QUOTE (|RadicalCategory|))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|IndexedAggregate&| S |Index| |Entry|) 
((|constructor| (NIL "An indexed aggregate is a many-to-one mapping of indices to entries. For example, a one-dimensional-array is an indexed aggregate where the index is an integer. Also, a table is an indexed aggregate where the indices and entries may have any type.")) (|swap!| (((|Void|) $ |#2| |#2|) "\\spad{swap!(u,i,j)} interchanges elements \\spad{i} and \\spad{j} of aggregate u. No meaningful value is returned.")) (|fill!| (($ $ |#3|) "\\spad{fill!(u,x)} replaces each entry in aggregate \\spad{u} by \\spad{x.} The modified \\spad{u} is returned as value.")) (|first| ((|#3| $) "\\spad{first(u)} returns the first element \\spad{x} of u. Note that for collections, \\axiom{first([x,y,...,z]) = \\spad{x}.} Error: if \\spad{u} is empty.")) (|minIndex| ((|#2| $) "\\spad{minIndex(u)} returns the minimum index \\spad{i} of aggregate u. Note that in general, \\axiom{minIndex(a) = reduce(min,[i for \\spad{i} in indices a])}; for lists, \\axiom{minIndex(a) = 1}.")) (|maxIndex| ((|#2| $) "\\spad{maxIndex(u)} returns the maximum index \\spad{i} of aggregate u. Note that in general, \\axiom{maxIndex(u) = reduce(max,[i for \\spad{i} in indices u])}; if \\spad{u} is a list, \\axiom{maxIndex(u) = \\#u}.")) (|entry?| (((|Boolean|) |#3| $) "\\spad{entry?(x,u)} tests if \\spad{x} equals \\axiom{u . i} for some index i.")) (|indices| (((|List| |#2|) $) "\\spad{indices(u)} returns a list of indices of aggregate \\spad{u} in no particular order. to become indices:")) (|index?| (((|Boolean|) |#2| $) "\\spad{index?(i,u)} tests if \\spad{i} is an index of aggregate u.")) (|entries| (((|List| |#3|) $) "\\spad{entries(u)} returns a list of all the entries of aggregate \\spad{u} in no assumed order."))) 
NIL 
((|HasAttribute| |#1| (QUOTE |shallowlyMutable|)) (|HasCategory| |#2| (QUOTE (|OrderedSet|))) (|HasAttribute| |#1| (QUOTE |finiteAggregate|)) (|HasCategory| |#3| (QUOTE (|SetCategory|)))) 
(|IndexedAggregate| |Index| |Entry|) 
((|constructor| (NIL "An indexed aggregate is a many-to-one mapping of indices to entries. For example, a one-dimensional-array is an indexed aggregate where the index is an integer. Also, a table is an indexed aggregate where the indices and entries may have any type.")) (|swap!| (((|Void|) $ |#1| |#1|) "\\spad{swap!(u,i,j)} interchanges elements \\spad{i} and \\spad{j} of aggregate u. No meaningful value is returned.")) (|fill!| (($ $ |#2|) "\\spad{fill!(u,x)} replaces each entry in aggregate \\spad{u} by \\spad{x.} The modified \\spad{u} is returned as value.")) (|first| ((|#2| $) "\\spad{first(u)} returns the first element \\spad{x} of u. Note that for collections, \\axiom{first([x,y,...,z]) = \\spad{x}.} Error: if \\spad{u} is empty.")) (|minIndex| ((|#1| $) "\\spad{minIndex(u)} returns the minimum index \\spad{i} of aggregate u. Note that in general, \\axiom{minIndex(a) = reduce(min,[i for \\spad{i} in indices a])}; for lists, \\axiom{minIndex(a) = 1}.")) (|maxIndex| ((|#1| $) "\\spad{maxIndex(u)} returns the maximum index \\spad{i} of aggregate u. Note that in general, \\axiom{maxIndex(u) = reduce(max,[i for \\spad{i} in indices u])}; if \\spad{u} is a list, \\axiom{maxIndex(u) = \\#u}.")) (|entry?| (((|Boolean|) |#2| $) "\\spad{entry?(x,u)} tests if \\spad{x} equals \\axiom{u . i} for some index i.")) (|indices| (((|List| |#1|) $) "\\spad{indices(u)} returns a list of indices of aggregate \\spad{u} in no particular order. to become indices:")) (|index?| (((|Boolean|) |#1| $) "\\spad{index?(i,u)} tests if \\spad{i} is an index of aggregate u.")) (|entries| (((|List| |#2|) $) "\\spad{entries(u)} returns a list of all the entries of aggregate \\spad{u} in no assumed order."))) 
((|nil| . T)) 
NIL 
(|AssociatedJordanAlgebra| R A) 
((|constructor| (NIL "AssociatedJordanAlgebra takes an algebra \\spad{A} and uses \\spadfun{*$A} to define the new multiplications \\spad{a*b \\spad{:=} (a *$A \\spad{b} + \\spad{b} *$A a)/2} (anticommutator). The usual notation \\spad{{a,b}_+} cannot be used due to restrictions in the current language. This domain only gives a Jordan algebra if the Jordan-identity \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} holds for all \\spad{a},\\spad{b},\\spad{c} in \\spad{A}. This relation can be checked by \\spadfun{jordanAdmissible?()$A}. \\blankline If the underlying algebra is of type \\spadtype{FramedNonAssociativeAlgebra(R)} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free R-module of finite rank, together with a fixed R-module basis), then the same is \\spad{true} for the associated Jordan algebra. Moreover, if the underlying algebra is of type \\spadtype{FiniteRankNonAssociativeAlgebra(R)} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free R-module of finite rank), then the same \\spad{true} for the associated Jordan algebra.")) (|coerce| (($ |#2|) "\\spad{coerce(a)} coerces the element \\spad{a} of the algebra \\spad{A} to an element of the Jordan algebra \\spadtype{AssociatedJordanAlgebra}(R,A)."))) 
((|unitsKnown| OR (|and| (|has| |#2| (|FiniteRankNonAssociativeAlgebra| |#1|)) (|has| |#1| (|IntegralDomain|))) (AND (|has| |#2| (|FramedNonAssociativeAlgebra| |#1|)) (|has| |#1| (|IntegralDomain|)))) (|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| |#2| (LIST (QUOTE |FramedNonAssociativeAlgebra|) (|devaluate| |#1|))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |FramedNonAssociativeAlgebra|) (|devaluate| |#1|)))) (|HasCategory| |#2| (LIST (QUOTE |FiniteRankNonAssociativeAlgebra|) (|devaluate| |#1|))) (OR (|HasCategory| |#2| (LIST (QUOTE |FiniteRankNonAssociativeAlgebra|) (|devaluate| |#1|))) (|HasCategory| |#2| (LIST (QUOTE |FramedNonAssociativeAlgebra|) (|devaluate| |#1|)))) (OR (AND (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (LIST (QUOTE |FiniteRankNonAssociativeAlgebra|) (|devaluate| |#1|)))) (AND (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (LIST (QUOTE |FramedNonAssociativeAlgebra|) (|devaluate| |#1|)))))) 
(|KeyedAccessFile| |Entry|) 
((|constructor| (NIL "This domain allows a random access file to be viewed both as a table and as a file object. The KeyedAccessFile format is a directory containing a single file called ``index.kaf''. This file is a random access file. The first thing in the file is an integer which is the byte offset of an association list (the dictionary) at the end of the file. The association list is of the form ((key . byteoffset) (key . byteoffset)...) where the byte offset is the number of bytes from the beginning of the file. This offset contains an s-expression for the value of the key.")) (|pack!| (($ $) "\\spad{pack!(f)} reorganizes the file \\spad{f} on disk to recover unused space."))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| (|String|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|)) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (QUOTE (|String|))) (LIST (QUOTE |:|) (QUOTE |entry|) (|devaluate| |#1|))))) (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|)) (QUOTE (|SetCategory|))))) 
(|KeyedDictionary&| S |Key| |Entry|) 
((|constructor| (NIL "A keyed dictionary is a dictionary of key-entry pairs for which there is a unique entry for each key.")) (|search| (((|Union| |#3| "failed") |#2| $) "\\spad{search(k,t)} searches the table \\spad{t} for the key \\spad{k,} returning the entry stored in \\spad{t} for key \\spad{k.} If \\spad{t} has no such key, \\axiom{search(k,t)} returns \"failed\".")) (|remove!| (((|Union| |#3| "failed") |#2| $) "\\spad{remove!(k,t)} searches the table \\spad{t} for the key \\spad{k} removing (and return) the entry if there. If \\spad{t} has no such key, \\axiom{remove!(k,t)} returns \"failed\".")) (|keys| (((|List| |#2|) $) "\\spad{keys(t)} returns the list the keys in table \\spad{t.}")) (|key?| (((|Boolean|) |#2| $) "\\spad{key?(k,t)} tests if \\spad{k} is a key in table \\spad{t.}"))) 
NIL 
NIL 
(|KeyedDictionary| |Key| |Entry|) 
((|constructor| (NIL "A keyed dictionary is a dictionary of key-entry pairs for which there is a unique entry for each key.")) (|search| (((|Union| |#2| "failed") |#1| $) "\\spad{search(k,t)} searches the table \\spad{t} for the key \\spad{k,} returning the entry stored in \\spad{t} for key \\spad{k.} If \\spad{t} has no such key, \\axiom{search(k,t)} returns \"failed\".")) (|remove!| (((|Union| |#2| "failed") |#1| $) "\\spad{remove!(k,t)} searches the table \\spad{t} for the key \\spad{k} removing (and return) the entry if there. If \\spad{t} has no such key, \\axiom{remove!(k,t)} returns \"failed\".")) (|keys| (((|List| |#1|) $) "\\spad{keys(t)} returns the list the keys in table \\spad{t.}")) (|key?| (((|Boolean|) |#1| $) "\\spad{key?(k,t)} tests if \\spad{k} is a key in table \\spad{t.}"))) 
((|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|KernelFunctions2| R S) 
((|constructor| (NIL "This package exports some auxiliary functions on kernels")) (|constantIfCan| (((|Union| |#1| "failed") (|Kernel| |#2|)) "\\spad{constantIfCan(k)} \\undocumented")) (|constantKernel| (((|Kernel| |#2|) |#1|) "\\spad{constantKernel(r)} \\undocumented"))) 
NIL 
NIL 
(|Kernel| S) 
((|constructor| (NIL "A kernel over a set \\spad{S} is an operator applied to a given list of arguments from \\spad{S.}")) (|is?| (((|Boolean|) $ (|Symbol|)) "\\spad{is?(op(a1,...,an), \\spad{s)}} tests if the name of op is \\spad{s.}") (((|Boolean|) $ (|BasicOperator|)) "\\spad{is?(op(a1,...,an), \\spad{f)}} tests if op = \\spad{f.}")) (|symbolIfCan| (((|Union| (|Symbol|) "failed") $) "\\spad{symbolIfCan(k)} returns \\spad{k} viewed as a symbol if \\spad{k} is a symbol, and \"failed\" otherwise.")) (|kernel| (($ (|Symbol|)) "\\spad{kernel(x)} returns \\spad{x} viewed as a kernel.") (($ (|BasicOperator|) (|List| |#1|) (|NonNegativeInteger|)) "\\spad{kernel(op, [a1,...,an], \\spad{m)}} returns the kernel \\spad{op(a1,...,an)} of nesting level \\spad{m.} Error: if \\spad{op} is k-ary for some \\spad{k} not equal to \\spad{m.}")) (|height| (((|NonNegativeInteger|) $) "\\spad{height(k)} returns the nesting level of \\spad{k.}")) (|argument| (((|List| |#1|) $) "\\spad{argument(op(a1,...,an))} returns \\spad{[a1,...,an]}.")) (|operator| (((|BasicOperator|) $) "\\spad{operator(op(a1,...,an))} returns the operator op.")) (|name| (((|Symbol|) $) "\\spad{name(op(a1,...,an))} returns the name of op."))) 
NIL 
((|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) 
(|CoercibleTo| S) 
((|constructor| (NIL "A is coercible to \\spad{B} means any element of A can automatically be converted into an element of \\spad{B} by the interpreter.")) (|coerce| ((|#1| $) "\\spad{coerce(a)} transforms a into an element of \\spad{S.}"))) 
NIL 
NIL 
(|ConvertibleTo| S) 
((|constructor| (NIL "A is convertible to \\spad{B} means any element of A can be converted into an element of \\spad{B,} but not automatically by the interpreter.")) (|convert| ((|#1| $) "\\spad{convert(a)} transforms a into an element of \\spad{S.}"))) 
NIL 
NIL 
(|Kovacic| F UP) 
((|constructor| (NIL "\\spadtype{Kovacic} provides a modified Kovacic's algorithm for solving explicitely irreducible 2nd order linear ordinary differential equations.")) (|kovacic| (((|Union| (|SparseUnivariatePolynomial| (|Fraction| |#2|)) "failed") (|Fraction| |#2|) (|Fraction| |#2|) (|Fraction| |#2|) (|Mapping| (|Factored| |#2|) |#2|)) "\\spad{kovacic(a_0,a_1,a_2,ezfactor)} returns either \"failed\" or P(u) such that \\spad{$e^{\\int(-a_1/2a_2)} e^{\\int u}$} is a solution of \\indented{5}{\\spad{$a_2 \\spad{y''} + \\spad{a_1} \\spad{y'} + \\spad{a0} \\spad{y} = 0$}} whenever \\spad{u} is a solution of \\spad{P \\spad{u} = 0}. The equation must be already irreducible over the rational functions. Argument \\spad{ezfactor} is a factorisation in \\spad{UP}, not necessarily into irreducibles.") (((|Union| (|SparseUnivariatePolynomial| (|Fraction| |#2|)) "failed") (|Fraction| |#2|) (|Fraction| |#2|) (|Fraction| |#2|)) "\\spad{kovacic(a_0,a_1,a_2)} returns either \"failed\" or P(u) such that \\spad{$e^{\\int(-a_1/2a_2)} e^{\\int u}$} is a solution of \\indented{5}{\\spad{a_2 \\spad{y''} + \\spad{a_1} \\spad{y'} + \\spad{a0} \\spad{y} = 0}} whenever \\spad{u} is a solution of \\spad{P \\spad{u} = 0}. The equation must be already irreducible over the rational functions."))) 
NIL 
NIL 
(|LeftAlgebra&| S R) 
((|constructor| (NIL "The category of all left algebras over an arbitrary ring.")) (|coerce| (($ |#2|) "\\spad{coerce(r)} returns \\spad{r} * 1 where 1 is the identity of the left algebra."))) 
NIL 
NIL 
(|LeftAlgebra| R) 
((|constructor| (NIL "The category of all left algebras over an arbitrary ring.")) (|coerce| (($ |#1|) "\\spad{coerce(r)} returns \\spad{r} * 1 where 1 is the identity of the left algebra."))) 
((|unitsKnown| . T)) 
NIL 
(|LocalAlgebra| A R S) 
((|constructor| (NIL "LocalAlgebra produces the localization of an algebra, \\spadignore{i.e.} fractions whose numerators come from some \\spad{R} algebra.")) (|denom| ((|#3| $) "\\spad{denom \\spad{x}} returns the denominator of \\spad{x.}")) (|numer| ((|#1| $) "\\spad{numer \\spad{x}} returns the numerator of \\spad{x.}")) (/ (($ |#1| |#3|) "\\spad{a / \\spad{d}} divides the element \\spad{a} by \\spad{d.}") (($ $ |#3|) "\\spad{x / \\spad{d}} divides the element \\spad{x} by \\spad{d.}"))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|OrderedRing|)))) 
(|LaplaceTransform| R F) 
((|constructor| (NIL "This package computes the forward Laplace Transform.")) (|laplace| ((|#2| |#2| (|Symbol|) (|Symbol|)) "\\spad{laplace(f, \\spad{t,} \\spad{s)}} returns the Laplace transform of \\spad{f(t)} using \\spad{s} as the new variable. This is \\spad{integral(exp(-s*t)*f(t), \\spad{t} = 0..%plusInfinity)}. Returns the formal object \\spad{laplace(f, \\spad{t,} \\spad{s)}} if it cannot compute the transform."))) 
NIL 
NIL 
(|LaurentPolynomial| R UP) 
((|constructor| (NIL "Univariate polynomials with negative and positive exponents.")) (|separate| (((|Record| (|:| |polyPart| $) (|:| |fracPart| (|Fraction| |#2|))) (|Fraction| |#2|)) "\\spad{separate(x)} is not documented")) (|monomial| (($ |#1| (|Integer|)) "\\spad{monomial(x,n)} is not documented")) (|coefficient| ((|#1| $ (|Integer|)) "\\spad{coefficient(x,n)} is not documented")) (|trailingCoefficient| ((|#1| $) "trailingCoefficient is not documented")) (|leadingCoefficient| ((|#1| $) "leadingCoefficient is not documented")) (|reductum| (($ $) "\\spad{reductum(x)} is not documented")) (|order| (((|Integer|) $) "\\spad{order(x)} is not documented")) (|degree| (((|Integer|) $) "\\spad{degree(x)} is not documented")) (|monomial?| (((|Boolean|) $) "\\spad{monomial?(x)} is not documented"))) 
((|leftUnitary| . T) (|rightUnitary| . T) ((|commutative| "*") . T) (|noZeroDivisors| . T) (|unitsKnown| . T)) 
((|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) 
(|LazardSetSolvingPackage| R E V P TS ST) 
((|constructor| (NIL "A package for solving polynomial systems by means of Lazard triangular sets. This package provides two operations. One for solving in the sense of the regular zeros, and the other for solving in the sense of the Zariski closure. Both produce square-free regular sets. Moreover, the decompositions do not contain any redundant component. However, only zero-dimensional regular sets are normalized, since normalization may be time consumming in positive dimension. The decomposition process is that of [2].")) (|zeroSetSplit| (((|List| |#6|) (|List| |#4|) (|Boolean|)) "\\axiom{zeroSetSplit(lp,clos?)} has the same specifications as zeroSetSplit(lp,clos?) from RegularTriangularSetCategory.")) (|normalizeIfCan| ((|#6| |#6|) "\\axiom{normalizeIfCan(ts)} returns \\axiom{ts} in an normalized shape if \\axiom{ts} is zero-dimensional."))) 
NIL 
NIL 
(|LeadingCoefDetermination| OV E Z P) 
((|constructor| (NIL "Package for leading coefficient determination in the lifting step. Package working for every \\spad{R} euclidean with property \"F\".")) (|distFact| (((|Union| (|Record| (|:| |polfac| (|List| |#4|)) (|:| |correct| |#3|) (|:| |corrfact| (|List| (|SparseUnivariatePolynomial| |#3|)))) "failed") |#3| (|List| (|SparseUnivariatePolynomial| |#3|)) (|Record| (|:| |contp| |#3|) (|:| |factors| (|List| (|Record| (|:| |irr| |#4|) (|:| |pow| (|Integer|)))))) (|List| |#3|) (|List| |#1|) (|List| |#3|)) "\\spad{distFact(contm,unilist,plead,vl,lvar,lval)}, where \\spad{contm} is the content of the evaluated polynomial, \\spad{unilist} is the list of factors of the evaluated polynomial, \\spad{plead} is the complete factorization of the leading coefficient, \\spad{vl} is the list of factors of the leading coefficient evaluated, \\spad{lvar} is the list of variables, \\spad{lval} is the list of values, returns a record giving the list of leading coefficients to impose on the univariate factors.")) (|polCase| (((|Boolean|) |#3| (|NonNegativeInteger|) (|List| |#3|)) "\\spad{polCase(contprod, numFacts, evallcs)}, where \\spad{contprod} is the product of the content of the leading coefficient of the polynomial to be factored with the content of the evaluated polynomial, \\spad{numFacts} is the number of factors of the leadingCoefficient, and evallcs is the list of the evaluated factors of the leadingCoefficient, returns \\spad{true} if the factors of the leading Coefficient can be distributed with this valuation."))) 
NIL 
NIL 
(|LieExponentials| |VarSet| R |Order|) 
((|constructor| (NIL "Management of the Lie Group associated with a free nilpotent Lie algebra. Every Lie bracket with length greater than \\axiom{Order} are assumed to be null. The implementation inherits from the \\spadtype{XPBWPolynomial} domain constructor: Lyndon coordinates are exponential coordinates of the second kind.")) (|identification| (((|List| (|Equation| |#2|)) $ $) "\\axiom{identification(g,h)} returns the list of equations \\axiom{g_i = h_i}, where \\axiom{g_i} (resp. \\axiom{h_i}) are exponential coordinates of \\axiom{g} (resp. \\axiom{h}).")) (|LyndonCoordinates| (((|List| (|Record| (|:| |k| (|LyndonWord| |#1|)) (|:| |c| |#2|))) $) "\\axiom{LyndonCoordinates(g)} returns the exponential coordinates of \\axiom{g}.")) (|LyndonBasis| (((|List| (|LiePolynomial| |#1| |#2|)) (|List| |#1|)) "\\axiom{LyndonBasis(lv)} returns the Lyndon basis of the nilpotent free Lie algebra.")) (|varList| (((|List| |#1|) $) "\\axiom{varList(g)} returns the list of variables of \\axiom{g}.")) (|mirror| (($ $) "\\axiom{mirror(g)} is the mirror of the internal representation of \\axiom{g}.")) (|coerce| (((|XPBWPolynomial| |#1| |#2|) $) "\\axiom{coerce(g)} returns the internal representation of \\axiom{g}.") (((|XDistributedPolynomial| |#1| |#2|) $) "\\axiom{coerce(g)} returns the internal representation of \\axiom{g}.")) (|listOfTerms| (((|List| (|Record| (|:| |k| (|PoincareBirkhoffWittLyndonBasis| |#1|)) (|:| |c| |#2|))) $) "\\axiom{listOfTerms(p)} returns the internal representation of \\axiom{p}.")) (|log| (((|LiePolynomial| |#1| |#2|) $) "\\axiom{log(p)} returns the logarithm of \\axiom{p}.")) (|exp| (($ (|LiePolynomial| |#1| |#2|)) "\\axiom{exp(p)} returns the exponential of \\axiom{p}."))) 
((|unitsKnown| . T)) 
NIL 
(|LexTriangularPackage| R |ls|) 
((|constructor| (NIL "A package for solving polynomial systems with finitely many solutions. The decompositions are given by means of regular triangular sets. The computations use lexicographical Groebner bases. The main operations are lexTriangular and squareFreeLexTriangular. The second one provide decompositions by means of square-free regular triangular sets. Both are based on the lexTriangular method described in [1]. They differ from the algorithm described in \\spad{[2]} by the fact that multiciplities of the roots are not kept. With the squareFreeLexTriangular operation all multiciplities are removed. With the other operation some multiciplities may remain. Both operations admit an optional argument to produce normalized triangular sets.")) (|zeroSetSplit| (((|List| (|SquareFreeRegularTriangularSet| |#1| (|IndexedExponents| (|OrderedVariableList| |#2|)) (|OrderedVariableList| |#2|) (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)))) (|List| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))) (|Boolean|)) "\\axiom{zeroSetSplit(lp, norm?)} decomposes the variety associated with \\axiom{lp} into square-free regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \\axiom{lp} needs to generate a zero-dimensional ideal. If \\axiom{norm?} is \\axiom{true} then the regular sets are normalized.") (((|List| (|RegularChain| |#1| |#2|)) (|List| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))) (|Boolean|)) "\\axiom{zeroSetSplit(lp, norm?)} decomposes the variety associated with \\axiom{lp} into regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \\axiom{lp} needs to generate a zero-dimensional ideal. If \\axiom{norm?} is \\axiom{true} then the regular sets are normalized.")) (|squareFreeLexTriangular| (((|List| (|SquareFreeRegularTriangularSet| |#1| (|IndexedExponents| (|OrderedVariableList| |#2|)) (|OrderedVariableList| |#2|) (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)))) (|List| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))) (|Boolean|)) "\\axiom{squareFreeLexTriangular(base, norm?)} decomposes the variety associated with \\axiom{base} into square-free regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \\axiom{base} needs to be a lexicographical Groebner basis of a zero-dimensional ideal. If \\axiom{norm?} is \\axiom{true} then the regular sets are normalized.")) (|lexTriangular| (((|List| (|RegularChain| |#1| |#2|)) (|List| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))) (|Boolean|)) "\\axiom{lexTriangular(base, norm?)} decomposes the variety associated with \\axiom{base} into regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \\axiom{base} needs to be a lexicographical Groebner basis of a zero-dimensional ideal. If \\axiom{norm?} is \\axiom{true} then the regular sets are normalized.")) (|groebner| (((|List| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))) (|List| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)))) "\\axiom{groebner(lp)} returns the lexicographical Groebner basis of \\axiom{lp}. If \\axiom{lp} generates a zero-dimensional ideal then the FGLM strategy is used, otherwise the Sugar strategy is used.")) (|fglmIfCan| (((|Union| (|List| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))) "failed") (|List| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)))) "\\axiom{fglmIfCan(lp)} returns the lexicographical Groebner basis of \\axiom{lp} by using the FGLM strategy, if \\axiom{zeroDimensional?(lp)} holds .")) (|zeroDimensional?| (((|Boolean|) (|List| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)))) "\\axiom{zeroDimensional?(lp)} returns \\spad{true} iff \\axiom{lp} generates a zero-dimensional ideal w.r.t. the variables involved in \\axiom{lp}."))) 
NIL 
NIL 
(|LiouvillianFunctionCategory|) 
((|constructor| (NIL "Category for the transcendental Liouvillian functions.")) (|fresnelC| (($ $) "\\spad{fresnelC(x)} is the Fresnel integral \\spad{C,} defined by C(x) = integrate(cos(t^2),t=0..x)")) (|fresnelS| (($ $) "\\spad{fresnelS(x)} is the Fresnel integral \\spad{S,} defined by S(x) = integrate(sin(t^2),t=0..x)")) (|erf| (($ $) "\\spad{erf(x)} returns the error function of \\spad{x,} that is, \\spad{2 / sqrt(\\%pi)} times the integral of \\spad{exp(-x**2) dx}.")) (|dilog| (($ $) "\\spad{dilog(x)} returns the dilogarithm of \\spad{x,} that is, the integral of \\spad{log(x) / \\spad{(1} - \\spad{x)} dx}.")) (|li| (($ $) "\\spad{li(x)} returns the logarithmic integral of \\spad{x,} that is, the integral of \\spad{dx / log(x)}.")) (|Ci| (($ $) "\\spad{Ci(x)} returns the cosine integral of \\spad{x,} that is, the integral of \\spad{cos(x) / \\spad{x} dx}.")) (|Si| (($ $) "\\spad{Si(x)} returns the sine integral of \\spad{x,} that is, the integral of \\spad{sin(x) / \\spad{x} dx}.")) (|Ei| (($ $) "\\spad{Ei(x)} returns the exponential integral of \\spad{x,} that is, the integral of \\spad{exp(x)/x dx}."))) 
NIL 
NIL 
(|LiouvillianFunction| R F) 
((|constructor| (NIL "This package provides liouvillian functions over an integral domain.")) (|integral| ((|#2| |#2| (|SegmentBinding| |#2|)) "\\spad{integral(f,x = a..b)} denotes the definite integral of \\spad{f} with respect to \\spad{x} from \\spad{a} to \\spad{b.}") ((|#2| |#2| (|Symbol|)) "\\spad{integral(f,x)} indefinite integral of \\spad{f} with respect to \\spad{x.}")) (|fresnelC| ((|#2| |#2|) "\\spad{fresnelC(f)} denotes the Fresnel integral \\spad{C}")) (|fresnelS| ((|#2| |#2|) "\\spad{fresnelS(f)} denotes the Fresnel integral \\spad{S}")) (|dilog| ((|#2| |#2|) "\\spad{dilog(f)} denotes the dilogarithm")) (|erf| ((|#2| |#2|) "\\spad{erf(f)} denotes the error function")) (|li| ((|#2| |#2|) "\\spad{li(f)} denotes the logarithmic integral")) (|Ci| ((|#2| |#2|) "\\spad{Ci(f)} denotes the cosine integral")) (|Si| ((|#2| |#2|) "\\spad{Si(f)} denotes the sine integral")) (|Ei| ((|#2| |#2|) "\\spad{Ei(f)} denotes the exponential integral")) (|operator| (((|BasicOperator|) (|BasicOperator|)) "\\spad{operator(op)} returns the Liouvillian operator based on \\spad{op}")) (|belong?| (((|Boolean|) (|BasicOperator|)) "\\spad{belong?(op)} checks if \\spad{op} is Liouvillian"))) 
NIL 
NIL 
(|LinGroebnerPackage| |lv| F) 
((|constructor| (NIL "Given a Groebner basis \\spad{B} with respect to the total degree ordering for a zero-dimensional ideal I, compute a Groebner basis with respect to the lexicographical ordering by using linear algebra.")) (|transform| (((|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|) (|DistributedMultivariatePolynomial| |#1| |#2|)) "\\spad{transform }\\undocumented")) (|choosemon| (((|DistributedMultivariatePolynomial| |#1| |#2|) (|DistributedMultivariatePolynomial| |#1| |#2|) (|List| (|DistributedMultivariatePolynomial| |#1| |#2|))) "\\spad{choosemon }\\undocumented")) (|intcompBasis| (((|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)) (|OrderedVariableList| |#1|) (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)) (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))) "\\spad{intcompBasis }\\undocumented")) (|anticoord| (((|DistributedMultivariatePolynomial| |#1| |#2|) (|List| |#2|) (|DistributedMultivariatePolynomial| |#1| |#2|) (|List| (|DistributedMultivariatePolynomial| |#1| |#2|))) "\\spad{anticoord }\\undocumented")) (|coord| (((|Vector| |#2|) (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|) (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))) "\\spad{coord }\\undocumented")) (|computeBasis| (((|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)) (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))) "\\spad{computeBasis }\\undocumented")) (|minPol| (((|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|) (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)) (|OrderedVariableList| |#1|)) "\\spad{minPol }\\undocumented") (((|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|) (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)) (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)) (|OrderedVariableList| |#1|)) "\\spad{minPol }\\undocumented")) (|totolex| (((|List| (|DistributedMultivariatePolynomial| |#1| |#2|)) (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))) "\\spad{totolex }\\undocumented")) (|groebgen| (((|Record| (|:| |glbase| (|List| (|DistributedMultivariatePolynomial| |#1| |#2|))) (|:| |glval| (|List| (|Integer|)))) (|List| (|DistributedMultivariatePolynomial| |#1| |#2|))) "\\spad{groebgen }\\undocumented")) (|linGenPos| (((|Record| (|:| |gblist| (|List| (|DistributedMultivariatePolynomial| |#1| |#2|))) (|:| |gvlist| (|List| (|Integer|)))) (|List| (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|))) "\\spad{linGenPos }\\undocumented"))) 
NIL 
NIL 
(|Library|) 
((|constructor| (NIL "This domain provides a simple way to save values in files.")) (|close!| (($ $) "\\spad{close!(f)} returns the library \\spad{f} closed to input and output.")) (|setelt| (((|Any|) $ (|Symbol|) (|Any|)) "\\spad{lib.k \\spad{:=} \\spad{v}} saves the value \\spad{v} in the library \\spad{lib}. It can later be extracted using the key \\spad{k}.")) (|elt| (((|Any|) $ (|Symbol|)) "\\spad{elt(lib,k)} or lib.k extracts the value corresponding to the key \\spad{k} from the library \\spad{lib}.")) (|pack!| (($ $) "\\spad{pack!(f)} reorganizes the file \\spad{f} on disk to recover unused space.")) (|library| (($ (|FileName|)) "\\spad{library(ln)} creates a new library file."))) 
((|shallowlyMutable| . T)) 
((|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|))) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|String|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Any|) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Any|) (LIST (QUOTE |Evalable|) (QUOTE (|Any|)))) (|HasCategory| (|Any|) (QUOTE (|SetCategory|)))) (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|))) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|))) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (QUOTE (|String|))) (LIST (QUOTE |:|) (QUOTE |entry|) (QUOTE (|Any|)))))) (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|))) (QUOTE (|SetCategory|)))) (OR (|HasCategory| (|Any|) (QUOTE (|SetCategory|))) (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| (|Any|))) (QUOTE (|SetCategory|))))) 
(|LieAlgebra&| S R) 
((|constructor| (NIL "The category of Lie Algebras. It is used by the domains of non-commutative algebra, LiePolynomial and XPBWPolynomial.")) (/ (($ $ |#2|) "\\axiom{x/r} returns the division of \\axiom{x} by \\axiom{r}.")) (|construct| (($ $ $) "\\axiom{construct(x,y)} returns the Lie bracket of \\axiom{x} and \\axiom{y}."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|Field|)))) 
(|LieAlgebra| R) 
((|constructor| (NIL "The category of Lie Algebras. It is used by the domains of non-commutative algebra, LiePolynomial and XPBWPolynomial.")) (/ (($ $ |#1|) "\\axiom{x/r} returns the division of \\axiom{x} by \\axiom{r}.")) (|construct| (($ $ $) "\\axiom{construct(x,y)} returns the Lie bracket of \\axiom{x} and \\axiom{y}."))) 
((|JacobiIdentity| . T) (|NullSquare| . T) (|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|AssociatedLieAlgebra| R A) 
((|constructor| (NIL "AssociatedLieAlgebra takes an algebra \\spad{A} and uses \\spadfun{*$A} to define the Lie bracket \\spad{a*b \\spad{:=} (a *$A \\spad{b} - \\spad{b} *$A a)} (commutator). Note that the notation \\spad{[a,b]} cannot be used due to restrictions of the current compiler. This domain only gives a Lie algebra if the Jacobi-identity \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} holds for all \\spad{a},\\spad{b},\\spad{c} in \\spad{A}. This relation can be checked by \\spad{lieAdmissible?()$A}. \\blankline If the underlying algebra is of type \\spadtype{FramedNonAssociativeAlgebra(R)} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free \\spad{R}-module of finite rank, together with a fixed \\spad{R}-module basis), then the same is \\spad{true} for the associated Lie algebra. Also, if the underlying algebra is of type \\spadtype{FiniteRankNonAssociativeAlgebra(R)} (\\spadignore{i.e.} a non associative algebra over \\spad{R} which is a free R-module of finite rank), then the same is \\spad{true} for the associated Lie algebra.")) (|coerce| (($ |#2|) "\\spad{coerce(a)} coerces the element \\spad{a} of the algebra \\spad{A} to an element of the Lie algebra \\spadtype{AssociatedLieAlgebra}(R,A)."))) 
((|unitsKnown| OR (|and| (|has| |#2| (|FiniteRankNonAssociativeAlgebra| |#1|)) (|has| |#1| (|IntegralDomain|))) (AND (|has| |#2| (|FramedNonAssociativeAlgebra| |#1|)) (|has| |#1| (|IntegralDomain|)))) (|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| |#2| (LIST (QUOTE |FramedNonAssociativeAlgebra|) (|devaluate| |#1|))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |FramedNonAssociativeAlgebra|) (|devaluate| |#1|)))) (|HasCategory| |#2| (LIST (QUOTE |FiniteRankNonAssociativeAlgebra|) (|devaluate| |#1|))) (OR (|HasCategory| |#2| (LIST (QUOTE |FiniteRankNonAssociativeAlgebra|) (|devaluate| |#1|))) (|HasCategory| |#2| (LIST (QUOTE |FramedNonAssociativeAlgebra|) (|devaluate| |#1|)))) (OR (AND (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (LIST (QUOTE |FiniteRankNonAssociativeAlgebra|) (|devaluate| |#1|)))) (AND (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (LIST (QUOTE |FramedNonAssociativeAlgebra|) (|devaluate| |#1|)))))) 
(|PowerSeriesLimitPackage| R FE) 
((|constructor| (NIL "PowerSeriesLimitPackage implements limits of expressions in one or more variables as one of the variables approaches a limiting value. Included are two-sided limits, left- and right- hand limits, and limits at plus or minus infinity.")) (|complexLimit| (((|Union| (|OnePointCompletion| |#2|) "failed") |#2| (|Equation| (|OnePointCompletion| |#2|))) "\\spad{complexLimit(f(x),x = a)} computes the complex limit \\spad{lim(x \\spad{->} a,f(x))}.")) (|limit| (((|Union| (|OrderedCompletion| |#2|) "failed") |#2| (|Equation| |#2|) (|String|)) "\\spad{limit(f(x),x=a,\"left\")} computes the left hand real limit \\spad{lim(x \\spad{->} a-,f(x))}; \\spad{limit(f(x),x=a,\"right\")} computes the right hand real limit \\spad{lim(x \\spad{->} a+,f(x))}.") (((|Union| (|OrderedCompletion| |#2|) (|Record| (|:| |leftHandLimit| (|Union| (|OrderedCompletion| |#2|) "failed")) (|:| |rightHandLimit| (|Union| (|OrderedCompletion| |#2|) "failed"))) "failed") |#2| (|Equation| (|OrderedCompletion| |#2|))) "\\spad{limit(f(x),x = a)} computes the real limit \\spad{lim(x \\spad{->} a,f(x))}."))) 
NIL 
NIL 
(|RationalFunctionLimitPackage| R) 
((|constructor| (NIL "Computation of limits for rational functions.")) (|complexLimit| (((|OnePointCompletion| (|Fraction| (|Polynomial| |#1|))) (|Fraction| (|Polynomial| |#1|)) (|Equation| (|Fraction| (|Polynomial| |#1|)))) "\\spad{complexLimit(f(x),x = a)} computes the complex limit of \\spad{f} as its argument \\spad{x} approaches \\spad{a}.") (((|OnePointCompletion| (|Fraction| (|Polynomial| |#1|))) (|Fraction| (|Polynomial| |#1|)) (|Equation| (|OnePointCompletion| (|Polynomial| |#1|)))) "\\spad{complexLimit(f(x),x = a)} computes the complex limit of \\spad{f} as its argument \\spad{x} approaches \\spad{a}.")) (|limit| (((|Union| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|))) "failed") (|Fraction| (|Polynomial| |#1|)) (|Equation| (|Fraction| (|Polynomial| |#1|))) (|String|)) "\\spad{limit(f(x),x,a,\"left\")} computes the real limit of \\spad{f} as its argument \\spad{x} approaches \\spad{a} from the left; limit(f(x),x,a,\"right\") computes the corresponding limit as \\spad{x} approaches \\spad{a} from the right.") (((|Union| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|))) (|Record| (|:| |leftHandLimit| (|Union| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|))) "failed")) (|:| |rightHandLimit| (|Union| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|))) "failed"))) "failed") (|Fraction| (|Polynomial| |#1|)) (|Equation| (|Fraction| (|Polynomial| |#1|)))) "\\spad{limit(f(x),x = a)} computes the real two-sided limit of \\spad{f} as its argument \\spad{x} approaches \\spad{a}.") (((|Union| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|))) (|Record| (|:| |leftHandLimit| (|Union| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|))) "failed")) (|:| |rightHandLimit| (|Union| (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|))) "failed"))) "failed") (|Fraction| (|Polynomial| |#1|)) (|Equation| (|OrderedCompletion| (|Polynomial| |#1|)))) "\\spad{limit(f(x),x = a)} computes the real two-sided limit of \\spad{f} as its argument \\spad{x} approaches \\spad{a}."))) 
NIL 
NIL 
(|LinearDependence| S R) 
((|constructor| (NIL "Test for linear dependence.")) (|solveLinear| (((|Union| (|Vector| (|Fraction| |#1|)) "failed") (|Vector| |#2|) |#2|) "\\spad{solveLinear([v1,...,vn], u)} returns \\spad{[c1,...,cn]} such that \\spad{c1*v1 + \\spad{...} + cn*vn = u}, \"failed\" if no such ci's exist in the quotient field of \\spad{S.}") (((|Union| (|Vector| |#1|) "failed") (|Vector| |#2|) |#2|) "\\spad{solveLinear([v1,...,vn], u)} returns \\spad{[c1,...,cn]} such that \\spad{c1*v1 + \\spad{...} + cn*vn = u}, \"failed\" if no such ci's exist in \\spad{S.}")) (|linearDependence| (((|Union| (|Vector| |#1|) "failed") (|Vector| |#2|)) "\\spad{linearDependence([v1,...,vn])} returns \\spad{[c1,...,cn]} if \\spad{c1*v1 + \\spad{...} + cn*vn = 0} and not all the ci's are 0, \"failed\" if the vi's are linearly independent over \\spad{S.}")) (|linearlyDependent?| (((|Boolean|) (|Vector| |#2|)) "\\spad{linearlyDependent?([v1,...,vn])} returns \\spad{true} if the vi's are linearly dependent over \\spad{S,} \\spad{false} otherwise."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|Field|))) (|not| (|HasCategory| |#1| (QUOTE (|Field|))))) 
(|LinearlyExplicitRingOver| R) 
((|constructor| (NIL "An extension ring with an explicit linear dependence test.")) (|reducedSystem| (((|Record| (|:| |mat| (|Matrix| |#1|)) (|:| |vec| (|Vector| |#1|))) (|Matrix| $) (|Vector| $)) "\\spad{reducedSystem(A, \\spad{v)}} returns a matrix \\spad{B} and a vector \\spad{w} such that \\spad{A \\spad{x} = \\spad{v}} and \\spad{B \\spad{x} = \\spad{w}} have the same solutions in \\spad{R.}") (((|Matrix| |#1|) (|Matrix| $)) "\\spad{reducedSystem(A)} returns a matrix \\spad{B} such that \\spad{A \\spad{x} = 0} and \\spad{B \\spad{x} = 0} have the same solutions in \\spad{R.}"))) 
((|unitsKnown| . T)) 
NIL 
(|ListToMap| A B) 
((|constructor| (NIL "\\spadtype{ListToMap} allows mappings to be described by a pair of lists of equal lengths. The image of an element \\spad{x}, which appears in position \\spad{n} in the first list, is then the \\spad{n}th element of the second list. A default value or default function can be specified to be used when \\spad{x} does not appear in the first list. In the absence of defaults, an error will occur in that case.")) (|match| ((|#2| (|List| |#1|) (|List| |#2|) |#1| (|Mapping| |#2| |#1|)) "\\spad{match(la, \\spad{lb,} a, \\spad{f)}} creates a map defined by lists \\spad{la} and \\spad{lb} of equal length. and applies this map to a. The target of a source value \\spad{x} in \\spad{la} is the value \\spad{y} with the same index \\spad{lb.} Argument \\spad{f} is a default function to call if a is not in la. The value returned is then obtained by applying \\spad{f} to argument a.") (((|Mapping| |#2| |#1|) (|List| |#1|) (|List| |#2|) (|Mapping| |#2| |#1|)) "\\spad{match(la, \\spad{lb,} \\spad{f)}} creates a map defined by lists \\spad{la} and \\spad{lb} of equal length. The target of a source value \\spad{x} in \\spad{la} is the value \\spad{y} with the same index \\spad{lb.} Argument \\spad{f} is used as the function to call when the given function argument is not in \\spad{la}. The value returned is \\spad{f} applied to that argument.") ((|#2| (|List| |#1|) (|List| |#2|) |#1| |#2|) "\\spad{match(la, \\spad{lb,} a, \\spad{b)}} creates a map defined by lists \\spad{la} and \\spad{lb} of equal length. and applies this map to a. The target of a source value \\spad{x} in \\spad{la} is the value \\spad{y} with the same index \\spad{lb.} Argument \\spad{b} is the default target value if a is not in la. Error: if \\spad{la} and \\spad{lb} are not of equal length.") (((|Mapping| |#2| |#1|) (|List| |#1|) (|List| |#2|) |#2|) "\\spad{match(la, \\spad{lb,} \\spad{b)}} creates a map defined by lists \\spad{la} and \\spad{lb} of equal length, where \\spad{b} is used as the default target value if the given function argument is not in \\spad{la}. The target of a source value \\spad{x} in \\spad{la} is the value \\spad{y} with the same index \\spad{lb.} Error: if \\spad{la} and \\spad{lb} are not of equal length.") ((|#2| (|List| |#1|) (|List| |#2|) |#1|) "\\spad{match(la, \\spad{lb,} a)} creates a map defined by lists \\spad{la} and \\spad{lb} of equal length, where \\spad{a} is used as the default source value if the given one is not in \\spad{la}. The target of a source value \\spad{x} in \\spad{la} is the value \\spad{y} with the same index \\spad{lb.} Error: if \\spad{la} and \\spad{lb} are not of equal length.") (((|Mapping| |#2| |#1|) (|List| |#1|) (|List| |#2|)) "\\spad{match(la, lb)} creates a map with no default source or target values defined by lists \\spad{la} and \\spad{lb} of equal length. The target of a source value \\spad{x} in \\spad{la} is the value \\spad{y} with the same index \\spad{lb.} Error: if \\spad{la} and \\spad{lb} are not of equal length. Note that when this map is applied, an error occurs when applied to a value missing from la."))) 
NIL 
NIL 
(|ListFunctions2| A B) 
((|constructor| (NIL "\\spadtype{ListFunctions2} implements utility functions that operate on two kinds of lists, each with a possibly different type of element.")) (|map| (((|List| |#2|) (|Mapping| |#2| |#1|) (|List| |#1|)) "\\spad{map(fn,u)} applies \\spad{fn} to each element of list \\spad{u} and returns a new list with the results. For example \\spad{map(square,[1,2,3]) = [1,4,9]}.")) (|reduce| ((|#2| (|Mapping| |#2| |#1| |#2|) (|List| |#1|) |#2|) "\\spad{reduce(fn,u,ident)} successively uses the binary function \\spad{fn} on the elements of list \\spad{u} and the result of previous applications. \\spad{ident} is returned if the \\spad{u} is empty. Note the order of application in the following examples: \\spad{reduce(fn,[1,2,3],0) = fn(3,fn(2,fn(1,0)))} and \\spad{reduce(*,[2,3],1) = 3 * \\spad{(2} * 1)}.")) (|scan| (((|List| |#2|) (|Mapping| |#2| |#1| |#2|) (|List| |#1|) |#2|) "\\spad{scan(fn,u,ident)} successively uses the binary function \\spad{fn} to reduce more and more of list \\spad{u}. \\spad{ident} is returned if the \\spad{u} is empty. The result is a list of the reductions at each step. See \\spadfun{reduce} for more information. Examples: \\spad{scan(fn,[1,2],0) = [fn(2,fn(1,0)),fn(1,0)]} and \\spad{scan(*,[2,3],1) = \\spad{[2} * 1, 3 * \\spad{(2} * 1)]}."))) 
NIL 
NIL 
(|ListFunctions3| A B C) 
((|constructor| (NIL "\\spadtype{ListFunctions3} implements utility functions that operate on three kinds of lists, each with a possibly different type of element.")) (|map| (((|List| |#3|) (|Mapping| |#3| |#1| |#2|) (|List| |#1|) (|List| |#2|)) "\\spad{map(fn,list1, u2)} applies the binary function \\spad{fn} to corresponding elements of lists \\spad{u1} and \\spad{u2} and returns a list of the results (in the same order). Thus \\spad{map(/,[1,2,3],[4,5,6]) = [1/4,2/4,1/2]}. The computation terminates when the end of either list is reached. That is, the length of the result list is equal to the minimum of the lengths of \\spad{u1} and \\spad{u2}."))) 
NIL 
NIL 
(|List| S) 
((|constructor| (NIL "\\spadtype{List} implements singly-linked lists that are addressable by indices; the index of the first element is 1. In addition to the operations provided by \\spadtype{IndexedList}, this constructor provides some LISP-like functions such as \\spadfun{null} and \\spadfun{cons}.")) (|setDifference| (($ $ $) "\\spad{setDifference(u1,u2)} returns a list of the elements of \\spad{u1} that are not also in \\spad{u2}. The order of elements in the resulting list is unspecified.")) (|setIntersection| (($ $ $) "\\spad{setIntersection(u1,u2)} returns a list of the elements that lists \\spad{u1} and \\spad{u2} have in common. The order of elements in the resulting list is unspecified.")) (|setUnion| (($ $ $) "\\spad{setUnion(u1,u2)} appends the two lists \\spad{u1} and u2, then removes all duplicates. The order of elements in the resulting list is unspecified.")) (|append| (($ $ $) "\\spad{append(u1,u2)} appends the elements of list \\spad{u1} onto the front of list \\spad{u2}. This new list and \\spad{u2} will share some structure.")) (|cons| (($ |#1| $) "\\spad{cons(element,u)} appends \\spad{element} onto the front of list \\spad{u} and returns the new list. This new list and the old one will share some structure.")) (|null| (((|Boolean|) $) "\\spad{null(u)} tests if list \\spad{u} is the empty list.")) (|nil| (($) "\\spad{nil()} returns the empty list."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|OpenMath|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|LinearSystemFromPowerSeriesPackage| K PCS) 
((|constructor| (NIL "Part of the PAFF package")) (|finiteSeries2LinSys| (((|Matrix| |#1|) (|List| |#2|) (|Integer|)) "\\spad{finiteSeries2LinSys(ls,n)} returns a matrix which right kernel is the solution of the linear combinations of the series in \\spad{ls} which has order greater or equal to \\spad{n.} NOTE: All the series in \\spad{ls} must be finite and must have order at least 0: so one must first call on each of them the function filterUpTo(s,n) and apply an appropriate shift (mult by a power of \\spad{t).}"))) 
NIL 
NIL 
(|ListMultiDictionary| S) 
((|constructor| (NIL "The \\spadtype{ListMultiDictionary} domain implements a dictionary with duplicates allowed. The representation is a list with duplicates represented explicitly. Hence most operations will be relatively inefficient when the number of entries in the dictionary becomes large. If the objects in the dictionary belong to an ordered set, the entries are maintained in ascending order.")) (|substitute| (($ |#1| |#1| $) "\\spad{substitute(x,y,d)} replace \\spad{x's} with \\spad{y's} in dictionary \\spad{d.}")) (|duplicates?| (((|Boolean|) $) "\\spad{duplicates?(d)} tests if dictionary \\spad{d} has duplicate entries."))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) 
(|LeftModule| R) 
((|constructor| (NIL "The category of left modules over an \\spad{rng} (ring not necessarily with unit). This is an abelian group which supports left multiplation by elements of the rng. \\blankline Axioms\\br \\tab{5}\\spad{ (a*b)*x = a*(b*x) }\\br \\tab{5}\\spad{ (a+b)*x = (a*x)+(b*x) }\\br \\tab{5}\\spad{ a*(x+y) = (a*x)+(a*y) }")) (* (($ |#1| $) "\\spad{r*x} returns the left multiplication of the module element \\spad{x} by the ring element \\spad{r.}"))) 
NIL 
NIL 
(|ListMonoidOps| S E |un|) 
((|constructor| (NIL "This internal package represents monoid (abelian or not, with or without inverses) as lists and provides some common operations to the various flavors of monoids.")) (|mapGen| (($ (|Mapping| |#1| |#1|) $) "\\spad{mapGen(f, \\spad{a1\\^e1} \\spad{...} an\\^en)} returns \\spad{f(a1)\\^e1 \\spad{...} f(an)\\^en}.")) (|mapExpon| (($ (|Mapping| |#2| |#2|) $) "\\spad{mapExpon(f, \\spad{a1\\^e1} \\spad{...} an\\^en)} returns \\spad{a1\\^f(e1) \\spad{...} an\\^f(en)}.")) (|commutativeEquality| (((|Boolean|) $ $) "\\spad{commutativeEquality(x,y)} returns \\spad{true} if \\spad{x} and \\spad{y} are equal assuming commutativity")) (|plus| (($ $ $) "\\spad{plus(x, \\spad{y)}} returns \\spad{x + \\spad{y}} where \\spad{+} is the monoid operation, which is assumed commutative.") (($ |#1| |#2| $) "\\spad{plus(s, e, \\spad{x)}} returns \\spad{e * \\spad{s} + \\spad{x}} where \\spad{+} is the monoid operation, which is assumed commutative.")) (|leftMult| (($ |#1| $) "\\spad{leftMult(s, a)} returns \\spad{s * a} where \\spad{*} is the monoid operation, which is assumed non-commutative.")) (|rightMult| (($ $ |#1|) "\\spad{rightMult(a, \\spad{s)}} returns \\spad{a * \\spad{s}} where \\spad{*} is the monoid operation, which is assumed non-commutative.")) (|makeUnit| (($) "\\spad{makeUnit()} returns the unit element of the monomial.")) (|size| (((|NonNegativeInteger|) $) "\\spad{size(l)} returns the number of monomials forming \\spad{l.}")) (|reverse!| (($ $) "\\spad{reverse!(l)} reverses the list of monomials forming \\spad{l,} destroying the element \\spad{l.}")) (|reverse| (($ $) "\\spad{reverse(l)} reverses the list of monomials forming \\spad{l.} This has some effect if the monoid is non-abelian, \\spadignore{i.e.} \\spad{reverse(a1\\^e1 \\spad{...} an\\^en) = an\\^en \\spad{...} a1\\^e1} which is different.")) (|nthFactor| ((|#1| $ (|Integer|)) "\\spad{nthFactor(l, \\spad{n)}} returns the factor of the n^th monomial of \\spad{l.}")) (|nthExpon| ((|#2| $ (|Integer|)) "\\spad{nthExpon(l, \\spad{n)}} returns the exponent of the n^th monomial of \\spad{l.}")) (|makeMulti| (($ (|List| (|Record| (|:| |gen| |#1|) (|:| |exp| |#2|)))) "\\spad{makeMulti(l)} returns the element whose list of monomials is \\spad{l.}")) (|makeTerm| (($ |#1| |#2|) "\\spad{makeTerm(s, e)} returns the monomial \\spad{s} exponentiated by \\spad{e} (\\spadignore{e.g.} s^e or \\spad{e} * \\spad{s).}")) (|listOfMonoms| (((|List| (|Record| (|:| |gen| |#1|) (|:| |exp| |#2|))) $) "\\spad{listOfMonoms(l)} returns the list of the monomials forming \\spad{l.}")) (|outputForm| (((|OutputForm|) $ (|Mapping| (|OutputForm|) (|OutputForm|) (|OutputForm|)) (|Mapping| (|OutputForm|) (|OutputForm|) (|OutputForm|)) (|Integer|)) "\\spad{outputForm(l, fop, fexp, unit)} converts the monoid element represented by \\spad{l} to an \\spadtype{OutputForm}. Argument unit is the output form for the \\spadignore{unit} of the monoid (\\spadignore{e.g.} 0 or 1), \\spad{fop(a, \\spad{b)}} is the output form for the monoid operation applied to \\spad{a} and \\spad{b} (\\spadignore{e.g.} \\spad{a + \\spad{b},} \\spad{a * \\spad{b},} \\spad{ab}), and \\spad{fexp(a, \\spad{n)}} is the output form for the exponentiation operation applied to \\spad{a} and \\spad{n} (\\spadignore{e.g.} \\spad{n a}, \\spad{n * a}, \\spad{a \\spad{**} \\spad{n},} \\spad{a\\^n})."))) 
NIL 
NIL 
(|LinearAggregate&| A S) 
((|constructor| (NIL "A linear aggregate is an aggregate whose elements are indexed by integers. Examples of linear aggregates are strings, lists, and arrays. Most of the exported operations for linear aggregates are non-destructive but are not always efficient for a particular aggregate. For example, \\spadfun{concat} of two lists needs only to copy its first argument, whereas \\spadfun{concat} of two arrays needs to copy both arguments. Most of the operations exported here apply to infinite objects (\\spadignore{e.g.} streams) as well to finite ones. For finite linear aggregates, see \\spadtype{FiniteLinearAggregate}.")) (|setelt| ((|#2| $ (|UniversalSegment| (|Integer|)) |#2|) "\\spad{setelt(u,i..j,x)} (also written: \\axiom{u(i..j) \\spad{:=} \\spad{x})} destructively replaces each element in the segment \\axiom{u(i..j)} by \\spad{x.} The value \\spad{x} is returned. Note that \\spad{u} is destructively change so that \\axiom{u.k \\spad{:=} \\spad{x} for \\spad{k} in i..j}; its length remains unchanged.")) (|insert| (($ $ $ (|Integer|)) "\\spad{insert(v,u,k)} returns a copy of \\spad{u} having \\spad{v} inserted beginning at the \\axiom{i}th element. Note that \\axiom{insert(v,u,k) = concat( u(0..k-1), \\spad{v,} u(k..) \\spad{)}.}") (($ |#2| $ (|Integer|)) "\\spad{insert(x,u,i)} returns a copy of \\spad{u} having \\spad{x} as its \\axiom{i}th element. Note that \\axiom{insert(x,a,k) = concat(concat(a(0..k-1),x),a(k..))}.")) (|delete| (($ $ (|UniversalSegment| (|Integer|))) "\\spad{delete(u,i..j)} returns a copy of \\spad{u} with the \\axiom{i}th through \\axiom{j}th element deleted. Note that \\axiom{delete(a,i..j) = concat(a(0..i-1),a(j+1..))}.") (($ $ (|Integer|)) "\\spad{delete(u,i)} returns a copy of \\spad{u} with the \\axiom{i}th element deleted. Note that for lists, \\axiom{delete(a,i) \\spad{==} concat(a(0..i - 1),a(i + 1,..))}.")) (|elt| (($ $ (|UniversalSegment| (|Integer|))) "\\spad{elt(u,i..j)} (also written: \\axiom{a(i..j)}) returns the aggregate of elements \\axiom{u} for \\spad{k} from \\spad{i} to \\spad{j} in that order. Note that in general, \\axiom{a.s = [a.k for \\spad{i} in s]}.")) (|map| (($ (|Mapping| |#2| |#2| |#2|) $ $) "\\spad{map(f,u,v)} returns a new collection \\spad{w} with elements \\axiom{z = f(x,y)} for corresponding elements \\spad{x} and \\spad{y} from \\spad{u} and \\spad{v.} Note that for linear aggregates, \\axiom{w.i = f(u.i,v.i)}.")) (|concat| (($ (|List| $)) "\\spad{concat(u)}, where \\spad{u} is a lists of aggregates \\axiom{[a,b,...,c]}, returns a single aggregate consisting of the elements of \\axiom{a} followed by those of \\spad{b} followed \\spad{...} by the elements of \\spad{c.} Note that \\axiom{concat(a,b,...,c) = concat(a,concat(b,...,c))}.") (($ $ $) "\\spad{concat(u,v)} returns an aggregate consisting of the elements of \\spad{u} followed by the elements of \\spad{v.} Note that if \\axiom{w = concat(u,v)} then \\axiom{w.i = u.i for \\spad{i} in indices u} and \\axiom{w.(j + maxIndex u) = \\spad{v.j} for \\spad{j} in indices \\spad{v}.}") (($ |#2| $) "\\spad{concat(x,u)} returns aggregate \\spad{u} with additional element at the front. Note that for lists: \\axiom{concat(x,u) \\spad{==} concat([x],u)}.") (($ $ |#2|) "\\spad{concat(u,x)} returns aggregate \\spad{u} with additional element \\spad{x} at the end. Note that for lists, \\axiom{concat(u,x) \\spad{==} concat(u,[x])}")) (|new| (($ (|NonNegativeInteger|) |#2|) "\\spad{new(n,x)} returns \\axiom{fill!(new n,x)}."))) 
NIL 
((|HasAttribute| |#1| (QUOTE |shallowlyMutable|))) 
(|LinearAggregate| S) 
((|constructor| (NIL "A linear aggregate is an aggregate whose elements are indexed by integers. Examples of linear aggregates are strings, lists, and arrays. Most of the exported operations for linear aggregates are non-destructive but are not always efficient for a particular aggregate. For example, \\spadfun{concat} of two lists needs only to copy its first argument, whereas \\spadfun{concat} of two arrays needs to copy both arguments. Most of the operations exported here apply to infinite objects (\\spadignore{e.g.} streams) as well to finite ones. For finite linear aggregates, see \\spadtype{FiniteLinearAggregate}.")) (|setelt| ((|#1| $ (|UniversalSegment| (|Integer|)) |#1|) "\\spad{setelt(u,i..j,x)} (also written: \\axiom{u(i..j) \\spad{:=} \\spad{x})} destructively replaces each element in the segment \\axiom{u(i..j)} by \\spad{x.} The value \\spad{x} is returned. Note that \\spad{u} is destructively change so that \\axiom{u.k \\spad{:=} \\spad{x} for \\spad{k} in i..j}; its length remains unchanged.")) (|insert| (($ $ $ (|Integer|)) "\\spad{insert(v,u,k)} returns a copy of \\spad{u} having \\spad{v} inserted beginning at the \\axiom{i}th element. Note that \\axiom{insert(v,u,k) = concat( u(0..k-1), \\spad{v,} u(k..) \\spad{)}.}") (($ |#1| $ (|Integer|)) "\\spad{insert(x,u,i)} returns a copy of \\spad{u} having \\spad{x} as its \\axiom{i}th element. Note that \\axiom{insert(x,a,k) = concat(concat(a(0..k-1),x),a(k..))}.")) (|delete| (($ $ (|UniversalSegment| (|Integer|))) "\\spad{delete(u,i..j)} returns a copy of \\spad{u} with the \\axiom{i}th through \\axiom{j}th element deleted. Note that \\axiom{delete(a,i..j) = concat(a(0..i-1),a(j+1..))}.") (($ $ (|Integer|)) "\\spad{delete(u,i)} returns a copy of \\spad{u} with the \\axiom{i}th element deleted. Note that for lists, \\axiom{delete(a,i) \\spad{==} concat(a(0..i - 1),a(i + 1,..))}.")) (|elt| (($ $ (|UniversalSegment| (|Integer|))) "\\spad{elt(u,i..j)} (also written: \\axiom{a(i..j)}) returns the aggregate of elements \\axiom{u} for \\spad{k} from \\spad{i} to \\spad{j} in that order. Note that in general, \\axiom{a.s = [a.k for \\spad{i} in s]}.")) (|map| (($ (|Mapping| |#1| |#1| |#1|) $ $) "\\spad{map(f,u,v)} returns a new collection \\spad{w} with elements \\axiom{z = f(x,y)} for corresponding elements \\spad{x} and \\spad{y} from \\spad{u} and \\spad{v.} Note that for linear aggregates, \\axiom{w.i = f(u.i,v.i)}.")) (|concat| (($ (|List| $)) "\\spad{concat(u)}, where \\spad{u} is a lists of aggregates \\axiom{[a,b,...,c]}, returns a single aggregate consisting of the elements of \\axiom{a} followed by those of \\spad{b} followed \\spad{...} by the elements of \\spad{c.} Note that \\axiom{concat(a,b,...,c) = concat(a,concat(b,...,c))}.") (($ $ $) "\\spad{concat(u,v)} returns an aggregate consisting of the elements of \\spad{u} followed by the elements of \\spad{v.} Note that if \\axiom{w = concat(u,v)} then \\axiom{w.i = u.i for \\spad{i} in indices u} and \\axiom{w.(j + maxIndex u) = \\spad{v.j} for \\spad{j} in indices \\spad{v}.}") (($ |#1| $) "\\spad{concat(x,u)} returns aggregate \\spad{u} with additional element at the front. Note that for lists: \\axiom{concat(x,u) \\spad{==} concat([x],u)}.") (($ $ |#1|) "\\spad{concat(u,x)} returns aggregate \\spad{u} with additional element \\spad{x} at the end. Note that for lists, \\axiom{concat(u,x) \\spad{==} concat(u,[x])}")) (|new| (($ (|NonNegativeInteger|) |#1|) "\\spad{new(n,x)} returns \\axiom{fill!(new n,x)}."))) 
((|nil| . T)) 
NIL 
(|LocalPowerSeriesCategory| K) 
((|printInfo| (((|Boolean|)) "returns the value of the \\spad{printInfo} flag.") (((|Boolean|) (|Boolean|)) "\\spad{printInfo(b)} set a flag such that when \\spad{true} \\spad{(b} \\spad{<-} true) prints some information during some critical computation.")) (|coefOfFirstNonZeroTerm| ((|#1| $) "\\spad{coefOfFirstNonZeroTerm(s)} returns the first non zero coefficient of the series.")) (|filterUpTo| (($ $ (|Integer|)) "\\spad{filterUpTo(s,n)} returns the series consisting of the terms of \\spad{s} having degree strictly less than \\spad{n.}")) (|shift| (($ $ (|Integer|)) "\\spad{shift(s,n)} returns t**n * \\spad{s}")) (|series| (($ (|Integer|) |#1| $) "\\spad{series(e,c,s)} create the series c*t**e + \\spad{s.}")) (|removeZeroes| (($ $) "\\spad{removeZeroes(s)} removes the zero terms in \\spad{s.}") (($ (|Integer|) $) "\\spad{removeZeroes(n,s)} removes the zero terms in the first \\spad{n} terms of \\spad{s.}")) (|monomial2series| (($ (|List| $) (|List| (|NonNegativeInteger|)) (|Integer|)) "\\spad{monomial2series(ls,le,n)} returns t**n * reduce(\"*\",[s \\spad{**} \\spad{e} for \\spad{s} in \\spad{ls} for \\spad{e} in le])")) (|delay| (($ (|Mapping| $)) "\\spad{delay delayed} the computation of the next term of the series given by the input function.")) (|posExpnPart| (($ $) "\\spad{posExpnPart(s)} returns the series \\spad{s} less the terms with negative exponant.")) (|order| (((|Integer|) $) "\\spad{order(s)} returns the order of \\spad{s.}"))) 
(((|commutative| "*") . T) (|noZeroDivisors| . T) (|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|ElementaryFunctionLODESolver| R F L) 
((|constructor| (NIL "\\spad{ElementaryFunctionLODESolver} provides the top-level functions for finding closed form solutions of linear ordinary differential equations and initial value problems.")) (|solve| (((|Union| |#2| "failed") |#3| |#2| (|Symbol|) |#2| (|List| |#2|)) "\\spad{solve(op, \\spad{g,} \\spad{x,} a, [y0,...,ym])} returns either the solution of the initial value problem \\spad{op \\spad{y} = \\spad{g,} y(a) = \\spad{y0,} y'(a) = y1,...} or \"failed\" if the solution cannot be found; \\spad{x} is the dependent variable.") (((|Union| (|Record| (|:| |particular| |#2|) (|:| |basis| (|List| |#2|))) "failed") |#3| |#2| (|Symbol|)) "\\spad{solve(op, \\spad{g,} \\spad{x)}} returns either a solution of the ordinary differential equation \\spad{op \\spad{y} = \\spad{g}} or \"failed\" if no non-trivial solution can be found; When found, the solution is returned in the form \\spad{[h, [b1,...,bm]]} where \\spad{h} is a particular solution and and \\spad{[b1,...bm]} are linearly independent solutions of the associated homogenuous equation \\spad{op \\spad{y} = 0}. A full basis for the solutions of the homogenuous equation is not always returned, only the solutions which were found; \\spad{x} is the dependent variable."))) 
NIL 
NIL 
(|LinearOrdinaryDifferentialOperator1| A) 
((|constructor| (NIL "\\spad{LinearOrdinaryDifferentialOperator1} defines a ring of differential operators with coefficients in a differential ring A. Multiplication of operators corresponds to functional composition:\\br \\spad{(L1 * L2).(f) = \\spad{L1} \\spad{L2} \\spad{f}}"))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) 
(|LinearOrdinaryDifferentialOperator2| A M) 
((|constructor| (NIL "\\spad{LinearOrdinaryDifferentialOperator2} defines a ring of differential operators with coefficients in a differential ring A and acting on an A-module \\spad{M.} Multiplication of operators corresponds to functional composition:\\br \\spad{(L1 * L2).(f) = \\spad{L1} \\spad{L2} \\spad{f}}")) (|differentiate| (($ $) "\\spad{differentiate(x)} returns the derivative of \\spad{x}"))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) 
(|LinearOrdinaryDifferentialOperatorCategory&| S A) 
((|constructor| (NIL "LinearOrdinaryDifferentialOperatorCategory is the category of differential operators with coefficients in a ring A with a given derivation. \\blankline Multiplication of operators corresponds to functional composition:\\br \\spad{(L1} * L2).(f) = \\spad{L1} \\spad{L2} \\spad{f}")) (|directSum| (($ $ $) "\\spad{directSum(a,b)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the sums of a solution of \\spad{a} by a solution of \\spad{b}.")) (|symmetricSquare| (($ $) "\\spad{symmetricSquare(a)} computes \\spad{symmetricProduct(a,a)} using a more efficient method.")) (|symmetricPower| (($ $ (|NonNegativeInteger|)) "\\spad{symmetricPower(a,n)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the products of \\spad{n} solutions of \\spad{a}.")) (|symmetricProduct| (($ $ $) "\\spad{symmetricProduct(a,b)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the products of a solution of \\spad{a} by a solution of \\spad{b}.")) (|adjoint| (($ $) "\\spad{adjoint(a)} returns the adjoint operator of a.")) (D (($) "\\spad{D()} provides the operator corresponding to a derivation in the ring \\spad{A}."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|Field|)))) 
(|LinearOrdinaryDifferentialOperatorCategory| A) 
((|constructor| (NIL "LinearOrdinaryDifferentialOperatorCategory is the category of differential operators with coefficients in a ring A with a given derivation. \\blankline Multiplication of operators corresponds to functional composition:\\br \\spad{(L1} * L2).(f) = \\spad{L1} \\spad{L2} \\spad{f}")) (|directSum| (($ $ $) "\\spad{directSum(a,b)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the sums of a solution of \\spad{a} by a solution of \\spad{b}.")) (|symmetricSquare| (($ $) "\\spad{symmetricSquare(a)} computes \\spad{symmetricProduct(a,a)} using a more efficient method.")) (|symmetricPower| (($ $ (|NonNegativeInteger|)) "\\spad{symmetricPower(a,n)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the products of \\spad{n} solutions of \\spad{a}.")) (|symmetricProduct| (($ $ $) "\\spad{symmetricProduct(a,b)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the products of a solution of \\spad{a} by a solution of \\spad{b}.")) (|adjoint| (($ $) "\\spad{adjoint(a)} returns the adjoint operator of a.")) (D (($) "\\spad{D()} provides the operator corresponding to a derivation in the ring \\spad{A}."))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|LinearOrdinaryDifferentialOperatorFactorizer| F UP) 
((|constructor| (NIL "\\spadtype{LinearOrdinaryDifferentialOperatorFactorizer} provides a factorizer for linear ordinary differential operators whose coefficients are rational functions.")) (|factor1| (((|List| (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))) (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))) "\\spad{factor1(a)} returns the factorisation of a, assuming that a has no first-order right factor.")) (|factor| (((|List| (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))) (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))) "\\spad{factor(a)} returns the factorisation of a.") (((|List| (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))) (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)) (|Mapping| (|List| |#1|) |#2|)) "\\spad{factor(a, zeros)} returns the factorisation of a. \\spad{zeros} is a zero finder in \\spad{UP}."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|AlgebraicallyClosedField|)))) 
(|LinearOrdinaryDifferentialOperator| A |diff|) 
((|constructor| (NIL "\\spad{LinearOrdinaryDifferentialOperator} defines a ring of differential operators with coefficients in a ring A with a given derivation. Multiplication of operators corresponds to functional composition:\\br \\spad{(L1 * L2).(f) = \\spad{L1} \\spad{L2} \\spad{f}}"))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) 
(|LinearOrdinaryDifferentialOperatorsOps| A L) 
((|constructor| (NIL "\\spad{LinearOrdinaryDifferentialOperatorsOps} provides symmetric products and sums for linear ordinary differential operators.")) (|directSum| ((|#2| |#2| |#2| (|Mapping| |#1| |#1|)) "\\spad{directSum(a,b,D)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the sums of a solution of \\spad{a} by a solution of \\spad{b}. \\spad{D} is the derivation to use.")) (|symmetricPower| ((|#2| |#2| (|NonNegativeInteger|) (|Mapping| |#1| |#1|)) "\\spad{symmetricPower(a,n,D)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the products of \\spad{n} solutions of \\spad{a}. \\spad{D} is the derivation to use.")) (|symmetricProduct| ((|#2| |#2| |#2| (|Mapping| |#1| |#1|)) "\\spad{symmetricProduct(a,b,D)} computes an operator \\spad{c} of minimal order such that the nullspace of \\spad{c} is generated by all the products of a solution of \\spad{a} by a solution of \\spad{b}. \\spad{D} is the derivation to use."))) 
NIL 
NIL 
(|Logic&| S) 
((|constructor| (NIL "Logic provides the basic operations for lattices, for example, boolean algebra.")) (|\\/| (($ $ $) "\\spadignore{\\/} returns the logical `join', for example, `or'.")) (|/\\| (($ $ $) "\\spadignore{/\\} returns the logical `meet', for example, `and'.")) (~ (($ $) "\\spad{~(x)} returns the logical complement of \\spad{x.}"))) 
NIL 
NIL 
(|Logic|) 
((|constructor| (NIL "Logic provides the basic operations for lattices, for example, boolean algebra.")) (|\\/| (($ $ $) "\\spadignore{\\/} returns the logical `join', for example, `or'.")) (|/\\| (($ $ $) "\\spadignore{/\\} returns the logical `meet', for example, `and'.")) (~ (($ $) "\\spad{~(x)} returns the logical complement of \\spad{x.}"))) 
NIL 
NIL 
(|Localize| M R S) 
((|constructor| (NIL "Localize(M,R,S) produces fractions with numerators from an \\spad{R} module \\spad{M} and denominators from some multiplicative subset \\spad{D} of \\spad{R.}")) (|denom| ((|#3| $) "\\spad{denom \\spad{x}} returns the denominator of \\spad{x.}")) (|numer| ((|#1| $) "\\spad{numer \\spad{x}} returns the numerator of \\spad{x.}")) (/ (($ |#1| |#3|) "\\spad{m / \\spad{d}} divides the element \\spad{m} by \\spad{d.}") (($ $ |#3|) "\\spad{x / \\spad{d}} divides the element \\spad{x} by \\spad{d.}"))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| |#1| (QUOTE (|OrderedAbelianGroup|)))) 
(|LinesOpPack| K) 
((|constructor| (NIL "A package that exports several linear algebra operations over lines of matrices. Part of the PAFF package.")) (|reduceRowOnList| (((|List| (|List| |#1|)) (|List| |#1|) (|List| (|List| |#1|))) "\\spad{reduceRowOnList(v,lvec)} applies a row reduction on each of the element of \\spad{lv} using \\spad{v} according to a pivot in \\spad{v} which is set to be the first non nul element in \\spad{v.}")) (|reduceLineOverLine| (((|List| |#1|) (|List| |#1|) (|List| |#1|) |#1|) "\\spad{reduceLineOverLine(v1,v2,a)} returns \\spad{v1-a*v1} where \\indented{1}{v1 and \\spad{v2} are considered as vector space.}")) (|quotVecSpaceBasis| (((|List| (|List| |#1|)) (|List| (|List| |#1|)) (|List| (|List| |#1|))) "\\spad{quotVecSpaceBasis(b1,b2)} returns a basis of \\spad{V1/V2} where \\spad{V1} and \\spad{V2} are vector space with basis \\spad{b1} and \\spad{b2} resp. and \\spad{V2} is suppose to be include in \\spad{V1;} Note that if it is not the case then it returs the basis of V1/W where \\spad{W} = intersection of \\spad{V1} and \\spad{V2}")) (|reduceRow| (((|List| (|List| |#1|)) (|List| (|List| |#1|))) "reduceRow: if the input is considered as a matrix, the output would be the row reduction matrix. It's almost the rowEchelon form except that no permution of lines is performed."))) 
NIL 
NIL 
(|LeftOreRing|) 
((|constructor| (NIL "This is the category of left ore rings, that is noncommutative rings without zero divisors where we can compute the least left common multiple.")) (|lcmCoef| (((|Record| (|:| |llcmres| $) (|:| |coeff1| $) (|:| |coeff2| $)) $ $) "\\spad{lcmCoef(c1, c2)} computes (llcm_res, coeff1, coeff2) such that llcm_res is least left common multiple of \\spad{c1} and \\spad{c2} and llcm_res = \\spad{coeff1*c1} = \\spad{coeff2*c2}"))) 
((|noZeroDivisors| . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|LocalParametrizationOfSimplePointPackage| K |symb| |PolyRing| E |ProjPt| PCS |Plc|) 
((|constructor| (NIL "This package is part of the PAFF package")) (|localize| (((|Record| (|:| |fnc| |#3|) (|:| |crv| |#3|) (|:| |chart| (|List| (|Integer|)))) |#3| |#5| |#3| (|Integer|)) "\\spad{localize(f,pt,crv,n)} returns a record containing the polynomials \\spad{f} and \\spad{crv} translate to the origin with respect to \\spad{pt.} The last element of the records, consisting of three integers contains information about the local parameter that will be used (either \\spad{x} or \\spad{y):} the first integer correspond to the variable that will be used as a local parameter.")) (|pointDominateBy| ((|#5| |#7|) "\\spad{pointDominateBy(pl)} returns the projective point dominated by the place \\spad{pl.}")) (|localParamOfSimplePt| (((|List| |#6|) |#5| |#3| (|Integer|)) "\\spad{localParamOfSimplePt(pt,pol,n)} computes the local parametrization of the simple point \\spad{pt} on the curve defined by pol. This local parametrization is done according to the standard open affine plane set by \\spad{n}")) (|pointToPlace| ((|#7| |#5| |#3|) "\\spad{pointToPlace(pt,pol)} takes for input a simple point \\spad{pt} on the curve defined by \\spad{pol} and set the local parametrization of the point.")) (|printInfo| (((|Boolean|)) "returns the value of the \\spad{printInfo} flag.") (((|Boolean|) (|Boolean|)) "\\spad{printInfo(b)} set a flag such that when \\spad{true} \\spad{(b} \\spad{<-} true) prints some information during some critical computation."))) 
NIL 
NIL 
(|LinearPolynomialEquationByFractions| R) 
((|constructor| (NIL "Given a PolynomialFactorizationExplicit ring, this package provides a defaulting rule for the \\spad{solveLinearPolynomialEquation} operation, by moving into the field of fractions, and solving it there via the \\spad{multiEuclidean} operation.")) (|solveLinearPolynomialEquationByFractions| (((|Union| (|List| (|SparseUnivariatePolynomial| |#1|)) "failed") (|List| (|SparseUnivariatePolynomial| |#1|)) (|SparseUnivariatePolynomial| |#1|)) "\\spad{solveLinearPolynomialEquationByFractions([f1, ..., fn], \\spad{g)}} (where the \\spad{fi} are relatively prime to each other) returns a list of \\spad{ai} such that \\spad{g/prod \\spad{fi} = sum ai/fi} or returns \"failed\" if no such exists."))) 
NIL 
NIL 
(|LiePolynomial| |VarSet| R) 
((|constructor| (NIL "This type supports Lie polynomials in Lyndon basis see Free Lie Algebras by \\spad{C.} Reutenauer (Oxford science publications).")) (|construct| (($ $ (|LyndonWord| |#1|)) "\\axiom{construct(x,y)} returns the Lie bracket \\axiom{[x,y]}.") (($ (|LyndonWord| |#1|) $) "\\axiom{construct(x,y)} returns the Lie bracket \\axiom{[x,y]}.") (($ (|LyndonWord| |#1|) (|LyndonWord| |#1|)) "\\axiom{construct(x,y)} returns the Lie bracket \\axiom{[x,y]}.")) (|LiePolyIfCan| (((|Union| $ "failed") (|XDistributedPolynomial| |#1| |#2|)) "\\axiom{LiePolyIfCan(p)} returns \\axiom{p} in Lyndon basis if \\axiom{p} is a Lie polynomial, otherwise \\axiom{\"failed\"} is returned."))) 
((|JacobiIdentity| . T) (|NullSquare| . T) (|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) 
(|ListAggregate&| A S) 
((|constructor| (NIL "A list aggregate is a model for a linked list data structure. A linked list is a versatile data structure. Insertion and deletion are efficient and searching is a linear operation.")) (|list| (($ |#2|) "\\spad{list(x)} returns the list of one element \\spad{x.}"))) 
NIL 
NIL 
(|ListAggregate| S) 
((|constructor| (NIL "A list aggregate is a model for a linked list data structure. A linked list is a versatile data structure. Insertion and deletion are efficient and searching is a linear operation.")) (|list| (($ |#1|) "\\spad{list(x)} returns the list of one element \\spad{x.}"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|LinearSystemMatrixPackage1| F) 
((|constructor| (NIL "This package solves linear system in the matrix form \\spad{AX = \\spad{B}.} It is essentially a particular instantiation of the package \\spadtype{LinearSystemMatrixPackage} for Matrix and Vector. This package's existence makes it easier to use \\spadfun{solve} in the AXIOM interpreter.")) (|rank| (((|NonNegativeInteger|) (|Matrix| |#1|) (|Vector| |#1|)) "\\spad{rank(A,B)} computes the rank of the complete matrix \\spad{(A|B)} of the linear system \\spad{AX = \\spad{B}.}")) (|hasSolution?| (((|Boolean|) (|Matrix| |#1|) (|Vector| |#1|)) "\\spad{hasSolution?(A,B)} tests if the linear system \\spad{AX = \\spad{B}} has a solution.")) (|particularSolution| (((|Union| (|Vector| |#1|) "failed") (|Matrix| |#1|) (|Vector| |#1|)) "\\spad{particularSolution(A,B)} finds a particular solution of the linear system \\spad{AX = \\spad{B}.}")) (|solve| (((|List| (|Record| (|:| |particular| (|Union| (|Vector| |#1|) "failed")) (|:| |basis| (|List| (|Vector| |#1|))))) (|List| (|List| |#1|)) (|List| (|Vector| |#1|))) "\\spad{solve(A,LB)} finds a particular soln of the systems \\spad{AX = \\spad{B}} and a basis of the associated homogeneous systems \\spad{AX = 0} where \\spad{B} varies in the list of column vectors \\spad{LB.}") (((|List| (|Record| (|:| |particular| (|Union| (|Vector| |#1|) "failed")) (|:| |basis| (|List| (|Vector| |#1|))))) (|Matrix| |#1|) (|List| (|Vector| |#1|))) "\\spad{solve(A,LB)} finds a particular soln of the systems \\spad{AX = \\spad{B}} and a basis of the associated homogeneous systems \\spad{AX = 0} where \\spad{B} varies in the list of column vectors \\spad{LB.}") (((|Record| (|:| |particular| (|Union| (|Vector| |#1|) "failed")) (|:| |basis| (|List| (|Vector| |#1|)))) (|List| (|List| |#1|)) (|Vector| |#1|)) "\\spad{solve(A,B)} finds a particular solution of the system \\spad{AX = \\spad{B}} and a basis of the associated homogeneous system \\spad{AX = 0}.") (((|Record| (|:| |particular| (|Union| (|Vector| |#1|) "failed")) (|:| |basis| (|List| (|Vector| |#1|)))) (|Matrix| |#1|) (|Vector| |#1|)) "\\spad{solve(A,B)} finds a particular solution of the system \\spad{AX = \\spad{B}} and a basis of the associated homogeneous system \\spad{AX = 0}."))) 
NIL 
NIL 
(|LinearSystemMatrixPackage| F |Row| |Col| M) 
((|constructor| (NIL "This package solves linear system in the matrix form \\spad{AX = \\spad{B}.}")) (|rank| (((|NonNegativeInteger|) |#4| |#3|) "\\spad{rank(A,B)} computes the rank of the complete matrix \\spad{(A|B)} of the linear system \\spad{AX = \\spad{B}.}")) (|hasSolution?| (((|Boolean|) |#4| |#3|) "\\spad{hasSolution?(A,B)} tests if the linear system \\spad{AX = \\spad{B}} has a solution.")) (|particularSolution| (((|Union| |#3| "failed") |#4| |#3|) "\\spad{particularSolution(A,B)} finds a particular solution of the linear system \\spad{AX = \\spad{B}.}")) (|solve| (((|List| (|Record| (|:| |particular| (|Union| |#3| "failed")) (|:| |basis| (|List| |#3|)))) |#4| (|List| |#3|)) "\\spad{solve(A,LB)} finds a particular soln of the systems \\spad{AX = \\spad{B}} and a basis of the associated homogeneous systems \\spad{AX = 0} where \\spad{B} varies in the list of column vectors \\spad{LB.}") (((|Record| (|:| |particular| (|Union| |#3| "failed")) (|:| |basis| (|List| |#3|))) |#4| |#3|) "\\spad{solve(A,B)} finds a particular solution of the system \\spad{AX = \\spad{B}} and a basis of the associated homogeneous system \\spad{AX = 0}."))) 
NIL 
NIL 
(|LinearSystemPolynomialPackage| R E OV P) 
((|constructor| (NIL "This package finds the solutions of linear systems presented as a list of polynomials.")) (|linSolve| (((|Record| (|:| |particular| (|Union| (|Vector| (|Fraction| |#4|)) "failed")) (|:| |basis| (|List| (|Vector| (|Fraction| |#4|))))) (|List| |#4|) (|List| |#3|)) "\\spad{linSolve(lp,lvar)} finds the solutions of the linear system of polynomials \\spad{lp} = 0 with respect to the list of symbols lvar."))) 
NIL 
NIL 
(|LieSquareMatrix| |n| R) 
((|constructor| (NIL "LieSquareMatrix(n,R) implements the Lie algebra of the \\spad{n} by \\spad{n} matrices over the commutative ring \\spad{R.} The Lie bracket (commutator) of the algebra is given by\\br \\spad{a*b \\spad{:=} (a *$SQMATRIX(n,R) \\spad{b} - \\spad{b} *$SQMATRIX(n,R) a)},\\br where \\spadfun{*$SQMATRIX(n,R)} is the usual matrix multiplication."))) 
((|unitsKnown| . T) (|finiteAggregate| . T) (|rightUnitary| . T) (|leftUnitary| . T)) 
((|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasAttribute| |#2| (QUOTE (|commutative| "*"))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (OR (|HasAttribute| |#2| (QUOTE (|commutative| "*"))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) 
(|LyndonWord| |VarSet|) 
((|constructor| (NIL "Lyndon words over arbitrary (ordered) symbols: see Free Lie Algebras by \\spad{C.} Reutenauer (Oxford science publications). A Lyndon word is a word which is smaller than any of its right factors w.r.t. the pure lexicographical ordering. If \\axiom{a} and \\axiom{b} are two Lyndon words such that \\axiom{a < \\spad{b}} holds w.r.t lexicographical ordering then \\axiom{a*b} is a Lyndon word. Parenthesized Lyndon words can be generated from symbols by using the following rule:\\br \\axiom{[[a,b],c]} is a Lyndon word iff \\axiom{a*b < \\spad{c} \\spad{<=} \\spad{b}} holds.\\br Lyndon words are internally represented by binary trees using the \\spadtype{Magma} domain constructor. Two ordering are provided: lexicographic and length-lexicographic.")) (|LyndonWordsList| (((|List| $) (|List| |#1|) (|PositiveInteger|)) "\\axiom{LyndonWordsList(vl, \\spad{n)}} returns the list of Lyndon words over the alphabet \\axiom{vl}, up to order \\axiom{n}.")) (|LyndonWordsList1| (((|OneDimensionalArray| (|List| $)) (|List| |#1|) (|PositiveInteger|)) "\\axiom{LyndonWordsList1(vl, \\spad{n)}} returns an array of lists of Lyndon words over the alphabet \\axiom{vl}, up to order \\axiom{n}.")) (|varList| (((|List| |#1|) $) "\\axiom{varList(x)} returns the list of distinct entries of \\axiom{x}.")) (|lyndonIfCan| (((|Union| $ "failed") (|OrderedFreeMonoid| |#1|)) "\\axiom{lyndonIfCan(w)} convert \\axiom{w} into a Lyndon word.")) (|lyndon| (($ (|OrderedFreeMonoid| |#1|)) "\\axiom{lyndon(w)} convert \\axiom{w} into a Lyndon word, error if \\axiom{w} is not a Lyndon word.")) (|lyndon?| (((|Boolean|) (|OrderedFreeMonoid| |#1|)) "\\axiom{lyndon?(w)} test if \\axiom{w} is a Lyndon word.")) (|factor| (((|List| $) (|OrderedFreeMonoid| |#1|)) "\\axiom{factor(x)} returns the decreasing factorization into Lyndon words.")) (|coerce| (((|Magma| |#1|) $) "\\axiom{coerce(x)} returns the element of \\axiomType{Magma}(VarSet) corresponding to \\axiom{x}.") (((|OrderedFreeMonoid| |#1|) $) "\\axiom{coerce(x)} returns the element of \\axiomType{OrderedFreeMonoid}(VarSet) corresponding to \\axiom{x}.")) (|lexico| (((|Boolean|) $ $) "\\axiom{lexico(x,y)} returns \\axiom{true} iff \\axiom{x} is smaller than \\axiom{y} w.r.t. the lexicographical ordering induced by \\axiom{VarSet}.")) (|length| (((|PositiveInteger|) $) "\\axiom{length(x)} returns the number of entries in \\axiom{x}.")) (|right| (($ $) "\\axiom{right(x)} returns right subtree of \\axiom{x} or error if retractable?(x) is true.")) (|left| (($ $) "\\axiom{left(x)} returns left subtree of \\axiom{x} or error if retractable?(x) is true.")) (|retractable?| (((|Boolean|) $) "\\axiom{retractable?(x)} tests if \\axiom{x} is a tree with only one entry."))) 
NIL 
NIL 
(|LazyStreamAggregate&| A S) 
((|constructor| (NIL "LazyStreamAggregate is the category of streams with lazy evaluation. It is understood that the function 'empty?' will cause lazy evaluation if necessary to determine if there are entries. Functions which call 'empty?', for example 'first' and 'rest', will also cause lazy evaluation if necessary.")) (|complete| (($ $) "\\spad{complete(st)} causes all entries of 'st' to be computed. \\indented{1}{this function should only be called on streams which are} \\indented{1}{known to be finite.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} n:=filterUntil(i+->i>100,m) \\spad{X} numberOfComputedEntries \\spad{n} \\spad{X} complete \\spad{n} \\spad{X} numberOfComputedEntries \\spad{n}")) (|extend| (($ $ (|Integer|)) "\\spad{extend(st,n)} causes entries to be computed, if necessary, \\indented{1}{so that 'st' will have at least \\spad{'n'} explicit entries or so} \\indented{1}{that all entries of 'st' will be computed if 'st' is finite} \\indented{1}{with length \\spad{<=} \\spad{n.}} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} numberOfComputedEntries \\spad{m} \\spad{X} extend(m,20) \\spad{X} numberOfComputedEntries \\spad{m}")) (|numberOfComputedEntries| (((|NonNegativeInteger|) $) "\\spad{numberOfComputedEntries(st)} returns the number of explicitly \\indented{1}{computed entries of stream \\spad{st} which exist immediately prior to the} \\indented{1}{time this function is called.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} numberOfComputedEntries \\spad{m}")) (|rst| (($ $) "\\spad{rst(s)} returns a pointer to the next node of stream \\spad{s.} \\indented{1}{Cautrion: this function should only be called after a \\spad{empty?}} \\indented{1}{test has been made since there no error check.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} \\spad{rst} \\spad{m}")) (|frst| ((|#2| $) "\\spad{frst(s)} returns the first element of stream \\spad{s.} \\indented{1}{Caution: this function should only be called after a \\spad{empty?}} \\indented{1}{test has been made since there no error check.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} frst \\spad{m}")) (|lazyEvaluate| (($ $) "\\spad{lazyEvaluate(s)} causes one lazy evaluation of stream \\spad{s.} \\indented{1}{Caution: the first node must be a lazy evaluation mechanism} \\indented{1}{(satisfies \\spad{lazy?(s) = true}) as there is no error check.} \\indented{1}{Note that a call to this function may} \\indented{1}{or may not produce an explicit first entry}")) (|lazy?| (((|Boolean|) $) "\\spad{lazy?(s)} returns \\spad{true} if the first node of the stream \\spad{s} \\indented{1}{is a lazy evaluation mechanism which could produce an} \\indented{1}{additional entry to \\spad{s.}} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} lazy? \\spad{m}")) (|explicitlyEmpty?| (((|Boolean|) $) "\\spad{explicitlyEmpty?(s)} returns \\spad{true} if the stream is an \\indented{1}{(explicitly) empty stream.} \\indented{1}{Note that this is a null test which will not cause lazy evaluation.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} explicitlyEmpty? \\spad{m}")) (|explicitEntries?| (((|Boolean|) $) "\\spad{explicitEntries?(s)} returns \\spad{true} if the stream \\spad{s} has \\indented{1}{explicitly computed entries, and \\spad{false} otherwise.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} explicitEntries? \\spad{m}")) (|select| (($ (|Mapping| (|Boolean|) |#2|) $) "\\spad{select(f,st)} returns a stream consisting of those elements of stream \\indented{1}{st satisfying the predicate \\spad{f.}} \\indented{1}{Note that \\spad{select(f,st) = \\spad{[x} for \\spad{x} in \\spad{st} | f(x)]}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} select(x+->prime? x,m)")) (|remove| (($ (|Mapping| (|Boolean|) |#2|) $) "\\spad{remove(f,st)} returns a stream consisting of those elements of stream \\indented{1}{st which do not satisfy the predicate \\spad{f.}} \\indented{1}{Note that \\spad{remove(f,st) = \\spad{[x} for \\spad{x} in \\spad{st} | not f(x)]}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} f(i:PositiveInteger):Boolean \\spad{==} even? \\spad{i} \\spad{X} remove(f,m)"))) 
NIL 
NIL 
(|LazyStreamAggregate| S) 
((|constructor| (NIL "LazyStreamAggregate is the category of streams with lazy evaluation. It is understood that the function 'empty?' will cause lazy evaluation if necessary to determine if there are entries. Functions which call 'empty?', for example 'first' and 'rest', will also cause lazy evaluation if necessary.")) (|complete| (($ $) "\\spad{complete(st)} causes all entries of 'st' to be computed. \\indented{1}{this function should only be called on streams which are} \\indented{1}{known to be finite.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} n:=filterUntil(i+->i>100,m) \\spad{X} numberOfComputedEntries \\spad{n} \\spad{X} complete \\spad{n} \\spad{X} numberOfComputedEntries \\spad{n}")) (|extend| (($ $ (|Integer|)) "\\spad{extend(st,n)} causes entries to be computed, if necessary, \\indented{1}{so that 'st' will have at least \\spad{'n'} explicit entries or so} \\indented{1}{that all entries of 'st' will be computed if 'st' is finite} \\indented{1}{with length \\spad{<=} \\spad{n.}} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} numberOfComputedEntries \\spad{m} \\spad{X} extend(m,20) \\spad{X} numberOfComputedEntries \\spad{m}")) (|numberOfComputedEntries| (((|NonNegativeInteger|) $) "\\spad{numberOfComputedEntries(st)} returns the number of explicitly \\indented{1}{computed entries of stream \\spad{st} which exist immediately prior to the} \\indented{1}{time this function is called.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} numberOfComputedEntries \\spad{m}")) (|rst| (($ $) "\\spad{rst(s)} returns a pointer to the next node of stream \\spad{s.} \\indented{1}{Cautrion: this function should only be called after a \\spad{empty?}} \\indented{1}{test has been made since there no error check.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} \\spad{rst} \\spad{m}")) (|frst| ((|#1| $) "\\spad{frst(s)} returns the first element of stream \\spad{s.} \\indented{1}{Caution: this function should only be called after a \\spad{empty?}} \\indented{1}{test has been made since there no error check.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} frst \\spad{m}")) (|lazyEvaluate| (($ $) "\\spad{lazyEvaluate(s)} causes one lazy evaluation of stream \\spad{s.} \\indented{1}{Caution: the first node must be a lazy evaluation mechanism} \\indented{1}{(satisfies \\spad{lazy?(s) = true}) as there is no error check.} \\indented{1}{Note that a call to this function may} \\indented{1}{or may not produce an explicit first entry}")) (|lazy?| (((|Boolean|) $) "\\spad{lazy?(s)} returns \\spad{true} if the first node of the stream \\spad{s} \\indented{1}{is a lazy evaluation mechanism which could produce an} \\indented{1}{additional entry to \\spad{s.}} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} lazy? \\spad{m}")) (|explicitlyEmpty?| (((|Boolean|) $) "\\spad{explicitlyEmpty?(s)} returns \\spad{true} if the stream is an \\indented{1}{(explicitly) empty stream.} \\indented{1}{Note that this is a null test which will not cause lazy evaluation.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} explicitlyEmpty? \\spad{m}")) (|explicitEntries?| (((|Boolean|) $) "\\spad{explicitEntries?(s)} returns \\spad{true} if the stream \\spad{s} has \\indented{1}{explicitly computed entries, and \\spad{false} otherwise.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} explicitEntries? \\spad{m}")) (|select| (($ (|Mapping| (|Boolean|) |#1|) $) "\\spad{select(f,st)} returns a stream consisting of those elements of stream \\indented{1}{st satisfying the predicate \\spad{f.}} \\indented{1}{Note that \\spad{select(f,st) = \\spad{[x} for \\spad{x} in \\spad{st} | f(x)]}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 0..] \\spad{X} select(x+->prime? x,m)")) (|remove| (($ (|Mapping| (|Boolean|) |#1|) $) "\\spad{remove(f,st)} returns a stream consisting of those elements of stream \\indented{1}{st which do not satisfy the predicate \\spad{f.}} \\indented{1}{Note that \\spad{remove(f,st) = \\spad{[x} for \\spad{x} in \\spad{st} | not f(x)]}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} f(i:PositiveInteger):Boolean \\spad{==} even? \\spad{i} \\spad{X} remove(f,m)"))) 
((|nil| . T)) 
NIL 
(|ThreeDimensionalMatrix| R) 
((|constructor| (NIL "This domain represents three dimensional matrices over a general object type")) (|matrixDimensions| (((|Vector| (|NonNegativeInteger|)) $) "\\spad{matrixDimensions(x)} returns the dimensions of a matrix")) (|matrixConcat3D| (($ (|Symbol|) $ $) "\\spad{matrixConcat3D(s,x,y)} concatenates two 3-D matrices along a specified axis")) (|coerce| (((|PrimitiveArray| (|PrimitiveArray| (|PrimitiveArray| |#1|))) $) "\\spad{coerce(x)} moves from the domain to the representation type") (($ (|PrimitiveArray| (|PrimitiveArray| (|PrimitiveArray| |#1|)))) "\\spad{coerce(p)} moves from the representation type (PrimitiveArray PrimitiveArray PrimitiveArray \\spad{R)} to the domain")) (|setelt!| ((|#1| $ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|) |#1|) "\\spad{setelt!(x,i,j,k,s)} (or x.i.j.k:=s) sets a specific element of the array to some value of type \\spad{R}")) (|elt| ((|#1| $ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{elt(x,i,j,k)} extract an element from the matrix \\spad{x}")) (|construct| (($ (|List| (|List| (|List| |#1|)))) "\\spad{construct(lll)} creates a 3-D matrix from a List List List \\spad{R} \\spad{lll}")) (|plus| (($ $ $) "\\spad{plus(x,y)} adds two matrices, term by term we note that they must be the same size")) (|identityMatrix| (($ (|NonNegativeInteger|)) "\\spad{identityMatrix(n)} create an identity matrix we note that this must be square")) (|zeroMatrix| (($ (|NonNegativeInteger|) (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{zeroMatrix(i,j,k)} create a matrix with all zero terms"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (QUOTE (|Ring|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|ModularAlgebraicGcdOperations| MPT MD) 
((|constructor| (NIL "This category specifies operations needed by ModularAlgebraicGcd package. Since we have multiple implementations we specify interface here and put implementations in separate packages. Most operations are done using special purpose abstract representation. Apropriate types are passesd as parametes: \\spad{MPT} is type of modular polynomials in one variable with coefficients in some algebraic extension. \\spad{MD} is type of modulus. Final results are converted to packed representation, with coefficients (from prime field) stored in one array and exponents (in main variable and in auxilary variables representing generators of algebrac extension) stored in parallel array.")) (|repack1| (((|Void|) |#1| (|U32Vector|) (|Integer|) |#2|) "\\spad{repack1(x, a, \\spad{d,} \\spad{m)}} stores coefficients of \\spad{x} in a. \\spad{d} is degree of \\spad{x.} Corresponding exponents are given by packExps.")) (|packExps| ((|SortedExponentVector| (|Integer|) (|Integer|) |#2|) "\\spad{packExps(d, \\spad{s,} \\spad{m)}} produces vector of exponents up to degree \\spad{d.} \\spad{s} is size (degree) of algebraic extension. Use together with repack1.")) (|degree| (((|Integer|) |#1|) "\\spad{degree(x)} gives degree of \\spad{x.}")) (|zero?| (((|Boolean|) |#1|) "\\spad{zero?(x)} checks if \\spad{x} is zero.")) (|MPtoMPT| ((|#1| (|Polynomial| (|Integer|)) (|Symbol|) (|List| (|Symbol|)) |#2|) "\\spad{MPtoMPT(p, \\spad{s,} \\spad{ls,} \\spad{m)}} coverts \\spad{p} to packed represntation.")) (|packModulus| (((|Union| |#2| "failed") (|List| (|Polynomial| (|Integer|))) (|List| (|Symbol|)) (|Integer|)) "\\spad{packModulus(lp, \\spad{ls,} \\spad{p)}} converts \\spad{lp,} \\spad{ls} and prime \\spad{p} which together describe algebraic extension to packed representation.")) (|canonicalIfCan| (((|Union| |#1| "failed") |#1| |#2|) "\\spad{canonicalIfCan(x, \\spad{m)}} tries to divide \\spad{x} by its leading coefficient modulo \\spad{m.}")) (|pseudoRem| ((|#1| |#1| |#1| |#2|) "\\spad{pseudoRem(x, \\spad{y,} \\spad{m)}} computes pseudoremainder of \\spad{x} by \\spad{y} modulo \\spad{m.}"))) 
NIL 
NIL 
(|Magma| |VarSet|) 
((|constructor| (NIL "This type is the basic representation of parenthesized words (binary trees over arbitrary symbols) useful in \\spadtype{LiePolynomial}.")) (|varList| (((|List| |#1|) $) "\\axiom{varList(x)} returns the list of distinct entries of \\axiom{x}.")) (|right| (($ $) "\\axiom{right(x)} returns right subtree of \\axiom{x} or error if retractable?(x) is true.")) (|retractable?| (((|Boolean|) $) "\\axiom{retractable?(x)} tests if \\axiom{x} is a tree with only one entry.")) (|rest| (($ $) "\\axiom{rest(x)} return \\axiom{x} without the first entry or error if retractable?(x) is true.")) (|mirror| (($ $) "\\axiom{mirror(x)} returns the reversed word of \\axiom{x}. That is \\axiom{x} itself if retractable?(x) is \\spad{true} and \\axiom{mirror(z) * mirror(y)} if \\axiom{x} is \\axiom{y*z}.")) (|lexico| (((|Boolean|) $ $) "\\axiom{lexico(x,y)} returns \\axiom{true} iff \\axiom{x} is smaller than \\axiom{y} w.r.t. the lexicographical ordering induced by \\axiom{VarSet}. N.B. This operation does not take into account the tree structure of its arguments. Thus this is not a total ordering.")) (|length| (((|PositiveInteger|) $) "\\axiom{length(x)} returns the number of entries in \\axiom{x}.")) (|left| (($ $) "\\axiom{left(x)} returns left subtree of \\axiom{x} or error if retractable?(x) is true.")) (|first| ((|#1| $) "\\axiom{first(x)} returns the first entry of the tree \\axiom{x}.")) (|coerce| (((|OrderedFreeMonoid| |#1|) $) "\\indented{1}{\\axiom{coerce(x)} returns the element of} \\axiomType{OrderedFreeMonoid}(VarSet) \\indented{1}{corresponding to \\axiom{x} by removing parentheses.}")) (* (($ $ $) "\\axiom{x*y} returns the tree \\axiom{[x,y]}."))) 
NIL 
NIL 
(|MatrixManipulation| R |Row| |Col| M) 
((|constructor| (NIL "Some functions for manipulating (dense) matrices. Supported are various kinds of slicing, splitting and stacking of matrices. The functions resemble operations often used in numerical linear algebra algorithms.")) (|blockSplit| (((|List| (|List| |#4|)) |#4| (|List| (|PositiveInteger|)) (|List| (|PositiveInteger|))) "\\spad{blockSplit} splits a matrix into multiple submatrices row and column wise, dividing a matrix into blocks.") (((|List| (|List| |#4|)) |#4| (|PositiveInteger|) (|List| (|PositiveInteger|))) "\\spad{blockSplit} splits a matrix into multiple submatrices row and column wise, dividing a matrix into blocks.") (((|List| (|List| |#4|)) |#4| (|List| (|PositiveInteger|)) (|PositiveInteger|)) "\\spad{blockSplit} splits a matrix into multiple submatrices row and column wise, dividing a matrix into blocks.") (((|List| (|List| |#4|)) |#4| (|PositiveInteger|) (|PositiveInteger|)) "\\spad{blockSplit} splits a matrix into multiple submatrices row and column wise, dividing a matrix into blocks.")) (|horizSplit| (((|List| |#4|) |#4| (|List| (|PositiveInteger|))) "\\spad{horizSplit} splits a matrix into multiple submatrices column wise.") (((|List| |#4|) |#4| (|PositiveInteger|)) "\\spad{horizSplit} splits a matrix into multiple submatrices column wise.")) (|vertSplit| (((|List| |#4|) |#4| (|List| (|PositiveInteger|))) "\\spad{vertSplit} splits a matrix into multiple submatrices row wise.") (((|List| |#4|) |#4| (|PositiveInteger|)) "\\spad{vertSplit} splits a matrix into multiple submatrices row wise.")) (|blockConcat| ((|#4| (|List| (|List| |#4|))) "\\spad{blockConcat} concatenates matrices row and column wise, building a block matrix. The order is row major as in \\spad{matrix}.")) (|vertConcat| ((|#4| (|List| |#4|)) "\\spad{vertConcat} concatenates matrices row wise.")) (|horizConcat| ((|#4| (|List| |#4|)) "\\spad{horizConcat} concatenates matrices column wise.")) (|bandMatrix| ((|#4| |#4| (|Segment| (|Integer|))) "\\spad{bandMatrix} returns multiple diagonals out of a matrix. The diagonals are put into a matrix of same shape as the original one. Positive integer arguments select upper off-diagonals, negative ones lower off-diagonals.") ((|#4| |#4| (|List| (|Integer|))) "\\spad{bandMatrix} returns multiple diagonals out of a matrix. The diagonals are put into a matrix of same shape as the original one. Positive integer arguments select upper off-diagonals, negative ones lower off-diagonals.")) (|diagonalMatrix| ((|#4| |#4|) "\\spad{diagonalMatrix} returns the main diagonal out of a matrix. The diagonal is put into a matrix of same shape as the original one.") ((|#4| |#4| (|Integer|)) "\\spad{diagonalMatrix} returns a diagonal out of a matrix. The diagonal is put into a matrix of same shape as the original one. Positive integer arguments select upper off-diagonals, negative ones lower off-diagonals.")) (|subMatrix| ((|#4| |#4| (|Segment| (|PositiveInteger|)) (|Segment| (|PositiveInteger|))) "\\spad{subMatrix} returns several elements out of a matrix. The elements are stacked into a submatrix.") ((|#4| |#4| (|List| (|PositiveInteger|)) (|List| (|PositiveInteger|))) "\\spad{subMatrix} returns several elements out of a matrix. The elements are stacked into a submatrix.")) (|columns| ((|#4| |#4| (|Segment| (|PositiveInteger|))) "\\spad{columns} returns several columns out of a matrix. The columns are stacked into a matrix.") ((|#4| |#4| (|List| (|PositiveInteger|))) "\\spad{columns} returns several columns out of a matrix. The columns are stacked into a matrix.")) (|aColumn| ((|#4| |#4| (|PositiveInteger|)) "\\spad{aColumn} returns a single column out of a matrix. The column is put into a one by \\spad{N} matrix.")) (|rows| ((|#4| |#4| (|Segment| (|PositiveInteger|))) "\\spad{rows} returns several rows out of a matrix. The rows are stacked into a matrix.") ((|#4| |#4| (|List| (|PositiveInteger|))) "\\spad{rows} returns several rows out of a matrix. The rows are stacked into a matrix.")) (|aRow| ((|#4| |#4| (|PositiveInteger|)) "\\spad{aRow} returns a single row out of a matrix. The row is put into a one by \\spad{N} matrix.")) (|element| ((|#4| |#4| (|PositiveInteger|) (|PositiveInteger|)) "\\spad{element} returns a single element out of a matrix. The element is put into a one by one matrix."))) 
NIL 
NIL 
(|MappingPackageInternalHacks1| A) 
((|constructor| (NIL "Various Currying operations.")) (|recur| ((|#1| (|Mapping| |#1| (|NonNegativeInteger|) |#1|) (|NonNegativeInteger|) |#1|) "\\spad{recur(n,g,x)} is \\spad{g(n,g(n-1,..g(1,x)..))}.")) (|iter| ((|#1| (|Mapping| |#1| |#1|) (|NonNegativeInteger|) |#1|) "\\spad{iter(f,n,x)} applies \\spad{f \\spad{n}} times to \\spad{x}."))) 
NIL 
NIL 
(|MappingPackageInternalHacks2| A C) 
((|constructor| (NIL "Various Currying operations.")) (|arg2| ((|#2| |#1| |#2|) "\\spad{arg2(a,c)} selects its second argument.")) (|arg1| ((|#1| |#1| |#2|) "\\spad{arg1(a,c)} selects its first argument."))) 
NIL 
NIL 
(|MappingPackageInternalHacks3| A B C) 
((|constructor| (NIL "Various Currying operations.")) (|comp| ((|#3| (|Mapping| |#3| |#2|) (|Mapping| |#2| |#1|) |#1|) "\\spad{comp(f,g,x)} is \\spad{f(g x)}."))) 
NIL 
NIL 
(|MappingPackage1| A) 
((|constructor| (NIL "Various Currying operations.")) (|recur| (((|Mapping| |#1| (|NonNegativeInteger|) |#1|) (|Mapping| |#1| (|NonNegativeInteger|) |#1|)) "\\spad{recur(g)} is the function \\spad{h} such that \\indented{1}{\\spad{h(n,x)= g(n,g(n-1,..g(1,x)..))}.}")) (** (((|Mapping| |#1| |#1|) (|Mapping| |#1| |#1|) (|NonNegativeInteger|)) "\\spad{f**n} is the function which is the n-fold application \\indented{1}{of \\spad{f}.}")) (|id| ((|#1| |#1|) "\\spad{id \\spad{x}} is \\spad{x}.")) (|fixedPoint| (((|List| |#1|) (|Mapping| (|List| |#1|) (|List| |#1|)) (|Integer|)) "\\spad{fixedPoint(f,n)} is the fixed point of function \\indented{1}{\\spad{f} which is assumed to transform a list of length} \\indented{1}{\\spad{n}.}") ((|#1| (|Mapping| |#1| |#1|)) "\\spad{fixedPoint \\spad{f}} is the fixed point of function \\spad{f}. \\indented{1}{that is, such that \\spad{fixedPoint \\spad{f} = f(fixedPoint f)}.}")) (|coerce| (((|Mapping| |#1|) |#1|) "\\spad{coerce A} changes its argument into a \\indented{1}{nullary function.}")) (|nullary| (((|Mapping| |#1|) |#1|) "\\spad{nullary A} changes its argument into a \\indented{1}{nullary function.}"))) 
NIL 
NIL 
(|MappingPackage2| A C) 
((|constructor| (NIL "Various Currying operations.")) (|diag| (((|Mapping| |#2| |#1|) (|Mapping| |#2| |#1| |#1|)) "\\spad{diag(f)} is the function \\spad{g} \\indented{1}{such that \\spad{g a = f(a,a)}.}")) (|constant| (((|Mapping| |#2| |#1|) (|Mapping| |#2|)) "\\spad{vu(f)} is the function \\spad{g} \\indented{1}{such that \\spad{g a= \\spad{f} ()}.}")) (|curry| (((|Mapping| |#2|) (|Mapping| |#2| |#1|) |#1|) "\\spad{cu(f,a)} is the function \\spad{g} \\indented{1}{such that \\spad{g \\spad{()=} \\spad{f} a}.}")) (|const| (((|Mapping| |#2| |#1|) |#2|) "\\spad{const \\spad{c}} is a function which produces \\spad{c} when \\indented{1}{applied to its argument.}"))) 
NIL 
NIL 
(|MappingPackage3| A B C) 
((|constructor| (NIL "Various Currying operations.")) (* (((|Mapping| |#3| |#1|) (|Mapping| |#3| |#2|) (|Mapping| |#2| |#1|)) "\\spad{f*g} is the function \\spad{h} \\indented{1}{such that \\spad{h \\spad{x=} \\spad{f(g} x)}.}")) (|twist| (((|Mapping| |#3| |#2| |#1|) (|Mapping| |#3| |#1| |#2|)) "\\spad{twist(f)} is the function \\spad{g} \\indented{1}{such that \\spad{g (a,b)= f(b,a)}.}")) (|constantLeft| (((|Mapping| |#3| |#1| |#2|) (|Mapping| |#3| |#2|)) "\\spad{constantLeft(f)} is the function \\spad{g} \\indented{1}{such that \\spad{g (a,b)= \\spad{f} b}.}")) (|constantRight| (((|Mapping| |#3| |#1| |#2|) (|Mapping| |#3| |#1|)) "\\spad{constantRight(f)} is the function \\spad{g} \\indented{1}{such that \\spad{g (a,b)= \\spad{f} a}.}")) (|curryLeft| (((|Mapping| |#3| |#2|) (|Mapping| |#3| |#1| |#2|) |#1|) "\\spad{curryLeft(f,a)} is the function \\spad{g} \\indented{1}{such that \\spad{g \\spad{b} = f(a,b)}.}")) (|curryRight| (((|Mapping| |#3| |#1|) (|Mapping| |#3| |#1| |#2|) |#2|) "\\spad{curryRight(f,b)} is the function \\spad{g} such that \\indented{1}{\\spad{g a = f(a,b)}.}"))) 
NIL 
NIL 
(|MappingPackage4| A B) 
((|constructor| (NIL "Functional Composition. Given functions \\spad{f} and \\spad{g,} returns the applicable closure")) (/ (((|Mapping| (|Expression| (|Integer|)) |#1|) (|Mapping| (|Expression| (|Integer|)) |#1|) (|Mapping| (|Expression| (|Integer|)) |#1|)) "\\indented{1}{\\spad(+) does functional addition} \\blankline \\spad{X} p:=(x:EXPR(INT)):EXPR(INT)+->3*x \\spad{X} \\spad{q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3} \\spad{X} (p/q)(4) \\spad{X} (p/q)(x)")) (* (((|Mapping| |#2| |#1|) (|Mapping| |#2| |#1|) (|Mapping| |#2| |#1|)) "\\indented{1}{\\spad(+) does functional addition} \\blankline \\spad{X} f:=(x:INT):INT \\spad{+->} 3*x \\spad{X} g:=(x:INT):INT \\spad{+->} 2*x+3 \\spad{X} (f*g)(4)")) (- (((|Mapping| |#2| |#1|) (|Mapping| |#2| |#1|) (|Mapping| |#2| |#1|)) "\\indented{1}{\\spad(+) does functional addition} \\blankline \\spad{X} f:=(x:INT):INT \\spad{+->} 3*x \\spad{X} g:=(x:INT):INT \\spad{+->} 2*x+3 \\spad{X} (f-g)(4)")) (+ (((|Mapping| |#2| |#1|) (|Mapping| |#2| |#1|) (|Mapping| |#2| |#1|)) "\\indented{1}{\\spad(+) does functional addition} \\blankline \\spad{X} f:=(x:INT):INT \\spad{+->} 3*x \\spad{X} g:=(x:INT):INT \\spad{+->} 2*x+3 \\spad{X} (f+g)(4)"))) 
NIL 
NIL 
(|MatrixCategoryFunctions2| R1 |Row1| |Col1| M1 R2 |Row2| |Col2| M2) 
((|constructor| (NIL "\\spadtype{MatrixCategoryFunctions2} provides functions between two matrix domains. The functions provided are \\spadfun{map} and \\spadfun{reduce}.")) (|reduce| ((|#5| (|Mapping| |#5| |#1| |#5|) |#4| |#5|) "\\spad{reduce(f,m,r)} returns a matrix \\spad{n} where \\spad{n[i,j] = f(m[i,j],r)} for all indices \\spad{i} and \\spad{j.}")) (|map| (((|Union| |#8| "failed") (|Mapping| (|Union| |#5| "failed") |#1|) |#4|) "\\spad{map(f,m)} applies the function \\spad{f} to the elements of the matrix \\spad{m.}") ((|#8| (|Mapping| |#5| |#1|) |#4|) "\\spad{map(f,m)} applies the function \\spad{f} to the elements of the matrix \\spad{m.}"))) 
NIL 
NIL 
(|MatrixCategory&| S R |Row| |Col|) 
((|constructor| (NIL "\\spadtype{MatrixCategory} is a general matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and colums returned as objects of type Col. A domain belonging to this category will be shallowly mutable. The index of the 'first' row may be obtained by calling the function \\spadfun{minRowIndex}. The index of the 'first' column may be obtained by calling the function \\spadfun{minColIndex}. The index of the first element of a Row is the same as the index of the first column in a matrix and vice versa.")) (|inverse| (((|Union| $ "failed") $) "\\spad{inverse(m)} returns the inverse of the matrix \\spad{m.} \\indented{1}{If the matrix is not invertible, \"failed\" is returned.} \\indented{1}{Error: if the matrix is not square.} \\blankline \\spad{X} inverse matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|pfaffian| ((|#2| $) "\\spad{pfaffian(m)} returns the Pfaffian of the matrix \\spad{m.} \\indented{1}{Error if the matrix is not antisymmetric} \\blankline \\spad{X} pfaffian [[0,1,0,0],[-1,0,0,0],[0,0,0,1],[0,0,-1,0]]")) (|minordet| ((|#2| $) "\\spad{minordet(m)} computes the determinant of the matrix \\spad{m} using \\indented{1}{minors. Error: if the matrix is not square.} \\blankline \\spad{X} minordet matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|determinant| ((|#2| $) "\\spad{determinant(m)} returns the determinant of the matrix \\spad{m.} \\indented{1}{Error: if the matrix is not square.} \\blankline \\spad{X} determinant matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|nullSpace| (((|List| |#4|) $) "\\spad{nullSpace(m)} returns a basis for the null space of \\indented{1}{the matrix \\spad{m.}} \\blankline \\spad{X} nullSpace matrix [[1,2,3],[4,5,6],[7,8,9]]")) (|nullity| (((|NonNegativeInteger|) $) "\\spad{nullity(m)} returns the nullity of the matrix \\spad{m.} This is \\indented{1}{the dimension of the null space of the matrix \\spad{m.}} \\blankline \\spad{X} nullity matrix [[1,2,3],[4,5,6],[7,8,9]]")) (|rank| (((|NonNegativeInteger|) $) "\\spad{rank(m)} returns the rank of the matrix \\spad{m.} \\blankline \\spad{X} rank matrix [[1,2,3],[4,5,6],[7,8,9]]")) (|columnSpace| (((|List| |#4|) $) "\\spad{columnSpace(m)} returns a sublist of columns of the matrix \\spad{m} \\indented{1}{forming a basis of its column space} \\blankline \\spad{X} columnSpace matrix [[1,2,3],[4,5,6],[7,8,9],[1,1,1]]")) (|rowEchelon| (($ $) "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m.} \\blankline \\spad{X} rowEchelon matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (/ (($ $ |#2|) "\\spad{m/r} divides the elements of \\spad{m} by \\spad{r.} Error: if \\spad{r = 0}. \\blankline \\spad{X} m:=matrix [[2**i for \\spad{i} in 2..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m/4}")) (|exquo| (((|Union| $ "failed") $ |#2|) "\\spad{exquo(m,r)} computes the exact quotient of the elements \\indented{1}{of \\spad{m} by \\spad{r,} returning \\axiom{\"failed\"} if this is not possible.} \\blankline \\spad{X} m:=matrix [[2**i for \\spad{i} in 2..4] for \\spad{j} in 1..5] \\spad{X} exquo(m,2)")) (** (($ $ (|Integer|)) "\\spad{m**n} computes an integral power of the matrix \\spad{m.} \\indented{1}{Error: if matrix is not square or if the matrix} \\indented{1}{is square but not invertible.} \\blankline \\spad{X} (matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]) \\spad{**} 2") (($ $ (|NonNegativeInteger|)) "\\spad{x \\spad{**} \\spad{n}} computes a non-negative integral power of the matrix \\spad{x.} \\indented{1}{Error: if the matrix is not square.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m**3}")) (* ((|#3| |#3| $) "\\spad{r * \\spad{x}} is the product of the row vector \\spad{r} and the matrix \\spad{x.} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} r:=transpose([1,2,3,4,5])@Matrix(INT) \\spad{X} \\spad{r*m}") ((|#4| $ |#4|) "\\spad{x * \\spad{c}} is the product of the matrix \\spad{x} and the column vector \\spad{c.} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} c:=coerce([1,2,3,4,5])@Matrix(INT) \\spad{X} \\spad{m*c}") (($ (|Integer|) $) "\\spad{n * \\spad{x}} is an integer multiple. \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} 3*m") (($ $ |#2|) "\\spad{x * \\spad{r}} is the right scalar multiple of the scalar \\spad{r} and the \\indented{1}{matrix \\spad{x.}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m*1/3}") (($ |#2| $) "\\spad{r*x} is the left scalar multiple of the scalar \\spad{r} and the \\indented{1}{matrix \\spad{x.}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} 1/3*m") (($ $ $) "\\spad{x * \\spad{y}} is the product of the matrices \\spad{x} and \\spad{y.} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m*m}")) (- (($ $) "\\spad{-x} returns the negative of the matrix \\spad{x.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{-m}") (($ $ $) "\\spad{x - \\spad{y}} is the difference of the matrices \\spad{x} and \\spad{y.} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m-m}")) (+ (($ $ $) "\\spad{x + \\spad{y}} is the sum of the matrices \\spad{x} and \\spad{y.} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m+m}")) (|setsubMatrix!| (($ $ (|Integer|) (|Integer|) $) "\\spad{setsubMatrix!(x,i1,j1,y)} destructively alters the \\indented{1}{matrix \\spad{x.} Here \\spad{x(i,j)} is set to \\spad{y(i-i1+1,j-j1+1)} for} \\indented{1}{\\spad{i = i1,...,i1-1+nrows \\spad{y}} and \\spad{j = j1,...,j1-1+ncols y}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} setsubMatrix!(m,2,2,matrix [[3,3],[3,3]])")) (|subMatrix| (($ $ (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{subMatrix(x,i1,i2,j1,j2)} extracts the submatrix \\indented{1}{\\spad{[x(i,j)]} where the index \\spad{i} ranges from \\spad{i1} to \\spad{i2}} \\indented{1}{and the index \\spad{j} ranges from \\spad{j1} to \\spad{j2}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} subMatrix(m,1,3,2,4)")) (|swapColumns!| (($ $ (|Integer|) (|Integer|)) "\\spad{swapColumns!(m,i,j)} interchanges the \\spad{i}th and \\spad{j}th \\indented{1}{columns of \\spad{m.} This destructively alters the matrix.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} swapColumns!(m,2,4)")) (|swapRows!| (($ $ (|Integer|) (|Integer|)) "\\spad{swapRows!(m,i,j)} interchanges the \\spad{i}th and \\spad{j}th \\indented{1}{rows of \\spad{m.} This destructively alters the matrix.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} swapRows!(m,2,4)")) (|setelt| (($ $ (|List| (|Integer|)) (|List| (|Integer|)) $) "\\spad{setelt(x,rowList,colList,y)} destructively alters the matrix \\spad{x.} \\indented{1}{If \\spad{y} is \\spad{m}-by-\\spad{n}, \\spad{rowList = [i<1>,i<2>,...,i<m>]}} \\indented{1}{and \\spad{colList = [j<1>,j<2>,...,j<n>]}, then \\spad{x(i<k>,j<l>)}} \\indented{1}{is set to \\spad{y(k,l)} for \\spad{k = 1,...,m} and \\spad{l = 1,...,n}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} setelt(m,3,3,10)")) (|elt| (($ $ (|List| (|Integer|)) (|List| (|Integer|))) "\\spad{elt(x,rowList,colList)} returns an m-by-n matrix consisting \\indented{1}{of elements of \\spad{x,} where \\spad{m = \\# rowList} and \\spad{n = \\# colList}} \\indented{1}{If \\spad{rowList = [i<1>,i<2>,...,i<m>]} and \\spad{colList \\spad{=}} \\indented{1}{[j<1>,j<2>,...,j<n>]}, then the \\spad{(k,l)}th entry of} \\indented{1}{\\spad{elt(x,rowList,colList)} is \\spad{x(i<k>,j<l>)}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} elt(m,3,3)")) (|listOfLists| (((|List| (|List| |#2|)) $) "\\spad{listOfLists(m)} returns the rows of the matrix \\spad{m} as a list \\indented{1}{of lists.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} listOfLists \\spad{m}")) (|vertConcat| (($ $ $) "\\spad{vertConcat(x,y)} vertically concatenates two matrices with an \\indented{1}{equal number of columns. The entries of \\spad{y} appear below} \\indented{1}{of the entries of x.\\space{2}Error: if the matrices} \\indented{1}{do not have the same number of columns.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} vertConcat(m,m)")) (|horizConcat| (($ $ $) "\\spad{horizConcat(x,y)} horizontally concatenates two matrices with \\indented{1}{an equal number of rows. The entries of \\spad{y} appear to the right} \\indented{1}{of the entries of x.\\space{2}Error: if the matrices} \\indented{1}{do not have the same number of rows.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} horizConcat(m,m)")) (|squareTop| (($ $) "\\spad{squareTop(m)} returns an n-by-n matrix consisting of the first \\indented{1}{n rows of the m-by-n matrix \\spad{m.} Error: if} \\indented{1}{\\spad{m < n}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..2] for \\spad{j} in 1..5] \\spad{X} squareTop \\spad{m}")) (|transpose| (($ $) "\\spad{transpose(m)} returns the transpose of the matrix \\spad{m.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} transpose \\spad{m}") (($ |#3|) "\\spad{transpose(r)} converts the row \\spad{r} to a row matrix. \\blankline \\spad{X} transpose([1,2,3])@Matrix(INT)")) (|coerce| (($ |#4|) "\\spad{coerce(col)} converts the column \\spad{col} to a column matrix. \\blankline \\spad{X} coerce([1,2,3])@Matrix(INT)")) (|diagonalMatrix| (($ (|List| $)) "\\spad{diagonalMatrix([m1,...,mk])} creates a block diagonal matrix \\indented{1}{M with block matrices m1,...,mk down the diagonal,} \\indented{1}{with 0 block matrices elsewhere.} \\indented{1}{More precisly: if \\spad{ri \\spad{:=} nrows mi}, \\spad{ci \\spad{:=} ncols mi},} \\indented{1}{then \\spad{m} is an (r1+..+rk) by (c1+..+ck) - matrix\\space{2}with entries} \\indented{1}{\\spad{m.i.j = ml.(i-r1-..-r(l-1)).(j-n1-..-n(l-1))}, if} \\indented{1}{\\spad{(r1+..+r(l-1)) < \\spad{i} \\spad{<=} r1+..+rl} and} \\indented{1}{\\spad{(c1+..+c(l-1)) < \\spad{i} \\spad{<=} c1+..+cl},} \\indented{1}{\\spad{m.i.j} = 0\\space{2}otherwise.} \\blankline \\spad{X} diagonalMatrix [matrix [[1,2],[3,4]], matrix [[4,5],[6,7]]]") (($ (|List| |#2|)) "\\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements \\indented{1}{of \\spad{l} on the diagonal.} \\blankline \\spad{X} diagonalMatrix [1,2,3]")) (|scalarMatrix| (($ (|NonNegativeInteger|) |#2|) "\\spad{scalarMatrix(n,r)} returns an n-by-n matrix with \\spad{r's} on the \\indented{1}{diagonal and zeroes elsewhere.} \\blankline \\spad{X} z:Matrix(INT):=scalarMatrix(3,5)")) (|matrix| (($ (|NonNegativeInteger|) (|NonNegativeInteger|) (|Mapping| |#2| (|Integer|) (|Integer|))) "\\spad{matrix(n,m,f)} constructs an \\spad{n * \\spad{m}} matrix with \\indented{1}{the \\spad{(i,j)} entry equal to \\spad{f(i,j)}} \\blankline \\spad{X} f(i:INT,j:INT):INT \\spad{==} i+j \\spad{X} matrix(3,4,f)") (($ (|List| (|List| |#2|))) "\\spad{matrix(l)} converts the list of lists \\spad{l} to a matrix, where the \\indented{1}{list of lists is viewed as a list of the rows of the matrix.} \\blankline \\spad{X} matrix [[1,2,3],[4,5,6],[7,8,9],[1,1,1]]")) (|zero| (($ (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{zero(m,n)} returns an m-by-n zero matrix. \\blankline \\spad{X} z:Matrix(INT):=zero(3,3)")) (|antisymmetric?| (((|Boolean|) $) "\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and \\indented{1}{antisymmetric (that is, \\spad{m[i,j] = -m[j,i]} for all \\spad{i} and \\spad{j)}} \\indented{1}{and \\spad{false} otherwise.} \\blankline \\spad{X} antisymmetric? matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|symmetric?| (((|Boolean|) $) "\\spad{symmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and \\indented{1}{symmetric (that is, \\spad{m[i,j] = m[j,i]} for all \\spad{i} and \\spad{j)} and false} \\indented{1}{otherwise.} \\blankline \\spad{X} symmetric? matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|diagonal?| (((|Boolean|) $) "\\spad{diagonal?(m)} returns \\spad{true} if the matrix \\spad{m} is square and \\indented{1}{diagonal (that is, all entries of \\spad{m} not on the diagonal are zero) and} \\indented{1}{false otherwise.} \\blankline \\spad{X} diagonal? matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|square?| (((|Boolean|) $) "\\spad{square?(m)} returns \\spad{true} if \\spad{m} is a square matrix \\indented{1}{(if \\spad{m} has the same number of rows as columns) and \\spad{false} otherwise.} \\blankline \\spad{X} square matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|finiteAggregate| ((|attribute|) "matrices are finite")) (|shallowlyMutable| ((|attribute|) "One may destructively alter matrices"))) 
NIL 
((|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasAttribute| |#2| (QUOTE (|commutative| "*"))) (|HasCategory| |#2| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) 
(|MatrixCategory| R |Row| |Col|) 
((|constructor| (NIL "\\spadtype{MatrixCategory} is a general matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and colums returned as objects of type Col. A domain belonging to this category will be shallowly mutable. The index of the 'first' row may be obtained by calling the function \\spadfun{minRowIndex}. The index of the 'first' column may be obtained by calling the function \\spadfun{minColIndex}. The index of the first element of a Row is the same as the index of the first column in a matrix and vice versa.")) (|inverse| (((|Union| $ "failed") $) "\\spad{inverse(m)} returns the inverse of the matrix \\spad{m.} \\indented{1}{If the matrix is not invertible, \"failed\" is returned.} \\indented{1}{Error: if the matrix is not square.} \\blankline \\spad{X} inverse matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|pfaffian| ((|#1| $) "\\spad{pfaffian(m)} returns the Pfaffian of the matrix \\spad{m.} \\indented{1}{Error if the matrix is not antisymmetric} \\blankline \\spad{X} pfaffian [[0,1,0,0],[-1,0,0,0],[0,0,0,1],[0,0,-1,0]]")) (|minordet| ((|#1| $) "\\spad{minordet(m)} computes the determinant of the matrix \\spad{m} using \\indented{1}{minors. Error: if the matrix is not square.} \\blankline \\spad{X} minordet matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|determinant| ((|#1| $) "\\spad{determinant(m)} returns the determinant of the matrix \\spad{m.} \\indented{1}{Error: if the matrix is not square.} \\blankline \\spad{X} determinant matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|nullSpace| (((|List| |#3|) $) "\\spad{nullSpace(m)} returns a basis for the null space of \\indented{1}{the matrix \\spad{m.}} \\blankline \\spad{X} nullSpace matrix [[1,2,3],[4,5,6],[7,8,9]]")) (|nullity| (((|NonNegativeInteger|) $) "\\spad{nullity(m)} returns the nullity of the matrix \\spad{m.} This is \\indented{1}{the dimension of the null space of the matrix \\spad{m.}} \\blankline \\spad{X} nullity matrix [[1,2,3],[4,5,6],[7,8,9]]")) (|rank| (((|NonNegativeInteger|) $) "\\spad{rank(m)} returns the rank of the matrix \\spad{m.} \\blankline \\spad{X} rank matrix [[1,2,3],[4,5,6],[7,8,9]]")) (|columnSpace| (((|List| |#3|) $) "\\spad{columnSpace(m)} returns a sublist of columns of the matrix \\spad{m} \\indented{1}{forming a basis of its column space} \\blankline \\spad{X} columnSpace matrix [[1,2,3],[4,5,6],[7,8,9],[1,1,1]]")) (|rowEchelon| (($ $) "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m.} \\blankline \\spad{X} rowEchelon matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (/ (($ $ |#1|) "\\spad{m/r} divides the elements of \\spad{m} by \\spad{r.} Error: if \\spad{r = 0}. \\blankline \\spad{X} m:=matrix [[2**i for \\spad{i} in 2..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m/4}")) (|exquo| (((|Union| $ "failed") $ |#1|) "\\spad{exquo(m,r)} computes the exact quotient of the elements \\indented{1}{of \\spad{m} by \\spad{r,} returning \\axiom{\"failed\"} if this is not possible.} \\blankline \\spad{X} m:=matrix [[2**i for \\spad{i} in 2..4] for \\spad{j} in 1..5] \\spad{X} exquo(m,2)")) (** (($ $ (|Integer|)) "\\spad{m**n} computes an integral power of the matrix \\spad{m.} \\indented{1}{Error: if matrix is not square or if the matrix} \\indented{1}{is square but not invertible.} \\blankline \\spad{X} (matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]) \\spad{**} 2") (($ $ (|NonNegativeInteger|)) "\\spad{x \\spad{**} \\spad{n}} computes a non-negative integral power of the matrix \\spad{x.} \\indented{1}{Error: if the matrix is not square.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m**3}")) (* ((|#2| |#2| $) "\\spad{r * \\spad{x}} is the product of the row vector \\spad{r} and the matrix \\spad{x.} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} r:=transpose([1,2,3,4,5])@Matrix(INT) \\spad{X} \\spad{r*m}") ((|#3| $ |#3|) "\\spad{x * \\spad{c}} is the product of the matrix \\spad{x} and the column vector \\spad{c.} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} c:=coerce([1,2,3,4,5])@Matrix(INT) \\spad{X} \\spad{m*c}") (($ (|Integer|) $) "\\spad{n * \\spad{x}} is an integer multiple. \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} 3*m") (($ $ |#1|) "\\spad{x * \\spad{r}} is the right scalar multiple of the scalar \\spad{r} and the \\indented{1}{matrix \\spad{x.}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m*1/3}") (($ |#1| $) "\\spad{r*x} is the left scalar multiple of the scalar \\spad{r} and the \\indented{1}{matrix \\spad{x.}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} 1/3*m") (($ $ $) "\\spad{x * \\spad{y}} is the product of the matrices \\spad{x} and \\spad{y.} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m*m}")) (- (($ $) "\\spad{-x} returns the negative of the matrix \\spad{x.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{-m}") (($ $ $) "\\spad{x - \\spad{y}} is the difference of the matrices \\spad{x} and \\spad{y.} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m-m}")) (+ (($ $ $) "\\spad{x + \\spad{y}} is the sum of the matrices \\spad{x} and \\spad{y.} \\indented{1}{Error: if the dimensions are incompatible.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} \\spad{m+m}")) (|setsubMatrix!| (($ $ (|Integer|) (|Integer|) $) "\\spad{setsubMatrix!(x,i1,j1,y)} destructively alters the \\indented{1}{matrix \\spad{x.} Here \\spad{x(i,j)} is set to \\spad{y(i-i1+1,j-j1+1)} for} \\indented{1}{\\spad{i = i1,...,i1-1+nrows \\spad{y}} and \\spad{j = j1,...,j1-1+ncols y}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} setsubMatrix!(m,2,2,matrix [[3,3],[3,3]])")) (|subMatrix| (($ $ (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{subMatrix(x,i1,i2,j1,j2)} extracts the submatrix \\indented{1}{\\spad{[x(i,j)]} where the index \\spad{i} ranges from \\spad{i1} to \\spad{i2}} \\indented{1}{and the index \\spad{j} ranges from \\spad{j1} to \\spad{j2}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} subMatrix(m,1,3,2,4)")) (|swapColumns!| (($ $ (|Integer|) (|Integer|)) "\\spad{swapColumns!(m,i,j)} interchanges the \\spad{i}th and \\spad{j}th \\indented{1}{columns of \\spad{m.} This destructively alters the matrix.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} swapColumns!(m,2,4)")) (|swapRows!| (($ $ (|Integer|) (|Integer|)) "\\spad{swapRows!(m,i,j)} interchanges the \\spad{i}th and \\spad{j}th \\indented{1}{rows of \\spad{m.} This destructively alters the matrix.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} swapRows!(m,2,4)")) (|setelt| (($ $ (|List| (|Integer|)) (|List| (|Integer|)) $) "\\spad{setelt(x,rowList,colList,y)} destructively alters the matrix \\spad{x.} \\indented{1}{If \\spad{y} is \\spad{m}-by-\\spad{n}, \\spad{rowList = [i<1>,i<2>,...,i<m>]}} \\indented{1}{and \\spad{colList = [j<1>,j<2>,...,j<n>]}, then \\spad{x(i<k>,j<l>)}} \\indented{1}{is set to \\spad{y(k,l)} for \\spad{k = 1,...,m} and \\spad{l = 1,...,n}} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} setelt(m,3,3,10)")) (|elt| (($ $ (|List| (|Integer|)) (|List| (|Integer|))) "\\spad{elt(x,rowList,colList)} returns an m-by-n matrix consisting \\indented{1}{of elements of \\spad{x,} where \\spad{m = \\# rowList} and \\spad{n = \\# colList}} \\indented{1}{If \\spad{rowList = [i<1>,i<2>,...,i<m>]} and \\spad{colList \\spad{=}} \\indented{1}{[j<1>,j<2>,...,j<n>]}, then the \\spad{(k,l)}th entry of} \\indented{1}{\\spad{elt(x,rowList,colList)} is \\spad{x(i<k>,j<l>)}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} elt(m,3,3)")) (|listOfLists| (((|List| (|List| |#1|)) $) "\\spad{listOfLists(m)} returns the rows of the matrix \\spad{m} as a list \\indented{1}{of lists.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} listOfLists \\spad{m}")) (|vertConcat| (($ $ $) "\\spad{vertConcat(x,y)} vertically concatenates two matrices with an \\indented{1}{equal number of columns. The entries of \\spad{y} appear below} \\indented{1}{of the entries of x.\\space{2}Error: if the matrices} \\indented{1}{do not have the same number of columns.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} vertConcat(m,m)")) (|horizConcat| (($ $ $) "\\spad{horizConcat(x,y)} horizontally concatenates two matrices with \\indented{1}{an equal number of rows. The entries of \\spad{y} appear to the right} \\indented{1}{of the entries of x.\\space{2}Error: if the matrices} \\indented{1}{do not have the same number of rows.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} horizConcat(m,m)")) (|squareTop| (($ $) "\\spad{squareTop(m)} returns an n-by-n matrix consisting of the first \\indented{1}{n rows of the m-by-n matrix \\spad{m.} Error: if} \\indented{1}{\\spad{m < n}.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..2] for \\spad{j} in 1..5] \\spad{X} squareTop \\spad{m}")) (|transpose| (($ $) "\\spad{transpose(m)} returns the transpose of the matrix \\spad{m.} \\blankline \\spad{X} m:=matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5] \\spad{X} transpose \\spad{m}") (($ |#2|) "\\spad{transpose(r)} converts the row \\spad{r} to a row matrix. \\blankline \\spad{X} transpose([1,2,3])@Matrix(INT)")) (|coerce| (($ |#3|) "\\spad{coerce(col)} converts the column \\spad{col} to a column matrix. \\blankline \\spad{X} coerce([1,2,3])@Matrix(INT)")) (|diagonalMatrix| (($ (|List| $)) "\\spad{diagonalMatrix([m1,...,mk])} creates a block diagonal matrix \\indented{1}{M with block matrices m1,...,mk down the diagonal,} \\indented{1}{with 0 block matrices elsewhere.} \\indented{1}{More precisly: if \\spad{ri \\spad{:=} nrows mi}, \\spad{ci \\spad{:=} ncols mi},} \\indented{1}{then \\spad{m} is an (r1+..+rk) by (c1+..+ck) - matrix\\space{2}with entries} \\indented{1}{\\spad{m.i.j = ml.(i-r1-..-r(l-1)).(j-n1-..-n(l-1))}, if} \\indented{1}{\\spad{(r1+..+r(l-1)) < \\spad{i} \\spad{<=} r1+..+rl} and} \\indented{1}{\\spad{(c1+..+c(l-1)) < \\spad{i} \\spad{<=} c1+..+cl},} \\indented{1}{\\spad{m.i.j} = 0\\space{2}otherwise.} \\blankline \\spad{X} diagonalMatrix [matrix [[1,2],[3,4]], matrix [[4,5],[6,7]]]") (($ (|List| |#1|)) "\\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements \\indented{1}{of \\spad{l} on the diagonal.} \\blankline \\spad{X} diagonalMatrix [1,2,3]")) (|scalarMatrix| (($ (|NonNegativeInteger|) |#1|) "\\spad{scalarMatrix(n,r)} returns an n-by-n matrix with \\spad{r's} on the \\indented{1}{diagonal and zeroes elsewhere.} \\blankline \\spad{X} z:Matrix(INT):=scalarMatrix(3,5)")) (|matrix| (($ (|NonNegativeInteger|) (|NonNegativeInteger|) (|Mapping| |#1| (|Integer|) (|Integer|))) "\\spad{matrix(n,m,f)} constructs an \\spad{n * \\spad{m}} matrix with \\indented{1}{the \\spad{(i,j)} entry equal to \\spad{f(i,j)}} \\blankline \\spad{X} f(i:INT,j:INT):INT \\spad{==} i+j \\spad{X} matrix(3,4,f)") (($ (|List| (|List| |#1|))) "\\spad{matrix(l)} converts the list of lists \\spad{l} to a matrix, where the \\indented{1}{list of lists is viewed as a list of the rows of the matrix.} \\blankline \\spad{X} matrix [[1,2,3],[4,5,6],[7,8,9],[1,1,1]]")) (|zero| (($ (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{zero(m,n)} returns an m-by-n zero matrix. \\blankline \\spad{X} z:Matrix(INT):=zero(3,3)")) (|antisymmetric?| (((|Boolean|) $) "\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and \\indented{1}{antisymmetric (that is, \\spad{m[i,j] = -m[j,i]} for all \\spad{i} and \\spad{j)}} \\indented{1}{and \\spad{false} otherwise.} \\blankline \\spad{X} antisymmetric? matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|symmetric?| (((|Boolean|) $) "\\spad{symmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and \\indented{1}{symmetric (that is, \\spad{m[i,j] = m[j,i]} for all \\spad{i} and \\spad{j)} and false} \\indented{1}{otherwise.} \\blankline \\spad{X} symmetric? matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|diagonal?| (((|Boolean|) $) "\\spad{diagonal?(m)} returns \\spad{true} if the matrix \\spad{m} is square and \\indented{1}{diagonal (that is, all entries of \\spad{m} not on the diagonal are zero) and} \\indented{1}{false otherwise.} \\blankline \\spad{X} diagonal? matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|square?| (((|Boolean|) $) "\\spad{square?(m)} returns \\spad{true} if \\spad{m} is a square matrix \\indented{1}{(if \\spad{m} has the same number of rows as columns) and \\spad{false} otherwise.} \\blankline \\spad{X} square matrix [[j**i for \\spad{i} in 0..4] for \\spad{j} in 1..5]")) (|finiteAggregate| ((|attribute|) "matrices are finite")) (|shallowlyMutable| ((|attribute|) "One may destructively alter matrices"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|MatrixLinearAlgebraFunctions| R |Row| |Col| M) 
((|constructor| (NIL "\\spadtype{MatrixLinearAlgebraFunctions} provides functions to compute inverses and canonical forms.")) (|inverse| (((|Union| |#4| "failed") |#4|) "\\spad{inverse(m)} returns the inverse of the matrix. If the matrix is not invertible, \"failed\" is returned. Error: if the matrix is not square.")) (|normalizedDivide| (((|Record| (|:| |quotient| |#1|) (|:| |remainder| |#1|)) |#1| |#1|) "\\spad{normalizedDivide(n,d)} returns a normalized quotient and remainder such that consistently unique representatives for the residue class are chosen, \\spadignore{e.g.} positive remainders")) (|rowEchelon| ((|#4| |#4|) "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m.}")) (|adjoint| (((|Record| (|:| |adjMat| |#4|) (|:| |detMat| |#1|)) |#4|) "\\spad{adjoint(m)} returns the ajoint matrix of \\spad{m} (\\spadignore{i.e.} the matrix \\spad{n} such that \\spad{m*n} = determinant(m)*id) and the detrminant of \\spad{m.}")) (|invertIfCan| (((|Union| |#4| "failed") |#4|) "\\spad{invertIfCan(m)} returns the inverse of \\spad{m} over \\spad{R}")) (|fractionFreeGauss!| ((|#4| |#4|) "\\spad{fractionFreeGauss(m)} performs the fraction free gaussian elimination on the matrix \\spad{m.}")) (|nullSpace| (((|List| |#3|) |#4|) "\\spad{nullSpace(m)} returns a basis for the null space of the matrix \\spad{m.}")) (|nullity| (((|NonNegativeInteger|) |#4|) "\\spad{nullity(m)} returns the mullity of the matrix \\spad{m.} This is the dimension of the null space of the matrix \\spad{m.}")) (|rank| (((|NonNegativeInteger|) |#4|) "\\spad{rank(m)} returns the rank of the matrix \\spad{m.}")) (|elColumn2!| ((|#4| |#4| |#1| (|Integer|) (|Integer|)) "\\spad{elColumn2!(m,a,i,j)} adds to column \\spad{i} a*column(m,j) : elementary operation of second kind. \\spad{(i} ^=j)")) (|elRow2!| ((|#4| |#4| |#1| (|Integer|) (|Integer|)) "\\spad{elRow2!(m,a,i,j)} adds to row \\spad{i} a*row(m,j) : elementary operation of second kind. \\spad{(i} ^=j)")) (|elRow1!| ((|#4| |#4| (|Integer|) (|Integer|)) "\\spad{elRow1!(m,i,j)} swaps rows \\spad{i} and \\spad{j} of matrix \\spad{m} : elementary operation of first kind")) (|minordet| ((|#1| |#4|) "\\spad{minordet(m)} computes the determinant of the matrix \\spad{m} using minors. Error: if the matrix is not square.")) (|determinant| ((|#1| |#4|) "\\spad{determinant(m)} returns the determinant of the matrix \\spad{m.} an error message is returned if the matrix is not square."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) 
(|Matrix| R) 
((|constructor| (NIL "\\spadtype{Matrix} is a matrix domain where 1-based indexing is used for both rows and columns.")) (|inverse| (((|Union| $ "failed") $) "\\spad{inverse(m)} returns the inverse of the matrix \\spad{m.} If the matrix is not invertible, \"failed\" is returned. Error: if the matrix is not square.")) (|diagonalMatrix| (($ (|Vector| |#1|)) "\\spad{diagonalMatrix(v)} returns a diagonal matrix where the elements of \\spad{v} appear on the diagonal."))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasAttribute| |#1| (QUOTE (|commutative| "*"))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|StorageEfficientMatrixOperations| R) 
((|constructor| (NIL "This package provides standard arithmetic operations on matrices. The functions in this package store the results of computations in existing matrices, rather than creating new matrices. This package works only for matrices of type Matrix and uses the internal representation of this type.")) (** (((|Matrix| |#1|) (|Matrix| |#1|) (|NonNegativeInteger|)) "\\spad{x \\spad{**} \\spad{n}} computes the \\spad{n}-th power of a square matrix. The power \\spad{n} is assumed greater than 1.")) (|power!| (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) (|NonNegativeInteger|)) "\\spad{power!(a,b,c,m,n)} computes \\spad{m} \\spad{**} \\spad{n} and stores the result in \\spad{a}. The matrices \\spad{b} and \\spad{c} are used to store intermediate results. Error: if \\spad{a}, \\spad{b,} \\spad{c,} and \\spad{m} are not square and of the same dimensions.")) (|times!| (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|)) "\\spad{times!(c,a,b)} computes the matrix product \\spad{a * \\spad{b}} and stores the result in the matrix \\spad{c.} Error: if \\spad{a}, \\spad{b,} and \\spad{c} do not have compatible dimensions.")) (|rightScalarTimes!| (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) |#1|) "\\spad{rightScalarTimes!(c,a,r)} computes the scalar product \\spad{a * \\spad{r}} and stores the result in the matrix \\spad{c.} Error: if \\spad{a} and \\spad{c} do not have the same dimensions.")) (|leftScalarTimes!| (((|Matrix| |#1|) (|Matrix| |#1|) |#1| (|Matrix| |#1|)) "\\spad{leftScalarTimes!(c,r,a)} computes the scalar product \\spad{r * a} and stores the result in the matrix \\spad{c.} Error: if \\spad{a} and \\spad{c} do not have the same dimensions.")) (|minus!| (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|)) "\\spad{!minus!(c,a,b)} computes the matrix difference \\spad{a - \\spad{b}} and stores the result in the matrix \\spad{c.} Error: if \\spad{a}, \\spad{b,} and \\spad{c} do not have the same dimensions.") (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|)) "\\spad{minus!(c,a)} computes \\spad{-a} and stores the result in the matrix \\spad{c.} Error: if a and \\spad{c} do not have the same dimensions.")) (|plus!| (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|)) "\\spad{plus!(c,a,b)} computes the matrix sum \\spad{a + \\spad{b}} and stores the result in the matrix \\spad{c.} Error: if \\spad{a}, \\spad{b,} and \\spad{c} do not have the same dimensions.")) (|copy!| (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|)) "\\spad{copy!(c,a)} copies the matrix \\spad{a} into the matrix \\spad{c.} Error: if \\spad{a} and \\spad{c} do not have the same dimensions."))) 
NIL 
NIL 
(|MultiVariableCalculusFunctions| S F FLAF FLAS) 
((|constructor| (NIL "\\spadtype{MultiVariableCalculusFunctions} Package provides several functions for multivariable calculus. These include gradient, hessian and jacobian, divergence and laplacian. Various forms for banded and sparse storage of matrices are included.")) (|bandedJacobian| (((|Matrix| |#2|) |#3| |#4| (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{bandedJacobian(vf,xlist,kl,ku)} computes the jacobian, the matrix of first partial derivatives, of the vector field \\spad{vf,} \\spad{vf} a vector function of the variables listed in xlist, \\spad{kl} is the number of nonzero subdiagonals, \\spad{ku} is the number of nonzero superdiagonals, \\spad{kl+ku+1} being actual bandwidth. Stores the nonzero band in a matrix, dimensions \\spad{kl+ku+1} by \\#xlist. The upper triangle is in the top \\spad{ku} rows, the diagonal is in row ku+1, the lower triangle in the last \\spad{kl} rows. Entries in a column in the band store correspond to entries in same column of full store. (The notation conforms to \\spad{LAPACK/NAG-F07} conventions.)")) (|jacobian| (((|Matrix| |#2|) |#3| |#4|) "\\spad{jacobian(vf,xlist)} computes the jacobian, the matrix of first partial derivatives, of the vector field \\spad{vf,} \\spad{vf} a vector function of the variables listed in xlist.")) (|bandedHessian| (((|Matrix| |#2|) |#2| |#4| (|NonNegativeInteger|)) "\\spad{bandedHessian(v,xlist,k)} computes the hessian, the matrix of second partial derivatives, of the scalar field \\spad{v,} \\spad{v} a function of the variables listed in xlist, \\spad{k} is the semi-bandwidth, the number of nonzero subdiagonals, 2*k+1 being actual bandwidth. Stores the nonzero band in lower triangle in a matrix, dimensions \\spad{k+1} by \\#xlist, whose rows are the vectors formed by diagonal, subdiagonal, etc. of the real, full-matrix, hessian. (The notation conforms to \\spad{LAPACK/NAG-F07} conventions.)")) (|hessian| (((|Matrix| |#2|) |#2| |#4|) "\\spad{hessian(v,xlist)} computes the hessian, the matrix of second partial derivatives, of the scalar field \\spad{v,} \\spad{v} a function of the variables listed in xlist.")) (|laplacian| ((|#2| |#2| |#4|) "\\spad{laplacian(v,xlist)} computes the laplacian of the scalar field \\spad{v,} \\spad{v} a function of the variables listed in xlist.")) (|divergence| ((|#2| |#3| |#4|) "\\spad{divergence(vf,xlist)} computes the divergence of the vector field \\spad{vf,} \\spad{vf} a vector function of the variables listed in xlist.")) (|gradient| (((|Vector| |#2|) |#2| |#4|) "\\spad{gradient(v,xlist)} computes the gradient, the vector of first partial derivatives, of the scalar field \\spad{v,} \\spad{v} a function of the variables listed in xlist."))) 
NIL 
NIL 
(|MatrixCommonDenominator| R Q) 
((|constructor| (NIL "MatrixCommonDenominator provides functions to compute the common denominator of a matrix of elements of the quotient field of an integral domain.")) (|splitDenominator| (((|Record| (|:| |num| (|Matrix| |#1|)) (|:| |den| |#1|)) (|Matrix| |#2|)) "\\spad{splitDenominator(q)} returns \\spad{[p, \\spad{d]}} such that \\spad{q = p/d} and \\spad{d} is a common denominator for the elements of \\spad{q.}")) (|clearDenominator| (((|Matrix| |#1|) (|Matrix| |#2|)) "\\spad{clearDenominator(q)} returns \\spad{p} such that \\spad{q = p/d} where \\spad{d} is a common denominator for the elements of \\spad{q.}")) (|commonDenominator| ((|#1| (|Matrix| |#2|)) "\\spad{commonDenominator(q)} returns a common denominator \\spad{d} for the elements of \\spad{q.}"))) 
NIL 
NIL 
(|MachineComplex|) 
((|constructor| (NIL "A domain which models the complex number representation used by machines in the AXIOM-NAG link.")) (|coerce| (((|Complex| (|Float|)) $) "\\spad{coerce(u)} transforms \\spad{u} into a COmplex Float") (($ (|Complex| (|MachineInteger|))) "\\spad{coerce(u)} transforms \\spad{u} into a MachineComplex") (($ (|Complex| (|MachineFloat|))) "\\spad{coerce(u)} transforms \\spad{u} into a MachineComplex") (($ (|Complex| (|Integer|))) "\\spad{coerce(u)} transforms \\spad{u} into a MachineComplex") (($ (|Complex| (|Float|))) "\\spad{coerce(u)} transforms \\spad{u} into a MachineComplex"))) 
((|noZeroDivisors| . T) (|canonicalUnitNormal| |has| (|MachineFloat|) (|Field|)) (|canonicalsClosed| |has| (|MachineFloat|) (|Field|)) (|complex| . T) (|multiplicativeValuation| |has| (|MachineFloat|) (ATTRIBUTE |multiplicativeValuation|)) (|additiveValuation| |has| (|MachineFloat|) (ATTRIBUTE |additiveValuation|)) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|MachineFloat|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|MachineFloat|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|MachineFloat|) (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| (|MachineFloat|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| (|MachineFloat|) (QUOTE (|Finite|))) (|HasCategory| (|MachineFloat|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|MachineFloat|) (QUOTE (|Field|))) (|HasCategory| (|MachineFloat|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|MachineFloat|) (QUOTE (|DifferentialRing|))) (|HasCategory| (|MachineFloat|) (QUOTE (|FiniteFieldCategory|))) (OR (|HasCategory| (|MachineFloat|) (QUOTE (|Field|))) (|HasCategory| (|MachineFloat|) (QUOTE (|FiniteFieldCategory|)))) (|HasCategory| (|MachineFloat|) (LIST (QUOTE |Eltable|) (QUOTE (|MachineFloat|)) (QUOTE (|MachineFloat|)))) (|HasCategory| (|MachineFloat|) (LIST (QUOTE |Evalable|) (QUOTE (|MachineFloat|)))) (|HasCategory| (|MachineFloat|) (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (QUOTE (|MachineFloat|)))) (|HasCategory| (|MachineFloat|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| (|MachineFloat|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| (|MachineFloat|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| (|MachineFloat|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (OR (|HasCategory| (|MachineFloat|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|MachineFloat|) (QUOTE (|Field|))) (|HasCategory| (|MachineFloat|) (QUOTE (|FiniteFieldCategory|)))) (|HasCategory| (|MachineFloat|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|MachineFloat|) (QUOTE (|RealConstant|))) (|HasCategory| (|MachineFloat|) (QUOTE (|TranscendentalFunctionCategory|))) (AND (|HasCategory| (|MachineFloat|) (QUOTE (|RadicalCategory|))) (|HasCategory| (|MachineFloat|) (QUOTE (|TranscendentalFunctionCategory|)))) (|HasCategory| (|MachineFloat|) (QUOTE (|IntegerNumberSystem|))) (|HasCategory| (|MachineFloat|) (QUOTE (|RealNumberSystem|))) (AND (|HasCategory| (|MachineFloat|) (QUOTE (|RealNumberSystem|))) (|HasCategory| (|MachineFloat|) (QUOTE (|TranscendentalFunctionCategory|)))) (OR (|HasCategory| (|MachineFloat|) (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| (|MachineFloat|) (QUOTE (|Field|)))) (|HasCategory| (|MachineFloat|) (QUOTE (|PolynomialFactorizationExplicit|))) (AND (|HasCategory| (|MachineFloat|) (QUOTE (|DifferentialRing|))) (|HasCategory| (|MachineFloat|) (QUOTE (|Field|)))) (AND (|HasCategory| (|MachineFloat|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|MachineFloat|) (QUOTE (|Field|)))) (|HasCategory| (|MachineFloat|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| (|MachineFloat|) (QUOTE (|OrderedSet|))) (|HasCategory| (|MachineFloat|) (QUOTE (|IntegralDomain|))) (|HasAttribute| (|MachineFloat|) (QUOTE |multiplicativeValuation|)) (|HasAttribute| (|MachineFloat|) (QUOTE |additiveValuation|)) (AND (|HasCategory| (|MachineFloat|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|MachineFloat|) (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| (|MachineFloat|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|MachineFloat|) (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| (|MachineFloat|) (QUOTE (|Field|))) (AND (|HasCategory| (|MachineFloat|) (QUOTE (|FiniteFieldCategory|))) (|HasCategory| (|MachineFloat|) (QUOTE (|PolynomialFactorizationExplicit|))))) (OR (AND (|HasCategory| (|MachineFloat|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|MachineFloat|) (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| (|MachineFloat|) (QUOTE (|Field|))) (|HasCategory| (|MachineFloat|) (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| (|MachineFloat|) (QUOTE (|FiniteFieldCategory|))) (|HasCategory| (|MachineFloat|) (QUOTE (|PolynomialFactorizationExplicit|))))) (OR (AND (|HasCategory| (|MachineFloat|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|MachineFloat|) (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| (|MachineFloat|) (QUOTE (|Field|)))) (OR (AND (|HasCategory| (|MachineFloat|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|MachineFloat|) (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| (|MachineFloat|) (QUOTE (|IntegralDomain|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|MachineFloat|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|MachineFloat|) (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| (|MachineFloat|) (QUOTE (|CharacteristicNonZero|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|MachineFloat|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|MachineFloat|) (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| (|MachineFloat|) (QUOTE (|FiniteFieldCategory|))))) 
(|MultiDictionary| S) 
((|constructor| (NIL "A multi-dictionary is a dictionary which may contain duplicates. As for any dictionary, its size is assumed large so that copying (non-destructive) operations are generally to be avoided.")) (|duplicates| (((|List| (|Record| (|:| |entry| |#1|) (|:| |count| (|NonNegativeInteger|)))) $) "\\spad{duplicates(d)} returns a list of values which have duplicates in \\spad{d}")) (|removeDuplicates!| (($ $) "\\spad{removeDuplicates!(d)} destructively removes any duplicate values in dictionary \\spad{d.}")) (|insert!| (($ |#1| $ (|NonNegativeInteger|)) "\\spad{insert!(x,d,n)} destructively inserts \\spad{n} copies of \\spad{x} into dictionary \\spad{d.}"))) 
((|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|ModularDistinctDegreeFactorizer| U) 
((|constructor| (NIL "This package supports factorization and gcds of univariate polynomials over the integers modulo different primes. The inputs are given as polynomials over the integers with the prime passed explicitly as an extra argument.")) (|exptMod| ((|#1| |#1| (|Integer|) |#1| (|Integer|)) "\\spad{exptMod(f,n,g,p)} raises the univariate polynomial \\spad{f} to the \\spad{n}th power modulo the polynomial \\spad{g} and the prime \\spad{p.}")) (|separateFactors| (((|List| |#1|) (|List| (|Record| (|:| |factor| |#1|) (|:| |degree| (|Integer|)))) (|Integer|)) "\\spad{separateFactors(ddl, \\spad{p)}} refines the distinct degree factorization produced by ddFact to give a complete list of factors.")) (|ddFact| (((|List| (|Record| (|:| |factor| |#1|) (|:| |degree| (|Integer|)))) |#1| (|Integer|)) "\\spad{ddFact(f,p)} computes a distinct degree factorization of the polynomial \\spad{f} modulo the prime \\spad{p,} \\spadignore{i.e.} such that each factor is a product of irreducibles of the same degrees. The input polynomial \\spad{f} is assumed to be square-free modulo \\spad{p.}")) (|factor| (((|List| |#1|) |#1| (|Integer|)) "\\spad{factor(f1,p)} returns the list of factors of the univariate polynomial \\spad{f1} modulo the integer prime \\spad{p.} Error: if \\spad{f1} is not square-free modulo \\spad{p.}")) (|linears| ((|#1| |#1| (|Integer|)) "\\spad{linears(f,p)} returns the product of all the linear factors of \\spad{f} modulo \\spad{p.} Potentially incorrect result if \\spad{f} is not square-free modulo \\spad{p.}")) (|gcd| ((|#1| |#1| |#1| (|Integer|)) "\\spad{gcd(f1,f2,p)} computes the \\spad{gcd} of the univariate polynomials \\spad{f1} and \\spad{f2} modulo the integer prime \\spad{p.}"))) 
NIL 
NIL 
(|MeshCreationRoutinesForThreeDimensions|) 
((|constructor| (NIL "This package has no description")) (|ptFunc| (((|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|))) "\\spad{ptFunc(a,b,c,d)} is an internal function exported in order to compile packages.")) (|meshPar1Var| (((|ThreeSpace| (|DoubleFloat|)) (|Expression| (|Integer|)) (|Expression| (|Integer|)) (|Expression| (|Integer|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|List| (|DrawOption|))) "\\spad{meshPar1Var(s,t,u,f,s1,l)} \\undocumented")) (|meshFun2Var| (((|ThreeSpace| (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) (|Union| (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) "undefined") (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|List| (|DrawOption|))) "\\spad{meshFun2Var(f,g,s1,s2,l)} \\undocumented")) (|meshPar2Var| (((|ThreeSpace| (|DoubleFloat|)) (|ThreeSpace| (|DoubleFloat|)) (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|List| (|DrawOption|))) "\\spad{meshPar2Var(sp,f,s1,s2,l)} \\undocumented") (((|ThreeSpace| (|DoubleFloat|)) (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|List| (|DrawOption|))) "\\spad{meshPar2Var(f,s1,s2,l)} \\undocumented") (((|ThreeSpace| (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) (|Union| (|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) "undefined") (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|List| (|DrawOption|))) "\\spad{meshPar2Var(f,g,h,j,s1,s2,l)} \\undocumented"))) 
NIL 
NIL 
(|MultFiniteFactorize| OV E F PG) 
((|constructor| (NIL "Package for factorization of multivariate polynomials over finite fields.")) (|factor| (((|Factored| (|SparseUnivariatePolynomial| |#4|)) (|SparseUnivariatePolynomial| |#4|)) "\\spad{factor(p)} produces the complete factorization of the multivariate polynomial \\spad{p} over a finite field. \\spad{p} is represented as a univariate polynomial with multivariate coefficients over a finite field.") (((|Factored| |#4|) |#4|) "\\spad{factor(p)} produces the complete factorization of the multivariate polynomial \\spad{p} over a finite field."))) 
NIL 
NIL 
(|MachineFloat|) 
((|constructor| (NIL "A domain which models the floating point representation used by machines in the AXIOM-NAG link.")) (|changeBase| (($ (|Integer|) (|Integer|) (|PositiveInteger|)) "\\spad{changeBase(exp,man,base)} is not documented")) (|exponent| (((|Integer|) $) "\\spad{exponent(u)} returns the exponent of \\spad{u}")) (|mantissa| (((|Integer|) $) "\\spad{mantissa(u)} returns the mantissa of \\spad{u}")) (|coerce| (($ (|MachineInteger|)) "\\spad{coerce(u)} transforms a MachineInteger into a MachineFloat") (((|Float|) $) "\\spad{coerce(u)} transforms a MachineFloat to a standard Float")) (|minimumExponent| (((|Integer|)) "\\spad{minimumExponent()} returns the minimum exponent in the model") (((|Integer|) (|Integer|)) "\\spad{minimumExponent(e)} sets the minimum exponent in the model to \\spad{e}")) (|maximumExponent| (((|Integer|)) "\\spad{maximumExponent()} returns the maximum exponent in the model") (((|Integer|) (|Integer|)) "\\spad{maximumExponent(e)} sets the maximum exponent in the model to \\spad{e}")) (|base| (((|PositiveInteger|)) "\\spad{base()} returns the base of the model") (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{base(b)} sets the base of the model to \\spad{b}")) (|precision| (((|PositiveInteger|)) "\\spad{precision()} returns the number of digits in the model") (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{precision(p)} sets the number of digits in the model to \\spad{p}"))) 
((|approximate| . T) (|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|ModularHermitianRowReduction| R) 
((|constructor| (NIL "Modular hermitian row reduction.")) (|normalizedDivide| (((|Record| (|:| |quotient| |#1|) (|:| |remainder| |#1|)) |#1| |#1|) "\\spad{normalizedDivide(n,d)} returns a normalized quotient and remainder such that consistently unique representatives for the residue class are chosen, \\spadignore{e.g.} positive remainders")) (|rowEchelonLocal| (((|Matrix| |#1|) (|Matrix| |#1|) |#1| |#1|) "\\spad{rowEchelonLocal(m, \\spad{d,} \\spad{p)}} computes the row-echelon form of \\spad{m} concatenated with \\spad{d} times the identity matrix over a local ring where \\spad{p} is the only prime.")) (|rowEchLocal| (((|Matrix| |#1|) (|Matrix| |#1|) |#1|) "\\spad{rowEchLocal(m,p)} computes a modular row-echelon form of \\spad{m,} finding an appropriate modulus over a local ring where \\spad{p} is the only prime.")) (|rowEchelon| (((|Matrix| |#1|) (|Matrix| |#1|) |#1|) "\\spad{rowEchelon(m, \\spad{d)}} computes a modular row-echelon form mod \\spad{d} of \\indented{3}{[d\\space{5}]} \\indented{3}{[\\space{2}d\\space{3}]} \\indented{3}{[\\space{4}. \\spad{]}} \\indented{3}{[\\space{5}d]} \\indented{3}{[\\space{3}M\\space{2}]} where \\spad{M = \\spad{m} mod \\spad{d}.}")) (|rowEch| (((|Matrix| |#1|) (|Matrix| |#1|)) "\\spad{rowEch(m)} computes a modular row-echelon form of \\spad{m,} finding an appropriate modulus."))) 
NIL 
NIL 
(|MachineInteger|) 
((|constructor| (NIL "A domain which models the integer representation used by machines in the AXIOM-NAG link.")) (|coerce| (((|Expression| $) (|Expression| (|Integer|))) "\\spad{coerce(x)} returns \\spad{x} with coefficients in the domain")) (|maxint| (((|PositiveInteger|)) "\\spad{maxint()} returns the maximum integer in the model") (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{maxint(u)} sets the maximum integer in the model to \\spad{u}"))) 
((|multiplicativeValuation| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|MakeBinaryCompiledFunction| S D1 D2 I) 
((|constructor| (NIL "Tools and transforms for making compiled functions from top-level expressions")) (|compiledFunction| (((|Mapping| |#4| |#2| |#3|) |#1| (|Symbol|) (|Symbol|)) "\\spad{compiledFunction(expr,x,y)} returns a function \\spad{f: (D1, \\spad{D2)} \\spad{->} I} defined by \\spad{f(x, \\spad{y)} \\spad{==} expr}. Function \\spad{f} is compiled and directly applicable to objects of type \\spad{(D1, D2)}")) (|binaryFunction| (((|Mapping| |#4| |#2| |#3|) (|Symbol|)) "\\spad{binaryFunction(s)} is a local function"))) 
NIL 
NIL 
(|MakeCachableSet| S) 
((|constructor| (NIL "MakeCachableSet(S) returns a cachable set which is equal to \\spad{S} as a set.")) (|coerce| (($ |#1|) "\\spad{coerce(s)} returns \\spad{s} viewed as an element of \\spad{%.}"))) 
NIL 
NIL 
(|MakeFloatCompiledFunction| S) 
((|constructor| (NIL "Tools for making compiled functions from top-level expressions MakeFloatCompiledFunction transforms top-level objects into compiled Lisp functions whose arguments are Lisp floats. This by-passes the Axiom compiler and interpreter, thereby gaining several orders of magnitude.")) (|makeFloatFunction| (((|Mapping| (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) |#1| (|Symbol|) (|Symbol|)) "\\spad{makeFloatFunction(expr, \\spad{x,} \\spad{y)}} returns a Lisp function \\spad{f: (\\axiomType{DoubleFloat}, \\axiomType{DoubleFloat}) \\spad{->} \\axiomType{DoubleFloat}} defined by \\spad{f(x, \\spad{y)} \\spad{==} expr}. Function \\spad{f} is compiled and directly applicable to objects of type \\spad{(\\axiomType{DoubleFloat}, \\axiomType{DoubleFloat})}.") (((|Mapping| (|DoubleFloat|) (|DoubleFloat|)) |#1| (|Symbol|)) "\\spad{makeFloatFunction(expr, \\spad{x)}} returns a Lisp function \\spad{f: \\axiomType{DoubleFloat} \\spad{->} \\axiomType{DoubleFloat}} defined by \\spad{f(x) \\spad{==} expr}. Function \\spad{f} is compiled and directly applicable to objects of type \\axiomType{DoubleFloat}."))) 
NIL 
NIL 
(|MakeFunction| S) 
((|constructor| (NIL "Tools for making interpreter functions from top-level expressions Transforms top-level objects into interpreter functions.")) (|function| (((|Symbol|) |#1| (|Symbol|) (|List| (|Symbol|))) "\\spad{function(e, foo, [x1,...,xn])} creates a function \\spad{foo(x1,...,xn) \\spad{==} e}.") (((|Symbol|) |#1| (|Symbol|) (|Symbol|) (|Symbol|)) "\\spad{function(e, foo, \\spad{x,} \\spad{y)}} creates a function \\spad{foo(x, \\spad{y)} = e}.") (((|Symbol|) |#1| (|Symbol|) (|Symbol|)) "\\spad{function(e, foo, \\spad{x)}} creates a function \\spad{foo(x) \\spad{==} e}.") (((|Symbol|) |#1| (|Symbol|)) "\\spad{function(e, foo)} creates a function \\spad{foo() \\spad{==} e}."))) 
NIL 
NIL 
(|MakeRecord| S T$) 
((|constructor| (NIL "MakeRecord is used internally by the interpreter to create record types which are used for doing parallel iterations on streams.")) (|makeRecord| (((|Record| (|:| |part1| |#1|) (|:| |part2| |#2|)) |#1| |#2|) "\\spad{makeRecord(a,b)} creates a record object with type Record(part1:S, part2:R), where \\spad{part1} is \\spad{a} and \\spad{part2} is \\spad{b}."))) 
NIL 
NIL 
(|MakeUnaryCompiledFunction| S D I) 
((|constructor| (NIL "Tools for making compiled functions from top-level expressions Transforms top-level objects into compiled functions.")) (|compiledFunction| (((|Mapping| |#3| |#2|) |#1| (|Symbol|)) "\\spad{compiledFunction(expr, \\spad{x)}} returns a function \\spad{f: \\spad{D} \\spad{->} I} defined by \\spad{f(x) \\spad{==} expr}. Function \\spad{f} is compiled and directly applicable to objects of type \\spad{D.}")) (|unaryFunction| (((|Mapping| |#3| |#2|) (|Symbol|)) "\\spad{unaryFunction(a)} is a local function"))) 
NIL 
NIL 
(|MultivariateLifting| E OV R P) 
((|constructor| (NIL "This package provides the functions for the multivariate \"lifting\", using an algorithm of Paul Wang. This package will work for every euclidean domain \\spad{R} which has property \\spad{F,} \\spadignore{i.e.} there exists a factor operation in \\spad{R[x]}.")) (|lifting1| (((|Union| (|List| (|SparseUnivariatePolynomial| |#4|)) "failed") (|SparseUnivariatePolynomial| |#4|) (|List| |#2|) (|List| (|SparseUnivariatePolynomial| |#4|)) (|List| |#3|) (|List| |#4|) (|List| (|List| (|Record| (|:| |expt| (|NonNegativeInteger|)) (|:| |pcoef| |#4|)))) (|List| (|NonNegativeInteger|)) (|Vector| (|List| (|SparseUnivariatePolynomial| |#3|))) |#3|) "\\spad{lifting1(u,lv,lu,lr,lp,lt,ln,t,r)} \\undocumented")) (|lifting| (((|Union| (|List| (|SparseUnivariatePolynomial| |#4|)) "failed") (|SparseUnivariatePolynomial| |#4|) (|List| |#2|) (|List| (|SparseUnivariatePolynomial| |#3|)) (|List| |#3|) (|List| |#4|) (|List| (|NonNegativeInteger|)) |#3|) "\\spad{lifting(u,lv,lu,lr,lp,ln,r)} \\undocumented")) (|corrPoly| (((|Union| (|List| (|SparseUnivariatePolynomial| |#4|)) "failed") (|SparseUnivariatePolynomial| |#4|) (|List| |#2|) (|List| |#3|) (|List| (|NonNegativeInteger|)) (|List| (|SparseUnivariatePolynomial| |#4|)) (|Vector| (|List| (|SparseUnivariatePolynomial| |#3|))) |#3|) "\\spad{corrPoly(u,lv,lr,ln,lu,t,r)} \\undocumented"))) 
NIL 
NIL 
(|MonogenicLinearOperator| R) 
((|constructor| (NIL "This is the category of linear operator rings with one generator. The generator is not named by the category but can always be constructed as \\spad{monomial(1,1)}. \\blankline For convenience, call the generator \\spad{G}. Then each value is equal to \\spad{sum(a(i)*G**i, \\spad{i} = 0..n)} for some unique \\spad{n} and \\spad{a(i)} in \\spad{R}. \\blankline Note that multiplication is not necessarily commutative. In fact, if \\spad{a} is in \\spad{R}, it is quite normal to have \\spad{a*G \\spad{\\^=} G*a}.")) (|monomial| (($ |#1| (|NonNegativeInteger|)) "\\spad{monomial(c,k)} produces \\spad{c} times the \\spad{k}-th power of the generating operator, \\spad{monomial(1,1)}.")) (|coefficient| ((|#1| $ (|NonNegativeInteger|)) "\\spad{coefficient(l,k)} is \\spad{a(k)} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}")) (|reductum| (($ $) "\\spad{reductum(l)} is \\spad{l - monomial(a(n),n)} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}")) (|leadingCoefficient| ((|#1| $) "\\spad{leadingCoefficient(l)} is \\spad{a(n)} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}")) (|minimumDegree| (((|NonNegativeInteger|) $) "\\spad{minimumDegree(l)} is the smallest \\spad{k} such that \\spad{a(k) \\spad{\\^=} 0} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}")) (|degree| (((|NonNegativeInteger|) $) "\\spad{degree(l)} is \\spad{n} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}"))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|MultipleMap| R1 UP1 UPUP1 R2 UP2 UPUP2) 
((|constructor| (NIL "Lifting of a map through 2 levels of polynomials.")) (|map| ((|#6| (|Mapping| |#4| |#1|) |#3|) "\\spad{map(f, \\spad{p)}} lifts \\spad{f} to the domain of \\spad{p} then applies it to \\spad{p.}"))) 
NIL 
NIL 
(|MathMLFormat|) 
((|constructor| (NIL "This package is based on the TeXFormat domain by Robert \\spad{S.} Sutor \\spadtype{MathMLFormat} provides a coercion from \\spadtype{OutputForm} to MathML format.")) (|display| (((|Void|) (|String|)) "prints the string returned by coerce, adding <math ...> tags.")) (|exprex| (((|String|) (|OutputForm|)) "coverts \\spadtype{OutputForm} to \\spadtype{String} with the structure preserved with braces. Actually this is not quite accurate. The function \\spadfun{precondition} is first applied to the \\spadtype{OutputForm} expression before \\spadfun{exprex}. The raw \\spadtype{OutputForm} and the nature of the \\spadfun{precondition} function is still obscure to me at the time of this writing (2007-02-14).")) (|coerceL| (((|String|) (|OutputForm|)) "coerceS(o) changes \\spad{o} in the standard output format to MathML format and displays result as one long string.")) (|coerceS| (((|String|) (|OutputForm|)) "\\spad{coerceS(o)} changes \\spad{o} in the standard output format to MathML format and displays formatted result.")) (|coerce| (((|String|) (|OutputForm|)) "coerceS(o) changes \\spad{o} in the standard output format to MathML format."))) 
NIL 
NIL 
(|ModularField| R |Mod| |reduction| |merge| |exactQuo|) 
((|constructor| (NIL "These domains are used for the factorization and gcds of univariate polynomials over the integers in order to work modulo different primes. See \\spadtype{ModularRing}, \\spadtype{EuclideanModularRing}")) (|exQuo| (((|Union| $ "failed") $ $) "\\spad{exQuo(x,y)} is not documented")) (|reduce| (($ |#1| |#2|) "\\spad{reduce(r,m)} is not documented")) (|coerce| ((|#1| $) "\\spad{coerce(x)} is not documented")) (|modulus| ((|#2| $) "\\spad{modulus(x)} is not documented"))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|ModMonic| R |Rep|) 
((|constructor| (NIL "This package has not been documented")) (|frobenius| (($ $) "\\spad{frobenius(x)} is not documented")) (|computePowers| (((|PrimitiveArray| $)) "\\spad{computePowers()} is not documented")) (|pow| (((|PrimitiveArray| $)) "\\spad{pow()} is not documented")) (|An| (((|Vector| |#1|) $) "\\spad{An(x)} is not documented")) (|UnVectorise| (($ (|Vector| |#1|)) "\\spad{UnVectorise(v)} is not documented")) (|Vectorise| (((|Vector| |#1|) $) "\\spad{Vectorise(x)} is not documented")) (|coerce| (($ |#2|) "\\spad{coerce(x)} is not documented")) (|lift| ((|#2| $) "\\spad{lift(x)} is not documented")) (|reduce| (($ |#2|) "\\spad{reduce(x)} is not documented")) (|modulus| ((|#2|) "\\spad{modulus()} is not documented")) (|setPoly| ((|#2| |#2|) "\\spad{setPoly(x)} is not documented"))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|additiveValuation| |has| |#1| (|Field|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|StepThrough|))) (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))) (OR (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))))) 
(|ModuleMonomial| IS E |ff|) 
((|constructor| (NIL "This package has no documentation")) (|construct| (($ |#1| |#2|) "\\spad{construct(i,e)} is not documented")) (|coerce| (((|Record| (|:| |index| |#1|) (|:| |exponent| |#2|)) $) "\\spad{coerce(x)} is not documented") (($ (|Record| (|:| |index| |#1|) (|:| |exponent| |#2|))) "\\spad{coerce(x)} is not documented")) (|index| ((|#1| $) "\\spad{index(x)} is not documented")) (|exponent| ((|#2| $) "\\spad{exponent(x)} is not documented"))) 
NIL 
NIL 
(|ModuleOperator| R M) 
((|constructor| (NIL "Algebra of ADDITIVE operators on a module.")) (|makeop| (($ |#1| (|FreeGroup| (|BasicOperator|))) "\\spad{makeop should} be local but conditional")) (|opeval| ((|#2| (|BasicOperator|) |#2|) "\\spad{opeval should} be local but conditional")) (** (($ $ (|Integer|)) "\\spad{op**n} is not documented") (($ (|BasicOperator|) (|Integer|)) "\\spad{op**n} is not documented")) (|evaluateInverse| (($ $ (|Mapping| |#2| |#2|)) "\\spad{evaluateInverse(x,f)} is not documented")) (|evaluate| (($ $ (|Mapping| |#2| |#2|)) "\\spad{evaluate(f, \\spad{u} \\spad{+->} \\spad{g} u)} attaches the map \\spad{g} to \\spad{f.} \\spad{f} must be a basic operator \\spad{g} MUST be additive, \\spadignore{i.e.} \\spad{g(a + \\spad{b)} = g(a) + g(b)} for any \\spad{a}, \\spad{b} in \\spad{M.} This implies that \\spad{g(n a) = \\spad{n} g(a)} for any \\spad{a} in \\spad{M} and integer \\spad{n > 0}.")) (|conjug| ((|#1| |#1|) "\\spad{conjug(x)}should be local but conditional")) (|adjoint| (($ $ $) "\\spad{adjoint(op1, op2)} sets the adjoint of \\spad{op1} to be op2. \\spad{op1} must be a basic operator") (($ $) "\\spad{adjoint(op)} returns the adjoint of the operator \\spad{op}."))) 
((|leftUnitary| |has| |#1| (|CommutativeRing|)) (|rightUnitary| |has| |#1| (|CommutativeRing|)) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|)))) 
(|ModularRing| R |Mod| |reduction| |merge| |exactQuo|) 
((|constructor| (NIL "These domains are used for the factorization and gcds of univariate polynomials over the integers in order to work modulo different primes. See \\spadtype{EuclideanModularRing} ,\\spadtype{ModularField}")) (|inv| (($ $) "\\spad{inv(x)} is not documented")) (|recip| (((|Union| $ "failed") $) "\\spad{recip(x)} is not documented")) (|exQuo| (((|Union| $ "failed") $ $) "\\spad{exQuo(x,y)} is not documented")) (|reduce| (($ |#1| |#2|) "\\spad{reduce(r,m)} is not documented")) (|coerce| ((|#1| $) "\\spad{coerce(x)} is not documented")) (|modulus| ((|#2| $) "\\spad{modulus(x)} is not documented"))) 
((|unitsKnown| . T)) 
NIL 
(|Module&| S R) 
((|constructor| (NIL "The category of modules over a commutative ring. \\blankline Axioms\\br \\tab{5}\\spad{1*x = x}\\br \\tab{5}\\spad{(a*b)*x = a*(b*x)}\\br \\tab{5}\\spad{(a+b)*x = (a*x)+(b*x)}\\br \\tab{5}\\spad{a*(x+y) = (a*x)+(a*y)}"))) 
NIL 
NIL 
(|Module| R) 
((|constructor| (NIL "The category of modules over a commutative ring. \\blankline Axioms\\br \\tab{5}\\spad{1*x = x}\\br \\tab{5}\\spad{(a*b)*x = a*(b*x)}\\br \\tab{5}\\spad{(a+b)*x = (a*x)+(b*x)}\\br \\tab{5}\\spad{a*(x+y) = (a*x)+(a*y)}"))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|MoebiusTransform| F) 
((|constructor| (NIL "MoebiusTransform(F) is the domain of fractional linear (Moebius) transformations over \\spad{F.} This a domain of 2-by-2 matrices acting on P1(F).")) (|eval| (((|OnePointCompletion| |#1|) $ (|OnePointCompletion| |#1|)) "\\spad{eval(m,x)} returns \\spad{(a*x + b)/(c*x + \\spad{d)}} where \\spad{m = moebius(a,b,c,d)} (see moebius from MoebiusTransform).") ((|#1| $ |#1|) "\\spad{eval(m,x)} returns \\spad{(a*x + b)/(c*x + \\spad{d)}} where \\spad{m = moebius(a,b,c,d)} (see moebius from MoebiusTransform).")) (|recip| (($ $) "\\spad{recip(m)} = recip() * \\spad{m}") (($) "\\spad{recip()} returns \\spad{matrix [[0,1],[1,0]]} representing the map \\spad{x \\spad{->} 1 / \\spad{x}.}")) (|scale| (($ $ |#1|) "\\spad{scale(m,h)} returns \\spad{scale(h) * \\spad{m}} (see shift from MoebiusTransform).") (($ |#1|) "\\spad{scale(k)} returns \\spad{matrix [[k,0],[0,1]]} representing the map \\spad{x \\spad{->} \\spad{k} * \\spad{x}.}")) (|shift| (($ $ |#1|) "\\spad{shift(m,h)} returns \\spad{shift(h) * \\spad{m}} (see shift from MoebiusTransform).") (($ |#1|) "\\spad{shift(k)} returns \\spad{matrix [[1,k],[0,1]]} representing the map \\spad{x \\spad{->} \\spad{x} + \\spad{k}.}")) (|moebius| (($ |#1| |#1| |#1| |#1|) "\\spad{moebius(a,b,c,d)} returns \\spad{matrix [[a,b],[c,d]]}."))) 
((|unitsKnown| . T)) 
NIL 
(|Monad&| S) 
((|constructor| (NIL "Monad is the class of all multiplicative monads, that is sets with a binary operation.")) (** (($ $ (|PositiveInteger|)) "\\spad{a**n} returns the \\spad{n}-th power of \\spad{a}, defined by repeated squaring.")) (|leftPower| (($ $ (|PositiveInteger|)) "\\spad{leftPower(a,n)} returns the \\spad{n}-th left power of \\spad{a}, that is, \\spad{leftPower(a,n) \\spad{:=} a * leftPower(a,n-1)} and \\spad{leftPower(a,1) \\spad{:=} a}.")) (|rightPower| (($ $ (|PositiveInteger|)) "\\spad{rightPower(a,n)} returns the \\spad{n}-th right power of \\spad{a}, that is, \\spad{rightPower(a,n) \\spad{:=} rightPower(a,n-1) * a} and \\spad{rightPower(a,1) \\spad{:=} a}.")) (* (($ $ $) "\\spad{a*b} is the product of \\spad{a} and \\spad{b} in a set with a binary operation."))) 
NIL 
NIL 
(|Monad|) 
((|constructor| (NIL "Monad is the class of all multiplicative monads, that is sets with a binary operation.")) (** (($ $ (|PositiveInteger|)) "\\spad{a**n} returns the \\spad{n}-th power of \\spad{a}, defined by repeated squaring.")) (|leftPower| (($ $ (|PositiveInteger|)) "\\spad{leftPower(a,n)} returns the \\spad{n}-th left power of \\spad{a}, that is, \\spad{leftPower(a,n) \\spad{:=} a * leftPower(a,n-1)} and \\spad{leftPower(a,1) \\spad{:=} a}.")) (|rightPower| (($ $ (|PositiveInteger|)) "\\spad{rightPower(a,n)} returns the \\spad{n}-th right power of \\spad{a}, that is, \\spad{rightPower(a,n) \\spad{:=} rightPower(a,n-1) * a} and \\spad{rightPower(a,1) \\spad{:=} a}.")) (* (($ $ $) "\\spad{a*b} is the product of \\spad{a} and \\spad{b} in a set with a binary operation."))) 
NIL 
NIL 
(|MonadWithUnit&| S) 
((|constructor| (NIL "MonadWithUnit is the class of multiplicative monads with unit, that is, sets with a binary operation and a unit element. \\blankline Axioms\\br \\tab{5}leftIdentity(\"*\":(\\%,\\%)->\\%,1) for example, 1*x=x\\br \\tab{5}rightIdentity(\"*\":(\\%,\\%)->\\%,1) for example, x*1=x \\blankline Common Additional Axioms\\br \\tab{5}unitsKnown - if \"recip\" says \"failed\", it PROVES input wasn't a unit")) (|rightRecip| (((|Union| $ "failed") $) "\\spad{rightRecip(a)} returns an element, which is a right inverse of \\spad{a}, or \\spad{\"failed\"} if such an element doesn't exist or cannot be determined (see unitsKnown).")) (|leftRecip| (((|Union| $ "failed") $) "\\spad{leftRecip(a)} returns an element, which is a left inverse of \\spad{a}, or \\spad{\"failed\"} if such an element doesn't exist or cannot be determined (see unitsKnown).")) (|recip| (((|Union| $ "failed") $) "\\spad{recip(a)} returns an element, which is both a left and a right inverse of \\spad{a}, or \\spad{\"failed\"} if such an element doesn't exist or cannot be determined (see unitsKnown).")) (** (($ $ (|NonNegativeInteger|)) "\\spad{a**n} returns the \\spad{n}-th power of \\spad{a}, defined by repeated squaring.")) (|leftPower| (($ $ (|NonNegativeInteger|)) "\\spad{leftPower(a,n)} returns the \\spad{n}-th left power of \\spad{a}, that is, \\spad{leftPower(a,n) \\spad{:=} a * leftPower(a,n-1)} and \\spad{leftPower(a,0) \\spad{:=} 1}.")) (|rightPower| (($ $ (|NonNegativeInteger|)) "\\spad{rightPower(a,n)} returns the \\spad{n}-th right power of \\spad{a}, that is, \\spad{rightPower(a,n) \\spad{:=} rightPower(a,n-1) * a} and \\spad{rightPower(a,0) \\spad{:=} 1}.")) (|one?| (((|Boolean|) $) "\\spad{one?(a)} tests whether \\spad{a} is the unit 1.")) ((|One|) (($) "\\spad{1} returns the unit element, denoted by 1."))) 
NIL 
NIL 
(|MonadWithUnit|) 
((|constructor| (NIL "MonadWithUnit is the class of multiplicative monads with unit, that is, sets with a binary operation and a unit element. \\blankline Axioms\\br \\tab{5}leftIdentity(\"*\":(\\%,\\%)->\\%,1) for example, 1*x=x\\br \\tab{5}rightIdentity(\"*\":(\\%,\\%)->\\%,1) for example, x*1=x \\blankline Common Additional Axioms\\br \\tab{5}unitsKnown - if \"recip\" says \"failed\", it PROVES input wasn't a unit")) (|rightRecip| (((|Union| $ "failed") $) "\\spad{rightRecip(a)} returns an element, which is a right inverse of \\spad{a}, or \\spad{\"failed\"} if such an element doesn't exist or cannot be determined (see unitsKnown).")) (|leftRecip| (((|Union| $ "failed") $) "\\spad{leftRecip(a)} returns an element, which is a left inverse of \\spad{a}, or \\spad{\"failed\"} if such an element doesn't exist or cannot be determined (see unitsKnown).")) (|recip| (((|Union| $ "failed") $) "\\spad{recip(a)} returns an element, which is both a left and a right inverse of \\spad{a}, or \\spad{\"failed\"} if such an element doesn't exist or cannot be determined (see unitsKnown).")) (** (($ $ (|NonNegativeInteger|)) "\\spad{a**n} returns the \\spad{n}-th power of \\spad{a}, defined by repeated squaring.")) (|leftPower| (($ $ (|NonNegativeInteger|)) "\\spad{leftPower(a,n)} returns the \\spad{n}-th left power of \\spad{a}, that is, \\spad{leftPower(a,n) \\spad{:=} a * leftPower(a,n-1)} and \\spad{leftPower(a,0) \\spad{:=} 1}.")) (|rightPower| (($ $ (|NonNegativeInteger|)) "\\spad{rightPower(a,n)} returns the \\spad{n}-th right power of \\spad{a}, that is, \\spad{rightPower(a,n) \\spad{:=} rightPower(a,n-1) * a} and \\spad{rightPower(a,0) \\spad{:=} 1}.")) (|one?| (((|Boolean|) $) "\\spad{one?(a)} tests whether \\spad{a} is the unit 1.")) ((|One|) (($) "\\spad{1} returns the unit element, denoted by 1."))) 
NIL 
NIL 
(|MonogenicAlgebra&| S R UP) 
((|constructor| (NIL "A \\spadtype{MonogenicAlgebra} is an algebra of finite rank which can be generated by a single element.")) (|derivationCoordinates| (((|Matrix| |#2|) (|Vector| $) (|Mapping| |#2| |#2|)) "\\spad{derivationCoordinates(b, \\spad{')}} returns \\spad{M} such that \\spad{b' = \\spad{M} \\spad{b}.}")) (|lift| ((|#3| $) "\\spad{lift(z)} returns a minimal degree univariate polynomial up such that \\spad{z=reduce up}.")) (|convert| (($ |#3|) "\\spad{convert(up)} converts the univariate polynomial \\spad{up} to an algebra element, reducing by the \\spad{definingPolynomial()} if necessary.")) (|reduce| (((|Union| $ "failed") (|Fraction| |#3|)) "\\spad{reduce(frac)} converts the fraction \\spad{frac} to an algebra element.") (($ |#3|) "\\spad{reduce(up)} converts the univariate polynomial \\spad{up} to an algebra element, reducing by the \\spad{definingPolynomial()} if necessary.")) (|definingPolynomial| ((|#3|) "\\spad{definingPolynomial()} returns the minimal polynomial which \\spad{generator()} satisfies.")) (|generator| (($) "\\spad{generator()} returns the generator for this domain."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|FiniteFieldCategory|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Finite|)))) 
(|MonogenicAlgebra| R UP) 
((|constructor| (NIL "A \\spadtype{MonogenicAlgebra} is an algebra of finite rank which can be generated by a single element.")) (|derivationCoordinates| (((|Matrix| |#1|) (|Vector| $) (|Mapping| |#1| |#1|)) "\\spad{derivationCoordinates(b, \\spad{')}} returns \\spad{M} such that \\spad{b' = \\spad{M} \\spad{b}.}")) (|lift| ((|#2| $) "\\spad{lift(z)} returns a minimal degree univariate polynomial up such that \\spad{z=reduce up}.")) (|convert| (($ |#2|) "\\spad{convert(up)} converts the univariate polynomial \\spad{up} to an algebra element, reducing by the \\spad{definingPolynomial()} if necessary.")) (|reduce| (((|Union| $ "failed") (|Fraction| |#2|)) "\\spad{reduce(frac)} converts the fraction \\spad{frac} to an algebra element.") (($ |#2|) "\\spad{reduce(up)} converts the univariate polynomial \\spad{up} to an algebra element, reducing by the \\spad{definingPolynomial()} if necessary.")) (|definingPolynomial| ((|#2|) "\\spad{definingPolynomial()} returns the minimal polynomial which \\spad{generator()} satisfies.")) (|generator| (($) "\\spad{generator()} returns the generator for this domain."))) 
((|noZeroDivisors| |has| |#1| (|Field|)) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|Monoid&| S) 
((|constructor| (NIL "The class of multiplicative monoids, \\spadignore{i.e.} semigroups with a multiplicative identity element. \\blankline Axioms\\br \\tab{5}\\spad{leftIdentity(\"*\":(\\%,\\%)->\\%,1)}\\tab{5}\\spad{1*x=x}\\br \\tab{5}\\spad{rightIdentity(\"*\":(\\%,\\%)->\\%,1)}\\tab{4}\\spad{x*1=x} \\blankline Conditional attributes\\br \\tab{5}unitsKnown - \\spadfun{recip} only returns \"failed\" on non-units")) (|recip| (((|Union| $ "failed") $) "\\spad{recip(x)} tries to compute the multiplicative inverse for \\spad{x} or \"failed\" if it cannot find the inverse (see unitsKnown).")) (^ (($ $ (|NonNegativeInteger|)) "\\spad{x^n} returns the repeated product of \\spad{x} \\spad{n} times, \\spadignore{i.e.} exponentiation.")) (** (($ $ (|NonNegativeInteger|)) "\\spad{x**n} returns the repeated product of \\spad{x} \\spad{n} times, \\spadignore{i.e.} exponentiation.")) (|one?| (((|Boolean|) $) "\\spad{one?(x)} tests if \\spad{x} is equal to 1.")) (|sample| (($) "\\spad{sample yields} a value of type \\%")) ((|One|) (($) "1 is the multiplicative identity."))) 
NIL 
NIL 
(|Monoid|) 
((|constructor| (NIL "The class of multiplicative monoids, \\spadignore{i.e.} semigroups with a multiplicative identity element. \\blankline Axioms\\br \\tab{5}\\spad{leftIdentity(\"*\":(\\%,\\%)->\\%,1)}\\tab{5}\\spad{1*x=x}\\br \\tab{5}\\spad{rightIdentity(\"*\":(\\%,\\%)->\\%,1)}\\tab{4}\\spad{x*1=x} \\blankline Conditional attributes\\br \\tab{5}unitsKnown - \\spadfun{recip} only returns \"failed\" on non-units")) (|recip| (((|Union| $ "failed") $) "\\spad{recip(x)} tries to compute the multiplicative inverse for \\spad{x} or \"failed\" if it cannot find the inverse (see unitsKnown).")) (^ (($ $ (|NonNegativeInteger|)) "\\spad{x^n} returns the repeated product of \\spad{x} \\spad{n} times, \\spadignore{i.e.} exponentiation.")) (** (($ $ (|NonNegativeInteger|)) "\\spad{x**n} returns the repeated product of \\spad{x} \\spad{n} times, \\spadignore{i.e.} exponentiation.")) (|one?| (((|Boolean|) $) "\\spad{one?(x)} tests if \\spad{x} is equal to 1.")) (|sample| (($) "\\spad{sample yields} a value of type \\%")) ((|One|) (($) "1 is the multiplicative identity."))) 
NIL 
NIL 
(|MonomialExtensionTools| F UP) 
((|constructor| (NIL "Tools for handling monomial extensions.")) (|decompose| (((|Record| (|:| |poly| |#2|) (|:| |normal| (|Fraction| |#2|)) (|:| |special| (|Fraction| |#2|))) (|Fraction| |#2|) (|Mapping| |#2| |#2|)) "\\spad{decompose(f, \\spad{D)}} returns \\spad{[p,n,s]} such that \\spad{f = p+n+s}, all the squarefree factors of \\spad{denom(n)} are normal w.r.t. \\spad{D,} \\spad{denom(s)} is special w.r.t. \\spad{D,} and \\spad{n} and \\spad{s} are proper fractions (no pole at infinity). \\spad{D} is the derivation to use.")) (|normalDenom| ((|#2| (|Fraction| |#2|) (|Mapping| |#2| |#2|)) "\\spad{normalDenom(f, \\spad{D)}} returns the product of all the normal factors of \\spad{denom(f)}. \\spad{D} is the derivation to use.")) (|splitSquarefree| (((|Record| (|:| |normal| (|Factored| |#2|)) (|:| |special| (|Factored| |#2|))) |#2| (|Mapping| |#2| |#2|)) "\\spad{splitSquarefree(p, \\spad{D)}} returns \\spad{[n_1 \\spad{n_2\\^2} \\spad{...} n_m\\^m, \\spad{s_1} \\spad{s_2\\^2} \\spad{...} s_q\\^q]} such that \\spad{p = \\spad{n_1} \\spad{n_2\\^2} \\spad{...} n_m\\^m \\spad{s_1} \\spad{s_2\\^2} \\spad{...} s_q\\^q}, each \\spad{n_i} is normal w.r.t. \\spad{D} and each \\spad{s_i} is special w.r.t \\spad{D.} \\spad{D} is the derivation to use.")) (|split| (((|Record| (|:| |normal| |#2|) (|:| |special| |#2|)) |#2| (|Mapping| |#2| |#2|)) "\\spad{split(p, \\spad{D)}} returns \\spad{[n,s]} such that \\spad{p = \\spad{n} \\spad{s},} all the squarefree factors of \\spad{n} are normal w.r.t. \\spad{D,} and \\spad{s} is special w.r.t. \\spad{D.} \\spad{D} is the derivation to use."))) 
NIL 
NIL 
(|MPolyCatFunctions2| |VarSet| E1 E2 R S PR PS) 
((|constructor| (NIL "Utilities for MPolyCat")) (|reshape| ((|#7| (|List| |#5|) |#6|) "\\spad{reshape(l,p)} \\undocumented")) (|map| ((|#7| (|Mapping| |#5| |#4|) |#6|) "\\spad{map(f,p)} \\undocumented"))) 
NIL 
NIL 
(|MPolyCatFunctions3| |Vars1| |Vars2| E1 E2 R PR1 PR2) 
((|constructor| (NIL "This package has no description")) (|map| ((|#7| (|Mapping| |#2| |#1|) |#6|) "\\spad{map(f,x)} \\undocumented"))) 
NIL 
NIL 
(|MPolyCatPolyFactorizer| E OV R PPR) 
((|constructor| (NIL "This package exports a factor operation for multivariate polynomials with coefficients which are polynomials over some ring \\spad{R} over which we can factor. It is used internally by packages such as the solve package which need to work with polynomials in a specific set of variables with coefficients which are polynomials in all the other variables.")) (|factor| (((|Factored| |#4|) |#4|) "\\spad{factor(p)} factors a polynomial with polynomial coefficients.")) (|variable| (((|Union| $ "failed") (|Symbol|)) "\\spad{variable(s)} makes an element from symbol \\spad{s} or fails.")) (|convert| (((|Symbol|) $) "\\spad{convert(x)} converts \\spad{x} to a symbol"))) 
NIL 
NIL 
(|MultivariatePolynomial| |vl| R) 
((|constructor| (NIL "This type is the basic representation of sparse recursive multivariate polynomials whose variables are from a user specified list of symbols. The ordering is specified by the position of the variable in the list. The coefficient ring may be non commutative, but the variables are assumed to commute."))) 
(((|commutative| "*") |has| |#2| (|CommutativeRing|)) (|noZeroDivisors| |has| |#2| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#2| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| (|OrderedVariableList| |#1|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#2| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Field|))) (OR (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasAttribute| |#2| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))))) 
(|MPolyCatRationalFunctionFactorizer| E OV R PRF) 
((|constructor| (NIL "This package exports a factor operation for multivariate polynomials with coefficients which are rational functions over some ring \\spad{R} over which we can factor. It is used internally by packages such as primary decomposition which need to work with polynomials with rational function coefficients, \\spadignore{i.e.} themselves fractions of polynomials.")) (|factor| (((|Factored| |#4|) |#4|) "\\spad{factor(prf)} factors a polynomial with rational function coefficients.")) (|pushuconst| ((|#4| (|Fraction| (|Polynomial| |#3|)) |#2|) "\\spad{pushuconst(r,var)} takes a rational function and raises all occurances of the variable \\spad{var} to the polynomial level.")) (|pushucoef| ((|#4| (|SparseUnivariatePolynomial| (|Polynomial| |#3|)) |#2|) "\\spad{pushucoef(upoly,var)} converts the anonymous univariate polynomial \\spad{upoly} to a polynomial in \\spad{var} over rational functions.")) (|pushup| ((|#4| |#4| |#2|) "\\spad{pushup(prf,var)} raises all occurences of the variable \\spad{var} in the coefficients of the polynomial \\spad{prf} back to the polynomial level.")) (|pushdterm| ((|#4| (|SparseUnivariatePolynomial| |#4|) |#2|) "\\spad{pushdterm(monom,var)} pushes all top level occurences of the variable \\spad{var} into the coefficient domain for the monomial monom.")) (|pushdown| ((|#4| |#4| |#2|) "\\spad{pushdown(prf,var)} pushes all top level occurences of the variable \\spad{var} into the coefficient domain for the polynomial prf.")) (|totalfract| (((|Record| (|:| |sup| (|Polynomial| |#3|)) (|:| |inf| (|Polynomial| |#3|))) |#4|) "\\spad{totalfract(prf)} takes a polynomial whose coefficients are themselves fractions of polynomials and returns a record containing the numerator and denominator resulting from putting \\spad{prf} over a common denominator.")) (|convert| (((|Symbol|) $) "\\spad{convert(x)} converts \\spad{x} to a symbol"))) 
NIL 
NIL 
(|MRationalFactorize| E OV R P) 
((|constructor| (NIL "MRationalFactorize contains the factor function for multivariate polynomials over the quotient field of a ring \\spad{R} such that the package MultivariateFactorize can factor multivariate polynomials over \\spad{R.}")) (|factor| (((|Factored| |#4|) |#4|) "\\spad{factor(p)} factors the multivariate polynomial \\spad{p} with coefficients which are fractions of elements of \\spad{R.}"))) 
NIL 
NIL 
(|MonoidRingFunctions2| R S M) 
((|constructor| (NIL "\\spad{MonoidRingFunctions2} implements functions between two monoid rings defined with the same monoid over different rings.")) (|map| (((|MonoidRing| |#2| |#3|) (|Mapping| |#2| |#1|) (|MonoidRing| |#1| |#3|)) "\\spad{map(f,u)} maps \\spad{f} onto the coefficients \\spad{f} the element \\spad{u} of the monoid ring to create an element of a monoid ring with the same monoid \\spad{b.}"))) 
NIL 
NIL 
(|MonoidRing| R M) 
((|constructor| (NIL "\\spadtype{MonoidRing}(R,M), implements the algebra of all maps from the monoid \\spad{M} to the commutative ring \\spad{R} with finite support. Multiplication of two maps \\spad{f} and \\spad{g} is defined to map an element \\spad{c} of \\spad{M} to the (convolution) sum over f(a)g(b) such that ab = \\spad{c.} Thus \\spad{M} can be identified with a canonical basis and the maps can also be considered as formal linear combinations of the elements in \\spad{M.} Scalar multiples of a basis element are called monomials. A prominent example is the class of polynomials where the monoid is a direct product of the natural numbers with pointwise addition. When \\spad{M} is \\spadtype{FreeMonoid Symbol}, one gets polynomials in infinitely many non-commuting variables. Another application area is representation theory of finite groups \\spad{G,} where modules over \\spadtype{MonoidRing}(R,G) are studied.")) (|reductum| (($ $) "\\spad{reductum(f)} is \\spad{f} minus its leading monomial.")) (|leadingCoefficient| ((|#1| $) "\\spad{leadingCoefficient(f)} gives the coefficient of \\spad{f,} whose corresponding monoid element is the greatest among all those with non-zero coefficients.")) (|leadingMonomial| ((|#2| $) "\\spad{leadingMonomial(f)} gives the monomial of \\spad{f} whose corresponding monoid element is the greatest among all those with non-zero coefficients.")) (|numberOfMonomials| (((|NonNegativeInteger|) $) "\\spad{numberOfMonomials(f)} is the number of non-zero coefficients with respect to the canonical basis.")) (|monomials| (((|List| $) $) "\\spad{monomials(f)} gives the list of all monomials whose sum is \\spad{f.}")) (|coefficients| (((|List| |#1|) $) "\\spad{coefficients(f)} lists all non-zero coefficients.")) (|monomial?| (((|Boolean|) $) "\\spad{monomial?(f)} tests if \\spad{f} is a single monomial.")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\spad{map(fn,u)} maps function \\spad{fn} onto the coefficients of the non-zero monomials of u.")) (|terms| (((|List| (|Record| (|:| |coef| |#1|) (|:| |monom| |#2|))) $) "\\spad{terms(f)} gives the list of non-zero coefficients combined with their corresponding basis element as records. This is the internal representation.")) (|coerce| (($ (|List| (|Record| (|:| |coef| |#1|) (|:| |monom| |#2|)))) "\\spad{coerce(lt)} converts a list of terms and coefficients to a member of the domain.")) (|coefficient| ((|#1| $ |#2|) "\\spad{coefficient(f,m)} extracts the coefficient of \\spad{m} in \\spad{f} with respect to the canonical basis \\spad{M.}")) (|monomial| (($ |#1| |#2|) "\\spad{monomial(r,m)} creates a scalar multiple of the basis element \\spad{m.}"))) 
((|leftUnitary| |has| |#1| (|CommutativeRing|)) (|rightUnitary| |has| |#1| (|CommutativeRing|)) (|unitsKnown| . T)) 
((AND (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#2| (QUOTE (|Finite|)))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (QUOTE (|OrderedSet|)))) 
(|MultisetAggregate| S) 
((|constructor| (NIL "A multi-set aggregate is a set which keeps track of the multiplicity of its elements."))) 
((|partiallyOrderedSet| . T) (|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|Multiset| S) 
((|constructor| (NIL "A multiset is a set with multiplicities.")) (|remove!| (($ (|Mapping| (|Boolean|) |#1|) $ (|Integer|)) "\\spad{remove!(p,ms,number)} removes destructively at most \\spad{number} copies of elements \\spad{x} such that \\spad{p(x)} is \\spadfun{true} if \\spad{number} is positive, all of them if \\spad{number} equals zero, and all but at most \\spad{-number} if \\spad{number} is negative.") (($ |#1| $ (|Integer|)) "\\spad{remove!(x,ms,number)} removes destructively at most \\spad{number} copies of element \\spad{x} if \\spad{number} is positive, all of them if \\spad{number} equals zero, and all but at most \\spad{-number} if \\spad{number} is negative.")) (|remove| (($ (|Mapping| (|Boolean|) |#1|) $ (|Integer|)) "\\spad{remove(p,ms,number)} removes at most \\spad{number} copies of elements \\spad{x} such that \\spad{p(x)} is \\spadfun{true} if \\spad{number} is positive, all of them if \\spad{number} equals zero, and all but at most \\spad{-number} if \\spad{number} is negative.") (($ |#1| $ (|Integer|)) "\\spad{remove(x,ms,number)} removes at most \\spad{number} copies of element \\spad{x} if \\spad{number} is positive, all of them if \\spad{number} equals zero, and all but at most \\spad{-number} if \\spad{number} is negative.")) (|members| (((|List| |#1|) $) "\\spad{members(ms)} returns a list of the elements of \\spad{ms} without their multiplicity. See also \\spadfun{parts}.")) (|multiset| (($ (|List| |#1|)) "\\spad{multiset(ls)} creates a multiset with elements from \\spad{ls}.") (($ |#1|) "\\spad{multiset(s)} creates a multiset with singleton \\spad{s.}") (($) "\\spad{multiset()}$D creates an empty multiset of domain \\spad{D.}"))) 
((|finiteAggregate| . T) (|partiallyOrderedSet| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|MoreSystemCommands|) 
((|constructor| (NIL "\\spadtype{MoreSystemCommands} implements an interface with the system command facility. These are the commands that are issued from source files or the system interpreter and they start with a close parenthesis, for example, the \"what\" commands.")) (|systemCommand| (((|Void|) (|String|)) "\\spad{systemCommand(cmd)} takes the string \\spadvar{cmd} and passes it to the runtime environment for execution as a system command. Although various things may be printed, no usable value is returned."))) 
NIL 
NIL 
(|MergeThing| S) 
((|constructor| (NIL "This package exports tools for merging lists")) (|mergeDifference| (((|List| |#1|) (|List| |#1|) (|List| |#1|)) "\\spad{mergeDifference(l1,l2)} returns a list of elements in \\spad{l1} not present in \\spad{l2.} Assumes lists are ordered and all \\spad{x} in \\spad{l2} are also in \\spad{l1.}"))) 
NIL 
NIL 
(|MultivariateTaylorSeriesCategory| |Coef| |Var|) 
((|constructor| (NIL "\\spadtype{MultivariateTaylorSeriesCategory} is the most general multivariate Taylor series category.")) (|integrate| (($ $ |#2|) "\\spad{integrate(f,x)} returns the anti-derivative of the power series \\spad{f(x)} with respect to the variable \\spad{x} with constant coefficient 1. We may integrate a series when we can divide coefficients by integers.")) (|polynomial| (((|Polynomial| |#1|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{polynomial(f,k1,k2)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 \\spad{<=} \\spad{d} \\spad{<=} k2}.") (((|Polynomial| |#1|) $ (|NonNegativeInteger|)) "\\spad{polynomial(f,k)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{<= \\spad{k}.}")) (|order| (((|NonNegativeInteger|) $ |#2| (|NonNegativeInteger|)) "\\spad{order(f,x,n)} returns \\spad{min(n,order(f,x))}.") (((|NonNegativeInteger|) $ |#2|) "\\spad{order(f,x)} returns the order of \\spad{f} viewed as a series in \\spad{x} may result in an infinite loop if \\spad{f} has no non-zero terms.")) (|monomial| (($ $ (|List| |#2|) (|List| (|NonNegativeInteger|))) "\\spad{monomial(a,[x1,x2,...,xk],[n1,n2,...,nk])} returns \\spad{a * \\spad{x1^n1} * \\spad{...} * xk^nk}.") (($ $ |#2| (|NonNegativeInteger|)) "\\spad{monomial(a,x,n)} returns \\spad{a*x^n}.")) (|extend| (($ $ (|NonNegativeInteger|)) "\\spad{extend(f,n)} causes all terms of \\spad{f} of degree \\spad{<= \\spad{n}} to be computed.")) (|coefficient| (($ $ (|List| |#2|) (|List| (|NonNegativeInteger|))) "\\spad{coefficient(f,[x1,x2,...,xk],[n1,n2,...,nk])} returns the coefficient of \\spad{x1^n1 * \\spad{...} * xk^nk} in \\spad{f.}") (($ $ |#2| (|NonNegativeInteger|)) "\\spad{coefficient(f,x,n)} returns the coefficient of \\spad{x^n} in \\spad{f.}"))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|MultivariateFactorize| OV E R P) 
((|constructor| (NIL "This is the top level package for doing multivariate factorization over basic domains like \\spadtype{Integer} or \\spadtype{Fraction Integer}.")) (|factor| (((|Factored| (|SparseUnivariatePolynomial| |#4|)) (|SparseUnivariatePolynomial| |#4|)) "\\spad{factor(p)} factors the multivariate polynomial \\spad{p} over its coefficient domain where \\spad{p} is represented as a univariate polynomial with multivariate coefficients") (((|Factored| |#4|) |#4|) "\\spad{factor(p)} factors the multivariate polynomial \\spad{p} over its coefficient domain"))) 
NIL 
NIL 
(|MultivariateSquareFree| E OV R P) 
((|constructor| (NIL "This package provides the functions for the computation of the square free decomposition of a multivariate polynomial. It uses the package GenExEuclid for the resolution of the equation \\spad{Af + \\spad{Bg} = \\spad{h}} and its generalization to \\spad{n} polynomials over an integral domain and the package \\spad{MultivariateLifting} for the \"multivariate\" lifting.")) (|normDeriv2| (((|SparseUnivariatePolynomial| |#3|) (|SparseUnivariatePolynomial| |#3|) (|Integer|)) "\\spad{normDeriv2 should} be local")) (|myDegree| (((|List| (|NonNegativeInteger|)) (|SparseUnivariatePolynomial| |#4|) (|List| |#2|) (|NonNegativeInteger|)) "\\spad{myDegree should} be local")) (|lift| (((|Union| (|List| (|SparseUnivariatePolynomial| |#4|)) "failed") (|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#3|) (|SparseUnivariatePolynomial| |#3|) |#4| (|List| |#2|) (|List| (|NonNegativeInteger|)) (|List| |#3|)) "\\spad{lift should} be local")) (|check| (((|Boolean|) (|List| (|Record| (|:| |factor| (|SparseUnivariatePolynomial| |#3|)) (|:| |exponent| (|Integer|)))) (|List| (|Record| (|:| |factor| (|SparseUnivariatePolynomial| |#3|)) (|:| |exponent| (|Integer|))))) "\\spad{check should} be local")) (|coefChoose| ((|#4| (|Integer|) (|Factored| |#4|)) "\\spad{coefChoose should} be local")) (|intChoose| (((|Record| (|:| |upol| (|SparseUnivariatePolynomial| |#3|)) (|:| |Lval| (|List| |#3|)) (|:| |Lfact| (|List| (|Record| (|:| |factor| (|SparseUnivariatePolynomial| |#3|)) (|:| |exponent| (|Integer|))))) (|:| |ctpol| |#3|)) (|SparseUnivariatePolynomial| |#4|) (|List| |#2|) (|List| (|List| |#3|))) "\\spad{intChoose should} be local")) (|nsqfree| (((|Record| (|:| |unitPart| |#4|) (|:| |suPart| (|List| (|Record| (|:| |factor| (|SparseUnivariatePolynomial| |#4|)) (|:| |exponent| (|Integer|)))))) (|SparseUnivariatePolynomial| |#4|) (|List| |#2|) (|List| (|List| |#3|))) "\\spad{nsqfree should} be local")) (|consnewpol| (((|Record| (|:| |pol| (|SparseUnivariatePolynomial| |#4|)) (|:| |polval| (|SparseUnivariatePolynomial| |#3|))) (|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#3|) (|Integer|)) "\\spad{consnewpol should} be local")) (|univcase| (((|Factored| |#4|) |#4| |#2|) "\\spad{univcase should} be local")) (|compdegd| (((|Integer|) (|List| (|Record| (|:| |factor| (|SparseUnivariatePolynomial| |#3|)) (|:| |exponent| (|Integer|))))) "\\spad{compdegd should} be local")) (|squareFreePrim| (((|Factored| |#4|) |#4|) "\\spad{squareFreePrim(p)} compute the square free decomposition of a primitive multivariate polynomial \\spad{p.}")) (|squareFree| (((|Factored| (|SparseUnivariatePolynomial| |#4|)) (|SparseUnivariatePolynomial| |#4|)) "\\spad{squareFree(p)} computes the square free decomposition of a multivariate polynomial \\spad{p} presented as a univariate polynomial with multivariate coefficients.") (((|Factored| |#4|) |#4|) "\\spad{squareFree(p)} computes the square free decomposition of a multivariate polynomial \\spad{p.}"))) 
NIL 
NIL 
(|MyExpression| |q| R) 
((|constructor| (NIL "This domain has no description"))) 
((|canonicalUnitNormal| |has| |#2| (|IntegralDomain|)) (|canonicalsClosed| |has| |#2| (|IntegralDomain|)) (|unitsKnown| OR (|has| |#2| (|Group|)) (|has| |#2| (|Ring|))) (|leftUnitary| |has| |#2| (|CommutativeRing|)) (|rightUnitary| |has| |#2| (|CommutativeRing|)) ((|commutative| "*") |has| |#2| (|IntegralDomain|)) (|noZeroDivisors| |has| |#2| (|IntegralDomain|))) 
((|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (QUOTE (|Ring|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Group|))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (OR (|HasCategory| |#2| (QUOTE (|Group|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (OR (|HasCategory| |#2| (QUOTE (|Group|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (|HasCategory| |#2| (QUOTE (|AbelianGroup|))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#2| (QUOTE (|SemiGroup|))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (OR (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (OR (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))))) (|HasCategory| $ (QUOTE (|Ring|))) (|HasCategory| $ (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) 
(|MyUnivariatePolynomial| |x| R) 
((|constructor| (NIL "This domain has no description")) (|fmecg| (($ $ (|NonNegativeInteger|) |#2| $) "\\spad{fmecg(p1,e,r,p2)} finds \\spad{x} : \\spad{p1} - \\spad{r} * x**e * \\spad{p2}")) (|coerce| (($ (|Variable| |#1|)) "\\spad{coerce(x)} converts the variable \\spad{x} to a univariate polynomial."))) 
(((|commutative| "*") |has| |#2| (|CommutativeRing|)) (|noZeroDivisors| |has| |#2| (|IntegralDomain|)) (|additiveValuation| |has| |#2| (|Field|)) (|canonicalUnitNormal| |has| |#2| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#2| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Field|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#2| (QUOTE (|StepThrough|))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (OR (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasAttribute| |#2| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))))) 
(|NonAssociativeAlgebra&| S R) 
((|constructor| (NIL "NonAssociativeAlgebra is the category of non associative algebras (modules which are themselves non associative rngs).\\br \\blankline Axioms\\br \\tab{5}r*(a*b) = (r*a)*b = a*(r*b)")) (|plenaryPower| (($ $ (|PositiveInteger|)) "\\spad{plenaryPower(a,n)} is recursively defined to be \\spad{plenaryPower(a,n-1)*plenaryPower(a,n-1)} for \\spad{n>1} and \\spad{a} for \\spad{n=1}."))) 
NIL 
NIL 
(|NonAssociativeAlgebra| R) 
((|constructor| (NIL "NonAssociativeAlgebra is the category of non associative algebras (modules which are themselves non associative rngs).\\br \\blankline Axioms\\br \\tab{5}r*(a*b) = (r*a)*b = a*(r*b)")) (|plenaryPower| (($ $ (|PositiveInteger|)) "\\spad{plenaryPower(a,n)} is recursively defined to be \\spad{plenaryPower(a,n-1)*plenaryPower(a,n-1)} for \\spad{n>1} and \\spad{a} for \\spad{n=1}."))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|NagPolynomialRootsPackage|) 
((|constructor| (NIL "This package uses the NAG Library to compute the zeros of a polynomial with real or complex coefficients.")) (|c02agf| (((|Result|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Boolean|) (|Integer|)) "\\spad{c02agf(a,n,scale,ifail)} finds all the roots of a real polynomial equation, using a variant of Laguerre's Method. See \\downlink{Manual Page}{manpageXXc02agf}.")) (|c02aff| (((|Result|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Boolean|) (|Integer|)) "\\spad{c02aff(a,n,scale,ifail)} finds all the roots of a complex polynomial equation, using a variant of Laguerre's Method. See \\downlink{Manual Page}{manpageXXc02aff}."))) 
NIL 
NIL 
(|NagRootFindingPackage|) 
((|constructor| (NIL "This package uses the NAG Library to calculate real zeros of continuous real functions of one or more variables. (Complex equations must be expressed in terms of the equivalent larger system of real equations.)")) (|c05pbf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp35| FCN)))) "\\spad{c05pbf(n,ldfjac,lwa,x,xtol,ifail,fcn)} is an easy-to-use routine to find a solution of a system of nonlinear equations by a modification of the Powell hybrid method. The user must provide the Jacobian. See \\downlink{Manual Page}{manpageXXc05pbf}.")) (|c05nbf| (((|Result|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp6| FCN)))) "\\spad{c05nbf(n,lwa,x,xtol,ifail,fcn)} is an easy-to-use routine to find a solution of a system of nonlinear equations by a modification of the Powell hybrid method. See \\downlink{Manual Page}{manpageXXc05nbf}.")) (|c05adf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp1| F)))) "\\spad{c05adf(a,b,eps,eta,ifail,f)} locates a zero of a continuous function in a given interval by a combination of the methods of linear interpolation, extrapolation and bisection. See \\downlink{Manual Page}{manpageXXc05adf}."))) 
NIL 
NIL 
(|NagSeriesSummationPackage|) 
((|constructor| (NIL "This package uses the NAG Library to calculate the discrete Fourier transform of a sequence of real or complex data values, and applies it to calculate convolutions and correlations.")) (|c06gsf| (((|Result|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{c06gsf(m,n,x,ifail)} takes \\spad{m} Hermitian sequences, each containing \\spad{n} data values, and forms the real and imaginary parts of the \\spad{m} corresponding complex sequences. See \\downlink{Manual Page}{manpageXXc06gsf}.")) (|c06gqf| (((|Result|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{c06gqf(m,n,x,ifail)} forms the complex conjugates, each containing \\spad{n} data values. See \\downlink{Manual Page}{manpageXXc06gqf}.")) (|c06gcf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{c06gcf(n,y,ifail)} forms the complex conjugate of a sequence of \\spad{n} data values. See \\downlink{Manual Page}{manpageXXc06gcf}.")) (|c06gbf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{c06gbf(n,x,ifail)} forms the complex conjugate of \\spad{n} data values. See \\downlink{Manual Page}{manpageXXc06gbf}.")) (|c06fuf| (((|Result|) (|Integer|) (|Integer|) (|String|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{c06fuf(m,n,init,x,y,trigm,trign,ifail)} computes the two-dimensional discrete Fourier transform of a bivariate sequence of complex data values. This routine is designed to be particularly efficient on vector processors. See \\downlink{Manual Page}{manpageXXc06fuf}.")) (|c06frf| (((|Result|) (|Integer|) (|Integer|) (|String|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{c06frf(m,n,init,x,y,trig,ifail)} computes the discrete Fourier transforms of \\spad{m} sequences, each containing \\spad{n} complex data values. This routine is designed to be particularly efficient on vector processors. See \\downlink{Manual Page}{manpageXXc06frf}.")) (|c06fqf| (((|Result|) (|Integer|) (|Integer|) (|String|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{c06fqf(m,n,init,x,trig,ifail)} computes the discrete Fourier transforms of \\spad{m} Hermitian sequences, each containing \\spad{n} complex data values. This routine is designed to be particularly efficient on vector processors. See \\downlink{Manual Page}{manpageXXc06fqf}.")) (|c06fpf| (((|Result|) (|Integer|) (|Integer|) (|String|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{c06fpf(m,n,init,x,trig,ifail)} computes the discrete Fourier transforms of \\spad{m} sequences, each containing \\spad{n} real data values. This routine is designed to be particularly efficient on vector processors. See \\downlink{Manual Page}{manpageXXc06fpf}.")) (|c06ekf| (((|Result|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{c06ekf(job,n,x,y,ifail)} calculates the circular convolution of two real vectors of period \\spad{n.} No extra workspace is required. See \\downlink{Manual Page}{manpageXXc06ekf}.")) (|c06ecf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{c06ecf(n,x,y,ifail)} calculates the discrete Fourier transform of a sequence of \\spad{n} complex data values. (No extra workspace required.) See \\downlink{Manual Page}{manpageXXc06ecf}.")) (|c06ebf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{c06ebf(n,x,ifail)} calculates the discrete Fourier transform of a Hermitian sequence of \\spad{n} complex data values. (No extra workspace required.) See \\downlink{Manual Page}{manpageXXc06ebf}.")) (|c06eaf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{c06eaf(n,x,ifail)} calculates the discrete Fourier transform of a sequence of \\spad{n} real data values. (No extra workspace required.) See \\downlink{Manual Page}{manpageXXc06eaf}."))) 
NIL 
NIL 
(|NagIntegrationPackage|) 
((|constructor| (NIL "This package uses the NAG Library to calculate the numerical value of definite integrals in one or more dimensions and to evaluate weights and abscissae of integration rules.")) (|d01gbf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp4| FUNCTN)))) "\\spad{d01gbf(ndim,a,b,maxcls,eps,lenwrk,mincls,wrkstr,ifail,functn)} returns an approximation to the integral of a function over a hyper-rectangular region, using a Monte Carlo method. An approximate relative error estimate is also returned. This routine is suitable for low accuracy work. See \\downlink{Manual Page}{manpageXXd01gbf}.")) (|d01gaf| (((|Result|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|)) "\\spad{d01gaf(x,y,n,ifail)} integrates a function which is specified numerically at four or more points, over the whole of its specified range, using third-order finite-difference formulae with error estimates, according to a method due to Gill and Miller. See \\downlink{Manual Page}{manpageXXd01gaf}.")) (|d01fcf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp4| FUNCTN)))) "\\spad{d01fcf(ndim,a,b,maxpts,eps,lenwrk,minpts,ifail,functn)} attempts to evaluate a multi-dimensional integral (up to 15 dimensions), with constant and finite limits, to a specified relative accuracy, using an adaptive subdivision strategy. See \\downlink{Manual Page}{manpageXXd01fcf}.")) (|d01bbf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{d01bbf(a,b,itype,n,gtype,ifail)} returns the weight appropriate to a Gaussian quadrature. The formulae provided are Gauss-Legendre, Gauss-Rational, Gauss- Laguerre and Gauss-Hermite. See \\downlink{Manual Page}{manpageXXd01bbf}.")) (|d01asf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp1| G)))) "\\spad{d01asf(a,omega,key,epsabs,limlst,lw,liw,ifail,g)} calculates an approximation to the sine or the cosine transform of a function \\spad{g} over [a,infty): See \\downlink{Manual Page}{manpageXXd01asf}.")) (|d01aqf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp1| G)))) "\\spad{d01aqf(a,b,c,epsabs,epsrel,lw,liw,ifail,g)} calculates an approximation to the Hilbert transform of a function g(x) over [a,b]: See \\downlink{Manual Page}{manpageXXd01aqf}.")) (|d01apf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp1| G)))) "\\spad{d01apf(a,b,alfa,beta,key,epsabs,epsrel,lw,liw,ifail,g)} is an adaptive integrator which calculates an approximation to the integral of a function g(x)w(x) over a finite interval [a,b]: See \\downlink{Manual Page}{manpageXXd01apf}.")) (|d01anf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp1| G)))) "\\spad{d01anf(a,b,omega,key,epsabs,epsrel,lw,liw,ifail,g)} calculates an approximation to the sine or the cosine transform of a function \\spad{g} over [a,b]: See \\downlink{Manual Page}{manpageXXd01anf}.")) (|d01amf| (((|Result|) (|DoubleFloat|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp1| F)))) "\\spad{d01amf(bound,inf,epsabs,epsrel,lw,liw,ifail,f)} calculates an approximation to the integral of a function f(x) over an infinite or semi-infinite interval [a,b]: See \\downlink{Manual Page}{manpageXXd01amf}.")) (|d01alf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp1| F)))) "\\spad{d01alf(a,b,npts,points,epsabs,epsrel,lw,liw,ifail,f)} is a general purpose integrator which calculates an approximation to the integral of a function f(x) over a finite interval [a,b]: See \\downlink{Manual Page}{manpageXXd01alf}.")) (|d01akf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp1| F)))) "\\spad{d01akf(a,b,epsabs,epsrel,lw,liw,ifail,f)} is an adaptive integrator, especially suited to oscillating, non-singular integrands, which calculates an approximation to the integral of a function f(x) over a finite interval [a,b]: See \\downlink{Manual Page}{manpageXXd01akf}.")) (|d01ajf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp1| F)))) "\\spad{d01ajf(a,b,epsabs,epsrel,lw,liw,ifail,f)} is a general-purpose integrator which calculates an approximation to the integral of a function f(x) over a finite interval [a,b]: See \\downlink{Manual Page}{manpageXXd01ajf}."))) 
NIL 
NIL 
(|NagOrdinaryDifferentialEquationsPackage|) 
((|constructor| (NIL "This package uses the NAG Library to calculate the numerical solution of ordinary differential equations. There are two main types of problem, those in which all boundary conditions are specified at one point (initial-value problems), and those in which the boundary conditions are distributed between two or more points (boundary- value problems and eigenvalue problems). Routines are available for initial-value problems, two-point boundary-value problems and Sturm-Liouville eigenvalue problems.")) (|d02raf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp41| FCN JACOBF JACEPS))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp42| G JACOBG JACGEP)))) "d02raf(n,mnp,numbeg,nummix,tol,init,iy,ijac,lwork, \\indented{7}{liwork,np,x,y,deleps,ifail,fcn,g)} solves the two-point boundary-value problem with general boundary conditions for a system of ordinary differential equations, using a deferred correction technique and Newton iteration. See \\downlink{Manual Page}{manpageXXd02raf}.")) (|d02kef| (((|Result|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|DoubleFloat|) (|Integer|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp10| COEFFN))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp80| BDYVAL))) (|FileName|) (|FileName|)) "d02kef(xpoint,m,k,tol,maxfun,match,elam,delam, \\indented{7}{hmax,maxit,ifail,coeffn,bdyval,monit,report)} finds a specified eigenvalue of a regular singular second- order Sturm-Liouville system on a finite or infinite range, using a Pruefer transformation and a shooting method. It also reports values of the eigenfunction and its derivatives. Provision is made for discontinuities in the coefficient functions or their derivatives. See \\downlink{Manual Page}{manpageXXd02kef}. Files \\spad{monit} and \\spad{report} will be used to define the subroutines for the MONIT and REPORT arguments. See \\downlink{Manual Page}{manpageXXd02gbf}.") (((|Result|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|DoubleFloat|) (|Integer|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp10| COEFFN))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp80| BDYVAL)))) "d02kef(xpoint,m,k,tol,maxfun,match,elam,delam, \\indented{7}{hmax,maxit,ifail,coeffn,bdyval)} finds a specified eigenvalue of a regular singular second- order Sturm-Liouville system on a finite or infinite range, using a Pruefer transformation and a shooting method. It also reports values of the eigenfunction and its derivatives. Provision is made for discontinuities in the coefficient functions or their derivatives. See \\downlink{Manual Page}{manpageXXd02kef}. ASP domains \\spad{Asp12} and \\spad{Asp33} are used to supply default subroutines for the MONIT and REPORT arguments via their \\axiomOp{outputAsFortran} operation.")) (|d02gbf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp77| FCNF))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp78| FCNG)))) "\\spad{d02gbf(a,b,n,tol,mnp,lw,liw,c,d,gam,x,np,ifail,fcnf,fcng)} solves a general linear two-point boundary value problem for a system of ordinary differential equations using a deferred correction technique. See \\downlink{Manual Page}{manpageXXd02gbf}.")) (|d02gaf| (((|Result|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp7| FCN)))) "\\spad{d02gaf(u,v,n,a,b,tol,mnp,lw,liw,x,np,ifail,fcn)} solves the two-point boundary-value problem with assigned boundary values for a system of ordinary differential equations, using a deferred correction technique and a Newton iteration. See \\downlink{Manual Page}{manpageXXd02gaf}.")) (|d02ejf| (((|Result|) (|DoubleFloat|) (|Integer|) (|Integer|) (|String|) (|Integer|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp9| G))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp7| FCN))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp31| PEDERV))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp8| OUTPUT)))) "\\spad{d02ejf(xend,m,n,relabs,iw,x,y,tol,ifail,g,fcn,pederv,output)} integrates a stiff system of first-order ordinary differential equations over an interval with suitable initial conditions, using a variable-order, variable-step method implementing the Backward Differentiation Formulae (BDF), until a user-specified function, if supplied, of the solution is zero, and returns the solution at points specified by the user, if desired. See \\downlink{Manual Page}{manpageXXd02ejf}.")) (|d02cjf| (((|Result|) (|DoubleFloat|) (|Integer|) (|Integer|) (|DoubleFloat|) (|String|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp9| G))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp7| FCN))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp8| OUTPUT)))) "\\spad{d02cjf(xend,m,n,tol,relabs,x,y,ifail,g,fcn,output)} integrates a system of first-order ordinary differential equations over a range with suitable initial conditions, using a variable-order, variable-step Adams method until a user-specified function, if supplied, of the solution is zero, and returns the solution at points specified by the user, if desired. See \\downlink{Manual Page}{manpageXXd02cjf}.")) (|d02bhf| (((|Result|) (|DoubleFloat|) (|Integer|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp9| G))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp7| FCN)))) "\\spad{d02bhf(xend,n,irelab,hmax,x,y,tol,ifail,g,fcn)} integrates a system of first-order ordinary differential equations over an interval with suitable initial conditions, using a Runge-Kutta-Merson method, until a user-specified function of the solution is zero. See \\downlink{Manual Page}{manpageXXd02bhf}.")) (|d02bbf| (((|Result|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp7| FCN))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp8| OUTPUT)))) "\\spad{d02bbf(xend,m,n,irelab,x,y,tol,ifail,fcn,output)} integrates a system of first-order ordinary differential equations over an interval with suitable initial conditions, using a Runge-Kutta-Merson method, and returns the solution at points specified by the user. See \\downlink{Manual Page}{manpageXXd02bbf}."))) 
NIL 
NIL 
(|NagPartialDifferentialEquationsPackage|) 
((|constructor| (NIL "This package uses the NAG Library to solve partial differential equations.")) (|d03faf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|ThreeDimensionalMatrix| (|DoubleFloat|)) (|Integer|)) "d03faf(xs,xf,l,lbdcnd,bdxs,bdxf,ys,yf,m,mbdcnd,bdys,bdyf,zs, \\indented{7}{zf,n,nbdcnd,bdzs,bdzf,lambda,ldimf,mdimf,lwrk,f,ifail)} solves the Helmholtz equation in Cartesian co-ordinates in three dimensions using the standard seven-point finite difference approximation. This routine is designed to be particularly efficient on vector processors. See \\downlink{Manual Page}{manpageXXd03faf}.")) (|d03eef| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|String|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp73| PDEF))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp74| BNDY)))) "\\spad{d03eef(xmin,xmax,ymin,ymax,ngx,ngy,lda,scheme,ifail,pdef,bndy)} discretizes a second order elliptic partial differential equation (PDE) on a rectangular region. See \\downlink{Manual Page}{manpageXXd03eef}.")) (|d03edf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|DoubleFloat|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{d03edf(ngx,ngy,lda,maxit,acc,iout,a,rhs,ub,ifail)} solves seven-diagonal systems of linear equations which arise from the discretization of an elliptic partial differential equation on a rectangular region. This routine uses a multigrid technique. See \\downlink{Manual Page}{manpageXXd03edf}."))) 
NIL 
NIL 
(|NagInterpolationPackage|) 
((|constructor| (NIL "This package uses the NAG Library to calculate the interpolation of a function of one or two variables. When provided with the value of the function (and possibly one or more of its lowest-order derivatives) at each of a number of values of the variable(s), the routines provide either an interpolating function or an interpolated value. For some of the interpolating functions, there are supporting routines to evaluate, differentiate or integrate them.")) (|e01sff| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|) (|Integer|)) "\\spad{e01sff(m,x,y,f,rnw,fnodes,px,py,ifail)} evaluates at a given point the two-dimensional interpolating function computed by E01SEF. See \\downlink{Manual Page}{manpageXXe01sff}.")) (|e01sef| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|)) "\\spad{e01sef(m,x,y,f,nw,nq,rnw,rnq,ifail)} generates a two-dimensional surface interpolating a set of scattered data points, using a modified Shepard method. See \\downlink{Manual Page}{manpageXXe01sef}.")) (|e01sbf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|Integer|)) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|) (|Integer|)) "\\spad{e01sbf(m,x,y,f,triang,grads,px,py,ifail)} evaluates at a given point the two-dimensional interpolant function computed by E01SAF. See \\downlink{Manual Page}{manpageXXe01sbf}.")) (|e01saf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{e01saf(m,x,y,f,ifail)} generates a two-dimensional surface interpolating a set of scattered data points, using the method of Renka and Cline. See \\downlink{Manual Page}{manpageXXe01saf}.")) (|e01daf| (((|Result|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{e01daf(mx,my,x,y,f,ifail)} computes a bicubic spline interpolating surface through a set of data values, given on a rectangular grid in the x-y plane. See \\downlink{Manual Page}{manpageXXe01daf}.")) (|e01bhf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|) (|Integer|)) "\\spad{e01bhf(n,x,f,d,a,b,ifail)} evaluates the definite integral of a piecewise cubic Hermite interpolant over the interval [a,b]. See \\downlink{Manual Page}{manpageXXe01bhf}.")) (|e01bgf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{e01bgf(n,x,f,d,m,px,ifail)} evaluates a piecewise cubic Hermite interpolant and its first derivative at a set of points. See \\downlink{Manual Page}{manpageXXe01bgf}.")) (|e01bff| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{e01bff(n,x,f,d,m,px,ifail)} evaluates a piecewise cubic Hermite interpolant at a set of points. See \\downlink{Manual Page}{manpageXXe01bff}.")) (|e01bef| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{e01bef(n,x,f,ifail)} computes a monotonicity-preserving piecewise cubic Hermite interpolant to a set of data points. See \\downlink{Manual Page}{manpageXXe01bef}.")) (|e01baf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Integer|)) "\\spad{e01baf(m,x,y,lck,lwrk,ifail)} determines a cubic spline to a given set of data. See \\downlink{Manual Page}{manpageXXe01baf}."))) 
NIL 
NIL 
(|NagFittingPackage|) 
((|constructor| (NIL "This package uses the NAG Library to find a function which approximates a set of data points. Typically the data contain random errors, as of experimental measurement, which need to be smoothed out. To seek an approximation to the data, it is first necessary to specify for the approximating function a mathematical form (a polynomial, for example) which contains a number of unspecified coefficients: the appropriate fitting routine then derives for the coefficients the values which provide the best fit of that particular form. The package deals mainly with curve and surface fitting (\\spadignore{i.e.} fitting with functions of one and of two variables) when a polynomial or a cubic spline is used as the fitting function, since these cover the most common needs. However, fitting with other functions and/or more variables can be undertaken by means of general linear or nonlinear routines (some of which are contained in other packages) depending on whether the coefficients in the function occur linearly or nonlinearly. Cases where a graph rather than a set of data points is given can be treated simply by first reading a suitable set of points from the graph. The package also contains routines for evaluating, differentiating and integrating polynomial and spline curves and surfaces, once the numerical values of their coefficients have been determined.")) (|e02zaf| (((|Result|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Integer|)) "\\spad{e02zaf(px,py,lamda,mu,m,x,y,npoint,nadres,ifail)} sorts two-dimensional data into rectangular panels. See \\downlink{Manual Page}{manpageXXe02zaf}.")) (|e02gaf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{e02gaf(m,la,nplus2,toler,a,b,ifail)} calculates an \\spad{l} solution to an over-determined system of linear equations. See \\downlink{Manual Page}{manpageXXe02gaf}.")) (|e02dff| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Integer|)) "\\spad{e02dff(mx,my,px,py,x,y,lamda,mu,c,lwrk,liwrk,ifail)} calculates values of a bicubic spline representation. The spline is evaluated at all points on a rectangular grid. See \\downlink{Manual Page}{manpageXXe02dff}.")) (|e02def| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{e02def(m,px,py,x,y,lamda,mu,c,ifail)} calculates values of a bicubic spline representation. See \\downlink{Manual Page}{manpageXXe02def}.")) (|e02ddf| (((|Result|) (|String|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{e02ddf(start,m,x,y,f,w,s,nxest,nyest,lwrk,liwrk,nx, \\spad{++} lamda,ny,mu,wrk,ifail)} computes a bicubic spline approximation to a set of scattered data are located automatically, but a single parameter must be specified to control the trade-off between closeness of fit and smoothness of fit. See \\downlink{Manual Page}{manpageXXe02ddf}.")) (|e02dcf| (((|Result|) (|String|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|Integer|)) (|Integer|)) "\\spad{e02dcf(start,mx,x,my,y,f,s,nxest,nyest,lwrk,liwrk,nx, \\spad{++} lamda,ny,mu,wrk,iwrk,ifail)} computes a bicubic spline approximation to a set of data values, given on a rectangular grid in the x-y plane. The knots of the spline are located automatically, but a single parameter must be specified to control the trade-off between closeness of fit and smoothness of fit. See \\downlink{Manual Page}{manpageXXe02dcf}.")) (|e02daf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|Integer|)) (|Integer|) (|Integer|) (|Integer|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{e02daf(m,px,py,x,y,f,w,mu,point,npoint,nc,nws,eps,lamda,ifail)} forms a minimal, weighted least-squares bicubic spline surface fit with prescribed knots to a given set of data points. See \\downlink{Manual Page}{manpageXXe02daf}.")) (|e02bef| (((|Result|) (|String|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|Integer|))) "\\spad{e02bef(start,m,x,y,w,s,nest,lwrk,n,lamda,ifail,wrk,iwrk)} computes a cubic spline approximation to an arbitrary set of data points. The knot are located automatically, but a single parameter must be specified to control the trade-off between closeness of fit and smoothness of fit. See \\downlink{Manual Page}{manpageXXe02bef}.")) (|e02bdf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{e02bdf(ncap7,lamda,c,ifail)} computes the definite integral from its B-spline representation. See \\downlink{Manual Page}{manpageXXe02bdf}.")) (|e02bcf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|) (|Integer|)) "\\spad{e02bcf(ncap7,lamda,c,x,left,ifail)} evaluates a cubic spline and its first three derivatives from its B-spline representation. See \\downlink{Manual Page}{manpageXXe02bcf}.")) (|e02bbf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|)) "\\spad{e02bbf(ncap7,lamda,c,x,ifail)} evaluates a cubic spline representation. See \\downlink{Manual Page}{manpageXXe02bbf}.")) (|e02baf| (((|Result|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{e02baf(m,ncap7,x,y,w,lamda,ifail)} computes a weighted least-squares approximation to an arbitrary set of data points by a cubic splines prescribed by the user. Cubic spline can also be carried out. See \\downlink{Manual Page}{manpageXXe02baf}.")) (|e02akf| (((|Result|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|DoubleFloat|) (|Integer|)) "\\spad{e02akf(np1,xmin,xmax,a,ia1,la,x,ifail)} evaluates a polynomial from its Chebyshev-series representation, allowing an arbitrary index increment for accessing the array of coefficients. See \\downlink{Manual Page}{manpageXXe02akf}.")) (|e02ajf| (((|Result|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{e02ajf(np1,xmin,xmax,a,ia1,la,qatm1,iaint1,laint,ifail)} determines the coefficients in the Chebyshev-series representation of the indefinite integral of a polynomial given in Chebyshev-series form. See \\downlink{Manual Page}{manpageXXe02ajf}.")) (|e02ahf| (((|Result|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{e02ahf(np1,xmin,xmax,a,ia1,la,iadif1,ladif,ifail)} determines the coefficients in the Chebyshev-series representation of the derivative of a polynomial given in Chebyshev-series form. See \\downlink{Manual Page}{manpageXXe02ahf}.")) (|e02agf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|Integer|)) (|Integer|) (|Integer|) (|Integer|)) "\\spad{e02agf(m,kplus1,nrows,xmin,xmax,x,y,w,mf,xf,yf,lyf,ip,lwrk,liwrk,ifail)} computes constrained weighted least-squares polynomial approximations in Chebyshev-series form to an arbitrary set of data points. The values of the approximations and any number of their derivatives can be specified at selected points. See \\downlink{Manual Page}{manpageXXe02agf}.")) (|e02aef| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|DoubleFloat|) (|Integer|)) "\\spad{e02aef(nplus1,a,xcap,ifail)} evaluates a polynomial from its Chebyshev-series representation. See \\downlink{Manual Page}{manpageXXe02aef}.")) (|e02adf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{e02adf(m,kplus1,nrows,x,y,w,ifail)} computes weighted least-squares polynomial approximations to an arbitrary set of data points. See \\downlink{Manual Page}{manpageXXe02adf}."))) 
NIL 
NIL 
(|NagOptimisationPackage|) 
((|constructor| (NIL "This package uses the NAG Library to perform optimization. An optimization problem involves minimizing a function (called the objective function) of several variables, possibly subject to restrictions on the values of the variables defined by a set of constraint functions. The routines in the NAG Foundation Library are concerned with function minimization only, since the problem of maximizing a given function can be transformed into a minimization problem simply by multiplying the function by \\spad{-1.}")) (|e04ycf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{e04ycf(job,m,n,fsumsq,s,lv,v,ifail)} returns estimates of elements of the variance matrix of the estimated regression coefficients for a nonlinear least squares problem. The estimates are derived from the Jacobian of the function f(x) at the solution. See \\downlink{Manual Page}{manpageXXe04ycf}.")) (|e04ucf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Boolean|) (|DoubleFloat|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Boolean|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Boolean|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|Integer|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp55| CONFUN))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp49| OBJFUN)))) "e04ucf(n,nclin,ncnln,nrowa,nrowj,nrowr,a,bl,bu,liwork,lwork,sta, \\indented{7}{cra,der,fea,fun,hes,infb,infs,linf,lint,list,maji,majp,mini,} \\indented{7}{minp,mon,nonf,opt,ste,stao,stac,stoo,stoc,ve,istate,cjac,} \\indented{7}{clamda,r,x,ifail,confun,objfun)} is designed to minimize an arbitrary smooth function subject to constraints on the variables, linear constraints. (E04UCF may be used for unconstrained, bound-constrained and linearly constrained optimization.) The user must provide subroutines that define the objective and constraint functions and as many of their first partial derivatives as possible. Unspecified derivatives are approximated by finite differences. All matrices are treated as dense, and hence E04UCF is not intended for large sparse problems. See \\downlink{Manual Page}{manpageXXe04ucf}.")) (|e04naf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|DoubleFloat|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Boolean|) (|Boolean|) (|Boolean|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|Integer|)) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp20| QPHESS)))) "e04naf(itmax,msglvl,n,nclin,nctotl,nrowa,nrowh,ncolh,bigbnd,a,bl, bu,cvec,featol,hess,cold,lpp,orthog,liwork,lwork,x,istate,ifail,qphess) is a comprehensive programming (QP) or linear programming (LP) problems. It is not intended for large sparse problems. See \\downlink{Manual Page}{manpageXXe04naf}.")) (|e04mbf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Boolean|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "e04mbf(itmax,msglvl,n,nclin,nctotl,nrowa,a,bl,bu, \\indented{7}{cvec,linobj,liwork,lwork,x,ifail)} is an easy-to-use routine for solving linear programming problems, or for finding a feasible point for such problems. It is not intended for large sparse problems. See \\downlink{Manual Page}{manpageXXe04mbf}.")) (|e04jaf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp24| FUNCT1)))) "\\spad{e04jaf(n,ibound,liw,lw,bl,bu,x,ifail,funct1)} is an easy-to-use quasi-Newton algorithm for finding a minimum of a function \\spad{F(x} \\spad{,x} ,...,x \\spad{),} subject to fixed upper and \\indented{25}{1\\space{2}2\\space{6}n} lower bounds of the independent variables \\spad{x} \\spad{,x} ,...,x ,{} using \\indented{43}{1\\space{2}2\\space{6}n} function values only. See \\downlink{Manual Page}{manpageXXe04jaf}.")) (|e04gcf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp19| LSFUN2)))) "\\spad{e04gcf(m,n,liw,lw,x,ifail,lsfun2)} is an easy-to-use quasi-Newton algorithm for finding an unconstrained minimum of \\spad{m} nonlinear functions in \\spad{n} variables (m>=n). First derivatives are required. See \\downlink{Manual Page}{manpageXXe04gcf}.")) (|e04fdf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp50| LSFUN1)))) "\\spad{e04fdf(m,n,liw,lw,x,ifail,lsfun1)} is an easy-to-use algorithm for finding an unconstrained minimum of a sum of squares of \\spad{m} nonlinear functions in \\spad{n} variables (m>=n). No derivatives are required. See \\downlink{Manual Page}{manpageXXe04fdf}.")) (|e04dgf| (((|Result|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|DoubleFloat|) (|Boolean|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp49| OBJFUN)))) "\\spad{e04dgf(n,es,fu,it,lin,list,ma,op,pr,sta,sto,ve,x,ifail,objfun)} minimizes an unconstrained nonlinear function of several variables using a pre-conditioned, limited memory quasi-Newton conjugate gradient method. First derivatives are required. The routine is intended for use on large scale problems. See \\downlink{Manual Page}{manpageXXe04dgf}."))) 
NIL 
NIL 
(|NagMatrixOperationsPackage|) 
((|constructor| (NIL "This package uses the NAG Library to provide facilities for matrix factorizations and associated transformations.")) (|f01ref| (((|Result|) (|String|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|Complex| (|DoubleFloat|))) (|Matrix| (|Complex| (|DoubleFloat|))) (|Integer|)) "\\spad{f01ref(wheret,m,n,ncolq,lda,theta,a,ifail)} returns the first \\spad{ncolq} columns of the complex \\spad{m} by \\spad{m} unitary matrix \\spad{Q,} where \\spad{Q} is given as the product of Householder transformation matrices. See \\downlink{Manual Page}{manpageXXf01ref}.")) (|f01rdf| (((|Result|) (|String|) (|String|) (|Integer|) (|Integer|) (|Matrix| (|Complex| (|DoubleFloat|))) (|Integer|) (|Matrix| (|Complex| (|DoubleFloat|))) (|Integer|) (|Integer|) (|Matrix| (|Complex| (|DoubleFloat|))) (|Integer|)) "\\spad{f01rdf(trans,wheret,m,n,a,lda,theta,ncolb,ldb,b,ifail)} performs one of the transformations See \\downlink{Manual Page}{manpageXXf01rdf}.")) (|f01rcf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|Complex| (|DoubleFloat|))) (|Integer|)) "\\spad{f01rcf(m,n,lda,a,ifail)} finds the \\spad{QR} factorization of the complex \\spad{m} by \\spad{n} matrix A, where m>=n. See \\downlink{Manual Page}{manpageXXf01rcf}.")) (|f01qef| (((|Result|) (|String|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f01qef(wheret,m,n,ncolq,lda,zeta,a,ifail)} returns the first \\spad{ncolq} columns of the real \\spad{m} by \\spad{m} orthogonal matrix \\spad{Q,} where \\spad{Q} is given as the product of Householder transformation matrices. See \\downlink{Manual Page}{manpageXXf01qef}.")) (|f01qdf| (((|Result|) (|String|) (|String|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f01qdf(trans,wheret,m,n,a,lda,zeta,ncolb,ldb,b,ifail)} performs one of the transformations See \\downlink{Manual Page}{manpageXXf01qdf}.")) (|f01qcf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f01qcf(m,n,lda,a,ifail)} finds the \\spad{QR} factorization of the real \\spad{m} by \\spad{n} matrix A, where m>=n. See \\downlink{Manual Page}{manpageXXf01qcf}.")) (|f01mcf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|Integer|)) (|Integer|)) "\\spad{f01mcf(n,avals,lal,nrow,ifail)} computes the Cholesky factorization of a real symmetric positive-definite variable-bandwidth matrix. See \\downlink{Manual Page}{manpageXXf01mcf}.")) (|f01maf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|List| (|Boolean|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|Integer|)) (|Matrix| (|Integer|)) (|DoubleFloat|) (|DoubleFloat|) (|Integer|)) "\\spad{f01maf(n,nz,licn,lirn,abort,avals,irn,icn,droptl,densw,ifail)} computes an incomplete Cholesky factorization of a real sparse symmetric positive-definite matrix A. See \\downlink{Manual Page}{manpageXXf01maf}.")) (|f01bsf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|Integer|)) (|Matrix| (|Integer|)) (|Matrix| (|Integer|)) (|Matrix| (|Integer|)) (|Boolean|) (|DoubleFloat|) (|Boolean|) (|Matrix| (|Integer|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "f01bsf(n,nz,licn,ivect,jvect,icn,ikeep,grow, \\indented{7}{eta,abort,idisp,avals,ifail)} factorizes a real sparse matrix using the pivotal sequence previously obtained by F01BRF when a matrix of the same sparsity pattern was factorized. See \\downlink{Manual Page}{manpageXXf01bsf}.")) (|f01brf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|DoubleFloat|) (|Boolean|) (|Boolean|) (|List| (|Boolean|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|Integer|)) (|Matrix| (|Integer|)) (|Integer|)) "\\spad{f01brf(n,nz,licn,lirn,pivot,lblock,grow,abort,a,irn,icn,ifail)} factorizes a real sparse matrix. The routine either forms the LU factorization of a permutation of the entire matrix, or, optionally, first permutes the matrix to block lower triangular form and then only factorizes the diagonal blocks. See \\downlink{Manual Page}{manpageXXf01brf}."))) 
NIL 
NIL 
(|NagEigenPackage|) 
((|constructor| (NIL "This package uses the NAG Library to compute\\br \\tab{5}eigenvalues and eigenvectors of a matrix\\br \\tab{5} eigenvalues and eigenvectors of generalized matrix eigenvalue problems\\br \\tab{5}singular values and singular vectors of a matrix.")) (|f02xef| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Boolean|) (|Integer|) (|Boolean|) (|Integer|) (|Matrix| (|Complex| (|DoubleFloat|))) (|Matrix| (|Complex| (|DoubleFloat|))) (|Integer|)) "\\spad{f02xef(m,n,lda,ncolb,ldb,wantq,ldq,wantp,ldph,a,b,ifail)} returns all, or part, of the singular value decomposition of a general complex matrix. See \\downlink{Manual Page}{manpageXXf02xef}.")) (|f02wef| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Boolean|) (|Integer|) (|Boolean|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f02wef(m,n,lda,ncolb,ldb,wantq,ldq,wantp,ldpt,a,b,ifail)} returns all, or part, of the singular value decomposition of a general real matrix. See \\downlink{Manual Page}{manpageXXf02wef}.")) (|f02fjf| (((|Result|) (|Integer|) (|Integer|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp27| DOT))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp28| IMAGE))) (|FileName|)) "f02fjf(n,k,tol,novecs,nrx,lwork,lrwork, \\indented{7}{liwork,m,noits,x,ifail,dot,image,monit)} finds eigenvalues of a real sparse symmetric or generalized symmetric eigenvalue problem. See \\downlink{Manual Page}{manpageXXf02fjf}.") (((|Result|) (|Integer|) (|Integer|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp27| DOT))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp28| IMAGE)))) "f02fjf(n,k,tol,novecs,nrx,lwork,lrwork, \\indented{7}{liwork,m,noits,x,ifail,dot,image)} finds eigenvalues of a real sparse symmetric or generalized symmetric eigenvalue problem. See \\downlink{Manual Page}{manpageXXf02fjf}.")) (|f02bjf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|DoubleFloat|) (|Boolean|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f02bjf(n,ia,ib,eps1,matv,iv,a,b,ifail)} calculates all the eigenvalues and, if required, all the eigenvectors of the generalized eigenproblem Ax=(lambda)Bx where A and \\spad{B} are real, square matrices, using the \\spad{QZ} algorithm. See \\downlink{Manual Page}{manpageXXf02bjf}.")) (|f02bbf| (((|Result|) (|Integer|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f02bbf(ia,n,alb,ub,m,iv,a,ifail)} calculates selected eigenvalues of a real symmetric matrix by reduction to tridiagonal form, bisection and inverse iteration, where the selected eigenvalues lie within a given interval. See \\downlink{Manual Page}{manpageXXf02bbf}.")) (|f02axf| (((|Result|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{f02axf(ar,iar,ai,iai,n,ivr,ivi,ifail)} calculates all the eigenvalues of a complex Hermitian matrix. See \\downlink{Manual Page}{manpageXXf02axf}.")) (|f02awf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f02awf(iar,iai,n,ar,ai,ifail)} calculates all the eigenvalues of a complex Hermitian matrix. See \\downlink{Manual Page}{manpageXXf02awf}.")) (|f02akf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f02akf(iar,iai,n,ivr,ivi,ar,ai,ifail)} calculates all the eigenvalues of a complex matrix. See \\downlink{Manual Page}{manpageXXf02akf}.")) (|f02ajf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f02ajf(iar,iai,n,ar,ai,ifail)} calculates all the eigenvalue. See \\downlink{Manual Page}{manpageXXf02ajf}.")) (|f02agf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f02agf(ia,n,ivr,ivi,a,ifail)} calculates all the eigenvalues of a real unsymmetric matrix. See \\downlink{Manual Page}{manpageXXf02agf}.")) (|f02aff| (((|Result|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f02aff(ia,n,a,ifail)} calculates all the eigenvalues of a real unsymmetric matrix. See \\downlink{Manual Page}{manpageXXf02aff}.")) (|f02aef| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f02aef(ia,ib,n,iv,a,b,ifail)} calculates all the eigenvalues of Ax=(lambda)Bx, where A is a real symmetric matrix and \\spad{B} is a real symmetric positive-definite matrix. See \\downlink{Manual Page}{manpageXXf02aef}.")) (|f02adf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f02adf(ia,ib,n,a,b,ifail)} calculates all the eigenvalues of Ax=(lambda)Bx, where A is a real symmetric matrix and \\spad{B} is a real symmetric positive- definite matrix. See \\downlink{Manual Page}{manpageXXf02adf}.")) (|f02abf| (((|Result|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{f02abf(a,ia,n,iv,ifail)} calculates all the eigenvalues of a real symmetric matrix. See \\downlink{Manual Page}{manpageXXf02abf}.")) (|f02aaf| (((|Result|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f02aaf(ia,n,a,ifail)} calculates all the eigenvalue. See \\downlink{Manual Page}{manpageXXf02aaf}."))) 
NIL 
NIL 
(|NagLinearEquationSolvingPackage|) 
((|constructor| (NIL "This package uses the NAG Library to solve the matrix equation \\spad{\\br} \\tab{5}\\axiom{AX=B}, where \\axiom{B}\\br may be a single vector or a matrix of multiple right-hand sides. The matrix \\axiom{A} may be real, complex, symmetric, Hermitian positive- definite, or sparse. It may also be rectangular, in which case a least-squares solution is obtained.")) (|f04qaf| (((|Result|) (|Integer|) (|Integer|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp30| APROD)))) "f04qaf(m,n,damp,atol,btol,conlim,itnlim,msglvl, \\indented{7}{lrwork,liwork,b,ifail,aprod)} solves sparse unsymmetric equations, sparse linear least- squares problems and sparse damped linear least-squares problems, using a Lanczos algorithm. See \\downlink{Manual Page}{manpageXXf04qaf}.")) (|f04mcf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|Integer|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{f04mcf(n,al,lal,d,nrow,ir,b,nrb,iselct,nrx,ifail)} computes the approximate solution of a system of real linear equations with multiple right-hand sides, AX=B, where A is a symmetric positive-definite variable-bandwidth matrix, which has previously been factorized by F01MCF. Related systems may also be solved. See \\downlink{Manual Page}{manpageXXf04mcf}.")) (|f04mbf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Boolean|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|DoubleFloat|) (|Integer|) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp28| APROD))) (|Union| (|:| |fn| (|FileName|)) (|:| |fp| (|Asp34| MSOLVE)))) "\\spad{f04mbf(n,b,precon,shift,itnlim,msglvl,lrwork, \\spad{++} liwork,rtol,ifail,aprod,msolve)} solves a system of real sparse symmetric linear equations using a Lanczos algorithm. See \\downlink{Manual Page}{manpageXXf04mbf}.")) (|f04maf| (((|Result|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|Integer|)) (|Integer|) (|Matrix| (|Integer|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|Integer|)) (|Matrix| (|Integer|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|Integer|)) (|Integer|)) "f04maf(n,nz,avals,licn,irn,lirn,icn,wkeep,ikeep, \\indented{7}{inform,b,acc,noits,ifail)} \\spad{e} a sparse symmetric positive-definite system of linear equations, Ax=b, using a pre-conditioned conjugate gradient method, where A has been factorized by F01MAF. See \\downlink{Manual Page}{manpageXXf04maf}.")) (|f04jgf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|DoubleFloat|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f04jgf(m,n,nra,tol,lwork,a,b,ifail)} finds the solution of a linear least-squares problem, Ax=b ,{} where A is a real \\spad{m} by \\spad{n} (m>=n) matrix and \\spad{b} is an \\spad{m} element vector. If the matrix of observations is not of full rank, then the minimal least-squares solution is returned. See \\downlink{Manual Page}{manpageXXf04jgf}.")) (|f04faf| (((|Result|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f04faf(job,n,d,e,b,ifail)} calculates the approximate solution of a set of real symmetric positive-definite tridiagonal linear equations. See \\downlink{Manual Page}{manpageXXf04faf}.")) (|f04axf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|Integer|)) (|Matrix| (|Integer|)) (|Integer|) (|Matrix| (|Integer|)) (|Matrix| (|DoubleFloat|))) "\\spad{f04axf(n,a,licn,icn,ikeep,mtype,idisp,rhs)} calculates the approximate solution of a set of real sparse linear equations with a single right-hand side, Ax=b or \\indented{1}{T} A x=b, where A has been factorized by F01BRF or F01BSF. See \\downlink{Manual Page}{manpageXXf04axf}.")) (|f04atf| (((|Result|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Integer|)) "\\spad{f04atf(a,ia,b,n,iaa,ifail)} calculates the accurate solution of a set of real linear equations with a single right-hand side, using an LU factorization with partial pivoting, and iterative refinement. See \\downlink{Manual Page}{manpageXXf04atf}.")) (|f04asf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f04asf(ia,b,n,a,ifail)} calculates the accurate solution of a set of real symmetric positive-definite linear equations with a single right- hand side, Ax=b, using a Cholesky factorization and iterative refinement. See \\downlink{Manual Page}{manpageXXf04asf}.")) (|f04arf| (((|Result|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|)) "\\spad{f04arf(ia,b,n,a,ifail)} calculates the approximate solution of a set of real linear equations with a single right-hand side, using an LU factorization with partial pivoting. See \\downlink{Manual Page}{manpageXXf04arf}.")) (|f04adf| (((|Result|) (|Integer|) (|Matrix| (|Complex| (|DoubleFloat|))) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|Complex| (|DoubleFloat|))) (|Integer|)) "\\spad{f04adf(ia,b,ib,n,m,ic,a,ifail)} calculates the approximate solution of a set of complex linear equations with multiple right-hand sides, using an LU factorization with partial pivoting. See \\downlink{Manual Page}{manpageXXf04adf}."))) 
NIL 
NIL 
(|NagLapack|) 
((|constructor| (NIL "This package uses the NAG Library to compute matrix factorizations, and to solve systems of linear equations following the matrix factorizations.")) (|f07fef| (((|Result|) (|String|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|))) "\\spad{f07fef(uplo,n,nrhs,a,lda,ldb,b)} (DPOTRS) solves a real symmetric positive-definite system of linear equations with multiple right-hand sides, AX=B, where A has been factorized by F07FDF (DPOTRF). See \\downlink{Manual Page}{manpageXXf07fef}.")) (|f07fdf| (((|Result|) (|String|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|))) "\\spad{f07fdf(uplo,n,lda,a)} (DPOTRF) computes the Cholesky factorization of a real symmetric positive-definite matrix. See \\downlink{Manual Page}{manpageXXf07fdf}.")) (|f07aef| (((|Result|) (|String|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|)) (|Integer|) (|Matrix| (|Integer|)) (|Integer|) (|Matrix| (|DoubleFloat|))) "\\spad{f07aef(trans,n,nrhs,a,lda,ipiv,ldb,b)} (DGETRS) solves a real system of linear equations with \\indented{36}{T} multiple right-hand sides, AX=B or A X=B, where A has been factorized by F07ADF (DGETRF). See \\downlink{Manual Page}{manpageXXf07aef}.")) (|f07adf| (((|Result|) (|Integer|) (|Integer|) (|Integer|) (|Matrix| (|DoubleFloat|))) "\\spad{f07adf(m,n,lda,a)} (DGETRF) computes the LU factorization of a real \\spad{m} by \\spad{n} matrix. See \\downlink{Manual Page}{manpageXXf07adf}."))) 
NIL 
NIL 
(|NagSpecialFunctionsPackage|) 
((|constructor| (NIL "This package uses the NAG Library to compute some commonly occurring physical and mathematical functions.")) (|s21bdf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|)) "\\spad{s21bdf(x,y,z,r,ifail)} returns a value of the symmetrised elliptic integral of the third kind, via the routine name. See \\downlink{Manual Page}{manpageXXs21bdf}.")) (|s21bcf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|)) "\\spad{s21bcf(x,y,z,ifail)} returns a value of the symmetrised elliptic integral of the second kind, via the routine name. See \\downlink{Manual Page}{manpageXXs21bcf}.")) (|s21bbf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|)) "\\spad{s21bbf(x,y,z,ifail)} returns a value of the symmetrised elliptic integral of the first kind, via the routine name. See \\downlink{Manual Page}{manpageXXs21bbf}.")) (|s21baf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|)) "\\spad{s21baf(x,y,ifail)} returns a value of an elementary integral, which occurs as a degenerate case of an elliptic integral of the first kind, via the routine name. See \\downlink{Manual Page}{manpageXXs21baf}.")) (|s20adf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s20adf(x,ifail)} returns a value for the Fresnel Integral C(x), via the routine name. See \\downlink{Manual Page}{manpageXXs20adf}.")) (|s20acf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s20acf(x,ifail)} returns a value for the Fresnel Integral S(x), via the routine name. See \\downlink{Manual Page}{manpageXXs20acf}.")) (|s19adf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s19adf(x,ifail)} returns a value for the Kelvin function kei(x) via the routine name. See \\downlink{Manual Page}{manpageXXs19adf}.")) (|s19acf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s19acf(x,ifail)} returns a value for the Kelvin function ker(x), via the routine name. See \\downlink{Manual Page}{manpageXXs19acf}.")) (|s19abf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s19abf(x,ifail)} returns a value for the Kelvin function bei(x) via the routine name. See \\downlink{Manual Page}{manpageXXs19abf}.")) (|s19aaf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s19aaf(x,ifail)} returns a value for the Kelvin function ber(x) via the routine name. See \\downlink{Manual Page}{manpageXXs19aaf}.")) (|s18def| (((|Result|) (|DoubleFloat|) (|Complex| (|DoubleFloat|)) (|Integer|) (|String|) (|Integer|)) "\\spad{s18def(fnu,z,n,scale,ifail)} returns a sequence of values for the modified Bessel functions \\indented{1}{I\\space{6}(z) for complex \\spad{z,} non-negative (nu) and} \\indented{2}{(nu)+n} n=0,1,...,N-1, with an option for exponential scaling. See \\downlink{Manual Page}{manpageXXs18def}.")) (|s18dcf| (((|Result|) (|DoubleFloat|) (|Complex| (|DoubleFloat|)) (|Integer|) (|String|) (|Integer|)) "\\spad{s18dcf(fnu,z,n,scale,ifail)} returns a sequence of values for the modified Bessel functions \\indented{1}{K\\space{6}(z) for complex \\spad{z,} non-negative (nu) and} \\indented{2}{(nu)+n} n=0,1,...,N-1, with an option for exponential scaling. See \\downlink{Manual Page}{manpageXXs18dcf}.")) (|s18aff| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s18aff(x,ifail)} returns a value for the modified Bessel Function \\indented{1}{I (x), via the routine name.} \\indented{2}{1} See \\downlink{Manual Page}{manpageXXs18aff}.")) (|s18aef| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s18aef(x,ifail)} returns the value of the modified Bessel Function \\indented{1}{I (x), via the routine name.} \\indented{2}{0} See \\downlink{Manual Page}{manpageXXs18aef}.")) (|s18adf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s18adf(x,ifail)} returns the value of the modified Bessel Function \\indented{1}{K (x), via the routine name.} \\indented{2}{1} See \\downlink{Manual Page}{manpageXXs18adf}.")) (|s18acf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s18acf(x,ifail)} returns the value of the modified Bessel Function \\indented{1}{K (x), via the routine name.} \\indented{2}{0} See \\downlink{Manual Page}{manpageXXs18acf}.")) (|s17dlf| (((|Result|) (|Integer|) (|DoubleFloat|) (|Complex| (|DoubleFloat|)) (|Integer|) (|String|) (|Integer|)) "\\spad{s17dlf(m,fnu,z,n,scale,ifail)} returns a sequence of values for the Hankel functions \\indented{2}{(1)\\space{11}(2)} \\indented{1}{H\\space{6}(z) or H\\space{6}(z) for complex \\spad{z,} non-negative (nu) and} \\indented{2}{(nu)+n\\space{8}(nu)+n} n=0,1,...,N-1, with an option for exponential scaling. See \\downlink{Manual Page}{manpageXXs17dlf}.")) (|s17dhf| (((|Result|) (|String|) (|Complex| (|DoubleFloat|)) (|String|) (|Integer|)) "\\spad{s17dhf(deriv,z,scale,ifail)} returns the value of the Airy function Bi(z) or its derivative Bi'(z) for complex \\spad{z,} with an option for exponential scaling. See \\downlink{Manual Page}{manpageXXs17dhf}.")) (|s17dgf| (((|Result|) (|String|) (|Complex| (|DoubleFloat|)) (|String|) (|Integer|)) "\\spad{s17dgf(deriv,z,scale,ifail)} returns the value of the Airy function Ai(z) or its derivative Ai'(z) for complex \\spad{z,} with an option for exponential scaling. See \\downlink{Manual Page}{manpageXXs17dgf}.")) (|s17def| (((|Result|) (|DoubleFloat|) (|Complex| (|DoubleFloat|)) (|Integer|) (|String|) (|Integer|)) "\\spad{s17def(fnu,z,n,scale,ifail)} returns a sequence of values for the Bessel functions \\indented{1}{J\\space{6}(z) for complex \\spad{z,} non-negative (nu) and n=0,1,...,N-1,} \\indented{2}{(nu)+n} with an option for exponential scaling. See \\downlink{Manual Page}{manpageXXs17def}.")) (|s17dcf| (((|Result|) (|DoubleFloat|) (|Complex| (|DoubleFloat|)) (|Integer|) (|String|) (|Integer|)) "\\spad{s17dcf(fnu,z,n,scale,ifail)} returns a sequence of values for the Bessel functions \\indented{1}{Y\\space{6}(z) for complex \\spad{z,} non-negative (nu) and n=0,1,...,N-1,} \\indented{2}{(nu)+n} with an option for exponential scaling. See \\downlink{Manual Page}{manpageXXs17dcf}.")) (|s17akf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s17akf(x,ifail)} returns a value for the derivative of the Airy function Bi(x), via the routine name. See \\downlink{Manual Page}{manpageXXs17akf}.")) (|s17ajf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s17ajf(x,ifail)} returns a value of the derivative of the Airy function Ai(x), via the routine name. See \\downlink{Manual Page}{manpageXXs17ajf}.")) (|s17ahf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s17ahf(x,ifail)} returns a value of the Airy function, Bi(x), via the routine name. See \\downlink{Manual Page}{manpageXXs17ahf}.")) (|s17agf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s17agf(x,ifail)} returns a value for the Airy function, Ai(x), via the routine name. See \\downlink{Manual Page}{manpageXXs17agf}.")) (|s17aff| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s17aff(x,ifail)} returns the value of the Bessel Function \\indented{1}{J (x), via the routine name.} \\indented{2}{1} See \\downlink{Manual Page}{manpageXXs17aff}.")) (|s17aef| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s17aef(x,ifail)} returns the value of the Bessel Function \\indented{1}{J (x), via the routine name.} \\indented{2}{0} See \\downlink{Manual Page}{manpageXXs17aef}.")) (|s17adf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s17adf(x,ifail)} returns the value of the Bessel Function \\indented{1}{Y (x), via the routine name.} \\indented{2}{1} See \\downlink{Manual Page}{manpageXXs17adf}.")) (|s17acf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s17acf(x,ifail)} returns the value of the Bessel Function \\indented{1}{Y (x), via the routine name.} \\indented{2}{0} See \\downlink{Manual Page}{manpageXXs17acf}.")) (|s15aef| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s15aef(x,ifail)} returns the value of the error function erf(x), via the routine name. See \\downlink{Manual Page}{manpageXXs15aef}.")) (|s15adf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s15adf(x,ifail)} returns the value of the complementary error function, erfc(x), via the routine name. See \\downlink{Manual Page}{manpageXXs15adf}.")) (|s14baf| (((|Result|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|)) "\\spad{s14baf(a,x,tol,ifail)} computes values for the incomplete gamma functions P(a,x) and Q(a,x). See \\downlink{Manual Page}{manpageXXs14baf}.")) (|s14abf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s14abf(x,ifail)} returns a value for the log, ln(Gamma(x)), via the routine name. See \\downlink{Manual Page}{manpageXXs14abf}.")) (|s14aaf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s14aaf(x,ifail)} returns the value of the Gamma function (Gamma)(x), via the routine name. See \\downlink{Manual Page}{manpageXXs14aaf}.")) (|s13adf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s13adf(x,ifail)} returns the value of the sine integral See \\downlink{Manual Page}{manpageXXs13adf}.")) (|s13acf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s13acf(x,ifail)} returns the value of the cosine integral See \\downlink{Manual Page}{manpageXXs13acf}.")) (|s13aaf| (((|Result|) (|DoubleFloat|) (|Integer|)) "\\spad{s13aaf(x,ifail)} returns the value of the exponential integral \\indented{1}{E (x), via the routine name.} \\indented{2}{1} See \\downlink{Manual Page}{manpageXXs13aaf}.")) (|s01eaf| (((|Result|) (|Complex| (|DoubleFloat|)) (|Integer|)) "\\spad{s01eaf(z,ifail)} S01EAF evaluates the exponential function exp(z) ,{} for complex \\spad{z.} See \\downlink{Manual Page}{manpageXXs01eaf}."))) 
NIL 
NIL 
(|NAGLinkSupportPackage|) 
((|constructor| (NIL "Support functions for the NAG Library Link functions")) (|restorePrecision| (((|Void|)) "\\spad{restorePrecision()} \\undocumented{}")) (|checkPrecision| (((|Boolean|)) "\\spad{checkPrecision()} \\undocumented{}")) (|dimensionsOf| (((|SExpression|) (|Symbol|) (|Matrix| (|Integer|))) "\\spad{dimensionsOf(s,m)} \\undocumented{}") (((|SExpression|) (|Symbol|) (|Matrix| (|DoubleFloat|))) "\\spad{dimensionsOf(s,m)} \\undocumented{}")) (|aspFilename| (((|String|) (|String|)) "\\spad{aspFilename(\"f\")} returns a String consisting of \\spad{\"f\"} suffixed with \\indented{1}{an extension identifying the current AXIOM session.}")) (|fortranLinkerArgs| (((|String|)) "\\spad{fortranLinkerArgs()} returns the current linker arguments")) (|fortranCompilerName| (((|String|)) "\\spad{fortranCompilerName()} returns the name of the currently selected \\indented{1}{Fortran compiler}"))) 
NIL 
NIL 
(|NonAssociativeRng&| S) 
((|constructor| (NIL "NonAssociativeRng is a basic ring-type structure, not necessarily commutative or associative, and not necessarily with unit.\\br Axioms\\br \\tab{5}x*(y+z) = x*y + x*z\\br \\tab{5}(x+y)*z = \\spad{x*z} + y*z\\br \\blankline Common Additional Axioms\\br \\tab{5}noZeroDivisors\\tab{5} ab = 0 \\spad{=>} \\spad{a=0} or \\spad{b=0}")) (|antiCommutator| (($ $ $) "\\spad{antiCommutator(a,b)} returns \\spad{a*b+b*a}.")) (|commutator| (($ $ $) "\\spad{commutator(a,b)} returns \\spad{a*b-b*a}.")) (|associator| (($ $ $ $) "\\spad{associator(a,b,c)} returns \\spad{(a*b)*c-a*(b*c)}."))) 
NIL 
NIL 
(|NonAssociativeRng|) 
((|constructor| (NIL "NonAssociativeRng is a basic ring-type structure, not necessarily commutative or associative, and not necessarily with unit.\\br Axioms\\br \\tab{5}x*(y+z) = x*y + x*z\\br \\tab{5}(x+y)*z = \\spad{x*z} + y*z\\br \\blankline Common Additional Axioms\\br \\tab{5}noZeroDivisors\\tab{5} ab = 0 \\spad{=>} \\spad{a=0} or \\spad{b=0}")) (|antiCommutator| (($ $ $) "\\spad{antiCommutator(a,b)} returns \\spad{a*b+b*a}.")) (|commutator| (($ $ $) "\\spad{commutator(a,b)} returns \\spad{a*b-b*a}.")) (|associator| (($ $ $ $) "\\spad{associator(a,b,c)} returns \\spad{(a*b)*c-a*(b*c)}."))) 
NIL 
NIL 
(|NonAssociativeRing&| S) 
((|constructor| (NIL "A NonAssociativeRing is a non associative \\spad{rng} which has a unit, the multiplication is not necessarily commutative or associative.")) (|coerce| (($ (|Integer|)) "\\spad{coerce(n)} coerces the integer \\spad{n} to an element of the ring.")) (|characteristic| (((|NonNegativeInteger|)) "\\spad{characteristic()} returns the characteristic of the ring."))) 
NIL 
NIL 
(|NonAssociativeRing|) 
((|constructor| (NIL "A NonAssociativeRing is a non associative \\spad{rng} which has a unit, the multiplication is not necessarily commutative or associative.")) (|coerce| (($ (|Integer|)) "\\spad{coerce(n)} coerces the integer \\spad{n} to an element of the ring.")) (|characteristic| (((|NonNegativeInteger|)) "\\spad{characteristic()} returns the characteristic of the ring."))) 
NIL 
NIL 
(|NumericComplexEigenPackage| |Par|) 
((|constructor| (NIL "This package computes explicitly eigenvalues and eigenvectors of matrices with entries over the complex rational numbers. The results are expressed either as complex floating numbers or as complex rational numbers depending on the type of the precision parameter.")) (|complexEigenvectors| (((|List| (|Record| (|:| |outval| (|Complex| |#1|)) (|:| |outmult| (|Integer|)) (|:| |outvect| (|List| (|Matrix| (|Complex| |#1|)))))) (|Matrix| (|Complex| (|Fraction| (|Integer|)))) |#1|) "\\spad{complexEigenvectors(m,eps)} returns a list of records each one containing a complex eigenvalue, its algebraic multiplicity, and a list of associated eigenvectors. All these results are computed to precision \\spad{eps} and are expressed as complex floats or complex rational numbers depending on the type of \\spad{eps} (float or rational).")) (|complexEigenvalues| (((|List| (|Complex| |#1|)) (|Matrix| (|Complex| (|Fraction| (|Integer|)))) |#1|) "\\spad{complexEigenvalues(m,eps)} computes the eigenvalues of the matrix \\spad{m} to precision eps. The eigenvalues are expressed as complex floats or complex rational numbers depending on the type of \\spad{eps} (float or rational).")) (|characteristicPolynomial| (((|Polynomial| (|Complex| (|Fraction| (|Integer|)))) (|Matrix| (|Complex| (|Fraction| (|Integer|)))) (|Symbol|)) "\\spad{characteristicPolynomial(m,x)} returns the characteristic polynomial of the matrix \\spad{m} expressed as polynomial over Complex Rationals with variable \\spad{x.}") (((|Polynomial| (|Complex| (|Fraction| (|Integer|)))) (|Matrix| (|Complex| (|Fraction| (|Integer|))))) "\\spad{characteristicPolynomial(m)} returns the characteristic polynomial of the matrix \\spad{m} expressed as polynomial over complex rationals with a new symbol as variable."))) 
NIL 
NIL 
(|NumericContinuedFraction| F) 
((|constructor| (NIL "\\spadtype{NumericContinuedFraction} provides functions for converting floating point numbers to continued fractions.")) (|continuedFraction| (((|ContinuedFraction| (|Integer|)) |#1|) "\\spad{continuedFraction(f)} converts the floating point number \\spad{f} to a reduced continued fraction."))) 
NIL 
NIL 
(|NonCommutativeOperatorDivision| P F) 
((|constructor| (NIL "This package provides a division and related operations for \\spadtype{MonogenicLinearOperator}s over a \\spadtype{Field}. Since the multiplication is in general non-commutative, these operations all have left- and right-hand versions. This package provides the operations based on left-division.\\br \\tab{5}[q,r] = leftDivide(a,b) means a=b*q+r")) (|leftLcm| ((|#1| |#1| |#1|) "\\spad{leftLcm(a,b)} computes the value \\spad{m} of lowest degree such that \\spad{m = a*aa = b*bb} for some values \\spad{aa} and \\spad{bb}. The value \\spad{m} is computed using left-division.")) (|leftGcd| ((|#1| |#1| |#1|) "\\spad{leftGcd(a,b)} computes the value \\spad{g} of highest degree such that \\indented{3}{\\spad{a = aa*g}} \\indented{3}{\\spad{b = bb*g}} for some values \\spad{aa} and \\spad{bb}. The value \\spad{g} is computed using left-division.")) (|leftExactQuotient| (((|Union| |#1| "failed") |#1| |#1|) "\\spad{leftExactQuotient(a,b)} computes the value \\spad{q}, if it exists, \\indented{1}{such that \\spad{a = b*q}.}")) (|leftRemainder| ((|#1| |#1| |#1|) "\\spad{leftRemainder(a,b)} computes the pair \\spad{[q,r]} such that \\spad{a = \\spad{b*q} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{r} is returned.")) (|leftQuotient| ((|#1| |#1| |#1|) "\\spad{leftQuotient(a,b)} computes the pair \\spad{[q,r]} such that \\spad{a = \\spad{b*q} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{q} is returned.")) (|leftDivide| (((|Record| (|:| |quotient| |#1|) (|:| |remainder| |#1|)) |#1| |#1|) "\\spad{leftDivide(a,b)} returns the pair \\spad{[q,r]} such that \\spad{a = \\spad{b*q} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. This process is called ``left division''."))) 
NIL 
NIL 
(|NewtonInterpolation| F) 
((|constructor| (NIL "This package exports Newton interpolation for the special case where the result is known to be in the original integral domain The packages defined in this file provide fast fraction free rational interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)")) (|newton| (((|SparseUnivariatePolynomial| |#1|) (|List| |#1|)) "\\spad{newton}(l) returns the interpolating polynomial for the values \\spad{l,} where the x-coordinates are assumed to be [1,2,3,...,n] and the coefficients of the interpolating polynomial are known to be in the domain \\spad{F.} I.e., it is a very streamlined version for a special case of interpolation."))) 
NIL 
NIL 
(|NumberFieldIntegralBasis| UP F) 
((|constructor| (NIL "In this package \\spad{F} is a framed algebra over the integers (typically \\spad{F = Z[a]} for some algebraic integer a). The package provides functions to compute the integral closure of \\spad{Z} in the quotient quotient field of \\spad{F.}")) (|localIntegralBasis| (((|Record| (|:| |basis| (|Matrix| (|Integer|))) (|:| |basisDen| (|Integer|)) (|:| |basisInv| (|Matrix| (|Integer|)))) (|Integer|)) "\\spad{integralBasis(p)} returns a record \\spad{[basis,basisDen,basisInv]} containing information regarding the local integral closure of \\spad{Z} at the prime \\spad{p} in the quotient field of \\spad{F,} where \\spad{F} is a framed algebra with Z-module basis \\spad{w1,w2,...,wn}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}.")) (|integralBasis| (((|Record| (|:| |basis| (|Matrix| (|Integer|))) (|:| |basisDen| (|Integer|)) (|:| |basisInv| (|Matrix| (|Integer|))))) "\\spad{integralBasis()} returns a record \\spad{[basis,basisDen,basisInv]} containing information regarding the integral closure of \\spad{Z} in the quotient field of \\spad{F,} where \\spad{F} is a framed algebra with Z-module basis \\spad{w1,w2,...,wn}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}.")) (|discriminant| (((|Integer|)) "\\spad{discriminant()} returns the discriminant of the integral closure of \\spad{Z} in the quotient field of the framed algebra \\spad{F.}"))) 
NIL 
NIL 
(|NumericalIntegrationProblem|) 
((|constructor| (NIL "\\axiomType{NumericalIntegrationProblem} is a \\axiom{domain} for the representation of Numerical Integration problems for use by ANNA. \\blankline The representation is a Union of two record types - one for integration of a function of one variable: \\blankline \\axiomType{Record}(var:\\axiomType{Symbol},\\br fn:\\axiomType{Expression DoubleFloat},\\br range:\\axiomType{Segment OrderedCompletion DoubleFloat},\\br abserr:\\axiomType{DoubleFloat},\\br relerr:\\axiomType{DoubleFloat},) \\blankline and one for multivariate integration: \\blankline \\axiomType{Record}(fn:\\axiomType{Expression DoubleFloat},\\br range:\\axiomType{List Segment OrderedCompletion DoubleFloat},\\br abserr:\\axiomType{DoubleFloat},\\br relerr:\\axiomType{DoubleFloat},). \\blankline")) (|retract| (((|Union| (|:| |nia| (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) (|:| |mdnia| (|Record| (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|List| (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))))) $) "\\spad{retract(x)} is not documented")) (|coerce| (((|OutputForm|) $) "\\spad{coerce(x)} is not documented") (($ (|Union| (|:| |nia| (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) (|:| |mdnia| (|Record| (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|List| (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))))) "\\spad{coerce(x)} is not documented") (($ (|Record| (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|List| (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{coerce(x)} is not documented") (($ (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{coerce(x)} is not documented"))) 
NIL 
NIL 
(|NonLinearSolvePackage| R) 
((|constructor| (NIL "NonLinearSolvePackage is an interface to \\spadtype{SystemSolvePackage} that attempts to retract the coefficients of the equations before solving. The solutions are given in the algebraic closure of \\spad{R} whenever possible.")) (|solve| (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))) (|List| (|Polynomial| |#1|))) "\\spad{solve(lp)} finds the solution in the algebraic closure of \\spad{R} of the list \\spad{lp} of rational functions with respect to all the symbols appearing in \\spad{lp.}") (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))) (|List| (|Polynomial| |#1|)) (|List| (|Symbol|))) "\\spad{solve(lp,lv)} finds the solutions in the algebraic closure of \\spad{R} of the list \\spad{lp} of rational functions with respect to the list of symbols \\spad{lv.}")) (|solveInField| (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))) (|List| (|Polynomial| |#1|))) "\\spad{solveInField(lp)} finds the solution of the list \\spad{lp} of rational functions with respect to all the symbols appearing in \\spad{lp.}") (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))) (|List| (|Polynomial| |#1|)) (|List| (|Symbol|))) "\\spad{solveInField(lp,lv)} finds the solutions of the list \\spad{lp} of rational functions with respect to the list of symbols \\spad{lv.}"))) 
NIL 
NIL 
(|NonNegativeInteger|) 
((|constructor| (NIL "\\spadtype{NonNegativeInteger} provides functions for non-negative integers.")) (|commutative| ((|attribute| "*") "\\spad{commutative(\"*\")} means multiplication is commutative, that is, \\spad{x*y = y*x}.")) (|random| (($ $) "\\spad{random(n)} returns a random integer from 0 to \\spad{n-1}.")) (|shift| (($ $ (|Integer|)) "\\spad{shift(a,i)} shift \\spad{a} by \\spad{i} bits.")) (|exquo| (((|Union| $ "failed") $ $) "\\spad{exquo(a,b)} returns the quotient of \\spad{a} and \\spad{b,} or \"failed\" if \\spad{b} is zero or \\spad{a} rem \\spad{b} is zero.")) (|divide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{divide(a,b)} returns a record containing both remainder and quotient.")) (|gcd| (($ $ $) "\\spad{gcd(a,b)} computes the greatest common divisor of two non negative integers \\spad{a} and \\spad{b.}")) (|rem| (($ $ $) "\\spad{a rem \\spad{b}} returns the remainder of \\spad{a} and \\spad{b.}")) (|quo| (($ $ $) "\\spad{a quo \\spad{b}} returns the quotient of \\spad{a} and \\spad{b,} forgetting the remainder."))) 
(((|commutative| "*") . T)) 
NIL 
(|NonLinearFirstOrderODESolver| R F) 
((|constructor| (NIL "NonLinearFirstOrderODESolver provides a function for finding closed form first integrals of nonlinear ordinary differential equations of order 1.")) (|solve| (((|Union| |#2| "failed") |#2| |#2| (|BasicOperator|) (|Symbol|)) "\\spad{solve(M(x,y), N(x,y), \\spad{y,} \\spad{x)}} returns \\spad{F(x,y)} such that \\spad{F(x,y) = \\spad{c}} for a constant \\spad{c} is a first integral of the equation \\spad{M(x,y) \\spad{dx} + N(x,y) dy = 0}, or \"failed\" if no first-integral can be found."))) 
NIL 
NIL 
(|NoneFunctions1| S) 
((|constructor| (NIL "\\spadtype{NoneFunctions1} implements functions on \\spadtype{None}. It particular it includes a particulary dangerous coercion from any other type to \\spadtype{None}.")) (|coerce| (((|None|) |#1|) "\\spad{coerce(x)} changes \\spad{x} into an object of type \\spadtype{None}."))) 
NIL 
NIL 
(|None|) 
((|constructor| (NIL "\\spadtype{None} implements a type with no objects. It is mainly used in technical situations where such a thing is needed (\\spadignore{e.g.} the interpreter and some of the internal \\spadtype{Expression} code)."))) 
NIL 
NIL 
(|NormInMonogenicAlgebra| R |PolR| E |PolE|) 
((|constructor| (NIL "This package implements the norm of a polynomial with coefficients in a monogenic algebra (using resultants)")) (|norm| ((|#2| |#4|) "\\spad{norm \\spad{q}} returns the norm of \\spad{q,} \\spadignore{i.e.} the product of all the conjugates of \\spad{q.}"))) 
NIL 
NIL 
(|NormalizationPackage| R E V P TS) 
((|constructor| (NIL "A package for computing normalized assocites of univariate polynomials with coefficients in a tower of simple extensions of a field.")) (|normInvertible?| (((|List| (|Record| (|:| |val| (|Boolean|)) (|:| |tower| |#5|))) |#4| |#5|) "\\axiom{normInvertible?(p,ts)} is an internal subroutine, exported only for developement.")) (|outputArgs| (((|Void|) (|String|) (|String|) |#4| |#5|) "\\axiom{outputArgs(s1,s2,p,ts)} is an internal subroutine, exported only for developement.")) (|normalize| (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| |#5|))) |#4| |#5|) "\\axiom{normalize(p,ts)} normalizes \\axiom{p} w.r.t \\spad{ts}.")) (|normalizedAssociate| ((|#4| |#4| |#5|) "\\axiom{normalizedAssociate(p,ts)} returns a normalized polynomial \\axiom{n} w.r.t. \\spad{ts} such that \\axiom{n} and \\axiom{p} are associates w.r.t \\spad{ts} and assuming that \\axiom{p} is invertible w.r.t \\spad{ts}.")) (|recip| (((|Record| (|:| |num| |#4|) (|:| |den| |#4|)) |#4| |#5|) "\\axiom{recip(p,ts)} returns the inverse of \\axiom{p} w.r.t \\spad{ts} assuming that \\axiom{p} is invertible w.r.t \\spad{ts}."))) 
NIL 
NIL 
(|NormRetractPackage| F |ExtF| |SUEx| |ExtP| |n|) 
((|constructor| (NIL "This package has no description")) (|Frobenius| ((|#4| |#4|) "\\spad{Frobenius(x)} \\undocumented")) (|retractIfCan| (((|Union| (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|)) "failed") |#4|) "\\spad{retractIfCan(x)} \\undocumented")) (|normFactors| (((|List| |#4|) |#4|) "\\spad{normFactors(x)} \\undocumented"))) 
NIL 
NIL 
(|NottinghamGroup| F) 
((|constructor| (NIL "This is an implmenentation of the Nottingham Group"))) 
((|unitsKnown| . T)) 
NIL 
(|NPCoef| BP E OV R P) 
((|constructor| (NIL "Package for the determination of the coefficients in the lifting process. Used by \\spadtype{MultivariateLifting}. This package will work for every euclidean domain \\spad{R} which has property \\spad{F,} \\spadignore{i.e.} there exists a factor operation in \\spad{R[x]}.")) (|listexp| (((|List| (|NonNegativeInteger|)) |#1|) "\\spad{listexp }\\undocumented")) (|npcoef| (((|Record| (|:| |deter| (|List| (|SparseUnivariatePolynomial| |#5|))) (|:| |dterm| (|List| (|List| (|Record| (|:| |expt| (|NonNegativeInteger|)) (|:| |pcoef| |#5|))))) (|:| |nfacts| (|List| |#1|)) (|:| |nlead| (|List| |#5|))) (|SparseUnivariatePolynomial| |#5|) (|List| |#1|) (|List| |#5|)) "\\spad{npcoef }\\undocumented"))) 
NIL 
NIL 
(|NewtonPolygon| K |PolyRing| E |dim|) 
((|constructor| (NIL "The following is part of the PAFF package"))) 
NIL 
NIL 
(|NumericRealEigenPackage| |Par|) 
((|constructor| (NIL "This package computes explicitly eigenvalues and eigenvectors of matrices with entries over the Rational Numbers. The results are expressed as floating numbers or as rational numbers depending on the type of the parameter Par.")) (|realEigenvectors| (((|List| (|Record| (|:| |outval| |#1|) (|:| |outmult| (|Integer|)) (|:| |outvect| (|List| (|Matrix| |#1|))))) (|Matrix| (|Fraction| (|Integer|))) |#1|) "\\spad{realEigenvectors(m,eps)} returns a list of records each one containing a real eigenvalue, its algebraic multiplicity, and a list of associated eigenvectors. All these results are computed to precision \\spad{eps} as floats or rational numbers depending on the type of \\spad{eps} .")) (|realEigenvalues| (((|List| |#1|) (|Matrix| (|Fraction| (|Integer|))) |#1|) "\\spad{realEigenvalues(m,eps)} computes the eigenvalues of the matrix \\spad{m} to precision eps. The eigenvalues are expressed as floats or rational numbers depending on the type of \\spad{eps} (float or rational).")) (|characteristicPolynomial| (((|Polynomial| (|Fraction| (|Integer|))) (|Matrix| (|Fraction| (|Integer|))) (|Symbol|)) "\\spad{characteristicPolynomial(m,x)} returns the characteristic polynomial of the matrix \\spad{m} expressed as polynomial over \\spad{RN} with variable \\spad{x.} Fraction \\spad{P} \\spad{RN.}") (((|Polynomial| (|Fraction| (|Integer|))) (|Matrix| (|Fraction| (|Integer|)))) "\\spad{characteristicPolynomial(m)} returns the characteristic polynomial of the matrix \\spad{m} expressed as polynomial over \\spad{RN} with a new symbol as variable."))) 
NIL 
NIL 
(|NeitherSparseOrDensePowerSeries| K) 
((|constructor| (NIL "This domain is part of the PAFF package"))) 
(((|commutative| "*") . T) (|noZeroDivisors| . T) (|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Integer|) (QUOTE (|SemiGroup|))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|Integer|)) (|devaluate| |#1|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|Integer|)) (|devaluate| |#1|))))) (|HasCategory| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Integer|))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|)))))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|)) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |k|) (QUOTE (|Integer|))) (LIST (QUOTE |:|) (QUOTE |c|) (|devaluate| |#1|))))) (|HasCategory| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|)) (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) 
(|NewSparseMultivariatePolynomial| R |VarSet|) 
((|constructor| (NIL "A post-facto extension for \\axiomType{SMP} in order to speed up operations related to pseudo-division and gcd. This domain is based on the \\axiomType{NSUP} constructor which is itself a post-facto extension of the \\axiomType{SUP} constructor."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|Symbol|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|Symbol|))))) (|HasCategory| |#1| (QUOTE (|Field|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|Symbol|))))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|Symbol|)))) (|not| (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|Symbol|)))))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|Symbol|)))) (|not| (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|not| (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|Symbol|)))) (|not| (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|not| (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|))))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|Symbol|)))) (|not| (|HasCategory| |#1| (LIST (QUOTE |QuotientFieldCategory|) (QUOTE (|Integer|))))))) (OR (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))))) 
(|NewSparseUnivariatePolynomialFunctions2| R S) 
((|constructor| (NIL "This package lifts a mapping from coefficient rings \\spad{R} to \\spad{S} to a mapping from sparse univariate polynomial over \\spad{R} to a sparse univariate polynomial over \\spad{S.} Note that the mapping is assumed to send zero to zero, since it will only be applied to the non-zero coefficients of the polynomial.")) (|map| (((|NewSparseUnivariatePolynomial| |#2|) (|Mapping| |#2| |#1|) (|NewSparseUnivariatePolynomial| |#1|)) "\\axiom{map(func, poly)} creates a new polynomial by applying func to every non-zero coefficient of the polynomial poly."))) 
NIL 
NIL 
(|NewSparseUnivariatePolynomial| R) 
((|constructor| (NIL "A post-facto extension for \\axiomType{SUP} in order to speed up operations related to pseudo-division and \\spad{gcd} for both \\axiomType{SUP} and, consequently, \\axiomType{NSMP}.")) (|halfExtendedResultant2| (((|Record| (|:| |resultant| |#1|) (|:| |coef2| $)) $ $) "\\axiom{halfExtendedResultant2(a,b)} returns \\axiom{[r,ca]} such that \\axiom{extendedResultant(a,b)} returns \\axiom{[r,ca, cb]}")) (|halfExtendedResultant1| (((|Record| (|:| |resultant| |#1|) (|:| |coef1| $)) $ $) "\\axiom{halfExtendedResultant1(a,b)} returns \\axiom{[r,ca]} such that \\axiom{extendedResultant(a,b)} returns \\axiom{[r,ca, cb]}")) (|extendedResultant| (((|Record| (|:| |resultant| |#1|) (|:| |coef1| $) (|:| |coef2| $)) $ $) "\\axiom{extendedResultant(a,b)} returns \\axiom{[r,ca,cb]} such that \\axiom{r} is the resultant of \\axiom{a} and \\axiom{b} and \\axiom{r = ca * a + \\spad{cb} * \\spad{b}}")) (|halfExtendedSubResultantGcd2| (((|Record| (|:| |gcd| $) (|:| |coef2| $)) $ $) "\\axiom{halfExtendedSubResultantGcd2(a,b)} returns \\axiom{[g,cb]} such that \\axiom{extendedSubResultantGcd(a,b)} returns \\axiom{[g,ca, cb]}")) (|halfExtendedSubResultantGcd1| (((|Record| (|:| |gcd| $) (|:| |coef1| $)) $ $) "\\axiom{halfExtendedSubResultantGcd1(a,b)} returns \\axiom{[g,ca]} such that \\axiom{extendedSubResultantGcd(a,b)} returns \\axiom{[g,ca, cb]}")) (|extendedSubResultantGcd| (((|Record| (|:| |gcd| $) (|:| |coef1| $) (|:| |coef2| $)) $ $) "\\axiom{extendedSubResultantGcd(a,b)} returns \\axiom{[g,ca, cb]} such that \\axiom{g} is a \\spad{gcd} of \\axiom{a} and \\axiom{b} in \\axiom{R^(-1) \\spad{P}} and \\axiom{g = ca * a + \\spad{cb} * \\spad{b}}")) (|lastSubResultant| (($ $ $) "\\axiom{lastSubResultant(a,b)} returns \\axiom{resultant(a,b)} if \\axiom{a} and \\axiom{b} has no non-trivial \\spad{gcd} in \\axiom{R^(-1) \\spad{P}} otherwise the non-zero sub-resultant with smallest index.")) (|subResultantsChain| (((|List| $) $ $) "\\axiom{subResultantsChain(a,b)} returns the list of the non-zero sub-resultants of \\axiom{a} and \\axiom{b} sorted by increasing degree.")) (|lazyPseudoQuotient| (($ $ $) "\\axiom{lazyPseudoQuotient(a,b)} returns \\axiom{q} if \\axiom{lazyPseudoDivide(a,b)} returns \\axiom{[c,g,q,r]}")) (|lazyPseudoDivide| (((|Record| (|:| |coef| |#1|) (|:| |gap| (|NonNegativeInteger|)) (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\axiom{lazyPseudoDivide(a,b)} returns \\axiom{[c,g,q,r]} such that \\axiom{c^n * a = \\spad{q*b} \\spad{+r}} and \\axiom{lazyResidueClass(a,b)} returns \\axiom{[r,c,n]} where \\axiom{n + \\spad{g} = max(0, degree(b) - degree(a) + 1)}.")) (|lazyPseudoRemainder| (($ $ $) "\\axiom{lazyPseudoRemainder(a,b)} returns \\axiom{r} if \\axiom{lazyResidueClass(a,b)} returns \\axiom{[r,c,n]}. This lazy pseudo-remainder is computed by means of the fmecg from NewSparseUnivariatePolynomial operation.")) (|lazyResidueClass| (((|Record| (|:| |polnum| $) (|:| |polden| |#1|) (|:| |power| (|NonNegativeInteger|))) $ $) "\\axiom{lazyResidueClass(a,b)} returns \\axiom{[r,c,n]} such that \\axiom{r} is reduced w.r.t. \\axiom{b} and \\axiom{b} divides \\axiom{c^n * a - \\spad{r}} where \\axiom{c} is \\axiom{leadingCoefficient(b)} and \\axiom{n} is as small as possible with the previous properties.")) (|monicModulo| (($ $ $) "\\axiom{monicModulo(a,b)} returns \\axiom{r} such that \\axiom{r} is reduced w.r.t. \\axiom{b} and \\axiom{b} divides \\axiom{a \\spad{-r}} where \\axiom{b} is monic.")) (|fmecg| (($ $ (|NonNegativeInteger|) |#1| $) "\\axiom{fmecg(p1,e,r,p2)} returns \\axiom{p1 - \\spad{r} * x**e * \\spad{p2}} where \\axiom{x} is \\axiom{monomial(1,1)}"))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|additiveValuation| |has| |#1| (|Field|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|StepThrough|))) (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (OR (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))))) 
(|NumberTheoreticPolynomialFunctions| R) 
((|constructor| (NIL "This package provides polynomials as functions on a ring.")) (|eulerE| ((|#1| (|NonNegativeInteger|) |#1|) "\\spad{eulerE(n,r)} \\undocumented")) (|bernoulliB| ((|#1| (|NonNegativeInteger|) |#1|) "\\spad{bernoulliB(n,r)} \\undocumented")) (|cyclotomic| ((|#1| (|NonNegativeInteger|) |#1|) "\\spad{cyclotomic(n,r)} \\undocumented"))) 
NIL 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) 
(|NormalizedTriangularSetCategory| R E V P) 
((|constructor| (NIL "The category of normalized triangular sets. A triangular set \\spad{ts} is said normalized if for every algebraic variable \\spad{v} of \\spad{ts} the polynomial select(ts,v) is normalized w.r.t. every polynomial in collectUnder(ts,v). A polynomial \\spad{p} is said normalized w.r.t. a non-constant polynomial \\spad{q} if \\spad{p} is constant or degree(p,mdeg(q)) = 0 and init(p) is normalized w.r.t. \\spad{q.} One of the important features of normalized triangular sets is that they are regular sets."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|Numeric| S) 
((|constructor| (NIL "Numeric provides real and complex numerical evaluation functions for various symbolic types.")) (|numericIfCan| (((|Union| (|Float|) "failed") (|Expression| |#1|) (|PositiveInteger|)) "\\spad{numericIfCan(x, \\spad{n)}} returns a real approximation of \\spad{x} up to \\spad{n} decimal places, or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Float|) "failed") (|Expression| |#1|)) "\\spad{numericIfCan(x)} returns a real approximation of \\spad{x,} or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Float|) "failed") (|Fraction| (|Polynomial| |#1|)) (|PositiveInteger|)) "\\spad{numericIfCan(x,n)} returns a real approximation of \\spad{x} up to \\spad{n} decimal places, or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Float|) "failed") (|Fraction| (|Polynomial| |#1|))) "\\spad{numericIfCan(x)} returns a real approximation of \\spad{x,} or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Float|) "failed") (|Polynomial| |#1|) (|PositiveInteger|)) "\\spad{numericIfCan(x,n)} returns a real approximation of \\spad{x} up to \\spad{n} decimal places, or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Float|) "failed") (|Polynomial| |#1|)) "\\spad{numericIfCan(x)} returns a real approximation of \\spad{x,} or \"failed\" if \\axiom{x} is not a constant.")) (|complexNumericIfCan| (((|Union| (|Complex| (|Float|)) "failed") (|Expression| (|Complex| |#1|)) (|PositiveInteger|)) "\\spad{complexNumericIfCan(x, \\spad{n)}} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places, or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Complex| (|Float|)) "failed") (|Expression| (|Complex| |#1|))) "\\spad{complexNumericIfCan(x)} returns a complex approximation of \\spad{x,} or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Complex| (|Float|)) "failed") (|Expression| |#1|) (|PositiveInteger|)) "\\spad{complexNumericIfCan(x, \\spad{n)}} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places, or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Complex| (|Float|)) "failed") (|Expression| |#1|)) "\\spad{complexNumericIfCan(x)} returns a complex approximation of \\spad{x,} or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Complex| (|Float|)) "failed") (|Fraction| (|Polynomial| (|Complex| |#1|))) (|PositiveInteger|)) "\\spad{complexNumericIfCan(x, \\spad{n)}} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places, or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Complex| (|Float|)) "failed") (|Fraction| (|Polynomial| (|Complex| |#1|)))) "\\spad{complexNumericIfCan(x)} returns a complex approximation of \\spad{x,} or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Complex| (|Float|)) "failed") (|Fraction| (|Polynomial| |#1|)) (|PositiveInteger|)) "\\spad{complexNumericIfCan(x, \\spad{n)}} returns a complex approximation of \\spad{x,} or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Complex| (|Float|)) "failed") (|Fraction| (|Polynomial| |#1|))) "\\spad{complexNumericIfCan(x)} returns a complex approximation of \\spad{x,} or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Complex| (|Float|)) "failed") (|Polynomial| |#1|) (|PositiveInteger|)) "\\spad{complexNumericIfCan(x, \\spad{n)}} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places, or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Complex| (|Float|)) "failed") (|Polynomial| |#1|)) "\\spad{complexNumericIfCan(x)} returns a complex approximation of \\spad{x,} or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Complex| (|Float|)) "failed") (|Polynomial| (|Complex| |#1|)) (|PositiveInteger|)) "\\spad{complexNumericIfCan(x, \\spad{n)}} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places, or \"failed\" if \\axiom{x} is not a constant.") (((|Union| (|Complex| (|Float|)) "failed") (|Polynomial| (|Complex| |#1|))) "\\spad{complexNumericIfCan(x)} returns a complex approximation of \\spad{x,} or \"failed\" if \\axiom{x} is not constant.")) (|complexNumeric| (((|Complex| (|Float|)) (|Expression| (|Complex| |#1|)) (|PositiveInteger|)) "\\spad{complexNumeric(x, \\spad{n)}} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.") (((|Complex| (|Float|)) (|Expression| (|Complex| |#1|))) "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x.}") (((|Complex| (|Float|)) (|Expression| |#1|) (|PositiveInteger|)) "\\spad{complexNumeric(x, \\spad{n)}} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.") (((|Complex| (|Float|)) (|Expression| |#1|)) "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x.}") (((|Complex| (|Float|)) (|Fraction| (|Polynomial| (|Complex| |#1|))) (|PositiveInteger|)) "\\spad{complexNumeric(x, \\spad{n)}} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.") (((|Complex| (|Float|)) (|Fraction| (|Polynomial| (|Complex| |#1|)))) "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x.}") (((|Complex| (|Float|)) (|Fraction| (|Polynomial| |#1|)) (|PositiveInteger|)) "\\spad{complexNumeric(x, \\spad{n)}} returns a complex approximation of \\spad{x}") (((|Complex| (|Float|)) (|Fraction| (|Polynomial| |#1|))) "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x.}") (((|Complex| (|Float|)) (|Polynomial| |#1|) (|PositiveInteger|)) "\\spad{complexNumeric(x, \\spad{n)}} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.") (((|Complex| (|Float|)) (|Polynomial| |#1|)) "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x.}") (((|Complex| (|Float|)) (|Polynomial| (|Complex| |#1|)) (|PositiveInteger|)) "\\spad{complexNumeric(x, \\spad{n)}} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.") (((|Complex| (|Float|)) (|Polynomial| (|Complex| |#1|))) "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x.}") (((|Complex| (|Float|)) (|Complex| |#1|) (|PositiveInteger|)) "\\spad{complexNumeric(x, \\spad{n)}} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.") (((|Complex| (|Float|)) (|Complex| |#1|)) "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x.}") (((|Complex| (|Float|)) |#1| (|PositiveInteger|)) "\\spad{complexNumeric(x, \\spad{n)}} returns a complex approximation of \\spad{x} up to \\spad{n} decimal places.") (((|Complex| (|Float|)) |#1|) "\\spad{complexNumeric(x)} returns a complex approximation of \\spad{x.}")) (|numeric| (((|Float|) (|Expression| |#1|) (|PositiveInteger|)) "\\spad{numeric(x, \\spad{n)}} returns a real approximation of \\spad{x} up to \\spad{n} decimal places.") (((|Float|) (|Expression| |#1|)) "\\spad{numeric(x)} returns a real approximation of \\spad{x.}") (((|Float|) (|Fraction| (|Polynomial| |#1|)) (|PositiveInteger|)) "\\spad{numeric(x,n)} returns a real approximation of \\spad{x} up to \\spad{n} decimal places.") (((|Float|) (|Fraction| (|Polynomial| |#1|))) "\\spad{numeric(x)} returns a real approximation of \\spad{x.}") (((|Float|) (|Polynomial| |#1|) (|PositiveInteger|)) "\\spad{numeric(x,n)} returns a real approximation of \\spad{x} up to \\spad{n} decimal places.") (((|Float|) (|Polynomial| |#1|)) "\\spad{numeric(x)} returns a real approximation of \\spad{x.}") (((|Float|) |#1| (|PositiveInteger|)) "\\spad{numeric(x, \\spad{n)}} returns a real approximation of \\spad{x} up to \\spad{n} decimal places.") (((|Float|) |#1|) "\\spad{numeric(x)} returns a real approximation of \\spad{x.}"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (AND (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (|HasCategory| |#1| (QUOTE (|Ring|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|)))) 
(|NumberFormats|) 
((|constructor| (NIL "NumberFormats provides function to format and read arabic and roman numbers, to convert numbers to strings and to read floating-point numbers.")) (|ScanFloatIgnoreSpacesIfCan| (((|Union| (|Float|) "failed") (|String|)) "\\spad{ScanFloatIgnoreSpacesIfCan(s)} tries to form a floating point number from the string \\spad{s} ignoring any spaces.")) (|ScanFloatIgnoreSpaces| (((|Float|) (|String|)) "\\spad{ScanFloatIgnoreSpaces(s)} forms a floating point number from the string \\spad{s} ignoring any spaces. Error is generated if the string is not recognised as a floating point number.")) (|ScanRoman| (((|PositiveInteger|) (|String|)) "\\spad{ScanRoman(s)} forms an integer from a Roman numeral string \\spad{s.}")) (|FormatRoman| (((|String|) (|PositiveInteger|)) "\\spad{FormatRoman(n)} forms a Roman numeral string from an integer \\spad{n.}")) (|ScanArabic| (((|PositiveInteger|) (|String|)) "\\spad{ScanArabic(s)} forms an integer from an Arabic numeral string \\spad{s.}")) (|FormatArabic| (((|String|) (|PositiveInteger|)) "\\spad{FormatArabic(n)} forms an Arabic numeral string from an integer \\spad{n.}"))) 
NIL 
NIL 
(|NumericalIntegrationCategory|) 
((|constructor| (NIL "\\axiomType{NumericalIntegrationCategory} is the \\axiom{category} for describing the set of Numerical Integration \\axiom{domains} with \\axiomFun{measure} and \\axiomFun{numericalIntegration}.")) (|numericalIntegration| (((|Result|) (|Record| (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|List| (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))) (|Result|)) "\\spad{numericalIntegration(args,hints)} performs the integration of the function given the strategy or method returned by \\axiomFun{measure}.") (((|Result|) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))) (|Result|)) "\\spad{numericalIntegration(args,hints)} performs the integration of the function given the strategy or method returned by \\axiomFun{measure}.")) (|measure| (((|Record| (|:| |measure| (|Float|)) (|:| |explanations| (|String|)) (|:| |extra| (|Result|))) (|RoutinesTable|) (|Record| (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|List| (|Segment| (|OrderedCompletion| (|DoubleFloat|))))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{measure(R,args)} calculates an estimate of the ability of a particular method to solve a problem. \\blankline This method may be either a specific NAG routine or a strategy (such as transforming the function from one which is difficult to one which is easier to solve). \\blankline It will call whichever agents are needed to perform analysis on the problem in order to calculate the measure. There is a parameter, labelled \\axiom{sofar}, which would contain the best compatibility found so far.") (((|Record| (|:| |measure| (|Float|)) (|:| |explanations| (|String|)) (|:| |extra| (|Result|))) (|RoutinesTable|) (|Record| (|:| |var| (|Symbol|)) (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |range| (|Segment| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{measure(R,args)} calculates an estimate of the ability of a particular method to solve a problem. \\blankline This method may be either a specific NAG routine or a strategy (such as transforming the function from one which is difficult to one which is easier to solve). \\blankline It will call whichever agents are needed to perform analysis on the problem in order to calculate the measure. There is a parameter, labelled \\axiom{sofar}, which would contain the best compatibility found so far."))) 
NIL 
NIL 
(|NumericalOrdinaryDifferentialEquations|) 
((|constructor| (NIL "This package is a suite of functions for the numerical integration of an ordinary differential equation of \\spad{n} variables:\\br \\tab{5}dy/dx = f(y,x)\\tab{5}y is an n-vector\\br All the routines are based on a 4-th order Runge-Kutta kernel. These routines generally have as arguments:\\br \\spad{n,} the number of dependent variables;\\br \\spad{x1,} the initial point;\\br \\spad{h,} the step size;\\br \\spad{y,} a vector of initial conditions of length n\\br which upon exit contains the solution at \\spad{x1 + h};\\br \\blankline \\spad{derivs}, a function which computes the right hand side of the ordinary differential equation: \\spad{derivs(dydx,y,x)} computes \\spad{dydx}, a vector which contains the derivative information. \\blankline In order of increasing complexity:\\br \\tab{5}\\spad{rk4(y,n,x1,h,derivs)} advances the solution vector to\\br \\tab{5}\\spad{x1 + \\spad{h}} and return the values in y.\\br \\blankline \\tab{5}\\spad{rk4(y,n,x1,h,derivs,t1,t2,t3,t4)} is the same as\\br \\tab{5}\\spad{rk4(y,n,x1,h,derivs)} except that you must provide 4 scratch\\br \\tab{5}arrays \\spad{t1-t4} of size n.\\br \\blankline \\tab{5}Starting with \\spad{y} at \\spad{x1,} \\spad{rk4f(y,n,x1,x2,ns,derivs)}\\br \\tab{5}uses \\spad{ns} fixed steps of a 4-th order Runge-Kutta\\br \\tab{5}integrator to advance the solution vector to \\spad{x2} and return\\br \\tab{5}the values in \\spad{y.} Argument \\spad{x2,} is the final point, and\\br \\tab{5}\\spad{ns}, the number of steps to take. \\blankline \\spad{rk4qc(y,n,x1,step,eps,yscal,derivs)} takes a 5-th order Runge-Kutta step with monitoring of local truncation to ensure accuracy and adjust stepsize. The function takes two half steps and one full step and scales the difference in solutions at the final point. If the error is within \\spad{eps}, the step is taken and the result is returned. If the error is not within \\spad{eps}, the stepsize if decreased and the procedure is tried again until the desired accuracy is reached. Upon input, an trial step size must be given and upon return, an estimate of the next step size to use is returned as well as the step size which produced the desired accuracy. The scaled error is computed as\\br \\tab{5}\\spad{error = MAX(ABS((y2steps(i) - y1step(i))/yscal(i)))}\\br and this is compared against \\spad{eps}. If this is greater than \\spad{eps}, the step size is reduced accordingly to\\br \\tab{5}\\spad{hnew = 0.9 * hdid * (error/eps)**(-1/4)}\\br If the error criterion is satisfied, then we check if the step size was too fine and return a more efficient one. If \\spad{error > \\spad{eps} * (6.0E-04)} then the next step size should be\\br \\tab{5}\\spad{hnext = 0.9 * hdid * (error/\\spad{eps})**(-1/5)}\\br Otherwise \\spad{hnext = 4.0 * hdid} is returned. A more detailed discussion of this and related topics can be found in the book \"Numerical Recipies\" by W.Press, B.P. Flannery, S.A. Teukolsky, W.T. Vetterling published by Cambridge University Press. \\blankline Argument \\spad{step} is a record of 3 floating point numbers \\spad{(try ,{} did ,{} next)}, \\spad{eps} is the required accuracy, \\spad{yscal} is the scaling vector for the difference in solutions. On input, \\spad{step.try} should be the guess at a step size to achieve the accuracy. On output, \\spad{step.did} contains the step size which achieved the accuracy and \\spad{step.next} is the next step size to use. \\blankline \\spad{rk4qc(y,n,x1,step,eps,yscal,derivs,t1,t2,t3,t4,t5,t6,t7)} is the same as \\spad{rk4qc(y,n,x1,step,eps,yscal,derivs)} except that the user must provide the 7 scratch arrays \\spad{t1-t7} of size \\spad{n.} \\blankline \\spad{rk4a(y,n,x1,x2,eps,h,ns,derivs)} is a driver program which uses \\spad{rk4qc} to integrate \\spad{n} ordinary differential equations starting at \\spad{x1} to \\spad{x2,} keeping the local truncation error to within \\spad{eps} by changing the local step size. The scaling vector is defined as\\br \\tab{5}\\spad{yscal(i) = abs(y(i)) + abs(h*dydx(i)) + tiny}\\br where \\spad{y(i)} is the solution at location \\spad{x,} \\spad{dydx} is the ordinary differential equation's right hand side, \\spad{h} is the current step size and \\spad{tiny} is 10 times the smallest positive number representable. \\blankline The user must supply an estimate for a trial step size and the maximum number of calls to \\spad{rk4qc} to use. Argument \\spad{x2} is the final point, \\spad{eps} is local truncation, \\spad{ns} is the maximum number of call to \\spad{rk4qc} to use.")) (|rk4f| (((|Void|) (|Vector| (|Float|)) (|Integer|) (|Float|) (|Float|) (|Integer|) (|Mapping| (|Void|) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Float|))) "\\spad{rk4f(y,n,x1,x2,ns,derivs)} uses a 4-th order Runge-Kutta method to numerically integrate the ordinary differential equation dy/dx = f(y,x) of \\spad{n} variables, where \\spad{y} is an n-vector. Starting with \\spad{y} at \\spad{x1,} this function uses \\spad{ns} fixed steps of a 4-th order Runge-Kutta integrator to advance the solution vector to \\spad{x2} and return the values in \\spad{y.} For details, see \\con{NumericalOrdinaryDifferentialEquations}.")) (|rk4qc| (((|Void|) (|Vector| (|Float|)) (|Integer|) (|Float|) (|Record| (|:| |try| (|Float|)) (|:| |did| (|Float|)) (|:| |next| (|Float|))) (|Float|) (|Vector| (|Float|)) (|Mapping| (|Void|) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Float|)) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Vector| (|Float|))) "\\spad{rk4qc(y,n,x1,step,eps,yscal,derivs,t1,t2,t3,t4,t5,t6,t7)} is a subfunction for the numerical integration of an ordinary differential equation dy/dx = f(y,x) of \\spad{n} variables, where \\spad{y} is an n-vector using a 4-th order Runge-Kutta method. This function takes a 5-th order Runge-Kutta \\spad{step} with monitoring of local truncation to ensure accuracy and adjust stepsize. For details, see \\con{NumericalOrdinaryDifferentialEquations}.") (((|Void|) (|Vector| (|Float|)) (|Integer|) (|Float|) (|Record| (|:| |try| (|Float|)) (|:| |did| (|Float|)) (|:| |next| (|Float|))) (|Float|) (|Vector| (|Float|)) (|Mapping| (|Void|) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Float|))) "\\spad{rk4qc(y,n,x1,step,eps,yscal,derivs)} is a subfunction for the numerical integration of an ordinary differential equation dy/dx = f(y,x) of \\spad{n} variables, where \\spad{y} is an n-vector using a 4-th order Runge-Kutta method. This function takes a 5-th order Runge-Kutta \\spad{step} with monitoring of local truncation to ensure accuracy and adjust stepsize. For details, see \\con{NumericalOrdinaryDifferentialEquations}.")) (|rk4a| (((|Void|) (|Vector| (|Float|)) (|Integer|) (|Float|) (|Float|) (|Float|) (|Float|) (|Integer|) (|Mapping| (|Void|) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Float|))) "\\spad{rk4a(y,n,x1,x2,eps,h,ns,derivs)} is a driver function for the numerical integration of an ordinary differential equation dy/dx = f(y,x) of \\spad{n} variables, where \\spad{y} is an n-vector using a 4-th order Runge-Kutta method. For details, see \\con{NumericalOrdinaryDifferentialEquations}.")) (|rk4| (((|Void|) (|Vector| (|Float|)) (|Integer|) (|Float|) (|Float|) (|Mapping| (|Void|) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Float|)) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Vector| (|Float|))) "\\spad{rk4(y,n,x1,h,derivs,t1,t2,t3,t4)} is the same as \\spad{rk4(y,n,x1,h,derivs)} except that you must provide 4 scratch arrays \\spad{t1-t4} of size \\spad{n.} For details, see \\con{NumericalOrdinaryDifferentialEquations}.") (((|Void|) (|Vector| (|Float|)) (|Integer|) (|Float|) (|Float|) (|Mapping| (|Void|) (|Vector| (|Float|)) (|Vector| (|Float|)) (|Float|))) "\\spad{rk4(y,n,x1,h,derivs)} uses a 4-th order Runge-Kutta method to numerically integrate the ordinary differential equation dy/dx = f(y,x) of \\spad{n} variables, where \\spad{y} is an n-vector. Argument \\spad{y} is a vector of initial conditions of length \\spad{n} which upon exit contains the solution at \\spad{x1 + \\spad{h},} \\spad{n} is the number of dependent variables, \\spad{x1} is the initial point, \\spad{h} is the step size, and \\spad{derivs} is a function which computes the right hand side of the ordinary differential equation. For details, see \\spadtype{NumericalOrdinaryDifferentialEquations}."))) 
NIL 
NIL 
(|NumericalQuadrature|) 
((|constructor| (NIL "This suite of routines performs numerical quadrature using algorithms derived from the basic trapezoidal rule. Because the error term of this rule contains only even powers of the step size (for open and closed versions), fast convergence can be obtained if the integrand is sufficiently smooth. \\blankline Each routine returns a Record of type TrapAns, which contains value Float: estimate of the integral error Float: estimate of the error in the computation totalpts Integer: total number of function evaluations success Boolean: if the integral was computed within the user specified error criterion To produce this estimate, each routine generates an internal sequence of sub-estimates, denoted by S(i), depending on the routine, to which the various convergence criteria are applied. The user must supply a relative accuracy, \\spad{eps_r}, and an absolute accuracy, \\spad{eps_a}. Convergence is obtained when either\\br \\tab{5}\\spad{ABS(S(i) - S(i-1)) < eps_r * ABS(S(i-1))}\\br \\tab{5}or \\spad{ABS(S(i) - S(i-1)) < eps_a} are \\spad{true} statements. \\blankline The routines come in three families and three flavors: closed: romberg, simpson, trapezoidal open: rombergo, simpsono, trapezoidalo adaptive closed: aromberg, asimpson, atrapezoidal \\blankline The S(i) for the trapezoidal family is the value of the integral using an equally spaced absicca trapezoidal rule for that level of refinement. \\blankline The S(i) for the simpson family is the value of the integral using an equally spaced absicca simpson rule for that level of refinement. \\blankline The S(i) for the romberg family is the estimate of the integral using an equally spaced absicca romberg method. For the \\spad{i}-th level, this is an appropriate combination of all the previous trapezodial estimates so that the error term starts with the 2*(i+1) power only. \\blankline The three families come in a closed version, where the formulas include the endpoints, an open version where the formulas do not include the endpoints and an adaptive version, where the user is required to input the number of subintervals over which the appropriate closed family integrator will apply with the usual convergence parmeters for each subinterval. This is useful where a large number of points are needed only in a small fraction of the entire domain. \\blankline Each routine takes as arguments:\\br \\spad{f} integrand\\br a starting point\\br \\spad{b} ending point\\br eps_r relative error\\br eps_a absolute error\\br nmin refinement level when to start checking for convergence \\spad{(>} 1)\\br nmax maximum level of refinement\\br \\blankline The adaptive routines take as an additional parameter, nint, the number of independent intervals to apply a closed family integrator of the same name. \\blankline")) (|trapezoidalo| (((|Record| (|:| |value| (|Float|)) (|:| |error| (|Float|)) (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|))) (|Mapping| (|Float|) (|Float|)) (|Float|) (|Float|) (|Float|) (|Float|) (|Integer|) (|Integer|)) "\\spad{trapezoidalo(fn,a,b,epsrel,epsabs,nmin,nmax)} uses the trapezoidal method to numerically integrate function \\spad{fn} over the open interval from \\spad{a} to \\spad{b}, with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs}, with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details.")) (|simpsono| (((|Record| (|:| |value| (|Float|)) (|:| |error| (|Float|)) (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|))) (|Mapping| (|Float|) (|Float|)) (|Float|) (|Float|) (|Float|) (|Float|) (|Integer|) (|Integer|)) "\\spad{simpsono(fn,a,b,epsrel,epsabs,nmin,nmax)} uses the simpson method to numerically integrate function \\spad{fn} over the open interval from \\spad{a} to \\spad{b}, with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs}, with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details.")) (|rombergo| (((|Record| (|:| |value| (|Float|)) (|:| |error| (|Float|)) (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|))) (|Mapping| (|Float|) (|Float|)) (|Float|) (|Float|) (|Float|) (|Float|) (|Integer|) (|Integer|)) "\\spad{rombergo(fn,a,b,epsrel,epsabs,nmin,nmax)} uses the romberg method to numerically integrate function \\spad{fn} over the open interval from \\spad{a} to \\spad{b}, with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs}, with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details.")) (|trapezoidal| (((|Record| (|:| |value| (|Float|)) (|:| |error| (|Float|)) (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|))) (|Mapping| (|Float|) (|Float|)) (|Float|) (|Float|) (|Float|) (|Float|) (|Integer|) (|Integer|)) "\\spad{trapezoidal(fn,a,b,epsrel,epsabs,nmin,nmax)} uses the trapezoidal method to numerically integrate function \\spadvar{fn} over the closed interval \\spad{a} to \\spad{b}, with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs}, with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details.")) (|simpson| (((|Record| (|:| |value| (|Float|)) (|:| |error| (|Float|)) (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|))) (|Mapping| (|Float|) (|Float|)) (|Float|) (|Float|) (|Float|) (|Float|) (|Integer|) (|Integer|)) "\\spad{simpson(fn,a,b,epsrel,epsabs,nmin,nmax)} uses the simpson method to numerically integrate function \\spad{fn} over the closed interval \\spad{a} to \\spad{b}, with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs}, with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details.")) (|romberg| (((|Record| (|:| |value| (|Float|)) (|:| |error| (|Float|)) (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|))) (|Mapping| (|Float|) (|Float|)) (|Float|) (|Float|) (|Float|) (|Float|) (|Integer|) (|Integer|)) "\\spad{romberg(fn,a,b,epsrel,epsabs,nmin,nmax)} uses the romberg method to numerically integrate function \\spadvar{fn} over the closed interval \\spad{a} to \\spad{b}, with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs}, with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details.")) (|atrapezoidal| (((|Record| (|:| |value| (|Float|)) (|:| |error| (|Float|)) (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|))) (|Mapping| (|Float|) (|Float|)) (|Float|) (|Float|) (|Float|) (|Float|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{atrapezoidal(fn,a,b,epsrel,epsabs,nmin,nmax,nint)} uses the adaptive trapezoidal method to numerically integrate function \\spad{fn} over the closed interval from \\spad{a} to \\spad{b}, with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs}, with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}, and where \\spad{nint} is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details.")) (|asimpson| (((|Record| (|:| |value| (|Float|)) (|:| |error| (|Float|)) (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|))) (|Mapping| (|Float|) (|Float|)) (|Float|) (|Float|) (|Float|) (|Float|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{asimpson(fn,a,b,epsrel,epsabs,nmin,nmax,nint)} uses the adaptive simpson method to numerically integrate function \\spad{fn} over the closed interval from \\spad{a} to \\spad{b}, with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs}, with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}, and where \\spad{nint} is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details.")) (|aromberg| (((|Record| (|:| |value| (|Float|)) (|:| |error| (|Float|)) (|:| |totalpts| (|Integer|)) (|:| |success| (|Boolean|))) (|Mapping| (|Float|) (|Float|)) (|Float|) (|Float|) (|Float|) (|Float|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{aromberg(fn,a,b,epsrel,epsabs,nmin,nmax,nint)} uses the adaptive romberg method to numerically integrate function \\spad{fn} over the closed interval from \\spad{a} to \\spad{b}, with relative accuracy \\spad{epsrel} and absolute accuracy \\spad{epsabs}, with the refinement levels for convergence checking vary from \\spad{nmin} to \\spad{nmax}, and where \\spad{nint} is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is \\spad{true} if the integral was computed within the user specified error criterion. See \\spadtype{NumericalQuadrature} for details."))) 
NIL 
NIL 
(|NumericTubePlot| |Curve|) 
((|constructor| (NIL "Package for constructing tubes around 3-dimensional parametric curves.")) (|tube| (((|TubePlot| |#1|) |#1| (|DoubleFloat|) (|Integer|)) "\\spad{tube(c,r,n)} creates a tube of radius \\spad{r} around the curve \\spad{c.}"))) 
NIL 
NIL 
(|OrderedAbelianGroup|) 
((|constructor| (NIL "Ordered sets which are also abelian groups, such that the addition preserves the ordering."))) 
NIL 
NIL 
(|OrderedAbelianMonoid|) 
((|constructor| (NIL "Ordered sets which are also abelian monoids, such that the addition preserves the ordering."))) 
NIL 
NIL 
(|OrderedAbelianMonoidSup|) 
((|constructor| (NIL "This domain is an OrderedAbelianMonoid with a sup operation added. The purpose of the sup operator in this domain is to act as a supremum with respect to the partial order imposed by `-`, rather than with respect to the total \\spad{$>$} order (since that is \"max\"). \\blankline Axioms\\br \\tab{5}sup(a,b)-a \\~~= \"failed\"\\br \\tab{5}sup(a,b)-b \\~~= \"failed\"\\br \\tab{5}x-a \\~~= \"failed\" and \\spad{x-b} \\~~= \"failed\" \\spad{=>} \\spad{x} \\spad{>=} sup(a,b)\\br")) (|sup| (($ $ $) "\\spad{sup(x,y)} returns the least element from which both \\spad{x} and \\spad{y} can be subtracted."))) 
NIL 
NIL 
(|OrderedAbelianSemiGroup|) 
((|constructor| (NIL "Ordered sets which are also abelian semigroups, such that the addition preserves the ordering.\\br \\blankline Axiom\\br \\tab{5} \\spad{x} < \\spad{y} \\spad{=>} \\spad{x+z} < \\spad{y+z}"))) 
NIL 
NIL 
(|OrderedCancellationAbelianMonoid|) 
((|constructor| (NIL "Ordered sets which are also abelian cancellation monoids, such that the addition preserves the ordering."))) 
NIL 
NIL 
(|OctonionCategory&| S R) 
((|constructor| (NIL "OctonionCategory gives the categorial frame for the octonions, and eight-dimensional non-associative algebra, doubling the the quaternions in the same way as doubling the Complex numbers to get the quaternions.")) (|inv| (($ $) "\\spad{inv(o)} returns the inverse of \\spad{o} if it exists.")) (|rationalIfCan| (((|Union| (|Fraction| (|Integer|)) "failed") $) "\\spad{rationalIfCan(o)} returns the real part if all seven imaginary parts are 0, and \"failed\" otherwise.")) (|rational| (((|Fraction| (|Integer|)) $) "\\spad{rational(o)} returns the real part if all seven imaginary parts are 0. Error: if \\spad{o} is not rational.")) (|rational?| (((|Boolean|) $) "\\spad{rational?(o)} tests if \\spad{o} is rational, \\spadignore{i.e.} that all seven imaginary parts are 0.")) (|abs| ((|#2| $) "\\spad{abs(o)} computes the absolute value of an octonion, equal to the square root of the \\spadfunFrom{norm}{Octonion}.")) (|octon| (($ |#2| |#2| |#2| |#2| |#2| |#2| |#2| |#2|) "\\spad{octon(re,ri,rj,rk,rE,rI,rJ,rK)} constructs an octonion from scalars.")) (|norm| ((|#2| $) "\\spad{norm(o)} returns the norm of an octonion, equal to the sum of the squares of its coefficients.")) (|imagK| ((|#2| $) "\\spad{imagK(o)} extracts the imaginary \\spad{K} part of octonion o.")) (|imagJ| ((|#2| $) "\\spad{imagJ(o)} extracts the imaginary \\spad{J} part of octonion o.")) (|imagI| ((|#2| $) "\\spad{imagI(o)} extracts the imaginary \\spad{I} part of octonion o.")) (|imagE| ((|#2| $) "\\spad{imagE(o)} extracts the imaginary \\spad{E} part of octonion o.")) (|imagk| ((|#2| $) "\\spad{imagk(o)} extracts the \\spad{k} part of octonion o.")) (|imagj| ((|#2| $) "\\spad{imagj(o)} extracts the \\spad{j} part of octonion o.")) (|imagi| ((|#2| $) "\\spad{imagi(o)} extracts the \\spad{i} part of octonion o.")) (|real| ((|#2| $) "\\spad{real(o)} extracts real part of octonion o.")) (|conjugate| (($ $) "\\spad{conjugate(o)} negates the imaginary parts i,j,k,E,I,J,K of octonian o."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#2| (QUOTE (|RealNumberSystem|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|Finite|)))) 
(|OctonionCategory| R) 
((|constructor| (NIL "OctonionCategory gives the categorial frame for the octonions, and eight-dimensional non-associative algebra, doubling the the quaternions in the same way as doubling the Complex numbers to get the quaternions.")) (|inv| (($ $) "\\spad{inv(o)} returns the inverse of \\spad{o} if it exists.")) (|rationalIfCan| (((|Union| (|Fraction| (|Integer|)) "failed") $) "\\spad{rationalIfCan(o)} returns the real part if all seven imaginary parts are 0, and \"failed\" otherwise.")) (|rational| (((|Fraction| (|Integer|)) $) "\\spad{rational(o)} returns the real part if all seven imaginary parts are 0. Error: if \\spad{o} is not rational.")) (|rational?| (((|Boolean|) $) "\\spad{rational?(o)} tests if \\spad{o} is rational, \\spadignore{i.e.} that all seven imaginary parts are 0.")) (|abs| ((|#1| $) "\\spad{abs(o)} computes the absolute value of an octonion, equal to the square root of the \\spadfunFrom{norm}{Octonion}.")) (|octon| (($ |#1| |#1| |#1| |#1| |#1| |#1| |#1| |#1|) "\\spad{octon(re,ri,rj,rk,rE,rI,rJ,rK)} constructs an octonion from scalars.")) (|norm| ((|#1| $) "\\spad{norm(o)} returns the norm of an octonion, equal to the sum of the squares of its coefficients.")) (|imagK| ((|#1| $) "\\spad{imagK(o)} extracts the imaginary \\spad{K} part of octonion o.")) (|imagJ| ((|#1| $) "\\spad{imagJ(o)} extracts the imaginary \\spad{J} part of octonion o.")) (|imagI| ((|#1| $) "\\spad{imagI(o)} extracts the imaginary \\spad{I} part of octonion o.")) (|imagE| ((|#1| $) "\\spad{imagE(o)} extracts the imaginary \\spad{E} part of octonion o.")) (|imagk| ((|#1| $) "\\spad{imagk(o)} extracts the \\spad{k} part of octonion o.")) (|imagj| ((|#1| $) "\\spad{imagj(o)} extracts the \\spad{j} part of octonion o.")) (|imagi| ((|#1| $) "\\spad{imagi(o)} extracts the \\spad{i} part of octonion o.")) (|real| ((|#1| $) "\\spad{real(o)} extracts real part of octonion o.")) (|conjugate| (($ $) "\\spad{conjugate(o)} negates the imaginary parts i,j,k,E,I,J,K of octonian o."))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|OctonionCategoryFunctions2| OR R OS S) 
((|constructor| (NIL "\\spad{OctonionCategoryFunctions2} implements functions between two octonion domains defined over different rings. The function map is used to coerce between octonion types.")) (|map| ((|#3| (|Mapping| |#4| |#2|) |#1|) "\\spad{map(f,u)} maps \\spad{f} onto the component parts of the octonion u."))) 
NIL 
NIL 
(|Octonion| R) 
((|constructor| (NIL "Octonion implements octonions (Cayley-Dixon algebra) over a commutative ring, an eight-dimensional non-associative algebra, doubling the quaternions in the same way as doubling the complex numbers to get the quaternions the main constructor function is octon which takes 8 arguments: the real part, the \\spad{i} imaginary part, the \\spad{j} imaginary part, the \\spad{k} imaginary part, (as with quaternions) and in addition the imaginary parts E, I, \\spad{J,} \\spad{K.}")) (|octon| (($ (|Quaternion| |#1|) (|Quaternion| |#1|)) "\\spad{octon(qe,qE)} constructs an octonion from two quaternions using the relation \\spad{O} = \\spad{Q} + QE."))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#1| (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (|devaluate| |#1|))) (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (LIST (QUOTE |Eltable|) (|devaluate| |#1|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|RealNumberSystem|))) (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| (|Quaternion| |#1|) (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| (|Quaternion| |#1|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (OR (|HasCategory| (|Quaternion| |#1|) (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (OR (|HasCategory| (|Quaternion| |#1|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))))) 
(|OrdinaryDifferentialEquationsSolverCategory|) 
((|constructor| (NIL "\\axiomType{OrdinaryDifferentialEquationsSolverCategory} is the \\axiom{category} for describing the set of ODE solver \\axiom{domains} with \\axiomFun{measure} and \\axiomFun{ODEsolve}.")) (|ODESolve| (((|Result|) (|Record| (|:| |xinit| (|DoubleFloat|)) (|:| |xend| (|DoubleFloat|)) (|:| |fn| (|Vector| (|Expression| (|DoubleFloat|)))) (|:| |yinit| (|List| (|DoubleFloat|))) (|:| |intvals| (|List| (|DoubleFloat|))) (|:| |g| (|Expression| (|DoubleFloat|))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{ODESolve(args)} performs the integration of the function given the strategy or method returned by \\axiomFun{measure}.")) (|measure| (((|Record| (|:| |measure| (|Float|)) (|:| |explanations| (|String|))) (|RoutinesTable|) (|Record| (|:| |xinit| (|DoubleFloat|)) (|:| |xend| (|DoubleFloat|)) (|:| |fn| (|Vector| (|Expression| (|DoubleFloat|)))) (|:| |yinit| (|List| (|DoubleFloat|))) (|:| |intvals| (|List| (|DoubleFloat|))) (|:| |g| (|Expression| (|DoubleFloat|))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{measure(R,args)} calculates an estimate of the ability of a particular method to solve a problem. \\blankline This method may be either a specific NAG routine or a strategy (such as transforming the function from one which is difficult to one which is easier to solve). \\blankline It will call whichever agents are needed to perform analysis on the problem in order to calculate the measure. There is a parameter, labelled \\axiom{sofar}, which would contain the best compatibility found so far."))) 
NIL 
NIL 
(|ConstantLODE| R F L) 
((|constructor| (NIL "Solution of linear ordinary differential equations, constant coefficient case.")) (|constDsolve| (((|Record| (|:| |particular| |#2|) (|:| |basis| (|List| |#2|))) |#3| |#2| (|Symbol|)) "\\spad{constDsolve(op, \\spad{g,} \\spad{x)}} returns \\spad{[f, [y1,...,ym]]} where \\spad{f} is a particular solution of the equation \\spad{op \\spad{y} = \\spad{g},} and the \\spad{yi}'s form a basis for the solutions of \\spad{op \\spad{y} = 0}."))) 
NIL 
NIL 
(|ElementaryFunctionODESolver| R F) 
((|constructor| (NIL "\\spad{ElementaryFunctionODESolver} provides the top-level functions for finding closed form solutions of ordinary differential equations and initial value problems.")) (|solve| (((|Union| |#2| "failed") |#2| (|BasicOperator|) (|Equation| |#2|) (|List| |#2|)) "\\spad{solve(eq, \\spad{y,} \\spad{x} = a, [y0,...,ym])} returns either the solution of the initial value problem \\spad{eq, y(a) = \\spad{y0,} y'(a) = y1,...} or \"failed\" if the solution cannot be found; error if the equation is not one linear ordinary or of the form \\spad{dy/dx = f(x,y)}.") (((|Union| |#2| "failed") (|Equation| |#2|) (|BasicOperator|) (|Equation| |#2|) (|List| |#2|)) "\\spad{solve(eq, \\spad{y,} \\spad{x} = a, [y0,...,ym])} returns either the solution of the initial value problem \\spad{eq, y(a) = \\spad{y0,} y'(a) = y1,...} or \"failed\" if the solution cannot be found; error if the equation is not one linear ordinary or of the form \\spad{dy/dx = f(x,y)}.") (((|Union| (|Record| (|:| |particular| |#2|) (|:| |basis| (|List| |#2|))) |#2| "failed") |#2| (|BasicOperator|) (|Symbol|)) "\\spad{solve(eq, \\spad{y,} \\spad{x)}} returns either a solution of the ordinary differential equation \\spad{eq} or \"failed\" if no non-trivial solution can be found; If the equation is linear ordinary, a solution is of the form \\spad{[h, [b1,...,bm]]} where \\spad{h} is a particular solution and and \\spad{[b1,...bm]} are linearly independent solutions of the associated homogenuous equation \\spad{f(x,y) = 0}; A full basis for the solutions of the homogenuous equation is not always returned, only the solutions which were found; If the equation is of the form {dy/dx = f(x,y)}, a solution is of the form \\spad{h(x,y)} where \\spad{h(x,y) = \\spad{c}} is a first integral of the equation for any constant \\spad{c}.") (((|Union| (|Record| (|:| |particular| |#2|) (|:| |basis| (|List| |#2|))) |#2| "failed") (|Equation| |#2|) (|BasicOperator|) (|Symbol|)) "\\spad{solve(eq, \\spad{y,} \\spad{x)}} returns either a solution of the ordinary differential equation \\spad{eq} or \"failed\" if no non-trivial solution can be found; If the equation is linear ordinary, a solution is of the form \\spad{[h, [b1,...,bm]]} where \\spad{h} is a particular solution and \\spad{[b1,...bm]} are linearly independent solutions of the associated homogenuous equation \\spad{f(x,y) = 0}; A full basis for the solutions of the homogenuous equation is not always returned, only the solutions which were found; If the equation is of the form {dy/dx = f(x,y)}, a solution is of the form \\spad{h(x,y)} where \\spad{h(x,y) = \\spad{c}} is a first integral of the equation for any constant \\spad{c}; error if the equation is not one of those 2 forms.") (((|Union| (|Record| (|:| |particular| (|Vector| |#2|)) (|:| |basis| (|List| (|Vector| |#2|)))) "failed") (|List| |#2|) (|List| (|BasicOperator|)) (|Symbol|)) "\\spad{solve([eq_1,...,eq_n], [y_1,...,y_n], \\spad{x)}} returns either \"failed\" or, if the equations form a fist order linear system, a solution of the form \\spad{[y_p, [b_1,...,b_n]]} where \\spad{h_p} is a particular solution and \\spad{[b_1,...b_m]} are linearly independent solutions of the associated homogenuous system. error if the equations do not form a first order linear system") (((|Union| (|Record| (|:| |particular| (|Vector| |#2|)) (|:| |basis| (|List| (|Vector| |#2|)))) "failed") (|List| (|Equation| |#2|)) (|List| (|BasicOperator|)) (|Symbol|)) "\\spad{solve([eq_1,...,eq_n], [y_1,...,y_n], \\spad{x)}} returns either \"failed\" or, if the equations form a fist order linear system, a solution of the form \\spad{[y_p, [b_1,...,b_n]]} where \\spad{h_p} is a particular solution and \\spad{[b_1,...b_m]} are linearly independent solutions of the associated homogenuous system. error if the equations do not form a first order linear system") (((|Union| (|List| (|Vector| |#2|)) "failed") (|Matrix| |#2|) (|Symbol|)) "\\spad{solve(m, \\spad{x)}} returns a basis for the solutions of \\spad{D \\spad{y} = \\spad{m} \\spad{y}.} \\spad{x} is the dependent variable.") (((|Union| (|Record| (|:| |particular| (|Vector| |#2|)) (|:| |basis| (|List| (|Vector| |#2|)))) "failed") (|Matrix| |#2|) (|Vector| |#2|) (|Symbol|)) "\\spad{solve(m, \\spad{v,} \\spad{x)}} returns \\spad{[v_p, [v_1,...,v_m]]} such that the solutions of the system \\spad{D \\spad{y} = \\spad{m} \\spad{y} + \\spad{v}} are \\spad{v_p + \\spad{c_1} \\spad{v_1} + \\spad{...} + \\spad{c_m} v_m} where the \\spad{c_i's} are constants, and the \\spad{v_i's} form a basis for the solutions of \\spad{D \\spad{y} = \\spad{m} \\spad{y}.} \\spad{x} is the dependent variable."))) 
NIL 
NIL 
(|ODEIntensityFunctionsTable|) 
((|constructor| (NIL "\\axiom{ODEIntensityFunctionsTable()} provides a dynamic table and a set of functions to store details found out about sets of ODE's.")) (|showIntensityFunctions| (((|Union| (|Record| (|:| |stiffness| (|Float|)) (|:| |stability| (|Float|)) (|:| |expense| (|Float|)) (|:| |accuracy| (|Float|)) (|:| |intermediateResults| (|Float|))) "failed") (|Record| (|:| |xinit| (|DoubleFloat|)) (|:| |xend| (|DoubleFloat|)) (|:| |fn| (|Vector| (|Expression| (|DoubleFloat|)))) (|:| |yinit| (|List| (|DoubleFloat|))) (|:| |intvals| (|List| (|DoubleFloat|))) (|:| |g| (|Expression| (|DoubleFloat|))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{showIntensityFunctions(k)} returns the entries in the table of intensity functions \\spad{k.}")) (|insert!| (($ (|Record| (|:| |key| (|Record| (|:| |xinit| (|DoubleFloat|)) (|:| |xend| (|DoubleFloat|)) (|:| |fn| (|Vector| (|Expression| (|DoubleFloat|)))) (|:| |yinit| (|List| (|DoubleFloat|))) (|:| |intvals| (|List| (|DoubleFloat|))) (|:| |g| (|Expression| (|DoubleFloat|))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) (|:| |entry| (|Record| (|:| |stiffness| (|Float|)) (|:| |stability| (|Float|)) (|:| |expense| (|Float|)) (|:| |accuracy| (|Float|)) (|:| |intermediateResults| (|Float|)))))) "\\spad{insert!(r)} inserts an entry \\spad{r} into theIFTable")) (|iFTable| (($ (|List| (|Record| (|:| |key| (|Record| (|:| |xinit| (|DoubleFloat|)) (|:| |xend| (|DoubleFloat|)) (|:| |fn| (|Vector| (|Expression| (|DoubleFloat|)))) (|:| |yinit| (|List| (|DoubleFloat|))) (|:| |intvals| (|List| (|DoubleFloat|))) (|:| |g| (|Expression| (|DoubleFloat|))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) (|:| |entry| (|Record| (|:| |stiffness| (|Float|)) (|:| |stability| (|Float|)) (|:| |expense| (|Float|)) (|:| |accuracy| (|Float|)) (|:| |intermediateResults| (|Float|))))))) "\\spad{iFTable(l)} creates an intensity-functions table from the elements of \\spad{l.}")) (|keys| (((|List| (|Record| (|:| |xinit| (|DoubleFloat|)) (|:| |xend| (|DoubleFloat|)) (|:| |fn| (|Vector| (|Expression| (|DoubleFloat|)))) (|:| |yinit| (|List| (|DoubleFloat|))) (|:| |intvals| (|List| (|DoubleFloat|))) (|:| |g| (|Expression| (|DoubleFloat|))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) $) "\\spad{keys(tab)} returns the list of keys of \\spad{f}")) (|clearTheIFTable| (((|Void|)) "\\spad{clearTheIFTable()} clears the current table of intensity functions.")) (|showTheIFTable| (($) "\\spad{showTheIFTable()} returns the current table of intensity functions."))) 
NIL 
NIL 
(|ODEIntegration| R F) 
((|constructor| (NIL "\\spadtype{ODEIntegration} provides an interface to the integrator. This package is intended for use by the differential equations solver but not at top-level.")) (|diff| (((|Mapping| |#2| |#2|) (|Symbol|)) "\\spad{diff(x)} returns the derivation with respect to \\spad{x.}")) (|expint| ((|#2| |#2| (|Symbol|)) "\\spad{expint(f, \\spad{x)}} returns e^{the integral of \\spad{f} with respect to \\spad{x}.}")) (|int| ((|#2| |#2| (|Symbol|)) "\\spad{int(f, \\spad{x)}} returns the integral of \\spad{f} with respect to \\spad{x.}"))) 
NIL 
NIL 
(|AnnaOrdinaryDifferentialEquationPackage|) 
((|constructor| (NIL "\\axiomType{AnnaOrdinaryDifferentialEquationPackage} is a \\axiom{package} of functions for the \\axiom{category} \\axiomType{OrdinaryDifferentialEquationsSolverCategory} with \\axiom{measure}, and \\axiom{solve}.")) (|measure| (((|Record| (|:| |measure| (|Float|)) (|:| |name| (|String|)) (|:| |explanations| (|List| (|String|)))) (|NumericalODEProblem|) (|RoutinesTable|)) "\\spad{measure(prob,R)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical ODE problem defined by \\axiom{prob}. \\blankline It calls each \\axiom{domain} listed in \\axiom{R} of \\axiom{category} \\axiomType{OrdinaryDifferentialEquationsSolverCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information. It predicts the likely most effective NAG numerical Library routine to solve the input set of ODEs by checking various attributes of the system of ODEs and calculating a measure of compatibility of each routine to these attributes.") (((|Record| (|:| |measure| (|Float|)) (|:| |name| (|String|)) (|:| |explanations| (|List| (|String|)))) (|NumericalODEProblem|)) "\\spad{measure(prob)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical ODE problem defined by \\axiom{prob}. \\blankline It calls each \\axiom{domain} of \\axiom{category} \\axiomType{OrdinaryDifferentialEquationsSolverCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information. It predicts the likely most effective NAG numerical Library routine to solve the input set of ODEs by checking various attributes of the system of ODEs and calculating a measure of compatibility of each routine to these attributes.")) (|solve| (((|Result|) (|Vector| (|Expression| (|Float|))) (|Float|) (|Float|) (|List| (|Float|)) (|Expression| (|Float|)) (|List| (|Float|)) (|Float|) (|Float|)) "\\spad{solve(f,xStart,xEnd,yInitial,G,intVals,epsabs,epsrel)} is a top level ANNA function to solve numerically a system of ordinary differential equations, \\axiom{f}, \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n] from \\axiom{xStart} to \\axiom{xEnd} with the initial values for y[1]..y[n] (\\axiom{yInitial}) to an absolute error requirement \\axiom{epsabs} and relative error \\axiom{epsrel}. The values of y[1]..y[n] will be output for the values of \\spad{x} in \\axiom{intVals}. The calculation will stop if the function G(x,y[1],..,y[n]) evaluates to zero before \\spad{x} = xEnd. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine.") (((|Result|) (|Vector| (|Expression| (|Float|))) (|Float|) (|Float|) (|List| (|Float|)) (|Expression| (|Float|)) (|List| (|Float|)) (|Float|)) "\\spad{solve(f,xStart,xEnd,yInitial,G,intVals,tol)} is a top level ANNA function to solve numerically a system of ordinary differential equations, \\axiom{f}, \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n] from \\axiom{xStart} to \\axiom{xEnd} with the initial values for y[1]..y[n] (\\axiom{yInitial}) to a tolerance \\axiom{tol}. The values of y[1]..y[n] will be output for the values of \\spad{x} in \\axiom{intVals}. The calculation will stop if the function G(x,y[1],..,y[n]) evaluates to zero before \\spad{x} = xEnd. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine.") (((|Result|) (|Vector| (|Expression| (|Float|))) (|Float|) (|Float|) (|List| (|Float|)) (|List| (|Float|)) (|Float|)) "\\spad{solve(f,xStart,xEnd,yInitial,intVals,tol)} is a top level ANNA function to solve numerically a system of ordinary differential equations, \\axiom{f}, \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n] from \\axiom{xStart} to \\axiom{xEnd} with the initial values for y[1]..y[n] (\\axiom{yInitial}) to a tolerance \\axiom{tol}. The values of y[1]..y[n] will be output for the values of \\spad{x} in \\axiom{intVals}. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine.") (((|Result|) (|Vector| (|Expression| (|Float|))) (|Float|) (|Float|) (|List| (|Float|)) (|Expression| (|Float|)) (|Float|)) "\\spad{solve(f,xStart,xEnd,yInitial,G,tol)} is a top level ANNA function to solve numerically a system of ordinary differential equations, \\axiom{f}, \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n] from \\axiom{xStart} to \\axiom{xEnd} with the initial values for y[1]..y[n] (\\axiom{yInitial}) to a tolerance \\axiom{tol}. The calculation will stop if the function G(x,y[1],..,y[n]) evaluates to zero before \\spad{x} = xEnd. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine.") (((|Result|) (|Vector| (|Expression| (|Float|))) (|Float|) (|Float|) (|List| (|Float|)) (|Float|)) "\\spad{solve(f,xStart,xEnd,yInitial,tol)} is a top level ANNA function to solve numerically a system of ordinary differential equations, \\axiom{f}, \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n] from \\axiom{xStart} to \\axiom{xEnd} with the initial values for y[1]..y[n] (\\axiom{yInitial}) to a tolerance \\axiom{tol}. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine.") (((|Result|) (|Vector| (|Expression| (|Float|))) (|Float|) (|Float|) (|List| (|Float|))) "\\spad{solve(f,xStart,xEnd,yInitial)} is a top level ANNA function to solve numerically a system of ordinary differential equations \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n], together with a starting value for \\spad{x} and y[1]..y[n] (called the initial conditions) and a final value of \\spad{x.} A default value is used for the accuracy requirement. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine.") (((|Result|) (|NumericalODEProblem|) (|RoutinesTable|)) "\\spad{solve(odeProblem,R)} is a top level ANNA function to solve numerically a system of ordinary differential equations \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n], together with starting values for \\spad{x} and y[1]..y[n] (called the initial conditions), a final value of \\spad{x,} an accuracy requirement and any intermediate points at which the result is required. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \\axiom{R} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine.") (((|Result|) (|NumericalODEProblem|)) "\\spad{solve(odeProblem)} is a top level ANNA function to solve numerically a system of ordinary differential equations \\spadignore{i.e.} equations for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n], together with starting values for \\spad{x} and y[1]..y[n] (called the initial conditions), a final value of \\spad{x,} an accuracy requirement and any intermediate points at which the result is required. \\blankline It iterates over the \\axiom{domains} of \\axiomType{OrdinaryDifferentialEquationsSolverCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate, \\spadignore{i.e.} have the best \\axiom{measure}. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine."))) 
NIL 
NIL 
(|PureAlgebraicLODE| F UP UPUP R) 
((|constructor| (NIL "In-field solution of an linear ordinary differential equation, pure algebraic case.")) (|algDsolve| (((|Record| (|:| |particular| (|Union| |#4| "failed")) (|:| |basis| (|List| |#4|))) (|LinearOrdinaryDifferentialOperator1| |#4|) |#4|) "\\spad{algDsolve(op, \\spad{g)}} returns \\spad{[\"failed\", []]} if the equation \\spad{op \\spad{y} = \\spad{g}} has no solution in \\spad{R}. Otherwise, it returns \\spad{[f, [y1,...,ym]]} where \\spad{f} is a particular rational solution and the \\spad{y_i's} form a basis for the solutions in \\spad{R} of the homogeneous equation."))) 
NIL 
NIL 
(|PrimitiveRatDE| F UP L LQ) 
((|constructor| (NIL "\\spad{PrimitiveRatDE} provides functions for in-field solutions of linear ordinary differential equations, in the transcendental case. The derivation to use is given by the parameter \\spad{L}.")) (|splitDenominator| (((|Record| (|:| |eq| |#3|) (|:| |rh| (|List| (|Fraction| |#2|)))) |#4| (|List| (|Fraction| |#2|))) "\\spad{splitDenominator(op, [g1,...,gm])} returns \\spad{op0, [h1,...,hm]} such that the equations \\spad{op \\spad{y} = \\spad{c1} \\spad{g1} + \\spad{...} + \\spad{cm} \\spad{gm}} and \\spad{op0 \\spad{y} = \\spad{c1} \\spad{h1} + \\spad{...} + \\spad{cm} \\spad{hm}} have the same solutions.")) (|indicialEquation| ((|#2| |#4| |#1|) "\\spad{indicialEquation(op, a)} returns the indicial equation of \\spad{op} at \\spad{a}.") ((|#2| |#3| |#1|) "\\spad{indicialEquation(op, a)} returns the indicial equation of \\spad{op} at \\spad{a}.")) (|indicialEquations| (((|List| (|Record| (|:| |center| |#2|) (|:| |equation| |#2|))) |#4| |#2|) "\\spad{indicialEquations(op, \\spad{p)}} returns \\spad{[[d1,e1],...,[dq,eq]]} where the \\spad{d_i}'s are the affine singularities of \\spad{op} above the roots of \\spad{p}, and the \\spad{e_i}'s are the indicial equations at each \\spad{d_i}.") (((|List| (|Record| (|:| |center| |#2|) (|:| |equation| |#2|))) |#4|) "\\spad{indicialEquations op} returns \\spad{[[d1,e1],...,[dq,eq]]} where the \\spad{d_i}'s are the affine singularities of \\spad{op}, and the \\spad{e_i}'s are the indicial equations at each \\spad{d_i}.") (((|List| (|Record| (|:| |center| |#2|) (|:| |equation| |#2|))) |#3| |#2|) "\\spad{indicialEquations(op, \\spad{p)}} returns \\spad{[[d1,e1],...,[dq,eq]]} where the \\spad{d_i}'s are the affine singularities of \\spad{op} above the roots of \\spad{p}, and the \\spad{e_i}'s are the indicial equations at each \\spad{d_i}.") (((|List| (|Record| (|:| |center| |#2|) (|:| |equation| |#2|))) |#3|) "\\spad{indicialEquations op} returns \\spad{[[d1,e1],...,[dq,eq]]} where the \\spad{d_i}'s are the affine singularities of \\spad{op}, and the \\spad{e_i}'s are the indicial equations at each \\spad{d_i}.")) (|denomLODE| ((|#2| |#3| (|List| (|Fraction| |#2|))) "\\spad{denomLODE(op, [g1,...,gm])} returns a polynomial \\spad{d} such that any rational solution of \\spad{op \\spad{y} = \\spad{c1} \\spad{g1} + \\spad{...} + \\spad{cm} \\spad{gm}} is of the form \\spad{p/d} for some polynomial \\spad{p.}") (((|Union| |#2| "failed") |#3| (|Fraction| |#2|)) "\\spad{denomLODE(op, \\spad{g)}} returns a polynomial \\spad{d} such that any rational solution of \\spad{op \\spad{y} = \\spad{g}} is of the form \\spad{p/d} for some polynomial \\spad{p,} and \"failed\", if the equation has no rational solution."))) 
NIL 
NIL 
(|NumericalODEProblem|) 
((|constructor| (NIL "\\axiomType{NumericalODEProblem} is a \\axiom{domain} for the representation of Numerical ODE problems for use by ANNA. \\blankline The representation is of type: \\blankline \\axiomType{Record}(xinit:\\axiomType{DoubleFloat},\\br xend:\\axiomType{DoubleFloat},\\br fn:\\axiomType{Vector Expression DoubleFloat},\\br yinit:\\axiomType{List DoubleFloat},intvals:\\axiomType{List DoubleFloat},\\br g:\\axiomType{Expression DoubleFloat},abserr:\\axiomType{DoubleFloat},\\br relerr:\\axiomType{DoubleFloat}) \\blankline")) (|retract| (((|Record| (|:| |xinit| (|DoubleFloat|)) (|:| |xend| (|DoubleFloat|)) (|:| |fn| (|Vector| (|Expression| (|DoubleFloat|)))) (|:| |yinit| (|List| (|DoubleFloat|))) (|:| |intvals| (|List| (|DoubleFloat|))) (|:| |g| (|Expression| (|DoubleFloat|))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|))) $) "\\spad{retract(x)} is not documented")) (|coerce| (((|OutputForm|) $) "\\spad{coerce(x)} is not documented") (($ (|Record| (|:| |xinit| (|DoubleFloat|)) (|:| |xend| (|DoubleFloat|)) (|:| |fn| (|Vector| (|Expression| (|DoubleFloat|)))) (|:| |yinit| (|List| (|DoubleFloat|))) (|:| |intvals| (|List| (|DoubleFloat|))) (|:| |g| (|Expression| (|DoubleFloat|))) (|:| |abserr| (|DoubleFloat|)) (|:| |relerr| (|DoubleFloat|)))) "\\spad{coerce(x)} is not documented"))) 
NIL 
NIL 
(|PrimitiveRatRicDE| F UP L LQ) 
((|constructor| (NIL "In-field solution of Riccati equations, primitive case.")) (|changeVar| ((|#3| |#3| (|Fraction| |#2|)) "\\spad{changeVar(+/[ai D^i], a)} returns the operator \\spad{+/[ai (D+a)^i]}.") ((|#3| |#3| |#2|) "\\spad{changeVar(+/[ai D^i], a)} returns the operator \\spad{+/[ai (D+a)^i]}.")) (|singRicDE| (((|List| (|Record| (|:| |frac| (|Fraction| |#2|)) (|:| |eq| |#3|))) |#3| (|Mapping| (|List| |#2|) |#2| (|SparseUnivariatePolynomial| |#2|)) (|Mapping| (|Factored| |#2|) |#2|)) "\\spad{singRicDE(op, zeros, ezfactor)} returns \\spad{[[f1, L1], [f2, L2], \\spad{...} ,{} [fk, Lk]]} such that the singular part of any rational solution of the associated Riccati equation of \\spad{op y=0} must be one of the fi's (up to the constant coefficient), in which case the equation for \\spad{z=y e^{-int \\spad{p}}} is \\spad{Li z=0}. \\spad{zeros(C(x),H(x,y))} returns all the \\spad{P_i(x)}'s such that \\spad{H(x,P_i(x)) = 0 modulo C(x)}. Argument \\spad{ezfactor} is a factorisation in \\spad{UP}, not necessarily into irreducibles.")) (|polyRicDE| (((|List| (|Record| (|:| |poly| |#2|) (|:| |eq| |#3|))) |#3| (|Mapping| (|List| |#1|) |#2|)) "\\spad{polyRicDE(op, zeros)} returns \\spad{[[p1, L1], [p2, L2], \\spad{...} ,{} [pk, Lk]]} such that the polynomial part of any rational solution of the associated Riccati equation of \\spad{op y=0} must be one of the pi's (up to the constant coefficient), in which case the equation for \\spad{z=y e^{-int \\spad{p}}} is \\spad{Li \\spad{z} =0}. \\spad{zeros} is a zero finder in \\spad{UP}.")) (|constantCoefficientRicDE| (((|List| (|Record| (|:| |constant| |#1|) (|:| |eq| |#3|))) |#3| (|Mapping| (|List| |#1|) |#2|)) "\\spad{constantCoefficientRicDE(op, ric)} returns \\spad{[[a1, L1], [a2, L2], \\spad{...} ,{} [ak, Lk]]} such that any rational solution with no polynomial part of the associated Riccati equation of \\spad{op \\spad{y} = 0} must be one of the ai's in which case the equation for \\spad{z = \\spad{y} e^{-int ai}} is \\spad{Li \\spad{z} = 0}. \\spad{ric} is a Riccati equation solver over \\spad{F}, whose input is the associated linear equation.")) (|leadingCoefficientRicDE| (((|List| (|Record| (|:| |deg| (|NonNegativeInteger|)) (|:| |eq| |#2|))) |#3|) "\\spad{leadingCoefficientRicDE(op)} returns \\spad{[[m1, p1], [m2, p2], \\spad{...} ,{} [mk, pk]]} such that the polynomial part of any rational solution of the associated Riccati equation of \\spad{op \\spad{y} = 0} must have degree \\spad{mj} for some \\spad{j,} and its leading coefficient is then a zero of \\spad{pj.} In addition,\\spad{m1>m2> \\spad{...} >mk}.")) (|denomRicDE| ((|#2| |#3|) "\\spad{denomRicDE(op)} returns a polynomial \\spad{d} such that any rational solution of the associated Riccati equation of \\spad{op \\spad{y} = 0} is of the form \\spad{p/d + q'/q + \\spad{r}} for some polynomials \\spad{p} and \\spad{q} and a reduced \\spad{r.} Also, \\spad{deg(p) < deg(d)} and {gcd(d,q) = 1}."))) 
NIL 
NIL 
(|RationalLODE| F UP) 
((|constructor| (NIL "\\spad{RationalLODE} provides functions for in-field solutions of linear ordinary differential equations, in the rational case.")) (|indicialEquationAtInfinity| ((|#2| (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|))) "\\spad{indicialEquationAtInfinity op} returns the indicial equation of \\spad{op} at infinity.") ((|#2| (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))) "\\spad{indicialEquationAtInfinity op} returns the indicial equation of \\spad{op} at infinity.")) (|ratDsolve| (((|Record| (|:| |basis| (|List| (|Fraction| |#2|))) (|:| |mat| (|Matrix| |#1|))) (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|)) (|List| (|Fraction| |#2|))) "\\spad{ratDsolve(op, [g1,...,gm])} returns \\spad{[[h1,...,hq], \\spad{M]}} such that any rational solution of \\spad{op \\spad{y} = \\spad{c1} \\spad{g1} + \\spad{...} + \\spad{cm} \\spad{gm}} is of the form \\spad{d1 \\spad{h1} + \\spad{...} + \\spad{dq} \\spad{hq}} where \\spad{M [d1,...,dq,c1,...,cm] = 0}.") (((|Record| (|:| |particular| (|Union| (|Fraction| |#2|) "failed")) (|:| |basis| (|List| (|Fraction| |#2|)))) (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|)) (|Fraction| |#2|)) "\\spad{ratDsolve(op, \\spad{g)}} returns \\spad{[\"failed\", []]} if the equation \\spad{op \\spad{y} = \\spad{g}} has no rational solution. Otherwise, it returns \\spad{[f, [y1,...,ym]]} where \\spad{f} is a particular rational solution and the yi's form a basis for the rational solutions of the homogeneous equation.") (((|Record| (|:| |basis| (|List| (|Fraction| |#2|))) (|:| |mat| (|Matrix| |#1|))) (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)) (|List| (|Fraction| |#2|))) "\\spad{ratDsolve(op, [g1,...,gm])} returns \\spad{[[h1,...,hq], \\spad{M]}} such that any rational solution of \\spad{op \\spad{y} = \\spad{c1} \\spad{g1} + \\spad{...} + \\spad{cm} \\spad{gm}} is of the form \\spad{d1 \\spad{h1} + \\spad{...} + \\spad{dq} \\spad{hq}} where \\spad{M [d1,...,dq,c1,...,cm] = 0}.") (((|Record| (|:| |particular| (|Union| (|Fraction| |#2|) "failed")) (|:| |basis| (|List| (|Fraction| |#2|)))) (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)) (|Fraction| |#2|)) "\\spad{ratDsolve(op, \\spad{g)}} returns \\spad{[\"failed\", []]} if the equation \\spad{op \\spad{y} = \\spad{g}} has no rational solution. Otherwise, it returns \\spad{[f, [y1,...,ym]]} where \\spad{f} is a particular rational solution and the yi's form a basis for the rational solutions of the homogeneous equation."))) 
NIL 
NIL 
(|ReduceLODE| F L UP A LO) 
((|constructor| (NIL "Elimination of an algebraic from the coefficentss of a linear ordinary differential equation.")) (|reduceLODE| (((|Record| (|:| |mat| (|Matrix| |#2|)) (|:| |vec| (|Vector| |#1|))) |#5| |#4|) "\\spad{reduceLODE(op, \\spad{g)}} returns \\spad{[m, \\spad{v]}} such that any solution in \\spad{A} of \\spad{op \\spad{z} = \\spad{g}} is of the form \\spad{z = (z_1,...,z_m) . (b_1,...,b_m)} where the \\spad{b_i's} are the basis of \\spad{A} over \\spad{F} returned by \\spadfun{basis}() from \\spad{A}, and the \\spad{z_i's} satisfy the differential system \\spad{M.z = \\spad{v}.}"))) 
NIL 
NIL 
(|RationalRicDE| F UP) 
((|constructor| (NIL "In-field solution of Riccati equations, rational case.")) (|polyRicDE| (((|List| (|Record| (|:| |poly| |#2|) (|:| |eq| (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|))))) (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|)) (|Mapping| (|List| |#1|) |#2|)) "\\spad{polyRicDE(op, zeros)} returns \\spad{[[p1,L1], [p2,L2], \\spad{...} ,{} [pk,Lk]]} such that the polynomial part of any rational solution of the associated Riccati equation of \\spad{op \\spad{y} = 0} must be one of the pi's (up to the constant coefficient), in which case the equation for \\spad{z = \\spad{y} e^{-int \\spad{p}}} is \\spad{Li \\spad{z} = 0}. \\spad{zeros} is a zero finder in \\spad{UP}.")) (|singRicDE| (((|List| (|Record| (|:| |frac| (|Fraction| |#2|)) (|:| |eq| (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|))))) (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|)) (|Mapping| (|Factored| |#2|) |#2|)) "\\spad{singRicDE(op, ezfactor)} returns \\spad{[[f1,L1], [f2,L2],..., [fk,Lk]]} such that the singular \\spad{++} part of any rational solution of the associated Riccati equation of \\spad{op \\spad{y} = 0} must be one of the fi's (up to the constant coefficient), in which case the equation for \\spad{z = \\spad{y} e^{-int ai}} is \\spad{Li \\spad{z} = 0}. Argument \\spad{ezfactor} is a factorisation in \\spad{UP}, not necessarily into irreducibles.")) (|ricDsolve| (((|List| (|Fraction| |#2|)) (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|)) (|Mapping| (|Factored| |#2|) |#2|)) "\\spad{ricDsolve(op, ezfactor)} returns the rational solutions of the associated Riccati equation of \\spad{op \\spad{y} = 0}. Argument \\spad{ezfactor} is a factorisation in \\spad{UP}, not necessarily into irreducibles.") (((|List| (|Fraction| |#2|)) (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|))) "\\spad{ricDsolve(op)} returns the rational solutions of the associated Riccati equation of \\spad{op \\spad{y} = 0}.") (((|List| (|Fraction| |#2|)) (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)) (|Mapping| (|Factored| |#2|) |#2|)) "\\spad{ricDsolve(op, ezfactor)} returns the rational solutions of the associated Riccati equation of \\spad{op \\spad{y} = 0}. Argument \\spad{ezfactor} is a factorisation in \\spad{UP}, not necessarily into irreducibles.") (((|List| (|Fraction| |#2|)) (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|))) "\\spad{ricDsolve(op)} returns the rational solutions of the associated Riccati equation of \\spad{op \\spad{y} = 0}.") (((|List| (|Fraction| |#2|)) (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|)) (|Mapping| (|List| |#1|) |#2|) (|Mapping| (|Factored| |#2|) |#2|)) "\\spad{ricDsolve(op, zeros, ezfactor)} returns the rational solutions of the associated Riccati equation of \\spad{op \\spad{y} = 0}. \\spad{zeros} is a zero finder in \\spad{UP}. Argument \\spad{ezfactor} is a factorisation in \\spad{UP}, not necessarily into irreducibles.") (((|List| (|Fraction| |#2|)) (|LinearOrdinaryDifferentialOperator2| |#2| (|Fraction| |#2|)) (|Mapping| (|List| |#1|) |#2|)) "\\spad{ricDsolve(op, zeros)} returns the rational solutions of the associated Riccati equation of \\spad{op \\spad{y} = 0}. \\spad{zeros} is a zero finder in \\spad{UP}.") (((|List| (|Fraction| |#2|)) (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)) (|Mapping| (|List| |#1|) |#2|) (|Mapping| (|Factored| |#2|) |#2|)) "\\spad{ricDsolve(op, zeros, ezfactor)} returns the rational solutions of the associated Riccati equation of \\spad{op \\spad{y} = 0}. \\spad{zeros} is a zero finder in \\spad{UP}. Argument \\spad{ezfactor} is a factorisation in \\spad{UP}, not necessarily into irreducibles.") (((|List| (|Fraction| |#2|)) (|LinearOrdinaryDifferentialOperator1| (|Fraction| |#2|)) (|Mapping| (|List| |#1|) |#2|)) "\\spad{ricDsolve(op, zeros)} returns the rational solutions of the associated Riccati equation of \\spad{op \\spad{y} = 0}. \\spad{zeros} is a zero finder in \\spad{UP}."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|AlgebraicallyClosedField|)))) 
(|SystemODESolver| F LO) 
((|constructor| (NIL "SystemODESolver provides tools for triangulating and solving some systems of linear ordinary differential equations.")) (|solveInField| (((|Record| (|:| |particular| (|Union| (|Vector| |#1|) "failed")) (|:| |basis| (|List| (|Vector| |#1|)))) (|Matrix| |#2|) (|Vector| |#1|) (|Mapping| (|Record| (|:| |particular| (|Union| |#1| "failed")) (|:| |basis| (|List| |#1|))) |#2| |#1|)) "\\spad{solveInField(m, \\spad{v,} solve)} returns \\spad{[[v_1,...,v_m], v_p]} such that the solutions in \\spad{F} of the system \\spad{m \\spad{x} = \\spad{v}} are \\spad{v_p + \\spad{c_1} \\spad{v_1} + \\spad{...} + \\spad{c_m} v_m} where the \\spad{c_i's} are constants, and the \\spad{v_i's} form a basis for the solutions of \\spad{m \\spad{x} = 0}. Argument \\spad{solve} is a function for solving a single linear ordinary differential equation in \\spad{F}.")) (|solve| (((|Union| (|Record| (|:| |particular| (|Vector| |#1|)) (|:| |basis| (|Matrix| |#1|))) "failed") (|Matrix| |#1|) (|Vector| |#1|) (|Mapping| (|Union| (|Record| (|:| |particular| |#1|) (|:| |basis| (|List| |#1|))) "failed") |#2| |#1|)) "\\spad{solve(m, \\spad{v,} solve)} returns \\spad{[[v_1,...,v_m], v_p]} such that the solutions in \\spad{F} of the system \\spad{D \\spad{x} = \\spad{m} \\spad{x} + \\spad{v}} are \\spad{v_p + \\spad{c_1} \\spad{v_1} + \\spad{...} + \\spad{c_m} v_m} where the \\spad{c_i's} are constants, and the \\spad{v_i's} form a basis for the solutions of \\spad{D \\spad{x} = \\spad{m} \\spad{x}.} Argument \\spad{solve} is a function for solving a single linear ordinary differential equation in \\spad{F}.")) (|triangulate| (((|Record| (|:| |mat| (|Matrix| |#2|)) (|:| |vec| (|Vector| |#1|))) (|Matrix| |#2|) (|Vector| |#1|)) "\\spad{triangulate(m, \\spad{v)}} returns \\spad{[m_0, v_0]} such that \\spad{m_0} is upper triangular and the system \\spad{m_0 \\spad{x} = v_0} is equivalent to \\spad{m \\spad{x} = \\spad{v}.}") (((|Record| (|:| A (|Matrix| |#1|)) (|:| |eqs| (|List| (|Record| (|:| C (|Matrix| |#1|)) (|:| |g| (|Vector| |#1|)) (|:| |eq| |#2|) (|:| |rh| |#1|))))) (|Matrix| |#1|) (|Vector| |#1|)) "\\spad{triangulate(M,v)} returns \\spad{A,[[C_1,g_1,L_1,h_1],...,[C_k,g_k,L_k,h_k]]} such that under the change of variable \\spad{y = A \\spad{z},} the first order linear system \\spad{D \\spad{y} = \\spad{M} \\spad{y} + \\spad{v}} is uncoupled as \\spad{D z_i = C_i z_i + g_i} and each \\spad{C_i} is a companion matrix corresponding to the scalar equation \\spad{L_i \\spad{z_j} = h_i}."))) 
NIL 
NIL 
(|ODETools| F LODO) 
((|constructor| (NIL "\\spad{ODETools} provides tools for the linear ODE solver.")) (|particularSolution| (((|Union| |#1| "failed") |#2| |#1| (|List| |#1|) (|Mapping| |#1| |#1|)) "\\spad{particularSolution(op, \\spad{g,} [f1,...,fm], I)} returns a particular solution \\spad{h} of the equation \\spad{op \\spad{y} = \\spad{g}} where \\spad{[f1,...,fm]} are linearly independent and \\spad{op(fi)=0}. The value \"failed\" is returned if no particular solution is found. Note that the method of variations of parameters is used.")) (|variationOfParameters| (((|Union| (|Vector| |#1|) "failed") |#2| |#1| (|List| |#1|)) "\\spad{variationOfParameters(op, \\spad{g,} [f1,...,fm])} returns \\spad{[u1,...,um]} such that a particular solution of the equation \\spad{op \\spad{y} = \\spad{g}} is \\spad{f1 int(u1) + \\spad{...} + \\spad{fm} int(um)} where \\spad{[f1,...,fm]} are linearly independent and \\spad{op(fi)=0}. The value \"failed\" is returned if \\spad{m < \\spad{n}} and no particular solution is found.")) (|wronskianMatrix| (((|Matrix| |#1|) (|List| |#1|) (|NonNegativeInteger|)) "\\spad{wronskianMatrix([f1,...,fn], \\spad{q,} \\spad{D)}} returns the \\spad{q \\spad{x} \\spad{n}} matrix \\spad{m} whose i^th row is \\spad{[f1^(i-1),...,fn^(i-1)]}.") (((|Matrix| |#1|) (|List| |#1|)) "\\spad{wronskianMatrix([f1,...,fn])} returns the \\spad{n \\spad{x} \\spad{n}} matrix \\spad{m} whose i^th row is \\spad{[f1^(i-1),...,fn^(i-1)]}."))) 
NIL 
NIL 
(|OrderedDirectProduct| |dim| S |f|) 
((|constructor| (NIL "This type represents the finite direct or cartesian product of an underlying ordered component type. The ordering on the type is determined by its third argument which represents the less than function on vectors. This type is a suitable third argument for \\spadtype{GeneralDistributedMultivariatePolynomial}."))) 
((|rightUnitary| |has| |#2| (|Ring|)) (|leftUnitary| |has| |#2| (|Ring|)) (|unitsKnown| |has| |#2| (ATTRIBUTE |unitsKnown|)) ((|commutative| "*") |has| |#2| (|CommutativeRing|)) (|finiteAggregate| . T)) 
((|HasCategory| |#2| (QUOTE (|SetCategory|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedRing|))) (OR (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedRing|)))) (|HasCategory| |#2| (QUOTE (|Monoid|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|Field|)))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (|HasCategory| |#2| (QUOTE (|Finite|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (|HasAttribute| |#2| (QUOTE |unitsKnown|)) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Finite|))) (|HasCategory| |#2| (QUOTE (|Monoid|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedRing|))) (|HasCategory| |#2| (QUOTE (|Ring|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (OR (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Field|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Finite|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Field|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Finite|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|Field|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|Finite|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|Ring|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))))) 
(|OrderlyDifferentialPolynomial| R) 
((|constructor| (NIL "\\spadtype{OrderlyDifferentialPolynomial} implements an ordinary differential polynomial ring in arbitrary number of differential indeterminates, with coefficients in a ring. The ranking on the differential indeterminate is orderly. This is analogous to the domain \\spadtype{Polynomial}."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|)) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|)) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|)) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|)) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| (|OrderlyDifferentialVariable| (|Symbol|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))))) 
(|OrdinaryDifferentialRing| |Kernels| R |var|) 
((|constructor| (NIL "This constructor produces an ordinary differential ring from a partial differential ring by specifying a variable.")) (|coerce| ((|#2| $) "\\spad{coerce(p)} views \\spad{p} as a valie in the partial differential ring.") (($ |#2|) "\\spad{coerce(r)} views \\spad{r} as a value in the ordinary differential ring."))) 
(((|commutative| "*") |has| |#2| (|Field|)) (|noZeroDivisors| |has| |#2| (|Field|)) (|canonicalUnitNormal| |has| |#2| (|Field|)) (|canonicalsClosed| |has| |#2| (|Field|)) (|unitsKnown| . T) (|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| |#2| (QUOTE (|Field|)))) 
(|OrderlyDifferentialVariable| S) 
((|constructor| (NIL "\\spadtype{OrderlyDifferentialVariable} adds a commonly used orderly ranking to the set of derivatives of an ordered list of differential indeterminates. An orderly ranking is a ranking \\spadfun{<} of the derivatives with the property that for two derivatives \\spad{u} and \\spad{v,} \\spad{u} \\spadfun{<} \\spad{v} if the \\spadfun{order} of \\spad{u} is less than that of \\spad{v.} This domain belongs to \\spadtype{DifferentialVariableCategory}. It defines \\spadfun{weight} to be just \\spadfun{order}, and it defines an orderly ranking \\spadfun{<} on derivatives \\spad{u} via the lexicographic order on the pair (\\spadfun{order}(u), \\spadfun{variable}(u))."))) 
NIL 
NIL 
(|OrderedFreeMonoid| S) 
((|constructor| (NIL "The free monoid on a set \\spad{S} is the monoid of finite products of the form \\spad{reduce(*,[si \\spad{**} ni])} where the si's are in \\spad{S,} and the ni's are non-negative integers. The multiplication is not commutative. For two elements \\spad{x} and \\spad{y} the relation \\spad{x < \\spad{y}} holds if either \\spad{length(x) < length(y)} holds or if these lengths are equal and if \\spad{x} is smaller than \\spad{y} w.r.t. the lexicographical ordering induced by \\spad{S}. This domain inherits implementation from \\spadtype{FreeMonoid}.")) (|varList| (((|List| |#1|) $) "\\indented{1}{\\spad{varList(x)} returns the list of variables of \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} varList \\spad{m1}")) (|length| (((|NonNegativeInteger|) $) "\\indented{1}{\\spad{length(x)} returns the length of \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} length \\spad{m1}")) (|factors| (((|List| (|Record| (|:| |gen| |#1|) (|:| |exp| (|NonNegativeInteger|)))) $) "\\indented{1}{\\spad{factors(a1\\^e1,...,an\\^en)} returns} \\indented{1}{\\spad{[[a1, e1],...,[an, en]]}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} factors \\spad{m1}")) (|nthFactor| ((|#1| $ (|Integer|)) "\\indented{1}{\\spad{nthFactor(x, \\spad{n)}} returns the factor of the \\spad{n-th}} \\indented{1}{monomial of \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} nthFactor(m1,2)")) (|nthExpon| (((|NonNegativeInteger|) $ (|Integer|)) "\\indented{1}{\\spad{nthExpon(x, \\spad{n)}} returns the exponent of the} \\indented{1}{\\spad{n-th} monomial of \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} nthExpon(m1,2)")) (|size| (((|NonNegativeInteger|) $) "\\indented{1}{\\spad{size(x)} returns the number of monomials in \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} size(m1,2)")) (|overlap| (((|Record| (|:| |lm| $) (|:| |mm| $) (|:| |rm| $)) $ $) "\\indented{1}{\\spad{overlap(x, \\spad{y)}} returns \\spad{[l, \\spad{m,} \\spad{r]}} such that} \\indented{1}{\\spad{x = \\spad{l} * \\spad{m}} and \\spad{y = \\spad{m} * \\spad{r}} hold and such that} \\indented{1}{\\spad{l} and \\spad{r} have no overlap,} \\indented{1}{that is \\spad{overlap(l, \\spad{r)} = \\spad{[l,} 1, r]}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} m2:=(x*y)$OFMONOID(Symbol) \\spad{X} overlap(m1,m2)")) (|divide| (((|Union| (|Record| (|:| |lm| (|Union| $ "failed")) (|:| |rm| (|Union| $ "failed"))) "failed") $ $) "\\indented{1}{\\spad{divide(x,y)} returns the left and right exact quotients of} \\indented{1}{\\spad{x} by \\spad{y}, that is \\spad{[l,r]} such that \\spad{x = l*y*r}.} \\indented{1}{\"failed\" is returned iff \\spad{x} is not of the form \\spad{l * \\spad{y} * r}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} m2:=(x*y)$OFMONOID(Symbol) \\spad{X} divide(m1,m2)")) (|rquo| (((|Union| $ "failed") $ |#1|) "\\indented{1}{\\spad{rquo(x, \\spad{s)}} returns the exact right quotient} \\indented{1}{of \\spad{x} by \\spad{s}.} \\blankline \\spad{X} m1:=(x*y)$OFMONOID(Symbol) \\spad{X} div(m1,y)") (((|Union| $ "failed") $ $) "\\indented{1}{\\spad{rquo(x, \\spad{y)}} returns the exact right quotient of \\spad{x}} \\indented{1}{by \\spad{y} that is \\spad{q} such that \\spad{x = \\spad{q} * y},} \\indented{1}{\"failed\" if \\spad{x} is not of the form \\spad{q * y}.} \\blankline \\spad{X} m1:=(q*y^3)$OFMONOID(Symbol) \\spad{X} m2:=(y^2)$OFMONOID(Symbol) \\spad{X} lquo(m1,m2)")) (|lquo| (((|Union| $ "failed") $ |#1|) "\\indented{1}{\\spad{lquo(x, \\spad{s)}} returns the exact left quotient of \\spad{x}} \\indented{1}{by \\spad{s}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} lquo(m1,x)") (((|Union| $ "failed") $ $) "\\indented{1}{\\spad{lquo(x, \\spad{y)}} returns the exact left quotient of \\spad{x}} \\indented{2}{by \\spad{y} that is \\spad{q} such that \\spad{x = \\spad{y} * q},} \\indented{1}{\"failed\" if \\spad{x} is not of the form \\spad{y * q}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} m2:=(x*y)$OFMONOID(Symbol) \\spad{X} lquo(m1,m2)")) (|hcrf| (($ $ $) "\\indented{1}{\\spad{hcrf(x, \\spad{y)}} returns the highest common right} \\indented{1}{factor of \\spad{x} and \\spad{y},} \\indented{1}{that is the largest \\spad{d} such that \\spad{x = a \\spad{d}}} \\indented{1}{and \\spad{y = \\spad{b} d}.} \\blankline \\spad{X} m1:=(x*y*z)$OFMONOID(Symbol) \\spad{X} m2:=(y*z)$OFMONOID(Symbol) \\spad{X} hcrf(m1,m2)")) (|hclf| (($ $ $) "\\indented{1}{\\spad{hclf(x, \\spad{y)}} returns the highest common left factor} \\indented{1}{of \\spad{x} and \\spad{y},} \\indented{1}{that is the largest \\spad{d} such that \\spad{x = \\spad{d} a}} \\indented{1}{and \\spad{y = \\spad{d} b}.} \\blankline \\spad{X} m1:=(x*y*z)$OFMONOID(Symbol) \\spad{X} m2:=(x*y)$OFMONOID(Symbol) \\spad{X} hclf(m1,m2)")) (|lexico| (((|Boolean|) $ $) "\\indented{1}{\\spad{lexico(x,y)} returns \\spad{true}} \\indented{1}{iff \\spad{x} is smaller than \\spad{y}} \\indented{1}{w.r.t. the pure lexicographical ordering induced by \\spad{S}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} m2:=(x*y)$OFMONOID(Symbol) \\spad{X} lexico(m1,m2) \\spad{X} lexico(m2,m1)")) (|mirror| (($ $) "\\indented{1}{\\spad{mirror(x)} returns the reversed word of \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} mirror \\spad{m1}")) (|rest| (($ $) "\\indented{1}{\\spad{rest(x)} returns \\spad{x} except the first letter.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} rest \\spad{m1}")) (|first| ((|#1| $) "\\indented{1}{\\spad{first(x)} returns the first letter of \\spad{x}.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} first \\spad{m1}")) (** (($ |#1| (|NonNegativeInteger|)) "\\indented{1}{\\spad{s**n} returns the product of \\spad{s} by itself \\spad{n} times.} \\blankline \\spad{X} m1:=(y**3)$OFMONOID(Symbol)")) (* (($ $ |#1|) "\\indented{1}{\\spad{x*s} returns the product of \\spad{x} by \\spad{s} on the right.} \\blankline \\spad{X} m1:=(y**3)$OFMONOID(Symbol) \\spad{X} m1*x") (($ |#1| $) "\\indented{1}{\\spad{s*x} returns the product of \\spad{x} by \\spad{s} on the left.} \\blankline \\spad{X} m1:=(x*y*y*z)$OFMONOID(Symbol) \\spad{X} \\spad{x*m1}"))) 
NIL 
NIL 
(|OrderedIntegralDomain|) 
((|constructor| (NIL "The category of ordered commutative integral domains, where ordering and the arithmetic operations are compatible"))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|OpenMathConnection|) 
((|constructor| (NIL "\\spadtype{OpenMathConnection} provides low-level functions for handling connections to and from \\spadtype{OpenMathDevice}s.")) (|OMbindTCP| (((|Boolean|) $ (|SingleInteger|)) "\\spad{OMbindTCP}")) (|OMconnectTCP| (((|Boolean|) $ (|String|) (|SingleInteger|)) "\\spad{OMconnectTCP}")) (|OMconnOutDevice| (((|OpenMathDevice|) $) "\\spad{OMconnOutDevice:}")) (|OMconnInDevice| (((|OpenMathDevice|) $) "\\spad{OMconnInDevice:}")) (|OMcloseConn| (((|Void|) $) "\\spad{OMcloseConn}")) (|OMmakeConn| (($ (|SingleInteger|)) "\\spad{OMmakeConn}"))) 
NIL 
NIL 
(|OpenMathDevice|) 
((|constructor| (NIL "\\spadtype{OpenMathDevice} provides support for reading and writing openMath objects to files, strings etc. It also provides access to low-level operations from within the interpreter.")) (|OMgetType| (((|Symbol|) $) "\\spad{OMgetType(dev)} returns the type of the next object on \\axiom{dev}.")) (|OMgetSymbol| (((|Record| (|:| |cd| (|String|)) (|:| |name| (|String|))) $) "\\spad{OMgetSymbol(dev)} reads a symbol from \\axiom{dev}.")) (|OMgetString| (((|String|) $) "\\spad{OMgetString(dev)} reads a string from \\axiom{dev}.")) (|OMgetVariable| (((|Symbol|) $) "\\spad{OMgetVariable(dev)} reads a variable from \\axiom{dev}.")) (|OMgetFloat| (((|DoubleFloat|) $) "\\spad{OMgetFloat(dev)} reads a float from \\axiom{dev}.")) (|OMgetInteger| (((|Integer|) $) "\\spad{OMgetInteger(dev)} reads an integer from \\axiom{dev}.")) (|OMgetEndObject| (((|Void|) $) "\\spad{OMgetEndObject(dev)} reads an end object token from \\axiom{dev}.")) (|OMgetEndError| (((|Void|) $) "\\spad{OMgetEndError(dev)} reads an end error token from \\axiom{dev}.")) (|OMgetEndBVar| (((|Void|) $) "\\spad{OMgetEndBVar(dev)} reads an end bound variable list token from \\axiom{dev}.")) (|OMgetEndBind| (((|Void|) $) "\\spad{OMgetEndBind(dev)} reads an end binder token from \\axiom{dev}.")) (|OMgetEndAttr| (((|Void|) $) "\\spad{OMgetEndAttr(dev)} reads an end attribute token from \\axiom{dev}.")) (|OMgetEndAtp| (((|Void|) $) "\\spad{OMgetEndAtp(dev)} reads an end attribute pair token from \\axiom{dev}.")) (|OMgetEndApp| (((|Void|) $) "\\spad{OMgetEndApp(dev)} reads an end application token from \\axiom{dev}.")) (|OMgetObject| (((|Void|) $) "\\spad{OMgetObject(dev)} reads a begin object token from \\axiom{dev}.")) (|OMgetError| (((|Void|) $) "\\spad{OMgetError(dev)} reads a begin error token from \\axiom{dev}.")) (|OMgetBVar| (((|Void|) $) "\\spad{OMgetBVar(dev)} reads a begin bound variable list token from \\axiom{dev}.")) (|OMgetBind| (((|Void|) $) "\\spad{OMgetBind(dev)} reads a begin binder token from \\axiom{dev}.")) (|OMgetAttr| (((|Void|) $) "\\spad{OMgetAttr(dev)} reads a begin attribute token from \\axiom{dev}.")) (|OMgetAtp| (((|Void|) $) "\\spad{OMgetAtp(dev)} reads a begin attribute pair token from \\axiom{dev}.")) (|OMgetApp| (((|Void|) $) "\\spad{OMgetApp(dev)} reads a begin application token from \\axiom{dev}.")) (|OMputSymbol| (((|Void|) $ (|String|) (|String|)) "\\spad{OMputSymbol(dev,cd,s)} writes the symbol \\axiom{s} from \\spad{CD} \\axiom{cd} to \\axiom{dev}.")) (|OMputString| (((|Void|) $ (|String|)) "\\spad{OMputString(dev,i)} writes the string \\axiom{i} to \\axiom{dev}.")) (|OMputVariable| (((|Void|) $ (|Symbol|)) "\\spad{OMputVariable(dev,i)} writes the variable \\axiom{i} to \\axiom{dev}.")) (|OMputFloat| (((|Void|) $ (|DoubleFloat|)) "\\spad{OMputFloat(dev,i)} writes the float \\axiom{i} to \\axiom{dev}.")) (|OMputInteger| (((|Void|) $ (|Integer|)) "\\spad{OMputInteger(dev,i)} writes the integer \\axiom{i} to \\axiom{dev}.")) (|OMputEndObject| (((|Void|) $) "\\spad{OMputEndObject(dev)} writes an end object token to \\axiom{dev}.")) (|OMputEndError| (((|Void|) $) "\\spad{OMputEndError(dev)} writes an end error token to \\axiom{dev}.")) (|OMputEndBVar| (((|Void|) $) "\\spad{OMputEndBVar(dev)} writes an end bound variable list token to \\axiom{dev}.")) (|OMputEndBind| (((|Void|) $) "\\spad{OMputEndBind(dev)} writes an end binder token to \\axiom{dev}.")) (|OMputEndAttr| (((|Void|) $) "\\spad{OMputEndAttr(dev)} writes an end attribute token to \\axiom{dev}.")) (|OMputEndAtp| (((|Void|) $) "\\spad{OMputEndAtp(dev)} writes an end attribute pair token to \\axiom{dev}.")) (|OMputEndApp| (((|Void|) $) "\\spad{OMputEndApp(dev)} writes an end application token to \\axiom{dev}.")) (|OMputObject| (((|Void|) $) "\\spad{OMputObject(dev)} writes a begin object token to \\axiom{dev}.")) (|OMputError| (((|Void|) $) "\\spad{OMputError(dev)} writes a begin error token to \\axiom{dev}.")) (|OMputBVar| (((|Void|) $) "\\spad{OMputBVar(dev)} writes a begin bound variable list token to \\axiom{dev}.")) (|OMputBind| (((|Void|) $) "\\spad{OMputBind(dev)} writes a begin binder token to \\axiom{dev}.")) (|OMputAttr| (((|Void|) $) "\\spad{OMputAttr(dev)} writes a begin attribute token to \\axiom{dev}.")) (|OMputAtp| (((|Void|) $) "\\spad{OMputAtp(dev)} writes a begin attribute pair token to \\axiom{dev}.")) (|OMputApp| (((|Void|) $) "\\spad{OMputApp(dev)} writes a begin application token to \\axiom{dev}.")) (|OMsetEncoding| (((|Void|) $ (|OpenMathEncoding|)) "\\spad{OMsetEncoding(dev,enc)} sets the encoding used for reading or writing OpenMath objects to or from \\axiom{dev} to \\axiom{enc}.")) (|OMclose| (((|Void|) $) "\\spad{OMclose(dev)} closes \\axiom{dev}, flushing output if necessary.")) (|OMopenString| (($ (|String|) (|OpenMathEncoding|)) "\\spad{OMopenString(s,mode)} opens the string \\axiom{s} for reading or writing OpenMath objects in encoding \\axiom{enc}.")) (|OMopenFile| (($ (|String|) (|String|) (|OpenMathEncoding|)) "\\spad{OMopenFile(f,mode,enc)} opens file \\axiom{f} for reading or writing OpenMath objects (depending on \\axiom{mode} which can be \"r\", \\spad{\"w\"} or \"a\" for read, write and append respectively), in the encoding \\axiom{enc}."))) 
NIL 
NIL 
(|OpenMathEncoding|) 
((|constructor| (NIL "\\spadtype{OpenMathEncoding} is the set of valid OpenMath encodings.")) (|OMencodingBinary| (($) "\\spad{OMencodingBinary()} is the constant for the OpenMath binary encoding.")) (|OMencodingSGML| (($) "\\spad{OMencodingSGML()} is the constant for the deprecated OpenMath SGML encoding.")) (|OMencodingXML| (($) "\\spad{OMencodingXML()} is the constant for the OpenMath \\spad{XML} encoding.")) (|OMencodingUnknown| (($) "\\spad{OMencodingUnknown()} is the constant for unknown encoding types. If this is used on an input device, the encoding will be autodetected. It is invalid to use it on an output device."))) 
NIL 
NIL 
(|OpenMathErrorKind|) 
((|constructor| (NIL "\\spadtype{OpenMathErrorKind} represents different kinds of OpenMath errors: specifically parse errors, unknown \\spad{CD} or symbol errors, and read errors.")) (|OMReadError?| (((|Boolean|) $) "\\spad{OMReadError?(u)} tests whether \\spad{u} is an OpenMath read error.")) (|OMUnknownSymbol?| (((|Boolean|) $) "\\spad{OMUnknownSymbol?(u)} tests whether \\spad{u} is an OpenMath unknown symbol error.")) (|OMUnknownCD?| (((|Boolean|) $) "\\spad{OMUnknownCD?(u)} tests whether \\spad{u} is an OpenMath unknown \\spad{CD} error.")) (|OMParseError?| (((|Boolean|) $) "\\spad{OMParseError?(u)} tests whether \\spad{u} is an OpenMath parsing error.")) (|coerce| (($ (|Symbol|)) "\\spad{coerce(u)} creates an OpenMath error object of an appropriate type if \\axiom{u} is one of \\axiom{OMParseError}, \\axiom{OMReadError}, \\axiom{OMUnknownCD} or \\axiom{OMUnknownSymbol}, otherwise it raises a runtime error."))) 
NIL 
NIL 
(|OpenMathError|) 
((|constructor| (NIL "\\spadtype{OpenMathError} is the domain of OpenMath errors.")) (|omError| (($ (|OpenMathErrorKind|) (|List| (|Symbol|))) "\\spad{omError(k,l)} creates an instance of OpenMathError.")) (|errorInfo| (((|List| (|Symbol|)) $) "\\spad{errorInfo(u)} returns information about the error u.")) (|errorKind| (((|OpenMathErrorKind|) $) "\\spad{errorKind(u)} returns the type of error which \\spad{u} represents."))) 
NIL 
NIL 
(|ExpressionToOpenMath| R) 
((|constructor| (NIL "\\spadtype{ExpressionToOpenMath} provides support for converting objects of type \\spadtype{Expression} into OpenMath."))) 
NIL 
NIL 
(|OppositeMonogenicLinearOperator| P R) 
((|constructor| (NIL "This constructor creates the \\spadtype{MonogenicLinearOperator} domain which is ``opposite'' in the ring sense to \\spad{P.} That is, as sets \\spad{P = \\spad{$}} but \\spad{a * \\spad{b}} in \\spad{$} is equal to \\spad{b * a} in \\spad{P.}")) (|po| ((|#1| $) "\\spad{po(q)} creates a value in \\spad{P} equal to \\spad{q} in \\spad{$.}")) (|op| (($ |#1|) "\\spad{op(p)} creates a value in \\$ equal to \\spad{p} in \\spad{P.}"))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|DifferentialRing|)))) 
(|OpenMath|) 
((|constructor| (NIL "\\spadtype{OpenMath} provides operations for exporting an object in OpenMath format.")) (|OMwrite| (((|Void|) (|OpenMathDevice|) $ (|Boolean|)) "\\spad{OMwrite(dev, u, true)} writes the OpenMath form of \\axiom{u} to the OpenMath device \\axiom{dev} as a complete OpenMath object; OMwrite(dev, u, false) writes the object as an OpenMath fragment.") (((|Void|) (|OpenMathDevice|) $) "\\spad{OMwrite(dev, u)} writes the OpenMath form of \\axiom{u} to the OpenMath device \\axiom{dev} as a complete OpenMath object.") (((|String|) $ (|Boolean|)) "\\spad{OMwrite(u, true)} returns the OpenMath \\spad{XML} encoding of \\axiom{u} as a complete OpenMath object; OMwrite(u, false) returns the OpenMath \\spad{XML} encoding of \\axiom{u} as an OpenMath fragment.") (((|String|) $) "\\spad{OMwrite(u)} returns the OpenMath \\spad{XML} encoding of \\axiom{u} as a complete OpenMath object."))) 
NIL 
NIL 
(|OpenMathPackage|) 
((|constructor| (NIL "\\spadtype{OpenMathPackage} provides some simple utilities to make reading OpenMath objects easier.")) (|OMunhandledSymbol| (((|Exit|) (|String|) (|String|)) "\\spad{OMunhandledSymbol(s,cd)} raises an error if AXIOM reads a symbol which it is unable to handle. Note that this is different from an unexpected symbol.")) (|OMsupportsSymbol?| (((|Boolean|) (|String|) (|String|)) "\\spad{OMsupportsSymbol?(s,cd)} returns \\spad{true} if AXIOM supports symbol \\axiom{s} from \\spad{CD} \\axiom{cd}, \\spad{false} otherwise.")) (|OMsupportsCD?| (((|Boolean|) (|String|)) "\\spad{OMsupportsCD?(cd)} returns \\spad{true} if AXIOM supports \\axiom{cd}, \\spad{false} otherwise.")) (|OMlistSymbols| (((|List| (|String|)) (|String|)) "\\spad{OMlistSymbols(cd)} lists all the symbols in \\axiom{cd}.")) (|OMlistCDs| (((|List| (|String|))) "\\spad{OMlistCDs()} lists all the \\spad{CDs} supported by AXIOM.")) (|OMreadStr| (((|Any|) (|String|)) "\\spad{OMreadStr(f)} reads an OpenMath object from \\axiom{f} and passes it to AXIOM.")) (|OMreadFile| (((|Any|) (|String|)) "\\spad{OMreadFile(f)} reads an OpenMath object from \\axiom{f} and passes it to AXIOM.")) (|OMread| (((|Any|) (|OpenMathDevice|)) "\\spad{OMread(dev)} reads an OpenMath object from \\axiom{dev} and passes it to AXIOM."))) 
NIL 
NIL 
(|OrderedMultisetAggregate| S) 
((|constructor| (NIL "to become an in order iterator")) (|min| ((|#1| $) "\\spad{min(u)} returns the smallest entry in the multiset aggregate u."))) 
((|finiteAggregate| . T) (|partiallyOrderedSet| . T) (|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|OpenMathServerPackage|) 
((|constructor| (NIL "\\spadtype{OpenMathServerPackage} provides the necessary operations to run AXIOM as an OpenMath server, reading/writing objects to/from a port. Please note the facilities available here are very basic. The idea is that a user calls \\spadignore{e.g.} \\axiom{Omserve(4000,60)} and then another process sends OpenMath objects to port 4000 and reads the result.")) (|OMserve| (((|Void|) (|SingleInteger|) (|SingleInteger|)) "\\spad{OMserve(portnum,timeout)} puts AXIOM into server mode on port number \\axiom{portnum}. The parameter \\axiom{timeout} specifies the \\spad{timeout} period for the connection.")) (|OMsend| (((|Void|) (|OpenMathConnection|) (|Any|)) "\\spad{OMsend(c,u)} attempts to output \\axiom{u} on \\axiom{c} in OpenMath.")) (|OMreceive| (((|Any|) (|OpenMathConnection|)) "\\spad{OMreceive(c)} reads an OpenMath object from connection \\axiom{c} and returns the appropriate AXIOM object."))) 
NIL 
NIL 
(|OnePointCompletionFunctions2| R S) 
((|constructor| (NIL "Lifting of maps to one-point completions.")) (|map| (((|OnePointCompletion| |#2|) (|Mapping| |#2| |#1|) (|OnePointCompletion| |#1|) (|OnePointCompletion| |#2|)) "\\spad{map(f, \\spad{r,} i)} lifts \\spad{f} and applies it to \\spad{r,} assuming that f(infinity) = i.") (((|OnePointCompletion| |#2|) (|Mapping| |#2| |#1|) (|OnePointCompletion| |#1|)) "\\spad{map(f, \\spad{r)}} lifts \\spad{f} and applies it to \\spad{r,} assuming that f(infinity) = infinity."))) 
NIL 
NIL 
(|OnePointCompletion| R) 
((|constructor| (NIL "Completion with infinity. Adjunction of a complex infinity to a set.")) (|rationalIfCan| (((|Union| (|Fraction| (|Integer|)) "failed") $) "\\spad{rationalIfCan(x)} returns \\spad{x} as a finite rational number if it is one, \"failed\" otherwise.")) (|rational| (((|Fraction| (|Integer|)) $) "\\spad{rational(x)} returns \\spad{x} as a finite rational number. Error: if \\spad{x} is not a rational number.")) (|rational?| (((|Boolean|) $) "\\spad{rational?(x)} tests if \\spad{x} is a finite rational number.")) (|infinite?| (((|Boolean|) $) "\\spad{infinite?(x)} tests if \\spad{x} is infinite.")) (|finite?| (((|Boolean|) $) "\\spad{finite?(x)} tests if \\spad{x} is finite.")) (|infinity| (($) "\\spad{infinity()} returns infinity."))) 
((|unitsKnown| |has| |#1| (|OrderedRing|))) 
((|HasCategory| |#1| (QUOTE (|OrderedRing|))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|))) (OR (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|OrderedRing|)))) (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (OR (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#1| (QUOTE (|OrderedRing|))))) 
(|Operator| R) 
((|constructor| (NIL "Algebra of ADDITIVE operators over a ring."))) 
((|leftUnitary| |has| |#1| (|CommutativeRing|)) (|rightUnitary| |has| |#1| (|CommutativeRing|)) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|)))) 
(|OperationsQuery|) 
((|constructor| (NIL "This package exports tools to create AXIOM Library information databases.")) (|getDatabase| (((|Database| (|IndexCard|)) (|String|)) "\\spad{getDatabase(\"char\")} returns a list of appropriate entries in the browser database. The legal values for \\spad{\"char\"} are \"o\" (operations), \\spad{\"k\"} (constructors), \\spad{\"d\"} (domains), \\spad{\"c\"} (categories) or \\spad{\"p\"} (packages)."))) 
NIL 
NIL 
(|NumericalOptimizationCategory|) 
((|constructor| (NIL "\\axiomType{NumericalOptimizationCategory} is the \\axiom{category} for describing the set of Numerical Optimization \\axiom{domains} with \\axiomFun{measure} and \\axiomFun{optimize}.")) (|numericalOptimization| (((|Result|) (|Record| (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |init| (|List| (|DoubleFloat|))) (|:| |lb| (|List| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |cf| (|List| (|Expression| (|DoubleFloat|)))) (|:| |ub| (|List| (|OrderedCompletion| (|DoubleFloat|)))))) "\\spad{numericalOptimization(args)} performs the optimization of the function given the strategy or method returned by \\axiomFun{measure}.") (((|Result|) (|Record| (|:| |lfn| (|List| (|Expression| (|DoubleFloat|)))) (|:| |init| (|List| (|DoubleFloat|))))) "\\spad{numericalOptimization(args)} performs the optimization of the function given the strategy or method returned by \\axiomFun{measure}.")) (|measure| (((|Record| (|:| |measure| (|Float|)) (|:| |explanations| (|String|))) (|RoutinesTable|) (|Record| (|:| |lfn| (|List| (|Expression| (|DoubleFloat|)))) (|:| |init| (|List| (|DoubleFloat|))))) "\\spad{measure(R,args)} calculates an estimate of the ability of a particular method to solve an optimization problem. \\blankline This method may be either a specific NAG routine or a strategy (such as transforming the function from one which is difficult to one which is easier to solve). \\blankline It will call whichever agents are needed to perform analysis on the problem in order to calculate the measure. There is a parameter, labelled \\axiom{sofar}, which would contain the best compatibility found so far.") (((|Record| (|:| |measure| (|Float|)) (|:| |explanations| (|String|))) (|RoutinesTable|) (|Record| (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |init| (|List| (|DoubleFloat|))) (|:| |lb| (|List| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |cf| (|List| (|Expression| (|DoubleFloat|)))) (|:| |ub| (|List| (|OrderedCompletion| (|DoubleFloat|)))))) "\\spad{measure(R,args)} calculates an estimate of the ability of a particular method to solve an optimization problem. \\blankline This method may be either a specific NAG routine or a strategy (such as transforming the function from one which is difficult to one which is easier to solve). \\blankline It will call whichever agents are needed to perform analysis on the problem in order to calculate the measure. There is a parameter, labelled \\axiom{sofar}, which would contain the best compatibility found so far."))) 
NIL 
NIL 
(|AnnaNumericalOptimizationPackage|) 
((|constructor| (NIL "\\axiomType{AnnaNumericalOptimizationPackage} is a \\axiom{package} of functions for the \\axiomType{NumericalOptimizationCategory} with \\axiom{measure} and \\axiom{optimize}.")) (|goodnessOfFit| (((|Result|) (|List| (|Expression| (|Float|))) (|List| (|Float|))) "\\spad{goodnessOfFit(lf,start)} is a top level ANNA function to check to goodness of fit of a least squares model \\spadignore{i.e.} the minimization of a set of functions, \\axiom{lf}, of one or more variables without constraints. \\blankline The parameter \\axiom{start} is a list of the initial guesses of the values of the variables. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \\axiom{measure} and then optimize the function on that \\axiom{domain}. It then calls the numerical routine \\axiomType{E04YCF} to get estimates of the variance-covariance matrix of the regression coefficients of the least-squares problem. \\blankline It thus returns both the results of the optimization and the variance-covariance calculation. goodnessOfFit(lf,start) is a top level function to iterate over the \\axiom{domains} of \\axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \\axiom{measure} and then optimize the function on that \\axiom{domain}. It then checks the goodness of fit of the least squares model.") (((|Result|) (|NumericalOptimizationProblem|)) "\\spad{goodnessOfFit(prob)} is a top level ANNA function to check to goodness of fit of a least squares model as defined within \\axiom{prob}. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \\axiom{measure} and then optimize the function on that \\axiom{domain}. It then calls the numerical routine \\axiomType{E04YCF} to get estimates of the variance-covariance matrix of the regression coefficients of the least-squares problem. \\blankline It thus returns both the results of the optimization and the variance-covariance calculation.")) (|optimize| (((|Result|) (|List| (|Expression| (|Float|))) (|List| (|Float|))) "\\spad{optimize(lf,start)} is a top level ANNA function to minimize a set of functions, \\axiom{lf}, of one or more variables without constraints \\spadignore{i.e.} a least-squares problem. \\blankline The parameter \\axiom{start} is a list of the initial guesses of the values of the variables. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \\axiom{measure} and then optimize the function on that \\axiom{domain}.") (((|Result|) (|Expression| (|Float|)) (|List| (|Float|))) "\\spad{optimize(f,start)} is a top level ANNA function to minimize a function, \\axiom{f}, of one or more variables without constraints. \\blankline The parameter \\axiom{start} is a list of the initial guesses of the values of the variables. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \\axiom{measure} and then optimize the function on that \\axiom{domain}.") (((|Result|) (|Expression| (|Float|)) (|List| (|Float|)) (|List| (|OrderedCompletion| (|Float|))) (|List| (|OrderedCompletion| (|Float|)))) "\\spad{optimize(f,start,lower,upper)} is a top level ANNA function to minimize a function, \\axiom{f}, of one or more variables with simple constraints. The bounds on the variables are defined in \\axiom{lower} and \\axiom{upper}. \\blankline The parameter \\axiom{start} is a list of the initial guesses of the values of the variables. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \\axiom{measure} and then optimize the function on that \\axiom{domain}.") (((|Result|) (|Expression| (|Float|)) (|List| (|Float|)) (|List| (|OrderedCompletion| (|Float|))) (|List| (|Expression| (|Float|))) (|List| (|OrderedCompletion| (|Float|)))) "\\spad{optimize(f,start,lower,cons,upper)} is a top level ANNA function to minimize a function, \\axiom{f}, of one or more variables with the given constraints. \\blankline These constraints may be simple constraints on the variables in which case \\axiom{cons} would be an empty list and the bounds on those variables defined in \\axiom{lower} and \\axiom{upper}, or a mixture of simple, linear and non-linear constraints, where \\axiom{cons} contains the linear and non-linear constraints and the bounds on these are added to \\axiom{upper} and \\axiom{lower}. \\blankline The parameter \\axiom{start} is a list of the initial guesses of the values of the variables. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \\axiom{measure} and then optimize the function on that \\axiom{domain}.") (((|Result|) (|NumericalOptimizationProblem|)) "\\spad{optimize(prob)} is a top level ANNA function to minimize a function or a set of functions with any constraints as defined within \\axiom{prob}. \\blankline It iterates over the \\axiom{domains} of \\axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \\axiom{measure} and then optimize the function on that \\axiom{domain}.") (((|Result|) (|NumericalOptimizationProblem|) (|RoutinesTable|)) "\\spad{optimize(prob,routines)} is a top level ANNA function to minimize a function or a set of functions with any constraints as defined within \\axiom{prob}. \\blankline It iterates over the \\axiom{domains} listed in \\axiom{routines} of \\axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \\axiom{measure} and then optimize the function on that \\axiom{domain}.")) (|measure| (((|Record| (|:| |measure| (|Float|)) (|:| |name| (|String|)) (|:| |explanations| (|List| (|String|)))) (|NumericalOptimizationProblem|) (|RoutinesTable|)) "\\spad{measure(prob,R)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical optimization problem defined by \\axiom{prob} by checking various attributes of the functions and calculating a measure of compatibility of each routine to these attributes. \\blankline It calls each \\axiom{domain} listed in \\axiom{R} of \\axiom{category} \\axiomType{NumericalOptimizationCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information.") (((|Record| (|:| |measure| (|Float|)) (|:| |name| (|String|)) (|:| |explanations| (|List| (|String|)))) (|NumericalOptimizationProblem|)) "\\spad{measure(prob)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical optimization problem defined by \\axiom{prob} by checking various attributes of the functions and calculating a measure of compatibility of each routine to these attributes. \\blankline It calls each \\axiom{domain} of \\axiom{category} \\axiomType{NumericalOptimizationCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information."))) 
NIL 
NIL 
(|NumericalOptimizationProblem|) 
((|constructor| (NIL "\\axiomType{NumericalOptimizationProblem} is a \\axiom{domain} for the representation of Numerical Optimization problems for use by ANNA. \\blankline The representation is a Union of two record types - one for otimization of a single function of one or more variables: \\blankline \\axiomType{Record}(\\br fn:\\axiomType{Expression DoubleFloat},\\br init:\\axiomType{List DoubleFloat},\\br lb:\\axiomType{List OrderedCompletion DoubleFloat},\\br cf:\\axiomType{List Expression DoubleFloat},\\br ub:\\axiomType{List OrderedCompletion DoubleFloat}) \\blankline and one for least-squares problems \\spadignore{i.e.} optimization of a set of observations of a data set: \\blankline \\axiomType{Record}(lfn:\\axiomType{List Expression DoubleFloat},\\br init:\\axiomType{List DoubleFloat}).")) (|retract| (((|Union| (|:| |noa| (|Record| (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |init| (|List| (|DoubleFloat|))) (|:| |lb| (|List| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |cf| (|List| (|Expression| (|DoubleFloat|)))) (|:| |ub| (|List| (|OrderedCompletion| (|DoubleFloat|)))))) (|:| |lsa| (|Record| (|:| |lfn| (|List| (|Expression| (|DoubleFloat|)))) (|:| |init| (|List| (|DoubleFloat|)))))) $) "\\spad{retract(x)} is not documented")) (|coerce| (((|OutputForm|) $) "\\spad{coerce(x)} is not documented") (($ (|Union| (|:| |noa| (|Record| (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |init| (|List| (|DoubleFloat|))) (|:| |lb| (|List| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |cf| (|List| (|Expression| (|DoubleFloat|)))) (|:| |ub| (|List| (|OrderedCompletion| (|DoubleFloat|)))))) (|:| |lsa| (|Record| (|:| |lfn| (|List| (|Expression| (|DoubleFloat|)))) (|:| |init| (|List| (|DoubleFloat|))))))) "\\spad{coerce(x)} is not documented") (($ (|Record| (|:| |lfn| (|List| (|Expression| (|DoubleFloat|)))) (|:| |init| (|List| (|DoubleFloat|))))) "\\spad{coerce(x)} is not documented") (($ (|Record| (|:| |fn| (|Expression| (|DoubleFloat|))) (|:| |init| (|List| (|DoubleFloat|))) (|:| |lb| (|List| (|OrderedCompletion| (|DoubleFloat|)))) (|:| |cf| (|List| (|Expression| (|DoubleFloat|)))) (|:| |ub| (|List| (|OrderedCompletion| (|DoubleFloat|)))))) "\\spad{coerce(x)} is not documented"))) 
NIL 
NIL 
(|OrderedCompletionFunctions2| R S) 
((|constructor| (NIL "Lifting of maps to ordered completions.")) (|map| (((|OrderedCompletion| |#2|) (|Mapping| |#2| |#1|) (|OrderedCompletion| |#1|) (|OrderedCompletion| |#2|) (|OrderedCompletion| |#2|)) "\\spad{map(f, \\spad{r,} \\spad{p,} \\spad{m)}} lifts \\spad{f} and applies it to \\spad{r,} assuming that f(plusInfinity) = \\spad{p} and that f(minusInfinity) = \\spad{m.}") (((|OrderedCompletion| |#2|) (|Mapping| |#2| |#1|) (|OrderedCompletion| |#1|)) "\\spad{map(f, \\spad{r)}} lifts \\spad{f} and applies it to \\spad{r,} assuming that f(plusInfinity) = plusInfinity and that f(minusInfinity) = minusInfinity."))) 
NIL 
NIL 
(|OrderedCompletion| R) 
((|constructor| (NIL "Completion with + and - infinity. Adjunction of two real infinites quantities to a set.")) (|rationalIfCan| (((|Union| (|Fraction| (|Integer|)) "failed") $) "\\spad{rationalIfCan(x)} returns \\spad{x} as a finite rational number if it is one and \"failed\" otherwise.")) (|rational| (((|Fraction| (|Integer|)) $) "\\spad{rational(x)} returns \\spad{x} as a finite rational number. Error: if \\spad{x} cannot be so converted.")) (|rational?| (((|Boolean|) $) "\\spad{rational?(x)} tests if \\spad{x} is a finite rational number.")) (|whatInfinity| (((|SingleInteger|) $) "\\spad{whatInfinity(x)} returns 0 if \\spad{x} is finite, 1 if \\spad{x} is +infinity, and \\spad{-1} if \\spad{x} is -infinity.")) (|infinite?| (((|Boolean|) $) "\\spad{infinite?(x)} tests if \\spad{x} is +infinity or -infinity.")) (|finite?| (((|Boolean|) $) "\\spad{finite?(x)} tests if \\spad{x} is finite.")) (|minusInfinity| (($) "\\spad{minusInfinity()} returns -infinity.")) (|plusInfinity| (($) "\\spad{plusInfinity()} returns +infinity."))) 
((|unitsKnown| |has| |#1| (|OrderedRing|))) 
((|HasCategory| |#1| (QUOTE (|OrderedRing|))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|))) (OR (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|OrderedRing|)))) (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (OR (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#1| (QUOTE (|OrderedRing|))))) 
(|OrderedFinite|) 
((|constructor| (NIL "Ordered finite sets."))) 
NIL 
NIL 
(|OrderingFunctions| |dim| S) 
((|constructor| (NIL "This package provides ordering functions on vectors which are suitable parameters for OrderedDirectProduct.")) (|reverseLex| (((|Boolean|) (|Vector| |#2|) (|Vector| |#2|)) "\\spad{reverseLex(v1,v2)} return \\spad{true} if the vector \\spad{v1} is less than the vector \\spad{v2} in the ordering which is total degree refined by the reverse lexicographic ordering.")) (|totalLex| (((|Boolean|) (|Vector| |#2|) (|Vector| |#2|)) "\\spad{totalLex(v1,v2)} return \\spad{true} if the vector \\spad{v1} is less than the vector \\spad{v2} in the ordering which is total degree refined by lexicographic ordering.")) (|pureLex| (((|Boolean|) (|Vector| |#2|) (|Vector| |#2|)) "\\spad{pureLex(v1,v2)} return \\spad{true} if the vector \\spad{v1} is less than the vector \\spad{v2} in the lexicographic ordering."))) 
NIL 
NIL 
(|OrderedMonoid|) 
((|constructor| (NIL "Ordered sets which are also monoids, such that multiplication preserves the ordering. \\blankline Axioms\\br \\tab{5}\\spad{x < \\spad{y} \\spad{=>} \\spad{x*z} < y*z}\\br \\tab{5}\\spad{x < \\spad{y} \\spad{=>} \\spad{z*x} < z*y}"))) 
NIL 
NIL 
(|OrderedRing&| S) 
((|constructor| (NIL "Ordered sets which are also rings, that is, domains where the ring operations are compatible with the ordering. \\blankline Axiom\\br \\tab{5}\\spad{0<a and \\spad{b<c} \\spad{=>} ab< ac}")) (|abs| (($ $) "\\spad{abs(x)} returns the absolute value of \\spad{x.}")) (|sign| (((|Integer|) $) "\\spad{sign(x)} is 1 if \\spad{x} is positive, \\spad{-1} if \\spad{x} is negative, 0 if \\spad{x} equals 0.")) (|negative?| (((|Boolean|) $) "\\spad{negative?(x)} tests whether \\spad{x} is strictly less than 0.")) (|positive?| (((|Boolean|) $) "\\spad{positive?(x)} tests whether \\spad{x} is strictly greater than 0."))) 
NIL 
NIL 
(|OrderedRing|) 
((|constructor| (NIL "Ordered sets which are also rings, that is, domains where the ring operations are compatible with the ordering. \\blankline Axiom\\br \\tab{5}\\spad{0<a and \\spad{b<c} \\spad{=>} ab< ac}")) (|abs| (($ $) "\\spad{abs(x)} returns the absolute value of \\spad{x.}")) (|sign| (((|Integer|) $) "\\spad{sign(x)} is 1 if \\spad{x} is positive, \\spad{-1} if \\spad{x} is negative, 0 if \\spad{x} equals 0.")) (|negative?| (((|Boolean|) $) "\\spad{negative?(x)} tests whether \\spad{x} is strictly less than 0.")) (|positive?| (((|Boolean|) $) "\\spad{positive?(x)} tests whether \\spad{x} is strictly greater than 0."))) 
((|unitsKnown| . T)) 
NIL 
(|OrderedSet&| S) 
((|constructor| (NIL "The class of totally ordered sets, that is, sets such that for each pair of elements \\spad{(a,b)} exactly one of the following relations holds \\spad{a<b or a=b or b<a} and the relation is transitive, that is, \\spad{a<b and \\spad{b<c} \\spad{=>} a<c}.")) (|min| (($ $ $) "\\spad{min(x,y)} returns the minimum of \\spad{x} and \\spad{y} relative to \"<\".")) (|max| (($ $ $) "\\spad{max(x,y)} returns the maximum of \\spad{x} and \\spad{y} relative to \"<\".")) (<= (((|Boolean|) $ $) "\\spad{x \\spad{<=} \\spad{y}} is a less than or equal test.")) (>= (((|Boolean|) $ $) "\\spad{x \\spad{>=} \\spad{y}} is a greater than or equal test.")) (> (((|Boolean|) $ $) "\\spad{x > \\spad{y}} is a greater than test.")) (< (((|Boolean|) $ $) "\\spad{x < \\spad{y}} is a strict total ordering on the elements of the set."))) 
NIL 
NIL 
(|OrderedSet|) 
((|constructor| (NIL "The class of totally ordered sets, that is, sets such that for each pair of elements \\spad{(a,b)} exactly one of the following relations holds \\spad{a<b or a=b or b<a} and the relation is transitive, that is, \\spad{a<b and \\spad{b<c} \\spad{=>} a<c}.")) (|min| (($ $ $) "\\spad{min(x,y)} returns the minimum of \\spad{x} and \\spad{y} relative to \"<\".")) (|max| (($ $ $) "\\spad{max(x,y)} returns the maximum of \\spad{x} and \\spad{y} relative to \"<\".")) (<= (((|Boolean|) $ $) "\\spad{x \\spad{<=} \\spad{y}} is a less than or equal test.")) (>= (((|Boolean|) $ $) "\\spad{x \\spad{>=} \\spad{y}} is a greater than or equal test.")) (> (((|Boolean|) $ $) "\\spad{x > \\spad{y}} is a greater than test.")) (< (((|Boolean|) $ $) "\\spad{x < \\spad{y}} is a strict total ordering on the elements of the set."))) 
NIL 
NIL 
(|UnivariateSkewPolynomialCategory&| S R) 
((|constructor| (NIL "This is the category of univariate skew polynomials over an Ore coefficient ring. The multiplication is given by \\spad{x a = \\sigma(a) \\spad{x} + \\delta a}. This category is an evolution of the types MonogenicLinearOperator, OppositeMonogenicLinearOperator, and NonCommutativeOperatorDivision")) (|leftLcm| (($ $ $) "\\spad{leftLcm(a,b)} computes the value \\spad{m} of lowest degree such that \\spad{m = aa*a = bb*b} for some values \\spad{aa} and \\spad{bb}. The value \\spad{m} is computed using right-division.")) (|rightExtendedGcd| (((|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $)) $ $) "\\spad{rightExtendedGcd(a,b)} returns \\spad{[c,d]} such that \\spad{g = \\spad{c} * a + \\spad{d} * \\spad{b} = rightGcd(a, b)}.")) (|rightGcd| (($ $ $) "\\spad{rightGcd(a,b)} computes the value \\spad{g} of highest degree such that \\indented{3}{\\spad{a = aa*g}} \\indented{3}{\\spad{b = bb*g}} for some values \\spad{aa} and \\spad{bb}. The value \\spad{g} is computed using right-division.")) (|rightExactQuotient| (((|Union| $ "failed") $ $) "\\spad{rightExactQuotient(a,b)} computes the value \\spad{q}, if it exists such that \\spad{a = q*b}.")) (|rightRemainder| (($ $ $) "\\spad{rightRemainder(a,b)} computes the pair \\spad{[q,r]} such that \\spad{a = \\spad{q*b} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{r} is returned.")) (|rightQuotient| (($ $ $) "\\spad{rightQuotient(a,b)} computes the pair \\spad{[q,r]} such that \\spad{a = \\spad{q*b} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{q} is returned.")) (|rightDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{rightDivide(a,b)} returns the pair \\spad{[q,r]} such that \\spad{a = \\spad{q*b} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. This process is called ``right division''.")) (|rightLcm| (($ $ $) "\\spad{rightLcm(a,b)} computes the value \\spad{m} of lowest degree such that \\spad{m = a*aa = b*bb} for some values \\spad{aa} and \\spad{bb}. The value \\spad{m} is computed using left-division.")) (|leftExtendedGcd| (((|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $)) $ $) "\\spad{leftExtendedGcd(a,b)} returns \\spad{[c,d]} such that \\spad{g = a * \\spad{c} + \\spad{b} * \\spad{d} = leftGcd(a, b)}.")) (|leftGcd| (($ $ $) "\\spad{leftGcd(a,b)} computes the value \\spad{g} of highest degree such that \\indented{3}{\\spad{a = g*aa}} \\indented{3}{\\spad{b = g*bb}} for some values \\spad{aa} and \\spad{bb}. The value \\spad{g} is computed using left-division.")) (|leftExactQuotient| (((|Union| $ "failed") $ $) "\\spad{leftExactQuotient(a,b)} computes the value \\spad{q}, if it exists, \\indented{1}{such that \\spad{a = b*q}.}")) (|leftRemainder| (($ $ $) "\\spad{leftRemainder(a,b)} computes the pair \\spad{[q,r]} such that \\spad{a = \\spad{b*q} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{r} is returned.")) (|leftQuotient| (($ $ $) "\\spad{leftQuotient(a,b)} computes the pair \\spad{[q,r]} such that \\spad{a = \\spad{b*q} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{q} is returned.")) (|leftDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{leftDivide(a,b)} returns the pair \\spad{[q,r]} such that \\spad{a = \\spad{b*q} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. This process is called ``left division''.")) (|primitivePart| (($ $) "\\spad{primitivePart(l)} returns \\spad{l0} such that \\spad{l = a * \\spad{l0}} for some a in \\spad{R,} and \\spad{content(l0) = 1}.")) (|content| ((|#2| $) "\\spad{content(l)} returns the \\spad{gcd} of all the coefficients of \\spad{l.}")) (|monicRightDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{monicRightDivide(a,b)} returns the pair \\spad{[q,r]} such that \\spad{a = \\spad{q*b} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. \\spad{b} must be monic. This process is called ``right division''.")) (|monicLeftDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{monicLeftDivide(a,b)} returns the pair \\spad{[q,r]} such that \\spad{a = \\spad{b*q} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. \\spad{b} must be monic. This process is called ``left division''.")) (|exquo| (((|Union| $ "failed") $ |#2|) "\\spad{exquo(l, a)} returns the exact quotient of \\spad{l} by a, returning \\axiom{\"failed\"} if this is not possible.")) (|apply| ((|#2| $ |#2| |#2|) "\\spad{apply(p, \\spad{c,} \\spad{m)}} returns \\spad{p(m)} where the action is given by \\spad{x \\spad{m} = \\spad{c} sigma(m) + delta(m)}.")) (|coefficients| (((|List| |#2|) $) "\\spad{coefficients(l)} returns the list of all the nonzero coefficients of \\spad{l.}")) (|monomial| (($ |#2| (|NonNegativeInteger|)) "\\spad{monomial(c,k)} produces \\spad{c} times the \\spad{k}-th power of the generating operator, \\spad{monomial(1,1)}.")) (|coefficient| ((|#2| $ (|NonNegativeInteger|)) "\\spad{coefficient(l,k)} is \\spad{a(k)} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}")) (|reductum| (($ $) "\\spad{reductum(l)} is \\spad{l - monomial(a(n),n)} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}")) (|leadingCoefficient| ((|#2| $) "\\spad{leadingCoefficient(l)} is \\spad{a(n)} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}")) (|minimumDegree| (((|NonNegativeInteger|) $) "\\spad{minimumDegree(l)} is the smallest \\spad{k} such that \\spad{a(k) \\spad{^=} 0} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}")) (|degree| (((|NonNegativeInteger|) $) "\\spad{degree(l)} is \\spad{n} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}"))) 
NIL 
((|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) 
(|UnivariateSkewPolynomialCategory| R) 
((|constructor| (NIL "This is the category of univariate skew polynomials over an Ore coefficient ring. The multiplication is given by \\spad{x a = \\sigma(a) \\spad{x} + \\delta a}. This category is an evolution of the types MonogenicLinearOperator, OppositeMonogenicLinearOperator, and NonCommutativeOperatorDivision")) (|leftLcm| (($ $ $) "\\spad{leftLcm(a,b)} computes the value \\spad{m} of lowest degree such that \\spad{m = aa*a = bb*b} for some values \\spad{aa} and \\spad{bb}. The value \\spad{m} is computed using right-division.")) (|rightExtendedGcd| (((|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $)) $ $) "\\spad{rightExtendedGcd(a,b)} returns \\spad{[c,d]} such that \\spad{g = \\spad{c} * a + \\spad{d} * \\spad{b} = rightGcd(a, b)}.")) (|rightGcd| (($ $ $) "\\spad{rightGcd(a,b)} computes the value \\spad{g} of highest degree such that \\indented{3}{\\spad{a = aa*g}} \\indented{3}{\\spad{b = bb*g}} for some values \\spad{aa} and \\spad{bb}. The value \\spad{g} is computed using right-division.")) (|rightExactQuotient| (((|Union| $ "failed") $ $) "\\spad{rightExactQuotient(a,b)} computes the value \\spad{q}, if it exists such that \\spad{a = q*b}.")) (|rightRemainder| (($ $ $) "\\spad{rightRemainder(a,b)} computes the pair \\spad{[q,r]} such that \\spad{a = \\spad{q*b} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{r} is returned.")) (|rightQuotient| (($ $ $) "\\spad{rightQuotient(a,b)} computes the pair \\spad{[q,r]} such that \\spad{a = \\spad{q*b} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{q} is returned.")) (|rightDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{rightDivide(a,b)} returns the pair \\spad{[q,r]} such that \\spad{a = \\spad{q*b} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. This process is called ``right division''.")) (|rightLcm| (($ $ $) "\\spad{rightLcm(a,b)} computes the value \\spad{m} of lowest degree such that \\spad{m = a*aa = b*bb} for some values \\spad{aa} and \\spad{bb}. The value \\spad{m} is computed using left-division.")) (|leftExtendedGcd| (((|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $)) $ $) "\\spad{leftExtendedGcd(a,b)} returns \\spad{[c,d]} such that \\spad{g = a * \\spad{c} + \\spad{b} * \\spad{d} = leftGcd(a, b)}.")) (|leftGcd| (($ $ $) "\\spad{leftGcd(a,b)} computes the value \\spad{g} of highest degree such that \\indented{3}{\\spad{a = g*aa}} \\indented{3}{\\spad{b = g*bb}} for some values \\spad{aa} and \\spad{bb}. The value \\spad{g} is computed using left-division.")) (|leftExactQuotient| (((|Union| $ "failed") $ $) "\\spad{leftExactQuotient(a,b)} computes the value \\spad{q}, if it exists, \\indented{1}{such that \\spad{a = b*q}.}")) (|leftRemainder| (($ $ $) "\\spad{leftRemainder(a,b)} computes the pair \\spad{[q,r]} such that \\spad{a = \\spad{b*q} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{r} is returned.")) (|leftQuotient| (($ $ $) "\\spad{leftQuotient(a,b)} computes the pair \\spad{[q,r]} such that \\spad{a = \\spad{b*q} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. The value \\spad{q} is returned.")) (|leftDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{leftDivide(a,b)} returns the pair \\spad{[q,r]} such that \\spad{a = \\spad{b*q} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. This process is called ``left division''.")) (|primitivePart| (($ $) "\\spad{primitivePart(l)} returns \\spad{l0} such that \\spad{l = a * \\spad{l0}} for some a in \\spad{R,} and \\spad{content(l0) = 1}.")) (|content| ((|#1| $) "\\spad{content(l)} returns the \\spad{gcd} of all the coefficients of \\spad{l.}")) (|monicRightDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{monicRightDivide(a,b)} returns the pair \\spad{[q,r]} such that \\spad{a = \\spad{q*b} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. \\spad{b} must be monic. This process is called ``right division''.")) (|monicLeftDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{monicLeftDivide(a,b)} returns the pair \\spad{[q,r]} such that \\spad{a = \\spad{b*q} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. \\spad{b} must be monic. This process is called ``left division''.")) (|exquo| (((|Union| $ "failed") $ |#1|) "\\spad{exquo(l, a)} returns the exact quotient of \\spad{l} by a, returning \\axiom{\"failed\"} if this is not possible.")) (|apply| ((|#1| $ |#1| |#1|) "\\spad{apply(p, \\spad{c,} \\spad{m)}} returns \\spad{p(m)} where the action is given by \\spad{x \\spad{m} = \\spad{c} sigma(m) + delta(m)}.")) (|coefficients| (((|List| |#1|) $) "\\spad{coefficients(l)} returns the list of all the nonzero coefficients of \\spad{l.}")) (|monomial| (($ |#1| (|NonNegativeInteger|)) "\\spad{monomial(c,k)} produces \\spad{c} times the \\spad{k}-th power of the generating operator, \\spad{monomial(1,1)}.")) (|coefficient| ((|#1| $ (|NonNegativeInteger|)) "\\spad{coefficient(l,k)} is \\spad{a(k)} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}")) (|reductum| (($ $) "\\spad{reductum(l)} is \\spad{l - monomial(a(n),n)} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}")) (|leadingCoefficient| ((|#1| $) "\\spad{leadingCoefficient(l)} is \\spad{a(n)} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}")) (|minimumDegree| (((|NonNegativeInteger|) $) "\\spad{minimumDegree(l)} is the smallest \\spad{k} such that \\spad{a(k) \\spad{^=} 0} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}")) (|degree| (((|NonNegativeInteger|) $) "\\spad{degree(l)} is \\spad{n} if \\indented{2}{\\spad{l = sum(monomial(a(i),i), \\spad{i} = 0..n)}.}"))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|UnivariateSkewPolynomialCategoryOps| R C) 
((|constructor| (NIL "\\spad{UnivariateSkewPolynomialCategoryOps} provides products and divisions of univariate skew polynomials.")) (|rightDivide| (((|Record| (|:| |quotient| |#2|) (|:| |remainder| |#2|)) |#2| |#2| (|Automorphism| |#1|)) "\\spad{rightDivide(a, \\spad{b,} sigma)} returns the pair \\spad{[q,r]} such that \\spad{a = \\spad{q*b} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. This process is called ``right division''. \\spad{\\sigma} is the morphism to use.")) (|leftDivide| (((|Record| (|:| |quotient| |#2|) (|:| |remainder| |#2|)) |#2| |#2| (|Automorphism| |#1|)) "\\spad{leftDivide(a, \\spad{b,} sigma)} returns the pair \\spad{[q,r]} such that \\spad{a = \\spad{b*q} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. This process is called ``left division''. \\spad{\\sigma} is the morphism to use.")) (|monicRightDivide| (((|Record| (|:| |quotient| |#2|) (|:| |remainder| |#2|)) |#2| |#2| (|Automorphism| |#1|)) "\\spad{monicRightDivide(a, \\spad{b,} sigma)} returns the pair \\spad{[q,r]} such that \\spad{a = \\spad{q*b} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. \\spad{b} must be monic. This process is called ``right division''. \\spad{\\sigma} is the morphism to use.")) (|monicLeftDivide| (((|Record| (|:| |quotient| |#2|) (|:| |remainder| |#2|)) |#2| |#2| (|Automorphism| |#1|)) "\\spad{monicLeftDivide(a, \\spad{b,} sigma)} returns the pair \\spad{[q,r]} such that \\spad{a = \\spad{b*q} + \\spad{r}} and the degree of \\spad{r} is less than the degree of \\spad{b}. \\spad{b} must be monic. This process is called ``left division''. \\spad{\\sigma} is the morphism to use.")) (|apply| ((|#1| |#2| |#1| |#1| (|Automorphism| |#1|) (|Mapping| |#1| |#1|)) "\\spad{apply(p, \\spad{c,} \\spad{m,} sigma, delta)} returns \\spad{p(m)} where the action is given by \\spad{x \\spad{m} = \\spad{c} sigma(m) + delta(m)}.")) (|times| ((|#2| |#2| |#2| (|Automorphism| |#1|) (|Mapping| |#1| |#1|)) "\\spad{times(p, \\spad{q,} sigma, delta)} returns \\spad{p * \\spad{q}.} \\spad{\\sigma} and \\spad{\\delta} are the maps to use."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) 
(|SparseUnivariateSkewPolynomial| R |sigma| |delta|) 
((|constructor| (NIL "This is the domain of sparse univariate skew polynomials over an Ore coefficient field. The multiplication is given by \\spad{x a = \\sigma(a) \\spad{x} + \\delta a}.")) (|outputForm| (((|OutputForm|) $ (|OutputForm|)) "\\spad{outputForm(p, \\spad{x)}} returns the output form of \\spad{p} using \\spad{x} for the otherwise anonymous variable."))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) 
(|UnivariateSkewPolynomial| |x| R |sigma| |delta|) 
((|constructor| (NIL "This is the domain of univariate skew polynomials over an Ore coefficient field in a named variable. The multiplication is given by \\spad{x a = \\sigma(a) \\spad{x} + \\delta a}.")) (|coerce| (($ (|Variable| |#1|)) "\\spad{coerce(x)} returns \\spad{x} as a skew-polynomial."))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|Field|)))) 
(|OrthogonalPolynomialFunctions| R) 
((|constructor| (NIL "This package provides orthogonal polynomials as functions on a ring.")) (|legendreP| ((|#1| (|NonNegativeInteger|) |#1|) "\\spad{legendreP(n,x)} is the \\spad{n}-th Legendre polynomial, \\spad{P[n](x)}. These are defined by \\spad{1/sqrt(1-2*x*t+t**2) = sum(P[n](x)*t**n, \\spad{n} = 0..)}.")) (|laguerreL| ((|#1| (|NonNegativeInteger|) (|NonNegativeInteger|) |#1|) "\\spad{laguerreL(m,n,x)} is the associated Laguerre polynomial, \\spad{L<m>[n](x)}. This is the \\spad{m}-th derivative of \\spad{L[n](x)}.") ((|#1| (|NonNegativeInteger|) |#1|) "\\spad{laguerreL(n,x)} is the \\spad{n}-th Laguerre polynomial, \\spad{L[n](x)}. These are defined by \\spad{exp(-t*x/(1-t))/(1-t) = sum(L[n](x)*t**n/n!, \\spad{n} = 0..)}.")) (|hermiteH| ((|#1| (|NonNegativeInteger|) |#1|) "\\spad{hermiteH(n,x)} is the \\spad{n}-th Hermite polynomial, \\spad{H[n](x)}. These are defined by \\spad{exp(2*t*x-t**2) = sum(H[n](x)*t**n/n!, \\spad{n} = 0..)}.")) (|chebyshevU| ((|#1| (|NonNegativeInteger|) |#1|) "\\spad{chebyshevU(n,x)} is the \\spad{n}-th Chebyshev polynomial of the second kind, \\spad{U[n](x)}. These are defined by \\spad{1/(1-2*t*x+t**2) = sum(T[n](x) *t**n, \\spad{n} = 0..)}.")) (|chebyshevT| ((|#1| (|NonNegativeInteger|) |#1|) "\\spad{chebyshevT(n,x)} is the \\spad{n}-th Chebyshev polynomial of the first kind, \\spad{T[n](x)}. These are defined by \\spad{(1-t*x)/(1-2*t*x+t**2) = sum(T[n](x) *t**n, \\spad{n} = 0..)}."))) 
NIL 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) 
(|OrdSetInts|) 
((|constructor| (NIL "A domain used in order to take the free R-module on the Integers I. This is actually the forgetful functor from OrderedRings to OrderedSets applied to \\spad{I}")) (|value| (((|Integer|) $) "\\spad{value(x)} returns the integer associated with \\spad{x}")) (|coerce| (($ (|Integer|)) "\\spad{coerce(i)} returns the element corresponding to \\spad{i}"))) 
NIL 
NIL 
(|OutputForm|) 
((|constructor| (NIL "This domain is used to create and manipulate mathematical expressions for output. It is intended to provide an insulating layer between the expression rendering software (\\spadignore{e.g.} TeX, or Script) and the output coercions in the various domains.")) (SEGMENT (($ $) "\\spad{SEGMENT(x)} creates the prefix form: \\spad{x..}.") (($ $ $) "\\spad{SEGMENT(x,y)} creates the infix form: \\spad{x..y}.")) (|not| (($ $) "\\spad{not \\spad{f}} creates the equivalent prefix form.")) (|or| (($ $ $) "\\spad{f or \\spad{g}} creates the equivalent infix form.")) (|and| (($ $ $) "\\spad{f and \\spad{g}} creates the equivalent infix form.")) (|exquo| (($ $ $) "\\spad{exquo(f,g)} creates the equivalent infix form.")) (|quo| (($ $ $) "\\spad{f quo \\spad{g}} creates the equivalent infix form.")) (|rem| (($ $ $) "\\spad{f rem \\spad{g}} creates the equivalent infix form.")) (|div| (($ $ $) "\\spad{f div \\spad{g}} creates the equivalent infix form.")) (** (($ $ $) "\\spad{f \\spad{**} \\spad{g}} creates the equivalent infix form.")) (/ (($ $ $) "\\spad{f / \\spad{g}} creates the equivalent infix form.")) (* (($ $ $) "\\spad{f * \\spad{g}} creates the equivalent infix form.")) (- (($ $) "\\spad{- \\spad{f}} creates the equivalent prefix form.") (($ $ $) "\\spad{f - \\spad{g}} creates the equivalent infix form.")) (+ (($ $ $) "\\spad{f + \\spad{g}} creates the equivalent infix form.")) (>= (($ $ $) "\\spad{f \\spad{>=} \\spad{g}} creates the equivalent infix form.")) (<= (($ $ $) "\\spad{f \\spad{<=} \\spad{g}} creates the equivalent infix form.")) (> (($ $ $) "\\spad{f > \\spad{g}} creates the equivalent infix form.")) (< (($ $ $) "\\spad{f < \\spad{g}} creates the equivalent infix form.")) (^= (($ $ $) "\\spad{f \\spad{^=} \\spad{g}} creates the equivalent infix form.")) (= (($ $ $) "\\spad{f = \\spad{g}} creates the equivalent infix form.")) (|blankSeparate| (($ (|List| $)) "\\spad{blankSeparate(l)} creates the form separating the elements of \\spad{l} by blanks.")) (|semicolonSeparate| (($ (|List| $)) "\\spad{semicolonSeparate(l)} creates the form separating the elements of \\spad{l} by semicolons.")) (|commaSeparate| (($ (|List| $)) "\\spad{commaSeparate(l)} creates the form separating the elements of \\spad{l} by commas.")) (|pile| (($ (|List| $)) "\\spad{pile(l)} creates the form consisting of the elements of \\spad{l} which displays as a pile, \\spadignore{i.e.} the elements begin on a new line and are indented right to the same margin.")) (|paren| (($ (|List| $)) "\\spad{paren(lf)} creates the form separating the elements of \\spad{lf} by commas and encloses the result in parentheses.") (($ $) "\\spad{paren(f)} creates the form enclosing \\spad{f} in parentheses.")) (|bracket| (($ (|List| $)) "\\spad{bracket(lf)} creates the form separating the elements of \\spad{lf} by commas and encloses the result in square brackets.") (($ $) "\\spad{bracket(f)} creates the form enclosing \\spad{f} in square brackets.")) (|brace| (($ (|List| $)) "\\spad{brace(lf)} creates the form separating the elements of \\spad{lf} by commas and encloses the result in curly brackets.") (($ $) "\\spad{brace(f)} creates the form enclosing \\spad{f} in braces (curly brackets).")) (|int| (($ $ $ $) "\\spad{int(expr,lowerlimit,upperlimit)} creates the form prefixing \\spad{expr} by an integral sign with both a \\spad{lowerlimit} and upperlimit.") (($ $ $) "\\spad{int(expr,lowerlimit)} creates the form prefixing \\spad{expr} by an integral sign with a lowerlimit.") (($ $) "\\spad{int(expr)} creates the form prefixing \\spad{expr} with an integral sign.")) (|prod| (($ $ $ $) "\\spad{prod(expr,lowerlimit,upperlimit)} creates the form prefixing \\spad{expr} by a capital \\spad{pi} with both a \\spad{lowerlimit} and upperlimit.") (($ $ $) "\\spad{prod(expr,lowerlimit)} creates the form prefixing \\spad{expr} by a capital \\spad{pi} with a lowerlimit.") (($ $) "\\spad{prod(expr)} creates the form prefixing \\spad{expr} by a capital pi.")) (|sum| (($ $ $ $) "\\spad{sum(expr,lowerlimit,upperlimit)} creates the form prefixing \\spad{expr} by a capital sigma with both a \\spad{lowerlimit} and upperlimit.") (($ $ $) "\\spad{sum(expr,lowerlimit)} creates the form prefixing \\spad{expr} by a capital sigma with a lowerlimit.") (($ $) "\\spad{sum(expr)} creates the form prefixing \\spad{expr} by a capital sigma.")) (|overlabel| (($ $ $) "\\spad{overlabel(x,f)} creates the form \\spad{f} with \\spad{\"x} overbar\" over the top.")) (|overbar| (($ $) "\\spad{overbar(f)} creates the form \\spad{f} with an overbar.")) (|prime| (($ $ (|NonNegativeInteger|)) "\\spad{prime(f,n)} creates the form \\spad{f} followed by \\spad{n} primes.") (($ $) "\\spad{prime(f)} creates the form \\spad{f} followed by a suffix prime (single quote).")) (|dot| (($ $ (|NonNegativeInteger|)) "\\spad{dot(f,n)} creates the form \\spad{f} with \\spad{n} dots overhead.") (($ $) "\\spad{dot(f)} creates the form with a one dot overhead.")) (|quote| (($ $) "\\spad{quote(f)} creates the form \\spad{f} with a prefix quote.")) (|supersub| (($ $ (|List| $)) "\\spad{supersub(a,[sub1,super1,sub2,super2,...])} creates a form with each subscript aligned under each superscript.")) (|scripts| (($ $ (|List| $)) "\\spad{scripts(f, [sub, super, presuper, presub])} \\indented{1}{creates a form for \\spad{f} with scripts on all 4 corners.}")) (|presuper| (($ $ $) "\\spad{presuper(f,n)} creates a form for \\spad{f} presuperscripted by \\spad{n.}")) (|presub| (($ $ $) "\\spad{presub(f,n)} creates a form for \\spad{f} presubscripted by \\spad{n.}")) (|super| (($ $ $) "\\spad{super(f,n)} creates a form for \\spad{f} superscripted by \\spad{n.}")) (|sub| (($ $ $) "\\spad{sub(f,n)} creates a form for \\spad{f} subscripted by \\spad{n.}")) (|binomial| (($ $ $) "\\spad{binomial(n,m)} creates a form for the binomial coefficient of \\spad{n} and \\spad{m.}")) (|differentiate| (($ $ (|NonNegativeInteger|)) "\\spad{differentiate(f,n)} creates a form for the \\spad{n}th derivative of \\spad{f,} \\spadignore{e.g.} \\spad{f'}, \\spad{f''}, \\spad{f'''}, \\spad{\"f} super \\spad{iv}\".")) (|rarrow| (($ $ $) "\\spad{rarrow(f,g)} creates a form for the mapping \\spad{f \\spad{->} \\spad{g}.}")) (|assign| (($ $ $) "\\spad{assign(f,g)} creates a form for the assignment \\spad{f \\spad{:=} \\spad{g}.}")) (|slash| (($ $ $) "\\spad{slash(f,g)} creates a form for the horizontal fraction of \\spad{f} over \\spad{g.}")) (|over| (($ $ $) "\\spad{over(f,g)} creates a form for the vertical fraction of \\spad{f} over \\spad{g.}")) (|root| (($ $ $) "\\spad{root(f,n)} creates a form for the \\spad{n}th root of form \\spad{f.}") (($ $) "\\spad{root(f)} creates a form for the square root of form \\spad{f.}")) (|zag| (($ $ $) "\\spad{zag(f,g)} creates a form for the continued fraction form for \\spad{f} over \\spad{g.}")) (|matrix| (($ (|List| (|List| $))) "\\spad{matrix(llf)} makes \\spad{llf} (a list of lists of forms) into a form which displays as a matrix.")) (|box| (($ $) "\\spad{box(f)} encloses \\spad{f} in a box.")) (|label| (($ $ $) "\\spad{label(n,f)} gives form \\spad{f} an equation label \\spad{n.}")) (|string| (($ $) "\\spad{string(f)} creates \\spad{f} with string quotes.")) (|elt| (($ $ (|List| $)) "\\spad{elt(op,l)} creates a form for application of \\spad{op} to list of arguments \\spad{l.}")) (|infix?| (((|Boolean|) $) "\\spad{infix?(op)} returns \\spad{true} if \\spad{op} is an infix operator, and \\spad{false} otherwise.")) (|postfix| (($ $ $) "\\spad{postfix(op, a)} creates a form which prints as: a op.")) (|infix| (($ $ $ $) "\\spad{infix(op, a, \\spad{b)}} creates a form which prints as: a \\spad{op} \\spad{b.}") (($ $ (|List| $)) "\\spad{infix(f,l)} creates a form depicting the n-ary application of infix operation \\spad{f} to a tuple of arguments \\spad{l.}")) (|prefix| (($ $ (|List| $)) "\\spad{prefix(f,l)} creates a form depicting the n-ary prefix application of \\spad{f} to a tuple of arguments given by list \\spad{l.}")) (|vconcat| (($ (|List| $)) "\\spad{vconcat(u)} vertically concatenates all forms in list u.") (($ $ $) "\\spad{vconcat(f,g)} vertically concatenates forms \\spad{f} and \\spad{g.}")) (|hconcat| (($ (|List| $)) "\\spad{hconcat(u)} horizontally concatenates all forms in list u.") (($ $ $) "\\spad{hconcat(f,g)} horizontally concatenate forms \\spad{f} and \\spad{g.}")) (|center| (($ $) "\\spad{center(f)} centers form \\spad{f} in total space.") (($ $ (|Integer|)) "\\spad{center(f,n)} centers form \\spad{f} within space of width \\spad{n.}")) (|right| (($ $) "\\spad{right(f)} right-justifies form \\spad{f} in total space.") (($ $ (|Integer|)) "\\spad{right(f,n)} right-justifies form \\spad{f} within space of width \\spad{n.}")) (|left| (($ $) "\\spad{left(f)} left-justifies form \\spad{f} in total space.") (($ $ (|Integer|)) "\\spad{left(f,n)} left-justifies form \\spad{f} within space of width \\spad{n.}")) (|rspace| (($ (|Integer|) (|Integer|)) "\\spad{rspace(n,m)} creates rectangular white space, \\spad{n} wide by \\spad{m} high.")) (|vspace| (($ (|Integer|)) "\\spad{vspace(n)} creates white space of height \\spad{n.}")) (|hspace| (($ (|Integer|)) "\\spad{hspace(n)} creates white space of width \\spad{n.}")) (|superHeight| (((|Integer|) $) "\\spad{superHeight(f)} returns the height of form \\spad{f} above the base line.")) (|subHeight| (((|Integer|) $) "\\spad{subHeight(f)} returns the height of form \\spad{f} below the base line.")) (|height| (((|Integer|)) "\\spad{height()} returns the height of the display area (an integer).") (((|Integer|) $) "\\spad{height(f)} returns the height of form \\spad{f} (an integer).")) (|width| (((|Integer|)) "\\spad{width()} returns the width of the display area (an integer).") (((|Integer|) $) "\\spad{width(f)} returns the width of form \\spad{f} (an integer).")) (|empty| (($) "\\spad{empty()} creates an empty form.")) (|outputForm| (($ (|DoubleFloat|)) "\\spad{outputForm(sf)} creates an form for small float \\spad{sf.}") (($ (|String|)) "\\spad{outputForm(s)} creates an form for string \\spad{s.}") (($ (|Symbol|)) "\\spad{outputForm(s)} creates an form for symbol \\spad{s.}") (($ (|Integer|)) "\\spad{outputForm(n)} creates an form for integer \\spad{n.}")) (|messagePrint| (((|Void|) (|String|)) "\\spad{messagePrint(s)} prints \\spad{s} without string quotes. Note: \\spad{messagePrint(s)} is equivalent to \\spad{print message(s)}.")) (|message| (($ (|String|)) "\\spad{message(s)} creates an form with no string quotes from string \\spad{s.}")) (|print| (((|Void|) $) "\\spad{print(u)} prints the form u."))) 
NIL 
NIL 
(|OutputPackage|) 
((|constructor| (NIL "OutPackage allows pretty-printing from programs.")) (|outputList| (((|Void|) (|List| (|Any|))) "\\spad{outputList(l)} displays the concatenated components of the list \\spad{l} on the ``algebra output'' stream, as defined by \\spadsyscom{set output algebra}; quotes are stripped from strings.")) (|output| (((|Void|) (|String|) (|OutputForm|)) "\\spad{output(s,x)} displays the string \\spad{s} followed by the form \\spad{x} on the ``algebra output'' stream, as defined by \\spadsyscom{set output algebra}.") (((|Void|) (|OutputForm|)) "\\spad{output(x)} displays the output form \\spad{x} on the ``algebra output'' stream, as defined by \\spadsyscom{set output algebra}.") (((|Void|) (|String|)) "\\spad{output(s)} displays the string \\spad{s} on the ``algebra output'' stream, as defined by \\spadsyscom{set output algebra}."))) 
NIL 
NIL 
(|OrderedVariableList| |VariableList|) 
((|constructor| (NIL "This domain implements ordered variables")) (|variable| (((|Union| $ "failed") (|Symbol|)) "\\spad{variable(s)} returns a member of the variable set or failed"))) 
NIL 
NIL 
(|OrdinaryWeightedPolynomials| R |vl| |wl| |wtlevel|) 
((|constructor| (NIL "This domain represents truncated weighted polynomials over the \"Polynomial\" type. The variables must be specified, as must the weights. The representation is sparse in the sense that only non-zero terms are represented.")) (|changeWeightLevel| (((|Void|) (|NonNegativeInteger|)) "\\spad{changeWeightLevel(n)} This changes the weight level to the new value given: \\spad{NB:} previously calculated terms are not affected")) (/ (((|Union| $ "failed") $ $) "\\spad{x/y} division (only works if minimum weight of divisor is zero, and if \\spad{R} is a Field)")) (|coerce| (($ (|Polynomial| |#1|)) "\\spad{coerce(p)} coerces a Polynomial(R) into Weighted form, applying weights and ignoring terms") (((|Polynomial| |#1|) $) "\\spad{coerce(p)} converts back into a Polynomial(R), ignoring weights"))) 
((|leftUnitary| |has| |#1| (|CommutativeRing|)) (|rightUnitary| |has| |#1| (|CommutativeRing|)) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|)))) 
(|PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory|) 
((|constructor| (NIL "This category exports the function for the domain PseudoAlgebraicClosureOfAlgExtOfRationalNumber which implement dynamic extension using the simple notion of tower extensions. A tower extension \\spad{T} of the ground field \\spad{K} is any sequence of field extension \\spad{(T} : K_0, K_1, ..., K_i...,K_n) where \\spad{K_0} = \\spad{K} and for \\spad{i} =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1 and defined by an irreducible polynomial p(Z) in K_{i-1}. Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1) and (T_2: K_02, K_12,...,K_i2,...,K_n2) are said to be related if \\spad{T_1} \\spad{<=} \\spad{T_2} (or \\spad{T_1} \\spad{>=} T_2), that is if \\spad{K_i1} = \\spad{K_i2} for \\spad{i=1,2,...,n1} (or i=1,2,...,n2). Any algebraic operations defined for several elements are only defined if all of the concerned elements are comming from a set of related tour extensions."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|PseudoAlgebraicClosureOfAlgExtOfRationalNumber| |downLevel|) 
((|constructor| (NIL "This domain implement dynamic extension over the PseudoAlgebraicClosureOfRationalNumber. A tower extension \\spad{T} of the ground field \\spad{K} is any sequence of field extension \\spad{(T} : K_0, K_1, ..., K_i...,K_n) where \\spad{K_0} = \\spad{K} and for \\spad{i} =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1 and defined by an irreducible polynomial p(Z) in K_{i-1}. Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1) and (T_2: K_02, K_12,...,K_i2,...,K_n2) are said to be related if \\spad{T_1} \\spad{<=} \\spad{T_2} (or \\spad{T_1} \\spad{>=} T_2), that is if \\spad{K_i1} = \\spad{K_i2} for \\spad{i=1,2,...,n1} (or i=1,2,...,n2). Any algebraic operations defined for several elements are only defined if all of the concerned elements are comming from a set of related tour extensions."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|PseudoAlgebraicClosureOfRationalNumber|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|PseudoAlgebraicClosureOfRationalNumber|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|PseudoAlgebraicClosureOfRationalNumber|) (QUOTE (|Finite|))) (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|Finite|))) (OR (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|Finite|))) (|HasCategory| (|PseudoAlgebraicClosureOfRationalNumber|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|PseudoAlgebraicClosureOfRationalNumber|) (QUOTE (|Finite|)))) (OR (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|Finite|))) (|HasCategory| (|PseudoAlgebraicClosureOfRationalNumber|) (QUOTE (|Finite|))))) 
(|PseudoAlgebraicClosureOfFiniteFieldCategory|) 
((|constructor| (NIL "This category exports the function for the domain PseudoAlgebraicClosureOfFiniteField which implement dynamic extension using the simple notion of tower extensions. A tower extension \\spad{T} of the ground field \\spad{K} is any sequence of field extension \\spad{(T} : K_0, K_1, ..., K_i...,K_n) where \\spad{K_0} = \\spad{K} and for \\spad{i} =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1 and defined by an irreducible polynomial p(Z) in K_{i-1}. Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1) and (T_2: K_02, K_12,...,K_i2,...,K_n2) are said to be related if \\spad{T_1} \\spad{<=} \\spad{T_2} (or \\spad{T_1} \\spad{>=} T_2), that is if \\spad{K_i1} = \\spad{K_i2} for \\spad{i=1,2,...,n1} (or i=1,2,...,n2). Any algebraic operations defined for several elements are only defined if all of the concerned elements are comming from a set of related tour extensions."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|PseudoAlgebraicClosureOfFiniteField| K) 
((|constructor| (NIL "This domain implement dynamic extension using the simple notion of tower extensions. A tower extension \\spad{T} of the ground field \\spad{K} is any sequence of field extension \\spad{(T} : K_0, K_1, ..., K_i...,K_n) where \\spad{K_0} = \\spad{K} and for \\spad{i} =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1 and defined by an irreducible polynomial p(Z) in K_{i-1}. Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1) and (T_2: K_02, K_12,...,K_i2,...,K_n2) are said to be related if \\spad{T_1} \\spad{<=} \\spad{T_2} (or \\spad{T_1} \\spad{>=} T_2), that is if \\spad{K_i1} = \\spad{K_i2} for \\spad{i=1,2,...,n1} (or i=1,2,...,n2). Any algebraic operations defined for several elements are only defined if all of the concerned elements are comming from a set of related tour extensions."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|Finite|)))) 
(|PseudoAlgebraicClosureOfPerfectFieldCategory|) 
((|constructor| (NIL "This category exports the function for domains which implement dynamic extension using the simple notion of tower extensions. \\spad{++} A tower extension \\spad{T} of the ground field \\spad{K} is any sequence of field extension \\spad{(T} : K_0, K_1, ..., K_i...,K_n) where \\spad{K_0} = \\spad{K} and for \\spad{i} =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1 and defined by an irreducible polynomial p(Z) in K_{i-1}. Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1) and (T_2: K_02, K_12,...,K_i2,...,K_n2) are said to be related if \\spad{T_1} \\spad{<=} \\spad{T_2} (or \\spad{T_1} \\spad{>=} T_2), that is if \\spad{K_i1} = \\spad{K_i2} for \\spad{i=1,2,...,n1} (or i=1,2,...,n2). Any algebraic operations defined for several elements are only defined if all of the concerned elements are coming from a set of related tower extensions.")) (|previousTower| (($ $) "\\spad{previousTower(a)} returns the previous tower extension over which the element a is defined.")) (|extDegree| (((|PositiveInteger|) $) "\\spad{extDegree(a)} returns the extension degree of the extension tower over which the element is defined.")) (|maxTower| (($ (|List| $)) "\\spad{maxTower(l)} returns the tower in the list having the maximal extension degree over the ground field. It has no meaning if the towers are not related.")) (|distinguishedRootsOf| (((|List| $) (|SparseUnivariatePolynomial| $) $) "\\spad{distinguishedRootsOf(p,a)} returns a (distinguised) root for each irreducible factor of the polynomial \\spad{p} (factored over the field defined by the element a)."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|PseudoAlgebraicClosureOfRationalNumberCategory|) 
((|constructor| (NIL "This category exports the function for the domain PseudoAlgebraicClosureOfRationalNumber which implement dynamic extension using the simple notion of tower extensions. A tower extension \\spad{T} of the ground field \\spad{K} is any sequence of field extension \\spad{(T} : K_0, K_1, ..., K_i...,K_n) where \\spad{K_0} = \\spad{K} and for \\spad{i} =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1 and defined by an irreducible polynomial p(Z) in K_{i-1}. Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1) and (T_2: K_02, K_12,...,K_i2,...,K_n2) are said to be related if \\spad{T_1} \\spad{<=} \\spad{T_2} (or \\spad{T_1} \\spad{>=} T_2), that is if \\spad{K_i1} = \\spad{K_i2} for \\spad{i=1,2,...,n1} (or i=1,2,...,n2). Any algebraic operations defined for several elements are only defined if all of the concerned elements are comming from a set of related tour extensions."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|PseudoAlgebraicClosureOfRationalNumber|) 
((|constructor| (NIL "This domain implements dynamic extension using the simple notion of tower extensions. A tower extension \\spad{T} of the ground field \\spad{K} is any sequence of field extension \\spad{(T} : K_0, K_1, ..., K_i...,K_n) where \\spad{K_0} = \\spad{K} and for \\spad{i} =1,2,...,n, K_i is an extension of K_{i-1} of degree > 1 and defined by an irreducible polynomial p(Z) in K_{i-1}. Two towers (T_1: K_01, K_11,...,K_i1,...,K_n1) and (T_2: K_02, K_12,...,K_i2,...,K_n2) are said to be related if \\spad{T_1} \\spad{<=} \\spad{T_2} (or \\spad{T_1} \\spad{>=} T_2), that is if \\spad{K_i1} = \\spad{K_i2} for \\spad{i=1,2,...,n1} (or i=1,2,...,n2). Any algebraic operations defined for several elements are only defined if all of the concerned elements are comming from a set of related tour extensions."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|Finite|))) (OR (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|Finite|))))) 
(|PadeApproximants| R PS UP) 
((|constructor| (NIL "This package computes reliable Pad&ea. approximants using a generalized Viskovatov continued fraction algorithm.")) (|padecf| (((|Union| (|ContinuedFraction| |#3|) "failed") (|NonNegativeInteger|) (|NonNegativeInteger|) |#2| |#2|) "\\spad{padecf(nd,dd,ns,ds)} computes the approximant as a continued fraction of polynomials (if it exists) for arguments \\spad{nd} (numerator degree of approximant), \\spad{dd} (denominator degree of approximant), \\spad{ns} (numerator series of function), and \\spad{ds} (denominator series of function).")) (|pade| (((|Union| (|Fraction| |#3|) "failed") (|NonNegativeInteger|) (|NonNegativeInteger|) |#2| |#2|) "\\spad{pade(nd,dd,ns,ds)} computes the approximant as a quotient of polynomials (if it exists) for arguments \\spad{nd} (numerator degree of approximant), \\spad{dd} (denominator degree of approximant), \\spad{ns} (numerator series of function), and \\spad{ds} (denominator series of function)."))) 
NIL 
NIL 
(|PadeApproximantPackage| R |x| |pt|) 
((|constructor| (NIL "This package computes reliable Pad&ea. approximants using a generalized Viskovatov continued fraction algorithm.")) (|pade| (((|Union| (|Fraction| (|UnivariatePolynomial| |#2| |#1|)) "failed") (|NonNegativeInteger|) (|NonNegativeInteger|) (|UnivariateTaylorSeries| |#1| |#2| |#3|)) "\\spad{pade(nd,dd,s)} computes the quotient of polynomials (if it exists) with numerator degree at most \\spad{nd} and denominator degree at most \\spad{dd} which matches the series \\spad{s} to order \\spad{nd + dd}.") (((|Union| (|Fraction| (|UnivariatePolynomial| |#2| |#1|)) "failed") (|NonNegativeInteger|) (|NonNegativeInteger|) (|UnivariateTaylorSeries| |#1| |#2| |#3|) (|UnivariateTaylorSeries| |#1| |#2| |#3|)) "\\spad{pade(nd,dd,ns,ds)} computes the approximant as a quotient of polynomials (if it exists) for arguments \\spad{nd} (numerator degree of approximant), \\spad{dd} (denominator degree of approximant), \\spad{ns} (numerator series of function), and \\spad{ds} (denominator series of function)."))) 
NIL 
NIL 
(|PAdicIntegerCategory| |p|) 
((|constructor| (NIL "This is the category of stream-based representations of the p-adic integers.")) (|root| (($ (|SparseUnivariatePolynomial| (|Integer|)) (|Integer|)) "\\spad{root(f,a)} returns a root of the polynomial \\spad{f}. Argument \\spad{a} must be a root of \\spad{f} \\spad{(mod p)}.")) (|sqrt| (($ $ (|Integer|)) "\\spad{sqrt(b,a)} returns a square root of \\spad{b.} Argument \\spad{a} is a square root of \\spad{b} \\spad{(mod p)}.")) (|approximate| (((|Integer|) $ (|Integer|)) "\\spad{approximate(x,n)} returns an integer \\spad{y} such that \\spad{y = \\spad{x} (mod p^n)} when \\spad{n} is positive, and 0 otherwise.")) (|quotientByP| (($ $) "\\spad{quotientByP(x)} returns \\spad{b,} where \\spad{x = a + \\spad{b} \\spad{p}.}")) (|moduloP| (((|Integer|) $) "\\spad{modulo(x)} returns a, where \\spad{x = a + \\spad{b} \\spad{p}.}")) (|modulus| (((|Integer|)) "\\spad{modulus()} returns the value of \\spad{p.}")) (|complete| (($ $) "\\spad{complete(x)} forces the computation of all digits.")) (|extend| (($ $ (|Integer|)) "\\spad{extend(x,n)} forces the computation of digits up to order \\spad{n.}")) (|order| (((|NonNegativeInteger|) $) "\\spad{order(x)} returns the exponent of the highest power of \\spad{p} dividing \\spad{x.}")) (|digits| (((|Stream| (|Integer|)) $) "\\spad{digits(x)} returns a stream of p-adic digits of \\spad{x.}"))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|PAdicInteger| |p|) 
((|constructor| (NIL "Stream-based implementation of \\spad{Zp:} p-adic numbers are represented as sum(i = 0.., a[i] * p^i), where the a[i] lie in 0,1,...,(p - 1)."))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|PAdicRational| |p|) 
((|constructor| (NIL "Stream-based implementation of \\spad{Qp:} numbers are represented as sum(i = k.., a[i] * p^i) where the a[i] lie in 0,1,...,(p - 1)."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| (|PAdicInteger| |#1|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|PAdicInteger| |#1|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|RealConstant|))) (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|PAdicInteger| |#1|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|StepThrough|))) (|HasCategory| (|PAdicInteger| |#1|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| (|PAdicInteger| |#1|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| (|PAdicInteger| |#1|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| (|PAdicInteger| |#1|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| (|PAdicInteger| |#1|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|DifferentialRing|))) (|HasCategory| (|PAdicInteger| |#1|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|PAdicInteger| |#1|) (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (LIST (QUOTE |PAdicInteger|) (|devaluate| |#1|)))) (|HasCategory| (|PAdicInteger| |#1|) (LIST (QUOTE |Evalable|) (LIST (QUOTE |PAdicInteger|) (|devaluate| |#1|)))) (|HasCategory| (|PAdicInteger| |#1|) (LIST (QUOTE |Eltable|) (LIST (QUOTE |PAdicInteger|) (|devaluate| |#1|)) (LIST (QUOTE |PAdicInteger|) (|devaluate| |#1|)))) (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|IntegerNumberSystem|))) (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|OrderedSet|))) (OR (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|OrderedSet|)))) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| (|PAdicInteger| |#1|) (QUOTE (|CharacteristicNonZero|))))) 
(|PAdicRationalConstructor| |p| PADIC) 
((|constructor| (NIL "This is the category of stream-based representations of \\spad{Qp.}")) (|removeZeroes| (($ (|Integer|) $) "\\spad{removeZeroes(n,x)} removes up to \\spad{n} leading zeroes from the p-adic rational \\spad{x}.") (($ $) "\\spad{removeZeroes(x)} removes leading zeroes from the representation of the p-adic rational \\spad{x}. A p-adic rational is represented by \\spad{(1)} an exponent and \\spad{(2)} a p-adic integer which may have leading zero digits. When the p-adic integer has a leading zero digit, a 'leading zero' is removed from the p-adic rational as follows: the number is rewritten by increasing the exponent by 1 and dividing the p-adic integer by \\spad{p.} Note: \\spad{removeZeroes(f)} removes all leading zeroes from \\spad{f.}")) (|continuedFraction| (((|ContinuedFraction| (|Fraction| (|Integer|))) $) "\\spad{continuedFraction(x)} converts the p-adic rational number \\spad{x} to a continued fraction.")) (|approximate| (((|Fraction| (|Integer|)) $ (|Integer|)) "\\spad{approximate(x,n)} returns a rational number \\spad{y} such that \\spad{y = \\spad{x} (mod p^n)}."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (QUOTE (|RealConstant|))) (|HasCategory| |#2| (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|StepThrough|))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |Eltable|) (|devaluate| |#2|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#2| (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#2| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#2| (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#2| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))))) 
(|PackageForAlgebraicFunctionFieldOverFiniteField| K |symb| BLMET) 
((|constructor| (NIL "A package that implements the Brill-Noether algorithm. Part of the PAFF package")) (|ZetaFunction| (((|UnivariateTaylorSeriesCZero| (|Integer|) |t|) (|PositiveInteger|)) "Returns the Zeta function of the curve in constant field extension. Calculated by using the L-Polynomial") (((|UnivariateTaylorSeriesCZero| (|Integer|) |t|)) "Returns the Zeta function of the curve. Calculated by using the L-Polynomial")) (|numberPlacesDegExtDeg| (((|Integer|) (|PositiveInteger|) (|PositiveInteger|)) "numberRatPlacesExtDegExtDeg(d, \\spad{n)} returns the number of places of degree \\spad{d} in the constant field extension of degree \\spad{n}")) (|numberRatPlacesExtDeg| (((|Integer|) (|PositiveInteger|)) "\\spad{numberRatPlacesExtDeg(n)} returns the number of rational places in the constant field extenstion of degree \\spad{n}")) (|numberOfPlacesOfDegree| (((|Integer|) (|PositiveInteger|)) "returns the number of places of the given degree")) (|placesOfDegree| (((|List| (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|)) (|PositiveInteger|)) "\\spad{placesOfDegree(d)} returns all places of degree \\spad{d} of the curve.")) (|classNumber| (((|Integer|)) "Returns the class number of the curve.")) (|LPolynomial| (((|SparseUnivariatePolynomial| (|Integer|)) (|PositiveInteger|)) "\\spad{LPolynomial(d)} returns the L-Polynomial of the curve in constant field extension of degree \\spad{d.}") (((|SparseUnivariatePolynomial| (|Integer|))) "Returns the L-Polynomial of the curve.")) (|adjunctionDivisor| (((|Divisor| (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|))) "\\spad{adjunctionDivisor computes} the adjunction divisor of the plane curve given by the polynomial defined by setCurve.")) (|intersectionDivisor| (((|Divisor| (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|)) (|DistributedMultivariatePolynomial| |#2| |#1|)) "\\spad{intersectionDivisor(pol)} compute the intersection divisor of the form \\spad{pol} with the curve. (If \\spad{pol} is not homogeneous an error message is issued).")) (|evalIfCan| (((|Union| |#1| "failed") (|Fraction| (|DistributedMultivariatePolynomial| |#2| |#1|)) (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|)) "\\spad{evalIfCan(u,pl)} evaluate the function \\spad{u} at the place \\spad{pl} (returns \"failed\" if it is a pole).") (((|Union| |#1| "failed") (|DistributedMultivariatePolynomial| |#2| |#1|) (|DistributedMultivariatePolynomial| |#2| |#1|) (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|)) "\\spad{evalIfCan(f,g,pl)} evaluate the function \\spad{f/g} at the place \\spad{pl} (returns \"failed\" if it is a pole).") (((|Union| |#1| "failed") (|DistributedMultivariatePolynomial| |#2| |#1|) (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|)) "\\spad{evalIfCan(f,pl)} evaluate \\spad{f} at the place \\spad{pl} (returns \"failed\" if it is a pole).")) (|eval| ((|#1| (|Fraction| (|DistributedMultivariatePolynomial| |#2| |#1|)) (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|)) "\\spad{eval(u,pl)} evaluate the function \\spad{u} at the place \\spad{pl.}") ((|#1| (|DistributedMultivariatePolynomial| |#2| |#1|) (|DistributedMultivariatePolynomial| |#2| |#1|) (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|)) "\\spad{eval(f,g,pl)} evaluate the function \\spad{f/g} at the place \\spad{pl.}") ((|#1| (|DistributedMultivariatePolynomial| |#2| |#1|) (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|)) "\\spad{eval(f,pl)} evaluate \\spad{f} at the place \\spad{pl.}")) (|interpolateForms| (((|List| (|DistributedMultivariatePolynomial| |#2| |#1|)) (|Divisor| (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|)) (|NonNegativeInteger|)) "\\spad{interpolateForms(d,n)} returns a basis of the interpolate forms of degree \\spad{n} of the divisor \\spad{d.}")) (|lBasis| (((|Record| (|:| |num| (|List| (|DistributedMultivariatePolynomial| |#2| |#1|))) (|:| |den| (|DistributedMultivariatePolynomial| |#2| |#1|))) (|Divisor| (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|))) "\\spad{lBasis computes} a basis associated to the specified divisor")) (|parametrize| (((|NeitherSparseOrDensePowerSeries| (|PseudoAlgebraicClosureOfFiniteField| |#1|)) (|DistributedMultivariatePolynomial| |#2| |#1|) (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|)) "\\spad{parametrize(f,pl)} returns a local parametrization of \\spad{f} at the place \\spad{pl.}")) (|singularPoints| (((|List| (|ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField| |#1|))) "rationalPoints() returns the singular points of the curve defined by the polynomial given to the package. If the singular points lie in an extension of the specified ground field an error message is issued specifying the extension degree needed to find all singular points.")) (|desingTree| (((|List| (|DesingTree| (|InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField| |#1| |#2| |#3|)))) "\\spad{desingTree returns} the desingularisation trees at all singular points of the curve defined by the polynomial given to the package.")) (|desingTreeWoFullParam| (((|List| (|DesingTree| (|InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField| |#1| |#2| |#3|)))) "\\spad{desingTreeWoFullParam returns} the desingularisation trees at all singular points of the curve defined by the polynomial given to the package. The local parametrizations are not computed.")) (|genus| (((|NonNegativeInteger|)) "\\spad{genus returns} the genus of the curve defined by the polynomial given to the package.")) (|theCurve| (((|DistributedMultivariatePolynomial| |#2| |#1|)) "\\spad{theCurve returns} the specified polynomial for the package.")) (|rationalPlaces| (((|List| (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|))) "\\spad{rationalPlaces returns} all the rational places of the curve defined by the polynomial given to the package.")) (|pointDominateBy| (((|ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField| |#1|) (|PlacesOverPseudoAlgebraicClosureOfFiniteField| |#1|)) "\\spad{pointDominateBy(pl)} returns the projective point dominated by the place \\spad{pl.}"))) 
NIL 
((|HasCategory| (|PseudoAlgebraicClosureOfFiniteField| |#1|) (QUOTE (|Finite|)))) 
(|PackageForAlgebraicFunctionField| K |symb| BLMET) 
((|constructor| (NIL "A package that implements the Brill-Noether algorithm. Part of the PAFF package")) (|ZetaFunction| (((|UnivariateTaylorSeriesCZero| (|Integer|) |t|) (|PositiveInteger|)) "Returns the Zeta function of the curve in constant field extension. Calculated by using the L-Polynomial") (((|UnivariateTaylorSeriesCZero| (|Integer|) |t|)) "Returns the Zeta function of the curve. Calculated by using the L-Polynomial")) (|numberPlacesDegExtDeg| (((|Integer|) (|PositiveInteger|) (|PositiveInteger|)) "numberRatPlacesExtDegExtDeg(d, \\spad{n)} returns the number of places of degree \\spad{d} in the constant field extension of degree \\spad{n}")) (|numberRatPlacesExtDeg| (((|Integer|) (|PositiveInteger|)) "\\spad{numberRatPlacesExtDeg(n)} returns the number of rational places in the constant field extenstion of degree \\spad{n}")) (|numberOfPlacesOfDegree| (((|Integer|) (|PositiveInteger|)) "returns the number of places of the given degree")) (|placesOfDegree| (((|List| (|Places| |#1|)) (|PositiveInteger|)) "\\spad{placesOfDegree(d)} returns all places of degree \\spad{d} of the curve.")) (|classNumber| (((|Integer|)) "Returns the class number of the curve.")) (|LPolynomial| (((|SparseUnivariatePolynomial| (|Integer|)) (|PositiveInteger|)) "\\spad{LPolynomial(d)} returns the L-Polynomial of the curve in constant field extension of degree \\spad{d.}") (((|SparseUnivariatePolynomial| (|Integer|))) "Returns the L-Polynomial of the curve.")) (|adjunctionDivisor| (((|Divisor| (|Places| |#1|))) "\\spad{adjunctionDivisor computes} the adjunction divisor of the plane curve given by the polynomial set with the function setCurve.")) (|intersectionDivisor| (((|Divisor| (|Places| |#1|)) (|DistributedMultivariatePolynomial| |#2| |#1|)) "\\spad{intersectionDivisor(pol)} compute the intersection divisor (the Cartier divisor) of the form \\spad{pol} with the curve. If some intersection points lie in an extension of the ground field, an error message is issued specifying the extension degree needed to find all the intersection points. (If \\spad{pol} is not homogeneous an error message is issued).")) (|evalIfCan| (((|Union| |#1| "failed") (|Fraction| (|DistributedMultivariatePolynomial| |#2| |#1|)) (|Places| |#1|)) "\\spad{evalIfCan(u,pl)} evaluate the function \\spad{u} at the place \\spad{pl} (returns \"failed\" if it is a pole).") (((|Union| |#1| "failed") (|DistributedMultivariatePolynomial| |#2| |#1|) (|DistributedMultivariatePolynomial| |#2| |#1|) (|Places| |#1|)) "\\spad{evalIfCan(f,g,pl)} evaluate the function \\spad{f/g} at the place \\spad{pl} (returns \"failed\" if it is a pole).") (((|Union| |#1| "failed") (|DistributedMultivariatePolynomial| |#2| |#1|) (|Places| |#1|)) "\\spad{evalIfCan(f,pl)} evaluate \\spad{f} at the place \\spad{pl} (returns \"failed\" if it is a pole).")) (|eval| ((|#1| (|Fraction| (|DistributedMultivariatePolynomial| |#2| |#1|)) (|Places| |#1|)) "\\spad{eval(u,pl)} evaluate the function \\spad{u} at the place \\spad{pl.}") ((|#1| (|DistributedMultivariatePolynomial| |#2| |#1|) (|DistributedMultivariatePolynomial| |#2| |#1|) (|Places| |#1|)) "\\spad{eval(f,g,pl)} evaluate the function \\spad{f/g} at the place \\spad{pl.}") ((|#1| (|DistributedMultivariatePolynomial| |#2| |#1|) (|Places| |#1|)) "\\spad{eval(f,pl)} evaluate \\spad{f} at the place \\spad{pl.}")) (|interpolateForms| (((|List| (|DistributedMultivariatePolynomial| |#2| |#1|)) (|Divisor| (|Places| |#1|)) (|NonNegativeInteger|)) "\\spad{interpolateForms(d,n)} returns a basis of the interpolate forms of degree \\spad{n} of the divisor \\spad{d.}")) (|lBasis| (((|Record| (|:| |num| (|List| (|DistributedMultivariatePolynomial| |#2| |#1|))) (|:| |den| (|DistributedMultivariatePolynomial| |#2| |#1|))) (|Divisor| (|Places| |#1|))) "\\spad{lBasis computes} a basis associated to the specified divisor")) (|parametrize| (((|NeitherSparseOrDensePowerSeries| |#1|) (|DistributedMultivariatePolynomial| |#2| |#1|) (|Places| |#1|)) "\\spad{parametrize(f,pl)} returns a local parametrization of \\spad{f} at the place \\spad{pl.}")) (|singularPoints| (((|List| (|ProjectivePlane| |#1|))) "rationalPoints() returns the singular points of the curve defined by the polynomial given to the package. If the singular points lie in an extension of the specified ground field an error message is issued specifying the extension degree needed to find all singular points.")) (|desingTree| (((|List| (|DesingTree| (|InfClsPt| |#1| |#2| |#3|)))) "\\spad{desingTree returns} the desingularisation trees at all singular points of the curve defined by the polynomial given to the package.")) (|desingTreeWoFullParam| (((|List| (|DesingTree| (|InfClsPt| |#1| |#2| |#3|)))) "\\spad{desingTreeWoFullParam returns} the desingularisation trees at all singular points of the curve defined by the polynomial given to the package. The local parametrizations are not computed.")) (|genus| (((|NonNegativeInteger|)) "\\spad{genus returns} the genus of the curve defined by the polynomial given to the package.")) (|theCurve| (((|DistributedMultivariatePolynomial| |#2| |#1|)) "\\spad{theCurve returns} the specified polynomial for the package.")) (|rationalPlaces| (((|List| (|Places| |#1|))) "\\spad{rationalPlaces returns} all the rational places of the curve defined by the polynomial given to the package.")) (|pointDominateBy| (((|ProjectivePlane| |#1|) (|Places| |#1|)) "\\spad{pointDominateBy(pl)} returns the projective point dominated by the place \\spad{pl.}"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|Finite|)))) 
(|Palette|) 
((|constructor| (NIL "This domain describes four groups of color shades (palettes).")) (|coerce| (($ (|Color|)) "\\spad{coerce(c)} sets the average shade for the palette to that of the indicated color \\spad{c.}")) (|shade| (((|Integer|) $) "\\spad{shade(p)} returns the shade index of the indicated palette \\spad{p.}")) (|hue| (((|Color|) $) "\\spad{hue(p)} returns the hue field of the indicated palette \\spad{p.}")) (|light| (($ (|Color|)) "\\spad{light(c)} sets the shade of a hue, \\spad{c,} to it's highest value.")) (|pastel| (($ (|Color|)) "\\spad{pastel(c)} sets the shade of a hue, \\spad{c,} above bright, but below light.")) (|bright| (($ (|Color|)) "\\spad{bright(c)} sets the shade of a hue, \\spad{c,} above dim, but below pastel.")) (|dim| (($ (|Color|)) "\\spad{dim(c)} sets the shade of a hue, \\spad{c,} above dark, but below bright.")) (|dark| (($ (|Color|)) "\\spad{dark(c)} sets the shade of the indicated hue of \\spad{c} to it's lowest value."))) 
NIL 
NIL 
(|PolynomialAN2Expression|) 
((|constructor| (NIL "This package provides a coerce from polynomials over algebraic numbers to \\spadtype{Expression AlgebraicNumber}.")) (|coerce| (((|Expression| (|Integer|)) (|Fraction| (|Polynomial| (|AlgebraicNumber|)))) "\\spad{coerce(rf)} converts \\spad{rf}, a fraction of polynomial \\spad{p} with algebraic number coefficients to \\spadtype{Expression Integer}.") (((|Expression| (|Integer|)) (|Polynomial| (|AlgebraicNumber|))) "\\spad{coerce(p)} converts the polynomial \\spad{p} with algebraic number coefficients to \\spadtype{Expression Integer}."))) 
NIL 
NIL 
(|ParametrizationPackage| K |symb| |PolyRing| E |ProjPt| PCS |Plc|) 
((|constructor| (NIL "The following is part of the PAFF package")) (|parametrize| ((|#6| |#3| |#7| (|Integer|)) "\\spad{parametrize(f,pl,n)} returns t**n * parametrize(f,p).") ((|#6| |#3| |#3| |#7|) "\\spad{parametrize(f,g,pl)} returns the local parametrization of the rational function \\spad{f/g} at the place \\spad{pl.} Note that local parametrization of the place must have first been compute and set. For simple point on a curve, this done with \\spad{pointToPlace}. The local parametrization places corresponding to a leaf in a desingularization tree are compute at the moment of their \"creation\". (See package \\spad{DesingTreePackage}.") ((|#6| |#3| |#7|) "\\spad{parametrize(f,pl)} returns the local parametrization of the polynomial function \\spad{f} at the place \\spad{pl.} Note that local parametrization of the place must have first been compute and set. For simple point on a curve, this done with \\spad{pointToPlace}. The local parametrization places corresponding to a leaf in a desingularization tree are compute at the moment of their \"creation\". (See package \\spad{DesingTreePackage}."))) 
NIL 
NIL 
(|ParametricPlaneCurveFunctions2| CF1 CF2) 
((|constructor| (NIL "This package has no description")) (|map| (((|ParametricPlaneCurve| |#2|) (|Mapping| |#2| |#1|) (|ParametricPlaneCurve| |#1|)) "\\spad{map(f,x)} \\undocumented"))) 
NIL 
NIL 
(|ParametricPlaneCurve| |ComponentFunction|) 
((|constructor| (NIL "ParametricPlaneCurve is used for plotting parametric plane curves in the affine plane.")) (|coordinate| ((|#1| $ (|NonNegativeInteger|)) "\\spad{coordinate(c,i)} returns a coordinate function for \\spad{c} using 1-based indexing according to i. This indicates what the function for the coordinate component \\spad{i} of the plane curve is.")) (|curve| (($ |#1| |#1|) "\\spad{curve(c1,c2)} creates a plane curve from 2 component functions \\spad{c1} and \\spad{c2}."))) 
NIL 
NIL 
(|ParametricSpaceCurveFunctions2| CF1 CF2) 
((|constructor| (NIL "This package has no description")) (|map| (((|ParametricSpaceCurve| |#2|) (|Mapping| |#2| |#1|) (|ParametricSpaceCurve| |#1|)) "\\spad{map(f,x)} \\undocumented"))) 
NIL 
NIL 
(|ParametricSpaceCurve| |ComponentFunction|) 
((|constructor| (NIL "ParametricSpaceCurve is used for plotting parametric space curves in affine 3-space.")) (|coordinate| ((|#1| $ (|NonNegativeInteger|)) "\\spad{coordinate(c,i)} returns a coordinate function of \\spad{c} using 1-based indexing according to i. This indicates what the function for the coordinate component, i, of the space curve is.")) (|curve| (($ |#1| |#1| |#1|) "\\spad{curve(c1,c2,c3)} creates a space curve from 3 component functions \\spad{c1}, \\spad{c2}, and \\spad{c3}."))) 
NIL 
NIL 
(|ParametricSurfaceFunctions2| CF1 CF2) 
((|constructor| (NIL "This package has no description")) (|map| (((|ParametricSurface| |#2|) (|Mapping| |#2| |#1|) (|ParametricSurface| |#1|)) "\\spad{map(f,x)} \\undocumented"))) 
NIL 
NIL 
(|ParametricSurface| |ComponentFunction|) 
((|constructor| (NIL "ParametricSurface is used for plotting parametric surfaces in affine 3-space.")) (|coordinate| ((|#1| $ (|NonNegativeInteger|)) "\\spad{coordinate(s,i)} returns a coordinate function of \\spad{s} using 1-based indexing according to i. This indicates what the function for the coordinate component, i, of the surface is.")) (|surface| (($ |#1| |#1| |#1|) "\\spad{surface(c1,c2,c3)} creates a surface from 3 parametric component functions \\spad{c1}, \\spad{c2}, and \\spad{c3}."))) 
NIL 
NIL 
(|PartitionsAndPermutations|) 
((|constructor| (NIL "PartitionsAndPermutations contains functions for generating streams of integer partitions, and streams of sequences of integers composed from a multi-set.")) (|permutations| (((|Stream| (|List| (|Integer|))) (|Integer|)) "\\spad{permutations(n)} is the stream of permutations \\indented{1}{formed from \\spad{1,2,3,...,n}.}")) (|sequences| (((|Stream| (|List| (|Integer|))) (|List| (|Integer|))) "\\spad{sequences([l0,l1,l2,..,ln])} is the set of \\indented{1}{all sequences formed from} \\spad{l0} 0's,\\spad{l1} 1's,\\spad{l2} 2's,...,\\spad{ln} n's.") (((|Stream| (|List| (|Integer|))) (|List| (|Integer|)) (|List| (|Integer|))) "\\spad{sequences(l1,l2)} is the stream of all sequences that \\indented{1}{can be composed from the multiset defined from} \\indented{1}{two lists of integers \\spad{l1} and l2.} \\indented{1}{For example,the pair \\spad{([1,2,4],[2,3,5])} represents} \\indented{1}{multi-set with 1 \\spad{2}, 2 \\spad{3}'s, and 4 \\spad{5}'s.}")) (|shufflein| (((|Stream| (|List| (|Integer|))) (|List| (|Integer|)) (|Stream| (|List| (|Integer|)))) "\\spad{shufflein(l,st)} maps shuffle(l,u) on to all \\indented{1}{members \\spad{u} of \\spad{st,} concatenating the results.}")) (|shuffle| (((|Stream| (|List| (|Integer|))) (|List| (|Integer|)) (|List| (|Integer|))) "\\spad{shuffle(l1,l2)} forms the stream of all shuffles of \\spad{l1} \\indented{1}{and \\spad{l2,} \\spadignore{i.e.} all sequences that can be formed from} \\indented{1}{merging \\spad{l1} and l2.}")) (|conjugates| (((|Stream| (|List| (|Integer|))) (|Stream| (|List| (|Integer|)))) "\\spad{conjugates(lp)} is the stream of conjugates of a stream \\indented{1}{of partitions lp.}")) (|conjugate| (((|List| (|Integer|)) (|List| (|Integer|))) "\\spad{conjugate(pt)} is the conjugate of the partition \\spad{pt.}")) (|partitions| (((|Stream| (|List| (|Integer|))) (|Integer|) (|Integer|)) "\\spad{partitions(p,l)} is the stream of all \\indented{1}{partitions whose number of} \\indented{1}{parts and largest part are no greater than \\spad{p} and \\spad{l.}}") (((|Stream| (|List| (|Integer|))) (|Integer|)) "\\spad{partitions(n)} is the stream of all partitions of \\spad{n.}") (((|Stream| (|List| (|Integer|))) (|Integer|) (|Integer|) (|Integer|)) "\\spad{partitions(p,l,n)} is the stream of partitions \\indented{1}{of \\spad{n} whose number of parts is no greater than \\spad{p}} \\indented{1}{and whose largest part is no greater than \\spad{l.}}"))) 
NIL 
NIL 
(|Patternable| R) 
((|constructor| (NIL "Category of sets that can be converted to useful patterns An object \\spad{S} is Patternable over an object \\spad{R} if \\spad{S} can lift the conversions from \\spad{R} into \\spadtype{Pattern(Integer)} and \\spadtype{Pattern(Float)} to itself."))) 
NIL 
NIL 
(|PatternMatchListResult| R S L) 
((|constructor| (NIL "A PatternMatchListResult is an object internally returned by the pattern matcher when matching on lists. It is either a failed match, or a pair of PatternMatchResult, one for atoms (elements of the list), and one for lists.")) (|lists| (((|PatternMatchResult| |#1| |#3|) $) "\\spad{lists(r)} returns the list of matches that match lists.")) (|atoms| (((|PatternMatchResult| |#1| |#2|) $) "\\spad{atoms(r)} returns the list of matches that match atoms (elements of the lists).")) (|makeResult| (($ (|PatternMatchResult| |#1| |#2|) (|PatternMatchResult| |#1| |#3|)) "\\spad{makeResult(r1,r2)} makes the combined result [r1,r2].")) (|new| (($) "\\spad{new()} returns a new empty match result.")) (|failed| (($) "\\spad{failed()} returns a failed match.")) (|failed?| (((|Boolean|) $) "\\spad{failed?(r)} tests if \\spad{r} is a failed match."))) 
NIL 
NIL 
(|PatternMatchable| S) 
((|constructor| (NIL "A set \\spad{R} is PatternMatchable over \\spad{S} if elements of \\spad{R} can be matched to patterns over \\spad{S.}")) (|patternMatch| (((|PatternMatchResult| |#1| $) $ (|Pattern| |#1|) (|PatternMatchResult| |#1| $)) "\\spad{patternMatch(expr, pat, res)} matches the pattern \\spad{pat} to the expression expr. res contains the variables of \\spad{pat} which are already matched and their matches (necessary for recursion). Initially, res is just the result of \\spadfun{new} which is an empty list of matches."))) 
NIL 
NIL 
(|PatternMatch| |Base| |Subject| |Pat|) 
((|constructor| (NIL "This package provides the top-level pattern macthing functions.")) (|Is| (((|PatternMatchResult| |#1| |#2|) |#2| |#3|) "\\spad{Is(expr, pat)} matches the pattern pat on the expression \\spad{expr} and returns a match of the form \\spad{[v1 = e1,...,vn = en]}; returns an empty match if \\spad{expr} is exactly equal to pat. returns a \\spadfun{failed} match if pat does not match expr.") (((|List| (|Equation| (|Polynomial| |#2|))) |#2| |#3|) "\\spad{Is(expr, pat)} matches the pattern pat on the expression \\spad{expr} and returns a list of matches \\spad{[v1 = e1,...,vn = en]}; returns an empty list if either \\spad{expr} is exactly equal to pat or if pat does not match expr.") (((|List| (|Equation| |#2|)) |#2| |#3|) "\\spad{Is(expr, pat)} matches the pattern pat on the expression \\spad{expr} and returns a list of matches \\spad{[v1 = e1,...,vn = en]}; returns an empty list if either \\spad{expr} is exactly equal to pat or if pat does not match expr.") (((|PatternMatchListResult| |#1| |#2| (|List| |#2|)) (|List| |#2|) |#3|) "\\spad{Is([e1,...,en], pat)} matches the pattern pat on the list of expressions \\spad{[e1,...,en]} and returns the result.")) (|is?| (((|Boolean|) (|List| |#2|) |#3|) "\\spad{is?([e1,...,en], pat)} tests if the list of expressions \\spad{[e1,...,en]} matches the pattern pat.") (((|Boolean|) |#2| |#3|) "\\spad{is?(expr, pat)} tests if the expression \\spad{expr} matches the pattern pat."))) 
NIL 
((|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (AND (|not| (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|))))) (|not| (|HasCategory| |#2| (QUOTE (|Ring|))))) (AND (|HasCategory| |#2| (QUOTE (|Ring|))) (|not| (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|))))))) 
(|PatternMatchResultFunctions2| R A B) 
((|constructor| (NIL "Lifts maps to pattern matching results.")) (|map| (((|PatternMatchResult| |#1| |#3|) (|Mapping| |#3| |#2|) (|PatternMatchResult| |#1| |#2|)) "\\spad{map(f, [(v1,a1),...,(vn,an)])} returns the matching result [(v1,f(a1)),...,(vn,f(an))]."))) 
NIL 
NIL 
(|PatternMatchResult| R S) 
((|constructor| (NIL "A PatternMatchResult is an object internally returned by the pattern matcher; It is either a failed match, or a list of matches of the form (var, expr) meaning that the variable var matches the expression expr.")) (|satisfy?| (((|Union| (|Boolean|) "failed") $ (|Pattern| |#1|)) "\\spad{satisfy?(r, \\spad{p)}} returns \\spad{true} if the matches satisfy the top-level predicate of \\spad{p,} \\spad{false} if they don't, and \"failed\" if not enough variables of \\spad{p} are matched in \\spad{r} to decide.")) (|construct| (($ (|List| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| |#2|)))) "\\spad{construct([v1,e1],...,[vn,en])} returns the match result containing the matches (v1,e1),...,(vn,en).")) (|destruct| (((|List| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| |#2|))) $) "\\spad{destruct(r)} returns the list of matches (var, expr) in \\spad{r.} Error: if \\spad{r} is a failed match.")) (|addMatchRestricted| (($ (|Pattern| |#1|) |#2| $ |#2|) "\\spad{addMatchRestricted(var, expr, \\spad{r,} val)} adds the match (var, expr) in \\spad{r,} provided that \\spad{expr} satisfies the predicates attached to var, that \\spad{var} is not matched to another expression already, and that either \\spad{var} is an optional pattern variable or that \\spad{expr} is not equal to val (usually an identity).")) (|insertMatch| (($ (|Pattern| |#1|) |#2| $) "\\spad{insertMatch(var, expr, \\spad{r)}} adds the match (var, expr) in \\spad{r,} without checking predicates or previous matches for var.")) (|addMatch| (($ (|Pattern| |#1|) |#2| $) "\\spad{addMatch(var, expr, \\spad{r)}} adds the match (var, expr) in \\spad{r,} provided that \\spad{expr} satisfies the predicates attached to var, and that \\spad{var} is not matched to another expression already.")) (|getMatch| (((|Union| |#2| "failed") (|Pattern| |#1|) $) "\\spad{getMatch(var, \\spad{r)}} returns the expression that \\spad{var} matches in the result \\spad{r,} and \"failed\" if \\spad{var} is not matched in \\spad{r.}")) (|union| (($ $ $) "\\spad{union(a, \\spad{b)}} makes the set-union of two match results.")) (|new| (($) "\\spad{new()} returns a new empty match result.")) (|failed| (($) "\\spad{failed()} returns a failed match.")) (|failed?| (((|Boolean|) $) "\\spad{failed?(r)} tests if \\spad{r} is a failed match."))) 
NIL 
NIL 
(|PatternFunctions1| R D) 
((|constructor| (NIL "Utilities for handling patterns")) (|badValues| (((|List| |#2|) (|Pattern| |#1|)) "\\spad{badValues(p)} returns the list of \"bad values\" for \\spad{p;} \\spad{p} is not allowed to match any of its \"bad values\".")) (|addBadValue| (((|Pattern| |#1|) (|Pattern| |#1|) |#2|) "\\spad{addBadValue(p, \\spad{v)}} adds \\spad{v} to the list of \"bad values\" for \\spad{p;} \\spad{p} is not allowed to match any of its \"bad values\".")) (|satisfy?| (((|Boolean|) (|List| |#2|) (|Pattern| |#1|)) "\\spad{satisfy?([v1,...,vn], \\spad{p)}} returns \\spad{f(v1,...,vn)} where \\spad{f} is the top-level predicate attached to \\spad{p.}") (((|Boolean|) |#2| (|Pattern| |#1|)) "\\spad{satisfy?(v, \\spad{p)}} returns f(v) where \\spad{f} is the predicate attached to \\spad{p.}")) (|predicate| (((|Mapping| (|Boolean|) |#2|) (|Pattern| |#1|)) "\\spad{predicate(p)} returns the predicate attached to \\spad{p,} the constant function \\spad{true} if \\spad{p} has no predicates attached to it.")) (|suchThat| (((|Pattern| |#1|) (|Pattern| |#1|) (|List| (|Symbol|)) (|Mapping| (|Boolean|) (|List| |#2|))) "\\spad{suchThat(p, [a1,...,an], \\spad{f)}} returns a copy of \\spad{p} with the top-level predicate set to \\spad{f(a1,...,an)}.") (((|Pattern| |#1|) (|Pattern| |#1|) (|List| (|Mapping| (|Boolean|) |#2|))) "\\spad{suchThat(p, [f1,...,fn])} makes a copy of \\spad{p} and adds the predicate \\spad{f1} and \\spad{...} and \\spad{fn} to the copy, which is returned.") (((|Pattern| |#1|) (|Pattern| |#1|) (|Mapping| (|Boolean|) |#2|)) "\\spad{suchThat(p, \\spad{f)}} makes a copy of \\spad{p} and adds the predicate \\spad{f} to the copy, which is returned."))) 
NIL 
NIL 
(|PatternFunctions2| R S) 
((|constructor| (NIL "Lifts maps to patterns")) (|map| (((|Pattern| |#2|) (|Mapping| |#2| |#1|) (|Pattern| |#1|)) "\\spad{map(f, \\spad{p)}} applies \\spad{f} to all the leaves of \\spad{p} and returns the result as a pattern over \\spad{S.}"))) 
NIL 
NIL 
(|Pattern| R) 
((|constructor| (NIL "Patterns for use by the pattern matcher.")) (|optpair| (((|Union| (|List| $) "failed") (|List| $)) "\\spad{optpair(l)} returns \\spad{l} has the form \\spad{[a, \\spad{b]}} and a is optional, and \"failed\" otherwise.")) (|variables| (((|List| $) $) "\\spad{variables(p)} returns the list of matching variables appearing in \\spad{p.}")) (|getBadValues| (((|List| (|Any|)) $) "\\spad{getBadValues(p)} returns the list of \"bad values\" for \\spad{p.} Note: \\spad{p} is not allowed to match any of its \"bad values\".")) (|addBadValue| (($ $ (|Any|)) "\\spad{addBadValue(p, \\spad{v)}} adds \\spad{v} to the list of \"bad values\" for \\spad{p.} Note: \\spad{p} is not allowed to match any of its \"bad values\".")) (|resetBadValues| (($ $) "\\spad{resetBadValues(p)} initializes the list of \"bad values\" for \\spad{p} to \\spad{[]}. Note: \\spad{p} is not allowed to match any of its \"bad values\".")) (|hasTopPredicate?| (((|Boolean|) $) "\\spad{hasTopPredicate?(p)} tests if \\spad{p} has a top-level predicate.")) (|topPredicate| (((|Record| (|:| |var| (|List| (|Symbol|))) (|:| |pred| (|Any|))) $) "\\spad{topPredicate(x)} returns \\spad{[[a1,...,an], \\spad{f]}} where the top-level predicate of \\spad{x} is \\spad{f(a1,...,an)}. Note: \\spad{n} is 0 if \\spad{x} has no top-level predicate.")) (|setTopPredicate| (($ $ (|List| (|Symbol|)) (|Any|)) "\\spad{setTopPredicate(x, [a1,...,an], \\spad{f)}} returns \\spad{x} with the top-level predicate set to \\spad{f(a1,...,an)}.")) (|patternVariable| (($ (|Symbol|) (|Boolean|) (|Boolean|) (|Boolean|)) "\\spad{patternVariable(x, \\spad{c?,} o?, m?)} creates a pattern variable \\spad{x,} which is constant if \\spad{c? = true}, optional if \\spad{o? = true}, and multiple if \\spad{m? = true}.")) (|withPredicates| (($ $ (|List| (|Any|))) "\\spad{withPredicates(p, [p1,...,pn])} makes a copy of \\spad{p} and attaches the predicate \\spad{p1} and \\spad{...} and \\spad{pn} to the copy, which is returned.")) (|setPredicates| (($ $ (|List| (|Any|))) "\\spad{setPredicates(p, [p1,...,pn])} attaches the predicate \\spad{p1} and \\spad{...} and \\spad{pn} to \\spad{p.}")) (|predicates| (((|List| (|Any|)) $) "\\spad{predicates(p)} returns \\spad{[p1,...,pn]} such that the predicate attached to \\spad{p} is \\spad{p1} and \\spad{...} and \\spad{pn.}")) (|hasPredicate?| (((|Boolean|) $) "\\spad{hasPredicate?(p)} tests if \\spad{p} has predicates attached to it.")) (|optional?| (((|Boolean|) $) "\\spad{optional?(p)} tests if \\spad{p} is a single matching variable which can match an identity.")) (|multiple?| (((|Boolean|) $) "\\spad{multiple?(p)} tests if \\spad{p} is a single matching variable allowing list matching or multiple term matching in a sum or product.")) (|generic?| (((|Boolean|) $) "\\spad{generic?(p)} tests if \\spad{p} is a single matching variable.")) (|constant?| (((|Boolean|) $) "\\spad{constant?(p)} tests if \\spad{p} contains no matching variables.")) (|symbol?| (((|Boolean|) $) "\\spad{symbol?(p)} tests if \\spad{p} is a symbol.")) (|quoted?| (((|Boolean|) $) "\\spad{quoted?(p)} tests if \\spad{p} is of the form \\spad{'s} for a symbol \\spad{s.}")) (|inR?| (((|Boolean|) $) "\\spad{inR?(p)} tests if \\spad{p} is an atom (\\spadignore{i.e.} an element of \\spad{R).}")) (|copy| (($ $) "\\spad{copy(p)} returns a recursive copy of \\spad{p.}")) (|convert| (($ (|List| $)) "\\spad{convert([a1,...,an])} returns the pattern \\spad{[a1,...,an]}.")) (|depth| (((|NonNegativeInteger|) $) "\\spad{depth(p)} returns the nesting level of \\spad{p.}")) (/ (($ $ $) "\\spad{a / \\spad{b}} returns the pattern \\spad{a / \\spad{b}.}")) (** (($ $ $) "\\spad{a \\spad{**} \\spad{b}} returns the pattern \\spad{a \\spad{**} \\spad{b}.}") (($ $ (|NonNegativeInteger|)) "\\spad{a \\spad{**} \\spad{n}} returns the pattern \\spad{a \\spad{**} \\spad{n}.}")) (* (($ $ $) "\\spad{a * \\spad{b}} returns the pattern \\spad{a * \\spad{b}.}")) (+ (($ $ $) "\\spad{a + \\spad{b}} returns the pattern \\spad{a + \\spad{b}.}")) (|elt| (($ (|BasicOperator|) (|List| $)) "\\spad{elt(op, [a1,...,an])} returns \\spad{op(a1,...,an)}.")) (|isPower| (((|Union| (|Record| (|:| |val| $) (|:| |exponent| $)) "failed") $) "\\spad{isPower(p)} returns \\spad{[a, \\spad{b]}} if \\spad{p = a \\spad{**} \\spad{b},} and \"failed\" otherwise.")) (|isList| (((|Union| (|List| $) "failed") $) "\\spad{isList(p)} returns \\spad{[a1,...,an]} if \\spad{p = [a1,...,an]}, \"failed\" otherwise.")) (|isQuotient| (((|Union| (|Record| (|:| |num| $) (|:| |den| $)) "failed") $) "\\spad{isQuotient(p)} returns \\spad{[a, \\spad{b]}} if \\spad{p = a / \\spad{b},} and \"failed\" otherwise.")) (|isExpt| (((|Union| (|Record| (|:| |val| $) (|:| |exponent| (|NonNegativeInteger|))) "failed") $) "\\spad{isExpt(p)} returns \\spad{[q, \\spad{n]}} if \\spad{n > 0} and \\spad{p = \\spad{q} \\spad{**} \\spad{n},} and \"failed\" otherwise.")) (|isOp| (((|Union| (|Record| (|:| |op| (|BasicOperator|)) (|:| |arg| (|List| $))) "failed") $) "\\spad{isOp(p)} returns \\spad{[op, [a1,...,an]]} if \\spad{p = op(a1,...,an)}, and \"failed\" otherwise.") (((|Union| (|List| $) "failed") $ (|BasicOperator|)) "\\spad{isOp(p, op)} returns \\spad{[a1,...,an]} if \\spad{p = op(a1,...,an)}, and \"failed\" otherwise.")) (|isTimes| (((|Union| (|List| $) "failed") $) "\\spad{isTimes(p)} returns \\spad{[a1,...,an]} if \\spad{n > 1} and \\spad{p = \\spad{a1} * \\spad{...} * an}, and \"failed\" otherwise.")) (|isPlus| (((|Union| (|List| $) "failed") $) "\\spad{isPlus(p)} returns \\spad{[a1,...,an]} if \\spad{n > 1} \\indented{1}{and \\spad{p = \\spad{a1} + \\spad{...} + an},} and \"failed\" otherwise.")) ((|One|) (($) "1")) ((|Zero|) (($) "0"))) 
NIL 
NIL 
(|PoincareBirkhoffWittLyndonBasis| |VarSet|) 
((|constructor| (NIL "This domain provides the internal representation of polynomials in non-commutative variables written over the Poincare-Birkhoff-Witt basis. See the \\spadtype{XPBWPolynomial} domain constructor. See Free Lie Algebras by \\spad{C.} Reutenauer (Oxford science publications).")) (|varList| (((|List| |#1|) $) "\\spad{varList([l1]*[l2]*...[ln])} returns the list of variables in the word \\spad{l1*l2*...*ln}.")) (|retractable?| (((|Boolean|) $) "\\spad{retractable?([l1]*[l2]*...[ln])} returns \\spad{true} iff \\spad{n} equals \\spad{1}.")) (|rest| (($ $) "\\spad{rest([l1]*[l2]*...[ln])} returns the list \\spad{l2, .... ln}.")) (|listOfTerms| (((|List| (|LyndonWord| |#1|)) $) "\\spad{listOfTerms([l1]*[l2]*...[ln])} returns the list of words \\spad{l1, \\spad{l2,} .... ln}.")) (|length| (((|NonNegativeInteger|) $) "\\spad{length([l1]*[l2]*...[ln])} returns the length of the word \\spad{l1*l2*...*ln}.")) (|first| (((|LyndonWord| |#1|) $) "\\spad{first([l1]*[l2]*...[ln])} returns the Lyndon word \\spad{l1}.")) (|coerce| (($ |#1|) "\\spad{coerce(v)} return \\spad{v}") (((|OrderedFreeMonoid| |#1|) $) "\\spad{coerce([l1]*[l2]*...[ln])} returns the word \\spad{l1*l2*...*ln}, where \\spad{[l_i]} is the backeted form of the Lyndon word \\spad{l_i}.")) ((|One|) (($) "\\spad{1} returns the empty list."))) 
NIL 
NIL 
(|PolynomialComposition| UP R) 
((|constructor| (NIL "Polynomial composition and decomposition functions\\br If \\spad{f} = \\spad{g} \\spad{o} \\spad{h} then g=leftFactor(f,h) and h=rightFactor(f,g)")) (|compose| ((|#1| |#1| |#1|) "\\spad{compose(p,q)} \\undocumented"))) 
NIL 
NIL 
(|PartialDifferentialEquationsSolverCategory|) 
((|constructor| (NIL "\\axiomType{PartialDifferentialEquationsSolverCategory} is the \\axiom{category} for describing the set of PDE solver \\axiom{domains} with \\axiomFun{measure} and \\axiomFun{PDEsolve}.")) (|PDESolve| (((|Result|) (|Record| (|:| |pde| (|List| (|Expression| (|DoubleFloat|)))) (|:| |constraints| (|List| (|Record| (|:| |start| (|DoubleFloat|)) (|:| |finish| (|DoubleFloat|)) (|:| |grid| (|NonNegativeInteger|)) (|:| |boundaryType| (|Integer|)) (|:| |dStart| (|Matrix| (|DoubleFloat|))) (|:| |dFinish| (|Matrix| (|DoubleFloat|)))))) (|:| |f| (|List| (|List| (|Expression| (|DoubleFloat|))))) (|:| |st| (|String|)) (|:| |tol| (|DoubleFloat|)))) "\\spad{PDESolve(args)} performs the integration of the function given the strategy or method returned by \\axiomFun{measure}.")) (|measure| (((|Record| (|:| |measure| (|Float|)) (|:| |explanations| (|String|))) (|RoutinesTable|) (|Record| (|:| |pde| (|List| (|Expression| (|DoubleFloat|)))) (|:| |constraints| (|List| (|Record| (|:| |start| (|DoubleFloat|)) (|:| |finish| (|DoubleFloat|)) (|:| |grid| (|NonNegativeInteger|)) (|:| |boundaryType| (|Integer|)) (|:| |dStart| (|Matrix| (|DoubleFloat|))) (|:| |dFinish| (|Matrix| (|DoubleFloat|)))))) (|:| |f| (|List| (|List| (|Expression| (|DoubleFloat|))))) (|:| |st| (|String|)) (|:| |tol| (|DoubleFloat|)))) "\\spad{measure(R,args)} calculates an estimate of the ability of a particular method to solve a problem. \\blankline This method may be either a specific NAG routine or a strategy (such as transforming the function from one which is difficult to one which is easier to solve). \\blankline It will call whichever agents are needed to perform analysis on the problem in order to calculate the measure. There is a parameter, labelled \\axiom{sofar}, which would contain the best compatibility found so far."))) 
NIL 
NIL 
(|PolynomialDecomposition| UP F) 
((|constructor| (NIL "Polynomial composition and decomposition functions\\br If \\spad{f} = \\spad{g} \\spad{o} \\spad{h} then g=leftFactor(f,h) and h=rightFactor(f,g)")) (|rightFactorCandidate| ((|#1| |#1| (|NonNegativeInteger|)) "\\spad{rightFactorCandidate(p,n)} \\undocumented")) (|leftFactor| (((|Union| |#1| "failed") |#1| |#1|) "\\spad{leftFactor(p,q)} \\undocumented")) (|decompose| (((|Union| (|Record| (|:| |left| |#1|) (|:| |right| |#1|)) "failed") |#1| (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{decompose(up,m,n)} \\undocumented") (((|List| |#1|) |#1|) "\\spad{decompose(up)} \\undocumented"))) 
NIL 
NIL 
(|AnnaPartialDifferentialEquationPackage|) 
((|constructor| (NIL "AnnaPartialDifferentialEquationPackage is an uncompleted package for the interface to NAG PDE routines. It has been realised that a new approach to solving PDEs will need to be created.")) (|measure| (((|Record| (|:| |measure| (|Float|)) (|:| |name| (|String|)) (|:| |explanations| (|List| (|String|)))) (|NumericalPDEProblem|) (|RoutinesTable|)) "\\spad{measure(prob,R)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical PDE problem defined by \\axiom{prob}. \\blankline It calls each \\axiom{domain} listed in \\axiom{R} of \\axiom{category} \\axiomType{PartialDifferentialEquationsSolverCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information. It predicts the likely most effective NAG numerical Library routine to solve the input set of PDEs by checking various attributes of the system of PDEs and calculating a measure of compatibility of each routine to these attributes.") (((|Record| (|:| |measure| (|Float|)) (|:| |name| (|String|)) (|:| |explanations| (|List| (|String|)))) (|NumericalPDEProblem|)) "\\spad{measure(prob)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical PDE problem defined by \\axiom{prob}. \\blankline It calls each \\axiom{domain} of \\axiom{category} \\axiomType{PartialDifferentialEquationsSolverCategory} in turn to calculate all measures and returns the best \\spadignore{i.e.} the name of the most appropriate domain and any other relevant information. It predicts the likely most effective NAG numerical Library routine to solve the input set of PDEs by checking various attributes of the system of PDEs and calculating a measure of compatibility of each routine to these attributes.")) (|solve| (((|Result|) (|Float|) (|Float|) (|Float|) (|Float|) (|NonNegativeInteger|) (|NonNegativeInteger|) (|List| (|Expression| (|Float|))) (|List| (|List| (|Expression| (|Float|)))) (|String|)) "\\spad{solve(xmin,ymin,xmax,ymax,ngx,ngy,pde,bounds,st)} is a top level ANNA function to solve numerically a system of partial differential equations. This is defined as a list of coefficients (\\axiom{pde}), a grid (\\axiom{xmin}, \\axiom{ymin}, \\axiom{xmax}, \\axiom{ymax}, \\axiom{ngx}, \\axiom{ngy}) and the boundary values (\\axiom{bounds}). A default value for tolerance is used. There is also a parameter (\\axiom{st}) which should contain the value \"elliptic\" if the PDE is known to be elliptic, or \"unknown\" if it is uncertain. This causes the routine to check whether the PDE is elliptic. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of PDE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine. \\blankline \\spad{**} At the moment, only Second Order Elliptic Partial Differential Equations are solved \\spad{**}") (((|Result|) (|Float|) (|Float|) (|Float|) (|Float|) (|NonNegativeInteger|) (|NonNegativeInteger|) (|List| (|Expression| (|Float|))) (|List| (|List| (|Expression| (|Float|)))) (|String|) (|DoubleFloat|)) "\\spad{solve(xmin,ymin,xmax,ymax,ngx,ngy,pde,bounds,st,tol)} is a top level ANNA function to solve numerically a system of partial differential equations. This is defined as a list of coefficients (\\axiom{pde}), a grid (\\axiom{xmin}, \\axiom{ymin}, \\axiom{xmax}, \\axiom{ymax}, \\axiom{ngx}, \\axiom{ngy}), the boundary values (\\axiom{bounds}) and a tolerance requirement (\\axiom{tol}). There is also a parameter (\\axiom{st}) which should contain the value \"elliptic\" if the PDE is known to be elliptic, or \"unknown\" if it is uncertain. This causes the routine to check whether the PDE is elliptic. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of PDE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine. \\blankline \\spad{**} At the moment, only Second Order Elliptic Partial Differential Equations are solved \\spad{**}") (((|Result|) (|NumericalPDEProblem|) (|RoutinesTable|)) "\\spad{solve(PDEProblem,routines)} is a top level ANNA function to solve numerically a system of partial differential equations. \\blankline The method used to perform the numerical process will be one of the \\spad{routines} contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of PDE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine. \\blankline \\spad{**} At the moment, only Second Order Elliptic Partial Differential Equations are solved \\spad{**}") (((|Result|) (|NumericalPDEProblem|)) "\\spad{solve(PDEProblem)} is a top level ANNA function to solve numerically a system of partial differential equations. \\blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of PDE's and calculating a measure of compatibility of each routine to these attributes. \\blankline It then calls the resulting `best' routine. \\blankline \\spad{**} At the moment, only Second Order Elliptic Partial Differential Equations are solved \\spad{**}"))) 
NIL 
NIL 
(|NumericalPDEProblem|) 
((|constructor| (NIL "\\axiomType{NumericalPDEProblem} is a \\axiom{domain} for the representation of Numerical PDE problems for use by ANNA. \\blankline The representation is of type: \\blankline \\axiomType{Record}(pde:\\axiomType{List Expression DoubleFloat}, \\spad{\\br} constraints:\\axiomType{List PDEC}, \\spad{\\br} f:\\axiomType{List List Expression DoubleFloat},\\br st:\\axiomType{String},\\br tol:\\axiomType{DoubleFloat}) \\blankline where \\axiomType{PDEC} is of type: \\blankline \\axiomType{Record}(start:\\axiomType{DoubleFloat}, \\spad{\\br} finish:\\axiomType{DoubleFloat},\\br grid:\\axiomType{NonNegativeInteger},\\br boundaryType:\\axiomType{Integer},\\br dStart:\\axiomType{Matrix DoubleFloat}, \\spad{\\br} dFinish:\\axiomType{Matrix DoubleFloat})")) (|retract| (((|Record| (|:| |pde| (|List| (|Expression| (|DoubleFloat|)))) (|:| |constraints| (|List| (|Record| (|:| |start| (|DoubleFloat|)) (|:| |finish| (|DoubleFloat|)) (|:| |grid| (|NonNegativeInteger|)) (|:| |boundaryType| (|Integer|)) (|:| |dStart| (|Matrix| (|DoubleFloat|))) (|:| |dFinish| (|Matrix| (|DoubleFloat|)))))) (|:| |f| (|List| (|List| (|Expression| (|DoubleFloat|))))) (|:| |st| (|String|)) (|:| |tol| (|DoubleFloat|))) $) "\\spad{retract(x)} is not documented")) (|coerce| (((|OutputForm|) $) "\\spad{coerce(x)} is not documented") (($ (|Record| (|:| |pde| (|List| (|Expression| (|DoubleFloat|)))) (|:| |constraints| (|List| (|Record| (|:| |start| (|DoubleFloat|)) (|:| |finish| (|DoubleFloat|)) (|:| |grid| (|NonNegativeInteger|)) (|:| |boundaryType| (|Integer|)) (|:| |dStart| (|Matrix| (|DoubleFloat|))) (|:| |dFinish| (|Matrix| (|DoubleFloat|)))))) (|:| |f| (|List| (|List| (|Expression| (|DoubleFloat|))))) (|:| |st| (|String|)) (|:| |tol| (|DoubleFloat|)))) "\\spad{coerce(x)} is not documented"))) 
NIL 
NIL 
(|PartialDifferentialRing&| A S) 
((|constructor| (NIL "A partial differential ring with differentiations indexed by a parameter type \\spad{S.} \\blankline Axioms\\br \\tab{5}\\spad{differentiate(x+y,e)=differentiate(x,e)+differentiate(y,e)}\\br \\tab{5}\\spad{differentiate(x*y,e)=x*differentiate(y,e)+differentiate(x,e)*y}")) (D (($ $ (|List| |#2|) (|List| (|NonNegativeInteger|))) "\\spad{D(x, [s1,...,sn], [n1,...,nn])} computes multiple partial derivatives, that is, \\spad{D(...D(x, \\spad{s1,} n1)..., \\spad{sn,} nn)}.") (($ $ |#2| (|NonNegativeInteger|)) "\\spad{D(x, \\spad{s,} \\spad{n)}} computes multiple partial derivatives, that is, \\spad{n}-th derivative of \\spad{x} with respect to \\spad{s.}") (($ $ (|List| |#2|)) "\\spad{D(x,[s1,...sn])} computes successive partial derivatives, that is, \\spad{D(...D(x, s1)..., sn)}.") (($ $ |#2|) "\\spad{D(x,v)} computes the partial derivative of \\spad{x} with respect to \\spad{v.}")) (|differentiate| (($ $ (|List| |#2|) (|List| (|NonNegativeInteger|))) "\\spad{differentiate(x, [s1,...,sn], [n1,...,nn])} computes multiple partial derivatives, that is, \\spad{D(...D(x, s1)..., sn)}.") (($ $ |#2| (|NonNegativeInteger|)) "\\spad{differentiate(x, \\spad{s,} \\spad{n)}} computes multiple partial derivatives, that is, \\spad{n}-th derivative of \\spad{x} with respect to \\spad{s.}") (($ $ (|List| |#2|)) "\\spad{differentiate(x,[s1,...sn])} computes successive partial derivatives, that is, \\spad{differentiate(...differentiate(x, s1)..., sn)}.") (($ $ |#2|) "\\spad{differentiate(x,v)} computes the partial derivative of \\spad{x} with respect to \\spad{v.}"))) 
NIL 
NIL 
(|PartialDifferentialRing| S) 
((|constructor| (NIL "A partial differential ring with differentiations indexed by a parameter type \\spad{S.} \\blankline Axioms\\br \\tab{5}\\spad{differentiate(x+y,e)=differentiate(x,e)+differentiate(y,e)}\\br \\tab{5}\\spad{differentiate(x*y,e)=x*differentiate(y,e)+differentiate(x,e)*y}")) (D (($ $ (|List| |#1|) (|List| (|NonNegativeInteger|))) "\\spad{D(x, [s1,...,sn], [n1,...,nn])} computes multiple partial derivatives, that is, \\spad{D(...D(x, \\spad{s1,} n1)..., \\spad{sn,} nn)}.") (($ $ |#1| (|NonNegativeInteger|)) "\\spad{D(x, \\spad{s,} \\spad{n)}} computes multiple partial derivatives, that is, \\spad{n}-th derivative of \\spad{x} with respect to \\spad{s.}") (($ $ (|List| |#1|)) "\\spad{D(x,[s1,...sn])} computes successive partial derivatives, that is, \\spad{D(...D(x, s1)..., sn)}.") (($ $ |#1|) "\\spad{D(x,v)} computes the partial derivative of \\spad{x} with respect to \\spad{v.}")) (|differentiate| (($ $ (|List| |#1|) (|List| (|NonNegativeInteger|))) "\\spad{differentiate(x, [s1,...,sn], [n1,...,nn])} computes multiple partial derivatives, that is, \\spad{D(...D(x, s1)..., sn)}.") (($ $ |#1| (|NonNegativeInteger|)) "\\spad{differentiate(x, \\spad{s,} \\spad{n)}} computes multiple partial derivatives, that is, \\spad{n}-th derivative of \\spad{x} with respect to \\spad{s.}") (($ $ (|List| |#1|)) "\\spad{differentiate(x,[s1,...sn])} computes successive partial derivatives, that is, \\spad{differentiate(...differentiate(x, s1)..., sn)}.") (($ $ |#1|) "\\spad{differentiate(x,v)} computes the partial derivative of \\spad{x} with respect to \\spad{v.}"))) 
((|unitsKnown| . T)) 
NIL 
(|PendantTree| S) 
((|constructor| (NIL "A PendantTree(S) is either a leaf? and is an \\spad{S} or has a left and a right both PendantTree(S)'s")) (|coerce| (((|Tree| |#1|) $) "\\indented{1}{coerce(x) is not documented} \\blankline \\spad{X} t1:=ptree([1,2,3]) \\spad{X} t2:=ptree(t1,ptree([1,2,3])) \\spad{X} t2::Tree List PositiveInteger")) (|ptree| (($ $ $) "\\indented{1}{ptree(x,y) is not documented} \\blankline \\spad{X} t1:=ptree([1,2,3]) \\spad{X} ptree(t1,ptree([1,2,3]))") (($ |#1|) "\\indented{1}{ptree(s) is a leaf? pendant tree} \\blankline \\spad{X} t1:=ptree([1,2,3])"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|Permanent| |n| R) 
((|constructor| (NIL "Permanent implements the functions permanent, the permanent for square matrices.")) (|permanent| ((|#2| (|SquareMatrix| |#1| |#2|)) "\\spad{permanent(x)} computes the permanent of a square matrix \\spad{x.} The permanent is equivalent to the \\spadfun{determinant} except that coefficients have no change of sign. This function is much more difficult to compute than the determinant. The formula used is by H.J. Ryser, improved by [Nijenhuis and Wilf, \\spad{Ch.} 19]. Note that permanent(x) choose one of three algorithms, depending on the underlying ring \\spad{R} and on \\spad{n,} the number of rows (and columns) of x:\\br if 2 has an inverse in \\spad{R} we can use the algorithm of [Nijenhuis and Wilf, ch.19,p.158]; if 2 has no inverse, some modifications are necessary:\\br if \\spad{n} > 6 and \\spad{R} is an integral domain with characteristic different from 2 (the algorithm works if and only 2 is not a zero-divisor of \\spad{R} and characteristic()$R \\spad{^=} 2, but how to check that for any given \\spad{R} \\spad{?),} the local function \\spad{permanent2} is called;\\br else, the local function \\spad{permanent3} is called (works for all commutative rings \\spad{R).}"))) 
NIL 
NIL 
(|PermutationCategory| S) 
((|constructor| (NIL "PermutationCategory provides a categorial environment for subgroups of bijections of a set (that is, permutations)")) (< (((|Boolean|) $ $) "\\spad{p < \\spad{q}} is an order relation on permutations. Note that this order is only total if and only if \\spad{S} is totally ordered or \\spad{S} is finite.")) (|orbit| (((|Set| |#1|) $ |#1|) "\\spad{orbit(p, el)} returns the orbit of el under the permutation \\spad{p,} that is, the set which is given by applications of the powers of \\spad{p} to el.")) (|elt| ((|#1| $ |#1|) "\\spad{elt(p, el)} returns the image of el under the permutation \\spad{p.}")) (|eval| ((|#1| $ |#1|) "\\spad{eval(p, el)} returns the image of el under the permutation \\spad{p.}")) (|cycles| (($ (|List| (|List| |#1|))) "\\spad{cycles(lls)} coerces a list list of cycles \\spad{lls} to a permutation, each cycle being a list with not repetitions, is coerced to the permutation, which maps ls.i to ls.i+1, indices modulo the length of the list, then these permutations are mutiplied. Error: if repetitions occur in one cycle.")) (|cycle| (($ (|List| |#1|)) "\\spad{cycle(ls)} coerces a cycle \\spad{ls,} that is, a list with not repetitions to a permutation, which maps ls.i to ls.i+1, indices modulo the length of the list. Error: if repetitions occur."))) 
((|unitsKnown| . T)) 
NIL 
(|PermutationGroup| S) 
((|constructor| (NIL "PermutationGroup implements permutation groups acting on a set \\spad{S,} \\spadignore{i.e.} all subgroups of the symmetric group of \\spad{S,} represented as a list of permutations (generators). Note that therefore the objects are not members of the Axiom category \\spadtype{Group}. Using the idea of base and strong generators by Sims, basic routines and algorithms are implemented so that the word problem for permutation groups can be solved.")) (|initializeGroupForWordProblem| (((|Void|) $ (|Integer|) (|Integer|)) "\\spad{initializeGroupForWordProblem(gp,m,n)} initializes the group \\spad{gp} for the word problem. Notes: \\spad{(1)} with a small integer you get shorter words, but the routine takes longer than the standard routine for longer words. \\spad{(2)} be careful: invoking this routine will destroy the possibly stored information about your group (but will recompute it again). \\spad{(3)} users need not call this function normally for the soultion of the word problem.") (((|Void|) $) "\\spad{initializeGroupForWordProblem(gp)} initializes the group \\spad{gp} for the word problem. Notes: it calls the other function of this name with parameters 0 and 1: initializeGroupForWordProblem(gp,0,1). Notes: \\spad{(1)} be careful: invoking this routine will destroy the possibly information about your group (but will recompute it again) \\spad{(2)} users need not call this function normally for the soultion of the word problem.")) (<= (((|Boolean|) $ $) "\\spad{gp1 \\spad{<=} gp2} returns \\spad{true} if and only if \\spad{gp1} is a subgroup of gp2. Note: because of a bug in the parser you have to call this function explicitly by \\spad{gp1} <=$(PERMGRP \\spad{S)} gp2.")) (< (((|Boolean|) $ $) "\\spad{gp1 < gp2} returns \\spad{true} if and only if \\spad{gp1} is a proper subgroup of gp2.")) (|movedPoints| (((|Set| |#1|) $) "\\spad{movedPoints(gp)} returns the points moved by the group \\spad{gp.}")) (|wordInGenerators| (((|List| (|NonNegativeInteger|)) (|Permutation| |#1|) $) "\\spad{wordInGenerators(p,gp)} returns the word for the permutation \\spad{p} in the original generators of the group \\spad{gp,} represented by the indices of the list, given by generators.")) (|wordInStrongGenerators| (((|List| (|NonNegativeInteger|)) (|Permutation| |#1|) $) "\\spad{wordInStrongGenerators(p,gp)} returns the word for the permutation \\spad{p} in the strong generators of the group \\spad{gp,} represented by the indices of the list, given by strongGenerators.")) (|member?| (((|Boolean|) (|Permutation| |#1|) $) "\\spad{member?(pp,gp)} answers the question, whether the permutation \\spad{pp} is in the group \\spad{gp} or not.")) (|orbits| (((|Set| (|Set| |#1|)) $) "\\spad{orbits(gp)} returns the orbits of the group \\spad{gp,} \\spadignore{i.e.} it partitions the (finite) of all moved points.")) (|orbit| (((|Set| (|List| |#1|)) $ (|List| |#1|)) "\\spad{orbit(gp,ls)} returns the orbit of the ordered list \\spad{ls} under the group \\spad{gp.} Note: return type is \\spad{L} \\spad{L} \\spad{S} temporarily because FSET \\spad{L} \\spad{S} has an error.") (((|Set| (|Set| |#1|)) $ (|Set| |#1|)) "\\spad{orbit(gp,els)} returns the orbit of the unordered set \\spad{els} under the group \\spad{gp.}") (((|Set| |#1|) $ |#1|) "\\spad{orbit(gp,el)} returns the orbit of the element \\spad{el} under the group \\spad{gp,} \\spadignore{i.e.} the set of all points gained by applying each group element to el.")) (|permutationGroup| (($ (|List| (|Permutation| |#1|))) "\\spad{permutationGroup(ls)} coerces a list of permutations \\spad{ls} to the group generated by this list.")) (|wordsForStrongGenerators| (((|List| (|List| (|NonNegativeInteger|))) $) "\\spad{wordsForStrongGenerators(gp)} returns the words for the strong generators of the group \\spad{gp} in the original generators of \\spad{gp,} represented by their indices in the list, given by generators.")) (|strongGenerators| (((|List| (|Permutation| |#1|)) $) "\\spad{strongGenerators(gp)} returns strong generators for the group \\spad{gp.}")) (|base| (((|List| |#1|) $) "\\spad{base(gp)} returns a base for the group \\spad{gp.}")) (|degree| (((|NonNegativeInteger|) $) "\\spad{degree(gp)} returns the number of points moved by all permutations of the group \\spad{gp.}")) (|order| (((|NonNegativeInteger|) $) "\\spad{order(gp)} returns the order of the group \\spad{gp.}")) (|random| (((|Permutation| |#1|) $) "\\spad{random(gp)} returns a random product of maximal 20 generators of the group \\spad{gp.} Note: random(gp)=random(gp,20).") (((|Permutation| |#1|) $ (|Integer|)) "\\spad{random(gp,i)} returns a random product of maximal \\spad{i} generators of the group \\spad{gp.}")) (|elt| (((|Permutation| |#1|) $ (|NonNegativeInteger|)) "\\spad{elt(gp,i)} returns the \\spad{i}-th generator of the group \\spad{gp.}")) (|generators| (((|List| (|Permutation| |#1|)) $) "\\spad{generators(gp)} returns the generators of the group \\spad{gp.}")) (|coerce| (($ (|List| (|Permutation| |#1|))) "\\spad{coerce(ls)} coerces a list of permutations \\spad{ls} to the group generated by this list.") (((|List| (|Permutation| |#1|)) $) "\\spad{coerce(gp)} returns the generators of the group \\spad{gp.}"))) 
NIL 
NIL 
(|Permutation| S) 
((|constructor| (NIL "Permutation(S) implements the group of all bijections on a set \\spad{S,} which move only a finite number of points. A permutation is considered as a map from \\spad{S} into \\spad{S.} In particular multiplication is defined as composition of maps:\\br \\spad{pi1} * \\spad{pi2} = \\spad{pi1} \\spad{o} pi2.\\br The internal representation of permuatations are two lists of equal length representing preimages and images.")) (|coerceImages| (($ (|List| |#1|)) "\\spad{coerceImages(ls)} coerces the list \\spad{ls} to a permutation whose image is given by \\spad{ls} and the preimage is fixed to be [1,...,n]. Note: {coerceImages(ls)=coercePreimagesImages([1,...,n],ls)}. We assume that both preimage and image do not contain repetitions.")) (|fixedPoints| (((|Set| |#1|) $) "\\indented{1}{fixedPoints(p) returns the points fixed by the permutation \\spad{p.}} \\spad{X} \\spad{p} \\spad{:=} coercePreimagesImages([[0,1,2,3],[3,0,2,1]])$PERM ZMOD 4 \\spad{X} fixedPoints \\spad{p}")) (|sort| (((|List| $) (|List| $)) "\\spad{sort(lp)} sorts a list of permutations \\spad{lp} according to cycle structure first according to length of cycles, second, if \\spad{S} has \\spadtype{Finite} or \\spad{S} has \\spadtype{OrderedSet} according to lexicographical order of entries in cycles of equal length.")) (|odd?| (((|Boolean|) $) "\\spad{odd?(p)} returns \\spad{true} if and only if \\spad{p} is an odd permutation \\spadignore{i.e.} sign(p) is \\spad{-1.}")) (|even?| (((|Boolean|) $) "\\indented{1}{even?(p) returns \\spad{true} if and only if \\spad{p} is an even permutation,} \\indented{1}{\\spadignore{i.e.} sign(p) is 1.} \\blankline \\spad{X} \\spad{p} \\spad{:=} coercePreimagesImages([[1,2,3],[1,2,3]]) \\spad{X} even? \\spad{p}")) (|sign| (((|Integer|) $) "\\spad{sign(p)} returns the signum of the permutation \\spad{p,} \\spad{+1} or \\spad{-1.}")) (|numberOfCycles| (((|NonNegativeInteger|) $) "\\spad{numberOfCycles(p)} returns the number of non-trivial cycles of the permutation \\spad{p.}")) (|order| (((|NonNegativeInteger|) $) "\\spad{order(p)} returns the order of a permutation \\spad{p} as a group element.")) (|cyclePartition| (((|Partition|) $) "\\spad{cyclePartition(p)} returns the cycle structure of a permutation \\spad{p} including cycles of length 1 only if \\spad{S} is finite.")) (|movedPoints| (((|Set| |#1|) $) "\\indented{1}{movedPoints(p) returns the set of points moved by the permutation \\spad{p.}} \\blankline \\spad{X} \\spad{p} \\spad{:=} coercePreimagesImages([[1,2,3],[1,2,3]]) \\spad{X} movedPoints \\spad{p}")) (|degree| (((|NonNegativeInteger|) $) "\\spad{degree(p)} retuns the number of points moved by the permutation \\spad{p.}")) (|coerceListOfPairs| (($ (|List| (|List| |#1|))) "\\spad{coerceListOfPairs(lls)} coerces a list of pairs \\spad{lls} to a permutation. Error: if not consistent, \\spadignore{i.e.} the set of the first elements coincides with the set of second elements. coerce(p) generates output of the permutation \\spad{p} with domain OutputForm.")) (|coerce| (($ (|List| |#1|)) "\\spad{coerce(ls)} coerces a cycle \\spad{ls,} \\spadignore{i.e.} a list with not repetitions to a permutation, which maps ls.i to ls.i+1, indices modulo the length of the list. Error: if repetitions occur.") (($ (|List| (|List| |#1|))) "\\spad{coerce(lls)} coerces a list of cycles \\spad{lls} to a permutation, each cycle being a list with no repetitions, is coerced to the permutation, which maps ls.i to ls.i+1, indices modulo the length of the list, then these permutations are mutiplied. Error: if repetitions occur in one cycle.")) (|coercePreimagesImages| (($ (|List| (|List| |#1|))) "\\indented{1}{coercePreimagesImages(lls) coerces the representation lls} \\indented{1}{of a permutation as a list of preimages and images to a permutation.} \\indented{1}{We assume that both preimage and image do not contain repetitions.} \\blankline \\spad{X} \\spad{p} \\spad{:=} coercePreimagesImages([[1,2,3],[1,2,3]]) \\spad{X} \\spad{q} \\spad{:=} coercePreimagesImages([[0,1,2,3],[3,0,2,1]])$PERM ZMOD 4")) (|listRepresentation| (((|Record| (|:| |preimage| (|List| |#1|)) (|:| |image| (|List| |#1|))) $) "\\spad{listRepresentation(p)} produces a representation rep of the permutation \\spad{p} as a list of preimages and images, i.e \\spad{p} maps (rep.preimage).k to (rep.image).k for all indices \\spad{k.} Elements of \\spad{S} not in (rep.preimage).k are fixed points, and these are the only fixed points of the permutation."))) 
((|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))))) 
(|PolynomialFactorizationByRecursion| R E |VarSet| S) 
((|constructor| (NIL "PolynomialFactorizationByRecursion(R,E,VarSet,S) is used for factorization of sparse univariate polynomials over a domain \\spad{S} of multivariate polynomials over \\spad{R.}")) (|factorSFBRlcUnit| (((|Factored| (|SparseUnivariatePolynomial| |#4|)) (|List| |#3|) (|SparseUnivariatePolynomial| |#4|)) "\\spad{factorSFBRlcUnit(p)} returns the square free factorization of polynomial \\spad{p} (see \\spadfun{factorSquareFreeByRecursion}{PolynomialFactorizationByRecursionUnivariate}) in the case where the leading coefficient of \\spad{p} is a unit.")) (|bivariateSLPEBR| (((|Union| (|List| (|SparseUnivariatePolynomial| |#4|)) "failed") (|List| (|SparseUnivariatePolynomial| |#4|)) (|SparseUnivariatePolynomial| |#4|) |#3|) "\\spad{bivariateSLPEBR(lp,p,v)} implements the bivariate case of solveLinearPolynomialEquationByRecursion its implementation depends on \\spad{R}")) (|randomR| ((|#1|) "\\spad{randomR produces} a random element of \\spad{R}")) (|factorSquareFreeByRecursion| (((|Factored| (|SparseUnivariatePolynomial| |#4|)) (|SparseUnivariatePolynomial| |#4|)) "\\spad{factorSquareFreeByRecursion(p)} returns the square free factorization of \\spad{p.} This functions performs the recursion step for factorSquareFreePolynomial, as defined in \\spadfun{PolynomialFactorizationExplicit} category (see \\spadfun{factorSquareFreePolynomial}).")) (|factorByRecursion| (((|Factored| (|SparseUnivariatePolynomial| |#4|)) (|SparseUnivariatePolynomial| |#4|)) "\\spad{factorByRecursion(p)} factors polynomial \\spad{p.} This function performs the recursion step for factorPolynomial, as defined in \\spadfun{PolynomialFactorizationExplicit} category (see \\spadfun{factorPolynomial})")) (|solveLinearPolynomialEquationByRecursion| (((|Union| (|List| (|SparseUnivariatePolynomial| |#4|)) "failed") (|List| (|SparseUnivariatePolynomial| |#4|)) (|SparseUnivariatePolynomial| |#4|)) "\\spad{solveLinearPolynomialEquationByRecursion([p1,...,pn],p)} returns the list of polynomials \\spad{[q1,...,qn]} such that \\spad{sum qi/pi = \\spad{p} / prod pi}, a recursion step for solveLinearPolynomialEquation as defined in \\spadfun{PolynomialFactorizationExplicit} category (see \\spadfun{solveLinearPolynomialEquation}). If no such list of \\spad{qi} exists, then \"failed\" is returned."))) 
NIL 
NIL 
(|PolynomialFactorizationByRecursionUnivariate| R S) 
((|constructor| (NIL "PolynomialFactorizationByRecursionUnivariate \\spad{R} is a \\spadfun{PolynomialFactorizationExplicit} domain, \\spad{S} is univariate polynomials over \\spad{R} We are interested in handling SparseUnivariatePolynomials over \\spad{S,} is a variable we shall call \\spad{z}")) (|factorSFBRlcUnit| (((|Factored| (|SparseUnivariatePolynomial| |#2|)) (|SparseUnivariatePolynomial| |#2|)) "\\spad{factorSFBRlcUnit(p)} returns the square free factorization of polynomial \\spad{p} (see \\spadfun{factorSquareFreeByRecursion}{PolynomialFactorizationByRecursionUnivariate}) in the case where the leading coefficient of \\spad{p} is a unit.")) (|randomR| ((|#1|) "\\spad{randomR()} produces a random element of \\spad{R}")) (|factorSquareFreeByRecursion| (((|Factored| (|SparseUnivariatePolynomial| |#2|)) (|SparseUnivariatePolynomial| |#2|)) "\\spad{factorSquareFreeByRecursion(p)} returns the square free factorization of \\spad{p.} This functions performs the recursion step for factorSquareFreePolynomial, as defined in \\spadfun{PolynomialFactorizationExplicit} category (see \\spadfun{factorSquareFreePolynomial}).")) (|factorByRecursion| (((|Factored| (|SparseUnivariatePolynomial| |#2|)) (|SparseUnivariatePolynomial| |#2|)) "\\spad{factorByRecursion(p)} factors polynomial \\spad{p.} This function performs the recursion step for factorPolynomial, as defined in \\spadfun{PolynomialFactorizationExplicit} category (see \\spadfun{factorPolynomial})")) (|solveLinearPolynomialEquationByRecursion| (((|Union| (|List| (|SparseUnivariatePolynomial| |#2|)) "failed") (|List| (|SparseUnivariatePolynomial| |#2|)) (|SparseUnivariatePolynomial| |#2|)) "\\spad{solveLinearPolynomialEquationByRecursion([p1,...,pn],p)} returns the list of polynomials \\spad{[q1,...,qn]} such that \\spad{sum qi/pi = \\spad{p} / prod pi}, a recursion step for solveLinearPolynomialEquation as defined in \\spadfun{PolynomialFactorizationExplicit} category (see \\spadfun{solveLinearPolynomialEquation}). If no such list of \\spad{qi} exists, then \"failed\" is returned."))) 
NIL 
NIL 
(|PolynomialFactorizationExplicit&| S) 
((|constructor| (NIL "This is the category of domains that know \"enough\" about themselves in order to factor univariate polynomials over themselves. This will be used in future releases for supporting factorization over finitely generated coefficient fields, it is not yet available in the current release of axiom.")) (|charthRoot| (((|Union| $ "failed") $) "\\spad{charthRoot(r)} returns the \\spad{p}-th root of \\spad{r,} or \"failed\" if none exists in the domain.")) (|conditionP| (((|Union| (|Vector| $) "failed") (|Matrix| $)) "\\spad{conditionP(m)} returns a vector of elements, not all zero, whose \\spad{p}-th powers \\spad{(p} is the characteristic of the domain) are a solution of the homogenous linear system represented by \\spad{m,} or \"failed\" is there is no such vector.")) (|solveLinearPolynomialEquation| (((|Union| (|List| (|SparseUnivariatePolynomial| $)) "failed") (|List| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $)) "\\spad{solveLinearPolynomialEquation([f1, ..., fn], \\spad{g)}} (where the \\spad{fi} are relatively prime to each other) returns a list of \\spad{ai} such that \\spad{g/prod \\spad{fi} = sum ai/fi} or returns \"failed\" if no such list of ai's exists.")) (|gcdPolynomial| (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)) "\\spad{gcdPolynomial(p,q)} returns the \\spad{gcd} of the univariate polynomials \\spad{p} \\spad{qnd} \\spad{q.}")) (|factorSquareFreePolynomial| (((|Factored| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $)) "\\spad{factorSquareFreePolynomial(p)} factors the univariate polynomial \\spad{p} into irreducibles where \\spad{p} is known to be square free and primitive with respect to its main variable.")) (|factorPolynomial| (((|Factored| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $)) "\\spad{factorPolynomial(p)} returns the factorization into irreducibles of the univariate polynomial \\spad{p.}")) (|squareFreePolynomial| (((|Factored| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $)) "\\spad{squareFreePolynomial(p)} returns the square-free factorization of the univariate polynomial \\spad{p.}"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|)))) 
(|PolynomialFactorizationExplicit|) 
((|constructor| (NIL "This is the category of domains that know \"enough\" about themselves in order to factor univariate polynomials over themselves. This will be used in future releases for supporting factorization over finitely generated coefficient fields, it is not yet available in the current release of axiom.")) (|charthRoot| (((|Union| $ "failed") $) "\\spad{charthRoot(r)} returns the \\spad{p}-th root of \\spad{r,} or \"failed\" if none exists in the domain.")) (|conditionP| (((|Union| (|Vector| $) "failed") (|Matrix| $)) "\\spad{conditionP(m)} returns a vector of elements, not all zero, whose \\spad{p}-th powers \\spad{(p} is the characteristic of the domain) are a solution of the homogenous linear system represented by \\spad{m,} or \"failed\" is there is no such vector.")) (|solveLinearPolynomialEquation| (((|Union| (|List| (|SparseUnivariatePolynomial| $)) "failed") (|List| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $)) "\\spad{solveLinearPolynomialEquation([f1, ..., fn], \\spad{g)}} (where the \\spad{fi} are relatively prime to each other) returns a list of \\spad{ai} such that \\spad{g/prod \\spad{fi} = sum ai/fi} or returns \"failed\" if no such list of ai's exists.")) (|gcdPolynomial| (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)) "\\spad{gcdPolynomial(p,q)} returns the \\spad{gcd} of the univariate polynomials \\spad{p} \\spad{qnd} \\spad{q.}")) (|factorSquareFreePolynomial| (((|Factored| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $)) "\\spad{factorSquareFreePolynomial(p)} factors the univariate polynomial \\spad{p} into irreducibles where \\spad{p} is known to be square free and primitive with respect to its main variable.")) (|factorPolynomial| (((|Factored| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $)) "\\spad{factorPolynomial(p)} returns the factorization into irreducibles of the univariate polynomial \\spad{p.}")) (|squareFreePolynomial| (((|Factored| (|SparseUnivariatePolynomial| $)) (|SparseUnivariatePolynomial| $)) "\\spad{squareFreePolynomial(p)} returns the square-free factorization of the univariate polynomial \\spad{p.}"))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|PrimeField| |p|) 
((|constructor| (NIL "PrimeField(p) implements the field with \\spad{p} elements if \\spad{p} is a prime number."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| $ (QUOTE (|CharacteristicZero|))) (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| $ (QUOTE (|Finite|)))) 
(|PointsOfFiniteOrder| R0 F UP UPUP R) 
((|constructor| (NIL "This package provides function for testing whether a divisor on a curve is a torsion divisor.")) (|torsionIfCan| (((|Union| (|Record| (|:| |order| (|NonNegativeInteger|)) (|:| |function| |#5|)) "failed") (|FiniteDivisor| |#2| |#3| |#4| |#5|)) "\\spad{torsionIfCan(f)}\\ undocumented")) (|torsion?| (((|Boolean|) (|FiniteDivisor| |#2| |#3| |#4| |#5|)) "\\spad{torsion?(f)} \\undocumented")) (|order| (((|Union| (|NonNegativeInteger|) "failed") (|FiniteDivisor| |#2| |#3| |#4| |#5|)) "\\spad{order(f)} \\undocumented"))) 
NIL 
NIL 
(|PointsOfFiniteOrderRational| UP UPUP R) 
((|constructor| (NIL "This package provides function for testing whether a divisor on a curve is a torsion divisor.")) (|torsionIfCan| (((|Union| (|Record| (|:| |order| (|NonNegativeInteger|)) (|:| |function| |#3|)) "failed") (|FiniteDivisor| (|Fraction| (|Integer|)) |#1| |#2| |#3|)) "\\spad{torsionIfCan(f)} \\undocumented")) (|torsion?| (((|Boolean|) (|FiniteDivisor| (|Fraction| (|Integer|)) |#1| |#2| |#3|)) "\\spad{torsion?(f)} \\undocumented")) (|order| (((|Union| (|NonNegativeInteger|) "failed") (|FiniteDivisor| (|Fraction| (|Integer|)) |#1| |#2| |#3|)) "\\spad{order(f)} \\undocumented"))) 
NIL 
NIL 
(|PackageForPoly| R |PolyRing| E |dim|) 
((|constructor| (NIL "The following is part of the PAFF package")) (|degreeOfMinimalForm| (((|NonNegativeInteger|) |#2|) "\\spad{degreeOfMinimalForm does} what it says")) (|listAllMono| (((|List| |#2|) (|NonNegativeInteger|)) "\\spad{listAllMono(l)} returns all the monomials of degree \\spad{l}")) (|listAllMonoExp| (((|List| |#3|) (|Integer|)) "\\spad{listAllMonoExp(l)} returns all the exponents of degree \\spad{l}")) (|homogenize| ((|#2| |#2| (|Integer|)) "\\spad{homogenize(pol,n)} returns the homogenized polynomial of \\spad{pol} with respect to the \\spad{n}-th variable.")) (|constant| ((|#1| |#2|) "\\spad{constant(pol)} returns the constant term of the polynomial.")) (|degOneCoef| ((|#1| |#2| (|PositiveInteger|)) "\\spad{degOneCoef(pol,n)} returns the coefficient in front of the monomial specified by the positive integer.")) (|translate| ((|#2| |#2| (|List| |#1|)) "\\spad{translate(pol,[a,b,c])} apply to \\spad{pol} the linear change of coordinates, x->x+a, y->y+b, z->z+c") ((|#2| |#2| (|List| |#1|) (|Integer|)) "\\spad{translate(pol,[a,b,c],3)} apply to \\spad{pol} the linear change of coordinates, x->x+a, y->y+b, z->1.")) (|replaceVarByOne| ((|#2| |#2| (|Integer|)) "\\spad{replaceVarByOne(pol,a)} evaluate to one the variable in \\spad{pol} specified by the integer a.")) (|replaceVarByZero| ((|#2| |#2| (|Integer|)) "\\spad{replaceVarByZero(pol,a)} evaluate to zero the variable in \\spad{pol} specified by the integer a.")) (|firstExponent| ((|#3| |#2|) "\\spad{firstExponent(pol)} returns the exponent of the first term in the representation of pol. Not to be confused with the leadingExponent \\indented{1}{which is the highest exponent according to the order} over the monomial.")) (|minimalForm| ((|#2| |#2|) "\\spad{minimalForm(pol)} returns the minimal forms of the polynomial pol."))) 
NIL 
NIL 
(|PointsOfFiniteOrderTools| UP UPUP) 
((|constructor| (NIL "Utilities for PFOQ and PFO")) (|polyred| ((|#2| |#2|) "\\spad{polyred(u)} \\undocumented")) (|doubleDisc| (((|Integer|) |#2|) "\\spad{doubleDisc(u)} \\undocumented")) (|mix| (((|Integer|) (|List| (|Record| (|:| |den| (|Integer|)) (|:| |gcdnum| (|Integer|))))) "\\spad{mix(l)} \\undocumented")) (|badNum| (((|Integer|) |#2|) "\\spad{badNum(u)} \\undocumented") (((|Record| (|:| |den| (|Integer|)) (|:| |gcdnum| (|Integer|))) |#1|) "\\spad{badNum(p)} \\undocumented")) (|getGoodPrime| (((|PositiveInteger|) (|Integer|)) "\\spad{getGoodPrime \\spad{n}} returns the smallest prime not dividing \\spad{n}"))) 
NIL 
NIL 
(|PartialFraction| R) 
((|constructor| (NIL "The domain \\spadtype{PartialFraction} implements partial fractions over a euclidean domain \\spad{R}. This requirement on the argument domain allows us to normalize the fractions. Of particular interest are the 2 forms for these fractions. The ``compact'' form has only one fractional term per prime in the denominator, while the ``p-adic'' form expands each numerator p-adically via the prime \\spad{p} in the denominator. For computational efficiency, the compact form is used, though the p-adic form may be gotten by calling the function padicFraction}. For a general euclidean domain, it is not known how to factor the denominator. Thus the function partialFraction takes as its second argument an element of \\spadtype{Factored(R)}.")) (|wholePart| ((|#1| $) "\\indented{1}{wholePart(p) extracts the whole part of the partial fraction} \\indented{1}{\\spad{p}.} \\blankline \\spad{X} a:=(74/13)::PFR(INT) \\spad{X} wholePart(a)")) (|partialFraction| (($ |#1| (|Factored| |#1|)) "\\indented{1}{partialFraction(numer,denom) is the main function for} \\indented{1}{constructing partial fractions. The second argument is the} \\indented{1}{denominator and should be factored.} \\blankline \\spad{X} partialFraction(1,factorial 10)")) (|padicFraction| (($ $) "\\indented{1}{padicFraction(q) expands the fraction p-adically in the primes} \\indented{1}{\\spad{p} in the denominator of \\spad{q}. For example,} \\indented{1}{\\spad{padicFraction(3/(2**2)) = 1/2 + 1/(2**2)}.} \\indented{1}{Use compactFraction from PartialFraction to} \\indented{1}{return to compact form.} \\blankline \\spad{X} a:=partialFraction(1,factorial 10) \\spad{X} padicFraction(a)")) (|padicallyExpand| (((|SparseUnivariatePolynomial| |#1|) |#1| |#1|) "\\spad{padicallyExpand(p,x)} is a utility function that expands the second argument \\spad{x} ``p-adically'' in the first.")) (|numberOfFractionalTerms| (((|Integer|) $) "\\indented{1}{numberOfFractionalTerms(p) computes the number of fractional} \\indented{1}{terms in \\spad{p}. This returns 0 if there is no fractional} \\indented{1}{part.} \\blankline \\spad{X} a:=partialFraction(1,factorial 10) \\spad{X} b:=padicFraction(a) \\spad{X} numberOfFractionalTerms(b)")) (|nthFractionalTerm| (($ $ (|Integer|)) "\\indented{1}{nthFractionalTerm(p,n) extracts the \\spad{n}th fractional term from} \\indented{1}{the partial fraction \\spad{p}.\\space{2}This returns 0 if the index} \\indented{1}{\\spad{n} is out of range.} \\blankline \\spad{X} a:=partialFraction(1,factorial 10) \\spad{X} b:=padicFraction(a) \\spad{X} nthFractionalTerm(b,3)")) (|firstNumer| ((|#1| $) "\\indented{1}{firstNumer(p) extracts the numerator of the first fractional} \\indented{1}{term. This returns 0 if there is no fractional part (use} \\indented{1}{wholePart from PartialFraction to get the whole part).} \\blankline \\spad{X} a:=partialFraction(1,factorial 10) \\spad{X} firstNumer(a)")) (|firstDenom| (((|Factored| |#1|) $) "\\indented{1}{firstDenom(p) extracts the denominator of the first fractional} \\indented{1}{term. This returns 1 if there is no fractional part (use} \\indented{1}{wholePart from PartialFraction to get the whole part).} \\blankline \\spad{X} a:=partialFraction(1,factorial 10) \\spad{X} firstDenom(a)")) (|compactFraction| (($ $) "\\indented{1}{compactFraction(p) normalizes the partial fraction \\spad{p}} \\indented{1}{to the compact representation. In this form, the partial} \\indented{1}{fraction has only one fractional term per prime in the} \\indented{1}{denominator.} \\blankline \\spad{X} a:=partialFraction(1,factorial 10) \\spad{X} b:=padicFraction(a) \\spad{X} compactFraction(b)")) (|coerce| (($ (|Fraction| (|Factored| |#1|))) "\\indented{1}{coerce(f) takes a fraction with numerator and denominator in} \\indented{1}{factored form and creates a partial fraction.\\space{2}It is} \\indented{1}{necessary for the parts to be factored because it is not} \\indented{1}{known in general how to factor elements of \\spad{R} and} \\indented{1}{this is needed to decompose into partial fractions.} \\blankline \\spad{X} (13/74)::PFR(INT)") (((|Fraction| |#1|) $) "\\indented{1}{coerce(p) sums up the components of the partial fraction and} \\indented{1}{returns a single fraction.} \\blankline \\spad{X} a:=(13/74)::PFR(INT) \\spad{X} a::FRAC(INT)"))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|PartialFractionPackage| R) 
((|constructor| (NIL "The package \\spadtype{PartialFractionPackage} gives an easier to use interfact the domain \\spadtype{PartialFraction}. The user gives a fraction of polynomials, and a variable and the package converts it to the proper datatype for the \\spadtype{PartialFraction} domain.")) (|partialFraction| (((|Any|) (|Polynomial| |#1|) (|Factored| (|Polynomial| |#1|)) (|Symbol|)) "\\spad{partialFraction(num, facdenom, var)} returns the partial fraction decomposition of the rational function whose numerator is \\spad{num} and whose factored denominator is \\spad{facdenom} with respect to the variable var.") (((|Any|) (|Fraction| (|Polynomial| |#1|)) (|Symbol|)) "\\indented{1}{partialFraction(rf, var) returns the partial fraction decomposition} \\indented{1}{of the rational function \\spad{rf} with respect to the variable var.} \\blankline \\spad{X} a:=x+1/(y+1) \\spad{X} partialFraction(a,y)$PFRPAC(INT)"))) 
NIL 
NIL 
(|PolynomialGcdPackage| E OV R P) 
((|constructor| (NIL "This package computes multivariate polynomial gcd's using a hensel lifting strategy. The constraint on the coefficient domain is imposed by the lifting strategy. It is assumed that the coefficient domain has the property that almost all specializations preserve the degree of the gcd.")) (|gcdPrimitive| ((|#4| (|List| |#4|)) "\\spad{gcdPrimitive \\spad{lp}} computes the \\spad{gcd} of the list of primitive polynomials \\spad{lp.}") (((|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#4|)) "\\spad{gcdPrimitive(p,q)} computes the \\spad{gcd} of the primitive polynomials \\spad{p} and \\spad{q.}") ((|#4| |#4| |#4|) "\\spad{gcdPrimitive(p,q)} computes the \\spad{gcd} of the primitive polynomials \\spad{p} and \\spad{q.}")) (|gcd| (((|SparseUnivariatePolynomial| |#4|) (|List| (|SparseUnivariatePolynomial| |#4|))) "\\spad{gcd(lp)} computes the \\spad{gcd} of the list of polynomials \\spad{lp.}") (((|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#4|) (|SparseUnivariatePolynomial| |#4|)) "\\spad{gcd(p,q)} computes the \\spad{gcd} of the two polynomials \\spad{p} and \\spad{q.}") ((|#4| (|List| |#4|)) "\\spad{gcd(lp)} computes the \\spad{gcd} of the list of polynomials \\spad{lp.}") ((|#4| |#4| |#4|) "\\indented{1}{gcd(p,q) computes the \\spad{gcd} of the two polynomials \\spad{p} and \\spad{q.}} \\blankline \\spad{X} p1:=(x+1)*(x+6) \\spad{X} p2:=(x+1)*(x-6) \\spad{X} gcd(p1,p2)"))) 
NIL 
NIL 
(|PermutationGroupExamples|) 
((|constructor| (NIL "PermutationGroupExamples provides permutation groups for some classes of groups: symmetric, alternating, dihedral, cyclic, direct products of cyclic, which are in fact the finite abelian groups of symmetric groups called Young subgroups. Furthermore, Rubik's group as permutation group of 48 integers and a list of sporadic simple groups derived from the atlas of finite groups.")) (|youngGroup| (((|PermutationGroup| (|Integer|)) (|Partition|)) "\\spad{youngGroup(lambda)} constructs the direct product of the symmetric groups given by the parts of the partition lambda.") (((|PermutationGroup| (|Integer|)) (|List| (|Integer|))) "\\spad{youngGroup([n1,...,nk])} constructs the direct product of the symmetric groups Sn1,...,Snk.")) (|rubiksGroup| (((|PermutationGroup| (|Integer|))) "\\spad{rubiksGroup constructs} the permutation group representing Rubic's Cube acting on integers 10*i+j for 1 \\spad{<=} \\spad{i} \\spad{<=} 6, 1 \\spad{<=} \\spad{j} \\spad{<=} 8. The faces of Rubik's Cube are labelled in the obvious way Front, Right, Up, Down, Left, Back and numbered from 1 to 6 in this given ordering, the pieces on each face (except the unmoveable center piece) are clockwise numbered from 1 to 8 starting with the piece in the upper left corner. The moves of the cube are represented as permutations on these pieces, represented as a two digit integer ij where \\spad{i} is the numer of theface \\spad{(1} to 6) and \\spad{j} is the number of the piece on this face. The remaining ambiguities are resolved by looking at the 6 generators, which represent a 90 degree turns of the faces, or from the following pictorial description. Permutation group representing Rubic's Cube acting on integers 10*i+j for 1 \\spad{<=} \\spad{i} \\spad{<=} 6, 1 \\spad{<=} \\spad{j} <=8. \\blankline\\begin{verbatim}Rubik's Cube:   +-----+ +-- B   where: marks Side # :               / U   /|/              /     / |         F(ront)    <->    1      L -->  +-----+ R|         R(ight)    <->    2             |     |  +         U(p)       <->    3             |  F  | /          D(own)     <->    4             |     |/           L(eft)     <->    5             +-----+            B(ack)     <->    6                ^                |                DThe Cube's surface:                               The pieces on each side            +---+              (except the unmoveable center            |567|              piece) are clockwise numbered            |4U8|              from 1 to 8 starting with the            |321|              piece in the upper left        +---+---+---+          corner (see figure on the        |781|123|345|          left).  The moves of the cube        |6L2|8F4|2R6|          are represented as        |543|765|187|          permutations on these pieces.        +---+---+---+          Each of the pieces is            |123|              represented as a two digit            |8D4|              integer ij where i is the            |765|              # of the side ( 1 to 6 for            +---+              F to B (see table above ))            |567|              and j is the # of the piece.            |4B8|            |321|            +---+\\end{verbatim}")) (|janko2| (((|PermutationGroup| (|Integer|))) "\\spad{janko2 constructs} the janko group acting on the integers 1,...,100.") (((|PermutationGroup| (|Integer|)) (|List| (|Integer|))) "\\spad{janko2(li)} constructs the janko group acting on the 100 integers given in the list li. Note that duplicates in the list will be removed. Error: if \\spad{li} has less or more than 100 different entries")) (|mathieu24| (((|PermutationGroup| (|Integer|))) "\\spad{mathieu24 constructs} the mathieu group acting on the integers 1,...,24.") (((|PermutationGroup| (|Integer|)) (|List| (|Integer|))) "\\spad{mathieu24(li)} constructs the mathieu group acting on the 24 integers given in the list li. Note that duplicates in the list will be removed. Error: if \\spad{li} has less or more than 24 different entries.")) (|mathieu23| (((|PermutationGroup| (|Integer|))) "\\spad{mathieu23 constructs} the mathieu group acting on the integers 1,...,23.") (((|PermutationGroup| (|Integer|)) (|List| (|Integer|))) "\\spad{mathieu23(li)} constructs the mathieu group acting on the 23 integers given in the list li. Note that duplicates in the list will be removed. Error: if \\spad{li} has less or more than 23 different entries.")) (|mathieu22| (((|PermutationGroup| (|Integer|))) "\\spad{mathieu22 constructs} the mathieu group acting on the integers 1,...,22.") (((|PermutationGroup| (|Integer|)) (|List| (|Integer|))) "\\spad{mathieu22(li)} constructs the mathieu group acting on the 22 integers given in the list li. Note that duplicates in the list will be removed. Error: if \\spad{li} has less or more than 22 different entries.")) (|mathieu12| (((|PermutationGroup| (|Integer|))) "\\spad{mathieu12 constructs} the mathieu group acting on the integers 1,...,12.") (((|PermutationGroup| (|Integer|)) (|List| (|Integer|))) "\\spad{mathieu12(li)} constructs the mathieu group acting on the 12 integers given in the list li. Note that duplicates in the list will be removed Error: if \\spad{li} has less or more than 12 different entries.")) (|mathieu11| (((|PermutationGroup| (|Integer|))) "\\spad{mathieu11 constructs} the mathieu group acting on the integers 1,...,11.") (((|PermutationGroup| (|Integer|)) (|List| (|Integer|))) "\\spad{mathieu11(li)} constructs the mathieu group acting on the 11 integers given in the list li. Note that duplicates in the list will be removed. error, if \\spad{li} has less or more than 11 different entries.")) (|dihedralGroup| (((|PermutationGroup| (|Integer|)) (|List| (|Integer|))) "\\spad{dihedralGroup([i1,...,ik])} constructs the dihedral group of order 2k acting on the integers out of i1,...,ik. Note that duplicates in the list will be removed.") (((|PermutationGroup| (|Integer|)) (|PositiveInteger|)) "\\spad{dihedralGroup(n)} constructs the dihedral group of order 2n acting on integers 1,...,N.")) (|cyclicGroup| (((|PermutationGroup| (|Integer|)) (|List| (|Integer|))) "\\spad{cyclicGroup([i1,...,ik])} constructs the cyclic group of order \\spad{k} acting on the integers i1,...,ik. Note that duplicates in the list will be removed.") (((|PermutationGroup| (|Integer|)) (|PositiveInteger|)) "\\spad{cyclicGroup(n)} constructs the cyclic group of order \\spad{n} acting on the integers 1,...,n.")) (|abelianGroup| (((|PermutationGroup| (|Integer|)) (|List| (|PositiveInteger|))) "\\spad{abelianGroup([n1,...,nk])} constructs the abelian group that is the direct product of cyclic groups with order ni.")) (|alternatingGroup| (((|PermutationGroup| (|Integer|)) (|List| (|Integer|))) "\\spad{alternatingGroup(li)} constructs the alternating group acting on the integers in the list li, generators are in general the n-2-cycle (li.3,...,li.n) and the 3-cycle (li.1,li.2,li.3), if \\spad{n} is odd and product of the 2-cycle (li.1,li.2) with n-2-cycle (li.3,...,li.n) and the 3-cycle (li.1,li.2,li.3), if \\spad{n} is even. Note that duplicates in the list will be removed.") (((|PermutationGroup| (|Integer|)) (|PositiveInteger|)) "\\spad{alternatingGroup(n)} constructs the alternating group An acting on the integers 1,...,n, generators are in general the n-2-cycle (3,...,n) and the 3-cycle (1,2,3) if \\spad{n} is odd and the product of the 2-cycle (1,2) with n-2-cycle (3,...,n) and the 3-cycle (1,2,3) if \\spad{n} is even.")) (|symmetricGroup| (((|PermutationGroup| (|Integer|)) (|List| (|Integer|))) "\\spad{symmetricGroup(li)} constructs the symmetric group acting on the integers in the list li, generators are the cycle given by \\spad{li} and the 2-cycle (li.1,li.2). Note that duplicates in the list will be removed.") (((|PermutationGroup| (|Integer|)) (|PositiveInteger|)) "\\spad{symmetricGroup(n)} constructs the symmetric group \\spad{Sn} acting on the integers 1,...,n, generators are the n-cycle (1,...,n) and the 2-cycle (1,2)."))) 
NIL 
NIL 
(|PolyGroebner| F) 
((|constructor| (NIL "Groebner functions for \\spad{P} \\spad{F} This package is an interface package to the groebner basis package which allows you to compute groebner bases for polynomials in either lexicographic ordering or total degree ordering refined by reverse lex. The input is the ordinary polynomial type which is internally converted to a type with the required ordering. The resulting grobner basis is converted back to ordinary polynomials. The ordering among the variables is controlled by an explicit list of variables which is passed as a second argument. The coefficient domain is allowed to be any \\spad{gcd} domain, but the groebner basis is computed as if the polynomials were over a field.")) (|totalGroebner| (((|List| (|Polynomial| |#1|)) (|List| (|Polynomial| |#1|)) (|List| (|Symbol|))) "\\spad{totalGroebner(lp,lv)} computes Groebner basis for the list of polynomials \\spad{lp} with the terms ordered first by total degree and then refined by reverse lexicographic ordering. The variables are ordered by their position in the list \\spad{lv.}")) (|lexGroebner| (((|List| (|Polynomial| |#1|)) (|List| (|Polynomial| |#1|)) (|List| (|Symbol|))) "\\spad{lexGroebner(lp,lv)} computes Groebner basis for the list of polynomials \\spad{lp} in lexicographic order. The variables are ordered by their position in the list \\spad{lv.}"))) 
NIL 
NIL 
(|PiCoercions| R) 
((|constructor| (NIL "Provides a coercion from the symbolic fractions in \\%pi with integer coefficients to any Expression type.")) (|coerce| (((|Expression| |#1|) (|Pi|)) "\\spad{coerce(f)} returns \\spad{f} as an Expression(R)."))) 
NIL 
NIL 
(|PrincipalIdealDomain|) 
((|constructor| (NIL "The category of constructive principal ideal domains, \\spadignore{i.e.} where a single generator can be constructively found for any ideal given by a finite set of generators. Note that this constructive definition only implies that finitely generated ideals are principal. It is not clear what we would mean by an infinitely generated ideal.")) (|expressIdealMember| (((|Union| (|List| $) "failed") (|List| $) $) "\\spad{expressIdealMember([f1,...,fn],h)} returns a representation of \\spad{h} as a linear combination of the \\spad{fi} or \"failed\" if \\spad{h} is not in the ideal generated by the fi.")) (|principalIdeal| (((|Record| (|:| |coef| (|List| $)) (|:| |generator| $)) (|List| $)) "\\spad{principalIdeal([f1,...,fn])} returns a record whose generator component is a generator of the ideal generated by \\spad{[f1,...,fn]} whose coef component satisfies \\spad{generator = sum (input.i * coef.i)}"))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|PositiveInteger|) 
((|constructor| (NIL "\\spadtype{PositiveInteger} provides functions for positive integers.")) (|commutative| ((|attribute| "*") "\\spad{commutative(\"*\")} means multiplication is commutative : x*y = \\spad{y*x}")) (|gcd| (($ $ $) "\\spad{gcd(a,b)} computes the greatest common divisor of two positive integers \\spad{a} and \\spad{b.}"))) 
(((|commutative| "*") . T)) 
NIL 
(|PolynomialInterpolationAlgorithms| F P) 
((|constructor| (NIL "This package exports interpolation algorithms")) (|LagrangeInterpolation| ((|#2| (|List| |#1|) (|List| |#1|)) "\\spad{LagrangeInterpolation(l1,l2)} \\undocumented"))) 
NIL 
NIL 
(|PolynomialInterpolation| |xx| F) 
((|constructor| (NIL "This package exports interpolation algorithms")) (|interpolate| (((|SparseUnivariatePolynomial| |#2|) (|List| |#2|) (|List| |#2|)) "\\spad{interpolate(lf,lg)} \\undocumented") (((|UnivariatePolynomial| |#1| |#2|) (|UnivariatePolynomial| |#1| |#2|) (|List| |#2|) (|List| |#2|)) "\\spad{interpolate(u,lf,lg)} \\undocumented"))) 
NIL 
NIL 
(|PlacesCategory| K PCS) 
((|constructor| (NIL "This is part of the PAFF package, related to projective space.")) (|elt| ((|#1| $ (|Integer|)) "\\spad{elt returns} the value of a specified coordinates if the places correspnd to a simple point")) (|setFoundPlacesToEmpty| (((|List| $)) "\\spad{setFoundPlacesToEmpty()} does what it says. (this should not be used)!!!")) (|foundPlaces| (((|List| $)) "\\spad{foundPlaces()} returns the list of all \"created\" places up to now.")) (|leaf?| (((|Boolean|) $) "\\spad{leaf?(pl)} test if the place \\spad{pl} correspond to a leaf of a desingularisation tree.")) (|setDegree!| (((|Void|) $ (|PositiveInteger|)) "\\spad{setDegree!(pl,ls)} set the degree.")) (|setParam!| (((|Void|) $ (|List| |#2|)) "\\spad{setParam!(pl,ls)} set the local parametrization of \\spad{pl} to \\spad{ls.}")) (|localParam| (((|List| |#2|) $) "\\spad{localParam(pl)} returns the local parametrization associated to the place \\spad{pl.}"))) 
NIL 
NIL 
(|Places| K) 
((|constructor| (NIL "The following is part of the PAFF package"))) 
NIL 
NIL 
(|PlacesOverPseudoAlgebraicClosureOfFiniteField| K) 
((|constructor| (NIL "The following is part of the PAFF package"))) 
NIL 
NIL 
(|Plcs| K PCS) 
((|constructor| (NIL "The following is part of the PAFF package"))) 
NIL 
NIL 
(|ParametricLinearEquations| R |Var| |Expon| GR) 
((|constructor| (NIL "This package completely solves a parametric linear system of equations by decomposing the set of all parametric values for which the linear system is consistent into a union of quasi-algebraic sets (which need not be irredundant, but most of the time is). Each quasi-algebraic set is described by a list of polynomials that vanish on the set, and a list of polynomials that vanish at no point of the set. For each quasi-algebraic set, the solution of the linear system is given, as a particular solution and a basis of the homogeneous system. \\blankline The parametric linear system should be given in matrix form, with a coefficient matrix and a right hand side vector. The entries of the coefficient matrix and right hand side vector should be polynomials in the parametric variables, over a Euclidean domain of characteristic zero. \\blankline If the system is homogeneous, the right hand side need not be given. The right hand side can also be replaced by an indeterminate vector, in which case, the conditions required for consistency will also be given. \\blankline The package has other facilities for saving results to external files, as well as solving the system for a specified minimum rank. Altogether there are 12 mode maps for psolve, as explained below.")) (|inconsistent?| (((|Boolean|) (|List| (|Polynomial| |#1|))) "inconsistant?(pl) returns \\spad{true} if the system of equations \\spad{p} = 0 for \\spad{p} in \\spad{pl} is inconsistent. It is assumed that \\spad{pl} is a groebner basis.") (((|Boolean|) (|List| |#4|)) "inconsistant?(pl) returns \\spad{true} if the system of equations \\spad{p} = 0 for \\spad{p} in \\spad{pl} is inconsistent. It is assumed that \\spad{pl} is a groebner basis.")) (|sqfree| ((|#4| |#4|) "\\spad{sqfree(p)} returns the product of square free factors of \\spad{p}")) (|regime| (((|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|)) (|:| |wcond| (|List| (|Polynomial| |#1|))) (|:| |bsoln| (|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|)))) (|:| |basis| (|List| (|Vector| (|Fraction| (|Polynomial| |#1|)))))))) (|Record| (|:| |det| |#4|) (|:| |rows| (|List| (|Integer|))) (|:| |cols| (|List| (|Integer|)))) (|Matrix| |#4|) (|List| (|Fraction| (|Polynomial| |#1|))) (|List| (|List| |#4|)) (|NonNegativeInteger|) (|NonNegativeInteger|) (|Integer|)) "\\spad{regime(y,c, \\spad{w,} \\spad{p,} \\spad{r,} \\spad{rm,} \\spad{m)}} returns a regime, a list of polynomials specifying the consistency conditions, a particular solution and basis representing the general solution of the parametric linear system \\spad{c} \\spad{z} = \\spad{w} on that regime. The regime returned depends on the subdeterminant y.det and the row and column indices. The solutions are simplified using the assumption that the system has rank \\spad{r} and maximum rank \\spad{rm.} The list \\spad{p} represents a list of list of factors of polynomials in a groebner basis of the ideal generated by higher order subdeterminants, and ius used for the simplification. The mode \\spad{m} distinguishes the cases when the system is homogeneous, or the right hand side is arbitrary, or when there is no new right hand side variables.")) (|redmat| (((|Matrix| |#4|) (|Matrix| |#4|) (|List| |#4|)) "\\spad{redmat(m,g)} returns a matrix whose entries are those of \\spad{m} modulo the ideal generated by the groebner basis \\spad{g}")) (|ParCond| (((|List| (|Record| (|:| |det| |#4|) (|:| |rows| (|List| (|Integer|))) (|:| |cols| (|List| (|Integer|))))) (|Matrix| |#4|) (|NonNegativeInteger|)) "\\spad{ParCond(m,k)} returns the list of all \\spad{k} by \\spad{k} subdeterminants in the matrix \\spad{m}")) (|overset?| (((|Boolean|) (|List| |#4|) (|List| (|List| |#4|))) "\\spad{overset?(s,sl)} returns \\spad{true} if \\spad{s} properly a sublist of a member of \\spad{sl;} otherwise it returns \\spad{false}")) (|nextSublist| (((|List| (|List| (|Integer|))) (|Integer|) (|Integer|)) "\\spad{nextSublist(n,k)} returns a list of k-subsets of \\spad{{1,} ..., \\spad{n}.}")) (|minset| (((|List| (|List| |#4|)) (|List| (|List| |#4|))) "\\spad{minset(sl)} returns the sublist of \\spad{sl} consisting of the minimal lists (with respect to inclusion) in the list \\spad{sl} of lists")) (|minrank| (((|NonNegativeInteger|) (|List| (|Record| (|:| |rank| (|NonNegativeInteger|)) (|:| |eqns| (|List| (|Record| (|:| |det| |#4|) (|:| |rows| (|List| (|Integer|))) (|:| |cols| (|List| (|Integer|)))))) (|:| |fgb| (|List| |#4|))))) "\\spad{minrank(r)} returns the minimum rank in the list \\spad{r} of regimes")) (|maxrank| (((|NonNegativeInteger|) (|List| (|Record| (|:| |rank| (|NonNegativeInteger|)) (|:| |eqns| (|List| (|Record| (|:| |det| |#4|) (|:| |rows| (|List| (|Integer|))) (|:| |cols| (|List| (|Integer|)))))) (|:| |fgb| (|List| |#4|))))) "\\spad{maxrank(r)} returns the maximum rank in the list \\spad{r} of regimes")) (|factorset| (((|List| |#4|) |#4|) "\\spad{factorset(p)} returns the set of irreducible factors of \\spad{p.}")) (|B1solve| (((|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|)))) (|:| |basis| (|List| (|Vector| (|Fraction| (|Polynomial| |#1|)))))) (|Record| (|:| |mat| (|Matrix| (|Fraction| (|Polynomial| |#1|)))) (|:| |vec| (|List| (|Fraction| (|Polynomial| |#1|)))) (|:| |rank| (|NonNegativeInteger|)) (|:| |rows| (|List| (|Integer|))) (|:| |cols| (|List| (|Integer|))))) "\\spad{B1solve(s)} solves the system (s.mat) \\spad{z} = s.vec for the variables given by the column indices of s.cols in terms of the other variables and the right hand side s.vec by assuming that the rank is s.rank, that the system is consistent, with the linearly independent equations indexed by the given row indices s.rows; the coefficients in s.mat involving parameters are treated as polynomials. B1solve(s) returns a particular solution to the system and a basis of the homogeneous system (s.mat) \\spad{z} = 0.")) (|redpps| (((|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|)))) (|:| |basis| (|List| (|Vector| (|Fraction| (|Polynomial| |#1|)))))) (|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|)))) (|:| |basis| (|List| (|Vector| (|Fraction| (|Polynomial| |#1|)))))) (|List| |#4|)) "\\spad{redpps(s,g)} returns the simplified form of \\spad{s} after reducing modulo a groebner basis \\spad{g}")) (|ParCondList| (((|List| (|Record| (|:| |rank| (|NonNegativeInteger|)) (|:| |eqns| (|List| (|Record| (|:| |det| |#4|) (|:| |rows| (|List| (|Integer|))) (|:| |cols| (|List| (|Integer|)))))) (|:| |fgb| (|List| |#4|)))) (|Matrix| |#4|) (|NonNegativeInteger|)) "\\spad{ParCondList(c,r)} computes a list of subdeterminants of each rank \\spad{>=} \\spad{r} of the matrix \\spad{c} and returns a groebner basis for the ideal they generate")) (|hasoln| (((|Record| (|:| |sysok| (|Boolean|)) (|:| |z0| (|List| |#4|)) (|:| |n0| (|List| |#4|))) (|List| |#4|) (|List| |#4|)) "\\spad{hasoln(g, \\spad{l)}} tests whether the quasi-algebraic set defined by \\spad{p} = 0 for \\spad{p} in \\spad{g} and \\spad{q} \\spad{^=} 0 for \\spad{q} in \\spad{l} is empty or not and returns a simplified definition of the quasi-algebraic set")) (|pr2dmp| ((|#4| (|Polynomial| |#1|)) "\\spad{pr2dmp(p)} converts \\spad{p} to target domain")) (|se2rfi| (((|List| (|Fraction| (|Polynomial| |#1|))) (|List| (|Symbol|))) "\\spad{se2rfi(l)} converts \\spad{l} to target domain")) (|dmp2rfi| (((|List| (|Fraction| (|Polynomial| |#1|))) (|List| |#4|)) "\\spad{dmp2rfi(l)} converts \\spad{l} to target domain") (((|Matrix| (|Fraction| (|Polynomial| |#1|))) (|Matrix| |#4|)) "\\spad{dmp2rfi(m)} converts \\spad{m} to target domain") (((|Fraction| (|Polynomial| |#1|)) |#4|) "\\spad{dmp2rfi(p)} converts \\spad{p} to target domain")) (|bsolve| (((|Record| (|:| |rgl| (|List| (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|)) (|:| |wcond| (|List| (|Polynomial| |#1|))) (|:| |bsoln| (|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|)))) (|:| |basis| (|List| (|Vector| (|Fraction| (|Polynomial| |#1|)))))))))) (|:| |rgsz| (|Integer|))) (|Matrix| |#4|) (|List| (|Fraction| (|Polynomial| |#1|))) (|NonNegativeInteger|) (|String|) (|Integer|)) "\\spad{bsolve(c, \\spad{w,} \\spad{r,} \\spad{s,} \\spad{m)}} returns a list of regimes and solutions of the system \\spad{c} \\spad{z} = \\spad{w} for ranks at least \\spad{r;} depending on the mode \\spad{m} chosen, it writes the output to a file given by the string \\spad{s.}")) (|rdregime| (((|List| (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|)) (|:| |wcond| (|List| (|Polynomial| |#1|))) (|:| |bsoln| (|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|)))) (|:| |basis| (|List| (|Vector| (|Fraction| (|Polynomial| |#1|))))))))) (|String|)) "\\spad{rdregime(s)} reads in a list from a file with name \\spad{s}")) (|wrregime| (((|Integer|) (|List| (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|)) (|:| |wcond| (|List| (|Polynomial| |#1|))) (|:| |bsoln| (|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|)))) (|:| |basis| (|List| (|Vector| (|Fraction| (|Polynomial| |#1|))))))))) (|String|)) "\\spad{wrregime(l,s)} writes a list of regimes to a file named \\spad{s} and returns the number of regimes written")) (|psolve| (((|Integer|) (|Matrix| |#4|) (|PositiveInteger|) (|String|)) "\\spad{psolve(c,k,s)} solves \\spad{c} \\spad{z} = 0 for all possible ranks \\spad{>=} \\spad{k} of the matrix \\spad{c,} writes the results to a file named \\spad{s,} and returns the number of regimes") (((|Integer|) (|Matrix| |#4|) (|List| (|Symbol|)) (|PositiveInteger|) (|String|)) "\\spad{psolve(c,w,k,s)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks \\spad{>=} \\spad{k} of the matrix \\spad{c} and indeterminate right hand side \\spad{w,} writes the results to a file named \\spad{s,} and returns the number of regimes") (((|Integer|) (|Matrix| |#4|) (|List| |#4|) (|PositiveInteger|) (|String|)) "\\spad{psolve(c,w,k,s)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks \\spad{>=} \\spad{k} of the matrix \\spad{c} and given right hand side \\spad{w,} writes the results to a file named \\spad{s,} and returns the number of regimes") (((|Integer|) (|Matrix| |#4|) (|String|)) "\\spad{psolve(c,s)} solves \\spad{c} \\spad{z} = 0 for all possible ranks of the matrix \\spad{c} and given right hand side vector \\spad{w,} writes the results to a file named \\spad{s,} and returns the number of regimes") (((|Integer|) (|Matrix| |#4|) (|List| (|Symbol|)) (|String|)) "\\spad{psolve(c,w,s)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks of the matrix \\spad{c} and indeterminate right hand side \\spad{w,} writes the results to a file named \\spad{s,} and returns the number of regimes") (((|Integer|) (|Matrix| |#4|) (|List| |#4|) (|String|)) "\\spad{psolve(c,w,s)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks of the matrix \\spad{c} and given right hand side vector \\spad{w,} writes the results to a file named \\spad{s,} and returns the number of regimes") (((|List| (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|)) (|:| |wcond| (|List| (|Polynomial| |#1|))) (|:| |bsoln| (|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|)))) (|:| |basis| (|List| (|Vector| (|Fraction| (|Polynomial| |#1|))))))))) (|Matrix| |#4|) (|PositiveInteger|)) "\\spad{psolve(c)} solves the homogeneous linear system \\spad{c} \\spad{z} = 0 for all possible ranks \\spad{>=} \\spad{k} of the matrix \\spad{c}") (((|List| (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|)) (|:| |wcond| (|List| (|Polynomial| |#1|))) (|:| |bsoln| (|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|)))) (|:| |basis| (|List| (|Vector| (|Fraction| (|Polynomial| |#1|))))))))) (|Matrix| |#4|) (|List| (|Symbol|)) (|PositiveInteger|)) "\\spad{psolve(c,w,k)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks \\spad{>=} \\spad{k} of the matrix \\spad{c} and indeterminate right hand side \\spad{w}") (((|List| (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|)) (|:| |wcond| (|List| (|Polynomial| |#1|))) (|:| |bsoln| (|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|)))) (|:| |basis| (|List| (|Vector| (|Fraction| (|Polynomial| |#1|))))))))) (|Matrix| |#4|) (|List| |#4|) (|PositiveInteger|)) "\\spad{psolve(c,w,k)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks \\spad{>=} \\spad{k} of the matrix \\spad{c} and given right hand side vector \\spad{w}") (((|List| (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|)) (|:| |wcond| (|List| (|Polynomial| |#1|))) (|:| |bsoln| (|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|)))) (|:| |basis| (|List| (|Vector| (|Fraction| (|Polynomial| |#1|))))))))) (|Matrix| |#4|)) "\\spad{psolve(c)} solves the homogeneous linear system \\spad{c} \\spad{z} = 0 for all possible ranks of the matrix \\spad{c}") (((|List| (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|)) (|:| |wcond| (|List| (|Polynomial| |#1|))) (|:| |bsoln| (|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|)))) (|:| |basis| (|List| (|Vector| (|Fraction| (|Polynomial| |#1|))))))))) (|Matrix| |#4|) (|List| (|Symbol|))) "\\spad{psolve(c,w)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks of the matrix \\spad{c} and indeterminate right hand side \\spad{w}") (((|List| (|Record| (|:| |eqzro| (|List| |#4|)) (|:| |neqzro| (|List| |#4|)) (|:| |wcond| (|List| (|Polynomial| |#1|))) (|:| |bsoln| (|Record| (|:| |partsol| (|Vector| (|Fraction| (|Polynomial| |#1|)))) (|:| |basis| (|List| (|Vector| (|Fraction| (|Polynomial| |#1|))))))))) (|Matrix| |#4|) (|List| |#4|)) "\\spad{psolve(c,w)} solves \\spad{c} \\spad{z} = \\spad{w} for all possible ranks of the matrix \\spad{c} and given right hand side vector \\spad{w}"))) 
NIL 
NIL 
(|PlotFunctions1| S) 
((|constructor| (NIL "\\spad{PlotFunctions1} provides facilities for plotting curves where functions \\spad{SF} \\spad{->} \\spad{SF} are specified by giving an expression")) (|plotPolar| (((|Plot|) |#1| (|Symbol|)) "\\spad{plotPolar(f,theta)} plots the graph of \\spad{r = f(theta)} as \\spad{theta} ranges from 0 to 2 \\spad{pi}") (((|Plot|) |#1| (|Symbol|) (|Segment| (|DoubleFloat|))) "\\spad{plotPolar(f,theta,seg)} plots the graph of \\spad{r = f(theta)} as \\spad{theta} ranges over an interval")) (|plot| (((|Plot|) |#1| |#1| (|Symbol|) (|Segment| (|DoubleFloat|))) "\\spad{plot(f,g,t,seg)} plots the graph of \\spad{x = f(t)}, \\spad{y = g(t)} as \\spad{t} ranges over an interval.") (((|Plot|) |#1| (|Symbol|) (|Segment| (|DoubleFloat|))) "\\spad{plot(fcn,x,seg)} plots the graph of \\spad{y = f(x)} on a interval"))) 
NIL 
NIL 
(|Plot3D|) 
((|constructor| (NIL "Plot3D supports parametric plots defined over a real number system. A real number system is a model for the real numbers and as such may be an approximation. For example, floating point numbers and infinite continued fractions are real number systems. The facilities at this point are limited to 3-dimensional parametric plots.")) (|debug3D| (((|Boolean|) (|Boolean|)) "\\spad{debug3D(true)} turns debug mode on; debug3D(false) turns debug mode off.")) (|numFunEvals3D| (((|Integer|)) "\\spad{numFunEvals3D()} returns the number of points computed.")) (|setAdaptive3D| (((|Boolean|) (|Boolean|)) "\\spad{setAdaptive3D(true)} turns adaptive plotting on; setAdaptive3D(false) turns adaptive plotting off.")) (|adaptive3D?| (((|Boolean|)) "\\spad{adaptive3D?()} determines whether plotting be done adaptively.")) (|setScreenResolution3D| (((|Integer|) (|Integer|)) "\\spad{setScreenResolution3D(i)} sets the screen resolution for a 3d graph to i.")) (|screenResolution3D| (((|Integer|)) "\\spad{screenResolution3D()} returns the screen resolution for a 3d graph.")) (|setMaxPoints3D| (((|Integer|) (|Integer|)) "\\spad{setMaxPoints3D(i)} sets the maximum number of points in a plot to i.")) (|maxPoints3D| (((|Integer|)) "\\spad{maxPoints3D()} returns the maximum number of points in a plot.")) (|setMinPoints3D| (((|Integer|) (|Integer|)) "\\spad{setMinPoints3D(i)} sets the minimum number of points in a plot to i.")) (|minPoints3D| (((|Integer|)) "\\spad{minPoints3D()} returns the minimum number of points in a plot.")) (|tValues| (((|List| (|List| (|DoubleFloat|))) $) "\\spad{tValues(p)} returns a list of lists of the values of the parameter for which a point is computed, one list for each curve in the plot \\spad{p.}")) (|tRange| (((|Segment| (|DoubleFloat|)) $) "\\spad{tRange(p)} returns the range of the parameter in a parametric plot \\spad{p.}")) (|refine| (($ $) "\\spad{refine(x)} is not documented") (($ $ (|Segment| (|DoubleFloat|))) "\\spad{refine(x,r)} is not documented")) (|zoom| (($ $ (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{zoom(x,r,s,t)} is not documented")) (|plot| (($ $ (|Segment| (|DoubleFloat|))) "\\spad{plot(x,r)} is not documented") (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{plot(f1,f2,f3,f4,x,y,z,w)} is not documented") (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{plot(f,g,h,a..b)} plots {/emx = f(t), \\spad{y} = g(t), \\spad{z} = h(t)} as \\spad{t} ranges over {/em[a,b]}.")) (|pointPlot| (($ (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{pointPlot(f,x,y,z,w)} is not documented") (($ (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{pointPlot(f,g,h,a..b)} plots {/emx = f(t), \\spad{y} = g(t), \\spad{z} = h(t)} as \\spad{t} ranges over {/em[a,b]}."))) 
NIL 
NIL 
(|Plot|) 
((|constructor| (NIL "The Plot domain supports plotting of functions defined over a real number system. A real number system is a model for the real numbers and as such may be an approximation. For example floating point numbers and infinite continued fractions. The facilities at this point are limited to 2-dimensional plots or either a single function or a parametric function.")) (|debug| (((|Boolean|) (|Boolean|)) "\\spad{debug(true)} turns debug mode on \\spad{debug(false)} turns debug mode off")) (|numFunEvals| (((|Integer|)) "\\spad{numFunEvals()} returns the number of points computed")) (|setAdaptive| (((|Boolean|) (|Boolean|)) "\\spad{setAdaptive(true)} turns adaptive plotting on \\spad{setAdaptive(false)} turns adaptive plotting off")) (|adaptive?| (((|Boolean|)) "\\spad{adaptive?()} determines whether plotting be done adaptively")) (|setScreenResolution| (((|Integer|) (|Integer|)) "\\spad{setScreenResolution(i)} sets the screen resolution to \\spad{i}")) (|screenResolution| (((|Integer|)) "\\spad{screenResolution()} returns the screen resolution")) (|setMaxPoints| (((|Integer|) (|Integer|)) "\\spad{setMaxPoints(i)} sets the maximum number of points in a plot to \\spad{i}")) (|maxPoints| (((|Integer|)) "\\spad{maxPoints()} returns the maximum number of points in a plot")) (|setMinPoints| (((|Integer|) (|Integer|)) "\\spad{setMinPoints(i)} sets the minimum number of points in a plot to \\spad{i}")) (|minPoints| (((|Integer|)) "\\spad{minPoints()} returns the minimum number of points in a plot")) (|tRange| (((|Segment| (|DoubleFloat|)) $) "\\spad{tRange(p)} returns the range of the parameter in a parametric plot \\spad{p}")) (|refine| (($ $) "\\spad{refine(p)} performs a refinement on the plot \\spad{p}") (($ $ (|Segment| (|DoubleFloat|))) "\\spad{refine(x,r)} is not documented")) (|zoom| (($ $ (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{zoom(x,r,s)} is not documented") (($ $ (|Segment| (|DoubleFloat|))) "\\spad{zoom(x,r)} is not documented")) (|parametric?| (((|Boolean|) $) "\\spad{parametric? determines} whether it is a parametric plot?")) (|plotPolar| (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|))) "\\spad{plotPolar(f)} plots the polar curve \\spad{r = f(theta)} as theta ranges over the interval \\spad{[0,2*\\%pi]}; this is the same as the parametric curve \\spad{x = f(t)*cos(t)}, \\spad{y = f(t)*sin(t)}.") (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{plotPolar(f,a..b)} plots the polar curve \\spad{r = f(theta)} as theta ranges over the interval \\spad{[a,b]}; this is the same as the parametric curve \\spad{x = f(t)*cos(t)}, \\spad{y = f(t)*sin(t)}.")) (|pointPlot| (($ (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{pointPlot(t \\spad{+->} (f(t),g(t)),a..b,c..d,e..f)} plots the parametric curve \\spad{x = f(t)}, \\spad{y = g(t)} as \\spad{t} ranges over the interval \\spad{[a,b]}; x-range of \\spad{[c,d]} and y-range of \\spad{[e,f]} are noted in Plot object.") (($ (|Mapping| (|Point| (|DoubleFloat|)) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{pointPlot(t \\spad{+->} (f(t),g(t)),a..b)} plots the parametric curve \\spad{x = f(t)}, \\spad{y = g(t)} as \\spad{t} ranges over the interval \\spad{[a,b]}.")) (|plot| (($ $ (|Segment| (|DoubleFloat|))) "\\spad{plot(x,r)} is not documented") (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{plot(f,g,a..b,c..d,e..f)} plots the parametric curve \\spad{x = f(t)}, \\spad{y = g(t)} as \\spad{t} ranges over the interval \\spad{[a,b]}; x-range of \\spad{[c,d]} and y-range of \\spad{[e,f]} are noted in Plot object.") (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{plot(f,g,a..b)} plots the parametric curve \\spad{x = f(t)}, \\spad{y = g(t)} as \\spad{t} ranges over the interval \\spad{[a,b]}.") (($ (|List| (|Mapping| (|DoubleFloat|) (|DoubleFloat|))) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{plot([f1,...,fm],a..b,c..d)} plots the functions \\spad{y = f1(x)},..., \\spad{y = fm(x)} on the interval \\spad{a..b}; y-range of \\spad{[c,d]} is noted in Plot object.") (($ (|List| (|Mapping| (|DoubleFloat|) (|DoubleFloat|))) (|Segment| (|DoubleFloat|))) "\\spad{plot([f1,...,fm],a..b)} plots the functions \\spad{y = f1(x)},..., \\spad{y = fm(x)} on the interval \\spad{a..b}.") (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\spad{plot(f,a..b,c..d)} plots the function \\spad{f(x)} on the interval \\spad{[a,b]}; y-range of \\spad{[c,d]} is noted in Plot object.") (($ (|Mapping| (|DoubleFloat|) (|DoubleFloat|)) (|Segment| (|DoubleFloat|))) "\\indented{1}{plot(f,a..b) plots the function \\spad{f(x)}} \\indented{1}{on the interval \\spad{[a,b]}.} \\blankline \\spad{X} fp:=(t:DFLOAT):DFLOAT \\spad{+->} sin(t) \\spad{X} plot(fp,-1.0..1.0)$PLOT"))) 
NIL 
NIL 
(|PlotTools|) 
((|constructor| (NIL "This package exports plotting tools")) (|calcRanges| (((|List| (|Segment| (|DoubleFloat|))) (|List| (|List| (|Point| (|DoubleFloat|))))) "\\spad{calcRanges(l)} \\undocumented"))) 
NIL 
NIL 
(|PolynomialPackageForCurve| K |PolyRing| E |dim| |ProjPt|) 
((|constructor| (NIL "The following is part of the PAFF package")) (|multiplicity| (((|NonNegativeInteger|) |#2| |#5| (|Integer|)) "\\spad{multiplicity returns} the multiplicity of the polynomial at given point.") (((|NonNegativeInteger|) |#2| |#5|) "\\spad{multiplicity returns} the multiplicity of the polynomial at given point.")) (|minimalForm| ((|#2| |#2| |#5| (|Integer|)) "\\spad{minimalForm returns} the minimal form after translation to the origin.") ((|#2| |#2| |#5|) "\\spad{minimalForm returns} the minimal form after translation to the origin.")) (|translateToOrigin| ((|#2| |#2| |#5|) "\\spad{translateToOrigin translate} the polynomial from the given point to the origin") ((|#2| |#2| |#5| (|Integer|)) "\\spad{translateToOrigin translate} the polynomial from the given point to the origin")) (|eval| ((|#1| |#2| |#5|) "\\spad{eval returns} the value at given point.")) (|pointInIdeal?| (((|Boolean|) (|List| |#2|) |#5|) "\\spad{pointInIdeal? test} if the given point is in the algebraic set defined by the given list of polynomials."))) 
NIL 
NIL 
(|FunctionSpaceAssertions| R F) 
((|constructor| (NIL "Attaching assertions to symbols for pattern matching.")) (|multiple| ((|#2| |#2|) "\\spad{multiple(x)} tells the pattern matcher that \\spad{x} should preferably match a multi-term quantity in a sum or product. For matching on lists, multiple(x) tells the pattern matcher that \\spad{x} should match a list instead of an element of a list. Error: if \\spad{x} is not a symbol.")) (|optional| ((|#2| |#2|) "\\spad{optional(x)} tells the pattern matcher that \\spad{x} can match an identity \\spad{(0} in a sum, 1 in a product or exponentiation). Error: if \\spad{x} is not a symbol.")) (|constant| ((|#2| |#2|) "\\spad{constant(x)} tells the pattern matcher that \\spad{x} should match only the symbol \\spad{'x} and no other quantity. Error: if \\spad{x} is not a symbol.")) (|assert| ((|#2| |#2| (|String|)) "\\spad{assert(x, \\spad{s)}} makes the assertion \\spad{s} about \\spad{x.} Error: if \\spad{x} is not a symbol."))) 
NIL 
NIL 
(|PatternMatchAssertions|) 
((|constructor| (NIL "Attaching assertions to symbols for pattern matching.")) (|multiple| (((|Expression| (|Integer|)) (|Symbol|)) "\\spad{multiple(x)} tells the pattern matcher that \\spad{x} should preferably match a multi-term quantity in a sum or product. For matching on lists, multiple(x) tells the pattern matcher that \\spad{x} should match a list instead of an element of a list.")) (|optional| (((|Expression| (|Integer|)) (|Symbol|)) "\\spad{optional(x)} tells the pattern matcher that \\spad{x} can match an identity \\spad{(0} in a sum, 1 in a product or exponentiation)..")) (|constant| (((|Expression| (|Integer|)) (|Symbol|)) "\\spad{constant(x)} tells the pattern matcher that \\spad{x} should match only the symbol \\spad{'x} and no other quantity.")) (|assert| (((|Expression| (|Integer|)) (|Symbol|) (|String|)) "\\spad{assert(x, \\spad{s)}} makes the assertion \\spad{s} about \\spad{x.}"))) 
NIL 
NIL 
(|PatternMatchPushDown| S A B) 
((|constructor| (NIL "This packages provides tools for matching recursively in type towers.")) (|patternMatch| (((|PatternMatchResult| |#1| |#3|) |#2| (|Pattern| |#1|) (|PatternMatchResult| |#1| |#3|)) "\\spad{patternMatch(expr, pat, res)} matches the pattern \\spad{pat} to the expression expr; res contains the variables of \\spad{pat} which are already matched and their matches. Note that this function handles type towers by changing the predicates and calling the matching function provided by \\spad{A}.")) (|fixPredicate| (((|Mapping| (|Boolean|) |#2|) (|Mapping| (|Boolean|) |#3|)) "\\spad{fixPredicate(f)} returns \\spad{g} defined by g(a) = f(a::B)."))) 
NIL 
NIL 
(|PatternMatchFunctionSpace| S R F) 
((|constructor| (NIL "This package provides pattern matching functions on function spaces.")) (|patternMatch| (((|PatternMatchResult| |#1| |#3|) |#3| (|Pattern| |#1|) (|PatternMatchResult| |#1| |#3|)) "\\spad{patternMatch(expr, pat, res)} matches the pattern \\spad{pat} to the expression expr; res contains the variables of \\spad{pat} which are already matched and their matches."))) 
NIL 
NIL 
(|PatternMatchIntegerNumberSystem| I) 
((|constructor| (NIL "This package provides pattern matching functions on integers.")) (|patternMatch| (((|PatternMatchResult| (|Integer|) |#1|) |#1| (|Pattern| (|Integer|)) (|PatternMatchResult| (|Integer|) |#1|)) "\\spad{patternMatch(n, pat, res)} matches the pattern \\spad{pat} to the integer \\spad{n;} res contains the variables of \\spad{pat} which are already matched and their matches."))) 
NIL 
NIL 
(|PatternMatchKernel| S E) 
((|constructor| (NIL "This package provides pattern matching functions on kernels.")) (|patternMatch| (((|PatternMatchResult| |#1| |#2|) (|Kernel| |#2|) (|Pattern| |#1|) (|PatternMatchResult| |#1| |#2|)) "\\spad{patternMatch(f(e1,...,en), pat, res)} matches the pattern \\spad{pat} to \\spad{f(e1,...,en)}; res contains the variables of \\spad{pat} which are already matched and their matches."))) 
NIL 
NIL 
(|PatternMatchListAggregate| S R L) 
((|constructor| (NIL "This package provides pattern matching functions on lists.")) (|patternMatch| (((|PatternMatchListResult| |#1| |#2| |#3|) |#3| (|Pattern| |#1|) (|PatternMatchListResult| |#1| |#2| |#3|)) "\\spad{patternMatch(l, pat, res)} matches the pattern \\spad{pat} to the list \\spad{l;} res contains the variables of \\spad{pat} which are already matched and their matches."))) 
NIL 
NIL 
(|PatternMatchPolynomialCategory| S E V R P) 
((|constructor| (NIL "This package provides pattern matching functions on polynomials.")) (|patternMatch| (((|PatternMatchResult| |#1| |#5|) |#5| (|Pattern| |#1|) (|PatternMatchResult| |#1| |#5|)) "\\spad{patternMatch(p, pat, res)} matches the pattern \\spad{pat} to the polynomial \\spad{p;} res contains the variables of \\spad{pat} which are already matched and their matches.") (((|PatternMatchResult| |#1| |#5|) |#5| (|Pattern| |#1|) (|PatternMatchResult| |#1| |#5|) (|Mapping| (|PatternMatchResult| |#1| |#5|) |#3| (|Pattern| |#1|) (|PatternMatchResult| |#1| |#5|))) "\\spad{patternMatch(p, pat, res, vmatch)} matches the pattern \\spad{pat} to the polynomial \\spad{p.} \\spad{res} contains the variables of \\spad{pat} which are already matched and their matches; vmatch is the matching function to use on the variables."))) 
NIL 
((|HasCategory| |#3| (LIST (QUOTE |PatternMatchable|) (|devaluate| |#1|)))) 
(|FunctionSpaceAttachPredicates| R F D) 
((|constructor| (NIL "Attaching predicates to symbols for pattern matching.")) (|suchThat| ((|#2| |#2| (|List| (|Mapping| (|Boolean|) |#3|))) "\\spad{suchThat(x, [f1, \\spad{f2,} ..., fn])} attaches the predicate \\spad{f1} and \\spad{f2} and \\spad{...} and \\spad{fn} to \\spad{x.} Error: if \\spad{x} is not a symbol.") ((|#2| |#2| (|Mapping| (|Boolean|) |#3|)) "\\spad{suchThat(x, foo)} attaches the predicate foo to \\spad{x;} error if \\spad{x} is not a symbol."))) 
NIL 
NIL 
(|AttachPredicates| D) 
((|constructor| (NIL "Attaching predicates to symbols for pattern matching.")) (|suchThat| (((|Expression| (|Integer|)) (|Symbol|) (|List| (|Mapping| (|Boolean|) |#1|))) "\\spad{suchThat(x, [f1, \\spad{f2,} ..., fn])} attaches the predicate \\spad{f1} and \\spad{f2} and \\spad{...} and \\spad{fn} to \\spad{x.}") (((|Expression| (|Integer|)) (|Symbol|) (|Mapping| (|Boolean|) |#1|)) "\\spad{suchThat(x, foo)} attaches the predicate foo to \\spad{x.}"))) 
NIL 
NIL 
(|PatternMatchQuotientFieldCategory| S R Q) 
((|constructor| (NIL "This package provides pattern matching functions on quotients.")) (|patternMatch| (((|PatternMatchResult| |#1| |#3|) |#3| (|Pattern| |#1|) (|PatternMatchResult| |#1| |#3|)) "\\spad{patternMatch(a/b, pat, res)} matches the pattern \\spad{pat} to the quotient a/b; res contains the variables of \\spad{pat} which are already matched and their matches."))) 
NIL 
NIL 
(|PatternMatchSymbol| S) 
((|constructor| (NIL "This package provides pattern matching functions on symbols.")) (|patternMatch| (((|PatternMatchResult| |#1| (|Symbol|)) (|Symbol|) (|Pattern| |#1|) (|PatternMatchResult| |#1| (|Symbol|))) "\\spad{patternMatch(expr, pat, res)} matches the pattern \\spad{pat} to the expression expr; res contains the variables of \\spad{pat} which are already matched and their matches (necessary for recursion)."))) 
NIL 
NIL 
(|PatternMatchTools| S R P) 
((|constructor| (NIL "This package provides tools for the pattern matcher.")) (|patternMatchTimes| (((|PatternMatchResult| |#1| |#3|) (|List| |#3|) (|List| (|Pattern| |#1|)) (|PatternMatchResult| |#1| |#3|) (|Mapping| (|PatternMatchResult| |#1| |#3|) |#3| (|Pattern| |#1|) (|PatternMatchResult| |#1| |#3|))) "\\spad{patternMatchTimes(lsubj, lpat, res, match)} matches the product of patterns \\spad{reduce(*,lpat)} to the product of subjects \\spad{reduce(*,lsubj)}; \\spad{r} contains the previous matches and match is a pattern-matching function on \\spad{P.}")) (|patternMatch| (((|PatternMatchResult| |#1| |#3|) (|List| |#3|) (|List| (|Pattern| |#1|)) (|Mapping| |#3| (|List| |#3|)) (|PatternMatchResult| |#1| |#3|) (|Mapping| (|PatternMatchResult| |#1| |#3|) |#3| (|Pattern| |#1|) (|PatternMatchResult| |#1| |#3|))) "\\spad{patternMatch(lsubj, lpat, op, res, match)} matches the list of patterns \\spad{lpat} to the list of subjects lsubj, allowing for commutativity; \\spad{op} is the operator such that op(lpat) should match op(lsubj) at the end, \\spad{r} contains the previous matches, and match is a pattern-matching function on \\spad{P.}"))) 
NIL 
NIL 
(|PolynomialNumberTheoryFunctions|) 
((|constructor| (NIL "This package provides various polynomial number theoretic functions over the integers.")) (|legendre| (((|SparseUnivariatePolynomial| (|Fraction| (|Integer|))) (|Integer|)) "\\spad{legendre(n)} returns the \\spad{n}th Legendre polynomial \\spad{P[n](x)}. Note that Legendre polynomials, denoted \\spad{P[n](x)}, are computed from the two term recurrence. The generating function is: \\spad{1/sqrt(1-2*t*x+t**2) = sum(P[n](x)*t**n, n=0..infinity)}.")) (|laguerre| (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|)) "\\spad{laguerre(n)} returns the \\spad{n}th Laguerre polynomial \\spad{L[n](x)}. Note that Laguerre polynomials, denoted \\spad{L[n](x)}, are computed from the two term recurrence. The generating function is: \\spad{exp(x*t/(t-1))/(1-t) = sum(L[n](x)*t**n/n!, n=0..infinity)}.")) (|hermite| (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|)) "\\spad{hermite(n)} returns the \\spad{n}th Hermite polynomial \\spad{H[n](x)}. Note that Hermite polynomials, denoted \\spad{H[n](x)}, are computed from the two term recurrence. The generating function is: \\spad{exp(2*t*x-t**2) = sum(H[n](x)*t**n/n!, n=0..infinity)}.")) (|fixedDivisor| (((|Integer|) (|SparseUnivariatePolynomial| (|Integer|))) "\\spad{fixedDivisor(a)} for \\spad{a(x)} in \\spad{Z[x]} is the largest integer \\spad{f} such that \\spad{f} divides \\spad{a(x=k)} for all integers \\spad{k.} Note that fixed divisor of \\spad{a} is \\spad{reduce(gcd,[a(x=k) for \\spad{k} in 0..degree(a)])}.")) (|euler| (((|SparseUnivariatePolynomial| (|Fraction| (|Integer|))) (|Integer|)) "\\spad{euler(n)} returns the \\spad{n}th Euler polynomial \\spad{E[n](x)}. Note that Euler polynomials denoted \\spad{E(n,x)} computed by solving the differential equation \\spad{differentiate(E(n,x),x) = \\spad{n} E(n-1,x)} where \\spad{E(0,x) = 1} and initial condition comes from \\spad{E(n) = 2**n E(n,1/2)}.")) (|cyclotomic| (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|)) "\\spad{cyclotomic(n)} returns the \\spad{n}th cyclotomic polynomial \\spad{phi[n](x)}. Note that \\spad{phi[n](x)} is the factor of \\spad{x**n - 1} whose roots are the primitive \\spad{n}th roots of unity.")) (|chebyshevU| (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|)) "\\spad{chebyshevU(n)} returns the \\spad{n}th Chebyshev polynomial \\spad{U[n](x)}. Note that Chebyshev polynomials of the second kind, denoted \\spad{U[n](x)}, computed from the two term recurrence. The generating function \\spad{1/(1-2*t*x+t**2) = sum(T[n](x)*t**n, n=0..infinity)}.")) (|chebyshevT| (((|SparseUnivariatePolynomial| (|Integer|)) (|Integer|)) "\\spad{chebyshevT(n)} returns the \\spad{n}th Chebyshev polynomial \\spad{T[n](x)}. Note that Chebyshev polynomials of the first kind, denoted \\spad{T[n](x)}, computed from the two term recurrence. The generating function \\spad{(1-t*x)/(1-2*t*x+t**2) = sum(T[n](x)*t**n, n=0..infinity)}.")) (|bernoulli| (((|SparseUnivariatePolynomial| (|Fraction| (|Integer|))) (|Integer|)) "\\spad{bernoulli(n)} returns the \\spad{n}th Bernoulli polynomial \\spad{B[n](x)}. Bernoulli polynomials denoted \\spad{B(n,x)} computed by solving the differential equation \\spad{differentiate(B(n,x),x) = \\spad{n} B(n-1,x)} where \\spad{B(0,x) = 1} and initial condition comes from \\spad{B(n) = B(n,0)}."))) 
NIL 
NIL 
(|Point| R) 
((|constructor| (NIL "This domain implements points in coordinate space"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#1| (QUOTE (|AbelianMonoid|))) (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#1| (QUOTE (|Monoid|))) (|HasCategory| |#1| (QUOTE (|Ring|))) (AND (|HasCategory| |#1| (QUOTE (|RadicalCategory|))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|PolToPol| |lv| R) 
((|constructor| (NIL "Package with the conversion functions among different kind of polynomials")) (|pToDmp| (((|DistributedMultivariatePolynomial| |#1| |#2|) (|Polynomial| |#2|)) "\\spad{pToDmp(p)} converts \\spad{p} from a \\spadtype{POLY} to a \\spadtype{DMP}.")) (|dmpToP| (((|Polynomial| |#2|) (|DistributedMultivariatePolynomial| |#1| |#2|)) "\\spad{dmpToP(p)} converts \\spad{p} from a \\spadtype{DMP} to a \\spadtype{POLY}.")) (|hdmpToP| (((|Polynomial| |#2|) (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)) "\\spad{hdmpToP(p)} converts \\spad{p} from a \\spadtype{HDMP} to a \\spadtype{POLY}.")) (|pToHdmp| (((|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|) (|Polynomial| |#2|)) "\\spad{pToHdmp(p)} converts \\spad{p} from a \\spadtype{POLY} to a \\spadtype{HDMP}.")) (|hdmpToDmp| (((|DistributedMultivariatePolynomial| |#1| |#2|) (|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|)) "\\spad{hdmpToDmp(p)} converts \\spad{p} from a \\spadtype{HDMP} to a \\spadtype{DMP}.")) (|dmpToHdmp| (((|HomogeneousDistributedMultivariatePolynomial| |#1| |#2|) (|DistributedMultivariatePolynomial| |#1| |#2|)) "\\spad{dmpToHdmp(p)} converts \\spad{p} from a \\spadtype{DMP} to a \\spadtype{HDMP}."))) 
NIL 
NIL 
(|RealPolynomialUtilitiesPackage| |TheField| |ThePols|) 
((|constructor| (NIL "\\axiomType{RealPolynomialUtilitiesPackage} provides common functions used by interval coding.")) (|lazyVariations| (((|NonNegativeInteger|) (|List| |#1|) (|Integer|) (|Integer|)) "\\axiom{lazyVariations(l,s1,sn)} is the number of sign variations in the list of non null numbers [s1::l]@sn.")) (|sturmVariationsOf| (((|NonNegativeInteger|) (|List| |#1|)) "\\axiom{sturmVariationsOf(l)} is the number of sign variations in the list of numbers \\spad{l,} note that the first term counts as a sign")) (|boundOfCauchy| ((|#1| |#2|) "\\axiom{boundOfCauchy(p)} bounds the roots of \\spad{p}")) (|sturmSequence| (((|List| |#2|) |#2|) "\\axiom{sturmSequence(p) = sylvesterSequence(p,p')}")) (|sylvesterSequence| (((|List| |#2|) |#2| |#2|) "\\axiom{sylvesterSequence(p,q)} is the negated remainder sequence of \\spad{p} and \\spad{q} divided by the last computed term"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|OrderedRing|)))) 
(|PolynomialFunctions2| R S) 
((|constructor| (NIL "This package takes a mapping between coefficient rings, and lifts it to a mapping between polynomials over those rings.")) (|map| (((|Polynomial| |#2|) (|Mapping| |#2| |#1|) (|Polynomial| |#1|)) "\\spad{map(f, \\spad{p)}} produces a new polynomial as a result of applying the function \\spad{f} to every coefficient of the polynomial \\spad{p.}"))) 
NIL 
NIL 
(|PolynomialToUnivariatePolynomial| |x| R) 
((|constructor| (NIL "This package is primarily to help the interpreter do coercions. It allows you to view a polynomial as a univariate polynomial in one of its variables with coefficients which are again a polynomial in all the other variables.")) (|univariate| (((|UnivariatePolynomial| |#1| (|Polynomial| |#2|)) (|Polynomial| |#2|) (|Variable| |#1|)) "\\spad{univariate(p, \\spad{x)}} converts the polynomial \\spad{p} to a one of type \\spad{UnivariatePolynomial(x,Polynomial(R))}, ie. as a member of \\spad{R[...][x]}."))) 
NIL 
NIL 
(|PolynomialCategory&| S R E |VarSet|) 
((|constructor| (NIL "The category for general multi-variate polynomials over a ring \\spad{R,} in variables from VarSet, with exponents from the \\spadtype{OrderedAbelianMonoidSup}.")) (|canonicalUnitNormal| ((|attribute|) "we can choose a unique representative for each associate class. This normalization is chosen to be normalization of leading coefficient (by default).")) (|squareFreePart| (($ $) "\\spad{squareFreePart(p)} returns product of all the irreducible factors of polynomial \\spad{p} each taken with multiplicity one.")) (|squareFree| (((|Factored| $) $) "\\spad{squareFree(p)} returns the square free factorization of the polynomial \\spad{p.}")) (|primitivePart| (($ $ |#4|) "\\spad{primitivePart(p,v)} returns the unitCanonical associate of the polynomial \\spad{p} with its content with respect to the variable \\spad{v} divided out.") (($ $) "\\spad{primitivePart(p)} returns the unitCanonical associate of the polynomial \\spad{p} with its content divided out.")) (|content| (($ $ |#4|) "\\spad{content(p,v)} is the \\spad{gcd} of the coefficients of the polynomial \\spad{p} when \\spad{p} is viewed as a univariate polynomial with respect to the variable \\spad{v.} Thus, for polynomial 7*x**2*y + 14*x*y**2, the \\spad{gcd} of the coefficients with respect to \\spad{x} is 7*y.")) (|discriminant| (($ $ |#4|) "\\spad{discriminant(p,v)} returns the disriminant of the polynomial \\spad{p} with respect to the variable \\spad{v.}")) (|resultant| (($ $ $ |#4|) "\\spad{resultant(p,q,v)} returns the resultant of the polynomials \\spad{p} and \\spad{q} with respect to the variable \\spad{v.}")) (|primitiveMonomials| (((|List| $) $) "\\spad{primitiveMonomials(p)} gives the list of monomials of the polynomial \\spad{p} with their coefficients removed. Note that \\spad{primitiveMonomials(sum(a_(i) X^(i))) = [X^(1),...,X^(n)]}.")) (|variables| (((|List| |#4|) $) "\\spad{variables(p)} returns the list of those variables actually appearing in the polynomial \\spad{p.}")) (|totalDegree| (((|NonNegativeInteger|) $ (|List| |#4|)) "\\spad{totalDegree(p, lv)} returns the maximum sum (over all monomials of polynomial \\spad{p)} of the variables in the list \\spad{lv.}") (((|NonNegativeInteger|) $) "\\spad{totalDegree(p)} returns the largest sum over all monomials of all exponents of a monomial.")) (|isExpt| (((|Union| (|Record| (|:| |var| |#4|) (|:| |exponent| (|NonNegativeInteger|))) "failed") $) "\\spad{isExpt(p)} returns \\spad{[x, \\spad{n]}} if polynomial \\spad{p} has the form \\spad{x**n} and \\spad{n > 0}.")) (|isTimes| (((|Union| (|List| $) "failed") $) "\\spad{isTimes(p)} returns \\spad{[a1,...,an]} if polynomial \\spad{p = \\spad{a1} \\spad{...} an} and \\spad{n \\spad{>=} 2}, and, for each i, \\spad{ai} is either a nontrivial constant in \\spad{R} or else of the form \\spad{x**e}, where \\spad{e > 0} is an integer and \\spad{x} in a member of VarSet.")) (|isPlus| (((|Union| (|List| $) "failed") $) "\\spad{isPlus(p)} returns \\spad{[m1,...,mn]} if polynomial \\spad{p = \\spad{m1} + \\spad{...} + \\spad{mn}} and \\spad{n \\spad{>=} 2} and each \\spad{mi} is a nonzero monomial.")) (|multivariate| (($ (|SparseUnivariatePolynomial| $) |#4|) "\\spad{multivariate(sup,v)} converts an anonymous univariable polynomial \\spad{sup} to a polynomial in the variable \\spad{v.}") (($ (|SparseUnivariatePolynomial| |#2|) |#4|) "\\spad{multivariate(sup,v)} converts an anonymous univariable polynomial \\spad{sup} to a polynomial in the variable \\spad{v.}")) (|monomial| (($ $ (|List| |#4|) (|List| (|NonNegativeInteger|))) "\\spad{monomial(a,[v1..vn],[e1..en])} returns \\spad{a*prod(vi**ei)}.") (($ $ |#4| (|NonNegativeInteger|)) "\\spad{monomial(a,x,n)} creates the monomial \\spad{a*x**n} where \\spad{a} is a polynomial, \\spad{x} is a variable and \\spad{n} is a nonnegative integer.")) (|monicDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $ |#4|) "\\spad{monicDivide(a,b,v)} divides the polynomial a by the polynomial \\spad{b,} with each viewed as a univariate polynomial in \\spad{v} returning both the quotient and remainder. Error: if \\spad{b} is not monic with respect to \\spad{v.}")) (|minimumDegree| (((|List| (|NonNegativeInteger|)) $ (|List| |#4|)) "\\spad{minimumDegree(p, lv)} gives the list of minimum degrees of the polynomial \\spad{p} with respect to each of the variables in the list \\spad{lv}") (((|NonNegativeInteger|) $ |#4|) "\\spad{minimumDegree(p,v)} gives the minimum degree of polynomial \\spad{p} with respect to \\spad{v,} \\spadignore{i.e.} viewed a univariate polynomial in \\spad{v}")) (|mainVariable| (((|Union| |#4| "failed") $) "\\spad{mainVariable(p)} returns the biggest variable which actually occurs in the polynomial \\spad{p,} or \"failed\" if no variables are present. fails precisely if polynomial satisfies ground?")) (|univariate| (((|SparseUnivariatePolynomial| |#2|) $) "\\spad{univariate(p)} converts the multivariate polynomial \\spad{p,} which should actually involve only one variable, into a univariate polynomial in that variable, whose coefficients are in the ground ring. Error: if polynomial is genuinely multivariate") (((|SparseUnivariatePolynomial| $) $ |#4|) "\\spad{univariate(p,v)} converts the multivariate polynomial \\spad{p} into a univariate polynomial in \\spad{v,} whose coefficients are still multivariate polynomials (in all the other variables).")) (|monomials| (((|List| $) $) "\\spad{monomials(p)} returns the list of non-zero monomials of polynomial \\spad{p,} \\spadignore{i.e.} \\spad{monomials(sum(a_(i) X^(i))) = [a_(1) X^(1),...,a_(n) X^(n)]}.")) (|coefficient| (($ $ (|List| |#4|) (|List| (|NonNegativeInteger|))) "\\spad{coefficient(p, \\spad{lv,} ln)} views the polynomial \\spad{p} as a polynomial in the variables of \\spad{lv} and returns the coefficient of the term \\spad{lv**ln}, \\spadignore{i.e.} \\spad{prod(lv_i \\spad{**} ln_i)}.") (($ $ |#4| (|NonNegativeInteger|)) "\\spad{coefficient(p,v,n)} views the polynomial \\spad{p} as a univariate polynomial in \\spad{v} and returns the coefficient of the \\spad{v**n} term.")) (|degree| (((|List| (|NonNegativeInteger|)) $ (|List| |#4|)) "\\spad{degree(p,lv)} gives the list of degrees of polynomial \\spad{p} with respect to each of the variables in the list \\spad{lv.}") (((|NonNegativeInteger|) $ |#4|) "\\spad{degree(p,v)} gives the degree of polynomial \\spad{p} with respect to the variable \\spad{v.}"))) 
NIL 
((|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasAttribute| |#2| (QUOTE |canonicalUnitNormal|)) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#4| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#4| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#4| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#4| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#4| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (QUOTE (|OrderedSet|)))) 
(|PolynomialCategory| R E |VarSet|) 
((|constructor| (NIL "The category for general multi-variate polynomials over a ring \\spad{R,} in variables from VarSet, with exponents from the \\spadtype{OrderedAbelianMonoidSup}.")) (|canonicalUnitNormal| ((|attribute|) "we can choose a unique representative for each associate class. This normalization is chosen to be normalization of leading coefficient (by default).")) (|squareFreePart| (($ $) "\\spad{squareFreePart(p)} returns product of all the irreducible factors of polynomial \\spad{p} each taken with multiplicity one.")) (|squareFree| (((|Factored| $) $) "\\spad{squareFree(p)} returns the square free factorization of the polynomial \\spad{p.}")) (|primitivePart| (($ $ |#3|) "\\spad{primitivePart(p,v)} returns the unitCanonical associate of the polynomial \\spad{p} with its content with respect to the variable \\spad{v} divided out.") (($ $) "\\spad{primitivePart(p)} returns the unitCanonical associate of the polynomial \\spad{p} with its content divided out.")) (|content| (($ $ |#3|) "\\spad{content(p,v)} is the \\spad{gcd} of the coefficients of the polynomial \\spad{p} when \\spad{p} is viewed as a univariate polynomial with respect to the variable \\spad{v.} Thus, for polynomial 7*x**2*y + 14*x*y**2, the \\spad{gcd} of the coefficients with respect to \\spad{x} is 7*y.")) (|discriminant| (($ $ |#3|) "\\spad{discriminant(p,v)} returns the disriminant of the polynomial \\spad{p} with respect to the variable \\spad{v.}")) (|resultant| (($ $ $ |#3|) "\\spad{resultant(p,q,v)} returns the resultant of the polynomials \\spad{p} and \\spad{q} with respect to the variable \\spad{v.}")) (|primitiveMonomials| (((|List| $) $) "\\spad{primitiveMonomials(p)} gives the list of monomials of the polynomial \\spad{p} with their coefficients removed. Note that \\spad{primitiveMonomials(sum(a_(i) X^(i))) = [X^(1),...,X^(n)]}.")) (|variables| (((|List| |#3|) $) "\\spad{variables(p)} returns the list of those variables actually appearing in the polynomial \\spad{p.}")) (|totalDegree| (((|NonNegativeInteger|) $ (|List| |#3|)) "\\spad{totalDegree(p, lv)} returns the maximum sum (over all monomials of polynomial \\spad{p)} of the variables in the list \\spad{lv.}") (((|NonNegativeInteger|) $) "\\spad{totalDegree(p)} returns the largest sum over all monomials of all exponents of a monomial.")) (|isExpt| (((|Union| (|Record| (|:| |var| |#3|) (|:| |exponent| (|NonNegativeInteger|))) "failed") $) "\\spad{isExpt(p)} returns \\spad{[x, \\spad{n]}} if polynomial \\spad{p} has the form \\spad{x**n} and \\spad{n > 0}.")) (|isTimes| (((|Union| (|List| $) "failed") $) "\\spad{isTimes(p)} returns \\spad{[a1,...,an]} if polynomial \\spad{p = \\spad{a1} \\spad{...} an} and \\spad{n \\spad{>=} 2}, and, for each i, \\spad{ai} is either a nontrivial constant in \\spad{R} or else of the form \\spad{x**e}, where \\spad{e > 0} is an integer and \\spad{x} in a member of VarSet.")) (|isPlus| (((|Union| (|List| $) "failed") $) "\\spad{isPlus(p)} returns \\spad{[m1,...,mn]} if polynomial \\spad{p = \\spad{m1} + \\spad{...} + \\spad{mn}} and \\spad{n \\spad{>=} 2} and each \\spad{mi} is a nonzero monomial.")) (|multivariate| (($ (|SparseUnivariatePolynomial| $) |#3|) "\\spad{multivariate(sup,v)} converts an anonymous univariable polynomial \\spad{sup} to a polynomial in the variable \\spad{v.}") (($ (|SparseUnivariatePolynomial| |#1|) |#3|) "\\spad{multivariate(sup,v)} converts an anonymous univariable polynomial \\spad{sup} to a polynomial in the variable \\spad{v.}")) (|monomial| (($ $ (|List| |#3|) (|List| (|NonNegativeInteger|))) "\\spad{monomial(a,[v1..vn],[e1..en])} returns \\spad{a*prod(vi**ei)}.") (($ $ |#3| (|NonNegativeInteger|)) "\\spad{monomial(a,x,n)} creates the monomial \\spad{a*x**n} where \\spad{a} is a polynomial, \\spad{x} is a variable and \\spad{n} is a nonnegative integer.")) (|monicDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $ |#3|) "\\spad{monicDivide(a,b,v)} divides the polynomial a by the polynomial \\spad{b,} with each viewed as a univariate polynomial in \\spad{v} returning both the quotient and remainder. Error: if \\spad{b} is not monic with respect to \\spad{v.}")) (|minimumDegree| (((|List| (|NonNegativeInteger|)) $ (|List| |#3|)) "\\spad{minimumDegree(p, lv)} gives the list of minimum degrees of the polynomial \\spad{p} with respect to each of the variables in the list \\spad{lv}") (((|NonNegativeInteger|) $ |#3|) "\\spad{minimumDegree(p,v)} gives the minimum degree of polynomial \\spad{p} with respect to \\spad{v,} \\spadignore{i.e.} viewed a univariate polynomial in \\spad{v}")) (|mainVariable| (((|Union| |#3| "failed") $) "\\spad{mainVariable(p)} returns the biggest variable which actually occurs in the polynomial \\spad{p,} or \"failed\" if no variables are present. fails precisely if polynomial satisfies ground?")) (|univariate| (((|SparseUnivariatePolynomial| |#1|) $) "\\spad{univariate(p)} converts the multivariate polynomial \\spad{p,} which should actually involve only one variable, into a univariate polynomial in that variable, whose coefficients are in the ground ring. Error: if polynomial is genuinely multivariate") (((|SparseUnivariatePolynomial| $) $ |#3|) "\\spad{univariate(p,v)} converts the multivariate polynomial \\spad{p} into a univariate polynomial in \\spad{v,} whose coefficients are still multivariate polynomials (in all the other variables).")) (|monomials| (((|List| $) $) "\\spad{monomials(p)} returns the list of non-zero monomials of polynomial \\spad{p,} \\spadignore{i.e.} \\spad{monomials(sum(a_(i) X^(i))) = [a_(1) X^(1),...,a_(n) X^(n)]}.")) (|coefficient| (($ $ (|List| |#3|) (|List| (|NonNegativeInteger|))) "\\spad{coefficient(p, \\spad{lv,} ln)} views the polynomial \\spad{p} as a polynomial in the variables of \\spad{lv} and returns the coefficient of the term \\spad{lv**ln}, \\spadignore{i.e.} \\spad{prod(lv_i \\spad{**} ln_i)}.") (($ $ |#3| (|NonNegativeInteger|)) "\\spad{coefficient(p,v,n)} views the polynomial \\spad{p} as a univariate polynomial in \\spad{v} and returns the coefficient of the \\spad{v**n} term.")) (|degree| (((|List| (|NonNegativeInteger|)) $ (|List| |#3|)) "\\spad{degree(p,lv)} gives the list of degrees of polynomial \\spad{p} with respect to each of the variables in the list \\spad{lv.}") (((|NonNegativeInteger|) $ |#3|) "\\spad{degree(p,v)} gives the degree of polynomial \\spad{p} with respect to the variable \\spad{v.}"))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|PolynomialCategoryQuotientFunctions| E V R P F) 
((|constructor| (NIL "Manipulations on polynomial quotients This package transforms multivariate polynomials or fractions into univariate polynomials or fractions, and back.")) (|isPower| (((|Union| (|Record| (|:| |val| |#5|) (|:| |exponent| (|Integer|))) "failed") |#5|) "\\spad{isPower(p)} returns \\spad{[x, \\spad{n]}} if \\spad{p = x**n} and \\spad{n \\spad{<>} 0}, \"failed\" otherwise.")) (|isExpt| (((|Union| (|Record| (|:| |var| |#2|) (|:| |exponent| (|Integer|))) "failed") |#5|) "\\spad{isExpt(p)} returns \\spad{[x, \\spad{n]}} if \\spad{p = x**n} and \\spad{n \\spad{<>} 0}, \"failed\" otherwise.")) (|isTimes| (((|Union| (|List| |#5|) "failed") |#5|) "\\spad{isTimes(p)} returns \\spad{[a1,...,an]} if \\spad{p = \\spad{a1} \\spad{...} an} and \\spad{n > 1}, \"failed\" otherwise.")) (|isPlus| (((|Union| (|List| |#5|) "failed") |#5|) "\\spad{isPlus(p)} returns [m1,...,mn] if \\spad{p = \\spad{m1} + \\spad{...} + \\spad{mn}} and \\spad{n > 1}, \"failed\" otherwise.")) (|multivariate| ((|#5| (|Fraction| (|SparseUnivariatePolynomial| |#5|)) |#2|) "\\spad{multivariate(f, \\spad{v)}} applies both the numerator and denominator of \\spad{f} to \\spad{v.}")) (|univariate| (((|SparseUnivariatePolynomial| |#5|) |#5| |#2| (|SparseUnivariatePolynomial| |#5|)) "\\spad{univariate(f, \\spad{x,} \\spad{p)}} returns \\spad{f} viewed as a univariate polynomial in \\spad{x,} using the side-condition \\spad{p(x) = 0}.") (((|Fraction| (|SparseUnivariatePolynomial| |#5|)) |#5| |#2|) "\\spad{univariate(f, \\spad{v)}} returns \\spad{f} viewed as a univariate rational function in \\spad{v.}")) (|mainVariable| (((|Union| |#2| "failed") |#5|) "\\spad{mainVariable(f)} returns the highest variable appearing in the numerator or the denominator of \\spad{f,} \"failed\" if \\spad{f} has no variables.")) (|variables| (((|List| |#2|) |#5|) "\\spad{variables(f)} returns the list of variables appearing in the numerator or the denominator of \\spad{f.}"))) 
NIL 
NIL 
(|PolynomialCategoryLifting| E |Vars| R P S) 
((|constructor| (NIL "This package provides a very general map function, which given a set \\spad{S} and polynomials over \\spad{R} with maps from the variables into \\spad{S} and the coefficients into \\spad{S,} maps polynomials into \\spad{S.} \\spad{S} is assumed to support \\spad{+}, \\spad{*} and \\spad{**}.")) (|map| ((|#5| (|Mapping| |#5| |#2|) (|Mapping| |#5| |#3|) |#4|) "\\spad{map(varmap, coefmap, \\spad{p)}} takes a varmap, a mapping from the variables of polynomial \\spad{p} into \\spad{S,} coefmap, a mapping from coefficients of \\spad{p} into \\spad{S,} and \\spad{p,} and produces a member of \\spad{S} using the corresponding arithmetic. in \\spad{S}"))) 
NIL 
NIL 
(|Polynomial| R) 
((|constructor| (NIL "This type is the basic representation of sparse recursive multivariate polynomials whose variables are arbitrary symbols. The ordering is alphabetic determined by the Symbol type. The coefficient ring may be non commutative, but the variables are assumed to commute.")) (|integrate| (($ $ (|Symbol|)) "\\spad{integrate(p,x)} computes the integral of \\spad{p*dx}, \\spadignore{i.e.} integrates the polynomial \\spad{p} with respect to the variable \\spad{x.}"))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| (|Symbol|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| (|Symbol|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| (|Symbol|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| (|Symbol|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| (|Symbol|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))))) 
(|PolynomialRoots| E V R P F) 
((|constructor| (NIL "Computes \\spad{n}-th roots of quotients of multivariate polynomials")) (|nthr| (((|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |coef| |#4|) (|:| |radicand| (|List| |#4|))) |#4| (|NonNegativeInteger|)) "\\spad{nthr(p,n)} should be local but conditional")) (|froot| (((|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |coef| |#5|) (|:| |radicand| |#5|)) |#5| (|NonNegativeInteger|)) "\\spad{froot(f, \\spad{n)}} returns \\spad{[m,c,r]} such that \\spad{f**(1/n) = \\spad{c} * r**(1/m)}.")) (|qroot| (((|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |coef| |#5|) (|:| |radicand| |#5|)) (|Fraction| (|Integer|)) (|NonNegativeInteger|)) "\\spad{qroot(f, \\spad{n)}} returns \\spad{[m,c,r]} such that \\spad{f**(1/n) = \\spad{c} * r**(1/m)}.")) (|rroot| (((|Record| (|:| |exponent| (|NonNegativeInteger|)) (|:| |coef| |#5|) (|:| |radicand| |#5|)) |#3| (|NonNegativeInteger|)) "\\spad{rroot(f, \\spad{n)}} returns \\spad{[m,c,r]} such that \\spad{f**(1/n) = \\spad{c} * r**(1/m)}.")) (|coerce| (($ |#4|) "\\spad{coerce(p)} \\undocumented")) (|denom| ((|#4| $) "\\spad{denom(x)} \\undocumented")) (|numer| ((|#4| $) "\\spad{numer(x)} \\undocumented"))) 
NIL 
((|HasCategory| |#3| (QUOTE (|GcdDomain|)))) 
(|U32VectorPolynomialOperations|) 
((|constructor| (NIL "This is a low-level package which implements operations on vectors treated as univariate modular polynomials. Most operations takes modulus as parameter. Modulus is machine sized prime which should be small enough to avoid overflow in intermediate calculations.")) (|resultant| (((|Integer|) (|U32Vector|) (|U32Vector|) (|Integer|)) "\\spad{resultant(v1, \\spad{v2,} \\spad{p)}} computes resultant of \\spad{v1} and \\spad{v2} modulo \\spad{p.}")) (|extendedgcd| (((|List| (|U32Vector|)) (|U32Vector|) (|U32Vector|) (|Integer|)) "extended_gcd(v1, \\spad{v2,} \\spad{p)} gives \\spad{[g,} \\spad{c1,} \\spad{c2]} such that \\spad{g} is \\spad{gcd(v1, \\spad{v2,} p)}, \\spad{g = \\spad{c1*v1} + c2*v2} and degree(c1) < max(degree(v2) - degree(g), 0) and degree(c2) < max(degree(v1) - degree(g), 1)")) (|degree| (((|Integer|) (|U32Vector|)) "\\spad{degree(v)} is degree of \\spad{v} treated as polynomial")) (|lcm| (((|U32Vector|) (|PrimitiveArray| (|U32Vector|)) (|Integer|) (|Integer|) (|Integer|)) "\\spad{lcm(a, lo, hi, \\spad{p)}} computes \\spad{lcm} of elements a(lo), a(lo+1), ..., a(hi).")) (|gcd| (((|U32Vector|) (|PrimitiveArray| (|U32Vector|)) (|Integer|) (|Integer|) (|Integer|)) "\\spad{gcd(a, lo, hi, \\spad{p)}} computes \\spad{gcd} of elements a(lo), a(lo+1), ..., a(hi).") (((|U32Vector|) (|U32Vector|) (|U32Vector|) (|Integer|)) "\\spad{gcd(v1, \\spad{v2,} \\spad{p)}} computes monic \\spad{gcd} of \\spad{v1} and \\spad{v2} modulo \\spad{p.}")) (|tomodpa| (((|U32Vector|) (|SparseUnivariatePolynomial| (|Integer|)) (|Integer|)) "to_mod_pa(s, \\spad{p)} reduces coefficients of polynomial \\spad{s} modulo prime \\spad{p} and converts the result to vector")) (|vectorcombination| (((|Void|) (|U32Vector|) (|Integer|) (|U32Vector|) (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "vector_combination(v1, \\spad{c1,} \\spad{v2,} \\spad{c2,} \\spad{n,} delta, \\spad{p)} replaces first \\spad{n} + 1 entires of \\spad{v1} by corresponding entries of \\spad{c1*v1+c2*x^delta*v2} mod \\spad{p.}")) (|remainder!| (((|Void|) (|U32Vector|) (|U32Vector|) (|Integer|)) "Polynomial remainder")) (|divide!| (((|Void|) (|U32Vector|) (|U32Vector|) (|U32Vector|) (|Integer|)) "Polynomial division.")) (|differentiate| (((|U32Vector|) (|U32Vector|) (|NonNegativeInteger|) (|Integer|)) "Polynomial differentiation.") (((|U32Vector|) (|U32Vector|) (|Integer|)) "Polynomial differentiation.")) (|pow| (((|U32Vector|) (|U32Vector|) (|PositiveInteger|) (|NonNegativeInteger|) (|Integer|)) "\\spad{pow(u, \\spad{n,} \\spad{d,} \\spad{p)}} returns u^n truncated after degree \\spad{d,} except if n=1, in which case \\spad{u} itself is returned")) (|truncatedmuladd| (((|Void|) (|U32Vector|) (|U32Vector|) (|U32Vector|) (|Integer|) (|Integer|)) "truncated_mul_add(x, \\spad{y,} \\spad{z,} \\spad{d,} \\spad{p)} adds to \\spad{z} the produce x*y truncated after degree \\spad{d}")) (|truncatedmultiplication| (((|U32Vector|) (|U32Vector|) (|U32Vector|) (|Integer|) (|Integer|)) "truncated_multiplication(x, \\spad{y,} \\spad{d,} \\spad{p)} computes x*y truncated after degree \\spad{d}")) (|mul| (((|U32Vector|) (|U32Vector|) (|U32Vector|) (|Integer|)) "Polynomial multiplication.")) (|mulbyscalar| (((|Void|) (|U32Vector|) (|Integer|) (|Integer|) (|Integer|)) "mul_by_scalar(v, deg, \\spad{c,} \\spad{p)} treats \\spad{v} as coefficients of polynomial of degree deg and multiplies in place this polynomial by scalar \\spad{c}")) (|mulbybinomial| (((|Void|) (|U32Vector|) (|Integer|) (|Integer|) (|Integer|)) "mul_by_binomial(v, deg, \\spad{pt,} \\spad{p)} treats \\spad{v} as coefficients of polynomial of degree deg and multiplies in place this polynomial by binomial \\spad{(x} + pt). Highest coefficient of product is ignored.") (((|Void|) (|U32Vector|) (|Integer|) (|Integer|)) "mul_by_binomial(v, \\spad{pt,} \\spad{p)} treats \\spad{v} a polynomial and multiplies in place this polynomial by binomial \\spad{(x} + pt). Highest coefficient of product is ignored.")) (|vectoraddmul| (((|Void|) (|U32Vector|) (|U32Vector|) (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "vector_add_mul(v1, \\spad{v2,} \\spad{m,} \\spad{n,} \\spad{c,} \\spad{p)} sets v1(m), ..., v1(n) to corresponding extries in \\spad{v1} + \\spad{c*v2} modulo \\spad{p.}")) (|evalat| (((|Integer|) (|U32Vector|) (|Integer|) (|Integer|) (|Integer|)) "\\indented{1}{eval_at(v, deg, \\spad{pt,} \\spad{p)} treats \\spad{v} as coefficients of} \\indented{1}{polynomial of degree deg and evaluates the} \\indented{1}{polynomial at point \\spad{pt} modulo \\spad{p}} \\blankline \\spad{X} a:=new(3,1)$U32VEC \\spad{X} \\spad{a.1:=2} \\spad{X} eval_at(a,2,3,1024) \\spad{X} eval_at(a,2,2,8) \\spad{X} eval_at(a,2,3,10)")) (|copyslice| (((|Void|) (|U32Vector|) (|U32Vector|) (|Integer|) (|Integer|)) "copy_first(v1, \\spad{v2,} \\spad{m,} \\spad{n)} copies the slice of \\spad{v2} starting at \\spad{m} elements and having \\spad{n} elements into corresponding positions in \\spad{v1.}")) (|copyfirst| (((|Void|) (|U32Vector|) (|U32Vector|) (|Integer|)) "copy_first(v1, \\spad{v2,} \\spad{n)} copies first \\spad{n} elements of \\spad{v2} into \\spad{n} first positions in \\spad{v1.}"))) 
NIL 
NIL 
(|PlottablePlaneCurveCategory|) 
((|constructor| (NIL "\\indented{1}{Author: Clifton \\spad{J.} Williamson} Date Created: 11 January 1990 Date Last Updated: 15 June 1990 Description:")) (|yRange| (((|Segment| (|DoubleFloat|)) $) "\\spad{yRange(c)} returns the range of the y-coordinates of the points on the curve \\spad{c.}")) (|xRange| (((|Segment| (|DoubleFloat|)) $) "\\spad{xRange(c)} returns the range of the x-coordinates of the points on the curve \\spad{c.}")) (|listBranches| (((|List| (|List| (|Point| (|DoubleFloat|)))) $) "\\spad{listBranches(c)} returns a list of lists of points, representing the branches of the curve \\spad{c.}"))) 
NIL 
NIL 
(|PrecomputedAssociatedEquations| R L) 
((|constructor| (NIL "\\spadtype{PrecomputedAssociatedEquations} stores some generic precomputations which speed up the computations of the associated equations needed for factoring operators.")) (|firstUncouplingMatrix| (((|Union| (|Matrix| |#1|) "failed") |#2| (|PositiveInteger|)) "\\spad{firstUncouplingMatrix(op, \\spad{m)}} returns the matrix A such that \\spad{A \\spad{w} = (W',W'',...,W^N)} in the corresponding associated equations for right-factors of order \\spad{m} of op. Returns \"failed\" if the matrix A has not been precomputed for the particular combination \\spad{degree(L), \\spad{m}.}"))) 
NIL 
NIL 
(|PrimitiveArrayFunctions2| A B) 
((|constructor| (NIL "This package provides tools for operating on primitive arrays with unary and binary functions involving different underlying types")) (|map| (((|PrimitiveArray| |#2|) (|Mapping| |#2| |#1|) (|PrimitiveArray| |#1|)) "\\indented{1}{map(f,a) applies function \\spad{f} to each member of primitive array} \\indented{1}{\\spad{a} resulting in a new primitive array over a} \\indented{1}{possibly different underlying domain.} \\blankline \\spad{X} T1:=PrimitiveArrayFunctions2(Integer,Integer) \\spad{X} map(x+->x+2,[i for \\spad{i} in 1..10])$T1")) (|reduce| ((|#2| (|Mapping| |#2| |#1| |#2|) (|PrimitiveArray| |#1|) |#2|) "\\indented{1}{reduce(f,a,r) applies function \\spad{f} to each} \\indented{1}{successive element of the} \\indented{1}{primitive array \\spad{a} and an accumulant initialized to \\spad{r.}} \\indented{1}{For example, \\spad{reduce(_+$Integer,[1,2,3],0)}} \\indented{1}{does \\spad{3+(2+(1+0))}. Note that third argument \\spad{r}} \\indented{1}{may be regarded as the identity element for the function \\spad{f.}} \\blankline \\spad{X} T1:=PrimitiveArrayFunctions2(Integer,Integer) \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} reduce(adder,[i for \\spad{i} in 1..10],0)$T1")) (|scan| (((|PrimitiveArray| |#2|) (|Mapping| |#2| |#1| |#2|) (|PrimitiveArray| |#1|) |#2|) "\\indented{1}{scan(f,a,r) successively applies} \\indented{1}{\\spad{reduce(f,x,r)} to more and more leading sub-arrays} \\indented{1}{x of primitive array \\spad{a}.} \\indented{1}{More precisely, if \\spad{a} is \\spad{[a1,a2,...]}, then} \\indented{1}{\\spad{scan(f,a,r)} returns} \\indented{1}{\\spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.} \\blankline \\spad{X} T1:=PrimitiveArrayFunctions2(Integer,Integer) \\spad{X} adder(a:Integer,b:Integer):Integer \\spad{==} a+b \\spad{X} scan(adder,[i for \\spad{i} in 1..10],0)$T1"))) 
NIL 
NIL 
(|PrimitiveArray| S) 
((|constructor| (NIL "This provides a fast array type with no bound checking on elt's. Minimum index is 0 in this type, cannot be changed"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|PrimitiveFunctionCategory|) 
((|constructor| (NIL "Category for the functions defined by integrals.")) (|integral| (($ $ (|SegmentBinding| $)) "\\spad{integral(f, \\spad{x} = a..b)} returns the formal definite integral of \\spad{f} \\spad{dx} for \\spad{x} between \\spad{a} and \\spad{b.}") (($ $ (|Symbol|)) "\\spad{integral(f, \\spad{x)}} returns the formal integral of \\spad{f} \\spad{dx.}"))) 
NIL 
NIL 
(|PrimitiveElement| F) 
((|constructor| (NIL "PrimitiveElement provides functions to compute primitive elements in algebraic extensions.")) (|primitiveElement| (((|Record| (|:| |coef| (|List| (|Integer|))) (|:| |poly| (|List| (|SparseUnivariatePolynomial| |#1|))) (|:| |prim| (|SparseUnivariatePolynomial| |#1|))) (|List| (|Polynomial| |#1|)) (|List| (|Symbol|)) (|Symbol|)) "\\spad{primitiveElement([p1,...,pn], [a1,...,an], a)} returns \\spad{[[c1,...,cn], [q1,...,qn], \\spad{q]}} such that then \\spad{k(a1,...,an) = k(a)}, where \\spad{a = \\spad{a1} \\spad{c1} + \\spad{...} + an cn}, \\spad{ai = qi(a)}, and \\spad{q(a) = 0}. The pi's are the defining polynomials for the ai's. This operation uses the technique of \\spadglossSee{groebner bases}{Groebner basis}.") (((|Record| (|:| |coef| (|List| (|Integer|))) (|:| |poly| (|List| (|SparseUnivariatePolynomial| |#1|))) (|:| |prim| (|SparseUnivariatePolynomial| |#1|))) (|List| (|Polynomial| |#1|)) (|List| (|Symbol|))) "\\spad{primitiveElement([p1,...,pn], [a1,...,an])} returns \\spad{[[c1,...,cn], [q1,...,qn], \\spad{q]}} such that then \\spad{k(a1,...,an) = k(a)}, where \\spad{a = \\spad{a1} \\spad{c1} + \\spad{...} + an cn}, \\spad{ai = qi(a)}, and \\spad{q(a) = 0}. The pi's are the defining polynomials for the ai's. This operation uses the technique of \\spadglossSee{groebner bases}{Groebner basis}.") (((|Record| (|:| |coef1| (|Integer|)) (|:| |coef2| (|Integer|)) (|:| |prim| (|SparseUnivariatePolynomial| |#1|))) (|Polynomial| |#1|) (|Symbol|) (|Polynomial| |#1|) (|Symbol|)) "\\spad{primitiveElement(p1, a1, \\spad{p2,} a2)} returns \\spad{[c1, \\spad{c2,} \\spad{q]}} such that \\spad{k(a1, a2) = k(a)} where \\spad{a = \\spad{c1} \\spad{a1} + \\spad{c2} a2, and q(a) = 0}. The pi's are the defining polynomials for the ai's. The \\spad{p2} may involve a1, but \\spad{p1} must not involve a2. This operation uses \\spadfun{resultant}."))) 
NIL 
NIL 
(|IntegerPrimesPackage| I) 
((|constructor| (NIL "The \\spadtype{IntegerPrimesPackage} implements a modification of Rabin's probabilistic primality test and the utility functions \\spadfun{nextPrime}, \\spadfun{prevPrime} and \\spadfun{primes}.")) (|primes| (((|List| |#1|) |#1| |#1|) "\\spad{primes(a,b)} returns a list of all primes \\spad{p} with \\spad{a \\spad{<=} \\spad{p} \\spad{<=} \\spad{b}}")) (|prevPrime| ((|#1| |#1|) "\\spad{prevPrime(n)} returns the largest prime strictly smaller than \\spad{n}")) (|nextPrime| ((|#1| |#1|) "\\spad{nextPrime(n)} returns the smallest prime strictly larger than \\spad{n}")) (|prime?| (((|Boolean|) |#1|) "\\spad{prime?(n)} returns \\spad{true} if \\spad{n} is prime and \\spad{false} if not. The algorithm used is Rabin's probabilistic primality test (reference: Knuth Volume 2 Semi Numerical Algorithms). If \\spad{prime? \\spad{n}} returns false, \\spad{n} is proven composite. If \\spad{prime? \\spad{n}} returns true, prime? may be in error however, the probability of error is very low. and is zero below 25*10**9 (due to a result of Pomerance et al), below 10**12 and 10**13 due to results of Pinch, and below 341550071728321 due to a result of Jaeschke. Specifically, this implementation does at least 10 pseudo prime tests and so the probability of error is \\spad{< 4**(-10)}. The running time of this method is cubic in the length of the input \\spad{n,} that is \\spad{O( (log \\spad{n)**3} \\spad{)},} for n<10**20. beyond that, the algorithm is quartic, \\spad{O( (log \\spad{n)**4} \\spad{)}.} Two improvements due to Davenport have been incorporated which catches some trivial strong pseudo-primes, such as [Jaeschke, 1991] 1377161253229053 * 413148375987157, which the original algorithm regards as prime"))) 
NIL 
NIL 
(|PrintPackage|) 
((|constructor| (NIL "PrintPackage provides a print function for output forms.")) (|print| (((|Void|) (|OutputForm|)) "\\spad{print(o)} writes the output form \\spad{o} on standard output using the two-dimensional formatter."))) 
NIL 
NIL 
(|ProjectiveAlgebraicSetPackage| K |symb| |PolyRing| E |ProjPt|) 
((|constructor| (NIL "The following is part of the PAFF package")) (|rationalPoints| (((|List| |#5|) |#3| (|PositiveInteger|)) "\\axiom{rationalPoints(f,d)} returns all points on the curve \\axiom{f} in the extension of the ground field of degree \\axiom{d}. For \\axiom{d > 1} this only works if \\axiom{K} is a \\axiomType{LocallyAlgebraicallyClosedField}")) (|algebraicSet| (((|List| |#5|) (|List| |#3|)) "\\spad{algebraicSet returns} the algebraic set if finite (dimension 0).")) (|singularPoints| (((|List| |#5|) |#3|) "\\spad{singularPoints retourne} les points singulier")) (|singularPointsWithRestriction| (((|List| |#5|) |#3| (|List| |#3|)) "return the singular points that anhilate"))) 
NIL 
NIL 
(|PolynomialRing| R E) 
((|constructor| (NIL "This domain represents generalized polynomials with coefficients (from a not necessarily commutative ring), and terms indexed by their exponents (from an arbitrary ordered abelian monoid). This type is used, for example, by the \\spadtype{DistributedMultivariatePolynomial} domain where the exponent domain is a direct product of non negative integers.")) (|canonicalUnitNormal| ((|attribute|) "canonicalUnitNormal guarantees that the function unitCanonical returns the same representative for all associates of any particular element.")) (|fmecg| (($ $ |#2| |#1| $) "\\spad{fmecg(p1,e,r,p2)} finds \\spad{x} : \\spad{p1} - \\spad{r} * x**e * \\spad{p2}"))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (AND (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (OR (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|))) 
(|Product| A B) 
((|constructor| (NIL "This domain implements cartesian product")) (|selectsecond| ((|#2| $) "\\spad{selectsecond(x)} is not documented")) (|selectfirst| ((|#1| $) "\\spad{selectfirst(x)} is not documented")) (|makeprod| (($ |#1| |#2|) "\\indented{1}{makeprod(a,b) computes the product of two functions} \\blankline \\spad{X} f:=(x:INT):INT \\spad{+->} 3*x \\spad{X} g:=(x:INT):INT \\spad{+->} \\spad{x^3} \\spad{X} h(x:INT):Product(INT,INT) \\spad{==} makeprod(f \\spad{x,} \\spad{g} \\spad{x)} \\spad{X} h(3)"))) 
((|unitsKnown| AND (|has| |#2| (|Group|)) (|has| |#1| (|Group|)))) 
((AND (|HasCategory| |#1| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#2| (QUOTE (|AbelianGroup|)))) (AND (|HasCategory| |#1| (QUOTE (|Group|))) (|HasCategory| |#2| (QUOTE (|Group|)))) (AND (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#2| (QUOTE (|Finite|)))) (AND (|HasCategory| |#1| (QUOTE (|Monoid|))) (|HasCategory| |#2| (QUOTE (|Monoid|)))) (OR (AND (|HasCategory| |#1| (QUOTE (|Group|))) (|HasCategory| |#2| (QUOTE (|Group|)))) (AND (|HasCategory| |#1| (QUOTE (|Monoid|))) (|HasCategory| |#2| (QUOTE (|Monoid|))))) (AND (|HasCategory| |#1| (QUOTE (|AbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|AbelianMonoid|)))) (AND (|HasCategory| |#1| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (OR (AND (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#2| (QUOTE (|AbelianGroup|)))) (AND (|HasCategory| |#1| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#1| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|))))) (OR (AND (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#2| (QUOTE (|AbelianGroup|)))) (AND (|HasCategory| |#1| (QUOTE (|AbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|AbelianMonoid|)))) (AND (|HasCategory| |#1| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#1| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|))))) (OR (AND (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#2| (QUOTE (|AbelianGroup|)))) (AND (|HasCategory| |#1| (QUOTE (|AbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|AbelianMonoid|)))) (AND (|HasCategory| |#1| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#1| (QUOTE (|Group|))) (|HasCategory| |#2| (QUOTE (|Group|)))) (AND (|HasCategory| |#1| (QUOTE (|Monoid|))) (|HasCategory| |#2| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#1| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|))))) (AND (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|OrderedSet|)))) (OR (AND (|HasCategory| |#1| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#2| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|OrderedSet|)))))) 
(|ProjectivePlane| K) 
((|constructor| (NIL "This is part of the PAFF package, related to projective space."))) 
NIL 
NIL 
(|ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField| K) 
((|constructor| (NIL "This is part of the PAFF package, related to projective space."))) 
NIL 
NIL 
(|ProjectiveSpace| |dim| K) 
((|constructor| (NIL "This is part of the PAFF package, related to projective space."))) 
NIL 
NIL 
(|PriorityQueueAggregate| S) 
((|constructor| (NIL "A priority queue is a bag of items from an ordered set where the item extracted is always the maximum element.")) (|merge!| (($ $ $) "\\spad{merge!(q,q1)} destructively changes priority queue \\spad{q} to include the values from priority queue \\spad{q1.}")) (|merge| (($ $ $) "\\spad{merge(q1,q2)} returns combines priority queues \\spad{q1} and \\spad{q2} to return a single priority queue \\spad{q.}")) (|max| ((|#1| $) "\\spad{max(q)} returns the maximum element of priority queue \\spad{q.}"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|PseudoRemainderSequence| R |polR|) 
((|constructor| (NIL "This package contains some functions: discriminant, resultant, subResultantGcd, chainSubResultants, degreeSubResultant, lastSubResultant, resultantEuclidean, subResultantGcdEuclidean, semiSubResultantGcdEuclidean1, semiSubResultantGcdEuclidean2\\br These procedures come from improvements of the subresultants algorithm.")) (|semiResultantEuclideannaif| (((|Record| (|:| |coef2| |#2|) (|:| |resultant| |#1|)) |#2| |#2|) "\\axiom{resultantEuclidean_naif(P,Q)} returns the semi-extended resultant of \\axiom{P} and \\axiom{Q} computed by means of the naive algorithm.")) (|resultantEuclideannaif| (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |resultant| |#1|)) |#2| |#2|) "\\axiom{resultantEuclidean_naif(P,Q)} returns the extended resultant of \\axiom{P} and \\axiom{Q} computed by means of the naive algorithm.")) (|resultantnaif| ((|#1| |#2| |#2|) "\\axiom{resultantEuclidean_naif(P,Q)} returns the resultant of \\axiom{P} and \\axiom{Q} computed by means of the naive algorithm.")) (|nextsousResultant2| ((|#2| |#2| |#2| |#2| |#1|) "\\axiom{nextsousResultant2(P, \\spad{Q,} \\spad{Z,} \\spad{s)}} returns the subresultant \\axiom{S_{e-1}} where \\axiom{P ~ S_d, \\spad{Q} = S_{d-1}, \\spad{Z} = S_e, \\spad{s} = lc(S_d)}")) (|Lazard2| ((|#2| |#2| |#1| |#1| (|NonNegativeInteger|)) "\\axiom{Lazard2(F, \\spad{x,} \\spad{y,} \\spad{n)}} computes \\axiom{(x/y)**(n-1) * \\spad{F}}")) (|Lazard| ((|#1| |#1| |#1| (|NonNegativeInteger|)) "\\axiom{Lazard(x, \\spad{y,} \\spad{n)}} computes \\axiom{x**n/y**(n-1)}")) (|divide| (((|Record| (|:| |quotient| |#2|) (|:| |remainder| |#2|)) |#2| |#2|) "\\axiom{divide(F,G)} computes quotient and rest of the exact euclidean division of \\axiom{F} by \\axiom{G}.")) (|pseudoDivide| (((|Record| (|:| |coef| |#1|) (|:| |quotient| |#2|) (|:| |remainder| |#2|)) |#2| |#2|) "\\axiom{pseudoDivide(P,Q)} computes the pseudoDivide of \\axiom{P} by \\axiom{Q}.")) (|exquo| (((|Vector| |#2|) (|Vector| |#2|) |#1|) "\\axiom{v exquo \\spad{r}} computes the exact quotient of \\axiom{v} by \\axiom{r}")) (* (((|Vector| |#2|) |#1| (|Vector| |#2|)) "\\axiom{r * \\spad{v}} computes the product of \\axiom{r} and \\axiom{v}")) (|gcd| ((|#2| |#2| |#2|) "\\axiom{gcd(P, \\spad{Q)}} returns the \\spad{gcd} of \\axiom{P} and \\axiom{Q}.")) (|semiResultantReduitEuclidean| (((|Record| (|:| |coef2| |#2|) (|:| |resultantReduit| |#1|)) |#2| |#2|) "\\axiom{semiResultantReduitEuclidean(P,Q)} returns the \"reduce resultant\" and carries out the equality \\axiom{...P + coef2*Q = resultantReduit(P,Q)}.")) (|resultantReduitEuclidean| (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |resultantReduit| |#1|)) |#2| |#2|) "\\axiom{resultantReduitEuclidean(P,Q)} returns the \"reduce resultant\" and carries out the equality \\axiom{coef1*P + coef2*Q = resultantReduit(P,Q)}.")) (|resultantReduit| ((|#1| |#2| |#2|) "\\axiom{resultantReduit(P,Q)} returns the \"reduce resultant\" of \\axiom{P} and \\axiom{Q}.")) (|schema| (((|List| (|NonNegativeInteger|)) |#2| |#2|) "\\axiom{schema(P,Q)} returns the list of degrees of non zero subresultants of \\axiom{P} and \\axiom{Q}.")) (|chainSubResultants| (((|List| |#2|) |#2| |#2|) "\\axiom{chainSubResultants(P, \\spad{Q)}} computes the list of non zero subresultants of \\axiom{P} and \\axiom{Q}.")) (|semiDiscriminantEuclidean| (((|Record| (|:| |coef2| |#2|) (|:| |discriminant| |#1|)) |#2|) "\\axiom{discriminantEuclidean(P)} carries out the equality \\axiom{...P + \\spad{coef2} * D(P) = discriminant(P)}. Warning. \\axiom{degree(P) \\spad{>=} degree(Q)}.")) (|discriminantEuclidean| (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |discriminant| |#1|)) |#2|) "\\axiom{discriminantEuclidean(P)} carries out the equality \\axiom{coef1 * \\spad{P} + \\spad{coef2} * D(P) = discriminant(P)}.")) (|discriminant| ((|#1| |#2|) "\\axiom{discriminant(P, \\spad{Q)}} returns the discriminant of \\axiom{P} and \\axiom{Q}.")) (|semiSubResultantGcdEuclidean1| (((|Record| (|:| |coef1| |#2|) (|:| |gcd| |#2|)) |#2| |#2|) "\\axiom{semiSubResultantGcdEuclidean1(P,Q)} carries out the equality \\axiom{coef1*P + ? \\spad{Q} = \\spad{+/-} S_i(P,Q)} where the degree (not the indice) of the subresultant \\axiom{S_i(P,Q)} is the smaller as possible.")) (|semiSubResultantGcdEuclidean2| (((|Record| (|:| |coef2| |#2|) (|:| |gcd| |#2|)) |#2| |#2|) "\\axiom{semiSubResultantGcdEuclidean2(P,Q)} carries out the equality \\axiom{...P + coef2*Q = \\spad{+/-} S_i(P,Q)} where the degree (not the indice) of the subresultant \\axiom{S_i(P,Q)} is the smaller as possible. Warning. \\axiom{degree(P) \\spad{>=} degree(Q)}.")) (|subResultantGcdEuclidean| (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |gcd| |#2|)) |#2| |#2|) "\\axiom{subResultantGcdEuclidean(P,Q)} carries out the equality \\axiom{coef1*P + coef2*Q = \\spad{+/-} S_i(P,Q)} where the degree (not the indice) of the subresultant \\axiom{S_i(P,Q)} is the smaller as possible.")) (|subResultantGcd| ((|#2| |#2| |#2|) "\\axiom{subResultantGcd(P, \\spad{Q)}} returns the \\spad{gcd} of two primitive polynomials \\axiom{P} and \\axiom{Q}.")) (|semiLastSubResultantEuclidean| (((|Record| (|:| |coef2| |#2|) (|:| |subResultant| |#2|)) |#2| |#2|) "\\axiom{semiLastSubResultantEuclidean(P, \\spad{Q)}} computes the last non zero subresultant \\axiom{S} and carries out the equality \\axiom{...P + coef2*Q = \\spad{S}.} Warning. \\axiom{degree(P) \\spad{>=} degree(Q)}.")) (|lastSubResultantEuclidean| (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |subResultant| |#2|)) |#2| |#2|) "\\axiom{lastSubResultantEuclidean(P, \\spad{Q)}} computes the last non zero subresultant \\axiom{S} and carries out the equality \\axiom{coef1*P + coef2*Q = \\spad{S}.}")) (|lastSubResultant| ((|#2| |#2| |#2|) "\\axiom{lastSubResultant(P, \\spad{Q)}} computes the last non zero subresultant of \\axiom{P} and \\axiom{Q}")) (|semiDegreeSubResultantEuclidean| (((|Record| (|:| |coef2| |#2|) (|:| |subResultant| |#2|)) |#2| |#2| (|NonNegativeInteger|)) "\\axiom{indiceSubResultant(P, \\spad{Q,} i)} returns a subresultant \\axiom{S} of degree \\axiom{d} and carries out the equality \\axiom{...P + coef2*Q = S_i}. Warning. \\axiom{degree(P) \\spad{>=} degree(Q)}.")) (|degreeSubResultantEuclidean| (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |subResultant| |#2|)) |#2| |#2| (|NonNegativeInteger|)) "\\axiom{indiceSubResultant(P, \\spad{Q,} i)} returns a subresultant \\axiom{S} of degree \\axiom{d} and carries out the equality \\axiom{coef1*P + coef2*Q = S_i}.")) (|degreeSubResultant| ((|#2| |#2| |#2| (|NonNegativeInteger|)) "\\axiom{degreeSubResultant(P, \\spad{Q,} \\spad{d)}} computes a subresultant of degree \\axiom{d}.")) (|semiIndiceSubResultantEuclidean| (((|Record| (|:| |coef2| |#2|) (|:| |subResultant| |#2|)) |#2| |#2| (|NonNegativeInteger|)) "\\axiom{semiIndiceSubResultantEuclidean(P, \\spad{Q,} i)} returns the subresultant \\axiom{S_i(P,Q)} and carries out the equality \\axiom{...P + coef2*Q = S_i(P,Q)} Warning. \\axiom{degree(P) \\spad{>=} degree(Q)}.")) (|indiceSubResultantEuclidean| (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |subResultant| |#2|)) |#2| |#2| (|NonNegativeInteger|)) "\\axiom{indiceSubResultant(P, \\spad{Q,} i)} returns the subresultant \\axiom{S_i(P,Q)} and carries out the equality \\axiom{coef1*P + coef2*Q = S_i(P,Q)}")) (|indiceSubResultant| ((|#2| |#2| |#2| (|NonNegativeInteger|)) "\\axiom{indiceSubResultant(P, \\spad{Q,} i)} returns the subresultant of indice \\axiom{i}")) (|semiResultantEuclidean1| (((|Record| (|:| |coef1| |#2|) (|:| |resultant| |#1|)) |#2| |#2|) "\\axiom{semiResultantEuclidean1(P,Q)} carries out the equality \\axiom{coef1.P + ? \\spad{Q} = resultant(P,Q)}.")) (|semiResultantEuclidean2| (((|Record| (|:| |coef2| |#2|) (|:| |resultant| |#1|)) |#2| |#2|) "\\axiom{semiResultantEuclidean2(P,Q)} carries out the equality \\axiom{...P + coef2*Q = resultant(P,Q)}. Warning. \\axiom{degree(P) \\spad{>=} degree(Q)}.")) (|resultantEuclidean| (((|Record| (|:| |coef1| |#2|) (|:| |coef2| |#2|) (|:| |resultant| |#1|)) |#2| |#2|) "\\axiom{resultantEuclidean(P,Q)} carries out the equality \\axiom{coef1*P + coef2*Q = resultant(P,Q)}")) (|resultant| ((|#1| |#2| |#2|) "\\axiom{resultant(P, \\spad{Q)}} returns the resultant of \\axiom{P} and \\axiom{Q}"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|GcdDomain|)))) 
(|ProjectiveSpaceCategory| K) 
((|constructor| (NIL "This is part of the PAFF package, related to projective space.")) (|pointValue| (((|List| |#1|) $) "\\spad{pointValue returns} the coordinates of the point or of the point of origin that represent an infinitly close point")) (|setelt| ((|#1| $ (|Integer|) |#1|) "\\spad{setelt sets} the value of a specified coordinates")) (|elt| ((|#1| $ (|Integer|)) "\\spad{elt returns} the value of a specified coordinates")) (|list| (((|List| |#1|) $) "\\spad{list returns} the list of the coordinates")) (|lastNonNull| (((|Integer|) $) "\\spad{lastNonNull returns} the integer corresponding to the last non null coordinates.")) (|rational?| (((|Boolean|) $) "\\spad{rational?(p)} test if the point is rational according to the characteristic of the ground field.") (((|Boolean|) $ (|NonNegativeInteger|)) "\\spad{rational?(p,n)} test if the point is rational according to \\spad{n.}")) (|removeConjugate| (((|List| $) (|List| $)) "\\spad{removeConjugate(lp)} returns removeConjugate(lp,n) where \\spad{n} is the characteristic of the ground field.") (((|List| $) (|List| $) (|NonNegativeInteger|)) "\\spad{removeConjugate(lp,n)} returns a list of points such that no points in the list is the conjugate (according to \\spad{n)} of another point.")) (|conjugate| (($ $) "\\spad{conjugate(p)} returns conjugate(p,n) where \\spad{n} is the characteristic of the ground field.") (($ $ (|NonNegativeInteger|)) "\\spad{conjugate(p,n)} returns p**n, that is all the coordinates of \\spad{p} to the power of \\spad{n}")) (|orbit| (((|List| $) $ (|NonNegativeInteger|)) "\\spad{orbit(p,n)} returns the orbit of the point \\spad{p} according to \\spad{n,} that is orbit(p,n) = \\spad{\\{} \\spad{p,} p**n, p**(n**2), p**(n**3), ..... \\spad{\\}}") (((|List| $) $) "\\spad{orbit(p)} returns the orbit of the point \\spad{p} according to the characteristic of \\spad{K,} that is, for \\spad{q=} char \\spad{K,} orbit(p) = \\spad{\\{} \\spad{p,} p**q, p**(q**2), p**(q**3), ..... \\spad{\\}}")) (|coerce| (($ (|List| |#1|)) "\\spad{coerce a} list of \\spad{K} to a projective point.") (((|List| |#1|) $) "\\spad{coerce a} a projective point list of \\spad{K}")) (|projectivePoint| (($ (|List| |#1|)) "\\spad{projectivePoint creates} a projective point from a list")) (|homogenize| (($ $) "\\spad{homogenize(pt)} the point according to the coordinate which is the last non null.") (($ $ (|Integer|)) "\\spad{homogenize the} point according to the coordinate specified by the integer"))) 
NIL 
NIL 
(|Partition|) 
((|constructor| (NIL "Domain for partitions of positive integers Partition is an OrderedCancellationAbelianMonoid which is used as the basis for symmetric polynomial representation of the sums of powers in SymmetricPolynomial. Thus, \\spad{(5 2 2 1)} will represent \\spad{s5 * \\spad{s2**2} * s1}.")) (|coerce| (((|List| (|Integer|)) $) "\\spad{coerce(p)} coerces a partition into a list of integers")) (|conjugate| (($ $) "\\spad{conjugate(p)} returns the conjugate partition of a partition \\spad{p}")) (|pdct| (((|Integer|) $) "\\spad{pdct(a1**n1 \\spad{a2**n2} ...)} returns \\spad{n1! * \\spad{a1**n1} * \\spad{n2!} * \\spad{a2**n2} * ...}. This function is used in the package \\spadtype{CycleIndicators}.")) (|powers| (((|List| (|List| (|Integer|))) (|List| (|Integer|))) "\\spad{powers(li)} returns a list of 2-element lists. For each 2-element list, the first element is an entry of \\spad{li} and the second element is the multiplicity with which the first element occurs in li. There is a 2-element list for each value occurring in \\spad{l.}")) (|partition| (($ (|List| (|Integer|))) "\\spad{partition(li)} converts a list of integers \\spad{li} to a partition"))) 
NIL 
NIL 
(|PowerSeriesCategory&| S |Coef| |Expon| |Var|) 
((|constructor| (NIL "\\spadtype{PowerSeriesCategory} is the most general power series category with exponents in an ordered abelian monoid.")) (|complete| (($ $) "\\spad{complete(f)} causes all terms of \\spad{f} to be computed. Note that this results in an infinite loop if \\spad{f} has infinitely many terms.")) (|pole?| (((|Boolean|) $) "\\spad{pole?(f)} determines if the power series \\spad{f} has a pole.")) (|variables| (((|List| |#4|) $) "\\spad{variables(f)} returns a list of the variables occuring in the power series \\spad{f.}")) (|degree| ((|#3| $) "\\spad{degree(f)} returns the exponent of the lowest order term of \\spad{f}.")) (|leadingCoefficient| ((|#2| $) "\\spad{leadingCoefficient(f)} returns the coefficient of the lowest order term of \\spad{f}")) (|leadingMonomial| (($ $) "\\spad{leadingMonomial(f)} returns the monomial of \\spad{f} of lowest order.")) (|monomial| (($ $ (|List| |#4|) (|List| |#3|)) "\\spad{monomial(a,[x1,..,xk],[n1,..,nk])} computes \\spad{a * \\spad{x1**n1} * \\spad{..} * xk**nk}.") (($ $ |#4| |#3|) "\\spad{monomial(a,x,n)} computes \\spad{a*x**n}."))) 
NIL 
NIL 
(|PowerSeriesCategory| |Coef| |Expon| |Var|) 
((|constructor| (NIL "\\spadtype{PowerSeriesCategory} is the most general power series category with exponents in an ordered abelian monoid.")) (|complete| (($ $) "\\spad{complete(f)} causes all terms of \\spad{f} to be computed. Note that this results in an infinite loop if \\spad{f} has infinitely many terms.")) (|pole?| (((|Boolean|) $) "\\spad{pole?(f)} determines if the power series \\spad{f} has a pole.")) (|variables| (((|List| |#3|) $) "\\spad{variables(f)} returns a list of the variables occuring in the power series \\spad{f.}")) (|degree| ((|#2| $) "\\spad{degree(f)} returns the exponent of the lowest order term of \\spad{f}.")) (|leadingCoefficient| ((|#1| $) "\\spad{leadingCoefficient(f)} returns the coefficient of the lowest order term of \\spad{f}")) (|leadingMonomial| (($ $) "\\spad{leadingMonomial(f)} returns the monomial of \\spad{f} of lowest order.")) (|monomial| (($ $ (|List| |#3|) (|List| |#2|)) "\\spad{monomial(a,[x1,..,xk],[n1,..,nk])} computes \\spad{a * \\spad{x1**n1} * \\spad{..} * xk**nk}.") (($ $ |#3| |#2|) "\\spad{monomial(a,x,n)} computes \\spad{a*x**n}."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|PlottableSpaceCurveCategory|) 
((|constructor| (NIL "PlottableSpaceCurveCategory is the category of curves in 3-space which may be plotted via the graphics facilities. Functions are provided for obtaining lists of lists of points, representing the branches of the curve, and for determining the ranges of the \\spad{x-,} \\spad{y-,} and z-coordinates of the points on the curve.")) (|zRange| (((|Segment| (|DoubleFloat|)) $) "\\spad{zRange(c)} returns the range of the z-coordinates of the points on the curve \\spad{c.}")) (|yRange| (((|Segment| (|DoubleFloat|)) $) "\\spad{yRange(c)} returns the range of the y-coordinates of the points on the curve \\spad{c.}")) (|xRange| (((|Segment| (|DoubleFloat|)) $) "\\spad{xRange(c)} returns the range of the x-coordinates of the points on the curve \\spad{c.}")) (|listBranches| (((|List| (|List| (|Point| (|DoubleFloat|)))) $) "\\spad{listBranches(c)} returns a list of lists of points, representing the branches of the curve \\spad{c.}"))) 
NIL 
NIL 
(|PolynomialSetCategory&| S R E |VarSet| P) 
((|constructor| (NIL "A category for finite subsets of a polynomial ring. Such a set is only regarded as a set of polynomials and not identified to the ideal it generates. So two distinct sets may generate the same the ideal. Furthermore, for \\spad{R} being an integral domain, a set of polynomials may be viewed as a representation of the ideal it generates in the polynomial ring \\spad{(R)^(-1) \\spad{P},} or the set of its zeros (described for instance by the radical of the previous ideal, or a split of the associated affine variety) and so on. So this category provides operations about those different notions.")) (|triangular?| (((|Boolean|) $) "\\axiom{triangular?(ps)} returns \\spad{true} iff \\axiom{ps} is a triangular set, \\spadignore{i.e.} two distinct polynomials have distinct main variables and no constant lies in \\axiom{ps}.")) (|rewriteIdealWithRemainder| (((|List| |#5|) (|List| |#5|) $) "\\axiom{rewriteIdealWithRemainder(lp,cs)} returns \\axiom{lr} such that every polynomial in \\axiom{lr} is fully reduced in the sense of Groebner bases w.r.t. \\axiom{cs} and \\axiom{(lp,cs)} and \\axiom{(lr,cs)} generate the same ideal in \\axiom{(R)^(-1) \\spad{P}.}")) (|rewriteIdealWithHeadRemainder| (((|List| |#5|) (|List| |#5|) $) "\\axiom{rewriteIdealWithHeadRemainder(lp,cs)} returns \\axiom{lr} such that the leading monomial of every polynomial in \\axiom{lr} is reduced in the sense of Groebner bases w.r.t. \\axiom{cs} and \\axiom{(lp,cs)} and \\axiom{(lr,cs)} generate the same ideal in \\axiom{(R)^(-1) \\spad{P}.}")) (|remainder| (((|Record| (|:| |rnum| |#2|) (|:| |polnum| |#5|) (|:| |den| |#2|)) |#5| $) "\\axiom{remainder(a,ps)} returns \\axiom{[c,b,r]} such that \\axiom{b} is fully reduced in the sense of Groebner bases w.r.t. \\axiom{ps}, \\axiom{r*a - c*b} lies in the ideal generated by \\axiom{ps}. Furthermore, if \\axiom{R} is a gcd-domain, \\axiom{b} is primitive.")) (|headRemainder| (((|Record| (|:| |num| |#5|) (|:| |den| |#2|)) |#5| $) "\\axiom{headRemainder(a,ps)} returns \\axiom{[b,r]} such that the leading monomial of \\axiom{b} is reduced in the sense of Groebner bases w.r.t. \\axiom{ps} and \\axiom{r*a - \\spad{b}} lies in the ideal generated by \\axiom{ps}.")) (|roughUnitIdeal?| (((|Boolean|) $) "\\axiom{roughUnitIdeal?(ps)} returns \\spad{true} iff \\axiom{ps} contains \\indented{1}{some non null element lying in the base ring \\axiom{R}.}")) (|roughEqualIdeals?| (((|Boolean|) $ $) "\\axiom{roughEqualIdeals?(ps1,ps2)} returns \\spad{true} iff it can proved that \\axiom{ps1} and \\axiom{ps2} generate the same ideal in \\axiom{(R)^(-1) \\spad{P}} without computing Groebner bases.")) (|roughSubIdeal?| (((|Boolean|) $ $) "\\axiom{roughSubIdeal?(ps1,ps2)} returns \\spad{true} iff it can proved that all polynomials in \\axiom{ps1} lie in the ideal generated by \\axiom{ps2} in \\axiom{\\axiom{(R)^(-1) \\spad{P}}} without computing Groebner bases.")) (|roughBase?| (((|Boolean|) $) "\\axiom{roughBase?(ps)} returns \\spad{true} iff for every pair \\axiom{{p,q}} of polynomials in \\axiom{ps} their leading monomials are relatively prime.")) (|trivialIdeal?| (((|Boolean|) $) "\\axiom{trivialIdeal?(ps)} returns \\spad{true} iff \\axiom{ps} does not contain non-zero elements.")) (|sort| (((|Record| (|:| |under| $) (|:| |floor| $) (|:| |upper| $)) $ |#4|) "\\axiom{sort(v,ps)} returns \\axiom{us,vs,ws} such that \\axiom{us} is \\axiom{collectUnder(ps,v)}, \\axiom{vs} is \\axiom{collect(ps,v)} and \\axiom{ws} is \\axiom{collectUpper(ps,v)}.")) (|collectUpper| (($ $ |#4|) "\\axiom{collectUpper(ps,v)} returns the set consisting of the polynomials of \\axiom{ps} with main variable greater than \\axiom{v}.")) (|collect| (($ $ |#4|) "\\axiom{collect(ps,v)} returns the set consisting of the polynomials of \\axiom{ps} with \\axiom{v} as main variable.")) (|collectUnder| (($ $ |#4|) "\\axiom{collectUnder(ps,v)} returns the set consisting of the polynomials of \\axiom{ps} with main variable less than \\axiom{v}.")) (|mainVariable?| (((|Boolean|) |#4| $) "\\axiom{mainVariable?(v,ps)} returns \\spad{true} iff \\axiom{v} is the main variable of some polynomial in \\axiom{ps}.")) (|mainVariables| (((|List| |#4|) $) "\\axiom{mainVariables(ps)} returns the decreasingly sorted list of the variables which are main variables of some polynomial in \\axiom{ps}.")) (|variables| (((|List| |#4|) $) "\\axiom{variables(ps)} returns the decreasingly sorted list of the variables which are variables of some polynomial in \\axiom{ps}.")) (|mvar| ((|#4| $) "\\axiom{mvar(ps)} returns the main variable of the non constant polynomial with the greatest main variable, if any, else an error is returned.")) (|retract| (($ (|List| |#5|)) "\\axiom{retract(lp)} returns an element of the domain whose elements are the members of \\axiom{lp} if such an element exists, otherwise an error is produced.")) (|retractIfCan| (((|Union| $ "failed") (|List| |#5|)) "\\axiom{retractIfCan(lp)} returns an element of the domain whose elements are the members of \\axiom{lp} if such an element exists, otherwise \\axiom{\"failed\"} is returned."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) 
(|PolynomialSetCategory| R E |VarSet| P) 
((|constructor| (NIL "A category for finite subsets of a polynomial ring. Such a set is only regarded as a set of polynomials and not identified to the ideal it generates. So two distinct sets may generate the same the ideal. Furthermore, for \\spad{R} being an integral domain, a set of polynomials may be viewed as a representation of the ideal it generates in the polynomial ring \\spad{(R)^(-1) \\spad{P},} or the set of its zeros (described for instance by the radical of the previous ideal, or a split of the associated affine variety) and so on. So this category provides operations about those different notions.")) (|triangular?| (((|Boolean|) $) "\\axiom{triangular?(ps)} returns \\spad{true} iff \\axiom{ps} is a triangular set, \\spadignore{i.e.} two distinct polynomials have distinct main variables and no constant lies in \\axiom{ps}.")) (|rewriteIdealWithRemainder| (((|List| |#4|) (|List| |#4|) $) "\\axiom{rewriteIdealWithRemainder(lp,cs)} returns \\axiom{lr} such that every polynomial in \\axiom{lr} is fully reduced in the sense of Groebner bases w.r.t. \\axiom{cs} and \\axiom{(lp,cs)} and \\axiom{(lr,cs)} generate the same ideal in \\axiom{(R)^(-1) \\spad{P}.}")) (|rewriteIdealWithHeadRemainder| (((|List| |#4|) (|List| |#4|) $) "\\axiom{rewriteIdealWithHeadRemainder(lp,cs)} returns \\axiom{lr} such that the leading monomial of every polynomial in \\axiom{lr} is reduced in the sense of Groebner bases w.r.t. \\axiom{cs} and \\axiom{(lp,cs)} and \\axiom{(lr,cs)} generate the same ideal in \\axiom{(R)^(-1) \\spad{P}.}")) (|remainder| (((|Record| (|:| |rnum| |#1|) (|:| |polnum| |#4|) (|:| |den| |#1|)) |#4| $) "\\axiom{remainder(a,ps)} returns \\axiom{[c,b,r]} such that \\axiom{b} is fully reduced in the sense of Groebner bases w.r.t. \\axiom{ps}, \\axiom{r*a - c*b} lies in the ideal generated by \\axiom{ps}. Furthermore, if \\axiom{R} is a gcd-domain, \\axiom{b} is primitive.")) (|headRemainder| (((|Record| (|:| |num| |#4|) (|:| |den| |#1|)) |#4| $) "\\axiom{headRemainder(a,ps)} returns \\axiom{[b,r]} such that the leading monomial of \\axiom{b} is reduced in the sense of Groebner bases w.r.t. \\axiom{ps} and \\axiom{r*a - \\spad{b}} lies in the ideal generated by \\axiom{ps}.")) (|roughUnitIdeal?| (((|Boolean|) $) "\\axiom{roughUnitIdeal?(ps)} returns \\spad{true} iff \\axiom{ps} contains \\indented{1}{some non null element lying in the base ring \\axiom{R}.}")) (|roughEqualIdeals?| (((|Boolean|) $ $) "\\axiom{roughEqualIdeals?(ps1,ps2)} returns \\spad{true} iff it can proved that \\axiom{ps1} and \\axiom{ps2} generate the same ideal in \\axiom{(R)^(-1) \\spad{P}} without computing Groebner bases.")) (|roughSubIdeal?| (((|Boolean|) $ $) "\\axiom{roughSubIdeal?(ps1,ps2)} returns \\spad{true} iff it can proved that all polynomials in \\axiom{ps1} lie in the ideal generated by \\axiom{ps2} in \\axiom{\\axiom{(R)^(-1) \\spad{P}}} without computing Groebner bases.")) (|roughBase?| (((|Boolean|) $) "\\axiom{roughBase?(ps)} returns \\spad{true} iff for every pair \\axiom{{p,q}} of polynomials in \\axiom{ps} their leading monomials are relatively prime.")) (|trivialIdeal?| (((|Boolean|) $) "\\axiom{trivialIdeal?(ps)} returns \\spad{true} iff \\axiom{ps} does not contain non-zero elements.")) (|sort| (((|Record| (|:| |under| $) (|:| |floor| $) (|:| |upper| $)) $ |#3|) "\\axiom{sort(v,ps)} returns \\axiom{us,vs,ws} such that \\axiom{us} is \\axiom{collectUnder(ps,v)}, \\axiom{vs} is \\axiom{collect(ps,v)} and \\axiom{ws} is \\axiom{collectUpper(ps,v)}.")) (|collectUpper| (($ $ |#3|) "\\axiom{collectUpper(ps,v)} returns the set consisting of the polynomials of \\axiom{ps} with main variable greater than \\axiom{v}.")) (|collect| (($ $ |#3|) "\\axiom{collect(ps,v)} returns the set consisting of the polynomials of \\axiom{ps} with \\axiom{v} as main variable.")) (|collectUnder| (($ $ |#3|) "\\axiom{collectUnder(ps,v)} returns the set consisting of the polynomials of \\axiom{ps} with main variable less than \\axiom{v}.")) (|mainVariable?| (((|Boolean|) |#3| $) "\\axiom{mainVariable?(v,ps)} returns \\spad{true} iff \\axiom{v} is the main variable of some polynomial in \\axiom{ps}.")) (|mainVariables| (((|List| |#3|) $) "\\axiom{mainVariables(ps)} returns the decreasingly sorted list of the variables which are main variables of some polynomial in \\axiom{ps}.")) (|variables| (((|List| |#3|) $) "\\axiom{variables(ps)} returns the decreasingly sorted list of the variables which are variables of some polynomial in \\axiom{ps}.")) (|mvar| ((|#3| $) "\\axiom{mvar(ps)} returns the main variable of the non constant polynomial with the greatest main variable, if any, else an error is returned.")) (|retract| (($ (|List| |#4|)) "\\axiom{retract(lp)} returns an element of the domain whose elements are the members of \\axiom{lp} if such an element exists, otherwise an error is produced.")) (|retractIfCan| (((|Union| $ "failed") (|List| |#4|)) "\\axiom{retractIfCan(lp)} returns an element of the domain whose elements are the members of \\axiom{lp} if such an element exists, otherwise \\axiom{\"failed\"} is returned."))) 
((|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|PolynomialSetUtilitiesPackage| R E V P) 
((|constructor| (NIL "This package provides modest routines for polynomial system solving. The aim of many of the operations of this package is to remove certain factors in some polynomials in order to avoid unnecessary computations in algorithms involving splitting techniques by partial factorization.")) (|removeIrreducibleRedundantFactors| (((|List| |#4|) (|List| |#4|) (|List| |#4|)) "\\axiom{removeIrreducibleRedundantFactors(lp,lq)} returns the same as \\axiom{irreducibleFactors(concat(lp,lq))} assuming that \\axiom{irreducibleFactors(lp)} returns \\axiom{lp} up to replacing some polynomial \\axiom{pj} in \\axiom{lp} by some polynomial \\axiom{qj} associated to \\axiom{pj}.")) (|lazyIrreducibleFactors| (((|List| |#4|) (|List| |#4|)) "\\axiom{lazyIrreducibleFactors(lp)} returns \\axiom{lf} such that if \\axiom{lp = [p1,...,pn]} and \\axiom{lf = [f1,...,fm]} then \\axiom{p1*p2*...*pn=0} means \\axiom{f1*f2*...*fm=0}, and the \\axiom{fi} are irreducible over \\axiom{R} and are pairwise distinct. The algorithm tries to avoid factorization into irreducible factors as far as possible and makes previously use of \\spad{gcd} techniques over \\axiom{R}.")) (|irreducibleFactors| (((|List| |#4|) (|List| |#4|)) "\\axiom{irreducibleFactors(lp)} returns \\axiom{lf} such that if \\axiom{lp = [p1,...,pn]} and \\axiom{lf = [f1,...,fm]} then \\axiom{p1*p2*...*pn=0} means \\axiom{f1*f2*...*fm=0}, and the \\axiom{fi} are irreducible over \\axiom{R} and are pairwise distinct.")) (|removeRedundantFactorsInPols| (((|List| |#4|) (|List| |#4|) (|List| |#4|)) "\\axiom{removeRedundantFactorsInPols(lp,lf)} returns \\axiom{newlp} where \\axiom{newlp} is obtained from \\axiom{lp} by removing in every polynomial \\axiom{p} of \\axiom{lp} any non trivial factor of any polynomial \\axiom{f} in \\axiom{lf}. Moreover, squares over \\axiom{R} are first removed in every polynomial \\axiom{lp}.")) (|removeRedundantFactorsInContents| (((|List| |#4|) (|List| |#4|) (|List| |#4|)) "\\axiom{removeRedundantFactorsInContents(lp,lf)} returns \\axiom{newlp} where \\axiom{newlp} is obtained from \\axiom{lp} by removing in the content of every polynomial of \\axiom{lp} any non trivial factor of any polynomial \\axiom{f} in \\axiom{lf}. Moreover, squares over \\axiom{R} are first removed in the content of every polynomial of \\axiom{lp}.")) (|removeRoughlyRedundantFactorsInContents| (((|List| |#4|) (|List| |#4|) (|List| |#4|)) "\\axiom{removeRoughlyRedundantFactorsInContents(lp,lf)} returns \\axiom{newlp}where \\axiom{newlp} is obtained from \\axiom{lp} by removing in the content of every polynomial of \\axiom{lp} any occurence of a polynomial \\axiom{f} in \\axiom{lf}. Moreover, squares over \\axiom{R} are first removed in the content of every polynomial of \\axiom{lp}.")) (|univariatePolynomialsGcds| (((|List| |#4|) (|List| |#4|) (|Boolean|)) "\\axiom{univariatePolynomialsGcds(lp,opt)} returns the same as \\axiom{univariatePolynomialsGcds(lp)} if \\axiom{opt} is \\axiom{false} and if the previous operation does not return any non null and constant polynomial, else return \\axiom{[1]}.") (((|List| |#4|) (|List| |#4|)) "\\axiom{univariatePolynomialsGcds(lp)} returns \\axiom{lg} where \\axiom{lg} is a list of the gcds of every pair in \\axiom{lp} of univariate polynomials in the same main variable.")) (|squareFreeFactors| (((|List| |#4|) |#4|) "\\axiom{squareFreeFactors(p)} returns the square-free factors of \\axiom{p} over \\axiom{R}")) (|rewriteIdealWithQuasiMonicGenerators| (((|List| |#4|) (|List| |#4|) (|Mapping| (|Boolean|) |#4| |#4|) (|Mapping| |#4| |#4| |#4|)) "\\axiom{rewriteIdealWithQuasiMonicGenerators(lp,redOp?,redOp)} returns \\axiom{lq} where \\axiom{lq} and \\axiom{lp} generate the same ideal in \\axiom{R^(-1) \\spad{P}} and \\axiom{lq} has rank not higher than the one of \\axiom{lp}. Moreover, \\axiom{lq} is computed by reducing \\axiom{lp} w.r.t. some basic set of the ideal generated by the quasi-monic polynomials in \\axiom{lp}.")) (|rewriteSetByReducingWithParticularGenerators| (((|List| |#4|) (|List| |#4|) (|Mapping| (|Boolean|) |#4|) (|Mapping| (|Boolean|) |#4| |#4|) (|Mapping| |#4| |#4| |#4|)) "\\axiom{rewriteSetByReducingWithParticularGenerators(lp,pred?,redOp?,redOp)} returns \\axiom{lq} where \\axiom{lq} is computed by the following algorithm. Chose a basic set w.r.t. the reduction-test \\axiom{redOp?} among the polynomials satisfying property \\axiom{pred?}, if it is empty then leave, else reduce the other polynomials by this basic set w.r.t. the reduction-operation \\axiom{redOp}. Repeat while another basic set with smaller rank can be computed. See code. If \\axiom{pred?} is \\axiom{quasiMonic?} the ideal is unchanged.")) (|crushedSet| (((|List| |#4|) (|List| |#4|)) "\\axiom{crushedSet(lp)} returns \\axiom{lq} such that \\axiom{lp} and and \\axiom{lq} generate the same ideal and no rough basic sets reduce (in the sense of Groebner bases) the other polynomials in \\axiom{lq}.")) (|roughBasicSet| (((|Union| (|Record| (|:| |bas| (|GeneralTriangularSet| |#1| |#2| |#3| |#4|)) (|:| |top| (|List| |#4|))) "failed") (|List| |#4|)) "\\axiom{roughBasicSet(lp)} returns the smallest (with Ritt-Wu ordering) triangular set contained in \\axiom{lp}.")) (|interReduce| (((|List| |#4|) (|List| |#4|)) "\\axiom{interReduce(lp)} returns \\axiom{lq} such that \\axiom{lp} and \\axiom{lq} generate the same ideal and no polynomial in \\axiom{lq} is reducuble by the others in the sense of Groebner bases. Since no assumptions are required the result may depend on the ordering the reductions are performed.")) (|removeRoughlyRedundantFactorsInPol| ((|#4| |#4| (|List| |#4|)) "\\axiom{removeRoughlyRedundantFactorsInPol(p,lf)} returns the same as removeRoughlyRedundantFactorsInPols([p],lf,true)")) (|removeRoughlyRedundantFactorsInPols| (((|List| |#4|) (|List| |#4|) (|List| |#4|) (|Boolean|)) "\\axiom{removeRoughlyRedundantFactorsInPols(lp,lf,opt)} returns the same as \\axiom{removeRoughlyRedundantFactorsInPols(lp,lf)} if \\axiom{opt} is \\axiom{false} and if the previous operation does not return any non null and constant polynomial, else return \\axiom{[1]}.") (((|List| |#4|) (|List| |#4|) (|List| |#4|)) "\\axiom{removeRoughlyRedundantFactorsInPols(lp,lf)} returns \\axiom{newlp}where \\axiom{newlp} is obtained from \\axiom{lp} by removing in every polynomial \\axiom{p} of \\axiom{lp} any occurence of a polynomial \\axiom{f} in \\axiom{lf}. This may involve a lot of exact-quotients computations.")) (|bivariatePolynomials| (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|))) (|List| |#4|)) "\\axiom{bivariatePolynomials(lp)} returns \\axiom{bps,nbps} where \\axiom{bps} is a list of the bivariate polynomials, and \\axiom{nbps} are the other ones.")) (|bivariate?| (((|Boolean|) |#4|) "\\axiom{bivariate?(p)} returns \\spad{true} iff \\axiom{p} involves two and only two variables.")) (|linearPolynomials| (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|))) (|List| |#4|)) "\\axiom{linearPolynomials(lp)} returns \\axiom{lps,nlps} where \\axiom{lps} is a list of the linear polynomials in \\spad{lp,} and \\axiom{nlps} are the other ones.")) (|linear?| (((|Boolean|) |#4|) "\\axiom{linear?(p)} returns \\spad{true} iff \\axiom{p} does not lie in the base ring \\axiom{R} and has main degree \\axiom{1}.")) (|univariatePolynomials| (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|))) (|List| |#4|)) "\\axiom{univariatePolynomials(lp)} returns \\axiom{ups,nups} where \\axiom{ups} is a list of the univariate polynomials, and \\axiom{nups} are the other ones.")) (|univariate?| (((|Boolean|) |#4|) "\\axiom{univariate?(p)} returns \\spad{true} iff \\axiom{p} involves one and only one variable.")) (|quasiMonicPolynomials| (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|))) (|List| |#4|)) "\\axiom{quasiMonicPolynomials(lp)} returns \\axiom{qmps,nqmps} where \\axiom{qmps} is a list of the quasi-monic polynomials in \\axiom{lp} and \\axiom{nqmps} are the other ones.")) (|selectAndPolynomials| (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|))) (|List| (|Mapping| (|Boolean|) |#4|)) (|List| |#4|)) "\\axiom{selectAndPolynomials(lpred?,ps)} returns \\axiom{gps,bps} where \\axiom{gps} is a list of the polynomial \\axiom{p} in \\axiom{ps} such that \\axiom{pred?(p)} holds for every \\axiom{pred?} in \\axiom{lpred?} and \\axiom{bps} are the other ones.")) (|selectOrPolynomials| (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|))) (|List| (|Mapping| (|Boolean|) |#4|)) (|List| |#4|)) "\\axiom{selectOrPolynomials(lpred?,ps)} returns \\axiom{gps,bps} where \\axiom{gps} is a list of the polynomial \\axiom{p} in \\axiom{ps} such that \\axiom{pred?(p)} holds for some \\axiom{pred?} in \\axiom{lpred?} and \\axiom{bps} are the other ones.")) (|selectPolynomials| (((|Record| (|:| |goodPols| (|List| |#4|)) (|:| |badPols| (|List| |#4|))) (|Mapping| (|Boolean|) |#4|) (|List| |#4|)) "\\axiom{selectPolynomials(pred?,ps)} returns \\axiom{gps,bps} where \\axiom{gps} is a list of the polynomial \\axiom{p} in \\axiom{ps} such that \\axiom{pred?(p)} holds and \\axiom{bps} are the other ones.")) (|probablyZeroDim?| (((|Boolean|) (|List| |#4|)) "\\axiom{probablyZeroDim?(lp)} returns \\spad{true} iff the number of polynomials in \\axiom{lp} is not smaller than the number of variables occurring in these polynomials.")) (|possiblyNewVariety?| (((|Boolean|) (|List| |#4|) (|List| (|List| |#4|))) "\\axiom{possiblyNewVariety?(newlp,llp)} returns \\spad{true} iff for every \\axiom{lp} in \\axiom{llp} certainlySubVariety?(newlp,lp) does not hold.")) (|certainlySubVariety?| (((|Boolean|) (|List| |#4|) (|List| |#4|)) "\\axiom{certainlySubVariety?(newlp,lp)} returns \\spad{true} iff for every \\axiom{p} in \\axiom{lp} the remainder of \\axiom{p} by \\axiom{newlp} using the division algorithm of Groebner techniques is zero.")) (|unprotectedRemoveRedundantFactors| (((|List| |#4|) |#4| |#4|) "\\axiom{unprotectedRemoveRedundantFactors(p,q)} returns the same as \\axiom{removeRedundantFactors(p,q)} but does assume that neither \\axiom{p} nor \\axiom{q} lie in the base ring \\axiom{R} and assumes that \\axiom{infRittWu?(p,q)} holds. Moreover, if \\axiom{R} is gcd-domain, then \\axiom{p} and \\axiom{q} are assumed to be square free.")) (|removeSquaresIfCan| (((|List| |#4|) (|List| |#4|)) "\\axiom{removeSquaresIfCan(lp)} returns \\axiom{removeDuplicates [squareFreePart(p)$P for \\spad{p} in lp]} if \\axiom{R} is gcd-domain else returns \\axiom{lp}.")) (|removeRedundantFactors| (((|List| |#4|) (|List| |#4|) (|List| |#4|) (|Mapping| (|List| |#4|) (|List| |#4|))) "\\axiom{removeRedundantFactors(lp,lq,remOp)} returns the same as \\axiom{concat(remOp(removeRoughlyRedundantFactorsInPols(lp,lq)),lq)} assuming that \\axiom{remOp(lq)} returns \\axiom{lq} up to similarity.") (((|List| |#4|) (|List| |#4|) (|List| |#4|)) "\\axiom{removeRedundantFactors(lp,lq)} returns the same as \\axiom{removeRedundantFactors(concat(lp,lq))} assuming that \\axiom{removeRedundantFactors(lp)} returns \\axiom{lp} up to replacing some polynomial \\axiom{pj} in \\axiom{lp} by some polynomial \\axiom{qj} associated to \\axiom{pj}.") (((|List| |#4|) (|List| |#4|) |#4|) "\\axiom{removeRedundantFactors(lp,q)} returns the same as \\axiom{removeRedundantFactors(cons(q,lp))} assuming that \\axiom{removeRedundantFactors(lp)} returns \\axiom{lp} up to replacing some polynomial \\axiom{pj} in \\axiom{lp} by some some polynomial \\axiom{qj} associated to \\axiom{pj}.") (((|List| |#4|) |#4| |#4|) "\\axiom{removeRedundantFactors(p,q)} returns the same as \\axiom{removeRedundantFactors([p,q])}") (((|List| |#4|) (|List| |#4|)) "\\axiom{removeRedundantFactors(lp)} returns \\axiom{lq} such that if \\axiom{lp = [p1,...,pn]} and \\axiom{lq = [q1,...,qm]} then the product \\axiom{p1*p2*...*pn} vanishes iff the product \\axiom{q1*q2*...*qm} vanishes, and the product of degrees of the \\axiom{qi} is not greater than the one of the \\axiom{pj}, and no polynomial in \\axiom{lq} divides another polynomial in \\axiom{lq}. In particular, polynomials lying in the base ring \\axiom{R} are removed. Moreover, \\axiom{lq} is sorted w.r.t \\axiom{infRittWu?}. Furthermore, if \\spad{R} is gcd-domain, the polynomials in \\axiom{lq} are pairwise without common non trivial factor."))) 
NIL 
((AND (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|EuclideanDomain|)))) (|HasCategory| |#1| (QUOTE (|GcdDomain|)))) 
(|PseudoLinearNormalForm| K) 
((|constructor| (NIL "PseudoLinearNormalForm provides a function for computing a block-companion form for pseudo-linear operators.")) (|companionBlocks| (((|List| (|Record| (|:| C (|Matrix| |#1|)) (|:| |g| (|Vector| |#1|)))) (|Matrix| |#1|) (|Vector| |#1|)) "\\spad{companionBlocks(m, \\spad{v)}} returns \\spad{[[C_1, g_1],...,[C_k, g_k]]} such that each \\spad{C_i} is a companion block and \\spad{m = diagonal(C_1,...,C_k)}.")) (|changeBase| (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|) (|Automorphism| |#1|) (|Mapping| |#1| |#1|)) "\\spad{changeBase(M, A, sig, der)}: computes the new matrix of a pseudo-linear transform given by the matrix \\spad{M} under the change of base A")) (|normalForm| (((|Record| (|:| R (|Matrix| |#1|)) (|:| A (|Matrix| |#1|)) (|:| |Ainv| (|Matrix| |#1|))) (|Matrix| |#1|) (|Automorphism| |#1|) (|Mapping| |#1| |#1|)) "\\spad{normalForm(M, sig, der)} returns \\spad{[R, A, A^{-1}]} such that the pseudo-linear operator whose matrix in the basis \\spad{y} is \\spad{M} had matrix \\spad{R} in the basis \\spad{z = A \\spad{y}.} \\spad{der} is a \\spad{sig}-derivation."))) 
NIL 
NIL 
(|PolynomialSquareFree| |VarSet| E RC P) 
((|constructor| (NIL "This package computes square-free decomposition of multivariate polynomials over a coefficient ring which is an arbitrary \\spad{gcd} domain. The requirement on the coefficient domain guarantees that the \\spadfun{content} can be removed so that factors will be primitive as well as square-free. Over an infinite ring of finite characteristic,it may not be possible to guarantee that the factors are square-free.")) (|squareFree| (((|Factored| |#4|) |#4|) "\\spad{squareFree(p)} returns the square-free factorization of the polynomial \\spad{p.} Each factor has no repeated roots, and the factors are pairwise relatively prime."))) 
NIL 
NIL 
(|PointCategory| R) 
((|constructor| (NIL "PointCategory is the category of points in space which may be plotted via the graphics facilities. Functions are provided for defining points and handling elements of points.")) (|extend| (($ $ (|List| |#1|)) "\\spad{extend(x,l,r)} \\undocumented")) (|cross| (($ $ $) "\\spad{cross(p,q)} computes the cross product of the two points \\spad{p} and \\spad{q}. Error if the \\spad{p} and \\spad{q} are not 3 dimensional")) (|convert| (($ (|List| |#1|)) "\\spad{convert(l)} takes a list of elements, \\spad{l,} from the domain Ring and returns the form of point category.")) (|dimension| (((|PositiveInteger|) $) "\\spad{dimension(s)} returns the dimension of the point category \\spad{s.}")) (|point| (($ (|List| |#1|)) "\\spad{point(l)} returns a point category defined by a list \\spad{l} of elements from the domain \\spad{R.}"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|PointFunctions2| R1 R2) 
((|constructor| (NIL "This package has no description")) (|map| (((|Point| |#2|) (|Mapping| |#2| |#1|) (|Point| |#1|)) "\\spad{map(f,p)} \\undocumented"))) 
NIL 
NIL 
(|PointPackage| R) 
((|constructor| (NIL "This package has no description")) (|shade| ((|#1| (|Point| |#1|)) "\\spad{shade(pt)} returns the fourth element of the two dimensional point, \\spad{pt,} although no assumptions are made with regards as to how the components of higher dimensional points are interpreted. This function is defined for the convenience of the user using specifically, shade to express a fourth dimension.")) (|hue| ((|#1| (|Point| |#1|)) "\\spad{hue(pt)} returns the third element of the two dimensional point, \\spad{pt,} although no assumptions are made with regards as to how the components of higher dimensional points are interpreted. This function is defined for the convenience of the user using specifically, hue to express a third dimension.")) (|color| ((|#1| (|Point| |#1|)) "\\spad{color(pt)} returns the fourth element of the point, \\spad{pt,} although no assumptions are made with regards as to how the components of higher dimensional points are interpreted. This function is defined for the convenience of the user using specifically, color to express a fourth dimension.")) (|phiCoord| ((|#1| (|Point| |#1|)) "\\spad{phiCoord(pt)} returns the third element of the point, \\spad{pt,} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a spherical coordinate system.")) (|thetaCoord| ((|#1| (|Point| |#1|)) "\\spad{thetaCoord(pt)} returns the second element of the point, \\spad{pt,} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a spherical or a cylindrical coordinate system.")) (|rCoord| ((|#1| (|Point| |#1|)) "\\spad{rCoord(pt)} returns the first element of the point, \\spad{pt,} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a spherical or a cylindrical coordinate system.")) (|zCoord| ((|#1| (|Point| |#1|)) "\\spad{zCoord(pt)} returns the third element of the point, \\spad{pt,} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a Cartesian or a cylindrical coordinate system.")) (|yCoord| ((|#1| (|Point| |#1|)) "\\spad{yCoord(pt)} returns the second element of the point, \\spad{pt,} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a Cartesian coordinate system.")) (|xCoord| ((|#1| (|Point| |#1|)) "\\spad{xCoord(pt)} returns the first element of the point, \\spad{pt,} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a Cartesian coordinate system."))) 
NIL 
NIL 
(|PartialTranscendentalFunctions| K) 
((|constructor| (NIL "A package which provides partial transcendental functions, for example, functions which return an answer or \"failed\" This is the description of any package which provides partial functions on a domain belonging to TranscendentalFunctionCategory.")) (|acschIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{acschIfCan(z)} returns acsch(z) if possible, and \"failed\" otherwise.")) (|asechIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{asechIfCan(z)} returns asech(z) if possible, and \"failed\" otherwise.")) (|acothIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{acothIfCan(z)} returns acoth(z) if possible, and \"failed\" otherwise.")) (|atanhIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{atanhIfCan(z)} returns atanh(z) if possible, and \"failed\" otherwise.")) (|acoshIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{acoshIfCan(z)} returns acosh(z) if possible, and \"failed\" otherwise.")) (|asinhIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{asinhIfCan(z)} returns asinh(z) if possible, and \"failed\" otherwise.")) (|cschIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{cschIfCan(z)} returns csch(z) if possible, and \"failed\" otherwise.")) (|sechIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{sechIfCan(z)} returns sech(z) if possible, and \"failed\" otherwise.")) (|cothIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{cothIfCan(z)} returns coth(z) if possible, and \"failed\" otherwise.")) (|tanhIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{tanhIfCan(z)} returns tanh(z) if possible, and \"failed\" otherwise.")) (|coshIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{coshIfCan(z)} returns cosh(z) if possible, and \"failed\" otherwise.")) (|sinhIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{sinhIfCan(z)} returns sinh(z) if possible, and \"failed\" otherwise.")) (|acscIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{acscIfCan(z)} returns acsc(z) if possible, and \"failed\" otherwise.")) (|asecIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{asecIfCan(z)} returns asec(z) if possible, and \"failed\" otherwise.")) (|acotIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{acotIfCan(z)} returns acot(z) if possible, and \"failed\" otherwise.")) (|atanIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{atanIfCan(z)} returns atan(z) if possible, and \"failed\" otherwise.")) (|acosIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{acosIfCan(z)} returns acos(z) if possible, and \"failed\" otherwise.")) (|asinIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{asinIfCan(z)} returns asin(z) if possible, and \"failed\" otherwise.")) (|cscIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{cscIfCan(z)} returns csc(z) if possible, and \"failed\" otherwise.")) (|secIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{secIfCan(z)} returns sec(z) if possible, and \"failed\" otherwise.")) (|cotIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{cotIfCan(z)} returns cot(z) if possible, and \"failed\" otherwise.")) (|tanIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{tanIfCan(z)} returns tan(z) if possible, and \"failed\" otherwise.")) (|cosIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{cosIfCan(z)} returns cos(z) if possible, and \"failed\" otherwise.")) (|sinIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{sinIfCan(z)} returns sin(z) if possible, and \"failed\" otherwise.")) (|logIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{logIfCan(z)} returns log(z) if possible, and \"failed\" otherwise.")) (|expIfCan| (((|Union| |#1| "failed") |#1|) "\\spad{expIfCan(z)} returns exp(z) if possible, and \"failed\" otherwise.")) (|nthRootIfCan| (((|Union| |#1| "failed") |#1| (|NonNegativeInteger|)) "\\spad{nthRootIfCan(z,n)} returns the \\spad{n}th root of \\spad{z} if possible, and \"failed\" otherwise."))) 
NIL 
NIL 
(|PushVariables| R E OV PPR) 
((|constructor| (NIL "This package has no description")) (|map| ((|#4| (|Mapping| |#4| (|Polynomial| |#1|)) |#4|) "\\spad{map(f,p)} \\undocumented{}")) (|pushup| ((|#4| |#4| (|List| |#3|)) "\\spad{pushup(p,lv)} \\undocumented{}") ((|#4| |#4| |#3|) "\\spad{pushup(p,v)} \\undocumented{}")) (|pushdown| ((|#4| |#4| (|List| |#3|)) "\\spad{pushdown(p,lv)} \\undocumented{}") ((|#4| |#4| |#3|) "\\spad{pushdown(p,v)} \\undocumented{}")) (|variable| (((|Union| $ "failed") (|Symbol|)) "\\spad{variable(s)} makes an element from symbol \\spad{s} or fails")) (|convert| (((|Symbol|) $) "\\spad{convert(x)} converts \\spad{x} to a symbol"))) 
NIL 
NIL 
(|PAdicWildFunctionFieldIntegralBasis| K R UP F) 
((|constructor| (NIL "In this package \\spad{K} is a finite field, \\spad{R} is a ring of univariate polynomials over \\spad{K,} and \\spad{F} is a monogenic algebra over \\spad{R.} We require that \\spad{F} is monogenic, \\spadignore{i.e.} that \\spad{F = K[x,y]/(f(x,y))}, because the integral basis algorithm used will factor the polynomial \\spad{f(x,y)}. The package provides a function to compute the integral closure of \\spad{R} in the quotient field of \\spad{F} as well as a function to compute a \"local integral basis\" at a specific prime.")) (|reducedDiscriminant| ((|#2| |#3|) "\\spad{reducedDiscriminant(up)} \\undocumented")) (|localIntegralBasis| (((|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|) (|:| |basisInv| (|Matrix| |#2|))) |#2|) "\\spad{integralBasis(p)} returns a record \\spad{[basis,basisDen,basisInv] } containing information regarding the local integral closure of \\spad{R} at the prime \\spad{p} in the quotient field of the framed algebra \\spad{F.} \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn}. If 'basis' is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the local integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of 'basis' contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix 'basisInv' contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if 'basisInv' is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}.")) (|integralBasis| (((|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|) (|:| |basisInv| (|Matrix| |#2|)))) "\\spad{integralBasis()} returns a record \\spad{[basis,basisDen,basisInv] } containing information regarding the integral closure of \\spad{R} in the quotient field of the framed algebra \\spad{F.} \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn}. If 'basis' is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of 'basis' contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix 'basisInv' contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if 'basisInv' is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}."))) 
NIL 
NIL 
(|QuasiAlgebraicSet2| |vl| |nv|) 
((|constructor| (NIL "\\spadtype{QuasiAlgebraicSet2} adds a function \\spadfun{radicalSimplify} which uses \\spadtype{IdealDecompositionPackage} to simplify the representation of a quasi-algebraic set. A quasi-algebraic set is the intersection of a Zariski closed set, defined as the common zeros of a given list of polynomials (the defining polynomials for equations), and a principal Zariski open set, defined as the complement of the common zeros of a polynomial \\spad{f} (the defining polynomial for the inequation). Quasi-algebraic sets are implemented in the domain \\spadtype{QuasiAlgebraicSet}, where two simplification routines are provided: \\spadfun{idealSimplify} and \\spadfun{simplify}. The function \\spadfun{radicalSimplify} is added for comparison study only. Because the domain \\spadtype{IdealDecompositionPackage} provides facilities for computing with radical ideals, it is necessary to restrict the ground ring to the domain \\spadtype{Fraction Integer}, and the polynomial ring to be of type \\spadtype{DistributedMultivariatePolynomial}. The routine \\spadfun{radicalSimplify} uses these to compute groebner basis of radical ideals and is inefficient and restricted when compared to the two in \\spadtype{QuasiAlgebraicSet}.")) (|radicalSimplify| (((|QuasiAlgebraicSet| (|Fraction| (|Integer|)) (|OrderedVariableList| |#1|) (|DirectProduct| |#2| (|NonNegativeInteger|)) (|DistributedMultivariatePolynomial| |#1| (|Fraction| (|Integer|)))) (|QuasiAlgebraicSet| (|Fraction| (|Integer|)) (|OrderedVariableList| |#1|) (|DirectProduct| |#2| (|NonNegativeInteger|)) (|DistributedMultivariatePolynomial| |#1| (|Fraction| (|Integer|))))) "\\spad{radicalSimplify(s)} returns a different and presumably simpler representation of \\spad{s} with the defining polynomials for the equations forming a groebner basis, and the defining polynomial for the inequation reduced with respect to the basis, using using groebner basis of radical ideals"))) 
NIL 
NIL 
(|QuasiAlgebraicSet| R |Var| |Expon| |Dpoly|) 
((|constructor| (NIL "\\spadtype{QuasiAlgebraicSet} constructs a domain representing quasi-algebraic sets, which is the intersection of a Zariski closed set, defined as the common zeros of a given list of polynomials (the defining polynomials for equations), and a principal Zariski open set, defined as the complement of the common zeros of a polynomial \\spad{f} (the defining polynomial for the inequation). This domain provides simplification of a user-given representation using groebner basis computations. There are two simplification routines: the first function \\spadfun{idealSimplify} uses groebner basis of ideals alone, while the second, \\spadfun{simplify} uses both groebner basis and factorization. The resulting defining equations \\spad{L} always form a groebner basis, and the resulting defining inequation \\spad{f} is always reduced. The function \\spadfun{simplify} may be applied several times if desired. A third simplification routine \\spadfun{radicalSimplify} is provided in \\spadtype{QuasiAlgebraicSet2} for comparison study only, as it is inefficient compared to the other two, as well as is restricted to only certain coefficient domains. For detail analysis and a comparison of the three methods, please consult the reference cited. \\blankline A polynomial function \\spad{q} defined on the quasi-algebraic set is equivalent to its reduced form with respect to \\spad{L.} While this may be obtained using the usual normal form algorithm, there is no canonical form for \\spad{q.} \\blankline The ordering in groebner basis computation is determined by the data type of the input polynomials. If it is possible we suggest to use refinements of total degree orderings.")) (|simplify| (($ $) "\\spad{simplify(s)} returns a different and presumably simpler representation of \\spad{s} with the defining polynomials for the equations forming a groebner basis, and the defining polynomial for the inequation reduced with respect to the basis, using a heuristic algorithm based on factoring.")) (|idealSimplify| (($ $) "\\spad{idealSimplify(s)} returns a different and presumably simpler representation of \\spad{s} with the defining polynomials for the equations forming a groebner basis, and the defining polynomial for the inequation reduced with respect to the basis, using Buchberger's algorithm.")) (|definingInequation| ((|#4| $) "\\spad{definingInequation(s)} returns a single defining polynomial for the inequation, that is, the Zariski open part of \\spad{s.}")) (|definingEquations| (((|List| |#4|) $) "\\spad{definingEquations(s)} returns a list of defining polynomials for equations, that is, for the Zariski closed part of \\spad{s.}")) (|empty?| (((|Boolean|) $) "\\spad{empty?(s)} returns \\spad{true} if the quasialgebraic set \\spad{s} has no points, and \\spad{false} otherwise.")) (|setStatus| (($ $ (|Union| (|Boolean|) "failed")) "\\spad{setStatus(s,t)} returns the same representation for \\spad{s,} but asserts the following: if \\spad{t} is true, then \\spad{s} is empty, if \\spad{t} is false, then \\spad{s} is non-empty, and if \\spad{t} = \"failed\", then no assertion is made (that is, \"don't know\"). Note: for internal use only, with care.")) (|status| (((|Union| (|Boolean|) "failed") $) "\\spad{status(s)} returns \\spad{true} if the quasi-algebraic set is empty, \\spad{false} if it is not, and \"failed\" if not yet known")) (|quasiAlgebraicSet| (($ (|List| |#4|) |#4|) "\\spad{quasiAlgebraicSet(pl,q)} returns the quasi-algebraic set with defining equations \\spad{p} = 0 for \\spad{p} belonging to the list \\spad{pl,} and defining inequation \\spad{q} \\spad{^=} 0.")) (|empty| (($) "\\spad{empty()} returns the empty quasi-algebraic set"))) 
NIL 
((AND (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|EuclideanDomain|))))) 
(|QuasiComponentPackage| R E V P TS) 
((|constructor| (NIL "A package for removing redundant quasi-components and redundant branches when decomposing a variety by means of quasi-components of regular triangular sets.")) (|branchIfCan| (((|Union| (|Record| (|:| |eq| (|List| |#4|)) (|:| |tower| |#5|) (|:| |ineq| (|List| |#4|))) "failed") (|List| |#4|) |#5| (|List| |#4|) (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|)) "\\axiom{branchIfCan(leq,ts,lineq,b1,b2,b3,b4,b5)} is an internal subroutine, exported only for developement.")) (|prepareDecompose| (((|List| (|Record| (|:| |eq| (|List| |#4|)) (|:| |tower| |#5|) (|:| |ineq| (|List| |#4|)))) (|List| |#4|) (|List| |#5|) (|Boolean|) (|Boolean|)) "\\axiom{prepareDecompose(lp,lts,b1,b2)} is an internal subroutine, exported only for developement.")) (|removeSuperfluousCases| (((|List| (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|))) (|List| (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|)))) "\\axiom{removeSuperfluousCases(llpwt)} is an internal subroutine, exported only for developement.")) (|subCase?| (((|Boolean|) (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|)) (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|))) "\\axiom{subCase?(lpwt1,lpwt2)} is an internal subroutine, exported only for developement.")) (|removeSuperfluousQuasiComponents| (((|List| |#5|) (|List| |#5|)) "\\axiom{removeSuperfluousQuasiComponents(lts)} removes from \\axiom{lts} any \\spad{ts} such that \\axiom{subQuasiComponent?(ts,us)} holds for another \\spad{us} in \\axiom{lts}.")) (|subQuasiComponent?| (((|Boolean|) |#5| (|List| |#5|)) "\\axiom{subQuasiComponent?(ts,lus)} returns \\spad{true} iff \\axiom{subQuasiComponent?(ts,us)} holds for one \\spad{us} in \\spad{lus}.") (((|Boolean|) |#5| |#5|) "\\axiom{subQuasiComponent?(ts,us)} returns \\spad{true} iff internalSubQuasiComponent? returs true.")) (|internalSubQuasiComponent?| (((|Union| (|Boolean|) "failed") |#5| |#5|) "\\axiom{internalSubQuasiComponent?(ts,us)} returns a boolean \\spad{b} value if the fact that the regular zero set of \\axiom{us} contains that of \\axiom{ts} can be decided (and in that case \\axiom{b} gives this inclusion) otherwise returns \\axiom{\"failed\"}.")) (|infRittWu?| (((|Boolean|) (|List| |#4|) (|List| |#4|)) "\\axiom{infRittWu?(lp1,lp2)} is an internal subroutine, exported only for developement.")) (|internalInfRittWu?| (((|Boolean|) (|List| |#4|) (|List| |#4|)) "\\axiom{internalInfRittWu?(lp1,lp2)} is an internal subroutine, exported only for developement.")) (|internalSubPolSet?| (((|Boolean|) (|List| |#4|) (|List| |#4|)) "\\axiom{internalSubPolSet?(lp1,lp2)} returns \\spad{true} iff \\axiom{lp1} is a sub-set of \\axiom{lp2} assuming that these lists are sorted increasingly w.r.t. infRittWu? from RecursivePolynomialCategory.")) (|subPolSet?| (((|Boolean|) (|List| |#4|) (|List| |#4|)) "\\axiom{subPolSet?(lp1,lp2)} returns \\spad{true} iff \\axiom{lp1} is a sub-set of \\axiom{lp2}.")) (|subTriSet?| (((|Boolean|) |#5| |#5|) "\\axiom{subTriSet?(ts,us)} returns \\spad{true} iff \\axiom{ts} is a sub-set of \\axiom{us}.")) (|moreAlgebraic?| (((|Boolean|) |#5| |#5|) "\\axiom{moreAlgebraic?(ts,us)} returns \\spad{false} iff \\axiom{ts} and \\axiom{us} are both empty, or \\axiom{ts} has less elements than \\axiom{us}, or some variable is algebraic w.r.t. \\axiom{us} and is not w.r.t. \\axiom{ts}.")) (|algebraicSort| (((|List| |#5|) (|List| |#5|)) "\\axiom{algebraicSort(lts)} sorts \\axiom{lts} w.r.t supDimElseRittWu?")) (|supDimElseRittWu?| (((|Boolean|) |#5| |#5|) "\\axiom{supDimElseRittWu(ts,us)} returns \\spad{true} iff \\axiom{ts} has less elements than \\axiom{us} otherwise if \\axiom{ts} has higher rank than \\axiom{us} w.r.t. Riit and Wu ordering.")) (|stopTable!| (((|Void|)) "\\axiom{stopTableGcd!()} is an internal subroutine, exported only for developement.")) (|startTable!| (((|Void|) (|String|) (|String|) (|String|)) "\\axiom{startTableGcd!(s1,s2,s3)} is an internal subroutine, exported only for developement."))) 
NIL 
NIL 
(|QueryEquation|) 
((|constructor| (NIL "This domain implements simple database queries")) (|value| (((|String|) $) "\\spad{value(q)} returns the value (\\spadignore{i.e.} right hand side) of \\axiom{q}.")) (|variable| (((|Symbol|) $) "\\spad{variable(q)} returns the variable (\\spadignore{i.e.} left hand side) of \\axiom{q}.")) (|equation| (($ (|Symbol|) (|String|)) "\\spad{equation(s,\"a\")} creates a new equation."))) 
NIL 
NIL 
(|QuotientFieldCategoryFunctions2| A B R S) 
((|constructor| (NIL "This package extends a function between integral domains to a mapping between their quotient fields.")) (|map| ((|#4| (|Mapping| |#2| |#1|) |#3|) "\\spad{map(func,frac)} applies the function \\spad{func} to the numerator and denominator of frac."))) 
NIL 
NIL 
(|QuotientFieldCategory&| A S) 
((|constructor| (NIL "QuotientField(S) is the category of fractions of an Integral Domain \\spad{S.}")) (|floor| ((|#2| $) "\\spad{floor(x)} returns the largest integral element below \\spad{x.}")) (|ceiling| ((|#2| $) "\\spad{ceiling(x)} returns the smallest integral element above \\spad{x.}")) (|random| (($) "\\spad{random()} returns a random fraction.")) (|fractionPart| (($ $) "\\spad{fractionPart(x)} returns the fractional part of \\spad{x.} \\spad{x} = wholePart(x) + fractionPart(x)")) (|wholePart| ((|#2| $) "\\spad{wholePart(x)} returns the whole part of the fraction \\spad{x} \\spadignore{i.e.} the truncated quotient of the numerator by the denominator.")) (|denominator| (($ $) "\\spad{denominator(x)} is the denominator of the fraction \\spad{x} converted to \\spad{%.}")) (|numerator| (($ $) "\\spad{numerator(x)} is the numerator of the fraction \\spad{x} converted to \\spad{%.}")) (|denom| ((|#2| $) "\\spad{denom(x)} returns the denominator of the fraction \\spad{x.}")) (|numer| ((|#2| $) "\\spad{numer(x)} returns the numerator of the fraction \\spad{x.}")) (/ (($ |#2| |#2|) "\\spad{d1 / \\spad{d2}} returns the fraction \\spad{d1} divided by \\spad{d2.}"))) 
NIL 
((|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#2| (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#2| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (QUOTE (|RealConstant|))) (|HasCategory| |#2| (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#2| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|StepThrough|)))) 
(|QuotientFieldCategory| S) 
((|constructor| (NIL "QuotientField(S) is the category of fractions of an Integral Domain \\spad{S.}")) (|floor| ((|#1| $) "\\spad{floor(x)} returns the largest integral element below \\spad{x.}")) (|ceiling| ((|#1| $) "\\spad{ceiling(x)} returns the smallest integral element above \\spad{x.}")) (|random| (($) "\\spad{random()} returns a random fraction.")) (|fractionPart| (($ $) "\\spad{fractionPart(x)} returns the fractional part of \\spad{x.} \\spad{x} = wholePart(x) + fractionPart(x)")) (|wholePart| ((|#1| $) "\\spad{wholePart(x)} returns the whole part of the fraction \\spad{x} \\spadignore{i.e.} the truncated quotient of the numerator by the denominator.")) (|denominator| (($ $) "\\spad{denominator(x)} is the denominator of the fraction \\spad{x} converted to \\spad{%.}")) (|numerator| (($ $) "\\spad{numerator(x)} is the numerator of the fraction \\spad{x} converted to \\spad{%.}")) (|denom| ((|#1| $) "\\spad{denom(x)} returns the denominator of the fraction \\spad{x.}")) (|numer| ((|#1| $) "\\spad{numer(x)} returns the numerator of the fraction \\spad{x.}")) (/ (($ |#1| |#1|) "\\spad{d1 / \\spad{d2}} returns the fraction \\spad{d1} divided by \\spad{d2.}"))) 
((|nil| . T) (|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|QuadraticForm| |n| K) 
((|constructor| (NIL "This domain provides modest support for quadratic forms.")) (|elt| ((|#2| $ (|DirectProduct| |#1| |#2|)) "\\spad{elt(qf,v)} evaluates the quadratic form \\spad{qf} on the vector \\spad{v,} producing a scalar.")) (|matrix| (((|SquareMatrix| |#1| |#2|) $) "\\spad{matrix(qf)} creates a square matrix from the quadratic form \\spad{qf.}")) (|quadraticForm| (($ (|SquareMatrix| |#1| |#2|)) "\\spad{quadraticForm(m)} creates a quadratic form from a symmetric, square matrix \\spad{m.}"))) 
NIL 
NIL 
(|QueueAggregate| S) 
((|constructor| (NIL "A queue is a bag where the first item inserted is the first item extracted.")) (|back| ((|#1| $) "\\spad{back(q)} returns the element at the back of the queue. The queue \\spad{q} is unchanged by this operation. Error: if \\spad{q} is empty.")) (|front| ((|#1| $) "\\spad{front(q)} returns the element at the front of the queue. The queue \\spad{q} is unchanged by this operation. Error: if \\spad{q} is empty.")) (|length| (((|NonNegativeInteger|) $) "\\spad{length(q)} returns the number of elements in the queue. Note that \\axiom{length(q) = \\#q}.")) (|rotate!| (($ $) "\\spad{rotate! \\spad{q}} rotates queue \\spad{q} so that the element at the front of the queue goes to the back of the queue. Note that rotate! \\spad{q} is equivalent to enqueue!(dequeue!(q)).")) (|dequeue!| ((|#1| $) "\\spad{dequeue! \\spad{s}} destructively extracts the first (top) element from queue \\spad{q.} The element previously second in the queue becomes the first element. Error: if \\spad{q} is empty.")) (|enqueue!| ((|#1| |#1| $) "\\spad{enqueue!(x,q)} inserts \\spad{x} into the queue \\spad{q} at the back end."))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|QuaternionCategory&| S R) 
((|constructor| (NIL "\\spadtype{QuaternionCategory} describes the category of quaternions and implements functions that are not representation specific.")) (|rationalIfCan| (((|Union| (|Fraction| (|Integer|)) "failed") $) "\\spad{rationalIfCan(q)} returns \\spad{q} as a rational number, or \"failed\" if this is not possible. Note that if \\spad{rational?(q)} is true, the conversion can be done and the rational number will be returned.")) (|rational| (((|Fraction| (|Integer|)) $) "\\spad{rational(q)} tries to convert \\spad{q} into a rational number. Error: if this is not possible. If \\spad{rational?(q)} is true, the conversion will be done and the rational number returned.")) (|rational?| (((|Boolean|) $) "\\spad{rational?(q)} returns {\\it true} if all the imaginary parts of \\spad{q} are zero and the real part can be converted into a rational number, and {\\it false} otherwise.")) (|abs| ((|#2| $) "\\spad{abs(q)} computes the absolute value of quaternion \\spad{q} (sqrt of norm).")) (|real| ((|#2| $) "\\spad{real(q)} extracts the real part of quaternion \\spad{q}.")) (|quatern| (($ |#2| |#2| |#2| |#2|) "\\spad{quatern(r,i,j,k)} constructs a quaternion from scalars.")) (|norm| ((|#2| $) "\\spad{norm(q)} computes the norm of \\spad{q} (the sum of the squares of the components).")) (|imagK| ((|#2| $) "\\spad{imagK(q)} extracts the imaginary \\spad{k} part of quaternion \\spad{q}.")) (|imagJ| ((|#2| $) "\\spad{imagJ(q)} extracts the imaginary \\spad{j} part of quaternion \\spad{q}.")) (|imagI| ((|#2| $) "\\spad{imagI(q)} extracts the imaginary \\spad{i} part of quaternion \\spad{q}.")) (|conjugate| (($ $) "\\spad{conjugate(q)} negates the imaginary parts of quaternion \\spad{q}."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#2| (QUOTE (|RealNumberSystem|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|EntireRing|)))) 
(|QuaternionCategory| R) 
((|constructor| (NIL "\\spadtype{QuaternionCategory} describes the category of quaternions and implements functions that are not representation specific.")) (|rationalIfCan| (((|Union| (|Fraction| (|Integer|)) "failed") $) "\\spad{rationalIfCan(q)} returns \\spad{q} as a rational number, or \"failed\" if this is not possible. Note that if \\spad{rational?(q)} is true, the conversion can be done and the rational number will be returned.")) (|rational| (((|Fraction| (|Integer|)) $) "\\spad{rational(q)} tries to convert \\spad{q} into a rational number. Error: if this is not possible. If \\spad{rational?(q)} is true, the conversion will be done and the rational number returned.")) (|rational?| (((|Boolean|) $) "\\spad{rational?(q)} returns {\\it true} if all the imaginary parts of \\spad{q} are zero and the real part can be converted into a rational number, and {\\it false} otherwise.")) (|abs| ((|#1| $) "\\spad{abs(q)} computes the absolute value of quaternion \\spad{q} (sqrt of norm).")) (|real| ((|#1| $) "\\spad{real(q)} extracts the real part of quaternion \\spad{q}.")) (|quatern| (($ |#1| |#1| |#1| |#1|) "\\spad{quatern(r,i,j,k)} constructs a quaternion from scalars.")) (|norm| ((|#1| $) "\\spad{norm(q)} computes the norm of \\spad{q} (the sum of the squares of the components).")) (|imagK| ((|#1| $) "\\spad{imagK(q)} extracts the imaginary \\spad{k} part of quaternion \\spad{q}.")) (|imagJ| ((|#1| $) "\\spad{imagJ(q)} extracts the imaginary \\spad{j} part of quaternion \\spad{q}.")) (|imagI| ((|#1| $) "\\spad{imagI(q)} extracts the imaginary \\spad{i} part of quaternion \\spad{q}.")) (|conjugate| (($ $) "\\spad{conjugate(q)} negates the imaginary parts of quaternion \\spad{q}."))) 
((|noZeroDivisors| |has| |#1| (|EntireRing|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|QuaternionCategoryFunctions2| QR R QS S) 
((|constructor| (NIL "\\spadtype{QuaternionCategoryFunctions2} implements functions between two quaternion domains. The function \\spadfun{map} is used by the system interpreter to coerce between quaternion types.")) (|map| ((|#3| (|Mapping| |#4| |#2|) |#1|) "\\indented{1}{map(f,u) maps \\spad{f} onto the component parts of the quaternion u.} \\indented{1}{to convert an expression in Quaterion(R) to Quaternion(S)} \\blankline \\spad{X} f(a:FRAC(INT)):COMPLEX(FRAC(INT)) \\spad{==} a::COMPLEX(FRAC(INT)) \\spad{X} q:=quatern(2/11,-8,3/4,1) \\spad{X} map(f,q)"))) 
NIL 
NIL 
(|Quaternion| R) 
((|constructor| (NIL "\\spadtype{Quaternion} implements quaternions over a commutative ring. The main constructor function is \\spadfun{quatern} which takes 4 arguments: the real part, the \\spad{i} imaginary part, the \\spad{j} imaginary part and the \\spad{k} imaginary part."))) 
((|noZeroDivisors| |has| |#1| (|EntireRing|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|EntireRing|))) (OR (|HasCategory| |#1| (QUOTE (|EntireRing|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (|devaluate| |#1|))) (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (LIST (QUOTE |Eltable|) (|devaluate| |#1|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|RealNumberSystem|))) (|HasCategory| |#1| (QUOTE (|IntegerNumberSystem|))) (OR (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|Field|))))) 
(|Queue| S) 
((|constructor| (NIL "Linked List implementation of a Queue")) (|member?| (((|Boolean|) |#1| $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} member?(3,a)")) (|members| (((|List| |#1|) $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} members a")) (|parts| (((|List| |#1|) $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} parts a")) (|#| (((|NonNegativeInteger|) $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} \\#a")) (|count| (((|NonNegativeInteger|) |#1| $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} count(4,a)") (((|NonNegativeInteger|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} count(x+->(x>2),a)")) (|any?| (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} any?(x+->(x=4),a)")) (|every?| (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} every?(x+->(x=4),a)")) (~= (((|Boolean|) $ $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} b:=copy a \\spad{X} (a~=b)")) (= (((|Boolean|) $ $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} b:Queue INT:= queue [1,2,3,4,5] \\spad{X} (a=b)@Boolean")) (|coerce| (((|OutputForm|) $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} coerce a")) (|hash| (((|SingleInteger|) $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} hash a")) (|latex| (((|String|) $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} latex a")) (|map!| (($ (|Mapping| |#1| |#1|) $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} map!(x+->x+10,a) \\spad{X} a")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} map(x+->x+10,a) \\spad{X} a")) (|eq?| (((|Boolean|) $ $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} b:=copy a \\spad{X} eq?(a,b)")) (|copy| (($ $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} copy a")) (|sample| (($) "\\blankline \\spad{X} sample()$Queue(INT)")) (|empty| (($) "\\blankline \\spad{X} b:=empty()$(Queue INT)")) (|empty?| (((|Boolean|) $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} empty? a")) (|bag| (($ (|List| |#1|)) "\\blankline \\spad{X} bag([1,2,3,4,5])$Queue(INT)")) (|size?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} size?(a,5)")) (|more?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} more?(a,9)")) (|less?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} less?(a,9)")) (|length| (((|NonNegativeInteger|) $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} length a")) (|rotate!| (($ $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} rotate! a")) (|back| ((|#1| $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} back a")) (|front| ((|#1| $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} front a")) (|inspect| ((|#1| $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} inspect a")) (|insert!| (($ |#1| $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} insert! (8,a) \\spad{X} a")) (|enqueue!| ((|#1| |#1| $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} enqueue! (9,a) \\spad{X} a")) (|extract!| ((|#1| $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} extract! a \\spad{X} a")) (|dequeue!| ((|#1| $) "\\blankline \\spad{X} a:Queue INT:= queue [1,2,3,4,5] \\spad{X} dequeue! a \\spad{X} a")) (|queue| (($ (|List| |#1|)) "\\indented{1}{queue([x,y,...,z]) creates a queue with first (top)} \\indented{1}{element \\spad{x,} second element y,...,and last (bottom) element \\spad{z.}} \\blankline \\spad{E} e:Queue INT:= queue [1,2,3,4,5]"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|RadicalCategory&| S) 
((|constructor| (NIL "Description:")) (** (($ $ (|Fraction| (|Integer|))) "\\spad{x \\spad{**} \\spad{y}} is the rational exponentiation of \\spad{x} by the power \\spad{y.}")) (|nthRoot| (($ $ (|Integer|)) "\\spad{nthRoot(x,n)} returns the \\spad{n}th root of \\spad{x.}")) (|sqrt| (($ $) "\\spad{sqrt(x)} returns the square root of \\spad{x.}"))) 
NIL 
NIL 
(|RadicalCategory|) 
((|constructor| (NIL "Description:")) (** (($ $ (|Fraction| (|Integer|))) "\\spad{x \\spad{**} \\spad{y}} is the rational exponentiation of \\spad{x} by the power \\spad{y.}")) (|nthRoot| (($ $ (|Integer|)) "\\spad{nthRoot(x,n)} returns the \\spad{n}th root of \\spad{x.}")) (|sqrt| (($ $) "\\spad{sqrt(x)} returns the square root of \\spad{x.}"))) 
NIL 
NIL 
(|RadicalFunctionField| F UP UPUP |radicnd| |n|) 
((|constructor| (NIL "Function field defined by y**n = f(x)."))) 
((|noZeroDivisors| |has| (|Fraction| |#2|) (|Field|)) (|canonicalUnitNormal| |has| (|Fraction| |#2|) (|Field|)) (|canonicalsClosed| |has| (|Fraction| |#2|) (|Field|)) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|Fraction| |#2|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|FiniteFieldCategory|))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|))) (OR (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|FiniteFieldCategory|)))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Finite|))) (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|Finite|))) (OR (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|)))) (AND (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|)))) (OR (AND (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|)))) (AND (|HasCategory| (|Fraction| |#2|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|FiniteFieldCategory|))))) (AND (|HasCategory| (|Fraction| |#2|) (QUOTE (|DifferentialRing|))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|)))) (OR (AND (|HasCategory| (|Fraction| |#2|) (QUOTE (|DifferentialRing|))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|Field|)))) (|HasCategory| (|Fraction| |#2|) (QUOTE (|FiniteFieldCategory|))))) 
(|RadixExpansion| |bb|) 
((|constructor| (NIL "This domain allows rational numbers to be presented as repeating decimal expansions or more generally as repeating expansions in any base.")) (|fractRadix| (($ (|List| (|Integer|)) (|List| (|Integer|))) "\\spad{fractRadix(pre,cyc)} creates a fractional radix expansion from a list of prefix ragits and a list of cyclic ragits. \\spadignore{e.g.} \\spad{fractRadix([1],[6])} will return \\spad{0.16666666...}.")) (|wholeRadix| (($ (|List| (|Integer|))) "\\spad{wholeRadix(l)} creates an integral radix expansion from a list of ragits. For example, \\spad{wholeRadix([1,3,4])} will return \\spad{134}.")) (|cycleRagits| (((|List| (|Integer|)) $) "\\spad{cycleRagits(rx)} returns the cyclic part of the ragits of the fractional part of a radix expansion. For example, if \\spad{x = 3/28 = 0.10 714285 714285 ...}, then \\spad{cycleRagits(x) = [7,1,4,2,8,5]}.")) (|prefixRagits| (((|List| (|Integer|)) $) "\\spad{prefixRagits(rx)} returns the non-cyclic part of the ragits of the fractional part of a radix expansion. For example, if \\spad{x = 3/28 = 0.10 714285 714285 ...}, then \\spad{prefixRagits(x)=[1,0]}.")) (|fractRagits| (((|Stream| (|Integer|)) $) "\\spad{fractRagits(rx)} returns the ragits of the fractional part of a radix expansion.")) (|wholeRagits| (((|List| (|Integer|)) $) "\\spad{wholeRagits(rx)} returns the ragits of the integer part of a radix expansion.")) (|fractionPart| (((|Fraction| (|Integer|)) $) "\\spad{fractionPart(rx)} returns the fractional part of a radix expansion.")) (|coerce| (((|Fraction| (|Integer|)) $) "\\spad{coerce(rx)} converts a radix expansion to a rational number."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|Integer|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| (|Integer|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| (|Integer|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Integer|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Integer|) (QUOTE (|RealConstant|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|Integer|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|StepThrough|))) (|HasCategory| (|Integer|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| (|Integer|) (QUOTE (|DifferentialRing|))) (|HasCategory| (|Integer|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |Eltable|) (QUOTE (|Integer|)) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|Integer|) (QUOTE (|IntegerNumberSystem|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (OR (|HasCategory| (|Integer|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|)))) (|HasCategory| (|Integer|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Integer|) (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|Integer|) (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| (|Integer|) (QUOTE (|CharacteristicNonZero|))))) 
(|RadixUtilities|) 
((|constructor| (NIL "This package provides tools for creating radix expansions.")) (|radix| (((|Any|) (|Fraction| (|Integer|)) (|Integer|)) "\\spad{radix(x,b)} converts \\spad{x} to a radix expansion in base \\spad{b.}"))) 
NIL 
NIL 
(|RandomNumberSource|) 
((|constructor| (NIL "Random number generators. All random numbers used in the system should originate from the same generator. This package is intended to be the source.")) (|seed| (((|Integer|)) "\\spad{seed()} returns the current seed value.")) (|reseed| (((|Void|) (|Integer|)) "\\spad{reseed(n)} restarts the random number generator at \\spad{n.}")) (|size| (((|Integer|)) "\\spad{size()} is the base of the random number generator")) (|randnum| (((|Integer|) (|Integer|)) "\\spad{randnum(n)} is a random number between 0 and \\spad{n.}") (((|Integer|)) "\\spad{randnum()} is a random number between 0 and size()."))) 
NIL 
NIL 
(|RationalFactorize| RP) 
((|constructor| (NIL "Factorization of extended polynomials with rational coefficients. This package implements factorization of extended polynomials whose coefficients are rational numbers. It does this by taking the \\spad{lcm} of the coefficients of the polynomial and creating a polynomial with integer coefficients. The algorithm in \\spadtype{GaloisGroupFactorizer} is then used to factor the integer polynomial. The result is normalized with respect to the original \\spad{lcm} of the denominators.")) (|factorSquareFree| (((|Factored| |#1|) |#1|) "\\spad{factorSquareFree(p)} factors an extended squareFree polynomial \\spad{p} over the rational numbers.")) (|factor| (((|Factored| |#1|) |#1|) "\\spad{factor(p)} factors an extended polynomial \\spad{p} over the rational numbers."))) 
NIL 
NIL 
(|RationalRetractions| S) 
((|constructor| (NIL "Rational number testing and retraction functions.")) (|rationalIfCan| (((|Union| (|Fraction| (|Integer|)) "failed") |#1|) "\\spad{rationalIfCan(x)} returns \\spad{x} as a rational number, \"failed\" if \\spad{x} is not a rational number.")) (|rational?| (((|Boolean|) |#1|) "\\spad{rational?(x)} returns \\spad{true} if \\spad{x} is a rational number, \\spad{false} otherwise.")) (|rational| (((|Fraction| (|Integer|)) |#1|) "\\spad{rational(x)} returns \\spad{x} as a rational number; error if \\spad{x} is not a rational number."))) 
NIL 
NIL 
(|RecursiveAggregate&| A S) 
((|constructor| (NIL "A recursive aggregate over a type \\spad{S} is a model for a a directed graph containing values of type \\spad{S.} Recursively, a recursive aggregate is a node consisting of a \\spadfun{value} from \\spad{S} and 0 or more \\spadfun{children} which are recursive aggregates. A node with no children is called a \\spadfun{leaf} node. A recursive aggregate may be cyclic for which some operations as noted may go into an infinite loop.")) (|setvalue!| ((|#2| $ |#2|) "\\spad{setvalue!(u,x)} sets the value of node \\spad{u} to \\spad{x.}")) (|setelt| ((|#2| $ "value" |#2|) "\\spad{setelt(a,\"value\",x)} (also written \\axiom{a . value \\spad{:=} \\spad{x})} is equivalent to \\axiom{setvalue!(a,x)}")) (|setchildren!| (($ $ (|List| $)) "\\spad{setchildren!(u,v)} replaces the current children of node \\spad{u} with the members of \\spad{v} in left-to-right order.")) (|node?| (((|Boolean|) $ $) "\\spad{node?(u,v)} tests if node \\spad{u} is contained in node \\spad{v} (either as a child, a child of a child, etc.).")) (|child?| (((|Boolean|) $ $) "\\spad{child?(u,v)} tests if node \\spad{u} is a child of node \\spad{v.}")) (|distance| (((|Integer|) $ $) "\\spad{distance(u,v)} returns the path length (an integer) from node \\spad{u} to \\spad{v.}")) (|leaves| (((|List| |#2|) $) "\\spad{leaves(t)} returns the list of values in obtained by visiting the nodes of tree \\axiom{t} in left-to-right order.")) (|cyclic?| (((|Boolean|) $) "\\spad{cyclic?(u)} tests if \\spad{u} has a cycle.")) (|elt| ((|#2| $ "value") "\\spad{elt(u,\"value\")} (also written: \\axiom{a. value}) is equivalent to \\axiom{value(a)}.")) (|value| ((|#2| $) "\\spad{value(u)} returns the value of the node u.")) (|leaf?| (((|Boolean|) $) "\\spad{leaf?(u)} tests if \\spad{u} is a terminal node.")) (|nodes| (((|List| $) $) "\\spad{nodes(u)} returns a list of all of the nodes of aggregate u.")) (|children| (((|List| $) $) "\\spad{children(u)} returns a list of the children of aggregate u."))) 
NIL 
((|HasAttribute| |#1| (QUOTE |shallowlyMutable|)) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) 
(|RecursiveAggregate| S) 
((|constructor| (NIL "A recursive aggregate over a type \\spad{S} is a model for a a directed graph containing values of type \\spad{S.} Recursively, a recursive aggregate is a node consisting of a \\spadfun{value} from \\spad{S} and 0 or more \\spadfun{children} which are recursive aggregates. A node with no children is called a \\spadfun{leaf} node. A recursive aggregate may be cyclic for which some operations as noted may go into an infinite loop.")) (|setvalue!| ((|#1| $ |#1|) "\\spad{setvalue!(u,x)} sets the value of node \\spad{u} to \\spad{x.}")) (|setelt| ((|#1| $ "value" |#1|) "\\spad{setelt(a,\"value\",x)} (also written \\axiom{a . value \\spad{:=} \\spad{x})} is equivalent to \\axiom{setvalue!(a,x)}")) (|setchildren!| (($ $ (|List| $)) "\\spad{setchildren!(u,v)} replaces the current children of node \\spad{u} with the members of \\spad{v} in left-to-right order.")) (|node?| (((|Boolean|) $ $) "\\spad{node?(u,v)} tests if node \\spad{u} is contained in node \\spad{v} (either as a child, a child of a child, etc.).")) (|child?| (((|Boolean|) $ $) "\\spad{child?(u,v)} tests if node \\spad{u} is a child of node \\spad{v.}")) (|distance| (((|Integer|) $ $) "\\spad{distance(u,v)} returns the path length (an integer) from node \\spad{u} to \\spad{v.}")) (|leaves| (((|List| |#1|) $) "\\spad{leaves(t)} returns the list of values in obtained by visiting the nodes of tree \\axiom{t} in left-to-right order.")) (|cyclic?| (((|Boolean|) $) "\\spad{cyclic?(u)} tests if \\spad{u} has a cycle.")) (|elt| ((|#1| $ "value") "\\spad{elt(u,\"value\")} (also written: \\axiom{a. value}) is equivalent to \\axiom{value(a)}.")) (|value| ((|#1| $) "\\spad{value(u)} returns the value of the node u.")) (|leaf?| (((|Boolean|) $) "\\spad{leaf?(u)} tests if \\spad{u} is a terminal node.")) (|nodes| (((|List| $) $) "\\spad{nodes(u)} returns a list of all of the nodes of aggregate u.")) (|children| (((|List| $) $) "\\spad{children(u)} returns a list of the children of aggregate u."))) 
((|nil| . T)) 
NIL 
(|RealClosedField&| S) 
((|constructor| (NIL "\\axiomType{RealClosedField} provides common access functions for all real closed fields. provides computations with generic real roots of polynomials")) (|approximate| (((|Fraction| (|Integer|)) $ $) "\\axiom{approximate(n,p)} gives an approximation of \\axiom{n} that has precision \\axiom{p}")) (|rename| (($ $ (|OutputForm|)) "\\axiom{rename(x,name)} gives a new number that prints as name")) (|rename!| (($ $ (|OutputForm|)) "\\axiom{rename!(x,name)} changes the way \\axiom{x} is printed")) (|sqrt| (($ (|Integer|)) "\\axiom{sqrt(x)} is \\axiom{x \\spad{**} (1/2)}") (($ (|Fraction| (|Integer|))) "\\axiom{sqrt(x)} is \\axiom{x \\spad{**} (1/2)}") (($ $) "\\axiom{sqrt(x)} is \\axiom{x \\spad{**} (1/2)}") (($ $ (|NonNegativeInteger|)) "\\axiom{sqrt(x,n)} is \\axiom{x \\spad{**} (1/n)}")) (|allRootsOf| (((|List| $) (|Polynomial| (|Integer|))) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} naming each uniquely") (((|List| $) (|Polynomial| (|Fraction| (|Integer|)))) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} naming each uniquely") (((|List| $) (|Polynomial| $)) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} naming each uniquely") (((|List| $) (|SparseUnivariatePolynomial| (|Integer|))) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} naming each uniquely") (((|List| $) (|SparseUnivariatePolynomial| (|Fraction| (|Integer|)))) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} naming each uniquely") (((|List| $) (|SparseUnivariatePolynomial| $)) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} naming each uniquely")) (|rootOf| (((|Union| $ "failed") (|SparseUnivariatePolynomial| $) (|PositiveInteger|)) "\\axiom{rootOf(pol,n)} creates the \\spad{n}th root for the order of \\axiom{pol} and gives it unique name") (((|Union| $ "failed") (|SparseUnivariatePolynomial| $) (|PositiveInteger|) (|OutputForm|)) "\\axiom{rootOf(pol,n,name)} creates the \\spad{n}th root for the order of \\axiom{pol} and names it \\axiom{name}")) (|mainValue| (((|Union| (|SparseUnivariatePolynomial| $) "failed") $) "\\axiom{mainValue(x)} is the expression of \\axiom{x} in terms of \\axiom{SparseUnivariatePolynomial($)}")) (|mainDefiningPolynomial| (((|Union| (|SparseUnivariatePolynomial| $) "failed") $) "\\axiom{mainDefiningPolynomial(x)} is the defining polynomial for the main algebraic quantity of \\axiom{x}")) (|mainForm| (((|Union| (|OutputForm|) "failed") $) "\\axiom{mainForm(x)} is the main algebraic quantity name of \\axiom{x}"))) 
NIL 
NIL 
(|RealClosedField|) 
((|constructor| (NIL "\\axiomType{RealClosedField} provides common access functions for all real closed fields. provides computations with generic real roots of polynomials")) (|approximate| (((|Fraction| (|Integer|)) $ $) "\\axiom{approximate(n,p)} gives an approximation of \\axiom{n} that has precision \\axiom{p}")) (|rename| (($ $ (|OutputForm|)) "\\axiom{rename(x,name)} gives a new number that prints as name")) (|rename!| (($ $ (|OutputForm|)) "\\axiom{rename!(x,name)} changes the way \\axiom{x} is printed")) (|sqrt| (($ (|Integer|)) "\\axiom{sqrt(x)} is \\axiom{x \\spad{**} (1/2)}") (($ (|Fraction| (|Integer|))) "\\axiom{sqrt(x)} is \\axiom{x \\spad{**} (1/2)}") (($ $) "\\axiom{sqrt(x)} is \\axiom{x \\spad{**} (1/2)}") (($ $ (|NonNegativeInteger|)) "\\axiom{sqrt(x,n)} is \\axiom{x \\spad{**} (1/n)}")) (|allRootsOf| (((|List| $) (|Polynomial| (|Integer|))) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} naming each uniquely") (((|List| $) (|Polynomial| (|Fraction| (|Integer|)))) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} naming each uniquely") (((|List| $) (|Polynomial| $)) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} naming each uniquely") (((|List| $) (|SparseUnivariatePolynomial| (|Integer|))) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} naming each uniquely") (((|List| $) (|SparseUnivariatePolynomial| (|Fraction| (|Integer|)))) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} naming each uniquely") (((|List| $) (|SparseUnivariatePolynomial| $)) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} naming each uniquely")) (|rootOf| (((|Union| $ "failed") (|SparseUnivariatePolynomial| $) (|PositiveInteger|)) "\\axiom{rootOf(pol,n)} creates the \\spad{n}th root for the order of \\axiom{pol} and gives it unique name") (((|Union| $ "failed") (|SparseUnivariatePolynomial| $) (|PositiveInteger|) (|OutputForm|)) "\\axiom{rootOf(pol,n,name)} creates the \\spad{n}th root for the order of \\axiom{pol} and names it \\axiom{name}")) (|mainValue| (((|Union| (|SparseUnivariatePolynomial| $) "failed") $) "\\axiom{mainValue(x)} is the expression of \\axiom{x} in terms of \\axiom{SparseUnivariatePolynomial($)}")) (|mainDefiningPolynomial| (((|Union| (|SparseUnivariatePolynomial| $) "failed") $) "\\axiom{mainDefiningPolynomial(x)} is the defining polynomial for the main algebraic quantity of \\axiom{x}")) (|mainForm| (((|Union| (|OutputForm|) "failed") $) "\\axiom{mainForm(x)} is the main algebraic quantity name of \\axiom{x}"))) 
((|noZeroDivisors| . T) (|canonicalUnitNormal| . T) (|canonicalsClosed| . T) (|leftUnitary| . T) (|rightUnitary| . T) ((|commutative| "*") . T) (|unitsKnown| . T)) 
NIL 
(|ElementaryRischDE| R F) 
((|constructor| (NIL "Risch differential equation, elementary case.")) (|rischDE| (((|Record| (|:| |ans| |#2|) (|:| |right| |#2|) (|:| |sol?| (|Boolean|))) (|Integer|) |#2| |#2| (|Symbol|) (|Mapping| (|Union| (|Record| (|:| |mainpart| |#2|) (|:| |limitedlogs| (|List| (|Record| (|:| |coeff| |#2|) (|:| |logand| |#2|))))) "failed") |#2| (|List| |#2|)) (|Mapping| (|Union| (|Record| (|:| |ratpart| |#2|) (|:| |coeff| |#2|)) "failed") |#2| |#2|)) "\\spad{rischDE(n, \\spad{f,} \\spad{g,} \\spad{x,} lim, ext)} returns \\spad{[y, \\spad{h,} \\spad{b]}} such that \\spad{dy/dx + \\spad{n} df/dx \\spad{y} = \\spad{h}} and \\spad{b \\spad{:=} \\spad{h} = \\spad{g}.} The equation \\spad{dy/dx + \\spad{n} df/dx \\spad{y} = \\spad{g}} has no solution if \\spad{h \\~~= \\spad{g}} (y is a partial solution in that case). Notes: \\spad{lim} is a limited integration function, and ext is an extended integration function."))) 
NIL 
NIL 
(|ElementaryRischDESystem| R F) 
((|constructor| (NIL "Risch differential equation, elementary case.")) (|rischDEsys| (((|Union| (|List| |#2|) "failed") (|Integer|) |#2| |#2| |#2| (|Symbol|) (|Mapping| (|Union| (|Record| (|:| |mainpart| |#2|) (|:| |limitedlogs| (|List| (|Record| (|:| |coeff| |#2|) (|:| |logand| |#2|))))) "failed") |#2| (|List| |#2|)) (|Mapping| (|Union| (|Record| (|:| |ratpart| |#2|) (|:| |coeff| |#2|)) "failed") |#2| |#2|)) "\\spad{rischDEsys(n, \\spad{f,} g_1, g_2, x,lim,ext)} returns \\spad{y_1.y_2} such that \\spad{(dy1/dx,dy2/dx) + ((0, - \\spad{n} df/dx),(n df/dx,0)) (y1,y2) = (g1,g2)} if \\spad{y_1,y_2} exist, \"failed\" otherwise. \\spad{lim} is a limited integration function, \\spad{ext} is an extended integration function."))) 
NIL 
NIL 
(|TranscendentalRischDE| F UP) 
((|constructor| (NIL "Risch differential equation, transcendental case.")) (|polyRDE| (((|Union| (|:| |ans| (|Record| (|:| |ans| |#2|) (|:| |nosol| (|Boolean|)))) (|:| |eq| (|Record| (|:| |b| |#2|) (|:| |c| |#2|) (|:| |m| (|Integer|)) (|:| |alpha| |#2|) (|:| |beta| |#2|)))) |#2| |#2| |#2| (|Integer|) (|Mapping| |#2| |#2|)) "\\spad{polyRDE(a, \\spad{B,} \\spad{C,} \\spad{n,} \\spad{D)}} returns either: 1. \\spad{[Q, \\spad{b]}} such that \\spad{degree(Q) \\spad{<=} \\spad{n}} and \\indented{3}{\\spad{a \\spad{Q'+} \\spad{B} \\spad{Q} = \\spad{C}} if \\spad{b = true}, \\spad{Q} is a partial solution} \\indented{3}{otherwise.} 2. \\spad{[B1, \\spad{C1,} \\spad{m,} \\alpha, \\beta]} such that any polynomial solution \\indented{3}{of degree at most \\spad{n} of \\spad{A \\spad{Q'} + \\spad{BQ} = \\spad{C}} must be of the form} \\indented{3}{\\spad{Q = \\alpha \\spad{H} + \\beta} where \\spad{degree(H) \\spad{<=} \\spad{m}} and} \\indented{3}{H satisfies \\spad{H' + \\spad{B1} \\spad{H} = C1}.} \\spad{D} is the derivation to use.")) (|baseRDE| (((|Record| (|:| |ans| (|Fraction| |#2|)) (|:| |nosol| (|Boolean|))) (|Fraction| |#2|) (|Fraction| |#2|)) "\\spad{baseRDE(f, \\spad{g)}} returns a \\spad{[y, \\spad{b]}} such that \\spad{y' + fy = \\spad{g}} if \\spad{b = true}, \\spad{y} is a partial solution otherwise (no solution in that case). \\spad{D} is the derivation to use.")) (|monomRDE| (((|Union| (|Record| (|:| |a| |#2|) (|:| |b| (|Fraction| |#2|)) (|:| |c| (|Fraction| |#2|)) (|:| |t| |#2|)) "failed") (|Fraction| |#2|) (|Fraction| |#2|) (|Mapping| |#2| |#2|)) "\\spad{monomRDE(f,g,D)} returns \\spad{[A, \\spad{B,} \\spad{C,} \\spad{T]}} such that \\spad{y' + \\spad{f} \\spad{y} = \\spad{g}} has a solution if and only if \\spad{y = \\spad{Q} / \\spad{T},} where \\spad{Q} satisfies \\spad{A \\spad{Q'} + \\spad{B} \\spad{Q} = \\spad{C}} and has no normal pole. A and \\spad{T} are polynomials and \\spad{B} and \\spad{C} have no normal poles. \\spad{D} is the derivation to use."))) 
NIL 
NIL 
(|TranscendentalRischDESystem| F UP) 
((|constructor| (NIL "Risch differential equation system, transcendental case.")) (|baseRDEsys| (((|Union| (|List| (|Fraction| |#2|)) "failed") (|Fraction| |#2|) (|Fraction| |#2|) (|Fraction| |#2|)) "\\spad{baseRDEsys(f, \\spad{g1,} g2)} returns fractions \\spad{y_1.y_2} such that \\spad{(y1', y2') + ((0, -f), \\spad{(f,} 0)) (y1,y2) = (g1,g2)} if \\spad{y_1,y_2} exist, \"failed\" otherwise.")) (|monomRDEsys| (((|Union| (|Record| (|:| |a| |#2|) (|:| |b| (|Fraction| |#2|)) (|:| |h| |#2|) (|:| |c1| (|Fraction| |#2|)) (|:| |c2| (|Fraction| |#2|)) (|:| |t| |#2|)) "failed") (|Fraction| |#2|) (|Fraction| |#2|) (|Fraction| |#2|) (|Mapping| |#2| |#2|)) "\\spad{monomRDEsys(f,g1,g2,D)} returns \\spad{[A, \\spad{B,} \\spad{H,} \\spad{C1,} \\spad{C2,} \\spad{T]}} such that \\spad{(y1', y2') + ((0, -f), \\spad{(f,} 0)) (y1,y2) = (g1,g2)} has a solution if and only if \\spad{y1 = \\spad{Q1} / \\spad{T,} \\spad{y2} = \\spad{Q2} / \\spad{T},} where \\spad{B,C1,C2,Q1,Q2} have no normal poles and satisfy A \\spad{(Q1', Q2') + ((H, -B), \\spad{(B,} \\spad{H))} (Q1,Q2) = (C1,C2)} \\spad{D} is the derivation to use."))) 
NIL 
NIL 
(|RandomDistributions| S) 
((|constructor| (NIL "This package exports random distributions")) (|rdHack1| (((|Mapping| |#1|) (|Vector| |#1|) (|Vector| (|Integer|)) (|Integer|)) "\\spad{rdHack1(v,u,n)} \\undocumented")) (|weighted| (((|Mapping| |#1|) (|List| (|Record| (|:| |value| |#1|) (|:| |weight| (|Integer|))))) "\\spad{weighted(l)} \\undocumented")) (|uniform| (((|Mapping| |#1|) (|Set| |#1|)) "\\spad{uniform(s)} \\undocumented"))) 
NIL 
NIL 
(|ReducedDivisor| F1 UP UPUP R F2) 
((|constructor| (NIL "Finds the order of a divisor over a finite field")) (|order| (((|NonNegativeInteger|) (|FiniteDivisor| |#1| |#2| |#3| |#4|) |#3| (|Mapping| |#5| |#1|)) "\\spad{order(f,u,g)} \\undocumented"))) 
NIL 
NIL 
(|RealZeroPackage| |Pol|) 
((|constructor| (NIL "This package provides functions for finding the real zeros of univariate polynomials over the integers to arbitrary user-specified precision. The results are returned as a list of isolating intervals which are expressed as records with \"left\" and \"right\" rational number components.")) (|midpoints| (((|List| (|Fraction| (|Integer|))) (|List| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|)))))) "\\spad{midpoints(isolist)} returns the list of midpoints for the list of intervals isolist.")) (|midpoint| (((|Fraction| (|Integer|)) (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|))))) "\\spad{midpoint(int)} returns the midpoint of the interval int.")) (|refine| (((|Union| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|)))) "failed") |#1| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|)))) (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|))))) "\\spad{refine(pol, int, range)} takes a univariate polynomial \\spad{pol} and and isolating interval \\spad{int} containing exactly one real root of pol; the operation returns an isolating interval which is contained within range, or \"failed\" if no such isolating interval exists.") (((|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|)))) |#1| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|)))) (|Fraction| (|Integer|))) "\\spad{refine(pol, int, eps)} refines the interval \\spad{int} containing exactly one root of the univariate polynomial \\spad{pol} to size less than the rational number eps.")) (|realZeros| (((|List| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|))))) |#1| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|)))) (|Fraction| (|Integer|))) "\\spad{realZeros(pol, int, eps)} returns a list of intervals of length less than the rational number eps for all the real roots of the polynomial \\spad{pol} which lie in the interval expressed by the record int.") (((|List| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|))))) |#1| (|Fraction| (|Integer|))) "\\spad{realZeros(pol, eps)} returns a list of intervals of length less than the rational number eps for all the real roots of the polynomial pol.") (((|List| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|))))) |#1| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|))))) "\\spad{realZeros(pol, range)} returns a list of isolating intervals for all the real zeros of the univariate polynomial \\spad{pol} which lie in the interval expressed by the record range.") (((|List| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|))))) |#1|) "\\spad{realZeros(pol)} returns a list of isolating intervals for all the real zeros of the univariate polynomial pol."))) 
NIL 
NIL 
(|RealZeroPackageQ| |Pol|) 
((|constructor| (NIL "This package provides functions for finding the real zeros of univariate polynomials over the rational numbers to arbitrary user-specified precision. The results are returned as a list of isolating intervals, expressed as records with \"left\" and \"right\" rational number components.")) (|refine| (((|Union| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|)))) "failed") |#1| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|)))) (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|))))) "\\spad{refine(pol, int, range)} takes a univariate polynomial \\spad{pol} and and isolating interval \\spad{int} which must contain exactly one real root of pol, and returns an isolating interval which is contained within range, or \"failed\" if no such isolating interval exists.") (((|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|)))) |#1| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|)))) (|Fraction| (|Integer|))) "\\spad{refine(pol, int, eps)} refines the interval \\spad{int} containing exactly one root of the univariate polynomial \\spad{pol} to size less than the rational number eps.")) (|realZeros| (((|List| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|))))) |#1| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|)))) (|Fraction| (|Integer|))) "\\spad{realZeros(pol, int, eps)} returns a list of intervals of length less than the rational number eps for all the real roots of the polynomial \\spad{pol} which lie in the interval expressed by the record int.") (((|List| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|))))) |#1| (|Fraction| (|Integer|))) "\\spad{realZeros(pol, eps)} returns a list of intervals of length less than the rational number eps for all the real roots of the polynomial pol.") (((|List| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|))))) |#1| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|))))) "\\spad{realZeros(pol, range)} returns a list of isolating intervals for all the real zeros of the univariate polynomial \\spad{pol} which lie in the interval expressed by the record range.") (((|List| (|Record| (|:| |left| (|Fraction| (|Integer|))) (|:| |right| (|Fraction| (|Integer|))))) |#1|) "\\spad{realZeros(pol)} returns a list of isolating intervals for all the real zeros of the univariate polynomial pol."))) 
NIL 
NIL 
(|RealConstant|) 
((|constructor| (NIL "The category of real numeric domains, that is, convertible to floats."))) 
NIL 
NIL 
(|RealSolvePackage|) 
((|constructor| (NIL "This package provides numerical solutions of systems of polynomial equations for use in ACPLOT")) (|realSolve| (((|List| (|List| (|Float|))) (|List| (|Polynomial| (|Integer|))) (|List| (|Symbol|)) (|Float|)) "\\indented{1}{realSolve(lp,lv,eps) = compute the list of the real} \\indented{1}{solutions of the list \\spad{lp} of polynomials with integer} \\indented{1}{coefficients with respect to the variables in lv,} \\indented{1}{with precision eps.} \\blankline \\spad{X} \\spad{p1} \\spad{:=} x**2*y*z + \\spad{y*z} \\spad{X} \\spad{p2} \\spad{:=} x**2*y**2*z + \\spad{x} + \\spad{z} \\spad{X} \\spad{p3} \\spad{:=} \\spad{x**2*y**2*z**2} + \\spad{z} + 1 \\spad{X} \\spad{lp} \\spad{:=} [p1, \\spad{p2,} \\spad{p3]} \\spad{X} realSolve(lp,[x,y,z],0.01)")) (|solve| (((|List| (|Float|)) (|Polynomial| (|Integer|)) (|Float|)) "\\indented{1}{solve(p,eps) finds the real zeroes of a univariate} \\indented{1}{integer polynomial \\spad{p} with precision eps.} \\blankline \\spad{X} \\spad{p} \\spad{:=} 4*x^3 - 3*x^2 + 2*x - 4 \\spad{X} solve(p,0.01)$REALSOLV") (((|List| (|Float|)) (|Polynomial| (|Fraction| (|Integer|))) (|Float|)) "\\indented{1}{solve(p,eps) finds the real zeroes of a} \\indented{1}{univariate rational polynomial \\spad{p} with precision eps.} \\blankline \\spad{X} \\spad{p} \\spad{:=} 4*x^3 - 3*x^2 + 2*x - 4 \\spad{X} solve(p::POLY(FRAC(INT)),0.01)$REALSOLV"))) 
NIL 
NIL 
(|RealClosure| |TheField|) 
((|constructor| (NIL "This domain implements the real closure of an ordered field.")) (|relativeApprox| (((|Fraction| (|Integer|)) $ $) "\\axiom{relativeApprox(n,p)} gives a relative approximation of \\axiom{n} that has precision \\axiom{p}")) (|mainCharacterization| (((|Union| (|RightOpenIntervalRootCharacterization| $ (|SparseUnivariatePolynomial| $)) "failed") $) "\\axiom{mainCharacterization(x)} is the main algebraic quantity of \\axiom{x} (\\axiom{SEG})")) (|algebraicOf| (($ (|RightOpenIntervalRootCharacterization| $ (|SparseUnivariatePolynomial| $)) (|OutputForm|)) "\\axiom{algebraicOf(char)} is the external number"))) 
((|noZeroDivisors| . T) (|canonicalUnitNormal| . T) (|canonicalsClosed| . T) (|leftUnitary| . T) (|rightUnitary| . T) ((|commutative| "*") . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| (|Fraction| (|Integer|)) (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| (|Fraction| (|Integer|)) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (OR (|HasCategory| (|Fraction| (|Integer|)) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))))) 
(|RecurrenceOperator| R F) 
((|constructor| (NIL "This package provides an operator for the \\spad{n}-th term of a recurrence and an operator for the coefficient of \\spad{x^n} in a function specified by a functional equation.")) (|getOp| (((|BasicOperator|) |#2|) "\\spad{getOp \\spad{f},} if \\spad{f} represents the coefficient of a recurrence or ADE, returns the operator representing the solution")) (|getEq| ((|#2| |#2|) "\\spad{getEq \\spad{f}} returns the defining equation, if \\spad{f} represents the coefficient of an ADE or a recurrence.")) (|evalADE| ((|#2| (|BasicOperator|) (|Symbol|) |#2| |#2| |#2| (|List| |#2|)) "\\spad{evalADE(f, dummy, \\spad{x,} \\spad{n,} eq, values)} creates an expression that stands for the coefficient of \\spad{x^n} in the Taylor expansion of f(x), where f(x) is given by the functional equation eq. However, for technical reasons the variable \\spad{x} has to be replaced by a \\spad{dummy} variable \\spad{dummy} in eq. The argument values specifies the first few Taylor coefficients.")) (|evalRec| ((|#2| (|BasicOperator|) (|Symbol|) |#2| |#2| |#2| (|List| |#2|)) "\\spad{evalRec(u, dummy, \\spad{n,} \\spad{n0,} eq, values)} creates an expression that stands for u(n0), where u(n) is given by the equation eq. However, for technical reasons the variable \\spad{n} has to be replaced by a \\spad{dummy} variable \\spad{dummy} in eq. The argument values specifies the initial values of the recurrence u(0), u(1),... For the moment we don't allow recursions that contain \\spad{u} inside of another operator."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|Ring|)))) 
(|ReductionOfOrder| F L) 
((|constructor| (NIL "\\spadtype{ReductionOfOrder} provides functions for reducing the order of linear ordinary differential equations once some solutions are known.")) (|ReduceOrder| (((|Record| (|:| |eq| |#2|) (|:| |op| (|List| |#1|))) |#2| (|List| |#1|)) "\\spad{ReduceOrder(op, [f1,...,fk])} returns \\spad{[op1,[g1,...,gk]]} such that for any solution \\spad{z} of \\spad{op1 \\spad{z} = 0}, \\spad{y = \\spad{gk} \\int(g_{k-1} \\int(... \\int(g1 \\int z)...)} is a solution of \\spad{op \\spad{y} = 0}. Each \\spad{fi} must satisfy \\spad{op \\spad{fi} = 0}.") ((|#2| |#2| |#1|) "\\spad{ReduceOrder(op, \\spad{s)}} returns \\spad{op1} such that for any solution \\spad{z} of \\spad{op1 \\spad{z} = 0}, \\spad{y = \\spad{s} \\int \\spad{z}} is a solution of \\spad{op \\spad{y} = 0}. \\spad{s} must satisfy \\spad{op \\spad{s} = 0}."))) 
NIL 
NIL 
(|Reference| S) 
((|constructor| (NIL "\\spadtype{Reference} is for making a changeable instance of something.")) (= (((|Boolean|) $ $) "\\spad{a=b} tests if \\spad{a} and \\spad{b} are equal.")) (|setref| ((|#1| $ |#1|) "\\spad{setref(n,m)} same as \\spad{setelt(n,m)}.")) (|deref| ((|#1| $) "\\spad{deref(n)} is equivalent to \\spad{elt(n)}.")) (|setelt| ((|#1| $ |#1|) "\\spad{setelt(n,m)} changes the value of the object \\spad{n} to \\spad{m.}")) (|elt| ((|#1| $) "\\spad{elt(n)} returns the object \\spad{n.}")) (|ref| (($ |#1|) "\\spad{ref(n)} creates a pointer (reference) to the object \\spad{n.}"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|SetCategory|)))) 
(|RegularTriangularSet| R E V P) 
((|constructor| (NIL "This domain provides an implementation of regular chains. Moreover, the operation zeroSetSplit is an implementation of a new algorithm for solving polynomial systems by means of regular chains.")) (|preprocess| (((|Record| (|:| |val| (|List| |#4|)) (|:| |towers| (|List| $))) (|List| |#4|) (|Boolean|) (|Boolean|)) "\\axiom{pre_process(lp,b1,b2)} is an internal subroutine, exported only for developement.")) (|internalZeroSetSplit| (((|List| $) (|List| |#4|) (|Boolean|) (|Boolean|) (|Boolean|)) "\\axiom{internalZeroSetSplit(lp,b1,b2,b3)} is an internal subroutine, exported only for developement.")) (|zeroSetSplit| (((|List| $) (|List| |#4|) (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|)) "\\axiom{zeroSetSplit(lp,b1,b2.b3,b4)} is an internal subroutine, exported only for developement.") (((|List| $) (|List| |#4|) (|Boolean|) (|Boolean|)) "\\axiom{zeroSetSplit(lp,clos?,info?)} has the same specifications as zeroSetSplit from RegularTriangularSetCategory. Moreover, if \\axiom{clos?} then solves in the sense of the Zariski closure else solves in the sense of the regular zeros. If \\axiom{info?} then do print messages during the computations.")) (|internalAugment| (((|List| $) |#4| $ (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|)) "\\axiom{internalAugment(p,ts,b1,b2,b3,b4,b5)} is an internal subroutine, exported only for developement."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#4| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#4| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#3| (QUOTE (|Finite|)))) 
(|RepresentationPackage1| R) 
((|constructor| (NIL "\\spad{RepresentationPackage1} provides functions for representation theory for finite groups and algebras. The package creates permutation representations and uses tensor products and its symmetric and antisymmetric components to create new representations of larger degree from given ones. Note that instead of having parameters from \\spadtype{Permutation} this package allows list notation of permutations as well: \\spadignore{e.g.} \\spad{[1,4,3,2]} denotes permutes 2 and 4 and fixes 1 and 3.")) (|permutationRepresentation| (((|List| (|Matrix| (|Integer|))) (|List| (|List| (|Integer|)))) "\\spad{permutationRepresentation([pi1,...,pik],n)} returns the list of matrices [(deltai,pi1(i)),...,(deltai,pik(i))] if the permutations pi1,...,pik are in list notation and are permuting {1,2,...,n}.") (((|List| (|Matrix| (|Integer|))) (|List| (|Permutation| (|Integer|))) (|Integer|)) "\\spad{permutationRepresentation([pi1,...,pik],n)} returns the list of matrices [(deltai,pi1(i)),...,(deltai,pik(i))] (Kronecker delta) for the permutations pi1,...,pik of {1,2,...,n}.") (((|Matrix| (|Integer|)) (|List| (|Integer|))) "\\spad{permutationRepresentation(pi,n)} returns the matrix (deltai,pi(i)) (Kronecker delta) if the permutation \\spad{pi} is in list notation and permutes {1,2,...,n}.") (((|Matrix| (|Integer|)) (|Permutation| (|Integer|)) (|Integer|)) "\\spad{permutationRepresentation(pi,n)} returns the matrix (deltai,pi(i)) (Kronecker delta) for a permutation \\spad{pi} of {1,2,...,n}.")) (|tensorProduct| (((|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|))) "\\spad{tensorProduct([a1,...ak])} calculates the list of Kronecker products of each matrix \\spad{ai} with itself for \\spad{{1} \\spad{<=} \\spad{i} \\spad{<=} \\spad{k}.} Note that if the list of matrices corresponds to a group representation (repr. of generators) of one group, then these matrices correspond to the tensor product of the representation with itself.") (((|Matrix| |#1|) (|Matrix| |#1|)) "\\spad{tensorProduct(a)} calculates the Kronecker product of the matrix a with itself.") (((|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|))) "\\spad{tensorProduct([a1,...,ak],[b1,...,bk])} calculates the list of Kronecker products of the matrices \\spad{ai} and \\spad{bi} for \\spad{{1} \\spad{<=} \\spad{i} \\spad{<=} \\spad{k}.} Note that if each list of matrices corresponds to a group representation (repr. of generators) of one group, then these matrices correspond to the tensor product of the two representations.") (((|Matrix| |#1|) (|Matrix| |#1|) (|Matrix| |#1|)) "\\spad{tensorProduct(a,b)} calculates the Kronecker product of the matrices a and \\spad{b.} Note that if each matrix corresponds to a group representation (repr. of generators) of one group, then these matrices correspond to the tensor product of the two representations.")) (|symmetricTensors| (((|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|)) (|PositiveInteger|)) "\\spad{symmetricTensors(la,n)} applies to each m-by-m square matrix in the list \\spad{la} the irreducible, polynomial representation of the general linear group \\spad{GLm} which corresponds to the partition (n,0,...,0) of \\spad{n.} Error: if the matrices in \\spad{la} are not square matrices. Note that this corresponds to the symmetrization of the representation with the trivial representation of the symmetric group \\spad{Sn.} The carrier spaces of the representation are the symmetric tensors of the n-fold tensor product.") (((|Matrix| |#1|) (|Matrix| |#1|) (|PositiveInteger|)) "\\spad{symmetricTensors(a,n)} applies to the m-by-m square matrix a the irreducible, polynomial representation of the general linear group \\spad{GLm} which corresponds to the partition (n,0,...,0) of \\spad{n.} Error: if a is not a square matrix. Note that this corresponds to the symmetrization of the representation with the trivial representation of the symmetric group \\spad{Sn.} The carrier spaces of the representation are the symmetric tensors of the n-fold tensor product.")) (|createGenericMatrix| (((|Matrix| (|Polynomial| |#1|)) (|NonNegativeInteger|)) "\\spad{createGenericMatrix(m)} creates a square matrix of dimension \\spad{k} whose entry at the \\spad{i}-th row and \\spad{j}-th column is the indeterminate x[i,j] (double subscripted).")) (|antisymmetricTensors| (((|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|)) (|PositiveInteger|)) "\\spad{antisymmetricTensors(la,n)} applies to each m-by-m square matrix in the list \\spad{la} the irreducible, polynomial representation of the general linear group \\spad{GLm} which corresponds to the partition (1,1,...,1,0,0,...,0) of \\spad{n.} Error: if \\spad{n} is greater than \\spad{m.} Note that this corresponds to the symmetrization of the representation with the sign representation of the symmetric group \\spad{Sn.} The carrier spaces of the representation are the antisymmetric tensors of the n-fold tensor product.") (((|Matrix| |#1|) (|Matrix| |#1|) (|PositiveInteger|)) "\\spad{antisymmetricTensors(a,n)} applies to the square matrix a the irreducible, polynomial representation of the general linear group GLm, where \\spad{m} is the number of rows of a, which corresponds to the partition (1,1,...,1,0,0,...,0) of \\spad{n.} Error: if \\spad{n} is greater than \\spad{m.} Note that this corresponds to the symmetrization of the representation with the sign representation of the symmetric group \\spad{Sn.} The carrier spaces of the representation are the antisymmetric tensors of the n-fold tensor product."))) 
NIL 
((|HasAttribute| |#1| (QUOTE (|commutative| "*")))) 
(|RepresentationPackage2| R) 
((|constructor| (NIL "\\spad{RepresentationPackage2} provides functions for working with modular representations of finite groups and algebra. The routines in this package are created, using ideas of \\spad{R.} Parker, (the meat-Axe) to get smaller representations from bigger ones, \\spadignore{i.e.} finding sub- and factormodules, or to show, that such the representations are irreducible. Note that most functions are randomized functions of Las Vegas type \\spadignore{i.e.} every answer is correct, but with small probability the algorithm fails to get an answer.")) (|scanOneDimSubspaces| (((|Vector| |#1|) (|List| (|Vector| |#1|)) (|Integer|)) "\\spad{scanOneDimSubspaces(basis,n)} gives a canonical representative of the \\spad{n}-th one-dimensional subspace of the vector space generated by the elements of basis, all from R**n. The coefficients of the representative are of shape (0,...,0,1,*,...,*), * in \\spad{R.} If the size of \\spad{R} is \\spad{q,} then there are (q**n-1)/(q-1) of them. We first reduce \\spad{n} modulo this number, then find the largest \\spad{i} such that +/[q**i for \\spad{i} in 0..i-1] \\spad{<=} \\spad{n.} Subtracting this sum of powers from \\spad{n} results in an i-digit number to \\spad{basis} \\spad{q.} This fills the positions of the stars.")) (|meatAxe| (((|List| (|List| (|Matrix| |#1|))) (|List| (|Matrix| |#1|)) (|PositiveInteger|)) "\\spad{meatAxe(aG, numberOfTries)} calls meatAxe(aG,true,numberOfTries,7). Notes: 7 covers the case of three-dimensional kernels over the field with 2 elements.") (((|List| (|List| (|Matrix| |#1|))) (|List| (|Matrix| |#1|)) (|Boolean|)) "\\spad{meatAxe(aG, randomElements)} calls meatAxe(aG,false,6,7), only using Parker's fingerprints, if randomElemnts is false. If it is true, it calls meatAxe(aG,true,25,7), only using random elements. Note that the choice of 25 was rather arbitrary. Also, 7 covers the case of three-dimensional kernels over the field with 2 elements.") (((|List| (|List| (|Matrix| |#1|))) (|List| (|Matrix| |#1|))) "\\spad{meatAxe(aG)} calls meatAxe(aG,false,25,7) returns a 2-list of representations as follows. All matrices of argument \\spad{aG} are assumed to be square and of equal size. Then \\spad{aG} generates a subalgebra, say \\spad{A}, of the algebra of all square matrices of dimension \\spad{n.} \\spad{V} \\spad{R} is an A-module in the usual way. meatAxe(aG) creates at most 25 random elements of the algebra, tests them for singularity. If singular, it tries at most 7 elements of its kernel to generate a proper submodule. If successful a list which contains first the list of the representations of the submodule, then a list of the representations of the factor module is returned. Otherwise, if we know that all the kernel is already scanned, Norton's irreducibility test can be used either to prove irreducibility or to find the splitting. Notes: the first 6 tries use Parker's fingerprints. Also, 7 covers the case of three-dimensional kernels over the field with 2 elements.") (((|List| (|List| (|Matrix| |#1|))) (|List| (|Matrix| |#1|)) (|Boolean|) (|Integer|) (|Integer|)) "\\spad{meatAxe(aG,randomElements,numberOfTries, maxTests)} returns a 2-list of representations as follows. All matrices of argument \\spad{aG} are assumed to be square and of equal size. Then \\spad{aG} generates a subalgebra, say \\spad{A}, of the algebra of all square matrices of dimension \\spad{n.} \\spad{V} \\spad{R} is an A-module in the usual way. meatAxe(aG,numberOfTries, maxTests) creates at most \\spad{numberOfTries} random elements of the algebra, tests them for singularity. If singular, it tries at most maxTests elements of its kernel to generate a proper submodule. If successful, a 2-list is returned: first, a list containing first the list of the representations of the submodule, then a list of the representations of the factor module. Otherwise, if we know that all the kernel is already scanned, Norton's irreducibility test can be used either to prove irreducibility or to find the splitting. If \\spad{randomElements} is false, the first 6 tries use Parker's fingerprints.")) (|split| (((|List| (|List| (|Matrix| |#1|))) (|List| (|Matrix| |#1|)) (|Vector| (|Vector| |#1|))) "\\spad{split(aG,submodule)} uses a proper \\spad{submodule} of R**n to create the representations of the \\spad{submodule} and of the factor module.") (((|List| (|List| (|Matrix| |#1|))) (|List| (|Matrix| |#1|)) (|Vector| |#1|)) "\\spad{split(aG, vector)} returns a subalgebra \\spad{A} of all square matrix of dimension \\spad{n} as a list of list of matrices, generated by the list of matrices aG, where \\spad{n} denotes both the size of vector as well as the dimension of each of the square matrices. \\spad{V} \\spad{R} is an A-module in the natural way. split(aG, vector) then checks whether the cyclic submodule generated by vector is a proper submodule of \\spad{V} \\spad{R.} If successful, it returns a two-element list, which contains first the list of the representations of the submodule, then the list of the representations of the factor module. If the vector generates the whole module, a one-element list of the old representation is given. Note that a later version this should call the other split.")) (|isAbsolutelyIrreducible?| (((|Boolean|) (|List| (|Matrix| |#1|))) "\\spad{isAbsolutelyIrreducible?(aG)} calls isAbsolutelyIrreducible?(aG,25). Note that the choice of 25 was rather arbitrary.") (((|Boolean|) (|List| (|Matrix| |#1|)) (|Integer|)) "\\spad{isAbsolutelyIrreducible?(aG, numberOfTries)} uses Norton's irreducibility test to check for absolute irreduciblity, assuming if a one-dimensional kernel is found. As no field extension changes create \"new\" elements in a one-dimensional space, the criterium stays \\spad{true} for every extension. The method looks for one-dimensionals only by creating random elements (no fingerprints) since a run of meatAxe would have proved absolute irreducibility anyway.")) (|areEquivalent?| (((|Matrix| |#1|) (|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|)) (|Integer|)) "\\spad{areEquivalent?(aG0,aG1,numberOfTries)} calls areEquivalent?(aG0,aG1,true,25). Note that the choice of 25 was rather arbitrary.") (((|Matrix| |#1|) (|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|))) "\\spad{areEquivalent?(aG0,aG1)} calls areEquivalent?(aG0,aG1,true,25). Note that the choice of 25 was rather arbitrary.") (((|Matrix| |#1|) (|List| (|Matrix| |#1|)) (|List| (|Matrix| |#1|)) (|Boolean|) (|Integer|)) "\\spad{areEquivalent?(aG0,aG1,randomelements,numberOfTries)} tests whether the two lists of matrices, all assumed of same square shape, can be simultaneously conjugated by a non-singular matrix. If these matrices represent the same group generators, the representations are equivalent. The algorithm tries \\spad{numberOfTries} times to create elements in the generated algebras in the same fashion. If their ranks differ, they are not equivalent. If an isomorphism is assumed, then the kernel of an element of the first algebra is mapped to the kernel of the corresponding element in the second algebra. Now consider the one-dimensional ones. If they generate the whole space (\\spadignore{e.g.} irreducibility \\spad{!)} we use standardBasisOfCyclicSubmodule to create the only possible transition matrix. The method checks whether the matrix conjugates all corresponding matrices from aGi. The way to choose the singular matrices is as in meatAxe. If the two representations are equivalent, this routine returns the transformation matrix \\spad{TM} with aG0.i * \\spad{TM} = \\spad{TM} * aG1.i for all i. If the representations are not equivalent, a small 0-matrix is returned. Note that the case with different sets of group generators cannot be handled.")) (|standardBasisOfCyclicSubmodule| (((|Matrix| |#1|) (|List| (|Matrix| |#1|)) (|Vector| |#1|)) "\\spad{standardBasisOfCyclicSubmodule(lm,v)} returns a matrix as follows. It is assumed that the size \\spad{n} of the vector equals the number of rows and columns of the matrices. Then the matrices generate a subalgebra, say \\spad{A}, of the algebra of all square matrices of dimension \\spad{n.} \\spad{V} \\spad{R} is an \\spad{A}-module in the natural way. standardBasisOfCyclicSubmodule(lm,v) calculates a matrix whose non-zero column vectors are the R-Basis of Av achieved in the way as described in section 6 of \\spad{R.} A. Parker's \"The Meat-Axe\". Note that in contrast to cyclicSubmodule, the result is not in echelon form.")) (|cyclicSubmodule| (((|Vector| (|Vector| |#1|)) (|List| (|Matrix| |#1|)) (|Vector| |#1|)) "\\spad{cyclicSubmodule(lm,v)} generates a basis as follows. It is assumed that the size \\spad{n} of the vector equals the number of rows and columns of the matrices. Then the matrices generate a subalgebra, say \\spad{A}, of the algebra of all square matrices of dimension \\spad{n.} \\spad{V} \\spad{R} is an \\spad{A}-module in the natural way. cyclicSubmodule(lm,v) generates the R-Basis of Av as described in section 6 of \\spad{R.} A. Parker's \"The Meat-Axe\". Note that in contrast to the description in \"The Meat-Axe\" and to standardBasisOfCyclicSubmodule the result is in echelon form.")) (|createRandomElement| (((|Matrix| |#1|) (|List| (|Matrix| |#1|)) (|Matrix| |#1|)) "\\spad{createRandomElement(aG,x)} creates a random element of the group algebra generated by aG.")) (|completeEchelonBasis| (((|Matrix| |#1|) (|Vector| (|Vector| |#1|))) "\\spad{completeEchelonBasis(lv)} completes the basis \\spad{lv} assumed to be in echelon form of a subspace of R**n \\spad{(n} the length of all the vectors in \\spad{lv} with unit vectors to a basis of R**n. It is assumed that the argument is not an empty vector and that it is not the basis of the 0-subspace. Note that the rows of the result correspond to the vectors of the basis."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|Field|))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|Finite|)))) (|HasCategory| |#1| (QUOTE (|EuclideanDomain|)))) 
(|RepeatedDoubling| S) 
((|constructor| (NIL "Implements multiplication by repeated addition")) (|double| ((|#1| (|PositiveInteger|) |#1|) "\\spad{double(i, \\spad{r)}} multiplies \\spad{r} by \\spad{i} using repeated doubling.")) (+ (($ $ $) "\\spad{x+y} returns the sum of \\spad{x} and \\spad{y}"))) 
NIL 
NIL 
(|RadicalEigenPackage|) 
((|constructor| (NIL "Package for the computation of eigenvalues and eigenvectors. This package works for matrices with coefficients which are rational functions over the integers. (see \\spadtype{Fraction Polynomial Integer}). The eigenvalues and eigenvectors are expressed in terms of radicals.")) (|orthonormalBasis| (((|List| (|Matrix| (|Expression| (|Integer|)))) (|Matrix| (|Fraction| (|Polynomial| (|Integer|))))) "\\spad{orthonormalBasis(m)} returns the orthogonal matrix \\spad{b} such that \\spad{b*m*(inverse \\spad{b)}} is diagonal. Error: if \\spad{m} is not a symmetric matrix.")) (|gramschmidt| (((|List| (|Matrix| (|Expression| (|Integer|)))) (|List| (|Matrix| (|Expression| (|Integer|))))) "\\spad{gramschmidt(lv)} converts the list of column vectors \\spad{lv} into a set of orthogonal column vectors of euclidean length 1 using the Gram-Schmidt algorithm.")) (|normalise| (((|Matrix| (|Expression| (|Integer|))) (|Matrix| (|Expression| (|Integer|)))) "\\spad{normalise(v)} returns the column vector \\spad{v} divided by its euclidean norm; when possible, the vector \\spad{v} is expressed in terms of radicals.")) (|eigenMatrix| (((|Union| (|Matrix| (|Expression| (|Integer|))) "failed") (|Matrix| (|Fraction| (|Polynomial| (|Integer|))))) "\\spad{eigenMatrix(m)} returns the matrix \\spad{b} such that \\spad{b*m*(inverse \\spad{b)}} is diagonal, or \"failed\" if no such \\spad{b} exists.")) (|radicalEigenvalues| (((|List| (|Expression| (|Integer|))) (|Matrix| (|Fraction| (|Polynomial| (|Integer|))))) "\\spad{radicalEigenvalues(m)} computes the eigenvalues of the matrix \\spad{m;} when possible, the eigenvalues are expressed in terms of radicals.")) (|radicalEigenvector| (((|List| (|Matrix| (|Expression| (|Integer|)))) (|Expression| (|Integer|)) (|Matrix| (|Fraction| (|Polynomial| (|Integer|))))) "\\spad{radicalEigenvector(c,m)} computes the eigenvector(s) of the matrix \\spad{m} corresponding to the eigenvalue \\spad{c;} when possible, values are expressed in terms of radicals.")) (|radicalEigenvectors| (((|List| (|Record| (|:| |radval| (|Expression| (|Integer|))) (|:| |radmult| (|Integer|)) (|:| |radvect| (|List| (|Matrix| (|Expression| (|Integer|))))))) (|Matrix| (|Fraction| (|Polynomial| (|Integer|))))) "\\spad{radicalEigenvectors(m)} computes the eigenvalues and the corresponding eigenvectors of the matrix \\spad{m;} when possible, values are expressed in terms of radicals."))) 
NIL 
NIL 
(|RepeatedSquaring| S) 
((|constructor| (NIL "Implements exponentiation by repeated squaring")) (|expt| ((|#1| |#1| (|PositiveInteger|)) "\\spad{expt(r, i)} computes r**i by repeated squaring")) (* (($ $ $) "\\spad{x*y} returns the product of \\spad{x} and \\spad{y}"))) 
NIL 
NIL 
(|ResolveLatticeCompletion| S) 
((|constructor| (NIL "This package provides coercions for the special types \\spadtype{Exit} and \\spadtype{Void}.")) (|coerce| ((|#1| (|Exit|)) "\\spad{coerce(e)} is never really evaluated. This coercion is used for formal type correctness when a function will not return directly to its caller.") (((|Void|) |#1|) "\\spad{coerce(s)} throws all information about \\spad{s} away. This coercion allows values of any type to appear in contexts where they will not be used. For example, it allows the resolution of different types in the \\spad{then} and \\spad{else} branches when an \\spad{if} is in a context where the resulting value is not used."))) 
NIL 
NIL 
(|ResidueRing| F |Expon| |VarSet| |FPol| |LFPol|) 
((|constructor| (NIL "ResidueRing is the quotient of a polynomial ring by an ideal. The ideal is given as a list of generators. The elements of the domain are equivalence classes expressed in terms of reduced elements")) (|lift| ((|#4| $) "\\spad{lift(x)} return the canonical representative of the equivalence class \\spad{x}")) (|coerce| (($ |#4|) "\\spad{coerce(f)} produces the equivalence class of \\spad{f} in the residue ring")) (|reduce| (($ |#4|) "\\spad{reduce(f)} produces the equivalence class of \\spad{f} in the residue ring"))) 
(((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|Result|) 
((|constructor| (NIL "A domain used to return the results from a call to the NAG Library. It prints as a list of names and types, though the user may choose to display values automatically if he or she wishes.")) (|showArrayValues| (((|Boolean|) (|Boolean|)) "\\spad{showArrayValues(true)} forces the values of array components to be \\indented{1}{displayed rather than just their types.}")) (|showScalarValues| (((|Boolean|) (|Boolean|)) "\\spad{showScalarValues(true)} forces the values of scalar components to be \\indented{1}{displayed rather than just their types.}"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|))) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|))) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|))) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (QUOTE (|Symbol|))) (LIST (QUOTE |:|) (QUOTE |entry|) (QUOTE (|Any|)))))) (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|))) (QUOTE (|SetCategory|)))) (|HasCategory| (|Symbol|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Any|) (QUOTE (|SetCategory|))) (OR (|HasCategory| (|Any|) (QUOTE (|SetCategory|))) (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|))) (QUOTE (|SetCategory|)))) (AND (|HasCategory| (|Any|) (LIST (QUOTE |Evalable|) (QUOTE (|Any|)))) (|HasCategory| (|Any|) (QUOTE (|SetCategory|))))) 
(|RetractableTo&| A S) 
((|constructor| (NIL "A is retractable to \\spad{B} means that some elements if A can be converted into elements of \\spad{B} and any element of \\spad{B} can be converted into an element of A.")) (|retract| ((|#2| $) "\\spad{retract(a)} transforms a into an element of \\spad{S} if possible. Error: if a cannot be made into an element of \\spad{S.}")) (|retractIfCan| (((|Union| |#2| "failed") $) "\\spad{retractIfCan(a)} transforms a into an element of \\spad{S} if possible. Returns \"failed\" if a cannot be made into an element of \\spad{S.}")) (|coerce| (($ |#2|) "\\spad{coerce(a)} transforms a into an element of \\spad{%.}"))) 
NIL 
NIL 
(|RetractableTo| S) 
((|constructor| (NIL "A is retractable to \\spad{B} means that some elements if A can be converted into elements of \\spad{B} and any element of \\spad{B} can be converted into an element of A.")) (|retract| ((|#1| $) "\\spad{retract(a)} transforms a into an element of \\spad{S} if possible. Error: if a cannot be made into an element of \\spad{S.}")) (|retractIfCan| (((|Union| |#1| "failed") $) "\\spad{retractIfCan(a)} transforms a into an element of \\spad{S} if possible. Returns \"failed\" if a cannot be made into an element of \\spad{S.}")) (|coerce| (($ |#1|) "\\spad{coerce(a)} transforms a into an element of \\spad{%.}"))) 
NIL 
NIL 
(|RetractSolvePackage| Q R) 
((|constructor| (NIL "RetractSolvePackage is an interface to \\spadtype{SystemSolvePackage} that attempts to retract the coefficients of the equations before solving.")) (|solveRetract| (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#2|))))) (|List| (|Polynomial| |#2|)) (|List| (|Symbol|))) "\\spad{solveRetract(lp,lv)} finds the solutions of the list \\spad{lp} of rational functions with respect to the list of symbols \\spad{lv.} The function tries to retract all the coefficients of the equations to \\spad{Q} before solving if possible."))) 
NIL 
NIL 
(|RandomFloatDistributions|) 
((|t| (((|Mapping| (|Float|)) (|NonNegativeInteger|)) "\\spad{t(n)} \\undocumented")) (F (((|Mapping| (|Float|)) (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{F(n,m)} \\undocumented")) (|Beta| (((|Mapping| (|Float|)) (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{Beta(n,m)} \\undocumented")) (|chiSquare| (((|Mapping| (|Float|)) (|NonNegativeInteger|)) "\\spad{chiSquare(n)} \\undocumented")) (|exponential| (((|Mapping| (|Float|)) (|Float|)) "\\spad{exponential(f)} \\undocumented")) (|normal| (((|Mapping| (|Float|)) (|Float|) (|Float|)) "\\spad{normal(f,g)} \\undocumented")) (|uniform| (((|Mapping| (|Float|)) (|Float|) (|Float|)) "\\spad{uniform(f,g)} \\undocumented")) (|chiSquare1| (((|Float|) (|NonNegativeInteger|)) "\\spad{chiSquare1(n)} \\undocumented")) (|exponential1| (((|Float|)) "\\spad{exponential1()} \\undocumented")) (|normal01| (((|Float|)) "\\spad{normal01()} \\undocumented")) (|uniform01| (((|Float|)) "\\spad{uniform01()} \\undocumented"))) 
NIL 
NIL 
(|RationalFunctionFactor| UP) 
((|constructor| (NIL "Factorization of univariate polynomials with coefficients which are rational functions with integer coefficients.")) (|factor| (((|Factored| |#1|) |#1|) "\\spad{factor(p)} returns a prime factorisation of \\spad{p.}"))) 
NIL 
NIL 
(|RationalFunctionFactorizer| R) 
((|constructor| (NIL "\\spadtype{RationalFunctionFactorizer} contains the factor function (called factorFraction) which factors fractions of polynomials by factoring the numerator and denominator. Since any non zero fraction is a unit the usual factor operation will just return the original fraction.")) (|factorFraction| (((|Fraction| (|Factored| (|Polynomial| |#1|))) (|Fraction| (|Polynomial| |#1|))) "\\spad{factorFraction(r)} factors the numerator and the denominator of the polynomial fraction \\spad{r.}"))) 
NIL 
NIL 
(|RationalFunction| R) 
((|constructor| (NIL "Utilities that provide the same top-level manipulations on fractions than on polynomials.")) (|coerce| (((|Fraction| (|Polynomial| |#1|)) |#1|) "\\spad{coerce(r)} returns \\spad{r} viewed as a rational function over \\spad{R.}")) (|eval| (((|Fraction| (|Polynomial| |#1|)) (|Fraction| (|Polynomial| |#1|)) (|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))) "\\spad{eval(f, \\spad{[v1} = g1,...,vn = gn])} returns \\spad{f} with each \\spad{vi} replaced by \\spad{gi} in parallel, \\spadignore{i.e.} vi's appearing inside the gi's are not replaced. Error: if any \\spad{vi} is not a symbol.") (((|Fraction| (|Polynomial| |#1|)) (|Fraction| (|Polynomial| |#1|)) (|Equation| (|Fraction| (|Polynomial| |#1|)))) "\\spad{eval(f, \\spad{v} = \\spad{g)}} returns \\spad{f} with \\spad{v} replaced by \\spad{g.} Error: if \\spad{v} is not a symbol.") (((|Fraction| (|Polynomial| |#1|)) (|Fraction| (|Polynomial| |#1|)) (|List| (|Symbol|)) (|List| (|Fraction| (|Polynomial| |#1|)))) "\\spad{eval(f, [v1,...,vn], [g1,...,gn])} returns \\spad{f} with each \\spad{vi} replaced by \\spad{gi} in parallel, \\spadignore{i.e.} vi's appearing inside the gi's are not replaced.") (((|Fraction| (|Polynomial| |#1|)) (|Fraction| (|Polynomial| |#1|)) (|Symbol|) (|Fraction| (|Polynomial| |#1|))) "\\spad{eval(f, \\spad{v,} \\spad{g)}} returns \\spad{f} with \\spad{v} replaced by \\spad{g.}")) (|multivariate| (((|Fraction| (|Polynomial| |#1|)) (|Fraction| (|SparseUnivariatePolynomial| (|Fraction| (|Polynomial| |#1|)))) (|Symbol|)) "\\spad{multivariate(f, \\spad{v)}} applies both the numerator and denominator of \\spad{f} to \\spad{v.}")) (|univariate| (((|Fraction| (|SparseUnivariatePolynomial| (|Fraction| (|Polynomial| |#1|)))) (|Fraction| (|Polynomial| |#1|)) (|Symbol|)) "\\spad{univariate(f, \\spad{v)}} returns \\spad{f} viewed as a univariate rational function in \\spad{v.}")) (|mainVariable| (((|Union| (|Symbol|) "failed") (|Fraction| (|Polynomial| |#1|))) "\\spad{mainVariable(f)} returns the highest variable appearing in the numerator or the denominator of \\spad{f,} \"failed\" if \\spad{f} has no variables.")) (|variables| (((|List| (|Symbol|)) (|Fraction| (|Polynomial| |#1|))) "\\spad{variables(f)} returns the list of variables appearing in the numerator or the denominator of \\spad{f.}"))) 
NIL 
NIL 
(|RootsFindingPackage| K) 
((|constructor| (NIL "This pacackage finds all the roots of a polynomial. If the constant field is not large enough then it returns the list of found zeros and the degree of the extension need to find the other roots missing. If the return degree is 1 then all the roots have been found. If 0 is return for the extension degree then there are an infinite number of zeros, that is you ask for the zeroes of 0. In the case of infinite field a list of all found zeros is kept and for each other call of a function that finds zeroes, a check is made on that list; this is to keep a kind of \"canonical\" representation of the elements.")) (|setFoundZeroes| (((|List| |#1|) (|List| |#1|)) "\\spad{setFoundZeroes sets} the list of foundZeroes to the given one.")) (|foundZeroes| (((|List| |#1|)) "\\spad{foundZeroes returns} the list of already found zeros by the functions distinguishedRootsOf and distinguishedCommonRootsOf.")) (|distinguishedCommonRootsOf| (((|Record| (|:| |zeros| (|List| |#1|)) (|:| |extDegree| (|Integer|))) (|List| (|SparseUnivariatePolynomial| |#1|)) |#1|) "\\spad{distinguishedCommonRootsOf returns} the common zeros of a list of polynomial. It returns a record as in distinguishedRootsOf. If 0 is returned as extension degree then there are an infinite number of common zeros (in this case, the polynomial 0 was given in the list of input polynomials).")) (|distinguishedRootsOf| (((|Record| (|:| |zeros| (|List| |#1|)) (|:| |extDegree| (|Integer|))) (|SparseUnivariatePolynomial| |#1|) |#1|) "\\spad{distinguishedRootsOf returns} a record consisting of a list of zeros of the input polynomial followed by the smallest extension degree needed to find all the zeros. If \\spad{K} has \\spad{PseudoAlgebraicClosureOfFiniteFieldCategory} or \\spad{PseudoAlgebraicClosureOfRationalNumberCategory} then a root is created for each irreducible factor, and only these roots are returns and not their conjugate."))) 
NIL 
NIL 
(|RegularChain| R |ls|) 
((|constructor| (NIL "A domain for regular chains (\\spadignore{i.e.} regular triangular sets) over a Gcd-Domain and with a fix list of variables. This is just a front-end for the \\spadtype{RegularTriangularSet} domain constructor.")) (|zeroSetSplit| (((|List| $) (|List| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))) (|Boolean|) (|Boolean|)) "\\spad{zeroSetSplit(lp,clos?,info?)} returns a list \\spad{lts} of regular chains such that the union of the closures of their regular zero sets equals the affine variety associated with \\spad{lp}. Moreover, if \\spad{clos?} is \\spad{false} then the union of the regular zero set of the \\spad{ts} (for \\spad{ts} in \\spad{lts}) equals this variety. If \\spad{info?} is \\spad{true} then some information is displayed during the computations. See zeroSetSplit from RegularTriangularSet."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |NewSparseMultivariatePolynomial|) (|devaluate| |#1|) (LIST (QUOTE |OrderedVariableList|) (|devaluate| |#2|))))) (|HasCategory| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|)) (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| (|OrderedVariableList| |#2|) (QUOTE (|Finite|)))) 
(|RandomIntegerDistributions|) 
((|constructor| (NIL "This package exports integer distributions")) (|ridHack1| (((|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Integer|)) "\\spad{ridHack1(i,j,k,l)} \\undocumented")) (|geometric| (((|Mapping| (|Integer|)) |RationalNumber|) "\\spad{geometric(f)} \\undocumented")) (|poisson| (((|Mapping| (|Integer|)) |RationalNumber|) "\\spad{poisson(f)} \\undocumented")) (|binomial| (((|Mapping| (|Integer|)) (|Integer|) |RationalNumber|) "\\spad{binomial(n,f)} \\undocumented")) (|uniform| (((|Mapping| (|Integer|)) (|Segment| (|Integer|))) "\\spad{uniform(s)} as \\indented{4}{l + \\spad{u0} + \\spad{w*u1} + \\spad{w**2*u2} +...+ \\spad{w**(n-1)*u-1} + w**n*m} where \\indented{4}{s = a..b} \\indented{4}{l = min(a,b)} \\indented{4}{m = abs(b-a) + 1} \\indented{4}{w**n < \\spad{m} < w**(n+1)} \\indented{4}{u0,...,un-1\\space{2}are uniform on\\space{2}0..w-1} \\indented{4}{m\\space{12}is\\space{2}uniform on\\space{2}0..(m quo w**n)-1}"))) 
NIL 
NIL 
(|Ring&| S) 
((|constructor| (NIL "The category of rings with unity, always associative, but not necessarily commutative.")) (|unitsKnown| ((|attribute|) "recip truly yields reciprocal or \"failed\" if not a unit. Note that \\spad{recip(0) = \"failed\"}.")) (|coerce| (($ (|Integer|)) "\\spad{coerce(i)} converts the integer \\spad{i} to a member of the given domain.")) (|characteristic| (((|NonNegativeInteger|)) "\\spad{characteristic()} returns the characteristic of the ring this is the smallest positive integer \\spad{n} such that \\spad{n*x=0} for all \\spad{x} in the ring, or zero if no such \\spad{n} exists."))) 
NIL 
NIL 
(|Ring|) 
((|constructor| (NIL "The category of rings with unity, always associative, but not necessarily commutative.")) (|unitsKnown| ((|attribute|) "recip truly yields reciprocal or \"failed\" if not a unit. Note that \\spad{recip(0) = \"failed\"}.")) (|coerce| (($ (|Integer|)) "\\spad{coerce(i)} converts the integer \\spad{i} to a member of the given domain.")) (|characteristic| (((|NonNegativeInteger|)) "\\spad{characteristic()} returns the characteristic of the ring this is the smallest positive integer \\spad{n} such that \\spad{n*x=0} for all \\spad{x} in the ring, or zero if no such \\spad{n} exists."))) 
((|unitsKnown| . T)) 
NIL 
(|RationalInterpolation| |xx| F) 
((|constructor| (NIL "This package exports rational interpolation algorithms"))) 
NIL 
NIL 
(|RectangularMatrixCategory&| S |m| |n| R |Row| |Col|) 
((|constructor| (NIL "\\spadtype{RectangularMatrixCategory} is a category of matrices of fixed dimensions. The dimensions of the matrix will be parameters of the domain. Domains in this category will be R-modules and will be non-mutable.")) (|nullSpace| (((|List| |#6|) $) "\\spad{nullSpace(m)}+ returns a basis for the null space of the matrix \\spad{m.}")) (|nullity| (((|NonNegativeInteger|) $) "\\spad{nullity(m)} returns the nullity of the matrix \\spad{m.} This is the dimension of the null space of the matrix \\spad{m.}")) (|rank| (((|NonNegativeInteger|) $) "\\spad{rank(m)} returns the rank of the matrix \\spad{m.}")) (|rowEchelon| (($ $) "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m.}")) (/ (($ $ |#4|) "\\spad{m/r} divides the elements of \\spad{m} by \\spad{r.} Error: if \\spad{r = 0}.")) (|exquo| (((|Union| $ "failed") $ |#4|) "\\spad{exquo(m,r)} computes the exact quotient of the elements of \\spad{m} by \\spad{r,} returning \\axiom{\"failed\"} if this is not possible.")) (|map| (($ (|Mapping| |#4| |#4| |#4|) $ $) "\\spad{map(f,a,b)} returns \\spad{c,} where \\spad{c} is such that \\spad{c(i,j) = f(a(i,j),b(i,j))} for all \\spad{i}, \\spad{j.}") (($ (|Mapping| |#4| |#4|) $) "\\spad{map(f,a)} returns \\spad{b,} where \\spad{b(i,j) = a(i,j)} for all i, \\spad{j.}")) (|column| ((|#6| $ (|Integer|)) "\\spad{column(m,j)} returns the \\spad{j}th column of the matrix \\spad{m.} Error: if the index outside the proper range.")) (|row| ((|#5| $ (|Integer|)) "\\spad{row(m,i)} returns the \\spad{i}th row of the matrix \\spad{m.} Error: if the index is outside the proper range.")) (|qelt| ((|#4| $ (|Integer|) (|Integer|)) "\\spad{qelt(m,i,j)} returns the element in the \\spad{i}th row and \\spad{j}th column of the matrix \\spad{m.} Note that there is NO error check to determine if indices are in the proper ranges.")) (|elt| ((|#4| $ (|Integer|) (|Integer|) |#4|) "\\spad{elt(m,i,j,r)} returns the element in the \\spad{i}th row and \\spad{j}th column of the matrix \\spad{m,} if \\spad{m} has an \\spad{i}th row and a \\spad{j}th column, and returns \\spad{r} otherwise.") ((|#4| $ (|Integer|) (|Integer|)) "\\spad{elt(m,i,j)} returns the element in the \\spad{i}th row and \\spad{j}th column of the matrix \\spad{m.} Error: if indices are outside the proper ranges.")) (|listOfLists| (((|List| (|List| |#4|)) $) "\\spad{listOfLists(m)} returns the rows of the matrix \\spad{m} as a list of lists.")) (|ncols| (((|NonNegativeInteger|) $) "\\spad{ncols(m)} returns the number of columns in the matrix \\spad{m.}")) (|nrows| (((|NonNegativeInteger|) $) "\\spad{nrows(m)} returns the number of rows in the matrix \\spad{m.}")) (|maxColIndex| (((|Integer|) $) "\\spad{maxColIndex(m)} returns the index of the 'last' column of the matrix \\spad{m.}")) (|minColIndex| (((|Integer|) $) "\\spad{minColIndex(m)} returns the index of the 'first' column of the matrix \\spad{m.}")) (|maxRowIndex| (((|Integer|) $) "\\spad{maxRowIndex(m)} returns the index of the 'last' row of the matrix \\spad{m.}")) (|minRowIndex| (((|Integer|) $) "\\spad{minRowIndex(m)} returns the index of the 'first' row of the matrix \\spad{m.}")) (|antisymmetric?| (((|Boolean|) $) "\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and antisymmetric. That is, \\spad{m[i,j] = -m[j,i]} for all \\spad{i} and \\spad{j} and \\spad{false} otherwise.")) (|symmetric?| (((|Boolean|) $) "\\spad{symmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and symmetric (that is, \\spad{m[i,j] = m[j,i]} for all \\spad{i} and \\spad{j)} and \\spad{false} otherwise.")) (|diagonal?| (((|Boolean|) $) "\\spad{diagonal?(m)} returns \\spad{true} if the matrix \\spad{m} is square and diagonal (that is, all entries of \\spad{m} not on the diagonal are zero) and \\spad{false} otherwise.")) (|square?| (((|Boolean|) $) "\\spad{square?(m)} returns \\spad{true} if \\spad{m} is a square matrix (that is, if \\spad{m} has the same number of rows as columns) and \\spad{false} otherwise.")) (|matrix| (($ (|List| (|List| |#4|))) "\\spad{matrix(l)} converts the list of lists \\spad{l} to a matrix, where the list of lists is viewed as a list of the rows of the matrix.")) (|finiteAggregate| ((|attribute|) "matrices are finite"))) 
NIL 
((|HasCategory| |#4| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#4| (QUOTE (|Field|))) (|HasCategory| |#4| (QUOTE (|IntegralDomain|))) (|HasCategory| |#4| (QUOTE (|CommutativeRing|)))) 
(|RectangularMatrixCategory| |m| |n| R |Row| |Col|) 
((|constructor| (NIL "\\spadtype{RectangularMatrixCategory} is a category of matrices of fixed dimensions. The dimensions of the matrix will be parameters of the domain. Domains in this category will be R-modules and will be non-mutable.")) (|nullSpace| (((|List| |#5|) $) "\\spad{nullSpace(m)}+ returns a basis for the null space of the matrix \\spad{m.}")) (|nullity| (((|NonNegativeInteger|) $) "\\spad{nullity(m)} returns the nullity of the matrix \\spad{m.} This is the dimension of the null space of the matrix \\spad{m.}")) (|rank| (((|NonNegativeInteger|) $) "\\spad{rank(m)} returns the rank of the matrix \\spad{m.}")) (|rowEchelon| (($ $) "\\spad{rowEchelon(m)} returns the row echelon form of the matrix \\spad{m.}")) (/ (($ $ |#3|) "\\spad{m/r} divides the elements of \\spad{m} by \\spad{r.} Error: if \\spad{r = 0}.")) (|exquo| (((|Union| $ "failed") $ |#3|) "\\spad{exquo(m,r)} computes the exact quotient of the elements of \\spad{m} by \\spad{r,} returning \\axiom{\"failed\"} if this is not possible.")) (|map| (($ (|Mapping| |#3| |#3| |#3|) $ $) "\\spad{map(f,a,b)} returns \\spad{c,} where \\spad{c} is such that \\spad{c(i,j) = f(a(i,j),b(i,j))} for all \\spad{i}, \\spad{j.}") (($ (|Mapping| |#3| |#3|) $) "\\spad{map(f,a)} returns \\spad{b,} where \\spad{b(i,j) = a(i,j)} for all i, \\spad{j.}")) (|column| ((|#5| $ (|Integer|)) "\\spad{column(m,j)} returns the \\spad{j}th column of the matrix \\spad{m.} Error: if the index outside the proper range.")) (|row| ((|#4| $ (|Integer|)) "\\spad{row(m,i)} returns the \\spad{i}th row of the matrix \\spad{m.} Error: if the index is outside the proper range.")) (|qelt| ((|#3| $ (|Integer|) (|Integer|)) "\\spad{qelt(m,i,j)} returns the element in the \\spad{i}th row and \\spad{j}th column of the matrix \\spad{m.} Note that there is NO error check to determine if indices are in the proper ranges.")) (|elt| ((|#3| $ (|Integer|) (|Integer|) |#3|) "\\spad{elt(m,i,j,r)} returns the element in the \\spad{i}th row and \\spad{j}th column of the matrix \\spad{m,} if \\spad{m} has an \\spad{i}th row and a \\spad{j}th column, and returns \\spad{r} otherwise.") ((|#3| $ (|Integer|) (|Integer|)) "\\spad{elt(m,i,j)} returns the element in the \\spad{i}th row and \\spad{j}th column of the matrix \\spad{m.} Error: if indices are outside the proper ranges.")) (|listOfLists| (((|List| (|List| |#3|)) $) "\\spad{listOfLists(m)} returns the rows of the matrix \\spad{m} as a list of lists.")) (|ncols| (((|NonNegativeInteger|) $) "\\spad{ncols(m)} returns the number of columns in the matrix \\spad{m.}")) (|nrows| (((|NonNegativeInteger|) $) "\\spad{nrows(m)} returns the number of rows in the matrix \\spad{m.}")) (|maxColIndex| (((|Integer|) $) "\\spad{maxColIndex(m)} returns the index of the 'last' column of the matrix \\spad{m.}")) (|minColIndex| (((|Integer|) $) "\\spad{minColIndex(m)} returns the index of the 'first' column of the matrix \\spad{m.}")) (|maxRowIndex| (((|Integer|) $) "\\spad{maxRowIndex(m)} returns the index of the 'last' row of the matrix \\spad{m.}")) (|minRowIndex| (((|Integer|) $) "\\spad{minRowIndex(m)} returns the index of the 'first' row of the matrix \\spad{m.}")) (|antisymmetric?| (((|Boolean|) $) "\\spad{antisymmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and antisymmetric. That is, \\spad{m[i,j] = -m[j,i]} for all \\spad{i} and \\spad{j} and \\spad{false} otherwise.")) (|symmetric?| (((|Boolean|) $) "\\spad{symmetric?(m)} returns \\spad{true} if the matrix \\spad{m} is square and symmetric (that is, \\spad{m[i,j] = m[j,i]} for all \\spad{i} and \\spad{j)} and \\spad{false} otherwise.")) (|diagonal?| (((|Boolean|) $) "\\spad{diagonal?(m)} returns \\spad{true} if the matrix \\spad{m} is square and diagonal (that is, all entries of \\spad{m} not on the diagonal are zero) and \\spad{false} otherwise.")) (|square?| (((|Boolean|) $) "\\spad{square?(m)} returns \\spad{true} if \\spad{m} is a square matrix (that is, if \\spad{m} has the same number of rows as columns) and \\spad{false} otherwise.")) (|matrix| (($ (|List| (|List| |#3|))) "\\spad{matrix(l)} converts the list of lists \\spad{l} to a matrix, where the list of lists is viewed as a list of the rows of the matrix.")) (|finiteAggregate| ((|attribute|) "matrices are finite"))) 
((|finiteAggregate| . T) (|nil| . T) (|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|RectangularMatrix| |m| |n| R) 
((|constructor| (NIL "\\spadtype{RectangularMatrix} is a matrix domain where the number of rows and the number of columns are parameters of the domain.")) (|coerce| (((|Matrix| |#3|) $) "\\spad{coerce(m)} converts a matrix of type \\spadtype{RectangularMatrix} to a matrix of type \\spad{Matrix}.")) (|rectangularMatrix| (($ (|Matrix| |#3|)) "\\spad{rectangularMatrix(m)} converts a matrix of type \\spadtype{Matrix} to a matrix of type \\spad{RectangularMatrix}."))) 
((|finiteAggregate| . T) (|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| |#3| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#3| (QUOTE (|Field|))) (|HasCategory| |#3| (QUOTE (|SetCategory|))) (|HasCategory| |#3| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#3| (QUOTE (|IntegralDomain|))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|Field|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|Field|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))))) 
(|RectangularMatrixCategoryFunctions2| |m| |n| R1 |Row1| |Col1| M1 R2 |Row2| |Col2| M2) 
((|constructor| (NIL "\\spadtype{RectangularMatrixCategoryFunctions2} provides functions between two matrix domains. The functions provided are \\spadfun{map} and \\spadfun{reduce}.")) (|reduce| ((|#7| (|Mapping| |#7| |#3| |#7|) |#6| |#7|) "\\spad{reduce(f,m,r)} returns a matrix \\spad{n} where \\spad{n[i,j] = f(m[i,j],r)} for all indices spad{i} and \\spad{j}.")) (|map| ((|#10| (|Mapping| |#7| |#3|) |#6|) "\\spad{map(f,m)} applies the function \\spad{f} to the elements of the matrix \\spad{m}."))) 
NIL 
NIL 
(|RightModule| R) 
((|constructor| (NIL "The category of right modules over an \\spad{rng} (ring not necessarily with unit). This is an abelian group which supports right multiplication by elements of the rng. \\blankline Axioms\\br \\tab{5}\\spad{x*(a*b) = (x*a)*b}\\br \\tab{5}\\spad{x*(a+b) = (x*a)+(x*b)}\\br \\tab{5}\\spad{(x+y)*x = (x*a)+(y*a)}")) (* (($ $ |#1|) "\\spad{x*r} returns the right multiplication of the module element \\spad{x} by the ring element \\spad{r.}"))) 
NIL 
NIL 
(|Rng|) 
((|constructor| (NIL "The category of associative rings, not necessarily commutative, and not necessarily with a 1. This is a combination of an abelian group and a semigroup, with multiplication distributing over addition. \\blankline Axioms\\br \\tab{5}\\spad{ x*(y+z) = x*y + x*z}\\br \\tab{5}\\spad{ (x+y)*z = \\spad{x*z} + \\spad{y*z} } \\blankline Conditional attributes\\br \\tab{5}noZeroDivisors\\tab{5}\\spad{ ab = 0 \\spad{=>} \\spad{a=0} or b=0}"))) 
NIL 
NIL 
(|RealNumberSystem&| S) 
((|constructor| (NIL "The real number system category is intended as a model for the real numbers. The real numbers form an ordered normed field. Note that we have purposely not included \\spadtype{DifferentialRing} or the elementary functions (see \\spadtype{TranscendentalFunctionCategory}) in the definition.")) (|abs| (($ $) "\\spad{abs \\spad{x}} returns the absolute value of \\spad{x.}")) (|round| (($ $) "\\spad{round \\spad{x}} computes the integer closest to \\spad{x.}")) (|truncate| (($ $) "\\spad{truncate \\spad{x}} returns the integer between \\spad{x} and 0 closest to \\spad{x.}")) (|fractionPart| (($ $) "\\spad{fractionPart \\spad{x}} returns the fractional part of \\spad{x.}")) (|wholePart| (((|Integer|) $) "\\spad{wholePart \\spad{x}} returns the integer part of \\spad{x.}")) (|floor| (($ $) "\\spad{floor \\spad{x}} returns the largest integer \\spad{<= \\spad{x}.}")) (|ceiling| (($ $) "\\spad{ceiling \\spad{x}} returns the small integer \\spad{>= \\spad{x}.}")) (|norm| (($ $) "\\spad{norm \\spad{x}} returns the same as absolute value."))) 
NIL 
NIL 
(|RealNumberSystem|) 
((|constructor| (NIL "The real number system category is intended as a model for the real numbers. The real numbers form an ordered normed field. Note that we have purposely not included \\spadtype{DifferentialRing} or the elementary functions (see \\spadtype{TranscendentalFunctionCategory}) in the definition.")) (|abs| (($ $) "\\spad{abs \\spad{x}} returns the absolute value of \\spad{x.}")) (|round| (($ $) "\\spad{round \\spad{x}} computes the integer closest to \\spad{x.}")) (|truncate| (($ $) "\\spad{truncate \\spad{x}} returns the integer between \\spad{x} and 0 closest to \\spad{x.}")) (|fractionPart| (($ $) "\\spad{fractionPart \\spad{x}} returns the fractional part of \\spad{x.}")) (|wholePart| (((|Integer|) $) "\\spad{wholePart \\spad{x}} returns the integer part of \\spad{x.}")) (|floor| (($ $) "\\spad{floor \\spad{x}} returns the largest integer \\spad{<= \\spad{x}.}")) (|ceiling| (($ $) "\\spad{ceiling \\spad{x}} returns the small integer \\spad{>= \\spad{x}.}")) (|norm| (($ $) "\\spad{norm \\spad{x}} returns the same as absolute value."))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|RightOpenIntervalRootCharacterization| |TheField| |ThePolDom|) 
((|constructor| (NIL "\\axiomType{RightOpenIntervalRootCharacterization} provides work with interval root coding.")) (|relativeApprox| ((|#1| |#2| $ |#1|) "\\axiom{relativeApprox(exp,c,p) = a} is relatively close to exp as a polynomial in \\spad{c} ip to precision \\spad{p}")) (|mightHaveRoots| (((|Boolean|) |#2| $) "\\axiom{mightHaveRoots(p,r)} is \\spad{false} if \\axiom{p.r} is not 0")) (|refine| (($ $) "\\axiom{refine(rootChar)} shrinks isolating interval around \\axiom{rootChar}")) (|middle| ((|#1| $) "\\axiom{middle(rootChar)} is the middle of the isolating interval")) (|size| ((|#1| $) "The size of the isolating interval")) (|right| ((|#1| $) "\\axiom{right(rootChar)} is the right bound of the isolating interval")) (|left| ((|#1| $) "\\axiom{left(rootChar)} is the left bound of the isolating interval"))) 
NIL 
NIL 
(|RomanNumeral|) 
((|constructor| (NIL "\\spadtype{RomanNumeral} provides functions for converting integers to roman numerals.")) (|roman| (($ (|Integer|)) "\\spad{roman(n)} creates a roman numeral for \\spad{n.}") (($ (|Symbol|)) "\\spad{roman(n)} creates a roman numeral for symbol \\spad{n.}")) (|convert| (($ (|Symbol|)) "\\spad{convert(n)} creates a roman numeral for symbol \\spad{n.}")) (|noetherian| ((|attribute|) "ascending chain condition on ideals.")) (|canonicalsClosed| ((|attribute|) "two positives multiply to give positive.")) (|canonical| ((|attribute|) "mathematical equality is data structure equality."))) 
((|noetherian| . T) (|canonicalsClosed| . T) (|canonical| . T) (|canonicalUnitNormal| . T) (|multiplicativeValuation| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|RoutinesTable|) 
((|constructor| (NIL "\\axiomType{RoutinesTable} implements a database and associated tuning mechanisms for a set of known NAG routines")) (|recoverAfterFail| (((|Union| (|String|) "failed") $ (|String|) (|Integer|)) "\\spad{recoverAfterFail(routs,routineName,ifailValue)} acts on the instructions given by the ifail list")) (|showTheRoutinesTable| (($) "\\spad{showTheRoutinesTable()} returns the current table of NAG routines.")) (|deleteRoutine!| (($ $ (|Symbol|)) "\\spad{deleteRoutine!(R,s)} destructively deletes the given routine from the current database of NAG routines")) (|getExplanations| (((|List| (|String|)) $ (|String|)) "\\spad{getExplanations(R,s)} gets the explanations of the output parameters for the given NAG routine.")) (|getMeasure| (((|Float|) $ (|Symbol|)) "\\spad{getMeasure(R,s)} gets the current value of the maximum measure for the given NAG routine.")) (|changeMeasure| (($ $ (|Symbol|) (|Float|)) "\\spad{changeMeasure(R,s,newValue)} changes the maximum value for a measure of the given NAG routine.")) (|changeThreshhold| (($ $ (|Symbol|) (|Float|)) "\\spad{changeThreshhold(R,s,newValue)} changes the value below which, given a NAG routine generating a higher measure, the routines will make no attempt to generate a measure.")) (|selectMultiDimensionalRoutines| (($ $) "\\spad{selectMultiDimensionalRoutines(R)} chooses only those routines from the database which are designed for use with multi-dimensional expressions")) (|selectNonFiniteRoutines| (($ $) "\\spad{selectNonFiniteRoutines(R)} chooses only those routines from the database which are designed for use with non-finite expressions.")) (|selectSumOfSquaresRoutines| (($ $) "\\spad{selectSumOfSquaresRoutines(R)} chooses only those routines from the database which are designed for use with sums of squares")) (|selectFiniteRoutines| (($ $) "\\spad{selectFiniteRoutines(R)} chooses only those routines from the database which are designed for use with finite expressions")) (|selectODEIVPRoutines| (($ $) "\\spad{selectODEIVPRoutines(R)} chooses only those routines from the database which are for the solution of ODE's")) (|selectPDERoutines| (($ $) "\\spad{selectPDERoutines(R)} chooses only those routines from the database which are for the solution of PDE's")) (|selectOptimizationRoutines| (($ $) "\\spad{selectOptimizationRoutines(R)} chooses only those routines from the database which are for integration")) (|selectIntegrationRoutines| (($ $) "\\spad{selectIntegrationRoutines(R)} chooses only those routines from the database which are for integration")) (|routines| (($) "\\spad{routines()} initialises a database of known NAG routines")) (|concat| (($ $ $) "\\spad{concat(x,y)} merges two tables \\spad{x} and \\spad{y}"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|))) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|))) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|))) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (QUOTE (|Symbol|))) (LIST (QUOTE |:|) (QUOTE |entry|) (QUOTE (|Any|)))))) (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|))) (QUOTE (|SetCategory|)))) (|HasCategory| (|Symbol|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Any|) (QUOTE (|SetCategory|))) (OR (|HasCategory| (|Any|) (QUOTE (|SetCategory|))) (|HasCategory| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|Any|))) (QUOTE (|SetCategory|)))) (AND (|HasCategory| (|Any|) (LIST (QUOTE |Evalable|) (QUOTE (|Any|)))) (|HasCategory| (|Any|) (QUOTE (|SetCategory|))))) 
(|RecursivePolynomialCategory&| S R E V) 
((|constructor| (NIL "\\indented{1}{Author: Marc Moreno Maza} Date Created: 04/22/1994 Date Last Updated: 14/12/1998 Description:")) (|mainSquareFreePart| (($ $) "\\axiom{mainSquareFreePart(p)} returns the square free part of \\axiom{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \\axiom{R}.")) (|mainPrimitivePart| (($ $) "\\axiom{mainPrimitivePart(p)} returns the primitive part of \\axiom{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \\axiom{R}.")) (|mainContent| (($ $) "\\axiom{mainContent(p)} returns the content of \\axiom{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \\axiom{R}.")) (|primitivePart!| (($ $) "\\axiom{primitivePart!(p)} replaces \\axiom{p} by its primitive part.")) (|gcd| ((|#2| |#2| $) "\\axiom{gcd(r,p)} returns the \\spad{gcd} of \\axiom{r} and the content of \\axiom{p}.")) (|nextsubResultant2| (($ $ $ $ $) "\\axiom{nextsubResultant2(p,q,z,s)} is the multivariate version of the operation \\spad{next_sousResultant2} from PseudoRemainderSequence from the \\axiomType{PseudoRemainderSequence} constructor.")) (|LazardQuotient2| (($ $ $ $ (|NonNegativeInteger|)) "\\axiom{LazardQuotient2(p,a,b,n)} returns \\axiom{(a**(n-1) * \\spad{p)} exquo b**(n-1)} assuming that this quotient does not fail.")) (|LazardQuotient| (($ $ $ (|NonNegativeInteger|)) "\\axiom{LazardQuotient(a,b,n)} returns \\axiom{a**n exquo b**(n-1)} assuming that this quotient does not fail.")) (|lastSubResultant| (($ $ $) "\\axiom{lastSubResultant(a,b)} returns the last non-zero subresultant of \\axiom{a} and \\axiom{b} where \\axiom{a} and \\axiom{b} are assumed to have the same main variable \\axiom{v} and are viewed as univariate polynomials in \\axiom{v}.")) (|subResultantChain| (((|List| $) $ $) "\\axiom{subResultantChain(a,b)}, where \\axiom{a} and \\axiom{b} are not contant polynomials with the same main variable, returns the subresultant chain of \\axiom{a} and \\axiom{b}.")) (|resultant| (($ $ $) "\\axiom{resultant(a,b)} computes the resultant of \\axiom{a} and \\axiom{b} where \\axiom{a} and \\axiom{b} are assumed to have the same main variable \\axiom{v} and are viewed as univariate polynomials in \\axiom{v}.")) (|halfExtendedSubResultantGcd2| (((|Record| (|:| |gcd| $) (|:| |coef2| $)) $ $) "\\axiom{halfExtendedSubResultantGcd2(a,b)} returns \\axiom{[g,cb]} if \\axiom{extendedSubResultantGcd(a,b)} returns \\axiom{[g,ca,cb]} otherwise produces an error.")) (|halfExtendedSubResultantGcd1| (((|Record| (|:| |gcd| $) (|:| |coef1| $)) $ $) "\\axiom{halfExtendedSubResultantGcd1(a,b)} returns \\axiom{[g,ca]} if \\axiom{extendedSubResultantGcd(a,b)} returns \\axiom{[g,ca,cb]} otherwise produces an error.")) (|extendedSubResultantGcd| (((|Record| (|:| |gcd| $) (|:| |coef1| $) (|:| |coef2| $)) $ $) "\\axiom{extendedSubResultantGcd(a,b)} returns \\axiom{[ca,cb,r]} such that \\axiom{r} is \\axiom{subResultantGcd(a,b)} and we have \\axiom{ca * a + \\spad{cb} * \\spad{cb} = \\spad{r}} .")) (|subResultantGcd| (($ $ $) "\\axiom{subResultantGcd(a,b)} computes a \\spad{gcd} of \\axiom{a} and \\axiom{b} where \\axiom{a} and \\axiom{b} are assumed to have the same main variable \\axiom{v} and are viewed as univariate polynomials in \\axiom{v} with coefficients in the fraction field of the polynomial ring generated by their other variables over \\axiom{R}.")) (|exactQuotient!| (($ $ $) "\\axiom{exactQuotient!(a,b)} replaces \\axiom{a} by \\axiom{exactQuotient(a,b)}") (($ $ |#2|) "\\axiom{exactQuotient!(p,r)} replaces \\axiom{p} by \\axiom{exactQuotient(p,r)}.")) (|exactQuotient| (($ $ $) "\\axiom{exactQuotient(a,b)} computes the exact quotient of \\axiom{a} by \\axiom{b}, which is assumed to be a divisor of \\axiom{a}. No error is returned if this exact quotient fails!") (($ $ |#2|) "\\axiom{exactQuotient(p,r)} computes the exact quotient of \\axiom{p} by \\axiom{r}, which is assumed to be a divisor of \\axiom{p}. No error is returned if this exact quotient fails!")) (|primPartElseUnitCanonical!| (($ $) "\\axiom{primPartElseUnitCanonical!(p)} replaces \\axiom{p} by \\axiom{primPartElseUnitCanonical(p)}.")) (|primPartElseUnitCanonical| (($ $) "\\axiom{primPartElseUnitCanonical(p)} returns \\axiom{primitivePart(p)} if \\axiom{R} is a gcd-domain, otherwise \\axiom{unitCanonical(p)}.")) (|convert| (($ (|Polynomial| |#2|)) "\\axiom{convert(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}, otherwise an error is produced.") (($ (|Polynomial| (|Integer|))) "\\axiom{convert(p)} returns the same as \\axiom{retract(p)}.") (($ (|Polynomial| (|Integer|))) "\\axiom{convert(p)} returns the same as \\axiom{retract(p)}") (($ (|Polynomial| (|Fraction| (|Integer|)))) "\\axiom{convert(p)} returns the same as \\axiom{retract(p)}.")) (|retract| (($ (|Polynomial| |#2|)) "\\axiom{retract(p)} returns \\axiom{p} as an element of the current domain if \\axiom{retractIfCan(p)} does not return \"failed\", otherwise an error is produced.") (($ (|Polynomial| |#2|)) "\\axiom{retract(p)} returns \\axiom{p} as an element of the current domain if \\axiom{retractIfCan(p)} does not return \"failed\", otherwise an error is produced.") (($ (|Polynomial| (|Integer|))) "\\axiom{retract(p)} returns \\axiom{p} as an element of the current domain if \\axiom{retractIfCan(p)} does not return \"failed\", otherwise an error is produced.") (($ (|Polynomial| |#2|)) "\\axiom{retract(p)} returns \\axiom{p} as an element of the current domain if \\axiom{retractIfCan(p)} does not return \"failed\", otherwise an error is produced.") (($ (|Polynomial| (|Integer|))) "\\axiom{retract(p)} returns \\axiom{p} as an element of the current domain if \\axiom{retractIfCan(p)} does not return \"failed\", otherwise an error is produced.") (($ (|Polynomial| (|Fraction| (|Integer|)))) "\\axiom{retract(p)} returns \\axiom{p} as an element of the current domain if \\axiom{retractIfCan(p)} does not return \"failed\", otherwise an error is produced.")) (|retractIfCan| (((|Union| $ "failed") (|Polynomial| |#2|)) "\\axiom{retractIfCan(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}.") (((|Union| $ "failed") (|Polynomial| |#2|)) "\\axiom{retractIfCan(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}.") (((|Union| $ "failed") (|Polynomial| (|Integer|))) "\\axiom{retractIfCan(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}.") (((|Union| $ "failed") (|Polynomial| |#2|)) "\\axiom{retractIfCan(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}.") (((|Union| $ "failed") (|Polynomial| (|Integer|))) "\\axiom{retractIfCan(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}.") (((|Union| $ "failed") (|Polynomial| (|Fraction| (|Integer|)))) "\\axiom{retractIfCan(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}.")) (|initiallyReduce| (($ $ $) "\\axiom{initiallyReduce(a,b)} returns a polynomial \\axiom{r} such that \\axiom{initiallyReduced?(r,b)} holds and there exists an integer \\axiom{e} such that \\axiom{init(b)^e a - \\spad{r}} is zero modulo \\axiom{b}.")) (|headReduce| (($ $ $) "\\axiom{headReduce(a,b)} returns a polynomial \\axiom{r} such that \\axiom{headReduced?(r,b)} holds and there exists an integer \\axiom{e} such that \\axiom{init(b)^e a - \\spad{r}} is zero modulo \\axiom{b}.")) (|lazyResidueClass| (((|Record| (|:| |polnum| $) (|:| |polden| $) (|:| |power| (|NonNegativeInteger|))) $ $) "\\axiom{lazyResidueClass(a,b)} returns \\axiom{[p,q,n]} where \\axiom{p / q**n} represents the residue class of \\axiom{a} modulo \\axiom{b} and \\axiom{p} is reduced w.r.t. \\axiom{b} and \\axiom{q} is \\axiom{init(b)}.")) (|monicModulo| (($ $ $) "\\axiom{monicModulo(a,b)} computes \\axiom{a mod \\spad{b},} if \\axiom{b} is monic as univariate polynomial in its main variable.")) (|pseudoDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\axiom{pseudoDivide(a,b)} computes \\axiom{[pquo(a,b),prem(a,b)]}, both polynomials viewed as univariate polynomials in the main variable of \\axiom{b}, if \\axiom{b} is not a constant polynomial.")) (|lazyPseudoDivide| (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|)) (|:| |quotient| $) (|:| |remainder| $)) $ $ |#4|) "\\axiom{lazyPseudoDivide(a,b,v)} returns \\axiom{[c,g,q,r]} such that \\axiom{r = lazyPrem(a,b,v)}, \\axiom{(c**g)*r = prem(a,b,v)} and \\axiom{q} is the pseudo-quotient computed in this lazy pseudo-division.") (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|)) (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\axiom{lazyPseudoDivide(a,b)} returns \\axiom{[c,g,q,r]} such that \\axiom{[c,g,r] = lazyPremWithDefault(a,b)} and \\axiom{q} is the pseudo-quotient computed in this lazy pseudo-division.")) (|lazyPremWithDefault| (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|)) (|:| |remainder| $)) $ $ |#4|) "\\axiom{lazyPremWithDefault(a,b,v)} returns \\axiom{[c,g,r]} such that \\axiom{r = lazyPrem(a,b,v)} and \\axiom{(c**g)*r = prem(a,b,v)}.") (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|)) (|:| |remainder| $)) $ $) "\\axiom{lazyPremWithDefault(a,b)} returns \\axiom{[c,g,r]} such that \\axiom{r = lazyPrem(a,b)} and \\axiom{(c**g)*r = prem(a,b)}.")) (|lazyPquo| (($ $ $ |#4|) "\\axiom{lazyPquo(a,b,v)} returns the polynomial \\axiom{q} such that \\axiom{lazyPseudoDivide(a,b,v)} returns \\axiom{[c,g,q,r]}.") (($ $ $) "\\axiom{lazyPquo(a,b)} returns the polynomial \\axiom{q} such that \\axiom{lazyPseudoDivide(a,b)} returns \\axiom{[c,g,q,r]}.")) (|lazyPrem| (($ $ $ |#4|) "\\axiom{lazyPrem(a,b,v)} returns the polynomial \\axiom{r} reduced w.r.t. \\axiom{b} viewed as univariate polynomials in the variable \\axiom{v} such that \\axiom{b} divides \\axiom{init(b)^e a - \\spad{r}} where \\axiom{e} is the number of steps of this pseudo-division.") (($ $ $) "\\axiom{lazyPrem(a,b)} returns the polynomial \\axiom{r} reduced w.r.t. \\axiom{b} and such that \\axiom{b} divides \\axiom{init(b)^e a - \\spad{r}} where \\axiom{e} is the number of steps of this pseudo-division.")) (|pquo| (($ $ $ |#4|) "\\axiom{pquo(a,b,v)} computes the pseudo-quotient of \\axiom{a} by \\axiom{b}, both viewed as univariate polynomials in \\axiom{v}.") (($ $ $) "\\axiom{pquo(a,b)} computes the pseudo-quotient of \\axiom{a} by \\axiom{b}, both viewed as univariate polynomials in the main variable of \\axiom{b}.")) (|prem| (($ $ $ |#4|) "\\axiom{prem(a,b,v)} computes the pseudo-remainder of \\axiom{a} by \\axiom{b}, both viewed as univariate polynomials in \\axiom{v}.") (($ $ $) "\\axiom{prem(a,b)} computes the pseudo-remainder of \\axiom{a} by \\axiom{b}, both viewed as univariate polynomials in the main variable of \\axiom{b}.")) (|normalized?| (((|Boolean|) $ (|List| $)) "\\axiom{normalized?(q,lp)} returns \\spad{true} iff \\axiom{normalized?(q,p)} holds for every \\axiom{p} in \\axiom{lp}.") (((|Boolean|) $ $) "\\axiom{normalized?(a,b)} returns \\spad{true} iff \\axiom{a} and its iterated initials have degree zero w.r.t. the main variable of \\axiom{b}")) (|initiallyReduced?| (((|Boolean|) $ (|List| $)) "\\axiom{initiallyReduced?(q,lp)} returns \\spad{true} iff \\axiom{initiallyReduced?(q,p)} holds for every \\axiom{p} in \\axiom{lp}.") (((|Boolean|) $ $) "\\axiom{initiallyReduced?(a,b)} returns \\spad{false} iff there exists an iterated initial of \\axiom{a} which is not reduced w.r.t \\axiom{b}.")) (|headReduced?| (((|Boolean|) $ (|List| $)) "\\axiom{headReduced?(q,lp)} returns \\spad{true} iff \\axiom{headReduced?(q,p)} holds for every \\axiom{p} in \\axiom{lp}.") (((|Boolean|) $ $) "\\axiom{headReduced?(a,b)} returns \\spad{true} iff \\axiom{degree(head(a),mvar(b)) < mdeg(b)}.")) (|reduced?| (((|Boolean|) $ (|List| $)) "\\axiom{reduced?(q,lp)} returns \\spad{true} iff \\axiom{reduced?(q,p)} holds for every \\axiom{p} in \\axiom{lp}.") (((|Boolean|) $ $) "\\axiom{reduced?(a,b)} returns \\spad{true} iff \\axiom{degree(a,mvar(b)) < mdeg(b)}.")) (|supRittWu?| (((|Boolean|) $ $) "\\axiom{supRittWu?(a,b)} returns \\spad{true} if \\axiom{a} is greater than \\axiom{b} w.r.t. the Ritt and Wu Wen Tsun ordering using the refinement of Lazard.")) (|infRittWu?| (((|Boolean|) $ $) "\\axiom{infRittWu?(a,b)} returns \\spad{true} if \\axiom{a} is less than \\axiom{b} w.r.t. the Ritt and Wu Wen Tsun ordering using the refinement of Lazard.")) (|RittWuCompare| (((|Union| (|Boolean|) "failed") $ $) "\\axiom{RittWuCompare(a,b)} returns \\axiom{\"failed\"} if \\axiom{a} and \\axiom{b} have same rank w.r.t. Ritt and Wu Wen Tsun ordering using the refinement of Lazard, otherwise returns \\axiom{infRittWu?(a,b)}.")) (|mainMonomials| (((|List| $) $) "\\axiom{mainMonomials(p)} returns an error if \\axiom{p} is \\axiom{O}, otherwise, if \\axiom{p} belongs to \\axiom{R} returns [1], otherwise returns the list of the monomials of \\axiom{p}, where \\axiom{p} is viewed as a univariate polynomial in its main variable.")) (|mainCoefficients| (((|List| $) $) "\\axiom{mainCoefficients(p)} returns an error if \\axiom{p} is \\axiom{O}, otherwise, if \\axiom{p} belongs to \\axiom{R} returns [p], otherwise returns the list of the coefficients of \\axiom{p}, where \\axiom{p} is viewed as a univariate polynomial in its main variable.")) (|leastMonomial| (($ $) "\\axiom{leastMonomial(p)} returns an error if \\axiom{p} is \\axiom{O}, otherwise, if \\axiom{p} belongs to \\axiom{R} returns \\axiom{1}, otherwise, the monomial of \\axiom{p} with lowest degree, where \\axiom{p} is viewed as a univariate polynomial in its main variable.")) (|mainMonomial| (($ $) "\\axiom{mainMonomial(p)} returns an error if \\axiom{p} is \\axiom{O}, otherwise, if \\axiom{p} belongs to \\axiom{R} returns \\axiom{1}, otherwise, \\axiom{mvar(p)} raised to the power \\axiom{mdeg(p)}.")) (|quasiMonic?| (((|Boolean|) $) "\\axiom{quasiMonic?(p)} returns \\spad{false} if \\axiom{p} belongs to \\axiom{R}, otherwise returns \\spad{true} iff the initial of \\axiom{p} lies in the base ring \\axiom{R}.")) (|monic?| (((|Boolean|) $) "\\axiom{monic?(p)} returns \\spad{false} if \\axiom{p} belongs to \\axiom{R}, otherwise returns \\spad{true} iff \\axiom{p} is monic as a univariate polynomial in its main variable.")) (|reductum| (($ $ |#4|) "\\axiom{reductum(p,v)} returns the reductum of \\axiom{p}, where \\axiom{p} is viewed as a univariate polynomial in \\axiom{v}.")) (|leadingCoefficient| (($ $ |#4|) "\\axiom{leadingCoefficient(p,v)} returns the leading coefficient of \\axiom{p}, where \\axiom{p} is viewed as A univariate polynomial in \\axiom{v}.")) (|deepestInitial| (($ $) "\\axiom{deepestInitial(p)} returns an error if \\axiom{p} belongs to \\axiom{R}, otherwise returns the last term of \\axiom{iteratedInitials(p)}.")) (|iteratedInitials| (((|List| $) $) "\\axiom{iteratedInitials(p)} returns \\axiom{[]} if \\axiom{p} belongs to \\axiom{R}, otherwise returns the list of the iterated initials of \\axiom{p}.")) (|deepestTail| (($ $) "\\axiom{deepestTail(p)} returns \\axiom{0} if \\axiom{p} belongs to \\axiom{R}, otherwise returns tail(p), if \\axiom{tail(p)} belongs to \\axiom{R} or \\axiom{mvar(tail(p)) < mvar(p)}, otherwise returns \\axiom{deepestTail(tail(p))}.")) (|tail| (($ $) "\\axiom{tail(p)} returns its reductum, where \\axiom{p} is viewed as a univariate polynomial in its main variable.")) (|head| (($ $) "\\axiom{head(p)} returns \\axiom{p} if \\axiom{p} belongs to \\axiom{R}, otherwise returns its leading term (monomial in the AXIOM sense), where \\axiom{p} is viewed as a univariate polynomial \\indented{1}{in its main variable.}")) (|init| (($ $) "\\axiom{init(p)} returns an error if \\axiom{p} belongs to \\axiom{R}, otherwise returns its leading coefficient, where \\axiom{p} is viewed as a univariate polynomial in its main variable.")) (|mdeg| (((|NonNegativeInteger|) $) "\\axiom{mdeg(p)} returns an error if \\axiom{p} is \\axiom{0}, otherwise, if \\axiom{p} belongs to \\axiom{R} returns \\axiom{0}, otherwise, returns the degree of \\axiom{p} in its main variable.")) (|mvar| ((|#4| $) "\\axiom{mvar(p)} returns an error if \\axiom{p} belongs to \\axiom{R}, otherwise returns its main variable \\spad{w.} \\spad{r.} \\spad{t.} to the total ordering on the elements in \\axiom{V}."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |QuotientFieldCategory|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#4| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|Symbol|))))) 
(|RecursivePolynomialCategory| R E V) 
((|constructor| (NIL "\\indented{1}{Author: Marc Moreno Maza} Date Created: 04/22/1994 Date Last Updated: 14/12/1998 Description:")) (|mainSquareFreePart| (($ $) "\\axiom{mainSquareFreePart(p)} returns the square free part of \\axiom{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \\axiom{R}.")) (|mainPrimitivePart| (($ $) "\\axiom{mainPrimitivePart(p)} returns the primitive part of \\axiom{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \\axiom{R}.")) (|mainContent| (($ $) "\\axiom{mainContent(p)} returns the content of \\axiom{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \\axiom{R}.")) (|primitivePart!| (($ $) "\\axiom{primitivePart!(p)} replaces \\axiom{p} by its primitive part.")) (|gcd| ((|#1| |#1| $) "\\axiom{gcd(r,p)} returns the \\spad{gcd} of \\axiom{r} and the content of \\axiom{p}.")) (|nextsubResultant2| (($ $ $ $ $) "\\axiom{nextsubResultant2(p,q,z,s)} is the multivariate version of the operation \\spad{next_sousResultant2} from PseudoRemainderSequence from the \\axiomType{PseudoRemainderSequence} constructor.")) (|LazardQuotient2| (($ $ $ $ (|NonNegativeInteger|)) "\\axiom{LazardQuotient2(p,a,b,n)} returns \\axiom{(a**(n-1) * \\spad{p)} exquo b**(n-1)} assuming that this quotient does not fail.")) (|LazardQuotient| (($ $ $ (|NonNegativeInteger|)) "\\axiom{LazardQuotient(a,b,n)} returns \\axiom{a**n exquo b**(n-1)} assuming that this quotient does not fail.")) (|lastSubResultant| (($ $ $) "\\axiom{lastSubResultant(a,b)} returns the last non-zero subresultant of \\axiom{a} and \\axiom{b} where \\axiom{a} and \\axiom{b} are assumed to have the same main variable \\axiom{v} and are viewed as univariate polynomials in \\axiom{v}.")) (|subResultantChain| (((|List| $) $ $) "\\axiom{subResultantChain(a,b)}, where \\axiom{a} and \\axiom{b} are not contant polynomials with the same main variable, returns the subresultant chain of \\axiom{a} and \\axiom{b}.")) (|resultant| (($ $ $) "\\axiom{resultant(a,b)} computes the resultant of \\axiom{a} and \\axiom{b} where \\axiom{a} and \\axiom{b} are assumed to have the same main variable \\axiom{v} and are viewed as univariate polynomials in \\axiom{v}.")) (|halfExtendedSubResultantGcd2| (((|Record| (|:| |gcd| $) (|:| |coef2| $)) $ $) "\\axiom{halfExtendedSubResultantGcd2(a,b)} returns \\axiom{[g,cb]} if \\axiom{extendedSubResultantGcd(a,b)} returns \\axiom{[g,ca,cb]} otherwise produces an error.")) (|halfExtendedSubResultantGcd1| (((|Record| (|:| |gcd| $) (|:| |coef1| $)) $ $) "\\axiom{halfExtendedSubResultantGcd1(a,b)} returns \\axiom{[g,ca]} if \\axiom{extendedSubResultantGcd(a,b)} returns \\axiom{[g,ca,cb]} otherwise produces an error.")) (|extendedSubResultantGcd| (((|Record| (|:| |gcd| $) (|:| |coef1| $) (|:| |coef2| $)) $ $) "\\axiom{extendedSubResultantGcd(a,b)} returns \\axiom{[ca,cb,r]} such that \\axiom{r} is \\axiom{subResultantGcd(a,b)} and we have \\axiom{ca * a + \\spad{cb} * \\spad{cb} = \\spad{r}} .")) (|subResultantGcd| (($ $ $) "\\axiom{subResultantGcd(a,b)} computes a \\spad{gcd} of \\axiom{a} and \\axiom{b} where \\axiom{a} and \\axiom{b} are assumed to have the same main variable \\axiom{v} and are viewed as univariate polynomials in \\axiom{v} with coefficients in the fraction field of the polynomial ring generated by their other variables over \\axiom{R}.")) (|exactQuotient!| (($ $ $) "\\axiom{exactQuotient!(a,b)} replaces \\axiom{a} by \\axiom{exactQuotient(a,b)}") (($ $ |#1|) "\\axiom{exactQuotient!(p,r)} replaces \\axiom{p} by \\axiom{exactQuotient(p,r)}.")) (|exactQuotient| (($ $ $) "\\axiom{exactQuotient(a,b)} computes the exact quotient of \\axiom{a} by \\axiom{b}, which is assumed to be a divisor of \\axiom{a}. No error is returned if this exact quotient fails!") (($ $ |#1|) "\\axiom{exactQuotient(p,r)} computes the exact quotient of \\axiom{p} by \\axiom{r}, which is assumed to be a divisor of \\axiom{p}. No error is returned if this exact quotient fails!")) (|primPartElseUnitCanonical!| (($ $) "\\axiom{primPartElseUnitCanonical!(p)} replaces \\axiom{p} by \\axiom{primPartElseUnitCanonical(p)}.")) (|primPartElseUnitCanonical| (($ $) "\\axiom{primPartElseUnitCanonical(p)} returns \\axiom{primitivePart(p)} if \\axiom{R} is a gcd-domain, otherwise \\axiom{unitCanonical(p)}.")) (|convert| (($ (|Polynomial| |#1|)) "\\axiom{convert(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}, otherwise an error is produced.") (($ (|Polynomial| (|Integer|))) "\\axiom{convert(p)} returns the same as \\axiom{retract(p)}.") (($ (|Polynomial| (|Integer|))) "\\axiom{convert(p)} returns the same as \\axiom{retract(p)}") (($ (|Polynomial| (|Fraction| (|Integer|)))) "\\axiom{convert(p)} returns the same as \\axiom{retract(p)}.")) (|retract| (($ (|Polynomial| |#1|)) "\\axiom{retract(p)} returns \\axiom{p} as an element of the current domain if \\axiom{retractIfCan(p)} does not return \"failed\", otherwise an error is produced.") (($ (|Polynomial| |#1|)) "\\axiom{retract(p)} returns \\axiom{p} as an element of the current domain if \\axiom{retractIfCan(p)} does not return \"failed\", otherwise an error is produced.") (($ (|Polynomial| (|Integer|))) "\\axiom{retract(p)} returns \\axiom{p} as an element of the current domain if \\axiom{retractIfCan(p)} does not return \"failed\", otherwise an error is produced.") (($ (|Polynomial| |#1|)) "\\axiom{retract(p)} returns \\axiom{p} as an element of the current domain if \\axiom{retractIfCan(p)} does not return \"failed\", otherwise an error is produced.") (($ (|Polynomial| (|Integer|))) "\\axiom{retract(p)} returns \\axiom{p} as an element of the current domain if \\axiom{retractIfCan(p)} does not return \"failed\", otherwise an error is produced.") (($ (|Polynomial| (|Fraction| (|Integer|)))) "\\axiom{retract(p)} returns \\axiom{p} as an element of the current domain if \\axiom{retractIfCan(p)} does not return \"failed\", otherwise an error is produced.")) (|retractIfCan| (((|Union| $ "failed") (|Polynomial| |#1|)) "\\axiom{retractIfCan(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}.") (((|Union| $ "failed") (|Polynomial| |#1|)) "\\axiom{retractIfCan(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}.") (((|Union| $ "failed") (|Polynomial| (|Integer|))) "\\axiom{retractIfCan(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}.") (((|Union| $ "failed") (|Polynomial| |#1|)) "\\axiom{retractIfCan(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}.") (((|Union| $ "failed") (|Polynomial| (|Integer|))) "\\axiom{retractIfCan(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}.") (((|Union| $ "failed") (|Polynomial| (|Fraction| (|Integer|)))) "\\axiom{retractIfCan(p)} returns \\axiom{p} as an element of the current domain if all its variables belong to \\axiom{V}.")) (|initiallyReduce| (($ $ $) "\\axiom{initiallyReduce(a,b)} returns a polynomial \\axiom{r} such that \\axiom{initiallyReduced?(r,b)} holds and there exists an integer \\axiom{e} such that \\axiom{init(b)^e a - \\spad{r}} is zero modulo \\axiom{b}.")) (|headReduce| (($ $ $) "\\axiom{headReduce(a,b)} returns a polynomial \\axiom{r} such that \\axiom{headReduced?(r,b)} holds and there exists an integer \\axiom{e} such that \\axiom{init(b)^e a - \\spad{r}} is zero modulo \\axiom{b}.")) (|lazyResidueClass| (((|Record| (|:| |polnum| $) (|:| |polden| $) (|:| |power| (|NonNegativeInteger|))) $ $) "\\axiom{lazyResidueClass(a,b)} returns \\axiom{[p,q,n]} where \\axiom{p / q**n} represents the residue class of \\axiom{a} modulo \\axiom{b} and \\axiom{p} is reduced w.r.t. \\axiom{b} and \\axiom{q} is \\axiom{init(b)}.")) (|monicModulo| (($ $ $) "\\axiom{monicModulo(a,b)} computes \\axiom{a mod \\spad{b},} if \\axiom{b} is monic as univariate polynomial in its main variable.")) (|pseudoDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\axiom{pseudoDivide(a,b)} computes \\axiom{[pquo(a,b),prem(a,b)]}, both polynomials viewed as univariate polynomials in the main variable of \\axiom{b}, if \\axiom{b} is not a constant polynomial.")) (|lazyPseudoDivide| (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|)) (|:| |quotient| $) (|:| |remainder| $)) $ $ |#3|) "\\axiom{lazyPseudoDivide(a,b,v)} returns \\axiom{[c,g,q,r]} such that \\axiom{r = lazyPrem(a,b,v)}, \\axiom{(c**g)*r = prem(a,b,v)} and \\axiom{q} is the pseudo-quotient computed in this lazy pseudo-division.") (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|)) (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\axiom{lazyPseudoDivide(a,b)} returns \\axiom{[c,g,q,r]} such that \\axiom{[c,g,r] = lazyPremWithDefault(a,b)} and \\axiom{q} is the pseudo-quotient computed in this lazy pseudo-division.")) (|lazyPremWithDefault| (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|)) (|:| |remainder| $)) $ $ |#3|) "\\axiom{lazyPremWithDefault(a,b,v)} returns \\axiom{[c,g,r]} such that \\axiom{r = lazyPrem(a,b,v)} and \\axiom{(c**g)*r = prem(a,b,v)}.") (((|Record| (|:| |coef| $) (|:| |gap| (|NonNegativeInteger|)) (|:| |remainder| $)) $ $) "\\axiom{lazyPremWithDefault(a,b)} returns \\axiom{[c,g,r]} such that \\axiom{r = lazyPrem(a,b)} and \\axiom{(c**g)*r = prem(a,b)}.")) (|lazyPquo| (($ $ $ |#3|) "\\axiom{lazyPquo(a,b,v)} returns the polynomial \\axiom{q} such that \\axiom{lazyPseudoDivide(a,b,v)} returns \\axiom{[c,g,q,r]}.") (($ $ $) "\\axiom{lazyPquo(a,b)} returns the polynomial \\axiom{q} such that \\axiom{lazyPseudoDivide(a,b)} returns \\axiom{[c,g,q,r]}.")) (|lazyPrem| (($ $ $ |#3|) "\\axiom{lazyPrem(a,b,v)} returns the polynomial \\axiom{r} reduced w.r.t. \\axiom{b} viewed as univariate polynomials in the variable \\axiom{v} such that \\axiom{b} divides \\axiom{init(b)^e a - \\spad{r}} where \\axiom{e} is the number of steps of this pseudo-division.") (($ $ $) "\\axiom{lazyPrem(a,b)} returns the polynomial \\axiom{r} reduced w.r.t. \\axiom{b} and such that \\axiom{b} divides \\axiom{init(b)^e a - \\spad{r}} where \\axiom{e} is the number of steps of this pseudo-division.")) (|pquo| (($ $ $ |#3|) "\\axiom{pquo(a,b,v)} computes the pseudo-quotient of \\axiom{a} by \\axiom{b}, both viewed as univariate polynomials in \\axiom{v}.") (($ $ $) "\\axiom{pquo(a,b)} computes the pseudo-quotient of \\axiom{a} by \\axiom{b}, both viewed as univariate polynomials in the main variable of \\axiom{b}.")) (|prem| (($ $ $ |#3|) "\\axiom{prem(a,b,v)} computes the pseudo-remainder of \\axiom{a} by \\axiom{b}, both viewed as univariate polynomials in \\axiom{v}.") (($ $ $) "\\axiom{prem(a,b)} computes the pseudo-remainder of \\axiom{a} by \\axiom{b}, both viewed as univariate polynomials in the main variable of \\axiom{b}.")) (|normalized?| (((|Boolean|) $ (|List| $)) "\\axiom{normalized?(q,lp)} returns \\spad{true} iff \\axiom{normalized?(q,p)} holds for every \\axiom{p} in \\axiom{lp}.") (((|Boolean|) $ $) "\\axiom{normalized?(a,b)} returns \\spad{true} iff \\axiom{a} and its iterated initials have degree zero w.r.t. the main variable of \\axiom{b}")) (|initiallyReduced?| (((|Boolean|) $ (|List| $)) "\\axiom{initiallyReduced?(q,lp)} returns \\spad{true} iff \\axiom{initiallyReduced?(q,p)} holds for every \\axiom{p} in \\axiom{lp}.") (((|Boolean|) $ $) "\\axiom{initiallyReduced?(a,b)} returns \\spad{false} iff there exists an iterated initial of \\axiom{a} which is not reduced w.r.t \\axiom{b}.")) (|headReduced?| (((|Boolean|) $ (|List| $)) "\\axiom{headReduced?(q,lp)} returns \\spad{true} iff \\axiom{headReduced?(q,p)} holds for every \\axiom{p} in \\axiom{lp}.") (((|Boolean|) $ $) "\\axiom{headReduced?(a,b)} returns \\spad{true} iff \\axiom{degree(head(a),mvar(b)) < mdeg(b)}.")) (|reduced?| (((|Boolean|) $ (|List| $)) "\\axiom{reduced?(q,lp)} returns \\spad{true} iff \\axiom{reduced?(q,p)} holds for every \\axiom{p} in \\axiom{lp}.") (((|Boolean|) $ $) "\\axiom{reduced?(a,b)} returns \\spad{true} iff \\axiom{degree(a,mvar(b)) < mdeg(b)}.")) (|supRittWu?| (((|Boolean|) $ $) "\\axiom{supRittWu?(a,b)} returns \\spad{true} if \\axiom{a} is greater than \\axiom{b} w.r.t. the Ritt and Wu Wen Tsun ordering using the refinement of Lazard.")) (|infRittWu?| (((|Boolean|) $ $) "\\axiom{infRittWu?(a,b)} returns \\spad{true} if \\axiom{a} is less than \\axiom{b} w.r.t. the Ritt and Wu Wen Tsun ordering using the refinement of Lazard.")) (|RittWuCompare| (((|Union| (|Boolean|) "failed") $ $) "\\axiom{RittWuCompare(a,b)} returns \\axiom{\"failed\"} if \\axiom{a} and \\axiom{b} have same rank w.r.t. Ritt and Wu Wen Tsun ordering using the refinement of Lazard, otherwise returns \\axiom{infRittWu?(a,b)}.")) (|mainMonomials| (((|List| $) $) "\\axiom{mainMonomials(p)} returns an error if \\axiom{p} is \\axiom{O}, otherwise, if \\axiom{p} belongs to \\axiom{R} returns [1], otherwise returns the list of the monomials of \\axiom{p}, where \\axiom{p} is viewed as a univariate polynomial in its main variable.")) (|mainCoefficients| (((|List| $) $) "\\axiom{mainCoefficients(p)} returns an error if \\axiom{p} is \\axiom{O}, otherwise, if \\axiom{p} belongs to \\axiom{R} returns [p], otherwise returns the list of the coefficients of \\axiom{p}, where \\axiom{p} is viewed as a univariate polynomial in its main variable.")) (|leastMonomial| (($ $) "\\axiom{leastMonomial(p)} returns an error if \\axiom{p} is \\axiom{O}, otherwise, if \\axiom{p} belongs to \\axiom{R} returns \\axiom{1}, otherwise, the monomial of \\axiom{p} with lowest degree, where \\axiom{p} is viewed as a univariate polynomial in its main variable.")) (|mainMonomial| (($ $) "\\axiom{mainMonomial(p)} returns an error if \\axiom{p} is \\axiom{O}, otherwise, if \\axiom{p} belongs to \\axiom{R} returns \\axiom{1}, otherwise, \\axiom{mvar(p)} raised to the power \\axiom{mdeg(p)}.")) (|quasiMonic?| (((|Boolean|) $) "\\axiom{quasiMonic?(p)} returns \\spad{false} if \\axiom{p} belongs to \\axiom{R}, otherwise returns \\spad{true} iff the initial of \\axiom{p} lies in the base ring \\axiom{R}.")) (|monic?| (((|Boolean|) $) "\\axiom{monic?(p)} returns \\spad{false} if \\axiom{p} belongs to \\axiom{R}, otherwise returns \\spad{true} iff \\axiom{p} is monic as a univariate polynomial in its main variable.")) (|reductum| (($ $ |#3|) "\\axiom{reductum(p,v)} returns the reductum of \\axiom{p}, where \\axiom{p} is viewed as a univariate polynomial in \\axiom{v}.")) (|leadingCoefficient| (($ $ |#3|) "\\axiom{leadingCoefficient(p,v)} returns the leading coefficient of \\axiom{p}, where \\axiom{p} is viewed as A univariate polynomial in \\axiom{v}.")) (|deepestInitial| (($ $) "\\axiom{deepestInitial(p)} returns an error if \\axiom{p} belongs to \\axiom{R}, otherwise returns the last term of \\axiom{iteratedInitials(p)}.")) (|iteratedInitials| (((|List| $) $) "\\axiom{iteratedInitials(p)} returns \\axiom{[]} if \\axiom{p} belongs to \\axiom{R}, otherwise returns the list of the iterated initials of \\axiom{p}.")) (|deepestTail| (($ $) "\\axiom{deepestTail(p)} returns \\axiom{0} if \\axiom{p} belongs to \\axiom{R}, otherwise returns tail(p), if \\axiom{tail(p)} belongs to \\axiom{R} or \\axiom{mvar(tail(p)) < mvar(p)}, otherwise returns \\axiom{deepestTail(tail(p))}.")) (|tail| (($ $) "\\axiom{tail(p)} returns its reductum, where \\axiom{p} is viewed as a univariate polynomial in its main variable.")) (|head| (($ $) "\\axiom{head(p)} returns \\axiom{p} if \\axiom{p} belongs to \\axiom{R}, otherwise returns its leading term (monomial in the AXIOM sense), where \\axiom{p} is viewed as a univariate polynomial \\indented{1}{in its main variable.}")) (|init| (($ $) "\\axiom{init(p)} returns an error if \\axiom{p} belongs to \\axiom{R}, otherwise returns its leading coefficient, where \\axiom{p} is viewed as a univariate polynomial in its main variable.")) (|mdeg| (((|NonNegativeInteger|) $) "\\axiom{mdeg(p)} returns an error if \\axiom{p} is \\axiom{0}, otherwise, if \\axiom{p} belongs to \\axiom{R} returns \\axiom{0}, otherwise, returns the degree of \\axiom{p} in its main variable.")) (|mvar| ((|#3| $) "\\axiom{mvar(p)} returns an error if \\axiom{p} belongs to \\axiom{R}, otherwise returns its main variable \\spad{w.} \\spad{r.} \\spad{t.} to the total ordering on the elements in \\axiom{V}."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|RealRootCharacterizationCategory&| S |TheField| |ThePols|) 
((|constructor| (NIL "\\axiomType{RealRootCharacterizationCategory} provides common access functions for all real roots of polynomials")) (|relativeApprox| ((|#2| |#3| $ |#2|) "\\axiom{approximate(term,root,prec)} gives an approximation of \\axiom{term} over \\axiom{root} with precision \\axiom{prec}")) (|approximate| ((|#2| |#3| $ |#2|) "\\axiom{approximate(term,root,prec)} gives an approximation of \\axiom{term} over \\axiom{root} with precision \\axiom{prec}")) (|rootOf| (((|Union| $ "failed") |#3| (|PositiveInteger|)) "\\axiom{rootOf(pol,n)} gives the \\spad{n}th root for the order of the Real Closure")) (|allRootsOf| (((|List| $) |#3|) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} in the Real Closure, assumed in order.")) (|definingPolynomial| ((|#3| $) "\\axiom{definingPolynomial(aRoot)} gives a polynomial such that \\axiom{definingPolynomial(aRoot).aRoot = 0}")) (|recip| (((|Union| |#3| "failed") |#3| $) "\\axiom{recip(pol,aRoot)} tries to inverse \\axiom{pol} interpreted as \\axiom{aRoot}")) (|positive?| (((|Boolean|) |#3| $) "\\axiom{positive?(pol,aRoot)} answers if \\axiom{pol} interpreted as \\axiom{aRoot} is positive")) (|negative?| (((|Boolean|) |#3| $) "\\axiom{negative?(pol,aRoot)} answers if \\axiom{pol} interpreted as \\axiom{aRoot} is negative")) (|zero?| (((|Boolean|) |#3| $) "\\axiom{zero?(pol,aRoot)} answers if \\axiom{pol} interpreted as \\axiom{aRoot} is \\axiom{0}")) (|sign| (((|Integer|) |#3| $) "\\axiom{sign(pol,aRoot)} gives the sign of \\axiom{pol} interpreted as \\axiom{aRoot}"))) 
NIL 
NIL 
(|RealRootCharacterizationCategory| |TheField| |ThePols|) 
((|constructor| (NIL "\\axiomType{RealRootCharacterizationCategory} provides common access functions for all real roots of polynomials")) (|relativeApprox| ((|#1| |#2| $ |#1|) "\\axiom{approximate(term,root,prec)} gives an approximation of \\axiom{term} over \\axiom{root} with precision \\axiom{prec}")) (|approximate| ((|#1| |#2| $ |#1|) "\\axiom{approximate(term,root,prec)} gives an approximation of \\axiom{term} over \\axiom{root} with precision \\axiom{prec}")) (|rootOf| (((|Union| $ "failed") |#2| (|PositiveInteger|)) "\\axiom{rootOf(pol,n)} gives the \\spad{n}th root for the order of the Real Closure")) (|allRootsOf| (((|List| $) |#2|) "\\axiom{allRootsOf(pol)} creates all the roots of \\axiom{pol} in the Real Closure, assumed in order.")) (|definingPolynomial| ((|#2| $) "\\axiom{definingPolynomial(aRoot)} gives a polynomial such that \\axiom{definingPolynomial(aRoot).aRoot = 0}")) (|recip| (((|Union| |#2| "failed") |#2| $) "\\axiom{recip(pol,aRoot)} tries to inverse \\axiom{pol} interpreted as \\axiom{aRoot}")) (|positive?| (((|Boolean|) |#2| $) "\\axiom{positive?(pol,aRoot)} answers if \\axiom{pol} interpreted as \\axiom{aRoot} is positive")) (|negative?| (((|Boolean|) |#2| $) "\\axiom{negative?(pol,aRoot)} answers if \\axiom{pol} interpreted as \\axiom{aRoot} is negative")) (|zero?| (((|Boolean|) |#2| $) "\\axiom{zero?(pol,aRoot)} answers if \\axiom{pol} interpreted as \\axiom{aRoot} is \\axiom{0}")) (|sign| (((|Integer|) |#2| $) "\\axiom{sign(pol,aRoot)} gives the sign of \\axiom{pol} interpreted as \\axiom{aRoot}"))) 
NIL 
NIL 
(|RegularSetDecompositionPackage| R E V P TS) 
((|constructor| (NIL "A package providing a new algorithm for solving polynomial systems by means of regular chains. Two ways of solving are proposed: in the sense of Zariski closure (like in Kalkbrener's algorithm) or in the sense of the regular zeros (like in Wu, Wang or Lazard methods). This algorithm is valid for any type of regular set. It does not care about the way a polynomial is added in an regular set, or how two quasi-components are compared (by an inclusion-test), or how the invertibility test is made in the tower of simple extensions associated with a regular set. These operations are realized respectively by the domain \\spad{TS} and the packages \\axiomType{QCMPACK}(R,E,V,P,TS) and \\axiomType{RSETGCD}(R,E,V,P,TS). The same way it does not care about the way univariate polynomial \\spad{gcd} (with coefficients in the tower of simple extensions associated with a regular set) are computed. The only requirement is that these \\spad{gcd} need to have invertible initials (normalized or not). WARNING. There is no need for a user to call directly any operation of this package since they can be accessed by the domain \\axiom{TS}. Thus, the operations of this package are not documented."))) 
NIL 
NIL 
(|RegularTriangularSetCategory&| S R E V P) 
((|constructor| (NIL "The category of regular triangular sets, introduced under the name regular chains in \\spad{[1]} (and other papers). In \\spad{[3]} it is proved that regular triangular sets and towers of simple extensions of a field are equivalent notions. In the following definitions, all polynomials and ideals are taken from the polynomial ring \\spad{k[x1,...,xn]} where \\spad{k} is the fraction field of \\spad{R}. The triangular set \\spad{[t1,...,tm]} is regular iff for every \\spad{i} the initial of \\spad{ti+1} is invertible in the tower of simple extensions associated with \\spad{[t1,...,ti]}. A family \\spad{[T1,...,Ts]} of regular triangular sets is a split of Kalkbrener of a given ideal \\spad{I} iff the radical of \\spad{I} is equal to the intersection of the radical ideals generated by the saturated ideals of the \\spad{[T1,...,Ti]}. A family \\spad{[T1,...,Ts]} of regular triangular sets is a split of Kalkbrener of a given triangular set \\spad{T} iff it is a split of Kalkbrener of the saturated ideal of \\spad{T}. Let \\spad{K} be an algebraic closure of \\spad{k}. Assume that \\spad{V} is finite with cardinality \\spad{n} and let \\spad{A} be the affine space \\spad{K^n}. For a regular triangular set \\spad{T} let denote by \\spad{W(T)} the set of regular zeros of \\spad{T}. A family \\spad{[T1,...,Ts]} of regular triangular sets is a split of Lazard of a given subset \\spad{S} of \\spad{A} iff the union of the \\spad{W(Ti)} contains \\spad{S} and is contained in the closure of \\spad{S} (w.r.t. Zariski topology). A family \\spad{[T1,...,Ts]} of regular triangular sets is a split of Lazard of a given triangular set \\spad{T} if it is a split of Lazard of \\spad{W(T)}. Note that if \\spad{[T1,...,Ts]} is a split of Lazard of \\spad{T} then it is also a split of Kalkbrener of \\spad{T}. The converse is false. This category provides operations related to both kinds of splits, the former being related to ideals decomposition whereas the latter deals with varieties decomposition. See the example illustrating the RegularTriangularSet constructor for more explanations about decompositions by means of regular triangular sets.")) (|zeroSetSplit| (((|List| $) (|List| |#5|) (|Boolean|)) "\\spad{zeroSetSplit(lp,clos?)} returns \\spad{lts} a split of Kalkbrener of the radical ideal associated with \\spad{lp}. If \\spad{clos?} is false, it is also a decomposition of the variety associated with \\spad{lp} into the regular zero set of the \\spad{ts} in \\spad{lts} (or, in other words, a split of Lazard of this variety). See the example illustrating the \\spadtype{RegularTriangularSet} constructor for more explanations about decompositions by means of regular triangular sets.")) (|extend| (((|List| $) (|List| |#5|) (|List| $)) "\\spad{extend(lp,lts)} returns the same as \\spad{concat([extend(lp,ts) for \\spad{ts} in lts])|}") (((|List| $) (|List| |#5|) $) "\\spad{extend(lp,ts)} returns \\spad{ts} if \\spad{empty? \\spad{lp}} \\spad{extend(p,ts)} if \\spad{lp = [p]} else \\spad{extend(first \\spad{lp,} extend(rest \\spad{lp,} ts))}") (((|List| $) |#5| (|List| $)) "\\spad{extend(p,lts)} returns the same as \\spad{concat([extend(p,ts) for \\spad{ts} in lts])|}") (((|List| $) |#5| $) "\\spad{extend(p,ts)} assumes that \\spad{p} is a non-constant polynomial whose main variable is greater than any variable of \\spad{ts}. Then it returns a split of Kalkbrener of \\spad{ts+p}. This may not be \\spad{ts+p} itself, if for instance \\spad{ts+p} is not a regular triangular set.")) (|internalAugment| (($ (|List| |#5|) $) "\\spad{internalAugment(lp,ts)} returns \\spad{ts} if \\spad{lp} is empty otherwise returns \\spad{internalAugment(rest \\spad{lp,} internalAugment(first \\spad{lp,} ts))}") (($ |#5| $) "\\spad{internalAugment(p,ts)} assumes that \\spad{augment(p,ts)} returns a singleton and returns it.")) (|augment| (((|List| $) (|List| |#5|) (|List| $)) "\\spad{augment(lp,lts)} returns the same as \\spad{concat([augment(lp,ts) for \\spad{ts} in lts])}") (((|List| $) (|List| |#5|) $) "\\spad{augment(lp,ts)} returns \\spad{ts} if \\spad{empty? lp}, \\spad{augment(p,ts)} if \\spad{lp = [p]}, otherwise \\spad{augment(first \\spad{lp,} augment(rest \\spad{lp,} ts))}") (((|List| $) |#5| (|List| $)) "\\spad{augment(p,lts)} returns the same as \\spad{concat([augment(p,ts) for \\spad{ts} in lts])}") (((|List| $) |#5| $) "\\spad{augment(p,ts)} assumes that \\spad{p} is a non-constant polynomial whose main variable is greater than any variable of \\spad{ts}. This operation assumes also that if \\spad{p} is added to \\spad{ts} the resulting set, say \\spad{ts+p}, is a regular triangular set. Then it returns a split of Kalkbrener of \\spad{ts+p}. This may not be \\spad{ts+p} itself, if for instance \\spad{ts+p} is required to be square-free.")) (|intersect| (((|List| $) |#5| (|List| $)) "\\spad{intersect(p,lts)} returns the same as \\spad{intersect([p],lts)}") (((|List| $) (|List| |#5|) (|List| $)) "\\spad{intersect(lp,lts)} returns the same as \\spad{concat([intersect(lp,ts) for \\spad{ts} in lts])|}") (((|List| $) (|List| |#5|) $) "\\spad{intersect(lp,ts)} returns \\spad{lts} a split of Lazard of the intersection of the affine variety associated with \\spad{lp} and the regular zero set of \\spad{ts}.") (((|List| $) |#5| $) "\\spad{intersect(p,ts)} returns the same as \\spad{intersect([p],ts)}")) (|squareFreePart| (((|List| (|Record| (|:| |val| |#5|) (|:| |tower| $))) |#5| $) "\\spad{squareFreePart(p,ts)} returns \\spad{lpwt} such that \\spad{lpwt.i.val} is a square-free polynomial w.r.t. \\spad{lpwt.i.tower}, this polynomial being associated with \\spad{p} modulo \\spad{lpwt.i.tower}, for every \\spad{i}. Moreover, the list of the \\spad{lpwt.i.tower} is a split of Kalkbrener of \\spad{ts}. WARNING: This assumes that \\spad{p} is a non-constant polynomial such that if \\spad{p} is added to \\spad{ts}, then the resulting set is a regular triangular set.")) (|lastSubResultant| (((|List| (|Record| (|:| |val| |#5|) (|:| |tower| $))) |#5| |#5| $) "\\spad{lastSubResultant(p1,p2,ts)} returns \\spad{lpwt} such that \\spad{lpwt.i.val} is a quasi-monic \\spad{gcd} of \\spad{p1} and \\spad{p2} w.r.t. \\spad{lpwt.i.tower}, for every \\spad{i}, and such that the list of the \\spad{lpwt.i.tower} is a split of Kalkbrener of \\spad{ts}. Moreover, if \\spad{p1} and \\spad{p2} do not have a non-trivial \\spad{gcd} w.r.t. \\spad{lpwt.i.tower} then \\spad{lpwt.i.val} is the resultant of these polynomials w.r.t. \\spad{lpwt.i.tower}. This assumes that \\spad{p1} and \\spad{p2} have the same main variable and that this variable is greater that any variable occurring in \\spad{ts}.")) (|lastSubResultantElseSplit| (((|Union| |#5| (|List| $)) |#5| |#5| $) "\\spad{lastSubResultantElseSplit(p1,p2,ts)} returns either \\spad{g} a quasi-monic \\spad{gcd} of \\spad{p1} and \\spad{p2} w.r.t. the \\spad{ts} or a split of Kalkbrener of \\spad{ts}. This assumes that \\spad{p1} and \\spad{p2} have the same maim variable and that this variable is greater that any variable occurring in \\spad{ts}.")) (|invertibleSet| (((|List| $) |#5| $) "\\spad{invertibleSet(p,ts)} returns a split of Kalkbrener of the quotient ideal of the ideal \\axiom{I} by \\spad{p} where \\spad{I} is the radical of saturated of \\spad{ts}.")) (|invertible?| (((|Boolean|) |#5| $) "\\spad{invertible?(p,ts)} returns \\spad{true} iff \\spad{p} is invertible in the tower associated with \\spad{ts}.") (((|List| (|Record| (|:| |val| (|Boolean|)) (|:| |tower| $))) |#5| $) "\\spad{invertible?(p,ts)} returns \\spad{lbwt} where \\spad{lbwt.i} is the result of \\spad{invertibleElseSplit?(p,lbwt.i.tower)} and the list of the \\spad{(lqrwt.i).tower} is a split of Kalkbrener of \\spad{ts}.")) (|invertibleElseSplit?| (((|Union| (|Boolean|) (|List| $)) |#5| $) "\\spad{invertibleElseSplit?(p,ts)} returns \\spad{true} (resp. \\spad{false}) if \\spad{p} is invertible in the tower associated with \\spad{ts} or returns a split of Kalkbrener of \\spad{ts}.")) (|purelyAlgebraicLeadingMonomial?| (((|Boolean|) |#5| $) "\\spad{purelyAlgebraicLeadingMonomial?(p,ts)} returns \\spad{true} iff the main variable of any non-constant iterarted initial of \\spad{p} is algebraic w.r.t. \\spad{ts}.")) (|algebraicCoefficients?| (((|Boolean|) |#5| $) "\\spad{algebraicCoefficients?(p,ts)} returns \\spad{true} iff every variable of \\spad{p} which is not the main one of \\spad{p} is algebraic w.r.t. \\spad{ts}.")) (|purelyTranscendental?| (((|Boolean|) |#5| $) "\\spad{purelyTranscendental?(p,ts)} returns \\spad{true} iff every variable of \\spad{p} is not algebraic w.r.t. \\spad{ts}")) (|purelyAlgebraic?| (((|Boolean|) $) "\\spad{purelyAlgebraic?(ts)} returns \\spad{true} iff for every algebraic variable \\spad{v} of \\spad{ts} we have \\spad{algebraicCoefficients?(t_v,ts_v_-)} where \\spad{ts_v} is select from TriangularSetCategory(ts,v) and \\spad{ts_v_-} is collectUnder from TriangularSetCategory(ts,v).") (((|Boolean|) |#5| $) "\\spad{purelyAlgebraic?(p,ts)} returns \\spad{true} iff every variable of \\spad{p} is algebraic w.r.t. \\spad{ts}."))) 
NIL 
NIL 
(|RegularTriangularSetCategory| R E V P) 
((|constructor| (NIL "The category of regular triangular sets, introduced under the name regular chains in \\spad{[1]} (and other papers). In \\spad{[3]} it is proved that regular triangular sets and towers of simple extensions of a field are equivalent notions. In the following definitions, all polynomials and ideals are taken from the polynomial ring \\spad{k[x1,...,xn]} where \\spad{k} is the fraction field of \\spad{R}. The triangular set \\spad{[t1,...,tm]} is regular iff for every \\spad{i} the initial of \\spad{ti+1} is invertible in the tower of simple extensions associated with \\spad{[t1,...,ti]}. A family \\spad{[T1,...,Ts]} of regular triangular sets is a split of Kalkbrener of a given ideal \\spad{I} iff the radical of \\spad{I} is equal to the intersection of the radical ideals generated by the saturated ideals of the \\spad{[T1,...,Ti]}. A family \\spad{[T1,...,Ts]} of regular triangular sets is a split of Kalkbrener of a given triangular set \\spad{T} iff it is a split of Kalkbrener of the saturated ideal of \\spad{T}. Let \\spad{K} be an algebraic closure of \\spad{k}. Assume that \\spad{V} is finite with cardinality \\spad{n} and let \\spad{A} be the affine space \\spad{K^n}. For a regular triangular set \\spad{T} let denote by \\spad{W(T)} the set of regular zeros of \\spad{T}. A family \\spad{[T1,...,Ts]} of regular triangular sets is a split of Lazard of a given subset \\spad{S} of \\spad{A} iff the union of the \\spad{W(Ti)} contains \\spad{S} and is contained in the closure of \\spad{S} (w.r.t. Zariski topology). A family \\spad{[T1,...,Ts]} of regular triangular sets is a split of Lazard of a given triangular set \\spad{T} if it is a split of Lazard of \\spad{W(T)}. Note that if \\spad{[T1,...,Ts]} is a split of Lazard of \\spad{T} then it is also a split of Kalkbrener of \\spad{T}. The converse is false. This category provides operations related to both kinds of splits, the former being related to ideals decomposition whereas the latter deals with varieties decomposition. See the example illustrating the RegularTriangularSet constructor for more explanations about decompositions by means of regular triangular sets.")) (|zeroSetSplit| (((|List| $) (|List| |#4|) (|Boolean|)) "\\spad{zeroSetSplit(lp,clos?)} returns \\spad{lts} a split of Kalkbrener of the radical ideal associated with \\spad{lp}. If \\spad{clos?} is false, it is also a decomposition of the variety associated with \\spad{lp} into the regular zero set of the \\spad{ts} in \\spad{lts} (or, in other words, a split of Lazard of this variety). See the example illustrating the \\spadtype{RegularTriangularSet} constructor for more explanations about decompositions by means of regular triangular sets.")) (|extend| (((|List| $) (|List| |#4|) (|List| $)) "\\spad{extend(lp,lts)} returns the same as \\spad{concat([extend(lp,ts) for \\spad{ts} in lts])|}") (((|List| $) (|List| |#4|) $) "\\spad{extend(lp,ts)} returns \\spad{ts} if \\spad{empty? \\spad{lp}} \\spad{extend(p,ts)} if \\spad{lp = [p]} else \\spad{extend(first \\spad{lp,} extend(rest \\spad{lp,} ts))}") (((|List| $) |#4| (|List| $)) "\\spad{extend(p,lts)} returns the same as \\spad{concat([extend(p,ts) for \\spad{ts} in lts])|}") (((|List| $) |#4| $) "\\spad{extend(p,ts)} assumes that \\spad{p} is a non-constant polynomial whose main variable is greater than any variable of \\spad{ts}. Then it returns a split of Kalkbrener of \\spad{ts+p}. This may not be \\spad{ts+p} itself, if for instance \\spad{ts+p} is not a regular triangular set.")) (|internalAugment| (($ (|List| |#4|) $) "\\spad{internalAugment(lp,ts)} returns \\spad{ts} if \\spad{lp} is empty otherwise returns \\spad{internalAugment(rest \\spad{lp,} internalAugment(first \\spad{lp,} ts))}") (($ |#4| $) "\\spad{internalAugment(p,ts)} assumes that \\spad{augment(p,ts)} returns a singleton and returns it.")) (|augment| (((|List| $) (|List| |#4|) (|List| $)) "\\spad{augment(lp,lts)} returns the same as \\spad{concat([augment(lp,ts) for \\spad{ts} in lts])}") (((|List| $) (|List| |#4|) $) "\\spad{augment(lp,ts)} returns \\spad{ts} if \\spad{empty? lp}, \\spad{augment(p,ts)} if \\spad{lp = [p]}, otherwise \\spad{augment(first \\spad{lp,} augment(rest \\spad{lp,} ts))}") (((|List| $) |#4| (|List| $)) "\\spad{augment(p,lts)} returns the same as \\spad{concat([augment(p,ts) for \\spad{ts} in lts])}") (((|List| $) |#4| $) "\\spad{augment(p,ts)} assumes that \\spad{p} is a non-constant polynomial whose main variable is greater than any variable of \\spad{ts}. This operation assumes also that if \\spad{p} is added to \\spad{ts} the resulting set, say \\spad{ts+p}, is a regular triangular set. Then it returns a split of Kalkbrener of \\spad{ts+p}. This may not be \\spad{ts+p} itself, if for instance \\spad{ts+p} is required to be square-free.")) (|intersect| (((|List| $) |#4| (|List| $)) "\\spad{intersect(p,lts)} returns the same as \\spad{intersect([p],lts)}") (((|List| $) (|List| |#4|) (|List| $)) "\\spad{intersect(lp,lts)} returns the same as \\spad{concat([intersect(lp,ts) for \\spad{ts} in lts])|}") (((|List| $) (|List| |#4|) $) "\\spad{intersect(lp,ts)} returns \\spad{lts} a split of Lazard of the intersection of the affine variety associated with \\spad{lp} and the regular zero set of \\spad{ts}.") (((|List| $) |#4| $) "\\spad{intersect(p,ts)} returns the same as \\spad{intersect([p],ts)}")) (|squareFreePart| (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| $))) |#4| $) "\\spad{squareFreePart(p,ts)} returns \\spad{lpwt} such that \\spad{lpwt.i.val} is a square-free polynomial w.r.t. \\spad{lpwt.i.tower}, this polynomial being associated with \\spad{p} modulo \\spad{lpwt.i.tower}, for every \\spad{i}. Moreover, the list of the \\spad{lpwt.i.tower} is a split of Kalkbrener of \\spad{ts}. WARNING: This assumes that \\spad{p} is a non-constant polynomial such that if \\spad{p} is added to \\spad{ts}, then the resulting set is a regular triangular set.")) (|lastSubResultant| (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| $))) |#4| |#4| $) "\\spad{lastSubResultant(p1,p2,ts)} returns \\spad{lpwt} such that \\spad{lpwt.i.val} is a quasi-monic \\spad{gcd} of \\spad{p1} and \\spad{p2} w.r.t. \\spad{lpwt.i.tower}, for every \\spad{i}, and such that the list of the \\spad{lpwt.i.tower} is a split of Kalkbrener of \\spad{ts}. Moreover, if \\spad{p1} and \\spad{p2} do not have a non-trivial \\spad{gcd} w.r.t. \\spad{lpwt.i.tower} then \\spad{lpwt.i.val} is the resultant of these polynomials w.r.t. \\spad{lpwt.i.tower}. This assumes that \\spad{p1} and \\spad{p2} have the same main variable and that this variable is greater that any variable occurring in \\spad{ts}.")) (|lastSubResultantElseSplit| (((|Union| |#4| (|List| $)) |#4| |#4| $) "\\spad{lastSubResultantElseSplit(p1,p2,ts)} returns either \\spad{g} a quasi-monic \\spad{gcd} of \\spad{p1} and \\spad{p2} w.r.t. the \\spad{ts} or a split of Kalkbrener of \\spad{ts}. This assumes that \\spad{p1} and \\spad{p2} have the same maim variable and that this variable is greater that any variable occurring in \\spad{ts}.")) (|invertibleSet| (((|List| $) |#4| $) "\\spad{invertibleSet(p,ts)} returns a split of Kalkbrener of the quotient ideal of the ideal \\axiom{I} by \\spad{p} where \\spad{I} is the radical of saturated of \\spad{ts}.")) (|invertible?| (((|Boolean|) |#4| $) "\\spad{invertible?(p,ts)} returns \\spad{true} iff \\spad{p} is invertible in the tower associated with \\spad{ts}.") (((|List| (|Record| (|:| |val| (|Boolean|)) (|:| |tower| $))) |#4| $) "\\spad{invertible?(p,ts)} returns \\spad{lbwt} where \\spad{lbwt.i} is the result of \\spad{invertibleElseSplit?(p,lbwt.i.tower)} and the list of the \\spad{(lqrwt.i).tower} is a split of Kalkbrener of \\spad{ts}.")) (|invertibleElseSplit?| (((|Union| (|Boolean|) (|List| $)) |#4| $) "\\spad{invertibleElseSplit?(p,ts)} returns \\spad{true} (resp. \\spad{false}) if \\spad{p} is invertible in the tower associated with \\spad{ts} or returns a split of Kalkbrener of \\spad{ts}.")) (|purelyAlgebraicLeadingMonomial?| (((|Boolean|) |#4| $) "\\spad{purelyAlgebraicLeadingMonomial?(p,ts)} returns \\spad{true} iff the main variable of any non-constant iterarted initial of \\spad{p} is algebraic w.r.t. \\spad{ts}.")) (|algebraicCoefficients?| (((|Boolean|) |#4| $) "\\spad{algebraicCoefficients?(p,ts)} returns \\spad{true} iff every variable of \\spad{p} which is not the main one of \\spad{p} is algebraic w.r.t. \\spad{ts}.")) (|purelyTranscendental?| (((|Boolean|) |#4| $) "\\spad{purelyTranscendental?(p,ts)} returns \\spad{true} iff every variable of \\spad{p} is not algebraic w.r.t. \\spad{ts}")) (|purelyAlgebraic?| (((|Boolean|) $) "\\spad{purelyAlgebraic?(ts)} returns \\spad{true} iff for every algebraic variable \\spad{v} of \\spad{ts} we have \\spad{algebraicCoefficients?(t_v,ts_v_-)} where \\spad{ts_v} is select from TriangularSetCategory(ts,v) and \\spad{ts_v_-} is collectUnder from TriangularSetCategory(ts,v).") (((|Boolean|) |#4| $) "\\spad{purelyAlgebraic?(p,ts)} returns \\spad{true} iff every variable of \\spad{p} is algebraic w.r.t. \\spad{ts}."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|RegularTriangularSetGcdPackage| R E V P TS) 
((|constructor| (NIL "An internal package for computing gcds and resultants of univariate polynomials with coefficients in a tower of simple extensions of a field.")) (|toseSquareFreePart| (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| |#5|))) |#4| |#5|) "\\axiom{toseSquareFreePart(p,ts)} has the same specifications as squareFreePart from RegularTriangularSetCategory.")) (|toseInvertibleSet| (((|List| |#5|) |#4| |#5|) "\\axiom{toseInvertibleSet(p1,p2,ts)} has the same specifications as invertibleSet from RegularTriangularSetCategory.")) (|toseInvertible?| (((|List| (|Record| (|:| |val| (|Boolean|)) (|:| |tower| |#5|))) |#4| |#5|) "\\axiom{toseInvertible?(p1,p2,ts)} has the same specifications as invertible? from RegularTriangularSetCategory.") (((|Boolean|) |#4| |#5|) "\\axiom{toseInvertible?(p1,p2,ts)} has the same specifications as invertible? from RegularTriangularSetCategory.")) (|toseLastSubResultant| (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| |#5|))) |#4| |#4| |#5|) "\\axiom{toseLastSubResultant(p1,p2,ts)} has the same specifications as lastSubResultant from RegularTriangularSetCategory.")) (|integralLastSubResultant| (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| |#5|))) |#4| |#4| |#5|) "\\axiom{integralLastSubResultant(p1,p2,ts)} is an internal subroutine, exported only for developement.")) (|internalLastSubResultant| (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| |#5|))) (|List| (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|))) |#3| (|Boolean|)) "\\axiom{internalLastSubResultant(lpwt,v,flag)} is an internal subroutine, exported only for developement.") (((|List| (|Record| (|:| |val| |#4|) (|:| |tower| |#5|))) |#4| |#4| |#5| (|Boolean|) (|Boolean|)) "\\axiom{internalLastSubResultant(p1,p2,ts,inv?,break?)} is an internal subroutine, exported only for developement.")) (|prepareSubResAlgo| (((|List| (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|))) |#4| |#4| |#5|) "\\axiom{prepareSubResAlgo(p1,p2,ts)} is an internal subroutine, exported only for developement.")) (|stopTableInvSet!| (((|Void|)) "\\axiom{stopTableInvSet!()} is an internal subroutine, exported only for developement.")) (|startTableInvSet!| (((|Void|) (|String|) (|String|) (|String|)) "\\axiom{startTableInvSet!(s1,s2,s3)} is an internal subroutine, exported only for developement.")) (|stopTableGcd!| (((|Void|)) "\\axiom{stopTableGcd!()} is an internal subroutine, exported only for developement.")) (|startTableGcd!| (((|Void|) (|String|) (|String|) (|String|)) "\\axiom{startTableGcd!(s1,s2,s3)} is an internal subroutine, exported only for developement."))) 
NIL 
NIL 
(|RuleCalled| |f|) 
((|constructor| (NIL "This domain implements named rules")) (|name| (((|Symbol|) $) "\\spad{name(x)} returns the symbol"))) 
NIL 
NIL 
(|RewriteRule| |Base| R F) 
((|constructor| (NIL "Rules for the pattern matcher")) (|quotedOperators| (((|List| (|Symbol|)) $) "\\spad{quotedOperators(r)} returns the list of operators on the right hand side of \\spad{r} that are considered quoted, that is they are not evaluated during any rewrite, but just applied formally to their arguments.")) (|elt| ((|#3| $ |#3| (|PositiveInteger|)) "\\spad{elt(r,f,n)} or r(f, \\spad{n)} applies the rule \\spad{r} to \\spad{f} at most \\spad{n} times.")) (|rhs| ((|#3| $) "\\spad{rhs(r)} returns the right hand side of the rule \\spad{r.}")) (|lhs| ((|#3| $) "\\spad{lhs(r)} returns the left hand side of the rule \\spad{r.}")) (|pattern| (((|Pattern| |#1|) $) "\\spad{pattern(r)} returns the pattern corresponding to the left hand side of the rule \\spad{r.}")) (|suchThat| (($ $ (|List| (|Symbol|)) (|Mapping| (|Boolean|) (|List| |#3|))) "\\spad{suchThat(r, [a1,...,an], \\spad{f)}} returns the rewrite rule \\spad{r} with the predicate \\spad{f(a1,...,an)} attached to it.")) (|rule| (($ |#3| |#3| (|List| (|Symbol|))) "\\spad{rule(f, \\spad{g,} [f1,...,fn])} creates the rewrite rule \\spad{f \\spad{==} eval(eval(g, \\spad{g} is \\spad{f),} [f1,...,fn])}, that is a rule with left-hand side \\spad{f} and right-hand side \\spad{g;} The symbols f1,...,fn are the operators that are considered quoted, that is they are not evaluated during any rewrite, but just applied formally to their arguments.") (($ |#3| |#3|) "\\indented{1}{rule(f, \\spad{g)} creates the rewrite rule: \\spad{f \\spad{==} eval(g, \\spad{g} is f)},} \\indented{1}{with left-hand side \\spad{f} and right-hand side \\spad{g.}} \\blankline \\spad{X} logrule \\spad{:=} rule log(x) + log(y) \\spad{==} log(x*y) \\spad{X} \\spad{f} \\spad{:=} log(sin(x)) + log(x) \\spad{X} logrule \\spad{f}"))) 
NIL 
NIL 
(|Ruleset| |Base| R F) 
((|constructor| (NIL "Sets of rules for the pattern matcher. A ruleset is a set of pattern matching rules grouped together.")) (|elt| ((|#3| $ |#3| (|PositiveInteger|)) "\\spad{elt(r,f,n)} or r(f, \\spad{n)} applies all the rules of \\spad{r} to \\spad{f} at most \\spad{n} times.")) (|rules| (((|List| (|RewriteRule| |#1| |#2| |#3|)) $) "\\spad{rules(r)} returns the rules contained in \\spad{r.}")) (|ruleset| (($ (|List| (|RewriteRule| |#1| |#2| |#3|))) "\\spad{ruleset([r1,...,rn])} creates the rule set \\spad{{r1,...,rn}}."))) 
NIL 
NIL 
(|RationalUnivariateRepresentationPackage| R |ls|) 
((|constructor| (NIL "A package for computing the rational univariate representation of a zero-dimensional algebraic variety given by a regular triangular set. This package is essentially an interface for the \\spadtype{InternalRationalUnivariateRepresentationPackage} constructor. It is used in the \\spadtype{ZeroDimensionalSolvePackage} for solving polynomial systems with finitely many solutions.")) (|rur| (((|List| (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|)) (|:| |coordinates| (|List| (|Polynomial| |#1|))))) (|List| (|Polynomial| |#1|)) (|Boolean|) (|Boolean|)) "\\spad{rur(lp,univ?,check?)} returns the same as \\spad{rur(lp,true)}. Moreover, if \\spad{check?} is \\spad{true} then the result is checked.") (((|List| (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|)) (|:| |coordinates| (|List| (|Polynomial| |#1|))))) (|List| (|Polynomial| |#1|))) "\\spad{rur(lp)} returns the same as \\spad{rur(lp,true)}") (((|List| (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|)) (|:| |coordinates| (|List| (|Polynomial| |#1|))))) (|List| (|Polynomial| |#1|)) (|Boolean|)) "\\spad{rur(lp,univ?)} returns a rational univariate representation of \\spad{lp}. This assumes that \\spad{lp} defines a regular triangular \\spad{ts} whose associated variety is zero-dimensional over \\spad{R}. \\spad{rur(lp,univ?)} returns a list of items \\spad{[u,lc]} where \\spad{u} is an irreducible univariate polynomial and each \\spad{c} in \\spad{lc} involves two variables: one from \\spad{ls}, called the coordinate of \\spad{c}, and an extra variable which represents any root of \\spad{u}. Every root of \\spad{u} leads to a tuple of values for the coordinates of \\spad{lc}. Moreover, a point \\spad{x} belongs to the variety associated with \\spad{lp} iff there exists an item \\spad{[u,lc]} in \\spad{rur(lp,univ?)} and a root \\spad{r} of \\spad{u} such that \\spad{x} is given by the tuple of values for the coordinates of \\spad{lc} evaluated at \\spad{r}. If \\spad{univ?} is \\spad{true} then each polynomial \\spad{c} will have a constant leading coefficient w.r.t. its coordinate. See the example which illustrates the \\spadtype{ZeroDimensionalSolvePackage} package constructor."))) 
NIL 
NIL 
(|SimpleAlgebraicExtensionAlgFactor| UP SAE UPA) 
((|constructor| (NIL "Factorization of univariate polynomials with coefficients in an algebraic extension of the rational numbers (\\spadtype{Fraction Integer}).")) (|factor| (((|Factored| |#3|) |#3|) "\\spad{factor(p)} returns a prime factorisation of \\spad{p.}"))) 
NIL 
NIL 
(|SimpleAlgebraicExtension| R UP M) 
((|constructor| (NIL "Algebraic extension of a ring by a single polynomial. Domain which represents simple algebraic extensions of arbitrary rings. The first argument to the domain, \\spad{R,} is the underlying ring, the second argument is a domain of univariate polynomials over \\spad{K,} while the last argument specifies the defining minimal polynomial. The elements of the domain are canonically represented as polynomials of degree less than that of the minimal polynomial with coefficients in \\spad{R.} The second argument is both the type of the third argument and the underlying representation used by \\spadtype{SAE} itself."))) 
((|noZeroDivisors| |has| |#1| (|Field|)) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|)))) (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))))) (OR (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (OR (AND (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|FiniteFieldCategory|))))) 
(|SAERationalFunctionAlgFactor| UP SAE UPA) 
((|constructor| (NIL "Factorization of univariate polynomials with coefficients in an algebraic extension of \\spadtype{Fraction Polynomial Integer}.")) (|factor| (((|Factored| |#3|) |#3|) "\\spad{factor(p)} returns a prime factorisation of \\spad{p.}"))) 
NIL 
NIL 
(|SingletonAsOrderedSet|) 
((|constructor| (NIL "This trivial domain lets us build Univariate Polynomials in an anonymous variable"))) 
NIL 
NIL 
(|SortedCache| S) 
((|constructor| (NIL "A sorted cache of a cachable set \\spad{S} is a dynamic structure that keeps the elements of \\spad{S} sorted and assigns an integer to each element of \\spad{S} once it is in the cache. This way, equality and ordering on \\spad{S} are tested directly on the integers associated with the elements of \\spad{S,} once they have been entered in the cache.")) (|enterInCache| ((|#1| |#1| (|Mapping| (|Integer|) |#1| |#1|)) "\\spad{enterInCache(x, \\spad{f)}} enters \\spad{x} in the cache, calling \\spad{f(x, \\spad{y)}} to determine whether \\spad{x < \\spad{y} (f(x,y) < 0), \\spad{x} = \\spad{y} (f(x,y) = 0)}, or \\spad{x > \\spad{y} (f(x,y) > 0)}. It returns \\spad{x} with an integer associated with it.") ((|#1| |#1| (|Mapping| (|Boolean|) |#1|)) "\\spad{enterInCache(x, \\spad{f)}} enters \\spad{x} in the cache, calling \\spad{f(y)} to determine whether \\spad{x} is equal to \\spad{y.} It returns \\spad{x} with an integer associated with it.")) (|cache| (((|List| |#1|)) "\\spad{cache()} returns the current cache as a list.")) (|clearCache| (((|Void|)) "\\spad{clearCache()} empties the cache."))) 
NIL 
NIL 
(|SimpleCell| |TheField| |ThePols|) 
NIL 
NIL 
NIL 
(|StructuralConstantsPackage| R) 
((|constructor| (NIL "StructuralConstantsPackage provides functions creating structural constants from a multiplication tables or a basis of a matrix algebra and other useful functions in this context.")) (|coordinates| (((|Vector| |#1|) (|Matrix| |#1|) (|List| (|Matrix| |#1|))) "\\spad{coordinates(a,[v1,...,vn])} returns the coordinates of \\spad{a} with respect to the \\spad{R}-module basis \\spad{v1},...,\\spad{vn}.")) (|structuralConstants| (((|Vector| (|Matrix| |#1|)) (|List| (|Matrix| |#1|))) "\\spad{structuralConstants(basis)} takes the \\spad{basis} of a matrix algebra, \\spadignore{e.g.} the result of \\spadfun{basisOfCentroid} and calculates the structural constants. Note, that the it is not checked, whether \\spad{basis} really is a \\spad{basis} of a matrix algebra.") (((|Vector| (|Matrix| (|Polynomial| |#1|))) (|List| (|Symbol|)) (|Matrix| (|Polynomial| |#1|))) "\\spad{structuralConstants(ls,mt)} determines the structural constants of an algebra with generators \\spad{ls} and multiplication table \\spad{mt,} the entries of which must be given as linear polynomials in the indeterminates given by \\spad{ls.} The result is in particular useful \\indented{1}{as fourth argument for \\spadtype{AlgebraGivenByStructuralConstants}} \\indented{1}{and \\spadtype{GenericNonAssociativeAlgebra}.}") (((|Vector| (|Matrix| (|Fraction| (|Polynomial| |#1|)))) (|List| (|Symbol|)) (|Matrix| (|Fraction| (|Polynomial| |#1|)))) "\\spad{structuralConstants(ls,mt)} determines the structural constants of an algebra with generators \\spad{ls} and multiplication table \\spad{mt,} the entries of which must be given as linear polynomials in the indeterminates given by \\spad{ls.} The result is in particular useful \\indented{1}{as fourth argument for \\spadtype{AlgebraGivenByStructuralConstants}} \\indented{1}{and \\spadtype{GenericNonAssociativeAlgebra}.}"))) 
NIL 
NIL 
(|StochasticDifferential| R) 
((|constructor| (NIL "A basic implementation of StochasticDifferential(R) using the associated domain BasicStochasticDifferential in the underlying representation as sparse multivariate polynomials. The domain is a module over Expression(R), and is a ring without identity (AXIOM term is \"Rng\"). Note that separate instances, for example using R=Integer and R=Float, have different hidden structure (multiplication and drift tables).")) (|uncorrelated?| (((|Boolean|) (|List| (|List| $))) "\\spad{uncorrelated?(ll)} checks whether its argument is a list of lists of stochastic differentials of zero inter-list quadratic co-variation.") (((|Boolean|) (|List| $) (|List| $)) "\\spad{uncorrelated?(l1,l2)} checks whether its two arguments are lists of stochastic differentials of zero inter-list quadratic co-variation.") (((|Boolean|) $ $) "\\spad{uncorrelated?(dx,dy)} checks whether its two arguments have zero quadratic co-variation.")) (|statusIto| (((|OutputForm|)) "\\indented{1}{statusIto() displays the current state of \\axiom{setBSD},} \\indented{1}{\\axiom{tableDrift}, and \\axiom{tableQuadVar}. Question} \\indented{1}{marks are printed instead of undefined entries} \\blankline \\spad{X} dt:=introduce!(t,dt) \\spad{X} dX:=introduce!(X,dX) \\spad{X} dY:=introduce!(Y,dY) \\spad{X} copyBSD() \\spad{X} copyIto() \\spad{X} copyhQuadVar() \\spad{X} statusIto()")) (^ (($ $ (|PositiveInteger|)) "\\spad{dx^n} is \\spad{dx} multiplied by itself \\spad{n} times.")) (** (($ $ (|PositiveInteger|)) "\\spad{dx**n} is \\spad{dx} multiplied by itself \\spad{n} times.")) (/ (($ $ (|Expression| |#1|)) "\\spad{dx/y} divides the stochastic differential \\spad{dx} by the previsible function \\spad{y.}")) (|copyQuadVar| (((|Table| $ $)) "\\spad{copyQuadVar returns} private multiplication table of basic stochastic differentials for inspection")) (|copyDrift| (((|Table| $ $)) "\\spad{copyDrift returns} private table of drifts of basic stochastic differentials for inspection")) (|equation| (((|Union| (|Equation| $) "failed") |#1| $) "\\spad{equation(0,dx)} allows \\spad{LHS} of Equation \\% to be zero") (((|Union| (|Equation| $) "failed") $ |#1|) "\\spad{equation(dx,0)} allows \\spad{RHS} of Equation \\% to be zero")) (|listSD| (((|List| (|BasicStochasticDifferential|)) $) "\\spad{listSD(dx)} returns a list of all \\axiom{BSD} involved in the generation of \\axiom{dx} as a module element")) (|coefficient| (((|Expression| |#1|) $ (|BasicStochasticDifferential|)) "\\spad{coefficient(sd,dX)} returns the coefficient of \\axiom{dX} in the stochastic differential \\axiom{sd}")) (|freeOf?| (((|Boolean|) $ (|BasicStochasticDifferential|)) "\\spad{freeOf?(sd,dX)} checks whether \\axiom{dX} occurs in \\axiom{sd} as a module element")) (|drift| (($ $) "\\spad{drift(dx)} returns the drift of \\axiom{dx}")) (|alterDrift!| (((|Union| $ "failed") (|BasicStochasticDifferential|) $) "\\spad{alterDrift! adds} drift formula for a stochastic differential to a private table. Failure occurs if \\indented{1}{(a) first arguments is not basic} \\indented{1}{(b) second argument is not exactly of first degree}")) (|alterQuadVar!| (((|Union| $ "failed") (|BasicStochasticDifferential|) (|BasicStochasticDifferential|) $) "\\spad{alterQuadVar! adds} multiplication formula for a pair of stochastic differentials to a private table. Failure occurs if \\indented{1}{(a) either of first or second arguments is not basic} \\indented{1}{(b) third argument is not exactly of first degree}"))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|SequentialDifferentialPolynomial| R) 
((|constructor| (NIL "\\spadtype{SequentialDifferentialPolynomial} implements an ordinary differential polynomial ring in arbitrary number of differential indeterminates, with coefficients in a ring. The ranking on the differential indeterminate is sequential."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|)) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|)) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|)) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|)) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| (|SequentialDifferentialVariable| (|Symbol|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))))) 
(|SequentialDifferentialVariable| S) 
((|constructor| (NIL "\\spadtype{OrderlyDifferentialVariable} adds a commonly used sequential ranking to the set of derivatives of an ordered list of differential indeterminates. A sequential ranking is a ranking \\spadfun{<} of the derivatives with the property that for any derivative \\spad{v,} there are only a finite number of derivatives \\spad{u} with \\spad{u} \\spadfun{<} \\spad{v.} This domain belongs to \\spadtype{DifferentialVariableCategory}. It defines \\spadfun{weight} to be just \\spadfun{order}, and it defines a sequential ranking \\spadfun{<} on derivatives \\spad{u} by the lexicographic order on the pair (\\spadfun{variable}(u), \\spadfun{order}(u))."))) 
NIL 
NIL 
(|SegmentFunctions2| R S) 
((|constructor| (NIL "This package provides operations for mapping functions onto segments.")) (|map| (((|List| |#2|) (|Mapping| |#2| |#1|) (|Segment| |#1|)) "\\spad{map(f,s)} expands the segment \\spad{s,} applying \\spad{f} to each value. For example, if \\spad{s = l..h by \\spad{k},} then the list \\spad{[f(l), f(l+k),..., f(lN)]} is computed, where \\spad{lN \\spad{<=} \\spad{h} < lN+k}.") (((|Segment| |#2|) (|Mapping| |#2| |#1|) (|Segment| |#1|)) "\\spad{map(f,l..h)} returns a new segment \\spad{f(l)..f(h)}."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|OrderedRing|)))) 
(|SegmentBindingFunctions2| R S) 
((|constructor| (NIL "This package provides operations for mapping functions onto \\spadtype{SegmentBinding}s.")) (|map| (((|SegmentBinding| |#2|) (|Mapping| |#2| |#1|) (|SegmentBinding| |#1|)) "\\spad{map(f,v=a..b)} returns the value given by \\spad{v=f(a)..f(b)}."))) 
NIL 
NIL 
(|SegmentBinding| S) 
((|constructor| (NIL "This domain is used to provide the function argument syntax \\spad{v=a..b}. This is used, for example, by the top-level \\spadfun{draw} functions.")) (|segment| (((|Segment| |#1|) $) "\\spad{segment(segb)} returns the segment from the right hand side of the \\spadtype{SegmentBinding}. For example, if \\spad{segb} is \\spad{v=a..b}, then \\spad{segment(segb)} returns \\spad{a..b}.")) (|variable| (((|Symbol|) $) "\\spad{variable(segb)} returns the variable from the left hand side of the \\spadtype{SegmentBinding}. For example, if \\spad{segb} is \\spad{v=a..b}, then \\spad{variable(segb)} returns \\spad{v}.")) (|equation| (($ (|Symbol|) (|Segment| |#1|)) "\\spad{equation(v,a..b)} creates a segment binding value with variable \\spad{v} and segment \\spad{a..b}. Note that the interpreter parses \\spad{v=a..b} to this form."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|SetCategory|)))) 
(|SegmentCategory| S) 
((|constructor| (NIL "This category provides operations on ranges, or segments as they are called.")) (|convert| (($ |#1|) "\\spad{convert(i)} creates the segment \\spad{i..i}.")) (|segment| (($ |#1| |#1|) "\\spad{segment(i,j)} is an alternate way to create the segment \\spad{i..j}.")) (|incr| (((|Integer|) $) "\\spad{incr(s)} returns \\spad{n}, where \\spad{s} is a segment in which every \\spad{n}-th element is used. Note that \\spad{incr(l..h by \\spad{n)} = \\spad{n}.}")) (|high| ((|#1| $) "\\spad{high(s)} returns the second endpoint of \\spad{s.} Note that \\spad{high(l..h) = \\spad{h}.}")) (|low| ((|#1| $) "\\spad{low(s)} returns the first endpoint of \\spad{s.} Note that \\spad{low(l..h) = \\spad{l}.}")) (|hi| ((|#1| $) "\\spad{hi(s)} returns the second endpoint of \\spad{s.} Note that \\spad{hi(l..h) = \\spad{h}.}")) (|lo| ((|#1| $) "\\spad{lo(s)} returns the first endpoint of \\spad{s.} Note that \\spad{lo(l..h) = \\spad{l}.}")) (BY (($ $ (|Integer|)) "\\spad{s by \\spad{n}} creates a new segment in which only every \\spad{n}-th element is used.")) (SEGMENT (($ |#1| |#1|) "\\spad{l..h} creates a segment with \\spad{l} and \\spad{h} as the endpoints."))) 
((|nil| . T)) 
NIL 
(|Segment| S) 
((|constructor| (NIL "This type is used to specify a range of values from type \\spad{S}."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|OrderedRing|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) 
(|SegmentExpansionCategory| S L) 
((|constructor| (NIL "This category provides an interface for expanding segments to a stream of elements.")) (|map| ((|#2| (|Mapping| |#1| |#1|) $) "\\spad{map(f,l..h by \\spad{k)}} produces a value of type \\spad{L} by applying \\spad{f} to each of the succesive elements of the segment, that is, \\spad{[f(l), f(l+k), ..., f(lN)]}, where \\spad{lN \\spad{<=} \\spad{h} < lN+k}.")) (|expand| ((|#2| $) "\\spad{expand(l..h by \\spad{k)}} creates value of type \\spad{L} with elements \\spad{l, l+k, \\spad{...} \\spad{lN}} where \\spad{lN \\spad{<=} \\spad{h} < lN+k}. For example, \\spad{expand(1..5 by 2) = [1,3,5]}.") ((|#2| (|List| $)) "\\spad{expand(l)} creates a new value of type \\spad{L} in which each segment \\spad{l..h by \\spad{k}} is replaced with \\spad{l, l+k, \\spad{...} lN}, where \\spad{lN \\spad{<=} \\spad{h} < lN+k}. For example, \\spad{expand [1..4, 7..9] = [1,2,3,4,7,8,9]}."))) 
((|nil| . T)) 
NIL 
(|SetAggregate&| A S) 
((|constructor| (NIL "A set category lists a collection of set-theoretic operations useful for both finite sets and multisets. Note however that finite sets are distinct from multisets. Although the operations defined for set categories are common to both, the relationship between the two cannot be described by inclusion or inheritance.")) (|union| (($ |#2| $) "\\spad{union(x,u)} returns the set aggregate \\spad{u} with the element \\spad{x} added. If \\spad{u} already contains \\spad{x,} \\axiom{union(x,u)} returns a copy of u.") (($ $ |#2|) "\\spad{union(u,x)} returns the set aggregate \\spad{u} with the element \\spad{x} added. If \\spad{u} already contains \\spad{x,} \\axiom{union(u,x)} returns a copy of u.") (($ $ $) "\\spad{union(u,v)} returns the set aggregate of elements which are members of either set aggregate \\spad{u} or \\spad{v.}")) (|subset?| (((|Boolean|) $ $) "\\spad{subset?(u,v)} tests if \\spad{u} is a subset of \\spad{v.} Note that equivalent to \\axiom{reduce(and,{member?(x,v) for \\spad{x} in u},true,false)}.")) (|symmetricDifference| (($ $ $) "\\spad{symmetricDifference(u,v)} returns the set aggregate of elements \\spad{x} which are members of set aggregate \\spad{u} or set aggregate \\spad{v} but not both. If \\spad{u} and \\spad{v} have no elements in common, \\axiom{symmetricDifference(u,v)} returns a copy of u. Note that \\axiom{symmetricDifference(u,v) = \\indented{1}{union(difference(u,v),difference(v,u))}}")) (|difference| (($ $ |#2|) "\\spad{difference(u,x)} returns the set aggregate \\spad{u} with element \\spad{x} removed. If \\spad{u} does not contain \\spad{x,} a copy of \\spad{u} is returned. Note that \\axiom{difference(s, \\spad{x)} = difference(s, {x})}.") (($ $ $) "\\spad{difference(u,v)} returns the set aggregate \\spad{w} consisting of elements in set aggregate \\spad{u} but not in set aggregate \\spad{v.} If \\spad{u} and \\spad{v} have no elements in common, \\axiom{difference(u,v)} returns a copy of u. Note that equivalent to the notation (not currently supported) \\axiom{{x for \\spad{x} in \\spad{u} | not member?(x,v)}}.")) (|intersect| (($ $ $) "\\spad{intersect(u,v)} returns the set aggregate \\spad{w} consisting of elements common to both set aggregates \\spad{u} and \\spad{v.} Note that equivalent to the notation (not currently supported) \\spad{{x} for \\spad{x} in \\spad{u} | member?(x,v)}.")) (|set| (($ (|List| |#2|)) "\\spad{set([x,y,...,z])} creates a set aggregate containing items x,y,...,z.") (($) "\\spad{set()}$D creates an empty set aggregate of type \\spad{D.}")) (|brace| (($ (|List| |#2|)) "\\spad{brace([x,y,...,z])} creates a set aggregate containing items x,y,...,z. This form is considered obsolete. Use \\axiomFun{set} instead.") (($) "\\spad{brace()}$D (otherwise written {}$D) creates an empty set aggregate of type \\spad{D.} This form is considered obsolete. Use \\axiomFun{set} instead.")) (< (((|Boolean|) $ $) "\\spad{s < \\spad{t}} returns \\spad{true} if all elements of set aggregate \\spad{s} are also elements of set aggregate \\spad{t.}"))) 
NIL 
NIL 
(|SetAggregate| S) 
((|constructor| (NIL "A set category lists a collection of set-theoretic operations useful for both finite sets and multisets. Note however that finite sets are distinct from multisets. Although the operations defined for set categories are common to both, the relationship between the two cannot be described by inclusion or inheritance.")) (|union| (($ |#1| $) "\\spad{union(x,u)} returns the set aggregate \\spad{u} with the element \\spad{x} added. If \\spad{u} already contains \\spad{x,} \\axiom{union(x,u)} returns a copy of u.") (($ $ |#1|) "\\spad{union(u,x)} returns the set aggregate \\spad{u} with the element \\spad{x} added. If \\spad{u} already contains \\spad{x,} \\axiom{union(u,x)} returns a copy of u.") (($ $ $) "\\spad{union(u,v)} returns the set aggregate of elements which are members of either set aggregate \\spad{u} or \\spad{v.}")) (|subset?| (((|Boolean|) $ $) "\\spad{subset?(u,v)} tests if \\spad{u} is a subset of \\spad{v.} Note that equivalent to \\axiom{reduce(and,{member?(x,v) for \\spad{x} in u},true,false)}.")) (|symmetricDifference| (($ $ $) "\\spad{symmetricDifference(u,v)} returns the set aggregate of elements \\spad{x} which are members of set aggregate \\spad{u} or set aggregate \\spad{v} but not both. If \\spad{u} and \\spad{v} have no elements in common, \\axiom{symmetricDifference(u,v)} returns a copy of u. Note that \\axiom{symmetricDifference(u,v) = \\indented{1}{union(difference(u,v),difference(v,u))}}")) (|difference| (($ $ |#1|) "\\spad{difference(u,x)} returns the set aggregate \\spad{u} with element \\spad{x} removed. If \\spad{u} does not contain \\spad{x,} a copy of \\spad{u} is returned. Note that \\axiom{difference(s, \\spad{x)} = difference(s, {x})}.") (($ $ $) "\\spad{difference(u,v)} returns the set aggregate \\spad{w} consisting of elements in set aggregate \\spad{u} but not in set aggregate \\spad{v.} If \\spad{u} and \\spad{v} have no elements in common, \\axiom{difference(u,v)} returns a copy of u. Note that equivalent to the notation (not currently supported) \\axiom{{x for \\spad{x} in \\spad{u} | not member?(x,v)}}.")) (|intersect| (($ $ $) "\\spad{intersect(u,v)} returns the set aggregate \\spad{w} consisting of elements common to both set aggregates \\spad{u} and \\spad{v.} Note that equivalent to the notation (not currently supported) \\spad{{x} for \\spad{x} in \\spad{u} | member?(x,v)}.")) (|set| (($ (|List| |#1|)) "\\spad{set([x,y,...,z])} creates a set aggregate containing items x,y,...,z.") (($) "\\spad{set()}$D creates an empty set aggregate of type \\spad{D.}")) (|brace| (($ (|List| |#1|)) "\\spad{brace([x,y,...,z])} creates a set aggregate containing items x,y,...,z. This form is considered obsolete. Use \\axiomFun{set} instead.") (($) "\\spad{brace()}$D (otherwise written {}$D) creates an empty set aggregate of type \\spad{D.} This form is considered obsolete. Use \\axiomFun{set} instead.")) (< (((|Boolean|) $ $) "\\spad{s < \\spad{t}} returns \\spad{true} if all elements of set aggregate \\spad{s} are also elements of set aggregate \\spad{t.}"))) 
((|partiallyOrderedSet| . T) (|nil| . T)) 
NIL 
(|SetCategoryWithDegree|) 
((|constructor| (NIL "This is part of the PAFF package, related to projective space."))) 
NIL 
NIL 
(|SetCategory&| S) 
((|constructor| (NIL "\\spadtype{SetCategory} is the basic category for describing a collection of elements with \\spadop{=} (equality) and \\spadfun{coerce} to output form. \\blankline Conditional Attributes\\br \\tab{5}canonical\\tab{5}data structure equality is the same as \\spadop{=}")) (|latex| (((|String|) $) "\\spad{latex(s)} returns a LaTeX-printable output representation of \\spad{s.}")) (|hash| (((|SingleInteger|) $) "\\spad{hash(s)} calculates a hash code for \\spad{s.}"))) 
NIL 
NIL 
(|SetCategory|) 
((|constructor| (NIL "\\spadtype{SetCategory} is the basic category for describing a collection of elements with \\spadop{=} (equality) and \\spadfun{coerce} to output form. \\blankline Conditional Attributes\\br \\tab{5}canonical\\tab{5}data structure equality is the same as \\spadop{=}")) (|latex| (((|String|) $) "\\spad{latex(s)} returns a LaTeX-printable output representation of \\spad{s.}")) (|hash| (((|SingleInteger|) $) "\\spad{hash(s)} calculates a hash code for \\spad{s.}"))) 
NIL 
NIL 
(|SetOfMIntegersInOneToN| |m| |n|) 
((|constructor| (NIL "\\spadtype{SetOfMIntegersInOneToN} implements the subsets of \\spad{M} integers in the interval \\spad{[1..n]}")) (|delta| (((|NonNegativeInteger|) $ (|PositiveInteger|) (|PositiveInteger|)) "\\spad{delta(S,k,p)} returns the number of elements of \\spad{S} which are strictly between \\spad{p} and the k^{th} element of \\spad{S.}")) (|member?| (((|Boolean|) (|PositiveInteger|) $) "\\spad{member?(p, \\spad{s)}} returns \\spad{true} is \\spad{p} is in \\spad{s,} \\spad{false} otherwise.")) (|enumerate| (((|Vector| $)) "\\spad{enumerate()} returns a vector of all the sets of \\spad{M} integers in \\spad{1..n}.")) (|setOfMinN| (($ (|List| (|PositiveInteger|))) "\\spad{setOfMinN([a_1,...,a_m])} returns the set {a_1,...,a_m}. Error if {a_1,...,a_m} is not a set of \\spad{M} integers in \\spad{1..n}.")) (|elements| (((|List| (|PositiveInteger|)) $) "\\spad{elements(S)} returns the list of the elements of \\spad{S} in increasing order.")) (|replaceKthElement| (((|Union| $ "failed") $ (|PositiveInteger|) (|PositiveInteger|)) "\\spad{replaceKthElement(S,k,p)} replaces the k^{th} element of \\spad{S} by \\spad{p,} and returns \"failed\" if the result is not a set of \\spad{M} integers in \\spad{1..n} any more.")) (|incrementKthElement| (((|Union| $ "failed") $ (|PositiveInteger|)) "\\spad{incrementKthElement(S,k)} increments the k^{th} element of \\spad{S,} and returns \"failed\" if the result is not a set of \\spad{M} integers in \\spad{1..n} any more."))) 
NIL 
NIL 
(|Set| S) 
((|constructor| (NIL "A set over a domain \\spad{D} models the usual mathematical notion of a finite set of elements from \\spad{D.} Sets are unordered collections of distinct elements (that is, order and duplication does not matter). The notation \\spad{set [a,b,c]} can be used to create a set and the usual operations such as union and intersection are available to form new sets. In our implementation, \\Language{} maintains the entries in sorted order. Specifically, the parts function returns the entries as a list in ascending order and the extract operation returns the maximum entry. Given two sets \\spad{s} and \\spad{t} where \\spad{\\#s = \\spad{m}} and \\spad{\\#t = \\spad{n},} the complexity of\\br \\tab{5}\\spad{s = \\spad{t}} is \\spad{O(min(n,m))}\\br \\tab{5}\\spad{s < \\spad{t}} is \\spad{O(max(n,m))}\\br \\tab{5}\\spad{union(s,t)}, \\spad{intersect(s,t)}, \\spad{minus(s,t)},\\br \\tab{10 \\spad{symmetricDifference(s,t)} is \\spad{O(max(n,m))}\\br \\tab{5}\\spad{member(x,t)} is \\spad{O(n log n)}\\br \\tab{5}\\spad{insert(x,t)} and \\spad{remove(x,t)} is \\spad{O(n)}"))) 
((|finiteAggregate| . T) (|partiallyOrderedSet| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|Finite|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|Finite|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|SExpressionCategory| |Str| |Sym| |Int| |Flt| |Expr|) 
((|constructor| (NIL "This category allows the manipulation of Lisp values while keeping the grunge fairly localized.")) (|elt| (($ $ (|List| (|Integer|))) "\\spad{elt((a1,...,an), [i1,...,im])} returns \\spad{(a_i1,...,a_im)}.") (($ $ (|Integer|)) "\\spad{elt((a1,...,an), i)} returns \\spad{ai}.")) (|#| (((|Integer|) $) "\\spad{\\#((a1,...,an))} returns \\spad{n.}")) (|cdr| (($ $) "\\spad{cdr((a1,...,an))} returns \\spad{(a2,...,an)}.")) (|car| (($ $) "\\spad{car((a1,...,an))} returns a1.")) (|convert| (($ |#5|) "\\spad{convert(x)} returns the Lisp atom \\spad{x.}") (($ |#4|) "\\spad{convert(x)} returns the Lisp atom \\spad{x.}") (($ |#3|) "\\spad{convert(x)} returns the Lisp atom \\spad{x.}") (($ |#2|) "\\spad{convert(x)} returns the Lisp atom \\spad{x.}") (($ |#1|) "\\spad{convert(x)} returns the Lisp atom \\spad{x;}") (($ (|List| $)) "\\spad{convert([a1,...,an])} returns an S-expression \\spad{(a1,...,an)}.")) (|expr| ((|#5| $) "\\spad{expr(s)} returns \\spad{s} as an element of Expr; Error: if \\spad{s} is not an atom that also belongs to Expr.")) (|float| ((|#4| $) "\\spad{float(s)} returns \\spad{s} as an element of Flt; Error: if \\spad{s} is not an atom that also belongs to Flt.")) (|integer| ((|#3| $) "\\spad{integer(s)} returns \\spad{s} as an element of Int. Error: if \\spad{s} is not an atom that also belongs to Int.")) (|symbol| ((|#2| $) "\\spad{symbol(s)} returns \\spad{s} as an element of Sym. Error: if \\spad{s} is not an atom that also belongs to Sym.")) (|string| ((|#1| $) "\\spad{string(s)} returns \\spad{s} as an element of Str. Error: if \\spad{s} is not an atom that also belongs to Str.")) (|destruct| (((|List| $) $) "\\spad{destruct((a1,...,an))} returns the list [a1,...,an].")) (|float?| (((|Boolean|) $) "\\spad{float?(s)} is \\spad{true} if \\spad{s} is an atom and belong to Flt.")) (|integer?| (((|Boolean|) $) "\\spad{integer?(s)} is \\spad{true} if \\spad{s} is an atom and belong to Int.")) (|symbol?| (((|Boolean|) $) "\\spad{symbol?(s)} is \\spad{true} if \\spad{s} is an atom and belong to Sym.")) (|string?| (((|Boolean|) $) "\\spad{string?(s)} is \\spad{true} if \\spad{s} is an atom and belong to Str.")) (|list?| (((|Boolean|) $) "\\spad{list?(s)} is \\spad{true} if \\spad{s} is a Lisp list, possibly \\spad{().}")) (|pair?| (((|Boolean|) $) "\\spad{pair?(s)} is \\spad{true} if \\spad{s} has is a non-null Lisp list.")) (|atom?| (((|Boolean|) $) "\\spad{atom?(s)} is \\spad{true} if \\spad{s} is a Lisp atom.")) (|null?| (((|Boolean|) $) "\\spad{null?(s)} is \\spad{true} if \\spad{s} is the S-expression \\spad{().}")) (|eq| (((|Boolean|) $ $) "\\spad{eq(s, \\spad{t)}} is \\spad{true} if EQ(s,t) is \\spad{true} in Lisp."))) 
NIL 
NIL 
(|SExpression|) 
((|constructor| (NIL "This domain allows the manipulation of the usual Lisp values."))) 
NIL 
NIL 
(|SExpressionOf| |Str| |Sym| |Int| |Flt| |Expr|) 
((|constructor| (NIL "This domain allows the manipulation of Lisp values over arbitrary atomic types."))) 
NIL 
NIL 
(|SimpleFortranProgram| R FS) 
((|constructor| (NIL "\\axiomType{SimpleFortranProgram(f,type)} provides a simple model of some FORTRAN subprograms, making it possible to coerce objects of various domains into a FORTRAN subprogram called \\axiom{f}. These can then be translated into legal FORTRAN code.")) (|fortran| (($ (|Symbol|) (|FortranScalarType|) |#2|) "\\spad{fortran(fname,ftype,body)} builds an object of type \\axiomType{FortranProgramCategory}. The three arguments specify the name, the type and the \\spad{body} of the program."))) 
NIL 
NIL 
(|SquareFreeQuasiComponentPackage| R E V P TS) 
((|constructor| (NIL "A internal package for removing redundant quasi-components and redundant branches when decomposing a variety by means of quasi-components of regular triangular sets.")) (|branchIfCan| (((|Union| (|Record| (|:| |eq| (|List| |#4|)) (|:| |tower| |#5|) (|:| |ineq| (|List| |#4|))) "failed") (|List| |#4|) |#5| (|List| |#4|) (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|)) "\\axiom{branchIfCan(leq,ts,lineq,b1,b2,b3,b4,b5)} is an internal subroutine, exported only for developement.")) (|prepareDecompose| (((|List| (|Record| (|:| |eq| (|List| |#4|)) (|:| |tower| |#5|) (|:| |ineq| (|List| |#4|)))) (|List| |#4|) (|List| |#5|) (|Boolean|) (|Boolean|)) "\\axiom{prepareDecompose(lp,lts,b1,b2)} is an internal subroutine, exported only for developement.")) (|removeSuperfluousCases| (((|List| (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|))) (|List| (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|)))) "\\axiom{removeSuperfluousCases(llpwt)} is an internal subroutine, exported only for developement.")) (|subCase?| (((|Boolean|) (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|)) (|Record| (|:| |val| (|List| |#4|)) (|:| |tower| |#5|))) "\\axiom{subCase?(lpwt1,lpwt2)} is an internal subroutine, exported only for developement.")) (|removeSuperfluousQuasiComponents| (((|List| |#5|) (|List| |#5|)) "\\axiom{removeSuperfluousQuasiComponents(lts)} removes from \\axiom{lts} any \\spad{ts} such that \\axiom{subQuasiComponent?(ts,us)} holds for another \\spad{us} in \\axiom{lts}.")) (|subQuasiComponent?| (((|Boolean|) |#5| (|List| |#5|)) "\\axiom{subQuasiComponent?(ts,lus)} returns \\spad{true} iff \\axiom{subQuasiComponent?(ts,us)} holds for one \\spad{us} in \\spad{lus}.") (((|Boolean|) |#5| |#5|) "\\axiom{subQuasiComponent?(ts,us)} returns \\spad{true} iff internalSubQuasiComponent?(ts,us) from QuasiComponentPackage returns true.")) (|internalSubQuasiComponent?| (((|Union| (|Boolean|) "failed") |#5| |#5|) "\\axiom{internalSubQuasiComponent?(ts,us)} returns a boolean \\spad{b} value if the fact the regular zero set of \\axiom{us} contains that of \\axiom{ts} can be decided (and in that case \\axiom{b} gives this inclusion) otherwise returns \\axiom{\"failed\"}.")) (|infRittWu?| (((|Boolean|) (|List| |#4|) (|List| |#4|)) "\\axiom{infRittWu?(lp1,lp2)} is an internal subroutine, exported only for developement.")) (|internalInfRittWu?| (((|Boolean|) (|List| |#4|) (|List| |#4|)) "\\axiom{internalInfRittWu?(lp1,lp2)} is an internal subroutine, exported only for developement.")) (|internalSubPolSet?| (((|Boolean|) (|List| |#4|) (|List| |#4|)) "\\axiom{internalSubPolSet?(lp1,lp2)} returns \\spad{true} iff \\axiom{lp1} is a sub-set of \\axiom{lp2} assuming that these lists are sorted increasingly w.r.t. infRittWu? from RecursivePolynomialCategory.")) (|subPolSet?| (((|Boolean|) (|List| |#4|) (|List| |#4|)) "\\axiom{subPolSet?(lp1,lp2)} returns \\spad{true} iff \\axiom{lp1} is a sub-set of \\axiom{lp2}.")) (|subTriSet?| (((|Boolean|) |#5| |#5|) "\\axiom{subTriSet?(ts,us)} returns \\spad{true} iff \\axiom{ts} is a sub-set of \\axiom{us}.")) (|moreAlgebraic?| (((|Boolean|) |#5| |#5|) "\\axiom{moreAlgebraic?(ts,us)} returns \\spad{false} iff \\axiom{ts} and \\axiom{us} are both empty, or \\axiom{ts} has less elements than \\axiom{us}, or some variable is algebraic w.r.t. \\axiom{us} and is not w.r.t. \\axiom{ts}.")) (|algebraicSort| (((|List| |#5|) (|List| |#5|)) "\\axiom{algebraicSort(lts)} sorts \\axiom{lts} w.r.t supDimElseRittWu from QuasiComponentPackage.")) (|supDimElseRittWu?| (((|Boolean|) |#5| |#5|) "\\axiom{supDimElseRittWu(ts,us)} returns \\spad{true} iff \\axiom{ts} has less elements than \\axiom{us} otherwise if \\axiom{ts} has higher rank than \\axiom{us} w.r.t. Riit and Wu ordering.")) (|stopTable!| (((|Void|)) "\\axiom{stopTableGcd!()} is an internal subroutine, exported only for developement.")) (|startTable!| (((|Void|) (|String|) (|String|) (|String|)) "\\axiom{startTableGcd!(s1,s2,s3)} is an internal subroutine, exported only for developement."))) 
NIL 
NIL 
(|SquareFreeRegularTriangularSetGcdPackage| R E V P TS) 
((|constructor| (NIL "A internal package for computing gcds and resultants of univariate polynomials with coefficients in a tower of simple extensions of a field. There is no need to use directly this package since its main operations are available from \\spad{TS}."))) 
NIL 
NIL 
(|SquareFreeRegularTriangularSetCategory| R E V P) 
((|constructor| (NIL "The category of square-free regular triangular sets. A regular triangular set \\spad{ts} is square-free if the \\spad{gcd} of any polynomial \\spad{p} in \\spad{ts} and differentiate(p,mvar(p)) w.r.t. collectUnder(ts,mvar(p)) has degree zero w.r.t. \\spad{mvar(p)}. Thus any square-free regular set defines a tower of square-free simple extensions."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|SymmetricGroupCombinatoricFunctions|) 
((|constructor| (NIL "SymmetricGroupCombinatoricFunctions contains combinatoric functions concerning symmetric groups and representation theory: list young tableaus, improper partitions, subsets bijection of Coleman.")) (|unrankImproperPartitions1| (((|List| (|Integer|)) (|Integer|) (|Integer|) (|Integer|)) "\\spad{unrankImproperPartitions1(n,m,k)} computes the \\spad{k}-th improper partition of nonnegative \\spad{n} in at most \\spad{m} nonnegative parts ordered as follows: first, in reverse lexicographically according to their non-zero parts, then according to their positions (\\spadignore{i.e.} lexicographical order using subSet: [3,0,0] < [0,3,0] < [0,0,3] < [2,1,0] < [2,0,1] < [0,2,1] < [1,2,0] < [1,0,2] < [0,1,2] < [1,1,1]. Note that counting of subtrees is done by numberOfImproperPartitionsInternal.")) (|unrankImproperPartitions0| (((|List| (|Integer|)) (|Integer|) (|Integer|) (|Integer|)) "\\spad{unrankImproperPartitions0(n,m,k)} computes the \\spad{k}-th improper partition of nonnegative \\spad{n} in \\spad{m} nonnegative parts in reverse lexicographical order. Example: [0,0,3] < [0,1,2] < [0,2,1] < [0,3,0] < [1,0,2] < [1,1,1] < [1,2,0] < [2,0,1] < [2,1,0] < [3,0,0]. Error: if \\spad{k} is negative or too big. Note that counting of subtrees is done by numberOfImproperPartitions")) (|subSet| (((|List| (|Integer|)) (|Integer|) (|Integer|) (|Integer|)) "\\spad{subSet(n,m,k)} calculates the \\spad{k}-th m-subset of the set 0,1,...,(n-1) in the lexicographic order considered as a decreasing map from 0,...,(m-1) into 0,...,(n-1). See S.G. Williamson: Theorem 1.60. Error: if not \\spad{(0} \\spad{<=} \\spad{m} \\spad{<=} \\spad{n} and 0 < = \\spad{k} < \\spad{(n} choose m)).")) (|numberOfImproperPartitions| (((|Integer|) (|Integer|) (|Integer|)) "\\spad{numberOfImproperPartitions(n,m)} computes the number of partitions of the nonnegative integer \\spad{n} in \\spad{m} nonnegative parts with regarding the order (improper partitions). Example: numberOfImproperPartitions (3,3) is 10, since [0,0,3], [0,1,2], [0,2,1], [0,3,0], [1,0,2], [1,1,1], [1,2,0], [2,0,1], [2,1,0], [3,0,0] are the possibilities. Note that this operation has a recursive implementation.")) (|nextPartition| (((|Vector| (|Integer|)) (|List| (|Integer|)) (|Vector| (|Integer|)) (|Integer|)) "\\spad{nextPartition(gamma,part,number)} generates the partition of \\spad{number} which follows \\spad{part} according to the right-to-left lexicographical order. The partition has the property that its components do not exceed the corresponding components of gamma. the first partition is achieved by part=[]. Also, \\spad{[]} indicates that \\spad{part} is the last partition.") (((|Vector| (|Integer|)) (|Vector| (|Integer|)) (|Vector| (|Integer|)) (|Integer|)) "\\spad{nextPartition(gamma,part,number)} generates the partition of \\spad{number} which follows \\spad{part} according to the right-to-left lexicographical order. The partition has the property that its components do not exceed the corresponding components of gamma. The first partition is achieved by part=[]. Also, \\spad{[]} indicates that \\spad{part} is the last partition.")) (|nextLatticePermutation| (((|List| (|Integer|)) (|List| (|Integer|)) (|List| (|Integer|)) (|Boolean|)) "\\spad{nextLatticePermutation(lambda,lattP,constructNotFirst)} generates the lattice permutation according to the proper partition \\spad{lambda} succeeding the lattice permutation \\spad{lattP} in lexicographical order as long as \\spad{constructNotFirst} is true. If \\spad{constructNotFirst} is false, the first lattice permutation is returned. The result nil indicates that \\spad{lattP} has no successor.")) (|nextColeman| (((|Matrix| (|Integer|)) (|List| (|Integer|)) (|List| (|Integer|)) (|Matrix| (|Integer|))) "\\spad{nextColeman(alpha,beta,C)} generates the next Coleman matrix of column sums \\spad{alpha} and row sums \\spad{beta} according to the lexicographical order from bottom-to-top. The first Coleman matrix is achieved by C=new(1,1,0). Also, new(1,1,0) indicates that \\spad{C} is the last Coleman matrix.")) (|makeYoungTableau| (((|Matrix| (|Integer|)) (|List| (|Integer|)) (|List| (|Integer|))) "\\spad{makeYoungTableau(lambda,gitter)} computes for a given lattice permutation \\spad{gitter} and for an improper partition \\spad{lambda} the corresponding standard tableau of shape lambda. Notes: see listYoungTableaus. The entries are from 0,...,n-1.")) (|listYoungTableaus| (((|List| (|Matrix| (|Integer|))) (|List| (|Integer|))) "\\spad{listYoungTableaus(lambda)} where \\spad{lambda} is a proper partition generates the list of all standard tableaus of shape \\spad{lambda} by means of lattice permutations. The numbers of the lattice permutation are interpreted as column labels. Hence the contents of these lattice permutations are the conjugate of lambda. Notes: the functions nextLatticePermutation and makeYoungTableau are used. The entries are from 0,...,n-1.")) (|inverseColeman| (((|List| (|Integer|)) (|List| (|Integer|)) (|List| (|Integer|)) (|Matrix| (|Integer|))) "\\spad{inverseColeman(alpha,beta,C)}: there is a bijection from the set of matrices having nonnegative entries and row sums alpha, column sums \\spad{beta} to the set of Salpha - Sbeta double cosets of the symmetric group \\spad{Sn.} (Salpha is the Young subgroup corresponding to the improper partition alpha). For such a matrix \\spad{C,} inverseColeman(alpha,beta,C) calculates the lexicographical smallest \\spad{pi} in the corresponding double coset. Note that the resulting permutation \\spad{pi} of {1,2,...,n} is given in list form. Notes: the inverse of this map is coleman. For details, see James/Kerber.")) (|coleman| (((|Matrix| (|Integer|)) (|List| (|Integer|)) (|List| (|Integer|)) (|List| (|Integer|))) "\\spad{coleman(alpha,beta,pi)}: there is a bijection from the set of matrices having nonnegative entries and row sums alpha, column sums \\spad{beta} to the set of Salpha - Sbeta double cosets of the symmetric group \\spad{Sn.} (Salpha is the Young subgroup corresponding to the improper partition alpha). For a representing element \\spad{pi} of such a double coset, coleman(alpha,beta,pi) generates the Coleman-matrix corresponding to alpha, beta, pi. Note that The permutation \\spad{pi} of {1,2,...,n} has to be given in list form. Note that the inverse of this map is inverseColeman (if \\spad{pi} is the lexicographical smallest permutation in the coset). For details see James/Kerber."))) 
NIL 
NIL 
(|SemiGroup&| S) 
((|constructor| (NIL "the class of all multiplicative semigroups, that is, a set with an associative operation \\spadop{*}. \\blankline Axioms\\br \\tab{5}\\spad{associative(\"*\":(\\%,\\%)->\\%)}\\tab{5}\\spad{(x*y)*z = x*(y*z)} \\blankline Conditional attributes\\br \\tab{5}\\spad{commutative(\"*\":(\\%,\\%)->\\%)}\\tab{5}\\spad{x*y = y*x}")) (^ (($ $ (|PositiveInteger|)) "\\spad{x^n} returns the repeated product of \\spad{x} \\spad{n} times, exponentiation.")) (** (($ $ (|PositiveInteger|)) "\\spad{x**n} returns the repeated product of \\spad{x} \\spad{n} times, exponentiation.")) (* (($ $ $) "\\spad{x*y} returns the product of \\spad{x} and \\spad{y.}"))) 
NIL 
NIL 
(|SemiGroup|) 
((|constructor| (NIL "the class of all multiplicative semigroups, that is, a set with an associative operation \\spadop{*}. \\blankline Axioms\\br \\tab{5}\\spad{associative(\"*\":(\\%,\\%)->\\%)}\\tab{5}\\spad{(x*y)*z = x*(y*z)} \\blankline Conditional attributes\\br \\tab{5}\\spad{commutative(\"*\":(\\%,\\%)->\\%)}\\tab{5}\\spad{x*y = y*x}")) (^ (($ $ (|PositiveInteger|)) "\\spad{x^n} returns the repeated product of \\spad{x} \\spad{n} times, exponentiation.")) (** (($ $ (|PositiveInteger|)) "\\spad{x**n} returns the repeated product of \\spad{x} \\spad{n} times, exponentiation.")) (* (($ $ $) "\\spad{x*y} returns the product of \\spad{x} and \\spad{y.}"))) 
NIL 
NIL 
(|SplitHomogeneousDirectProduct| |dimtot| |dim1| S) 
((|constructor| (NIL "This type represents the finite direct or cartesian product of an underlying ordered component type. The vectors are ordered as if they were split into two blocks. The \\spad{dim1} parameter specifies the length of the first block. The ordering is lexicographic between the blocks but acts like \\spadtype{HomogeneousDirectProduct} within each block. This type is a suitable third argument for \\spadtype{GeneralDistributedMultivariatePolynomial}."))) 
((|rightUnitary| |has| |#3| (|Ring|)) (|leftUnitary| |has| |#3| (|Ring|)) (|unitsKnown| |has| |#3| (ATTRIBUTE |unitsKnown|)) ((|commutative| "*") |has| |#3| (|CommutativeRing|)) (|finiteAggregate| . T)) 
((|HasCategory| |#3| (QUOTE (|SetCategory|))) (|HasCategory| |#3| (QUOTE (|Field|))) (|HasCategory| |#3| (QUOTE (|Ring|))) (|HasCategory| |#3| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#3| (QUOTE (|OrderedRing|))) (OR (|HasCategory| |#3| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#3| (QUOTE (|OrderedRing|)))) (|HasCategory| |#3| (QUOTE (|Monoid|))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|Field|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (OR (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|Field|)))) (OR (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (|HasCategory| |#3| (QUOTE (|Finite|))) (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|))) (OR (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|))) (|HasCategory| |#3| (QUOTE (|Field|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (OR (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (AND (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (QUOTE (|DifferentialRing|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))) (|HasAttribute| |#3| (QUOTE |unitsKnown|)) (|HasCategory| |#3| (QUOTE (|CancellationAbelianMonoid|))) (OR (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|))) (|HasCategory| |#3| (QUOTE (|Field|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (|HasCategory| |#3| (QUOTE (|AbelianSemiGroup|))) (OR (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#3| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|))) (|HasCategory| |#3| (QUOTE (|Field|))) (|HasCategory| |#3| (QUOTE (|Finite|))) (|HasCategory| |#3| (QUOTE (|Monoid|))) (|HasCategory| |#3| (QUOTE (|OrderedAbelianMonoidSup|))) (|HasCategory| |#3| (QUOTE (|OrderedRing|))) (|HasCategory| |#3| (QUOTE (|Ring|))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))) (OR (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#3| (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|))) (|HasCategory| |#3| (QUOTE (|Field|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (OR (AND (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|AbelianSemiGroup|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|Field|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|Finite|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#3| (QUOTE (|SetCategory|))))) (OR (AND (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|AbelianSemiGroup|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|Field|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|Finite|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#3| (QUOTE (|SetCategory|))))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|))))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|AbelianSemiGroup|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|CancellationAbelianMonoid|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|Field|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|Finite|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|Monoid|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|OrderedAbelianMonoidSup|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|OrderedRing|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|Ring|)))) (AND (|HasCategory| |#3| (LIST (QUOTE |Evalable|) (|devaluate| |#3|))) (|HasCategory| |#3| (QUOTE (|SetCategory|)))))) 
(|SturmHabichtPackage| R |x|) 
((|constructor| (NIL "This package produces functions for counting etc. real roots of univariate polynomials in \\spad{x} over \\spad{R,} which must be an OrderedIntegralDomain")) (|countRealRootsMultiple| (((|Integer|) (|UnivariatePolynomial| |#2| |#1|)) "\\spad{countRealRootsMultiple(p)} says how many real roots \\spad{p} has, counted with multiplicity")) (|SturmHabichtMultiple| (((|Integer|) (|UnivariatePolynomial| |#2| |#1|) (|UnivariatePolynomial| |#2| |#1|)) "\\spad{SturmHabichtMultiple(p1,p2)} computes c_{+}-c_{-} where c_{+} is the number of real roots of \\spad{p1} with \\spad{p2>0} and c_{-} is the number of real roots of \\spad{p1} with p2<0. If \\spad{p2=1} what you get is the number of real roots of \\spad{p1.}")) (|countRealRoots| (((|Integer|) (|UnivariatePolynomial| |#2| |#1|)) "\\spad{countRealRoots(p)} says how many real roots \\spad{p} has")) (|SturmHabicht| (((|Integer|) (|UnivariatePolynomial| |#2| |#1|) (|UnivariatePolynomial| |#2| |#1|)) "\\spad{SturmHabicht(p1,p2)} computes c_{+}-c_{-} where c_{+} is the number of real roots of \\spad{p1} with \\spad{p2>0} and c_{-} is the number of real roots of \\spad{p1} with p2<0. If \\spad{p2=1} what you get is the number of real roots of \\spad{p1.}")) (|SturmHabichtCoefficients| (((|List| |#1|) (|UnivariatePolynomial| |#2| |#1|) (|UnivariatePolynomial| |#2| |#1|)) "\\spad{SturmHabichtCoefficients(p1,p2)} computes the principal Sturm-Habicht coefficients of \\spad{p1} and \\spad{p2}")) (|SturmHabichtSequence| (((|List| (|UnivariatePolynomial| |#2| |#1|)) (|UnivariatePolynomial| |#2| |#1|) (|UnivariatePolynomial| |#2| |#1|)) "\\spad{SturmHabichtSequence(p1,p2)} computes the Sturm-Habicht sequence of \\spad{p1} and \\spad{p2}")) (|subresultantSequence| (((|List| (|UnivariatePolynomial| |#2| |#1|)) (|UnivariatePolynomial| |#2| |#1|) (|UnivariatePolynomial| |#2| |#1|)) "\\spad{subresultantSequence(p1,p2)} computes the (standard) subresultant sequence of \\spad{p1} and \\spad{p2}"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|GcdDomain|)))) 
(|ElementaryFunctionSign| R F) 
((|constructor| (NIL "This package provides functions to determine the sign of an elementary function around a point or infinity.")) (|sign| (((|Union| (|Integer|) "failed") |#2| (|Symbol|) |#2| (|String|)) "\\spad{sign(f, \\spad{x,} a, \\spad{s)}} returns the sign of \\spad{f} as \\spad{x} nears \\spad{a} from below if \\spad{s} is \"left\", or above if \\spad{s} is \"right\".") (((|Union| (|Integer|) "failed") |#2| (|Symbol|) (|OrderedCompletion| |#2|)) "\\spad{sign(f, \\spad{x,} a)} returns the sign of \\spad{f} as \\spad{x} nears \\spad{a}, from both sides if \\spad{a} is finite.") (((|Union| (|Integer|) "failed") |#2|) "\\spad{sign(f)} returns the sign of \\spad{f} if it is constant everywhere."))) 
NIL 
NIL 
(|RationalFunctionSign| R) 
((|constructor| (NIL "Find the sign of a rational function around a point or infinity.")) (|sign| (((|Union| (|Integer|) "failed") (|Fraction| (|Polynomial| |#1|)) (|Symbol|) (|Fraction| (|Polynomial| |#1|)) (|String|)) "\\spad{sign(f, \\spad{x,} a, \\spad{s)}} returns the sign of \\spad{f} as \\spad{x} nears \\spad{a} from the left (below) if \\spad{s} is the string \\spad{\"left\"}, or from the right (above) if \\spad{s} is the string \\spad{\"right\"}.") (((|Union| (|Integer|) "failed") (|Fraction| (|Polynomial| |#1|)) (|Symbol|) (|OrderedCompletion| (|Fraction| (|Polynomial| |#1|)))) "\\spad{sign(f, \\spad{x,} a)} returns the sign of \\spad{f} as \\spad{x} approaches \\spad{a}, from both sides if \\spad{a} is finite.") (((|Union| (|Integer|) "failed") (|Fraction| (|Polynomial| |#1|))) "\\spad{sign \\spad{f}} returns the sign of \\spad{f} if it is constant everywhere."))) 
NIL 
NIL 
(|SimplifyAlgebraicNumberConvertPackage|) 
((|constructor| (NIL "Package to allow simplify to be called on AlgebraicNumbers by converting to EXPR(INT)")) (|simplify| (((|Expression| (|Integer|)) (|AlgebraicNumber|)) "\\spad{simplify(an)} applies simplifications to \\spad{an}"))) 
NIL 
NIL 
(|SingleInteger|) 
((|constructor| (NIL "SingleInteger is intended to support machine integer arithmetic.")) (|Or| (($ $ $) "\\spad{Or(n,m)} returns the bit-by-bit logical or of the single integers \\spad{n} and \\spad{m.}")) (|And| (($ $ $) "\\spad{And(n,m)} returns the bit-by-bit logical and of the single integers \\spad{n} and \\spad{m.}")) (|Not| (($ $) "\\spad{Not(n)} returns the bit-by-bit logical not of the single integer \\spad{n.}")) (|xor| (($ $ $) "\\spad{xor(n,m)} returns the bit-by-bit logical xor of the single integers \\spad{n} and \\spad{m.}")) (|\\/| (($ $ $) "\\spad{n} \\spad{\\/} \\spad{m} returns the bit-by-bit logical or of the single integers \\spad{n} and \\spad{m.}")) (|/\\| (($ $ $) "\\spad{n} \\spad{/\\} \\spad{m} returns the bit-by-bit logical and of the single integers \\spad{n} and \\spad{m.}")) (~ (($ $) "\\spad{~ \\spad{n}} returns the bit-by-bit logical not of the single integer \\spad{n.}")) (|not| (($ $) "\\spad{not(n)} returns the bit-by-bit logical not of the single integer \\spad{n.}")) (|min| (($) "\\spad{min()} returns the smallest single integer.")) (|max| (($) "\\spad{max()} returns the largest single integer.")) (|noetherian| ((|attribute|) "\\spad{noetherian} all ideals are finitely generated (in fact principal).")) (|canonicalsClosed| ((|attribute|) "\\spad{canonicalClosed} means two positives multiply to give positive.")) (|canonical| ((|attribute|) "\\spad{canonical} means that mathematical equality is implied by data structure equality."))) 
((|noetherian| . T) (|canonicalsClosed| . T) (|canonical| . T) (|canonicalUnitNormal| . T) (|multiplicativeValuation| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|StackAggregate| S) 
((|constructor| (NIL "A stack is a bag where the last item inserted is the first item extracted.")) (|depth| (((|NonNegativeInteger|) $) "\\spad{depth(s)} returns the number of elements of stack \\spad{s.} \\indented{1}{Note that \\axiom{depth(s) = \\#s}.} \\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} depth a")) (|top| ((|#1| $) "\\spad{top(s)} returns the top element \\spad{x} from \\spad{s;} \\spad{s} remains unchanged. \\indented{1}{Note that Use \\axiom{pop!(s)} to obtain \\spad{x} and remove it from \\spad{s.}} \\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} top a")) (|pop!| ((|#1| $) "\\spad{pop!(s)} returns the top element \\spad{x,} destructively removing \\spad{x} from \\spad{s.} \\indented{1}{Note that Use \\axiom{top(s)} to obtain \\spad{x} without removing it from \\spad{s.}} \\indented{1}{Error: if \\spad{s} is empty.} \\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} pop! a \\spad{X} a")) (|push!| ((|#1| |#1| $) "\\spad{push!(x,s)} pushes \\spad{x} onto stack \\spad{s,} that is, destructively changing \\spad{s} \\indented{1}{so as to have a new first (top) element \\spad{x.}} \\indented{1}{Afterwards, pop!(s) produces \\spad{x} and pop!(s) produces the original \\spad{s.}} \\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} push! a \\spad{X} a"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|SquareMatrixCategory&| S |ndim| R |Row| |Col|) 
((|constructor| (NIL "\\spadtype{SquareMatrixCategory} is a general square matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and colums returned as objects of type Col.")) (** (($ $ (|Integer|)) "\\spad{m**n} computes an integral power of the matrix \\spad{m.} Error: if the matrix is not invertible.")) (|inverse| (((|Union| $ "failed") $) "\\spad{inverse(m)} returns the inverse of the matrix \\spad{m,} if that matrix is invertible and returns \"failed\" otherwise.")) (|minordet| ((|#3| $) "\\spad{minordet(m)} computes the determinant of the matrix \\spad{m} using minors.")) (|determinant| ((|#3| $) "\\spad{determinant(m)} returns the determinant of the matrix \\spad{m.}")) (* ((|#4| |#4| $) "\\spad{r * \\spad{x}} is the product of the row vector \\spad{r} and the matrix \\spad{x.} Error: if the dimensions are incompatible.") ((|#5| $ |#5|) "\\spad{x * \\spad{c}} is the product of the matrix \\spad{x} and the column vector \\spad{c.} Error: if the dimensions are incompatible.")) (|diagonalProduct| ((|#3| $) "\\spad{diagonalProduct(m)} returns the product of the elements on the diagonal of the matrix \\spad{m.}")) (|trace| ((|#3| $) "\\spad{trace(m)} returns the trace of the matrix \\spad{m.} this is the sum of the elements on the diagonal of the matrix \\spad{m.}")) (|diagonal| ((|#4| $) "\\spad{diagonal(m)} returns a row consisting of the elements on the diagonal of the matrix \\spad{m.}")) (|diagonalMatrix| (($ (|List| |#3|)) "\\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements of \\spad{l} on the diagonal.")) (|scalarMatrix| (($ |#3|) "\\spad{scalarMatrix(r)} returns an n-by-n matrix with \\spad{r's} on the diagonal and zeroes elsewhere."))) 
NIL 
((|HasCategory| |#3| (QUOTE (|Field|))) (|HasAttribute| |#3| (QUOTE (|commutative| "*"))) (|HasCategory| |#3| (QUOTE (|CommutativeRing|)))) 
(|SquareMatrixCategory| |ndim| R |Row| |Col|) 
((|constructor| (NIL "\\spadtype{SquareMatrixCategory} is a general square matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and colums returned as objects of type Col.")) (** (($ $ (|Integer|)) "\\spad{m**n} computes an integral power of the matrix \\spad{m.} Error: if the matrix is not invertible.")) (|inverse| (((|Union| $ "failed") $) "\\spad{inverse(m)} returns the inverse of the matrix \\spad{m,} if that matrix is invertible and returns \"failed\" otherwise.")) (|minordet| ((|#2| $) "\\spad{minordet(m)} computes the determinant of the matrix \\spad{m} using minors.")) (|determinant| ((|#2| $) "\\spad{determinant(m)} returns the determinant of the matrix \\spad{m.}")) (* ((|#3| |#3| $) "\\spad{r * \\spad{x}} is the product of the row vector \\spad{r} and the matrix \\spad{x.} Error: if the dimensions are incompatible.") ((|#4| $ |#4|) "\\spad{x * \\spad{c}} is the product of the matrix \\spad{x} and the column vector \\spad{c.} Error: if the dimensions are incompatible.")) (|diagonalProduct| ((|#2| $) "\\spad{diagonalProduct(m)} returns the product of the elements on the diagonal of the matrix \\spad{m.}")) (|trace| ((|#2| $) "\\spad{trace(m)} returns the trace of the matrix \\spad{m.} this is the sum of the elements on the diagonal of the matrix \\spad{m.}")) (|diagonal| ((|#3| $) "\\spad{diagonal(m)} returns a row consisting of the elements on the diagonal of the matrix \\spad{m.}")) (|diagonalMatrix| (($ (|List| |#2|)) "\\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements of \\spad{l} on the diagonal.")) (|scalarMatrix| (($ |#2|) "\\spad{scalarMatrix(r)} returns an n-by-n matrix with \\spad{r's} on the diagonal and zeroes elsewhere."))) 
((|nil| . T) (|finiteAggregate| . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|SmithNormalForm| R |Row| |Col| M) 
((|constructor| (NIL "\\spadtype{SmithNormalForm} is a package which provides some standard canonical forms for matrices.")) (|diophantineSystem| (((|Record| (|:| |particular| (|Union| |#3| "failed")) (|:| |basis| (|List| |#3|))) |#4| |#3|) "\\spad{diophantineSystem(A,B)} returns a particular integer solution and an integer basis of the equation \\spad{AX = \\spad{B}.}")) (|completeSmith| (((|Record| (|:| |Smith| |#4|) (|:| |leftEqMat| |#4|) (|:| |rightEqMat| |#4|)) |#4|) "\\spad{completeSmith} returns a record that contains the Smith normal form \\spad{H} of the matrix and the left and right equivalence matrices \\spad{U} and \\spad{V} such that U*m*v = \\spad{H}")) (|smith| ((|#4| |#4|) "\\spad{smith(m)} returns the Smith Normal form of the matrix \\spad{m.}")) (|completeHermite| (((|Record| (|:| |Hermite| |#4|) (|:| |eqMat| |#4|)) |#4|) "\\spad{completeHermite} returns a record that contains the Hermite normal form \\spad{H} of the matrix and the equivalence matrix \\spad{U} such that U*m = \\spad{H}")) (|hermite| ((|#4| |#4|) "\\spad{hermite(m)} returns the Hermite normal form of the matrix \\spad{m.}"))) 
NIL 
NIL 
(|SparseMultivariatePolynomial| R |VarSet|) 
((|constructor| (NIL "This type is the basic representation of sparse recursive multivariate polynomials. It is parameterized by the coefficient ring and the variable set which may be infinite. The variable ordering is determined by the variable set parameter. The coefficient ring may be non-commutative, but the variables are assumed to commute."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))))) 
(|SparseMultivariateTaylorSeries| |Coef| |Var| SMP) 
((|constructor| (NIL "This domain provides multivariate Taylor series with variables from an arbitrary ordered set. A Taylor series is represented by a stream of polynomials from the polynomial domain SMP. The \\spad{n}th element of the stream is a form of degree \\spad{n.} SMTS is an internal domain.")) (|fintegrate| (($ (|Mapping| $) |#2| |#1|) "\\spad{fintegrate(f,v,c)} is the integral of \\spad{f()} with respect \\indented{1}{to \\spad{v} and having \\spad{c} as the constant of integration.} \\indented{1}{The evaluation of \\spad{f()} is delayed.}")) (|integrate| (($ $ |#2| |#1|) "\\spad{integrate(s,v,c)} is the integral of \\spad{s} with respect \\indented{1}{to \\spad{v} and having \\spad{c} as the constant of integration.}")) (|csubst| (((|Mapping| (|Stream| |#3|) |#3|) (|List| |#2|) (|List| (|Stream| |#3|))) "\\spad{csubst(a,b)} is for internal use only")) (* (($ |#3| $) "\\spad{smp*ts} multiplies a TaylorSeries by a monomial SMP.")) (|coerce| (($ |#3|) "\\spad{coerce(poly)} regroups the terms by total degree and forms a series.") (($ |#2|) "\\spad{coerce(var)} converts a variable to a Taylor series")) (|coefficient| ((|#3| $ (|NonNegativeInteger|)) "\\indented{1}{\\spad{coefficient(s, \\spad{n)}} gives the terms of total degree \\spad{n.}} \\blankline \\spad{X} xts:=x::TaylorSeries Fraction Integer \\spad{X} t1:=sin(xts) \\spad{X} coefficient(t1,3)"))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) 
(|SquareFreeNormalizedTriangularSetCategory| R E V P) 
((|constructor| (NIL "The category of square-free and normalized triangular sets. Thus, up to the primitivity axiom of [1], these sets are Lazard triangular sets."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|PolynomialSolveByFormulas| UP F) 
((|constructor| (NIL "This package factors the formulas out of the general solve code, allowing their recursive use over different domains. Care is taken to introduce few radicals so that radical extension domains can more easily simplify the results.")) (|aQuartic| ((|#2| |#2| |#2| |#2| |#2| |#2|) "\\spad{aQuartic(f,g,h,i,k)} \\undocumented")) (|aCubic| ((|#2| |#2| |#2| |#2| |#2|) "\\spad{aCubic(f,g,h,j)} \\undocumented")) (|aQuadratic| ((|#2| |#2| |#2| |#2|) "\\spad{aQuadratic(f,g,h)} \\undocumented")) (|aLinear| ((|#2| |#2| |#2|) "\\spad{aLinear(f,g)} \\undocumented")) (|quartic| (((|List| |#2|) |#2| |#2| |#2| |#2| |#2|) "\\spad{quartic(f,g,h,i,j)} \\undocumented") (((|List| |#2|) |#1|) "\\spad{quartic(u)} \\undocumented")) (|cubic| (((|List| |#2|) |#2| |#2| |#2| |#2|) "\\spad{cubic(f,g,h,i)} \\undocumented") (((|List| |#2|) |#1|) "\\spad{cubic(u)} \\undocumented")) (|quadratic| (((|List| |#2|) |#2| |#2| |#2|) "\\spad{quadratic(f,g,h)} \\undocumented") (((|List| |#2|) |#1|) "\\spad{quadratic(u)} \\undocumented")) (|linear| (((|List| |#2|) |#2| |#2|) "\\spad{linear(f,g)} \\undocumented") (((|List| |#2|) |#1|) "\\spad{linear(u)} \\undocumented")) (|mapSolve| (((|Record| (|:| |solns| (|List| |#2|)) (|:| |maps| (|List| (|Record| (|:| |arg| |#2|) (|:| |res| |#2|))))) |#1| (|Mapping| |#2| |#2|)) "\\spad{mapSolve(u,f)} \\undocumented")) (|particularSolution| ((|#2| |#1|) "\\spad{particularSolution(u)} \\undocumented")) (|solve| (((|List| |#2|) |#1|) "\\spad{solve(u)} \\undocumented"))) 
NIL 
NIL 
(|RadicalSolvePackage| R) 
((|constructor| (NIL "This package tries to find solutions expressed in terms of radicals for systems of equations of rational functions with coefficients in an integral domain \\spad{R.}")) (|contractSolve| (((|SuchThat| (|List| (|Expression| |#1|)) (|List| (|Equation| (|Expression| |#1|)))) (|Fraction| (|Polynomial| |#1|)) (|Symbol|)) "\\spad{contractSolve(rf,x)} finds the solutions expressed in terms of radicals of the equation \\spad{rf} = 0 with respect to the symbol \\spad{x,} where \\spad{rf} is a rational function. The result contains new symbols for common subexpressions in order to reduce the size of the output. \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} contractSolve(b,x)") (((|SuchThat| (|List| (|Expression| |#1|)) (|List| (|Equation| (|Expression| |#1|)))) (|Equation| (|Fraction| (|Polynomial| |#1|))) (|Symbol|)) "\\spad{contractSolve(eq,x)} finds the solutions expressed in terms of radicals of the equation of rational functions \\spad{eq} with respect to the symbol \\spad{x.} The result contains new symbols for common subexpressions in order to reduce the size of the output. \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} contractSolve(b=0,x)")) (|radicalRoots| (((|List| (|List| (|Expression| |#1|))) (|List| (|Fraction| (|Polynomial| |#1|))) (|List| (|Symbol|))) "\\spad{radicalRoots(lrf,lvar)} finds the roots expressed in terms of radicals of the list of rational functions \\spad{lrf} with respect to the list of symbols lvar. \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} c:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) \\spad{X} radicalRoots([b,c],[x,y])") (((|List| (|Expression| |#1|)) (|Fraction| (|Polynomial| |#1|)) (|Symbol|)) "\\spad{radicalRoots(rf,x)} finds the roots expressed in terms of radicals of the rational function \\spad{rf} with respect to the symbol \\spad{x.} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} radicalRoots(b,x)")) (|radicalSolve| (((|List| (|List| (|Equation| (|Expression| |#1|)))) (|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))) "\\spad{radicalSolve(leq)} finds the solutions expressed in terms of radicals of the system of equations of rational functions \\spad{leq} with respect to the unique symbol \\spad{x} appearing in leq. \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} c:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) \\spad{X} radicalSolve([b=0,c=0])") (((|List| (|List| (|Equation| (|Expression| |#1|)))) (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))) (|List| (|Symbol|))) "\\spad{radicalSolve(leq,lvar)} finds the solutions expressed in terms of radicals of the system of equations of rational functions \\spad{leq} with respect to the list of symbols lvar. \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} c:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) \\spad{X} radicalSolve([b=0,c=0],[x,y])") (((|List| (|List| (|Equation| (|Expression| |#1|)))) (|List| (|Fraction| (|Polynomial| |#1|)))) "\\spad{radicalSolve(lrf)} finds the solutions expressed in terms of radicals of the system of equations \\spad{lrf} = 0, where \\spad{lrf} is a system of univariate rational functions. \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} c:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) \\spad{X} radicalSolve([b,c])") (((|List| (|List| (|Equation| (|Expression| |#1|)))) (|List| (|Fraction| (|Polynomial| |#1|))) (|List| (|Symbol|))) "\\spad{radicalSolve(lrf,lvar)} finds the solutions expressed in terms of radicals of the system of equations \\spad{lrf} = 0 with respect to the list of symbols lvar, \\indented{1}{where \\spad{lrf} is a list of rational functions.} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} c:Fraction(Polynomial(Integer)):=(y^2+4)/(y+1) \\spad{X} radicalSolve([b,c],[x,y])") (((|List| (|Equation| (|Expression| |#1|))) (|Equation| (|Fraction| (|Polynomial| |#1|)))) "\\spad{radicalSolve(eq)} finds the solutions expressed in terms of radicals of the equation of rational functions \\spad{eq} with respect to the unique symbol \\spad{x} appearing in eq. \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} radicalSolve(b=0)") (((|List| (|Equation| (|Expression| |#1|))) (|Equation| (|Fraction| (|Polynomial| |#1|))) (|Symbol|)) "\\spad{radicalSolve(eq,x)} finds the solutions expressed in terms of radicals of the equation of rational functions \\spad{eq} with respect to the symbol \\spad{x.} \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} radicalSolve(b=0,x)") (((|List| (|Equation| (|Expression| |#1|))) (|Fraction| (|Polynomial| |#1|))) "\\spad{radicalSolve(rf)} finds the solutions expressed in terms of radicals of the equation \\spad{rf} = 0, where \\spad{rf} is a univariate rational function. \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} radicalSolve(b)") (((|List| (|Equation| (|Expression| |#1|))) (|Fraction| (|Polynomial| |#1|)) (|Symbol|)) "\\spad{radicalSolve(rf,x)} finds the solutions expressed in terms of radicals of the equation \\spad{rf} = 0 with respect to the symbol \\spad{x,} where \\spad{rf} is a rational function. \\blankline \\spad{X} b:Fraction(Polynomial(Integer)):=(3*x^3+7)/(5*x^2-13) \\spad{X} radicalSolve(b,x)"))) 
NIL 
NIL 
(|TransSolvePackageService| R) 
((|constructor| (NIL "This package finds the function \\spad{func3} where \\spad{func1} and \\spad{func2} are given and \\spad{func1} = func3(func2) . If there is no solution then function \\spad{func1} will be returned. An example would be \\spad{func1:= 8*X**3+32*X**2-14*X ::EXPR INT} and \\spad{func2:=2*X ::EXPR INT} convert them via univariate to FRAC SUP EXPR INT and then the solution is \\spad{func3:=X**3+X**2-X} of type FRAC SUP EXPR INT")) (|unvectorise| (((|Fraction| (|SparseUnivariatePolynomial| (|Expression| |#1|))) (|Vector| (|Expression| |#1|)) (|Fraction| (|SparseUnivariatePolynomial| (|Expression| |#1|))) (|Integer|)) "\\spad{unvectorise(vect, var, \\spad{n)}} returns \\spad{vect(1) + vect(2)*var + \\spad{...} + vect(n+1)*var**(n)} where \\spad{vect} is the vector of the coefficients of the polynomail ,{} \\spad{var} the new variable and \\spad{n} the degree.")) (|decomposeFunc| (((|Fraction| (|SparseUnivariatePolynomial| (|Expression| |#1|))) (|Fraction| (|SparseUnivariatePolynomial| (|Expression| |#1|))) (|Fraction| (|SparseUnivariatePolynomial| (|Expression| |#1|))) (|Fraction| (|SparseUnivariatePolynomial| (|Expression| |#1|)))) "\\spad{decomposeFunc(func1, func2, newvar)} returns a function \\spad{func3} where \\spad{func1} = func3(func2) and expresses it in the new variable newvar. If there is no solution then \\spad{func1} will be returned."))) 
NIL 
NIL 
(|TransSolvePackage| R) 
((|constructor| (NIL "This package tries to find solutions of equations of type Expression(R). This means expressions involving transcendental, exponential, logarithmic and nthRoot functions. After trying to transform different kernels to one kernel by applying several rules, it calls zerosOf for the SparseUnivariatePolynomial in the remaining kernel. For example the expression \\spad{sin(x)*cos(x)-2} will be transformed to \\spad{-2 \\spad{tan(x/2)**4} \\spad{-2} \\spad{tan(x/2)**3} \\spad{-4} \\spad{tan(x/2)**2} \\spad{+2} tan(x/2) \\spad{-2}} by using the function normalize and then to \\spad{-2 \\spad{tan(x)**2} + tan(x) \\spad{-2}} with help of subsTan. This function tries to express the given function in terms of \\spad{tan(x/2)} to express in terms of \\spad{tan(x)} . Other examples are the expressions \\spad{sqrt(x+1)+sqrt(x+7)+1} or \\spad{sqrt(sin(x))+1} .")) (|solve| (((|List| (|List| (|Equation| (|Expression| |#1|)))) (|List| (|Equation| (|Expression| |#1|))) (|List| (|Symbol|))) "\\spad{solve(leqs, lvar)} returns a list of solutions to the list of equations \\spad{leqs} with respect to the list of symbols lvar.") (((|List| (|Equation| (|Expression| |#1|))) (|Expression| |#1|) (|Symbol|)) "\\indented{1}{solve(expr,x) finds the solutions of the equation expr = 0} \\indented{1}{with respect to the symbol \\spad{x} where expr is a function} \\indented{1}{of type Expression(R).} \\blankline \\spad{X} solve(1/2*v*v*cos(theta+phi)*cos(theta+phi)+g*l*cos(phi)=g*l,phi) \\spad{X} definingPolynomial \\spad{%phi0} \\spad{X} definingPolynomial \\spad{%phi1}") (((|List| (|Equation| (|Expression| |#1|))) (|Equation| (|Expression| |#1|)) (|Symbol|)) "\\spad{solve(eq,x)} finds the solutions of the equation \\spad{eq} where \\spad{eq} is an equation of functions of type Expression(R) with respect to the symbol \\spad{x.}") (((|List| (|Equation| (|Expression| |#1|))) (|Equation| (|Expression| |#1|))) "\\spad{solve(eq)} finds the solutions of the equation \\spad{eq} where \\spad{eq} is an equation of functions of type Expression(R) with respect to the unique symbol \\spad{x} appearing in eq.") (((|List| (|Equation| (|Expression| |#1|))) (|Expression| |#1|)) "\\spad{solve(expr)} finds the solutions of the equation \\spad{expr} = 0 where \\spad{expr} is a function of type Expression(R) with respect to the unique symbol \\spad{x} appearing in eq."))) 
NIL 
NIL 
(|SortPackage| S A) 
((|constructor| (NIL "This package exports sorting algorithnms")) (|insertionSort!| ((|#2| |#2|) "\\spad{insertionSort! }\\undocumented") ((|#2| |#2| (|Mapping| (|Boolean|) |#1| |#1|)) "\\spad{insertionSort!(a,f)} \\undocumented")) (|bubbleSort!| ((|#2| |#2|) "\\spad{bubbleSort!(a)} \\undocumented") ((|#2| |#2| (|Mapping| (|Boolean|) |#1| |#1|)) "\\spad{bubbleSort!(a,f)} \\undocumented"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|OrderedSet|)))) 
(|ThreeSpace| R) 
((|constructor| (NIL "The domain ThreeSpace is used for creating three dimensional objects using functions for defining points, curves, polygons, constructs and the subspaces containing them."))) 
NIL 
NIL 
(|ThreeSpaceCategory| R) 
((|constructor| (NIL "The category ThreeSpaceCategory is used for creating three dimensional objects using functions for defining points, curves, polygons, constructs and the subspaces containing them.")) (|coerce| (((|OutputForm|) $) "\\spad{coerce(s)} returns the \\spadtype{ThreeSpace} \\spad{s} to Output format.")) (|subspace| (((|SubSpace| 3 |#1|) $) "\\spad{subspace(s)} returns the \\spadtype{SubSpace} which holds all the point information in the \\spadtype{ThreeSpace}, \\spad{s.}")) (|check| (($ $) "\\spad{check(s)} returns lllpt, list of lists of lists of point information about the \\spadtype{ThreeSpace} \\spad{s.}")) (|objects| (((|Record| (|:| |points| (|NonNegativeInteger|)) (|:| |curves| (|NonNegativeInteger|)) (|:| |polygons| (|NonNegativeInteger|)) (|:| |constructs| (|NonNegativeInteger|))) $) "\\spad{objects(s)} returns the \\spadtype{ThreeSpace}, \\spad{s,} in the form of a 3D object record containing information on the number of points, curves, polygons and constructs comprising the \\spadtype{ThreeSpace}..")) (|lprop| (((|List| (|SubSpaceComponentProperty|)) $) "\\spad{lprop(s)} checks to see if the \\spadtype{ThreeSpace}, \\spad{s,} is composed of a list of subspace component properties, and if so, returns the list; An error is signaled otherwise.")) (|llprop| (((|List| (|List| (|SubSpaceComponentProperty|))) $) "\\spad{llprop(s)} checks to see if the \\spadtype{ThreeSpace}, \\spad{s,} is composed of a list of curves which are lists of the subspace component properties of the curves, and if so, returns the list of lists; An error is signaled otherwise.")) (|lllp| (((|List| (|List| (|List| (|Point| |#1|)))) $) "\\spad{lllp(s)} checks to see if the \\spadtype{ThreeSpace}, \\spad{s,} is composed of a list of components, which are lists of curves, which are lists of points, and if so, returns the list of lists of lists; An error is signaled otherwise.")) (|lllip| (((|List| (|List| (|List| (|NonNegativeInteger|)))) $) "\\spad{lllip(s)} checks to see if the \\spadtype{ThreeSpace}, \\spad{s,} is composed of a list of components, which are lists of curves, which are lists of indices to points, and if so, returns the list of lists of lists; An error is signaled otherwise.")) (|lp| (((|List| (|Point| |#1|)) $) "\\spad{lp(s)} returns the list of points component which the \\spadtype{ThreeSpace}, \\spad{s,} contains; these points are used by reference, that is, the component holds indices referring to the points rather than the points themselves. This allows for sharing of the points.")) (|mesh?| (((|Boolean|) $) "\\spad{mesh?(s)} returns \\spad{true} if the \\spadtype{ThreeSpace} \\spad{s} is composed of one component, a mesh comprising a list of curves which are lists of points, or returns \\spad{false} if otherwise")) (|mesh| (((|List| (|List| (|Point| |#1|))) $) "\\spad{mesh(s)} checks to see if the \\spadtype{ThreeSpace}, \\spad{s,} is composed of a single surface component defined by a list curves which contain lists of points, and if so, returns the list of lists of points; An error is signaled otherwise.") (($ (|List| (|List| (|Point| |#1|))) (|Boolean|) (|Boolean|)) "\\spad{mesh([[p0],[p1],...,[pn]], close1, close2)} creates a surface defined over a list of curves, \\spad{p0} through \\spad{pn,} which are lists of points; the booleans \\spad{close1} and \\spad{close2} indicate how the surface is to be closed: \\spad{close1} set to \\spad{true} means that each individual list (a curve) is to be closed (that is, the last point of the list is to be connected to the first point); \\spad{close2} set to \\spad{true} means that the boundary at one end of the surface is to be connected to the boundary at the other end (the boundaries are defined as the first list of points (curve) and the last list of points (curve)); the \\spadtype{ThreeSpace} containing this surface is returned.") (($ (|List| (|List| (|Point| |#1|)))) "\\spad{mesh([[p0],[p1],...,[pn]])} creates a surface defined by a list of curves which are lists, \\spad{p0} through \\spad{pn,} of points, and returns a \\spadtype{ThreeSpace} whose component is the surface.") (($ $ (|List| (|List| (|List| |#1|))) (|Boolean|) (|Boolean|)) "\\spad{mesh(s, LLLR, close1, close2)} where \\spad{LLLR} is of the form [[[r10]...,[r1m]],[[r20]...,[r2m]],...,[[rn0]...,[rnm]]], adds a surface component to the \\spadtype{ThreeSpace} \\spad{s,} which is defined over a rectangular domain of size \\spad{WxH} where \\spad{W} is the number of lists of points from the domain \\spad{PointDomain(R)} and \\spad{H} is the number of elements in each of those lists; the booleans \\spad{close1} and \\spad{close2} indicate how the surface is to be closed: if \\spad{close1} is \\spad{true} this means that each individual list (a curve) is to be closed (that is, the last point of the list is to be connected to the first point); if \\spad{close2} is true, this means that the boundary at one end of the surface is to be connected to the boundary at the other end (the boundaries are defined as the first list of points (curve) and the last list of points (curve)).") (($ $ (|List| (|List| (|Point| |#1|))) (|Boolean|) (|Boolean|)) "\\spad{mesh(s, LLP, close1, close2)} where \\spad{LLP} is of the form [[p0],[p1],...,[pn]] adds a surface component to the \\spadtype{ThreeSpace}, which is defined over a list of curves, in which each of these curves is a list of points. The boolean arguments \\spad{close1} and \\spad{close2} indicate how the surface is to be closed. Argument \\spad{close1} equal \\spad{true} means that each individual list (a curve) is to be closed, that is, the last point of the list is to be connected to the first point. Argument \\spad{close2} equal \\spad{true} means that the boundary at one end of the surface is to be connected to the boundary at the other end, that is, the boundaries are defined as the first list of points (curve) and the last list of points (curve).") (($ $ (|List| (|List| (|List| |#1|))) (|List| (|SubSpaceComponentProperty|)) (|SubSpaceComponentProperty|)) "\\spad{mesh(s, LLLR, [props], prop)} where \\spad{LLLR} is of the form: [[[r10]...,[r1m]],[[r20]...,[r2m]],...,[[rn0]...,[rnm]]], adds a surface component to the \\spadtype{ThreeSpace} \\spad{s,} which is defined over a rectangular domain of size \\spad{WxH} where \\spad{W} is the number of lists of points from the domain \\spad{PointDomain(R)} and \\spad{H} is the number of elements in each of those lists; lprops is the list of the subspace component properties for each curve list, and prop is the subspace component property by which the points are defined.") (($ $ (|List| (|List| (|Point| |#1|))) (|List| (|SubSpaceComponentProperty|)) (|SubSpaceComponentProperty|)) "\\spad{mesh(s,[[p0],[p1],...,[pn]],[props],prop)} adds a surface component, defined over a list curves which contains lists of points, to the \\spadtype{ThreeSpace} \\spad{s;} props is a list which contains the subspace component properties for each surface parameter, and \\spad{prop} is the subspace component property by which the points are defined.")) (|polygon?| (((|Boolean|) $) "\\spad{polygon?(s)} returns \\spad{true} if the \\spadtype{ThreeSpace} \\spad{s} contains a single polygon component, or \\spad{false} otherwise.")) (|polygon| (((|List| (|Point| |#1|)) $) "\\spad{polygon(s)} checks to see if the \\spadtype{ThreeSpace}, \\spad{s,} is composed of a single polygon component defined by a list of points, and if so, returns the list of points; An error is signaled otherwise.") (($ (|List| (|Point| |#1|))) "\\spad{polygon([p0,p1,...,pn])} creates a polygon defined by a list of points, \\spad{p0} through \\spad{pn,} and returns a \\spadtype{ThreeSpace} whose component is the polygon.") (($ $ (|List| (|List| |#1|))) "\\spad{polygon(s,[[r0],[r1],...,[rn]])} adds a polygon component defined by a list of points \\spad{r0} through \\spad{rn}, which are lists of elements from the domain \\spad{PointDomain(m,R)} to the \\spadtype{ThreeSpace} \\spad{s,} where \\spad{m} is the dimension of the points and \\spad{R} is the \\spadtype{Ring} over which the points are defined.") (($ $ (|List| (|Point| |#1|))) "\\spad{polygon(s,[p0,p1,...,pn])} adds a polygon component defined by a list of points, \\spad{p0} throught \\spad{pn,} to the \\spadtype{ThreeSpace} \\spad{s.}")) (|closedCurve?| (((|Boolean|) $) "\\spad{closedCurve?(s)} returns \\spad{true} if the \\spadtype{ThreeSpace} \\spad{s} contains a single closed curve component, that is, the first element of the curve is also the last element, or \\spad{false} otherwise.")) (|closedCurve| (((|List| (|Point| |#1|)) $) "\\spad{closedCurve(s)} checks to see if the \\spadtype{ThreeSpace}, \\spad{s,} is composed of a single closed curve component defined by a list of points in which the first point is also the last point, all of which are from the domain \\spad{PointDomain(m,R)} and if so, returns the list of points. An error is signaled otherwise.") (($ (|List| (|Point| |#1|))) "\\spad{closedCurve(lp)} sets a list of points defined by the first element of \\spad{lp} through the last element of \\spad{lp} and back to the first elelment again and returns a \\spadtype{ThreeSpace} whose component is the closed curve defined by \\spad{lp.}") (($ $ (|List| (|List| |#1|))) "\\spad{closedCurve(s,[[lr0],[lr1],...,[lrn],[lr0]])} adds a closed curve component defined by a list of points \\spad{lr0} through \\spad{lrn}, which are lists of elements from the domain \\spad{PointDomain(m,R)}, where \\spad{R} is the \\spadtype{Ring} over which the point elements are defined and \\spad{m} is the dimension of the points, in which the last element of the list of points contains a copy of the first element list, lr0. The closed curve is added to the \\spadtype{ThreeSpace}, \\spad{s.}") (($ $ (|List| (|Point| |#1|))) "\\spad{closedCurve(s,[p0,p1,...,pn,p0])} adds a closed curve component which is a list of points defined by the first element \\spad{p0} through the last element \\spad{pn} and back to the first element \\spad{p0} again, to the \\spadtype{ThreeSpace} \\spad{s.}")) (|curve?| (((|Boolean|) $) "\\spad{curve?(s)} queries whether the \\spadtype{ThreeSpace}, \\spad{s,} is a curve, that is, has one component, a list of list of points, and returns \\spad{true} if it is, or \\spad{false} otherwise.")) (|curve| (((|List| (|Point| |#1|)) $) "\\spad{curve(s)} checks to see if the \\spadtype{ThreeSpace}, \\spad{s,} is composed of a single curve defined by a list of points and if so, returns the curve, that is, list of points. An error is signaled otherwise.") (($ (|List| (|Point| |#1|))) "\\spad{curve([p0,p1,p2,...,pn])} creates a space curve defined by the list of points \\spad{p0} through \\spad{pn}, and returns the \\spadtype{ThreeSpace} whose component is the curve.") (($ $ (|List| (|List| |#1|))) "\\spad{curve(s,[[p0],[p1],...,[pn]])} adds a space curve which is a list of points \\spad{p0} through \\spad{pn} defined by lists of elements from the domain \\spad{PointDomain(m,R)}, where \\spad{R} is the \\spadtype{Ring} over which the point elements are defined and \\spad{m} is the dimension of the points, to the \\spadtype{ThreeSpace} \\spad{s.}") (($ $ (|List| (|Point| |#1|))) "\\spad{curve(s,[p0,p1,...,pn])} adds a space curve component defined by a list of points \\spad{p0} through \\spad{pn}, to the \\spadtype{ThreeSpace} \\spad{s.}")) (|point?| (((|Boolean|) $) "\\spad{point?(s)} queries whether the \\spadtype{ThreeSpace}, \\spad{s,} is composed of a single component which is a point and returns the boolean result.")) (|point| (((|Point| |#1|) $) "\\spad{point(s)} checks to see if the \\spadtype{ThreeSpace}, \\spad{s,} is composed of only a single point and if so, returns the point. An error is signaled otherwise.") (($ (|Point| |#1|)) "\\spad{point(p)} returns a \\spadtype{ThreeSpace} object which is composed of one component, the point \\spad{p.}") (($ $ (|NonNegativeInteger|)) "\\spad{point(s,i)} adds a point component which is placed into a component list of the \\spadtype{ThreeSpace}, \\spad{s,} at the index given by i.") (($ $ (|List| |#1|)) "\\spad{point(s,[x,y,z])} adds a point component defined by a list of elements which are from the \\spad{PointDomain(R)} to the \\spadtype{ThreeSpace}, \\spad{s,} where \\spad{R} is the \\spadtype{Ring} over which the point elements are defined.") (($ $ (|Point| |#1|)) "\\spad{point(s,p)} adds a point component defined by the point, \\spad{p,} specified as a list from \\spad{List(R)}, to the \\spadtype{ThreeSpace}, \\spad{s,} where \\spad{R} is the \\spadtype{Ring} over which the point is defined.")) (|modifyPointData| (($ $ (|NonNegativeInteger|) (|Point| |#1|)) "\\spad{modifyPointData(s,i,p)} changes the point at the indexed location \\spad{i} in the \\spadtype{ThreeSpace}, \\spad{s,} to that of point \\spad{p.} This is useful for making changes to a point which has been transformed.")) (|enterPointData| (((|NonNegativeInteger|) $ (|List| (|Point| |#1|))) "\\spad{enterPointData(s,[p0,p1,...,pn])} adds a list of points from \\spad{p0} through \\spad{pn} to the \\spadtype{ThreeSpace}, \\spad{s,} and returns the index, to the starting point of the list.")) (|copy| (($ $) "\\spad{copy(s)} returns a new \\spadtype{ThreeSpace} that is an exact copy of \\spad{s.}")) (|composites| (((|List| $) $) "\\spad{composites(s)} takes the \\spadtype{ThreeSpace} \\spad{s,} and creates a list containing a unique \\spadtype{ThreeSpace} for each single composite of \\spad{s.} If \\spad{s} has no composites defined (composites need to be explicitly created), the list returned is empty. Note that not all the components need to be part of a composite.")) (|components| (((|List| $) $) "\\spad{components(s)} takes the \\spadtype{ThreeSpace} \\spad{s,} and creates a list containing a unique \\spadtype{ThreeSpace} for each single component of \\spad{s.} If \\spad{s} has no components defined, the list returned is empty.")) (|composite| (($ (|List| $)) "\\spad{composite([s1,s2,...,sn])} will create a new \\spadtype{ThreeSpace} that is a union of all the components from each \\spadtype{ThreeSpace} in the parameter list, grouped as a composite.")) (|merge| (($ $ $) "\\spad{merge(s1,s2)} will create a new \\spadtype{ThreeSpace} that has the components of \\spad{s1} and \\spad{s2}; Groupings of components into composites are maintained.") (($ (|List| $)) "\\spad{merge([s1,s2,...,sn])} will create a new \\spadtype{ThreeSpace} that has the components of all the ones in the list; Groupings of components into composites are maintained.")) (|numberOfComposites| (((|NonNegativeInteger|) $) "\\spad{numberOfComposites(s)} returns the number of supercomponents, or composites, in the \\spadtype{ThreeSpace}, \\spad{s;} Composites are arbitrary groupings of otherwise distinct and unrelated components; A \\spadtype{ThreeSpace} need not have any composites defined at all and, outside of the requirement that no component can belong to more than one composite at a time, the definition and interpretation of composites are unrestricted.")) (|numberOfComponents| (((|NonNegativeInteger|) $) "\\spad{numberOfComponents(s)} returns the number of distinct object components in the indicated \\spadtype{ThreeSpace}, \\spad{s,} such as points, curves, polygons, and constructs.")) (|create3Space| (($ (|SubSpace| 3 |#1|)) "\\spad{create3Space(s)} creates a \\spadtype{ThreeSpace} object containing objects pre-defined within some \\spadtype{SubSpace} \\spad{s.}") (($) "\\spad{create3Space()} creates a \\spadtype{ThreeSpace} object capable of holding point, curve, mesh components and any combination."))) 
NIL 
NIL 
(|SpecialOutputPackage|) 
((|constructor| (NIL "SpecialOutputPackage allows FORTRAN, Tex and Script Formula Formatter output from programs.")) (|outputAsTex| (((|Void|) (|List| (|OutputForm|))) "\\spad{outputAsTex(l)} sends (for each expression in the list \\spad{l)} output in Tex format to the destination as defined by \\spadsyscom{set output tex}.") (((|Void|) (|OutputForm|)) "\\spad{outputAsTex(o)} sends output \\spad{o} in Tex format to the destination defined by \\spadsyscom{set output tex}.")) (|outputAsScript| (((|Void|) (|List| (|OutputForm|))) "\\spad{outputAsScript(l)} sends (for each expression in the list \\spad{l)} output in Script Formula Formatter format to the destination defined. by \\spadsyscom{set output forumula}.") (((|Void|) (|OutputForm|)) "\\spad{outputAsScript(o)} sends output \\spad{o} in Script Formula Formatter format to the destination defined by \\spadsyscom{set output formula}.")) (|outputAsFortran| (((|Void|) (|List| (|OutputForm|))) "\\spad{outputAsFortran(l)} sends (for each expression in the list \\spad{l)} output in FORTRAN format to the destination defined by \\spadsyscom{set output fortran}.") (((|Void|) (|OutputForm|)) "\\spad{outputAsFortran(o)} sends output \\spad{o} in FORTRAN format.") (((|Void|) (|String|) (|OutputForm|)) "\\spad{outputAsFortran(v,o)} sends output \\spad{v} = \\spad{o} in FORTRAN format to the destination defined by \\spadsyscom{set output fortran}."))) 
NIL 
NIL 
(|SpecialFunctionCategory|) 
((|constructor| (NIL "Category for the other special functions.")) (|airyBi| (($ $) "\\spad{airyBi(x)} is the Airy function \\spad{Bi(x)}.")) (|airyAi| (($ $) "\\spad{airyAi(x)} is the Airy function \\spad{Ai(x)}.")) (|besselK| (($ $ $) "\\spad{besselK(v,z)} is the modified Bessel function of the second kind.")) (|besselI| (($ $ $) "\\spad{besselI(v,z)} is the modified Bessel function of the first kind.")) (|besselY| (($ $ $) "\\spad{besselY(v,z)} is the Bessel function of the second kind.")) (|besselJ| (($ $ $) "\\spad{besselJ(v,z)} is the Bessel function of the first kind.")) (|polygamma| (($ $ $) "\\spad{polygamma(k,x)} is the \\spad{k-th} derivative of \\spad{digamma(x)}, (often written \\spad{psi(k,x)} in the literature).")) (|digamma| (($ $) "\\spad{digamma(x)} is the logarithmic derivative of \\spad{Gamma(x)} (often written \\spad{psi(x)} in the literature).")) (|Beta| (($ $ $) "\\spad{Beta(x,y)} is \\spad{Gamma(x) * Gamma(y)/Gamma(x+y)}.")) (|Gamma| (($ $ $) "\\spad{Gamma(a,x)} is the incomplete Gamma function.") (($ $) "\\spad{Gamma(x)} is the Euler Gamma function.")) (|abs| (($ $) "\\spad{abs(x)} returns the absolute value of \\spad{x.}"))) 
NIL 
NIL 
(|SplittingNode| V C) 
((|constructor| (NIL "This domain exports a modest implementation for the vertices of splitting trees. These vertices are called here splitting nodes. Every of these nodes store 3 informations. The first one is its value, that is the current expression to evaluate. The second one is its condition, that is the hypothesis under which the value has to be evaluated. The last one is its status, that is a boolean flag which is \\spad{true} iff the value is the result of its evaluation under its condition. Two splitting vertices are equal iff they have the sane values and the same conditions (so their status do not matter).")) (|subNode?| (((|Boolean|) $ $ (|Mapping| (|Boolean|) |#2| |#2|)) "\\axiom{subNode?(n1,n2,o2)} returns \\spad{true} iff \\axiom{value(n1) = value(n2)} and \\axiom{o2(condition(n1),condition(n2))}")) (|infLex?| (((|Boolean|) $ $ (|Mapping| (|Boolean|) |#1| |#1|) (|Mapping| (|Boolean|) |#2| |#2|)) "\\axiom{infLex?(n1,n2,o1,o2)} returns \\spad{true} iff \\axiom{o1(value(n1),value(n2))} or \\axiom{value(n1) = value(n2)} and \\axiom{o2(condition(n1),condition(n2))}.")) (|setEmpty!| (($ $) "\\axiom{setEmpty!(n)} replaces \\spad{n} by \\axiom{empty()$\\%}.")) (|setStatus!| (($ $ (|Boolean|)) "\\axiom{setStatus!(n,b)} returns \\spad{n} whose status has been replaced by \\spad{b} if it is not empty, else an error is produced.")) (|setCondition!| (($ $ |#2|) "\\axiom{setCondition!(n,t)} returns \\spad{n} whose condition has been replaced by \\spad{t} if it is not empty, else an error is produced.")) (|setValue!| (($ $ |#1|) "\\axiom{setValue!(n,v)} returns \\spad{n} whose value has been replaced by \\spad{v} if it is not empty, else an error is produced.")) (|copy| (($ $) "\\axiom{copy(n)} returns a copy of \\spad{n.}")) (|construct| (((|List| $) |#1| (|List| |#2|)) "\\axiom{construct(v,lt)} returns the same as \\axiom{[construct(v,t) for \\spad{t} in lt]}") (((|List| $) (|List| (|Record| (|:| |val| |#1|) (|:| |tower| |#2|)))) "\\axiom{construct(lvt)} returns the same as \\axiom{[construct(vt.val,vt.tower) for \\spad{vt} in lvt]}") (($ (|Record| (|:| |val| |#1|) (|:| |tower| |#2|))) "\\axiom{construct(vt)} returns the same as \\axiom{construct(vt.val,vt.tower)}") (($ |#1| |#2|) "\\axiom{construct(v,t)} returns the same as \\axiom{construct(v,t,false)}") (($ |#1| |#2| (|Boolean|)) "\\axiom{construct(v,t,b)} returns the non-empty node with value \\spad{v,} condition \\spad{t} and flag \\spad{b}")) (|status| (((|Boolean|) $) "\\axiom{status(n)} returns the status of the node \\spad{n.}")) (|condition| ((|#2| $) "\\axiom{condition(n)} returns the condition of the node \\spad{n.}")) (|value| ((|#1| $) "\\axiom{value(n)} returns the value of the node \\spad{n.}")) (|empty?| (((|Boolean|) $) "\\axiom{empty?(n)} returns \\spad{true} iff the node \\spad{n} is \\axiom{empty()$\\%}.")) (|empty| (($) "\\axiom{empty()} returns the same as \\axiom{[empty()$V,empty()$C,false]$\\%}"))) 
NIL 
NIL 
(|SplittingTree| V C) 
((|constructor| (NIL "This domain exports a modest implementation of splitting trees. Spliiting trees are needed when the evaluation of some quantity under some hypothesis requires to split the hypothesis into sub-cases. For instance by adding some new hypothesis on one hand and its negation on another hand. The computations are terminated is a splitting tree \\axiom{a} when \\axiom{status(value(a))} is \\axiom{true}. Thus, if for the splitting tree \\axiom{a} the flag \\axiom{status(value(a))} is \\axiom{true}, then \\axiom{status(value(d))} is \\axiom{true} for any subtree \\axiom{d} of \\axiom{a}. This property of splitting trees is called the termination condition. If no vertex in a splitting tree \\axiom{a} is equal to another, \\axiom{a} is said to satisfy the no-duplicates condition. The splitting tree \\axiom{a} will satisfy this condition if nodes are added to \\axiom{a} by mean of \\axiom{splitNodeOf!} and if \\axiom{construct} is only used to create the root of \\axiom{a} with no children.")) (|splitNodeOf!| (($ $ $ (|List| (|SplittingNode| |#1| |#2|)) (|Mapping| (|Boolean|) |#2| |#2|)) "\\axiom{splitNodeOf!(l,a,ls,sub?)} returns \\axiom{a} where the children list of \\axiom{l} has been set to \\axiom{[[s]$% for \\spad{s} in \\spad{ls} | not subNodeOf?(s,a,sub?)]}. Thus, if \\axiom{l} is not a node of \\axiom{a}, this latter splitting tree is unchanged.") (($ $ $ (|List| (|SplittingNode| |#1| |#2|))) "\\axiom{splitNodeOf!(l,a,ls)} returns \\axiom{a} where the children list of \\axiom{l} has been set to \\axiom{[[s]$% for \\spad{s} in \\spad{ls} | not nodeOf?(s,a)]}. Thus, if \\axiom{l} is not a node of \\axiom{a}, this latter splitting tree is unchanged.")) (|remove!| (($ (|SplittingNode| |#1| |#2|) $) "\\axiom{remove!(s,a)} replaces a by remove(s,a)")) (|remove| (($ (|SplittingNode| |#1| |#2|) $) "\\axiom{remove(s,a)} returns the splitting tree obtained from a by removing every sub-tree \\axiom{b} such that \\axiom{value(b)} and \\axiom{s} have the same value, condition and status.")) (|subNodeOf?| (((|Boolean|) (|SplittingNode| |#1| |#2|) $ (|Mapping| (|Boolean|) |#2| |#2|)) "\\axiom{subNodeOf?(s,a,sub?)} returns \\spad{true} iff for some node \\axiom{n} in \\axiom{a} we have \\axiom{s = \\spad{n}} or \\axiom{status(n)} and \\axiom{subNode?(s,n,sub?)}.")) (|nodeOf?| (((|Boolean|) (|SplittingNode| |#1| |#2|) $) "\\axiom{nodeOf?(s,a)} returns \\spad{true} iff some node of \\axiom{a} is equal to \\axiom{s}")) (|result| (((|List| (|Record| (|:| |val| |#1|) (|:| |tower| |#2|))) $) "\\axiom{result(a)} where \\axiom{ls} is the leaves list of \\axiom{a} returns \\axiom{[[value(s),condition(s)]$VT for \\spad{s} in ls]} if the computations are terminated in \\axiom{a} else an error is produced.")) (|conditions| (((|List| |#2|) $) "\\axiom{conditions(a)} returns the list of the conditions of the leaves of a")) (|construct| (($ |#1| |#2| |#1| (|List| |#2|)) "\\axiom{construct(v1,t,v2,lt)} creates a splitting tree with value (\\spadignore{i.e.} root vertex) given by \\axiom{[v,t]$S} and with children list given by \\axiom{[[[v,t]$S]$% for \\spad{s} in ls]}.") (($ |#1| |#2| (|List| (|SplittingNode| |#1| |#2|))) "\\axiom{construct(v,t,ls)} creates a splitting tree with value (\\spadignore{i.e.} root vertex) given by \\axiom{[v,t]$S} and with children list given by \\axiom{[[s]$% for \\spad{s} in ls]}.") (($ |#1| |#2| (|List| $)) "\\axiom{construct(v,t,la)} creates a splitting tree with value (\\spadignore{i.e.} root vertex) given by \\axiom{[v,t]$S} and with \\axiom{la} as children list.") (($ (|SplittingNode| |#1| |#2|)) "\\axiom{construct(s)} creates a splitting tree with value (\\spadignore{i.e.} root vertex) given by \\axiom{s} and no children. Thus, if the status of \\axiom{s} is false, \\axiom{[s]} represents the starting point of the evaluation \\axiom{value(s)} under the hypothesis \\axiom{condition(s)}.")) (|updateStatus!| (($ $) "\\axiom{updateStatus!(a)} returns a where the status of the vertices are updated to satisfy the \"termination condition\".")) (|extractSplittingLeaf| (((|Union| $ "failed") $) "\\axiom{extractSplittingLeaf(a)} returns the left most leaf (as a tree) whose status is \\spad{false} if any, else \"failed\" is returned."))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|SplittingNode| |#1| |#2|) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|SplittingNode| |#1| |#2|) (LIST (QUOTE |Evalable|) (LIST (QUOTE |SplittingNode|) (|devaluate| |#1|) (|devaluate| |#2|)))) (|HasCategory| (|SplittingNode| |#1| |#2|) (QUOTE (|SetCategory|))))) 
(|SquareMatrix| |ndim| R) 
((|constructor| (NIL "\\spadtype{SquareMatrix} is a matrix domain of square matrices, where the number of rows \\spad{(=} number of columns) is a parameter of the type.")) (|unitsKnown| ((|attribute|) "the invertible matrices are simply the matrices whose determinants are units in the Ring \\spad{R.}")) (|central| ((|attribute|) "the elements of the Ring \\spad{R,} viewed as diagonal matrices, commute with all matrices and, indeed, are the only matrices which commute with all matrices.")) (|coerce| (((|Matrix| |#2|) $) "\\spad{coerce(m)} converts a matrix of type \\spadtype{SquareMatrix} to a matrix of type \\spadtype{Matrix}.")) (|squareMatrix| (($ (|Matrix| |#2|)) "\\spad{squareMatrix(m)} converts a matrix of type \\spadtype{Matrix} to a matrix of type \\spadtype{SquareMatrix}.")) (|transpose| (($ $) "\\spad{transpose(m)} returns the transpose of the matrix \\spad{m.}"))) 
((|unitsKnown| . T) (|central| |has| |#2| (ATTRIBUTE (|commutative| "*"))) (|finiteAggregate| . T) (|rightUnitary| . T) (|leftUnitary| . T)) 
((|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasAttribute| |#2| (QUOTE (|commutative| "*"))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (QUOTE (|EuclideanDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))) (|HasCategory| |#2| (QUOTE (|Field|))) (OR (|HasAttribute| |#2| (QUOTE (|commutative| "*"))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|))))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))) 
(|StringAggregate&| S) 
((|constructor| (NIL "A string aggregate is a category for strings, that is, one dimensional arrays of characters.")) (|elt| (($ $ $) "\\spad{elt(s,t)} returns the concatenation of \\spad{s} and \\spad{t.} It is provided to allow juxtaposition of strings to work as concatenation. For example, \\axiom{\"smoo\" \"shed\"} returns \\axiom{\"smooshed\"}.")) (|rightTrim| (($ $ (|CharacterClass|)) "\\spad{rightTrim(s,cc)} returns \\spad{s} with all trailing occurences of characters in \\spad{cc} deleted. For example, \\axiom{rightTrim(\"(abc)\", charClass \"()\")} returns \\axiom{\"(abc\"}.") (($ $ (|Character|)) "\\spad{rightTrim(s,c)} returns \\spad{s} with all trailing occurrences of \\spad{c} deleted. For example, \\axiom{rightTrim(\" abc \\spad{\",} char \" \\spad{\")}} returns \\axiom{\" abc\"}.")) (|leftTrim| (($ $ (|CharacterClass|)) "\\spad{leftTrim(s,cc)} returns \\spad{s} with all leading characters in \\spad{cc} deleted. For example, \\axiom{leftTrim(\"(abc)\", charClass \"()\")} returns \\axiom{\"abc)\"}.") (($ $ (|Character|)) "\\spad{leftTrim(s,c)} returns \\spad{s} with all leading characters \\spad{c} deleted. For example, \\axiom{leftTrim(\" abc \\spad{\",} char \" \\spad{\")}} returns \\axiom{\"abc \\spad{\"}.}")) (|trim| (($ $ (|CharacterClass|)) "\\spad{trim(s,cc)} returns \\spad{s} with all characters in \\spad{cc} deleted from right and left ends. For example, \\axiom{trim(\"(abc)\", charClass \"()\")} returns \\axiom{\"abc\"}.") (($ $ (|Character|)) "\\spad{trim(s,c)} returns \\spad{s} with all characters \\spad{c} deleted from right and left ends. For example, \\axiom{trim(\" abc \\spad{\",} char \" \\spad{\")}} returns \\axiom{\"abc\"}.")) (|split| (((|List| $) $ (|CharacterClass|)) "\\spad{split(s,cc)} returns a list of substrings delimited by characters in \\spad{cc.}") (((|List| $) $ (|Character|)) "\\spad{split(s,c)} returns a list of substrings delimited by character \\spad{c.}")) (|coerce| (($ (|Character|)) "\\spad{coerce(c)} returns \\spad{c} as a string \\spad{s} with the character \\spad{c.}")) (|position| (((|Integer|) (|CharacterClass|) $ (|Integer|)) "\\spad{position(cc,t,i)} returns the position \\axiom{j \\spad{>=} i} in \\spad{t} of the first character belonging to \\spad{cc.}") (((|Integer|) $ $ (|Integer|)) "\\spad{position(s,t,i)} returns the position \\spad{j} of the substring \\spad{s} in string \\spad{t,} where \\axiom{j \\spad{>=} i} is required.")) (|replace| (($ $ (|UniversalSegment| (|Integer|)) $) "\\spad{replace(s,i..j,t)} replaces the substring \\axiom{s(i..j)} of \\spad{s} by string \\spad{t.}")) (|match?| (((|Boolean|) $ $ (|Character|)) "\\spad{match?(s,t,c)} tests if \\spad{s} matches \\spad{t} except perhaps for multiple and consecutive occurrences of character \\spad{c.} Typically \\spad{c} is the blank character.")) (|match| (((|NonNegativeInteger|) $ $ (|Character|)) "\\spad{match(p,s,wc)} tests if pattern \\axiom{p} matches subject \\axiom{s} where \\axiom{wc} is a wild card character. If no match occurs, the index \\axiom{0} is returned; otheriwse, the value returned is the first index of the first character in the subject matching the subject (excluding that matched by an initial wild-card). For example, \\axiom{match(\"*to*\",\"yorktown\",\"*\")} returns \\axiom{5} indicating a successful match starting at index \\axiom{5} of \\axiom{\"yorktown\"}.")) (|substring?| (((|Boolean|) $ $ (|Integer|)) "\\spad{substring?(s,t,i)} tests if \\spad{s} is a substring of \\spad{t} beginning at index i. Note that \\axiom{substring?(s,t,0) = prefix?(s,t)}.")) (|suffix?| (((|Boolean|) $ $) "\\spad{suffix?(s,t)} tests if the string \\spad{s} is the final substring of \\spad{t.} Note that \\axiom{suffix?(s,t) \\spad{==} \\indented{1}{reduce(and,[s.i = t.(n - \\spad{m} + i) for \\spad{i} in 0..maxIndex s])}} where \\spad{m} and \\spad{n} denote the maxIndex of \\spad{s} and \\spad{t} respectively.")) (|prefix?| (((|Boolean|) $ $) "\\spad{prefix?(s,t)} tests if the string \\spad{s} is the initial substring of \\spad{t.} Note that \\axiom{prefix?(s,t) \\spad{==} \\indented{2}{reduce(and,[s.i = t.i for \\spad{i} in 0..maxIndex s])}.}")) (|upperCase!| (($ $) "\\spad{upperCase!(s)} destructively replaces the alphabetic characters in \\spad{s} by upper case characters.")) (|upperCase| (($ $) "\\spad{upperCase(s)} returns the string with all characters in upper case.")) (|lowerCase!| (($ $) "\\spad{lowerCase!(s)} destructively replaces the alphabetic characters in \\spad{s} by lower case.")) (|lowerCase| (($ $) "\\spad{lowerCase(s)} returns the string with all characters in lower case."))) 
NIL 
NIL 
(|StringAggregate|) 
((|constructor| (NIL "A string aggregate is a category for strings, that is, one dimensional arrays of characters.")) (|elt| (($ $ $) "\\spad{elt(s,t)} returns the concatenation of \\spad{s} and \\spad{t.} It is provided to allow juxtaposition of strings to work as concatenation. For example, \\axiom{\"smoo\" \"shed\"} returns \\axiom{\"smooshed\"}.")) (|rightTrim| (($ $ (|CharacterClass|)) "\\spad{rightTrim(s,cc)} returns \\spad{s} with all trailing occurences of characters in \\spad{cc} deleted. For example, \\axiom{rightTrim(\"(abc)\", charClass \"()\")} returns \\axiom{\"(abc\"}.") (($ $ (|Character|)) "\\spad{rightTrim(s,c)} returns \\spad{s} with all trailing occurrences of \\spad{c} deleted. For example, \\axiom{rightTrim(\" abc \\spad{\",} char \" \\spad{\")}} returns \\axiom{\" abc\"}.")) (|leftTrim| (($ $ (|CharacterClass|)) "\\spad{leftTrim(s,cc)} returns \\spad{s} with all leading characters in \\spad{cc} deleted. For example, \\axiom{leftTrim(\"(abc)\", charClass \"()\")} returns \\axiom{\"abc)\"}.") (($ $ (|Character|)) "\\spad{leftTrim(s,c)} returns \\spad{s} with all leading characters \\spad{c} deleted. For example, \\axiom{leftTrim(\" abc \\spad{\",} char \" \\spad{\")}} returns \\axiom{\"abc \\spad{\"}.}")) (|trim| (($ $ (|CharacterClass|)) "\\spad{trim(s,cc)} returns \\spad{s} with all characters in \\spad{cc} deleted from right and left ends. For example, \\axiom{trim(\"(abc)\", charClass \"()\")} returns \\axiom{\"abc\"}.") (($ $ (|Character|)) "\\spad{trim(s,c)} returns \\spad{s} with all characters \\spad{c} deleted from right and left ends. For example, \\axiom{trim(\" abc \\spad{\",} char \" \\spad{\")}} returns \\axiom{\"abc\"}.")) (|split| (((|List| $) $ (|CharacterClass|)) "\\spad{split(s,cc)} returns a list of substrings delimited by characters in \\spad{cc.}") (((|List| $) $ (|Character|)) "\\spad{split(s,c)} returns a list of substrings delimited by character \\spad{c.}")) (|coerce| (($ (|Character|)) "\\spad{coerce(c)} returns \\spad{c} as a string \\spad{s} with the character \\spad{c.}")) (|position| (((|Integer|) (|CharacterClass|) $ (|Integer|)) "\\spad{position(cc,t,i)} returns the position \\axiom{j \\spad{>=} i} in \\spad{t} of the first character belonging to \\spad{cc.}") (((|Integer|) $ $ (|Integer|)) "\\spad{position(s,t,i)} returns the position \\spad{j} of the substring \\spad{s} in string \\spad{t,} where \\axiom{j \\spad{>=} i} is required.")) (|replace| (($ $ (|UniversalSegment| (|Integer|)) $) "\\spad{replace(s,i..j,t)} replaces the substring \\axiom{s(i..j)} of \\spad{s} by string \\spad{t.}")) (|match?| (((|Boolean|) $ $ (|Character|)) "\\spad{match?(s,t,c)} tests if \\spad{s} matches \\spad{t} except perhaps for multiple and consecutive occurrences of character \\spad{c.} Typically \\spad{c} is the blank character.")) (|match| (((|NonNegativeInteger|) $ $ (|Character|)) "\\spad{match(p,s,wc)} tests if pattern \\axiom{p} matches subject \\axiom{s} where \\axiom{wc} is a wild card character. If no match occurs, the index \\axiom{0} is returned; otheriwse, the value returned is the first index of the first character in the subject matching the subject (excluding that matched by an initial wild-card). For example, \\axiom{match(\"*to*\",\"yorktown\",\"*\")} returns \\axiom{5} indicating a successful match starting at index \\axiom{5} of \\axiom{\"yorktown\"}.")) (|substring?| (((|Boolean|) $ $ (|Integer|)) "\\spad{substring?(s,t,i)} tests if \\spad{s} is a substring of \\spad{t} beginning at index i. Note that \\axiom{substring?(s,t,0) = prefix?(s,t)}.")) (|suffix?| (((|Boolean|) $ $) "\\spad{suffix?(s,t)} tests if the string \\spad{s} is the final substring of \\spad{t.} Note that \\axiom{suffix?(s,t) \\spad{==} \\indented{1}{reduce(and,[s.i = t.(n - \\spad{m} + i) for \\spad{i} in 0..maxIndex s])}} where \\spad{m} and \\spad{n} denote the maxIndex of \\spad{s} and \\spad{t} respectively.")) (|prefix?| (((|Boolean|) $ $) "\\spad{prefix?(s,t)} tests if the string \\spad{s} is the initial substring of \\spad{t.} Note that \\axiom{prefix?(s,t) \\spad{==} \\indented{2}{reduce(and,[s.i = t.i for \\spad{i} in 0..maxIndex s])}.}")) (|upperCase!| (($ $) "\\spad{upperCase!(s)} destructively replaces the alphabetic characters in \\spad{s} by upper case characters.")) (|upperCase| (($ $) "\\spad{upperCase(s)} returns the string with all characters in upper case.")) (|lowerCase!| (($ $) "\\spad{lowerCase!(s)} destructively replaces the alphabetic characters in \\spad{s} by lower case.")) (|lowerCase| (($ $) "\\spad{lowerCase(s)} returns the string with all characters in lower case."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|SquareFreeRegularSetDecompositionPackage| R E V P TS) 
((|constructor| (NIL "A package providing a new algorithm for solving polynomial systems by means of regular chains. Two ways of solving are provided: in the sense of Zariski closure (like in Kalkbrener's algorithm) or in the sense of the regular zeros (like in Wu, Wang or Lazard- Moreno methods). This algorithm is valid for any type of regular set. It does not care about the way a polynomial is added in an regular set, or how two quasi-components are compared (by an inclusion-test), or how the invertibility test is made in the tower of simple extensions associated with a regular set. These operations are realized respectively by the domain \\spad{TS} and the packages \\spad{QCMPPK(R,E,V,P,TS)} and \\spad{RSETGCD(R,E,V,P,TS)}. The same way it does not care about the way univariate polynomial gcds (with coefficients in the tower of simple extensions associated with a regular set) are computed. The only requirement is that these gcds need to have invertible initials (normalized or not). WARNING. There is no need for a user to call directly any operation of this package since they can be accessed by the domain \\axiomType{TS}. Thus, the operations of this package are not documented."))) 
NIL 
NIL 
(|SquareFreeRegularTriangularSet| R E V P) 
((|constructor| (NIL "This domain provides an implementation of square-free regular chains. Moreover, the operation zeroSetSplit is an implementation of a new algorithm for solving polynomial systems by means of regular chains.")) (|preprocess| (((|Record| (|:| |val| (|List| |#4|)) (|:| |towers| (|List| $))) (|List| |#4|) (|Boolean|) (|Boolean|)) "\\axiom{pre_process(lp,b1,b2)} is an internal subroutine, exported only for developement.")) (|internalZeroSetSplit| (((|List| $) (|List| |#4|) (|Boolean|) (|Boolean|) (|Boolean|)) "\\axiom{internalZeroSetSplit(lp,b1,b2,b3)} is an internal subroutine, exported only for developement.")) (|zeroSetSplit| (((|List| $) (|List| |#4|) (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|)) "\\axiom{zeroSetSplit(lp,b1,b2.b3,b4)} is an internal subroutine, exported only for developement.") (((|List| $) (|List| |#4|) (|Boolean|) (|Boolean|)) "\\axiom{zeroSetSplit(lp,clos?,info?)} has the same specifications as zeroSetSplit from RegularTriangularSetCategory from \\spadtype{RegularTriangularSetCategory} Moreover, if clos? then solves in the sense of the Zariski closure else solves in the sense of the regular zeros. If \\axiom{info?} then do print messages during the computations.")) (|internalAugment| (((|List| $) |#4| $ (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|) (|Boolean|)) "\\axiom{internalAugment(p,ts,b1,b2,b3,b4,b5)} is an internal subroutine, exported only for developement."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#4| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#4| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#3| (QUOTE (|Finite|)))) 
(|Stack| S) 
((|constructor| (NIL "Linked List implementation of a Stack")) (|member?| (((|Boolean|) |#1| $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} member?(3,a)")) (|members| (((|List| |#1|) $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} members a")) (|parts| (((|List| |#1|) $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} parts a")) (|#| (((|NonNegativeInteger|) $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} \\#a")) (|count| (((|NonNegativeInteger|) |#1| $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} count(4,a)") (((|NonNegativeInteger|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} count(x+->(x>2),a)")) (|any?| (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} any?(x+->(x=4),a)")) (|every?| (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} every?(x+->(x=4),a)")) (~= (((|Boolean|) $ $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} b:=copy a \\spad{X} (a~=b)")) (= (((|Boolean|) $ $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} b:Stack INT:= stack [1,2,3,4,5] \\spad{X} (a=b)@Boolean")) (|coerce| (((|OutputForm|) $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} coerce a")) (|hash| (((|SingleInteger|) $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} hash a")) (|latex| (((|String|) $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} latex a")) (|map!| (($ (|Mapping| |#1| |#1|) $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} map!(x+->x+10,a) \\spad{X} a")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} map(x+->x+10,a) \\spad{X} a")) (|eq?| (((|Boolean|) $ $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} b:=copy a \\spad{X} eq?(a,b)")) (|copy| (($ $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} copy a")) (|sample| (($) "\\blankline \\spad{X} sample()$Stack(INT)")) (|empty| (($) "\\blankline \\spad{X} b:=empty()$(Stack INT)")) (|empty?| (((|Boolean|) $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} empty? a")) (|bag| (($ (|List| |#1|)) "\\blankline \\spad{X} bag([1,2,3,4,5])$Stack(INT)")) (|size?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} size?(a,5)")) (|more?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} more?(a,9)")) (|less?| (((|Boolean|) $ (|NonNegativeInteger|)) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} less?(a,9)")) (|depth| (((|NonNegativeInteger|) $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} depth a")) (|top| ((|#1| $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} top a")) (|inspect| ((|#1| $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} inspect a")) (|insert!| (($ |#1| $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} insert!(8,a) \\spad{X} a")) (|push!| ((|#1| |#1| $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} push!(9,a) \\spad{X} a")) (|extract!| ((|#1| $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} extract! a \\spad{X} a")) (|pop!| ((|#1| $) "\\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5] \\spad{X} pop! a \\spad{X} a")) (|stack| (($ (|List| |#1|)) "\\indented{1}{stack([x,y,...,z]) creates a stack with first (top)} \\indented{1}{element \\spad{x,} second element y,...,and last element \\spad{z.}} \\blankline \\spad{X} a:Stack INT:= stack [1,2,3,4,5]"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|StreamAggregate&| A S) 
((|constructor| (NIL "A stream aggregate is a linear aggregate which possibly has an infinite number of elements. A basic domain constructor which builds stream aggregates is \\spadtype{Stream}. From streams, a number of infinite structures such power series can be built. A stream aggregate may also be infinite since it may be cyclic. For example, see \\spadtype{DecimalExpansion}.")) (|possiblyInfinite?| (((|Boolean|) $) "\\spad{possiblyInfinite?(s)} tests if the stream \\spad{s} could possibly have an infinite number of elements. Note that for many datatypes, \\axiom{possiblyInfinite?(s) = not explictlyFinite?(s)}.")) (|explicitlyFinite?| (((|Boolean|) $) "\\spad{explicitlyFinite?(s)} tests if the stream has a finite number of elements, and \\spad{false} otherwise. Note that for many datatypes, \\axiom{explicitlyFinite?(s) = not possiblyInfinite?(s)}."))) 
NIL 
NIL 
(|StreamAggregate| S) 
((|constructor| (NIL "A stream aggregate is a linear aggregate which possibly has an infinite number of elements. A basic domain constructor which builds stream aggregates is \\spadtype{Stream}. From streams, a number of infinite structures such power series can be built. A stream aggregate may also be infinite since it may be cyclic. For example, see \\spadtype{DecimalExpansion}.")) (|possiblyInfinite?| (((|Boolean|) $) "\\spad{possiblyInfinite?(s)} tests if the stream \\spad{s} could possibly have an infinite number of elements. Note that for many datatypes, \\axiom{possiblyInfinite?(s) = not explictlyFinite?(s)}.")) (|explicitlyFinite?| (((|Boolean|) $) "\\spad{explicitlyFinite?(s)} tests if the stream has a finite number of elements, and \\spad{false} otherwise. Note that for many datatypes, \\axiom{explicitlyFinite?(s) = not possiblyInfinite?(s)}."))) 
((|nil| . T)) 
NIL 
(|SparseTable| |Key| |Ent| |dent|) 
((|constructor| (NIL "A sparse table has a default entry, which is returned if no other value has been explicitly stored for a key."))) 
((|shallowlyMutable| . T)) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (|devaluate| |#1|)) (LIST (QUOTE |:|) (QUOTE |entry|) (|devaluate| |#2|))))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|)))) (OR (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) 
(|StepThrough|) 
((|constructor| (NIL "A class of objects which can be 'stepped through'. Repeated applications of \\spadfun{nextItem} is guaranteed never to return duplicate items and only return \"failed\" after exhausting all elements of the domain. This assumes that the sequence starts with \\spad{init()}. For infinite domains, repeated application of \\spadfun{nextItem} is not required to reach all possible domain elements starting from any initial element. \\blankline Conditional attributes\\br \\tab{5}infinite\\tab{5}repeated nextItem's are never \"failed\".")) (|nextItem| (((|Union| $ "failed") $) "\\spad{nextItem(x)} returns the next item, or \"failed\" if domain is exhausted.")) (|init| (($) "\\spad{init()} chooses an initial object for stepping."))) 
NIL 
NIL 
(|StreamInfiniteProduct| |Coef|) 
((|constructor| (NIL "This package computes infinite products of Taylor series over an integral domain of characteristic 0. Here Taylor series are represented by streams of Taylor coefficients.")) (|generalInfiniteProduct| (((|Stream| |#1|) (|Stream| |#1|) (|Integer|) (|Integer|)) "\\spad{generalInfiniteProduct(f(x),a,d)} computes \\spad{product(n=a,a+d,a+2*d,...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1.")) (|oddInfiniteProduct| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{oddInfiniteProduct(f(x))} computes \\spad{product(n=1,3,5...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1.")) (|evenInfiniteProduct| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{evenInfiniteProduct(f(x))} computes \\spad{product(n=2,4,6...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1.")) (|infiniteProduct| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{infiniteProduct(f(x))} computes \\spad{product(n=1,2,3...,f(x**n))}. The series \\spad{f(x)} should have constant coefficient 1."))) 
NIL 
NIL 
(|StreamTensor| R) 
((|constructor| (NIL "This package has no description")) (|tensorMap| (((|Stream| |#1|) (|Stream| |#1|) (|Mapping| (|List| |#1|) |#1|)) "\\spad{tensorMap([s1, \\spad{s2,} ...], \\spad{f)}} returns the stream consisting of all elements of f(s1) followed by all elements of f(s2) and so on."))) 
NIL 
NIL 
(|StreamFunctions1| S) 
((|constructor| (NIL "Functions defined on streams with entries in one set.")) (|concat| (((|Stream| |#1|) (|Stream| (|Stream| |#1|))) "\\indented{1}{concat(u) returns the left-to-right concatentation of the} \\indented{1}{streams in u. Note that \\spad{concat(u) = reduce(concat,u)}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 10..] \\spad{X} n:=[j for \\spad{j} in 1.. | prime? \\spad{j]} \\spad{X} p:=[m,n]::Stream(Stream(PositiveInteger)) \\spad{X} concat(p)"))) 
NIL 
NIL 
(|StreamFunctions2| A B) 
((|constructor| (NIL "Functions defined on streams with entries in two sets.")) (|reduce| ((|#2| |#2| (|Mapping| |#2| |#1| |#2|) (|Stream| |#1|)) "\\indented{1}{reduce(b,f,u), where \\spad{u} is a finite stream \\spad{[x0,x1,...,xn]},} \\indented{1}{returns the value \\spad{r(n)} computed as follows:} \\indented{1}{\\spad{r0 = f(x0,b),} \\indented{1}{r1 = f(x1,r0),...,} \\indented{1}{r(n) = f(xn,r(n-1))}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..300]::Stream(Integer) \\spad{X} f(i:Integer,j:Integer):Integer==i+j \\spad{X} reduce(1,f,m)")) (|scan| (((|Stream| |#2|) |#2| (|Mapping| |#2| |#1| |#2|) (|Stream| |#1|)) "\\indented{1}{scan(b,h,[x0,x1,x2,...]) returns \\spad{[y0,y1,y2,...]}, where} \\indented{1}{\\spad{y0 = h(x0,b)},} \\indented{1}{\\spad{y1 = h(x1,y0)},\\spad{...}} \\indented{1}{\\spad{yn = h(xn,y(n-1))}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..]::Stream(Integer) \\spad{X} f(i:Integer,j:Integer):Integer==i+j \\spad{X} scan(1,f,m)")) (|map| (((|Stream| |#2|) (|Mapping| |#2| |#1|) (|Stream| |#1|)) "\\indented{1}{map(f,s) returns a stream whose elements are the function \\spad{f} applied} \\indented{1}{to the corresponding elements of \\spad{s.}} \\indented{1}{Note that \\spad{map(f,[x0,x1,x2,...]) = [f(x0),f(x1),f(x2),..]}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} \\spad{f(i:PositiveInteger):PositiveInteger==i**2} \\spad{X} map(f,m)"))) 
NIL 
NIL 
(|StreamFunctions3| A B C) 
((|constructor| (NIL "Functions defined on streams with entries in three sets.")) (|map| (((|Stream| |#3|) (|Mapping| |#3| |#1| |#2|) (|Stream| |#1|) (|Stream| |#2|)) "\\indented{1}{map(f,st1,st2) returns the stream whose elements are the} \\indented{1}{function \\spad{f} applied to the corresponding elements of \\spad{st1} and st2.} \\indented{1}{\\spad{map(f,[x0,x1,x2,..],[y0,y1,y2,..]) = [f(x0,y0),f(x1,y1),..]}.} \\blankline \\spad{S} \\spad{X} m:=[i for \\spad{i} in 1..]::Stream(Integer) \\spad{X} n:=[i for \\spad{i} in 1..]::Stream(Integer) \\spad{X} f(i:Integer,j:Integer):Integer \\spad{==} i+j \\spad{X} map(f,m,n)"))) 
NIL 
NIL 
(|Stream| S) 
((|constructor| (NIL "A stream is an implementation of an infinite sequence using a list of terms that have been computed and a function closure to compute additional terms when needed.")) (|filterUntil| (($ (|Mapping| (|Boolean|) |#1|) $) "\\indented{1}{filterUntil(p,s) returns \\spad{[x0,x1,...,x(n)]} where} \\indented{1}{\\spad{s = [x0,x1,x2,..]} and} \\indented{1}{n is the smallest index such that \\spad{p(xn) = true}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} f(x:PositiveInteger):Boolean \\spad{==} \\spad{x} < 5 \\spad{X} filterUntil(f,m)")) (|filterWhile| (($ (|Mapping| (|Boolean|) |#1|) $) "\\indented{1}{filterWhile(p,s) returns \\spad{[x0,x1,...,x(n-1)]} where} \\indented{1}{\\spad{s = [x0,x1,x2,..]} and} \\indented{1}{n is the smallest index such that \\spad{p(xn) = false}.} \\blankline \\spad{X} m:=[i for \\spad{i} in 1..] \\spad{X} f(x:PositiveInteger):Boolean \\spad{==} \\spad{x} < 5 \\spad{X} filterWhile(f,m)")) (|generate| (($ (|Mapping| |#1| |#1|) |#1|) "\\indented{1}{generate(f,x) creates an infinite stream whose first element is} \\indented{1}{x and whose \\spad{n}th element (\\spad{n > 1}) is \\spad{f} applied to the previous} \\indented{1}{element. Note: \\spad{generate(f,x) = [x,f(x),f(f(x)),...]}.} \\blankline \\spad{X} f(x:Integer):Integer \\spad{==} \\spad{x+10} \\spad{X} generate(f,10)") (($ (|Mapping| |#1|)) "\\indented{1}{generate(f) creates an infinite stream all of whose elements are} \\indented{1}{equal to \\spad{f()}.} \\indented{1}{Note: \\spad{generate(f) = [f(),f(),f(),...]}.} \\blankline \\spad{X} f():Integer \\spad{==} 1 \\spad{X} generate(f)")) (|setrest!| (($ $ (|Integer|) $) "\\indented{1}{setrest!(x,n,y) sets rest(x,n) to \\spad{y.} The function will expand} \\indented{1}{cycles if necessary.} \\blankline \\spad{X} p:=[i for \\spad{i} in 1..] \\spad{X} q:=[i for \\spad{i} in 9..] \\spad{X} setrest!(p,4,q) \\spad{X} \\spad{p}")) (|showAll?| (((|Boolean|)) "\\spad{showAll?()} returns \\spad{true} if all computed entries of streams will be displayed.")) (|showAllElements| (((|OutputForm|) $) "\\indented{1}{showAllElements(s) creates an output form which displays all} \\indented{1}{computed elements.} \\blankline \\spad{X} m:=[1,2,3,4,5,6,7,8,9,10,11,12] \\spad{X} n:=m::Stream(PositiveInteger) \\spad{X} showAllElements \\spad{n}")) (|output| (((|Void|) (|Integer|) $) "\\indented{1}{output(n,st) computes and displays the first \\spad{n} entries} \\indented{1}{of st.} \\blankline \\spad{X} m:=[1,2,3] \\spad{X} n:=repeating(m) \\spad{X} output(5,n)")) (|cons| (($ |#1| $) "\\indented{1}{cons(a,s) returns a stream whose \\spad{first} is \\spad{a}} \\indented{1}{and whose \\spad{rest} is \\spad{s.}} \\indented{1}{Note: \\spad{cons(a,s) = concat(a,s)}.} \\blankline \\spad{X} m:=[1,2,3] \\spad{X} n:=repeating(m) \\spad{X} cons(4,n)")) (|delay| (($ (|Mapping| $)) "\\spad{delay(f)} creates a stream with a lazy evaluation defined by function \\spad{f.} Caution: This function can only be called in compiled code.")) (|findCycle| (((|Record| (|:| |cycle?| (|Boolean|)) (|:| |prefix| (|NonNegativeInteger|)) (|:| |period| (|NonNegativeInteger|))) (|NonNegativeInteger|) $) "\\indented{1}{findCycle(n,st) determines if st is periodic within \\spad{n.}} \\blankline \\spad{X} m:=[1,2,3] \\spad{X} n:=repeating(m) \\spad{X} findCycle(3,n) \\spad{X} findCycle(2,n)")) (|repeating?| (((|Boolean|) (|List| |#1|) $) "\\indented{1}{repeating?(l,s) returns \\spad{true} if a stream \\spad{s} is periodic} \\indented{1}{with period \\spad{l,} and \\spad{false} otherwise.} \\blankline \\spad{X} m:=[1,2,3] \\spad{X} n:=repeating(m) \\spad{X} repeating?(m,n)")) (|repeating| (($ (|List| |#1|)) "\\indented{1}{repeating(l) is a repeating stream whose period is the list \\spad{l.}} \\blankline \\spad{X} m:=repeating([-1,0,1,2,3])")) (|coerce| (($ (|List| |#1|)) "\\indented{1}{coerce(l) converts a list \\spad{l} to a stream.} \\blankline \\spad{X} m:=[1,2,3,4,5,6,7,8,9,10,11,12] \\spad{X} coerce(m)@Stream(Integer) \\spad{X} m::Stream(Integer)")) (|shallowlyMutable| ((|attribute|) "one may destructively alter a stream by assigning new values to its entries."))) 
((|shallowlyMutable| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|)))) 
(|StringCategory|) 
((|constructor| (NIL "A category for string-like objects")) (|string| (($ (|Integer|)) "\\spad{string(i)} returns the decimal representation of \\spad{i} in a string"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|String|) 
((|constructor| (NIL "This is the domain of character strings. Strings are 1 based."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| (|Character|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Character|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Character|) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Character|) (LIST (QUOTE |Evalable|) (QUOTE (|Character|)))) (|HasCategory| (|Character|) (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| (|Character|) (LIST (QUOTE |Evalable|) (QUOTE (|Character|)))) (|HasCategory| (|Character|) (QUOTE (|OrderedSet|)))) (AND (|HasCategory| (|Character|) (LIST (QUOTE |Evalable|) (QUOTE (|Character|)))) (|HasCategory| (|Character|) (QUOTE (|SetCategory|)))))) 
(|StringTable| |Entry|) 
((|constructor| (NIL "This domain provides tables where the keys are strings. A specialized hash function for strings is used."))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|)) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (QUOTE (|String|))) (LIST (QUOTE |:|) (QUOTE |entry|) (|devaluate| |#1|))))) (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|)) (QUOTE (|SetCategory|)))) (|HasCategory| (|String|) (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))) (OR (|HasCategory| (|Record| (|:| |key| (|String|)) (|:| |entry| |#1|)) (QUOTE (|SetCategory|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|StreamTaylorSeriesOperations| A) 
((|constructor| (NIL "StreamTaylorSeriesOperations implements Taylor series arithmetic, where a Taylor series is represented by a stream of its coefficients.")) (|power| (((|Stream| |#1|) |#1| (|Stream| |#1|)) "\\spad{power(a,f)} returns the power series \\spad{f} raised to the power \\spad{a}.")) (|lazyGintegrate| (((|Stream| |#1|) (|Mapping| |#1| (|Integer|)) |#1| (|Mapping| (|Stream| |#1|))) "\\spad{lazyGintegrate(f,r,g)} is used for fixed point computations.")) (|mapdiv| (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) "\\spad{mapdiv([a0,a1,..],[b0,b1,..])} returns \\spad{[a0/b0,a1/b1,..]}.")) (|powern| (((|Stream| |#1|) (|Fraction| (|Integer|)) (|Stream| |#1|)) "\\spad{powern(r,f)} raises power series \\spad{f} to the power \\spad{r.}")) (|nlde| (((|Stream| |#1|) (|Stream| (|Stream| |#1|))) "\\spad{nlde(u)} solves a first order non-linear differential equation described by \\spad{u} of the form \\spad{[[b<0,0>,b<0,1>,...],[b<1,0>,b<1,1>,.],...]}. the differential equation has the form \\spad{y'=sum(i=0 to \\spad{infinity,j=0} to infinity,b<i,j>*(x**i)*(y**j))}.")) (|lazyIntegrate| (((|Stream| |#1|) |#1| (|Mapping| (|Stream| |#1|))) "\\spad{lazyIntegrate(r,f)} is a local function used for fixed point computations.")) (|integrate| (((|Stream| |#1|) |#1| (|Stream| |#1|)) "\\spad{integrate(r,a)} returns the integral of the power series \\spad{a} with respect to the power series variableintegration where \\spad{r} denotes the constant of integration. Thus \\spad{integrate(a,[a0,a1,a2,...]) = [a,a0,a1/2,a2/3,...]}.")) (|invmultisect| (((|Stream| |#1|) (|Integer|) (|Integer|) (|Stream| |#1|)) "\\spad{invmultisect(a,b,st)} substitutes \\spad{x**((a+b)*n)} for \\spad{x**n} and multiplies by \\spad{x**b}.")) (|multisect| (((|Stream| |#1|) (|Integer|) (|Integer|) (|Stream| |#1|)) "\\spad{multisect(a,b,st)} selects the coefficients of \\spad{x**((a+b)*n+a)}, and changes them to \\spad{x**n}.")) (|generalLambert| (((|Stream| |#1|) (|Stream| |#1|) (|Integer|) (|Integer|)) "\\spad{generalLambert(f(x),a,d)} returns \\spad{f(x**a) + f(x**(a + \\spad{d))} + f(x**(a + 2 \\spad{d))} + ...}. \\spad{f(x)} should have zero constant coefficient and \\spad{a} and \\spad{d} should be positive.")) (|evenlambert| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{evenlambert(st)} computes \\spad{f(x**2) + f(x**4) + f(x**6) + ...} if \\spad{st} is a stream representing \\spad{f(x)}. This function is used for computing infinite products. If \\spad{f(x)} is a power series with constant coefficient 1, then \\spad{prod(f(x**(2*n)),n=1..infinity) = exp(evenlambert(log(f(x))))}.")) (|oddlambert| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{oddlambert(st)} computes \\spad{f(x) + f(x**3) + f(x**5) + ...} if \\spad{st} is a stream representing \\spad{f(x)}. This function is used for computing infinite products. If f(x) is a power series with constant coefficient 1 then \\spad{prod(f(x**(2*n-1)),n=1..infinity) = exp(oddlambert(log(f(x))))}.")) (|lambert| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{lambert(st)} computes \\spad{f(x) + f(x**2) + f(x**3) + ...} if \\spad{st} is a stream representing \\spad{f(x)}. This function is used for computing infinite products. If \\spad{f(x)} is a power series with constant coefficient 1 then \\spad{prod(f(x**n),n = 1..infinity) = exp(lambert(log(f(x))))}.")) (|addiag| (((|Stream| |#1|) (|Stream| (|Stream| |#1|))) "\\spad{addiag(x)} performs diagonal addition of a stream of streams. if \\spad{x} = \\spad{[[a<0,0>,a<0,1>,..],[a<1,0>,a<1,1>,..],[a<2,0>,a<2,1>,..],..]} and \\spad{addiag(x) = [b<0,b<1>,...], then b<k> = sum(i+j=k,a<i,j>)}.")) (|revert| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{revert(a)} computes the inverse of a power series \\spad{a} with respect to composition. the series should have constant coefficient 0 and first order coefficient 1.")) (|lagrange| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{lagrange(g)} produces the power series for \\spad{f} where \\spad{f} is implicitly defined as \\spad{f(z) = z*g(f(z))}.")) (|compose| (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) "\\spad{compose(a,b)} composes the power series \\spad{a} with the power series \\spad{b.}")) (|eval| (((|Stream| |#1|) (|Stream| |#1|) |#1|) "\\spad{eval(a,r)} returns a stream of partial sums of the power series \\spad{a} evaluated at the power series variable equal to \\spad{r.}")) (|coerce| (((|Stream| |#1|) |#1|) "\\spad{coerce(r)} converts a ring element \\spad{r} to a stream with one element.")) (|gderiv| (((|Stream| |#1|) (|Mapping| |#1| (|Integer|)) (|Stream| |#1|)) "\\spad{gderiv(f,[a0,a1,a2,..])} returns \\spad{[f(0)*a0,f(1)*a1,f(2)*a2,..]}.")) (|deriv| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{deriv(a)} returns the derivative of the power series with respect to the power series variable. Thus \\spad{deriv([a0,a1,a2,...])} returns \\spad{[a1,2 \\spad{a2,3} a3,...]}.")) (|mapmult| (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) "\\spad{mapmult([a0,a1,..],[b0,b1,..])} returns \\spad{[a0*b0,a1*b1,..]}.")) (|int| (((|Stream| |#1|) |#1|) "\\spad{int(r)} returns [r,r+1,r+2,...], where \\spad{r} is a ring element.")) (|oddintegers| (((|Stream| (|Integer|)) (|Integer|)) "\\spad{oddintegers(n)} returns \\spad{[n,n+2,n+4,...]}.")) (|integers| (((|Stream| (|Integer|)) (|Integer|)) "\\spad{integers(n)} returns \\spad{[n,n+1,n+2,...]}.")) (|monom| (((|Stream| |#1|) |#1| (|Integer|)) "\\spad{monom(deg,coef)} is a monomial of degree \\spad{deg} with coefficient coef.")) (|recip| (((|Union| (|Stream| |#1|) "failed") (|Stream| |#1|)) "\\spad{recip(a)} returns the power series reciprocal of \\spad{a}, or \"failed\" if not possible.")) (/ (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) "\\spad{a / \\spad{b}} returns the power series quotient of \\spad{a} by \\spad{b.} An error message is returned if \\spad{b} is not invertible. This function is used in fixed point computations.")) (|exquo| (((|Union| (|Stream| |#1|) "failed") (|Stream| |#1|) (|Stream| |#1|)) "\\spad{exquo(a,b)} returns the power series quotient of \\spad{a} by \\spad{b,} if the quotient exists, and \"failed\" otherwise")) (* (((|Stream| |#1|) (|Stream| |#1|) |#1|) "\\spad{a * \\spad{r}} returns the power series scalar multiplication of \\spad{a} by \\spad{r:} \\spad{[a0,a1,...] * \\spad{r} = \\spad{[a0} * \\spad{r,a1} * r,...]}") (((|Stream| |#1|) |#1| (|Stream| |#1|)) "\\spad{r * a} returns the power series scalar multiplication of \\spad{r} by \\spad{a}: \\spad{r * [a0,a1,...] = \\spad{[r} * a0,r * a1,...]}") (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) "\\spad{a * \\spad{b}} returns the power series (Cauchy) product of \\spad{a} and \\spad{b:} \\spad{[a0,a1,...] * [b0,b1,...] = [c0,c1,...]} where \\spad{ck = sum(i + \\spad{j} = k,ai * bk)}.")) (- (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{- a} returns the power series negative of \\spad{a}: \\spad{- [a0,a1,...] = \\spad{[-} a0,- a1,...]}") (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) "\\spad{a - \\spad{b}} returns the power series difference of \\spad{a} and \\spad{b}: \\spad{[a0,a1,..] - [b0,b1,..] = \\spad{[a0} - \\spad{b0,a1} - b1,..]}")) (+ (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) "\\spad{a + \\spad{b}} returns the power series sum of \\spad{a} and \\spad{b}: \\spad{[a0,a1,..] + [b0,b1,..] = \\spad{[a0} + \\spad{b0,a1} + b1,..]}"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) 
(|StreamTranscendentalFunctionsNonCommutative| |Coef|) 
((|constructor| (NIL "StreamTranscendentalFunctionsNonCommutative implements transcendental functions on Taylor series over a non-commutative ring, where a Taylor series is represented by a stream of its coefficients.")) (|acsch| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{acsch(st)} computes the inverse hyperbolic cosecant of a power series \\spad{st.}")) (|asech| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{asech(st)} computes the inverse hyperbolic secant of a power series \\spad{st.}")) (|acoth| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{acoth(st)} computes the inverse hyperbolic cotangent of a power series \\spad{st.}")) (|atanh| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{atanh(st)} computes the inverse hyperbolic tangent of a power series \\spad{st.}")) (|acosh| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{acosh(st)} computes the inverse hyperbolic cosine of a power series \\spad{st.}")) (|asinh| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{asinh(st)} computes the inverse hyperbolic sine of a power series \\spad{st.}")) (|csch| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{csch(st)} computes the hyperbolic cosecant of a power series \\spad{st.}")) (|sech| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{sech(st)} computes the hyperbolic secant of a power series \\spad{st.}")) (|coth| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{coth(st)} computes the hyperbolic cotangent of a power series \\spad{st.}")) (|tanh| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{tanh(st)} computes the hyperbolic tangent of a power series \\spad{st.}")) (|cosh| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{cosh(st)} computes the hyperbolic cosine of a power series \\spad{st.}")) (|sinh| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{sinh(st)} computes the hyperbolic sine of a power series \\spad{st.}")) (|acsc| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{acsc(st)} computes arccosecant of a power series \\spad{st.}")) (|asec| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{asec(st)} computes arcsecant of a power series \\spad{st.}")) (|acot| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{acot(st)} computes arccotangent of a power series \\spad{st.}")) (|atan| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{atan(st)} computes arctangent of a power series \\spad{st.}")) (|acos| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{acos(st)} computes arccosine of a power series \\spad{st.}")) (|asin| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{asin(st)} computes arcsine of a power series \\spad{st.}")) (|csc| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{csc(st)} computes cosecant of a power series \\spad{st.}")) (|sec| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{sec(st)} computes secant of a power series \\spad{st.}")) (|cot| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{cot(st)} computes cotangent of a power series \\spad{st.}")) (|tan| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{tan(st)} computes tangent of a power series \\spad{st.}")) (|cos| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{cos(st)} computes cosine of a power series \\spad{st.}")) (|sin| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{sin(st)} computes sine of a power series \\spad{st.}")) (** (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) "\\spad{st1 \\spad{**} st2} computes the power of a power series \\spad{st1} by another power series st2.")) (|log| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{log(st)} computes the log of a power series.")) (|exp| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{exp(st)} computes the exponential of a power series \\spad{st.}"))) 
NIL 
NIL 
(|StreamTranscendentalFunctions| |Coef|) 
((|constructor| (NIL "StreamTranscendentalFunctions implements transcendental functions on Taylor series, where a Taylor series is represented by a stream of its coefficients.")) (|acsch| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{acsch(st)} computes the inverse hyperbolic cosecant of a power series \\spad{st.}")) (|asech| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{asech(st)} computes the inverse hyperbolic secant of a power series \\spad{st.}")) (|acoth| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{acoth(st)} computes the inverse hyperbolic cotangent of a power series \\spad{st.}")) (|atanh| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{atanh(st)} computes the inverse hyperbolic tangent of a power series \\spad{st.}")) (|acosh| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{acosh(st)} computes the inverse hyperbolic cosine of a power series \\spad{st.}")) (|asinh| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{asinh(st)} computes the inverse hyperbolic sine of a power series \\spad{st.}")) (|csch| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{csch(st)} computes the hyperbolic cosecant of a power series \\spad{st.}")) (|sech| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{sech(st)} computes the hyperbolic secant of a power series \\spad{st.}")) (|coth| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{coth(st)} computes the hyperbolic cotangent of a power series \\spad{st.}")) (|tanh| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{tanh(st)} computes the hyperbolic tangent of a power series \\spad{st.}")) (|cosh| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{cosh(st)} computes the hyperbolic cosine of a power series \\spad{st.}")) (|sinh| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{sinh(st)} computes the hyperbolic sine of a power series \\spad{st.}")) (|sinhcosh| (((|Record| (|:| |sinh| (|Stream| |#1|)) (|:| |cosh| (|Stream| |#1|))) (|Stream| |#1|)) "\\spad{sinhcosh(st)} returns a record containing the hyperbolic sine and cosine of a power series \\spad{st.}")) (|acsc| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{acsc(st)} computes arccosecant of a power series \\spad{st.}")) (|asec| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{asec(st)} computes arcsecant of a power series \\spad{st.}")) (|acot| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{acot(st)} computes arccotangent of a power series \\spad{st.}")) (|atan| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{atan(st)} computes arctangent of a power series \\spad{st.}")) (|acos| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{acos(st)} computes arccosine of a power series \\spad{st.}")) (|asin| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{asin(st)} computes arcsine of a power series \\spad{st.}")) (|csc| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{csc(st)} computes cosecant of a power series \\spad{st.}")) (|sec| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{sec(st)} computes secant of a power series \\spad{st.}")) (|cot| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{cot(st)} computes cotangent of a power series \\spad{st.}")) (|tan| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{tan(st)} computes tangent of a power series \\spad{st.}")) (|cos| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{cos(st)} computes cosine of a power series \\spad{st.}")) (|sin| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{sin(st)} computes sine of a power series \\spad{st.}")) (|sincos| (((|Record| (|:| |sin| (|Stream| |#1|)) (|:| |cos| (|Stream| |#1|))) (|Stream| |#1|)) "\\spad{sincos(st)} returns a record containing the sine and cosine of a power series \\spad{st.}")) (** (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) "\\spad{st1 \\spad{**} st2} computes the power of a power series \\spad{st1} by another power series st2.")) (|log| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{log(st)} computes the log of a power series.")) (|exp| (((|Stream| |#1|) (|Stream| |#1|)) "\\spad{exp(st)} computes the exponential of a power series \\spad{st.}"))) 
NIL 
NIL 
(|SubResultantPackage| R UP) 
((|constructor| (NIL "This package computes the subresultants of two polynomials which is needed for the `Lazard Rioboo' enhancement to Tragers integrations formula For efficiency reasons this has been rewritten to call Lionel Ducos package which is currently the best one.")) (|primitivePart| ((|#2| |#2| |#1|) "\\spad{primitivePart(p, \\spad{q)}} reduces the coefficient of \\spad{p} modulo \\spad{q,} takes the primitive part of the result, and ensures that the leading coefficient of that result is monic.")) (|subresultantVector| (((|PrimitiveArray| |#2|) |#2| |#2|) "\\spad{subresultantVector(p, \\spad{q)}} returns \\spad{[p0,...,pn]} where \\spad{pi} is the \\spad{i}-th subresultant of \\spad{p} and \\spad{q.} In particular, \\spad{p0 = resultant(p, q)}."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|EuclideanDomain|)))) 
(|SubSpace| |n| R) 
((|constructor| (NIL "This domain is not documented")) (|pointData| (((|List| (|Point| |#2|)) $) "\\spad{pointData(s)} returns the list of points from the point data field of the 3 dimensional subspace \\spad{s.}")) (|parent| (($ $) "\\spad{parent(s)} returns the subspace which is the parent of the indicated 3 dimensional subspace \\spad{s.} If \\spad{s} is the top level subspace an error message is returned.")) (|level| (((|NonNegativeInteger|) $) "\\spad{level(s)} returns a non negative integer which is the current level field of the indicated 3 dimensional subspace \\spad{s.}")) (|extractProperty| (((|SubSpaceComponentProperty|) $) "\\spad{extractProperty(s)} returns the property of domain \\spadtype{SubSpaceComponentProperty} of the indicated 3 dimensional subspace \\spad{s.}")) (|extractClosed| (((|Boolean|) $) "\\spad{extractClosed(s)} returns the \\spadtype{Boolean} value of the closed property for the indicated 3 dimensional subspace \\spad{s.} If the property is closed, \\spad{True} is returned, otherwise \\spad{False} is returned.")) (|extractIndex| (((|NonNegativeInteger|) $) "\\spad{extractIndex(s)} returns a non negative integer which is the current index of the 3 dimensional subspace \\spad{s.}")) (|extractPoint| (((|Point| |#2|) $) "\\spad{extractPoint(s)} returns the point which is given by the current index location into the point data field of the 3 dimensional subspace \\spad{s.}")) (|traverse| (($ $ (|List| (|NonNegativeInteger|))) "\\spad{traverse(s,li)} follows the branch list of the 3 dimensional subspace, \\spad{s,} along the path dictated by the list of non negative integers, li, which points to the component which has been traversed to. The subspace, \\spad{s,} is returned, where \\spad{s} is now the subspace pointed to by li.")) (|defineProperty| (($ $ (|List| (|NonNegativeInteger|)) (|SubSpaceComponentProperty|)) "\\spad{defineProperty(s,li,p)} defines the component property in the 3 dimensional subspace, \\spad{s,} to be that of \\spad{p,} where \\spad{p} is of the domain \\spadtype{SubSpaceComponentProperty}. The list of non negative integers, li, dictates the path to follow, or, to look at it another way, points to the component whose property is being defined. The subspace, \\spad{s,} is returned with the component property definition.")) (|closeComponent| (($ $ (|List| (|NonNegativeInteger|)) (|Boolean|)) "\\spad{closeComponent(s,li,b)} sets the property of the component in the 3 dimensional subspace, \\spad{s,} to be closed if \\spad{b} is true, or open if \\spad{b} is false. The list of non negative integers, li, dictates the path to follow, or, to look at it another way, points to the component whose closed property is to be set. The subspace, \\spad{s,} is returned with the component property modification.")) (|modifyPoint| (($ $ (|NonNegativeInteger|) (|Point| |#2|)) "\\spad{modifyPoint(s,ind,p)} modifies the point referenced by the index location, ind, by replacing it with the point, \\spad{p} in the 3 dimensional subspace, \\spad{s.} An error message occurs if \\spad{s} is empty, otherwise the subspace \\spad{s} is returned with the point modification.") (($ $ (|List| (|NonNegativeInteger|)) (|NonNegativeInteger|)) "\\spad{modifyPoint(s,li,i)} replaces an existing point in the 3 dimensional subspace, \\spad{s,} with the 4 dimensional point indicated by the index location, i. The list of non negative integers, li, dictates the path to follow, or, to look at it another way, points to the component in which the existing point is to be modified. An error message occurs if \\spad{s} is empty, otherwise the subspace \\spad{s} is returned with the point modification.") (($ $ (|List| (|NonNegativeInteger|)) (|Point| |#2|)) "\\spad{modifyPoint(s,li,p)} replaces an existing point in the 3 dimensional subspace, \\spad{s,} with the 4 dimensional point, \\spad{p.} The list of non negative integers, li, dictates the path to follow, or, to look at it another way, points to the component in which the existing point is to be modified. An error message occurs if \\spad{s} is empty, otherwise the subspace \\spad{s} is returned with the point modification.")) (|addPointLast| (($ $ $ (|Point| |#2|) (|NonNegativeInteger|)) "\\spad{addPointLast(s,s2,li,p)} adds the 4 dimensional point, \\spad{p,} to the 3 dimensional subspace, \\spad{s.} \\spad{s2} point to the end of the subspace \\spad{s.} \\spad{n} is the path in the \\spad{s2} component. The subspace \\spad{s} is returned with the additional point.")) (|addPoint2| (($ $ (|Point| |#2|)) "\\spad{addPoint2(s,p)} adds the 4 dimensional point, \\spad{p,} to the 3 dimensional subspace, \\spad{s.} The subspace \\spad{s} is returned with the additional point.")) (|addPoint| (((|NonNegativeInteger|) $ (|Point| |#2|)) "\\spad{addPoint(s,p)} adds the point, \\spad{p,} to the 3 dimensional subspace, \\spad{s,} and returns the new total number of points in \\spad{s.}") (($ $ (|List| (|NonNegativeInteger|)) (|NonNegativeInteger|)) "\\spad{addPoint(s,li,i)} adds the 4 dimensional point indicated by the index location, i, to the 3 dimensional subspace, \\spad{s.} The list of non negative integers, li, dictates the path to follow, or, to look at it another way, points to the component in which the point is to be added. It's length should range from 0 to \\spad{n - 1} where \\spad{n} is the dimension of the subspace. If the length is \\spad{n - 1}, then a specific lowest level component is being referenced. If it is less than \\spad{n - 1}, then some higher level component \\spad{(0} indicates top level component) is being referenced and a component of that level with the desired point is created. The subspace \\spad{s} is returned with the additional point.") (($ $ (|List| (|NonNegativeInteger|)) (|Point| |#2|)) "\\spad{addPoint(s,li,p)} adds the 4 dimensional point, \\spad{p,} to the 3 dimensional subspace, \\spad{s.} The list of non negative integers, li, dictates the path to follow, or, to look at it another way, points to the component in which the point is to be added. It's length should range from 0 to \\spad{n - 1} where \\spad{n} is the dimension of the subspace. If the length is \\spad{n - 1}, then a specific lowest level component is being referenced. If it is less than \\spad{n - 1}, then some higher level component \\spad{(0} indicates top level component) is being referenced and a component of that level with the desired point is created. The subspace \\spad{s} is returned with the additional point.")) (|separate| (((|List| $) $) "\\spad{separate(s)} makes each of the components of the \\spadtype{SubSpace}, \\spad{s,} into a list of separate and distinct subspaces and returns the list.")) (|merge| (($ (|List| $)) "\\spad{merge(ls)} a list of subspaces, \\spad{ls,} into one subspace.") (($ $ $) "\\spad{merge(s1,s2)} the subspaces \\spad{s1} and \\spad{s2} into a single subspace.")) (|deepCopy| (($ $) "\\spad{deepCopy(x)} is not documented")) (|shallowCopy| (($ $) "\\spad{shallowCopy(x)} is not documented")) (|numberOfChildren| (((|NonNegativeInteger|) $) "\\spad{numberOfChildren(x)} is not documented")) (|children| (((|List| $) $) "\\spad{children(x)} is not documented")) (|child| (($ $ (|NonNegativeInteger|)) "\\spad{child(x,n)} is not documented")) (|birth| (($ $) "\\spad{birth(x)} is not documented")) (|subspace| (($) "\\spad{subspace()} is not documented")) (|new| (($) "\\spad{new()} is not documented")) (|internal?| (((|Boolean|) $) "\\spad{internal?(x)} is not documented")) (|root?| (((|Boolean|) $) "\\spad{root?(x)} is not documented")) (|leaf?| (((|Boolean|) $) "\\spad{leaf?(x)} is not documented"))) 
NIL 
NIL 
(|SuchThat| S1 S2) 
((|constructor| (NIL "This domain implements \"such that\" forms")) (|rhs| ((|#2| $) "\\spad{rhs(f)} returns the right side of \\spad{f}")) (|lhs| ((|#1| $) "\\spad{lhs(f)} returns the left side of \\spad{f}")) (|construct| (($ |#1| |#2|) "\\spad{construct(s,t)} makes a form \\spad{s:t}"))) 
NIL 
NIL 
(|SparseUnivariateLaurentSeries| |Coef| |var| |cen|) 
((|constructor| (NIL "Sparse Laurent series in one variable \\spadtype{SparseUnivariateLaurentSeries} is a domain representing Laurent series in one variable with coefficients in an arbitrary ring. The parameters of the type specify the coefficient ring, the power series variable, and the center of the power series expansion. For example, \\spad{SparseUnivariateLaurentSeries(Integer,x,3)} represents Laurent series in \\spad{(x - 3)} with integer coefficients.")) (|integrate| (($ $ (|Variable| |#2|)) "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.")) (|differentiate| (($ $ (|Variable| |#2|)) "\\spad{differentiate(f(x),x)} returns the derivative of \\spad{f(x)} with respect to \\spad{x}.")) (|coerce| (($ (|Variable| |#2|)) "\\spad{coerce(var)} converts the series variable \\spad{var} into a Laurent series."))) 
(((|commutative| "*") OR (|and| (|has| |#1| (|Field|)) (|has| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (|OrderedIntegralDomain|))) (|has| |#1| (|CommutativeRing|)) (|and| (|has| |#1| (|Field|)) (|has| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (|PolynomialFactorizationExplicit|)))) (|noZeroDivisors| OR (|and| (|has| |#1| (|Field|)) (|has| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (|OrderedIntegralDomain|))) (|has| |#1| (|IntegralDomain|)) (|and| (|has| |#1| (|Field|)) (|has| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (|PolynomialFactorizationExplicit|)))) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| (|Integer|) (QUOTE (|SemiGroup|))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|)))) (OR (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|Integer|)) (|devaluate| |#1|)))))) (OR (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|DifferentialRing|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|Integer|)) (|devaluate| |#1|))))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|RealConstant|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|StepThrough|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |Eltable|) (LIST (QUOTE |SparseUnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)) (LIST (QUOTE |SparseUnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |Evalable|) (LIST (QUOTE |SparseUnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (LIST (QUOTE |SparseUnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Integer|))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|)))))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|)))) (OR (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (OR (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (OR (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|Field|))))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (OR (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |Eltable|) (LIST (QUOTE |SparseUnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)) (LIST (QUOTE |SparseUnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |Evalable|) (LIST (QUOTE |SparseUnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (LIST (QUOTE |SparseUnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|RealConstant|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|StepThrough|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |AlgebraicallyClosedFunctionSpace|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|PrimitiveFunctionCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |integrate|) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Symbol|))))) (|HasSignature| |#1| (LIST (QUOTE |variables|) (LIST (LIST (QUOTE |List|) (QUOTE (|Symbol|))) (|devaluate| |#1|)))))) (OR (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|SparseUnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))))) 
(|FunctionSpaceSum| R F) 
((|constructor| (NIL "Computes sums of top-level expressions")) (|sum| ((|#2| |#2| (|SegmentBinding| |#2|)) "\\spad{sum(f(n), \\spad{n} = a..b)} returns f(a) + f(a+1) + \\spad{...} + f(b).") ((|#2| |#2| (|Symbol|)) "\\spad{sum(a(n), \\spad{n)}} returns A(n) such that A(n+1) - A(n) = a(n)."))) 
NIL 
NIL 
(|RationalFunctionSum| R) 
((|constructor| (NIL "Computes sums of rational functions.")) (|sum| (((|Union| (|Fraction| (|Polynomial| |#1|)) (|Expression| |#1|)) (|Fraction| (|Polynomial| |#1|)) (|SegmentBinding| (|Fraction| (|Polynomial| |#1|)))) "\\indented{1}{sum(f(n), \\spad{n} = a..b) returns \\spad{f(a) + f(a+1) + \\spad{...} f(b)}.} \\blankline \\spad{X} sum(i::Fraction(Polynomial(Integer)),i=1..n)") (((|Fraction| (|Polynomial| |#1|)) (|Polynomial| |#1|) (|SegmentBinding| (|Polynomial| |#1|))) "\\indented{1}{sum(f(n), \\spad{n} = a..b) returns \\spad{f(a) + f(a+1) + \\spad{...} f(b)}.} \\blankline \\spad{X} sum(i,i=1..n)") (((|Union| (|Fraction| (|Polynomial| |#1|)) (|Expression| |#1|)) (|Fraction| (|Polynomial| |#1|)) (|Symbol|)) "\\indented{1}{sum(a(n), \\spad{n)} returns \\spad{A} which} \\indented{1}{is the indefinite sum of \\spad{a} with respect to} \\indented{1}{upward difference on \\spad{n}, \\spadignore{i.e.} \\spad{A(n+1) - A(n) = a(n)}.} \\blankline \\spad{X} sum(i::Fraction(Polynomial(Integer)),i::Symbol)") (((|Fraction| (|Polynomial| |#1|)) (|Polynomial| |#1|) (|Symbol|)) "\\indented{1}{sum(a(n), \\spad{n)} returns \\spad{A} which} \\indented{1}{is the indefinite sum of \\spad{a} with respect to} \\indented{1}{upward difference on \\spad{n}, \\spadignore{i.e.} \\spad{A(n+1) - A(n) = a(n)}.} \\blankline \\spad{X} sum(i::Polynomial(Integer),variable(i=1..n))"))) 
NIL 
NIL 
(|SparseUnivariatePolynomialFunctions2| R S) 
((|constructor| (NIL "This package lifts a mapping from coefficient rings \\spad{R} to \\spad{S} to a mapping from sparse univariate polynomial over \\spad{R} to a sparse univariate polynomial over \\spad{S.} Note that the mapping is assumed to send zero to zero, since it will only be applied to the non-zero coefficients of the polynomial.")) (|map| (((|SparseUnivariatePolynomial| |#2|) (|Mapping| |#2| |#1|) (|SparseUnivariatePolynomial| |#1|)) "\\spad{map(func, poly)} creates a new polynomial by applying \\spad{func} to every non-zero coefficient of the polynomial poly."))) 
NIL 
NIL 
(|SparseUnivariatePolynomialExpressions| R) 
((|constructor| (NIL "This domain has no description"))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|additiveValuation| |has| |#1| (|Field|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|StepThrough|))) (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|))) (OR (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))))) 
(|SupFractionFactorizer| E OV R P) 
((|constructor| (NIL "SupFractionFactorize contains the factor function for univariate polynomials over the quotient field of a ring \\spad{S} such that the package MultivariateFactorize works for \\spad{S}")) (|squareFree| (((|Factored| (|SparseUnivariatePolynomial| (|Fraction| |#4|))) (|SparseUnivariatePolynomial| (|Fraction| |#4|))) "\\spad{squareFree(p)} returns the square-free factorization of the univariate polynomial \\spad{p} with coefficients which are fractions of polynomials over \\spad{R.} Each factor has no repeated roots and the factors are pairwise relatively prime.")) (|factor| (((|Factored| (|SparseUnivariatePolynomial| (|Fraction| |#4|))) (|SparseUnivariatePolynomial| (|Fraction| |#4|))) "\\spad{factor(p)} factors the univariate polynomial \\spad{p} with coefficients which are fractions of polynomials over \\spad{R.}"))) 
NIL 
NIL 
(|SparseUnivariatePolynomial| R) 
((|constructor| (NIL "This domain represents univariate polynomials over arbitrary (not necessarily commutative) coefficient rings. The variable is unspecified so that the variable displays as \\spad{?} on output. If it is necessary to specify the variable name, use type \\spadtype{UnivariatePolynomial}. The representation is sparse in the sense that only non-zero terms are represented. Note that if the coefficient ring is a field, this domain forms a euclidean domain.")) (|fmecg| (($ $ (|NonNegativeInteger|) |#1| $) "\\spad{fmecg(p1,e,r,p2)} finds \\spad{x} : \\spad{p1} - \\spad{r} * x**e * \\spad{p2}")) (|outputForm| (((|OutputForm|) $ (|OutputForm|)) "\\spad{outputForm(p,var)} converts the SparseUnivariatePolynomial \\spad{p} to an output form (see \\spadtype{OutputForm}) printed as a polynomial in the output form variable."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|additiveValuation| |has| |#1| (|Field|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|StepThrough|))) (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (OR (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasCategory| |#1| (QUOTE (|DifferentialRing|))) (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))))) 
(|SparseUnivariatePuiseuxSeries| |Coef| |var| |cen|) 
((|constructor| (NIL "Sparse Puiseux series in one variable \\spadtype{SparseUnivariatePuiseuxSeries} is a domain representing Puiseux series in one variable with coefficients in an arbitrary ring. The parameters of the type specify the coefficient ring, the power series variable, and the center of the power series expansion. For example, \\spad{SparseUnivariatePuiseuxSeries(Integer,x,3)} represents Puiseux series in \\spad{(x - 3)} with \\spadtype{Integer} coefficients.")) (|integrate| (($ $ (|Variable| |#2|)) "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.")) (|differentiate| (($ $ (|Variable| |#2|)) "\\spad{differentiate(f(x),x)} returns the derivative of \\spad{f(x)} with respect to \\spad{x}.")) (|coerce| (($ (|Variable| |#2|)) "\\spad{coerce(var)} converts the series variable \\spad{var} into a Puiseux series."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))) (|devaluate| |#1|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))) (|devaluate| |#1|))))) (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|SemiGroup|))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|)))))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |AlgebraicallyClosedFunctionSpace|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|PrimitiveFunctionCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |integrate|) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Symbol|))))) (|HasSignature| |#1| (LIST (QUOTE |variables|) (LIST (LIST (QUOTE |List|) (QUOTE (|Symbol|))) (|devaluate| |#1|))))))) 
(|SparseUnivariateTaylorSeries| |Coef| |var| |cen|) 
((|constructor| (NIL "Sparse Taylor series in one variable \\spadtype{SparseUnivariateTaylorSeries} is a domain representing Taylor series in one variable with coefficients in an arbitrary ring. The parameters of the type specify the coefficient ring, the power series variable, and the center of the power series expansion. For example, \\spadtype{SparseUnivariateTaylorSeries}(Integer,x,3) represents Taylor series in \\spad{(x - 3)} with \\spadtype{Integer} coefficients.")) (|integrate| (($ $ (|Variable| |#2|)) "\\spad{integrate(f(x),x)} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.")) (|differentiate| (($ $ (|Variable| |#2|)) "\\spad{differentiate(f(x),x)} computes the derivative of \\spad{f(x)} with respect to \\spad{x}.")) (|univariatePolynomial| (((|UnivariatePolynomial| |#2| |#1|) $ (|NonNegativeInteger|)) "\\spad{univariatePolynomial(f,k)} returns a univariate polynomial \\indented{1}{consisting of the sum of all terms of \\spad{f} of degree \\spad{<= k}.}")) (|coerce| (($ (|Variable| |#2|)) "\\spad{coerce(var)} converts the series variable \\spad{var} into a \\indented{1}{Taylor series.}") (($ (|UnivariatePolynomial| |#2| |#1|)) "\\spad{coerce(p)} converts a univariate polynomial \\spad{p} in the variable \\spad{var} to a univariate Taylor series in \\spad{var}."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|)) (|devaluate| |#1|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|)) (|devaluate| |#1|))))) (|HasCategory| (|NonNegativeInteger|) (QUOTE (|SemiGroup|))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|)))))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |AlgebraicallyClosedFunctionSpace|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|PrimitiveFunctionCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |integrate|) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Symbol|))))) (|HasSignature| |#1| (LIST (QUOTE |variables|) (LIST (LIST (QUOTE |List|) (QUOTE (|Symbol|))) (|devaluate| |#1|))))))) 
(|Switch|) 
((|constructor| (NIL "This domain builds representations of boolean expressions for use with the \\axiomType{FortranCode} domain.")) (NOT (($ $) "\\spad{NOT(x)} returns the \\axiomType{Switch} expression representing \\spad{\\~~x}.") (($ (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))) "\\spad{NOT(x)} returns the \\axiomType{Switch} expression representing \\spad{\\~~x}.")) (AND (($ (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)) (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))) "\\spad{AND(x,y)} returns the \\axiomType{Switch} expression representing \\spad{x and \\spad{y}.}")) (EQ (($ (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)) (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))) "\\spad{EQ(x,y)} returns the \\axiomType{Switch} expression representing \\spad{x = \\spad{y}.}")) (OR (($ (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)) (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))) "\\spad{OR(x,y)} returns the \\axiomType{Switch} expression representing \\spad{x or \\spad{y}.}")) (GE (($ (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)) (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))) "\\spad{GE(x,y)} returns the \\axiomType{Switch} expression representing \\spad{x>=y}.")) (LE (($ (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)) (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))) "\\spad{LE(x,y)} returns the \\axiomType{Switch} expression representing \\spad{x<=y}.")) (GT (($ (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)) (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))) "\\spad{GT(x,y)} returns the \\axiomType{Switch} expression representing \\spad{x>y}.")) (LT (($ (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $)) (|Union| (|:| I (|Expression| (|Integer|))) (|:| F (|Expression| (|Float|))) (|:| CF (|Expression| (|Complex| (|Float|)))) (|:| |switch| $))) "\\spad{LT(x,y)} returns the \\axiomType{Switch} expression representing \\spad{x<y}.")) (|coerce| (($ (|Symbol|)) "\\spad{coerce(s)} is not documented"))) 
NIL 
NIL 
(|Symbol|) 
((|constructor| (NIL "Basic and scripted symbols.")) (|sample| (($) "\\spad{sample()} returns a sample of \\%")) (|list| (((|List| $) $) "\\spad{list(sy)} takes a scripted symbol and produces a list of the name followed by the scripts.")) (|string| (((|String|) $) "\\spad{string(s)} converts the symbol \\spad{s} to a string. Error: if the symbol is subscripted.")) (|elt| (($ $ (|List| (|OutputForm|))) "\\spad{elt(s,[a1,...,an])} or s([a1,...,an]) returns \\spad{s} subscripted by \\spad{[a1,...,an]}.")) (|argscript| (($ $ (|List| (|OutputForm|))) "\\spad{argscript(s, [a1,...,an])} returns \\spad{s} arg-scripted by \\spad{[a1,...,an]}.")) (|superscript| (($ $ (|List| (|OutputForm|))) "\\spad{superscript(s, [a1,...,an])} returns \\spad{s} superscripted by \\spad{[a1,...,an]}.")) (|subscript| (($ $ (|List| (|OutputForm|))) "\\spad{subscript(s, [a1,...,an])} returns \\spad{s} subscripted by \\spad{[a1,...,an]}.")) (|script| (($ $ (|Record| (|:| |sub| (|List| (|OutputForm|))) (|:| |sup| (|List| (|OutputForm|))) (|:| |presup| (|List| (|OutputForm|))) (|:| |presub| (|List| (|OutputForm|))) (|:| |args| (|List| (|OutputForm|))))) "\\spad{script(s, [a,b,c,d,e])} returns \\spad{s} with subscripts a, superscripts \\spad{b,} pre-superscripts \\spad{c,} pre-subscripts \\spad{d,} and argument-scripts e.") (($ $ (|List| (|List| (|OutputForm|)))) "\\spad{script(s, [a,b,c,d,e])} returns \\spad{s} with subscripts a, superscripts \\spad{b,} pre-superscripts \\spad{c,} pre-subscripts \\spad{d,} and argument-scripts e. Omitted components are taken to be empty. For example, \\spad{script(s, [a,b,c])} is equivalent to \\spad{script(s,[a,b,c,[],[]])}.")) (|scripts| (((|Record| (|:| |sub| (|List| (|OutputForm|))) (|:| |sup| (|List| (|OutputForm|))) (|:| |presup| (|List| (|OutputForm|))) (|:| |presub| (|List| (|OutputForm|))) (|:| |args| (|List| (|OutputForm|)))) $) "\\spad{scripts(s)} returns all the scripts of \\spad{s.}")) (|scripted?| (((|Boolean|) $) "\\spad{scripted?(s)} is \\spad{true} if \\spad{s} has been given any scripts.")) (|name| (($ $) "\\spad{name(s)} returns \\spad{s} without its scripts.")) (|coerce| (($ (|String|)) "\\spad{coerce(s)} converts the string \\spad{s} to a symbol.")) (|resetNew| (((|Void|)) "\\spad{resetNew()} resets the internals counters that new() and new(s) use to return distinct symbols every time.")) (|new| (($ $) "\\spad{new(s)} returns a new symbol whose name starts with \\spad{%s.}") (($) "\\spad{new()} returns a new symbol whose name starts with \\spad{%.}"))) 
NIL 
NIL 
(|SymmetricFunctions| R) 
((|constructor| (NIL "Computes all the symmetric functions in \\spad{n} variables.")) (|symFunc| (((|Vector| |#1|) |#1| (|PositiveInteger|)) "\\spad{symFunc(r, \\spad{n)}} returns the vector of the elementary symmetric functions in \\spad{[r,r,...,r]} \\spad{n} times.") (((|Vector| |#1|) (|List| |#1|)) "\\spad{symFunc([r1,...,rn])} returns the vector of the elementary symmetric functions in the \\spad{ri's}: \\spad{[r1 + \\spad{...} + \\spad{rn,} \\spad{r1} \\spad{r2} + \\spad{...} + r(n-1) \\spad{rn,} ..., \\spad{r1} \\spad{r2} \\spad{...} rn]}."))) 
NIL 
NIL 
(|SymmetricPolynomial| R) 
((|constructor| (NIL "This domain implements symmetric polynomial"))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|GcdDomain|))) (AND (|HasCategory| (|Partition|) (QUOTE (|CancellationAbelianMonoid|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (OR (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|))) 
(|TheSymbolTable|) 
((|constructor| (NIL "Creates and manipulates one global symbol table for FORTRAN code generation, containing details of types, dimensions, and argument lists.")) (|symbolTableOf| (((|SymbolTable|) (|Symbol|) $) "\\spad{symbolTableOf(f,tab)} returns the symbol table of \\spad{f}")) (|argumentListOf| (((|List| (|Symbol|)) (|Symbol|) $) "\\spad{argumentListOf(f,tab)} returns the argument list of \\spad{f}")) (|returnTypeOf| (((|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| "void")) (|Symbol|) $) "\\spad{returnTypeOf(f,tab)} returns the type of the object returned by \\spad{f}")) (|empty| (($) "\\spad{empty()} creates a new, empty symbol table.")) (|printTypes| (((|Void|) (|Symbol|)) "\\spad{printTypes(tab)} produces FORTRAN type declarations from tab, on the current FORTRAN output stream")) (|printHeader| (((|Void|)) "\\spad{printHeader()} produces the FORTRAN header for the current subprogram in the global symbol table on the current FORTRAN output stream.") (((|Void|) (|Symbol|)) "\\spad{printHeader(f)} produces the FORTRAN header for subprogram \\spad{f} in the global symbol table on the current FORTRAN output stream.") (((|Void|) (|Symbol|) $) "\\spad{printHeader(f,tab)} produces the FORTRAN header for subprogram \\spad{f} in symbol table \\spad{tab} on the current FORTRAN output stream.")) (|returnType!| (((|Void|) (|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| "void"))) "\\spad{returnType!(t)} declares that the return type of he current subprogram in the global symbol table is \\spad{t.}") (((|Void|) (|Symbol|) (|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| "void"))) "\\spad{returnType!(f,t)} declares that the return type of subprogram \\spad{f} in the global symbol table is \\spad{t.}") (((|Void|) (|Symbol|) (|Union| (|:| |fst| (|FortranScalarType|)) (|:| |void| "void")) $) "\\spad{returnType!(f,t,tab)} declares that the return type of subprogram \\spad{f} in symbol table \\spad{tab} is \\spad{t.}")) (|argumentList!| (((|Void|) (|List| (|Symbol|))) "\\spad{argumentList!(l)} declares that the argument list for the current subprogram in the global symbol table is \\spad{l.}") (((|Void|) (|Symbol|) (|List| (|Symbol|))) "\\spad{argumentList!(f,l)} declares that the argument list for subprogram \\spad{f} in the global symbol table is \\spad{l.}") (((|Void|) (|Symbol|) (|List| (|Symbol|)) $) "\\spad{argumentList!(f,l,tab)} declares that the argument list for subprogram \\spad{f} in symbol table \\spad{tab} is \\spad{l.}")) (|endSubProgram| (((|Symbol|)) "\\spad{endSubProgram()} asserts that we are no longer processing the current subprogram.")) (|currentSubProgram| (((|Symbol|)) "\\spad{currentSubProgram()} returns the name of the current subprogram being processed")) (|newSubProgram| (((|Void|) (|Symbol|)) "\\spad{newSubProgram(f)} asserts that from now on type declarations are part of subprogram \\spad{f.}")) (|declare!| (((|FortranType|) (|Symbol|) (|FortranType|) (|Symbol|)) "\\spad{declare!(u,t,asp)} declares the parameter \\spad{u} to have type \\spad{t} in asp.") (((|FortranType|) (|Symbol|) (|FortranType|)) "\\spad{declare!(u,t)} declares the parameter \\spad{u} to have type \\spad{t} in the current level of the symbol table.") (((|FortranType|) (|List| (|Symbol|)) (|FortranType|) (|Symbol|) $) "\\spad{declare!(u,t,asp,tab)} declares the parameters \\spad{u} of subprogram \\spad{asp} to have type \\spad{t} in symbol table tab.") (((|FortranType|) (|Symbol|) (|FortranType|) (|Symbol|) $) "\\spad{declare!(u,t,asp,tab)} declares the parameter \\spad{u} of subprogram \\spad{asp} to have type \\spad{t} in symbol table tab.")) (|clearTheSymbolTable| (((|Void|) (|Symbol|)) "\\spad{clearTheSymbolTable(x)} removes the symbol \\spad{x} from the table") (((|Void|)) "\\spad{clearTheSymbolTable()} clears the current symbol table.")) (|showTheSymbolTable| (($) "\\spad{showTheSymbolTable()} returns the current symbol table."))) 
NIL 
NIL 
(|SymbolTable|) 
((|constructor| (NIL "Create and manipulate a symbol table for generated FORTRAN code")) (|symbolTable| (($ (|List| (|Record| (|:| |key| (|Symbol|)) (|:| |entry| (|FortranType|))))) "\\spad{symbolTable(l)} creates a symbol table from the elements of \\spad{l.}")) (|printTypes| (((|Void|) $) "\\spad{printTypes(tab)} produces FORTRAN type declarations from tab, on the current FORTRAN output stream")) (|newTypeLists| (((|SExpression|) $) "\\spad{newTypeLists(x)} is not documented")) (|typeLists| (((|List| (|List| (|Union| (|:| |name| (|Symbol|)) (|:| |bounds| (|List| (|Union| (|:| S (|Symbol|)) (|:| P (|Polynomial| (|Integer|))))))))) $) "\\spad{typeLists(tab)} returns a list of lists of types of objects in \\spad{tab}")) (|externalList| (((|List| (|Symbol|)) $) "\\spad{externalList(tab)} returns a list of all the external symbols in \\spad{tab}")) (|typeList| (((|List| (|Union| (|:| |name| (|Symbol|)) (|:| |bounds| (|List| (|Union| (|:| S (|Symbol|)) (|:| P (|Polynomial| (|Integer|)))))))) (|FortranScalarType|) $) "\\spad{typeList(t,tab)} returns a list of all the objects of type \\spad{t} in \\spad{tab}")) (|parametersOf| (((|List| (|Symbol|)) $) "\\spad{parametersOf(tab)} returns a list of all the symbols declared in \\spad{tab}")) (|fortranTypeOf| (((|FortranType|) (|Symbol|) $) "\\spad{fortranTypeOf(u,tab)} returns the type of \\spad{u} in \\spad{tab}")) (|declare!| (((|FortranType|) (|Symbol|) (|FortranType|) $) "\\spad{declare!(u,t,tab)} creates a new entry in tab, declaring \\spad{u} to be of type \\spad{t}") (((|FortranType|) (|List| (|Symbol|)) (|FortranType|) $) "\\spad{declare!(l,t,tab)} creates new entrys in tab, declaring each of \\spad{l} to be of type \\spad{t}")) (|empty| (($) "\\spad{empty()} returns a new, empty symbol table")) (|coerce| (((|Table| (|Symbol|) (|FortranType|)) $) "\\spad{coerce(x)} returns a table view of \\spad{x}"))) 
NIL 
NIL 
(|SystemSolvePackage| R) 
((|constructor| (NIL "Symbolic solver for systems of rational functions with coefficients in an integral domain \\spad{R.} The systems are solved in the field of rational functions over \\spad{R.} Solutions are exact of the form variable = value when the value is a member of the coefficient domain \\spad{R.} Otherwise the solutions are implicitly expressed as roots of univariate polynomial equations over \\spad{R.} Care is taken to guarantee that the denominators of the input equations do not vanish on the solution sets. The arguments to solve can either be given as equations or as rational functions interpreted as equal to zero. The user can specify an explicit list of symbols to be solved for, treating all other symbols appearing as parameters or omit the list of symbols in which case the system tries to solve with respect to all symbols appearing in the input.")) (|triangularSystems| (((|List| (|List| (|Polynomial| |#1|))) (|List| (|Fraction| (|Polynomial| |#1|))) (|List| (|Symbol|))) "\\spad{triangularSystems(lf,lv)} solves the system of equations defined by \\spad{lf} with respect to the list of symbols \\spad{lv;} the system of equations is obtaining by equating to zero the list of rational functions \\spad{lf.} The output is a list of solutions where each solution is expressed as a \"reduced\" triangular system of polynomials.")) (|solve| (((|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))) (|Equation| (|Fraction| (|Polynomial| |#1|)))) "\\spad{solve(eq)} finds the solutions of the equation \\spad{eq} with respect to the unique variable appearing in eq.") (((|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))) (|Fraction| (|Polynomial| |#1|))) "\\spad{solve(p)} finds the solution of a rational function \\spad{p} = 0 with respect to the unique variable appearing in \\spad{p.}") (((|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))) (|Equation| (|Fraction| (|Polynomial| |#1|))) (|Symbol|)) "\\spad{solve(eq,v)} finds the solutions of the equation \\spad{eq} with respect to the variable \\spad{v.}") (((|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))) (|Fraction| (|Polynomial| |#1|)) (|Symbol|)) "\\spad{solve(p,v)} solves the equation p=0, where \\spad{p} is a rational function with respect to the variable \\spad{v.}") (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))) (|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))) "\\spad{solve(le)} finds the solutions of the list \\spad{le} of equations of rational functions with respect to all symbols appearing in le.") (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))) (|List| (|Fraction| (|Polynomial| |#1|)))) "\\spad{solve(lp)} finds the solutions of the list \\spad{lp} of rational functions with respect to all symbols appearing in \\spad{lp.}") (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))) (|List| (|Equation| (|Fraction| (|Polynomial| |#1|)))) (|List| (|Symbol|))) "\\spad{solve(le,lv)} finds the solutions of the list \\spad{le} of equations of rational functions with respect to the list of symbols \\spad{lv.}") (((|List| (|List| (|Equation| (|Fraction| (|Polynomial| |#1|))))) (|List| (|Fraction| (|Polynomial| |#1|))) (|List| (|Symbol|))) "\\spad{solve(lp,lv)} finds the solutions of the list \\spad{lp} of rational functions with respect to the list of symbols \\spad{lv.}"))) 
NIL 
NIL 
(|TableauxBumpers| S) 
((|constructor| (NIL "TableauBumpers implements the Schenstead-Knuth correspondence between sequences and pairs of Young tableaux. The 2 Young tableaux are represented as a single tableau with pairs as components.")) (|mr| (((|Record| (|:| |f1| (|List| |#1|)) (|:| |f2| (|List| (|List| (|List| |#1|)))) (|:| |f3| (|List| (|List| |#1|))) (|:| |f4| (|List| (|List| (|List| |#1|))))) (|List| (|List| (|List| |#1|)))) "\\spad{mr(t)} is an auxiliary function which finds the position of the maximum element of a tableau \\spad{t} which is in the lowest row, producing a record of results")) (|maxrow| (((|Record| (|:| |f1| (|List| |#1|)) (|:| |f2| (|List| (|List| (|List| |#1|)))) (|:| |f3| (|List| (|List| |#1|))) (|:| |f4| (|List| (|List| (|List| |#1|))))) (|List| |#1|) (|List| (|List| (|List| |#1|))) (|List| (|List| |#1|)) (|List| (|List| (|List| |#1|))) (|List| (|List| (|List| |#1|))) (|List| (|List| (|List| |#1|)))) "\\spad{maxrow(a,b,c,d,e)} is an auxiliary function for \\spad{mr}")) (|inverse| (((|List| |#1|) (|List| |#1|)) "\\spad{inverse(ls)} forms the inverse of a sequence \\spad{ls}")) (|slex| (((|List| (|List| |#1|)) (|List| |#1|)) "\\spad{slex(ls)} sorts the argument sequence \\spad{ls,} then zips (see map) the original argument sequence with the sorted result to a list of pairs")) (|lex| (((|List| (|List| |#1|)) (|List| (|List| |#1|))) "\\spad{lex(ls)} sorts a list of pairs to lexicographic order")) (|tab| (((|Tableau| (|List| |#1|)) (|List| |#1|)) "\\spad{tab(ls)} creates a tableau from \\spad{ls} by first creating a list of pairs using slex, then creating a tableau using tab1.")) (|tab1| (((|List| (|List| (|List| |#1|))) (|List| (|List| |#1|))) "\\spad{tab1(lp)} creates a tableau from a list of pairs \\spad{lp}")) (|bat| (((|List| (|List| |#1|)) (|Tableau| (|List| |#1|))) "\\spad{bat(ls)} unbumps a tableau \\spad{ls}")) (|bat1| (((|List| (|List| |#1|)) (|List| (|List| (|List| |#1|)))) "\\spad{bat1(llp)} unbumps a tableau llp. Operation \\spad{bat1} is the inverse of tab1.")) (|untab| (((|List| (|List| |#1|)) (|List| (|List| |#1|)) (|List| (|List| (|List| |#1|)))) "\\spad{untab(lp,llp)} is an auxiliary function which unbumps a tableau llp, using \\spad{lp} to accumulate pairs")) (|bumptab1| (((|List| (|List| (|List| |#1|))) (|List| |#1|) (|List| (|List| (|List| |#1|)))) "\\spad{bumptab1(pr,t)} bumps a tableau \\spad{t} with a pair \\spad{pr} using comparison function \\spadfun{<}, returning a new tableau")) (|bumptab| (((|List| (|List| (|List| |#1|))) (|Mapping| (|Boolean|) |#1| |#1|) (|List| |#1|) (|List| (|List| (|List| |#1|)))) "\\spad{bumptab(cf,pr,t)} bumps a tableau \\spad{t} with a pair \\spad{pr} using comparison function \\spad{cf,} returning a new tableau")) (|bumprow| (((|Record| (|:| |fs| (|Boolean|)) (|:| |sd| (|List| |#1|)) (|:| |td| (|List| (|List| |#1|)))) (|Mapping| (|Boolean|) |#1| |#1|) (|List| |#1|) (|List| (|List| |#1|))) "\\spad{bumprow(cf,pr,r)} is an auxiliary function which bumps a row \\spad{r} with a pair \\spad{pr} using comparison function \\spad{cf,} and returns a record"))) 
NIL 
NIL 
(|Tableau| S) 
((|constructor| (NIL "The tableau domain is for printing Young tableaux, and coercions to and from List List \\spad{S} where \\spad{S} is a set.")) (|coerce| (((|OutputForm|) $) "\\spad{coerce(t)} converts a tableau \\spad{t} to an output form.")) (|listOfLists| (((|List| (|List| |#1|)) $) "\\spad{listOfLists \\spad{t}} converts a tableau \\spad{t} to a list of lists.")) (|tableau| (($ (|List| (|List| |#1|))) "\\spad{tableau(ll)} converts a list of lists \\spad{ll} to a tableau."))) 
NIL 
NIL 
(|Table| |Key| |Entry|) 
((|constructor| (NIL "This is the general purpose table type. The keys are hashed to look up the entries. This creates a \\spadtype{HashTable} if equal for the Key domain is consistent with Lisp EQUAL otherwise an \\spadtype{AssociationList}"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (LIST (QUOTE |Evalable|) (LIST (QUOTE |Record|) (LIST (QUOTE |:|) (QUOTE |key|) (|devaluate| |#1|)) (LIST (QUOTE |:|) (QUOTE |entry|) (|devaluate| |#2|))))) (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))) (OR (|HasCategory| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)) (QUOTE (|SetCategory|))) (|HasCategory| |#2| (QUOTE (|SetCategory|)))) (AND (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|))) (|HasCategory| |#2| (QUOTE (|SetCategory|))))) 
(|TangentExpansions| R) 
((|constructor| (NIL "Expands tangents of sums and scalar products.")) (|tanNa| ((|#1| |#1| (|Integer|)) "\\spad{tanNa(a, \\spad{n)}} returns \\spad{f(a)} such that if \\spad{a = tan(u)} then \\spad{f(a) = tan(n * u)}.")) (|tanAn| (((|SparseUnivariatePolynomial| |#1|) |#1| (|PositiveInteger|)) "\\spad{tanAn(a, \\spad{n)}} returns \\spad{P(x)} such that if \\spad{a = tan(u)} then \\spad{P(tan(u/n)) = 0}.")) (|tanSum| ((|#1| (|List| |#1|)) "\\spad{tanSum([a1,...,an])} returns \\spad{f(a1,...,an)} such that if \\spad{ai = tan(ui)} then \\spad{f(a1,...,an) = \\spad{tan(u1} + \\spad{...} + un)}."))) 
NIL 
NIL 
(|TableAggregate&| S |Key| |Entry|) 
((|constructor| (NIL "A table aggregate is a model of a table, that is, a discrete many-to-one mapping from keys to entries.")) (|map| (($ (|Mapping| |#3| |#3| |#3|) $ $) "\\spad{map(fn,t1,t2)} creates a new table \\spad{t} from given tables \\spad{t1} and \\spad{t2} with elements fn(x,y) where \\spad{x} and \\spad{y} are corresponding elements from \\spad{t1} and \\spad{t2} respectively.")) (|table| (($ (|List| (|Record| (|:| |key| |#2|) (|:| |entry| |#3|)))) "\\spad{table([x,y,...,z])} creates a table consisting of entries \\axiom{x,y,...,z}.") (($) "\\spad{table()}$T creates an empty table of type \\spad{T.} \\blankline \\spad{E} Data:=Record(age:Integer,gender:String) \\spad{E} a1:AssociationList(String,Data):=table() \\spad{E} a1.\"tim\":=[55,\"male\"]$Data")) (|setelt| ((|#3| $ |#2| |#3|) "\\spad{setelt(t,k,e)} (also written \\axiom{t.k \\spad{:=} e}) is equivalent to \\axiom{(insert([k,e],t); e)}."))) 
NIL 
NIL 
(|TableAggregate| |Key| |Entry|) 
((|constructor| (NIL "A table aggregate is a model of a table, that is, a discrete many-to-one mapping from keys to entries.")) (|map| (($ (|Mapping| |#2| |#2| |#2|) $ $) "\\spad{map(fn,t1,t2)} creates a new table \\spad{t} from given tables \\spad{t1} and \\spad{t2} with elements fn(x,y) where \\spad{x} and \\spad{y} are corresponding elements from \\spad{t1} and \\spad{t2} respectively.")) (|table| (($ (|List| (|Record| (|:| |key| |#1|) (|:| |entry| |#2|)))) "\\spad{table([x,y,...,z])} creates a table consisting of entries \\axiom{x,y,...,z}.") (($) "\\spad{table()}$T creates an empty table of type \\spad{T.} \\blankline \\spad{E} Data:=Record(age:Integer,gender:String) \\spad{E} a1:AssociationList(String,Data):=table() \\spad{E} a1.\"tim\":=[55,\"male\"]$Data")) (|setelt| ((|#2| $ |#1| |#2|) "\\spad{setelt(t,k,e)} (also written \\axiom{t.k \\spad{:=} e}) is equivalent to \\axiom{(insert([k,e],t); e)}."))) 
((|shallowlyMutable| . T) (|nil| . T)) 
NIL 
(|TabulatedComputationPackage| |Key| |Entry|) 
((|constructor| (NIL "\\axiom{TabulatedComputationPackage(Key ,Entry)} provides some modest support for dealing with operations with type \\axiom{Key \\spad{->} Entry}. The result of such operations can be stored and retrieved with this package by using a hash-table. The user does not need to worry about the management of this hash-table. However, onnly one hash-table is built by calling \\axiom{TabulatedComputationPackage(Key ,Entry)}.")) (|insert!| (((|Void|) |#1| |#2|) "\\axiom{insert!(x,y)} stores the item whose key is \\axiom{x} and whose entry is \\axiom{y}.")) (|extractIfCan| (((|Union| |#2| "failed") |#1|) "\\axiom{extractIfCan(x)} searches the item whose key is \\axiom{x}.")) (|makingStats?| (((|Boolean|)) "\\axiom{makingStats?()} returns \\spad{true} iff the statisitics process is running.")) (|printingInfo?| (((|Boolean|)) "\\axiom{printingInfo?()} returns \\spad{true} iff messages are printed when manipulating items from the hash-table.")) (|usingTable?| (((|Boolean|)) "\\axiom{usingTable?()} returns \\spad{true} iff the hash-table is used")) (|clearTable!| (((|Void|)) "\\axiom{clearTable!()} clears the hash-table and assumes that it will no longer be used.")) (|printStats!| (((|Void|)) "\\axiom{printStats!()} prints the statistics.")) (|startStats!| (((|Void|) (|String|)) "\\axiom{startStats!(x)} initializes the statisitics process and sets the comments to display when statistics are printed")) (|printInfo!| (((|Void|) (|String|) (|String|)) "\\axiom{printInfo!(x,y)} initializes the mesages to be printed when manipulating items from the hash-table. If a key is retrieved then \\axiom{x} is displayed. If an item is stored then \\axiom{y} is displayed.")) (|initTable!| (((|Void|)) "\\axiom{initTable!()} initializes the hash-table."))) 
NIL 
NIL 
(|TemplateUtilities|) 
((|constructor| (NIL "This package provides functions for template manipulation")) (|stripCommentsAndBlanks| (((|String|) (|String|)) "\\spad{stripCommentsAndBlanks(s)} treats \\spad{s} as a piece of AXIOM input, and removes comments, and leading and trailing blanks.")) (|interpretString| (((|Any|) (|String|)) "\\spad{interpretString(s)} treats a string as a piece of AXIOM input, by parsing and interpreting it."))) 
NIL 
NIL 
(|TexFormat1| S) 
((|constructor| (NIL "\\spadtype{TexFormat1} provides a utility coercion for changing to TeX format anything that has a coercion to the standard output format.")) (|coerce| (((|TexFormat|) |#1|) "\\spad{coerce(s)} provides a direct coercion from a domain \\spad{S} to TeX format. This allows the user to skip the step of first manually coercing the object to standard output format before it is coerced to TeX format."))) 
NIL 
NIL 
(|TexFormat|) 
((|constructor| (NIL "\\spadtype{TexFormat} provides a coercion from \\spadtype{OutputForm} to \\TeX{} format. The particular dialect of \\TeX{} used is \\LaTeX{}. The basic object consists of three parts: a prologue, a tex part and an epilogue. The functions \\spadfun{prologue}, \\spadfun{tex} and \\spadfun{epilogue} extract these parts, respectively. The main guts of the expression go into the tex part. The other parts can be set (\\spadfun{setPrologue!}, \\spadfun{setEpilogue!}) so that contain the appropriate tags for printing. For example, the prologue and epilogue might simply contain ``\\verb+\\[+'' and ``\\verb+\\]+'', respectively, so that the TeX section will be printed in LaTeX display math mode.")) (|setPrologue!| (((|List| (|String|)) $ (|List| (|String|))) "\\spad{setPrologue!(t,strings)} sets the prologue section of a TeX form \\spad{t} to strings.")) (|setTex!| (((|List| (|String|)) $ (|List| (|String|))) "\\spad{setTex!(t,strings)} sets the TeX section of a TeX form \\spad{t} to strings.")) (|setEpilogue!| (((|List| (|String|)) $ (|List| (|String|))) "\\spad{setEpilogue!(t,strings)} sets the epilogue section of a TeX form \\spad{t} to strings.")) (|prologue| (((|List| (|String|)) $) "\\spad{prologue(t)} extracts the prologue section of a TeX form \\spad{t.}")) (|new| (($) "\\spad{new()} create a new, empty object. Use \\spadfun{setPrologue!}, \\spadfun{setTex!} and \\spadfun{setEpilogue!} to set the various components of this object.")) (|tex| (((|List| (|String|)) $) "\\spad{tex(t)} extracts the TeX section of a TeX form \\spad{t.}")) (|epilogue| (((|List| (|String|)) $) "\\spad{epilogue(t)} extracts the epilogue section of a TeX form \\spad{t.}")) (|display| (((|Void|) $) "\\spad{display(t)} outputs the TeX formatted code \\spad{t} so that each line has length less than or equal to the value set by the system command \\spadsyscom{set output length}.") (((|Void|) $ (|Integer|)) "\\spad{display(t,width)} outputs the TeX formatted code \\spad{t} so that each line has length less than or equal to \\spadvar{width}.")) (|convert| (($ (|OutputForm|) (|Integer|) (|OutputForm|)) "\\spad{convert(o,step,type)} changes \\spad{o} in standard output format to TeX format and also adds the given \\spad{step} number and type. This is useful if you want to create equations with given numbers or have the equation numbers correspond to the interpreter \\spad{step} numbers.") (($ (|OutputForm|) (|Integer|)) "\\spad{convert(o,step)} changes \\spad{o} in standard output format to TeX format and also adds the given \\spad{step} number. This is useful if you want to create equations with given numbers or have the equation numbers correspond to the interpreter \\spad{step} numbers.")) (|coerce| (($ (|OutputForm|)) "\\spad{coerce(o)} changes \\spad{o} in the standard output format to TeX format."))) 
NIL 
NIL 
(|TextFile|) 
((|constructor| (NIL "This domain provides an implementation of text files. Text is stored in these files using the native character set of the computer.")) (|endOfFile?| (((|Boolean|) $) "\\spad{endOfFile?(f)} tests whether the file \\spad{f} is positioned after the end of all text. If the file is open for output, then this test is always true.")) (|readIfCan!| (((|Union| (|String|) "failed") $) "\\spad{readIfCan!(f)} returns a string of the contents of a line from file \\spad{f,} if possible. If \\spad{f} is not readable or if it is positioned at the end of file, then \\spad{\"failed\"} is returned.")) (|readLineIfCan!| (((|Union| (|String|) "failed") $) "\\spad{readLineIfCan!(f)} returns a string of the contents of a line from file \\spad{f,} if possible. If \\spad{f} is not readable or if it is positioned at the end of file, then \\spad{\"failed\"} is returned.")) (|readLine!| (((|String|) $) "\\spad{readLine!(f)} returns a string of the contents of a line from the file \\spad{f.}")) (|writeLine!| (((|String|) $) "\\spad{writeLine!(f)} finishes the current line in the file \\spad{f.} An empty string is returned. The call \\spad{writeLine!(f)} is equivalent to \\spad{writeLine!(f,\"\")}.") (((|String|) $ (|String|)) "\\spad{writeLine!(f,s)} writes the contents of the string \\spad{s} and finishes the current line in the file \\spad{f.} The value of \\spad{s} is returned."))) 
NIL 
NIL 
(|ToolsForSign| R) 
((|constructor| (NIL "Tools for the sign finding utilities.")) (|direction| (((|Integer|) (|String|)) "\\spad{direction(s)} \\undocumented")) (|nonQsign| (((|Union| (|Integer|) "failed") |#1|) "\\spad{nonQsign(r)} \\undocumented")) (|sign| (((|Union| (|Integer|) "failed") |#1|) "\\spad{sign(r)} \\undocumented"))) 
NIL 
NIL 
(|TopLevelThreeSpace|) 
((|constructor| (NIL "This package exports a function for making a \\spadtype{ThreeSpace}")) (|createThreeSpace| (((|ThreeSpace| (|DoubleFloat|))) "\\spad{createThreeSpace()} creates a \\spadtype{ThreeSpace(DoubleFloat)} object capable of holding point, curve, mesh components and any combination."))) 
NIL 
NIL 
(|TranscendentalFunctionCategory&| S) 
((|constructor| (NIL "Category for the transcendental elementary functions.")) (|pi| (($) "\\spad{pi()} returns the constant pi."))) 
NIL 
NIL 
(|TranscendentalFunctionCategory|) 
((|constructor| (NIL "Category for the transcendental elementary functions.")) (|pi| (($) "\\spad{pi()} returns the constant pi."))) 
NIL 
NIL 
(|Tree| S) 
((|constructor| (NIL "\\spadtype{Tree(S)} is a basic domains of tree structures. Each tree is either empty or else is a node consisting of a value and a list of (sub)trees.")) (|cyclicParents| (((|List| $) $) "\\indented{1}{cyclicParents(t) returns a list of cycles that are parents of \\spad{t.}} \\blankline \\spad{X} t1:=tree [1,2,3,4] \\spad{X} cyclicParents \\spad{t1}")) (|cyclicEqual?| (((|Boolean|) $ $) "\\indented{1}{cyclicEqual?(t1, \\spad{t2)} tests of two cyclic trees have} \\indented{1}{the same structure.} \\blankline \\spad{X} t1:=tree [1,2,3,4] \\spad{X} t2:=tree [1,2,3,4] \\spad{X} cyclicEqual?(t1,t2)")) (|cyclicEntries| (((|List| $) $) "\\indented{1}{cyclicEntries(t) returns a list of top-level cycles in tree \\spad{t.}} \\blankline \\spad{X} t1:=tree [1,2,3,4] \\spad{X} cyclicEntries \\spad{t1}")) (|cyclicCopy| (($ $) "\\indented{1}{cyclicCopy(l) makes a copy of a (possibly) cyclic tree \\spad{l.}} \\blankline \\spad{X} t1:=tree [1,2,3,4] \\spad{X} cyclicCopy \\spad{t1}")) (|cyclic?| (((|Boolean|) $) "\\indented{1}{cyclic?(t) tests if \\spad{t} is a cyclic tree.} \\blankline \\spad{X} t1:=tree [1,2,3,4] \\spad{X} cyclic? \\spad{t1}")) (|tree| (($ |#1|) "\\indented{1}{tree(nd) creates a tree with value \\spad{nd,} and no children} \\blankline \\spad{X} tree 6") (($ (|List| |#1|)) "\\indented{1}{tree(ls) creates a tree from a list of elements of \\spad{s.}} \\blankline \\spad{X} tree [1,2,3,4]") (($ |#1| (|List| $)) "\\indented{1}{tree(nd,ls) creates a tree with value \\spad{nd,} and children ls.} \\blankline \\spad{X} t1:=tree [1,2,3,4] \\spad{X} tree(5,[t1])"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|))))) 
(|TrigonometricFunctionCategory&| S) 
((|constructor| (NIL "Category for the trigonometric functions.")) (|tan| (($ $) "\\spad{tan(x)} returns the tangent of \\spad{x.}")) (|sin| (($ $) "\\spad{sin(x)} returns the sine of \\spad{x.}")) (|sec| (($ $) "\\spad{sec(x)} returns the secant of \\spad{x.}")) (|csc| (($ $) "\\spad{csc(x)} returns the cosecant of \\spad{x.}")) (|cot| (($ $) "\\spad{cot(x)} returns the cotangent of \\spad{x.}")) (|cos| (($ $) "\\spad{cos(x)} returns the cosine of \\spad{x.}"))) 
NIL 
NIL 
(|TrigonometricFunctionCategory|) 
((|constructor| (NIL "Category for the trigonometric functions.")) (|tan| (($ $) "\\spad{tan(x)} returns the tangent of \\spad{x.}")) (|sin| (($ $) "\\spad{sin(x)} returns the sine of \\spad{x.}")) (|sec| (($ $) "\\spad{sec(x)} returns the secant of \\spad{x.}")) (|csc| (($ $) "\\spad{csc(x)} returns the cosecant of \\spad{x.}")) (|cot| (($ $) "\\spad{cot(x)} returns the cotangent of \\spad{x.}")) (|cos| (($ $) "\\spad{cos(x)} returns the cosine of \\spad{x.}"))) 
NIL 
NIL 
(|TrigonometricManipulations| R F) 
((|constructor| (NIL "\\spadtype{TrigonometricManipulations} provides transformations from trigonometric functions to complex exponentials and logarithms, and back.")) (|complexForm| (((|Complex| |#2|) |#2|) "\\spad{complexForm(f)} returns \\spad{[real \\spad{f,} imag f]}.")) (|real?| (((|Boolean|) |#2|) "\\spad{real?(f)} returns \\spad{true} if \\spad{f = real \\spad{f}.}")) (|imag| ((|#2| |#2|) "\\spad{imag(f)} returns the imaginary part of \\spad{f} where \\spad{f} is a complex function.")) (|real| ((|#2| |#2|) "\\spad{real(f)} returns the real part of \\spad{f} where \\spad{f} is a complex function.")) (|trigs| ((|#2| |#2|) "\\spad{trigs(f)} rewrites all the complex logs and exponentials appearing in \\spad{f} in terms of trigonometric functions.")) (|complexElementary| ((|#2| |#2| (|Symbol|)) "\\spad{complexElementary(f, \\spad{x)}} rewrites the kernels of \\spad{f} involving \\spad{x} in terms of the 2 fundamental complex transcendental elementary functions: \\spad{log, exp}.") ((|#2| |#2|) "\\spad{complexElementary(f)} rewrites \\spad{f} in terms of the 2 fundamental complex transcendental elementary functions: \\spad{log, exp}.")) (|complexNormalize| ((|#2| |#2| (|Symbol|)) "\\spad{complexNormalize(f, \\spad{x)}} rewrites \\spad{f} using the least possible number of complex independent kernels involving \\spad{x}.") ((|#2| |#2|) "\\spad{complexNormalize(f)} rewrites \\spad{f} using the least possible number of complex independent kernels."))) 
NIL 
NIL 
(|TriangularMatrixOperations| R |Row| |Col| M) 
((|constructor| (NIL "This package provides functions that compute \"fraction-free\" inverses of upper and lower triangular matrices over a integral domain. By \"fraction-free inverses\" we mean the following: given a matrix \\spad{B} with entries in \\spad{R} and an element \\spad{d} of \\spad{R} such that \\spad{d} * inv(B) also has entries in \\spad{R,} we return \\spad{d} * inv(B). Thus, it is not necessary to pass to the quotient field in any of our computations.")) (|LowTriBddDenomInv| ((|#4| |#4| |#1|) "\\spad{LowTriBddDenomInv(B,d)} returns \\spad{M,} where \\spad{B} is a non-singular lower triangular matrix and \\spad{d} is an element of \\spad{R} such that \\spad{M = \\spad{d} * inv(B)} has entries in \\spad{R.}")) (|UpTriBddDenomInv| ((|#4| |#4| |#1|) "\\spad{UpTriBddDenomInv(B,d)} returns \\spad{M,} where \\spad{B} is a non-singular upper triangular matrix and \\spad{d} is an element of \\spad{R} such that \\spad{M = \\spad{d} * inv(B)} has entries in \\spad{R.}"))) 
NIL 
NIL 
(|TranscendentalManipulations| R F) 
((|constructor| (NIL "TranscendentalManipulations provides functions to simplify and expand expressions involving transcendental operators.")) (|expandTrigProducts| ((|#2| |#2|) "\\spad{expandTrigProducts(e)} replaces \\axiom{sin(x)*sin(y)} by \\spad{(cos(x-y)-cos(x+y))/2}, \\axiom{cos(x)*cos(y)} by \\spad{(cos(x-y)+cos(x+y))/2}, and \\axiom{sin(x)*cos(y)} by \\spad{(sin(x-y)+sin(x+y))/2}. Note that this operation uses the pattern matcher and so is relatively expensive. To avoid getting into an infinite loop the transformations are applied at most ten times.")) (|removeSinhSq| ((|#2| |#2|) "\\spad{removeSinhSq(f)} converts every \\spad{sinh(u)**2} appearing in \\spad{f} into \\spad{1 - cosh(x)**2}, and also reduces higher powers of \\spad{sinh(u)} with that formula.")) (|removeCoshSq| ((|#2| |#2|) "\\spad{removeCoshSq(f)} converts every \\spad{cosh(u)**2} appearing in \\spad{f} into \\spad{1 - sinh(x)**2}, and also reduces higher powers of \\spad{cosh(u)} with that formula.")) (|removeSinSq| ((|#2| |#2|) "\\spad{removeSinSq(f)} converts every \\spad{sin(u)**2} appearing in \\spad{f} into \\spad{1 - cos(x)**2}, and also reduces higher powers of \\spad{sin(u)} with that formula.")) (|removeCosSq| ((|#2| |#2|) "\\spad{removeCosSq(f)} converts every \\spad{cos(u)**2} appearing in \\spad{f} into \\spad{1 - sin(x)**2}, and also reduces higher powers of \\spad{cos(u)} with that formula.")) (|coth2tanh| ((|#2| |#2|) "\\spad{coth2tanh(f)} converts every \\spad{coth(u)} appearing in \\spad{f} into \\spad{1/tanh(u)}.")) (|cot2tan| ((|#2| |#2|) "\\spad{cot2tan(f)} converts every \\spad{cot(u)} appearing in \\spad{f} into \\spad{1/tan(u)}.")) (|tanh2coth| ((|#2| |#2|) "\\spad{tanh2coth(f)} converts every \\spad{tanh(u)} appearing in \\spad{f} into \\spad{1/coth(u)}.")) (|tan2cot| ((|#2| |#2|) "\\spad{tan2cot(f)} converts every \\spad{tan(u)} appearing in \\spad{f} into \\spad{1/cot(u)}.")) (|tanh2trigh| ((|#2| |#2|) "\\spad{tanh2trigh(f)} converts every \\spad{tanh(u)} appearing in \\spad{f} into \\spad{sinh(u)/cosh(u)}.")) (|tan2trig| ((|#2| |#2|) "\\spad{tan2trig(f)} converts every \\spad{tan(u)} appearing in \\spad{f} into \\spad{sin(u)/cos(u)}.")) (|sinh2csch| ((|#2| |#2|) "\\spad{sinh2csch(f)} converts every \\spad{sinh(u)} appearing in \\spad{f} into \\spad{1/csch(u)}.")) (|sin2csc| ((|#2| |#2|) "\\spad{sin2csc(f)} converts every \\spad{sin(u)} appearing in \\spad{f} into \\spad{1/csc(u)}.")) (|sech2cosh| ((|#2| |#2|) "\\spad{sech2cosh(f)} converts every \\spad{sech(u)} appearing in \\spad{f} into \\spad{1/cosh(u)}.")) (|sec2cos| ((|#2| |#2|) "\\spad{sec2cos(f)} converts every \\spad{sec(u)} appearing in \\spad{f} into \\spad{1/cos(u)}.")) (|csch2sinh| ((|#2| |#2|) "\\spad{csch2sinh(f)} converts every \\spad{csch(u)} appearing in \\spad{f} into \\spad{1/sinh(u)}.")) (|csc2sin| ((|#2| |#2|) "\\spad{csc2sin(f)} converts every \\spad{csc(u)} appearing in \\spad{f} into \\spad{1/sin(u)}.")) (|coth2trigh| ((|#2| |#2|) "\\spad{coth2trigh(f)} converts every \\spad{coth(u)} appearing in \\spad{f} into \\spad{cosh(u)/sinh(u)}.")) (|cot2trig| ((|#2| |#2|) "\\spad{cot2trig(f)} converts every \\spad{cot(u)} appearing in \\spad{f} into \\spad{cos(u)/sin(u)}.")) (|cosh2sech| ((|#2| |#2|) "\\spad{cosh2sech(f)} converts every \\spad{cosh(u)} appearing in \\spad{f} into \\spad{1/sech(u)}.")) (|cos2sec| ((|#2| |#2|) "\\spad{cos2sec(f)} converts every \\spad{cos(u)} appearing in \\spad{f} into \\spad{1/sec(u)}.")) (|expandLog| ((|#2| |#2|) "\\spad{expandLog(f)} converts every \\spad{log(a/b)} appearing in \\spad{f} into \\spad{log(a) - log(b)}, and every \\spad{log(a*b)} into \\spad{log(a) + log(b)}..")) (|expandPower| ((|#2| |#2|) "\\spad{expandPower(f)} converts every power \\spad{(a/b)**c} appearing in \\spad{f} into \\spad{a**c * b**(-c)}.")) (|simplifyLog| ((|#2| |#2|) "\\spad{simplifyLog(f)} converts every \\spad{log(a) - log(b)} appearing in \\spad{f} into \\spad{log(a/b)}, every \\spad{log(a) + log(b)} into \\spad{log(a*b)} and every \\spad{n*log(a)} into \\spad{log(a^n)}.")) (|simplifyExp| ((|#2| |#2|) "\\spad{simplifyExp(f)} converts every product \\spad{exp(a)*exp(b)} appearing in \\spad{f} into \\spad{exp(a+b)}.")) (|htrigs| ((|#2| |#2|) "\\spad{htrigs(f)} converts all the exponentials in \\spad{f} into hyperbolic sines and cosines.")) (|simplify| ((|#2| |#2|) "\\spad{simplify(f)} performs the following simplifications on f:\\begin{items} \\item 1. rewrites trigs and hyperbolic trigs in terms of \\spad{sin} ,\\spad{cos}, \\spad{sinh}, \\spad{cosh}. \\item 2. rewrites \\spad{sin**2} and \\spad{sinh**2} in terms of \\spad{cos} and \\spad{cosh}, \\item 3. rewrites \\spad{exp(a)*exp(b)} as \\spad{exp(a+b)}. \\item 4. rewrites \\spad{(a**(1/n))**m * (a**(1/s))**t} as a single power of a single radical of \\spad{a}. \\end{items}")) (|expand| ((|#2| |#2|) "\\spad{expand(f)} performs the following expansions on f:\\begin{items} \\item 1. logs of products are expanded into sums of logs, \\item 2. trigonometric and hyperbolic trigonometric functions of sums are expanded into sums of products of trigonometric and hyperbolic trigonometric functions. \\item 3. formal powers of the form \\spad{(a/b)**c} are expanded into \\spad{a**c * b**(-c)}. \\end{items}"))) 
NIL 
((AND (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (|devaluate| |#1|)))) (|HasCategory| |#1| (LIST (QUOTE |PatternMatchable|) (|devaluate| |#1|))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (|devaluate| |#1|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (|devaluate| |#1|))))) 
(|TriangularSetCategory&| S R E V P) 
((|constructor| (NIL "The category of triangular sets of multivariate polynomials with coefficients in an integral domain. Let \\axiom{R} be an integral domain and \\axiom{V} a finite ordered set of variables, say \\axiom{X1 < \\spad{X2} < \\spad{...} < Xn}. A set \\axiom{S} of polynomials in \\axiom{R[X1,X2,...,Xn]} is triangular if no elements of \\axiom{S} lies in \\axiom{R}, and if two distinct elements of \\axiom{S} have distinct main variables. Note that the empty set is a triangular set. A triangular set is not necessarily a (lexicographical) Groebner basis and the notion of reduction related to triangular sets is based on the recursive view of polynomials. We recall this notion here and refer to \\spad{[1]} for more details. A polynomial \\axiom{P} is reduced w.r.t a non-constant polynomial \\axiom{Q} if the degree of \\axiom{P} in the main variable of \\axiom{Q} is less than the main degree of \\axiom{Q}. A polynomial \\axiom{P} is reduced w.r.t a triangular set \\axiom{T} if it is reduced w.r.t. every polynomial of \\axiom{T}.")) (|coHeight| (((|NonNegativeInteger|) $) "\\axiom{coHeight(ts)} returns \\axiom{size()\\$V} minus \\axiom{\\#ts}.")) (|extend| (($ $ |#5|) "\\axiom{extend(ts,p)} returns a triangular set which encodes the simple extension by \\axiom{p} of the extension of the base field defined by \\axiom{ts}, according to the properties of triangular sets of the current category. If the required properties do not hold an error is returned.")) (|extendIfCan| (((|Union| $ "failed") $ |#5|) "\\axiom{extendIfCan(ts,p)} returns a triangular set which encodes the simple extension by \\axiom{p} of the extension of the base field defined by \\axiom{ts}, according to the properties of triangular sets of the current domain. If the required properties do not hold then \"failed\" is returned. This operation encodes in some sense the properties of the triangular sets of the current category. Is is used to implement the \\axiom{construct} operation to guarantee that every triangular set build from a list of polynomials has the required properties.")) (|select| (((|Union| |#5| "failed") $ |#4|) "\\axiom{select(ts,v)} returns the polynomial of \\axiom{ts} with \\axiom{v} as main variable, if any.")) (|algebraic?| (((|Boolean|) |#4| $) "\\axiom{algebraic?(v,ts)} returns \\spad{true} iff \\axiom{v} is the main variable of some polynomial in \\axiom{ts}.")) (|algebraicVariables| (((|List| |#4|) $) "\\axiom{algebraicVariables(ts)} returns the decreasingly sorted list of the main variables of the polynomials of \\axiom{ts}.")) (|rest| (((|Union| $ "failed") $) "\\axiom{rest(ts)} returns the polynomials of \\axiom{ts} with smaller main variable than \\axiom{mvar(ts)} if \\axiom{ts} is not empty, otherwise returns \"failed\"")) (|last| (((|Union| |#5| "failed") $) "\\axiom{last(ts)} returns the polynomial of \\axiom{ts} with smallest main variable if \\axiom{ts} is not empty, otherwise returns \\axiom{\"failed\"}.")) (|first| (((|Union| |#5| "failed") $) "\\axiom{first(ts)} returns the polynomial of \\axiom{ts} with greatest main variable if \\axiom{ts} is not empty, otherwise returns \\axiom{\"failed\"}.")) (|zeroSetSplitIntoTriangularSystems| (((|List| (|Record| (|:| |close| $) (|:| |open| (|List| |#5|)))) (|List| |#5|)) "\\axiom{zeroSetSplitIntoTriangularSystems(lp)} returns a list of triangular systems \\axiom{[[ts1,qs1],...,[tsn,qsn]]} such that the zero set of \\axiom{lp} is the union of the closures of the \\axiom{W_i} where \\axiom{W_i} consists of the zeros of \\axiom{ts} which do not cancel any polynomial in \\axiom{qsi}.")) (|zeroSetSplit| (((|List| $) (|List| |#5|)) "\\axiom{zeroSetSplit(lp)} returns a list \\axiom{lts} of triangular sets such that the zero set of \\axiom{lp} is the union of the closures of the regular zero sets of the members of \\axiom{lts}.")) (|reduceByQuasiMonic| ((|#5| |#5| $) "\\axiom{reduceByQuasiMonic(p,ts)} returns the same as \\axiom{remainder(p,collectQuasiMonic(ts)).polnum}.")) (|collectQuasiMonic| (($ $) "\\axiom{collectQuasiMonic(ts)} returns the subset of \\axiom{ts} consisting of the polynomials with initial in \\axiom{R}.")) (|removeZero| ((|#5| |#5| $) "\\axiom{removeZero(p,ts)} returns \\axiom{0} if \\axiom{p} reduces to \\axiom{0} by pseudo-division w.r.t \\axiom{ts} otherwise returns a polynomial \\axiom{q} computed from \\axiom{p} by removing any coefficient in \\axiom{p} reducing to \\axiom{0}.")) (|initiallyReduce| ((|#5| |#5| $) "\\axiom{initiallyReduce(p,ts)} returns a polynomial \\axiom{r} such that \\axiom{initiallyReduced?(r,ts)} holds and there exists some product \\axiom{h} of \\axiom{initials(ts)} such that \\axiom{h*p - \\spad{r}} lies in the ideal generated by \\axiom{ts}.")) (|headReduce| ((|#5| |#5| $) "\\axiom{headReduce(p,ts)} returns a polynomial \\axiom{r} such that \\axiom{headReduce?(r,ts)} holds and there exists some product \\axiom{h} of \\axiom{initials(ts)} such that \\axiom{h*p - \\spad{r}} lies in the ideal generated by \\axiom{ts}.")) (|stronglyReduce| ((|#5| |#5| $) "\\axiom{stronglyReduce(p,ts)} returns a polynomial \\axiom{r} such that \\axiom{stronglyReduced?(r,ts)} holds and there exists some product \\axiom{h} of \\axiom{initials(ts)} such that \\axiom{h*p - \\spad{r}} lies in the ideal generated by \\axiom{ts}.")) (|rewriteSetWithReduction| (((|List| |#5|) (|List| |#5|) $ (|Mapping| |#5| |#5| |#5|) (|Mapping| (|Boolean|) |#5| |#5|)) "\\axiom{rewriteSetWithReduction(lp,ts,redOp,redOp?)} returns a list \\axiom{lq} of polynomials such that \\axiom{[reduce(p,ts,redOp,redOp?) for \\spad{p} in lp]} and \\axiom{lp} have the same zeros inside the regular zero set of \\axiom{ts}. Moreover, for every polynomial \\axiom{q} in \\axiom{lq} and every polynomial \\axiom{t} in \\axiom{ts} \\axiom{redOp?(q,t)} holds and there exists a polynomial \\axiom{p} in the ideal generated by \\axiom{lp} and a product \\axiom{h} of \\axiom{initials(ts)} such that \\axiom{h*p - \\spad{r}} lies in the ideal generated by \\axiom{ts}. The operation \\axiom{redOp} must satisfy the following conditions. For every \\axiom{p} and \\axiom{q} we have \\axiom{redOp?(redOp(p,q),q)} and there exists an integer \\axiom{e} and a polynomial \\axiom{f} such that \\axiom{init(q)^e*p = \\spad{f*q} + redOp(p,q)}.")) (|reduce| ((|#5| |#5| $ (|Mapping| |#5| |#5| |#5|) (|Mapping| (|Boolean|) |#5| |#5|)) "\\axiom{reduce(p,ts,redOp,redOp?)} returns a polynomial \\axiom{r} such that \\axiom{redOp?(r,p)} holds for every \\axiom{p} of \\axiom{ts} and there exists some product \\axiom{h} of the initials of the members of \\axiom{ts} such that \\axiom{h*p - \\spad{r}} lies in the ideal generated by \\axiom{ts}. The operation \\axiom{redOp} must satisfy the following conditions. For every \\axiom{p} and \\axiom{q} we have \\axiom{redOp?(redOp(p,q),q)} and there exists an integer \\axiom{e} and a polynomial \\axiom{f} such that \\axiom{init(q)^e*p = \\spad{f*q} + redOp(p,q)}.")) (|autoReduced?| (((|Boolean|) $ (|Mapping| (|Boolean|) |#5| (|List| |#5|))) "\\axiom{autoReduced?(ts,redOp?)} returns \\spad{true} iff every element of \\axiom{ts} is reduced w.r.t to every other in the sense of \\axiom{redOp?}")) (|initiallyReduced?| (((|Boolean|) $) "\\spad{initiallyReduced?(ts)} returns \\spad{true} iff for every element \\axiom{p} of \\axiom{ts}. \\axiom{p} and all its iterated initials are reduced w.r.t. to the other elements of \\axiom{ts} with the same main variable.") (((|Boolean|) |#5| $) "\\axiom{initiallyReduced?(p,ts)} returns \\spad{true} iff \\axiom{p} and all its iterated initials are reduced w.r.t. to the elements of \\axiom{ts} with the same main variable.")) (|headReduced?| (((|Boolean|) $) "\\spad{headReduced?(ts)} returns \\spad{true} iff the head of every element of \\axiom{ts} is reduced w.r.t to any other element of \\axiom{ts}.") (((|Boolean|) |#5| $) "\\axiom{headReduced?(p,ts)} returns \\spad{true} iff the head of \\axiom{p} is reduced w.r.t. \\axiom{ts}.")) (|stronglyReduced?| (((|Boolean|) $) "\\axiom{stronglyReduced?(ts)} returns \\spad{true} iff every element of \\axiom{ts} is reduced w.r.t to any other element of \\axiom{ts}.") (((|Boolean|) |#5| $) "\\axiom{stronglyReduced?(p,ts)} returns \\spad{true} iff \\axiom{p} is reduced w.r.t. \\axiom{ts}.")) (|reduced?| (((|Boolean|) |#5| $ (|Mapping| (|Boolean|) |#5| |#5|)) "\\axiom{reduced?(p,ts,redOp?)} returns \\spad{true} iff \\axiom{p} is reduced w.r.t.in the sense of the operation \\axiom{redOp?}, that is if for every \\axiom{t} in \\axiom{ts} \\axiom{redOp?(p,t)} holds.")) (|normalized?| (((|Boolean|) $) "\\axiom{normalized?(ts)} returns \\spad{true} iff for every axiom{p} in \\axiom{ts} we have \\axiom{normalized?(p,us)} where \\axiom{us} is \\axiom{collectUnder(ts,mvar(p))}.") (((|Boolean|) |#5| $) "\\axiom{normalized?(p,ts)} returns \\spad{true} iff \\axiom{p} and all its iterated initials have degree zero w.r.t. the main variables of the polynomials of \\axiom{ts}")) (|quasiComponent| (((|Record| (|:| |close| (|List| |#5|)) (|:| |open| (|List| |#5|))) $) "\\axiom{quasiComponent(ts)} returns \\axiom{[lp,lq]} where \\axiom{lp} is the list of the members of \\axiom{ts} and \\axiom{lq}is \\axiom{initials(ts)}.")) (|degree| (((|NonNegativeInteger|) $) "\\axiom{degree(ts)} returns the product of main degrees of the members of \\axiom{ts}.")) (|initials| (((|List| |#5|) $) "\\axiom{initials(ts)} returns the list of the non-constant initials of the members of \\axiom{ts}.")) (|basicSet| (((|Union| (|Record| (|:| |bas| $) (|:| |top| (|List| |#5|))) "failed") (|List| |#5|) (|Mapping| (|Boolean|) |#5|) (|Mapping| (|Boolean|) |#5| |#5|)) "\\axiom{basicSet(ps,pred?,redOp?)} returns the same as \\axiom{basicSet(qs,redOp?)} where \\axiom{qs} consists of the polynomials of \\axiom{ps} satisfying property \\axiom{pred?}.") (((|Union| (|Record| (|:| |bas| $) (|:| |top| (|List| |#5|))) "failed") (|List| |#5|) (|Mapping| (|Boolean|) |#5| |#5|)) "\\axiom{basicSet(ps,redOp?)} returns \\axiom{[bs,ts]} where \\axiom{concat(bs,ts)} is \\axiom{ps} and \\axiom{bs} is a basic set in Wu Wen Tsun sense of \\axiom{ps} w.r.t the reduction-test \\axiom{redOp?}, if no non-zero constant polynomial lie in \\axiom{ps}, otherwise \\axiom{\"failed\"} is returned.")) (|infRittWu?| (((|Boolean|) $ $) "\\axiom{infRittWu?(ts1,ts2)} returns \\spad{true} iff \\axiom{ts2} has higher rank than \\axiom{ts1} in Wu Wen Tsun sense."))) 
NIL 
((|HasCategory| |#4| (QUOTE (|Finite|)))) 
(|TriangularSetCategory| R E V P) 
((|constructor| (NIL "The category of triangular sets of multivariate polynomials with coefficients in an integral domain. Let \\axiom{R} be an integral domain and \\axiom{V} a finite ordered set of variables, say \\axiom{X1 < \\spad{X2} < \\spad{...} < Xn}. A set \\axiom{S} of polynomials in \\axiom{R[X1,X2,...,Xn]} is triangular if no elements of \\axiom{S} lies in \\axiom{R}, and if two distinct elements of \\axiom{S} have distinct main variables. Note that the empty set is a triangular set. A triangular set is not necessarily a (lexicographical) Groebner basis and the notion of reduction related to triangular sets is based on the recursive view of polynomials. We recall this notion here and refer to \\spad{[1]} for more details. A polynomial \\axiom{P} is reduced w.r.t a non-constant polynomial \\axiom{Q} if the degree of \\axiom{P} in the main variable of \\axiom{Q} is less than the main degree of \\axiom{Q}. A polynomial \\axiom{P} is reduced w.r.t a triangular set \\axiom{T} if it is reduced w.r.t. every polynomial of \\axiom{T}.")) (|coHeight| (((|NonNegativeInteger|) $) "\\axiom{coHeight(ts)} returns \\axiom{size()\\$V} minus \\axiom{\\#ts}.")) (|extend| (($ $ |#4|) "\\axiom{extend(ts,p)} returns a triangular set which encodes the simple extension by \\axiom{p} of the extension of the base field defined by \\axiom{ts}, according to the properties of triangular sets of the current category. If the required properties do not hold an error is returned.")) (|extendIfCan| (((|Union| $ "failed") $ |#4|) "\\axiom{extendIfCan(ts,p)} returns a triangular set which encodes the simple extension by \\axiom{p} of the extension of the base field defined by \\axiom{ts}, according to the properties of triangular sets of the current domain. If the required properties do not hold then \"failed\" is returned. This operation encodes in some sense the properties of the triangular sets of the current category. Is is used to implement the \\axiom{construct} operation to guarantee that every triangular set build from a list of polynomials has the required properties.")) (|select| (((|Union| |#4| "failed") $ |#3|) "\\axiom{select(ts,v)} returns the polynomial of \\axiom{ts} with \\axiom{v} as main variable, if any.")) (|algebraic?| (((|Boolean|) |#3| $) "\\axiom{algebraic?(v,ts)} returns \\spad{true} iff \\axiom{v} is the main variable of some polynomial in \\axiom{ts}.")) (|algebraicVariables| (((|List| |#3|) $) "\\axiom{algebraicVariables(ts)} returns the decreasingly sorted list of the main variables of the polynomials of \\axiom{ts}.")) (|rest| (((|Union| $ "failed") $) "\\axiom{rest(ts)} returns the polynomials of \\axiom{ts} with smaller main variable than \\axiom{mvar(ts)} if \\axiom{ts} is not empty, otherwise returns \"failed\"")) (|last| (((|Union| |#4| "failed") $) "\\axiom{last(ts)} returns the polynomial of \\axiom{ts} with smallest main variable if \\axiom{ts} is not empty, otherwise returns \\axiom{\"failed\"}.")) (|first| (((|Union| |#4| "failed") $) "\\axiom{first(ts)} returns the polynomial of \\axiom{ts} with greatest main variable if \\axiom{ts} is not empty, otherwise returns \\axiom{\"failed\"}.")) (|zeroSetSplitIntoTriangularSystems| (((|List| (|Record| (|:| |close| $) (|:| |open| (|List| |#4|)))) (|List| |#4|)) "\\axiom{zeroSetSplitIntoTriangularSystems(lp)} returns a list of triangular systems \\axiom{[[ts1,qs1],...,[tsn,qsn]]} such that the zero set of \\axiom{lp} is the union of the closures of the \\axiom{W_i} where \\axiom{W_i} consists of the zeros of \\axiom{ts} which do not cancel any polynomial in \\axiom{qsi}.")) (|zeroSetSplit| (((|List| $) (|List| |#4|)) "\\axiom{zeroSetSplit(lp)} returns a list \\axiom{lts} of triangular sets such that the zero set of \\axiom{lp} is the union of the closures of the regular zero sets of the members of \\axiom{lts}.")) (|reduceByQuasiMonic| ((|#4| |#4| $) "\\axiom{reduceByQuasiMonic(p,ts)} returns the same as \\axiom{remainder(p,collectQuasiMonic(ts)).polnum}.")) (|collectQuasiMonic| (($ $) "\\axiom{collectQuasiMonic(ts)} returns the subset of \\axiom{ts} consisting of the polynomials with initial in \\axiom{R}.")) (|removeZero| ((|#4| |#4| $) "\\axiom{removeZero(p,ts)} returns \\axiom{0} if \\axiom{p} reduces to \\axiom{0} by pseudo-division w.r.t \\axiom{ts} otherwise returns a polynomial \\axiom{q} computed from \\axiom{p} by removing any coefficient in \\axiom{p} reducing to \\axiom{0}.")) (|initiallyReduce| ((|#4| |#4| $) "\\axiom{initiallyReduce(p,ts)} returns a polynomial \\axiom{r} such that \\axiom{initiallyReduced?(r,ts)} holds and there exists some product \\axiom{h} of \\axiom{initials(ts)} such that \\axiom{h*p - \\spad{r}} lies in the ideal generated by \\axiom{ts}.")) (|headReduce| ((|#4| |#4| $) "\\axiom{headReduce(p,ts)} returns a polynomial \\axiom{r} such that \\axiom{headReduce?(r,ts)} holds and there exists some product \\axiom{h} of \\axiom{initials(ts)} such that \\axiom{h*p - \\spad{r}} lies in the ideal generated by \\axiom{ts}.")) (|stronglyReduce| ((|#4| |#4| $) "\\axiom{stronglyReduce(p,ts)} returns a polynomial \\axiom{r} such that \\axiom{stronglyReduced?(r,ts)} holds and there exists some product \\axiom{h} of \\axiom{initials(ts)} such that \\axiom{h*p - \\spad{r}} lies in the ideal generated by \\axiom{ts}.")) (|rewriteSetWithReduction| (((|List| |#4|) (|List| |#4|) $ (|Mapping| |#4| |#4| |#4|) (|Mapping| (|Boolean|) |#4| |#4|)) "\\axiom{rewriteSetWithReduction(lp,ts,redOp,redOp?)} returns a list \\axiom{lq} of polynomials such that \\axiom{[reduce(p,ts,redOp,redOp?) for \\spad{p} in lp]} and \\axiom{lp} have the same zeros inside the regular zero set of \\axiom{ts}. Moreover, for every polynomial \\axiom{q} in \\axiom{lq} and every polynomial \\axiom{t} in \\axiom{ts} \\axiom{redOp?(q,t)} holds and there exists a polynomial \\axiom{p} in the ideal generated by \\axiom{lp} and a product \\axiom{h} of \\axiom{initials(ts)} such that \\axiom{h*p - \\spad{r}} lies in the ideal generated by \\axiom{ts}. The operation \\axiom{redOp} must satisfy the following conditions. For every \\axiom{p} and \\axiom{q} we have \\axiom{redOp?(redOp(p,q),q)} and there exists an integer \\axiom{e} and a polynomial \\axiom{f} such that \\axiom{init(q)^e*p = \\spad{f*q} + redOp(p,q)}.")) (|reduce| ((|#4| |#4| $ (|Mapping| |#4| |#4| |#4|) (|Mapping| (|Boolean|) |#4| |#4|)) "\\axiom{reduce(p,ts,redOp,redOp?)} returns a polynomial \\axiom{r} such that \\axiom{redOp?(r,p)} holds for every \\axiom{p} of \\axiom{ts} and there exists some product \\axiom{h} of the initials of the members of \\axiom{ts} such that \\axiom{h*p - \\spad{r}} lies in the ideal generated by \\axiom{ts}. The operation \\axiom{redOp} must satisfy the following conditions. For every \\axiom{p} and \\axiom{q} we have \\axiom{redOp?(redOp(p,q),q)} and there exists an integer \\axiom{e} and a polynomial \\axiom{f} such that \\axiom{init(q)^e*p = \\spad{f*q} + redOp(p,q)}.")) (|autoReduced?| (((|Boolean|) $ (|Mapping| (|Boolean|) |#4| (|List| |#4|))) "\\axiom{autoReduced?(ts,redOp?)} returns \\spad{true} iff every element of \\axiom{ts} is reduced w.r.t to every other in the sense of \\axiom{redOp?}")) (|initiallyReduced?| (((|Boolean|) $) "\\spad{initiallyReduced?(ts)} returns \\spad{true} iff for every element \\axiom{p} of \\axiom{ts}. \\axiom{p} and all its iterated initials are reduced w.r.t. to the other elements of \\axiom{ts} with the same main variable.") (((|Boolean|) |#4| $) "\\axiom{initiallyReduced?(p,ts)} returns \\spad{true} iff \\axiom{p} and all its iterated initials are reduced w.r.t. to the elements of \\axiom{ts} with the same main variable.")) (|headReduced?| (((|Boolean|) $) "\\spad{headReduced?(ts)} returns \\spad{true} iff the head of every element of \\axiom{ts} is reduced w.r.t to any other element of \\axiom{ts}.") (((|Boolean|) |#4| $) "\\axiom{headReduced?(p,ts)} returns \\spad{true} iff the head of \\axiom{p} is reduced w.r.t. \\axiom{ts}.")) (|stronglyReduced?| (((|Boolean|) $) "\\axiom{stronglyReduced?(ts)} returns \\spad{true} iff every element of \\axiom{ts} is reduced w.r.t to any other element of \\axiom{ts}.") (((|Boolean|) |#4| $) "\\axiom{stronglyReduced?(p,ts)} returns \\spad{true} iff \\axiom{p} is reduced w.r.t. \\axiom{ts}.")) (|reduced?| (((|Boolean|) |#4| $ (|Mapping| (|Boolean|) |#4| |#4|)) "\\axiom{reduced?(p,ts,redOp?)} returns \\spad{true} iff \\axiom{p} is reduced w.r.t.in the sense of the operation \\axiom{redOp?}, that is if for every \\axiom{t} in \\axiom{ts} \\axiom{redOp?(p,t)} holds.")) (|normalized?| (((|Boolean|) $) "\\axiom{normalized?(ts)} returns \\spad{true} iff for every axiom{p} in \\axiom{ts} we have \\axiom{normalized?(p,us)} where \\axiom{us} is \\axiom{collectUnder(ts,mvar(p))}.") (((|Boolean|) |#4| $) "\\axiom{normalized?(p,ts)} returns \\spad{true} iff \\axiom{p} and all its iterated initials have degree zero w.r.t. the main variables of the polynomials of \\axiom{ts}")) (|quasiComponent| (((|Record| (|:| |close| (|List| |#4|)) (|:| |open| (|List| |#4|))) $) "\\axiom{quasiComponent(ts)} returns \\axiom{[lp,lq]} where \\axiom{lp} is the list of the members of \\axiom{ts} and \\axiom{lq}is \\axiom{initials(ts)}.")) (|degree| (((|NonNegativeInteger|) $) "\\axiom{degree(ts)} returns the product of main degrees of the members of \\axiom{ts}.")) (|initials| (((|List| |#4|) $) "\\axiom{initials(ts)} returns the list of the non-constant initials of the members of \\axiom{ts}.")) (|basicSet| (((|Union| (|Record| (|:| |bas| $) (|:| |top| (|List| |#4|))) "failed") (|List| |#4|) (|Mapping| (|Boolean|) |#4|) (|Mapping| (|Boolean|) |#4| |#4|)) "\\axiom{basicSet(ps,pred?,redOp?)} returns the same as \\axiom{basicSet(qs,redOp?)} where \\axiom{qs} consists of the polynomials of \\axiom{ps} satisfying property \\axiom{pred?}.") (((|Union| (|Record| (|:| |bas| $) (|:| |top| (|List| |#4|))) "failed") (|List| |#4|) (|Mapping| (|Boolean|) |#4| |#4|)) "\\axiom{basicSet(ps,redOp?)} returns \\axiom{[bs,ts]} where \\axiom{concat(bs,ts)} is \\axiom{ps} and \\axiom{bs} is a basic set in Wu Wen Tsun sense of \\axiom{ps} w.r.t the reduction-test \\axiom{redOp?}, if no non-zero constant polynomial lie in \\axiom{ps}, otherwise \\axiom{\"failed\"} is returned.")) (|infRittWu?| (((|Boolean|) $ $) "\\axiom{infRittWu?(ts1,ts2)} returns \\spad{true} iff \\axiom{ts2} has higher rank than \\axiom{ts1} in Wu Wen Tsun sense."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|TaylorSeries| |Coef|) 
((|constructor| (NIL "\\spadtype{TaylorSeries} is a general multivariate Taylor series domain over the ring Coef and with variables of type Symbol.")) (|fintegrate| (($ (|Mapping| $) (|Symbol|) |#1|) "\\spad{fintegrate(f,v,c)} is the integral of \\spad{f()} with respect \\indented{1}{to \\spad{v} and having \\spad{c} as the constant of integration.} \\indented{1}{The evaluation of \\spad{f()} is delayed.}")) (|integrate| (($ $ (|Symbol|) |#1|) "\\spad{integrate(s,v,c)} is the integral of \\spad{s} with respect \\indented{1}{to \\spad{v} and having \\spad{c} as the constant of integration.}")) (|coerce| (($ (|Polynomial| |#1|)) "\\spad{coerce(s)} regroups terms of \\spad{s} by total degree \\indented{1}{and forms a series.}") (($ (|Symbol|)) "\\spad{coerce(s)} converts a variable to a Taylor series")) (|coefficient| (((|Polynomial| |#1|) $ (|NonNegativeInteger|)) "\\spad{coefficient(s, \\spad{n)}} gives the terms of total degree \\spad{n.}"))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) 
(|TubePlot| |Curve|) 
((|constructor| (NIL "Package for constructing tubes around 3-dimensional parametric curves. Domain of tubes around 3-dimensional parametric curves.")) (|tube| (($ |#1| (|List| (|List| (|Point| (|DoubleFloat|)))) (|Boolean|)) "\\spad{tube(c,ll,b)} creates a tube of the domain \\spadtype{TubePlot} from a space curve \\spad{c} of the category \\spadtype{PlottableSpaceCurveCategory}, a list of lists of points (loops) \\spad{ll} and a boolean \\spad{b} which if \\spad{true} indicates a closed tube, or if \\spad{false} an open tube.")) (|setClosed| (((|Boolean|) $ (|Boolean|)) "\\spad{setClosed(t,b)} declares the given tube plot \\spad{t} to be closed if \\spad{b} is true, or if \\spad{b} is false, \\spad{t} is set to be open.")) (|open?| (((|Boolean|) $) "\\spad{open?(t)} tests whether the given tube plot \\spad{t} is open.")) (|closed?| (((|Boolean|) $) "\\spad{closed?(t)} tests whether the given tube plot \\spad{t} is closed.")) (|listLoops| (((|List| (|List| (|Point| (|DoubleFloat|)))) $) "\\spad{listLoops(t)} returns the list of lists of points, or the 'loops', of the given tube plot \\spad{t.}")) (|getCurve| ((|#1| $) "\\spad{getCurve(t)} returns the \\spadtype{PlottableSpaceCurveCategory} representing the parametric curve of the given tube plot \\spad{t.}"))) 
NIL 
NIL 
(|TubePlotTools|) 
((|constructor| (NIL "Tools for constructing tubes around 3-dimensional parametric curves.")) (|loopPoints| (((|List| (|Point| (|DoubleFloat|))) (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|)) (|DoubleFloat|) (|List| (|List| (|DoubleFloat|)))) "\\spad{loopPoints(p,n,b,r,lls)} creates and returns a list of points which form the loop with radius \\spad{r,} around the center point indicated by the point \\spad{p,} with the principal normal vector of the space curve at point \\spad{p} given by the point(vector) \\spad{n,} and the binormal vector given by the point(vector) \\spad{b,} and a list of lists, lls, which is the \\spadfun{cosSinInfo} of the number of points defining the loop.")) (|cosSinInfo| (((|List| (|List| (|DoubleFloat|))) (|Integer|)) "\\spad{cosSinInfo(n)} returns the list of lists of values for \\spad{n,} in the form \\spad{[[cos(n-1) a,sin(n-1) a],...,[cos 2 a,sin 2 a],[cos a,sin a]]} where \\spad{a = 2 pi/n}. Note that \\spad{n} should be greater than 2.")) (|unitVector| (((|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|))) "\\spad{unitVector(p)} creates the unit vector of the point \\spad{p} and returns the result as a point. Note that \\spad{unitVector(p) = p/|p|}.")) (|cross| (((|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|))) "\\spad{cross(p,q)} computes the cross product of the two points \\spad{p} and \\spad{q} using only the first three coordinates, and keeping the color of the first point \\spad{p.} The result is returned as a point.")) (|dot| (((|DoubleFloat|) (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|))) "\\spad{dot(p,q)} computes the dot product of the two points \\spad{p} and \\spad{q} using only the first three coordinates, and returns the resulting \\spadtype{DoubleFloat}.")) (- (((|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|))) "\\spad{p - \\spad{q}} computes and returns a point whose coordinates are the differences of the coordinates of two points \\spad{p} and \\spad{q}, using the color, or fourth coordinate, of the first point \\spad{p} as the color also of the point \\spad{q}.")) (+ (((|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|)) (|Point| (|DoubleFloat|))) "\\spad{p + \\spad{q}} computes and returns a point whose coordinates are the sums of the coordinates of the two points \\spad{p} and \\spad{q}, using the color, or fourth coordinate, of the first point \\spad{p} as the color also of the point \\spad{q}.")) (* (((|Point| (|DoubleFloat|)) (|DoubleFloat|) (|Point| (|DoubleFloat|))) "\\spad{s * \\spad{p}} returns a point whose coordinates are the scalar multiple of the point \\spad{p} by the scalar \\spad{s,} preserving the color, or fourth coordinate, of \\spad{p.}")) (|point| (((|Point| (|DoubleFloat|)) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|)) "\\spad{point(x1,x2,x3,c)} creates and returns a point from the three specified coordinates \\spad{x1}, \\spad{x2}, \\spad{x3}, and also a fourth coordinate, \\spad{c,} which is generally used to specify the color of the point."))) 
NIL 
NIL 
(|Tuple| S) 
((|constructor| (NIL "This domain is used to interface with the interpreter's notion of comma-delimited sequences of values.")) (|length| (((|NonNegativeInteger|) $) "\\indented{1}{length(x) returns the number of elements in tuple \\spad{x}} \\blankline \\spad{X} t1:PrimitiveArray(Integer):= \\spad{[i} for \\spad{i} in 1..10] \\spad{X} t2:=coerce(t1)$Tuple(Integer) \\spad{X} length(t2)")) (|select| ((|#1| $ (|NonNegativeInteger|)) "\\indented{1}{select(x,n) returns the \\spad{n}-th element of tuple \\spad{x.}} \\indented{1}{tuples are 0-based} \\blankline \\spad{X} t1:PrimitiveArray(Integer):= \\spad{[i} for \\spad{i} in 1..10] \\spad{X} t2:=coerce(t1)$Tuple(Integer) \\spad{X} select(t2,3)")) (|coerce| (($ (|PrimitiveArray| |#1|)) "\\indented{1}{coerce(a) makes a tuple from primitive array a} \\blankline \\spad{X} t1:PrimitiveArray(Integer):= \\spad{[i} for \\spad{i} in 1..10] \\spad{X} t2:=coerce(t1)$Tuple(Integer)"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|SetCategory|)))) 
(|TwoFactorize| F) 
((|constructor| (NIL "A basic package for the factorization of bivariate polynomials over a finite field. The functions here represent the base step for the multivariate factorizer.")) (|twoFactor| (((|Factored| (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|))) (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|)) (|Integer|)) "\\spad{twoFactor(p,n)} returns the factorisation of polynomial \\spad{p,} a sparse univariate polynomial (sup) over a sup over \\spad{F.} Also, \\spad{p} is assumed primitive and square-free and \\spad{n} is the degree of the inner variable of \\spad{p} (maximum of the degrees of the coefficients of \\spad{p).}")) (|generalSqFr| (((|Factored| (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|))) (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|))) "\\spad{generalSqFr(p)} returns the square-free factorisation of polynomial \\spad{p,} a sparse univariate polynomial (sup) over a sup over \\spad{F.}")) (|generalTwoFactor| (((|Factored| (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|))) (|SparseUnivariatePolynomial| (|SparseUnivariatePolynomial| |#1|))) "\\spad{generalTwoFactor(p)} returns the factorisation of polynomial \\spad{p,} a sparse univariate polynomial (sup) over a sup over \\spad{F.}"))) 
NIL 
NIL 
(|Type|) 
((|constructor| (NIL "The fundamental Type."))) 
((|nil| . T)) 
NIL 
(|U16Matrix|) 
((|constructor| (NIL "This is a low-level domain which implements matrices (two dimensional arrays) of 16-bit integers. Indexing is 0 based, there is no bound checking (unless provided by lower level).")) (|qnew| (($ (|Integer|) (|Integer|)) "\\indented{1}{qnew(n, \\spad{m)} creates a new \\spad{n} by \\spad{m} matrix of zeros.} \\blankline \\spad{X} qnew(3,4)$U16Matrix()"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Integer|) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|Integer|) (QUOTE (|IntegralDomain|))) (|HasAttribute| (|Integer|) (QUOTE (|commutative| "*"))) (|HasCategory| (|Integer|) (QUOTE (|CommutativeRing|))) (|HasCategory| (|Integer|) (QUOTE (|Field|)))) 
(|U16Vector|) 
((|constructor| (NIL "\\indented{2}{fill!(x, \\spad{s)} modifies a vector \\spad{x} so every element has value \\spad{s}} \\blankline \\spad{X} t1:=new(10,7)$U16Vector \\spad{X} fill!(t1,9)"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| (|Integer|) (QUOTE (|SetCategory|))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (OR (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Integer|) (QUOTE (|SetCategory|)))) (AND (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|)))) (AND (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|SetCategory|)))))) 
(|U32Matrix|) 
((|constructor| (NIL "This is a low-level domain which implements matrices (two dimensional arrays) of 32-bit integers. Indexing is 0 based, there is no bound checking (unless provided by lower level).")) (|qnew| (($ (|Integer|) (|Integer|)) "\\indented{1}{qnew(n, \\spad{m)} creates a new \\spad{n} by \\spad{m} matrix of zeros.} \\blankline \\spad{X} qnew(3,4)$U32Matrix()"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Integer|) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|Integer|) (QUOTE (|IntegralDomain|))) (|HasAttribute| (|Integer|) (QUOTE (|commutative| "*"))) (|HasCategory| (|Integer|) (QUOTE (|CommutativeRing|))) (|HasCategory| (|Integer|) (QUOTE (|Field|)))) 
(|U32Vector|) 
((|constructor| (NIL "\\indented{2}{fill!(x, \\spad{s)} modifies a vector \\spad{x} so every element has value \\spad{s}} \\blankline \\spad{X} t1:=new(10,7)$U32Vector \\spad{X} fill!(t1,9)"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| (|Integer|) (QUOTE (|SetCategory|))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (OR (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Integer|) (QUOTE (|SetCategory|)))) (AND (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|)))) (AND (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|SetCategory|)))))) 
(|U8Matrix|) 
((|constructor| (NIL "This is a low-level domain which implements matrices (two dimensional arrays) of 8-bit integers. Indexing is 0 based, there is no bound checking (unless provided by lower level).")) (|qnew| (($ (|Integer|) (|Integer|)) "\\indented{1}{qnew(n, \\spad{m)} creates a new \\spad{n} by \\spad{m} matrix of zeros.} \\blankline \\spad{X} qnew(3,4)$U8Matrix()"))) 
((|finiteAggregate| . T) (|shallowlyMutable| . T)) 
((|HasCategory| (|Integer|) (QUOTE (|SetCategory|))) (AND (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|EuclideanDomain|))) (|HasCategory| (|Integer|) (QUOTE (|IntegralDomain|))) (|HasAttribute| (|Integer|) (QUOTE (|commutative| "*"))) (|HasCategory| (|Integer|) (QUOTE (|CommutativeRing|))) (|HasCategory| (|Integer|) (QUOTE (|Field|)))) 
(|U8Vector|) 
((|constructor| (NIL "\\indented{2}{fill!(x, \\spad{s)} modifies a vector \\spad{x} so every element has value \\spad{s}} \\blankline \\spad{X} t1:=new(10,7)$U8Vector \\spad{X} fill!(t1,9)"))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| (|Integer|) (QUOTE (|SetCategory|))) (|HasCategory| (|Integer|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (OR (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (|HasCategory| (|Integer|) (QUOTE (|SetCategory|)))) (AND (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|)))) (AND (|HasCategory| (|Integer|) (LIST (QUOTE |Evalable|) (QUOTE (|Integer|)))) (|HasCategory| (|Integer|) (QUOTE (|SetCategory|)))))) 
(|UserDefinedPartialOrdering| S) 
((|constructor| (NIL "Provides functions to force a partial ordering on any set.")) (|more?| (((|Boolean|) |#1| |#1|) "\\spad{more?(a, \\spad{b)}} compares a and \\spad{b} in the partial ordering induced by setOrder, and uses the ordering on \\spad{S} if a and \\spad{b} are not comparable in the partial ordering.")) (|userOrdered?| (((|Boolean|)) "\\spad{userOrdered?()} tests if the partial ordering induced by setOrder is not empty.")) (|largest| ((|#1| (|List| |#1|)) "\\spad{largest \\spad{l}} returns the largest element of \\spad{l} where the partial ordering induced by setOrder is completed into a total one by the ordering on \\spad{S.}") ((|#1| (|List| |#1|) (|Mapping| (|Boolean|) |#1| |#1|)) "\\spad{largest(l, fn)} returns the largest element of \\spad{l} where the partial ordering induced by setOrder is completed into a total one by \\spad{fn.}")) (|less?| (((|Boolean|) |#1| |#1| (|Mapping| (|Boolean|) |#1| |#1|)) "\\spad{less?(a, \\spad{b,} fn)} compares \\spad{a} and \\spad{b} in the partial ordering induced by setOrder, and returns \\spad{fn(a, \\spad{b)}} if \\spad{a} and \\spad{b} are not comparable in that ordering.") (((|Union| (|Boolean|) "failed") |#1| |#1|) "\\spad{less?(a, \\spad{b)}} compares \\spad{a} and \\spad{b} in the partial ordering induced by setOrder.")) (|getOrder| (((|Record| (|:| |low| (|List| |#1|)) (|:| |high| (|List| |#1|)))) "\\spad{getOrder()} returns \\spad{[[b1,...,bm], [a1,...,an]]} such that the partial ordering on \\spad{S} was given by \\spad{setOrder([b1,...,bm],[a1,...,an])}.")) (|setOrder| (((|Void|) (|List| |#1|) (|List| |#1|)) "\\spad{setOrder([b1,...,bm], [a1,...,an])} defines a partial ordering on \\spad{S} given \\spad{by:} \\indented{3}{(1)\\space{2}\\spad{b1 < \\spad{b2} < \\spad{...} < \\spad{bm} < \\spad{a1} < \\spad{a2} < \\spad{...} < an}.} \\indented{3}{(2)\\space{2}\\spad{bj < \\spad{c} < ai}\\space{2}for \\spad{c} not among the ai's and bj's.} \\indented{3}{(3)\\space{2}undefined on \\spad{(c,d)} if neither is among the ai's,bj's.}") (((|Void|) (|List| |#1|)) "\\spad{setOrder([a1,...,an])} defines a partial ordering on \\spad{S} given \\spad{by:} \\indented{3}{(1)\\space{2}\\spad{a1 < \\spad{a2} < \\spad{...} < an}.} \\indented{3}{(2)\\space{2}\\spad{b < ai\\space{3}for \\spad{i} = 1..n} and \\spad{b} not among the ai's.} \\indented{3}{(3)\\space{2}undefined on \\spad{(b, \\spad{c)}} if neither is among the ai's.}"))) 
NIL 
((|HasCategory| |#1| (QUOTE (|OrderedSet|)))) 
(|UserDefinedVariableOrdering|) 
((|constructor| (NIL "This packages provides functions to allow the user to select the ordering on the variables and operators for displaying polynomials, fractions and expressions. The ordering affects the display only and not the computations.")) (|resetVariableOrder| (((|Void|)) "\\spad{resetVariableOrder()} cancels any previous use of setVariableOrder and returns to the default system ordering.")) (|getVariableOrder| (((|Record| (|:| |high| (|List| (|Symbol|))) (|:| |low| (|List| (|Symbol|))))) "\\spad{getVariableOrder()} returns \\spad{[[b1,...,bm], [a1,...,an]]} such that the ordering on the variables was given by \\spad{setVariableOrder([b1,...,bm], [a1,...,an])}.")) (|setVariableOrder| (((|Void|) (|List| (|Symbol|)) (|List| (|Symbol|))) "\\spad{setVariableOrder([b1,...,bm], [a1,...,an])} defines an ordering on the variables given by \\spad{b1 > \\spad{b2} > \\spad{...} > \\spad{bm} \\spad{>}} other variables \\spad{> \\spad{a1} > \\spad{a2} > \\spad{...} > an}.") (((|Void|) (|List| (|Symbol|))) "\\spad{setVariableOrder([a1,...,an])} defines an ordering on the variables given by \\spad{a1 > \\spad{a2} > \\spad{...} > an > other variables}."))) 
NIL 
NIL 
(|UniqueFactorizationDomain&| S) 
((|constructor| (NIL "A constructive unique factorization domain, \\spadignore{i.e.} where we can constructively factor members into a product of a finite number of irreducible elements.")) (|factor| (((|Factored| $) $) "\\spad{factor(x)} returns the factorization of \\spad{x} into irreducibles.")) (|squareFreePart| (($ $) "\\spad{squareFreePart(x)} returns a product of prime factors of \\spad{x} each taken with multiplicity one.")) (|squareFree| (((|Factored| $) $) "\\spad{squareFree(x)} returns the square-free factorization of \\spad{x} \\spadignore{i.e.} such that the factors are pairwise relatively prime and each has multiple prime factors.")) (|prime?| (((|Boolean|) $) "\\spad{prime?(x)} tests if \\spad{x} can never be written as the product of two non-units of the ring, \\spadignore{i.e.} \\spad{x} is an irreducible element."))) 
NIL 
NIL 
(|UniqueFactorizationDomain|) 
((|constructor| (NIL "A constructive unique factorization domain, \\spadignore{i.e.} where we can constructively factor members into a product of a finite number of irreducible elements.")) (|factor| (((|Factored| $) $) "\\spad{factor(x)} returns the factorization of \\spad{x} into irreducibles.")) (|squareFreePart| (($ $) "\\spad{squareFreePart(x)} returns a product of prime factors of \\spad{x} each taken with multiplicity one.")) (|squareFree| (((|Factored| $) $) "\\spad{squareFree(x)} returns the square-free factorization of \\spad{x} \\spadignore{i.e.} such that the factors are pairwise relatively prime and each has multiple prime factors.")) (|prime?| (((|Boolean|) $) "\\spad{prime?(x)} tests if \\spad{x} can never be written as the product of two non-units of the ring, \\spadignore{i.e.} \\spad{x} is an irreducible element."))) 
((|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|UnivariateFormalPowerSeriesFunctions| |Coef|) 
((|constructor| (NIL "This package has no description"))) 
NIL 
NIL 
(|UnivariateFormalPowerSeries| |Coef|) 
((|constructor| (NIL "This domain has no description"))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|)) (|devaluate| |#1|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|)) (|devaluate| |#1|))))) (|HasCategory| (|NonNegativeInteger|) (QUOTE (|SemiGroup|))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|)))))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |AlgebraicallyClosedFunctionSpace|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|PrimitiveFunctionCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |integrate|) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Symbol|))))) (|HasSignature| |#1| (LIST (QUOTE |variables|) (LIST (LIST (QUOTE |List|) (QUOTE (|Symbol|))) (|devaluate| |#1|))))))) 
(|UnivariateLaurentSeriesFunctions2| |Coef1| |Coef2| |var1| |var2| |cen1| |cen2|) 
((|constructor| (NIL "Mapping package for univariate Laurent series This package allows one to apply a function to the coefficients of a univariate Laurent series.")) (|map| (((|UnivariateLaurentSeries| |#2| |#4| |#6|) (|Mapping| |#2| |#1|) (|UnivariateLaurentSeries| |#1| |#3| |#5|)) "\\spad{map(f,g(x))} applies the map \\spad{f} to the coefficients of the Laurent series \\spad{g(x)}."))) 
NIL 
NIL 
(|UnivariateLaurentSeriesCategory| |Coef|) 
((|constructor| (NIL "\\spadtype{UnivariateLaurentSeriesCategory} is the category of Laurent series in one variable.")) (|integrate| (($ $ (|Symbol|)) "\\spad{integrate(f(x),y)} returns an anti-derivative of the power series \\spad{f(x)} with respect to the variable \\spad{y}.") (($ $ (|Symbol|)) "\\spad{integrate(f(x),y)} returns an anti-derivative of the power series \\spad{f(x)} with respect to the variable \\spad{y}.") (($ $) "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 1. We may integrate a series when we can divide coefficients by integers.")) (|rationalFunction| (((|Fraction| (|Polynomial| |#1|)) $ (|Integer|) (|Integer|)) "\\spad{rationalFunction(f,k1,k2)} returns a rational function consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 \\spad{<=} \\spad{d} \\spad{<=} k2}.") (((|Fraction| (|Polynomial| |#1|)) $ (|Integer|)) "\\spad{rationalFunction(f,k)} returns a rational function consisting of the sum of all terms of \\spad{f} of degree \\spad{<=} \\spad{k.}")) (|multiplyCoefficients| (($ (|Mapping| |#1| (|Integer|)) $) "\\spad{multiplyCoefficients(f,sum(n = n0..infinity,a[n] * x**n)) = sum(n = 0..infinity,f(n) * a[n] * x**n)}. This function is used when Puiseux series are represented by a Laurent series and an exponent.")) (|series| (($ (|Stream| (|Record| (|:| |k| (|Integer|)) (|:| |c| |#1|)))) "\\spad{series(st)} creates a series from a stream of non-zero terms, where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|UnivariateLaurentSeriesConstructorCategory&| S |Coef| UTS) 
((|constructor| (NIL "This is a category of univariate Laurent series constructed from univariate Taylor series. A Laurent series is represented by a pair \\spad{[n,f(x)]}, where \\spad{n} is an arbitrary integer and \\spad{f(x)} is a Taylor series. This pair represents the Laurent series \\spad{x**n * f(x)}.")) (|taylorIfCan| (((|Union| |#3| "failed") $) "\\spad{taylorIfCan(f(x))} converts the Laurent series \\spad{f(x)} to a Taylor series, if possible. If this is not possible, \"failed\" is returned.")) (|taylor| ((|#3| $) "\\spad{taylor(f(x))} converts the Laurent series \\spad{f(x)} to a Taylor series, if possible. Error: if this is not possible.")) (|coerce| (($ |#3|) "\\spad{coerce(f(x))} converts the Taylor series \\spad{f(x)} to a Laurent series.")) (|removeZeroes| (($ (|Integer|) $) "\\spad{removeZeroes(n,f(x))} removes up to \\spad{n} leading zeroes from the Laurent series \\spad{f(x)}. A Laurent series is represented by \\spad{(1)} an exponent and \\spad{(2)} a Taylor series which may have leading zero coefficients. When the Taylor series has a leading zero coefficient, the 'leading zero' is removed from the Laurent series as follows: the series is rewritten by increasing the exponent by 1 and dividing the Taylor series by its variable.") (($ $) "\\spad{removeZeroes(f(x))} removes leading zeroes from the representation of the Laurent series \\spad{f(x)}. A Laurent series is represented by \\spad{(1)} an exponent and \\spad{(2)} a Taylor series which may have leading zero coefficients. When the Taylor series has a leading zero coefficient, the 'leading zero' is removed from the Laurent series as follows: the series is rewritten by increasing the exponent by 1 and dividing the Taylor series by its variable. Note that \\spad{removeZeroes(f)} removes all leading zeroes from \\spad{f}")) (|taylorRep| ((|#3| $) "\\spad{taylorRep(f(x))} returns \\spad{g(x)}, where \\spad{f = x**n * g(x)} is represented by \\spad{[n,g(x)]}.")) (|degree| (((|Integer|) $) "\\spad{degree(f(x))} returns the degree of the lowest order term of \\spad{f(x)}, which may have zero as a coefficient.")) (|laurent| (($ (|Integer|) |#3|) "\\spad{laurent(n,f(x))} returns \\spad{x**n * f(x)}."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|Field|)))) 
(|UnivariateLaurentSeriesConstructorCategory| |Coef| UTS) 
((|constructor| (NIL "This is a category of univariate Laurent series constructed from univariate Taylor series. A Laurent series is represented by a pair \\spad{[n,f(x)]}, where \\spad{n} is an arbitrary integer and \\spad{f(x)} is a Taylor series. This pair represents the Laurent series \\spad{x**n * f(x)}.")) (|taylorIfCan| (((|Union| |#2| "failed") $) "\\spad{taylorIfCan(f(x))} converts the Laurent series \\spad{f(x)} to a Taylor series, if possible. If this is not possible, \"failed\" is returned.")) (|taylor| ((|#2| $) "\\spad{taylor(f(x))} converts the Laurent series \\spad{f(x)} to a Taylor series, if possible. Error: if this is not possible.")) (|coerce| (($ |#2|) "\\spad{coerce(f(x))} converts the Taylor series \\spad{f(x)} to a Laurent series.")) (|removeZeroes| (($ (|Integer|) $) "\\spad{removeZeroes(n,f(x))} removes up to \\spad{n} leading zeroes from the Laurent series \\spad{f(x)}. A Laurent series is represented by \\spad{(1)} an exponent and \\spad{(2)} a Taylor series which may have leading zero coefficients. When the Taylor series has a leading zero coefficient, the 'leading zero' is removed from the Laurent series as follows: the series is rewritten by increasing the exponent by 1 and dividing the Taylor series by its variable.") (($ $) "\\spad{removeZeroes(f(x))} removes leading zeroes from the representation of the Laurent series \\spad{f(x)}. A Laurent series is represented by \\spad{(1)} an exponent and \\spad{(2)} a Taylor series which may have leading zero coefficients. When the Taylor series has a leading zero coefficient, the 'leading zero' is removed from the Laurent series as follows: the series is rewritten by increasing the exponent by 1 and dividing the Taylor series by its variable. Note that \\spad{removeZeroes(f)} removes all leading zeroes from \\spad{f}")) (|taylorRep| ((|#2| $) "\\spad{taylorRep(f(x))} returns \\spad{g(x)}, where \\spad{f = x**n * g(x)} is represented by \\spad{[n,g(x)]}.")) (|degree| (((|Integer|) $) "\\spad{degree(f(x))} returns the degree of the lowest order term of \\spad{f(x)}, which may have zero as a coefficient.")) (|laurent| (($ (|Integer|) |#2|) "\\spad{laurent(n,f(x))} returns \\spad{x**n * f(x)}."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|nil| |has| |#1| (|Field|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|UnivariateLaurentSeriesConstructor| |Coef| UTS) 
((|constructor| (NIL "This package enables one to construct a univariate Laurent series domain from a univariate Taylor series domain. Univariate Laurent series are represented by a pair \\spad{[n,f(x)]}, where \\spad{n} is an arbitrary integer and \\spad{f(x)} is a Taylor series. This pair represents the Laurent series \\spad{x**n * f(x)}."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| (|Integer|) (QUOTE (|SemiGroup|))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|Integer|)) (|devaluate| |#1|))))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))))) (OR (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|Integer|)) (|devaluate| |#1|))))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|))))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|RealConstant|)))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|OrderedIntegralDomain|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|StepThrough|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |Eltable|) (|devaluate| |#2|) (|devaluate| |#2|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (|devaluate| |#2|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Integer|))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|)))))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|OrderedSet|)))) (OR (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|OrderedIntegralDomain|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|OrderedSet|))))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|IntegerNumberSystem|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|EuclideanDomain|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (OR (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |Eltable|) (|devaluate| |#2|) (|devaluate| |#2|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (|devaluate| |#2|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|))))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|))))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|OrderedIntegralDomain|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|RealConstant|)))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|StepThrough|))))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |AlgebraicallyClosedFunctionSpace|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|PrimitiveFunctionCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |integrate|) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Symbol|))))) (|HasSignature| |#1| (LIST (QUOTE |variables|) (LIST (LIST (QUOTE |List|) (QUOTE (|Symbol|))) (|devaluate| |#1|)))))) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (AND (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|)))))) 
(|UnivariateLaurentSeries| |Coef| |var| |cen|) 
((|constructor| (NIL "Dense Laurent series in one variable \\spadtype{UnivariateLaurentSeries} is a domain representing Laurent series in one variable with coefficients in an arbitrary ring. The parameters of the type specify the coefficient ring, the power series variable, and the center of the power series expansion. For example, \\spad{UnivariateLaurentSeries(Integer,x,3)} represents Laurent series in \\spad{(x - 3)} with integer coefficients.")) (|integrate| (($ $ (|Variable| |#2|)) "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.")) (|differentiate| (($ $ (|Variable| |#2|)) "\\spad{differentiate(f(x),x)} returns the derivative of \\spad{f(x)} with respect to \\spad{x}.")) (|coerce| (($ (|Variable| |#2|)) "\\spad{coerce(var)} converts the series variable \\spad{var} into a Laurent series."))) 
(((|commutative| "*") OR (|and| (|has| |#1| (|Field|)) (|has| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (|OrderedIntegralDomain|))) (|has| |#1| (|CommutativeRing|)) (|and| (|has| |#1| (|Field|)) (|has| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (|PolynomialFactorizationExplicit|)))) (|noZeroDivisors| OR (|and| (|has| |#1| (|Field|)) (|has| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (|OrderedIntegralDomain|))) (|has| |#1| (|IntegralDomain|)) (|and| (|has| |#1| (|Field|)) (|has| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (|PolynomialFactorizationExplicit|)))) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| (|Integer|) (QUOTE (|SemiGroup|))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|CharacteristicZero|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|)))) (OR (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|Integer|)) (|devaluate| |#1|)))))) (OR (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|DifferentialRing|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|Integer|)) (|devaluate| |#1|))))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|RealConstant|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|StepThrough|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |Eltable|) (LIST (QUOTE |UnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)) (LIST (QUOTE |UnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |Evalable|) (LIST (QUOTE |UnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (LIST (QUOTE |UnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Integer|))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|)))))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|IntegerNumberSystem|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|EuclideanDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (OR (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|)))) (OR (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (OR (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (OR (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|Field|))))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (OR (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |Eltable|) (LIST (QUOTE |UnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)) (LIST (QUOTE |UnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |Evalable|) (LIST (QUOTE |UnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |InnerEvalable|) (QUOTE (|Symbol|)) (LIST (QUOTE |UnivariateTaylorSeries|) (|devaluate| |#1|) (|devaluate| |#2|) (|devaluate| |#3|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Symbol|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedIntegralDomain|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|RealConstant|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|StepThrough|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |AlgebraicallyClosedFunctionSpace|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|PrimitiveFunctionCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |integrate|) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Symbol|))))) (|HasSignature| |#1| (LIST (QUOTE |variables|) (LIST (LIST (QUOTE |List|) (QUOTE (|Symbol|))) (|devaluate| |#1|)))))) (OR (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (AND (|HasCategory| (|UnivariateTaylorSeries| |#1| |#2| |#3|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|Field|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))))) 
(|UnivariateFactorize| ZP) 
((|constructor| (NIL "Package for the factorization of univariate polynomials with integer coefficients. The factorization is done by \"lifting\" (HENSEL) the factorization over a finite field.")) (|henselFact| (((|Record| (|:| |contp| (|Integer|)) (|:| |factors| (|List| (|Record| (|:| |irr| |#1|) (|:| |pow| (|Integer|)))))) |#1| (|Boolean|)) "\\spad{henselFact(m,flag)} returns the factorization of \\spad{m,} FinalFact is a Record s.t. FinalFact.contp=content \\spad{m,} FinalFact.factors=List of irreducible factors of \\spad{m} with exponent ,{} if \\spad{flag} =true the polynomial is assumed square free.")) (|factorSquareFree| (((|Factored| |#1|) |#1|) "\\spad{factorSquareFree(m)} returns the factorization of \\spad{m} square free polynomial")) (|factor| (((|Factored| |#1|) |#1|) "\\spad{factor(m)} returns the factorization of \\spad{m}"))) 
NIL 
NIL 
(|UniversalSegmentFunctions2| R S) 
((|constructor| (NIL "This package provides operations for mapping functions onto segments.")) (|map| (((|Stream| |#2|) (|Mapping| |#2| |#1|) (|UniversalSegment| |#1|)) "\\spad{map(f,s)} expands the segment \\spad{s,} applying \\spad{f} to each value.") (((|UniversalSegment| |#2|) (|Mapping| |#2| |#1|) (|UniversalSegment| |#1|)) "\\spad{map(f,seg)} returns the new segment obtained by applying \\spad{f} to the endpoints of seg."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|OrderedRing|)))) 
(|UniversalSegment| S) 
((|constructor| (NIL "This domain provides segments which may be half open. That is, ranges of the form \\spad{a..} or \\spad{a..b}.")) (|hasHi| (((|Boolean|) $) "\\spad{hasHi(s)} tests whether the segment \\spad{s} has an upper bound.")) (|coerce| (($ (|Segment| |#1|)) "\\spad{coerce(x)} allows \\spadtype{Segment} values to be used as \\spad{%.}")) (|segment| (($ |#1|) "\\spad{segment(l)} is an alternate way to construct the segment \\spad{l..}.")) (SEGMENT (($ |#1|) "\\spad{l..} produces a half open segment, that is, one with no upper bound."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|OrderedRing|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) 
(|UnivariatePolynomialFunctions2| |x| R |y| S) 
((|constructor| (NIL "This package lifts a mapping from coefficient rings \\spad{R} to \\spad{S} to a mapping from \\spadtype{UnivariatePolynomial}(x,R) to \\spadtype{UnivariatePolynomial}(y,S). Note that the mapping is assumed to send zero to zero, since it will only be applied to the non-zero coefficients of the polynomial.")) (|map| (((|UnivariatePolynomial| |#3| |#4|) (|Mapping| |#4| |#2|) (|UnivariatePolynomial| |#1| |#2|)) "\\spad{map(func, poly)} creates a new polynomial by applying \\spad{func} to every non-zero coefficient of the polynomial poly."))) 
NIL 
NIL 
(|UnivariatePolynomialCommonDenominator| R Q UP) 
((|constructor| (NIL "UnivariatePolynomialCommonDenominator provides functions to compute the common denominator of the coefficients of univariate polynomials over the quotient field of a \\spad{gcd} domain.")) (|splitDenominator| (((|Record| (|:| |num| |#3|) (|:| |den| |#1|)) |#3|) "\\spad{splitDenominator(q)} returns \\spad{[p, \\spad{d]}} such that \\spad{q = p/d} and \\spad{d} is a common denominator for the coefficients of \\spad{q.}")) (|clearDenominator| ((|#3| |#3|) "\\spad{clearDenominator(q)} returns \\spad{p} such that \\spad{q = p/d} where \\spad{d} is a common denominator for the coefficients of \\spad{q.}")) (|commonDenominator| ((|#1| |#3|) "\\spad{commonDenominator(q)} returns a common denominator \\spad{d} for the coefficients of \\spad{q.}"))) 
NIL 
NIL 
(|UnivariatePolynomialDecompositionPackage| R UP) 
((|constructor| (NIL "UnivariatePolynomialDecompositionPackage implements functional decomposition of univariate polynomial with coefficients in an \\spad{IntegralDomain} of \\spad{CharacteristicZero}.")) (|monicCompleteDecompose| (((|List| |#2|) |#2|) "\\spad{monicCompleteDecompose(f)} returns a list of factors of \\spad{f} for the functional decomposition \\spad{([} \\spad{f1,} ..., \\spad{fn} ] means \\spad{f} = \\spad{f1} \\spad{o} \\spad{...} \\spad{o} fn).")) (|monicDecomposeIfCan| (((|Union| (|Record| (|:| |left| |#2|) (|:| |right| |#2|)) "failed") |#2|) "\\spad{monicDecomposeIfCan(f)} returns a functional decomposition of the monic polynomial \\spad{f} of \"failed\" if it has not found any.")) (|leftFactorIfCan| (((|Union| |#2| "failed") |#2| |#2|) "\\spad{leftFactorIfCan(f,h)} returns the left factor \\spad{(g} in \\spad{f} = \\spad{g} \\spad{o} \\spad{h)} of the functional decomposition of the polynomial \\spad{f} with given \\spad{h} or \\spad{\"failed\"} if \\spad{g} does not exist.")) (|rightFactorIfCan| (((|Union| |#2| "failed") |#2| (|NonNegativeInteger|) |#1|) "\\spad{rightFactorIfCan(f,d,c)} returns a candidate to be the right factor \\spad{(h} in \\spad{f} = \\spad{g} \\spad{o} \\spad{h)} of degree \\spad{d} with leading coefficient \\spad{c} of a functional decomposition of the polynomial \\spad{f} or \\spad{\"failed\"} if no such candidate.")) (|monicRightFactorIfCan| (((|Union| |#2| "failed") |#2| (|NonNegativeInteger|)) "\\spad{monicRightFactorIfCan(f,d)} returns a candidate to be the monic right factor \\spad{(h} in \\spad{f} = \\spad{g} \\spad{o} \\spad{h)} of degree \\spad{d} of a functional decomposition of the polynomial \\spad{f} or \\spad{\"failed\"} if no such candidate."))) 
NIL 
NIL 
(|UnivariatePolynomialDivisionPackage| R UP) 
((|constructor| (NIL "UnivariatePolynomialDivisionPackage provides a division for non monic univarite polynomials with coefficients in an \\spad{IntegralDomain}.")) (|divideIfCan| (((|Union| (|Record| (|:| |quotient| |#2|) (|:| |remainder| |#2|)) "failed") |#2| |#2|) "\\spad{divideIfCan(f,g)} returns quotient and remainder of the division of \\spad{f} by \\spad{g} or \"failed\" if it has not succeeded."))) 
NIL 
NIL 
(|UnivariatePolynomialMultiplicationPackage| R U) 
((|constructor| (NIL "This package implements Karatsuba's trick for multiplying (large) univariate polynomials. It could be improved with a version doing the work on place and also with a special case for squares. We've done this in Basicmath, but we believe that this out of the scope of AXIOM.")) (|karatsuba| ((|#2| |#2| |#2| (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{karatsuba(a,b,l,k)} returns \\spad{a*b} by applying Karatsuba's trick provided that both \\spad{a} and \\spad{b} have at least \\spad{l} terms and \\spad{k > 0} holds and by calling \\spad{noKaratsuba} otherwise. The other multiplications are performed by recursive calls with the same third argument and \\spad{k-1} as fourth argument.")) (|karatsubaOnce| ((|#2| |#2| |#2|) "\\spad{karatsuba(a,b)} returns \\spad{a*b} by applying Karatsuba's trick once. The other multiplications are performed by calling \\spad{*} from \\spad{U}.")) (|noKaratsuba| ((|#2| |#2| |#2|) "\\spad{noKaratsuba(a,b)} returns \\spad{a*b} without using Karatsuba's trick at all."))) 
NIL 
NIL 
(|UnivariatePolynomial| |x| R) 
((|constructor| (NIL "This domain represents univariate polynomials in some symbol over arbitrary (not necessarily commutative) coefficient rings. The representation is sparse in the sense that only non-zero terms are represented. Note that if the coefficient ring is a field, then this domain forms a euclidean domain.")) (|fmecg| (($ $ (|NonNegativeInteger|) |#2| $) "\\spad{fmecg(p1,e,r,p2)} finds \\spad{x} : \\spad{p1} - \\spad{r} * x**e * \\spad{p2}")) (|coerce| (($ (|Variable| |#1|)) "\\spad{coerce(x)} converts the variable \\spad{x} to a univariate polynomial."))) 
(((|commutative| "*") |has| |#2| (|CommutativeRing|)) (|noZeroDivisors| |has| |#2| (|IntegralDomain|)) (|additiveValuation| |has| |#2| (|Field|)) (|canonicalUnitNormal| |has| |#2| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Float|))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |PatternMatchable|) (QUOTE (|Integer|))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Float|)))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (LIST (QUOTE |Pattern|) (QUOTE (|Integer|)))))) (AND (|HasCategory| (|SingletonAsOrderedSet|) (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#2| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|))))) (|HasCategory| |#2| (QUOTE (|OrderedSet|))) (|HasCategory| |#2| (LIST (QUOTE |LinearlyExplicitRingOver|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (OR (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Field|))) (OR (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#2| (QUOTE (|StepThrough|))) (|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (OR (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasCategory| |#2| (QUOTE (|DifferentialRing|))) (|HasAttribute| |#2| (QUOTE |canonicalUnitNormal|)) (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (OR (AND (|HasCategory| $ (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))))) 
(|UnivariatePolynomialCategoryFunctions2| R PR S PS) 
((|constructor| (NIL "Mapping from polynomials over \\spad{R} to polynomials over \\spad{S} given a map from \\spad{R} to \\spad{S} assumed to send zero to zero.")) (|map| ((|#4| (|Mapping| |#3| |#1|) |#2|) "\\spad{map(f, \\spad{p)}} takes a function \\spad{f} from \\spad{R} to \\spad{S,} and applies it to each (non-zero) coefficient of a polynomial \\spad{p} over \\spad{R,} getting a new polynomial over \\spad{S.} Note that since the map is not applied to zero elements, it may map zero to zero."))) 
NIL 
NIL 
(|UnivariatePolynomialCategory&| S R) 
((|constructor| (NIL "The category of univariate polynomials over a ring \\spad{R.} No particular model is assumed - implementations can be either sparse or dense.")) (|integrate| (($ $) "\\spad{integrate(p)} integrates the univariate polynomial \\spad{p} with respect to its distinguished variable.")) (|additiveValuation| ((|attribute|) "euclideanSize(a*b) = euclideanSize(a) + euclideanSize(b)")) (|separate| (((|Record| (|:| |primePart| $) (|:| |commonPart| $)) $ $) "\\spad{separate(p, \\spad{q)}} returns \\spad{[a, \\spad{b]}} such that polynomial \\spad{p = a \\spad{b}} and \\spad{a} is relatively prime to \\spad{q.}")) (|pseudoDivide| (((|Record| (|:| |coef| |#2|) (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{pseudoDivide(p,q)} returns \\spad{[c, \\spad{q,} r]}, when \\spad{p' \\spad{:=} p*lc(q)**(deg \\spad{p} - deg \\spad{q} + 1) = \\spad{c} * \\spad{p}} is pseudo right-divided by \\spad{q,} \\spadignore{i.e.} \\spad{p' = \\spad{s} \\spad{q} + \\spad{r}.}")) (|pseudoQuotient| (($ $ $) "\\spad{pseudoQuotient(p,q)} returns \\spad{r,} the quotient when \\spad{p' \\spad{:=} p*lc(q)**(deg \\spad{p} - deg \\spad{q} + 1)} is pseudo right-divided by \\spad{q,} \\spadignore{i.e.} \\spad{p' = \\spad{s} \\spad{q} + \\spad{r}.}")) (|composite| (((|Union| (|Fraction| $) "failed") (|Fraction| $) $) "\\spad{composite(f, \\spad{q)}} returns \\spad{h} if \\spad{f} = h(q), and \"failed\" is no such \\spad{h} exists.") (((|Union| $ "failed") $ $) "\\spad{composite(p, \\spad{q)}} returns \\spad{h} if \\spad{p = h(q)}, and \"failed\" no such \\spad{h} exists.")) (|subResultantGcd| (($ $ $) "\\spad{subResultantGcd(p,q)} computes the \\spad{gcd} of the polynomials \\spad{p} and \\spad{q} using the SubResultant \\spad{GCD} algorithm.")) (|order| (((|NonNegativeInteger|) $ $) "\\spad{order(p, \\spad{q)}} returns the largest \\spad{n} such that \\spad{q**n} divides polynomial \\spad{p} \\spadignore{i.e.} the order of \\spad{p(x)} at \\spad{q(x)=0}.")) (|elt| ((|#2| (|Fraction| $) |#2|) "\\spad{elt(a,r)} evaluates the fraction of univariate polynomials \\spad{a} with the distinguished variable replaced by the constant \\spad{r.}") (((|Fraction| $) (|Fraction| $) (|Fraction| $)) "\\spad{elt(a,b)} evaluates the fraction of univariate polynomials \\spad{a} with the distinguished variable replaced by \\spad{b.}")) (|resultant| ((|#2| $ $) "\\spad{resultant(p,q)} returns the resultant of the polynomials \\spad{p} and \\spad{q.}")) (|discriminant| ((|#2| $) "\\spad{discriminant(p)} returns the discriminant of the polynomial \\spad{p.}")) (|differentiate| (($ $ (|Mapping| |#2| |#2|) $) "\\spad{differentiate(p, \\spad{d,} x')} extends the R-derivation \\spad{d} to an extension \\spad{D} in \\spad{R[x]} where \\spad{Dx} is given by \\spad{x',} and returns \\spad{Dp}.")) (|pseudoRemainder| (($ $ $) "\\spad{pseudoRemainder(p,q)} = \\spad{r,} for polynomials \\spad{p} and \\spad{q,} returns the remainder when \\spad{p' \\spad{:=} p*lc(q)**(deg \\spad{p} - deg \\spad{q} + 1)} is pseudo right-divided by \\spad{q,} \\spadignore{i.e.} \\spad{p' = \\spad{s} \\spad{q} + \\spad{r}.}")) (|shiftLeft| (($ $ (|NonNegativeInteger|)) "\\spad{shiftLeft(p,n)} returns \\spad{p * monomial(1,n)}")) (|shiftRight| (($ $ (|NonNegativeInteger|)) "\\spad{shiftRight(p,n)} returns \\spad{monicDivide(p,monomial(1,n)).quotient}")) (|karatsubaDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ (|NonNegativeInteger|)) "\\spad{karatsubaDivide(p,n)} returns the same as \\spad{monicDivide(p,monomial(1,n))}")) (|monicDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{monicDivide(p,q)} divide the polynomial \\spad{p} by the monic polynomial \\spad{q,} returning the pair \\spad{[quotient, remainder]}. Error: if \\spad{q} isn't monic.")) (|divideExponents| (((|Union| $ "failed") $ (|NonNegativeInteger|)) "\\spad{divideExponents(p,n)} returns a new polynomial resulting from dividing all exponents of the polynomial \\spad{p} by the non negative integer \\spad{n,} or \"failed\" if some exponent is not exactly divisible by \\spad{n.}")) (|multiplyExponents| (($ $ (|NonNegativeInteger|)) "\\spad{multiplyExponents(p,n)} returns a new polynomial resulting from multiplying all exponents of the polynomial \\spad{p} by the non negative integer \\spad{n.}")) (|unmakeSUP| (($ (|SparseUnivariatePolynomial| |#2|)) "\\spad{unmakeSUP(sup)} converts \\spad{sup} of type \\spadtype{SparseUnivariatePolynomial(R)} to be a member of the given type. Note that converse of makeSUP.")) (|makeSUP| (((|SparseUnivariatePolynomial| |#2|) $) "\\spad{makeSUP(p)} converts the polynomial \\spad{p} to be of type SparseUnivariatePolynomial over the same coefficients.")) (|unvectorise| (($ (|Vector| |#2|)) "\\indented{1}{unvectorise(v) returns the polynomial which has for coefficients the} \\indented{1}{entries of \\spad{v} in the increasing order.} \\blankline \\spad{X} \\spad{t1:UP(x,FRAC(INT)):=3*x^3+4*x^2+5*x+6} \\spad{X} t2:=vectorise(t1,4) \\spad{X} t3:UP(x,FRAC(INT)):=unvectorise(t2)")) (|vectorise| (((|Vector| |#2|) $ (|NonNegativeInteger|)) "\\indented{1}{vectorise(p, \\spad{n)} returns \\spad{[a0,...,a(n-1)]} where} \\indented{1}{\\spad{p = \\spad{a0} + a1*x + \\spad{...} + a(n-1)*x**(n-1)} + higher order terms.} \\indented{1}{The degree of polynomial \\spad{p} can be different from \\spad{n-1}.} \\blankline \\spad{X} \\spad{t1:UP(x,FRAC(INT)):=3*x^3+4*x^2+5*x+6} \\spad{X} t2:=vectorise(t1,4)"))) 
NIL 
((|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Field|))) (|HasCategory| |#2| (QUOTE (|GcdDomain|))) (|HasCategory| |#2| (QUOTE (|IntegralDomain|))) (|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (QUOTE (|StepThrough|)))) 
(|UnivariatePolynomialCategory| R) 
((|constructor| (NIL "The category of univariate polynomials over a ring \\spad{R.} No particular model is assumed - implementations can be either sparse or dense.")) (|integrate| (($ $) "\\spad{integrate(p)} integrates the univariate polynomial \\spad{p} with respect to its distinguished variable.")) (|additiveValuation| ((|attribute|) "euclideanSize(a*b) = euclideanSize(a) + euclideanSize(b)")) (|separate| (((|Record| (|:| |primePart| $) (|:| |commonPart| $)) $ $) "\\spad{separate(p, \\spad{q)}} returns \\spad{[a, \\spad{b]}} such that polynomial \\spad{p = a \\spad{b}} and \\spad{a} is relatively prime to \\spad{q.}")) (|pseudoDivide| (((|Record| (|:| |coef| |#1|) (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{pseudoDivide(p,q)} returns \\spad{[c, \\spad{q,} r]}, when \\spad{p' \\spad{:=} p*lc(q)**(deg \\spad{p} - deg \\spad{q} + 1) = \\spad{c} * \\spad{p}} is pseudo right-divided by \\spad{q,} \\spadignore{i.e.} \\spad{p' = \\spad{s} \\spad{q} + \\spad{r}.}")) (|pseudoQuotient| (($ $ $) "\\spad{pseudoQuotient(p,q)} returns \\spad{r,} the quotient when \\spad{p' \\spad{:=} p*lc(q)**(deg \\spad{p} - deg \\spad{q} + 1)} is pseudo right-divided by \\spad{q,} \\spadignore{i.e.} \\spad{p' = \\spad{s} \\spad{q} + \\spad{r}.}")) (|composite| (((|Union| (|Fraction| $) "failed") (|Fraction| $) $) "\\spad{composite(f, \\spad{q)}} returns \\spad{h} if \\spad{f} = h(q), and \"failed\" is no such \\spad{h} exists.") (((|Union| $ "failed") $ $) "\\spad{composite(p, \\spad{q)}} returns \\spad{h} if \\spad{p = h(q)}, and \"failed\" no such \\spad{h} exists.")) (|subResultantGcd| (($ $ $) "\\spad{subResultantGcd(p,q)} computes the \\spad{gcd} of the polynomials \\spad{p} and \\spad{q} using the SubResultant \\spad{GCD} algorithm.")) (|order| (((|NonNegativeInteger|) $ $) "\\spad{order(p, \\spad{q)}} returns the largest \\spad{n} such that \\spad{q**n} divides polynomial \\spad{p} \\spadignore{i.e.} the order of \\spad{p(x)} at \\spad{q(x)=0}.")) (|elt| ((|#1| (|Fraction| $) |#1|) "\\spad{elt(a,r)} evaluates the fraction of univariate polynomials \\spad{a} with the distinguished variable replaced by the constant \\spad{r.}") (((|Fraction| $) (|Fraction| $) (|Fraction| $)) "\\spad{elt(a,b)} evaluates the fraction of univariate polynomials \\spad{a} with the distinguished variable replaced by \\spad{b.}")) (|resultant| ((|#1| $ $) "\\spad{resultant(p,q)} returns the resultant of the polynomials \\spad{p} and \\spad{q.}")) (|discriminant| ((|#1| $) "\\spad{discriminant(p)} returns the discriminant of the polynomial \\spad{p.}")) (|differentiate| (($ $ (|Mapping| |#1| |#1|) $) "\\spad{differentiate(p, \\spad{d,} x')} extends the R-derivation \\spad{d} to an extension \\spad{D} in \\spad{R[x]} where \\spad{Dx} is given by \\spad{x',} and returns \\spad{Dp}.")) (|pseudoRemainder| (($ $ $) "\\spad{pseudoRemainder(p,q)} = \\spad{r,} for polynomials \\spad{p} and \\spad{q,} returns the remainder when \\spad{p' \\spad{:=} p*lc(q)**(deg \\spad{p} - deg \\spad{q} + 1)} is pseudo right-divided by \\spad{q,} \\spadignore{i.e.} \\spad{p' = \\spad{s} \\spad{q} + \\spad{r}.}")) (|shiftLeft| (($ $ (|NonNegativeInteger|)) "\\spad{shiftLeft(p,n)} returns \\spad{p * monomial(1,n)}")) (|shiftRight| (($ $ (|NonNegativeInteger|)) "\\spad{shiftRight(p,n)} returns \\spad{monicDivide(p,monomial(1,n)).quotient}")) (|karatsubaDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ (|NonNegativeInteger|)) "\\spad{karatsubaDivide(p,n)} returns the same as \\spad{monicDivide(p,monomial(1,n))}")) (|monicDivide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) "\\spad{monicDivide(p,q)} divide the polynomial \\spad{p} by the monic polynomial \\spad{q,} returning the pair \\spad{[quotient, remainder]}. Error: if \\spad{q} isn't monic.")) (|divideExponents| (((|Union| $ "failed") $ (|NonNegativeInteger|)) "\\spad{divideExponents(p,n)} returns a new polynomial resulting from dividing all exponents of the polynomial \\spad{p} by the non negative integer \\spad{n,} or \"failed\" if some exponent is not exactly divisible by \\spad{n.}")) (|multiplyExponents| (($ $ (|NonNegativeInteger|)) "\\spad{multiplyExponents(p,n)} returns a new polynomial resulting from multiplying all exponents of the polynomial \\spad{p} by the non negative integer \\spad{n.}")) (|unmakeSUP| (($ (|SparseUnivariatePolynomial| |#1|)) "\\spad{unmakeSUP(sup)} converts \\spad{sup} of type \\spadtype{SparseUnivariatePolynomial(R)} to be a member of the given type. Note that converse of makeSUP.")) (|makeSUP| (((|SparseUnivariatePolynomial| |#1|) $) "\\spad{makeSUP(p)} converts the polynomial \\spad{p} to be of type SparseUnivariatePolynomial over the same coefficients.")) (|unvectorise| (($ (|Vector| |#1|)) "\\indented{1}{unvectorise(v) returns the polynomial which has for coefficients the} \\indented{1}{entries of \\spad{v} in the increasing order.} \\blankline \\spad{X} \\spad{t1:UP(x,FRAC(INT)):=3*x^3+4*x^2+5*x+6} \\spad{X} t2:=vectorise(t1,4) \\spad{X} t3:UP(x,FRAC(INT)):=unvectorise(t2)")) (|vectorise| (((|Vector| |#1|) $ (|NonNegativeInteger|)) "\\indented{1}{vectorise(p, \\spad{n)} returns \\spad{[a0,...,a(n-1)]} where} \\indented{1}{\\spad{p = \\spad{a0} + a1*x + \\spad{...} + a(n-1)*x**(n-1)} + higher order terms.} \\indented{1}{The degree of polynomial \\spad{p} can be different from \\spad{n-1}.} \\blankline \\spad{X} \\spad{t1:UP(x,FRAC(INT)):=3*x^3+4*x^2+5*x+6} \\spad{X} t2:=vectorise(t1,4)"))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|additiveValuation| |has| |#1| (|Field|)) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|UnivariatePowerSeriesCategory&| S |Coef| |Expon|) 
((|constructor| (NIL "\\spadtype{UnivariatePowerSeriesCategory} is the most general univariate power series category with exponents in an ordered abelian monoid. Note that this category exports a substitution function if it is possible to multiply exponents. Also note that this category exports a derivative operation if it is possible to multiply coefficients by exponents.")) (|eval| (((|Stream| |#2|) $ |#2|) "\\spad{eval(f,a)} evaluates a power series at a value in the ground ring by returning a stream of partial sums.")) (|extend| (($ $ |#3|) "\\spad{extend(f,n)} causes all terms of \\spad{f} of degree \\spad{<=} \\spad{n} to be computed.")) (|approximate| ((|#2| $ |#3|) "\\spad{approximate(f)} returns a truncated power series with the series variable viewed as an element of the coefficient domain.")) (|truncate| (($ $ |#3| |#3|) "\\spad{truncate(f,k1,k2)} returns a (finite) power series consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 \\spad{<=} \\spad{d} \\spad{<=} k2}.") (($ $ |#3|) "\\spad{truncate(f,k)} returns a (finite) power series consisting of the sum of all terms of \\spad{f} of degree \\spad{<= \\spad{k}.}")) (|order| ((|#3| $ |#3|) "\\spad{order(f,n) = min(m,n)}, where \\spad{m} is the degree of the lowest order non-zero term in \\spad{f.}") ((|#3| $) "\\spad{order(f)} is the degree of the lowest order non-zero term in \\spad{f.} This will result in an infinite loop if \\spad{f} has no non-zero terms.")) (|multiplyExponents| (($ $ (|PositiveInteger|)) "\\spad{multiplyExponents(f,n)} multiplies all exponents of the power series \\spad{f} by the positive integer \\spad{n.}")) (|center| ((|#2| $) "\\spad{center(f)} returns the point about which the series \\spad{f} is expanded.")) (|variable| (((|Symbol|) $) "\\spad{variable(f)} returns the (unique) power series variable of the power series \\spad{f.}")) (|elt| ((|#2| $ |#3|) "\\spad{elt(f(x),r)} returns the coefficient of the term of degree \\spad{r} in \\spad{f(x)}. This is the same as the function \\spadfun{coefficient}.")) (|terms| (((|Stream| (|Record| (|:| |k| |#3|) (|:| |c| |#2|))) $) "\\spad{terms(f(x))} returns a stream of non-zero terms, where a a term is an exponent-coefficient pair. The terms in the stream are ordered by increasing order of exponents."))) 
NIL 
((|HasCategory| |#2| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#2| (LIST (QUOTE *) (LIST (|devaluate| |#2|) (|devaluate| |#3|) (|devaluate| |#2|)))) (|HasCategory| |#3| (QUOTE (|SemiGroup|))) (|HasSignature| |#2| (LIST (QUOTE **) (LIST (|devaluate| |#2|) (|devaluate| |#2|) (|devaluate| |#3|)))) (|HasSignature| |#2| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#2|) (QUOTE (|Symbol|)))))) 
(|UnivariatePowerSeriesCategory| |Coef| |Expon|) 
((|constructor| (NIL "\\spadtype{UnivariatePowerSeriesCategory} is the most general univariate power series category with exponents in an ordered abelian monoid. Note that this category exports a substitution function if it is possible to multiply exponents. Also note that this category exports a derivative operation if it is possible to multiply coefficients by exponents.")) (|eval| (((|Stream| |#1|) $ |#1|) "\\spad{eval(f,a)} evaluates a power series at a value in the ground ring by returning a stream of partial sums.")) (|extend| (($ $ |#2|) "\\spad{extend(f,n)} causes all terms of \\spad{f} of degree \\spad{<=} \\spad{n} to be computed.")) (|approximate| ((|#1| $ |#2|) "\\spad{approximate(f)} returns a truncated power series with the series variable viewed as an element of the coefficient domain.")) (|truncate| (($ $ |#2| |#2|) "\\spad{truncate(f,k1,k2)} returns a (finite) power series consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 \\spad{<=} \\spad{d} \\spad{<=} k2}.") (($ $ |#2|) "\\spad{truncate(f,k)} returns a (finite) power series consisting of the sum of all terms of \\spad{f} of degree \\spad{<= \\spad{k}.}")) (|order| ((|#2| $ |#2|) "\\spad{order(f,n) = min(m,n)}, where \\spad{m} is the degree of the lowest order non-zero term in \\spad{f.}") ((|#2| $) "\\spad{order(f)} is the degree of the lowest order non-zero term in \\spad{f.} This will result in an infinite loop if \\spad{f} has no non-zero terms.")) (|multiplyExponents| (($ $ (|PositiveInteger|)) "\\spad{multiplyExponents(f,n)} multiplies all exponents of the power series \\spad{f} by the positive integer \\spad{n.}")) (|center| ((|#1| $) "\\spad{center(f)} returns the point about which the series \\spad{f} is expanded.")) (|variable| (((|Symbol|) $) "\\spad{variable(f)} returns the (unique) power series variable of the power series \\spad{f.}")) (|elt| ((|#1| $ |#2|) "\\spad{elt(f(x),r)} returns the coefficient of the term of degree \\spad{r} in \\spad{f(x)}. This is the same as the function \\spadfun{coefficient}.")) (|terms| (((|Stream| (|Record| (|:| |k| |#2|) (|:| |c| |#1|))) $) "\\spad{terms(f(x))} returns a stream of non-zero terms, where a a term is an exponent-coefficient pair. The terms in the stream are ordered by increasing order of exponents."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|UnivariatePolynomialSquareFree| RC P) 
((|constructor| (NIL "This package provides for square-free decomposition of univariate polynomials over arbitrary rings, \\spadignore{i.e.} a partial factorization such that each factor is a product of irreducibles with multiplicity one and the factors are pairwise relatively prime. If the ring has characteristic zero, the result is guaranteed to satisfy this condition. If the ring is an infinite ring of finite characteristic, then it may not be possible to decide when polynomials contain factors which are \\spad{p}th powers. In this case, the flag associated with that polynomial is set to \"nil\" (meaning that that polynomials are not guaranteed to be square-free).")) (|BumInSepFFE| (((|Record| (|:| |flg| (|Union| "nil" "sqfr" "irred" "prime")) (|:| |fctr| |#2|) (|:| |xpnt| (|Integer|))) (|Record| (|:| |flg| (|Union| "nil" "sqfr" "irred" "prime")) (|:| |fctr| |#2|) (|:| |xpnt| (|Integer|)))) "\\spad{BumInSepFFE(f)} is a local function, exported only because it has multiple conditional definitions.")) (|squareFreePart| ((|#2| |#2|) "\\spad{squareFreePart(p)} returns a polynomial which has the same irreducible factors as the univariate polynomial \\spad{p,} but each factor has multiplicity one.")) (|squareFree| (((|Factored| |#2|) |#2|) "\\spad{squareFree(p)} computes the square-free factorization of the univariate polynomial \\spad{p.} Each factor has no repeated roots, and the factors are pairwise relatively prime.")) (|gcd| (($ $ $) "\\spad{gcd(p,q)} computes the greatest-common-divisor of \\spad{p} and \\spad{q.}"))) 
NIL 
NIL 
(|UnivariatePuiseuxSeriesFunctions2| |Coef1| |Coef2| |var1| |var2| |cen1| |cen2|) 
((|constructor| (NIL "Mapping package for univariate Puiseux series. This package allows one to apply a function to the coefficients of a univariate Puiseux series.")) (|map| (((|UnivariatePuiseuxSeries| |#2| |#4| |#6|) (|Mapping| |#2| |#1|) (|UnivariatePuiseuxSeries| |#1| |#3| |#5|)) "\\spad{map(f,g(x))} applies the map \\spad{f} to the coefficients of the Puiseux series \\spad{g(x)}."))) 
NIL 
NIL 
(|UnivariatePuiseuxSeriesCategory| |Coef|) 
((|constructor| (NIL "\\spadtype{UnivariatePuiseuxSeriesCategory} is the category of Puiseux series in one variable.")) (|integrate| (($ $ (|Symbol|)) "\\spad{integrate(f(x),y)} returns an anti-derivative of the power series \\spad{f(x)} with respect to the variable \\spad{y}.") (($ $ (|Symbol|)) "\\spad{integrate(f(x),var)} returns an anti-derivative of the power series \\spad{f(x)} with respect to the variable \\spad{var}.") (($ $) "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 1. We may integrate a series when we can divide coefficients by rational numbers.")) (|multiplyExponents| (($ $ (|Fraction| (|Integer|))) "\\spad{multiplyExponents(f,r)} multiplies all exponents of the power series \\spad{f} by the positive rational number \\spad{r.}")) (|series| (($ (|NonNegativeInteger|) (|Stream| (|Record| (|:| |k| (|Fraction| (|Integer|))) (|:| |c| |#1|)))) "\\spad{series(n,st)} creates a series from a common denomiator and a stream of non-zero terms, where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents and \\spad{n} should be a common denominator for the exponents in the stream of terms."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|UnivariatePuiseuxSeriesConstructorCategory&| S |Coef| ULS) 
((|constructor| (NIL "This is a category of univariate Puiseux series constructed from univariate Laurent series. A Puiseux series is represented by a pair \\spad{[r,f(x)]}, where \\spad{r} is a positive rational number and \\spad{f(x)} is a Laurent series. This pair represents the Puiseux series \\spad{f(x^r)}.")) (|laurentIfCan| (((|Union| |#3| "failed") $) "\\spad{laurentIfCan(f(x))} converts the Puiseux series \\spad{f(x)} to a Laurent series if possible. If this is not possible, \"failed\" is returned.")) (|laurent| ((|#3| $) "\\spad{laurent(f(x))} converts the Puiseux series \\spad{f(x)} to a Laurent series if possible. Error: if this is not possible.")) (|coerce| (($ |#3|) "\\spad{coerce(f(x))} converts the Laurent series \\spad{f(x)} to a Puiseux series.")) (|degree| (((|Fraction| (|Integer|)) $) "\\spad{degree(f(x))} returns the degree of the leading term of the Puiseux series \\spad{f(x)}, which may have zero as a coefficient.")) (|laurentRep| ((|#3| $) "\\spad{laurentRep(f(x))} returns \\spad{g(x)} where the Puiseux series \\spad{f(x) = g(x^r)} is represented by \\spad{[r,g(x)]}.")) (|rationalPower| (((|Fraction| (|Integer|)) $) "\\spad{rationalPower(f(x))} returns \\spad{r} where the Puiseux series \\spad{f(x) = g(x^r)}.")) (|puiseux| (($ (|Fraction| (|Integer|)) |#3|) "\\spad{puiseux(r,f(x))} returns \\spad{f(x^r)}."))) 
NIL 
NIL 
(|UnivariatePuiseuxSeriesConstructorCategory| |Coef| ULS) 
((|constructor| (NIL "This is a category of univariate Puiseux series constructed from univariate Laurent series. A Puiseux series is represented by a pair \\spad{[r,f(x)]}, where \\spad{r} is a positive rational number and \\spad{f(x)} is a Laurent series. This pair represents the Puiseux series \\spad{f(x^r)}.")) (|laurentIfCan| (((|Union| |#2| "failed") $) "\\spad{laurentIfCan(f(x))} converts the Puiseux series \\spad{f(x)} to a Laurent series if possible. If this is not possible, \"failed\" is returned.")) (|laurent| ((|#2| $) "\\spad{laurent(f(x))} converts the Puiseux series \\spad{f(x)} to a Laurent series if possible. Error: if this is not possible.")) (|coerce| (($ |#2|) "\\spad{coerce(f(x))} converts the Laurent series \\spad{f(x)} to a Puiseux series.")) (|degree| (((|Fraction| (|Integer|)) $) "\\spad{degree(f(x))} returns the degree of the leading term of the Puiseux series \\spad{f(x)}, which may have zero as a coefficient.")) (|laurentRep| ((|#2| $) "\\spad{laurentRep(f(x))} returns \\spad{g(x)} where the Puiseux series \\spad{f(x) = g(x^r)} is represented by \\spad{[r,g(x)]}.")) (|rationalPower| (((|Fraction| (|Integer|)) $) "\\spad{rationalPower(f(x))} returns \\spad{r} where the Puiseux series \\spad{f(x) = g(x^r)}.")) (|puiseux| (($ (|Fraction| (|Integer|)) |#2|) "\\spad{puiseux(r,f(x))} returns \\spad{f(x^r)}."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|UnivariatePuiseuxSeriesConstructor| |Coef| ULS) 
((|constructor| (NIL "This package enables one to construct a univariate Puiseux series domain from a univariate Laurent series domain. Univariate Puiseux series are represented by a pair \\spad{[r,f(x)]}, where \\spad{r} is a positive rational number and \\spad{f(x)} is a Laurent series. This pair represents the Puiseux series \\spad{f(x^r)}."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))) (|devaluate| |#1|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))) (|devaluate| |#1|))))) (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|SemiGroup|))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|)))))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |AlgebraicallyClosedFunctionSpace|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|PrimitiveFunctionCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |integrate|) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Symbol|))))) (|HasSignature| |#1| (LIST (QUOTE |variables|) (LIST (LIST (QUOTE |List|) (QUOTE (|Symbol|))) (|devaluate| |#1|))))))) 
(|UnivariatePuiseuxSeries| |Coef| |var| |cen|) 
((|constructor| (NIL "Dense Puiseux series in one variable")) (|integrate| (($ $ (|Variable| |#2|)) "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.")) (|differentiate| (($ $ (|Variable| |#2|)) "\\spad{differentiate(f(x),x)} returns the derivative of \\spad{f(x)} with respect to \\spad{x}.")) (|coerce| (($ (|Variable| |#2|)) "\\spad{coerce(var)} converts the series variable \\spad{var} into a Puiseux series."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|canonicalUnitNormal| |has| |#1| (|Field|)) (|canonicalsClosed| |has| |#1| (|Field|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))) (|devaluate| |#1|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))) (|devaluate| |#1|))))) (|HasCategory| (|Fraction| (|Integer|)) (QUOTE (|SemiGroup|))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (OR (|HasCategory| |#1| (QUOTE (|Field|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|)))))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |AlgebraicallyClosedFunctionSpace|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|PrimitiveFunctionCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |integrate|) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Symbol|))))) (|HasSignature| |#1| (LIST (QUOTE |variables|) (LIST (LIST (QUOTE |List|) (QUOTE (|Symbol|))) (|devaluate| |#1|))))))) 
(|UnivariatePuiseuxSeriesWithExponentialSingularity| R FE |var| |cen|) 
((|constructor| (NIL "UnivariatePuiseuxSeriesWithExponentialSingularity is a domain used to represent functions with essential singularities. Objects in this domain are sums, where each term in the sum is a univariate Puiseux series times the exponential of a univariate Puiseux series. Thus, the elements of this domain are sums of expressions of the form \\spad{g(x) * exp(f(x))}, where g(x) is a univariate Puiseux series and f(x) is a univariate Puiseux series with no terms of non-negative degree.")) (|dominantTerm| (((|Union| (|Record| (|:| |%term| (|Record| (|:| |%coef| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|)) (|:| |%expon| (|ExponentialOfUnivariatePuiseuxSeries| |#2| |#3| |#4|)) (|:| |%expTerms| (|List| (|Record| (|:| |k| (|Fraction| (|Integer|))) (|:| |c| |#2|)))))) (|:| |%type| (|String|))) "failed") $) "\\spad{dominantTerm(f(var))} returns the term that dominates the limiting behavior of \\spad{f(var)} as \\spad{var \\spad{->} cen+} together with a \\spadtype{String} which briefly describes that behavior. The value of the \\spadtype{String} will be \\spad{\"zero\"} (resp. \\spad{\"infinity\"}) if the term tends to zero (resp. infinity) exponentially and will \\spad{\"series\"} if the term is a Puiseux series.")) (|limitPlus| (((|Union| (|OrderedCompletion| |#2|) "failed") $) "\\spad{limitPlus(f(var))} returns \\spad{limit(var \\spad{->} cen+,f(var))}."))) 
(((|commutative| "*") |has| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (|CommutativeRing|)) (|noZeroDivisors| |has| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (|IntegralDomain|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (QUOTE (|CharacteristicNonZero|))) (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (QUOTE (|CharacteristicZero|))) (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (QUOTE (|CommutativeRing|))) (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (LIST (QUOTE |RetractableTo|) (QUOTE (|Integer|)))) (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (QUOTE (|Field|))) (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (QUOTE (|GcdDomain|))) (OR (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (LIST (QUOTE |RetractableTo|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|)))))) (|HasCategory| (|UnivariatePuiseuxSeries| |#2| |#3| |#4|) (QUOTE (|IntegralDomain|)))) 
(|UnaryRecursiveAggregate&| A S) 
((|constructor| (NIL "A unary-recursive aggregate is a one where nodes may have either 0 or 1 children. This aggregate models, though not precisely, a linked list possibly with a single cycle. A node with one children models a non-empty list, with the \\spadfun{value} of the list designating the head, or \\spadfun{first}, of the list, and the child designating the tail, or \\spadfun{rest}, of the list. A node with no child then designates the empty list. Since these aggregates are recursive aggregates, they may be cyclic.")) (|split!| (($ $ (|Integer|)) "\\spad{split!(u,n)} splits \\spad{u} into two aggregates: \\axiom{v = rest(u,n)} and \\axiom{w = first(u,n)}, returning \\axiom{v}. Note that afterwards \\axiom{rest(u,n)} returns \\axiom{empty()}.")) (|setlast!| ((|#2| $ |#2|) "\\spad{setlast!(u,x)} destructively changes the last element of \\spad{u} to \\spad{x.}")) (|setrest!| (($ $ $) "\\spad{setrest!(u,v)} destructively changes the rest of \\spad{u} to \\spad{v.}")) (|setelt| ((|#2| $ "last" |#2|) "\\spad{setelt(u,\"last\",x)} (also written: \\axiom{u.last \\spad{:=} \\spad{b})} is equivalent to \\axiom{setlast!(u,v)}.") (($ $ "rest" $) "\\spad{setelt(u,\"rest\",v)} (also written: \\axiom{u.rest \\spad{:=} \\spad{v})} is equivalent to \\axiom{setrest!(u,v)}.") ((|#2| $ "first" |#2|) "\\spad{setelt(u,\"first\",x)} (also written: \\axiom{u.first \\spad{:=} \\spad{x})} is equivalent to \\axiom{setfirst!(u,x)}.")) (|setfirst!| ((|#2| $ |#2|) "\\spad{setfirst!(u,x)} destructively changes the first element of a to \\spad{x.}")) (|cycleSplit!| (($ $) "\\spad{cycleSplit!(u)} splits the aggregate by dropping off the cycle. The value returned is the cycle entry, or nil if none exists. For example, if \\axiom{w = concat(u,v)} is the cyclic list where \\spad{v} is the head of the cycle, \\axiom{cycleSplit!(w)} will drop \\spad{v} off \\spad{w} thus destructively changing \\spad{w} to u, and returning \\spad{v.}")) (|concat!| (($ $ |#2|) "\\spad{concat!(u,x)} destructively adds element \\spad{x} to the end of u. Note that \\axiom{concat!(a,x) = setlast!(a,[x])}.") (($ $ $) "\\spad{concat!(u,v)} destructively concatenates \\spad{v} to the end of u. Note that \\axiom{concat!(u,v) = setlast_!(u,v)}.")) (|cycleTail| (($ $) "\\spad{cycleTail(u)} returns the last node in the cycle, or empty if none exists.")) (|cycleLength| (((|NonNegativeInteger|) $) "\\spad{cycleLength(u)} returns the length of a top-level cycle contained in aggregate u, or 0 is \\spad{u} has no such cycle.")) (|cycleEntry| (($ $) "\\spad{cycleEntry(u)} returns the head of a top-level cycle contained in aggregate u, or \\axiom{empty()} if none exists.")) (|third| ((|#2| $) "\\spad{third(u)} returns the third element of u. Note that \\axiom{third(u) = first(rest(rest(u)))}.")) (|second| ((|#2| $) "\\spad{second(u)} returns the second element of u. Note that \\axiom{second(u) = first(rest(u))}.")) (|tail| (($ $) "\\spad{tail(u)} returns the last node of u. Note that if \\spad{u} is \\axiom{shallowlyMutable}, \\axiom{setrest(tail(u),v) = concat(u,v)}.")) (|last| (($ $ (|NonNegativeInteger|)) "\\spad{last(u,n)} returns a copy of the last \\spad{n} (\\axiom{n \\spad{>=} 0}) nodes of u. Note that \\axiom{last(u,n)} is a list of \\spad{n} elements.") ((|#2| $) "\\spad{last(u)} resturn the last element of u. Note that for lists, \\axiom{last(u)=u . (maxIndex u)=u . \\spad{(#} \\spad{u} - 1)}.")) (|rest| (($ $ (|NonNegativeInteger|)) "\\spad{rest(u,n)} returns the \\axiom{n}th \\spad{(n} \\spad{>=} 0) node of u. Note that \\axiom{rest(u,0) = u}.") (($ $) "\\spad{rest(u)} returns an aggregate consisting of all but the first element of \\spad{u} (equivalently, the next node of u).")) (|elt| ((|#2| $ "last") "\\spad{elt(u,\"last\")} (also written: \\axiom{u . last}) is equivalent to last u.") (($ $ "rest") "\\spad{elt(\\%,\"rest\")} (also written: \\axiom{u.rest}) is equivalent to \\axiom{rest u}.") ((|#2| $ "first") "\\spad{elt(u,\"first\")} (also written: \\axiom{u . first}) is equivalent to first u.")) (|first| (($ $ (|NonNegativeInteger|)) "\\spad{first(u,n)} returns a copy of the first \\spad{n} (\\axiom{n \\spad{>=} 0}) elements of u.") ((|#2| $) "\\spad{first(u)} returns the first element of \\spad{u} (equivalently, the value at the current node).")) (|concat| (($ |#2| $) "\\spad{concat(x,u)} returns aggregate consisting of \\spad{x} followed by the elements of u. Note that if \\axiom{v = concat(x,u)} then \\axiom{x = first \\spad{v}} and \\axiom{u = rest \\spad{v}.}") (($ $ $) "\\spad{concat(u,v)} returns an aggregate \\spad{w} consisting of the elements of \\spad{u} followed by the elements of \\spad{v.} Note that \\axiom{v = rest(w,\\#a)}."))) 
NIL 
((|HasAttribute| |#1| (QUOTE |shallowlyMutable|))) 
(|UnaryRecursiveAggregate| S) 
((|constructor| (NIL "A unary-recursive aggregate is a one where nodes may have either 0 or 1 children. This aggregate models, though not precisely, a linked list possibly with a single cycle. A node with one children models a non-empty list, with the \\spadfun{value} of the list designating the head, or \\spadfun{first}, of the list, and the child designating the tail, or \\spadfun{rest}, of the list. A node with no child then designates the empty list. Since these aggregates are recursive aggregates, they may be cyclic.")) (|split!| (($ $ (|Integer|)) "\\spad{split!(u,n)} splits \\spad{u} into two aggregates: \\axiom{v = rest(u,n)} and \\axiom{w = first(u,n)}, returning \\axiom{v}. Note that afterwards \\axiom{rest(u,n)} returns \\axiom{empty()}.")) (|setlast!| ((|#1| $ |#1|) "\\spad{setlast!(u,x)} destructively changes the last element of \\spad{u} to \\spad{x.}")) (|setrest!| (($ $ $) "\\spad{setrest!(u,v)} destructively changes the rest of \\spad{u} to \\spad{v.}")) (|setelt| ((|#1| $ "last" |#1|) "\\spad{setelt(u,\"last\",x)} (also written: \\axiom{u.last \\spad{:=} \\spad{b})} is equivalent to \\axiom{setlast!(u,v)}.") (($ $ "rest" $) "\\spad{setelt(u,\"rest\",v)} (also written: \\axiom{u.rest \\spad{:=} \\spad{v})} is equivalent to \\axiom{setrest!(u,v)}.") ((|#1| $ "first" |#1|) "\\spad{setelt(u,\"first\",x)} (also written: \\axiom{u.first \\spad{:=} \\spad{x})} is equivalent to \\axiom{setfirst!(u,x)}.")) (|setfirst!| ((|#1| $ |#1|) "\\spad{setfirst!(u,x)} destructively changes the first element of a to \\spad{x.}")) (|cycleSplit!| (($ $) "\\spad{cycleSplit!(u)} splits the aggregate by dropping off the cycle. The value returned is the cycle entry, or nil if none exists. For example, if \\axiom{w = concat(u,v)} is the cyclic list where \\spad{v} is the head of the cycle, \\axiom{cycleSplit!(w)} will drop \\spad{v} off \\spad{w} thus destructively changing \\spad{w} to u, and returning \\spad{v.}")) (|concat!| (($ $ |#1|) "\\spad{concat!(u,x)} destructively adds element \\spad{x} to the end of u. Note that \\axiom{concat!(a,x) = setlast!(a,[x])}.") (($ $ $) "\\spad{concat!(u,v)} destructively concatenates \\spad{v} to the end of u. Note that \\axiom{concat!(u,v) = setlast_!(u,v)}.")) (|cycleTail| (($ $) "\\spad{cycleTail(u)} returns the last node in the cycle, or empty if none exists.")) (|cycleLength| (((|NonNegativeInteger|) $) "\\spad{cycleLength(u)} returns the length of a top-level cycle contained in aggregate u, or 0 is \\spad{u} has no such cycle.")) (|cycleEntry| (($ $) "\\spad{cycleEntry(u)} returns the head of a top-level cycle contained in aggregate u, or \\axiom{empty()} if none exists.")) (|third| ((|#1| $) "\\spad{third(u)} returns the third element of u. Note that \\axiom{third(u) = first(rest(rest(u)))}.")) (|second| ((|#1| $) "\\spad{second(u)} returns the second element of u. Note that \\axiom{second(u) = first(rest(u))}.")) (|tail| (($ $) "\\spad{tail(u)} returns the last node of u. Note that if \\spad{u} is \\axiom{shallowlyMutable}, \\axiom{setrest(tail(u),v) = concat(u,v)}.")) (|last| (($ $ (|NonNegativeInteger|)) "\\spad{last(u,n)} returns a copy of the last \\spad{n} (\\axiom{n \\spad{>=} 0}) nodes of u. Note that \\axiom{last(u,n)} is a list of \\spad{n} elements.") ((|#1| $) "\\spad{last(u)} resturn the last element of u. Note that for lists, \\axiom{last(u)=u . (maxIndex u)=u . \\spad{(#} \\spad{u} - 1)}.")) (|rest| (($ $ (|NonNegativeInteger|)) "\\spad{rest(u,n)} returns the \\axiom{n}th \\spad{(n} \\spad{>=} 0) node of u. Note that \\axiom{rest(u,0) = u}.") (($ $) "\\spad{rest(u)} returns an aggregate consisting of all but the first element of \\spad{u} (equivalently, the next node of u).")) (|elt| ((|#1| $ "last") "\\spad{elt(u,\"last\")} (also written: \\axiom{u . last}) is equivalent to last u.") (($ $ "rest") "\\spad{elt(\\%,\"rest\")} (also written: \\axiom{u.rest}) is equivalent to \\axiom{rest u}.") ((|#1| $ "first") "\\spad{elt(u,\"first\")} (also written: \\axiom{u . first}) is equivalent to first u.")) (|first| (($ $ (|NonNegativeInteger|)) "\\spad{first(u,n)} returns a copy of the first \\spad{n} (\\axiom{n \\spad{>=} 0}) elements of u.") ((|#1| $) "\\spad{first(u)} returns the first element of \\spad{u} (equivalently, the value at the current node).")) (|concat| (($ |#1| $) "\\spad{concat(x,u)} returns aggregate consisting of \\spad{x} followed by the elements of u. Note that if \\axiom{v = concat(x,u)} then \\axiom{x = first \\spad{v}} and \\axiom{u = rest \\spad{v}.}") (($ $ $) "\\spad{concat(u,v)} returns an aggregate \\spad{w} consisting of the elements of \\spad{u} followed by the elements of \\spad{v.} Note that \\axiom{v = rest(w,\\#a)}."))) 
((|nil| . T)) 
NIL 
(|UnivariateTaylorSeriesFunctions2| |Coef1| |Coef2| UTS1 UTS2) 
((|constructor| (NIL "Mapping package for univariate Taylor series. This package allows one to apply a function to the coefficients of a univariate Taylor series.")) (|map| ((|#4| (|Mapping| |#2| |#1|) |#3|) "\\spad{map(f,g(x))} applies the map \\spad{f} to the coefficients of \\indented{1}{the Taylor series \\spad{g(x)}.}"))) 
NIL 
NIL 
(|UnivariateTaylorSeriesCategory&| S |Coef|) 
((|constructor| (NIL "\\spadtype{UnivariateTaylorSeriesCategory} is the category of Taylor series in one variable.")) (|integrate| (($ $ (|Symbol|)) "\\spad{integrate(f(x),y)} returns an anti-derivative of the power series \\spad{f(x)} with respect to the variable \\spad{y}.") (($ $ (|Symbol|)) "\\spad{integrate(f(x),y)} returns an anti-derivative of the power series \\spad{f(x)} with respect to the variable \\spad{y}.") (($ $) "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.")) (** (($ $ |#2|) "\\spad{f(x) \\spad{**} a} computes a power of a power series. When the coefficient ring is a field, we may raise a series to an exponent from the coefficient ring provided that the constant coefficient of the series is 1.")) (|polynomial| (((|Polynomial| |#2|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{polynomial(f,k1,k2)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 \\spad{<=} \\spad{d} \\spad{<=} k2}.") (((|Polynomial| |#2|) $ (|NonNegativeInteger|)) "\\spad{polynomial(f,k)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{<= \\spad{k}.}")) (|multiplyCoefficients| (($ (|Mapping| |#2| (|Integer|)) $) "\\spad{multiplyCoefficients(f,sum(n = 0..infinity,a[n] * x**n))} returns \\spad{sum(n = 0..infinity,f(n) * a[n] * x**n)}. This function is used when Laurent series are represented by a Taylor series and an order.")) (|quoByVar| (($ $) "\\spad{quoByVar(a0 + \\spad{a1} \\spad{x} + \\spad{a2} \\spad{x**2} + ...)} returns \\spad{a1 + \\spad{a2} \\spad{x} + \\spad{a3} \\spad{x**2} + ...} Thus, this function substracts the constant term and divides by the series variable. This function is used when Laurent series are represented by a Taylor series and an order.")) (|coefficients| (((|Stream| |#2|) $) "\\spad{coefficients(a0 + \\spad{a1} \\spad{x} + \\spad{a2} \\spad{x**2} + ...)} returns a stream of coefficients: \\spad{[a0,a1,a2,...]}. The entries of the stream may be zero.")) (|series| (($ (|Stream| |#2|)) "\\spad{series([a0,a1,a2,...])} is the Taylor series \\spad{a0 + \\spad{a1} \\spad{x} + \\spad{a2} \\spad{x**2} + ...}.") (($ (|Stream| (|Record| (|:| |k| (|NonNegativeInteger|)) (|:| |c| |#2|)))) "\\spad{series(st)} creates a series from a stream of non-zero terms, where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents."))) 
NIL 
((|HasCategory| |#2| (LIST (QUOTE |AlgebraicallyClosedFunctionSpace|) (QUOTE (|Integer|)))) (|HasCategory| |#2| (QUOTE (|PrimitiveFunctionCategory|))) (|HasCategory| |#2| (QUOTE (|TranscendentalFunctionCategory|))) (|HasSignature| |#2| (LIST (QUOTE |variables|) (LIST (LIST (QUOTE |List|) (QUOTE (|Symbol|))) (|devaluate| |#2|)))) (|HasSignature| |#2| (LIST (QUOTE |integrate|) (LIST (|devaluate| |#2|) (|devaluate| |#2|) (QUOTE (|Symbol|))))) (|HasCategory| |#2| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#2| (QUOTE (|Field|)))) 
(|UnivariateTaylorSeriesCategory| |Coef|) 
((|constructor| (NIL "\\spadtype{UnivariateTaylorSeriesCategory} is the category of Taylor series in one variable.")) (|integrate| (($ $ (|Symbol|)) "\\spad{integrate(f(x),y)} returns an anti-derivative of the power series \\spad{f(x)} with respect to the variable \\spad{y}.") (($ $ (|Symbol|)) "\\spad{integrate(f(x),y)} returns an anti-derivative of the power series \\spad{f(x)} with respect to the variable \\spad{y}.") (($ $) "\\spad{integrate(f(x))} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.")) (** (($ $ |#1|) "\\spad{f(x) \\spad{**} a} computes a power of a power series. When the coefficient ring is a field, we may raise a series to an exponent from the coefficient ring provided that the constant coefficient of the series is 1.")) (|polynomial| (((|Polynomial| |#1|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{polynomial(f,k1,k2)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{d} with \\spad{k1 \\spad{<=} \\spad{d} \\spad{<=} k2}.") (((|Polynomial| |#1|) $ (|NonNegativeInteger|)) "\\spad{polynomial(f,k)} returns a polynomial consisting of the sum of all terms of \\spad{f} of degree \\spad{<= \\spad{k}.}")) (|multiplyCoefficients| (($ (|Mapping| |#1| (|Integer|)) $) "\\spad{multiplyCoefficients(f,sum(n = 0..infinity,a[n] * x**n))} returns \\spad{sum(n = 0..infinity,f(n) * a[n] * x**n)}. This function is used when Laurent series are represented by a Taylor series and an order.")) (|quoByVar| (($ $) "\\spad{quoByVar(a0 + \\spad{a1} \\spad{x} + \\spad{a2} \\spad{x**2} + ...)} returns \\spad{a1 + \\spad{a2} \\spad{x} + \\spad{a3} \\spad{x**2} + ...} Thus, this function substracts the constant term and divides by the series variable. This function is used when Laurent series are represented by a Taylor series and an order.")) (|coefficients| (((|Stream| |#1|) $) "\\spad{coefficients(a0 + \\spad{a1} \\spad{x} + \\spad{a2} \\spad{x**2} + ...)} returns a stream of coefficients: \\spad{[a0,a1,a2,...]}. The entries of the stream may be zero.")) (|series| (($ (|Stream| |#1|)) "\\spad{series([a0,a1,a2,...])} is the Taylor series \\spad{a0 + \\spad{a1} \\spad{x} + \\spad{a2} \\spad{x**2} + ...}.") (($ (|Stream| (|Record| (|:| |k| (|NonNegativeInteger|)) (|:| |c| |#1|)))) "\\spad{series(st)} creates a series from a stream of non-zero terms, where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|UnivariateTaylorSeries| |Coef| |var| |cen|) 
((|constructor| (NIL "Dense Taylor series in one variable \\spadtype{UnivariateTaylorSeries} is a domain representing Taylor series in one variable with coefficients in an arbitrary ring. The parameters of the type specify the coefficient ring, the power series variable, and the center of the power series expansion. For example, \\spadtype{UnivariateTaylorSeries}(Integer,x,3) represents Taylor series in \\spad{(x - 3)} with \\spadtype{Integer} coefficients.")) (|integrate| (($ $ (|Variable| |#2|)) "\\spad{integrate(f(x),x)} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.")) (|invmultisect| (($ (|Integer|) (|Integer|) $) "\\spad{invmultisect(a,b,f(x))} substitutes \\spad{x^((a+b)*n)} \\indented{1}{for \\spad{x^n} and multiples by \\spad{x^b}.}")) (|multisect| (($ (|Integer|) (|Integer|) $) "\\spad{multisect(a,b,f(x))} selects the coefficients of \\indented{1}{\\spad{x^((a+b)*n+a)}, and changes this monomial to \\spad{x^n}.}")) (|revert| (($ $) "\\spad{revert(f(x))} returns a Taylor series \\spad{g(x)} such that \\spad{f(g(x)) = g(f(x)) = \\spad{x}.} Series \\spad{f(x)} should have constant coefficient 0 and 1st order coefficient 1.")) (|generalLambert| (($ $ (|Integer|) (|Integer|)) "\\spad{generalLambert(f(x),a,d)} returns \\spad{f(x^a) + f(x^(a + \\spad{d))} + \\indented{1}{f(x^(a + 2 \\spad{d))} + \\spad{...} \\spad{}.} \\spad{f(x)} should have zero constant} \\indented{1}{coefficient and \\spad{a} and \\spad{d} should be positive.}")) (|evenlambert| (($ $) "\\spad{evenlambert(f(x))} returns \\spad{f(x^2) + f(x^4) + f(x^6) + ...}. \\indented{1}{\\spad{f(x)} should have a zero constant coefficient.} \\indented{1}{This function is used for computing infinite products.} \\indented{1}{If \\spad{f(x)} is a Taylor series with constant term 1, then} \\indented{1}{\\spad{product(n=1..infinity,f(x^(2*n))) = exp(log(evenlambert(f(x))))}.}")) (|oddlambert| (($ $) "\\spad{oddlambert(f(x))} returns \\spad{f(x) + f(x^3) + f(x^5) + ...}. \\indented{1}{\\spad{f(x)} should have a zero constant coefficient.} \\indented{1}{This function is used for computing infinite products.} \\indented{1}{If \\spad{f(x)} is a Taylor series with constant term 1, then} \\indented{1}{\\spad{product(n=1..infinity,f(x^(2*n-1)))=exp(log(oddlambert(f(x))))}.}")) (|lambert| (($ $) "\\spad{lambert(f(x))} returns \\spad{f(x) + f(x^2) + f(x^3) + ...}. \\indented{1}{This function is used for computing infinite products.} \\indented{1}{\\spad{f(x)} should have zero constant coefficient.} \\indented{1}{If \\spad{f(x)} is a Taylor series with constant term 1, then} \\indented{1}{\\spad{product(n = 1..infinity,f(x^n)) = exp(log(lambert(f(x))))}.}")) (|lagrange| (($ $) "\\spad{lagrange(g(x))} produces the Taylor series for \\spad{f(x)} \\indented{1}{where \\spad{f(x)} is implicitly defined as \\spad{f(x) = x*g(f(x))}.}")) (|differentiate| (($ $ (|Variable| |#2|)) "\\spad{differentiate(f(x),x)} computes the derivative of \\spad{f(x)} with respect to \\spad{x}.")) (|univariatePolynomial| (((|UnivariatePolynomial| |#2| |#1|) $ (|NonNegativeInteger|)) "\\spad{univariatePolynomial(f,k)} returns a univariate polynomial \\indented{1}{consisting of the sum of all terms of \\spad{f} of degree \\spad{<= k}.}")) (|coerce| (($ (|Variable| |#2|)) "\\spad{coerce(var)} converts the series variable \\spad{var} into a \\indented{1}{Taylor series.}") (($ (|UnivariatePolynomial| |#2| |#1|)) "\\spad{coerce(p)} converts a univariate polynomial \\spad{p} in the variable \\spad{var} to a univariate Taylor series in \\spad{var}."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|)) (|devaluate| |#1|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|)) (|devaluate| |#1|))))) (|HasCategory| (|NonNegativeInteger|) (QUOTE (|SemiGroup|))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|)))))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |AlgebraicallyClosedFunctionSpace|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|PrimitiveFunctionCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |integrate|) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Symbol|))))) (|HasSignature| |#1| (LIST (QUOTE |variables|) (LIST (LIST (QUOTE |List|) (QUOTE (|Symbol|))) (|devaluate| |#1|))))))) 
(|UnivariateTaylorSeriesODESolver| |Coef| UTS) 
((|constructor| (NIL "Taylor series solutions of explicit ODE's. This package provides Taylor series solutions to regular linear or non-linear ordinary differential equations of arbitrary order.")) (|mpsode| (((|List| |#2|) (|List| |#1|) (|List| (|Mapping| |#2| (|List| |#2|)))) "\\spad{mpsode(r,f)} solves the system of differential equations \\spad{dy[i]/dx =f[i] [x,y[1],y[2],...,y[n]]}, \\spad{y[i](a) = r[i]} for \\spad{i} in 1..n.")) (|ode| ((|#2| (|Mapping| |#2| (|List| |#2|)) (|List| |#1|)) "\\spad{ode(f,cl)} is the solution to \\spad{y<n>=f(y,y',..,y<n-1>)} such that \\spad{y<i>(a) = cl.i} for \\spad{i} in 1..n.")) (|ode2| ((|#2| (|Mapping| |#2| |#2| |#2|) |#1| |#1|) "\\spad{ode2(f,c0,c1)} is the solution to \\spad{y'' = f(y,y')} such that \\spad{y(a) = \\spad{c0}} and \\spad{y'(a) = c1}.")) (|ode1| ((|#2| (|Mapping| |#2| |#2|) |#1|) "\\spad{ode1(f,c)} is the solution to \\spad{y' = f(y)} such that \\spad{y(a) = \\spad{c}.}")) (|fixedPointExquo| ((|#2| |#2| |#2|) "\\spad{fixedPointExquo(f,g)} computes the exact quotient of \\spad{f} and \\spad{g} using a fixed point computation.")) (|stFuncN| (((|Mapping| (|Stream| |#1|) (|List| (|Stream| |#1|))) (|Mapping| |#2| (|List| |#2|))) "\\spad{stFuncN(f)} is a local function xported due to compiler problem. This function is of no interest to the top-level user.")) (|stFunc2| (((|Mapping| (|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) (|Mapping| |#2| |#2| |#2|)) "\\spad{stFunc2(f)} is a local function exported due to compiler problem. This function is of no interest to the top-level user.")) (|stFunc1| (((|Mapping| (|Stream| |#1|) (|Stream| |#1|)) (|Mapping| |#2| |#2|)) "\\spad{stFunc1(f)} is a local function exported due to compiler problem. This function is of no interest to the top-level user."))) 
NIL 
NIL 
(|UTSodetools| F UP L UTS) 
((|constructor| (NIL "\\spad{RUTSodetools} provides tools to interface with the series ODE solver when presented with linear ODEs.")) (RF2UTS ((|#4| (|Fraction| |#2|)) "\\spad{RF2UTS(f)} converts \\spad{f} to a Taylor series.")) (LODO2FUN (((|Mapping| |#4| (|List| |#4|)) |#3|) "\\spad{LODO2FUN(op)} returns the function to pass to the series ODE solver in order to solve \\spad{op \\spad{y} = 0}.")) (UTS2UP ((|#2| |#4| (|NonNegativeInteger|)) "\\spad{UTS2UP(s, \\spad{n)}} converts the first \\spad{n} terms of \\spad{s} to a univariate polynomial.")) (UP2UTS ((|#4| |#2|) "\\spad{UP2UTS(p)} converts \\spad{p} to a Taylor series."))) 
NIL 
((|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) 
(|TaylorSolve| F UTSF UTSSUPF) 
((|constructor| (NIL "This package has no description"))) 
NIL 
NIL 
(|UnivariateTaylorSeriesCZero| |Coef| |var|) 
((|constructor| (NIL "Part of the Package for Algebraic Function Fields in one variable PAFF")) (|integrate| (($ $ (|Variable| |#2|)) "\\spad{integrate(f(x),x)} returns an anti-derivative of the power series \\spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.")) (|invmultisect| (($ (|Integer|) (|Integer|) $) "\\spad{invmultisect(a,b,f(x))} substitutes \\spad{x^((a+b)*n)} \\indented{1}{for \\spad{x^n} and multiples by \\spad{x^b}.}")) (|multisect| (($ (|Integer|) (|Integer|) $) "\\spad{multisect(a,b,f(x))} selects the coefficients of \\indented{1}{\\spad{x^((a+b)*n+a)}, and changes this monomial to \\spad{x^n}.}")) (|revert| (($ $) "\\spad{revert(f(x))} returns a Taylor series \\spad{g(x)} such that \\spad{f(g(x)) = g(f(x)) = \\spad{x}.} Series \\spad{f(x)} should have constant coefficient 0 and 1st order coefficient 1.")) (|generalLambert| (($ $ (|Integer|) (|Integer|)) "\\spad{generalLambert(f(x),a,d)} returns \\spad{f(x^a) + f(x^(a + \\spad{d))} + \\indented{1}{f(x^(a + 2 \\spad{d))} + \\spad{...} \\spad{}.} \\spad{f(x)} should have zero constant} \\indented{1}{coefficient and \\spad{a} and \\spad{d} should be positive.}")) (|evenlambert| (($ $) "\\spad{evenlambert(f(x))} returns \\spad{f(x^2) + f(x^4) + f(x^6) + ...}. \\indented{1}{\\spad{f(x)} should have a zero constant coefficient.} \\indented{1}{This function is used for computing infinite products.} \\indented{1}{If \\spad{f(x)} is a Taylor series with constant term 1, then} \\indented{1}{\\spad{product(n=1..infinity,f(x^(2*n)))=exp(log(evenlambert(f(x))))}.}")) (|oddlambert| (($ $) "\\spad{oddlambert(f(x))} returns \\spad{f(x) + f(x^3) + f(x^5) + ...}. \\indented{1}{\\spad{f(x)} should have a zero constant coefficient.} \\indented{1}{This function is used for computing infinite products.} \\indented{1}{If \\spad{f(x)} is a Taylor series with constant term 1, then} \\indented{1}{\\spad{product(n=1..infinity,f(x^(2*n-1)))=exp(log(oddlambert(f(x))))}.}")) (|lambert| (($ $) "\\spad{lambert(f(x))} returns \\spad{f(x) + f(x^2) + f(x^3) + ...}. \\indented{1}{This function is used for computing infinite products.} \\indented{1}{\\spad{f(x)} should have zero constant coefficient.} \\indented{1}{If \\spad{f(x)} is a Taylor series with constant term 1, then} \\indented{1}{\\spad{product(n = 1..infinity,f(x^n)) = exp(log(lambert(f(x))))}.}")) (|lagrange| (($ $) "\\spad{lagrange(g(x))} produces the Taylor series for \\spad{f(x)} \\indented{1}{where \\spad{f(x)} is implicitly defined as \\spad{f(x) = x*g(f(x))}.}")) (|differentiate| (($ $ (|Variable| |#2|)) "\\spad{differentiate(f(x),x)} computes the derivative of \\spad{f(x)} with respect to \\spad{x}.")) (|univariatePolynomial| (((|UnivariatePolynomial| |#2| |#1|) $ (|NonNegativeInteger|)) "\\spad{univariatePolynomial(f,k)} returns a univariate polynomial \\indented{1}{consisting of the sum of all terms of \\spad{f} of degree \\spad{<= k}.}")) (|coerce| (($ (|Variable| |#2|)) "\\spad{coerce(var)} converts the series variable \\spad{var} into a \\indented{1}{Taylor series.}") (($ (|UnivariatePolynomial| |#2| |#1|)) "\\spad{coerce(p)} converts a univariate polynomial \\spad{p} in the variable \\spad{var} to a univariate Taylor series in \\spad{var}."))) 
(((|commutative| "*") |has| |#1| (|CommutativeRing|)) (|noZeroDivisors| |has| |#1| (|IntegralDomain|)) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (OR (|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|)))) (|HasCategory| |#1| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#1| (QUOTE (|CharacteristicZero|))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|)) (|devaluate| |#1|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |PartialDifferentialRing|) (QUOTE (|Symbol|)))) (|HasSignature| |#1| (LIST (QUOTE *) (LIST (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|)) (|devaluate| |#1|))))) (|HasCategory| (|NonNegativeInteger|) (QUOTE (|SemiGroup|))) (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|))))) (AND (|HasSignature| |#1| (LIST (QUOTE **) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|NonNegativeInteger|))))) (|HasSignature| |#1| (LIST (QUOTE |coerce|) (LIST (|devaluate| |#1|) (QUOTE (|Symbol|)))))) (|HasCategory| |#1| (QUOTE (|Field|))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |AlgebraicallyClosedFunctionSpace|) (QUOTE (|Integer|)))) (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasCategory| |#1| (QUOTE (|PrimitiveFunctionCategory|))) (|HasCategory| |#1| (QUOTE (|TranscendentalFunctionCategory|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Algebra|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasSignature| |#1| (LIST (QUOTE |integrate|) (LIST (|devaluate| |#1|) (|devaluate| |#1|) (QUOTE (|Symbol|))))) (|HasSignature| |#1| (LIST (QUOTE |variables|) (LIST (LIST (QUOTE |List|) (QUOTE (|Symbol|))) (|devaluate| |#1|))))))) 
(|Variable| |sym|) 
((|constructor| (NIL "This domain implements variables")) (|variable| (((|Symbol|)) "\\spad{variable()} returns the symbol")) (|coerce| (((|Symbol|) $) "\\spad{coerce(x)} returns the symbol"))) 
NIL 
NIL 
(|VectorCategory&| S R) 
((|constructor| (NIL "\\spadtype{VectorCategory} represents the type of vector like objects, that is, finite sequences indexed by some finite segment of the integers. The operations available on vectors depend on the structure of the underlying components. Many operations from the component domain are defined for vectors componentwise. It can by assumed that extraction or updating components can be done in constant time.")) (|magnitude| ((|#2| $) "\\spad{magnitude(v)} computes the sqrt(dot(v,v)), that is, the length")) (|length| ((|#2| $) "\\spad{length(v)} computes the sqrt(dot(v,v)), that is, the magnitude")) (|cross| (($ $ $) "\\spad{cross(u,v)} constructs the cross product of \\spad{u} and \\spad{v.} Error: if \\spad{u} and \\spad{v} are not of length 3.")) (|outerProduct| (((|Matrix| |#2|) $ $) "\\spad{outerProduct(u,v)} constructs the matrix whose (i,j)'th element is u(i)*v(j).")) (|dot| ((|#2| $ $) "\\spad{dot(x,y)} computes the inner product of the two vectors \\spad{x} and \\spad{y.} Error: if \\spad{x} and \\spad{y} are not of the same length.")) (* (($ $ |#2|) "\\spad{y * \\spad{r}} multiplies each component of the vector \\spad{y} by the element \\spad{r.}") (($ |#2| $) "\\spad{r * \\spad{y}} multiplies the element \\spad{r} times each component of the vector \\spad{y.}") (($ (|Integer|) $) "\\spad{n * \\spad{y}} multiplies each component of the vector \\spad{y} by the integer \\spad{n.}")) (- (($ $ $) "\\spad{x - \\spad{y}} returns the component-wise difference of the vectors \\spad{x} and \\spad{y.} Error: if \\spad{x} and \\spad{y} are not of the same length.") (($ $) "\\spad{-x} negates all components of the vector \\spad{x.}")) (|zero| (($ (|NonNegativeInteger|)) "\\spad{zero(n)} creates a zero vector of length \\spad{n.}")) (+ (($ $ $) "\\spad{x + \\spad{y}} returns the component-wise sum of the vectors \\spad{x} and \\spad{y.} Error: if \\spad{x} and \\spad{y} are not of the same length."))) 
NIL 
((|HasCategory| |#2| (QUOTE (|RadicalCategory|))) (|HasCategory| |#2| (QUOTE (|Ring|))) (|HasCategory| |#2| (QUOTE (|Monoid|))) (|HasCategory| |#2| (QUOTE (|AbelianGroup|))) (|HasCategory| |#2| (QUOTE (|AbelianMonoid|))) (|HasCategory| |#2| (QUOTE (|AbelianSemiGroup|)))) 
(|VectorCategory| R) 
((|constructor| (NIL "\\spadtype{VectorCategory} represents the type of vector like objects, that is, finite sequences indexed by some finite segment of the integers. The operations available on vectors depend on the structure of the underlying components. Many operations from the component domain are defined for vectors componentwise. It can by assumed that extraction or updating components can be done in constant time.")) (|magnitude| ((|#1| $) "\\spad{magnitude(v)} computes the sqrt(dot(v,v)), that is, the length")) (|length| ((|#1| $) "\\spad{length(v)} computes the sqrt(dot(v,v)), that is, the magnitude")) (|cross| (($ $ $) "\\spad{cross(u,v)} constructs the cross product of \\spad{u} and \\spad{v.} Error: if \\spad{u} and \\spad{v} are not of length 3.")) (|outerProduct| (((|Matrix| |#1|) $ $) "\\spad{outerProduct(u,v)} constructs the matrix whose (i,j)'th element is u(i)*v(j).")) (|dot| ((|#1| $ $) "\\spad{dot(x,y)} computes the inner product of the two vectors \\spad{x} and \\spad{y.} Error: if \\spad{x} and \\spad{y} are not of the same length.")) (* (($ $ |#1|) "\\spad{y * \\spad{r}} multiplies each component of the vector \\spad{y} by the element \\spad{r.}") (($ |#1| $) "\\spad{r * \\spad{y}} multiplies the element \\spad{r} times each component of the vector \\spad{y.}") (($ (|Integer|) $) "\\spad{n * \\spad{y}} multiplies each component of the vector \\spad{y} by the integer \\spad{n.}")) (- (($ $ $) "\\spad{x - \\spad{y}} returns the component-wise difference of the vectors \\spad{x} and \\spad{y.} Error: if \\spad{x} and \\spad{y} are not of the same length.") (($ $) "\\spad{-x} negates all components of the vector \\spad{x.}")) (|zero| (($ (|NonNegativeInteger|)) "\\spad{zero(n)} creates a zero vector of length \\spad{n.}")) (+ (($ $ $) "\\spad{x + \\spad{y}} returns the component-wise sum of the vectors \\spad{x} and \\spad{y.} Error: if \\spad{x} and \\spad{y} are not of the same length."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T) (|nil| . T)) 
NIL 
(|VectorFunctions2| A B) 
((|constructor| (NIL "This package provides operations which all take as arguments vectors of elements of some type \\spad{A} and functions from \\spad{A} to another of type \\spad{B.} The operations all iterate over their vector argument and either return a value of type \\spad{B} or a vector over \\spad{B.}")) (|map| (((|Union| (|Vector| |#2|) "failed") (|Mapping| (|Union| |#2| "failed") |#1|) (|Vector| |#1|)) "\\spad{map(f, \\spad{v)}} applies the function \\spad{f} to every element of the vector \\spad{v} producing a new vector containing the values or \\spad{\"failed\"}.") (((|Vector| |#2|) (|Mapping| |#2| |#1|) (|Vector| |#1|)) "\\spad{map(f, \\spad{v)}} applies the function \\spad{f} to every element of the vector \\spad{v} producing a new vector containing the values.")) (|reduce| ((|#2| (|Mapping| |#2| |#1| |#2|) (|Vector| |#1|) |#2|) "\\spad{reduce(func,vec,ident)} combines the elements in \\spad{vec} using the binary function func. Argument \\spad{ident} is returned if \\spad{vec} is empty.")) (|scan| (((|Vector| |#2|) (|Mapping| |#2| |#1| |#2|) (|Vector| |#1|) |#2|) "\\spad{scan(func,vec,ident)} creates a new vector whose elements are the result of applying reduce to the binary function func, increasing initial subsequences of the vector vec, and the element ident."))) 
NIL 
NIL 
(|Vector| R) 
((|constructor| (NIL "This type represents vector like objects with varying lengths and indexed by a finite segment of integers starting at 1.")) (|vector| (($ (|List| |#1|)) "\\spad{vector(l)} converts the list \\spad{l} to a vector."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#1| (QUOTE (|SetCategory|))) (|HasCategory| |#1| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (OR (|HasCategory| |#1| (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|))) (|HasCategory| |#1| (QUOTE (|AbelianSemiGroup|))) (|HasCategory| |#1| (QUOTE (|AbelianMonoid|))) (|HasCategory| |#1| (QUOTE (|AbelianGroup|))) (|HasCategory| |#1| (QUOTE (|Monoid|))) (|HasCategory| |#1| (QUOTE (|Ring|))) (AND (|HasCategory| |#1| (QUOTE (|RadicalCategory|))) (|HasCategory| |#1| (QUOTE (|Ring|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))) (OR (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|OrderedSet|)))) (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|))) (|HasCategory| |#1| (QUOTE (|SetCategory|)))))) 
(|TwoDimensionalViewport|) 
((|constructor| (NIL "TwoDimensionalViewport creates viewports to display graphs.")) (|coerce| (((|OutputForm|) $) "\\spad{coerce(v)} returns the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport} as output of the domain \\spadtype{OutputForm}.")) (|key| (((|Integer|) $) "\\spad{key(v)} returns the process ID number of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}.")) (|reset| (((|Void|) $) "\\spad{reset(v)} sets the current state of the graph characteristics of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, back to their initial settings.")) (|write| (((|String|) $ (|String|) (|List| (|String|))) "\\spad{write(v,s,lf)} takes the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, and creates a directory indicated by \\spad{s,} which contains the graph data files for \\spad{v} and the optional file types indicated by the list \\spad{lf.}") (((|String|) $ (|String|) (|String|)) "\\spad{write(v,s,f)} takes the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, and creates a directory indicated by \\spad{s,} which contains the graph data files for \\spad{v} and an optional file type \\spad{f.}") (((|String|) $ (|String|)) "\\spad{write(v,s)} takes the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, and creates a directory indicated by \\spad{s,} which contains the graph data files for \\spad{v.}")) (|resize| (((|Void|) $ (|PositiveInteger|) (|PositiveInteger|)) "\\spad{resize(v,w,h)} displays the two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, with a width of \\spad{w} and a height of \\spad{h,} keeping the upper left-hand corner position unchanged.")) (|update| (((|Void|) $ (|GraphImage|) (|PositiveInteger|)) "\\spad{update(v,gr,n)} drops the graph \\spad{gr} in slot \\spad{n} of viewport \\spad{v}. The graph \\spad{gr} must have been transmitted already and acquired an integer key.")) (|move| (((|Void|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{move(v,x,y)} displays the two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, with the upper left-hand corner of the viewport window at the screen coordinate position \\spad{x,} \\spad{y.}")) (|show| (((|Void|) $ (|PositiveInteger|) (|String|)) "\\spad{show(v,n,s)} displays the graph in field \\spad{n} of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, if \\spad{s} is \"on\", or does not display the graph if \\spad{s} is \"off\".")) (|translate| (((|Void|) $ (|PositiveInteger|) (|Float|) (|Float|)) "\\spad{translate(v,n,dx,dy)} displays the graph in field \\spad{n} of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, translated by \\spad{dx} in the x-coordinate direction from the center of the viewport, and by \\spad{dy} in the y-coordinate direction from the center. Setting \\spad{dx} and \\spad{dy} to \\spad{0} places the center of the graph at the center of the viewport.")) (|scale| (((|Void|) $ (|PositiveInteger|) (|Float|) (|Float|)) "\\spad{scale(v,n,sx,sy)} displays the graph in field \\spad{n} of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, scaled by the factor \\spad{sx} in the x-coordinate direction and by the factor \\spad{sy} in the y-coordinate direction.")) (|dimensions| (((|Void|) $ (|NonNegativeInteger|) (|NonNegativeInteger|) (|PositiveInteger|) (|PositiveInteger|)) "\\spad{dimensions(v,x,y,width,height)} sets the position of the upper left-hand corner of the two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, to the window coordinate \\spad{x,} \\spad{y,} and sets the dimensions of the window to that of \\spad{width}, \\spad{height}. The new dimensions are not displayed until the function \\spadfun{makeViewport2D} is executed again for \\spad{v.}")) (|close| (((|Void|) $) "\\spad{close(v)} closes the viewport window of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, and terminates the corresponding process ID.")) (|controlPanel| (((|Void|) $ (|String|)) "\\spad{controlPanel(v,s)} displays the control panel of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, if \\spad{s} is \"on\", or hides the control panel if \\spad{s} is \"off\".")) (|connect| (((|Void|) $ (|PositiveInteger|) (|String|)) "\\spad{connect(v,n,s)} displays the lines connecting the graph points in field \\spad{n} of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, if \\spad{s} is \"on\", or does not display the lines if \\spad{s} is \"off\".")) (|region| (((|Void|) $ (|PositiveInteger|) (|String|)) "\\spad{region(v,n,s)} displays the bounding box of the graph in field \\spad{n} of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, if \\spad{s} is \"on\", or does not display the bounding box if \\spad{s} is \"off\".")) (|points| (((|Void|) $ (|PositiveInteger|) (|String|)) "\\spad{points(v,n,s)} displays the points of the graph in field \\spad{n} of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, if \\spad{s} is \"on\", or does not display the points if \\spad{s} is \"off\".")) (|units| (((|Void|) $ (|PositiveInteger|) (|Palette|)) "\\spad{units(v,n,c)} displays the units of the graph in field \\spad{n} of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, with the units color set to the given palette color \\spad{c.}") (((|Void|) $ (|PositiveInteger|) (|String|)) "\\spad{units(v,n,s)} displays the units of the graph in field \\spad{n} of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, if \\spad{s} is \"on\", or does not display the units if \\spad{s} is \"off\".")) (|axes| (((|Void|) $ (|PositiveInteger|) (|Palette|)) "\\spad{axes(v,n,c)} displays the axes of the graph in field \\spad{n} of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, with the axes color set to the given palette color \\spad{c.}") (((|Void|) $ (|PositiveInteger|) (|String|)) "\\spad{axes(v,n,s)} displays the axes of the graph in field \\spad{n} of the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, if \\spad{s} is \"on\", or does not display the axes if \\spad{s} is \"off\".")) (|getGraph| (((|GraphImage|) $ (|PositiveInteger|)) "\\spad{getGraph(v,n)} returns the graph which is of the domain \\spadtype{GraphImage} which is located in graph field \\spad{n} of the given two-dimensional viewport, \\spad{v,} which is of the domain \\spadtype{TwoDimensionalViewport}.")) (|putGraph| (((|Void|) $ (|GraphImage|) (|PositiveInteger|)) "\\spad{putGraph(v,gi,n)} sets the graph field indicated by \\spad{n,} of the indicated two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}, to be the graph, \\spad{gi} of domain \\spadtype{GraphImage}. The contents of viewport, \\spad{v,} will contain \\spad{gi} when the function \\spadfun{makeViewport2D} is called to create the an updated viewport \\spad{v.}")) (|title| (((|Void|) $ (|String|)) "\\spad{title(v,s)} changes the title which is shown in the two-dimensional viewport window, \\spad{v} of domain \\spadtype{TwoDimensionalViewport}.")) (|graphs| (((|Vector| (|Union| (|GraphImage|) "undefined")) $) "\\spad{graphs(v)} returns a vector, or list, which is a union of all the graphs, of the domain \\spadtype{GraphImage}, which are allocated for the two-dimensional viewport, \\spad{v,} of domain \\spadtype{TwoDimensionalViewport}. Those graphs which have no data are labeled \"undefined\", otherwise their contents are shown.")) (|graphStates| (((|Vector| (|Record| (|:| |scaleX| (|DoubleFloat|)) (|:| |scaleY| (|DoubleFloat|)) (|:| |deltaX| (|DoubleFloat|)) (|:| |deltaY| (|DoubleFloat|)) (|:| |points| (|Integer|)) (|:| |connect| (|Integer|)) (|:| |spline| (|Integer|)) (|:| |axes| (|Integer|)) (|:| |axesColor| (|Palette|)) (|:| |units| (|Integer|)) (|:| |unitsColor| (|Palette|)) (|:| |showing| (|Integer|)))) $) "\\spad{graphStates(v)} returns and shows a listing of a record containing the current state of the characteristics of each of the ten graph records in the given two-dimensional viewport, \\spad{v,} which is of domain \\spadtype{TwoDimensionalViewport}.")) (|graphState| (((|Void|) $ (|PositiveInteger|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|DoubleFloat|) (|Integer|) (|Integer|) (|Integer|) (|Integer|) (|Palette|) (|Integer|) (|Palette|) (|Integer|)) "\\spad{graphState(v,num,sX,sY,dX,dY,pts,lns,box,axes,axesC,un,unC,cP)} sets the state of the characteristics for the graph indicated by \\spad{num} in the given two-dimensional viewport \\spad{v,} of domain \\spadtype{TwoDimensionalViewport}, to the values given as parameters. The scaling of the graph in the \\spad{x} and \\spad{y} component directions is set to be \\spad{sX} and \\spad{sY}; the window translation in the \\spad{x} and \\spad{y} component directions is set to be \\spad{dX} and \\spad{dY}; The graph points, lines, bounding box, axes, or units will be shown in the viewport if their given parameters \\spad{pts}, \\spad{lns}, \\spad{box}, \\spad{axes} or \\spad{un} are set to be \\spad{1}, but will not be shown if they are set to \\spad{0}. The color of the \\spad{axes} and the color of the units are indicated by the palette colors \\spad{axesC} and \\spad{unC} respectively. To display the control panel when the viewport window is displayed, set \\spad{cP} to \\spad{1}, otherwise set it to \\spad{0}.")) (|options| (($ $ (|List| (|DrawOption|))) "\\spad{options(v,lopt)} takes the given two-dimensional viewport, \\spad{v,} of the domain \\spadtype{TwoDimensionalViewport} and returns \\spad{v} with it's draw options modified to be those which are indicated in the given list, \\spad{lopt} of domain \\spadtype{DrawOption}.") (((|List| (|DrawOption|)) $) "\\spad{options(v)} takes the given two-dimensional viewport, \\spad{v,} of the domain \\spadtype{TwoDimensionalViewport} and returns a list containing the draw options from the domain \\spadtype{DrawOption} for \\spad{v.}")) (|makeViewport2D| (($ (|GraphImage|) (|List| (|DrawOption|))) "\\spad{makeViewport2D(gi,lopt)} creates and displays a viewport window of the domain \\spadtype{TwoDimensionalViewport} whose graph field is assigned to be the given graph, \\spad{gi}, of domain \\spadtype{GraphImage}, and whose options field is set to be the list of options, \\spad{lopt} of domain \\spadtype{DrawOption}.") (($ $) "\\spad{makeViewport2D(v)} takes the given two-dimensional viewport, \\spad{v,} of the domain \\spadtype{TwoDimensionalViewport} and displays a viewport window on the screen which contains the contents of \\spad{v.}")) (|viewport2D| (($) "\\spad{viewport2D()} returns an undefined two-dimensional viewport of the domain \\spadtype{TwoDimensionalViewport} whose contents are empty.")) (|getPickedPoints| (((|List| (|Point| (|DoubleFloat|))) $) "\\spad{getPickedPoints(x)} returns a list of small floats for the points the user interactively picked on the viewport for full integration into the system, some design issues need to be addressed: \\spadignore{e.g.} how to go through the GraphImage interface, how to default to graphs, etc."))) 
NIL 
NIL 
(|ThreeDimensionalViewport|) 
((|constructor| (NIL "ThreeDimensionalViewport creates viewports to display graphs")) (|key| (((|Integer|) $) "\\spad{key(v)} returns the process ID number of the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}.")) (|close| (((|Void|) $) "\\spad{close(v)} closes the viewport window of the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}, and terminates the corresponding process ID.")) (|write| (((|String|) $ (|String|) (|List| (|String|))) "\\spad{write(v,s,lf)} takes the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}, and creates a directory indicated by \\spad{s,} which contains the graph data file for \\spad{v} and the optional file types indicated by the list \\spad{lf.}") (((|String|) $ (|String|) (|String|)) "\\spad{write(v,s,f)} takes the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}, and creates a directory indicated by \\spad{s,} which contains the graph data file for \\spad{v} and an optional file type \\spad{f.}") (((|String|) $ (|String|)) "\\spad{write(v,s)} takes the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}, and creates a directory indicated by \\spad{s,} which contains the graph data file for \\spad{v.}")) (|colorDef| (((|Void|) $ (|Color|) (|Color|)) "\\spad{colorDef(v,c1,c2)} sets the range of colors along the colormap so that the lower end of the colormap is defined by \\spad{c1} and the top end of the colormap is defined by \\spad{c2}, for the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}.")) (|reset| (((|Void|) $) "\\spad{reset(v)} sets the current state of the graph characteristics of the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}, back to their initial settings.")) (|intensity| (((|Void|) $ (|Float|)) "\\spad{intensity(v,i)} sets the intensity of the light source to i, for the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}.")) (|lighting| (((|Void|) $ (|Float|) (|Float|) (|Float|)) "\\spad{lighting(v,x,y,z)} sets the position of the light source to the coordinates \\spad{x,} \\spad{y,} and \\spad{z} and displays the graph for the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}.")) (|clipSurface| (((|Void|) $ (|String|)) "\\spad{clipSurface(v,s)} displays the graph with the specified clipping region removed if \\spad{s} is \"on\", or displays the graph without clipping implemented if \\spad{s} is \"off\", for the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}.")) (|showClipRegion| (((|Void|) $ (|String|)) "\\spad{showClipRegion(v,s)} displays the clipping region of the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}, if \\spad{s} is \"on\", or does not display the region if \\spad{s} is \"off\".")) (|showRegion| (((|Void|) $ (|String|)) "\\spad{showRegion(v,s)} displays the bounding box of the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}, if \\spad{s} is \"on\", or does not display the box if \\spad{s} is \"off\".")) (|hitherPlane| (((|Void|) $ (|Float|)) "\\spad{hitherPlane(v,h)} sets the hither clipping plane of the graph to \\spad{h,} for the viewport \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport}.")) (|eyeDistance| (((|Void|) $ (|Float|)) "\\spad{eyeDistance(v,d)} sets the distance of the observer from the center of the graph to \\spad{d,} for the viewport \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport}.")) (|perspective| (((|Void|) $ (|String|)) "\\spad{perspective(v,s)} displays the graph in perspective if \\spad{s} is \"on\", or does not display perspective if \\spad{s} is \"off\" for the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}.")) (|translate| (((|Void|) $ (|Float|) (|Float|)) "\\spad{translate(v,dx,dy)} sets the horizontal viewport offset to \\spad{dx} and the vertical viewport offset to \\spad{dy}, for the viewport \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport}.")) (|zoom| (((|Void|) $ (|Float|) (|Float|) (|Float|)) "\\spad{zoom(v,sx,sy,sz)} sets the graph scaling factors for the x-coordinate axis to \\spad{sx}, the y-coordinate axis to \\spad{sy} and the z-coordinate axis to \\spad{sz} for the viewport \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport}.") (((|Void|) $ (|Float|)) "\\spad{zoom(v,s)} sets the graph scaling factor to \\spad{s,} for the viewport \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport}.")) (|rotate| (((|Void|) $ (|Integer|) (|Integer|)) "\\spad{rotate(v,th,phi)} rotates the graph to the longitudinal view angle \\spad{th} degrees and the latitudinal view angle \\spad{phi} degrees for the viewport \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport}. The new rotation position is not displayed until the function \\spadfun{makeViewport3D} is executed again for \\spad{v.}") (((|Void|) $ (|Float|) (|Float|)) "\\spad{rotate(v,th,phi)} rotates the graph to the longitudinal view angle \\spad{th} radians and the latitudinal view angle \\spad{phi} radians for the viewport \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport}.")) (|drawStyle| (((|Void|) $ (|String|)) "\\spad{drawStyle(v,s)} displays the surface for the given three-dimensional viewport \\spad{v} which is of domain \\spadtype{ThreeDimensionalViewport} in the style of drawing indicated by \\spad{s.} If \\spad{s} is not a valid drawing style the style is wireframe by default. Possible styles are \\spad{\"shade\"}, \\spad{\"solid\"} or \\spad{\"opaque\"}, \\spad{\"smooth\"}, and \\spad{\"wireMesh\"}.")) (|outlineRender| (((|Void|) $ (|String|)) "\\spad{outlineRender(v,s)} displays the polygon outline showing either triangularized surface or a quadrilateral surface outline depending on the whether the \\spadfun{diagonals} function has been set, for the given three-dimensional viewport \\spad{v} which is of domain \\spadtype{ThreeDimensionalViewport}, if \\spad{s} is \"on\", or does not display the polygon outline if \\spad{s} is \"off\".")) (|diagonals| (((|Void|) $ (|String|)) "\\spad{diagonals(v,s)} displays the diagonals of the polygon outline showing a triangularized surface instead of a quadrilateral surface outline, for the given three-dimensional viewport \\spad{v} which is of domain \\spadtype{ThreeDimensionalViewport}, if \\spad{s} is \"on\", or does not display the diagonals if \\spad{s} is \"off\".")) (|axes| (((|Void|) $ (|String|)) "\\spad{axes(v,s)} displays the axes of the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}, if \\spad{s} is \"on\", or does not display the axes if \\spad{s} is \"off\".")) (|controlPanel| (((|Void|) $ (|String|)) "\\spad{controlPanel(v,s)} displays the control panel of the given three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}, if \\spad{s} is \"on\", or hides the control panel if \\spad{s} is \"off\".")) (|viewpoint| (((|Void|) $ (|Float|) (|Float|) (|Float|)) "\\spad{viewpoint(v,rotx,roty,rotz)} sets the rotation about the x-axis to be \\spad{rotx} radians, sets the rotation about the y-axis to be \\spad{roty} radians, and sets the rotation about the z-axis to be \\spad{rotz} radians, for the viewport \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport} and displays \\spad{v} with the new view position.") (((|Void|) $ (|Float|) (|Float|)) "\\spad{viewpoint(v,th,phi)} sets the longitudinal view angle to \\spad{th} radians and the latitudinal view angle to \\spad{phi} radians for the viewport \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport}. The new viewpoint position is not displayed until the function \\spadfun{makeViewport3D} is executed again for \\spad{v.}") (((|Void|) $ (|Integer|) (|Integer|) (|Float|) (|Float|) (|Float|)) "\\spad{viewpoint(v,th,phi,s,dx,dy)} sets the longitudinal view angle to \\spad{th} degrees, the latitudinal view angle to \\spad{phi} degrees, the scale factor to \\spad{s}, the horizontal viewport offset to \\spad{dx}, and the vertical viewport offset to \\spad{dy} for the viewport \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport}. The new viewpoint position is not displayed until the function \\spadfun{makeViewport3D} is executed again for \\spad{v.}") (((|Void|) $ (|Record| (|:| |theta| (|DoubleFloat|)) (|:| |phi| (|DoubleFloat|)) (|:| |scale| (|DoubleFloat|)) (|:| |scaleX| (|DoubleFloat|)) (|:| |scaleY| (|DoubleFloat|)) (|:| |scaleZ| (|DoubleFloat|)) (|:| |deltaX| (|DoubleFloat|)) (|:| |deltaY| (|DoubleFloat|)))) "\\spad{viewpoint(v,viewpt)} sets the viewpoint for the viewport. The viewport record consists of the latitudal and longitudal angles, the zoom factor, the x,y and \\spad{z} scales, and the \\spad{x} and \\spad{y} displacements.") (((|Record| (|:| |theta| (|DoubleFloat|)) (|:| |phi| (|DoubleFloat|)) (|:| |scale| (|DoubleFloat|)) (|:| |scaleX| (|DoubleFloat|)) (|:| |scaleY| (|DoubleFloat|)) (|:| |scaleZ| (|DoubleFloat|)) (|:| |deltaX| (|DoubleFloat|)) (|:| |deltaY| (|DoubleFloat|))) $) "\\spad{viewpoint(v)} returns the current viewpoint setting of the given viewport, \\spad{v.} This function is useful in the situation where the user has created a viewport, proceeded to interact with it via the control panel and desires to save the values of the viewpoint as the default settings for another viewport to be created using the system.") (((|Void|) $ (|Float|) (|Float|) (|Float|) (|Float|) (|Float|)) "\\spad{viewpoint(v,th,phi,s,dx,dy)} sets the longitudinal view angle to \\spad{th} radians, the latitudinal view angle to \\spad{phi} radians, the scale factor to \\spad{s}, the horizontal viewport offset to \\spad{dx}, and the vertical viewport offset to \\spad{dy} for the viewport \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport}. The new viewpoint position is not displayed until the function \\spadfun{makeViewport3D} is executed again for \\spad{v.}")) (|dimensions| (((|Void|) $ (|NonNegativeInteger|) (|NonNegativeInteger|) (|PositiveInteger|) (|PositiveInteger|)) "\\spad{dimensions(v,x,y,width,height)} sets the position of the upper left-hand corner of the three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}, to the window coordinate \\spad{x,} \\spad{y,} and sets the dimensions of the window to that of \\spad{width}, \\spad{height}. The new dimensions are not displayed until the function \\spadfun{makeViewport3D} is executed again for \\spad{v.}")) (|title| (((|Void|) $ (|String|)) "\\spad{title(v,s)} changes the title which is shown in the three-dimensional viewport window, \\spad{v} of domain \\spadtype{ThreeDimensionalViewport}.")) (|resize| (((|Void|) $ (|PositiveInteger|) (|PositiveInteger|)) "\\spad{resize(v,w,h)} displays the three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}, with a width of \\spad{w} and a height of \\spad{h,} keeping the upper left-hand corner position unchanged.")) (|move| (((|Void|) $ (|NonNegativeInteger|) (|NonNegativeInteger|)) "\\spad{move(v,x,y)} displays the three-dimensional viewport, \\spad{v,} which is of domain \\spadtype{ThreeDimensionalViewport}, with the upper left-hand corner of the viewport window at the screen coordinate position \\spad{x,} \\spad{y.}")) (|options| (($ $ (|List| (|DrawOption|))) "\\spad{options(v,lopt)} takes the viewport, \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport} and sets the draw options being used by \\spad{v} to those indicated in the list, \\spad{lopt}, which is a list of options from the domain \\spad{DrawOption}.") (((|List| (|DrawOption|)) $) "\\spad{options(v)} takes the viewport, \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport} and returns a list of all the draw options from the domain \\spad{DrawOption} which are being used by \\spad{v.}")) (|modifyPointData| (((|Void|) $ (|NonNegativeInteger|) (|Point| (|DoubleFloat|))) "\\spad{modifyPointData(v,ind,pt)} takes the viewport, \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport}, and places the data point, \\spad{pt} into the list of points database of \\spad{v} at the index location given by \\spad{ind}.")) (|subspace| (($ $ (|ThreeSpace| (|DoubleFloat|))) "\\spad{subspace(v,sp)} places the contents of the viewport \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport}, in the subspace \\spad{sp}, which is of the domain \\spad{ThreeSpace}.") (((|ThreeSpace| (|DoubleFloat|)) $) "\\spad{subspace(v)} returns the contents of the viewport \\spad{v,} which is of the domain \\spadtype{ThreeDimensionalViewport}, as a subspace of the domain \\spad{ThreeSpace}.")) (|makeViewport3D| (($ (|ThreeSpace| (|DoubleFloat|)) (|List| (|DrawOption|))) "\\spad{makeViewport3D(sp,lopt)} takes the given space, \\spad{sp} which is of the domain \\spadtype{ThreeSpace} and displays a viewport window on the screen which contains the contents of \\spad{sp}, and whose draw options are indicated by the list \\spad{lopt}, which is a list of options from the domain \\spad{DrawOption}.") (($ (|ThreeSpace| (|DoubleFloat|)) (|String|)) "\\spad{makeViewport3D(sp,s)} takes the given space, \\spad{sp} which is of the domain \\spadtype{ThreeSpace} and displays a viewport window on the screen which contains the contents of \\spad{sp}, and whose title is given by \\spad{s.}") (($ $) "\\spad{makeViewport3D(v)} takes the given three-dimensional viewport, \\spad{v,} of the domain \\spadtype{ThreeDimensionalViewport} and displays a viewport window on the screen which contains the contents of \\spad{v.}")) (|viewport3D| (($) "\\spad{viewport3D()} returns an undefined three-dimensional viewport of the domain \\spadtype{ThreeDimensionalViewport} whose contents are empty.")) (|viewDeltaYDefault| (((|Float|) (|Float|)) "\\spad{viewDeltaYDefault(dy)} sets the current default vertical offset from the center of the viewport window to be \\spad{dy} and returns \\spad{dy}.") (((|Float|)) "\\spad{viewDeltaYDefault()} returns the current default vertical offset from the center of the viewport window.")) (|viewDeltaXDefault| (((|Float|) (|Float|)) "\\spad{viewDeltaXDefault(dx)} sets the current default horizontal offset from the center of the viewport window to be \\spad{dx} and returns \\spad{dx}.") (((|Float|)) "\\spad{viewDeltaXDefault()} returns the current default horizontal offset from the center of the viewport window.")) (|viewZoomDefault| (((|Float|) (|Float|)) "\\spad{viewZoomDefault(s)} sets the current default graph scaling value to \\spad{s} and returns \\spad{s.}") (((|Float|)) "\\spad{viewZoomDefault()} returns the current default graph scaling value.")) (|viewPhiDefault| (((|Float|) (|Float|)) "\\spad{viewPhiDefault(p)} sets the current default latitudinal view angle in radians to the value \\spad{p} and returns \\spad{p.}") (((|Float|)) "\\spad{viewPhiDefault()} returns the current default latitudinal view angle in radians.")) (|viewThetaDefault| (((|Float|) (|Float|)) "\\spad{viewThetaDefault(t)} sets the current default longitudinal view angle in radians to the value \\spad{t} and returns \\spad{t.}") (((|Float|)) "\\spad{viewThetaDefault()} returns the current default longitudinal view angle in radians."))) 
NIL 
NIL 
(|ViewDefaultsPackage|) 
((|constructor| (NIL "ViewportDefaultsPackage describes default and user definable values for graphics")) (|tubeRadiusDefault| (((|DoubleFloat|)) "\\spad{tubeRadiusDefault()} returns the radius used for a 3D tube plot.") (((|DoubleFloat|) (|Float|)) "\\spad{tubeRadiusDefault(r)} sets the default radius for a 3D tube plot to \\spad{r.}")) (|tubePointsDefault| (((|PositiveInteger|)) "\\spad{tubePointsDefault()} returns the number of points to be used when creating the circle to be used in creating a 3D tube plot.") (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{tubePointsDefault(i)} sets the number of points to use when creating the circle to be used in creating a 3D tube plot to i.")) (|var2StepsDefault| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{var2StepsDefault(i)} sets the number of steps to take when creating a 3D mesh in the direction of the first defined free variable to \\spad{i} (a free variable is considered defined when its range is specified (\\spadignore{e.g.} x=0..10)).") (((|PositiveInteger|)) "\\spad{var2StepsDefault()} is the current setting for the number of steps to take when creating a 3D mesh in the direction of the first defined free variable (a free variable is considered defined when its range is specified (\\spadignore{e.g.} x=0..10)).")) (|var1StepsDefault| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{var1StepsDefault(i)} sets the number of steps to take when creating a 3D mesh in the direction of the first defined free variable to \\spad{i} (a free variable is considered defined when its range is specified (\\spadignore{e.g.} x=0..10)).") (((|PositiveInteger|)) "\\spad{var1StepsDefault()} is the current setting for the number of steps to take when creating a 3D mesh in the direction of the first defined free variable (a free variable is considered defined when its range is specified (\\spadignore{e.g.} x=0..10)).")) (|viewWriteAvailable| (((|List| (|String|))) "\\spad{viewWriteAvailable()} returns a list of available methods for writing, such as BITMAP, POSTSCRIPT, etc.")) (|viewWriteDefault| (((|List| (|String|)) (|List| (|String|))) "\\spad{viewWriteDefault(l)} sets the default list of things to write in a viewport data file to the strings in \\spad{l;} a viewalone file is always genereated.") (((|List| (|String|))) "\\spad{viewWriteDefault()} returns the list of things to write in a viewport data file; a viewalone file is always generated.")) (|viewDefaults| (((|Void|)) "\\spad{viewDefaults()} resets all the default graphics settings.")) (|viewSizeDefault| (((|List| (|PositiveInteger|)) (|List| (|PositiveInteger|))) "\\spad{viewSizeDefault([w,h])} sets the default viewport width to \\spad{w} and height to \\spad{h.}") (((|List| (|PositiveInteger|))) "\\spad{viewSizeDefault()} returns the default viewport width and height.")) (|viewPosDefault| (((|List| (|NonNegativeInteger|)) (|List| (|NonNegativeInteger|))) "\\spad{viewPosDefault([x,y])} sets the default \\spad{x} and \\spad{y} position of a viewport window unless overriden explicityly, newly created viewports will have the \\spad{x} and \\spad{y} coordinates \\spad{x,} \\spad{y.}") (((|List| (|NonNegativeInteger|))) "\\spad{viewPosDefault()} returns the default \\spad{x} and \\spad{y} position of a viewport window unless overriden explicityly, newly created viewports will have this \\spad{x} and \\spad{y} coordinate.")) (|pointSizeDefault| (((|PositiveInteger|) (|PositiveInteger|)) "\\spad{pointSizeDefault(i)} sets the default size of the points in a 2D viewport to i.") (((|PositiveInteger|)) "\\spad{pointSizeDefault()} returns the default size of the points in a 2D viewport.")) (|unitsColorDefault| (((|Palette|) (|Palette|)) "\\spad{unitsColorDefault(p)} sets the default color of the unit ticks in a 2D viewport to the palette \\spad{p.}") (((|Palette|)) "\\spad{unitsColorDefault()} returns the default color of the unit ticks in a 2D viewport.")) (|axesColorDefault| (((|Palette|) (|Palette|)) "\\spad{axesColorDefault(p)} sets the default color of the axes in a 2D viewport to the palette \\spad{p.}") (((|Palette|)) "\\spad{axesColorDefault()} returns the default color of the axes in a 2D viewport.")) (|lineColorDefault| (((|Palette|) (|Palette|)) "\\spad{lineColorDefault(p)} sets the default color of lines connecting points in a 2D viewport to the palette \\spad{p.}") (((|Palette|)) "\\spad{lineColorDefault()} returns the default color of lines connecting points in a 2D viewport.")) (|pointColorDefault| (((|Palette|) (|Palette|)) "\\spad{pointColorDefault(p)} sets the default color of points in a 2D viewport to the palette \\spad{p.}") (((|Palette|)) "\\spad{pointColorDefault()} returns the default color of points in a 2D viewport."))) 
NIL 
NIL 
(|ViewportPackage|) 
((|constructor| (NIL "ViewportPackage provides functions for creating GraphImages and TwoDimensionalViewports from lists of lists of points.")) (|coerce| (((|TwoDimensionalViewport|) (|GraphImage|)) "\\spad{coerce(gi)} converts the indicated \\spadtype{GraphImage}, gi, into the \\spadtype{TwoDimensionalViewport} form.")) (|drawCurves| (((|TwoDimensionalViewport|) (|List| (|List| (|Point| (|DoubleFloat|)))) (|List| (|DrawOption|))) "\\spad{drawCurves([[p0],[p1],...,[pn]],[options])} creates a \\spadtype{TwoDimensionalViewport} from the list of lists of points, \\spad{p0} throught \\spad{pn,} using the options specified in the list \\spad{options}.") (((|TwoDimensionalViewport|) (|List| (|List| (|Point| (|DoubleFloat|)))) (|Palette|) (|Palette|) (|PositiveInteger|) (|List| (|DrawOption|))) "\\spad{drawCurves([[p0],[p1],...,[pn]],ptColor,lineColor,ptSize,[options])} creates a \\spadtype{TwoDimensionalViewport} from the list of lists of points, \\spad{p0} throught \\spad{pn,} using the options specified in the list \\spad{options}. The point color is specified by \\spad{ptColor}, the line color is specified by \\spad{lineColor}, and the point size is specified by \\spad{ptSize}.")) (|graphCurves| (((|GraphImage|) (|List| (|List| (|Point| (|DoubleFloat|)))) (|List| (|DrawOption|))) "\\spad{graphCurves([[p0],[p1],...,[pn]],[options])} creates a \\spadtype{GraphImage} from the list of lists of points, \\spad{p0} throught \\spad{pn,} using the options specified in the list \\spad{options}.") (((|GraphImage|) (|List| (|List| (|Point| (|DoubleFloat|))))) "\\spad{graphCurves([[p0],[p1],...,[pn]])} creates a \\spadtype{GraphImage} from the list of lists of points indicated by \\spad{p0} through \\spad{pn.}") (((|GraphImage|) (|List| (|List| (|Point| (|DoubleFloat|)))) (|Palette|) (|Palette|) (|PositiveInteger|) (|List| (|DrawOption|))) "\\spad{graphCurves([[p0],[p1],...,[pn]],ptColor,lineColor,ptSize,[options])} creates a \\spadtype{GraphImage} from the list of lists of points, \\spad{p0} throught \\spad{pn,} using the options specified in the list \\spad{options}. The graph point color is specified by \\spad{ptColor}, the graph line color is specified by \\spad{lineColor}, and the size of the points is specified by \\spad{ptSize}."))) 
NIL 
NIL 
(|Void|) 
((|constructor| (NIL "This type is used when no value is needed, \\spadignore{e.g.} in the \\spad{then} part of a one armed \\spad{if}. All values can be coerced to type Void. Once a value has been coerced to Void, it cannot be recovered.")) (|coerce| (((|OutputForm|) $) "\\spad{coerce(v)} coerces void object to outputForm.")) (|void| (($) "\\spad{void()} produces a void object."))) 
NIL 
NIL 
(|VectorSpace&| A S) 
((|constructor| (NIL "Vector Spaces (not necessarily finite dimensional) over a field.")) (|dimension| (((|CardinalNumber|)) "\\spad{dimension()} returns the dimensionality of the vector space.")) (/ (($ $ |#2|) "\\spad{x/y} divides the vector \\spad{x} by the scalar \\spad{y.}"))) 
NIL 
NIL 
(|VectorSpace| S) 
((|constructor| (NIL "Vector Spaces (not necessarily finite dimensional) over a field.")) (|dimension| (((|CardinalNumber|)) "\\spad{dimension()} returns the dimensionality of the vector space.")) (/ (($ $ |#1|) "\\spad{x/y} divides the vector \\spad{x} by the scalar \\spad{y.}"))) 
((|leftUnitary| . T) (|rightUnitary| . T)) 
NIL 
(|WeierstrassPreparation| R) 
((|constructor| (NIL "This package implements the Weierstrass preparation theorem \\spad{f} or multivariate power series. weierstrass(v,p) where \\spad{v} is a variable, and \\spad{p} is a TaylorSeries(R) in which the terms of lowest degree \\spad{s} must include c*v**s where \\spad{c} is a constant,s>0, is a list of TaylorSeries coefficients A[i] of the equivalent polynomial A = A[0] + A[1]*v + \\spad{A[2]*v**2} + \\spad{...} + A[s-1]*v**(s-1) + v**s such that p=A*B ,{} \\spad{B} being a TaylorSeries of minimum degree 0")) (|qqq| (((|Mapping| (|Stream| (|TaylorSeries| |#1|)) (|Stream| (|TaylorSeries| |#1|))) (|NonNegativeInteger|) (|TaylorSeries| |#1|) (|Stream| (|TaylorSeries| |#1|))) "\\spad{qqq(n,s,st)} is used internally.")) (|weierstrass| (((|List| (|TaylorSeries| |#1|)) (|Symbol|) (|TaylorSeries| |#1|)) "\\spad{weierstrass(v,ts)} where \\spad{v} is a variable and \\spad{ts} is \\indented{1}{a TaylorSeries, impements the Weierstrass Preparation} \\indented{1}{Theorem. The result is a list of TaylorSeries that} \\indented{1}{are the coefficients of the equivalent series.}")) (|clikeUniv| (((|Mapping| (|SparseUnivariatePolynomial| (|Polynomial| |#1|)) (|Polynomial| |#1|)) (|Symbol|)) "\\spad{clikeUniv(v)} is used internally.")) (|sts2stst| (((|Stream| (|Stream| (|Polynomial| |#1|))) (|Symbol|) (|Stream| (|Polynomial| |#1|))) "\\spad{sts2stst(v,s)} is used internally.")) (|cfirst| (((|Mapping| (|Stream| (|Polynomial| |#1|)) (|Stream| (|Polynomial| |#1|))) (|NonNegativeInteger|)) "\\spad{cfirst \\spad{n}} is used internally.")) (|crest| (((|Mapping| (|Stream| (|Polynomial| |#1|)) (|Stream| (|Polynomial| |#1|))) (|NonNegativeInteger|)) "\\spad{crest \\spad{n}} is used internally."))) 
NIL 
NIL 
(|WildFunctionFieldIntegralBasis| K R UP F) 
((|constructor| (NIL "In this package \\spad{K} is a finite field, \\spad{R} is a ring of univariate polynomials over \\spad{K,} and \\spad{F} is a framed algebra over \\spad{R.} The package provides a function to compute the integral closure of \\spad{R} in the quotient field of \\spad{F} as well as a function to compute a \"local integral basis\" at a specific prime.")) (|localIntegralBasis| (((|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|) (|:| |basisInv| (|Matrix| |#2|))) |#2|) "\\spad{integralBasis(p)} returns a record \\spad{[basis,basisDen,basisInv]} containing information regarding the local integral closure of \\spad{R} at the prime \\spad{p} in the quotient field of \\spad{F,} where \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the local integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}.")) (|integralBasis| (((|Record| (|:| |basis| (|Matrix| |#2|)) (|:| |basisDen| |#2|) (|:| |basisInv| (|Matrix| |#2|)))) "\\spad{integralBasis()} returns a record \\spad{[basis,basisDen,basisInv]} containing information regarding the integral closure of \\spad{R} in the quotient field of \\spad{F,} where \\spad{F} is a framed algebra with R-module basis \\spad{w1,w2,...,wn}. If \\spad{basis} is the matrix \\spad{(aij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then the \\spad{i}th element of the integral basis is \\spad{vi = (1/basisDen) * sum(aij * \\spad{wj,} \\spad{j} = 1..n)}, \\spadignore{i.e.} the \\spad{i}th row of \\spad{basis} contains the coordinates of the \\spad{i}th basis vector. Similarly, the \\spad{i}th row of the matrix \\spad{basisInv} contains the coordinates of \\spad{wi} with respect to the basis \\spad{v1,...,vn}: if \\spad{basisInv} is the matrix \\spad{(bij, \\spad{i} = 1..n, \\spad{j} = 1..n)}, then \\spad{wi = sum(bij * \\spad{vj,} \\spad{j} = 1..n)}."))) 
NIL 
NIL 
(|WeightedPolynomials| R |VarSet| E P |vl| |wl| |wtlevel|) 
((|constructor| (NIL "This domain represents truncated weighted polynomials over a general (not necessarily commutative) polynomial type. The variables must be specified, as must the weights. The representation is sparse in the sense that only non-zero terms are represented.")) (|changeWeightLevel| (((|Void|) (|NonNegativeInteger|)) "\\spad{changeWeightLevel(n)} changes the weight level to the new value given: \\spad{NB:} previously calculated terms are not affected")) (/ (((|Union| $ "failed") $ $) "\\spad{x/y} division (only works if minimum weight of divisor is zero, and if \\spad{R} is a Field)")) (|coerce| (($ |#4|) "\\spad{coerce(p)} coerces \\spad{p} into Weighted form, applying weights and ignoring terms") ((|#4| $) "convert back into a \"P\", ignoring weights"))) 
((|leftUnitary| |has| |#1| (|CommutativeRing|)) (|rightUnitary| |has| |#1| (|CommutativeRing|)) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|)))) 
(|WuWenTsunTriangularSet| R E V P) 
((|constructor| (NIL "A domain constructor of the category \\axiomType{GeneralTriangularSet}. The only requirement for a list of polynomials to be a member of such a domain is the following: no polynomial is constant and two distinct polynomials have distinct main variables. Such a triangular set may not be auto-reduced or consistent. The construct operation does not check the previous requirement. Triangular sets are stored as sorted lists w.r.t. the main variables of their members. Furthermore, this domain exports operations dealing with the characteristic set method of Wu Wen Tsun and some optimizations mainly proposed by Dong Ming Wang.")) (|characteristicSerie| (((|List| $) (|List| |#4|)) "\\axiom{characteristicSerie(ps)} returns the same as \\axiom{characteristicSerie(ps,initiallyReduced?,initiallyReduce)}.") (((|List| $) (|List| |#4|) (|Mapping| (|Boolean|) |#4| |#4|) (|Mapping| |#4| |#4| |#4|)) "\\axiom{characteristicSerie(ps,redOp?,redOp)} returns a list \\axiom{lts} of triangular sets such that the zero set of \\axiom{ps} is the union of the regular zero sets of the members of \\axiom{lts}. This is made by the Ritt and Wu Wen Tsun process applying the operation \\axiom{characteristicSet(ps,redOp?,redOp)} to compute characteristic sets in Wu Wen Tsun sense.")) (|characteristicSet| (((|Union| $ "failed") (|List| |#4|)) "\\axiom{characteristicSet(ps)} returns the same as \\axiom{characteristicSet(ps,initiallyReduced?,initiallyReduce)}.") (((|Union| $ "failed") (|List| |#4|) (|Mapping| (|Boolean|) |#4| |#4|) (|Mapping| |#4| |#4| |#4|)) "\\axiom{characteristicSet(ps,redOp?,redOp)} returns a non-contradictory characteristic set of \\axiom{ps} in Wu Wen Tsun sense w.r.t the reduction-test \\axiom{redOp?} (using \\axiom{redOp} to reduce polynomials w.r.t a \\axiom{redOp?} basic set), if no non-zero constant polynomial appear during those reductions, else \\axiom{\"failed\"} is returned. The operations \\axiom{redOp} and \\axiom{redOp?} must satisfy the following conditions: \\axiom{redOp?(redOp(p,q),q)} holds for every polynomials \\axiom{p,q} and there exists an integer \\axiom{e} and a polynomial \\axiom{f} such that we have \\axiom{init(q)^e*p = \\spad{f*q} + redOp(p,q)}.")) (|medialSet| (((|Union| $ "failed") (|List| |#4|)) "\\axiom{medial(ps)} returns the same as \\axiom{medialSet(ps,initiallyReduced?,initiallyReduce)}.") (((|Union| $ "failed") (|List| |#4|) (|Mapping| (|Boolean|) |#4| |#4|) (|Mapping| |#4| |#4| |#4|)) "\\axiom{medialSet(ps,redOp?,redOp)} returns \\axiom{bs} a basic set (in Wu Wen Tsun sense w.r.t the reduction-test \\axiom{redOp?}) of some set generating the same ideal as \\axiom{ps} (with rank not higher than any basic set of \\axiom{ps}), if no non-zero constant polynomials appear during the computatioms, else \\axiom{\"failed\"} is returned. In the former case, \\axiom{bs} has to be understood as a candidate for being a characteristic set of \\axiom{ps}. In the original algorithm, \\axiom{bs} is simply a basic set of \\axiom{ps}."))) 
((|shallowlyMutable| . T) (|finiteAggregate| . T)) 
((|HasCategory| |#4| (LIST (QUOTE |ConvertibleTo|) (QUOTE (|InputForm|)))) (|HasCategory| |#4| (QUOTE (|SetCategory|))) (AND (|HasCategory| |#4| (LIST (QUOTE |Evalable|) (|devaluate| |#4|))) (|HasCategory| |#4| (QUOTE (|SetCategory|)))) (|HasCategory| |#1| (QUOTE (|IntegralDomain|))) (|HasCategory| |#3| (QUOTE (|Finite|)))) 
(|XAlgebra| R) 
((|constructor| (NIL "This is the category of algebras over non-commutative rings. It is used by constructors of non-commutative algebras such as XPolynomialRing and XFreeAlgebra")) (|coerce| (($ |#1|) "\\spad{coerce(r)} equals \\spad{r*1}."))) 
((|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|XDistributedPolynomial| |vl| R) 
((|constructor| (NIL "This type supports distributed multivariate polynomials whose variables do not commute. The coefficient ring may be non-commutative too. However, coefficients and variables commute."))) 
((|unitsKnown| . T) (|noZeroDivisors| |has| |#2| (ATTRIBUTE |noZeroDivisors|)) (|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasAttribute| |#2| (QUOTE |noZeroDivisors|))) 
(|XExponentialPackage| R |VarSet| XPOLY) 
((|constructor| (NIL "This package provides computations of logarithms and exponentials for polynomials in non-commutative variables.")) (|Hausdorff| ((|#3| |#3| |#3| (|NonNegativeInteger|)) "\\axiom{Hausdorff(a,b,n)} returns log(exp(a)*exp(b)) truncated at order \\axiom{n}.")) (|log| ((|#3| |#3| (|NonNegativeInteger|)) "\\axiom{log(p, \\spad{n)}} returns the logarithm of \\axiom{p} truncated at order \\axiom{n}.")) (|exp| ((|#3| |#3| (|NonNegativeInteger|)) "\\axiom{exp(p, \\spad{n)}} returns the exponential of \\axiom{p} truncated at order \\axiom{n}."))) 
NIL 
NIL 
(|XFreeAlgebra| |vl| R) 
((|constructor| (NIL "This category specifies opeations for polynomials and formal series with non-commutative variables.")) (|varList| (((|List| |#1|) $) "\\spad{varList(x)} returns the list of variables which appear in \\spad{x}.")) (|map| (($ (|Mapping| |#2| |#2|) $) "\\spad{map(fn,x)} returns \\spad{Sum(fn(r_i) w_i)} if \\spad{x} writes \\spad{Sum(r_i w_i)}.")) (|sh| (($ $ (|NonNegativeInteger|)) "\\spad{sh(x,n)} returns the shuffle power of \\spad{x} to the \\spad{n}.") (($ $ $) "\\spad{sh(x,y)} returns the shuffle-product of \\spad{x} by \\spad{y}. This multiplication is associative and commutative.")) (|quasiRegular| (($ $) "\\spad{quasiRegular(x)} return \\spad{x} minus its constant term.")) (|quasiRegular?| (((|Boolean|) $) "\\spad{quasiRegular?(x)} return \\spad{true} if \\spad{constant(x)} is zero")) (|constant| ((|#2| $) "\\spad{constant(x)} returns the constant term of \\spad{x}.")) (|constant?| (((|Boolean|) $) "\\spad{constant?(x)} returns \\spad{true} if \\spad{x} is constant.")) (|coerce| (($ |#1|) "\\spad{coerce(v)} returns \\spad{v}.")) (|mirror| (($ $) "\\spad{mirror(x)} returns \\spad{Sum(r_i mirror(w_i))} if \\spad{x} writes \\spad{Sum(r_i w_i)}.")) (|monomial?| (((|Boolean|) $) "\\spad{monomial?(x)} returns \\spad{true} if \\spad{x} is a monomial")) (|monom| (($ (|OrderedFreeMonoid| |#1|) |#2|) "\\spad{monom(w,r)} returns the product of the word \\spad{w} by the coefficient \\spad{r}.")) (|rquo| (($ $ $) "\\spad{rquo(x,y)} returns the right simplification of \\spad{x} by \\spad{y}.") (($ $ (|OrderedFreeMonoid| |#1|)) "\\spad{rquo(x,w)} returns the right simplification of \\spad{x} by \\spad{w}.") (($ $ |#1|) "\\spad{rquo(x,v)} returns the right simplification of \\spad{x} by the variable \\spad{v}.")) (|lquo| (($ $ $) "\\spad{lquo(x,y)} returns the left simplification of \\spad{x} by \\spad{y}.") (($ $ (|OrderedFreeMonoid| |#1|)) "\\spad{lquo(x,w)} returns the left simplification of \\spad{x} by the word \\spad{w}.") (($ $ |#1|) "\\spad{lquo(x,v)} returns the left simplification of \\spad{x} by the variable \\spad{v}.")) (|coef| ((|#2| $ $) "\\spad{coef(x,y)} returns scalar product of \\spad{x} by \\spad{y}, the set of words being regarded as an orthogonal basis.") ((|#2| $ (|OrderedFreeMonoid| |#1|)) "\\spad{coef(x,w)} returns the coefficient of the word \\spad{w} in \\spad{x}.")) (|mindegTerm| (((|Record| (|:| |k| (|OrderedFreeMonoid| |#1|)) (|:| |c| |#2|)) $) "\\spad{mindegTerm(x)} returns the term whose word is \\spad{mindeg(x)}.")) (|mindeg| (((|OrderedFreeMonoid| |#1|) $) "\\spad{mindeg(x)} returns the little word which appears in \\spad{x}. Error if \\spad{x=0}.")) (* (($ $ |#2|) "\\spad{x * \\spad{r}} returns the product of \\spad{x} by \\spad{r}. Usefull if \\spad{R} is a non-commutative Ring.") (($ |#1| $) "\\spad{v * \\spad{x}} returns the product of a variable \\spad{x} by \\spad{x}."))) 
((|noZeroDivisors| |has| |#2| (ATTRIBUTE |noZeroDivisors|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|ExtensionField&| S F) 
((|constructor| (NIL "ExtensionField \\spad{F} is the category of fields which extend the field \\spad{F}")) (|Frobenius| (($ $ (|NonNegativeInteger|)) "\\spad{Frobenius(a,s)} returns \\spad{a**(q**s)} where \\spad{q} is the size()$F.") (($ $) "\\spad{Frobenius(a)} returns \\spad{a \\spad{**} \\spad{q}} where \\spad{q} is the \\spad{size()$F}.")) (|transcendenceDegree| (((|NonNegativeInteger|)) "\\spad{transcendenceDegree()} returns the transcendence degree of the field extension, 0 if the extension is algebraic.")) (|extensionDegree| (((|OnePointCompletion| (|PositiveInteger|))) "\\spad{extensionDegree()} returns the degree of the field extension if the extension is algebraic, and \\spad{infinity} if it is not.")) (|degree| (((|OnePointCompletion| (|PositiveInteger|)) $) "\\spad{degree(a)} returns the degree of minimal polynomial of an element \\spad{a} if \\spad{a} is algebraic with respect to the ground field \\spad{F,} and \\spad{infinity} otherwise.")) (|inGroundField?| (((|Boolean|) $) "\\spad{inGroundField?(a)} tests whether an element \\spad{a} is already in the ground field \\spad{F.}")) (|transcendent?| (((|Boolean|) $) "\\spad{transcendent?(a)} tests whether an element \\spad{a} is transcendent with respect to the ground field \\spad{F.}")) (|algebraic?| (((|Boolean|) $) "\\spad{algebraic?(a)} tests whether an element \\spad{a} is algebraic with respect to the ground field \\spad{F.}"))) 
NIL 
((|HasCategory| |#2| (QUOTE (|Finite|))) (|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|))) (|HasCategory| |#2| (QUOTE (|CharacteristicZero|)))) 
(|ExtensionField| F) 
((|constructor| (NIL "ExtensionField \\spad{F} is the category of fields which extend the field \\spad{F}")) (|Frobenius| (($ $ (|NonNegativeInteger|)) "\\spad{Frobenius(a,s)} returns \\spad{a**(q**s)} where \\spad{q} is the size()$F.") (($ $) "\\spad{Frobenius(a)} returns \\spad{a \\spad{**} \\spad{q}} where \\spad{q} is the \\spad{size()$F}.")) (|transcendenceDegree| (((|NonNegativeInteger|)) "\\spad{transcendenceDegree()} returns the transcendence degree of the field extension, 0 if the extension is algebraic.")) (|extensionDegree| (((|OnePointCompletion| (|PositiveInteger|))) "\\spad{extensionDegree()} returns the degree of the field extension if the extension is algebraic, and \\spad{infinity} if it is not.")) (|degree| (((|OnePointCompletion| (|PositiveInteger|)) $) "\\spad{degree(a)} returns the degree of minimal polynomial of an element \\spad{a} if \\spad{a} is algebraic with respect to the ground field \\spad{F,} and \\spad{infinity} otherwise.")) (|inGroundField?| (((|Boolean|) $) "\\spad{inGroundField?(a)} tests whether an element \\spad{a} is already in the ground field \\spad{F.}")) (|transcendent?| (((|Boolean|) $) "\\spad{transcendent?(a)} tests whether an element \\spad{a} is transcendent with respect to the ground field \\spad{F.}")) (|algebraic?| (((|Boolean|) $) "\\spad{algebraic?(a)} tests whether an element \\spad{a} is algebraic with respect to the ground field \\spad{F.}"))) 
((|canonicalsClosed| . T) (|canonicalUnitNormal| . T) (|noZeroDivisors| . T) ((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|XPBWPolynomial| |VarSet| R) 
((|constructor| (NIL "This domain constructor implements polynomials in non-commutative variables written in the Poincare-Birkhoff-Witt basis from the Lyndon basis. These polynomials can be used to compute Baker-Campbell-Hausdorff relations.")) (|log| (($ $ (|NonNegativeInteger|)) "\\axiom{log(p,n)} returns the logarithm of \\axiom{p} (truncated up to order \\axiom{n}).")) (|exp| (($ $ (|NonNegativeInteger|)) "\\axiom{exp(p,n)} returns the exponential of \\axiom{p} (truncated up to order \\axiom{n}).")) (|product| (($ $ $ (|NonNegativeInteger|)) "\\axiom{product(a,b,n)} returns \\axiom{a*b} (truncated up to order \\axiom{n}).")) (|LiePolyIfCan| (((|Union| (|LiePolynomial| |#1| |#2|) "failed") $) "\\axiom{LiePolyIfCan(p)} return \\axiom{p} if \\axiom{p} is a Lie polynomial.")) (|coerce| (((|XRecursivePolynomial| |#1| |#2|) $) "\\axiom{coerce(p)} returns \\axiom{p} as a recursive polynomial.") (((|XDistributedPolynomial| |#1| |#2|) $) "\\axiom{coerce(p)} returns \\axiom{p} as a distributed polynomial.") (($ (|LiePolynomial| |#1| |#2|)) "\\axiom{coerce(p)} returns \\axiom{p}."))) 
((|noZeroDivisors| |has| |#2| (ATTRIBUTE |noZeroDivisors|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasCategory| |#2| (LIST (QUOTE |Module|) (LIST (QUOTE |Fraction|) (QUOTE (|Integer|))))) (|HasAttribute| |#2| (QUOTE |noZeroDivisors|))) 
(|XPolynomialsCat| |vl| R) 
((|constructor| (NIL "The Category of polynomial rings with non-commutative variables. The coefficient ring may be non-commutative too. However coefficients commute with variables.")) (|trunc| (($ $ (|NonNegativeInteger|)) "\\spad{trunc(p,n)} returns the polynomial \\spad{p} truncated at order \\spad{n}.")) (|degree| (((|NonNegativeInteger|) $) "\\spad{degree(p)} returns the degree of \\spad{p}. \\indented{1}{Note that the degree of a word is its length.}")) (|maxdeg| (((|OrderedFreeMonoid| |#1|) $) "\\spad{maxdeg(p)} returns the greatest leading word in the support of \\spad{p}."))) 
((|noZeroDivisors| |has| |#2| (ATTRIBUTE |noZeroDivisors|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
NIL 
(|XPolynomial| R) 
((|constructor| (NIL "This type supports multivariate polynomials whose set of variables is \\spadtype{Symbol}. The representation is recursive. The coefficient ring may be non-commutative and the variables do not commute. However, coefficients and variables commute."))) 
((|noZeroDivisors| |has| |#1| (ATTRIBUTE |noZeroDivisors|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasAttribute| |#1| (QUOTE |noZeroDivisors|))) 
(|XPolynomialRing| R E) 
((|constructor| (NIL "This domain represents generalized polynomials with coefficients (from a not necessarily commutative ring), and words belonging to an arbitrary \\spadtype{OrderedMonoid}. This type is used, for instance, by the \\spadtype{XDistributedPolynomial} domain constructor where the Monoid is free.")) (|canonicalUnitNormal| ((|attribute|) "canonicalUnitNormal guarantees that the function unitCanonical returns the same representative for all associates of any particular element.")) (/ (($ $ |#1|) "\\spad{p/r} returns \\spad{p*(1/r)}.")) (|map| (($ (|Mapping| |#1| |#1|) $) "\\spad{map(fn,x)} returns \\spad{Sum(fn(r_i) w_i)} if \\spad{x} writes \\spad{Sum(r_i w_i)}.")) (|quasiRegular| (($ $) "\\spad{quasiRegular(x)} return \\spad{x} minus its constant term.")) (|quasiRegular?| (((|Boolean|) $) "\\spad{quasiRegular?(x)} return \\spad{true} if \\spad{constant(p)} is zero.")) (|constant| ((|#1| $) "\\spad{constant(p)} return the constant term of \\spad{p}.")) (|constant?| (((|Boolean|) $) "\\spad{constant?(p)} tests whether the polynomial \\spad{p} belongs to the coefficient ring.")) (|coef| ((|#1| $ |#2|) "\\spad{coef(p,e)} extracts the coefficient of the monomial \\spad{e}. Returns zero if \\spad{e} is not present.")) (|reductum| (($ $) "\\spad{reductum(p)} returns \\spad{p} minus its leading term. An error is produced if \\spad{p} is zero.")) (|mindeg| ((|#2| $) "\\spad{mindeg(p)} returns the smallest word occurring in the polynomial \\spad{p} with a non-zero coefficient. An error is produced if \\spad{p} is zero.")) (|maxdeg| ((|#2| $) "\\spad{maxdeg(p)} returns the greatest word occurring in the polynomial \\spad{p} with a non-zero coefficient. An error is produced if \\spad{p} is zero.")) (|coerce| (($ |#2|) "\\spad{coerce(e)} returns \\spad{1*e}")) (|#| (((|NonNegativeInteger|) $) "\\spad{# \\spad{p}} returns the number of terms in \\spad{p}.")) (* (($ $ |#1|) "\\spad{p*r} returns the product of \\spad{p} by \\spad{r}."))) 
((|unitsKnown| . T) (|canonicalUnitNormal| |has| |#1| (ATTRIBUTE |canonicalUnitNormal|)) (|noZeroDivisors| |has| |#1| (ATTRIBUTE |noZeroDivisors|)) (|leftUnitary| . T) (|rightUnitary| . T)) 
((|HasCategory| |#1| (QUOTE (|CommutativeRing|))) (|HasCategory| |#1| (QUOTE (|Field|))) (|HasAttribute| |#1| (QUOTE |unitsKnown|)) (|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|)) (|HasAttribute| |#1| (QUOTE |noZeroDivisors|))) 
(|XRecursivePolynomial| |VarSet| R) 
((|constructor| (NIL "This type supports multivariate polynomials whose variables do not commute. The representation is recursive. The coefficient ring may be non-commutative. Coefficients and variables commute.")) (|RemainderList| (((|List| (|Record| (|:| |k| |#1|) (|:| |c| $))) $) "\\spad{RemainderList(p)} returns the regular part of \\spad{p} as a list of terms.")) (|unexpand| (($ (|XDistributedPolynomial| |#1| |#2|)) "\\spad{unexpand(p)} returns \\spad{p} in recursive form.")) (|expand| (((|XDistributedPolynomial| |#1| |#2|) $) "\\spad{expand(p)} returns \\spad{p} in distributed form."))) 
((|noZeroDivisors| |has| |#2| (ATTRIBUTE |noZeroDivisors|)) (|leftUnitary| . T) (|rightUnitary| . T) (|unitsKnown| . T)) 
((|HasCategory| |#2| (QUOTE (|CommutativeRing|))) (|HasAttribute| |#2| (QUOTE |noZeroDivisors|))) 
(|ParadoxicalCombinatorsForStreams| A) 
((|constructor| (NIL "This package implements fixed-point computations on streams.")) (Y (((|List| (|Stream| |#1|)) (|Mapping| (|List| (|Stream| |#1|)) (|List| (|Stream| |#1|))) (|Integer|)) "\\spad{Y(g,n)} computes a fixed point of the function \\spad{g,} where \\spad{g} takes a list of \\spad{n} streams and returns a list of \\spad{n} streams.") (((|Stream| |#1|) (|Mapping| (|Stream| |#1|) (|Stream| |#1|))) "\\spad{Y(f)} computes a fixed point of the function \\spad{f.}"))) 
NIL 
NIL 
(|ZeroDimensionalSolvePackage| R |ls| |ls2|) 
((|constructor| (NIL "A package for computing symbolically the complex and real roots of zero-dimensional algebraic systems over the integer or rational numbers. Complex roots are given by means of univariate representations of irreducible regular chains. Real roots are given by means of tuples of coordinates lying in the \\spadtype{RealClosure} of the coefficient ring. This constructor takes three arguments. The first one \\spad{R} is the coefficient ring. The second one \\spad{ls} is the list of variables involved in the systems to solve. The third one must be \\spad{concat(ls,s)} where \\spad{s} is an additional symbol used for the univariate representations. WARNING. The third argument is not checked. All operations are based on triangular decompositions. The default is to compute these decompositions directly from the input system by using the \\spadtype{RegularChain} domain constructor. The lexTriangular algorithm can also be used for computing these decompositions (see \\spadtype{LexTriangularPackage} package constructor). For that purpose, the operations univariateSolve, realSolve and positiveSolve admit an optional argument.")) (|convert| (((|List| (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#3|))) (|SquareFreeRegularTriangularSet| |#1| (|IndexedExponents| (|OrderedVariableList| |#3|)) (|OrderedVariableList| |#3|) (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#3|)))) "\\spad{convert(st)} returns the members of \\spad{st}.") (((|SparseUnivariatePolynomial| (|RealClosure| (|Fraction| |#1|))) (|SparseUnivariatePolynomial| |#1|)) "\\spad{convert(u)} converts \\spad{u}.") (((|Polynomial| (|RealClosure| (|Fraction| |#1|))) (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#3|))) "\\spad{convert(q)} converts \\spad{q}.") (((|Polynomial| (|RealClosure| (|Fraction| |#1|))) (|Polynomial| |#1|)) "\\spad{convert(p)} converts \\spad{p}.") (((|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#3|)) (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#2|))) "\\spad{convert(q)} converts \\spad{q}.")) (|squareFree| (((|List| (|SquareFreeRegularTriangularSet| |#1| (|IndexedExponents| (|OrderedVariableList| |#3|)) (|OrderedVariableList| |#3|) (|NewSparseMultivariatePolynomial| |#1| (|OrderedVariableList| |#3|)))) (|RegularChain| |#1| |#2|)) "\\spad{squareFree(ts)} returns the square-free factorization of \\spad{ts}. Moreover, each factor is a Lazard triangular set and the decomposition is a Kalkbrener split of \\spad{ts}, which is enough here for the matter of solving zero-dimensional algebraic systems. WARNING. \\spad{ts} is not checked to be zero-dimensional.")) (|positiveSolve| (((|List| (|List| (|RealClosure| (|Fraction| |#1|)))) (|List| (|Polynomial| |#1|))) "\\spad{positiveSolve(lp)} returns the same as \\spad{positiveSolve(lp,false,false)}.") (((|List| (|List| (|RealClosure| (|Fraction| |#1|)))) (|List| (|Polynomial| |#1|)) (|Boolean|)) "\\spad{positiveSolve(lp)} returns the same as \\spad{positiveSolve(lp,info?,false)}.") (((|List| (|List| (|RealClosure| (|Fraction| |#1|)))) (|List| (|Polynomial| |#1|)) (|Boolean|) (|Boolean|)) "\\spad{positiveSolve(lp,info?,lextri?)} returns the set of the points in the variety associated with \\spad{lp} whose coordinates are (real) strictly positive. Moreover, if \\spad{info?} is \\spad{true} then some information is displayed during decomposition into regular chains. If \\spad{lextri?} is \\spad{true} then the lexTriangular algorithm is called from the \\spadtype{LexTriangularPackage} constructor (see zeroSetSplit from LexTriangularPackage(lp,false)). Otherwise, the triangular decomposition is computed directly from the input system by using the zeroSetSplit from \\spadtype{RegularChain}. WARNING. For each set of coordinates given by \\spad{positiveSolve(lp,info?,lextri?)} the ordering of the indeterminates is reversed w.r.t. \\spad{ls}.") (((|List| (|List| (|RealClosure| (|Fraction| |#1|)))) (|RegularChain| |#1| |#2|)) "\\spad{positiveSolve(ts)} returns the points of the regular set of \\spad{ts} with (real) strictly positive coordinates.")) (|realSolve| (((|List| (|List| (|RealClosure| (|Fraction| |#1|)))) (|List| (|Polynomial| |#1|))) "\\spad{realSolve(lp)} returns the same as \\spad{realSolve(ts,false,false,false)}") (((|List| (|List| (|RealClosure| (|Fraction| |#1|)))) (|List| (|Polynomial| |#1|)) (|Boolean|)) "\\spad{realSolve(ts,info?)} returns the same as \\spad{realSolve(ts,info?,false,false)}.") (((|List| (|List| (|RealClosure| (|Fraction| |#1|)))) (|List| (|Polynomial| |#1|)) (|Boolean|) (|Boolean|)) "\\spad{realSolve(ts,info?,check?)} returns the same as \\spad{realSolve(ts,info?,check?,false)}.") (((|List| (|List| (|RealClosure| (|Fraction| |#1|)))) (|List| (|Polynomial| |#1|)) (|Boolean|) (|Boolean|) (|Boolean|)) "\\spad{realSolve(ts,info?,check?,lextri?)} returns the set of the points in the variety associated with \\spad{lp} whose coordinates are all real. Moreover, if \\spad{info?} is \\spad{true} then some information is displayed during decomposition into regular chains. If \\spad{check?} is \\spad{true} then the result is checked. If \\spad{lextri?} is \\spad{true} then the lexTriangular algorithm is called from the \\spadtype{LexTriangularPackage} constructor (see zeroSetSplit from LexTriangularPackage(lp,false)). Otherwise, the triangular decomposition is computed directly from the input system by using the zeroSetSplit from \\spadtype{RegularChain}. WARNING. For each set of coordinates given by \\spad{realSolve(ts,info?,check?,lextri?)} the ordering of the indeterminates is reversed w.r.t. \\spad{ls}.") (((|List| (|List| (|RealClosure| (|Fraction| |#1|)))) (|RegularChain| |#1| |#2|)) "\\spad{realSolve(ts)} returns the set of the points in the regular zero set of \\spad{ts} whose coordinates are all real. WARNING. For each set of coordinates given by \\spad{realSolve(ts)} the ordering of the indeterminates is reversed w.r.t. \\spad{ls}.")) (|univariateSolve| (((|List| (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|)) (|:| |coordinates| (|List| (|Polynomial| |#1|))))) (|List| (|Polynomial| |#1|))) "\\spad{univariateSolve(lp)} returns the same as \\spad{univariateSolve(lp,false,false,false)}.") (((|List| (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|)) (|:| |coordinates| (|List| (|Polynomial| |#1|))))) (|List| (|Polynomial| |#1|)) (|Boolean|)) "\\spad{univariateSolve(lp,info?)} returns the same as \\spad{univariateSolve(lp,info?,false,false)}.") (((|List| (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|)) (|:| |coordinates| (|List| (|Polynomial| |#1|))))) (|List| (|Polynomial| |#1|)) (|Boolean|) (|Boolean|)) "\\spad{univariateSolve(lp,info?,check?)} returns the same as \\spad{univariateSolve(lp,info?,check?,false)}.") (((|List| (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|)) (|:| |coordinates| (|List| (|Polynomial| |#1|))))) (|List| (|Polynomial| |#1|)) (|Boolean|) (|Boolean|) (|Boolean|)) "\\spad{univariateSolve(lp,info?,check?,lextri?)} returns a univariate representation of the variety associated with \\spad{lp}. Moreover, if \\spad{info?} is \\spad{true} then some information is displayed during the decomposition into regular chains. If \\spad{check?} is \\spad{true} then the result is checked. See rur from RationalUnivariateRepresentationPackage(lp,true). If \\spad{lextri?} is \\spad{true} then the lexTriangular algorithm is called from the \\spadtype{LexTriangularPackage} constructor (see zeroSetSplit from LexTriangularPackage(lp,false)). Otherwise, the triangular decomposition is computed directly from the input system by using the zeroSetSplit from RegularChain") (((|List| (|Record| (|:| |complexRoots| (|SparseUnivariatePolynomial| |#1|)) (|:| |coordinates| (|List| (|Polynomial| |#1|))))) (|RegularChain| |#1| |#2|)) "\\spad{univariateSolve(ts)} returns a univariate representation of \\spad{ts}. See rur from RationalUnivariateRepresentationPackage(lp,true).")) (|triangSolve| (((|List| (|RegularChain| |#1| |#2|)) (|List| (|Polynomial| |#1|))) "\\spad{triangSolve(lp)} returns the same as \\spad{triangSolve(lp,false,false)}") (((|List| (|RegularChain| |#1| |#2|)) (|List| (|Polynomial| |#1|)) (|Boolean|)) "\\spad{triangSolve(lp,info?)} returns the same as \\spad{triangSolve(lp,false)}") (((|List| (|RegularChain| |#1| |#2|)) (|List| (|Polynomial| |#1|)) (|Boolean|) (|Boolean|)) "\\spad{triangSolve(lp,info?,lextri?)} decomposes the variety associated with \\axiom{lp} into regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \\axiom{lp} needs to generate a zero-dimensional ideal. If \\axiom{lp} is not zero-dimensional then the result is only a decomposition of its zero-set in the sense of the closure (w.r.t. Zarisky topology). Moreover, if \\spad{info?} is \\spad{true} then some information is displayed during the computations. See zeroSetSplit from RegularTriangularSetCategory(lp,true,info?). If \\spad{lextri?} is \\spad{true} then the lexTriangular algorithm is called from the \\spadtype{LexTriangularPackage} constructor (see zeroSetSplit from LexTriangularPackage(lp,false)). Otherwise, the triangular decomposition is computed directly from the input system by using the zeroSetSplit from RegularChain"))) 
NIL 
NIL 
(|IntegerLinearDependence| R) 
((|constructor| (NIL "Test for linear dependence over the integers.")) (|solveLinearlyOverQ| (((|Union| (|Vector| (|Fraction| (|Integer|))) "failed") (|Vector| |#1|) |#1|) "\\spad{solveLinearlyOverQ([v1,...,vn], u)} returns \\spad{[c1,...,cn]} such that \\spad{c1*v1 + \\spad{...} + cn*vn = u}, \"failed\" if no such rational numbers ci's exist.")) (|linearDependenceOverZ| (((|Union| (|Vector| (|Integer|)) "failed") (|Vector| |#1|)) "\\spad{linearlyDependenceOverZ([v1,...,vn])} returns \\spad{[c1,...,cn]} if \\spad{c1*v1 + \\spad{...} + cn*vn = 0} and not all the ci's are 0, \"failed\" if the vi's are linearly independent over the integers.")) (|linearlyDependentOverZ?| (((|Boolean|) (|Vector| |#1|)) "\\spad{linearlyDependentOverZ?([v1,...,vn])} returns \\spad{true} if the vi's are linearly dependent over the integers, \\spad{false} otherwise."))) 
NIL 
NIL 
(|IntegerMod| |p|) 
((|constructor| (NIL "IntegerMod(n) creates the ring of integers reduced modulo the integer \\spad{n.}"))) 
(((|commutative| "*") . T) (|rightUnitary| . T) (|leftUnitary| . T) (|unitsKnown| . T)) 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
NIL 
((|Category| NIL 2503885 2503890 2503895 2503900) (|Union| NIL 2503865 2503870 2503875 2503880) (|Record| NIL 2503845 2503850 2503855 2503860) (|Mapping| NIL 2503825 2503830 2503835 2503840) (|Enumeration| NIL 2503805 2503810 2503815 2503820) (|IntegerMod| "bookvol10.3.pamphlet" 2503583 2503603 2503711 2503800) (|IntegerLinearDependence| "bookvol10.4.pamphlet" 2502683 2502714 2503573 2503578) (|ZeroDimensionalSolvePackage| "bookvol10.4.pamphlet" 2493275 2493321 2502673 2502678) (|ParadoxicalCombinatorsForStreams| "bookvol10.4.pamphlet" 2492743 2492783 2493265 2493270) (|XRecursivePolynomial| "bookvol10.3.pamphlet" 2491884 2491921 2492522 2492644) (|XPolynomialRing| "bookvol10.3.pamphlet" 2489463 2489488 2491460 2491651) (|XPolynomial| "bookvol10.3.pamphlet" 2488950 2488969 2489242 2489364) (|XPolynomialsCat| "bookvol10.2.pamphlet" 2488203 2488231 2488823 2488945) (|XPBWPolynomial| "bookvol10.3.pamphlet" 2486765 2486796 2487891 2488013) (|ExtensionField| "bookvol10.2.pamphlet" 2485150 2485172 2486595 2486760) (|ExtensionField&| NIL 2483547 2483572 2484995 2485000) (|XFreeAlgebra| "bookvol10.2.pamphlet" 2480520 2480545 2483420 2483542) (|XExponentialPackage| "bookvol10.4.pamphlet" 2479903 2479945 2480510 2480515) (|XDistributedPolynomial| "bookvol10.3.pamphlet" 2479438 2479473 2479682 2479804) (|XAlgebra| "bookvol10.2.pamphlet" 2479108 2479124 2479370 2479433) (|WuWenTsunTriangularSet| "bookvol10.3.pamphlet" 2475676 2475712 2478729 2478781) (|WeightedPolynomials| "bookvol10.3.pamphlet" 2474624 2474684 2475468 2475585) (|WildFunctionFieldIntegralBasis| "bookvol10.4.pamphlet" 2472176 2472221 2474614 2474619) (|WeierstrassPreparation| "bookvol10.4.pamphlet" 2470421 2470451 2472166 2472171) (|VectorSpace| "bookvol10.2.pamphlet" 2470069 2470088 2470372 2470416) (|VectorSpace&| NIL 2469753 2469775 2470059 2470064) (|Void| "bookvol10.3.pamphlet" 2469346 2469356 2469743 2469748) (|ViewportPackage| "bookvol10.4.pamphlet" 2467050 2467071 2469336 2469341) (|ViewDefaultsPackage| "bookvol10.4.pamphlet" 2462294 2462319 2467040 2467045) (|ThreeDimensionalViewport| "bookvol10.3.pamphlet" 2446489 2446519 2462284 2462289) (|TwoDimensionalViewport| "bookvol10.3.pamphlet" 2434661 2434689 2446479 2446484) (|Vector| "bookvol10.3.pamphlet" 2433375 2433389 2433629 2433681) (|VectorFunctions2| "bookvol10.4.pamphlet" 2432036 2432062 2433365 2433370) (|VectorCategory| "bookvol10.2.pamphlet" 2430000 2430022 2431967 2432031) (|VectorCategory&| NIL 2427752 2427777 2429722 2429727) (|Variable| "bookvol10.3.pamphlet" 2427527 2427547 2427742 2427747) (|UnivariateTaylorSeriesCZero| "bookvol10.3.pamphlet" 2422256 2422302 2425571 2425736) (|TaylorSolve| "bookvol10.4.pamphlet" 2422155 2422187 2422246 2422251) (|UTSodetools| "bookvol10.4.pamphlet" 2421433 2421461 2422099 2422104) (|UnivariateTaylorSeriesODESolver| "bookvol10.4.pamphlet" 2419595 2419643 2421423 2421428) (|UnivariateTaylorSeries| "bookvol10.3.pamphlet" 2413952 2413999 2417639 2417804) (|UnivariateTaylorSeriesCategory| "bookvol10.2.pamphlet" 2411174 2411217 2413782 2413947) (|UnivariateTaylorSeriesCategory&| NIL 2407981 2408027 2410592 2410597) (|UnivariateTaylorSeriesFunctions2| "bookvol10.4.pamphlet" 2407577 2407641 2407971 2407976) (|UnaryRecursiveAggregate| "bookvol10.2.pamphlet" 2402841 2402872 2407557 2407572) (|UnaryRecursiveAggregate&| NIL 2398065 2398099 2402784 2402789) (|UnivariatePuiseuxSeriesWithExponentialSingularity| "bookvol10.3.pamphlet" 2395200 2395272 2396660 2396901) (|UnivariatePuiseuxSeries| "bookvol10.3.pamphlet" 2392261 2392309 2392862 2393114) (|UnivariatePuiseuxSeriesConstructor| "bookvol10.3.pamphlet" 2389521 2389572 2389923 2390175) (|UnivariatePuiseuxSeriesConstructorCategory| "bookvol10.2.pamphlet" 2387849 2387908 2389264 2389516) (|UnivariatePuiseuxSeriesConstructorCategory&| NIL 2386421 2386483 2387839 2387844) (|UnivariatePuiseuxSeriesCategory| "bookvol10.2.pamphlet" 2384881 2384925 2386164 2386416) (|UnivariatePuiseuxSeriesFunctions2| "bookvol10.4.pamphlet" 2384394 2384477 2384871 2384876) (|UnivariatePolynomialSquareFree| "bookvol10.4.pamphlet" 2382795 2382836 2384384 2384389) (|UnivariatePowerSeriesCategory| "bookvol10.2.pamphlet" 2380271 2380321 2382625 2382790) (|UnivariatePowerSeriesCategory&| NIL 2377484 2377537 2379841 2379846) (|UnivariatePolynomialCategory| "bookvol10.2.pamphlet" 2371723 2371759 2377202 2377479) (|UnivariatePolynomialCategory&| NIL 2365917 2365956 2371399 2371404) (|UnivariatePolynomialCategoryFunctions2| "bookvol10.4.pamphlet" 2365347 2365401 2365907 2365912) (|UnivariatePolynomial| "bookvol10.3.pamphlet" 2361228 2361260 2361836 2362113) (|UnivariatePolynomialMultiplicationPackage| "bookvol10.4.pamphlet" 2360124 2360175 2361218 2361223) (|UnivariatePolynomialDivisionPackage| "bookvol10.4.pamphlet" 2359657 2359703 2360114 2360119) (|UnivariatePolynomialDecompositionPackage| "bookvol10.4.pamphlet" 2357861 2357912 2359647 2359652) (|UnivariatePolynomialCommonDenominator| "bookvol10.4.pamphlet" 2357028 2357078 2357851 2357856) (|UnivariatePolynomialFunctions2| "bookvol10.4.pamphlet" 2356403 2356451 2357018 2357023) (|UniversalSegment| "bookvol10.3.pamphlet" 2355726 2355750 2356305 2356310) (|UniversalSegmentFunctions2| "bookvol10.4.pamphlet" 2355201 2355237 2355673 2355678) (|UnivariateFactorize| "bookvol10.4.pamphlet" 2354308 2354336 2355191 2355196) (|UnivariateLaurentSeries| "bookvol10.3.pamphlet" 2342131 2342179 2343124 2343834) (|UnivariateLaurentSeriesConstructor| "bookvol10.3.pamphlet" 2334869 2334920 2335268 2335520) (|UnivariateLaurentSeriesConstructorCategory| "bookvol10.2.pamphlet" 2332317 2332376 2334583 2334864) (|UnivariateLaurentSeriesConstructorCategory&| NIL 2330001 2330063 2332270 2332275) (|UnivariateLaurentSeriesCategory| "bookvol10.2.pamphlet" 2328080 2328124 2329744 2329996) (|UnivariateLaurentSeriesFunctions2| "bookvol10.4.pamphlet" 2327594 2327677 2328070 2328075) (|UnivariateFormalPowerSeries| "bookvol10.3.pamphlet" 2325540 2325580 2325638 2325803) (|UnivariateFormalPowerSeriesFunctions| "bookvol10.4.pamphlet" 2325422 2325471 2325530 2325535) (|UniqueFactorizationDomain| "bookvol10.2.pamphlet" 2324426 2324457 2325305 2325417) (|UniqueFactorizationDomain&| NIL 2323534 2323568 2324416 2324421) (|UserDefinedVariableOrdering| "bookvol10.4.pamphlet" 2322321 2322354 2323524 2323529) (|UserDefinedPartialOrdering| "bookvol10.4.pamphlet" 2319816 2319850 2322269 2322274) (|U8Vector| "bookvol10.3.pamphlet" 2318861 2318875 2319069 2319121) (|U8Matrix| "bookvol10.3.pamphlet" 2317960 2317974 2318352 2318404) (|U32Vector| "bookvol10.3.pamphlet" 2317003 2317018 2317213 2317265) (|U32Matrix| "bookvol10.3.pamphlet" 2316099 2316114 2316494 2316546) (|U16Vector| "bookvol10.3.pamphlet" 2315142 2315157 2315352 2315404) (|U16Matrix| "bookvol10.3.pamphlet" 2314238 2314253 2314633 2314685) (|Type| "bookvol10.2.pamphlet" 2314159 2314169 2314218 2314233) (|TwoFactorize| "bookvol10.4.pamphlet" 2312814 2312834 2314149 2314154) (|Tuple| "bookvol10.3.pamphlet" 2311813 2311826 2312761 2312766) (|TubePlotTools| "bookvol10.4.pamphlet" 2308697 2308716 2311803 2311808) (|TubePlot| "bookvol10.3.pamphlet" 2307382 2307404 2308687 2308692) (|TaylorSeries| "bookvol10.3.pamphlet" 2305794 2305819 2306777 2306942) (|TriangularSetCategory| "bookvol10.2.pamphlet" 2295307 2295342 2305725 2305789) (|TriangularSetCategory&| NIL 2284838 2284876 2295259 2295264) (|TranscendentalManipulations| "bookvol10.4.pamphlet" 2279214 2279251 2284484 2284489) (|TriangularMatrixOperations| "bookvol10.4.pamphlet" 2278162 2278210 2279204 2279209) (|TrigonometricManipulations| "bookvol10.4.pamphlet" 2276640 2276676 2278152 2278157) (|TrigonometricFunctionCategory| "bookvol10.2.pamphlet" 2276126 2276161 2276630 2276635) (|TrigonometricFunctionCategory&| NIL 2275609 2275647 2276116 2276121) (|Tree| "bookvol10.3.pamphlet" 2273774 2273786 2275392 2275444) (|TranscendentalFunctionCategory| "bookvol10.2.pamphlet" 2273594 2273630 2273764 2273769) (|TranscendentalFunctionCategory&| NIL 2273411 2273450 2273584 2273589) (|TopLevelThreeSpace| "bookvol10.4.pamphlet" 2273074 2273098 2273401 2273406) (|ToolsForSign| "bookvol10.4.pamphlet" 2272728 2272748 2273064 2273069) (|TextFile| "bookvol10.3.pamphlet" 2271302 2271316 2272718 2272723) (|TexFormat| "bookvol10.3.pamphlet" 2268433 2268448 2271292 2271297) (|TexFormat1| "bookvol10.4.pamphlet" 2267982 2268000 2268423 2268428) (|TemplateUtilities| "bookvol10.4.pamphlet" 2267529 2267552 2267972 2267977) (|TabulatedComputationPackage| "bookvol10.4.pamphlet" 2265696 2265743 2267519 2267524) (|TableAggregate| "bookvol10.2.pamphlet" 2264694 2264728 2265651 2265691) (|TableAggregate&| NIL 2263724 2263761 2264684 2264689) (|TangentExpansions| "bookvol10.4.pamphlet" 2263086 2263111 2263714 2263719) (|Table| "bookvol10.3.pamphlet" 2261901 2261926 2262173 2262225) (|Tableau| "bookvol10.3.pamphlet" 2261387 2261402 2261891 2261896) (|TableauxBumpers| "bookvol10.4.pamphlet" 2258293 2258316 2261377 2261382) (|SystemSolvePackage| "bookvol10.4.pamphlet" 2254909 2254935 2258283 2258288) (|SymbolTable| "bookvol10.3.pamphlet" 2252998 2253015 2254899 2254904) (|TheSymbolTable| "bookvol10.3.pamphlet" 2249052 2249072 2252988 2252993) (|SymmetricPolynomial| "bookvol10.3.pamphlet" 2247698 2247725 2247796 2248030) (|SymmetricFunctions| "bookvol10.4.pamphlet" 2247104 2247130 2247688 2247693) (|Symbol| "bookvol10.3.pamphlet" 2244563 2244575 2247094 2247099) (|Switch| "bookvol10.3.pamphlet" 2241306 2241318 2244553 2244558) (|SparseUnivariateTaylorSeries| "bookvol10.3.pamphlet" 2237889 2237942 2239350 2239515) (|SparseUnivariatePuiseuxSeries| "bookvol10.3.pamphlet" 2234527 2234581 2235551 2235803) (|SparseUnivariatePolynomial| "bookvol10.3.pamphlet" 2230138 2230172 2231016 2231293) (|SupFractionFactorizer| "bookvol10.4.pamphlet" 2229240 2229276 2230128 2230133) (|SparseUnivariatePolynomialExpressions| "bookvol10.3.pamphlet" 2225562 2225607 2225665 2225942) (|SparseUnivariatePolynomialFunctions2| "bookvol10.4.pamphlet" 2224923 2224969 2225552 2225557) (|RationalFunctionSum| "bookvol10.4.pamphlet" 2223509 2223536 2224913 2224918) (|FunctionSpaceSum| "bookvol10.4.pamphlet" 2223178 2223204 2223499 2223504) (|SparseUnivariateLaurentSeries| "bookvol10.3.pamphlet" 2210610 2210664 2211622 2212356) (|SuchThat| "bookvol10.3.pamphlet" 2210287 2210307 2210600 2210605) (|SubSpace| "bookvol10.3.pamphlet" 2202637 2202657 2210277 2210282) (|SubResultantPackage| "bookvol10.4.pamphlet" 2201780 2201810 2202580 2202585) (|StreamTranscendentalFunctions| "bookvol10.4.pamphlet" 2197855 2197897 2201770 2201775) (|StreamTranscendentalFunctionsNonCommutative| "bookvol10.4.pamphlet" 2194285 2194341 2197845 2197850) (|StreamTaylorSeriesOperations| "bookvol10.4.pamphlet" 2186812 2186848 2194146 2194151) (|StringTable| "bookvol10.3.pamphlet" 2185706 2185731 2185863 2185915) (|String| "bookvol10.3.pamphlet" 2184891 2184903 2184992 2185044) (|StringCategory| "bookvol10.2.pamphlet" 2184631 2184651 2184822 2184886) (|Stream| "bookvol10.3.pamphlet" 2180150 2180164 2184313 2184341) (|StreamFunctions3| "bookvol10.4.pamphlet" 2179478 2179506 2180140 2180145) (|StreamFunctions2| "bookvol10.4.pamphlet" 2178038 2178064 2179468 2179473) (|StreamFunctions1| "bookvol10.4.pamphlet" 2177533 2177557 2178028 2178033) (|StreamTensor| "bookvol10.4.pamphlet" 2177209 2177229 2177523 2177528) (|StreamInfiniteProduct| "bookvol10.4.pamphlet" 2176127 2176161 2177199 2177204) (|StepThrough| "bookvol10.2.pamphlet" 2175345 2175362 2176117 2176122) (|SparseTable| "bookvol10.3.pamphlet" 2174283 2174319 2174456 2174484) (|StreamAggregate| "bookvol10.2.pamphlet" 2173370 2173393 2174263 2174278) (|StreamAggregate&| NIL 2172464 2172490 2173360 2173365) (|Stack| "bookvol10.3.pamphlet" 2168452 2168465 2172247 2172299) (|SquareFreeRegularTriangularSet| "bookvol10.3.pamphlet" 2166591 2166635 2168073 2168125) (|SquareFreeRegularSetDecompositionPackage| "bookvol10.4.pamphlet" 2165320 2165377 2166581 2166586) (|StringAggregate| "bookvol10.2.pamphlet" 2160620 2160641 2165251 2165315) (|StringAggregate&| NIL 2155976 2156000 2160610 2160615) (|SquareMatrix| "bookvol10.3.pamphlet" 2153240 2153267 2154155 2154297) (|SplittingTree| "bookvol10.3.pamphlet" 2148650 2148673 2152904 2152956) (|SplittingNode| "bookvol10.3.pamphlet" 2145688 2145711 2148640 2148645) (|SpecialFunctionCategory| "bookvol10.2.pamphlet" 2144479 2144508 2145678 2145683) (|SpecialOutputPackage| "bookvol10.4.pamphlet" 2143031 2143057 2144469 2144474) (|ThreeSpaceCategory| "bookvol10.2.pamphlet" 2127406 2127432 2143021 2143026) (|ThreeSpace| "bookvol10.3.pamphlet" 2127181 2127199 2127396 2127401) (|SortPackage| "bookvol10.4.pamphlet" 2126714 2126735 2127129 2127134) (|TransSolvePackage| "bookvol10.4.pamphlet" 2124295 2124320 2126704 2126709) (|TransSolvePackageService| "bookvol10.4.pamphlet" 2122863 2122895 2124285 2124290) (|RadicalSolvePackage| "bookvol10.4.pamphlet" 2117335 2117362 2122853 2122858) (|PolynomialSolveByFormulas| "bookvol10.4.pamphlet" 2115781 2115817 2117325 2117330) (|SquareFreeNormalizedTriangularSetCategory| "bookvol10.2.pamphlet" 2115489 2115544 2115712 2115776) (|SparseMultivariateTaylorSeries| "bookvol10.3.pamphlet" 2113446 2113499 2114884 2115049) (|SparseMultivariatePolynomial| "bookvol10.3.pamphlet" 2109978 2110023 2110376 2110610) (|SmithNormalForm| "bookvol10.4.pamphlet" 2108803 2108840 2109968 2109973) (|SquareMatrixCategory| "bookvol10.2.pamphlet" 2106858 2106905 2108699 2108798) (|SquareMatrixCategory&| NIL 2104868 2104918 2106712 2106717) (|StackAggregate| "bookvol10.2.pamphlet" 2103434 2103456 2104799 2104863) (|SingleInteger| "bookvol10.3.pamphlet" 2101682 2101701 2103195 2103429) (|SimplifyAlgebraicNumberConvertPackage| "bookvol10.4.pamphlet" 2101391 2101434 2101672 2101677) (|RationalFunctionSign| "bookvol10.4.pamphlet" 2100464 2100492 2101381 2101386) (|ElementaryFunctionSign| "bookvol10.4.pamphlet" 2099708 2099740 2100454 2100459) (|SturmHabichtPackage| "bookvol10.4.pamphlet" 2097649 2097680 2099657 2099662) (|SplitHomogeneousDirectProduct| "bookvol10.3.pamphlet" 2087285 2087338 2087813 2088017) (|SemiGroup| "bookvol10.2.pamphlet" 2086591 2086606 2087275 2087280) (|SemiGroup&| NIL 2085894 2085912 2086581 2086586) (|SymmetricGroupCombinatoricFunctions| "bookvol10.4.pamphlet" 2079374 2079415 2085884 2085889) (|SquareFreeRegularTriangularSetCategory| "bookvol10.2.pamphlet" 2078877 2078929 2079305 2079369) (|SquareFreeRegularTriangularSetGcdPackage| "bookvol10.4.pamphlet" 2078539 2078596 2078867 2078872) (|SquareFreeQuasiComponentPackage| "bookvol10.4.pamphlet" 2074428 2074476 2078529 2078534) (|SimpleFortranProgram| "bookvol10.3.pamphlet" 2073872 2073903 2074418 2074423) (|SExpressionOf| "bookvol10.3.pamphlet" 2073705 2073755 2073862 2073867) (|SExpression| "bookvol10.3.pamphlet" 2073589 2073606 2073695 2073700) (|SExpressionCategory| "bookvol10.2.pamphlet" 2070824 2070880 2073579 2073584) (|Set| "bookvol10.3.pamphlet" 2069074 2069085 2070187 2070267) (|SetOfMIntegersInOneToN| "bookvol10.3.pamphlet" 2067535 2067571 2069064 2069069) (|SetCategory| "bookvol10.2.pamphlet" 2067017 2067034 2067525 2067530) (|SetCategory&| NIL 2066496 2066516 2067007 2067012) (|SetCategoryWithDegree| "bookvol10.2.pamphlet" 2066369 2066396 2066486 2066491) (|SetAggregate| "bookvol10.2.pamphlet" 2063234 2063254 2066321 2066364) (|SetAggregate&| NIL 2060134 2060157 2063224 2063229) (|SegmentExpansionCategory| "bookvol10.2.pamphlet" 2059175 2059209 2060114 2060129) (|Segment| "bookvol10.3.pamphlet" 2058967 2058982 2059077 2059082) (|SegmentCategory| "bookvol10.2.pamphlet" 2057743 2057766 2058947 2058962) (|SegmentBinding| "bookvol10.3.pamphlet" 2056810 2056832 2057690 2057695) (|SegmentBindingFunctions2| "bookvol10.4.pamphlet" 2056495 2056529 2056800 2056805) (|SegmentFunctions2| "bookvol10.4.pamphlet" 2055891 2055918 2056442 2056447) (|SequentialDifferentialVariable| "bookvol10.3.pamphlet" 2055162 2055200 2055881 2055886) (|SequentialDifferentialPolynomial| "bookvol10.3.pamphlet" 2051450 2051490 2051756 2051990) (|StochasticDifferential| "bookvol10.3.pamphlet" 2047885 2047915 2051401 2051445) (|StructuralConstantsPackage| "bookvol10.4.pamphlet" 2045965 2045999 2047875 2047880) (|SimpleCell| "bookvol10.3.pamphlet" 2045913 2045950 2045955 2045960) (|SortedCache| "bookvol10.4.pamphlet" 2044754 2044773 2045903 2045908) (|SingletonAsOrderedSet| "bookvol10.3.pamphlet" 2044608 2044635 2044744 2044749) (|SAERationalFunctionAlgFactor| "bookvol10.4.pamphlet" 2044296 2044341 2044598 2044603) (|SimpleAlgebraicExtension| "bookvol10.3.pamphlet" 2042023 2042060 2042701 2042917) (|SimpleAlgebraicExtensionAlgFactor| "bookvol10.4.pamphlet" 2041694 2041744 2042013 2042018) (|RationalUnivariateRepresentationPackage| "bookvol10.4.pamphlet" 2039394 2039446 2041684 2041689) (|Ruleset| "bookvol10.3.pamphlet" 2038826 2038850 2039384 2039389) (|RewriteRule| "bookvol10.3.pamphlet" 2037004 2037032 2038816 2038821) (|RuleCalled| "bookvol10.3.pamphlet" 2036849 2036869 2036994 2036999) (|RegularTriangularSetGcdPackage| "bookvol10.4.pamphlet" 2034192 2034239 2036839 2036844) (|RegularTriangularSetCategory| "bookvol10.2.pamphlet" 2024980 2025022 2034123 2034187) (|RegularTriangularSetCategory&| NIL 2015824 2015869 2024970 2024975) (|RegularSetDecompositionPackage| "bookvol10.4.pamphlet" 2014550 2014597 2015814 2015819) (|RealRootCharacterizationCategory| "bookvol10.2.pamphlet" 2012927 2012986 2014540 2014545) (|RealRootCharacterizationCategory&| NIL 2011301 2011363 2012917 2012922) (|RecursivePolynomialCategory| "bookvol10.2.pamphlet" 1994412 1994451 2011062 2011296) (|RecursivePolynomialCategory&| NIL 1977226 1977268 1993879 1993884) (|RoutinesTable| "bookvol10.3.pamphlet" 1973502 1973521 1976256 1976308) (|RomanNumeral| "bookvol10.3.pamphlet" 1972635 1972653 1973263 1973497) (|RightOpenIntervalRootCharacterization| "bookvol10.3.pamphlet" 1971735 1971801 1972625 1972630) (|RealNumberSystem| "bookvol10.2.pamphlet" 1970473 1970495 1971565 1971730) (|RealNumberSystem&| NIL 1969368 1969393 1970463 1970468) (|Rng| "bookvol10.2.pamphlet" 1968888 1968897 1969358 1969363) (|RightModule| "bookvol10.2.pamphlet" 1968395 1968414 1968878 1968883) (|RectangularMatrixCategoryFunctions2| "bookvol10.4.pamphlet" 1967791 1967880 1968385 1968390) (|RectangularMatrix| "bookvol10.3.pamphlet" 1966350 1966383 1966852 1966920) (|RectangularMatrixCategory| "bookvol10.2.pamphlet" 1961935 1961988 1966265 1966345) (|RectangularMatrixCategory&| NIL 1957409 1957465 1961742 1961747) (|RationalInterpolation| "bookvol10.4.pamphlet" 1957283 1957317 1957399 1957404) (|Ring| "bookvol10.2.pamphlet" 1956634 1956644 1957256 1957278) (|Ring&| NIL 1955999 1956012 1956624 1956629) (|RandomIntegerDistributions| "bookvol10.4.pamphlet" 1955004 1955036 1955989 1955994) (|RegularChain| "bookvol10.3.pamphlet" 1953346 1953371 1954236 1954288) (|RootsFindingPackage| "bookvol10.4.pamphlet" 1951380 1951407 1953336 1953341) (|RationalFunction| "bookvol10.4.pamphlet" 1949023 1949047 1951370 1951375) (|RationalFunctionFactorizer| "bookvol10.4.pamphlet" 1948462 1948496 1949013 1949018) (|RationalFunctionFactor| "bookvol10.4.pamphlet" 1948178 1948209 1948452 1948457) (|RandomFloatDistributions| "bookvol10.4.pamphlet" 1947153 1947183 1948168 1948173) (|RetractSolvePackage| "bookvol10.4.pamphlet" 1946556 1946585 1947143 1947148) (|RetractableTo| "bookvol10.2.pamphlet" 1945888 1945909 1946546 1946551) (|RetractableTo&| NIL 1945217 1945241 1945878 1945883) (|Result| "bookvol10.3.pamphlet" 1943659 1943671 1944247 1944299) (|ResidueRing| "bookvol10.3.pamphlet" 1942970 1943021 1943565 1943654) (|ResolveLatticeCompletion| "bookvol10.4.pamphlet" 1942275 1942307 1942960 1942965) (|RepeatedSquaring| "bookvol10.4.pamphlet" 1941993 1942017 1942265 1942270) (|RadicalEigenPackage| "bookvol10.4.pamphlet" 1939533 1939558 1941983 1941988) (|RepeatedDoubling| "bookvol10.4.pamphlet" 1939219 1939243 1939523 1939528) (|RepresentationPackage2| "bookvol10.4.pamphlet" 1929197 1929227 1939038 1939043) (|RepresentationPackage1| "bookvol10.4.pamphlet" 1923558 1923588 1929139 1929144) (|RegularTriangularSet| "bookvol10.3.pamphlet" 1921755 1921789 1923179 1923231) (|Reference| "bookvol10.3.pamphlet" 1921091 1921108 1921702 1921707) (|ReductionOfOrder| "bookvol10.4.pamphlet" 1920212 1920238 1921081 1921086) (|RecurrenceOperator| "bookvol10.4.pamphlet" 1918607 1918635 1920166 1920171) (|RealClosure| "bookvol10.3.pamphlet" 1917228 1917256 1917890 1918055) (|RealSolvePackage| "bookvol10.4.pamphlet" 1915788 1915810 1917218 1917223) (|RealConstant| "bookvol10.2.pamphlet" 1915663 1915681 1915778 1915783) (|RealZeroPackageQ| "bookvol10.4.pamphlet" 1913001 1913029 1915653 1915658) (|RealZeroPackage| "bookvol10.4.pamphlet" 1909898 1909925 1912991 1912996) (|ReducedDivisor| "bookvol10.4.pamphlet" 1909636 1909672 1909888 1909893) (|RandomDistributions| "bookvol10.4.pamphlet" 1909187 1909214 1909626 1909631) (|TranscendentalRischDESystem| "bookvol10.4.pamphlet" 1908021 1908059 1909177 1909182) (|TranscendentalRischDE| "bookvol10.4.pamphlet" 1905972 1906004 1908011 1908016) (|ElementaryRischDESystem| "bookvol10.4.pamphlet" 1905197 1905230 1905962 1905967) (|ElementaryRischDE| "bookvol10.4.pamphlet" 1904243 1904270 1905187 1905192) (|RealClosedField| "bookvol10.2.pamphlet" 1901488 1901509 1904073 1904238) (|RealClosedField&| NIL 1898890 1898914 1901478 1901483) (|RecursiveAggregate| "bookvol10.2.pamphlet" 1896848 1896874 1898870 1898885) (|RecursiveAggregate&| NIL 1894721 1894750 1896746 1896751) (|RationalRetractions| "bookvol10.4.pamphlet" 1894126 1894153 1894711 1894716) (|RationalFactorize| "bookvol10.4.pamphlet" 1893296 1893322 1894116 1894121) (|RandomNumberSource| "bookvol10.4.pamphlet" 1892638 1892662 1893286 1893291) (|RadixUtilities| "bookvol10.4.pamphlet" 1892383 1892403 1892628 1892633) (|RadixExpansion| "bookvol10.3.pamphlet" 1888474 1888499 1890137 1890302) (|RadicalFunctionField| "bookvol10.3.pamphlet" 1886346 1886396 1886462 1886717) (|RadicalCategory| "bookvol10.2.pamphlet" 1885965 1885986 1886336 1886341) (|RadicalCategory&| NIL 1885581 1885605 1885955 1885960) (|Queue| "bookvol10.3.pamphlet" 1881349 1881362 1885364 1885416) (|Quaternion| "bookvol10.3.pamphlet" 1879672 1879690 1879973 1880081) (|QuaternionCategoryFunctions2| "bookvol10.4.pamphlet" 1879051 1879095 1879662 1879667) (|QuaternionCategory| "bookvol10.2.pamphlet" 1877199 1877225 1878938 1879046) (|QuaternionCategory&| NIL 1875038 1875067 1876780 1876785) (|QueueAggregate| "bookvol10.2.pamphlet" 1873815 1873837 1874969 1875033) (|QuadraticForm| "bookvol10.3.pamphlet" 1873273 1873298 1873805 1873810) (|QuotientFieldCategory| "bookvol10.2.pamphlet" 1871877 1871906 1873091 1873268) (|QuotientFieldCategory&| NIL 1869971 1870003 1871188 1871193) (|QuotientFieldCategoryFunctions2| "bookvol10.4.pamphlet" 1869643 1869688 1869961 1869966) (|QueryEquation| "bookvol10.3.pamphlet" 1869207 1869226 1869633 1869638) (|QuasiComponentPackage| "bookvol10.4.pamphlet" 1865172 1865210 1869197 1869202) (|QuasiAlgebraicSet| "bookvol10.3.pamphlet" 1861301 1861348 1865057 1865062) (|QuasiAlgebraicSet2| "bookvol10.4.pamphlet" 1859297 1859331 1861291 1861296) (|PAdicWildFunctionFieldIntegralBasis| "bookvol10.4.pamphlet" 1856596 1856646 1859287 1859292) (|PushVariables| "bookvol10.4.pamphlet" 1855922 1855952 1856586 1856591) (|PartialTranscendentalFunctions| "bookvol10.2.pamphlet" 1852173 1852211 1855912 1855917) (|PointPackage| "bookvol10.4.pamphlet" 1849289 1849309 1852163 1852168) (|PointFunctions2| "bookvol10.4.pamphlet" 1849095 1849122 1849279 1849284) (|PointCategory| "bookvol10.2.pamphlet" 1848151 1848172 1849026 1849090) (|PolynomialSquareFree| "bookvol10.4.pamphlet" 1847444 1847486 1848141 1848146) (|PseudoLinearNormalForm| "bookvol10.4.pamphlet" 1846294 1846324 1847434 1847439) (|PolynomialSetUtilitiesPackage| "bookvol10.4.pamphlet" 1833740 1833783 1846136 1846141) (|PolynomialSetCategory| "bookvol10.2.pamphlet" 1828564 1828606 1833696 1833735) (|PolynomialSetCategory&| NIL 1823373 1823418 1828508 1828513) (|PlottableSpaceCurveCategory| "bookvol10.2.pamphlet" 1822373 1822406 1823363 1823368) (|PowerSeriesCategory| "bookvol10.2.pamphlet" 1821051 1821097 1822203 1822368) (|PowerSeriesCategory&| NIL 1819886 1819935 1821041 1821046) (|Partition| "bookvol10.3.pamphlet" 1818682 1818697 1819876 1819881) (|ProjectiveSpaceCategory| "bookvol10.2.pamphlet" 1816156 1816187 1818672 1818677) (|PseudoRemainderSequence| "bookvol10.4.pamphlet" 1807797 1807835 1816105 1816110) (|PriorityQueueAggregate| "bookvol10.2.pamphlet" 1807175 1807205 1807728 1807792) (|ProjectiveSpace| "bookvol10.3.pamphlet" 1807046 1807075 1807165 1807170) (|ProjectivePlaneOverPseudoAlgebraicClosureOfFiniteField| "bookvol10.3.pamphlet" 1806884 1806946 1807036 1807041) (|ProjectivePlane| "bookvol10.3.pamphlet" 1806761 1806784 1806874 1806879) (|Product| "bookvol10.3.pamphlet" 1803561 1803578 1804093 1804161) (|PolynomialRing| "bookvol10.3.pamphlet" 1801609 1801633 1802314 1802548) (|ProjectiveAlgebraicSetPackage| "bookvol10.4.pamphlet" 1800836 1800902 1801599 1801604) (|PrintPackage| "bookvol10.4.pamphlet" 1800578 1800596 1800826 1800831) (|IntegerPrimesPackage| "bookvol10.4.pamphlet" 1798793 1798821 1800568 1800573) (|PrimitiveElement| "bookvol10.4.pamphlet" 1796870 1796894 1798783 1798788) (|PrimitiveFunctionCategory| "bookvol10.2.pamphlet" 1796458 1796489 1796860 1796865) (|PrimitiveArray| "bookvol10.3.pamphlet" 1795575 1795597 1795740 1795792) (|PrimitiveArrayFunctions2| "bookvol10.4.pamphlet" 1793659 1793693 1795565 1795570) (|PrecomputedAssociatedEquations| "bookvol10.4.pamphlet" 1792997 1793037 1793649 1793654) (|PlottablePlaneCurveCategory| "bookvol10.2.pamphlet" 1792337 1792370 1792987 1792992) (|U32VectorPolynomialOperations| "bookvol10.4.pamphlet" 1787119 1787154 1792327 1792332) (|PolynomialRoots| "bookvol10.4.pamphlet" 1785847 1785878 1787068 1787073) (|Polynomial| "bookvol10.3.pamphlet" 1782243 1782261 1782747 1782981) (|PolynomialCategoryLifting| "bookvol10.4.pamphlet" 1781509 1781555 1782233 1782238) (|PolynomialCategoryQuotientFunctions| "bookvol10.4.pamphlet" 1779490 1779541 1781499 1781504) (|PolynomialCategory| "bookvol10.2.pamphlet" 1772797 1772834 1779251 1779485) (|PolynomialCategory&| NIL 1765251 1765291 1771708 1771713) (|PolynomialToUnivariatePolynomial| "bookvol10.4.pamphlet" 1764667 1764711 1765241 1765246) (|PolynomialFunctions2| "bookvol10.4.pamphlet" 1764255 1764285 1764657 1764662) (|RealPolynomialUtilitiesPackage| "bookvol10.4.pamphlet" 1763259 1763316 1764202 1764207) (|PolToPol| "bookvol10.4.pamphlet" 1762001 1762022 1763249 1763254) (|Point| "bookvol10.3.pamphlet" 1760879 1760892 1760969 1761021) (|PolynomialNumberTheoryFunctions| "bookvol10.4.pamphlet" 1757522 1757559 1760869 1760874) (|PatternMatchTools| "bookvol10.4.pamphlet" 1756328 1756357 1757512 1757517) (|PatternMatchSymbol| "bookvol10.4.pamphlet" 1755869 1755895 1756318 1756323) (|PatternMatchQuotientFieldCategory| "bookvol10.4.pamphlet" 1755437 1755482 1755859 1755864) (|AttachPredicates| "bookvol10.4.pamphlet" 1754947 1754971 1755427 1755432) (|FunctionSpaceAttachPredicates| "bookvol10.4.pamphlet" 1754423 1754464 1754937 1754942) (|PatternMatchPolynomialCategory| "bookvol10.4.pamphlet" 1753461 1753507 1754341 1754346) (|PatternMatchListAggregate| "bookvol10.4.pamphlet" 1753023 1753060 1753451 1753456) (|PatternMatchKernel| "bookvol10.4.pamphlet" 1752586 1752614 1753013 1753018) (|PatternMatchIntegerNumberSystem| "bookvol10.4.pamphlet" 1752137 1752176 1752576 1752581) (|PatternMatchFunctionSpace| "bookvol10.4.pamphlet" 1751703 1751740 1752127 1752132) (|PatternMatchPushDown| "bookvol10.4.pamphlet" 1750995 1751027 1751693 1751698) (|PatternMatchAssertions| "bookvol10.4.pamphlet" 1750042 1750070 1750985 1750990) (|FunctionSpaceAssertions| "bookvol10.4.pamphlet" 1749049 1749082 1750032 1750037) (|PolynomialPackageForCurve| "bookvol10.4.pamphlet" 1747924 1747985 1749039 1749044) (|PlotTools| "bookvol10.4.pamphlet" 1747697 1747712 1747914 1747919) (|Plot| "bookvol10.3.pamphlet" 1742547 1742557 1747687 1747692) (|Plot3D| "bookvol10.3.pamphlet" 1739157 1739169 1742537 1742542) (|PlotFunctions1| "bookvol10.4.pamphlet" 1738296 1738318 1739147 1739152) (|ParametricLinearEquations| "bookvol10.4.pamphlet" 1724386 1724436 1738286 1738291) (|Plcs| "bookvol10.3.pamphlet" 1724291 1724307 1724376 1724381) (|PlacesOverPseudoAlgebraicClosureOfFiniteField| "bookvol10.3.pamphlet" 1724159 1724212 1724281 1724286) (|Places| "bookvol10.3.pamphlet" 1724066 1724080 1724149 1724154) (|PlacesCategory| "bookvol10.2.pamphlet" 1723096 1723122 1724056 1724061) (|PolynomialInterpolation| "bookvol10.4.pamphlet" 1722701 1722737 1723086 1723091) (|PolynomialInterpolationAlgorithms| "bookvol10.4.pamphlet" 1722458 1722501 1722691 1722696) (|PositiveInteger| "bookvol10.3.pamphlet" 1722061 1722082 1722424 1722453) (|PrincipalIdealDomain| "bookvol10.2.pamphlet" 1720980 1721006 1721944 1722056) (|PiCoercions| "bookvol10.4.pamphlet" 1720716 1720735 1720970 1720975) (|PolyGroebner| "bookvol10.4.pamphlet" 1719328 1719348 1720706 1720711) (|PermutationGroupExamples| "bookvol10.4.pamphlet" 1711264 1711294 1719318 1719323) (|PolynomialGcdPackage| "bookvol10.4.pamphlet" 1709727 1709762 1711254 1711259) (|PartialFractionPackage| "bookvol10.4.pamphlet" 1708758 1708788 1709717 1709722) (|PartialFraction| "bookvol10.3.pamphlet" 1704243 1704266 1708588 1708753) (|PointsOfFiniteOrderTools| "bookvol10.4.pamphlet" 1703568 1703606 1704233 1704238) (|PackageForPoly| "bookvol10.4.pamphlet" 1701697 1701738 1703558 1703563) (|PointsOfFiniteOrderRational| "bookvol10.4.pamphlet" 1701042 1701085 1701687 1701692) (|PointsOfFiniteOrder| "bookvol10.4.pamphlet" 1700450 1700490 1701032 1701037) (|PrimeField| "bookvol10.3.pamphlet" 1700006 1700026 1700144 1700309) (|PolynomialFactorizationExplicit| "bookvol10.2.pamphlet" 1697642 1697679 1699889 1700001) (|PolynomialFactorizationExplicit&| NIL 1695329 1695369 1697579 1697584) (|PolynomialFactorizationByRecursionUnivariate| "bookvol10.4.pamphlet" 1693194 1693248 1695319 1695324) (|PolynomialFactorizationByRecursion| "bookvol10.4.pamphlet" 1690822 1690877 1693184 1693189) (|Permutation| "bookvol10.3.pamphlet" 1686107 1686126 1690624 1690646) (|PermutationGroup| "bookvol10.3.pamphlet" 1680858 1680882 1686097 1686102) (|PermutationCategory| "bookvol10.2.pamphlet" 1679497 1679524 1680831 1680853) (|Permanent| "bookvol10.4.pamphlet" 1678249 1678270 1679487 1679492) (|PendantTree| "bookvol10.3.pamphlet" 1677490 1677509 1678079 1678084) (|PartialDifferentialRing| "bookvol10.2.pamphlet" 1675837 1675868 1677463 1677485) (|PartialDifferentialRing&| NIL 1674198 1674232 1675827 1675832) (|NumericalPDEProblem| "bookvol10.3.pamphlet" 1672360 1672385 1674188 1674193) (|AnnaPartialDifferentialEquationPackage| "bookvol10.4.pamphlet" 1666400 1666444 1672350 1672355) (|PolynomialDecomposition| "bookvol10.4.pamphlet" 1665735 1665769 1666390 1666395) (|PartialDifferentialEquationsSolverCategory| "bookvol10.2.pamphlet" 1663845 1663893 1665725 1665730) (|PolynomialComposition| "bookvol10.4.pamphlet" 1663561 1663593 1663835 1663840) (|PoincareBirkhoffWittLyndonBasis| "bookvol10.3.pamphlet" 1662174 1662220 1663551 1663556) (|Pattern| "bookvol10.3.pamphlet" 1656454 1656469 1662164 1662169) (|PatternFunctions2| "bookvol10.4.pamphlet" 1656170 1656197 1656444 1656449) (|PatternFunctions1| "bookvol10.4.pamphlet" 1654457 1654484 1656160 1656165) (|PatternMatchResult| "bookvol10.3.pamphlet" 1652102 1652130 1654447 1654452) (|PatternMatchResultFunctions2| "bookvol10.4.pamphlet" 1651788 1651828 1652092 1652097) (|PatternMatch| "bookvol10.4.pamphlet" 1649958 1649999 1651455 1651460) (|PatternMatchable| "bookvol10.2.pamphlet" 1649383 1649407 1649948 1649953) (|PatternMatchListResult| "bookvol10.3.pamphlet" 1648473 1648507 1649373 1649378) (|Patternable| "bookvol10.2.pamphlet" 1648170 1648189 1648463 1648468) (|PartitionsAndPermutations| "bookvol10.4.pamphlet" 1645665 1645696 1648160 1648165) (|ParametricSurface| "bookvol10.3.pamphlet" 1645108 1645151 1645655 1645660) (|ParametricSurfaceFunctions2| "bookvol10.4.pamphlet" 1644876 1644917 1645098 1645103) (|ParametricSpaceCurve| "bookvol10.3.pamphlet" 1644316 1644362 1644866 1644871) (|ParametricSpaceCurveFunctions2| "bookvol10.4.pamphlet" 1644075 1644119 1644306 1644311) (|ParametricPlaneCurve| "bookvol10.3.pamphlet" 1643527 1643573 1644065 1644070) (|ParametricPlaneCurveFunctions2| "bookvol10.4.pamphlet" 1643286 1643330 1643517 1643522) (|ParametrizationPackage| "bookvol10.4.pamphlet" 1642089 1642158 1643276 1643281) (|PolynomialAN2Expression| "bookvol10.4.pamphlet" 1641482 1641511 1642079 1642084) (|Palette| "bookvol10.3.pamphlet" 1640485 1640498 1641472 1641477) (|PackageForAlgebraicFunctionField| "bookvol10.4.pamphlet" 1634898 1634951 1640437 1640442) (|PackageForAlgebraicFunctionFieldOverFiniteField| "bookvol10.4.pamphlet" 1628697 1628765 1634810 1634815) (|PAdicRationalConstructor| "bookvol10.3.pamphlet" 1625493 1625533 1626644 1626809) (|PAdicRational| "bookvol10.3.pamphlet" 1622677 1622700 1622861 1623026) (|PAdicInteger| "bookvol10.3.pamphlet" 1622369 1622391 1622560 1622672) (|PAdicIntegerCategory| "bookvol10.2.pamphlet" 1620854 1620884 1622252 1622364) (|PadeApproximantPackage| "bookvol10.4.pamphlet" 1619779 1619818 1620844 1620849) (|PadeApproximants| "bookvol10.4.pamphlet" 1618770 1618800 1619769 1619774) (|PseudoAlgebraicClosureOfRationalNumber| "bookvol10.3.pamphlet" 1617383 1617427 1618255 1618420) (|PseudoAlgebraicClosureOfRationalNumberCategory| "bookvol10.2.pamphlet" 1616251 1616303 1617213 1617378) (|PseudoAlgebraicClosureOfPerfectFieldCategory| "bookvol10.2.pamphlet" 1614436 1614486 1616081 1616246) (|PseudoAlgebraicClosureOfFiniteField| "bookvol10.3.pamphlet" 1613251 1613294 1614121 1614286) (|PseudoAlgebraicClosureOfFiniteFieldCategory| "bookvol10.2.pamphlet" 1612125 1612174 1613081 1613246) (|PseudoAlgebraicClosureOfAlgExtOfRationalNumber| "bookvol10.3.pamphlet" 1610140 1610204 1611035 1611200) (|PseudoAlgebraicClosureOfAlgExtOfRationalNumberCategory| "bookvol10.2.pamphlet" 1608992 1609052 1609970 1610135) (|OrdinaryWeightedPolynomials| "bookvol10.3.pamphlet" 1607909 1607964 1608784 1608901) (|OrderedVariableList| "bookvol10.3.pamphlet" 1607673 1607713 1607899 1607904) (|OutputPackage| "bookvol10.4.pamphlet" 1606788 1606807 1607663 1607668) (|OutputForm| "bookvol10.3.pamphlet" 1596194 1596210 1606778 1606783) (|OrdSetInts| "bookvol10.3.pamphlet" 1595791 1595807 1596184 1596189) (|OrthogonalPolynomialFunctions| "bookvol10.4.pamphlet" 1594204 1594241 1595691 1595696) (|UnivariateSkewPolynomial| "bookvol10.3.pamphlet" 1593435 1593487 1593789 1593852) (|SparseUnivariateSkewPolynomial| "bookvol10.3.pamphlet" 1592595 1592649 1593020 1593083) (|UnivariateSkewPolynomialCategoryOps| "bookvol10.4.pamphlet" 1590307 1590352 1592500 1592505) (|UnivariateSkewPolynomialCategory| "bookvol10.2.pamphlet" 1584265 1584305 1590239 1590302) (|UnivariateSkewPolynomialCategory&| NIL 1578101 1578144 1584078 1584083) (|OrderedSet| "bookvol10.2.pamphlet" 1577233 1577249 1578091 1578096) (|OrderedSet&| NIL 1576362 1576381 1577223 1577228) (|OrderedRing| "bookvol10.2.pamphlet" 1575680 1575697 1576335 1576357) (|OrderedRing&| NIL 1575012 1575032 1575670 1575675) (|OrderedMonoid| "bookvol10.2.pamphlet" 1574725 1574744 1575002 1575007) (|OrderingFunctions| "bookvol10.4.pamphlet" 1573857 1573888 1574715 1574720) (|OrderedFinite| "bookvol10.2.pamphlet" 1573780 1573799 1573847 1573852) (|OrderedCompletion| "bookvol10.3.pamphlet" 1572130 1572155 1573200 1573245) (|OrderedCompletionFunctions2| "bookvol10.4.pamphlet" 1571457 1571494 1572120 1572125) (|NumericalOptimizationProblem| "bookvol10.3.pamphlet" 1569197 1569231 1571447 1571452) (|AnnaNumericalOptimizationPackage| "bookvol10.4.pamphlet" 1561619 1561657 1569187 1569192) (|NumericalOptimizationCategory| "bookvol10.2.pamphlet" 1559070 1559105 1561609 1561614) (|OperationsQuery| "bookvol10.4.pamphlet" 1558612 1558633 1559060 1559065) (|Operator| "bookvol10.3.pamphlet" 1558250 1558266 1558336 1558453) (|OnePointCompletion| "bookvol10.3.pamphlet" 1556883 1556909 1557670 1557715) (|OnePointCompletionFunctions2| "bookvol10.4.pamphlet" 1556348 1556386 1556873 1556878) (|OpenMathServerPackage| "bookvol10.4.pamphlet" 1555379 1555406 1556338 1556343) (|OrderedMultisetAggregate| "bookvol10.2.pamphlet" 1555100 1555132 1555282 1555374) (|OpenMathPackage| "bookvol10.4.pamphlet" 1553763 1553784 1555090 1555095) (|OpenMath| "bookvol10.2.pamphlet" 1552832 1552846 1553753 1553758) (|OppositeMonogenicLinearOperator| "bookvol10.3.pamphlet" 1552169 1552210 1552667 1552730) (|ExpressionToOpenMath| "bookvol10.4.pamphlet" 1551985 1552013 1552159 1552164) (|OpenMathError| "bookvol10.3.pamphlet" 1551527 1551546 1551975 1551980) (|OpenMathErrorKind| "bookvol10.3.pamphlet" 1550564 1550587 1551517 1551522) (|OpenMathEncoding| "bookvol10.3.pamphlet" 1549896 1549918 1550554 1550559) (|OpenMathDevice| "bookvol10.3.pamphlet" 1544627 1544647 1549886 1549891) (|OpenMathConnection| "bookvol10.3.pamphlet" 1544028 1544052 1544617 1544622) (|OrderedIntegralDomain| "bookvol10.2.pamphlet" 1543743 1543770 1543911 1544023) (|OrderedFreeMonoid| "bookvol10.3.pamphlet" 1537355 1537380 1543733 1543738) (|OrderlyDifferentialVariable| "bookvol10.3.pamphlet" 1536613 1536648 1537345 1537350) (|OrdinaryDifferentialRing| "bookvol10.3.pamphlet" 1535952 1536000 1536338 1536571) (|OrderlyDifferentialPolynomial| "bookvol10.3.pamphlet" 1532208 1532245 1532561 1532795) (|OrderedDirectProduct| "bookvol10.3.pamphlet" 1521996 1522034 1522372 1522576) (|ODETools| "bookvol10.4.pamphlet" 1520519 1520540 1521986 1521991) (|SystemODESolver| "bookvol10.4.pamphlet" 1517970 1517996 1520509 1520514) (|RationalRicDE| "bookvol10.4.pamphlet" 1513869 1513893 1517904 1517909) (|ReduceLODE| "bookvol10.4.pamphlet" 1513226 1513254 1513859 1513864) (|RationalLODE| "bookvol10.4.pamphlet" 1510664 1510687 1513216 1513221) (|PrimitiveRatRicDE| "bookvol10.4.pamphlet" 1507668 1507701 1510654 1510659) (|NumericalODEProblem| "bookvol10.3.pamphlet" 1506307 1506332 1507658 1507663) (|PrimitiveRatDE| "bookvol10.4.pamphlet" 1503557 1503587 1506297 1506302) (|PureAlgebraicLODE| "bookvol10.4.pamphlet" 1502912 1502947 1503547 1503552) (|AnnaOrdinaryDifferentialEquationPackage| "bookvol10.4.pamphlet" 1490619 1490664 1502902 1502907) (|ODEIntegration| "bookvol10.4.pamphlet" 1490030 1490054 1490609 1490614) (|ODEIntensityFunctionsTable| "bookvol10.3.pamphlet" 1487409 1487441 1490020 1490025) (|ElementaryFunctionODESolver| "bookvol10.4.pamphlet" 1482705 1482742 1487399 1487404) (|ConstantLODE| "bookvol10.4.pamphlet" 1482208 1482232 1482695 1482700) (|OrdinaryDifferentialEquationsSolverCategory| "bookvol10.2.pamphlet" 1480558 1480607 1482198 1482203) (|Octonion| "bookvol10.3.pamphlet" 1478407 1478423 1479095 1479158) (|OctonionCategoryFunctions2| "bookvol10.4.pamphlet" 1478032 1478074 1478397 1478402) (|OctonionCategory| "bookvol10.2.pamphlet" 1475942 1475966 1477964 1478027) (|OctonionCategory&| NIL 1473502 1473529 1475527 1475532) (|OrderedCancellationAbelianMonoid| "bookvol10.2.pamphlet" 1473322 1473360 1473492 1473497) (|OrderedAbelianSemiGroup| "bookvol10.2.pamphlet" 1473067 1473096 1473312 1473317) (|OrderedAbelianMonoidSup| "bookvol10.2.pamphlet" 1472400 1472429 1473057 1473062) (|OrderedAbelianMonoid| "bookvol10.2.pamphlet" 1472245 1472271 1472390 1472395) (|OrderedAbelianGroup| "bookvol10.2.pamphlet" 1472092 1472117 1472235 1472240) (|NumericTubePlot| "bookvol10.4.pamphlet" 1471806 1471835 1472082 1472087) (|NumericalQuadrature| "bookvol10.4.pamphlet" 1460518 1460543 1471796 1471801) (|NumericalOrdinaryDifferentialEquations| "bookvol10.4.pamphlet" 1452049 1452093 1460508 1460513) (|NumericalIntegrationCategory| "bookvol10.2.pamphlet" 1449378 1449412 1452039 1452044) (|NumberFormats| "bookvol10.4.pamphlet" 1448209 1448228 1449368 1449373) (|Numeric| "bookvol10.4.pamphlet" 1440316 1440331 1447968 1447973) (|NormalizedTriangularSetCategory| "bookvol10.2.pamphlet" 1439669 1439714 1440247 1440311) (|NumberTheoreticPolynomialFunctions| "bookvol10.4.pamphlet" 1439171 1439213 1439569 1439574) (|NewSparseUnivariatePolynomial| "bookvol10.3.pamphlet" 1431984 1432021 1435660 1435937) (|NewSparseUnivariatePolynomialFunctions2| "bookvol10.4.pamphlet" 1431343 1431392 1431974 1431979) (|NewSparseMultivariatePolynomial| "bookvol10.3.pamphlet" 1426329 1426377 1426650 1426884) (|NeitherSparseOrDensePowerSeries| "bookvol10.3.pamphlet" 1424503 1424542 1424609 1424774) (|NumericRealEigenPackage| "bookvol10.4.pamphlet" 1422872 1422907 1424493 1424498) (|NewtonPolygon| "bookvol10.4.pamphlet" 1422753 1422793 1422862 1422867) (|NPCoef| "bookvol10.4.pamphlet" 1421997 1422021 1422743 1422748) (|NottinghamGroup| "bookvol10.3.pamphlet" 1421869 1421892 1421970 1421992) (|NormRetractPackage| "bookvol10.4.pamphlet" 1421451 1421502 1421859 1421864) (|NormalizationPackage| "bookvol10.4.pamphlet" 1420281 1420318 1421441 1421446) (|NormInMonogenicAlgebra| "bookvol10.4.pamphlet" 1419943 1419989 1420271 1420276) (|None| "bookvol10.3.pamphlet" 1419682 1419692 1419933 1419938) (|NoneFunctions1| "bookvol10.4.pamphlet" 1419346 1419368 1419672 1419677) (|NonLinearFirstOrderODESolver| "bookvol10.4.pamphlet" 1418781 1418819 1419336 1419341) (|NonNegativeInteger| "bookvol10.3.pamphlet" 1417647 1417671 1418747 1418776) (|NonLinearSolvePackage| "bookvol10.4.pamphlet" 1416254 1416283 1417637 1417642) (|NumericalIntegrationProblem| "bookvol10.3.pamphlet" 1413917 1413950 1416244 1416249) (|NumberFieldIntegralBasis| "bookvol10.4.pamphlet" 1411367 1411402 1413907 1413912) (|NewtonInterpolation| "bookvol10.4.pamphlet" 1410673 1410700 1411357 1411362) (|NonCommutativeOperatorDivision| "bookvol10.4.pamphlet" 1408789 1408829 1410663 1410668) (|NumericContinuedFraction| "bookvol10.4.pamphlet" 1408428 1408460 1408779 1408784) (|NumericComplexEigenPackage| "bookvol10.4.pamphlet" 1406582 1406620 1408418 1408423) (|NonAssociativeRing| "bookvol10.2.pamphlet" 1406164 1406188 1406572 1406577) (|NonAssociativeRing&| NIL 1405743 1405770 1406154 1406159) (|NonAssociativeRng| "bookvol10.2.pamphlet" 1405106 1405129 1405733 1405738) (|NonAssociativeRng&| NIL 1404466 1404492 1405096 1405101) (|NAGLinkSupportPackage| "bookvol10.4.pamphlet" 1403524 1403551 1404456 1404461) (|NagSpecialFunctionsPackage| "bookvol10.4.pamphlet" 1393942 1393974 1403514 1403519) (|NagLapack| "bookvol10.4.pamphlet" 1392435 1392450 1393932 1393937) (|NagLinearEquationSolvingPackage| "bookvol10.4.pamphlet" 1386870 1386907 1392425 1392430) (|NagEigenPackage| "bookvol10.4.pamphlet" 1381013 1381034 1386860 1386865) (|NagMatrixOperationsPackage| "bookvol10.4.pamphlet" 1376799 1376831 1381003 1381008) (|NagOptimisationPackage| "bookvol10.4.pamphlet" 1370573 1370601 1376789 1376794) (|NagFittingPackage| "bookvol10.4.pamphlet" 1361315 1361338 1370563 1370568) (|NagInterpolationPackage| "bookvol10.4.pamphlet" 1357385 1357414 1361305 1361310) (|NagPartialDifferentialEquationsPackage| "bookvol10.4.pamphlet" 1355388 1355432 1357375 1357380) (|NagOrdinaryDifferentialEquationsPackage| "bookvol10.4.pamphlet" 1348157 1348202 1355378 1355383) (|NagIntegrationPackage| "bookvol10.4.pamphlet" 1342682 1342709 1348147 1348152) (|NagSeriesSummationPackage| "bookvol10.4.pamphlet" 1338591 1338622 1342672 1342677) (|NagRootFindingPackage| "bookvol10.4.pamphlet" 1337118 1337145 1338581 1338586) (|NagPolynomialRootsPackage| "bookvol10.4.pamphlet" 1336425 1336456 1337108 1337113) (|NonAssociativeAlgebra| "bookvol10.2.pamphlet" 1335941 1335970 1336376 1336420) (|NonAssociativeAlgebra&| NIL 1335493 1335525 1335931 1335936) (|MyUnivariatePolynomial| "bookvol10.3.pamphlet" 1331639 1331673 1331982 1332259) (|MyExpression| "bookvol10.3.pamphlet" 1329189 1329213 1329271 1329638) (|MultivariateSquareFree| "bookvol10.4.pamphlet" 1326137 1326174 1329179 1329184) (|MultivariateFactorize| "bookvol10.4.pamphlet" 1325516 1325552 1326127 1326132) (|MultivariateTaylorSeriesCategory| "bookvol10.2.pamphlet" 1323448 1323499 1325346 1325511) (|MergeThing| "bookvol10.4.pamphlet" 1323099 1323117 1323438 1323443) (|MoreSystemCommands| "bookvol10.4.pamphlet" 1322541 1322565 1323089 1323094) (|Multiset| "bookvol10.3.pamphlet" 1320517 1320533 1322222 1322302) (|MultisetAggregate| "bookvol10.2.pamphlet" 1320306 1320331 1320444 1320512) (|MonoidRing| "bookvol10.3.pamphlet" 1317219 1317239 1319900 1320017) (|MonoidRingFunctions2| "bookvol10.4.pamphlet" 1316763 1316795 1317209 1317214) (|MRationalFactorize| "bookvol10.4.pamphlet" 1316308 1316341 1316753 1316758) (|MPolyCatRationalFunctionFactorizer| "bookvol10.4.pamphlet" 1314349 1314400 1316298 1316303) (|MultivariatePolynomial| "bookvol10.3.pamphlet" 1310797 1310832 1311159 1311393) (|MPolyCatPolyFactorizer| "bookvol10.4.pamphlet" 1310056 1310095 1310787 1310792) (|MPolyCatFunctions3| "bookvol10.4.pamphlet" 1309853 1309909 1310046 1310051) (|MPolyCatFunctions2| "bookvol10.4.pamphlet" 1309588 1309637 1309843 1309848) (|MonomialExtensionTools| "bookvol10.4.pamphlet" 1307943 1307976 1309578 1309583) (|Monoid| "bookvol10.2.pamphlet" 1306841 1306853 1307933 1307938) (|Monoid&| NIL 1305736 1305751 1306831 1306836) (|MonogenicAlgebra| "bookvol10.2.pamphlet" 1304369 1304396 1305515 1305731) (|MonogenicAlgebra&| NIL 1303080 1303110 1304229 1304234) (|MonadWithUnit| "bookvol10.2.pamphlet" 1301222 1301241 1303070 1303075) (|MonadWithUnit&| NIL 1299361 1299383 1301212 1301217) (|Monad| "bookvol10.2.pamphlet" 1298549 1298560 1299351 1299356) (|Monad&| NIL 1297734 1297748 1298539 1298544) (|MoebiusTransform| "bookvol10.3.pamphlet" 1296374 1296398 1297707 1297729) (|Module| "bookvol10.2.pamphlet" 1296066 1296080 1296325 1296369) (|Module&| NIL 1295794 1295811 1296056 1296061) (|ModularRing| "bookvol10.3.pamphlet" 1295089 1295145 1295767 1295789) (|ModuleOperator| "bookvol10.3.pamphlet" 1293599 1293623 1294813 1294930) (|ModuleMonomial| "bookvol10.3.pamphlet" 1293100 1293130 1293589 1293594) (|ModMonic| "bookvol10.3.pamphlet" 1288672 1288694 1289496 1289773) (|ModularField| "bookvol10.3.pamphlet" 1287949 1288006 1288502 1288667) (|MathMLFormat| "bookvol10.3.pamphlet" 1286744 1286762 1287939 1287944) (|MultipleMap| "bookvol10.4.pamphlet" 1286469 1286512 1286734 1286739) (|MonogenicLinearOperator| "bookvol10.2.pamphlet" 1284842 1284873 1286401 1286464) (|MultivariateLifting| "bookvol10.4.pamphlet" 1283441 1283475 1284832 1284837) (|MakeUnaryCompiledFunction| "bookvol10.4.pamphlet" 1282862 1282899 1283431 1283436) (|MakeRecord| "bookvol10.4.pamphlet" 1282446 1282467 1282852 1282857) (|MakeFunction| "bookvol10.4.pamphlet" 1281721 1281741 1282436 1282441) (|MakeFloatCompiledFunction| "bookvol10.4.pamphlet" 1280548 1280581 1281711 1281716) (|MakeCachableSet| "bookvol10.3.pamphlet" 1280313 1280336 1280538 1280543) (|MakeBinaryCompiledFunction| "bookvol10.4.pamphlet" 1279728 1279770 1280303 1280308) (|MachineInteger| "bookvol10.3.pamphlet" 1279076 1279096 1279551 1279723) (|ModularHermitianRowReduction| "bookvol10.4.pamphlet" 1277689 1277725 1279066 1279071) (|MachineFloat| "bookvol10.3.pamphlet" 1276047 1276065 1277499 1277684) (|MultFiniteFactorize| "bookvol10.4.pamphlet" 1275434 1275469 1276037 1276042) (|MeshCreationRoutinesForThreeDimensions| "bookvol10.4.pamphlet" 1273310 1273354 1275424 1275429) (|ModularDistinctDegreeFactorizer| "bookvol10.4.pamphlet" 1271534 1271573 1273300 1273305) (|MultiDictionary| "bookvol10.2.pamphlet" 1270789 1270812 1271489 1271529) (|MachineComplex| "bookvol10.3.pamphlet" 1264702 1264722 1265328 1265733) (|MatrixCommonDenominator| "bookvol10.4.pamphlet" 1263883 1263916 1264692 1264697) (|MultiVariableCalculusFunctions| "bookvol10.4.pamphlet" 1261119 1261169 1263873 1263878) (|StorageEfficientMatrixOperations| "bookvol10.4.pamphlet" 1258369 1258409 1261109 1261114) (|Matrix| "bookvol10.3.pamphlet" 1257124 1257138 1257610 1257662) (|MatrixLinearAlgebraFunctions| "bookvol10.4.pamphlet" 1254478 1254528 1256980 1256985) (|MatrixCategory| "bookvol10.2.pamphlet" 1240569 1240603 1254409 1254473) (|MatrixCategory&| NIL 1226483 1226520 1240326 1240331) (|MatrixCategoryFunctions2| "bookvol10.4.pamphlet" 1225743 1225813 1226473 1226478) (|MappingPackage4| "bookvol10.4.pamphlet" 1224524 1224549 1225733 1225738) (|MappingPackage3| "bookvol10.4.pamphlet" 1223386 1223413 1224514 1224519) (|MappingPackage2| "bookvol10.4.pamphlet" 1222679 1222704 1223376 1223381) (|MappingPackage1| "bookvol10.4.pamphlet" 1221488 1221511 1222669 1222674) (|MappingPackageInternalHacks3| "bookvol10.4.pamphlet" 1221274 1221314 1221478 1221483) (|MappingPackageInternalHacks2| "bookvol10.4.pamphlet" 1221017 1221055 1221264 1221269) (|MappingPackageInternalHacks1| "bookvol10.4.pamphlet" 1220627 1220663 1221007 1221012) (|MatrixManipulation| "bookvol10.4.pamphlet" 1216283 1216323 1220617 1220622) (|Magma| "bookvol10.3.pamphlet" 1214564 1214584 1216273 1216278) (|ModularAlgebraicGcdOperations| "bookvol10.2.pamphlet" 1212393 1212435 1214554 1214559) (|ThreeDimensionalMatrix| "bookvol10.3.pamphlet" 1210317 1210347 1211953 1211958) (|LazyStreamAggregate| "bookvol10.2.pamphlet" 1206048 1206075 1210297 1210312) (|LazyStreamAggregate&| NIL 1201786 1201816 1206038 1206043) (|LyndonWord| "bookvol10.3.pamphlet" 1199016 1199041 1201776 1201781) (|LieSquareMatrix| "bookvol10.3.pamphlet" 1196929 1196956 1197324 1197411) (|LinearSystemPolynomialPackage| "bookvol10.4.pamphlet" 1196445 1196489 1196919 1196924) (|LinearSystemMatrixPackage| "bookvol10.4.pamphlet" 1195228 1195275 1196435 1196440) (|LinearSystemMatrixPackage1| "bookvol10.4.pamphlet" 1192970 1193004 1195218 1195223) (|ListAggregate| "bookvol10.2.pamphlet" 1192591 1192612 1192901 1192965) (|ListAggregate&| NIL 1192268 1192292 1192581 1192586) (|LiePolynomial| "bookvol10.3.pamphlet" 1191372 1191402 1192091 1192177) (|LinearPolynomialEquationByFractions| "bookvol10.4.pamphlet" 1190600 1190643 1191362 1191367) (|LocalParametrizationOfSimplePointPackage| "bookvol10.4.pamphlet" 1189038 1189125 1190590 1190595) (|LeftOreRing| "bookvol10.2.pamphlet" 1188483 1188500 1188947 1189033) (|LinesOpPack| "bookvol10.4.pamphlet" 1187147 1187166 1188473 1188478) (|Localize| "bookvol10.3.pamphlet" 1186504 1186524 1187047 1187091) (|Logic| "bookvol10.2.pamphlet" 1186133 1186144 1186494 1186499) (|Logic&| NIL 1185759 1185773 1186123 1186128) (|LinearOrdinaryDifferentialOperatorsOps| "bookvol10.4.pamphlet" 1184653 1184701 1185749 1185754) (|LinearOrdinaryDifferentialOperator| "bookvol10.3.pamphlet" 1183896 1183945 1184238 1184301) (|LinearOrdinaryDifferentialOperatorFactorizer| "bookvol10.4.pamphlet" 1182883 1182938 1183830 1183835) (|LinearOrdinaryDifferentialOperatorCategory| "bookvol10.2.pamphlet" 1181468 1181518 1182815 1182878) (|LinearOrdinaryDifferentialOperatorCategory&| NIL 1180071 1180124 1181421 1181426) (|LinearOrdinaryDifferentialOperator2| "bookvol10.3.pamphlet" 1179203 1179248 1179656 1179719) (|LinearOrdinaryDifferentialOperator1| "bookvol10.3.pamphlet" 1178462 1178505 1178788 1178851) (|ElementaryFunctionLODESolver| "bookvol10.4.pamphlet" 1177166 1177206 1178452 1178457) (|LocalPowerSeriesCategory| "bookvol10.2.pamphlet" 1175495 1175527 1176996 1177161) (|LinearAggregate| "bookvol10.2.pamphlet" 1171958 1171981 1175475 1175490) (|LinearAggregate&| NIL 1168381 1168407 1171901 1171906) (|ListMonoidOps| "bookvol10.3.pamphlet" 1164982 1165010 1168371 1168376) (|LeftModule| "bookvol10.2.pamphlet" 1164489 1164507 1164972 1164977) (|ListMultiDictionary| "bookvol10.3.pamphlet" 1163529 1163556 1164198 1164250) (|LinearSystemFromPowerSeriesPackage| "bookvol10.4.pamphlet" 1162948 1162994 1163519 1163524) (|List| "bookvol10.3.pamphlet" 1160779 1160791 1162188 1162240) (|ListFunctions3| "bookvol10.4.pamphlet" 1160082 1160108 1160769 1160774) (|ListFunctions2| "bookvol10.4.pamphlet" 1158750 1158774 1160072 1160077) (|ListToMap| "bookvol10.4.pamphlet" 1155606 1155625 1158740 1158745) (|LinearlyExplicitRingOver| "bookvol10.2.pamphlet" 1154955 1154987 1155579 1155601) (|LinearDependence| "bookvol10.4.pamphlet" 1153808 1153834 1154861 1154866) (|RationalFunctionLimitPackage| "bookvol10.4.pamphlet" 1151740 1151776 1153798 1153803) (|PowerSeriesLimitPackage| "bookvol10.4.pamphlet" 1150594 1150628 1151730 1151735) (|AssociatedLieAlgebra| "bookvol10.3.pamphlet" 1148299 1148329 1149577 1149821) (|LieAlgebra| "bookvol10.2.pamphlet" 1147859 1147877 1148208 1148294) (|LieAlgebra&| NIL 1147460 1147481 1147812 1147817) (|Library| "bookvol10.3.pamphlet" 1145803 1145816 1146514 1146542) (|LinGroebnerPackage| "bookvol10.4.pamphlet" 1143169 1143200 1145793 1145798) (|LiouvillianFunction| "bookvol10.4.pamphlet" 1141935 1141964 1143159 1143164) (|LiouvillianFunctionCategory| "bookvol10.2.pamphlet" 1140763 1140796 1141925 1141930) (|LexTriangularPackage| "bookvol10.4.pamphlet" 1136577 1136610 1140753 1140758) (|LieExponentials| "bookvol10.3.pamphlet" 1134792 1134832 1136550 1136572) (|LeadingCoefDetermination| "bookvol10.4.pamphlet" 1133200 1133239 1134782 1134787) (|LazardSetSolvingPackage| "bookvol10.4.pamphlet" 1132289 1132332 1133190 1133195) (|LaurentPolynomial| "bookvol10.3.pamphlet" 1130895 1130923 1131727 1131839) (|LaplaceTransform| "bookvol10.4.pamphlet" 1130430 1130456 1130885 1130890) (|LocalAlgebra| "bookvol10.3.pamphlet" 1129797 1129821 1130319 1130382) (|LeftAlgebra| "bookvol10.2.pamphlet" 1129557 1129576 1129770 1129792) (|LeftAlgebra&| NIL 1129331 1129353 1129547 1129552) (|Kovacic| "bookvol10.4.pamphlet" 1128011 1128029 1129321 1129326) (|ConvertibleTo| "bookvol10.2.pamphlet" 1127724 1127745 1128001 1128006) (|CoercibleTo| "bookvol10.2.pamphlet" 1127452 1127471 1127714 1127719) (|Kernel| "bookvol10.3.pamphlet" 1125951 1125965 1127178 1127183) (|KernelFunctions2| "bookvol10.4.pamphlet" 1125640 1125666 1125941 1125946) (|KeyedDictionary| "bookvol10.2.pamphlet" 1124753 1124788 1125595 1125635) (|KeyedDictionary&| NIL 1123898 1123936 1124743 1124748) (|KeyedAccessFile| "bookvol10.3.pamphlet" 1122370 1122399 1123092 1123144) (|AssociatedJordanAlgebra| "bookvol10.3.pamphlet" 1120051 1120084 1121353 1121597) (|IndexedAggregate| "bookvol10.2.pamphlet" 1118281 1118319 1120031 1120046) (|IndexedAggregate&| NIL 1116334 1116375 1118087 1118092) (|IndexedVector| "bookvol10.3.pamphlet" 1115151 1115177 1115302 1115354) (|InfiniteTuple| "bookvol10.3.pamphlet" 1114260 1114281 1115141 1115146) (|InnerTrigonometricManipulations| "bookvol10.4.pamphlet" 1112998 1113042 1114250 1114255) (|InfiniteTupleFunctions3| "bookvol10.4.pamphlet" 1112483 1112518 1112988 1112993) (|InfiniteTupleFunctions2| "bookvol10.4.pamphlet" 1112206 1112239 1112473 1112478) (|InnerTaylorSeries| "bookvol10.3.pamphlet" 1109896 1109926 1111939 1112155) (|InnerSparseUnivariatePowerSeries| "bookvol10.3.pamphlet" 1102023 1102068 1108639 1108804) (|InnerPolySum| "bookvol10.4.pamphlet" 1101480 1101506 1102013 1102018) (|IndexedString| "bookvol10.3.pamphlet" 1100477 1100501 1100654 1100706) (|InternalRationalUnivariateRepresentationPackage| "bookvol10.4.pamphlet" 1099427 1099491 1100467 1100472) (|IrrRepSymNatPackage| "bookvol10.4.pamphlet" 1097478 1097503 1099417 1099422) (|IntegrationResultRFToFunction| "bookvol10.4.pamphlet" 1095982 1096019 1097418 1097423) (|IrredPolyOverFiniteField| "bookvol10.4.pamphlet" 1095561 1095594 1095972 1095977) (|IntegerRoots| "bookvol10.4.pamphlet" 1093867 1093887 1095551 1095556) (|IntegrationResult| "bookvol10.3.pamphlet" 1091525 1091550 1093668 1093712) (|IntegrationResultFunctions2| "bookvol10.4.pamphlet" 1090648 1090685 1091515 1091520) (|IntegrationResultToFunction| "bookvol10.4.pamphlet" 1089804 1089841 1090638 1090643) (|InternalPrintPackage| "bookvol10.4.pamphlet" 1089562 1089588 1089794 1089799) (|InnerPrimeField| "bookvol10.3.pamphlet" 1089139 1089164 1089256 1089421) (|InnerPAdicInteger| "bookvol10.3.pamphlet" 1088852 1088893 1089022 1089134) (|InverseLaplaceTransform| "bookvol10.4.pamphlet" 1088432 1088465 1088842 1088847) (|TranscendentalIntegration| "bookvol10.4.pamphlet" 1081435 1081471 1088422 1088427) (|IntegrationTools| "bookvol10.4.pamphlet" 1079138 1079164 1080857 1080862) (|IntegerSolveLinearPolynomialEquation| "bookvol10.4.pamphlet" 1078424 1078466 1079128 1079133) (|Interval| "bookvol10.3.pamphlet" 1078143 1078159 1078287 1078419) (|RationalFunctionIntegration| "bookvol10.4.pamphlet" 1076486 1076521 1078133 1078138) (|IntegerRetractions| "bookvol10.4.pamphlet" 1075963 1075989 1076476 1076481) (|RationalIntegration| "bookvol10.4.pamphlet" 1074619 1074649 1075953 1075958) (|PatternMatchIntegration| "bookvol10.4.pamphlet" 1072790 1072823 1074137 1074142) (|PureAlgebraicIntegration| "bookvol10.4.pamphlet" 1070389 1070425 1072682 1072687) (|AnnaNumericalIntegrationPackage| "bookvol10.4.pamphlet" 1060885 1060922 1070379 1070384) (|Integer| "bookvol10.3.pamphlet" 1060131 1060144 1060629 1060880) (|TranscendentalHermiteIntegration| "bookvol10.4.pamphlet" 1059371 1059414 1060121 1060126) (|AlgebraicHermiteIntegration| "bookvol10.4.pamphlet" 1058995 1059040 1059361 1059366) (|IntegerNumberTheoryFunctions| "bookvol10.4.pamphlet" 1055348 1055382 1058985 1058990) (|GenusZeroIntegration| "bookvol10.4.pamphlet" 1048452 1048484 1055240 1055245) (|IntegrationFunctionsTable| "bookvol10.3.pamphlet" 1042427 1042458 1048442 1048447) (|InterpolateFormsPackage| "bookvol10.4.pamphlet" 1041558 1041636 1042417 1042422) (|IntegerFactorizationPackage| "bookvol10.4.pamphlet" 1040619 1040654 1041548 1041553) (|InterfaceGroebnerPackage| "bookvol10.4.pamphlet" 1040465 1040511 1040609 1040614) (|ElementaryIntegration| "bookvol10.4.pamphlet" 1038808 1038839 1040455 1040460) (|IntegralDomain| "bookvol10.2.pamphlet" 1037405 1037425 1038691 1038803) (|IntegralDomain&| NIL 1036106 1036129 1037395 1037400) (|IntersectionDivisorPackage| "bookvol10.4.pamphlet" 1035228 1035339 1036096 1036101) (|IntervalCategory| "bookvol10.2.pamphlet" 1033784 1033808 1035091 1035223) (|IntegerBits| "bookvol10.4.pamphlet" 1033306 1033323 1033774 1033779) (|AlgebraicIntegrate| "bookvol10.4.pamphlet" 1032452 1032491 1033296 1033301) (|AlgebraicIntegration| "bookvol10.4.pamphlet" 1031914 1031944 1032442 1032447) (|InnerTable| "bookvol10.3.pamphlet" 1030830 1030869 1031001 1031053) (|IntegerNumberSystem| "bookvol10.2.pamphlet" 1028068 1028093 1030653 1030825) (|IntegerNumberSystem&| NIL 1025470 1025498 1028058 1028063) (|InnerPolySign| "bookvol10.4.pamphlet" 1024907 1024931 1025460 1025465) (|InfiniteProductPrimeField| "bookvol10.4.pamphlet" 1023980 1024022 1024897 1024902) (|InfiniteProductFiniteField| "bookvol10.4.pamphlet" 1023044 1023092 1023970 1023975) (|InnerMultFact| "bookvol10.4.pamphlet" 1022039 1022067 1023034 1023039) (|InnerModularGcd| "bookvol10.4.pamphlet" 1021183 1021226 1022029 1022034) (|InnerNumericFloatSolvePackage| "bookvol10.4.pamphlet" 1019505 1019550 1021173 1021178) (|InfiniteProductCharacteristicZero| "bookvol10.4.pamphlet" 1018554 1018604 1019495 1019500) (|InputForm| "bookvol10.3.pamphlet" 1015468 1015483 1018544 1018549) (|InputFormFunctions1| "bookvol10.4.pamphlet" 1015096 1015123 1015458 1015463) (|Infinity| "bookvol10.4.pamphlet" 1014678 1014692 1015086 1015091) (|InfinitlyClosePoint| "bookvol10.3.pamphlet" 1014078 1014158 1014668 1014673) (|InfinitlyClosePointOverPseudoAlgebraicClosureOfFiniteField| "bookvol10.3.pamphlet" 1013464 1013543 1014068 1014073) (|InfinitlyClosePointCategory| "bookvol10.2.pamphlet" 1012092 1012180 1013454 1013459) (|InnerNumericEigenPackage| "bookvol10.4.pamphlet" 1010618 1010658 1012082 1012087) (|IndexedExponents| "bookvol10.3.pamphlet" 1010510 1010541 1010608 1010613) (|IncrementingMaps| "bookvol10.4.pamphlet" 1009913 1009937 1010500 1010505) (|InnerNormalBasisFieldFunctions| "bookvol10.4.pamphlet" 1005779 1005818 1009903 1009908) (|IndexedMatrix| "bookvol10.3.pamphlet" 1004804 1004841 1005327 1005379) (|InnerMatrixQuotientFieldFunctions| "bookvol10.4.pamphlet" 1003852 1003927 1004747 1004752) (|InnerMatrixLinearAlgebraFunctions| "bookvol10.4.pamphlet" 1002421 1002476 1003795 1003800) (|IndexedList| "bookvol10.3.pamphlet" 1001175 1001199 1001703 1001755) (|InnerIndexedTwoDimensionalArray| "bookvol10.3.pamphlet" 1000824 1000891 1000958 1001010) (|InnerFiniteField| "bookvol10.3.pamphlet" 1000044 1000074 1000309 1000474) (|IndexedFlexibleArray| "bookvol10.3.pamphlet" 997135 997168 999326 999378) (|InnerFreeAbelianMonoid| "bookvol10.3.pamphlet" 996935 996972 997073 997078) (|InnerEvalable| "bookvol10.2.pamphlet" 996321 996344 996925 996930) (|InnerEvalable&| NIL 995704 995730 996311 996316) (|IndexedDirectProductObject| "bookvol10.3.pamphlet" 995493 995529 995694 995699) (|IndexedDirectProductOrderedAbelianMonoidSup| "bookvol10.3.pamphlet" 995225 995278 995483 995488) (|IndexedDirectProductOrderedAbelianMonoid| "bookvol10.3.pamphlet" 994922 994972 995215 995220) (|IndexedDirectProductCategory| "bookvol10.2.pamphlet" 993834 993872 994912 994917) (|IndexedDirectProductAbelianMonoid| "bookvol10.3.pamphlet" 993563 993606 993824 993829) (|IndexedDirectProductAbelianGroup| "bookvol10.3.pamphlet" 993295 993337 993553 993558) (|IdealDecompositionPackage| "bookvol10.4.pamphlet" 990544 990585 993285 993290) (|PolynomialIdeals| "bookvol10.3.pamphlet" 985600 985649 990465 990470) (|InfClsPt| "bookvol10.3.pamphlet" 985051 985080 985590 985595) (|InnerCommonDenominator| "bookvol10.4.pamphlet" 984264 984300 985041 985046) (|IndexCard| "bookvol10.3.pamphlet" 983540 983555 984254 984259) (|IntegralBasisPolynomialTools| "bookvol10.4.pamphlet" 982157 982200 983530 983535) (|IndexedBits| "bookvol10.3.pamphlet" 981314 981336 981735 981787) (|IntegralBasisTools| "bookvol10.4.pamphlet" 978229 978260 981304 981309) (|ChineseRemainderToolsForIntegralBases| "bookvol10.4.pamphlet" 977104 977154 978219 978224) (|IndexedTwoDimensionalArray| "bookvol10.3.pamphlet" 976764 976814 976887 976939) (|IndexedOneDimensionalArray| "bookvol10.3.pamphlet" 975929 975968 976046 976098) (|InnerAlgebraicNumber| "bookvol10.3.pamphlet" 974046 974072 975657 975822) (|InnerAlgFactor| "bookvol10.4.pamphlet" 973595 973636 974036 974041) (|HyperbolicFunctionCategory| "bookvol10.2.pamphlet" 972949 972981 973585 973590) (|HyperbolicFunctionCategory&| NIL 972300 972335 972939 972944) (|HTMLFormat| "bookvol10.3.pamphlet" 971144 971160 972290 972295) (|HomogeneousAggregate| "bookvol10.2.pamphlet" 968920 968948 971124 971139) (|HomogeneousAggregate&| NIL 966497 966528 968704 968709) (|HexadecimalExpansion| "bookvol10.3.pamphlet" 963635 963661 964251 964416) (|HeuGcd| "bookvol10.4.pamphlet" 962583 962598 963625 963630) (|HyperellipticFiniteDivisor| "bookvol10.3.pamphlet" 962195 962239 962573 962578) (|Heap| "bookvol10.3.pamphlet" 958283 958295 961978 962030) (|HomogeneousDirectProduct| "bookvol10.3.pamphlet" 948065 948103 948447 948651) (|HomogeneousDistributedMultivariatePolynomial| "bookvol10.3.pamphlet" 944234 944291 944875 945109) (|HallBasis| "bookvol10.4.pamphlet" 942823 942838 944224 944229) (|HashTable| "bookvol10.3.pamphlet" 941694 941732 941910 941962) (|Pi| "bookvol10.3.pamphlet" 941233 941241 941524 941689) (|GuessUnivariatePolynomial| "bookvol10.4.pamphlet" 927307 927342 941223 941228) (|GuessPolynomial| "bookvol10.4.pamphlet" 926981 927002 927094 927099) (|Guess| "bookvol10.4.pamphlet" 911246 911288 926825 926830) (|GuessInteger| "bookvol10.4.pamphlet" 910955 910973 911063 911068) (|GuessFinite| "bookvol10.4.pamphlet" 910758 910777 910876 910881) (|GuessFiniteFunctions| "bookvol10.4.pamphlet" 910621 910649 910748 910753) (|GuessAlgebraicNumber| "bookvol10.4.pamphlet" 910409 910435 910527 910532) (|GeneralTriangularSet| "bookvol10.3.pamphlet" 909526 909560 910030 910082) (|GeneralSparseTable| "bookvol10.3.pamphlet" 908449 908500 908637 908665) (|GeneralUnivariatePowerSeries| "bookvol10.3.pamphlet" 905126 905179 906111 906363) (|Group| "bookvol10.2.pamphlet" 904094 904105 905099 905121) (|Group&| NIL 903076 903090 904084 904089) (|GroebnerSolve| "bookvol10.4.pamphlet" 901660 901688 903066 903071) (|GradedModule| "bookvol10.2.pamphlet" 900290 900312 901650 901655) (|GradedModule&| NIL 898917 898942 900280 900285) (|GraphImage| "bookvol10.3.pamphlet" 891948 891964 898907 898912) (|GraphicsDefaults| "bookvol10.4.pamphlet" 890329 890351 891938 891943) (|GrayCode| "bookvol10.4.pamphlet" 888864 888878 890319 890324) (|Graphviz| "bookvol10.4.pamphlet" 887688 887702 888854 888859) (|GradedAlgebra| "bookvol10.2.pamphlet" 886880 886903 887678 887683) (|GradedAlgebra&| NIL 886069 886095 886870 886875) (|GeneralPolynomialSet| "bookvol10.3.pamphlet" 885500 885541 885730 885782) (|GeneralPackageForAlgebraicFunctionField| "bookvol10.4.pamphlet" 880233 880357 885452 885457) (|GosperSummationMethod| "bookvol10.4.pamphlet" 879483 879520 880223 880228) (|GuessOption| "bookvol10.3.pamphlet" 873767 873784 879473 879478) (|GuessOptionFunctions0| "bookvol10.3.pamphlet" 870163 870190 873757 873762) (|GeneralModulePolynomial| "bookvol10.3.pamphlet" 869242 869290 870114 870158) (|GeneralHenselPackage| "bookvol10.4.pamphlet" 868396 868428 869232 869237) (|GenerateUnivariatePowerSeries| "bookvol10.4.pamphlet" 864182 864222 868386 868391) (|GenUFactorize| "bookvol10.4.pamphlet" 863775 863796 864172 864177) (|GeneralPolynomialGcdPackage| "bookvol10.4.pamphlet" 863400 863442 863765 863770) (|GeneralizedMultivariateFactorize| "bookvol10.4.pamphlet" 862837 862886 863390 863395) (|GenExEuclid| "bookvol10.4.pamphlet" 861310 861332 862827 862832) (|GnuDraw| "bookvol10.4.pamphlet" 859770 859783 861300 861305) (|GeneralDistributedMultivariatePolynomial| "bookvol10.3.pamphlet" 855789 855844 856580 856814) (|GenericNonAssociativeAlgebra| "bookvol10.3.pamphlet" 849629 849682 855478 855595) (|GcdDomain| "bookvol10.2.pamphlet" 848533 848548 849512 849624) (|GcdDomain&| NIL 847541 847559 848523 848528) (|GroebnerPackage| "bookvol10.4.pamphlet" 843072 843123 847494 847499) (|GroebnerInternalPackage| "bookvol10.4.pamphlet" 839149 839208 843062 843067) (|GroebnerFactorizationPackage| "bookvol10.4.pamphlet" 834588 834652 839139 839144) (|EuclideanGroebnerBasisPackage| "bookvol10.4.pamphlet" 831214 831279 834578 834583) (|GaussianFactorizationPackage| "bookvol10.4.pamphlet" 830511 830545 831204 831209) (|GaloisGroupUtilities| "bookvol10.4.pamphlet" 828802 828830 830450 830455) (|GaloisGroupPolynomialUtilities| "bookvol10.4.pamphlet" 827241 827282 828792 828797) (|GaloisGroupFactorizationUtilities| "bookvol10.4.pamphlet" 825419 825465 827231 827236) (|GaloisGroupFactorizer| "bookvol10.4.pamphlet" 815838 815868 825409 825414) (|FortranVectorFunctionCategory| "bookvol10.2.pamphlet" 812754 812789 815818 815833) (|FortranVectorCategory| "bookvol10.2.pamphlet" 811779 811806 812734 812749) (|FunctionCalled| "bookvol10.3.pamphlet" 811616 811640 811769 811774) (|FortranType| "bookvol10.3.pamphlet" 809839 809856 811606 811611) (|FortranTemplate| "bookvol10.3.pamphlet" 808997 809018 809829 809834) (|FunctionSpaceUnivariatePolynomialFactor| "bookvol10.4.pamphlet" 807986 808038 808909 808914) (|FortranScalarType| "bookvol10.3.pamphlet" 806115 806138 807976 807981) (|FunctionSpaceReduce| "bookvol10.4.pamphlet" 805526 805555 806105 806110) (|FunctionSpacePrimitiveElement| "bookvol10.4.pamphlet" 804340 804379 805460 805465) (|FunctionalSpecialFunction| "bookvol10.4.pamphlet" 801608 801643 804330 804335) (|FunctionSpace| "bookvol10.2.pamphlet" 795360 795381 801224 801603) (|FunctionSpace&| NIL 788919 788943 794786 794791) (|FunctionSpaceIntegration| "bookvol10.4.pamphlet" 788517 788551 788909 788914) (|FourierSeries| "bookvol10.3.pamphlet" 787766 787789 788269 788424) (|FunctionSpaceComplexIntegration| "bookvol10.4.pamphlet" 787005 787046 787756 787761) (|FiniteSetAggregate| "bookvol10.2.pamphlet" 786125 786151 786908 787000) (|FiniteSetAggregate&| NIL 785247 785276 786033 786038) (|FiniteSetAggregateFunctions2| "bookvol10.4.pamphlet" 783964 784006 785237 785242) (|FunctionSpaceToUnivariatePowerSeries| "bookvol10.4.pamphlet" 778421 778489 783954 783959) (|FunctionSpaceFunctions2| "bookvol10.4.pamphlet" 778012 778049 778411 778416) (|FunctionSpaceToExponentialExpansion| "bookvol10.4.pamphlet" 777142 777198 778002 778007) (|FactoredFunctionUtilities| "bookvol10.4.pamphlet" 776119 776152 777132 777137) (|Factored| "bookvol10.3.pamphlet" 767823 767839 774877 774989) (|FramedNonAssociativeAlgebra| "bookvol10.2.pamphlet" 762945 762980 767729 767818) (|FramedNonAssociativeAlgebra&| NIL 758111 758149 762898 762903) (|FramedNonAssociativeAlgebraFunctions2| "bookvol10.4.pamphlet" 757524 757577 758101 758106) (|FramedModule| "bookvol10.3.pamphlet" 756918 756954 757445 757450) (|FractionalIdeal| "bookvol10.3.pamphlet" 756135 756165 756891 756913) (|FractionalIdealFunctions2| "bookvol10.4.pamphlet" 755850 755905 756125 756130) (|FullyRetractableTo| "bookvol10.2.pamphlet" 755508 755534 755840 755845) (|FullyRetractableTo&| NIL 754995 755024 755330 755335) (|FramedAlgebra| "bookvol10.2.pamphlet" 753366 753390 754927 754990) (|FramedAlgebra&| NIL 751792 751819 753356 753361) (|Fraction| "bookvol10.3.pamphlet" 748044 748060 748435 748729) (|FractionFunctions2| "bookvol10.4.pamphlet" 747641 747669 748034 748039) (|FactoredFunctions2| "bookvol10.4.pamphlet" 746983 747011 747631 747636) (|FloatingPointSystem| "bookvol10.2.pamphlet" 743835 743860 746793 746978) (|FloatingPointSystem&| NIL 740765 740793 743726 743731) (|FieldOfPrimeCharacteristic| "bookvol10.2.pamphlet" 739723 739755 740595 740760) (|FieldOfPrimeCharacteristic&| NIL 738838 738873 739713 739718) (|FullyPatternMatchable| "bookvol10.2.pamphlet" 738571 738600 738818 738833) (|FullPartialFractionExpansion| "bookvol10.3.pamphlet" 737299 737338 738561 738566) (|FortranProgram| "bookvol10.3.pamphlet" 735771 735833 737289 737294) (|FortranPackage| "bookvol10.4.pamphlet" 734708 734728 735761 735766) (|FortranFunctionCategory| "bookvol10.2.pamphlet" 731777 731806 734688 734703) (|FortranProgramCategory| "bookvol10.2.pamphlet" 731460 731488 731757 731772) (|ScriptFormulaFormat| "bookvol10.3.pamphlet" 728837 728862 731450 731455) (|ScriptFormulaFormat1| "bookvol10.4.pamphlet" 728298 728326 728827 728832) (|FindOrderFinite| "bookvol10.4.pamphlet" 728070 728103 728288 728293) (|FortranOutputStackPackage| "bookvol10.4.pamphlet" 727248 727279 728060 728065) (|FreeNilpotentLie| "bookvol10.3.pamphlet" 726639 726675 727199 727243) (|FileNameCategory| "bookvol10.2.pamphlet" 724969 724991 726629 726634) (|FileName| "bookvol10.3.pamphlet" 724855 724869 724959 724964) (|FortranMachineTypeCategory| "bookvol10.2.pamphlet" 724586 724618 724738 724850) (|FreeMonoid| "bookvol10.3.pamphlet" 721340 721358 724534 724539) (|FreeModule| "bookvol10.3.pamphlet" 721005 721025 721244 721288) (|FortranMatrixFunctionCategory| "bookvol10.2.pamphlet" 717928 717963 720985 721000) (|FortranMatrixCategory| "bookvol10.2.pamphlet" 716953 716980 717908 717923) (|FreeModuleCat| "bookvol10.2.pamphlet" 714619 714648 716904 716948) (|FreeModule1| "bookvol10.3.pamphlet" 714042 714063 714523 714567) (|FloatingRealPackage| "bookvol10.4.pamphlet" 711833 711864 714032 714037) (|Float| "bookvol10.3.pamphlet" 708626 708637 711590 711828) (|FloatingComplexPackage| "bookvol10.4.pamphlet" 706072 706106 708616 708621) (|FullyLinearlyExplicitRingOver| "bookvol10.2.pamphlet" 705740 705777 706045 706067) (|FullyLinearlyExplicitRingOver&| NIL 705341 705381 705649 705654) (|FiniteLinearAggregateSort| "bookvol10.4.pamphlet" 704574 704609 705331 705336) (|FreeLieAlgebra| "bookvol10.2.pamphlet" 702612 702643 704483 704569) (|FiniteLinearAggregate| "bookvol10.2.pamphlet" 699787 699816 702568 702607) (|FiniteLinearAggregate&| NIL 696857 696889 699641 699646) (|FiniteLinearAggregateFunctions2| "bookvol10.4.pamphlet" 695549 695594 696847 696852) (|FiniteRankAlgebra| "bookvol10.2.pamphlet" 693631 693659 695481 695544) (|FiniteRankAlgebra&| NIL 691624 691655 693477 693482) (|Finite| "bookvol10.2.pamphlet" 690615 690627 691614 691619) (|Finite&| NIL 689603 689618 690605 690610) (|FiniteRankNonAssociativeAlgebra| "bookvol10.2.pamphlet" 678887 678926 689509 689598) (|FiniteRankNonAssociativeAlgebra&| NIL 668206 668248 678831 678836) (|File| "bookvol10.3.pamphlet" 667791 667803 668196 668201) (|FileCategory| "bookvol10.2.pamphlet" 666228 666255 667781 667786) (|Field| "bookvol10.2.pamphlet" 665491 665502 666058 666223) (|Field&| NIL 664911 664925 665481 665486) (|FreeGroup| "bookvol10.3.pamphlet" 663438 663455 664884 664906) (|FGLMIfCanPackage| "bookvol10.4.pamphlet" 662331 662360 663428 663433) (|FiniteFieldExtension| "bookvol10.3.pamphlet" 661611 661644 661916 662081) (|FiniteFieldSquareFreeDecomposition| "bookvol10.4.pamphlet" 661452 661501 661601 661606) (|FiniteFieldSolveLinearPolynomialEquation| "bookvol10.4.pamphlet" 660921 660976 661442 661447) (|FiniteFieldPolynomialPackage| "bookvol10.4.pamphlet" 652294 652331 660911 660916) (|FiniteFieldPolynomialPackage2| "bookvol10.4.pamphlet" 651353 651393 652284 652289) (|FiniteFieldExtensionByPolynomial| "bookvol10.3.pamphlet" 650688 650738 650938 651103) (|FiniteField| "bookvol10.3.pamphlet" 649976 650001 650198 650363) (|FiniteFieldNormalBasisExtension| "bookvol10.3.pamphlet" 648366 648415 649561 649726) (|FiniteFieldNormalBasisExtensionByPolynomial| "bookvol10.3.pamphlet" 646730 646788 647951 648116) (|FiniteFieldNormalBasis| "bookvol10.3.pamphlet" 645080 645121 646240 646405) (|FunctionFieldIntegralBasis| "bookvol10.4.pamphlet" 642430 642469 645070 645075) (|FiniteFieldCategory| "bookvol10.2.pamphlet" 639939 639964 642260 642425) (|FiniteFieldCategory&| NIL 637605 637633 639929 639934) (|FiniteFieldHomomorphisms| "bookvol10.4.pamphlet" 636376 636415 637595 637600) (|FiniteFieldFunctions| "bookvol10.4.pamphlet" 633833 633862 636366 636371) (|FractionFreeFastGaussian| "bookvol10.4.pamphlet" 627937 627971 633823 633828) (|FractionFreeFastGaussianFractions| "bookvol10.4.pamphlet" 626585 626631 627927 627932) (|FiniteFieldFactorizationWithSizeParseBySideEffect| "bookvol10.4.pamphlet" 625957 626021 626575 626580) (|FiniteFieldFactorization| "bookvol10.4.pamphlet" 625856 625895 625947 625952) (|FiniteFieldCyclicGroupExtension| "bookvol10.3.pamphlet" 624577 624626 625441 625606) (|FiniteFieldCyclicGroupExtensionByPolynomial| "bookvol10.3.pamphlet" 623320 623381 624162 624327) (|FiniteFieldCyclicGroup| "bookvol10.3.pamphlet" 621956 621997 622830 622995) (|FunctionFieldCategory| "bookvol10.2.pamphlet" 610647 610684 621696 621951) (|FunctionFieldCategory&| NIL 599508 599548 610560 610565) (|FunctionFieldCategoryFunctions2| "bookvol10.4.pamphlet" 599218 599287 599498 599503) (|FortranExpression| "bookvol10.3.pamphlet" 591811 591872 598906 598969) (|FullyEvalableOver| "bookvol10.2.pamphlet" 591506 591531 591801 591806) (|FullyEvalableOver&| NIL 590960 590988 591258 591263) (|FiniteDivisor| "bookvol10.3.pamphlet" 590404 590435 590950 590955) (|FiniteDivisorCategory| "bookvol10.2.pamphlet" 588401 588440 590394 590399) (|FiniteDivisorCategory&| NIL 586395 586437 588391 588396) (|FiniteDivisorFunctions2| "bookvol10.4.pamphlet" 586120 586181 586385 586390) (|FortranCodePackage1| "bookvol10.4.pamphlet" 584664 584689 586110 586115) (|FourierComponent| "bookvol10.3.pamphlet" 584181 584205 584654 584659) (|FortranCode| "bookvol10.3.pamphlet" 574137 574154 584171 584176) (|FiniteAlgebraicExtensionField| "bookvol10.2.pamphlet" 567319 567356 573967 574132) (|FiniteAlgebraicExtensionField&| NIL 560620 560660 567271 567276) (|FlexibleArray| "bookvol10.3.pamphlet" 558913 558934 559902 559954) (|FiniteAbelianMonoidRing| "bookvol10.2.pamphlet" 556966 556999 558743 558908) (|FiniteAbelianMonoidRing&| NIL 555038 555074 556818 556823) (|FiniteAbelianMonoidRingFunctions2| "bookvol10.4.pamphlet" 554581 554634 555028 555033) (|FreeAbelianMonoid| "bookvol10.3.pamphlet" 554189 554214 554501 554506) (|FreeAbelianMonoidCategory| "bookvol10.2.pamphlet" 552349 552384 554179 554184) (|FreeAbelianGroup| "bookvol10.3.pamphlet" 551901 551925 552197 552241) (|FactoringUtilities| "bookvol10.4.pamphlet" 550097 550130 551891 551896) (|FactorisationOverPseudoAlgebraicClosureOfRationalNumber| "bookvol10.4.pamphlet" 549926 549989 550087 550092) (|FactoredFunctions| "bookvol10.4.pamphlet" 549105 549130 549916 549921) (|FactorisationOverPseudoAlgebraicClosureOfAlgExtOfRationalNumber| "bookvol10.4.pamphlet" 548926 548997 549095 549100) (|ExponentialOfUnivariatePuiseuxSeries| "bookvol10.3.pamphlet" 545259 545316 546588 546840) (|ExpressionTubePlot| "bookvol10.4.pamphlet" 542711 542735 545249 545254) (|ExpressionSolve| "bookvol10.4.pamphlet" 542604 542642 542701 542706) (|ExpressionSpaceODESolver| "bookvol10.4.pamphlet" 539330 539364 542594 542599) (|Expression| "bookvol10.3.pamphlet" 533411 533429 534141 534764) (|ExpressionToUnivariatePowerSeries| "bookvol10.4.pamphlet" 529470 529514 533401 533406) (|ExpressionFunctions2| "bookvol10.4.pamphlet" 529222 529252 529460 529465) (|ExponentialExpansion| "bookvol10.3.pamphlet" 524154 524197 524810 524975) (|Export3D| "bookvol10.4.pamphlet" 524001 524015 524144 524149) (|Exit| "bookvol10.3.pamphlet" 523670 523680 523991 523996) (|EvaluateCycleIndicators| "bookvol10.4.pamphlet" 523147 523178 523660 523665) (|Evalable| "bookvol10.2.pamphlet" 522705 522721 523137 523142) (|Evalable&| NIL 522260 522279 522695 522700) (|EuclideanDomain| "bookvol10.2.pamphlet" 519776 519797 522143 522255) (|EuclideanDomain&| NIL 517396 517420 519766 519771) (|ExpertSystemToolsPackage| "bookvol10.4.pamphlet" 509232 509262 517386 517391) (|ExpertSystemToolsPackage2| "bookvol10.4.pamphlet" 508804 508841 509222 509227) (|ExpertSystemToolsPackage1| "bookvol10.4.pamphlet" 508466 508500 508794 508799) (|ExpressionSpace| "bookvol10.2.pamphlet" 501400 501421 508456 508461) (|ExpressionSpace&| NIL 494223 494247 501282 501287) (|ExpertSystemContinuityPackage| "bookvol10.4.pamphlet" 491005 491040 494213 494218) (|ExpertSystemContinuityPackage1| "bookvol10.4.pamphlet" 490718 490758 490995 491000) (|ExpressionSpaceFunctions2| "bookvol10.4.pamphlet" 490206 490241 490708 490713) (|ExpressionSpaceFunctions1| "bookvol10.4.pamphlet" 489745 489780 490196 490201) (|ErrorFunctions| "bookvol10.4.pamphlet" 487209 487229 489735 489740) (|EqTable| "bookvol10.3.pamphlet" 486082 486109 486296 486348) (|Equation| "bookvol10.3.pamphlet" 480557 480573 483310 483449) (|EquationFunctions2| "bookvol10.4.pamphlet" 480259 480287 480547 480552) (|EigenPackage| "bookvol10.4.pamphlet" 476603 476623 480249 480254) (|EntireRing| "bookvol10.2.pamphlet" 476104 476120 476512 476598) (|EuclideanModularRing| "bookvol10.3.pamphlet" 475231 475298 475987 476099) (|EltableAggregate| "bookvol10.2.pamphlet" 473673 473706 475221 475226) (|EltableAggregate&| NIL 472065 472101 473616 473621) (|Eltable| "bookvol10.2.pamphlet" 471592 471615 472055 472060) (|EllipticFunctionsUnivariateTaylorSeries| "bookvol10.4.pamphlet" 470944 471000 471582 471587) (|ElementaryFunctionCategory| "bookvol10.2.pamphlet" 470617 470649 470934 470939) (|ElementaryFunctionCategory&| NIL 470287 470322 470607 470612) (|ExtensibleLinearAggregate| "bookvol10.2.pamphlet" 468167 468200 470242 470282) (|ExtensibleLinearAggregate&| NIL 465992 466028 468070 468075) (|ElementaryFunctionsUnivariatePuiseuxSeries| "bookvol10.3.pamphlet" 462724 462794 465945 465950) (|ElementaryFunctionsUnivariateLaurentSeries| "bookvol10.3.pamphlet" 459517 459580 462677 462682) (|ElementaryFunctionStructurePackage| "bookvol10.4.pamphlet" 457486 457530 459507 459512) (|ElementaryFunction| "bookvol10.4.pamphlet" 452250 452278 457476 457481) (|ExtAlgBasis| "bookvol10.3.pamphlet" 450555 450572 452240 452245) (|e04ucfAnnaType| "bookvol10.3.pamphlet" 450081 450101 450545 450550) (|e04nafAnnaType| "bookvol10.3.pamphlet" 449648 449668 450071 450076) (|e04mbfAnnaType| "bookvol10.3.pamphlet" 449218 449238 449638 449643) (|e04jafAnnaType| "bookvol10.3.pamphlet" 448744 448764 449208 449213) (|e04gcfAnnaType| "bookvol10.3.pamphlet" 448270 448290 448734 448739) (|e04fdfAnnaType| "bookvol10.3.pamphlet" 447796 447816 448260 448265) (|e04dgfAnnaType| "bookvol10.3.pamphlet" 447322 447342 447786 447791) (|e04AgentsPackage| "bookvol10.4.pamphlet" 443050 443072 447312 447317) (|DifferentialVariableCategory| "bookvol10.2.pamphlet" 439773 439809 443040 443045) (|DifferentialVariableCategory&| NIL 436493 436532 439763 439768) (|DesingTreePackage| "bookvol10.4.pamphlet" 433563 433665 436483 436488) (|DesingTree| "bookvol10.3.pamphlet" 432714 432732 433346 433398) (|DesingTreeCategory| "bookvol10.2.pamphlet" 432267 432293 432645 432709) (|DifferentialSparseMultivariatePolynomial| "bookvol10.3.pamphlet" 428735 428787 429066 429300) (|DrawOption| "bookvol10.3.pamphlet" 422490 422506 428725 428730) (|DrawOptionFunctions1| "bookvol10.4.pamphlet" 422143 422171 422480 422485) (|DrawOptionFunctions0| "bookvol10.4.pamphlet" 417084 417110 422133 422138) (|TopLevelDrawFunctionsForPoints| "bookvol10.4.pamphlet" 415297 415333 417074 417079) (|TopLevelDrawFunctions| "bookvol10.4.pamphlet" 408186 408218 415287 415292) (|DrawNumericHack| "bookvol10.4.pamphlet" 407436 407459 408176 408181) (|DrawComplex| "bookvol10.4.pamphlet" 404852 404869 407426 407431) (|TopLevelDrawFunctionsForAlgebraicCurves| "bookvol10.4.pamphlet" 404362 404414 404842 404847) (|TopLevelDrawFunctionsForCompiledFunctions| "bookvol10.4.pamphlet" 393763 393810 404352 404357) (|DequeueAggregate| "bookvol10.2.pamphlet" 391934 391958 393694 393758) (|DifferentialPolynomialCategory| "bookvol10.2.pamphlet" 387196 387240 391695 391929) (|DifferentialPolynomialCategory&| NIL 382636 382683 387138 387143) (|DirectProductModule| "bookvol10.3.pamphlet" 374403 374436 374542 374981) (|DirectProductMatrixModule| "bookvol10.3.pamphlet" 366161 366202 366309 366748) (|DistributedMultivariatePolynomial| "bookvol10.3.pamphlet" 362387 362433 362971 363205) (|DiscreteLogarithmPackage| "bookvol10.4.pamphlet" 361705 361737 362377 362382) (|DataList| "bookvol10.3.pamphlet" 360290 360306 360987 361039) (|DoublyLinkedAggregate| "bookvol10.2.pamphlet" 358718 358747 360270 360285) (|DivisionRing| "bookvol10.2.pamphlet" 358114 358132 358627 358713) (|DivisionRing&| NIL 357588 357609 358104 358109) (|Divisor| "bookvol10.3.pamphlet" 357396 357411 357480 357524) (|DivisorCategory| "bookvol10.2.pamphlet" 356131 356154 357347 357391) (|DisplayPackage| "bookvol10.4.pamphlet" 354333 354353 356121 356126) (|DirichletRing| "bookvol10.3.pamphlet" 353494 353520 354061 354281) (|DirectProduct| "bookvol10.3.pamphlet" 343022 343049 343658 343862) (|DirectProductFunctions2| "bookvol10.4.pamphlet" 341862 341901 343012 343017) (|DirectProductCategory| "bookvol10.2.pamphlet" 340701 340736 341641 341857) (|DirectProductCategory&| NIL 339245 339283 340188 340193) (|DiophantineSolutionPackage| "bookvol10.4.pamphlet" 338066 338098 339235 339240) (|DictionaryOperations| "bookvol10.2.pamphlet" 337115 337143 338021 338061) (|DictionaryOperations&| NIL 336150 336181 337059 337064) (|DifferentialRing| "bookvol10.2.pamphlet" 335250 335272 336123 336145) (|DifferentialRing&| NIL 334364 334389 335240 335245) (|DifferentialExtension| "bookvol10.2.pamphlet" 333489 333518 334337 334359) (|DifferentialExtension&| NIL 332499 332531 333350 333355) (|Dictionary| "bookvol10.2.pamphlet" 332098 332116 332454 332494) (|Dictionary&| NIL 331729 331750 332088 332093) (|DenavitHartenbergMatrix| "bookvol10.3.pamphlet" 329894 329925 331277 331329) (|DoubleFloatVector| "bookvol10.3.pamphlet" 328248 328271 328649 328701) (|DoubleFloatSpecialFunctions| "bookvol10.4.pamphlet" 319417 319450 328238 328243) (|DoubleFloatMatrix| "bookvol10.3.pamphlet" 318442 318465 318872 318924) (|DoubleFloat| "bookvol10.3.pamphlet" 314738 314755 318252 318437) (|DefiniteIntegrationTools| "bookvol10.4.pamphlet" 312955 312989 314728 314733) (|DeRhamComplex| "bookvol10.3.pamphlet" 310895 310938 312928 312950) (|Dequeue| "bookvol10.3.pamphlet" 305033 305048 310678 310730) (|DegreeReductionPackage| "bookvol10.4.pamphlet" 304628 304662 305023 305028) (|RationalFunctionDefiniteIntegration| "bookvol10.4.pamphlet" 302060 302103 304618 304623) (|ElementaryFunctionDefiniteIntegration| "bookvol10.4.pamphlet" 300509 300556 302050 302055) (|DecimalExpansion| "bookvol10.3.pamphlet" 297663 297685 298263 298428) (|DistinctDegreeFactorize| "bookvol10.4.pamphlet" 295523 295557 297653 297658) (|DoubleResultantPackage| "bookvol10.4.pamphlet" 295115 295155 295513 295518) (|Database| "bookvol10.3.pamphlet" 293762 293778 295105 295110) (|d03fafAnnaType| "bookvol10.3.pamphlet" 293578 293598 293752 293757) (|d03eefAnnaType| "bookvol10.3.pamphlet" 293386 293406 293568 293573) (|d03AgentsPackage| "bookvol10.4.pamphlet" 292317 292339 293376 293381) (|d02ejfAnnaType| "bookvol10.3.pamphlet" 291769 291789 292307 292312) (|d02cjfAnnaType| "bookvol10.3.pamphlet" 291237 291257 291759 291764) (|d02bhfAnnaType| "bookvol10.3.pamphlet" 290717 290737 291227 291232) (|d02bbfAnnaType| "bookvol10.3.pamphlet" 290197 290217 290707 290712) (|d02AgentsPackage| "bookvol10.4.pamphlet" 285128 285150 290187 290192) (|d01WeightsPackage| "bookvol10.4.pamphlet" 283436 283459 285118 285123) (|d01TransformFunctionType| "bookvol10.3.pamphlet" 283391 283421 283426 283431) (|d01gbfAnnaType| "bookvol10.3.pamphlet" 282903 282923 283381 283386) (|d01fcfAnnaType| "bookvol10.3.pamphlet" 282415 282435 282893 282898) (|d01asfAnnaType| "bookvol10.3.pamphlet" 281873 281893 282405 282410) (|d01aqfAnnaType| "bookvol10.3.pamphlet" 281356 281376 281863 281868) (|d01apfAnnaType| "bookvol10.3.pamphlet" 280826 280846 281346 281351) (|d01anfAnnaType| "bookvol10.3.pamphlet" 280310 280330 280816 280821) (|d01amfAnnaType| "bookvol10.3.pamphlet" 279810 279830 280300 280305) (|d01alfAnnaType| "bookvol10.3.pamphlet" 279340 279360 279800 279805) (|d01akfAnnaType| "bookvol10.3.pamphlet" 278858 278878 279330 279335) (|d01ajfAnnaType| "bookvol10.3.pamphlet" 278371 278391 278848 278853) (|d01AgentsPackage| "bookvol10.4.pamphlet" 274464 274486 278361 278366) (|CyclotomicPolynomialPackage| "bookvol10.4.pamphlet" 273943 273976 274454 274459) (|CycleIndicators| "bookvol10.4.pamphlet" 270741 270762 273933 273938) (|CoerceVectorMatrixPackage| "bookvol10.4.pamphlet" 270103 270136 270731 270736) (|ComplexTrigonometricManipulations| "bookvol10.4.pamphlet" 268544 268587 270093 270098) (|CyclicStreamTools| "bookvol10.4.pamphlet" 267318 267346 268534 268539) (|ComplexRootFindingPackage| "bookvol10.4.pamphlet" 261310 261346 267308 267313) (|CRApackage| "bookvol10.4.pamphlet" 260459 260477 261300 261305) (|ComplexPatternMatch| "bookvol10.4.pamphlet" 259932 259964 260362 260367) (|CharacteristicPolynomialInMonogenicalAlgebra| "bookvol10.4.pamphlet" 259595 259656 259922 259927) (|CoordinateSystems| "bookvol10.4.pamphlet" 254595 254620 259585 259590) (|ContinuedFraction| "bookvol10.3.pamphlet" 250509 250534 254425 254590) (|CommutativeRing| "bookvol10.2.pamphlet" 250143 250164 250415 250504) (|SubSpaceComponentProperty| "bookvol10.3.pamphlet" 249620 249651 250133 250138) (|ComplexPattern| "bookvol10.4.pamphlet" 249375 249402 249610 249615) (|Complex| "bookvol10.3.pamphlet" 241232 241247 241486 241962) (|ComplexFunctions2| "bookvol10.4.pamphlet" 240940 240967 241222 241227) (|ComplexFactorization| "bookvol10.4.pamphlet" 240718 240750 240930 240935) (|ComplexCategory| "bookvol10.2.pamphlet" 238596 238619 240225 240713) (|ComplexCategory&| NIL 236162 236188 237794 237799) (|Comparable| "bookvol10.2.pamphlet" 235893 235909 236152 236157) (|CommuteUnivariatePolynomialCategory| "bookvol10.4.pamphlet" 235634 235685 235883 235888) (|CommonOperators| "bookvol10.4.pamphlet" 235160 235181 235624 235629) (|Commutator| "bookvol10.3.pamphlet" 234961 234977 235150 235155) (|CombinatorialOpsCategory| "bookvol10.2.pamphlet" 233974 234004 234951 234956) (|IntegerCombinatoricFunctions| "bookvol10.4.pamphlet" 232440 232476 233964 233969) (|CombinatorialFunction| "bookvol10.4.pamphlet" 229875 229906 232430 232435) (|Color| "bookvol10.3.pamphlet" 228710 228721 229865 229870) (|ComplexRootPackage| "bookvol10.4.pamphlet" 228028 228061 228700 228705) (|TwoDimensionalPlotClipping| "bookvol10.4.pamphlet" 224124 224156 228018 228023) (|CliffordAlgebra| "bookvol10.3.pamphlet" 222802 222831 224056 224119) (|Collection| "bookvol10.2.pamphlet" 219814 219832 222782 222797) (|Collection&| NIL 216668 216689 219639 219644) (|ComplexIntegerSolveLinearPolynomialEquation| "bookvol10.4.pamphlet" 215966 216020 216658 216663) (|ChangeOfVariable| "bookvol10.4.pamphlet" 213926 213958 215956 215961) (|CharacteristicZero| "bookvol10.2.pamphlet" 213818 213842 213899 213921) (|CharacteristicPolynomialPackage| "bookvol10.4.pamphlet" 213303 213342 213808 213813) (|CharacteristicNonZero| "bookvol10.2.pamphlet" 213030 213057 213276 213298) (|Character| "bookvol10.3.pamphlet" 209384 209399 213020 213025) (|CombinatorialFunctionCategory| "bookvol10.2.pamphlet" 208530 208565 209374 209379) (|Cell| "bookvol10.3.pamphlet" 208494 208515 208520 208525) (|ComplexDoubleFloatVector| "bookvol10.3.pamphlet" 206305 206335 206958 207010) (|ComplexDoubleFloatMatrix| "bookvol10.3.pamphlet" 205193 205223 205639 205691) (|CommonDenominator| "bookvol10.4.pamphlet" 204418 204447 205183 205188) (|CharacterClass| "bookvol10.3.pamphlet" 202612 202632 203682 203762) (|CartesianTensor| "bookvol10.3.pamphlet" 193778 193815 202602 202607) (|CartesianTensorFunctions2| "bookvol10.4.pamphlet" 193145 193195 193768 193773) (|CardinalNumber| "bookvol10.3.pamphlet" 189463 189483 193111 193140) (|CylindricalAlgebraicDecompositionUtilities| "bookvol10.4.pamphlet" 189087 189139 189453 189458) (|CylindricalAlgebraicDecompositionPackage| "bookvol10.4.pamphlet" 189015 189072 189077 189082) (|CachableSet| "bookvol10.2.pamphlet" 188622 188639 189005 189010) (|CancellationAbelianMonoid| "bookvol10.2.pamphlet" 188092 188123 188612 188617) (|BinaryTree| "bookvol10.3.pamphlet" 187129 187147 187875 187927) (|BinaryTournament| "bookvol10.3.pamphlet" 186310 186334 186912 186964) (|BinaryTreeCategory| "bookvol10.2.pamphlet" 185643 185669 186241 186305) (|BinaryTreeCategory&| NIL 185032 185061 185633 185638) (|BitAggregate| "bookvol10.2.pamphlet" 184100 184118 184963 185027) (|BitAggregate&| NIL 183224 183245 184090 184095) (|BinarySearchTree| "bookvol10.3.pamphlet" 181821 181845 183007 183059) (|BasicStochasticDifferential| "bookvol10.3.pamphlet" 179686 179719 181811 181816) (|BrillhartTests| "bookvol10.4.pamphlet" 178447 178470 179676 179681) (|BinaryRecursiveAggregate| "bookvol10.2.pamphlet" 177385 177417 178427 178442) (|BinaryRecursiveAggregate&| NIL 176283 176318 177328 177333) (|BalancedPAdicRational| "bookvol10.3.pamphlet" 173193 173224 173403 173568) (|BalancedPAdicInteger| "bookvol10.3.pamphlet" 172860 172890 173076 173188) (|BoundIntegerRoots| "bookvol10.4.pamphlet" 172507 172535 172850 172855) (|BasicOperator| "bookvol10.3.pamphlet" 168028 168047 172497 172502) (|BasicOperatorFunctions1| "bookvol10.4.pamphlet" 165485 165516 167976 167981) (|Boolean| "bookvol10.3.pamphlet" 164350 164363 165475 165480) (|BiModule| "bookvol10.2.pamphlet" 163971 163989 164301 164345) (|BlowUpPackage| "bookvol10.4.pamphlet" 162238 162285 163961 163966) (|BlowUpWithQuadTrans| "bookvol10.3.pamphlet" 162111 162136 162203 162233) (|BlowUpMethodCategory| "bookvol10.2.pamphlet" 162070 162096 162101 162106) (|BlowUpWithHamburgerNoether| "bookvol10.3.pamphlet" 161938 161970 162037 162065) (|BlasLevelOne| "bookvol10.5.pamphlet" 150200 150218 161928 161933) (|Bits| "bookvol10.3.pamphlet" 149561 149571 149778 149830) (|BinaryFile| "bookvol10.3.pamphlet" 148910 148926 149551 149556) (|BinaryExpansion| "bookvol10.3.pamphlet" 146032 146053 146664 146829) (|BagAggregate| "bookvol10.2.pamphlet" 145254 145274 145987 146027) (|BagAggregate&| NIL 144508 144531 145244 145249) (|BasicFunctions| "bookvol10.3.pamphlet" 143905 143925 144476 144503) (|BezoutMatrix| "bookvol10.4.pamphlet" 143027 143064 143847 143852) (|Bezier| "bookvol10.4.pamphlet" 140886 140900 143017 143022) (|BalancedBinaryTree| "bookvol10.3.pamphlet" 136455 136481 140669 140721) (|BasicType| "bookvol10.2.pamphlet" 136142 136157 136445 136450) (|BasicType&| NIL 135826 135844 136132 136137) (|BalancedFactorisation| "bookvol10.4.pamphlet" 135226 135258 135816 135821) (|AxiomServer| "bookvol10.4.pamphlet" 135077 135094 135216 135221) (|Automorphism| "bookvol10.3.pamphlet" 134504 134524 135050 135072) (|UnitsKnownAttribute| "bookvol10.2.pamphlet" 134282 134307 134484 134499) (|AttributeRegistry| "bookvol10.2.pamphlet" 130635 130658 133835 134277) (|AttributeButtons| "bookvol10.3.pamphlet" 126733 126755 130603 130630) (|ShallowlyMutableAttribute| "bookvol10.2.pamphlet" 126470 126501 126713 126728) (|ArcTrigonometricFunctionCategory| "bookvol10.2.pamphlet" 125909 125947 126460 126465) (|ArcTrigonometricFunctionCategory&| NIL 125345 125386 125899 125904) (|PartiallyOrderedSetAttribute| "bookvol10.2.pamphlet" 125117 125151 125325 125340) (|NoZeroDivisorsAttribute| "bookvol10.2.pamphlet" 124918 124947 125097 125112) (|NullSquareAttribute| "bookvol10.2.pamphlet" 124783 124808 124898 124913) (|NotherianAttribute| "bookvol10.2.pamphlet" 124641 124665 124763 124778) (|MultiplicativeValuationAttribute| "bookvol10.2.pamphlet" 124450 124488 124621 124636) (|LeftUnitaryAttribute| "bookvol10.2.pamphlet" 124293 124319 124430 124445) (|LazyRepresentationAttribute| "bookvol10.2.pamphlet" 124155 124188 124273 124288) (|JacobiIdentityAttribute| "bookvol10.2.pamphlet" 123988 124017 124135 124150) (|FiniteAggregateAttribute| "bookvol10.2.pamphlet" 123849 123879 123968 123983) (|CanonicalUnitNormalAttribute| "bookvol10.2.pamphlet" 123523 123557 123829 123844) (|CommutativeStarAttribute| "bookvol10.2.pamphlet" 123250 123280 123503 123518) (|CentralAttribute| "bookvol10.2.pamphlet" 122931 122953 123230 123245) (|CanonicalAttribute| "bookvol10.2.pamphlet" 122728 122752 122911 122926) (|CanonicalClosedAttribute| "bookvol10.2.pamphlet" 122544 122574 122708 122723) (|ArbitraryPrecisionAttribute| "bookvol10.2.pamphlet" 122374 122407 122524 122539) (|ArbitraryExponentAttribute| "bookvol10.2.pamphlet" 122242 122274 122354 122369) (|ApproximateAttribute| "bookvol10.2.pamphlet" 122131 122157 122222 122237) (|AdditiveValuationAttribute| "bookvol10.2.pamphlet" 121944 121976 122111 122126) (|ArrayStack| "bookvol10.3.pamphlet" 117592 117610 121727 121779) (|AssociatedEquations| "bookvol10.4.pamphlet" 116361 116390 117545 117550) (|Asp9| "bookvol10.3.pamphlet" 115514 115531 116351 116356) (|Asp8| "bookvol10.3.pamphlet" 114453 114470 115504 115509) (|Asp80| "bookvol10.3.pamphlet" 113780 113798 114443 114448) (|Asp7| "bookvol10.3.pamphlet" 112974 112991 113770 113775) (|Asp78| "bookvol10.3.pamphlet" 112448 112466 112964 112969) (|Asp77| "bookvol10.3.pamphlet" 111816 111834 112438 112443) (|Asp74| "bookvol10.3.pamphlet" 110838 110856 111806 111811) (|Asp73| "bookvol10.3.pamphlet" 110096 110114 110828 110833) (|Asp6| "bookvol10.3.pamphlet" 108772 108789 110086 110091) (|Asp55| "bookvol10.3.pamphlet" 107204 107222 108762 108767) (|Asp50| "bookvol10.3.pamphlet" 104855 104873 107194 107199) (|Asp4| "bookvol10.3.pamphlet" 104140 104157 104845 104850) (|Asp49| "bookvol10.3.pamphlet" 103124 103142 104130 104135) (|Asp42| "bookvol10.3.pamphlet" 101396 101439 103114 103119) (|Asp41| "bookvol10.3.pamphlet" 99894 99937 101386 101391) (|Asp35| "bookvol10.3.pamphlet" 98874 98892 99884 99889) (|Asp34| "bookvol10.3.pamphlet" 98120 98138 98864 98869) (|Asp33| "bookvol10.3.pamphlet" 97701 97719 98110 98115) (|Asp31| "bookvol10.3.pamphlet" 96810 96828 97691 97696) (|Asp30| "bookvol10.3.pamphlet" 95537 95555 96800 96805) (|Asp29| "bookvol10.3.pamphlet" 95016 95034 95527 95532) (|Asp28| "bookvol10.3.pamphlet" 85442 85460 95006 95011) (|Asp27| "bookvol10.3.pamphlet" 84293 84311 85432 85437) (|Asp24| "bookvol10.3.pamphlet" 83371 83389 84283 84288) (|Asp20| "bookvol10.3.pamphlet" 82539 82557 83361 83366) (|Asp1| "bookvol10.3.pamphlet" 81915 81932 82529 82534) (|Asp19| "bookvol10.3.pamphlet" 75989 76007 81905 81910) (|Asp12| "bookvol10.3.pamphlet" 75402 75420 75979 75984) (|Asp10| "bookvol10.3.pamphlet" 74678 74696 75392 75397) (|TwoDimensionalArray| "bookvol10.3.pamphlet" 74219 74246 74461 74513) (|OneDimensionalArray| "bookvol10.3.pamphlet" 72993 73020 73501 73553) (|OneDimensionalArrayFunctions2| "bookvol10.4.pamphlet" 71002 71041 72983 72988) (|TwoDimensionalArrayCategory| "bookvol10.2.pamphlet" 64227 64274 70933 70997) (|TwoDimensionalArrayCategory&| NIL 57508 57558 64217 64222) (|ApplyRules| "bookvol10.4.pamphlet" 56819 56846 57498 57503) (|ApplyUnivariateSkewPolynomial| "bookvol10.4.pamphlet" 56394 56435 56809 56814) (|ApplicationProgramInterface| "bookvol10.4.pamphlet" 55305 55338 56384 56389) (|Any| "bookvol10.3.pamphlet" 53651 53660 55295 55300) (|AnyFunctions1| "bookvol10.4.pamphlet" 52716 52737 53641 53646) (|AntiSymm| "bookvol10.3.pamphlet" 51159 51182 52689 52711) (|AnonymousFunction| "bookvol10.3.pamphlet" 51056 51079 51149 51154) (|AlgebraicNumber| "bookvol10.3.pamphlet" 49265 49286 50784 50949) (|AbelianMonoidRing| "bookvol10.2.pamphlet" 47392 47419 49095 49260) (|AbelianMonoidRing&| NIL 45343 45373 47049 47054) (|AssociationList| "bookvol10.3.pamphlet" 43080 43115 43442 43494) (|AlgebraGivenByStructuralConstants| "bookvol10.3.pamphlet" 42104 42162 42901 42990) (|AlgebraPackage| "bookvol10.4.pamphlet" 38043 38067 42047 42052) (|AlgebraicMultFact| "bookvol10.4.pamphlet" 37236 37266 38033 38038) (|AlgebraicManipulations| "bookvol10.4.pamphlet" 34652 34684 36992 36997) (|AlgebraicFunctionField| "bookvol10.3.pamphlet" 32419 32467 32640 32895) (|AlgFactor| "bookvol10.4.pamphlet" 31536 31554 32409 32414) (|Algebra| "bookvol10.2.pamphlet" 31006 31021 31468 31531) (|Algebra&| NIL 30531 30549 30996 31001) (|AssociationListAggregate| "bookvol10.2.pamphlet" 29985 30029 30462 30526) (|ArcHyperbolicFunctionCategory| "bookvol10.2.pamphlet" 29338 29373 29975 29980) (|Aggregate| "bookvol10.2.pamphlet" 27707 27722 29318 29333) (|Aggregate&| NIL 26037 26055 27651 27656) (|AffineSpaceCategory| "bookvol10.2.pamphlet" 23907 23934 26027 26032) (|AlgebraicFunction| "bookvol10.4.pamphlet" 22279 22306 23827 23832) (|AffineSpace| "bookvol10.3.pamphlet" 22112 22137 22269 22274) (|AffinePlaneOverPseudoAlgebraicClosureOfFiniteField| "bookvol10.3.pamphlet" 21912 21970 22102 22107) (|AffinePlane| "bookvol10.3.pamphlet" 21751 21770 21902 21907) (|AffineAlgebraicSetComputeWithResultant| "bookvol10.4.pamphlet" 21597 21672 21741 21746) (|AffineAlgebraicSetComputeWithGroebnerBasis| "bookvol10.4.pamphlet" 21139 21218 21587 21592) (|PlaneAlgebraicCurvePlot| "bookvol10.3.pamphlet" 19405 19434 21129 21134) (|AlgebraicallyClosedFunctionSpace| "bookvol10.2.pamphlet" 17181 17221 19223 19400) (|AlgebraicallyClosedFunctionSpace&| NIL 15126 15169 17171 17176) (|AlgebraicallyClosedField| "bookvol10.2.pamphlet" 10185 10215 14956 15121) (|AlgebraicallyClosedField&| NIL 5401 5434 10175 10180) (|AbelianSemiGroup| "bookvol10.2.pamphlet" 4744 4766 5391 5396) (|AbelianSemiGroup&| NIL 4084 4109 4734 4739) (|AbelianMonoid| "bookvol10.2.pamphlet" 3441 3460 4074 4079) (|AbelianMonoid&| NIL 2795 2817 3431 3436) (|AbelianGroup| "bookvol10.2.pamphlet" 2290 2308 2785 2790) (|AbelianGroup&| NIL 1782 1803 2280 2285) (|OneDimensionalArrayAggregate| "bookvol10.2.pamphlet" 878 914 1713 1777) (|OneDimensionalArrayAggregate&| NIL 30 69 868 873)) 