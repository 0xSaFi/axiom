\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp g-opt.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{chunk}{*}

(IN-PACKAGE "BOOT" )

;--% OPTIMIZER
;
;optimizeFunctionDef(def) ==
;  if $reportOptimization then
;    sayBrightlyI bright '"Original LISP code:"
;    pp def
;
;  def' := optimize COPY def
;
;  if $reportOptimization then
;    sayBrightlyI bright '"Optimized LISP code:"
;    pp def'
;    sayBrightlyI bright '"Final LISP code:"
;  [name,[slamOrLam,args,body]] := def'
;
;  body':=
;    removeTopLevelCatch body where
;      removeTopLevelCatch body ==
;        body is ["CATCH",g,u] =>
;          removeTopLevelCatch replaceThrowByReturn(u,g)
;        body
;      replaceThrowByReturn(x,g) ==
;        fn(x,g)
;        x
;      fn(x,g) ==
;        x is ["THROW", =g,:u] =>
;          rplac(first x,"RETURN")
;          rplac(rest x,replaceThrowByReturn(u,g))
;        atom x => nil
;        replaceThrowByReturn(first x,g)
;        replaceThrowByReturn(rest x,g)
;  [name,[slamOrLam,args,body']]

(DEFUN |optimizeFunctionDef,fn| (|x| |g|)
  (PROG (|ISTMP#1| |u|)
    (RETURN
      (SEQ (IF (AND (PAIRP |x|) (EQ (QCAR |x|) 'THROW)
                    (PROGN
                      (SPADLET |ISTMP#1| (QCDR |x|))
                      (AND (PAIRP |ISTMP#1|)
                           (EQUAL (QCAR |ISTMP#1|) |g|)
                           (PROGN (SPADLET |u| (QCDR |ISTMP#1|)) 'T))))
               (EXIT (SEQ (|rplac| (CAR |x|) 'RETURN)
                          (EXIT (|rplac| (CDR |x|)
                                    (|optimizeFunctionDef,replaceThrowByReturn|
                                          |u| |g|))))))
           (IF (ATOM |x|) (EXIT NIL))
           (|optimizeFunctionDef,replaceThrowByReturn| (CAR |x|) |g|)
           (EXIT (|optimizeFunctionDef,replaceThrowByReturn| (CDR |x|)
                     |g|))))))


(DEFUN |optimizeFunctionDef,replaceThrowByReturn| (|x| |g|)
  (SEQ (|optimizeFunctionDef,fn| |x| |g|) (EXIT |x|)))

(DEFUN |optimizeFunctionDef,removeTopLevelCatch| (|body|)
  (PROG (|ISTMP#1| |g| |ISTMP#2| |u|)
    (RETURN
      (SEQ (IF (AND (PAIRP |body|) (EQ (QCAR |body|) 'CATCH)
                    (PROGN
                      (SPADLET |ISTMP#1| (QCDR |body|))
                      (AND (PAIRP |ISTMP#1|)
                           (PROGN
                             (SPADLET |g| (QCAR |ISTMP#1|))
                             (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (PAIRP |ISTMP#2|)
                                  (EQ (QCDR |ISTMP#2|) NIL)
                                  (PROGN
                                    (SPADLET |u| (QCAR |ISTMP#2|))
                                    'T))))))
               (EXIT (|optimizeFunctionDef,removeTopLevelCatch|
                         (|optimizeFunctionDef,replaceThrowByReturn|
                             |u| |g|))))
           (EXIT |body|)))))

(DEFUN |optimizeFunctionDef| (|def|)
  (PROG (|def'| |name| |slamOrLam| |args| |body| |body'|)
    (DECLARE (SPECIAL |$reportOptimization|))
    (RETURN
      (PROGN
        (COND
          (|$reportOptimization|
              (|sayBrightlyI|
                  (|bright| "Original LISP code:"))
              (|pp| |def|)))
        (SPADLET |def'| (|optimize| (COPY |def|)))
        (COND
          (|$reportOptimization|
              (|sayBrightlyI|
                  (|bright| "Optimized LISP code:"))
              (|pp| |def'|)
              (|sayBrightlyI|
                  (|bright| "Final LISP code:"))))
        (SPADLET |name| (CAR |def'|))
        (SPADLET |slamOrLam| (CAADR |def'|))
        (SPADLET |args| (CADADR |def'|))
        (SPADLET |body| (CAR (CDDADR |def'|)))
        (SPADLET |body'|
                 (|optimizeFunctionDef,removeTopLevelCatch| |body|))
        (CONS |name|
              (CONS (CONS |slamOrLam| (CONS |args| (CONS |body'| NIL)))
                    NIL))))))

;optimize x ==
;  (opt x; x) where
;    opt x ==
;      atom x => nil
;      (y:= first x)='QUOTE => nil
;      y='CLOSEDFN => nil
;      y is [["XLAM",argl,body],:a] =>
;        optimize rest x
;        argl = "ignore" => RPLAC(first x,body)
;        if not (LENGTH argl<=LENGTH a) then
;          SAY '"length mismatch in XLAM expression"
;          PRETTYPRINT y
;        RPLAC(first x,optimize optXLAMCond SUBLIS(pairList(argl,a),body))
;      atom y =>
;        optimize rest x
;        y="true" => RPLAC(first x,'(QUOTE (QUOTE T)))
;        y="false" => RPLAC(first x,nil)
;      if first y="IF" then (RPLAC(first x,optIF2COND y); y:= first x)
;      op:= GET(subrname first y,"OPTIMIZE") =>
;        (optimize rest x; RPLAC(first x,FUNCALL(op,optimize first x)))
;      RPLAC(first x,optimize first x)
;      optimize rest x

(DEFUN |optimize,opt| (|x|)
  (PROG (|ISTMP#1| |ISTMP#2| |argl| |ISTMP#3| |body| |a| |y| |op|)
    (RETURN
      (SEQ (IF (ATOM |x|) (EXIT NIL))
           (IF (BOOT-EQUAL (SPADLET |y| (CAR |x|)) 'QUOTE) (EXIT NIL))
           (IF (BOOT-EQUAL |y| 'CLOSEDFN) (EXIT NIL))
           (IF (AND (PAIRP |y|)
                    (PROGN
                      (SPADLET |ISTMP#1| (QCAR |y|))
                      (AND (PAIRP |ISTMP#1|)
                           (EQ (QCAR |ISTMP#1|) 'XLAM)
                           (PROGN
                             (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (PAIRP |ISTMP#2|)
                                  (PROGN
                                    (SPADLET |argl| (QCAR |ISTMP#2|))
                                    (SPADLET |ISTMP#3|
                                     (QCDR |ISTMP#2|))
                                    (AND (PAIRP |ISTMP#3|)
                                     (EQ (QCDR |ISTMP#3|) NIL)
                                     (PROGN
                                       (SPADLET |body|
                                        (QCAR |ISTMP#3|))
                                       'T)))))))
                    (PROGN (SPADLET |a| (QCDR |y|)) 'T))
               (EXIT (SEQ (|optimize| (CDR |x|))
                          (IF (BOOT-EQUAL |argl| '|ignore|)
                              (EXIT (RPLAC (CAR |x|) |body|)))
                          (IF (NULL (<= (LENGTH |argl|) (LENGTH |a|)))
                              (SEQ (SAY
                                                                         "length mismatch in XLAM expression")
                                   (EXIT (PRETTYPRINT |y|)))
                              NIL)
                          (EXIT (RPLAC (CAR |x|)
                                       (|optimize|
                                        (|optXLAMCond|
                                         (SUBLIS
                                          (|pairList| |argl| |a|)
                                          |body|))))))))
           (IF (ATOM |y|)
               (EXIT (SEQ (|optimize| (CDR |x|))
                          (IF (BOOT-EQUAL |y| '|true|)
                              (EXIT (RPLAC (CAR |x|) '''T)))
                          (EXIT (IF (BOOT-EQUAL |y| '|false|)
                                    (EXIT (RPLAC (CAR |x|) NIL)))))))
           (IF (BOOT-EQUAL (CAR |y|) 'IF)
               (SEQ (RPLAC (CAR |x|) (|optIF2COND| |y|))
                    (EXIT (SPADLET |y| (CAR |x|))))
               NIL)
           (IF (SPADLET |op| (GETL (|subrname| (CAR |y|)) 'OPTIMIZE))
               (EXIT (SEQ (|optimize| (CDR |x|))
                          (EXIT (RPLAC (CAR |x|)
                                       (FUNCALL |op|
                                        (|optimize| (CAR |x|))))))))
           (RPLAC (CAR |x|) (|optimize| (CAR |x|)))
           (EXIT (|optimize| (CDR |x|)))))))

(DEFUN |optimize| (|x|) (PROGN (|optimize,opt| |x|) |x|)) 

;
;subrname u ==
;  IDENTP u => u
;  COMPILED_-FUNCTION_-P u or MBPIP u => BPINAME u
;  nil

(DEFUN |subrname| (|u|)
  (COND
    ((IDENTP |u|) |u|)
    ((OR (COMPILED-FUNCTION-P |u|) (MBPIP |u|)) (BPINAME |u|))
    ('T NIL)))

;optCatch (x is ["CATCH",g,a]) ==
;  $InteractiveMode => x
;  atom a => a
;  if a is ["SEQ",:s,["THROW", =g,u]] then
;    changeThrowToExit(s,g) where
;      changeThrowToExit(s,g) ==
;        atom s or MEMQ(first s,'(QUOTE SEQ REPEAT COLLECT)) => nil
;        s is ["THROW", =g,:u] => (rplac(first s,"EXIT"); rplac(rest s,u))
;        changeThrowToExit(first s,g)
;        changeThrowToExit(rest s,g)
;    rplac(rest a,[:s,["EXIT",u]])
;    ["CATCH",y,a]:= optimize x
;  if hasNoThrows(a,g)
;     then (rplac(first x,first a); rplac(rest x,rest a)) where
;      hasNoThrows(a,g) ==
;        a is ["THROW", =g,:.] => false
;        atom a => true
;        hasNoThrows(first a,g) and hasNoThrows(rest a,g)
;   else
;    changeThrowToGo(a,g) where
;      changeThrowToGo(s,g) ==
;        atom s or first s='QUOTE => nil
;        s is ["THROW", =g,u] =>
;          changeThrowToGo(u,g)
;          rplac(first s,"PROGN")
;          rplac(rest s,[["LET",CADR g,u],["GO",CADR g]])
;        changeThrowToGo(first s,g)
;        changeThrowToGo(rest s,g)
;    rplac(first x,"SEQ")
;    rplac(rest x,[["EXIT",a],CADR g,["EXIT",CADR g]])
;  x

(DEFUN |optCatch,changeThrowToExit| (|s| |g|)
  (PROG (|ISTMP#1| |u|)
    (RETURN
      (SEQ (IF (OR (ATOM |s|)
                   (member (CAR |s|) '(QUOTE SEQ REPEAT COLLECT)))
               (EXIT NIL))
           (IF (AND (PAIRP |s|) (EQ (QCAR |s|) 'THROW)
                    (PROGN
                      (SPADLET |ISTMP#1| (QCDR |s|))
                      (AND (PAIRP |ISTMP#1|)
                           (EQUAL (QCAR |ISTMP#1|) |g|)
                           (PROGN (SPADLET |u| (QCDR |ISTMP#1|)) 'T))))
               (EXIT (SEQ (|rplac| (CAR |s|) 'EXIT)
                          (EXIT (|rplac| (CDR |s|) |u|)))))
           (|optCatch,changeThrowToExit| (CAR |s|) |g|)
           (EXIT (|optCatch,changeThrowToExit| (CDR |s|) |g|))))))

(DEFUN |optCatch,hasNoThrows| (|a| |g|)
  (PROG (|ISTMP#1|)
    (RETURN
      (SEQ (IF (AND (PAIRP |a|) (EQ (QCAR |a|) 'THROW)
                    (PROGN
                      (SPADLET |ISTMP#1| (QCDR |a|))
                      (AND (PAIRP |ISTMP#1|)
                           (EQUAL (QCAR |ISTMP#1|) |g|))))
               (EXIT NIL))
           (IF (ATOM |a|) (EXIT 'T))
           (EXIT (AND (|optCatch,hasNoThrows| (CAR |a|) |g|)
                      (|optCatch,hasNoThrows| (CDR |a|) |g|)))))))

(DEFUN |optCatch,changeThrowToGo| (|s| |g|)
  (PROG (|ISTMP#1| |ISTMP#2| |u|)
    (RETURN
      (SEQ (IF (OR (ATOM |s|) (BOOT-EQUAL (CAR |s|) 'QUOTE))
               (EXIT NIL))
           (IF (AND (PAIRP |s|) (EQ (QCAR |s|) 'THROW)
                    (PROGN
                      (SPADLET |ISTMP#1| (QCDR |s|))
                      (AND (PAIRP |ISTMP#1|)
                           (EQUAL (QCAR |ISTMP#1|) |g|)
                           (PROGN
                             (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (PAIRP |ISTMP#2|)
                                  (EQ (QCDR |ISTMP#2|) NIL)
                                  (PROGN
                                    (SPADLET |u| (QCAR |ISTMP#2|))
                                    'T))))))
               (EXIT (SEQ (|optCatch,changeThrowToGo| |u| |g|)
                          (|rplac| (CAR |s|) 'PROGN)
                          (EXIT (|rplac| (CDR |s|)
                                         (CONS
                                          (CONS 'LET
                                           (CONS (CADR |g|)
                                            (CONS |u| NIL)))
                                          (CONS
                                           (CONS 'GO
                                            (CONS (CADR |g|) NIL))
                                           NIL)))))))
           (|optCatch,changeThrowToGo| (CAR |s|) |g|)
           (EXIT (|optCatch,changeThrowToGo| (CDR |s|) |g|))))))

(DEFUN |optCatch| (|x|)
  (PROG (|g| |ISTMP#1| |ISTMP#2| |ISTMP#3| |ISTMP#4| |ISTMP#5| |u| |s|
             |LETTMP#1| |y| |a|)
    (DECLARE (SPECIAL |$InteractiveMode|))
    (RETURN
      (SEQ (PROGN
             (COND ((EQ (CAR |x|) 'CATCH) (CAR |x|)))
             (SPADLET |g| (CADR |x|))
             (SPADLET |a| (CADDR |x|))
             (COND
               (|$InteractiveMode| |x|)
               ((ATOM |a|) |a|)
               ('T
                (COND
                  ((AND (PAIRP |a|) (EQ (QCAR |a|) 'SEQ)
                        (PROGN
                          (SPADLET |ISTMP#1| (QCDR |a|))
                          (AND (PAIRP |ISTMP#1|)
                               (PROGN
                                 (SPADLET |ISTMP#2|
                                          (REVERSE |ISTMP#1|))
                                 'T)
                               (PAIRP |ISTMP#2|)
                               (PROGN
                                 (SPADLET |ISTMP#3| (QCAR |ISTMP#2|))
                                 (AND (PAIRP |ISTMP#3|)
                                      (EQ (QCAR |ISTMP#3|) 'THROW)
                                      (PROGN
                                        (SPADLET |ISTMP#4|
                                         (QCDR |ISTMP#3|))
                                        (AND (PAIRP |ISTMP#4|)
                                         (EQUAL (QCAR |ISTMP#4|) |g|)
                                         (PROGN
                                           (SPADLET |ISTMP#5|
                                            (QCDR |ISTMP#4|))
                                           (AND (PAIRP |ISTMP#5|)
                                            (EQ (QCDR |ISTMP#5|) NIL)
                                            (PROGN
                                              (SPADLET |u|
                                               (QCAR |ISTMP#5|))
                                              'T)))))))
                               (PROGN
                                 (SPADLET |s| (QCDR |ISTMP#2|))
                                 'T)
                               (PROGN (SPADLET |s| (NREVERSE |s|)) 'T))))
                   (|optCatch,changeThrowToExit| |s| |g|)
                   (|rplac| (CDR |a|)
                            (APPEND |s|
                                    (CONS (CONS 'EXIT (CONS |u| NIL))
                                     NIL)))
                   (SPADLET |LETTMP#1| (|optimize| |x|))
                   (COND
                     ((EQ (CAR |LETTMP#1|) 'CATCH) (CAR |LETTMP#1|)))
                   (SPADLET |y| (CADR |LETTMP#1|))
                   (SPADLET |a| (CADDR |LETTMP#1|)) |LETTMP#1|))
                (COND
                  ((|optCatch,hasNoThrows| |a| |g|)
                   (|rplac| (CAR |x|) (CAR |a|))
                   (|rplac| (CDR |x|) (CDR |a|)))
                  ('T (|optCatch,changeThrowToGo| |a| |g|)
                   (|rplac| (CAR |x|) 'SEQ)
                   (|rplac| (CDR |x|)
                            (CONS (CONS 'EXIT (CONS |a| NIL))
                                  (CONS (CADR |g|)
                                        (CONS
                                         (CONS 'EXIT
                                          (CONS (CADR |g|) NIL))
                                         NIL))))))
                |x|)))))))

;optSPADCALL(form is ['SPADCALL,:argl]) ==
;  null $InteractiveMode => form
;  -- last arg is function/env, but may be a form
;  argl is [:argl,fun] =>
;    fun is ['ELT,dom,slot] or fun is ['LISPELT,dom,slot] =>
;      optCall ['call,['ELT,dom,slot],:argl]
;    form
;  form

(DEFUN |optSPADCALL| (|form|)
  (PROG (|fun| |argl| |ISTMP#1| |dom| |ISTMP#2| |slot|)
    (DECLARE (SPECIAL |$InteractiveMode|))
    (RETURN
      (PROGN
        (SPADLET |argl| (CDR |form|))
        (COND
          ((NULL |$InteractiveMode|) |form|)
          ((AND (PAIRP |argl|)
                (PROGN (SPADLET |ISTMP#1| (REVERSE |argl|)) 'T)
                (PAIRP |ISTMP#1|)
                (PROGN
                  (SPADLET |fun| (QCAR |ISTMP#1|))
                  (SPADLET |argl| (QCDR |ISTMP#1|))
                  'T)
                (PROGN (SPADLET |argl| (NREVERSE |argl|)) 'T))
           (COND
             ((OR (AND (PAIRP |fun|) (EQ (QCAR |fun|) 'ELT)
                       (PROGN
                         (SPADLET |ISTMP#1| (QCDR |fun|))
                         (AND (PAIRP |ISTMP#1|)
                              (PROGN
                                (SPADLET |dom| (QCAR |ISTMP#1|))
                                (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                                (AND (PAIRP |ISTMP#2|)
                                     (EQ (QCDR |ISTMP#2|) NIL)
                                     (PROGN
                                       (SPADLET |slot|
                                        (QCAR |ISTMP#2|))
                                       'T))))))
                  (AND (PAIRP |fun|) (EQ (QCAR |fun|) 'LISPELT)
                       (PROGN
                         (SPADLET |ISTMP#1| (QCDR |fun|))
                         (AND (PAIRP |ISTMP#1|)
                              (PROGN
                                (SPADLET |dom| (QCAR |ISTMP#1|))
                                (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                                (AND (PAIRP |ISTMP#2|)
                                     (EQ (QCDR |ISTMP#2|) NIL)
                                     (PROGN
                                       (SPADLET |slot|
                                        (QCAR |ISTMP#2|))
                                       'T)))))))
              (|optCall|
                  (CONS '|call|
                        (CONS (CONS 'ELT
                                    (CONS |dom| (CONS |slot| NIL)))
                              |argl|))))
             ('T |form|)))
          ('T |form|))))))

;optCall (x is ["call",:u]) ==
;  -- destructively optimizes this new x
;  x:= optimize [u]
;  -- next should happen only as result of macro expansion
;  atom first x => first x
;  [fn,:a]:= first x
;  atom fn => (RPLAC(rest x,a); RPLAC(first x,fn))
;  fn is ["PAC",:.] => optPackageCall(x,fn,a)
;  fn is ["applyFun",name] =>
;    (RPLAC(first x,"SPADCALL"); RPLAC(rest x,[:a,name]); x)
;  fn is [q,R,n] and MEMQ(q,'(ELT QREFELT CONST)) =>
;    not $bootStrapMode and (w:= optCallSpecially(q,x,n,R)) => w
;    q="CONST" =>
;--+
;      ["spadConstant",R,n]
;    --putInLocalDomainReferences will change this to ELT or QREFELT
;    RPLAC(first x,"SPADCALL")
;    if $QuickCode then RPLACA(fn,"QREFELT")
;    RPLAC(rest x,[:a,fn])
;    x
;  systemErrorHere '"optCall"

(DEFUN |optCall| (|x|)
  (PROG (|u| |LETTMP#1| |fn| |a| |name| |q| |ISTMP#1| R |ISTMP#2| |n|
             |w|)
    (DECLARE (SPECIAL |$QuickCode| |$bootStrapMode|))
    (RETURN
      (PROGN
        (COND ((EQ (CAR |x|) '|call|) (CAR |x|)))
        (SPADLET |u| (CDR |x|))
        (SPADLET |x| (|optimize| (CONS |u| NIL)))
        (COND
          ((ATOM (CAR |x|)) (CAR |x|))
          ('T (SPADLET |LETTMP#1| (CAR |x|))
           (SPADLET |fn| (CAR |LETTMP#1|))
           (SPADLET |a| (CDR |LETTMP#1|))
           (COND
             ((ATOM |fn|) (RPLAC (CDR |x|) |a|) (RPLAC (CAR |x|) |fn|))
             ((AND (PAIRP |fn|) (EQ (QCAR |fn|) 'PAC))
              (|optPackageCall| |x| |fn| |a|))
             ((AND (PAIRP |fn|) (EQ (QCAR |fn|) '|applyFun|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |fn|))
                     (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (SPADLET |name| (QCAR |ISTMP#1|)) 'T))))
              (RPLAC (CAR |x|) 'SPADCALL)
              (RPLAC (CDR |x|) (APPEND |a| (CONS |name| NIL))) |x|)
             ((AND (PAIRP |fn|)
                   (PROGN
                     (SPADLET |q| (QCAR |fn|))
                     (SPADLET |ISTMP#1| (QCDR |fn|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET R (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (PAIRP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |n| (QCAR |ISTMP#2|))
                                   'T)))))
                   (member |q| '(ELT QREFELT CONST)))
              (COND
                ((AND (NULL |$bootStrapMode|)
                      (SPADLET |w| (|optCallSpecially| |q| |x| |n| R)))
                 |w|)
                ((BOOT-EQUAL |q| 'CONST)
                 (CONS '|spadConstant| (CONS R (CONS |n| NIL))))
                ('T (RPLAC (CAR |x|) 'SPADCALL)
                 (COND (|$QuickCode| (RPLACA |fn| 'QREFELT)))
                 (RPLAC (CDR |x|) (APPEND |a| (CONS |fn| NIL))) |x|)))
             ('T (|systemErrorHere| "optCall")))))))))

;optPackageCall(x,["PAC",packageVariableOrForm,functionName],arglist) ==
;  RPLACA(x,functionName)
;  RPLACD(x,[:arglist,packageVariableOrForm])
;  x

(DEFUN |optPackageCall| (|x| G166589 |arglist|)
  (PROG (|packageVariableOrForm| |functionName|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G166589) 'PAC) (CAR G166589)))
        (SPADLET |packageVariableOrForm| (CADR G166589))
        (SPADLET |functionName| (CADDR G166589))
        (RPLACA |x| |functionName|)
        (RPLACD |x|
                (APPEND |arglist| (CONS |packageVariableOrForm| NIL)))
        |x|))))

;optCallSpecially(q,x,n,R) ==
;    y:= LASSOC(R,$specialCaseKeyList) => optSpecialCall(x,y,n)
;    MEMQ(KAR R,$optimizableConstructorNames) => optSpecialCall(x,R,n)
;    (y:= get(R,"value",$e)) and
;      MEMQ(opOf y.expr,$optimizableConstructorNames) =>
;        optSpecialCall(x,y.expr,n)
;    (
;      (y:= lookup(R,$getDomainCode)) and ([op,y,prop]:= y) and
;        (yy:= LASSOC(y,$specialCaseKeyList)) =>
;         optSpecialCall(x,[op,yy,prop],n)) where
;            lookup(a,l) ==
;              null l => nil
;              [l',:l]:= l
;              l' is ["LET", =a,l',:.] => l'
;              lookup(a,l)
;    nil

(DEFUN |optCallSpecially,lookup| (|a| |l|)
  (PROG (|LETTMP#1| |ISTMP#1| |ISTMP#2| |l'|)
    (RETURN
      (SEQ (IF (NULL |l|) (EXIT NIL))
           (PROGN
             (SPADLET |LETTMP#1| |l|)
             (SPADLET |l'| (CAR |LETTMP#1|))
             (SPADLET |l| (CDR |LETTMP#1|))
             |LETTMP#1|)
           (IF (AND (PAIRP |l'|) (EQ (QCAR |l'|) 'LET)
                    (PROGN
                      (SPADLET |ISTMP#1| (QCDR |l'|))
                      (AND (PAIRP |ISTMP#1|)
                           (EQUAL (QCAR |ISTMP#1|) |a|)
                           (PROGN
                             (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (PAIRP |ISTMP#2|)
                                  (PROGN
                                    (SPADLET |l'| (QCAR |ISTMP#2|))
                                    'T))))))
               (EXIT |l'|))
           (EXIT (|optCallSpecially,lookup| |a| |l|))))))

(DEFUN |optCallSpecially| (|q| |x| |n| R)
  (declare (ignore |q|))
  (PROG (|LETTMP#1| |op| |y| |prop| |yy|)
    (DECLARE (SPECIAL |$specialCaseKeyList| |$getDomainCode| |$e|
                      |$optimizableConstructorNames|))
    (RETURN
      (COND
        ((SPADLET |y| (LASSOC R |$specialCaseKeyList|))
         (|optSpecialCall| |x| |y| |n|))
        ((member (KAR R) |$optimizableConstructorNames|)
         (|optSpecialCall| |x| R |n|))
        ((AND (SPADLET |y| (|get| R '|value| |$e|))
              (member (|opOf| (CAR |y|)) |$optimizableConstructorNames|))
         (|optSpecialCall| |x| (CAR |y|) |n|))
        ((AND (SPADLET |y|
                       (|optCallSpecially,lookup| R |$getDomainCode|))
              (PROGN
                (SPADLET |LETTMP#1| |y|)
                (SPADLET |op| (CAR |LETTMP#1|))
                (SPADLET |y| (CADR |LETTMP#1|))
                (SPADLET |prop| (CADDR |LETTMP#1|))
                |LETTMP#1|)
              (SPADLET |yy| (LASSOC |y| |$specialCaseKeyList|)))
         (|optSpecialCall| |x|
             (CONS |op| (CONS |yy| (CONS |prop| NIL))) |n|))
        ('T NIL)))))

;optCallEval u ==
;  u is ["List",:.] => List Integer()
;  u is ["Vector",:.] => Vector Integer()
;  u is ["PrimitiveArray",:.] => PrimitiveArray Integer()
;  u is ["FactoredForm",:.] => FactoredForm Integer()
;  u is ["Matrix",:.] => Matrix Integer()
;  eval u

(DEFUN |optCallEval| (|u|)
  (COND
    ((AND (PAIRP |u|) (EQ (QCAR |u|) '|List|)) (|List| (|Integer|)))
    ((AND (PAIRP |u|) (EQ (QCAR |u|) '|Vector|))
     (|Vector| (|Integer|)))
    ((AND (PAIRP |u|) (EQ (QCAR |u|) '|PrimitiveArray|))
     (|PrimitiveArray| (|Integer|)))
    ((AND (PAIRP |u|) (EQ (QCAR |u|) '|FactoredForm|))
     (|FactoredForm| (|Integer|)))
    ((AND (PAIRP |u|) (EQ (QCAR |u|) '|Matrix|))
     (|Matrix| (|Integer|)))
    ('T (|eval| |u|))))

;optCons (x is ["CONS",a,b]) ==
;  a="NIL" =>
;    b='NIL => (rplac(first x,'QUOTE); rplac(rest x,['NIL,:'NIL]); x)
;    b is ['QUOTE,:c] => (rplac(first x,'QUOTE); rplac(rest x,['NIL,:c]); x)
;    x
;  a is ['QUOTE,a'] =>
;    b='NIL => (rplac(first x,'QUOTE); rplac(rest x,[a',:'NIL]); x)
;    b is ['QUOTE,:c] => (rplac(first x,'QUOTE); rplac(rest x,[a',:c]); x)
;    x
;  x

(DEFUN |optCons| (|x|)
  (PROG (|a| |b| |ISTMP#1| |a'| |c|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR |x|) 'CONS) (CAR |x|)))
        (SPADLET |a| (CADR |x|))
        (SPADLET |b| (CADDR |x|))
        (COND
          ((BOOT-EQUAL |a| 'NIL)
           (COND
             ((BOOT-EQUAL |b| 'NIL) (|rplac| (CAR |x|) 'QUOTE)
              (|rplac| (CDR |x|) (CONS 'NIL 'NIL)) |x|)
             ((AND (PAIRP |b|) (EQ (QCAR |b|) 'QUOTE)
                   (PROGN (SPADLET |c| (QCDR |b|)) 'T))
              (|rplac| (CAR |x|) 'QUOTE)
              (|rplac| (CDR |x|) (CONS 'NIL |c|)) |x|)
             ('T |x|)))
          ((AND (PAIRP |a|) (EQ (QCAR |a|) 'QUOTE)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |a|))
                  (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                       (PROGN (SPADLET |a'| (QCAR |ISTMP#1|)) 'T))))
           (COND
             ((BOOT-EQUAL |b| 'NIL) (|rplac| (CAR |x|) 'QUOTE)
              (|rplac| (CDR |x|) (CONS |a'| 'NIL)) |x|)
             ((AND (PAIRP |b|) (EQ (QCAR |b|) 'QUOTE)
                   (PROGN (SPADLET |c| (QCDR |b|)) 'T))
              (|rplac| (CAR |x|) 'QUOTE)
              (|rplac| (CDR |x|) (CONS |a'| |c|)) |x|)
             ('T |x|)))
          ('T |x|))))))

;optSpecialCall(x,y,n) ==
;  yval := optCallEval y
;  CAAAR x="CONST" =>
;    KAR yval.n = function Undef =>
;      keyedSystemError("S2GE0016",['"optSpecialCall",
;        '"invalid constant"])
;    MKQ yval.n
;  fn := GET(compileTimeBindingOf first yval.n,'SPADreplace) =>
;    rplac(rest x,CDAR x)
;    rplac(first x,fn)
;    if fn is ["XLAM",:.] then x:=first optimize [x]
;    x is ["EQUAL",:args] => RPLACW(x,DEF_-EQUAL args)
;                --DEF-EQUAL is really an optimiser
;    x
;  [fn,:a]:= first x
;  RPLAC(first x,"SPADCALL")
;  if $QuickCode then RPLACA(fn,"QREFELT")
;  RPLAC(rest x,[:a,fn])
;  x

(DEFUN |optSpecialCall| (|x| |y| |n|)
  (PROG (|yval| |args| |LETTMP#1| |fn| |a|)
    (DECLARE (SPECIAL |$QuickCode|))
    (RETURN
      (PROGN
        (SPADLET |yval| (|optCallEval| |y|))
        (COND
          ((BOOT-EQUAL (CAAAR |x|) 'CONST)
           (COND
             ((BOOT-EQUAL (KAR (ELT |yval| |n|)) (|function| |Undef|))
              (|keyedSystemError| 'S2GE0016
                  (CONS "optSpecialCall" (CONS "invalid constant" NIL))))
             ('T (MKQ (ELT |yval| |n|)))))
          ((SPADLET |fn|
                    (GETL (|compileTimeBindingOf|
                              (CAR (ELT |yval| |n|)))
                          '|SPADreplace|))
           (|rplac| (CDR |x|) (CDAR |x|)) (|rplac| (CAR |x|) |fn|)
           (COND
             ((AND (PAIRP |fn|) (EQ (QCAR |fn|) 'XLAM))
              (SPADLET |x| (CAR (|optimize| (CONS |x| NIL))))))
           (COND
             ((AND (PAIRP |x|) (EQ (QCAR |x|) 'EQUAL)
                   (PROGN (SPADLET |args| (QCDR |x|)) 'T))
              (RPLACW |x| (DEF-EQUAL |args|)))
             ('T |x|)))
          ('T (SPADLET |LETTMP#1| (CAR |x|))
           (SPADLET |fn| (CAR |LETTMP#1|))
           (SPADLET |a| (CDR |LETTMP#1|)) (RPLAC (CAR |x|) 'SPADCALL)
           (COND (|$QuickCode| (RPLACA |fn| 'QREFELT)))
           (RPLAC (CDR |x|) (APPEND |a| (CONS |fn| NIL))) |x|))))))

;compileTimeBindingOf u ==
;  NULL(name:= BPINAME u)  => keyedSystemError("S2OO0001",[u])
;  name="Undef" => MOAN "optimiser found unknown function"
;  name

(DEFUN |compileTimeBindingOf| (|u|)
  (PROG (|name|)
    (RETURN
      (COND
        ((NULL (SPADLET |name| (BPINAME |u|)))
         (|keyedSystemError| 'S2OO0001 (CONS |u| NIL)))
        ((BOOT-EQUAL |name| '|Undef|)
         (MOAN "optimiser found unknown function"))
        ('T |name|)))))

;optMkRecord ["mkRecord",:u] ==
;  u is [x] => ["LIST",x]
;  #u=2 => ["CONS",:u]
;  ["VECTOR",:u]

(DEFUN |optMkRecord| (G166580)
  (PROG (|u| |x|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G166580) '|mkRecord|) (CAR G166580)))
        (SPADLET |u| (CDR G166580))
        (COND
          ((AND (PAIRP |u|) (EQ (QCDR |u|) NIL)
                (PROGN (SPADLET |x| (QCAR |u|)) 'T))
           (CONS 'LIST (CONS |x| NIL)))
          ((EQL (|#| |u|) 2) (CONS 'CONS |u|))
          ('T (CONS 'VECTOR |u|)))))))

;optCond (x is ['COND,:l]) ==
;  if l is [a,[aa,b]] and TruthP aa and b is ["COND",:c] then
;    RPLACD(rest x,c)
;  if l is [[p1,:c1],[p2,:c2],:.] then
;    if (p1 is ['NULL,p1'] and p1' = p2) or (p2 is ['NULL,p2'] and p2' = p1) then
;      l:=[[p1,:c1],['(QUOTE T),:c2]]
;      RPLACD( x,l)
;    c1 is ['NIL] and p2 = '(QUOTE T) and first c2 = '(QUOTE T) =>
;      p1 is ['NULL,p1']=> return p1'
;      return ['NULL,p1]
;  l is [[p1,:c1],[p2,:c2],[p3,:c3]] and TruthP p3 =>
;    EqualBarGensym(c1,c3) =>
;      ["COND",[["OR",p1,["NULL",p2]],:c1],[['QUOTE,true],:c2]]
;    EqualBarGensym(c1,c2) => ["COND",[["OR",p1,p2],:c1],[['QUOTE,true],:c3]]
;    x
;  for y in tails l repeat
;    while y is [[a1,c1],[a2,c2],:y'] and EqualBarGensym(c1,c2) repeat
;      a:=['OR,a1,a2]
;      RPLAC(first first y,a)
;      RPLAC(rest y,y')
;  x

(DEFUN |optCond| (|x|)
  (PROG (|aa| |b| |c| |p2'| |l| |p1'| |p1| |p2| |p3| |c3| |ISTMP#1|
              |a1| |ISTMP#2| |c1| |ISTMP#3| |ISTMP#4| |a2| |ISTMP#5|
              |c2| |y'| |a|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |l| (CDR |x|))
             (COND
               ((AND (PAIRP |l|)
                     (PROGN
                       (SPADLET |a| (QCAR |l|))
                       (SPADLET |ISTMP#1| (QCDR |l|))
                       (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN
                              (SPADLET |ISTMP#2| (QCAR |ISTMP#1|))
                              (AND (PAIRP |ISTMP#2|)
                                   (PROGN
                                     (SPADLET |aa| (QCAR |ISTMP#2|))
                                     (SPADLET |ISTMP#3|
                                      (QCDR |ISTMP#2|))
                                     (AND (PAIRP |ISTMP#3|)
                                      (EQ (QCDR |ISTMP#3|) NIL)
                                      (PROGN
                                        (SPADLET |b| (QCAR |ISTMP#3|))
                                        'T)))))))
                     (|TruthP| |aa|) (PAIRP |b|) (EQ (QCAR |b|) 'COND)
                     (PROGN (SPADLET |c| (QCDR |b|)) 'T))
                (RPLACD (CDR |x|) |c|)))
             (COND
               ((AND (PAIRP |l|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCAR |l|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |p1| (QCAR |ISTMP#1|))
                              (SPADLET |c1| (QCDR |ISTMP#1|))
                              'T)))
                     (PROGN
                       (SPADLET |ISTMP#2| (QCDR |l|))
                       (AND (PAIRP |ISTMP#2|)
                            (PROGN
                              (SPADLET |ISTMP#3| (QCAR |ISTMP#2|))
                              (AND (PAIRP |ISTMP#3|)
                                   (PROGN
                                     (SPADLET |p2| (QCAR |ISTMP#3|))
                                     (SPADLET |c2| (QCDR |ISTMP#3|))
                                     'T))))))
                (COND
                  ((OR (AND (PAIRP |p1|) (EQ (QCAR |p1|) 'NULL)
                            (PROGN
                              (SPADLET |ISTMP#1| (QCDR |p1|))
                              (AND (PAIRP |ISTMP#1|)
                                   (EQ (QCDR |ISTMP#1|) NIL)
                                   (PROGN
                                     (SPADLET |p1'| (QCAR |ISTMP#1|))
                                     'T)))
                            (BOOT-EQUAL |p1'| |p2|))
                       (AND (PAIRP |p2|) (EQ (QCAR |p2|) 'NULL)
                            (PROGN
                              (SPADLET |ISTMP#1| (QCDR |p2|))
                              (AND (PAIRP |ISTMP#1|)
                                   (EQ (QCDR |ISTMP#1|) NIL)
                                   (PROGN
                                     (SPADLET |p2'| (QCAR |ISTMP#1|))
                                     'T)))
                            (BOOT-EQUAL |p2'| |p1|)))
                   (SPADLET |l|
                            (CONS (CONS |p1| |c1|)
                                  (CONS (CONS ''T |c2|) NIL)))
                   (RPLACD |x| |l|)))
                (COND
                  ((AND (PAIRP |c1|) (EQ (QCDR |c1|) NIL)
                        (EQUAL (QCAR |c1|) 'NIL) (BOOT-EQUAL |p2| ''T)
                        (BOOT-EQUAL (CAR |c2|) ''T))
                   (COND
                     ((AND (PAIRP |p1|) (EQ (QCAR |p1|) 'NULL)
                           (PROGN
                             (SPADLET |ISTMP#1| (QCDR |p1|))
                             (AND (PAIRP |ISTMP#1|)
                                  (EQ (QCDR |ISTMP#1|) NIL)
                                  (PROGN
                                    (SPADLET |p1'| (QCAR |ISTMP#1|))
                                    'T))))
                      (RETURN |p1'|))
                     ('T (RETURN (CONS 'NULL (CONS |p1| NIL)))))))))
             (COND
               ((AND (PAIRP |l|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCAR |l|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |p1| (QCAR |ISTMP#1|))
                              (SPADLET |c1| (QCDR |ISTMP#1|))
                              'T)))
                     (PROGN
                       (SPADLET |ISTMP#2| (QCDR |l|))
                       (AND (PAIRP |ISTMP#2|)
                            (PROGN
                              (SPADLET |ISTMP#3| (QCAR |ISTMP#2|))
                              (AND (PAIRP |ISTMP#3|)
                                   (PROGN
                                     (SPADLET |p2| (QCAR |ISTMP#3|))
                                     (SPADLET |c2| (QCDR |ISTMP#3|))
                                     'T)))
                            (PROGN
                              (SPADLET |ISTMP#4| (QCDR |ISTMP#2|))
                              (AND (PAIRP |ISTMP#4|)
                                   (EQ (QCDR |ISTMP#4|) NIL)
                                   (PROGN
                                     (SPADLET |ISTMP#5|
                                      (QCAR |ISTMP#4|))
                                     (AND (PAIRP |ISTMP#5|)
                                      (PROGN
                                        (SPADLET |p3| (QCAR |ISTMP#5|))
                                        (SPADLET |c3| (QCDR |ISTMP#5|))
                                        'T)))))))
                     (|TruthP| |p3|))
                (COND
                  ((|EqualBarGensym| |c1| |c3|)
                   (CONS 'COND
                         (CONS (CONS (CONS 'OR
                                      (CONS |p1|
                                       (CONS
                                        (CONS 'NULL (CONS |p2| NIL))
                                        NIL)))
                                     |c1|)
                               (CONS (CONS (CONS 'QUOTE (CONS 'T NIL))
                                      |c2|)
                                     NIL))))
                  ((|EqualBarGensym| |c1| |c2|)
                   (CONS 'COND
                         (CONS (CONS (CONS 'OR
                                      (CONS |p1| (CONS |p2| NIL)))
                                     |c1|)
                               (CONS (CONS (CONS 'QUOTE (CONS 'T NIL))
                                      |c3|)
                                     NIL))))
                  ('T |x|)))
               ('T
                (DO ((|y| |l| (CDR |y|))) ((ATOM |y|) NIL)
                  (SEQ (EXIT (DO ()
                                 ((NULL (AND (PAIRP |y|)
                                         (PROGN
                                           (SPADLET |ISTMP#1|
                                            (QCAR |y|))
                                           (AND (PAIRP |ISTMP#1|)
                                            (PROGN
                                              (SPADLET |a1|
                                               (QCAR |ISTMP#1|))
                                              (SPADLET |ISTMP#2|
                                               (QCDR |ISTMP#1|))
                                              (AND (PAIRP |ISTMP#2|)
                                               (EQ (QCDR |ISTMP#2|)
                                                NIL)
                                               (PROGN
                                                 (SPADLET |c1|
                                                  (QCAR |ISTMP#2|))
                                                 'T)))))
                                         (PROGN
                                           (SPADLET |ISTMP#3|
                                            (QCDR |y|))
                                           (AND (PAIRP |ISTMP#3|)
                                            (PROGN
                                              (SPADLET |ISTMP#4|
                                               (QCAR |ISTMP#3|))
                                              (AND (PAIRP |ISTMP#4|)
                                               (PROGN
                                                 (SPADLET |a2|
                                                  (QCAR |ISTMP#4|))
                                                 (SPADLET |ISTMP#5|
                                                  (QCDR |ISTMP#4|))
                                                 (AND (PAIRP |ISTMP#5|)
                                                  (EQ (QCDR |ISTMP#5|)
                                                   NIL)
                                                  (PROGN
                                                    (SPADLET |c2|
                                                     (QCAR |ISTMP#5|))
                                                    'T)))))
                                            (PROGN
                                              (SPADLET |y'|
                                               (QCDR |ISTMP#3|))
                                              'T)))
                                         (|EqualBarGensym| |c1| |c2|)))
                                  NIL)
                               (SEQ (EXIT
                                     (PROGN
                                       (SPADLET |a|
                                        (CONS 'OR
                                         (CONS |a1| (CONS |a2| NIL))))
                                       (RPLAC (CAR (CAR |y|)) |a|)
                                       (RPLAC (CDR |y|) |y'|))))))))
                |x|)))))))

;AssocBarGensym(key,l) ==
;  for x in l repeat
;    PAIRP x =>
;      EqualBarGensym(key,CAR x) => return x

(DEFUN |AssocBarGensym| (|key| |l|)
  (PROG ()
    (RETURN
      (SEQ (DO ((G166925 |l| (CDR G166925)) (|x| NIL))
               ((OR (ATOM G166925)
                    (PROGN (SETQ |x| (CAR G166925)) NIL))
                NIL)
             (SEQ (EXIT (COND
                          ((PAIRP |x|)
                           (EXIT (COND
                                   ((|EqualBarGensym| |key| (CAR |x|))
                                    (EXIT (RETURN |x|))))))))))))))

;EqualBarGensym(x,y) ==
;  $GensymAssoc: nil
;  fn(x,y) where
;    fn(x,y) ==
;      x=y => true
;      GENSYMP x and GENSYMP y =>
;        z:= ASSOC(x,$GensymAssoc) => (y=rest z => true; false)
;        $GensymAssoc:= [[x,:y],:$GensymAssoc]
;        true
;      null x => y is [g] and GENSYMP g
;      null y => x is [g] and GENSYMP g
;      atom x or atom y => false
;      fn(first x,first y) and fn(rest x,rest y)

(DEFUN |EqualBarGensym,fn| (|x| |y|)
  (PROG (|z| |g|)
    (DECLARE (SPECIAL |$GensymAssoc|))
    (RETURN
      (SEQ (IF (BOOT-EQUAL |x| |y|) (EXIT 'T))
           (IF (AND (GENSYMP |x|) (GENSYMP |y|))
               (EXIT (SEQ (IF (SPADLET |z|
                                       (|assoc| |x| |$GensymAssoc|))
                              (EXIT (SEQ
                                     (IF (BOOT-EQUAL |y| (CDR |z|))
                                      (EXIT 'T))
                                     (EXIT NIL))))
                          (SPADLET |$GensymAssoc|
                                   (CONS (CONS |x| |y|) |$GensymAssoc|))
                          (EXIT 'T))))
           (IF (NULL |x|)
               (EXIT (AND (AND (PAIRP |y|) (EQ (QCDR |y|) NIL)
                               (PROGN (SPADLET |g| (QCAR |y|)) 'T))
                          (GENSYMP |g|))))
           (IF (NULL |y|)
               (EXIT (AND (AND (PAIRP |x|) (EQ (QCDR |x|) NIL)
                               (PROGN (SPADLET |g| (QCAR |x|)) 'T))
                          (GENSYMP |g|))))
           (IF (OR (ATOM |x|) (ATOM |y|)) (EXIT NIL))
           (EXIT (AND (|EqualBarGensym,fn| (CAR |x|) (CAR |y|))
                      (|EqualBarGensym,fn| (CDR |x|) (CDR |y|))))))))

(DEFUN |EqualBarGensym| (|x| |y|)
  (PROG (|$GensymAssoc|)
    (DECLARE (SPECIAL |$GensymAssoc|))
    (RETURN
      (PROGN
        (SPADLET |$GensymAssoc| NIL)
        (|EqualBarGensym,fn| |x| |y|)))))

;--Called early, to change IF to COND
;
;optIF2COND ["IF",a,b,c] ==
;  b is "noBranch" => ["COND",[["NULL",a],c]]
;  c is "noBranch" => ["COND",[a,b]]
;  c is ["IF",:.] => ["COND",[a,b],:rest optIF2COND c]
;  c is ["COND",:p] => ["COND",[a,b],:p]
;  ["COND",[a,b],[$true,c]]

(DEFUN |optIF2COND| (G166953)
  (PROG (|a| |b| |c| |p|)
    (DECLARE (SPECIAL |$true|))
    (RETURN
      (PROGN
        (COND ((EQ (CAR G166953) 'IF) (CAR G166953)))
        (SPADLET |a| (CADR G166953))
        (SPADLET |b| (CADDR G166953))
        (SPADLET |c| (CADDDR G166953))
        (COND
          ((EQ |b| '|noBranch|)
           (CONS 'COND
                 (CONS (CONS (CONS 'NULL (CONS |a| NIL))
                             (CONS |c| NIL))
                       NIL)))
          ((EQ |c| '|noBranch|)
           (CONS 'COND (CONS (CONS |a| (CONS |b| NIL)) NIL)))
          ((AND (PAIRP |c|) (EQ (QCAR |c|) 'IF))
           (CONS 'COND
                 (CONS (CONS |a| (CONS |b| NIL))
                       (CDR (|optIF2COND| |c|)))))
          ((AND (PAIRP |c|) (EQ (QCAR |c|) 'COND)
                (PROGN (SPADLET |p| (QCDR |c|)) 'T))
           (CONS 'COND (CONS (CONS |a| (CONS |b| NIL)) |p|)))
          ('T
           (CONS 'COND
                 (CONS (CONS |a| (CONS |b| NIL))
                       (CONS (CONS |$true| (CONS |c| NIL)) NIL)))))))))

;optXLAMCond x ==
;  x is ["COND",u:= [p,c],:l] =>
;    (optPredicateIfTrue p => c; ["COND",u,:optCONDtail l])
;  atom x => x
;  RPLAC(first x,optXLAMCond first x)
;  RPLAC(rest x,optXLAMCond rest x)
;  x

(DEFUN |optXLAMCond| (|x|)
  (PROG (|ISTMP#1| |ISTMP#2| |p| |ISTMP#3| |c| |u| |l|)
    (RETURN
      (COND
        ((AND (PAIRP |x|) (EQ (QCAR |x|) 'COND)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |x|))
                (AND (PAIRP |ISTMP#1|)
                     (PROGN
                       (SPADLET |ISTMP#2| (QCAR |ISTMP#1|))
                       (AND (PAIRP |ISTMP#2|)
                            (PROGN
                              (SPADLET |p| (QCAR |ISTMP#2|))
                              (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                              (AND (PAIRP |ISTMP#3|)
                                   (EQ (QCDR |ISTMP#3|) NIL)
                                   (PROGN
                                     (SPADLET |c| (QCAR |ISTMP#3|))
                                     'T)))))
                     (PROGN (SPADLET |u| (QCAR |ISTMP#1|)) 'T)
                     (PROGN (SPADLET |l| (QCDR |ISTMP#1|)) 'T))))
         (COND
           ((|optPredicateIfTrue| |p|) |c|)
           ('T (CONS 'COND (CONS |u| (|optCONDtail| |l|))))))
        ((ATOM |x|) |x|)
        ('T (RPLAC (CAR |x|) (|optXLAMCond| (CAR |x|)))
         (RPLAC (CDR |x|) (|optXLAMCond| (CDR |x|))) |x|)))))

;optPredicateIfTrue p ==
;  p is ['QUOTE,:.] => true
;  p is [fn,x] and MEMQ(fn,$BasicPredicates) and FUNCALL(fn,x) => true
;  nil

(DEFUN |optPredicateIfTrue| (|p|)
  (PROG (|fn| |ISTMP#1| |x|)
    (DECLARE (SPECIAL |$BasicPredicates|))
    (RETURN
      (COND
        ((AND (PAIRP |p|) (EQ (QCAR |p|) 'QUOTE)) 'T)
        ((AND (PAIRP |p|)
              (PROGN
                (SPADLET |fn| (QCAR |p|))
                (SPADLET |ISTMP#1| (QCDR |p|))
                (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                     (PROGN (SPADLET |x| (QCAR |ISTMP#1|)) 'T)))
              (member |fn| |$BasicPredicates|) (FUNCALL |fn| |x|))
         'T)
        ('T NIL)))))

;optCONDtail l ==
;  null l => nil
;  [frst:= [p,c],:l']:= l
;  optPredicateIfTrue p => [[$true,c]]
;  null rest l => [frst,[$true,["CondError"]]]
;  [frst,:optCONDtail l']

(DEFUN |optCONDtail| (|l|)
  (PROG (|frst| |p| |c| |l'|)
    (DECLARE (SPECIAL |$true|))
    (RETURN
      (COND
        ((NULL |l|) NIL)
        ('T (SPADLET |frst| (CAR |l|)) (SPADLET |p| (CAAR |l|))
         (SPADLET |c| (CADAR |l|)) (SPADLET |l'| (CDR |l|))
         (COND
           ((|optPredicateIfTrue| |p|)
            (CONS (CONS |$true| (CONS |c| NIL)) NIL))
           ((NULL (CDR |l|))
            (CONS |frst|
                  (CONS (CONS |$true|
                              (CONS (CONS '|CondError| NIL) NIL))
                        NIL)))
           ('T (CONS |frst| (|optCONDtail| |l'|)))))))))

;optSEQ ["SEQ",:l] ==
;  tryToRemoveSEQ SEQToCOND getRidOfTemps l where
;    getRidOfTemps l ==
;      null l => nil
;      l is [["LET",g,x,:.],:r] and GENSYMP g and 2>numOfOccurencesOf(g,r) =>
;        getRidOfTemps substitute(x,g,r)
;      first l="/throwAway" => getRidOfTemps rest l
;      --this gets rid of unwanted labels generated by declarations in SEQs
;      [first l,:getRidOfTemps rest l]
;    SEQToCOND l ==
;      transform:= [[a,b] for x in l while (x is ["COND",[a,["EXIT",b]]])]
;      before:= take(#transform,l)
;      aft:= after(l,before)
;      null before => ["SEQ",:aft]
;      null aft => ["COND",:transform,'((QUOTE T) (conderr))]
;      true => ["COND",:transform,['(QUOTE T),optSEQ ["SEQ",:aft]]]
;    tryToRemoveSEQ l ==
;      l is ["SEQ",[op,a]] and MEMQ(op,'(EXIT RETURN THROW)) => a
;      l

(DEFUN |optSEQ,tryToRemoveSEQ| (|l|)
  (PROG (|ISTMP#1| |ISTMP#2| |op| |ISTMP#3| |a|)
    (RETURN
      (SEQ (IF (AND (AND (PAIRP |l|) (EQ (QCAR |l|) 'SEQ)
                         (PROGN
                           (SPADLET |ISTMP#1| (QCDR |l|))
                           (AND (PAIRP |ISTMP#1|)
                                (EQ (QCDR |ISTMP#1|) NIL)
                                (PROGN
                                  (SPADLET |ISTMP#2| (QCAR |ISTMP#1|))
                                  (AND (PAIRP |ISTMP#2|)
                                       (PROGN
                                         (SPADLET |op|
                                          (QCAR |ISTMP#2|))
                                         (SPADLET |ISTMP#3|
                                          (QCDR |ISTMP#2|))
                                         (AND (PAIRP |ISTMP#3|)
                                          (EQ (QCDR |ISTMP#3|) NIL)
                                          (PROGN
                                            (SPADLET |a|
                                             (QCAR |ISTMP#3|))
                                            'T))))))))
                    (member |op| '(EXIT RETURN THROW)))
               (EXIT |a|))
           (EXIT |l|)))))

(DEFUN |optSEQ,SEQToCOND| (|l|)
  (PROG (|ISTMP#1| |ISTMP#2| |a| |ISTMP#3| |ISTMP#4| |ISTMP#5| |b|
            |transform| |before| |aft|)
    (RETURN
      (SEQ (SPADLET |transform|
                    (PROG (G167164)
                      (SPADLET G167164 NIL)
                      (RETURN
                        (DO ((G167170 |l| (CDR G167170)) (|x| NIL))
                            ((OR (ATOM G167170)
                                 (PROGN
                                   (SETQ |x| (CAR G167170))
                                   NIL)
                                 (NULL (AND (PAIRP |x|)
                                        (EQ (QCAR |x|) 'COND)
                                        (PROGN
                                          (SPADLET |ISTMP#1|
                                           (QCDR |x|))
                                          (AND (PAIRP |ISTMP#1|)
                                           (EQ (QCDR |ISTMP#1|) NIL)
                                           (PROGN
                                             (SPADLET |ISTMP#2|
                                              (QCAR |ISTMP#1|))
                                             (AND (PAIRP |ISTMP#2|)
                                              (PROGN
                                                (SPADLET |a|
                                                 (QCAR |ISTMP#2|))
                                                (SPADLET |ISTMP#3|
                                                 (QCDR |ISTMP#2|))
                                                (AND (PAIRP |ISTMP#3|)
                                                 (EQ (QCDR |ISTMP#3|)
                                                  NIL)
                                                 (PROGN
                                                   (SPADLET |ISTMP#4|
                                                    (QCAR |ISTMP#3|))
                                                   (AND
                                                    (PAIRP |ISTMP#4|)
                                                    (EQ
                                                     (QCAR |ISTMP#4|)
                                                     'EXIT)
                                                    (PROGN
                                                      (SPADLET
                                                       |ISTMP#5|
                                                       (QCDR |ISTMP#4|))
                                                      (AND
                                                       (PAIRP
                                                        |ISTMP#5|)
                                                       (EQ
                                                        (QCDR
                                                         |ISTMP#5|)
                                                        NIL)
                                                       (PROGN
                                                         (SPADLET |b|
                                                          (QCAR
                                                           |ISTMP#5|))
                                                         'T))))))))))))))
                             (NREVERSE0 G167164))
                          (SEQ (EXIT (SETQ G167164
                                      (CONS (CONS |a| (CONS |b| NIL))
                                       G167164))))))))
           (SPADLET |before| (TAKE (|#| |transform|) |l|))
           (SPADLET |aft| (|after| |l| |before|))
           (IF (NULL |before|) (EXIT (CONS 'SEQ |aft|)))
           (IF (NULL |aft|)
               (EXIT (CONS 'COND
                           (APPEND |transform|
                                   (CONS '('T (|conderr|)) NIL)))))
           (EXIT (IF 'T
                     (EXIT (CONS 'COND
                                 (APPEND |transform|
                                         (CONS
                                          (CONS ''T
                                           (CONS
                                            (|optSEQ|
                                             (CONS 'SEQ |aft|))
                                            NIL))
                                          NIL))))))))))

(DEFUN |optSEQ,getRidOfTemps| (|l|)
  (PROG (|ISTMP#1| |ISTMP#2| |g| |ISTMP#3| |x| |r|)
    (RETURN
      (SEQ (IF (NULL |l|) (EXIT NIL))
           (IF (AND (AND (AND (PAIRP |l|)
                              (PROGN
                                (SPADLET |ISTMP#1| (QCAR |l|))
                                (AND (PAIRP |ISTMP#1|)
                                     (EQ (QCAR |ISTMP#1|) 'LET)
                                     (PROGN
                                       (SPADLET |ISTMP#2|
                                        (QCDR |ISTMP#1|))
                                       (AND (PAIRP |ISTMP#2|)
                                        (PROGN
                                          (SPADLET |g|
                                           (QCAR |ISTMP#2|))
                                          (SPADLET |ISTMP#3|
                                           (QCDR |ISTMP#2|))
                                          (AND (PAIRP |ISTMP#3|)
                                           (PROGN
                                             (SPADLET |x|
                                              (QCAR |ISTMP#3|))
                                             'T)))))))
                              (PROGN (SPADLET |r| (QCDR |l|)) 'T))
                         (GENSYMP |g|))
                    (> 2 (|numOfOccurencesOf| |g| |r|)))
               (EXIT (|optSEQ,getRidOfTemps| (MSUBST |x| |g| |r|))))
           (IF (BOOT-EQUAL (CAR |l|) '|/throwAway|)
               (EXIT (|optSEQ,getRidOfTemps| (CDR |l|))))
           (EXIT (CONS (CAR |l|) (|optSEQ,getRidOfTemps| (CDR |l|))))))))

(DEFUN |optSEQ| (G167201)
  (PROG (|l|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167201) 'SEQ) (CAR G167201)))
        (SPADLET |l| (CDR G167201))
        (|optSEQ,tryToRemoveSEQ|
            (|optSEQ,SEQToCOND| (|optSEQ,getRidOfTemps| |l|)))))))

;optRECORDELT ["RECORDELT",name,ind,len] ==
;  len=1 =>
;    ind=0 => ["QCAR",name]
;    keyedSystemError("S2OO0002",[ind])
;  len=2 =>
;    ind=0 => ["QCAR",name]
;    ind=1 => ["QCDR",name]
;    keyedSystemError("S2OO0002",[ind])
;  ["QVELT",name,ind]

(DEFUN |optRECORDELT| (G167217)
  (PROG (|name| |ind| |len|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167217) 'RECORDELT) (CAR G167217)))
        (SPADLET |name| (CADR G167217))
        (SPADLET |ind| (CADDR G167217))
        (SPADLET |len| (CADDDR G167217))
        (COND
          ((EQL |len| 1)
           (COND
             ((EQL |ind| 0) (CONS 'QCAR (CONS |name| NIL)))
             ('T (|keyedSystemError| 'S2OO0002 (CONS |ind| NIL)))))
          ((EQL |len| 2)
           (COND
             ((EQL |ind| 0) (CONS 'QCAR (CONS |name| NIL)))
             ((EQL |ind| 1) (CONS 'QCDR (CONS |name| NIL)))
             ('T (|keyedSystemError| 'S2OO0002 (CONS |ind| NIL)))))
          ('T (CONS 'QVELT (CONS |name| (CONS |ind| NIL)))))))))

;optSETRECORDELT ["SETRECORDELT",name,ind,len,expr] ==
;  len=1 =>
;    ind=0 => ["PROGN",["RPLACA",name,expr],["QCAR",name]]
;    keyedSystemError("S2OO0002",[ind])
;  len=2 =>
;    ind=0 => ["PROGN",["RPLACA",name,expr],["QCAR",name]]
;    ind=1 => ["PROGN",["RPLACD",name,expr],["QCDR",name]]
;    keyedSystemError("S2OO0002",[ind])
;  ["QSETVELT",name,ind,expr]

(DEFUN |optSETRECORDELT| (G167239)
  (PROG (|name| |ind| |len| |expr|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167239) 'SETRECORDELT) (CAR G167239)))
        (SPADLET |name| (CADR G167239))
        (SPADLET |ind| (CADDR G167239))
        (SPADLET |len| (CADDDR G167239))
        (SPADLET |expr| (CAR (CDDDDR G167239)))
        (COND
          ((EQL |len| 1)
           (COND
             ((EQL |ind| 0)
              (CONS 'PROGN
                    (CONS (CONS 'RPLACA
                                (CONS |name| (CONS |expr| NIL)))
                          (CONS (CONS 'QCAR (CONS |name| NIL)) NIL))))
             ('T (|keyedSystemError| 'S2OO0002 (CONS |ind| NIL)))))
          ((EQL |len| 2)
           (COND
             ((EQL |ind| 0)
              (CONS 'PROGN
                    (CONS (CONS 'RPLACA
                                (CONS |name| (CONS |expr| NIL)))
                          (CONS (CONS 'QCAR (CONS |name| NIL)) NIL))))
             ((EQL |ind| 1)
              (CONS 'PROGN
                    (CONS (CONS 'RPLACD
                                (CONS |name| (CONS |expr| NIL)))
                          (CONS (CONS 'QCDR (CONS |name| NIL)) NIL))))
             ('T (|keyedSystemError| 'S2OO0002 (CONS |ind| NIL)))))
          ('T
           (CONS 'QSETVELT
                 (CONS |name| (CONS |ind| (CONS |expr| NIL))))))))))

;optRECORDCOPY ["RECORDCOPY",name,len] ==
;  len=1 => ["LIST",["CAR",name]]
;  len=2 => ["CONS",["CAR",name],["CDR",name]]
;  ["MOVEVEC",["MAKE_-ARRAY",len],name]

(DEFUN |optRECORDCOPY| (G167262)
  (PROG (|name| |len|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167262) 'RECORDCOPY) (CAR G167262)))
        (SPADLET |name| (CADR G167262))
        (SPADLET |len| (CADDR G167262))
        (COND
          ((EQL |len| 1)
           (CONS 'LIST (CONS (CONS 'CAR (CONS |name| NIL)) NIL)))
          ((EQL |len| 2)
           (CONS 'CONS
                 (CONS (CONS 'CAR (CONS |name| NIL))
                       (CONS (CONS 'CDR (CONS |name| NIL)) NIL))))
          ('T
           (CONS 'replace
                 (CONS (CONS 'make-array (CONS |len| NIL))
                       (CONS |name| NIL)))))))))

;--mkRecordAccessFunction(ind,len) ==
;--  stringOfDs:= $EmptyString
;--  for i in 0..(ind-1) do stringOfDs:= STRCONC(stringOfDs,PNAME "D")
;--  prefix:= if ind=len-1 then PNAME "C" else PNAME "CA"
;--  if $QuickCode then prefix:=STRCONC("Q",prefix)
;--  INTERN(STRCONC(prefix,stringOfDs,PNAME "R"))
;
;optSuchthat [.,:u] == ["SUCHTHAT",:u]

(DEFUN |optSuchthat| (G167278)
  (PROG (|u|)
    (RETURN
      (PROGN (SPADLET |u| (CDR G167278)) (CONS 'SUCHTHAT |u|)))))

;optMINUS u ==
;  u is ['MINUS,v] =>
;    NUMBERP v => -v
;    u
;  u

(DEFUN |optMINUS| (|u|)
  (PROG (|ISTMP#1| |v|)
    (RETURN
      (COND
        ((AND (PAIRP |u|) (EQ (QCAR |u|) 'MINUS)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |u|))
                (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                     (PROGN (SPADLET |v| (QCAR |ISTMP#1|)) 'T))))
         (COND ((NUMBERP |v|) (SPADDIFFERENCE |v|)) ('T |u|)))
        ('T |u|)))))

;optQSMINUS u ==
;  u is ['QSMINUS,v] =>
;    NUMBERP v => -v
;    u
;  u

(DEFUN |optQSMINUS| (|u|)
  (PROG (|ISTMP#1| |v|)
    (RETURN
      (COND
        ((AND (PAIRP |u|) (EQ (QCAR |u|) 'QSMINUS)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |u|))
                (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                     (PROGN (SPADLET |v| (QCAR |ISTMP#1|)) 'T))))
         (COND ((NUMBERP |v|) (SPADDIFFERENCE |v|)) ('T |u|)))
        ('T |u|)))))

;opt_- u ==
;  u is ['_-,v] =>
;    NUMBERP v => -v
;    u
;  u

(DEFUN |opt-| (|u|)
  (PROG (|ISTMP#1| |v|)
    (RETURN
      (COND
        ((AND (PAIRP |u|) (EQ (QCAR |u|) '-)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |u|))
                (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                     (PROGN (SPADLET |v| (QCAR |ISTMP#1|)) 'T))))
         (COND ((NUMBERP |v|) (SPADDIFFERENCE |v|)) ('T |u|)))
        ('T |u|)))))

;optLESSP u ==
;  u is ['LESSP,a,b] =>
;    b = 0 => ['MINUSP,a]
;    ['GREATERP,b,a]
;  u

(DEFUN |optLESSP| (|u|)
  (PROG (|ISTMP#1| |a| |ISTMP#2| |b|)
    (RETURN
      (COND
        ((AND (PAIRP |u|) (EQ (QCAR |u|) 'LESSP)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |u|))
                (AND (PAIRP |ISTMP#1|)
                     (PROGN
                       (SPADLET |a| (QCAR |ISTMP#1|))
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)
                            (PROGN (SPADLET |b| (QCAR |ISTMP#2|)) 'T))))))
         (COND
           ((EQL |b| 0) (CONS 'MINUSP (CONS |a| NIL)))
           ('T (CONS '> (CONS |b| (CONS |a| NIL))))))
        ('T |u|)))))

;optEQ u ==
;  u is ['EQ,l,r] =>
;    NUMBERP l and NUMBERP r => ['QUOTE,EQ(l,r)]
;    -- That undoes some weird work in Boolean to do with the definition of true
;    u
;  u

(DEFUN |optEQ| (|u|)
  (PROG (|ISTMP#1| |l| |ISTMP#2| |r|)
    (RETURN
      (COND
        ((AND (PAIRP |u|) (EQ (QCAR |u|) 'EQ)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |u|))
                (AND (PAIRP |ISTMP#1|)
                     (PROGN
                       (SPADLET |l| (QCAR |ISTMP#1|))
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)
                            (PROGN (SPADLET |r| (QCAR |ISTMP#2|)) 'T))))))
         (COND
           ((AND (NUMBERP |l|) (NUMBERP |r|))
            (CONS 'QUOTE (CONS (EQ |l| |r|) NIL)))
           ('T |u|)))
        ('T |u|)))))

;EVALANDFILEACTQ
; (
;   for x in '( (call         optCall) _
;              (SEQ          optSEQ)_
;              (EQ optEQ)
;              (MINUS        optMINUS)_
;              (QSMINUS      optQSMINUS)_
;              (_-           opt_-)_
;              (LESSP        optLESSP)_
;              (SPADCALL     optSPADCALL)_
;              (_|           optSuchthat)_
;              (CATCH        optCatch)_
;              (COND         optCond)_
;              (mkRecord     optMkRecord)_
;              (RECORDELT    optRECORDELT)_
;              (SETRECORDELT optSETRECORDELT)_
;              (RECORDCOPY   optRECORDCOPY)) _
;      repeat MAKEPROP(CAR x,'OPTIMIZE,CREATE_-SBC CADR x)
;          --much quicker to call functions if they have an SBC
;    )
;

(EVALANDFILEACTQ
    (REPEAT (IN |x|
                '((|call| |optCall|) (SEQ |optSEQ|) (EQ |optEQ|)
                  (MINUS |optMINUS|) (QSMINUS |optQSMINUS|) (- |opt-|)
                  (LESSP |optLESSP|) (SPADCALL |optSPADCALL|)
                  (|\|| |optSuchthat|) (CATCH |optCatch|)
                  (COND |optCond|) (|mkRecord| |optMkRecord|)
                  (RECORDELT |optRECORDELT|)
                  (SETRECORDELT |optSETRECORDELT|)
                  (RECORDCOPY |optRECORDCOPY|)))
            (MAKEPROP (CAR |x|) 'OPTIMIZE (CADR |x|))))

\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
