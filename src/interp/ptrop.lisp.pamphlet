\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp ptrop.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=
(IN-PACKAGE "BOOT")

;--% Utility operations on Abstract Syntax Trees
 
;-- An S-expression which people can read.
;pfSexpr pform ==
;    strip pform where
;         strip pform ==
;            pfId? pform       => pfIdSymbol pform
;            pfLiteral?  pform => pfLiteralString pform
;            pfLeaf? pform     => tokPart pform
; 
;            pfApplication? pform =>
;                args :=
;                    a := pfApplicationArg pform
;                    if pfTuple? a then pf0TupleParts a else [a]
;                [strip p for p in cons(pfApplicationOp pform, args)]
; 
;            cons(pfAbSynOp pform, [strip p for p in pfParts pform])
 
(DEFUN |pfSexpr| (|pform|)
  (PROG () (RETURN (|pfSexpr,strip| |pform|))))

(DEFUN |pfSexpr,strip| (|pform|)
  (PROG (|args| |a|)
    (RETURN
      (COND
        ((|pfId?| |pform|) (|pfIdSymbol| |pform|))
        ((|pfLiteral?| |pform|) (|pfLiteralString| |pform|))
        ((|pfLeaf?| |pform|) (|tokPart| |pform|))
        ((|pfApplication?| |pform|)
         (PROGN
           (SETQ |args|
                 (PROGN
                   (SETQ |a| (|pfApplicationArg| |pform|))
                   (COND
                     ((|pfTuple?| |a|) (|pf0TupleParts| |a|))
                     ('T (LIST |a|)))))
           ((LAMBDA (|bfVar#2| |bfVar#1| |p|)
              (LOOP
                (COND
                  ((OR (ATOM |bfVar#1|)
                       (PROGN (SETQ |p| (CAR |bfVar#1|)) NIL))
                   (RETURN (NREVERSE |bfVar#2|)))
                  ('T
                   (SETQ |bfVar#2|
                         (CONS (|pfSexpr,strip| |p|) |bfVar#2|))))
                (SETQ |bfVar#1| (CDR |bfVar#1|))))
            NIL (CONS (|pfApplicationOp| |pform|) |args|) NIL)))
        ('T
         (CONS (|pfAbSynOp| |pform|)
               ((LAMBDA (|bfVar#4| |bfVar#3| |p|)
                  (LOOP
                    (COND
                      ((OR (ATOM |bfVar#3|)
                           (PROGN (SETQ |p| (CAR |bfVar#3|)) NIL))
                       (RETURN (NREVERSE |bfVar#4|)))
                      ('T
                       (SETQ |bfVar#4|
                             (CONS (|pfSexpr,strip| |p|) |bfVar#4|))))
                    (SETQ |bfVar#3| (CDR |bfVar#3|))))
                NIL (|pfParts| |pform|) NIL)))))))

;pfCopyWithPos( pform , pos ) == 
;    pfLeaf? pform =>         pfLeaf( pfAbSynOp pform , tokPart pform , pos )
;    pfTree( pfAbSynOp pform , [ pfCopyWithPos( p , pos ) for p in pfParts pform ] )
 
(DEFUN |pfCopyWithPos| (|pform| |pos|)
  (PROG ()
    (RETURN
      (COND
        ((|pfLeaf?| |pform|)
         (|pfLeaf| (|pfAbSynOp| |pform|) (|tokPart| |pform|) |pos|))
        ('T
         (|pfTree| (|pfAbSynOp| |pform|)
             ((LAMBDA (|bfVar#6| |bfVar#5| |p|)
                (LOOP
                  (COND
                    ((OR (ATOM |bfVar#5|)
                         (PROGN (SETQ |p| (CAR |bfVar#5|)) NIL))
                     (RETURN (NREVERSE |bfVar#6|)))
                    ('T
                     (SETQ |bfVar#6|
                           (CONS (|pfCopyWithPos| |p| |pos|) |bfVar#6|))))
                  (SETQ |bfVar#5| (CDR |bfVar#5|))))
              NIL (|pfParts| |pform|) NIL)))))))

;pfMapParts(f, pform) ==
;    pfLeaf? pform => pform
;    parts0 := pfParts pform
;    parts1 := [FUNCALL(f, p) for p in parts0]
;    -- Return the original if no changes.
;    same := true
;    for p0 in parts0 for p1 in parts1 while same repeat same := EQ(p0,p1)
;    same => pform
;    pfTree(pfAbSynOp pform, parts1)
 
(DEFUN |pfMapParts| (|f| |pform|)
  (PROG (|same| |parts1| |parts0|)
    (RETURN
      (COND
        ((|pfLeaf?| |pform|) |pform|)
        ('T
         (PROGN
           (SETQ |parts0| (|pfParts| |pform|))
           (SETQ |parts1|
                 ((LAMBDA (|bfVar#8| |bfVar#7| |p|)
                    (LOOP
                      (COND
                        ((OR (ATOM |bfVar#7|)
                             (PROGN (SETQ |p| (CAR |bfVar#7|)) NIL))
                         (RETURN (NREVERSE |bfVar#8|)))
                        ('T
                         (SETQ |bfVar#8|
                               (CONS (FUNCALL |f| |p|) |bfVar#8|))))
                      (SETQ |bfVar#7| (CDR |bfVar#7|))))
                  NIL |parts0| NIL))
           (SETQ |same| T)
           ((LAMBDA (|bfVar#9| |p0| |bfVar#10| |p1|)
              (LOOP
                (COND
                  ((OR (ATOM |bfVar#9|)
                       (PROGN (SETQ |p0| (CAR |bfVar#9|)) NIL)
                       (ATOM |bfVar#10|)
                       (PROGN (SETQ |p1| (CAR |bfVar#10|)) NIL)
                       (NOT |same|))
                   (RETURN NIL))
                  ('T (SETQ |same| (EQ |p0| |p1|))))
                (SETQ |bfVar#9| (CDR |bfVar#9|))
                (SETQ |bfVar#10| (CDR |bfVar#10|))))
            |parts0| NIL |parts1| NIL)
           (COND
             (|same| |pform|)
             ('T (|pfTree| (|pfAbSynOp| |pform|) |parts1|)))))))))

;pf0ApplicationArgs pform ==
;    arg := pfApplicationArg pform
;    pf0FlattenSyntacticTuple arg
 
(DEFUN |pf0ApplicationArgs| (|pform|)
  (PROG (|arg|)
    (RETURN
      (PROGN
        (SETQ |arg| (|pfApplicationArg| |pform|))
        (|pf0FlattenSyntacticTuple| |arg|)))))

;pf0FlattenSyntacticTuple pform ==
;    not pfTuple? pform => [pform]
;    [:pf0FlattenSyntacticTuple p for p in pf0TupleParts pform]

(DEFUN |pf0FlattenSyntacticTuple| (|pform|)
  (PROG ()
    (RETURN
      (COND
        ((NULL (|pfTuple?| |pform|)) (LIST |pform|))
        ('T
         ((LAMBDA (|bfVar#12| |bfVar#11| |p|)
            (LOOP
              (COND
                ((OR (ATOM |bfVar#11|)
                     (PROGN (SETQ |p| (CAR |bfVar#11|)) NIL))
                 (RETURN (NREVERSE |bfVar#12|)))
                ('T
                 (SETQ |bfVar#12|
                       (APPEND (REVERSE (|pf0FlattenSyntacticTuple|
                                         |p|))
                               |bfVar#12|))))
              (SETQ |bfVar#11| (CDR |bfVar#11|))))
          NIL (|pf0TupleParts| |pform|) NIL))))))

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
