\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp bc-matrix.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=

(IN-PACKAGE "BOOT" )

;-- Basic Command matrix entry
;bcMatrix() ==  bcReadMatrix nil

(DEFUN |bcMatrix| () (|bcReadMatrix| NIL))

;bcReadMatrix exitFunctionOrNil ==
;  page := htInitPage('"Matrix Basic Command", nil)
;  htpSetProperty(page,'exitFunction,exitFunctionOrNil)
;  htMakePage
;   '((domainConditions
;     (isDomain PI (PositiveInteger)))
;    (text . "Enter the size of the matrix:")
;    (inputStrings
;     ("Number of {\em rows}:\space{3}" "" 5 2 rows PI)
;     ("Number of {\em columns}: " "" 5 2 cols PI))
;    (text . "\blankline ")
;    (text . "How would you like to enter the matrix?")
;    (text . "\beginmenu")
;    (text . "\item ")
;    (bcLinks ("\menuitemstyle{By entering individual entries}" "" bcInputExplicitMatrix  explicit))
;    (text . "\item ")
;    (bcLinks ("\menuitemstyle{By formula}" "" bcInputMatrixByFormula formula))
;    (text . "\endmenu"))
;  htShowPage()

(DEFUN |bcReadMatrix| (|exitFunctionOrNil|)
  (PROG (|page|)
    (RETURN
      (PROGN
        (SPADLET |page|
                 (|htInitPage| (MAKESTRING "Matrix Basic Command") NIL))
        (|htpSetProperty| |page| '|exitFunction| |exitFunctionOrNil|)
        (|htMakePage|
            '((|domainConditions| (|isDomain| PI (|PositiveInteger|)))
              (|text| . "Enter the size of the matrix:")
              (|inputStrings|
                  ("Number of {\\em rows}:\\space{3}" "" 5 2 |rows| PI)
                  ("Number of {\\em columns}: " "" 5 2 |cols| PI))
              (|text| . "\\blankline ")
              (|text| . "How would you like to enter the matrix?")
              (|text| . "\\beginmenu") (|text| . "\\item ")
              (|bcLinks|
                  ("\\menuitemstyle{By entering individual entries}" ""
                   |bcInputExplicitMatrix| |explicit|))
              (|text| . "\\item ")
              (|bcLinks|
                  ("\\menuitemstyle{By formula}" ""
                   |bcInputMatrixByFormula| |formula|))
              (|text| . "\\endmenu")))
        (|htShowPage|)))))

;bcInputMatrixByFormula(htPage,junk) ==
;  page := htInitPage('"Basic Matrix Command", htpPropertyList htPage)
;  htMakePage '(
;    (domainConditions
;      (isDomain S (Symbol))
;      (isDomain FE (Expression (Integer))))
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em row variable}: ")
;    (text . "\tab{36}")
;    (bcStrings (6 i rowVar S))
;    (text . "\blankline ")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em column variable}: ")
;    (text . "\tab{36}")
;    (bcStrings (6 j colVar S))
;    (text . "\blankline ")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text .  "Enter the general {\em formula} for the entries:")
;    (text . "\newline\tab{2} ")
;    (bcStrings (40 "1/(x - i - j - 1)" formula FE)))
;  htMakeDoneButton('"Continue", 'bcInputMatrixByFormulaGen)
;  nrows :=
;    null $bcParseOnly => objValUnwrap htpLabelSpadValue(htPage,'rows)
;    PARSE_-INTEGER htpLabelInputString(htPage,'rows)
;  ncols :=
;    null $bcParseOnly => objValUnwrap htpLabelSpadValue(htPage,'cols)
;    PARSE_-INTEGER htpLabelInputString(htPage,'cols)
;  htpSetProperty(page, 'nrows, nrows)
;  htpSetProperty(page, 'ncols, ncols)
;  htShowPage()

(DEFUN |bcInputMatrixByFormula| (|htPage| |junk|)
  (declare (ignore |junk|))
  (PROG (|page| |nrows| |ncols|)
  (declare (special |$bcParseOnly|))
    (RETURN
      (PROGN
        (SPADLET |page|
                 (|htInitPage| (MAKESTRING "Basic Matrix Command")
                     (|htpPropertyList| |htPage|)))
        (|htMakePage|
            '((|domainConditions| (|isDomain| S (|Symbol|))
                  (|isDomain| FE (|Expression| (|Integer|))))
              (|text| . "\\menuitemstyle{}\\tab{2}")
              (|text| . "Enter the {\\em row variable}: ")
              (|text| . "\\tab{36}") (|bcStrings| (6 |i| |rowVar| S))
              (|text| . "\\blankline ") (|text| . "\\newline ")
              (|text| . "\\menuitemstyle{}\\tab{2}")
              (|text| . "Enter the {\\em column variable}: ")
              (|text| . "\\tab{36}") (|bcStrings| (6 |j| |colVar| S))
              (|text| . "\\blankline ") (|text| . "\\newline ")
              (|text| . "\\menuitemstyle{}\\tab{2}")
              (|text|
               . "Enter the general {\\em formula} for the entries:")
              (|text| . "\\newline\\tab{2} ")
              (|bcStrings| (40 "1/(x - i - j - 1)" |formula| FE))))
        (|htMakeDoneButton| (MAKESTRING "Continue")
            '|bcInputMatrixByFormulaGen|)
        (SPADLET |nrows|
                 (COND
                   ((NULL |$bcParseOnly|)
                    (|objValUnwrap|
                        (|htpLabelSpadValue| |htPage| '|rows|)))
                   ('T
                    (PARSE-INTEGER
                        (|htpLabelInputString| |htPage| '|rows|)))))
        (SPADLET |ncols|
                 (COND
                   ((NULL |$bcParseOnly|)
                    (|objValUnwrap|
                        (|htpLabelSpadValue| |htPage| '|cols|)))
                   ('T
                    (PARSE-INTEGER
                        (|htpLabelInputString| |htPage| '|cols|)))))
        (|htpSetProperty| |page| '|nrows| |nrows|)
        (|htpSetProperty| |page| '|ncols| |ncols|)
        (|htShowPage|)))))

;bcInputMatrixByFormulaGen htPage ==
;  fun :=  htpProperty(htPage,'exitFunction) => FUNCALL(fun, htPage)
;  formula := htpLabelInputString(htPage,'formula)
;  rowVar := htpLabelInputString(htPage,'rowVar)
;  colVar := htpLabelInputString(htPage,'colVar)
;  nrows := htpProperty(htPage,'nrows)
;  ncols := htpProperty(htPage,'ncols)
;  bcGen STRCONC('"matrix([[",formula,'" for ",colVar,'" in 1..",
;    STRINGIMAGE ncols,'"] for ",rowVar,'" in 1..",STRINGIMAGE nrows,'"])")

(DEFUN |bcInputMatrixByFormulaGen| (|htPage|)
  (PROG (|fun| |formula| |rowVar| |colVar| |nrows| |ncols|)
    (RETURN
      (COND
        ((SPADLET |fun| (|htpProperty| |htPage| '|exitFunction|))
         (FUNCALL |fun| |htPage|))
        ('T
         (SPADLET |formula|
                  (|htpLabelInputString| |htPage| '|formula|))
         (SPADLET |rowVar| (|htpLabelInputString| |htPage| '|rowVar|))
         (SPADLET |colVar| (|htpLabelInputString| |htPage| '|colVar|))
         (SPADLET |nrows| (|htpProperty| |htPage| '|nrows|))
         (SPADLET |ncols| (|htpProperty| |htPage| '|ncols|))
         (|bcGen| (STRCONC (MAKESTRING "matrix([[") |formula|
                           (MAKESTRING " for ") |colVar|
                           (MAKESTRING " in 1..") (STRINGIMAGE |ncols|)
                           (MAKESTRING "] for ") |rowVar|
                           (MAKESTRING " in 1..") (STRINGIMAGE |nrows|)
                           (MAKESTRING "])"))))))))

;bcInputExplicitMatrix(htPage,junk) ==
;  nrows :=
;    null $bcParseOnly => objValUnwrap htpLabelSpadValue(htPage,'rows)
;    PARSE_-INTEGER htpLabelInputString(htPage,'rows)
;  ncols :=
;    null $bcParseOnly => objValUnwrap htpLabelSpadValue(htPage,'cols)
;    PARSE_-INTEGER htpLabelInputString(htPage,'cols)
;  cond := nil
;  k := 0
;  wrows := # STRINGIMAGE nrows
;  wcols := # STRINGIMAGE ncols
;  labelList :=
;    "append"/[[f for j in 1..ncols] for i in 1..nrows] where f ==
;      rowpart := STRCONC('"{\em Row",htStringPad(i,wrows))
;      colpart := STRCONC('", Column",htStringPad(j,wcols),'":}\space{2}")
;      prefix := STRCONC(rowpart,colpart)
; --     name := INTERN STRCONC(htMkName('"row",i),htMkName('"col",j))
;      name := INTERN STRINGIMAGE (k := k + 1)
;      [prefix,'"",30, 0,name,'P]
;  labelList :=
;    [['domainConditions, '(isDomain P (Polynomial $EmptyMode)), cond],
;     ['inputStrings, :labelList] ]
;  page := htInitPage('"Solve Basic Command", htpPropertyList htPage)
;  bcHt '"Enter the entries of the matrix:"
;  htMakePage labelList
;  htMakeDoneButton('"Continue", 'bcGenExplicitMatrix)
;  htpSetProperty(page,'nrows,nrows)
;  htpSetProperty(page,'ncols,ncols)
;  htShowPage()

(DEFUN |bcInputExplicitMatrix| (|htPage| |junk|)
  (declare (ignore |junk|))
  (PROG (|nrows| |ncols| |cond| |wrows| |wcols| |rowpart| |colpart|
                 |prefix| |k| |name| |labelList| |page|)
  (declare (special |$EmptyMode| |$bcParseOnly|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |nrows|
                      (COND
                        ((NULL |$bcParseOnly|)
                         (|objValUnwrap|
                             (|htpLabelSpadValue| |htPage| '|rows|)))
                        ('T
                         (PARSE-INTEGER
                             (|htpLabelInputString| |htPage| '|rows|)))))
             (SPADLET |ncols|
                      (COND
                        ((NULL |$bcParseOnly|)
                         (|objValUnwrap|
                             (|htpLabelSpadValue| |htPage| '|cols|)))
                        ('T
                         (PARSE-INTEGER
                             (|htpLabelInputString| |htPage| '|cols|)))))
             (SPADLET |cond| NIL)
             (SPADLET |k| 0)
             (SPADLET |wrows| (|#| (STRINGIMAGE |nrows|)))
             (SPADLET |wcols| (|#| (STRINGIMAGE |ncols|)))
             (SPADLET |labelList|
                      (PROG (G166089)
                        (SPADLET G166089 NIL)
                        (RETURN
                          (DO ((|i| 1 (QSADD1 |i|)))
                              ((QSGREATERP |i| |nrows|) G166089)
                            (SEQ (EXIT (SETQ G166089
                                        (APPEND G166089
                                         (PROG (G166111)
                                           (SPADLET G166111 NIL)
                                           (RETURN
                                             (DO ((|j| 1 (QSADD1 |j|)))
                                              ((QSGREATERP |j| |ncols|)
                                               (NREVERSE0 G166111))
                                               (SEQ
                                                (EXIT
                                                 (SETQ G166111
                                                  (CONS
                                                   (PROGN
                                                     (SPADLET |rowpart|
                                                      (STRCONC
                                                       (MAKESTRING
                                                        "{\\em Row")
                                                       (|htStringPad|
                                                        |i| |wrows|)))
                                                     (SPADLET |colpart|
                                                      (STRCONC
                                                       (MAKESTRING
                                                        ", Column")
                                                       (|htStringPad|
                                                        |j| |wcols|)
                                                       (MAKESTRING
                                                        ":}\\space{2}")))
                                                     (SPADLET |prefix|
                                                      (STRCONC
                                                       |rowpart|
                                                       |colpart|))
                                                     (SPADLET |name|
                                                      (INTERN
                                                       (STRINGIMAGE
                                                        (SPADLET |k|
                                                         (PLUS |k| 1)))))
                                                     (CONS |prefix|
                                                      (CONS
                                                       (MAKESTRING "")
                                                       (CONS 30
                                                        (CONS 0
                                                         (CONS |name|
                                                          (CONS 'P NIL)))))))
                                                   G166111)))))))))))))))
             (SPADLET |labelList|
                      (CONS (CONS '|domainConditions|
                                  (CONS '(|isDomain| P
                                          (|Polynomial| |$EmptyMode|))
                                        (CONS |cond| NIL)))
                            (CONS (CONS '|inputStrings| |labelList|)
                                  NIL)))
             (SPADLET |page|
                      (|htInitPage| (MAKESTRING "Solve Basic Command")
                          (|htpPropertyList| |htPage|)))
             (|bcHt| (MAKESTRING "Enter the entries of the matrix:"))
             (|htMakePage| |labelList|)
             (|htMakeDoneButton| (MAKESTRING "Continue")
                 '|bcGenExplicitMatrix|)
             (|htpSetProperty| |page| '|nrows| |nrows|)
             (|htpSetProperty| |page| '|ncols| |ncols|)
             (|htShowPage|))))))

;bcGenExplicitMatrix htPage ==
;  htpSetProperty(htPage,'matrix,htpInputAreaAlist htPage)
;  fun :=  htpProperty(htPage,'exitFunction) => FUNCALL(fun, htPage)
;  bcGen bcMatrixGen htPage

(DEFUN |bcGenExplicitMatrix| (|htPage|)
  (PROG (|fun|)
    (RETURN
      (PROGN
        (|htpSetProperty| |htPage| '|matrix|
            (|htpInputAreaAlist| |htPage|))
        (COND
          ((SPADLET |fun| (|htpProperty| |htPage| '|exitFunction|))
           (FUNCALL |fun| |htPage|))
          ('T (|bcGen| (|bcMatrixGen| |htPage|))))))))

;bcMatrixGen htPage ==
;  nrows := htpProperty(htPage,'nrows)
;  ncols := htpProperty(htPage,'ncols)
;  mat := htpProperty(htPage,'matrix)
;  formula := LASSOC('formula,mat) =>
;    formula := formula.0
;    rowVar := LASSOC('rowVar,mat).0
;    colVar := LASSOC('colVar,mat).0
;    STRCONC('"matrix([[",formula,'" for ",colVar,'" in 1..",
;      STRINGIMAGE ncols,'"] for ",rowVar,'" in 1..",STRINGIMAGE nrows,'"])")
;  mat := htpProperty(htPage,'matrix) =>
;    mat := REVERSE mat
;    k := -1
;    matform := [[mat.(k := k + 1).1
;      for j in 0..(ncols-1)] for i in 0..(nrows-1)]
;    matstring := bcwords2liststring [bcwords2liststring x for x in matform]
;    STRCONC('"matrix(",matstring,'")")
;  systemError nil

(DEFUN |bcMatrixGen| (|htPage|)
  (PROG (|nrows| |ncols| |formula| |rowVar| |colVar| |mat| |k|
                 |matform| |matstring|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |nrows| (|htpProperty| |htPage| '|nrows|))
             (SPADLET |ncols| (|htpProperty| |htPage| '|ncols|))
             (SPADLET |mat| (|htpProperty| |htPage| '|matrix|))
             (COND
               ((SPADLET |formula| (LASSOC '|formula| |mat|))
                (SPADLET |formula| (ELT |formula| 0))
                (SPADLET |rowVar| (ELT (LASSOC '|rowVar| |mat|) 0))
                (SPADLET |colVar| (ELT (LASSOC '|colVar| |mat|) 0))
                (STRCONC (MAKESTRING "matrix([[") |formula|
                         (MAKESTRING " for ") |colVar|
                         (MAKESTRING " in 1..") (STRINGIMAGE |ncols|)
                         (MAKESTRING "] for ") |rowVar|
                         (MAKESTRING " in 1..") (STRINGIMAGE |nrows|)
                         (MAKESTRING "])")))
               ((SPADLET |mat| (|htpProperty| |htPage| '|matrix|))
                (SPADLET |mat| (REVERSE |mat|))
                (SPADLET |k| (SPADDIFFERENCE 1))
                (SPADLET |matform|
                         (PROG (G166155)
                           (SPADLET G166155 NIL)
                           (RETURN
                             (DO ((G166160
                                      (SPADDIFFERENCE |nrows| 1))
                                  (|i| 0 (QSADD1 |i|)))
                                 ((QSGREATERP |i| G166160)
                                  (NREVERSE0 G166155))
                               (SEQ (EXIT
                                     (SETQ G166155
                                      (CONS
                                       (PROG (G166168)
                                         (SPADLET G166168 NIL)
                                         (RETURN
                                           (DO
                                            ((G166173
                                              (SPADDIFFERENCE |ncols|
                                               1))
                                             (|j| 0 (QSADD1 |j|)))
                                            ((QSGREATERP |j| G166173)
                                             (NREVERSE0 G166168))
                                             (SEQ
                                              (EXIT
                                               (SETQ G166168
                                                (CONS
                                                 (ELT
                                                  (ELT |mat|
                                                   (SPADLET |k|
                                                    (PLUS |k| 1)))
                                                  1)
                                                 G166168)))))))
                                       G166155))))))))
                (SPADLET |matstring|
                         (|bcwords2liststring|
                             (PROG (G166181)
                               (SPADLET G166181 NIL)
                               (RETURN
                                 (DO ((G166186 |matform|
                                       (CDR G166186))
                                      (|x| NIL))
                                     ((OR (ATOM G166186)
                                       (PROGN
                                         (SETQ |x| (CAR G166186))
                                         NIL))
                                      (NREVERSE0 G166181))
                                   (SEQ
                                    (EXIT
                                     (SETQ G166181
                                      (CONS (|bcwords2liststring| |x|)
                                       G166181)))))))))
                (STRCONC (MAKESTRING "matrix(") |matstring|
                         (MAKESTRING ")")))
               ('T (|systemError| NIL))))))))

;--Hypertex commands other than solve and matrix
;bcDrawIt2(ind,a,b) == STRCONC('"{}",ind,'"=",a,'"{}..",b,'"{}")

(DEFUN |bcDrawIt2| (|ind| |a| |b|)
  (STRCONC (MAKESTRING "{}") |ind| (MAKESTRING "=") |a|
           (MAKESTRING "{}..") |b| (MAKESTRING "{}")))

;bcIndefiniteIntegrate() ==
;  htInitPage("Indefinite Integration Basic Command",nil)
;  htMakePage '(
;     (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain S (String))
;       (isDomain SY (Symbol)))
;     (text . "\newline ")
;     (text . "\menuitemstyle{}\tab{2}")
;     (text . "Enter the {\em function} you would like to integrate:")
;     (text . "\newline\tab{2} ")
;     (bcStrings (45 "1/(x**2 + 6)" integrand EM))
;     (text . "\blankline")
;     (text . "\newline ")
;     (text . "\menuitemstyle{}\tab{2}")
;     (text . "Enter the {\em variable of integration}:")
;     (text . "\tab{37}")
;     (bcStrings (10 x symbol SY))
;     (doneButton "Continue" bcIndefiniteIntegrateGen))
;  htShowPage()

(DEFUN |bcIndefiniteIntegrate| ()
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| '|Indefinite Integration Basic Command| NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em function} you would like to integrate:")
          (|text| . "\\newline\\tab{2} ")
          (|bcStrings| (45 "1/(x**2 + 6)" |integrand| EM))
          (|text| . "\\blankline") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the {\\em variable of integration}:")
          (|text| . "\\tab{37}") (|bcStrings| (10 |x| |symbol| SY))
          (|doneButton| "Continue" |bcIndefiniteIntegrateGen|)))
    (|htShowPage|)))

;bcIndefiniteIntegrateGen htPage ==
;  integrand := htpLabelInputString(htPage,'integrand)
;  var := htpLabelInputString(htPage,'symbol)
;  bcGen STRCONC('"integrate(",integrand,'",",var,")")

(DEFUN |bcIndefiniteIntegrateGen| (|htPage|)
  (PROG (|integrand| |var|)
    (RETURN
      (PROGN
        (SPADLET |integrand|
                 (|htpLabelInputString| |htPage| '|integrand|))
        (SPADLET |var| (|htpLabelInputString| |htPage| '|symbol|))
        (|bcGen| (STRCONC (MAKESTRING "integrate(") |integrand|
                          (MAKESTRING ",") |var| '|)|))))))

;bcDefiniteIntegrate() ==
;  htInitPage("Definite Integration Basic Command",nil)
;  htMakePage '(
;     (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain S (String))
;       (isDomain SY (Symbol)))
;     (text . "\newline ")
;     (text . "\menuitemstyle{}\tab{2}")
;     (text . "Enter the {\em function} you would like to integrate:")
;     (text . "\newline\tab{2} ")
;     (bcStrings (45 "1/(x**2 + 6)" integrand EM))
;     (text . "\blankline")
;     (text . "\newline ")
;     (text . "\menuitemstyle{}\tab{2}")
;     (text . "Enter the {\em variable of integration}:")
;     (text . "\tab{37}")
;     (bcStrings (10 x symbol SY))
;     (text . "\blankline")
;     (text . "\newline ")
;     (text . "\menuitemstyle{}\tab{2}")
;     (text . "\newline Enter {\em lower limit}:")
;     (radioButtons fromButton
;       ("" "Minus infinity" minusInfinity)
;       (""  (
;         (text . "A finite point:\tab{15}")
;         (bcStrings (10 0 from EM . bcOptional))) fromPoint))
;     (text . "\blankline")
;     (text . "\newline ")
;     (text . "\menuitemstyle{}\tab{2}")
;     (text . "\indent{2}\newline Enter {\em upper limit}:")
;     (radioButtons toButton
;       ("" "Plus infinity" plusInfinity)
;       ("" (
;         (text "A finite point:\tab{15}")
;         (bcStrings (10 y to EM . bcOptional))) toPoint))
;     (doneButton "Continue" bcDefiniteIntegrateGen))
;  htShowPage()

(DEFUN |bcDefiniteIntegrate| ()
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| '|Definite Integration Basic Command| NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em function} you would like to integrate:")
          (|text| . "\\newline\\tab{2} ")
          (|bcStrings| (45 "1/(x**2 + 6)" |integrand| EM))
          (|text| . "\\blankline") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the {\\em variable of integration}:")
          (|text| . "\\tab{37}") (|bcStrings| (10 |x| |symbol| SY))
          (|text| . "\\blankline") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "\\newline Enter {\\em lower limit}:")
          (|radioButtons| |fromButton|
              ("" "Minus infinity" |minusInfinity|)
              (""
               ((|text| . "A finite point:\\tab{15}")
                (|bcStrings| (10 0 |from| EM . |bcOptional|)))
               |fromPoint|))
          (|text| . "\\blankline") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "\\indent{2}\\newline Enter {\\em upper limit}:")
          (|radioButtons| |toButton|
              ("" "Plus infinity" |plusInfinity|)
              (""
               ((|text| "A finite point:\\tab{15}")
                (|bcStrings| (10 |y| |to| EM . |bcOptional|)))
               |toPoint|))
          (|doneButton| "Continue" |bcDefiniteIntegrateGen|)))
    (|htShowPage|)))

;bcDefiniteIntegrateGen htPage ==
;  integrand := htpLabelInputString(htPage,'integrand)
;  var := htpLabelInputString(htPage,'symbol)
;  lowerLimit :=
;    htpButtonValue(htPage,'fromButton) = 'fromPoint =>
;      htpLabelInputString(htPage,'from)
;    '"%minusInfinity"
;  upperLimit :=
;    htpButtonValue(htPage,'toButton) = 'toPoint =>
;      htpLabelInputString(htPage,'to)
;    '"%plusInfinity"
;  varpart := STRCONC(var,'" = ",lowerLimit,'"..",upperLimit)
;  bcGen
;   STRCONC('"integrate(",integrand,'",",varpart,'")")

(DEFUN |bcDefiniteIntegrateGen| (|htPage|)
  (PROG (|integrand| |var| |lowerLimit| |upperLimit| |varpart|)
    (RETURN
      (PROGN
        (SPADLET |integrand|
                 (|htpLabelInputString| |htPage| '|integrand|))
        (SPADLET |var| (|htpLabelInputString| |htPage| '|symbol|))
        (SPADLET |lowerLimit|
                 (COND
                   ((BOOT-EQUAL
                        (|htpButtonValue| |htPage| '|fromButton|)
                        '|fromPoint|)
                    (|htpLabelInputString| |htPage| '|from|))
                   ('T (MAKESTRING "%minusInfinity"))))
        (SPADLET |upperLimit|
                 (COND
                   ((BOOT-EQUAL (|htpButtonValue| |htPage| '|toButton|)
                        '|toPoint|)
                    (|htpLabelInputString| |htPage| '|to|))
                   ('T (MAKESTRING "%plusInfinity"))))
        (SPADLET |varpart|
                 (STRCONC |var| (MAKESTRING " = ") |lowerLimit|
                          (MAKESTRING "..") |upperLimit|))
        (|bcGen| (STRCONC (MAKESTRING "integrate(") |integrand|
                          (MAKESTRING ",") |varpart| (MAKESTRING ")")))))))

;bcSum() ==
;  htInitPage("Sum Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain S (String))
;       (isDomain SY (Symbol)))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em function} you would like to sum:")
;    (text . "\newline\tab{2} ")
;    (bcStrings (44 "i**3" summand EM))
;    (text . "\blankline ")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em summation index}:")
;    (text . "\tab{36}")
;    (bcStrings (10 i index SY))
;    (text . "\blankline ")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the limits of the sum:")
;    (text . "\newline\tab{10}{\em From:}")
;    (bcStrings (10 1 first S))
;    (text . "\tab{32}{\em To:}")
;    (text . "\tab{36}")
;    (bcStrings (10  n  last S))
;    (doneButton "Continue" bcSumGen))
;  htShowPage()

(DEFUN |bcSum| ()
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| '|Sum Basic Command| NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the {\\em function} you would like to sum:")
          (|text| . "\\newline\\tab{2} ")
          (|bcStrings| (44 "i**3" |summand| EM))
          (|text| . "\\blankline ") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the {\\em summation index}:")
          (|text| . "\\tab{36}") (|bcStrings| (10 |i| |index| SY))
          (|text| . "\\blankline ") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the limits of the sum:")
          (|text| . "\\newline\\tab{10}{\\em From:}")
          (|bcStrings| (10 1 |first| S))
          (|text| . "\\tab{32}{\\em To:}") (|text| . "\\tab{36}")
          (|bcStrings| (10 |n| |last| S))
          (|doneButton| "Continue" |bcSumGen|)))
    (|htShowPage|)))

;bcSumGen htPage ==
;  mand := htpLabelInputString(htPage,'summand)
;  index := htpLabelInputString(htPage,'index)
;  first := htpLabelInputString(htPage,'first)
;  last := htpLabelInputString(htPage,'last)
;  bcGen STRCONC('"sum(",mand,'",",index,'" = ",first,'"..",last,'")")

(DEFUN |bcSumGen| (|htPage|)
  (PROG (|mand| |index| CAR |last|)
    (RETURN
      (PROGN
        (SPADLET |mand| (|htpLabelInputString| |htPage| '|summand|))
        (SPADLET |index| (|htpLabelInputString| |htPage| '|index|))
        (SPADLET CAR (|htpLabelInputString| |htPage| '|first|))
        (SPADLET |last| (|htpLabelInputString| |htPage| '|last|))
        (|bcGen| (STRCONC (MAKESTRING "sum(") |mand| (MAKESTRING ",")
                          |index| (MAKESTRING " = ") CAR
                          (MAKESTRING "..") |last| (MAKESTRING ")")))))))

;bcProduct() ==
;  htInitPage("Product Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain S (String))
;       (isDomain SY (Symbol)))
;    (text . "Enter the {\em function} you would like to compute the product of:")
;    (inputStrings ("" "" 45 "i**2" mand EM))
;    (text . "\vspace{1}\newline")
;    (inputStrings ("Enter the {\em index of the product}:" "" 5 i index SY))
;    (text . "\vspace{1}\newline Enter the limits of the index:")
;    (inputStrings
;      ("\newline{\em From:}" "" 10 "1" first  EM)
;      ("{\em To:}\space{2}" "" 10  "n" last   EM))
;    (doneButton "Continue" bcProductGen))
;  htShowPage()

(DEFUN |bcProduct| ()
  (PROGN
    (|htInitPage| '|Product Basic Command| NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
          (|text|
           . "Enter the {\\em function} you would like to compute the product of:")
          (|inputStrings| ("" "" 45 "i**2" |mand| EM))
          (|text| . "\\vspace{1}\\newline")
          (|inputStrings|
              ("Enter the {\\em index of the product}:" "" 5 |i|
               |index| SY))
          (|text|
           . "\\vspace{1}\\newline Enter the limits of the index:")
          (|inputStrings|
              ("\\newline{\\em From:}" "" 10 "1" |first| EM)
              ("{\\em To:}\\space{2}" "" 10 "n" |last| EM))
          (|doneButton| "Continue" |bcProductGen|)))
    (|htShowPage|)))

;bcProductGen htPage ==
;  mand := htpLabelInputString(htPage,'mand)
;  index := htpLabelInputString(htPage,'index)
;  first := htpLabelInputString(htPage,'first)
;  last := htpLabelInputString(htPage,'last)
;  bcGen STRCONC('"product(",mand,'",",index,'",",first,'",",last,'")")

(DEFUN |bcProductGen| (|htPage|)
  (PROG (|mand| |index| CAR |last|)
    (RETURN
      (PROGN
        (SPADLET |mand| (|htpLabelInputString| |htPage| '|mand|))
        (SPADLET |index| (|htpLabelInputString| |htPage| '|index|))
        (SPADLET CAR (|htpLabelInputString| |htPage| '|first|))
        (SPADLET |last| (|htpLabelInputString| |htPage| '|last|))
        (|bcGen| (STRCONC (MAKESTRING "product(") |mand|
                          (MAKESTRING ",") |index| (MAKESTRING ",") CAR
                          (MAKESTRING ",") |last| (MAKESTRING ")")))))))

;bcDifferentiate() ==
;  htInitPage("Differentiate Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain S (String))
;       (isDomain SY (Symbol)))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em function} you want to differentiate:")
;    (text . "\newline\tab{2} ")
;    (bcStrings (55 "sin(x*y)" diffand EM))
;    (text . "\blankline")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "\newline List the {\em variables} you want to differentiate with respect to?")
;    (text . "\newline\tab{2} ")
;    (bcStrings (55 "x y" variables S . quoteString))
;    (text . "\blankline")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "\newline List the number of {\em times} you want to differentiate with respect to each variable (leave blank if once for each)")
;    (text . "\newline\tab{2} ")
;    (bcStrings (55 "1 2" times S . quoteString)))
;  htMakeDoneButton('"Continue", 'bcDifferentiateGen)
;  htShowPage()

(DEFUN |bcDifferentiate| ()
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| '|Differentiate Basic Command| NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em function} you want to differentiate:")
          (|text| . "\\newline\\tab{2} ")
          (|bcStrings| (55 "sin(x*y)" |diffand| EM))
          (|text| . "\\blankline") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "\\newline List the {\\em variables} you want to differentiate with respect to?")
          (|text| . "\\newline\\tab{2} ")
          (|bcStrings| (55 "x y" |variables| S . |quoteString|))
          (|text| . "\\blankline") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "\\newline List the number of {\\em times} you want to differentiate with respect to each variable (leave blank if once for each)")
          (|text| . "\\newline\\tab{2} ")
          (|bcStrings| (55 "1 2" |times| S . |quoteString|))))
    (|htMakeDoneButton| (MAKESTRING "Continue") '|bcDifferentiateGen|)
    (|htShowPage|)))

;bcDifferentiateGen htPage ==
;  mand := htpLabelInputString(htPage,'diffand)
;  varlist := bcString2WordList htpLabelInputString(htPage,'variables)
;  indexList := bcString2WordList htpLabelInputString(htPage,'times)
;  varpart :=
;    #varlist > 1 => bcwords2liststring varlist
;    first varlist
;  indexpart :=
;    null indexList => nil
;    null rest indexList => first indexList
;    #indexList = #varlist => bcwords2liststring indexList
;    bcError '"You must say how many times you want to differentiate with respect to each variable---or leave that entry blank"
;  lastPart :=
;    indexpart => STRCONC('",",indexpart,'")")
;    '")"
;  bcGen STRCONC('"differentiate(",mand,'",",varpart,lastPart)

(DEFUN |bcDifferentiateGen| (|htPage|)
  (PROG (|mand| |varlist| |indexList| |varpart| |indexpart| |lastPart|)
    (RETURN
      (PROGN
        (SPADLET |mand| (|htpLabelInputString| |htPage| '|diffand|))
        (SPADLET |varlist|
                 (|bcString2WordList|
                     (|htpLabelInputString| |htPage| '|variables|)))
        (SPADLET |indexList|
                 (|bcString2WordList|
                     (|htpLabelInputString| |htPage| '|times|)))
        (SPADLET |varpart|
                 (COND
                   ((> (|#| |varlist|) 1)
                    (|bcwords2liststring| |varlist|))
                   ('T (CAR |varlist|))))
        (SPADLET |indexpart|
                 (COND
                   ((NULL |indexList|) NIL)
                   ((NULL (CDR |indexList|)) (CAR |indexList|))
                   ((BOOT-EQUAL (|#| |indexList|) (|#| |varlist|))
                    (|bcwords2liststring| |indexList|))
                   ('T
                    (|bcError|
                        (MAKESTRING
                            "You must say how many times you want to differentiate with respect to each variable---or leave that entry blank")))))
        (SPADLET |lastPart|
                 (COND
                   (|indexpart|
                       (STRCONC (MAKESTRING ",") |indexpart|
                                (MAKESTRING ")")))
                   ('T (MAKESTRING ")"))))
        (|bcGen| (STRCONC (MAKESTRING "differentiate(") |mand|
                          (MAKESTRING ",") |varpart| |lastPart|))))))

;bcDraw() ==
;  htInitPage('"Draw Basic Command",nil)
;  bcHt '"What would you like to draw?"
;  bcHt '"\newline\centerline{{\em Two Dimensional Plots}}\newline"
;  bcHt '"\lispdownlink{A function of one variable}{(|bcDraw2Dfun|)}"
;  bcHt '"\space{2}y = f(x)\newline"
;  bcHt '"\lispdownlink{A parametrically defined curve}{(|bcDraw2Dpar|)}"
;  bcHt '"\space{2}(x(t), y(t))\newline"
;  bcHt '"\lispdownlink{A solution to a polynomial equation}{(|bcDraw2DSolve|)}"
;  bcHt '"\space{2} p(x,y) = 0\newline"
;  bcHt '"\vspace{1}\newline "
;  bcHt '"\centerline{{\em Three Dimensional Surfaces}}\newline\newline"
;  bcHt '"\lispdownlink{A function of two variables}{(|bcDraw3Dfun|)}"
;  bcHt '"\space{2} z = f(x,y)\newline"
;  bcHt '"\lispdownlink{A parametrically defined tube}{(|bcDraw3Dpar|)}"
;  bcHt '"\space{2}(x(t), y(t), z(t))\newline"
;  bcHt '"\lispdownlink{A parameterically defined surface}{(|bcDraw3Dpar1|)}"
;  bcHt '"\space{2}(x(u,v), y(u,v), z(u,v))\newline"
;  htShowPage()

(DEFUN |bcDraw| ()
  (PROGN
    (|htInitPage| (MAKESTRING "Draw Basic Command") NIL)
    (|bcHt| (MAKESTRING "What would you like to draw?"))
    (|bcHt| (MAKESTRING
                "\\newline\\centerline{{\\em Two Dimensional Plots}}\\newline"))
    (|bcHt| (MAKESTRING
                "\\lispdownlink{A function of one variable}{(|bcDraw2Dfun|)}"))
    (|bcHt| (MAKESTRING "\\space{2}y = f(x)\\newline"))
    (|bcHt| (MAKESTRING
                "\\lispdownlink{A parametrically defined curve}{(|bcDraw2Dpar|)}"))
    (|bcHt| (MAKESTRING "\\space{2}(x(t), y(t))\\newline"))
    (|bcHt| (MAKESTRING
                "\\lispdownlink{A solution to a polynomial equation}{(|bcDraw2DSolve|)}"))
    (|bcHt| (MAKESTRING "\\space{2} p(x,y) = 0\\newline"))
    (|bcHt| (MAKESTRING "\\vspace{1}\\newline "))
    (|bcHt| (MAKESTRING
                "\\centerline{{\\em Three Dimensional Surfaces}}\\newline\\newline"))
    (|bcHt| (MAKESTRING
                "\\lispdownlink{A function of two variables}{(|bcDraw3Dfun|)}"))
    (|bcHt| (MAKESTRING "\\space{2} z = f(x,y)\\newline"))
    (|bcHt| (MAKESTRING
                "\\lispdownlink{A parametrically defined tube}{(|bcDraw3Dpar|)}"))
    (|bcHt| (MAKESTRING "\\space{2}(x(t), y(t), z(t))\\newline"))
    (|bcHt| (MAKESTRING
                "\\lispdownlink{A parameterically defined surface}{(|bcDraw3Dpar1|)}"))
    (|bcHt| (MAKESTRING "\\space{2}(x(u,v), y(u,v), z(u,v))\\newline"))
    (|htShowPage|)))

;bcDraw2Dfun() ==
;  htInitPage('"Draw Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain F (Float))
;       (isDomain SY (Symbol)))
;    (text
;      "\centerline{Drawing {\em y = f(x)}}\newline "
;      "\centerline{where {\em y} is the dependent variable and}\newline "
;      "\centerline{where {\em x} is the independent variable}\vspace{1}\newline "
;      "\menuitemstyle{}\tab{2}What {\em function} f would you like to draw?\newline\tab{2}")
;    (bcStrings (55 "x*cos(x)" function EM))
;    (text . "\vspace{1}\newline\menuitemstyle{}\tab{2}Enter {\em dependent} variable:")
;    (bcStrings (6 y dependent SY))
;    (text . "\newline\vspace{1}\newline ")
;    (text . "\menuitemstyle{}\tab{2}Enter {\em independent} variable and {\em range}:\newline\tab{2} ")
;    (text . "{\em Variable:}")
;    (bcStrings (6 x ind SY))
;    (text . "ranges {\em from:}")
;    (bcStrings (9 0 from1 F))
;    (text . "{\em to:}")
;    (bcStrings (9 30 to1 F))
;    (text
;      "\indent{0}\vspace{1}\newline\menuitemstyle{}\tab{2} "
;      "Optionally enter a {\em title} for your curve:"
;      )
;    (bcStrings (15 "y = x*cos(x)" title S))
;    (text . "\indent{0}")
;    (doneButton "Continue" bcDraw2DfunGen)
;    (text . "{}"))
;  htShowPage()

(DEFUN |bcDraw2Dfun| ()
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| (MAKESTRING "Draw Basic Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| F (|Float|)) (|isDomain| SY (|Symbol|)))
          (|text| "\\centerline{Drawing {\\em y = f(x)}}\\newline "
                  "\\centerline{where {\\em y} is the dependent variable and}\\newline "
                  "\\centerline{where {\\em x} is the independent variable}\\vspace{1}\\newline "
                  "\\menuitemstyle{}\\tab{2}What {\\em function} f would you like to draw?\\newline\\tab{2}")
          (|bcStrings| (55 "x*cos(x)" |function| EM))
          (|text|
           . "\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}Enter {\\em dependent} variable:")
          (|bcStrings| (6 |y| |dependent| SY))
          (|text| . "\\newline\\vspace{1}\\newline ")
          (|text|
           . "\\menuitemstyle{}\\tab{2}Enter {\\em independent} variable and {\\em range}:\\newline\\tab{2} ")
          (|text| . "{\\em Variable:}") (|bcStrings| (6 |x| |ind| SY))
          (|text| . "ranges {\\em from:}")
          (|bcStrings| (9 0 |from1| F)) (|text| . "{\\em to:}")
          (|bcStrings| (9 30 |to1| F))
          (|text| "\\indent{0}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2} "
                  "Optionally enter a {\\em title} for your curve:")
          (|bcStrings| (15 "y = x*cos(x)" |title| S))
          (|text| . "\\indent{0}")
          (|doneButton| "Continue" |bcDraw2DfunGen|) (|text| . "{}")))
    (|htShowPage|)))

;bcDraw2DfunGen htPage ==
;  fun := htpLabelInputString(htPage,'function)
;  dep := htpLabelInputString(htPage,'dependent)
;  ind := htpLabelInputString(htPage,'ind)
;  from1 := htpLabelInputString(htPage,'from1)
;  to1 := htpLabelInputString(htPage,'to1)
;  title := htpLabelInputString(htPage,'title)
;  if (title ^= '"") then
;    titlePart := STRCONC('"{}",'"title ==_"",title,'"_"")
;    bcFinish('"draw",fun,bcDrawIt2(ind,from1,to1),titlePart)
;  else
;    bcFinish('"draw",fun,bcDrawIt2(ind,from1,to1))

(DEFUN |bcDraw2DfunGen| (|htPage|)
  (PROG (|fun| |dep| |ind| |from1| |to1| |title| |titlePart|)
    (RETURN
      (PROGN
        (SPADLET |fun| (|htpLabelInputString| |htPage| '|function|))
        (SPADLET |dep| (|htpLabelInputString| |htPage| '|dependent|))
        (SPADLET |ind| (|htpLabelInputString| |htPage| '|ind|))
        (SPADLET |from1| (|htpLabelInputString| |htPage| '|from1|))
        (SPADLET |to1| (|htpLabelInputString| |htPage| '|to1|))
        (SPADLET |title| (|htpLabelInputString| |htPage| '|title|))
        (COND
          ((NEQUAL |title| (MAKESTRING ""))
           (SPADLET |titlePart|
                    (STRCONC (MAKESTRING "{}")
                             (MAKESTRING "title ==\"") |title|
                             (MAKESTRING "\"")))
           (|bcFinish| (MAKESTRING "draw") |fun|
               (|bcDrawIt2| |ind| |from1| |to1|) |titlePart|))
          ('T
           (|bcFinish| (MAKESTRING "draw") |fun|
               (|bcDrawIt2| |ind| |from1| |to1|))))))))

;bcDraw2Dpar() ==
;  htInitPage('"Draw Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain F (Float))
;       (isDomain SY (Symbol)))
;    (text
;      "\centerline{Drawing a parametrically defined curve:}\newline "
;      "\centerline{{\em ( f1(t), f2(t) )}}\newline "
;      "\centerline{in terms of two functions {\em f1} and {\em f2}}"
;      "\centerline{and an independent variable {\em t}}\vspace{1}\newline"
;      "\menuitemstyle{}\tab{2}Enter the two {\em functions:}")
;    (text . "\newline\tab{2}{\em Function 1:}")
;    (bcStrings (44 "-9*sin(4*t/5)" function1 EM))
;    (text . "\newline\tab{2}{\em Function 2:}")
;    (bcStrings (44 "8*sin(t)" function2 EM))
;    (text ."\vspace{1}\newline\menuitemstyle{}\tab{2}Enter {\em independent} variable and range:\newline\tab{2} ")
;    (text . "{\em Variable:}")
;    (bcStrings (6 t ind SY))
;    (text . "ranges {\em from:}")
;    (bcStrings (9 "-5*\%pi" from1 F))
;    (text . "{\em to:}")
;    (bcStrings (9 "5*\%pi" to1 F))
;    (text
;      "\vspace{1}\newline\menuitemstyle{}\tab{2}"
;      "Optionally enter a {\em title} for your curve:")
;    (bcStrings (15 "Lissajous" title S))
;    (text . "\indent{0}")
;    (doneButton "Continue" bcDraw2DparGen))
;  htShowPage()

(DEFUN |bcDraw2Dpar| ()
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| (MAKESTRING "Draw Basic Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| F (|Float|)) (|isDomain| SY (|Symbol|)))
          (|text| "\\centerline{Drawing a parametrically defined curve:}\\newline "
                  "\\centerline{{\\em ( f1(t), f2(t) )}}\\newline "
                  "\\centerline{in terms of two functions {\\em f1} and {\\em f2}}"
                  "\\centerline{and an independent variable {\\em t}}\\vspace{1}\\newline"
                  "\\menuitemstyle{}\\tab{2}Enter the two {\\em functions:}")
          (|text| . "\\newline\\tab{2}{\\em Function 1:}")
          (|bcStrings| (44 "-9*sin(4*t/5)" |function1| EM))
          (|text| . "\\newline\\tab{2}{\\em Function 2:}")
          (|bcStrings| (44 "8*sin(t)" |function2| EM))
          (|text|
           . "\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}Enter {\\em independent} variable and range:\\newline\\tab{2} ")
          (|text| . "{\\em Variable:}") (|bcStrings| (6 |t| |ind| SY))
          (|text| . "ranges {\\em from:}")
          (|bcStrings| (9 "-5*\\%pi" |from1| F))
          (|text| . "{\\em to:}") (|bcStrings| (9 "5*\\%pi" |to1| F))
          (|text| "\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}"
                  "Optionally enter a {\\em title} for your curve:")
          (|bcStrings| (15 "Lissajous" |title| S))
          (|text| . "\\indent{0}")
          (|doneButton| "Continue" |bcDraw2DparGen|)))
    (|htShowPage|)))

;bcDraw2DparGen htPage ==
;  fun1 := htpLabelInputString(htPage,'function1)
;  fun2 := htpLabelInputString(htPage,'function2)
;  ind := htpLabelInputString(htPage,'ind)
;  from1 := htpLabelInputString(htPage,'from1)
;  to1 := htpLabelInputString(htPage,'to1)
;  title := htpLabelInputString(htPage,'title)
;  curvePart := STRCONC('"curve(",'"{}",fun1,'",{}",fun2,'")")
;  if (title ^= '"") then
;    titlePart := (title = '"" => nil; STRCONC('"{}",'"title ==_"",title,'"_""))
;    bcFinish('"draw",curvePart,bcDrawIt2(ind,from1,to1),titlePart)
;  else
;    bcFinish('"draw",curvePart,bcDrawIt2(ind,from1,to1))

(DEFUN |bcDraw2DparGen| (|htPage|)
  (PROG (|fun1| |fun2| |ind| |from1| |to1| |title| |curvePart|
                |titlePart|)
    (RETURN
      (PROGN
        (SPADLET |fun1| (|htpLabelInputString| |htPage| '|function1|))
        (SPADLET |fun2| (|htpLabelInputString| |htPage| '|function2|))
        (SPADLET |ind| (|htpLabelInputString| |htPage| '|ind|))
        (SPADLET |from1| (|htpLabelInputString| |htPage| '|from1|))
        (SPADLET |to1| (|htpLabelInputString| |htPage| '|to1|))
        (SPADLET |title| (|htpLabelInputString| |htPage| '|title|))
        (SPADLET |curvePart|
                 (STRCONC (MAKESTRING "curve(") (MAKESTRING "{}")
                          |fun1| (MAKESTRING ",{}") |fun2|
                          (MAKESTRING ")")))
        (COND
          ((NEQUAL |title| (MAKESTRING ""))
           (SPADLET |titlePart|
                    (COND
                      ((BOOT-EQUAL |title| (MAKESTRING "")) NIL)
                      ('T
                       (STRCONC (MAKESTRING "{}")
                                (MAKESTRING "title ==\"") |title|
                                (MAKESTRING "\"")))))
           (|bcFinish| (MAKESTRING "draw") |curvePart|
               (|bcDrawIt2| |ind| |from1| |to1|) |titlePart|))
          ('T
           (|bcFinish| (MAKESTRING "draw") |curvePart|
               (|bcDrawIt2| |ind| |from1| |to1|))))))))

;bcDraw2DSolve() ==
;  htInitPage('"Draw Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain F (Float))
;       (isDomain SY (Symbol)))
;    (text
;      "\centerline{Plotting the solution to {\em p(x,y) = 0}, where} "
;      "\centerline{{\em p} is a polynomial in two variables {\em x} and {\em y}}"
;      "\vspace{1}\newline\menuitemstyle{}\tab{2}Enter the {\em polynomial} p:"
;      "\newline\tab{2}")
;    (bcStrings (40 "y**2+7*x*y-(x**3+16*x)" function EM))
;    (text . "\vspace{1}\newline\menuitemstyle{}\tab{2}Enter the {\em variables}:")
;    (text . "\newline\tab{2}{\em Variable 1:} ")
;    (bcStrings (4 x independent1 SY))
;    (text . "ranges {\em from:}")
;    (bcStrings (9 -15 from1 F))
;    (text . "{\em to:}")
;    (bcStrings (9 10 to1 F))
;    (text . "\newline\tab{2}{\em Variable 2:} ")
;    (bcStrings (4 y independent2 SY))
;    (text . "ranges {\em from:}")
;    (bcStrings (9 -10 from2 F))
;    (text . "{\em to:}")
;    (bcStrings (9 50 to2 F))
;    (text
;      "\indent{0}\vspace{1}\newline\menuitemstyle{}\tab{2} "
;      "Optionally enter a {\em title} for your curve:")
;    (bcStrings (15 "" title S))
;    (text . "\indent{0}"))
;  htMakeDoneButton('"Continue",'bcDraw2DSolveGen)
;  htShowPage()

(DEFUN |bcDraw2DSolve| ()
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| (MAKESTRING "Draw Basic Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| F (|Float|)) (|isDomain| SY (|Symbol|)))
          (|text| "\\centerline{Plotting the solution to {\\em p(x,y) = 0}, where} "
                  "\\centerline{{\\em p} is a polynomial in two variables {\\em x} and {\\em y}}"
                  "\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}Enter the {\\em polynomial} p:"
                  "\\newline\\tab{2}")
          (|bcStrings| (40 "y**2+7*x*y-(x**3+16*x)" |function| EM))
          (|text|
           . "\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}Enter the {\\em variables}:")
          (|text| . "\\newline\\tab{2}{\\em Variable 1:} ")
          (|bcStrings| (4 |x| |independent1| SY))
          (|text| . "ranges {\\em from:}")
          (|bcStrings| (9 -15 |from1| F)) (|text| . "{\\em to:}")
          (|bcStrings| (9 10 |to1| F))
          (|text| . "\\newline\\tab{2}{\\em Variable 2:} ")
          (|bcStrings| (4 |y| |independent2| SY))
          (|text| . "ranges {\\em from:}")
          (|bcStrings| (9 -10 |from2| F)) (|text| . "{\\em to:}")
          (|bcStrings| (9 50 |to2| F))
          (|text| "\\indent{0}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2} "
                  "Optionally enter a {\\em title} for your curve:")
          (|bcStrings| (15 "" |title| S)) (|text| . "\\indent{0}")))
    (|htMakeDoneButton| (MAKESTRING "Continue") '|bcDraw2DSolveGen|)
    (|htShowPage|)))

;bcDraw2DSolveGen htPage ==
;  fun := htpLabelInputString(htPage,'function)
;  ind1 := htpLabelInputString(htPage,'independent1)
;  from1 := htpLabelInputString(htPage,'from1)
;  to1 := htpLabelInputString(htPage,'to1)
;  ind2 := htpLabelInputString(htPage,'independent2)
;  from2 := htpLabelInputString(htPage,'from2)
;  to2 := htpLabelInputString(htPage,'to2)
;  title := htpLabelInputString(htPage,'title)
;  clipPart := STRCONC('"{}",'"range==[{}",from1,'"..",to1,",{}",from2,'"..",to2,'"]")
;  if (title ^= '"") then
;    titlePart := (title = '"" => nil; STRCONC('"{}",'"title ==_"",title,'"_""))
;    bcFinish('"draw",STRCONC(fun,'" = 0 "),ind1,ind2,clipPart,titlePart)
;  else
;    bcFinish('"draw",STRCONC(fun,'" = 0 "),ind1,ind2,clipPart)

(DEFUN |bcDraw2DSolveGen| (|htPage|)
  (PROG (|fun| |ind1| |from1| |to1| |ind2| |from2| |to2| |title|
               |clipPart| |titlePart|)
    (RETURN
      (PROGN
        (SPADLET |fun| (|htpLabelInputString| |htPage| '|function|))
        (SPADLET |ind1|
                 (|htpLabelInputString| |htPage| '|independent1|))
        (SPADLET |from1| (|htpLabelInputString| |htPage| '|from1|))
        (SPADLET |to1| (|htpLabelInputString| |htPage| '|to1|))
        (SPADLET |ind2|
                 (|htpLabelInputString| |htPage| '|independent2|))
        (SPADLET |from2| (|htpLabelInputString| |htPage| '|from2|))
        (SPADLET |to2| (|htpLabelInputString| |htPage| '|to2|))
        (SPADLET |title| (|htpLabelInputString| |htPage| '|title|))
        (SPADLET |clipPart|
                 (STRCONC (MAKESTRING "{}") (MAKESTRING "range==[{}")
                          |from1| (MAKESTRING "..") |to1| '|,{}|
                          |from2| (MAKESTRING "..") |to2|
                          (MAKESTRING "]")))
        (COND
          ((NEQUAL |title| (MAKESTRING ""))
           (SPADLET |titlePart|
                    (COND
                      ((BOOT-EQUAL |title| (MAKESTRING "")) NIL)
                      ('T
                       (STRCONC (MAKESTRING "{}")
                                (MAKESTRING "title ==\"") |title|
                                (MAKESTRING "\"")))))
           (|bcFinish| (MAKESTRING "draw")
               (STRCONC |fun| (MAKESTRING " = 0 ")) |ind1| |ind2|
               |clipPart| |titlePart|))
          ('T
           (|bcFinish| (MAKESTRING "draw")
               (STRCONC |fun| (MAKESTRING " = 0 ")) |ind1| |ind2|
               |clipPart|)))))))

;bcDraw3Dfun() ==
;  htInitPage('"Three Dimensional Draw Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain F (Float))
;       (isDomain SY (Symbol)))
;    (text
;      "\centerline{Drawing {\em z = f(x,y)}}\newline "
;      "\centerline{where {\em z} is the dependent variable and}\newline "
;      "\centerline{where {\em x, y} are the independent variables}\vspace{1}\newline\menuitemstyle{}\tab{2} "
;      "What {\em function} f which you like to draw?\newline\tab{2}")
;    (bcStrings (55 "exp(cos(x-y)-sin(x*y))-2" function EM))
;    (text . "\newline\menuitemstyle{}\tab{2}Enter {\em dependent} variable:")
;    (bcStrings (6 z dependent SY))
;    (text
;      "\vspace{1}\newline\menuitemstyle{}\tab{2}"
;      "Enter {\em independent} variables and ranges:\newline\tab{2} "
;      "{\em Variable:}")
;    (bcStrings (6 x independent1 SY))
;    (text . "ranges {\em from:}")
;    (bcStrings (9 -5 from1 F))
;    (text . "{\em to:}")
;    (bcStrings (9 5 to1 F))
;    (text . "\newline\tab{2}{\em Variable:}")
;    (bcStrings (6 y independent2 SY))
;    (text . "ranges {\em from:}")
;    (bcStrings (9 -5 from2 F))
;    (text . "{\em to:}")
;    (bcStrings (9 5 to2 F))
;    (text
;      "\indent{0}\vspace{1}\newline\menuitemstyle{}\tab{2} "
;      "Optionally enter a {\em title} for your surface:")
;    (bcStrings (15 "" title S))
;    (text . "\indent{0}")
;    (doneButton "Continue" bcDraw3DfunGen))
;  htShowPage()

(DEFUN |bcDraw3Dfun| ()
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| (MAKESTRING "Three Dimensional Draw Basic Command")
        NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| F (|Float|)) (|isDomain| SY (|Symbol|)))
          (|text| "\\centerline{Drawing {\\em z = f(x,y)}}\\newline "
                  "\\centerline{where {\\em z} is the dependent variable and}\\newline "
                  "\\centerline{where {\\em x, y} are the independent variables}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2} "
                  "What {\\em function} f which you like to draw?\\newline\\tab{2}")
          (|bcStrings| (55 "exp(cos(x-y)-sin(x*y))-2" |function| EM))
          (|text|
           . "\\newline\\menuitemstyle{}\\tab{2}Enter {\\em dependent} variable:")
          (|bcStrings| (6 |z| |dependent| SY))
          (|text| "\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}"
                  "Enter {\\em independent} variables and ranges:\\newline\\tab{2} "
                  "{\\em Variable:}")
          (|bcStrings| (6 |x| |independent1| SY))
          (|text| . "ranges {\\em from:}")
          (|bcStrings| (9 -5 |from1| F)) (|text| . "{\\em to:}")
          (|bcStrings| (9 5 |to1| F))
          (|text| . "\\newline\\tab{2}{\\em Variable:}")
          (|bcStrings| (6 |y| |independent2| SY))
          (|text| . "ranges {\\em from:}")
          (|bcStrings| (9 -5 |from2| F)) (|text| . "{\\em to:}")
          (|bcStrings| (9 5 |to2| F))
          (|text| "\\indent{0}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2} "
                  "Optionally enter a {\\em title} for your surface:")
          (|bcStrings| (15 "" |title| S)) (|text| . "\\indent{0}")
          (|doneButton| "Continue" |bcDraw3DfunGen|)))
    (|htShowPage|)))

;bcDraw3DfunGen htPage ==
;  fun := htpLabelInputString(htPage,'function)
;  dep := htpLabelInputString(htPage,'dependent)
;  ind1 := htpLabelInputString(htPage,'independent1)
;  from1 := htpLabelInputString(htPage,'from1)
;  to1 := htpLabelInputString(htPage,'to1)
;  ind2 := htpLabelInputString(htPage,'independent2)
;  from2 := htpLabelInputString(htPage,'from2)
;  to2 := htpLabelInputString(htPage,'to2)
;  title := htpLabelInputString(htPage,'title)
;  if (title ^= '"") then
;    titlePart := (title = '"" => nil;STRCONC('"{}",'"title ==_"",title,'"_""))
;    bcFinish('"draw",fun,bcDrawIt2(ind1,from1,to1),bcDrawIt2(ind2,from2,to2),titlePart)
;  else
;    bcFinish('"draw",fun,bcDrawIt2(ind1,from1,to1),bcDrawIt2(ind2,from2,to2))

(DEFUN |bcDraw3DfunGen| (|htPage|)
  (PROG (|fun| |dep| |ind1| |from1| |to1| |ind2| |from2| |to2| |title|
               |titlePart|)
    (RETURN
      (PROGN
        (SPADLET |fun| (|htpLabelInputString| |htPage| '|function|))
        (SPADLET |dep| (|htpLabelInputString| |htPage| '|dependent|))
        (SPADLET |ind1|
                 (|htpLabelInputString| |htPage| '|independent1|))
        (SPADLET |from1| (|htpLabelInputString| |htPage| '|from1|))
        (SPADLET |to1| (|htpLabelInputString| |htPage| '|to1|))
        (SPADLET |ind2|
                 (|htpLabelInputString| |htPage| '|independent2|))
        (SPADLET |from2| (|htpLabelInputString| |htPage| '|from2|))
        (SPADLET |to2| (|htpLabelInputString| |htPage| '|to2|))
        (SPADLET |title| (|htpLabelInputString| |htPage| '|title|))
        (COND
          ((NEQUAL |title| (MAKESTRING ""))
           (SPADLET |titlePart|
                    (COND
                      ((BOOT-EQUAL |title| (MAKESTRING "")) NIL)
                      ('T
                       (STRCONC (MAKESTRING "{}")
                                (MAKESTRING "title ==\"") |title|
                                (MAKESTRING "\"")))))
           (|bcFinish| (MAKESTRING "draw") |fun|
               (|bcDrawIt2| |ind1| |from1| |to1|)
               (|bcDrawIt2| |ind2| |from2| |to2|) |titlePart|))
          ('T
           (|bcFinish| (MAKESTRING "draw") |fun|
               (|bcDrawIt2| |ind1| |from1| |to1|)
               (|bcDrawIt2| |ind2| |from2| |to2|))))))))

;bcDraw3Dpar() ==
;  htInitPage('"Draw Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain F (Float))
;       (isDomain SY (Symbol)))
;    (text
;      "\centerline{Drawing a parametrically defined curve:"
;      "{\em ( f1(t), f2(t), f3(t) )}}\newline "
;      "\centerline{in terms of three functions {\em f1}, {\em f2}, and {\em f3}}\newline "
;      "\centerline{and an independent variable {\em t}}\vspace{1}\newline\menuitemstyle{}\tab{2} "
;      "Enter the three {\em functions} of the independent variable:")
;    (text . "\newline\tab{2}{\em Function f1:}")
;    (bcStrings (42 "1.3*cos(2*t)*cos(4*t) + sin(4*t)*cos(t)" function1 EM))
;    (text . "\newline\tab{2}{\em Function f2:}")
;    (bcStrings  (42 "1.3*sin(2*t)*cos(4*t) - sin(4*t)*sin(t)" function2 EM))
;    (text . "\newline\tab{2}{\em Function f3:}")
;    (bcStrings  (42 "2.5*cos(4*t)" function3 EM))
;    (text ."\vspace{1}\newline\menuitemstyle{}\tab{2}Enter {\em independent} variable and range:\newline\tab{2} ")
;    (text ."{\em Variable:}")
;    (bcStrings (6 t ind SY))
;    (text . "ranges {\em from:}")
;    (bcStrings (9 0 from1 F))
;    (text "{\em to:}")
;    (bcStrings (9 "4*\%pi" to1 F))
;    (text
;      "\indent{0}\vspace{1}\newline\menuitemstyle{}\tab{2} "
;      "Optionally enter a {\em title} for your surface:")
;    (bcStrings (15 "knot" title S))
;    (text . "\indent{0}")
;    (doneButton "Continue" bcDraw3DparGen))
;  htShowPage()

(DEFUN |bcDraw3Dpar| ()
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| (MAKESTRING "Draw Basic Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| F (|Float|)) (|isDomain| SY (|Symbol|)))
          (|text| "\\centerline{Drawing a parametrically defined curve:"
                  "{\\em ( f1(t), f2(t), f3(t) )}}\\newline "
                  "\\centerline{in terms of three functions {\\em f1}, {\\em f2}, and {\\em f3}}\\newline "
                  "\\centerline{and an independent variable {\\em t}}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2} "
                  "Enter the three {\\em functions} of the independent variable:")
          (|text| . "\\newline\\tab{2}{\\em Function f1:}")
          (|bcStrings|
              (42 "1.3*cos(2*t)*cos(4*t) + sin(4*t)*cos(t)" |function1|
               EM))
          (|text| . "\\newline\\tab{2}{\\em Function f2:}")
          (|bcStrings|
              (42 "1.3*sin(2*t)*cos(4*t) - sin(4*t)*sin(t)" |function2|
               EM))
          (|text| . "\\newline\\tab{2}{\\em Function f3:}")
          (|bcStrings| (42 "2.5*cos(4*t)" |function3| EM))
          (|text|
           . "\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}Enter {\\em independent} variable and range:\\newline\\tab{2} ")
          (|text| . "{\\em Variable:}") (|bcStrings| (6 |t| |ind| SY))
          (|text| . "ranges {\\em from:}")
          (|bcStrings| (9 0 |from1| F)) (|text| "{\\em to:}")
          (|bcStrings| (9 "4*\\%pi" |to1| F))
          (|text| "\\indent{0}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2} "
                  "Optionally enter a {\\em title} for your surface:")
          (|bcStrings| (15 "knot" |title| S)) (|text| . "\\indent{0}")
          (|doneButton| "Continue" |bcDraw3DparGen|)))
    (|htShowPage|)))

;bcDraw3DparGen htPage ==
;  fun1 := htpLabelInputString(htPage,'function1)
;  fun2 := htpLabelInputString(htPage,'function2)
;  fun3 := htpLabelInputString(htPage,'function3)
;  ind := htpLabelInputString(htPage,'ind)
;  from1 := htpLabelInputString(htPage,'from1)
;  to1 := htpLabelInputString(htPage,'to1)
;  title := htpLabelInputString(htPage,'title)
;  curvePart := STRCONC('"curve(",'"{}",fun1,'",{}",fun2,'",{}",fun3,'")")
;  tubePart := '"{}tubeRadius==.25,{}tubePoints==16"
;  if (title ^= '"") then
;    titlePart := (title = '"" => nil; STRCONC('"{}",'"title ==_"",title,'"_""))
;    bcFinish('"draw",curvePart,bcDrawIt2(ind,from1,to1),tubePart,titlePart)
;  else
;    bcFinish('"draw",curvePart,bcDrawIt2(ind,from1,to1),tubePart)

(DEFUN |bcDraw3DparGen| (|htPage|)
  (PROG (|fun1| |fun2| |fun3| |ind| |from1| |to1| |title| |curvePart|
                |tubePart| |titlePart|)
    (RETURN
      (PROGN
        (SPADLET |fun1| (|htpLabelInputString| |htPage| '|function1|))
        (SPADLET |fun2| (|htpLabelInputString| |htPage| '|function2|))
        (SPADLET |fun3| (|htpLabelInputString| |htPage| '|function3|))
        (SPADLET |ind| (|htpLabelInputString| |htPage| '|ind|))
        (SPADLET |from1| (|htpLabelInputString| |htPage| '|from1|))
        (SPADLET |to1| (|htpLabelInputString| |htPage| '|to1|))
        (SPADLET |title| (|htpLabelInputString| |htPage| '|title|))
        (SPADLET |curvePart|
                 (STRCONC (MAKESTRING "curve(") (MAKESTRING "{}")
                          |fun1| (MAKESTRING ",{}") |fun2|
                          (MAKESTRING ",{}") |fun3| (MAKESTRING ")")))
        (SPADLET |tubePart|
                 (MAKESTRING "{}tubeRadius==.25,{}tubePoints==16"))
        (COND
          ((NEQUAL |title| (MAKESTRING ""))
           (SPADLET |titlePart|
                    (COND
                      ((BOOT-EQUAL |title| (MAKESTRING "")) NIL)
                      ('T
                       (STRCONC (MAKESTRING "{}")
                                (MAKESTRING "title ==\"") |title|
                                (MAKESTRING "\"")))))
           (|bcFinish| (MAKESTRING "draw") |curvePart|
               (|bcDrawIt2| |ind| |from1| |to1|) |tubePart|
               |titlePart|))
          ('T
           (|bcFinish| (MAKESTRING "draw") |curvePart|
               (|bcDrawIt2| |ind| |from1| |to1|) |tubePart|)))))))

;bcDraw3Dpar1() ==
;  htInitPage('"Draw Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain F (Float))
;       (isDomain SY (Symbol)))
;    (text
;      "\centerline{Drawing a parametrically defined surface:}\newline "
;      "\centerline{{\em ( f1(u,v), f2(u,v), f3(u,v) )}}\newline "
;      "\centerline{in terms of three functions {\em f1}, {\em f2}, and {\em f3}}\newline "
;      "\centerline{and two independent variables {\em u} and {\em v}}\vspace{1}\newline\menuitemstyle{}\tab{2}"
;      "Enter the three {\em functions} of the independent variables:")
;    (text . "\newline\tab{2}")
;    (text . "{\em Function f1:}")
;    (bcStrings (43 "u*sin(v)" function1 EM))
;    (text . "\newline\tab{2}")
;    (text . "{\em Function f2:}")
;    (bcStrings (43 "v*cos(u)" function2 EM))
;    (text . "\newline\tab{2}")
;    (text . "{\em Function f3:}")
;    (bcStrings (43 "u*cos(v)" function3 EM))
;    (text . "\newline\menuitemstyle{}\tab{2}Enter independent {\em variables} and ranges:")
;    (text . "\newline\tab{2}")
;    (text . "{\em Variable 1:}")
;    (bcStrings (5 u ind1 SY))
;    (text . "ranges {\em from:}")
;    (bcStrings (9 "-\%pi" from1 F))
;    (text . "{\em to:}")
;    (bcStrings (9 "\%pi" to1 F))
;    (text . "\newline\tab{2}")
;    (text . "{\em Variable 2:}")
;    (bcStrings (5 v ind2 SY))
;    (text . "ranges {\em from:}")
;    (bcStrings (9 "-\%pi/2" from2 F))
;    (text . "{\em to:}")
;    (bcStrings (9 "\%pi/2" to2 F))
;    (text
;      "\indent{0}\newline\menuitemstyle{}\tab{2} "
;      "Optionally enter a {\em title} for your surface:")
;    (bcStrings (15 "surface" title S))
;    (text . "\indent{0}"))
;  htMakeDoneButton ('"Continue",'bcDraw3Dpar1Gen)
;  htShowPage()

(DEFUN |bcDraw3Dpar1| ()
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| (MAKESTRING "Draw Basic Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| F (|Float|)) (|isDomain| SY (|Symbol|)))
          (|text| "\\centerline{Drawing a parametrically defined surface:}\\newline "
                  "\\centerline{{\\em ( f1(u,v), f2(u,v), f3(u,v) )}}\\newline "
                  "\\centerline{in terms of three functions {\\em f1}, {\\em f2}, and {\\em f3}}\\newline "
                  "\\centerline{and two independent variables {\\em u} and {\\em v}}\\vspace{1}\\newline\\menuitemstyle{}\\tab{2}"
                  "Enter the three {\\em functions} of the independent variables:")
          (|text| . "\\newline\\tab{2}")
          (|text| . "{\\em Function f1:}")
          (|bcStrings| (43 "u*sin(v)" |function1| EM))
          (|text| . "\\newline\\tab{2}")
          (|text| . "{\\em Function f2:}")
          (|bcStrings| (43 "v*cos(u)" |function2| EM))
          (|text| . "\\newline\\tab{2}")
          (|text| . "{\\em Function f3:}")
          (|bcStrings| (43 "u*cos(v)" |function3| EM))
          (|text|
           . "\\newline\\menuitemstyle{}\\tab{2}Enter independent {\\em variables} and ranges:")
          (|text| . "\\newline\\tab{2}")
          (|text| . "{\\em Variable 1:}")
          (|bcStrings| (5 |u| |ind1| SY))
          (|text| . "ranges {\\em from:}")
          (|bcStrings| (9 "-\\%pi" |from1| F)) (|text| . "{\\em to:}")
          (|bcStrings| (9 "\\%pi" |to1| F))
          (|text| . "\\newline\\tab{2}")
          (|text| . "{\\em Variable 2:}")
          (|bcStrings| (5 |v| |ind2| SY))
          (|text| . "ranges {\\em from:}")
          (|bcStrings| (9 "-\\%pi/2" |from2| F))
          (|text| . "{\\em to:}") (|bcStrings| (9 "\\%pi/2" |to2| F))
          (|text| "\\indent{0}\\newline\\menuitemstyle{}\\tab{2} "
                  "Optionally enter a {\\em title} for your surface:")
          (|bcStrings| (15 "surface" |title| S))
          (|text| . "\\indent{0}")))
    (|htMakeDoneButton| (MAKESTRING "Continue") '|bcDraw3Dpar1Gen|)
    (|htShowPage|)))

;bcDraw3Dpar1Gen htPage ==
;  fun1 := htpLabelInputString(htPage,'function1)
;  fun2 := htpLabelInputString(htPage,'function2)
;  fun3 := htpLabelInputString(htPage,'function3)
;  ind1 := htpLabelInputString(htPage,'ind1)
;  from1 := htpLabelInputString(htPage,'from1)
;  to1 := htpLabelInputString(htPage,'to1)
;  ind2 := htpLabelInputString(htPage,'ind2)
;  from2 := htpLabelInputString(htPage,'from2)
;  to2 := htpLabelInputString(htPage,'to2)
;  title := htpLabelInputString(htPage,'title)
;  r1 := bcDrawIt2(ind1,from1,to1)
;  r2 := bcDrawIt2(ind2,from2,to2)
;  surfacePart := STRCONC('"surface(",'"{}",fun1,'",{}",fun2,'",{}",fun3,'")")
;  if (title ^= '"") then
;    titlePart := (title = '"" => nil; STRCONC('"{}",'"title ==_"",title,'"_""))
;    bcFinish('"draw",surfacePart,r1,r2,titlePart)
;  else
;    bcFinish('"draw",surfacePart,r1,r2)

(DEFUN |bcDraw3Dpar1Gen| (|htPage|)
  (PROG (|fun1| |fun2| |fun3| |ind1| |from1| |to1| |ind2| |from2| |to2|
                |title| |r1| |r2| |surfacePart| |titlePart|)
    (RETURN
      (PROGN
        (SPADLET |fun1| (|htpLabelInputString| |htPage| '|function1|))
        (SPADLET |fun2| (|htpLabelInputString| |htPage| '|function2|))
        (SPADLET |fun3| (|htpLabelInputString| |htPage| '|function3|))
        (SPADLET |ind1| (|htpLabelInputString| |htPage| '|ind1|))
        (SPADLET |from1| (|htpLabelInputString| |htPage| '|from1|))
        (SPADLET |to1| (|htpLabelInputString| |htPage| '|to1|))
        (SPADLET |ind2| (|htpLabelInputString| |htPage| '|ind2|))
        (SPADLET |from2| (|htpLabelInputString| |htPage| '|from2|))
        (SPADLET |to2| (|htpLabelInputString| |htPage| '|to2|))
        (SPADLET |title| (|htpLabelInputString| |htPage| '|title|))
        (SPADLET |r1| (|bcDrawIt2| |ind1| |from1| |to1|))
        (SPADLET |r2| (|bcDrawIt2| |ind2| |from2| |to2|))
        (SPADLET |surfacePart|
                 (STRCONC (MAKESTRING "surface(") (MAKESTRING "{}")
                          |fun1| (MAKESTRING ",{}") |fun2|
                          (MAKESTRING ",{}") |fun3| (MAKESTRING ")")))
        (COND
          ((NEQUAL |title| (MAKESTRING ""))
           (SPADLET |titlePart|
                    (COND
                      ((BOOT-EQUAL |title| (MAKESTRING "")) NIL)
                      ('T
                       (STRCONC (MAKESTRING "{}")
                                (MAKESTRING "title ==\"") |title|
                                (MAKESTRING "\"")))))
           (|bcFinish| (MAKESTRING "draw") |surfacePart| |r1| |r2|
               |titlePart|))
          ('T (|bcFinish| (MAKESTRING "draw") |surfacePart| |r1| |r2|)))))))

;bcSeries() ==
;  htInitPage('"Series Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain S (String))
;       (isDomain SY (Symbol)))
;   (text .  "Create a series by: ")
;   (text . "\beginmenu")
;   (text . "\item ")
;   (bcLinks ("\menuitemstyle{Expansion}" "" bcSeriesExpansion NILl))
;   (text . "\tab{11}Expand a function in a series around a point")
;   (text . "\item ")
;   (bcLinks ("\menuitemstyle{Formula}"  "" bcSeriesByFormula NIL))
;   (text . "\tab{11}Give a formula for the {\em i}'th coefficient")
;   (text . "\endmenu"))
;  htShowPage()

(DEFUN |bcSeries| ()
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| (MAKESTRING "Series Basic Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
          (|text| . "Create a series by: ") (|text| . "\\beginmenu")
          (|text| . "\\item ")
          (|bcLinks|
              ("\\menuitemstyle{Expansion}" "" |bcSeriesExpansion|
               |NILl|))
          (|text|
           . "\\tab{11}Expand a function in a series around a point")
          (|text| . "\\item ")
          (|bcLinks|
              ("\\menuitemstyle{Formula}" "" |bcSeriesByFormula| NIL))
          (|text|
           . "\\tab{11}Give a formula for the {\\em i}'th coefficient")
          (|text| . "\\endmenu")))
    (|htShowPage|)))

;bcSeriesExpansion(a,b) ==
;  htInitPage('"Series Expansion Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain EEM (Expression $EmptyMode))
;       (isDomain S (String))
;       (isDomain SY (Symbol)))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em function} you want to expand in a power series")
;    (text . "\newline\tab{2} ")
;    (bcStrings (55 "log(cot(x))" function EM))
;    (text . "\blankline ")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em power series variable}")
;    (text . "\tab{49}")
;    (bcStrings (8 x variable SY))
;    (text . "\blankline ")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em point} about which you want to expand")
;    (text . "\tab{49}")
;    (bcStrings (8 "\%pi/2" point EM)))
;  htMakeDoneButton('"Continue",'bcSeriesExpansionGen)
;  htShowPage()

(DEFUN |bcSeriesExpansion| (|a| |b|)
  (declare (ignore |a| |b|))
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| (MAKESTRING "Series Expansion Basic Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| EEM (|Expression| |$EmptyMode|))
              (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em function} you want to expand in a power series")
          (|text| . "\\newline\\tab{2} ")
          (|bcStrings| (55 "log(cot(x))" |function| EM))
          (|text| . "\\blankline ") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the {\\em power series variable}")
          (|text| . "\\tab{49}") (|bcStrings| (8 |x| |variable| SY))
          (|text| . "\\blankline ") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em point} about which you want to expand")
          (|text| . "\\tab{49}")
          (|bcStrings| (8 "\\%pi/2" |point| EM))))
    (|htMakeDoneButton| (MAKESTRING "Continue")
        '|bcSeriesExpansionGen|)
    (|htShowPage|)))

;bcSeriesExpansionGen htPage ==
;  fun := htpLabelInputString(htPage,'function)
;  var := htpLabelInputString(htPage,'variable)
;  point := htpLabelInputString(htPage,'point)
;  terms := htpLabelInputString(htPage,'numberOfTerms)
;  bcFinish("series",fun,STRCONC(var,'" = ",point))

(DEFUN |bcSeriesExpansionGen| (|htPage|)
  (PROG (|fun| |var| |point| |terms|)
    (RETURN
      (PROGN
        (SPADLET |fun| (|htpLabelInputString| |htPage| '|function|))
        (SPADLET |var| (|htpLabelInputString| |htPage| '|variable|))
        (SPADLET |point| (|htpLabelInputString| |htPage| '|point|))
        (SPADLET |terms|
                 (|htpLabelInputString| |htPage| '|numberOfTerms|))
        (|bcFinish| '|series| |fun|
            (STRCONC |var| (MAKESTRING " = ") |point|))))))

;bcSeriesByFormula(a,b) ==
;  htInitPage('"Power Series Basic Command",nil)
;  htMakePage '(
;    (text . "Select the kind of power series you want to create:")
;    (text . "\beginmenu")
;    (text . "\item ")
;    (bcLinks ("\menuitemstyle{Taylor Series}" "" bcTaylorSeries taylor))
;    (text . "\newline Series where the exponent ranges over the integers from a {\em non-negative integer} value to plus infinity by an arbitrary {\em positive integer} step size")
;    (text . "\item ")
;    (bcLinks ("\menuitemstyle{Laurent Series}" "" bcLaurentSeries laurent))
;    (text . "\newline Series where the exponent ranges from an arbitrary {\em integer} value to plus infinity by an arbitrary {\em positive integer} step size")
;    (text . "\item ")
;    (bcLinks ("\menuitemstyle{Puiseux Series}" "" bcPuiseuxSeries puiseux))
;    (text . "\newline Series where the exponent ranges from an arbitrary {\em rational value} to plus infinity by an arbitrary {\em positive rational number} step size")
;    (text . "\endmenu"))
;  htShowPage()

(DEFUN |bcSeriesByFormula| (|a| |b|)
  (declare (ignore |a| |b|))
  (PROGN
    (|htInitPage| (MAKESTRING "Power Series Basic Command") NIL)
    (|htMakePage|
        '((|text|
           . "Select the kind of power series you want to create:")
          (|text| . "\\beginmenu") (|text| . "\\item ")
          (|bcLinks|
              ("\\menuitemstyle{Taylor Series}" "" |bcTaylorSeries|
               |taylor|))
          (|text|
           . "\\newline Series where the exponent ranges over the integers from a {\\em non-negative integer} value to plus infinity by an arbitrary {\\em positive integer} step size")
          (|text| . "\\item ")
          (|bcLinks|
              ("\\menuitemstyle{Laurent Series}" "" |bcLaurentSeries|
               |laurent|))
          (|text|
           . "\\newline Series where the exponent ranges from an arbitrary {\\em integer} value to plus infinity by an arbitrary {\\em positive integer} step size")
          (|text| . "\\item ")
          (|bcLinks|
              ("\\menuitemstyle{Puiseux Series}" "" |bcPuiseuxSeries|
               |puiseux|))
          (|text|
           . "\\newline Series where the exponent ranges from an arbitrary {\\em rational value} to plus infinity by an arbitrary {\\em positive rational number} step size")
          (|text| . "\\endmenu")))
    (|htShowPage|)))

;bcTaylorSeries(a,b) ==
;  htInitPage('"Taylor Series Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain EEM (Expression $EmptyMode))
;       (isDomain S (String))
;       (isDomain SY (Symbol)))
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the formula for the general coefficient of the series")
;    (text . "\newline\tab{2} ")
;    (bcStrings (55 "1/factorial(i)" formula EM))
;    (text . "\blankline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em index variable} for your formula")
;    (text . "\tab{49}")
;    (bcStrings (8 i index SY))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em power series variable}")
;    (text . "\tab{49}")
;    (bcStrings (8 x variable SY))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em point} about which you want to expand")
;    (text . "\tab{49}")
;    (bcStrings (8 0 point EM))
;    (text . "\blankline ")
;    (text ."For Taylor Series, the exponent of the power series variable ranges  from an {\em initial value}, an arbitrary non-negative integer, to plus infinity; the {\em step size} is any positive integer.")
;    (text . "\blankline ")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em initial value} of the index (an integer)")
;    (text . "\tab{49}")
;    (bcStrings (8 "0" min I))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em step size} (a positive integer)")
;    (text . "\tab{49}")
;    (bcStrings (8 "1" step PI))
;    (doneButton "Continue" bcTaylorSeriesGen))
;  htShowPage()

(DEFUN |bcTaylorSeries| (|a| |b|)
  (declare (ignore |a| |b|))
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| (MAKESTRING "Taylor Series Basic Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| EEM (|Expression| |$EmptyMode|))
              (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the formula for the general coefficient of the series")
          (|text| . "\\newline\\tab{2} ")
          (|bcStrings| (55 "1/factorial(i)" |formula| EM))
          (|text| . "\\blankline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the {\\em index variable} for your formula")
          (|text| . "\\tab{49}") (|bcStrings| (8 |i| |index| SY))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the {\\em power series variable}")
          (|text| . "\\tab{49}") (|bcStrings| (8 |x| |variable| SY))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em point} about which you want to expand")
          (|text| . "\\tab{49}") (|bcStrings| (8 0 |point| EM))
          (|text| . "\\blankline ")
          (|text|
           . "For Taylor Series, the exponent of the power series variable ranges  from an {\\em initial value}, an arbitrary non-negative integer, to plus infinity; the {\\em step size} is any positive integer.")
          (|text| . "\\blankline ") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em initial value} of the index (an integer)")
          (|text| . "\\tab{49}") (|bcStrings| (8 "0" |min| I))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the {\\em step size} (a positive integer)")
          (|text| . "\\tab{49}") (|bcStrings| (8 "1" |step| PI))
          (|doneButton| "Continue" |bcTaylorSeriesGen|)))
    (|htShowPage|)))

;bcSeriesByFormulaGen htPage == bcNotReady()

(DEFUN |bcSeriesByFormulaGen| (|htPage|) 
 (declare (ignore |htPage|))
 (|bcNotReady|))

;bcLaurentSeries(a,b) ==
;  htInitPage('"Laurent Series Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain EEM (Expression $EmptyMode))
;       (isDomain S (String))
;       (isDomain I (Integer))
;       (isDomain PI (PositiveInteger))
;       (isDomain SY (Symbol)))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the formula for the general coefficient of the series")
;    (text . "\newline\tab{2} ")
;    (bcStrings (55 "(-1)**(n - 1)/(n + 2)" formula EM))
;    (text . "\vspace{1}\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em index variable} for your formula")
;    (text . "\tab{49}")
;    (bcStrings (8 n index SY))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em power series variable}")
;    (text . "\tab{49}")
;    (bcStrings (8 x variable SY))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em point} about which you want to expand")
;    (text . "\tab{49}")
;    (bcStrings (8 0 point F))
;    (text . "\blankline")
;    (text . "\newline For Laurent Series, the exponent of the power series variable ranges from an {\em initial value}, an arbitrary integer value, to plus infinity; the {\em step size} is any positive integer.")
;    (text . "\blankline")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em initial value} of the index (an integer)")
;    (text . "\tab{49}")
;    (bcStrings (8 "-1" min I))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em step size} (a positive integer)")
;    (text . "\tab{49}")
;    (bcStrings (8 "1" step PI))
;    (doneButton "Continue" bcLaurentSeriesGen))
;  htShowPage()

(DEFUN |bcLaurentSeries| (|a| |b|)
  (declare (special |$EmptyMode|) (ignore |a| |b|))
  (PROGN
    (|htInitPage| (MAKESTRING "Laurent Series Basic Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| EEM (|Expression| |$EmptyMode|))
              (|isDomain| S (|String|)) (|isDomain| I (|Integer|))
              (|isDomain| PI (|PositiveInteger|))
              (|isDomain| SY (|Symbol|)))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the formula for the general coefficient of the series")
          (|text| . "\\newline\\tab{2} ")
          (|bcStrings| (55 "(-1)**(n - 1)/(n + 2)" |formula| EM))
          (|text| . "\\vspace{1}\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the {\\em index variable} for your formula")
          (|text| . "\\tab{49}") (|bcStrings| (8 |n| |index| SY))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the {\\em power series variable}")
          (|text| . "\\tab{49}") (|bcStrings| (8 |x| |variable| SY))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em point} about which you want to expand")
          (|text| . "\\tab{49}") (|bcStrings| (8 0 |point| F))
          (|text| . "\\blankline")
          (|text|
           . "\\newline For Laurent Series, the exponent of the power series variable ranges from an {\\em initial value}, an arbitrary integer value, to plus infinity; the {\\em step size} is any positive integer.")
          (|text| . "\\blankline")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em initial value} of the index (an integer)")
          (|text| . "\\tab{49}") (|bcStrings| (8 "-1" |min| I))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the {\\em step size} (a positive integer)")
          (|text| . "\\tab{49}") (|bcStrings| (8 "1" |step| PI))
          (|doneButton| "Continue" |bcLaurentSeriesGen|)))
    (|htShowPage|)))

;bcPuiseuxSeries(a,b) ==
;  htInitPage('"Puiseux Series Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain EEM (Expression $EmptyMode))
;       (isDomain S (String))
;       (isDomain I (Integer))
;       (isDomain PI (PositiveInteger))
;       (isDOmain RN (Fraction (Integer)))
;       (isDomain SY (Symbol)))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text ."Enter the {\em formula} for the general coefficient of the series")
;    (text . "\newline\tab{2} ")
;    (bcStrings(55 "(-1)**((3*n - 4)/6)/factorial(n - 1/3)" formula EM))
;    (text . "\vspace{1}\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em index variable} for your formula")
;    (text . "\tab{49}")
;    (bcStrings (8 n index SY))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em power series variable}")
;    (text . "\tab{49}")
;    (bcStrings (8 x variable SY))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em point} about which you want to expand")
;    (text . "\tab{49}")
;    (bcStrings (8 0 point F))
;    (text . "\blankline ")
;    (text . "For Puiseux Series, the exponent of the power series variable ranges from an {\em initial value}, an arbitary rational number, to plus infinity; the {\em step size} is an any positive rational number.")
;    (text . "\blankline ")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em initial value} of index (a rational number)")
;    (text . "\tab{51}")
;    (bcStrings (6 "4/3" min RN))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em step size} (a positive rational number)")
;    (text . "\tab{51}")
;    (bcStrings (6 "2" step RN))
;    (doneButton "Continue" bcPuiseuxSeriesGen))
;  htShowPage()

(DEFUN |bcPuiseuxSeries| (|a| |b|)
  (declare (special |$EmptyMode|) (ignore |a| |b|))
  (PROGN
    (|htInitPage| (MAKESTRING "Puiseux Series Basic Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| EEM (|Expression| |$EmptyMode|))
              (|isDomain| S (|String|)) (|isDomain| I (|Integer|))
              (|isDomain| PI (|PositiveInteger|))
              (|isDOmain| RN (|Fraction| (|Integer|)))
              (|isDomain| SY (|Symbol|)))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em formula} for the general coefficient of the series")
          (|text| . "\\newline\\tab{2} ")
          (|bcStrings|
              (55 "(-1)**((3*n - 4)/6)/factorial(n - 1/3)" |formula|
               EM))
          (|text| . "\\vspace{1}\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the {\\em index variable} for your formula")
          (|text| . "\\tab{49}") (|bcStrings| (8 |n| |index| SY))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the {\\em power series variable}")
          (|text| . "\\tab{49}") (|bcStrings| (8 |x| |variable| SY))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em point} about which you want to expand")
          (|text| . "\\tab{49}") (|bcStrings| (8 0 |point| F))
          (|text| . "\\blankline ")
          (|text|
           . "For Puiseux Series, the exponent of the power series variable ranges from an {\\em initial value}, an arbitary rational number, to plus infinity; the {\\em step size} is an any positive rational number.")
          (|text| . "\\blankline ") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em initial value} of index (a rational number)")
          (|text| . "\\tab{51}") (|bcStrings| (6 "4/3" |min| RN))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em step size} (a positive rational number)")
          (|text| . "\\tab{51}") (|bcStrings| (6 "2" |step| RN))
          (|doneButton| "Continue" |bcPuiseuxSeriesGen|)))
    (|htShowPage|)))

;bcTaylorSeriesGen htPage == bcSeriesGen(htPage)

(DEFUN |bcTaylorSeriesGen| (|htPage|) (|bcSeriesGen| |htPage|))

;bcLaurentSeriesGen htPage ==
;  bcSeriesGen(htPage)

(DEFUN |bcLaurentSeriesGen| (|htPage|) (|bcSeriesGen| |htPage|))

;bcPuiseuxSeriesGen htPage ==
;  bcSeriesGen(htPage)

(DEFUN |bcPuiseuxSeriesGen| (|htPage|) (|bcSeriesGen| |htPage|))

;bcSeriesGen(htPage) ==
;  step:= htpLabelInputString(htPage,'step)
;  min := htpLabelInputString(htPage,'min)
;  formula := htpLabelInputString(htPage,'formula)
;  index   := htpLabelInputString(htPage,'index)
;  var := htpLabelInputString(htPage,'variable)
;  point := htpLabelInputString(htPage,'point)
;  varPart := STRCONC(var,'" = ",point)
;  minPart := STRCONC(min,'"..")
;  bcFinish('"series",STRCONC(index,'" +-> ",formula),varPart,minPart,step)

(DEFUN |bcSeriesGen| (|htPage|)
  (PROG (|step| |min| |formula| |index| |var| |point| |varPart|
                |minPart|)
    (RETURN
      (PROGN
        (SPADLET |step| (|htpLabelInputString| |htPage| '|step|))
        (SPADLET |min| (|htpLabelInputString| |htPage| '|min|))
        (SPADLET |formula| (|htpLabelInputString| |htPage| '|formula|))
        (SPADLET |index| (|htpLabelInputString| |htPage| '|index|))
        (SPADLET |var| (|htpLabelInputString| |htPage| '|variable|))
        (SPADLET |point| (|htpLabelInputString| |htPage| '|point|))
        (SPADLET |varPart| (STRCONC |var| (MAKESTRING " = ") |point|))
        (SPADLET |minPart| (STRCONC |min| (MAKESTRING "..")))
        (|bcFinish| (MAKESTRING "series")
            (STRCONC |index| (MAKESTRING " +-> ") |formula|) |varPart|
            |minPart| |step|)))))

;bcLimit() ==
;  htInitPage('"Limit Basic Command",nil)
;  htMakePage '(
;   (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain S (String))
;       (isDomain SY (Symbol)))
;   (text . "What kind of limit do you want to compute? ")
;   (text . "\blankline ")
;   (text . "\beginmenu")
;   (text . "\item ")
;   (bcLinks ("\menuitemstyle{A real limit?}" "" bcRealLimit real))
;   (text . "\indentrel{17}\tab{0}")
;   (text . "The limit as the variable approaches a {\em real} value along the real axis")
;   (text . "\indentrel{-17}")
;   (text . "\item ")
;   (text . "\blankline ")
;   (bcLinks ("\menuitemstyle{A complex limit?}" "" bcComplexLimit complex))
;   (text . "\indentrel{17}\tab{0}")
;   (text . "The limit as the variable approaches a {\em complex} value along any path in the complex plane")
;   (text . "\indentrel{-17}")
;   (text . "\endmenu")
;    )
;  htShowPage()

(DEFUN |bcLimit| ()
  (declare (special |$EmptyMode|))
  (PROGN
    (|htInitPage| (MAKESTRING "Limit Basic Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| S (|String|)) (|isDomain| SY (|Symbol|)))
          (|text| . "What kind of limit do you want to compute? ")
          (|text| . "\\blankline ") (|text| . "\\beginmenu")
          (|text| . "\\item ")
          (|bcLinks|
              ("\\menuitemstyle{A real limit?}" "" |bcRealLimit|
               |real|))
          (|text| . "\\indentrel{17}\\tab{0}")
          (|text|
           . "The limit as the variable approaches a {\\em real} value along the real axis")
          (|text| . "\\indentrel{-17}") (|text| . "\\item ")
          (|text| . "\\blankline ")
          (|bcLinks|
              ("\\menuitemstyle{A complex limit?}" "" |bcComplexLimit|
               |complex|))
          (|text| . "\\indentrel{17}\\tab{0}")
          (|text|
           . "The limit as the variable approaches a {\\em complex} value along any path in the complex plane")
          (|text| . "\\indentrel{-17}") (|text| . "\\endmenu")))
    (|htShowPage|)))

;bcRealLimit(a,b) ==
;  htInitPage('"Real Limit Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;       (isDomain EM $EmptyMode)
;       (isDomain S (String))
;       (isDomain F (Float))
;       (isDomain SY (Symbol)))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em function} you want to compute the limit of:")
;    (text . "\newline\tab{2} ")
;    (bcStrings (45 "x*sin(1/x)" expression EM))
;    (text . "\blankline")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the name of the {\em variable}: ")
;    (text . "\tab{41}")
;    (bcStrings (6 x variable SY))
;    (text . "\blankline")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Compute the limit at")
;    (radioButtons location
;      ("A finite point:" (
;        (text . "\tab{33}")
;        (bcStrings (6 0 point F))) finitePoint)
;      ("Plus infinity" "" plusInfinity)
;      ("Minus infinity" "" minusInfinity))
;    (doneButton "Continue" bcRealLimitGen))
;  htShowPage()

(DEFUN |bcRealLimit| (|a| |b|)
  (declare (special |$EmptyMode|) (ignore |a| |b|))
  (PROGN
    (|htInitPage| (MAKESTRING "Real Limit Basic Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| S (|String|)) (|isDomain| F (|Float|))
              (|isDomain| SY (|Symbol|)))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em function} you want to compute the limit of:")
          (|text| . "\\newline\\tab{2} ")
          (|bcStrings| (45 "x*sin(1/x)" |expression| EM))
          (|text| . "\\blankline") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the name of the {\\em variable}: ")
          (|text| . "\\tab{41}") (|bcStrings| (6 |x| |variable| SY))
          (|text| . "\\blankline") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Compute the limit at")
          (|radioButtons| |location|
              ("A finite point:"
               ((|text| . "\\tab{33}") (|bcStrings| (6 0 |point| F)))
               |finitePoint|)
              ("Plus infinity" "" |plusInfinity|)
              ("Minus infinity" "" |minusInfinity|))
          (|doneButton| "Continue" |bcRealLimitGen|)))
    (|htShowPage|)))

;bcRealLimitGen htPage ==
;  (p := htpButtonValue(htPage,'location)) ^= 'finitePoint =>
;    fun := htpLabelInputString(htPage,'expression)
;    var := htpLabelInputString(htPage,'variable)
;    loc :=
;      p = 'plusInfinity => '"%plusInfinity"
;      '"%minusInfinity"
;    bcFinish('"limit",fun,STRCONC(var,'" = ",loc))
;  page := htInitPage('"Real Limit Basic Command",nil)
;  htMakePage '(
;    (text . "Compute the limit")
;    (lispLinks
;       ("\menuitemstyle{From both directions}" "" bcRealLimitGen1 both)
;       ("\menuitemstyle{From the right}" "" bcRealLimitGen1 right)
;       ("\menuitemstyle{From the left}" "" bcRealLimitGen1 left)))
;  htpSetProperty(page,'fun,htpLabelInputString(htPage,'expression))
;  htpSetProperty(page,'var,htpLabelInputString(htPage,'variable))
;  htpSetProperty(page,'loc,htpLabelInputString(htPage,'point))
;  htShowPage()

(DEFUN |bcRealLimitGen| (|htPage|)
  (PROG (|p| |fun| |var| |loc| |page|)
    (RETURN
      (COND
        ((NEQUAL (SPADLET |p| (|htpButtonValue| |htPage| '|location|))
                 '|finitePoint|)
         (SPADLET |fun| (|htpLabelInputString| |htPage| '|expression|))
         (SPADLET |var| (|htpLabelInputString| |htPage| '|variable|))
         (SPADLET |loc|
                  (COND
                    ((BOOT-EQUAL |p| '|plusInfinity|)
                     (MAKESTRING "%plusInfinity"))
                    ('T (MAKESTRING "%minusInfinity"))))
         (|bcFinish| (MAKESTRING "limit") |fun|
             (STRCONC |var| (MAKESTRING " = ") |loc|)))
        ('T
         (SPADLET |page|
                  (|htInitPage| (MAKESTRING "Real Limit Basic Command")
                      NIL))
         (|htMakePage|
             '((|text| . "Compute the limit")
               (|lispLinks|
                   ("\\menuitemstyle{From both directions}" ""
                    |bcRealLimitGen1| |both|)
                   ("\\menuitemstyle{From the right}" ""
                    |bcRealLimitGen1| |right|)
                   ("\\menuitemstyle{From the left}" ""
                    |bcRealLimitGen1| |left|))))
         (|htpSetProperty| |page| '|fun|
             (|htpLabelInputString| |htPage| '|expression|))
         (|htpSetProperty| |page| '|var|
             (|htpLabelInputString| |htPage| '|variable|))
         (|htpSetProperty| |page| '|loc|
             (|htpLabelInputString| |htPage| '|point|))
         (|htShowPage|))))))

;bcRealLimitGen1(htPage,key) ==
;  direction :=
;    key = 'right => '"_"right_""
;    key = 'left => '"_"left_""
;    nil
;  fun := htpProperty(htPage,'fun)
;  var := htpProperty(htPage,'var)
;  loc := htpProperty(htPage,'loc)
;  varPart := STRCONC(var,'" = ",loc)
;  bcFinish('"limit",fun,varPart,direction)

(DEFUN |bcRealLimitGen1| (|htPage| |key|)
  (PROG (|direction| |fun| |var| |loc| |varPart|)
    (RETURN
      (PROGN
        (SPADLET |direction|
                 (COND
                   ((BOOT-EQUAL |key| '|right|)
                    (MAKESTRING "\"right\""))
                   ((BOOT-EQUAL |key| '|left|) (MAKESTRING "\"left\""))
                   ('T NIL)))
        (SPADLET |fun| (|htpProperty| |htPage| '|fun|))
        (SPADLET |var| (|htpProperty| |htPage| '|var|))
        (SPADLET |loc| (|htpProperty| |htPage| '|loc|))
        (SPADLET |varPart| (STRCONC |var| (MAKESTRING " = ") |loc|))
        (|bcFinish| (MAKESTRING "limit") |fun| |varPart| |direction|)))))

;bcComplexLimit(a,b) ==
;  htInitPage('"Complex Limit Basic Command",nil)
;  htMakePage '(
;    (domainConditions
;        (isDomain EM $EmptyMode)
;       (isDomain S (String))
;       (isDomain F (Float))
;       (isDomain SY (Symbol)))
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the {\em function} you want to compute the limit of:")
;    (text . "\newline\tab{2} ")
;    (bcStrings (40 "sin(a*x)/tan(b*x)" expression EM))
;    (text . "\blankline ")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Enter the name of the {\em variable}: ")
;    (text . "\tab{37}")
;    (bcStrings (5 x variable SY))
;    (text . "\blankline ")
;    (text . "\newline ")
;    (text . "\menuitemstyle{}\tab{2}")
;    (text . "Compute the limit at")
;    (radioButtons location
;      ("A finite point:" (
;       (text . "\newline\space{0}Real part:\space{3}")
;       (bcStrings (20 0 real F))
;       (text . "\newline Complex part:")
;       (bcStrings (20 0 complex F))) finitePoint)
;      ("Complex infinity" "" complexInfinity))
;     (doneButton "Continue" bcComplexLimitGen))
;  htShowPage()

(DEFUN |bcComplexLimit| (|a| |b|)
  (declare (special |$EmptyMode|) (ignore |a| |b|))
  (PROGN
    (|htInitPage| (MAKESTRING "Complex Limit Basic Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| EM |$EmptyMode|)
              (|isDomain| S (|String|)) (|isDomain| F (|Float|))
              (|isDomain| SY (|Symbol|)))
          (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text|
           . "Enter the {\\em function} you want to compute the limit of:")
          (|text| . "\\newline\\tab{2} ")
          (|bcStrings| (40 "sin(a*x)/tan(b*x)" |expression| EM))
          (|text| . "\\blankline ") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Enter the name of the {\\em variable}: ")
          (|text| . "\\tab{37}") (|bcStrings| (5 |x| |variable| SY))
          (|text| . "\\blankline ") (|text| . "\\newline ")
          (|text| . "\\menuitemstyle{}\\tab{2}")
          (|text| . "Compute the limit at")
          (|radioButtons| |location|
              ("A finite point:"
               ((|text| . "\\newline\\space{0}Real part:\\space{3}")
                (|bcStrings| (20 0 |real| F))
                (|text| . "\\newline Complex part:")
                (|bcStrings| (20 0 |complex| F)))
               |finitePoint|)
              ("Complex infinity" "" |complexInfinity|))
          (|doneButton| "Continue" |bcComplexLimitGen|)))
    (|htShowPage|)))

;bcComplexLimitGen htPage ==
;  fun := htpLabelInputString(htPage,'expression)
;  var := htpLabelInputString(htPage,'variable)
;  loc :=
;    (p := htpButtonValue(htPage,'location)) = 'finitePoint =>
;      real := htpLabelInputString(htPage,'real)
;      comp := htpLabelInputString(htPage,'complex)
;      complexPart :=
;        comp = '"0" => '""
;        comp = '"1" => '"%i"
;        STRCONC(comp,'"*%i")
;      real = '"0" =>
;        complexPart = '"" => "0"
;        complexPart
;      complexPart = '"" => real
;      STRCONC(real,'" + ",complexPart)
;    '"%infinity"
;  varPart := STRCONC(var,'" = ",loc)
;  bcFinish('"complexLimit",fun,varPart)

(DEFUN |bcComplexLimitGen| (|htPage|)
  (PROG (|fun| |var| |p| |real| |comp| |complexPart| |loc| |varPart|)
    (RETURN
      (PROGN
        (SPADLET |fun| (|htpLabelInputString| |htPage| '|expression|))
        (SPADLET |var| (|htpLabelInputString| |htPage| '|variable|))
        (SPADLET |loc|
                 (COND
                   ((BOOT-EQUAL
                        (SPADLET |p|
                                 (|htpButtonValue| |htPage|
                                     '|location|))
                        '|finitePoint|)
                    (SPADLET |real|
                             (|htpLabelInputString| |htPage| '|real|))
                    (SPADLET |comp|
                             (|htpLabelInputString| |htPage|
                                 '|complex|))
                    (SPADLET |complexPart|
                             (COND
                               ((BOOT-EQUAL |comp| (MAKESTRING "0"))
                                (MAKESTRING ""))
                               ((BOOT-EQUAL |comp| (MAKESTRING "1"))
                                (MAKESTRING "%i"))
                               ('T (STRCONC |comp| (MAKESTRING "*%i")))))
                    (COND
                      ((BOOT-EQUAL |real| (MAKESTRING "0"))
                       (COND
                         ((BOOT-EQUAL |complexPart| (MAKESTRING ""))
                          '|0|)
                         ('T |complexPart|)))
                      ((BOOT-EQUAL |complexPart| (MAKESTRING ""))
                       |real|)
                      ('T
                       (STRCONC |real| (MAKESTRING " + ")
                                |complexPart|))))
                   ('T (MAKESTRING "%infinity"))))
        (SPADLET |varPart| (STRCONC |var| (MAKESTRING " = ") |loc|))
        (|bcFinish| (MAKESTRING "complexLimit") |fun| |varPart|)))))

;  -- HyperTeX basic Solve Command
;$systemType := nil

(SPADLET |$systemType| NIL) 

;$numberOfEquations := 0

(SPADLET |$numberOfEquations| 0) 

;$solutionMethod := nil

(SPADLET |$solutionMethod| NIL) 

;bcSolve() ==
;  htInitPage('"Solve Basic Command", nil)
;  htMakePage '(
;   (text . "What do you want to solve? ")
;   (text . "\beginmenu")
;   (text . "\item ")
;   (bcLinks ("\menuitemstyle{A System Of Linear Equations}" "" bcLinearSolve linear))
;   (text . "\item ")
;   (bcLinks ("\menuitemstyle{A System of Polynomial Equations}" "" bcSystemSolve  polynomial))
;   (text . "\item ")
;   (bcLinks ("\menuitemstyle{A Single Polynomial Equation}" "" bcSolveSingle onePolynomial))
;   (text . "\endmenu"))
;  htShowPage()

(DEFUN |bcSolve| ()
  (PROGN
    (|htInitPage| (MAKESTRING "Solve Basic Command") NIL)
    (|htMakePage|
        '((|text| . "What do you want to solve? ")
          (|text| . "\\beginmenu") (|text| . "\\item ")
          (|bcLinks|
              ("\\menuitemstyle{A System Of Linear Equations}" ""
               |bcLinearSolve| |linear|))
          (|text| . "\\item ")
          (|bcLinks|
              ("\\menuitemstyle{A System of Polynomial Equations}" ""
               |bcSystemSolve| |polynomial|))
          (|text| . "\\item ")
          (|bcLinks|
              ("\\menuitemstyle{A Single Polynomial Equation}" ""
               |bcSolveSingle| |onePolynomial|))
          (|text| . "\\endmenu")))
    (|htShowPage|)))

;bcLinearSolve(p,nn) ==
;  htInitPage('"Basic Solve Command", nil)
;  htMakePage '(
;    (text . "How do you want to enter the equations?")
;    (text . "\beginmenu")
;    (text . "\item ")
;    (text . "\newline ")
;    (bcLinks ("\menuitemstyle{Directly as equations}" "" bcLinearSolveEqns equations))
;    (text . "\item ")
;    (text . "\newline ")
;    (bcLinks ("\menuitemstyle{In matrix form}" "" bcLinearSolveMatrix matrix))
;    (text . "\indentrel{16}\tab{0}")
;    (text . " \spad{AX = B}, where \spad{A} is a matrix of coefficients and \spad{B} is a vector" )
;    (text . "\indentrel{-16}\item ")
;    (text . "\endmenu"))
;  htShowPage()

(DEFUN |bcLinearSolve| (|p| |nn|)
  (declare (ignore |p| |nn|))
  (PROGN
    (|htInitPage| (MAKESTRING "Basic Solve Command") NIL)
    (|htMakePage|
        '((|text| . "How do you want to enter the equations?")
          (|text| . "\\beginmenu") (|text| . "\\item ")
          (|text| . "\\newline ")
          (|bcLinks|
              ("\\menuitemstyle{Directly as equations}" ""
               |bcLinearSolveEqns| |equations|))
          (|text| . "\\item ") (|text| . "\\newline ")
          (|bcLinks|
              ("\\menuitemstyle{In matrix form}" ""
               |bcLinearSolveMatrix| |matrix|))
          (|text| . "\\indentrel{16}\\tab{0}")
          (|text|
           . " \\spad{AX = B}, where \\spad{A} is a matrix of coefficients and \\spad{B} is a vector")
          (|text| . "\\indentrel{-16}\\item ") (|text| . "\\endmenu")))
    (|htShowPage|)))

;bcLinearSolveEqns(htPage, p) ==
;  htInitPage('"Basic Solve Command", nil)
;  htMakePage '(
;    (domainConditions (isDomain PI (PositiveInteger)))
;    (inputStrings
;      ("Enter the {\em number} of equations:" "" 5 2 numberOfEquations PI)))
;  htMakeDoneButton('"Continue", 'bcLinearSolveEqns1)
;  htShowPage()

(DEFUN |bcLinearSolveEqns| (|htPage| |p|)
  (declare (ignore |htPage| |p|))
  (PROGN
    (|htInitPage| (MAKESTRING "Basic Solve Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| PI (|PositiveInteger|)))
          (|inputStrings|
              ("Enter the {\\em number} of equations:" "" 5 2
               |numberOfEquations| PI))))
    (|htMakeDoneButton| (MAKESTRING "Continue") '|bcLinearSolveEqns1|)
    (|htShowPage|)))

;bcSystemSolve(htPage, p) ==
;  htInitPage('"Basic Solve Command", nil)
;  htMakePage '(
;    (domainConditions (isDomain PI (PositiveInteger)))
;    (inputStrings
;      ("Enter the {\em number} of equations:" "" 5 2 numberOfEquations PI)))
;  htMakeDoneButton('"Continue", 'bcSystemSolveEqns1)
;  htShowPage()

(DEFUN |bcSystemSolve| (|htPage| |p|)
  (declare (ignore |htPage| |p|))
  (PROGN
    (|htInitPage| (MAKESTRING "Basic Solve Command") NIL)
    (|htMakePage|
        '((|domainConditions| (|isDomain| PI (|PositiveInteger|)))
          (|inputStrings|
              ("Enter the {\\em number} of equations:" "" 5 2
               |numberOfEquations| PI))))
    (|htMakeDoneButton| (MAKESTRING "Continue") '|bcSystemSolveEqns1|)
    (|htShowPage|)))

;bcSolveSingle(htPage,p) ==
;  htpSetProperty(htPage,'systemType, 'onePolynomial)
;  htpSetProperty(htPage,'exitFunction,'bcInputSolveInfo)
;  bcInputEquations(htPage,'exact)

(DEFUN |bcSolveSingle| (|htPage| |p|)
  (declare (ignore |p|))
  (PROGN
    (|htpSetProperty| |htPage| '|systemType| '|onePolynomial|)
    (|htpSetProperty| |htPage| '|exitFunction| '|bcInputSolveInfo|)
    (|bcInputEquations| |htPage| '|exact|)))

;bcSystemSolveEqns1 htPage ==
;  htpSetProperty(htPage,'systemType,'polynomial)
;  htpSetProperty(htPage,'exitFunction,'bcInputSolveInfo)
;  bcInputEquations(htPage,'exact)

(DEFUN |bcSystemSolveEqns1| (|htPage|)
  (PROGN
    (|htpSetProperty| |htPage| '|systemType| '|polynomial|)
    (|htpSetProperty| |htPage| '|exitFunction| '|bcInputSolveInfo|)
    (|bcInputEquations| |htPage| '|exact|)))

;bcLinearSolveEqns1 htPage ==
;  htpSetProperty(htPage,'systemType,'linear)
;  htpSetProperty(htPage,'exitFunction,'bcLinearSolveEqnsGen)
;  bcInputEquations(htPage,'exact)

(DEFUN |bcLinearSolveEqns1| (|htPage|)
  (PROGN
    (|htpSetProperty| |htPage| '|systemType| '|linear|)
    (|htpSetProperty| |htPage| '|exitFunction| '|bcLinearSolveEqnsGen|)
    (|bcInputEquations| |htPage| '|exact|)))

;bcInputSolveInfo htPage ==
;  page := htInitPage('"Solve Basic Command", htpPropertyList htPage)
;  htpSetProperty(page,'numberOfEquations,htpProperty(htPage,'numberOfEquations))
;  htpSetProperty(page,'inputArea,htpInputAreaAlist htPage)
;  htMakePage '(
;   (domainConditions (isDomain PI (PositiveInteger)))
;   (text . "What would you like?")
;   (text . "\beginmenu")
;   (text . "\item ")
;   (bcLinks ("\menuitemstyle{Exact Solutions}" "" bcSolveEquations exact))
;   (text . "\indentrel{18}\tab{0} ")
;   (text . "Solutions expressed in terms of {\em roots} of irreducible polynomials")
;   (text . "\indentrel{-18}")
;   (text . "\item ")
;   (bcLinks ("\menuitemstyle{Numeric Solutions}" "" bcSolveEquationsNumerically numeric))
;   (text . "\indentrel{18}\tab{0} ")
;   (text . "Solutions expressed in terms of approximate real or complex {\em numbers}")
;   (text . "\indentrel{-18}")
;   (text . "\item ")
;   (bcLinks ("\menuitemstyle{Radical Solutions}" "" bcSolveEquations radical))
;   (text . "\indentrel{18}\tab{0} ")
;   (text . "Solutions expressed in terms of {\em radicals} if it is possible")
;   (text . "\indentrel{-18}")
;   (text . "\endmenu"))
;  htShowPage()

(DEFUN |bcInputSolveInfo| (|htPage|)
  (PROG (|page|)
    (RETURN
      (PROGN
        (SPADLET |page|
                 (|htInitPage| (MAKESTRING "Solve Basic Command")
                     (|htpPropertyList| |htPage|)))
        (|htpSetProperty| |page| '|numberOfEquations|
            (|htpProperty| |htPage| '|numberOfEquations|))
        (|htpSetProperty| |page| '|inputArea|
            (|htpInputAreaAlist| |htPage|))
        (|htMakePage|
            '((|domainConditions| (|isDomain| PI (|PositiveInteger|)))
              (|text| . "What would you like?")
              (|text| . "\\beginmenu") (|text| . "\\item ")
              (|bcLinks|
                  ("\\menuitemstyle{Exact Solutions}" ""
                   |bcSolveEquations| |exact|))
              (|text| . "\\indentrel{18}\\tab{0} ")
              (|text|
               . "Solutions expressed in terms of {\\em roots} of irreducible polynomials")
              (|text| . "\\indentrel{-18}") (|text| . "\\item ")
              (|bcLinks|
                  ("\\menuitemstyle{Numeric Solutions}" ""
                   |bcSolveEquationsNumerically| |numeric|))
              (|text| . "\\indentrel{18}\\tab{0} ")
              (|text|
               . "Solutions expressed in terms of approximate real or complex {\\em numbers}")
              (|text| . "\\indentrel{-18}") (|text| . "\\item ")
              (|bcLinks|
                  ("\\menuitemstyle{Radical Solutions}" ""
                   |bcSolveEquations| |radical|))
              (|text| . "\\indentrel{18}\\tab{0} ")
              (|text|
               . "Solutions expressed in terms of {\\em radicals} if it is possible")
              (|text| . "\\indentrel{-18}") (|text| . "\\endmenu")))
        (|htShowPage|)))))

;bcInputEquations(htPage,solutionMethod) ==
;  numEqs :=
;    htpProperty(htPage, 'systemType) = 'onePolynomial => 1
;    $bcParseOnly => PARSE_-INTEGER htpLabelInputString(htPage,'numberOfEquations)
;    objValUnwrap htpLabelSpadValue(htPage, 'numberOfEquations)
;  linearPred := htpProperty(htPage,'systemType) = 'linear
;  labelList :=
;    numEqs = 1 => '(
;      (bcStrings (42 "x^2+1" l1 P))
;      (text . " = ")
;      (bcStrings (6 0 r1 P)))
;    "append"/[f(i,numEqs,linearPred) for i in 1..numEqs] where f(i,n,linearp) ==
;      spacer := (i > 99 => 0; i > 9 => 1; 2)
;      prefix := STRCONC('"\newline\tab{2}{\em Equation ",STRINGIMAGE i,'":}")
;      prefix := STRCONC(prefix,'"\space{",STRINGIMAGE spacer,'"}")
;      lnam := INTERN STRCONC('"l",STRINGIMAGE i)
;      rnam := INTERN STRCONC('"r",STRINGIMAGE i)
;      var:=
;        linearp => bcMakeLinearEquations(i,n)
;        bcMakeEquations(i,n)
;      [['text,:prefix],['bcStrings,[30,var,lnam,'P]],'(text . " = "),['bcStrings,[5,"0",rnam,'P]]]
;  equationPart := [
;     '(domainConditions
;        (isDomain P (Polynomial $EmptyMode))
;         (isDomain S (String))
;          (isDomain PI (PositiveInteger))),
;            :labelList]
;  page := htInitPage('"Solve Basic Command", htpPropertyList htPage)
;  htpSetProperty(page, 'numberOfEquations, numEqs)
;  htpSetProperty(page, 'solutionMethod,solutionMethod)
;  htSay '"\newline\menuitemstyle{}\tab{2}"
;  htSay
;    numEqs = 1 => '"Enter the {\em Equation}:"
;    '"Enter the {\em Equations}:"
;  htSay '"\newline\tab{2}"
;  htMakePage equationPart
;  bcHt '"\blankline "
;  htSay '"\newline\menuitemstyle{}\tab{2}"
;  htMakePage
;    numEqs = 1 =>  '(
;      (text ."Enter the {\em unknown} (leave blank if implied): ")
;      (text . "\tab{48}")
;      (bcStrings (6 "x" unknowns S . quoteString)))
;    ['(text . "Enter the unknowns (leave blank if implied):"),
;     '(text . "\tab{44}"),
;      ['bcStrings, [10,bcMakeUnknowns(numEqs),'unknowns,'P]]]
;  htMakeDoneButton('"Continue", 'bcInputEquationsEnd)
;  htShowPage()

(DEFUN |bcInputEquations,f| (|i| |n| |linearp|)
  (PROG (|spacer| |prefix| |lnam| |rnam| |var|)
    (RETURN
      (SEQ (SPADLET |spacer|
                    (SEQ (IF (> |i| 99) (EXIT 0))
                         (IF (> |i| 9) (EXIT 1)) (EXIT 2)))
           (SPADLET |prefix|
                    (STRCONC (MAKESTRING
                                 "\\newline\\tab{2}{\\em Equation ")
                             (STRINGIMAGE |i|) (MAKESTRING ":}")))
           (SPADLET |prefix|
                    (STRCONC |prefix| (MAKESTRING "\\space{")
                             (STRINGIMAGE |spacer|) (MAKESTRING "}")))
           (SPADLET |lnam|
                    (INTERN (STRCONC (MAKESTRING "l")
                                     (STRINGIMAGE |i|))))
           (SPADLET |rnam|
                    (INTERN (STRCONC (MAKESTRING "r")
                                     (STRINGIMAGE |i|))))
           (SPADLET |var|
                    (SEQ (IF |linearp|
                             (EXIT (|bcMakeLinearEquations| |i| |n|)))
                         (EXIT (|bcMakeEquations| |i| |n|))))
           (EXIT (CONS (CONS '|text| |prefix|)
                       (CONS (CONS '|bcStrings|
                                   (CONS
                                    (CONS 30
                                     (CONS |var|
                                      (CONS |lnam| (CONS 'P NIL))))
                                    NIL))
                             (CONS '(|text| . " = ")
                                   (CONS
                                    (CONS '|bcStrings|
                                     (CONS
                                      (CONS 5
                                       (CONS '|0|
                                        (CONS |rnam| (CONS 'P NIL))))
                                      NIL))
                                    NIL)))))))))

(DEFUN |bcInputEquations| (|htPage| |solutionMethod|)
  (PROG (|numEqs| |linearPred| |labelList| |equationPart| |page|)
  (declare (special |$EmptyMode| |$bcParseOnly|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |numEqs|
                      (COND
                        ((BOOT-EQUAL
                             (|htpProperty| |htPage| '|systemType|)
                             '|onePolynomial|)
                         1)
                        (|$bcParseOnly|
                            (PARSE-INTEGER
                                (|htpLabelInputString| |htPage|
                                    '|numberOfEquations|)))
                        ('T
                         (|objValUnwrap|
                             (|htpLabelSpadValue| |htPage|
                                 '|numberOfEquations|)))))
             (SPADLET |linearPred|
                      (BOOT-EQUAL
                          (|htpProperty| |htPage| '|systemType|)
                          '|linear|))
             (SPADLET |labelList|
                      (COND
                        ((EQL |numEqs| 1)
                         '((|bcStrings| (42 "x^2+1" |l1| P))
                           (|text| . " = ") (|bcStrings| (6 0 |r1| P))))
                        ('T
                         (PROG (G166558)
                           (SPADLET G166558 NIL)
                           (RETURN
                             (DO ((|i| 1 (QSADD1 |i|)))
                                 ((QSGREATERP |i| |numEqs|) G166558)
                               (SEQ (EXIT
                                     (SETQ G166558
                                      (APPEND G166558
                                       (|bcInputEquations,f| |i|
                                        |numEqs| |linearPred|)))))))))))
             (SPADLET |equationPart|
                      (CONS '(|domainConditions|
                                 (|isDomain| P
                                     (|Polynomial| |$EmptyMode|))
                                 (|isDomain| S (|String|))
                                 (|isDomain| PI (|PositiveInteger|)))
                            |labelList|))
             (SPADLET |page|
                      (|htInitPage| (MAKESTRING "Solve Basic Command")
                          (|htpPropertyList| |htPage|)))
             (|htpSetProperty| |page| '|numberOfEquations| |numEqs|)
             (|htpSetProperty| |page| '|solutionMethod|
                 |solutionMethod|)
             (|htSay| (MAKESTRING "\\newline\\menuitemstyle{}\\tab{2}"))
             (|htSay| (COND
                        ((EQL |numEqs| 1)
                         (MAKESTRING "Enter the {\\em Equation}:"))
                        ('T (MAKESTRING "Enter the {\\em Equations}:"))))
             (|htSay| (MAKESTRING "\\newline\\tab{2}"))
             (|htMakePage| |equationPart|)
             (|bcHt| (MAKESTRING "\\blankline "))
             (|htSay| (MAKESTRING "\\newline\\menuitemstyle{}\\tab{2}"))
             (|htMakePage|
                 (COND
                   ((EQL |numEqs| 1)
                    '((|text|
                       . "Enter the {\\em unknown} (leave blank if implied): ")
                      (|text| . "\\tab{48}")
                      (|bcStrings|
                          (6 "x" |unknowns| S . |quoteString|))))
                   ('T
                    (CONS '(|text|
                            . "Enter the unknowns (leave blank if implied):")
                          (CONS '(|text| . "\\tab{44}")
                                (CONS (CONS '|bcStrings|
                                       (CONS
                                        (CONS 10
                                         (CONS
                                          (|bcMakeUnknowns| |numEqs|)
                                          (CONS '|unknowns|
                                           (CONS 'P NIL))))
                                        NIL))
                                      NIL))))))
             (|htMakeDoneButton| (MAKESTRING "Continue")
                 '|bcInputEquationsEnd|)
             (|htShowPage|))))))

;bcCreateVariableString(i) ==
;   STRCONC('"x",STRINGIMAGE i)

(DEFUN |bcCreateVariableString| (|i|)
  (STRCONC (MAKESTRING "x") (STRINGIMAGE |i|)))

;bcMakeUnknowns(number)==
;   APPLY('CONCAT,[STRCONC(bcCreateVariableString(i)," ") for i in 1..number])

(DEFUN |bcMakeUnknowns| (|number|)
  (PROG ()
    (RETURN
      (SEQ (APPLY 'CONCAT
                  (PROG (G166582)
                    (SPADLET G166582 NIL)
                    (RETURN
                      (DO ((|i| 1 (QSADD1 |i|)))
                          ((QSGREATERP |i| |number|)
                           (NREVERSE0 G166582))
                        (SEQ (EXIT (SETQ G166582
                                    (CONS
                                     (STRCONC
                                      (|bcCreateVariableString| |i|)
                                      '| |)
                                     G166582))))))))))))

;bcMakeEquations(i,number)==
;   number =1 => STRCONC(bcCreateVariableString(1),"^2+1")
;   bcCreateVariableString(i)
;   STRCONC(
;     STRCONC(
;      APPLY('CONCAT,[STRCONC(bcCreateVariableString(j),"+") for j in 1..number]),"1"),
;        STRCONC("-2*",STRCONC(bcCreateVariableString(i),"^2")))

(DEFUN |bcMakeEquations| (|i| |number|)
  (PROG ()
    (RETURN
      (SEQ (COND
             ((EQL |number| 1)
              (STRCONC (|bcCreateVariableString| 1) '|^2+1|))
             ('T (|bcCreateVariableString| |i|)
              (STRCONC (STRCONC (APPLY 'CONCAT
                                       (PROG (G166599)
                                         (SPADLET G166599 NIL)
                                         (RETURN
                                           (DO ((|j| 1 (QSADD1 |j|)))
                                            ((QSGREATERP |j| |number|)
                                             (NREVERSE0 G166599))
                                             (SEQ
                                              (EXIT
                                               (SETQ G166599
                                                (CONS
                                                 (STRCONC
                                                  (|bcCreateVariableString|
                                                   |j|)
                                                  '+)
                                                 G166599))))))))
                                '|1|)
                       (STRCONC '-2*
                                (STRCONC (|bcCreateVariableString| |i|)
                                         '|^2|)))))))))

;bcMakeLinearEquations(i,number)==
;   number = 1 => bcCreateVariableString(1)
;   number = 2 =>
;        i=1 => STRCONC(bcCreateVariableString(1),STRCONC("+",bcCreateVariableString(2)))
;        STRCONC(bcCreateVariableString(1),STRCONC("-",bcCreateVariableString(2)))
;   STRCONC(
;     STRCONC(
;      APPLY('CONCAT,[STRCONC(bcCreateVariableString(j),"+") for j in 1..number]),"1"),
;        STRCONC("-2*",bcCreateVariableString(i)))

(DEFUN |bcMakeLinearEquations| (|i| |number|)
  (PROG ()
    (RETURN
      (SEQ (COND
             ((EQL |number| 1) (|bcCreateVariableString| 1))
             ((EQL |number| 2)
              (COND
                ((EQL |i| 1)
                 (STRCONC (|bcCreateVariableString| 1)
                          (STRCONC '+ (|bcCreateVariableString| 2))))
                ('T
                 (STRCONC (|bcCreateVariableString| 1)
                          (STRCONC '- (|bcCreateVariableString| 2))))))
             ('T
              (STRCONC (STRCONC (APPLY 'CONCAT
                                       (PROG (G166617)
                                         (SPADLET G166617 NIL)
                                         (RETURN
                                           (DO ((|j| 1 (QSADD1 |j|)))
                                            ((QSGREATERP |j| |number|)
                                             (NREVERSE0 G166617))
                                             (SEQ
                                              (EXIT
                                               (SETQ G166617
                                                (CONS
                                                 (STRCONC
                                                  (|bcCreateVariableString|
                                                   |j|)
                                                  '+)
                                                 G166617))))))))
                                '|1|)
                       (STRCONC '-2* (|bcCreateVariableString| |i|)))))))))

;bcInputEquationsEnd htPage ==
;  fun := htpProperty(htPage, 'exitFunction) => FUNCALL(fun,htPage)
;  systemError nil

(DEFUN |bcInputEquationsEnd| (|htPage|)
  (PROG (|fun|)
    (RETURN
      (COND
        ((SPADLET |fun| (|htpProperty| |htPage| '|exitFunction|))
         (FUNCALL |fun| |htPage|))
        ('T (|systemError| NIL))))))

;bcSolveEquationsNumerically(htPage,p) ==
;  page := htInitPage('"Solve Basic Command", htpPropertyList htPage)
;  htMakePage '(
;    (text . "What would you like?")
;    (radioButtons choice
;      ("Real roots expressed as rational numbers" "" rr)
;      ("Real roots expressed as floats" "" rf)
;      ("Complex roots expressed as rational numbers" "" cr)
;      ("Complex roots expressed as floats" "" cf))
;      (text . "\vspace{1}\newline")
;      (inputStrings
;        ("Enter the number of desired {\em digits} of accuracy" "" 5 20 acc PI)))
;  htMakeDoneButton('"Continue", 'bcSolveNumerically1)
;  htShowPage()

(DEFUN |bcSolveEquationsNumerically| (|htPage| |p|)
  (declare (ignore |p|))
  (PROG (|page|)
    (RETURN
      (PROGN
        (SPADLET |page|
                 (|htInitPage| (MAKESTRING "Solve Basic Command")
                     (|htpPropertyList| |htPage|)))
        (|htMakePage|
            '((|text| . "What would you like?")
              (|radioButtons| |choice|
                  ("Real roots expressed as rational numbers" "" |rr|)
                  ("Real roots expressed as floats" "" |rf|)
                  ("Complex roots expressed as rational numbers" ""
                   |cr|)
                  ("Complex roots expressed as floats" "" |cf|))
              (|text| . "\\vspace{1}\\newline")
              (|inputStrings|
                  ("Enter the number of desired {\\em digits} of accuracy"
                   "" 5 20 |acc| PI))))
        (|htMakeDoneButton| (MAKESTRING "Continue")
            '|bcSolveNumerically1|)
        (|htShowPage|)))))

;bcSolveNumerically1(htPage) ==
; bcSolveEquations(htPage,'numeric)

(DEFUN |bcSolveNumerically1| (|htPage|)
  (|bcSolveEquations| |htPage| '|numeric|))

;--bcSolveNumerically1(htPage,kind) ==
;-- htpSetProperty(htPage,'kind,kind)
;-- bcSolveEquations(htPage,'numeric)
;
;bcSolveEquations(htPage,solutionMethod) ==
;  if solutionMethod = 'numeric then
;    digits := htpLabelInputString(htPage,'acc)
;    kind := htpButtonValue(htPage,'choice)
;    accString :=
;      kind in '(rf cf) => STRCONC('"1.e-",digits)
;      STRCONC('"1/10**",digits)
;  alist := htpProperty(htPage,'inputArea)
;  [[.,varpart,:.],:r] := alist
;  varlist := bcString2WordList varpart
;  varString := (rest varlist => bcwords2liststring varlist; first varlist)
;  eqnString := bcGenEquations r
;  solutionMethod = 'numeric =>
;    name :=
;      kind in '(rf rr) => '"solve"
;      '"complexSolve"
;    bcFinish(name,eqnString,accString)
;  name :=
;    solutionMethod = 'radical => '"radicalSolve"
;    '"solve"
;  bcFinish(name,eqnString,varString,accString)

(DEFUN |bcSolveEquations| (|htPage| |solutionMethod|)
  (PROG (|digits| |kind| |accString| |alist| |varpart| |r| |varlist|
            |varString| |eqnString| |name|)
    (RETURN
      (PROGN
        (COND
          ((BOOT-EQUAL |solutionMethod| '|numeric|)
           (SPADLET |digits| (|htpLabelInputString| |htPage| '|acc|))
           (SPADLET |kind| (|htpButtonValue| |htPage| '|choice|))
           (SPADLET |accString|
                    (COND
                      ((|member| |kind| '(|rf| |cf|))
                       (STRCONC (MAKESTRING "1.e-") |digits|))
                      ('T (STRCONC (MAKESTRING "1/10**") |digits|))))))
        (SPADLET |alist| (|htpProperty| |htPage| '|inputArea|))
        (SPADLET |varpart| (CADAR |alist|))
        (SPADLET |r| (CDR |alist|))
        (SPADLET |varlist| (|bcString2WordList| |varpart|))
        (SPADLET |varString|
                 (COND
                   ((CDR |varlist|) (|bcwords2liststring| |varlist|))
                   ('T (CAR |varlist|))))
        (SPADLET |eqnString| (|bcGenEquations| |r|))
        (COND
          ((BOOT-EQUAL |solutionMethod| '|numeric|)
           (SPADLET |name|
                    (COND
                      ((|member| |kind| '(|rf| |rr|))
                       (MAKESTRING "solve"))
                      ('T (MAKESTRING "complexSolve"))))
           (|bcFinish| |name| |eqnString| |accString|))
          ('T
           (SPADLET |name|
                    (COND
                      ((BOOT-EQUAL |solutionMethod| '|radical|)
                       (MAKESTRING "radicalSolve"))
                      ('T (MAKESTRING "solve"))))
           (|bcFinish| |name| |eqnString| |varString| |accString|)))))))

;bcLinearSolveMatrix(htPage,junk) ==
;  bcReadMatrix 'bcLinearSolveMatrix1

(DEFUN |bcLinearSolveMatrix| (|htPage| |junk|)
  (declare (ignore |htPage| |junk|))
  (|bcReadMatrix| '|bcLinearSolveMatrix1|))

;bcLinearSolveMatrix1 htPage ==
;  page := htInitPage('"Linear Solve Basic Command",htpPropertyList htPage)
;  htpSetProperty(page,'matrix,bcLinearExtractMatrix htPage)
;  htMakePage '(
;    (text . "The right side vector B is:")
;    (lispLinks
;      ("Zero:" "the system is homogeneous" bcLinearSolveMatrixHomo homo)
;      ("Not zero:" "the system is not homogeneous" bcLinearSolveMatrixInhomo nothomo)))
;  htShowPage()

(DEFUN |bcLinearSolveMatrix1| (|htPage|)
  (PROG (|page|)
    (RETURN
      (PROGN
        (SPADLET |page|
                 (|htInitPage|
                     (MAKESTRING "Linear Solve Basic Command")
                     (|htpPropertyList| |htPage|)))
        (|htpSetProperty| |page| '|matrix|
            (|bcLinearExtractMatrix| |htPage|))
        (|htMakePage|
            '((|text| . "The right side vector B is:")
              (|lispLinks|
                  ("Zero:" "the system is homogeneous"
                   |bcLinearSolveMatrixHomo| |homo|)
                  ("Not zero:" "the system is not homogeneous"
                   |bcLinearSolveMatrixInhomo| |nothomo|))))
        (|htShowPage|)))))

;bcLinearExtractMatrix htPage == REVERSE htpInputAreaAlist htPage

(DEFUN |bcLinearExtractMatrix| (|htPage|)
  (REVERSE (|htpInputAreaAlist| |htPage|)))

;bcLinearSolveMatrixInhomo(htPage,junk) ==
;  nrows := htpProperty(htPage,'nrows)
;  ncols := htpProperty(htPage,'ncols)
;  labelList :=
;    [f(i) for i in 1..ncols] where f(i) ==
;      spacer := (i > 99 => 0; i > 9 => 1; 2)
;      prefix := STRCONC('"{\em Coefficient ",STRINGIMAGE i,'":}")
;      if spacer ^= 0 then
;        prefix := STRCONC(prefix,'"\space{",STRINGIMAGE spacer,'"}")
;      name := INTERN STRCONC('"c",STRINGIMAGE i)
;      [prefix,"",30, 0,name, 'P]
;  page := htInitPage('"Linear Solve Basic Command",htpPropertyList htPage)
;  htpSetProperty(page,'matrix,htpProperty(htPage,'matrix))
;  htpSetProperty(page,'nrows,nrows)
;  htpSetProperty(page,'ncols,ncols)
;  htMakePage [
;   '(domainConditions (isDomain P (Polynomial $EmptyMode))),
;    '(text . "Enter the right side vector B:"),
;        ['inputStrings, :labelList],
;          '(text . "\vspace{1}\newline Do you want:" ),
;             '(lispLinks
;                 ("All the solutions?" "" bcLinearSolveMatrixInhomoGen all)
;                  ("A particular solution?" "" bcLinearSolveMatrixInhomoGen particular))]
;  htShowPage()

(DEFUN |bcLinearSolveMatrixInhomo,f| (|i|)
  (PROG (|spacer| |prefix| |name|)
    (RETURN
      (SEQ (SPADLET |spacer|
                    (SEQ (IF (> |i| 99) (EXIT 0))
                         (IF (> |i| 9) (EXIT 1)) (EXIT 2)))
           (SPADLET |prefix|
                    (STRCONC (MAKESTRING "{\\em Coefficient ")
                             (STRINGIMAGE |i|) (MAKESTRING ":}")))
           (IF (NEQUAL |spacer| 0)
               (SPADLET |prefix|
                        (STRCONC |prefix| (MAKESTRING "\\space{")
                                 (STRINGIMAGE |spacer|)
                                 (MAKESTRING "}")))
               NIL)
           (SPADLET |name|
                    (INTERN (STRCONC (MAKESTRING "c")
                                     (STRINGIMAGE |i|))))
           (EXIT (CONS |prefix|
                       (CONS '||
                             (CONS 30
                                   (CONS 0 (CONS |name| (CONS 'P NIL)))))))))))

(DEFUN |bcLinearSolveMatrixInhomo| (|htPage| |junk|)
  (declare (ignore |junk|))
  (PROG (|nrows| |ncols| |labelList| |page|)
  (declare (special |$EmptyMode|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |nrows| (|htpProperty| |htPage| '|nrows|))
             (SPADLET |ncols| (|htpProperty| |htPage| '|ncols|))
             (SPADLET |labelList|
                      (PROG (G166692)
                        (SPADLET G166692 NIL)
                        (RETURN
                          (DO ((|i| 1 (QSADD1 |i|)))
                              ((QSGREATERP |i| |ncols|)
                               (NREVERSE0 G166692))
                            (SEQ (EXIT (SETQ G166692
                                        (CONS
                                         (|bcLinearSolveMatrixInhomo,f|
                                          |i|)
                                         G166692))))))))
             (SPADLET |page|
                      (|htInitPage|
                          (MAKESTRING "Linear Solve Basic Command")
                          (|htpPropertyList| |htPage|)))
             (|htpSetProperty| |page| '|matrix|
                 (|htpProperty| |htPage| '|matrix|))
             (|htpSetProperty| |page| '|nrows| |nrows|)
             (|htpSetProperty| |page| '|ncols| |ncols|)
             (|htMakePage|
                 (CONS '(|domainConditions|
                            (|isDomain| P (|Polynomial| |$EmptyMode|)))
                       (CONS '(|text|
                               . "Enter the right side vector B:")
                             (CONS (CONS '|inputStrings| |labelList|)
                                   (CONS
                                    '(|text|
                                      . "\\vspace{1}\\newline Do you want:")
                                    (CONS
                                     '(|lispLinks|
                                       ("All the solutions?" ""
                                        |bcLinearSolveMatrixInhomoGen|
                                        |all|)
                                       ("A particular solution?" ""
                                        |bcLinearSolveMatrixInhomoGen|
                                        |particular|))
                                     NIL))))))
             (|htShowPage|))))))

;bcLinearSolveMatrixInhomoGen(htPage,key) ==  bcLinearMatrixGen(htPage,key)

(DEFUN |bcLinearSolveMatrixInhomoGen| (|htPage| |key|)
  (|bcLinearMatrixGen| |htPage| |key|))

;bcLinearSolveMatrixHomo(htPage,key) == bcLinearMatrixGen(htPage,'homo)

(DEFUN |bcLinearSolveMatrixHomo| (|htPage| |key|)
  (declare (ignore |key|))
  (|bcLinearMatrixGen| |htPage| '|homo|))

;bcLinearMatrixGen(htPage,key) ==
;  matform := bcMatrixGen htPage
;  key = 'homo => bcFinish('"nullSpace",matform)
;  vector := [x.1 for x in REVERSE htpInputAreaAlist htPage]
;  vecform := bcVectorGen vector
;  form := bcMkFunction('"solve",matform,[vecform])
;  bcGen
;    key = 'particular => STRCONC(form,'".particular")
;    form

(DEFUN |bcLinearMatrixGen| (|htPage| |key|)
  (PROG (|matform| |vector| |vecform| |form|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |matform| (|bcMatrixGen| |htPage|))
             (COND
               ((BOOT-EQUAL |key| '|homo|)
                (|bcFinish| (MAKESTRING "nullSpace") |matform|))
               ('T
                (SPADLET |vector|
                         (PROG (G166720)
                           (SPADLET G166720 NIL)
                           (RETURN
                             (DO ((G166725
                                      (REVERSE
                                       (|htpInputAreaAlist| |htPage|))
                                      (CDR G166725))
                                  (|x| NIL))
                                 ((OR (ATOM G166725)
                                      (PROGN
                                        (SETQ |x| (CAR G166725))
                                        NIL))
                                  (NREVERSE0 G166720))
                               (SEQ (EXIT
                                     (SETQ G166720
                                      (CONS (ELT |x| 1) G166720))))))))
                (SPADLET |vecform| (|bcVectorGen| |vector|))
                (SPADLET |form|
                         (|bcMkFunction| (MAKESTRING "solve") |matform|
                             (CONS |vecform| NIL)))
                (|bcGen| (COND
                           ((BOOT-EQUAL |key| '|particular|)
                            (STRCONC |form| (MAKESTRING ".particular")))
                           ('T |form|))))))))))

;linearFinalRequest(nhh,mat,vect) ==
;  sayBrightly '"Do you want more information on the meaning of the output"
;  sayBrightly '"   (1) no "
;  sayBrightly '"   (2) yes "
;  tt := bcQueryInteger(1,2,true)
;  tt=1 => sayBrightly '"Bye Bye"
;  tt=2 => explainLinear(nhh)

(DEFUN |linearFinalRequest| (|nhh| |mat| |vect|)
  (declare (ignore |mat| |vect|))
  (PROG (|tt|)
    (RETURN
      (PROGN
        (|sayBrightly|
            (MAKESTRING
                "Do you want more information on the meaning of the output"))
        (|sayBrightly| (MAKESTRING "   (1) no "))
        (|sayBrightly| (MAKESTRING "   (2) yes "))
        (SPADLET |tt| (|bcQueryInteger| 1 2 'T))
        (COND
          ((EQL |tt| 1) (|sayBrightly| (MAKESTRING "Bye Bye")))
          ((EQL |tt| 2) (|explainLinear| |nhh|)))))))

;explainLinear(flag) ==
;  flag="notHomogeneous" =>
;   '("solve returns a particular solution and a basis for"
;     "the vector space of solutions for the homogeneous part."
;     "The particular solution is _"failed_" if one cannot be found.")
;  flag= "homogeneous" =>
;    '("solve returns a basis for"
;      "the vector space of solutions for the homogeneous part")
;  systemError nil

(DEFUN |explainLinear| (|flag|)
  (COND
    ((BOOT-EQUAL |flag| '|notHomogeneous|)
     '("solve returns a particular solution and a basis for"
       "the vector space of solutions for the homogeneous part."
       "The particular solution is \"failed\" if one cannot be found."))
    ((BOOT-EQUAL |flag| '|homogeneous|)
     '("solve returns a basis for"
       "the vector space of solutions for the homogeneous part"))
    ('T (|systemError| NIL))))

;finalExactRequest(equations,unknowns) ==
;  sayBrightly '"Do you like:"
;  sayBrightly '"   (1) the solutions how they are displayed"
;  sayBrightly '"   (2) to get ????"
;  sayBrightly '"   (3) more information on the meaning of the output"
;  tt := bcQueryInteger(1,3,true)
;  tt=1 => sayBrightly '"Bye Bye"
;  tt=2 => moreExactSolution(equations,unknowns,flag)
;  tt=3 => explainExact(equations,unknowns)

(DEFUN |finalExactRequest| (|equations| |unknowns|)
  (PROG (|tt|)
    (RETURN
      (PROGN
        (|sayBrightly| (MAKESTRING "Do you like:"))
        (|sayBrightly|
            (MAKESTRING "   (1) the solutions how they are displayed"))
        (|sayBrightly| (MAKESTRING "   (2) to get ????"))
        (|sayBrightly|
            (MAKESTRING
                "   (3) more information on the meaning of the output"))
        (SPADLET |tt| (|bcQueryInteger| 1 3 'T))
        (COND
          ((EQL |tt| 1) (|sayBrightly| (MAKESTRING "Bye Bye")))
          ((EQL |tt| 2)
           (|moreExactSolution| |equations| |unknowns|))
          ((EQL |tt| 3) (|explainExact| |equations| |unknowns|)))))))

;bcLinearSolveEqnsGen htPage ==
;  alist := htpInputAreaAlist htPage
;  if vars := htpLabelInputString(htPage,'unknowns) then
;    varlist := bcString2WordList vars
;    varString := (rest varlist => bcwords2liststring varlist; first varlist)
;    alist := rest alist  --know these are first on the list
;  eqnString := bcGenEquations alist
;  bcFinish('"solve",eqnString,varString)

(DEFUN |bcLinearSolveEqnsGen| (|htPage|)
  (PROG (|vars| |varlist| |varString| |alist| |eqnString|)
    (RETURN
      (PROGN
        (SPADLET |alist| (|htpInputAreaAlist| |htPage|))
        (COND
          ((SPADLET |vars|
                    (|htpLabelInputString| |htPage| '|unknowns|))
           (SPADLET |varlist| (|bcString2WordList| |vars|))
           (SPADLET |varString|
                    (COND
                      ((CDR |varlist|)
                       (|bcwords2liststring| |varlist|))
                      ('T (CAR |varlist|))))
           (SPADLET |alist| (CDR |alist|))))
        (SPADLET |eqnString| (|bcGenEquations| |alist|))
        (|bcFinish| (MAKESTRING "solve") |eqnString| |varString|)))))

;bcGenEquations alist ==
;  y := alist
;  while y repeat
;    right := (first y).1
;    y := rest y
;    left := (first y).1
;    y := rest y
;    eqnlist := [STRCONC(left,'" = ",right),:eqnlist]
;  rest eqnlist => bcwords2liststring eqnlist
;  first eqnlist

(DEFUN |bcGenEquations| (|alist|)
  (PROG (|right| |left| |y| |eqnlist|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |y| |alist|)
             (DO () ((NULL |y|) NIL)
               (SEQ (EXIT (PROGN
                            (SPADLET |right| (ELT (CAR |y|) 1))
                            (SPADLET |y| (CDR |y|))
                            (SPADLET |left| (ELT (CAR |y|) 1))
                            (SPADLET |y| (CDR |y|))
                            (SPADLET |eqnlist|
                                     (CONS
                                      (STRCONC |left|
                                       (MAKESTRING " = ") |right|)
                                      |eqnlist|))))))
             (COND
               ((CDR |eqnlist|) (|bcwords2liststring| |eqnlist|))
               ('T (CAR |eqnlist|))))))))

;bcFinish(name,arg,:args) == bcGen bcMkFunction(name,arg,args)

(DEFUN |bcFinish| (&REST G166790 &AUX |args| |arg| |name|)
  (DSETQ (|name| |arg| . |args|) G166790)
  (|bcGen| (|bcMkFunction| |name| |arg| |args|)))

;bcMkFunction(name,arg,args) ==
;  args := [x for x in args | x]
;  STRCONC(name,'"(",arg,"STRCONC"/[STRCONC('",", x) for x in args],'")")

(DEFUN |bcMkFunction| (|name| |arg| |args|)
  (PROG ()
    (RETURN
      (SEQ (PROGN
             (SPADLET |args|
                      (PROG (G166797)
                        (SPADLET G166797 NIL)
                        (RETURN
                          (DO ((G166803 |args| (CDR G166803))
                               (|x| NIL))
                              ((OR (ATOM G166803)
                                   (PROGN
                                     (SETQ |x| (CAR G166803))
                                     NIL))
                               (NREVERSE0 G166797))
                            (SEQ (EXIT (COND
                                         (|x|
                                          (SETQ G166797
                                           (CONS |x| G166797))))))))))
             (STRCONC |name| (MAKESTRING "(") |arg|
                      (PROG (G166809)
                        (SPADLET G166809 "")
                        (RETURN
                          (DO ((G166814 |args| (CDR G166814))
                               (|x| NIL))
                              ((OR (ATOM G166814)
                                   (PROGN
                                     (SETQ |x| (CAR G166814))
                                     NIL))
                               G166809)
                            (SEQ (EXIT (SETQ G166809
                                        (STRCONC G166809
                                         (STRCONC (MAKESTRING ",") |x|))))))))
                      (MAKESTRING ")")))))))

;bcString2HyString2 s ==
;  (STRINGP s) and (s.0 = char '_")  =>
;    len := #s
;    STRCONC('"\_"", SUBSTRING(s, 1, len-2), '"\_"")
;  s

(DEFUN |bcString2HyString2| (|s|)
  (PROG (|len|)
    (RETURN
      (COND
        ((AND (STRINGP |s|) (BOOT-EQUAL (ELT |s| 0) (|char| '|"|)))
         (SPADLET |len| (|#| |s|))
         (STRCONC (MAKESTRING "\\\"")
                  (SUBSTRING |s| 1 (SPADDIFFERENCE |len| 2))
                  (MAKESTRING "\\\"")))
        ('T |s|)))))

;bcString2HyString s == s

(DEFUN |bcString2HyString| (|s|) |s|)

;bcFindString(s,i,n,char) ==  or/[j for j in i..n | s.j = char]

(DEFUN |bcFindString| (|s| |i| |n| |char|)
  (PROG ()
    (RETURN
      (SEQ (PROG (G166835)
             (SPADLET G166835 NIL)
             (RETURN
               (DO ((G166842 NIL G166835) (|j| |i| (+ |j| 1)))
                   ((OR G166842 (> |j| |n|)) G166835)
                 (SEQ (EXIT (COND
                              ((BOOT-EQUAL (ELT |s| |j|) |char|)
                               (SETQ G166835 (OR G166835 |j|)))))))))))))

;bcGen command ==
;  htInitPage('"Basic Command",nil)
;  string :=
;    #command < 50 => STRCONC('"{\centerline{\tt ",command,'" }}")
;    STRCONC('"{\tt ",command,'" }")
;  htMakePage [
;     '(text
;        "{Here is the AXIOM command you could have issued to compute this result:}"
;            "\vspace{2}\newline "),
;      ['text,:string]]
;  htMakeDoitButton('"Do It", command)
;  htShowPage()

(DEFUN |bcGen| (|command|)
  (PROG (|string|)
    (RETURN
      (PROGN
        (|htInitPage| (MAKESTRING "Basic Command") NIL)
        (SPADLET |string|
                 (COND
                   ((QSLESSP (|#| |command|) 50)
                    (STRCONC (MAKESTRING "{\\centerline{\\tt ")
                             |command| (MAKESTRING " }}")))
                   ('T
                    (STRCONC (MAKESTRING "{\\tt ") |command|
                             (MAKESTRING " }")))))
        (|htMakePage|
            (CONS '(|text| "{Here is the AXIOM command you could have issued to compute this result:}"
                           "\\vspace{2}\\newline ")
                  (CONS (CONS '|text| |string|) NIL)))
        (|htMakeDoitButton| (MAKESTRING "Do It") |command|)
        (|htShowPage|)))))

;-- bcGen for axiom - nag link
;linkGen command ==
;  htInitPage('"AXIOM-Nag Link Command",nil)
;  string :=
;    #command < 50 => STRCONC('"{\centerline{ ",command,'" }}")
;    command
;  htMakePage [
;     '(text
;        "\centerline{{\em Here is the AXIOM command}}"
;          "\centerline{{\em you could have issued to compute this result:}}"
;            "\vspace{2}\newline "),
;      ['text,:string]]
;  htMakeDoitButton('"Do It", command)
;  htShowPage()

(DEFUN |linkGen| (|command|)
  (PROG (|string|)
    (RETURN
      (PROGN
        (|htInitPage| (MAKESTRING "AXIOM-Nag Link Command") NIL)
        (SPADLET |string|
                 (COND
                   ((QSLESSP (|#| |command|) 50)
                    (STRCONC (MAKESTRING "{\\centerline{ ") |command|
                             (MAKESTRING " }}")))
                   ('T |command|)))
        (|htMakePage|
            (CONS '(|text| "\\centerline{{\\em Here is the AXIOM command}}"
                           "\\centerline{{\\em you could have issued to compute this result:}}"
                           "\\vspace{2}\\newline ")
                  (CONS (CONS '|text| |string|) NIL)))
        (|htMakeDoitButton| (MAKESTRING "Do It") |command|)
        (|htShowPage|)))))

;bcOptional s ==
;  s = '"" => '"2"
;  s

(DEFUN |bcOptional| (|s|)
  (COND ((BOOT-EQUAL |s| (MAKESTRING "")) (MAKESTRING "2")) ('T |s|)))

;bcvspace() == bcHt '"\vspace{1}\newline "

(DEFUN |bcvspace| () (|bcHt| (MAKESTRING "\\vspace{1}\\newline ")))

;bcString2WordList s == fn(s,0,MAXINDEX s) where
;  fn(s,i,n) ==
;    i > n => nil
;    k := or/[j for j in i..n | s.j ^= char '_  ]
;    null INTEGERP k => nil
;    l := bcFindString(s,k + 1,n,char '_  )
;    null INTEGERP l => [SUBSTRING(s,k,nil)]
;    [SUBSTRING(s,k,l-k),:fn(s,l + 1,n)]

(DEFUN |bcString2WordList,fn| (|s| |i| |n|)
  (PROG (|k| |l|)
    (RETURN
      (SEQ (IF (> |i| |n|) (EXIT NIL))
           (SPADLET |k|
                    (PROG (G166871)
                      (SPADLET G166871 NIL)
                      (RETURN
                        (DO ((G166878 NIL G166871)
                             (|j| |i| (+ |j| 1)))
                            ((OR G166878 (> |j| |n|)) G166871)
                          (SEQ (EXIT (COND
                                       ((NEQUAL (ELT |s| |j|)
                                         (|char| '| |))
                                        (SETQ G166871
                                         (OR G166871 |j|))))))))))
           (IF (NULL (INTEGERP |k|)) (EXIT NIL))
           (SPADLET |l|
                    (|bcFindString| |s| (PLUS |k| 1) |n| (|char| '| |)))
           (IF (NULL (INTEGERP |l|))
               (EXIT (CONS (SUBSTRING |s| |k| NIL) NIL)))
           (EXIT (CONS (SUBSTRING |s| |k| (SPADDIFFERENCE |l| |k|))
                       (|bcString2WordList,fn| |s| (PLUS |l| 1) |n|)))))))


(DEFUN |bcString2WordList| (|s|)
  (|bcString2WordList,fn| |s| 0 (MAXINDEX |s|)))

;bcwords2liststring u ==
;  null u => nil
;  STRCONC('"[",first u,fn rest u) where
;    fn(u) ==
;      null u => '"]"
;      STRCONC('", ",first u,fn rest u)

(DEFUN |bcwords2liststring,fn| (|u|)
  (SEQ (IF (NULL |u|) (EXIT (MAKESTRING "]")))
       (EXIT (STRCONC (MAKESTRING ", ") (CAR |u|)
                      (|bcwords2liststring,fn| (CDR |u|))))))

(DEFUN |bcwords2liststring| (|u|)
  (COND
    ((NULL |u|) NIL)
    ('T
     (STRCONC (MAKESTRING "[") (CAR |u|)
              (|bcwords2liststring,fn| (CDR |u|))))))

;bcVectorGen vec == bcwords2liststring vec

(DEFUN |bcVectorGen| (|vec|) (|bcwords2liststring| |vec|))

;bcError string ==
;  sayBrightlyNT '"NOTE: "
;  sayBrightly string

(DEFUN |bcError| (|string|)
  (PROGN
    (|sayBrightlyNT| (MAKESTRING "NOTE: "))
    (|sayBrightly| |string|)))

;bcDrawIt(ind,a,b) == STRCONC(ind,'"=",a,'"..",b)

(DEFUN |bcDrawIt| (|ind| |a| |b|)
  (STRCONC |ind| (MAKESTRING "=") |a| (MAKESTRING "..") |b|))

;bcNotReady htPage ==
;  htInitPage('"Basic Command",nil)
;  htMakePage '(
;     (text .
;        "{\centerline{\em This facility will soon be available}}"))
;  htShowPage()

(DEFUN |bcNotReady| (|htPage|)
  (declare (ignore |htPage|))
  (PROGN
    (|htInitPage| (MAKESTRING "Basic Command") NIL)
    (|htMakePage|
        '((|text|
           . "{\\centerline{\\em This facility will soon be available}}")))
    (|htShowPage|)))

;htStringPad(n,w) ==
;  s := STRINGIMAGE n
;  ws := #s
;  STRCONC('"\space{",STRINGIMAGE (w - ws + 1),'"}",s)

(DEFUN |htStringPad| (|n| |w|)
  (PROG (|s| |ws|)
    (RETURN
      (PROGN
        (SPADLET |s| (STRINGIMAGE |n|))
        (SPADLET |ws| (|#| |s|))
        (STRCONC (MAKESTRING "\\space{")
                 (STRINGIMAGE (PLUS (SPADDIFFERENCE |w| |ws|) 1))
                 (MAKESTRING "}") |s|)))))

;stringList2String x ==
;  null x => '"()"
;  STRCONC('"(",first x,"STRCONC"/[STRCONC('",",y) for y in rest x],'")")

(DEFUN |stringList2String| (|x|)
  (PROG ()
    (RETURN
      (SEQ (COND
             ((NULL |x|) (MAKESTRING "()"))
             ('T
              (STRCONC (MAKESTRING "(") (CAR |x|)
                       (PROG (G166923)
                         (SPADLET G166923 "")
                         (RETURN
                           (DO ((G166928 (CDR |x|) (CDR G166928))
                                (|y| NIL))
                               ((OR (ATOM G166928)
                                    (PROGN
                                      (SETQ |y| (CAR G166928))
                                      NIL))
                                G166923)
                             (SEQ (EXIT (SETQ G166923
                                         (STRCONC G166923
                                          (STRCONC (MAKESTRING ",")
                                           |y|))))))))
                       (MAKESTRING ")"))))))))

;htMkName(s,n) == STRCONC(s,STRINGIMAGE n)

(DEFUN |htMkName| (|s| |n|) (STRCONC |s| (STRINGIMAGE |n|)))

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}

