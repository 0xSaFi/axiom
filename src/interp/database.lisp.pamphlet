\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp database.boot}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{chunk}{*}
(IN-PACKAGE "BOOT" )

(SETANDFILEQ |$getUnexposedOperations| 'T)

(defun |getDomainFromMm| (mm)
 (let (c cond condList val)
  (setq cond (cadr mm))
  (when (and (pairp cond) (eq (qcar cond) '|partial|))
    (setq cond (qcdr cond)))
  (setq condList
   (cond
    ((and (pairp cond) (eq (qcar cond) 'and))
      (qcdr cond))
    ((and (pairp cond) (eq (qcar cond) 'or)
          (pairp (qcdr cond)) (pairp (qcar (qcdr cond)))
          (eq (qcar (qcar (qcdr cond))) 'and))
      (qcdr (qcar (qcdr cond))))
    (t (list cond))))
  (setq val
   (dolist (condition condList)
    (when
      (and (pairp condition) 
           (or (eq (qcar condition) '|isDomain|)
               (eq (qcar condition) '|ofCategory|))
           (pairp (qcdr condition))
           (eq (qcar (qcdr condition)) '*1)
           (pairp (qcdr (qcdr condition)))
           (eq (qcdr (qcdr (qcdr condition))) nil))
      (return (|opOf| (caddr condition))))))
   (cond
    ((null val)
     (|keyedSystemError| 'S2GE0016
      (list "getDomainFromMm" "Can't find domain in modemap condition")))
    (t val))))

;getFirstArgTypeFromMm mm ==
;  -- Returns the type of the first argument or nil
;  [pats, cond] := mm
;  [.,.,:args] := pats
;  null args => nil
;  arg1 := first args
;  if cond is ['partial, :c] then cond := c
;  condList :=
;    cond is ['AND, :cl] => cl
;    cond is ['OR, ['AND, :cl],:.] => cl  --all cl's should give same info
;    [cond]
;  type := nil
;  for condition in condList while not type repeat
;      if condition is ['isDomain, a1, dom] and a1=arg1 then type := dom
;  type

(DEFUN |getFirstArgTypeFromMm| (|mm|)
  (PROG (|pats| |args| |arg1| |c| |cond| |cl| |condList| |ISTMP#1| |a1|
                |ISTMP#2| |dom| |type|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |pats| (CAR |mm|))
             (SPADLET |cond| (CADR |mm|))
             (SPADLET |args| (CDDR |pats|))
             (COND
               ((NULL |args|) NIL)
               ('T (SPADLET |arg1| (CAR |args|))
                (COND
                  ((AND (PAIRP |cond|) (EQ (QCAR |cond|) '|partial|)
                        (PROGN (SPADLET |c| (QCDR |cond|)) 'T))
                   (SPADLET |cond| |c|)))
                (SPADLET |condList|
                         (COND
                           ((AND (PAIRP |cond|) (EQ (QCAR |cond|) 'AND)
                                 (PROGN
                                   (SPADLET |cl| (QCDR |cond|))
                                   'T))
                            |cl|)
                           ((AND (PAIRP |cond|) (EQ (QCAR |cond|) 'OR)
                                 (PROGN
                                   (SPADLET |ISTMP#1| (QCDR |cond|))
                                   (AND (PAIRP |ISTMP#1|)
                                    (PROGN
                                      (SPADLET |ISTMP#2|
                                       (QCAR |ISTMP#1|))
                                      (AND (PAIRP |ISTMP#2|)
                                       (EQ (QCAR |ISTMP#2|) 'AND)
                                       (PROGN
                                         (SPADLET |cl|
                                          (QCDR |ISTMP#2|))
                                         'T))))))
                            |cl|)
                           ('T (CONS |cond| NIL))))
                (SPADLET |type| NIL)
                (DO ((G167357 |condList| (CDR G167357))
                     (|condition| NIL))
                    ((OR (ATOM G167357)
                         (PROGN
                           (SETQ |condition| (CAR G167357))
                           NIL)
                         (NULL (NULL |type|)))
                     NIL)
                  (SEQ (EXIT (COND
                               ((AND (PAIRP |condition|)
                                     (EQ (QCAR |condition|)
                                      '|isDomain|)
                                     (PROGN
                                       (SPADLET |ISTMP#1|
                                        (QCDR |condition|))
                                       (AND (PAIRP |ISTMP#1|)
                                        (PROGN
                                          (SPADLET |a1|
                                           (QCAR |ISTMP#1|))
                                          (SPADLET |ISTMP#2|
                                           (QCDR |ISTMP#1|))
                                          (AND (PAIRP |ISTMP#2|)
                                           (EQ (QCDR |ISTMP#2|) NIL)
                                           (PROGN
                                             (SPADLET |dom|
                                              (QCAR |ISTMP#2|))
                                             'T)))))
                                     (BOOT-EQUAL |a1| |arg1|))
                                (SPADLET |type| |dom|))
                               ('T NIL)))))
                |type|)))))))

;isFreeFunctionFromMm mm ==
;  -- This returns true is the modemap represents a free function, ie,
;  -- one not coming from a domain or category.
;  [., cond] := mm
;  isFreeFunctionFromMmCond cond

(DEFUN |isFreeFunctionFromMm| (|mm|)
  (PROG (|cond|)
    (RETURN
      (PROGN
        (SPADLET |cond| (CADR |mm|))
        (|isFreeFunctionFromMmCond| |cond|)))))

;isFreeFunctionFromMmCond cond ==
;  -- This returns true is the modemap represents a free function, ie,
;  -- one not coming from a domain or category.
;  if cond is ['partial, :c] then cond := c
;  condList :=
;    cond is ['AND, :cl] => cl
;    cond is ['OR, ['AND, :cl],:.] => cl  --all cl's should give same info
;    [cond]
;  iff := false
;  for condition in condList while not iff repeat
;      if condition is ['isFreeFunction, :.] then iff := true
;  iff

(DEFUN |isFreeFunctionFromMmCond| (|cond|)
  (PROG (|c| |ISTMP#1| |ISTMP#2| |cl| |condList| |iff|)
    (RETURN
      (SEQ (PROGN
             (COND
               ((AND (PAIRP |cond|) (EQ (QCAR |cond|) '|partial|)
                     (PROGN (SPADLET |c| (QCDR |cond|)) 'T))
                (SPADLET |cond| |c|)))
             (SPADLET |condList|
                      (COND
                        ((AND (PAIRP |cond|) (EQ (QCAR |cond|) 'AND)
                              (PROGN (SPADLET |cl| (QCDR |cond|)) 'T))
                         |cl|)
                        ((AND (PAIRP |cond|) (EQ (QCAR |cond|) 'OR)
                              (PROGN
                                (SPADLET |ISTMP#1| (QCDR |cond|))
                                (AND (PAIRP |ISTMP#1|)
                                     (PROGN
                                       (SPADLET |ISTMP#2|
                                        (QCAR |ISTMP#1|))
                                       (AND (PAIRP |ISTMP#2|)
                                        (EQ (QCAR |ISTMP#2|) 'AND)
                                        (PROGN
                                          (SPADLET |cl|
                                           (QCDR |ISTMP#2|))
                                          'T))))))
                         |cl|)
                        ('T (CONS |cond| NIL))))
             (SPADLET |iff| NIL)
             (DO ((G167407 |condList| (CDR G167407))
                  (|condition| NIL))
                 ((OR (ATOM G167407)
                      (PROGN (SETQ |condition| (CAR G167407)) NIL)
                      (NULL (NULL |iff|)))
                  NIL)
               (SEQ (EXIT (COND
                            ((AND (PAIRP |condition|)
                                  (EQ (QCAR |condition|)
                                      '|isFreeFunction|))
                             (SPADLET |iff| 'T))
                            ('T NIL)))))
             |iff|)))))

;getAllModemapsFromDatabase(op,nargs) ==
;  $getUnexposedOperations: local := true
;  startTimingProcess 'diskread
;  ans := getSystemModemaps(op,nargs)
;  stopTimingProcess 'diskread
;  ans

(DEFUN |getAllModemapsFromDatabase| (|op| |nargs|)
  (PROG (|$getUnexposedOperations| |ans|)
    (DECLARE (SPECIAL |$getUnexposedOperations|))
    (RETURN
      (PROGN
        (SPADLET |$getUnexposedOperations| 'T)
        (|startTimingProcess| '|diskread|)
        (SPADLET |ans| (|getSystemModemaps| |op| |nargs|))
        (|stopTimingProcess| '|diskread|)
        |ans|))))

;getModemapsFromDatabase(op,nargs) ==
;  $getUnexposedOperations: local := false
;  startTimingProcess 'diskread
;  ans := getSystemModemaps(op,nargs)
;  stopTimingProcess 'diskread
;  ans

(DEFUN |getModemapsFromDatabase| (|op| |nargs|)
  (PROG (|$getUnexposedOperations| |ans|)
    (DECLARE (SPECIAL |$getUnexposedOperations|))
    (RETURN
      (PROGN
        (SPADLET |$getUnexposedOperations| NIL)
        (|startTimingProcess| '|diskread|)
        (SPADLET |ans| (|getSystemModemaps| |op| |nargs|))
        (|stopTimingProcess| '|diskread|)
        |ans|))))

;getSystemModemaps(op,nargs) ==
;  mml:= GETDATABASE(op,'OPERATION) =>
;    mms := NIL
;    for (x := [[.,:sig],.]) in mml repeat
;      (NUMBERP nargs) and (nargs ^= #QCDR sig) => 'iterate
;      $getUnexposedOperations or isFreeFunctionFromMm(x) or
;        isExposedConstructor(getDomainFromMm(x)) => mms := [x,:mms]
;      'iterate
;    mms
;  nil

(DEFUN |getSystemModemaps| (|op| |nargs|)
  (PROG (|mml| |sig| |mms|)
    (DECLARE (SPECIAL |$getUnexposedOperations|))
    (RETURN
      (SEQ (COND
             ((SPADLET |mml| (GETDATABASE |op| 'OPERATION))
              (SPADLET |mms| NIL)
              (DO ((G167451 |mml| (CDR G167451)) (|x| NIL))
                  ((OR (ATOM G167451)
                       (PROGN (SETQ |x| (CAR G167451)) NIL)
                       (PROGN
                         (PROGN (SPADLET |sig| (CDAR |x|)) |x|)
                         NIL))
                   NIL)
                (SEQ (EXIT (COND
                             ((AND (NUMBERP |nargs|)
                                   (NEQUAL |nargs| (|#| (QCDR |sig|))))
                              '|iterate|)
                             ((OR |$getUnexposedOperations|
                                  (|isFreeFunctionFromMm| |x|)
                                  (|isExposedConstructor|
                                      (|getDomainFromMm| |x|)))
                              (SPADLET |mms| (CONS |x| |mms|)))
                             ('T '|iterate|)))))
              |mms|)
             ('T NIL))))))

\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
