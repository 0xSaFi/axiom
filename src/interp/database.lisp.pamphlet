\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp database.boot}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{chunk}{*}
(IN-PACKAGE "BOOT" )

(SETANDFILEQ |$getUnexposedOperations| 'T)

;buildDatabase(filemode,expensive) ==
;  $InteractiveMode: local:= true
;  $constructorList := nil       --looked at by buildLibdb
;  $ConstructorCache:= MAKE_-HASHTABLE('ID)
;  SAY '"Making constructor autoload"
;  makeConstructorsAutoLoad()
;  SAY '"Building category table"
;  genCategoryTable()
;  SAY '"Building libdb.text"
;  buildLibdb()
;  SAY '"splitting libdb.text"
;  dbSplitLibdb()
;  SAY '"creating browse constructor index"
;  dbAugmentConstructorDataTable()
;  SAY '"Building browse.lisp"
;  buildBrowsedb()
;  SAY '"Building constructor users database"
;  mkUsersHashTable()
;  SAY '"Saving constructor users database"
;  saveUsersHashTable()
;  SAY '"Building constructor dependents database"
;  mkDependentsHashTable()
;  SAY '"Saving constructor dependents database"
;  saveDependentsHashTable()
;  SAY '"Building glossary files"
;  buildGloss()

(DEFUN |buildDatabase| (|filemode| |expensive|)
  (declare (ignore |filemode| |expensive|))
  (PROG (|$InteractiveMode|)
    (DECLARE (SPECIAL |$InteractiveMode| |$ConstructorCache|
                      |$constructorList|))
    (RETURN
      (PROGN
        (SPADLET |$InteractiveMode| 'T)
        (SPADLET |$constructorList| NIL)
        (SPADLET |$ConstructorCache| (MAKE-HASHTABLE 'ID))
        (SAY "Making constructor autoload")
        (|makeConstructorsAutoLoad|)
        (SAY "Building category table")
        (|genCategoryTable|)
        (SAY "Building libdb.text")
        (|buildLibdb|)
        (SAY "splitting libdb.text")
        (|dbSplitLibdb|)
        (SAY "creating browse constructor index")
        (|dbAugmentConstructorDataTable|)
        (SAY "Building browse.lisp")
        (|buildBrowsedb|)
        (SAY "Building constructor users database")
        (|mkUsersHashTable|)
        (SAY "Saving constructor users database")
        (|saveUsersHashTable|)
        (SAY "Building constructor dependents database")
        (|mkDependentsHashTable|)
        (SAY "Saving constructor dependents database")
        (|saveDependentsHashTable|)
        (SAY "Building glossary files")
        (|buildGloss|)))))

;saveUsersHashTable() ==
;  _$ERASE('users,'DATABASE,'a)
;  stream:= writeLib1('users,'DATABASE,'a)
;  for k in MSORT HKEYS $usersTb repeat
;    rwrite(k, HGET($usersTb, k), stream)
;  RSHUT stream

(DEFUN |saveUsersHashTable| ()
  (PROG (|stream|)
    (DECLARE (SPECIAL |$usersTb| $ERASE))
    (RETURN
      (SEQ (PROGN
             ($ERASE '|users| 'DATABASE '|a|)
             (SPADLET |stream| (|writeLib1| '|users| 'DATABASE '|a|))
             (DO ((G166334 (MSORT (HKEYS |$usersTb|))
                      (CDR G166334))
                  (|k| NIL))
                 ((OR (ATOM G166334)
                      (PROGN (SETQ |k| (CAR G166334)) NIL))
                  NIL)
               (SEQ (EXIT (|rwrite| |k| (HGET |$usersTb| |k|) |stream|))))
             (RSHUT |stream|))))))

;saveDependentsHashTable() ==
;  _$ERASE('dependents,'DATABASE,'a)
;  stream:= writeLib1('dependents,'DATABASE,'a)
;  for k in MSORT HKEYS $depTb repeat
;    rwrite(k, HGET($depTb, k), stream)
;  RSHUT stream

(DEFUN |saveDependentsHashTable| ()
  (PROG (|stream|)
    (DECLARE (SPECIAL |$depTb| $ERASE))
    (RETURN
      (SEQ (PROGN
             ($ERASE '|dependents| 'DATABASE '|a|)
             (SPADLET |stream|
                      (|writeLib1| '|dependents| 'DATABASE '|a|))
             (DO ((G166348 (MSORT (HKEYS |$depTb|)) (CDR G166348))
                  (|k| NIL))
                 ((OR (ATOM G166348)
                      (PROGN (SETQ |k| (CAR G166348)) NIL))
                  NIL)
               (SEQ (EXIT (|rwrite| |k| (HGET |$depTb| |k|) |stream|))))
             (RSHUT |stream|))))))

;readLib1(fn,ft,fm) ==
;  -- see if it exists first
;  p := pathname [fn,ft,fm]
;  readLibPathFast p

(defun |readLib1| (fn ft fm)
 (|readLibPathFast| (|pathname| (list fn ft fm))))

;getUsersOfConstructor(con) ==
;  stream := readLib1('users, 'DATABASE, 'a)
;  val := rread(con, stream, nil)
;  RSHUT stream
;  val

(DEFUN |getUsersOfConstructor| (|con|)
  (PROG (|stream| |val|)
    (RETURN
      (PROGN
        (SPADLET |stream| (|readLib1| '|users| 'DATABASE '|a|))
        (SPADLET |val| (|rread| |con| |stream| NIL))
        (RSHUT |stream|)
        |val|))))

;getDependentsOfConstructor(con) ==
;  stream := readLib1('dependents, 'DATABASE, 'a)
;  val := rread(con, stream, nil)
;  RSHUT stream
;  val

(DEFUN |getDependentsOfConstructor| (|con|)
  (PROG (|stream| |val|)
    (RETURN
      (PROGN
        (SPADLET |stream| (|readLib1| '|dependents| 'DATABASE '|a|))
        (SPADLET |val| (|rread| |con| |stream| NIL))
        (RSHUT |stream|)
        |val|))))

;orderPredicateItems(pred1,sig,skip) ==
;  pred:= signatureTran pred1
;  pred is ["AND",:l] => orderPredTran(l,sig,skip)
;  pred

(DEFUN |orderPredicateItems| (|pred1| |sig| |skip|)
  (PROG (|pred| |l|)
    (RETURN
      (PROGN
        (SPADLET |pred| (|signatureTran| |pred1|))
        (COND
          ((AND (PAIRP |pred|) (EQ (QCAR |pred|) 'AND)
                (PROGN (SPADLET |l| (QCDR |pred|)) 'T))
           (|orderPredTran| |l| |sig| |skip|))
          ('T |pred|))))))

;orderPredTran(oldList,sig,skip) ==
;  lastPreds:=nil
;  --(1) make two kinds of predicates appear last:
;  -----  (op *target ..) when *target does not appear later in sig
;  -----  (isDomain *1 ..)
;  for pred in oldList repeat
;    ((pred is [op,pvar,.] and MEMQ(op,'(isDomain ofCategory))
;       and pvar=first sig and ^(pvar in rest sig)) or
;        (^skip and pred is ['isDomain,pvar,.] and pvar="*1")) =>
;          oldList:=DELETE(pred,oldList)
;          lastPreds:=[pred,:lastPreds]
;--sayBrightlyNT "lastPreds="
;--pp lastPreds
;  --(2a) lastDependList=list of all variables that lastPred forms depend upon
;  lastDependList := "UNIONQ"/[listOfPatternIds x for x in lastPreds]
;--sayBrightlyNT "lastDependList="
;--pp lastDependList
;  --(2b) dependList=list of all variables that isDom/ofCat forms depend upon
;  dependList :=
;    "UNIONQ"/[listOfPatternIds y for x in oldList |
;      x is ['isDomain,.,y] or x is ['ofCategory,.,y]]
;--sayBrightlyNT "dependList="
;--pp dependList
;  --(3a) newList= list of ofCat/isDom entries that don't depend on
;  for x in oldList repeat
;    if (x is ['ofCategory,v,body]) or (x is ['isDomain,v,body]) then
;      indepvl:=listOfPatternIds v
;      depvl:=listOfPatternIds body
;    else
;      indepvl := listOfPatternIds x
;      depvl := nil
;    (INTERSECTIONQ(indepvl,dependList) = nil)
;        and INTERSECTIONQ(indepvl,lastDependList) =>
;      somethingDone := true
;      lastPreds := [:lastPreds,x]
;      oldList := DELETE(x,oldList)
;--if somethingDone then
;--  sayBrightlyNT "Again lastPreds="
;--  pp lastPreds
;--  sayBrightlyNT "Again oldList="
;--  pp oldList
;  --(3b) newList= list of ofCat/isDom entries that don't depend on
;  while oldList repeat
;    for x in oldList repeat
;      if (x is ['ofCategory,v,body]) or (x is ['isDomain,v,body]) then
;        indepvl:=listOfPatternIds v
;        depvl:=listOfPatternIds body
;      else
;        indepvl := listOfPatternIds x
;        depvl := nil
;      (INTERSECTIONQ(indepvl,dependList) = nil) =>
;        dependList:= setDifference(dependList,depvl)
;        newList:= [:newList,x]
;--  sayBrightlyNT "newList="
;--  pp newList
;  --(4) noldList= what is left over
;    (noldList:= setDifference(oldList,newList)) = oldList =>
;--    sayMSG '"NOTE: Parameters to domain have circular dependencies"
;      newList := [:newList,:oldList]
;      return nil
;    oldList:=noldList
;--  sayBrightlyNT "noldList="
;--  pp noldList
;  for pred in newList repeat
;    if pred is ['isDomain,x,y] or x is ['ofCategory,x,y] then
;      ids:= listOfPatternIds y
;      if and/[id in fullDependList for id in ids] then
;        fullDependList:= insertWOC(x,fullDependList)
;      fullDependList:= UNIONQ(fullDependList,ids)
;  newList:=[:newList,:lastPreds]
;--substitute (isDomain ..) forms as completely as possible to avoid false paths
;  newList := isDomainSubst newList
;  answer := [['AND,:newList],:INTERSECTIONQ(fullDependList,sig)]

(DEFUN |orderPredTran| (|oldList| |sig| |skip|)
  (PROG (|op| |pvar| |lastDependList| |somethingDone| |lastPreds| |v|
              |body| |indepvl| |depvl| |dependList| |noldList|
              |ISTMP#1| |x| |ISTMP#2| |y| |ids| |fullDependList|
              |newList| |answer|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |lastPreds| NIL)
             (SEQ (DO ((G166547 |oldList| (CDR G166547))
                       (|pred| NIL))
                      ((OR (ATOM G166547)
                           (PROGN (SETQ |pred| (CAR G166547)) NIL))
                       NIL)
                    (SEQ (EXIT (COND
                                 ((OR (AND (PAIRP |pred|)
                                       (PROGN
                                         (SPADLET |op| (QCAR |pred|))
                                         (SPADLET |ISTMP#1|
                                          (QCDR |pred|))
                                         (AND (PAIRP |ISTMP#1|)
                                          (PROGN
                                            (SPADLET |pvar|
                                             (QCAR |ISTMP#1|))
                                            (SPADLET |ISTMP#2|
                                             (QCDR |ISTMP#1|))
                                            (AND (PAIRP |ISTMP#2|)
                                             (EQ (QCDR |ISTMP#2|) NIL)))))
                                       (member |op|
                                        '(|isDomain| |ofCategory|))
                                       (BOOT-EQUAL |pvar| (CAR |sig|))
                                       (NULL
                                        (|member| |pvar| (CDR |sig|))))
                                      (AND (NULL |skip|) (PAIRP |pred|)
                                       (EQ (QCAR |pred|) '|isDomain|)
                                       (PROGN
                                         (SPADLET |ISTMP#1|
                                          (QCDR |pred|))
                                         (AND (PAIRP |ISTMP#1|)
                                          (PROGN
                                            (SPADLET |pvar|
                                             (QCAR |ISTMP#1|))
                                            (SPADLET |ISTMP#2|
                                             (QCDR |ISTMP#1|))
                                            (AND (PAIRP |ISTMP#2|)
                                             (EQ (QCDR |ISTMP#2|) NIL)))))
                                       (BOOT-EQUAL |pvar| '*1)))
                                  (EXIT (PROGN
                                          (SPADLET |oldList|
                                           (|delete| |pred| |oldList|))
                                          (SPADLET |lastPreds|
                                           (CONS |pred| |lastPreds|)))))))))
                  (SPADLET |lastDependList|
                           (PROG (G166553)
                             (SPADLET G166553 NIL)
                             (RETURN
                               (DO ((G166558 |lastPreds|
                                     (CDR G166558))
                                    (|x| NIL))
                                   ((OR (ATOM G166558)
                                     (PROGN
                                       (SETQ |x| (CAR G166558))
                                       NIL))
                                    G166553)
                                 (SEQ (EXIT
                                       (SETQ G166553
                                        (UNIONQ G166553
                                         (|listOfPatternIds| |x|)))))))))
                  (SPADLET |dependList|
                           (PROG (G166564)
                             (SPADLET G166564 NIL)
                             (RETURN
                               (DO ((G166570 |oldList|
                                     (CDR G166570))
                                    (|x| NIL))
                                   ((OR (ATOM G166570)
                                     (PROGN
                                       (SETQ |x| (CAR G166570))
                                       NIL))
                                    G166564)
                                 (SEQ (EXIT
                                       (COND
                                         ((OR
                                           (AND (PAIRP |x|)
                                            (EQ (QCAR |x|) '|isDomain|)
                                            (PROGN
                                              (SPADLET |ISTMP#1|
                                               (QCDR |x|))
                                              (AND (PAIRP |ISTMP#1|)
                                               (PROGN
                                                 (SPADLET |ISTMP#2|
                                                  (QCDR |ISTMP#1|))
                                                 (AND (PAIRP |ISTMP#2|)
                                                  (EQ (QCDR |ISTMP#2|)
                                                   NIL)
                                                  (PROGN
                                                    (SPADLET |y|
                                                     (QCAR |ISTMP#2|))
                                                    'T))))))
                                           (AND (PAIRP |x|)
                                            (EQ (QCAR |x|)
                                             '|ofCategory|)
                                            (PROGN
                                              (SPADLET |ISTMP#1|
                                               (QCDR |x|))
                                              (AND (PAIRP |ISTMP#1|)
                                               (PROGN
                                                 (SPADLET |ISTMP#2|
                                                  (QCDR |ISTMP#1|))
                                                 (AND (PAIRP |ISTMP#2|)
                                                  (EQ (QCDR |ISTMP#2|)
                                                   NIL)
                                                  (PROGN
                                                    (SPADLET |y|
                                                     (QCAR |ISTMP#2|))
                                                    'T)))))))
                                          (SETQ G166564
                                           (UNIONQ G166564
                                            (|listOfPatternIds| |y|)))))))))))
                  (DO ((G166598 |oldList| (CDR G166598)) (|x| NIL))
                      ((OR (ATOM G166598)
                           (PROGN (SETQ |x| (CAR G166598)) NIL))
                       NIL)
                    (SEQ (EXIT (PROGN
                                 (COND
                                   ((OR
                                     (AND (PAIRP |x|)
                                      (EQ (QCAR |x|) '|ofCategory|)
                                      (PROGN
                                        (SPADLET |ISTMP#1| (QCDR |x|))
                                        (AND (PAIRP |ISTMP#1|)
                                         (PROGN
                                           (SPADLET |v|
                                            (QCAR |ISTMP#1|))
                                           (SPADLET |ISTMP#2|
                                            (QCDR |ISTMP#1|))
                                           (AND (PAIRP |ISTMP#2|)
                                            (EQ (QCDR |ISTMP#2|) NIL)
                                            (PROGN
                                              (SPADLET |body|
                                               (QCAR |ISTMP#2|))
                                              'T))))))
                                     (AND (PAIRP |x|)
                                      (EQ (QCAR |x|) '|isDomain|)
                                      (PROGN
                                        (SPADLET |ISTMP#1| (QCDR |x|))
                                        (AND (PAIRP |ISTMP#1|)
                                         (PROGN
                                           (SPADLET |v|
                                            (QCAR |ISTMP#1|))
                                           (SPADLET |ISTMP#2|
                                            (QCDR |ISTMP#1|))
                                           (AND (PAIRP |ISTMP#2|)
                                            (EQ (QCDR |ISTMP#2|) NIL)
                                            (PROGN
                                              (SPADLET |body|
                                               (QCAR |ISTMP#2|))
                                              'T)))))))
                                    (SPADLET |indepvl|
                                     (|listOfPatternIds| |v|))
                                    (SPADLET |depvl|
                                     (|listOfPatternIds| |body|)))
                                   ('T
                                    (SPADLET |indepvl|
                                     (|listOfPatternIds| |x|))
                                    (SPADLET |depvl| NIL)))
                                 (COND
                                   ((AND
                                     (NULL
                                      (INTERSECTIONQ |indepvl|
                                       |dependList|))
                                     (INTERSECTIONQ |indepvl|
                                      |lastDependList|))
                                    (PROGN
                                      (SPADLET |somethingDone| 'T)
                                      (SPADLET |lastPreds|
                                       (APPEND |lastPreds|
                                        (CONS |x| NIL)))
                                      (SPADLET |oldList|
                                       (|delete| |x| |oldList|)))))))))
                  (DO () ((NULL |oldList|) NIL)
                    (SEQ (EXIT (PROGN
                                 (DO ((G166651 |oldList|
                                       (CDR G166651))
                                      (|x| NIL))
                                     ((OR (ATOM G166651)
                                       (PROGN
                                         (SETQ |x| (CAR G166651))
                                         NIL))
                                      NIL)
                                   (SEQ
                                    (EXIT
                                     (PROGN
                                       (COND
                                         ((OR
                                           (AND (PAIRP |x|)
                                            (EQ (QCAR |x|)
                                             '|ofCategory|)
                                            (PROGN
                                              (SPADLET |ISTMP#1|
                                               (QCDR |x|))
                                              (AND (PAIRP |ISTMP#1|)
                                               (PROGN
                                                 (SPADLET |v|
                                                  (QCAR |ISTMP#1|))
                                                 (SPADLET |ISTMP#2|
                                                  (QCDR |ISTMP#1|))
                                                 (AND (PAIRP |ISTMP#2|)
                                                  (EQ (QCDR |ISTMP#2|)
                                                   NIL)
                                                  (PROGN
                                                    (SPADLET |body|
                                                     (QCAR |ISTMP#2|))
                                                    'T))))))
                                           (AND (PAIRP |x|)
                                            (EQ (QCAR |x|) '|isDomain|)
                                            (PROGN
                                              (SPADLET |ISTMP#1|
                                               (QCDR |x|))
                                              (AND (PAIRP |ISTMP#1|)
                                               (PROGN
                                                 (SPADLET |v|
                                                  (QCAR |ISTMP#1|))
                                                 (SPADLET |ISTMP#2|
                                                  (QCDR |ISTMP#1|))
                                                 (AND (PAIRP |ISTMP#2|)
                                                  (EQ (QCDR |ISTMP#2|)
                                                   NIL)
                                                  (PROGN
                                                    (SPADLET |body|
                                                     (QCAR |ISTMP#2|))
                                                    'T)))))))
                                          (SPADLET |indepvl|
                                           (|listOfPatternIds| |v|))
                                          (SPADLET |depvl|
                                           (|listOfPatternIds| |body|)))
                                         ('T
                                          (SPADLET |indepvl|
                                           (|listOfPatternIds| |x|))
                                          (SPADLET |depvl| NIL)))
                                       (COND
                                         ((NULL
                                           (INTERSECTIONQ |indepvl|
                                            |dependList|))
                                          (PROGN
                                            (SPADLET |dependList|
                                             (SETDIFFERENCE
                                              |dependList| |depvl|))
                                            (SPADLET |newList|
                                             (APPEND |newList|
                                              (CONS |x| NIL))))))))))
                                 (COND
                                   ((BOOT-EQUAL
                                     (SPADLET |noldList|
                                      (SETDIFFERENCE |oldList|
                                       |newList|))
                                     |oldList|)
                                    (SPADLET |newList|
                                     (APPEND |newList| |oldList|))
                                    (RETURN NIL))
                                   ('T (SPADLET |oldList| |noldList|)))))))
                  (DO ((G166674 |newList| (CDR G166674))
                       (|pred| NIL))
                      ((OR (ATOM G166674)
                           (PROGN (SETQ |pred| (CAR G166674)) NIL))
                       NIL)
                    (SEQ (EXIT (COND
                                 ((OR (AND (PAIRP |pred|)
                                       (EQ (QCAR |pred|) '|isDomain|)
                                       (PROGN
                                         (SPADLET |ISTMP#1|
                                          (QCDR |pred|))
                                         (AND (PAIRP |ISTMP#1|)
                                          (PROGN
                                            (SPADLET |x|
                                             (QCAR |ISTMP#1|))
                                            (SPADLET |ISTMP#2|
                                             (QCDR |ISTMP#1|))
                                            (AND (PAIRP |ISTMP#2|)
                                             (EQ (QCDR |ISTMP#2|) NIL)
                                             (PROGN
                                               (SPADLET |y|
                                                (QCAR |ISTMP#2|))
                                               'T))))))
                                      (AND (PAIRP |x|)
                                       (EQ (QCAR |x|) '|ofCategory|)
                                       (PROGN
                                         (SPADLET |ISTMP#1| (QCDR |x|))
                                         (AND (PAIRP |ISTMP#1|)
                                          (PROGN
                                            (SPADLET |x|
                                             (QCAR |ISTMP#1|))
                                            (SPADLET |ISTMP#2|
                                             (QCDR |ISTMP#1|))
                                            (AND (PAIRP |ISTMP#2|)
                                             (EQ (QCDR |ISTMP#2|) NIL)
                                             (PROGN
                                               (SPADLET |y|
                                                (QCAR |ISTMP#2|))
                                               'T)))))))
                                  (SPADLET |ids|
                                           (|listOfPatternIds| |y|))
                                  (COND
                                    ((PROG (G166680)
                                       (SPADLET G166680 'T)
                                       (RETURN
                                         (DO
                                          ((G166686 NIL
                                            (NULL G166680))
                                           (G166687 |ids|
                                            (CDR G166687))
                                           (|id| NIL))
                                          ((OR G166686
                                            (ATOM G166687)
                                            (PROGN
                                              (SETQ |id|
                                               (CAR G166687))
                                              NIL))
                                           G166680)
                                           (SEQ
                                            (EXIT
                                             (SETQ G166680
                                              (AND G166680
                                               (|member| |id|
                                                |fullDependList|))))))))
                                     (SPADLET |fullDependList|
                                      (|insertWOC| |x|
                                       |fullDependList|))))
                                  (SPADLET |fullDependList|
                                           (UNIONQ |fullDependList|
                                            |ids|)))
                                 ('T NIL)))))
                  (SPADLET |newList| (APPEND |newList| |lastPreds|))
                  (SPADLET |newList| (|isDomainSubst| |newList|))
                  (SPADLET |answer|
                           (CONS (CONS 'AND |newList|)
                                 (INTERSECTIONQ |fullDependList| |sig|)))))))))

;--sayBrightlyNT '"answer="
;--pp answer
;isDomainSubst u == main where
;  main ==
;    u is [head,:tail] =>
;      nhead :=
;        head is ['isDomain,x,y] => ['isDomain,x,fn(y,tail)]
;        head
;      [nhead,:isDomainSubst rest u]
;    u
;  fn(x,alist) ==
;    atom x =>
;      IDENTP x and MEMQ(x,$PatternVariableList) and (s := findSub(x,alist)) => s
;      x
;    [CAR x,:[fn(y,alist) for y in CDR x]]
;  findSub(x,alist) ==
;    null alist => nil
;    alist is [['isDomain,y,z],:.] and x = y => z
;    findSub(x,rest alist)

(DEFUN |isDomainSubst,findSub| (|x| |alist|)
  (PROG (|ISTMP#1| |ISTMP#2| |y| |ISTMP#3| |z|)
    (RETURN
      (SEQ (IF (NULL |alist|) (EXIT NIL))
           (IF (AND (AND (PAIRP |alist|)
                         (PROGN
                           (SPADLET |ISTMP#1| (QCAR |alist|))
                           (AND (PAIRP |ISTMP#1|)
                                (EQ (QCAR |ISTMP#1|) '|isDomain|)
                                (PROGN
                                  (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                                  (AND (PAIRP |ISTMP#2|)
                                       (PROGN
                                         (SPADLET |y| (QCAR |ISTMP#2|))
                                         (SPADLET |ISTMP#3|
                                          (QCDR |ISTMP#2|))
                                         (AND (PAIRP |ISTMP#3|)
                                          (EQ (QCDR |ISTMP#3|) NIL)
                                          (PROGN
                                            (SPADLET |z|
                                             (QCAR |ISTMP#3|))
                                            'T))))))))
                    (BOOT-EQUAL |x| |y|))
               (EXIT |z|))
           (EXIT (|isDomainSubst,findSub| |x| (CDR |alist|)))))))

(DEFUN |isDomainSubst,fn| (|x| |alist|)
  (PROG (|s|)
    (DECLARE (SPECIAL |$PatternVariableList|))
    (RETURN
      (SEQ (IF (ATOM |x|)
               (EXIT (SEQ (IF (AND (AND (IDENTP |x|)
                                    (member |x| |$PatternVariableList|))
                                   (SPADLET |s|
                                    (|isDomainSubst,findSub| |x|
                                     |alist|)))
                              (EXIT |s|))
                          (EXIT |x|))))
           (EXIT (CONS (CAR |x|)
                       (PROG (G166826)
                         (SPADLET G166826 NIL)
                         (RETURN
                           (DO ((G166831 (CDR |x|) (CDR G166831))
                                (|y| NIL))
                               ((OR (ATOM G166831)
                                    (PROGN
                                      (SETQ |y| (CAR G166831))
                                      NIL))
                                (NREVERSE0 G166826))
                             (SEQ (EXIT (SETQ G166826
                                         (CONS
                                          (|isDomainSubst,fn| |y|
                                           |alist|)
                                          G166826)))))))))))))

(DEFUN |isDomainSubst| (|u|)
  (PROG (|head| |tail| |ISTMP#1| |x| |ISTMP#2| |y| |nhead|)
    (RETURN
      (COND
        ((AND (PAIRP |u|)
              (PROGN
                (SPADLET |head| (QCAR |u|))
                (SPADLET |tail| (QCDR |u|))
                'T))
         (SPADLET |nhead|
                  (COND
                    ((AND (PAIRP |head|) (EQ (QCAR |head|) '|isDomain|)
                          (PROGN
                            (SPADLET |ISTMP#1| (QCDR |head|))
                            (AND (PAIRP |ISTMP#1|)
                                 (PROGN
                                   (SPADLET |x| (QCAR |ISTMP#1|))
                                   (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                                   (AND (PAIRP |ISTMP#2|)
                                    (EQ (QCDR |ISTMP#2|) NIL)
                                    (PROGN
                                      (SPADLET |y| (QCAR |ISTMP#2|))
                                      'T))))))
                     (CONS '|isDomain|
                           (CONS |x|
                                 (CONS (|isDomainSubst,fn| |y| |tail|)
                                       NIL))))
                    ('T |head|)))
         (CONS |nhead| (|isDomainSubst| (CDR |u|))))
        ('T |u|)))))

;signatureTran pred ==
;  atom pred => pred
;  pred is ['has,D,catForm] and isCategoryForm(catForm,$e) =>
;    ['ofCategory,D,catForm]
;  [signatureTran p for p in pred]

(DEFUN |signatureTran| (|pred|)
  (PROG (|ISTMP#1| D |ISTMP#2| |catForm|)
    (DECLARE (SPECIAL |$e|))
    (RETURN
      (SEQ (COND
             ((ATOM |pred|) |pred|)
             ((AND (PAIRP |pred|) (EQ (QCAR |pred|) '|has|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |pred|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET D (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (PAIRP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |catForm| (QCAR |ISTMP#2|))
                                   'T)))))
                   (|isCategoryForm| |catForm| |$e|))
              (CONS '|ofCategory| (CONS D (CONS |catForm| NIL))))
             ('T
              (PROG (G166884)
                (SPADLET G166884 NIL)
                (RETURN
                  (DO ((G166889 |pred| (CDR G166889)) (|p| NIL))
                      ((OR (ATOM G166889)
                           (PROGN (SETQ |p| (CAR G166889)) NIL))
                       (NREVERSE0 G166884))
                    (SEQ (EXIT (SETQ G166884
                                     (CONS (|signatureTran| |p|)
                                      G166884)))))))))))))

;interactiveModemapForm mm ==
;  --  create modemap form for use by the interpreter.  This function
;  --  replaces all specific domains mentioned in the modemap with pattern
;  --  variables, and predicates
;  mm := replaceVars(COPY mm,$PatternVariableList,$FormalMapVariableList)
;  [pattern:=[dc,:sig],pred] := mm
;  pred := [fn x for x in pred] where fn x ==
;    x is [a,b,c] and a ^= 'isFreeFunction and atom c => [a,b,[c]]
;    x
;--pp pred
;  [mmpat, patternAlist, partial, patvars] :=
;    modemapPattern(pattern,sig)
;--pp [pattern, mmpat, patternAlist, partial, patvars]
;  [pred,domainPredicateList] :=
;    substVars(pred,patternAlist,patvars)
;--pp [pred,domainPredicateList]
;  [pred,:dependList]:=
;    fixUpPredicate(pred,domainPredicateList,partial,rest mmpat)
;--pp [pred,dependList]
;  [cond, :.] := pred
;  [mmpat, cond]

(DEFUN |interactiveModemapForm,fn| (|x|)
  (PROG (|a| |ISTMP#1| |b| |ISTMP#2| |c|)
    (RETURN
      (SEQ (IF (AND (AND (AND (PAIRP |x|)
                              (PROGN
                                (SPADLET |a| (QCAR |x|))
                                (SPADLET |ISTMP#1| (QCDR |x|))
                                (AND (PAIRP |ISTMP#1|)
                                     (PROGN
                                       (SPADLET |b| (QCAR |ISTMP#1|))
                                       (SPADLET |ISTMP#2|
                                        (QCDR |ISTMP#1|))
                                       (AND (PAIRP |ISTMP#2|)
                                        (EQ (QCDR |ISTMP#2|) NIL)
                                        (PROGN
                                          (SPADLET |c|
                                           (QCAR |ISTMP#2|))
                                          'T))))))
                         (NEQUAL |a| '|isFreeFunction|))
                    (ATOM |c|))
               (EXIT (CONS |a| (CONS |b| (CONS (CONS |c| NIL) NIL)))))
           (EXIT |x|)))))

(DEFUN |interactiveModemapForm| (|mm|)
  (PROG (|pattern| |dc| |sig| |mmpat| |patternAlist| |partial|
            |patvars| |domainPredicateList| |LETTMP#1| |pred|
            |dependList| |cond|)
    (DECLARE (SPECIAL |$PatternVariableList| |$FormalMapVariableList|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |mm|
                      (|replaceVars| (COPY |mm|) |$PatternVariableList|
                          |$FormalMapVariableList|))
             (SPADLET |pattern| (CAR |mm|))
             (SPADLET |dc| (CAAR |mm|))
             (SPADLET |sig| (CDAR |mm|))
             (SPADLET |pred| (CADR |mm|))
             (SPADLET |pred|
                      (PROG (G166974)
                        (SPADLET G166974 NIL)
                        (RETURN
                          (DO ((G166979 |pred| (CDR G166979))
                               (|x| NIL))
                              ((OR (ATOM G166979)
                                   (PROGN
                                     (SETQ |x| (CAR G166979))
                                     NIL))
                               (NREVERSE0 G166974))
                            (SEQ (EXIT (SETQ G166974
                                        (CONS
                                         (|interactiveModemapForm,fn|
                                          |x|)
                                         G166974))))))))
             (SPADLET |LETTMP#1| (|modemapPattern| |pattern| |sig|))
             (SPADLET |mmpat| (CAR |LETTMP#1|))
             (SPADLET |patternAlist| (CADR |LETTMP#1|))
             (SPADLET |partial| (CADDR |LETTMP#1|))
             (SPADLET |patvars| (CADDDR |LETTMP#1|))
             (SPADLET |LETTMP#1|
                      (|substVars| |pred| |patternAlist| |patvars|))
             (SPADLET |pred| (CAR |LETTMP#1|))
             (SPADLET |domainPredicateList| (CADR |LETTMP#1|))
             (SPADLET |LETTMP#1|
                      (|fixUpPredicate| |pred| |domainPredicateList|
                          |partial| (CDR |mmpat|)))
             (SPADLET |pred| (CAR |LETTMP#1|))
             (SPADLET |dependList| (CDR |LETTMP#1|))
             (SPADLET |cond| (CAR |pred|))
             (CONS |mmpat| (CONS |cond| NIL)))))))

;modemapPattern(mmPattern,sig) ==
;  --  Returns a list of the pattern of a modemap, an Alist of the
;  --  substitutions made, a boolean flag indicating whether
;  --  the result type is partial, and a list of unused pattern variables
;  patternAlist := nil
;  mmpat := nil
;  patvars := $PatternVariableList
;  partial := false
;  for xTails in tails mmPattern repeat
;    x := first xTails
;    if x is ['Union,dom,tag] and tag = '"failed" and xTails=sig then
;      x := dom
;      partial := true
;    patvar := RASSOC(x,patternAlist)
;    not null patvar => mmpat := [patvar,:mmpat]
;    patvar := first patvars
;    patvars := rest patvars
;    mmpat := [patvar,:mmpat]
;    patternAlist := [[patvar,:x],:patternAlist]
;  [NREVERSE mmpat,patternAlist,partial,patvars]

(DEFUN |modemapPattern| (|mmPattern| |sig|)
  (PROG (|ISTMP#1| |dom| |ISTMP#2| |tag| |x| |partial| |patvar|
            |patvars| |mmpat| |patternAlist|)
    (DECLARE (SPECIAL |$PatternVariableList|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |patternAlist| NIL)
             (SPADLET |mmpat| NIL)
             (SPADLET |patvars| |$PatternVariableList|)
             (SPADLET |partial| NIL)
             (DO ((|xTails| |mmPattern| (CDR |xTails|)))
                 ((ATOM |xTails|) NIL)
               (SEQ (EXIT (PROGN
                            (SPADLET |x| (CAR |xTails|))
                            (COND
                              ((AND (PAIRP |x|)
                                    (EQ (QCAR |x|) '|Union|)
                                    (PROGN
                                      (SPADLET |ISTMP#1| (QCDR |x|))
                                      (AND (PAIRP |ISTMP#1|)
                                       (PROGN
                                         (SPADLET |dom|
                                          (QCAR |ISTMP#1|))
                                         (SPADLET |ISTMP#2|
                                          (QCDR |ISTMP#1|))
                                         (AND (PAIRP |ISTMP#2|)
                                          (EQ (QCDR |ISTMP#2|) NIL)
                                          (PROGN
                                            (SPADLET |tag|
                                             (QCAR |ISTMP#2|))
                                            'T)))))
                                    (BOOT-EQUAL |tag|
                                     "failed")
                                    (BOOT-EQUAL |xTails| |sig|))
                               (SPADLET |x| |dom|)
                               (SPADLET |partial| 'T)))
                            (SPADLET |patvar|
                                     (|rassoc| |x| |patternAlist|))
                            (COND
                              ((NULL (NULL |patvar|))
                               (SPADLET |mmpat|
                                        (CONS |patvar| |mmpat|)))
                              ('T (SPADLET |patvar| (CAR |patvars|))
                               (SPADLET |patvars| (CDR |patvars|))
                               (SPADLET |mmpat|
                                        (CONS |patvar| |mmpat|))
                               (SPADLET |patternAlist|
                                        (CONS (CONS |patvar| |x|)
                                         |patternAlist|))))))))
             (CONS (NREVERSE |mmpat|)
                   (CONS |patternAlist|
                         (CONS |partial| (CONS |patvars| NIL)))))))))

;substVars(pred,patternAlist,patternVarList) ==
;  --make pattern variable substitutions
;  domainPredicates := nil
;  for [[patVar,:value],:.] in tails patternAlist repeat
;    pred := substitute(patVar,value,pred)
;    patternAlist := nsubst(patVar,value,patternAlist)
;    domainPredicates := substitute(patVar,value,domainPredicates)
;    if ^MEMQ(value,$FormalMapVariableList) then
;      domainPredicates := [["isDomain",patVar,value],:domainPredicates]
;  everything := [pred,patternAlist,domainPredicates]
;  for var in $FormalMapVariableList repeat
;    CONTAINED(var,everything) =>
;      replacementVar := first patternVarList
;      patternVarList := rest patternVarList
;      pred := substitute(replacementVar,var,pred)
;      domainPredicates := substitute(replacementVar,var,domainPredicates)
;  [pred, domainPredicates]

(DEFUN |substVars| (|pred| |patternAlist| |patternVarList|)
  (PROG (|patVar| |value| |everything| |replacementVar|
            |domainPredicates|)
    (DECLARE (SPECIAL |$FormalMapVariableList|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |domainPredicates| NIL)
             (DO ((G167064 |patternAlist| (CDR G167064)))
                 ((OR (ATOM G167064)
                      (PROGN
                        (PROGN
                          (SPADLET |patVar| (CAAR G167064))
                          (SPADLET |value| (CDAR G167064))
                          G167064)
                        NIL))
                  NIL)
               (SEQ (EXIT (PROGN
                            (SPADLET |pred|
                                     (MSUBST |patVar| |value| |pred|))
                            (SPADLET |patternAlist|
                                     (|nsubst| |patVar| |value|
                                      |patternAlist|))
                            (SPADLET |domainPredicates|
                                     (MSUBST |patVar| |value|
                                      |domainPredicates|))
                            (COND
                              ((NULL (member |value|
                                      |$FormalMapVariableList|))
                               (SPADLET |domainPredicates|
                                        (CONS
                                         (CONS '|isDomain|
                                          (CONS |patVar|
                                           (CONS |value| NIL)))
                                         |domainPredicates|)))
                              ('T NIL))))))
             (SPADLET |everything|
                      (CONS |pred|
                            (CONS |patternAlist|
                                  (CONS |domainPredicates| NIL))))
             (SEQ (DO ((G167089 |$FormalMapVariableList|
                           (CDR G167089))
                       (|var| NIL))
                      ((OR (ATOM G167089)
                           (PROGN (SETQ |var| (CAR G167089)) NIL))
                       NIL)
                    (SEQ (EXIT (COND
                                 ((CONTAINED |var| |everything|)
                                  (EXIT (PROGN
                                          (SPADLET |replacementVar|
                                           (CAR |patternVarList|))
                                          (SPADLET |patternVarList|
                                           (CDR |patternVarList|))
                                          (SPADLET |pred|
                                           (MSUBST |replacementVar|
                                            |var| |pred|))
                                          (SPADLET |domainPredicates|
                                           (MSUBST |replacementVar|
                                            |var| |domainPredicates|)))))))))
                  (CONS |pred| (CONS |domainPredicates| NIL))))))))

;fixUpPredicate(predClause, domainPreds, partial, sig) ==
;  --  merge the predicates in predClause and domainPreds into a
;  --  single predicate
;  [predicate, fn, :skip] := predClause
;  if first predicate = "AND" then
;    predicates := APPEND(domainPreds,rest predicate)
;  else if predicate ^= MKQ "T"
;--was->then predicates:= REVERSE [predicate, :domainPreds]
;       then predicates:= [predicate, :domainPreds]
;       else predicates := domainPreds or [predicate]
;  if #predicates > 1 then
;    pred := ["AND",:predicates]
;    [pred,:dependList]:=orderPredicateItems(pred,sig,skip)
;  else
;    pred := orderPredicateItems(first predicates,sig,skip)
;    dependList:= if pred is ['isDomain,pvar,[.]] then [pvar] else nil
;  pred := moveORsOutside pred
;  if partial then pred := ["partial", :pred]
;  [[pred, fn, :skip],:dependList]

(DEFUN |fixUpPredicate| (|predClause| |domainPreds| |partial| |sig|)
  (PROG (|predicate| |fn| |skip| |predicates| |LETTMP#1| |ISTMP#1|
            |pvar| |ISTMP#2| |ISTMP#3| |dependList| |pred|)
    (RETURN
      (PROGN
        (SPADLET |predicate| (CAR |predClause|))
        (SPADLET |fn| (CADR |predClause|))
        (SPADLET |skip| (CDDR |predClause|))
        (COND
          ((BOOT-EQUAL (CAR |predicate|) 'AND)
           (SPADLET |predicates|
                    (APPEND |domainPreds| (CDR |predicate|))))
          ((NEQUAL |predicate| (MKQ 'T))
           (SPADLET |predicates| (CONS |predicate| |domainPreds|)))
          ('T
           (SPADLET |predicates|
                    (OR |domainPreds| (CONS |predicate| NIL)))))
        (COND
          ((> (|#| |predicates|) 1)
           (SPADLET |pred| (CONS 'AND |predicates|))
           (SPADLET |LETTMP#1|
                    (|orderPredicateItems| |pred| |sig| |skip|))
           (SPADLET |pred| (CAR |LETTMP#1|))
           (SPADLET |dependList| (CDR |LETTMP#1|)) |LETTMP#1|)
          ('T
           (SPADLET |pred|
                    (|orderPredicateItems| (CAR |predicates|) |sig|
                        |skip|))
           (SPADLET |dependList|
                    (COND
                      ((AND (PAIRP |pred|)
                            (EQ (QCAR |pred|) '|isDomain|)
                            (PROGN
                              (SPADLET |ISTMP#1| (QCDR |pred|))
                              (AND (PAIRP |ISTMP#1|)
                                   (PROGN
                                     (SPADLET |pvar| (QCAR |ISTMP#1|))
                                     (SPADLET |ISTMP#2|
                                      (QCDR |ISTMP#1|))
                                     (AND (PAIRP |ISTMP#2|)
                                      (EQ (QCDR |ISTMP#2|) NIL)
                                      (PROGN
                                        (SPADLET |ISTMP#3|
                                         (QCAR |ISTMP#2|))
                                        (AND (PAIRP |ISTMP#3|)
                                         (EQ (QCDR |ISTMP#3|) NIL))))))))
                       (CONS |pvar| NIL))
                      ('T NIL)))))
        (SPADLET |pred| (|moveORsOutside| |pred|))
        (COND (|partial| (SPADLET |pred| (CONS '|partial| |pred|))))
        (CONS (CONS |pred| (CONS |fn| |skip|)) |dependList|)))))

;moveORsOutside p ==
;  p is ['AND,:q] =>
;    q := [moveORsOutside r for r in q]
;    x := or/[r for r in q | r is ['OR,:s]] =>
;      moveORsOutside(['OR,:[['AND,:SUBST(t,x,q)] for t in CDR x]])
;    ['AND,:q]
;  p

(DEFUN |moveORsOutside| (|p|)
  (PROG (|q| |s| |x|)
    (RETURN
      (SEQ (COND
             ((AND (PAIRP |p|) (EQ (QCAR |p|) 'AND)
                   (PROGN (SPADLET |q| (QCDR |p|)) 'T))
              (SPADLET |q|
                       (PROG (G167169)
                         (SPADLET G167169 NIL)
                         (RETURN
                           (DO ((G167174 |q| (CDR G167174))
                                (|r| NIL))
                               ((OR (ATOM G167174)
                                    (PROGN
                                      (SETQ |r| (CAR G167174))
                                      NIL))
                                (NREVERSE0 G167169))
                             (SEQ (EXIT (SETQ G167169
                                         (CONS (|moveORsOutside| |r|)
                                          G167169))))))))
              (COND
                ((SPADLET |x|
                          (PROG (G167180)
                            (SPADLET G167180 NIL)
                            (RETURN
                              (DO ((G167187 NIL G167180)
                                   (G167188 |q| (CDR G167188))
                                   (|r| NIL))
                                  ((OR G167187 (ATOM G167188)
                                    (PROGN
                                      (SETQ |r| (CAR G167188))
                                      NIL))
                                   G167180)
                                (SEQ (EXIT
                                      (COND
                                        ((AND (PAIRP |r|)
                                          (EQ (QCAR |r|) 'OR)
                                          (PROGN
                                            (SPADLET |s| (QCDR |r|))
                                            'T))
                                         (SETQ G167180
                                          (OR G167180 |r|))))))))))
                 (|moveORsOutside|
                     (CONS 'OR
                           (PROG (G167199)
                             (SPADLET G167199 NIL)
                             (RETURN
                               (DO ((G167204 (CDR |x|)
                                     (CDR G167204))
                                    (|t| NIL))
                                   ((OR (ATOM G167204)
                                     (PROGN
                                       (SETQ |t| (CAR G167204))
                                       NIL))
                                    (NREVERSE0 G167199))
                                 (SEQ (EXIT
                                       (SETQ G167199
                                        (CONS
                                         (CONS 'AND
                                          (MSUBST |t| |x| |q|))
                                         G167199))))))))))
                ('T (CONS 'AND |q|))))
             ('T |p|))))))

;replaceVars(x,oldvars,newvars) ==
;  --  replace every identifier in oldvars with the corresponding
;  --  identifier in newvars in the expression x
;  for old in oldvars for new in newvars repeat
;    x := substitute(new,old,x)
;  x

(DEFUN |replaceVars| (|x| |oldvars| |newvars|)
  (SEQ (PROGN
         (DO ((G167225 |oldvars| (CDR G167225)) (|old| NIL)
              (G167226 |newvars| (CDR G167226)) (|new| NIL))
             ((OR (ATOM G167225)
                  (PROGN (SETQ |old| (CAR G167225)) NIL)
                  (ATOM G167226)
                  (PROGN (SETQ |new| (CAR G167226)) NIL))
              NIL)
           (SEQ (EXIT (SPADLET |x| (MSUBST |new| |old| |x|)))))
         |x|)))

;getDomainFromMm mm ==
;  -- Returns the Domain (or package or category) of origin from a pattern
;  -- modemap
;  [., cond] := mm
;  if cond is ['partial, :c] then cond := c
;  condList :=
;    cond is ['AND, :cl] => cl
;    cond is ['OR, ['AND, :cl],:.] => cl  --all cl's should give same info
;    [cond]
;  val :=
;    for condition in condList repeat
;      condition is ['isDomain, "*1", dom] => return opOf dom
;      condition is ['ofCategory, "*1", cat] => return opOf cat
;  null val =>
;    keyedSystemError("S2GE0016",
;      ['"getDomainFromMm",'"Can't find domain in modemap condition"])
;  val

(DEFUN |getDomainFromMm| (|mm|)
  (PROG (|c| |cond| |cl| |condList| |dom| |ISTMP#1| |ISTMP#2| |cat|
             |val|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |cond| (CADR |mm|))
             (COND
               ((AND (PAIRP |cond|) (EQ (QCAR |cond|) '|partial|)
                     (PROGN (SPADLET |c| (QCDR |cond|)) 'T))
                (SPADLET |cond| |c|)))
             (SPADLET |condList|
                      (COND
                        ((AND (PAIRP |cond|) (EQ (QCAR |cond|) 'AND)
                              (PROGN (SPADLET |cl| (QCDR |cond|)) 'T))
                         |cl|)
                        ((AND (PAIRP |cond|) (EQ (QCAR |cond|) 'OR)
                              (PROGN
                                (SPADLET |ISTMP#1| (QCDR |cond|))
                                (AND (PAIRP |ISTMP#1|)
                                     (PROGN
                                       (SPADLET |ISTMP#2|
                                        (QCAR |ISTMP#1|))
                                       (AND (PAIRP |ISTMP#2|)
                                        (EQ (QCAR |ISTMP#2|) 'AND)
                                        (PROGN
                                          (SPADLET |cl|
                                           (QCDR |ISTMP#2|))
                                          'T))))))
                         |cl|)
                        ('T (CONS |cond| NIL))))
             (SPADLET |val|
                      (DO ((G167289 |condList| (CDR G167289))
                           (|condition| NIL))
                          ((OR (ATOM G167289)
                               (PROGN
                                 (SETQ |condition| (CAR G167289))
                                 NIL))
                           NIL)
                        (SEQ (EXIT (COND
                                     ((AND (PAIRP |condition|)
                                       (EQ (QCAR |condition|)
                                        '|isDomain|)
                                       (PROGN
                                         (SPADLET |ISTMP#1|
                                          (QCDR |condition|))
                                         (AND (PAIRP |ISTMP#1|)
                                          (EQ (QCAR |ISTMP#1|) '*1)
                                          (PROGN
                                            (SPADLET |ISTMP#2|
                                             (QCDR |ISTMP#1|))
                                            (AND (PAIRP |ISTMP#2|)
                                             (EQ (QCDR |ISTMP#2|) NIL)
                                             (PROGN
                                               (SPADLET |dom|
                                                (QCAR |ISTMP#2|))
                                               'T))))))
                                      (RETURN (|opOf| |dom|)))
                                     ((AND (PAIRP |condition|)
                                       (EQ (QCAR |condition|)
                                        '|ofCategory|)
                                       (PROGN
                                         (SPADLET |ISTMP#1|
                                          (QCDR |condition|))
                                         (AND (PAIRP |ISTMP#1|)
                                          (EQ (QCAR |ISTMP#1|) '*1)
                                          (PROGN
                                            (SPADLET |ISTMP#2|
                                             (QCDR |ISTMP#1|))
                                            (AND (PAIRP |ISTMP#2|)
                                             (EQ (QCDR |ISTMP#2|) NIL)
                                             (PROGN
                                               (SPADLET |cat|
                                                (QCAR |ISTMP#2|))
                                               'T))))))
                                      (RETURN (|opOf| |cat|))))))))
             (COND
               ((NULL |val|)
                (|keyedSystemError| 'S2GE0016
                    (CONS "getDomainFromMm"
                          (CONS "Can't find domain in modemap condition"
                                NIL))))
               ('T |val|)))))))

;getFirstArgTypeFromMm mm ==
;  -- Returns the type of the first argument or nil
;  [pats, cond] := mm
;  [.,.,:args] := pats
;  null args => nil
;  arg1 := first args
;  if cond is ['partial, :c] then cond := c
;  condList :=
;    cond is ['AND, :cl] => cl
;    cond is ['OR, ['AND, :cl],:.] => cl  --all cl's should give same info
;    [cond]
;  type := nil
;  for condition in condList while not type repeat
;      if condition is ['isDomain, a1, dom] and a1=arg1 then type := dom
;  type

(DEFUN |getFirstArgTypeFromMm| (|mm|)
  (PROG (|pats| |args| |arg1| |c| |cond| |cl| |condList| |ISTMP#1| |a1|
                |ISTMP#2| |dom| |type|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |pats| (CAR |mm|))
             (SPADLET |cond| (CADR |mm|))
             (SPADLET |args| (CDDR |pats|))
             (COND
               ((NULL |args|) NIL)
               ('T (SPADLET |arg1| (CAR |args|))
                (COND
                  ((AND (PAIRP |cond|) (EQ (QCAR |cond|) '|partial|)
                        (PROGN (SPADLET |c| (QCDR |cond|)) 'T))
                   (SPADLET |cond| |c|)))
                (SPADLET |condList|
                         (COND
                           ((AND (PAIRP |cond|) (EQ (QCAR |cond|) 'AND)
                                 (PROGN
                                   (SPADLET |cl| (QCDR |cond|))
                                   'T))
                            |cl|)
                           ((AND (PAIRP |cond|) (EQ (QCAR |cond|) 'OR)
                                 (PROGN
                                   (SPADLET |ISTMP#1| (QCDR |cond|))
                                   (AND (PAIRP |ISTMP#1|)
                                    (PROGN
                                      (SPADLET |ISTMP#2|
                                       (QCAR |ISTMP#1|))
                                      (AND (PAIRP |ISTMP#2|)
                                       (EQ (QCAR |ISTMP#2|) 'AND)
                                       (PROGN
                                         (SPADLET |cl|
                                          (QCDR |ISTMP#2|))
                                         'T))))))
                            |cl|)
                           ('T (CONS |cond| NIL))))
                (SPADLET |type| NIL)
                (DO ((G167357 |condList| (CDR G167357))
                     (|condition| NIL))
                    ((OR (ATOM G167357)
                         (PROGN
                           (SETQ |condition| (CAR G167357))
                           NIL)
                         (NULL (NULL |type|)))
                     NIL)
                  (SEQ (EXIT (COND
                               ((AND (PAIRP |condition|)
                                     (EQ (QCAR |condition|)
                                      '|isDomain|)
                                     (PROGN
                                       (SPADLET |ISTMP#1|
                                        (QCDR |condition|))
                                       (AND (PAIRP |ISTMP#1|)
                                        (PROGN
                                          (SPADLET |a1|
                                           (QCAR |ISTMP#1|))
                                          (SPADLET |ISTMP#2|
                                           (QCDR |ISTMP#1|))
                                          (AND (PAIRP |ISTMP#2|)
                                           (EQ (QCDR |ISTMP#2|) NIL)
                                           (PROGN
                                             (SPADLET |dom|
                                              (QCAR |ISTMP#2|))
                                             'T)))))
                                     (BOOT-EQUAL |a1| |arg1|))
                                (SPADLET |type| |dom|))
                               ('T NIL)))))
                |type|)))))))

;isFreeFunctionFromMm mm ==
;  -- This returns true is the modemap represents a free function, ie,
;  -- one not coming from a domain or category.
;  [., cond] := mm
;  isFreeFunctionFromMmCond cond

(DEFUN |isFreeFunctionFromMm| (|mm|)
  (PROG (|cond|)
    (RETURN
      (PROGN
        (SPADLET |cond| (CADR |mm|))
        (|isFreeFunctionFromMmCond| |cond|)))))

;isFreeFunctionFromMmCond cond ==
;  -- This returns true is the modemap represents a free function, ie,
;  -- one not coming from a domain or category.
;  if cond is ['partial, :c] then cond := c
;  condList :=
;    cond is ['AND, :cl] => cl
;    cond is ['OR, ['AND, :cl],:.] => cl  --all cl's should give same info
;    [cond]
;  iff := false
;  for condition in condList while not iff repeat
;      if condition is ['isFreeFunction, :.] then iff := true
;  iff

(DEFUN |isFreeFunctionFromMmCond| (|cond|)
  (PROG (|c| |ISTMP#1| |ISTMP#2| |cl| |condList| |iff|)
    (RETURN
      (SEQ (PROGN
             (COND
               ((AND (PAIRP |cond|) (EQ (QCAR |cond|) '|partial|)
                     (PROGN (SPADLET |c| (QCDR |cond|)) 'T))
                (SPADLET |cond| |c|)))
             (SPADLET |condList|
                      (COND
                        ((AND (PAIRP |cond|) (EQ (QCAR |cond|) 'AND)
                              (PROGN (SPADLET |cl| (QCDR |cond|)) 'T))
                         |cl|)
                        ((AND (PAIRP |cond|) (EQ (QCAR |cond|) 'OR)
                              (PROGN
                                (SPADLET |ISTMP#1| (QCDR |cond|))
                                (AND (PAIRP |ISTMP#1|)
                                     (PROGN
                                       (SPADLET |ISTMP#2|
                                        (QCAR |ISTMP#1|))
                                       (AND (PAIRP |ISTMP#2|)
                                        (EQ (QCAR |ISTMP#2|) 'AND)
                                        (PROGN
                                          (SPADLET |cl|
                                           (QCDR |ISTMP#2|))
                                          'T))))))
                         |cl|)
                        ('T (CONS |cond| NIL))))
             (SPADLET |iff| NIL)
             (DO ((G167407 |condList| (CDR G167407))
                  (|condition| NIL))
                 ((OR (ATOM G167407)
                      (PROGN (SETQ |condition| (CAR G167407)) NIL)
                      (NULL (NULL |iff|)))
                  NIL)
               (SEQ (EXIT (COND
                            ((AND (PAIRP |condition|)
                                  (EQ (QCAR |condition|)
                                      '|isFreeFunction|))
                             (SPADLET |iff| 'T))
                            ('T NIL)))))
             |iff|)))))

;getAllModemapsFromDatabase(op,nargs) ==
;  $getUnexposedOperations: local := true
;  startTimingProcess 'diskread
;  ans := getSystemModemaps(op,nargs)
;  stopTimingProcess 'diskread
;  ans

(DEFUN |getAllModemapsFromDatabase| (|op| |nargs|)
  (PROG (|$getUnexposedOperations| |ans|)
    (DECLARE (SPECIAL |$getUnexposedOperations|))
    (RETURN
      (PROGN
        (SPADLET |$getUnexposedOperations| 'T)
        (|startTimingProcess| '|diskread|)
        (SPADLET |ans| (|getSystemModemaps| |op| |nargs|))
        (|stopTimingProcess| '|diskread|)
        |ans|))))

;getModemapsFromDatabase(op,nargs) ==
;  $getUnexposedOperations: local := false
;  startTimingProcess 'diskread
;  ans := getSystemModemaps(op,nargs)
;  stopTimingProcess 'diskread
;  ans

(DEFUN |getModemapsFromDatabase| (|op| |nargs|)
  (PROG (|$getUnexposedOperations| |ans|)
    (DECLARE (SPECIAL |$getUnexposedOperations|))
    (RETURN
      (PROGN
        (SPADLET |$getUnexposedOperations| NIL)
        (|startTimingProcess| '|diskread|)
        (SPADLET |ans| (|getSystemModemaps| |op| |nargs|))
        (|stopTimingProcess| '|diskread|)
        |ans|))))

;getSystemModemaps(op,nargs) ==
;  mml:= GETDATABASE(op,'OPERATION) =>
;    mms := NIL
;    for (x := [[.,:sig],.]) in mml repeat
;      (NUMBERP nargs) and (nargs ^= #QCDR sig) => 'iterate
;      $getUnexposedOperations or isFreeFunctionFromMm(x) or
;        isExposedConstructor(getDomainFromMm(x)) => mms := [x,:mms]
;      'iterate
;    mms
;  nil

(DEFUN |getSystemModemaps| (|op| |nargs|)
  (PROG (|mml| |sig| |mms|)
    (DECLARE (SPECIAL |$getUnexposedOperations|))
    (RETURN
      (SEQ (COND
             ((SPADLET |mml| (GETDATABASE |op| 'OPERATION))
              (SPADLET |mms| NIL)
              (DO ((G167451 |mml| (CDR G167451)) (|x| NIL))
                  ((OR (ATOM G167451)
                       (PROGN (SETQ |x| (CAR G167451)) NIL)
                       (PROGN
                         (PROGN (SPADLET |sig| (CDAR |x|)) |x|)
                         NIL))
                   NIL)
                (SEQ (EXIT (COND
                             ((AND (NUMBERP |nargs|)
                                   (NEQUAL |nargs| (|#| (QCDR |sig|))))
                              '|iterate|)
                             ((OR |$getUnexposedOperations|
                                  (|isFreeFunctionFromMm| |x|)
                                  (|isExposedConstructor|
                                      (|getDomainFromMm| |x|)))
                              (SPADLET |mms| (CONS |x| |mms|)))
                             ('T '|iterate|)))))
              |mms|)
             ('T NIL))))))

;getInCoreModemaps(modemapList,op,nargs) ==
;  mml:= LASSOC (op,modemapList) =>
;    mml:= CAR mml
;    [x for (x:= [[dc,:sig],.]) in mml |
;      (NUMBERP nargs => nargs=#rest sig; true) and
;        (cfn := abbreviate (domName := getDomainFromMm x)) and
;          ($getUnexposedOperations or isExposedConstructor(domName))]
;  nil

(DEFUN |getInCoreModemaps| (|modemapList| |op| |nargs|)
  (PROG (|mml| |dc| |sig| |domName| |cfn|)
    (DECLARE (SPECIAL |$getUnexposedOperations|))
    (RETURN
      (SEQ (COND
             ((SPADLET |mml| (LASSOC |op| |modemapList|))
              (SPADLET |mml| (CAR |mml|))
              (PROG (G167477)
                (SPADLET G167477 NIL)
                (RETURN
                  (DO ((G167484 |mml| (CDR G167484)) (|x| NIL))
                      ((OR (ATOM G167484)
                           (PROGN (SETQ |x| (CAR G167484)) NIL)
                           (PROGN
                             (PROGN
                               (SPADLET |dc| (CAAR |x|))
                               (SPADLET |sig| (CDAR |x|))
                               |x|)
                             NIL))
                       (NREVERSE0 G167477))
                    (SEQ (EXIT (COND
                                 ((AND (COND
                                         ((NUMBERP |nargs|)
                                          (BOOT-EQUAL |nargs|
                                           (|#| (CDR |sig|))))
                                         ('T 'T))
                                       (SPADLET |cfn|
                                        (|abbreviate|
                                         (SPADLET |domName|
                                          (|getDomainFromMm| |x|))))
                                       (OR |$getUnexposedOperations|
                                        (|isExposedConstructor|
                                         |domName|)))
                                  (SETQ G167477 (CONS |x| G167477))))))))))
             ('T NIL))))))

;mkAlistOfExplicitCategoryOps target ==
;  if target is ['add,a,:l] then
;    target:=a
;  target is ['Join,:l] =>
;    "UNION"/[mkAlistOfExplicitCategoryOps cat for cat in l]
;  target is ['CATEGORY,.,:l] =>
;    l:= flattenSignatureList ['PROGN,:l]
;    u:=
;      [[atomizeOp op,:sig] for x in l | x is ['SIGNATURE,op,sig,:.]]
;            where
;              atomizeOp op ==
;                atom op => op
;                op is [a] => a
;                keyedSystemError("S2GE0016",
;                  ['"mkAlistOfExplicitCategoryOps",'"bad signature"])
;    opList:= REMDUP ASSOCLEFT u
;    [[x,:fn(x,u)] for x in opList] where
;      fn(op,u) ==
;        u is [[a,:b],:c] => (a=op => [b,:fn(op,c)]; fn(op,c))
;  isCategoryForm(target,$e) => nil
;  keyedSystemError("S2GE0016",
;    ['"mkAlistOfExplicitCategoryOps",'"bad signature"])

(DEFUN |mkAlistOfExplicitCategoryOps,atomizeOp| (|op|)
  (PROG (|a|)
    (RETURN
      (SEQ (IF (ATOM |op|) (EXIT |op|))
           (IF (AND (PAIRP |op|) (EQ (QCDR |op|) NIL)
                    (PROGN (SPADLET |a| (QCAR |op|)) 'T))
               (EXIT |a|))
           (EXIT (|keyedSystemError| 'S2GE0016
                     (CONS "mkAlistOfExplicitCategoryOps"
                           (CONS "bad signature" NIL))))))))

(DEFUN |mkAlistOfExplicitCategoryOps,fn| (|op| |u|)
  (PROG (|ISTMP#1| |a| |b| |c|)
    (RETURN
      (SEQ (IF (AND (PAIRP |u|)
                    (PROGN
                      (SPADLET |ISTMP#1| (QCAR |u|))
                      (AND (PAIRP |ISTMP#1|)
                           (PROGN
                             (SPADLET |a| (QCAR |ISTMP#1|))
                             (SPADLET |b| (QCDR |ISTMP#1|))
                             'T)))
                    (PROGN (SPADLET |c| (QCDR |u|)) 'T))
               (EXIT (SEQ (IF (BOOT-EQUAL |a| |op|)
                              (EXIT (CONS |b|
                                     (|mkAlistOfExplicitCategoryOps,fn|
                                      |op| |c|))))
                          (EXIT (|mkAlistOfExplicitCategoryOps,fn| |op|
                                    |c|)))))))))

(DEFUN |mkAlistOfExplicitCategoryOps| (|target|)
  (PROG (|a| |l| |ISTMP#1| |op| |ISTMP#2| |sig| |u| |opList|)
    (DECLARE (SPECIAL |$e|))
    (RETURN
      (SEQ (PROGN
             (COND
               ((AND (PAIRP |target|) (EQ (QCAR |target|) '|add|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |target|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |a| (QCAR |ISTMP#1|))
                              (SPADLET |l| (QCDR |ISTMP#1|))
                              'T))))
                (SPADLET |target| |a|)))
             (COND
               ((AND (PAIRP |target|) (EQ (QCAR |target|) '|Join|)
                     (PROGN (SPADLET |l| (QCDR |target|)) 'T))
                (PROG (G167561)
                  (SPADLET G167561 NIL)
                  (RETURN
                    (DO ((G167566 |l| (CDR G167566)) (|cat| NIL))
                        ((OR (ATOM G167566)
                             (PROGN (SETQ |cat| (CAR G167566)) NIL))
                         G167561)
                      (SEQ (EXIT (SETQ G167561
                                       (|union| G167561
                                        (|mkAlistOfExplicitCategoryOps|
                                         |cat|)))))))))
               ((AND (PAIRP |target|) (EQ (QCAR |target|) 'CATEGORY)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |target|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN (SPADLET |l| (QCDR |ISTMP#1|)) 'T))))
                (SPADLET |l|
                         (|flattenSignatureList| (CONS 'PROGN |l|)))
                (SPADLET |u|
                         (PROG (G167577)
                           (SPADLET G167577 NIL)
                           (RETURN
                             (DO ((G167583 |l| (CDR G167583))
                                  (|x| NIL))
                                 ((OR (ATOM G167583)
                                      (PROGN
                                        (SETQ |x| (CAR G167583))
                                        NIL))
                                  (NREVERSE0 G167577))
                               (SEQ (EXIT
                                     (COND
                                       ((AND (PAIRP |x|)
                                         (EQ (QCAR |x|) 'SIGNATURE)
                                         (PROGN
                                           (SPADLET |ISTMP#1|
                                            (QCDR |x|))
                                           (AND (PAIRP |ISTMP#1|)
                                            (PROGN
                                              (SPADLET |op|
                                               (QCAR |ISTMP#1|))
                                              (SPADLET |ISTMP#2|
                                               (QCDR |ISTMP#1|))
                                              (AND (PAIRP |ISTMP#2|)
                                               (PROGN
                                                 (SPADLET |sig|
                                                  (QCAR |ISTMP#2|))
                                                 'T))))))
                                        (SETQ G167577
                                         (CONS
                                          (CONS
                                      (|mkAlistOfExplicitCategoryOps,atomizeOp|
                                            |op|)
                                           |sig|)
                                          G167577))))))))))
                (SPADLET |opList| (REMDUP (ASSOCLEFT |u|)))
                (PROG (G167593)
                  (SPADLET G167593 NIL)
                  (RETURN
                    (DO ((G167598 |opList| (CDR G167598))
                         (|x| NIL))
                        ((OR (ATOM G167598)
                             (PROGN (SETQ |x| (CAR G167598)) NIL))
                         (NREVERSE0 G167593))
                      (SEQ (EXIT (SETQ G167593
                                       (CONS
                                        (CONS |x|
                                         (|mkAlistOfExplicitCategoryOps,fn|
                                          |x| |u|))
                                        G167593))))))))
               ((|isCategoryForm| |target| |$e|) NIL)
               ('T
                (|keyedSystemError| 'S2GE0016
                    (CONS "mkAlistOfExplicitCategoryOps"
                          (CONS "bad signature" NIL))))))))))

;flattenSignatureList(x) ==
;  atom x => nil
;  x is ['SIGNATURE,:.] => [x]
;  x is ['IF,cond,b1,b2] =>
;     append(flattenSignatureList b1, flattenSignatureList b2)
;  x is ['PROGN,:l] =>
;     ll:= []
;     for x in l repeat
;        x is ['SIGNATURE,:.] => ll:=cons(x,ll)
;        ll:= append(flattenSignatureList x,ll)
;     ll
;  nil

(DEFUN |flattenSignatureList| (|x|)
  (PROG (|ISTMP#1| |cond| |ISTMP#2| |b1| |ISTMP#3| |b2| |l| |ll|)
    (RETURN
      (SEQ (COND
             ((ATOM |x|) NIL)
             ((AND (PAIRP |x|) (EQ (QCAR |x|) 'SIGNATURE))
              (CONS |x| NIL))
             ((AND (PAIRP |x|) (EQ (QCAR |x|) 'IF)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |x|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |cond| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (PAIRP |ISTMP#2|)
                                 (PROGN
                                   (SPADLET |b1| (QCAR |ISTMP#2|))
                                   (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                                   (AND (PAIRP |ISTMP#3|)
                                    (EQ (QCDR |ISTMP#3|) NIL)
                                    (PROGN
                                      (SPADLET |b2| (QCAR |ISTMP#3|))
                                      'T))))))))
              (APPEND (|flattenSignatureList| |b1|)
                      (|flattenSignatureList| |b2|)))
             ((AND (PAIRP |x|) (EQ (QCAR |x|) 'PROGN)
                   (PROGN (SPADLET |l| (QCDR |x|)) 'T))
              (SPADLET |ll| NIL)
              (DO ((G167664 |l| (CDR G167664)) (|x| NIL))
                  ((OR (ATOM G167664)
                       (PROGN (SETQ |x| (CAR G167664)) NIL))
                   NIL)
                (SEQ (EXIT (COND
                             ((AND (PAIRP |x|)
                                   (EQ (QCAR |x|) 'SIGNATURE))
                              (SPADLET |ll| (CONS |x| |ll|)))
                             ('T
                              (SPADLET |ll|
                                       (APPEND
                                        (|flattenSignatureList| |x|)
                                        |ll|)))))))
              |ll|)
             ('T NIL))))))

;mkDatabasePred [a,t] ==
;  isCategoryForm(t,$e) => ['ofCategory,a,t]
;  ['ofType,a,t]

(DEFUN |mkDatabasePred| (G167684)
  (PROG (|a| |t|)
    (DECLARE (SPECIAL |$e|))
    (RETURN
      (PROGN
        (SPADLET |a| (CAR G167684))
        (SPADLET |t| (CADR G167684))
        (COND
          ((|isCategoryForm| |t| |$e|)
           (CONS '|ofCategory| (CONS |a| (CONS |t| NIL))))
          ('T (CONS '|ofType| (CONS |a| (CONS |t| NIL)))))))))

;formal2Pattern x ==
;  SUBLIS(pairList($FormalMapVariableList,rest $PatternVariableList),x)

(DEFUN |formal2Pattern| (|x|)
  (DECLARE (SPECIAL |$PatternVariableList|))
  (SUBLIS (|pairList| |$FormalMapVariableList|
              (CDR |$PatternVariableList|))
          |x|))

;updateDatabase(fname,cname,systemdir?) ==
; -- for now in NRUNTIME do database update only if forced
;  not $forceDatabaseUpdate => nil
;  -- these modemaps are never needed in the old scheme
;  if oldFname := constructor? cname then
;    clearClams()
;    clearAllSlams []
;    if GET(cname, 'LOADED) then
;      clearConstructorCaches()
;  if $forceDatabaseUpdate or not systemdir? then
;    clearClams()
;    clearAllSlams []

(DEFUN |updateDatabase| (|fname| |cname| |systemdir?|)
  (declare (ignore |fname|))
  (PROG (|oldFname|)
    (DECLARE (SPECIAL |$forceDatabaseUpdate|))
    (RETURN
      (COND
        ((NULL |$forceDatabaseUpdate|) NIL)
        ('T
         (COND
           ((SPADLET |oldFname| (|constructor?| |cname|))
            (|clearClams|) (|clearAllSlams| NIL)
            (COND
              ((GETL |cname| 'LOADED) (|clearConstructorCaches|))
              ('T NIL))))
         (COND
           ((OR |$forceDatabaseUpdate| (NULL |systemdir?|))
            (|clearClams|) (|clearAllSlams| NIL))
           ('T NIL)))))))

;removeCoreModemaps(modemapList,c) ==
;  newUserModemaps:= nil
;  c := opOf unabbrev c
;  for [op,mmList] in modemapList repeat
;    temp:= nil
;    for mm in mmList repeat
;      cname := getDomainFromMm mm
;      if cname ^= c then temp:= [:temp,mm]
;    if temp then newUserModemaps:= [:newUserModemaps,[op,temp]]
;  newUserModemaps

(DEFUN |removeCoreModemaps| (|modemapList| |c|)
  (PROG (|op| |mmList| |cname| |temp| |newUserModemaps|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |newUserModemaps| NIL)
             (SPADLET |c| (|opOf| (|unabbrev| |c|)))
             (DO ((G167724 |modemapList| (CDR G167724))
                  (G167710 NIL))
                 ((OR (ATOM G167724)
                      (PROGN (SETQ G167710 (CAR G167724)) NIL)
                      (PROGN
                        (PROGN
                          (SPADLET |op| (CAR G167710))
                          (SPADLET |mmList| (CADR G167710))
                          G167710)
                        NIL))
                  NIL)
               (SEQ (EXIT (PROGN
                            (SPADLET |temp| NIL)
                            (DO ((G167736 |mmList| (CDR G167736))
                                 (|mm| NIL))
                                ((OR (ATOM G167736)
                                     (PROGN
                                       (SETQ |mm| (CAR G167736))
                                       NIL))
                                 NIL)
                              (SEQ (EXIT
                                    (PROGN
                                      (SPADLET |cname|
                                       (|getDomainFromMm| |mm|))
                                      (COND
                                        ((NEQUAL |cname| |c|)
                                         (SPADLET |temp|
                                          (APPEND |temp|
                                           (CONS |mm| NIL))))
                                        ('T NIL))))))
                            (COND
                              (|temp| (SPADLET |newUserModemaps|
                                       (APPEND |newUserModemaps|
                                        (CONS
                                         (CONS |op| (CONS |temp| NIL))
                                         NIL))))
                              ('T NIL))))))
             |newUserModemaps|)))))

;addCoreModemap(modemapList,op,modemap,cname) ==
;  entry:= ASSQ(op,modemapList) =>
;    RPLAC(CADR entry,[modemap,:CADR entry])
;    modemapList
;  modeMapList:= [:modemapList,[op,[ modemap]]]

(DEFUN |addCoreModemap| (|modemapList| |op| |modemap| |cname|)
  (declare (ignore |cname|))
  (PROG (|entry| |modeMapList|)
    (RETURN
      (COND
        ((SPADLET |entry| (ASSQ |op| |modemapList|))
         (RPLAC (CADR |entry|) (CONS |modemap| (CADR |entry|)))
         |modemapList|)
        ('T
         (SPADLET |modeMapList|
                  (APPEND |modemapList|
                          (CONS (CONS |op|
                                      (CONS (CONS |modemap| NIL) NIL))
                                NIL))))))))

;REMOVER(lst,item) ==
;  --destructively removes item from lst
;  not PAIRP lst =>
;    lst=item => nil
;    lst
;  first lst=item => rest lst
;  RPLNODE(lst,REMOVER(first lst,item),REMOVER(rest lst,item))

(DEFUN REMOVER (|lst| |item|)
  (COND
    ((NULL (PAIRP |lst|))
     (COND ((BOOT-EQUAL |lst| |item|) NIL) ('T |lst|)))
    ((BOOT-EQUAL (CAR |lst|) |item|) (CDR |lst|))
    ('T
     (RPLNODE |lst| (REMOVER (CAR |lst|) |item|)
              (REMOVER (CDR |lst|) |item|)))))

;allLASSOCs(op,alist) ==
;  [value for [key,:value] in alist | key = op]

(DEFUN |allLASSOCs| (|op| |alist|)
  (PROG (|key| |value|)
    (RETURN
      (SEQ (PROG (G167775)
             (SPADLET G167775 NIL)
             (RETURN
               (DO ((G167782 |alist| (CDR G167782))
                    (G167765 NIL))
                   ((OR (ATOM G167782)
                        (PROGN (SETQ G167765 (CAR G167782)) NIL)
                        (PROGN
                          (PROGN
                            (SPADLET |key| (CAR G167765))
                            (SPADLET |value| (CDR G167765))
                            G167765)
                          NIL))
                    (NREVERSE0 G167775))
                 (SEQ (EXIT (COND
                              ((BOOT-EQUAL |key| |op|)
                               (SETQ G167775
                                     (CONS |value| G167775)))))))))))))

;loadDependents fn ==
;  isExistingFile [fn,$spadLibFT,"*"] =>
;    MEMQ("dependents",RKEYIDS(fn,$spadLibFT)) =>
;      stream:= readLib1(fn,$spadLibFT,"*")
;      l:= rread('dependents,stream,nil)
;      RSHUT stream
;      for x in l repeat
;        x='SubDomain => nil
;        loadIfNecessary x

(DEFUN |loadDependents| (|fn|)
  (PROG (|stream| |l|)
    (DECLARE (SPECIAL |$spadLibFT|))
    (RETURN
      (SEQ (COND
             ((|isExistingFile|
                  (CONS |fn| (CONS |$spadLibFT| (CONS '* NIL))))
              (EXIT (COND
                      ((member '|dependents| (RKEYIDS |fn| |$spadLibFT|))
                       (EXIT (PROGN
                               (SPADLET |stream|
                                        (|readLib1| |fn| |$spadLibFT|
                                         '*))
                               (SPADLET |l|
                                        (|rread| '|dependents| |stream|
                                         NIL))
                               (RSHUT |stream|)
                               (DO ((G167800 |l| (CDR G167800))
                                    (|x| NIL))
                                   ((OR (ATOM G167800)
                                     (PROGN
                                       (SETQ |x| (CAR G167800))
                                       NIL))
                                    NIL)
                                 (SEQ (EXIT
                                       (COND
                                         ((BOOT-EQUAL |x| '|SubDomain|)
                                          NIL)
                                    ('T (|loadIfNecessary| |x|)))))))))))))))))

;--% Miscellaneous Stuff
;getOplistForConstructorForm (form := [op,:argl]) ==
;  --  The new form is an op-Alist which has entries (<op> . signature-Alist)
;  --    where signature-Alist has entries (<signature> . item)
;  --      where item has form (<slotNumber> <condition> <kind>)
;  --        where <kind> =  ELT | CONST | Subsumed | (XLAM..) ..
;  pairlis:= [[fv,:arg] for fv in $FormalMapVariableList for arg in argl]
;  opAlist := getOperationAlistFromLisplib op
;  [:getOplistWithUniqueSignatures(op,pairlis,signatureAlist)
;      for [op,:signatureAlist] in opAlist]

(DEFUN |getOplistForConstructorForm| (|form|)
  (PROG (|argl| |pairlis| |opAlist| |op| |signatureAlist|)
    (DECLARE (SPECIAL |$FormalMapVariableList|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |op| (CAR |form|))
             (SPADLET |argl| (CDR |form|))
             (SPADLET |pairlis|
                      (PROG (G167832)
                        (SPADLET G167832 NIL)
                        (RETURN
                          (DO ((G167838 |$FormalMapVariableList|
                                   (CDR G167838))
                               (|fv| NIL)
                               (G167839 |argl| (CDR G167839))
                               (|arg| NIL))
                              ((OR (ATOM G167838)
                                   (PROGN
                                     (SETQ |fv| (CAR G167838))
                                     NIL)
                                   (ATOM G167839)
                                   (PROGN
                                     (SETQ |arg| (CAR G167839))
                                     NIL))
                               (NREVERSE0 G167832))
                            (SEQ (EXIT (SETQ G167832
                                        (CONS (CONS |fv| |arg|)
                                         G167832))))))))
             (SPADLET |opAlist| (|getOperationAlistFromLisplib| |op|))
             (PROG (G167848)
               (SPADLET G167848 NIL)
               (RETURN
                 (DO ((G167854 |opAlist| (CDR G167854))
                      (G167811 NIL))
                     ((OR (ATOM G167854)
                          (PROGN (SETQ G167811 (CAR G167854)) NIL)
                          (PROGN
                            (PROGN
                              (SPADLET |op| (CAR G167811))
                              (SPADLET |signatureAlist|
                                       (CDR G167811))
                              G167811)
                            NIL))
                      G167848)
                   (SEQ (EXIT (SETQ G167848
                                    (APPEND G167848
                                     (|getOplistWithUniqueSignatures|
                                   |op| |pairlis| |signatureAlist|)))))))))))))

;getOplistWithUniqueSignatures(op,pairlis,signatureAlist) ==
;  alist:= nil
;  for [sig,:[slotNumber,pred,kind]] in signatureAlist | kind ^= 'Subsumed repeat
;    alist:= insertAlist(SUBLIS(pairlis,[op,sig]),
;                SUBLIS(pairlis,[pred,[kind,nil,slotNumber]]),
;                alist)
;  alist

(DEFUN |getOplistWithUniqueSignatures|
       (|op| |pairlis| |signatureAlist|)
  (PROG (|sig| |slotNumber| |pred| |kind| |alist|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |alist| NIL)
             (DO ((G167884 |signatureAlist| (CDR G167884))
                  (G167872 NIL))
                 ((OR (ATOM G167884)
                      (PROGN (SETQ G167872 (CAR G167884)) NIL)
                      (PROGN
                        (PROGN
                          (SPADLET |sig| (CAR G167872))
                          (SPADLET |slotNumber| (CADR G167872))
                          (SPADLET |pred| (CADDR G167872))
                          (SPADLET |kind| (CADDDR G167872))
                          G167872)
                        NIL))
                  NIL)
               (SEQ (EXIT (COND
                            ((NEQUAL |kind| '|Subsumed|)
                             (SPADLET |alist|
                                      (|insertAlist|
                                       (SUBLIS |pairlis|
                                        (CONS |op| (CONS |sig| NIL)))
                                       (SUBLIS |pairlis|
                                        (CONS |pred|
                                         (CONS
                                          (CONS |kind|
                                           (CONS NIL
                                            (CONS |slotNumber| NIL)))
                                          NIL)))
                                       |alist|)))))))
             |alist|)))))

;--% Code For Modemap Insertion
;insertModemap(new,mmList) ==
;  null mmList => [new]
;--isMoreSpecific(new,old:= first mmList) => [new,:mmList]
;--[old,:insertModemap(new,rest mmList)]
;  [new,:mmList]

(DEFUN |insertModemap| (|new| |mmList|)
  (COND ((NULL |mmList|) (CONS |new| NIL)) ('T (CONS |new| |mmList|))))

;--% Exposure Group Code
;dropPrefix(fn) ==
;  MEMBER(fn.0,[char "?",char "-",char "+"]) => SUBSTRING(fn,1,nil)
;  fn

(DEFUN |dropPrefix| (|fn|)
  (COND
    ((|member| (ELT |fn| 0)
               (CONS (|char| '?)
                     (CONS (|char| '-) (CONS (|char| '+) NIL))))
     (SUBSTRING |fn| 1 NIL))
    ('T |fn|)))

;isExposedConstructor name ==
;  -- this function checks the local exposure data in the frame to
;  -- see if the given constructor is exposed. The format of
;  -- $localExposureData is a vector with
;  --   slot 0: list of groups exposed in the frame
;  --   slot 1: list of constructors explicitly exposed
;  --   slot 2: list of constructors explicitly hidden
;  -- check if it is explicitly hidden
;  MEMQ(name,'(Union Record Mapping)) => true
;  MEMQ(name,$localExposureData.2) => false
;  -- check if it is explicitly exposed
;  MEMQ(name,$localExposureData.1) => true
;  -- check if it is in an exposed group
;  found := NIL
;  for g in $localExposureData.0 while not found repeat
;    null (x := GETALIST($globalExposureGroupAlist,g)) => 'iterate
;    if GETALIST(x,name) then found := true
;  found

(DEFUN |isExposedConstructor| (|name|)
  (PROG (|x| |found|)
    (DECLARE (SPECIAL |$globalExposureGroupAlist| |$localExposureData|))
    (RETURN
      (SEQ (COND
             ((member |name| '(|Union| |Record| |Mapping|)) 'T)
             ((member |name| (ELT |$localExposureData| 2)) NIL)
             ((member |name| (ELT |$localExposureData| 1)) 'T)
             ('T (SPADLET |found| NIL)
              (DO ((G167914 (ELT |$localExposureData| 0)
                       (CDR G167914))
                   (|g| NIL))
                  ((OR (ATOM G167914)
                       (PROGN (SETQ |g| (CAR G167914)) NIL)
                       (NULL (NULL |found|)))
                   NIL)
                (SEQ (EXIT (COND
                             ((NULL (SPADLET |x|
                                     (GETALIST
                                      |$globalExposureGroupAlist| |g|)))
                              '|iterate|)
                             ((GETALIST |x| |name|)
                              (SPADLET |found| 'T))
                             ('T NIL)))))
              |found|))))))


\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
