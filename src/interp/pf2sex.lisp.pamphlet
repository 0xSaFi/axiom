\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp pf2sex.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{Changes}
In the function [[float2Sex]] we need to special case the return value
if the global variable [[$useBFasDefault]] is set to true. This variable
allows ``big'' floating point values.

The change can be seen from this email from Greg Vanuxem:
\begin{verbatim}
Attached is the patch (pf2sex.patch) that allows the use 
of DoubleFloat by default in the interpreter. Test it.

(1) -> 1.7+7.2

   (1)  8.9
                               Type: Float
(2) -> 1.7-7.2

   (2)  - 5.5
                               Type: Float
(3) -> -1.7-7.2

   (3)  - 8.9
                               Type: Float
(4) -> )boot $useBFasDefault:=false

(SPADLET |$useBFasDefault| NIL)
Value = NIL

(4) -> 1.7+7.2

   (4)  8.9000000000000004
                               Type: DoubleFloat
(5) -> 1.7-7.2

   (5)  - 5.5
                               Type: DoubleFloat
(6) -> -1.7-7.2

   (6)  - 8.9000000000000004
                               Type: DoubleFloat



\end{verbatim}
<<*>>=

(IN-PACKAGE "BOOT")

;$dotdot := INTERN('"..", '"BOOT")

(EVAL-WHEN (EVAL LOAD) (SETQ |$dotdot| (INTERN ".." "BOOT")))

;$specificMsgTags := nil

(EVAL-WHEN (EVAL LOAD) (SETQ |$specificMsgTags| NIL))

;pmDontQuote? sy ==
;   SymMemQ(sy, '(_+ _- _* _*_* _^ _/ log exp pi sqrt ei li erf ci si dilog _
;            sin cos tan cot sec csc asin acos atan acot asec acsc _
;            sinh cosh tanh coth sech csch asinh acosh atanh acoth asech acsc))

(DEFUN |pmDontQuote?| (|sy|)
  (PROG ()
    (RETURN
      (memq |sy|
          '(+ - * ** ^ / |log| |exp| |pi| |sqrt| |ei| |li| |erf| |ci|
              |si| |dilog| |sin| |cos| |tan| |cot| |sec| |csc| |asin|
              |acos| |atan| |acot| |asec| |acsc| |sinh| |cosh| |tanh|
              |coth| |sech| |csch| |asinh| |acosh| |atanh| |acoth|
              |asech| |acsc|)))))

;pfOp2Sex pf ==
;  alreadyQuoted := pfSymbol? pf
;  op := pf2Sex1 pf
;  op is ["QUOTE", realOp] =>
;    $insideRule = 'left => realOp
;    $insideRule = 'right =>
;      pmDontQuote? realOp => realOp
;      $quotedOpList := [op, :$quotedOpList]
;      op
;    symEqual(realOp, "|") => realOp
;    symEqual(realOp, ":") => realOp
;    symEqual(realOp, "?") => realOp
;    op
;  op

(DEFUN |pfOp2Sex| (|pf|)
  (PROG (|realOp| |ISTMP#1| |op| |alreadyQuoted|)
    (DECLARE (SPECIAL |$quotedOpList| |$insideRule|))
    (RETURN
      (PROGN
        (SETQ |alreadyQuoted| (|pfSymbol?| |pf|))
        (SETQ |op| (|pf2Sex1| |pf|))
        (COND
          ((AND (CONSP |op|) (EQ (CAR |op|) 'QUOTE)
                (PROGN
                  (SETQ |ISTMP#1| (CDR |op|))
                  (AND (CONSP |ISTMP#1|) (EQ (CDR |ISTMP#1|) NIL)
                       (PROGN (SETQ |realOp| (CAR |ISTMP#1|)) 'T))))
           (COND
             ((EQ |$insideRule| '|left|) |realOp|)
             ((EQ |$insideRule| '|right|)
              (COND
                ((|pmDontQuote?| |realOp|) |realOp|)
                ('T
                 (PROGN
                   (SETQ |$quotedOpList| (CONS |op| |$quotedOpList|))
                   |op|))))
             ((eq |realOp| '|\||) |realOp|)
             ((eq |realOp| '|:|) |realOp|)
             ((eq |realOp| '?) |realOp|)
             ('T |op|)))
          ('T |op|))))))

;hasOptArgs? argSex ==
;  nonOpt := nil
;  opt := nil
;  for arg in argSex repeat
;    arg is ["OPTARG", lhs, rhs] =>
;      opt := [[lhs, rhs], :opt]
;    nonOpt := [arg, :nonOpt]
;  null opt => nil
;  NCONC (nreverse nonOpt, [["construct", :nreverse opt]])

(DEFUN |hasOptArgs?| (|argSex|)
  (PROG (|rhs| |ISTMP#2| |lhs| |ISTMP#1| |opt| |nonOpt|)
    (RETURN
      (PROGN
        (SETQ |nonOpt| NIL)
        (SETQ |opt| NIL)
        ((LAMBDA (|bfVar#17| |arg|)
           (LOOP
             (COND
               ((OR (ATOM |bfVar#17|)
                    (PROGN (SETQ |arg| (CAR |bfVar#17|)) NIL))
                (RETURN NIL))
               ('T
                (COND
                  ((AND (CONSP |arg|) (EQ (CAR |arg|) 'OPTARG)
                        (PROGN
                          (SETQ |ISTMP#1| (CDR |arg|))
                          (AND (CONSP |ISTMP#1|)
                               (PROGN
                                 (SETQ |lhs| (CAR |ISTMP#1|))
                                 (SETQ |ISTMP#2| (CDR |ISTMP#1|))
                                 (AND (CONSP |ISTMP#2|)
                                      (EQ (CDR |ISTMP#2|) NIL)
                                      (PROGN
                                        (SETQ |rhs| (CAR |ISTMP#2|))
                                        'T))))))
                   (SETQ |opt| (CONS (LIST |lhs| |rhs|) |opt|)))
                  ('T (SETQ |nonOpt| (CONS |arg| |nonOpt|))))))
             (SETQ |bfVar#17| (CDR |bfVar#17|))))
         |argSex| NIL)
        (COND
          ((NULL |opt|) NIL)
          ('T
           (NCONC (NREVERSE |nonOpt|)
                  (LIST (CONS '|construct| (NREVERSE |opt|))))))))))

;pfDefinition2Sex pf ==
;  $insideApplication =>
;    ["OPTARG", pf2Sex1 CAR pf0DefinitionLhsItems pf,
;     pf2Sex1 pfDefinitionRhs pf]
;  idList := [pf2Sex1 x for x in pf0DefinitionLhsItems pf]
;  #idList ^= 1 =>
;    systemError '"lhs of definition must be a single item in the interpreter"
;  id := first idList
;  rhs := pfDefinitionRhs pf
;  [argList, :body] := pfLambdaTran rhs
;  ["DEF", (argList = 'id => id; [id, :argList]), :body]

(DEFUN |pfDefinition2Sex| (|pf|)
  (PROG (|body| |argList| |LETTMP#1| |rhs| |id| |idList|)
    (DECLARE (SPECIAL |$insideApplication|))
    (RETURN
      (COND
        (|$insideApplication|
            (LIST 'OPTARG
                  (|pf2Sex1| (CAR (|pf0DefinitionLhsItems| |pf|)))
                  (|pf2Sex1| (|pfDefinitionRhs| |pf|))))
        ('T
         (PROGN
           (SETQ |idList|
                 ((LAMBDA (|bfVar#19| |bfVar#18| |x|)
                    (LOOP
                      (COND
                        ((OR (ATOM |bfVar#18|)
                             (PROGN (SETQ |x| (CAR |bfVar#18|)) NIL))
                         (RETURN (NREVERSE |bfVar#19|)))
                        ('T
                         (SETQ |bfVar#19|
                               (CONS (|pf2Sex1| |x|) |bfVar#19|))))
                      (SETQ |bfVar#18| (CDR |bfVar#18|))))
                  NIL (|pf0DefinitionLhsItems| |pf|) NIL))
           (COND
             ((NOT (EQL (LENGTH |idList|) 1))
              (|systemError|
                 "lhs of definition must be a single item in the interpreter"))
             ('T
              (PROGN
                (SETQ |id| (CAR |idList|))
                (SETQ |rhs| (|pfDefinitionRhs| |pf|))
                (SETQ |LETTMP#1| (|pfLambdaTran| |rhs|))
                (SETQ |argList| (CAR |LETTMP#1|))
                (SETQ |body| (CDR |LETTMP#1|))
                (CONS 'DEF
                      (CONS (COND
                              ((EQ |argList| '|id|) |id|)
                              ('T (CONS |id| |argList|)))
                            |body|)))))))))))

;pfLambdaTran pf ==
;  pfLambda? pf =>
;    argTypeList := nil
;    argList := nil
;    for arg in pf0LambdaArgs pf repeat
;      pfTyped? arg =>
;        argList := [pfCollectArgTran pfTypedId arg, :argList]
;        pfNothing? pfTypedType arg =>
;          argTypeList := [nil, :argTypeList]
;        argTypeList := [pf2Sex1 pfTypedType arg, :argTypeList]
;      systemError '"definition args should be typed"
;    argList := nreverse argList
;    retType :=
;      pfNothing? pfLambdaRets pf => nil
;      pf2Sex1 pfLambdaRets pf
;    argTypeList := [retType, :nreverse argTypeList]
;    [argList, :[argTypeList, [nil for arg in argTypeList],
;      pf2Sex1 pfLambdaBody pf]]
;  ['id, :['(()), '(()), pf2Sex1 pf]]

(DEFUN |pfLambdaTran| (|pf|)
  (PROG (|retType| |argList| |argTypeList|)
    (RETURN
      (COND
        ((|pfLambda?| |pf|)
         (PROGN
           (SETQ |argTypeList| NIL)
           (SETQ |argList| NIL)
           ((LAMBDA (|bfVar#20| |arg|)
              (LOOP
                (COND
                  ((OR (ATOM |bfVar#20|)
                       (PROGN (SETQ |arg| (CAR |bfVar#20|)) NIL))
                   (RETURN NIL))
                  ('T
                   (COND
                     ((|pfTyped?| |arg|)
                      (PROGN
                        (SETQ |argList|
                              (CONS (|pfCollectArgTran|
                                     (|pfTypedId| |arg|))
                                    |argList|))
                        (COND
                          ((|pfNothing?| (|pfTypedType| |arg|))
                           (SETQ |argTypeList|
                                 (CONS NIL |argTypeList|)))
                          ('T
                           (SETQ |argTypeList|
                                 (CONS (|pf2Sex1|
                                        (|pfTypedType| |arg|))
                                       |argTypeList|))))))
                     ('T
                      (|systemError| "definition args should be typed")))))
                (SETQ |bfVar#20| (CDR |bfVar#20|))))
            (|pf0LambdaArgs| |pf|) NIL)
           (SETQ |argList| (NREVERSE |argList|))
           (SETQ |retType|
                 (COND
                   ((|pfNothing?| (|pfLambdaRets| |pf|)) NIL)
                   ('T (|pf2Sex1| (|pfLambdaRets| |pf|)))))
           (SETQ |argTypeList|
                 (CONS |retType| (NREVERSE |argTypeList|)))
           (CONS |argList|
                 (LIST |argTypeList|
                       ((LAMBDA (|bfVar#22| |bfVar#21| |arg|)
                          (LOOP
                            (COND
                              ((OR (ATOM |bfVar#21|)
                                   (PROGN
                                     (SETQ |arg| (CAR |bfVar#21|))
                                     NIL))
                               (RETURN (NREVERSE |bfVar#22|)))
                              ('T
                               (SETQ |bfVar#22| (CONS NIL |bfVar#22|))))
                            (SETQ |bfVar#21| (CDR |bfVar#21|))))
                        NIL |argTypeList| NIL)
                       (|pf2Sex1| (|pfLambdaBody| |pf|))))))
        ('T (CONS '|id| (LIST '(NIL) '(NIL) (|pf2Sex1| |pf|))))))))

;pfLambda2Sex pf ==
;  [argList, :body] := pfLambdaTran pf
;  ["ADEF", argList, :body]

(DEFUN |pfLambda2Sex| (|pf|)
  (PROG (|body| |argList| |LETTMP#1|)
    (RETURN
      (PROGN
        (SETQ |LETTMP#1| (|pfLambdaTran| |pf|))
        (SETQ |argList| (CAR |LETTMP#1|))
        (SETQ |body| (CDR |LETTMP#1|))
        (CONS 'ADEF (CONS |argList| |body|))))))

;pfCollectArgTran pf ==
;  pfCollect? pf =>
;    conds := [pf2Sex1 x for x in pfParts pfCollectIterators pf]
;    id := pf2Sex1 pfCollectBody pf
;    conds is [["|", cond]] =>
;      ["|", id, cond]
;    [id, :conds]
;  pf2Sex1 pf

(DEFUN |pfCollectArgTran| (|pf|)
  (PROG (|cond| |ISTMP#2| |ISTMP#1| |id| |conds|)
    (RETURN
      (COND
        ((|pfCollect?| |pf|)
         (PROGN
           (SETQ |conds|
                 ((LAMBDA (|bfVar#24| |bfVar#23| |x|)
                    (LOOP
                      (COND
                        ((OR (ATOM |bfVar#23|)
                             (PROGN (SETQ |x| (CAR |bfVar#23|)) NIL))
                         (RETURN (NREVERSE |bfVar#24|)))
                        ('T
                         (SETQ |bfVar#24|
                               (CONS (|pf2Sex1| |x|) |bfVar#24|))))
                      (SETQ |bfVar#23| (CDR |bfVar#23|))))
                  NIL (|pfParts| (|pfCollectIterators| |pf|)) NIL))
           (SETQ |id| (|pf2Sex1| (|pfCollectBody| |pf|)))
           (COND
             ((AND (CONSP |conds|) (EQ (CDR |conds|) NIL)
                   (PROGN
                     (SETQ |ISTMP#1| (CAR |conds|))
                     (AND (CONSP |ISTMP#1|) (EQ (CAR |ISTMP#1|) '|\||)
                          (PROGN
                            (SETQ |ISTMP#2| (CDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (CDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SETQ |cond| (CAR |ISTMP#2|))
                                   'T))))))
              (LIST '|\|| |id| |cond|))
             ('T (CONS |id| |conds|)))))
        ('T (|pf2Sex1| |pf|))))))

;float2Sex num ==
;  eIndex := SEARCH('"e", num)
;  mantPart :=
;    eIndex => SUBSEQ(num, 0, eIndex)
;    num
;  expPart := (eIndex => READ_-FROM_-STRING SUBSEQ(num, eIndex+1); 0)
;  dotIndex := SEARCH('".", mantPart)
;  intPart :=
;    dotIndex => READ_-FROM_-STRING SUBSEQ(mantPart, 0, dotIndex)
;    READ_-FROM_-STRING mantPart
;  fracPartString :=
;    dotIndex => SUBSEQ(mantPart, dotIndex+1)
;    '"0"
;  bfForm := MAKE_-FLOAT(intPart, READ_-FROM_-STRING fracPartString,
;    LENGTH fracPartString, expPart)
;  $useBFasDefault =>
;    [., frac, :exp] := bfForm
;    [["$elt", intNewFloat(), 'float], frac, exp, 10]
;  bfForm 

(DEFUN |float2Sex| (|num|)
  (PROG (|exp| |frac| |bfForm| |fracPartString| |intPart| |dotIndex|
               |expPart| |mantPart| |eIndex|)
    (DECLARE (SPECIAL |$useBFasDefault|))
    (RETURN
      (PROGN
        (SETQ |eIndex| (SEARCH "e" |num|))
        (SETQ |mantPart|
              (COND (|eIndex| (SUBSEQ |num| 0 |eIndex|)) ('T |num|)))
        (SETQ |expPart|
              (COND
                (|eIndex|
                    (READ-FROM-STRING (SUBSEQ |num| (+ |eIndex| 1))))
                ('T 0)))
        (SETQ |dotIndex| (SEARCH "." |mantPart|))
        (SETQ |intPart|
              (COND
                (|dotIndex|
                    (READ-FROM-STRING (SUBSEQ |mantPart| 0 |dotIndex|)))
                ('T (READ-FROM-STRING |mantPart|))))
        (SETQ |fracPartString|
              (COND
                (|dotIndex| (SUBSEQ |mantPart| (+ |dotIndex| 1)))
                ('T "0")))
        (SETQ |bfForm|
              (MAKE-FLOAT |intPart| (READ-FROM-STRING |fracPartString|)
                  (LENGTH |fracPartString|) |expPart|))
        (COND
          (|$useBFasDefault|
              (PROGN
                (SETQ |frac| (CADR |bfForm|))
                (SETQ |exp| (CDDR |bfForm|))
                (LIST (LIST '|$elt| (list '|Float|) '|float|) |frac|
                      |exp| 10)))
          ('T |bfForm|))))))


;pfCollect2Sex pf ==
;  sex := ["COLLECT", :loopIters2Sex pfParts pfCollectIterators pf,
;    pf2Sex1 pfCollectBody pf]
;  sex is ["COLLECT", ["|", cond], var] and SYMBOLP var =>
;    ["|", var, cond]
;  sex

(DEFUN |pfCollect2Sex| (|pf|)
  (PROG (|var| |ISTMP#4| |cond| |ISTMP#3| |ISTMP#2| |ISTMP#1| |sex|)
    (RETURN
      (PROGN
        (SETQ |sex|
              (CONS 'COLLECT
                    (APPEND (|loopIters2Sex|
                                (|pfParts| (|pfCollectIterators| |pf|)))
                            (CONS (|pf2Sex1| (|pfCollectBody| |pf|))
                                  NIL))))
        (COND
          ((AND (CONSP |sex|) (EQ (CAR |sex|) 'COLLECT)
                (PROGN
                  (SETQ |ISTMP#1| (CDR |sex|))
                  (AND (CONSP |ISTMP#1|)
                       (PROGN
                         (SETQ |ISTMP#2| (CAR |ISTMP#1|))
                         (AND (CONSP |ISTMP#2|)
                              (EQ (CAR |ISTMP#2|) '|\||)
                              (PROGN
                                (SETQ |ISTMP#3| (CDR |ISTMP#2|))
                                (AND (CONSP |ISTMP#3|)
                                     (EQ (CDR |ISTMP#3|) NIL)
                                     (PROGN
                                       (SETQ |cond| (CAR |ISTMP#3|))
                                       'T)))))
                       (PROGN
                         (SETQ |ISTMP#4| (CDR |ISTMP#1|))
                         (AND (CONSP |ISTMP#4|)
                              (EQ (CDR |ISTMP#4|) NIL)
                              (PROGN (SETQ |var| (CAR |ISTMP#4|)) 'T)))))
                (SYMBOLP |var|))
           (LIST '|\|| |var| |cond|))
          ('T |sex|))))))

;pfRule2Sex pf ==
;  $quotedOpList:local := nil
;  $predicateList:local := nil
;  $multiVarPredicateList:local := nil
;  lhs := pfLhsRule2Sex pfRuleLhsItems pf
;  rhs := pfRhsRule2Sex pfRuleRhs pf
;  lhs := ruleLhsTran lhs
;  rulePredicateTran
;    $quotedOpList => ["rule", lhs, rhs, ["construct", :$quotedOpList]]
;    ["rule", lhs, rhs]

(DEFUN |pfRule2Sex| (|pf|)
  (PROG (|$multiVarPredicateList| |$predicateList| |$quotedOpList|
            |rhs| |lhs|)
    (DECLARE (SPECIAL |$multiVarPredicateList| |$predicateList|
                      |$quotedOpList|))
    (RETURN
      (PROGN
        (SETQ |$quotedOpList| NIL)
        (SETQ |$predicateList| NIL)
        (SETQ |$multiVarPredicateList| NIL)
        (SETQ |lhs| (|pfLhsRule2Sex| (|pfRuleLhsItems| |pf|)))
        (SETQ |rhs| (|pfRhsRule2Sex| (|pfRuleRhs| |pf|)))
        (SETQ |lhs| (|ruleLhsTran| |lhs|))
        (|rulePredicateTran|
            (COND
              (|$quotedOpList|
                  (LIST '|rule| |lhs| |rhs|
                        (CONS '|construct| |$quotedOpList|)))
              ('T (LIST '|rule| |lhs| |rhs|))))))))

;ruleLhsTran ruleLhs ==
;  for pred in $predicateList repeat
;    [name, predLhs, :predRhs] := pred
;    vars := patternVarsOf predRhs
;    CDR vars =>  -- if there is more than one patternVariable
;      ruleLhs := NSUBST(predLhs, name, ruleLhs)
;      $multiVarPredicateList := [pred, :$multiVarPredicateList]
;    predicate :=
;      [., var] := predLhs
;      ["suchThat", predLhs, ["ADEF", [var],
;        '((Boolean) (Expression (Integer))), '(() ()), predRhs]]
;    ruleLhs := NSUBST(predicate, name, ruleLhs)
;  ruleLhs

(DEFUN |ruleLhsTran| (|ruleLhs|)
  (PROG (|predicate| |var| |vars| |predRhs| |predLhs| |name|)
    (DECLARE (SPECIAL |$predicateList| |$multiVarPredicateList|))
    (RETURN
      (PROGN
        ((LAMBDA (|bfVar#28| |pred|)
           (LOOP
             (COND
               ((OR (ATOM |bfVar#28|)
                    (PROGN (SETQ |pred| (CAR |bfVar#28|)) NIL))
                (RETURN NIL))
               ('T
                (PROGN
                  (SETQ |name| (CAR |pred|))
                  (SETQ |predLhs| (CADR |pred|))
                  (SETQ |predRhs| (CDDR |pred|))
                  (SETQ |vars| (|patternVarsOf| |predRhs|))
                  (COND
                    ((CDR |vars|)
                     (PROGN
                       (SETQ |ruleLhs|
                             (NSUBST |predLhs| |name| |ruleLhs|))
                       (SETQ |$multiVarPredicateList|
                             (CONS |pred| |$multiVarPredicateList|))))
                    ('T
                     (PROGN
                       (SETQ |predicate|
                             (PROGN
                               (SETQ |var| (CADR |predLhs|))
                               (LIST '|suchThat| |predLhs|
                                     (LIST 'ADEF (LIST |var|)
                                      '((|Boolean|)
                                        (|Expression| (|Integer|)))
                                      '(NIL NIL) |predRhs|))))
                       (SETQ |ruleLhs|
                             (NSUBST |predicate| |name| |ruleLhs|))))))))
             (SETQ |bfVar#28| (CDR |bfVar#28|))))
         |$predicateList| NIL)
        |ruleLhs|))))

;rulePredicateTran rule ==
;  null $multiVarPredicateList => rule
;  varList := patternVarsOf [rhs for [.,.,:rhs] in $multiVarPredicateList]
;  predBody :=
;    CDR $multiVarPredicateList =>
;      ['AND, :[:pvarPredTran(rhs, varList) for [.,.,:rhs] in
;        $multiVarPredicateList]]
;    [[.,.,:rhs],:.] := $multiVarPredicateList
;    pvarPredTran(rhs, varList)
;  ['suchThat, rule,
;   ['construct, :[["QUOTE", var] for var in varList]],
;    ['ADEF, '(predicateVariable),
;     '((Boolean) (List (Expression (Integer)))), '(() ()),
;      predBody]]

(DEFUN |rulePredicateTran| (|rule|)
  (PROG (|predBody| |varList| |rhs| |ISTMP#1|)
    (DECLARE (SPECIAL |$multiVarPredicateList|))
    (RETURN
      (COND
        ((NULL |$multiVarPredicateList|) |rule|)
        ('T
         (PROGN
           (SETQ |varList|
                 (|patternVarsOf|
                     ((LAMBDA (|bfVar#31| |bfVar#30| |bfVar#29|)
                        (LOOP
                          (COND
                            ((OR (ATOM |bfVar#30|)
                                 (PROGN
                                   (SETQ |bfVar#29| (CAR |bfVar#30|))
                                   NIL))
                             (RETURN (NREVERSE |bfVar#31|)))
                            ('T
                             (AND (CONSP |bfVar#29|)
                                  (PROGN
                                    (SETQ |ISTMP#1| (CDR |bfVar#29|))
                                    (AND (CONSP |ISTMP#1|)
                                     (PROGN
                                       (SETQ |rhs| (CDR |ISTMP#1|))
                                       'T)))
                                  (SETQ |bfVar#31|
                                        (CONS |rhs| |bfVar#31|)))))
                          (SETQ |bfVar#30| (CDR |bfVar#30|))))
                      NIL |$multiVarPredicateList| NIL)))
           (SETQ |predBody|
                 (COND
                   ((CDR |$multiVarPredicateList|)
                    (CONS 'AND
                          ((LAMBDA (|bfVar#34| |bfVar#33| |bfVar#32|)
                             (LOOP
                               (COND
                                 ((OR (ATOM |bfVar#33|)
                                      (PROGN
                                        (SETQ |bfVar#32|
                                         (CAR |bfVar#33|))
                                        NIL))
                                  (RETURN (NREVERSE |bfVar#34|)))
                                 ('T
                                  (AND (CONSP |bfVar#32|)
                                       (PROGN
                                         (SETQ |ISTMP#1|
                                          (CDR |bfVar#32|))
                                         (AND (CONSP |ISTMP#1|)
                                          (PROGN
                                            (SETQ |rhs|
                                             (CDR |ISTMP#1|))
                                            'T)))
                                       (SETQ |bfVar#34|
                                        (APPEND
                                         (REVERSE
                                          (|pvarPredTran| |rhs|
                                           |varList|))
                                         |bfVar#34|)))))
                               (SETQ |bfVar#33| (CDR |bfVar#33|))))
                           NIL |$multiVarPredicateList| NIL)))
                   ('T
                    (PROGN
                      (SETQ |rhs| (CDDAR |$multiVarPredicateList|))
                      (|pvarPredTran| |rhs| |varList|)))))
           (LIST '|suchThat| |rule|
                 (CONS '|construct|
                       ((LAMBDA (|bfVar#36| |bfVar#35| |var|)
                          (LOOP
                            (COND
                              ((OR (ATOM |bfVar#35|)
                                   (PROGN
                                     (SETQ |var| (CAR |bfVar#35|))
                                     NIL))
                               (RETURN (NREVERSE |bfVar#36|)))
                              ('T
                               (SETQ |bfVar#36|
                                     (CONS (LIST 'QUOTE |var|)
                                      |bfVar#36|))))
                            (SETQ |bfVar#35| (CDR |bfVar#35|))))
                        NIL |varList| NIL))
                 (LIST 'ADEF '(|predicateVariable|)
                       '((|Boolean|)
                         (|List| (|Expression| (|Integer|))))
                       '(NIL NIL) |predBody|))))))))

;pvarPredTran(rhs, varList) ==
;  for var in varList for i in 1.. repeat
;    rhs := NSUBST(['elt, 'predicateVariable, i], var, rhs)
;  rhs

(DEFUN |pvarPredTran| (|rhs| |varList|)
  (PROG ()
    (RETURN
      (PROGN
        ((LAMBDA (|bfVar#37| |var| |i|)
           (LOOP
             (COND
               ((OR (ATOM |bfVar#37|)
                    (PROGN (SETQ |var| (CAR |bfVar#37|)) NIL))
                (RETURN NIL))
               ('T
                (SETQ |rhs|
                      (NSUBST (LIST '|elt| '|predicateVariable| |i|)
                              |var| |rhs|))))
             (SETQ |bfVar#37| (CDR |bfVar#37|))
             (SETQ |i| (+ |i| 1))))
         |varList| NIL 1)
        |rhs|))))

;patternVarsOf expr ==
;  patternVarsOf1(expr, nil)

(DEFUN |patternVarsOf| (|expr|)
  (PROG () (RETURN (|patternVarsOf1| |expr| NIL))))

;patternVarsOf1(expr, varList) ==
;  NULL expr => varList
;  ATOM expr =>
;    null SYMBOLP expr => varList
;    SymMemQ(expr, varList) => varList
;    [expr, :varList]
;  expr is [op, :argl] =>
;    for arg in argl repeat
;      varList := patternVarsOf1(arg, varList)
;    varList
;  varList

(DEFUN |patternVarsOf1| (|expr| |varList|)
  (PROG (|argl| |op|)
    (RETURN
      (COND
        ((NULL |expr|) |varList|)
        ((ATOM |expr|)
         (COND
           ((NULL (SYMBOLP |expr|)) |varList|)
           ((memq |expr| |varList|) |varList|)
           ('T (CONS |expr| |varList|))))
        ((AND (CONSP |expr|)
              (PROGN
                (SETQ |op| (CAR |expr|))
                (SETQ |argl| (CDR |expr|))
                'T))
         (PROGN
           ((LAMBDA (|bfVar#38| |arg|)
              (LOOP
                (COND
                  ((OR (ATOM |bfVar#38|)
                       (PROGN (SETQ |arg| (CAR |bfVar#38|)) NIL))
                   (RETURN NIL))
                  ('T
                   (SETQ |varList| (|patternVarsOf1| |arg| |varList|))))
                (SETQ |bfVar#38| (CDR |bfVar#38|))))
            |argl| NIL)
           |varList|))
        ('T |varList|)))))

;pfLhsRule2Sex lhs ==
;  $insideRule: local := 'left
;  pf2Sex1 lhs

(DEFUN |pfLhsRule2Sex| (|lhs|)
  (PROG (|$insideRule|)
    (DECLARE (SPECIAL |$insideRule|))
    (RETURN (PROGN (SETQ |$insideRule| '|left|) (|pf2Sex1| |lhs|)))))

;pfRhsRule2Sex rhs ==
;  $insideRule: local := 'right
;  pf2Sex1 rhs

(DEFUN |pfRhsRule2Sex| (|rhs|)
  (PROG (|$insideRule|)
    (DECLARE (SPECIAL |$insideRule|))
    (RETURN (PROGN (SETQ |$insideRule| '|right|) (|pf2Sex1| |rhs|)))))

;pfSuchThat2Sex args ==
;  name := GENTEMP()
;  argList := pf0TupleParts args
;  lhsSex := pf2Sex1 CAR argList
;  rhsSex := pf2Sex CADR argList
;  $predicateList := [[name, lhsSex, :rhsSex], :$predicateList]
;  name

(DEFUN |pfSuchThat2Sex| (|args|)
  (PROG (|rhsSex| |lhsSex| |argList| |name|)
    (DECLARE (SPECIAL |$predicateList|))
    (RETURN
      (PROGN
        (SETQ |name| (GENTEMP))
        (SETQ |argList| (|pf0TupleParts| |args|))
        (SETQ |lhsSex| (|pf2Sex1| (CAR |argList|)))
        (SETQ |rhsSex| (|pf2Sex| (CADR |argList|)))
        (SETQ |$predicateList|
              (CONS (CONS |name| (CONS |lhsSex| |rhsSex|))
                    |$predicateList|))
        |name|))))

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
