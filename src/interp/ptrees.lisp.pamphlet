\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp ptrees.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=
(in-package "BOOT")

;pfLeaf? form ==
;  MEMQ(pfAbSynOp form,
;       '(id idsy symbol string char float expression integer
;          Document error))

(DEFUN |pfLeaf?| (|form|)
  (PROG ()
    (RETURN
      (MEMQ (|pfAbSynOp| |form|)
            '(|id| |idsy| |symbol| |string| |char| |float| |expression|
                   |integer| |Document| |error|)))))

;pfLeafPosition form == tokPosn form

(DEFUN |pfLeafPosition| (|form|)
  (PROG () (RETURN (|tokPosn| |form|))))

;--% LEAVES
;pfId(expr)               == pfLeaf('id, expr)

(DEFUN |pfId| (|expr|) (PROG () (RETURN (|pfLeaf| '|id| |expr|))))

;pfIdPos(expr,pos)        == pfLeaf('id,expr,pos)

(DEFUN |pfIdPos| (|expr| |pos|)
  (PROG () (RETURN (|pfLeaf| '|id| |expr| |pos|))))

;pfExpression(expr, :optpos) ==
;               pfLeaf("expression", expr, IFCAR optpos)

(DEFUN |pfExpression| (|expr| &REST |optpos|)
  (PROG () (RETURN (|pfLeaf| '|expression| |expr| (IFCAR |optpos|)))))

;pfSymbol(expr, :optpos) ==
;               pfLeaf("symbol", expr, IFCAR optpos)

(DEFUN |pfSymbol| (|expr| &REST |optpos|)
  (PROG () (RETURN (|pfLeaf| '|symbol| |expr| (IFCAR |optpos|)))))

;pfSymb(expr, :optpos) ==
;         if pfLeaf? expr
;         then pfSymbol(tokPart expr,IFCAR optpos)
;         else pfExpression(pfSexpr expr,IFCAR optpos)

(DEFUN |pfSymb| (|expr| &REST |optpos|)
  (PROG ()
    (RETURN
      (COND
        ((|pfLeaf?| |expr|)
         (|pfSymbol| (|tokPart| |expr|) (IFCAR |optpos|)))
        ('T (|pfExpression| (|pfSexpr| |expr|) (IFCAR |optpos|)))))))

;--% TREES
;-- parser interface functions
;-- these are potential sources of trouble in macro expansion
;
;-- the comment is attached to all signatutres
;pfWDec(doc,name)   == [pfWDeclare(i,doc) for i in pfParts name]

(DEFUN |pfWDec| (|doc| |name|)
  (PROG ()
    (RETURN
      ((LAMBDA (|bfVar#2| |bfVar#1| |i|)
         (LOOP
           (COND
             ((OR (ATOM |bfVar#1|)
                  (PROGN (SETQ |i| (CAR |bfVar#1|)) NIL))
              (RETURN (NREVERSE |bfVar#2|)))
             ('T
              (SETQ |bfVar#2|
                    (CONS (|pfWDeclare| |i| |doc|) |bfVar#2|))))
           (SETQ |bfVar#1| (CDR |bfVar#1|))))
       NIL (|pfParts| |name|) NIL))))

;pfTweakIf form==
;    a:=pfIfElse form
;    b:=if pfNothing? a then pfListOf [] else a
;    pfTree('WIf,[pfIfCond form,pfIfThen form,b])

(DEFUN |pfTweakIf| (|form|)
  (PROG (|b| |a|)
    (RETURN
      (PROGN
        (SETQ |a| (|pfIfElse| |form|))
        (SETQ |b|
              (COND ((|pfNothing?| |a|) (|pfListOf| NIL)) ('T |a|)))
        (|pfTree| '|WIf|
            (LIST (|pfIfCond| |form|) (|pfIfThen| |form|) |b|))))))

;pfFromDom(dom,expr)==
;    if pfApplication? expr
;    then pfApplication(pfFromdom(pfApplicationOp expr,dom),
;                       pfApplicationArg expr)
;    else pfFromdom(expr,dom)
;

(DEFUN |pfFromDom| (|dom| |expr|)
  (PROG ()
    (RETURN
      (COND
        ((|pfApplication?| |expr|)
         (|pfApplication|
             (|pfFromdom| (|pfApplicationOp| |expr|) |dom|)
             (|pfApplicationArg| |expr|)))
        ('T (|pfFromdom| |expr| |dom|))))))

;pfIfThenOnly(pred,first)==pfIf(pred,first,pfNothing())

(DEFUN |pfIfThenOnly| (|pred| CAR)
  (PROG () (RETURN (|pfIf| |pred| CAR (|pfNothing|)))))

;pfLp(iterators,body)==
;       pfLoop pfListOf [:iterators,pfDo body]

(DEFUN |pfLp| (|iterators| |body|)
  (PROG ()
    (RETURN
      (|pfLoop|
          (|pfListOf| (APPEND |iterators| (CONS (|pfDo| |body|) NIL)))))))

;pfLoop1 body == pfLoop pfListOf [pfDo body]

(DEFUN |pfLoop1| (|body|)
  (PROG () (RETURN (|pfLoop| (|pfListOf| (LIST (|pfDo| |body|)))))))

;pfReturnNoName(value)==pfReturn(value,pfNothing())

(DEFUN |pfReturnNoName| (|value|)
  (PROG () (RETURN (|pfReturn| |value| (|pfNothing|)))))

;pfBrace(a,part)==pfApplication(pfIdPos( "{}",tokPosn a),part)

(DEFUN |pfBrace| (|a| |part|)
  (PROG ()
    (RETURN (|pfApplication| (|pfIdPos| '{} (|tokPosn| |a|)) |part|))))

;pfBracket(a,part) ==  pfApplication(pfIdPos( "[]",tokPosn a),part)

(DEFUN |pfBracket| (|a| |part|)
  (PROG ()
    (RETURN (|pfApplication| (|pfIdPos| '[] (|tokPosn| |a|)) |part|))))

;pfBraceBar(a,part)==pfApplication(pfIdPos( "{||}",tokPosn a),part)

(DEFUN |pfBraceBar| (|a| |part|)
  (PROG ()
    (RETURN
      (|pfApplication| (|pfIdPos| '|{\|\|}| (|tokPosn| |a|)) |part|))))

;pfBracketBar(a,part) ==  pfApplication(pfIdPos( "[||]",tokPosn a),part)

(DEFUN |pfBracketBar| (|a| |part|)
  (PROG ()
    (RETURN
      (|pfApplication| (|pfIdPos| '|[\|\|]| (|tokPosn| |a|)) |part|))))

;pfHide(a,part) ==   pfTree("Hide",[part])

(DEFUN |pfHide| (|a| |part|)
  (PROG () (RETURN (|pfTree| '|Hide| (LIST |part|)))))

;pfParen(a,part)==part

(DEFUN |pfParen| (|a| |part|) (PROG () (RETURN |part|)))

;pfPile(part)==part

(DEFUN |pfPile| (|part|) (PROG () (RETURN |part|)))

;pfSpread(l,t)==  [pfTyped(i,t) for i in l]

(DEFUN |pfSpread| (|l| |t|)
  (PROG ()
    (RETURN
      ((LAMBDA (|bfVar#4| |bfVar#3| |i|)
         (LOOP
           (COND
             ((OR (ATOM |bfVar#3|)
                  (PROGN (SETQ |i| (CAR |bfVar#3|)) NIL))
              (RETURN (NREVERSE |bfVar#4|)))
             ('T (SETQ |bfVar#4| (CONS (|pfTyped| |i| |t|) |bfVar#4|))))
           (SETQ |bfVar#3| (CDR |bfVar#3|))))
       NIL |l| NIL))))

;--The rest have been generated from ABCUT INPUT
;-- 1/31/89
;
;
;--              Add         / Application  / Assign /
;--              Coerceto    / Collect      / ComDefinition  / DeclPart /
;--              Exit        / Export       / Free /
;--              Fromdom     / Id           / If            / Inline /
;--              Iterate     / Lambda /
;--              Break       / Literal      / Local         / Loop   /
;--              MLambda     / Pretend      / Restrict    / Return /
;--              Sequence    / Tagged       / Tuple         / Typing /
;--              Where       / With

;pfExpr? pf ==
;     pfAdd? pf or _
;     pfApplication? pf or _
;     pfAssign? pf or _
;     pfCoerceto? pf or _
;     pfCollect? pf or _
;     pfComDefinition? pf or _
;     pfDeclPart? pf or _
;     pfExit? pf or _
;     pfExport? pf or _
;     pfFree? pf or _
;     pfFromdom? pf or _
;     pfId? pf or _
;     pfIf? pf or _
;     pfInline? pf or _
;     pfIterate? pf or _
;     pfLambda? pf or _
;     pfBreak? pf or _
;     pfLiteral? pf or _
;     pfLocal? pf or _
;     pfLoop? pf or _
;     pfMLambda? pf or _
;     pfPretend? pf or _
;     pfRestrict? pf or _
;     pfReturn? pf or _
;     pfSequence? pf or _
;     pfTagged? pf or _
;     pfTuple? pf or _
;     pfTyping? pf or _
;     pfWhere? pf or _
;     pfWith? pf

;-- Add         := (Base: [Typed],  Addin: Expr)

;pfAdd(pfbase, pfaddin,:addon) ==
;    lhs := if addon
;           then first addon
;           else pfNothing()
;    pfTree('Add, [pfbase, pfaddin,lhs])

(DEFUN |pfAdd| (|pfbase| |pfaddin| &REST |addon|)
  (PROG (|lhs|)
    (RETURN
      (PROGN
        (SETQ |lhs| (COND (|addon| (CAR |addon|)) ('T (|pfNothing|))))
        (|pfTree| '|Add| (LIST |pfbase| |pfaddin| |lhs|))))))

;-- With        := (Base: [Typed],  Within: [WithPart])

;pfWith(pfbase, pfwithin,pfwithon) ==
;         pfTree('With, [pfbase, pfwithin,pfwithon])

(DEFUN |pfWith| (|pfbase| |pfwithin| |pfwithon|)
  (PROG ()
    (RETURN (|pfTree| '|With| (LIST |pfbase| |pfwithin| |pfwithon|)))))

;-- WDeclare    := (Signature: Typed, Doc: ? Document)

;pfWDeclare(pfsignature, pfdoc) == pfTree('WDeclare, [pfsignature, pfdoc])

(DEFUN |pfWDeclare| (|pfsignature| |pfdoc|)
  (PROG ()
    (RETURN (|pfTree| '|WDeclare| (LIST |pfsignature| |pfdoc|)))))

;-- Attribute   := (Expr: Primary)

;pfAttribute(pfexpr) == pfTree('Attribute, [pfexpr])

(DEFUN |pfAttribute| (|pfexpr|)
  (PROG () (RETURN (|pfTree| '|Attribute| (LIST |pfexpr|)))))

;-- Typed       := (Id: Id,    Type: ? Type)

;pfTyped(pfid, pftype) == pfTree('Typed, [pfid, pftype])

(DEFUN |pfTyped| (|pfid| |pftype|)
  (PROG () (RETURN (|pfTree| '|Typed| (LIST |pfid| |pftype|)))))

;-- Application := (Op:   Expr, Arg:    Expr)

;pfApplication(pfop, pfarg) ==
;        pfTree('Application, [pfop, pfarg])

;-- Tagged      := (Tag:  Expr, Expr:   Expr)

;pfTagged(pftag, pfexpr) == pfTree('Tagged, [pftag, pfexpr])

(DEFUN |pfTagged| (|pftag| |pfexpr|)
  (PROG () (RETURN (|pfTree| '|Tagged| (LIST |pftag| |pfexpr|)))))

;-- Pretend     := (Expr: Expr, Type:   Type)

;pfPretend(pfexpr, pftype) == pfTree('Pretend, [pfexpr, pftype])

(DEFUN |pfPretend| (|pfexpr| |pftype|)
  (PROG () (RETURN (|pfTree| '|Pretend| (LIST |pfexpr| |pftype|)))))


;-- Restrict    := (Expr: Expr, Type:   Type)

;pfRestrict(pfexpr, pftype) == pfTree('Restrict, [pfexpr, pftype])

(DEFUN |pfRestrict| (|pfexpr| |pftype|)
  (PROG () (RETURN (|pfTree| '|Restrict| (LIST |pfexpr| |pftype|)))))

;pfRetractTo(pfexpr, pftype) == pfTree('RetractTo, [pfexpr, pftype])

(DEFUN |pfRetractTo| (|pfexpr| |pftype|)
  (PROG () (RETURN (|pfTree| '|RetractTo| (LIST |pfexpr| |pftype|)))))

;-- Coerceto    := (Expr: Expr, Type:   Type)

;pfCoerceto(pfexpr, pftype) == pfTree('Coerceto, [pfexpr, pftype])

(DEFUN |pfCoerceto| (|pfexpr| |pftype|)
  (PROG () (RETURN (|pfTree| '|Coerceto| (LIST |pfexpr| |pftype|)))))

;-- Fromdom     := (What: Id,   Domain: Type)

;pfFromdom(pfwhat, pfdomain) == pfTree('Fromdom, [pfwhat, pfdomain])

(DEFUN |pfFromdom| (|pfwhat| |pfdomain|)
  (PROG () (RETURN (|pfTree| '|Fromdom| (LIST |pfwhat| |pfdomain|)))))

;pfFix pf== pfApplication(pfId "Y",pf)

(DEFUN |pfFix| (|pf|)
  (PROG () (RETURN (|pfApplication| (|pfId| 'Y) |pf|))))

;-- MLambda     := (Args: [Id], Body: Expr)

;pfMLambda(pfargs, pfbody) == pfTree('MLambda, [pfargs, pfbody])

(DEFUN |pfMLambda| (|pfargs| |pfbody|)
  (PROG () (RETURN (|pfTree| '|MLambda| (LIST |pfargs| |pfbody|)))))

;pfMLambdaArgs pf == CADR pf       -- was ==>

(DEFUN |pfMLambdaArgs| (|pf|) (PROG () (RETURN (CADR |pf|))))

;pfMLambdaBody pf == CADDR pf       -- was ==>

(DEFUN |pfMLambdaBody| (|pf|) (PROG () (RETURN (CADDR |pf|))))

;pf0MLambdaArgs pf == pfParts pfMLambdaArgs pf

(DEFUN |pf0MLambdaArgs| (|pf|)
  (PROG () (RETURN (|pfParts| (|pfMLambdaArgs| |pf|)))))

;-- Where       := (Context: [DeclPart], Expr: Expr)

;pfWhere(pfcontext, pfexpr) == pfTree('Where, [pfcontext, pfexpr])

(DEFUN |pfWhere| (|pfcontext| |pfexpr|)
  (PROG () (RETURN (|pfTree| '|Where| (LIST |pfcontext| |pfexpr|)))))

;-- If          := (Cond: Expr, Then: Expr, Else: ? Expr)
;
;pfIf(pfcond, pfthen, pfelse) == pfTree('If, [pfcond, pfthen, pfelse])

(DEFUN |pfIf| (|pfcond| |pfthen| |pfelse|)
  (PROG ()
    (RETURN (|pfTree| '|If| (LIST |pfcond| |pfthen| |pfelse|)))))

;-- Loop        := (Iterators: [Iterator])

;pfLoop(pfiterators) == pfTree('Loop, [pfiterators])

(DEFUN |pfLoop| (|pfiterators|)
  (PROG () (RETURN (|pfTree| '|Loop| (LIST |pfiterators|)))))

;-- Collect     := (Body: Expr, Iterators: [Iterator])

;pfCollect(pfbody, pfiterators) == pfTree('Collect, [pfbody, pfiterators])

(DEFUN |pfCollect| (|pfbody| |pfiterators|)
  (PROG ()
    (RETURN (|pfTree| '|Collect| (LIST |pfbody| |pfiterators|)))))

;-- Forin       := (Lhs: [AssLhs], Whole: Expr)

;pfForin(pflhs, pfwhole) == pfTree('Forin, [pflhs, pfwhole])

(DEFUN |pfForin| (|pflhs| |pfwhole|)
  (PROG () (RETURN (|pfTree| '|Forin| (LIST |pflhs| |pfwhole|)))))

;-- While       := (Cond: Expr)

;pfWhile(pfcond) == pfTree('While, [pfcond])

(DEFUN |pfWhile| (|pfcond|)
  (PROG () (RETURN (|pfTree| '|While| (LIST |pfcond|)))))

;-- Until       := (Cond: Expr)

;--pfUntil(pfcond) == pfTree('Until, [pfcond])
;--pfUntil?(pf) == pfAbSynOp? (pf, 'Until)
;--pfUntilCond pf == CADR pf       -- was ==>


;-- Suchthat    := (Cond: Expr)

;pfSuchthat(pfcond) == pfTree('Suchthat, [pfcond])

(DEFUN |pfSuchthat| (|pfcond|)
  (PROG () (RETURN (|pfTree| '|Suchthat| (LIST |pfcond|)))))

;-- Do          := (Body: Expr)

;pfDo(pfbody) == pfTree('Do, [pfbody])

(DEFUN |pfDo| (|pfbody|)
  (PROG () (RETURN (|pfTree| '|Do| (LIST |pfbody|)))))

;-- Iterate     := (From: ? Id)

;pfIterate(pffrom) == pfTree('Iterate, [pffrom])

(DEFUN |pfIterate| (|pffrom|)
  (PROG () (RETURN (|pfTree| '|Iterate| (LIST |pffrom|)))))

;-- Break       := (From: ? Id)

;pfBreak(pffrom) == pfTree('Break, [pffrom])

(DEFUN |pfBreak| (|pffrom|)
  (PROG () (RETURN (|pfTree| '|Break| (LIST |pffrom|)))))

;-- Return      := (Expr: ? Expr, From: ? Id)

;pfReturn(pfexpr, pffrom) == pfTree('Return, [pfexpr, pffrom])

(DEFUN |pfReturn| (|pfexpr| |pffrom|)
  (PROG () (RETURN (|pfTree| '|Return| (LIST |pfexpr| |pffrom|)))))

;-- Exit        := (Cond: ? Expr, Expr: ? Expr)

;pfExit(pfcond, pfexpr) == pfTree('Exit, [pfcond, pfexpr])

(DEFUN |pfExit| (|pfcond| |pfexpr|)
  (PROG () (RETURN (|pfTree| '|Exit| (LIST |pfcond| |pfexpr|)))))

;-- Macro       := (Lhs:  Id,     Rhs: ExprorNot)

;pfMacro(pflhs, pfrhs) == pfTree('Macro, [pflhs, pfrhs])

(DEFUN |pfMacro| (|pflhs| |pfrhs|)
  (PROG () (RETURN (|pfTree| '|Macro| (LIST |pflhs| |pfrhs|)))))

;pfMacroLhs pf == CADR pf       -- was ==>

(DEFUN |pfMacroLhs| (|pf|) (PROG () (RETURN (CADR |pf|))))

;pfMacroRhs pf == CADDR pf       -- was ==>

(DEFUN |pfMacroRhs| (|pf|) (PROG () (RETURN (CADDR |pf|))))

;-- Definition  := (LhsItems:  [Typed], Rhs:  Expr)

;pfDefinition(pflhsitems, pfrhs) == pfTree('Definition, [pflhsitems, pfrhs])

(DEFUN |pfDefinition| (|pflhsitems| |pfrhs|)
  (PROG ()
    (RETURN (|pfTree| '|Definition| (LIST |pflhsitems| |pfrhs|)))))

;-- Assign      := (LhsItems:  [AssLhs], Rhs:  Expr)
;
;pfAssign(pflhsitems, pfrhs) == pfTree('Assign, [pflhsitems, pfrhs])

(DEFUN |pfAssign| (|pflhsitems| |pfrhs|)
  (PROG () (RETURN (|pfTree| '|Assign| (LIST |pflhsitems| |pfrhs|)))))

;-- Typing      := (Items: [Typed])

;pfTyping(pfitems) == pfTree('Typing, [pfitems])

(DEFUN |pfTyping| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Typing| (LIST |pfitems|)))))

;-- Export       := (Items: [Typed])

;pfExport(pfitems) == pfTree('Export, [pfitems])

(DEFUN |pfExport| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Export| (LIST |pfitems|)))))

;-- Local       := (Items: [Typed])

;pfLocal(pfitems) == pfTree('Local, [pfitems])

(DEFUN |pfLocal| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Local| (LIST |pfitems|)))))

;-- Free        := (Items: [Typed])

;pfFree(pfitems) == pfTree('Free, [pfitems])

(DEFUN |pfFree| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Free| (LIST |pfitems|)))))

;-- Import      := (Items: [QualType])

;pfImport(pfitems) == pfTree('Import, [pfitems])

(DEFUN |pfImport| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Import| (LIST |pfitems|)))))

;-- Inline      := (Items: [QualType])

;pfInline(pfitems) == pfTree('Inline, [pfitems])

(DEFUN |pfInline| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Inline| (LIST |pfitems|)))))

;-- QualType    := (Type: Type, Qual: ? Type)

;pfQualType(pftype, pfqual) == pfTree('QualType, [pftype, pfqual])

(DEFUN |pfQualType| (|pftype| |pfqual|)
  (PROG () (RETURN (|pfTree| '|QualType| (LIST |pftype| |pfqual|)))))

;pfSuch(x,y)== pfInfApplication(pfId "|",x,y)

(DEFUN |pfSuch| (|x| |y|)
  (PROG () (RETURN (|pfInfApplication| (|pfId| '|\||) |x| |y|))))

;pfTaggedToTyped x==
;  rt:=if pfTagged? x then pfTaggedExpr x else pfNothing()
;  form:= if pfTagged? x then pfTaggedTag x else x
;  not pfId? form =>
;      a:=pfId GENSYM()
;      pfTyped(pfSuch(a,
;           pfInfApplication (pfId "=", a,form)),rt)
;  pfTyped(form,rt)

(DEFUN |pfTaggedToTyped| (|x|)
  (PROG (|a| |form| |rt|)
    (RETURN
      (PROGN
        (SETQ |rt|
              (COND
                ((|pfTagged?| |x|) (|pfTaggedExpr| |x|))
                ('T (|pfNothing|))))
        (SETQ |form|
              (COND ((|pfTagged?| |x|) (|pfTaggedTag| |x|)) ('T |x|)))
        (COND
          ((NULL (|pfId?| |form|))
           (PROGN
             (SETQ |a| (|pfId| (GENSYM)))
             (|pfTyped|
                 (|pfSuch| |a|
                     (|pfInfApplication| (|pfId| '=) |a| |form|))
                 |rt|)))
          ('T (|pfTyped| |form| |rt|)))))))

;pfTaggedToTyped1 x==
;    pfCollect1? x => pfCollectVariable1 x
;    pfDefinition? x => pfTyped(x,pfNothing())
;    pfTaggedToTyped x

(DEFUN |pfTaggedToTyped1| (|x|)
  (PROG ()
    (RETURN
      (COND
        ((|pfCollect1?| |x|) (|pfCollectVariable1| |x|))
        ((|pfDefinition?| |x|) (|pfTyped| |x| (|pfNothing|)))
        ('T (|pfTaggedToTyped| |x|))))))

;pfCollectVariable1 x==
;      a := pfApplicationArg x
;      var:=first pf0TupleParts a
;      id:=pfTaggedToTyped var
;      pfTyped(pfSuch(pfTypedId id,CADR pf0TupleParts a),
;              pfTypedType id)

(DEFUN |pfCollectVariable1| (|x|)
  (PROG (|id| |var| |a|)
    (RETURN
      (PROGN
        (SETQ |a| (|pfApplicationArg| |x|))
        (SETQ |var| (CAR (|pf0TupleParts| |a|)))
        (SETQ |id| (|pfTaggedToTyped| |var|))
        (|pfTyped|
            (|pfSuch| (|pfTypedId| |id|) (CADR (|pf0TupleParts| |a|)))
            (|pfTypedType| |id|))))))

;pfPushBody(t,args,body)==
;        if null args
;        then  body
;        else if null rest args
;              then  pfLambda(first args,t,body)
;              else
;                 pfLambda(first args,pfNothing(),
;                     pfPushBody(t,rest args,body))

(DEFUN |pfPushBody| (|t| |args| |body|)
  (PROG ()
    (RETURN
      (COND
        ((NULL |args|) |body|)
        ((NULL (CDR |args|)) (|pfLambda| (CAR |args|) |t| |body|))
        ('T
         (|pfLambda| (CAR |args|) (|pfNothing|)
             (|pfPushBody| |t| (CDR |args|) |body|)))))))

;pfCheckItOut x ==
;  rt:=if pfTagged? x then pfTaggedExpr x else pfNothing()
;  form:= if pfTagged? x then pfTaggedTag x else x
;  pfId? form => [pfListOf [pfTyped(form,rt)],nil,rt]
;  pfCollect1? form =>
;                [pfListOf [pfCollectVariable1 form],nil,rt]
;  pfTuple? form =>
;       [pfListOf [pfTaggedToTyped i for i in pf0TupleParts form],nil,rt]
;  pfDefinition? form =>
;       [pfListOf [pfTyped(form,pfNothing())],nil,rt]
;  pfApplication? form =>
;          ls:=pfFlattenApp form
;          op:= pfTaggedToTyped1 first ls
;          args:=[pfTransformArg i for i in rest ls]
;          [pfListOf [op],args,rt]
;  npTrapForm form

(DEFUN |pfCheckItOut| (|x|)
  (PROG (|args| |op| |ls| |form| |rt|)
    (RETURN
      (PROGN
        (SETQ |rt|
              (COND
                ((|pfTagged?| |x|) (|pfTaggedExpr| |x|))
                ('T (|pfNothing|))))
        (SETQ |form|
              (COND ((|pfTagged?| |x|) (|pfTaggedTag| |x|)) ('T |x|)))
        (COND
          ((|pfId?| |form|)
           (LIST (|pfListOf| (LIST (|pfTyped| |form| |rt|))) NIL |rt|))
          ((|pfCollect1?| |form|)
           (LIST (|pfListOf| (LIST (|pfCollectVariable1| |form|))) NIL
                 |rt|))
          ((|pfTuple?| |form|)
           (LIST (|pfListOf|
                     ((LAMBDA (|bfVar#6| |bfVar#5| |i|)
                        (LOOP
                          (COND
                            ((OR (ATOM |bfVar#5|)
                                 (PROGN
                                   (SETQ |i| (CAR |bfVar#5|))
                                   NIL))
                             (RETURN (NREVERSE |bfVar#6|)))
                            ('T
                             (SETQ |bfVar#6|
                                   (CONS (|pfTaggedToTyped| |i|)
                                    |bfVar#6|))))
                          (SETQ |bfVar#5| (CDR |bfVar#5|))))
                      NIL (|pf0TupleParts| |form|) NIL))
                 NIL |rt|))
          ((|pfDefinition?| |form|)
           (LIST (|pfListOf| (LIST (|pfTyped| |form| (|pfNothing|))))
                 NIL |rt|))
          ((|pfApplication?| |form|)
           (PROGN
             (SETQ |ls| (|pfFlattenApp| |form|))
             (SETQ |op| (|pfTaggedToTyped1| (CAR |ls|)))
             (SETQ |args|
                   ((LAMBDA (|bfVar#8| |bfVar#7| |i|)
                      (LOOP
                        (COND
                          ((OR (ATOM |bfVar#7|)
                               (PROGN (SETQ |i| (CAR |bfVar#7|)) NIL))
                           (RETURN (NREVERSE |bfVar#8|)))
                          ('T
                           (SETQ |bfVar#8|
                                 (CONS (|pfTransformArg| |i|)
                                       |bfVar#8|))))
                        (SETQ |bfVar#7| (CDR |bfVar#7|))))
                    NIL (CDR |ls|) NIL))
             (LIST (|pfListOf| (LIST |op|)) |args| |rt|)))
          ('T (|npTrapForm| |form|)))))))

;pfCollect1? x==
;        pfApplication? x =>
;              a:=pfApplicationOp x
;              pfId? a => pfIdSymbol a = "|"
;              false
;        false

(DEFUN |pfCollect1?| (|x|)
  (PROG (|a|)
    (RETURN
      (COND
        ((|pfApplication?| |x|)
         (PROGN
           (SETQ |a| (|pfApplicationOp| |x|))
           (COND
             ((|pfId?| |a|) (EQ (|pfIdSymbol| |a|) '|\||))
             ('T NIL))))
        ('T NIL)))))

;pfTransformArg  args==
;          argl:= if pfTuple? args then pf0TupleParts args else [args]
;          pfListOf [pfTaggedToTyped1 i for i in argl]

(DEFUN |pfTransformArg| (|args|)
  (PROG (|argl|)
    (RETURN
      (PROGN
        (SETQ |argl|
              (COND
                ((|pfTuple?| |args|) (|pf0TupleParts| |args|))
                ('T (LIST |args|))))
        (|pfListOf|
            ((LAMBDA (|bfVar#10| |bfVar#9| |i|)
               (LOOP
                 (COND
                   ((OR (ATOM |bfVar#9|)
                        (PROGN (SETQ |i| (CAR |bfVar#9|)) NIL))
                    (RETURN (NREVERSE |bfVar#10|)))
                   ('T
                    (SETQ |bfVar#10|
                          (CONS (|pfTaggedToTyped1| |i|) |bfVar#10|))))
                 (SETQ |bfVar#9| (CDR |bfVar#9|))))
             NIL |argl| NIL))))))

;pfCheckMacroOut form ==
;  pfId? form => [form,nil]
;  pfApplication? form =>
;          ls:=pfFlattenApp form
;          op:= pfCheckId first ls
;          args:=[pfCheckArg i for i in rest ls]
;          [op,args]
;  npTrapForm form

(DEFUN |pfCheckMacroOut| (|form|)
  (PROG (|args| |op| |ls|)
    (RETURN
      (COND
        ((|pfId?| |form|) (LIST |form| NIL))
        ((|pfApplication?| |form|)
         (PROGN
           (SETQ |ls| (|pfFlattenApp| |form|))
           (SETQ |op| (|pfCheckId| (CAR |ls|)))
           (SETQ |args|
                 ((LAMBDA (|bfVar#12| |bfVar#11| |i|)
                    (LOOP
                      (COND
                        ((OR (ATOM |bfVar#11|)
                             (PROGN (SETQ |i| (CAR |bfVar#11|)) NIL))
                         (RETURN (NREVERSE |bfVar#12|)))
                        ('T
                         (SETQ |bfVar#12|
                               (CONS (|pfCheckArg| |i|) |bfVar#12|))))
                      (SETQ |bfVar#11| (CDR |bfVar#11|))))
                  NIL (CDR |ls|) NIL))
           (LIST |op| |args|)))
        ('T (|npTrapForm| |form|))))))

;pfCheckArg args==
;          argl:= if pfTuple? args then pf0TupleParts args else [args]
;          pfListOf [pfCheckId i for i in argl]

(DEFUN |pfCheckArg| (|args|)
  (PROG (|argl|)
    (RETURN
      (PROGN
        (SETQ |argl|
              (COND
                ((|pfTuple?| |args|) (|pf0TupleParts| |args|))
                ('T (LIST |args|))))
        (|pfListOf|
            ((LAMBDA (|bfVar#14| |bfVar#13| |i|)
               (LOOP
                 (COND
                   ((OR (ATOM |bfVar#13|)
                        (PROGN (SETQ |i| (CAR |bfVar#13|)) NIL))
                    (RETURN (NREVERSE |bfVar#14|)))
                   ('T
                    (SETQ |bfVar#14|
                          (CONS (|pfCheckId| |i|) |bfVar#14|))))
                 (SETQ |bfVar#13| (CDR |bfVar#13|))))
             NIL |argl| NIL))))))

;pfCheckId form==   if not pfId? form then npTrapForm(form) else form

(DEFUN |pfCheckId| (|form|)
  (PROG ()
    (RETURN
      (COND
        ((NULL (|pfId?| |form|)) (|npTrapForm| |form|))
        ('T |form|)))))

;pfPushMacroBody(args,body)==
;    null args =>   body
;    pfMLambda(first args,pfPushMacroBody(rest args,body))

(DEFUN |pfPushMacroBody| (|args| |body|)
  (PROG ()
    (RETURN
      (COND
        ((NULL |args|) |body|)
        ('T
         (|pfMLambda| (CAR |args|)
             (|pfPushMacroBody| (CDR |args|) |body|)))))))

;pfFlattenApp x==
;   pfApplication? x=>
;             pfCollect1? x =>[ x ]
;             append (pfFlattenApp pfApplicationOp x,
;                        pfFlattenApp pfApplicationArg x)
;   [x]

(DEFUN |pfFlattenApp| (|x|)
  (PROG ()
    (RETURN
      (COND
        ((|pfApplication?| |x|)
         (COND
           ((|pfCollect1?| |x|) (LIST |x|))
           ('T
            (APPEND (|pfFlattenApp| (|pfApplicationOp| |x|))
                    (|pfFlattenApp| (|pfApplicationArg| |x|))))))
        ('T (LIST |x|))))))

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
