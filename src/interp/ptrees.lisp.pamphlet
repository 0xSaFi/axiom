\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp ptrees.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=
(in-package "BOOT")

;pfLeafPosition form == tokPosn form

(DEFUN |pfLeafPosition| (|form|)
  (PROG () (RETURN (|tokPosn| |form|))))

;--% LEAVES

;--% TREES
;-- parser interface functions
;-- these are potential sources of trouble in macro expansion
;
;-- the comment is attached to all signatutres
;pfWDec(doc,name)   == [pfWDeclare(i,doc) for i in pfParts name]

(DEFUN |pfWDec| (|doc| |name|)
  (PROG ()
    (RETURN
      ((LAMBDA (|bfVar#2| |bfVar#1| |i|)
         (LOOP
           (COND
             ((OR (ATOM |bfVar#1|)
                  (PROGN (SETQ |i| (CAR |bfVar#1|)) NIL))
              (RETURN (NREVERSE |bfVar#2|)))
             ('T
              (SETQ |bfVar#2|
                    (CONS (|pfWDeclare| |i| |doc|) |bfVar#2|))))
           (SETQ |bfVar#1| (CDR |bfVar#1|))))
       NIL (|pfParts| |name|) NIL))))

;pfLp(iterators,body)==
;       pfLoop pfListOf [:iterators,pfDo body]

(DEFUN |pfLp| (|iterators| |body|)
  (PROG ()
    (RETURN
      (|pfLoop|
          (|pfListOf| (APPEND |iterators| (CONS (|pfDo| |body|) NIL)))))))

;pfLoop1 body == pfLoop pfListOf [pfDo body]

(DEFUN |pfLoop1| (|body|)
  (PROG () (RETURN (|pfLoop| (|pfListOf| (LIST (|pfDo| |body|)))))))

;--The rest have been generated from ABCUT INPUT
;-- 1/31/89
;
;
;--              Add         / Application  / Assign /
;--              Coerceto    / Collect      / ComDefinition  / DeclPart /
;--              Exit        / Export       / Free /
;--              Fromdom     / Id           / If            / Inline /
;--              Iterate     / Lambda /
;--              Break       / Literal      / Local         / Loop   /
;--              MLambda     / Pretend      / Restrict    / Return /
;--              Sequence    / Tagged       / Tuple         / Typing /
;--              Where       / With

;pfExpr? pf ==
;     pfAdd? pf or _
;     pfApplication? pf or _
;     pfAssign? pf or _
;     pfCoerceto? pf or _
;     pfCollect? pf or _
;     pfComDefinition? pf or _
;     pfDeclPart? pf or _
;     pfExit? pf or _
;     pfExport? pf or _
;     pfFree? pf or _
;     pfFromdom? pf or _
;     pfId? pf or _
;     pfIf? pf or _
;     pfInline? pf or _
;     pfIterate? pf or _
;     pfLambda? pf or _
;     pfBreak? pf or _
;     pfLiteral? pf or _
;     pfLocal? pf or _
;     pfLoop? pf or _
;     pfMLambda? pf or _
;     pfPretend? pf or _
;     pfRestrict? pf or _
;     pfReturn? pf or _
;     pfSequence? pf or _
;     pfTagged? pf or _
;     pfTuple? pf or _
;     pfTyping? pf or _
;     pfWhere? pf or _
;     pfWith? pf

;-- WDeclare    := (Signature: Typed, Doc: ? Document)

;pfWDeclare(pfsignature, pfdoc) == pfTree('WDeclare, [pfsignature, pfdoc])

(DEFUN |pfWDeclare| (|pfsignature| |pfdoc|)
  (PROG ()
    (RETURN (|pfTree| '|WDeclare| (LIST |pfsignature| |pfdoc|)))))

;-- MLambda     := (Args: [Id], Body: Expr)

;pfMLambda(pfargs, pfbody) == pfTree('MLambda, [pfargs, pfbody])

(DEFUN |pfMLambda| (|pfargs| |pfbody|)
  (PROG () (RETURN (|pfTree| '|MLambda| (LIST |pfargs| |pfbody|)))))

;pfMLambdaArgs pf == CADR pf       -- was ==>

(DEFUN |pfMLambdaArgs| (|pf|) (PROG () (RETURN (CADR |pf|))))

;pfMLambdaBody pf == CADDR pf       -- was ==>

(DEFUN |pfMLambdaBody| (|pf|) (PROG () (RETURN (CADDR |pf|))))

;pf0MLambdaArgs pf == pfParts pfMLambdaArgs pf

(DEFUN |pf0MLambdaArgs| (|pf|)
  (PROG () (RETURN (|pfParts| (|pfMLambdaArgs| |pf|)))))

;-- Loop        := (Iterators: [Iterator])

;pfLoop(pfiterators) == pfTree('Loop, [pfiterators])

(DEFUN |pfLoop| (|pfiterators|)
  (PROG () (RETURN (|pfTree| '|Loop| (LIST |pfiterators|)))))

;-- Collect     := (Body: Expr, Iterators: [Iterator])

;pfCollect(pfbody, pfiterators) == pfTree('Collect, [pfbody, pfiterators])

(DEFUN |pfCollect| (|pfbody| |pfiterators|)
  (PROG ()
    (RETURN (|pfTree| '|Collect| (LIST |pfbody| |pfiterators|)))))

;-- Suchthat    := (Cond: Expr)

;pfSuchthat(pfcond) == pfTree('Suchthat, [pfcond])

(DEFUN |pfSuchthat| (|pfcond|)
  (PROG () (RETURN (|pfTree| '|Suchthat| (LIST |pfcond|)))))

;-- Do          := (Body: Expr)

;pfDo(pfbody) == pfTree('Do, [pfbody])

(DEFUN |pfDo| (|pfbody|)
  (PROG () (RETURN (|pfTree| '|Do| (LIST |pfbody|)))))

;-- Macro       := (Lhs:  Id,     Rhs: ExprorNot)

;pfMacro(pflhs, pfrhs) == pfTree('Macro, [pflhs, pfrhs])

(DEFUN |pfMacro| (|pflhs| |pfrhs|)
  (PROG () (RETURN (|pfTree| '|Macro| (LIST |pflhs| |pfrhs|)))))

;pfMacroLhs pf == CADR pf       -- was ==>

(DEFUN |pfMacroLhs| (|pf|) (PROG () (RETURN (CADR |pf|))))

;pfMacroRhs pf == CADDR pf       -- was ==>

(DEFUN |pfMacroRhs| (|pf|) (PROG () (RETURN (CADDR |pf|))))

;-- Assign      := (LhsItems:  [AssLhs], Rhs:  Expr)
;
;pfAssign(pflhsitems, pfrhs) == pfTree('Assign, [pflhsitems, pfrhs])

(DEFUN |pfAssign| (|pflhsitems| |pfrhs|)
  (PROG () (RETURN (|pfTree| '|Assign| (LIST |pflhsitems| |pfrhs|)))))

;-- Typing      := (Items: [Typed])

;pfTyping(pfitems) == pfTree('Typing, [pfitems])

(DEFUN |pfTyping| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Typing| (LIST |pfitems|)))))

;-- Local       := (Items: [Typed])

;pfLocal(pfitems) == pfTree('Local, [pfitems])

(DEFUN |pfLocal| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Local| (LIST |pfitems|)))))

;-- Import      := (Items: [QualType])

;pfImport(pfitems) == pfTree('Import, [pfitems])

(DEFUN |pfImport| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Import| (LIST |pfitems|)))))

;pfCheckMacroOut form ==
;  pfId? form => [form,nil]
;  pfApplication? form =>
;          ls:=pfFlattenApp form
;          op:= pfCheckId first ls
;          args:=[pfCheckArg i for i in rest ls]
;          [op,args]
;  npTrapForm form

(DEFUN |pfCheckMacroOut| (|form|)
  (PROG (|args| |op| |ls|)
    (RETURN
      (COND
        ((|pfId?| |form|) (LIST |form| NIL))
        ((|pfApplication?| |form|)
         (PROGN
           (SETQ |ls| (|pfFlattenApp| |form|))
           (SETQ |op| (|pfCheckId| (CAR |ls|)))
           (SETQ |args|
                 ((LAMBDA (|bfVar#12| |bfVar#11| |i|)
                    (LOOP
                      (COND
                        ((OR (ATOM |bfVar#11|)
                             (PROGN (SETQ |i| (CAR |bfVar#11|)) NIL))
                         (RETURN (NREVERSE |bfVar#12|)))
                        ('T
                         (SETQ |bfVar#12|
                               (CONS (|pfCheckArg| |i|) |bfVar#12|))))
                      (SETQ |bfVar#11| (CDR |bfVar#11|))))
                  NIL (CDR |ls|) NIL))
           (LIST |op| |args|)))
        ('T (|npTrapForm| |form|))))))

;pfCheckArg args==
;          argl:= if pfTuple? args then pf0TupleParts args else [args]
;          pfListOf [pfCheckId i for i in argl]

(DEFUN |pfCheckArg| (|args|)
  (PROG (|argl|)
    (RETURN
      (PROGN
        (SETQ |argl|
              (COND
                ((|pfTuple?| |args|) (|pf0TupleParts| |args|))
                ('T (LIST |args|))))
        (|pfListOf|
            ((LAMBDA (|bfVar#14| |bfVar#13| |i|)
               (LOOP
                 (COND
                   ((OR (ATOM |bfVar#13|)
                        (PROGN (SETQ |i| (CAR |bfVar#13|)) NIL))
                    (RETURN (NREVERSE |bfVar#14|)))
                   ('T
                    (SETQ |bfVar#14|
                          (CONS (|pfCheckId| |i|) |bfVar#14|))))
                 (SETQ |bfVar#13| (CDR |bfVar#13|))))
             NIL |argl| NIL))))))

;pfCheckId form==   if not pfId? form then npTrapForm(form) else form

(DEFUN |pfCheckId| (|form|)
  (PROG ()
    (RETURN
      (COND
        ((NULL (|pfId?| |form|)) (|npTrapForm| |form|))
        ('T |form|)))))

;pfPushMacroBody(args,body)==
;    null args =>   body
;    pfMLambda(first args,pfPushMacroBody(rest args,body))

(DEFUN |pfPushMacroBody| (|args| |body|)
  (PROG ()
    (RETURN
      (COND
        ((NULL |args|) |body|)
        ('T
         (|pfMLambda| (CAR |args|)
             (|pfPushMacroBody| (CDR |args|) |body|)))))))

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
