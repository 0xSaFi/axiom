\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp ptrees.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=
(in-package "BOOT")

;pfLeafPosition form == tokPosn form

(DEFUN |pfLeafPosition| (|form|)
  (PROG () (RETURN (|tokPosn| |form|))))

;--% LEAVES

;--% TREES
;-- parser interface functions
;-- these are potential sources of trouble in macro expansion
;
;-- the comment is attached to all signatutres
;pfWDec(doc,name)   == [pfWDeclare(i,doc) for i in pfParts name]

(DEFUN |pfWDec| (|doc| |name|)
  (PROG ()
    (RETURN
      ((LAMBDA (|bfVar#2| |bfVar#1| |i|)
         (LOOP
           (COND
             ((OR (ATOM |bfVar#1|)
                  (PROGN (SETQ |i| (CAR |bfVar#1|)) NIL))
              (RETURN (NREVERSE |bfVar#2|)))
             ('T
              (SETQ |bfVar#2|
                    (CONS (|pfWDeclare| |i| |doc|) |bfVar#2|))))
           (SETQ |bfVar#1| (CDR |bfVar#1|))))
       NIL (|pfParts| |name|) NIL))))

;pfLp(iterators,body)==
;       pfLoop pfListOf [:iterators,pfDo body]

(DEFUN |pfLp| (|iterators| |body|)
  (PROG ()
    (RETURN
      (|pfLoop|
          (|pfListOf| (APPEND |iterators| (CONS (|pfDo| |body|) NIL)))))))

;pfLoop1 body == pfLoop pfListOf [pfDo body]

(DEFUN |pfLoop1| (|body|)
  (PROG () (RETURN (|pfLoop| (|pfListOf| (LIST (|pfDo| |body|)))))))

;pfReturnNoName(value)==pfReturn(value,pfNothing())

(DEFUN |pfReturnNoName| (|value|)
  (PROG () (RETURN (|pfReturn| |value| (|pfNothing|)))))

;pfSpread(l,t)==  [pfTyped(i,t) for i in l]

(DEFUN |pfSpread| (|l| |t|)
  (PROG ()
    (RETURN
      ((LAMBDA (|bfVar#4| |bfVar#3| |i|)
         (LOOP
           (COND
             ((OR (ATOM |bfVar#3|)
                  (PROGN (SETQ |i| (CAR |bfVar#3|)) NIL))
              (RETURN (NREVERSE |bfVar#4|)))
             ('T (SETQ |bfVar#4| (CONS (|pfTyped| |i| |t|) |bfVar#4|))))
           (SETQ |bfVar#3| (CDR |bfVar#3|))))
       NIL |l| NIL))))

;--The rest have been generated from ABCUT INPUT
;-- 1/31/89
;
;
;--              Add         / Application  / Assign /
;--              Coerceto    / Collect      / ComDefinition  / DeclPart /
;--              Exit        / Export       / Free /
;--              Fromdom     / Id           / If            / Inline /
;--              Iterate     / Lambda /
;--              Break       / Literal      / Local         / Loop   /
;--              MLambda     / Pretend      / Restrict    / Return /
;--              Sequence    / Tagged       / Tuple         / Typing /
;--              Where       / With

;pfExpr? pf ==
;     pfAdd? pf or _
;     pfApplication? pf or _
;     pfAssign? pf or _
;     pfCoerceto? pf or _
;     pfCollect? pf or _
;     pfComDefinition? pf or _
;     pfDeclPart? pf or _
;     pfExit? pf or _
;     pfExport? pf or _
;     pfFree? pf or _
;     pfFromdom? pf or _
;     pfId? pf or _
;     pfIf? pf or _
;     pfInline? pf or _
;     pfIterate? pf or _
;     pfLambda? pf or _
;     pfBreak? pf or _
;     pfLiteral? pf or _
;     pfLocal? pf or _
;     pfLoop? pf or _
;     pfMLambda? pf or _
;     pfPretend? pf or _
;     pfRestrict? pf or _
;     pfReturn? pf or _
;     pfSequence? pf or _
;     pfTagged? pf or _
;     pfTuple? pf or _
;     pfTyping? pf or _
;     pfWhere? pf or _
;     pfWith? pf

;-- WDeclare    := (Signature: Typed, Doc: ? Document)

;pfWDeclare(pfsignature, pfdoc) == pfTree('WDeclare, [pfsignature, pfdoc])

(DEFUN |pfWDeclare| (|pfsignature| |pfdoc|)
  (PROG ()
    (RETURN (|pfTree| '|WDeclare| (LIST |pfsignature| |pfdoc|)))))

;-- Tagged      := (Tag:  Expr, Expr:   Expr)

;pfTagged(pftag, pfexpr) == pfTree('Tagged, [pftag, pfexpr])

(DEFUN |pfTagged| (|pftag| |pfexpr|)
  (PROG () (RETURN (|pfTree| '|Tagged| (LIST |pftag| |pfexpr|)))))

;-- Pretend     := (Expr: Expr, Type:   Type)

;pfPretend(pfexpr, pftype) == pfTree('Pretend, [pfexpr, pftype])

(DEFUN |pfPretend| (|pfexpr| |pftype|)
  (PROG () (RETURN (|pfTree| '|Pretend| (LIST |pfexpr| |pftype|)))))


;-- Restrict    := (Expr: Expr, Type:   Type)

;pfRestrict(pfexpr, pftype) == pfTree('Restrict, [pfexpr, pftype])

(DEFUN |pfRestrict| (|pfexpr| |pftype|)
  (PROG () (RETURN (|pfTree| '|Restrict| (LIST |pfexpr| |pftype|)))))

;pfRetractTo(pfexpr, pftype) == pfTree('RetractTo, [pfexpr, pftype])

(DEFUN |pfRetractTo| (|pfexpr| |pftype|)
  (PROG () (RETURN (|pfTree| '|RetractTo| (LIST |pfexpr| |pftype|)))))

;-- Coerceto    := (Expr: Expr, Type:   Type)

;pfCoerceto(pfexpr, pftype) == pfTree('Coerceto, [pfexpr, pftype])

(DEFUN |pfCoerceto| (|pfexpr| |pftype|)
  (PROG () (RETURN (|pfTree| '|Coerceto| (LIST |pfexpr| |pftype|)))))

;pfFix pf== pfApplication(pfId "Y",pf)

(DEFUN |pfFix| (|pf|)
  (PROG () (RETURN (|pfApplication| (|pfId| 'Y) |pf|))))

;-- MLambda     := (Args: [Id], Body: Expr)

;pfMLambda(pfargs, pfbody) == pfTree('MLambda, [pfargs, pfbody])

(DEFUN |pfMLambda| (|pfargs| |pfbody|)
  (PROG () (RETURN (|pfTree| '|MLambda| (LIST |pfargs| |pfbody|)))))

;pfMLambdaArgs pf == CADR pf       -- was ==>

(DEFUN |pfMLambdaArgs| (|pf|) (PROG () (RETURN (CADR |pf|))))

;pfMLambdaBody pf == CADDR pf       -- was ==>

(DEFUN |pfMLambdaBody| (|pf|) (PROG () (RETURN (CADDR |pf|))))

;pf0MLambdaArgs pf == pfParts pfMLambdaArgs pf

(DEFUN |pf0MLambdaArgs| (|pf|)
  (PROG () (RETURN (|pfParts| (|pfMLambdaArgs| |pf|)))))

;-- Where       := (Context: [DeclPart], Expr: Expr)

;pfWhere(pfcontext, pfexpr) == pfTree('Where, [pfcontext, pfexpr])

(DEFUN |pfWhere| (|pfcontext| |pfexpr|)
  (PROG () (RETURN (|pfTree| '|Where| (LIST |pfcontext| |pfexpr|)))))

;-- Loop        := (Iterators: [Iterator])

;pfLoop(pfiterators) == pfTree('Loop, [pfiterators])

(DEFUN |pfLoop| (|pfiterators|)
  (PROG () (RETURN (|pfTree| '|Loop| (LIST |pfiterators|)))))

;-- Collect     := (Body: Expr, Iterators: [Iterator])

;pfCollect(pfbody, pfiterators) == pfTree('Collect, [pfbody, pfiterators])

(DEFUN |pfCollect| (|pfbody| |pfiterators|)
  (PROG ()
    (RETURN (|pfTree| '|Collect| (LIST |pfbody| |pfiterators|)))))

;-- Forin       := (Lhs: [AssLhs], Whole: Expr)

;pfForin(pflhs, pfwhole) == pfTree('Forin, [pflhs, pfwhole])

(DEFUN |pfForin| (|pflhs| |pfwhole|)
  (PROG () (RETURN (|pfTree| '|Forin| (LIST |pflhs| |pfwhole|)))))

;-- While       := (Cond: Expr)

;pfWhile(pfcond) == pfTree('While, [pfcond])

(DEFUN |pfWhile| (|pfcond|)
  (PROG () (RETURN (|pfTree| '|While| (LIST |pfcond|)))))

;-- Suchthat    := (Cond: Expr)

;pfSuchthat(pfcond) == pfTree('Suchthat, [pfcond])

(DEFUN |pfSuchthat| (|pfcond|)
  (PROG () (RETURN (|pfTree| '|Suchthat| (LIST |pfcond|)))))

;-- Do          := (Body: Expr)

;pfDo(pfbody) == pfTree('Do, [pfbody])

(DEFUN |pfDo| (|pfbody|)
  (PROG () (RETURN (|pfTree| '|Do| (LIST |pfbody|)))))

;-- Iterate     := (From: ? Id)

;pfIterate(pffrom) == pfTree('Iterate, [pffrom])

(DEFUN |pfIterate| (|pffrom|)
  (PROG () (RETURN (|pfTree| '|Iterate| (LIST |pffrom|)))))

;-- Break       := (From: ? Id)

;pfBreak(pffrom) == pfTree('Break, [pffrom])

(DEFUN |pfBreak| (|pffrom|)
  (PROG () (RETURN (|pfTree| '|Break| (LIST |pffrom|)))))

;-- Return      := (Expr: ? Expr, From: ? Id)

;pfReturn(pfexpr, pffrom) == pfTree('Return, [pfexpr, pffrom])

(DEFUN |pfReturn| (|pfexpr| |pffrom|)
  (PROG () (RETURN (|pfTree| '|Return| (LIST |pfexpr| |pffrom|)))))

;-- Exit        := (Cond: ? Expr, Expr: ? Expr)

;pfExit(pfcond, pfexpr) == pfTree('Exit, [pfcond, pfexpr])

(DEFUN |pfExit| (|pfcond| |pfexpr|)
  (PROG () (RETURN (|pfTree| '|Exit| (LIST |pfcond| |pfexpr|)))))

;-- Macro       := (Lhs:  Id,     Rhs: ExprorNot)

;pfMacro(pflhs, pfrhs) == pfTree('Macro, [pflhs, pfrhs])

(DEFUN |pfMacro| (|pflhs| |pfrhs|)
  (PROG () (RETURN (|pfTree| '|Macro| (LIST |pflhs| |pfrhs|)))))

;pfMacroLhs pf == CADR pf       -- was ==>

(DEFUN |pfMacroLhs| (|pf|) (PROG () (RETURN (CADR |pf|))))

;pfMacroRhs pf == CADDR pf       -- was ==>

(DEFUN |pfMacroRhs| (|pf|) (PROG () (RETURN (CADDR |pf|))))

;-- Assign      := (LhsItems:  [AssLhs], Rhs:  Expr)
;
;pfAssign(pflhsitems, pfrhs) == pfTree('Assign, [pflhsitems, pfrhs])

(DEFUN |pfAssign| (|pflhsitems| |pfrhs|)
  (PROG () (RETURN (|pfTree| '|Assign| (LIST |pflhsitems| |pfrhs|)))))

;-- Typing      := (Items: [Typed])

;pfTyping(pfitems) == pfTree('Typing, [pfitems])

(DEFUN |pfTyping| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Typing| (LIST |pfitems|)))))

;-- Export       := (Items: [Typed])

;pfExport(pfitems) == pfTree('Export, [pfitems])

(DEFUN |pfExport| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Export| (LIST |pfitems|)))))

;-- Local       := (Items: [Typed])

;pfLocal(pfitems) == pfTree('Local, [pfitems])

(DEFUN |pfLocal| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Local| (LIST |pfitems|)))))

;-- Free        := (Items: [Typed])

;pfFree(pfitems) == pfTree('Free, [pfitems])

(DEFUN |pfFree| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Free| (LIST |pfitems|)))))

;-- Import      := (Items: [QualType])

;pfImport(pfitems) == pfTree('Import, [pfitems])

(DEFUN |pfImport| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Import| (LIST |pfitems|)))))

;-- Inline      := (Items: [QualType])

;pfInline(pfitems) == pfTree('Inline, [pfitems])

(DEFUN |pfInline| (|pfitems|)
  (PROG () (RETURN (|pfTree| '|Inline| (LIST |pfitems|)))))

;-- QualType    := (Type: Type, Qual: ? Type)

;pfQualType(pftype, pfqual) == pfTree('QualType, [pftype, pfqual])

(DEFUN |pfQualType| (|pftype| |pfqual|)
  (PROG () (RETURN (|pfTree| '|QualType| (LIST |pftype| |pfqual|)))))

;pfCheckMacroOut form ==
;  pfId? form => [form,nil]
;  pfApplication? form =>
;          ls:=pfFlattenApp form
;          op:= pfCheckId first ls
;          args:=[pfCheckArg i for i in rest ls]
;          [op,args]
;  npTrapForm form

(DEFUN |pfCheckMacroOut| (|form|)
  (PROG (|args| |op| |ls|)
    (RETURN
      (COND
        ((|pfId?| |form|) (LIST |form| NIL))
        ((|pfApplication?| |form|)
         (PROGN
           (SETQ |ls| (|pfFlattenApp| |form|))
           (SETQ |op| (|pfCheckId| (CAR |ls|)))
           (SETQ |args|
                 ((LAMBDA (|bfVar#12| |bfVar#11| |i|)
                    (LOOP
                      (COND
                        ((OR (ATOM |bfVar#11|)
                             (PROGN (SETQ |i| (CAR |bfVar#11|)) NIL))
                         (RETURN (NREVERSE |bfVar#12|)))
                        ('T
                         (SETQ |bfVar#12|
                               (CONS (|pfCheckArg| |i|) |bfVar#12|))))
                      (SETQ |bfVar#11| (CDR |bfVar#11|))))
                  NIL (CDR |ls|) NIL))
           (LIST |op| |args|)))
        ('T (|npTrapForm| |form|))))))

;pfCheckArg args==
;          argl:= if pfTuple? args then pf0TupleParts args else [args]
;          pfListOf [pfCheckId i for i in argl]

(DEFUN |pfCheckArg| (|args|)
  (PROG (|argl|)
    (RETURN
      (PROGN
        (SETQ |argl|
              (COND
                ((|pfTuple?| |args|) (|pf0TupleParts| |args|))
                ('T (LIST |args|))))
        (|pfListOf|
            ((LAMBDA (|bfVar#14| |bfVar#13| |i|)
               (LOOP
                 (COND
                   ((OR (ATOM |bfVar#13|)
                        (PROGN (SETQ |i| (CAR |bfVar#13|)) NIL))
                    (RETURN (NREVERSE |bfVar#14|)))
                   ('T
                    (SETQ |bfVar#14|
                          (CONS (|pfCheckId| |i|) |bfVar#14|))))
                 (SETQ |bfVar#13| (CDR |bfVar#13|))))
             NIL |argl| NIL))))))

;pfCheckId form==   if not pfId? form then npTrapForm(form) else form

(DEFUN |pfCheckId| (|form|)
  (PROG ()
    (RETURN
      (COND
        ((NULL (|pfId?| |form|)) (|npTrapForm| |form|))
        ('T |form|)))))

;pfPushMacroBody(args,body)==
;    null args =>   body
;    pfMLambda(first args,pfPushMacroBody(rest args,body))

(DEFUN |pfPushMacroBody| (|args| |body|)
  (PROG ()
    (RETURN
      (COND
        ((NULL |args|) |body|)
        ('T
         (|pfMLambda| (CAR |args|)
             (|pfPushMacroBody| (CDR |args|) |body|)))))))

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
