\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp pathname.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=
(IN-PACKAGE "BOOT" )

;-- This file implements the Common Lisp pathname functions for
;-- Lisp/VM.  On VM, a filename is 3-list consisting of the filename,
;-- filetype and filemode. We also UPCASE everything.
;
;-- This file also contains some other VM specific functions for
;-- dealing with files.
;
;--% Common Lisp Pathname Functions
;
;pathname? p == p=[] or PATHNAMEP p

(DEFUN |pathname?| (|p|) (OR (NULL |p|) (PATHNAMEP |p|)))

;pathname p ==
;  p = [] => p
;  PATHNAMEP p => p
;  not PAIRP p => PATHNAME p
;  if #p>2 then p:=[p.0,p.1]
;  PATHNAME APPLY(FUNCTION MAKE_-FILENAME, p)

(DEFUN |pathname| (|p|)
  (COND
    ((NULL |p|) |p|)
    ((PATHNAMEP |p|) |p|)
    ((NULL (PAIRP |p|)) (PATHNAME |p|))
    ('T
     (COND
       ((> (|#| |p|) 2)
        (SPADLET |p| (CONS (ELT |p| 0) (CONS (ELT |p| 1) NIL)))))
     (PATHNAME (APPLY #'MAKE-FILENAME |p|)))))

;namestring p == NAMESTRING pathname p

(DEFUN |namestring| (|p|) (NAMESTRING (|pathname| |p|)))

;pathnameName p == PATHNAME_-NAME pathname p

(DEFUN |pathnameName| (|p|) (PATHNAME-NAME (|pathname| |p|)))

;pathnameType p == PATHNAME_-TYPE pathname p

(DEFUN |pathnameType| (|p|) (PATHNAME-TYPE (|pathname| |p|))) 

;pathnameTypeId p == UPCASE object2Identifier pathnameType p

(DEFUN |pathnameTypeId| (|p|)
  (UPCASE (|object2Identifier| (|pathnameType| |p|))))

;pathnameDirectory p ==
;   NAMESTRING MAKE_-PATHNAME(KEYWORD'DIRECTORY,PATHNAME_-DIRECTORY pathname p)

(DEFUN |pathnameDirectory| (|p|)
  (NAMESTRING
      (MAKE-PATHNAME :DIRECTORY (PATHNAME-DIRECTORY (|pathname| |p|)))))

;deleteFile f == _$ERASE pathname f

(DEFUN |deleteFile| (|f|) 
 (declare (special $ERASE))
 ($ERASE (|pathname| |f|)))

;isExistingFile f ==
;--  p := pathname f
;  --member(p,$existingFiles) => true
;  if MAKE_-INPUT_-FILENAME f
;    then
;      --$existingFiles := [p,:$existingFiles]
;      true
;    else false

(DEFUN |isExistingFile| (|f|)
  (COND ((MAKE-INPUT-FILENAME |f|) 'T) ('T NIL)))

;--% Scratchpad II File Name Functions
;
;makePathname(name,type,dir) ==
;  -- Common Lisp version of this will have to be written
;  -- using MAKE-PATHNAME and the optional args.
;  pathname [object2String name,object2String type]

(DEFUN |makePathname| (|name| |type| |dir|)
  (declare (ignore |dir|))
  (|pathname|
      (CONS (|object2String| |name|)
            (CONS (|object2String| |type|) NIL))))

;mergePathnames(a,b) ==
;  (fn := pathnameName(a)) = '"*" => b
;  fn ^= pathnameName(b) => a
;  (ft := pathnameType(a)) = '"*" => b
;  ft ^= pathnameType(b) => a
;  (fm := pathnameDirectory(a)) = ['"*"] => b
;  a

(DEFUN |mergePathnames| (|a| |b|)
  (PROG (|fn| |ft| |fm|)
    (RETURN
      (COND
        ((BOOT-EQUAL (SPADLET |fn| (|pathnameName| |a|))
             (MAKESTRING "*"))
         |b|)
        ((NEQUAL |fn| (|pathnameName| |b|)) |a|)
        ((BOOT-EQUAL (SPADLET |ft| (|pathnameType| |a|))
             (MAKESTRING "*"))
         |b|)
        ((NEQUAL |ft| (|pathnameType| |b|)) |a|)
        ((BOOT-EQUAL (SPADLET |fm| (|pathnameDirectory| |a|))
             (CONS (MAKESTRING "*") NIL))
         |b|)
        ('T |a|)))))

;isSystemDirectory dir == EVERY(function CHAR_=,$SPADROOT,dir)

(DEFUN |isSystemDirectory| (|dir|)
  (declare (special $SPADROOT))
  (EVERY (|function| CHAR=) $SPADROOT |dir|))

;-- the next function is an improved version of the one in DEBUG LISP
;
;_/MKINFILENAM(infile) == CATCH('FILNAM, newMKINFILENAM infile)

(DEFUN /MKINFILENAM (|infile|)
  (CATCH 'FILNAM (|newMKINFILENAM| |infile|)))

;SETANDFILEQ($sourceFileTypes,'(INPUT SPAD BOOT LISP LISP370 META))

(SETANDFILEQ |$sourceFileTypes| (QUOTE (INPUT SPAD BOOT LISP LISP370 META))) 


;newMKINFILENAM(infile) ==
;  NULL infile => nil
;  file := infile := pathname infile
;  repeat
;    fn := pathnameName file
;    nfile := $FINDFILE (file,$sourceFileTypes)
;    null nfile =>
;      nfile := file
;      if fn = '"*" or fn = '"NIL" then sayKeyedMsg("S2IL0016",NIL)
;      else              sayKeyedMsg("S2IL0003",[namestring file])
;      ans := queryUserKeyedMsg("S2IL0017",NIL)
;      if (SIZE(ans) > 0) and ('")" = SUBSTRING(ans,0,1)) then n := 2
;      else n := 1
;      nfn := UPCASE STRING2ID_-N(ans,n)
;      (nfn = 0) or (nfn = 'QUIT) =>
;        sayKeyedMsg("S2IL0018",NIL)
;        THROW('FILENAM,NIL)
;      nfn = 'CREATE => return 'fromThisLoop
;      file := pathname ans
;    return 'fromThisLoop
;  if nfile then pathname nfile
;  else NIL

(DEFUN |newMKINFILENAM| (|infile|)
  (PROG (|fn| |nfile| |ans| |n| |nfn| |file|)
  (declare (special |$sourceFileTypes| $FINDFILE))
    (RETURN
      (SEQ (COND
             ((NULL |infile|) NIL)
             ('T
              (SPADLET |file| (SPADLET |infile| (|pathname| |infile|)))
              (DO () (NIL NIL)
                (SEQ (EXIT (PROGN
                             (SPADLET |fn| (|pathnameName| |file|))
                             (SPADLET |nfile|
                                      ($FINDFILE |file|
                                       |$sourceFileTypes|))
                             (COND
                               ((NULL |nfile|) (SPADLET |nfile| |file|)
                                (COND
                                  ((OR
                                    (BOOT-EQUAL |fn| (MAKESTRING "*"))
                                    (BOOT-EQUAL |fn|
                                     (MAKESTRING "NIL")))
                                   (|sayKeyedMsg| 'S2IL0016 NIL))
                                  ('T
                                   (|sayKeyedMsg| 'S2IL0003
                                    (CONS (|namestring| |file|) NIL))))
                                (SPADLET |ans|
                                         (|queryUserKeyedMsg| 'S2IL0017
                                          NIL))
                                (COND
                                  ((AND (> (SIZE |ans|) 0)
                                    (BOOT-EQUAL (MAKESTRING ")")
                                     (SUBSTRING |ans| 0 1)))
                                   (SPADLET |n| 2))
                                  ('T (SPADLET |n| 1)))
                                (SPADLET |nfn|
                                         (UPCASE
                                          (STRING2ID-N |ans| |n|)))
                                (COND
                                  ((OR (EQL |nfn| 0)
                                    (BOOT-EQUAL |nfn| 'QUIT))
                                   (|sayKeyedMsg| 'S2IL0018 NIL)
                                   (THROW 'FILENAM NIL))
                                  ((BOOT-EQUAL |nfn| 'CREATE)
                                   (RETURN '|fromThisLoop|))
                                  ('T
                                   (SPADLET |file| (|pathname| |ans|)))))
                               ('T (RETURN '|fromThisLoop|)))))))
              (COND (|nfile| (|pathname| |nfile|)) ('T NIL))))))))

;getFunctionSourceFile fun ==
;  null (f := getFunctionSourceFile1 fun) => NIL
;  if MAKE_-INPUT_-FILENAME(f) then updateSourceFiles f
;  f

(DEFUN |getFunctionSourceFile| (|fun|)
  (PROG (|f|)
    (RETURN
      (COND
        ((NULL (SPADLET |f| (|getFunctionSourceFile1| |fun|))) NIL)
        ('T
         (COND ((MAKE-INPUT-FILENAME |f|) (|updateSourceFiles| |f|)))
         |f|)))))

;getFunctionSourceFile1 fun ==
;  -- returns NIL or [fn,ft,fm]
;  (file := KDR GET(fun,'DEFLOC)) => pathname file
;  null ((fileinfo := FUNLOC fun) or
;    (fileinfo := FUNLOC unabbrev fun)) =>
;      u := bootFind fun => getFunctionSourceFile1 SETQ($FUNCTION,INTERN u)
;      NIL
;  3 = #fileinfo =>
;    [fn,ft,$FUNCTION] := fileinfo
;    newMKINFILENAM pathname [fn,ft]
;  [fn,$FUNCTION] := fileinfo
;  newMKINFILENAM pathname [fn]

(DEFUN |getFunctionSourceFile1| (|fun|)
  (PROG (|file| |fileinfo| |u| |ft| |fn|)
  (declare (special $FUNCTION))
    (RETURN
      (COND
        ((SPADLET |file| (KDR (GETL |fun| 'DEFLOC)))
         (|pathname| |file|))
        ((NULL (OR (SPADLET |fileinfo| (FUNLOC |fun|))
                   (SPADLET |fileinfo| (FUNLOC (|unabbrev| |fun|)))))
         (COND
           ((SPADLET |u| (|bootFind| |fun|))
            (|getFunctionSourceFile1| (SETQ $FUNCTION (INTERN |u|))))
           ('T NIL)))
        ((EQL 3 (|#| |fileinfo|)) (SPADLET |fn| (CAR |fileinfo|))
         (SPADLET |ft| (CADR |fileinfo|))
         (SPADLET $FUNCTION (CADDR |fileinfo|))
         (|newMKINFILENAM| (|pathname| (CONS |fn| (CONS |ft| NIL)))))
        ('T (SPADLET |fn| (CAR |fileinfo|))
         (SPADLET $FUNCTION (CADR |fileinfo|))
         (|newMKINFILENAM| (|pathname| (CONS |fn| NIL))))))))

;updateSourceFiles p ==
;  p := pathname p
;  p := pathname [pathnameName p, pathnameType p, '"*"]
;  if MAKE_-INPUT_-FILENAME p and pathnameTypeId p in '(BOOT LISP META) then
;    $sourceFiles := insert(p, $sourceFiles)
;  p

;;;     ***       |updateSourceFiles| REDEFINED

(DEFUN |updateSourceFiles| (|p|)
  (declare (special |$sourceFiles|))
  (PROGN
    (SPADLET |p| (|pathname| |p|))
    (SPADLET |p|
             (|pathname|
                 (CONS (|pathnameName| |p|)
                       (CONS (|pathnameType| |p|)
                             (CONS (MAKESTRING "*") NIL)))))
    (COND
      ((AND (MAKE-INPUT-FILENAME |p|)
            (|member| (|pathnameTypeId| |p|) '(BOOT LISP META)))
       (SPADLET |$sourceFiles| (|insert| |p| |$sourceFiles|))))
    |p|))

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
