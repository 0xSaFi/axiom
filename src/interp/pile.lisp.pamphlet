\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp pile.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=
(IN-PACKAGE "BOOT")

;-- insertpiles converts a line-list to a line-forest where
; 
;-- a line is a token-dequeue and has a column which is an integer.
;-- an A-forest is an A-tree-list
;-- an A-tree has a root which is an A, and subtrees which is an A-forest.
; 
;-- A forest with more than one tree corresponds to a Scratchpad pile
;-- structure (t1;t2;t3;...;tn), and a tree corresponds to a pile item.
;-- The ( ; and ) tokens are inserted into a >1-forest, otherwise
;-- the root of the first tree is concatenated with its forest.
;-- column t is the number of spaces before the first non-space in line t
; 
;pileColumn t==CDR tokPosn CAAR t

(DEFUN |pileColumn| (|t|)
  (PROG () (RETURN (CDR (|tokPosn| (CAAR |t|))))))

;pileComment t== EQ(tokType CAAR t,"negcomment")

(DEFUN |pileComment| (|t|)
  (PROG () (RETURN (EQ (|tokType| (CAAR |t|)) '|negcomment|))))

;pilePlusComment t== EQ(tokType CAAR t,"comment")

(DEFUN |pilePlusComment| (|t|)
  (PROG () (RETURN (EQ (|tokType| (CAAR |t|)) '|comment|))))

;-- insertpile is used by next so s is non-null
;-- bite off a line-tree, return it and the remaining line-list.
; 
;insertpile (s)==
;     if npNull s
;     then [false,0,[],s]
;     else
;       [h,t]:=[car s,cdr s]
;       if pilePlusComment h
;       then
;          [h1,t1]:=pilePlusComments s
;          a:=pileTree(-1,t1)
;          cons([pileCforest [:h1,a.2]],a.3)
;       else
;         stream:=CADAR s
;         a:=pileTree(-1,s)
;         cons([[a.2,stream]],a.3)
 
(DEFUN |insertpile| (|s|)
  (PROG (|stream| |a| |t1| |h1| |t| |h| |LETTMP#1|)
    (RETURN
      (COND
        ((|npNull| |s|) (LIST NIL 0 NIL |s|))
        ('T (SETQ |LETTMP#1| (LIST (CAR |s|) (CDR |s|)))
         (SETQ |h| (CAR |LETTMP#1|)) (SETQ |t| (CADR |LETTMP#1|))
         (COND
           ((|pilePlusComment| |h|)
            (SETQ |LETTMP#1| (|pilePlusComments| |s|))
            (SETQ |h1| (CAR |LETTMP#1|)) (SETQ |t1| (CADR |LETTMP#1|))
            (SETQ |a| (|pileTree| (- 1) |t1|))
            (CONS (LIST (|pileCforest|
                            (APPEND |h1| (CONS (ELT |a| 2) NIL))))
                  (ELT |a| 3)))
           ('T (SETQ |stream| (CADAR |s|))
            (SETQ |a| (|pileTree| (- 1) |s|))
            (CONS (LIST (LIST (ELT |a| 2) |stream|)) (ELT |a| 3)))))))))

;pilePlusComments s==
;      if npNull s
;      then [[],s]
;      else
;       [h,t]:=[car s,cdr s]
;       if pilePlusComment h
;       then
;         [h1,t1]:=pilePlusComments t
;         [cons(h,h1),t1]
;       else [[],s]
 
(DEFUN |pilePlusComments| (|s|)
  (PROG (|t1| |h1| |t| |h| |LETTMP#1|)
    (RETURN
      (COND
        ((|npNull| |s|) (LIST NIL |s|))
        ('T (SETQ |LETTMP#1| (LIST (CAR |s|) (CDR |s|)))
         (SETQ |h| (CAR |LETTMP#1|)) (SETQ |t| (CADR |LETTMP#1|))
         (COND
           ((|pilePlusComment| |h|)
            (SETQ |LETTMP#1| (|pilePlusComments| |t|))
            (SETQ |h1| (CAR |LETTMP#1|)) (SETQ |t1| (CADR |LETTMP#1|))
            (LIST (CONS |h| |h1|) |t1|))
           ('T (LIST NIL |s|))))))))

;pileTree(n,s)==
;    if npNull s
;    then [false,n,[],s]
;    else
;        [h,t]:=[car s,cdr s]
;        hh:=pileColumn CAR h
;        if hh > n
;        then pileForests(CAR h,hh,t)
;        else [false,n,[],s]
 
(DEFUN |pileTree| (|n| |s|)
  (PROG (|hh| |t| |h| |LETTMP#1|)
    (RETURN
      (COND
        ((|npNull| |s|) (LIST NIL |n| NIL |s|))
        ('T (SETQ |LETTMP#1| (LIST (CAR |s|) (CDR |s|)))
         (SETQ |h| (CAR |LETTMP#1|)) (SETQ |t| (CADR |LETTMP#1|))
         (SETQ |hh| (|pileColumn| (CAR |h|)))
         (COND
           ((< |n| |hh|) (|pileForests| (CAR |h|) |hh| |t|))
           ('T (LIST NIL |n| NIL |s|))))))))

;eqpileTree(n,s)==
;    if npNull s
;    then [false,n,[],s]
;    else
;        [h,t]:=[car s,cdr s]
;        hh:=pileColumn CAR h
;        if hh = n
;        then pileForests(CAR h,hh,t)
;        else [false,n,[],s]
 
(DEFUN |eqpileTree| (|n| |s|)
  (PROG (|hh| |t| |h| |LETTMP#1|)
    (RETURN
      (COND
        ((|npNull| |s|) (LIST NIL |n| NIL |s|))
        ('T (SETQ |LETTMP#1| (LIST (CAR |s|) (CDR |s|)))
         (SETQ |h| (CAR |LETTMP#1|)) (SETQ |t| (CADR |LETTMP#1|))
         (SETQ |hh| (|pileColumn| (CAR |h|)))
         (COND
           ((EQUAL |hh| |n|) (|pileForests| (CAR |h|) |hh| |t|))
           ('T (LIST NIL |n| NIL |s|))))))))

;pileForest(n,s)==
;     [b,hh,h,t]:= pileTree(n,s)
;     if b
;     then
;       [h1,t1]:=pileForest1(hh,t)
;       [cons(h,h1),t1]
;     else [[],s]
 
(DEFUN |pileForest| (|n| |s|)
  (PROG (|t1| |h1| |t| |h| |hh| |b| |LETTMP#1|)
    (RETURN
      (PROGN
        (SETQ |LETTMP#1| (|pileTree| |n| |s|))
        (SETQ |b| (CAR |LETTMP#1|))
        (SETQ |hh| (CADR |LETTMP#1|))
        (SETQ |h| (CADDR |LETTMP#1|))
        (SETQ |t| (CADDDR |LETTMP#1|))
        (COND
          (|b| (SETQ |LETTMP#1| (|pileForest1| |hh| |t|))
               (SETQ |h1| (CAR |LETTMP#1|))
               (SETQ |t1| (CADR |LETTMP#1|))
               (LIST (CONS |h| |h1|) |t1|))
          ('T (LIST NIL |s|)))))))

;pileForest1(n,s)==
;     [b,n1,h,t]:= eqpileTree(n,s)
;     if b
;     then
;       [h1,t1]:=pileForest1(n,t)
;       [cons(h,h1),t1]
;     else [[],s]
 
(DEFUN |pileForest1| (|n| |s|)
  (PROG (|t1| |h1| |t| |h| |n1| |b| |LETTMP#1|)
    (RETURN
      (PROGN
        (SETQ |LETTMP#1| (|eqpileTree| |n| |s|))
        (SETQ |b| (CAR |LETTMP#1|))
        (SETQ |n1| (CADR |LETTMP#1|))
        (SETQ |h| (CADDR |LETTMP#1|))
        (SETQ |t| (CADDDR |LETTMP#1|))
        (COND
          (|b| (SETQ |LETTMP#1| (|pileForest1| |n| |t|))
               (SETQ |h1| (CAR |LETTMP#1|))
               (SETQ |t1| (CADR |LETTMP#1|))
               (LIST (CONS |h| |h1|) |t1|))
          ('T (LIST NIL |s|)))))))

;pileForests(h,n,s)==
;      [h1,t1]:=pileForest(n,s)
;      if npNull h1
;      then [true,n,h,s]
;      else pileForests(pileCtree(h,h1),n,t1)
 
(DEFUN |pileForests| (|h| |n| |s|)
  (PROG (|t1| |h1| |LETTMP#1|)
    (RETURN
      (PROGN
        (SETQ |LETTMP#1| (|pileForest| |n| |s|))
        (SETQ |h1| (CAR |LETTMP#1|))
        (SETQ |t1| (CADR |LETTMP#1|))
        (COND
          ((|npNull| |h1|) (LIST T |n| |h| |s|))
          ('T (|pileForests| (|pileCtree| |h| |h1|) |n| |t1|)))))))

;pileCtree(x,y)==dqAppend(x,pileCforest y)
 
(DEFUN |pileCtree| (|x| |y|)
  (PROG () (RETURN (|dqAppend| |x| (|pileCforest| |y|)))))

;-- only enpiles forests with >=2 trees
; 
;pileCforest x==
;   if null x
;   then []
;   else if null cdr x
;        then
;           f:= car x
;           if EQ(tokPart CAAR f,"IF")
;           then enPile f
;           else f
;        else enPile separatePiles x
 
(DEFUN |pileCforest| (|x|)
  (PROG (|f|)
    (RETURN
      (COND
        ((NULL |x|) NIL)
        ((NULL (CDR |x|)) (SETQ |f| (CAR |x|))
         (COND
           ((EQ (|tokPart| (CAAR |f|)) 'IF) (|enPile| |f|))
           ('T |f|)))
        ('T (|enPile| (|separatePiles| |x|)))))))

;firstTokPosn t== tokPosn CAAR t

(DEFUN |firstTokPosn| (|t|) (PROG () (RETURN (|tokPosn| (CAAR |t|)))))

;lastTokPosn  t== tokPosn CADR t
 
(DEFUN |lastTokPosn| (|t|) (PROG () (RETURN (|tokPosn| (CADR |t|)))))

;separatePiles x==
;  if null x
;  then []
;  else if null cdr x
;       then car x
;       else
;         a:=car x
;         semicolon:=dqUnit tokConstruct("key", "BACKSET",lastTokPosn a)
;         dqConcat [a,semicolon,separatePiles cdr x]
 
(DEFUN |separatePiles| (|x|)
  (PROG (|semicolon| |a|)
    (RETURN
      (COND
        ((NULL |x|) NIL)
        ((NULL (CDR |x|)) (CAR |x|))
        ('T (SETQ |a| (CAR |x|))
         (SETQ |semicolon|
               (|dqUnit|
                   (|tokConstruct| '|key| 'BACKSET (|lastTokPosn| |a|))))
         (|dqConcat|
             (LIST |a| |semicolon| (|separatePiles| (CDR |x|)))))))))

;enPile x==
;   dqConcat [dqUnit tokConstruct("key","SETTAB",firstTokPosn x),
;             x, _
;             dqUnit tokConstruct("key","BACKTAB",lastTokPosn  x)]
 
(DEFUN |enPile| (|x|)
  (PROG ()
    (RETURN
      (|dqConcat|
          (LIST (|dqUnit|
                    (|tokConstruct| '|key| 'SETTAB
                        (|firstTokPosn| |x|)))
                |x|
                (|dqUnit|
                    (|tokConstruct| '|key| 'BACKTAB
                        (|lastTokPosn| |x|))))))))

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
