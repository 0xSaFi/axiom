\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp i-spec1.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{verbatim}
Handlers for Special Forms (1 of 2)

This file contains the functions which do type analysis and
evaluation of special functions in the interpreter.
Special functions are ones which are not defined in the algebra
code, such as assignment, construct, COLLECT and declaration.

Operators which require special handlers all have a LISP "up"
property which is the name of the special handler, which is
always the word "up" followed by the operator name.
If an operator has this "up" property the handler is called
automatically from bottomUp instead of general modemap selection.

The up handlers are usually split into two pieces, the first is
the up function itself, which performs the type analysis, and an
"eval" function, which generates (and executes, if required) the
code for the function.
The up functions always take a single argument, which is the
entire attributed tree for the operation, and return the modeSet
of the node, which is a singleton list containing the type
computed for the node.
The eval functions can take any arguments deemed necessary.
Actual evaluation is done if $genValue is true, otherwise code is
generated.
(See the function analyzeMap for other things that may affect
what is generated in these functions.)

These functions are required to do two things:
  1) do a putValue on the operator vector with the computed value
     of the node, which is a triple.  This is usually done in the
     eval functions.
  2) do a putModeSet on the operator vector with a list of the
     computed type of the node.  This is usually done in the
     up functions.

There are several special modes used in these functions:
  1) Void is the mode that should be used for all statements
     that do not otherwise return values, such as declarations,
     loops, IF-THEN's without ELSE's, etc..
  2) $NoValueMode and $ThrowAwayMode used to be used in situations
     where Void is now used, and are being phased out completely.
\end{verbatim}
\begin{chunk}{*}

(IN-PACKAGE "BOOT" )

;SETANDFILEQ($repeatLabel, NIL)

(SETANDFILEQ |$repeatLabel| NIL) 

;SETANDFILEQ($breakCount, 0)

(SETANDFILEQ |$breakCount| 0) 

;SETANDFILEQ($anonymousMapCounter, 0)

(SETANDFILEQ |$anonymousMapCounter| 0) 

;SETANDFILEQ($specialOps, '(
;  ADEF AlgExtension and case COERCE COLLECT construct Declare DEF Dollar
;   equation error free has IF is isnt iterate break LET local MDEF or
;    pretend QUOTE REDUCE REPEAT return SEQ TARGET Tuple typeOf where ))

(SETANDFILEQ |$specialOps|
    '(ADEF |AlgExtension| |and| |case| COERCE COLLECT |construct|
           |Declare| DEF |Dollar| |equation| |error| |free| |has| IF
           |is| |isnt| |iterate| |break| LET |local| MDEF |or|
           |pretend| QUOTE REDUCE REPEAT |return| SEQ TARGET |Tuple|
           |typeOf| |where|))

;--% Void stuff
;--% Handlers for Anonymous Function Definitions
;upADEF t ==
;  t isnt [.,[vars,types,.,body],pred,.] => NIL
;  -- do some checking on what we got
;  for var in vars repeat
;    if not IDENTP(var) then throwKeyedMsg("S2IS0057",[var])
;  -- unabbreviate types
;  types := [(if t then evaluateType unabbrev t else NIL) for t in types]
;  -- we do not allow partial types
;  if isPartialMode(m := first types) then throwKeyedMsg("S2IS0058",[m])
;  -- we want everything to be declared or nothing. The exception is that
;  -- we do not require a target type since we will compute one anyway.
;  if null(m) and rest types then
;    m := first rest types
;    types' := rest rest types
;  else
;    types' := rest types
;  for type in types' repeat
;    if (type and null m) or (m and null type) then
;      throwKeyedMsg("S2IS0059",NIL)
;    if isPartialMode type  then throwKeyedMsg("S2IS0058",[type])
;--  $localVars: local := nil
;--  $freeVars:  local := nil
;--  $env:       local := [[NIL]]
;  $compilingMap : local := true
;  -- if there is a predicate, merge it in with the body
;  if pred ^= true then body := ['IF,pred,body,'noMapVal]
;  tar := getTarget t
;  null m and tar is ['Mapping,.,:argTypes] and (#vars = #argTypes) =>
;    if isPartialMode tar then throwKeyedMsg("S2IS0058",[tar])
;    evalTargetedADEF(t,vars,rest tar,body)
;  null m => evalUntargetedADEF(t,vars,types,body)
;  evalTargetedADEF(t,vars,types,body)

(DEFUN |upADEF| (|t|)
  (PROG (|$compilingMap| |ISTMP#2| |vars| |ISTMP#3| |ISTMP#4| |ISTMP#5|
            |ISTMP#6| |pred| |ISTMP#7| |types| |m| |types'| |body|
            |tar| |ISTMP#1| |argTypes|)
    (DECLARE (SPECIAL |$compilingMap|))
    (RETURN
      (SEQ (COND
             ((NULL (AND (CONSP |t|)
                         (PROGN
                           (setq |ISTMP#1| (QCDR |t|))
                           (AND (CONSP |ISTMP#1|)
                                (PROGN
                                  (setq |ISTMP#2| (QCAR |ISTMP#1|))
                                  (AND (CONSP |ISTMP#2|)
                                       (PROGN
                                         (setq |vars|
                                          (QCAR |ISTMP#2|))
                                         (setq |ISTMP#3|
                                          (QCDR |ISTMP#2|))
                                         (AND (CONSP |ISTMP#3|)
                                          (PROGN
                                            (setq |types|
                                             (QCAR |ISTMP#3|))
                                            (setq |ISTMP#4|
                                             (QCDR |ISTMP#3|))
                                            (AND (CONSP |ISTMP#4|)
                                             (PROGN
                                               (setq |ISTMP#5|
                                                (QCDR |ISTMP#4|))
                                               (AND (CONSP |ISTMP#5|)
                                                (EQ (QCDR |ISTMP#5|)
                                                 NIL)
                                                (PROGN
                                                  (setq |body|
                                                   (QCAR |ISTMP#5|))
                                                  'T)))))))))
                                (PROGN
                                  (setq |ISTMP#6| (QCDR |ISTMP#1|))
                                  (AND (CONSP |ISTMP#6|)
                                       (PROGN
                                         (setq |pred|
                                          (QCAR |ISTMP#6|))
                                         (setq |ISTMP#7|
                                          (QCDR |ISTMP#6|))
                                         (AND (CONSP |ISTMP#7|)
                                          (EQ (QCDR |ISTMP#7|) NIL)))))))))
              NIL)
             ('T
              (DO ((G166148 |vars| (CDR G166148)) (|var| NIL))
                  ((OR (ATOM G166148)
                       (PROGN (SETQ |var| (CAR G166148)) NIL))
                   NIL)
                (SEQ (EXIT (COND
                             ((NULL (IDENTP |var|))
                              (|throwKeyedMsg|
                               (format nil
                                "All parameters to anonymous user maps must ~
                                 identifiers, possibly in combination with ~
                                 declarations and predicates. Constants are ~
                                 not allowed. The given expression %1 is not ~
                                 allowed.")
                                  (CONS |var| NIL)))
                             ('T NIL)))))
              (setq |types|
                       (PROG (G166158)
                         (setq G166158 NIL)
                         (RETURN
                           (DO ((G166163 |types| (CDR G166163))
                                (|t| NIL))
                               ((OR (ATOM G166163)
                                    (PROGN
                                      (SETQ |t| (CAR G166163))
                                      NIL))
                                (NREVERSE0 G166158))
                             (SEQ (EXIT (SETQ G166158
                                         (CONS
                                          (COND
                                            (|t|
                                             (|evaluateType|
                                              (|unabbrev| |t|)))
                                            ('T NIL))
                                          G166158))))))))
              (COND
                ((|isPartialMode| (setq |m| (CAR |types|)))
                 (|throwKeyedMsg|
                  (format nil
                   "Partial type declarations are not allowed for anonymous ~
                    user maps. This also means that is you are using a +-> ~
                    form in a context where the type is to be deduced from ~
                    target information, the target type must not be partial.")
                  (CONS |m| NIL))))
              (COND
                ((AND (NULL |m|) (CDR |types|))
                 (setq |m| (CAR (CDR |types|)))
                 (setq |types'| (CDR (CDR |types|))))
                ('T (setq |types'| (CDR |types|))))
              (DO ((G166174 |types'| (CDR G166174)) (|type| NIL))
                  ((OR (ATOM G166174)
                       (PROGN (SETQ |type| (CAR G166174)) NIL))
                   NIL)
                (SEQ (EXIT (PROGN
                             (COND
                               ((OR (AND |type| (NULL |m|))
                                    (AND |m| (NULL |type|)))
                                (|throwKeyedMsg|
                (format nil
                 "You entered an incomplete signature for an anonymous user ~
                  function. You must either declare the type types of the ~
                  rest and all the arguments or you  must declare the ~
                  types of none of them.")
                                  NIL)))
                             (COND
                               ((|isPartialMode| |type|)
                                (|throwKeyedMsg| 
                        (format nil
                         "Partial type declarations are not allowed for ~
                          anonymous user maps. This also means that is you ~
                          are using a +-> form in a context  where the type ~
                          is to be deduced from target information, the ~
                          target type must not be partial.")
                                    (CONS |type| NIL)))
                               ('T NIL))))))
              (setq |$compilingMap| 'T)
              (COND
                ((NEQUAL |pred| 'T)
                 (setq |body|
                          (CONS 'IF
                                (CONS |pred|
                                      (CONS |body|
                                       (CONS '|noMapVal| NIL)))))))
              (setq |tar| (|getTarget| |t|))
              (COND
                ((AND (NULL |m|) (CONSP |tar|)
                      (EQ (QCAR |tar|) '|Mapping|)
                      (PROGN
                        (setq |ISTMP#1| (QCDR |tar|))
                        (AND (CONSP |ISTMP#1|)
                             (PROGN
                               (setq |argTypes| (QCDR |ISTMP#1|))
                               'T)))
                      (BOOT-EQUAL (|#| |vars|) (|#| |argTypes|)))
                 (COND
                   ((|isPartialMode| |tar|)
                    (|throwKeyedMsg|
                     (format nil
                      "Partial type declarations are not allowed for ~
                       anonymous user maps. This also means that is you are ~
                       using a +-> form in a context where the type is to be ~
                       deduced from target information, the target type ~
                       must not be partial.")
                     (CONS |tar| NIL))))
                 (|evalTargetedADEF| |t| |vars| (CDR |tar|) |body|))
                ((NULL |m|)
                 (|evalUntargetedADEF| |t| |vars| |types| |body|))
                ('T (|evalTargetedADEF| |t| |vars| |types| |body|)))))))))

;evalUntargetedADEF(t,vars,types,body) ==
;  -- recreate a parse form
;  if vars is [var]
;    then vars := var
;    else vars := ['Tuple,:vars]
;  val := objNewWrap(["+->",vars,body],$AnonymousFunction)
;  putValue(t,val)
;  putModeSet(t,[objMode val])

(DEFUN |evalUntargetedADEF| (|t| |vars| |types| |body|)
  (declare (ignore |types|))
  (PROG (|var| |val|)
  (declare (special |$AnonymousFunction|))
    (RETURN
      (PROGN
        (COND
          ((AND (CONSP |vars|) (EQ (QCDR |vars|) NIL)
                (PROGN (setq |var| (QCAR |vars|)) 'T))
           (setq |vars| |var|))
          ('T (setq |vars| (CONS '|Tuple| |vars|))))
        (setq |val|
                 (mkObjWrap
                     (CONS '+-> (CONS |vars| (CONS |body| NIL)))
                     |$AnonymousFunction|))
        (|putValue| |t| |val|)
        (|putModeSet| |t| (CONS (|objMode| |val|) NIL))))))

;evalTargetedADEF(t,vars,types,body) ==
;  $mapName : local := makeInternalMapName('"anonymousFunction",
;    #vars,$anonymousMapCounter,'"internal")
;  $anonymousMapCounter := 1 + $anonymousMapCounter
;  $compilingMap   : local := true  -- state that we are trying to compile
;  $mapThrowCount  : local := 0     -- number of "return"s encountered
;  $mapReturnTypes : local := nil   -- list of types from returns
;  $repeatLabel    : local := nil   -- for loops; see upREPEAT
;  $breakCount     : local := 0     -- breaks from loops; ditto
;  -- now substitute formal names for the parm variables
;  -- this is used in the interpret-code case, but isn't so bad any way
;  -- since it makes the bodies look more like regular map bodies
;  sublist := [[var,:GENSYM()] for var in vars]
;  body := sublisNQ(sublist,body)
;  vars := [CDR v for v in sublist]
;  for m in CDR types for var in vars repeat
;    $env:= put(var,'mode,m,$env)
;    mkLocalVar($mapName,var)
;  for lvar in getLocalVars($mapName,body) repeat
;    mkLocalVar($mapName,lvar)
;  -- set up catch point for interpret-code mode
;  x := CATCH('mapCompiler,compileTargetedADEF(t,vars,types,body))
;  x = 'tryInterpOnly => mkInterpTargetedADEF(t,vars,types,body)
;  x

(DEFUN |evalTargetedADEF| (|t| |vars| |types| |body|)
  (PROG (|$mapName| |$compilingMap| |$mapThrowCount| |$mapReturnTypes|
            |$repeatLabel| |$breakCount| |sublist| |x|)
    (DECLARE (SPECIAL |$mapName| |$compilingMap| |$mapThrowCount| |$env|
                      |$mapReturnTypes| |$repeatLabel| |$breakCount|
                      |$anonymousMapCounter|))
    (RETURN
      (SEQ (PROGN
             (setq |$mapName|
                      (|makeInternalMapName|
                          "anonymousFunction" (|#| |vars|)
                          |$anonymousMapCounter|
                          "internal"))
             (setq |$anonymousMapCounter|
                      (+ 1 |$anonymousMapCounter|))
             (setq |$compilingMap| 'T)
             (setq |$mapThrowCount| 0)
             (setq |$mapReturnTypes| NIL)
             (setq |$repeatLabel| NIL)
             (setq |$breakCount| 0)
             (setq |sublist|
                      (PROG (G166221)
                        (setq G166221 NIL)
                        (RETURN
                          (DO ((G166226 |vars| (CDR G166226))
                               (|var| NIL))
                              ((OR (ATOM G166226)
                                   (PROGN
                                     (SETQ |var| (CAR G166226))
                                     NIL))
                               (NREVERSE0 G166221))
                            (SEQ (EXIT (SETQ G166221
                                        (CONS (CONS |var| (GENSYM))
                                         G166221))))))))
             (setq |body| (|sublisNQ| |sublist| |body|))
             (setq |vars|
                      (PROG (G166236)
                        (setq G166236 NIL)
                        (RETURN
                          (DO ((G166241 |sublist| (CDR G166241))
                               (|v| NIL))
                              ((OR (ATOM G166241)
                                   (PROGN
                                     (SETQ |v| (CAR G166241))
                                     NIL))
                               (NREVERSE0 G166236))
                            (SEQ (EXIT (SETQ G166236
                                        (CONS (CDR |v|) G166236))))))))
             (DO ((G166253 (CDR |types|) (CDR G166253)) (|m| NIL)
                  (G166254 |vars| (CDR G166254)) (|var| NIL))
                 ((OR (ATOM G166253)
                      (PROGN (SETQ |m| (CAR G166253)) NIL)
                      (ATOM G166254)
                      (PROGN (SETQ |var| (CAR G166254)) NIL))
                  NIL)
               (SEQ (EXIT (PROGN
                            (setq |$env|
                                     (|put| |var| '|mode| |m| |$env|))
                            (|mkLocalVar| |$mapName| |var|)))))
             (DO ((G166266 (|getLocalVars| |$mapName| |body|)
                      (CDR G166266))
                  (|lvar| NIL))
                 ((OR (ATOM G166266)
                      (PROGN (SETQ |lvar| (CAR G166266)) NIL))
                  NIL)
               (SEQ (EXIT (|mkLocalVar| |$mapName| |lvar|))))
             (setq |x|
                      (CATCH '|mapCompiler|
                        (|compileTargetedADEF| |t| |vars| |types|
                            |body|)))
             (COND
               ((BOOT-EQUAL |x| '|tryInterpOnly|)
                (|mkInterpTargetedADEF| |t| |vars| |types| |body|))
               ('T |x|)))))))

;mkInterpTargetedADEF(t,vars,types,oldBody) ==
;  null first types =>
;    throwKeyedMsg("S2IS0056",NIL)
;    throwMessage '"   map result type needed but not present."
;  arglCode := ['LIST,:[argCode for type in rest types for var in vars]]
;    where argCode == ['putValueValue,['mkAtreeNode,MKQ var],
;      objNewCode(['wrap,var],type)]
;  put($mapName,'mapBody,oldBody,$e)
;  body := ['rewriteMap1,MKQ $mapName,arglCode,MKQ types]
;  compileADEFBody(t,vars,types,body,first types)

(DEFUN |mkInterpTargetedADEF| (|t| |vars| |types| |oldBody|)
  (PROG (|arglCode| |body|)
  (declare (special |$mapName| |$e|))
    (RETURN
      (SEQ (COND
             ((NULL (CAR |types|))
               (|throwKeyedMsg| 
                (format nil
                 "Anonymous user functions created with +-> that are ~
                  processed in interpret-code mode must have result target ~
                  information available. This information is not present so ~
                  Axiom cannot proceed any further. This may be remedied by ~
                  declaring the function.")
                NIL)
              (|throwMessage|
                                 "   map result type needed but not present."))
             ('T
              (setq |arglCode|
                       (CONS 'LIST
                             (PROG (G166309)
                               (setq G166309 NIL)
                               (RETURN
                                 (DO ((G166315 (CDR |types|)
                                       (CDR G166315))
                                      (|type| NIL)
                                      (G166316 |vars|
                                       (CDR G166316))
                                      (|var| NIL))
                                     ((OR (ATOM G166315)
                                       (PROGN
                                         (SETQ |type| (CAR G166315))
                                         NIL)
                                       (ATOM G166316)
                                       (PROGN
                                         (SETQ |var| (CAR G166316))
                                         NIL))
                                      (NREVERSE0 G166309))
                                   (SEQ
                                    (EXIT
                                     (SETQ G166309
                                      (CONS
                                       (CONS '|putValueValue|
                                        (CONS
                                         (CONS '|mkAtreeNode|
                                          (CONS (MKQ |var|) NIL))
                                         (CONS
                                          (mkObjCode
                                           (CONS '|wrap|
                                            (CONS |var| NIL))
                                           |type|)
                                          NIL)))
                                       G166309)))))))))
              (|put| |$mapName| '|mapBody| |oldBody| |$e|)
              (setq |body|
                       (CONS '|rewriteMap1|
                             (CONS (MKQ |$mapName|)
                                   (CONS |arglCode|
                                    (CONS (MKQ |types|) NIL)))))
              (|compileADEFBody| |t| |vars| |types| |body|
                  (CAR |types|))))))))

;compileTargetedADEF(t,vars,types,body) ==
;  val := compileBody(body,CAR types)
;  computedResultType := objMode val
;  body := wrapMapBodyWithCatch flattenCOND objVal val
;  compileADEFBody(t,vars,types,body,computedResultType)

(DEFUN |compileTargetedADEF| (|t| |vars| |types| |body|)
  (PROG (|val| |computedResultType|)
    (RETURN
      (PROGN
        (setq |val| (|compileBody| |body| (CAR |types|)))
        (setq |computedResultType| (|objMode| |val|))
        (setq |body|
                 (|wrapMapBodyWithCatch|
                     (|flattenCOND| (|objVal| |val|))))
        (|compileADEFBody| |t| |vars| |types| |body|
            |computedResultType|)))))

;compileADEFBody(t,vars,types,body,computedResultType) ==
;--+
;  $compiledOpNameList := [$mapName]
;  minivectorName := makeInternalMapMinivectorName(PNAME $mapName)
;  $minivectorNames := [[$mapName,:minivectorName],:$minivectorNames]
;  body := SUBST(minivectorName,"$$$",body)
;  if $compilingInputFile then
;    $minivectorCode := [:$minivectorCode,minivectorName]
;  SET(minivectorName,LIST2REFVEC $minivector)
;  -- The use of the three variables $definingMap, $genValue and $compilingMap
;  -- is to cover the following cases:
;  --
;  -- $definingMap: This is set in analyzeMap and covers examples like:
;  --  addx x == ((y: Integer): Integer +-> x + y)
;  --  g := addx 10
;  --  g 3
;  -- i.e. we are storing the mapping as an object.
;  --
;  -- $compilingMap: This covers mappings which are created and applied "on the
;  -- "fly", for example:
;  --  [map(h +-> D(h, t), v) for v in [t]]
;  --
;  -- $genValue: This seems to be needed when we create a map as an argument
;  -- for a constructor, e.g.:
;  --  Dx: LODO(EXPR INT, f +-> D(f, x)) := D()
;  --
;  -- MCD 13/3/96
;  if not $definingMap and ($genValue or $compilingMap) then
;    fun := ['function,['LAMBDA,[:vars,'envArg],body]]
;    code :=  wrap timedEVALFUN ['LIST,fun]
;  else
;    $freeVariables := []
;    $boundVariables := [minivectorName,:vars]
;    -- CCL does not support upwards funargs, so we check for any free variables
;    -- and pass them into the lambda as part of envArg.
;    body := checkForFreeVariables(body,"ALL")
;    fun := ['function,['LAMBDA,[:vars,'envArg],body]]
;    code := ['CONS, fun, ["VECTOR", :reverse $freeVariables]]
;  val := objNew(code,rt := ['Mapping,computedResultType,:rest types])
;  putValue(t,val)
;  putModeSet(t,[rt])

(DEFUN |compileADEFBody| (|t| |vars| |types| |body| |computedResultType|)
  (PROG (|minivectorName| |fun| |code| |rt| |val|)
  (declare (special |$freeVariables| |$boundVariables| |$compilingMap|
                    |$genValue| |$definingMap| |$minivector| |$mapName|
                    |$minivectorCode| |$compilingInputFile| 
                    |$minivectorNames| |$compiledOpNameList|))
    (RETURN
      (PROGN
        (setq |$compiledOpNameList| (CONS |$mapName| NIL))
        (setq |minivectorName|
                 (|makeInternalMapMinivectorName| (PNAME |$mapName|)))
        (setq |$minivectorNames|
                 (CONS (CONS |$mapName| |minivectorName|)
                       |$minivectorNames|))
        (setq |body| (MSUBST |minivectorName| '$$$ |body|))
        (COND
          (|$compilingInputFile|
              (setq |$minivectorCode|
                       (APPEND |$minivectorCode|
                               (CONS |minivectorName| NIL)))))
        (SET |minivectorName| (LIST2REFVEC |$minivector|))
        (COND
          ((AND (NULL |$definingMap|) (OR |$genValue| |$compilingMap|))
           (setq |fun|
                    (CONS 'function
                          (CONS (CONS 'LAMBDA
                                      (CONS
                                       (APPEND |vars|
                                        (CONS '|envArg| NIL))
                                       (CONS |body| NIL)))
                                NIL)))
           (setq |code|
                    (|wrap| (|timedEVALFUN|
                                (CONS 'LIST (CONS |fun| NIL))))))
          ('T (setq |$freeVariables| NIL)
           (setq |$boundVariables| (CONS |minivectorName| |vars|))
           (setq |body| (|checkForFreeVariables| |body| 'ALL))
           (setq |fun|
                    (CONS 'function
                          (CONS (CONS 'LAMBDA
                                      (CONS
                                       (APPEND |vars|
                                        (CONS '|envArg| NIL))
                                       (CONS |body| NIL)))
                                NIL)))
           (setq |code|
                    (CONS 'CONS
                          (CONS |fun|
                                (CONS (CONS 'VECTOR
                                       (REVERSE |$freeVariables|))
                                      NIL))))))
        (setq |val|
                 (mkObj |code|
                           (setq |rt|
                                    (CONS '|Mapping|
                                     (CONS |computedResultType|
                                      (CDR |types|))))))
        (|putValue| |t| |val|)
        (|putModeSet| |t| (CONS |rt| NIL))))))

;--% Handler for Algebraic Extensions
;upAlgExtension t ==
;  -- handler for algebraic extension declaration.  These are of
;  --  the form "a | a**2+1", and have the effect that "a" is declared
;  --  to be a simple algebraic extension, with respect to the given
;  --  polynomial, and given the value "a" in this type.
;  t isnt [op,var,eq] => nil
;  null $genValue => throwKeyedMsg("S2IS0001",NIL)
;  a := getUnname var
;  clearCmdParts ['propert,a]  --clear properties of a
;  algExtension:= eq2AlgExtension eq
;  upmode := ['UnivariatePolynomial,a,$EmptyMode]
;  $declaredMode : local := upmode
;  putTarget(algExtension,upmode)
;  ms:= bottomUp algExtension
;  triple:= getValue algExtension
;  upmode:= resolveTMOrCroak(objMode(triple),upmode)
;  null (T:= coerceInteractive(triple,upmode)) =>
;    throwKeyedMsgCannotCoerceWithValue(objVal(triple),
;      objMode(triple),upmode)
;  newmode := objMode T
;  (field := resolveTCat(CADDR newmode,'(Field))) or
;    throwKeyedMsg("S2IS0002",[eq])
;  pd:= ['UnivariatePolynomial,a,field]
;  null (canonicalAE:= coerceInteractive(T,pd)) =>
;    throwKeyedMsgCannotCoerceWithValue(objVal T,objMode T,pd)
;  sae:= ['SimpleAlgebraicExtension,field,pd,objValUnwrap canonicalAE]
;  saeTypeSynonym := INTERN STRCONC('"SAE",princ-to-string a)
;  saeTypeSynonymValue := objNew(sae,'(Domain))
;  fun := getFunctionFromDomain('generator,sae,NIL)
;  expr:= wrap SPADCALL(fun)
;  putHist(saeTypeSynonym,'value,saeTypeSynonymValue,$e)
;  putHist(a,'mode,sae,$e)
;  putHist(a,'value,T2:= objNew(expr,sae),$e)
;  clearDependencies(a,true)
;  if $printTypeIfTrue then
;    sayKeyedMsg("S2IS0003",NIL)
;    sayMSG concat ['%l,'"   ",saeTypeSynonym,'" := ",
;      :prefix2String objVal saeTypeSynonymValue]
;    sayMSG concat ['"   ",a,'" : ",saeTypeSynonym,'" := ",a]
;  putValue(op,T2)
;  putModeSet(op,[sae])

(DEFUN |upAlgExtension| (|t|)
  (PROG (|$declaredMode| |op| |ISTMP#1| |var| |ISTMP#2| |eq| |a|
            |algExtension| |ms| |triple| |upmode| T$ |newmode| |field|
            |pd| |canonicalAE| |sae| |saeTypeSynonym|
            |saeTypeSynonymValue| |fun| |expr| T2)
    (DECLARE (SPECIAL |$declaredMode| |$printTypeIfTrue| |$e| |$EmptyMode|
                      |$genValue|))
    (RETURN
      (COND
        ((NULL (AND (CONSP |t|)
                    (PROGN
                      (setq |op| (QCAR |t|))
                      (setq |ISTMP#1| (QCDR |t|))
                      (AND (CONSP |ISTMP#1|)
                           (PROGN
                             (setq |var| (QCAR |ISTMP#1|))
                             (setq |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (CONSP |ISTMP#2|)
                                  (EQ (QCDR |ISTMP#2|) NIL)
                                  (PROGN
                                    (setq |eq| (QCAR |ISTMP#2|))
                                    'T)))))))
         NIL)
        ((NULL |$genValue|)
          (|throwKeyedMsg|
            "Cannot compile algebraic extension declarations yet."
            NIL))
        ('T (setq |a| (|getUnname| |var|))
         (|clearCmdParts| (CONS '|propert| (CONS |a| NIL)))
         (setq |algExtension| (|eq2AlgExtension| |eq|))
         (setq |upmode|
                  (CONS '|UnivariatePolynomial|
                        (CONS |a| (CONS |$EmptyMode| NIL))))
         (setq |$declaredMode| |upmode|)
         (|putTarget| |algExtension| |upmode|)
         (setq |ms| (|bottomUp| |algExtension|))
         (setq |triple| (|getValue| |algExtension|))
         (setq |upmode|
                  (|resolveTMOrCroak| (|objMode| |triple|) |upmode|))
         (COND
           ((NULL (setq T$ (|coerceInteractive| |triple| |upmode|)))
            (|throwKeyedMsgCannotCoerceWithValue| (|objVal| |triple|)
                (|objMode| |triple|) |upmode|))
           ('T (setq |newmode| (|objMode| T$))
            (OR (setq |field|
                         (|resolveTCat| (CADDR |newmode|) '(|Field|)))
                (|throwKeyedMsg|
                 "Cannot pass to a field from the domain %1p ."
                 (CONS |eq| NIL)))
            (setq |pd|
                     (CONS '|UnivariatePolynomial|
                           (CONS |a| (CONS |field| NIL))))
            (COND
              ((NULL (setq |canonicalAE|
                              (|coerceInteractive| T$ |pd|)))
               (|throwKeyedMsgCannotCoerceWithValue| (|objVal| T$)
                   (|objMode| T$) |pd|))
              ('T
               (setq |sae|
                        (CONS '|SimpleAlgebraicExtension|
                              (CONS |field|
                                    (CONS |pd|
                                     (CONS
                                      (|objValUnwrap| |canonicalAE|)
                                      NIL)))))
               (setq |saeTypeSynonym|
                        (INTERN (STRCONC "SAE"
                                         (princ-to-string |a|))))
               (setq |saeTypeSynonymValue|
                        (mkObj |sae| '(|Domain|)))
               (setq |fun|
                        (|getFunctionFromDomain| '|generator| |sae|
                            NIL))
               (setq |expr| (|wrap| (SPADCALL |fun|)))
               (|putHist| |saeTypeSynonym| '|value|
                   |saeTypeSynonymValue| |$e|)
               (|putHist| |a| '|mode| |sae| |$e|)
               (|putHist| |a| '|value|
                   (setq T2 (mkObj |expr| |sae|)) |$e|)
               (|clearDependencies| |a| 'T)
               (COND
                 (|$printTypeIfTrue|
                     (|sayKeyedMsg|
                      (format nil
                       "Your statement has resulted in the following ~
                        assignments and declaration:")
                       NIL)
                     (|sayMSG|
                         (|concat|
                             (CONS '|%l|
                                   (CONS "   "
                                    (CONS |saeTypeSynonym|
                                     (CONS " := "
                                      (|prefix2String|
                                       (|objVal| |saeTypeSynonymValue|))))))))
                     (|sayMSG|
                         (|concat|
                             (CONS "   "
                                   (CONS |a|
                                    (CONS " : "
                                     (CONS |saeTypeSynonym|
                                      (CONS " := "
                                       (CONS |a| NIL))))))))))
               (|putValue| |op| T2)
               (|putModeSet| |op| (CONS |sae| NIL)))))))))))

;eq2AlgExtension eq ==
;  -- transforms "a=b" to a-b for processing
;  eq is [op,:l] and VECP op and (getUnname op='equation) =>
;    [mkAtreeNode "-",:l]
;  eq

(DEFUN |eq2AlgExtension| (|eq|)
  (PROG (|op| |l|)
    (RETURN
      (COND
        ((AND (CONSP |eq|)
              (PROGN
                (setq |op| (QCAR |eq|))
                (setq |l| (QCDR |eq|))
                'T)
              (VECP |op|) (BOOT-EQUAL (|getUnname| |op|) '|equation|))
         (CONS (|mkAtreeNode| '-) |l|))
        ('T |eq|)))))

;--% Handlers for booleans
;upand x ==
;  -- generates code for  and  forms. The second argument is only
;  -- evaluated if the first argument is true.
;  x isnt [op,term1,term2] => NIL
;  putTarget(term1,$Boolean)
;  putTarget(term2,$Boolean)
;  ms := bottomUp term1
;  ms isnt [=$Boolean] => throwKeyedMsgSP("S2IS0054",[1,'"_"and_""],term1)
;  $genValue =>
;    BooleanEquality(objValUnwrap(getValue term1),
;      getConstantFromDomain('(false),$Boolean)) =>
;        putValue(x,getValue term1)
;        putModeSet(x,ms)
;    -- first term is true, so look at the second one
;    ms := bottomUp term2
;    ms isnt [=$Boolean] => throwKeyedMsgSP("S2IS0054",[2,'"_"and_""],term2)
;    putValue(x,getValue term2)
;    putModeSet(x,ms)
;  ms := bottomUp term2
;  ms isnt [=$Boolean] => throwKeyedMsgSP("S2IS0054",[2,'"_"and_""],term2)
;  -- generate an IF expression and let the rest of the code handle it
;  cond := [mkAtreeNode "=",mkAtree 'false,term1]
;  putTarget(cond,$Boolean)
;  code := [mkAtreeNode 'IF,cond,mkAtree 'false,term2]
;  putTarget(code,$Boolean)
;  bottomUp code
;  putValue(x,getValue code)
;  putModeSet(x,ms)

(DEFUN |upand| (|x|)
  (PROG (|op| |ISTMP#1| |term1| |ISTMP#2| |term2| |ms| |cond| |code|)
  (declare (special |$Boolean| |$genValue|))
    (RETURN
      (COND
        ((NULL (AND (CONSP |x|)
                    (PROGN
                      (setq |op| (QCAR |x|))
                      (setq |ISTMP#1| (QCDR |x|))
                      (AND (CONSP |ISTMP#1|)
                           (PROGN
                             (setq |term1| (QCAR |ISTMP#1|))
                             (setq |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (CONSP |ISTMP#2|)
                                  (EQ (QCDR |ISTMP#2|) NIL)
                                  (PROGN
                                    (setq |term2| (QCAR |ISTMP#2|))
                                    'T)))))))
         NIL)
        ('T (|putTarget| |term1| |$Boolean|)
         (|putTarget| |term2| |$Boolean|)
         (setq |ms| (|bottomUp| |term1|))
         (COND
           ((NULL (AND (CONSP |ms|) (EQ (QCDR |ms|) NIL)
                       (EQUAL (QCAR |ms|) |$Boolean|)))
            (|throwKeyedMsgSP|
                "Argument number %1 to %2 must be a Boolean."
                (CONS 1 (CONS "\"and\"" NIL)) |term1|))
           (|$genValue|
               (COND
                 ((|BooleanEquality|
                      (|objValUnwrap| (|getValue| |term1|))
                      (|getConstantFromDomain| '(|false|) |$Boolean|))
                  (|putValue| |x| (|getValue| |term1|))
                  (|putModeSet| |x| |ms|))
                 ('T (setq |ms| (|bottomUp| |term2|))
                  (COND
                    ((NULL (AND (CONSP |ms|) (EQ (QCDR |ms|) NIL)
                                (EQUAL (QCAR |ms|) |$Boolean|)))
                     (|throwKeyedMsgSP|
                       "Argument number %1 to %2 must be a Boolean."
                         (CONS 2 (CONS "\"and\"" NIL))
                         |term2|))
                    ('T (|putValue| |x| (|getValue| |term2|))
                     (|putModeSet| |x| |ms|))))))
           ('T (setq |ms| (|bottomUp| |term2|))
            (COND
              ((NULL (AND (CONSP |ms|) (EQ (QCDR |ms|) NIL)
                          (EQUAL (QCAR |ms|) |$Boolean|)))
               (|throwKeyedMsgSP|
                  "Argument number %1 to %2 must be a Boolean."
                   (CONS 2 (CONS "\"and\"" NIL)) |term2|))
              ('T
               (setq |cond|
                        (CONS (|mkAtreeNode| '=)
                              (CONS (|mkAtree| '|false|)
                                    (CONS |term1| NIL))))
               (|putTarget| |cond| |$Boolean|)
               (setq |code|
                        (CONS (|mkAtreeNode| 'IF)
                              (CONS |cond|
                                    (CONS (|mkAtree| '|false|)
                                     (CONS |term2| NIL)))))
               (|putTarget| |code| |$Boolean|) (|bottomUp| |code|)
               (|putValue| |x| (|getValue| |code|))
               (|putModeSet| |x| |ms|))))))))))

;upor x ==
;  -- generates code for  or  forms. The second argument is only
;  -- evaluated if the first argument is false.
;  x isnt [op,term1,term2] => NIL
;  putTarget(term1,$Boolean)
;  putTarget(term2,$Boolean)
;  ms := bottomUp term1
;  ms isnt [=$Boolean] => throwKeyedMsgSP("S2IS0054",[1,'"_"or_""],term1)
;  $genValue =>
;    BooleanEquality(objValUnwrap(getValue term1),
;      getConstantFromDomain('(true),$Boolean)) =>
;        putValue(x,getValue term1)
;        putModeSet(x,ms)
;    -- first term is false, so look at the second one
;    ms := bottomUp term2
;    ms isnt [=$Boolean] => throwKeyedMsgSP("S2IS0054",[2,'"_"or_""],term2)
;    putValue(x,getValue term2)
;    putModeSet(x,ms)
;  ms := bottomUp term2
;  ms isnt [=$Boolean] => throwKeyedMsgSP("S2IS0054",[2,'"_"or_""],term2)
;  -- generate an IF expression and let the rest of the code handle it
;  cond := [mkAtreeNode "=",mkAtree 'true,term1]
;  putTarget(cond,$Boolean)
;  code := [mkAtreeNode 'IF,cond,mkAtree 'true,term2]
;  putTarget(code,$Boolean)
;  bottomUp code
;  putValue(x,getValue code)
;  putModeSet(x,ms)

(DEFUN |upor| (|x|)
  (PROG (|op| |ISTMP#1| |term1| |ISTMP#2| |term2| |ms| |cond| |code|)
  (declare (special |$Boolean| |$genValue|))
    (RETURN
      (COND
        ((NULL (AND (CONSP |x|)
                    (PROGN
                      (setq |op| (QCAR |x|))
                      (setq |ISTMP#1| (QCDR |x|))
                      (AND (CONSP |ISTMP#1|)
                           (PROGN
                             (setq |term1| (QCAR |ISTMP#1|))
                             (setq |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (CONSP |ISTMP#2|)
                                  (EQ (QCDR |ISTMP#2|) NIL)
                                  (PROGN
                                    (setq |term2| (QCAR |ISTMP#2|))
                                    'T)))))))
         NIL)
        ('T (|putTarget| |term1| |$Boolean|)
         (|putTarget| |term2| |$Boolean|)
         (setq |ms| (|bottomUp| |term1|))
         (COND
           ((NULL (AND (CONSP |ms|) (EQ (QCDR |ms|) NIL)
                       (EQUAL (QCAR |ms|) |$Boolean|)))
            (|throwKeyedMsgSP|
              "Argument number %1 to %2 must be a Boolean."
                (CONS 1 (CONS "\"or\"" NIL)) |term1|))
           (|$genValue|
               (COND
                 ((|BooleanEquality|
                      (|objValUnwrap| (|getValue| |term1|))
                      (|getConstantFromDomain| '(|true|) |$Boolean|))
                  (|putValue| |x| (|getValue| |term1|))
                  (|putModeSet| |x| |ms|))
                 ('T (setq |ms| (|bottomUp| |term2|))
                  (COND
                    ((NULL (AND (CONSP |ms|) (EQ (QCDR |ms|) NIL)
                                (EQUAL (QCAR |ms|) |$Boolean|)))
                     (|throwKeyedMsgSP| 
                       "Argument number %1 to %2 must be a Boolean."
                         (CONS 2 (CONS "\"or\"" NIL))
                         |term2|))
                    ('T (|putValue| |x| (|getValue| |term2|))
                     (|putModeSet| |x| |ms|))))))
           ('T (setq |ms| (|bottomUp| |term2|))
            (COND
              ((NULL (AND (CONSP |ms|) (EQ (QCDR |ms|) NIL)
                          (EQUAL (QCAR |ms|) |$Boolean|)))
               (|throwKeyedMsgSP|
                 "Argument number %1 to %2 must be a Boolean."
                   (CONS 2 (CONS "\"or\"" NIL)) |term2|))
              ('T
               (setq |cond|
                        (CONS (|mkAtreeNode| '=)
                              (CONS (|mkAtree| '|true|)
                                    (CONS |term1| NIL))))
               (|putTarget| |cond| |$Boolean|)
               (setq |code|
                        (CONS (|mkAtreeNode| 'IF)
                              (CONS |cond|
                                    (CONS (|mkAtree| '|true|)
                                     (CONS |term2| NIL)))))
               (|putTarget| |code| |$Boolean|) (|bottomUp| |code|)
               (|putValue| |x| (|getValue| |code|))
               (|putModeSet| |x| |ms|))))))))))

;--% Handlers for case
;upcase t ==
;  t isnt [op,lhs,rhs] => nil
;  bottomUp lhs
;  triple := getValue lhs
;  objMode(triple) isnt ['Union,:unionDoms] =>
;    throwKeyedMsg("S2IS0004",NIL)
;  if (rhs' := isDomainValuedVariable(rhs)) then rhs := rhs'
;  if first unionDoms is ['_:,.,.] then
;     for i in 0.. for d in unionDoms repeat
;        if d is ['_:,=rhs,.] then rhstag := i
;     if NULL rhstag then error "upcase: bad Union form"
;     $genValue =>
;        rhstag = first unwrap objVal triple => code := wrap 'TRUE
;        code := wrap NIL
;     code :=
;        ['COND,
;          [['EQL,rhstag,['CAR,['unwrap,objVal triple]]],
;            ''TRUE],
;              [''T,NIL]]
;  else
;    $genValue =>
;        t' := coerceUnion2Branch triple
;        rhs = objMode t' => code := wrap 'TRUE
;        code := wrap NIL
;    triple' := objNewCode(['wrap,objVal triple],objMode triple)
;    code :=
;        ['COND,
;          [['EQUAL,MKQ rhs,['objMode,['coerceUnion2Branch,triple']]],
;            ''TRUE],
;              [''T,NIL]]
;  putValue(op,objNew(code,$Boolean))
;  putModeSet(op,[$Boolean])

(DEFUN |upcase| (|t|)
  (PROG (|op| |lhs| |triple| |unionDoms| |rhs'| |rhs| |ISTMP#3|
              |ISTMP#1| |ISTMP#2| |rhstag| |t'| |triple'| |code|)
  (declare (special |$Boolean| |$genValue|))
    (RETURN
      (SEQ (COND
             ((NULL (AND (CONSP |t|)
                         (PROGN
                           (setq |op| (QCAR |t|))
                           (setq |ISTMP#1| (QCDR |t|))
                           (AND (CONSP |ISTMP#1|)
                                (PROGN
                                  (setq |lhs| (QCAR |ISTMP#1|))
                                  (setq |ISTMP#2| (QCDR |ISTMP#1|))
                                  (AND (CONSP |ISTMP#2|)
                                       (EQ (QCDR |ISTMP#2|) NIL)
                                       (PROGN
                                         (setq |rhs|
                                          (QCAR |ISTMP#2|))
                                         'T)))))))
              NIL)
             ('T (|bottomUp| |lhs|)
              (setq |triple| (|getValue| |lhs|))
              (COND
                ((NULL (PROGN
                         (setq |ISTMP#1| (|objMode| |triple|))
                         (AND (CONSP |ISTMP#1|)
                              (EQ (QCAR |ISTMP#1|) '|Union|)
                              (PROGN
                                (setq |unionDoms| (QCDR |ISTMP#1|))
                                'T))))
                 (|throwKeyedMsg|
                  (format nil
                   "case is only used for Unions and the object on the ~
                    left-hand side does not belong to a union.")
                  NIL))
                ('T
                 (COND
                   ((setq |rhs'| (|isDomainValuedVariable| |rhs|))
                    (setq |rhs| |rhs'|)))
                 (COND
                   ((PROGN
                      (setq |ISTMP#1| (CAR |unionDoms|))
                      (AND (CONSP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) '|:|)
                           (PROGN
                             (setq |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (CONSP |ISTMP#2|)
                                  (PROGN
                                    (setq |ISTMP#3|
                                     (QCDR |ISTMP#2|))
                                    (AND (CONSP |ISTMP#3|)
                                     (EQ (QCDR |ISTMP#3|) NIL)))))))
                    (DO ((|i| 0 (QSADD1 |i|))
                         (G166560 |unionDoms| (CDR G166560))
                         (|d| NIL))
                        ((OR (ATOM G166560)
                             (PROGN (SETQ |d| (CAR G166560)) NIL))
                         NIL)
                      (SEQ (EXIT (COND
                                   ((AND (CONSP |d|)
                                     (EQ (QCAR |d|) '|:|)
                                     (PROGN
                                       (setq |ISTMP#1| (QCDR |d|))
                                       (AND (CONSP |ISTMP#1|)
                                        (EQUAL (QCAR |ISTMP#1|) |rhs|)
                                        (PROGN
                                          (setq |ISTMP#2|
                                           (QCDR |ISTMP#1|))
                                          (AND (CONSP |ISTMP#2|)
                                           (EQ (QCDR |ISTMP#2|) NIL))))))
                                    (setq |rhstag| |i|))
                                   ('T NIL)))))
                    (COND
                      ((NULL |rhstag|)
                       (|error| '|upcase: bad Union form|)))
                    (COND
                      (|$genValue|
                          (COND
                            ((BOOT-EQUAL |rhstag|
                                 (CAR (|unwrap| (|objVal| |triple|))))
                             (setq |code| (|wrap| 'TRUE)))
                            ('T (setq |code| (|wrap| NIL)))))
                      ('T
                       (setq |code|
                                (CONS 'COND
                                      (CONS
                                       (CONS
                                        (CONS 'EQL
                                         (CONS |rhstag|
                                          (CONS
                                           (CONS 'CAR
                                            (CONS
                                             (CONS '|unwrap|
                                              (CONS (|objVal| |triple|)
                                               NIL))
                                             NIL))
                                           NIL)))
                                        (CONS ''TRUE NIL))
                                       (CONS (CONS ''T (CONS NIL NIL))
                                        NIL)))))))
                   (|$genValue|
                       (setq |t'| (|coerceUnion2Branch| |triple|))
                       (COND
                         ((BOOT-EQUAL |rhs| (|objMode| |t'|))
                          (setq |code| (|wrap| 'TRUE)))
                         ('T (setq |code| (|wrap| NIL)))))
                   ('T
                    (setq |triple'|
                             (mkObjCode
                                 (CONS '|wrap|
                                       (CONS (|objVal| |triple|) NIL))
                                 (|objMode| |triple|)))
                    (setq |code|
                             (CONS 'COND
                                   (CONS
                                    (CONS
                                     (CONS 'EQUAL
                                      (CONS (MKQ |rhs|)
                                       (CONS
                                        (CONS '|objMode|
                                         (CONS
                                          (CONS '|coerceUnion2Branch|
                                           (CONS |triple'| NIL))
                                          NIL))
                                        NIL)))
                                     (CONS ''TRUE NIL))
                                    (CONS (CONS ''T (CONS NIL NIL))
                                     NIL))))))
                 (|putValue| |op| (mkObj |code| |$Boolean|))
                 (|putModeSet| |op| (CONS |$Boolean| NIL))))))))))

;--% Handlers for TARGET
;upTARGET t ==
;  -- Evaluates the rhs to a mode,which is used as the target type for
;  -- the lhs.
;  t isnt [op,lhs,rhs] => nil
;  -- do not (yet) support local variables on the rhs
;  (not $genValue) and or/[CONTAINED(var,rhs) for var in $localVars] =>
;    keyedMsgCompFailure("S2IC0010",[rhs])
;  $declaredMode: local := NIL
;  m:= evaluateType unabbrev rhs
;  not isLegitimateMode(m,NIL,NIL) => throwKeyedMsg("S2IE0004",[m])
;  categoryForm?(m) => throwKeyedMsg("S2IE0014",[m])
;  $declaredMode:= m
;  not atom(lhs) and putTarget(lhs,m)
;  ms := bottomUp lhs
;  first ms ^= m =>
;    throwKeyedMsg("S2IC0011",[first ms,m])
;  putValue(op,getValue lhs)
;  putModeSet(op,ms)

(DEFUN |upTARGET| (|t|)
  (PROG (|$declaredMode| |op| |ISTMP#1| |lhs| |ISTMP#2| |rhs| |m| |ms|)
    (DECLARE (SPECIAL |$declaredMode| |$localVars| |$genValue|))
    (RETURN
      (SEQ (COND
             ((NULL (AND (CONSP |t|)
                         (PROGN
                           (setq |op| (QCAR |t|))
                           (setq |ISTMP#1| (QCDR |t|))
                           (AND (CONSP |ISTMP#1|)
                                (PROGN
                                  (setq |lhs| (QCAR |ISTMP#1|))
                                  (setq |ISTMP#2| (QCDR |ISTMP#1|))
                                  (AND (CONSP |ISTMP#2|)
                                       (EQ (QCDR |ISTMP#2|) NIL)
                                       (PROGN
                                         (setq |rhs|
                                          (QCAR |ISTMP#2|))
                                         'T)))))))
              NIL)
             ((AND (NULL |$genValue|)
                   (PROG (G166618)
                     (setq G166618 NIL)
                     (RETURN
                       (DO ((G166624 NIL G166618)
                            (G166625 |$localVars| (CDR G166625))
                            (|var| NIL))
                           ((OR G166624 (ATOM G166625)
                                (PROGN
                                  (SETQ |var| (CAR G166625))
                                  NIL))
                            G166618)
                         (SEQ (EXIT (SETQ G166618
                                     (OR G166618
                                      (CONTAINED |var| |rhs|)))))))))
              (|keyedMsgCompFailure|
               (format nil
                "Cannot compile target expressions for types involving local ~
                 variables. In particular, could not compile the expression ~
                 involving @ %1p")
                (CONS |rhs| NIL)))
             ('T (setq |$declaredMode| NIL)
              (setq |m| (|evaluateType| (|unabbrev| |rhs|)))
              (COND
                ((NULL (|isLegitimateMode| |m| NIL NIL))
                 (|throwKeyedMsg| "%1p is not a valid type." (CONS |m| NIL)))
                ((|categoryForm?| |m|)
                 (|throwKeyedMsg|
                  (format nil
                   "You cannot use %1p or any other category in a target, ~
                    coercion, or package-call context.")
                   (CONS |m| NIL)))
                ('T (setq |$declaredMode| |m|)
                 (AND (NULL (ATOM |lhs|)) (|putTarget| |lhs| |m|))
                 (setq |ms| (|bottomUp| |lhs|))
                 (COND
                   ((NEQUAL (CAR |ms|) |m|)
                    (|throwKeyedMsg|
                     (format nil
                      "An expression involving @ %2p actually evaluated to ~
                       one of type %1p .  Perhaps you should use :: %2p .")
                        (CONS (CAR |ms|) (CONS |m| NIL))))
                   ('T (|putValue| |op| (|getValue| |lhs|))
                    (|putModeSet| |op| |ms|)))))))))))

;--% Handlers for COERCE
;upCOERCE t ==
;  -- evaluate the lhs and then tries to coerce the result to the
;  -- mode which is the rhs.
;  -- previous to 5/16/89, this had the same semantics as
;  --    (lhs@rhs) :: rhs
;  -- this must be made explicit now.
;  t isnt [op,lhs,rhs] => nil
;  $useConvertForCoercions : local := true
;  -- do not (yet) support local variables on the rhs
;  (not $genValue) and or/[CONTAINED(var,rhs) for var in $localVars] =>
;    keyedMsgCompFailure("S2IC0006",[rhs])
;  $declaredMode: local := NIL
;  m := evaluateType unabbrev rhs
;  not isLegitimateMode(m,NIL,NIL) => throwKeyedMsg("S2IE0004",[m])
;  categoryForm?(m) => throwKeyedMsg("S2IE0014",[m])
;  $declaredMode:= m
;  -- 05/16/89 (RSS) following line commented out to give correct
;  -- semantic difference between :: and @
;  bottomUp lhs
;  type:=evalCOERCE(op,lhs,m)
;  putModeSet(op,[type])

(DEFUN |upCOERCE| (|t|)
  (PROG (|$useConvertForCoercions| |$declaredMode| |op| |ISTMP#1| |lhs|
            |ISTMP#2| |rhs| |m| |type|)
    (DECLARE (SPECIAL |$useConvertForCoercions| |$declaredMode| |$localVars|
                      |$genValue|))
    (RETURN
      (SEQ (COND
             ((NULL (AND (CONSP |t|)
                         (PROGN
                           (setq |op| (QCAR |t|))
                           (setq |ISTMP#1| (QCDR |t|))
                           (AND (CONSP |ISTMP#1|)
                                (PROGN
                                  (setq |lhs| (QCAR |ISTMP#1|))
                                  (setq |ISTMP#2| (QCDR |ISTMP#1|))
                                  (AND (CONSP |ISTMP#2|)
                                       (EQ (QCDR |ISTMP#2|) NIL)
                                       (PROGN
                                         (setq |rhs|
                                          (QCAR |ISTMP#2|))
                                         'T)))))))
              NIL)
             ('T (setq |$useConvertForCoercions| 'T)
              (COND
                ((AND (NULL |$genValue|)
                      (PROG (G166672)
                        (setq G166672 NIL)
                        (RETURN
                          (DO ((G166678 NIL G166672)
                               (G166679 |$localVars| (CDR G166679))
                               (|var| NIL))
                              ((OR G166678 (ATOM G166679)
                                   (PROGN
                                     (SETQ |var| (CAR G166679))
                                     NIL))
                               G166672)
                            (SEQ (EXIT (SETQ G166672
                                        (OR G166672
                                         (CONTAINED |var| |rhs|)))))))))
                 (|keyedMsgCompFailure|
                  (format nil
                   "Cannot compile conversion for types involving local ~
                    variables. In particular, could not compile the ~
                    expression involving :: %1p ")
                  (CONS |rhs| NIL)))
                ('T (setq |$declaredMode| NIL)
                 (setq |m| (|evaluateType| (|unabbrev| |rhs|)))
                 (COND
                   ((NULL (|isLegitimateMode| |m| NIL NIL))
                    (|throwKeyedMsg| "%1p is not a valid type."
                     (CONS |m| NIL)))
                   ((|categoryForm?| |m|)
                    (|throwKeyedMsg|
                     (format nil
                      "You cannot use %1p or any other category in a target, ~
                       coercion, or package-call context.")
                     (CONS |m| NIL)))
                   ('T (setq |$declaredMode| |m|) (|bottomUp| |lhs|)
                    (setq |type| (|evalCOERCE| |op| |lhs| |m|))
                    (|putModeSet| |op| (CONS |type| NIL))))))))))))

;evalCOERCE(op,tree,m) ==
;  -- the value of tree is coerced to mode m
;  -- this is not necessary, if the target property of tree was used
;  v  := getValue tree
;  t1 := objMode(v)
;  if $genValue and t1 is ['Union,:.] then
;    v := coerceUnion2Branch v
;    t1 := objMode(v)
;  e  := objVal(v)
;  value:=
;    t1=m => v
;    t2 :=
;      if isPartialMode m
;        then
;          $genValue and (t1 = '(Symbol)) and containsPolynomial m =>
;            resolveTM(['UnivariatePolynomial,objValUnwrap(v),'(Integer)],m)
;          resolveTM(t1,m)
;        else m
;    null t2 => throwKeyedMsgCannotCoerceWithValue(e,t1,m)
;    $genValue => coerceOrRetract(v,t2)
;    objNew(getArgValue(tree,t2),t2)
;  val:= value or throwKeyedMsgCannotCoerceWithValue(e,t1,m)
;  putValue(op,val)
;  objMode(val)

(DEFUN |evalCOERCE| (|op| |tree| |m|)
  (PROG (|v| |t1| |e| |t2| |value| |val|)
  (declare (special |$genValue|))
    (RETURN
      (PROGN
        (setq |v| (|getValue| |tree|))
        (setq |t1| (|objMode| |v|))
        (COND
          ((AND |$genValue| (CONSP |t1|) (EQ (QCAR |t1|) '|Union|))
           (setq |v| (|coerceUnion2Branch| |v|))
           (setq |t1| (|objMode| |v|))))
        (setq |e| (|objVal| |v|))
        (setq |value|
                 (COND
                   ((BOOT-EQUAL |t1| |m|) |v|)
                   ('T
                    (setq |t2|
                             (COND
                               ((|isPartialMode| |m|)
                                (COND
                                  ((AND |$genValue|
                                    (BOOT-EQUAL |t1| '(|Symbol|))
                                    (|containsPolynomial| |m|))
                                   (|resolveTM|
                                    (CONS '|UnivariatePolynomial|
                                     (CONS (|objValUnwrap| |v|)
                                      (CONS '(|Integer|) NIL)))
                                    |m|))
                                  ('T (|resolveTM| |t1| |m|))))
                               ('T |m|)))
                    (COND
                      ((NULL |t2|)
                       (|throwKeyedMsgCannotCoerceWithValue| |e| |t1|
                           |m|))
                      (|$genValue| (|coerceOrRetract| |v| |t2|))
                      ('T (mkObj (|getArgValue| |tree| |t2|) |t2|))))))
        (setq |val|
                 (OR |value|
                     (|throwKeyedMsgCannotCoerceWithValue| |e| |t1|
                         |m|)))
        (|putValue| |op| |val|)
        (|objMode| |val|)))))

;--% Handlers for COLLECT
;transformCollect [:itrl,body] ==
;  -- syntactic transformation for COLLECT form, called from mkAtree1
;  iterList:=[:iterTran1 for it in itrl] where iterTran1 ==
;    it is ['STEP,index,lower,step,:upperList] =>
;      [['STEP,index,mkAtree1 lower,mkAtree1 step,:[mkAtree1 upper
;        for upper in upperList]]]
;    it is ['IN,index,s] =>
;      [['IN,index,mkAtree1 s]]
;    it is ['ON,index,s] =>
;      [['IN,index,mkAtree1 ['tails,s]]]
;    it is ['WHILE,b] =>
;      [['WHILE,mkAtree1 b]]
;    it is ['_|,pred] =>
;      [['SUCHTHAT,mkAtree1 pred]]
;    it is [op,:.] and (op in '(VALUE UNTIL)) => nil
;  bodyTree:=mkAtree1 body
;  iterList:=NCONC(iterList,[:iterTran2 for it in itrl]) where
;    iterTran2 ==
;      it is ['STEP,:.] => nil
;      it is ['IN,:.] => nil
;      it is ['ON,:.] => nil
;      it is ['WHILE,:.] => nil
;      it is [op,b] and (op in '(UNTIL)) =>
;        [[op,mkAtree1 b]]
;      it is ['_|,pred] => nil
;      keyedSystemError("S2GE0016",
;        ['"transformCollect",'"Unknown type of iterator"])
;  [:iterList,bodyTree]

(DEFUN |transformCollect| (G166863)
  (PROG (|LETTMP#1| |body| |itrl| |lower| |ISTMP#3| |step| |upperList|
            |index| |ISTMP#2| |s| |bodyTree| |op| |b| |ISTMP#1| |pred|
            |iterList|)
    (RETURN
      (SEQ (PROGN
             (setq |LETTMP#1| (REVERSE G166863))
             (setq |body| (CAR |LETTMP#1|))
             (setq |itrl| (NREVERSE (CDR |LETTMP#1|)))
             (setq |iterList|
                      (PROG (G166918)
                        (setq G166918 NIL)
                        (RETURN
                          (DO ((G166958 |itrl| (CDR G166958))
                               (|it| NIL))
                              ((OR (ATOM G166958)
                                   (PROGN
                                     (SETQ |it| (CAR G166958))
                                     NIL))
                               G166918)
                            (SEQ (EXIT (SETQ G166918
                                        (APPEND G166918
                                         (COND
                                           ((AND (CONSP |it|)
                                             (EQ (QCAR |it|) 'STEP)
                                             (PROGN
                                               (setq |ISTMP#1|
                                                (QCDR |it|))
                                               (AND (CONSP |ISTMP#1|)
                                                (PROGN
                                                  (setq |index|
                                                   (QCAR |ISTMP#1|))
                                                  (setq |ISTMP#2|
                                                   (QCDR |ISTMP#1|))
                                                  (AND
                                                   (CONSP |ISTMP#2|)
                                                   (PROGN
                                                     (setq |lower|
                                                      (QCAR |ISTMP#2|))
                                                     (setq |ISTMP#3|
                                                      (QCDR |ISTMP#2|))
                                                     (AND
                                                      (CONSP |ISTMP#3|)
                                                      (PROGN
                                                        (setq |step|
                                                         (QCAR
                                                          |ISTMP#3|))
                                                        (setq
                                                         |upperList|
                                                         (QCDR
                                                          |ISTMP#3|))
                                                        'T))))))))
                                            (CONS
                                             (CONS 'STEP
                                              (CONS |index|
                                               (CONS
                                                (|mkAtree1| |lower|)
                                                (CONS
                                                 (|mkAtree1| |step|)
                                                 (PROG (G166968)
                                                   (setq G166968
                                                    NIL)
                                                   (RETURN
                                                     (DO
                                                      ((G166973
                                                        |upperList|
                                                        (CDR G166973))
                                                       (|upper| NIL))
                                                      ((OR
                                                        (ATOM
                                                         G166973)
                                                        (PROGN
                                                          (SETQ |upper|
                                                           (CAR
                                                            G166973))
                                                          NIL))
                                                       (NREVERSE0
                                                        G166968))
                                                       (SEQ
                                                        (EXIT
                                                         (SETQ
                                                          G166968
                                                          (CONS
                                                           (|mkAtree1|
                                                            |upper|)
                                                           G166968)))))))))))
                                             NIL))
                                           ((AND (CONSP |it|)
                                             (EQ (QCAR |it|) 'IN)
                                             (PROGN
                                               (setq |ISTMP#1|
                                                (QCDR |it|))
                                               (AND (CONSP |ISTMP#1|)
                                                (PROGN
                                                  (setq |index|
                                                   (QCAR |ISTMP#1|))
                                                  (setq |ISTMP#2|
                                                   (QCDR |ISTMP#1|))
                                                  (AND
                                                   (CONSP |ISTMP#2|)
                                                   (EQ (QCDR |ISTMP#2|)
                                                    NIL)
                                                   (PROGN
                                                     (setq |s|
                                                      (QCAR |ISTMP#2|))
                                                     'T))))))
                                            (CONS
                                             (CONS 'IN
                                              (CONS |index|
                                               (CONS (|mkAtree1| |s|)
                                                NIL)))
                                             NIL))
                                           ((AND (CONSP |it|)
                                             (EQ (QCAR |it|) 'ON)
                                             (PROGN
                                               (setq |ISTMP#1|
                                                (QCDR |it|))
                                               (AND (CONSP |ISTMP#1|)
                                                (PROGN
                                                  (setq |index|
                                                   (QCAR |ISTMP#1|))
                                                  (setq |ISTMP#2|
                                                   (QCDR |ISTMP#1|))
                                                  (AND
                                                   (CONSP |ISTMP#2|)
                                                   (EQ (QCDR |ISTMP#2|)
                                                    NIL)
                                                   (PROGN
                                                     (setq |s|
                                                      (QCAR |ISTMP#2|))
                                                     'T))))))
                                            (CONS
                                             (CONS 'IN
                                              (CONS |index|
                                               (CONS
                                                (|mkAtree1|
                                                 (CONS '|tails|
                                                  (CONS |s| NIL)))
                                                NIL)))
                                             NIL))
                                           ((AND (CONSP |it|)
                                             (EQ (QCAR |it|) 'WHILE)
                                             (PROGN
                                               (setq |ISTMP#1|
                                                (QCDR |it|))
                                               (AND (CONSP |ISTMP#1|)
                                                (EQ (QCDR |ISTMP#1|)
                                                 NIL)
                                                (PROGN
                                                  (setq |b|
                                                   (QCAR |ISTMP#1|))
                                                  'T))))
                                            (CONS
                                             (CONS 'WHILE
                                              (CONS (|mkAtree1| |b|)
                                               NIL))
                                             NIL))
                                           ((AND (CONSP |it|)
                                             (EQ (QCAR |it|) '|\||)
                                             (PROGN
                                               (setq |ISTMP#1|
                                                (QCDR |it|))
                                               (AND (CONSP |ISTMP#1|)
                                                (EQ (QCDR |ISTMP#1|)
                                                 NIL)
                                                (PROGN
                                                  (setq |pred|
                                                   (QCAR |ISTMP#1|))
                                                  'T))))
                                            (CONS
                                             (CONS 'SUCHTHAT
                                              (CONS (|mkAtree1| |pred|)
                                               NIL))
                                             NIL))
                                           ((AND (CONSP |it|)
                                             (PROGN
                                               (setq |op|
                                                (QCAR |it|))
                                               'T)
                                             (|member| |op|
                                              '(VALUE UNTIL)))
                                            NIL))))))))))
             (setq |bodyTree| (|mkAtree1| |body|))
             (setq |iterList|
                      (NCONC |iterList|
                             (PROG (G166979)
                               (setq G166979 NIL)
                               (RETURN
                                 (DO ((G166993 |itrl|
                                       (CDR G166993))
                                      (|it| NIL))
                                     ((OR (ATOM G166993)
                                       (PROGN
                                         (SETQ |it| (CAR G166993))
                                         NIL))
                                      G166979)
                                   (SEQ
                                    (EXIT
                                     (SETQ G166979
                                      (APPEND G166979
                                       (COND
                                         ((AND (CONSP |it|)
                                           (EQ (QCAR |it|) 'STEP))
                                          NIL)
                                         ((AND (CONSP |it|)
                                           (EQ (QCAR |it|) 'IN))
                                          NIL)
                                         ((AND (CONSP |it|)
                                           (EQ (QCAR |it|) 'ON))
                                          NIL)
                                         ((AND (CONSP |it|)
                                           (EQ (QCAR |it|) 'WHILE))
                                          NIL)
                                         ((AND (CONSP |it|)
                                           (PROGN
                                             (setq |op| (QCAR |it|))
                                             (setq |ISTMP#1|
                                              (QCDR |it|))
                                             (AND (CONSP |ISTMP#1|)
                                              (EQ (QCDR |ISTMP#1|) NIL)
                                              (PROGN
                                                (setq |b|
                                                 (QCAR |ISTMP#1|))
                                                'T)))
                                           (|member| |op| '(UNTIL)))
                                          (CONS
                                           (CONS |op|
                                            (CONS (|mkAtree1| |b|) NIL))
                                           NIL))
                                         ((AND (CONSP |it|)
                                           (EQ (QCAR |it|) '|\||)
                                           (PROGN
                                             (setq |ISTMP#1|
                                              (QCDR |it|))
                                             (AND (CONSP |ISTMP#1|)
                                              (EQ (QCDR |ISTMP#1|) NIL)
                                              (PROGN
                                                (setq |pred|
                                                 (QCAR |ISTMP#1|))
                                                'T))))
                                          NIL)
                                         ('T
                                          (|keyedSystemError| 
                 "Unexpected error or improper call to system function %1: %2"
                                           (CONS
                                                                                         "transformCollect"
                                            (CONS
                                                                                           "Unknown type of iterator"
                                             NIL))))))))))))))
             (APPEND |iterList| (CONS |bodyTree| NIL)))))))

;upCOLLECT t ==
;  -- $compilingLoop variable insures that throw to interp-only mode
;  --   goes to the outermost loop.
;  $compilingLoop => upCOLLECT1 t
;  upCOLLECT0 t

(DEFUN |upCOLLECT| (|t|)
  (declare (special |$compilingLoop|))
  (COND (|$compilingLoop| (|upCOLLECT1| |t|)) ('T (|upCOLLECT0| |t|))))

;upCOLLECT0 t ==
;  -- sets up catch point for interpret-code mode
;  $compilingLoop: local := true
;  ms:=CATCH('loopCompiler,upCOLLECT1 t)
;  ms = 'tryInterpOnly => interpOnlyCOLLECT t
;  ms

(DEFUN |upCOLLECT0| (|t|)
  (PROG (|$compilingLoop| |ms|)
    (DECLARE (SPECIAL |$compilingLoop|))
    (RETURN
      (PROGN
        (setq |$compilingLoop| 'T)
        (setq |ms| (CATCH '|loopCompiler| (|upCOLLECT1| |t|)))
        (COND
          ((BOOT-EQUAL |ms| '|tryInterpOnly|)
           (|interpOnlyCOLLECT| |t|))
          ('T |ms|))))))

;upCOLLECT1 t ==
;  t isnt [op,:itrl,body] => nil
;  -- upCOLLECT with compiled body
;  if (target := getTarget t) and not getTarget(body) then
;    if target is [agg,S] and agg in '(List Vector Stream InfiniteTuple) then
;      putTarget(body,S)
;  $interpOnly => interpCOLLECT(op,itrl,body)
;  isStreamCollect itrl => collectStream(t,op,itrl,body)
;  upLoopIters itrl
;  ms:= bottomUpCompile body
;  [m]:= ms
;  for itr in itrl repeat
;    itr is ['UNTIL, pred] => bottomUpCompilePredicate(pred,'"until")
;  mode:= ['Tuple,m]
;  evalCOLLECT(op,rest t,mode)
;  putModeSet(op,[mode])

(DEFUN |upCOLLECT1| (|t|)
  (PROG (|op| |ISTMP#2| |body| |itrl| |target| |agg| S |ms| |m|
              |ISTMP#1| |pred| |mode|)
  (declare (special |$interpOnly|))
    (RETURN
      (SEQ (COND
             ((NULL (AND (CONSP |t|)
                         (PROGN
                           (setq |op| (QCAR |t|))
                           (setq |ISTMP#1| (QCDR |t|))
                           (AND (CONSP |ISTMP#1|)
                                (PROGN
                                  (setq |ISTMP#2|
                                           (REVERSE |ISTMP#1|))
                                  'T)
                                (CONSP |ISTMP#2|)
                                (PROGN
                                  (setq |body| (QCAR |ISTMP#2|))
                                  (setq |itrl| (QCDR |ISTMP#2|))
                                  'T)
                                (PROGN
                                  (setq |itrl| (NREVERSE |itrl|))
                                  'T)))))
              NIL)
             ('T
              (COND
                ((AND (setq |target| (|getTarget| |t|))
                      (NULL (|getTarget| |body|)))
                 (COND
                   ((AND (CONSP |target|)
                         (PROGN
                           (setq |agg| (QCAR |target|))
                           (setq |ISTMP#1| (QCDR |target|))
                           (AND (CONSP |ISTMP#1|)
                                (EQ (QCDR |ISTMP#1|) NIL)
                                (PROGN
                                  (setq S (QCAR |ISTMP#1|))
                                  'T)))
                         (|member| |agg|
                             '(|List| |Vector| |Stream|
                                      |InfiniteTuple|)))
                    (|putTarget| |body| S))
                   ('T NIL))))
              (COND
                (|$interpOnly| (|interpCOLLECT| |op| |itrl| |body|))
                ((|isStreamCollect| |itrl|)
                 (|collectStream| |t| |op| |itrl| |body|))
                ('T (|upLoopIters| |itrl|)
                 (setq |ms| (|bottomUpCompile| |body|))
                 (setq |m| (CAR |ms|))
                 (SEQ (DO ((G167093 |itrl| (CDR G167093))
                           (|itr| NIL))
                          ((OR (ATOM G167093)
                               (PROGN
                                 (SETQ |itr| (CAR G167093))
                                 NIL))
                           NIL)
                        (SEQ (EXIT (COND
                                     ((AND (CONSP |itr|)
                                       (EQ (QCAR |itr|) 'UNTIL)
                                       (PROGN
                                         (setq |ISTMP#1|
                                          (QCDR |itr|))
                                         (AND (CONSP |ISTMP#1|)
                                          (EQ (QCDR |ISTMP#1|) NIL)
                                          (PROGN
                                            (setq |pred|
                                             (QCAR |ISTMP#1|))
                                            'T))))
                                      (EXIT
                                       (|bottomUpCompilePredicate|
                                        |pred| "until")))))))
                      (setq |mode| (CONS '|Tuple| (CONS |m| NIL)))
                      (|evalCOLLECT| |op| (CDR |t|) |mode|)
                      (|putModeSet| |op| (CONS |mode| NIL)))))))))))

;upLoopIters itrl ==
;  -- type analyze iterator loop iterators
;  for iter in itrl repeat
;    iter is ['WHILE,pred] =>
;      bottomUpCompilePredicate(pred,'"while")
;    iter is ['SUCHTHAT,pred] =>
;      bottomUpCompilePredicate(pred,'"|")
;    iter is ['UNTIL,:.] =>
;      NIL      -- handle after body is analyzed
;    iter is ['IN,index,s] =>
;      upLoopIterIN(iter,index,s)
;    iter is ['STEP,index,lower,step,:upperList] =>
;      upLoopIterSTEP(index,lower,step,upperList)
;      -- following is an optimization
;      typeIsASmallInteger(get(index,'mode,$env)) =>
;        RPLACA(iter,'ISTEP)
;    NIL       -- should have error msg here?

(DEFUN |upLoopIters| (|itrl|)
  (PROG (|pred| |s| |ISTMP#1| |index| |ISTMP#2| |lower| |ISTMP#3|
                |step| |upperList|)
  (declare (special |$env|))
    (RETURN
      (SEQ (DO ((G167214 |itrl| (CDR G167214)) (|iter| NIL))
               ((OR (ATOM G167214)
                    (PROGN (SETQ |iter| (CAR G167214)) NIL))
                NIL)
             (SEQ (EXIT (COND
                          ((AND (CONSP |iter|)
                                (EQ (QCAR |iter|) 'WHILE)
                                (PROGN
                                  (setq |ISTMP#1| (QCDR |iter|))
                                  (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)
                                       (PROGN
                                         (setq |pred|
                                          (QCAR |ISTMP#1|))
                                         'T))))
                           (|bottomUpCompilePredicate| |pred|
                               "while"))
                          ((AND (CONSP |iter|)
                                (EQ (QCAR |iter|) 'SUCHTHAT)
                                (PROGN
                                  (setq |ISTMP#1| (QCDR |iter|))
                                  (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)
                                       (PROGN
                                         (setq |pred|
                                          (QCAR |ISTMP#1|))
                                         'T))))
                           (|bottomUpCompilePredicate| |pred|
                               "|"))
                          ((AND (CONSP |iter|)
                                (EQ (QCAR |iter|) 'UNTIL))
                           NIL)
                          ((AND (CONSP |iter|) (EQ (QCAR |iter|) 'IN)
                                (PROGN
                                  (setq |ISTMP#1| (QCDR |iter|))
                                  (AND (CONSP |ISTMP#1|)
                                       (PROGN
                                         (setq |index|
                                          (QCAR |ISTMP#1|))
                                         (setq |ISTMP#2|
                                          (QCDR |ISTMP#1|))
                                         (AND (CONSP |ISTMP#2|)
                                          (EQ (QCDR |ISTMP#2|) NIL)
                                          (PROGN
                                            (setq |s|
                                             (QCAR |ISTMP#2|))
                                            'T))))))
                           (|upLoopIterIN| |iter| |index| |s|))
                          ((AND (CONSP |iter|) (EQ (QCAR |iter|) 'STEP)
                                (PROGN
                                  (setq |ISTMP#1| (QCDR |iter|))
                                  (AND (CONSP |ISTMP#1|)
                                       (PROGN
                                         (setq |index|
                                          (QCAR |ISTMP#1|))
                                         (setq |ISTMP#2|
                                          (QCDR |ISTMP#1|))
                                         (AND (CONSP |ISTMP#2|)
                                          (PROGN
                                            (setq |lower|
                                             (QCAR |ISTMP#2|))
                                            (setq |ISTMP#3|
                                             (QCDR |ISTMP#2|))
                                            (AND (CONSP |ISTMP#3|)
                                             (PROGN
                                               (setq |step|
                                                (QCAR |ISTMP#3|))
                                               (setq |upperList|
                                                (QCDR |ISTMP#3|))
                                               'T))))))))
                           (|upLoopIterSTEP| |index| |lower| |step|
                               |upperList|)
                           (COND
                             ((|typeIsASmallInteger|
                                  (|get| |index| '|mode| |$env|))
                              (RPLACA |iter| 'ISTEP))))
                          ('T NIL)))))))))

;upLoopIterIN(iter,index,s) ==
;  iterMs := bottomUp s
;  null IDENTP index =>  throwKeyedMsg("S2IS0005",[index])
;  if $genValue and first iterMs is ['Union,:.] then
;    v := coerceUnion2Branch getValue s
;    m := objMode v
;    putValue(s,v)
;    putMode(s,m)
;    iterMs := [m]
;    putModeSet(s,iterMs)
;  -- transform segment variable into STEP
;  iterMs is [['Segment,.]] or iterMs is [['UniversalSegment,.]] =>
;    lower := [mkAtreeNode 'lo,s]
;    step := [mkAtreeNode 'incr, s]
;    upperList :=
;      CAAR(iterMs) = 'Segment => [[mkAtreeNode 'hi,s]]
;      NIL
;    upLoopIterSTEP(index,lower,step,upperList)
;    newIter := ['STEP,index,lower,step,:upperList]
;    RPLACA(iter,CAR newIter)
;    RPLACD(iter,CDR newIter)
;  iterMs isnt [['List,ud]] => throwKeyedMsg("S2IS0006",[index])
;  put(index,'mode,ud,$env)
;  mkLocalVar('"the iterator expression",index)

(DEFUN |upLoopIterIN| (|iter| |index| |s|)
  (PROG (|v| |m| |iterMs| |lower| |step| |upperList| |newIter|
             |ISTMP#1| |ISTMP#2| |ud|)
  (declare (special |$env| |$genValue|))
    (RETURN
      (PROGN
        (setq |iterMs| (|bottomUp| |s|))
        (COND
          ((NULL (IDENTP |index|))
           (|throwKeyedMsg|
            (format nil
             "The index variable in an iterator must be a symbol and %1 ~
             is not one.")
            (CONS |index| NIL)))
          ('T
           (COND
             ((AND |$genValue|
                   (PROGN
                     (setq |ISTMP#1| (CAR |iterMs|))
                     (AND (CONSP |ISTMP#1|)
                          (EQ (QCAR |ISTMP#1|) '|Union|))))
              (setq |v| (|coerceUnion2Branch| (|getValue| |s|)))
              (setq |m| (|objMode| |v|)) (|putValue| |s| |v|)
              (|putMode| |s| |m|) (setq |iterMs| (CONS |m| NIL))
              (|putModeSet| |s| |iterMs|)))
           (COND
             ((OR (AND (CONSP |iterMs|) (EQ (QCDR |iterMs|) NIL)
                       (PROGN
                         (setq |ISTMP#1| (QCAR |iterMs|))
                         (AND (CONSP |ISTMP#1|)
                              (EQ (QCAR |ISTMP#1|) '|Segment|)
                              (PROGN
                                (setq |ISTMP#2| (QCDR |ISTMP#1|))
                                (AND (CONSP |ISTMP#2|)
                                     (EQ (QCDR |ISTMP#2|) NIL))))))
                  (AND (CONSP |iterMs|) (EQ (QCDR |iterMs|) NIL)
                       (PROGN
                         (setq |ISTMP#1| (QCAR |iterMs|))
                         (AND (CONSP |ISTMP#1|)
                              (EQ (QCAR |ISTMP#1|) '|UniversalSegment|)
                              (PROGN
                                (setq |ISTMP#2| (QCDR |ISTMP#1|))
                                (AND (CONSP |ISTMP#2|)
                                     (EQ (QCDR |ISTMP#2|) NIL)))))))
              (setq |lower|
                       (CONS (|mkAtreeNode| '|lo|) (CONS |s| NIL)))
              (setq |step|
                       (CONS (|mkAtreeNode| '|incr|) (CONS |s| NIL)))
              (setq |upperList|
                       (COND
                         ((BOOT-EQUAL (CAAR |iterMs|) '|Segment|)
                          (CONS (CONS (|mkAtreeNode| '|hi|)
                                      (CONS |s| NIL))
                                NIL))
                         ('T NIL)))
              (|upLoopIterSTEP| |index| |lower| |step| |upperList|)
              (setq |newIter|
                       (CONS 'STEP
                             (CONS |index|
                                   (CONS |lower|
                                    (CONS |step| |upperList|)))))
              (RPLACA |iter| (CAR |newIter|))
              (RPLACD |iter| (CDR |newIter|)))
             ((NULL (AND (CONSP |iterMs|) (EQ (QCDR |iterMs|) NIL)
                         (PROGN
                           (setq |ISTMP#1| (QCAR |iterMs|))
                           (AND (CONSP |ISTMP#1|)
                                (EQ (QCAR |ISTMP#1|) '|List|)
                                (PROGN
                                  (setq |ISTMP#2| (QCDR |ISTMP#1|))
                                  (AND (CONSP |ISTMP#2|)
                                       (EQ (QCDR |ISTMP#2|) NIL)
                                       (PROGN
                                         (setq |ud|
                                          (QCAR |ISTMP#2|))
                                         'T)))))))
              (|throwKeyedMsg|
               (format nil
                "Axiom cannot iterate with %1 over your form now. Perhaps ~
                 you should try using a conversion to make sure your form is ~
                 a list or stream, for example.")
                (CONS |index| NIL)))
             ('T (|put| |index| '|mode| |ud| |$env|)
              (|mkLocalVar| "the iterator expression"
                  |index|)))))))))

;upLoopIterSTEP(index,lower,step,upperList) ==
;  null IDENTP index => throwKeyedMsg("S2IS0005",[index])
;  ltype := IFCAR bottomUpUseSubdomain(lower)
;  not (typeIsASmallInteger(ltype) or isEqualOrSubDomain(ltype,$Integer))=>
;    throwKeyedMsg("S2IS0007",['"lower"])
;  stype := IFCAR bottomUpUseSubdomain(step)
;  not (typeIsASmallInteger(stype) or isEqualOrSubDomain(stype,$Integer))=>
;    throwKeyedMsg("S2IS0008",NIL)
;  types := [ltype]
;  utype := nil
;  for upper in upperList repeat
;    utype := IFCAR bottomUpUseSubdomain(upper)
;    not (typeIsASmallInteger(utype) or isEqualOrSubDomain(utype,$Integer))=>
;      throwKeyedMsg("S2IS0007",['"upper"])
;  if utype then types := [utype, :types]
;  else types := [stype, :types]
;  type := resolveTypeListAny REMDUP types
;  put(index,'mode,type,$env)
;  mkLocalVar('"the iterator expression",index)

(DEFUN |upLoopIterSTEP| (|index| |lower| |step| |upperList|)
  (PROG (|ltype| |stype| |utype| |types| |type|)
  (declare (special |$env| |$Integer|))
    (RETURN
      (SEQ (COND
             ((NULL (IDENTP |index|))
              (|throwKeyedMsg|
               (format nil
                "The index variable in an iterator must be a symbol and %1 ~
                 is not one.")
               (CONS |index| NIL)))
             ('T
              (setq |ltype|
                       (IFCAR (|bottomUpUseSubdomain| |lower|)))
              (COND
                ((NULL (OR (|typeIsASmallInteger| |ltype|)
                           (|isEqualOrSubDomain| |ltype| |$Integer|)))
                 (|throwKeyedMsg| 
                  "The %1 bound in a loop must be an integer."
                     (CONS "lower" NIL)))
                ('T
                 (setq |stype|
                          (IFCAR (|bottomUpUseSubdomain| |step|)))
                 (COND
                   ((NULL (OR (|typeIsASmallInteger| |stype|)
                              (|isEqualOrSubDomain| |stype| |$Integer|)))
                    (|throwKeyedMsg|
                     "The step value in a loop must be a constant integer."
                      NIL))
                   ('T (setq |types| (CONS |ltype| NIL))
                    (setq |utype| NIL)
                    (DO ((G167292 |upperList| (CDR G167292))
                         (|upper| NIL))
                        ((OR (ATOM G167292)
                             (PROGN
                               (SETQ |upper| (CAR G167292))
                               NIL))
                         NIL)
                      (SEQ (EXIT (PROGN
                                   (setq |utype|
                                    (IFCAR
                                     (|bottomUpUseSubdomain| |upper|)))
                                   (COND
                                     ((NULL
                                       (OR
                                        (|typeIsASmallInteger| |utype|)
                                        (|isEqualOrSubDomain| |utype|
                                         |$Integer|)))
                                      (|throwKeyedMsg| 
                                  "The %1 bound in a loop must be an integer."
                                       (CONS "upper" NIL))))))))
                    (COND
                      (|utype| (setq |types| (CONS |utype| |types|)))
                      ('T (setq |types| (CONS |stype| |types|))))
                    (setq |type|
                             (|resolveTypeListAny| (REMDUP |types|)))
                    (|put| |index| '|mode| |type| |$env|)
                    (|mkLocalVar|
                      "the iterator expression" |index|)))))))))))

;evalCOLLECT(op,[:itrl,body],m) ==
;  iters := [evalLoopIter itr for itr in itrl]
;  bod := getArgValue(body,computedMode body)
;  if bod isnt ['SPADCALL,:.] then bode := ['unwrap,bod]
;  code := timedOptimization asTupleNewCode0 ['COLLECT,:iters,bod]
;  if $genValue then code := wrap timedEVALFUN code
;  putValue(op,objNew(code,m))

(DEFUN |evalCOLLECT| (|op| G167310 |m|)
  (PROG (|LETTMP#1| |body| |itrl| |iters| |bod| |bode| |code|)
  (declare (special |$genValue|))
    (RETURN
      (SEQ (PROGN
             (setq |LETTMP#1| (REVERSE G167310))
             (setq |body| (CAR |LETTMP#1|))
             (setq |itrl| (NREVERSE (CDR |LETTMP#1|)))
             (setq |iters|
                      (PROG (G167325)
                        (setq G167325 NIL)
                        (RETURN
                          (DO ((G167330 |itrl| (CDR G167330))
                               (|itr| NIL))
                              ((OR (ATOM G167330)
                                   (PROGN
                                     (SETQ |itr| (CAR G167330))
                                     NIL))
                               (NREVERSE0 G167325))
                            (SEQ (EXIT (SETQ G167325
                                        (CONS (|evalLoopIter| |itr|)
                                         G167325))))))))
             (setq |bod|
                      (|getArgValue| |body| (|computedMode| |body|)))
             (COND
               ((NULL (AND (CONSP |bod|) (EQ (QCAR |bod|) 'SPADCALL)))
                (setq |bode| (CONS '|unwrap| (CONS |bod| NIL)))))
             (setq |code|
                      (|timedOptimization|
                          (|asTupleNewCode0|
                              (CONS 'COLLECT
                                    (APPEND |iters| (CONS |bod| NIL))))))
             (COND
               (|$genValue|
                   (setq |code| (|wrap| (|timedEVALFUN| |code|)))))
             (|putValue| |op| (mkObj |code| |m|)))))))

;falseFun(x) == nil

(DEFUN |falseFun| (|x|)
 (declare (ignore |x|))
 NIL) 

;evalLoopIter itr ==
;  -- generate code for loop iterator
;  itr is ['STEP,index,lower,step,:upperList] =>
;    ['STEP,getUnname index,getArgValue(lower,$Integer),
;      getArgValue(step,$Integer),
;        :[getArgValue(upper,$Integer) for upper in upperList]]
;  itr is ['ISTEP,index,lower,step,:upperList] =>
;    ['ISTEP,getUnname index,getArgValue(lower,$SmallInteger),
;      getArgValue(step,$SmallInteger),
;        :[getArgValue(upper,$SmallInteger) for upper in upperList]]
;  itr is ['IN,index,s] =>
;    ['IN,getUnname index,getArgValue(s,['List,get(index,'mode,$env)])]
;  (itr is [x,pred]) and (x in '(WHILE UNTIL SUCHTHAT)) =>
;    [x,getArgValue(pred,$Boolean)]

(DEFUN |evalLoopIter| (|itr|)
  (PROG (|lower| |ISTMP#3| |step| |upperList| |index| |ISTMP#2| |s| |x|
                 |ISTMP#1| |pred|)
  (declare (special |$Boolean| |$env| |$SmallInteger| |$Integer|))
    (RETURN
      (SEQ (COND
             ((AND (CONSP |itr|) (EQ (QCAR |itr|) 'STEP)
                   (PROGN
                     (setq |ISTMP#1| (QCDR |itr|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (setq |index| (QCAR |ISTMP#1|))
                            (setq |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (PROGN
                                   (setq |lower| (QCAR |ISTMP#2|))
                                   (setq |ISTMP#3| (QCDR |ISTMP#2|))
                                   (AND (CONSP |ISTMP#3|)
                                    (PROGN
                                      (setq |step| (QCAR |ISTMP#3|))
                                      (setq |upperList|
                                       (QCDR |ISTMP#3|))
                                      'T))))))))
              (CONS 'STEP
                    (CONS (|getUnname| |index|)
                          (CONS (|getArgValue| |lower| |$Integer|)
                                (CONS (|getArgValue| |step| |$Integer|)
                                      (PROG (G167465)
                                        (setq G167465 NIL)
                                        (RETURN
                                          (DO
                                           ((G167470 |upperList|
                                             (CDR G167470))
                                            (|upper| NIL))
                                           ((OR (ATOM G167470)
                                             (PROGN
                                               (SETQ |upper|
                                                (CAR G167470))
                                               NIL))
                                            (NREVERSE0 G167465))
                                            (SEQ
                                             (EXIT
                                              (SETQ G167465
                                               (CONS
                                                (|getArgValue| |upper|
                                                 |$Integer|)
                                                G167465))))))))))))
             ((AND (CONSP |itr|) (EQ (QCAR |itr|) 'ISTEP)
                   (PROGN
                     (setq |ISTMP#1| (QCDR |itr|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (setq |index| (QCAR |ISTMP#1|))
                            (setq |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (PROGN
                                   (setq |lower| (QCAR |ISTMP#2|))
                                   (setq |ISTMP#3| (QCDR |ISTMP#2|))
                                   (AND (CONSP |ISTMP#3|)
                                    (PROGN
                                      (setq |step| (QCAR |ISTMP#3|))
                                      (setq |upperList|
                                       (QCDR |ISTMP#3|))
                                      'T))))))))
              (CONS 'ISTEP
                    (CONS (|getUnname| |index|)
                          (CONS (|getArgValue| |lower| |$SmallInteger|)
                                (CONS (|getArgValue| |step|
                                       |$SmallInteger|)
                                      (PROG (G167480)
                                        (setq G167480 NIL)
                                        (RETURN
                                          (DO
                                           ((G167485 |upperList|
                                             (CDR G167485))
                                            (|upper| NIL))
                                           ((OR (ATOM G167485)
                                             (PROGN
                                               (SETQ |upper|
                                                (CAR G167485))
                                               NIL))
                                            (NREVERSE0 G167480))
                                            (SEQ
                                             (EXIT
                                              (SETQ G167480
                                               (CONS
                                                (|getArgValue| |upper|
                                                 |$SmallInteger|)
                                                G167480))))))))))))
             ((AND (CONSP |itr|) (EQ (QCAR |itr|) 'IN)
                   (PROGN
                     (setq |ISTMP#1| (QCDR |itr|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (setq |index| (QCAR |ISTMP#1|))
                            (setq |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (setq |s| (QCAR |ISTMP#2|))
                                   'T))))))
              (CONS 'IN
                    (CONS (|getUnname| |index|)
                          (CONS (|getArgValue| |s|
                                    (CONS '|List|
                                     (CONS
                                      (|get| |index| '|mode| |$env|)
                                      NIL)))
                                NIL))))
             ((AND (CONSP |itr|)
                   (PROGN
                     (setq |x| (QCAR |itr|))
                     (setq |ISTMP#1| (QCDR |itr|))
                     (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (setq |pred| (QCAR |ISTMP#1|)) 'T)))
                   (|member| |x| '(WHILE UNTIL SUCHTHAT)))
              (CONS |x| (CONS (|getArgValue| |pred| |$Boolean|) NIL))))))))

;interpCOLLECT(op,itrl,body) ==
;  -- interpret-code mode COLLECT handler
;  $collectTypeList: local := NIL
;  $indexVars: local := NIL
;  $indexTypes: local := NIL
;  emptyAtree op
;  emptyAtree itrl
;  emptyAtree body
;  code := ['COLLECT,:[interpIter itr for itr in itrl],
;    interpCOLLECTbody(body,$indexVars,$indexTypes)]
;  value := timedEVALFUN code
;  t :=
;    null value => '(None)
;    last $collectTypeList
;  rm := ['Tuple,t]
;  value := [objValUnwrap coerceInteractive(objNewWrap(v,m),t)
;    for v in value for m in $collectTypeList]
;  putValue(op,objNewWrap(asTupleNew(#value, value),rm))
;  putModeSet(op,[rm])

(DEFUN |interpCOLLECT| (|op| |itrl| |body|)
  (PROG (|$collectTypeList| |$indexVars| |$indexTypes| |code| |t| |rm|
            |value|)
    (DECLARE (SPECIAL |$collectTypeList| |$indexVars| |$indexTypes|))
    (RETURN
      (SEQ (PROGN
             (setq |$collectTypeList| NIL)
             (setq |$indexVars| NIL)
             (setq |$indexTypes| NIL)
             (|emptyAtree| |op|)
             (|emptyAtree| |itrl|)
             (|emptyAtree| |body|)
             (setq |code|
                      (CONS 'COLLECT
                            (APPEND (PROG (G167523)
                                      (setq G167523 NIL)
                                      (RETURN
                                        (DO
                                         ((G167528 |itrl|
                                           (CDR G167528))
                                          (|itr| NIL))
                                         ((OR (ATOM G167528)
                                           (PROGN
                                             (SETQ |itr|
                                              (CAR G167528))
                                             NIL))
                                          (NREVERSE0 G167523))
                                          (SEQ
                                           (EXIT
                                            (SETQ G167523
                                             (CONS (|interpIter| |itr|)
                                              G167523)))))))
                                    (CONS
                                     (|interpCOLLECTbody| |body|
                                      |$indexVars| |$indexTypes|)
                                     NIL))))
             (setq |value| (|timedEVALFUN| |code|))
             (setq |t|
                      (COND
                        ((NULL |value|) '(|None|))
                        ('T (|last| |$collectTypeList|))))
             (setq |rm| (CONS '|Tuple| (CONS |t| NIL)))
             (setq |value|
                      (PROG (G167539)
                        (setq G167539 NIL)
                        (RETURN
                          (DO ((G167545 |value| (CDR G167545))
                               (|v| NIL)
                               (G167546 |$collectTypeList|
                                   (CDR G167546))
                               (|m| NIL))
                              ((OR (ATOM G167545)
                                   (PROGN
                                     (SETQ |v| (CAR G167545))
                                     NIL)
                                   (ATOM G167546)
                                   (PROGN
                                     (SETQ |m| (CAR G167546))
                                     NIL))
                               (NREVERSE0 G167539))
                            (SEQ (EXIT (SETQ G167539
                                        (CONS
                                         (|objValUnwrap|
                                          (|coerceInteractive|
                                           (mkObjWrap |v| |m|) |t|))
                                         G167539))))))))
             (|putValue| |op|
                         (mkObjWrap
                             (|asTupleNew| (|#| |value|) |value|) |rm|))
             (|putModeSet| |op| (CONS |rm| NIL)))))))

;interpIter itr ==
;  -- interpret loop iterator
;  itr is ['STEP,index,lower,step,:upperList] =>
;    $indexVars:= [getUnname index,:$indexVars]
;    [m]:= bottomUp lower
;    $indexTypes:= [m,:$indexTypes]
;    for up in upperList repeat bottomUp up
;    ['STEP,getUnname index,getArgValue(lower,$Integer),
;      getArgValue(step,$Integer),
;        :[getArgValue(upper,$Integer) for upper in upperList]]
;  itr is ['ISTEP,index,lower,step,:upperList] =>
;    $indexVars:= [getUnname index,:$indexVars]
;    [m]:= bottomUp lower
;    $indexTypes:= [m,:$indexTypes]
;    for up in upperList repeat bottomUp up
;    ['ISTEP,getUnname index,getArgValue(lower,$SmallInteger),
;      getArgValue(step,$SmallInteger),
;        :[getArgValue(upper,$SmallInteger) for upper in upperList]]
;  itr is ['IN,index,s] =>
;    $indexVars:=[getUnname index,:$indexVars]
;    [m]:= bottomUp s
;    m isnt ['List,um] => throwKeyedMsg("S2IS0009",[m])
;    $indexTypes:=[um,:$indexTypes]
;    ['IN,getUnname index,getArgValue(s,m)]
;  (itr is [x,pred]) and (x in '(WHILE UNTIL SUCHTHAT)) =>
;    [x,interpLoop(pred,$indexVars,$indexTypes,$Boolean)]

(DEFUN |interpIter| (|itr|)
  (PROG (|lower| |ISTMP#3| |step| |upperList| |index| |ISTMP#2| |s|
                 |LETTMP#1| |m| |um| |x| |ISTMP#1| |pred|)
  (declare (special |$Boolean| |$indexTypes| |$indexVars| |$SmallInteger|
                    |$Integer|))
    (RETURN
      (SEQ (COND
             ((AND (CONSP |itr|) (EQ (QCAR |itr|) 'STEP)
                   (PROGN
                     (setq |ISTMP#1| (QCDR |itr|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (setq |index| (QCAR |ISTMP#1|))
                            (setq |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (PROGN
                                   (setq |lower| (QCAR |ISTMP#2|))
                                   (setq |ISTMP#3| (QCDR |ISTMP#2|))
                                   (AND (CONSP |ISTMP#3|)
                                    (PROGN
                                      (setq |step| (QCAR |ISTMP#3|))
                                      (setq |upperList|
                                       (QCDR |ISTMP#3|))
                                      'T))))))))
              (setq |$indexVars|
                       (CONS (|getUnname| |index|) |$indexVars|))
              (setq |LETTMP#1| (|bottomUp| |lower|))
              (setq |m| (CAR |LETTMP#1|))
              (setq |$indexTypes| (CONS |m| |$indexTypes|))
              (DO ((G167709 |upperList| (CDR G167709)) (|up| NIL))
                  ((OR (ATOM G167709)
                       (PROGN (SETQ |up| (CAR G167709)) NIL))
                   NIL)
                (SEQ (EXIT (|bottomUp| |up|))))
              (CONS 'STEP
                    (CONS (|getUnname| |index|)
                          (CONS (|getArgValue| |lower| |$Integer|)
                                (CONS (|getArgValue| |step| |$Integer|)
                                      (PROG (G167719)
                                        (setq G167719 NIL)
                                        (RETURN
                                          (DO
                                           ((G167724 |upperList|
                                             (CDR G167724))
                                            (|upper| NIL))
                                           ((OR (ATOM G167724)
                                             (PROGN
                                               (SETQ |upper|
                                                (CAR G167724))
                                               NIL))
                                            (NREVERSE0 G167719))
                                            (SEQ
                                             (EXIT
                                              (SETQ G167719
                                               (CONS
                                                (|getArgValue| |upper|
                                                 |$Integer|)
                                                G167719))))))))))))
             ((AND (CONSP |itr|) (EQ (QCAR |itr|) 'ISTEP)
                   (PROGN
                     (setq |ISTMP#1| (QCDR |itr|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (setq |index| (QCAR |ISTMP#1|))
                            (setq |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (PROGN
                                   (setq |lower| (QCAR |ISTMP#2|))
                                   (setq |ISTMP#3| (QCDR |ISTMP#2|))
                                   (AND (CONSP |ISTMP#3|)
                                    (PROGN
                                      (setq |step| (QCAR |ISTMP#3|))
                                      (setq |upperList|
                                       (QCDR |ISTMP#3|))
                                      'T))))))))
              (setq |$indexVars|
                       (CONS (|getUnname| |index|) |$indexVars|))
              (setq |LETTMP#1| (|bottomUp| |lower|))
              (setq |m| (CAR |LETTMP#1|))
              (setq |$indexTypes| (CONS |m| |$indexTypes|))
              (DO ((G167733 |upperList| (CDR G167733)) (|up| NIL))
                  ((OR (ATOM G167733)
                       (PROGN (SETQ |up| (CAR G167733)) NIL))
                   NIL)
                (SEQ (EXIT (|bottomUp| |up|))))
              (CONS 'ISTEP
                    (CONS (|getUnname| |index|)
                          (CONS (|getArgValue| |lower| |$SmallInteger|)
                                (CONS (|getArgValue| |step|
                                       |$SmallInteger|)
                                      (PROG (G167743)
                                        (setq G167743 NIL)
                                        (RETURN
                                          (DO
                                           ((G167748 |upperList|
                                             (CDR G167748))
                                            (|upper| NIL))
                                           ((OR (ATOM G167748)
                                             (PROGN
                                               (SETQ |upper|
                                                (CAR G167748))
                                               NIL))
                                            (NREVERSE0 G167743))
                                            (SEQ
                                             (EXIT
                                              (SETQ G167743
                                               (CONS
                                                (|getArgValue| |upper|
                                                 |$SmallInteger|)
                                                G167743))))))))))))
             ((AND (CONSP |itr|) (EQ (QCAR |itr|) 'IN)
                   (PROGN
                     (setq |ISTMP#1| (QCDR |itr|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (setq |index| (QCAR |ISTMP#1|))
                            (setq |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (setq |s| (QCAR |ISTMP#2|))
                                   'T))))))
              (setq |$indexVars|
                       (CONS (|getUnname| |index|) |$indexVars|))
              (setq |LETTMP#1| (|bottomUp| |s|))
              (setq |m| (CAR |LETTMP#1|))
              (COND
                ((NULL (AND (CONSP |m|) (EQ (QCAR |m|) '|List|)
                            (PROGN
                              (setq |ISTMP#1| (QCDR |m|))
                              (AND (CONSP |ISTMP#1|)
                                   (EQ (QCDR |ISTMP#1|) NIL)
                                   (PROGN
                                     (setq |um| (QCAR |ISTMP#1|))
                                     'T)))))
                 (|throwKeyedMsg|
                  (format nil
                   "Axiom can only iterate over lists now and you supplied an ~
                    object of type %1p .")
                   (CONS |m| NIL)))
                ('T (setq |$indexTypes| (CONS |um| |$indexTypes|))
                 (CONS 'IN
                       (CONS (|getUnname| |index|)
                             (CONS (|getArgValue| |s| |m|) NIL))))))
             ((AND (CONSP |itr|)
                   (PROGN
                     (setq |x| (QCAR |itr|))
                     (setq |ISTMP#1| (QCDR |itr|))
                     (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (setq |pred| (QCAR |ISTMP#1|)) 'T)))
                   (|member| |x| '(WHILE UNTIL SUCHTHAT)))
              (CONS |x|
                    (CONS (|interpLoop| |pred| |$indexVars|
                              |$indexTypes| |$Boolean|)
                          NIL))))))))

;interpOnlyCOLLECT t ==
;  -- called when compilation failed in COLLECT body, not in compiling map
;  $genValue: local := true
;  $interpOnly: local := true
;  upCOLLECT t

(DEFUN |interpOnlyCOLLECT| (|t|)
  (PROG (|$genValue| |$interpOnly|)
    (DECLARE (SPECIAL |$genValue| |$interpOnly|))
    (RETURN
      (PROGN
        (setq |$genValue| 'T)
        (setq |$interpOnly| 'T)
        (|upCOLLECT| |t|)))))

;interpCOLLECTbody(expr,indexList,indexTypes) ==
;  -- generate code for interpret-code collect
;  ['interpCOLLECTbodyIter,MKQ expr,MKQ indexList,['LIST,:indexList],
;    MKQ indexTypes]

(DEFUN |interpCOLLECTbody| (|expr| |indexList| |indexTypes|)
  (CONS '|interpCOLLECTbodyIter|
        (CONS (MKQ |expr|)
              (CONS (MKQ |indexList|)
                    (CONS (CONS 'LIST |indexList|)
                          (CONS (MKQ |indexTypes|) NIL))))))

;interpCOLLECTbodyIter(exp,indexList,indexVals,indexTypes) ==
;  -- execute interpret-code collect body.  keeps list of type of
;  --  elements in list in $collectTypeList.
;  emptyAtree exp
;  for i in indexList for val in indexVals for type in indexTypes repeat
;    put(i,'value,objNewWrap(val,type),$env)
;  [m]:=bottomUp exp
;  $collectTypeList:=
;    null $collectTypeList => [rm:=m]
;    [:$collectTypeList,rm:=resolveTT(m,last $collectTypeList)]
;  null rm => throwKeyedMsg("S2IS0010",NIL)
;  value:=
;    rm ^= m => coerceInteractive(getValue exp,rm)
;    getValue exp
;  objValUnwrap(value)

(DEFUN |interpCOLLECTbodyIter|
       (|exp| |indexList| |indexVals| |indexTypes|)
  (PROG (|LETTMP#1| |m| |rm| |value|)
  (declare (special |$collectTypeList| |$env|))
    (RETURN
      (SEQ (PROGN
             (|emptyAtree| |exp|)
             (DO ((G167820 |indexList| (CDR G167820)) (|i| NIL)
                  (G167821 |indexVals| (CDR G167821)) (|val| NIL)
                  (G167822 |indexTypes| (CDR G167822))
                  (|type| NIL))
                 ((OR (ATOM G167820)
                      (PROGN (SETQ |i| (CAR G167820)) NIL)
                      (ATOM G167821)
                      (PROGN (SETQ |val| (CAR G167821)) NIL)
                      (ATOM G167822)
                      (PROGN (SETQ |type| (CAR G167822)) NIL))
                  NIL)
               (SEQ (EXIT (|put| |i| '|value|
                                 (mkObjWrap |val| |type|) |$env|))))
             (setq |LETTMP#1| (|bottomUp| |exp|))
             (setq |m| (CAR |LETTMP#1|))
             (setq |$collectTypeList|
                      (COND
                        ((NULL |$collectTypeList|)
                         (CONS (setq |rm| |m|) NIL))
                        ('T
                         (APPEND |$collectTypeList|
                                 (CONS (setq |rm|
                                        (|resolveTT| |m|
                                         (|last| |$collectTypeList|)))
                                       NIL)))))
             (COND
               ((NULL |rm|)
                 (|throwKeyedMsg| "Cannot resolve types in collect body." NIL))
               ('T
                (setq |value|
                         (COND
                           ((NEQUAL |rm| |m|)
                            (|coerceInteractive| (|getValue| |exp|)
                                |rm|))
                           ('T (|getValue| |exp|))))
                (|objValUnwrap| |value|))))))))

;--% Stream Collect functions
;isStreamCollect itrl ==
;  -- calls bottomUp on iterators and if any of them are streams
;  -- then whole shebang is a stream
;  isStream := false
;  for itr in itrl until isStream repeat
;    itr is ['IN,.,s] =>
;      iterMs := bottomUp s
;      iterMs is [['Stream,:.]] => isStream := true
;      iterMs is [['InfiniteTuple,:.]] => isStream := true
;      iterMs is [['UniversalSegment,:.]] => isStream := true
;    itr is ['STEP,.,.,.] => isStream := true
;  isStream

(DEFUN |isStreamCollect| (|itrl|)
  (PROG (|s| |iterMs| |ISTMP#1| |ISTMP#2| |ISTMP#3| |isStream|)
    (RETURN
      (SEQ (PROGN
             (setq |isStream| NIL)
             (DO ((G167896 |itrl| (CDR G167896)) (|itr| NIL)
                  (G167897 NIL |isStream|))
                 ((OR (ATOM G167896)
                      (PROGN (SETQ |itr| (CAR G167896)) NIL)
                      G167897)
                  NIL)
               (SEQ (EXIT (COND
                            ((AND (CONSP |itr|) (EQ (QCAR |itr|) 'IN)
                                  (PROGN
                                    (setq |ISTMP#1| (QCDR |itr|))
                                    (AND (CONSP |ISTMP#1|)
                                     (PROGN
                                       (setq |ISTMP#2|
                                        (QCDR |ISTMP#1|))
                                       (AND (CONSP |ISTMP#2|)
                                        (EQ (QCDR |ISTMP#2|) NIL)
                                        (PROGN
                                          (setq |s|
                                           (QCAR |ISTMP#2|))
                                          'T))))))
                             (setq |iterMs| (|bottomUp| |s|))
                             (COND
                               ((AND (CONSP |iterMs|)
                                     (EQ (QCDR |iterMs|) NIL)
                                     (PROGN
                                       (setq |ISTMP#1|
                                        (QCAR |iterMs|))
                                       (AND (CONSP |ISTMP#1|)
                                        (EQ (QCAR |ISTMP#1|) '|Stream|))))
                                (setq |isStream| 'T))
                               ((AND (CONSP |iterMs|)
                                     (EQ (QCDR |iterMs|) NIL)
                                     (PROGN
                                       (setq |ISTMP#1|
                                        (QCAR |iterMs|))
                                       (AND (CONSP |ISTMP#1|)
                                        (EQ (QCAR |ISTMP#1|)
                                         '|InfiniteTuple|))))
                                (setq |isStream| 'T))
                               ((AND (CONSP |iterMs|)
                                     (EQ (QCDR |iterMs|) NIL)
                                     (PROGN
                                       (setq |ISTMP#1|
                                        (QCAR |iterMs|))
                                       (AND (CONSP |ISTMP#1|)
                                        (EQ (QCAR |ISTMP#1|)
                                         '|UniversalSegment|))))
                                (setq |isStream| 'T))))
                            ((AND (CONSP |itr|) (EQ (QCAR |itr|) 'STEP)
                                  (PROGN
                                    (setq |ISTMP#1| (QCDR |itr|))
                                    (AND (CONSP |ISTMP#1|)
                                     (PROGN
                                       (setq |ISTMP#2|
                                        (QCDR |ISTMP#1|))
                                       (AND (CONSP |ISTMP#2|)
                                        (PROGN
                                          (setq |ISTMP#3|
                                           (QCDR |ISTMP#2|))
                                          (AND (CONSP |ISTMP#3|)
                                           (EQ (QCDR |ISTMP#3|) NIL))))))))
                             (setq |isStream| 'T))))))
             |isStream|)))))

;collectStream(t,op,itrl,body) ==
;  v := CATCH('loopCompiler,collectStream1(t,op,itrl,body))
;  v = 'tryInterpOnly => throwKeyedMsg("S2IS0011",NIL)
;  v

(DEFUN |collectStream| (|t| |op| |itrl| |body|)
  (PROG (|v|)
    (RETURN
      (PROGN
        (setq |v|
                 (CATCH '|loopCompiler|
                   (|collectStream1| |t| |op| |itrl| |body|)))
        (COND
          ((BOOT-EQUAL |v| '|tryInterpOnly|)
           (|throwKeyedMsg|
            "Interpret-Code mode is not supported for stream bodies."
             NIL))
          ('T |v|))))))

;collectStream1(t,op,itrl,body) ==
;  $indexVars:local := NIL
;  upStreamIters itrl
;  if #$indexVars = 1 then mode:=collectOneStream(t,op,itrl,body)
;  else mode:=collectSeveralStreams(t,op,itrl,body)
;  putModeSet(op,[mode])

(DEFUN |collectStream1| (|t| |op| |itrl| |body|)
  (PROG (|$indexVars| |mode|)
    (DECLARE (SPECIAL |$indexVars|))
    (RETURN
      (PROGN
        (setq |$indexVars| NIL)
        (|upStreamIters| |itrl|)
        (COND
          ((EQL (|#| |$indexVars|) 1)
           (setq |mode| (|collectOneStream| |t| |op| |itrl| |body|)))
          ('T
           (setq |mode|
                    (|collectSeveralStreams| |t| |op| |itrl| |body|))))
        (|putModeSet| |op| (CONS |mode| NIL))))))

;upStreamIters itrl ==
;  -- type analyze stream collect loop iterators
;  for iter in itrl repeat
;    iter is ['IN,index,s] =>
;      upStreamIterIN(iter,index,s)
;    iter is ['STEP,index,lower,step,:upperList] =>
;      upStreamIterSTEP(index,lower,step,upperList)

(DEFUN |upStreamIters| (|itrl|)
  (PROG (|s| |ISTMP#1| |index| |ISTMP#2| |lower| |ISTMP#3| |step|
             |upperList|)
    (RETURN
      (SEQ (DO ((G168016 |itrl| (CDR G168016)) (|iter| NIL))
               ((OR (ATOM G168016)
                    (PROGN (SETQ |iter| (CAR G168016)) NIL))
                NIL)
             (SEQ (EXIT (COND
                          ((AND (CONSP |iter|) (EQ (QCAR |iter|) 'IN)
                                (PROGN
                                  (setq |ISTMP#1| (QCDR |iter|))
                                  (AND (CONSP |ISTMP#1|)
                                       (PROGN
                                         (setq |index|
                                          (QCAR |ISTMP#1|))
                                         (setq |ISTMP#2|
                                          (QCDR |ISTMP#1|))
                                         (AND (CONSP |ISTMP#2|)
                                          (EQ (QCDR |ISTMP#2|) NIL)
                                          (PROGN
                                            (setq |s|
                                             (QCAR |ISTMP#2|))
                                            'T))))))
                           (|upStreamIterIN| |iter| |index| |s|))
                          ((AND (CONSP |iter|) (EQ (QCAR |iter|) 'STEP)
                                (PROGN
                                  (setq |ISTMP#1| (QCDR |iter|))
                                  (AND (CONSP |ISTMP#1|)
                                       (PROGN
                                         (setq |index|
                                          (QCAR |ISTMP#1|))
                                         (setq |ISTMP#2|
                                          (QCDR |ISTMP#1|))
                                         (AND (CONSP |ISTMP#2|)
                                          (PROGN
                                            (setq |lower|
                                             (QCAR |ISTMP#2|))
                                            (setq |ISTMP#3|
                                             (QCDR |ISTMP#2|))
                                            (AND (CONSP |ISTMP#3|)
                                             (PROGN
                                               (setq |step|
                                                (QCAR |ISTMP#3|))
                                               (setq |upperList|
                                                (QCDR |ISTMP#3|))
                                               'T))))))))
                           (|upStreamIterSTEP| |index| |lower| |step|
                               |upperList|))))))))))

;upStreamIterIN(iter,index,s) ==
;  iterMs := bottomUp s
;  -- transform segment variable into STEP
;  iterMs is [['Segment,.]] or iterMs is [['UniversalSegment,.]] =>
;    lower := [mkAtreeNode 'lo, s]
;    step := [mkAtreeNode 'incr, s]
;    upperList :=
;      CAAR(iterMs) = 'Segment => [[mkAtreeNode 'hi,s]]
;      NIL
;    upStreamIterSTEP(index,lower,step,upperList)
;    newIter := ['STEP,index,lower,step,:upperList]
;    RPLACA(iter,CAR newIter)
;    RPLACD(iter,CDR newIter)
;  (iterMs isnt [['List,ud]]) and (iterMs isnt [['Stream,ud]])
;    and (iterMs isnt [['InfinitTuple, ud]]) =>
;      throwKeyedMsg("S2IS0006",[index])
;  put(index,'mode,ud,$env)
;  mkLocalVar('"the iterator expression",index)
;  s :=
;    iterMs is [['List,ud],:.] =>
;      form:=[mkAtreeNode 'pretend, [mkAtreeNode 'COERCE,s,['Stream,ud]],
;             ['InfiniteTuple, ud]]
;      bottomUp form
;      form
;    s
;  $indexVars:= [[index,:s],:$indexVars]

(DEFUN |upStreamIterIN| (|iter| |index| |s|)
  (PROG (|iterMs| |lower| |step| |upperList| |newIter| |ISTMP#1|
            |ISTMP#2| |ud| |form|)
  (declare (special |$indexVars| |$env|))
    (RETURN
      (PROGN
        (setq |iterMs| (|bottomUp| |s|))
        (COND
          ((OR (AND (CONSP |iterMs|) (EQ (QCDR |iterMs|) NIL)
                    (PROGN
                      (setq |ISTMP#1| (QCAR |iterMs|))
                      (AND (CONSP |ISTMP#1|)
                           (EQ (QCAR |ISTMP#1|) '|Segment|)
                           (PROGN
                             (setq |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (CONSP |ISTMP#2|)
                                  (EQ (QCDR |ISTMP#2|) NIL))))))
               (AND (CONSP |iterMs|) (EQ (QCDR |iterMs|) NIL)
                    (PROGN
                      (setq |ISTMP#1| (QCAR |iterMs|))
                      (AND (CONSP |ISTMP#1|)
                           (EQ (QCAR |ISTMP#1|) '|UniversalSegment|)
                           (PROGN
                             (setq |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (CONSP |ISTMP#2|)
                                  (EQ (QCDR |ISTMP#2|) NIL)))))))
           (setq |lower|
                    (CONS (|mkAtreeNode| '|lo|) (CONS |s| NIL)))
           (setq |step|
                    (CONS (|mkAtreeNode| '|incr|) (CONS |s| NIL)))
           (setq |upperList|
                    (COND
                      ((BOOT-EQUAL (CAAR |iterMs|) '|Segment|)
                       (CONS (CONS (|mkAtreeNode| '|hi|)
                                   (CONS |s| NIL))
                             NIL))
                      ('T NIL)))
           (|upStreamIterSTEP| |index| |lower| |step| |upperList|)
           (setq |newIter|
                    (CONS 'STEP
                          (CONS |index|
                                (CONS |lower|
                                      (CONS |step| |upperList|)))))
           (RPLACA |iter| (CAR |newIter|))
           (RPLACD |iter| (CDR |newIter|)))
          ((AND (NULL (AND (CONSP |iterMs|) (EQ (QCDR |iterMs|) NIL)
                           (PROGN
                             (setq |ISTMP#1| (QCAR |iterMs|))
                             (AND (CONSP |ISTMP#1|)
                                  (EQ (QCAR |ISTMP#1|) '|List|)
                                  (PROGN
                                    (setq |ISTMP#2|
                                     (QCDR |ISTMP#1|))
                                    (AND (CONSP |ISTMP#2|)
                                     (EQ (QCDR |ISTMP#2|) NIL)
                                     (PROGN
                                       (setq |ud| (QCAR |ISTMP#2|))
                                       'T)))))))
                (NULL (AND (CONSP |iterMs|) (EQ (QCDR |iterMs|) NIL)
                           (PROGN
                             (setq |ISTMP#1| (QCAR |iterMs|))
                             (AND (CONSP |ISTMP#1|)
                                  (EQ (QCAR |ISTMP#1|) '|Stream|)
                                  (PROGN
                                    (setq |ISTMP#2|
                                     (QCDR |ISTMP#1|))
                                    (AND (CONSP |ISTMP#2|)
                                     (EQ (QCDR |ISTMP#2|) NIL)
                                     (PROGN
                                       (setq |ud| (QCAR |ISTMP#2|))
                                       'T)))))))
                (NULL (AND (CONSP |iterMs|) (EQ (QCDR |iterMs|) NIL)
                           (PROGN
                             (setq |ISTMP#1| (QCAR |iterMs|))
                             (AND (CONSP |ISTMP#1|)
                                  (EQ (QCAR |ISTMP#1|) '|InfinitTuple|)
                                  (PROGN
                                    (setq |ISTMP#2|
                                     (QCDR |ISTMP#1|))
                                    (AND (CONSP |ISTMP#2|)
                                     (EQ (QCDR |ISTMP#2|) NIL)
                                     (PROGN
                                       (setq |ud| (QCAR |ISTMP#2|))
                                       'T))))))))
           (|throwKeyedMsg|
            (format nil
             "Axiom cannot iterate with %1 over your form now. Perhaps you ~
              should try using a conversion to make sure your form is a ~
              list or stream, for example.")
            (CONS |index| NIL)))
          ('T (|put| |index| '|mode| |ud| |$env|)
           (|mkLocalVar| "the iterator expression"
               |index|)
           (setq |s|
                    (COND
                      ((AND (CONSP |iterMs|)
                            (PROGN
                              (setq |ISTMP#1| (QCAR |iterMs|))
                              (AND (CONSP |ISTMP#1|)
                                   (EQ (QCAR |ISTMP#1|) '|List|)
                                   (PROGN
                                     (setq |ISTMP#2|
                                      (QCDR |ISTMP#1|))
                                     (AND (CONSP |ISTMP#2|)
                                      (EQ (QCDR |ISTMP#2|) NIL)
                                      (PROGN
                                        (setq |ud| (QCAR |ISTMP#2|))
                                        'T))))))
                       (setq |form|
                                (CONS (|mkAtreeNode| '|pretend|)
                                      (CONS
                                       (CONS (|mkAtreeNode| 'COERCE)
                                        (CONS |s|
                                         (CONS
                                          (CONS '|Stream|
                                           (CONS |ud| NIL))
                                          NIL)))
                                       (CONS
                                        (CONS '|InfiniteTuple|
                                         (CONS |ud| NIL))
                                        NIL))))
                       (|bottomUp| |form|) |form|)
                      ('T |s|)))
           (setq |$indexVars|
                    (CONS (CONS |index| |s|) |$indexVars|))))))))

;upStreamIterSTEP(index,lower,step,upperList) ==
;  null isEqualOrSubDomain(ltype := IFCAR bottomUpUseSubdomain(lower),
;    $Integer) => throwKeyedMsg("S2IS0007",['"lower"])
;  null isEqualOrSubDomain(stype := IFCAR bottomUpUseSubdomain(step),
;    $Integer) => throwKeyedMsg("S2IS0008",NIL)
;  for upper in upperList repeat
;    null isEqualOrSubDomain(IFCAR bottomUpUseSubdomain(upper),
;      $Integer) => throwKeyedMsg("S2IS0007",['"upper"])
;  put(index,'mode,type := resolveTT(ltype,stype),$env)
;  null type => throwKeyedMsg("S2IS0010", nil)
;  mkLocalVar('"the iterator expression",index)
;  s :=
;    null upperList =>
;      -- create the function that does the appropriate incrementing
;      genFun := 'generate
;      form := [mkAtreeNode genFun,
;        [[mkAtreeNode 'Dollar, ['IncrementingMaps,type],
;          mkAtreeNode 'incrementBy],step],lower]
;      bottomUp form
;      form
;    form := [mkAtreeNode 'SEGMENT,lower,first upperList]
;    putTarget(form,['Segment,type])
;    form := [mkAtreeNode 'construct,form]
;    putTarget(form,['List,['Segment,type]])
;    form := [mkAtreeNode 'expand,form]
;    putTarget(form,'(List (Integer)))
;    form:=[mkAtreeNode 'pretend, [mkAtreeNode 'COERCE,form,['Stream,$Integer]],
;           ['InfiniteTuple, $Integer]]
;    bottomUp form
;    form
;  $indexVars:= [[index,:s],:$indexVars]

(DEFUN |upStreamIterSTEP| (|index| |lower| |step| |upperList|)
  (PROG (|ltype| |stype| |type| |genFun| |form| |s|)
  (declare (special |$indexVars| |$Integer| |$env| |$Integer|))
    (RETURN
      (SEQ (COND
             ((NULL (|isEqualOrSubDomain|
                        (setq |ltype|
                                 (IFCAR (|bottomUpUseSubdomain|
                                         |lower|)))
                        |$Integer|))
              (|throwKeyedMsg|
                  "The %1 bound in a loop must be an integer."
                  (CONS "lower" NIL)))
             ((NULL (|isEqualOrSubDomain|
                        (setq |stype|
                                 (IFCAR (|bottomUpUseSubdomain| |step|)))
                        |$Integer|))
              (|throwKeyedMsg| 
               "The step value in a loop must be a constant integer."
               NIL))
             ('T
              (SEQ (DO ((G168126 |upperList| (CDR G168126))
                        (|upper| NIL))
                       ((OR (ATOM G168126)
                            (PROGN (SETQ |upper| (CAR G168126)) NIL))
                        NIL)
                     (SEQ (EXIT (COND
                                  ((NULL
                                    (|isEqualOrSubDomain|
                                     (IFCAR
                                      (|bottomUpUseSubdomain| |upper|))
                                     |$Integer|))
                                   (EXIT
                                    (|throwKeyedMsg| 
                              "The %1 bound in a loop must be an integer."
                                     (CONS "upper" NIL))))))))
                   (|put| |index| '|mode|
                          (setq |type|
                                   (|resolveTT| |ltype| |stype|))
                          |$env|)
                   (COND
                     ((NULL |type|)
                      (EXIT
                       (|throwKeyedMsg| 
                        "Cannot resolve types in collect body."
                        NIL))))
                   (|mkLocalVar| "the iterator expression"
                       |index|)
                   (setq |s|
                            (COND
                              ((NULL |upperList|)
                               (setq |genFun| '|generate|)
                               (setq |form|
                                        (CONS (|mkAtreeNode| |genFun|)
                                         (CONS
                                          (CONS
                                           (CONS
                                            (|mkAtreeNode| '|Dollar|)
                                            (CONS
                                             (CONS '|IncrementingMaps|
                                              (CONS |type| NIL))
                                             (CONS
                                              (|mkAtreeNode|
                                               '|incrementBy|)
                                              NIL)))
                                           (CONS |step| NIL))
                                          (CONS |lower| NIL))))
                               (|bottomUp| |form|) |form|)
                              ('T
                               (setq |form|
                                        (CONS (|mkAtreeNode| 'SEGMENT)
                                         (CONS |lower|
                                          (CONS (CAR |upperList|) NIL))))
                               (|putTarget| |form|
                                   (CONS '|Segment| (CONS |type| NIL)))
                               (setq |form|
                                        (CONS
                                         (|mkAtreeNode| '|construct|)
                                         (CONS |form| NIL)))
                               (|putTarget| |form|
                                   (CONS '|List|
                                    (CONS
                                     (CONS '|Segment|
                                      (CONS |type| NIL))
                                     NIL)))
                               (setq |form|
                                        (CONS (|mkAtreeNode| '|expand|)
                                         (CONS |form| NIL)))
                               (|putTarget| |form|
                                   '(|List| (|Integer|)))
                               (setq |form|
                                        (CONS
                                         (|mkAtreeNode| '|pretend|)
                                         (CONS
                                          (CONS (|mkAtreeNode| 'COERCE)
                                           (CONS |form|
                                            (CONS
                                             (CONS '|Stream|
                                              (CONS |$Integer| NIL))
                                             NIL)))
                                          (CONS
                                           (CONS '|InfiniteTuple|
                                            (CONS |$Integer| NIL))
                                           NIL))))
                               (|bottomUp| |form|) |form|)))
                   (setq |$indexVars|
                            (CONS (CONS |index| |s|) |$indexVars|)))))))))

;collectOneStream(t,op,itrl,body) ==
;  -- build stream collect for case of iterating over a single stream
;  --  In this case we don't need to build records
;  form := mkAndApplyPredicates itrl
;  bodyVec := mkIterFun(CAR $indexVars,body,$localVars)
;  form := [mkAtreeNode 'map,bodyVec,form]
;  bottomUp form
;  val := getValue form
;  m := objMode val
;  m isnt ['Stream, ud] and m isnt ['InfiniteTuple, ud] =>
;    systemError '"Not a Stream"
;  newVal := objNew(objVal val, ['InfiniteTuple, ud])
;  putValue(op,newVal)
;  objMode newVal

(DEFUN |collectOneStream| (|t| |op| |itrl| |body|)
  (declare (ignore |t|))
  (PROG (|bodyVec| |form| |val| |m| |ISTMP#1| |ud| |newVal|)
  (declare (special |$localVars| |$indexVars|))
    (RETURN
      (PROGN
        (setq |form| (|mkAndApplyPredicates| |itrl|))
        (setq |bodyVec|
                 (|mkIterFun| (CAR |$indexVars|) |body| |$localVars|))
        (setq |form|
                 (CONS (|mkAtreeNode| '|map|)
                       (CONS |bodyVec| (CONS |form| NIL))))
        (|bottomUp| |form|)
        (setq |val| (|getValue| |form|))
        (setq |m| (|objMode| |val|))
        (COND
          ((AND (NULL (AND (CONSP |m|) (EQ (QCAR |m|) '|Stream|)
                           (PROGN
                             (setq |ISTMP#1| (QCDR |m|))
                             (AND (CONSP |ISTMP#1|)
                                  (EQ (QCDR |ISTMP#1|) NIL)
                                  (PROGN
                                    (setq |ud| (QCAR |ISTMP#1|))
                                    'T)))))
                (NULL (AND (CONSP |m|) (EQ (QCAR |m|) '|InfiniteTuple|)
                           (PROGN
                             (setq |ISTMP#1| (QCDR |m|))
                             (AND (CONSP |ISTMP#1|)
                                  (EQ (QCDR |ISTMP#1|) NIL)
                                  (PROGN
                                    (setq |ud| (QCAR |ISTMP#1|))
                                    'T))))))
           (|systemError| "Not a Stream"))
          ('T
           (setq |newVal|
                    (mkObj (|objVal| |val|)
                        (CONS '|InfiniteTuple| (CONS |ud| NIL))))
           (|putValue| |op| |newVal|) (|objMode| |newVal|)))))))

;mkAndApplyPredicates itrl ==
;  -- for one index variable case for now.  may generalize later
;  [indSet] := $indexVars
;  [.,:s] := indSet
;  for iter in itrl repeat
;    iter is ['WHILE,pred] =>
;      fun := 'filterWhile
;      predVec := mkIterFun(indSet,pred,$localVars)
;      s := [mkAtreeNode fun,predVec,s]
;    iter is ['UNTIL,pred] =>
;      fun := 'filterUntil
;      predVec := mkIterFun(indSet,pred,$localVars)
;      s := [mkAtreeNode fun,predVec,s]
;    iter is ['SUCHTHAT,pred] =>
;      fun := 'select
;      putTarget(pred,$Boolean)
;      predVec := mkIterFun(indSet,pred,$localVars)
;      s := [mkAtreeNode fun,predVec,s]
;  s

(DEFUN |mkAndApplyPredicates| (|itrl|)
  (PROG (|indSet| |ISTMP#1| |pred| |fun| |predVec| |s|)
  (declare (special |$localVars| |$Boolean| |$indexVars|))
    (RETURN
      (SEQ (PROGN
             (setq |indSet| (CAR |$indexVars|))
             (setq |s| (CDR |indSet|))
             (DO ((G168208 |itrl| (CDR G168208)) (|iter| NIL))
                 ((OR (ATOM G168208)
                      (PROGN (SETQ |iter| (CAR G168208)) NIL))
                  NIL)
               (SEQ (EXIT (COND
                            ((AND (CONSP |iter|)
                                  (EQ (QCAR |iter|) 'WHILE)
                                  (PROGN
                                    (setq |ISTMP#1| (QCDR |iter|))
                                    (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (PROGN
                                       (setq |pred|
                                        (QCAR |ISTMP#1|))
                                       'T))))
                             (setq |fun| '|filterWhile|)
                             (setq |predVec|
                                      (|mkIterFun| |indSet| |pred|
                                       |$localVars|))
                             (setq |s|
                                      (CONS (|mkAtreeNode| |fun|)
                                       (CONS |predVec| (CONS |s| NIL)))))
                            ((AND (CONSP |iter|)
                                  (EQ (QCAR |iter|) 'UNTIL)
                                  (PROGN
                                    (setq |ISTMP#1| (QCDR |iter|))
                                    (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (PROGN
                                       (setq |pred|
                                        (QCAR |ISTMP#1|))
                                       'T))))
                             (setq |fun| '|filterUntil|)
                             (setq |predVec|
                                      (|mkIterFun| |indSet| |pred|
                                       |$localVars|))
                             (setq |s|
                                      (CONS (|mkAtreeNode| |fun|)
                                       (CONS |predVec| (CONS |s| NIL)))))
                            ((AND (CONSP |iter|)
                                  (EQ (QCAR |iter|) 'SUCHTHAT)
                                  (PROGN
                                    (setq |ISTMP#1| (QCDR |iter|))
                                    (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (PROGN
                                       (setq |pred|
                                        (QCAR |ISTMP#1|))
                                       'T))))
                             (PROGN
                               (setq |fun| '|select|)
                               (|putTarget| |pred| |$Boolean|)
                               (setq |predVec|
                                        (|mkIterFun| |indSet| |pred|
                                         |$localVars|))
                               (setq |s|
                                        (CONS (|mkAtreeNode| |fun|)
                                         (CONS |predVec|
                                          (CONS |s| NIL))))))))))
             |s|)))))

;mkIterFun([index,:s],funBody,$localVars) ==
;  -- transform funBody into a lambda with index as the parameter
;  mode := objMode getValue s
;  mode isnt ['Stream, indMode] and mode isnt ['InfiniteTuple, indMode] =>
;    keyedSystemError('"S2GE0016", '("mkIterFun" "bad stream index type"))
;  put(index,'mode,indMode,$env)
;  mkLocalVar($mapName,index)
;  [m]:=bottomUpCompile funBody
;  mapMode := ['Mapping,m,indMode]
;  $freeVariables := []
;  $boundVariables := [index]
;  -- CCL does not support upwards funargs, so we check for any free variables
;  -- and pass them into the lambda as part of envArg.
;  body := checkForFreeVariables(getValue funBody,$localVars)
;  val:=['function,['LAMBDA,[index,'envArg],objVal body]]
;  vec := mkAtreeNode GENSYM()
;  putValue(vec,objNew(['CONS,val,["VECTOR",:reverse $freeVariables]],mapMode))
;  vec

(DEFUN |mkIterFun| (G168248 |funBody| |$localVars|)
  (DECLARE (SPECIAL |$localVars|))
  (PROG (|index| |s| |mode| |ISTMP#1| |indMode| |LETTMP#1| |m|
                 |mapMode| |body| |val| |vec|)
  (declare (special |$freeVariables| |$boundVariables| |$mapName| |$env|))
    (RETURN
      (PROGN
        (setq |index| (CAR G168248))
        (setq |s| (CDR G168248))
        (setq |mode| (|objMode| (|getValue| |s|)))
        (COND
          ((AND (NULL (AND (CONSP |mode|) (EQ (QCAR |mode|) '|Stream|)
                           (PROGN
                             (setq |ISTMP#1| (QCDR |mode|))
                             (AND (CONSP |ISTMP#1|)
                                  (EQ (QCDR |ISTMP#1|) NIL)
                                  (PROGN
                                    (setq |indMode|
                                     (QCAR |ISTMP#1|))
                                    'T)))))
                (NULL (AND (CONSP |mode|)
                           (EQ (QCAR |mode|) '|InfiniteTuple|)
                           (PROGN
                             (setq |ISTMP#1| (QCDR |mode|))
                             (AND (CONSP |ISTMP#1|)
                                  (EQ (QCDR |ISTMP#1|) NIL)
                                  (PROGN
                                    (setq |indMode|
                                     (QCAR |ISTMP#1|))
                                    'T))))))
           (|keyedSystemError|
             "Unexpected error or improper call to system function %1: %2"
               '("mkIterFun" "bad stream index type")))
          ('T (|put| |index| '|mode| |indMode| |$env|)
           (|mkLocalVar| |$mapName| |index|)
           (setq |LETTMP#1| (|bottomUpCompile| |funBody|))
           (setq |m| (CAR |LETTMP#1|))
           (setq |mapMode|
                    (CONS '|Mapping| (CONS |m| (CONS |indMode| NIL))))
           (setq |$freeVariables| NIL)
           (setq |$boundVariables| (CONS |index| NIL))
           (setq |body|
                    (|checkForFreeVariables| (|getValue| |funBody|)
                        |$localVars|))
           (setq |val|
                    (CONS 'function
                          (CONS (CONS 'LAMBDA
                                      (CONS
                                       (CONS |index|
                                        (CONS '|envArg| NIL))
                                       (CONS (|objVal| |body|) NIL)))
                                NIL)))
           (setq |vec| (|mkAtreeNode| (GENSYM)))
           (|putValue| |vec|
               (mkObj
                   (CONS 'CONS
                         (CONS |val|
                               (CONS (CONS 'VECTOR
                                      (REVERSE |$freeVariables|))
                                     NIL)))
                   |mapMode|))
           |vec|))))))

;checkForFreeVariables(v,locals) ==
;  -- v is the body of a lambda expression.  The list $boundVariables is all the
;  -- bound variables, the parameter locals contains local variables which might
;  -- be free, or the token ALL, which means that any parameter is a candidate
;  -- to be free.
;  NULL v => v
;  SYMBOLP v =>
;    v="$$$" => v -- Placeholder for mini-vector
;    MEMQ(v,$boundVariables) => v
;    p := POSITION(v,$freeVariables) =>
;      ["ELT","envArg",positionInVec(p,#($freeVariables))]
;    (locals = "ALL") or MEMQ(v,locals) =>
;      $freeVariables := [v,:$freeVariables]
;      ["ELT","envArg",positionInVec(0,#($freeVariables))]
;    v
;  LISTP v =>
;    CDR(LASTTAIL v) => -- Must be a better way to check for a genuine list?
;      v
;    [op,:args] := v
;    LISTP op =>
;      -- Might have a mode at the front of a list, or be calling a function
;      -- which returns a function.
;      [checkForFreeVariables(op,locals),:[checkForFreeVariables(a,locals) for a in args]]
;    op = "LETT" => -- Expands to a SETQ.
;      ["SETF",:[checkForFreeVariables(a,locals) for a in args]]
;    op = "COLLECT" => -- Introduces a new bound variable?
;      first(args) is ["STEP",var,:.] =>
;       $boundVariables := [var,:$boundVariables]
;       r := ["COLLECT",:[checkForFreeVariables(a,locals) for a in args]]
;       $boundVariables := DELETE(var,$boundVariables)
;       r
;      ["COLLECT",:[checkForFreeVariables(a,locals) for a in args]]
;    op = "REPEAT" => -- Introduces a new bound variable?
;      first(args) is ["STEP",var,:.] =>
;       $boundVariables := [var,:$boundVariables]
;       r := ["REPEAT",:[checkForFreeVariables(a,locals) for a in args]]
;       $boundVariables := DELETE(var,$boundVariables)
;       r
;      ["REPEAT",:[checkForFreeVariables(a,locals) for a in args]]
;    op = "LET" =>
;      args is [var,form,name] =>
;        -- This is some bizarre LET, not what one would expect in Common Lisp!
;        -- Treat var as a free variable, since it may be bound out of scope
;        -- if we are in a lambda within another lambda.
;        newvar :=
;          p := POSITION(var,$freeVariables) =>
;            ["ELT","envArg",positionInVec(p,#($freeVariables))]
;          $freeVariables := [var,:$freeVariables]
;          ["ELT","envArg",positionInVec(0,#($freeVariables))]
;        ["SETF",newvar,checkForFreeVariables(form,locals)]
;      error "Non-simple variable bindings are not currently supported"
;    op = "PROG" =>
;      error "Non-simple variable bindings are not currently supported"
;    op = "LAMBDA" => v
;    op = "QUOTE" => v
;    op = "getValueFromEnvironment" => v
;    [op,:[checkForFreeVariables(a,locals) for a in args]]
;  v

(DEFUN |checkForFreeVariables| (|v| |locals|)
  (PROG (|op| |args| |r| |var| |ISTMP#1| |form| |ISTMP#2| |name| |p| |newvar|)
  (declare (special |$freeVariables| |$boundVariables|))
    (RETURN
      (SEQ (COND
             ((NULL |v|) |v|)
             ((SYMBOLP |v|)
              (COND
                ((BOOT-EQUAL |v| '$$$) |v|)
                ((member |v| |$boundVariables|) |v|)
                ((setq |p| (POSITION |v| |$freeVariables|))
                 (CONS 'ELT
                       (CONS '|envArg|
                             (CONS (|positionInVec| |p|
                                    (|#| |$freeVariables|))
                                   NIL))))
                ((OR (BOOT-EQUAL |locals| 'ALL) (member |v| |locals|))
                 (setq |$freeVariables| (CONS |v| |$freeVariables|))
                 (CONS 'ELT
                       (CONS '|envArg|
                             (CONS (|positionInVec| 0
                                    (|#| |$freeVariables|))
                                   NIL))))
                ('T |v|)))
             ((LISTP |v|)
              (COND
                ((CDR (LASTTAIL |v|)) |v|)
                ('T (setq |op| (CAR |v|)) (setq |args| (CDR |v|))
                 (COND
                   ((LISTP |op|)
                    (CONS (|checkForFreeVariables| |op| |locals|)
                          (PROG (G168349)
                            (setq G168349 NIL)
                            (RETURN
                              (DO ((G168354 |args| (CDR G168354))
                                   (|a| NIL))
                                  ((OR (ATOM G168354)
                                    (PROGN
                                      (SETQ |a| (CAR G168354))
                                      NIL))
                                   (NREVERSE0 G168349))
                                (SEQ (EXIT
                                      (SETQ G168349
                                       (CONS
                                        (|checkForFreeVariables| |a|
                                         |locals|)
                                        G168349)))))))))
                   ((BOOT-EQUAL |op| 'LETT)
                    (CONS 'SETF
                          (PROG (G168364)
                            (setq G168364 NIL)
                            (RETURN
                              (DO ((G168369 |args| (CDR G168369))
                                   (|a| NIL))
                                  ((OR (ATOM G168369)
                                    (PROGN
                                      (SETQ |a| (CAR G168369))
                                      NIL))
                                   (NREVERSE0 G168364))
                                (SEQ (EXIT
                                      (SETQ G168364
                                       (CONS
                                        (|checkForFreeVariables| |a|
                                         |locals|)
                                        G168364)))))))))
                   ((BOOT-EQUAL |op| 'COLLECT)
                    (COND
                      ((PROGN
                         (setq |ISTMP#1| (CAR |args|))
                         (AND (CONSP |ISTMP#1|)
                              (EQ (QCAR |ISTMP#1|) 'STEP)
                              (PROGN
                                (setq |ISTMP#2| (QCDR |ISTMP#1|))
                                (AND (CONSP |ISTMP#2|)
                                     (PROGN
                                       (setq |var| (QCAR |ISTMP#2|))
                                       'T)))))
                       (setq |$boundVariables|
                                (CONS |var| |$boundVariables|))
                       (setq |r|
                                (CONS 'COLLECT
                                      (PROG (G168379)
                                        (setq G168379 NIL)
                                        (RETURN
                                          (DO
                                           ((G168384 |args|
                                             (CDR G168384))
                                            (|a| NIL))
                                           ((OR (ATOM G168384)
                                             (PROGN
                                               (SETQ |a|
                                                (CAR G168384))
                                               NIL))
                                            (NREVERSE0 G168379))
                                            (SEQ
                                             (EXIT
                                              (SETQ G168379
                                               (CONS
                                                (|checkForFreeVariables|
                                                 |a| |locals|)
                                                G168379)))))))))
                       (setq |$boundVariables|
                                (|delete| |var| |$boundVariables|))
                       |r|)
                      ('T
                       (CONS 'COLLECT
                             (PROG (G168394)
                               (setq G168394 NIL)
                               (RETURN
                                 (DO ((G168399 |args|
                                       (CDR G168399))
                                      (|a| NIL))
                                     ((OR (ATOM G168399)
                                       (PROGN
                                         (SETQ |a| (CAR G168399))
                                         NIL))
                                      (NREVERSE0 G168394))
                                   (SEQ
                                    (EXIT
                                     (SETQ G168394
                                      (CONS
                                       (|checkForFreeVariables| |a|
                                        |locals|)
                                       G168394)))))))))))
                   ((BOOT-EQUAL |op| 'REPEAT)
                    (COND
                      ((PROGN
                         (setq |ISTMP#1| (CAR |args|))
                         (AND (CONSP |ISTMP#1|)
                              (EQ (QCAR |ISTMP#1|) 'STEP)
                              (PROGN
                                (setq |ISTMP#2| (QCDR |ISTMP#1|))
                                (AND (CONSP |ISTMP#2|)
                                     (PROGN
                                       (setq |var| (QCAR |ISTMP#2|))
                                       'T)))))
                       (setq |$boundVariables|
                                (CONS |var| |$boundVariables|))
                       (setq |r|
                                (CONS 'REPEAT
                                      (PROG (G168409)
                                        (setq G168409 NIL)
                                        (RETURN
                                          (DO
                                           ((G168414 |args|
                                             (CDR G168414))
                                            (|a| NIL))
                                           ((OR (ATOM G168414)
                                             (PROGN
                                               (SETQ |a|
                                                (CAR G168414))
                                               NIL))
                                            (NREVERSE0 G168409))
                                            (SEQ
                                             (EXIT
                                              (SETQ G168409
                                               (CONS
                                                (|checkForFreeVariables|
                                                 |a| |locals|)
                                                G168409)))))))))
                       (setq |$boundVariables|
                                (|delete| |var| |$boundVariables|))
                       |r|)
                      ('T
                       (CONS 'REPEAT
                             (PROG (G168424)
                               (setq G168424 NIL)
                               (RETURN
                                 (DO ((G168429 |args|
                                       (CDR G168429))
                                      (|a| NIL))
                                     ((OR (ATOM G168429)
                                       (PROGN
                                         (SETQ |a| (CAR G168429))
                                         NIL))
                                      (NREVERSE0 G168424))
                                   (SEQ
                                    (EXIT
                                     (SETQ G168424
                                      (CONS
                                       (|checkForFreeVariables| |a|
                                        |locals|)
                                       G168424)))))))))))
                   ((BOOT-EQUAL |op| 'LET)
                    (COND
                      ((AND (CONSP |args|)
                            (PROGN
                              (setq |var| (QCAR |args|))
                              (setq |ISTMP#1| (QCDR |args|))
                              (AND (CONSP |ISTMP#1|)
                                   (PROGN
                                     (setq |form| (QCAR |ISTMP#1|))
                                     (setq |ISTMP#2|
                                      (QCDR |ISTMP#1|))
                                     (AND (CONSP |ISTMP#2|)
                                      (EQ (QCDR |ISTMP#2|) NIL)
                                      (PROGN
                                        (setq |name|
                                         (QCAR |ISTMP#2|))
                                        'T))))))
                       (setq |newvar|
                                (COND
                                  ((setq |p|
                                    (POSITION |var| |$freeVariables|))
                                   (CONS 'ELT
                                    (CONS '|envArg|
                                     (CONS
                                      (|positionInVec| |p|
                                       (|#| |$freeVariables|))
                                      NIL))))
                                  ('T
                                   (setq |$freeVariables|
                                    (CONS |var| |$freeVariables|))
                                   (CONS 'ELT
                                    (CONS '|envArg|
                                     (CONS
                                      (|positionInVec| 0
                                       (|#| |$freeVariables|))
                                      NIL))))))
                       (CONS 'SETF
                             (CONS |newvar|
                                   (CONS
                                    (|checkForFreeVariables| |form|
                                     |locals|)
                                    NIL))))
                      ('T
       (|error| '|Non-simple variable bindings are not currently supported|))))
                   ((BOOT-EQUAL |op| 'PROG)
        (|error| '|Non-simple variable bindings are not currently supported|))
                   ((BOOT-EQUAL |op| 'LAMBDA) |v|)
                   ((BOOT-EQUAL |op| 'QUOTE) |v|)
                   ((BOOT-EQUAL |op| '|getValueFromEnvironment|) |v|)
                   ('T
                    (CONS |op|
                          (PROG (G168439)
                            (setq G168439 NIL)
                            (RETURN
                              (DO ((G168444 |args| (CDR G168444))
                                   (|a| NIL))
                                  ((OR (ATOM G168444)
                                    (PROGN
                                      (SETQ |a| (CAR G168444))
                                      NIL))
                                   (NREVERSE0 G168439))
                                (SEQ (EXIT
                                      (SETQ G168439
                                       (CONS
                                        (|checkForFreeVariables| |a|
                                         |locals|)
                                        G168439)))))))))))))
             ('T |v|))))))

;positionInVec(p,l) ==
;  -- We cons up the free list, but need to keep positions consistent so
;  -- count from the end of the list.
;  l-p-1

(DEFUN |positionInVec| (|p| |l|) (SPADDIFFERENCE (SPADDIFFERENCE |l| |p|) 1)) 

;collectSeveralStreams(t,op,itrl,body) ==
;  -- performs collects over several streams in parallel
;  $index: local := nil
;  [form,:zipType] := mkZipCode $indexVars
;  form := mkAndApplyZippedPredicates(form,zipType,itrl)
;  vec := mkIterZippedFun($indexVars,body,zipType,$localVars)
;  form := [mkAtreeNode 'map, vec, form]
;  bottomUp form
;  val := getValue form
;  m := objMode val
;  m isnt ['Stream, ud] and m isnt ['InfiniteTuple, ud] =>
;    systemError '"Not a Stream"
;  newVal := objNew(objVal val, ['InfiniteTuple, ud])
;  putValue(op,newVal)
;  objMode newVal

(DEFUN |collectSeveralStreams| (|t| |op| |itrl| |body|)
  (declare (ignore |t|))
  (PROG (|$index| |LETTMP#1| |zipType| |vec| |form| |val| |m| |ISTMP#1|
            |ud| |newVal|)
    (DECLARE (SPECIAL |$index| |$localVars| |$indexVars|))
    (RETURN
      (PROGN
        (setq |$index| NIL)
        (setq |LETTMP#1| (|mkZipCode| |$indexVars|))
        (setq |form| (CAR |LETTMP#1|))
        (setq |zipType| (CDR |LETTMP#1|))
        (setq |form|
                 (|mkAndApplyZippedPredicates| |form| |zipType| |itrl|))
        (setq |vec|
                 (|mkIterZippedFun| |$indexVars| |body| |zipType|
                     |$localVars|))
        (setq |form|
                 (CONS (|mkAtreeNode| '|map|)
                       (CONS |vec| (CONS |form| NIL))))
        (|bottomUp| |form|)
        (setq |val| (|getValue| |form|))
        (setq |m| (|objMode| |val|))
        (COND
          ((AND (NULL (AND (CONSP |m|) (EQ (QCAR |m|) '|Stream|)
                           (PROGN
                             (setq |ISTMP#1| (QCDR |m|))
                             (AND (CONSP |ISTMP#1|)
                                  (EQ (QCDR |ISTMP#1|) NIL)
                                  (PROGN
                                    (setq |ud| (QCAR |ISTMP#1|))
                                    'T)))))
                (NULL (AND (CONSP |m|) (EQ (QCAR |m|) '|InfiniteTuple|)
                           (PROGN
                             (setq |ISTMP#1| (QCDR |m|))
                             (AND (CONSP |ISTMP#1|)
                                  (EQ (QCDR |ISTMP#1|) NIL)
                                  (PROGN
                                    (setq |ud| (QCAR |ISTMP#1|))
                                    'T))))))
           (|systemError| "Not a Stream"))
          ('T
           (setq |newVal|
                    (mkObj (|objVal| |val|)
                        (CONS '|InfiniteTuple| (CONS |ud| NIL))))
           (|putValue| |op| |newVal|) (|objMode| |newVal|)))))))

;mkZipCode indexList ==
;  -- create interpreter form for turning a list of parallel streams
;  -- into a stream of nested record types.  returns [form,:recordType]
;  #indexList = 2 =>
;    [[.,:s2],[.,:s1]] := indexList
;    t1 := CADR objMode getValue s1
;    t2 := CADR objMode getValue s2
;    zipType := ['Record,['_:,'part1,t1], ['_:,'part2,t2] ]
;    zipFun := [mkAtreeNode 'Dollar, ['MakeRecord,mkEvalable t1,
;                                     mkEvalable t2],
;               mkAtreeNode 'makeRecord]
;    form := [mkAtreeNode 'map,zipFun,s1,s2]
;    [form,:zipType]
;  [form,:zipType] := mkZipCode CDR indexList
;  [[.,:s],:.] := indexList
;  t := CADR objMode getValue s
;  zipFun := [mkAtreeNode 'Dollar, ['MakeRecord,mkEvalable t,
;                                   mkEvalable zipType],
;             mkAtreeNode 'makeRecord]
;  form := [mkAtreeNode 'map,zipFun,s,form]
;  zipType := ['Record,['_:,'part1,t],['_:,'part2,zipType]]
;  [form,:zipType]

(DEFUN |mkZipCode| (|indexList|)
  (PROG (|s2| |s1| |t1| |t2| |LETTMP#1| |s| |t| |zipFun| |form|
              |zipType|)
    (RETURN
      (COND
        ((EQL (|#| |indexList|) 2) (setq |s2| (CDAR |indexList|))
         (setq |s1| (CDADR |indexList|))
         (setq |t1| (CADR (|objMode| (|getValue| |s1|))))
         (setq |t2| (CADR (|objMode| (|getValue| |s2|))))
         (setq |zipType|
                  (CONS '|Record|
                        (CONS (CONS '|:|
                                    (CONS '|part1| (CONS |t1| NIL)))
                              (CONS (CONS '|:|
                                     (CONS '|part2| (CONS |t2| NIL)))
                                    NIL))))
         (setq |zipFun|
                  (CONS (|mkAtreeNode| '|Dollar|)
                        (CONS (CONS '|MakeRecord|
                                    (CONS (|mkEvalable| |t1|)
                                     (CONS (|mkEvalable| |t2|) NIL)))
                              (CONS (|mkAtreeNode| '|makeRecord|) NIL))))
         (setq |form|
                  (CONS (|mkAtreeNode| '|map|)
                        (CONS |zipFun| (CONS |s1| (CONS |s2| NIL)))))
         (CONS |form| |zipType|))
        ('T (setq |LETTMP#1| (|mkZipCode| (CDR |indexList|)))
         (setq |form| (CAR |LETTMP#1|))
         (setq |zipType| (CDR |LETTMP#1|))
         (setq |s| (CDAR |indexList|))
         (setq |t| (CADR (|objMode| (|getValue| |s|))))
         (setq |zipFun|
                  (CONS (|mkAtreeNode| '|Dollar|)
                        (CONS (CONS '|MakeRecord|
                                    (CONS (|mkEvalable| |t|)
                                     (CONS (|mkEvalable| |zipType|)
                                      NIL)))
                              (CONS (|mkAtreeNode| '|makeRecord|) NIL))))
         (setq |form|
                  (CONS (|mkAtreeNode| '|map|)
                        (CONS |zipFun| (CONS |s| (CONS |form| NIL)))))
         (setq |zipType|
                  (CONS '|Record|
                        (CONS (CONS '|:|
                                    (CONS '|part1| (CONS |t| NIL)))
                              (CONS (CONS '|:|
                                     (CONS '|part2|
                                      (CONS |zipType| NIL)))
                                    NIL))))
         (CONS |form| |zipType|))))))

;mkAndApplyZippedPredicates (s,zipType,itrl) ==
;  -- for one index variable case for now.  may generalize later
;  for iter in itrl repeat
;    iter is ['WHILE,pred] =>
;      predVec := mkIterZippedFun($indexList,pred,zipType,$localVars)
;      s := [mkAtreeNode 'swhile,predVec,s]
;    iter is ['UNTIL,pred] =>
;      predVec := mkIterZippedFun($indexList,pred,zipType,$localVars)
;      s := [mkAtreeNode 'suntil,predVec,s]
;    iter is ['SUCHTHAT,pred] =>
;      putTarget(pred,$Boolean)
;      predVec := mkIterZippedFun($indexList,pred,zipType,$localVars)
;      s := [mkAtreeNode 'select,predVec,s]
;  s

(DEFUN |mkAndApplyZippedPredicates| (|s| |zipType| |itrl|)
  (PROG (|ISTMP#1| |pred| |predVec|)
  (declare (special |$localVars| |$indexList| |$Boolean| ))
    (RETURN
      (SEQ (PROGN
             (DO ((G168589 |itrl| (CDR G168589)) (|iter| NIL))
                 ((OR (ATOM G168589)
                      (PROGN (SETQ |iter| (CAR G168589)) NIL))
                  NIL)
               (SEQ (EXIT (COND
                            ((AND (CONSP |iter|)
                                  (EQ (QCAR |iter|) 'WHILE)
                                  (PROGN
                                    (setq |ISTMP#1| (QCDR |iter|))
                                    (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (PROGN
                                       (setq |pred|
                                        (QCAR |ISTMP#1|))
                                       'T))))
                             (setq |predVec|
                                      (|mkIterZippedFun| |$indexList|
                                       |pred| |zipType| |$localVars|))
                             (setq |s|
                                      (CONS (|mkAtreeNode| '|swhile|)
                                       (CONS |predVec| (CONS |s| NIL)))))
                            ((AND (CONSP |iter|)
                                  (EQ (QCAR |iter|) 'UNTIL)
                                  (PROGN
                                    (setq |ISTMP#1| (QCDR |iter|))
                                    (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (PROGN
                                       (setq |pred|
                                        (QCAR |ISTMP#1|))
                                       'T))))
                             (setq |predVec|
                                      (|mkIterZippedFun| |$indexList|
                                       |pred| |zipType| |$localVars|))
                             (setq |s|
                                      (CONS (|mkAtreeNode| '|suntil|)
                                       (CONS |predVec| (CONS |s| NIL)))))
                            ((AND (CONSP |iter|)
                                  (EQ (QCAR |iter|) 'SUCHTHAT)
                                  (PROGN
                                    (setq |ISTMP#1| (QCDR |iter|))
                                    (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (PROGN
                                       (setq |pred|
                                        (QCAR |ISTMP#1|))
                                       'T))))
                             (PROGN
                               (|putTarget| |pred| |$Boolean|)
                               (setq |predVec|
                                        (|mkIterZippedFun| |$indexList|
                                         |pred| |zipType| |$localVars|))
                               (setq |s|
                                        (CONS (|mkAtreeNode| '|select|)
                                         (CONS |predVec|
                                          (CONS |s| NIL))))))))))
             |s|)))))

;mkIterZippedFun(indexList,funBody,zipType,$localVars) ==
;  -- transform funBody into a lamda with $index as the parameter
;  numVars:= #$indexVars
;  for [var,:.] in $indexVars repeat
;    funBody := subVecNodes(mkIterVarSub(var,numVars),var,funBody)
;  put($index,'mode,zipType,$env)
;  mkLocalVar($mapName,$index)
;  [m]:=bottomUpCompile funBody
;  mapMode := ['Mapping,m,zipType]
;  $freeVariables := []
;  $boundVariables := [$index]
;  -- CCL does not support upwards funargs, so we check for any free variables
;  -- and pass them into the lambda as part of envArg.
;  body :=
;   [checkForFreeVariables(form,$localVars) for form in getValue funBody]
;  val:=['function,['LAMBDA,[$index,'envArg],objVal body]]
;  vec := mkAtreeNode GENSYM()
;  putValue(vec,objNew(['CONS,val,["VECTOR",:reverse $freeVariables]],mapMode))
;  vec

(DEFUN |mkIterZippedFun| (|indexList| |funBody| |zipType| |$localVars|)
  (DECLARE (SPECIAL |$localVars|) (ignore |indexList|))
  (PROG (|numVars| |var| |LETTMP#1| |m| |mapMode| |body| |val| |vec|)
  (declare (special |$freeVariables| |$index| |$boundVariables| |$mapName|
                    |$env| |$indexVars|))
    (RETURN
      (SEQ (PROGN
             (setq |numVars| (|#| |$indexVars|))
             (DO ((G168623 |$indexVars| (CDR G168623))
                  (G168610 NIL))
                 ((OR (ATOM G168623)
                      (PROGN (SETQ G168610 (CAR G168623)) NIL)
                      (PROGN
                        (PROGN
                          (setq |var| (CAR G168610))
                          G168610)
                        NIL))
                  NIL)
               (SEQ (EXIT (setq |funBody|
                                   (|subVecNodes|
                                    (|mkIterVarSub| |var| |numVars|)
                                    |var| |funBody|)))))
             (|put| |$index| '|mode| |zipType| |$env|)
             (|mkLocalVar| |$mapName| |$index|)
             (setq |LETTMP#1| (|bottomUpCompile| |funBody|))
             (setq |m| (CAR |LETTMP#1|))
             (setq |mapMode|
                      (CONS '|Mapping| (CONS |m| (CONS |zipType| NIL))))
             (setq |$freeVariables| NIL)
             (setq |$boundVariables| (CONS |$index| NIL))
             (setq |body|
                      (PROG (G168634)
                        (setq G168634 NIL)
                        (RETURN
                          (DO ((G168639 (|getValue| |funBody|)
                                   (CDR G168639))
                               (|form| NIL))
                              ((OR (ATOM G168639)
                                   (PROGN
                                     (SETQ |form| (CAR G168639))
                                     NIL))
                               (NREVERSE0 G168634))
                            (SEQ (EXIT (SETQ G168634
                                        (CONS
                                         (|checkForFreeVariables|
                                          |form| |$localVars|)
                                         G168634))))))))
             (setq |val|
                      (CONS 'function
                            (CONS (CONS 'LAMBDA
                                        (CONS
                                         (CONS |$index|
                                          (CONS '|envArg| NIL))
                                         (CONS (|objVal| |body|) NIL)))
                                  NIL)))
             (setq |vec| (|mkAtreeNode| (GENSYM)))
             (|putValue| |vec|
                 (mkObj
                     (CONS 'CONS
                           (CONS |val|
                                 (CONS (CONS 'VECTOR
                                        (REVERSE |$freeVariables|))
                                       NIL)))
                     |mapMode|))
             |vec|)))))

;subVecNodes(new,old,form) ==
;  ATOM form =>
;    (VECP form) and (form.0 = old) => new
;    form
;  [subVecNodes(new,old,CAR form), :subVecNodes(new,old,CDR form)]

(DEFUN |subVecNodes| (|new| |old| |form|)
  (COND
    ((ATOM |form|)
     (COND
       ((AND (VECP |form|) (BOOT-EQUAL (ELT |form| 0) |old|)) |new|)
       ('T |form|)))
    ('T
     (CONS (|subVecNodes| |new| |old| (CAR |form|))
           (|subVecNodes| |new| |old| (CDR |form|))))))

;mkIterVarSub(var,numVars) ==
;  n := iterVarPos var
;  n=2 =>
;    [mkAtreeNode 'elt,mkNestedElts(numVars-2),mkAtreeNode 'part2]
;  n=1 =>
;    [mkAtreeNode 'elt,mkNestedElts(numVars-2),mkAtreeNode 'part1]
;  [mkAtreeNode 'elt,mkNestedElts(numVars-n),mkAtreeNode 'part1]

(DEFUN |mkIterVarSub| (|var| |numVars|)
  (PROG (|n|)
    (RETURN
      (PROGN
        (setq |n| (|iterVarPos| |var|))
        (COND
          ((EQL |n| 2)
           (CONS (|mkAtreeNode| '|elt|)
                 (CONS (|mkNestedElts| (SPADDIFFERENCE |numVars| 2))
                       (CONS (|mkAtreeNode| '|part2|) NIL))))
          ((EQL |n| 1)
           (CONS (|mkAtreeNode| '|elt|)
                 (CONS (|mkNestedElts| (SPADDIFFERENCE |numVars| 2))
                       (CONS (|mkAtreeNode| '|part1|) NIL))))
          ('T
           (CONS (|mkAtreeNode| '|elt|)
                 (CONS (|mkNestedElts| (SPADDIFFERENCE |numVars| |n|))
                       (CONS (|mkAtreeNode| '|part1|) NIL)))))))))

;iterVarPos var ==
;  for [index,:.] in reverse $indexVars for i in 1.. repeat
;    index=var => return(i)

(DEFUN |iterVarPos| (|var|)
  (PROG (|index|)
  (declare (special |$indexVars|))
    (RETURN
      (SEQ (DO ((G168679 (REVERSE |$indexVars|) (CDR G168679))
                (G168671 NIL) (|i| 1 (QSADD1 |i|)))
               ((OR (ATOM G168679)
                    (PROGN (SETQ G168671 (CAR G168679)) NIL)
                    (PROGN
                      (PROGN
                        (setq |index| (CAR G168671))
                        G168671)
                      NIL))
                NIL)
             (SEQ (EXIT (COND
                          ((BOOT-EQUAL |index| |var|)
                           (EXIT (RETURN |i|)))))))))))

;mkNestedElts n ==
;  n=0 => mkAtreeNode($index or ($index:= GENSYM()))
;  [mkAtreeNode 'elt, mkNestedElts(n-1), mkAtreeNode 'part2]

(DEFUN |mkNestedElts| (|n|)
  (declare (special |$index|))
  (COND
    ((EQL |n| 0)
     (|mkAtreeNode| (OR |$index| (setq |$index| (GENSYM)))))
    ('T
     (CONS (|mkAtreeNode| '|elt|)
           (CONS (|mkNestedElts| (SPADDIFFERENCE |n| 1))
                 (CONS (|mkAtreeNode| '|part2|) NIL))))))

;--% Handlers for construct
;upconstruct t ==
;  --Computes the common mode set of the construct by resolving across
;  --the argument list, and evaluating
;  t isnt [op,:l] => nil
;  dol := getAtree(op,'dollar)
;  tar := getTarget(op) or dol
;  null l => upNullList(op,l,tar)
;  tar is ['Record,:types] => upRecordConstruct(op,l,tar)
;  isTaggedUnion tar => upTaggedUnionConstruct(op,l,tar)
;  aggs := '(List)
;  if tar and CONSP(tar) and ^isPartialMode(tar) then
;    CAR(tar) in aggs =>
;      ud :=
;        (l is [[realOp, :.]]) and (getUnname(realOp) = 'COLLECT) => tar
;        CADR tar
;      for x in l repeat if not getTarget(x) then putTarget(x,ud)
;    CAR(tar) in '(Matrix SquareMatrix RectangularMatrix) =>
;      vec := ['List,underDomainOf tar]
;      for x in l repeat if not getTarget(x) then putTarget(x,vec)
;  argModeSetList:= [bottomUp x for x in l]
;  dol and dol is [topType,:.] and not (topType in aggs) =>
;    (mmS:= selectMms(op,l,tar)) and (mS:= evalForm(op,getUnname op,l,mmS)) =>
;      putModeSet(op,mS)
;    NIL
;  (tar and tar is [topType,:.] and not (topType in aggs)) and
;    (mmS:= modemapsHavingTarget(selectMms(op,l,tar),tar)) and
;        (mS:= evalForm(op,getUnname op,l,mmS)) =>
;          putModeSet(op,mS)
;  eltTypes := replaceSymbols([first x for x in argModeSetList],l)
;  eltTypes is [['Tuple, td]] =>
;    mode := ['List, td]
;    evalTupleConstruct(op, l, mode, tar)
;  eltTypes is [['InfiniteTuple, td]] =>
;    mode := ['Stream, td]
;    evalInfiniteTupleConstruct(op, l, mode, tar)
;  if not isPartialMode(tar) and tar is ['List,ud] then
;    mode := ['List, resolveTypeListAny cons(ud,eltTypes)]
;  else mode := ['List, resolveTypeListAny eltTypes]
;  if isPartialMode tar then tar:=resolveTM(mode,tar)
;  evalconstruct(op,l,mode,tar)

(DEFUN |upconstruct| (|t|)
  (PROG (|op| |l| |dol| |types| |aggs| |realOp| |vec| |argModeSetList|
              |topType| |mmS| |mS| |eltTypes| |ISTMP#2| |td| |ISTMP#1|
              |ud| |mode| |tar|)
    (RETURN
      (SEQ (COND
             ((NULL (AND (CONSP |t|)
                         (PROGN
                           (setq |op| (QCAR |t|))
                           (setq |l| (QCDR |t|))
                           'T)))
              NIL)
             ('T (setq |dol| (|getAtree| |op| '|dollar|))
              (setq |tar| (OR (|getTarget| |op|) |dol|))
              (COND
                ((NULL |l|) (|upNullList| |op| |l| |tar|))
                ((AND (CONSP |tar|) (EQ (QCAR |tar|) '|Record|)
                      (PROGN (setq |types| (QCDR |tar|)) 'T))
                 (|upRecordConstruct| |op| |l| |tar|))
                ((|isTaggedUnion| |tar|)
                 (|upTaggedUnionConstruct| |op| |l| |tar|))
                ('T (setq |aggs| '(|List|))
                 (COND
                   ((AND |tar| (CONSP |tar|)
                         (NULL (|isPartialMode| |tar|)))
                    (COND
                      ((|member| (CAR |tar|) |aggs|)
                       (setq |ud|
                                (COND
                                  ((AND (CONSP |l|) (EQ (QCDR |l|) NIL)
                                    (PROGN
                                      (setq |ISTMP#1| (QCAR |l|))
                                      (AND (CONSP |ISTMP#1|)
                                       (PROGN
                                         (setq |realOp|
                                          (QCAR |ISTMP#1|))
                                         'T)))
                                    (BOOT-EQUAL (|getUnname| |realOp|)
                                     'COLLECT))
                                   |tar|)
                                  ('T (CADR |tar|))))
                       (DO ((G168737 |l| (CDR G168737)) (|x| NIL))
                           ((OR (ATOM G168737)
                                (PROGN (SETQ |x| (CAR G168737)) NIL))
                            NIL)
                         (SEQ (EXIT (COND
                                      ((NULL (|getTarget| |x|))
                                       (|putTarget| |x| |ud|))
                                      ('T NIL))))))
                      ((|member| (CAR |tar|)
                           '(|Matrix| |SquareMatrix|
                                |RectangularMatrix|))
                       (setq |vec|
                                (CONS '|List|
                                      (CONS (|underDomainOf| |tar|)
                                       NIL)))
                       (DO ((G168746 |l| (CDR G168746)) (|x| NIL))
                           ((OR (ATOM G168746)
                                (PROGN (SETQ |x| (CAR G168746)) NIL))
                            NIL)
                         (SEQ (EXIT (COND
                                      ((NULL (|getTarget| |x|))
                                       (|putTarget| |x| |vec|))
                                      ('T NIL)))))))))
                 (setq |argModeSetList|
                          (PROG (G168756)
                            (setq G168756 NIL)
                            (RETURN
                              (DO ((G168761 |l| (CDR G168761))
                                   (|x| NIL))
                                  ((OR (ATOM G168761)
                                    (PROGN
                                      (SETQ |x| (CAR G168761))
                                      NIL))
                                   (NREVERSE0 G168756))
                                (SEQ (EXIT
                                      (SETQ G168756
                                       (CONS (|bottomUp| |x|)
                                        G168756))))))))
                 (COND
                   ((AND |dol| (CONSP |dol|)
                         (PROGN (setq |topType| (QCAR |dol|)) 'T)
                         (NULL (|member| |topType| |aggs|)))
                    (COND
                      ((AND (setq |mmS|
                                     (|selectMms| |op| |l| |tar|))
                            (setq |mS|
                                     (|evalForm| |op|
                                      (|getUnname| |op|) |l| |mmS|)))
                       (|putModeSet| |op| |mS|))
                      ('T NIL)))
                   ((AND |tar| (CONSP |tar|)
                         (PROGN (setq |topType| (QCAR |tar|)) 'T)
                         (NULL (|member| |topType| |aggs|))
                         (setq |mmS|
                                  (|modemapsHavingTarget|
                                      (|selectMms| |op| |l| |tar|)
                                      |tar|))
                         (setq |mS|
                                  (|evalForm| |op| (|getUnname| |op|)
                                      |l| |mmS|)))
                    (|putModeSet| |op| |mS|))
                   ('T
                    (setq |eltTypes|
                             (|replaceSymbols|
                                 (PROG (G168771)
                                   (setq G168771 NIL)
                                   (RETURN
                                     (DO
                                      ((G168776 |argModeSetList|
                                        (CDR G168776))
                                       (|x| NIL))
                                      ((OR (ATOM G168776)
                                        (PROGN
                                          (SETQ |x| (CAR G168776))
                                          NIL))
                                       (NREVERSE0 G168771))
                                       (SEQ
                                        (EXIT
                                         (SETQ G168771
                                          (CONS (CAR |x|) G168771)))))))
                                 |l|))
                    (COND
                      ((AND (CONSP |eltTypes|)
                            (EQ (QCDR |eltTypes|) NIL)
                            (PROGN
                              (setq |ISTMP#1| (QCAR |eltTypes|))
                              (AND (CONSP |ISTMP#1|)
                                   (EQ (QCAR |ISTMP#1|) '|Tuple|)
                                   (PROGN
                                     (setq |ISTMP#2|
                                      (QCDR |ISTMP#1|))
                                     (AND (CONSP |ISTMP#2|)
                                      (EQ (QCDR |ISTMP#2|) NIL)
                                      (PROGN
                                        (setq |td| (QCAR |ISTMP#2|))
                                        'T))))))
                       (setq |mode| (CONS '|List| (CONS |td| NIL)))
                       (|evalTupleConstruct| |op| |l| |mode| |tar|))
                      ((AND (CONSP |eltTypes|)
                            (EQ (QCDR |eltTypes|) NIL)
                            (PROGN
                              (setq |ISTMP#1| (QCAR |eltTypes|))
                              (AND (CONSP |ISTMP#1|)
                                   (EQ (QCAR |ISTMP#1|)
                                    '|InfiniteTuple|)
                                   (PROGN
                                     (setq |ISTMP#2|
                                      (QCDR |ISTMP#1|))
                                     (AND (CONSP |ISTMP#2|)
                                      (EQ (QCDR |ISTMP#2|) NIL)
                                      (PROGN
                                        (setq |td| (QCAR |ISTMP#2|))
                                        'T))))))
                       (setq |mode|
                                (CONS '|Stream| (CONS |td| NIL)))
                       (|evalInfiniteTupleConstruct| |op| |l| |mode|
                           |tar|))
                      ('T
                       (COND
                         ((AND (NULL (|isPartialMode| |tar|))
                               (CONSP |tar|) (EQ (QCAR |tar|) '|List|)
                               (PROGN
                                 (setq |ISTMP#1| (QCDR |tar|))
                                 (AND (CONSP |ISTMP#1|)
                                      (EQ (QCDR |ISTMP#1|) NIL)
                                      (PROGN
                                        (setq |ud| (QCAR |ISTMP#1|))
                                        'T))))
                          (setq |mode|
                                   (CONS '|List|
                                    (CONS
                                     (|resolveTypeListAny|
                                      (CONS |ud| |eltTypes|))
                                     NIL))))
                         ('T
                          (setq |mode|
                                   (CONS '|List|
                                    (CONS
                                     (|resolveTypeListAny| |eltTypes|)
                                     NIL)))))
                       (COND
                         ((|isPartialMode| |tar|)
                          (setq |tar| (|resolveTM| |mode| |tar|))))
                       (|evalconstruct| |op| |l| |mode| |tar|)))))))))))))

;modemapsHavingTarget(mmS,target) ==
;  -- returns those modemaps have the signature result matching the
;  -- given target
;  [mm for mm in mmS | ([[.,res,:.],:.] := mm) and res = target]

(DEFUN |modemapsHavingTarget| (|mmS| |target|)
  (PROG (|res|)
    (RETURN
      (SEQ (PROG (G168825)
             (setq G168825 NIL)
             (RETURN
               (DO ((G168831 |mmS| (CDR G168831)) (|mm| NIL))
                   ((OR (ATOM G168831)
                        (PROGN (SETQ |mm| (CAR G168831)) NIL))
                    (NREVERSE0 G168825))
                 (SEQ (EXIT (COND
                              ((AND (PROGN
                                      (setq |res| (CADAR |mm|))
                                      |mm|)
                                    (BOOT-EQUAL |res| |target|))
                               (SETQ G168825 (CONS |mm| G168825)))))))))))))

;evalTupleConstruct(op,l,m,tar) ==
;  ['List, ud] := m
;  code := ['APPEND,
;    :([["asTupleAsList", getArgValueOrThrow(x,['Tuple, ud])] for x in l])]
;  val :=
;    $genValue => objNewWrap(timedEVALFUN code,m)
;    objNew(code,m)
;  (val1 := coerceInteractive(val,tar or m)) =>
;    putValue(op,val1)
;    putModeSet(op,[tar or m])
;  putValue(op,val)
;  putModeSet(op,[m])

(DEFUN |evalTupleConstruct| (|op| |l| |m| |tar|)
  (PROG (|ud| |code| |val| |val1|)
  (declare (special |$genValue|))
    (RETURN
      (SEQ (PROGN
             (setq |ud| (CADR |m|))
             (setq |code|
                      (CONS 'APPEND
                            (PROG (G168851)
                              (setq G168851 NIL)
                              (RETURN
                                (DO ((G168856 |l| (CDR G168856))
                                     (|x| NIL))
                                    ((OR (ATOM G168856)
                                      (PROGN
                                        (SETQ |x| (CAR G168856))
                                        NIL))
                                     (NREVERSE0 G168851))
                                  (SEQ (EXIT
                                        (SETQ G168851
                                         (CONS
                                          (CONS '|asTupleAsList|
                                           (CONS
                                            (|getArgValueOrThrow| |x|
                                             (CONS '|Tuple|
                                              (CONS |ud| NIL)))
                                            NIL))
                                          G168851)))))))))
             (setq |val|
                      (COND
                        (|$genValue|
                            (mkObjWrap (|timedEVALFUN| |code|) |m|))
                        ('T (mkObj |code| |m|))))
             (COND
               ((setq |val1|
                         (|coerceInteractive| |val| (OR |tar| |m|)))
                (|putValue| |op| |val1|)
                (|putModeSet| |op| (CONS (OR |tar| |m|) NIL)))
               ('T (|putValue| |op| |val|)
                (|putModeSet| |op| (CONS |m| NIL)))))))))

;evalInfiniteTupleConstruct(op,l,m,tar) ==
;  ['Stream, ud] := m
;  code := first [(getArgValue(x,['InfiniteTuple, ud]) or
;    throwKeyedMsg("S2IC0007",[['InifinteTuple, ud]])) for x in l]
;  val :=
;    $genValue => objNewWrap(timedEVALFUN code,m)
;    objNew(code,m)
;  if tar then val1 := coerceInteractive(val,tar) else val1 := val
;  val1 =>
;    putValue(op,val1)
;    putModeSet(op,[tar or m])
;  putValue(op,val)
;  putModeSet(op,[m])

(DEFUN |evalInfiniteTupleConstruct| (|op| |l| |m| |tar|)
  (PROG (|ud| |code| |val| |val1|)
  (declare (special |$genValue|))
    (RETURN
      (SEQ (PROGN
             (setq |ud| (CADR |m|))
             (setq |code|
                      (CAR (PROG (G168879)
                             (setq G168879 NIL)
                             (RETURN
                               (DO ((G168884 |l| (CDR G168884))
                                    (|x| NIL))
                                   ((OR (ATOM G168884)
                                     (PROGN
                                       (SETQ |x| (CAR G168884))
                                       NIL))
                                    (NREVERSE0 G168879))
                                 (SEQ (EXIT
                                       (SETQ G168879
                                        (CONS
                                         (OR
                                          (|getArgValue| |x|
                                           (CONS '|InfiniteTuple|
                                            (CONS |ud| NIL)))
                                          (|throwKeyedMsg| 
                    "Cannot convert an element of the construct to type %1p ."
                                           (CONS
                                            (CONS '|InifinteTuple|
                                             (CONS |ud| NIL))
                                            NIL)))
                                         G168879)))))))))
             (setq |val|
                      (COND
                        (|$genValue|
                            (mkObjWrap (|timedEVALFUN| |code|) |m|))
                        ('T (mkObj |code| |m|))))
             (COND
               (|tar| (setq |val1|
                               (|coerceInteractive| |val| |tar|)))
               ('T (setq |val1| |val|)))
             (COND
               (|val1| (|putValue| |op| |val1|)
                       (|putModeSet| |op| (CONS (OR |tar| |m|) NIL)))
               ('T (|putValue| |op| |val|)
                (|putModeSet| |op| (CONS |m| NIL)))))))))

;evalconstruct(op,l,m,tar) ==
;  [agg,:.,underMode]:= m
;  code := ['LIST, :(argCode:=[(getArgValue(x,underMode) or
;    throwKeyedMsg("S2IC0007",[underMode])) for x in l])]
;  val :=
;    $genValue => objNewWrap(timedEVALFUN code,m)
;    objNew(code,m)
;  if tar then val1 := coerceInteractive(val,tar) else val1 := val
;  val1 =>
;    putValue(op,val1)
;    putModeSet(op,[tar or m])
;  putValue(op,val)
;  putModeSet(op,[m])

(DEFUN |evalconstruct| (|op| |l| |m| |tar|)
  (PROG (|agg| |LETTMP#1| |underMode| |argCode| |code| |val| |val1|)
  (declare (special |$genValue|))
    (RETURN
      (SEQ (PROGN
             (setq |agg| (CAR |m|))
             (setq |LETTMP#1| (REVERSE (CDR |m|)))
             (setq |underMode| (CAR |LETTMP#1|))
             (setq |code|
                      (CONS 'LIST
                            (setq |argCode|
                                     (PROG (G168910)
                                       (setq G168910 NIL)
                                       (RETURN
                                         (DO
                                          ((G168915 |l|
                                            (CDR G168915))
                                           (|x| NIL))
                                          ((OR (ATOM G168915)
                                            (PROGN
                                              (SETQ |x|
                                               (CAR G168915))
                                              NIL))
                                           (NREVERSE0 G168910))
                                           (SEQ
                                            (EXIT
                                             (SETQ G168910
                                              (CONS
                                               (OR
                                                (|getArgValue| |x|
                                                 |underMode|)
                                                (|throwKeyedMsg|
                   "Cannot convert an element of the construct to type %1p ."
                                                 (CONS |underMode| NIL)))
                                               G168910))))))))))
             (setq |val|
                      (COND
                        (|$genValue|
                            (mkObjWrap (|timedEVALFUN| |code|) |m|))
                        ('T (mkObj |code| |m|))))
             (COND
               (|tar| (setq |val1|
                               (|coerceInteractive| |val| |tar|)))
               ('T (setq |val1| |val|)))
             (COND
               (|val1| (|putValue| |op| |val1|)
                       (|putModeSet| |op| (CONS (OR |tar| |m|) NIL)))
               ('T (|putValue| |op| |val|)
                (|putModeSet| |op| (CONS |m| NIL)))))))))

;replaceSymbols(modeList,l) ==
;  -- replaces symbol types with their corresponding polynomial types
;  --  if not all type are symbols
;  not ($Symbol in modeList) => modeList
;  modeList is [a,:b] and and/[a=x for x in b] => modeList
;  [if m=$Symbol then getMinimalVarMode(objValUnwrap(getValue arg),
;    $declaredMode) else m for m in modeList for arg in l]

(DEFUN |replaceSymbols| (|modeList| |l|)
  (PROG (|a| |b|)
  (declare (special |$declaredMode| |$Symbol|))
    (RETURN
      (SEQ (COND
             ((NULL (|member| |$Symbol| |modeList|)) |modeList|)
             ((AND (CONSP |modeList|)
                   (PROGN
                     (setq |a| (QCAR |modeList|))
                     (setq |b| (QCDR |modeList|))
                     'T)
                   (PROG (G168937)
                     (setq G168937 'T)
                     (RETURN
                       (DO ((G168943 NIL (NULL G168937))
                            (G168944 |b| (CDR G168944)) (|x| NIL))
                           ((OR G168943 (ATOM G168944)
                                (PROGN (SETQ |x| (CAR G168944)) NIL))
                            G168937)
                         (SEQ (EXIT (SETQ G168937
                                     (AND G168937
                                      (BOOT-EQUAL |a| |x|)))))))))
              |modeList|)
             ('T
              (PROG (G168956)
                (setq G168956 NIL)
                (RETURN
                  (DO ((G168962 |modeList| (CDR G168962)) (|m| NIL)
                       (G168963 |l| (CDR G168963)) (|arg| NIL))
                      ((OR (ATOM G168962)
                           (PROGN (SETQ |m| (CAR G168962)) NIL)
                           (ATOM G168963)
                           (PROGN (SETQ |arg| (CAR G168963)) NIL))
                       (NREVERSE0 G168956))
                    (SEQ (EXIT (SETQ G168956
                                     (CONS
                                      (COND
                                        ((BOOT-EQUAL |m| |$Symbol|)
                                         (|getMinimalVarMode|
                                          (|objValUnwrap|
                                           (|getValue| |arg|))
                                          |$declaredMode|))
                                        ('T |m|))
                                      G168956)))))))))))))

;upNullList(op,l,tar) ==
;  -- handler for [] (empty list)
;  defMode :=
;    tar and tar is [a,b] and (a in '(Stream Vector List)) and
;      not isPartialMode(b) => ['List,b]
;    '(List (None))
;  val := objNewWrap(NIL,defMode)
;  tar and not isPartialMode(tar) =>
;    null (val' := coerceInteractive(val,tar)) =>
;      throwKeyedMsg("S2IS0013",[tar])
;    putValue(op,val')
;    putModeSet(op,[tar])
;  putValue(op,val)
;  putModeSet(op,[defMode])

(DEFUN |upNullList| (|op| |l| |tar|)
  (declare (ignore |l|))
  (PROG (|a| |ISTMP#1| |b| |defMode| |val| |val'|)
    (RETURN
      (PROGN
        (setq |defMode|
                 (COND
                   ((AND |tar| (CONSP |tar|)
                         (PROGN
                           (setq |a| (QCAR |tar|))
                           (setq |ISTMP#1| (QCDR |tar|))
                           (AND (CONSP |ISTMP#1|)
                                (EQ (QCDR |ISTMP#1|) NIL)
                                (PROGN
                                  (setq |b| (QCAR |ISTMP#1|))
                                  'T)))
                         (|member| |a| '(|Stream| |Vector| |List|))
                         (NULL (|isPartialMode| |b|)))
                    (CONS '|List| (CONS |b| NIL)))
                   ('T '(|List| (|None|)))))
        (setq |val| (mkObjWrap NIL |defMode|))
        (COND
          ((AND |tar| (NULL (|isPartialMode| |tar|)))
           (COND
             ((NULL (setq |val'| (|coerceInteractive| |val| |tar|)))
              (|throwKeyedMsg|
               (format nil
                "Axiom does not understand what you mean when you specify ~
                [ ] as having the type %1p .")
               (CONS |tar| NIL)))
             ('T (|putValue| |op| |val'|)
              (|putModeSet| |op| (CONS |tar| NIL)))))
          ('T (|putValue| |op| |val|)
           (|putModeSet| |op| (CONS |defMode| NIL))))))))

;upTaggedUnionConstruct(op,l,tar) ==
;  -- special handler for tagged union constructors
;  tar isnt [.,:types] => nil
;  #l ^= 1 => throwKeyedMsg("S2IS0051",[#l,tar])
;  bottomUp first l
;  obj := getValue first l
;  (code := coerceInteractive(getValue first l,tar)) or
;    throwKeyedMsgCannotCoerceWithValue(objVal obj, objMode obj,tar)
;  putValue(op,code)
;  putModeSet(op,[tar])

(DEFUN |upTaggedUnionConstruct| (|op| |l| |tar|)
  (PROG (|types| |obj| |code|)
    (RETURN
      (COND
        ((NULL (AND (CONSP |tar|)
                    (PROGN (setq |types| (QCDR |tar|)) 'T)))
         NIL)
        ((NEQUAL (|#| |l|) 1)
         (|throwKeyedMsg|
          (format nil
           "A tagged union construct with [ and ] must contain only one ~
            element and you supplied %1 to create an object of type %2p.")
          (CONS (|#| |l|) (CONS |tar| NIL))))
        ('T (|bottomUp| (CAR |l|))
         (setq |obj| (|getValue| (CAR |l|)))
         (OR (setq |code|
                      (|coerceInteractive| (|getValue| (CAR |l|))
                          |tar|))
             (|throwKeyedMsgCannotCoerceWithValue| (|objVal| |obj|)
                 (|objMode| |obj|) |tar|))
         (|putValue| |op| |code|) (|putModeSet| |op| (CONS |tar| NIL)))))))

;upRecordConstruct(op,l,tar) ==
;  -- special handler for record constructors
;  tar isnt [.,:types] => nil
;  argModes := nil
;  for arg in l repeat bottomUp arg
;  argCode :=
;    [(getArgValue(arg,type) or throwKeyedMsgCannotCoerceWithValue(
;      objVal getValue arg,objMode getValue arg,type))
;        for arg in l for ['_:,.,type] in types]
;  len := #l
;  code :=
;    (len = 1) => ['CONS, :argCode, '()]
;    (len = 2) => ['CONS,:argCode]
;    ['VECTOR,:argCode]
;  if $genValue then code :=  wrap timedEVALFUN code
;  putValue(op,objNew(code,tar))
;  putModeSet(op,[tar])

(DEFUN |upRecordConstruct| (|op| |l| |tar|)
  (PROG (|types| |argModes| |type| |argCode| |len| |code|)
  (declare (special |$genValue|))
    (RETURN
      (SEQ (COND
             ((NULL (AND (CONSP |tar|)
                         (PROGN (setq |types| (QCDR |tar|)) 'T)))
              NIL)
             ('T (setq |argModes| NIL)
              (DO ((G169015 |l| (CDR G169015)) (|arg| NIL))
                  ((OR (ATOM G169015)
                       (PROGN (SETQ |arg| (CAR G169015)) NIL))
                   NIL)
                (SEQ (EXIT (|bottomUp| |arg|))))
              (setq |argCode|
                       (PROG (G169027)
                         (setq G169027 NIL)
                         (RETURN
                           (DO ((G169034 |l| (CDR G169034))
                                (|arg| NIL)
                                (G169035 |types| (CDR G169035))
                                (G169007 NIL))
                               ((OR (ATOM G169034)
                                    (PROGN
                                      (SETQ |arg| (CAR G169034))
                                      NIL)
                                    (ATOM G169035)
                                    (PROGN
                                      (SETQ G169007 (CAR G169035))
                                      NIL)
                                    (PROGN
                                      (PROGN
                                        (setq |type|
                                         (CADDR G169007))
                                        G169007)
                                      NIL))
                                (NREVERSE0 G169027))
                             (SEQ (EXIT (SETQ G169027
                                         (CONS
                                          (OR
                                           (|getArgValue| |arg| |type|)
                                          (|throwKeyedMsgCannotCoerceWithValue|
                                            (|objVal|
                                             (|getValue| |arg|))
                                            (|objMode|
                                             (|getValue| |arg|))
                                            |type|))
                                          G169027))))))))
              (setq |len| (|#| |l|))
              (setq |code|
                       (COND
                         ((EQL |len| 1)
                          (CONS 'CONS
                                (APPEND |argCode| (CONS 'NIL NIL))))
                         ((EQL |len| 2) (CONS 'CONS |argCode|))
                         ('T (CONS 'VECTOR |argCode|))))
              (COND
                (|$genValue|
                    (setq |code| (|wrap| (|timedEVALFUN| |code|)))))
              (|putValue| |op| (mkObj |code| |tar|))
              (|putModeSet| |op| (CONS |tar| NIL))))))))

;--% Handlers for declarations
;upDeclare t ==
;  t isnt  [op,lhs,rhs] => nil
;  (not $genValue) and or/[CONTAINED(var,rhs) for var in $localVars] =>
;    keyedMsgCompFailure("S2IS0014",[lhs])
;  mode := evaluateType unabbrev rhs
;  mode = $Void => throwKeyedMsgSP("S2IS0015",NIL,op)
;  not isLegitimateMode(mode,nil,nil) => throwKeyedMsgSP("S2IE0004",[mode],op)
;  categoryForm?(mode) => throwKeyedMsgSP("S2IE0011",[mode, 'category],op)
;  packageForm?(mode) => throwKeyedMsgSP("S2IE0011",[mode, 'package],op)
;  junk :=
;    lhs is ['free,['Tuple,:vars]] or lhs is ['free,['LISTOF,:vars]] or
;      lhs is ['free,:vars] =>
;        for var in vars repeat declare(['free,var],mode)
;    lhs is ['local,['Tuple,:vars]] or lhs is ['local,['LISTOF,:vars]] or
;      lhs is ['local,:vars] =>
;        for var in vars repeat declare(['local,var],mode)
;    lhs is ['Tuple,:vars] or lhs is ['LISTOF,:vars] =>
;      for var in vars repeat declare(var,mode)
;    declare(lhs,mode)
;  putValue(op,objNewWrap(voidValue(), $Void))
;  putModeSet(op,[$Void])

(DEFUN |upDeclare| (|t|)
  (PROG (|op| |lhs| |rhs| |mode| |ISTMP#1| |ISTMP#2| |vars| |junk|)
  (declare (special |$Void| |$localVars| |$genValue|))
    (RETURN
      (SEQ (COND
             ((NULL (AND (CONSP |t|)
                         (PROGN
                           (setq |op| (QCAR |t|))
                           (setq |ISTMP#1| (QCDR |t|))
                           (AND (CONSP |ISTMP#1|)
                                (PROGN
                                  (setq |lhs| (QCAR |ISTMP#1|))
                                  (setq |ISTMP#2| (QCDR |ISTMP#1|))
                                  (AND (CONSP |ISTMP#2|)
                                       (EQ (QCDR |ISTMP#2|) NIL)
                                       (PROGN
                                         (setq |rhs|
                                          (QCAR |ISTMP#2|))
                                         'T)))))))
              NIL)
             ((AND (NULL |$genValue|)
                   (PROG (G169122)
                     (setq G169122 NIL)
                     (RETURN
                       (DO ((G169128 NIL G169122)
                            (G169129 |$localVars| (CDR G169129))
                            (|var| NIL))
                           ((OR G169128 (ATOM G169129)
                                (PROGN
                                  (SETQ |var| (CAR G169129))
                                  NIL))
                            G169122)
                         (SEQ (EXIT (SETQ G169122
                                     (OR G169122
                                      (CONTAINED |var| |rhs|)))))))))
              (|keyedMsgCompFailure|
               (format nil
                "Cannot compile the declaration for %1 because its (possible ~
                 partial) type contains a local variable.")
               (CONS |lhs| NIL)))
             ('T (setq |mode| (|evaluateType| (|unabbrev| |rhs|)))
              (COND
                ((BOOT-EQUAL |mode| |$Void|)
                 (|throwKeyedMsgSP|
                  "An identifier cannot be declared to have type Void "
                  NIL |op|))
                ((NULL (|isLegitimateMode| |mode| NIL NIL))
                 (|throwKeyedMsgSP| "%1p is not a valid type."
                  (CONS |mode| NIL) |op|))
                ((|categoryForm?| |mode|)
                 (|throwKeyedMsgSP|
                "%1p is a %2 , not a domain, and declarations require domains."
                     (CONS |mode| (CONS '|category| NIL)) |op|))
                ((|packageForm?| |mode|)
                 (|throwKeyedMsgSP|
                "%1p is a %2 , not a domain, and declarations require domains."
                     (CONS |mode| (CONS '|package| NIL)) |op|))
                ('T
                 (setq |junk|
                          (COND
                            ((OR (AND (CONSP |lhs|)
                                      (EQ (QCAR |lhs|) '|free|)
                                      (PROGN
                                        (setq |ISTMP#1|
                                         (QCDR |lhs|))
                                        (AND (CONSP |ISTMP#1|)
                                         (EQ (QCDR |ISTMP#1|) NIL)
                                         (PROGN
                                           (setq |ISTMP#2|
                                            (QCAR |ISTMP#1|))
                                           (AND (CONSP |ISTMP#2|)
                                            (EQ (QCAR |ISTMP#2|)
                                             '|Tuple|)
                                            (PROGN
                                              (setq |vars|
                                               (QCDR |ISTMP#2|))
                                              'T))))))
                                 (AND (CONSP |lhs|)
                                      (EQ (QCAR |lhs|) '|free|)
                                      (PROGN
                                        (setq |ISTMP#1|
                                         (QCDR |lhs|))
                                        (AND (CONSP |ISTMP#1|)
                                         (EQ (QCDR |ISTMP#1|) NIL)
                                         (PROGN
                                           (setq |ISTMP#2|
                                            (QCAR |ISTMP#1|))
                                           (AND (CONSP |ISTMP#2|)
                                            (EQ (QCAR |ISTMP#2|)
                                             'LISTOF)
                                            (PROGN
                                              (setq |vars|
                                               (QCDR |ISTMP#2|))
                                              'T))))))
                                 (AND (CONSP |lhs|)
                                      (EQ (QCAR |lhs|) '|free|)
                                      (PROGN
                                        (setq |vars| (QCDR |lhs|))
                                        'T)))
                             (DO ((G169139 |vars| (CDR G169139))
                                  (|var| NIL))
                                 ((OR (ATOM G169139)
                                      (PROGN
                                        (SETQ |var| (CAR G169139))
                                        NIL))
                                  NIL)
                               (SEQ (EXIT
                                     (|declare|
                                      (CONS '|free| (CONS |var| NIL))
                                      |mode|)))))
                            ((OR (AND (CONSP |lhs|)
                                      (EQ (QCAR |lhs|) '|local|)
                                      (PROGN
                                        (setq |ISTMP#1|
                                         (QCDR |lhs|))
                                        (AND (CONSP |ISTMP#1|)
                                         (EQ (QCDR |ISTMP#1|) NIL)
                                         (PROGN
                                           (setq |ISTMP#2|
                                            (QCAR |ISTMP#1|))
                                           (AND (CONSP |ISTMP#2|)
                                            (EQ (QCAR |ISTMP#2|)
                                             '|Tuple|)
                                            (PROGN
                                              (setq |vars|
                                               (QCDR |ISTMP#2|))
                                              'T))))))
                                 (AND (CONSP |lhs|)
                                      (EQ (QCAR |lhs|) '|local|)
                                      (PROGN
                                        (setq |ISTMP#1|
                                         (QCDR |lhs|))
                                        (AND (CONSP |ISTMP#1|)
                                         (EQ (QCDR |ISTMP#1|) NIL)
                                         (PROGN
                                           (setq |ISTMP#2|
                                            (QCAR |ISTMP#1|))
                                           (AND (CONSP |ISTMP#2|)
                                            (EQ (QCAR |ISTMP#2|)
                                             'LISTOF)
                                            (PROGN
                                              (setq |vars|
                                               (QCDR |ISTMP#2|))
                                              'T))))))
                                 (AND (CONSP |lhs|)
                                      (EQ (QCAR |lhs|) '|local|)
                                      (PROGN
                                        (setq |vars| (QCDR |lhs|))
                                        'T)))
                             (DO ((G169148 |vars| (CDR G169148))
                                  (|var| NIL))
                                 ((OR (ATOM G169148)
                                      (PROGN
                                        (SETQ |var| (CAR G169148))
                                        NIL))
                                  NIL)
                               (SEQ (EXIT
                                     (|declare|
                                      (CONS '|local| (CONS |var| NIL))
                                      |mode|)))))
                            ((OR (AND (CONSP |lhs|)
                                      (EQ (QCAR |lhs|) '|Tuple|)
                                      (PROGN
                                        (setq |vars| (QCDR |lhs|))
                                        'T))
                                 (AND (CONSP |lhs|)
                                      (EQ (QCAR |lhs|) 'LISTOF)
                                      (PROGN
                                        (setq |vars| (QCDR |lhs|))
                                        'T)))
                             (DO ((G169157 |vars| (CDR G169157))
                                  (|var| NIL))
                                 ((OR (ATOM G169157)
                                      (PROGN
                                        (SETQ |var| (CAR G169157))
                                        NIL))
                                  NIL)
                               (SEQ (EXIT (|declare| |var| |mode|)))))
                            ('T (|declare| |lhs| |mode|))))
                 (|putValue| |op| (mkObjWrap (|voidValue|) |$Void|))
                 (|putModeSet| |op| (CONS |$Void| NIL))))))))))

;declare(var,mode) ==
;  -- performs declaration.
;  -- 10/31/89: no longer coerces value to new declared type
;  if var is ['local,v] then
;    uplocalWithType(v,mode)
;    var := v
;  if var is ['free,v] then
;    upfreeWithType(v,mode)
;    var := v
;  not IDENTP(var) =>
;    throwKeyedMsg("S2IS0016",[princ-to-string var])
;  var in '(% %%) => throwKeyedMsg("S2IS0050",[var])
;  if get(var,'isInterpreterFunction,$e) then
;    mode isnt ['Mapping,.,:args] =>
;      throwKeyedMsg("S2IS0017",[var,mode])
;    -- validate that the new declaration has the defined # of args
;    mapval := objVal get(var,'value,$e)
;    -- mapval looks like '(MAP (args . defn))
;    margs := CAADR mapval
;    -- if one args, margs is not a pair, just #1 or NIL
;    -- otherwise it looks like (Tuple #1 #2 ...)
;    nargs :=
;      null margs => 0
;      CONSP margs => -1 + #margs
;      1
;    nargs ^= #args => throwKeyedMsg("S2IM0008",[var])
;  if $compilingMap then mkLocalVar($mapName,var)
;  else clearDependencies(var,true)
;  isLocalVar(var) => put(var,'mode,mode,$env)
;  mode is ['Mapping,:.] => declareMap(var,mode)
;  v := get(var,'value,$e) =>
;    -- only allow this if either
;    --   - value already has given type
;    --   - new mode is same as old declared mode
;    objMode(v) = mode => putHist(var,'mode,mode,$e)
;    mode = get(var,'mode,$e) => NIL   -- nothing to do
;    throwKeyedMsg("S2IS0052",[var,mode])
;  putHist(var,'mode,mode,$e)

(DEFUN |declare| (|var| |mode|)
  (PROG (|ISTMP#1| |args| |mapval| |margs| |nargs| |v|)
  (declare (special |$e| |$env| |$mapName| |$compilingMap|))
    (RETURN
      (PROGN
        (COND
          ((AND (CONSP |var|) (EQ (QCAR |var|) '|local|)
                (PROGN
                  (setq |ISTMP#1| (QCDR |var|))
                  (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                       (PROGN (setq |v| (QCAR |ISTMP#1|)) 'T))))
           (|uplocalWithType| |v| |mode|) (setq |var| |v|)))
        (COND
          ((AND (CONSP |var|) (EQ (QCAR |var|) '|free|)
                (PROGN
                  (setq |ISTMP#1| (QCDR |var|))
                  (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                       (PROGN (setq |v| (QCAR |ISTMP#1|)) 'T))))
           (|upfreeWithType| |v| |mode|) (setq |var| |v|)))
        (COND
          ((NULL (IDENTP |var|))
           (|throwKeyedMsg|
            "Declarations are only allowed on variables and %1 is not one."
            (CONS (princ-to-string |var|) NIL)))
          ((|member| |var| '(% %%))
           (|throwKeyedMsg|
            (format nil
             "Because of its use for recalling previous results, you cannot ~
            use %1 as a variable name.  In particular, you cannot declare it.")
            (CONS |var| NIL)))
          ('T
           (COND
             ((|get| |var| '|isInterpreterFunction| |$e|)
              (COND
                ((NULL (AND (CONSP |mode|)
                            (EQ (QCAR |mode|) '|Mapping|)
                            (PROGN
                              (setq |ISTMP#1| (QCDR |mode|))
                              (AND (CONSP |ISTMP#1|)
                                   (PROGN
                                     (setq |args| (QCDR |ISTMP#1|))
                                     'T)))))
                 (|throwKeyedMsg| 
                  (format nil
                   "The previous use of %1 as a function is not compatible ~
                    with its new declaration as %2p . If you do not want ~
                    the old value, issue %l )clear prop %1")
                     (CONS |var| (CONS |mode| NIL))))
                ('T
                 (setq |mapval|
                          (|objVal| (|get| |var| '|value| |$e|)))
                 (setq |margs| (CAADR |mapval|))
                 (setq |nargs|
                          (COND
                            ((NULL |margs|) 0)
                            ((CONSP |margs|)
                             (+ (SPADDIFFERENCE 1) (|#| |margs|)))
                            ('T 1)))
                 (COND
                   ((NEQUAL |nargs| (|#| |args|))
                    (|throwKeyedMsg|
                     (format nil
                    "The number of parameters in your definition for %1p ~
                     does not correspond to the declared number of arguments.")
                     (CONS |var| NIL))))))))
           (COND
             (|$compilingMap| (|mkLocalVar| |$mapName| |var|))
             ('T (|clearDependencies| |var| 'T)))
           (COND
             ((|isLocalVar| |var|) (|put| |var| '|mode| |mode| |$env|))
             ((AND (CONSP |mode|) (EQ (QCAR |mode|) '|Mapping|))
              (|declareMap| |var| |mode|))
             ((setq |v| (|get| |var| '|value| |$e|))
              (COND
                ((BOOT-EQUAL (|objMode| |v|) |mode|)
                 (|putHist| |var| '|mode| |mode| |$e|))
                ((BOOT-EQUAL |mode| (|get| |var| '|mode| |$e|)) NIL)
                ('T
                 (|throwKeyedMsg|
                  (format nil
                   "You cannot declare %1 to be of type %2p because either ~
                    the declared type of %1 or the type of the value of %1 ~
                    is different from %2p .")
                     (CONS |var| (CONS |mode| NIL))))))
             ('T (|putHist| |var| '|mode| |mode| |$e|)))))))))

;declareMap(var,mode) ==
;  -- declare a Mapping property
;  (v:=get(var,'value,$e)) and objVal(v) isnt ['MAP,:.] =>
;    throwKeyedMsg("S2IS0019",[var])
;  isPartialMode mode => throwKeyedMsg("S2IM0004",NIL)
;  putHist(var,'mode,mode,$e)

(DEFUN |declareMap| (|var| |mode|)
  (PROG (|v| |ISTMP#1|)
  (declare (special |$e|))
    (RETURN
      (COND
        ((AND (setq |v| (|get| |var| '|value| |$e|))
              (NULL (PROGN
                      (setq |ISTMP#1| (|objVal| |v|))
                      (AND (CONSP |ISTMP#1|)
                           (EQ (QCAR |ISTMP#1|) 'MAP)))))
         (|throwKeyedMsg|
          (format nil
           "Cannot process mapping declaration on %1 since it already has a ~
            value.")
           (CONS |var| NIL)))
        ((|isPartialMode| |mode|)
          (|throwKeyedMsg|
           (format nil
            "Partial types are not allowed in the declarations of function ~
             arguments or return types.")
            NIL))
        ('T (|putHist| |var| '|mode| |mode| |$e|))))))

;isOkInterpMode m ==
;  isPartialMode(m) => isLegitimateMode(m,nil,nil)
;  isValidType(m) and isLegitimateMode(m,nil,nil)

(DEFUN |isOkInterpMode| (|m|)
  (COND
    ((|isPartialMode| |m|) (|isLegitimateMode| |m| NIL NIL))
    ('T (AND (|isValidType| |m|) (|isLegitimateMode| |m| NIL NIL)))))

;isLegitimateRecordOrTaggedUnion u ==
;  and/[x is [":",.,d] and isLegitimateMode(d,nil,nil) for x in u]

(DEFUN |isLegitimateRecordOrTaggedUnion| (|u|)
  (PROG (|ISTMP#1| |ISTMP#2| |d|)
    (RETURN
      (SEQ (PROG (G169295)
             (setq G169295 'T)
             (RETURN
               (DO ((G169307 NIL (NULL G169295))
                    (G169308 |u| (CDR G169308)) (|x| NIL))
                   ((OR G169307 (ATOM G169308)
                        (PROGN (SETQ |x| (CAR G169308)) NIL))
                    G169295)
                 (SEQ (EXIT (SETQ G169295
                                  (AND G169295
                                       (AND (CONSP |x|)
                                        (EQ (QCAR |x|) '|:|)
                                        (PROGN
                                          (setq |ISTMP#1|
                                           (QCDR |x|))
                                          (AND (CONSP |ISTMP#1|)
                                           (PROGN
                                             (setq |ISTMP#2|
                                              (QCDR |ISTMP#1|))
                                             (AND (CONSP |ISTMP#2|)
                                              (EQ (QCDR |ISTMP#2|) NIL)
                                              (PROGN
                                                (setq |d|
                                                 (QCAR |ISTMP#2|))
                                                'T)))))
                                        (|isLegitimateMode| |d| NIL
                                         NIL)))))))))))))

;isPolynomialMode m ==
;  -- If m is a polynomial type this function returns a list of its
;  --  variables, and nil otherwise
;  m is [op,a,:rargs] =>
;    a := removeQuote a
;    MEMQ(op,'(Polynomial RationalFunction AlgebraicFunction Expression
;      ElementaryFunction LiouvillianFunction FunctionalExpression
;        CombinatorialFunction ))=> 'all
;    op = 'UnivariatePolynomial => LIST a
;    op = 'Variable       => LIST a
;    MEMQ(op,'(MultivariatePolynomial DistributedMultivariatePolynomial
;      HomogeneousDistributedMultivariatePolynomial)) => a
;    NIL
;  NIL

(DEFUN |isPolynomialMode| (|m|)
  (PROG (|op| |ISTMP#1| |rargs| |a|)
    (RETURN
      (COND
        ((AND (CONSP |m|)
              (PROGN
                (setq |op| (QCAR |m|))
                (setq |ISTMP#1| (QCDR |m|))
                (AND (CONSP |ISTMP#1|)
                     (PROGN
                       (setq |a| (QCAR |ISTMP#1|))
                       (setq |rargs| (QCDR |ISTMP#1|))
                       'T))))
         (setq |a| (|removeQuote| |a|))
         (COND
           ((member |op|
                  '(|Polynomial| |RationalFunction| |AlgebraicFunction|
                       |Expression| |ElementaryFunction|
                       |LiouvillianFunction| |FunctionalExpression|
                       |CombinatorialFunction|))
            '|all|)
           ((BOOT-EQUAL |op| '|UnivariatePolynomial|) (LIST |a|))
           ((BOOT-EQUAL |op| '|Variable|) (LIST |a|))
           ((member |op|
                  '(|MultivariatePolynomial|
                       |DistributedMultivariatePolynomial|
                       |HomogeneousDistributedMultivariatePolynomial|))
            |a|)
           ('T NIL)))
        ('T NIL)))))

;containsPolynomial m ==
;  not CONSP(m) => NIL
;  [d,:.] := m
;  d in $univariateDomains or d in $multivariateDomains or
;    d in '(Polynomial RationalFunction) => true
;  (m' := underDomainOf m) and containsPolynomial m'

(DEFUN |containsPolynomial| (|m|)
  (PROG (|d| |m'|)
  (declare (special |$multivariateDomains| |$univariateDomains|))
    (RETURN
      (COND
        ((NULL (CONSP |m|)) NIL)
        ('T (setq |d| (CAR |m|))
         (COND
           ((OR (|member| |d| |$univariateDomains|)
                (|member| |d| |$multivariateDomains|)
                (|member| |d| '(|Polynomial| |RationalFunction|)))
            'T)
           ('T
            (AND (setq |m'| (|underDomainOf| |m|))
                 (|containsPolynomial| |m'|)))))))))

;containsVariables m ==
;  not CONSP(m) => NIL
;  [d,:.] := m
;  d in $univariateDomains or d in $multivariateDomains => true
;  (m' := underDomainOf m) and containsVariables m'

(DEFUN |containsVariables| (|m|)
  (PROG (|d| |m'|)
  (declare (special |$multivariateDomains| |$univariateDomains|))
    (RETURN
      (COND
        ((NULL (CONSP |m|)) NIL)
        ('T (setq |d| (CAR |m|))
         (COND
           ((OR (|member| |d| |$univariateDomains|)
                (|member| |d| |$multivariateDomains|))
            'T)
           ('T
            (AND (setq |m'| (|underDomainOf| |m|))
                 (|containsVariables| |m'|)))))))))

;listOfDuplicates l ==
;  l is [x,:l'] =>
;    x in l' => [x,:listOfDuplicates deleteAll(x,l')]
;    listOfDuplicates l'

(DEFUN |listOfDuplicates| (|l|)
  (PROG (|x| |l'|)
    (RETURN
      (SEQ (COND
             ((AND (CONSP |l|)
                   (PROGN
                     (setq |x| (QCAR |l|))
                     (setq |l'| (QCDR |l|))
                     'T))
              (EXIT (COND
                      ((|member| |x| |l'|)
                       (CONS |x|
                             (|listOfDuplicates|
                                 (|deleteAll| |x| |l'|))))
                      ('T (|listOfDuplicates| |l'|))))))))))

;-- The following function removes all occurrences of x from the list l
;deleteAll(x,l) ==
;  null l => nil
;  x = CAR(l) => deleteAll(x,CDR l)
;  [first l,:deleteAll(x,rest l)]

(DEFUN |deleteAll| (|x| |l|)
  (COND
    ((NULL |l|) NIL)
    ((BOOT-EQUAL |x| (CAR |l|)) (|deleteAll| |x| (CDR |l|)))
    ('T (CONS (CAR |l|) (|deleteAll| |x| (CDR |l|))))))

\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
