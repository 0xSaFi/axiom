documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp depsys.lisp}
\author{Lars Ericson, Barry Trager, Martial Schor, Timothy Daly}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents

<<*>>=


;      VM LISP EMULATION PACKAGE
;      Lars Ericson, Barry Trager, Martial Schor, tim daly, LVMCL, et al
;      IBM Thomas J. Watson Research Center
;      Summer, 1986
;  see /spad/daly.changes

; This emulation package version is written for Symbolics Common Lisp.
; Emulation commentary refers to LISP/VM, IBM Program Number 5798-DQZ,
; as described in the LISP/VM User's Guide, document SH20-6477-1.
; Main comment section headings refer to sections in the User's Guide.

; If you are using this, you are probably in Common Lisp, yes?

(in-package "VMLISP")

(export '(MAKE-HASHTABLE HCOUNT HPUT* HREM HCLEAR HREMPROP
          HASHEQ HASHUEQUAL HASHCVEC HASHID HASHTABLEP CVEC UEQUAL ID HPUTPROP
	  HASHTABLE-CLASS))
(import '(BOOT::QENUM ))
(import '(BOOT::STRPOSL ))
(import '(BOOT::STRPOS ))
(import '(BOOT::SIZE ))
(import '(BOOT::DIGITP))
(import '(BOOT::HGET ))
(import '(BOOT::HPUT ))
(import '(BOOT::|startsId?| ))
(import '(BOOT::LOTSOF ))
(import '(BOOT::WRAP))

(setq *features* (adjoin :common-lisp *features*))

;; DEFVARS

(defvar *embedded-functions* nil)

(defvar *comp370-apply* nil "function (name def) for comp370 to apply")

(defvar *fileactq-apply* nil "function to apply in fileactq")

(defvar *lam-name* nil "name to be used by lam macro if non-nil")

(defvar macerrorcount 0  "Put some documentation in here someday")

(defvar *read-place-holder* (make-symbol "%.EOF")
   "default value returned by read and read-line at end-of-file")

;; DEFMACROS


(defmacro absval (x)
 `(abs ,x))

(defmacro add1 (x)
 `(1+ ,x))

(defmacro assemble (&rest ignore) 
 (declare (ignore ignore))
  nil)

(defmacro applx (&rest args)
 `(apply ,@args))

(defmacro assq (a b)
 `(assoc ,a ,b :test #'eq))

(defmacro bintp (n)
 `(typep ,n 'bignum))

(defmacro |char| (x)
  (if (and (consp x) (eq (car x) 'quote)) (character (cadr x))
    `(character ,x)))

(defmacro closedfn (form)
 `(function ,form))

(defmacro |copyList| (x) 
 `(copy-list ,x))

(defmacro create-sbc (x) x)  ;a no-op for common lisp

(defmacro cvecp (x)
 `(stringp ,x))

(defmacro dcq (&rest args)
 (cons 'setqp args))

(defmacro define-macro (f v)
 `(setf (macro-function ,f) (macro-function ,v)))

(defmacro difference (&rest args)
 `(- ,@args))

(defmacro dsetq (&whole form pattern exp)
 (dodsetq form pattern exp))

(defmacro ecq (&rest args)
 (cons 'eqq args))

(defmacro eqcar (x y)
 (let ((test
        (cond
         ((equable y) 'eq)
	 ((integerp y) 'i=)
	 ('eql))))
  (if (atom x)
   `(and (consp ,x) (,test (qcar ,x) ,y))
    (let ((xx (gensym)))
     `(let ((,xx ,x))
       (and (consp ,xx) (,test (qcar ,xx) ,y)))))))

(defmacro eqq (pattern exp)
 `(,(ecqexp pattern nil) ,exp))

(defmacro |equal| (x y)
 `(equalp ,x ,y))

(defmacro evalandfileactq (name &optional (form name))
 `(eval-when (eval load) ,form))  

(defmacro exit (&rest value)
 `(return-from seq ,@value))

(defmacro fetchchar (x i)
 `(char ,x ,i))

(defmacro fixp (x)
 `(integerp ,x))

(defmacro greaterp (&rest args)
 `(> ,@args))

(defmacro i= (x y) ;; integer equality
  (if (typep y 'fixnum)
      (let ((gx (gensym)))
	`(let ((,gx ,x))
	   (and (typep ,gx 'fixnum) (eql (the fixnum ,gx) ,y))))
    (let ((gx (gensym)) (gy (gensym)))
      `(let ((,gx ,x) (,gy ,y))
	 (cond ((and (typep ,gx 'fixnum) (typep ,gy 'fixnum))
		(eql (the fixnum ,gx) (the fixnum ,gy)))
	       ((eql (the integer ,gx) (the integer,gy))))))))

(defmacro ifcar (x)
  (if (atom x)
      `(and (consp ,x) (qcar ,x))
    (let ((xx (gensym)))
      `(let ((,xx ,x))
	 (and (consp ,xx) (qcar ,xx))))))

(defmacro ifcdr (x)
  (if (atom x)
      `(and (consp ,x) (qcdr ,x))
    (let ((xx (gensym)))
      `(let ((,xx ,x))
	 (and (consp ,xx) (qcdr ,xx))))))

(defmacro intp (x)
 `(integerp ,x))

(defmacro lam (&rest body)
 (list 'quote (*lam (copy-tree body))))

(defmacro lastnode (l)
 `(last ,l))

(defmacro lastpair (l)
 `(last ,l))

(defmacro lessp (&rest args)
 `(< ,@args))

(defmacro lintp (n)
 `(typep ,n 'bignum))

(defmacro makestring (a) a)

(defmacro mapelt (f vec)
 `(map 'vector ,f ,vec))

(defmacro maxindex (x)
 `(the fixnum (1- (the fixnum (length ,x)))))

(defmacro memq (a b)
 `(member ,a ,b :test #'eq))

(defmacro minus (x)
 `(- ,x))

(defmacro mrp (x)
 `(special-form-p ,x))

(defmacro namederrset (id iexp &rest item)
 (declare (ignore item))
  `(catch ,id ,iexp))

(defmacro ne (a b) `(not (equal ,a ,b)))

;;; This may need adjustment in CCL where NEQ means (NOT (EQUAL ..)))
(defmacro neq (a b) `(not (eq ,a ,b)))

(defmacro nreverse0 (x)
  (if (atom x)
      `(if (atom ,x) ,x (nreverse ,x))
    (let ((xx (gensym)))
      `(let ((,xx ,x))
	 (if (atom ,xx) ,xx (nreverse ,xx))))))

(defmacro nump (n)
 `(numberp ,n))

(defmacro |opOf| (x) ;(if (atom x) x (qcar x))
  (if (atom x)
      `(if (consp ,x) (qcar ,x) ,x)
    (let ((xx (gensym)))
      `(let ((,xx ,x))
	 (if (consp ,xx) (qcar ,xx) ,xx)))))

(defmacro oraddtempdefs (filearg)
 `(eval-when (compile) (load ,filearg)))

(defmacro pairp (x)
 `(consp ,x)) 

(defmacro plus (&rest args)
 `(+ ,@ args))

(defmacro qassq (a b) `(assq ,a ,b))

(defmacro qcar (x)
 `(car (the cons ,x)))

(defmacro qcdr (x)
 `(cdr (the cons ,x)))


(defmacro qcaar (x)
 `(car (the cons (car (the cons ,x)))))

(defmacro qcadr (x)
 `(car (the cons (cdr (the cons ,x)))))

(defmacro qcdar (x)
 `(cdr (the cons (car (the cons ,x)))))

(defmacro qcddr (x)
 `(cdr (the cons (cdr (the cons ,x)))))

(defmacro qcaaar (x)
 `(car (the cons (car (the cons (car (the cons ,x)))))))
(defmacro qcaadr (x)
 `(car (the cons (car (the cons (cdr (the cons ,x)))))))
(defmacro qcadar (x)
 `(car (the cons (cdr (the cons (car (the cons ,x)))))))
(defmacro qcaddr (x)
 `(car (the cons (cdr (the cons (cdr (the cons ,x)))))))
(defmacro qcdaar (x)
 `(cdr (the cons (car (the cons (car (the cons ,x)))))))
(defmacro qcdadr (x)
 `(cdr (the cons (car (the cons (cdr (the cons ,x)))))))
(defmacro qcddar (x)
 `(cdr (the cons (cdr (the cons (car (the cons ,x)))))))
(defmacro qcdddr (x)
 `(cdr (the cons (cdr (the cons (cdr (the cons ,x)))))))

(defmacro qcaaaar (x)
 `(car (the cons (car (the cons (car (the cons (car (the cons ,x)))))))))
(defmacro qcaaadr (x)
 `(car (the cons (car (the cons (car (the cons (cdr (the cons ,x)))))))))
(defmacro qcaadar (x)
 `(car (the cons (car (the cons (cdr (the cons (car (the cons ,x)))))))))
(defmacro qcaaddr (x)
 `(car (the cons (car (the cons (cdr (the cons (cdr (the cons ,x)))))))))
(defmacro qcadaar (x)
 `(car (the cons (cdr (the cons (car (the cons (car (the cons ,x)))))))))
(defmacro qcadadr (x)
 `(car (the cons (cdr (the cons (car (the cons (cdr (the cons ,x)))))))))
(defmacro qcaddar (x)
 `(car (the cons (cdr (the cons (cdr (the cons (car (the cons ,x)))))))))
(defmacro qcadddr (x)
 `(car (the cons (cdr (the cons (cdr (the cons (cdr (the cons ,x)))))))))
(defmacro qcdaaar (x)
 `(cdr (the cons (car (the cons (car (the cons (car (the cons ,x)))))))))
(defmacro qcdaadr (x)
 `(cdr (the cons (car (the cons (car (the cons (cdr (the cons ,x)))))))))
(defmacro qcdadar (x)
 `(cdr (the cons (car (the cons (cdr (the cons (car (the cons ,x)))))))))
(defmacro qcdaddr (x)
 `(cdr (the cons (car (the cons (cdr (the cons (cdr (the cons ,x)))))))))
(defmacro qcddaar (x)
 `(cdr (the cons (cdr (the cons (car (the cons (car (the cons ,x)))))))))
(defmacro qcddadr (x)
 `(cdr (the cons (cdr (the cons (car (the cons (cdr (the cons ,x)))))))))
(defmacro qcdddar (x)
 `(cdr (the cons (cdr (the cons (cdr (the cons (car (the cons ,x)))))))))
(defmacro qcddddr (x)
 `(cdr (the cons (cdr (the cons (cdr (the cons (cdr (the cons ,x)))))))))

(defmacro qcsize (x)
 `(the fixnum (length (the simple-string ,x))))

(defmacro qeqq (pattern exp)
 `(,(ecqexp pattern 1) ,exp))

(defmacro qlength (a)
 `(length ,a))

(defmacro qmemq (a b) `(memq ,a ,b))

(defmacro qrefelt (vec ind)
 `(svref ,vec ,ind))

(defmacro qrplaca (a b)
 `(rplaca (the cons ,a) ,b))

(defmacro qrplacd (a b)
 `(rplacd (the cons ,a) ,b))

(defmacro qrplq (&whole form pattern exp)
 (if (or (consp pattern) (simple-vector-p pattern))
  `(,(rcqexp pattern) ,exp)
   (macro-invalidargs 'qrplq form "form must be updateable.")))

(defmacro qsadd1 (x)
 `(the fixnum (1+ (the fixnum ,x))))

(defmacro qsdec1 (x)
 `(the fixnum (1- (the fixnum ,x))))

(defmacro qsdifference (x y)
 `(the fixnum (- (the fixnum ,x) (the fixnum ,y))))

(defmacro qsetq (&whole form pattern exp)
 (declare (ignore form))
  `(,(dcqexp pattern '=) ,exp))

(defmacro qsetrefv (vec ind val)
 `(setf (svref ,vec (the fixnum ,ind)) ,val))

(defmacro qsetvelt (vec ind val)
 `(setf (svref ,vec (the fixnum ,ind)) ,val))

(defmacro qsetvelt-1 (vec ind val)
 `(setf (svref ,vec (the fixnum (1- (the fixnum ,ind)))) ,val))

(defmacro qsgreaterp (a b)
 `(> (the fixnum ,a) (the fixnum ,b)))

(defmacro qsinc1 (x)
 `(the fixnum (1+ (the fixnum ,x))))

(defmacro qsleftshift (a b)
 `(the fixnum (ash (the fixnum ,a) (the fixnum ,b))))

(defmacro qslessp (a b)
 `(< (the fixnum ,a) (the fixnum ,b)))

(defmacro qsmax (x y)
 `(the fixnum (max (the fixnum ,x) (the fixnum ,y))))

(defmacro qsmin (x y)
 `(the fixnum (min (the fixnum ,x) (the fixnum ,y))))

(defmacro qsminus (x)
 `(the fixnum (minus (the fixnum ,x))))

(defmacro qsminusp (x)
 `(minusp (the fixnum ,x)))

(defmacro qsoddp (x)
 `(oddp (the fixnum ,x)))

(defmacro qsabsval (x)
  `(the fixnum (abs (the fixnum ,x))))

(defmacro qsplus (x y)
 `(the fixnum (+ (the fixnum ,x) (the fixnum ,y))))

(defmacro qssub1 (x)
 `(the fixnum (1- (the fixnum ,x))))

(defmacro qstimes (x y)
 `(the fixnum (* (the fixnum ,x) (the fixnum ,y))))

(defmacro qstringlength (x)
 `(the fixnum (length (the simple-string ,x))))

(defmacro qszerop (x)
 `(zerop (the fixnum ,x)))

(defmacro qvelt (vec ind)
 `(svref ,vec (the fixnum ,ind)))

(defmacro qvelt-1 (vec ind)
 `(svref ,vec (the fixnum (1- (the fixnum ,ind)))))

(defmacro qvmaxindex (x)
 `(the fixnum (1- (the fixnum (length (the simple-vector ,x))))))

(defmacro qvsize (x)
 `(the fixnum (length (the simple-vector ,x))))

(defmacro refvecp (v) `(simple-vector-p ,v))

(defmacro resetq (a b)
 `(prog1 ,a (setq ,a ,b)))

(defmacro rnump (n)
 `(floatp ,n))

(defmacro rplq (&whole form exp pattern)
 (if (or (consp pattern) (simple-vector-p pattern))
  `(,(rcqexp pattern) ,exp)
   (macro-invalidargs 'rplq form "form must be updateable.")))

(defmacro rvecp (v)
 `(typep ,v '(vector float)))

(defmacro setandfileq (id item)
 `(eval-when (eval load) 
   (setq ,id ,item)
   (lam\,fileactq ',id (list 'setq ',id (list 'quote ,id)))))

(defmacro setelt (vec ind val)
 `(setf (elt ,vec ,ind) ,val))

(defmacro setqp (&whole form pattern exp)
 (declare (ignore form))
  `(,(dcqexp pattern '=) ,exp))

(defmacro seq (&rest form)
  (let* ((body (reverse form))
         (val `(return-from seq ,(pop body))))
    (nsubstitute '(progn) nil body) ;don't treat NIL as a label
    `(block seq (tagbody ,@(nreverse body) ,val))))

(defmacro sfp (x)
 `(special-form-p ,x))

(defmacro |shoeConsole| (line)
 `(write-line ,line *terminal-io*))

(defmacro |shoeInputFile| (filespec)
 `(open ,filespec :direction :input :if-does-not-exist nil))

(defmacro |shoeread-line| (st)
 `(read-line ,st nil nil))

(defmacro sintp (n)
 `(typep ,n 'fixnum))

(defmacro smintp (n)
 `(typep ,n 'fixnum))

(defmacro stringlength (x)
 `(length (the string ,x)))

(defmacro subrp (x)
 `(compiled-function-p ,x))

(defmacro sub1 (x)
 `(1- ,x))

(defmacro throw-protect (exp1 exp2)
 `(unwind-protect ,exp1 ,exp2))

(defmacro times (&rest args)
 `(* ,@args))

(defmacro vec-setelt (vec ind val)
 `(setf (svref ,vec ,ind) ,val))

(defmacro vecp (v) `(simple-vector-p ,v))

(defmacro zero? (x)
  `(and (typep ,x 'fixnum) (zerop (the fixnum ,x))))

;; defuns

(defun define-function (f v)
 (setf (symbol-function f) v))

(define-function 'tempus-fugit #'get-internal-run-time)

(defun $TOTAL-ELAPSED-TIME ()
   (list (get-internal-run-time) (get-internal-real-time)))

(defun $TOTAL-GC-TIME (&aux (gcruntime (system:gbc-time)))
  (if (minusp gcruntime)
      (setq gcruntime (system:gbc-time 0)))
  (list gcruntime gcruntime))

; 7.0 Macros

; 7.2 Creating Macro Expressions

; 5.2 Functions

; 5.2.2 Lambda Expressions

(defun *LAM (body)
  (cond  ((NOT (ISQUOTEDP (first BODY))) (cons 'LAMBDA BODY))
         ((LET* ((BV (DEQUOTE (first BODY)))
                 (CONTROL (QUOTESOF (first BODY)))
                 (BODY (cdr BODY))
                 (ARGS (GENSYM))
                 (INNER-FUNC (or *lam-name* (gentemp))))
            (COMP370 (LIST INNER-FUNC `(LAMBDA ,BV . ,BODY)))
            `(MLAMBDA ,ARGS
                      (CONS (QUOTE ,INNER-FUNC)
                            (WRAP (cdr ,ARGS) ',CONTROL)))))))

(defun ISQUOTEDP (bv)
  (COND ((NOT (consp BV)) NIL)
        ((EQ (first BV) 'QUOTE))
        ((AND (consp (first BV)) (EQ (QCAAR BV) 'QUOTE)))
        ((ISQUOTEDP (cdr BV)))))

(defun QUOTESOF (BV)
  (COND ((NOT (consp BV)) NIL)
      ((EQ (first BV) 'QUOTE) 'QUOTE)
      ((CONS (COND ((NOT (consp (first BV))) nil)
                   ((EQ (QCAAR BV) 'QUOTE) 'QUOTE)
                   (T NIL))
             (QUOTESOF (cdr BV))))))

(defun DEQUOTE (BV)
  (COND ((NOT (consp BV)) BV)
        ((EQ 'QUOTE (first BV)) (second BV))
        ((CONS (if (EQ 'QUOTE (IFCAR (CAR BV))) (CADAR BV) (first BV))
               (DEQUOTE (cdr BV))))))

; 7.4 Using Macros

; Beats me how to simulate macro expansion "in the environment of sd"...:

(defun MDEF (arg item &optional sd)
 (declare (ignore sd))
  (macroexpand `(,arg ,item)))

(define-function 'MDEFX #'MDEF)

; 8.0 Operator Definition and Transformation

; 8.1 Definition and Transformation Operations

(defun COMP370 (fnlist)
  (cond ((atom (car fnlist)) (list (COMPILE1 fnlist)))
        (t (MAPCAR #'(lambda (x) (COMPILE1 x)) fnlist))))

(defun COMPILE1 (fn)
  (let* (nargs
         (fname (car fn))
         (lamda (cadr fn))
         (ltype (car lamda))
         *vars* *decl* args
         (body (cddr lamda)))
    (declare (special *vars* *decl*))
    (if (eq ltype 'LAM)
        (let ((*lam-name* (intern (concat fname "\,LAM"))))
          (setq lamda (eval lamda) ltype (car lamda) body (cddr lamda))))
    (let ((dectest (car body)))
      (if (and (eqcar dectest 'declare) (eqcar (cadr dectest) 'special))
	  (setq *decl* (cdr (cadr dectest)) body (cdr body))))
    (setq args (remove-fluids (cadr lamda)))
    (cond ((and (eq ltype 'lambda) (simple-arglist args)) (setq nargs args))
          (t (setq nargs (gensym))
             (setq body `((dsetq ,args  ,nargs) ,@body))
             (cond ((eq ltype 'lambda) (setq nargs `(&rest ,nargs &aux ,@*vars*)))
                   ((eq ltype 'mlambda)
                    (setq nargs `(&whole ,nargs &rest ,(gensym) &aux ,@*vars*)))
                   (t (error "bad function type")))))
    (cond (*decl* (setq body (cons `(declare (special ,@ *decl*)) body))))
    (setq body
          (cond ((eq ltype 'lambda) `(defun ,fname ,nargs . ,body))
                ((eq ltype 'mlambda) `(defmacro ,fname ,nargs . ,body))))
    (if *COMP370-APPLY* (funcall *COMP370-APPLY* fname body))

    body))

(defun simple-arglist (arglist)
  (or (null arglist)
      (and (consp arglist) (null (cdr (last arglist)))
           (every #'symbolp arglist))))

(defun remove-fluids (arglist &aux f v) ;updates specials *decl* and *vars*
  (declare (special *decl* *vars*))
   (cond ((null arglist) arglist)
         ((symbolp arglist) (push arglist *vars*) arglist)
                ;if atom but not symbol, ignore value
         ((atom arglist) (push (setq arglist (gentemp)) *vars*) arglist)
         ((and (setq f (car arglist))
               (eq f 'fluid)
               (listp (cdr arglist))
               (setq v (cadr arglist))
               (identp v)
               (null (cddr arglist)))
          (push v *decl*)
          (push v *vars*)
          v)
         (t (cons (remove-fluids (car arglist))
                  (remove-fluids (cdr arglist))))))

(define-function 'KOMPILE #'COMP370)

; 9.4 Vectors and Bpis

(defun IVECP (x) (and (vectorp x) (subtypep (array-element-type x) 'integer)))

(defun mbpip (item) (and (symbolp item) ;cannot know a compiled macro in CLISP
                         (compiled-function-p (macro-function item))))

(defun FBPIP (item) (or (compiled-function-p item)
			(and (symbolp item) (fboundp item)
			     (not (macro-function item))
			     (compiled-function-p (symbol-function item)))))

; 9.5 Identifiers

(defun gensymp (x) (and (symbolp x) (null (symbol-package x))))

(defun dig2fix (x)
  (if (symbolp x)
    (digit-char-p (char (symbol-name x) 0))
    (digit-char-p x)))

(defun LN (x) (LOG x))

(defun LOG2 (x) (LOG x 2.0))
(defun |log| (x) (LOG x 10.0))

; 9.13 Streams

(defun IS-CONSOLE (stream)
  (and (streamp stream) (output-stream-p stream)
       (eq (system:fp-output-stream stream)
           (system:fp-output-stream *terminal-io*))))

; 10.0 Control Structures

; 10.8.4 Auxiliary Operators

(defun nilfn (&rest ignore)
 (declare (ignore ignore)) 
 ())

; 11.0 Operations on Identifiers

; 11.1 Creation

(defun upcase (l)
  (cond ((stringp l) (string-upcase l))
        ((identp l) (intern (string-upcase (symbol-name l))))
        ((characterp l) (char-upcase l))
        ((atom l) l)
        (t (mapcar #'upcase l))))

(define-function 'U-CASE #'upcase)
(define-function 'LC2UC #'upcase)

(defun downcase (l)
  (cond ((stringp l) (string-downcase l))
        ((identp l) (intern (string-downcase (symbol-name l))))
        ((characterp l) (char-downcase L))
        ((atom l) l)
        (t (mapcar #'downcase l))))

(define-function 'L-CASE #'downcase)

; 11.2 Accessing

;; note it is important that PNAME returns nil not an error for non-symbols
(defun pname (x)
  (cond ((symbolp x) (symbol-name x))
	((characterp x) (string x))
	(t nil)))

;; property lists in vmlisp are alists
(defun PROPLIST (x)
  (if (symbolp x)
   (plist2alist (symbol-plist x))
    nil))

(defun plist2alist (x)
  (if (null x) 
      nil
      (cons (cons (first x) (second x)) (plist2alist (cddr x)))))

(defun put (sym ind val) (setf (get sym ind) val))

(define-function 'MAKEPROP #'put)

; 12.0 Operations on Numbers

@
\section{The digits-by-radix function} 
The purpose of the following function is to calculate the number of
digits in the radix $B$ expansion of an arbitrary Lisp integer $n$.
The width of an integer can be determined rapidly when the radix is a
power of two, otherwise an approach based on successive divisions is
used.

We have a subfunction called ``power-of-two-width''.
When the radix $B$ is of the form $2^b$, $b$ bits are needed to
represent one radix $B$ digit. The radix $B$ width of $n$ is obtained
by dividing the width of the binary representation of $n$ by $b$, and
incrementing the result when the remainder is non-zero.

We have a subfunction called ``digits-by-radix''.
When the radix is not a power of two, we choose a power $p$ of the
radix $B$ and use $B^p$ as a divisor.  Each division counts as $p$
digits in the radix $B$ expansion.  The power, bound to the variable
[[digits]] below, is chosen so that $B^p <$
\texttt{most-positive-long-float}. This allows use of [[log]] to
compute $p$ without concern for floating point overflow.  Once a
quotient is produced which is smaller than the divisor, we complete
the calculation by repeated divisions using the radix itself.

@
<<*>>=
(defun digits-by-radix (n &optional (radix 10))
  (flet (
   (power-of-two-width (n radix)
    (let ((bits (integer-length n))
          (radix-bits (1- (integer-length radix))))
      (multiple-value-bind (quo rem) (floor bits radix-bits)
        (if (zerop rem) quo (1+ quo)))))
   (iterative-width (n radix)
     (multiple-value-bind (q width)
         (let* ((target (if (< n most-positive-long-float)
                            (values n)
                            (values most-positive-long-float)))
                (digits (let ((d (floor (log target radix))))
                          (if (zerop d) 1 d)))
                (div (expt radix digits)))
           (loop for q = n then (floor q div)
                 until (< q div) sum digits into width
                 finally (return (values q width))))
       (+ width (loop for r = q then (floor r radix)
                      until (zerop r) count t))))
      )
    (assert (>= radix 2) (radix) 
            "Bad radix ~D < 2 given to DIGITS-BY-RADIX." radix)
    (setq n (abs n))
    (cond
      ((zerop n) (values 1))
      ((zerop (logand radix (1- radix))) (power-of-two-width n radix))
      (t (iterative-width n radix)))))


; 12.1 Conversion

(define-function 'FIX #'truncate)
(define-function 'INT2RNUM #'float)

; 12.2 Predicates

;(define-function 'lessp #'<)

;(define-function 'greaterp #'>)


;(define-function 'fixp #'integerp)

; 12.3 Computation

;(define-function 'add1 #'1+)
;(define-function 'sub1 #'1-)
;(define-function 'plus #'+)
;(define-function 'times #'*)
;(define-function 'difference #'-)
;(define-function 'minus #'-)
;(define-function 'absval #'abs)

(defun QUOTIENT (x y)
  (cond ((or (floatp x) (floatp y)) (lisp:/ x y))
        (t (truncate x y))))

(define-function 'vm/ #'quotient)

(defun REMAINDER (x y)
  (if (and (integerp x) (integerp y))
      (rem x y)
      (- x (* y (QUOTIENT x y)))))

(defun DIVIDE (x y)
  (if (and (integerp x) (integerp y))
      (multiple-value-list (truncate x y))
      (list (QUOTIENT x y) (REMAINDER x y))))

(defun QSQUOTIENT (a b) (the fixnum (truncate (the fixnum a) (the fixnum b))))

(defun QSREMAINDER (a b) (the fixnum (rem (the fixnum a) (the fixnum b))))

; 13.3 Updating


(defun RPLPAIR (pair1 pair2)
  (RPLACA pair1 (CAR pair2))
  (RPLACD pair1 (CDR pair2)) pair1)

(defun RPLNODE (pair1 ca2 cd2)
 (RPLACA pair1 ca2) 
 (RPLACD pair1 cd2) pair1)

; 14.0 Operations on Lists

; 14.1 Creation

(defun VEC2LIST (vec) (coerce vec 'list))

(defun |remove| (list item &optional (count 1))
  (if (integerp count)
      (remove item list :count count :test #'equalp)
      (remove item list :test #'equalp)))

(defun REMOVEQ (list item &optional (count 1))
  (if (integerp count)
      (remove item list :count count :test #'eq)
      (remove item list :test #'eq)))

; 14.2 Accessing

(defun |last| (x) (car (lastpair x)))

; 14.3 Searching

(DEFUN |assoc| (X Y)
  "Return the pair associated with key X in association list Y."
  ; ignores non-nil list terminators
  ; ignores non-pair a-list entries
  (cond ((symbolp X)
	 (PROG NIL
	       A  (COND ((ATOM Y) (RETURN NIL))
			((NOT (consp (CAR Y))) )
			((EQ (CAAR Y) X) (RETURN (CAR Y))) )
	       (SETQ Y (CDR Y))
	       (GO A)))
	((or (numberp x) (characterp x))
	 (PROG NIL
	       A  (COND ((ATOM Y) (RETURN NIL))
			((NOT (consp (CAR Y))) )
			((EQL (CAAR Y) X) (RETURN (CAR Y))) )
	       (SETQ Y (CDR Y))
	       (GO A)))
	(t
	 (PROG NIL
	       A  (COND ((ATOM Y) (RETURN NIL))
			((NOT (consp (CAR Y))) )
			((EQUAL (CAAR Y) X) (RETURN (CAR Y))) )
	       (SETQ Y (CDR Y))
	       (GO A)))))
; 14.5 Updating

(defun NREMOVE (list item &optional (count 1))
  (if (integerp count)
      (delete item list :count count :test #'equal)
      (delete item list :test #'equal)))

(defun NREMOVEQ (list item &optional (count 1))
  (if (integerp count)
      (delete item list :count count )
      (delete item list )))

(defun EFFACE (item list) (delete item list :count 1 :test #'equal))

(defun NCONC2 (x y) (NCONC x y)) ;NCONC with exactly two arguments

; 14.6 Miscellaneous

(defun QSORT (l)
 (declare (special sortgreaterp))
  (NREVERSE (sort (copy-seq l) SORTGREATERP)))

(defun SORTBY (keyfn l)
 (declare (special sortgreaterp))
  (nreverse (sort (copy-seq l) SORTGREATERP :key keyfn)))

; 16.0 Operations on Vectors

; 16.1 Creation

(defun MAKE-VEC (n) (make-array n))

(define-function 'GETREFV #'make-array)

@
Waldek Hebisch points out that, in the expression:
\begin{verbatim}
  reduce(+,[1.0/i for i in 1..20000])
\end{verbatim}
a significant amount of the time is spent in this function.
A special case was added to significantly reduce the execution time.
This was a problem in GCL as of 2.6.8pre and may be fixed in future
releases. If it is fixed then the original definition, which was
\begin{verbatim}
(defun LIST2VEC (list) (coerce list 'vector))
\end{verbatim}
can be restored.
<<*>>=
(defun LIST2VEC (list)
 (if (consp list)
  (let* ((len (length list))
         (vec (make-array len)))
    (dotimes (i len)
     (setf (aref vec i) (pop list)))
    vec)
  (coerce list 'vector)))

(define-function 'LIST2REFVEC #'LIST2VEC)

; 16.2 Accessing


;(define-function 'FETCHCHAR #'char)

(define-function 'MOVEVEC #'replace)

; 17.0 Operations on Character and Bit Vectors

(defun charp (a) (or (characterp a)
                     (and (identp a) (= (length (symbol-name a)) 1))))

(defun NUM2CHAR (n) (code-char n))

(defun CHAR2NUM (c) (char-code (character c)))

(defun CGREATERP (s1 s2) (string> (string s1) (string s2)))

(define-function 'STRGREATERP #'CGREATERP)

; 17.1 Creation

(define-function 'strconc #'concat)

(defun make-cvec (sint) (make-array sint :fill-pointer 0 :element-type 'string-char))

(define-function 'getstr #'make-cvec)

(defun make-full-cvec (sint &optional (char #\space))
  (make-string sint :initial-element (character char)))

(define-function 'getfullstr #'make-full-cvec)

; 17.2 Accessing

(defun QESET (cvec ind charnum)
  (setf (char cvec ind) (code-char charnum)))

(defun string2id-n (cvec sint)
  (if (< sint 1)
      nil
      (let ((start (position-if-not #'(lambda (x) (char= x #\Space)) cvec)))
        (if start
            (let ((end (or (position #\Space cvec :start start) (length cvec))))
              (if (= sint 1)
                  (intern (subseq cvec start end))
                  (string2id-n (subseq cvec end) (1- sint))))
            0))))

(defun substring (cvec start length)
  (setq cvec (string cvec))
  (if length (subseq cvec start (+ start length)) (subseq cvec start)))

; 17.3 Searching

; 17.4 Updating operators

(defun suffix (id cvec)
  "Suffixes the first char of the symbol or char ID to the string CVEC,
    changing CVEC."
  (unless (characterp id) (setq id (elt (string id) 0)))
  (cond ((array-has-fill-pointer-p cvec)
	 (vector-push-extend id cvec)
	 cvec)
	((adjustable-array-p cvec)
	 (let ((l (length cvec)))
	   (adjust-array cvec (1+ l))
	   (setf (elt cvec l) id)
	   cvec))
	(t (concat cvec id))))

(defun setsize (vector size) (adjust-array vector size))

(define-function 'changelength #'setsize)

(defun trimstring (x) x)

; The following version has been provided to avoid reliance on the
; Common Lisp concatenate and replace functions. These built-in Lisp
; functions would probably end up doing the character-by-character
; copying shown here, but would also need to cope with generic sorts
; of sequences and unwarranted keyword generality

(defun rplacstr (cvec1 start1 length1 cvec2
                       &optional start2 length2
                       &aux end1 end2)
  (setq cvec2 (string cvec2))
  (if (null start1) (setq start1 0))
  (if (null start2) (setq start2 0))
  (if (null length1) (setq length1 (- (length cvec1) start1)))
  (if (null length2) (setq length2 (- (length cvec2) start2)))
  (setq end1 (+ start1 length1))
  (setq end2 (+ start2 length2))
  (if (= length1 length2)
      (do ()
          ((= start1 end1) cvec1)
          (setf (aref cvec1 start1) (aref cvec2 start2))
          (setq start1 (1+ start1))
          (setq start2 (1+ start2)))
      (let* ((l1 (length cvec1))
             (r (lisp::make-string (- (+ l1 length2) length1)))
             (i 0))
         (do ((j 0 (1+ j)))
             ((= j start1))
             (setf (aref r i) (aref cvec1 j))
             (setq i (1+ i)))
         (do ((j start2 (1+ j)))
             ((= j end2))
             (setf (aref r i) (aref cvec2 j))
             (setq i (1+ i)))
         (do ((j end1 (1+ j)))
             ((= j l1))
             (setf (aref r i) (aref cvec1 j))
             (setq i (1+ i)))
         r)
  ))

; 19.0 Operations on Arbitrary Objects

; 19.1 Creating

(defun MSUBST (new old tree) (subst new old tree :test #'equal))
; note subst isn't guaranteed to copy
(defun |nsubst| (new old tree) (nsubst new old tree :test #'equal))
(define-function 'MSUBSTQ #'subst) ;default test is eql
(define-function 'SUBSTQ #'SUBST) ;default test is eql subst is not guaranteed to copy

(defun copy (x) (copy-tree x)) ; not right since should descend vectors

(defun eqsubstlist (new old list) (sublis (mapcar #'cons old new) list))

; Gen code for SETQP expr

(eval-when (compile load eval)
 (defun DCQEXP (FORM EQTAG)
  (PROG (SV pvl avl CODE)
        (declare (special pvl avl))
        (setq SV (GENSYM))
        (setq CODE (DCQGENEXP SV FORM EQTAG NIL))
        (RETURN
          `(LAMBDA (,sv)
             (PROG ,pvl
                   ,@code
                   (RETURN 'true)
                BAD (RETURN NIL) ) ))))
)
; Generate Expr code for DCQ
(eval-when (compile load eval)
 (defun DCQGENEXP (SV FORM EQTAG QFLAG)
  (PROG (D A I L C W)
        (declare (special pvl avl))
    (COND ((EQ FORM SV) (RETURN NIL))
          ((IDENTP FORM) (RETURN `((setq ,form ,sv)) ))
          ((simple-vector-p FORM)
           (RETURN (SEQ
             (setq L (length FORM))
             (IF (EQ L 0)
                 (RETURN (COND ((NULL QFLAG)
                                `((cond ((not (simple-vector-p ,sv)) (go bad))))))))
             (setq I (1- L))
         LP  (setq A (elt FORM I))
             (COND ((AND (NULL W) (OR (consp A) (simple-vector-p A)))
                    (COND ((consp AVL) (setq W (car (RESETQ AVL (cdr AVL)))))
                          ((setq PVL (CONS (setq W (GENSYM)) PVL))))))
             (setq C (NCONC (COND ((IDENTP A) `((setq ,a (ELT ,sv ,i))))
                                  ((OR (consp A) (simple-vector-p A))
                                   `((setq ,w (ELT ,sv ,i))
                                     ,@(dcqgenexp w a eqtag qflag))))
                            C))
             (if (EQ I 0) (GO RET))
             (setq I (1- I))
             (GO LP)
         RET (if W (setq AVL (CONS W AVL)))
             (COND ((NULL QFLAG)
                    `((COND ((OR (NOT (simple-vector-p ,sv)) (< (length ,sv) ,l))
                             (GO BAD)))
                      ,@c))
                   ('T C)))))
          ((NOT (consp FORM)) (RETURN NIL))
          ((AND EQTAG (EQ (car FORM) EQTAG))
           (RETURN
             (COND
               ((OR (NOT (EQ 3 (LENGTH FORM))) (NOT (IDENTP (car (setq FORM (cdr FORM))))))
                (MACRO-INVALIDARGS 'DCQ\/QDCQ FORM (MAKESTRING "invalid pattern.")))
               (`((setq ,(car form) ,sv)  ,@(DCQGENEXP SV (CADR FORM) EQTAG QFLAG)))))))
    (setq A (car FORM))
    (setq D (cdr FORM))
    (setq C (COND ((IDENTP A) `((setq ,a (CAR ,sv))))
                  ((OR (consp A) (simple-vector-p A))
                   (COND ((AND (NULL D) (IDENTP SV)) )
                         ((COND ((consp AVL) (setq W (car (RESETQ AVL (cdr AVL)))))
                                ((setq PVL (CONS (setq W (GENSYM)) PVL)) ) ) ) )
                   (COND ((AND (consp A) EQTAG (EQ (car A) EQTAG))
                          (DCQGENEXP (LIST 'CAR SV) A EQTAG QFLAG) )
                         (`((setq ,(or w sv) (CAR ,sv))
                            ,@(DCQGENEXP (OR W SV) A EQTAG QFLAG)))))))
    (setq C (NCONC C (COND ((IDENTP D) `((setq ,d (CDR ,sv))))
                           ((OR (consp D) (simple-vector-p D))
                            (COND
                              ((OR W (IDENTP SV)) )
                              ((COND ((consp AVL)
                                      (setq W (car (RESETQ AVL (cdr AVL)))) )
                                     ((setq PVL (CONS (setq W (GENSYM)) PVL)) ) ) ) )
                            (COND ((AND (consp D) EQTAG (EQ (car D) EQTAG))
                                   (DCQGENEXP (LIST 'CDR SV) D EQTAG QFLAG) )
                                  (`((setq ,(or w sv) (CDR ,sv))
                                     ,@(DCQGENEXP (OR W SV) D EQTAG QFLAG))))))))
    (COND (W (setq AVL (CONS W AVL))))
    (RETURN (COND ((NULL QFLAG) `((COND ((ATOM ,sv) (GO BAD))) ,@c)) (C)))))
)


; 19.3 Searching

; Generate code for EQQ

(eval-when (compile load eval)
 (defun ECQEXP (FORM QFLAG)
  (PROG (SV PVL CODE)
        (declare (special pvl))
        (setq SV (GENSYM))
        (setq CODE (ECQGENEXP SV FORM QFLAG))
        (RETURN
              `(LAMBDA (,sv)
                 (PROG ,pvl
                       ,@code
                       (RETURN 'true)
                    BAD (RETURN NIL) ) ))))
)

; Generate code for EQQ innards

(eval-when (compile load eval)
 (defun ECQGENEXP (SV FORM QFLAG)
  (PROG (D A I L C W)
        (declare (special pvl))
        (COND
          ((EQ FORM SV) (RETURN NIL))
          ((OR
              (IDENTP FORM)
              (NUMP FORM)
              (AND (consp FORM) (EQ (qcar FORM) 'QUOTE)))
           (RETURN
             `((COND ((NOT (EQ ,form ,sv)) (GO BAD))) )))
          ((simple-vector-p FORM)
           (RETURN (SEQ
              (setq L (length FORM))
              (if (EQ L 0)
                  (RETURN
                    (COND ((NULL QFLAG)
                           `((COND ((NOT (simple-vector-p ,sv)) (GO BAD))) )))
                    ))
              (setq I (1- L))
           LP (setq A (elt FORM I))
              (if (AND (NULL W) (OR (consp A) (simple-vector-p A)))
                  (push (setq W (GENSYM)) PVL))
              (setq C
                    (NCONC
                      (COND
                        ( (OR
                            (IDENTP A)
                            (NUMP A)
                            (AND (consp A) (EQ (qcar A) 'QUOTE)))
                         `((COND ( (NOT (EQ ,a (ELT ,sv ,i)))
                                  (GO BAD) ) ) ) )
                        ( (OR (consp A) (simple-vector-p A))
                         `((setq ,w (ELT ,sv ,i))
                           ,@(ECQGENEXP W A QFLAG))))
                      C) )
              (if (EQ I 0) (GO RET) )
              (setq I (1- I))
              (GO LP)
           RET
              (COND
                ( (NULL QFLAG)
                 `((COND ( (OR
                             (NOT (simple-vector-p ,sv))
                             (< (length ,sv) ,l))
                          (GO BAD) ) )
                   ,@c))
                ( 'T C ) )) ))
          ( (NOT (consp FORM))
           (RETURN NIL) ) )
        (setq A (car FORM))
        (setq D (cdr FORM))
        (if (OR (consp A) (simple-vector-p A) (consp D) (simple-vector-p D))
           (setq PVL (CONS (setq W (GENSYM)) PVL)))
        (setq C
              (COND
                ( (OR (IDENTP A) (NUMP A) (AND (consp A) (EQ (car A) 'QUOTE)))
                 `((COND ((NOT (EQ ,a (CAR ,sv))) (GO BAD))) ))
                ( (OR (consp A) (simple-vector-p A))
                 `((setq ,w (CAR ,sv))
                   ,@(ECQGENEXP W A QFLAG)))))
        (setq C
              (NCONC
                C
                (COND
                  ( (OR (IDENTP D) (NUMP D) (AND (consp D)
                                                 (EQ (car D) 'QUOTE)))
                   `((COND ((NOT (EQ ,d (CDR ,sv))) (GO BAD))) ))
                  ( (OR (consp D) (simple-vector-p D))
                   `((setq ,sv (CDR ,sv))
                     ,@(ECQGENEXP SV D QFLAG))))))
        (RETURN
          (COND
            ( (NULL QFLAG)
             `((COND ( (ATOM ,sv)
                      (GO BAD) ) )
               ,@c))
            ( 'T
             C ) )) ) )
)

; 19.4 Updating

; Generate code for RPLQ exprs

(eval-when (compile load eval)
 (defun RCQEXP (FORM)
    (PROG (SV PVL CODE)
          (declare (special pvl))
      (setq SV (GENSYM))
      (setq CODE (RCQGENEXP SV FORM NIL))
      (RETURN
        `(LAMBDA (,sv)
              (PROG ,pvl
                ,@code
                (RETURN 'true)
            BAD (RETURN NIL) ) ))))
)

; Generate code for RPLQ expr innards

(eval-when (compile load eval)
 (defun RCQGENEXP (SV FORM QFLAG)
    (PROG (D A I L C W)
          (declare (special pvl))
      (COND
        ( (EQ FORM SV)
          (RETURN NIL) )
        ( (simple-vector-p FORM)
         (RETURN (SEQ
            (setq L (length FORM))
            (if (EQ L 0) (RETURN NIL))
            (setq I (1- L))
        LP  (setq A (elt FORM I))
            (COND
              ( (AND
                  (NULL W)
                  (OR (AND (consp A) (NOT (EQ (car A) 'QUOTE)))
                           (simple-vector-p A)))
                (setq PVL (CONS (setq W (GENSYM)) PVL)) ) )
            (setq C
              (NCONC
                (COND
                  ( (OR
                      (IDENTP A)
                      (NUMP A)
                      (AND (consp A) (EQ (car A) 'QUOTE)))
                    `((SETELT ,sv ,i ,a)))
                  ( (OR (consp A) (simple-vector-p A))
                    `((setq ,w (ELT ,sv ,i))
                      ,@(RCQGENEXP W A QFLAG))))
                C) )
            (COND
              ( (EQ I 0)
                (GO RET) ) )
            (setq I (1- I))
            (GO LP)
        RET (RETURN
              (COND
                ( (NULL QFLAG)
                  `((COND ( (OR
                              (NOT (simple-vector-p ,sv))
                              (< (length ,sv) ,l))
                            (GO BAD) ) )
                    ,@c))
                ( 'T
                  C ) )) )))
        ( (NOT (consp FORM))
          (RETURN NIL) ) )
      (setq A (car FORM))
      (setq D (cdr FORM))
      (cond
        ( (or (and (consp A) (NOT (EQ (car A) 'QUOTE))) (simple-vector-p A))
          (setq PVL (CONS (setq W (GENSYM)) PVL)) ) )
      (setq C
        (COND
          ( (OR (IDENTP A) (NUMP A) (AND (consp A) (EQ (car A) 'QUOTE)))
            `((rplaca ,sv ,a)))
          ( (OR (consp A) (simple-vector-p A))
            `((setq ,w (CAR ,sv))
              ,@(RCQGENEXP W A QFLAG)))))
      (setq C
        (NCONC
          C
          (COND
            ( (OR (IDENTP D) (NUMP D) (AND (consp D) (EQ (car D) 'QUOTE)))
              `((RPLACD ,sv ,d)))
            ( (OR (consp D) (simple-vector-p D))
              `((setq ,sv (CDR ,sv))
                ,@(RCQGENEXP SV D QFLAG))))))
      (RETURN
        (COND
          ( (NULL QFLAG)
            `((COND ( (ATOM ,sv)
                      (GO BAD) ) )
              ,@c))
          ( 'T
            C ) )) ) )
)

; 22.0 Internal and External Forms

; 23.0 Reading


(define-function 'next #'read-char)

; 24.0 Printing

@
\section{The StringImage Fix}
In GCL 2.5 there is a bug in the write-to-string function.
It should respect *print-escape* but it does not. That is,
\begin{verbatim}

In GCL 2.4.1:
(setq *print-escape* nil)
(write-to-string '|a|) ==> "a"

In GCL 2.5:
(setq *print-escape* nil)
(write-to-string '|a|) ==> "|a|"

\end{verbatim}
The form2LispString function uses stringimage and fails.
The princ-to-string function assumes *print-escape* is nil
and works properly.

<<*>>=
(define-function 'prin2cvec #'princ-to-string)
(define-function 'stringimage #'princ-to-string)
(define-function 'printexp #'princ)
(define-function 'prin0  #'prin1)

(defun |F,PRINT-ONE| (form &optional (stream *standard-output*))
 (declare (ignore stream))
    (let ((*print-level* 4) (*print-length* 4))
       (prin1 form) (terpri)))

(defun prettyprint (x &optional (stream *standard-output*))
  (prettyprin0 x stream) (terpri stream))

(defun prettyprin0 (x &optional (stream *standard-output*))
  (let ((*print-pretty* t) (*print-array* t))
    (prin1 x stream)))

(defun vmprint (x &optional (stream *standard-output*))
  (prin1 x stream) (terpri stream))

(defun tab (sint &optional (stream t))
  (format stream "~vT" sint))

; 27.0 Stream I/O


; 27.1 Creation

; 28.0 Key addressed I/O


; 46.0 Call tracing


(defun EMBEDDED () (mapcar #'car *embedded-functions*))

(defun EMBED (CURRENT-BINDING NEW-DEFINITION)
  (PROG (OP BV BODY OLD-DEF)
      (COND
        ( (NOT (IDENTP CURRENT-BINDING))
          (SETQ CURRENT-BINDING
                (error (format nil "invalid argument ~s to EMBED" CURRENT-BINDING))) ) )
      (SETQ OLD-DEF (symbol-function CURRENT-BINDING))
      (SETQ NEW-DEFINITION
        (SETF (symbol-function CURRENT-BINDING)
          (COND
            ( (NOT (consp NEW-DEFINITION))
              NEW-DEFINITION )
            ( (AND
                (DCQ (OP BV . BODY) NEW-DEFINITION)
                (OR (EQ OP 'LAMBDA) (EQ OP 'MLAMBDA)))
              (COND
                ( (NOT (MEMQ CURRENT-BINDING (FLAT-BV-LIST BV)))
                 `(,OP ,BV ((LAMBDA (,CURRENT-BINDING) . ,BODY) ',OLD-DEF))
                   )
                ( 'T
                  NEW-DEFINITION ) ) )
            ( 'T
              `((LAMBDA (,CURRENT-BINDING) ,NEW-DEFINITION) ',OLD-DEF)))
            ) )
      (push (LIST CURRENT-BINDING NEW-DEFINITION OLD-DEF) *embedded-functions*)
      (RETURN CURRENT-BINDING) ) )

(defun UNEMBED (CURRENT-BINDING)
    (PROG  (TMP E-LIST CUR-DEF)
      (SETQ E-LIST *embedded-functions*)
      (SETQ CUR-DEF (symbol-function CURRENT-BINDING))
      (COND
        ( (NOT (consp E-LIST))
          NIL )
        ( (ECQ ((CURRENT-BINDING CUR-DEF)) E-LIST)
          (SETF (symbol-function CURRENT-BINDING) (QCADDAR E-LIST))
          (SETQ *embedded-functions* (QCDR E-LIST))
          (RETURN CURRENT-BINDING) )
        ( 'T
          (SEQ
            (SETQ TMP E-LIST)
        LP  (COND
              ( (NOT (consp (QCDR TMP)))
                (EXIT NIL) )
              ( (NULL (ECQ ((CURRENT-BINDING CUR-DEF)) (QCDR TMP)))
                (SETQ TMP (QCDR TMP))
                (GO LP) )
              ( 'T
                (SETF (symbol-function  CURRENT-BINDING) (QCAR (QCDDADR TMP)))
                (RPLACD TMP (QCDDR TMP))
                (RETURN CURRENT-BINDING) ) ) ) ) )
      (RETURN NIL) ))

(defun FLAT-BV-LIST (BV-LIST)
  (PROG (TMP1)
      (RETURN
        (COND
          ( (VARP BV-LIST)
            (LIST BV-LIST) )
          ( (REFVECP BV-LIST)
            (FLAT-BV-LIST (VEC2LIST (MAPELT #'FLAT-BV-LIST BV-LIST))) )
          ( (NOT (consp BV-LIST))
            NIL )
          ( (EQ '= (SETQ TMP1 (QCAR BV-LIST)))
            (FLAT-BV-LIST (QCDR BV-LIST)) )
          ( (VARP TMP1)
            (CONS TMP1 (FLAT-BV-LIST (QCDR BV-LIST))) )
          ( (AND (NOT (consp TMP1)) (NOT (REFVECP TMP1)))
            (FLAT-BV-LIST (QCDR BV-LIST)) )
          ( 'T
            (NCONC (FLAT-BV-LIST TMP1) (FLAT-BV-LIST (QCDR BV-LIST))) ) )) ))

(defun VARP (TEST-ITEM)
    (COND
      ( (IDENTP TEST-ITEM)
        TEST-ITEM )
      ( (AND
          (consp TEST-ITEM)
          (OR (EQ (QCAR TEST-ITEM) 'FLUID) (EQ (QCAR TEST-ITEM) 'LEX))
          (consp (QCDR TEST-ITEM))
          (IDENTP (QCADR TEST-ITEM)))
        TEST-ITEM )
      ( 'T
        NIL ) ) )

; 48.0 Miscellaneous CMS Interactions

(defun CurrentTime ()
  (multiple-value-bind (sec min hour day month year) (get-decoded-time)
    (format nil "~2,'0D/~2,'0D/~2,'0D~2,'0D:~2,'0D:~2,'0D"
	    month day (rem year 100) hour min sec)))

(defun $screensize () '(24 80))          ; You tell me!!

; 97.0 Stuff In The Manual But Wierdly Documented

(defun EBCDIC (x) (int-char x))

;; This isn't really compatible but is as close as you can get in common lisp
;; In place of ((one-of 1 2 3) l)  you should use
;;   (funcall (one-of 1 2 3) l)

(defun doDSETQ (form pattern exp)
  (let (PVL AVL)
    (declare (special PVL AVL))
    (COND ((IDENTP PATTERN)
           (LIST 'SETQ PATTERN EXP))
          ((AND (NOT (consp PATTERN)) (NOT (simple-vector-p PATTERN)))
           (MACRO-INVALIDARGS 'DSETQ FORM "constant target."))
          ((let* ((SV (GENSYM))
                  (E-PART (DCQGENEXP (LIST 'IDENTITY SV) PATTERN '= NIL)))
             (setq e-part
                   `(LAMBDA (,sv)
                      (PROG ,pvl
                            ,@e-part
                            (RETURN ,sv)
                         BAD (RETURN (SETQERROR ,sv)))))
             `(,e-part ,exp))))))

(defun SETQERROR (&rest FORM) (error (format nil "in destructuring ~S" FORM)))




(defun MACRO-INVALIDARGS (NAME FORM MESSAGE)
    (setq MACERRORCOUNT  (+ 1 (eval 'MACERRORCOUNT)))
    (error (format nil 
                   "invalid arguments to macro ~S with invalid argument ~S, ~S"
                   name form message)))

(defun MACRO-MISSINGARGS (NAME ignore N)
  (declare (ignore ignore))
  (setq MACERRORCOUNT (+ 1 (eval 'MACERRORCOUNT)))
  (error (concatenate 'string (symbol-name NAME) " requires "
                       (if (minusp N) "at least " "exactly ")
                       (setq N (abs N))
                       (case N (0 "no") (1 "one") (2 "two") (3 "three")
                             (4 "four") (5 "five") (6 "six")
                             (t (princ-to-string N)))
                       (if (eq n 1) " argument," " arguments,"))))

(defun MACERR (MESSAGE &rest ignore)
  (declare (ignore ignore))
      (setq MACERRORCOUNT (+ 1 (eval 'MACERRORCOUNT)))
      (error
        (LIST "in the expression:" MESSAGE))
      ())

; 98.0 Stuff Not In The VMLisp Manual That We Like

; A version of GET that works with lists

; (defun getl (sym key )
;   (cond ((consp sym) (cdr (assoc key sym :test #'eq)))
;         ((symbolp sym) (get sym key))))
(defun getl (sym key )
  (cond ((consp sym) (cdr (assq key sym)))
        ((symbolp sym) (get sym key))))

; The following should actually position the cursor at the sint'th line of the screen:

(defun $showline (cvec sint) (terpri) sint (princ cvec))

; 99.0 Ancient Stuff We Decided To Keep

(defun LAM\,EVALANDFILEACTQ (name &optional (form name))
    (LAM\,FILEACTQ name form) (eval form))

(defun LAM\,FILEACTQ (name form)
       (if *FILEACTQ-APPLY* (FUNCALL *FILEACTQ-APPLY* name form)))

(defun CALLBELOW (&rest junk) junk) ; to invoke system dependent code?

(define-function 'EVA1 #'eval) ;EVA1 and VMLISP EVAL make lexicals visible
(define-function 'EVALFUN #'eval) ;EVALFUN drops lexicals before evaluating
(define-function 'EVA1FUN #'EVALFUN)

(defun PLACEP (item) (eq item *read-place-holder*))
(defun VMREAD (&optional (st *standard-input*) (eofval *read-place-holder*))
  (read st nil eofval))
(defun |read-line| (st &optional (eofval *read-place-holder*))
  (read-line st nil eofval))

(defun STATEP (item)
 (declare (ignore item))
   nil) ;no state objects
(defun FUNARGP (item)
 (declare (ignore item))
  nil) ;can't tell closures from other functions
(defun PAPPP (item)
 (declare (ignore item))
  nil) ;no partial application objects

(defun gcmsg (x)
   (prog1 system:*gbc-message* (setq system:*gbc-message* x)))

(defun reclaim () (gbc t))

(defun BPINAME (func)
  (if (functionp func)
      (cond ((symbolp func) func)
	    ((and (consp func) (eq (car func) 'LAMBDA-BLOCK))
	      (cadr func))
	    ((compiled-function-p func)
	     (system:compiled-function-name func))
	    ('t func))))

(defun LISTOFQUOTES (bpi)
 (declare (ignore bpi))
  ())

(defun LISTOFFREES (bpi)
 (declare (ignore bpi))
 ())

(defun OBEY (S) (SYSTEM S))

(defun RE-ENABLE-INT (number-of-handler) number-of-handler)

(defun equable (x) ;;def needed to prevent recursion in def of eqcar
  (or (null x) (and (consp x) (eq (car x) 'quote) (symbolp (cadr x)))))


(defun QUOREM (i j r) ; never used, refed in parini.boot
  (multiple-value-bind (x y) (truncate i j)
   (rplaca (the cons r) x) (rplacd (the cons r) y)))

(defun MAKE-BVEC (n)
 (make-array (list n) :element-type 'bit :initial-element 0))

(DEFUN LEXGREATERP (COMPERAND-1 COMPERAND-2)
    ;;  "Order of types: pair NIL vec ivec/rvec cvec ident num fbpi mbpi other"
    (COND
      ((EQ COMPERAND-1 COMPERAND-2) NIL)
      ((consp COMPERAND-1)
        (COND
          ( (consp COMPERAND-2)
            (COND
              ( (EQUAL (qcar COMPERAND-1) (qcar COMPERAND-2))
                (LEXGREATERP (qcdr COMPERAND-1) (qcdr COMPERAND-2)) )
              ( (LEXGREATERP (qcar COMPERAND-1) (qcar COMPERAND-2)) ) ) )
          ('else t)))
      ((consp COMPERAND-2) NIL)
      ((NULL COMPERAND-1) 'T )
      ((NULL COMPERAND-2) NIL)
      ((VECP COMPERAND-1)
        (COND
          ((VECP COMPERAND-2) (LEXVGREATERP COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((VECP COMPERAND-2) NIL)
      ((OR (IVECP COMPERAND-1) (RVECP COMPERAND-1))
        (COND
          ( (OR (IVECP COMPERAND-2) (RVECP COMPERAND-2))
            (LEXVGREATERP COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((OR (IVECP COMPERAND-2) (RVECP COMPERAND-2)) NIL )
      ((stringp COMPERAND-1)
        (COND
          ((stringp COMPERAND-2)
            (STRING-GREATERP COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((stringp COMPERAND-2) NIL)
      ((symbolp COMPERAND-1)
        (COND
          ((symbolp COMPERAND-2)
            (STRING-GREATERP (symbol-name COMPERAND-1) (symbol-name COMPERAND-2)) )
          ('else t)))
      ((symbolp COMPERAND-2) NIL )
      ((numberp COMPERAND-1)
        (COND
          ( (numberp COMPERAND-2)
            (> COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((numberp COMPERAND-2) NIL)
      ((CHARACTERP COMPERAND-1)
	(COND 
          ((CHARACTERP COMPERAND-2)
	    (CHAR-GREATERP COMPERAND-1 COMPERAND-2) )
	  ('else t)))
      ((CHARACTERP COMPERAND-2)	NIL )
      ((FBPIP COMPERAND-1)
        (COND
          ((FBPIP COMPERAND-2)
            (LEXGREATERP (BPINAME COMPERAND-1) (BPINAME COMPERAND-2)) )
          ('else t)))
      ((FBPIP COMPERAND-2) NIL)
      ((MBPIP COMPERAND-1)
        (COND
          ((MBPIP COMPERAND-2)
            (LEXGREATERP (BPINAME COMPERAND-1) (BPINAME COMPERAND-2)) )
          ('else t)))
      ((MBPIP COMPERAND-2)
        NIL )
      ((> (SXHASH COMPERAND-1) (SXHASH COMPERAND-2)))))

(DEFUN LEXVGREATERP (VECTOR-COMPERAND-1 VECTOR-COMPERAND-2)
  (declare (simple-vector vector-comperand-1 vector-comperand-2))
    (PROG (L1 L2 I T1 T2)
     (declare (fixnum i l1 l2) )
      (SETQ I -1)
      (SETQ L1 (length VECTOR-COMPERAND-1))
      (SETQ L2 (length VECTOR-COMPERAND-2))
  LP  (setq i (1+ i))
      (COND
        ((EQL L1 I) (RETURN NIL))
        ((EQL L2 I) (RETURN 'T)))
      (COND
        ((EQUAL
            (SETQ T1 (svref VECTOR-COMPERAND-1 I))
            (SETQ T2 (svref VECTOR-COMPERAND-2 I)))
          (GO LP)))
      (RETURN (LEXGREATERP T1 T2)) ) )


(DEFUN GGREATERP (COMPERAND-1 COMPERAND-2)
    ;;  "Order of types: pair NIL vec ivec/rvec cvec ident num fbpi mbpi other"
    (COND
      ((EQ COMPERAND-1 COMPERAND-2) NIL)
      ((symbolp COMPERAND-1)
        (COND
          ((symbolp COMPERAND-2)
            (CGREATERP (symbol-name COMPERAND-1) (symbol-name COMPERAND-2)) )
          ('else t)))
      ((symbolp COMPERAND-2) NIL )
      ((consp COMPERAND-1)
        (COND
          ( (consp COMPERAND-2)
            (COND
              ( (EQUAL (qcar COMPERAND-1) (qcar COMPERAND-2))
                (GGREATERP (qcdr COMPERAND-1) (qcdr COMPERAND-2)) )
              ( (GGREATERP (qcar COMPERAND-1) (qcar COMPERAND-2)) ) ) )
          ('else t)))
      ((consp COMPERAND-2) NIL)
      ((NULL COMPERAND-1) 'T )
      ((NULL COMPERAND-2) NIL)
      ((VECP COMPERAND-1)
        (COND
          ((VECP COMPERAND-2) (VGREATERP COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((VECP COMPERAND-2) NIL)
      ((OR (IVECP COMPERAND-1) (RVECP COMPERAND-1))
        (COND
          ( (OR (IVECP COMPERAND-2) (RVECP COMPERAND-2))
            (VGREATERP COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((OR (IVECP COMPERAND-2) (RVECP COMPERAND-2)) NIL )
      ((stringp COMPERAND-1)
        (COND
          ((stringp COMPERAND-2)
            (CGREATERP COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((stringp COMPERAND-2) NIL)
      ((numberp COMPERAND-1)
        (COND
          ( (numberp COMPERAND-2)
            (> COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((numberp COMPERAND-2) NIL)
      ((CHARACTERP COMPERAND-1)
	(COND 
          ((CHARACTERP COMPERAND-2)
	    (CHAR> COMPERAND-1 COMPERAND-2) )
	  ('else t)))
      ((CHARACTERP COMPERAND-2)	NIL )
      ((FBPIP COMPERAND-1)
        (COND
          ((FBPIP COMPERAND-2)
            (GGREATERP (BPINAME COMPERAND-1) (BPINAME COMPERAND-2)) )
          ('else t)))
      ((FBPIP COMPERAND-2) NIL)
      ((MBPIP COMPERAND-1)
        (COND
          ((MBPIP COMPERAND-2)
            (GGREATERP (BPINAME COMPERAND-1) (BPINAME COMPERAND-2)) )
          ('else t)))
      ((MBPIP COMPERAND-2)
        NIL )
      ((> (SXHASH COMPERAND-1) (SXHASH COMPERAND-2)))))

(DEFUN VGREATERP (VECTOR-COMPERAND-1 VECTOR-COMPERAND-2)
  (declare (simple-vector vector-comperand-1 vector-comperand-2))
    (PROG (L1 L2 I T1 T2)
     (declare (fixnum i l1 l2) )
      (SETQ I -1)
      (SETQ L1 (length VECTOR-COMPERAND-1))
      (SETQ L2 (length VECTOR-COMPERAND-2))
  LP  (setq i (1+ i))
      (COND
        ((EQL L1 I) (RETURN NIL))
        ((EQL L2 I) (RETURN 'T)))
      (COND
        ((EQUAL
            (SETQ T1 (svref VECTOR-COMPERAND-1 I))
            (SETQ T2 (svref VECTOR-COMPERAND-2 I)))
          (GO LP)))
      (RETURN (GGREATERP T1 T2)) ) )

(defvar SORTGREATERP #'GGREATERP "default sorting predicate")

;17.0 Operations on Hashtables
;17.1 Creation

(defun MAKE-HASHTABLE (id1 &optional (id2 nil))
 (declare (ignore id2))
   (let ((test (case id1
		     ((EQ ID) #'eq)
		     (CVEC #'equal)
		     (EQL #'eql)
		     ((UEQUAL EQUAL) #'equal)
		     (otherwise (error "bad arg to make-hashtable")))))     
      (make-hash-table :test test)))

;17.2 Accessing


@
The static declaration causes a problem as of GCL-2.6.8pre.
Camm issued a fix. This used to read:
\begin{verbatim}
#+AKCL
(clines "static int mem_value(x ,i)object x;int i; { return ((short *)x)[i];}")
\end{verbatim}
<<*>>=
(clines "int mem_value(x ,i)object x;int i; { return ((short *)x)[i];}")

(defentry memory-value-short(object int) (int "mem_value"))

;(memory-value-short  (make-hash-table :test 'equal) 12) is 0,1,or 2
;depending on whether the test is eq,eql or equal.
(defun HASHTABLE-CLASS (table)
  (case (memory-value-short table 12)
	(0 'EQ)
	(1 'EQL)
	(2 'EQUAL)
	(t "error unknown hash table class")))

(define-function 'HCOUNT #'hash-table-count)

;17.4 Searching and Updating

(defun HPUT* (table alist)
  (mapc #'(lambda (pair) (hput table (car pair) (cdr pair))) alist))

(defmacro HREM (table key) `(remhash ,key ,table))

(defun HREMPROP (table key property)
  (let ((plist (gethash key table)))
    (if plist (setf (gethash key table)
                    (delete property plist :test #'equal :key #'car)))))

;17.5 Updating

(define-function 'HCLEAR #'clrhash)

;17.6 Miscellaneous

(define-function 'HASHTABLEP #'hash-table-p)

(define-function 'HASHEQ #'sxhash)

(define-function 'HASHUEQUAL #'sxhash)

(define-function 'HASHCVEC #'sxhash)

(define-function 'HASHID #'sxhash)

;;macros from file vmlisp are necessary to compile this file

(DEFUN |intersection|  (LIST-OF-ITEMS-1 LIST-OF-ITEMS-2)
    (PROG (I H V)
      (SETQ V (SETQ H (CONS NIL NIL)))
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-1))
          (SETQ LIST-OF-ITEMS-1 (LIST LIST-OF-ITEMS-1)) ) )
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-2))
          (SETQ LIST-OF-ITEMS-2 (LIST LIST-OF-ITEMS-2)) ) )
  LP  (COND
        ( (NOT (PAIRP LIST-OF-ITEMS-1))
          (RETURN (QCDR H)) )
        ( (|member|
            (SETQ I (QCAR (RESETQ LIST-OF-ITEMS-1 (QCDR LIST-OF-ITEMS-1))))
            (QCDR H)) )
        ( (|member| I LIST-OF-ITEMS-2)
          (QRPLACD V (SETQ V (CONS I NIL))) ) )
      (GO LP) ) )

(DEFUN INTERSECTIONQ (LIST-OF-ITEMS-1 LIST-OF-ITEMS-2)
    (PROG (I H V)
      (SETQ V (SETQ H (CONS NIL NIL)))
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-1))
          (SETQ LIST-OF-ITEMS-1 (LIST LIST-OF-ITEMS-1)) ) )
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-2))
          (SETQ LIST-OF-ITEMS-2 (LIST LIST-OF-ITEMS-2)) ) )
  LP  (COND
        ( (NOT (PAIRP LIST-OF-ITEMS-1))
          (RETURN (QCDR H)) )
        ( (QMEMQ
            (SETQ I (QCAR (RESETQ LIST-OF-ITEMS-1 (QCDR LIST-OF-ITEMS-1))))
            (QCDR H)) )
        ( (QMEMQ I LIST-OF-ITEMS-2)
          (QRPLACD V (SETQ V (CONS I NIL))) ) )
      (GO LP) ) )

(DEFUN |union| (LIST-OF-ITEMS-1 LIST-OF-ITEMS-2)
    (PROG (I H V)
      (SETQ H (SETQ V (CONS NIL NIL)))
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-1))
          (SETQ LIST-OF-ITEMS-1 (LIST LIST-OF-ITEMS-1)) ) )
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-2))
          (SETQ LIST-OF-ITEMS-2 (LIST LIST-OF-ITEMS-2)) ) )
  LP1 (COND
        ( (NOT (PAIRP LIST-OF-ITEMS-1))
          (COND
            ( (PAIRP LIST-OF-ITEMS-2)
              (SETQ LIST-OF-ITEMS-1 (RESETQ LIST-OF-ITEMS-2 NIL)) )
            ( 'T
              (RETURN (QCDR H)) ) ) )
        ( (NOT
            (|member|
              (SETQ I (QCAR (RESETQ LIST-OF-ITEMS-1 (QCDR LIST-OF-ITEMS-1))))
              (QCDR H)))
          (QRPLACD V (SETQ V (CONS I NIL))) ) )
      (GO LP1) ) )

(DEFUN UNIONQ (LIST-OF-ITEMS-1 LIST-OF-ITEMS-2)
    (PROG (I H V)
      (SETQ H (SETQ V (CONS NIL NIL)))
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-1))
          (SETQ LIST-OF-ITEMS-1 (LIST LIST-OF-ITEMS-1)) ) )
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-2))
          (SETQ LIST-OF-ITEMS-2 (LIST LIST-OF-ITEMS-2)) ) )
  LP1 (COND
        ( (NOT (PAIRP LIST-OF-ITEMS-1))
          (COND
            ( (PAIRP LIST-OF-ITEMS-2)
              (SETQ LIST-OF-ITEMS-1 (RESETQ LIST-OF-ITEMS-2 NIL)) )
            ( 'T
              (RETURN (QCDR H)) ) ) )
        ( (NOT
            (QMEMQ
              (SETQ I (QCAR (RESETQ LIST-OF-ITEMS-1 (QCDR LIST-OF-ITEMS-1))))
              (QCDR H)))
          (QRPLACD V (SETQ V (CONS I NIL))) ) )
      (GO LP1) ) )

(DEFUN SETDIFFERENCE (LIST-OF-ITEMS-1 LIST-OF-ITEMS-2)
    (PROG (I H V)
      (SETQ H (SETQ V (CONS NIL NIL)))
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-1))
          (SETQ LIST-OF-ITEMS-1 (LIST LIST-OF-ITEMS-1)) ) )
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-2))
          (SETQ LIST-OF-ITEMS-2 (LIST LIST-OF-ITEMS-2)) ) )
  LP1 (COND
        ( (NOT (PAIRP LIST-OF-ITEMS-1))
          (RETURN (QCDR H)) )
        ( (|member|
            (SETQ I (QCAR (RESETQ LIST-OF-ITEMS-1 (QCDR LIST-OF-ITEMS-1))))
            (QCDR H)) )
        ( (NOT (|member| I LIST-OF-ITEMS-2))
          (QRPLACD V (SETQ V (CONS I NIL))) ) )
      (GO LP1) ) )

(DEFUN SETDIFFERENCEQ (LIST-OF-ITEMS-1 LIST-OF-ITEMS-2)
    (PROG (I H V)
      (SETQ H (SETQ V (CONS NIL NIL)))
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-1))
          (SETQ LIST-OF-ITEMS-1 (LIST LIST-OF-ITEMS-1)) ) )
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-2))
          (SETQ LIST-OF-ITEMS-2 (LIST LIST-OF-ITEMS-2)) ) )
  LP1 (COND
        ( (NOT (PAIRP LIST-OF-ITEMS-1))
          (RETURN (QCDR H)) )
        ( (QMEMQ
            (SETQ I (QCAR (RESETQ LIST-OF-ITEMS-1 (QCDR LIST-OF-ITEMS-1))))
            (QCDR H)) )
        ( (NOT (QMEMQ I LIST-OF-ITEMS-2))
          (QRPLACD V (SETQ V (CONS I NIL))) ) )
      (GO LP1) ) )

(defvar *lisp-bin-filetype* "o")

(defvar *lisp-source-filetype* "lsp")

;; definition of our stream structure
(defstruct libstream  mode dirname (indextable nil)  (indexstream nil))
;indextable is a list of entries (key class <location or filename>)
;filename is of the form filenumber.lsp or filenumber.o

(defvar optionlist nil "alist which controls compiler output")

(defun addoptions (key value) "adds pairs to optionlist"
  (push (cons key value) optionlist)
  (if (equal key 'FILE)
      (push 
       (cons 'COMPILER-OUTPUT-STREAM
                   (open (concat (libstream-dirname value) "/" "code.lsp")
                         :direction :output :if-exists :supersede))
             optionlist)))

(defun directory? (filename) (|directoryp| filename))

;; (RDEFIOSTREAM ((MODE . IO) (FILE fn ft dir))) IO is I,O,INPUT,OUTPUT
(defun rdefiostream (options &optional (missing-file-error-flag t))
  (let ((mode (cdr (assoc 'mode options)))
	(file (assoc 'file options))
	(stream nil)
	(fullname nil)
	(indextable nil))
        (cond ((equal (elt (string mode) 0) #\I)
	       ;;(setq fullname (make-input-filename (cdr file) 'LISPLIB))
	       (setq fullname (make-input-filename (cdr file) 'NIL))
	       (setq stream (get-input-index-stream fullname))
               (if (null stream)
		   (if missing-file-error-flag
		       (ERROR (format nil "Library ~s doesn't exist"
			      ;;(make-filename (cdr file) 'LISPLIB))
			      (make-filename (cdr file) 'NIL)))
		     NIL)
               (make-libstream :mode 'input  :dirname fullname
                               :indextable (get-index-table-from-stream stream)
			       :indexstream stream)))
              ((equal (elt (string mode) 0) #\O)
	       ;;(setq fullname (make-full-namestring (cdr file) 'LISPLIB))
	       (setq fullname (make-full-namestring (cdr file) 'NIL))
	       (case (directory? fullname)
		     (-1 (makedir fullname))
		     (0 (error (format nil "~s is an existing file, not a library" fullname)))
		     (otherwise))
	       (multiple-value-setq (stream indextable) (get-io-index-stream fullname))
	       (make-libstream :mode 'output  :dirname fullname
			       :indextable indextable
			       :indexstream stream ))
              ('t  (ERROR "Unknown MODE")))))

(defvar *index-filename* "index.kaf")

;get the index table of the lisplib in dirname
(defun getindextable (dirname)
  (let ((index-file (concat dirname "/" *index-filename*)))
     (if (probe-file index-file)
         (with-open-file (stream index-file) (get-index-table-from-stream stream))
            ;; create empty index file to mark directory as lisplib
         (with-open-file (stream index-file :direction :output) nil))))

;get the index stream of the lisplib in dirname
(defun get-input-index-stream (dirname)
  (let ((index-file (concat dirname "/" *index-filename*)))
    (open index-file :direction :input :if-does-not-exist nil)))

(defun get-index-table-from-stream (stream)
  (let ((pos (read  stream)))
    (cond ((numberp pos)
	   (file-position stream pos)
	   (read stream))
	  (t pos))))

(defun get-io-index-stream (dirname)
  (let* ((index-file (concat dirname "/" *index-filename*))
	 (stream (open index-file :direction :io :if-exists :overwrite
		       :if-does-not-exist :create))
	 (indextable ())
	 (pos (read stream nil nil)))
    (cond ((numberp pos)
	   (file-position stream pos)
	   (setq indextable (read stream))
	   (file-position stream pos))
	  (t (file-position stream 0)
	     (princ "                    " stream)
	     (setq indextable pos)))
    (values stream indextable)))

;substitute indextable in dirname

(defun write-indextable (indextable stream)
  (let ((pos (file-position stream)))
    (write indextable :stream stream :level nil :length nil :escape t)
    (finish-output stream)
    (file-position stream 0)
    (princ pos stream)
    (finish-output stream)))

(defun putindextable (indextable dirname)
  (with-open-file
    (stream (concat dirname "/" *index-filename*)
             :direction :io :if-exists :overwrite
             :if-does-not-exist :create)
    (file-position stream :end)
    (write-indextable indextable stream)))

;makedir (fname) fname is a directory name.
(defun makedir (fname)
  (system (concat "mkdir " fname)))

;; (RREAD key rstream)
(defun rread (key rstream &optional (error-val nil error-val-p))
  (if (equal (libstream-mode rstream) 'output) (error "not input stream"))
  (let* ((entry
	 (and (stringp key)
	      (assoc key (libstream-indextable rstream) :test #'string=)))
	 (file-or-pos (and entry (caddr entry))))
    (cond ((null entry)
	   (if error-val-p error-val (error (format nil "key ~a not found" key))))
	  ((null (caddr entry)) (cdddr entry))  ;; for small items
	  ((numberp file-or-pos)
	   (file-position (libstream-indexstream rstream) file-or-pos)
	   (read (libstream-indexstream rstream)))
	  (t
	   (with-open-file
	    (stream (concat (libstream-dirname rstream) "/" file-or-pos))
	    (read  stream))) )))

(defvar *lib-var*)

;; (RKEYIDS filearg) -- interned version of keys
(defun rkeyids (&rest filearg)
  (mapcar #'intern (mapcar #'car (getindextable
				  (make-input-filename filearg 'NIL)))))
;;(defun rkeyids (&rest filearg)
;;  (mapcar #'intern (mapcar #'car (getindextable
;;				  (make-input-filename filearg 'LISPLIB)))))

;; (RWRITE cvec item rstream)
(defun rwrite (key item rstream)
  (if (equal (libstream-mode rstream) 'input) (error "not output stream"))
  (let ((stream (libstream-indexstream rstream))
	(pos (if item (cons (file-position (libstream-indexstream rstream)) nil)
	       (cons nil item))))   ;; for small items
    (make-entry (string key) rstream pos)
    (when (numberp (car pos))
	  (write item :stream stream :level nil :length nil
		 :circle t :array t :escape t)
	  (terpri stream))))

(defun make-entry (key rstream value-or-pos)
   (let ((entry (assoc key (libstream-indextable rstream) :test #'equal)))
     (if (null entry)
	 (push (setq entry (cons key (cons 0 value-or-pos)))
	       (libstream-indextable rstream))
       (progn
	 (if (stringp (caddr entry)) ($erase (caddr entry)))
	 (setf (cddr entry) value-or-pos)))
     entry))

;;(defun rshut (rstream)
;;  (when (and (equal rstream (cdr (assoc 'FILE OPTIONLIST)))
;;             (assoc 'compiler-output-stream optionlist))
;;        (close (cdr (assoc 'compiler-output-stream optionlist)))
;;        (setq optionlist nil))
;;  (if (eq (libstream-mode rstream) 'output)
;;      (write-indextable (libstream-indextable rstream) (libstream-indexstream rstream)))
;;  (close (libstream-indexstream rstream)))
(defun rshut (rstream)
  (when (and (equal rstream (cdr (assoc 'FILE OPTIONLIST)))
             (assoc 'compiler-output-stream optionlist))
        (close (cdr (assoc 'compiler-output-stream optionlist)))
        (setq optionlist (cddr optionlist)))
  (if (eq (libstream-mode rstream) 'output)
      (write-indextable (libstream-indextable rstream) (libstream-indexstream rstream)))
  (close (libstream-indexstream rstream)))

@
\section{GCL code.lsp name change}
When we compile an algebra file we create an nrlib directory which contains
several files. One of the files is named code.lsp. 
On certain platforms this causes linking problems for GCL. 
The problem is that the compiler produces an init code block which is
sensitive to the name of the source file.
Since all of the code.lsp files have the same name all of
the init blocks have the same name. At link time this causes
the names to collide. Here we rename the file before we compile,
do the compile, and then rename the result back to code.o.
<<*>>=
;; filespec is id or list of 1, 2 or 3 ids
;; filearg is filespec or 1, 2 or 3 ids
;; (RPACKFILE filearg)  -- compiles code files and converts to compressed format
(defun rpackfile (filespec)
  (setq filespec (make-filename filespec))
  (if (string= (pathname-type filespec) "nrlib")
  (let* ((base (pathname-name filespec))
             (code (concatenate 'string (namestring filespec) "/code.lsp"))
             (temp (concatenate 'string (namestring filespec) "/" base ".lsp"))
             (o (make-pathname :type "o")))
        (si::system (format nil "cp ~S ~S" code temp))
        (recompile-lib-file-if-necessary temp)
        (si::system (format nil "mv ~S ~S~%" 
           (namestring (merge-pathnames o temp))
           (namestring (merge-pathnames o code)))))
  ;; only pack non libraries to avoid lucid file handling problems    
    (let* ((rstream (rdefiostream (list (cons 'file filespec) (cons 'mode 'input))))
	   (nstream nil)
	   (nindextable nil)
	   (nrstream nil)
	   (index-file-name (concat (truename filespec) "/" *index-filename*))
	   (temp-index-file-name (make-pathname :name "oldindex"
						:defaults index-file-name)))
      (rename-file index-file-name temp-index-file-name ) ;; stays until closed
      (multiple-value-setq (nstream nindextable) (get-io-index-stream filespec))
      (setq nrstream (make-libstream :mode 'output  :dirname filespec
				     :indextable nindextable
				     :indexstream nstream ))
      (dolist (entry (libstream-indextable rstream))
	      (rwrite (car entry) (rread (car entry) rstream) nrstream)
	      (if (stringp (caddr entry))
		  (delete-file (concat filespec "/" (caddr entry)))))
      (close (libstream-indexstream rstream))
      (delete-file temp-index-file-name)
      (rshut nrstream)))
  filespec)

(defun recompile-lib-file-if-necessary (lfile)
   (let* ((bfile (make-pathname :type *lisp-bin-filetype* :defaults lfile))
          (bdate (and (probe-file bfile) (file-write-date bfile)))
          (ldate (and (probe-file lfile) (file-write-date lfile))))
     (if ldate
	 (if (and bdate (> bdate ldate)) nil
	   (progn (compile-lib-file lfile) (list bfile))))))

(defun spad-fixed-arg (fname )
   (and (equal (symbol-package fname) (find-package "BOOT"))
        (not (get fname 'compiler::spad-var-arg))
	(search ";" (symbol-name fname))
        (or (get fname 'compiler::fixed-args)
	    (setf (get fname 'compiler::fixed-args) t)))
   nil)

(defun compile-lib-file (fn &rest opts)
  (unwind-protect
      (progn
	(trace (compiler::fast-link-proclaimed-type-p
		:exitcond nil
		:entrycond (spad-fixed-arg (car system::arglist))))
	(trace (compiler::t1defun :exitcond nil
		:entrycond (spad-fixed-arg (caar system::arglist))))
	(apply #'compile-file fn opts))
    (untrace compiler::fast-link-proclaimed-type-p compiler::t1defun)))

;; (RDROPITEMS filearg keys) don't delete, used in files.spad
(defun rdropitems (filearg keys &aux (ctable (getindextable filearg)))
  (mapc #'(lambda(x)
           (setq ctable (delete x ctable :key #'car :test #'equal)) )
           (mapcar #'string keys))
  (putindextable ctable filearg))

;; cms file operations
(defun make-filename (filearg &optional (filetype nil))
  (let ((filetype (if (symbolp filetype) 
		      (symbol-name filetype)
		      filetype)))
    (cond
     ((pathnamep filearg) 
      (cond ((pathname-type filearg) (namestring filearg))
	    (t (namestring (make-pathname :directory (pathname-directory filearg)
					  :name (pathname-name filearg)
					  :type filetype)))))
     ;; Previously, given a filename containing "." and
     ;; an extension this function would return filearg. MCD 23-8-95.
     ((and (stringp filearg) (pathname-type filearg) (null filetype)) filearg)
     ;;  ((and (stringp filearg)
     ;;    (or (pathname-type filearg) (null filetype)))
     ;;     filearg)
     ((and (stringp filearg) (stringp filetype)
	   (pathname-type filearg) 
	   (string-equal (pathname-type filearg) filetype))
      filearg)
     ((consp filearg)
      (make-filename (car filearg) (or (cadr filearg) filetype)))
     (t (if (stringp filetype) (setq filetype (intern filetype "BOOT")))
	(let ((ft (or (cdr (assoc filetype $filetype-table)) filetype)))
	  (if ft 
	      (concatenate 'string (string filearg) "." (string ft))
	      (string filearg)))))))

(defun make-full-namestring (filearg &optional (filetype nil))
  (namestring (merge-pathnames (make-filename filearg filetype))))

(defun probe-name (file)
  (if (probe-file file) (namestring file) nil))

(defun get-directory-list (ft &aux (cd (namestring $current-directory)))
  (declare (special $current-directory))
  (cond ((member ft '("nrlib" "daase" "exposed") :test #'string=)
	   (if (eq BOOT::|$UserLevel| 'BOOT::|development|)
	       (cons cd $library-directory-list)
	       $library-directory-list))
	(t (adjoin cd 
              (adjoin (namestring (user-homedir-pathname)) $directory-list 
                      :test #'string=) 
              :test #'string=))))

(defun make-input-filename (filearg &optional (filetype nil))
   (let*
     ((filename  (make-filename filearg filetype))
      (dirname (pathname-directory filename))
      (ft (pathname-type filename))
      (dirs (get-directory-list ft))
      (newfn nil))   
    (if (or (null dirname) (eqcar dirname :relative))
	(dolist (dir dirs (probe-name filename))
		(when 
		 (probe-file 
		  (setq newfn (concatenate 'string dir filename)))
		 (return newfn)))
      (probe-name filename))))

(defun $FILEP (&rest filearg) (make-full-namestring filearg))
(define-function '$OUTFILEP #'$FILEP) ;;temporary bogus def

(defun $findfile (filespec filetypelist)
  (let ((file-name (if (consp filespec) (car filespec) filespec))
	(file-type (if (consp filespec) (cadr filespec) nil)))
    (if file-type (push file-type filetypelist))
    (some #'(lambda (ft) (make-input-filename file-name ft))
	  filetypelist)))

;; ($ERASE filearg) -> 0 if succeeds else 1
(defun $erase (&rest filearg)
  (system (concat "rm -rf "(make-full-namestring filearg))))

(defun $REPLACE (filespec1 filespec2)
    ($erase (setq filespec1 (make-full-namestring filespec1)))
    (rename-file (make-full-namestring filespec2) filespec1))



;;(defun move-file (namestring1 namestring2)
;;  (rename-file namestring1 namestring2))

(defun $FCOPY (filespec1 filespec2)
    (let ((name1 (make-full-namestring filespec1))
	  (name2 (make-full-namestring filespec2)))
      (if (library-file name1)
	(copy-lib-directory name1 name2)
	(copy-file name1 name2))))


(defun copy-lib-directory (name1 name2)
   (makedir name2)
   (system (concat "sh -c 'cp " name1 "/* " name2 "'")))

(defun copy-file (namestring1 namestring2)
  (system (concat "cp " namestring1 " " namestring2)))


(defvar vmlisp::$filetype-table
  '((BOOT::LISPLIB . |LILIB|)
    (BOOT::SPADLIB . |slib|)
    (BOOT::HISTORY . |hist|)
    (BOOT::HELPSPAD . |help|)
    (BOOT::INPUT . |input|)
    (BOOT::SPAD . |spad|)
    (BOOT::BOOT . |boot|)
    (BOOT::LISP . |lsp|)
    (BOOT::META . |meta|)
    (BOOT::OUTPUT . |splog|)
    (BOOT::ERRORLIB . |erlib|)
    (BOOT::DATABASE . |daase|)
    (BOOT::SPADDATA . |sdata|)
    (BOOT::SPADFORT . |sfort|)
    (BOOT::SPADFORM . |sform|)
    (BOOT::SPADTEX . |stex|)
    (BOOT::SPADOUT . |spout|)))

(in-package 'boot)

;;--------------------> NEW DEFINITION (see unlisp.lisp.pamphlet)
(defun |AlistAssocQ| (key l)
  (assoc key l :test #'eq) )

;;--------------------> NEW DEFINITION (see unlisp.lisp.pamphlet)
(defun |ListMember?| (ob l)
  (member ob l :test #'equal) )

; rewrite nnPP for csl, which does not support flet
(defvar *npPParg* nil "rewrite flets, using global scoping")
(defun npPPff () (and (funcall *npPParg*) (|npPush| (list (|npPop1|)))))
(defun npPPf () (|npSemiListing| (function npPPff)))
(defun npPPg () 
 (and (|npListAndRecover| (function npPPf)))
 (|npPush| (|pfAppend| (|npPop1|))))
(defun |npPP| (|f|)
 (declare (special *npPParg*))
  (setq *npPParg* |f|)
  (or (|npParened| (function npPPf))
    (and  (|npPileBracketed| (function npPPg))
          (|npPush| (|pfEnSequence| (|npPop1|))))
       (funcall |f|)))

(defvar *npPCff* nil "rewrite flets, using global scoping")
(defun npPCff () (and (funcall *npPCff*) (|npPush| (list (|npPop1|)))))
(defun npPCg () 
 (and (|npListAndRecover| (function npPCff)))
 (|npPush| (|pfAppend| (|npPop1|))))
(defun |npPC| (|f|)
  (or
    (and (|npPileBracketed| (function npPCg))
         (|npPush| (|pfEnSequence| (|npPop1|))))
    (funcall |f|)))

(defun |stringLE1| (x y)
  (string<= x y :start1 1 :start2 2))

(defun |sortCarString| (lines)
  (sort lines #'string<= :key #'car))

(defun |insertString| (s1 s2 i1)
   (replace s2 s1 :start1 i1 :end1 (1+ i1) :end2 (size s1))) 

; NAME:	   Boot Package
; PURPOSE: Provide forward references to Boot Code for functions to be at
;	   defined at the boot level, but which must be accessible
;	   not defined at lower levels.

(in-package "BOOT")
(use-package '("LISP" "VMLISP"))

(defmacro def-boot-fun (f args where)
  `(compiler-let nil
     (defun ,f ,args ,where (print (list ',f . ,args)))
     (export '(,f) "BOOT")))

(defmacro def-boot-var (p where)
  `(compiler-let nil
     (defparameter ,p nil ,where)
     (export '(,p) "BOOT")))

(defmacro def-boot-val (p val where)
  `(compiler-let nil
     (defparameter ,p ,val ,where)
     (export '(,p) "BOOT")))

(def-boot-fun |updateSourceFiles| (x) "temp def")
(def-boot-val |$timerTicksPerSecond| INTERNAL-TIME-UNITS-PER-SECOND
    "for TEMPUS-FUGIT and $TOTAL-ELAPSED-TIME")
(def-boot-val $boxString
  (concatenate 'string (list (code-char #x1d) (code-char #xe2)))
  "this string of 2 chars displays as a box")
(def-boot-val |$quadSymbol| $boxString "displays an APL quad")
(def-boot-val |$quadSym| '|$quadSym| "unbound symbol referenced in format.boot")
(def-boot-val $escapeString  (string (code-char 27))
   "string for single escape character")
(def-boot-val $boldString (concatenate 'string $escapeString "[12m")
  "switch into bold font")
(def-boot-val $normalString (concatenate 'string $escapeString "[0;10m")
  "switch back into normal font")
(def-boot-val $reverseVideoString (concatenate 'string $escapeString "[7m")
  "switch into reverse video")
(def-boot-val $underlineString (concatenate 'string $escapeString "[4m")
  "switch into underline mode")
(def-boot-val $COMPILE t  "checked in COMP-2 to skip compilation")
(def-boot-var |$abbreviationTable|		    "???")
(def-boot-val |$algebraList|
	'(|QuotientField| |Polynomial|
	  |UnivariatePoly|
	  |MultivariatePolynomial|
	  |DistributedMultivariatePolynomial|
	  |HomogeneousDistributedMultivariatePolynomial|
	  |Gaussian| |SquareMatrix|
	  |RectangularMatrix|)			"???")
(def-boot-val |$BasicDomains|
	  '(|Integer| |Float| |Symbol|
	    |Boolean| |String|)			"???")
(def-boot-val |$BasicPredicates|
	  '(FIXP STRINGP FLOATP)		"???")
(def-boot-val |$BFtag| '-BF-	   "big float marker")
(def-boot-val |$BigFloat| '(|Float|)		    "???")
(def-boot-val |$BigFloatOpt| '(|BigFloat| . OPT)    "???")
(def-boot-val |$Boolean| '(|Boolean|)		    "???")
(def-boot-val |$BooleanOpt| '(|Boolean| . OPT)	    "???")
(def-boot-val |$bootStrapMode| ()  "if T compCapsule skips body")
(def-boot-fun |bootUnionPrint| (x s tt)		    "Interpreter>Coerce.boot")
(def-boot-fun |break| (msg)			    "Interpreter>Trace.boot")
(def-boot-fun |breaklet| (fn vars)		    "Interpreter>Trace.boot")
(def-boot-var |$brightenCommentsFlag|		    "???")
(def-boot-var |$brightenCommentsIfTrue|		    "???")
(def-boot-val |$BreakMode| '|query|		    "error.boot")
(def-boot-var |$cacheAlist|			    "Interpreter>System.boot")
(def-boot-val |$cacheCount| 0			    "???")
(def-boot-val |$Category| '(|Category|)		    "???")
;  modemap:==  ( <map> (p e) (p e) ... (p e) )
;  modemaplist:= ( modemap ... )

(def-boot-val |$CategoryFrame|
	  '((((|Category| . ((|modemap| (((|Category|) (|Category|)) (T *)))))
	      (|Join| . ((|modemap|
      (((|Category|) (|Category|) (|Category|) (|Category|)) (T *))
      (((|Category|) (|Category|) (|List| |Category|)) (|Category|)) (T *))
	)))))
	"Compiler>CUtil.boot")
(def-boot-val |$CategoryNames|
	'(|Category| |CATEGORY| |RecordCategory| |Join|
	  |StringCategory| |SubsetCategory| |UnionCategory|)
	"???")
(def-boot-val |$clamList|
	  '((|getModemapsFromDatabase| |hash| UEQUAL |count|)
	    (|getOperationAlistFromLisplib| |hash| UEQUAL |count|)
	    (|getFileProperty| |hash| UEQUAL |count|)
	    (|canCoerceFrom| |hash| UEQUAL |count|)
	    (|selectMms1| |hash| UEQUAL |count|)
	    (|coerceMmSelection| |hash| UEQUAL |count|)
	    (|isValidType| |hash| UEQUAL |count|))
						"Interpreter>Clammed.boot")
(def-boot-val |$CommonDomains|
	 '(|Record| |Union| |List| |Vector|
	   |String| |Float| |Integer|
	   |NonNegativeInteger| |Expression|
	   |NonPositiveInteger|
	   |PositiveInteger| |SmallInteger|
	   |Boolean|) "???")

(def-boot-var |$compCount|			    "???")
(def-boot-var |$compileMapFlag|			    "Interpreter>SetVars.boot")
(def-boot-var |$compUniquelyIfTrue|		    "Compiler>Compiler.boot")
(def-boot-val |$consistencyCheck| nil		    "Interpreter>Consis.boot")
(def-boot-val |$ConstructorCache| (MAKE-HASHTABLE 'ID)	"???")
(def-boot-var |$constructorsNotInDatabase|	    "Interpreter>Database.boot")
(def-boot-var |$createUpdateFiles|		    "Interpreter>SetVarT.boot")
(def-boot-var |$croakIfTrue|			    "See moan in U.")
(def-boot-var |$currentFunction|		    "???")
(def-boot-val |$currentLine|	""          "current input line for history")
(def-boot-val $delay 0				    "???")
(def-boot-var $Directory			    "???")
(def-boot-var $DISPLAY				    "???")
(def-boot-val |$Domain| '(|Domain|)		    "???")
(def-boot-var |$DomainFrame|			    "???")
(def-boot-val |$DomainNames|
	'(|Integer| |Float| |Symbol| |Boolean|
	  |String| |Expression|
	  |Mapping| |SubDomain| |List| |Union|
	  |Record| |Vector|)			"???")
(def-boot-val |$DomainsInScope| '(NIL)		    "???")
(def-boot-val |$domainTraceNameAssoc| ()    "association list of trace domains")
(def-boot-val |$DomainVariableList|
  '($1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11
       $12 $13 $14 $15)				"???")
(def-boot-val |$DoubleQuote| "\""                   "???")
(def-boot-val |$DummyFunctorNames|
	  '(|Boolean| |Mapping|)		"???")
(def-boot-var |$eltIfNil|			    "SpecialFunctions>PSpad.boot")
(def-boot-val |$EmptyEnvironment| '((NIL))	    "???")
(def-boot-val |$EmptyList| ()			    "???")
@
\verb|$EmptyMode| is a contant whose value is \verb|$EmptyMode|.
It is used by isPartialMode (in i-funsel.boot) to
decide if a modemap is partially constructed. If the \verb|$EmptyMode|
constant occurs anywhere in the modemap structure at any depth
then the modemap is still incomplete. To find this constant the
isPartialMode function calls CONTAINED \verb|$EmptyMode| Y
which will walk the structure $Y$ looking for this constant.
<<*>>=
(def-boot-val |$EmptyMode| '|$EmptyMode|    "compiler constant")
(def-boot-val |$EM| |$EmptyMode|		    "???")
(def-boot-val |$EmptyString| ""                     "???")
(def-boot-val |$EmptyVector| '#()		     "???")
(def-boot-val |$Expression| '(|Expression|)	    "???")
(def-boot-val |$ExpressionOpt|
	  '(|Expression| . OPT)			"???")
(def-boot-var |$evalDomain|			    "???")
(def-boot-val |$Exit| '(Exit)	      "compiler constant")
(def-boot-var |$exitMode|			    "???")
(def-boot-var |$exitModeStack|			    "???")
(def-boot-val |$failure| (GENSYM)	    "Symbol denoting a failed operation.")
(def-boot-val |$false| NIL			    "???")
(def-boot-val |$Float| '(|Float|)		    "???")
(def-boot-val |$FloatOpt| '(|Float| . OPT)	    "???")
(def-boot-val |$FontTable| '(|FontTable|)	    "???")
(def-boot-var |$forceDatabaseUpdate|		    "See load function.")
(def-boot-var |$form|				    "???")
(def-boot-val |$FormalMapVariableList|
  '(\#1 \#2 \#3 \#4 \#5 \#6 \#7 \#8 \#9
    \#10 \#11 \#12 \#13 \#14 \#15)		"???")
(def-boot-val |$FormalMapVariableList2|
  '(\#\#1 \#\#2 \#\#3 \#\#4 \#\#5 \#\#6 \#\#7 \#\#8 \#\#9
    \#\#10 \#\#11 \#\#12 \#\#13 \#\#14 \#\#15)		    "???")
(def-boot-var |$fromSpadTrace|			    "Interpreter>Trace.boot")
(def-boot-var $function				    "Interpreter>System.boot")
(def-boot-var $FunName				    "???")
(def-boot-var $FunName_Tail			    "???")
(def-boot-val |$ConstructorNames|
	'(|SubDomain| |List| |Union| |Record| |Vector|)
	"Used in isFunctor test, and compDefine.")
(def-boot-val |$gauss01| '(|gauss| 0 1)		    "???")
(def-boot-var |$genFVar|			    "???")
(def-boot-val |$genSDVar| 0	    "counter for genSomeVariable" )
(def-boot-val |$hasCategoryTable| (MAKE-HASHTABLE 'UEQUAL) "???")
(def-boot-var |$hasYield|			    "???")
(def-boot-var |$ignoreCommentsIfTrue|		    "???")
(def-boot-var |$Index|				    "???")
(def-boot-val |$InitialDomainsInScope|
	  '((|Boolean|) |$EmptyMode| |$NoValueMode|)
	  "???")
(def-boot-val |$InitialModemapFrame| '((NIL))	    "???")
(def-boot-var |$inLispVM|			    "Interpreter>Eval.boot")
(def-boot-var |$insideCapsuleFunctionIfTrue|	    "???")
(def-boot-var |$insideCategoryIfTrue|		    "???")
(def-boot-var |$insideCoerceInteractiveHardIfTrue|  "???")
(def-boot-val |$insideCompTypeOf| NIL  "checked in comp3")
(def-boot-val |$insideConstructIfTrue| NIL "checked in parse.boot")
(def-boot-var |$insideExpressionIfTrue|		    "???")
(def-boot-var |$insideFunctorIfTrue|		    "???")
(def-boot-var |$insideWhereIfTrue|		    "???")
(def-boot-val |$instantRecord| (MAKE-HASHTABLE 'ID) "???")
(def-boot-val |$Integer| '(|Integer|)		    "???")
(def-boot-val |$IntegerOpt| '(|Integer| . OPT)	    "???")
(def-boot-val |$InteractiveFrame| '((NIL))	    "top level environment")
(def-boot-var |$InteractiveMode|		    "Interactive>System.boot")
(def-boot-val |$InteractiveModemapFrame| '((NIL))   "???")
(def-boot-var |$InteractiveTimingStatsIfTrue|	    "???")
(def-boot-var |$LastCxArg|			    "???")
(def-boot-val $lastprefix "S-"                      "???")
(def-boot-val |$lastUntraced| NIL      "Used for )restore option of )trace.")
(def-boot-var |$leaveLevelStack|		    "???")
(def-boot-var |$leaveMode|			    "???")
(def-boot-val |$leftPren| "("                       "For use in SAY expressions.")
(def-boot-val |$letAssoc| NIL	    "Used for trace of assignments in SPAD code.")
(def-boot-var |$libFile|			    "Compiler>LispLib.boot")
(def-boot-var $LINENUMBER			    "???")
(def-boot-var $linestack			    "???")
(def-boot-val |$Lisp| '(|Lisp|)			    "???")
(def-boot-val $LISPLIB nil		    "whether to produce a lisplib or not")
(def-boot-var |$lisplibDependentCategories|	    "Compiler>LispLib.boot")
(def-boot-var |$lisplibDomainDependents|	    "Compiler>LispLib.boot")
(def-boot-var |$lisplibForm|			    "Compiler>LispLib.boot")
(def-boot-var |$lisplibKind|			    "Compiler>LispLib.boot")
(def-boot-var |$lisplibModemapAlist|		    "Compiler>LispLib.boot")
(def-boot-var |$lisplibModemap|			    "Compiler>LispLib.boot")
(def-boot-var |$lisplibOperationAlist|		    "Compiler>LispLib.boot")
(def-boot-var |$lisplibSignatureAlist|		    "Compiler>LispLib.boot")
(def-boot-var |$lisplibVariableAlist|		    "Compiler>LispLib.boot")
(def-boot-var |$lisp2lispRenameAssoc|		    "???")
(def-boot-val |$LocalFrame| '((NIL))		    "???")
(def-boot-var |$mapSubNameAlist|		    "Interpreter>Trace.boot")
(def-boot-var |$mathTrace|			    "Interpreter>Trace.boot")
(def-boot-var |$mathTraceList|		    "Controls mathprint output for )trace.")
(def-boot-var $maxlinenumber			    "???")
(def-boot-val |$Mode| '(Mode)	   "compiler constant")
(def-boot-var |$ModemapFrame|			    "???")
(def-boot-val |$ModeVariableList|
  '(&1 &2 &3 &4 &5 &6 &7 &8 &9 &10 &11
       &12 &13 &14 &15)				"???")
(def-boot-var |$mostRecentOpAlist|		    "???")
(def-boot-var $NBOOT				    "???")
(def-boot-val |$NegativeIntegerOpt| '(|NegativeInteger| . OPT) "???")
(def-boot-val |$NegativeInteger| '(|NegativeInteger|) "???")
(def-boot-val |$NETail| (CONS |$EmptyEnvironment| NIL) "???")
(def-boot-var $NEWLINSTACK			    "???")
(def-boot-var |$noEnv|				    "???")
(def-boot-val |$NonMentionableDomainNames| '($ |Rep| |Mapping|) "???")
(def-boot-val |$NonNegativeIntegerOpt| '(|NonNegativeInteger| . OPT) "???")
(def-boot-val |$NonNegativeInteger| '(|NonNegativeInteger|) "???")
(def-boot-val |$NonPositiveIntegerOpt| '(|NonPositiveInteger| . OPT) "???")
(def-boot-val |$NonPositiveInteger| '(|NonPositiveInteger|) "???")
(def-boot-var |$noParseCommands|		    "???")
(def-boot-val |$NoValueMode| '|$NoValueMode|   "compiler literal")
(def-boot-val |$NoValue| '|$NoValue|   "compiler literal")
(def-boot-val $num_of_meta_errors 0		    "Number of errors seen so far")
(def-boot-var $OLDLINE				    "Used to output command lines.")
(def-boot-val |$oldTime| 0			    "???")
(def-boot-val |$One| '(|One|)			    "???")
(def-boot-val |$OneCoef| '(1 1 . 1)		    "???")
(def-boot-val |$operationNameList| NIL		 "op names for apropos")
(def-boot-var |$opFilter|			    "Used to /s a function")
(def-boot-var |OptionList|			    "???")
(def-boot-val |$optionAlist| nil       "info for trace boot")
(def-boot-var |$OutsideStringIfTrue|		    "???")
(def-boot-val |$PatternVariableList|
  '(*1 *2 *3 *4 *5 *6 *7 *8 *9 *10 *11
       *12 *13 *14 *15)				"???")
(def-boot-var |$PolyMode|			    "???")
(def-boot-val |$Polvar| '(WRAPPED . ((1 . 1)))	    "???")
(def-boot-var |$polyDefaultAssoc|		    "???")
(def-boot-val |$PolyDomains|
	'(|Polynomial| |MultivariatePolynomial|
	  |UnivariatePoly|
	  |DistributedMultivariatePolynomial|
	  |HomogeneousDistributedMultivariatePolynomial|)
	"???")
(def-boot-val |$PositiveIntegerOpt| '(|PositiveInteger| . OPT) "???")
(def-boot-val |$PositiveInteger| '(|PositiveInteger|) "???")
(def-boot-var |$postStack|			    "???")
(def-boot-var |$prefix|				    "???")
(def-boot-val |$PrettyPrint| nil "if t generated code is prettyprinted")
(def-boot-var |$previousTime|			    "???")
(def-boot-val |$PrimitiveDomainNames| nil
"Used in mkCategory to avoid generating vector slot
for primitive domains.	Also used by putInLocalDomainReferences and optCal.")
(def-boot-val |$optimizableDomainNames|
      '(|FactoredForm| |List| |Vector|
	|Integer| |NonNegativeInteger| |PositiveInteger|
	|SmallInteger| |String| |Boolean| |Symbol| |BooleanFunctions|)
   "used in optCall to decide which domains can be optimized")
(def-boot-val |$PrintBox| '(|PrintBox|)		    "???")
(def-boot-var |$PrintCompilerMessagesIfTrue|	    "???")
(def-boot-val |$printConStats| nil  "display constructor cache totals")
(def-boot-val |$printLoadMsgs|	't	    "Interpreter>SetVarT.boot")
(def-boot-var |$PrintOnly|			    "Compiler>LispLib.boot")
(def-boot-val |$UserSynonyms| ()    "list of user defined synonyms")
(def-boot-val |$SystemSynonyms| () "list of system defined synonyms")
(def-boot-val |$QuickCode| NIL	    "Controls generation of QREFELT, etc.")
(def-boot-val |$QuickLet| NIL	    "Set to T for no LET tracing.")
(def-boot-var |$QuietIfNil|			    "???")
(def-boot-val |$RationalNumberOpt| '(|RationalNumber| . OPT) "???")
(def-boot-val |$RationalNumber| '(|RationalNumber|) "???")
(def-boot-var |$readingFile|			    "???")
(def-boot-val |$report3| nil	 "addMap report info")
(def-boot-var |$reportBottomUpFlag|		    "Interpreter>SetVarT.boot")
(def-boot-var |$reportCoerce|			    "???")
(def-boot-var |$reportCoerceIfTrue|		    "???")
(def-boot-var |$reportCompilation|		    "???")
(def-boot-var |$reportExitModeStack|		    "???")
(def-boot-var |$reportFlag|			    "Interpreter>SetVars.boot")
(def-boot-val |$reportSpadTrace| ()    "report list of traced functions")
(def-boot-var |$resolveFlag|			    "Interpreter>SetVars.boot")
(def-boot-var |$returnMode|			    "???")
(def-boot-val |$rightPren| ")"                      "???")
(def-boot-var |$scanModeFlag|			    "???")
(def-boot-var |$semanticErrorStack|		    "???")
(def-boot-val |$SetFunctions| nil  "checked in SetFunctionSlots")
(def-boot-val |$SideEffectFreeFunctionList|
  '(|null| |case| |Zero| |One| \: \:\: |has| |Mapping|
    |elt| = \> \>= \< \<= MEMBER |is| |isnt| ATOM
    $= $\> $\>= $\< $\<= $^= $MEMBER)		"???")
(def-boot-var |$slamFlag|			    "Interpreter>SetVars.boot")
(def-boot-val |$SmallInteger| '(|SmallInteger|)	    "???")
(def-boot-val |$SmallIntegerOpt| '(|SmallInteger| . OPT) "???")
(def-boot-val |$sourceFileTypes|
	  '(SPAD BOOT LISP LISP370 META)
	  "Interpreter>System.boot")
(def-boot-val $SPAD nil				    "Is this Spad code?")
(def-boot-var $SPAD_ERRORS			    "???")
(def-boot-val |$spadLibFT| 'LISPLIB		    "???")
(def-boot-var |$spadOpList|			    "???")
(def-boot-var |$spadSystemDisks|		    "Interpreter>Database.boot")
(def-boot-val |$SpecialDomainNames|
  '(|add| |CAPSULE| |SubDomain| |List| |Union| |Record| |Vector|)
  "Used in isDomainForm, addEmptyCapsuleIfnecessary.")
(def-boot-var |$streamAlist|			    "???")
(def-boot-val |$streamCount| 0			    "???")
(def-boot-var |$streamIndexing|			    "???")
(def-boot-val |$StreamIndex| 0			    "???")
(def-boot-val |$StringCategory| '(|StringCategory|) "???")
(def-boot-val |$StringOpt| '(|String| . OPT)	    "???")
(def-boot-val |$String| '(|String|)		    "???")
(def-boot-var |$suffix|				    "???")
(def-boot-val |$Symbol| '(|Symbol|)		    "???")
(def-boot-val |$SymbolOpt| '(|Symbol| . OPT)	    "???")
(def-boot-val |$systemCreation| (currenttime)	    "???")
(def-boot-val |$systemLastChanged|
	  |$systemCreation|			"???")
(def-boot-val |$tempCategoryTable| (MAKE-HASHTABLE 'UEQUAL) "???")
(def-boot-val |$ThrowAwayMode| '|$ThrowAwayMode|    "interp constant")
(def-boot-val |$timerOn| t			    "???")
(def-boot-var |$topOp|				   "See displayPreCompilationErrors")
(def-boot-var |$tokenCommands|			    "???")
(def-boot-var $TOKSTACK				    "???")
(def-boot-val $TOP_LEVEL t			    "???")
(def-boot-var $top_stack			    "???")
(def-boot-var |$tracedModemap|			    "Interpreter>Trace.boot")
(def-boot-val |$traceDomains| t			     "enables domain tracing")
(def-boot-val |$TraceFlag| t			    "???")
(def-boot-var |$tracedSpadModemap|		    "Interpreter>Trace.boot")
(def-boot-var |$traceletFunctions|		    "???")
(def-boot-var |$traceNoisely|			    "Interpreter>Trace.boot")
(def-boot-var |$TranslateOnly|			    "???")
(def-boot-var |$tripleCache|			    "Compiler>Compiler.boot")
(def-boot-val |$true| ''T			    "???")
(def-boot-var $Type				    "???")
(def-boot-val |$underDomainAlist|
	'((|DistributedMultivariatePolynomial| . 2)
	  (|FactoredForm| . 1)
	  (|FactoredRing| . 1)
	  (|Gaussian| . 1)
	  (|List| . 1)
	  (|Matrix| . 1)
	  (|MultivariatePolynomial| . 2)
	  (|HomogeneousDistributedMultivariatePolynomial| . 2)
	  (|Polynomial| . 1)
	  (|QuotientField| . 1)
	  (|RectangularMatrix| . 3)
	  (|SquareMatrix| . 2)
	  (|UnivariatePoly| . 2)
	  (|Vector| . 1)
	  (|VVectorSpace| . 2))			"???")

(def-boot-val |$updateCatTableIfTrue| T	   "update category table on load")
(def-boot-var |$updateIfTrue|
	  "Should SPAD databases be updated&squeezed?")
(def-boot-val |$useBFasDefault| T
	  "Determines whether to use BF as default floating point type.")
(def-boot-val |$useDCQnotLET| () "checked in DEF-LET for use of DCQ")
(def-boot-fun BUMPCOMPERRORCOUNT ()		    "errorSupervisor1")
(def-boot-var |$VariableCount|			    "???")
(def-boot-val |$Void| '(|Void|) "compiler constant")
(def-boot-var |$warningStack|			    "???")
(def-boot-val |$whereList| () "referenced in format boot formDecl2String")
(def-boot-var |$xCount|				    "???")
(def-boot-var |$xeditIsConsole|			    "???")
(def-boot-var |$xyCurrent|			    "???")
(def-boot-var |$xyInitial|			    "???")
(def-boot-var |$xyMax|				    "???")
(def-boot-var |$xyMin|				    "???")
(def-boot-var |$xyStack|			    "???")
(def-boot-val |$Zero| '(|Zero|)			    "???")

(def-boot-val |$domainsWithUnderDomains|
	  (mapcar #'car |$underDomainAlist|)	"???")
(def-boot-val |$inputPromptType| '|step|  "checked in MKPROMPT")
(def-boot-val |$IOindex| 0		   "step counter")

(defvar |$compilingMap| ())
(defvar |$definingMap| nil)
 
(defmacro KAR (ARG) `(ifcar ,arg))
(defmacro KDR (ARG) `(ifcdr ,arg))
(defmacro KADR (ARG) `(ifcar (ifcdr ,arg)))
(defmacro KADDR (ARG) `(ifcar (ifcdr (ifcdr ,arg))))

; 5 PROGRAM STRUCTURE
 
; 5.3 Top-Level Forms
 
(defun SETANDFILE (x y) (LAM\,EVALANDFILEACTQ `(setq ,x ',y)))
 
; 5.3.2 Declaring Global Variables and Named Constants
 
(defmacro |function| (name) `(FUNCTION ,name))
(defmacro |dispatchFunction| (name) `(FUNCTION ,name))
 
(defun |macrop| (fn) (and (identp fn) (macro-function fn)))
 
; 6 PREDICATES
 
; 6.2 Data Type Predicates
 
; 6.3 Equality Predicates
 
;; qeqcar should be used when you know the first arg is a pair
;; the second arg should either be a literal fixnum or a symbol
;; the car of the first arg is always of the same type as the second
;; use eql unless we are sure fixnums are represented canonically
 
(defmacro qeqcar (x y)
  (if (integerp y) `(eql (the fixnum (qcar ,x)) (the fixnum ,y))
      `(eq (qcar ,x) ,y)))
 
(defun COMPARE (X Y)
  "True if X is an atom or X and Y are lists and X and Y are equal up to X."
  (COND ((ATOM X) T)
        ((ATOM Y) NIL)
        ((EQUAL (CAR X) (CAR Y)) (COMPARE (CDR X) (CDR Y)))))
 
 
(DEFUN ?ORDER (U V)  "Multiple-type ordering relation."
  (COND ((NULL U))
        ((NULL V) NIL)
        ((ATOM U)
         (if (ATOM V)
             (COND ((NUMBERP U) (if (NUMBERP V) (> V U) T))
                   ((NUMBERP V) NIL)
                   ((IDENTP U) (AND (IDENTP V) (string> (SYMBOL-NAME V) (SYMBOL-NAME U))))
                   ((IDENTP V) NIL)
                   ((STRINGP U) (AND (STRINGP V) (string> V U)))
                   ((STRINGP V) NIL)
                   ((AND (VECP U) (VECP V))
                    (AND (> (SIZE V) (SIZE U))
                         (DO ((I 0 (1+ I)))
                             ((GT I (MAXINDEX U)) 'T)
                           (COND ((NOT (EQUAL (ELT U I) (ELT V I)))
                                  (RETURN (?ORDER (ELT U I) (ELT V I))))))))
                   ((croak "Do not understand")))
               T))
        ((ATOM V) NIL)
        ((EQUAL U V))
        ((NOT (string> (write-to-string U) (write-to-string V))))))
 
(defmacro boot-equal (a b)
   (cond ((ident-char-lit a)
           `(or (eql ,a ,b) (eql (character ,a) ,b)))
	 ((ident-char-lit b)
           `(or (eql ,a ,b) (eql ,a (character ,b))))
	 (t `(eqqual ,a ,b))))
 
(defun ident-char-lit (x)
   (and (eqcar x 'quote) (identp (cadr x)) (= (length (pname (cadr x))) 1)))
 
(defmacro EQQUAL (a b)
  (cond ((OR (EQUABLE a) (EQUABLE b)) `(eq ,a ,b))
	((OR (numberp a) (numberp b)) `(eql ,a ,b))
	(t  `(equal ,a ,b))))
 
(defmacro NEQUAL (a b) `(not (BOOT-EQUAL ,a ,b)))
 
(defun EQUABLE (X)
  (OR (NULL X) (AND (EQCAR X 'QUOTE) (symbolp (CADR X)))))
 
; 7 CONTROL STRUCTURE
 
; 7.1 Constants and Variables
 
; 7.1.1 Reference
 
(DEFUN MKQ (X)
  "Evaluates an object and returns it with QUOTE wrapped around it."
  (if (NUMBERP X) X (LIST 'QUOTE X)))
 
; 7.2 Generalized Variables
 
(defmacro IS (x y) `(dcq ,y ,x))
 
(defmacro LETT (var val &rest L)
  (COND
    (|$QuickLet| `(SETQ ,var ,val))
    (|$compilingMap|
   ;; map tracing
     `(PROGN
        (SETQ ,var ,val)
        (COND (|$letAssoc|
               (|mapLetPrint| ,(MKQ var)
                              ,var
                              (QUOTE ,(KAR L))))
              ('T ,var))))
     ;; used for LETs in SPAD code --- see devious trick in COMP,TRAN,1
     ((ATOM var)
      `(PROGN
         (SETQ ,var ,val)
         (IF |$letAssoc|
             ,(cond ((null (cdr l))
                     `(|letPrint| ,(MKQ var) ,var (QUOTE ,(KAR L))))
                    ((and (eqcar (car l) 'SPADCALL) (= (length (car l)) 3))
                     `(|letPrint3| ,(MKQ var) ,var ,(third (car l)) (QUOTE ,(KADR L))))
                    (t `(|letPrint2| ,(MKQ var) ,(car l) (QUOTE ,(KADR L))))))
         ,var))
     ('T (ERROR "Cannot compileLET construct"))))
 
(defmacro SPADLET (A B)
  (if (ATOM A) `(SETQ ,A ,B)
     `(OR (IS ,B ,A) (LET_ERROR ,(MK_LEFORM A) ,(MKQ B) ))))
 
(defmacro RPLAC (&rest L)
  (if (EQCAR (CAR L) 'ELT)
      (LIST 'SETELT (CADAR L) (CADDR (CAR L)) (CADR L))
      (let ((A (CARCDREXPAND (CAR L) NIL)) (B (CADR L)))
        (COND ((CDDR L) (ERROR 'RPLAC))
              ((EQCAR A 'CAR) (LIST 'RPLACA (CADR A) B))
              ((EQCAR A 'CDR) (LIST 'RPLACD (CADR A) B))
              ((ERROR 'RPLAC))))))
 
(MAPC #'(LAMBDA (J) (MAKEPROP (CAR J) 'SELCODE (CADR J)))
      '((CAR 2) (CDR 3) (CAAR 4) (CADR 5) (CDAR 6) (CDDR 7)
        (CAAAR 8) (CAADR 9) (CADAR 10) (CADDR 11) (CDAAR 12)
        (CDADR 13) (CDDAR 14) (CDDDR 15) (CAAAAR 16) (CAAADR 17)
        (CAADAR 18) (CAADDR 19) (CADAAR 20) (CADADR 21) (CADDAR 22)
        (CADDDR 23) (CDAAAR 24) (CDAADR 25) (CDADAR 26) (CDADDR 27)
        (CDDAAR 28) (CDDADR 29) (CDDDAR 30) (CDDDDR 31)))
 
(eval-when (compile eval load)
(defun CARCDREXPAND (X FG)    ; FG = TRUE FOR CAR AND CDR
    (let (n hx)
      (COND ((ATOM X) X)
            ((SETQ N (GET (RENAME (SETQ HX (CARCDREXPAND (CAR X) FG))) 'SELCODE))
             (CARCDRX1 (CARCDREXPAND (CADR X) FG) N FG))
            ((CONS HX (MAPCAR #'(LAMBDA (Y) (CARCDREXPAND Y FG)) (CDR X)))))))
 
(DEFUN RENAME (U) 
 (let (x)
  (if (AND (IDENTP U) (SETQ X (GET U 'NEWNAM))) X U)))
 
(defun CARCDRX1 (X N FG)      ; FG = TRUE FOR CAR AND CDR
    (COND ((< N 1) (fail))
          ((EQL N 1) X)
          ((let ((D (DIVIDE N 2)))
             (CARCDRX1 (LIST (if (EQL (CADR D) 0) (if FG 'CAR 'CAR) (if FG 'CDR 'CDR)) X)
                       (CAR D)
                       FG))))))
 
 
; 7.3 Function Invocation
 
(DEFUN APPLYR (L X) (if (not L) X  (LIST (CAR L) (APPLYR (CDR L) X))))
 
; 7.8 Iteration
 
; 7.8.2 General Iteration
 
(defmacro REPEAT (&rest L)
  (let ((U (REPEAT-TRAN L NIL))) (-REPEAT (CDR U) (CAR U))))
 
(defun REPEAT-TRAN (L LP)
  (COND ((ATOM L) (ERROR "REPEAT FORMAT ERROR"))
        ((MEMBER (KAR (KAR L))
                 '(EXIT RESET IN ON GSTEP ISTEP STEP GENERAL UNTIL WHILE SUCHTHAT EXIT))
         (REPEAT-TRAN (CDR L) (CONS (CAR L) LP)))
        ((CONS (NREVERSE LP) (MKPF L 'PROGN)))))
 
(DEFUN MKPF (L OP)
  (if (FLAGP OP 'NARY) (SETQ L (MKPFFLATTEN-1 L OP NIL)))
  (MKPF1 L OP))
 
(DEFUN MKPFFLATTEN (X OP)
  (COND ((ATOM X) X)
        ((EQL (CAR X) OP) (CONS OP (MKPFFLATTEN-1 (CDR X) OP NIL)))
        ((CONS (MKPFFLATTEN (CAR X) OP) (MKPFFLATTEN (CDR X) OP)))))
 
(DEFUN MKPFFLATTEN-1 (L OP R)
  (let (X)
    (if (NULL L)
        R
        (MKPFFLATTEN-1 (CDR L) OP
           (APPEND R (if (EQCAR (SETQ X
                                      (MKPFFLATTEN (CAR L) OP)) OP)
                         (CDR X) (LIST X)))))))
 
(DEFUN MKPF1 (L OP)
  (let (X) (case OP (PLUS (COND ((EQL 0 (SETQ X (LENGTH
                                                 (SETQ L (S- L '(0 (ZERO))))))) 0)
                                ((EQL 1 X) (CAR L))
                                ((CONS 'PLUS L)) ))
                 (TIMES (COND ((S* L '(0 (ZERO))) 0)
                              ((EQL 0 (SETQ X (LENGTH
                                               (SETQ L (S- L '(1 (ONE))))))) 1)
                              ((EQL 1 X) (CAR L))
                              ((CONS 'TIMES L)) ))
                 (QUOTIENT (COND ((GREATERP (LENGTH L) 2) (fail))
                                 ((EQL 0 (CAR L)) 0)
                                 ((EQL (CADR L) 1) (CAR L))
                                 ((CONS 'QUOTIENT L)) ))
                 (MINUS (COND ((CDR L) (FAIL))
                              ((NUMBERP (SETQ X (CAR L))) (MINUS X))
                              ((EQCAR X 'MINUS) (CADR X))
                              ((CONS 'MINUS L))  ))
                 (DIFFERENCE (COND ((GREATERP (LENGTH L) 2) (FAIL))
                                   ((EQUAL (CAR L) (CADR L)) '(ZERO))
                                   ((|member| (CAR L) '(0 (ZERO))) (MKPF (CDR L) 'MINUS))
                                   ((|member| (CADR L) '(0 (ZERO))) (CAR L))
                                   ((EQCAR (CADR L) 'MINUS)
                                    (MKPF (LIST (CAR L) (CADADR L)) 'PLUS))
                                   ((CONS 'DIFFERENCE L)) ))
                 (EXPT (COND ((GREATERP (LENGTH L) 2) (FAIL))
                             ((EQL 0 (CADR L)) 1)
                             ((EQL 1 (CADR L)) (CAR L))
                             ((|member| (CAR L) '(0 1 (ZERO) (ONE))) (CAR L))
                             ((CONS 'EXPT L)) ))
                 (OR (COND ((MEMBER 'T L) ''T)
                           ((EQL 0 (SETQ X (LENGTH (SETQ L (REMOVE NIL L))))) NIL)
                           ((EQL 1 X) (CAR L))
                           ((CONS 'OR L)) ))
                 (|or| (COND ((MEMBER 'T L) 'T)
                             ((EQL 0 (SETQ X (LENGTH (SETQ L (REMOVE NIL L))))) NIL)
                             ((EQL 1 X) (CAR L))
                             ((CONS 'or L)) ))
                 (NULL (COND ((CDR L) (FAIL))
                             ((EQCAR (CAR L) 'NULL) (CADAR L))
                             ((EQL (CAR L) 'T) NIL)
                             ((NULL (CAR L)) ''T)
                             ((CONS 'NULL L)) ))
                 (|and| (COND ((EQL 0 (SETQ X (LENGTH
                                               (SETQ L (REMOVE T (REMOVE '|true| L)))))) T)
                              ((EQL 1 X) (CAR L))
                              ((CONS '|and| L)) ))
                 (AND (COND ((EQL 0 (SETQ X (LENGTH
                                             (SETQ L (REMOVE T (REMOVE '|true| L)))))) ''T)
                            ((EQL 1 X) (CAR L))
                            ((CONS 'AND L)) ))
                 (PROGN (COND ((AND (NOT (ATOM L)) (NULL (LAST L)))
                               (if (CDR L) `(PROGN . ,L) (CAR L)))
                              ((NULL (SETQ L (REMOVE NIL L))) NIL)
                              ((CDR L) (CONS 'PROGN L))
                              ((CAR L))))
                 (SEQ (COND ((EQCAR (CAR L) 'EXIT) (CADAR L))
                            ((CDR L) (CONS 'SEQ L))
                            ((CAR L))))
                 (LIST (if L (cons 'LIST L)))
                 (CONS (if (cdr L) (cons 'CONS L) (car L)))
                 (t (CONS OP L) ))))
 
(defvar $TRACELETFLAG NIL "Also referred to in Comp.Lisp")
 
(defmacro |Zero| (&rest L) 
 (declare (ignore l)) 
 "Needed by spadCompileOrSetq" 0)
 
(defmacro |One| (&rest L)
 (declare (ignore l))
 "Needed by spadCompileOrSetq" 1)
 
(defun -REPEAT (BD SPL)
  (let (u g g1 inc final xcl xv il rsl tll funPLUS funGT fun? funIdent
        funPLUSform funGTform)
    (DO ((X SPL (CDR X)))
        ((ATOM X)
         (LIST 'spadDO (NREVERSE IL) (LIST (MKPF (NREVERSE XCL) 'OR) XV)
               (SEQOPT (CONS 'SEQ (NCONC (NREVERSE RSL) (LIST (LIST 'EXIT BD)))))))
      (COND ((ATOM (CAR X)) (FAIL)))
      (COND ((AND (EQ (CAAR X) 'STEP)
                  (|member| (CADDAR X) '(2 1 0 (|One|) (|Zero|)))
                  (|member| (CADR (CDDAR X)) '(1 (|One|))))
             (SETQ X (CONS (CONS 'ISTEP (CDAR X)) (CDR X))) ))
                        ; A hack to increase the likelihood of small integers
      (SETQ U (CDAR X))
      (case (CAAR X)
        (GENERAL (AND (CDDDR U) (PUSH (CADDDR U) XCL))
                 (PUSH (LIST (CAR U) (CADR U) (CADDR U)) IL) )
        (GSTEP
          (SETQ tll (CDDDDR U))  ;tll is (+fun >fun type? ident)
          (SETQ funPLUSform (CAR tll))
          (SETQ funGTform   (CAR (SETQ tll (QCDR tll))))
          (PUSH (LIST (SETQ funPLUS (GENSYM)) funPLUSform) IL)
          (PUSH (LIST (SETQ funGT   (GENSYM)) funGTform) IL)
          (COND ((SETQ tll (CDR tll)) 
            (SETQ fun?     (CAR tll))
            (SETQ funIdent (CAR (SETQ tll (QCDR tll))))))
	  (IF (NOT (ATOM (SETQ inc (CADDR U)) ))
	      (PUSH (LIST (SETQ inc (GENSYM)) (CADDR U)) IL))
	  (SETQ final (CADDDR U))
          (COND (final
	     (COND ((ATOM final))
                   ((PUSH (LIST (SETQ final (GENSYM)) (CADDDR U)) IL)))
		 ; If CADDDR U is not an atom, only compute the value once
             (PUSH
                (if fun? 
                      (if (FUNCALL fun? INC)
                          (if  (FUNCALL (EVAL funGTform) INC funIdent) 
                               (LIST 'FUNCALL funGT (CAR U) FINAL)
                               (LIST 'FUNCALL funGT FINAL (CAR U)))
                           (LIST 'IF (LIST 'FUNCALL funGT INC funIdent)
                                     (LIST 'FUNCALL funGT (CAR U) FINAL)
                                     (LIST 'FUNCALL funGT FINAL  (CAR U))))
                       (LIST 'FUNCALL funGT (CAR U) final))
                     XCL)))
	  (PUSH (LIST (CAR U) (CADR U) (LIST 'FUNCALL funPLUS (CAR U) INC)) IL))
        (STEP
	  (IF (NOT (ATOM (SETQ inc (CADDR U)) ))
	      (PUSH (LIST (SETQ inc (GENSYM)) (CADDR U)) IL))
	  (COND ((CDDDR U)
		 (COND ((ATOM (SETQ final (CADDDR U)) ))
		       ((PUSH (LIST (SETQ final (GENSYM)) (CADDDR U)) IL)))
		 ; If CADDDR U is not an atom, only compute the value once
		 (PUSH
		   (if (INTEGERP INC)
		       (LIST (if  (MINUSP INC) '< '>) (CAR U) FINAL)
		     `(if (MINUSP ,INC)
			  (< ,(CAR U) ,FINAL)
			(> ,(CAR U) ,FINAL)))
		       XCL)))
	  (PUSH (LIST (CAR U) (CADR U) (LIST '+ (CAR U) INC)) IL))
        (ISTEP
	  (IF (NOT (ATOM (SETQ inc (CADDR U)) ))
	      (PUSH (LIST (SETQ inc (GENSYM)) (CADDR U)) IL))
          (COND ((CDDDR U)
                 (COND ((ATOM (SETQ final (CADDDR U)) ))
                       ((PUSH (LIST (SETQ final (GENSYM)) (CADDDR U)) IL)))
                     ; If CADDDR U is not an atom, only compute the value once
                 (PUSH
		   (if (INTEGERP INC)
		       (LIST (if  (QSMINUSP INC) 'QSLESSP 'QSGREATERP)
			     (CAR U) FINAL)
		     `(if (QSMINUSP ,INC)
			  (QSLESSP ,(CAR U) ,FINAL)
			(QSGREATERP ,(CAR U) ,FINAL)))
                       XCL)))
          (PUSH (LIST (CAR U) (CADR U)
                      (COND ((|member| INC '(1 (|One|)))
			     (MKQSADD1 (CAR U)))
                            ((LIST 'QSPLUS (CAR U) INC)) ))
                IL))
        (ON (PUSH (LIST 'ATOM (CAR U)) XCL)
            (PUSH (LIST (CAR U) (CADR U) (LIST 'CDR (CAR U))) IL))
        (RESET (PUSH (LIST 'PROGN (CAR U) NIL) XCL))
        (IN
          (PUSH (LIST 'OR
                      (LIST 'ATOM (SETQ G (GENSYM)))
                      (CONS 'PROGN
                            (CONS
                              (LIST 'SETQ (CAR U) (LIST 'CAR G))
                              (APPEND
                                (COND ((AND (symbol-package (car U)) $TRACELETFLAG)
                                       (LIST (LIST '/TRACELET-PRINT (CAR U)
                                                   (CAR U))))
                                      (NIL))
                                (LIST NIL))))  ) XCL)
          (PUSH (LIST G (CADR U) (LIST 'CDR G)) IL)
          (PUSH (LIST (CAR U) NIL) IL))
        (INDOM (SETQ G (GENSYM))
               (SETQ G1 (GENSYM))
               (PUSH (LIST 'ATOM G) XCL)
               (PUSH (LIST G (LIST 'INDOM-FIRST (CADR U))
                           (LIST 'INDOM-NEXT G1)) IL)
               (PUSH (LIST (CAR U) NIL) IL)
               (PUSH (LIST G1 NIL) IL)
               (PUSH (LIST 'SETQ G1 (LIST 'CDR G)) RSL)
               (PUSH (LIST 'SETQ (CAR U) (LIST 'CAR G)) RSL))
        (UNTIL (SETQ G (GENSYM)) (PUSH (LIST G NIL (CAR U)) IL) (PUSH G XCL))
        (WHILE (PUSH (LIST 'NULL (CAR U)) XCL))
        (SUCHTHAT (SETQ BD (LIST 'SUCHTHATCLAUSE BD (CAR U))))
        (EXIT (SETQ XV (CAR U))) (FAIL)))))
 

(defun SEQOPT (U)
  (if (AND (EQCAR U 'SEQ) (EQCAR (CADR U) 'EXIT) (EQCAR (CADADR U) 'SEQ))
      (CADADR U)
      U))
 
(defmacro SUCHTHATCLAUSE  (&rest L) (LIST 'COND (LIST (CADR L) (CAR L))))
 
(defvar $NEWSPAD NIL)
(defvar $BOOT NIL)
 
(defmacro spadDO (&rest OL)
    (PROG (VARS L VL V U INITS U-VARS U-VALS ENDTEST EXITFORMS BODYFORMS)
         (if (OR $BOOT (NOT $NEWSPAD)) (return (CONS 'DO OL)))
         (SETQ L  (copy-list OL))
         (if (OR (ATOM L) (ATOM (CDR L))) (GO BADO))
         (setq vl (POP L))
         (COND ((IDENTP VL)
                (SETQ VARS (LIST VL))
                (AND (OR (ATOM L)
                         (ATOM (progn (setq inits (POP L)) L))
                         (ATOM (progn (setq u-vals (pop L)) L)))
                     (GO BADO))
                (SETQ INITS (LIST INITS) U-VARS (LIST (CAR VARS)) U-VALS (LIST U-VALS))
                (setq endtest (POP L)))
               ((prog nil
                        (COND ((NULL VL) (GO TG5)) ((ATOM VL) (GO BADO)))
                 G180   (AND (NOT (PAIRP (SETQ V (CAR VL)))) (SETQ V (LIST V)))
                        (AND (NOT (IDENTP (CAR V))) (GO BADO))
                        (PUSH (CAR V) VARS)
                        (PUSH (COND ((PAIRP (CDR V)) (CADR V))) INITS)
                        (AND (PAIRP (CDR V))
                             (PAIRP (CDDR V))
                             (SEQ (PUSH (CAR V) U-VARS)
                                  (PUSH (CADDR V) U-VALS)))
                        (AND (PAIRP (progn (POP VL) VL)) (GO G180))
                    TG5 (setq exitforms (POP L))
                        (and (PAIRP EXITFORMS)
                             (progn (setq endtest (POP EXITFORMS)) exitforms)))))
         (AND L
           (COND ((CDR L) (SETQ BODYFORMS (CONS 'SEQ L)))
                 ((NULL (EQCAR (CAR L) 'SEQ)) (SETQ BODYFORMS (CONS 'SEQ L)))
                 ((SETQ BODYFORMS (CAR L)))))
         (SETQ EXITFORMS `(EXIT ,(MKPF EXITFORMS 'PROGN)))
         (AND ENDTEST (SETQ ENDTEST (LIST 'COND (LIST ENDTEST '(GO G191)))))
         (COND ((NULL U-VARS) (GO XT) )
               ((NULL (CDR U-VARS))
                (SEQ (SETQ U-VARS (LIST 'SETQ (CAR U-VARS) (CAR U-VALS)))
                     (GO XT)) ))
         (SETQ VL (LIST 'SETQ (CAR U-VARS) (CAR U-VALS)))
         (SEQ (SETQ V (CDR U-VARS)) (SETQ U (CDR U-VALS)))
     TG  (SETQ VL (LIST 'SETQ (CAR V) (LIST 'PROG1 (CAR U) VL)))
         (POP U)
         (AND (progn (POP V) V)  (GO TG))
         (SETQ U-VARS VL)
     XT  (RETURN (COND
           ((AND $NEWSPAD (NULL $BOOT))
             (CONS 'SEQ (NCONC (DO_LET VARS INITS)
               (LIST 'G190 ENDTEST BODYFORMS U-VARS '(GO G190)
                'G191 EXITFORMS))))
           ((CONS `(LAMBDA ,(NRECONC VARS NIL)
                     (SEQ G190 ,ENDTEST ,BODYFORMS ,U-VARS (GO G190) G191 ,EXITFORMS))
                  (NRECONC INITS NIL)))))
   BADO  (ERROR (FORMAT NIL "BAD DO FORMAT~%~A" OL))))
 
(defun DO_LET (VARS INITS)
  (if (OR (NULL VARS) (NULL INITS)) NIL
      (CONS (LIST 'SPADLET (CAR VARS) (CAR INITS))
           (DO_LET (CDR VARS) (CDR INITS)))))
 
(defun NREVERSE0 (X) ; Already built-in to CCL
  "Returns LST, reversed. The argument is modified.
This version is needed so that (COLLECT (IN X Y) ... (RETURN 'JUNK))=>JUNK."
 (if (ATOM X) X (NREVERSE X)))
 
; 7.8.4 Mapping
 
(defmacro COLLECT (&rest L)
  (let ((U (REPEAT-TRAN L NIL)))
    (CONS 'THETA (CONS '\, (NCONC (CAR U) (LIST (CDR U)))))))
 
;; The following was changed to a macro for efficiency in CCL.  To change
;; it back to a function would require recompilation of a large chunk of
;; the library.
(defmacro PRIMVEC2ARR (x) x) ;redefine to change Array rep

(defmacro COLLECTVEC (&rest L)
   `(PRIMVEC2ARR (COLLECTV ,@L)))

(defmacro COLLECTV (&rest L)
  (PROG (CONDS BODY ANS COUNTER X Y)
         ;If we can work out how often we will go round
         ;allocate a vector first
    (SETQ CONDS NIL)
    (SETQ BODY (REVERSE L))
    (SETQ ANS (GENSYM))
    (SETQ COUNTER NIL)
    (SETQ X (CDR BODY))
    (SETQ BODY (CAR BODY))
LP  (COND ((NULL X)
            (COND ((NULL COUNTER)
                    (SETQ COUNTER (GENSYM))
                    (SETQ L (CONS (LIST 'ISTEP COUNTER 0 1) L)) ))
            (RETURN (LIST 'PROGN
                          (LIST 'SPADLET ANS
                                     (LIST 'GETREFV
                                           (COND ((NULL CONDS) (fail))
                                                 ((NULL (CDR CONDS))
                                                   (CAR CONDS))
                                                   ((CONS 'MIN CONDS)) ) ))
                          (CONS 'REPEAT (NCONC (CDR (REVERSE L))
                                        (LIST (LIST 'SETELT ANS COUNTER BODY))))
                          ANS)) ))
    (SETQ Y (CAR X))
    (SETQ X (CDR X))
    (COND ((MEMQ (CAR Y) '(SUCHTHAT WHILE UNTIL))
                (RETURN (LIST 'LIST2VEC (CONS 'COLLECT L)) ))
          ((member (CAR Y) '(IN ON) :test #'eq)
            (SETQ CONDS (CONS (LIST 'SIZE (CADDR Y)) CONDS))
            (GO LP))
          ((member (CAR Y) '(STEP ISTEP) :test #'eq)
            (if (AND (EQL (CADDR Y) 0) (EQL (CADDDR Y) 1))
		(SETQ COUNTER (CADR Y)) )
            (COND ((CDDDDR Y)    ; there may not be a limit
                   (SETQ CONDS (CONS
                                 (COND ((EQL 1 (CADDDR Y))
                                        (COND ((EQL 1 (CADDR Y)) (CAR (CDDDDR Y)))
                                              ((EQL 0 (CADDR Y)) (MKQSADD1 (CAR (CDDDDR Y))))
                                              ((MKQSADD1 `(- ,(CAR (CDDDDR Y)) ,(CADDR Y))))))
                                       ((EQL 1 (CADDR Y)) `(/ ,(CAR (CDDDDR Y)) ,(CADDR Y)))
                                       ((EQL 0 (CADDR Y))
                                        `(/ ,(MKQSADD1 (CAR (CDDDDR Y))) ,(CADDR Y)))
                                       (`(/ (- ,(MKQSADD1 (CAR (CDDDDR Y))) ,(CADDR Y))
                                            ,(CADDR Y))))
                                 CONDS))))
            (GO LP)))
  (ERROR "Cannot handle macro expansion")))
 
(defun MKQSADD1 (X)
  (COND ((ATOM X) `(QSADD1 ,X))
        ((AND (member (CAR X) '(-DIFFERENCE QSDIFFERENCE -) :test #'eq)
	      (EQL 1 (CADDR X)))
         (CADR X))
        (`(QSADD1 ,X))))
 
; 7.10 Dynamic Non-local Exits
 
(defmacro yield (L)
  (let ((g (gensym)))
    `(let ((,g (state)))
       (if (statep ,g) (throw 'yield (list 'pair ,L) ,g)))))
 
; 10.1 The Property List
 
(DEFUN FLAG (L KEY)
  "Set the KEY property of every item in list L to T."
  (mapc #'(lambda (item) (makeprop item KEY T)) L))
 
(FLAG '(* + AND OR PROGN) 'NARY)                ; flag for MKPF
 
(DEFUN REMFLAG (L KEY)
  "Set the KEY property of every item in list L to NIL."
  (OR (ATOM L) (SEQ (REMPROP (CAR L) KEY) (REMFLAG (CDR L) KEY))))
 
(DEFUN FLAGP (X KEY)
  "If X has a KEY property, then FLAGP is true."
  (GET X KEY))
 
(defun PROPERTY (X IND N)
  "Returns the Nth element of X's IND property, if it exists."
  (let (Y) (if (AND (INTEGERP N) (SETQ Y (GET X IND)) (>= (LENGTH Y) N)) (ELEM Y N))))
 
; 10.3 Creating Symbols
 
(defmacro INTERNL (a &rest b) (if (not b) `(intern ,a) `(intern (strconc ,a . ,b))))

(defvar $GENNO 0)
 
(DEFUN GENVAR () (INTERNL "$" (STRINGIMAGE (SETQ $GENNO (1+ $GENNO)))))
 
(DEFUN IS_GENVAR (X)
  (AND (IDENTP X)
       (let ((y (symbol-name x)))
         (and (char= #\$ (elt y 0)) (> (size y) 1) (digitp (elt y 1))))))
 
(DEFUN IS_\#GENVAR (X)
  (AND (IDENTP X)
       (let ((y (symbol-name x)))
         (and (char= #\# (ELT y 0)) (> (SIZE Y) 1) (DIGITP (ELT Y 1))))))
 
; 10.7 CATCH and THROW
 
(defmacro SPADCATCH (&rest form) (CONS 'CATCH form))
 
(defmacro SPADTHROW (&rest form) (CONS 'THROW form))
 
; 12 NUMBERS
 
; 12.3 Comparisons on Numbers
 
(defmacro IEQUAL (&rest L) `(eql . ,L))
(defmacro GE (&rest L) `(>= . ,L))
(defmacro GT (&rest L) `(> . ,L))
(defmacro LE (&rest L) `(<= . ,L))
(defmacro LT (&rest L) `(< . ,L))
 
; 12.4 Arithmetic Operations
 
(defmacro SPADDIFFERENCE (&rest x) `(- . ,x))
 
; 12.5 Irrational and Transcendental Functions
 
; 12.5.1 Exponential and Logarithmic Functions
 
(define-function 'QSEXPT #'expt)
 
; 12.6 Small Finite Field ops with vector trimming
 
;; following macros assume 0 <= x,y < z

(defmacro qsaddmod (x y z)
  `(let* ((sum (qsplus ,x ,y))
	  (rsum (qsdifference sum ,z)))
     (if (qsminusp rsum) sum rsum)))
 
(defmacro qsdifmod (x y z)
  `(let ((dif (qsdifference ,x ,y)))
     (if (qsminusp dif) (qsplus dif ,z) dif)))
 
(defmacro qsmultmod (x y z)
 `(rem (* ,x ,y) ,z))
 
(defun TRIMLZ (vec)
  (declare (simple-vector vec))
  (let ((n (position 0 vec :from-end t :test-not #'eql)))
     (cond ((null n) (vector))
           ((eql n (qvmaxindex vec)) vec)
           (t (subseq vec 0 (+ n 1))))))
 
; 14 SEQUENCES
 
; 14.1 Simple Sequence Functions
 
(DEFUN NLIST (N FN)
  "Returns a list of N items, each initialized to the value of an
 invocation of FN"
  (if (LT N 1) NIL (CONS (EVAL FN) (NLIST (SUB1 N) FN))))
 
(define-function 'getchar #'elt)
 
(defun GETCHARN (A M) "Return the code of the Mth character of A"
  (let ((a (if (identp a) (symbol-name a) a))) (char-code (elt A M))))
 
; 14.2 Concatenating, Mapping, and Reducing Sequences
 
(DEFUN STRINGPAD (STR N)
  (let ((M (length STR)))
    (if (>= M N)
        STR
        (concatenate 'string str (make-string (- N M) :initial-element #\Space)))))
 
(DEFUN STRINGSUFFIX (TARGET SOURCE) "Suffix source to target if enough room else nil."
  (concatenate 'string target source))
 
(defun NSTRCONC (s1 s2) (concatenate 'string (string s1) (string s2)))
 
(defmacro spadREDUCE (OP AXIS BOD) (REDUCE-1 OP AXIS BOD))
 
(MAPC #'(LAMBDA (X) (MAKEPROP (CAR X) 'THETA (CDR X)))
      '((PLUS 0) (+ (|Zero|)) (|lcm| (|One|)) (STRCONC "") (|strconc| "")
        (MAX -999999) (MIN 999999) (TIMES 1) (* (|One|)) (CONS NIL)
        (APPEND NIL) (|append| NIL) (UNION NIL) (UNIONQ NIL) (|gcd| (|Zero|))
        (|union| NIL) (NCONC NIL) (|and| |true|) (|or| |false|) (AND 'T)
        (OR NIL)))
 
(define-function '|append| #'APPEND)
 
;;(defun |delete| (item list)    ; renaming from DELETE is done in DEF
;;   (cond ((atom list) list)
;;         ((equalp item (qcar list)) (|delete| item (qcdr list)))
;;         ('t (cons (qcar list) (|delete| item (qcdr list))))))
 
(defun |delete| (item sequence)
   (cond ((symbolp item) (remove item sequence :test #'eq))
	 ((and (atom item) (not (arrayp item))) (remove item sequence))
	 (T (remove item sequence :test #'equalp))))
 
(MAPC #'(LAMBDA (J) (MAKEPROP (CAR J) 'UNMACRO (CADR J)))
      '( (AND AND2) (OR OR2)))
 
(defun and2 (x y) (and x y))
 
(defun or2 (x y) (or x y))
 
(MAKEPROP 'CONS 'RIGHT-ASSOCIATIVE T)
 
(defun REDUCE-1 (OP AXIS BOD)
  (let (u op1 tran iden)
    (SEQ (SETQ OP1 (cond ((EQ OP '\,) 'CONS)
                         ((EQCAR OP 'QUOTE) (CADR OP))
                         (OP)))
         (SETQ IDEN (if (SETQ U (GET OP1 'THETA)) (CAR U) 'NO_THETA_PROPERTY))
         (SETQ TRAN (if (EQCAR BOD 'COLLECT)
                        (PROG (L BOD1 ITL)
                              (SETQ L (REVERSE (CDR BOD)))
                              (SETQ BOD1 (CAR L))
                              (SETQ ITL (NREVERSE (CDR L)))
                              (RETURN (-REDUCE OP1 AXIS IDEN BOD1 ITL)) )
                        (progn (SETQ U (-REDUCE-OP OP1 AXIS))
                               (LIST 'REDUCE-N (MKQ (OR (GET U 'UNMACRO) U))
                                     (GET OP1 'RIGHT-ASSOCIATIVE)
                                     BOD IDEN))))
         (if (EQ OP '\,) (LIST 'NREVERSE-N TRAN AXIS) TRAN))))
 
(defun -REDUCE (OP AXIS Y BODY SPL)
  (PROG (X G AUX EXIT VALUE PRESET CONSCODE RESETCODE)
   (SETQ G (GENSYM))
   ; create preset of accumulate
   (SETQ PRESET (COND
      ((EQ Y 'NO_THETA_PROPERTY) (LIST 'SPADLET G (MKQ G)))
      ((LIST 'SPADLET G Y)) ))
   (SETQ EXIT (COND
      ((SETQ X (ASSOC 'EXIT SPL))(SETQ SPL (DELASC 'EXIT SPL)) (COND
         ((MEMBER OP '(AND OR)) (LIST 'AND G (CADR X))) ((CADR X)) ))
      ((EQ Y 'NO_THETA_PROPERTY) (LIST 'THETACHECK G (MKQ G)(MKQ OP)))
      (G) ))
   (COND ((EQ OP 'CONS) (SETQ EXIT (LIST 'NREVERSE0 EXIT))))
   ; CONSCODE= code which conses a member onto the list
   (SETQ VALUE (COND ((EQ Y 'NO_THETA_PROPERTY) (GENSYM))
                     (BODY)))
   (SETQ CONSCODE (CONS (-REDUCE-OP OP AXIS) (COND
      ((FLAGP OP 'RIGHT-ASSOCIATIVE) (LIST VALUE G))
      ((LIST G VALUE) ) ) ) )
   ; next reset code which varies if THETA property is|/is not given
   (SETQ RESETCODE (LIST 'SETQ G (COND
      ((EQ Y 'NO_THETA_PROPERTY)
         (LIST 'COND (LIST (LIST 'EQ G (MKQ G)) VALUE)
                     (LIST ''T CONSCODE)) )
      (CONSCODE) )))
   ; create body
   (SETQ BODY (COND ((EQ VALUE BODY) RESETCODE)
                    ((LIST 'PROGN (LIST 'SPADLET VALUE BODY) RESETCODE)) ))
   (SETQ AUX (CONS (LIST 'EXIT EXIT) (COND
      ((EQ OP 'AND) (LIST (LIST 'UNTIL (LIST 'NULL G))))
      ((EQ OP 'OR) (LIST (LIST 'UNTIL G)))
      (NIL) )))
   (RETURN (COND
      ((AND $NEWSPAD (NULL $BOOT)) (LIST 'PROGN PRESET
         (CONS 'REPEAT (APPEND AUX (APPEND SPL (LIST BODY))) )))
      ((LIST 'PROG
                (COND ((EQ RESETCODE BODY) (LIST G)) ((LIST G VALUE)))
                PRESET (LIST 'RETURN
         (CONS 'REPEAT (APPEND AUX (APPEND SPL (LIST BODY)))))))))))
 
(defun -REDUCE-OP (OP AXIS)
  (COND ((EQL AXIS 0) OP)
        ((EQL AXIS 1)
         (COND ((EQ OP 'CONS) 'CONS-N)
               ((EQ OP 'APPEND) 'APPEND-N)
               ((FAIL))))
        ((FAIL))))
 
(defun NREVERSE-N (X AXIS)
  (COND ((EQL AXIS 0) (NREVERSE X))
        ((MAPCAR #'(LAMBDA (Y) (NREVERSE-N Y (SUB1 AXIS))) X))))
 
(defun CONS-N (X Y)
  (COND ((NULL Y) (CONS-N X (NLIST (LENGTH X) NIL)))
        ((MAPCAR #'CONS X Y))))
 
(defun APPEND-N (X Y)
  (COND ((NULL X) (APPEND-N (NLIST (LENGTH Y) NIL) Y))
        ((MAPCAR #'APPEND X Y))))
 
(defun REDUCE-N (OP RIGHT L ACC)
  (COND (RIGHT (PROG (U L1)
                     (SETQ L1 (NREVERSE L))
                     (SETQ U (REDUCE-N-1 OP 'T L1 ACC))
                     (NREVERSE L1)
                     (RETURN U) ))
        ((REDUCE-N-1 OP NIL L ACC))))
 
(defun REDUCE-N-1 (OP RIGHT L ACC)
  (COND ((EQ ACC 'NO_THETA_PROPERTY)
         (COND ((NULL L) (THETA_ERROR OP))
               ((REDUCE-N-2 OP RIGHT (CDR L) (CAR L))) ))
        ((REDUCE-N-2 OP RIGHT L ACC))))
 
(defun REDUCE-N-2 (OP RIGHT L ACC)
  (COND ((NULL L) ACC)
        (RIGHT (REDUCE-N-2 OP RIGHT (CDR L) (funcall (symbol-function OP) (CAR L) ACC)))
        ((REDUCE-N-2 OP RIGHT (CDR L) (funcall (symbol-function OP) ACC (CAR L))))))
 
(defmacro THETA (&rest LL)
  (let (U (L (copy-list LL)))
    (if (EQ (KAR L) '\,)  `(theta CONS . ,(CDR L))
        (progn
         (if (EQCAR (CAR L) 'QUOTE) (RPLAC (CAR L) (CADAR L)))
         (-REDUCE (CAR L) 0
                  (if (SETQ U (GET (CAR L) 'THETA)) (CAR U)
                      (MOAN "NO THETA PROPERTY"))
                  (CAR (SETQ L (NREVERSE (CDR L))))
                  (NREVERSE (CDR L)))))))
 
(defmacro THETA1 (&rest LL)
  (let (U (L (copy-list LL)))
    (if (EQ (KAR L) '\,)
        (LIST 'NREVERSE-N (CONS 'THETA1 (CONS 'CONS (CDR L))) 1)
        (-REDUCE (CAR L) 1
                 (if (SETQ U (GET (CAR L) 'THETA)) (CAR U)
                     (MOAN "NO THETA PROPERTY"))
                 (CAR (SETQ L (NREVERSE (CDR L))))
                 (NREVERSE (CDR L))))))
 
 
(defun THETACHECK (VAL VAR OP) (if (EQL VAL VAR) (THETA_ERROR OP) val))
 
(defun THETA_ERROR (OP)
  (Boot::|userError|
        (LIST "Sorry, do not know the identity element for " OP)))
 
; 15 LISTS
 
; 15.1 Conses
 
 
(defmacro |SPADfirst| (l)
  (let ((tem (gensym)))
    `(let ((,tem ,l)) (if ,tem (car ,tem) (first-error)))))
 
(defun first-error () (error "Cannot take first of an empty list"))
 
; 15.2 Lists
 
 
(defmacro ELEM (val &rest indices)
   (if (null indices) val `(ELEM (nth (1- ,(car indices)) ,val) ,@(cdr indices))))
 
(defun ELEMN (X N DEFAULT)
  (COND ((NULL X) DEFAULT)
        ((EQL N 1) (CAR X))
        ((ELEMN (CDR X) (SUB1 N) DEFAULT))))
 
(defmacro TAIL (&rest L)
  (let ((x (car L)) (n (if (cdr L) (cadr L) 1)))
    (COND ((EQL N 0) X)
          ((EQL N 1) (LIST 'CDR X))
          ((GT N 1) (APPLYR (PARTCODET N) X))
          ((LIST 'TAILFN X N)))))
 
(defun PARTCODET (N)
  (COND ((OR (NULL (INTEGERP N)) (LT N 1)) (ERROR 'PARTCODET))
        ((EQL N 1) '(CDR))
        ((EQL N 2) '(CDDR))
        ((EQL N 3) '(CDDDR))
        ((EQL N 4) '(CDDDDR))
        ((APPEND (PARTCODET (PLUS N -4)) '(CDDDDR)))))
 
(defmacro TL (&rest L) `(tail . ,L))
 
(defun TAILFN (X N) (if (LT N 1) X (TAILFN (CDR X) (SUB1 N))))
 
(defmacro SPADCONST (&rest L) (cons 'qrefelt L))
 
(defmacro SPADCALL (&rest L)
   (let ((args (butlast l)) (fn (car (last l))) (gi (gensym)))
     ;; (values t) indicates a single return value
     `(let ((,gi ,fn)) (the (values t) (funcall (car ,gi) ,@args (cdr ,gi))))
     ))
 
(DEFUN LASTELEM (X) (car (last X)))
 
(defun LISTOFATOMS (X)
  (COND ((NULL X) NIL)
        ((ATOM X) (LIST X))
        ((NCONC (LISTOFATOMS (CAR X)) (LISTOFATOMS (CDR X))))))
 
(DEFUN LASTATOM (L) (if (ATOM L) L (LASTATOM (CDR L))))
 
(define-function 'LASTTAIL #'last)
 
(define-function 'LISPELT #'ELT)
 
(defun DROP (N X &aux m)
  "Return a pointer to the Nth cons of X, counting 0 as the first cons."
  (COND ((EQL N 0) X)
        ((> N 0) (DROP (1- N) (CDR X)))
        ((>= (setq m (+ (length x) N)) 0) (take m x))
        ((CROAK (list "Bad args to DROP" N X)))))
 
(DEFUN TAKE (N X &aux m)
  "Returns a list of the first N elements of list X."
  (COND ((EQL N 0) NIL)
        ((> N 0) (CONS (CAR X) (TAKE (1- N) (CDR X))))
	((>= (setq m (+ (length x) N)) 0) (drop m x))
        ((CROAK (list "Bad args to DROP" N X)))))
 
(DEFUN NUMOFNODES (X) (if (ATOM X) 0 (+ 1 (NUMOFNODES (CAR X)) (NUMOFNODES (CDR X)))))
 
(DEFUN TRUNCLIST (L TL) "Truncate list L at the point marked by TL."
  (let ((U L)) (TRUNCLIST-1 L TL) U))
 
(DEFUN TRUNCLIST-1 (L TL)
  (COND ((ATOM L) L)
        ((EQL (CDR L) TL) (RPLACD L NIL))
        ((TRUNCLIST-1 (CDR L) TL))))
 
; 15.3 Alteration of List Structure
 
(defun RPLACW (x w) (let (y z) (dsetq (Y . Z) w) (RPLACA X Y) (RPLACD X Z)  X))
 
; 15.4 Substitution of Expressions
 
(DEFUN SUBSTEQ (NEW OLD FORM)
  "Version of SUBST that uses EQ rather than EQUAL on the world."
  (PROG (NFORM HNFORM ITEM)
        (SETQ HNFORM (SETQ NFORM (CONS () ())))
     LP    (RPLACD NFORM
                   (COND ((EQ FORM OLD) (SETQ FORM ()) NEW )
                         ((NOT (PAIRP FORM)) FORM )
                         ((EQ (SETQ ITEM (CAR FORM)) OLD) (CONS NEW ()) )
                         ((PAIRP ITEM) (CONS (SUBSTEQ NEW OLD ITEM) ()) )
                         ((CONS ITEM ()))))
        (if (NOT (PAIRP FORM)) (RETURN (CDR HNFORM)))
        (SETQ NFORM (CDR NFORM))
        (SETQ FORM (CDR FORM))
        (GO LP)))
 
(DEFUN SUBLISNQ (KEY E) (declare (special KEY)) (if (NULL KEY) E (SUBANQ E)))
 
(DEFUN SUBANQ (E)
  (declare (special key))
  (COND ((ATOM E) (SUBB KEY E))
        ((EQCAR E (QUOTE QUOTE)) E)
        ((MAPCAR #'(LAMBDA (J) (SUBANQ J)) E))))
 
(DEFUN SUBB (X E)
  (COND ((ATOM X) E)
        ((EQ (CAAR X) E) (CDAR X))
        ((SUBB (CDR X) E))))
 
(defun SUBLISLIS (newl oldl form)
   (sublis (mapcar #'cons oldl newl) form))

; 15.5 Using Lists as Sets

@
\section{DEFUN CONTAINED}
The CONTAINED predicate is used to walk internal structures
such as modemaps to see if the $X$ object occurs within $Y$. One
particular use is in a function called isPartialMode (see
i-funsel.boot) to decide
if a modemap is only partially complete. If this is true then the 
modemap will contain the constant \verb|$EmptyMode|. So the call 
ends up being CONTAINED \verb|$EmptyMode| Y. 
<<*>>=
(DEFUN CONTAINED (X Y)
  (if (symbolp x)
      (contained\,eq X Y)
      (contained\,equal X Y)))
 
(defun contained\,eq (x y)
       (if (atom y) (eq x y)
           (or (contained\,eq x (car y)) (contained\,eq x (cdr y)))))
 
(defun contained\,equal (x y)
   (cond ((atom y) (equal x y))
         ((equal x y) 't)
         ('t (or (contained\,equal x (car y)) (contained\,equal x (cdr y))))))
 
(DEFUN S+ (X Y)
  (COND ((ATOM Y) X)
        ((ATOM X) Y)
        ((MEMBER (CAR X) Y :test #'equal) (S+ (CDR X) Y))
        ((S+ (CDR X) (CONS (CAR X) Y)))))
 
(defun S* (l1 l2) (INTERSECTION l1 l2 :test #'equal))
(defun S- (l1 l2) (set-difference l1 l2 :test #'equal))
 
(DEFUN PREDECESSOR (TL L)
  "Returns the sublist of L whose CDR is EQ to TL."
  (COND ((ATOM L) NIL)
        ((EQ TL (CDR L)) L)
        ((PREDECESSOR TL (CDR L)))))
 
(defun remdup (l) (remove-duplicates l :test #'equalp))
 
(DEFUN GETTAIL (X L) (member X L :test #'equal))
 
; 15.6 Association Lists
 
(defun DelAsc (u v) "Returns a copy of a-list V in which any pair with key U is deleted."
   (cond ((atom v) nil)
         ((or (atom (car v))(not (equal u (caar v))))
          (cons (car v) (DelAsc u (cdr v))))
         ((cdr v))))
 
(DEFUN ADDASSOC (X Y L)
  "Put the association list pair (X . Y) into L, erasing any previous association for X"
  (COND ((ATOM L) (CONS (CONS X Y) L))
        ((EQUAL X (CAAR L)) (CONS (CONS X Y) (CDR L)))
        ((CONS (CAR L) (ADDASSOC X Y (CDR L))))))
 
(DEFUN DELLASOS (U V)
  "Remove any assocation pair (U . X) from list V."
  (COND ((ATOM V) NIL)
        ((EQUAL U (CAAR V)) (CDR V))
        ((CONS (CAR V) (DELLASOS U (CDR V))))))
 
(DEFUN ASSOCLEFT (X)
  "Returns all the keys of association list X."
  (if (ATOM X) X (mapcar #'car x)))
 
(DEFUN ASSOCRIGHT (X)
  "Returns all the datums of association list X."
  (if (ATOM X) X (mapcar #'cdr x)))
 
(DEFUN LASSOC (X Y)
  "Return the datum associated with key X in association list Y."
  (PROG NIL
     A  (COND ((ATOM Y) (RETURN NIL))
              ((EQUAL (CAAR Y) X) (RETURN (CDAR Y))) )
        (SETQ Y (CDR Y))
        (GO A)))
 
(DEFUN |rassoc| (X Y)
  "Return the datum associated with key X in association list Y."
  (PROG NIL
     A  (COND ((ATOM Y) (RETURN NIL))
              ((EQUAL (CDAR Y) X) (RETURN (CAAR Y))) )
        (SETQ Y (CDR Y))
        (GO A)))
 
; (defun QLASSQ (p a-list) (let ((y (assoc p a-list :test #'eq))) (if y (cdr y))))
(defun QLASSQ (p a-list) (cdr (assq p a-list)))

(define-function 'LASSQ #'QLASSQ)
 
(defun pair (x y) (mapcar #'cons x y))
 
;;; Operations on Association Sets (AS)
 
(defun AS-INSERT (A B L)
   ;; PF(item) x PF(item) x LIST(of pairs) -> LIST(of pairs with (A . B) added)
   ;; destructive on L; if (A . C) appears already, C is replaced by B
   (cond ((null l) (list (cons a b)))
         ((equal a (caar l)) (rplac (cdar l) b) l)
         ((?order a (caar l)) (cons (cons a b) l))
         (t (as-insert1 a b l) l)))
 
(defun as-insert1 (a b l)
   (cond ((null (cdr l)) (rplac (cdr l) (list (cons a b))))
         ((equal a (caadr l)) (rplac (cdadr l) b))
         ((?order a (caadr l)) (rplac (cdr l) (cons (cons a b) (cdr l))))
         (t (as-insert1 a b (cdr l)))))
 
 
; 17 ARRAYS
 
; 17.6 Changing the Dimensions of an Array
 
@
\section{Performance change}
Camm has identified a performace problem during compiles. There is
a loop that continually adds one element to a vector. This causes
the vector to get extended by 1 and copied. These patches fix the 
problem since vectors with fill pointers don't need to be copied.

These cut out the lion's share of the gc problem
on this compile.  30min {\tt ->} 7 min on my box.  There is still some gc
churning in cons pages due to many calls to 'list' with small n.  One
can likely improve things further with an appropriate (declare
(:dynamic-extent ...)) in the right place -- gcl will allocate such
lists on the C stack (very fast).

\subsection{lengthenvec}
The original code was:
\begin{verbatim}
(defun lengthenvec (v n)
  (if (adjustable-array-p v) (adjust-array v n)
    (replace (make-array n) v)))
\end{verbatim}

@
<<*>>=
(defun lengthenvec (v n)
  (if 
    (and (array-has-fill-pointer-p v) (adjustable-array-p v))
    (if 
      (>= n (array-total-size v)) 
        (adjust-array v (* n 2) :fill-pointer n) 
        (progn 
          (setf (fill-pointer v) n) 
          v))
    (replace (make-array n :fill-pointer t) v)))

(defun make-init-vector (n val) 
  (make-array n :initial-element val :fill-pointer t))

; 22 INPUT/OUTPUT
 
; 22.2 Input Functions
 
; 22.2.1 Input from Character Streams
 
(DEFUN STREAM-EOF (&optional (STRM *terminal-io*))
  "T if input stream STRM is at the end or saw a ~."
  (not (peek-char nil STRM nil nil nil))     )
 
(DEFUN CONSOLEINPUTP (STRM) (IS-CONSOLE STRM))
 
(defvar $filelinenumber 0)
(defvar $prompt "--->")
(defvar stream-buffer nil)
 
(DEFUN NEXTSTRMLINE (STRM) "Returns the next input line from stream STRM."
  (let ((v (read-line strm nil -1 nil)))
    (if (equal v -1) (throw 'spad_reader nil)
        (progn (setq stream-buffer v) v))))
 
(DEFUN CURSTRMLINE (STRM)
  "Returns the current input line from the stream buffer of STRM (VM-specific!)."
  (cond (stream-buffer)
        ((stream-eof strm) (fail))
        ((nextstrmline strm))))
 
(defvar *EOF* NIL)
 
(DEFUN CURMAXINDEX (STRM)
"Something bizarre and VM-specific with respect to streams."
  (if *EOF* (FAIL) (ELT (ELT (LASTATOM STRM) 1) 3)))
 
(DEFUN ADJCURMAXINDEX (STRM)
"Something unearthly and VM-specific with respect to streams."
  (let (v) (if *eof* (fail)
               (progn (SETQ V (ELT (LASTATOM STRM) 1))
                      (SETELT V 3 (SIZE (ELT V 0)))))))
 
(DEFUN STRMBLANKLINE (STRM)
"Something diabolical and VM-specific with respect to streams."
  (if *EOF* (FAIL) (AND (EQ '\  (CAR STRM)) (EQL 1 (CURMAXINDEX STRM)))))
 
(DEFUN STRMSKIPTOBLANK (STRM)
"Munch away on the stream until you get to a blank line."
  (COND (*EOF* (FAIL))
        ((PROGN (NEXTSTRMLINE STRM) (STRMBLANKLINE STRM)) STRM)
        ((STRMSKIPTOBLANK STRM))))
 
(DEFUN CURINPUTLINE () (CURSTRMLINE *standard-input*))
 
(DEFUN NEXTINPUTLINE () (NEXTSTRMLINE *standard-input*))
 
; 22.3 Output Functions
 
; 22.3.1 Output to Character Streams
 
(DEFUN ATOM2STRING (X)
  "Give me the string which would be printed out to denote an atom."
  (cond ((atom x) (symbol-name x))
        ((stringp x) x)
        ((write-to-string x))))
 
(defvar |conOutStream| *terminal-io* "console output stream")
 
(defun |sayTeX| (x) (if (null x) nil (sayBrightly1 x |$texOutputStream|)))
 
(defun |sayNewLine| () (TERPRI))

(defvar |$sayBrightlyStream| nil "if not nil, gives stream for sayBrightly output")
 
(defun |sayBrightly| (x &optional (out-stream *standard-output*))
  (COND ((NULL X) NIL)
	(|$sayBrightlyStream| (sayBrightly1 X |$sayBrightlyStream|))
        ((IS-CONSOLE out-stream) (sayBrightly1 X out-stream))
        ((sayBrightly1 X out-stream) (sayBrightly1 X *terminal-io*))))
 
(defun |sayBrightlyI| (x &optional (s *terminal-io*))
    "Prints at console or output stream."
  (if (NULL X) NIL (sayBrightly1 X S)))
 
(defun |sayBrightlyNT| (x &optional (S *standard-output*))
  (COND ((NULL X) NIL)
	(|$sayBrightlyStream| (sayBrightlyNT1 X |$sayBrightlyStream|))
        ((IS-CONSOLE S) (sayBrightlyNT1 X S))
        ((sayBrightly1 X S) (sayBrightlyNT1 X *terminal-io*))))
 
(defun sayBrightlyNT1 (X *standard-output*)
  (if (ATOM X) (BRIGHTPRINT-0 X) (BRIGHTPRINT X)))
 
(defun |saySpadMsg| (X)
  (if (NULL X) NIL (sayBrightly1 X |$algebraOutputStream|)))
 
(defun |sayALGEBRA| (X) "Prints on Algebra output stream."
  (if (NULL X) NIL (sayBrightly1 X |$algebraOutputStream|)))
 
(defun |sayMSGNT| (X)
  (if (NULL X) NIL (sayBrightlyNT1 X |$algebraOutputStream|)))
 
(defvar |$fortranOutputStream|)
 
(defun |sayFORTRAN| (x) "Prints on Fortran output stream."
  (if (NULL X) NIL (sayBrightly1 X |$fortranOutputStream|)))
 
(defvar |$formulaOutputStream|)
 
(defun |sayFORMULA| (X) "Prints on formula output stream."
  (if (NULL X) NIL (sayBrightly1 X |$formulaOutputStream|)))
 
(defvar |$highlightAllowed| nil "Used in BRIGHTPRINT and is a )set variable.")
 
(defvar |$highlightFontOn| $boldstring "switch to highlight font")
(defvar |$highlightFontOff| $normalstring "return to normal font")
 
;; the following are redefined in MSGDB BOOT
 
(defun SAY (&rest x) (progn (MESSAGEPRINT X) (TERPRI)))
 
(DEFUN BLANKS (N &optional (stream *standard-output*)) "Print N blanks."
    (do ((i 1 (the fixnum(1+ i))))
	((> i N))(declare (fixnum i n)) (princ " " stream)))
 
; 23 FILE SYSTEM INTERFACE
 
; 23.2 Opening and Closing Files
 
(DEFUN DEFSTREAM (file MODE)
       (if (member mode '(i input))
	   (MAKE-INSTREAM file)
	 (MAKE-OUTSTREAM file)))
 
; 23.3 Renaming, Deleting and Other File Operations
 
(DEFUN NOTE (STRM)
"Attempts to return the current record number of a file stream.  This is 0 for
terminals and empty or at-end files.  In Common Lisp, we must assume record sizes of 1!"
   (COND ((STREAM-EOF STRM) 0)
         ((IS-CONSOLE STRM) 0)
         ((file-position STRM))))
 
(DEFUN IS-CONSOLE-NOT-XEDIT (S) (not (OR (NULL (IS-CONSOLE S)))))
 
(DEFUN POINTW (RECNO STRM)
"Does something obscure and VM-specific with respect to streams."
  (let (V)
    (if (STREAM-EOF STRM) (FAIL))
    (SETQ V (LASTATOM STRM))
    (SETELT V 4 RECNO)
    (SETQ *EOF* (STREAM-EOF STRM))
    strm))
 
(DEFUN POINT (RECNO STRM) (file-position strm recno))
 
(DEFUN STRM (RECNO STRM)
"Does something obscure and VM-specific with respect to streams."
  (let (V)
    (if (STREAM-EOF STRM) (FAIL))
    (SETQ V (LASTATOM STRM))
    (SETELT V 4 RECNO)
    (read-char STRM)
    (SETQ *EOF* (STREAM-EOF STRM))
    strm))
 
; 24 ERRORS
 
; 24.2 Specialized Error-Signalling Forms and Macros
 
(defun MOAN (&rest x) (|sayBrightly| `(|%l| "===> " ,@X |%l|)))
 
(DEFUN FAIL () (|systemError| '"Antique error (FAIL ENTERED)"))
 
(defun CROAK (&rest x) (|systemError| x))
 
; 25 MISCELLANEOUS FEATURES
 
;; range tests and assertions
 
(defmacro |assert| (x y) `(IF (NULL ,x) (|error| ,y)))
 
(defun coerce-failure-msg (val mode)
   (STRCONC (MAKE-REASONABLE (STRINGIMAGE val))
	    " cannot be coerced to mode "
	    (STRINGIMAGE (|devaluate| mode))))
 
(defmacro |check-subtype| (pred submode val)
   `(|assert| ,pred (coerce-failure-msg ,val ,submode)))
 
(defmacro |check-union| (pred branch val)
   `(|assert| ,pred (coerce-failure-msg ,val ,branch )))
 
(defun MAKE-REASONABLE (Z)
   (if (> (length Z) 30) (CONCAT "expression beginning " (subseq Z 0 20)) Z))
 
 
(defmacro |elapsedUserTime| () '(get-internal-run-time))
 
(defmacro |elapsedGcTime| () '(system:gbc-time))
 
(defmacro |do| (&rest args) (CONS 'PROGN args))

(defmacro |char| (arg)
  (cond ((stringp arg) (character arg))
        ((integerp arg) (code-char arg))
	((and (consp arg) (eq (car arg) 'quote)) (character (cadr arg)))
	(t `(character ,arg))))

(defun DROPTRAILINGBLANKS  (LINE) (string-right-trim " " LINE))
 
; # Gives the number of elements of a list, 0 for atoms.
; If we quote it, then an interpreter trip is necessary every time
; we call #, and this costs us - 4% in the RATINT DEMO."

(define-function '\# #'SIZE)

(defun print-and-eval-defun (name body)
   (eval body)
   (print-defun name body)
  ;; (set name (symbol-function name)) ;; this should go away
   )

(defun eval-defun (name body) (eval (macroexpandall body)))

; This function was modified by Greg Vanuxem on March 31, 2005
; to handle the special case of #'(lambda ..... which expands
; into (function (lambda .....
; 
; The extra if clause fixes bugs #196 and #114
;
; an example that used to cause the failure was:
; )set func comp off
; f(xl:LIST FRAC INT): LIST FRAC INT == map(x +-> x, xl)
; f [1,2,3]
;
; which expanded into
;
; (defun |xl;f;1;initial| (|#1| |envArg|)
;  (prog (#:G1420)
;   (return 
;    (progn
;     (lett #:G1420 'uninitialized_variable |f| |#1;f;1:initial|)
;      (spadcall 
;       (cons (|function| (lambda (#:G1420 |envArg|) #:G1420)) (vector))
;       |#1|
;       (qrefelt |*1;f;1;initial;MV| 0))))))
;
; the (|function| (lambda form used to cause an infinite expansion loop
;      
(defun macroexpandall (sexpr)
 (cond
  ((atom sexpr) sexpr)
  ((eq (car sexpr) 'quote) sexpr)
  ((eq (car sexpr) 'defun)
   (cons (car sexpr) (cons (cadr sexpr)
       (mapcar #'macroexpandall (cddr sexpr)))))
  ((and (symbolp (car sexpr)) (macro-function (car sexpr)))
   (do ()
       ((not (and (consp sexpr) (symbolp (car sexpr))
		  (macro-function (car sexpr)))))
     (setq sexpr (macroexpand sexpr)))
   (if (consp sexpr) 
     (let ((a (car sexpr)) (b (caadr sexpr)))
       (if (and (eq a 'function) (eq b 'lambda))
         (cons a (list (cons b (mapcar #'macroexpandall (cdadr sexpr)))))
         (mapcar #'macroexpandall sexpr)))
       sexpr))
  ('else	
    (mapcar #'macroexpandall sexpr))))


(defun compile-defun (name body) (eval body) (compile name))

(defmacro |Record| (&rest x)
  `(|Record0| (LIST ,@(COLLECT (IN Y X)
                         (list 'CONS (MKQ (CADR Y)) (CADDR Y))))))

(defmacro |:| (tag expr) `(LIST '|:| ,(MKQ tag) ,expr))

(defun |deleteWOC| (item list) (lisp::delete item list :test #'equal))

(DEFUN |leftBindingPowerOf| (X IND &AUX (Y (GETL X IND)))
   (IF Y (ELEMN Y 3 0) 0))

(DEFUN |rightBindingPowerOf| (X IND &AUX (Y (GETL X IND)))
   (IF Y (ELEMN Y 4 105) 105))

(defmacro make-bf (MT EP) `(CONS |$BFtag| (CONS ,MT ,EP)))

(defun MAKE-FLOAT (int frac fraclen exp)
    (if (AND $SPAD |$useBFasDefault|)
        (if (= frac 0)
          (MAKE-BF int exp)
          (MAKE-BF (+ (* int (expt 10 fraclen)) frac) (- exp fraclen)) )
        (read-from-string
          (format nil "~D.~v,'0De~D" int fraclen frac exp))) )

;;---- Added by WFS.
 
(proclaim '(ftype (function (t t) t) |subWord|)) ;hack for bug in akcl-478
 
(DEFUN |subWord| (|str| N )
  (declare (fixnum n ) (string |str|))
  (PROG (|word| (|n| 0) |inWord|(|l| 0) )
     (declare (fixnum |n| |l|))
    (RETURN
      (SEQ (COND
             ((> 1 N) NIL)
             ('T (SPADLET |l| (SPADDIFFERENCE (|#| |str|) 1))
              (COND
                ((EQL |l| 0) NIL)
                ('T (SPADLET |n| 0) (SPADLET |word| '||)
                 (SPADLET |inWord| NIL)
                 (DO ((|i| 0 (QSADD1 |i|))) ((QSGREATERP |i| |l|) NIL)
               (declare (fixnum |i|))
                   (SEQ (EXIT (COND
                                ((eql (aref |str| |i|) #\space)
                                 (COND
                                   ((NULL |inWord|) NIL)
                                   ((eql |n| N) (RETURN |word|))
                                   ('T (SPADLET |inWord| NIL))))
                                ('T
                                 (COND
                                   ((NULL |inWord|)
                                    (SPADLET |inWord| 'T)
                                    (SPADLET |n| (PLUS |n| 1))))
                                 (COND
                                   ((eql |n| N)
                       (cond ((eq |word| '||)
                           (setq |word|
                           (make-array 10 :adjustable t
                                    :element-type 'standard-char
                                  :fill-pointer 0))))
                       (or |word| (error "bad"))
                       (vector-push-extend (aref |str| |i|)
                                  (the string |word|)
                                  )
                       )
                                   ('T NIL)))))))
                 (COND ((> N |n|) NIL) ('T |word|))))))))))

(defun print-full (expr &optional (stream *standard-output*))
   (let ((*print-circle* t) (*print-array* t) *print-level* *print-length*)
     (print expr stream)
     (terpri stream)
     (finish-output stream)))

;; moved here from preparse.lisp

(defun NEXT-TAB-LOC (i) (* (1+ (truncate i 8)) 8))
 
(defun INDENT-POS (STR)
  (do ((i 0 (1+ i))
       (pos 0))
      ((>= i (length str)) nil)
      (case (char str i)
            (#\space (incf pos))
            (#\tab (setq pos (next-tab-loc pos)))
            (otherwise (return pos)))))

;;(defun expand-tabs (str)
;;  (let ((bpos (nonblankloc str))
;;	(tpos (indent-pos str)))
;;    (if (eql bpos tpos) str
;;      (concatenate 'string (make-string tpos :initial-element #\space)
;;		   (subseq str bpos)))))
(defun expand-tabs (str)
   (if (and (stringp str) (> (length str) 0))
      (let ((bpos (nonblankloc str))
            (tpos (indent-pos str)))
        (setq str 
              (if (eql bpos tpos)
                  str
                  (concatenate 'string
                               (make-string tpos :initial-element #\space)
                               (subseq str bpos))))
         ;; remove dos CR
        (let ((lpos (maxindex str)))
          (if (eq (char str lpos) #\Return) (subseq str 0 lpos) str)))
    str))

(defun blankp (char) (or (eq char #\Space) (eq char #\tab)))
 
(defun nonblankloc (str) (position-if-not #'blankp str))
 
;; stream handling for paste-in generation

(defun |applyWithOutputToString| (func args)
  ;; returns the cons of applying func to args and a string produced
  ;; from standard-output while executing.
  (let* ((*standard-output* (make-string-output-stream))
	 (curoutstream *standard-output*)
	 (*terminal-io* *standard-output*)
	 (|$algebraOutputStream| *standard-output*)
         (erroroutstream *standard-output*)
	val)
    (declare (special *standard-output* curoutstream
		      *terminal-io* |$algebraOutputStream|))
    (setq val (catch 'spad_reader
		(catch 'TOP_LEVEL
		  (apply (symbol-function func) args))))
    (cons val (get-output-stream-string *standard-output*))))

(defun |breakIntoLines| (str)
  (let ((bol 0) (eol) (line-list nil))
    (loop
     (setq eol (position #\Newline str :start bol))
     (if (null eol) (return))
     (if (> eol bol) 
	 (setq line-list (cons (subseq str bol eol) line-list)))
     (setq bol (+ eol 1)))
    (nreverse line-list)))

; part of the old spad to new spad translator
; these are here because they need to be in depsys
; they were in nspadaux.lisp

(defmacro wi (a b) b)

(defmacro |try| (X)
  `(LET ((|$autoLine|))
	(declare (special |$autoLine|))
	(|tryToFit| (|saveState|) ,X)))

(defmacro |embrace| (X) `(|wrapBraces| (|saveC|) ,X (|restoreC|)))
(defmacro |indentNB| (X) `(|wrapBraces| (|saveD|) ,X (|restoreD|)))

(defmacro |tryBreak| (a b c d) 
; Try to format <a b> by:
; (1) with no line breaking ($autoLine = nil)
; (2) with possible line breaks within a;
; (3) otherwise use a brace
  `(LET
    ((state))
    (setq state (|saveState| 't))
    (or
      (LET ((|$autoLine|))
	 (declare (special |$autoLine|))
         (and ,a (|formatRight| '|formatPreferPile| ,b ,c ,d)))
      (|restoreState| state)
      (and (eqcar ,b (quote seq))
               (|embrace| (and 
                  ,a
                  (|formatLB|)
                  (|formatRight| '|formatPreferPile| ,b ,c ,d))))
      (|restoreState| state)
      (|embrace| (and ,a 
                  (|formatLB|)
                  (|formatRight| '|formatPreferPile| ,b ,c ,d))))))

(defmacro |tryBreakNB| (a b c d) 
; Try to format <a b> by:
; (1) with no line breaking ($autoLine = nil)
; (2) with possible line breaks within a;
; (3) otherwise display without a brace
  `(LET
    ((state))
    (setq state (|saveState| 't))
    (or
      (markhash ,b 0)
      (LET ((|$autoLine|))
	 (declare (special |$autoLine|))
         (and ,a (|formatRight| '|formatPreferPile| ,b ,c ,d)))
      (|restoreState| state)
      (markhash ,b 1)
      (and (eqcar ,b (quote seq))
               (|embrace| (and 
                  ,a
                  (|formatLB|)
                  (|formatRight| '|formatPreferPile| ,b ,c ,d))))
      (markhash ,b 2)
      (|restoreState| state)
      (|indentNB| (and ,a 
                  (|formatRight| '|formatPreferPile| ,b ,c ,d)))
      (markhash ,b 3)

)))   

(defun markhash (key n) (progn (cond
  ((equal n 3) (remhash key ht))
  ('t (hput ht key n)) ) nil))


; NAME:    Compiler Utilities Package

; PURPOSE: Comp is a modified version of Compile which is a preprocessor for
;          calls to Lisp Compile.  It searches for variable assignments that use
;          (SPADLET a b). It allows you to create local variables without
;          declaring them local by moving them into a PROG variable list.
;          This is not an ordinary SPADLET.  It looks and is used like a SETQ.
;          This preprocessor then collects the uses and creates the PROG.
;
;          SPADLET is defined in Macro.Lisp.
;
;          Comp recognizes as new lambda types the forms ILAM, SPADSLAM, SLAM,
;          and entries on $clamList.  These cache results.  ("Saving LAMbda".)
;          If the function is called with EQUAL arguments, returns the previous
;          result computed.
;
;          The package also causes traced things which are recompiled to
;          become untraced.

(export '(Comp FluidVars LocVars OptionList SLAM SPADSLAM ILAM FLUID))

;;; Common Block section

(defparameter FluidVars nil)
(defparameter LocVars nil)
(defparameter SpecialVars nil)

(defun |compAndDefine| (L)
  (let ((*comp370-apply* (function print-and-eval-defun)))
    (declare (special *comp370-apply*))
    (COMP L)))

(defun COMP (L) (MAPCAR #'COMP-2 (MAPCAN #'COMP-1 L)))

(defun |compQuietly| (fn)
  (let ((*comp370-apply*
	 (if |$InteractiveMode|
	     (if |$compileDontDefineFunctions| #'compile-defun #'eval-defun)
	   #'print-defun))
     ;; following creates a null outputstream if $InteractiveMode
	(*standard-output*
	 (if |$InteractiveMode| (make-broadcast-stream)
	   *standard-output*)))
    (COMP fn)))

;; The following are used mainly in setvars.boot
(defun notEqualLibs (u v)
  (if (string= u (library-name v)) (seq (close-library v) t) nil))

(defun |dropInputLibrary| (lib) 
  ;; Close any existing copies of this library on the input path
 (setq input-libraries
  (delete lib input-libraries :test #'notEqualLibs )))

(defun |openOutputLibrary| (lib)
  (|dropInputLibrary| lib)
  (setq output-library (open-library lib 't))
  (setq input-libraries (cons output-library input-libraries)) )

(defun |addInputLibrary| (lib)
  (|dropInputLibrary| lib)
   (setq input-libraries (cons (open-library lib) input-libraries)) )

(defun |compileQuietly| (fn)
  (let ((*comp370-apply*
	 (if |$InteractiveMode|
	     (if |$compileDontDefineFunctions| #'compile-defun #'eval-defun)
	   #'print-defun))
     ;; following creates a null outputstream if $InteractiveMode
	(*standard-output*
	 (if |$InteractiveMode| (make-broadcast-stream)
	   *standard-output*)))
    (COMP370 fn)))

(defun COMP-1 (X)
  (let* ((FNAME (car X))
	 ($FUNNAME FNAME)
         ($FUNNAME_TAIL (LIST FNAME))
	 (LAMEX (second X))
	 ($closedfns nil))
    (declare (special $FUNNAME $FUNNAME_TAIL $CLOSEDFNS))
    (setq LAMEX (COMP-TRAN LAMEX))
    (COMP-NEWNAM LAMEX)
    (if (fboundp FNAME)
	(format t "~&~%;;;     ***       ~S REDEFINED~%" FNAME))
    (CONS (LIST FNAME LAMEX) $CLOSEDFNS)))

(defun Comp-2 (args &aux name type argl bodyl junk)
    (dsetq (NAME (TYPE ARGL . BODYL) . JUNK) args)
    (cond (JUNK (MOAN (format nil "******pren error in (~S (~S ...) ...)" NAME TYPE)))
          ((eq TYPE 'SLAM) (COMP-SLAM NAME ARGL BODYL))
          ((LASSQ NAME |$clamList|) (|compClam| NAME ARGL BODYL |$clamList|))
          ((eq TYPE 'SPADSLAM) (COMP-SPADSLAM NAME ARGL BODYL))
          ((eq TYPE 'ILAM) (COMP-ILAM NAME ARGL BODYL))
          ((setq BODYL (LIST NAME (CONS TYPE (CONS ARGL BODYL))))
           (if |$PrettyPrint| (pprint bodyl))
           (if (null $COMPILE) (SAY "No Compilation")
               (COMP370 (LIST BODYL)))
           NAME)))

;; used to be called POSN - but that interfered with a CCL function
(DEFUN POSN1 (X L) (position x l :test #'equal))

(DEFUN COMP-ILAM (NAME ARGL BODYL)
  (let* ((FARGL (NLIST (LENGTH ARGL) '(GENSYM)))
         (BODYLP (SUBLISLIS FARGL ARGL BODYL)))
        (MAKEPROP NAME 'ILAM T)
        (SET NAME (CONS 'LAMBDA (CONS FARGL BODYLP)))
        NAME))

(DEFUN COMP-SPADSLAM (NAME ARGL BODYL)
  (let* ((AL (INTERNL NAME ";AL"))
         (AUXFN (INTERNL NAME ";"))
         (G1 (GENSYM))
         (G2 (GENSYM))
         (U (COND ((NOT ARGL) (LIST NIL NIL (LIST AUXFN)))
                  ((NOT (CDR ARGL))
                   (LIST (LIST G1) (LIST '|devaluate| G1) (LIST AUXFN G1)))
                  ((LIST G1
                         (LIST '|devaluateList| G1)
                         (LIST 'APPLY (LIST 'FUNCTION AUXFN) G1)))))
         (ARG (first U))
         (ARGTRAN (second U))
         (APP (third U))
         (LAMEX  `(lam ,ARG
                       (let (,g2)
                         (cond ,(COND (ARGL `((setq ,g2 (|assoc| ,argtran ,al))
                                              (cdr ,g2)))
                                      ((LIST AL)))
                               ,(COND (ARGL
                                       `(t(setq ,al(|cons5|(cons ,argtran
                                                                 (setq ,g2 ,app))
                                                           ,al))
                                          ,g2))
                                      (`(t (setq ,al ,app)))))))))
    (setandfile AL NIL)
    (setq U (LIST NAME LAMEX))
    (if |$PrettyPrint| (PRETTYPRINT U))
    (COMP370 (LIST U))
    (setq U (LIST AUXFN (CONS 'LAMBDA (CONS ARGL BODYL))))
    (COND (|$PrettyPrint| (PRETTYPRINT U)))
    (COMP370 (LIST U))
    NAME))

(DEFUN COMP-SLAM (NAME ARGL BODYL)
  (let* ((AL (INTERNL NAME ";AL"))
         (AUXFN (INTERNL NAME ";"))
         (G1 (GENSYM))
         (G2 (GENSYM))
         (U (COND ((NOT ARGL) `(nil (,auxfn)))
                  ((NOT (CDR ARGL)) `((,g1)(,auxfn ,g1)))
                  (`(,g1 (applx (function ,auxfn) ,g1)))))
         (ARG (CAR U))
         (APP (CADR U))
         (LAMEX
           (LIST 'LAM ARG
                 (LIST 'PROG (LIST G2)
                       (LIST 'RETURN
                             (LIST 'COND
                                   (COND (ARGL
                                          `((setq ,G2 (|assoc| ,G1 ,AL))
                                            (CDR ,G2)))
                                         ((LIST AL)))
                                   (COND (ARGL (LIST ''T `(setq ,G2 ,APP)
                                                     (LIST 'SETQ AL
                                                           `(CONS
                                                              (CONS ,G1 ,G2) ,AL))
                                                     G2))
                                         ((LIST ''T `(setq ,AL ,APP))))))))))
    (set AL NIL)
    (setq U (LIST NAME LAMEX))
    (if |$PrettyPrint| (PRETTYPRINT U))
    (COMP370 (LIST U))
    (setq U (LIST AUXFN (CONS 'LAMBDA (CONS ARGL BODYL))))
    (if |$PrettyPrint| (PRETTYPRINT U))
    (COMP370 (LIST U))
    NAME))

(DEFUN COMP-NEWNAM (X)
  (let (y u)
    (cond ((ATOM X) NIL)
          ((ATOM (setq Y (CAR X)))
          ;; (AND (IDENTP Y) (setq U (GET Y 'NEWNAM)) (RPLACA X U))
           (AND (NOT (eq Y 'QUOTE)) (COMP-NEWNAM (CDR X)))
	   (WHEN (and (EQ Y 'CLOSEDFN) (boundp '$closedfns))
		 (SETQ U (MAKE-CLOSEDFN-NAME))
		 (PUSH (list U (CADR X)) $closedfns)
		 (rplaca x 'FUNCTION)
		 (rplaca (cdr x) u)))
          (t (COMP-NEWNAM (CAR X)) (COMP-NEWNAM (CDR X))))))

(defun make-closedfn-name ()
  (internl $FUNNAME "!" (STRINGIMAGE (LENGTH $CLOSEDFNS))))

(DEFUN COMP-TRAN (X)
  "SEXPR<FN. BODY> -> SEXPR"
  (let ((X (COMP-EXPAND X)) FluidVars LocVars SpecialVars)
    (COMP-TRAN-1 (CDDR X))
    (setq X (list (first x) (second x)
                  (if (and (null (cdddr x))
                           (or (atom (third x))
                               (eq (car (third x)) 'SEQ)
			       (not (contained 'EXIT (third x)))))
                      (caddr x)
                      (cons 'SEQ (cddr x))))) ;catch naked EXITs
    (let* ((FluidVars (REMDUP (NREVERSE FLUIDVARS)))
           (LOCVARS (S- (S- (REMDUP (NREVERSE LOCVARS)) FLUIDVARS)
                        (LISTOFATOMS (CADR X))))
           (LVARS (append fluidvars LOCVARS)))
      (let ((fluids (S+ fluidvars SpecialVars)))
        (setq x
              (if fluids
                  `(,(first x) ,(second x)
                    (prog ,lvars (declare (special . ,fluids))
                      (return ,(third x))))
                  (list (first x) (second x)
		     (if (or lvars (contained 'RETURN (third x)))
			 `(prog ,lvars (return ,(third x)))
		         (third x)) )))))
    (let ((fluids (S+ (comp-fluidize (second x)) SpecialVars)))
      (if fluids
          `(,(first x) ,(second x) (declare (special . ,fluids)) . ,(cddr x))
          `(,(first x) ,(second x) . ,(cddr x))))))

; Fluidize: Returns a list of fluid variables in X

(DEFUN COMP-FLUIDIZE (X)
  (COND ((AND (symbolp X)
              (NE X '$)
	      (NE X '$$)
              (char= #\$ (ELT (PNAME X) 0))
              (NOT (DIGITP (ELT (PNAME X) 1))))
         x)
        ((atom x) nil)
        ((eq (first X) 'FLUID) (second X))
        ((let ((a (comp-fluidize (first x)))
               (b (comp-fluidize (rest x))))
           (if a (cons a b) b)))))

(DEFUN COMP\,FLUIDIZE  (X) (COND
  ((AND (IDENTP X)
        (NE X '$)
        (NE X '$$)
        (char= #\$ (ELT (PNAME X) 0)) (NULL (DIGITP (ELT (PNAME X) 1))))
    (LIST 'FLUID X))
  ((ATOM X) X)
  ((EQ (QCAR X) 'FLUID) X)
  ('T (PROG (A B)
      (SETQ A (COMP\,FLUIDIZE (QCAR X)))
      (SETQ B (COMP\,FLUIDIZE (QCDR X)))
      (COND ((AND (EQ A (QCAR X)) (EQ B (QCDR X)))
              (RETURN X))
            ('T (RETURN (CONS A B)) )) )    )))

; NOTE: It is potentially dangerous to assume every occurrence of element of
; $COMP-MACROLIST is actually a macro call

(defparameter $COMP-MACROLIST
  '(COLLECT REPEAT SUCHTHATCLAUSE THETA COLLECTV COLLECTVEC
	    THETA1 SPADREDUCE SPADDO)
  "???")

(DEFUN COMP-EXPAND (X)
  (COND ((atom x) x)
        ((eq (CAR X) 'QUOTE) X)
        ((memq (CAR X) $COMP-MACROLIST)
         (comp-expand (macroexpand-1 x)))
        ((let ((a (comp-expand (car x)))
               (b (comp-expand (cdr x))))
           (if (AND (eq A (CAR X)) (eq B (CDR X)))
               x
               (CONS A B))))))

(DEFUN COMP-TRAN-1 (X)
  (let (u)
    (cond ((ATOM X) NIL)
          ((eq (setq U (CAR X)) 'QUOTE) NIL)
          ((AND (eq U 'MAKEPROP) $TRACELETFLAG (RPLAC (CAR X) 'MAKEPROP-SAY) NIL)
           NIL)
           ; temporarily make TRACELET cause MAKEPROPs to be reported
          ((MEMQ U '(DCQ RELET PRELET SPADLET SETQ LET) )
           (COND ((NOT (eq U 'DCQ))
                  (COND ((OR (AND (eq $NEWSPAD T) (NOT $BOOT))
                             (MEMQ $FUNNAME |$traceletFunctions|))
                         (NCONC X $FUNNAME_TAIL)
                         (RPLACA X 'LETT))
                        ; this devious trick (due to RDJ) is needed since the compile
                        ; looks only at global variables in top-level environment;
                        ; thus SPADLET cannot itself test for such flags (7/83).
                        ($TRACELETFLAG (RPLACA X '/TRACE-LET))
                        ((eq U 'LET) (RPLACA X 'SPADLET)))))
           (COMP-TRAN-1 (CDDR X))
           (AND (NOT (MEMQ U '(setq RELET)))
                (COND ((IDENTP (CADR X)) (PUSHLOCVAR (CADR X)))
                      ((EQCAR (CADR X) 'FLUID)
                       (PUSH (CADADR X) FLUIDVARS)
                       (RPLAC (CADR X) (CADADR X)))
                      ((mapc #'pushlocvar (listofatoms (cadr x))) nil))))
          ((and (symbolp u) (GET U 'ILAM))
           (RPLACA X (EVAL U)) (COMP-TRAN-1 X))
          ((MEMQ U '(PROG LAMBDA))
           (PROG (NEWBINDINGS RES)
                 (setq NEWBINDINGS NIL)
                 (mapcar #'(lambda (Y)
                             (COND ((NOT (MEMQ Y LOCVARS))
                                    (setq LOCVARS (CONS Y LOCVARS))
                                    (setq NEWBINDINGS (CONS Y NEWBINDINGS)))))
                         (second x))
                 (setq RES (COMP-TRAN-1 (CDDR X)))
                 (setq locvars (remove-if #'(lambda (y) (memq y newbindings))
                                          locvars))
                 (RETURN (CONS U (CONS (CADR X) RES)) )) )
          ((PROGN (COMP-TRAN-1 U) (COMP-TRAN-1 (CDR X)))))))

(DEFUN PUSHLOCVAR (X)
  (let (p)
    (cond ((AND (NE X '$)
                (char= #\$ (ELT (setq P (PNAME X)) 0))
                (NOT (char= #\, (ELT P 1)))
                (NOT (DIGITP (ELT P 1)))) NIL)
          ((PUSH X LOCVARS)))))

(defmacro PRELET (L) `(spadlet . ,L))
(defmacro RELET (L) `(spadlet . ,L))
(defmacro PRESET (L) `(spadlet . ,L))
(defmacro RESET (L) `(spadlet . ,L))

;; this files contains basic routines for error handling
(defun error-format (message args)
  (let ((|$BreakMode| '|break|))
    (declare (special |$BreakMode|))
   (if (stringp message) (apply #'format nil message args) nil)))
 
;;(defmacro |trappedSpadEval| (form) form) ;;nop for now

;; failed union branch --  value returned for numeric failure
(setq |$numericFailure| (cons 1 "failed")) 

(defvar |$oldBreakMode|)

;; following macro evaluates form returning Union(type-of form, "failed")

(defmacro |trapNumericErrors| (form)
  `(let ((|$oldBreakMode| |$BreakMode|)
	 (|$BreakMode| '|trapNumerics|)
	 (val))
     (setq val (catch '|trapNumerics| ,form))
     (if (eq val |$numericFailure|) val
       (cons 0 val))))

;;;;;; considering this version for kcl
;;(defmacro |trapNumericErrors| (form)
;;   `(let ((val))
;;      (setq val (errorset ,form))
;;      (if (NULL val) |$numericFailure| (cons 0 (car val)))))

;; the following form embeds around the akcl error handler
(eval-when
 (load eval)
 (unembed 'system:universal-error-handler)
 (embed 'system:universal-error-handler
	    '(lambda (type correctable? op
			   continue-string error-string &rest args)
	       (block
		nil
		(setq |$NeedToSignalSessionManager| T)
		(if (and (boundp '|$inLispVM|) (boundp '|$BreakMode|))
		    (cond ((eq |$BreakMode| '|validate|)
			   (|systemError| (error-format error-string args)))
			  ((and (eq |$BreakMode| '|trapNumerics|)
				(eq type :ERROR))
			   (setq |$BreakMode| nil)			   (throw '|trapNumerics| |$numericFailure|))
                          ((and (eq |$BreakMode| '|trapNumerics|)
				(boundp '|$oldBreakMode|)
				(setq |$BreakMode| |$oldBreakMode|)
				nil)) ;; resets error handler
			  ((and (null |$inLispVM|)
				(memq |$BreakMode| '(|nobreak| |query| |resume|)))
			   (let ((|$inLispVM| T)) ;; turn off handler
			     (return
			      (|systemError| (error-format error-string args)))))
			  ((eq |$BreakMode| '|letPrint2|)
			   (setq |$BreakMode| nil)
			   (throw '|letPrint2| nil))))
		(apply system:universal-error-handler type correctable? op
		       continue-string error-string args )))))


;;;  @(#)debug.lisp	2.5      90/02/15  10:27:33
 
; NAME:    Debugging Package
; PURPOSE: Debugging hooks for Boot code
 
 
(DEFPARAMETER /COUNTLIST NIL)
(DEFPARAMETER /TIMERLIST NIL)
(DEFPARAMETER /TRACESIZE NIL "sets limit on size of object to be mathprinted")
(DEFVAR CURSTRM *TERMINAL-IO*)
(DEFVAR /TRACELETNAMES ())
(DEFVAR /PRETTY () "controls pretty printing of trace output")
(SETANDFILEQ /ECHO NIL) ;;"prevents echo of SPAD or BOOT code with /c"
(MAKEPROP 'LISP '/TERMCHR '(#\  #\())
(MAKEPROP 'LSP '/TERMCHR '(#\  #\())
(MAKEPROP 'META '/TERMCHR '(#\:  #\())
(MAKEPROP 'INPUT '/TERMCHR '(#\:  #\<  #\  #\())
(MAKEPROP 'SPAD '/TERMCHR '(#\:  #\<  #\  #\())
(MAKEPROP 'BOOT '/TERMCHR '(#\:  #\<  #\  #\())
(MAKEPROP 'INPUT '/XCAPE #\_)
(MAKEPROP 'BOOT '/XCAPE '#\_)
(MAKEPROP 'SPAD '/XCAPE '#\_)
(MAKEPROP 'META '/READFUN 'META\,RULE)
(MAKEPROP 'INPUT '/READFUN '|New,LEXPR,Interactive|)
(MAKEPROP 'INPUT '/TRAN '/TRANSPAD)
(MAKEPROP 'BOOT '/READFUN '|New,LEXPR1|)
(MAKEPROP 'BOOT '/TRAN '/TRANSNBOOT)
(MAKEPROP 'SPAD '/READFUN '|New,LEXPR|)
(MAKEPROP 'SPAD '/TRAN '/TRANSPAD)
 
(defmacro |/C,LIB| (&rest L &aux optionlist /editfile
			  ($prettyprint 't) ($reportCompilation 't))
  (declare (special optionlist /editfile $prettyprint $reportComilation))
  `',(|compileConstructorLib| L (/COMP) NIL NIL))
 
(defmacro /C (&rest L) `',(/D-1 L (/COMP) NIL NIL))
 
(defmacro /CT (&rest L) `',(/D-1 L (/COMP) NIL 'T))
 
(defmacro /CTL (&rest L) `',(/D-1 L (/COMP) NIL 'TRACELET))
 
(defmacro /D (&rest L) `',(/D-1 L 'DEFINE NIL NIL))
 
(defmacro /EC (&rest L) `', (/D-1 L (/COMP) 'T NIL))
 
(defmacro /ECT (&rest L) `',(/D-1 L (/COMP) 'T 'T))
 
(defmacro /ECTL (&rest L) `',(/D-1 L (/COMP) 'T 'TRACELET))
 
(defmacro /E (&rest L) `',(/D-1 L NIL 'T NIL))
 
(defmacro /ED (&rest L) `',(/D-1 L 'DEFINE 'T NIL))
 
(defun heapelapsed () 0)
 
(defun /COMP () (if (fboundp 'COMP) 'COMP 'COMP370))
 
(DEFUN /D-1 (L OP EFLG TFLG)
  (CATCH 'FILENAM
    (PROG (TO OPTIONL OPTIONS FNL INFILE OUTSTREAM FN )
          (declare (special fn infile outstream ))
          (if (member '? L :test #'eq)
              (RETURN (OBEY "EXEC SPADEDIT /C TELL")))
          (SETQ OPTIONL (/OPTIONS L))
          (SETQ FNL (TRUNCLIST L OPTIONL))
          (SETQ OPTIONS (OPTIONS2UC OPTIONL))
          (SETQ INFILE (/MKINFILENAM (/GETOPTION OPTIONS 'FROM)))
          (SETQ TO (/GETOPTION OPTIONS 'TO))
          (if TO (SETQ TO (/MKOUTFILENAM (/GETOPTION OPTIONS 'TO) INFILE)))
          (SETQ OUTSTREAM (if TO (DEFSTREAM TO 'OUTPUT) CUROUTSTREAM))
          (RETURN (mapcar #'(lambda (fn)
                              (/D-2 FN INFILE OUTSTREAM OP EFLG TFLG))
			  (or fnl (list /fn)))))))
 
(DEFUN |/D,2,LIB| (FN INFILE CUROUTSTREAM OP EDITFLAG TRACEFLAG)
       (declare (special CUROUTSTREAM))
  "Called from compConLib1 (see LISPLIB BOOT) to bind CUROUTSTREAM."
  (/D-2 FN INFILE CUROUTSTREAM OP EDITFLAG TRACEFLAG))
 
(DEFUN /D-2 (FN INFILE OUTPUTSTREAM OP EDITFLAG TRACEFLAG)
       (declare (special OUTPUTSTREAM))
  (PROG (FT oft SFN X EDINFILE FILE DEF KEY RECNO U W SOURCEFILES
	 ECHOMETA SINGLINEMODE XCAPE XTOKENREADER INPUTSTREAM SPADERRORSTREAM
	 ISID NBLNK COMMENTCHR $TOKSTACK (/SOURCEFILES |$sourceFiles|)
	 METAKEYLST DEFINITION_NAME (|$sourceFileTypes| '(|spad| |boot| |lisp| |lsp| |meta|))
	 ($FUNCTION FN) $BOOT $NEWSPAD $LINESTACK $LINENUMBER STACK STACKX BACK OK
	 |$InteractiveMode| TOK COUNT ERRCOL COLUMN *QUERY CHR LINE
	 (*COMP370-APPLY* (if (eq op 'define) #'eval-defun #'compile-defun)))
	(declare (special ECHOMETA SINGLINEMODE XCAPE XTOKENREADER INPUTSTREAM
		     SPADERRORSTREAM ISID NBLNK COMMENTCHR $TOKSTACK /SOURCEFILES
		     METAKEYLST DEFINITION_NAME |$sourceFileTypes|
		     $FUNCTION $BOOT $NEWSPAD $LINESTACK $LINENUMBER STACK STACKX BACK OK
		     |$InteractiveMode| TOK COUNT ERRCOL COLUMN *QUERY CHR LINE))
        (if (PAIRP FN) (SETQ FN (QCAR FN)))
        (SETQ INFILE (OR INFILE (|getFunctionSourceFile| FN)))
	  ;; $FUNCTION is freely set in getFunctionSourceFile
	(IF (PAIRP $FUNCTION) (SETQ $FUNCTION (QCAR $FUNCTION)))
        (SETQ FN $FUNCTION)
        (SETQ /FN $FUNCTION)
   LOOP (SETQ SOURCEFILES
              (cond ( INFILE
		      (SETQ /SOURCEFILES (CONS INFILE (REMOVE INFILE /SOURCEFILES)))
		      (LIST INFILE))
		    ( /EDITFILE
		      (|insert| (|pathname| /EDITFILE) /SOURCEFILES))
		    ( 't /SOURCEFILES)))
        (SETQ RECNO
              (dolist (file sourcefiles)
                    (SETQ INPUTSTREAM (DEFSTREAM FILE 'INPUT))
 
                    ;;?(REMFLAG S-SPADKEY 'KEY)    ;  hack !!
		    (SETQ  FT (|pathnameType| FILE))
		    (SETQ  oft (|object2Identifier| (UPCASE FT)))
		    (SETQ XCAPE (OR (GET oft '/XCAPE) #\|))
                    (SETQ COMMENTCHR (GET oft '/COMMENTCHR))
                    (SETQ XTOKENREADER (OR (GET oft '/NXTTOK) 'METATOK))
                    (SETQ DEFINITION_NAME FN)
                    (SETQ KEY
                          (STRCONC
                            (OR (AND (EQ oFT 'SPAD) "")
                                (AND (EQ oFT 'BOOT) "")
                                (GET oFT '/PREFIX)
                                "")
                            (PNAME FN)))
                    (SETQ SFN (GET oFT '/READFUN))
                    (SETQ RECNO (/LOCATE FN KEY FILE 0))
		    (SHUT INPUTSTREAM)
                    (cond ((NUMBERP RECNO)
                           (SETQ /SOURCEFILES (CONS FILE (REMOVE FILE /SOURCEFILES)))
                           (SETQ INFILE FILE)
                           (RETURN RECNO)))) )
        (if (NOT RECNO)
            (if (SETQ INFILE (/MKINFILENAM '(NIL))) (GO LOOP) (UNWIND)))
        (TERPRI)
        (TERPRI)
	(SETQ INFILE (|pathname| INFILE))
	(COND
	 ( EDITFLAG
          ;;%% next form is used because $FINDFILE seems to screw up
          ;;%% sometimes. The stream is opened and closed several times
          ;;%% in case the filemode has changed during editing.
          (SETQ EDINFILE (make-input-filename INFILE))
          (SETQ INPUTSTREAM (DEFSTREAM EDINFILE 'INPUT))
          (|sayBrightly|
            (LIST  "   editing file" '|%b| (|namestring| EDINFILE) '|%d|))
          (OBEY
            (STRCONC
              (make-absolute-filename "/lib/SPADEDFN ")
              (|namestring| EDINFILE)
              " "
              (STRINGIMAGE $LINENUMBER)))
          (SHUT INPUTSTREAM)
          ;(COND
	  ;  ( (EQ (READ ERRORINSTREAM) 'ABORTPROCESS)
	  ;    (RETURN 'ABORT) ) )
          ;;%% next is done in case the diskmode changed
          ;;(SETQ INFILE (|pathname| (IFCAR
	  ;; (QSORT ($LISTFILE INFILE)))))
          (SETQ INPUTSTREAM (DEFSTREAM INFILE 'INPUT))
          (SETQ RECNO (/LOCATE FN KEY INFILE RECNO))
	
	  (COND ((NOT RECNO)
		 (|sayBrightly| (LIST "   Warning: function" "%b" /FN "%d"
				      "was not found in the file" "%l" "  " "%b"
				      (|namestring| INFILE) "%d" "after editing."))
		 (RETURN NIL)))
	  ;; next is done in case the diskmode changed
	  (SHUT INPUTSTREAM) ))
	;;(SETQ INFILE (|pathname| (IFCAR ($LISTFILE INFILE))))
	(SETQ INFILE (vmlisp::make-input-filename INFILE))
	(MAKEPROP /FN 'DEFLOC
		  (CONS RECNO INFILE))
	(SETQ oft (|object2Identifier| (UPCASE (|pathnameType| INFILE))))
	(COND
	 ( (NULL OP)
	   (RETURN /FN) ) )
	(COND
	 ( (EQ TRACEFLAG 'TRACELET)
	   (RETURN (/TRACELET-1 (LIST FN) NIL)) ) )
	(SETQ INPUTSTREAM (DEFSTREAM INFILE 'INPUT))
	(|sayBrightly|
	 (LIST  "   Reading file" '|%b| (|namestring| INFILE) '|%d|))
	(TERPRI)
	(SETQ $BOOT (EQ oft 'BOOT))
	(SETQ $NEWSPAD (OR $BOOT (EQ oft 'SPAD)))
	(SETQ DEF
	      (COND
	       ( SFN
		 ;(+VOL 'METABASE)
		 (POINT RECNO INPUTSTREAM)
		 ;(SETQ CHR (CAR INPUTSTREAM))
		 ;(SETQ ERRCOL 0)
		 ;(SETQ COUNT 0)
		 ;(SETQ COLUMN 0)
		 (SETQ OK 'T)
		 ;(NXTTOK)
		 ;(SETQ LINE (CURINPUTLINE))
		 ;(SETQ SPADERRORSTREAM CUROUTSTREAM)
		 ;(AND /ECHO (SETQ ECHOMETA 'T) (PRINTEXP LINE) (TERPRI))
		 ;(SFN)
		 (SETQ DEF (BOOT-PARSE-1 INPUTSTREAM))
		 (SETQ DEBUGMODE 'YES)
		 (COND
		  ( (NULL OK)
		    (FUNCALL (GET oft 'SYNTAX_ERROR))
		    NIL )
		  ( 'T
		    DEF ) ) )
	       ( 'T
		 (let* ((mode-line (read-line inputstream))
			(pacpos (search "package:" mode-line :test #'equalp))
			(endpos (search "-*-" mode-line :from-end t))
			(*package* *package*)
			(newpac nil))
		   (when pacpos
			 (setq newpac (read-from-string mode-line nil nil
							:start (+ pacpos 8)
							:end endpos))
			 (setq *package*
			       (cond ((find-package newpac))
				     (t *package*))))
		   (POINT RECNO INPUTSTREAM)
		   (READ INPUTSTREAM)))))
	(COND
	 ( (SETQ U (GET oft '/TRAN))
	   (SETQ DEF (FUNCALL U DEF)) ) )
      (/WRITEUPDATE
        /FN
        (|pathnameName| INFILE)
        (|pathnameType| INFILE)
        (OR (|pathnameDirectory| INFILE) '*)
        (OR (KAR (KAR (KDR DEF))) NIL)
        OP)
      (COND
        ( (OR /ECHO $PRETTYPRINT)
          (PRETTYPRINT DEF OUTPUTSTREAM) ) )
      (COND
        ( (EQ oft 'LISP)
	  (if (EQ OP 'DEFINE) (EVAL DEF)
	    (compile (EVAL DEF))))
        ( DEF
          (FUNCALL OP (LIST DEF)) ) )
      (COND
        ( TRACEFLAG
          (/TRACE-2 /FN NIL) ) )
      (SHUT INPUTSTREAM)
      (RETURN (LIST /FN)) ) )
 
(DEFUN FUNLOC (func &aux file)
  (if (PAIRP func) (SETQ func (CAR func)))
  (setq file (ifcar (findtag func)))
  (if file (list (pathname-name file) (pathname-type file) func)
    nil))
 
(DEFUN /LOCATE (FN KEY INFILE INITRECNO)
       (PROG (FT RECNO KEYLENGTH LN)
        (if (AND (NOT (eq 'FROMWRITEUPDATE (|pathnameName| INFILE)))
                    (NOT (make-input-filename INFILE)))
            (RETURN NIL))
	(SETQ FT (UPCASE (|object2Identifier| (|pathnameType| INFILE))))
        (SETQ KEYLENGTH (STRINGLENGTH KEY))
	(WHEN (> INITRECNO 1)  ;; we think we know where it is
	      (POINT INITRECNO INPUTSTREAM)
	      (SETQ LN (READ-LINE INPUTSTREAM NIL NIL))
	      (IF (AND LN (MATCH-FUNCTION-DEF FN KEY KEYLENGTH LN FT))
		  (RETURN INITRECNO)))
	(SETQ $LINENUMBER 0)
	(POINT 0 INPUTSTREAM)
EXAMINE (SETQ RECNO (NOTE INPUTSTREAM))
	(SETQ LN (READ-LINE INPUTSTREAM NIL NIL))
	(INCF $LINENUMBER)
	(if (NULL LN) (RETURN NIL))
	(IF (MATCH-FUNCTION-DEF FN KEY KEYLENGTH LN FT)
	    (RETURN RECNO))
        (GO EXAMINE)))
 
(DEFUN MATCH-FUNCTION-DEF (fn key keylength line type)
       (if (eq type 'LISP) (match-lisp-tag fn line "(def")
	 (let ((n (mismatch key line)))
	   (and (= n keylength)
		(or (= n (length line))
		    (member (elt line n)
			    (or (get type '/termchr) '(#\space ))))))))
 
(define-function '|/D,1| #'/D-1)
 
(DEFUN /INITUPDATES (/VERSION)
   (SETQ FILENAME (STRINGIMAGE /VERSION))
   (SETQ /UPDATESTREAM (open (strconc "/tmp/update." FILENAME) :direction :output
			     :if-exists :append :if-does-not-exist :create))
   (PRINTEXP
 "       Function Name                    Filename             Date   Time"
      /UPDATESTREAM)
   (TERPRI /UPDATESTREAM)
   (PRINTEXP
 " ---------------------------      -----------------------  -------- -----"
      /UPDATESTREAM)
   (TERPRI /UPDATESTREAM) )
 
(defun /UPDATE (&rest ARGS)
  (LET (( FILENAME (OR (KAR ARGS)
		       (strconc "/tmp/update." (STRINGIMAGE /VERSION))))
        (|$createUpdateFiles| NIL))
       (DECLARE (SPECIAL |$createUpdateFiles|))
       (CATCH 'FILENAM (/UPDATE-1 FILENAME '(/COMP)))
       (SAY "Update is finished")))

(defun /DUPDATE (&rest ARGS)
  (LET (( FILENAME (OR (KAR ARGS)
		       (strconc "/tmp/update." (STRINGIMAGE /VERSION))))
        (|$createUpdateFiles| NIL))
       (DECLARE (SPECIAL |$createUpdateFiles|))
       (CATCH 'FILENAM (/UPDATE-1 FILENAME 'DEFINE))
       (SAY "Update is finished")))
 
(DEFUN /UPDATE-1 (UPFILE OP)
   ;;if /VERSION=0 then no new update files will be written.
  (prog (STREAM RECORD FUN FILE FUNFILES)
   (SETQ STREAM (DEFSTREAM (/MKINFILENAM UPFILE) 'INPUT))
 LOOP
   (if (STREAM-EOF STREAM) (RETURN NIL))
   (SETQ RECORD (read-line STREAM))
   (if (NOT (STRINGP RECORD)) (RETURN NIL))
   (if (< (LENGTH RECORD) 36) (GO LOOP))
   (SETQ FUN (STRING2ID-N (SUBSTRING RECORD 0 36) 1))
   (if (AND (NOT (EQUAL FUN 'QUAD)) (EQUAL (SUBSTRING RECORD 0 1) " "))
       (GO LOOP))
   (SETQ FILE (STRING2ID-N RECORD 2))
   (if (member (cons fun file) funfiles :test #'equal) (go loop))
   (push (cons fun file) funfiles)
   (COND ((EQUAL FUN 'QUAD) (/RF-1 FILE))
         ((/D-2 FUN FILE CUROUTSTREAM OP NIL NIL)))
   (GO LOOP)))
 
(DEFUN /WRITEUPDATE (FUN FN FT FM FTYPE OP)
 
;;;If /VERSION=0 then no save has yet been done.
;;;If A disk is not read-write, then issue msg and return.
;;;If /UPDATESTREAM not set or current /UPDATES file doesnt exist, initialize.
 
   (PROG (IFT KEY RECNO ORECNO COUNT DATE TIME)
;         (if (EQ 0 /VERSION) (RETURN NIL))
         (if (EQ 'INPUT FT) (RETURN NIL))
         (if (NOT |$createUpdateFiles|) (RETURN NIL))
;         (COND ((/= 0 (directory "A")))
;               ((SAY "A disk is not read-write. Update file not modified")
;                (RETURN NIL)))
         (if (OR (NOT (BOUNDP '/UPDATESTREAM))
		 (NOT (STREAMP /UPDATESTREAM)))
             (/INITUPDATES /VERSION))
;         (SETQ IFT (INTERN (STRINGIMAGE /VERSION)))
;         (SETQ INPUTSTREAM (open (strconc IFT /WSNAME) :direction :input))
;         (NEXT INPUTSTREAM)
;         (SETQ KEY (if (NOT FUN)
;                       (STRCONC "                                QUAD "
;                                (PNAME FN))
;                       (PNAME FUN)))
;         (SETQ RECNO (/LOCATE KEY (LIST 'FROMWRITEUPDATE /WSNAME) 1))
;         (SETQ COUNT (COND
;                       ((NOT (NUMBERP RECNO)) 1)
;                       ((POINT RECNO INPUTSTREAM)
;                        (do ((i 1 (1+ i))) ((> i 4)) (read inputstream))
;                        (1+ (READ INPUTSTREAM)) )))
;         (COND ((NUMBERP RECNO)
;                (SETQ ORECNO (NOTE /UPDATESTREAM))
;                (POINTW RECNO /UPDATESTREAM) ))
	 (SETQ DATETIME (|getDateAndTime|))
	 (SETQ DATE (CAR DATETIME))
	 (SETQ TIME (CDR DATETIME))
         (PRINTEXP (STRCONC
                  (COND ((NOT FUN) "                                QUAD ")
                        ((STRINGPAD (PNAME FUN) 28))) " "
		  (STRINGIMAGE FM)
		  (STRINGIMAGE FN) "." (STRINGIMAGE FT)
                  " "
                  DATE " " TIME) /UPDATESTREAM)
         (TERPRI /UPDATESTREAM)
;         (if (NUMBERP RECNO) (POINTW ORECNO /UPDATESTREAM))
	 ))
 
(defun |getDateAndTime| ()
   (MULTIPLE-VALUE-BIND (sec min hour day mon year) (get-decoded-time)
   (CONS (STRCONC (LENGTH2STR mon) "/"
		  (LENGTH2STR day) "/"
		  (LENGTH2STR year) )
	 (STRCONC (LENGTH2STR hour) ":"
		  (LENGTH2STR min)))))
 
(DEFUN LENGTH2STR (X &aux XLEN)
       (cond ( (= 1 (SETQ XLEN (LENGTH (SETQ X (STRINGIMAGE X))))) (STRCONC "0" X))
	     ( (= 2 XLEN) X)
	     ( (subseq x (- XLEN 2)))))
 
(defmacro /T (&rest L) (CONS '/TRACE (OR L (LIST /FN))))
 
(defmacro /TRACE (&rest L) `',(/TRACE-0 L))
 
(DEFUN /TRACE-0 (L)
  (if (member '? L :test #'eq)
      (OBEY "EXEC NORMEDIT TRACE TELL")
      (let* ((options (/OPTIONS L)) (FNL (TRUNCLIST L OPTIONS)))
        (/TRACE-1 FNL OPTIONS))))
 
(define-function '|/TRACE,0| #'/TRACE-0)
 
(defmacro /TRACEANDCOUNT (&rest L) `',
  (let* ((OPTIONS (/OPTIONS L))
         (FNL (TRUNCLIST L OPTIONS)))
    (/TRACE-1 FNL (CONS '(DEPTH) OPTIONS))))
 
(DEFUN /TRACE-1 (FNLIST OPTIONS)
   (mapcar #'(lambda (X) (/TRACE-2 X OPTIONS)) FNLIST)
   (/TRACEREPLY))
 
(DEFUN /TRACE-2 (FN OPTIONS)
  (PROG (U FNVAL COUNTNAM TRACECODE BEFORE AFTER CONDITION
         TRACENAME CALLER VARS BREAK FROM_CONDITION VARBREAK TIMERNAM
         ONLYS G WITHIN_CONDITION  DEPTH_CONDITION COUNT_CONDITION
         LETFUNCODE MATHTRACE )
        (if (member FN /TRACENAMES :test #'eq) (/UNTRACE-2 FN NIL))
        (SETQ OPTIONS (OPTIONS2UC OPTIONS))
        (if (AND |$traceDomains| (|isFunctor| FN) (ATOM FN))
            (RETURN (|traceDomainConstructor| FN OPTIONS)))
        (SETQ MATHTRACE (/GETTRACEOPTIONS OPTIONS 'MATHPRINT))
        (if (AND MATHTRACE (NOT (EQL (ELT (PNAME FN) 0) #\$)) (NOT (GENSYMP FN)))
            (if (RASSOC FN |$mapSubNameAlist|)
                (SETQ |$mathTraceList| (CONS FN |$mathTraceList|))
                (|spadThrowBrightly|
                  (format nil "mathprint not available for ~A" FN))))
        (SETQ VARS (/GETTRACEOPTIONS OPTIONS 'VARS))
        (if VARS
            (progn (if (NOT (CDR VARS)) (SETQ VARS 'all) (SETQ VARS (CDR VARS)))
                   (|tracelet| FN VARS)))
        (SETQ BREAK (/GETTRACEOPTIONS OPTIONS 'BREAK))
        (SETQ VARBREAK (/GETTRACEOPTIONS OPTIONS 'VARBREAK))
        (if VARBREAK
            (progn   (if (NOT (CDR VARBREAK)) (SETQ VARS 'all)
                         (SETQ VARS (CDR VARBREAK)))
                     (|breaklet| FN VARS)))
        (if (and (symbolp fn) (not (boundp FN)) (not (fboundp FN)))
            (progn
              (COND ((|isUncompiledMap| FN)
                     (|sayBrightly|
                       (format nil
           "~A must be compiled before it may be traced -- invoke ~A to compile"
                                            FN FN)))
                    ((|isInterpOnlyMap| FN)
                     (|sayBrightly| (format nil
            "~A cannot be traced because it is an interpret-only function" FN)))
                    (T (|sayBrightly| (format nil "~A is not a function" FN))))
              (RETURN NIL)))
        (if (and (symbolp fn) (boundp FN)
		 (|isDomainOrPackage| (SETQ FNVAL (EVAL FN))))
	    (RETURN (|spadTrace| FNVAL OPTIONS)))
        (if (SETQ U (/GETTRACEOPTIONS OPTIONS 'MASK=))
            (MAKEPROP FN '/TRANSFORM (CADR U)))
        (SETQ /TRACENAMES
              (COND ((/GETTRACEOPTIONS OPTIONS 'ALIAS) /TRACENAMES)
                    ((ATOM /TRACENAMES) (LIST FN))
                    ((CONS FN /TRACENAMES))))
        (SETQ TRACENAME
              (COND ((SETQ U (/GETTRACEOPTIONS OPTIONS 'ALIAS))
                     (STRINGIMAGE (CADR U)))
                    (T
                     (COND ((AND |$traceNoisely| (NOT VARS)
                                 (NOT (|isSubForRedundantMapName| FN)))
                            (|sayBrightly|
                             (LIST '|%b| (|rassocSub| FN |$mapSubNameAlist|)
                                   '|%d| "traced"))))
                     (STRINGIMAGE FN))))
        (COND (|$fromSpadTrace|
               (if MATHTRACE (push (INTERN TRACENAME) |$mathTraceList|))
               (SETQ LETFUNCODE `(SETQ |$currentFunction| ,(MKQ FN)))
               (SETQ BEFORE
                     (if (SETQ U (/GETTRACEOPTIONS OPTIONS 'BEFORE))
                         `(progn ,(CADR U) ,LETFUNCODE)
                         LETFUNCODE)))
              (T (SETQ BEFORE
                       (if (SETQ U (/GETTRACEOPTIONS OPTIONS 'BEFORE))
                           (CADR U)))))
        (SETQ AFTER (if (SETQ U (/GETTRACEOPTIONS OPTIONS 'AFTER)) (CADR U)))
        (SETQ CALLER (/GETTRACEOPTIONS OPTIONS 'CALLER))
        (SETQ FROM_CONDITION
              (if (SETQ U (/GETTRACEOPTIONS OPTIONS 'FROM))
                  (LIST 'EQ '|#9| (LIST 'QUOTE (CADR U)))
                  T))
        (SETQ CONDITION
              (if (SETQ U (/GETTRACEOPTIONS OPTIONS 'WHEN)) (CADR U) T))
        (SETQ WITHIN_CONDITION T)
        (COND ((SETQ U (/GETTRACEOPTIONS OPTIONS 'WITHIN))
               (SETQ G (INTERN (STRCONC (PNAME FN) "/" (PNAME (CADR U)))))
               (SET G 0)
               (/TRACE-1
                 (LIST (CADR U))
                 `((WHEN NIL)
                   (BEFORE (SETQ ,G (1+ ,G)))
                   (AFTER (SETQ ,G (1- ,G)))))
               (SETQ WITHIN_CONDITION `(> ,G 0))))
        (SETQ COUNTNAM
              (AND (/GETTRACEOPTIONS OPTIONS 'COUNT)
                   (INTERN (STRCONC TRACENAME ",COUNT"))) )
        (SETQ COUNT_CONDITION
              (COND ((SETQ U (/GETTRACEOPTIONS OPTIONS 'COUNT))
                     (SETQ /COUNTLIST (adjoin TRACENAME /COUNTLIST
					      :test 'equal))
                     (if (AND (CDR U) (integerp (CADR U)))
                         `(cond ((<= ,COUNTNAM ,(CADR U)) t)
                                (t (/UNTRACE-2 ,(MKQ FN) NIL) NIL))
                         t))
                    (T T)))
        (AND (/GETTRACEOPTIONS OPTIONS 'TIMER)
             (SETQ TIMERNAM (INTERN (STRCONC TRACENAME ",TIMER")))
             (SETQ /TIMERLIST (adjoin TRACENAME /TIMERLIST :test 'equal)))
        (SETQ DEPTH_CONDITION
              (if (SETQ U (/GETTRACEOPTIONS OPTIONS 'DEPTH))
                  (if (AND (CDR U) (integerp (CADR U)))
		      (LIST 'LE 'FUNDEPTH (CADR U))
		    (TRACE_OPTION_ERROR 'DEPTH))
                  T))
        (SETQ CONDITION
              (MKPF
                (LIST CONDITION WITHIN_CONDITION FROM_CONDITION COUNT_CONDITION
                      DEPTH_CONDITION )
                'AND))
        (SETQ ONLYS (/GETTRACEOPTIONS OPTIONS 'ONLY))
 
        ;TRACECODE meaning:
        ; 0:        Caller (0,1)           print caller if 1
        ; 1:        Value (0,1)            print value if 1
        ; 2...:     Arguments (0,...,9)    stop if 0; print ith if i; all if 9
        (SETQ TRACECODE
              (if (/GETTRACEOPTIONS OPTIONS 'NT) "000"
                  (PROG (F A V C NL BUF)
                        (SETQ ONLYS (MAPCAR #'COND-UCASE ONLYS))
                        (SETQ F (OR (member 'F ONLYS :test #'eq)
                                    (member 'FULL ONLYS :test #'eq)))
                        (SETQ A (OR F (member 'A ONLYS :test #'eq)
                                    (member 'ARGS ONLYS :test #'eq)))
                        (SETQ V (OR F (member 'V ONLYS :test #'eq)
                                    (member 'VALUE ONLYS :test #'eq)))
                        (SETQ C (OR F (member 'C ONLYS :test #'eq)
                                    (member 'CALLER ONLYS :test #'eq)))
                        (SETQ NL
                              (if A '(#\9)
                                  (mapcan #'(lambda (X)
                                              (if (AND (INTEGERP X)
                                                       (> X 0)
                                                       (< X 9))
                                                  (LIST (FETCHCHAR (STRINGIMAGE X) 0))))
                                          onlys)))
                        (if (NOT (OR A V C NL))
                            (if Caller (return "119") (return "019")))
                        (SETQ NL (APPEND NL '(\0)))
                        (SETQ BUF (GETSTR 12))
                        (SUFFIX (if (or C Caller) #\1 #\0) BUF)
                        (SUFFIX (if V #\1 #\0) BUF)
                        (if A (suffix #\9 BUF)
                            (mapcar #'(lambda (x) (suffix x BUF)) NL))
                        (RETURN BUF))))
        (/MONITOR FN TRACECODE BEFORE AFTER CONDITION TIMERNAM
                  COUNTNAM TRACENAME BREAK )))
 
(DEFUN OPTIONS2UC (L)
  (COND ((NOT L) NIL)
        ((ATOM (CAR L))
         (|spadThrowBrightly|
           (format nil "~A has wrong format for an option" (car L))))
        ((CONS (CONS (LC2UC (CAAR L)) (CDAR L)) (OPTIONS2UC (CDR L))))))
 
(DEFUN COND-UCASE (X) (COND ((INTEGERP X) X) ((UPCASE X))))
 
(DEFUN TRACEOPTIONS (X)
  (COND ((NOT X) NIL)
        ((EQ (CAR X) '/) X)
        ((TRACEOPTIONS (CDR X)))))
 
(defmacro |/untrace| (&rest L) `', (/UNTRACE-0 L))
 
(defmacro /UNTRACE (&rest L) `', (/UNTRACE-0 L))
 
(defmacro /U (&rest L) `', (/UNTRACE-0 L))
 
(DEFUN /UNTRACE-0 (L)
    (PROG (OPTIONL OPTIONS FNL)
      (if (member '? L :test #'eq) (RETURN (OBEY "EXEC NORMEDIT TRACE TELL")))
      (SETQ OPTIONL (/OPTIONS L))
      (SETQ FNL (TRUNCLIST L OPTIONL))
      (SETQ OPTIONS (if OPTIONL (CAR OPTIONL)))
      (RETURN (/UNTRACE-1 FNL OPTIONS))))
 
(define-function '|/UNTRACE,0| #'/UNTRACE-0)
 
(defun /UNTRACE-1 (L OPTIONS)
  (cond
    ((NOT L)
     (if (ATOM /TRACENAMES)
         NIL
         (mapcar #'(lambda (u) (/UNTRACE-2 (/UNTRACE-REDUCE U) OPTIONS))
                 (APPEND /TRACENAMES NIL))))
    ((mapcar #'(lambda (x) (/UNTRACE-2 X OPTIONS)) L)))
  (/TRACEREPLY))
 
(DEFUN /UNTRACE-REDUCE (X) (if (ATOM X) X (first X))) ; (CAR X) is now a domain
 
(DEFUN /UNTRACE-2 (X OPTIONS)
 (let (u y)
  (COND ((AND (|isFunctor| X) (ATOM X))
         (|untraceDomainConstructor| X))
        ((OR (|isDomainOrPackage| (SETQ U X))
             (and (symbolp X) (boundp X)
		  (|isDomain| (SETQ U (EVAL X)))))
         (|spadUntrace| U OPTIONS))
        ((EQCAR OPTIONS 'ALIAS)
           (if |$traceNoisely|
               (|sayBrightly| (LIST '|%b| (CADR OPTIONS) '|%d| '**untraced)))
           (SETQ /TIMERLIST
		 (REMOVE (STRINGIMAGE (CADR OPTIONS)) /TIMERLIST :test 'equal))
           (SETQ /COUNTLIST
		 (REMOVE (STRINGIMAGE (CADR OPTIONS)) /COUNTLIST :test 'equal))
           (SETQ |$mathTraceList|
		 (REMOVE (CADR OPTIONS) |$mathTraceList| :test 'equal))
           (UNEMBED X))
        ((AND (NOT (MEMBER X /TRACENAMES))
              (NOT (|isSubForRedundantMapName| X)))
         (|sayBrightly|
           (LIST
             '|%b|
             (|rassocSub| X |$mapSubNameAlist|)
             '|%d|
             "not traced")))
        (T (SETQ /TRACENAMES (REMOVE X /TRACENAMES :test 'equal))
           (SETQ |$mathTraceList|
                 (REMOVE (if (STRINGP X) (INTERN X) X) |$mathTraceList|))
           (SETQ |$letAssoc| (DELASC X |$letAssoc|))
           (setq Y (if (IS_GENVAR X) (|devaluate| (EVAL X)) X))
           (SETQ /TIMERLIST (REMOVE (STRINGIMAGE Y) /TIMERLIST :test 'equal))
           (SET (INTERN (STRCONC Y ",TIMER")) 0)
           (SETQ /COUNTLIST (REMOVE (STRINGIMAGE Y) /COUNTLIST :test 'equal))
           (SET (INTERN (STRCONC Y ",COUNT")) 0)
           (COND ((AND |$traceNoisely| (NOT (|isSubForRedundantMapName| Y)))
                  (|sayBrightly|
                    (LIST '|%b| (|rassocSub| Y |$mapSubNameAlist|)
                  '|%d| "untraced"))))
           (UNEMBED X)))))
 
  ;; the following is called by |clearCache|
(define-function '/UNTRACE\,2 #'/UNTRACE-2)
 
(DEFUN MONITOR-PRINVALUE (VAL NAME)
  (let (u)
    (COND ((setq U (GET NAME '/TRANSFORM))
           (COND
             ((EQCAR U '&)
	      (PRINC "//" CURSTRM) (PRIN1 VAL CURSTRM) (TERPRI CURSTRM))
	     (T (PRINC "! " CURSTRM)
		(PRIN1 (EVAL (SUBST (MKQ VAL) '* (CAR U))) CURSTRM)
		(TERPRI CURSTRM)) ))
          (T
	   (PRINC ": " CURSTRM)
           (COND ((NOT (SMALL-ENOUGH VAL)) (|F,PRINT-ONE| VAL CURSTRM))
                 (/PRETTY (PRETTYPRINT VAL CURSTRM))
                 (T (COND (|$mathTrace| (TERPRI)))
		    (PRINMATHOR0 VAL CURSTRM)))))))
 
(DEFUN MONITOR-BLANKS (N) (PRINC (MAKE-FULL-CVEC N " ") CURSTRM))
 
(DEFUN MONITOR-EVALBEFORE (X) (EVALFUN (MONITOR-EVALTRAN X NIL)) X)
 
(DEFUN MONITOR-EVALAFTER (X) (EVALFUN (MONITOR-EVALTRAN X 'T)))
 
(DEFUN MONITOR-EVALTRAN (X FG)
  (if (HAS_SHARP_VAR X) (MONITOR-EVALTRAN1 X FG) X))
 
(define-function 'MONITOR\,EVALTRAN #'MONITOR-EVALTRAN)
 
(DEFUN MONITOR-EVALTRAN1 (X FG)
  (let (n)
    (COND
      ((SETQ N (|isSharpVarWithNum| X)) (MONITOR-GETVALUE N FG))
      ((ATOM X) X)
      ((CONS (MONITOR-EVALTRAN1 (CAR X) FG)
             (MONITOR-EVALTRAN1 (CDR X) FG))))))
 
(DEFUN HAS_SHARP_VAR (X)
  (COND ((AND (ATOM X) (IS_SHARP_VAR X)) 'T)
        ((ATOM X) NIL)
        ((OR (HAS_SHARP_VAR (CAR X)) (HAS_SHARP_VAR (CDR X))))))
 
(DEFUN IS_SHARP_VAR (X)
  (AND (IDENTP X)
       (EQL (ELT (PNAME X) 0) #\#)
       (INTEGERP (lisp:parse-integer (symbol-name X) :start 1))))
 
(DEFUN MONITOR-GETVALUE (N FG)
  (COND ((= N 0)
         (if FG
             (MKQ /VALUE)
             (|spadThrowBrightly| "cannot ask for value before execution")))
        ((= N 9) (MKQ /CALLER))
        ((<= N (SIZE /ARGS)) (MKQ (ELT /ARGS (1- N))))
        ((|spadThrowBrightly| (LIST 'function '|%b| /NAME '|%d|
                              "does not have" '|%b| N '|%d| "arguments")))))
 
(DEFUN MONITOR-PRINARGS (L CODE /TRANSFORM)
  (let (N)
    (cond
      ((= (digit-char-p (elt CODE 2)) 0) NIL)
      ((= (digit-char-p (elt CODE 2)) 9)
       (cond
         (/TRANSFORM
           (mapcar
             #'(lambda (x y)
                 (COND ((EQ Y '*)
			(PRINC "\\ " CURSTRM)
                        (MONITOR-PRINT X CURSTRM))
                       ((EQ Y '&)
                        (PRINC "\\\\" CURSTRM)
                        (TERPRI CURSTRM)
                        (PRINT X CURSTRM))
                       ((NOT Y) (PRINC "! " CURSTRM))
                       (T
			(PRINC "! " CURSTRM)
                        (MONITOR-PRINT
                          (EVAL (SUBST (MKQ X) '* Y)) CURSTRM))))
	    L (cdr /transform)))
	 (T (PRINC ": " CURSTRM)
            (COND ((NOT (ATOM L))
                   (if |$mathTrace| (TERPRI CURSTRM))
                   (MONITOR-PRINT (CAR L) CURSTRM) (SETQ L (CDR L))))
            (mapcar #'monitor-printrest L))))
      ((do ((istep 2 (+ istep 1))
            (k (maxindex code)))
	   ((> istep k) nil)
        (when (not (= 0 (SETQ N (digit-char-p (elt CODE ISTEP)))))
         (PRINC "\\" CURSTRM)
         (PRINMATHOR0 N CURSTRM)
         (PRINC ": " CURSTRM)
         (MONITOR-PRINARGS-1 L N)))))))
 
(DEFUN MONITOR-PRINTREST (X)
  (COND ((NOT (SMALL-ENOUGH X))
         (PROGN (TERPRI)
                (MONITOR-BLANKS (1+ /DEPTH))
                (PRINC "\\" CURSTRM)
                (PRINT X CURSTRM)))
        ((PROGN (if (NOT |$mathTrace|) (PRINC "\\" CURSTRM))
                (COND (/PRETTY (PRETTYPRINT X CURSTRM))
                      ((PRINMATHOR0 X CURSTRM)))))))
 
(DEFUN MONITOR-PRINARGS-1 (L N)
  (COND ((OR (ATOM L) (LESSP N 1)) NIL)
        ((EQ N 1) (MONITOR-PRINT (CAR L) CURSTRM))
        ((MONITOR-PRINARGS-1 (CDR L) (1- N)))))
 
(DEFUN MONITOR-PRINT (X CURSTRM)
  (COND ((NOT (SMALL-ENOUGH X)) (|F,PRINT-ONE| X CURSTRM))
        (/PRETTY (PRETTYPRINT X CURSTRM))
        ((PRINMATHOR0 X CURSTRM))))
 
(DEFUN PRINMATHOR0 (X CURSTRM)
  (if |$mathTrace| (|maprinSpecial| (|outputTran| X) /DEPTH 80)
      (PRIN0 X CURSTRM)))
 
(DEFUN SMALL-ENOUGH (X) (if /TRACESIZE (SMALL-ENOUGH-COUNT X 0 /TRACESIZE) t))
 
(DEFUN SMALL-ENOUGH-COUNT (X N M)
  "Returns number if number of nodes < M otherwise nil."
  (COND ((< M N) NIL)
        ((VECP X)
         (do ((i 0 (1+ i)) (k (maxindex x)))
             ((> i k) n)
           (if (NOT (SETQ N (SMALL-ENOUGH-COUNT (ELT X I) (1+ N) M)))
               (RETURN NIL))))
        ((ATOM X) N)
        ((AND (SETQ N (SMALL-ENOUGH-COUNT (CAR X) (1+ N) M))
              (SMALL-ENOUGH-COUNT (CDR X) N M)))))
 
(DEFUN /OPTIONS (X)
  (COND ((ATOM X) NIL)
        ((OR (ATOM (CAR X)) (|isFunctor| (CAAR X))) (/OPTIONS (CDR X)))
        (X)))
 
(DEFUN /GETOPTION (L OPT) (KDR (/GETTRACEOPTIONS L OPT)))
 
(DEFUN /GETTRACEOPTIONS (L OPT)
  (COND ((ATOM L) NIL)
        ((EQ (KAR (CAR L)) OPT) (CAR L))
        ((/GETTRACEOPTIONS (CDR L) OPT))))
 
(DEFMACRO /TRACELET (&rest L) `',
  (PROG (OPTIONL FNL)
        (if (member '? L :test #'eq)
            (RETURN (OBEY (if (EQ (SYSID) 1)
                              "EXEC NORMEDIT TRACELET TELL"
                              "$COPY AZ8F:TRLET.TELL")) ))
        (SETQ OPTIONL (/OPTIONS L))
        (SETQ FNL (TRUNCLIST L OPTIONL))
        (RETURN (/TRACELET-1 FNL OPTIONL))))
 
(DEFUN /TRACELET-1 (FNLIST OPTIONL)
  (mapcar #'(lambda (x) (/tracelet-2 x optionl)) fnlist)
  (/TRACE-1 FNLIST OPTIONL)
  (TRACELETREPLY))
 
(DEFUN TRACELETREPLY ()
   (if (ATOM /TRACELETNAMES) '(none tracelet)
       (APPEND /TRACELETNAMES (LIST 'tracelet))))
 
(DEFUN /TRACELET-2 (FN OPTIONL &AUX ($TRACELETFLAG T))
  (/D-1 (CONS FN OPTIONL) 'COMP NIL NIL)
  (SETQ /TRACELETNAMES
        (if (ATOM /TRACELETNAMES) (LIST FN) (CONS FN /TRACELETNAMES)))
  FN)
 
(defmacro /TRACE-LET (A B)
  `(PROG1 (SPADLET ,A ,B)
          . ,(mapcar #'(lambda (x) `(/tracelet-print ',x ,x))
                     (if (ATOM A) (LIST A) A))))
 
(defun /TRACELET-PRINT (X Y &AUX (/PRETTY 'T))
  (PRINC (STRCONC (PNAME X) ": ") *terminal-io*)
  (MONITOR-PRINT Y *terminal-io*))
 
(defmacro /UNTRACELET (&rest L) `',
  (COND
    ((NOT L)
     (if (ATOM /TRACELETNAMES) NIL (EVAL (CONS '/UNTRACELET /TRACELETNAMES))))
    ((mapcar #'/untracelet-1 L))
    ((TRACELETREPLY))))
 
(DEFUN /UNTRACELET-1 (X)
  (COND
    ((NOT (MEMBER X /TRACELETNAMES))
     (PROGN (PRINT (STRCONC (PNAME X) " not tracelet")) (TERPRI)))
    ((PROGN
       (/UNTRACELET-2 X)
       (/D-1 (LIST X) 'COMP NIL NIL)))))
 
(DEFUN /UNTRACELET-2 (X)
  (SETQ /TRACELETNAMES (REMOVE X /TRACELETNAMES))
  (PRINT (STRCONC (PNAME X) " untracelet")) (TERPRI))
 
(defmacro /EMBED (&rest L) `',
 (COND ((NOT L) (/EMBEDREPLY))
       ((member '? L :test #'eq) (OBEY "EXEC NORMEDIT EMBED TELL"))
       ((EQ 2 (LENGTH L)) (/EMBED-1 (CAR L) (CADR L)))
       ((MOAN "IMPROPER USE OF /EMBED"))))
 
(defmacro /UNEMBED (&rest L) `',
  (COND ((NOT L)
         (if (ATOM (EMBEDDED)) NIL
             (mapcar #'unembed (embedded)))
         (SETQ /TRACENAMES NIL)
         (SETQ /EMBEDNAMES NIL))
        ((mapcar #'/unembed-1 L)
         (SETQ /TRACENAMES (S- /TRACENAMES L)) ))
  (/EMBEDREPLY))
 
(defun /UNEMBED-Q (X)
  (COND
    ((NOT (MEMBER X /EMBEDNAMES))
     (ERROR (STRCONC (PNAME X) " not embeded")))
    ((PROGN
       (SETQ /EMBEDNAMES (REMOVE X /EMBEDNAMES))
       (UNEMBED X)))))
 
(defun /UNEMBED-1 (X)
  (COND
    ((NOT (MEMBER X /EMBEDNAMES))
     (|sayBrightly| (LIST '|%b| (PNAME X) '|%d| "not embeded" '|%l|)))
    ((PROGN
       (SETQ /EMBEDNAMES (REMOVE X /EMBEDNAMES))
       (|sayBrightly| (LIST '|%b| (PNAME X) '|%d| "unembeded" '|%l|))
       (UNEMBED X)))  ))
 
 
 
(defun /MONITOR (&rest G5)
  (PROG (G1 G4 TRACECODE BEFORE AFTER CONDITION
         TIMERNAM COUNTNAM TRACENAME BREAK)
        (dcq (G1 TRACECODE BEFORE AFTER CONDITION TIMERNAM COUNTNAM TRACENAME BREAK) G5)
        (SETQ G4 (macro-function G1))
        (SETQ TRACECODE (OR TRACECODE "119"))
        (if COUNTNAM (SET COUNTNAM 0))
        (if TIMERNAM (SET TIMERNAM 0))
        (EMBED
          G1
          (LIST
            (if G4 'MLAMBDA 'LAMBDA)
            '(&rest G6)
            (LIST
              '/MONITORX
              (QUOTE G6)
              G1
              (LIST
                'QUOTE
                (LIST
                  TRACENAME (if G4 'MACRO) TRACECODE
                  COUNTNAM TIMERNAM BEFORE AFTER
                  CONDITION BREAK |$tracedModemap| ''T)))))
        (RETURN G1)))
 
(defun /MONITORX (/ARGS FUNCT OPTS &AUX NAME TYPE TRACECODE COUNTNAM TIMERNAM
                        BEFORE AFTER CONDITION BREAK TRACEDMODEMAP
                        BREAKCONDITION)
            (declare (special /ARGS))
  (DCQ (NAME TYPE TRACECODE COUNTNAM TIMERNAM BEFORE AFTER CONDITION BREAK TRACEDMODEMAP BREAKCONDITION) OPTS)
  (|stopTimer|)
  (PROG (C V A NAME1 CURSTRM EVAL_TIME INIT_TIME NOT_TOP_LEVEL
         (/DEPTH (if (and (BOUNDP '/DEPTH) (numberp /depth)) (1+ /DEPTH) 1))
         (|depthAlist| (if (BOUNDP '|depthAlist|) (COPY-TREE |depthAlist|) NIL))
         FUNDEPTH NAMEID YES (|$tracedSpadModemap| TRACEDMODEMAP) (|$mathTrace| NIL)
	 /caller /name /value /breakcondition curdepth)
    (declare (special curstrm /depth fundepth |$tracedSpadModemap| |$mathTrace|
		      /caller /name /value /breakcondition |depthAlist|))
        (SETQ /NAME NAME)
        (SETQ NAME1 (PNAME (|rassocSub| (INTERN NAME) |$mapSubNameAlist|)))
        (SETQ /BREAKCONDITION BREAKCONDITION)
        (SETQ /CALLER (|rassocSub| (WHOCALLED 6) |$mapSubNameAlist|))
        (if (NOT (STRINGP TRACECODE))
            (MOAN "set TRACECODE to \'1911\' and restart"))
        (SETQ C (digit-char-p (elt TRACECODE 0))
              V (digit-char-p (elt TRACECODE 1))
              A (digit-char-p (elt TRACECODE 2)))
        (if COUNTNAM (SET COUNTNAM (1+ (EVAL COUNTNAM))))
        (SETQ NAMEID (INTERN NAME))
        (SETQ NOT_TOP_LEVEL (ASSOC NAMEID |depthAlist| :test #'eq))
        (if (NOT NOT_TOP_LEVEL)
            (SETQ |depthAlist| (CONS (CONS NAMEID 1) |depthAlist|))
            (RPLACD NOT_TOP_LEVEL (1+ (CDR NOT_TOP_LEVEL))))
        (SETQ FUNDEPTH (CDR (ASSOC NAMEID |depthAlist| :test #'eq)))
        (SETQ CONDITION (MONITOR-EVALTRAN CONDITION NIL))
        (SETQ YES (EVALFUN CONDITION))
        (if (member NAMEID |$mathTraceList| :test #'eq)
            (SETQ |$mathTrace| T))
        (if (AND YES |$TraceFlag|)
            (PROG (|$TraceFlag|)
                  (SETQ CURSTRM *TERMINAL-IO*)
                  (if (EQUAL TRACECODE "000") (RETURN NIL))
                  (TAB 0 CURSTRM)
                  (MONITOR-BLANKS (1- /DEPTH))
                  (PRIN0 FUNDEPTH CURSTRM)
                  (|sayBrightlyNT| (LIST "<enter" '|%b|
                                         NAME1 '|%d|) CURSTRM)
                  (COND ((EQ 0 C) NIL)
                        ((EQ TYPE 'MACRO)
                         (PRINT " expanded" CURSTRM))
                        (T (PRINT " from " CURSTRM)
                           (PRIN0 /CALLER CURSTRM)))
                  (MONITOR-PRINARGS
                    (if (SPADSYSNAMEP NAME)
                        (NREVERSE (REVERSE  (|coerceTraceArgs2E|
                                              (INTERN NAME1)
                                              (INTERN NAME)
                                              /ARGS)))
                        (|coerceTraceArgs2E| (INTERN NAME1)
                                             (INTERN NAME) /ARGS))
                    TRACECODE
                    (GET (INTERN NAME) '/TRANSFORM))
                  (if (NOT |$mathTrace|) (TERPRI CURSTRM))))
        (if before (MONITOR-EVALBEFORE BEFORE))
        (if (member '|before| BREAK :test #'eq)
            (|break| (LIST "Break on entering" '|%b| NAME1 '|%d| ":")))
        (if TIMERNAM (SETQ INIT_TIME (|startTimer|)))
        (SETQ /VALUE (if (EQ TYPE 'MACRO) (MDEFX FUNCT /ARGS)
                         (APPLY FUNCT /ARGS)))
        (|stopTimer|)
        (if TIMERNAM (SETQ EVAL_TIME (- (|clock|) INIT_TIME)) )
        (if (AND TIMERNAM (NOT NOT_TOP_LEVEL))
            (SET TIMERNAM (+ (EVAL TIMERNAM) EVAL_TIME)))
        (if AFTER (MONITOR-EVALAFTER AFTER))
        (if (AND YES |$TraceFlag|)
            (PROG (|$TraceFlag|)
                  (if (EQUAL TRACECODE "000") (GO SKIP))
                  (TAB 0 CURSTRM)
                  (MONITOR-BLANKS (1- /DEPTH))
                  (PRIN0 FUNDEPTH CURSTRM)
                  (|sayBrightlyNT| (LIST ">exit " '|%b| NAME1 '|%d|) CURSTRM)
                  (COND (TIMERNAM
                         (|sayBrightlyNT| '\( CURSTRM)
                         (|sayBrightlyNT| (/ EVAL_TIME 60.0) CURSTRM)
                         (|sayBrightlyNT| '\ sec\) CURSTRM) ))
                  (if (EQ 1 V)
                      (MONITOR-PRINVALUE
                        (|coerceTraceFunValue2E|
                          (INTERN NAME1) (INTERN NAME) /VALUE)
                        (INTERN NAME1)))
                  (if (NOT |$mathTrace|) (TERPRI CURSTRM))
               SKIP))
        (if (member '|after| BREAK :test #'eq)
            (|break| (LIST "Break on exiting" '|%b| NAME1 '|%d| ":")))
        (|startTimer|)
        (RETURN /VALUE)))
 
; Functions to run a timer for tracing
; It avoids timing the tracing function itself by turning the timer
; on and off
 
(defun |startTimer| ()
    (SETQ $delay (PLUS $delay (DIFFERENCE (TEMPUS-FUGIT) |$oldTime|)))
    (SETQ |$timerOn| 'T)
    (|clock|))
 
(defun |stopTimer| () (SETQ |$oldTime| (TEMPUS-FUGIT) |$timerOn| NIL) (|clock|))
 
(defun |clock| ()
  (if |$timerOn| (- (TEMPUS-FUGIT) $delay) (- |$oldTime| $delay)))
 
; Functions to trace/untrace a BPI; use as follows:
; To trace a BPI-value <bpi>, evaluate (SETQ <name> (BPITRACE <bpi>))
; To later untrace <bpi>, evaluate (BPITRACE <name>)
 
(defun PAIRTRACE (PAIR ALIAS)
   (RPLACA PAIR (BPITRACE (CAR PAIR) ALIAS )) NIL)
 
(defun BPITRACE (BPI ALIAS &optional OPTIONS)
  (SETQ NEWNAME (GENSYM))
  (IF (identp bpi) (setq bpi (symbol-function bpi)))
  (SET NEWNAME BPI)
  (SETF (symbol-function NEWNAME) BPI)
  (/TRACE-0 (APPEND (LIST NEWNAME (LIST 'ALIAS ALIAS)) OPTIONS))
  NEWNAME)
 
(defun BPIUNTRACE (X ALIAS) (/UNTRACE-0 (LIST X (LIST 'ALIAS ALIAS))))
 
(defun SPADSYSNAMEP (STR)
  (let (n i j)
    (AND (SETQ N (MAXINDEX STR))
         (SETQ I (position #\. STR :start 1))
         (SETQ J (position #\, STR :start (1+ I)))
         (do ((k (1+ j) (1+ k)))
             ((> k n) t)
           (if (not (digitp (elt str k))) (return nil))))))
 
; **********************************************************************
;            Utility functions for Tracing Package
; **********************************************************************
 
(MAKEPROP '|coerce| '/TRANSFORM '(& & *))
(MAKEPROP '|comp| '/TRANSFORM '(& * * &))
(MAKEPROP '|compIf| '/TRANSFORM '(& * * &))
 
;  by having no transform for the 3rd argument, it is simply not printed
 
(MAKEPROP '|compFormWithModemap| '/TRANSFORM '(& * * & *))
 
(defun UNVEC (X)
  (COND ((REFVECP X) (CONS '$ (VEC_TO_TREE X)))
        ((ATOM X) X)
        ((CONS (UNVEC (CAR X)) (UNVEC (CDR X))))))
 
(defun DROPENV (X) (AND X (LIST (CAR X) (CADR X))))
 
(defun SHOWBIND (E)
  (do ((v e (cdr v))
       (llev 1 (1+ llev)))
      ((not v))
    (PRINT (LIST "LAMBDA LEVEL" LLEV))
    (do ((w (car v) (cdr w))
         (clev 1 (1+ clev)))
        ((not w))
      (PRINT (LIST "CONTOUR LEVEL" CLEV))
      (PRINT (mapcar #'car (car W))))))
 
(defun lisp-break-from-axiom (&rest ignore) 
    (boot::|handleLispBreakLoop| boot::|$BreakMode|))

@
\subsection{interrupt}
A "resumable" break loop for use in trace etc. Unfortunately this
only works for CCL. We need to define a Common Lisp version. For
now the function is defined but does nothing.
<<*>>=
(defun interrupt (&rest ignore))

; NAME:	   Scratchpad Package
; PURPOSE: This is an initialization and system-building file for Scratchpad.

;;; Common  Block

(defvar |$UserLevel| '|development|)
(defvar |$preserveSystemLisplib| t "if nil finalizeLisplib does MA REP")
(defvar |$incrementalLisplibFlag| nil "checked in compDefineLisplib")
(defvar |$reportInstantiations| nil)
(defvar |$reportEachInstantiation| nil)
(defvar |$reportCounts| nil)
(defvar |$CategoryDefaults| nil)
(defvar |$compForModeIfTrue| nil "checked in compSymbol")
(defvar |$functorForm| nil "checked in addModemap0")
(defvar |$formalArgList| nil "checked in compSymbol")
(defvar |$newComp| nil "use new compiler")
(defvar |$newCompCompare| nil "compare new compiler with old")
(defvar |$compileOnlyCertainItems| nil "list of functions to compile")
(defvar |$newCompAtTopLevel| nil "if t uses new compiler")
(defvar |$doNotCompileJustPrint| nil "switch for compile")
(defvar |$PrintCompilerMessageIfTrue| t)
(defvar |$Rep| '|$Rep| "should be bound to gensym? checked in coerce")
;; the following initialization of $ must not be a defvar
;; since that make $ special
(setq $ '$) ;; used in def of Ring which is Algebra($)
(defvar |$scanIfTrue| nil "if t continue compiling after errors")
(defvar |$Representation| nil "checked in compNoStacking")
(defvar |$definition| nil "checked in DomainSubstitutionFunction")
(defvar |$Attributes| nil "global attribute list used in JoinInner")
(defvar |$env| nil "checked in isDomainValuedVariable")
(defvar |$e| nil "checked in isDomainValuedVariable")
(defvar |$getPutTrace| nil)
(defvar |$specialCaseKeyList| nil "checked in optCall")
(defvar |$formulaFormat| nil "if true produce script formula output")
(defvar |$texFormat| nil "if true produce tex output")
(defvar |$fortranFormat| nil "if true produce fortran output")
(defvar |$algebraFormat| t "produce 2-d algebra output")
(defvar |$kernelWarn| NIL "")
(defvar |$kernelProtect| NIL "")
(defvar |$HiFiAccess| nil "if true maintain history file")
(defvar |$mapReturnTypes| nil)
(defvar /TRACENAMES NIL)

(defvar INPUTSTREAM t "bogus initialization for now")

(defvar |boot-NewKEY| NIL)
(setq /WSNAME 'NOBOOT)
(DEFVAR _ '&)
(setq $linestack 'begin_unit)
(setq $maxlinenumber 0)
(defvar /EDIT-FM 'A1)
(defvar /EDIT-FT 'SPAD)
(defvar /RELEASE '"UNKNOWN")
(defvar /rp '/RP)
(defvar APLMODE NIL)
(defvar error-print)
(defvar ind)
(defvar INITCOLUMN 0)
(defvar JUNKTOKLIST '(FOR IN AS INTO OF TO))
(defvar LCTRUE '|true|)
(defvar m-chrbuffer)
(defvar m-chrindex)
(defvar MARG 0 "Margin for testing by ?OP")
(defvar NewFlag)
(defvar ParseMode)
(defvar RLGENSYMFG NIL)
(defvar RLGENSYMLST NIL)
(defvar S-SPADTOK 'SPADSYSTOK)
(defvar sortpred)
(defvar SPADSYSKEY '(EOI EOL))
(defvar STAKCOLUMN -1)
(setq XTOKENREADER 'SPADTOK)
(defvar xtrans '|boot-new|)
(defvar |$IOAlist| '((|%i| . (|gauss| 0 1))))
(setq |$useBFasDefault| T)
(defvar |New-LEXPR|)
(defvar |NewFLAG| t)
(defvar |uc| 'UC)
(setq |$lisp2lispRenameAssoc| '((RETURN . |return|)
	  (EXIT . |exit|)
	  (AND . |and|)
	  (OR . |or|)
	  (NOT . |not|)
	  (IS . |is|)
	  (CAR . |first|)
	  (CDR . |rest|)
	  (EQUAL . =)
	  (NEQUAL . ^=)
	  (PLUS . +)
	  (TIMES . *)
	  (QUOTIENT . /)
	  (EXPT . **)
	  (SUBST . |substitute|)
	  (NULL . ^)
	  (ATOM . |atom|)
	  (NULL . |null|)
	  ))

(setq |$spadOpList|
	'(\.\. - = * / ** + - \< \> \<= \>= ^= \# \' ^
	  \: \:\: \. =\> == ==\> \| \:=))

(DEFUN INTEGER-BIT (N I) (LOGBITP I N))

(DEFUN /TRANSPAD (X)
  (PROG (proplist)
	(setq proplist (LIST '(FLUID . |true|)
			     (CONS '|special|
				   (COPY-TREE |$InitialDomainsInScope|))))
	(SETQ |$tripleCache| NIL)
	(SETQ |$InteractiveFrame|
	      (|addBinding| '|$DomainsInScope| proplist
			  (|addBinding| '|$Information| NIL
				      (COPY-TREE |$InitialModemapFrame|))))
	(RETURN (PROGN (S-PROCESS X) NIL))))

(DEFUN /TRANSBOOT (X) (S-PROCESS X) NIL)

(DEFUN /TRANSNBOOT (X) (S-PROCESS X) NIL)

 ;; NIL needed below since END\_UNIT is not generated by current parser
(defun |isTokenDelimiter| () (MEMBER (CURRENT-SYMBOL) '(\) END\_UNIT NIL)))

(defun |traceComp| ()
  (SETQ |$compCount| 0)
  (EMBED '|comp|
     '(LAMBDA (X Y Z)
	 (PROG (U)
	       (SETQ |$compCount| (1+ |$compCount|))
	       (SETQ |yesOrNo| (if (SETQ U (|comp| X Y Z))
				   (if (EQUAL (SECOND U) Y) '|yes| (SECOND U))
				 ('T '|no|)))
	       (|sayBrightly| (CONS (MAKE-FULL-CVEC |$compCount| " ")
				    (LIST X " --> " Y '|%b| |yesOrNo| '|%d|)))
	       (SETQ |$compCount| (1- |$compCount|))
	       (RETURN U)  )))
  (|comp| $x $m $f)
  (UNEMBED '|comp|))

(defun READ-SPAD (FN FM TO)
  (LET ((proplist
	  (LIST '(FLUID . |true|)
		(CONS '|special| (COPY-TREE |$InitialDomainsInScope|)))))
    (SETQ |$InteractiveFrame|
	  (|addBinding| '|$DomainsInScope| proplist
		      (|addBinding| '|$Information| NIL
				  (|makeInitialModemapFrame|))))
    (READ-SPAD0 FN 'SPAD FM TO)))

(defun READ-INPUT (FN FM TO) (READ-SPAD0 FN 'INPUT FM TO))

(defun READ-SPAD0 (FN FT FM TO)
  (let (($newspad t)) (READ-SPAD1 FN FT FM TO)))

(defun READ-SPAD-1 () (|New,ENTRY,1|))

(defun BOOT-LEXPR () (SETQ $BOOT 'T) (SPAD-LEXPR1))

(defun NBOOT-LEXPR () (SETQ $NBOOT 'T) (SPAD-LEXPR1))

(defun UNCONS (X)
  (COND ((ATOM X) X)
	((EQCAR X 'CONS) (CONS (SECOND X) (UNCONS (THIRD X))))
	(T (ERROR "UNCONS"))))

(defun OPTIMIZE\&PRINT (X) (PRETTYPRINT (/MDEF X)))

(defun SPAD-PRINTTIME (A B)
  (let (c msg)
    (setq C (+ A B))
    (setq MSG (STRCONC "(" (STRINGIMAGE A) " + " (STRINGIMAGE B)
		       " = " (STRINGIMAGE C) " MS.)"))
    (PRINT (STRCONC (STRINGPAD "" (DIFFERENCE 80 (SIZE MSG))) MSG))))

(defun SPAD-MODETRAN (X) (D-TRAN X))

(defun SPAD-MDTR-1 (X)
  (COND
    ((ATOM X) (LIST (LIST X)))
    ((EQCAR X 'LIST) (SPAD-MDTR-2 (CDR X)))
    (T (CROAK "MODE TRANSFORM ERROR"))))

(defun SPAD-MDTR-2 (L)
  (COND
    ((NOT L) L)
    ((ATOM (FIRST L))
     (COND
       ((MEMBER (FIRST L) $DOMVAR) (FIRST L))
       (T (CONS (LIST (LIST (FIRST L))) (SPAD-MDTR-2 (CDR L))))	 ))
    (T (CONS (FIRST L) (SPAD-MDTR-2 (CDR L))))))

(defun SPAD-EVAL (X)
  (COND ((ATOM X) (EVAL X))
	((CONS (FIRST X) (MAPCAR #'SPAD-EVAL (CDR X))))))

;************************************************************************
;	  SYSTEM COMMANDS
;************************************************************************

(defun CLEARDATABASE () (OBEY "ERASE MODEMAP DATABASE"))

(defun erase (FN FT)
  (OBEY (STRCONC "ERASE " (STRINGIMAGE FN) " " (STRINGIMAGE FT))))

(defun READLISP (UPPER_CASE_FG)
  (let (v expr val )
    (setq EXPR (READ-FROM-STRING
		  (IF UPPER_CASE_FG (string-upcase (line-buffer CURRENT-LINE))
		      (line-buffer CURRENT-LINE))
		  t nil :start (Line-CURRENT-INDEX CURRENT-LINE)))
    (VMPRINT EXPR)
    (setq VAL ((LAMBDA (|$InteractiveMode|)  (EVAL EXPR)) NIL))
    (FORMAT t "~&VALUE = ~S" VAL)
    (TERSYSCOMMAND)))

(defun TERSYSCOMMAND ()
  (FRESH-LINE)
  (SETQ CHR 'ENDOFLINECHR)
  (SETQ TOK 'END_UNIT)
  (|spadThrow|))

(defun /READ (L Q)
;  (SETQ /EDIT-FN (OR (KAR L) /EDIT-FN))
;  (SETQ /EDIT-FT (OR (KAR (KDR L)) 'INPUT))
;  (SETQ /EDIT-FM (OR (KAR (KDR (KDR L))) '*))
;  (SETQ /EDITFILE (LIST /EDIT-FN /EDIT-FT /EDIT-FM))
  (SETQ /EDITFILE L)
  (COND
    (Q	(/RQ))
    ('T (/RF)) )
  (FLAG |boot-NewKEY| 'KEY)
  (|terminateSystemCommand|)
  (|spadPrompt|))

(defun /EDIT (L)
  (SETQ /EDITFILE L)
  (/EF)
  (|terminateSystemCommand|)
  (|spadPrompt|))

(defun /COMPINTERP (L OPTS)
  (SETQ /EDITFILE (/MKINFILENAM L))
  (COND ((EQUAL OPTS "rf") (/RF))
	((EQUAL OPTS "rq") (/RQ))
	('T (/RQ-LIB)))
  (|terminateSystemCommand|)
  (|spadPrompt|))

(defun CPSAY (X) (let (n) (if (EQ 0 (setq N (OBEY X))) NIL (PRINT N))))

(defun /FLAG (L)
  (MAKEPROP (FIRST L) 'FLAGS (LET ((X (UNION (CDR L)))) (GET (FIRST L) 'FLAGS)))
  (SAY (FIRST L) " has flags: " X)
  (TERSYSCOMMAND))

(defun |fin| ()
  (SETQ *EOF* 'T)
  (THROW 'SPAD_READER NIL))


(defun STRINGREST (X) (if (EQ (SIZE X) 1) (make-string 0) (SUBSTRING X 1 NIL)))

(defun STREAM2UC (STRM)
  (LET ((X (ELT (LASTATOM STRM) 1))) (SETELT X 0 (LC2UC (ELT X 0)))))

(defun NEWNAMTRANS (X)
  (COND
    ((IDENTP X) (COND ( (GET X 'NEWNAM) (GET X 'NEWNAM)) ('T X)))
    ((STRINGP X) X)
    ((*VECP X) (MAPVWOC X (FUNCTION NEWNAMTRANS)))
    ((ATOM X) X)
    ((EQCAR X 'QUOTE))
    (T (CONS (NEWNAMTRANS (FIRST X)) (NEWNAMTRANS (CDR X))))))

(defun GP2COND (L)
  (COND ((NOT L) (ERROR "GP2COND"))
	((NOT (CDR L))
	 (COND ((EQCAR (FIRST L) 'COLON)
		(CONS (SECOND L) (LIST (LIST T 'FAIL))))
	       (T (LIST (LIST T (FIRST L)))) ))
	((EQCAR (FIRST L) 'COLON) (CONS (CDAR L) (GP2COND (CDR L))))
	(T (ERROR "GP2COND"))))

(FLAG JUNKTOKLIST 'KEY)

(defmacro |report| (L)
  (SUBST (SECOND L) 'x
	 '(COND ($reportFlag (sayBrightly x)) ((QUOTE T) NIL))))

(defmacro |DomainSubstitutionMacro| (&rest L)
  (|DomainSubstitutionFunction| (first L) (second L)))

(defun |sort| (seq spadfn)
    (sort (copy-seq seq) (function (lambda (x y) (SPADCALL X Y SPADFN)))))

(defun QUOTIENT2 (X Y) (values (TRUNCATE X Y)))

(define-function 'REMAINDER2 #'REM)

(defun DIVIDE2 (X Y) (multiple-value-call #'cons (TRUNCATE X Y)))

(defmacro APPEND2 (x y) `(append ,x ,y))

(defmacro |float| (x &optional (y 0.0d0)) `(float ,x ,y))

(defun |makeSF| (mantissa exponent)
  (|float| (/ mantissa (expt 2 (- exponent)))))

(define-function 'list1 #'list)
(define-function '|not| #'NOT)

(defun |random| () (random (expt 2 26)))
(defun \,plus (x y) (+ x y))
(defun \,times (x y) (* x y))
(defun \,difference (x y) (- x y))
(defun \,max (x y) (max x y))
(defun \,min (x y) (min x y))
;; This is used in the domain Boolean (BOOLEAN.nrlib/code.lsp)
(defun |BooleanEquality| (x y) (if x y (null y)))

(defun S-PROCESS (X)
  (let ((|$Index| 0)
	($MACROASSOC ())
	($NEWSPAD T)
	(|$PolyMode| |$EmptyMode|)
	(|$compUniquelyIfTrue| nil)
	|$currentFunction|
	(|$postStack| nil)
	|$topOp|
	(|$semanticErrorStack| ())
	(|$warningStack| ())
	(|$exitMode| |$EmptyMode|)
	(|$exitModeStack| ())
	(|$returnMode| |$EmptyMode|)
	(|$leaveMode| |$EmptyMode|)
	(|$leaveLevelStack| ())
	$TOP_LEVEL |$insideFunctorIfTrue| |$insideExpressionIfTrue|
	|$insideCoerceInteractiveHardIfTrue| |$insideWhereIfTrue|
	|$insideCategoryIfTrue| |$insideCapsuleFunctionIfTrue| |$form|
	(|$DomainFrame| '((NIL)))
	(|$e| |$EmptyEnvironment|)
	(|$genFVar| 0)
	(|$genSDVar| 0)
	(|$VariableCount| 0)
	(|$previousTime| (TEMPUS-FUGIT))
	(|$LocalFrame| '((NIL))))
  (prog ((CURSTRM CUROUTSTREAM) |$s| |$x| |$m| u)
     (declare (special CURSTRM |$s| |$x| |$m| CUROUTSTREAM))
      (SETQ $TRACEFLAG T)
      (if (NOT X) (RETURN NIL))
      (setq X (if $BOOT (DEF-RENAME (|new2OldLisp| X))
		  (|parseTransform| (|postTransform| X))))
      (if |$TranslateOnly| (RETURN (SETQ |$Translation| X)))
      (when |$postStack| (|displayPreCompilationErrors|) (RETURN NIL))
      (COND (|$PrintOnly|
	     (format t "~S   =====>~%" |$currentLine|)
	     (RETURN (PRETTYPRINT X))))
      (if (NOT $BOOT)
	  (if |$InteractiveMode|
	      (|processInteractive| X NIL)
	    (if (setq U (|compTopLevel|	 X |$EmptyMode|
					 |$InteractiveFrame|))
		(SETQ |$InteractiveFrame| (third U))))
	(DEF-PROCESS X))
      (if |$semanticErrorStack| (|displaySemanticErrors|))
      (TERPRI))))

(MAKEPROP 'END_UNIT 'KEY T)

(defun |process| (x)
  (COND ((NOT (EQ TOK 'END_UNIT))
	 (SETQ DEBUGMODE 'NO)
	 (SPAD_SYNTAX_ERROR)
	 (if |$InteractiveMode| (|spadThrow|))
	 (S-PROCESS x))))


@
The evalSharpOne function needs to declare the second argument
special to reduce warning messages about variables being assumed
special.
<<*>>=
(defun |evalSharpOne| (x |#1|) (declare (special |#1|))
 (EVAL `(let() (declare (special |#1|)) ,x)))

(defun new () (|New,ENTRY|))

(defun newpo () (let ((|$PrintOnly| t)) (new)))

(defun |New,ENTRY| ()
   (let ((|$InteractiveMode| t)(inputstream in-stream) )
      (declare (special inputstream))
      (spad)))

(defun |New,ENTRY,SYS| ()
  (let (|$InteractiveMode|)
    (|New,ENTRY1|)))

(defun |New,ENTRY1| ()
  (let ((spaderrorstream curoutstream) $boot (curinstream curinstream)
	(strm curinstream))
    (SETQ CURINSTREAM *terminal-io*)
    (|New,ENTRY,1|)
    (SETQ CURINSTREAM STRM)
    'END_OF_New))

(setq *PROMPT* 'LISP)

(defun |New,ENTRY,1| ()
    (let (ZZ str N RLGENSYMFG RLGENSYMLST |NewFLAG| XCAPE *PROMPT*
	  SINGLELINEMODE OK ISID NBLNK COUNT CHR ULCASEFG ($LINESTACK 'BEGIN_UNIT)
	  $NEWLINSTACK $TOKSTACK COMMENTCHR TOK LINE BACK INPUTSTREAM XTRANS
	  XTOKENREADER STACK STACKX)
      (SETQ XTRANS '|boot-New|
	    XTOKENREADER 'NewSYSTOK
	    SYNTAX_ERROR 'SPAD_SYNTAX_ERROR)
      (FLAG |boot-NewKEY| 'KEY)
      (SETQ *PROMPT* 'Scratchpad-II)
      (PROMPT)
      (SETQ XCAPE '_)
      (SETQ COMMENTCHR 'IGNORE)
      (SETQ COLUMN 0)
      (SETQ SINGLINEMODE T)   ; SEE NewSYSTOK
      (SETQ NewFLAG T)
      (SETQ ULCASEFG T)
      (setq STR (|New,ENTRY,2| '|PARSE-NewEXPR| '|process| curinstream))
      (if (/= 0 (setq N (NOTE STR)))
	  (progn  (SETQ CURINSTREAM (POINTW N CURINSTREAM)))
	  )
      '|END_OF_New|))

(defun |New,ENTRY,2| (RULE FN INPUTSTREAM) (declare (special INPUTSTREAM))
  (let (zz)
      (INITIALIZE)
      (SETQ $previousTime (TEMPUS-FUGIT))
      (setq ZZ (CONVERSATION '|PARSE-NewExpr| '|process|))
      (REMFLAG |boot-NewKEY| 'KEY)
      INPUTSTREAM))

(defun INITIALIZE () (init-boot/spad-reader) (initialize-preparse INPUTSTREAM))

(defun New-LEXPR () (New-LEXPR1))

(defun New-LEXPR-Interactive () (setq |$InteractiveMode| t) (New-LEXPR1))

(setq *prompt* 'new)

(defun New-LEXPR1 ()
  (FLAG |boot-NewKEY| 'KEY)
  (SETLINE (SUB1 (file-position INPUTSTREAM)) INPUTSTREAM)
  (SETQ CHR 'ENDOFLINECHR)
  (NXTTOK)
  (|boot-Statement|)
  (CAR STACK))

(defun parserState ()
  (PRINT (LIST 'CHR= CHR 'NBLNK= NBLNK 'TOK= TOK 'ISID= ISID
	       'COUNT= COUNT 'COLUMN= COLUMN))
  (PRINT (LIST 'STACK= STACK 'STACKX= STACKX))
  (PRINT (LIST '$TOKSTACK= $TOKSTACK 'INPUTSTREAM= INPUTSTREAM)))

(defmacro try (X)
  `(LET ((|$autoLine|))
	(declare (special |$autoLine|))
	(|tryToFit| (|saveState|) ,X)))

(mapcar #'(lambda (X) (MAKEPROP (CAR X) 'format (CADR X)))
	'((COMMENT |formatCOMMENT|)
	  (SEQ |formatSEQ|)
	  (DEF |formatDEF|)
	  (LET |formatLET|)
	  (\: |formatColon|)
	  (ELT |formatELT|)
	  (SEGMENT |formatSEGMENT|)
	  (COND |formatCOND|)
	  (SCOND |formatSCOND|)
	  (QUOTE |formatQUOTE|)
	  (CONS |formatCONS|)
	  (|where| |formatWHERE|)
	  (APPEND |formatAPPEND|)
	  (REPEAT |formatREPEAT|)
	  (COLLECT |formatCOLLECT|)
	  (REDUCE |formatREDUCE|)))

(defun |boot2Lisp| (LINESET)
  (let* (($TOP_STACK T) (*PROMPT* 'New) ($MAXLINENUMBER 0)
	  (NewFLAG T) (XTRANS '|boot-New|) (XCAPE '!)
	  (COMMENTCHR 'NOTHING)	 (XTOKENREADER 'NewSYSTOK)
	  ($NBOOT T) (ERRCOL 0) (COUNT 0) (COLUMN 0)
	  (OK T) (SPADERRORSTREAM CUROUTSTREAM)
	  ($LINESTACK 'BEGIN_UNIT)
	  (INPUTSTREAM LINESET)
	  (CHR 'ENDOFLINECHR))
    (REMFLAG S-SPADKEY 'KEY)
    (FLAG |boot-NewKEY| 'KEY)
    (NXTTOK)   ; causes PREPARSE to be called
    (|boot-Statement|)
    (REMFLAG |boot-NewKEY| 'KEY)
    (FLAG S-SPADKEY 'KEY)
    (if (NULL OK) (|boot2LispError|))
    (|new2OldLisp| (CAR STACK))))

(defun /cx (L)
  "CAUTION: will not work if function in L has DEFLOC with ft=NBOOT"
  (if (not L) (SETQ L |$LastCxArg|))
  (SETQ |$LastCxArg| L)
  (/D-1 L '|lisp2BootAndCompare| NIL NIL))

(defun /foobar (L)
  (let (($xCount 0))
    (if (not L) (SETQ L $LastCxArg))
    (SETQ $LastCxArg L)
    (/D-1 L 'foobar NIL NIL)))

(defun foobar (X) |$xCount|)

(defun |/cxd| (L)
  (if (NULL L) (SETQ L $|LastCxArg|))
  (SETQ |$LastCxArg| L)
  (/D-1 L '|lispOfBoot2NBootAndCompare| NIL NIL))

(defun |/rx| (L)
  (let ((DEF-RENAME 'IDENTITY)
	(DEF-PROCESS '|lispOfBoot2NBootAndCompare|) )
    (declare (SPECIAL DEF-RENAME DEF-PROCESS))
    (if (OR (NULL L) (NULL (ATOM (CAR L))))
	(EVAL (APPEND (CONS '/RF /EDITFILE) L))
	(CATCH 'FILENAM (/RF-1 L)))))

(defun |/ry| (L)
  (let ((DEF-RENAME 'IDENTITY)
	(DEF-PROCESS '|pp|) )
    (declare (SPECIAL DEF-RENAME DEF-PROCESS))
   (if (OR (NULL L) (NULL (ATOM (CAR L))))
       (EVAL (APPEND (CONS '/RF /EDITFILE) L))
       (CATCH 'FILENAM (/RF-1 L)))))

(defun |/tb| (L)
  (let ((DEF-RENAME 'IDENTITY) (DEF-PROCESS 'lispOfBoot2NBAC1))
    (declare (special DEF-RENAME DEF-PROCESS))
    (if (NULL L)
	(EVAL (CONS '/RQ /EDITFILE))
	(CATCH 'FILENAM
	  (PROG (OUTFILE ($PRETTYPRINT T))
		(SETQ /EDITFILE (LIST (CAR L) 'BOOT '*))
		(OBEY (STRCONC "ERASE " (PNAME (CAR /EDITFILE)) " NBOOT E1"))
		(SETQ OUTFILE (LIST (CAR /EDITFILE) 'NBOOT 'E1))
		(RETURN (/RF-1 (APPEND /EDITFILE
				       (LIST (CONS 'TO= OUTFILE))))))))))

(defun |boot2LispError| ()
  "Print syntax error indication, underline character, scrub line."
  (COND ((OR (EQ DEBUGMODE 'YES) (NULL (CONSOLEINPUTP INPUTSTREAM)))
	 (SPAD_LONG_ERROR))
	(T (SPAD_SHORT_ERROR)))
  (SETQ OK T))

(defun |getTranslation| (|function| |fn| |ft| |rdr|)
  (let ((|New-LEXPR| |rdr|) (|$TranslateOnly| T))
    (declare (special |New-LEXPR| |$TranslateOnly|))
    (/D-1 (LIST |function| (LIST 'FROM= |fn| |ft|)) 'IDENTITY NIL NIL)
    |$Translation|))

(defmacro |incTimeSum| (a b)
  (if (not |$InteractiveTimingStatsIfTrue|) a
      (let ((key  b) (oldkey (gensym)) (val (gensym)))
	`(prog (,oldkey ,val)
	       (setq ,oldkey (|incrementTimeSum| ,key))
	       (setq ,val ,a)
	       (|incrementTimeSum| ,oldkey)
	       (return ,val)))))

(defun GLESSEQP (X Y) (NOT (GGREATERP X Y)))

(defun LEXLESSEQP (X Y) (NOT (LEXGREATERP X Y)))

(defun SETELTFIRST (A B C) (declare (ignore b)) (RPLACA A C))

(defun SETELTREST (A B C) (declare (ignore b)) (RPLACD A C))

(defmacro |rplac| (&rest L)
  (let (a b s)
    (cond
      ((EQCAR (SETQ A (CAR L)) 'ELT)
       (COND ((AND (INTEGERP (SETQ B (CADDR A))) (>= B 0))
	      (SETQ S "CA")
	      (do ((i 1 (1+ i))) ((> i b)) (SETQ S (STRCONC S "D")))
	      (LIST 'RPLAC (LIST (INTERN (STRCONC S "R")) (CADR A)) (CADR L)))
	     ((ERROR "rplac"))))
      ((PROGN
	 (SETQ A (CARCDREXPAND (CAR L) NIL))
	 (SETQ B (CADR L))
	 (COND
	   ((CDDR L) (ERROR 'RPLAC))
	   ((EQCAR A 'CAR) (LIST 'RPLACA (CADR A) B))
	   ((EQCAR A 'CDR) (LIST 'RPLACD (CADR A) B))
	   ((ERROR 'RPLAC))))))))

(DEFUN ASSOCIATER (FN LST)
  (COND ((NULL LST) NIL)
	((NULL (CDR LST)) (CAR LST))
	((LIST FN (CAR LST) (ASSOCIATER FN (CDR LST))))))

(defun ISLOCALOP-1 (IND)
  "Curindex points at character after '.'"
  (prog (selector buf termtok (NEWCHR (NEXTCHARACTER)))
    (if (TERMINATOR NEWCHR) (RETURN NIL))
    (setq SELECTOR
	  (do ((x nil))
	      (nil)
	    (if (terminator newchr)
		(reverse x)
		(push (setq newchr (nextcharacter)) x))))
    (if (EQUAL NEWCHR '\.) (RETURN (ISLOCALOP-1 IND)))
    (setq BUF (GETSTR (LENGTH SELECTOR)))
    (mapc #'(lambda (x) (suffix x buf)) selector)
    (setq buf (copy-seq selector))
    (setq TERMTOK (INTERN BUF))
    (if (NOT (GET TERMTOK 'GENERIC)) (RETURN NIL))
    (if (OR (GET TERMTOK '|Led|) (GET TERMTOK '|Nud|))
	(GET TERMTOK IND))
    (return TERMTOK)))
; **** X. Random tables

(defvar MATBORCH "*")
(defvar $MARGIN 3)
(defvar $LINELENGTH 71)
(defvar TEMPGENSYMLIST '(|s| |r| |q| |p|))
(defvar ALPHLIST '(|a| |b| |c| |d| |e| |f| |g|))
(defvar LITTLEIN " in ")
(defvar INITALPHLIST ALPHLIST)
(defvar INITXPARLST '(|i| |j| |k| |l| |m| |n| |p| |q|))
(defvar PORDLST (COPY-tree INITXPARLST))
(defvar INITPARLST '(|x| |y| |z| |u| |v| |w| |r| |s| |t|))
(defvar LITTLEA '|a|)
(defvar LITTLEI '|i|)
(defvar *TALLPAR NIL)
(defvar ALLSTAR NIL)
(defvar BLANK " ")
(defvar PLUSS "+")
(defvar PERIOD ".")
(defvar SLASH "/")
(defvar COMMA ",")
(defvar LPAR "(")
(defvar RPAR ")")
(defvar EQSIGN "=")
(defvar DASH "-")
(defvar STAR "*")
(defvar DOLLAR "$")
(defvar COLON ":")

; (SETQ |boot-NewKEY| (S- |boot-NewKEY| '(|cp| |cms| |lisp| |boot|)))

(FLAG TEMPGENSYMLIST 'IS-GENSYM)

(MAKEPROP 'COND '|Nud| '(|if| |if| 130 0))
(MAKEPROP 'CONS '|Led| '(CONS CONS 1000 1000))
(MAKEPROP 'APPEND '|Led| '(APPEND APPEND 1000 1000))
(MAKEPROP 'TAG '|Led| '(TAG TAG 122 121))
(MAKEPROP 'EQUATNUM '|Nud| '(|dummy| |dummy| 0 0))
(MAKEPROP 'EQUATNUM '|Led| '(|dummy| |dummy| 10000 0))
(MAKEPROP 'LET '|Led| '(:= LET 125 124))
(MAKEPROP 'RARROW '|Led| '(== DEF 122 121))
(MAKEPROP 'SEGMENT '|Led| '(\.\. SEGMENT 401 699 (|boot-Seg|)))

;; NAME:    DECIMAL-LENGTH
;; PURPOSE: Computes number of decimal digits in print representation of x
;;  This should made as efficient as possible.

(DEFUN DECIMAL-LENGTH (X)
   (LET* ((K (FIX (* #.(LOG 2.0 10.) (INTEGER-LENGTH X))))
	  (X (TRUNCATE (ABS X) (EXPT 10 (1- K)))))
     (IF (LESSP X 10) K (1+ K))))

;(DEFUN DECIMAL-LENGTH2 (X)
;   (LET ((K (FIX (* #.(LOG 2.0 10.) (INTEGER-LENGTH X)))))
;     (IF (< (ABS X) (EXPT 10 K)) K (1+ K))))


;; function to create byte and half-word vectors in new runtime system 8/90

(defun |makeByteWordVec| (initialvalue)
  (let ((n (cond ((null initialvalue) 7) ('t (reduce #'max initialvalue)))))
    (make-array (length initialvalue)
      :element-type (list 'mod (1+ n))
      :initial-contents initialvalue)))

(defun |makeByteWordVec2| (maxelement initialvalue)
  (let ((n (cond ((null initialvalue) 7) ('t maxelement))))
    (make-array (length initialvalue)
      :element-type (list 'mod (1+ n))
      :initial-contents initialvalue)))

(defun |knownEqualPred| (dom)
  (let ((fun (|compiledLookup| '= '((|Boolean|) $ $) dom)))
    (if fun (get (bpiname (car fun)) '|SPADreplace|)
      nil)))

(defun |hashable| (dom)
  (memq (|knownEqualPred| dom)
	 '(EQ EQL EQUAL)
	))

;; simpler interpface to RDEFIOSTREAM
(defun RDEFINSTREAM (&rest fn)
  ;; following line prevents rdefiostream from adding a default filetype
  (if (null (rest fn)) (setq fn (list (pathname (car fn)))))
  (rdefiostream (list (cons 'FILE fn) '(mode . INPUT))))

(defun RDEFOUTSTREAM (&rest fn)
  ;; following line prevents rdefiostream from adding a default filetype
  (if (null (rest fn)) (setq fn (list (pathname (car fn)))))
  (rdefiostream (list (cons 'FILE fn) '(mode . OUTPUT))))

(defmacro |spadConstant| (dollar n)
 `(spadcall (svref ,dollar (the fixnum ,n))))


;;; The operations which traverse entire vectors are given as functions
;;; since the function calling overhead will be relatively small.
;;; The operations which extract or set a single part of the vector are
;;; provided as macros.

(defmacro truth-to-bit (x) `(cond (,x 1) ('else 0)))
(defmacro bit-to-truth (b) `(eq ,b 1))

(defun    bvec-make-full (n x) 
    (make-array (list n) :element-type 'bit :initial-element x))

(defmacro bvec-elt       (bv i)    `(sbit ,bv ,i))
(defmacro bvec-setelt    (bv i x)  `(setf (sbit ,bv ,i) ,x))
(defmacro bvec-size      (bv)      `(size ,bv))

(defun    bvec-copy      (bv)      (copy-seq bv))
(defun    bvec-concat    (bv1 bv2) (concatenate '(vector bit) bv1 bv2))
(defun    bvec-equal     (bv1 bv2) (equal    bv1 bv2))
(defun    bvec-greater   (bv1 bv2)
  (let ((pos (mismatch bv1 bv2)))
    (cond ((or (null pos) (>= pos (length bv1))) nil)
	  ((< pos (length bv2)) (> (bit bv1 pos) (bit bv2 pos)))
	  ((find 1 bv1 :start pos) t)
	  (t nil))))
(defun    bvec-and       (bv1 bv2) (bit-and  bv1 bv2))
(defun    bvec-or        (bv1 bv2) (bit-ior  bv1 bv2))
(defun    bvec-xor       (bv1 bv2) (bit-xor  bv1 bv2))
(defun    bvec-nand      (bv1 bv2) (bit-nand bv1 bv2))
(defun    bvec-nor       (bv1 bv2) (bit-nor  bv1 bv2))
(defun    bvec-not       (bv)      (bit-not  bv))

(SETQ |/MAJOR-VERSION| 7)
(SETQ /VERSION 0)
(SETQ /RELEASE 0)

(defconstant |$cclSystem| nil)

;; These two variables are referred to in setvars.boot.
(setq input-libraries nil)
(setq output-library nil)

;; For the browser, used for building local databases when a user compiles
;; their own code.
(SETQ |$newConstructorList| nil)
(SETQ |$newConlist| nil)
(SETQ |$createLocalLibDb| 't)

;; These are duplicates of definitions in bookvol9

(defvar |$byConstructors| () "list of constructors to be compiled")
(defvar |$constructorsSeen| () "list of constructors found")

;; These were originally in SPAD LISP

(SETQ $BOOT NIL)
(SETQ $NBOOT NIL)
(setq |$interpOnly| nil)
(SETQ |$testingSystem| NIL)
(SETQ |$publicSystem| NIL)
(SETQ |$newcompMode| NIL)
(SETQ |$newComp| NIL)
(SETQ |$newCompCompare| NIL)
(SETQ |$permitWhere| NIL)
(SETQ |$newSystem| T)
(SETQ |$noSubsumption| T) ;; was T in a running axiom, from xruncomp
(SETQ |$bootStrapMode| NIL) ;; if true skip functor bodies
(SETQ |$compileDontDefineFunctions| 'T)
(SETQ |$compileOnlyCertainItems| NIL)
(SETQ |$devaluateList| NIL)
(SETQ |$doNotCompressHashTableIfTrue| NIL)
(SETQ |$mutableChecking| NIL)	 ; used in DEFINE BOOT
(SETQ |$mutableDomains| NIL)	 ; checked in DEFINE BOOT
(SETQ |$maxSignatureLineNumber| 0)
(SETQ |$functionLocations| NIL)
(SETQ |$functorLocalParameters| NIL) ; used in compSymbol
(SETQ /RELEASE '"UNKNOWN")
(SETQ |$insideCategoryPackageIfTrue| NIL)
(SETQ |$insideCompileBodyIfTrue| NIL)
(SETQ |$globalExposureGroupAlist| NIL)
(SETQ |$localExposureDataDefault|
  (VECTOR (LIST '|basic| '|categories| '|naglink| '|anna| ) NIL NIL))
(SETQ |$localExposureData|
  (VECTOR (LIST '|basic| '|categories| '|naglink| '|anna| ) NIL NIL))
(SETQ |$compilingInputFile| NIL)
(SETQ |$minivectorNames| NIL)
(setq |$ReadingFile| NIL)
(setq |$NonNullStream| "NonNullStream")
(setq |$NullStream| "NullStream")
(setq |$domPvar| nil)
(setq |$Newline| #\Newline)


(setq |$createUpdateFiles| nil)

(SETQ $FUNNAME NIL)   ;; this and next used in COMP,TRAN,1
(SETQ $FUNNAME_TAIL '(()))
(SETQ $LASTPREFIX "S:")    ;"default setting"
(SETQ |$inLispVM| 'T)
(SETQ $SPAD_ERRORS (VECTOR 0 0 0))
(SETQ STAKCOLUMN -1)
(SETQ ECHOMETA NIL)
(SETQ |$checkParseIfTrue| 'NIL)
(SETQ |$oldParserExpandAbbrs| NIL)
(SETQ $DISPLAY NIL)
(SETQ |S:SPADKEY| NIL) ;" this is augmented by MAKESPADOP"
(SETQ $OLDLINE NIL)  ;"used to output command lines"
(SETQ |/EDIT,FT| 'SPAD)
(SETQ |/EDIT,FM| 'A)
(SETQ /EDITFILE NIL)
(SETQ INITCOLUMN 0)
(SETQ |$functionTable| NIL)
(SETQ |$spaddefs| NIL)
(SETQ |$xeditIsConsole|	 NIL)
(SETQ |$echoInputLines|	 NIL)	    ;; This is in SETVART also
(SETQ |$Slot1DataBase| (MAKE-HASHTABLE 'ID))  ;; See NRUNTIME BOOT
(SETQ |$pfKeysForBrowse|  NIL)
(SETQ MARG 0)
  ;" Margin for testing by ?OP"
(SETQ LCTRUE '|true|)
(SETQ |$displayParserOutput| 'T)

(SETQ |$insideReadRulesIfTrue| NIL)
(SETQ |$consistencyCheck| 'T)
(SETQ |$useUndo| NIL)
(SETQ |$ruleSetsInitialized| NIL)

;; tell the system not to use the new parser
(SETQ |$useNewParser| NIL)

(SETQ |$htPrecedenceTable| NIL)

(SETQ |$NRTmakeCompactDirect| NIL)
(SETQ |$NRTquick| NIL)
(SETQ |$NRTmakeShortDirect| NIL)
(SETQ |$newWorld| NIL)
(SETQ |$returnNowhereFromGoGet| NIL)

(SETQ |$insideCanCoerceFrom| NIL)

(SETQ |$useCoerceOrCroak| T)

(SETQ |$abbreviateJoin| NIL)

(SETQ |$InterpreterMacroAlist|
      '((|%i| . (|complex| 0 1))
	(|%e| . (|exp| 1))
	(|%pi| . (|pi|))
	(|SF| . (|DoubleFloat|))
	(|%infinity| . (|infinity|))
	(|%plusInfinity| . (|plusInfinity|))
	(|%minusInfinity| . (|minusInfinity|))))

;; variables controlling companion pages (see copage.boot)
(SETQ |$HTCompanionWindowID| nil)
(SETQ |$HTPreviousDomain| nil)
(SETQ |$HTOperationError| nil)

;; Common lisp control variables
;;(setq *load-verbose* nil)
(setq *print-array* nil)
(setq *print-pretty* nil)
(setq *print-circle* nil)

(SETQ |S:SPADTOK| 'SPADSYSTOK)
(SETQ APLMODE NIL)
(SETQ RLGENSYMFG NIL)
(SETQ RLGENSYMLST NIL)
(SETQ XTOKENREADER 'SPADTOK)
(SETQ |$delimiterTokenList|
  '(| |	 |)| |(| |{| |}| |[| |]| ENDOFLINECHR EOI EOL |END_LINE|))
(SETQ |$generalTokenIfTrue| NIL)
(SETQ OPASSOC NIL)
(SETQ SPADSYSKEY '(EOI EOL))

(SETQ $cacheAlist NIL)
(SETQ $streamAlist NIL)

;; These are for the output routines in OUT BOOT

(SETQ $LINELENGTH 77)
(SETQ $MARGIN 3)
(SETQ *TALLPAR NIL)
(SETQ ALLSTAR NIL)
(SETQ BLANK " ")
(SETQ COLON ":")
(SETQ COMMA ",")
(SETQ DASH "-")
(SETQ DOLLAR "$")
(SETQ EQSIGN "=")
(SETQ LPAR "(")
(SETQ MATBORCH "*")
(SETQ PERIOD ".")
(SETQ PLUSS "+")
(SETQ RPAR ")")
(SETQ SLASH "/")
(SETQ STAR "*")
(SETQ |$fortranArrayStartingIndex| 0)

;; These were originally in INIT LISP

(SETQ |$systemCreation|
  (STRCONC (SUBSTRING (CURRENTTIME) 0 8) " at "
	   (SUBSTRING (CURRENTTIME) 8 5)))
(SETQ |$systemLastChanged| |$systemCreation|)

(SETQ $LISPLIB NIL)
(SETQ |$dependeeClosureAlist|	    NIL)
(SETQ |$userModemaps| NIL)
(SETQ |$forceDatabaseUpdate| NIL)  ;; see "load" function
(SETQ |$spadSystemDisks|  '(I J K L))
(SETQ |$functorForm| NIL)

(SETQ |$spadLibFT| 'LISPLIB)

(SETQ |$existingFiles| (MAKE-HASHTABLE 'UEQUAL))
(SETQ |$updateCatTableIfTrue| 'T)

(SETQ |$ConstructorCache| (MAKE-HASHTABLE 'ID))
(SETQ |$instantRecord| (MAKE-HASHTABLE 'ID))
(SETQ |$immediateDataSymbol| '|--immediateData--|)

(SETQ |$useIntegerSubdomain| 'T)
(SETQ |$useNewFloat| 'T)

;; Directories/disks on which to place various kinds of files
(SETQ |$libraryDirectory| 'A)
(SETQ |$listingDirectory| 'A)

;; See CLAMMED BOOT for defs of following functions
(SETQ |$clamList| '(
  (|canCoerce| |hash| UEQUAL |count|)
  (|canCoerceFrom| |hash| UEQUAL |count|)
  (|coerceConvertMmSelection| |hash| UEQUAL |count|)
; (|getModemapsFromDatabase| |hash| UEQUAL |count|)
; (|getOperationAlistFromLisplib| |hash| UEQUAL |count|)
  (|hasFileProperty| |hash| UEQUAL |count|)
  (|isLegitimateMode| |hash| UEQUAL |count|)
  (|isValidType| |hash| UEQUAL |count|)
  (|resolveTT|	 |hash| UEQUAL |count|)
  (|selectMms1| |hash| UEQUAL |count|)
  (|underDomainOf|   |hash| UEQUAL |count|)
;  (|isSubDomain|   |hash| UEQUAL |count|)
))

;; following is symbol denoting a failed operation
(SETQ |$failure| (GENSYM))
;; the following symbol holds the canonical "failed" value
(SETQ |$failed| "failed")

(SETQ |$constructorDataTable| NIL)

(SETQ |$underDomainAlist| '())
;;(SETQ |$underDomainAlist| '(
;;  (|DistributedMultivariatePolynomial| . 2)
;;  (|MultivariatePolynomial| . 2)
;;  (|NewDistributedMultivariatePolynomial| . 2)
;;  (|RectangularMatrix| . 3)
;;  (|SquareMatrix| . 2)
;;  (|UnivariatePoly| . 2)
;;  (|VVectorSpace| . 2)
;;))

(SETQ |$univariateDomains| '(
    |UnivariatePolynomial|
    |UnivariateTaylorSeries|
    |UnivariateLaurentSeries|
    |UnivariatePuiseuxSeries|
    ))
(SETQ |$multivariateDomains| '(
    |MultivariatePolynomial|
    |DistributedMultivariatePolynomial|
    |HomogeneousDistributedMultivariatePolynomial|
    |GeneralDistributedMultivariatePolynomial|
    ))

(SETQ |$Primitives| '(|Union| |Mapping| |Record| |Enumeration|))

(SETQ |$DomainsWithoutLisplibs| '(
  CAPSULE |Union| |Record| |SubDomain| |Mapping| |Enumeration| |Domain| |Mode|))

(SETQ |$letAssoc| NIL)
	;" used for trace of assignments in SPAD code -- see macro LETT"
(SETQ |$useDCQnotLET| NIL)	;; use DCQs for destructuring := patterns
(SETQ |$QuickCode| T)
	 ;" controls generation of QREFELT etc."
(SETQ |$QuickLet| T)
	 ;" controls generation of LET tracing."
(SETQ |$lastUntraced| NIL)
 ;" used for )restore option of )trace."
(SETQ |$mathTraceList| NIL)
	 ;" controls mathprint output for )trace."
(SETQ |$domainTraceNameAssoc| NIL)
	;"alist of traced domains"
(SETQ |$tracedMapSignatures| ())
(SETQ |$highlightAllowed| 'T)
	 ;" used in BRIGHTPRINT and is a )set variable"

(SETQ |$leftPren| "(")    ;;[for use in SAY expressions]
(SETQ |$rightPren| ")")

(SETQ |$abbreviationTable| NIL)

(SETQ |$ConstructorNames| '(
  |SubDomain| |List| |Union| |Record| |Vector|
      ))
	   ;" Used in isFunctor test, and compDefine "

(SETQ |$SpecialDomainNames| '(
  |add| CAPSULE |SubDomain| |List| |Union| |Record| |Vector|
      ))
		 ;" Used in isDomainForm, addEmptyCapsuleIfnecessary"

(SETQ |$DomainNames| '(
   |Integer| |Float| |Symbol| |Boolean| |String| |Expression|
   |Mapping| |SubDomain| |List| |Union| |Record| |Vector| |Enumeration|
      ))

(SETQ |$CategoryNames| '(
   |Category| |CATEGORY| |RecordCategory| |Join| |EnumerationCategory|
   |StringCategory| |SubsetCategory| |UnionCategory|
      ))

(|SETQ| |$BasicDomains| '(|Integer| |Float| |Symbol| |Boolean| |String|))

(SETQ |$PrintCompilerMessagesIfTrue| NIL)
(SETQ |$printStorageIfTrue| NIL) ;; storage info disabled in common lisp
(SETQ |$mostRecentOpAlist| NIL)
(SETQ |$noEnv| NIL)
(SETQ |$croakIfTrue| NIL) ;" see moan in UT"
(SETQ |$opFilter| NIL)	 ;" used to |/s a function "
(SETQ |$evalDomain| NIL)

(SETQ |$SideEffectFreeFunctionList| '(
  |null| |case| |Zero| |One| \: |::| |has| |Mapping|
  |elt| = |>| |>=| |<| |<=| MEMBER |is| |isnt| ATOM
  $= |$>| |$>=| |$<| |$<=| $^= $MEMBER
))

(SETQ |$AnonymousFunction| '(|AnonymousFunction|))
(SETQ |$Any|   '(|Any|))
(SETQ |$BFtag| '|:BF:|)
(SETQ |$Boolean| '(|Boolean|))
(SETQ |$Category| '(|Category|))
(SETQ |$Domain| '(|Domain|))
(SETQ |$Exit|  '(|Exit|))
(SETQ |$Expression| '(|OutputForm|))

(SETQ |$OutputForm| '(|OutputForm|))
(SETQ |$BigFloat| '(|Float|))
(SETQ |$Float| '(|Float|))
(SETQ |$DoubleFloat| '(|DoubleFloat|))

(SETQ |$FontTable| '(|FontTable|))
(SETQ |$Integer| '(|Integer|))
(SETQ |$ComplexInteger| (LIST '|Complex| |$Integer|))
(SETQ |$Mode|	'(|Mode|))
(SETQ |$NegativeInteger| '(|NegativeInteger|))
(SETQ |$NonNegativeInteger| '(|NonNegativeInteger|))
(SETQ |$NonPositiveInteger| '(|NonPositiveInteger|))
(SETQ |$PositiveInteger| '(|PositiveInteger|))
(SETQ |$RationalNumber| '(|Fraction| (|Integer|)))
(SETQ |$String| '(|String|))
(SETQ |$StringCategory| '(|StringCategory|))
(SETQ |$Symbol| '(|Symbol|))
(SETQ |$Void|  '(|Void|))
(SETQ |$QuotientField| '|Fraction|)
(SETQ |$FunctionalExpression| '|Expression|)
(SETQ |$defaultFunctionTargets| '(()))

;; Old names
(SETQ |$SmallInteger| '(|SingleInteger|))

;; New Names
(SETQ |$SingleFloat| '(|SingleFloat|))
(SETQ |$DoubleFloat| '(|DoubleFloat|))
(SETQ |$SingleInteger| '(|SingleInteger|))

(SETQ $TOP_LEVEL T)
(SETQ $NE (LIST (LIST NIL)))
(SETQ |$InteractiveFrame| (LIST (LIST NIL)))
(SETQ |$gauss01| '(|gauss| 0 1))
(SETQ |$LocalFrame| (LIST (LIST NIL)))
(SETQ |$DomainsInScope| (LIST NIL))
(SETQ |$EmptyEnvironment| '((NIL)))
(SETQ |$NETail| (CONS |$EmptyEnvironment| NIL))
(SETQ |$EmptyMode| '|$EmptyMode|)
(SETQ |$DummyFunctorNames| '(|Mapping|))
(SETQ |$form| NIL)
(SETQ |$DoubleQuote| '"\"")
(SETQ |$EmptyString| "")
(SETQ |$EmptyVector| (VECTOR))
(SETQ |$EmptyList| ())
(SETQ |$Index| 0)
(SETQ |$true| ''T)
(SETQ |$false| NIL)
(SETQ |$suffix| NIL)
(SETQ |$BasicPredicates| '(INTEGERP STRINGP FLOATP))
(SETQ |$coerceIntByMapCounter| 0)
(SETQ |$reportCoerce| NIL)
(SETQ |$reportCompilation| NIL)
(SETQ |$streamCount| 0)
(SETQ |$cacheCount| 0)
(SETQ |$streamIndexing| NIL)
(SETQ |$reportExitModeStack| NIL)
(SETQ |$prefix| NIL)
(SETQ |$Polvar| '(WRAPPED . ((1 . 1))))
(SETQ |$OneCoef| '(1 1 . 1))
(SETQ |$Lisp| '(|Lisp|))
(SETQ |$ExpressionOpt| '(|Expression| . OPT))
(SETQ |$formalArgList| ())
(SETQ |$FormalMapVariableList|
  '(|#1| |#2| |#3| |#4| |#5| |#6| |#7| |#8| |#9| |#10|
    |#11| |#12| |#13| |#14| |#15| |#16| |#17| |#18| |#19| |#20|
    |#21| |#22| |#23| |#24| |#25| |#26| |#27| |#28| |#29| |#30|
    |#31| |#32| |#33| |#34| |#35| |#36| |#37| |#38| |#39| |#40|
    |#41| |#42| |#43| |#44| |#45| |#46| |#47| |#48| |#49| |#50|
    ))
(SETQ |$PatternVariableList|
  '(*1 *2 *3 *4 *5 *6 *7 *8 *9 *10 *11 *12 *13 *14 *15 *16 *17 *18 *19 *20
  *21 *22 *23 *24 *25 *26 *27 *28 *29 *30 *31 *32 *33 *34 *35 *36 *37 *38 *39 *40
  *41 *42 *43 *44 *45 *46 *47 *48 *49 *50))
(SETQ |$ModeVariableList|
  '(dv$1 dv$2 dv$3 dv$4 dv$5 dv$6 dv$7 dv$8 dv$9 dv$10 dv$11 dv$12 dv$13 dv$14 dv$15
	 dv$16 dv$17 dv$18 dv$19 dv$20))
(SETQ |$DomainVariableList|
  '($1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14 $15 $16 $17 $18 $19 $20))
(SETQ |$TriangleVariableList|
   '(|t#1| |t#2| |t#3| |t#4| |t#5| |t#6| |t#7| |t#8| |t#9| |t#10|
     |t#11| |t#12| |t#13| |t#14| |t#15| |t#16| |t#17| |t#18| |t#19| |t#20|
     |t#21| |t#22| |t#23| |t#24| |t#25| |t#26| |t#27| |t#28| |t#29| |t#30|
     |t#31| |t#32| |t#33| |t#34| |t#35| |t#36| |t#37| |t#38| |t#39| |t#40|
     |t#41| |t#42| |t#43| |t#44| |t#45| |t#46| |t#47| |t#48| |t#49| |t#50|))

(SETQ |$PrimitiveDomainNames|
      '(|List| |Integer| |NonNegativeInteger| |PositiveInteger|
	|SingleInteger| |String| |Boolean|))
	    ;" used in mkCategory to avoid generating vector slots"
	    ;" for primitive domains "
	    ;" also used by putInLocalDomainReferences and optCall"
(SETQ |$optimizableConstructorNames|
   '(|List| |Integer| |PositiveInteger| |NonNegativeInteger| |SingleInteger|
     |String| |Boolean| |Symbol| |DoubleFloat| |PrimitiveArray| |Vector|))
	    ;" used by optCallSpecially"
(SETQ |$Zero| '(|Zero|))
(SETQ |$One| '(|One|))
(SETQ |$NonMentionableDomainNames|
      '($ |Rep| |Record| |Union| |Mapping| |Enumeration|))

;"  modemap:==  ( <map> (p e) (p e) ... (p e) )  "
;"  modemaplist:= ( modemap ... )  "
(SETQ |$CategoryFrame| '(((
  (|Category| .
    ((|modemap|
      ( ((|Category|) (|Category|)) (T *) )
	)))
  (|Join| .
    ((|modemap|
      ( ((|Category|) (|Category|) (|Category|) (|Category|)) (|T| *) )
      ( ((|Category|) (|Category|) (|List| (|Category|)) (|Category|)) (T *) )
	)))
    ))))

(SETQ |$InitialDomainsInScope|
  '(|$EmptyMode| |$NoValueMode|))

(SETQ |$InitialModemapFrame| '((NIL)))

(SETQ NRTPARSE NIL)
(SETQ |$NRTflag| T)
(SETQ |$NRTaddForm| NIL)
(SETQ |$NRTdeltaList| NIL)
(SETQ |$NRTbase| 0)
(SETQ |$NRTdeltaLength| 0)
(SETQ |$NRTopt| NIL) ;; turns off buggy code
(SETQ |$Slot1DataBase| NIL)
(SETQ |$NRTmonitorIfTrue| NIL)

(SETQ |$useConvertForCoercions| NIL)

(MAKEPROP '|One| '|defaultType| |$Integer|)
(MAKEPROP '|Zero| '|defaultType| |$Integer|)

;; Following were originally in EXPLORE BOOT

(SETQ |$xdatabase|	   NIL)
(SETQ |$CatOfCatDatabase|  NIL)
(SETQ |$DomOfCatDatabase|  NIL)
(SETQ |$JoinOfDomDatabase| NIL)
(SETQ |$JoinOfCatDatabase| NIL)
(SETQ |$attributeDb|	   NIL)

(SETQ |$abbreviateIfTrue|  NIL)
(SETQ |$deltax|	 0)
(SETQ |$deltay|	 0)
(SETQ |$displayDomains|	 'T)
(SETQ |$displayTowardAncestors|	 NIL)
(SETQ |$focus|	NIL)
(SETQ |$focusAccessPath|  NIL)
(SETQ |$minimumSeparation|  3)
(SETQ |$origMaxColumn|	80)
(SETQ |$origMaxRow|  20)
(SETQ |$origMinColumn|	1)
(SETQ |$origMinRow|  1)

;; ---- start of initial settings for variables used in test.boot

(SETQ |$testOutputLineFlag| NIL)   ;; referenced by charyTop, prnd
				   ;; to stash lines
(SETQ |$testOutputLineStack| NIL)  ;; saves lines to be printed
				   ;; (needed to convert lines for use
				   ;; in hypertex)
(SETQ |$runTestFlag| NIL)	   ;; referenced by maPrin to stash
				   ;; output by recordAndPrint to not
				   ;; print type/time
(SETQ |$mkTestFlag| NIL)	   ;; referenced by READLN to stash input
				   ;; by maPrin to stash output
				   ;; by recordAndPrint to write i/o
				   ;; onto $testStream
(SETQ |$mkTestInputStack| NIL)	   ;; saves input for $testStream
				   ;; (see READLN)
(SETQ |$mkTestOutputStack| NIL)	   ;; saves output for $testStream
				   ;; (see maPrin)

;; ---- end of initial settings for variables used in test.boot

;; Next flag determines whether to use BF as default floating point
;; type. (actually, now means NewFloat)

(SETQ |$useBFasDefault| 'T)

;; Next are initial values for fluid variables in G-BOOT BOOT

(SETQ |$inDefLET| NIL)
(SETQ |$inDefIS|  NIL)
(SETQ |$letGenVarCounter| 1)
(SETQ |$isGenVarCounter|  1)

;; Next 2 lines originally from CLAM BOOT

;; this node is used in looking up values
(SETQ |$hashNode| (LIST NIL))

(SETQ ERRORINSTREAM (DEFIOSTREAM
    '((DEVICE . CONSOLE) (MODE . INPUT) (QUAL . T)) 133 1))

(SETQ ERROROUTSTREAM
  (DEFIOSTREAM '((DEVICE . CONSOLE)(MODE . OUTPUT)) 80 0) )

(SETQ |$algebraOutputStream|
  (DEFIOSTREAM '((DEVICE . CONSOLE)(MODE . OUTPUT)) 255 0) )

;; By default, don't generate info files with old compiler.
(setq |$profileCompiler| nil)


@
\begin{verbatim}
This file contains most of the code that puts properties on
identifiers in the Scratchpad II system.  If it was not possible
to actually put the code here, we have pointers to where such
property list manipulation is being done.

Pointers:
o  see NEWAUX LISP for some code that puts GENERIC and RENAMETOK
   properties on identifiers for the parser
o  coerceIntCommute puts the "commute" property on constructors.
o  coerceRetract puts the "retract" property on constructors.
o  there is some code at the end of SPECEVAL BOOT that puts "up"
   properties on some special handlers.

\end{verbatim}
<<*>>=

(MAKEPROP 'END_UNIT 'KEY 'T)

(MAKEPROP 'TAG 'Led '(TAG TAG 122 121))
(MAKEPROP 'EQUATNUM '|Nud| '(|dummy| |dummy| 0 0))
(MAKEPROP 'EQUATNUM '|Led| '(|dummy| |dummy| 10000 0))
(MAKEPROP 'LET '|Led| '(|:=| LET 125 124))
(MAKEPROP 'RARROW '|Led| '(== DEF 122 121))
(MAKEPROP 'SEGMENT '|Led| '(|..| SEGMENT 401 699 (|P:Seg|)))
(MAKEPROP 'SEGMENT '|isSuffix| 'T)
(MAKEPROP 'EQUAL1 'CHRYBNAM 'EQ)

(REPEAT (IN X '(
   (LET " := ")
   (= "=")
   (|/| "/")
   (+ "+")
   (* "*")
   (** "**")
   (^ "^")
   (|:| ":")
   (|::| "::")
   (|@| "@")
   (SEL ".")
   (|exquo| " exquo ")
   (|div| " div ")
   (|quo| " quo ")
   (|rem| " rem ")
   (|case| " case ")
   (|and| " and ")
   (|or| " or ")
   (TAG " -> ")
   (|+->| " +-> ")
   (RARROW ": ")
   (SEGMENT "..")
   (in " in ")
   (|^=|  "^=")
   (EL* ":")
   (JOIN " JOIN ")
   (EQUATNUM "  ")
   (IQUOTIENT "//")
   (= "= ")
   (|>=| " >= ")
   (|>| " > ")
   (|<=| " <= ")
   (|<| " < ")
   (\| " \| ")
   (+ " + ")
   (- " - ")
   (MEMBER " in ")
   (NMEMBER " nin ")
   (WHERE " WHERE ")
   (AT " AT ")
   (MAX " MAX ")
   (MIN " MIN ")
       )) (MAKEPROP (CAR X) 'INFIXOP (CADR X)))

(REPEAT (IN X '(
  (= "=")
  (|:| ":")
  (|not| "^ ")
  (\| " \| ")
  (SEGMENT "..")  ;" 0.. is represented by (SEGMENT 0)"
 )) (MAKEPROP (CAR X) 'PREFIXOP (CADR X)))

(REPEAT (IN X '(
  (+ WIDTH |sumWidth|)
  (- APP |appneg|)
  (- WIDTH |minusWidth|)
  (/ APP |appfrac|)
  (/ SUBSPAN |fracsub|)
  (/ SUPERSPAN |fracsuper|)
  (/ WIDTH |fracwidth|)
  (AGGSET APP |argsapp|)
  (AGGSET SUBSPAN |agggsub|)
  (AGGSET SUPERSPAN |agggsuper|)
  (AGGSET WIDTH |agggwidth|)
  (|binom| APP |binomApp|)
  (|binom| SUBSPAN |binomSub|)
  (|binom| SUPERSPAN |binomSuper|)
  (|binom| WIDTH |binomWidth|)
  (ALTSUPERSUB APP	 |altSuperSubApp|)
  (ALTSUPERSUB SUBSPAN	 |altSuperSubSub|)
  (ALTSUPERSUB SUPERSPAN |altSuperSubSuper|)
  (ALTSUPERSUB WIDTH	 |altSuperSubWidth|)
  (BOX APP |boxApp|)
  (BOX SUBSPAN |boxSub|)
  (BOX SUPERSPAN |boxSuper|)
  (BOX WIDTH |boxWidth|)
  (BRACKET SUBSPAN |qTSub|)
  (BRACKET SUPERSPAN |qTSuper|)
  (BRACKET WIDTH |qTWidth|)
  (CENTER APP |centerApp|)
  (EXT APP |appext|)
  (EXT SUBSPAN |extsub|)
  (EXT SUPERSPAN |extsuper|)
  (EXT WIDTH |extwidth|)
  (MATRIX APP |appmat|)
  (MATRIX SUBSPAN |matSub|)
  (MATRIX SUPERSPAN |matSuper|)
  (MATRIX WIDTH |matWidth|)
  (NOTHING APP	     |nothingApp|)
  (NOTHING SUPERSPAN |nothingSuper|)
  (NOTHING SUBSPAN   |nothingSub|)
  (NOTHING WIDTH     |nothingWidth|)
  (OVER APP |appfrac|)
  (OVER SUBSPAN |fracsub|)
  (OVER SUPERSPAN |fracsuper|)
  (OVER WIDTH |fracwidth|)
  (OVERLABEL APP |overlabelApp|)
  (OVERLABEL SUPERSPAN |overlabelSuper|)
  (OVERLABEL WIDTH |overlabelWidth|)
  (OVERBAR APP |overbarApp|)
  (OVERBAR SUPERSPAN |overbarSuper|)
  (OVERBAR WIDTH |overbarWidth|)
  (PAREN APP |appparu1|)
  (PAREN SUBSPAN |qTSub|)
  (PAREN SUPERSPAN |qTSuper|)
  (PAREN WIDTH |qTWidth|)
  (ROOT APP	  |rootApp|)
  (ROOT SUBSPAN	  |rootSub|)
  (ROOT SUPERSPAN |rootSuper|)
  (ROOT WIDTH	  |rootWidth|)
  (ROW WIDTH |eq0|)
  (SC APP |appsc|)
  (SC SUBSPAN |agggsub|)
  (SC SUPERSPAN |agggsuper|)
  (SC WIDTH |widthSC|)
  (SETQ APP |appsetq|)
  (SETQ WIDTH |letWidth|)
  (SLASH APP	   |slashApp|)
  (SLASH SUBSPAN   |slashSub|)
  (SLASH SUPERSPAN |slashSuper|)
  (SLASH WIDTH	   |slashWidth|)
  (SUB APP |appsub|)
  (SUB SUBSPAN |subSub|)
  (SUB SUPERSPAN |subSuper|)
  (SUB WIDTH |suScWidth|)
  (SUPERSUB APP |superSubApp|)
  (SUPERSUB SUBSPAN |superSubSub|)
  (SUPERSUB SUPERSPAN |superSubSuper|)
  (SUPERSUB WIDTH |superSubWidth|)
  (VCONCAT APP |vconcatapp|)
  (VCONCAT SUBSPAN |vConcatSub|)
  (VCONCAT SUPERSPAN |vConcatSuper|)
  (VCONCAT WIDTH |vConcatWidth|)
  (BINOMIAL APP |binomialApp|)
  (BINOMIAL SUBSPAN |binomialSub|)
  (BINOMIAL SUPERSPAN |binomialSuper|)
  (BINOMIAL WIDTH |binomialWidth|)
  (ZAG APP |zagApp|)
  (ZAG SUBSPAN |zagSub|)
  (ZAG SUPERSPAN |zagSuper|)
  (ZAG WIDTH |zagWidth|)
)) (PROGN (MAKEPROP (CAR X) (CADR X) (CADDR X)))
)

(REPEAT (IN X '(
  (+ APP |plusApp|)
  (* APP |timesApp|)
  (* WIDTH |timesWidth|)
  (** APP |exptApp|)
  (** WIDTH |exptWidth|)
  (** SUBSPAN |exptSub|)
  (** SUPERSPAN |exptSuper|)
  (^  APP |exptApp|)
  (^  WIDTH |exptWidth|)
  (^  SUBSPAN |exptSub|)
  (^  SUPERSPAN |exptSuper|)
  (STEP APP |stepApp|)
  (STEP WIDTH |stepWidth|)
  (STEP SUBSPAN |stepSub|)
  (STEP SUPERSPAN |stepSuper|)
  (IN APP |inApp|)
  (IN WIDTH |inWidth|)
  (IN SUBSPAN |inSub|)
  (IN SUPERSPAN |inSuper|)
  (AGGLST APP |aggApp|)
  (AGGLST SUBSPAN |aggSub|)
  (AGGLST SUPERSPAN |aggSuper|)
  (CONCATB APP |concatbApp|)
  (CONCATB SUBSPAN |concatSub|)
  (CONCATB SUPERSPAN |concatSuper|)
  (CONCATB WIDTH |concatbWidth|)
  (CONCAT APP |concatApp|)
  (CONCAT  SUBSPAN |concatSub|)
  (CONCAT SUPERSPAN |concatSuper|)
  (CONCAT WIDTH |concatWidth|)
  (QUOTE APP |quoteApp|)
  (QUOTE SUBSPAN |quoteSub|)
  (QUOTE SUPERSPAN |quoteSuper|)
  (QUOTE WIDTH |quoteWidth|)
  (STRING APP |stringApp|)
  (STRING SUBSPAN |eq0|)
  (STRING SUPERSPAN |eq0|)
  (STRING WIDTH |stringWidth|)
  (SIGMA APP |sigmaApp|)
  (SIGMA SUBSPAN |sigmaSub|)
  (SIGMA SUPERSPAN |sigmaSup|)
  (SIGMA WIDTH |sigmaWidth|)
  (SIGMA2 APP |sigma2App|)
  (SIGMA2 SUBSPAN |sigma2Sub|)
  (SIGMA2 SUPERSPAN |sigma2Sup|)
  (SIGMA2 WIDTH |sigma2Width|)
  (INTSIGN APP |intApp|)
  (INTSIGN SUBSPAN |intSub|)
  (INTSIGN SUPERSPAN |intSup|)
  (INTSIGN WIDTH |intWidth|)
  (INDEFINTEGRAL APP |indefIntegralApp|)
  (INDEFINTEGRAL SUBSPAN |indefIntegralSub|)
  (INDEFINTEGRAL SUPERSPAN |indefIntegralSup|)
  (INDEFINTEGRAL WIDTH |indefIntegralWidth|)
  (PI APP |piApp|)
  (PI SUBSPAN |piSub|)
  (PI SUPERSPAN |piSup|)
  (PI WIDTH |piWidth|)
  (PI2 APP |pi2App|)
  (PI2 SUBSPAN |pi2Sub|)
  (PI2 SUPERSPAN |pi2Sup|)
  (PI2 WIDTH |pi2Width|)
  (AGGLST WIDTH |aggWidth|)
  (BRACKET APP |bracketApp|)
  (BRACE APP |braceApp|)
  (BRACE WIDTH |qTWidth|)
)) (PROGN (MAKEPROP (CAR X) (CADR X) (CADDR X)))
)

;; from DEF LISP

(REPEAT (IN X '(
  (|:| |DEF-:|)
  (|::| |DEF-::|)
  (ELT DEF-ELT)
  (SETELT DEF-SETELT)
  (LET DEF-LET)
  (COLLECT DEF-COLLECT)
  (LESSP DEF-LESSP)
  (|<| DEF-LESSP)
  (REPEAT DEF-REPEAT)
;;(|TRACE,LET| DEF-TRACE-LET)
  (CATEGORY DEF-CATEGORY)
  (EQUAL DEF-EQUAL)
  (|is| DEF-IS)
  (SEQ DEF-SEQ)
  (|isnt| DEF-ISNT)
  (|where| DEF-WHERE)
)) (PROGN (MAKEPROP (CAR X) '|DEF-TRAN| (CADR X)) (CREATE-SBC (CADR X))))

;; following was in INIT LISP

(REPEAT (IN X '(
  |Polynomial| |UnivariatePoly| |SquareMatrix| |QuotientField|
  )) (MAKEPROP X '|status|
     (CREATE-SBC (INTERNL (STRCONC "status" (STRINGIMAGE X))) )))

(REPEAT (IN X '(
  |UnivariatePoly| |Matrix| |QuotientField| |Gaussian|
  )) (MAKEPROP X '|dataCoerce|
     (CREATE-SBC (INTERNL (STRCONC "coerce" (STRINGIMAGE X))) )))

(REPEAT (IN X '(
  (|Integer| . (INTEGERP |#1|))
  ;; (|Float| . (FLOATP |#1|))
  (|DoubleFloat| . (FLOATP |#1|))
  ;; (|Symbol| . (IDENTP |#1|))
  ;;(|Boolean| . (BOOLEANP |#1|))  worthless predicate is always true
  (|String| . (STRINGP |#1|))
  (|PrimitiveSymbol| . (IDENTP |#1|))
  )) (MAKEPROP (CAR X) '|BasicPredicate| (CDR X)))

(MAKEPROP '|Integer| '|Subsets|
  '((|PositiveInteger| . (|>| * 0))
    (|NonNegativeInteger| . (|>=| * 0))
    (|NegativeInteger| . (|<| * 0))
    (|NonPositiveInteger| . (|<=| * 0))
    (|NonZeroInteger| . (^= * 0))
    (|SingleInteger| . (SMINTP *))
    ))

(MAKEPROP '|NonNegativeInteger| '|Subsets| '(
  (|PositiveInteger| . (|>| * 0))
  ))

(MAKEPROP '|NonPositiveInteger| '|Subsets| '(
  (|NegativeInteger| . (|<| * 0))
  ))

(FLAG '(|Union| |Record| |Enumration| |Mapping| |Enumeration|) 'FUNCTOR)

(FLAG '(* + AND OR PROGN) 'NARY)

(REPEAT (IN X '(
  (|Record| |mkRecordFunList|)
  (|Union| |mkUnionFunList|)
  (|Mapping| |mkMappingFunList|)
  (|Enumeration| |mkEnumerationFunList|)
)) (MAKEPROP (CAR X) '|makeFunctionList| (CREATE-SBC (CADR X))))

(REPEAT (IN X '(
  (|<=| |parseLessEqual|)
  (|>| |parseGreaterThan|)
  (|>=| |parseGreaterEqual|)
  (|$<=| |parseDollarLessEqual|)
  (|$>| |parseDollarGreaterThan|)
  (|$>=| |parseDollarGreaterEqual|)
  ($^= |parseDollarNotEqual|)
  (^ |parseNot|)
  (^= |parseNotEqual|)
  (\: |parseColon|)
  (|::| |parseCoerce|)
  (@ |parseAtSign|)
;;These two lines were commented out in the original sources.
;;However both of these lines involved control characters that
;;latex cannot handle. control-V and control-H should be the
;;actual control characters, not the text replacement shown here.
;;(control-V |parseUpArrow|) 
;;(|control-H| |parseLeftArrow|) 
  (|and| |parseAnd|)
  (CATEGORY |parseCategory|)
  (|construct| |parseConstruct|)
  (DEF |parseDEF|)
  (|eqv| |parseEquivalence|)
  (|exit| |parseExit|)
  (|has| |parseHas|)
  (IF |parseIf|)
  (|implies| |parseImplies|)
  (IN |parseIn|)
  (INBY |parseInBy|)
  (|is| |parseIs|)
  (|isnt| |parseIsnt|)
  (|Join| |parseJoin|)
  (|leave| |parseLeave|)
  (LET |parseLET|)
  (LETD |parseLETD|)
  (MDEF |parseMDEF|)
  (|not| |parseNot|)
  (|or| |parseOr|)
  (|pretend| |parsePretend|)
  (|return| |parseReturn|)
  (SEGMENT |parseSegment|)
  (SEQ |parseSeq|)
  (VCONS |parseVCONS|)
  (|where| |parseWhere|)
;;  (|xor| |parseExclusiveOr|)
)) (MAKEPROP (CAR X) '|parseTran| (CADR X)))

(REPEAT (IN X '(
  (|with| |postWith|)
  (|Scripts| |postScripts|)
  (/ |postSlash|)
  (|construct| |postConstruct|)
  (|Block| |postBlock|)
  (QUOTE |postQUOTE|)
  (COLLECT |postCollect|)
  (|:BF:| |postBigFloat|)
  (|in| |postin|)  ;" the infix operator version of in"
  (IN |postIn|)	 ;" the iterator form of in"
  (REPEAT |postRepeat|)
  (|TupleCollect| |postTupleCollect|)
  (|add| |postAdd|)
  (|Reduce| |postReduce|)
  (\, |postComma|)
  (\; |postSemiColon|)
  (|where| |postWhere|)
  (|::| |postColonColon|)
  (\: |postColon|)
  (@ |postAtSign|)
  (|pretend| |postPretend|)
  (|if| |postIf|)
  (|Join| |postJoin|)
  (|Signature| |postSignature|)
  (CATEGORY |postCategory|)
;;(	 |postDef|)
  (== |postDef|)
  (|==>| |postMDef|)
  (|->| |postMapping|)
  (|=>| |postExit|)
  (|@Tuple| |postTuple|)
)) (MAKEPROP (CAR X) '|postTran| (CADR X)))

(MAKEPROP 'INTEGER 'ISFUNCTION 'FIXP)
(MAKEPROP '|Integer| '|isFunction| '|IsInteger|)
(MAKEPROP '|Boolean| '|isFunction| '|isBoolean|)

;; Many of the following are now in COMPAT LISP
(REPEAT (IN X '(
  (+ PLUS)
  (|and| AND)
  (|append| APPEND)
  (|apply| APPLY)
  (|atom| ATOM)
  (|brace| REMDUP)
  (|car| CAR)
  (|cdr| CDR)
  (|cons| CONS)
  (|copy| COPY)
  (|croak| CROAK)
  (|drop| DROP)
  (|exit| EXIT)
  (|false| NIL)
  (|first| CAR)
  (|genvar| GENVAR)
  (|in| |member|)
  (|is| IS)
  (|lastNode| LASTNODE)
  (|list| LIST)
  (|mkpf| MKPF)
  (|nconc| NCONC)
  (|nil| NIL)
  (|not| NULL)
  (|NOT| NULL)
  (|nreverse| NREVERSE)
  (|null| NULL)
  (|or| OR)
  (|otherwise| 'T)
  (|removeDuplicates| REMDUP)
  (|rest| CDR)
  (|return| RETURN)
  (|reverse| REVERSE)
  (|setDifference| SETDIFFERENCE)
  (|setIntersection| |intersection|)
  (|setPart| SETELT)
  (|setUnion| |union|)
  (|size| SIZE)
  (|strconc| STRCONC)
  (|substitute| MSUBST)
  (SUBST MSUBST)
  (|take| TAKE)
  (|true| 'T)
  (|where| WHERE)
  (* TIMES)
  (** EXPT)
  (^ NULL)
  (^= NEQUAL)
  (- SPADDIFFERENCE)
  (/ QUOTIENT)
  (= EQUAL)
  (ASSOC  |assoc|)
  (DELETE |delete|)
  (GET GETL)
  (INTERSECTION |intersection|)
  (LAST |last|)
  (MEMBER |member|)
  (RASSOC |rassoc|)
  (READ VMREAD)
  (READ-LINE |read-line|)
  (REDUCE SPADREDUCE)
  (REMOVE |remove|)
  (\| SUCHTHAT)
  (T T$)
  (UNION |union|)
)) (MAKEPROP (CAR X) 'RENAME (CDR X)))

;; these are accessor names for fields in data structures. Thus one would
;; write datastructure.setName 
(REPEAT (IN X '(
  (|setName|  0)
  (|setLabel| 1)
  (|setLevel| 2)
  (|setType|  3)
  (|setVar|   4)
  (|setLeaf|  5)
  (|setDef|   6)
  (|aGeneral| 4)
  (|aMode| 1)
  (|aModeSet| 3)
  (|aTree| 0)
  (|attributes| CADDR)
  (|aValue| 2)
  (|cacheCount| CADDDDR)
  (|cacheName| CADR)
  (|cacheReset| CADDDR)
  (|cacheType| CADDR)
  (|env| CADDR)
  (|expr| CAR)
  (|first| CAR)
  (|mmCondition| CAADR)
  (|mmDC| CAAR)
  (|mmImplementation| CADADR)
  (|mmSignature| CDAR)
  (|mmTarget| CADAR)
  (|mode| CADR)
  (|op| CAR)
  (|opcode| CADR)
  (|opSig| CADR)
  (|rest| CDR)
  (|sig| CDDR)
  (|source| CDR)
  (|streamCode| CADDDR)
  (|streamDef| CADDR)
  (|streamName| CADR)
  (|target| CAR)
)) (MAKEPROP (CAR X) '|SEL,FUNCTION| (CADR X)))

(REPEAT (IN X '(
  (\| |compSuchthat|)
  (\@ |compAtSign|)
  (|:| |compColon|)
  (\:\: |compCoerce|)
  (|+->| |compLambda|)
  (QUOTE |compQuote|)
;; We have a similar problem with the control-G character.
;;  (control-G |compContained|)
  (|add| |compAdd|)
  (CAPSULE |compCapsule|)
  (|case| |compCase|)
  (CATEGORY |compCategory|)
  (COLLECT |compRepeatOrCollect|)
  (COLLECTV |compCollectV|)
  (CONS |compCons|)
  (|construct| |compConstruct|)
  (DEF |compDefine|)
  (|elt| |compElt|)
  (|exit| |compExit|)
  (|has| |compHas|)
  (IF |compIf|)
  (|import| |compImport|)
  (|is| |compIs|)
  (|Join| |compJoin|)
  (|leave| |compLeave|)
  (LET |compSetq|)
  (|ListCategory| |compConstructorCategory|)
  (MDEF |compMacro|)
  (|pretend| |compPretend|)
  (|Record| |compCat|)
  (|RecordCategory| |compConstructorCategory|)
  (REDUCE |compReduce|)
  (REPEAT |compRepeatOrCollect|)
  (|return| |compReturn|)
  (SEQ |compSeq|)
  (SETQ |compSetq|)
  (|String| |compString|)
  (|SubDomain| |compSubDomain|)
  (|SubsetCategory| |compSubsetCategory|)
  (|Union| |compCat|)
  (|Mapping| |compCat|)
  (|UnionCategory| |compConstructorCategory|)
  (VECTOR |compVector|)
  (|VectorCategory| |compConstructorCategory|)
  (|where| |compWhere|)
)) (MAKEPROP (CAR X) 'SPECIAL (CREATE-SBC (CADR X))))

(REPEAT (IN X '(
  (\: |compColonInteractive|)
  (DEF |compDefineInteractive|)
  (|construct| |compConstructInteractive|)
  (LET |compSetqInteractive|)
)) (MAKEPROP (CAR X) 'INTERACTIVE (CREATE-SBC (CADR X))))

@
\begin{verbatim}

Operating system interface

The only non-common lisp functions used in this file are in this section.
The following functions are provided:

  OsRunProgram program &rest args  
     Run the named program with given arguments.
     All I/O is to the current places.
     Value returned is implementation-dependent.

  OsRunProgramToStream program &rest args
     Run the named program  with given arguments.
     Input and error output to the current places.
     Value returned is a stream of the program's standard output.

  OsEnvVarCharacter
     The character which indicates OS environment variables in a string.
     On Unix this is "$".

  OsEnvGet name
     name is a string or a symbol
     The string associated with the given name is returned.
     This is from the environment on Unix. On CMS globalvars could be used.

  OsProcessNumber
     Returns a unique number associated with the current session.
     On Unix this is the process id.  
     The same workspace started a second time must give a different result.

\end{verbatim}
<<*>>=
(defun |OsRunProgram| (program &rest args)
 (kcl-os-run-program     program args)
 nil )

(defun |OsRunProgramToStream| (program &rest args)
  (kcl-os-run-program-to-stream       program args)
  (make-string-output-stream "") )

(defvar |OsEnvVarCharacter| #\$)

(defun |OsEnvGet| (sym)
 (kcl-os-env-get     sym)
   "" )

(defun |OsProcessNumber| ()
  (kcl-os-process-number)
  42 )


;;;
;;; KCL-only implementations
;;;

(defun kcl-os-run-program (program args)
  (system (format nil "~{~a ~}" (cons program args))) )

(defun kcl-os-run-program-to-stream (program args)
  (system (format nil "~{~a ~}" (cons program args))) )

(defun kcl-os-env-get (sym) 
  (system:getenv (string sym)) )

(defun kcl-os-process-number () 
  77 )

;;;;
;;;; Time
;;;;

(defun |TimeStampString| ()
  (multiple-value-bind (sec min hr mody mo yr wkdy daylight zone)
     (get-decoded-time)
     (declare (ignore wkdy daylight zone))
     (format nil "~2,'0d/~2,'0d/~2,'0d ~2,'0d:~2,'0d:~2,'0d" 
       yr mo mody hr min sec) ))
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; Lisp Interface
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun |LispReadFromString| (str &optional (startpos 0))
  (prog (ob nextpos)
        (multiple-value-setq
         (ob nextpos)
         (read-from-string str nil nil :start startpos) )
        (return (list ob nextpos)) ))

(defun |LispEval| (expr)
  (eval expr) )

;;; expr must be a defun, defmacro, etc.
(defun |LispCompile| (expr)
   (eval expr)
   (compile (second expr)) )
   
(defun |LispCompileFileQuietlyToObject| (source object)
   (compile-file source :output-file object :messages nil :warnings nil)) 

(defun |LispLoadFileQuietly| (object)
   (load object :verbose nil :print nil))

(defun |LispCompileFile| (fname)
  (compile-file fname) )

(defun |LispLoadFile| (fname)
  (load fname) )

(defun |LispKeyword| (str)
  (intern str 'keyword) )

;;;
;;; Control
;;;

           
(defmacro |funcall| (&rest args)
  (cons 'funcall args) )

(defmacro |Catch| (tag expr) 
  `(catch ,tag ,expr) )

(defmacro |Throw| (tag expr) 
  `(Throw ,tag ,expr) )

(defmacro |UnwindProtect| (a b)
  `(unwind-protect ,a ,b) )

;;; This macro catches as much as it can.  
;;; Systems with a catchall should use it.  
;;; It is legitimate to not catch anything, if there is no system support.
;;; 
;;; If the result was caught, then tagvar is set to the desination tag
;;; and the thown value is returned.  Otherwise, tagvar is set to nil
;;; and the first result of the expression is returned.

(defmacro |CatchAsCan| (tagvar expr)
  `(progn 
      (setq tagvar nil) 
      ,expr ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; General
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro |Eq| (a b)
  `(eq ,a ,b) )

(defvar |Nil| nil)

(defun |DeepCopy| (x)
  (copy-tree x) )

(defun |SortInPlace| (l pred)
  (sort l pred) )

(defun |Sort| (l pred)
  (sort (copy-tree l) pred) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Streams
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun |Prompt| (line &optional (readfn nil))
  (format *query-io* "~a" line)
  (when readfn (apply readfn (list *query-io*))) )

(defun |PlainError| (&rest args)
  (let ((fmt (plain-print-format-string args)))
       (error fmt args) ))

(defun |PrettyPrint| (expr &optional (outstream *standard-output*))
  (write expr :stream outstream :level nil :length nil :pretty 't :escape 't) 
  (finish-output outstream) )

(defun |PlainPrint| (&rest args)
  (let ((fmt (plain-print-format-string args)))
       (format *standard-output* fmt args) ))

(defun |PlainPrintOn| (stream &rest args)
  (let ((fmt (plain-print-format-string args)))
       (format stream fmt args) ))

(defun plain-print-format-string (l)
  (format nil "~~~d{~~a~~}~~%" (length l)) )


;;; Lucid 1.01 bug:  Must flush output after each write or else
;;;                  strange errors arise from invalid buffer reuse.

(defun |WriteLispExpr| (expr &optional (outstream *standard-output*))
  (let ((*package* (find-package "USER")))
    (declare (special *package*))
    (write expr :stream outstream 
        :level nil :length nil :pretty nil :escape 't ) 
    (finish-output outstream) ))

(defmacro |WriteByte| (byte &rest outstream)
  `(write-byte ,byte ,@outstream) )

(defmacro |WriteChar| (char &rest outstream)
  `(write-char ,char ,@outstream) )

;; Write a string -- no new line.
(defun |WriteString| (string &optional (outstream *standard-output*))
  (format outstream "~a" string) 
  (finish-output outstream) )

;; Write a string then start a new line.
(defun |WriteLine| (string &optional (outstream *standard-output*))
  (write-line string outstream) 
  (finish-output outstream) )    

(defun |ByteFileWriteLine| (string outstream)
  (let ((n (length string)))
    (do ((i 0 (+ i 1)))
        ((= i n))
        (write-byte (char-code (char string i)) outstream) ))
  (write-byte (char-code #\Newline) outstream)
  (finish-output outstream) )



(defun |ReadLispExpr| (&optional (instream *standard-input*))
  (let ((*package* (find-package "USER")))
    (declare (special *package*))
    (read instream nil nil) ))

(defmacro |ReadByte| (instream)
  `(read-byte ,instream nil nil) )

(defmacro |ReadChar| (&rest instream)
  (if instream
    `(read-char ,@instream nil nil) 
    '(read-char *standard-input* nil nil) ))

(defun |ReadLine| (&optional (instream *standard-input*))
  (read-line instream nil nil) )

(defun |ByteFileReadLine| (instream)
  (do ((buf (make-array '(80) 
                :element-type 'string-char 
                :fill-pointer 0
                :adjustable 't ))
       (b (read-byte instream nil nil) (read-byte instream nil nil))
       (c) )

      ((or (null b) (char= (setq c (code-char b)) #\Newline)) buf)
     
      (vector-push-extend c buf) ))

;;; Reads no more than the rest of the current line into the string argument.
;;; The #\Newline is not included in the string.
;;;
;;; The result is an integer, 'T or nil.
;;;   Nil  the stream was already exhausted.
;;;   T    the string was filled before the end of line was reached.
;;;   k    the end of line was reached and k characters were copied.
;;;
;;; If the argument "flags" is passed a cons cell, it is updated
;;; to contain (Eof . Eol).  
;;; Eof indicates whether the end of file was detected.
;;; Eol indicates whether the line was terminated by a #\newline.

(defun |ReadLineIntoString| (string &optional (instream *standard-input*) 
                                              (flags nil) )

  (when (consp flags) (rplaca flags nil) (rplacd flags nil))

  (let ((n (length string))
        (i 0)
        (c (read-char instream nil nil)) )
    
       (loop
         (cond 
           ((null c)
              (when (consp flags) (rplaca flags 't))
              (return (if (= i 0) nil i)) )
           ((char= c #\Newline)
              (when (consp flags) (rplacd flags 't))
              (return i) )
           ((= i n)
              (unread-char c instream)
              (return 't) ))

         (setf (char string i) c)
         (setq i (+ i 1))
         (setq c (read-char instream nil nil)) )))
   

;;; Similar to ReadLineIntoString but reads from a ByteFile.
(defun |ByteFileReadLineIntoString| (string instream &optional (flags nil))

  (when (consp flags) (rplaca flags nil) (rplacd flags nil))

  (let ((n (length string))
        (i 0)
        (b nil)
        (c nil) )
    
       (loop
         (when (= i n) (return 't) )
         (setq b (read-byte instream nil nil)) 
         (when (null b)
           (when (consp flags) (rplaca flags 't))
           (return i) )

         (setq c (code-char b))
         (when (char= c #\Newline)
           (when (consp flags) (rplacd flags 't))
           (return i) )

         (setf (char string i) c)
         (setq i (+ i 1)) )))

(defun |ReadBytesIntoVector| 
           (vector &optional (instream *standard-input*) (flags nil) )

  (when (consp flags) (rplaca flags nil) (rplacd flags nil))

  (let ((n (length vector))
        (i 0)
        (b nil) )
    
       (loop
         (when (= i n) (return 't))
         (setq b (read-byte instream nil nil))
         (when (null b)
           (when (consp flags) (rplaca flags 't))
           (return i) )

         (setf (aref vector i) b)
         (setq i (+ i 1)) )))


(defun |InputStream?| (stream)
   (input-stream-p stream) )

(defun |OutputStream?| (stream)
   (output-stream-p stream) )

;;; Whether the position is a record number or character number is 
;;; implementation specific.  In Common Lisp it is a character number.

(defun |StreamGetPosition| (stream)
  (file-position stream) )

(defun |StreamSetPosition| (stream pos)
  (file-position stream pos))

(defun |StreamSize| (stream)
  (file-length stream))

(defmacro |WithOpenStream| (var stream-form body)
  `(with-open-stream (,var ,stream-form) ,body) )

;;; Copy up to n characters or eof.
;;; Return number of characters actually copied
(defun |StreamCopyChars| (instream outstream n)
  (do ((i 0 (+ i 1))
       (c (read-char instream nil nil) (read-char instream nil nil)) )
      ((or (null c) (= i n))  (finish-output outstream) i)

      (write-char c outstream) ))

(defun |StreamCopyBytes| (instream outstream n)
  (do ((i 0 (+ i 1))
       (b (read-byte instream nil nil) (read-byte instream nil nil)) )
      ((or (null b) (= i n))  (finish-output outstream) i)

      (write-byte b outstream) ))

(defun |StreamEnd?| (instream)
  (null (peek-char nil instream nil nil)) )

(defun |StreamFlush| (&optional (outstream *standard-output*))
  (finish-output outstream) )

(defun |StreamClose| (stream)
  (close stream) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;  Types
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Functions for manipulating values of type Xxxx are prefixed with Xxxx.
;;; E.g., CsetUnion
;;; Values of type Xxxx are suffixed with Xxxx.
;;; E.g., AlphaCset
;;; The primary function for creating object of this type is named Xxxx.
;;; The type-testing predicate is Xxxx?

;;; xx    := Xxxx(args)
;;; val   := XxxxGet(xx, key)  or  XxxxGet(xx, key, default)
;;; val   := XxxxSet(xx, key, val)
;;; val   := XxxxUnset(xx, key)
;;;
;;; xx    := XxxxRemove(val, xx)    XxxxRemoveQ
;;; truth := XxxxMember?(val, xx)   XxxxMemberQ?
;;; xx    := XxxxUnion(xx1, xx2)
;;;
;;; The suffix "Q" means the test involved is "EQ".  "N" between the
;;; the type name and the function name proper means the function is
;;; non-copying (destructive).

;;;
;;; Pathnames
;;;

(defvar |TempFileDirectory| (pathname-directory "/tmp/"))
(defvar |LispFileType| "lisp")
(defvar |FaslFileType| "bbin")

(defun |Pathname| (name &optional (type nil) (dir 'none))
  (if (equal dir 'none)
      (make-pathname :name name :type type :defaults name) 
      (make-pathname :directory dir :name name :type type) ))

(defun |ToPathname| (string)
  (pathname string) )

;;; System-wide unique name on each call.
(defvar *new-pathname-counter* 1)

(defun |NewPathname| (&optional (prefix "t")(type nil)(dir '(:relative)))
   (let ((name 
          (format nil "~a~a-~a" 
            prefix (|OsProcessNumber|) *new-pathname-counter* )))
     (setq *new-pathname-counter* (+ *new-pathname-counter* 1))
     (make-pathname :directory dir :name name :type type) ))
         
;;; System-wide unique name for the current session.
(defun |SessionPathname| (&optional (prefix "t")(type nil)(dir '(:relative)))
   (let ((name (format nil "~a~a" prefix (|OsProcessNumber|))))
     (make-pathname :directory dir :name name :type type) ))
  
(defun |PathnameDirectory| (path)
  (pathname-directory path) )

(defun |PathnameName| (path)
  (pathname-name path) )

(defun |PathnameType| (path) 
  (pathname-type path) )


(defun |PathnameWithType| (path type)
  (make-pathname :type type :defaults path) )

(defun |PathnameWithoutType| (path)
  (make-pathname :type nil :defaults path) )


(defun |PathnameWithDirectory| (path dir)
  (make-pathname :directory dir :defaults path) )

(defun |PathnameWithoutDirectory| (path)
  (make-pathname :directory nil :defaults path) )


(defun |PathnameString| (path)
  (namestring path) )

(defun |PathnameToUsualCase| (path)
  (pathname (|StringLowerCase| (namestring path))) )


;; Lucid 1.01 specific  -- uses representation of directories.
(defun |PathnameAbsolute?| (path)
  (let ((dir (pathname-directory path)))
       (not (and (consp dir) (or
           (eq (car dir) :current) 
           (eq (car dir) :relative) ))) ))

;; Lucid 1.01 specific  -- uses representation of directories.
(defun |PathnameWithinDirectory| (dir relpath)
  (if (|PathnameAbsolute?| relpath)
    (|PlainError| "The path " relpath " cannot be used within directory " dir)
    (make-pathname 
       :directory (append dir (cdr (pathname-directory relpath)))
       :defaults  relpath )))

;; Unix specific -- uses unix file syntax.
(defun |PathnameDirectoryOfDirectoryPathname| (dirpath)
  (pathname-directory 
    (concatenate 'string  (namestring dirpath) "/junk.bar") ))

;; Unix specific -- uses environment variables.
(defun |PathnameWithinOsEnvVar| (varname relpath)
  (let ((envstr (|OsEnvGet| varname)))
    (parse-namestring (concatenate 'string envstr "/" relpath)) ))

;;;
;;; Symbols
;;;


;;!! Worry about packages a later day.  
;;!! For now, the responsibility of setting *package* is on the caller.
(defun |MakeSymbol| (str)
  (let ((a (intern str))) a) ) ; Return only 1 value

(defmacro |Symbol?| (ob)
  `(and ,ob (symbolp ,ob)) )

(defmacro |SymbolString| (sym)
  `(string ,sym) )

;;;
;;; Bits
;;;
(defmacro  |Bit| (x)
  (cond 
   ((eq x 1) 1) 
   ((eq x 0) 0) 
   (x 1) 
   (t 0)))

(defun |Bit?| (x) 
  (or (eql x 1) (eql x 0)) )

(defvar |TrueBit|  1)
(defvar |FalseBit| 0)

(defmacro  |BitOn?|   (b) `(eq ,b 1))

(defmacro |BitOr| (x y)
  `(bit-ior ,x ,y) )

;;;
;;; General Sequences
;;;
;;  ELT and SETELT work on these.

;; Removed because it clashed with size in vmlisp.lisp
;; (defun SIZE (x)  ;; #x in boot generates (SIZE x)
;;  (length x))

;;;
;;; Vectors
;;;
(defun |FullVector| (size &optional (init nil))
  (make-array 
   (list size)
   :element-type 't
   :initial-element init ))

(defun |Vector?| (x)
   (vectorp x) )

;;;
;;; Bit Vectors
;;;

;; Common Lisp simple bit vectors

(defun |FullBvec| (size &optional (init 0))
  (make-array 
   (list size)
   :element-type 'bit
   :initial-element init ))

;;;
;;; Characters
;;;

;;(defun |char| (x) 
;;  (char (string x) 0) )

(defmacro |Char| (x) 
  `(char (string ,x) 0) )

(defmacro |Char?| (c) 
  `(characterp ,c) )
  ;; (or (characterp a) 
  ;;     (and (symbolp a) (= (length (symbol-name a)) 1))))


(defmacro |CharCode| (c)
  `(char-code ,c) )

(defmacro |CharGreater?| (c1 c2) 
  `(char> ,c1 ,c2) )

(defun |CharDigit?| (x)
  (or 
   (and (characterp x) (digit-char-p x))
   (and (stringp x) (= (length x) 1) (digit-char-p (char x 0)))
   (and (symbolp x) (|CharDigit?| (string x))) ))

(defvar |SpaceChar|   #\Space)
(defvar |NewlineChar| #\Newline)

;;;
;;; Character Sets
;;;

(defun |Cset| (str) 
  (let 
   ((cset (make-array
           (list char-code-limit)
           :element-type 'bit
           :initial-element 0 ))
    (len (length str)) )
   
   (do ((i 0 (+ 1 i)))
       ((= i len))
       (setf (sbit cset (char-code (char str i))) 1) )
   cset ))

(defun |CsetMember?| (c cset)
  (eql 1 (sbit cset (char-code c))) )

(defun |CsetUnion| (cset1 cset2)
  (bit-ior cset1 cset2) )

(defun |CsetComplement| (cset)
  (bit-not cset) )

(defun |CsetString| (cset)
  (let 
   ((chars '())
    (len (length cset)))
   (do ((i 0 (+ 1 i)))
       ((= i len))
       (if (eql 1 (sbit cset i)) (push (string (int-char i)) chars)) )
   (apply #'concatenate (cons 'string (nreverse chars))) ))

(defvar |NumericCset|      (|Cset| "0123456789") )
(defvar |LowerCaseCset|    (|Cset| "abcdefghijklmnopqrstuvwxyz") )
(defvar |UpperCaseCset|    (|Cset| "ABCDEFGHIJKLMNOPQRSTUVWXYZ") )
(defvar |AlphaCset|        (|CsetUnion| |LowerCaseCset| |UpperCaseCset|))
(defvar |AlphaNumericCset| (|CsetUnion| |AlphaCset| |NumericCset|) )

;;;
;;; Character Strings 
;;;

;;  Common Lisp simple strings
;;  ELT and SETELT work on these.


(defun |FullString| (size &optional (init #\Space))
  (make-array
   (list size)
   :element-type 'string-char
   :initial-element init ))

(defun |ToString| (ob)
  (string ob) )

(defun |StringImage| (ob)
  (format nil "~a" ob) )

(defun |String?| (ob)
  (stringp ob) )

(defmacro |StringGetCode| (str ix)
  `(char-code (char ,str ,ix)) )

(defun |StringConcat| (&rest l)
  (progn
   (setq l (mapcar #'string l))
   (apply #'concatenate 'string l) ))

(defun |StringFromTo| (string from to)
  (subseq string from (+ to 1)) )

(defun |StringFromToEnd| (string from)
  (subseq string from) )

(defun |StringFromLong| (string from len)
  (subseq string from (+ from len)) )

(defun |StringPrefix?| (pref string)
  (let ((mm (mismatch pref string)))
       (or (not mm) (eql mm (length pref))) ))

(defun |StringUpperCase| (l)
  (cond ((stringp l) (string-upcase l))
        ((symbolp l) (intern (string-upcase (symbol-name l))))
        ((characterp l) (char-upcase l))
        ((atom l) l)
        (t (mapcar #'|StringUpperCase| l)) ))

(defun |StringLowerCase| (l)
  (cond ((stringp l) (string-downcase l))
        ((symbolp l) (intern (string-downcase (symbol-name l))))
        ((characterp l) (char-downcase L))
        ((atom l) l)
        (t (mapcar #'|StringLowerCase| l)) ))

(defun |StringGreater?| (s1 s2)
  (string> s1 s2) )

(defun |StringToInteger| (s)
  (read-from-string s) )

(defun |StringToFloat| (s)
  (read-from-string s) )

(defun |StringLength| (s)
  (length s) )

;;;
;;; Numbers
;;;



(defmacro |Number?|       (x) `(numberp ,x))
(defmacro |Integer?|      (x) `(integerp ,x))
(defmacro |Float?|        (x) `(floatp ,x))

(defmacro |Odd?|     (n)   `(oddp ,n))
(defmacro |Remainder|(a b) `(rem ,a ,b))

(defmacro |DoublePrecision| (x) `(coerce ,x 'double-precision))

(defmacro |Abs|   (x) `(abs  ,x))
(defmacro |Min|   (x &rest yz) `(min ,x ,@yz))
(defmacro |Max|   (x &rest yz) `(max ,x ,@yz))

(defmacro |Exp|   (x) `(exp ,x))
(defmacro |Ln|    (x) `(log ,x))
(defmacro |Log10| (x) `(log ,x 10))
(defmacro |Sin|   (x) `(sin ,x))
(defmacro |Cos|   (x) `(cos ,x))
(defmacro |Tan|   (x) `(tan ,x))
(defmacro |Cotan| (x) `(/ 1.0 (tan ,x)))
(defmacro |Arctan|(x) `(atan ,x))

;;;
;;; Pairs
;;;

(defmacro |Pair?| (x) `(consp ,x))

(defmacro |car|    (x) `(car    ,x))
(defmacro |cdr|    (x) `(cdr    ,x))

(defmacro |caar|   (x) `(caar   ,x))
(defmacro |cadr|   (x) `(cadr   ,x))
(defmacro |cdar|   (x) `(cdar   ,x))
(defmacro |cddr|   (x) `(cddr   ,x))

(defmacro |caaar|  (x) `(caaar  ,x))
(defmacro |caadr|  (x) `(caadr  ,x))
(defmacro |cadar|  (x) `(cadar  ,x))
(defmacro |caddr|  (x) `(caddr  ,x))
(defmacro |cdaar|  (x) `(cdaar  ,x))
(defmacro |cdadr|  (x) `(cdadr  ,x))
(defmacro |cddar|  (x) `(cddar  ,x))
(defmacro |cdddr|  (x) `(cdddr  ,x))

(defmacro |FastCar|    (x) `(car (the cons ,x)))
(defmacro |FastCdr|    (x) `(cdr (the cons ,x)))

(defmacro |FastCaar|   (x) `(|FastCar| (|FastCar| ,x)))
(defmacro |FastCadr|   (x) `(|FastCar| (|FastCdr| ,x)))
(defmacro |FastCdar|   (x) `(|FastCdr| (|FastCar| ,x)))
(defmacro |FastCddr|   (x) `(|FastCdr| (|FastCdr| ,x)))

(defmacro |FastCaaar|  (x) `(|FastCar| (|FastCaar| ,x)))
(defmacro |FastCaadr|  (x) `(|FastCar| (|FastCadr| ,x)))
(defmacro |FastCadar|  (x) `(|FastCar| (|FastCdar| ,x)))
(defmacro |FastCaddr|  (x) `(|FastCar| (|FastCddr| ,x)))
(defmacro |FastCdaar|  (x) `(|FastCdr| (|FastCaar| ,x)))
(defmacro |FastCdadr|  (x) `(|FastCdr| (|FastCadr| ,x)))
(defmacro |FastCddar|  (x) `(|FastCdr| (|FastCdar| ,x)))
(defmacro |FastCdddr|  (x) `(|FastCdr| (|FastCddr| ,x)))

(defmacro |IfCar| (x) `(if (consp ,x) (car ,x)))
(defmacro |IfCdr| (x) `(if (consp ,x) (cdr ,x)))

(defmacro |EqCar| (l a) `(eq (car ,l) ,a))
(defmacro |EqCdr| (l d) `(eq (cdr ,l) ,d))

;;;
;;; Lists
;;;


(defun |ListNReverse| (l)
  (nreverse l) )

(defun |ListIsLength?| (l n)
  (if l (= n 0) (|ListIsLength?| (cdr l) (1- n))) )

;;--------------------> NEW DEFINITION (override in vmlisp.lisp.pamphlet)
(defun |ListMemberQ?| (ob l)
  (member ob l :test #'eq) )

(defun |ListMember?| (ob l)
  (member ob l :test #'equal) )

(defun |ListRemoveQ| (ob l)
  (remove ob l :test #'eq :count 1) )

(defun |ListNRemoveQ| (ob l)
  (delete ob l :test #'eq :count 1) )

(defun |ListRemoveDuplicatesQ| (l)
  (remove-duplicates l :test #'eq) )

(defun |ListUnion| (l1 l2)
  (union l1 l2 :test #'equal) )

(defun |ListUnionQ| (l1 l2)
  (union l1 l2 :test #'eq) )

(defun |ListIntersection| (l1 l2)
  (intersection l1 l2 :test #'equal) )

(defun |ListIntersectionQ| (l1 l2)
  (intersection l1 l2 :test #'eq) )

(defun |ListAdjoin| (ob l)
  (adjoin ob l :test #'equal) )

(defun |ListAdjoinQ| (ob l)
  (adjoin ob l :test #'eq) )

;;;
;;; Association lists
;;;


(defun |AlistAssoc| (key l)
  (assoc key l :test #'equal) )

;;--------------------> NEW DEFINITION (override in vmlisp.lisp.pamphlet)
(defun |AlistAssocQ| (key l)
  (assoc key l :test #'eq) )

(defun |AlistRemove| (key l)
  (let ((pr (assoc key l :test #'equal)))
       (if pr 
           (remove pr l :test #'equal) 
           l) ))

(defun |AlistRemoveQ| (key l)
  (let ((pr (assoc key l :test #'eq)))
       (if pr 
           (remove pr l :test #'eq) 
           l) ))

(defun |AlistAdjoinQ| (pr l)
  (cons pr (|AlistRemoveQ| (car pr) l)) )

(defun |AlistUnionQ| (l1 l2)
  (union l1 l2 :test #'eq :key #'car) )

;;;
;;; Tables
;;;

;;(defmacro |EqTable| ()
;;  `(make-hash-table :test #'eq) )
;;(defmacro |EqualTable| ()
;;  `(make-hash-table :test #'equal) )
;;(defmacro |StringTable| ()
;;  `(make-hash-table :test #'equal) )
;; following is not used and causes CCL problems
;;(defmacro |SymbolTable| ()
;;  `(make-hash-table :test #'eq) )


(defmacro |Table?| (ob)
  `(hash-table-p ,ob) )

(defmacro |TableCount| (tab)
  `(hash-table-count ,tab) )

(defmacro |TableGet| (tab key &rest default)
  `(gethash ,key ,tab ,@default) )

(defmacro |TableSet| (tab key val)
  `(setf (gethash ,key ,tab) ,val) )

(defun |TableUnset| (tab key)
  (let ((val (gethash key tab)))
       (remhash key tab)
       val ))

(defun |TableKeys| (tab)
  (let ((key-list nil))
       (maphash 
        #'(lambda (key val) (declare (ignore val))
        	  (setq key-list (cons key key-list)) )
        tab )
       key-list ))

(defun log10 (u) (log u 10))

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
