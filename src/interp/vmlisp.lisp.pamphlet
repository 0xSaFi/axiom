documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp depsys.lisp}
\author{Lars Ericson, Barry Trager, Martial Schor, Timothy Daly}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents

\begin{chunk}{*}

;      VM LISP EMULATION PACKAGE
;      Lars Ericson, Barry Trager, Martial Schor, tim daly, LVMCL, et al
;      IBM Thomas J. Watson Research Center
;      Summer, 1986
;  see /spad/daly.changes

; This emulation package version is written for Symbolics Common Lisp.
; Emulation commentary refers to LISP/VM, IBM Program Number 5798-DQZ,
; as described in the LISP/VM User's Guide, document SH20-6477-1.
; Main comment section headings refer to sections in the User's Guide.

; If you are using this, you are probably in Common Lisp, yes?

(in-package "VMLISP")

(export '(MAKE-HASHTABLE HPUT* HREM HREMPROP
          CVEC UEQUAL ID HPUTPROP
          HASHTABLE-CLASS))
(import '(BOOT::QENUM ))
(import '(BOOT::STRPOSL ))
(import '(BOOT::STRPOS ))
(import '(BOOT::SIZE ))
(import '(BOOT::DIGITP))
(import '(BOOT::HGET ))
(import '(BOOT::HPUT ))
(import '(BOOT::|startsId?| ))
(import '(BOOT::LOTSOF ))
(import '(BOOT::WRAP))

(setq *features* (adjoin :common-lisp *features*))

;; DEFVARS

(defvar *embedded-functions* nil)

(defvar *comp370-apply* nil "function (name def) for comp370 to apply")

(defvar *fileactq-apply* nil "function to apply in fileactq")

(defvar *lam-name* nil "name to be used by lam macro if non-nil")

(defvar macerrorcount 0  "Put some documentation in here someday")

(defvar *read-place-holder* (make-symbol "%.EOF")
   "default value returned by read and read-line at end-of-file")

;; DEFMACROS


(defmacro |char| (x)
  (if (and (consp x) (eq (car x) 'quote)) (character (cadr x))
    `(character ,x)))

(defmacro closedfn (form)
 `(function ,form))

(defmacro dcq (&rest args)
 (cons 'setqp args))

(defmacro define-macro (f v)
 `(setf (macro-function ,f) (macro-function ,v)))

(defmacro dsetq (&whole form pattern exp)
 (dodsetq form pattern exp))

(defmacro ecq (&rest args)
 (cons 'eqq args))

(defmacro eqcar (x y)
 (let ((test
        (cond
         ((equable y) 'eq)
         ((integerp y) 'i=)
         ('eql))))
  (if (atom x)
   `(and (consp ,x) (,test (qcar ,x) ,y))
    (let ((xx (gensym)))
     `(let ((,xx ,x))
       (and (consp ,xx) (,test (qcar ,xx) ,y)))))))

(defmacro eqq (pattern exp)
 `(,(ecqexp pattern nil) ,exp))

(defmacro |equal| (x y)
 `(equalp ,x ,y))

(defmacro evalandfileactq (name &optional (form name))
 `(eval-when (eval load) ,form))  

(defmacro exit (&rest value)
 `(return-from seq ,@value))

(defmacro i= (x y) ;; integer equality
  (if (typep y 'fixnum)
      (let ((gx (gensym)))
        `(let ((,gx ,x))
           (and (typep ,gx 'fixnum) (eql (the fixnum ,gx) ,y))))
    (let ((gx (gensym)) (gy (gensym)))
      `(let ((,gx ,x) (,gy ,y))
         (cond ((and (typep ,gx 'fixnum) (typep ,gy 'fixnum))
                (eql (the fixnum ,gx) (the fixnum ,gy)))
               ((eql (the integer ,gx) (the integer,gy))))))))

(defmacro ifcar (x)
  (if (atom x)
      `(and (consp ,x) (qcar ,x))
    (let ((xx (gensym)))
      `(let ((,xx ,x))
         (and (consp ,xx) (qcar ,xx))))))

(defmacro ifcdr (x)
  (if (atom x)
      `(and (consp ,x) (qcdr ,x))
    (let ((xx (gensym)))
      `(let ((,xx ,x))
         (and (consp ,xx) (qcdr ,xx))))))

(defmacro lam (&rest body)
 (list 'quote (*lam (copy-tree body))))

(defmacro lastnode (l)
 `(last ,l))

(defmacro lastpair (l)
 `(last ,l))

(defmacro lessp (&rest args)
 `(< ,@args))

(defmacro makestring (a) a)

(defmacro mapelt (f vec)
 `(map 'vector ,f ,vec))

(defmacro minus (x)
 `(- ,x))

(defmacro mrp (x)
 `(special-form-p ,x))

(defmacro namederrset (id iexp &rest item)
 (declare (ignore item))
  `(catch ,id ,iexp))

(defmacro ne (a b) `(not (equal ,a ,b)))

;;; This may need adjustment in CCL where NEQ means (NOT (EQUAL ..)))
(defmacro neq (a b) `(not (eq ,a ,b)))

(defmacro nreverse0 (x)
  (if (atom x)
      `(if (atom ,x) ,x (nreverse ,x))
    (let ((xx (gensym)))
      `(let ((,xx ,x))
         (if (atom ,xx) ,xx (nreverse ,xx))))))

(defmacro nump (n)
 `(numberp ,n))

(defmacro |opOf| (x) ;(if (atom x) x (qcar x))
  (if (atom x)
      `(if (consp ,x) (qcar ,x) ,x)
    (let ((xx (gensym)))
      `(let ((,xx ,x))
         (if (consp ,xx) (qcar ,xx) ,xx)))))

;(defmacro pairp (x)
; `(consp ,x)) 

(defmacro plus (&rest args)
 `(+ ,@ args))

(defmacro qassq (a b) `(assq ,a ,b))

(defmacro qcar (x)
 `(car (the cons ,x)))

(defmacro qfirst (x)
 `(car (the cons ,x)))

(defmacro qcdr (x)
 `(cdr (the cons ,x)))

(defmacro qrest (x)
 `(cdr (the cons ,x)))

(defmacro qcaar (x)
 `(car (the cons (car (the cons ,x)))))

(defmacro qcadr (x)
 `(car (the cons (cdr (the cons ,x)))))

(defmacro qsecond (x)
 `(car (the cons (cdr (the cons ,x)))))

(defmacro qcdar (x)
 `(cdr (the cons (car (the cons ,x)))))

(defmacro qcddr (x)
 `(cdr (the cons (cdr (the cons ,x)))))

(defmacro qcaaar (x)
 `(car (the cons (car (the cons (car (the cons ,x)))))))
(defmacro qcaadr (x)
 `(car (the cons (car (the cons (cdr (the cons ,x)))))))
(defmacro qcadar (x)
 `(car (the cons (cdr (the cons (car (the cons ,x)))))))
(defmacro qcaddr (x)
 `(car (the cons (cdr (the cons (cdr (the cons ,x)))))))
(defmacro qthird (x)
 `(car (the cons (cdr (the cons (cdr (the cons ,x)))))))
(defmacro qcdaar (x)
 `(cdr (the cons (car (the cons (car (the cons ,x)))))))
(defmacro qcdadr (x)
 `(cdr (the cons (car (the cons (cdr (the cons ,x)))))))
(defmacro qcddar (x)
 `(cdr (the cons (cdr (the cons (car (the cons ,x)))))))
(defmacro qcdddr (x)
 `(cdr (the cons (cdr (the cons (cdr (the cons ,x)))))))

(defmacro qcaaaar (x)
 `(car (the cons (car (the cons (car (the cons (car (the cons ,x)))))))))
(defmacro qcaaadr (x)
 `(car (the cons (car (the cons (car (the cons (cdr (the cons ,x)))))))))
(defmacro qcaadar (x)
 `(car (the cons (car (the cons (cdr (the cons (car (the cons ,x)))))))))
(defmacro qcaaddr (x)
 `(car (the cons (car (the cons (cdr (the cons (cdr (the cons ,x)))))))))
(defmacro qcadaar (x)
 `(car (the cons (cdr (the cons (car (the cons (car (the cons ,x)))))))))
(defmacro qcadadr (x)
 `(car (the cons (cdr (the cons (car (the cons (cdr (the cons ,x)))))))))
(defmacro qcaddar (x)
 `(car (the cons (cdr (the cons (cdr (the cons (car (the cons ,x)))))))))
(defmacro qcadddr (x)
 `(car (the cons (cdr (the cons (cdr (the cons (cdr (the cons ,x)))))))))
(defmacro qfourth (x)
 `(car (the cons (cdr (the cons (cdr (the cons (cdr (the cons ,x)))))))))
(defmacro qcdaaar (x)
 `(cdr (the cons (car (the cons (car (the cons (car (the cons ,x)))))))))
(defmacro qcdaadr (x)
 `(cdr (the cons (car (the cons (car (the cons (cdr (the cons ,x)))))))))
(defmacro qcdadar (x)
 `(cdr (the cons (car (the cons (cdr (the cons (car (the cons ,x)))))))))
(defmacro qcdaddr (x)
 `(cdr (the cons (car (the cons (cdr (the cons (cdr (the cons ,x)))))))))
(defmacro qcddaar (x)
 `(cdr (the cons (cdr (the cons (car (the cons (car (the cons ,x)))))))))
(defmacro qcddadr (x)
 `(cdr (the cons (cdr (the cons (car (the cons (cdr (the cons ,x)))))))))
(defmacro qcdddar (x)
 `(cdr (the cons (cdr (the cons (cdr (the cons (car (the cons ,x)))))))))
(defmacro qcddddr (x)
 `(cdr (the cons (cdr (the cons (cdr (the cons (cdr (the cons ,x)))))))))

(defmacro qlength (a)
 `(length ,a))

(defmacro qrefelt (vec ind)
 `(svref ,vec ,ind))

(defmacro qrplaca (a b)
 `(rplaca (the cons ,a) ,b))

(defmacro qrplacd (a b)
 `(rplacd (the cons ,a) ,b))

(defmacro qrplq (&whole form pattern exp)
 (if (or (consp pattern) (simple-vector-p pattern))
  `(,(rcqexp pattern) ,exp)
   (macro-invalidargs 'qrplq form "form must be updateable.")))

(defmacro qsdec1 (x)
 `(the fixnum (1- (the fixnum ,x))))

(defmacro qsetq (&whole form pattern exp)
 (declare (ignore form))
  `(,(dcqexp pattern '=) ,exp))

(defmacro qsetrefv (vec ind val)
 `(setf (svref ,vec (the fixnum ,ind)) ,val))

(defmacro qsetvelt (vec ind val)
 `(setf (svref ,vec (the fixnum ,ind)) ,val))

(defmacro qsetvelt-1 (vec ind val)
 `(setf (svref ,vec (the fixnum (1- (the fixnum ,ind)))) ,val))

(defmacro qsinc1 (x)
 `(the fixnum (1+ (the fixnum ,x))))

(defmacro qsleftshift (a b)
 `(the fixnum (ash (the fixnum ,a) (the fixnum ,b))))

(defmacro qsminusp (x)
 `(minusp (the fixnum ,x)))

(defmacro qstringlength (x)
 `(the fixnum (length (the simple-string ,x))))

(defmacro qvelt (vec ind)
 `(svref ,vec (the fixnum ,ind)))

(defmacro qvelt-1 (vec ind)
 `(svref ,vec (the fixnum (1- (the fixnum ,ind)))))

(defmacro qvmaxindex (x)
 `(the fixnum (1- (the fixnum (length (the simple-vector ,x))))))

(defmacro qvsize (x)
 `(the fixnum (length (the simple-vector ,x))))

(defmacro refvecp (v) `(simple-vector-p ,v))

(defmacro resetq (a b)
 `(prog1 ,a (setq ,a ,b)))

(defmacro rplq (&whole form exp pattern)
 (if (or (consp pattern) (simple-vector-p pattern))
  `(,(rcqexp pattern) ,exp)
   (macro-invalidargs 'rplq form "form must be updateable.")))

(defmacro rvecp (v)
 `(typep ,v '(vector float)))

(defmacro setandfileq (id item)
 `(eval-when (eval load) 
   (setq ,id ,item)
   (lam\,fileactq ',id (list 'setq ',id (list 'quote ,id)))))

(defmacro setelt (vec ind val)
 `(setf (elt ,vec ,ind) ,val))

(defmacro setqp (&whole form pattern exp)
 (declare (ignore form))
  `(,(dcqexp pattern '=) ,exp))

(defmacro seq (&rest form)
  (let* ((body (reverse form))
         (val `(return-from seq ,(pop body))))
    (nsubstitute '(progn) nil body) ;don't treat NIL as a label
    `(block seq (tagbody ,@(nreverse body) ,val))))

(defmacro sfp (x)
 `(special-form-p ,x))

(defmacro |shoeConsole| (line)
 `(write-line ,line *terminal-io*))

(defmacro |shoeInputFile| (filespec)
 `(open ,filespec :direction :input :if-does-not-exist nil))

(defmacro stringlength (x)
 `(length (the string ,x)))

(defmacro subrp (x)
 `(compiled-function-p ,x))

(defmacro sub1 (x)
 `(1- ,x))

(defmacro throw-protect (exp1 exp2)
 `(unwind-protect ,exp1 ,exp2))

(defmacro times (&rest args)
 `(* ,@args))

(defmacro vec-setelt (vec ind val)
 `(setf (svref ,vec ,ind) ,val))

(defmacro vecp (v) `(simple-vector-p ,v))

(defmacro zero? (x)
  `(and (typep ,x 'fixnum) (zerop (the fixnum ,x))))

;; defuns

(defun define-function (f v)
 (setf (symbol-function f) v))

;;; functions used somewhere

(defun COMP370 (fnlist)
  (cond ((atom (car fnlist)) (list (COMPILE1 fnlist)))
        (t (MAPCAR #'(lambda (x) (COMPILE1 x)) fnlist))))

(defun COMPILE1 (fn)
  (let* (nargs
         (fname (car fn))
         (lamda (cadr fn))
         (ltype (car lamda))
         *vars* *decl* args
         (body (cddr lamda)))
    (declare (special *vars* *decl*))
    (if (eq ltype 'LAM)
        (let ((*lam-name* (intern (concat fname "\,LAM"))))
          (setq lamda (eval lamda) ltype (car lamda) body (cddr lamda))))
    (let ((dectest (car body)))
      (if (and (eqcar dectest 'declare) (eqcar (cadr dectest) 'special))
          (setq *decl* (cdr (cadr dectest)) body (cdr body))))
    (setq args (remove-fluids (cadr lamda)))
    (cond ((and (eq ltype 'lambda) (simple-arglist args)) (setq nargs args))
          (t (setq nargs (gensym))
             (setq body `((dsetq ,args  ,nargs) ,@body))
             (cond
              ((eq ltype 'lambda)
                (setq nargs `(&rest ,nargs &aux ,@*vars*)))
              ((eq ltype 'mlambda)
                (setq nargs `(&whole ,nargs &rest ,(gensym) &aux ,@*vars*)))
              (t (error "bad function type")))))
    (cond (*decl* (setq body (cons `(declare (special ,@ *decl*)) body))))
    (setq body
          (cond ((eq ltype 'lambda) `(defun ,fname ,nargs . ,body))
                ((eq ltype 'mlambda) `(defmacro ,fname ,nargs . ,body))))
    (if *COMP370-APPLY* (funcall *COMP370-APPLY* fname body))

    body))

(defun *LAM (body)
  (cond  ((NOT (ISQUOTEDP (first BODY))) (cons 'LAMBDA BODY))
         ((LET* ((BV (DEQUOTE (first BODY)))
                 (CONTROL (QUOTESOF (first BODY)))
                 (BODY (cdr BODY))
                 (ARGS (GENSYM))
                 (INNER-FUNC (or *lam-name* (gentemp))))
            (COMP370 (LIST INNER-FUNC `(LAMBDA ,BV . ,BODY)))
            `(MLAMBDA ,ARGS
                      (CONS (QUOTE ,INNER-FUNC)
                            (WRAP (cdr ,ARGS) ',CONTROL)))))))

(defun QUOTESOF (BV)
  (COND ((NOT (consp BV)) NIL)
      ((EQ (first BV) 'QUOTE) 'QUOTE)
      ((CONS (COND ((NOT (consp (first BV))) nil)
                   ((EQ (QCAAR BV) 'QUOTE) 'QUOTE)
                   (T NIL))
             (QUOTESOF (cdr BV))))))

(defun ISQUOTEDP (bv)
  (COND ((NOT (consp BV)) NIL)
        ((EQ (first BV) 'QUOTE))
        ((AND (consp (first BV)) (EQ (QCAAR BV) 'QUOTE)))
        ((ISQUOTEDP (cdr BV)))))


(defun remove-fluids (arglist &aux f v) ;updates specials *decl* and *vars*
  (declare (special *decl* *vars*))
   (cond ((null arglist) arglist)
         ((symbolp arglist) (push arglist *vars*) arglist)
                ;if atom but not symbol, ignore value
         ((atom arglist) (push (setq arglist (gentemp)) *vars*) arglist)
         ((and (setq f (car arglist))
               (eq f 'fluid)
               (listp (cdr arglist))
               (setq v (cadr arglist))
               (identp v)
               (null (cddr arglist)))
          (push v *decl*)
          (push v *vars*)
          v)
         (t (cons (remove-fluids (car arglist))
                  (remove-fluids (cdr arglist))))))

(defun simple-arglist (arglist)
  (or (null arglist)
      (and (consp arglist) (null (cdr (last arglist)))
           (every #'symbolp arglist))))

; 7.0 Macros

; 7.2 Creating Macro Expressions

; 5.2 Functions

; 5.2.2 Lambda Expressions

; 7.4 Using Macros

; Beats me how to simulate macro expansion "in the environment of sd"...:

(defun MDEF (arg item &optional sd)
 (declare (ignore sd))
  (macroexpand `(,arg ,item)))

; 8.0 Operator Definition and Transformation

; 8.1 Definition and Transformation Operations

(defun COMP370 (fnlist)
  (cond ((atom (car fnlist)) (list (COMPILE1 fnlist)))
        (t (MAPCAR #'(lambda (x) (COMPILE1 x)) fnlist))))

(defun COMPILE1 (fn)
  (let* (nargs
         (fname (car fn))
         (lamda (cadr fn))
         (ltype (car lamda))
         *vars* *decl* args
         (body (cddr lamda)))
    (declare (special *vars* *decl*))
    (if (eq ltype 'LAM)
        (let ((*lam-name* (intern (concat fname "\,LAM"))))
          (setq lamda (eval lamda) ltype (car lamda) body (cddr lamda))))
    (let ((dectest (car body)))
      (if (and (eqcar dectest 'declare) (eqcar (cadr dectest) 'special))
          (setq *decl* (cdr (cadr dectest)) body (cdr body))))
    (setq args (remove-fluids (cadr lamda)))
    (cond ((and (eq ltype 'lambda) (simple-arglist args)) (setq nargs args))
          (t (setq nargs (gensym))
             (setq body `((dsetq ,args  ,nargs) ,@body))
             (cond
              ((eq ltype 'lambda)
                (setq nargs `(&rest ,nargs &aux ,@*vars*)))
              ((eq ltype 'mlambda)
                (setq nargs `(&whole ,nargs &rest ,(gensym) &aux ,@*vars*)))
              (t (error "bad function type")))))
    (cond (*decl* (setq body (cons `(declare (special ,@ *decl*)) body))))
    (setq body
          (cond ((eq ltype 'lambda) `(defun ,fname ,nargs . ,body))
                ((eq ltype 'mlambda) `(defmacro ,fname ,nargs . ,body))))
    (if *COMP370-APPLY* (funcall *COMP370-APPLY* fname body))

    body))

(defun *LAM (body)
  (cond  ((NOT (ISQUOTEDP (first BODY))) (cons 'LAMBDA BODY))
         ((LET* ((BV (DEQUOTE (first BODY)))
                 (CONTROL (QUOTESOF (first BODY)))
                 (BODY (cdr BODY))
                 (ARGS (GENSYM))
                 (INNER-FUNC (or *lam-name* (gentemp))))
            (COMP370 (LIST INNER-FUNC `(LAMBDA ,BV . ,BODY)))
            `(MLAMBDA ,ARGS
                      (CONS (QUOTE ,INNER-FUNC)
                            (WRAP (cdr ,ARGS) ',CONTROL)))))))

(defun QUOTESOF (BV)
  (COND ((NOT (consp BV)) NIL)
      ((EQ (first BV) 'QUOTE) 'QUOTE)
      ((CONS (COND ((NOT (consp (first BV))) nil)
                   ((EQ (QCAAR BV) 'QUOTE) 'QUOTE)
                   (T NIL))
             (QUOTESOF (cdr BV))))))

; 9.4 Vectors and Bpis

(defun IVECP (x) (and (vectorp x) (subtypep (array-element-type x) 'integer)))

(defun mbpip (item) (and (symbolp item) ;cannot know a compiled macro in CLISP
                         (compiled-function-p (macro-function item))))

(defun FBPIP (item) (or (compiled-function-p item)
                        (and (symbolp item) (fboundp item)
                             (not (macro-function item))
                             (compiled-function-p (symbol-function item)))))

; 9.5 Identifiers

(defun gensymp (x) (and (symbolp x) (null (symbol-package x))))

(defun dig2fix (x)
  (if (symbolp x)
    (digit-char-p (char (symbol-name x) 0))
    (digit-char-p x)))

(defun LN (x) (LOG x))

(defun LOG2 (x) (LOG x 2.0))
(defun |log| (x) (LOG x 10.0))

; 9.13 Streams

; 10.0 Control Structures

;;; 20101207 tpd moving this from vmlisp breaks the build.
(defmacro maxindex (x)
 `(the fixnum (1- (the fixnum (length ,x)))))


; 10.8.4 Auxiliary Operators

; 11.0 Operations on Identifiers

; 11.1 Creation

; 11.2 Accessing

(defun put (sym ind val) (setf (get sym ind) val))

(defun QUOTIENT (x y)
  (cond ((or (floatp x) (floatp y)) (lisp:/ x y))
        (t (truncate x y))))

(defun REMAINDER (x y)
  (if (and (integerp x) (integerp y))
      (rem x y)
      (- x (* y (QUOTIENT x y)))))

(defun DIVIDE (x y)
  (if (and (integerp x) (integerp y))
      (multiple-value-list (truncate x y))
      (list (QUOTIENT x y) (REMAINDER x y))))

; 13.3 Updating

; 14.0 Operations on Lists

; 14.1 Creation

(defun |remove| (list item &optional (count 1))
  (if (integerp count)
      (remove item list :count count :test #'equalp)
      (remove item list :test #'equalp)))

(defun |last| (x) (car (lastpair x)))

(DEFUN |assoc| (X Y)
  "Return the pair associated with key X in association list Y."
  ; ignores non-nil list terminators
  ; ignores non-pair a-list entries
  (cond ((symbolp X)
         (PROG NIL
               A  (COND ((ATOM Y) (RETURN NIL))
                        ((NOT (consp (CAR Y))) )
                        ((EQ (CAAR Y) X) (RETURN (CAR Y))) )
               (SETQ Y (CDR Y))
               (GO A)))
        ((or (numberp x) (characterp x))
         (PROG NIL
               A  (COND ((ATOM Y) (RETURN NIL))
                        ((NOT (consp (CAR Y))) )
                        ((EQL (CAAR Y) X) (RETURN (CAR Y))) )
               (SETQ Y (CDR Y))
               (GO A)))
        (t
         (PROG NIL
               A  (COND ((ATOM Y) (RETURN NIL))
                        ((NOT (consp (CAR Y))) )
                        ((EQUAL (CAAR Y) X) (RETURN (CAR Y))) )
               (SETQ Y (CDR Y))
               (GO A)))))
; 14.5 Updating

; 14.6 Miscellaneous

(defun QSORT (l)
 (declare (special sortgreaterp))
  (NREVERSE (sort (copy-seq l) SORTGREATERP)))

(defun SORTBY (keyfn l)
 (declare (special sortgreaterp))
  (nreverse (sort (copy-seq l) SORTGREATERP :key keyfn)))

; 16.0 Operations on Vectors

; 16.1 Creation

\end{chunk}
Waldek Hebisch points out that, in the expression:
\begin{verbatim}
  reduce(+,[1.0/i for i in 1..20000])
\end{verbatim}
a significant amount of the time is spent in this function.
A special case was added to significantly reduce the execution time.
This was a problem in GCL as of 2.6.8pre and may be fixed in future
releases. If it is fixed then the original definition, which was
\begin{verbatim}
(defun LIST2VEC (list) (coerce list 'vector))
\end{verbatim}
can be restored.
\begin{chunk}{*}
(defun LIST2VEC (list)
 (if (consp list)
  (let* ((len (length list))
         (vec (make-array len)))
    (dotimes (i len)
     (setf (aref vec i) (pop list)))
    vec)
  (coerce list 'vector)))

(define-function 'LIST2REFVEC #'LIST2VEC)

; 16.2 Accessing


; 17.0 Operations on Character and Bit Vectors

(defun charp (a) (or (characterp a)
                     (and (identp a) (= (length (symbol-name a)) 1))))

(defun CHAR2NUM (c) (char-code (character c)))

(defun CGREATERP (s1 s2) (string> (string s1) (string s2)))

(define-function 'STRGREATERP #'CGREATERP)

; 17.1 Creation

(define-function 'strconc #'concat)

(defun make-cvec (sint) (make-array sint :fill-pointer 0 :element-type 'string-char))

(define-function 'getstr #'make-cvec)

; rewrite this as make-string everywhere and delete this
(defun make-full-cvec (sint &optional (char #\space))
  (make-string sint :initial-element (character char)))

; 17.2 Accessing

(defun string2id-n (cvec sint)
  (if (< sint 1)
      nil
      (let ((start (position-if-not #'(lambda (x) (char= x #\Space)) cvec)))
        (if start
            (let ((end (or (position #\Space cvec :start start) (length cvec))))
              (if (= sint 1)
                  (intern (subseq cvec start end))
                  (string2id-n (subseq cvec end) (1- sint))))
            0))))


; 17.3 Searching

; 17.4 Updating operators

(defun suffix (id cvec)
  "Suffixes the first char of the symbol or char ID to the string CVEC,
    changing CVEC."
  (unless (characterp id) (setq id (elt (string id) 0)))
  (cond ((array-has-fill-pointer-p cvec)
         (vector-push-extend id cvec)
         cvec)
        ((adjustable-array-p cvec)
         (let ((l (length cvec)))
           (adjust-array cvec (1+ l))
           (setf (elt cvec l) id)
           cvec))
        (t (concat cvec id))))

; The following version has been provided to avoid reliance on the
; Common Lisp concatenate and replace functions. These built-in Lisp
; functions would probably end up doing the character-by-character
; copying shown here, but would also need to cope with generic sorts
; of sequences and unwarranted keyword generality

(defun rplacstr (cvec1 start1 length1 cvec2
                       &optional start2 length2
                       &aux end1 end2)
  (setq cvec2 (string cvec2))
  (if (null start1) (setq start1 0))
  (if (null start2) (setq start2 0))
  (if (null length1) (setq length1 (- (length cvec1) start1)))
  (if (null length2) (setq length2 (- (length cvec2) start2)))
  (setq end1 (+ start1 length1))
  (setq end2 (+ start2 length2))
  (if (= length1 length2)
      (do ()
          ((= start1 end1) cvec1)
          (setf (aref cvec1 start1) (aref cvec2 start2))
          (setq start1 (1+ start1))
          (setq start2 (1+ start2)))
      (let* ((l1 (length cvec1))
             (r (lisp::make-string (- (+ l1 length2) length1)))
             (i 0))
         (do ((j 0 (1+ j)))
             ((= j start1))
             (setf (aref r i) (aref cvec1 j))
             (setq i (1+ i)))
         (do ((j start2 (1+ j)))
             ((= j end2))
             (setf (aref r i) (aref cvec2 j))
             (setq i (1+ i)))
         (do ((j end1 (1+ j)))
             ((= j l1))
             (setf (aref r i) (aref cvec1 j))
             (setq i (1+ i)))
         r)
  ))

; 19.0 Operations on Arbitrary Objects

; 19.1 Creating

(defun MSUBST (new old tree) (subst new old tree :test #'equal))
; note subst isn't guaranteed to copy
(defun |nsubst| (new old tree) (nsubst new old tree :test #'equal))
(define-function 'MSUBSTQ #'subst) ;default test is eql
(define-function 'SUBSTQ #'SUBST) ;default test is eql subst is not guaranteed to copy

(defun copy (x) (copy-tree x)) ; not right since should descend vectors

(defun eqsubstlist (new old list) (sublis (mapcar #'cons old new) list))

; Gen code for SETQP expr

(eval-when (compile load eval)
 (defun DCQEXP (FORM EQTAG)
  (PROG (SV pvl avl CODE)
        (declare (special pvl avl))
        (setq SV (GENSYM))
        (setq CODE (DCQGENEXP SV FORM EQTAG NIL))
        (RETURN
          `(LAMBDA (,sv)
             (PROG ,pvl
                   ,@code
                   (RETURN 'true)
                BAD (RETURN NIL) ) ))))
)
; Generate Expr code for DCQ
(eval-when (compile load eval)
 (defun DCQGENEXP (SV FORM EQTAG QFLAG)
  (PROG (D A I L C W)
        (declare (special pvl avl))
    (COND ((EQ FORM SV) (RETURN NIL))
          ((IDENTP FORM) (RETURN `((setq ,form ,sv)) ))
          ((simple-vector-p FORM)
           (RETURN (SEQ
             (setq L (length FORM))
             (IF (EQ L 0)
                 (RETURN (COND ((NULL QFLAG)
                                `((cond ((not (simple-vector-p ,sv)) (go bad))))))))
             (setq I (1- L))
         LP  (setq A (elt FORM I))
             (COND ((AND (NULL W) (OR (consp A) (simple-vector-p A)))
                    (COND ((consp AVL) (setq W (car (RESETQ AVL (cdr AVL)))))
                          ((setq PVL (CONS (setq W (GENSYM)) PVL))))))
             (setq C (NCONC (COND ((IDENTP A) `((setq ,a (ELT ,sv ,i))))
                                  ((OR (consp A) (simple-vector-p A))
                                   `((setq ,w (ELT ,sv ,i))
                                     ,@(dcqgenexp w a eqtag qflag))))
                            C))
             (if (EQ I 0) (GO RET))
             (setq I (1- I))
             (GO LP)
         RET (if W (setq AVL (CONS W AVL)))
             (COND ((NULL QFLAG)
                    `((COND ((OR (NOT (simple-vector-p ,sv)) (< (length ,sv) ,l))
                             (GO BAD)))
                      ,@c))
                   ('T C)))))
          ((NOT (consp FORM)) (RETURN NIL))
          ((AND EQTAG (EQ (car FORM) EQTAG))
           (RETURN
             (COND
               ((OR (NOT (EQ 3 (LENGTH FORM))) (NOT (IDENTP (car (setq FORM (cdr FORM))))))
                (MACRO-INVALIDARGS 'DCQ\/QDCQ FORM "invalid pattern."))
               (`((setq ,(car form) ,sv)  ,@(DCQGENEXP SV (CADR FORM) EQTAG QFLAG)))))))
    (setq A (car FORM))
    (setq D (cdr FORM))
    (setq C (COND ((IDENTP A) `((setq ,a (CAR ,sv))))
                  ((OR (consp A) (simple-vector-p A))
                   (COND ((AND (NULL D) (IDENTP SV)) )
                         ((COND ((consp AVL) (setq W (car (RESETQ AVL (cdr AVL)))))
                                ((setq PVL (CONS (setq W (GENSYM)) PVL)) ) ) ) )
                   (COND ((AND (consp A) EQTAG (EQ (car A) EQTAG))
                          (DCQGENEXP (LIST 'CAR SV) A EQTAG QFLAG) )
                         (`((setq ,(or w sv) (CAR ,sv))
                            ,@(DCQGENEXP (OR W SV) A EQTAG QFLAG)))))))
    (setq C (NCONC C (COND ((IDENTP D) `((setq ,d (CDR ,sv))))
                           ((OR (consp D) (simple-vector-p D))
                            (COND
                              ((OR W (IDENTP SV)) )
                              ((COND ((consp AVL)
                                      (setq W (car (RESETQ AVL (cdr AVL)))) )
                                     ((setq PVL (CONS (setq W (GENSYM)) PVL)) ) ) ) )
                            (COND ((AND (consp D) EQTAG (EQ (car D) EQTAG))
                                   (DCQGENEXP (LIST 'CDR SV) D EQTAG QFLAG) )
                                  (`((setq ,(or w sv) (CDR ,sv))
                                     ,@(DCQGENEXP (OR W SV) D EQTAG QFLAG))))))))
    (COND (W (setq AVL (CONS W AVL))))
    (RETURN (COND ((NULL QFLAG) `((COND ((ATOM ,sv) (GO BAD))) ,@c)) (C)))))
)


; 19.3 Searching

; Generate code for EQQ

(eval-when (compile load eval)
 (defun ECQEXP (FORM QFLAG)
  (PROG (SV PVL CODE)
        (declare (special pvl))
        (setq SV (GENSYM))
        (setq CODE (ECQGENEXP SV FORM QFLAG))
        (RETURN
              `(LAMBDA (,sv)
                 (PROG ,pvl
                       ,@code
                       (RETURN 'true)
                    BAD (RETURN NIL) ) ))))
)

; Generate code for EQQ innards

(eval-when (compile load eval)
 (defun ECQGENEXP (SV FORM QFLAG)
  (PROG (D A I L C W)
        (declare (special pvl))
        (COND
          ((EQ FORM SV) (RETURN NIL))
          ((OR
              (IDENTP FORM)
              (NUMP FORM)
              (AND (consp FORM) (EQ (qcar FORM) 'QUOTE)))
           (RETURN
             `((COND ((NOT (EQ ,form ,sv)) (GO BAD))) )))
          ((simple-vector-p FORM)
           (RETURN (SEQ
              (setq L (length FORM))
              (if (EQ L 0)
                  (RETURN
                    (COND ((NULL QFLAG)
                           `((COND ((NOT (simple-vector-p ,sv)) (GO BAD))) )))
                    ))
              (setq I (1- L))
           LP (setq A (elt FORM I))
              (if (AND (NULL W) (OR (consp A) (simple-vector-p A)))
                  (push (setq W (GENSYM)) PVL))
              (setq C
                    (NCONC
                      (COND
                        ( (OR
                            (IDENTP A)
                            (NUMP A)
                            (AND (consp A) (EQ (qcar A) 'QUOTE)))
                         `((COND ( (NOT (EQ ,a (ELT ,sv ,i)))
                                  (GO BAD) ) ) ) )
                        ( (OR (consp A) (simple-vector-p A))
                         `((setq ,w (ELT ,sv ,i))
                           ,@(ECQGENEXP W A QFLAG))))
                      C) )
              (if (EQ I 0) (GO RET) )
              (setq I (1- I))
              (GO LP)
           RET
              (COND
                ( (NULL QFLAG)
                 `((COND ( (OR
                             (NOT (simple-vector-p ,sv))
                             (< (length ,sv) ,l))
                          (GO BAD) ) )
                   ,@c))
                ( 'T C ) )) ))
          ( (NOT (consp FORM))
           (RETURN NIL) ) )
        (setq A (car FORM))
        (setq D (cdr FORM))
        (if (OR (consp A) (simple-vector-p A) (consp D) (simple-vector-p D))
           (setq PVL (CONS (setq W (GENSYM)) PVL)))
        (setq C
              (COND
                ( (OR (IDENTP A) (NUMP A) (AND (consp A) (EQ (car A) 'QUOTE)))
                 `((COND ((NOT (EQ ,a (CAR ,sv))) (GO BAD))) ))
                ( (OR (consp A) (simple-vector-p A))
                 `((setq ,w (CAR ,sv))
                   ,@(ECQGENEXP W A QFLAG)))))
        (setq C
              (NCONC
                C
                (COND
                  ( (OR (IDENTP D) (NUMP D) (AND (consp D)
                                                 (EQ (car D) 'QUOTE)))
                   `((COND ((NOT (EQ ,d (CDR ,sv))) (GO BAD))) ))
                  ( (OR (consp D) (simple-vector-p D))
                   `((setq ,sv (CDR ,sv))
                     ,@(ECQGENEXP SV D QFLAG))))))
        (RETURN
          (COND
            ( (NULL QFLAG)
             `((COND ( (ATOM ,sv)
                      (GO BAD) ) )
               ,@c))
            ( 'T
             C ) )) ) )
)

; 19.4 Updating

; Generate code for RPLQ exprs

(eval-when (compile load eval)
 (defun RCQEXP (FORM)
    (PROG (SV PVL CODE)
          (declare (special pvl))
      (setq SV (GENSYM))
      (setq CODE (RCQGENEXP SV FORM NIL))
      (RETURN
        `(LAMBDA (,sv)
              (PROG ,pvl
                ,@code
                (RETURN 'true)
            BAD (RETURN NIL) ) ))))
)

; Generate code for RPLQ expr innards

(eval-when (compile load eval)
 (defun RCQGENEXP (SV FORM QFLAG)
    (PROG (D A I L C W)
          (declare (special pvl))
      (COND
        ( (EQ FORM SV)
          (RETURN NIL) )
        ( (simple-vector-p FORM)
         (RETURN (SEQ
            (setq L (length FORM))
            (if (EQ L 0) (RETURN NIL))
            (setq I (1- L))
        LP  (setq A (elt FORM I))
            (COND
              ( (AND
                  (NULL W)
                  (OR (AND (consp A) (NOT (EQ (car A) 'QUOTE)))
                           (simple-vector-p A)))
                (setq PVL (CONS (setq W (GENSYM)) PVL)) ) )
            (setq C
              (NCONC
                (COND
                  ( (OR
                      (IDENTP A)
                      (NUMP A)
                      (AND (consp A) (EQ (car A) 'QUOTE)))
                    `((SETELT ,sv ,i ,a)))
                  ( (OR (consp A) (simple-vector-p A))
                    `((setq ,w (ELT ,sv ,i))
                      ,@(RCQGENEXP W A QFLAG))))
                C) )
            (COND
              ( (EQ I 0)
                (GO RET) ) )
            (setq I (1- I))
            (GO LP)
        RET (RETURN
              (COND
                ( (NULL QFLAG)
                  `((COND ( (OR
                              (NOT (simple-vector-p ,sv))
                              (< (length ,sv) ,l))
                            (GO BAD) ) )
                    ,@c))
                ( 'T
                  C ) )) )))
        ( (NOT (consp FORM))
          (RETURN NIL) ) )
      (setq A (car FORM))
      (setq D (cdr FORM))
      (cond
        ( (or (and (consp A) (NOT (EQ (car A) 'QUOTE))) (simple-vector-p A))
          (setq PVL (CONS (setq W (GENSYM)) PVL)) ) )
      (setq C
        (COND
          ( (OR (IDENTP A) (NUMP A) (AND (consp A) (EQ (car A) 'QUOTE)))
            `((rplaca ,sv ,a)))
          ( (OR (consp A) (simple-vector-p A))
            `((setq ,w (CAR ,sv))
              ,@(RCQGENEXP W A QFLAG)))))
      (setq C
        (NCONC
          C
          (COND
            ( (OR (IDENTP D) (NUMP D) (AND (consp D) (EQ (car D) 'QUOTE)))
              `((RPLACD ,sv ,d)))
            ( (OR (consp D) (simple-vector-p D))
              `((setq ,sv (CDR ,sv))
                ,@(RCQGENEXP SV D QFLAG))))))
      (RETURN
        (COND
          ( (NULL QFLAG)
            `((COND ( (ATOM ,sv)
                      (GO BAD) ) )
              ,@c))
          ( 'T
            C ) )) ) )
)

; 22.0 Internal and External Forms

; 23.0 Reading


(define-function 'next #'read-char)

; 24.0 Printing

\end{chunk}
\section{The StringImage Fix}
In GCL 2.5 there is a bug in the write-to-string function.
It should respect *print-escape* but it does not. That is,
\begin{verbatim}

In GCL 2.4.1:
(setq *print-escape* nil)
(write-to-string '|a|) ==> "a"

In GCL 2.5:
(setq *print-escape* nil)
(write-to-string '|a|) ==> "|a|"

\end{verbatim}
The form2LispString function uses stringimage and fails.
The princ-to-string function assumes *print-escape* is nil
and works properly.

\begin{chunk}{*}
(define-function 'stringimage #'princ-to-string)
(define-function 'printexp #'princ)
(define-function 'prin0  #'prin1)

(defun |F,PRINT-ONE| (form &optional (stream *standard-output*))
 (declare (ignore stream))
    (let ((*print-level* 4) (*print-length* 4))
       (prin1 form) (terpri)))

(defun prettyprint (x &optional (stream *standard-output*))
  (prettyprin0 x stream) (terpri stream))

(defun prettyprin0 (x &optional (stream *standard-output*))
  (let ((*print-pretty* t) (*print-array* t))
    (prin1 x stream)))

(defun vmprint (x &optional (stream *standard-output*))
  (prin1 x stream) (terpri stream))

(defun tab (sint &optional (stream t))
  (format stream "~vT" sint))

; 27.0 Stream I/O


; 27.1 Creation

; 28.0 Key addressed I/O


; 46.0 Call tracing


(defun EMBEDDED () (mapcar #'car *embedded-functions*))

(defun EMBED (CURRENT-BINDING NEW-DEFINITION)
  (PROG (OP BV BODY OLD-DEF)
      (COND
        ( (NOT (IDENTP CURRENT-BINDING))
          (SETQ CURRENT-BINDING
                (error (format nil "invalid argument ~s to EMBED" CURRENT-BINDING))) ) )
      (SETQ OLD-DEF (symbol-function CURRENT-BINDING))
      (SETQ NEW-DEFINITION
        (SETF (symbol-function CURRENT-BINDING)
          (COND
            ( (NOT (consp NEW-DEFINITION))
              NEW-DEFINITION )
            ( (AND
                (DCQ (OP BV . BODY) NEW-DEFINITION)
                (OR (EQ OP 'LAMBDA) (EQ OP 'MLAMBDA)))
              (COND
                ( (NOT (member CURRENT-BINDING (FLAT-BV-LIST BV)))
                 `(,OP ,BV ((LAMBDA (,CURRENT-BINDING) . ,BODY) ',OLD-DEF))
                   )
                ( 'T
                  NEW-DEFINITION ) ) )
            ( 'T
              `((LAMBDA (,CURRENT-BINDING) ,NEW-DEFINITION) ',OLD-DEF)))
            ) )
      (push (LIST CURRENT-BINDING NEW-DEFINITION OLD-DEF) *embedded-functions*)
      (RETURN CURRENT-BINDING) ) )

(defun UNEMBED (CURRENT-BINDING)
    (PROG  (TMP E-LIST CUR-DEF)
      (SETQ E-LIST *embedded-functions*)
      (SETQ CUR-DEF (symbol-function CURRENT-BINDING))
      (COND
        ( (NOT (consp E-LIST))
          NIL )
        ( (ECQ ((CURRENT-BINDING CUR-DEF)) E-LIST)
          (SETF (symbol-function CURRENT-BINDING) (QCADDAR E-LIST))
          (SETQ *embedded-functions* (QCDR E-LIST))
          (RETURN CURRENT-BINDING) )
        ( 'T
          (SEQ
            (SETQ TMP E-LIST)
        LP  (COND
              ( (NOT (consp (QCDR TMP)))
                (EXIT NIL) )
              ( (NULL (ECQ ((CURRENT-BINDING CUR-DEF)) (QCDR TMP)))
                (SETQ TMP (QCDR TMP))
                (GO LP) )
              ( 'T
                (SETF (symbol-function  CURRENT-BINDING) (QCAR (QCDDADR TMP)))
                (RPLACD TMP (QCDDR TMP))
                (RETURN CURRENT-BINDING) ) ) ) ) )
      (RETURN NIL) ))

(defun FLAT-BV-LIST (BV-LIST)
  (PROG (TMP1)
      (RETURN
        (COND
          ( (VARP BV-LIST)
            (LIST BV-LIST) )
          ( (REFVECP BV-LIST)
            (FLAT-BV-LIST (VEC2LIST (MAPELT #'FLAT-BV-LIST BV-LIST))) )
          ( (NOT (consp BV-LIST))
            NIL )
          ( (EQ '= (SETQ TMP1 (QCAR BV-LIST)))
            (FLAT-BV-LIST (QCDR BV-LIST)) )
          ( (VARP TMP1)
            (CONS TMP1 (FLAT-BV-LIST (QCDR BV-LIST))) )
          ( (AND (NOT (consp TMP1)) (NOT (REFVECP TMP1)))
            (FLAT-BV-LIST (QCDR BV-LIST)) )
          ( 'T
            (NCONC (FLAT-BV-LIST TMP1) (FLAT-BV-LIST (QCDR BV-LIST))) ) )) ))

(defun VARP (TEST-ITEM)
    (COND
      ( (IDENTP TEST-ITEM)
        TEST-ITEM )
      ( (AND
          (consp TEST-ITEM)
          (OR (EQ (QCAR TEST-ITEM) 'FLUID) (EQ (QCAR TEST-ITEM) 'LEX))
          (consp (QCDR TEST-ITEM))
          (IDENTP (QCADR TEST-ITEM)))
        TEST-ITEM )
      ( 'T
        NIL ) ) )

; 48.0 Miscellaneous CMS Interactions

(defun CurrentTime ()
  (multiple-value-bind (sec min hour day month year) (get-decoded-time)
    (format nil "~2,'0D/~2,'0D/~2,'0D~2,'0D:~2,'0D:~2,'0D"
            month day (rem year 100) hour min sec)))

(defun $screensize () '(24 80))          ; You tell me!!

; 97.0 Stuff In The Manual But Wierdly Documented

(defun EBCDIC (x) (int-char x))

;; This isn't really compatible but is as close as you can get in common lisp
;; In place of ((one-of 1 2 3) l)  you should use
;;   (funcall (one-of 1 2 3) l)

(defun doDSETQ (form pattern exp)
  (let (PVL AVL)
    (declare (special PVL AVL))
    (COND ((IDENTP PATTERN)
           (LIST 'SETQ PATTERN EXP))
          ((AND (NOT (consp PATTERN)) (NOT (simple-vector-p PATTERN)))
           (MACRO-INVALIDARGS 'DSETQ FORM "constant target."))
          ((let* ((SV (GENSYM))
                  (E-PART (DCQGENEXP (LIST 'IDENTITY SV) PATTERN '= NIL)))
             (setq e-part
                   `(LAMBDA (,sv)
                      (PROG ,pvl
                            ,@e-part
                            (RETURN ,sv)
                         BAD (RETURN (SETQERROR ,sv)))))
             `(,e-part ,exp))))))

(defun SETQERROR (&rest FORM) (error (format nil "in destructuring ~S" FORM)))




(defun MACRO-INVALIDARGS (NAME FORM MESSAGE)
    (setq MACERRORCOUNT  (+ 1 (eval 'MACERRORCOUNT)))
    (error (format nil 
                   "invalid arguments to macro ~S with invalid argument ~S, ~S"
                   name form message)))

(defun MACRO-MISSINGARGS (NAME ignore N)
  (declare (ignore ignore))
  (setq MACERRORCOUNT (+ 1 (eval 'MACERRORCOUNT)))
  (error (concatenate 'string (symbol-name NAME) " requires "
                       (if (minusp N) "at least " "exactly ")
                       (setq N (abs N))
                       (case N (0 "no") (1 "one") (2 "two") (3 "three")
                             (4 "four") (5 "five") (6 "six")
                             (t (princ-to-string N)))
                       (if (eq n 1) " argument," " arguments,"))))

(defun MACERR (MESSAGE &rest ignore)
  (declare (ignore ignore))
      (setq MACERRORCOUNT (+ 1 (eval 'MACERRORCOUNT)))
      (error
        (LIST "in the expression:" MESSAGE))
      ())

; 98.0 Stuff Not In The VMLisp Manual That We Like

; The following should actually position the cursor at the sint'th line of the screen:

(defun $showline (cvec sint) (terpri) sint (princ cvec))

; 99.0 Ancient Stuff We Decided To Keep

(defun LAM\,EVALANDFILEACTQ (name &optional (form name))
    (LAM\,FILEACTQ name form) (eval form))

(defun LAM\,FILEACTQ (name form)
       (if *FILEACTQ-APPLY* (FUNCALL *FILEACTQ-APPLY* name form)))

(defun CALLBELOW (&rest junk) junk) ; to invoke system dependent code?

(define-function 'EVA1 #'eval) ;EVA1 and VMLISP EVAL make lexicals visible
(define-function 'EVALFUN #'eval) ;EVALFUN drops lexicals before evaluating
(define-function 'EVA1FUN #'EVALFUN)

(defun PLACEP (item) (eq item *read-place-holder*))
(defun VMREAD (&optional (st *standard-input*) (eofval *read-place-holder*))
  (read st nil eofval))

\end{chunk}
\sig{read-line}{Stream}{String}
\begin{chunk}{*}
(defun |read-line| (st &optional (eofval *read-place-holder*))
  (read-line st nil eofval))

(defun STATEP (item)
 (declare (ignore item))
   nil) ;no state objects
(defun FUNARGP (item)
 (declare (ignore item))
  nil) ;can't tell closures from other functions
(defun PAPPP (item)
 (declare (ignore item))
  nil) ;no partial application objects

(defun gcmsg (x)
   (prog1 system:*gbc-message* (setq system:*gbc-message* x)))

(defun reclaim () (gbc t))

(defun BPINAME (func)
  (if (functionp func)
      (cond ((symbolp func) func)
            ((and (consp func) (eq (car func) 'LAMBDA-BLOCK))
              (cadr func))
            ((compiled-function-p func)
             (system:compiled-function-name func))
            ('t func))))

(defun LISTOFQUOTES (bpi)
 (declare (ignore bpi))
  ())

(defun LISTOFFREES (bpi)
 (declare (ignore bpi))
 ())

(defun OBEY (S) (SYSTEM S))

(defun RE-ENABLE-INT (number-of-handler) number-of-handler)

(defun equable (x) ;;def needed to prevent recursion in def of eqcar
  (or (null x) (and (consp x) (eq (car x) 'quote) (symbolp (cadr x)))))


(defun QUOREM (i j r) ; never used, refed in parini.boot
  (multiple-value-bind (x y) (truncate i j)
   (rplaca (the cons r) x) (rplacd (the cons r) y)))

(defun MAKE-BVEC (n)
 (make-array (list n) :element-type 'bit :initial-element 0))

(DEFUN LEXGREATERP (COMPERAND-1 COMPERAND-2)
    ;;  "Order of types: pair NIL vec ivec/rvec cvec ident num fbpi mbpi other"
    (COND
      ((EQ COMPERAND-1 COMPERAND-2) NIL)
      ((consp COMPERAND-1)
        (COND
          ( (consp COMPERAND-2)
            (COND
              ( (EQUAL (qcar COMPERAND-1) (qcar COMPERAND-2))
                (LEXGREATERP (qcdr COMPERAND-1) (qcdr COMPERAND-2)) )
              ( (LEXGREATERP (qcar COMPERAND-1) (qcar COMPERAND-2)) ) ) )
          ('else t)))
      ((consp COMPERAND-2) NIL)
      ((NULL COMPERAND-1) 'T )
      ((NULL COMPERAND-2) NIL)
      ((VECP COMPERAND-1)
        (COND
          ((VECP COMPERAND-2) (LEXVGREATERP COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((VECP COMPERAND-2) NIL)
      ((OR (IVECP COMPERAND-1) (RVECP COMPERAND-1))
        (COND
          ( (OR (IVECP COMPERAND-2) (RVECP COMPERAND-2))
            (LEXVGREATERP COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((OR (IVECP COMPERAND-2) (RVECP COMPERAND-2)) NIL )
      ((stringp COMPERAND-1)
        (COND
          ((stringp COMPERAND-2)
            (STRING-GREATERP COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((stringp COMPERAND-2) NIL)
      ((symbolp COMPERAND-1)
        (COND
          ((symbolp COMPERAND-2)
            (STRING-GREATERP (symbol-name COMPERAND-1) (symbol-name COMPERAND-2)) )
          ('else t)))
      ((symbolp COMPERAND-2) NIL )
      ((numberp COMPERAND-1)
        (COND
          ( (numberp COMPERAND-2)
            (> COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((numberp COMPERAND-2) NIL)
      ((CHARACTERP COMPERAND-1)
        (COND 
          ((CHARACTERP COMPERAND-2)
            (CHAR-GREATERP COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((CHARACTERP COMPERAND-2)        NIL )
      ((FBPIP COMPERAND-1)
        (COND
          ((FBPIP COMPERAND-2)
            (LEXGREATERP (BPINAME COMPERAND-1) (BPINAME COMPERAND-2)) )
          ('else t)))
      ((FBPIP COMPERAND-2) NIL)
      ((MBPIP COMPERAND-1)
        (COND
          ((MBPIP COMPERAND-2)
            (LEXGREATERP (BPINAME COMPERAND-1) (BPINAME COMPERAND-2)) )
          ('else t)))
      ((MBPIP COMPERAND-2)
        NIL )
      ((> (SXHASH COMPERAND-1) (SXHASH COMPERAND-2)))))

(DEFUN LEXVGREATERP (VECTOR-COMPERAND-1 VECTOR-COMPERAND-2)
  (declare (simple-vector vector-comperand-1 vector-comperand-2))
    (PROG (L1 L2 I T1 T2)
     (declare (fixnum i l1 l2) )
      (SETQ I -1)
      (SETQ L1 (length VECTOR-COMPERAND-1))
      (SETQ L2 (length VECTOR-COMPERAND-2))
  LP  (setq i (1+ i))
      (COND
        ((EQL L1 I) (RETURN NIL))
        ((EQL L2 I) (RETURN 'T)))
      (COND
        ((EQUAL
            (SETQ T1 (svref VECTOR-COMPERAND-1 I))
            (SETQ T2 (svref VECTOR-COMPERAND-2 I)))
          (GO LP)))
      (RETURN (LEXGREATERP T1 T2)) ) )


(DEFUN GGREATERP (COMPERAND-1 COMPERAND-2)
    ;;  "Order of types: pair NIL vec ivec/rvec cvec ident num fbpi mbpi other"
    (COND
      ((EQ COMPERAND-1 COMPERAND-2) NIL)
      ((symbolp COMPERAND-1)
        (COND
          ((symbolp COMPERAND-2)
            (CGREATERP (symbol-name COMPERAND-1) (symbol-name COMPERAND-2)) )
          ('else t)))
      ((symbolp COMPERAND-2) NIL )
      ((consp COMPERAND-1)
        (COND
          ( (consp COMPERAND-2)
            (COND
              ( (EQUAL (qcar COMPERAND-1) (qcar COMPERAND-2))
                (GGREATERP (qcdr COMPERAND-1) (qcdr COMPERAND-2)) )
              ( (GGREATERP (qcar COMPERAND-1) (qcar COMPERAND-2)) ) ) )
          ('else t)))
      ((consp COMPERAND-2) NIL)
      ((NULL COMPERAND-1) 'T )
      ((NULL COMPERAND-2) NIL)
      ((VECP COMPERAND-1)
        (COND
          ((VECP COMPERAND-2) (VGREATERP COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((VECP COMPERAND-2) NIL)
      ((OR (IVECP COMPERAND-1) (RVECP COMPERAND-1))
        (COND
          ( (OR (IVECP COMPERAND-2) (RVECP COMPERAND-2))
            (VGREATERP COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((OR (IVECP COMPERAND-2) (RVECP COMPERAND-2)) NIL )
      ((stringp COMPERAND-1)
        (COND
          ((stringp COMPERAND-2)
            (CGREATERP COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((stringp COMPERAND-2) NIL)
      ((numberp COMPERAND-1)
        (COND
          ( (numberp COMPERAND-2)
            (> COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((numberp COMPERAND-2) NIL)
      ((CHARACTERP COMPERAND-1)
        (COND 
          ((CHARACTERP COMPERAND-2)
            (CHAR> COMPERAND-1 COMPERAND-2) )
          ('else t)))
      ((CHARACTERP COMPERAND-2)        NIL )
      ((FBPIP COMPERAND-1)
        (COND
          ((FBPIP COMPERAND-2)
            (GGREATERP (BPINAME COMPERAND-1) (BPINAME COMPERAND-2)) )
          ('else t)))
      ((FBPIP COMPERAND-2) NIL)
      ((MBPIP COMPERAND-1)
        (COND
          ((MBPIP COMPERAND-2)
            (GGREATERP (BPINAME COMPERAND-1) (BPINAME COMPERAND-2)) )
          ('else t)))
      ((MBPIP COMPERAND-2)
        NIL )
      ((> (SXHASH COMPERAND-1) (SXHASH COMPERAND-2)))))

(DEFUN VGREATERP (VECTOR-COMPERAND-1 VECTOR-COMPERAND-2)
  (declare (simple-vector vector-comperand-1 vector-comperand-2))
    (PROG (L1 L2 I T1 T2)
     (declare (fixnum i l1 l2) )
      (SETQ I -1)
      (SETQ L1 (length VECTOR-COMPERAND-1))
      (SETQ L2 (length VECTOR-COMPERAND-2))
  LP  (setq i (1+ i))
      (COND
        ((EQL L1 I) (RETURN NIL))
        ((EQL L2 I) (RETURN 'T)))
      (COND
        ((EQUAL
            (SETQ T1 (svref VECTOR-COMPERAND-1 I))
            (SETQ T2 (svref VECTOR-COMPERAND-2 I)))
          (GO LP)))
      (RETURN (GGREATERP T1 T2)) ) )

(defvar SORTGREATERP #'GGREATERP "default sorting predicate")

;17.0 Operations on Hashtables
;17.1 Creation

(defun MAKE-HASHTABLE (id1 &optional (id2 nil))
 (declare (ignore id2))
   (let ((test (case id1
                     ((EQ ID) #'eq)
                     (CVEC #'equal)
                     (EQL #'eql)
                     ((UEQUAL EQUAL) #'equal)
                     (otherwise (error "bad arg to make-hashtable")))))     
      (make-hash-table :test test)))

;17.2 Accessing


\end{chunk}
The static declaration causes a problem as of GCL-2.6.8pre.
Camm issued a fix. This used to read:
\begin{verbatim}
#+AKCL
(clines "static int mem_value(x ,i)object x;int i; { return ((short *)x)[i];}")
\end{verbatim}
\begin{chunk}{*}
(clines "int mem_value(x ,i)object x;int i; { return ((short *)x)[i];}")

(defentry memory-value-short(object int) (int "mem_value"))

;(memory-value-short  (make-hash-table :test 'equal) 12) is 0,1,or 2
;depending on whether the test is eq,eql or equal.
(defun HASHTABLE-CLASS (table)
  (case (memory-value-short table 12)
        (0 'EQ)
        (1 'EQL)
        (2 'EQUAL)
        (t "error unknown hash table class")))

;17.4 Searching and Updating

(defun HPUT* (table alist)
  (mapc #'(lambda (pair) (hput table (car pair) (cdr pair))) alist))

(defmacro HREM (table key) `(remhash ,key ,table))

(defun HREMPROP (table key property)
  (let ((plist (gethash key table)))
    (if plist (setf (gethash key table)
                    (delete property plist :test #'equal :key #'car)))))

;17.6 Miscellaneous

;;macros from file vmlisp are necessary to compile this file

(DEFUN |intersection|  (LIST-OF-ITEMS-1 LIST-OF-ITEMS-2)
    (PROG (I H V)
      (SETQ V (SETQ H (CONS NIL NIL)))
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-1))
          (SETQ LIST-OF-ITEMS-1 (LIST LIST-OF-ITEMS-1)) ) )
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-2))
          (SETQ LIST-OF-ITEMS-2 (LIST LIST-OF-ITEMS-2)) ) )
  LP  (COND
        ( (NOT (CONSP LIST-OF-ITEMS-1))
          (RETURN (QCDR H)) )
        ( (|member|
            (SETQ I (QCAR (RESETQ LIST-OF-ITEMS-1 (QCDR LIST-OF-ITEMS-1))))
            (QCDR H)) )
        ( (|member| I LIST-OF-ITEMS-2)
          (QRPLACD V (SETQ V (CONS I NIL))) ) )
      (GO LP) ) )

(DEFUN INTERSECTIONQ (LIST-OF-ITEMS-1 LIST-OF-ITEMS-2)
    (PROG (I H V)
      (SETQ V (SETQ H (CONS NIL NIL)))
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-1))
          (SETQ LIST-OF-ITEMS-1 (LIST LIST-OF-ITEMS-1)) ) )
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-2))
          (SETQ LIST-OF-ITEMS-2 (LIST LIST-OF-ITEMS-2)) ) )
  LP  (COND
        ( (NOT (CONSP LIST-OF-ITEMS-1))
          (RETURN (QCDR H)) )
        ( (member
            (SETQ I (QCAR (RESETQ LIST-OF-ITEMS-1 (QCDR LIST-OF-ITEMS-1))))
            (QCDR H)) )
        ( (member I LIST-OF-ITEMS-2)
          (QRPLACD V (SETQ V (CONS I NIL))) ) )
      (GO LP) ) )

(DEFUN |union| (LIST-OF-ITEMS-1 LIST-OF-ITEMS-2)
    (PROG (I H V)
      (SETQ H (SETQ V (CONS NIL NIL)))
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-1))
          (SETQ LIST-OF-ITEMS-1 (LIST LIST-OF-ITEMS-1)) ) )
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-2))
          (SETQ LIST-OF-ITEMS-2 (LIST LIST-OF-ITEMS-2)) ) )
  LP1 (COND
        ( (NOT (CONSP LIST-OF-ITEMS-1))
          (COND
            ( (CONSP LIST-OF-ITEMS-2)
              (SETQ LIST-OF-ITEMS-1 (RESETQ LIST-OF-ITEMS-2 NIL)) )
            ( 'T
              (RETURN (QCDR H)) ) ) )
        ( (NOT
            (|member|
              (SETQ I (QCAR (RESETQ LIST-OF-ITEMS-1 (QCDR LIST-OF-ITEMS-1))))
              (QCDR H)))
          (QRPLACD V (SETQ V (CONS I NIL))) ) )
      (GO LP1) ) )

(DEFUN UNIONQ (LIST-OF-ITEMS-1 LIST-OF-ITEMS-2)
    (PROG (I H V)
      (SETQ H (SETQ V (CONS NIL NIL)))
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-1))
          (SETQ LIST-OF-ITEMS-1 (LIST LIST-OF-ITEMS-1)) ) )
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-2))
          (SETQ LIST-OF-ITEMS-2 (LIST LIST-OF-ITEMS-2)) ) )
  LP1 (COND
        ( (NOT (CONSP LIST-OF-ITEMS-1))
          (COND
            ( (CONSP LIST-OF-ITEMS-2)
              (SETQ LIST-OF-ITEMS-1 (RESETQ LIST-OF-ITEMS-2 NIL)) )
            ( 'T
              (RETURN (QCDR H)) ) ) )
        ( (NOT
            (member
              (SETQ I (QCAR (RESETQ LIST-OF-ITEMS-1 (QCDR LIST-OF-ITEMS-1))))
              (QCDR H)))
          (QRPLACD V (SETQ V (CONS I NIL))) ) )
      (GO LP1) ) )

(DEFUN SETDIFFERENCE (LIST-OF-ITEMS-1 LIST-OF-ITEMS-2)
    (PROG (I H V)
      (SETQ H (SETQ V (CONS NIL NIL)))
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-1))
          (SETQ LIST-OF-ITEMS-1 (LIST LIST-OF-ITEMS-1)) ) )
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-2))
          (SETQ LIST-OF-ITEMS-2 (LIST LIST-OF-ITEMS-2)) ) )
  LP1 (COND
        ( (NOT (CONSP LIST-OF-ITEMS-1))
          (RETURN (QCDR H)) )
        ( (|member|
            (SETQ I (QCAR (RESETQ LIST-OF-ITEMS-1 (QCDR LIST-OF-ITEMS-1))))
            (QCDR H)) )
        ( (NOT (|member| I LIST-OF-ITEMS-2))
          (QRPLACD V (SETQ V (CONS I NIL))) ) )
      (GO LP1) ) )

(DEFUN SETDIFFERENCEQ (LIST-OF-ITEMS-1 LIST-OF-ITEMS-2)
    (PROG (I H V)
      (SETQ H (SETQ V (CONS NIL NIL)))
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-1))
          (SETQ LIST-OF-ITEMS-1 (LIST LIST-OF-ITEMS-1)) ) )
      (COND
        ( (NOT (LISTP LIST-OF-ITEMS-2))
          (SETQ LIST-OF-ITEMS-2 (LIST LIST-OF-ITEMS-2)) ) )
  LP1 (COND
        ( (NOT (CONSP LIST-OF-ITEMS-1))
          (RETURN (QCDR H)) )
        ( (member
            (SETQ I (QCAR (RESETQ LIST-OF-ITEMS-1 (QCDR LIST-OF-ITEMS-1))))
            (QCDR H)) )
        ( (NOT (member I LIST-OF-ITEMS-2))
          (QRPLACD V (SETQ V (CONS I NIL))) ) )
      (GO LP1) ) )

(defvar *lisp-bin-filetype* "o")

(defvar *lisp-source-filetype* "lsp")

;; definition of our stream structure
(defstruct libstream  mode dirname (indextable nil)  (indexstream nil))
;indextable is a list of entries (key class <location or filename>)
;filename is of the form filenumber.lsp or filenumber.o

(defvar optionlist nil "alist which controls compiler output")

(defun addoptions (key value) "adds pairs to optionlist"
  (push (cons key value) optionlist)
  (if (equal key 'FILE)
      (push 
       (cons 'COMPILER-OUTPUT-STREAM
                   (open (concat (libstream-dirname value) "/" "code.lsp")
                         :direction :output :if-exists :supersede))
             optionlist)))

(defun directory? (filename) (|directoryp| filename))

;; (RDEFIOSTREAM ((MODE . IO) (FILE fn ft dir))) IO is I,O,INPUT,OUTPUT
(defun rdefiostream (options &optional (missing-file-error-flag t))
  (let ((mode (cdr (assoc 'mode options)))
        (file (assoc 'file options))
        (stream nil)
        (fullname nil)
        (indextable nil))
        (cond ((equal (elt (string mode) 0) #\I)
               (setq fullname (boot::makeInputFilename (cdr file) nil))
               (setq stream (get-input-index-stream fullname))
               (if (null stream)
                   (if missing-file-error-flag
                       (ERROR (format nil "Library ~s doesn't exist"
                              ;;(make-filename (cdr file) 'LISPLIB))
                              (make-filename (cdr file) 'NIL)))
                     NIL)
               (make-libstream :mode 'input  :dirname fullname
                               :indextable (get-index-table-from-stream stream)
                               :indexstream stream)))
              ((equal (elt (string mode) 0) #\O)
               ;;(setq fullname (boot::makeFullNamestring (cdr file) 'LISPLIB))
               (setq fullname (boot::makeFullNamestring (cdr file) nil))
               (case (directory? fullname)
                     (-1 (makedir fullname))
                     (0 (error (format nil "~s is an existing file, not a library" fullname)))
                     (otherwise))
               (multiple-value-setq (stream indextable) (get-io-index-stream fullname))
               (make-libstream :mode 'output  :dirname fullname
                               :indextable indextable
                               :indexstream stream ))
              ('t  (ERROR "Unknown MODE")))))

(defvar *index-filename* "index.kaf")

;get the index table of the lisplib in dirname
(defun getindextable (dirname)
  (let ((index-file (concat dirname "/" *index-filename*)))
     (if (probe-file index-file)
         (with-open-file (stream index-file) (get-index-table-from-stream stream))
            ;; create empty index file to mark directory as lisplib
         (with-open-file (stream index-file :direction :output) nil))))

;get the index stream of the lisplib in dirname
(defun get-input-index-stream (dirname)
  (let ((index-file (concat dirname "/" *index-filename*)))
    (open index-file :direction :input :if-does-not-exist nil)))

(defun get-index-table-from-stream (stream)
  (let ((pos (read  stream)))
    (cond ((numberp pos)
           (file-position stream pos)
           (read stream))
          (t pos))))

(defun get-io-index-stream (dirname)
  (let* ((index-file (concat dirname "/" *index-filename*))
         (stream (open index-file :direction :io :if-exists :overwrite
                       :if-does-not-exist :create))
         (indextable ())
         (pos (read stream nil nil)))
    (cond ((numberp pos)
           (file-position stream pos)
           (setq indextable (read stream))
           (file-position stream pos))
          (t (file-position stream 0)
             (princ "                    " stream)
             (setq indextable pos)))
    (values stream indextable)))

;substitute indextable in dirname

(defun write-indextable (indextable stream)
  (let ((pos (file-position stream)))
    (write indextable :stream stream :level nil :length nil :escape t)
    (finish-output stream)
    (file-position stream 0)
    (princ pos stream)
    (finish-output stream)))

(defun putindextable (indextable dirname)
  (with-open-file
    (stream (concat dirname "/" *index-filename*)
             :direction :io :if-exists :overwrite
             :if-does-not-exist :create)
    (file-position stream :end)
    (write-indextable indextable stream)))

;makedir (fname) fname is a directory name.
(defun makedir (fname)
  (system (concat "mkdir " fname)))

;; (RREAD key rstream)
(defun rread (key rstream &optional (error-val nil error-val-p))
  (if (equal (libstream-mode rstream) 'output) (error "not input stream"))
  (let* ((entry
         (and (stringp key)
              (assoc key (libstream-indextable rstream) :test #'string=)))
         (file-or-pos (and entry (caddr entry))))
    (cond ((null entry)
           (if error-val-p error-val (error (format nil "key ~a not found" key))))
          ((null (caddr entry)) (cdddr entry))  ;; for small items
          ((numberp file-or-pos)
           (file-position (libstream-indexstream rstream) file-or-pos)
           (read (libstream-indexstream rstream)))
          (t
           (with-open-file
            (stream (concat (libstream-dirname rstream) "/" file-or-pos))
            (read  stream))) )))

(defvar *lib-var*)

;; (RKEYIDS filearg) -- interned version of keys
(defun rkeyids (&rest filearg)
  (mapcar #'intern (mapcar #'car (getindextable
                                  (boot::makeInputFilename filearg 'NIL)))))
;; (RWRITE cvec item rstream)
(defun rwrite (key item rstream)
  (if (equal (libstream-mode rstream) 'input) (error "not output stream"))
  (let ((stream (libstream-indexstream rstream))
        (pos (if item (cons (file-position (libstream-indexstream rstream)) nil)
               (cons nil item))))   ;; for small items
    (make-entry (string key) rstream pos)
    (when (numberp (car pos))
          (write item :stream stream :level nil :length nil
                 :circle t :array t :escape t)
          (terpri stream))))

(defun make-entry (key rstream value-or-pos)
   (let ((entry (assoc key (libstream-indextable rstream) :test #'equal)))
     (if (null entry)
         (push (setq entry (cons key (cons 0 value-or-pos)))
               (libstream-indextable rstream))
       (progn
         (if (stringp (caddr entry)) ($erase (caddr entry)))
         (setf (cddr entry) value-or-pos)))
     entry))

;;(defun rshut (rstream)
;;  (when (and (equal rstream (cdr (assoc 'FILE OPTIONLIST)))
;;             (assoc 'compiler-output-stream optionlist))
;;        (close (cdr (assoc 'compiler-output-stream optionlist)))
;;        (setq optionlist nil))
;;  (if (eq (libstream-mode rstream) 'output)
;;      (write-indextable (libstream-indextable rstream) (libstream-indexstream rstream)))
;;  (close (libstream-indexstream rstream)))
(defun rshut (rstream)
  (when (and (equal rstream (cdr (assoc 'FILE OPTIONLIST)))
             (assoc 'compiler-output-stream optionlist))
        (close (cdr (assoc 'compiler-output-stream optionlist)))
        (setq optionlist (cddr optionlist)))
  (if (eq (libstream-mode rstream) 'output)
      (write-indextable (libstream-indextable rstream) (libstream-indexstream rstream)))
  (close (libstream-indexstream rstream)))

\end{chunk}
\section{GCL code.lsp name change}
When we compile an algebra file we create an nrlib directory which contains
several files. One of the files is named code.lsp. 
On certain platforms this causes linking problems for GCL. 
The problem is that the compiler produces an init code block which is
sensitive to the name of the source file.
Since all of the code.lsp files have the same name all of
the init blocks have the same name. At link time this causes
the names to collide. Here we rename the file before we compile,
do the compile, and then rename the result back to code.o.
\begin{chunk}{*}
;; filespec is id or list of 1, 2 or 3 ids
;; filearg is filespec or 1, 2 or 3 ids
;; (RPACKFILE filearg)  -- compiles code files and converts to compressed format
(defun rpackfile (filespec)
  (setq filespec (make-filename filespec))
  (if (string= (pathname-type filespec) "nrlib")
  (let* ((base (pathname-name filespec))
             (code (concatenate 'string (namestring filespec) "/code.lsp"))
             (temp (concatenate 'string (namestring filespec) "/" base ".lsp"))
             (o (make-pathname :type "o")))
        (si::system (format nil "cp ~S ~S" code temp))
        (recompile-lib-file-if-necessary temp)
        (si::system (format nil "mv ~S ~S~%" 
           (namestring (merge-pathnames o temp))
           (namestring (merge-pathnames o code)))))
  ;; only pack non libraries to avoid lucid file handling problems    
    (let* ((rstream (rdefiostream (list (cons 'file filespec) (cons 'mode 'input))))
           (nstream nil)
           (nindextable nil)
           (nrstream nil)
           (index-file-name (concat (truename filespec) "/" *index-filename*))
           (temp-index-file-name (make-pathname :name "oldindex"
                                                :defaults index-file-name)))
      (rename-file index-file-name temp-index-file-name ) ;; stays until closed
      (multiple-value-setq (nstream nindextable) (get-io-index-stream filespec))
      (setq nrstream (make-libstream :mode 'output  :dirname filespec
                                     :indextable nindextable
                                     :indexstream nstream ))
      (dolist (entry (libstream-indextable rstream))
              (rwrite (car entry) (rread (car entry) rstream) nrstream)
              (if (stringp (caddr entry))
                  (delete-file (concat filespec "/" (caddr entry)))))
      (close (libstream-indexstream rstream))
      (delete-file temp-index-file-name)
      (rshut nrstream)))
  filespec)

(defun spad-fixed-arg (fname )
   (and (equal (symbol-package fname) (find-package "BOOT"))
        (not (get fname 'compiler::spad-var-arg))
        (search ";" (symbol-name fname))
        (or (get fname 'compiler::fixed-args)
            (setf (get fname 'compiler::fixed-args) t)))
   nil)

;; (RDROPITEMS filearg keys) don't delete, used in files.spad
(defun rdropitems (filearg keys &aux (ctable (getindextable filearg)))
  (mapc #'(lambda(x)
           (setq ctable (delete x ctable :key #'car :test #'equal)) )
           (mapcar #'string keys))
  (putindextable ctable filearg))

;; cms file operations
(defun make-filename (filearg &optional (filetype nil))
  (let ((filetype (if (and filetype (symbolp filetype))
                      (symbol-name filetype)
                      filetype)))
    (cond
     ((pathnamep filearg) 
      (cond ((pathname-type filearg) (namestring filearg))
            (t (namestring
                (make-pathname :directory (pathname-directory filearg)
                               :name (pathname-name filearg)
                               :type filetype)))))
     ((and (stringp filearg) (pathname-type filearg) (null filetype)) filearg)
     ((and (stringp filearg) (stringp filetype)
           (pathname-type filearg) 
           (string-equal (pathname-type filearg) filetype))
      filearg)
     ((consp filearg)
      (make-filename (car filearg) (or (cadr filearg) filetype)))
     (t (if (stringp filetype) (setq filetype (intern filetype "BOOT")))
        (let ((ft (or (cdr (assoc filetype $filetype-table)) filetype)))
          (if ft 
              (concatenate 'string (string filearg) "." (string ft))
              (string filearg)))))))

(defun $FILEP (&rest filearg) (boot::makeFullNamestring filearg))
(define-function '$OUTFILEP #'$FILEP) ;;temporary bogus def

(defun $findfile (filespec filetypelist)
  (let ((file-name (if (consp filespec) (car filespec) filespec))
        (file-type (if (consp filespec) (cadr filespec) nil)))
    (if file-type (push file-type filetypelist))
    (some #'(lambda (ft) (boot::makeInputFilename file-name ft))
          filetypelist)))

;; ($ERASE filearg) -> 0 if succeeds else 1
(defun $erase (&rest filearg)
  (system (concat "rm -rf "(boot::makeFullNamestring filearg))))


(defun $FCOPY (filespec1 filespec2)
    (let ((name1 (boot::makeFullNamestring filespec1))
          (name2 (boot::makeFullNamestring filespec2)))
      (if (library-file name1)
        (copy-lib-directory name1 name2)
        (copy-file name1 name2))))


(defun copy-lib-directory (name1 name2)
   (makedir name2)
   (system (concat "sh -c 'cp " name1 "/* " name2 "'")))

(defun copy-file (namestring1 namestring2)
  (system (concat "cp " namestring1 " " namestring2)))


(defvar vmlisp::$filetype-table
  '((BOOT::LISPLIB . |LILIB|)
    (BOOT::SPADLIB . |slib|)
    (BOOT::HISTORY . |hist|)
    (BOOT::HELPSPAD . |help|)
    (BOOT::INPUT . |input|)
    (BOOT::SPAD . |spad|)
    (BOOT::BOOT . |boot|)
    (BOOT::LISP . |lsp|)
    (BOOT::META . |meta|)
    (BOOT::OUTPUT . |splog|)
    (BOOT::ERRORLIB . |erlib|)
    (BOOT::DATABASE . |daase|)
    (BOOT::SPADDATA . |sdata|)
    (BOOT::SPADFORT . |sfort|)
    (BOOT::SPADFORM . |sform|)
    (BOOT::SPADTEX . |stex|)
    (BOOT::SPADOUT . |spout|)))

(in-package 'boot)

(defvar *npPCff* nil "rewrite flets, using global scoping")
(defun npPCff () (and (funcall *npPCff*) (|npPush| (list (|npPop1|)))))
(defun npPCg () 
 (and (|npListAndRecover| (function npPCff)))
 (|npPush| (|pfAppend| (|npPop1|))))
(defun |npPC| (|f|)
  (or
    (and (|npPileBracketed| (function npPCg))
         (|npPush| (|pfEnSequence| (|npPop1|))))
    (funcall |f|)))

(defun |stringLE1| (x y)
  (string<= x y :start1 1 :start2 2))

(defun |sortCarString| (lines)
  (sort lines #'string<= :key #'car))

(defun |insertString| (s1 s2 i1)
   (replace s2 s1 :start1 i1 :end1 (1+ i1) :end2 (size s1))) 

; NAME:           Boot Package
; PURPOSE: Provide forward references to Boot Code for functions to be at
;           defined at the boot level, but which must be accessible
;           not defined at lower levels.

(in-package "BOOT")
(use-package '("LISP" "VMLISP"))

(defmacro def-boot-fun (f args where)
  `(compiler-let nil
     (defun ,f ,args ,where (print (list ',f . ,args)))
     (export '(,f) "BOOT")))

(defmacro def-boot-var (p where)
  `(compiler-let nil
     (defparameter ,p nil ,where)
     (export '(,p) "BOOT")))

(defmacro def-boot-val (p val where)
  `(compiler-let nil
     (defparameter ,p ,val ,where)
     (export '(,p) "BOOT")))

(def-boot-fun |updateSourceFiles| (x) "temp def")
(def-boot-val |$timerTicksPerSecond| INTERNAL-TIME-UNITS-PER-SECOND
    "for TEMPUS-FUGIT and $TOTAL-ELAPSED-TIME")
(def-boot-val $boxString
  (concatenate 'string (list (code-char #x1d) (code-char #xe2)))
  "this string of 2 chars displays as a box")
(def-boot-val |$quadSymbol| $boxString "displays an APL quad")
(def-boot-val |$quadSym| '|$quadSym| "unbound symbol referenced in format.boot")
(def-boot-val $escapeString  (string (code-char 27))
   "string for single escape character")
(def-boot-val $boldString (concatenate 'string $escapeString "[12m")
  "switch into bold font")
(def-boot-val $normalString (concatenate 'string $escapeString "[0;10m")
  "switch back into normal font")
(def-boot-val $reverseVideoString (concatenate 'string $escapeString "[7m")
  "switch into reverse video")
(def-boot-val $underlineString (concatenate 'string $escapeString "[4m")
  "switch into underline mode")
(def-boot-val $COMPILE t  "checked in COMP-2 to skip compilation")
(def-boot-var |$abbreviationTable|                    "???")
(def-boot-val |$algebraList|
        '(|QuotientField| |Polynomial|
          |UnivariatePoly|
          |MultivariatePolynomial|
          |DistributedMultivariatePolynomial|
          |HomogeneousDistributedMultivariatePolynomial|
          |Gaussian| |SquareMatrix|
          |RectangularMatrix|)                        "???")
(def-boot-val |$BasicDomains|
          '(|Integer| |Float| |Symbol|
            |Boolean| |String|)                        "???")
(def-boot-val |$BFtag| '-BF-           "big float marker")
(def-boot-val |$BigFloat| '(|Float|)                    "???")
(def-boot-val |$BigFloatOpt| '(|BigFloat| . OPT)    "???")
(def-boot-val |$Boolean| '(|Boolean|)                    "???")
(def-boot-val |$BooleanOpt| '(|Boolean| . OPT)            "???")
(def-boot-val |$bootStrapMode| ()  "if T compCapsule skips body")
(def-boot-fun |bootUnionPrint| (x s tt)                    "Interpreter>Coerce.boot")
(def-boot-fun |break| (msg)                            "Interpreter>Trace.boot")
(def-boot-fun |breaklet| (fn vars)                    "Interpreter>Trace.boot")
(def-boot-var |$brightenCommentsFlag|                    "???")
(def-boot-var |$brightenCommentsIfTrue|                    "???")
(def-boot-val |$BreakMode| '|query|                    "error.boot")
(def-boot-var |$cacheAlist|                            "Interpreter>System.boot")
(def-boot-val |$cacheCount| 0                            "???")
(def-boot-val |$Category| '(|Category|)                    "???")
;  modemap:==  ( <map> (p e) (p e) ... (p e) )
;  modemaplist:= ( modemap ... )

(def-boot-val |$CategoryFrame|
          '((((|Category| . ((|modemap| (((|Category|) (|Category|)) (T *)))))
              (|Join| . ((|modemap|
      (((|Category|) (|Category|) (|Category|) (|Category|)) (T *))
      (((|Category|) (|Category|) (|List| |Category|)) (|Category|)) (T *))
        )))))
        "Compiler>CUtil.boot")
(def-boot-val |$CategoryNames|
        '(|Category| |CATEGORY| |RecordCategory| |Join|
          |StringCategory| |SubsetCategory| |UnionCategory|)
        "???")
(def-boot-val |$clamList|
          '((|getModemapsFromDatabase| |hash| UEQUAL |count|)
            (|getOperationAlistFromLisplib| |hash| UEQUAL |count|)
            (|getFileProperty| |hash| UEQUAL |count|)
            (|canCoerceFrom| |hash| UEQUAL |count|)
            (|selectMms1| |hash| UEQUAL |count|)
            (|coerceMmSelection| |hash| UEQUAL |count|)
            (|isValidType| |hash| UEQUAL |count|))
                                                "Interpreter>Clammed.boot")
(def-boot-val |$CommonDomains|
         '(|Record| |Union| |List| |Vector|
           |String| |Float| |Integer|
           |NonNegativeInteger| |Expression|
           |NonPositiveInteger|
           |PositiveInteger| |SmallInteger|
           |Boolean|) "???")

(def-boot-var |$compCount|                            "???")
(def-boot-var |$compileMapFlag|                            "Interpreter>SetVars.boot")
(def-boot-var |$compUniquelyIfTrue|                    "Compiler>Compiler.boot")
(def-boot-val |$consistencyCheck| nil                    "Interpreter>Consis.boot")
(def-boot-val |$ConstructorCache| (MAKE-HASHTABLE 'ID)        "???")
(def-boot-var |$constructorsNotInDatabase|            "Interpreter>Database.boot")
(def-boot-var |$createUpdateFiles|                    "Interpreter>SetVarT.boot")
(def-boot-var |$croakIfTrue|                            "See moan in U.")
(def-boot-var |$currentFunction|                    "???")
(def-boot-val $delay 0                                    "???")
(def-boot-var $Directory                            "???")
(def-boot-val |$Domain| '(|Domain|)                    "???")
(def-boot-var |$DomainFrame|                            "???")
(def-boot-val |$DomainNames|
        '(|Integer| |Float| |Symbol| |Boolean|
          |String| |Expression|
          |Mapping| |SubDomain| |List| |Union|
          |Record| |Vector|)                        "???")
(def-boot-val |$DomainsInScope| '(NIL)                    "???")
(def-boot-val |$domainTraceNameAssoc| ()    "association list of trace domains")
(def-boot-val |$DomainVariableList|
  '($1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11
       $12 $13 $14 $15)                                "???")
(def-boot-val |$DoubleQuote| "\""                   "???")
(def-boot-val |$DummyFunctorNames|
          '(|Boolean| |Mapping|)                "???")
(def-boot-var |$eltIfNil|                            "SpecialFunctions>PSpad.boot")
(def-boot-val |$EmptyEnvironment| '((NIL))            "???")
(def-boot-val |$EmptyList| ()                            "???")
\end{chunk}
\begin{chunk}{*}
(def-boot-val |$EmptyString| ""                     "???")
(def-boot-val |$EmptyVector| '#()                     "???")
(def-boot-val |$Expression| '(|Expression|)            "???")
(def-boot-val |$ExpressionOpt|
          '(|Expression| . OPT)                        "???")
(def-boot-var |$evalDomain|                            "???")
(def-boot-val |$Exit| '(Exit)              "compiler constant")
(def-boot-var |$exitMode|                            "???")
(def-boot-var |$exitModeStack|                            "???")
(def-boot-val |$failure| (GENSYM)            "Symbol denoting a failed operation.")
(def-boot-val |$false| NIL                            "???")
(def-boot-val |$Float| '(|Float|)                    "???")
(def-boot-val |$FloatOpt| '(|Float| . OPT)            "???")
(def-boot-val |$FontTable| '(|FontTable|)            "???")
(def-boot-var |$forceDatabaseUpdate|                    "See load function.")
(def-boot-var |$form|                                    "???")
(def-boot-val |$FormalMapVariableList2|
  '(\#\#1 \#\#2 \#\#3 \#\#4 \#\#5 \#\#6 \#\#7 \#\#8 \#\#9
    \#\#10 \#\#11 \#\#12 \#\#13 \#\#14 \#\#15)                    "???")
(def-boot-var |$fromSpadTrace|                            "Interpreter>Trace.boot")
(def-boot-var $function                                    "Interpreter>System.boot")
(def-boot-var $FunName                                    "???")
(def-boot-var $FunnameTail                            "???")
(def-boot-val |$ConstructorNames|
        '(|SubDomain| |List| |Union| |Record| |Vector|)
        "Used in isFunctor test, and compDefine.")
(def-boot-val |$gauss01| '(|gauss| 0 1)                    "???")
(def-boot-var |$genFVar|                            "???")
(def-boot-val |$genSDVar| 0            "counter for genSomeVariable" )
(def-boot-val |$hasCategoryTable| (MAKE-HASHTABLE 'UEQUAL) "???")
(def-boot-var |$hasYield|                            "???")
(def-boot-var |$ignoreCommentsIfTrue|                    "???")
(def-boot-var |$Index|                                    "???")
(def-boot-var |$insideCapsuleFunctionIfTrue|            "???")
(def-boot-var |$insideCategoryIfTrue|                    "???")
(def-boot-var |$insideCoerceInteractiveHardIfTrue|  "???")
(def-boot-val |$insideCompTypeOf| NIL  "checked in comp3")
(def-boot-val |$insideConstructIfTrue| NIL "checked in parse.boot")
(def-boot-var |$insideExpressionIfTrue|                    "???")
(def-boot-var |$insideFunctorIfTrue|                    "???")
(def-boot-var |$insideWhereIfTrue|                    "???")
(def-boot-val |$Integer| '(|Integer|)                    "???")
(def-boot-val |$IntegerOpt| '(|Integer| . OPT)            "???")
(def-boot-val |$InteractiveModemapFrame| '((NIL))   "???")
(def-boot-var |$InteractiveTimingStatsIfTrue|            "???")
(def-boot-var |$LastCxArg|                            "???")
(def-boot-val |$lastUntraced| NIL      "Used for )restore option of )trace.")
(def-boot-var |$leaveLevelStack|                    "???")
(def-boot-var |$leaveMode|                            "???")
(def-boot-val |$letAssoc| NIL            "Used for trace of assignments in SPAD code.")
(def-boot-var |$libFile|                            "Compiler>LispLib.boot")
(def-boot-var $LINENUMBER                            "???")
(def-boot-var $linestack                            "???")
(def-boot-val |$Lisp| '(|Lisp|)                            "???")
(def-boot-val $LISPLIB nil                    "whether to produce a lisplib or not")
(def-boot-var |$lisplibForm|                            "Compiler>LispLib.boot")
(def-boot-var |$lisplibKind|                            "Compiler>LispLib.boot")
(def-boot-var |$lisplibModemapAlist|                    "Compiler>LispLib.boot")
(def-boot-var |$lisplibModemap|                            "Compiler>LispLib.boot")
(def-boot-var |$lisplibOperationAlist|                    "Compiler>LispLib.boot")
(def-boot-var |$lisplibSignatureAlist|                    "Compiler>LispLib.boot")
(def-boot-var |$lisplibVariableAlist|                    "Compiler>LispLib.boot")
(def-boot-val |$LocalFrame| '((NIL))                    "???")
(def-boot-var |$mapSubNameAlist|                    "Interpreter>Trace.boot")
(def-boot-var |$mathTrace|                            "Interpreter>Trace.boot")
(def-boot-var |$mathTraceList|                    "Controls mathprint output for )trace.")
(def-boot-var $maxlinenumber                            "???")
(def-boot-val |$Mode| '(Mode)           "compiler constant")
(def-boot-var |$ModemapFrame|                            "???")
(def-boot-val |$ModeVariableList|
  '(&1 &2 &3 &4 &5 &6 &7 &8 &9 &10 &11
       &12 &13 &14 &15)                                "???")
(def-boot-var |$mostRecentOpAlist|                    "???")
(def-boot-val |$NegativeIntegerOpt| '(|NegativeInteger| . OPT) "???")
(def-boot-val |$NegativeInteger| '(|NegativeInteger|) "???")
(def-boot-val |$NETail| (CONS |$EmptyEnvironment| NIL) "???")
(def-boot-var $NEWLINSTACK                            "???")
(def-boot-var |$noEnv|                                    "???")
(def-boot-val |$NonMentionableDomainNames| '($ |Rep| |Mapping|) "???")
(def-boot-val |$NonNegativeIntegerOpt| '(|NonNegativeInteger| . OPT) "???")
(def-boot-val |$NonNegativeInteger| '(|NonNegativeInteger|) "???")
(def-boot-val |$NonPositiveIntegerOpt| '(|NonPositiveInteger| . OPT) "???")
(def-boot-val |$NonPositiveInteger| '(|NonPositiveInteger|) "???")
(def-boot-var |$noParseCommands|                    "???")
;(def-boot-val |$NoValueMode| '|$NoValueMode|   "compiler literal")
(def-boot-val |$NoValue| '|$NoValue|   "compiler literal")
(def-boot-val $num_of_meta_errors 0                    "Number of errors seen so far")
(def-boot-var $OLDLINE                                    "Used to output command lines.")
(def-boot-val |$oldTime| 0                            "???")
(def-boot-val |$One| '(|One|)                            "???")
(def-boot-val |$OneCoef| '(1 1 . 1)                    "???")
(def-boot-val |$operationNameList| NIL                 "op names for apropos")
(def-boot-var |$opFilter|                            "Used to /s a function")
(def-boot-var |OptionList|                            "???")
(def-boot-val |$optionAlist| nil       "info for trace boot")
(def-boot-var |$OutsideStringIfTrue|                    "???")
(def-boot-val |$PatternVariableList|
  '(*1 *2 *3 *4 *5 *6 *7 *8 *9 *10 *11
       *12 *13 *14 *15)                                "???")
(def-boot-var |$PolyMode|                            "???")
(def-boot-val |$Polvar| '(WRAPPED . ((1 . 1)))            "???")
(def-boot-var |$polyDefaultAssoc|                    "???")
(def-boot-val |$PolyDomains|
        '(|Polynomial| |MultivariatePolynomial|
          |UnivariatePoly|
          |DistributedMultivariatePolynomial|
          |HomogeneousDistributedMultivariatePolynomial|)
        "???")
(def-boot-val |$PositiveIntegerOpt| '(|PositiveInteger| . OPT) "???")
(def-boot-val |$PositiveInteger| '(|PositiveInteger|) "???")
(def-boot-var |$postStack|                            "???")
(def-boot-var |$prefix|                                    "???")
(def-boot-val |$PrettyPrint| nil "if t generated code is prettyprinted")
(def-boot-var |$previousTime|                            "???")
(def-boot-val |$PrimitiveDomainNames| nil
"Used in mkCategory to avoid generating vector slot
for primitive domains.        Also used by putInLocalDomainReferences and optCal.")
(def-boot-val |$optimizableDomainNames|
      '(|FactoredForm| |List| |Vector|
        |Integer| |NonNegativeInteger| |PositiveInteger|
        |SmallInteger| |String| |Boolean| |Symbol| |BooleanFunctions|)
   "used in optCall to decide which domains can be optimized")
(def-boot-val |$PrintBox| '(|PrintBox|)                    "???")
(def-boot-val |$printConStats| nil  "display constructor cache totals")
(def-boot-val |$printLoadMsgs|        't            "Interpreter>SetVarT.boot")
(def-boot-var |$PrintOnly|                            "Compiler>LispLib.boot")
(def-boot-val |$UserSynonyms| ()    "list of user defined synonyms")
(def-boot-val |$SystemSynonyms| () "list of system defined synonyms")
(def-boot-val |$QuickCode| NIL            "Controls generation of QREFELT, etc.")
(def-boot-val |$QuickLet| NIL            "Set to T for no LET tracing.")
(def-boot-var |$QuietIfNil|                            "???")
(def-boot-val |$RationalNumberOpt| '(|RationalNumber| . OPT) "???")
(def-boot-val |$RationalNumber| '(|RationalNumber|) "???")
(def-boot-var |$readingFile|                            "???")
(def-boot-val |$report3| nil         "addMap report info")
(def-boot-var |$reportBottomUpFlag|                    "Interpreter>SetVarT.boot")
(def-boot-var |$reportCoerce|                            "???")
(def-boot-var |$reportCoerceIfTrue|                    "???")
(def-boot-var |$reportCompilation|                    "???")
(def-boot-var |$reportExitModeStack|                    "???")
(def-boot-var |$reportFlag|                            "Interpreter>SetVars.boot")
(def-boot-val |$reportSpadTrace| ()    "report list of traced functions")
(def-boot-var |$resolveFlag|                            "Interpreter>SetVars.boot")
(def-boot-var |$returnMode|                            "???")
(def-boot-var |$scanModeFlag|                            "???")
(def-boot-var |$semanticErrorStack|                    "???")
(def-boot-val |$SetFunctions| nil  "checked in SetFunctionSlots")
(def-boot-val |$SideEffectFreeFunctionList|
  '(|null| |case| |Zero| |One| \: \:\: |has| |Mapping|
    |elt| = \> \>= \< \<= MEMBER |is| |isnt| ATOM
    $= $\> $\>= $\< $\<= $^= $MEMBER)                "???")
(def-boot-var |$slamFlag|                            "Interpreter>SetVars.boot")
(def-boot-val |$SmallInteger| '(|SmallInteger|)            "???")
(def-boot-val |$SmallIntegerOpt| '(|SmallInteger| . OPT) "???")
(def-boot-val |$sourceFileTypes|
          '(INPUT SPAD BOOT LISP LISP370 META)
          "Interpreter>System.boot")
(def-boot-val $SPAD nil                                    "Is this Spad code?")
(def-boot-var $SPAD_ERRORS                            "???")
(def-boot-val |$spadLibFT| 'LISPLIB                    "???")
(def-boot-val |$SpecialDomainNames|
  '(|add| |CAPSULE| |SubDomain| |List| |Union| |Record| |Vector|)
  "Used in isDomainForm, addEmptyCapsuleIfnecessary.")
(def-boot-val |$streamCount| 0                            "???")
(def-boot-var |$streamIndexing|                            "???")
(def-boot-val |$StreamIndex| 0                            "???")
(def-boot-val |$StringCategory| '(|StringCategory|) "???")
(def-boot-val |$StringOpt| '(|String| . OPT)            "???")
(def-boot-val |$String| '(|String|)                    "???")
(def-boot-var |$suffix|                                    "???")
(def-boot-val |$Symbol| '(|Symbol|)                    "???")
(def-boot-val |$SymbolOpt| '(|Symbol| . OPT)            "???")
(def-boot-val |$tempCategoryTable| (MAKE-HASHTABLE 'UEQUAL) "???")
(def-boot-val |$timerOn| t                            "???")
(def-boot-var |$topOp|                                   "See displayPreCompilationErrors")
(def-boot-var |$tokenCommands|                            "???")
(def-boot-var $TOKSTACK                                    "???")
(def-boot-val $TOP_LEVEL t                            "???")
(def-boot-var $top_stack                            "???")
(def-boot-var |$tracedModemap|                            "Interpreter>Trace.boot")
(def-boot-val |$traceDomains| t                             "enables domain tracing")
(def-boot-val |$TraceFlag| t                            "???")
(def-boot-var |$tracedSpadModemap|                    "Interpreter>Trace.boot")
(def-boot-var |$traceletFunctions|                    "???")
(def-boot-var |$traceNoisely|                            "Interpreter>Trace.boot")
(def-boot-var |$TranslateOnly|                            "???")
(def-boot-var |$tripleCache|                            "Compiler>Compiler.boot")
(def-boot-val |$true| ''T                            "???")
(def-boot-var $Type                                    "???")
(def-boot-val |$underDomainAlist|
        '((|DistributedMultivariatePolynomial| . 2)
          (|FactoredForm| . 1)
          (|FactoredRing| . 1)
          (|Gaussian| . 1)
          (|List| . 1)
          (|Matrix| . 1)
          (|MultivariatePolynomial| . 2)
          (|HomogeneousDistributedMultivariatePolynomial| . 2)
          (|Polynomial| . 1)
          (|QuotientField| . 1)
          (|RectangularMatrix| . 3)
          (|SquareMatrix| . 2)
          (|UnivariatePoly| . 2)
          (|Vector| . 1)
          (|VVectorSpace| . 2))                        "???")

(def-boot-val |$updateCatTableIfTrue| T           "update category table on load")
(def-boot-var |$updateIfTrue|
          "Should SPAD databases be updated&squeezed?")
(def-boot-val |$useBFasDefault| T
          "Determines whether to use BF as default floating point type.")
(def-boot-val |$useDCQnotLET| () "checked in DEF-LET for use of DCQ")
(def-boot-fun BUMPCOMPERRORCOUNT ()                    "errorSupervisor1")
(def-boot-var |$VariableCount|                      "???")
(def-boot-var |$warningStack|                       "???")
(def-boot-val |$whereList| () "referenced in format boot formDecl2String")
(def-boot-var |$xCount|                             "???")
(def-boot-var |$xyCurrent|                          "???")
(def-boot-var |$xyInitial|                          "???")
(def-boot-var |$xyMax|                              "???")
(def-boot-var |$xyMin|                              "???")
(def-boot-var |$xyStack|                            "???")
(def-boot-val |$Zero| '(|Zero|)                     "???")

(def-boot-val |$domainsWithUnderDomains|
          (mapcar #'car |$underDomainAlist|)    "???")
(def-boot-val |$inputPromptType| '|step|  "checked in MKPROMPT")
(def-boot-val |$IOindex| 0                 "step counter")

(defvar |$definingMap| nil)
 
(defmacro KAR (ARG) `(ifcar ,arg))
(defmacro KDR (ARG) `(ifcdr ,arg))
(defmacro KADR (ARG) `(ifcar (ifcdr ,arg)))
(defmacro KADDR (ARG) `(ifcar (ifcdr (ifcdr ,arg))))

; 5 PROGRAM STRUCTURE
 
; 5.3 Top-Level Forms
 
(defun SETANDFILE (x y) (LAM\,EVALANDFILEACTQ `(setq ,x ',y)))
 
; 5.3.2 Declaring Global Variables and Named Constants
 
(defmacro |function| (name) `(FUNCTION ,name))
(defmacro |dispatchFunction| (name) `(FUNCTION ,name))
 
(defun |macrop| (fn) (and (identp fn) (macro-function fn)))
 
; 6 PREDICATES
 
; 6.2 Data Type Predicates
 
; 6.3 Equality Predicates
 
;; qeqcar should be used when you know the first arg is a pair
;; the second arg should either be a literal fixnum or a symbol
;; the car of the first arg is always of the same type as the second
;; use eql unless we are sure fixnums are represented canonically
 
(defmacro qeqcar (x y)
  (if (integerp y) `(eql (the fixnum (qcar ,x)) (the fixnum ,y))
      `(eq (qcar ,x) ,y)))
 
(defun COMPARE (X Y)
  "True if X is an atom or X and Y are lists and X and Y are equal up to X."
  (COND ((ATOM X) T)
        ((ATOM Y) NIL)
        ((EQUAL (CAR X) (CAR Y)) (COMPARE (CDR X) (CDR Y)))))
 
 
(DEFUN ?ORDER (U V)  "Multiple-type ordering relation."
  (COND ((NULL U))
        ((NULL V) NIL)
        ((ATOM U)
         (if (ATOM V)
             (COND ((NUMBERP U) (if (NUMBERP V) (> V U) T))
                   ((NUMBERP V) NIL)
                   ((IDENTP U) (AND (IDENTP V) (string> (SYMBOL-NAME V) (SYMBOL-NAME U))))
                   ((IDENTP V) NIL)
                   ((STRINGP U) (AND (STRINGP V) (string> V U)))
                   ((STRINGP V) NIL)
                   ((AND (VECP U) (VECP V))
                    (AND (> (SIZE V) (SIZE U))
                         (DO ((I 0 (1+ I)))
                             ((GT I (MAXINDEX U)) 'T)
                           (COND ((NOT (EQUAL (ELT U I) (ELT V I)))
                                  (RETURN (?ORDER (ELT U I) (ELT V I))))))))
                   ((croak "Do not understand")))
               T))
        ((ATOM V) NIL)
        ((EQUAL U V))
        ((NOT (string> (write-to-string U) (write-to-string V))))))
 
(defmacro boot-equal (a b)
   (cond ((ident-char-lit a)
           `(or (eql ,a ,b) (eql (character ,a) ,b)))
         ((ident-char-lit b)
           `(or (eql ,a ,b) (eql ,a (character ,b))))
         (t `(eqqual ,a ,b))))
 
(defun ident-char-lit (x)
   (and (eqcar x 'quote) (identp (cadr x)) (= (length (pname (cadr x))) 1)))
 
(defmacro EQQUAL (a b)
  (cond ((OR (EQUABLE a) (EQUABLE b)) `(eq ,a ,b))
        ((OR (numberp a) (numberp b)) `(eql ,a ,b))
        (t  `(equal ,a ,b))))
 
(defmacro NEQUAL (a b) `(not (BOOT-EQUAL ,a ,b)))
 
(defun EQUABLE (X)
  (OR (NULL X) (AND (EQCAR X 'QUOTE) (symbolp (CADR X)))))
 
; 7 CONTROL STRUCTURE
 
; 7.1 Constants and Variables
 
; 7.1.1 Reference
 
(DEFUN MKQ (X)
  "Evaluates an object and returns it with QUOTE wrapped around it."
  (if (NUMBERP X) X (LIST 'QUOTE X)))
 
; 7.2 Generalized Variables
 
(defmacro IS (x y) `(dcq ,y ,x))
 
(defmacro LETT (var val &rest L)
  (COND
    (|$QuickLet| `(SETQ ,var ,val))
    (|$compilingMap|
   ;; map tracing
     `(PROGN
        (SETQ ,var ,val)
        (COND (|$letAssoc|
               (|mapLetPrint| ,(MKQ var)
                              ,var
                              (QUOTE ,(KAR L))))
              ('T ,var))))
     ;; used for LETs in SPAD code --- see devious trick in COMP,TRAN,1
     ((ATOM var)
      `(PROGN
         (SETQ ,var ,val)
         (IF |$letAssoc|
             ,(cond ((null (cdr l))
                     `(|letPrint| ,(MKQ var) ,var (QUOTE ,(KAR L))))
                    ((and (eqcar (car l) 'SPADCALL) (= (length (car l)) 3))
                     `(|letPrint3| ,(MKQ var) ,var ,(third (car l)) (QUOTE ,(KADR L))))
                    (t `(|letPrint2| ,(MKQ var) ,(car l) (QUOTE ,(KADR L))))))
         ,var))
     ('T (ERROR "Cannot compileLET construct"))))
 
(defmacro SPADLET (A B)
  (if (ATOM A) `(SETQ ,A ,B)
     `(OR (IS ,B ,A) (letError ,(MK_LEFORM A) ,(MKQ B) ))))
 
(defmacro RPLAC (&rest L)
  (if (EQCAR (CAR L) 'ELT)
      (LIST 'SETELT (CADAR L) (CADDR (CAR L)) (CADR L))
      (let ((A (CARCDREXPAND (CAR L) NIL)) (B (CADR L)))
        (COND ((CDDR L) (ERROR 'RPLAC))
              ((EQCAR A 'CAR) (LIST 'RPLACA (CADR A) B))
              ((EQCAR A 'CDR) (LIST 'RPLACD (CADR A) B))
              ((ERROR 'RPLAC))))))
 
(MAPC #'(lambda (j)
         (setf (get (first j) 'selcode) (second j)))
      '((CAR 2) (CDR 3) (CAAR 4) (CADR 5) (CDAR 6) (CDDR 7)
        (CAAAR 8) (CAADR 9) (CADAR 10) (CADDR 11) (CDAAR 12)
        (CDADR 13) (CDDAR 14) (CDDDR 15) (CAAAAR 16) (CAAADR 17)
        (CAADAR 18) (CAADDR 19) (CADAAR 20) (CADADR 21) (CADDAR 22)
        (CADDDR 23) (CDAAAR 24) (CDAADR 25) (CDADAR 26) (CDADDR 27)
        (CDDAAR 28) (CDDADR 29) (CDDDAR 30) (CDDDDR 31)))
 
(eval-when (compile eval load)
(defun CARCDREXPAND (X FG)    ; FG = TRUE FOR CAR AND CDR
    (let (n hx)
      (COND ((ATOM X) X)
            ((SETQ N (GET (RENAME (SETQ HX (CARCDREXPAND (CAR X) FG))) 'SELCODE))
             (CARCDRX1 (CARCDREXPAND (CADR X) FG) N FG))
            ((CONS HX (MAPCAR #'(LAMBDA (Y) (CARCDREXPAND Y FG)) (CDR X)))))))
 
(DEFUN RENAME (U) 
 (let (x)
  (if (AND (IDENTP U) (SETQ X (GET U 'NEWNAM))) X U)))
 
(defun CARCDRX1 (X N FG)      ; FG = TRUE FOR CAR AND CDR
    (COND ((< N 1) (fail))
          ((EQL N 1) X)
          ((let ((D (DIVIDE N 2)))
             (CARCDRX1 (LIST (if (EQL (CADR D) 0) (if FG 'CAR 'CAR) (if FG 'CDR 'CDR)) X)
                       (CAR D)
                       FG))))))
 
 
; 7.3 Function Invocation
 
(DEFUN APPLYR (L X) (if (not L) X  (LIST (CAR L) (APPLYR (CDR L) X))))
 
; 7.8 Iteration
 
; 7.8.2 General Iteration
 
(defmacro REPEAT (&rest L)
  (let ((U (REPEAT-TRAN L NIL))) (-REPEAT (CDR U) (CAR U))))
 
(defun REPEAT-TRAN (L LP)
  (COND ((ATOM L) (ERROR "REPEAT FORMAT ERROR"))
        ((MEMBER (KAR (KAR L))
                 '(EXIT RESET IN ON GSTEP ISTEP STEP GENERAL UNTIL WHILE SUCHTHAT EXIT))
         (REPEAT-TRAN (CDR L) (CONS (CAR L) LP)))
        ((CONS (NREVERSE LP) (MKPF L 'PROGN)))))
 
(DEFUN MKPF (L OP)
  (if (FLAGP OP 'NARY) (SETQ L (MKPFFLATTEN-1 L OP NIL)))
  (MKPF1 L OP))
 
(DEFUN MKPFFLATTEN (X OP)
  (COND ((ATOM X) X)
        ((EQL (CAR X) OP) (CONS OP (MKPFFLATTEN-1 (CDR X) OP NIL)))
        ((CONS (MKPFFLATTEN (CAR X) OP) (MKPFFLATTEN (CDR X) OP)))))
 
(DEFUN MKPFFLATTEN-1 (L OP R)
  (let (X)
    (if (NULL L)
        R
        (MKPFFLATTEN-1 (CDR L) OP
           (APPEND R (if (EQCAR (SETQ X
                                      (MKPFFLATTEN (CAR L) OP)) OP)
                         (CDR X) (LIST X)))))))
 
(DEFUN MKPF1 (L OP)
  (let (X) (case OP (+ (COND ((EQL 0 (SETQ X (LENGTH
                                                 (SETQ L (S- L '(0 (ZERO))))))) 0)
                                ((EQL 1 X) (CAR L))
                                ((CONS '+ L)) ))
                 (TIMES (COND ((S* L '(0 (ZERO))) 0)
                              ((EQL 0 (SETQ X (LENGTH
                                               (SETQ L (S- L '(1 (ONE))))))) 1)
                              ((EQL 1 X) (CAR L))
                              ((CONS 'TIMES L)) ))
                 (QUOTIENT (COND ((> (LENGTH L) 2) (fail))
                                 ((EQL 0 (CAR L)) 0)
                                 ((EQL (CADR L) 1) (CAR L))
                                 ((CONS 'QUOTIENT L)) ))
                 (MINUS (COND ((CDR L) (FAIL))
                              ((NUMBERP (SETQ X (CAR L))) (MINUS X))
                              ((EQCAR X 'MINUS) (CADR X))
                              ((CONS 'MINUS L))  ))
                 (DIFFERENCE (COND ((> (LENGTH L) 2) (FAIL))
                                   ((EQUAL (CAR L) (CADR L)) '(ZERO))
                                   ((|member| (CAR L) '(0 (ZERO))) (MKPF (CDR L) 'MINUS))
                                   ((|member| (CADR L) '(0 (ZERO))) (CAR L))
                                   ((EQCAR (CADR L) 'MINUS)
                                    (MKPF (LIST (CAR L) (CADADR L)) '+))
                                   ((CONS 'DIFFERENCE L)) ))
                 (EXPT (COND ((> (LENGTH L) 2) (FAIL))
                             ((EQL 0 (CADR L)) 1)
                             ((EQL 1 (CADR L)) (CAR L))
                             ((|member| (CAR L) '(0 1 (ZERO) (ONE))) (CAR L))
                             ((CONS 'EXPT L)) ))
                 (OR (COND ((MEMBER 'T L) ''T)
                           ((EQL 0 (SETQ X (LENGTH (SETQ L (REMOVE NIL L))))) NIL)
                           ((EQL 1 X) (CAR L))
                           ((CONS 'OR L)) ))
                 (|or| (COND ((MEMBER 'T L) 'T)
                             ((EQL 0 (SETQ X (LENGTH (SETQ L (REMOVE NIL L))))) NIL)
                             ((EQL 1 X) (CAR L))
                             ((CONS 'or L)) ))
                 (NULL (COND ((CDR L) (FAIL))
                             ((EQCAR (CAR L) 'NULL) (CADAR L))
                             ((EQL (CAR L) 'T) NIL)
                             ((NULL (CAR L)) ''T)
                             ((CONS 'NULL L)) ))
                 (|and| (COND ((EQL 0 (SETQ X (LENGTH
                                               (SETQ L (REMOVE T (REMOVE '|true| L)))))) T)
                              ((EQL 1 X) (CAR L))
                              ((CONS '|and| L)) ))
                 (AND (COND ((EQL 0 (SETQ X (LENGTH
                                             (SETQ L (REMOVE T (REMOVE '|true| L)))))) ''T)
                            ((EQL 1 X) (CAR L))
                            ((CONS 'AND L)) ))
                 (PROGN (COND ((AND (NOT (ATOM L)) (NULL (LAST L)))
                               (if (CDR L) `(PROGN . ,L) (CAR L)))
                              ((NULL (SETQ L (REMOVE NIL L))) NIL)
                              ((CDR L) (CONS 'PROGN L))
                              ((CAR L))))
                 (SEQ (COND ((EQCAR (CAR L) 'EXIT) (CADAR L))
                            ((CDR L) (CONS 'SEQ L))
                            ((CAR L))))
                 (LIST (if L (cons 'LIST L)))
                 (CONS (if (cdr L) (cons 'CONS L) (car L)))
                 (t (CONS OP L) ))))
 
(defvar $TRACELETFLAG NIL "Also referred to in Comp.Lisp")
 
(defmacro |Zero| (&rest L) 
 (declare (ignore l)) 
 "Needed by spadCompileOrSetq" 0)
 
(defmacro |One| (&rest L)
 (declare (ignore l))
 "Needed by spadCompileOrSetq" 1)
 
(defun -REPEAT (BD SPL)
 (labels (
   (seqoptimize (u)
   (if (and (eqcar (cadr u) 'exit) (eqcar (cadadr u) 'seq))
       (cadadr u)
       u)))
  (let (u g g1 inc final xcl xv il rsl tll funPLUS funGT fun? funIdent
        funPLUSform funGTform)
    (DO ((X SPL (CDR X)))
        ((ATOM X)
         (LIST 'spadDO (NREVERSE IL) (LIST (MKPF (NREVERSE XCL) 'OR) XV)
          (seqoptimize 
            (CONS 'SEQ (NCONC (NREVERSE RSL) (LIST (LIST 'EXIT BD)))))))
      (COND ((ATOM (CAR X)) (FAIL)))
      (COND ((AND (EQ (CAAR X) 'STEP)
                  (|member| (CADDAR X) '(2 1 0 (|One|) (|Zero|)))
                  (|member| (CADR (CDDAR X)) '(1 (|One|))))
             (SETQ X (CONS (CONS 'ISTEP (CDAR X)) (CDR X))) ))
                        ; A hack to increase the likelihood of small integers
      (SETQ U (CDAR X))
      (case (CAAR X)
        (GENERAL (AND (CDDDR U) (PUSH (CADDDR U) XCL))
                 (PUSH (LIST (CAR U) (CADR U) (CADDR U)) IL) )
        (GSTEP
          (SETQ tll (CDDDDR U))  ;tll is (+fun >fun type? ident)
          (SETQ funPLUSform (CAR tll))
          (SETQ funGTform   (CAR (SETQ tll (QCDR tll))))
          (PUSH (LIST (SETQ funPLUS (GENSYM)) funPLUSform) IL)
          (PUSH (LIST (SETQ funGT   (GENSYM)) funGTform) IL)
          (COND ((SETQ tll (CDR tll)) 
            (SETQ fun?     (CAR tll))
            (SETQ funIdent (CAR (SETQ tll (QCDR tll))))))
          (IF (NOT (ATOM (SETQ inc (CADDR U)) ))
              (PUSH (LIST (SETQ inc (GENSYM)) (CADDR U)) IL))
          (SETQ final (CADDDR U))
          (COND (final
             (COND ((ATOM final))
                   ((PUSH (LIST (SETQ final (GENSYM)) (CADDDR U)) IL)))
                 ; If CADDDR U is not an atom, only compute the value once
             (PUSH
                (if fun? 
                      (if (FUNCALL fun? INC)
                          (if  (FUNCALL (EVAL funGTform) INC funIdent) 
                               (LIST 'FUNCALL funGT (CAR U) FINAL)
                               (LIST 'FUNCALL funGT FINAL (CAR U)))
                           (LIST 'IF (LIST 'FUNCALL funGT INC funIdent)
                                     (LIST 'FUNCALL funGT (CAR U) FINAL)
                                     (LIST 'FUNCALL funGT FINAL  (CAR U))))
                       (LIST 'FUNCALL funGT (CAR U) final))
                     XCL)))
          (PUSH (LIST (CAR U) (CADR U) (LIST 'FUNCALL funPLUS (CAR U) INC)) IL))
        (STEP
          (IF (NOT (ATOM (SETQ inc (CADDR U)) ))
              (PUSH (LIST (SETQ inc (GENSYM)) (CADDR U)) IL))
          (COND ((CDDDR U)
                 (COND ((ATOM (SETQ final (CADDDR U)) ))
                       ((PUSH (LIST (SETQ final (GENSYM)) (CADDDR U)) IL)))
                 ; If CADDDR U is not an atom, only compute the value once
                 (PUSH
                   (if (INTEGERP INC)
                       (LIST (if  (MINUSP INC) '< '>) (CAR U) FINAL)
                     `(if (MINUSP ,INC)
                          (< ,(CAR U) ,FINAL)
                        (> ,(CAR U) ,FINAL)))
                       XCL)))
          (PUSH (LIST (CAR U) (CADR U) (LIST '+ (CAR U) INC)) IL))
        (ISTEP
          (IF (NOT (ATOM (SETQ inc (CADDR U)) ))
              (PUSH (LIST (SETQ inc (GENSYM)) (CADDR U)) IL))
          (COND ((CDDDR U)
                 (COND ((ATOM (SETQ final (CADDDR U)) ))
                       ((PUSH (LIST (SETQ final (GENSYM)) (CADDDR U)) IL)))
                     ; If CADDDR U is not an atom, only compute the value once
                 (PUSH
                   (if (INTEGERP INC)
                       (LIST (if  (QSMINUSP INC) 'QSLESSP 'QSGREATERP)
                             (CAR U) FINAL)
                     `(if (QSMINUSP ,INC)
                          (QSLESSP ,(CAR U) ,FINAL)
                        (QSGREATERP ,(CAR U) ,FINAL)))
                       XCL)))
          (PUSH (LIST (CAR U) (CADR U)
                      (COND ((|member| INC '(1 (|One|)))
                             (MKQSADD1 (CAR U)))
                            ((LIST 'QSPLUS (CAR U) INC)) ))
                IL))
        (ON (PUSH (LIST 'ATOM (CAR U)) XCL)
            (PUSH (LIST (CAR U) (CADR U) (LIST 'CDR (CAR U))) IL))
        (RESET (PUSH (LIST 'PROGN (CAR U) NIL) XCL))
        (IN
          (PUSH (LIST 'OR
                      (LIST 'ATOM (SETQ G (GENSYM)))
                      (CONS 'PROGN
                            (CONS
                              (LIST 'SETQ (CAR U) (LIST 'CAR G))
                              (APPEND
                                (COND ((AND (symbol-package (car U)) $TRACELETFLAG)
                                       (LIST (LIST '/TRACELET-PRINT (CAR U)
                                                   (CAR U))))
                                      (NIL))
                                (LIST NIL))))  ) XCL)
          (PUSH (LIST G (CADR U) (LIST 'CDR G)) IL)
          (PUSH (LIST (CAR U) NIL) IL))
        (INDOM (SETQ G (GENSYM))
               (SETQ G1 (GENSYM))
               (PUSH (LIST 'ATOM G) XCL)
               (PUSH (LIST G (LIST 'INDOM-FIRST (CADR U))
                           (LIST 'INDOM-NEXT G1)) IL)
               (PUSH (LIST (CAR U) NIL) IL)
               (PUSH (LIST G1 NIL) IL)
               (PUSH (LIST 'SETQ G1 (LIST 'CDR G)) RSL)
               (PUSH (LIST 'SETQ (CAR U) (LIST 'CAR G)) RSL))
        (UNTIL (SETQ G (GENSYM)) (PUSH (LIST G NIL (CAR U)) IL) (PUSH G XCL))
        (WHILE (PUSH (LIST 'NULL (CAR U)) XCL))
        (SUCHTHAT (SETQ BD (LIST 'SUCHTHATCLAUSE BD (CAR U))))
        (EXIT (SETQ XV (CAR U))) (FAIL))))))
 
(defmacro SUCHTHATCLAUSE  (&rest L) (LIST 'COND (LIST (CADR L) (CAR L))))
 
(defvar $BOOT NIL)
 
(defmacro spadDO (&rest OL)
    (PROG (VARS L VL V U INITS U-VARS U-VALS ENDTEST EXITFORMS BODYFORMS)
         (if (OR $BOOT (NOT $NEWSPAD)) (return (CONS 'DO OL)))
         (SETQ L  (copy-list OL))
         (if (OR (ATOM L) (ATOM (CDR L))) (GO BADO))
         (setq vl (POP L))
         (COND ((IDENTP VL)
                (SETQ VARS (LIST VL))
                (AND (OR (ATOM L)
                         (ATOM (progn (setq inits (POP L)) L))
                         (ATOM (progn (setq u-vals (pop L)) L)))
                     (GO BADO))
                (SETQ INITS (LIST INITS) U-VARS (LIST (CAR VARS)) U-VALS (LIST U-VALS))
                (setq endtest (POP L)))
               ((prog nil
                        (COND ((NULL VL) (GO TG5)) ((ATOM VL) (GO BADO)))
                 G180   (AND (NOT (CONSP (SETQ V (CAR VL)))) (SETQ V (LIST V)))
                        (AND (NOT (IDENTP (CAR V))) (GO BADO))
                        (PUSH (CAR V) VARS)
                        (PUSH (COND ((CONSP (CDR V)) (CADR V))) INITS)
                        (AND (CONSP (CDR V))
                             (CONSP (CDDR V))
                             (SEQ (PUSH (CAR V) U-VARS)
                                  (PUSH (CADDR V) U-VALS)))
                        (AND (CONSP (progn (POP VL) VL)) (GO G180))
                    TG5 (setq exitforms (POP L))
                        (and (CONSP EXITFORMS)
                             (progn (setq endtest (POP EXITFORMS)) exitforms)))))
         (AND L
           (COND ((CDR L) (SETQ BODYFORMS (CONS 'SEQ L)))
                 ((NULL (EQCAR (CAR L) 'SEQ)) (SETQ BODYFORMS (CONS 'SEQ L)))
                 ((SETQ BODYFORMS (CAR L)))))
         (SETQ EXITFORMS `(EXIT ,(MKPF EXITFORMS 'PROGN)))
         (AND ENDTEST (SETQ ENDTEST (LIST 'COND (LIST ENDTEST '(GO G191)))))
         (COND ((NULL U-VARS) (GO XT) )
               ((NULL (CDR U-VARS))
                (SEQ (SETQ U-VARS (LIST 'SETQ (CAR U-VARS) (CAR U-VALS)))
                     (GO XT)) ))
         (SETQ VL (LIST 'SETQ (CAR U-VARS) (CAR U-VALS)))
         (SEQ (SETQ V (CDR U-VARS)) (SETQ U (CDR U-VALS)))
     TG  (SETQ VL (LIST 'SETQ (CAR V) (LIST 'PROG1 (CAR U) VL)))
         (POP U)
         (AND (progn (POP V) V)  (GO TG))
         (SETQ U-VARS VL)
     XT  (RETURN (COND
           ((AND $NEWSPAD (NULL $BOOT))
             (CONS 'SEQ (NCONC (DO_LET VARS INITS)
               (LIST 'G190 ENDTEST BODYFORMS U-VARS '(GO G190)
                'G191 EXITFORMS))))
           ((CONS `(LAMBDA ,(NRECONC VARS NIL)
                     (SEQ G190 ,ENDTEST ,BODYFORMS ,U-VARS (GO G190) G191 ,EXITFORMS))
                  (NRECONC INITS NIL)))))
   BADO  (ERROR (FORMAT NIL "BAD DO FORMAT~%~A" OL))))
 
(defun DO_LET (VARS INITS)
  (if (OR (NULL VARS) (NULL INITS)) NIL
      (CONS (LIST 'SPADLET (CAR VARS) (CAR INITS))
           (DO_LET (CDR VARS) (CDR INITS)))))
 
(defun NREVERSE0 (X) ; Already built-in to CCL
  "Returns LST, reversed. The argument is modified.
This version is needed so that (COLLECT (IN X Y) ... (RETURN 'JUNK))=>JUNK."
 (if (ATOM X) X (NREVERSE X)))
 
; 7.8.4 Mapping
 
(defmacro COLLECT (&rest L)
  (let ((U (REPEAT-TRAN L NIL)))
    (CONS 'THETA (CONS '\, (NCONC (CAR U) (LIST (CDR U)))))))
 
;; The following was changed to a macro for efficiency in CCL.  To change
;; it back to a function would require recompilation of a large chunk of
;; the library.
(defmacro PRIMVEC2ARR (x) x) ;redefine to change Array rep

(defmacro COLLECTVEC (&rest L)
   `(PRIMVEC2ARR (COLLECTV ,@L)))

(defmacro COLLECTV (&rest L)
  (PROG (CONDS BODY ANS COUNTER X Y)
         ;If we can work out how often we will go round
         ;allocate a vector first
    (SETQ CONDS NIL)
    (SETQ BODY (REVERSE L))
    (SETQ ANS (GENSYM))
    (SETQ COUNTER NIL)
    (SETQ X (CDR BODY))
    (SETQ BODY (CAR BODY))
LP  (COND ((NULL X)
            (COND ((NULL COUNTER)
                    (SETQ COUNTER (GENSYM))
                    (SETQ L (CONS (LIST 'ISTEP COUNTER 0 1) L)) ))
            (RETURN (LIST 'PROGN
                          (LIST 'SPADLET ANS
                                     (LIST 'make-array
                                           (COND ((NULL CONDS) (fail))
                                                 ((NULL (CDR CONDS))
                                                   (CAR CONDS))
                                                   ((CONS 'MIN CONDS)) ) ))
                          (CONS 'REPEAT (NCONC (CDR (REVERSE L))
                                        (LIST (LIST 'SETELT ANS COUNTER BODY))))
                          ANS)) ))
    (SETQ Y (CAR X))
    (SETQ X (CDR X))
    (COND ((member (CAR Y) '(SUCHTHAT WHILE UNTIL))
                (RETURN (LIST 'LIST2VEC (CONS 'COLLECT L)) ))
          ((member (CAR Y) '(IN ON) :test #'eq)
            (SETQ CONDS (CONS (LIST 'SIZE (CADDR Y)) CONDS))
            (GO LP))
          ((member (CAR Y) '(STEP ISTEP) :test #'eq)
            (if (AND (EQL (CADDR Y) 0) (EQL (CADDDR Y) 1))
                (SETQ COUNTER (CADR Y)) )
            (COND ((CDDDDR Y)    ; there may not be a limit
                   (SETQ CONDS (CONS
                                 (COND ((EQL 1 (CADDDR Y))
                                        (COND ((EQL 1 (CADDR Y)) (CAR (CDDDDR Y)))
                                              ((EQL 0 (CADDR Y)) (MKQSADD1 (CAR (CDDDDR Y))))
                                              ((MKQSADD1 `(- ,(CAR (CDDDDR Y)) ,(CADDR Y))))))
                                       ((EQL 1 (CADDR Y)) `(/ ,(CAR (CDDDDR Y)) ,(CADDR Y)))
                                       ((EQL 0 (CADDR Y))
                                        `(/ ,(MKQSADD1 (CAR (CDDDDR Y))) ,(CADDR Y)))
                                       (`(/ (- ,(MKQSADD1 (CAR (CDDDDR Y))) ,(CADDR Y))
                                            ,(CADDR Y))))
                                 CONDS))))
            (GO LP)))
  (ERROR "Cannot handle macro expansion")))
 
(defun MKQSADD1 (X)
  (COND ((ATOM X) `(QSADD1 ,X))
        ((AND (member (CAR X) '(-DIFFERENCE QSDIFFERENCE -) :test #'eq)
              (EQL 1 (CADDR X)))
         (CADR X))
        (`(QSADD1 ,X))))
 
; 7.10 Dynamic Non-local Exits
 
(defmacro yield (L)
  (let ((g (gensym)))
    `(let ((,g (state)))
       (if (statep ,g) (throw 'yield (list 'pair ,L) ,g)))))
 
; 10.1 The Property List
 
(defun flag (l key)
  "Set the KEY property of every item in list L to T."
  (mapc #'(lambda (item) (setf (get item key) t)) l))
 
(FLAG '(* + AND OR PROGN) 'NARY)                ; flag for MKPF
 
(DEFUN REMFLAG (L KEY)
  "Set the KEY property of every item in list L to NIL."
  (OR (ATOM L) (SEQ (REMPROP (CAR L) KEY) (REMFLAG (CDR L) KEY))))
 
(DEFUN FLAGP (X KEY)
  "If X has a KEY property, then FLAGP is true."
  (GET X KEY))
 
(defun PROPERTY (X IND N)
  "Returns the Nth element of X's IND property, if it exists."
  (let (Y) (if (AND (INTEGERP N) (SETQ Y (GET X IND)) (>= (LENGTH Y) N)) (ELEM Y N))))
 
; 10.3 Creating Symbols
 
(defmacro INTERNL (a &rest b) (if (not b) `(intern ,a) `(intern (strconc ,a . ,b))))

(defvar $GENNO 0)
 
(DEFUN GENVAR () (INTERNL "$" (STRINGIMAGE (SETQ $GENNO (1+ $GENNO)))))
 
(DEFUN IS_GENVAR (X)
  (AND (IDENTP X)
       (let ((y (symbol-name x)))
         (and (char= #\$ (elt y 0)) (> (size y) 1) (digitp (elt y 1))))))
 
(DEFUN IS_\#GENVAR (X)
  (AND (IDENTP X)
       (let ((y (symbol-name x)))
         (and (char= #\# (ELT y 0)) (> (SIZE Y) 1) (DIGITP (ELT Y 1))))))
 
; 10.7 CATCH and THROW
 
; 12 NUMBERS
 
; 12.3 Comparisons on Numbers
 
(defmacro IEQUAL (&rest L) `(eql . ,L))
(defmacro GE (&rest L) `(>= . ,L))
(defmacro GT (&rest L) `(> . ,L))
(defmacro LE (&rest L) `(<= . ,L))
(defmacro LT (&rest L) `(< . ,L))
 
; 12.4 Arithmetic Operations
 
(defmacro SPADDIFFERENCE (&rest x) `(- . ,x))
 
; 12.5 Irrational and Transcendental Functions
 
; 12.5.1 Exponential and Logarithmic Functions
 
(define-function 'QSEXPT #'expt)
 
; 12.6 Small Finite Field ops with vector trimming
 
;; following macros assume 0 <= x,y < z

(defmacro qsaddmod (x y z)
  `(let* ((sum (qsplus ,x ,y))
          (rsum (qsdifference sum ,z)))
     (if (qsminusp rsum) sum rsum)))
 
(defmacro qsdifmod (x y z)
  `(let ((dif (qsdifference ,x ,y)))
     (if (qsminusp dif) (qsplus dif ,z) dif)))
 
(defmacro qsmultmod (x y z)
 `(rem (* ,x ,y) ,z))
 
(defun TRIMLZ (vec)
  (declare (simple-vector vec))
  (let ((n (position 0 vec :from-end t :test-not #'eql)))
     (cond ((null n) (vector))
           ((eql n (qvmaxindex vec)) vec)
           (t (subseq vec 0 (+ n 1))))))
 
; 14 SEQUENCES
 
; 14.1 Simple Sequence Functions
 
(DEFUN NLIST (N FN)
  "Returns a list of N items, each initialized to the value of an
 invocation of FN"
  (if (LT N 1) NIL (CONS (EVAL FN) (NLIST (SUB1 N) FN))))
 
(define-function 'getchar #'elt)
 
(defun GETCHARN (A M) "Return the code of the Mth character of A"
  (let ((a (if (identp a) (symbol-name a) a))) (char-code (elt A M))))
 
; 14.2 Concatenating, Mapping, and Reducing Sequences
 
(DEFUN STRINGPAD (STR N)
  (let ((M (length STR)))
    (if (>= M N)
        STR
        (concatenate 'string str (make-string (- N M) :initial-element #\Space)))))
 
(DEFUN STRINGSUFFIX (TARGET SOURCE) "Suffix source to target if enough room else nil."
  (concatenate 'string target source))
 
(defun NSTRCONC (s1 s2) (concatenate 'string (string s1) (string s2)))
 
(defmacro spadREDUCE (OP AXIS BOD) (REDUCE-1 OP AXIS BOD))
 
(MAPC #'(lambda (x) (setf (get (first x) 'theta) (rest x)))
      '((PLUS 0) (+ (|Zero|)) (|lcm| (|One|)) (STRCONC "") (|strconc| "")
        (MAX -999999) (MIN 999999) (TIMES 1) (* (|One|)) (CONS NIL)
        (APPEND NIL) (|append| NIL) (UNION NIL) (UNIONQ NIL) (|gcd| (|Zero|))
        (|union| NIL) (NCONC NIL) (|and| |true|) (|or| |false|) (AND 'T)
        (OR NIL)))
 
(define-function '|append| #'APPEND)
 
;;(defun |delete| (item list)    ; renaming from DELETE is done in DEF
;;   (cond ((atom list) list)
;;         ((equalp item (qcar list)) (|delete| item (qcdr list)))
;;         ('t (cons (qcar list) (|delete| item (qcdr list))))))
 
(defun |delete| (item sequence)
   (cond ((symbolp item) (remove item sequence :test #'eq))
         ((and (atom item) (not (arrayp item))) (remove item sequence))
         (T (remove item sequence :test #'equalp))))
 
(MAPC #'(lambda (j) (setf (get (first j) 'unmacro) (second j)))
      '( (AND AND2) (OR OR2)))
 
(defun and2 (x y) (and x y))
 
(defun or2 (x y) (or x y))
 
(setf (get 'cons 'right-associative) t)
 
(defun REDUCE-1 (OP AXIS BOD)
  (let (u op1 tran iden)
    (SEQ (SETQ OP1 (cond ((EQ OP '\,) 'CONS)
                         ((EQCAR OP 'QUOTE) (CADR OP))
                         (OP)))
         (SETQ IDEN (if (SETQ U (GET OP1 'THETA)) (CAR U) 'NO_THETA_PROPERTY))
         (SETQ TRAN (if (EQCAR BOD 'COLLECT)
                        (PROG (L BOD1 ITL)
                              (SETQ L (REVERSE (CDR BOD)))
                              (SETQ BOD1 (CAR L))
                              (SETQ ITL (NREVERSE (CDR L)))
                              (RETURN (-REDUCE OP1 AXIS IDEN BOD1 ITL)) )
                        (progn (SETQ U (-REDUCE-OP OP1 AXIS))
                               (LIST 'REDUCE-N (MKQ (OR (GET U 'UNMACRO) U))
                                     (GET OP1 'RIGHT-ASSOCIATIVE)
                                     BOD IDEN))))
         (if (EQ OP '\,) (LIST 'NREVERSE-N TRAN AXIS) TRAN))))
 
(defun -REDUCE (OP AXIS Y BODY SPL)
  (PROG (X G AUX EXIT VALUE PRESET CONSCODE RESETCODE)
   (SETQ G (GENSYM))
   ; create preset of accumulate
   (SETQ PRESET (COND
      ((EQ Y 'NO_THETA_PROPERTY) (LIST 'SPADLET G (MKQ G)))
      ((LIST 'SPADLET G Y)) ))
   (SETQ EXIT (COND
      ((SETQ X (ASSOC 'EXIT SPL))(SETQ SPL (DELASC 'EXIT SPL)) (COND
         ((MEMBER OP '(AND OR)) (LIST 'AND G (CADR X))) ((CADR X)) ))
      ((EQ Y 'NO_THETA_PROPERTY) (LIST 'THETACHECK G (MKQ G)(MKQ OP)))
      (G) ))
   (COND ((EQ OP 'CONS) (SETQ EXIT (LIST 'NREVERSE0 EXIT))))
   ; CONSCODE= code which conses a member onto the list
   (SETQ VALUE (COND ((EQ Y 'NO_THETA_PROPERTY) (GENSYM))
                     (BODY)))
   (SETQ CONSCODE (CONS (-REDUCE-OP OP AXIS) (COND
      ((FLAGP OP 'RIGHT-ASSOCIATIVE) (LIST VALUE G))
      ((LIST G VALUE) ) ) ) )
   ; next reset code which varies if THETA property is|/is not given
   (SETQ RESETCODE (LIST 'SETQ G (COND
      ((EQ Y 'NO_THETA_PROPERTY)
         (LIST 'COND (LIST (LIST 'EQ G (MKQ G)) VALUE)
                     (LIST ''T CONSCODE)) )
      (CONSCODE) )))
   ; create body
   (SETQ BODY (COND ((EQ VALUE BODY) RESETCODE)
                    ((LIST 'PROGN (LIST 'SPADLET VALUE BODY) RESETCODE)) ))
   (SETQ AUX (CONS (LIST 'EXIT EXIT) (COND
      ((EQ OP 'AND) (LIST (LIST 'UNTIL (LIST 'NULL G))))
      ((EQ OP 'OR) (LIST (LIST 'UNTIL G)))
      (NIL) )))
   (RETURN (COND
      ((AND $NEWSPAD (NULL $BOOT)) (LIST 'PROGN PRESET
         (CONS 'REPEAT (APPEND AUX (APPEND SPL (LIST BODY))) )))
      ((LIST 'PROG
                (COND ((EQ RESETCODE BODY) (LIST G)) ((LIST G VALUE)))
                PRESET (LIST 'RETURN
         (CONS 'REPEAT (APPEND AUX (APPEND SPL (LIST BODY)))))))))))
 
(defun -REDUCE-OP (OP AXIS)
  (COND ((EQL AXIS 0) OP)
        ((EQL AXIS 1)
         (COND ((EQ OP 'CONS) 'CONS-N)
               ((EQ OP 'APPEND) 'APPEND-N)
               ((FAIL))))
        ((FAIL))))
 
(defun NREVERSE-N (X AXIS)
  (COND ((EQL AXIS 0) (NREVERSE X))
        ((MAPCAR #'(LAMBDA (Y) (NREVERSE-N Y (SUB1 AXIS))) X))))
 
(defun CONS-N (X Y)
  (COND ((NULL Y) (CONS-N X (NLIST (LENGTH X) NIL)))
        ((MAPCAR #'CONS X Y))))
 
(defun APPEND-N (X Y)
  (COND ((NULL X) (APPEND-N (NLIST (LENGTH Y) NIL) Y))
        ((MAPCAR #'APPEND X Y))))
 
(defun REDUCE-N (OP RIGHT L ACC)
  (COND (RIGHT (PROG (U L1)
                     (SETQ L1 (NREVERSE L))
                     (SETQ U (REDUCE-N-1 OP 'T L1 ACC))
                     (NREVERSE L1)
                     (RETURN U) ))
        ((REDUCE-N-1 OP NIL L ACC))))
 
(defun REDUCE-N-1 (OP RIGHT L ACC)
  (COND ((EQ ACC 'NO_THETA_PROPERTY)
         (COND ((NULL L) (THETA_ERROR OP))
               ((REDUCE-N-2 OP RIGHT (CDR L) (CAR L))) ))
        ((REDUCE-N-2 OP RIGHT L ACC))))
 
(defun REDUCE-N-2 (OP RIGHT L ACC)
  (COND ((NULL L) ACC)
        (RIGHT (REDUCE-N-2 OP RIGHT (CDR L) (funcall (symbol-function OP) (CAR L) ACC)))
        ((REDUCE-N-2 OP RIGHT (CDR L) (funcall (symbol-function OP) ACC (CAR L))))))
 
(defmacro THETA (&rest LL)
  (let (U (L (copy-list LL)))
    (if (EQ (KAR L) '\,)  `(theta CONS . ,(CDR L))
        (progn
         (if (EQCAR (CAR L) 'QUOTE) (RPLAC (CAR L) (CADAR L)))
         (-REDUCE (CAR L) 0
                  (if (SETQ U (GET (CAR L) 'THETA)) (CAR U)
                      (MOAN "NO THETA PROPERTY"))
                  (CAR (SETQ L (NREVERSE (CDR L))))
                  (NREVERSE (CDR L)))))))
 
(defmacro THETA1 (&rest LL)
  (let (U (L (copy-list LL)))
    (if (EQ (KAR L) '\,)
        (LIST 'NREVERSE-N (CONS 'THETA1 (CONS 'CONS (CDR L))) 1)
        (-REDUCE (CAR L) 1
                 (if (SETQ U (GET (CAR L) 'THETA)) (CAR U)
                     (MOAN "NO THETA PROPERTY"))
                 (CAR (SETQ L (NREVERSE (CDR L))))
                 (NREVERSE (CDR L))))))
 
 
(defun THETACHECK (VAL VAR OP) (if (EQL VAL VAR) (THETA_ERROR OP) val))
 
(defun THETA_ERROR (OP)
  (Boot::|userError|
        (LIST "Sorry, do not know the identity element for " OP)))
 
; 15 LISTS
 
; 15.1 Conses
 
 
(defmacro |SPADfirst| (l)
  (let ((tem (gensym)))
    `(let ((,tem ,l)) (if ,tem (car ,tem) (first-error)))))
 
(defun first-error () (error "Cannot take first of an empty list"))
 
; 15.2 Lists
 
 
(defmacro ELEM (val &rest indices)
   (if (null indices) val `(ELEM (nth (1- ,(car indices)) ,val) ,@(cdr indices))))
 
(defun ELEMN (X N DEFAULT)
  (COND ((NULL X) DEFAULT)
        ((EQL N 1) (CAR X))
        ((ELEMN (CDR X) (SUB1 N) DEFAULT))))
 
(defmacro TAIL (&rest L)
  (let ((x (car L)) (n (if (cdr L) (cadr L) 1)))
    (COND ((EQL N 0) X)
          ((EQL N 1) (LIST 'CDR X))
          ((GT N 1) (APPLYR (PARTCODET N) X))
          ((LIST 'TAILFN X N)))))
 
(defun PARTCODET (N)
  (COND ((OR (NULL (INTEGERP N)) (LT N 1)) (ERROR 'PARTCODET))
        ((EQL N 1) '(CDR))
        ((EQL N 2) '(CDDR))
        ((EQL N 3) '(CDDDR))
        ((EQL N 4) '(CDDDDR))
        ((APPEND (PARTCODET (+ N -4)) '(CDDDDR)))))
 
(defmacro TL (&rest L) `(tail . ,L))
 
(defun TAILFN (X N) (if (LT N 1) X (TAILFN (CDR X) (SUB1 N))))
 
(defmacro SPADCONST (&rest L) (cons 'qrefelt L))
 
(defmacro SPADCALL (&rest L)
   (let ((args (butlast l)) (fn (car (last l))) (gi (gensym)))
     ;; (values t) indicates a single return value
     `(let ((,gi ,fn)) (the (values t) (funcall (car ,gi) ,@args (cdr ,gi))))
     ))
 
(DEFUN LASTELEM (X) (car (last X)))
 
(defun LISTOFATOMS (X)
  (COND ((NULL X) NIL)
        ((ATOM X) (LIST X))
        ((NCONC (LISTOFATOMS (CAR X)) (LISTOFATOMS (CDR X))))))
 
(DEFUN LASTATOM (L) (if (ATOM L) L (LASTATOM (CDR L))))
 
(define-function 'LASTTAIL #'last)
 
(define-function 'LISPELT #'ELT)
 
(DEFUN TAKE (N X &aux m)
  "Returns a list of the first N elements of list X."
  (COND ((EQL N 0) NIL)
        ((> N 0) (CONS (CAR X) (TAKE (1- N) (CDR X))))
        ((>= (setq m (+ (length x) N)) 0) (drop m x))
        ((CROAK (list "Bad args to DROP" N X)))))
 
(DEFUN NUMOFNODES (X) (if (ATOM X) 0 (+ 1 (NUMOFNODES (CAR X)) (NUMOFNODES (CDR X)))))
 
(DEFUN TRUNCLIST (L TL) "Truncate list L at the point marked by TL."
  (let ((U L)) (TRUNCLIST-1 L TL) U))
 
(DEFUN TRUNCLIST-1 (L TL)
  (COND ((ATOM L) L)
        ((EQL (CDR L) TL) (RPLACD L NIL))
        ((TRUNCLIST-1 (CDR L) TL))))
 
; 15.3 Alteration of List Structure
 
(defun RPLACW (x w) (let (y z) (dsetq (Y . Z) w) (RPLACA X Y) (RPLACD X Z)  X))
 
; 15.4 Substitution of Expressions
 
(DEFUN SUBSTEQ (NEW OLD FORM)
  "Version of SUBST that uses EQ rather than EQUAL on the world."
  (PROG (NFORM HNFORM ITEM)
        (SETQ HNFORM (SETQ NFORM (CONS () ())))
     LP    (RPLACD NFORM
                   (COND ((EQ FORM OLD) (SETQ FORM ()) NEW )
                         ((NOT (CONSP FORM)) FORM )
                         ((EQ (SETQ ITEM (CAR FORM)) OLD) (CONS NEW ()) )
                         ((CONSP ITEM) (CONS (SUBSTEQ NEW OLD ITEM) ()) )
                         ((CONS ITEM ()))))
        (if (NOT (CONSP FORM)) (RETURN (CDR HNFORM)))
        (SETQ NFORM (CDR NFORM))
        (SETQ FORM (CDR FORM))
        (GO LP)))
 
(DEFUN SUBLISNQ (KEY E) (declare (special KEY)) (if (NULL KEY) E (SUBANQ E)))
 
(DEFUN SUBANQ (E)
  (declare (special key))
  (COND ((ATOM E) (SUBB KEY E))
        ((EQCAR E (QUOTE QUOTE)) E)
        ((MAPCAR #'(LAMBDA (J) (SUBANQ J)) E))))
 
(DEFUN SUBB (X E)
  (COND ((ATOM X) E)
        ((EQ (CAAR X) E) (CDAR X))
        ((SUBB (CDR X) E))))
 
(defun SUBLISLIS (newl oldl form)
   (sublis (mapcar #'cons oldl newl) form))

; 15.5 Using Lists as Sets

\end{chunk}
\section{DEFUN CONTAINED}
The CONTAINED predicate is used to walk internal structures
such as modemaps to see if the $X$ object occurs within $Y$. One
particular use is in a function called isPartialMode (see
i-funsel.boot) to decide
if a modemap is only partially complete. If this is true then the 
modemap will contain the constant \verb|$EmptyMode|. So the call 
ends up being CONTAINED \verb|$EmptyMode| Y. 
\begin{chunk}{*}
(DEFUN CONTAINED (X Y)
  (if (symbolp x)
      (contained\,eq X Y)
      (contained\,equal X Y)))
 
(defun contained\,eq (x y)
       (if (atom y) (eq x y)
           (or (contained\,eq x (car y)) (contained\,eq x (cdr y)))))
 
(defun contained\,equal (x y)
   (cond ((atom y) (equal x y))
         ((equal x y) 't)
         ('t (or (contained\,equal x (car y)) (contained\,equal x (cdr y))))))
 
(DEFUN S+ (X Y)
  (COND ((ATOM Y) X)
        ((ATOM X) Y)
        ((MEMBER (CAR X) Y :test #'equal) (S+ (CDR X) Y))
        ((S+ (CDR X) (CONS (CAR X) Y)))))
 
(defun S* (l1 l2) (INTERSECTION l1 l2 :test #'equal))
(defun S- (l1 l2) (set-difference l1 l2 :test #'equal))
 
(DEFUN PREDECESSOR (TL L)
  "Returns the sublist of L whose CDR is EQ to TL."
  (COND ((ATOM L) NIL)
        ((EQ TL (CDR L)) L)
        ((PREDECESSOR TL (CDR L)))))
 
(defun remdup (l) (remove-duplicates l :test #'equalp))
 
(DEFUN GETTAIL (X L) (member X L :test #'equal))
 
; 15.6 Association Lists
 
(defun DelAsc (u v) "Returns a copy of a-list V in which any pair with key U is deleted."
   (cond ((atom v) nil)
         ((or (atom (car v))(not (equal u (caar v))))
          (cons (car v) (DelAsc u (cdr v))))
         ((cdr v))))
 
(DEFUN ADDASSOC (X Y L)
  "Put the association list pair (X . Y) into L, erasing any previous association for X"
  (COND ((ATOM L) (CONS (CONS X Y) L))
        ((EQUAL X (CAAR L)) (CONS (CONS X Y) (CDR L)))
        ((CONS (CAR L) (ADDASSOC X Y (CDR L))))))
 
(DEFUN DELLASOS (U V)
  "Remove any assocation pair (U . X) from list V."
  (COND ((ATOM V) NIL)
        ((EQUAL U (CAAR V)) (CDR V))
        ((CONS (CAR V) (DELLASOS U (CDR V))))))
 
(DEFUN ASSOCLEFT (X)
  "Returns all the keys of association list X."
  (if (ATOM X) X (mapcar #'car x)))
 
(DEFUN ASSOCRIGHT (X)
  "Returns all the datums of association list X."
  (if (ATOM X) X (mapcar #'cdr x)))
 
(DEFUN LASSOC (X Y)
  "Return the datum associated with key X in association list Y."
  (PROG NIL
     A  (COND ((ATOM Y) (RETURN NIL))
              ((EQUAL (CAAR Y) X) (RETURN (CDAR Y))) )
        (SETQ Y (CDR Y))
        (GO A)))
 
(DEFUN |rassoc| (X Y)
  "Return the datum associated with key X in association list Y."
  (PROG NIL
     A  (COND ((ATOM Y) (RETURN NIL))
              ((EQUAL (CDAR Y) X) (RETURN (CAAR Y))) )
        (SETQ Y (CDR Y))
        (GO A)))
 
; (defun QLASSQ (p a-list) (let ((y (assoc p a-list :test #'eq))) (if y (cdr y))))
(defun QLASSQ (p a-list) (cdr (assq p a-list)))

(define-function 'LASSQ #'QLASSQ)
 
(defun pair (x y) (mapcar #'cons x y))
 
;;; Operations on Association Sets (AS)
 
(defun AS-INSERT (A B L)
   ;; PF(item) x PF(item) x LIST(of pairs) -> LIST(of pairs with (A . B) added)
   ;; destructive on L; if (A . C) appears already, C is replaced by B
   (cond ((null l) (list (cons a b)))
         ((equal a (caar l)) (rplac (cdar l) b) l)
         ((?order a (caar l)) (cons (cons a b) l))
         (t (as-insert1 a b l) l)))
 
(defun as-insert1 (a b l)
   (cond ((null (cdr l)) (rplac (cdr l) (list (cons a b))))
         ((equal a (caadr l)) (rplac (cdadr l) b))
         ((?order a (caadr l)) (rplac (cdr l) (cons (cons a b) (cdr l))))
         (t (as-insert1 a b (cdr l)))))
 
 
; 17 ARRAYS
 
; 17.6 Changing the Dimensions of an Array
 
\end{chunk}
\section{Performance change}
Camm has identified a performace problem during compiles. There is
a loop that continually adds one element to a vector. This causes
the vector to get extended by 1 and copied. These patches fix the 
problem since vectors with fill pointers don't need to be copied.

These cut out the lion's share of the gc problem
on this compile.  30min {\tt ->} 7 min on my box.  There is still some gc
churning in cons pages due to many calls to 'list' with small n.  One
can likely improve things further with an appropriate (declare
(:dynamic-extent ...)) in the right place -- gcl will allocate such
lists on the C stack (very fast).

\subsection{lengthenvec}
The original code was:
\begin{verbatim}
(defun lengthenvec (v n)
  (if (adjustable-array-p v) (adjust-array v n)
    (replace (make-array n) v)))
\end{verbatim}

\end{chunk}
\begin{chunk}{*}
(defun lengthenvec (v n)
  (if 
    (and (array-has-fill-pointer-p v) (adjustable-array-p v))
    (if 
      (>= n (array-total-size v)) 
        (adjust-array v (* n 2) :fill-pointer n) 
        (progn 
          (setf (fill-pointer v) n) 
          v))
    (replace (make-array n :fill-pointer t) v)))

(defun make-init-vector (n val) 
  (make-array n :initial-element val :fill-pointer t))

; 22 INPUT/OUTPUT
 
; 22.2 Input Functions
 
; 22.2.1 Input from Character Streams
 
(DEFUN STREAM-EOF (&optional (STRM *terminal-io*))
  "T if input stream STRM is at the end or saw a ~."
  (not (peek-char nil STRM nil nil nil))     )
 
(DEFUN CONSOLEINPUTP (STRM) (IS-CONSOLE STRM))
 
(defvar $filelinenumber 0)
(defvar $prompt "--->")
(defvar stream-buffer nil)
 
(DEFUN NEXTSTRMLINE (STRM) "Returns the next input line from stream STRM."
  (let ((v (read-line strm nil -1 nil)))
    (if (equal v -1) (throw 'spad_reader nil)
        (progn (setq stream-buffer v) v))))
 
(DEFUN CURSTRMLINE (STRM)
  "Returns the current input line from the stream buffer of STRM (VM-specific!)."
  (cond (stream-buffer)
        ((stream-eof strm) (fail))
        ((nextstrmline strm))))
 
(defvar *EOF* NIL)
 
(DEFUN CURMAXINDEX (STRM)
"Something bizarre and VM-specific with respect to streams."
  (if *EOF* (FAIL) (ELT (ELT (LASTATOM STRM) 1) 3)))
 
(DEFUN ADJCURMAXINDEX (STRM)
"Something unearthly and VM-specific with respect to streams."
  (let (v) (if *eof* (fail)
               (progn (SETQ V (ELT (LASTATOM STRM) 1))
                      (SETELT V 3 (SIZE (ELT V 0)))))))
 
(DEFUN STRMBLANKLINE (STRM)
"Something diabolical and VM-specific with respect to streams."
  (if *EOF* (FAIL) (AND (EQ '\  (CAR STRM)) (EQL 1 (CURMAXINDEX STRM)))))
 
(DEFUN STRMSKIPTOBLANK (STRM)
"Munch away on the stream until you get to a blank line."
  (COND (*EOF* (FAIL))
        ((PROGN (NEXTSTRMLINE STRM) (STRMBLANKLINE STRM)) STRM)
        ((STRMSKIPTOBLANK STRM))))
 
(DEFUN CURINPUTLINE () (CURSTRMLINE *standard-input*))
 
(DEFUN NEXTINPUTLINE () (NEXTSTRMLINE *standard-input*))
 
; 22.3 Output Functions
 
; 22.3.1 Output to Character Streams
 
(DEFUN ATOM2STRING (X)
  "Give me the string which would be printed out to denote an atom."
  (cond ((atom x) (symbol-name x))
        ((stringp x) x)
        ((write-to-string x))))
 
(defvar |conOutStream| *terminal-io* "console output stream")
 
(defun |sayTeX| (x) (if (null x) nil (sayBrightly1 x |$texOutputStream|)))
 
(defvar |$sayBrightlyStream| nil "if not nil, gives stream for sayBrightly output")
 
(defun |sayBrightly| (x &optional (out-stream *standard-output*))
  (COND ((NULL X) NIL)
        (|$sayBrightlyStream| (sayBrightly1 X |$sayBrightlyStream|))
        ((IS-CONSOLE out-stream) (sayBrightly1 X out-stream))
        ((sayBrightly1 X out-stream) (sayBrightly1 X *terminal-io*))))
 
(defun |sayBrightlyI| (x &optional (s *terminal-io*))
    "Prints at console or output stream."
  (if (NULL X) NIL (sayBrightly1 X S)))
 
(defun |sayBrightlyNT| (x &optional (S *standard-output*))
  (COND ((NULL X) NIL)
        (|$sayBrightlyStream| (sayBrightlyNT1 X |$sayBrightlyStream|))
        ((IS-CONSOLE S) (sayBrightlyNT1 X S))
        ((sayBrightly1 X S) (sayBrightlyNT1 X *terminal-io*))))
 
(defun sayBrightlyNT1 (X *standard-output*)
  (if (ATOM X) (BRIGHTPRINT-0 X) (BRIGHTPRINT X)))
 
(defvar |$formulaOutputStream|)
 
(defun |sayFORMULA| (X) "Prints on formula output stream."
  (if (NULL X) NIL (sayBrightly1 X |$formulaOutputStream|)))
 
(defvar |$highlightAllowed| nil "Used in BRIGHTPRINT and is a )set variable.")
 
(defvar |$highlightFontOn| $boldstring "switch to highlight font")
(defvar |$highlightFontOff| $normalstring "return to normal font")
 
;; the following are redefined in MSGDB BOOT
 
(defun SAY (&rest x) (progn (MESSAGEPRINT X) (TERPRI)))
 
(DEFUN BLANKS (N &optional (stream *standard-output*)) "Print N blanks."
    (do ((i 1 (the fixnum(1+ i))))
        ((> i N))(declare (fixnum i n)) (princ " " stream)))
 
; 23 FILE SYSTEM INTERFACE
 
; 23.2 Opening and Closing Files
 
(DEFUN DEFSTREAM (file MODE)
       (if (member mode '(i input))
           (MAKE-INSTREAM file)
         (MAKE-OUTSTREAM file)))
 
; 23.3 Renaming, Deleting and Other File Operations
 
(DEFUN NOTE (STRM)
"Attempts to return the current record number of a file stream.  This is 0 for
terminals and empty or at-end files.  In Common Lisp, we must assume record sizes of 1!"
   (COND ((STREAM-EOF STRM) 0)
         ((IS-CONSOLE STRM) 0)
         ((file-position STRM))))
 
(DEFUN POINTW (RECNO STRM)
"Does something obscure and VM-specific with respect to streams."
  (let (V)
    (if (STREAM-EOF STRM) (FAIL))
    (SETQ V (LASTATOM STRM))
    (SETELT V 4 RECNO)
    (SETQ *EOF* (STREAM-EOF STRM))
    strm))
 
(DEFUN POINT (RECNO STRM) (file-position strm recno))
 
(DEFUN STRM (RECNO STRM)
"Does something obscure and VM-specific with respect to streams."
  (let (V)
    (if (STREAM-EOF STRM) (FAIL))
    (SETQ V (LASTATOM STRM))
    (SETELT V 4 RECNO)
    (read-char STRM)
    (SETQ *EOF* (STREAM-EOF STRM))
    strm))
 
; 24 ERRORS
 
; 24.2 Specialized Error-Signalling Forms and Macros
 
(defun MOAN (&rest x) (|sayBrightly| `(|%l| "===> " ,@X |%l|)))
 
(DEFUN FAIL () (|systemError| '"Antique error (FAIL ENTERED)"))
 
(defun CROAK (&rest x) (|systemError| x))
 
; 25 MISCELLANEOUS FEATURES
 
;; range tests and assertions
 
(defmacro |assert| (x y) `(IF (NULL ,x) (|error| ,y)))
 
(defun coerce-failure-msg (val mode)
   (STRCONC (MAKE-REASONABLE (STRINGIMAGE val))
            " cannot be coerced to mode "
            (STRINGIMAGE (|devaluate| mode))))
 
(defmacro |check-subtype| (pred submode val)
   `(|assert| ,pred (coerce-failure-msg ,val ,submode)))
 
(defmacro |check-union| (pred branch val)
   `(|assert| ,pred (coerce-failure-msg ,val ,branch )))
 
(defun MAKE-REASONABLE (Z)
   (if (> (length Z) 30) (CONCAT "expression beginning " (subseq Z 0 20)) Z))
 
 
(defmacro |elapsedUserTime| () '(get-internal-run-time))
 
(defmacro |elapsedGcTime| () '(system:gbc-time))
 
(defmacro |do| (&rest args) (CONS 'PROGN args))

(defmacro |char| (arg)
  (cond ((stringp arg) (character arg))
        ((integerp arg) (code-char arg))
        ((and (consp arg) (eq (car arg) 'quote)) (character (cadr arg)))
        (t `(character ,arg))))

; # Gives the number of elements of a list, 0 for atoms.
; If we quote it, then an interpreter trip is necessary every time
; we call #, and this costs us - 4% in the RATINT DEMO."

(define-function '\# #'SIZE)

(defun print-and-eval-defun (name body)
   (eval body)
   (print-defun name body)
  ;; (set name (symbol-function name)) ;; this should go away
   )

(defun eval-defun (name body) (eval (macroexpandall body)))

; This function was modified by Greg Vanuxem on March 31, 2005
; to handle the special case of #'(lambda ..... which expands
; into (function (lambda .....
; 
; The extra if clause fixes bugs #196 and #114
;
; an example that used to cause the failure was:
; )set func comp off
; f(xl:LIST FRAC INT): LIST FRAC INT == map(x +-> x, xl)
; f [1,2,3]
;
; which expanded into
;
; (defun |xl;f;1;initial| (|#1| |envArg|)
;  (prog (#:G1420)
;   (return 
;    (progn
;     (lett #:G1420 'uninitialized_variable |f| |#1;f;1:initial|)
;      (spadcall 
;       (cons (|function| (lambda (#:G1420 |envArg|) #:G1420)) (vector))
;       |#1|
;       (qrefelt |*1;f;1;initial;MV| 0))))))
;
; the (|function| (lambda form used to cause an infinite expansion loop
;      
(defun macroexpandall (sexpr)
 (cond
  ((atom sexpr) sexpr)
  ((eq (car sexpr) 'quote) sexpr)
  ((eq (car sexpr) 'defun)
   (cons (car sexpr) (cons (cadr sexpr)
       (mapcar #'macroexpandall (cddr sexpr)))))
  ((and (symbolp (car sexpr)) (macro-function (car sexpr)))
   (do ()
       ((not (and (consp sexpr) (symbolp (car sexpr))
                  (macro-function (car sexpr)))))
     (setq sexpr (macroexpand sexpr)))
   (if (consp sexpr) 
     (let ((a (car sexpr)) (b (caadr sexpr)))
       (if (and (eq a 'function) (eq b 'lambda))
         (cons a (list (cons b (mapcar #'macroexpandall (cdadr sexpr)))))
         (mapcar #'macroexpandall sexpr)))
       sexpr))
  ('else        
    (mapcar #'macroexpandall sexpr))))


(defun compile-defun (name body) (eval body) (compile name))

(defmacro |Record| (&rest x)
  `(|Record0| (LIST ,@(COLLECT (IN Y X)
                         (list 'CONS (MKQ (CADR Y)) (CADDR Y))))))

(defmacro |:| (tag expr) `(LIST '|:| ,(MKQ tag) ,expr))

(defun |deleteWOC| (item list) (lisp::delete item list :test #'equal))

(DEFUN |leftBindingPowerOf| (X IND &AUX (Y (GETL X IND)))
   (IF Y (ELEMN Y 3 0) 0))

(DEFUN |rightBindingPowerOf| (X IND &AUX (Y (GETL X IND)))
   (IF Y (ELEMN Y 4 105) 105))

(defmacro make-bf (MT EP) `(CONS |$BFtag| (CONS ,MT ,EP)))

(defun MAKE-FLOAT (int frac fraclen exp)
    (if (AND $SPAD |$useBFasDefault|)
        (if (= frac 0)
          (MAKE-BF int exp)
          (MAKE-BF (+ (* int (expt 10 fraclen)) frac) (- exp fraclen)) )
        (read-from-string
          (format nil "~D.~v,'0De~D" int fraclen frac exp))) )

;;---- Added by WFS.
 
(proclaim '(ftype (function (t t) t) |subWord|)) ;hack for bug in akcl-478
 
(DEFUN |subWord| (|str| N )
  (declare (fixnum n ) (string |str|))
  (PROG (|word| (|n| 0) |inWord|(|l| 0) )
     (declare (fixnum |n| |l|))
    (RETURN
      (SEQ (COND
             ((> 1 N) NIL)
             ('T (SPADLET |l| (SPADDIFFERENCE (|#| |str|) 1))
              (COND
                ((EQL |l| 0) NIL)
                ('T (SPADLET |n| 0) (SPADLET |word| '||)
                 (SPADLET |inWord| NIL)
                 (DO ((|i| 0 (QSADD1 |i|))) ((QSGREATERP |i| |l|) NIL)
               (declare (fixnum |i|))
                   (SEQ (EXIT (COND
                                ((eql (aref |str| |i|) #\space)
                                 (COND
                                   ((NULL |inWord|) NIL)
                                   ((eql |n| N) (RETURN |word|))
                                   ('T (SPADLET |inWord| NIL))))
                                ('T
                                 (COND
                                   ((NULL |inWord|)
                                    (SPADLET |inWord| 'T)
                                    (SPADLET |n| (+ |n| 1))))
                                 (COND
                                   ((eql |n| N)
                       (cond ((eq |word| '||)
                           (setq |word|
                           (make-array 10 :adjustable t
                                    :element-type 'standard-char
                                  :fill-pointer 0))))
                       (or |word| (error "bad"))
                       (vector-push-extend (aref |str| |i|)
                                  (the string |word|)
                                  )
                       )
                                   ('T NIL)))))))
                 (COND ((> N |n|) NIL) ('T |word|))))))))))

(defun print-full (expr &optional (stream *standard-output*))
   (let ((*print-circle* t) (*print-array* t) *print-level* *print-length*)
     (print expr stream)
     (terpri stream)
     (finish-output stream)))
 
;; stream handling for paste-in generation

(defun |applyWithOutputToString| (func args)
  ;; returns the cons of applying func to args and a string produced
  ;; from standard-output while executing.
  (let* ((*standard-output* (make-string-output-stream))
         (curoutstream *standard-output*)
         (*terminal-io* *standard-output*)
         (|$algebraOutputStream| *standard-output*)
         (erroroutstream *standard-output*)
        val)
    (declare (special *standard-output* curoutstream
                      *terminal-io* |$algebraOutputStream|))
    (setq val (catch 'spad_reader
                (catch 'TOP_LEVEL
                  (apply (symbol-function func) args))))
    (cons val (get-output-stream-string *standard-output*))))

(defun |breakIntoLines| (str)
  (let ((bol 0) (eol) (line-list nil))
    (loop
     (setq eol (position #\Newline str :start bol))
     (if (null eol) (return))
     (if (> eol bol) 
         (setq line-list (cons (subseq str bol eol) line-list)))
     (setq bol (+ eol 1)))
    (nreverse line-list)))

; part of the old spad to new spad translator
; these are here because they need to be in depsys
; they were in nspadaux.lisp

(defmacro wi (a b) b)

(defmacro |try| (X)
  `(LET ((|$autoLine|))
        (declare (special |$autoLine|))
        (|tryToFit| (|saveState|) ,X)))

(defmacro |embrace| (X) `(|wrapBraces| (|saveC|) ,X (|restoreC|)))
(defmacro |indentNB| (X) `(|wrapBraces| (|saveD|) ,X (|restoreD|)))

(defmacro |tryBreak| (a b c d) 
; Try to format <a b> by:
; (1) with no line breaking ($autoLine = nil)
; (2) with possible line breaks within a;
; (3) otherwise use a brace
  `(LET
    ((state))
    (setq state (|saveState| 't))
    (or
      (LET ((|$autoLine|))
         (declare (special |$autoLine|))
         (and ,a (|formatRight| '|formatPreferPile| ,b ,c ,d)))
      (|restoreState| state)
      (and (eqcar ,b (quote seq))
               (|embrace| (and 
                  ,a
                  (|formatLB|)
                  (|formatRight| '|formatPreferPile| ,b ,c ,d))))
      (|restoreState| state)
      (|embrace| (and ,a 
                  (|formatLB|)
                  (|formatRight| '|formatPreferPile| ,b ,c ,d))))))

(defmacro |tryBreakNB| (a b c d) 
; Try to format <a b> by:
; (1) with no line breaking ($autoLine = nil)
; (2) with possible line breaks within a;
; (3) otherwise display without a brace
  `(LET
    ((state))
    (setq state (|saveState| 't))
    (or
      (markhash ,b 0)
      (LET ((|$autoLine|))
         (declare (special |$autoLine|))
         (and ,a (|formatRight| '|formatPreferPile| ,b ,c ,d)))
      (|restoreState| state)
      (markhash ,b 1)
      (and (eqcar ,b (quote seq))
               (|embrace| (and 
                  ,a
                  (|formatLB|)
                  (|formatRight| '|formatPreferPile| ,b ,c ,d))))
      (markhash ,b 2)
      (|restoreState| state)
      (|indentNB| (and ,a 
                  (|formatRight| '|formatPreferPile| ,b ,c ,d)))
      (markhash ,b 3)

)))   

(defun markhash (key n) (progn (cond
  ((equal n 3) (remhash key ht))
  ('t (hput ht key n)) ) nil))


; NAME:    Compiler Utilities Package

; PURPOSE: Comp is a modified version of Compile which is a preprocessor for
;          calls to Lisp Compile.  It searches for variable assignments that use
;          (SPADLET a b). It allows you to create local variables without
;          declaring them local by moving them into a PROG variable list.
;          This is not an ordinary SPADLET.  It looks and is used like a SETQ.
;          This preprocessor then collects the uses and creates the PROG.
;
;          SPADLET is defined in Macro.Lisp.
;
;          Comp recognizes as new lambda types the forms ILAM, SPADSLAM, SLAM,
;          and entries on $clamList.  These cache results.  ("Saving LAMbda".)
;          If the function is called with EQUAL arguments, returns the previous
;          result computed.
;
;          The package also causes traced things which are recompiled to
;          become untraced.

(export '(Comp FluidVars LocVars OptionList SLAM SPADSLAM ILAM FLUID))

;;; Common Block section

(defparameter FluidVars nil)
(defparameter LocVars nil)
(defparameter SpecialVars nil)

(defun |compAndDefine| (L)
  (let ((*comp370-apply* (function print-and-eval-defun)))
    (declare (special *comp370-apply*))
    (COMP L)))

(defun COMP (L) (MAPCAR #'COMP-2 (MAPCAN #'COMP-1 L)))

(defun |compQuietly| (fn)
  (let ((*comp370-apply*
         (if |$InteractiveMode|
             (if |$compileDontDefineFunctions| #'compile-defun #'eval-defun)
           #'print-defun))
     ;; following creates a null outputstream if $InteractiveMode
        (*standard-output*
         (if |$InteractiveMode| (make-broadcast-stream)
           *standard-output*)))
    (COMP fn)))

;; The following are used mainly in setvars.boot
(defun notEqualLibs (u v)
  (if (string= u (library-name v)) (seq (close-library v) t) nil))

(defun |dropInputLibrary| (lib) 
  ;; Close any existing copies of this library on the input path
 (setq input-libraries
  (delete lib input-libraries :test #'notEqualLibs )))

(defun |openOutputLibrary| (lib)
  (|dropInputLibrary| lib)
  (setq output-library (open-library lib 't))
  (setq input-libraries (cons output-library input-libraries)) )

(defun |addInputLibrary| (lib)
  (|dropInputLibrary| lib)
   (setq input-libraries (cons (open-library lib) input-libraries)) )

(defun |compileQuietly| (fn)
  (let ((*comp370-apply*
         (if |$InteractiveMode|
             (if |$compileDontDefineFunctions| #'compile-defun #'eval-defun)
           #'print-defun))
     ;; following creates a null outputstream if $InteractiveMode
        (*standard-output*
         (if |$InteractiveMode| (make-broadcast-stream)
           *standard-output*)))
    (COMP370 fn)))

(defun COMP-1 (X)
  (let* ((FNAME (car X))
         ($FUNNAME FNAME)
         ($FUNNAMETAIL (LIST FNAME))
         (LAMEX (second X))
         ($closedfns nil))
    (declare (special $FUNNAME $FUNNAMETAIL $CLOSEDFNS))
    (setq LAMEX (COMP-TRAN LAMEX))
    (COMP-NEWNAM LAMEX)
    (if (fboundp FNAME)
        (format t "~&~%;;;     ***       ~S REDEFINED~%" FNAME))
    (CONS (LIST FNAME LAMEX) $CLOSEDFNS)))

(defun Comp-2 (args &aux name type argl bodyl junk)
    (dsetq (NAME (TYPE ARGL . BODYL) . JUNK) args)
    (cond (JUNK (MOAN (format nil "******pren error in (~S (~S ...) ...)" NAME TYPE)))
          ((eq TYPE 'SLAM) (COMP-SLAM NAME ARGL BODYL))
          ((LASSQ NAME |$clamList|) (|compClam| NAME ARGL BODYL |$clamList|))
          ((eq TYPE 'SPADSLAM) (COMP-SPADSLAM NAME ARGL BODYL))
          ((eq TYPE 'ILAM) (COMP-ILAM NAME ARGL BODYL))
          ((setq BODYL (LIST NAME (CONS TYPE (CONS ARGL BODYL))))
           (if |$PrettyPrint| (pprint bodyl))
           (if (null $COMPILE) (SAY "No Compilation")
               (COMP370 (LIST BODYL)))
           NAME)))

;; used to be called POSN - but that interfered with a CCL function
(DEFUN POSN1 (X L) (position x l :test #'equal))

(DEFUN COMP-ILAM (NAME ARGL BODYL)
  (let* ((FARGL (NLIST (LENGTH ARGL) '(GENSYM)))
         (BODYLP (SUBLISLIS FARGL ARGL BODYL)))
        (setf (get name 'ilam) t)
        (SET NAME (CONS 'LAMBDA (CONS FARGL BODYLP)))
        NAME))

(DEFUN COMP-SPADSLAM (NAME ARGL BODYL)
  (let* ((AL (INTERNL NAME ";AL"))
         (AUXFN (INTERNL NAME ";"))
         (G1 (GENSYM))
         (G2 (GENSYM))
         (U (COND ((NOT ARGL) (LIST NIL NIL (LIST AUXFN)))
                  ((NOT (CDR ARGL))
                   (LIST (LIST G1) (LIST '|devaluate| G1) (LIST AUXFN G1)))
                  ((LIST G1
                         (LIST '|devaluateList| G1)
                         (LIST 'APPLY (LIST 'FUNCTION AUXFN) G1)))))
         (ARG (first U))
         (ARGTRAN (second U))
         (APP (third U))
         (LAMEX  `(lam ,ARG
                       (let (,g2)
                         (cond ,(COND (ARGL `((setq ,g2 (|assoc| ,argtran ,al))
                                              (cdr ,g2)))
                                      ((LIST AL)))
                               ,(COND (ARGL
                                       `(t(setq ,al(|cons5|(cons ,argtran
                                                                 (setq ,g2 ,app))
                                                           ,al))
                                          ,g2))
                                      (`(t (setq ,al ,app)))))))))
    (setandfile AL NIL)
    (setq U (LIST NAME LAMEX))
    (if |$PrettyPrint| (PRETTYPRINT U))
    (COMP370 (LIST U))
    (setq U (LIST AUXFN (CONS 'LAMBDA (CONS ARGL BODYL))))
    (COND (|$PrettyPrint| (PRETTYPRINT U)))
    (COMP370 (LIST U))
    NAME))

(DEFUN COMP-SLAM (NAME ARGL BODYL)
  (let* ((AL (INTERNL NAME ";AL"))
         (AUXFN (INTERNL NAME ";"))
         (G1 (GENSYM))
         (G2 (GENSYM))
         (U (COND ((NOT ARGL) `(nil (,auxfn)))
                  ((NOT (CDR ARGL)) `((,g1)(,auxfn ,g1)))
                  (`(,g1 (apply (function ,auxfn) ,g1)))))
         (ARG (CAR U))
         (APP (CADR U))
         (LAMEX
           (LIST 'LAM ARG
                 (LIST 'PROG (LIST G2)
                       (LIST 'RETURN
                             (LIST 'COND
                                   (COND (ARGL
                                          `((setq ,G2 (|assoc| ,G1 ,AL))
                                            (CDR ,G2)))
                                         ((LIST AL)))
                                   (COND (ARGL (LIST ''T `(setq ,G2 ,APP)
                                                     (LIST 'SETQ AL
                                                           `(CONS
                                                              (CONS ,G1 ,G2) ,AL))
                                                     G2))
                                         ((LIST ''T `(setq ,AL ,APP))))))))))
    (set AL NIL)
    (setq U (LIST NAME LAMEX))
    (if |$PrettyPrint| (PRETTYPRINT U))
    (COMP370 (LIST U))
    (setq U (LIST AUXFN (CONS 'LAMBDA (CONS ARGL BODYL))))
    (if |$PrettyPrint| (PRETTYPRINT U))
    (COMP370 (LIST U))
    NAME))

(DEFUN COMP-NEWNAM (X)
  (let (y u)
    (cond ((ATOM X) NIL)
          ((ATOM (setq Y (CAR X)))
          ;; (AND (IDENTP Y) (setq U (GET Y 'NEWNAM)) (RPLACA X U))
           (AND (NOT (eq Y 'QUOTE)) (COMP-NEWNAM (CDR X)))
           (WHEN (and (EQ Y 'CLOSEDFN) (boundp '$closedfns))
                 (SETQ U (MAKE-CLOSEDFN-NAME))
                 (PUSH (list U (CADR X)) $closedfns)
                 (rplaca x 'FUNCTION)
                 (rplaca (cdr x) u)))
          (t (COMP-NEWNAM (CAR X)) (COMP-NEWNAM (CDR X))))))

(defun make-closedfn-name ()
  (internl $FUNNAME "!" (STRINGIMAGE (LENGTH $CLOSEDFNS))))

(DEFUN COMP-TRAN (X)
  "SEXPR<FN. BODY> -> SEXPR"
  (let ((X (COMP-EXPAND X)) FluidVars LocVars SpecialVars)
    (COMP-TRAN-1 (CDDR X))
    (setq X (list (first x) (second x)
                  (if (and (null (cdddr x))
                           (or (atom (third x))
                               (eq (car (third x)) 'SEQ)
                               (not (contained 'EXIT (third x)))))
                      (caddr x)
                      (cons 'SEQ (cddr x))))) ;catch naked EXITs
    (let* ((FluidVars (REMDUP (NREVERSE FLUIDVARS)))
           (LOCVARS (S- (S- (REMDUP (NREVERSE LOCVARS)) FLUIDVARS)
                        (LISTOFATOMS (CADR X))))
           (LVARS (append fluidvars LOCVARS)))
      (let ((fluids (S+ fluidvars SpecialVars)))
        (setq x
              (if fluids
                  `(,(first x) ,(second x)
                    (prog ,lvars (declare (special . ,fluids))
                      (return ,(third x))))
                  (list (first x) (second x)
                     (if (or lvars (contained 'RETURN (third x)))
                         `(prog ,lvars (return ,(third x)))
                         (third x)) )))))
    (let ((fluids (S+ (comp-fluidize (second x)) SpecialVars)))
      (if fluids
          `(,(first x) ,(second x) (declare (special . ,fluids)) . ,(cddr x))
          `(,(first x) ,(second x) . ,(cddr x))))))

; Fluidize: Returns a list of fluid variables in X

(DEFUN COMP-FLUIDIZE (X)
  (COND ((AND (symbolp X)
              (NE X '$)
              (NE X '$$)
              (char= #\$ (ELT (PNAME X) 0))
              (NOT (DIGITP (ELT (PNAME X) 1))))
         x)
        ((atom x) nil)
        ((eq (first X) 'FLUID) (second X))
        ((let ((a (comp-fluidize (first x)))
               (b (comp-fluidize (rest x))))
           (if a (cons a b) b)))))

(DEFUN COMPFLUIDIZE  (X) (COND
  ((AND (IDENTP X)
        (NE X '$)
        (NE X '$$)
        (char= #\$ (ELT (PNAME X) 0)) (NULL (DIGITP (ELT (PNAME X) 1))))
    (LIST 'FLUID X))
  ((ATOM X) X)
  ((EQ (QCAR X) 'FLUID) X)
  ('T (PROG (A B)
      (SETQ A (COMPFLUIDIZE (QCAR X)))
      (SETQ B (COMPFLUIDIZE (QCDR X)))
      (COND ((AND (EQ A (QCAR X)) (EQ B (QCDR X)))
              (RETURN X))
            ('T (RETURN (CONS A B)) )) )    )))

; NOTE: It is potentially dangerous to assume every occurrence of element of
; $COMP-MACROLIST is actually a macro call

(defparameter $COMP-MACROLIST
  '(COLLECT REPEAT SUCHTHATCLAUSE THETA COLLECTV COLLECTVEC
            THETA1 SPADREDUCE SPADDO)
  "???")

(DEFUN COMP-EXPAND (X)
  (COND ((atom x) x)
        ((eq (CAR X) 'QUOTE) X)
        ((member (CAR X) $COMP-MACROLIST)
         (comp-expand (macroexpand-1 x)))
        ((let ((a (comp-expand (car x)))
               (b (comp-expand (cdr x))))
           (if (AND (eq A (CAR X)) (eq B (CDR X)))
               x
               (CONS A B))))))

(DEFUN COMP-TRAN-1 (X)
  (let (u)
    (cond ((ATOM X) NIL)
          ((eq (setq U (CAR X)) 'QUOTE) NIL)
          ((member U '(DCQ RELET PRELET SPADLET SETQ LET) )
           (COND ((NOT (eq U 'DCQ))
                  (COND ((OR (AND (eq $NEWSPAD T) (NOT $BOOT))
                             (member $FUNNAME |$traceletFunctions|))
                         (NCONC X $FUNNAMETAIL)
                         (RPLACA X 'LETT))
                        ; this devious trick (due to RDJ) is needed since the compile
                        ; looks only at global variables in top-level environment;
                        ; thus SPADLET cannot itself test for such flags (7/83).
                        ($TRACELETFLAG (RPLACA X '/TRACE-LET))
                        ((eq U 'LET) (RPLACA X 'SPADLET)))))
           (COMP-TRAN-1 (CDDR X))
           (AND (NOT (member U '(setq RELET)))
                (COND ((IDENTP (CADR X)) (PUSHLOCVAR (CADR X)))
                      ((EQCAR (CADR X) 'FLUID)
                       (PUSH (CADADR X) FLUIDVARS)
                       (RPLAC (CADR X) (CADADR X)))
                      ((mapc #'pushlocvar (listofatoms (cadr x))) nil))))
          ((and (symbolp u) (GET U 'ILAM))
           (RPLACA X (EVAL U)) (COMP-TRAN-1 X))
          ((member U '(PROG LAMBDA))
           (PROG (NEWBINDINGS RES)
                 (setq NEWBINDINGS NIL)
                 (mapcar #'(lambda (Y)
                             (COND ((NOT (member Y LOCVARS))
                                    (setq LOCVARS (CONS Y LOCVARS))
                                    (setq NEWBINDINGS (CONS Y NEWBINDINGS)))))
                         (second x))
                 (setq RES (COMP-TRAN-1 (CDDR X)))
                 (setq locvars (remove-if #'(lambda (y) (member y newbindings))
                                          locvars))
                 (RETURN (CONS U (CONS (CADR X) RES)) )) )
          ((PROGN (COMP-TRAN-1 U) (COMP-TRAN-1 (CDR X)))))))

(DEFUN PUSHLOCVAR (X)
  (let (p)
    (cond ((AND (NE X '$)
                (char= #\$ (ELT (setq P (PNAME X)) 0))
                (NOT (char= #\, (ELT P 1)))
                (NOT (DIGITP (ELT P 1)))) NIL)
          ((PUSH X LOCVARS)))))

(defmacro PRELET (L) `(spadlet . ,L))
(defmacro RELET (L) `(spadlet . ,L))
(defmacro PRESET (L) `(spadlet . ,L))
(defmacro RESET (L) `(spadlet . ,L))

;; this files contains basic routines for error handling
(defun error-format (message args)
  (let ((|$BreakMode| '|break|))
    (declare (special |$BreakMode|))
   (if (stringp message) (apply #'format nil message args) nil)))
 

;; the following form embeds around the akcl error handler
(eval-when
 (load eval)
 (unembed 'system:universal-error-handler)
 (embed 'system:universal-error-handler
            '(lambda (type correctable? op
                           continue-string error-string &rest args)
               (block
                nil
                (setq |$NeedToSignalSessionManager| T)
                (if (boundp '|$BreakMode|)
                    (cond ((eq |$BreakMode| '|validate|)
                           (|systemError| (error-format error-string args)))
                          ((and (eq |$BreakMode| '|trapNumerics|)
                                (eq type :ERROR))
                           (setq |$BreakMode| nil)
                           (throw '|trapNumerics| |$numericFailure|))
                          ((and (eq |$BreakMode| '|trapNumerics|)
                                (boundp '|$oldBreakMode|)
                                (setq |$BreakMode| |$oldBreakMode|)
                                nil)) ;; resets error handler
                          ((member |$BreakMode| '(|nobreak| |query| |resume|))
                            (|systemError| (error-format error-string args)))
                          ((eq |$BreakMode| '|letPrint2|)
                           (setq |$BreakMode| nil)
                           (throw '|letPrint2| nil))))
                (apply system:universal-error-handler type correctable? op
                       continue-string error-string args )))))



;;;  @(#)debug.lisp      2.5      90/02/15  10:27:33
 
; NAME:    Debugging Package
; PURPOSE: Debugging hooks for Boot code
 
 
(DEFPARAMETER /COUNTLIST NIL)
(DEFPARAMETER /TIMERLIST NIL)
(DEFPARAMETER /TRACESIZE NIL "sets limit on size of object to be mathprinted")
(DEFVAR CURSTRM *TERMINAL-IO*)
(DEFVAR /TRACELETNAMES ())
(DEFVAR /PRETTY () "controls pretty printing of trace output")
(SETANDFILEQ /ECHO NIL) ;;"prevents echo of SPAD or BOOT code with /c"
(setf (get 'lisp '/termchr) '(#\  #\())
(setf (get 'lsp '/termchr) '(#\  #\())
(setf (get 'meta '/termchr) '(#\:  #\())
(setf (get 'input '/termchr) '(#\:  #\<  #\  #\())
(setf (get 'spad '/termchr) '(#\:  #\<  #\  #\())
(setf (get 'boot '/termchr) '(#\:  #\<  #\  #\())
(setf (get 'meta '/readfun) 'META\,RULE)
(setf (get 'input '/readfun) '|New,LEXPR,Interactive|)
(setf (get 'boot '/readfun) '|New,LEXPR1|)
(setf (get 'spad '/readfun) '|New,LEXPR|)
 
(defmacro |/C,LIB| (&rest L &aux optionlist /editfile
                          ($prettyprint 't) ($reportCompilation 't))
  (declare (special optionlist /editfile $prettyprint $reportComilation))
  `',(|compileConstructorLib| L (/COMP) NIL NIL))
 
(DEFUN FUNLOC (func &aux file)
  (if (CONSP func) (SETQ func (CAR func)))
  (setq file (ifcar (findtag func)))
  (if file (list (pathname-name file) (pathname-type file) func)
    nil))
 
(DEFUN MATCH-FUNCTION-DEF (fn key keylength line type)
       (if (eq type 'LISP) (match-lisp-tag fn line "(def")
         (let ((n (mismatch key line)))
           (and (= n keylength)
                (or (= n (length line))
                    (member (elt line n)
                            (or (get type '/termchr) '(#\space ))))))))
 
(defun |getDateAndTime| ()
   (MULTIPLE-VALUE-BIND (sec min hour day mon year) (get-decoded-time)
   (CONS (STRCONC (LENGTH2STR mon) "/"
                  (LENGTH2STR day) "/"
                  (LENGTH2STR year) )
         (STRCONC (LENGTH2STR hour) ":"
                  (LENGTH2STR min)))))
 
(DEFUN LENGTH2STR (X &aux XLEN)
       (cond ( (= 1 (SETQ XLEN (LENGTH (SETQ X (STRINGIMAGE X))))) (STRCONC "0" X))
             ( (= 2 XLEN) X)
             ( (subseq x (- XLEN 2)))))
 
(DEFUN OPTIONS2UC (L)
  (COND ((NOT L) NIL)
        ((ATOM (CAR L))
         (|spadThrowBrightly|
           (format nil "~A has wrong format for an option" (car L))))
        ((CONS (CONS (upcase (CAAR L)) (CDAR L)) (OPTIONS2UC (CDR L))))))
 
(DEFUN COND-UCASE (X) (COND ((INTEGERP X) X) ((UPCASE X))))
 
(DEFUN TRACEOPTIONS (X)
  (COND ((NOT X) NIL)
        ((EQ (CAR X) '/) X)
        ((TRACEOPTIONS (CDR X)))))
 
(DEFUN MONITOR-PRINVALUE (VAL NAME)
  (let (u)
    (COND ((setq U (GET NAME '/TRANSFORM))
           (COND
             ((EQCAR U '&)
              (PRINC "//" CURSTRM) (PRIN1 VAL CURSTRM) (TERPRI CURSTRM))
             (T (PRINC "! " CURSTRM)
                (PRIN1 (EVAL (SUBST (MKQ VAL) '* (CAR U))) CURSTRM)
                (TERPRI CURSTRM)) ))
          (T
           (PRINC ": " CURSTRM)
           (COND ((NOT (SMALL-ENOUGH VAL)) (|F,PRINT-ONE| VAL CURSTRM))
                 (/PRETTY (PRETTYPRINT VAL CURSTRM))
                 (T (COND (|$mathTrace| (TERPRI)))
                    (PRINMATHOR0 VAL CURSTRM)))))))
 
(DEFUN MONITOR-BLANKS (N) (PRINC (MAKE-FULL-CVEC N " ") CURSTRM))
 
(DEFUN MONITOR-EVALBEFORE (X) (EVALFUN (MONITOR-EVALTRAN X NIL)) X)
 
(DEFUN MONITOR-EVALAFTER (X) (EVALFUN (MONITOR-EVALTRAN X 'T)))
 
(DEFUN MONITOR-EVALTRAN (X FG)
  (if (HAS_SHARP_VAR X) (MONITOR-EVALTRAN1 X FG) X))
 
(define-function 'MONITOR\,EVALTRAN #'MONITOR-EVALTRAN)
 
(DEFUN MONITOR-EVALTRAN1 (X FG)
  (let (n)
    (COND
      ((SETQ N (|isSharpVarWithNum| X)) (MONITOR-GETVALUE N FG))
      ((ATOM X) X)
      ((CONS (MONITOR-EVALTRAN1 (CAR X) FG)
             (MONITOR-EVALTRAN1 (CDR X) FG))))))
 
(DEFUN HAS_SHARP_VAR (X)
  (COND ((AND (ATOM X) (IS_SHARP_VAR X)) 'T)
        ((ATOM X) NIL)
        ((OR (HAS_SHARP_VAR (CAR X)) (HAS_SHARP_VAR (CDR X))))))
 
(DEFUN IS_SHARP_VAR (X)
  (AND (IDENTP X)
       (EQL (ELT (PNAME X) 0) #\#)
       (INTEGERP (lisp:parse-integer (symbol-name X) :start 1))))
 
(DEFUN MONITOR-GETVALUE (N FG)
  (COND ((= N 0)
         (if FG
             (MKQ /VALUE)
             (|spadThrowBrightly| "cannot ask for value before execution")))
        ((= N 9) (MKQ /CALLER))
        ((<= N (SIZE /ARGS)) (MKQ (ELT /ARGS (1- N))))
        ((|spadThrowBrightly| (LIST 'function '|%b| /NAME '|%d|
                              "does not have" '|%b| N '|%d| "arguments")))))
 
(DEFUN MONITOR-PRINARGS (L CODE /TRANSFORM)
  (let (N)
    (cond
      ((= (digit-char-p (elt CODE 2)) 0) NIL)
      ((= (digit-char-p (elt CODE 2)) 9)
       (cond
         (/TRANSFORM
           (mapcar
             #'(lambda (x y)
                 (COND ((EQ Y '*)
                        (PRINC "\\ " CURSTRM)
                        (MONITOR-PRINT X CURSTRM))
                       ((EQ Y '&)
                        (PRINC "\\\\" CURSTRM)
                        (TERPRI CURSTRM)
                        (PRINT X CURSTRM))
                       ((NOT Y) (PRINC "! " CURSTRM))
                       (T
                        (PRINC "! " CURSTRM)
                        (MONITOR-PRINT
                          (EVAL (SUBST (MKQ X) '* Y)) CURSTRM))))
            L (cdr /transform)))
         (T (PRINC ": " CURSTRM)
            (COND ((NOT (ATOM L))
                   (if |$mathTrace| (TERPRI CURSTRM))
                   (MONITOR-PRINT (CAR L) CURSTRM) (SETQ L (CDR L))))
            (mapcar #'monitor-printrest L))))
      ((do ((istep 2 (+ istep 1))
            (k (maxindex code)))
           ((> istep k) nil)
        (when (not (= 0 (SETQ N (digit-char-p (elt CODE ISTEP)))))
         (PRINC "\\" CURSTRM)
         (PRINMATHOR0 N CURSTRM)
         (PRINC ": " CURSTRM)
         (MONITOR-PRINARGS-1 L N)))))))
 
(DEFUN MONITOR-PRINTREST (X)
  (COND ((NOT (SMALL-ENOUGH X))
         (PROGN (TERPRI)
                (MONITOR-BLANKS (1+ /DEPTH))
                (PRINC "\\" CURSTRM)
                (PRINT X CURSTRM)))
        ((PROGN (if (NOT |$mathTrace|) (PRINC "\\" CURSTRM))
                (COND (/PRETTY (PRETTYPRINT X CURSTRM))
                      ((PRINMATHOR0 X CURSTRM)))))))
 
(DEFUN MONITOR-PRINARGS-1 (L N)
  (COND ((OR (ATOM L) (LESSP N 1)) NIL)
        ((EQ N 1) (MONITOR-PRINT (CAR L) CURSTRM))
        ((MONITOR-PRINARGS-1 (CDR L) (1- N)))))
 
(DEFUN MONITOR-PRINT (X CURSTRM)
  (COND ((NOT (SMALL-ENOUGH X)) (|F,PRINT-ONE| X CURSTRM))
        (/PRETTY (PRETTYPRINT X CURSTRM))
        ((PRINMATHOR0 X CURSTRM))))
 
(DEFUN PRINMATHOR0 (X CURSTRM)
  (if |$mathTrace| (|maprinSpecial| (|outputTran| X) /DEPTH 80)
      (PRIN0 X CURSTRM)))
 
(DEFUN SMALL-ENOUGH (X) (if /TRACESIZE (SMALL-ENOUGH-COUNT X 0 /TRACESIZE) t))
 
(DEFUN SMALL-ENOUGH-COUNT (X N M)
  "Returns number if number of nodes < M otherwise nil."
  (COND ((< M N) NIL)
        ((VECP X)
         (do ((i 0 (1+ i)) (k (maxindex x)))
             ((> i k) n)
           (if (NOT (SETQ N (SMALL-ENOUGH-COUNT (ELT X I) (1+ N) M)))
               (RETURN NIL))))
        ((ATOM X) N)
        ((AND (SETQ N (SMALL-ENOUGH-COUNT (CAR X) (1+ N) M))
              (SMALL-ENOUGH-COUNT (CDR X) N M)))))
 
; Functions to run a timer for tracing
; It avoids timing the tracing function itself by turning the timer
; on and off
 
(defun |startTimer| ()
    (SETQ $delay (+ $delay (- (get-internal-run-time) |$oldTime|)))
    (SETQ |$timerOn| 'T)
    (|clock|))
 
(defun |stopTimer| ()
 (SETQ |$oldTime| (get-internal-run-time) |$timerOn| NIL) (|clock|))
 
(defun |clock| ()
  (if |$timerOn| (- (get-internal-run-time) $delay) (- |$oldTime| $delay)))
 
; Functions to trace/untrace a BPI; use as follows:
; To trace a BPI-value <bpi>, evaluate (SETQ <name> (BPITRACE <bpi>))
; To later untrace <bpi>, evaluate (BPITRACE <name>)
 
(defun PAIRTRACE (PAIR ALIAS)
   (RPLACA PAIR (BPITRACE (CAR PAIR) ALIAS )) NIL)
 
(defun BPITRACE (BPI ALIAS &optional OPTIONS)
  (SETQ NEWNAME (GENSYM))
  (IF (identp bpi) (setq bpi (symbol-function bpi)))
  (SET NEWNAME BPI)
  (SETF (symbol-function NEWNAME) BPI)
  (/TRACE-0 (APPEND (LIST NEWNAME (LIST 'ALIAS ALIAS)) OPTIONS))
  NEWNAME)
 
(defun BPIUNTRACE (X ALIAS) (/UNTRACE-0 (LIST X (LIST 'ALIAS ALIAS))))
 
(defun SPADSYSNAMEP (STR)
  (let (n i j)
    (AND (SETQ N (MAXINDEX STR))
         (SETQ I (position #\. STR :start 1))
         (SETQ J (position #\, STR :start (1+ I)))
         (do ((k (1+ j) (1+ k)))
             ((> k n) t)
           (if (not (digitp (elt str k))) (return nil))))))
 
; **********************************************************************
;            Utility functions for Tracing Package
; **********************************************************************
 
(setf (get '|coerce| '/transform) '(& & *))
(setf (get '|comp| '/transform) '(& * * &))
(setf (get '|compIf| '/transform) '(& * * &))
 
;  by having no transform for the 3rd argument, it is simply not printed
 
(setf (get '|compFormWithModemap| '/TRANSFORM) '(& * * & *))
 
(defun UNVEC (X)
  (COND ((REFVECP X) (CONS '$ (VEC_TO_TREE X)))
        ((ATOM X) X)
        ((CONS (UNVEC (CAR X)) (UNVEC (CDR X))))))
 
(defun DROPENV (X) (AND X (LIST (CAR X) (CADR X))))
 
(defun SHOWBIND (E)
  (do ((v e (cdr v))
       (llev 1 (1+ llev)))
      ((not v))
    (PRINT (LIST "LAMBDA LEVEL" LLEV))
    (do ((w (car v) (cdr w))
         (clev 1 (1+ clev)))
        ((not w))
      (PRINT (LIST "CONTOUR LEVEL" CLEV))
      (PRINT (mapcar #'car (car W))))))
 
(defun lisp-break-from-axiom (&rest ignore) 
    (boot::|handleLispBreakLoop| boot::|$BreakMode|))

\end{chunk}
\subsection{interrupt}
A "resumable" break loop for use in trace etc. Unfortunately this
only works for CCL. We need to define a Common Lisp version. For
now the function is defined but does nothing.
\begin{chunk}{*}
(defun interrupt (&rest ignore))

; NAME:    Scratchpad Package
; PURPOSE: This is an initialization and system-building file for Scratchpad.

;;; Common  Block

(defvar |$UserLevel| '|development|)
(defvar |$incrementalLisplibFlag| nil "checked in compDefineLisplib")
(defvar |$reportInstantiations| nil)
(defvar |$reportEachInstantiation| nil)
(defvar |$reportCounts| nil)
(defvar |$CategoryDefaults| nil)
(defvar |$compForModeIfTrue| nil "checked in compSymbol")
(defvar |$functorForm| nil "checked in addModemap0")
(defvar |$formalArgList| nil "checked in compSymbol")
(defvar |$newCompCompare| nil "compare new compiler with old")
(defvar |$compileOnlyCertainItems| nil "list of functions to compile")
(defvar |$doNotCompileJustPrint| nil "switch for compile")
(defvar |$Rep| '|$Rep| "should be bound to gensym? checked in coerce")
;; the following initialization of $ must not be a defvar
;; since that make $ special
(setq $ '$) ;; used in def of Ring which is Algebra($)
(defvar |$scanIfTrue| nil "if t continue compiling after errors")
(defvar |$Representation| nil "checked in compNoStacking")
(defvar |$definition| nil "checked in DomainSubstitutionFunction")
(defvar |$Attributes| nil "global attribute list used in JoinInner")
(defvar |$getPutTrace| nil)
(defvar |$specialCaseKeyList| nil "checked in optCall")
(defvar |$formulaFormat| nil "if true produce script formula output")
(defvar |$texFormat| nil "if true produce tex output")
(defvar |$mathmlFormat| nil "if true produce mathml output")
(defvar |$htmlFormat| nil "if true produce html output")
(defvar |$texFormat| nil "if true produce tex output")
(defvar |$fortranFormat| nil "if true produce fortran output")
(defvar |$algebraFormat| t "produce 2-d algebra output")
(defvar |$kernelWarn| NIL "")
(defvar |$kernelProtect| NIL "")
(defvar |$HiFiAccess| nil "if true maintain history file")
(defvar |$mapReturnTypes| nil)
(defvar /TRACENAMES NIL)

(defvar INPUTSTREAM t "bogus initialization for now")

(defvar |boot-NewKEY| NIL)
(setq /WSNAME 'NOBOOT)
(DEFVAR _ '&)
(setq $linestack 'begin_unit)
(setq $maxlinenumber 0)
(defvar /EDIT-FM 'A1)
(defvar /EDIT-FT 'SPAD)
(defvar /rp '/RP)
(defvar error-print)
(defvar ind)
(defvar m-chrbuffer)
(defvar m-chrindex)
(defvar MARG 0 "Margin for testing by ?OP")
(defvar ParseMode)
(setq XTOKENREADER 'SPADTOK)
(defvar xtrans '|boot-new|)
(defvar |$IOAlist| '((|%i| . (|gauss| 0 1))))
(setq |$useBFasDefault| T)
(defvar |New-LEXPR|)

;************************************************************************
;         SYSTEM COMMANDS
;************************************************************************

(defmacro |DomainSubstitutionMacro| (&rest L)
  (|DomainSubstitutionFunction| (first L) (second L)))

; vol 10.2?
(defun |sort| (seq spadfn)
    (sort (copy-seq seq) (function (lambda (x y) (SPADCALL X Y SPADFN)))))

(defmacro |float| (x &optional (y 0.0d0)) `(float ,x ,y))

(define-function 'list1 #'list)
(define-function '|not| #'NOT)

(setf (get 'end_unit 'key) t)

(defun |process| (x)
  (COND ((NOT (EQ TOK 'END_UNIT))
         (SETQ DEBUGMODE 'NO)
         (SPAD-SYNTAX-ERROR)
         (if |$InteractiveMode| (|spadThrow|))
         (S-PROCESS x))))


\end{chunk}
\begin{chunk}{*}

(setq *PROMPT* 'LISP)

(defun INITIALIZE () (init-boot/spad-reader) (initialize-preparse INPUTSTREAM))

(setq *prompt* 'new)

(defmacro try (X)
  `(LET ((|$autoLine|))
        (declare (special |$autoLine|))
        (|tryToFit| (|saveState|) ,X)))

(defun GLESSEQP (X Y) (NOT (GGREATERP X Y)))

(defun LEXLESSEQP (X Y) (NOT (LEXGREATERP X Y)))

(defmacro |rplac| (&rest L)
  (let (a b s)
    (cond
      ((EQCAR (SETQ A (CAR L)) 'ELT)
       (COND ((AND (INTEGERP (SETQ B (CADDR A))) (>= B 0))
              (SETQ S "CA")
              (do ((i 1 (1+ i))) ((> i b)) (SETQ S (STRCONC S "D")))
              (LIST 'RPLAC (LIST (INTERN (STRCONC S "R")) (CADR A)) (CADR L)))
             ((ERROR "rplac"))))
      ((PROGN
         (SETQ A (CARCDREXPAND (CAR L) NIL))
         (SETQ B (CADR L))
         (COND
           ((CDDR L) (ERROR 'RPLAC))
           ((EQCAR A 'CAR) (LIST 'RPLACA (CADR A) B))
           ((EQCAR A 'CDR) (LIST 'RPLACD (CADR A) B))
           ((ERROR 'RPLAC))))))))

; **** X. Random tables

(defun |makeSF| (mantissa exponent)
  (|float| (/ mantissa (expt 2 (- exponent)))))

(setf (get 'cond '|Nud|) '(|if| |if| 130 0))
(setf (get 'cons '|Led|) '(cons cons 1000 1000))
(setf (get 'append '|Led|) '(append append 1000 1000))
(setf (get 'tag '|Led|) '(tag tag 122 121))
(setf (get 'equatnum '|Nud|) '(|dummy| |dummy| 0 0))
(setf (get 'equatnum '|Led|) '(|dummy| |dummy| 10000 0))
(setf (get 'let '|Led|) '(:= let 125 124))
(setf (get 'rarrow '|Led|) '(== def 122 121))
(setf (get 'segment '|Led|) '(\.\. segment 401 699 (|boot-Seg|)))

;; function to create byte and half-word vectors in new runtime system 8/90

(SETQ |/MAJOR-VERSION| 7)
(SETQ /VERSION 0)

;; For the browser, used for building local databases when a user compiles
;; their own code.
(SETQ |$newConstructorList| nil)
(SETQ |$createLocalLibDb| 't)

;; These are duplicates of definitions in bookvol9

(defvar |$byConstructors| () "list of constructors to be compiled")
(defvar |$constructorsSeen| () "list of constructors found")

;; These were originally in SPAD LISP

;======================================================================
;TPDHERE START

(SETQ |$newComp| NIL)
(SETQ |$newCompCompare| NIL)
(SETQ |$permitWhere| NIL)
(SETQ |$newSystem| T)
(SETQ |$bootStrapMode| NIL) ;; if true skip functor bodies
(SETQ |$compileOnlyCertainItems| NIL)
(SETQ |$devaluateList| NIL)
(SETQ |$doNotCompressHashTableIfTrue| NIL)
(SETQ |$mutableDomains| NIL)     ; checked in DEFINE BOOT
(SETQ |$maxSignatureLineNumber| 0)
(SETQ |$functionLocations| NIL)
(SETQ |$functorLocalParameters| NIL) ; used in compSymbol
(SETQ |$insideCategoryPackageIfTrue| NIL)
(SETQ |$insideCompileBodyIfTrue| NIL)
(SETQ |$compilingInputFile| NIL)
(setq |$ReadingFile| NIL)
(setq |$Newline| #\Newline)
(setq |$createUpdateFiles| nil)
(SETQ $FUNNAME NIL)   ;; this and next used in COMP,TRAN,1
(SETQ $FUNNAMETAIL '(()))
(SETQ |$Slot1DataBase| (MAKE-HASHTABLE 'ID))  ;; See NRUNTIME BOOT
(SETQ |$ruleSetsInitialized| NIL)
(SETQ |$NRTmakeCompactDirect| NIL)
(SETQ |$returnNowhereFromGoGet| NIL) ; this is not set true anywhere
(SETQ |$insideCanCoerceFrom| NIL)
(SETQ |$useCoerceOrCroak| T) ; this is always true everywhere
(SETQ |$InterpreterMacroAlist|
      '((|%i| . (|complex| 0 1))
        (|%e| . (|exp| 1))
        (|%pi| . (|pi|))
        (|SF| . (|DoubleFloat|))
        (|%infinity| . (|infinity|))
        (|%plusInfinity| . (|plusInfinity|))
        (|%minusInfinity| . (|minusInfinity|))))

;; These are for the output routines in OUT BOOT

(SETQ *TALLPAR NIL) ; never set to true
(SETQ BLANK " ")
(SETQ COLON ":")
(SETQ COMMA ",")
(SETQ DASH "-")
(SETQ DOLLAR "$")
(SETQ EQSIGN "=")
(SETQ LPAR "(")
(SETQ MATBORCH "*")
(SETQ PERIOD ".")
(SETQ PLUSS "+")
(SETQ RPAR ")")
(SETQ SLASH "/")
(SETQ STAR "*")

;======================================================================
;TPDHERE END








(SETQ $LISPLIB NIL)
(SETQ |$dependeeClosureAlist|  NIL)
(SETQ |$userModemaps| NIL)
(SETQ |$forceDatabaseUpdate| NIL)  ;; see "load" function
(SETQ |$functorForm| NIL)

(SETQ |$spadLibFT| 'LISPLIB)

(SETQ |$existingFiles| (MAKE-HASHTABLE 'UEQUAL))
(SETQ |$updateCatTableIfTrue| 'T)

(SETQ |$ConstructorCache| (MAKE-HASHTABLE 'ID))
(SETQ |$immediateDataSymbol| '|--immediateData--|)

(SETQ |$useIntegerSubdomain| 'T)
(SETQ |$useNewFloat| 'T)

;; See CLAMMED BOOT for defs of following functions
(SETQ |$clamList| '(
  (|canCoerce| |hash| UEQUAL |count|)
  (|canCoerceFrom| |hash| UEQUAL |count|)
  (|coerceConvertMmSelection| |hash| UEQUAL |count|)
  (|hasFileProperty| |hash| UEQUAL |count|)
  (|isLegitimateMode| |hash| UEQUAL |count|)
  (|isValidType| |hash| UEQUAL |count|)
  (|resolveTT|       |hash| UEQUAL |count|)
  (|selectMms1| |hash| UEQUAL |count|)
  (|underDomainOf|   |hash| UEQUAL |count|)
))

;; following is symbol denoting a failed operation
(SETQ |$failure| (GENSYM))
;; the following symbol holds the canonical "failed" value
(SETQ |$failed| "failed")

(SETQ |$constructorDataTable| NIL)

(SETQ |$underDomainAlist| '())
;;(SETQ |$underDomainAlist| '(
;;  (|DistributedMultivariatePolynomial| . 2)
;;  (|MultivariatePolynomial| . 2)
;;  (|NewDistributedMultivariatePolynomial| . 2)
;;  (|RectangularMatrix| . 3)
;;  (|SquareMatrix| . 2)
;;  (|UnivariatePoly| . 2)
;;  (|VVectorSpace| . 2)
;;))

(SETQ |$univariateDomains| '(
    |UnivariatePolynomial|
    |UnivariateTaylorSeries|
    |UnivariateLaurentSeries|
    |UnivariatePuiseuxSeries|
    ))
(SETQ |$multivariateDomains| '(
    |MultivariatePolynomial|
    |DistributedMultivariatePolynomial|
    |HomogeneousDistributedMultivariatePolynomial|
    |GeneralDistributedMultivariatePolynomial|
    ))

(SETQ |$Primitives| '(|Union| |Mapping| |Record| |Enumeration|))

(SETQ |$DomainsWithoutLisplibs| '(
  CAPSULE |Union| |Record| |SubDomain| |Mapping| |Enumeration| |Domain| |Mode|))

(SETQ |$letAssoc| NIL)
        ;" used for trace of assignments in SPAD code -- see macro LETT"
(SETQ |$QuickCode| T)
         ;" controls generation of QREFELT etc."
(SETQ |$QuickLet| T)
         ;" controls generation of LET tracing."
(SETQ |$lastUntraced| NIL)
 ;" used for )restore option of )trace."
(SETQ |$mathTraceList| NIL)
         ;" controls mathprint output for )trace."
(SETQ |$domainTraceNameAssoc| NIL)
        ;"alist of traced domains"
(SETQ |$tracedMapSignatures| ())
(SETQ |$highlightAllowed| 'T)
         ;" used in BRIGHTPRINT and is a )set variable"

(SETQ |$abbreviationTable| NIL)

(SETQ |$ConstructorNames| '(
  |SubDomain| |List| |Union| |Record| |Vector|
      ))
           ;" Used in isFunctor test, and compDefine "

(SETQ |$SpecialDomainNames| '(
  |add| CAPSULE |SubDomain| |List| |Union| |Record| |Vector|
      ))
                 ;" Used in isDomainForm, addEmptyCapsuleIfnecessary"

(SETQ |$DomainNames| '(
   |Integer| |Float| |Symbol| |Boolean| |String| |Expression|
   |Mapping| |SubDomain| |List| |Union| |Record| |Vector| |Enumeration|
      ))

(SETQ |$CategoryNames| '(
   |Category| |CATEGORY| |RecordCategory| |Join| |EnumerationCategory|
   |StringCategory| |SubsetCategory| |UnionCategory|
      ))

(|SETQ| |$BasicDomains| '(|Integer| |Float| |Symbol| |Boolean| |String|))

(SETQ |$printStorageIfTrue| NIL) ;; storage info disabled in common lisp
(SETQ |$mostRecentOpAlist| NIL)
(SETQ |$noEnv| NIL)
(SETQ |$croakIfTrue| NIL) ;" see moan in UT"
(SETQ |$opFilter| NIL)    ;" used to |/s a function "
(SETQ |$evalDomain| NIL)

(SETQ |$SideEffectFreeFunctionList| '(
  |null| |case| |Zero| |One| \: |::| |has| |Mapping|
  |elt| = |>| |>=| |<| |<=| MEMBER |is| |isnt| ATOM
  $= |$>| |$>=| |$<| |$<=| $^= $MEMBER
))

(SETQ |$AnonymousFunction| '(|AnonymousFunction|))
(SETQ |$Any|   '(|Any|))
(SETQ |$BFtag| '|:BF:|)
(SETQ |$Boolean| '(|Boolean|))
(SETQ |$Category| '(|Category|))
(SETQ |$Domain| '(|Domain|))
(SETQ |$Exit|  '(|Exit|))
(SETQ |$Expression| '(|OutputForm|))
(SETQ |$OutputForm| '(|OutputForm|))
(SETQ |$BigFloat| '(|Float|))
(SETQ |$Float| '(|Float|))
(SETQ |$DoubleFloat| '(|DoubleFloat|))
(SETQ |$FontTable| '(|FontTable|))
(SETQ |$Integer| '(|Integer|))
(SETQ |$ComplexInteger| (LIST '|Complex| |$Integer|))
(SETQ |$Mode| '(|Mode|))
(SETQ |$NegativeInteger| '(|NegativeInteger|))
(SETQ |$NonNegativeInteger| '(|NonNegativeInteger|))
(SETQ |$NonPositiveInteger| '(|NonPositiveInteger|))
(SETQ |$PositiveInteger| '(|PositiveInteger|))
(SETQ |$RationalNumber| '(|Fraction| (|Integer|)))
(SETQ |$String| '(|String|))
(SETQ |$StringCategory| '(|StringCategory|))
(SETQ |$Symbol| '(|Symbol|))
(SETQ |$Void|  '(|Void|))
(SETQ |$QuotientField| '|Fraction|)
(SETQ |$FunctionalExpression| '|Expression|)
(SETQ |$defaultFunctionTargets| '(()))
(SETQ |$SmallInteger| '(|SingleInteger|))
(SETQ |$SingleFloat| '(|SingleFloat|))
(SETQ |$DoubleFloat| '(|DoubleFloat|))
(SETQ |$SingleInteger| '(|SingleInteger|))

(SETQ $TOP_LEVEL T)
(SETQ $NE (LIST (LIST NIL)))
(SETQ |$gauss01| '(|gauss| 0 1))
(SETQ |$LocalFrame| (LIST (LIST NIL)))
(SETQ |$DomainsInScope| (LIST NIL))
(SETQ |$EmptyEnvironment| '((NIL)))
(SETQ |$NETail| (CONS |$EmptyEnvironment| NIL))

(SETQ |$DummyFunctorNames| '(|Mapping|))
(SETQ |$form| NIL)
(SETQ |$DoubleQuote| '"\"")
(SETQ |$EmptyString| "")
(SETQ |$EmptyVector| (VECTOR))
(SETQ |$EmptyList| ())
(SETQ |$Index| 0)
(SETQ |$true| ''T)
(SETQ |$false| NIL)
(SETQ |$suffix| NIL)
(SETQ |$coerceIntByMapCounter| 0)
(SETQ |$reportCoerce| NIL)
(SETQ |$reportCompilation| NIL)
(SETQ |$streamCount| 0)
(SETQ |$cacheCount| 0)
(SETQ |$streamIndexing| NIL)
(SETQ |$reportExitModeStack| NIL)
(SETQ |$prefix| NIL)
(SETQ |$Polvar| '(WRAPPED . ((1 . 1))))
(SETQ |$OneCoef| '(1 1 . 1))
(SETQ |$Lisp| '(|Lisp|))
(SETQ |$ExpressionOpt| '(|Expression| . OPT))
(SETQ |$formalArgList| ())
(SETQ |$FormalMapVariableList|
  '(|#1| |#2| |#3| |#4| |#5| |#6| |#7| |#8| |#9| |#10|
    |#11| |#12| |#13| |#14| |#15| |#16| |#17| |#18| |#19| |#20|
    |#21| |#22| |#23| |#24| |#25| |#26| |#27| |#28| |#29| |#30|
    |#31| |#32| |#33| |#34| |#35| |#36| |#37| |#38| |#39| |#40|
    |#41| |#42| |#43| |#44| |#45| |#46| |#47| |#48| |#49| |#50|
    ))
(SETQ |$PatternVariableList|
  '(*1 *2 *3 *4 *5 *6 *7 *8 *9 *10 *11 *12 *13 *14 *15 *16 *17 *18 *19 *20
  *21 *22 *23 *24 *25 *26 *27 *28 *29 *30 *31 *32 *33 *34 *35 *36 *37 *38 *39 *40
  *41 *42 *43 *44 *45 *46 *47 *48 *49 *50))
(SETQ |$ModeVariableList|
  '(dv$1 dv$2 dv$3 dv$4 dv$5 dv$6 dv$7 dv$8 dv$9 dv$10 dv$11 dv$12 dv$13 dv$14 dv$15
         dv$16 dv$17 dv$18 dv$19 dv$20))
(SETQ |$DomainVariableList|
  '($1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14 $15 $16 $17 $18 $19 $20))
(SETQ |$TriangleVariableList|
   '(|t#1| |t#2| |t#3| |t#4| |t#5| |t#6| |t#7| |t#8| |t#9| |t#10|
     |t#11| |t#12| |t#13| |t#14| |t#15| |t#16| |t#17| |t#18| |t#19| |t#20|
     |t#21| |t#22| |t#23| |t#24| |t#25| |t#26| |t#27| |t#28| |t#29| |t#30|
     |t#31| |t#32| |t#33| |t#34| |t#35| |t#36| |t#37| |t#38| |t#39| |t#40|
     |t#41| |t#42| |t#43| |t#44| |t#45| |t#46| |t#47| |t#48| |t#49| |t#50|))

(SETQ |$PrimitiveDomainNames|
      '(|List| |Integer| |NonNegativeInteger| |PositiveInteger|
        |SingleInteger| |String| |Boolean|))
            ;" used in mkCategory to avoid generating vector slots"
            ;" for primitive domains "
            ;" also used by putInLocalDomainReferences and optCall"
(SETQ |$optimizableConstructorNames|
   '(|List| |Integer| |PositiveInteger| |NonNegativeInteger| |SingleInteger|
     |String| |Boolean| |Symbol| |DoubleFloat| |PrimitiveArray| |Vector|))
            ;" used by optCallSpecially"
(SETQ |$Zero| '(|Zero|))
(SETQ |$One| '(|One|))
(SETQ |$NonMentionableDomainNames|
      '($ |Rep| |Record| |Union| |Mapping| |Enumeration|))

;"  modemap:==  ( <map> (p e) (p e) ... (p e) )  "
;"  modemaplist:= ( modemap ... )  "
(SETQ |$CategoryFrame| '(((
  (|Category| .
    ((|modemap|
      ( ((|Category|) (|Category|)) (T *) )
        )))
  (|Join| .
    ((|modemap|
      ( ((|Category|) (|Category|) (|Category|) (|Category|)) (|T| *) )
      ( ((|Category|) (|Category|) (|List| (|Category|)) (|Category|)) (T *) )
        )))
    ))))

(SETQ |$NRTflag| T)
(SETQ |$NRTaddForm| NIL)
(SETQ |$NRTdeltaList| NIL)
(SETQ |$NRTbase| 0)
(SETQ |$NRTdeltaLength| 0)
(SETQ |$NRTopt| NIL) ;; turns off buggy code
(SETQ |$Slot1DataBase| NIL)
(SETQ |$NRTmonitorIfTrue| NIL)

(SETQ |$useConvertForCoercions| NIL)

(setf (get '|One| '|defaultType|) |$Integer|)
(setf (get '|Zero| '|defaultType|) |$Integer|)

;; Following were originally in EXPLORE BOOT

(SETQ |$xdatabase|         NIL)
(SETQ |$CatOfCatDatabase|  NIL)
(SETQ |$DomOfCatDatabase|  NIL)
(SETQ |$JoinOfDomDatabase| NIL)
(SETQ |$JoinOfCatDatabase| NIL)
(SETQ |$attributeDb|       NIL)

(SETQ |$abbreviateIfTrue|  NIL)
(SETQ |$deltax| 0)
(SETQ |$deltay| 0)
(SETQ |$displayDomains| 'T)
(SETQ |$displayTowardAncestors| NIL)
(SETQ |$focus| NIL)
(SETQ |$focusAccessPath|  NIL)
(SETQ |$minimumSeparation|  3)
(SETQ |$origMaxColumn| 80)
(SETQ |$origMaxRow|  20)
(SETQ |$origMinColumn| 1)
(SETQ |$origMinRow|  1)

;; ---- start of initial settings for variables used in test.boot

(SETQ |$testOutputLineFlag| NIL)   ;; referenced by charyTop, prnd
                                   ;; to stash lines
(SETQ |$testOutputLineStack| NIL)  ;; saves lines to be printed
                                   ;; (needed to convert lines for use
                                   ;; in hypertex)
(SETQ |$mkTestInputStack| NIL)     ;; saves input for $testStream
                                   ;; (see READLN)
(SETQ |$mkTestOutputStack| NIL)    ;; saves output for $testStream
                                   ;; (see maPrin)

;; ---- end of initial settings for variables used in test.boot

;; Next flag determines whether to use BF as default floating point
;; type. (actually, now means NewFloat)

(SETQ |$useBFasDefault| 'T)

;; Next are initial values for fluid variables in G-BOOT BOOT

(SETQ |$inDefLET| NIL)
(SETQ |$inDefIS|  NIL)
(SETQ |$letGenVarCounter| 1)
(SETQ |$isGenVarCounter|  1)

;; Next 2 lines originally from CLAM BOOT

;; this node is used in looking up values
(SETQ |$hashNode| (LIST NIL))

(SETQ ERRORINSTREAM (DEFIOSTREAM
    '((DEVICE . CONSOLE) (MODE . INPUT) (QUAL . T)) 133 1))

(SETQ ERROROUTSTREAM
  (DEFIOSTREAM '((DEVICE . CONSOLE)(MODE . OUTPUT)) 80 0) )

(SETQ |$algebraOutputStream|
  (DEFIOSTREAM '((DEVICE . CONSOLE)(MODE . OUTPUT)) 255 0) )

;; By default, don't generate info files with old compiler.
(setq |$profileCompiler| nil)


\end{chunk}
\begin{verbatim}
This file contains most of the code that puts properties on
identifiers in the Scratchpad II system.  If it was not possible
to actually put the code here, we have pointers to where such
property list manipulation is being done.

Pointers:
o  see NEWAUX LISP for some code that puts GENERIC and RENAMETOK
   properties on identifiers for the parser
o  coerceIntCommute puts the "commute" property on constructors.
o  coerceRetract puts the "retract" property on constructors.
o  there is some code at the end of SPECEVAL BOOT that puts "up"
   properties on some special handlers.

\end{verbatim}
\begin{chunk}{*}

(setf (get 'end_unit 'key) t)

(setf (get 'tag 'Led) '(tag tag 122 121))
(setf (get 'equatnum '|Nud|) '(|dummy| |dummy| 0 0))
(setf (get 'equatnum '|Led|) '(|dummy| |dummy| 10000 0))
(setf (get 'let '|Led|) '(|:=| let 125 124))
(setf (get 'rarrow '|Led|) '(== def 122 121))
(setf (get 'segment '|Led|) '(|..| segment 401 699 (|P:Seg|)))
(setf (get 'segment '|isSuffix|) t)
(setf (get 'equal1 'chrybnam) 'eq)

(REPEAT (IN X '(
   (LET " := ")
   (= "=")
   (|/| "/")
   (+ "+")
   (* "*")
   (** "**")
   (^ "^")
   (|:| ":")
   (|::| "::")
   (|@| "@")
   (SEL ".")
   (|exquo| " exquo ")
   (|div| " div ")
   (|quo| " quo ")
   (|rem| " rem ")
   (|case| " case ")
   (|and| " and ")
   (|or| " or ")
   (TAG " -> ")
   (|+->| " +-> ")
   (RARROW ": ")
   (SEGMENT "..")
   (in " in ")
   (|^=|  "^=")
   (EL* ":")
   (JOIN " JOIN ")
   (EQUATNUM "  ")
   (IQUOTIENT "//")
   (= "= ")
   (|>=| " >= ")
   (|>| " > ")
   (|<=| " <= ")
   (|<| " < ")
   (\| " \| ")
   (+ " + ")
   (- " - ")
   (MEMBER " in ")
   (NMEMBER " nin ")
   (WHERE " WHERE ")
   (AT " AT ")
   (MAX " MAX ")
   (MIN " MIN ")
       )) (setf (get (first x) 'infixop) (second x)))

(REPEAT (IN X '(
  (= "=")
  (|:| ":")
  (|not| "^ ")
  (\| " \| ")
  (SEGMENT "..")  ;" 0.. is represented by (SEGMENT 0)"
 )) (setf (get (first x) 'prefixop) (second x)))

(REPEAT (IN X '(
  (+ WIDTH |sumWidth|)
  (- APP |appneg|)
  (- WIDTH |minusWidth|)
  (/ APP |appfrac|)
  (/ SUBSPAN |fracsub|)
  (/ SUPERSPAN |fracsuper|)
  (/ WIDTH |fracwidth|)
  (AGGSET APP |argsapp|)
  (AGGSET SUBSPAN |agggsub|)
  (AGGSET SUPERSPAN |agggsuper|)
  (AGGSET WIDTH |agggwidth|)
  (|binom| APP |binomApp|)
  (|binom| SUBSPAN |binomSub|)
  (|binom| SUPERSPAN |binomSuper|)
  (|binom| WIDTH |binomWidth|)
  (ALTSUPERSUB APP       |altSuperSubApp|)
  (ALTSUPERSUB SUBSPAN   |altSuperSubSub|)
  (ALTSUPERSUB SUPERSPAN |altSuperSubSuper|)
  (ALTSUPERSUB WIDTH     |altSuperSubWidth|)
  (BOX APP |boxApp|)
  (BOX SUBSPAN |boxSub|)
  (BOX SUPERSPAN |boxSuper|)
  (BOX WIDTH |boxWidth|)
  (BRACKET SUBSPAN |qTSub|)
  (BRACKET SUPERSPAN |qTSuper|)
  (BRACKET WIDTH |qTWidth|)
  (CENTER APP |centerApp|)
  (EXT APP |appext|)
  (EXT SUBSPAN |extsub|)
  (EXT SUPERSPAN |extsuper|)
  (EXT WIDTH |extwidth|)
  (MATRIX APP |appmat|)
  (MATRIX SUBSPAN |matSub|)
  (MATRIX SUPERSPAN |matSuper|)
  (MATRIX WIDTH |matWidth|)
  (NOTHING APP       |nothingApp|)
  (NOTHING SUPERSPAN |nothingSuper|)
  (NOTHING SUBSPAN   |nothingSub|)
  (NOTHING WIDTH     |nothingWidth|)
  (OVER APP |appfrac|)
  (OVER SUBSPAN |fracsub|)
  (OVER SUPERSPAN |fracsuper|)
  (OVER WIDTH |fracwidth|)
  (OVERLABEL APP |overlabelApp|)
  (OVERLABEL SUPERSPAN |overlabelSuper|)
  (OVERLABEL WIDTH |overlabelWidth|)
  (OVERBAR APP |overbarApp|)
  (OVERBAR SUPERSPAN |overbarSuper|)
  (OVERBAR WIDTH |overbarWidth|)
  (PAREN APP |appparu1|)
  (PAREN SUBSPAN |qTSub|)
  (PAREN SUPERSPAN |qTSuper|)
  (PAREN WIDTH |qTWidth|)
  (ROOT APP       |rootApp|)
  (ROOT SUBSPAN   |rootSub|)
  (ROOT SUPERSPAN |rootSuper|)
  (ROOT WIDTH     |rootWidth|)
  (ROW WIDTH |eq0|)
  (SC APP |appsc|)
  (SC SUBSPAN |agggsub|)
  (SC SUPERSPAN |agggsuper|)
  (SC WIDTH |widthSC|)
  (SETQ APP |appsetq|)
  (SETQ WIDTH |letWidth|)
  (SLASH APP       |slashApp|)
  (SLASH SUBSPAN   |slashSub|)
  (SLASH SUPERSPAN |slashSuper|)
  (SLASH WIDTH     |slashWidth|)
  (SUB APP |appsub|)
  (SUB SUBSPAN |subSub|)
  (SUB SUPERSPAN |subSuper|)
  (SUB WIDTH |suScWidth|)
  (SUPERSUB APP |superSubApp|)
  (SUPERSUB SUBSPAN |superSubSub|)
  (SUPERSUB SUPERSPAN |superSubSuper|)
  (SUPERSUB WIDTH |superSubWidth|)
  (VCONCAT APP |vconcatapp|)
  (VCONCAT SUBSPAN |vConcatSub|)
  (VCONCAT SUPERSPAN |vConcatSuper|)
  (VCONCAT WIDTH |vConcatWidth|)
  (BINOMIAL APP |binomialApp|)
  (BINOMIAL SUBSPAN |binomialSub|)
  (BINOMIAL SUPERSPAN |binomialSuper|)
  (BINOMIAL WIDTH |binomialWidth|)
  (ZAG APP |zagApp|)
  (ZAG SUBSPAN |zagSub|)
  (ZAG SUPERSPAN |zagSuper|)
  (ZAG WIDTH |zagWidth|)
)) (setf (get (first x) (second x)) (third x)))

(REPEAT (IN X '(
  (+ APP |plusApp|)
  (* APP |timesApp|)
  (* WIDTH |timesWidth|)
  (** APP |exptApp|)
  (** WIDTH |exptWidth|)
  (** SUBSPAN |exptSub|)
  (** SUPERSPAN |exptSuper|)
  (^  APP |exptApp|)
  (^  WIDTH |exptWidth|)
  (^  SUBSPAN |exptSub|)
  (^  SUPERSPAN |exptSuper|)
  (STEP APP |stepApp|)
  (STEP WIDTH |stepWidth|)
  (STEP SUBSPAN |stepSub|)
  (STEP SUPERSPAN |stepSuper|)
  (IN APP |inApp|)
  (IN WIDTH |inWidth|)
  (IN SUBSPAN |inSub|)
  (IN SUPERSPAN |inSuper|)
  (AGGLST APP |aggApp|)
  (AGGLST SUBSPAN |aggSub|)
  (AGGLST SUPERSPAN |aggSuper|)
  (CONCATB APP |concatbApp|)
  (CONCATB SUBSPAN |concatSub|)
  (CONCATB SUPERSPAN |concatSuper|)
  (CONCATB WIDTH |concatbWidth|)
  (CONCAT APP |concatApp|)
  (CONCAT  SUBSPAN |concatSub|)
  (CONCAT SUPERSPAN |concatSuper|)
  (CONCAT WIDTH |concatWidth|)
  (QUOTE APP |quoteApp|)
  (QUOTE SUBSPAN |quoteSub|)
  (QUOTE SUPERSPAN |quoteSuper|)
  (QUOTE WIDTH |quoteWidth|)
  (STRING APP |stringApp|)
  (STRING SUBSPAN |eq0|)
  (STRING SUPERSPAN |eq0|)
  (STRING WIDTH |stringWidth|)
  (SIGMA APP |sigmaApp|)
  (SIGMA SUBSPAN |sigmaSub|)
  (SIGMA SUPERSPAN |sigmaSup|)
  (SIGMA WIDTH |sigmaWidth|)
  (SIGMA2 APP |sigma2App|)
  (SIGMA2 SUBSPAN |sigma2Sub|)
  (SIGMA2 SUPERSPAN |sigma2Sup|)
  (SIGMA2 WIDTH |sigma2Width|)
  (INTSIGN APP |intApp|)
  (INTSIGN SUBSPAN |intSub|)
  (INTSIGN SUPERSPAN |intSup|)
  (INTSIGN WIDTH |intWidth|)
  (INDEFINTEGRAL APP |indefIntegralApp|)
  (INDEFINTEGRAL SUBSPAN |indefIntegralSub|)
  (INDEFINTEGRAL SUPERSPAN |indefIntegralSup|)
  (INDEFINTEGRAL WIDTH |indefIntegralWidth|)
  (PI APP |piApp|)
  (PI SUBSPAN |piSub|)
  (PI SUPERSPAN |piSup|)
  (PI WIDTH |piWidth|)
  (PI2 APP |pi2App|)
  (PI2 SUBSPAN |pi2Sub|)
  (PI2 SUPERSPAN |pi2Sup|)
  (PI2 WIDTH |pi2Width|)
  (AGGLST WIDTH |aggWidth|)
  (BRACKET APP |bracketApp|)
  (BRACE APP |braceApp|)
  (BRACE WIDTH |qTWidth|)
)) (setf (get (first x) (second x)) (third x)))

;; from DEF LISP

;; following was in INIT LISP

(REPEAT (IN X '(
  |Polynomial| |UnivariatePoly| |SquareMatrix| |QuotientField|
  )) 
(setf (get x '|status|) (internl (strconc "status" (stringimage x)))))

(REPEAT (IN X '(
  |UnivariatePoly| |Matrix| |QuotientField| |Gaussian|
  ))
(setf (get x '|dataCoerce|) (internl (strconc "coerce" (stringimage x)))))

;; this property is checked for Integers to decide which subdomain to
;; choose at compile time.

(setf (get '|Integer| '|Subsets|)
  '((|PositiveInteger| . (|>| * 0))
    (|NonNegativeInteger| . (|>=| * 0))
    (|NegativeInteger| . (|<| * 0))
    (|NonPositiveInteger| . (|<=| * 0))
    (|NonZeroInteger| . (^= * 0))
    (|SingleInteger| . (typep * 'fixnum))
    ))

(setf (get '|NonNegativeInteger| '|Subsets|)
  '((|PositiveInteger| . (|>| * 0))))

(setf (get '|NonPositiveInteger| '|Subsets|)
 '((|NegativeInteger| . (|<| * 0))))

(FLAG '(|Union| |Record| |Enumration| |Mapping| |Enumeration|) 'FUNCTOR)

(FLAG '(* + AND OR PROGN) 'NARY)

(setf (get 'integer 'isfunction) 'integerp)
(setf (get '|Integer| '|isFunction|) '|IsInteger|)
(setf (get '|Boolean| '|isFunction|) '|isBoolean|)

;; Many of the following are now in COMPAT LISP
(REPEAT (IN X '(
  (|and| AND)
  (|append| APPEND)
  (|apply| APPLY)
  (|atom| ATOM)
  (|brace| REMDUP)
  (|cons| CONS)
  (|copy| COPY)
  (|croak| CROAK)
  (|drop| DROP)
  (|exit| EXIT)
  (|false| NIL)
  (|first| CAR)
  (|genvar| GENVAR)
  (|in| |member|)
  (|is| IS)
  (|lastNode| LASTNODE)
  (|list| LIST)
  (|mkpf| MKPF)
  (|nconc| NCONC)
  (|nil| NIL)
  (|not| NULL)
  (|NOT| NULL)
  (|nreverse| NREVERSE)
  (|null| NULL)
  (|or| OR)
  (|otherwise| 'T)
  (|removeDuplicates| REMDUP)
  (|rest| CDR)
  (|return| RETURN)
  (|reverse| REVERSE)
  (|setDifference| SETDIFFERENCE)
  (|setIntersection| |intersection|)
  (|setPart| SETELT)
  (|setUnion| |union|)
  (|size| SIZE)
  (|strconc| STRCONC)
  (|substitute| MSUBST)
  (SUBST MSUBST)
  (|take| TAKE)
  (|true| 'T)
  (|where| WHERE)
  (* TIMES)
  (** EXPT)
  (^ NULL)
  (^= NEQUAL)
  (- SPADDIFFERENCE)
  (/ QUOTIENT)
  (= EQUAL)
  (ASSOC  |assoc|)
  (DELETE |delete|)
  (GET GETL)
  (INTERSECTION |intersection|)
  (LAST |last|)
  (MEMBER |member|)
  (RASSOC |rassoc|)
  (READ VMREAD)
  (READ-LINE |read-line|)
  (REDUCE SPADREDUCE)
  (REMOVE |remove|)
  (\| SUCHTHAT)
  (T T$)
  (UNION |union|)
)) (setf (get (first x) 'rename) (rest x)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; General
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro |Eq| (a b)
  `(eq ,a ,b) )

(defvar |Nil| nil)

(defun |DeepCopy| (x)
  (copy-tree x) )

(defun |SortInPlace| (l pred)
  (sort l pred) )

(defun |Sort| (l pred)
  (sort (copy-tree l) pred) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Streams
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun |Prompt| (line &optional (readfn nil))
  (format *query-io* "~a" line)
  (when readfn (apply readfn (list *query-io*))) )

(defun |PlainError| (&rest args)
  (let ((fmt (plain-print-format-string args)))
       (error fmt args) ))

(defun |PrettyPrint| (expr &optional (outstream *standard-output*))
  (write expr :stream outstream :level nil :length nil :pretty 't :escape 't) 
  (finish-output outstream) )

(defun |PlainPrint| (&rest args)
  (let ((fmt (plain-print-format-string args)))
       (format *standard-output* fmt args) ))

(defun |PlainPrintOn| (stream &rest args)
  (let ((fmt (plain-print-format-string args)))
       (format stream fmt args) ))

(defun plain-print-format-string (l)
  (format nil "~~~d{~~a~~}~~%" (length l)) )


;;; Lucid 1.01 bug:  Must flush output after each write or else
;;;                  strange errors arise from invalid buffer reuse.

(defun |WriteLispExpr| (expr &optional (outstream *standard-output*))
  (let ((*package* (find-package "USER")))
    (declare (special *package*))
    (write expr :stream outstream 
        :level nil :length nil :pretty nil :escape 't ) 
    (finish-output outstream) ))

(defmacro |WriteByte| (byte &rest outstream)
  `(write-byte ,byte ,@outstream) )

(defmacro |WriteChar| (char &rest outstream)
  `(write-char ,char ,@outstream) )

;; Write a string -- no new line.
(defun |WriteString| (string &optional (outstream *standard-output*))
  (format outstream "~a" string) 
  (finish-output outstream) )

;; Write a string then start a new line.
(defun |WriteLine| (string &optional (outstream *standard-output*))
  (write-line string outstream) 
  (finish-output outstream) )    

(defun |ByteFileWriteLine| (string outstream)
  (let ((n (length string)))
    (do ((i 0 (+ i 1)))
        ((= i n))
        (write-byte (char-code (char string i)) outstream) ))
  (write-byte (char-code #\Newline) outstream)
  (finish-output outstream) )



(defun |ReadLispExpr| (&optional (instream *standard-input*))
  (let ((*package* (find-package "USER")))
    (declare (special *package*))
    (read instream nil nil) ))

(defmacro |ReadByte| (instream)
  `(read-byte ,instream nil nil) )

(defmacro |ReadChar| (&rest instream)
  (if instream
    `(read-char ,@instream nil nil) 
    '(read-char *standard-input* nil nil) ))

(defun |ReadLine| (&optional (instream *standard-input*))
  (read-line instream nil nil) )

(defun |ByteFileReadLine| (instream)
  (do ((buf (make-array '(80) 
                :element-type 'string-char 
                :fill-pointer 0
                :adjustable 't ))
       (b (read-byte instream nil nil) (read-byte instream nil nil))
       (c) )

      ((or (null b) (char= (setq c (code-char b)) #\Newline)) buf)
     
      (vector-push-extend c buf) ))

;;; Reads no more than the rest of the current line into the string argument.
;;; The #\Newline is not included in the string.
;;;
;;; The result is an integer, 'T or nil.
;;;   Nil  the stream was already exhausted.
;;;   T    the string was filled before the end of line was reached.
;;;   k    the end of line was reached and k characters were copied.
;;;
;;; If the argument "flags" is passed a cons cell, it is updated
;;; to contain (Eof . Eol).  
;;; Eof indicates whether the end of file was detected.
;;; Eol indicates whether the line was terminated by a #\newline.

(defun |ReadLineIntoString| (string &optional (instream *standard-input*) 
                                              (flags nil) )

  (when (consp flags) (rplaca flags nil) (rplacd flags nil))

  (let ((n (length string))
        (i 0)
        (c (read-char instream nil nil)) )
    
       (loop
         (cond 
           ((null c)
              (when (consp flags) (rplaca flags 't))
              (return (if (= i 0) nil i)) )
           ((char= c #\Newline)
              (when (consp flags) (rplacd flags 't))
              (return i) )
           ((= i n)
              (unread-char c instream)
              (return 't) ))

         (setf (char string i) c)
         (setq i (+ i 1))
         (setq c (read-char instream nil nil)) )))
   

;;; Similar to ReadLineIntoString but reads from a ByteFile.
(defun |ByteFileReadLineIntoString| (string instream &optional (flags nil))

  (when (consp flags) (rplaca flags nil) (rplacd flags nil))

  (let ((n (length string))
        (i 0)
        (b nil)
        (c nil) )
    
       (loop
         (when (= i n) (return 't) )
         (setq b (read-byte instream nil nil)) 
         (when (null b)
           (when (consp flags) (rplaca flags 't))
           (return i) )

         (setq c (code-char b))
         (when (char= c #\Newline)
           (when (consp flags) (rplacd flags 't))
           (return i) )

         (setf (char string i) c)
         (setq i (+ i 1)) )))

(defun |ReadBytesIntoVector| 
           (vector &optional (instream *standard-input*) (flags nil) )

  (when (consp flags) (rplaca flags nil) (rplacd flags nil))

  (let ((n (length vector))
        (i 0)
        (b nil) )
    
       (loop
         (when (= i n) (return 't))
         (setq b (read-byte instream nil nil))
         (when (null b)
           (when (consp flags) (rplaca flags 't))
           (return i) )

         (setf (aref vector i) b)
         (setq i (+ i 1)) )))


(defun |InputStream?| (stream)
   (input-stream-p stream) )

(defun |OutputStream?| (stream)
   (output-stream-p stream) )

;;; Whether the position is a record number or character number is 
;;; implementation specific.  In Common Lisp it is a character number.

(defun |StreamGetPosition| (stream)
  (file-position stream) )

(defun |StreamSetPosition| (stream pos)
  (file-position stream pos))

(defun |StreamSize| (stream)
  (file-length stream))

(defmacro |WithOpenStream| (var stream-form body)
  `(with-open-stream (,var ,stream-form) ,body) )

;;; Copy up to n characters or eof.
;;; Return number of characters actually copied
(defun |StreamCopyChars| (instream outstream n)
  (do ((i 0 (+ i 1))
       (c (read-char instream nil nil) (read-char instream nil nil)) )
      ((or (null c) (= i n))  (finish-output outstream) i)

      (write-char c outstream) ))

(defun |StreamCopyBytes| (instream outstream n)
  (do ((i 0 (+ i 1))
       (b (read-byte instream nil nil) (read-byte instream nil nil)) )
      ((or (null b) (= i n))  (finish-output outstream) i)

      (write-byte b outstream) ))

(defun |StreamEnd?| (instream)
  (null (peek-char nil instream nil nil)) )

(defun |StreamFlush| (&optional (outstream *standard-output*))
  (finish-output outstream) )

(defun |StreamClose| (stream)
  (close stream) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;  Types
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Functions for manipulating values of type Xxxx are prefixed with Xxxx.
;;; E.g., CsetUnion
;;; Values of type Xxxx are suffixed with Xxxx.
;;; E.g., AlphaCset
;;; The primary function for creating object of this type is named Xxxx.
;;; The type-testing predicate is Xxxx?

;;; xx    := Xxxx(args)
;;; val   := XxxxGet(xx, key)  or  XxxxGet(xx, key, default)
;;; val   := XxxxSet(xx, key, val)
;;; val   := XxxxUnset(xx, key)
;;;
;;; xx    := XxxxRemove(val, xx)    XxxxRemoveQ
;;; truth := XxxxMember?(val, xx)   XxxxMemberQ?
;;; xx    := XxxxUnion(xx1, xx2)
;;;
;;; The suffix "Q" means the test involved is "EQ".  "N" between the
;;; the type name and the function name proper means the function is
;;; non-copying (destructive).

;;;
;;; Pathnames
;;;

(defvar |TempFileDirectory| (pathname-directory "/tmp/"))
(defvar |LispFileType| "lisp")
(defvar |FaslFileType| "bbin")

(defun |Pathname| (name &optional (type nil) (dir 'none))
  (if (equal dir 'none)
      (make-pathname :name name :type type :defaults name) 
      (make-pathname :directory dir :name name :type type) ))

(defun |ToPathname| (string)
  (pathname string) )

;;; System-wide unique name on each call.
(defvar *new-pathname-counter* 1)

(defun |PathnameDirectory| (path)
  (pathname-directory path) )

(defun |PathnameName| (path)
  (pathname-name path) )

(defun |PathnameType| (path) 
  (pathname-type path) )


(defun |PathnameWithType| (path type)
  (make-pathname :type type :defaults path) )

(defun |PathnameWithoutType| (path)
  (make-pathname :type nil :defaults path) )


(defun |PathnameWithDirectory| (path dir)
  (make-pathname :directory dir :defaults path) )

(defun |PathnameWithoutDirectory| (path)
  (make-pathname :directory nil :defaults path) )


(defun |PathnameString| (path)
  (namestring path) )

(defun |PathnameToUsualCase| (path)
  (pathname (|StringLowerCase| (namestring path))) )


;; Lucid 1.01 specific  -- uses representation of directories.
(defun |PathnameAbsolute?| (path)
  (let ((dir (pathname-directory path)))
       (not (and (consp dir) (or
           (eq (car dir) :current) 
           (eq (car dir) :relative) ))) ))

;; Lucid 1.01 specific  -- uses representation of directories.
(defun |PathnameWithinDirectory| (dir relpath)
  (if (|PathnameAbsolute?| relpath)
    (|PlainError| "The path " relpath " cannot be used within directory " dir)
    (make-pathname 
       :directory (append dir (cdr (pathname-directory relpath)))
       :defaults  relpath )))

;; Unix specific -- uses unix file syntax.
(defun |PathnameDirectoryOfDirectoryPathname| (dirpath)
  (pathname-directory 
    (concatenate 'string  (namestring dirpath) "/junk.bar") ))

;; Unix specific -- uses environment variables.
(defun |PathnameWithinOsEnvVar| (varname relpath)
  (let ((envstr (|OsEnvGet| varname)))
    (parse-namestring (concatenate 'string envstr "/" relpath)) ))

;;;
;;; Symbols
;;;


;;!! Worry about packages a later day.  
;;!! For now, the responsibility of setting *package* is on the caller.
(defun |MakeSymbol| (str)
  (let ((a (intern str))) a) ) ; Return only 1 value

(defmacro |Symbol?| (ob)
  `(and ,ob (symbolp ,ob)) )

(defmacro |SymbolString| (sym)
  `(string ,sym) )

;;;
;;; Bits
;;;
(defmacro  |Bit| (x)
  (cond 
   ((eq x 1) 1) 
   ((eq x 0) 0) 
   (x 1) 
   (t 0)))

(defun |Bit?| (x) 
  (or (eql x 1) (eql x 0)) )

(defvar |TrueBit|  1)
(defvar |FalseBit| 0)

(defmacro  |BitOn?|   (b) `(eq ,b 1))

(defmacro |BitOr| (x y)
  `(bit-ior ,x ,y) )

;;;
;;; General Sequences
;;;
;;  ELT and SETELT work on these.

;; Removed because it clashed with size in vmlisp.lisp
;; (defun SIZE (x)  ;; #x in boot generates (SIZE x)
;;  (length x))

;;;
;;; Vectors
;;;
(defun |FullVector| (size &optional (init nil))
  (make-array 
   (list size)
   :element-type 't
   :initial-element init ))

(defun |Vector?| (x)
   (vectorp x) )

;;;
;;; Bit Vectors
;;;

;; Common Lisp simple bit vectors

(defun |FullBvec| (size &optional (init 0))
  (make-array 
   (list size)
   :element-type 'bit
   :initial-element init ))

;;;
;;; Characters
;;;

;;(defun |char| (x) 
;;  (char (string x) 0) )

(defmacro |Char| (x) 
  `(char (string ,x) 0) )

(defmacro |Char?| (c) 
  `(characterp ,c) )
  ;; (or (characterp a) 
  ;;     (and (symbolp a) (= (length (symbol-name a)) 1))))


(defmacro |CharCode| (c)
  `(char-code ,c) )

(defmacro |CharGreater?| (c1 c2) 
  `(char> ,c1 ,c2) )

(defun |CharDigit?| (x)
  (or 
   (and (characterp x) (digit-char-p x))
   (and (stringp x) (= (length x) 1) (digit-char-p (char x 0)))
   (and (symbolp x) (|CharDigit?| (string x))) ))

(defvar |SpaceChar|   #\Space)
(defvar |NewlineChar| #\Newline)

;;;
;;; Character Sets
;;;

(defun |Cset| (str) 
  (let 
   ((cset (make-array
           (list char-code-limit)
           :element-type 'bit
           :initial-element 0 ))
    (len (length str)) )
   
   (do ((i 0 (+ 1 i)))
       ((= i len))
       (setf (sbit cset (char-code (char str i))) 1) )
   cset ))

(defun |CsetMember?| (c cset)
  (eql 1 (sbit cset (char-code c))) )

(defun |CsetUnion| (cset1 cset2)
  (bit-ior cset1 cset2) )

(defun |CsetComplement| (cset)
  (bit-not cset) )

(defun |CsetString| (cset)
  (let 
   ((chars '())
    (len (length cset)))
   (do ((i 0 (+ 1 i)))
       ((= i len))
       (if (eql 1 (sbit cset i)) (push (string (int-char i)) chars)) )
   (apply #'concatenate (cons 'string (nreverse chars))) ))

(defvar |NumericCset|      (|Cset| "0123456789") )
(defvar |LowerCaseCset|    (|Cset| "abcdefghijklmnopqrstuvwxyz") )
(defvar |UpperCaseCset|    (|Cset| "ABCDEFGHIJKLMNOPQRSTUVWXYZ") )
(defvar |AlphaCset|        (|CsetUnion| |LowerCaseCset| |UpperCaseCset|))
(defvar |AlphaNumericCset| (|CsetUnion| |AlphaCset| |NumericCset|) )

;;;
;;; Character Strings 
;;;

;;  Common Lisp simple strings
;;  ELT and SETELT work on these.


(defun |FullString| (size &optional (init #\Space))
  (make-array
   (list size)
   :element-type 'string-char
   :initial-element init ))

(defun |ToString| (ob)
  (string ob) )

(defun |StringImage| (ob)
  (format nil "~a" ob) )

(defun |String?| (ob)
  (stringp ob) )

(defmacro |StringGetCode| (str ix)
  `(char-code (char ,str ,ix)) )

(defun |StringConcat| (&rest l)
  (progn
   (setq l (mapcar #'string l))
   (apply #'concatenate 'string l) ))

(defun |StringFromTo| (string from to)
  (subseq string from (+ to 1)) )

(defun |StringFromToEnd| (string from)
  (subseq string from) )

(defun |StringFromLong| (string from len)
  (subseq string from (+ from len)) )

(defun |StringPrefix?| (pref string)
  (let ((mm (mismatch pref string)))
       (or (not mm) (eql mm (length pref))) ))

(defun |StringUpperCase| (l)
  (cond ((stringp l) (string-upcase l))
        ((symbolp l) (intern (string-upcase (symbol-name l))))
        ((characterp l) (char-upcase l))
        ((atom l) l)
        (t (mapcar #'|StringUpperCase| l)) ))

(defun |StringLowerCase| (l)
  (cond ((stringp l) (string-downcase l))
        ((symbolp l) (intern (string-downcase (symbol-name l))))
        ((characterp l) (char-downcase L))
        ((atom l) l)
        (t (mapcar #'|StringLowerCase| l)) ))

(defun |StringGreater?| (s1 s2)
  (string> s1 s2) )

(defun |StringToInteger| (s)
  (read-from-string s) )

(defun |StringToFloat| (s)
  (read-from-string s) )

(defun |StringLength| (s)
  (length s) )

;;;
;;; Numbers
;;;



(defmacro |Number?|       (x) `(numberp ,x))
(defmacro |Integer?|      (x) `(integerp ,x))
(defmacro |Float?|        (x) `(floatp ,x))

(defmacro |Odd?|     (n)   `(oddp ,n))
(defmacro |Remainder|(a b) `(rem ,a ,b))

(defmacro |DoublePrecision| (x) `(coerce ,x 'double-precision))

(defmacro |Abs|   (x) `(abs  ,x))
(defmacro |Min|   (x &rest yz) `(min ,x ,@yz))
(defmacro |Max|   (x &rest yz) `(max ,x ,@yz))

(defmacro |Exp|   (x) `(exp ,x))
(defmacro |Ln|    (x) `(log ,x))
(defmacro |Log10| (x) `(log ,x 10))
(defmacro |Sin|   (x) `(sin ,x))
(defmacro |Cos|   (x) `(cos ,x))
(defmacro |Tan|   (x) `(tan ,x))
(defmacro |Cotan| (x) `(/ 1.0 (tan ,x)))
(defmacro |Arctan|(x) `(atan ,x))

;;;
;;; Pairs
;;;

(defmacro |Pair?| (x) `(consp ,x))

(defmacro |car|    (x) `(car    ,x))
(defmacro |cdr|    (x) `(cdr    ,x))

\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
