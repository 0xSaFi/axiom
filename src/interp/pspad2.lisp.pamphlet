\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp pspad2.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=
(IN-PACKAGE "BOOT" )

;--======================================================================
;--                Constructor Transformation Functions
;--======================================================================
;formatDeftranForm(form,tlist) ==
;  [ttype,:atypeList] := tlist
;  if form is [":",f,t] then
;    form := f
;    ttype := t
;  if form is ['elt,a,b] then    ----> a.b ====> apply(b,a)
;    form :=
;      isTypeProbably? a =>
;        atypeList := REVERSE atypeList
;        ["$$", b, a]
;      ["apply",a, b]
;  op   := KAR form
;  argl := KDR form
;  if or/[t for t in atypeList] then
;    form := [op,:[(t => [":",a,t]; a) for a in argl for t in atypeList]]
;  if ttype then form := [":",form,ttype]
;  form

(DEFUN |formatDeftranForm| (|form| |tlist|)
  (PROG (|f| |t| |ttype| |ISTMP#1| |a| |ISTMP#2| |b| |atypeList| |op|
             |argl|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |ttype| (CAR |tlist|))
             (SPADLET |atypeList| (CDR |tlist|))
             (COND
               ((AND (PAIRP |form|) (EQ (QCAR |form|) '|:|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |form|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |f| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (PAIRP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (PROGN
                                     (SPADLET |t| (QCAR |ISTMP#2|))
                                     'T))))))
                (SPADLET |form| |f|) (SPADLET |ttype| |t|)))
             (COND
               ((AND (PAIRP |form|) (EQ (QCAR |form|) '|elt|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |form|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |a| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (PAIRP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (PROGN
                                     (SPADLET |b| (QCAR |ISTMP#2|))
                                     'T))))))
                (SPADLET |form|
                         (COND
                           ((|isTypeProbably?| |a|)
                            (SPADLET |atypeList| (REVERSE |atypeList|))
                            (CONS '$$ (CONS |b| (CONS |a| NIL))))
                           ('T
                            (CONS '|apply| (CONS |a| (CONS |b| NIL))))))))
             (SPADLET |op| (KAR |form|))
             (SPADLET |argl| (KDR |form|))
             (COND
               ((PROG (G166097)
                  (SPADLET G166097 NIL)
                  (RETURN
                    (DO ((G166103 NIL G166097)
                         (G166104 |atypeList| (CDR G166104))
                         (|t| NIL))
                        ((OR G166103 (ATOM G166104)
                             (PROGN (SETQ |t| (CAR G166104)) NIL))
                         G166097)
                      (SEQ (EXIT (SETQ G166097 (OR G166097 |t|)))))))
                (SPADLET |form|
                         (CONS |op|
                               (PROG (G166116)
                                 (SPADLET G166116 NIL)
                                 (RETURN
                                   (DO
                                    ((G166122 |argl| (CDR G166122))
                                     (|a| NIL)
                                     (G166123 |atypeList|
                                      (CDR G166123))
                                     (|t| NIL))
                                    ((OR (ATOM G166122)
                                      (PROGN
                                        (SETQ |a| (CAR G166122))
                                        NIL)
                                      (ATOM G166123)
                                      (PROGN
                                        (SETQ |t| (CAR G166123))
                                        NIL))
                                     (NREVERSE0 G166116))
                                     (SEQ
                                      (EXIT
                                       (SETQ G166116
                                        (CONS
                                         (COND
                                           (|t|
                                            (CONS '|:|
                                             (CONS |a| (CONS |t| NIL))))
                                           ('T |a|))
                                         G166116)))))))))))
             (COND
               (|ttype| (SPADLET |form|
                                 (CONS '|:|
                                       (CONS |form| (CONS |ttype| NIL))))))
             |form|)))))

;formatDeftran(u,SEQflag) ==
;  u is ['Join,:x] => formatDeftranJoin(u,SEQflag)
;  u is ['CATEGORY,kind,:l,x] => formatDeftran(['with,['SEQ,:l,['exit,n,x]]],SEQflag)
;  u is ['CAPSULE,:l,x] => formatDeftranCapsule(l,x,SEQflag)
;  u is [op,:.] and MEMQ(op,'(rep per)) => formatDeftranRepper(u,SEQflag)
;  u is [op,:.] and MEMQ(op,'(_: _:_: _pretend _@)) =>
;    formatDeftranColon(u,SEQflag)
;  u is ['PROGN,:l,x] => formatDeftran(['SEQ,:l,['exit,1,x]],SEQflag)
;  u is ['SEQ,:l,[.,n,x]] =>
;    v := [:l,x]
;    a := "APPEND"/[formatDeftranSEQ(x,true) for x in l]
;    b := formatDeftranSEQ(x,false)
;    if b is [:.,c] and c = '(void) then b := DROP(-1, b)
;    [:m,y] := [:a,:b]
;    ['SEQ,:m,['exit,n,y]]
;--  u is ['not,arg] and (op := LASSOC(KAR arg,'((_= . _^_=) (_< . _>_=)))) =>
;--    formatDeftran([op,:CDR arg],nil)
;  u is ["^",a] => formatDeftran(['not,a],SEQflag)
;  u is ["exquo",a,b] => formatDeftran(['xquo,a,b],SEQflag)
;  u is ['IF,a,b,c] =>
;    a := formatDeftran(a,nil)
;    b := formatDeftran(b,nil)
;    c := formatDeftran(c,nil)
;    null SEQflag and $insideDEF =>
;      [:y,last] := formatDeftranIf(a,b,c)
;      ['SEQ,:y,['exit,1,last]]
;    ['IF,a,b,c]
;  u is ['Union,:argl] =>
;    ['Union,:[x for a in argl
;      | x := (STRINGP a => [":",INTERN a,'Branch]; formatDeftran(a,nil))]]
;  u is [op,:itl,body] and MEMQ(op,'(REPEAT COLLECT)) and
;    ([nitl,:nbody] := formatDeftranREPEAT(itl,body)) =>
;      formatDeftran([op,:nitl,nbody],SEQflag)
;  u is [":",a,b] => [":",formatDeftran(a,nil),formatDeftran(markMacroTran(b),nil)]
;  u is ["DEF",:.] => formatCapsuleFunction(u)
;  u is [op,:argl]=>[formatDeftran(op,nil),:[formatDeftran(x,nil) for x in argl]]
;  u = 'nil => 'empty
;  u

(DEFUN |formatDeftran| (|u| |SEQflag|)
  (PROG (|kind| |ISTMP#4| |n| |ISTMP#5| |l| |v| |m| |ISTMP#3| |c|
                |LETTMP#2| |last| |y| |x| |body| |itl| |LETTMP#1|
                |nitl| |nbody| |ISTMP#1| |a| |ISTMP#2| |b| |op| |argl|)
  (declare (special |$insideDEF|))
    (RETURN
      (SEQ (COND
             ((AND (PAIRP |u|) (EQ (QCAR |u|) '|Join|)
                   (PROGN (SPADLET |x| (QCDR |u|)) 'T))
              (|formatDeftranJoin| |u| |SEQflag|))
             ((AND (PAIRP |u|) (EQ (QCAR |u|) 'CATEGORY)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |u|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |kind| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (PAIRP |ISTMP#2|)
                                 (PROGN
                                   (SPADLET |ISTMP#3|
                                    (REVERSE |ISTMP#2|))
                                   'T)
                                 (PAIRP |ISTMP#3|)
                                 (PROGN
                                   (SPADLET |x| (QCAR |ISTMP#3|))
                                   (SPADLET |l| (QCDR |ISTMP#3|))
                                   'T)
                                 (PROGN
                                   (SPADLET |l| (NREVERSE |l|))
                                   'T))))))
              (|formatDeftran|
                  (CONS '|with|
                        (CONS (CONS 'SEQ
                                    (APPEND |l|
                                     (CONS
                                      (CONS '|exit|
                                       (CONS |n| (CONS |x| NIL)))
                                      NIL)))
                              NIL))
                  |SEQflag|))
             ((AND (PAIRP |u|) (EQ (QCAR |u|) 'CAPSULE)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |u|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |ISTMP#2| (REVERSE |ISTMP#1|))
                            'T)
                          (PAIRP |ISTMP#2|)
                          (PROGN
                            (SPADLET |x| (QCAR |ISTMP#2|))
                            (SPADLET |l| (QCDR |ISTMP#2|))
                            'T)
                          (PROGN (SPADLET |l| (NREVERSE |l|)) 'T))))
              (|formatDeftranCapsule| |l| |x| |SEQflag|))
             ((AND (PAIRP |u|) (PROGN (SPADLET |op| (QCAR |u|)) 'T)
                   (MEMQ |op| '(|rep| |per|)))
              (|formatDeftranRepper| |u| |SEQflag|))
             ((AND (PAIRP |u|) (PROGN (SPADLET |op| (QCAR |u|)) 'T)
                   (MEMQ |op| '(|:| |::| |pretend| @)))
              (|formatDeftranColon| |u| |SEQflag|))
             ((AND (PAIRP |u|) (EQ (QCAR |u|) 'PROGN)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |u|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |ISTMP#2| (REVERSE |ISTMP#1|))
                            'T)
                          (PAIRP |ISTMP#2|)
                          (PROGN
                            (SPADLET |x| (QCAR |ISTMP#2|))
                            (SPADLET |l| (QCDR |ISTMP#2|))
                            'T)
                          (PROGN (SPADLET |l| (NREVERSE |l|)) 'T))))
              (|formatDeftran|
                  (CONS 'SEQ
                        (APPEND |l|
                                (CONS (CONS '|exit|
                                       (CONS 1 (CONS |x| NIL)))
                                      NIL)))
                  |SEQflag|))
             ((AND (PAIRP |u|) (EQ (QCAR |u|) 'SEQ)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |u|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |ISTMP#2| (REVERSE |ISTMP#1|))
                            'T)
                          (PAIRP |ISTMP#2|)
                          (PROGN
                            (SPADLET |ISTMP#3| (QCAR |ISTMP#2|))
                            (AND (PAIRP |ISTMP#3|)
                                 (PROGN
                                   (SPADLET |ISTMP#4| (QCDR |ISTMP#3|))
                                   (AND (PAIRP |ISTMP#4|)
                                    (PROGN
                                      (SPADLET |n| (QCAR |ISTMP#4|))
                                      (SPADLET |ISTMP#5|
                                       (QCDR |ISTMP#4|))
                                      (AND (PAIRP |ISTMP#5|)
                                       (EQ (QCDR |ISTMP#5|) NIL)
                                       (PROGN
                                         (SPADLET |x| (QCAR |ISTMP#5|))
                                         'T)))))))
                          (PROGN (SPADLET |l| (QCDR |ISTMP#2|)) 'T)
                          (PROGN (SPADLET |l| (NREVERSE |l|)) 'T))))
              (SPADLET |v| (APPEND |l| (CONS |x| NIL)))
              (SPADLET |a|
                       (PROG (G166380)
                         (SPADLET G166380 NIL)
                         (RETURN
                           (DO ((G166385 |l| (CDR G166385))
                                (|x| NIL))
                               ((OR (ATOM G166385)
                                    (PROGN
                                      (SETQ |x| (CAR G166385))
                                      NIL))
                                G166380)
                             (SEQ (EXIT (SETQ G166380
                                         (APPEND G166380
                                          (|formatDeftranSEQ| |x| 'T)))))))))
              (SPADLET |b| (|formatDeftranSEQ| |x| NIL))
              (COND
                ((AND (PAIRP |b|)
                      (PROGN (SPADLET |ISTMP#1| (REVERSE |b|)) 'T)
                      (PAIRP |ISTMP#1|)
                      (PROGN (SPADLET |c| (QCAR |ISTMP#1|)) 'T)
                      (BOOT-EQUAL |c| '(|void|)))
                 (SPADLET |b| (DROP (SPADDIFFERENCE 1) |b|))))
              (SPADLET |LETTMP#1| (APPEND |a| |b|))
              (SPADLET |LETTMP#2| (REVERSE |LETTMP#1|))
              (SPADLET |y| (CAR |LETTMP#2|))
              (SPADLET |m| (NREVERSE (CDR |LETTMP#2|)))
              (CONS 'SEQ
                    (APPEND |m|
                            (CONS (CONS '|exit|
                                        (CONS |n| (CONS |y| NIL)))
                                  NIL))))
             ((AND (PAIRP |u|) (EQ (QCAR |u|) '^)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |u|))
                     (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) 'T))))
              (|formatDeftran| (CONS '|not| (CONS |a| NIL)) |SEQflag|))
             ((AND (PAIRP |u|) (EQ (QCAR |u|) '|exquo|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |u|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |a| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (PAIRP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |b| (QCAR |ISTMP#2|))
                                   'T))))))
              (|formatDeftran| (CONS '|xquo| (CONS |a| (CONS |b| NIL)))
                  |SEQflag|))
             ((AND (PAIRP |u|) (EQ (QCAR |u|) 'IF)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |u|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |a| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (PAIRP |ISTMP#2|)
                                 (PROGN
                                   (SPADLET |b| (QCAR |ISTMP#2|))
                                   (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                                   (AND (PAIRP |ISTMP#3|)
                                    (EQ (QCDR |ISTMP#3|) NIL)
                                    (PROGN
                                      (SPADLET |c| (QCAR |ISTMP#3|))
                                      'T))))))))
              (SPADLET |a| (|formatDeftran| |a| NIL))
              (SPADLET |b| (|formatDeftran| |b| NIL))
              (SPADLET |c| (|formatDeftran| |c| NIL))
              (COND
                ((AND (NULL |SEQflag|) |$insideDEF|)
                 (SPADLET |LETTMP#1| (|formatDeftranIf| |a| |b| |c|))
                 (SPADLET |LETTMP#2| (REVERSE |LETTMP#1|))
                 (SPADLET |last| (CAR |LETTMP#2|))
                 (SPADLET |y| (NREVERSE (CDR |LETTMP#2|)))
                 (CONS 'SEQ
                       (APPEND |y|
                               (CONS (CONS '|exit|
                                      (CONS 1 (CONS |last| NIL)))
                                     NIL))))
                ('T (CONS 'IF (CONS |a| (CONS |b| (CONS |c| NIL)))))))
             ((AND (PAIRP |u|) (EQ (QCAR |u|) '|Union|)
                   (PROGN (SPADLET |argl| (QCDR |u|)) 'T))
              (CONS '|Union|
                    (PROG (G166396)
                      (SPADLET G166396 NIL)
                      (RETURN
                        (DO ((G166402 |argl| (CDR G166402))
                             (|a| NIL))
                            ((OR (ATOM G166402)
                                 (PROGN
                                   (SETQ |a| (CAR G166402))
                                   NIL))
                             (NREVERSE0 G166396))
                          (SEQ (EXIT (COND
                                       ((SPADLET |x|
                                         (COND
                                           ((STRINGP |a|)
                                            (CONS '|:|
                                             (CONS (INTERN |a|)
                                              (CONS '|Branch| NIL))))
                                           ('T
                                            (|formatDeftran| |a| NIL))))
                                        (SETQ G166396
                                         (CONS |x| G166396)))))))))))
             ((AND (PAIRP |u|)
                   (PROGN
                     (SPADLET |op| (QCAR |u|))
                     (SPADLET |ISTMP#1| (QCDR |u|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |ISTMP#2| (REVERSE |ISTMP#1|))
                            'T)
                          (PAIRP |ISTMP#2|)
                          (PROGN
                            (SPADLET |body| (QCAR |ISTMP#2|))
                            (SPADLET |itl| (QCDR |ISTMP#2|))
                            'T)
                          (PROGN (SPADLET |itl| (NREVERSE |itl|)) 'T)))
                   (MEMQ |op| '(REPEAT COLLECT))
                   (PROGN
                     (SPADLET |LETTMP#1|
                              (|formatDeftranREPEAT| |itl| |body|))
                     (SPADLET |nitl| (CAR |LETTMP#1|))
                     (SPADLET |nbody| (CDR |LETTMP#1|))
                     |LETTMP#1|))
              (|formatDeftran|
                  (CONS |op| (APPEND |nitl| (CONS |nbody| NIL)))
                  |SEQflag|))
             ((AND (PAIRP |u|) (EQ (QCAR |u|) '|:|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |u|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |a| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (PAIRP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |b| (QCAR |ISTMP#2|))
                                   'T))))))
              (CONS '|:|
                    (CONS (|formatDeftran| |a| NIL)
                          (CONS (|formatDeftran| (|markMacroTran| |b|)
                                    NIL)
                                NIL))))
             ((AND (PAIRP |u|) (EQ (QCAR |u|) 'DEF))
              (|formatCapsuleFunction| |u|))
             ((AND (PAIRP |u|)
                   (PROGN
                     (SPADLET |op| (QCAR |u|))
                     (SPADLET |argl| (QCDR |u|))
                     'T))
              (CONS (|formatDeftran| |op| NIL)
                    (PROG (G166412)
                      (SPADLET G166412 NIL)
                      (RETURN
                        (DO ((G166417 |argl| (CDR G166417))
                             (|x| NIL))
                            ((OR (ATOM G166417)
                                 (PROGN
                                   (SETQ |x| (CAR G166417))
                                   NIL))
                             (NREVERSE0 G166412))
                          (SEQ (EXIT (SETQ G166412
                                      (CONS (|formatDeftran| |x| NIL)
                                       G166412)))))))))
             ((BOOT-EQUAL |u| '|nil|) '|empty|)
             ('T |u|))))))

;formatCapsuleFunction ["DEF",form,tlist,b,body] ==
;  $insideDEF : local := true
;  ["DEF", formatDeftran(form,nil),tlist,b,formatDeftran(body,nil)]

(DEFUN |formatCapsuleFunction| (G166505)
  (PROG (|$insideDEF| |form| |tlist| |b| |body|)
    (DECLARE (SPECIAL |$insideDEF|))
    (RETURN
      (PROGN
        (COND ((EQ (CAR G166505) 'DEF) (CAR G166505)))
        (SPADLET |form| (CADR G166505))
        (SPADLET |tlist| (CADDR G166505))
        (SPADLET |b| (CADDDR G166505))
        (SPADLET |body| (CAR (CDDDDR G166505)))
        (SPADLET |$insideDEF| 'T)
        (CONS 'DEF
              (CONS (|formatDeftran| |form| NIL)
                    (CONS |tlist|
                          (CONS |b|
                                (CONS (|formatDeftran| |body| NIL) NIL)))))))))

;formatDeftranCapsule(l,x,SEQflag) ==
;  $insideCAPSULE: local := true
;  formatDeftran(['SEQ,:l,['exit,1,x]],SEQflag)

(DEFUN |formatDeftranCapsule| (|l| |x| |SEQflag|)
  (PROG (|$insideCAPSULE|)
    (DECLARE (SPECIAL |$insideCAPSULE|))
    (RETURN
      (PROGN
        (SPADLET |$insideCAPSULE| 'T)
        (|formatDeftran|
            (CONS 'SEQ
                  (APPEND |l|
                          (CONS (CONS '|exit| (CONS 1 (CONS |x| NIL)))
                                NIL)))
            |SEQflag|)))))

;formatDeftranRepper([op,a],SEQflag) ==
;    a is [op1,b] and MEMQ(op1,'(rep per)) =>
;        op = op1 => formatDeftran(a,SEQflag)
;        formatDeftran(b,SEQflag)
;    a is ["::",b,t] =>
;      b := formatDeftran(b,SEQflag)
;      t := formatDeftran(t,SEQflag)
;      a := ["::",b,t]
;      op = 'per and t = "$" or op = 'rep and t = 'Rep => a
;      [op,a]
;    a is ['SEQ,:r] => ['SEQ,:[formatSeqRepper(op,x) for x in r]]
;    a is ['IF,p,b,c] =>
;      formatDeftran(['IF,p,[op,b],[op, c]], SEQflag)
;    a is ['LET,a,b] => formatDeftran(['LET,a,[op,b]],SEQflag)
;    a is ['not,[op,a,b]] and (op1 := LASSOC(op,$pspadRelationAlist)) =>
;      formatDeftran [op1,a,b]
;    a is ['return,n,r] =>
;      MEMQ(opOf r,'(true false)) => a
;      ['return,n,[op,formatDeftran(r,SEQflag)]]
;    a is ['error,:.] => a
;    [op,formatDeftran(a,SEQflag)]

(DEFUN |formatDeftranRepper| (G166678 |SEQflag|)
  (PROG (|t| |p| |c| |op| |ISTMP#3| |a| |ISTMP#4| |b| |op1| |ISTMP#1|
             |n| |ISTMP#2| |r|)
  (declare (special |$pspadRelationAlist|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |op| (CAR G166678))
             (SPADLET |a| (CADR G166678))
             (COND
               ((AND (PAIRP |a|)
                     (PROGN
                       (SPADLET |op1| (QCAR |a|))
                       (SPADLET |ISTMP#1| (QCDR |a|))
                       (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN (SPADLET |b| (QCAR |ISTMP#1|)) 'T)))
                     (MEMQ |op1| '(|rep| |per|)))
                (COND
                  ((BOOT-EQUAL |op| |op1|)
                   (|formatDeftran| |a| |SEQflag|))
                  ('T (|formatDeftran| |b| |SEQflag|))))
               ((AND (PAIRP |a|) (EQ (QCAR |a|) '|::|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |a|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |b| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (PAIRP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (PROGN
                                     (SPADLET |t| (QCAR |ISTMP#2|))
                                     'T))))))
                (SPADLET |b| (|formatDeftran| |b| |SEQflag|))
                (SPADLET |t| (|formatDeftran| |t| |SEQflag|))
                (SPADLET |a| (CONS '|::| (CONS |b| (CONS |t| NIL))))
                (COND
                  ((OR (AND (BOOT-EQUAL |op| '|per|)
                            (BOOT-EQUAL |t| '$))
                       (AND (BOOT-EQUAL |op| '|rep|)
                            (BOOT-EQUAL |t| '|Rep|)))
                   |a|)
                  ('T (CONS |op| (CONS |a| NIL)))))
               ((AND (PAIRP |a|) (EQ (QCAR |a|) 'SEQ)
                     (PROGN (SPADLET |r| (QCDR |a|)) 'T))
                (CONS 'SEQ
                      (PROG (G166741)
                        (SPADLET G166741 NIL)
                        (RETURN
                          (DO ((G166746 |r| (CDR G166746))
                               (|x| NIL))
                              ((OR (ATOM G166746)
                                   (PROGN
                                     (SETQ |x| (CAR G166746))
                                     NIL))
                               (NREVERSE0 G166741))
                            (SEQ (EXIT (SETQ G166741
                                        (CONS
                                         (|formatSeqRepper| |op| |x|)
                                         G166741)))))))))
               ((AND (PAIRP |a|) (EQ (QCAR |a|) 'IF)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |a|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |p| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (PAIRP |ISTMP#2|)
                                   (PROGN
                                     (SPADLET |b| (QCAR |ISTMP#2|))
                                     (SPADLET |ISTMP#3|
                                      (QCDR |ISTMP#2|))
                                     (AND (PAIRP |ISTMP#3|)
                                      (EQ (QCDR |ISTMP#3|) NIL)
                                      (PROGN
                                        (SPADLET |c| (QCAR |ISTMP#3|))
                                        'T))))))))
                (|formatDeftran|
                    (CONS 'IF
                          (CONS |p|
                                (CONS (CONS |op| (CONS |b| NIL))
                                      (CONS (CONS |op| (CONS |c| NIL))
                                       NIL))))
                    |SEQflag|))
               ((AND (PAIRP |a|) (EQ (QCAR |a|) 'LET)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |a|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |a| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (PAIRP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (PROGN
                                     (SPADLET |b| (QCAR |ISTMP#2|))
                                     'T))))))
                (|formatDeftran|
                    (CONS 'LET
                          (CONS |a|
                                (CONS (CONS |op| (CONS |b| NIL)) NIL)))
                    |SEQflag|))
               ((AND (PAIRP |a|) (EQ (QCAR |a|) '|not|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |a|))
                       (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN
                              (SPADLET |ISTMP#2| (QCAR |ISTMP#1|))
                              (AND (PAIRP |ISTMP#2|)
                                   (PROGN
                                     (SPADLET |op| (QCAR |ISTMP#2|))
                                     (SPADLET |ISTMP#3|
                                      (QCDR |ISTMP#2|))
                                     (AND (PAIRP |ISTMP#3|)
                                      (PROGN
                                        (SPADLET |a| (QCAR |ISTMP#3|))
                                        (SPADLET |ISTMP#4|
                                         (QCDR |ISTMP#3|))
                                        (AND (PAIRP |ISTMP#4|)
                                         (EQ (QCDR |ISTMP#4|) NIL)
                                         (PROGN
                                           (SPADLET |b|
                                            (QCAR |ISTMP#4|))
                                           'T)))))))))
                     (SPADLET |op1|
                              (LASSOC |op| |$pspadRelationAlist|)))
                (|formatDeftran|
                    (CONS |op1| (CONS |a| (CONS |b| NIL)))))
               ((AND (PAIRP |a|) (EQ (QCAR |a|) '|return|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |a|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |n| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (PAIRP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (PROGN
                                     (SPADLET |r| (QCAR |ISTMP#2|))
                                     'T))))))
                (COND
                  ((MEMQ (|opOf| |r|) '(|true| |false|)) |a|)
                  ('T
                   (CONS '|return|
                         (CONS |n|
                               (CONS (CONS |op|
                                      (CONS
                                       (|formatDeftran| |r| |SEQflag|)
                                       NIL))
                                     NIL))))))
               ((AND (PAIRP |a|) (EQ (QCAR |a|) '|error|)) |a|)
               ('T
                (CONS |op| (CONS (|formatDeftran| |a| |SEQflag|) NIL)))))))))

;formatDeftranColon([op,a,t],SEQflag) ==  --op is one of :  ::  pretend  @
;    a := formatDeftran(a,SEQflag)
;    t := formatDeftran(t,SEQflag)
;    a is ["UNCOERCE",b] => b
;    a is [op1,b,t1] and t1 = t and MEMQ(op,'(_: _:_: _pretend _@)) =>
;      op1 = "pretend" or op = "pretend" => ["pretend",b,t]
;      null SEQflag and op1 = ":" or op = ":" => ["pretend",b,t]
;      a
;    a is [=op,b,t1] =>
;      t1 = t => a
;      [op,b,t]
;    t = "$" =>
;      a is ['rep,b] => b
;      a is ['per,b] => a
;      [op,a,t]
;    t = "Rep" =>
;      a is ['per,b] => b
;      a is ['rep,b] => a
;      [op,a,t]
;    [op,a,t]

(DEFUN |formatDeftranColon| (G166856 |SEQflag|)
  (PROG (|op| |a| |t| |op1| |ISTMP#2| |t1| |ISTMP#1| |b|)
    (RETURN
      (PROGN
        (SPADLET |op| (CAR G166856))
        (SPADLET |a| (CADR G166856))
        (SPADLET |t| (CADDR G166856))
        (SPADLET |a| (|formatDeftran| |a| |SEQflag|))
        (SPADLET |t| (|formatDeftran| |t| |SEQflag|))
        (COND
          ((AND (PAIRP |a|) (EQ (QCAR |a|) 'UNCOERCE)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |a|))
                  (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                       (PROGN (SPADLET |b| (QCAR |ISTMP#1|)) 'T))))
           |b|)
          ((AND (PAIRP |a|)
                (PROGN
                  (SPADLET |op1| (QCAR |a|))
                  (SPADLET |ISTMP#1| (QCDR |a|))
                  (AND (PAIRP |ISTMP#1|)
                       (PROGN
                         (SPADLET |b| (QCAR |ISTMP#1|))
                         (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (PAIRP |ISTMP#2|)
                              (EQ (QCDR |ISTMP#2|) NIL)
                              (PROGN
                                (SPADLET |t1| (QCAR |ISTMP#2|))
                                'T)))))
                (BOOT-EQUAL |t1| |t|)
                (MEMQ |op| '(|:| |::| |pretend| @)))
           (COND
             ((OR (BOOT-EQUAL |op1| '|pretend|)
                  (BOOT-EQUAL |op| '|pretend|))
              (CONS '|pretend| (CONS |b| (CONS |t| NIL))))
             ((OR (AND (NULL |SEQflag|) (BOOT-EQUAL |op1| '|:|))
                  (BOOT-EQUAL |op| '|:|))
              (CONS '|pretend| (CONS |b| (CONS |t| NIL))))
             ('T |a|)))
          ((AND (PAIRP |a|) (EQUAL (QCAR |a|) |op|)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |a|))
                  (AND (PAIRP |ISTMP#1|)
                       (PROGN
                         (SPADLET |b| (QCAR |ISTMP#1|))
                         (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (PAIRP |ISTMP#2|)
                              (EQ (QCDR |ISTMP#2|) NIL)
                              (PROGN
                                (SPADLET |t1| (QCAR |ISTMP#2|))
                                'T))))))
           (COND
             ((BOOT-EQUAL |t1| |t|) |a|)
             ('T (CONS |op| (CONS |b| (CONS |t| NIL))))))
          ((BOOT-EQUAL |t| '$)
           (COND
             ((AND (PAIRP |a|) (EQ (QCAR |a|) '|rep|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |a|))
                     (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (SPADLET |b| (QCAR |ISTMP#1|)) 'T))))
              |b|)
             ((AND (PAIRP |a|) (EQ (QCAR |a|) '|per|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |a|))
                     (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (SPADLET |b| (QCAR |ISTMP#1|)) 'T))))
              |a|)
             ('T (CONS |op| (CONS |a| (CONS |t| NIL))))))
          ((BOOT-EQUAL |t| '|Rep|)
           (COND
             ((AND (PAIRP |a|) (EQ (QCAR |a|) '|per|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |a|))
                     (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (SPADLET |b| (QCAR |ISTMP#1|)) 'T))))
              |b|)
             ((AND (PAIRP |a|) (EQ (QCAR |a|) '|rep|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |a|))
                     (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (SPADLET |b| (QCAR |ISTMP#1|)) 'T))))
              |a|)
             ('T (CONS |op| (CONS |a| (CONS |t| NIL))))))
          ('T (CONS |op| (CONS |a| (CONS |t| NIL)))))))))

;formatSeqRepper(op,x) ==
;  x is ['exit,n,y] => ['exit,n,[op,formatDeftran(y,nil)]]
;  x is ["=>",a,b] => ["=>",formatDeftran(a,nil),[op,formatDeftran(b,nil)]]
;  atom x => x
;  [formatSeqRepper(op,y) for y in x]

(DEFUN |formatSeqRepper| (|op| |x|)
  (PROG (|n| |y| |ISTMP#1| |a| |ISTMP#2| |b|)
    (RETURN
      (SEQ (COND
             ((AND (PAIRP |x|) (EQ (QCAR |x|) '|exit|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |x|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |n| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (PAIRP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |y| (QCAR |ISTMP#2|))
                                   'T))))))
              (CONS '|exit|
                    (CONS |n|
                          (CONS (CONS |op|
                                      (CONS (|formatDeftran| |y| NIL)
                                       NIL))
                                NIL))))
             ((AND (PAIRP |x|) (EQ (QCAR |x|) '=>)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |x|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |a| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (PAIRP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |b| (QCAR |ISTMP#2|))
                                   'T))))))
              (CONS '=>
                    (CONS (|formatDeftran| |a| NIL)
                          (CONS (CONS |op|
                                      (CONS (|formatDeftran| |b| NIL)
                                       NIL))
                                NIL))))
             ((ATOM |x|) |x|)
             ('T
              (PROG (G166966)
                (SPADLET G166966 NIL)
                (RETURN
                  (DO ((G166971 |x| (CDR G166971)) (|y| NIL))
                      ((OR (ATOM G166971)
                           (PROGN (SETQ |y| (CAR G166971)) NIL))
                       (NREVERSE0 G166966))
                    (SEQ (EXIT (SETQ G166966
                                     (CONS (|formatSeqRepper| |op| |y|)
                                      G166966)))))))))))))

;formatDeftranJoin(u,SEQflag) ==
;  ['Join,:cats,lastcat] := u
;  lastcat is ['CATEGORY,kind,:l,x] =>
;    cat :=
;      CDR cats => ['Join,:cats]
;      first cats
;    formatDeftran(['with,cat,['SEQ,:l,['exit,1,x]]],SEQflag)
;  u

(DEFUN |formatDeftranJoin| (|u| |SEQflag|)
  (PROG (|LETTMP#1| |lastcat| |cats| |ISTMP#1| |kind| |ISTMP#2|
            |ISTMP#3| |x| |l| |cat|)
    (RETURN
      (PROGN
        (SPADLET |LETTMP#1| (REVERSE (CDR |u|)))
        (SPADLET |lastcat| (CAR |LETTMP#1|))
        (SPADLET |cats| (NREVERSE (CDR |LETTMP#1|)))
        (COND
          ((AND (PAIRP |lastcat|) (EQ (QCAR |lastcat|) 'CATEGORY)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |lastcat|))
                  (AND (PAIRP |ISTMP#1|)
                       (PROGN
                         (SPADLET |kind| (QCAR |ISTMP#1|))
                         (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (PAIRP |ISTMP#2|)
                              (PROGN
                                (SPADLET |ISTMP#3| (REVERSE |ISTMP#2|))
                                'T)
                              (PAIRP |ISTMP#3|)
                              (PROGN
                                (SPADLET |x| (QCAR |ISTMP#3|))
                                (SPADLET |l| (QCDR |ISTMP#3|))
                                'T)
                              (PROGN (SPADLET |l| (NREVERSE |l|)) 'T))))))
           (SPADLET |cat|
                    (COND
                      ((CDR |cats|) (CONS '|Join| |cats|))
                      ('T (CAR |cats|))))
           (|formatDeftran|
               (CONS '|with|
                     (CONS |cat|
                           (CONS (CONS 'SEQ
                                       (APPEND |l|
                                        (CONS
                                         (CONS '|exit|
                                          (CONS 1 (CONS |x| NIL)))
                                         NIL)))
                                 NIL)))
               |SEQflag|))
          ('T |u|))))))

;formatENUM ['MyENUM, x] == format "'" and format x and format "'"

(DEFUN |formatENUM| (G167044)
  (PROG (|x|)
    (RETURN
      (PROGN
        (SPADLET |x| (CADR G167044))
        (AND (|format| '|'|) (|format| |x|) (|format| '|'|))))))

;formatDeftranREPEAT(itl,body) ==
;--do nothing unless "itl" contains UNTIL statements
;  u := [x for x in itl | x is ["UNTIL",p]] or return nil
;  nitl := SETDIFFERENCE(itl,u)
;  pred := MKPF([p for ['UNTIL,p] in u],'or)
;  cond := ['IF,pred,['leave,n,nil],'noBranch]
;  nbody :=
;    body is ['SEQ,:l,[.,n,x]] => ['SEQ,:l,x,['exit,n,cond]]
;    ['SEQ,body,['exit,n,cond]]
;  [nitl,:nbody]

(DEFUN |formatDeftranREPEAT| (|itl| |body|)
  (PROG (|u| |nitl| |p| |pred| |cond| |ISTMP#1| |ISTMP#2| |ISTMP#3|
             |ISTMP#4| |n| |ISTMP#5| |x| |l| |nbody|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |u|
                      (OR (PROG (G167111)
                            (SPADLET G167111 NIL)
                            (RETURN
                              (DO ((G167117 |itl| (CDR G167117))
                                   (|x| NIL))
                                  ((OR (ATOM G167117)
                                    (PROGN
                                      (SETQ |x| (CAR G167117))
                                      NIL))
                                   (NREVERSE0 G167111))
                                (SEQ (EXIT
                                      (COND
                                        ((AND (PAIRP |x|)
                                          (EQ (QCAR |x|) 'UNTIL)
                                          (PROGN
                                            (SPADLET |ISTMP#1|
                                             (QCDR |x|))
                                            (AND (PAIRP |ISTMP#1|)
                                             (EQ (QCDR |ISTMP#1|) NIL)
                                             (PROGN
                                               (SPADLET |p|
                                                (QCAR |ISTMP#1|))
                                               'T))))
                                         (SETQ G167111
                                          (CONS |x| G167111)))))))))
                          (RETURN NIL)))
             (SPADLET |nitl| (SETDIFFERENCE |itl| |u|))
             (SPADLET |pred|
                      (MKPF (PROG (G167128)
                              (SPADLET G167128 NIL)
                              (RETURN
                                (DO ((G167134 |u| (CDR G167134))
                                     (G167059 NIL))
                                    ((OR (ATOM G167134)
                                      (PROGN
                                        (SETQ G167059
                                         (CAR G167134))
                                        NIL)
                                      (PROGN
                                        (PROGN
                                          (SPADLET |p|
                                           (CADR G167059))
                                          G167059)
                                        NIL))
                                     (NREVERSE0 G167128))
                                  (SEQ (EXIT
                                        (SETQ G167128
                                         (CONS |p| G167128)))))))
                            '|or|))
             (SPADLET |cond|
                      (CONS 'IF
                            (CONS |pred|
                                  (CONS (CONS '|leave|
                                         (CONS |n| (CONS NIL NIL)))
                                        (CONS '|noBranch| NIL)))))
             (SPADLET |nbody|
                      (COND
                        ((AND (PAIRP |body|) (EQ (QCAR |body|) 'SEQ)
                              (PROGN
                                (SPADLET |ISTMP#1| (QCDR |body|))
                                (AND (PAIRP |ISTMP#1|)
                                     (PROGN
                                       (SPADLET |ISTMP#2|
                                        (REVERSE |ISTMP#1|))
                                       'T)
                                     (PAIRP |ISTMP#2|)
                                     (PROGN
                                       (SPADLET |ISTMP#3|
                                        (QCAR |ISTMP#2|))
                                       (AND (PAIRP |ISTMP#3|)
                                        (PROGN
                                          (SPADLET |ISTMP#4|
                                           (QCDR |ISTMP#3|))
                                          (AND (PAIRP |ISTMP#4|)
                                           (PROGN
                                             (SPADLET |n|
                                              (QCAR |ISTMP#4|))
                                             (SPADLET |ISTMP#5|
                                              (QCDR |ISTMP#4|))
                                             (AND (PAIRP |ISTMP#5|)
                                              (EQ (QCDR |ISTMP#5|) NIL)
                                              (PROGN
                                                (SPADLET |x|
                                                 (QCAR |ISTMP#5|))
                                                'T)))))))
                                     (PROGN
                                       (SPADLET |l| (QCDR |ISTMP#2|))
                                       'T)
                                     (PROGN
                                       (SPADLET |l| (NREVERSE |l|))
                                       'T))))
                         (CONS 'SEQ
                               (APPEND |l|
                                       (CONS |x|
                                        (CONS
                                         (CONS '|exit|
                                          (CONS |n| (CONS |cond| NIL)))
                                         NIL)))))
                        ('T
                         (CONS 'SEQ
                               (CONS |body|
                                     (CONS
                                      (CONS '|exit|
                                       (CONS |n| (CONS |cond| NIL)))
                                      NIL))))))
             (CONS |nitl| |nbody|))))))

;formatDeftranSEQ(x,flag) ==
;  u := formatDeftran(x,flag)
;  u is ['SEQ,:.] => rest u
;  [u]

(DEFUN |formatDeftranSEQ| (|x| |flag|)
  (PROG (|u|)
    (RETURN
      (PROGN
        (SPADLET |u| (|formatDeftran| |x| |flag|))
        (COND
          ((AND (PAIRP |u|) (EQ (QCAR |u|) 'SEQ)) (CDR |u|))
          ('T (CONS |u| NIL)))))))

;formatDeftranIf(a,b,c) ==
;  b = 'noBranch =>
;    a is [op,:r] and (al := '((_= . _~_=) (_< . _>_=) (_> . _<_=));
;                      iop := LASSOC(op, al) or RASSOC(op, al)) =>
;      [["=>",[iop, :r],c]]
;    a is [op,r] and MEMQ(op,'(NOT not NULL null)) =>
;      [["=>", r, c]]
;    [["=>", ['not, a], c]]
;  post :=
;    c = 'noBranch => nil
;    c is ['SEQ,:.] => CDR c
;    [c]
;  [["=>",a,b],:post]

(DEFUN |formatDeftranIf| (|a| |b| |c|)
  (PROG (|al| |iop| |op| |ISTMP#1| |r| |post|)
    (RETURN
      (COND
        ((BOOT-EQUAL |b| '|noBranch|)
         (COND
           ((AND (PAIRP |a|)
                 (PROGN
                   (SPADLET |op| (QCAR |a|))
                   (SPADLET |r| (QCDR |a|))
                   'T)
                 (PROGN
                   (SPADLET |al| '((= . ~=) (< . >=) (> . <=)))
                   (SPADLET |iop|
                            (OR (LASSOC |op| |al|)
                                (|rassoc| |op| |al|)))))
            (CONS (CONS '=> (CONS (CONS |iop| |r|) (CONS |c| NIL)))
                  NIL))
           ((AND (PAIRP |a|)
                 (PROGN
                   (SPADLET |op| (QCAR |a|))
                   (SPADLET |ISTMP#1| (QCDR |a|))
                   (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                        (PROGN (SPADLET |r| (QCAR |ISTMP#1|)) 'T)))
                 (MEMQ |op| '(NOT |not| NULL |null|)))
            (CONS (CONS '=> (CONS |r| (CONS |c| NIL))) NIL))
           ('T
            (CONS (CONS '=>
                        (CONS (CONS '|not| (CONS |a| NIL))
                              (CONS |c| NIL)))
                  NIL))))
        ('T
         (SPADLET |post|
                  (COND
                    ((BOOT-EQUAL |c| '|noBranch|) NIL)
                    ((AND (PAIRP |c|) (EQ (QCAR |c|) 'SEQ)) (CDR |c|))
                    ('T (CONS |c| NIL))))
         (CONS (CONS '=> (CONS |a| (CONS |b| NIL))) |post|))))))

;formatWHERE ["where",a,b] ==
;  $insideTypeExpression: local := nil
;  $insideCAPSULE: local := false
;  tryBreak(formatLeft("format",a,"where","Led") and format " where ",b,"where","Led")

(DEFUN |formatWHERE| (G167196)
  (PROG (|$insideTypeExpression| |$insideCAPSULE| |a| |b|)
    (DECLARE (SPECIAL |$insideTypeExpression| |$insideCAPSULE|))
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167196) '|where|) (CAR G167196)))
        (SPADLET |a| (CADR G167196))
        (SPADLET |b| (CADDR G167196))
        (SPADLET |$insideTypeExpression| NIL)
        (SPADLET |$insideCAPSULE| NIL)
        (|tryBreak|
            (AND (|formatLeft| '|format| |a| '|where| '|Led|)
                 (|format| '| where |))
            |b| '|where| '|Led|)))))

;--======================================================================
;--              Special Handlers:  Categories
;--======================================================================
;formatATTRIBUTE ['ATTRIBUTE,att] == format att

(DEFUN |formatATTRIBUTE| (G167218)
  (PROG (|att|)
    (RETURN (PROGN (SPADLET |att| (CADR G167218)) (|format| |att|)))))

;formatDeftranCategory ['CATEGORY,kind,:items,item] == ["SEQ",:items,["exit",1,item]]

(DEFUN |formatDeftranCategory| (G167229)
  (PROG (|kind| |LETTMP#1| |item| |items|)
    (RETURN
      (PROGN
        (SPADLET |kind| (CADR G167229))
        (SPADLET |LETTMP#1| (REVERSE (CDDR G167229)))
        (SPADLET |item| (CAR |LETTMP#1|))
        (SPADLET |items| (NREVERSE (CDR |LETTMP#1|)))
        (CONS 'SEQ
              (APPEND |items|
                      (CONS (CONS '|exit| (CONS 1 (CONS |item| NIL)))
                            NIL)))))))

;formatCategory ['Category] == format " " and format "Category"

(DEFUN |formatCategory| (G167249)
  (declare (ignore G167249))
  (AND (|format| '| |) (|format| '|Category|)))

;formatCATEGORY cat ==
;  con := opOf $form
;  $comments: local := SUBST('_$,'_%,GETDATABASE(con,'DOCUMENTATION))
;  $insideEXPORTS : local := true
;  format ["with",formatDeftranCategory cat]

(DEFUN |formatCATEGORY| (|cat|)
  (PROG (|$comments| |$insideEXPORTS| |con|)
    (DECLARE (SPECIAL |$comments| |$insideEXPORTS| |$form|))
    (RETURN
      (PROGN
        (SPADLET |con| (|opOf| |$form|))
        (SPADLET |$comments|
                 (MSUBST '$ '% (GETDATABASE |con| 'DOCUMENTATION)))
        (SPADLET |$insideEXPORTS| 'T)
        (|format|
            (CONS '|with| (CONS (|formatDeftranCategory| |cat|) NIL)))))))

;formatSIGNATURE ['SIGNATURE,op,types,:r] ==
;  MEMQ('constant,r) => format op and format ": " and (u := format first types) and
;    formatSC() and formatComments(u,op,types)
;  format op and format ": " and (u := format ['Mapping,:types]) and formatSC() and
;    formatComments(u,op,types)

(DEFUN |formatSIGNATURE| (G167268)
  (PROG (|op| |types| |r| |u|)
    (RETURN
      (PROGN
        (SPADLET |op| (CADR G167268))
        (SPADLET |types| (CADDR G167268))
        (SPADLET |r| (CDDDR G167268))
        (COND
          ((MEMQ '|constant| |r|)
           (AND (|format| |op|) (|format| '|: |)
                (SPADLET |u| (|format| (CAR |types|))) (|formatSC|)
                (|formatComments| |u| |op| |types|)))
          ('T
           (AND (|format| |op|) (|format| '|: |)
                (SPADLET |u| (|format| (CONS '|Mapping| |types|)))
                (|formatSC|) (|formatComments| |u| |op| |types|))))))))

;formatDefault ["default",a] ==
;  $insideCategoryIfTrue : local := false
;  $insideCAPSULE: local := true
;  $insideTypeExpression: local := false
;  tryBreak(format "default ",a,"with","Nud")

(DEFUN |formatDefault| (G167288)
  (PROG (|$insideCategoryIfTrue| |$insideCAPSULE|
            |$insideTypeExpression| |a|)
    (DECLARE (SPECIAL |$insideCategoryIfTrue| |$insideCAPSULE|
                      |$insideTypeExpression|))
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167288) '|default|) (CAR G167288)))
        (SPADLET |a| (CADR G167288))
        (SPADLET |$insideCategoryIfTrue| NIL)
        (SPADLET |$insideCAPSULE| 'T)
        (SPADLET |$insideTypeExpression| NIL)
        (|tryBreak| (|format| '|default |) |a| '|with| '|Nud|)))))

;--======================================================================
;--              Special Handlers:  Control Structures
;--======================================================================
;formatUNCOERCE ['UNCOERCE,x] == format x

(DEFUN |formatUNCOERCE| (G167310)
  (PROG (|x|)
    (RETURN (PROGN (SPADLET |x| (CADR G167310)) (|format| |x|)))))

;formatIF ['IF,a,b,c] ==
;  c = 'noBranch => formatIF2(a,b,"if ")
;  b = 'noBranch => formatIF ['IF,['not,a],c,'noBranch]
;  formatIF2(a,b,"if ") and newLine() and formatIF3 c

(DEFUN |formatIF| (G167322)
  (PROG (|a| |b| |c|)
    (RETURN
      (PROGN
        (SPADLET |a| (CADR G167322))
        (SPADLET |b| (CADDR G167322))
        (SPADLET |c| (CADDDR G167322))
        (COND
          ((BOOT-EQUAL |c| '|noBranch|) (|formatIF2| |a| |b| '|if |))
          ((BOOT-EQUAL |b| '|noBranch|)
           (|formatIF|
               (CONS 'IF
                     (CONS (CONS '|not| (CONS |a| NIL))
                           (CONS |c| (CONS '|noBranch| NIL))))))
          ('T
           (AND (|formatIF2| |a| |b| '|if |) (|newLine|)
                (|formatIF3| |c|))))))))

;formatIF2(a,b,prefix) ==
;  tryBreakNB(format prefix and format a and format " then ",b,"then","Nud")

(DEFUN |formatIF2| (|a| |b| |prefix|)
  (|tryBreakNB|
      (AND (|format| |prefix|) (|format| |a|) (|format| '| then |)) |b|
      '|then| '|Nud|))

;formatIF3 x ==
;  x is ['IF,a,b,c] =>
;    c = 'noBranch => tryBreak(format "else if "
;      and format a and format " then ",b,"then","Nud")
;    formatIF2(a,b,"else if ") and newLine() and formatIF3 c
;  tryBreak(format "else ",x,"else","Nud")

(DEFUN |formatIF3| (|x|)
  (PROG (|ISTMP#1| |a| |ISTMP#2| |b| |ISTMP#3| |c|)
    (RETURN
      (COND
        ((AND (PAIRP |x|) (EQ (QCAR |x|) 'IF)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |x|))
                (AND (PAIRP |ISTMP#1|)
                     (PROGN
                       (SPADLET |a| (QCAR |ISTMP#1|))
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (PAIRP |ISTMP#2|)
                            (PROGN
                              (SPADLET |b| (QCAR |ISTMP#2|))
                              (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                              (AND (PAIRP |ISTMP#3|)
                                   (EQ (QCDR |ISTMP#3|) NIL)
                                   (PROGN
                                     (SPADLET |c| (QCAR |ISTMP#3|))
                                     'T))))))))
         (COND
           ((BOOT-EQUAL |c| '|noBranch|)
            (|tryBreak|
                (AND (|format| '|else if |) (|format| |a|)
                     (|format| '| then |))
                |b| '|then| '|Nud|))
           ('T
            (AND (|formatIF2| |a| |b| '|else if |) (|newLine|)
                 (|formatIF3| |c|)))))
        ('T (|tryBreak| (|format| '|else |) |x| '|else| '|Nud|))))))

;formatBlock(l,x) ==
;  null l => format x
;  $pilesAreOkHere: local := nil
;  format "{ " and format first l and
;    (and/[formatSC() and format y for y in rest l])
;      and formatSC() and format x and format " }"

(DEFUN |formatBlock| (|l| |x|)
  (PROG (|$pilesAreOkHere|)
    (DECLARE (SPECIAL |$pilesAreOkHere|))
    (RETURN
      (SEQ (COND
             ((NULL |l|) (|format| |x|))
             ('T (SPADLET |$pilesAreOkHere| NIL)
              (AND (|format| '|{ |) (|format| (CAR |l|))
                   (PROG (G167388)
                     (SPADLET G167388 'T)
                     (RETURN
                       (DO ((G167394 NIL (NULL G167388))
                            (G167395 (CDR |l|) (CDR G167395))
                            (|y| NIL))
                           ((OR G167394 (ATOM G167395)
                                (PROGN (SETQ |y| (CAR G167395)) NIL))
                            G167388)
                         (SEQ (EXIT (SETQ G167388
                                     (AND G167388
                                      (AND (|formatSC|) (|format| |y|)))))))))
                   (|formatSC|) (|format| |x|) (|format| '| }|))))))))

;formatExit ["exit",.,u] == format u

(DEFUN |formatExit| (G167409)
  (PROG (|u|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167409) '|exit|) (CAR G167409)))
        (SPADLET |u| (CADDR G167409))
        (|format| |u|)))))

;formatvoid ["void"] == format "()"

(DEFUN |formatvoid| (G167422)
  (PROGN
    (COND ((EQ (CAR G167422) '|void|) (CAR G167422)))
    (|format| '|()|)))

;formatLeave ["leave",.,u] == format "break"

(DEFUN |formatLeave| (G167432)
  (PROG (|u|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167432) '|leave|) (CAR G167432)))
        (SPADLET |u| (CADDR G167432))
        (|format| '|break|)))))

;formatCOLLECT u == formatSpill("formatCOLLECT1",u)

(DEFUN |formatCOLLECT| (|u|) (|formatSpill| '|formatCOLLECT1| |u|))

;formatCOLLECT1 ["COLLECT",:iteratorList,body] ==
;  $pilesAreOkHere: local := nil
;  format "[" and format body and format " " and
;    formatSpill("formatIteratorTail",iteratorList)

(DEFUN |formatCOLLECT1| (G167449)
  (PROG (|$pilesAreOkHere| |LETTMP#1| |body| |iteratorList|)
    (DECLARE (SPECIAL |$pilesAreOkHere|))
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167449) 'COLLECT) (CAR G167449)))
        (SPADLET |LETTMP#1| (REVERSE (CDR G167449)))
        (SPADLET |body| (CAR |LETTMP#1|))
        (SPADLET |iteratorList| (NREVERSE (CDR |LETTMP#1|)))
        (SPADLET |$pilesAreOkHere| NIL)
        (AND (|format| '[) (|format| |body|) (|format| '| |)
             (|formatSpill| '|formatIteratorTail| |iteratorList|))))))

;formatIteratorTail iteratorList ==
;  formatIterator first iteratorList and
;    (and/[format " " and formatIterator x for x in rest iteratorList]) and format "]"

(DEFUN |formatIteratorTail| (|iteratorList|)
  (PROG ()
    (RETURN
      (SEQ (AND (|formatIterator| (CAR |iteratorList|))
                (PROG (G167471)
                  (SPADLET G167471 'T)
                  (RETURN
                    (DO ((G167477 NIL (NULL G167471))
                         (G167478 (CDR |iteratorList|)
                             (CDR G167478))
                         (|x| NIL))
                        ((OR G167477 (ATOM G167478)
                             (PROGN (SETQ |x| (CAR G167478)) NIL))
                         G167471)
                      (SEQ (EXIT (SETQ G167471
                                       (AND G167471
                                        (AND (|format| '| |)
                                         (|formatIterator| |x|)))))))))
                (|format| ']))))))

;--======================================================================
;--                  Special Handlers:  Keywords
;--======================================================================
;
;formatColon [":",a,b] ==
;  b is ['with,c,:d] => formatColonWith(a,c,d)
;  if not $insideTypeExpression then
;    insideCat() => nil
;    format
;      $insideDEF => "local "
;      "default "
;  op :=
;    $insideCAPSULE and not $insideDEF => ": "
;    insideCat() => ": "
;    ":"
;  b := (atom b => b; markMacroTran b)
;  a is ['LISTOF,:c] => formatComma c and format ": " and formatLocal1 b
;  formatInfix(op,[a, b],formatOpBindingPower(":","Led","left"),
;                              formatOpBindingPower(":","Led","right"))

(DEFUN |formatColon| (G167502)
  (PROG (|a| |ISTMP#1| |d| |op| |b| |c|)
  (declare (special |$insideDEF| |$insideCAPSULE| |$insideTypeExpression|))
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167502) '|:|) (CAR G167502)))
        (SPADLET |a| (CADR G167502))
        (SPADLET |b| (CADDR G167502))
        (COND
          ((AND (PAIRP |b|) (EQ (QCAR |b|) '|with|)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |b|))
                  (AND (PAIRP |ISTMP#1|)
                       (PROGN
                         (SPADLET |c| (QCAR |ISTMP#1|))
                         (SPADLET |d| (QCDR |ISTMP#1|))
                         'T))))
           (|formatColonWith| |a| |c| |d|))
          ('T
           (COND
             ((NULL |$insideTypeExpression|)
              (COND
                ((|insideCat|) NIL)
                ('T
                 (|format|
                     (COND (|$insideDEF| '|local |) ('T '|default |)))))))
           (SPADLET |op|
                    (COND
                      ((AND |$insideCAPSULE| (NULL |$insideDEF|))
                       '|: |)
                      ((|insideCat|) '|: |)
                      ('T '|:|)))
           (SPADLET |b|
                    (COND ((ATOM |b|) |b|) ('T (|markMacroTran| |b|))))
           (COND
             ((AND (PAIRP |a|) (EQ (QCAR |a|) 'LISTOF)
                   (PROGN (SPADLET |c| (QCDR |a|)) 'T))
              (AND (|formatComma| |c|) (|format| '|: |)
                   (|formatLocal1| |b|)))
             ('T
              (|formatInfix| |op| (CONS |a| (CONS |b| NIL))
                  (|formatOpBindingPower| '|:| '|Led| '|left|)
                  (|formatOpBindingPower| '|:| '|Led| '|right|))))))))))

;formatColonWith(form,a,b) ==
;  con := opOf $form
;  $comments: local := SUBST('_$,'_%,GETDATABASE(con,'DOCUMENTATION))
;  $insideEXPORTS : local := true
;  $pilesAreOkHere: local := true
;  $insideTypeExpression : local := false
;  b => tryBreak(formatDefForm form and format ": "
;        and format a and format " with ",first b,"with","Led")
;  tryBreak(formatDefForm form and format ": with ",a,"with","Nud")

(DEFUN |formatColonWith| (|form| |a| |b|)
  (PROG (|$comments| |$insideEXPORTS| |$pilesAreOkHere|
            |$insideTypeExpression| |con|)
    (DECLARE (SPECIAL |$comments| |$insideEXPORTS| |$pilesAreOkHere|
                      |$insideTypeExpression| |$form|))
    (RETURN
      (PROGN
        (SPADLET |con| (|opOf| |$form|))
        (SPADLET |$comments|
                 (MSUBST '$ '% (GETDATABASE |con| 'DOCUMENTATION)))
        (SPADLET |$insideEXPORTS| 'T)
        (SPADLET |$pilesAreOkHere| 'T)
        (SPADLET |$insideTypeExpression| NIL)
        (COND
          (|b| (|tryBreak|
                   (AND (|formatDefForm| |form|) (|format| '|: |)
                        (|format| |a|) (|format| '| with |))
                   (CAR |b|) '|with| '|Led|))
          ('T
           (|tryBreak|
               (AND (|formatDefForm| |form|) (|format| '|: with |)) |a|
               '|with| '|Nud|)))))))

;formatCOND ["COND",:l] ==
;  originalC:= $c
;  and/[x is [a,[.,.,b]] for x in l] =>
;    (originalC=$m or indent() and newLine()) and first l is [a,[.,.,b]] and
;      formatIfExit(a,b) and
;        (and/[newLine() and formatIfExit(a,b) for [a,[.,.,b]] in rest l]) and (originalC=$m or undent()) and originalC
;  formatIfThenElse l

(DEFUN |formatCOND| (G167644)
  (PROG (|l| |originalC| |ISTMP#1| |ISTMP#2| |ISTMP#3| |ISTMP#4|
             |ISTMP#5| |a| |b|)
  (declare (special |$m| |$c|))
    (RETURN
      (SEQ (PROGN
             (COND ((EQ (CAR G167644) 'COND) (CAR G167644)))
             (SPADLET |l| (CDR G167644))
             (SPADLET |originalC| |$c|)
             (COND
               ((PROG (G167680)
                  (SPADLET G167680 'T)
                  (RETURN
                    (DO ((G167697 NIL (NULL G167680))
                         (G167698 |l| (CDR G167698)) (|x| NIL))
                        ((OR G167697 (ATOM G167698)
                             (PROGN (SETQ |x| (CAR G167698)) NIL))
                         G167680)
                      (SEQ (EXIT (SETQ G167680
                                       (AND G167680
                                        (AND (PAIRP |x|)
                                         (PROGN
                                           (SPADLET |a| (QCAR |x|))
                                           (SPADLET |ISTMP#1|
                                            (QCDR |x|))
                                           (AND (PAIRP |ISTMP#1|)
                                            (EQ (QCDR |ISTMP#1|) NIL)
                                            (PROGN
                                              (SPADLET |ISTMP#2|
                                               (QCAR |ISTMP#1|))
                                              (AND (PAIRP |ISTMP#2|)
                                               (PROGN
                                                 (SPADLET |ISTMP#3|
                                                  (QCDR |ISTMP#2|))
                                                 (AND (PAIRP |ISTMP#3|)
                                                  (PROGN
                                                    (SPADLET |ISTMP#4|
                                                     (QCDR |ISTMP#3|))
                                                    (AND
                                                     (PAIRP |ISTMP#4|)
                                                     (EQ
                                                      (QCDR |ISTMP#4|)
                                                      NIL)
                                                     (PROGN
                                                       (SPADLET |b|
                                                        (QCAR
                                                         |ISTMP#4|))
                                                       'T)))))))))))))))))
                (AND (OR (BOOT-EQUAL |originalC| |$m|)
                         (AND (|indent|) (|newLine|)))
                     (PROGN
                       (SPADLET |ISTMP#1| (CAR |l|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |a| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (PAIRP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (PROGN
                                     (SPADLET |ISTMP#3|
                                      (QCAR |ISTMP#2|))
                                     (AND (PAIRP |ISTMP#3|)
                                      (PROGN
                                        (SPADLET |ISTMP#4|
                                         (QCDR |ISTMP#3|))
                                        (AND (PAIRP |ISTMP#4|)
                                         (PROGN
                                           (SPADLET |ISTMP#5|
                                            (QCDR |ISTMP#4|))
                                           (AND (PAIRP |ISTMP#5|)
                                            (EQ (QCDR |ISTMP#5|) NIL)
                                            (PROGN
                                              (SPADLET |b|
                                               (QCAR |ISTMP#5|))
                                              'T)))))))))))
                     (|formatIfExit| |a| |b|)
                     (PROG (G167705)
                       (SPADLET G167705 'T)
                       (RETURN
                         (DO ((G167712 NIL (NULL G167705))
                              (G167713 (CDR |l|) (CDR G167713))
                              (G167639 NIL))
                             ((OR G167712 (ATOM G167713)
                                  (PROGN
                                    (SETQ G167639 (CAR G167713))
                                    NIL)
                                  (PROGN
                                    (PROGN
                                      (SPADLET |a| (CAR G167639))
                                      (SPADLET |b|
                                       (CAR (CDDADR G167639)))
                                      G167639)
                                    NIL))
                              G167705)
                           (SEQ (EXIT (SETQ G167705
                                       (AND G167705
                                        (AND (|newLine|)
                                         (|formatIfExit| |a| |b|)))))))))
                     (OR (BOOT-EQUAL |originalC| |$m|) (|undent|))
                     |originalC|))
               ('T (|formatIfThenElse| |l|))))))))

;formatPROGN ["PROGN",:l] ==
;  l is [:u,x] => formatPiles(u,x)
;  error '"formatPROGN"

(DEFUN |formatPROGN| (G167747)
  (PROG (|l| |ISTMP#1| |x| |u|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167747) 'PROGN) (CAR G167747)))
        (SPADLET |l| (CDR G167747))
        (COND
          ((AND (PAIRP |l|)
                (PROGN (SPADLET |ISTMP#1| (REVERSE |l|)) 'T)
                (PAIRP |ISTMP#1|)
                (PROGN
                  (SPADLET |x| (QCAR |ISTMP#1|))
                  (SPADLET |u| (QCDR |ISTMP#1|))
                  'T)
                (PROGN (SPADLET |u| (NREVERSE |u|)) 'T))
           (|formatPiles| |u| |x|))
          ('T (|error| "formatPROGN")))))))

;formatELT ["ELT",a,b] == formatApplication [a,b]

(DEFUN |formatELT| (G167771)
  (PROG (|a| |b|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167771) 'ELT) (CAR G167771)))
        (SPADLET |a| (CADR G167771))
        (SPADLET |b| (CADDR G167771))
        (|formatApplication| (CONS |a| (CONS |b| NIL)))))))

;formatCONS ["CONS",a,b] ==
;  $pilesAreOkHere: local := nil
;  format "[" and formatConstructItem a and formatTail b

(DEFUN |formatCONS| (G167788)
  (PROG (|$pilesAreOkHere| |a| |b|)
    (DECLARE (SPECIAL |$pilesAreOkHere|))
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167788) 'CONS) (CAR G167788)))
        (SPADLET |a| (CADR G167788))
        (SPADLET |b| (CADDR G167788))
        (SPADLET |$pilesAreOkHere| NIL)
        (AND (|format| '[) (|formatConstructItem| |a|)
             (|formatTail| |b|))))))

;formatTail x ==
;  null x => format "]"
;  format "," and formatTail1 x

(DEFUN |formatTail| (|x|)
  (COND
    ((NULL |x|) (|format| ']))
    ('T (AND (|format| '|,|) (|formatTail1| |x|)))))

;formatTail1 x ==
;  x is ["CONS",a,b] => formatConstructItem a and formatTail b
;  x is ["APPEND",a,b] =>
;    null b => formatConstructItem a and format "]"
;    format ":" and formatConstructItem a and formatTail b
;  format ":" and formatConstructItem x and format "]"

(DEFUN |formatTail1| (|x|)
  (PROG (|ISTMP#1| |a| |ISTMP#2| |b|)
    (RETURN
      (COND
        ((AND (PAIRP |x|) (EQ (QCAR |x|) 'CONS)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |x|))
                (AND (PAIRP |ISTMP#1|)
                     (PROGN
                       (SPADLET |a| (QCAR |ISTMP#1|))
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)
                            (PROGN (SPADLET |b| (QCAR |ISTMP#2|)) 'T))))))
         (AND (|formatConstructItem| |a|) (|formatTail| |b|)))
        ((AND (PAIRP |x|) (EQ (QCAR |x|) 'APPEND)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |x|))
                (AND (PAIRP |ISTMP#1|)
                     (PROGN
                       (SPADLET |a| (QCAR |ISTMP#1|))
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)
                            (PROGN (SPADLET |b| (QCAR |ISTMP#2|)) 'T))))))
         (COND
           ((NULL |b|) (AND (|formatConstructItem| |a|) (|format| '])))
           ('T
            (AND (|format| '|:|) (|formatConstructItem| |a|)
                 (|formatTail| |b|)))))
        ('T
         (AND (|format| '|:|) (|formatConstructItem| |x|)
              (|format| '])))))))

;-- x = "." => format ""
;formatConstructItem x == format x

(DEFUN |formatConstructItem| (|x|) (|format| |x|)) 

;formatLET ["LET",a,b] ==
;  $insideTypeExpression: local := true
;  a = "Rep" or atom a and constructor? opOf b =>
;    tryBreakNB(formatAtom a and format " == ",b,":=","Led")
;  tryBreakNB((IDENTP a => formatAtom a; format a) and format " := ",b,":=","Led")

(DEFUN |formatLET| (G167861)
  (PROG (|$insideTypeExpression| |a| |b|)
    (DECLARE (SPECIAL |$insideTypeExpression|))
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167861) 'LET) (CAR G167861)))
        (SPADLET |a| (CADR G167861))
        (SPADLET |b| (CADDR G167861))
        (SPADLET |$insideTypeExpression| 'T)
        (COND
          ((OR (BOOT-EQUAL |a| '|Rep|)
               (AND (ATOM |a|) (|constructor?| (|opOf| |b|))))
           (|tryBreakNB| (AND (|formatAtom| |a|) (|format| '| == |))
               |b| '|:=| '|Led|))
          ('T
           (|tryBreakNB|
               (AND (COND
                      ((IDENTP |a|) (|formatAtom| |a|))
                      ('T (|format| |a|)))
                    (|format| '| := |))
               |b| '|:=| '|Led|)))))))

;formatIfExit(a,b) ==
;                       --called from SCOND or COND only
;  $numberOfSpills: local:= 0
;  curMargin:= $m
;  curMarginStack:= $currentMarginStack
;  $doNotResetMarginIfTrue:= true
;  format a and format " => " and formatRight("formatCut",b,"=>","Led") =>
;    ($currentMarginStack:= curMarginStack; $m:= curMargin)

(DEFUN |formatIfExit| (|a| |b|)
  (PROG (|$numberOfSpills| |curMargin| |curMarginStack|)
    (DECLARE (SPECIAL |$numberOfSpills| |$m| |$currentMarginStack|
                      |$doNotResetMarginIfTrue|))
    (RETURN
      (PROGN
        (SPADLET |$numberOfSpills| 0)
        (SPADLET |curMargin| |$m|)
        (SPADLET |curMarginStack| |$currentMarginStack|)
        (SPADLET |$doNotResetMarginIfTrue| 'T)
        (COND
          ((AND (|format| |a|) (|format| '| => |)
                (|formatRight| '|formatCut| |b| '=> '|Led|))
           (PROGN
             (SPADLET |$currentMarginStack| |curMarginStack|)
             (SPADLET |$m| |curMargin|))))))))

;formatIfThenElse x == formatSpill("formatIf1",x)

(DEFUN |formatIfThenElse| (|x|) (|formatSpill| '|formatIf1| |x|))

;formatIf1 x ==
;  x is [[a,:r],:c] and null c =>
;    b:=
;      r is [:l,s] and l => ['SEQ,:l,['exit,.,s]]
;      first r
;    isTrue a => format b
;    format "if " and format a and format " then " and format b
;  format "if " and format a and
;    (try
;      (format " then " and format b and format " else "
;        and formatIfThenElse c) or spillLine()
;          and format " then " and format b and
;--           ($c:= $m:= $m+6) and
;            ($numberOfSpills:= $numberOfSpills-1)
;              and spillLine() and format " else " and formatIfThenElse c)

(DEFUN |formatIf1| (|x|)
  (PROG (|a| |r| |c| |ISTMP#1| |s| |l| |b|)
  (declare (special |$numberOfSpills|))
    (RETURN
      (COND
        ((AND (PAIRP |x|)
              (PROGN
                (SPADLET |ISTMP#1| (QCAR |x|))
                (AND (PAIRP |ISTMP#1|)
                     (PROGN
                       (SPADLET |a| (QCAR |ISTMP#1|))
                       (SPADLET |r| (QCDR |ISTMP#1|))
                       'T)))
              (PROGN (SPADLET |c| (QCDR |x|)) 'T) (NULL |c|))
         (SPADLET |b|
                  (COND
                    ((AND (PAIRP |r|)
                          (PROGN (SPADLET |ISTMP#1| (REVERSE |r|)) 'T)
                          (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |s| (QCAR |ISTMP#1|))
                            (SPADLET |l| (QCDR |ISTMP#1|))
                            'T)
                          (PROGN (SPADLET |l| (NREVERSE |l|)) 'T) |l|)
                     (CONS 'SEQ
                           (APPEND |l|
                                   (CONS
                                    (CONS '|exit|
                                     (CONS '|.| (CONS |s| NIL)))
                                    NIL))))
                    ('T (CAR |r|))))
         (COND
           ((|isTrue| |a|) (|format| |b|))
           ('T
            (AND (|format| '|if |) (|format| |a|) (|format| '| then |)
                 (|format| |b|)))))
        ('T
         (AND (|format| '|if |) (|format| |a|)
              (OR (|try| (AND (|format| '| then |) (|format| |b|)
                              (|format| '| else |)
                              (|formatIfThenElse| |c|)))
                  (AND (|spillLine|) (|format| '| then |)
                       (|format| |b|)
                       (SPADLET |$numberOfSpills|
                                (SPADDIFFERENCE |$numberOfSpills| 1))
                       (|spillLine|) (|format| '| else |)
                       (|formatIfThenElse| |c|)))))))))

;formatQUOTE ["QUOTE",x] == format "('" and format x and format ")"

(DEFUN |formatQUOTE| (G167923)
  (PROG (|x|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167923) 'QUOTE) (CAR G167923)))
        (SPADLET |x| (CADR G167923))
        (AND (|format| '|('|) (|format| |x|) (|format| '|)|))))))

;formatMI ["MI",a,b] == format a

(DEFUN |formatMI| (G167936)
  (PROG (|a| |b|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G167936) 'MI) (CAR G167936)))
        (SPADLET |a| (CADR G167936))
        (SPADLET |b| (CADDR G167936))
        (|format| |a|)))))

;formatMapping ['Mapping,target,:sources] ==
;  $noColonDeclaration: local := true
;  formatTuple ['Tuple,:sources] and format " -> " and format target

(DEFUN |formatMapping| (G167953)
  (PROG (|$noColonDeclaration| |target| |sources|)
    (DECLARE (SPECIAL |$noColonDeclaration|))
    (RETURN
      (PROGN
        (SPADLET |target| (CADR G167953))
        (SPADLET |sources| (CDDR G167953))
        (SPADLET |$noColonDeclaration| 'T)
        (AND (|formatTuple| (CONS '|Tuple| |sources|))
             (|format| '| -> |) (|format| |target|))))))

;formatTuple ['Tuple,:types] ==
;  null types => format "()"
;  null rest types => format first types
;  formatFunctionCallTail types

(DEFUN |formatTuple| (G167971)
  (PROG (|types|)
    (RETURN
      (PROGN
        (SPADLET |types| (CDR G167971))
        (COND
          ((NULL |types|) (|format| '|()|))
          ((NULL (CDR |types|)) (|format| (CAR |types|)))
          ('T (|formatFunctionCallTail| |types|)))))))

;formatConstruct(['construct,:u]) ==
;  format "[" and (null u or format first u and
;    "and"/[format "," and formatCut x for x in rest u]) and format "]"

(DEFUN |formatConstruct| (G167982)
  (PROG (|u|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |u| (CDR G167982))
             (AND (|format| '[)
                  (OR (NULL |u|)
                      (AND (|format| (CAR |u|))
                           (PROG (G167989)
                             (SPADLET G167989 'T)
                             (RETURN
                               (DO ((G167995 NIL (NULL G167989))
                                    (G167996 (CDR |u|)
                                     (CDR G167996))
                                    (|x| NIL))
                                   ((OR G167995 (ATOM G167996)
                                     (PROGN
                                       (SETQ |x| (CAR G167996))
                                       NIL))
                                    G167989)
                                 (SEQ (EXIT
                                       (SETQ G167989
                                        (AND G167989
                                         (AND (|format| '|,|)
                                          (|formatCut| |x|)))))))))))
                  (|format| '])))))))

;formatNextConstructItem x ==
;  try format x or ($m := $m + 2) and newLine() and format x

(DEFUN |formatNextConstructItem| (|x|)
  (declare (special |$m|))
  (OR (|try| (|format| |x|))
      (AND (SPADLET |$m| (PLUS |$m| 2)) (|newLine|) (|format| |x|))))

;formatREPEAT ["REPEAT",:iteratorList,body] ==
;  tryBreakNB(null iteratorList or (formatIterator first iteratorList and
;    (and/[format " " and formatIterator x for x in rest iteratorList]) and format " ")
;      and format "repeat ",body,"repeat","Led")

(DEFUN |formatREPEAT| (G168012)
  (PROG (|LETTMP#1| |body| |iteratorList|)
    (RETURN
      (SEQ (PROGN
             (COND ((EQ (CAR G168012) 'REPEAT) (CAR G168012)))
             (SPADLET |LETTMP#1| (REVERSE (CDR G168012)))
             (SPADLET |body| (CAR |LETTMP#1|))
             (SPADLET |iteratorList| (NREVERSE (CDR |LETTMP#1|)))
             (|tryBreakNB|
                 (OR (NULL |iteratorList|)
                     (AND (|formatIterator| (CAR |iteratorList|))
                          (PROG (G168025)
                            (SPADLET G168025 'T)
                            (RETURN
                              (DO ((G168031 NIL (NULL G168025))
                                   (G168032 (CDR |iteratorList|)
                                    (CDR G168032))
                                   (|x| NIL))
                                  ((OR G168031 (ATOM G168032)
                                    (PROGN
                                      (SETQ |x| (CAR G168032))
                                      NIL))
                                   G168025)
                                (SEQ (EXIT
                                      (SETQ G168025
                                       (AND G168025
                                        (AND (|format| '| |)
                                         (|formatIterator| |x|)))))))))
                          (|format| '| |) (|format| '|repeat |)))
                 |body| '|repeat| '|Led|))))))

;formatFATARROW ["=>",a,b] == tryBreak(format a and format " => ",b,"=>","Led")

(DEFUN |formatFATARROW| (G168046)
  (PROG (|a| |b|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G168046) '=>) (CAR G168046)))
        (SPADLET |a| (CADR G168046))
        (SPADLET |b| (CADDR G168046))
        (|tryBreak| (AND (|format| |a|) (|format| '| => |)) |b| '=>
            '|Led|)))))

;formatMap ["+->",a,b] ==
;  $noColonDeclaration: local := true
;  tryBreak(format a and format " +-> ", b, "+->","Led")

(DEFUN |formatMap| (G168063)
  (PROG (|$noColonDeclaration| |a| |b|)
    (DECLARE (SPECIAL |$noColonDeclaration|))
    (RETURN
      (PROGN
        (COND ((EQ (CAR G168063) '+->) (CAR G168063)))
        (SPADLET |a| (CADR G168063))
        (SPADLET |b| (CADDR G168063))
        (SPADLET |$noColonDeclaration| 'T)
        (|tryBreak| (AND (|format| |a|) (|format| '| +-> |)) |b| '+->
            '|Led|)))))

;formatREDUCE ["REDUCE",op,.,u] == formatReduce1(op,u)

(DEFUN |formatREDUCE| (G168082)
  (PROG (|op| |u|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G168082) 'REDUCE) (CAR G168082)))
        (SPADLET |op| (CADR G168082))
        (SPADLET |u| (CADDDR G168082))
        (|formatReduce1| |op| |u|)))))

;formatreduce ["reduce",op,u] == formatReduce1(op,u)

(DEFUN |formatreduce| (G168098)
  (PROG (|op| |u|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G168098) '|reduce|) (CAR G168098)))
        (SPADLET |op| (CADR G168098))
        (SPADLET |u| (CADDR G168098))
        (|formatReduce1| |op| |u|)))))

;formatReduce1(op,u) ==
;  if STRINGP op then op := INTERN op
;  id := LASSOC(op,
;    '((_+ Zero)(_* One)(append . NIL)(gcd Zero) (lcm One) (strconc . "")(lcm One)))
;  formatFunctionCall
;    id => ['reduce,op,u,id]
;    ['reduce,op,u]

(DEFUN |formatReduce1| (|op| |u|)
  (PROG (|id|)
    (RETURN
      (PROGN
        (COND ((STRINGP |op|) (SPADLET |op| (INTERN |op|))))
        (SPADLET |id|
                 (LASSOC |op|
                         '((+ |Zero|) (* |One|) (|append|)
                           (|gcd| |Zero|) (|lcm| |One|)
                           (|strconc| . "") (|lcm| |One|))))
        (|formatFunctionCall|
            (COND
              (|id| (CONS '|reduce|
                          (CONS |op| (CONS |u| (CONS |id| NIL)))))
              ('T (CONS '|reduce| (CONS |op| (CONS |u| NIL))))))))))

;formatIterator u ==
;  $noColonDeclaration : local := true
;  u is ["IN",x,y] =>
;    format "for " and formatLeft("format",x,"in","Led") and format " in " and
;      formatRight("format",y,"in","Led")
;  u is ["WHILE",x] => format "while " and formatRight("format",x,"while","Nud")
;  u is ["UNTIL",x] => format "until " and formatRight("format",x,"until","Nud")
;  u is ["|",x] => format "| " and formatRight("format",x,"|","Led")
;  u is ["STEP",i,init,step,:v] =>
;    final := IFCAR v
;    format "for " and formatLeft("format",i,"in","Led") and format " in " and
;      (seg := ['SEGMENT,init,final]) and (formatStepOne? step => format seg; formatBy ['by,seg,step])
;  error "formatIterator"

(DEFUN |formatIterator| (|u|)
  (PROG (|$noColonDeclaration| |y| |x| |ISTMP#1| |i| |ISTMP#2| |init|
            |ISTMP#3| |step| |v| |final| |seg|)
    (DECLARE (SPECIAL |$noColonDeclaration|))
    (RETURN
      (PROGN
        (SPADLET |$noColonDeclaration| 'T)
        (COND
          ((AND (PAIRP |u|) (EQ (QCAR |u|) 'IN)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |u|))
                  (AND (PAIRP |ISTMP#1|)
                       (PROGN
                         (SPADLET |x| (QCAR |ISTMP#1|))
                         (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (PAIRP |ISTMP#2|)
                              (EQ (QCDR |ISTMP#2|) NIL)
                              (PROGN
                                (SPADLET |y| (QCAR |ISTMP#2|))
                                'T))))))
           (AND (|format| '|for |)
                (|formatLeft| '|format| |x| '|in| '|Led|)
                (|format| '| in |)
                (|formatRight| '|format| |y| '|in| '|Led|)))
          ((AND (PAIRP |u|) (EQ (QCAR |u|) 'WHILE)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |u|))
                  (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                       (PROGN (SPADLET |x| (QCAR |ISTMP#1|)) 'T))))
           (AND (|format| '|while |)
                (|formatRight| '|format| |x| '|while| '|Nud|)))
          ((AND (PAIRP |u|) (EQ (QCAR |u|) 'UNTIL)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |u|))
                  (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                       (PROGN (SPADLET |x| (QCAR |ISTMP#1|)) 'T))))
           (AND (|format| '|until |)
                (|formatRight| '|format| |x| '|until| '|Nud|)))
          ((AND (PAIRP |u|) (EQ (QCAR |u|) '|\||)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |u|))
                  (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                       (PROGN (SPADLET |x| (QCAR |ISTMP#1|)) 'T))))
           (AND (|format| '|\| |)
                (|formatRight| '|format| |x| '|\|| '|Led|)))
          ((AND (PAIRP |u|) (EQ (QCAR |u|) 'STEP)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |u|))
                  (AND (PAIRP |ISTMP#1|)
                       (PROGN
                         (SPADLET |i| (QCAR |ISTMP#1|))
                         (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (PAIRP |ISTMP#2|)
                              (PROGN
                                (SPADLET |init| (QCAR |ISTMP#2|))
                                (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                                (AND (PAIRP |ISTMP#3|)
                                     (PROGN
                                       (SPADLET |step|
                                        (QCAR |ISTMP#3|))
                                       (SPADLET |v| (QCDR |ISTMP#3|))
                                       'T))))))))
           (SPADLET |final| (IFCAR |v|))
           (AND (|format| '|for |)
                (|formatLeft| '|format| |i| '|in| '|Led|)
                (|format| '| in |)
                (SPADLET |seg|
                         (CONS 'SEGMENT
                               (CONS |init| (CONS |final| NIL))))
                (COND
                  ((|formatStepOne?| |step|) (|format| |seg|))
                  ('T
                   (|formatBy|
                       (CONS '|by| (CONS |seg| (CONS |step| NIL))))))))
          ('T (|error| '|formatIterator|)))))))

;formatStepOne? step ==
;  step = 1 or step = '(One) => true
;  step is [op,n,.] and MEMQ(op,'(_:_:  _@)) => n = 1 or n = '(One)
;  false

(DEFUN |formatStepOne?| (|step|)
  (PROG (|op| |ISTMP#1| |n| |ISTMP#2|)
    (RETURN
      (COND
        ((OR (EQL |step| 1) (BOOT-EQUAL |step| '(|One|))) 'T)
        ((AND (PAIRP |step|)
              (PROGN
                (SPADLET |op| (QCAR |step|))
                (SPADLET |ISTMP#1| (QCDR |step|))
                (AND (PAIRP |ISTMP#1|)
                     (PROGN
                       (SPADLET |n| (QCAR |ISTMP#1|))
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (PAIRP |ISTMP#2|)
                            (EQ (QCDR |ISTMP#2|) NIL)))))
              (MEMQ |op| '(|::| @)))
         (OR (EQL |n| 1) (BOOT-EQUAL |n| '(|One|))))
        ('T NIL)))))

;formatBy ['by,seg,step] == format seg and format " by " and format step

(DEFUN |formatBy| (G168243)
  (PROG (|seg| |step|)
    (RETURN
      (PROGN
        (SPADLET |seg| (CADR G168243))
        (SPADLET |step| (CADDR G168243))
        (AND (|format| |seg|) (|format| '| by |) (|format| |step|))))))

;formatSCOND ["SCOND",:l] ==
;  $pilesAreOkHere =>
;                            --called from formatPileLine or formatBlock
;                     --if from formatPileLine
;    initialC:= $c
;    and/[x is [a,["exit",.,b]] for x in l] =>
;      first l is [a,["exit",.,b]] and formatIfExit(a,b) and
;        (and/[newLine() and formatIfExit(a,b) for [a,["exit",.,b]] in rest l]) and initialC
;    formatIfThenElse l and initialC
;  and/[x is [a,["exit",.,b]] for x in l] =>
;    first l is [a,["exit",.,b]] and formatIfExit(a,b) and
;      (and/[format "; " and formatIfExit(a,b) for [a,["exit",.,b]] in rest l]) and $c
;   --warning: and/(...) returns T if there are no entries
;  formatIfThenElse l

(DEFUN |formatSCOND| (G168449)
  (PROG (|l| |initialC| |ISTMP#1| |ISTMP#2| |ISTMP#3| |ISTMP#4|
             |ISTMP#5| |a| |b|)
  (declare (special |$c| |$pilesAreOkHere|))
    (RETURN
      (SEQ (PROGN
             (COND ((EQ (CAR G168449) 'SCOND) (CAR G168449)))
             (SPADLET |l| (CDR G168449))
             (COND
               (|$pilesAreOkHere| (SPADLET |initialC| |$c|)
                   (COND
                     ((PROG (G168512)
                        (SPADLET G168512 'T)
                        (RETURN
                          (DO ((G168529 NIL (NULL G168512))
                               (G168530 |l| (CDR G168530))
                               (|x| NIL))
                              ((OR G168529 (ATOM G168530)
                                   (PROGN
                                     (SETQ |x| (CAR G168530))
                                     NIL))
                               G168512)
                            (SEQ (EXIT (SETQ G168512
                                        (AND G168512
                                         (AND (PAIRP |x|)
                                          (PROGN
                                            (SPADLET |a| (QCAR |x|))
                                            (SPADLET |ISTMP#1|
                                             (QCDR |x|))
                                            (AND (PAIRP |ISTMP#1|)
                                             (EQ (QCDR |ISTMP#1|) NIL)
                                             (PROGN
                                               (SPADLET |ISTMP#2|
                                                (QCAR |ISTMP#1|))
                                               (AND (PAIRP |ISTMP#2|)
                                                (EQ (QCAR |ISTMP#2|)
                                                 '|exit|)
                                                (PROGN
                                                  (SPADLET |ISTMP#3|
                                                   (QCDR |ISTMP#2|))
                                                  (AND
                                                   (PAIRP |ISTMP#3|)
                                                   (PROGN
                                                     (SPADLET |ISTMP#4|
                                                      (QCDR |ISTMP#3|))
                                                     (AND
                                                      (PAIRP |ISTMP#4|)
                                                      (EQ
                                                       (QCDR |ISTMP#4|)
                                                       NIL)
                                                      (PROGN
                                                        (SPADLET |b|
                                                         (QCAR
                                                          |ISTMP#4|))
                                                        'T)))))))))))))))))
                      (AND (PROGN
                             (SPADLET |ISTMP#1| (CAR |l|))
                             (AND (PAIRP |ISTMP#1|)
                                  (PROGN
                                    (SPADLET |a| (QCAR |ISTMP#1|))
                                    (SPADLET |ISTMP#2|
                                     (QCDR |ISTMP#1|))
                                    (AND (PAIRP |ISTMP#2|)
                                     (EQ (QCDR |ISTMP#2|) NIL)
                                     (PROGN
                                       (SPADLET |ISTMP#3|
                                        (QCAR |ISTMP#2|))
                                       (AND (PAIRP |ISTMP#3|)
                                        (EQ (QCAR |ISTMP#3|) '|exit|)
                                        (PROGN
                                          (SPADLET |ISTMP#4|
                                           (QCDR |ISTMP#3|))
                                          (AND (PAIRP |ISTMP#4|)
                                           (PROGN
                                             (SPADLET |ISTMP#5|
                                              (QCDR |ISTMP#4|))
                                             (AND (PAIRP |ISTMP#5|)
                                              (EQ (QCDR |ISTMP#5|) NIL)
                                              (PROGN
                                                (SPADLET |b|
                                                 (QCAR |ISTMP#5|))
                                                'T)))))))))))
                           (|formatIfExit| |a| |b|)
                           (PROG (G168537)
                             (SPADLET G168537 'T)
                             (RETURN
                               (DO ((G168544 NIL (NULL G168537))
                                    (G168545 (CDR |l|)
                                     (CDR G168545))
                                    (G168348 NIL))
                                   ((OR G168544 (ATOM G168545)
                                     (PROGN
                                       (SETQ G168348 (CAR G168545))
                                       NIL)
                                     (PROGN
                                       (PROGN
                                         (SPADLET |a| (CAR G168348))
                                         (SPADLET |b|
                                          (CAR (CDDADR G168348)))
                                         G168348)
                                       NIL))
                                    G168537)
                                 (SEQ (EXIT
                                       (SETQ G168537
                                        (AND G168537
                                         (AND (|newLine|)
                                          (|formatIfExit| |a| |b|)))))))))
                           |initialC|))
                     ('T (AND (|formatIfThenElse| |l|) |initialC|))))
               ((PROG (G168553)
                  (SPADLET G168553 'T)
                  (RETURN
                    (DO ((G168570 NIL (NULL G168553))
                         (G168571 |l| (CDR G168571)) (|x| NIL))
                        ((OR G168570 (ATOM G168571)
                             (PROGN (SETQ |x| (CAR G168571)) NIL))
                         G168553)
                      (SEQ (EXIT (SETQ G168553
                                       (AND G168553
                                        (AND (PAIRP |x|)
                                         (PROGN
                                           (SPADLET |a| (QCAR |x|))
                                           (SPADLET |ISTMP#1|
                                            (QCDR |x|))
                                           (AND (PAIRP |ISTMP#1|)
                                            (EQ (QCDR |ISTMP#1|) NIL)
                                            (PROGN
                                              (SPADLET |ISTMP#2|
                                               (QCAR |ISTMP#1|))
                                              (AND (PAIRP |ISTMP#2|)
                                               (EQ (QCAR |ISTMP#2|)
                                                '|exit|)
                                               (PROGN
                                                 (SPADLET |ISTMP#3|
                                                  (QCDR |ISTMP#2|))
                                                 (AND (PAIRP |ISTMP#3|)
                                                  (PROGN
                                                    (SPADLET |ISTMP#4|
                                                     (QCDR |ISTMP#3|))
                                                    (AND
                                                     (PAIRP |ISTMP#4|)
                                                     (EQ
                                                      (QCDR |ISTMP#4|)
                                                      NIL)
                                                     (PROGN
                                                       (SPADLET |b|
                                                        (QCAR
                                                         |ISTMP#4|))
                                                       'T)))))))))))))))))
                (AND (PROGN
                       (SPADLET |ISTMP#1| (CAR |l|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |a| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (PAIRP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (PROGN
                                     (SPADLET |ISTMP#3|
                                      (QCAR |ISTMP#2|))
                                     (AND (PAIRP |ISTMP#3|)
                                      (EQ (QCAR |ISTMP#3|) '|exit|)
                                      (PROGN
                                        (SPADLET |ISTMP#4|
                                         (QCDR |ISTMP#3|))
                                        (AND (PAIRP |ISTMP#4|)
                                         (PROGN
                                           (SPADLET |ISTMP#5|
                                            (QCDR |ISTMP#4|))
                                           (AND (PAIRP |ISTMP#5|)
                                            (EQ (QCDR |ISTMP#5|) NIL)
                                            (PROGN
                                              (SPADLET |b|
                                               (QCAR |ISTMP#5|))
                                              'T)))))))))))
                     (|formatIfExit| |a| |b|)
                     (PROG (G168578)
                       (SPADLET G168578 'T)
                       (RETURN
                         (DO ((G168585 NIL (NULL G168578))
                              (G168586 (CDR |l|) (CDR G168586))
                              (G168444 NIL))
                             ((OR G168585 (ATOM G168586)
                                  (PROGN
                                    (SETQ G168444 (CAR G168586))
                                    NIL)
                                  (PROGN
                                    (PROGN
                                      (SPADLET |a| (CAR G168444))
                                      (SPADLET |b|
                                       (CAR (CDDADR G168444)))
                                      G168444)
                                    NIL))
                              G168578)
                           (SEQ (EXIT (SETQ G168578
                                       (AND G168578
                                        (AND (|format| '|; |)
                                         (|formatIfExit| |a| |b|)))))))))
                     |$c|))
               ('T (|formatIfThenElse| |l|))))))))

;formatSEGMENT ["SEGMENT",a,b] ==
;  $pilesAreOkHere: local := nil
;  (if pspadBindingPowerOf("right",a)<750 then formatPren a else format a) and
;    formatInfixOp ".." and
;      (null b and $c or
;        (if 750>pspadBindingPowerOf("left",b) then formatPren b else format b))

(DEFUN |formatSEGMENT| (G168634)
  (PROG (|$pilesAreOkHere| |a| |b|)
    (DECLARE (SPECIAL |$pilesAreOkHere| |$c|))
    (RETURN
      (PROGN
        (COND ((EQ (CAR G168634) 'SEGMENT) (CAR G168634)))
        (SPADLET |a| (CADR G168634))
        (SPADLET |b| (CADDR G168634))
        (SPADLET |$pilesAreOkHere| NIL)
        (AND (COND
               ((> 750 (|pspadBindingPowerOf| '|right| |a|))
                (|formatPren| |a|))
               ('T (|format| |a|)))
             (|formatInfixOp| (INTERN ".." "BOOT"))
             (OR (AND (NULL |b|) |$c|)
                 (COND
                   ((> 750 (|pspadBindingPowerOf| '|left| |b|))
                    (|formatPren| |b|))
                   ('T (|format| |b|)))))))))

;formatSexpr x ==
;  atom x =>
;    null x or IDENTP x => consBuffer ident2PrintImage PNAME x
;    consBuffer x
;  spill("formatNonAtom",x)

(DEFUN |formatSexpr| (|x|)
  (COND
    ((ATOM |x|)
     (COND
       ((OR (NULL |x|) (IDENTP |x|))
        (|consBuffer| (|ident2PrintImage| (PNAME |x|))))
       ('T (|consBuffer| |x|))))
    ('T (|spill| '|formatNonAtom| |x|))))

;formatNonAtom x ==
;  format "_(" and formatSexpr first x and
;    (and/[format " " and formatSexpr y for y in rest x])
;      and (y:= LASTATOM x => format " . "
;        and formatSexpr y; true) and format "_)"

(DEFUN |formatNonAtom| (|x|)
  (PROG (|y|)
    (RETURN
      (SEQ (AND (|format| '|(|) (|formatSexpr| (CAR |x|))
                (PROG (G168659)
                  (SPADLET G168659 'T)
                  (RETURN
                    (DO ((G168665 NIL (NULL G168659))
                         (G168666 (CDR |x|) (CDR G168666))
                         (|y| NIL))
                        ((OR G168665 (ATOM G168666)
                             (PROGN (SETQ |y| (CAR G168666)) NIL))
                         G168659)
                      (SEQ (EXIT (SETQ G168659
                                       (AND G168659
                                        (AND (|format| '| |)
                                         (|formatSexpr| |y|)))))))))
                (COND
                  ((SPADLET |y| (LASTATOM |x|))
                   (AND (|format| '| . |) (|formatSexpr| |y|)))
                  ('T 'T))
                (|format| '|)|))))))

;formatCAPSULE ['CAPSULE,:l,x] ==
;  $insideCAPSULE: local := true
;  try formatBlock(l,x) or formatPiles(l,x) or spillLine() and formatBlock(l,x)

(DEFUN |formatCAPSULE| (G168679)
  (PROG (|$insideCAPSULE| |LETTMP#1| |x| |l|)
    (DECLARE (SPECIAL |$insideCAPSULE|))
    (RETURN
      (PROGN
        (SPADLET |LETTMP#1| (REVERSE (CDR G168679)))
        (SPADLET |x| (CAR |LETTMP#1|))
        (SPADLET |l| (NREVERSE (CDR |LETTMP#1|)))
        (SPADLET |$insideCAPSULE| 'T)
        (OR (|try| (|formatBlock| |l| |x|)) (|formatPiles| |l| |x|)
            (AND (|spillLine|) (|formatBlock| |l| |x|)))))))

;formatPAREN [.,:argl] == formatFunctionCallTail argl

(DEFUN |formatPAREN| (G168699)
  (PROG (|argl|)
    (RETURN
      (PROGN
        (SPADLET |argl| (CDR G168699))
        (|formatFunctionCallTail| |argl|)))))

;formatSEQ ["SEQ",:l,[.,.,x]] ==
;  try formatBlock(l,x) or formatPiles(l,x) or spillLine() and formatBlock(l,x)

(DEFUN |formatSEQ| (G168710)
  (PROG (|LETTMP#1| |x| |l|)
    (RETURN
      (PROGN
        (COND ((EQ (CAR G168710) 'SEQ) (CAR G168710)))
        (SPADLET |LETTMP#1| (REVERSE (CDR G168710)))
        (SPADLET |x| (CADDAR |LETTMP#1|))
        (SPADLET |l| (NREVERSE (CDR |LETTMP#1|)))
        (OR (|try| (|formatBlock| |l| |x|)) (|formatPiles| |l| |x|)
            (AND (|spillLine|) (|formatBlock| |l| |x|)))))))

;--======================================================================
;--              Comment Handlers
;--======================================================================
;formatCOMMENT ["COMMENT",x,marg,startXY,endXY,commentStack] ==
;  $commentsToPrint:= [[marg,startXY,endXY,commentStack],:$commentsToPrint]
;  format x

(DEFUN |formatCOMMENT| (G168730)
  (PROG (|x| |marg| |startXY| |endXY| |commentStack|)
  (declare (special |$commentsToPrint|))
    (RETURN
      (PROGN
        (COND ((EQ (CAR G168730) 'COMMENT) (CAR G168730)))
        (SPADLET |x| (CADR G168730))
        (SPADLET |marg| (CADDR G168730))
        (SPADLET |startXY| (CADDDR G168730))
        (SPADLET |endXY| (CAR (CDDDDR G168730)))
        (SPADLET |commentStack| (CADR (CDDDDR G168730)))
        (SPADLET |$commentsToPrint|
                 (CONS (CONS |marg|
                             (CONS |startXY|
                                   (CONS |endXY|
                                    (CONS |commentStack| NIL))))
                       |$commentsToPrint|))
        (|format| |x|)))))

;formatComments(u,op,types) ==
;  $numberOfSpills :local := $commentIndentation/2 - 1
;  not $insideEXPORTS => u
;  alist := LASSOC(op,$comments) or
;    sayBrightly ['"No documentation for ",op]
;    return u
;  ftypes := SUBLISLIS($FormalMapVariableList,rest $form,types)
;  consComments(LASSOC(ftypes,alist),'"++ ")
;  u

(DEFUN |formatComments| (|u| |op| |types|)
  (PROG (|$numberOfSpills| |alist| |ftypes|)
    (DECLARE (SPECIAL |$numberOfSpills| |$form| |$FormalMapVariableList|
                      |$comments| |$insideEXPORTS| |$commentIndentation|))
    (RETURN
      (PROGN
        (SPADLET |$numberOfSpills|
                 (SPADDIFFERENCE (QUOTIENT |$commentIndentation| 2) 1))
        (COND
          ((NULL |$insideEXPORTS|) |u|)
          ('T
           (SPADLET |alist|
                    (OR (LASSOC |op| |$comments|)
                        (PROGN
                          (|sayBrightly|
                              (CONS "No documentation for "
                                    (CONS |op| NIL)))
                          (RETURN |u|))))
           (SPADLET |ftypes|
                    (SUBLISLIS |$FormalMapVariableList| (CDR |$form|)
                        |types|))
           (|consComments| (LASSOC |ftypes| |alist|)
               "++ ")
           |u|))))))

;consComments(s,plusPlus) ==
;  s is [word,:r] and null atom r => consComments(r, plusPlus)
;  s := first s
;  null s => nil
;  s := consCommentsTran s
;  indent() and newLine() or return nil
;  columnsLeft := $lineLength - $m - 2
;  while (m := MAXINDEX s) >= columnsLeft repeat
;    k := or/[i for i in (columnsLeft - 1)..1 by -1 | s.i = $charBlank]
;    k := (k => k + 1; columnsLeft)
;    piece := SUBSTRING(s,0,k)
;    formatDoCommentLine [plusPlus,piece]
;    s := SUBSTRING(s,k,nil)
;  formatDoCommentLine [plusPlus,s]
;  undent()
;  $m

(DEFUN |consComments| (|s| |plusPlus|)
  (PROG (|word| |r| |columnsLeft| |m| |k| |piece|)
  (declare (special |$m| |$charBlank| |$lineLength|))
    (RETURN
      (SEQ (COND
             ((AND (PAIRP |s|)
                   (PROGN
                     (SPADLET |word| (QCAR |s|))
                     (SPADLET |r| (QCDR |s|))
                     'T)
                   (NULL (ATOM |r|)))
              (|consComments| |r| |plusPlus|))
             ('T (SPADLET |s| (CAR |s|))
              (COND
                ((NULL |s|) NIL)
                ('T (SPADLET |s| (|consCommentsTran| |s|))
                 (OR (AND (|indent|) (|newLine|)) (RETURN NIL))
                 (SPADLET |columnsLeft|
                          (SPADDIFFERENCE
                              (SPADDIFFERENCE |$lineLength| |$m|) 2))
                 (DO ()
                     ((NULL (>= (SPADLET |m| (MAXINDEX |s|))
                                |columnsLeft|))
                      NIL)
                   (SEQ (EXIT (PROGN
                                (SPADLET |k|
                                         (PROG (G168783)
                                           (SPADLET G168783 NIL)
                                           (RETURN
                                             (DO
                                              ((G168790 NIL
                                                G168783)
                                               (G168791
                                                (SPADDIFFERENCE 1))
                                               (|i|
                                                (SPADDIFFERENCE
                                                 |columnsLeft| 1)
                                                (+ |i| G168791)))
                                              ((OR G168790
                                                (IF (MINUSP G168791)
                                                 (< |i| 1) (> |i| 1)))
                                               G168783)
                                               (SEQ
                                                (EXIT
                                                 (COND
                                                   ((BOOT-EQUAL
                                                     (ELT |s| |i|)
                                                     |$charBlank|)
                                                    (SETQ G168783
                                                    (OR G168783 |i|))))))))))
                                (SPADLET |k|
                                         (COND
                                           (|k| (PLUS |k| 1))
                                           ('T |columnsLeft|)))
                                (SPADLET |piece| (SUBSTRING |s| 0 |k|))
                                (|formatDoCommentLine|
                                    (CONS |plusPlus|
                                     (CONS |piece| NIL)))
                                (SPADLET |s| (SUBSTRING |s| |k| NIL))))))
                 (|formatDoCommentLine|
                     (CONS |plusPlus| (CONS |s| NIL)))
                 (|undent|) |$m|))))))))

;consCommentsTran s ==
;  m := MAXINDEX s
;  k := or/[i for i in 0..(m - 7) | substring?('"\spad{",s,i)] =>
;    r := charPosition(char '_},s,k + 6)
;    r = m + 1 => s
;    STRCONC(SUBSTRING(s,0,k),'"`",SUBSTRING(s,k+6,r-k-6),'"'",consCommentsTran SUBSTRING(s,r+1,nil))
;  s

(DEFUN |consCommentsTran| (|s|)
  (PROG (|m| |k| |r|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |m| (MAXINDEX |s|))
             (COND
               ((SPADLET |k|
                         (PROG (G168812)
                           (SPADLET G168812 NIL)
                           (RETURN
                             (DO ((G168819 NIL G168812)
                                  (G168820 (SPADDIFFERENCE |m| 7))
                                  (|i| 0 (QSADD1 |i|)))
                                 ((OR G168819
                                      (QSGREATERP |i| G168820))
                                  G168812)
                               (SEQ (EXIT
                                     (COND
                                       ((|substring?|
                                         "\\spad{" |s|
                                         |i|)
                                        (SETQ G168812
                                         (OR G168812 |i|))))))))))
                (SPADLET |r|
                         (|charPosition| (|char| '}) |s| (PLUS |k| 6)))
                (COND
                  ((BOOT-EQUAL |r| (PLUS |m| 1)) |s|)
                  ('T
                   (STRCONC (SUBSTRING |s| 0 |k|) "`"
                            (SUBSTRING |s| (PLUS |k| 6)
                                (SPADDIFFERENCE
                                    (SPADDIFFERENCE |r| |k|) 6))
                            "'"
                            (|consCommentsTran|
                                (SUBSTRING |s| (PLUS |r| 1) NIL))))))
               ('T |s|)))))))

;formatDoCommentLine line ==
;  $lineBuffer := consLineBuffer [nBlanks $c,:line]
;  $c := $m+2*$numberOfSpills

(DEFUN |formatDoCommentLine| (|line|)
  (declare (special |$numberOfSpills| |$lineBuffer| |$c| |$m|))
  (PROGN
    (SPADLET |$lineBuffer|
             (|consLineBuffer| (CONS (|nBlanks| |$c|) |line|)))
    (SPADLET |$c| (PLUS |$m| (TIMES 2 |$numberOfSpills|)))))

;--======================================================================
;--                  Pile Handlers
;--======================================================================
;formatPreferPile y ==
;  y is ["SEQ",:l,[.,.,x]] =>
;    (u:= formatPiles(l,x)) => u
;    formatSpill("format",y)
;  formatSpill("format",y)

(DEFUN |formatPreferPile| (|y|)
  (PROG (|ISTMP#1| |ISTMP#2| |ISTMP#3| |ISTMP#4| |ISTMP#5| |x| |l| |u|)
    (RETURN
      (COND
        ((AND (PAIRP |y|) (EQ (QCAR |y|) 'SEQ)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |y|))
                (AND (PAIRP |ISTMP#1|)
                     (PROGN
                       (SPADLET |ISTMP#2| (REVERSE |ISTMP#1|))
                       'T)
                     (PAIRP |ISTMP#2|)
                     (PROGN
                       (SPADLET |ISTMP#3| (QCAR |ISTMP#2|))
                       (AND (PAIRP |ISTMP#3|)
                            (PROGN
                              (SPADLET |ISTMP#4| (QCDR |ISTMP#3|))
                              (AND (PAIRP |ISTMP#4|)
                                   (PROGN
                                     (SPADLET |ISTMP#5|
                                      (QCDR |ISTMP#4|))
                                     (AND (PAIRP |ISTMP#5|)
                                      (EQ (QCDR |ISTMP#5|) NIL)
                                      (PROGN
                                        (SPADLET |x| (QCAR |ISTMP#5|))
                                        'T)))))))
                     (PROGN (SPADLET |l| (QCDR |ISTMP#2|)) 'T)
                     (PROGN (SPADLET |l| (NREVERSE |l|)) 'T))))
         (COND
           ((SPADLET |u| (|formatPiles| |l| |x|)) |u|)
           ('T (|formatSpill| '|format| |y|))))
        ('T (|formatSpill| '|format| |y|))))))

;formatPiles(l,x) ==
;  $insideTypeExpression : local := false
;  not $pilesAreOkHere => nil
;  originalC:= $c
;  lines:= [:l,x]
;                                                --piles must begin at margin
;  originalC=$m or indent() and newLine() or return nil
;  null (formatPileLine($m,first lines,false)) => nil
;  not (and/[formatPileLine($m,y,true) for y in rest lines]) => nil
;  (originalC=$m or undent()) and originalC          --==> brace

(DEFUN |formatPiles| (|l| |x|)
  (PROG (|$insideTypeExpression| |originalC| |lines|)
    (DECLARE (SPECIAL |$insideTypeExpression| |$m| |$c| |$pilesAreOkHere|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |$insideTypeExpression| NIL)
             (COND
               ((NULL |$pilesAreOkHere|) NIL)
               ('T (SPADLET |originalC| |$c|)
                (SPADLET |lines| (APPEND |l| (CONS |x| NIL)))
                (OR (BOOT-EQUAL |originalC| |$m|)
                    (AND (|indent|) (|newLine|)) (RETURN NIL))
                (COND
                  ((NULL (|formatPileLine| |$m| (CAR |lines|) NIL))
                   NIL)
                  ((NULL (PROG (G168887)
                           (SPADLET G168887 'T)
                           (RETURN
                             (DO ((G168893 NIL (NULL G168887))
                                  (G168894 (CDR |lines|)
                                      (CDR G168894))
                                  (|y| NIL))
                                 ((OR G168893 (ATOM G168894)
                                      (PROGN
                                        (SETQ |y| (CAR G168894))
                                        NIL))
                                  G168887)
                               (SEQ (EXIT
                                     (SETQ G168887
                                      (AND G168887
                                       (|formatPileLine| |$m| |y| 'T)))))))))
                   NIL)
                  ('T
                   (AND (OR (BOOT-EQUAL |originalC| |$m|) (|undent|))
                        |originalC|))))))))))

;formatPileLine($m,x,newLineIfTrue) ==
;  if newLineIfTrue then newLine() or return nil
;  $numberOfSpills: local:= 0
;  $newLineWritten := nil
;  format x and (x is ['SIGNATURE,:.] or $rightBraceFlag => $c; formatSC())
;    and (x is ['DEF,:.] and optNewLine() or $c)

(DEFUN |formatPileLine| (|$m| |x| |newLineIfTrue|)
  (DECLARE (SPECIAL |$m|))
  (PROG (|$numberOfSpills|)
    (DECLARE (SPECIAL |$numberOfSpills| |$c| |$rightBraceFlag|
                      |$newLineWritten| |$numberOfSpills|))
    (RETURN
      (PROGN
        (COND (|newLineIfTrue| (OR (|newLine|) (RETURN NIL))))
        (SPADLET |$numberOfSpills| 0)
        (SPADLET |$newLineWritten| NIL)
        (AND (|format| |x|)
             (COND
               ((OR (AND (PAIRP |x|) (EQ (QCAR |x|) 'SIGNATURE))
                    |$rightBraceFlag|)
                |$c|)
               ('T (|formatSC|)))
             (OR (AND (PAIRP |x|) (EQ (QCAR |x|) 'DEF) (|optNewLine|))
                 |$c|))))))

;--======================================================================
;--                       Utility Functions
;--======================================================================
;nBlanks m == "STRCONC"/[char('_  ) for i in 1..m]

(DEFUN |nBlanks| (|m|)
  (PROG ()
    (RETURN
      (SEQ (PROG (G168920)
             (SPADLET G168920 "")
             (RETURN
               (DO ((|i| 1 (QSADD1 |i|)))
                   ((QSGREATERP |i| |m|) G168920)
                 (SEQ (EXIT (SETQ G168920
                                  (STRCONC G168920 (|char| '| |))))))))))))

;isNewspadOperator op == GET(op,"Led") or GET(op,"Nud")

(DEFUN |isNewspadOperator| (|op|)
  (OR (GETL |op| '|Led|) (GETL |op| '|Nud|)))

;isTrue x == x="true" or x is '(QUOTE T)

(DEFUN |isTrue| (|x|) (OR (BOOT-EQUAL |x| '|true|) (EQUAL |x| ''T)))

;nary2Binary(u,op) ==
;  u is [a,b,:t] => (t => nary2Binary([[op,a,b],:t],op); [op,a,b])
;  errhuh()

(DEFUN |nary2Binary| (|u| |op|)
  (PROG (|a| |ISTMP#1| |b| |t|)
    (RETURN
      (COND
        ((AND (PAIRP |u|)
              (PROGN
                (SPADLET |a| (QCAR |u|))
                (SPADLET |ISTMP#1| (QCDR |u|))
                (AND (PAIRP |ISTMP#1|)
                     (PROGN
                       (SPADLET |b| (QCAR |ISTMP#1|))
                       (SPADLET |t| (QCDR |ISTMP#1|))
                       'T))))
         (COND
           (|t| (|nary2Binary|
                    (CONS (CONS |op| (CONS |a| (CONS |b| NIL))) |t|)
                    |op|))
           ('T (CONS |op| (CONS |a| (CONS |b| NIL))))))
        ('T (|errhuh|))))))

;string2PrintImage s ==
;  u:= GETSTR (2*SIZE s)
;  for i in 0..MAXINDEX s repeat
;    (if MEMQ(s.i,'(_( _{ _) _} _! _")) then
;      SUFFIX('__,u); u:= SUFFIX(s.i,u))
;  u

(DEFUN |string2PrintImage| (|s|)
  (PROG (|u|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |u| (GETSTR (TIMES 2 (SIZE |s|))))
             (DO ((G168968 (MAXINDEX |s|)) (|i| 0 (QSADD1 |i|)))
                 ((QSGREATERP |i| G168968) NIL)
               (SEQ (EXIT (PROGN
                            (COND
                              ((MEMQ (ELT |s| |i|)
                                     '(|(| { |)| } ! |"|))
                               (SUFFIX '_ |u|)))
                            (SPADLET |u| (SUFFIX (ELT |s| |i|) |u|))))))
             |u|)))))

;ident2PrintImage s ==
;  m := MAXINDEX s
;  if m > 1 and s.(m - 1) = $underScore then s := STRCONC(SUBSTRING(s,0,m-1),s.m)
;  u:= GETSTR (2*SIZE s)
;  if not (ALPHA_-CHAR_-P s.(0) or s.(0)=char '"$") then SUFFIX('__,u)
;  u:= SUFFIX(s.(0),u)
;  for i in 1..MAXINDEX s repeat
;    if not (DIGITP s.i or ALPHA_-CHAR_-P s.i or ((c := s.i) = char '?)
;      or (c = char '!)) then SUFFIX('__,u)
;    u:= SUFFIX(s.i,u)
;  INTERN u

(DEFUN |ident2PrintImage| (|s|)
  (PROG (|m| |c| |u|)
  (declare (special |$underScore|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |m| (MAXINDEX |s|))
             (COND
               ((AND (> |m| 1)
                     (BOOT-EQUAL (ELT |s| (SPADDIFFERENCE |m| 1))
                         |$underScore|))
                (SPADLET |s|
                         (STRCONC (SUBSTRING |s| 0
                                      (SPADDIFFERENCE |m| 1))
                                  (ELT |s| |m|)))))
             (SPADLET |u| (GETSTR (TIMES 2 (SIZE |s|))))
             (COND
               ((NULL (OR (ALPHA-CHAR-P (ELT |s| 0))
                          (BOOT-EQUAL (ELT |s| 0)
                              (|char| "$"))))
                (SUFFIX '_ |u|)))
             (SPADLET |u| (SUFFIX (ELT |s| 0) |u|))
             (DO ((G168984 (MAXINDEX |s|)) (|i| 1 (QSADD1 |i|)))
                 ((QSGREATERP |i| G168984) NIL)
               (SEQ (EXIT (PROGN
                            (COND
                              ((NULL (OR (DIGITP (ELT |s| |i|))
                                      (ALPHA-CHAR-P (ELT |s| |i|))
                                      (BOOT-EQUAL
                                       (SPADLET |c| (ELT |s| |i|))
                                       (|char| '?))
                                      (BOOT-EQUAL |c| (|char| '!))))
                               (SUFFIX '_ |u|)))
                            (SPADLET |u| (SUFFIX (ELT |s| |i|) |u|))))))
             (INTERN |u|))))))

;isIdentifier x ==
;  IDENTP x =>
;    s:= PNAME x
;    #s = 0 => nil
;    ALPHA_-CHAR_-P s.(0) => and/[s.i^=char '" " for i in 1..MAXINDEX s]
;    #s>1 =>
;      or/[ALPHA_-CHAR_-P s.i for i in 1..(m:= MAXINDEX s)] =>
;        and/[s.i^=char '" " for i in 1..m] => true

(DEFUN |isIdentifier| (|x|)
  (PROG (|s| |m|)
    (RETURN
      (SEQ (COND
             ((IDENTP |x|)
              (EXIT (PROGN
                      (SPADLET |s| (PNAME |x|))
                      (SEQ (COND
                             ((EQL (|#| |s|) 0) NIL)
                             ((ALPHA-CHAR-P (ELT |s| 0))
                              (PROG (G168998)
                                (SPADLET G168998 'T)
                                (RETURN
                                  (DO ((G169004 NIL (NULL G168998))
                                       (G169005 (MAXINDEX |s|))
                                       (|i| 1 (QSADD1 |i|)))
                                      ((OR G169004
                                        (QSGREATERP |i| G169005))
                                       G168998)
                                    (SEQ
                                     (EXIT
                                      (SETQ G168998
                                       (AND G168998
                                        (NEQUAL (ELT |s| |i|)
                                         (|char| " "))))))))))
                             ('T
                              (COND
                                ((> (|#| |s|) 1)
                                 (COND
                                   ((PROG (G169010)
                                      (SPADLET G169010 NIL)
                                      (RETURN
                                        (DO
                                         ((G169016 NIL G169010)
                                          (G169017
                                           (SPADLET |m| (MAXINDEX |s|)))
                                          (|i| 1 (QSADD1 |i|)))
                                         ((OR G169016
                                           (QSGREATERP |i| G169017))
                                          G169010)
                                          (SEQ
                                           (EXIT
                                            (SETQ G169010
                                             (OR G169010
                                              (ALPHA-CHAR-P
                                               (ELT |s| |i|)))))))))
                                    (EXIT
                                     (COND
                                       ((PROG (G169022)
                                          (SPADLET G169022 'T)
                                          (RETURN
                                            (DO
                                             ((G169028 NIL
                                               (NULL G169022))
                                              (|i| 1 (QSADD1 |i|)))
                                             ((OR G169028
                                               (QSGREATERP |i| |m|))
                                              G169022)
                                              (SEQ
                                               (EXIT
                                                (SETQ G169022
                                                 (AND G169022
                                                  (NEQUAL (ELT |s| |i|)
                                                   (|char|
                                                    " ")))))))))
                                        (EXIT 'T)))))))))))))))))))

;isGensym x ==
;  s := STRINGIMAGE x
;  n := MAXINDEX s
;  s.0 = char '_G and and/[DIGITP s.i for i in 1..n]

(DEFUN |isGensym| (|x|)
  (PROG (|s| |n|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |s| (STRINGIMAGE |x|))
             (SPADLET |n| (MAXINDEX |s|))
             (AND (BOOT-EQUAL (ELT |s| 0) (|char| 'G))
                  (PROG (G169042)
                    (SPADLET G169042 'T)
                    (RETURN
                      (DO ((G169048 NIL (NULL G169042))
                           (|i| 1 (QSADD1 |i|)))
                          ((OR G169048 (QSGREATERP |i| |n|))
                           G169042)
                        (SEQ (EXIT (SETQ G169042
                                    (AND G169042
                                     (DIGITP (ELT |s| |i|)))))))))))))))

;--======================================================================
;--                       Macro Helpers
;--======================================================================
;tryToFit(s,x) ==
;--% try to format on current line; see macro try in file PSPADAUX LISP
;  --returns nil if unable to format stuff in x on a single line
;  x => ($back:= rest $back; $c)
;  restoreState()
;  nil

(DEFUN |tryToFit| (|s| |x|)
  (declare (special |$back| |$c|) (ignore |s|))
  (COND
    (|x| (SPADLET |$back| (CDR |$back|)) |$c|)
    ('T (|restoreState|) NIL)))

;restoreState(:options) ==
;  back := IFCAR options or $back
;  [
;    [$lineBuffer, $lineFragmentBuffer,$comments,$marginStack,$braceStack,$DEFdepth,
;      $bc,$c,$m,$commentsToPrint,$numberOfSpills,flags], :back]
;        := back
;  if null options then $back := back
;  [$newLineWritten, $autoLine, $rightBraceFlag,
;      $semicolonFlag,$insideDEF,$insideTypeExpression,$pilesAreOkHere,
;       $insideEXPORTS, $insideCAPSULE, $insideCategoryIfTrue,
;         $doNotResetMarginIfTrue,$noColonDeclaration]
;           := flags
;  nil

(DEFUN |restoreState| (&REST G169139 &AUX |options|)
  (DSETQ |options| G169139)
  (PROG (|LETTMP#1| |flags| |back|)
  (declare (special |$noColonDeclaration| |$doNotResetMarginIfTrue|
                    |$insideCategoryIfTrue| |$insideCAPSULE|
                    |$insideEXPORTS| |$pilesAreOkHere| |$insideTypeExpression|
                    |$insideDEF| |$semicolonFlag| |$rightBraceFlag|
                    |$autoLine| |$newLineWritten| |$back| |$numberOfSpills|
                    |$commentsToPrint| |$m| |$c| |$bc| |$DEFdepth|
                    |$braceStack| |$marginStack| |$comments| |$lineBuffer|
                    |$lineFragmentBuffer|))
    (RETURN
      (PROGN
        (SPADLET |back| (OR (IFCAR |options|) |$back|))
        (SPADLET |LETTMP#1| |back|)
        (SPADLET |$lineBuffer| (CAAR |LETTMP#1|))
        (SPADLET |$lineFragmentBuffer| (CADAR |LETTMP#1|))
        (SPADLET |$comments| (CADDAR |LETTMP#1|))
        (SPADLET |$marginStack| (CAR (CDDDAR |LETTMP#1|)))
        (SPADLET |$braceStack| (CADR (CDDDAR |LETTMP#1|)))
        (SPADLET |$DEFdepth| (CADDR (CDDDAR |LETTMP#1|)))
        (SPADLET |$bc| (CADDDR (CDDDAR |LETTMP#1|)))
        (SPADLET |$c| (CAR (CDDDDR (CDDDAR |LETTMP#1|))))
        (SPADLET |$m| (CADR (CDDDDR (CDDDAR |LETTMP#1|))))
        (SPADLET |$commentsToPrint|
                 (CADDR (CDDDDR (CDDDAR |LETTMP#1|))))
        (SPADLET |$numberOfSpills|
                 (CADDDR (CDDDDR (CDDDAR |LETTMP#1|))))
        (SPADLET |flags| (CAR (CDDDDR (CDDDDR (CDDDAR |LETTMP#1|)))))
        (SPADLET |back| (CDR |LETTMP#1|))
        (COND ((NULL |options|) (SPADLET |$back| |back|)))
        (SPADLET |$newLineWritten| (CAR |flags|))
        (SPADLET |$autoLine| (CADR |flags|))
        (SPADLET |$rightBraceFlag| (CADDR |flags|))
        (SPADLET |$semicolonFlag| (CADDDR |flags|))
        (SPADLET |$insideDEF| (CAR (CDDDDR |flags|)))
        (SPADLET |$insideTypeExpression| (CADR (CDDDDR |flags|)))
        (SPADLET |$pilesAreOkHere| (CADDR (CDDDDR |flags|)))
        (SPADLET |$insideEXPORTS| (CADDDR (CDDDDR |flags|)))
        (SPADLET |$insideCAPSULE| (CAR (CDDDDR (CDDDDR |flags|))))
        (SPADLET |$insideCategoryIfTrue|
                 (CADR (CDDDDR (CDDDDR |flags|))))
        (SPADLET |$doNotResetMarginIfTrue|
                 (CADDR (CDDDDR (CDDDDR |flags|))))
        (SPADLET |$noColonDeclaration|
                 (CADDDR (CDDDDR (CDDDDR |flags|))))
        NIL))))

;saveState(:options) ==
;  flags :=
;    [$newLineWritten, $autoLine, $rightBraceFlag,
;      $semicolonFlag,$insideDEF,$insideTypeExpression,$pilesAreOkHere,
;       $insideEXPORTS, $insideCAPSULE, $insideCategoryIfTrue,
;         $doNotResetMarginIfTrue,$noColonDeclaration]
;  newState :=
;   [
;    [$lineBuffer, $lineFragmentBuffer,$comments,$marginStack,$braceStack,$DEFdepth,
;      $bc,$c,$m,$commentsToPrint,$numberOfSpills,flags], :$back]
;  if not KAR options then $back := newState
;  newState

(DEFUN |saveState| (&REST G169147 &AUX |options|)
  (DSETQ |options| G169147)
  (PROG (|flags| |newState|)
  (declare (special |$back| |$numberOfSpills| |$commentsToPrint| |$m| |$c|
                    |$bc| |$DEFdepth| |$braceStack| |$marginStack|
                    |$comments| |$lineFragmentBuffer| |$lineBuffer|
                    |$newLineWritten| |$autoLine| |$rightBraceFlag|
                    |$semicolonFlag| |$insideDEF| |$insideTypeExpression|
                    |$pilesAreOkHere| |$insideEXPORTS| |$insideCAPSULE|
                    |$doNotResetMarginIfTrue| |$noColonDeclaration|))
    (RETURN
      (PROGN
        (SPADLET |flags|
                 (CONS |$newLineWritten|
                       (CONS |$autoLine|
                             (CONS |$rightBraceFlag|
                                   (CONS |$semicolonFlag|
                                    (CONS |$insideDEF|
                                     (CONS |$insideTypeExpression|
                                      (CONS |$pilesAreOkHere|
                                       (CONS |$insideEXPORTS|
                                        (CONS |$insideCAPSULE|
                                         (CONS |$insideCategoryIfTrue|
                                          (CONS
                                           |$doNotResetMarginIfTrue|
                                           (CONS |$noColonDeclaration|
                                            NIL)))))))))))))
        (SPADLET |newState|
                 (CONS (CONS |$lineBuffer|
                             (CONS |$lineFragmentBuffer|
                                   (CONS |$comments|
                                    (CONS |$marginStack|
                                     (CONS |$braceStack|
                                      (CONS |$DEFdepth|
                                       (CONS |$bc|
                                        (CONS |$c|
                                         (CONS |$m|
                                          (CONS |$commentsToPrint|
                                           (CONS |$numberOfSpills|
                                            (CONS |flags| NIL))))))))))))
                       |$back|))
        (COND ((NULL (KAR |options|)) (SPADLET |$back| |newState|)))
        |newState|))))

;formatSC() ==
;  $pileStyle or $semicolonFlag => $c
;  format "; "

(DEFUN |formatSC| ()
  (declare (special |$pileStyle| |$semicolonFlag| |$c|))
  (COND
    ((OR |$pileStyle| |$semicolonFlag|) |$c|)
    ('T (|format| '|; |))))

;wrapBraces(x,y,z) == y

(DEFUN |wrapBraces| (|x| |y| |z|)
 (declare (ignore |x| |z|))
 |y|) 

;formatLB() ==
;  $pileStyle => $c
;  $numberOfSpills :=
;    $c > $lineLength / 2 => $braceIndentation/3 - 1
;    $braceIndentation/2 - 1
;  format "{"

(DEFUN |formatLB| ()
  (declare (special |$braceIndentation| |$lineLength| |$numberOfSpills| |$c|
                    |$pileStyle|))
  (COND
    (|$pileStyle| |$c|)
    ('T
     (SPADLET |$numberOfSpills|
              (COND
                ((> |$c| (QUOTIENT |$lineLength| 2))
                 (SPADDIFFERENCE (QUOTIENT |$braceIndentation| 3) 1))
                ('T
                 (SPADDIFFERENCE (QUOTIENT |$braceIndentation| 2) 1))))
     (|format| '{))))

;restoreC() == --used by macro "embrace"
;  originalC := CAR $braceStack
;  $braceStack := CDR $braceStack
;  formatRB originalC

(DEFUN |restoreC| ()
  (PROG (|originalC|)
  (declare (special |$braceStack|))
    (RETURN
      (PROGN
        (SPADLET |originalC| (CAR |$braceStack|))
        (SPADLET |$braceStack| (CDR |$braceStack|))
        (|formatRB| |originalC|)))))

;saveC() ==  --used by macro "embrace"
;  $braceStack := [$c,:$braceStack]

(DEFUN |saveC| ()
 (declare (special |$braceStack| |$c|))
 (SPADLET |$braceStack| (CONS |$c| |$braceStack|)))

;saveD() ==  --used by macro "embrace"
;  $braceStack := [$c,:$braceStack]

(DEFUN |saveD| ()
 (declare (special |$braceStack| |$c|))
 (SPADLET |$braceStack| (CONS |$c| |$braceStack|)))

;restoreD() == --used by macro "indentNB"
;  originalC := CAR $braceStack
;  $braceStack := CDR $braceStack
;  originalC

(DEFUN |restoreD| ()
  (PROG (|originalC|)
  (declare (special |$braceStack|))
    (RETURN
      (PROGN
        (SPADLET |originalC| (CAR |$braceStack|))
        (SPADLET |$braceStack| (CDR |$braceStack|))
        |originalC|))))

;formatRB(originalC) == --called only by restoreC
;  while $marginStack and $m > originalC repeat undent()
;  if $m < originalC then $marginStack := [originalC,:$marginStack]
;  $m := originalC
;  $pileStyle => $m
;  newLine() and format "}" and $m    --==> brace

(DEFUN |formatRB| (|originalC|)
  (declare (special |$m| |$pileStyle| |$marginStack|))
  (SEQ (PROGN
         (DO () ((NULL (AND |$marginStack| (> |$m| |originalC|))) NIL)
           (SEQ (EXIT (|undent|))))
         (COND
           ((> |originalC| |$m|)
            (SPADLET |$marginStack| (CONS |originalC| |$marginStack|))))
         (SPADLET |$m| |originalC|)
         (COND
           (|$pileStyle| |$m|)
           ('T (AND (|newLine|) (|format| '}) |$m|))))))

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
