\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp i-coerce.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{Coercion conventions}
\begin{verbatim}
Coercion conventions

Coercion involves the  changing of the datatype of an  object.  This
   can be  done for conformality of  operations or, for  example, to
   change the structure of an object  into one that is understood by
   the printing routines.

The actual coercion  is controlled  by the  function "coerce"  which
   takes  and delivers  wrapped operands.   Also  see the  functions
   interpCoerce and coerceInteractive.

Sometimes one  does not  want to  actually change  the datatype  but
   rather wants to determine  whether it is possible to do  so.  The
   controlling function  to do this  is "canCoerceFrom".   The value
   passed   to  specific   coercion  routines   in   this  case   is
   "$fromCoerceable$".   The value returned is  true or false.   See
   specific examples for more info.

The special routines that  do the coercions typically  involve a "2"
   in their  names.   For example, G2E  converts type  "Gaussian" to
   type  "Expression".   These  special  routines take  and  deliver
   unwrapped operands.   The determination of which  special routine
   to  use  is  often  made  by  consulting  the  list  $CoerceTable
   (currently in COT BOOT) and  this is controlled by coerceByTable.
   Note that the special routines are in the file COERCEFN BOOT.
\end{verbatim}
\begin{chunk}{*}
(IN-PACKAGE "BOOT" )

;--%  Algebraic coercions using interactive code
;algCoerceInteractive(p,source,target) ==
;  -- now called in some groebner code
;  $useConvertForCoercions : local := true
;  source := devaluate source
;  target := devaluate target
;  u := coerceInteractive(objNewWrap(p,source),target)
;  u => objValUnwrap(u)
;  error ['"can't convert",p,'"of mode",source,'"to mode",target]

(DEFUN |algCoerceInteractive| (|p| |source| |target|)
  (PROG (|$useConvertForCoercions| |u|)
    (DECLARE (SPECIAL |$useConvertForCoercions|))
    (RETURN
      (PROGN
        (SPADLET |$useConvertForCoercions| 'T)
        (SPADLET |source| (|devaluate| |source|))
        (SPADLET |target| (|devaluate| |target|))
        (SPADLET |u|
                 (|coerceInteractive| (|objNewWrap| |p| |source|)
                     |target|))
        (COND
          (|u| (|objValUnwrap| |u|))
          ('T
           (|error| (CONS "can't convert"
                          (CONS |p|
                                (CONS "of mode"
                                      (CONS |source|
                                       (CONS "to mode"
                                        (CONS |target| NIL)))))))))))))


;spad2BootCoerce(x,source,target) ==
;  -- x : source and we wish to coerce to target
;  -- used in spad code for Any
;  null isValidType source => throwKeyedMsg("S2IE0004",[source])
;  null isValidType target => throwKeyedMsg("S2IE0004",[target])
;  x' := coerceInteractive(objNewWrap(x,source),target) =>
;    objValUnwrap(x')
;  throwKeyedMsgCannotCoerceWithValue(wrap x,source,target)

(DEFUN |spad2BootCoerce| (|x| |source| |target|)
  (PROG (|x'|)
    (RETURN
      (COND
        ((NULL (|isValidType| |source|))
         (|throwKeyedMsg| 'S2IE0004 (CONS |source| NIL)))
        ((NULL (|isValidType| |target|))
         (|throwKeyedMsg| 'S2IE0004 (CONS |target| NIL)))
        ((SPADLET |x'|
                  (|coerceInteractive| (|objNewWrap| |x| |source|)
                      |target|))
         (|objValUnwrap| |x'|))
        ('T
         (|throwKeyedMsgCannotCoerceWithValue| (|wrap| |x|) |source|
             |target|))))))

;--%  Functions for Coercion or Else We'll Get Rough
;coerceOrFail(triple,t,mapName) ==
;  -- some code generated for this is in coerceInt0
;  t = $NoValueMode => triple
;  t' := coerceInteractive(triple,t)
;  t' => objValUnwrap(t')
;  sayKeyedMsg("S2IC0004",[mapName,objMode triple,t])
;  '"failed"

(DEFUN |coerceOrFail| (|triple| |t| |mapName|)
  (PROG (|t'|)
    (DECLARE (SPECIAL |$NoValueMode|))
    (RETURN
      (COND
        ((BOOT-EQUAL |t| |$NoValueMode|) |triple|)
        ('T (SPADLET |t'| (|coerceInteractive| |triple| |t|))
         (COND
           (|t'| (|objValUnwrap| |t'|))
           ('T
            (|sayKeyedMsg| 'S2IC0004
                (CONS |mapName|
                      (CONS (|objMode| |triple|) (CONS |t| NIL))))
            "failed")))))))

;coerceOrCroak(triple, t, mapName) ==
;  -- this does the coercion and returns the value or dies
;  t = $NoValueMode => triple
;  t' := coerceOrConvertOrRetract(triple,t)
;  t' => objValUnwrap(t')
;  mapName = 'noMapName =>
;    throwKeyedMsgCannotCoerceWithValue(objVal triple,objMode triple, t)
;  sayKeyedMsg("S2IC0005",[mapName])
;  throwKeyedMsgCannotCoerceWithValue(objVal triple,objMode triple, t)

(DEFUN |coerceOrCroak| (|triple| |t| |mapName|)
  (PROG (|t'|)
    (DECLARE (SPECIAL |$NoValueMode|))
    (RETURN
      (COND
        ((BOOT-EQUAL |t| |$NoValueMode|) |triple|)
        ('T (SPADLET |t'| (|coerceOrConvertOrRetract| |triple| |t|))
         (COND
           (|t'| (|objValUnwrap| |t'|))
           ((BOOT-EQUAL |mapName| '|noMapName|)
            (|throwKeyedMsgCannotCoerceWithValue| (|objVal| |triple|)
                (|objMode| |triple|) |t|))
           ('T (|sayKeyedMsg| 'S2IC0005 (CONS |mapName| NIL))
            (|throwKeyedMsgCannotCoerceWithValue| (|objVal| |triple|)
                (|objMode| |triple|) |t|))))))))

;coerceOrThrowFailure(value, t1, t2) ==
;  (result := coerceOrRetract(objNewWrap(value, t1), t2)) or
;    coercionFailure()
;  objValUnwrap(result)

(DEFUN |coerceOrThrowFailure| (|value| |t1| |t2|)
  (PROG (|result|)
    (RETURN
      (PROGN
        (OR (SPADLET |result|
                     (|coerceOrRetract| (|objNewWrap| |value| |t1|)
                         |t2|))
            (|coercionFailure|))
        (|objValUnwrap| |result|)))))

;--%  Retraction functions
;retract object ==
;  type := objMode object
;  STRINGP type => 'failed
;  type = $EmptyMode => 'failed
;  val := objVal object
;  not isWrapped val and val isnt ['MAP,:.] => 'failed
;  type' := equiType(type)
;  (ans := retract1 objNew(val,equiType(type))) = 'failed => ans
;  objNew(objVal ans,eqType objMode ans)

(DEFUN |retract| (|object|)
  (PROG (|type| |val| |type'| |ans|)
    (DECLARE (SPECIAL |$EmptyMode|))
    (RETURN
      (PROGN
        (SPADLET |type| (|objMode| |object|))
        (COND
          ((STRINGP |type|) '|failed|)
          ((BOOT-EQUAL |type| |$EmptyMode|) '|failed|)
          ('T (SPADLET |val| (|objVal| |object|))
           (COND
             ((AND (NULL (|isWrapped| |val|))
                   (NULL (AND (CONSP |val|) (EQ (QCAR |val|) 'MAP))))
              '|failed|)
             ('T (SPADLET |type'| (|equiType| |type|))
              (COND
                ((BOOT-EQUAL
                     (SPADLET |ans|
                              (|retract1|
                                  (|objNew| |val| (|equiType| |type|))))
                     '|failed|)
                 |ans|)
                ('T
                 (|objNew| (|objVal| |ans|)
                     (|eqType| (|objMode| |ans|)))))))))))))

;retract1 object ==
;  -- this function is the new version of the old "pullback"
;  -- it first tries to change the datatype of an object to that of
;  -- largest contained type. Examples: P RN -> RN, RN -> I
;  -- This is mostly for cases such as constant polynomials or
;  -- quotients with 1 in the denominator.
;  type := objMode object
;  STRINGP type => 'failed
;  val := objVal object
;  type = $PositiveInteger =>    objNew(val,$NonNegativeInteger)
;  type = $NonNegativeInteger => objNew(val,$Integer)
;  type = $Integer and SINTP unwrap val => objNew(val, $SingleInteger)
;  type' := equiType(type)
;  if not EQ(type,type') then object := objNew(val,type')
;  (1 = #type') or (type' is ['Union,:.]) or
;    (type' is ['FunctionCalled,.])
;     or (type' is ['OrderedVariableList,.]) or (type is ['Variable,.]) =>
;      (object' := retract2Specialization(object)) => object'
;      'failed
;  null (underDomain := underDomainOf type') => 'failed
;  -- try to retract the "coefficients"
;  -- think of P RN -> P I or M RN -> M I
;  object' := retractUnderDomain(object,type,underDomain)
;  object' ^= 'failed => object'
;  -- see if we can use the retract functions
;  (object' := coerceRetract(object,underDomain)) => object'
;  -- see if we have a special case here
;  (object' := retract2Specialization(object)) => object'
;  'failed

(DEFUN |retract1| (|object|)
  (PROG (|type| |val| |type'| |ISTMP#1| |underDomain| |object'|)
    (DECLARE (SPECIAL |$SingleInteger| |$Integer| |$NonNegativeInteger|
                      |$PositiveInteger|))
    (RETURN
      (PROGN
        (SPADLET |type| (|objMode| |object|))
        (COND
          ((STRINGP |type|) '|failed|)
          ('T (SPADLET |val| (|objVal| |object|))
           (COND
             ((BOOT-EQUAL |type| |$PositiveInteger|)
              (|objNew| |val| |$NonNegativeInteger|))
             ((BOOT-EQUAL |type| |$NonNegativeInteger|)
              (|objNew| |val| |$Integer|))
             ((AND (BOOT-EQUAL |type| |$Integer|)
                   (typep (|unwrap| |val|) 'fixnum))
              (|objNew| |val| |$SingleInteger|))
             ('T (SPADLET |type'| (|equiType| |type|))
              (COND
                ((NULL (EQ |type| |type'|))
                 (SPADLET |object| (|objNew| |val| |type'|))))
              (COND
                ((OR (EQL 1 (|#| |type'|))
                     (AND (CONSP |type'|) (EQ (QCAR |type'|) '|Union|))
                     (AND (CONSP |type'|)
                          (EQ (QCAR |type'|) '|FunctionCalled|)
                          (PROGN
                            (SPADLET |ISTMP#1| (QCDR |type'|))
                            (AND (CONSP |ISTMP#1|)
                                 (EQ (QCDR |ISTMP#1|) NIL))))
                     (AND (CONSP |type'|)
                          (EQ (QCAR |type'|) '|OrderedVariableList|)
                          (PROGN
                            (SPADLET |ISTMP#1| (QCDR |type'|))
                            (AND (CONSP |ISTMP#1|)
                                 (EQ (QCDR |ISTMP#1|) NIL))))
                     (AND (CONSP |type|) (EQ (QCAR |type|) '|Variable|)
                          (PROGN
                            (SPADLET |ISTMP#1| (QCDR |type|))
                            (AND (CONSP |ISTMP#1|)
                                 (EQ (QCDR |ISTMP#1|) NIL)))))
                 (COND
                   ((SPADLET |object'|
                             (|retract2Specialization| |object|))
                    |object'|)
                   ('T '|failed|)))
                ((NULL (SPADLET |underDomain|
                                (|underDomainOf| |type'|)))
                 '|failed|)
                ('T
                 (SPADLET |object'|
                          (|retractUnderDomain| |object| |type|
                              |underDomain|))
                 (COND
                   ((NEQUAL |object'| '|failed|) |object'|)
                   ((SPADLET |object'|
                             (|coerceRetract| |object| |underDomain|))
                    |object'|)
                   ((SPADLET |object'|
                             (|retract2Specialization| |object|))
                    |object'|)
                   ('T '|failed|))))))))))))

;retractUnderDomain(object,type,underDomain) ==
;  null (ud := underDomainOf underDomain) => 'failed
;  [c,:args] := deconstructT type
;  1 ^= #args => 'failed
;  1 ^= #c => 'failed
;  type'' := constructT(c,[ud])
;  (object' := coerceInt(object,type'')) => object'
;  'failed

(DEFUN |retractUnderDomain| (|object| |type| |underDomain|)
  (PROG (|ud| |LETTMP#1| |c| |args| |type''| |object'|)
    (RETURN
      (COND
        ((NULL (SPADLET |ud| (|underDomainOf| |underDomain|)))
         '|failed|)
        ('T (SPADLET |LETTMP#1| (|deconstructT| |type|))
         (SPADLET |c| (CAR |LETTMP#1|))
         (SPADLET |args| (CDR |LETTMP#1|))
         (COND
           ((NEQUAL 1 (|#| |args|)) '|failed|)
           ((NEQUAL 1 (|#| |c|)) '|failed|)
           ('T (SPADLET |type''| (|constructT| |c| (CONS |ud| NIL)))
            (COND
              ((SPADLET |object'| (|coerceInt| |object| |type''|))
               |object'|)
              ('T '|failed|)))))))))

;retract2Specialization object ==
;  -- handles some specialization retraction cases, like matrices
;  val := objVal object
;  val' := unwrap val
;  type := objMode object
;  type = $Any =>
;    [dom,:obj] := val'
;    objNewWrap(obj,dom)
;  type is ['Union,:unionDoms] => coerceUnion2Branch object
;  type = $Symbol =>
;    objNewWrap(1,['OrderedVariableList,[val']])
;  type is ['OrderedVariableList,var] =>
;    coerceInt(objNewWrap(var.(val'-1),$Symbol), '(Polynomial (Integer)))
;-- !! following retract seems wrong and breaks ug13.input
;--  type is ['Variable,var] =>
;--    coerceInt(object,$Symbol)
;  type is ['Polynomial,D] =>
;    val' is [ =1,x,:.] =>
;      vl := REMDUP reverse varsInPoly val'
;      1 = #vl => coerceInt(object,['UnivariatePolynomial,x,D])
;      NIL
;    val' is [ =0,:.] => coerceInt(object, D)
;    NIL
;  type is ['Matrix,D] =>
;    n := # val'
;    m := # val'.0
;    n = m => objNew(val,['SquareMatrix,n,D])
;    objNew(val,['RectangularMatrix,n,m,D])
;  type is ['RectangularMatrix,n,m,D] =>
;    n = m => objNew(val,['SquareMatrix,n,D])
;    NIL
;  (type is [agg,D]) and (agg in '(Vector Segment UniversalSegment)) =>
;    D = $PositiveInteger => objNew(val,[agg,$NonNegativeInteger])
;    D = $NonNegativeInteger => objNew(val,[agg,$Integer])
;    NIL
;  type is ['Array,bds,D] =>
;    D = $PositiveInteger => objNew(val,['Array,bds,$NonNegativeInteger])
;    D = $NonNegativeInteger => objNew(val,['Array,bds,$Integer])
;    NIL
;  type is ['List,D] =>
;    D isnt ['List,D'] =>
;      -- try to retract elements
;      D = $PositiveInteger => objNew(val,['List,$NonNegativeInteger])
;      D = $NonNegativeInteger => objNew(val,['List,$Integer])
;      null val' => nil
;--        null (um := underDomainOf D) => nil
;--        objNewWrap(nil,['List,um])
;      vl := nil
;      tl := nil
;      bad := nil
;      for e in val' while not bad repeat
;        (e' := retract objNewWrap(e,D)) = 'failed => bad := true
;        vl := [objValUnwrap e',:vl]
;        tl := [objMode e',:tl]
;      bad => NIL
;      (m := resolveTypeListAny tl) = D => NIL
;      D = equiType(m) => NIL
;      vl' := nil
;      for e in vl for t in tl repeat
;        t = m => vl' := [e,:vl']
;        e' := coerceInt(objNewWrap(e,t),m)
;        null e' => return NIL
;        vl' := [objValUnwrap e',:vl']
;      objNewWrap(vl',['List,m])
;    D' = $PositiveInteger =>
;      objNew(val,['List,['List,$NonNegativeInteger]])
;    D' = $NonNegativeInteger =>
;      objNew(val,['List,['List,$Integer]])
;    D' is ['Variable,.] or D' is ['OrderedVariableList,.] =>
;        coerceInt(object,['List,['List,$Symbol]])
;    n := # val'
;    m := # val'.0
;    null isRectangularList(val',n,m) => NIL
;    coerceInt(object,['Matrix,D'])
;  type is ['Expression,D] =>
;    [num,:den] := val'
;    -- coerceRetract already handles case where den = 1
;    num isnt [0,:num] => NIL
;    den isnt [0,:den] => NIL
;    objNewWrap([num,:den],[$QuotientField, D])
;  type is ['SimpleAlgebraicExtension,k,rep,.] =>
;    -- try to retract as an element of rep and see if we can get an
;    -- element of k
;    val' := retract objNew(val,rep)
;    while (val' ^= 'failed) and
;      (equiType(objMode val') ^= k) repeat
;        val' := retract val'
;    val' = 'failed => NIL
;    val'
;  type is ['UnivariatePuiseuxSeries, coef, var, cen] =>
;    coerceInt(object, ['UnivariateLaurentSeries, coef, var, cen])
;  type is ['UnivariateLaurentSeries, coef, var, cen] =>
;    coerceInt(object, ['UnivariateTaylorSeries, coef, var, cen])
;  type is ['FunctionCalled,name] =>
;    null (m := get(name,'mode,$e)) => NIL
;    isPartialMode m => NIL
;    objNew(val,m)
;  NIL

(DEFUN |retract2Specialization| (|object|)
  (PROG (|val| |type| |dom| |obj| |unionDoms| |x| |agg| |bds| |D'|
               |bad| |vl| |tl| |e'| |vl'| |n| D |num| |den| |k| |rep|
               |val'| |coef| |ISTMP#2| |var| |ISTMP#3| |cen| |ISTMP#1|
               |name| |m|)
    (DECLARE (SPECIAL |$e| |$QuotientField| |$Symbol| |$Integer| |$Any|
                      |$NonNegativeInteger| |$PositiveInteger|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |val| (|objVal| |object|))
             (SPADLET |val'| (|unwrap| |val|))
             (SPADLET |type| (|objMode| |object|))
             (COND
               ((BOOT-EQUAL |type| |$Any|) (SPADLET |dom| (CAR |val'|))
                (SPADLET |obj| (CDR |val'|))
                (|objNewWrap| |obj| |dom|))
               ((AND (CONSP |type|) (EQ (QCAR |type|) '|Union|)
                     (PROGN (SPADLET |unionDoms| (QCDR |type|)) 'T))
                (|coerceUnion2Branch| |object|))
               ((BOOT-EQUAL |type| |$Symbol|)
                (|objNewWrap| 1
                    (CONS '|OrderedVariableList|
                          (CONS (CONS |val'| NIL) NIL))))
               ((AND (CONSP |type|)
                     (EQ (QCAR |type|) '|OrderedVariableList|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |type|))
                       (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN
                              (SPADLET |var| (QCAR |ISTMP#1|))
                              'T))))
                (|coerceInt|
                    (|objNewWrap| (ELT |var| (SPADDIFFERENCE |val'| 1))
                        |$Symbol|)
                    '(|Polynomial| (|Integer|))))
               ((AND (CONSP |type|) (EQ (QCAR |type|) '|Polynomial|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |type|))
                       (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN (SPADLET D (QCAR |ISTMP#1|)) 'T))))
                (COND
                  ((AND (CONSP |val'|) (EQUAL (QCAR |val'|) 1)
                        (PROGN
                          (SPADLET |ISTMP#1| (QCDR |val'|))
                          (AND (CONSP |ISTMP#1|)
                               (PROGN
                                 (SPADLET |x| (QCAR |ISTMP#1|))
                                 'T))))
                   (SPADLET |vl|
                            (REMDUP (REVERSE (|varsInPoly| |val'|))))
                   (COND
                     ((EQL 1 (|#| |vl|))
                      (|coerceInt| |object|
                          (CONS '|UnivariatePolynomial|
                                (CONS |x| (CONS D NIL)))))
                     ('T NIL)))
                  ((AND (CONSP |val'|) (EQUAL (QCAR |val'|) 0))
                   (|coerceInt| |object| D))
                  ('T NIL)))
               ((AND (CONSP |type|) (EQ (QCAR |type|) '|Matrix|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |type|))
                       (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN (SPADLET D (QCAR |ISTMP#1|)) 'T))))
                (SPADLET |n| (|#| |val'|))
                (SPADLET |m| (|#| (ELT |val'| 0)))
                (COND
                  ((BOOT-EQUAL |n| |m|)
                   (|objNew| |val|
                       (CONS '|SquareMatrix| (CONS |n| (CONS D NIL)))))
                  ('T
                   (|objNew| |val|
                       (CONS '|RectangularMatrix|
                             (CONS |n| (CONS |m| (CONS D NIL))))))))
               ((AND (CONSP |type|)
                     (EQ (QCAR |type|) '|RectangularMatrix|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |type|))
                       (AND (CONSP |ISTMP#1|)
                            (PROGN
                              (SPADLET |n| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (CONSP |ISTMP#2|)
                                   (PROGN
                                     (SPADLET |m| (QCAR |ISTMP#2|))
                                     (SPADLET |ISTMP#3|
                                      (QCDR |ISTMP#2|))
                                     (AND (CONSP |ISTMP#3|)
                                      (EQ (QCDR |ISTMP#3|) NIL)
                                      (PROGN
                                        (SPADLET D (QCAR |ISTMP#3|))
                                        'T))))))))
                (COND
                  ((BOOT-EQUAL |n| |m|)
                   (|objNew| |val|
                       (CONS '|SquareMatrix| (CONS |n| (CONS D NIL)))))
                  ('T NIL)))
               ((AND (CONSP |type|)
                     (PROGN
                       (SPADLET |agg| (QCAR |type|))
                       (SPADLET |ISTMP#1| (QCDR |type|))
                       (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN (SPADLET D (QCAR |ISTMP#1|)) 'T)))
                     (|member| |agg|
                         '(|Vector| |Segment| |UniversalSegment|)))
                (COND
                  ((BOOT-EQUAL D |$PositiveInteger|)
                   (|objNew| |val|
                       (CONS |agg| (CONS |$NonNegativeInteger| NIL))))
                  ((BOOT-EQUAL D |$NonNegativeInteger|)
                   (|objNew| |val| (CONS |agg| (CONS |$Integer| NIL))))
                  ('T NIL)))
               ((AND (CONSP |type|) (EQ (QCAR |type|) '|Array|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |type|))
                       (AND (CONSP |ISTMP#1|)
                            (PROGN
                              (SPADLET |bds| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (CONSP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (PROGN
                                     (SPADLET D (QCAR |ISTMP#2|))
                                     'T))))))
                (COND
                  ((BOOT-EQUAL D |$PositiveInteger|)
                   (|objNew| |val|
                       (CONS '|Array|
                             (CONS |bds|
                                   (CONS |$NonNegativeInteger| NIL)))))
                  ((BOOT-EQUAL D |$NonNegativeInteger|)
                   (|objNew| |val|
                       (CONS '|Array|
                             (CONS |bds| (CONS |$Integer| NIL)))))
                  ('T NIL)))
               ((AND (CONSP |type|) (EQ (QCAR |type|) '|List|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |type|))
                       (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN (SPADLET D (QCAR |ISTMP#1|)) 'T))))
                (COND
                  ((NULL (AND (CONSP D) (EQ (QCAR D) '|List|)
                              (PROGN
                                (SPADLET |ISTMP#1| (QCDR D))
                                (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (PROGN
                                       (SPADLET |D'| (QCAR |ISTMP#1|))
                                       'T)))))
                   (COND
                     ((BOOT-EQUAL D |$PositiveInteger|)
                      (|objNew| |val|
                          (CONS '|List|
                                (CONS |$NonNegativeInteger| NIL))))
                     ((BOOT-EQUAL D |$NonNegativeInteger|)
                      (|objNew| |val|
                          (CONS '|List| (CONS |$Integer| NIL))))
                     ((NULL |val'|) NIL)
                     ('T (SPADLET |vl| NIL) (SPADLET |tl| NIL)
                      (SPADLET |bad| NIL)
                      (DO ((G166347 |val'| (CDR G166347))
                           (|e| NIL))
                          ((OR (ATOM G166347)
                               (PROGN (SETQ |e| (CAR G166347)) NIL)
                               (NULL (NULL |bad|)))
                           NIL)
                        (SEQ (EXIT (COND
                                     ((BOOT-EQUAL
                                       (SPADLET |e'|
                                        (|retract|
                                         (|objNewWrap| |e| D)))
                                       '|failed|)
                                      (SPADLET |bad| 'T))
                                     ('T
                                      (SPADLET |vl|
                                       (CONS (|objValUnwrap| |e'|)
                                        |vl|))
                                      (SPADLET |tl|
                                       (CONS (|objMode| |e'|) |tl|)))))))
                      (COND
                        (|bad| NIL)
                        ((BOOT-EQUAL
                             (SPADLET |m| (|resolveTypeListAny| |tl|))
                             D)
                         NIL)
                        ((BOOT-EQUAL D (|equiType| |m|)) NIL)
                        ('T (SPADLET |vl'| NIL)
                         (DO ((G166358 |vl| (CDR G166358))
                              (|e| NIL)
                              (G166359 |tl| (CDR G166359))
                              (|t| NIL))
                             ((OR (ATOM G166358)
                                  (PROGN
                                    (SETQ |e| (CAR G166358))
                                    NIL)
                                  (ATOM G166359)
                                  (PROGN
                                    (SETQ |t| (CAR G166359))
                                    NIL))
                              NIL)
                           (SEQ (EXIT (COND
                                        ((BOOT-EQUAL |t| |m|)
                                         (SPADLET |vl'|
                                          (CONS |e| |vl'|)))
                                        ('T
                                         (SPADLET |e'|
                                          (|coerceInt|
                                           (|objNewWrap| |e| |t|) |m|))
                                         (COND
                                           ((NULL |e'|) (RETURN NIL))
                                           ('T
                                            (SPADLET |vl'|
                                             (CONS
                                              (|objValUnwrap| |e'|)
                                              |vl'|)))))))))
                         (|objNewWrap| |vl'|
                             (CONS '|List| (CONS |m| NIL))))))))
                  ((BOOT-EQUAL |D'| |$PositiveInteger|)
                   (|objNew| |val|
                       (CONS '|List|
                             (CONS (CONS '|List|
                                    (CONS |$NonNegativeInteger| NIL))
                                   NIL))))
                  ((BOOT-EQUAL |D'| |$NonNegativeInteger|)
                   (|objNew| |val|
                       (CONS '|List|
                             (CONS (CONS '|List| (CONS |$Integer| NIL))
                                   NIL))))
                  ((OR (AND (CONSP |D'|) (EQ (QCAR |D'|) '|Variable|)
                            (PROGN
                              (SPADLET |ISTMP#1| (QCDR |D'|))
                              (AND (CONSP |ISTMP#1|)
                                   (EQ (QCDR |ISTMP#1|) NIL))))
                       (AND (CONSP |D'|)
                            (EQ (QCAR |D'|) '|OrderedVariableList|)
                            (PROGN
                              (SPADLET |ISTMP#1| (QCDR |D'|))
                              (AND (CONSP |ISTMP#1|)
                                   (EQ (QCDR |ISTMP#1|) NIL)))))
                   (|coerceInt| |object|
                       (CONS '|List|
                             (CONS (CONS '|List| (CONS |$Symbol| NIL))
                                   NIL))))
                  ('T (SPADLET |n| (|#| |val'|))
                   (SPADLET |m| (|#| (ELT |val'| 0)))
                   (COND
                     ((NULL (|isRectangularList| |val'| |n| |m|)) NIL)
                     ('T
                      (|coerceInt| |object|
                          (CONS '|Matrix| (CONS |D'| NIL))))))))
               ((AND (CONSP |type|) (EQ (QCAR |type|) '|Expression|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |type|))
                       (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN (SPADLET D (QCAR |ISTMP#1|)) 'T))))
                (SPADLET |num| (CAR |val'|))
                (SPADLET |den| (CDR |val'|))
                (COND
                  ((NULL (AND (CONSP |num|) (EQUAL (QCAR |num|) 0)
                              (PROGN (SPADLET |num| (QCDR |num|)) 'T)))
                   NIL)
                  ((NULL (AND (CONSP |den|) (EQUAL (QCAR |den|) 0)
                              (PROGN (SPADLET |den| (QCDR |den|)) 'T)))
                   NIL)
                  ('T
                   (|objNewWrap| (CONS |num| |den|)
                       (CONS |$QuotientField| (CONS D NIL))))))
               ((AND (CONSP |type|)
                     (EQ (QCAR |type|) '|SimpleAlgebraicExtension|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |type|))
                       (AND (CONSP |ISTMP#1|)
                            (PROGN
                              (SPADLET |k| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (CONSP |ISTMP#2|)
                                   (PROGN
                                     (SPADLET |rep| (QCAR |ISTMP#2|))
                                     (SPADLET |ISTMP#3|
                                      (QCDR |ISTMP#2|))
                                     (AND (CONSP |ISTMP#3|)
                                      (EQ (QCDR |ISTMP#3|) NIL))))))))
                (SPADLET |val'| (|retract| (|objNew| |val| |rep|)))
                (DO ()
                    ((NULL (AND (NEQUAL |val'| '|failed|)
                                (NEQUAL (|equiType| (|objMode| |val'|))
                                        |k|)))
                     NIL)
                  (SEQ (EXIT (SPADLET |val'| (|retract| |val'|)))))
                (COND ((BOOT-EQUAL |val'| '|failed|) NIL) ('T |val'|)))
               ((AND (CONSP |type|)
                     (EQ (QCAR |type|) '|UnivariatePuiseuxSeries|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |type|))
                       (AND (CONSP |ISTMP#1|)
                            (PROGN
                              (SPADLET |coef| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (CONSP |ISTMP#2|)
                                   (PROGN
                                     (SPADLET |var| (QCAR |ISTMP#2|))
                                     (SPADLET |ISTMP#3|
                                      (QCDR |ISTMP#2|))
                                     (AND (CONSP |ISTMP#3|)
                                      (EQ (QCDR |ISTMP#3|) NIL)
                                      (PROGN
                                        (SPADLET |cen|
                                         (QCAR |ISTMP#3|))
                                        'T))))))))
                (|coerceInt| |object|
                    (CONS '|UnivariateLaurentSeries|
                          (CONS |coef| (CONS |var| (CONS |cen| NIL))))))
               ((AND (CONSP |type|)
                     (EQ (QCAR |type|) '|UnivariateLaurentSeries|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |type|))
                       (AND (CONSP |ISTMP#1|)
                            (PROGN
                              (SPADLET |coef| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (CONSP |ISTMP#2|)
                                   (PROGN
                                     (SPADLET |var| (QCAR |ISTMP#2|))
                                     (SPADLET |ISTMP#3|
                                      (QCDR |ISTMP#2|))
                                     (AND (CONSP |ISTMP#3|)
                                      (EQ (QCDR |ISTMP#3|) NIL)
                                      (PROGN
                                        (SPADLET |cen|
                                         (QCAR |ISTMP#3|))
                                        'T))))))))
                (|coerceInt| |object|
                    (CONS '|UnivariateTaylorSeries|
                          (CONS |coef| (CONS |var| (CONS |cen| NIL))))))
               ((AND (CONSP |type|)
                     (EQ (QCAR |type|) '|FunctionCalled|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |type|))
                       (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN
                              (SPADLET |name| (QCAR |ISTMP#1|))
                              'T))))
                (COND
                  ((NULL (SPADLET |m| (|get| |name| '|mode| |$e|)))
                   NIL)
                  ((|isPartialMode| |m|) NIL)
                  ('T (|objNew| |val| |m|))))
               ('T NIL)))))))

;coerceOrConvertOrRetract(T,m) ==
;  $useConvertForCoercions : local := true
;  coerceOrRetract(T,m)

(DEFUN |coerceOrConvertOrRetract| (T$ |m|)
  (PROG (|$useConvertForCoercions|)
    (DECLARE (SPECIAL |$useConvertForCoercions|))
    (RETURN
      (PROGN
        (SPADLET |$useConvertForCoercions| 'T)
        (|coerceOrRetract| T$ |m|)))))

;coerceOrRetract(T,m) ==
;  (t' := coerceInteractive(T,m)) => t'
;  t := T
;  ans := nil
;  repeat
;    ans => return ans
;    t := retract t   -- retract is new name for pullback
;    t = 'failed => return ans
;    ans := coerceInteractive(t,m)
;  ans

(DEFUN |coerceOrRetract| (T$ |m|)
  (PROG (|t'| |t| |ans|)
    (RETURN
      (SEQ (COND
             ((SPADLET |t'| (|coerceInteractive| T$ |m|)) |t'|)
             ('T (SPADLET |t| T$) (SPADLET |ans| NIL)
              (DO () (NIL NIL)
                (SEQ (EXIT (COND
                             (|ans| (RETURN |ans|))
                             ('T (SPADLET |t| (|retract| |t|))
                              (COND
                                ((BOOT-EQUAL |t| '|failed|)
                                 (RETURN |ans|))
                                ('T
                                 (SPADLET |ans|
                                          (|coerceInteractive| |t| |m|)))))))))
              |ans|))))))

;coerceRetract(object,t2) ==
;  -- tries to handle cases such as P I -> I
;  (val := objValUnwrap(object)) = "$fromCoerceable$" => NIL
;  t1 := objMode object
;  t2 = $OutputForm => NIL
;  isEqualOrSubDomain(t1,$Integer) and typeIsASmallInteger(t2) and SMINTP(val) =>
;    objNewWrap(val,t2)
;  t1 = $Integer    => NIL
;  t1 = $Symbol     => NIL
;  t1 = $OutputForm => NIL
;  (c := retractByFunction(object, t2)) => c
;  t1 is [D,:.] =>
;    fun := GET(D,'retract) or
;           INTERN STRCONC('"retract",STRINGIMAGE D)
;    functionp fun =>
;      PUT(D,'retract,fun)
;      c := CATCH('coerceFailure,FUNCALL(fun,object,t2))
;      (c = $coerceFailure) => NIL
;      c
;    NIL
;  NIL

(DEFUN |coerceRetract| (|object| |t2|)
  (PROG (|val| |t1| D |fun| |c|)
    (DECLARE (SPECIAL |$coerceFailure| |$OutputForm| |$Symbol|
                      |$Integer|))
    (RETURN
      (COND
        ((BOOT-EQUAL (SPADLET |val| (|objValUnwrap| |object|))
             '|$fromCoerceable$|)
         NIL)
        ('T (SPADLET |t1| (|objMode| |object|))
         (COND
           ((BOOT-EQUAL |t2| |$OutputForm|) NIL)
           ((AND (|isEqualOrSubDomain| |t1| |$Integer|)
                 (|typeIsASmallInteger| |t2|) (typep |val| 'fixnum))
            (|objNewWrap| |val| |t2|))
           ((BOOT-EQUAL |t1| |$Integer|) NIL)
           ((BOOT-EQUAL |t1| |$Symbol|) NIL)
           ((BOOT-EQUAL |t1| |$OutputForm|) NIL)
           ((SPADLET |c| (|retractByFunction| |object| |t2|)) |c|)
           ((AND (CONSP |t1|) (PROGN (SPADLET D (QCAR |t1|)) 'T))
            (SPADLET |fun|
                     (OR (GETL D '|retract|)
                         (INTERN (STRCONC "retract"
                                          (STRINGIMAGE D)))))
            (COND
              ((|functionp| |fun|) (PUT D '|retract| |fun|)
               (SPADLET |c|
                        (CATCH '|coerceFailure|
                          (FUNCALL |fun| |object| |t2|)))
               (COND ((BOOT-EQUAL |c| |$coerceFailure|) NIL) ('T |c|)))
              ('T NIL)))
           ('T NIL)))))))

;retractByFunction(object,u) ==
;  -- tries to retract by using function "retractIfCan"
;  -- if the type belongs to the correct category.
;  $reportBottomUpFlag: local := NIL
;  t := objMode object
;  -- JHD/CRF not ofCategory(t,['RetractableTo,u]) => NIL
;  val := objValUnwrap object
;  -- try to get and apply the function "retractable?"
;  target := ['Union,u,'"failed"]
;  funName := 'retractIfCan
;  if $reportBottomUpFlag then
;    sayFunctionSelection(funName,[t],target,NIL,
;      '"coercion facility (retraction)")
;  -- JHD/CRF if (mms := findFunctionInDomain(funName,t,target,[t],[t],'T,'T))
;  -- MCD: changed penultimate variable to NIL.
;  if (mms := append(findFunctionInDomain(funName,t,target,[t],[t],NIL,'T),
;                    findFunctionInDomain(funName,u,target,[t],[t],NIL,'T)))
;-- The above two lines were:      (RDJ/BMT 6/95)
;--  if (mms := append(findFunctionInDomain(funName,t,target,[t],[t],'T,'T),
;--                    findFunctionInDomain(funName,u,target,[t],[t],'T,'T)))
;    then mms := orderMms(funName,mms,[t],[t],target)
;  if $reportBottomUpFlag then
;    sayFunctionSelectionResult(funName,[t],mms)
;  null mms => NIL
;  -- [[dc,:.],slot,.]:= CAR mms
;  dc := CAAAR mms
;  slot := CADAR mms
;  dcVector:= evalDomain dc
;  fun :=
;--+
;    compiledLookup(funName,[target,t],dcVector)
;  NULL fun => NIL
;  CAR(fun) = function Undef => NIL
;--+
;  $: fluid := dcVector
;  object' := coerceUnion2Branch objNewWrap(SPADCALL(val,fun),target)
;  u' := objMode object'
;  u = u' => object'
;  NIL

(DEFUN |retractByFunction| (|object| |u|)
  (PROG (|$reportBottomUpFlag| $ |t| |val| |target| |funName| |mms|
            |dc| |slot| |dcVector| |fun| |object'| |u'|)
    (DECLARE (SPECIAL |$reportBottomUpFlag| $))
    (RETURN
      (PROGN
        (SPADLET |$reportBottomUpFlag| NIL)
        (SPADLET |t| (|objMode| |object|))
        (SPADLET |val| (|objValUnwrap| |object|))
        (SPADLET |target|
                 (CONS '|Union|
                       (CONS |u| (CONS "failed" NIL))))
        (SPADLET |funName| '|retractIfCan|)
        (COND
          (|$reportBottomUpFlag|
              (|sayFunctionSelection| |funName| (CONS |t| NIL) |target|
                  NIL "coercion facility (retraction)")))
        (COND
          ((SPADLET |mms|
                    (APPEND (|findFunctionInDomain| |funName| |t|
                                |target| (CONS |t| NIL) (CONS |t| NIL)
                                NIL 'T)
                            (|findFunctionInDomain| |funName| |u|
                                |target| (CONS |t| NIL) (CONS |t| NIL)
                                NIL 'T)))
           (SPADLET |mms|
                    (|orderMms| |funName| |mms| (CONS |t| NIL)
                        (CONS |t| NIL) |target|))))
        (COND
          (|$reportBottomUpFlag|
              (|sayFunctionSelectionResult| |funName| (CONS |t| NIL)
                  |mms|)))
        (COND
          ((NULL |mms|) NIL)
          ('T (SPADLET |dc| (CAAAR |mms|))
           (SPADLET |slot| (CADAR |mms|))
           (SPADLET |dcVector| (|evalDomain| |dc|))
           (SPADLET |fun|
                    (|compiledLookup| |funName|
                        (CONS |target| (CONS |t| NIL)) |dcVector|))
           (COND
             ((NULL |fun|) NIL)
             ((BOOT-EQUAL (CAR |fun|) (|function| |Undef|)) NIL)
             ('T (SPADLET $ |dcVector|)
              (SPADLET |object'|
                       (|coerceUnion2Branch|
                           (|objNewWrap| (SPADCALL |val| |fun|)
                               |target|)))
              (SPADLET |u'| (|objMode| |object'|))
              (COND ((BOOT-EQUAL |u| |u'|) |object'|) ('T NIL))))))))))

;--% Coercion utilities
;-- The next function extracts the structural definition of constants
;-- from a given domain. For example, getConstantFromDomain('(One),S)
;-- returns the representation of 1 in the domain S.
;constantInDomain?(form,domainForm) ==
;    opAlist := getOperationAlistFromLisplib first domainForm
;    key := opOf form
;    entryList := LASSOC(key,opAlist)
;    entryList is [[., ., ., type]] and type in '(CONST ASCONST) => true
;    key = "One" => constantInDomain?(["1"], domainForm)
;    key = "Zero" => constantInDomain?(["0"], domainForm)
;    false

(DEFUN |constantInDomain?| (|form| |domainForm|)
  (PROG (|opAlist| |key| |entryList| |ISTMP#1| |ISTMP#2| |ISTMP#3|
                   |ISTMP#4| |type|)
    (RETURN
      (PROGN
        (SPADLET |opAlist|
                 (|getOperationAlistFromLisplib| (CAR |domainForm|)))
        (SPADLET |key| (|opOf| |form|))
        (SPADLET |entryList| (LASSOC |key| |opAlist|))
        (COND
          ((AND (CONSP |entryList|) (EQ (QCDR |entryList|) NIL)
                (PROGN
                  (SPADLET |ISTMP#1| (QCAR |entryList|))
                  (AND (CONSP |ISTMP#1|)
                       (PROGN
                         (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (CONSP |ISTMP#2|)
                              (PROGN
                                (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                                (AND (CONSP |ISTMP#3|)
                                     (PROGN
                                       (SPADLET |ISTMP#4|
                                        (QCDR |ISTMP#3|))
                                       (AND (CONSP |ISTMP#4|)
                                        (EQ (QCDR |ISTMP#4|) NIL)
                                        (PROGN
                                          (SPADLET |type|
                                           (QCAR |ISTMP#4|))
                                          'T)))))))))
                (|member| |type| '(CONST ASCONST)))
           'T)
          ((BOOT-EQUAL |key| '|One|)
           (|constantInDomain?| (CONS '|1| NIL) |domainForm|))
          ((BOOT-EQUAL |key| '|Zero|)
           (|constantInDomain?| (CONS '|0| NIL) |domainForm|))
          ('T NIL))))))


\end{chunk}
\section{Function getConstantFromDomain}
[[getConstantFromDomain]] is used to look up the constants $0$ and $1$
from the given [[domainForm]].
\begin{enumerate}
\item if [[isPartialMode]] (see i-funsel.boot) returns true then the
domain modemap contains the constant [[$EmptyMode]] which indicates
that the domain is not fully formed. In this case we return [[NIL]].
\end{enumerate}
\begin{chunk}{*}
;getConstantFromDomain(form,domainForm) ==
;    isPartialMode domainForm => NIL
;    opAlist := getOperationAlistFromLisplib first domainForm
;    key := opOf form
;    entryList := LASSOC(key,opAlist)
;    entryList isnt [[sig, ., ., .]] =>
;        key = "One" => getConstantFromDomain(["1"], domainForm)
;        key = "Zero" => getConstantFromDomain(["0"], domainForm)
;        throwKeyedMsg("S2IC0008",[form,domainForm])
;    -- i.e., there should be exactly one item under this key of that form
;    domain := evalDomain domainForm
;    SPADCALL compiledLookupCheck(key,sig,domain)

(DEFUN |getConstantFromDomain| (|form| |domainForm|)
  (PROG (|opAlist| |key| |entryList| |ISTMP#1| |sig| |ISTMP#2|
            |ISTMP#3| |ISTMP#4| |domain|)
    (RETURN
      (COND
        ((|isPartialMode| |domainForm|) NIL)
        ('T
         (SPADLET |opAlist|
                  (|getOperationAlistFromLisplib| (CAR |domainForm|)))
         (SPADLET |key| (|opOf| |form|))
         (SPADLET |entryList| (LASSOC |key| |opAlist|))
         (COND
           ((NULL (AND (CONSP |entryList|) (EQ (QCDR |entryList|) NIL)
                       (PROGN
                         (SPADLET |ISTMP#1| (QCAR |entryList|))
                         (AND (CONSP |ISTMP#1|)
                              (PROGN
                                (SPADLET |sig| (QCAR |ISTMP#1|))
                                (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                                (AND (CONSP |ISTMP#2|)
                                     (PROGN
                                       (SPADLET |ISTMP#3|
                                        (QCDR |ISTMP#2|))
                                       (AND (CONSP |ISTMP#3|)
                                        (PROGN
                                          (SPADLET |ISTMP#4|
                                           (QCDR |ISTMP#3|))
                                          (AND (CONSP |ISTMP#4|)
                                           (EQ (QCDR |ISTMP#4|) NIL)))))))))))
            (COND
              ((BOOT-EQUAL |key| '|One|)
               (|getConstantFromDomain| (CONS '|1| NIL) |domainForm|))
              ((BOOT-EQUAL |key| '|Zero|)
               (|getConstantFromDomain| (CONS '|0| NIL) |domainForm|))
              ('T
               (|throwKeyedMsg| 'S2IC0008
                   (CONS |form| (CONS |domainForm| NIL))))))
           ('T (SPADLET |domain| (|evalDomain| |domainForm|))
            (SPADCALL (|compiledLookupCheck| |key| |sig| |domain|)))))))))

;domainOne(domain) == getConstantFromDomain('(One),domain)

(DEFUN |domainOne| (|domain|)
  (|getConstantFromDomain| '(|One|) |domain|))

;domainZero(domain) == getConstantFromDomain('(Zero),domain)

(DEFUN |domainZero| (|domain|)
  (|getConstantFromDomain| '(|Zero|) |domain|))

;equalOne(object, domain) ==
;  -- tries using constant One and "=" from domain
;  -- object should not be wrapped
;  algEqual(object, getConstantFromDomain('(One),domain), domain)

(DEFUN |equalOne| (|object| |domain|)
  (|algEqual| |object| (|getConstantFromDomain| '(|One|) |domain|)
      |domain|))

;equalZero(object, domain) ==
;  -- tries using constant Zero and "=" from domain
;  -- object should not be wrapped
;  algEqual(object, getConstantFromDomain('(Zero),domain), domain)

(DEFUN |equalZero| (|object| |domain|)
  (|algEqual| |object| (|getConstantFromDomain| '(|Zero|) |domain|)
      |domain|))

;algEqual(object1, object2, domain) ==
;  -- sees if 2 objects of the same domain are equal by using the
;  -- "=" from the domain
;  -- objects should not be wrapped
;--  eqfunc := getFunctionFromDomain("=",domain,[domain,domain])
;  eqfunc := compiledLookupCheck("=",[$Boolean,'$,'$],evalDomain domain)
;  SPADCALL(object1,object2, eqfunc)

(DEFUN |algEqual| (|object1| |object2| |domain|)
  (PROG (|eqfunc|)
    (DECLARE (SPECIAL |$Boolean|))
    (RETURN
      (PROGN
        (SPADLET |eqfunc|
                 (|compiledLookupCheck| '=
                     (CONS |$Boolean| (CONS '$ (CONS '$ NIL)))
                     (|evalDomain| |domain|)))
        (SPADCALL |object1| |object2| |eqfunc|)))))

\end{chunk}
\begin{verbatim}
 main algorithms for canCoerceFrom and coerceInteractive

coerceInteractive and canCoerceFrom are the two coercion functions
for $InteractiveMode. They translate RN, RF and RR to QF I, QF P
and RE RN, respectively, and call coerceInt or canCoerce, which
both work in the same way (e.g. coercion from t1 to t2):
1. they try to coerce t1 to t2 directly (tower coercion), and, if
  this fails, to coerce t1 to the last argument of t2 and embed
  this last argument into t2. These embedding functions are now only
  defined in the algebra code. (RSS 2-27-87)
2. the tower coercion looks whether there is any applicable local
  coercion, which means, one defined in boot or in algebra code.
  If there is an applicable function from a constructor, which is
  inside the type tower of t1, to the top level constructor of t2,
  then this constructor is bubbled up inside t1. This means,
  special coercion functions (defined in boot) are called, which
  commute two constructors in a tower. Then the local coercion is
  called on these constructors, which both are on top level now.
example:
let t1 = A B C D E (short for (A (B (C (D (E))))), where A ... E are
  type constructors), and t2 = F D G H I J
there is no coercion from t1 to t2 directly, so we try to coerce
  t1 to s1 = D G H I J, the last argument of t2
we create the type s2 = A D B C E and call a local coercion A2A
  from t1 to s2, which, by recursively calling coerce, bubbles up
  the constructor D
then we call a commute coerce from s2 to s3 = D A B C E and a local
  coerce D2D from s3 to s1
finally we embed s1 into t2, which completes the coercion t1 to t2
the result of canCoerceFrom is TRUE or NIL
the result of coerceInteractive is a object or NIL (=failed)
all boot coercion functions have the following result:
1. if u=$fromCoerceable$, then TRUE or NIL
2. if the coercion succeeds, the coerced value (this may be NIL)
3. if the coercion fails, they throw to a catch point in
     coerceByFunction

Interpreter Coercion Query Functions
\end{verbatim}
\begin{chunk}{*}
;canCoerce1(t1,t2) ==
;  -- general test for coercion
;  -- the result is NIL if it fails
;  t1 = t2 => true
;  absolutelyCanCoerceByCheating(t1,t2) or t1 = '(None) or t2 = '(Any) or
;    t1 in '((Mode)  (Domain) (SubDomain (Domain))) =>
;      t2 = $OutputForm => true
;      NIL
;    -- next is for tagged union selectors for the time being
;    t1 is ['Variable,=t2] or t2 is ['Variable,=t1] => true
;    STRINGP t1 =>
;      t2 = $String => true
;      t2 = $OutputForm => true
;      t2 is ['Union,:.] => canCoerceUnion(t1,t2)
;      t2 is ['Variable,v] and (t1 = PNAME(v)) => true
;      NIL
;    STRINGP t2 =>
;      t1 is ['Variable,v] and (t2 = PNAME(v)) => true
;      NIL
;    atom t1 or atom t2 => NIL
;    null isValidType(t2) => NIL
;    absolutelyCannotCoerce(t1,t2) => NIL
;    nt1 := CAR t1
;    nt2 := CAR t2
;    EQ(nt1,'Mapping) => EQ(nt2,'Any)
;    EQ(nt2,'Mapping) =>
;      EQ(nt1,'Variable) or EQ(nt1,'FunctionCalled) =>
;        canCoerceExplicit2Mapping(t1,t2)
;      NIL
;    EQ(nt1,'Union) or EQ(nt2,'Union) => canCoerceUnion(t1,t2)
;    -- efficiency hack
;    t1 is ['Segment, s1] and t2 is ['UniversalSegment, s2] and
;        (isEqualOrSubDomain(s1, s2) or canCoerce(s1, s2)) => true
;    t1 is ['Tuple,S] and t2 ^= '(OutputForm) => canCoerce(['List, S], t2)
;    isRingT2 := ofCategory(t2,'(Ring))
;    isRingT2 and isEqualOrSubDomain(t1,$Integer) => true
;    (ans := canCoerceTopMatching(t1,t2,nt1,nt2)) ^= 'maybe => ans
;    t2 = $Integer => canCoerceLocal(t1,t2)   -- is true
;    ans := canCoerceTower(t1,t2) or
;      [.,:arg]:= deconstructT t2
;      arg and
;        t:= last arg
;        canCoerce(t1,t) and canCoerceByFunction(t,t2) and 'T
;    ans or (t1 in '((PositiveInteger) (NonNegativeInteger))
;      and canCoerce($Integer,t2))

(DEFUN |canCoerce1| (|t1| |t2|)
  (PROG (|v| |nt1| |nt2| |s1| |s2| |ISTMP#1| S |isRingT2| |LETTMP#1|
             |arg| |t| |ans|)
    (DECLARE (SPECIAL |$Integer| |$OutputForm| |$String|))
    (RETURN
      (COND
        ((BOOT-EQUAL |t1| |t2|) 'T)
        ('T
         (OR (|absolutelyCanCoerceByCheating| |t1| |t2|)
             (BOOT-EQUAL |t1| '(|None|)) (BOOT-EQUAL |t2| '(|Any|))
             (COND
               ((|member| |t1|
                    '((|Mode|) (|Domain|) (|SubDomain| (|Domain|))))
                (COND ((BOOT-EQUAL |t2| |$OutputForm|) 'T) ('T NIL)))
               ((OR (AND (CONSP |t1|) (EQ (QCAR |t1|) '|Variable|)
                         (PROGN
                           (SPADLET |ISTMP#1| (QCDR |t1|))
                           (AND (CONSP |ISTMP#1|)
                                (EQ (QCDR |ISTMP#1|) NIL)
                                (EQUAL (QCAR |ISTMP#1|) |t2|))))
                    (AND (CONSP |t2|) (EQ (QCAR |t2|) '|Variable|)
                         (PROGN
                           (SPADLET |ISTMP#1| (QCDR |t2|))
                           (AND (CONSP |ISTMP#1|)
                                (EQ (QCDR |ISTMP#1|) NIL)
                                (EQUAL (QCAR |ISTMP#1|) |t1|)))))
                'T)
               ((STRINGP |t1|)
                (COND
                  ((BOOT-EQUAL |t2| |$String|) 'T)
                  ((BOOT-EQUAL |t2| |$OutputForm|) 'T)
                  ((AND (CONSP |t2|) (EQ (QCAR |t2|) '|Union|))
                   (|canCoerceUnion| |t1| |t2|))
                  ((AND (CONSP |t2|) (EQ (QCAR |t2|) '|Variable|)
                        (PROGN
                          (SPADLET |ISTMP#1| (QCDR |t2|))
                          (AND (CONSP |ISTMP#1|)
                               (EQ (QCDR |ISTMP#1|) NIL)
                               (PROGN
                                 (SPADLET |v| (QCAR |ISTMP#1|))
                                 'T)))
                        (BOOT-EQUAL |t1| (PNAME |v|)))
                   'T)
                  ('T NIL)))
               ((STRINGP |t2|)
                (COND
                  ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|Variable|)
                        (PROGN
                          (SPADLET |ISTMP#1| (QCDR |t1|))
                          (AND (CONSP |ISTMP#1|)
                               (EQ (QCDR |ISTMP#1|) NIL)
                               (PROGN
                                 (SPADLET |v| (QCAR |ISTMP#1|))
                                 'T)))
                        (BOOT-EQUAL |t2| (PNAME |v|)))
                   'T)
                  ('T NIL)))
               ((OR (ATOM |t1|) (ATOM |t2|)) NIL)
               ((NULL (|isValidType| |t2|)) NIL)
               ((|absolutelyCannotCoerce| |t1| |t2|) NIL)
               ('T (SPADLET |nt1| (CAR |t1|))
                (SPADLET |nt2| (CAR |t2|))
                (COND
                  ((EQ |nt1| '|Mapping|) (EQ |nt2| '|Any|))
                  ((EQ |nt2| '|Mapping|)
                   (COND
                     ((OR (EQ |nt1| '|Variable|)
                          (EQ |nt1| '|FunctionCalled|))
                      (|canCoerceExplicit2Mapping| |t1| |t2|))
                     ('T NIL)))
                  ((OR (EQ |nt1| '|Union|) (EQ |nt2| '|Union|))
                   (|canCoerceUnion| |t1| |t2|))
                  ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|Segment|)
                        (PROGN
                          (SPADLET |ISTMP#1| (QCDR |t1|))
                          (AND (CONSP |ISTMP#1|)
                               (EQ (QCDR |ISTMP#1|) NIL)
                               (PROGN
                                 (SPADLET |s1| (QCAR |ISTMP#1|))
                                 'T)))
                        (CONSP |t2|)
                        (EQ (QCAR |t2|) '|UniversalSegment|)
                        (PROGN
                          (SPADLET |ISTMP#1| (QCDR |t2|))
                          (AND (CONSP |ISTMP#1|)
                               (EQ (QCDR |ISTMP#1|) NIL)
                               (PROGN
                                 (SPADLET |s2| (QCAR |ISTMP#1|))
                                 'T)))
                        (OR (|isEqualOrSubDomain| |s1| |s2|)
                            (|canCoerce| |s1| |s2|)))
                   'T)
                  ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|Tuple|)
                        (PROGN
                          (SPADLET |ISTMP#1| (QCDR |t1|))
                          (AND (CONSP |ISTMP#1|)
                               (EQ (QCDR |ISTMP#1|) NIL)
                               (PROGN (SPADLET S (QCAR |ISTMP#1|)) 'T)))
                        (NEQUAL |t2| '(|OutputForm|)))
                   (|canCoerce| (CONS '|List| (CONS S NIL)) |t2|))
                  ('T
                   (SPADLET |isRingT2| (|ofCategory| |t2| '(|Ring|)))
                   (COND
                     ((AND |isRingT2|
                           (|isEqualOrSubDomain| |t1| |$Integer|))
                      'T)
                     ((NEQUAL (SPADLET |ans|
                                       (|canCoerceTopMatching| |t1|
                                        |t2| |nt1| |nt2|))
                              '|maybe|)
                      |ans|)
                     ((BOOT-EQUAL |t2| |$Integer|)
                      (|canCoerceLocal| |t1| |t2|))
                     ('T
                      (SPADLET |ans|
                               (OR (|canCoerceTower| |t1| |t2|)
                                   (PROGN
                                     (SPADLET |LETTMP#1|
                                      (|deconstructT| |t2|))
                                     (SPADLET |arg| (CDR |LETTMP#1|))
                                     (AND |arg|
                                      (PROGN
                                        (SPADLET |t| (|last| |arg|))
                                        (AND (|canCoerce| |t1| |t|)
                                         (|canCoerceByFunction| |t|
                                          |t2|)
                                         'T))))))
                      (OR |ans|
                          (AND (|member| |t1|
                                   '((|PositiveInteger|)
                                     (|NonNegativeInteger|)))
                               (|canCoerce| |$Integer| |t2|)))))))))))))))

;canCoerceFrom0(t1,t2) ==
;-- top level test for coercion, which transfers all RN, RF and RR into
;-- equivalent types
;  startTimingProcess 'querycoerce
;  q :=
;    isEqualOrSubDomain(t1,t2) or t1 = '(None) or t2 = '(Any) or
;      if t2 = $OutputForm then (s1 := t1; s2 := t2)
;      else (s1:= equiType(t1); s2:= equiType(t2))
;      -- make sure we are trying to coerce to a legal type
;      -- in particular, polynomials are repeated, etc.
;      null isValidType(t2) => NIL
;      null isLegitimateMode(t2,nil,nil) => NIL
;      t1 = $RationalNumber =>
;        isEqualOrSubDomain(t2,$Integer) => NIL
;        canCoerce(t1,t2) or canCoerce(s1,s2)
;      canCoerce(s1,s2)
;  stopTimingProcess 'querycoerce
;  q

(DEFUN |canCoerceFrom0| (|t1| |t2|)
  (PROG (|s1| |s2| |q|)
    (DECLARE (SPECIAL |$Integer| |$RationalNumber| |$OutputForm|))
    (RETURN
      (PROGN
        (|startTimingProcess| '|querycoerce|)
        (SPADLET |q|
                 (OR (|isEqualOrSubDomain| |t1| |t2|)
                     (BOOT-EQUAL |t1| '(|None|))
                     (BOOT-EQUAL |t2| '(|Any|))
                     (PROGN
                       (COND
                         ((BOOT-EQUAL |t2| |$OutputForm|)
                          (SPADLET |s1| |t1|) (SPADLET |s2| |t2|))
                         ('T (SPADLET |s1| (|equiType| |t1|))
                          (SPADLET |s2| (|equiType| |t2|))))
                       (COND
                         ((NULL (|isValidType| |t2|)) NIL)
                         ((NULL (|isLegitimateMode| |t2| NIL NIL)) NIL)
                         ((BOOT-EQUAL |t1| |$RationalNumber|)
                          (COND
                            ((|isEqualOrSubDomain| |t2| |$Integer|)
                             NIL)
                            ('T
                             (OR (|canCoerce| |t1| |t2|)
                                 (|canCoerce| |s1| |s2|)))))
                         ('T (|canCoerce| |s1| |s2|))))))
        (|stopTimingProcess| '|querycoerce|)
        |q|))))

;isSubTowerOf(t1,t2) ==
;  -- assumes RF and RN stuff has been expanded
;  -- tests whether t1 is somewhere inside t2
;  isEqualOrSubDomain(t1,t2) => true
;  null (u := underDomainOf t2) => nil
;  isSubTowerOf(t1,u)

(DEFUN |isSubTowerOf| (|t1| |t2|)
  (PROG (|u|)
    (RETURN
      (COND
        ((|isEqualOrSubDomain| |t1| |t2|) 'T)
        ((NULL (SPADLET |u| (|underDomainOf| |t2|))) NIL)
        ('T (|isSubTowerOf| |t1| |u|))))))

;canCoerceTopMatching(t1,t2,tt1,tt2) ==
;  -- returns true, nil or maybe
;  -- for example, if t1 = P[x] D1 and t2 = P[y] D2 and x = y then
;  -- canCoerce will only be true if D1 = D2
;  not EQ(tt1,tt2) => 'maybe
;  doms := '(Polynomial List Matrix FiniteSet Vector Stream Gaussian)
;  MEMQ(tt1,doms) => canCoerce(CADR t1, CADR t2)
;  not (member(tt1,$univariateDomains) or MEMQ(tt2,$multivariateDomains)) =>
;    'maybe
;  u2 := deconstructT t2
;  1 = #u2 => NIL
;  u1 := deconstructT t1
;  1 = #u1 => NIL                             -- no under domain
;  first(u1) ^= first(u2) => 'maybe
;  canCoerce(underDomainOf t1, underDomainOf t2)

(DEFUN |canCoerceTopMatching| (|t1| |t2| |tt1| |tt2|)
  (PROG (|doms| |u2| |u1|)
    (DECLARE (SPECIAL |$multivariateDomains| |$univariateDomains|))
    (RETURN
      (COND
        ((NULL (EQ |tt1| |tt2|)) '|maybe|)
        ('T
         (SPADLET |doms|
                  '(|Polynomial| |List| |Matrix| |FiniteSet| |Vector|
                       |Stream| |Gaussian|))
         (COND
           ((member |tt1| |doms|) (|canCoerce| (CADR |t1|) (CADR |t2|)))
           ((NULL (OR (member |tt1| |$univariateDomains|)
                      (member |tt2| |$multivariateDomains|)))
            '|maybe|)
           ('T (SPADLET |u2| (|deconstructT| |t2|))
            (COND
              ((EQL 1 (|#| |u2|)) NIL)
              ('T (SPADLET |u1| (|deconstructT| |t1|))
               (COND
                 ((EQL 1 (|#| |u1|)) NIL)
                 ((NEQUAL (CAR |u1|) (CAR |u2|)) '|maybe|)
                 ('T
                  (|canCoerce| (|underDomainOf| |t1|)
                      (|underDomainOf| |t2|)))))))))))))

;canCoerceExplicit2Mapping(t1,t is ['Mapping,target,:argl]) ==
;  -- determines if there a mapping called var with the given args
;  -- and target
;  $useCoerceOrCroak: local := nil
;  t1 is ['Variable,var] =>
;    null (mms :=selectMms1(var,target,argl,[NIL for a in argl],true)) => NIL
;    mm := CAAR mms
;    mm is [., targ, :.] =>
;      targ = target => true
;      false
;    false
;  t1 is ['FunctionCalled,fun] =>
;    funNode := mkAtreeNode fun
;    transferPropsToNode(fun,funNode)
;    mms := CATCH('coerceOrCroaker, selectLocalMms(funNode,fun,argl,target))
;    CONSP mms =>
;      mms is [[['interpOnly,:.],:.]] => nil
;      mm := CAAR mms
;      mm is [., targ, :.] =>
;        targ = target => true
;        false
;      false
;    NIL
;  NIL

(DEFUN |canCoerceExplicit2Mapping| (|t1| |t|)
  (PROG (|$useCoerceOrCroak| |target| |argl| |var| |fun| |funNode|
            |mms| |ISTMP#2| |mm| |ISTMP#1| |targ|)
    (DECLARE (SPECIAL |$useCoerceOrCroak|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |target| (CADR |t|))
             (SPADLET |argl| (CDDR |t|))
             (SPADLET |$useCoerceOrCroak| NIL)
             (COND
               ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|Variable|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |t1|))
                       (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN
                              (SPADLET |var| (QCAR |ISTMP#1|))
                              'T))))
                (COND
                  ((NULL (SPADLET |mms|
                                  (|selectMms1| |var| |target| |argl|
                                      (PROG (G166754)
                                        (SPADLET G166754 NIL)
                                        (RETURN
                                          (DO
                                           ((G166759 |argl|
                                             (CDR G166759))
                                            (|a| NIL))
                                           ((OR (ATOM G166759)
                                             (PROGN
                                               (SETQ |a|
                                                (CAR G166759))
                                               NIL))
                                            (NREVERSE0 G166754))
                                            (SEQ
                                             (EXIT
                                              (SETQ G166754
                                               (CONS NIL G166754)))))))
                                      'T)))
                   NIL)
                  ('T (SPADLET |mm| (CAAR |mms|))
                   (COND
                     ((AND (CONSP |mm|)
                           (PROGN
                             (SPADLET |ISTMP#1| (QCDR |mm|))
                             (AND (CONSP |ISTMP#1|)
                                  (PROGN
                                    (SPADLET |targ| (QCAR |ISTMP#1|))
                                    'T))))
                      (COND
                        ((BOOT-EQUAL |targ| |target|) 'T)
                        ('T NIL)))
                     ('T NIL)))))
               ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|FunctionCalled|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |t1|))
                       (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN
                              (SPADLET |fun| (QCAR |ISTMP#1|))
                              'T))))
                (SPADLET |funNode| (|mkAtreeNode| |fun|))
                (|transferPropsToNode| |fun| |funNode|)
                (SPADLET |mms|
                         (CATCH '|coerceOrCroaker|
                           (|selectLocalMms| |funNode| |fun| |argl|
                               |target|)))
                (COND
                  ((CONSP |mms|)
                   (COND
                     ((AND (CONSP |mms|) (EQ (QCDR |mms|) NIL)
                           (PROGN
                             (SPADLET |ISTMP#1| (QCAR |mms|))
                             (AND (CONSP |ISTMP#1|)
                                  (PROGN
                                    (SPADLET |ISTMP#2|
                                     (QCAR |ISTMP#1|))
                                    (AND (CONSP |ISTMP#2|)
                                     (EQ (QCAR |ISTMP#2|)
                                      '|interpOnly|))))))
                      NIL)
                     ('T (SPADLET |mm| (CAAR |mms|))
                      (COND
                        ((AND (CONSP |mm|)
                              (PROGN
                                (SPADLET |ISTMP#1| (QCDR |mm|))
                                (AND (CONSP |ISTMP#1|)
                                     (PROGN
                                       (SPADLET |targ|
                                        (QCAR |ISTMP#1|))
                                       'T))))
                         (COND
                           ((BOOT-EQUAL |targ| |target|) 'T)
                           ('T NIL)))
                        ('T NIL)))))
                  ('T NIL)))
               ('T NIL)))))))

;canCoerceUnion(t1,t2) ==
;  -- sees if one can coerce to or from a Union Domain
;  -- assumes one of t1 and t2 is one
;  -- get the domains in the union, checking for tagged unions
;  if (isUnion1 := t1 is ['Union,:uds1]) then
;    unionDoms1 :=
;      uds1 and first uds1 is [":",:.] => [t for [.,.,t] in uds1]
;      uds1
;  if (isUnion2 := t2 is ['Union,:uds2]) then
;    unionDoms2 :=
;      uds2 and first uds2 is [":",:.] => [t for [.,.,t] in uds2]
;      uds2
;  isUnion2 =>
;    MEMBER(t1,unionDoms2) => true
;    isUnion1 =>
;      and/[or/[canCoerce(ud1,ud2) for ud2 in unionDoms2]
;        for ud1 in unionDoms1]
;    or/[canCoerce(t1,ud) for ud in unionDoms2]
;  -- next, a little lie
;  t1 is ['Union,d1, ='"failed"] and t2 = d1 => true
;  isUnion1 =>
;    and/[canCoerce(ud,t2) for ud in unionDoms1]
;  keyedSystemError("S2GE0016",['"canCoerceUnion",
;     '"called with 2 non-Unions"])

(DEFUN |canCoerceUnion| (|t1| |t2|)
  (PROG (|uds1| |isUnion1| |unionDoms1| |uds2| |isUnion2| |t|
                |unionDoms2| |ISTMP#1| |d1| |ISTMP#2|)
    (RETURN
      (SEQ (PROGN
             (COND
               ((SPADLET |isUnion1|
                         (AND (CONSP |t1|) (EQ (QCAR |t1|) '|Union|)
                              (PROGN (SPADLET |uds1| (QCDR |t1|)) 'T)))
                (SPADLET |unionDoms1|
                         (COND
                           ((AND |uds1|
                                 (PROGN
                                   (SPADLET |ISTMP#1| (CAR |uds1|))
                                   (AND (CONSP |ISTMP#1|)
                                    (EQ (QCAR |ISTMP#1|) '|:|))))
                            (PROG (G166818)
                              (SPADLET G166818 NIL)
                              (RETURN
                                (DO ((G166824 |uds1| (CDR G166824))
                                     (G166791 NIL))
                                    ((OR (ATOM G166824)
                                      (PROGN
                                        (SETQ G166791
                                         (CAR G166824))
                                        NIL)
                                      (PROGN
                                        (PROGN
                                          (SPADLET |t|
                                           (CADDR G166791))
                                          G166791)
                                        NIL))
                                     (NREVERSE0 G166818))
                                  (SEQ (EXIT
                                        (SETQ G166818
                                         (CONS |t| G166818))))))))
                           ('T |uds1|)))))
             (COND
               ((SPADLET |isUnion2|
                         (AND (CONSP |t2|) (EQ (QCAR |t2|) '|Union|)
                              (PROGN (SPADLET |uds2| (QCDR |t2|)) 'T)))
                (SPADLET |unionDoms2|
                         (COND
                           ((AND |uds2|
                                 (PROGN
                                   (SPADLET |ISTMP#1| (CAR |uds2|))
                                   (AND (CONSP |ISTMP#1|)
                                    (EQ (QCAR |ISTMP#1|) '|:|))))
                            (PROG (G166836)
                              (SPADLET G166836 NIL)
                              (RETURN
                                (DO ((G166842 |uds2| (CDR G166842))
                                     (G166797 NIL))
                                    ((OR (ATOM G166842)
                                      (PROGN
                                        (SETQ G166797
                                         (CAR G166842))
                                        NIL)
                                      (PROGN
                                        (PROGN
                                          (SPADLET |t|
                                           (CADDR G166797))
                                          G166797)
                                        NIL))
                                     (NREVERSE0 G166836))
                                  (SEQ (EXIT
                                        (SETQ G166836
                                         (CONS |t| G166836))))))))
                           ('T |uds2|)))))
             (COND
               (|isUnion2|
                   (COND
                     ((|member| |t1| |unionDoms2|) 'T)
                     (|isUnion1|
                         (PROG (G166849)
                           (SPADLET G166849 'T)
                           (RETURN
                             (DO ((G166855 NIL (NULL G166849))
                                  (G166856 |unionDoms1|
                                      (CDR G166856))
                                  (|ud1| NIL))
                                 ((OR G166855 (ATOM G166856)
                                      (PROGN
                                        (SETQ |ud1| (CAR G166856))
                                        NIL))
                                  G166849)
                               (SEQ (EXIT
                                     (SETQ G166849
                                      (AND G166849
                                       (PROG (G166863)
                                         (SPADLET G166863 NIL)
                                         (RETURN
                                           (DO
                                            ((G166869 NIL G166863)
                                             (G166870 |unionDoms2|
                                              (CDR G166870))
                                             (|ud2| NIL))
                                            ((OR G166869
                                              (ATOM G166870)
                                              (PROGN
                                                (SETQ |ud2|
                                                 (CAR G166870))
                                                NIL))
                                             G166863)
                                             (SEQ
                                              (EXIT
                                               (SETQ G166863
                                                (OR G166863
                                                 (|canCoerce| |ud1|
                                                  |ud2|))))))))))))))))
                     ('T
                      (PROG (G166877)
                        (SPADLET G166877 NIL)
                        (RETURN
                          (DO ((G166883 NIL G166877)
                               (G166884 |unionDoms2| (CDR G166884))
                               (|ud| NIL))
                              ((OR G166883 (ATOM G166884)
                                   (PROGN
                                     (SETQ |ud| (CAR G166884))
                                     NIL))
                               G166877)
                            (SEQ (EXIT (SETQ G166877
                                        (OR G166877
                                         (|canCoerce| |t1| |ud|)))))))))))
               ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|Union|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |t1|))
                       (AND (CONSP |ISTMP#1|)
                            (PROGN
                              (SPADLET |d1| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (CONSP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (EQUAL (QCAR |ISTMP#2|) '"failed")))))
                     (BOOT-EQUAL |t2| |d1|))
                'T)
               (|isUnion1|
                   (PROG (G166891)
                     (SPADLET G166891 'T)
                     (RETURN
                       (DO ((G166897 NIL (NULL G166891))
                            (G166898 |unionDoms1| (CDR G166898))
                            (|ud| NIL))
                           ((OR G166897 (ATOM G166898)
                                (PROGN
                                  (SETQ |ud| (CAR G166898))
                                  NIL))
                            G166891)
                         (SEQ (EXIT (SETQ G166891
                                     (AND G166891
                                      (|canCoerce| |ud| |t2|)))))))))
               ('T
                (|keyedSystemError| 'S2GE0016
                    (CONS "canCoerceUnion"
                          (CONS "called with 2 non-Unions" NIL))))))))))

;canCoerceByMap(t1,t2) ==
;  -- idea is this: if t1 is D U1 and t2 is D U2, then look for
;  -- map: (U1 -> U2, D U1) -> D U2.  If it exists, then answer true
;  -- if canCoerceFrom(t1,t2).
;  u2 := deconstructT t2
;  1 = #u2 => NIL
;  u1 := deconstructT t1
;  1 = #u1 => NIL                             -- no under domain
;  CAR(u1) ^= CAR(u2) => NIL
;  top := CAAR u1
;  u1 := underDomainOf t1
;  u2 := underDomainOf t2
;  absolutelyCannotCoerce(u1,u2) => NIL
;  -- save some time for those we know about
;  know := '(List Vector Segment Stream UniversalSegment Array
;    Polynomial UnivariatePolynomial SquareMatrix Matrix)
;  top in know => canCoerce(u1,u2)
;  null selectMms1('map,t2,[['Mapping,u2,u1],t1],
;    [['Mapping,u2,u1],u1],NIL) => NIL
;  -- don't bother checking for Undef, so avoid instantiation
;  canCoerce(u1,u2)

(DEFUN |canCoerceByMap| (|t1| |t2|)
  (PROG (|top| |u1| |u2| |know|)
    (RETURN
      (PROGN
        (SPADLET |u2| (|deconstructT| |t2|))
        (COND
          ((EQL 1 (|#| |u2|)) NIL)
          ('T (SPADLET |u1| (|deconstructT| |t1|))
           (COND
             ((EQL 1 (|#| |u1|)) NIL)
             ((NEQUAL (CAR |u1|) (CAR |u2|)) NIL)
             ('T (SPADLET |top| (CAAR |u1|))
              (SPADLET |u1| (|underDomainOf| |t1|))
              (SPADLET |u2| (|underDomainOf| |t2|))
              (COND
                ((|absolutelyCannotCoerce| |u1| |u2|) NIL)
                ('T
                 (SPADLET |know|
                          '(|List| |Vector| |Segment| |Stream|
                                   |UniversalSegment| |Array|
                                   |Polynomial| |UnivariatePolynomial|
                                   |SquareMatrix| |Matrix|))
                 (COND
                   ((|member| |top| |know|) (|canCoerce| |u1| |u2|))
                   ((NULL (|selectMms1| '|map| |t2|
                              (CONS (CONS '|Mapping|
                                     (CONS |u2| (CONS |u1| NIL)))
                                    (CONS |t1| NIL))
                              (CONS (CONS '|Mapping|
                                     (CONS |u2| (CONS |u1| NIL)))
                                    (CONS |u1| NIL))
                              NIL))
                    NIL)
                   ('T (|canCoerce| |u1| |u2|)))))))))))))

;canCoerceTower(t1,t2) ==
;-- tries to find a coercion between top level t2 and somewhere inside t1
;-- builds new bubbled type, for which coercion is called recursively
;  canCoerceByMap(t1,t2) or newCanCoerceCommute(t1,t2) or
;   canCoerceLocal(t1,t2) or canCoercePermute(t1,t2) or
;    [c1,:arg1]:= deconstructT t1
;    arg1 and
;      TL:= NIL
;      arg:= arg1
;      until x or not arg repeat x:=
;        t:= last arg
;        [c,:arg]:= deconstructT t
;        TL:= [c,arg,:TL]
;        arg and coerceIntTest(t,t2) and
;          CDDR TL =>
;            s:= constructT(c1,replaceLast(arg1,bubbleConstructor TL))
;            canCoerceLocal(t1,s) and
;              [c2,:arg2]:= deconstructT last s
;              s1:= bubbleConstructor [c2,arg2,c1,arg1]
;              canCoerceCommute(s,s1) and canCoerceLocal(s1,t2)
;          s:= bubbleConstructor [c,arg,c1,arg1]
;          newCanCoerceCommute(t1,s) and canCoerceLocal(s,t2)
;      x

(DEFUN |canCoerceTower| (|t1| |t2|)
  (PROG (|c1| |arg1| |t| |c| |arg| TL |LETTMP#1| |c2| |arg2| |s1| |s|
              |x|)
    (RETURN
      (SEQ (OR (|canCoerceByMap| |t1| |t2|)
               (|newCanCoerceCommute| |t1| |t2|)
               (|canCoerceLocal| |t1| |t2|)
               (|canCoercePermute| |t1| |t2|)
               (PROGN
                 (SPADLET |LETTMP#1| (|deconstructT| |t1|))
                 (SPADLET |c1| (CAR |LETTMP#1|))
                 (SPADLET |arg1| (CDR |LETTMP#1|))
                 (AND |arg1|
                      (PROGN
                        (SPADLET TL NIL)
                        (SPADLET |arg| |arg1|)
                        (DO ((G166978 NIL (OR |x| (NULL |arg|))))
                            (G166978 NIL)
                          (SEQ (EXIT (SPADLET |x|
                                      (PROGN
                                        (SPADLET |t| (|last| |arg|))
                                        (SPADLET |LETTMP#1|
                                         (|deconstructT| |t|))
                                        (SPADLET |c| (CAR |LETTMP#1|))
                                        (SPADLET |arg|
                                         (CDR |LETTMP#1|))
                                        (SPADLET TL
                                         (CONS |c| (CONS |arg| TL)))
                                        (AND |arg|
                                         (|coerceIntTest| |t| |t2|)
                                         (COND
                                           ((CDDR TL)
                                            (SPADLET |s|
                                             (|constructT| |c1|
                                              (|replaceLast| |arg1|
                                               (|bubbleConstructor| TL))))
                                            (AND
                                             (|canCoerceLocal| |t1|
                                              |s|)
                                             (PROGN
                                               (SPADLET |LETTMP#1|
                                                (|deconstructT|
                                                 (|last| |s|)))
                                               (SPADLET |c2|
                                                (CAR |LETTMP#1|))
                                               (SPADLET |arg2|
                                                (CDR |LETTMP#1|))
                                               (SPADLET |s1|
                                                (|bubbleConstructor|
                                                 (CONS |c2|
                                                  (CONS |arg2|
                                                   (CONS |c1|
                                                    (CONS |arg1| NIL))))))
                                               (AND
                                                (|canCoerceCommute| |s|
                                                 |s1|)
                                                (|canCoerceLocal| |s1|
                                                 |t2|)))))
                                           ('T
                                            (SPADLET |s|
                                             (|bubbleConstructor|
                                              (CONS |c|
                                               (CONS |arg|
                                                (CONS |c1|
                                                 (CONS |arg1| NIL))))))
                                            (AND
                                             (|newCanCoerceCommute|
                                              |t1| |s|)
                                             (|canCoerceLocal| |s|
                                              |t2|))))))))))
                        |x|))))))))

;canCoerceLocal(t1,t2) ==
;  -- test for coercion on top level
;  p:= ASSQ(CAR t1,$CoerceTable)
;  p and ASSQ(CAR t2,CDR p) is [.,:[tag,fun]] =>
;    tag='partial => NIL
;    tag='total   => true
;    (functionp(fun) and
;       (v:=CATCH('coerceFailure,FUNCALL(fun,'_$fromCoerceable_$,t1,t2)))
;         and v ^= $coerceFailure)  or  canCoerceByFunction(t1,t2)
;  canCoerceByFunction(t1,t2)

(DEFUN |canCoerceLocal| (|t1| |t2|)
  (PROG (|p| |ISTMP#1| |ISTMP#2| |tag| |ISTMP#3| |fun| |v|)
    (DECLARE (SPECIAL |$coerceFailure| |$CoerceTable|))
    (RETURN
      (PROGN
        (SPADLET |p| (ASSQ (CAR |t1|) |$CoerceTable|))
        (COND
          ((AND |p|
                (PROGN
                  (SPADLET |ISTMP#1| (ASSQ (CAR |t2|) (CDR |p|)))
                  (AND (CONSP |ISTMP#1|)
                       (PROGN
                         (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (CONSP |ISTMP#2|)
                              (PROGN
                                (SPADLET |tag| (QCAR |ISTMP#2|))
                                (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                                (AND (CONSP |ISTMP#3|)
                                     (EQ (QCDR |ISTMP#3|) NIL)
                                     (PROGN
                                       (SPADLET |fun| (QCAR |ISTMP#3|))
                                       'T))))))))
           (COND
             ((BOOT-EQUAL |tag| '|partial|) NIL)
             ((BOOT-EQUAL |tag| '|total|) 'T)
             ('T
              (OR (AND (|functionp| |fun|)
                       (SPADLET |v|
                                (CATCH '|coerceFailure|
                                  (FUNCALL |fun| '|$fromCoerceable$|
                                           |t1| |t2|)))
                       (NEQUAL |v| |$coerceFailure|))
                  (|canCoerceByFunction| |t1| |t2|)))))
          ('T (|canCoerceByFunction| |t1| |t2|)))))))

;canCoerceCommute(t1,t2) ==
;-- THIS IS OUT-MODED AND WILL GO AWAY SOON  RSS 2-87
;-- t1 is t2 with the two top level constructors commuted
;-- looks for the existence of a commuting function
;  CAR(t1) in (l := [$QuotientField, 'Gaussian]) and
;    CAR(t2) in l => true
;  p:= ASSQ(CAR t1,$CommuteTable)
;  p and ASSQ(CAR t2,CDR p) is [.,:['commute,.]]

(DEFUN |canCoerceCommute| (|t1| |t2|)
  (PROG (|l| |p| |ISTMP#1| |ISTMP#2| |ISTMP#3|)
    (DECLARE (SPECIAL |$CommuteTable| |$QuotientField|))
    (RETURN
      (COND
        ((AND (|member| (CAR |t1|)
                  (SPADLET |l|
                           (CONS |$QuotientField|
                                 (CONS '|Gaussian| NIL))))
              (|member| (CAR |t2|) |l|))
         'T)
        ('T (SPADLET |p| (ASSQ (CAR |t1|) |$CommuteTable|))
         (AND |p|
              (PROGN
                (SPADLET |ISTMP#1| (ASSQ (CAR |t2|) (CDR |p|)))
                (AND (CONSP |ISTMP#1|)
                     (PROGN
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (CONSP |ISTMP#2|)
                            (EQ (QCAR |ISTMP#2|) '|commute|)
                            (PROGN
                              (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                              (AND (CONSP |ISTMP#3|)
                                   (EQ (QCDR |ISTMP#3|) NIL)))))))))))))

;newCanCoerceCommute(t1,t2) ==
;  coerceIntCommute(objNewWrap("$fromCoerceable$",t1),t2)

(DEFUN |newCanCoerceCommute| (|t1| |t2|)
  (|coerceIntCommute| (|objNewWrap| '|$fromCoerceable$| |t1|) |t2|))

;canCoercePermute(t1,t2) ==
;  -- try to generate a sequence of transpositions that will convert
;  -- t1 into t2
;  t2 in '((Integer) (OutputForm)) => NIL
;  towers := computeTTTranspositions(t1,t2)
;  -- at this point, CAR towers = t1 and last towers should be similar
;  -- to t2 in the sense that the components of t1 are in the same order
;  -- as in t2. If length towers = 2 and t2 = last towers, we quit to
;  -- avoid an infinte loop.
;  NULL towers or NULL CDR towers => NIL
;  NULL CDDR towers and t2 = CADR towers => NIL
;  -- do the coercions successively, quitting if any fail
;  ok := true
;  for t in CDR towers while ok repeat
;    ok := canCoerce(t1,t)
;    if ok then t1 := t
;  ok

(DEFUN |canCoercePermute| (|t1| |t2|)
  (PROG (|towers| |ok|)
    (RETURN
      (SEQ (COND
             ((|member| |t2| '((|Integer|) (|OutputForm|))) NIL)
             ('T
              (SPADLET |towers| (|computeTTTranspositions| |t1| |t2|))
              (COND
                ((OR (NULL |towers|) (NULL (CDR |towers|))) NIL)
                ((AND (NULL (CDDR |towers|))
                      (BOOT-EQUAL |t2| (CADR |towers|)))
                 NIL)
                ('T (SPADLET |ok| 'T)
                 (DO ((G167071 (CDR |towers|) (CDR G167071))
                      (|t| NIL))
                     ((OR (ATOM G167071)
                          (PROGN (SETQ |t| (CAR G167071)) NIL)
                          (NULL |ok|))
                      NIL)
                   (SEQ (EXIT (PROGN
                                (SPADLET |ok| (|canCoerce| |t1| |t|))
                                (COND
                                  (|ok| (SPADLET |t1| |t|))
                                  ('T NIL))))))
                 |ok|))))))))

;canConvertByFunction(m1,m2) ==
;  null $useConvertForCoercions => NIL
;  canCoerceByFunction1(m1,m2,'convert)

(DEFUN |canConvertByFunction| (|m1| |m2|)
  (DECLARE (SPECIAL |$useConvertForCoercions|))
  (COND
    ((NULL |$useConvertForCoercions|) NIL)
    ('T (|canCoerceByFunction1| |m1| |m2| '|convert|))))

;canCoerceByFunction(m1,m2) == canCoerceByFunction1(m1,m2,'coerce)

(DEFUN |canCoerceByFunction| (|m1| |m2|)
  (|canCoerceByFunction1| |m1| |m2| '|coerce|))

;canCoerceByFunction1(m1,m2,fun) ==
;  -- calls selectMms with $Coerce=NIL and tests for required target=m2
;  $declaredMode:local:= NIL
;  $reportBottomUpFlag:local:= NIL
;  -- have to handle cases where we might have changed from RN to QF I
;  -- make 2 lists of expanded and unexpanded types
;  l1 := REMDUP [m1,eqType m1]
;  l2 := REMDUP [m2,eqType m2]
;  ans  := NIL
;  for t1 in l1 while not ans repeat
;    for t2 in l2 while not ans repeat
;      l := selectMms1(fun,t2,[t1],[t1],NIL)
;      ans := [x for x in l | x is [sig,:.] and CADR sig=t2 and
;       CADDR sig=t1 and
;        CAR(sig) isnt ['TypeEquivalence,:.]] and true
;  ans

(DEFUN |canCoerceByFunction1| (|m1| |m2| |fun|)
  (PROG (|$declaredMode| |$reportBottomUpFlag| |l1| |l2| |l| |sig|
            |ISTMP#1| |ans|)
    (DECLARE (SPECIAL |$declaredMode| |$reportBottomUpFlag|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |$declaredMode| NIL)
             (SPADLET |$reportBottomUpFlag| NIL)
             (SPADLET |l1|
                      (REMDUP (CONS |m1| (CONS (|eqType| |m1|) NIL))))
             (SPADLET |l2|
                      (REMDUP (CONS |m2| (CONS (|eqType| |m2|) NIL))))
             (SPADLET |ans| NIL)
             (DO ((G167106 |l1| (CDR G167106)) (|t1| NIL))
                 ((OR (ATOM G167106)
                      (PROGN (SETQ |t1| (CAR G167106)) NIL)
                      (NULL (NULL |ans|)))
                  NIL)
               (SEQ (EXIT (DO ((G167123 |l2| (CDR G167123))
                               (|t2| NIL))
                              ((OR (ATOM G167123)
                                   (PROGN
                                     (SETQ |t2| (CAR G167123))
                                     NIL)
                                   (NULL (NULL |ans|)))
                               NIL)
                            (SEQ (EXIT (PROGN
                                         (SPADLET |l|
                                          (|selectMms1| |fun| |t2|
                                           (CONS |t1| NIL)
                                           (CONS |t1| NIL) NIL))
                                         (SPADLET |ans|
                                          (AND
                                           (PROG (G167135)
                                             (SPADLET G167135 NIL)
                                             (RETURN
                                               (DO
                                                ((G167141 |l|
                                                  (CDR G167141))
                                                 (|x| NIL))
                                                ((OR (ATOM G167141)
                                                  (PROGN
                                                    (SETQ |x|
                                                     (CAR G167141))
                                                    NIL))
                                                 (NREVERSE0 G167135))
                                                 (SEQ
                                                  (EXIT
                                                   (COND
                                                     ((AND (CONSP |x|)
                                                       (PROGN
                                                         (SPADLET |sig|
                                                          (QCAR |x|))
                                                         'T)
                                                       (BOOT-EQUAL
                                                        (CADR |sig|)
                                                        |t2|)
                                                       (BOOT-EQUAL
                                                        (CADDR |sig|)
                                                        |t1|)
                                                       (NULL
                                                        (PROGN
                                                          (SPADLET
                                                           |ISTMP#1|
                                                           (CAR |sig|))
                                                          (AND
                                                           (CONSP
                                                            |ISTMP#1|)
                                                           (EQ
                                                            (QCAR
                                                             |ISTMP#1|)
                                                        '|TypeEquivalence|)))))
                                                      (SETQ G167135
                                                       (CONS |x|
                                                        G167135)))))))))
                                           'T)))))))))
             |ans|)))))


;absolutelyCanCoerceByCheating(t1,t2) ==
;  -- this typically involves subdomains and towers where the only
;  -- difference is a subdomain
;  isEqualOrSubDomain(t1,t2) => true
;  typeIsASmallInteger(t1) and t2 = $Integer => true
;  ATOM(t1) or ATOM(t2) => false
;  [tl1,:u1] := deconstructT t1
;  [tl2,:u2] := deconstructT t2
;  tl1 = '(Stream) and tl2 = '(InfiniteTuple) =>
;    #u1 ^= #u2 => false
;    "and"/[absolutelyCanCoerceByCheating(x1,x2) for x1 in u1 for x2 in u2]
;  tl1 ^= tl2 => false
;  #u1 ^= #u2 => false
;  "and"/[absolutelyCanCoerceByCheating(x1,x2) for x1 in u1 for x2 in u2]

(DEFUN |absolutelyCanCoerceByCheating| (|t1| |t2|)
  (PROG (|tl1| |u1| |LETTMP#1| |tl2| |u2|)
    (DECLARE (SPECIAL |$Integer|))
    (RETURN
      (SEQ (COND
             ((|isEqualOrSubDomain| |t1| |t2|) 'T)
             ((AND (|typeIsASmallInteger| |t1|)
                   (BOOT-EQUAL |t2| |$Integer|))
              'T)
             ((OR (ATOM |t1|) (ATOM |t2|)) NIL)
             ('T (SPADLET |LETTMP#1| (|deconstructT| |t1|))
              (SPADLET |tl1| (CAR |LETTMP#1|))
              (SPADLET |u1| (CDR |LETTMP#1|))
              (SPADLET |LETTMP#1| (|deconstructT| |t2|))
              (SPADLET |tl2| (CAR |LETTMP#1|))
              (SPADLET |u2| (CDR |LETTMP#1|))
              (COND
                ((AND (BOOT-EQUAL |tl1| '(|Stream|))
                      (BOOT-EQUAL |tl2| '(|InfiniteTuple|)))
                 (COND
                   ((NEQUAL (|#| |u1|) (|#| |u2|)) NIL)
                   ('T
                    (PROG (G167180)
                      (SPADLET G167180 'T)
                      (RETURN
                        (DO ((G167187 NIL (NULL G167180))
                             (G167188 |u1| (CDR G167188))
                             (|x1| NIL)
                             (G167189 |u2| (CDR G167189))
                             (|x2| NIL))
                            ((OR G167187 (ATOM G167188)
                                 (PROGN
                                   (SETQ |x1| (CAR G167188))
                                   NIL)
                                 (ATOM G167189)
                                 (PROGN
                                   (SETQ |x2| (CAR G167189))
                                   NIL))
                             G167180)
                          (SEQ (EXIT (SETQ G167180
                                      (AND G167180
                                       (|absolutelyCanCoerceByCheating|
                                        |x1| |x2|)))))))))))
                ((NEQUAL |tl1| |tl2|) NIL)
                ((NEQUAL (|#| |u1|) (|#| |u2|)) NIL)
                ('T
                 (PROG (G167199)
                   (SPADLET G167199 'T)
                   (RETURN
                     (DO ((G167206 NIL (NULL G167199))
                          (G167207 |u1| (CDR G167207)) (|x1| NIL)
                          (G167208 |u2| (CDR G167208)) (|x2| NIL))
                         ((OR G167206 (ATOM G167207)
                              (PROGN (SETQ |x1| (CAR G167207)) NIL)
                              (ATOM G167208)
                              (PROGN (SETQ |x2| (CAR G167208)) NIL))
                          G167199)
                       (SEQ (EXIT (SETQ G167199
                                        (AND G167199
                                         (|absolutelyCanCoerceByCheating|
                                          |x1| |x2|))))))))))))))))

;absolutelyCannotCoerce(t1,t2) ==
;  -- response of true means "definitely cannot coerce"
;  -- this is largely an efficiency hack
;  ATOM(t1) or ATOM(t2) => NIL
;  t2 = '(None) => true
;  n1   := CAR t1
;  n2   := CAR t2
;  QFI  := [$QuotientField, $Integer]
;  int2 := isEqualOrSubDomain(t2,$Integer)
;  scalars := '(BigFloat NewFloat Float DoubleFloat RationalNumber)
;  MEMQ(n1,scalars) and int2 => true
;  (t1 = QFI) and int2       => true
;  num2 := int2 or MEMQ(n2,scalars) or (t2 = QFI)
;  isVar1 := MEMQ(n1,'(Variable Symbol))
;  num2 and isVar1 => true
;  num2 and MEMQ(n1,$univariateDomains) => true
;  num2 and MEMQ(n1,$multivariateDomains) => true
;  miscpols :=  '(Polynomial ElementaryFunction SimpleAlgebraicExtension)
;  num2 and MEMQ(n1,miscpols) => true
;  aggs :=  '(
;    Matrix List Vector Stream Array RectangularMatrix FiniteSet
;       )
;  u1 := underDomainOf t1
;  u2 := underDomainOf t2
;  MEMQ(n1,aggs) and (u1 = t2) => true
;  MEMQ(n2,aggs) and (u2 = t1) => true
;  algs :=  '(
;    SquareMatrix Gaussian RectangularMatrix Quaternion
;       )
;  nonpols := append(aggs,algs)
;  num2 and MEMQ(n1,nonpols) => true
;  isVar1 and MEMQ(n2,nonpols) and
;    absolutelyCannotCoerce(t1,u2) => true
;  (member(n1,scalars) or (t1 = QFI)) and (t2 = '(Polynomial (Integer))) =>
;    true
;  v2 := deconstructT t2
;  1 = #v2 => NIL
;  v1 := deconstructT t1
;  1 = #v1 => NIL
;  CAR(v1) ^= CAR(v2) => NIL
;  absolutelyCannotCoerce(u1,u2)

(DEFUN |absolutelyCannotCoerce| (|t1| |t2|)
  (PROG (|n1| |n2| QFI |int2| |scalars| |num2| |isVar1| |miscpols|
              |aggs| |u1| |u2| |algs| |nonpols| |v2| |v1|)
    (DECLARE (SPECIAL |$multivariateDomains| |$univariateDomains|
                      |$Integer| |$QuotientField|))
    (RETURN
      (COND
        ((OR (ATOM |t1|) (ATOM |t2|)) NIL)
        ((BOOT-EQUAL |t2| '(|None|)) 'T)
        ('T (SPADLET |n1| (CAR |t1|)) (SPADLET |n2| (CAR |t2|))
         (SPADLET QFI (CONS |$QuotientField| (CONS |$Integer| NIL)))
         (SPADLET |int2| (|isEqualOrSubDomain| |t2| |$Integer|))
         (SPADLET |scalars|
                  '(|BigFloat| |NewFloat| |Float| |DoubleFloat|
                       |RationalNumber|))
         (COND
           ((AND (member |n1| |scalars|) |int2|) 'T)
           ((AND (BOOT-EQUAL |t1| QFI) |int2|) 'T)
           ('T
            (SPADLET |num2|
                     (OR |int2| (member |n2| |scalars|)
                         (BOOT-EQUAL |t2| QFI)))
            (SPADLET |isVar1| (member |n1| '(|Variable| |Symbol|)))
            (COND
              ((AND |num2| |isVar1|) 'T)
              ((AND |num2| (member |n1| |$univariateDomains|)) 'T)
              ((AND |num2| (member |n1| |$multivariateDomains|)) 'T)
              ('T
               (SPADLET |miscpols|
                        '(|Polynomial| |ElementaryFunction|
                             |SimpleAlgebraicExtension|))
               (COND
                 ((AND |num2| (member |n1| |miscpols|)) 'T)
                 ('T
                  (SPADLET |aggs|
                           '(|Matrix| |List| |Vector| |Stream| |Array|
                                |RectangularMatrix| |FiniteSet|))
                  (SPADLET |u1| (|underDomainOf| |t1|))
                  (SPADLET |u2| (|underDomainOf| |t2|))
                  (COND
                    ((AND (member |n1| |aggs|) (BOOT-EQUAL |u1| |t2|))
                     'T)
                    ((AND (member |n2| |aggs|) (BOOT-EQUAL |u2| |t1|))
                     'T)
                    ('T
                     (SPADLET |algs|
                              '(|SquareMatrix| |Gaussian|
                                   |RectangularMatrix| |Quaternion|))
                     (SPADLET |nonpols| (APPEND |aggs| |algs|))
                     (COND
                       ((AND |num2| (member |n1| |nonpols|)) 'T)
                       ((AND |isVar1| (member |n2| |nonpols|)
                             (|absolutelyCannotCoerce| |t1| |u2|))
                        'T)
                       ((AND (OR (member |n1| |scalars|)
                                 (BOOT-EQUAL |t1| QFI))
                             (BOOT-EQUAL |t2|
                                 '(|Polynomial| (|Integer|))))
                        'T)
                       ('T (SPADLET |v2| (|deconstructT| |t2|))
                        (COND
                          ((EQL 1 (|#| |v2|)) NIL)
                          ('T (SPADLET |v1| (|deconstructT| |t1|))
                           (COND
                             ((EQL 1 (|#| |v1|)) NIL)
                             ((NEQUAL (CAR |v1|) (CAR |v2|)) NIL)
                    ('T (|absolutelyCannotCoerce| |u1| |u2|))))))))))))))))))))

;typeIsASmallInteger x == (x = $SingleInteger)

(DEFUN |typeIsASmallInteger| (|x|)
  (DECLARE (SPECIAL |$SingleInteger|))
  (BOOT-EQUAL |x| |$SingleInteger|))

;--% Interpreter Coercion Functions
;coerceInteractive(triple,t2) ==
;  -- bind flag for recording/reporting instantiations
;  -- (see recordInstantiation)
;  t1 := objMode triple
;  val := objVal triple
;  null(t2) or t2 = $EmptyMode => NIL
;  t2 = t1 => triple
;  t2 = '$NoValueMode => objNew(val,t2)
;  if t2 is ['SubDomain,x,.] then t2:= x
;  -- JHD added category Aug 1996 for BasicMath
;  t1 in '((Category) (Mode) (Domain) (SubDomain (Domain))) =>
;    t2 = $OutputForm => objNew(val,t2)
;    NIL
;  t1 = '$NoValueMode =>
;    if $compilingMap then clearDependentMaps($mapName,nil)
;    throwKeyedMsg("S2IC0009",[t2,$mapName])
;  $insideCoerceInteractive: local := true
;  expr2 := EQUAL(t2,$OutputForm)
;  if expr2 then startTimingProcess 'print
;  else startTimingProcess 'coercion
;  -- next 2 lines handle cases like '"failed"
;  result :=
;    expr2 and (t1 = val) => objNew(val,$OutputForm)
;    expr2 and t1 is ['Variable,var] => objNewWrap(var,$OutputForm)
;    coerceInt0(triple,t2)
;  if expr2 then stopTimingProcess 'print
;  else stopTimingProcess 'coercion
;  result

(DEFUN |coerceInteractive| (|triple| |t2|)
  (PROG (|$insideCoerceInteractive| |t1| |val| |x| |ISTMP#2| |expr2|
            |ISTMP#1| |var| |result|)
    (DECLARE (SPECIAL |$insideCoerceInteractive| |$OutputForm|
                      |$mapName| |$compilingMap| |$NoValueMode|
                      |$EmptyMode|))
    (RETURN
      (PROGN
        (SPADLET |t1| (|objMode| |triple|))
        (SPADLET |val| (|objVal| |triple|))
        (COND
          ((OR (NULL |t2|) (BOOT-EQUAL |t2| |$EmptyMode|)) NIL)
          ((BOOT-EQUAL |t2| |t1|) |triple|)
          ((BOOT-EQUAL |t2| '|$NoValueMode|) (|objNew| |val| |t2|))
          ('T
           (COND
             ((AND (CONSP |t2|) (EQ (QCAR |t2|) '|SubDomain|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |t2|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (SPADLET |x| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL))))))
              (SPADLET |t2| |x|)))
           (COND
             ((|member| |t1|
                  '((|Category|) (|Mode|) (|Domain|)
                    (|SubDomain| (|Domain|))))
              (COND
                ((BOOT-EQUAL |t2| |$OutputForm|) (|objNew| |val| |t2|))
                ('T NIL)))
             ((BOOT-EQUAL |t1| '|$NoValueMode|)
              (COND
                (|$compilingMap| (|clearDependentMaps| |$mapName| NIL)))
              (|throwKeyedMsg| 'S2IC0009
                  (CONS |t2| (CONS |$mapName| NIL))))
             ('T (SPADLET |$insideCoerceInteractive| 'T)
              (SPADLET |expr2| (BOOT-EQUAL |t2| |$OutputForm|))
              (COND
                (|expr2| (|startTimingProcess| '|print|))
                ('T (|startTimingProcess| '|coercion|)))
              (SPADLET |result|
                       (COND
                         ((AND |expr2| (BOOT-EQUAL |t1| |val|))
                          (|objNew| |val| |$OutputForm|))
                         ((AND |expr2| (CONSP |t1|)
                               (EQ (QCAR |t1|) '|Variable|)
                               (PROGN
                                 (SPADLET |ISTMP#1| (QCDR |t1|))
                                 (AND (CONSP |ISTMP#1|)
                                      (EQ (QCDR |ISTMP#1|) NIL)
                                      (PROGN
                                        (SPADLET |var|
                                         (QCAR |ISTMP#1|))
                                        'T))))
                          (|objNewWrap| |var| |$OutputForm|))
                         ('T (|coerceInt0| |triple| |t2|))))
              (COND
                (|expr2| (|stopTimingProcess| '|print|))
                ('T (|stopTimingProcess| '|coercion|)))
              |result|))))))))

;coerceInt0(triple,t2) ==
;  -- top level interactive coercion, which transfers all RN, RF and RR
;  -- into equivalent types
;  val := objVal triple
;  t1  := objMode triple
;  val='_$fromCoerceable_$ => canCoerceFrom(t1,t2)
;  t1 = t2 => triple
;  if t2 = $OutputForm then
;    s1 := t1
;    s2 := t2
;  else
;    s1 := equiType(t1)
;    s2 := equiType(t2)
;    s1 = s2 => return objNew(val,t2)
;  -- t1 is ['Mapping,:.] and t2 ^= '(Any) => NIL
;  -- note: may be able to coerce TO mapping
;  -- treat Exit like Any
;  -- handle case where we must generate code
;  null(isWrapped val) and
;    (t1 isnt ['FunctionCalled,:.] or not $genValue)=>
;      intCodeGenCOERCE(triple,t2)
;  t1 = $Any and t2 ^= $OutputForm and ([t1',:val'] := unwrap val) and
;    (ans := coerceInt0(objNewWrap(val',t1'),t2)) => ans
;  if not EQ(s1,t1) then triple := objNew(val,s1)
;  x := coerceInt(triple,s2) =>
;    EQ(s2,t2) => x
;    objSetMode(x,t2)
;    x
;  NIL

(DEFUN |coerceInt0| (|triple| |t2|)
  (PROG (|val| |t1| |s1| |s2| |LETTMP#1| |t1'| |val'| |ans| |x|)
    (DECLARE (SPECIAL |$OutputForm| |$Any| |$genValue|))
    (RETURN
      (PROGN
        (SPADLET |val| (|objVal| |triple|))
        (SPADLET |t1| (|objMode| |triple|))
        (COND
          ((BOOT-EQUAL |val| '|$fromCoerceable$|)
           (|canCoerceFrom| |t1| |t2|))
          ((BOOT-EQUAL |t1| |t2|) |triple|)
          ('T
           (COND
             ((BOOT-EQUAL |t2| |$OutputForm|) (SPADLET |s1| |t1|)
              (SPADLET |s2| |t2|))
             ('T (SPADLET |s1| (|equiType| |t1|))
              (SPADLET |s2| (|equiType| |t2|))
              (COND
                ((BOOT-EQUAL |s1| |s2|) (RETURN (|objNew| |val| |t2|))))))
           (COND
             ((AND (NULL (|isWrapped| |val|))
                   (OR (NULL (AND (CONSP |t1|)
                                  (EQ (QCAR |t1|) '|FunctionCalled|)))
                       (NULL |$genValue|)))
              (|intCodeGenCOERCE| |triple| |t2|))
             ((AND (BOOT-EQUAL |t1| |$Any|) (NEQUAL |t2| |$OutputForm|)
                   (PROGN
                     (SPADLET |LETTMP#1| (|unwrap| |val|))
                     (SPADLET |t1'| (CAR |LETTMP#1|))
                     (SPADLET |val'| (CDR |LETTMP#1|))
                     |LETTMP#1|)
                   (SPADLET |ans|
                            (|coerceInt0| (|objNewWrap| |val'| |t1'|)
                                |t2|)))
              |ans|)
             ('T
              (COND
                ((NULL (EQ |s1| |t1|))
                 (SPADLET |triple| (|objNew| |val| |s1|))))
              (COND
                ((SPADLET |x| (|coerceInt| |triple| |s2|))
                 (COND
                   ((EQ |s2| |t2|) |x|)
                   ('T (|objSetMode| |x| |t2|) |x|)))
                ('T NIL))))))))))

;coerceInt(triple, t2) ==
;  val := coerceInt1(triple, t2) => val
;  t1 := objMode triple
;  t1 is ['Variable, :.] =>
;    newMode := getMinimalVarMode(unwrap objVal triple, nil)
;    newVal := coerceInt(triple, newMode)
;    coerceInt(newVal, t2)
;  nil

(DEFUN |coerceInt| (|triple| |t2|)
  (PROG (|val| |t1| |newMode| |newVal|)
    (RETURN
      (COND
        ((SPADLET |val| (|coerceInt1| |triple| |t2|)) |val|)
        ('T (SPADLET |t1| (|objMode| |triple|))
         (COND
           ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|Variable|))
            (SPADLET |newMode|
                     (|getMinimalVarMode|
                         (|unwrap| (|objVal| |triple|)) NIL))
            (SPADLET |newVal| (|coerceInt| |triple| |newMode|))
            (|coerceInt| |newVal| |t2|))
           ('T NIL)))))))

;coerceInt1(triple,t2) ==
;  -- general interactive coercion
;  -- the result is a new triple with type m2 or NIL (= failed)
;  $useCoerceOrCroak: local := true
;  t2 = $EmptyMode => NIL
;  t1 := objMode triple
;  t1=t2 => triple
;  val := objVal triple
;  absolutelyCanCoerceByCheating(t1,t2) => objNew(val,t2)
;  isSubDomain(t2, t1) => coerceSubDomain(val, t1, t2)
;  if typeIsASmallInteger(t1) then
;    (t2 = $Integer) or typeIsASmallInteger(t2) => return objNew(val,t2)
;    sintp := SINTP val
;    sintp and (t2 = $PositiveInteger) and val > 0 => return objNew(val,t2)
;    sintp and (t2 = $NonNegativeInteger) and val >= 0 => return objNew(val,t2)
;  typeIsASmallInteger(t2) and isEqualOrSubDomain(t1, $Integer) and INTP val =>
;    SINTP val => objNew(val,t2)
;    NIL
;  t2 = $Void => objNew(voidValue(),$Void)
;  t2 = $Any => objNewWrap([t1,:unwrap val],'(Any))
;  t1 = $Any and t2 ^= $OutputForm and ([t1',:val'] := unwrap val) and
;    (ans := coerceInt(objNewWrap(val',t1'),t2)) => ans
;  -- next is for tagged union selectors for the time being
;  t1 is ['Variable,=t2] or t2 is ['Variable,=t1] => objNew(val,t2)
;  STRINGP t2 =>
;    t1 is ['Variable,v] and (t2 = PNAME(v)) => objNewWrap(t2,t2)
;    val' := unwrap val
;    (t2 = val') and ((val' = t1) or (t1 = $String)) => objNew(val,t2)
;    NIL
;  --  t1 is ['Tuple,S] and t2 ^= '(OutputForm) =>
;  t1 is ['Tuple,S]  =>
;    coerceInt1(objNewWrap(asTupleAsList unwrap val, ['List, S]), t2)
;  t1 is ['Union,:.] => coerceIntFromUnion(triple,t2)
;  t2 is ['Union,:.] => coerceInt2Union(triple,t2)
;  (STRINGP t1) and (t2 = $String) => objNew(val,$String)
;  (STRINGP t1) and (t2 is ['Variable,v]) =>
;    t1 = PNAME(v) => objNewWrap(v,t2)
;    NIL
;  (STRINGP t1) and (t1 = unwrap val) =>
;    t2 = $OutputForm => objNew(t1,$OutputForm)
;    NIL
;  atom t1 => NIL
;  if t1 = $AnonymousFunction and (t2 is ['Mapping,target,:margl]) then
;    $useCoerceOrCroak := nil
;    [.,vars,:body] := unwrap val
;    vars :=
;      atom vars => [vars]
;      vars is ['Tuple,:.] => rest vars
;      vars
;    #margl ^= #vars => 'continue
;    tree := mkAtree ['ADEF,vars,[target,:margl],[NIL for x in rest t2],:body]
;    CATCH('coerceOrCroaker, bottomUp tree) = 'croaked => nil
;    return getValue tree
;  (t1 = $Symbol) and (t2 is ['Mapping,target,:margl]) =>
;    null (mms := selectMms1(unwrap val,nil,margl,margl,target)) => NIL
;    [dc,targ,:argl] := CAAR mms
;    targ ^= target => NIL
;    $genValue =>
;      fun := getFunctionFromDomain(unwrap val,dc,argl)
;      objNewWrap(fun,t2)
;    val := NRTcompileEvalForm(unwrap val, CDR CAAR mms, evalDomain dc)
;    objNew(val, t2)
;  (t1 is ['Variable,sym]) and (t2 is ['Mapping,target,:margl]) =>
;    null (mms := selectMms1(sym,target,margl,margl,NIL)) =>
;       null (mms := selectMms1(sym,target,margl,margl,true)) => NIL
;    [dc,targ,:argl] := CAAR mms
;    targ ^= target => NIL
;    dc is ["__FreeFunction__",:freeFun] => objNew( freeFun, t2 )
;    $genValue => objNewWrap( getFunctionFromDomain(sym,dc,argl), t2 )
;    val := NRTcompileEvalForm(sym, CDR CAAR mms, evalDomain dc)
;    objNew(val, t2)
;  (t1 is ['FunctionCalled,sym]) and (t2 is ['Mapping,target,:margl]) =>
;    symNode := mkAtreeNode sym
;    transferPropsToNode(sym,symNode)
;    null (mms := selectLocalMms(symNode,sym,margl,target)) => NIL
;    [dc,targ,:argl] := CAAR mms
;    targ ^= target => NIL
;    ml := [target,:margl]
;    intName :=
;      or/[mm for mm in mms | (mm is [[., :ml1],oldName,:.]
;        and compareTypeLists(ml1,ml))] => [oldName]
;      NIL
;    null intName => NIL
;    objNewWrap(intName,t2)
;  (t1 is ['FunctionCalled,sym]) =>
;    (t3 := get(sym,'mode,$e)) and t3 is ['Mapping,:.] =>
;      (triple' := coerceInt(triple,t3)) => coerceInt(triple',t2)
;      NIL
;    NIL
;  EQ(CAR(t1),'Variable) and CONSP(t2) and
;    (isEqualOrSubDomain(t2,$Integer) or
;      (t2 = [$QuotientField, $Integer]) or MEMQ(CAR(t2),
;        '(RationalNumber BigFloat NewFloat Float DoubleFloat))) => NIL
;  ans := coerceRetract(triple,t2) or coerceIntTower(triple,t2) or
;    [.,:arg]:= deconstructT t2
;    arg and
;      t:= coerceInt(triple,last arg)
;      t and coerceByFunction(t,t2)
;  ans or (isSubDomain(t1,$Integer) and
;    coerceInt(objNew(val,$Integer),t2)) or
;      coerceIntAlgebraicConstant(triple,t2) or
;        coerceIntX(val,t1,t2)

(DEFUN |coerceInt1| (|triple| |t2|)
  (PROG (|$useCoerceOrCroak| |t1| |sintp| |t1'| |val'| S |v| |body|
            |vars| |tree| |fun| |freeFun| |val| |target| |margl|
            |symNode| |mms| |dc| |targ| |argl| |ml| |ml1| |ISTMP#2|
            |oldName| |intName| |ISTMP#1| |sym| |t3| |triple'|
            |LETTMP#1| |arg| |t| |ans|)
    (DECLARE (SPECIAL |$useCoerceOrCroak| |$Integer| |$QuotientField|
                      |$e| |$genValue| |$Symbol| |$AnonymousFunction|
                      |$OutputForm| |$String| |$Any| |$Void|
                      |$NonNegativeInteger| |$PositiveInteger|
                      |$EmptyMode|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |$useCoerceOrCroak| 'T)
             (COND
               ((BOOT-EQUAL |t2| |$EmptyMode|) NIL)
               ('T (SPADLET |t1| (|objMode| |triple|))
                (COND
                  ((BOOT-EQUAL |t1| |t2|) |triple|)
                  ('T (SPADLET |val| (|objVal| |triple|))
                   (COND
                     ((|absolutelyCanCoerceByCheating| |t1| |t2|)
                      (|objNew| |val| |t2|))
                     ((|isSubDomain| |t2| |t1|)
                      (|coerceSubDomain| |val| |t1| |t2|))
                     ('T
                      (COND
                        ((|typeIsASmallInteger| |t1|)
                         (COND
                           ((OR (BOOT-EQUAL |t2| |$Integer|)
                                (|typeIsASmallInteger| |t2|))
                            (RETURN (|objNew| |val| |t2|)))
                           ('T (SPADLET |sintp| (typep |val| 'fixnum))
                            (COND
                              ((AND |sintp|
                                    (BOOT-EQUAL |t2|
                                     |$PositiveInteger|)
                                    (> |val| 0))
                               (RETURN (|objNew| |val| |t2|)))
                              ((AND |sintp|
                                    (BOOT-EQUAL |t2|
                                     |$NonNegativeInteger|)
                                    (>= |val| 0))
                               (RETURN (|objNew| |val| |t2|))))))))
                      (COND
                        ((AND (|typeIsASmallInteger| |t2|)
                              (|isEqualOrSubDomain| |t1| |$Integer|)
                              (integerp |val|))
                         (COND
                           ((typep |val| 'fixnum) (|objNew| |val| |t2|))
                           ('T NIL)))
                        ((BOOT-EQUAL |t2| |$Void|)
                         (|objNew| (|voidValue|) |$Void|))
                        ((BOOT-EQUAL |t2| |$Any|)
                         (|objNewWrap| (CONS |t1| (|unwrap| |val|))
                             '(|Any|)))
                        ((AND (BOOT-EQUAL |t1| |$Any|)
                              (NEQUAL |t2| |$OutputForm|)
                              (PROGN
                                (SPADLET |LETTMP#1| (|unwrap| |val|))
                                (SPADLET |t1'| (CAR |LETTMP#1|))
                                (SPADLET |val'| (CDR |LETTMP#1|))
                                |LETTMP#1|)
                              (SPADLET |ans|
                                       (|coerceInt|
                                        (|objNewWrap| |val'| |t1'|)
                                        |t2|)))
                         |ans|)
                        ((OR (AND (CONSP |t1|)
                                  (EQ (QCAR |t1|) '|Variable|)
                                  (PROGN
                                    (SPADLET |ISTMP#1| (QCDR |t1|))
                                    (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (EQUAL (QCAR |ISTMP#1|) |t2|))))
                             (AND (CONSP |t2|)
                                  (EQ (QCAR |t2|) '|Variable|)
                                  (PROGN
                                    (SPADLET |ISTMP#1| (QCDR |t2|))
                                    (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (EQUAL (QCAR |ISTMP#1|) |t1|)))))
                         (|objNew| |val| |t2|))
                        ((STRINGP |t2|)
                         (COND
                           ((AND (CONSP |t1|)
                                 (EQ (QCAR |t1|) '|Variable|)
                                 (PROGN
                                   (SPADLET |ISTMP#1| (QCDR |t1|))
                                   (AND (CONSP |ISTMP#1|)
                                    (EQ (QCDR |ISTMP#1|) NIL)
                                    (PROGN
                                      (SPADLET |v| (QCAR |ISTMP#1|))
                                      'T)))
                                 (BOOT-EQUAL |t2| (PNAME |v|)))
                            (|objNewWrap| |t2| |t2|))
                           ('T (SPADLET |val'| (|unwrap| |val|))
                            (COND
                              ((AND (BOOT-EQUAL |t2| |val'|)
                                    (OR (BOOT-EQUAL |val'| |t1|)
                                     (BOOT-EQUAL |t1| |$String|)))
                               (|objNew| |val| |t2|))
                              ('T NIL)))))
                        ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|Tuple|)
                              (PROGN
                                (SPADLET |ISTMP#1| (QCDR |t1|))
                                (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (PROGN
                                       (SPADLET S (QCAR |ISTMP#1|))
                                       'T))))
                         (|coerceInt1|
                             (|objNewWrap|
                                 (|asTupleAsList| (|unwrap| |val|))
                                 (CONS '|List| (CONS S NIL)))
                             |t2|))
                        ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|Union|))
                         (|coerceIntFromUnion| |triple| |t2|))
                        ((AND (CONSP |t2|) (EQ (QCAR |t2|) '|Union|))
                         (|coerceInt2Union| |triple| |t2|))
                        ((AND (STRINGP |t1|)
                              (BOOT-EQUAL |t2| |$String|))
                         (|objNew| |val| |$String|))
                        ((AND (STRINGP |t1|) (CONSP |t2|)
                              (EQ (QCAR |t2|) '|Variable|)
                              (PROGN
                                (SPADLET |ISTMP#1| (QCDR |t2|))
                                (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (PROGN
                                       (SPADLET |v| (QCAR |ISTMP#1|))
                                       'T))))
                         (COND
                           ((BOOT-EQUAL |t1| (PNAME |v|))
                            (|objNewWrap| |v| |t2|))
                           ('T NIL)))
                        ((AND (STRINGP |t1|)
                              (BOOT-EQUAL |t1| (|unwrap| |val|)))
                         (COND
                           ((BOOT-EQUAL |t2| |$OutputForm|)
                            (|objNew| |t1| |$OutputForm|))
                           ('T NIL)))
                        ((ATOM |t1|) NIL)
                        ('T
                         (COND
                           ((AND (BOOT-EQUAL |t1| |$AnonymousFunction|)
                                 (CONSP |t2|)
                                 (EQ (QCAR |t2|) '|Mapping|)
                                 (PROGN
                                   (SPADLET |ISTMP#1| (QCDR |t2|))
                                   (AND (CONSP |ISTMP#1|)
                                    (PROGN
                                      (SPADLET |target|
                                       (QCAR |ISTMP#1|))
                                      (SPADLET |margl|
                                       (QCDR |ISTMP#1|))
                                      'T))))
                            (SPADLET |$useCoerceOrCroak| NIL)
                            (SPADLET |LETTMP#1| (|unwrap| |val|))
                            (SPADLET |vars| (CADR |LETTMP#1|))
                            (SPADLET |body| (CDDR |LETTMP#1|))
                            (SPADLET |vars|
                                     (COND
                                       ((ATOM |vars|)
                                        (CONS |vars| NIL))
                                       ((AND (CONSP |vars|)
                                         (EQ (QCAR |vars|) '|Tuple|))
                                        (CDR |vars|))
                                       ('T |vars|)))
                            (COND
                              ((NEQUAL (|#| |margl|) (|#| |vars|))
                               '|continue|)
                              ('T
                               (SPADLET |tree|
                                        (|mkAtree|
                                         (CONS 'ADEF
                                          (CONS |vars|
                                           (CONS
                                            (CONS |target| |margl|)
                                            (CONS
                                             (PROG (G167455)
                                               (SPADLET G167455 NIL)
                                               (RETURN
                                                 (DO
                                                  ((G167460
                                                    (CDR |t2|)
                                                    (CDR G167460))
                                                   (|x| NIL))
                                                  ((OR (ATOM G167460)
                                                    (PROGN
                                                      (SETQ |x|
                                                       (CAR G167460))
                                                      NIL))
                                                   (NREVERSE0
                                                    G167455))
                                                   (SEQ
                                                    (EXIT
                                                     (SETQ G167455
                                                      (CONS NIL
                                                       G167455)))))))
                                             |body|))))))
                               (COND
                                 ((BOOT-EQUAL
                                      (CATCH '|coerceOrCroaker|
                                        (|bottomUp| |tree|))
                                      '|croaked|)
                                  NIL)
                                 ('T (RETURN (|getValue| |tree|))))))))
                         (COND
                           ((AND (BOOT-EQUAL |t1| |$Symbol|)
                                 (CONSP |t2|)
                                 (EQ (QCAR |t2|) '|Mapping|)
                                 (PROGN
                                   (SPADLET |ISTMP#1| (QCDR |t2|))
                                   (AND (CONSP |ISTMP#1|)
                                    (PROGN
                                      (SPADLET |target|
                                       (QCAR |ISTMP#1|))
                                      (SPADLET |margl|
                                       (QCDR |ISTMP#1|))
                                      'T))))
                            (COND
                              ((NULL (SPADLET |mms|
                                      (|selectMms1| (|unwrap| |val|)
                                       NIL |margl| |margl| |target|)))
                               NIL)
                              ('T (SPADLET |LETTMP#1| (CAAR |mms|))
                               (SPADLET |dc| (CAR |LETTMP#1|))
                               (SPADLET |targ| (CADR |LETTMP#1|))
                               (SPADLET |argl| (CDDR |LETTMP#1|))
                               (COND
                                 ((NEQUAL |targ| |target|) NIL)
                                 (|$genValue|
                                     (SPADLET |fun|
                                      (|getFunctionFromDomain|
                                       (|unwrap| |val|) |dc| |argl|))
                                     (|objNewWrap| |fun| |t2|))
                                 ('T
                                  (SPADLET |val|
                                           (|NRTcompileEvalForm|
                                            (|unwrap| |val|)
                                            (CDR (CAAR |mms|))
                                            (|evalDomain| |dc|)))
                                  (|objNew| |val| |t2|))))))
                           ((AND (CONSP |t1|)
                                 (EQ (QCAR |t1|) '|Variable|)
                                 (PROGN
                                   (SPADLET |ISTMP#1| (QCDR |t1|))
                                   (AND (CONSP |ISTMP#1|)
                                    (EQ (QCDR |ISTMP#1|) NIL)
                                    (PROGN
                                      (SPADLET |sym| (QCAR |ISTMP#1|))
                                      'T)))
                                 (CONSP |t2|)
                                 (EQ (QCAR |t2|) '|Mapping|)
                                 (PROGN
                                   (SPADLET |ISTMP#1| (QCDR |t2|))
                                   (AND (CONSP |ISTMP#1|)
                                    (PROGN
                                      (SPADLET |target|
                                       (QCAR |ISTMP#1|))
                                      (SPADLET |margl|
                                       (QCDR |ISTMP#1|))
                                      'T))))
                            (SEQ (COND
                                   ((NULL
                                     (SPADLET |mms|
                                      (|selectMms1| |sym| |target|
                                       |margl| |margl| NIL)))
                                    (EXIT
                                     (COND
                                       ((NULL
                                         (SPADLET |mms|
                                          (|selectMms1| |sym| |target|
                                           |margl| |margl| T)))
                                        (EXIT NIL))))))
                                 (SPADLET |LETTMP#1| (CAAR |mms|))
                                 (SPADLET |dc| (CAR |LETTMP#1|))
                                 (SPADLET |targ| (CADR |LETTMP#1|))
                                 (SPADLET |argl| (CDDR |LETTMP#1|))
                                 (COND
                                   ((NEQUAL |targ| |target|)
                                    (EXIT NIL))
                                   ((AND (CONSP |dc|)
                                     (EQ (QCAR |dc|) '|_FreeFunction_|)
                                     (PROGN
                                       (SPADLET |freeFun| (QCDR |dc|))
                                       'T))
                                    (EXIT (|objNew| |freeFun| |t2|))))
                                 (COND
                                   (|$genValue|
                                    (EXIT
                                     (|objNewWrap|
                                      (|getFunctionFromDomain| |sym|
                                       |dc| |argl|)
                                      |t2|))))
                                 (SPADLET |val|
                                          (|NRTcompileEvalForm| |sym|
                                           (CDR (CAAR |mms|))
                                           (|evalDomain| |dc|)))
                                 (|objNew| |val| |t2|)))
                           ((AND (CONSP |t1|)
                                 (EQ (QCAR |t1|) '|FunctionCalled|)
                                 (PROGN
                                   (SPADLET |ISTMP#1| (QCDR |t1|))
                                   (AND (CONSP |ISTMP#1|)
                                    (EQ (QCDR |ISTMP#1|) NIL)
                                    (PROGN
                                      (SPADLET |sym| (QCAR |ISTMP#1|))
                                      'T)))
                                 (CONSP |t2|)
                                 (EQ (QCAR |t2|) '|Mapping|)
                                 (PROGN
                                   (SPADLET |ISTMP#1| (QCDR |t2|))
                                   (AND (CONSP |ISTMP#1|)
                                    (PROGN
                                      (SPADLET |target|
                                       (QCAR |ISTMP#1|))
                                      (SPADLET |margl|
                                       (QCDR |ISTMP#1|))
                                      'T))))
                            (SPADLET |symNode| (|mkAtreeNode| |sym|))
                            (|transferPropsToNode| |sym| |symNode|)
                            (COND
                              ((NULL (SPADLET |mms|
                                      (|selectLocalMms| |symNode| |sym|
                                       |margl| |target|)))
                               NIL)
                              ('T (SPADLET |LETTMP#1| (CAAR |mms|))
                               (SPADLET |dc| (CAR |LETTMP#1|))
                               (SPADLET |targ| (CADR |LETTMP#1|))
                               (SPADLET |argl| (CDDR |LETTMP#1|))
                               (COND
                                 ((NEQUAL |targ| |target|) NIL)
                                 ('T
                                  (SPADLET |ml|
                                           (CONS |target| |margl|))
                                  (SPADLET |intName|
                                           (COND
                                             ((PROG (G167466)
                                                (SPADLET G167466 NIL)
                                                (RETURN
                                                  (DO
                                                   ((G167473 NIL
                                                     G167466)
                                                    (G167474 |mms|
                                                     (CDR G167474))
                                                    (|mm| NIL))
                                                   ((OR G167473
                                                     (ATOM G167474)
                                                     (PROGN
                                                       (SETQ |mm|
                                                        (CAR G167474))
                                                       NIL))
                                                    G167466)
                                                    (SEQ
                                                     (EXIT
                                                      (COND
                                                        ((AND
                                                          (CONSP |mm|)
                                                          (PROGN
                                                            (SPADLET
                                                             |ISTMP#1|
                                                             (QCAR
                                                              |mm|))
                                                            (AND
                                                             (CONSP
                                                              |ISTMP#1|)
                                                             (PROGN
                                                               (SPADLET
                                                                |ml1|
                                                                (QCDR
                                                                 |ISTMP#1|))
                                                               'T)))
                                                          (PROGN
                                                            (SPADLET
                                                             |ISTMP#2|
                                                             (QCDR
                                                              |mm|))
                                                            (AND
                                                             (CONSP
                                                              |ISTMP#2|)
                                                             (PROGN
                                                               (SPADLET
                                                                |oldName|
                                                                (QCAR
                                                                 |ISTMP#2|))
                                                               'T)))
                                                          (|compareTypeLists|
                                                           |ml1| |ml|))
                                                         (SETQ
                                                          G167466
                                                          (OR G167466
                                                           |mm|)))))))))
                                              (CONS |oldName| NIL))
                                             ('T NIL)))
                                  (COND
                                    ((NULL |intName|) NIL)
                                    ('T (|objNewWrap| |intName| |t2|))))))))
                           ((AND (CONSP |t1|)
                                 (EQ (QCAR |t1|) '|FunctionCalled|)
                                 (PROGN
                                   (SPADLET |ISTMP#1| (QCDR |t1|))
                                   (AND (CONSP |ISTMP#1|)
                                    (EQ (QCDR |ISTMP#1|) NIL)
                                    (PROGN
                                      (SPADLET |sym| (QCAR |ISTMP#1|))
                                      'T))))
                            (COND
                              ((AND (SPADLET |t3|
                                     (|get| |sym| '|mode| |$e|))
                                    (CONSP |t3|)
                                    (EQ (QCAR |t3|) '|Mapping|))
                               (COND
                                 ((SPADLET |triple'|
                                           (|coerceInt| |triple| |t3|))
                                  (|coerceInt| |triple'| |t2|))
                                 ('T NIL)))
                              ('T NIL)))
                           ((AND (EQ (CAR |t1|) '|Variable|)
                                 (CONSP |t2|)
                                 (OR (|isEqualOrSubDomain| |t2|
                                      |$Integer|)
                                     (BOOT-EQUAL |t2|
                                      (CONS |$QuotientField|
                                       (CONS |$Integer| NIL)))
                                     (member (CAR |t2|)
                                      '(|RationalNumber| |BigFloat|
                                        |NewFloat| |Float|
                                        |DoubleFloat|))))
                            NIL)
                           ('T
                            (SPADLET |ans|
                                     (OR
                                      (|coerceRetract| |triple| |t2|)
                                      (|coerceIntTower| |triple| |t2|)
                                      (PROGN
                                        (SPADLET |LETTMP#1|
                                         (|deconstructT| |t2|))
                                        (SPADLET |arg|
                                         (CDR |LETTMP#1|))
                                        (AND |arg|
                                         (PROGN
                                           (SPADLET |t|
                                            (|coerceInt| |triple|
                                             (|last| |arg|)))
                                           (AND |t|
                                            (|coerceByFunction| |t|
                                             |t2|)))))))
                            (OR |ans|
                                (AND (|isSubDomain| |t1| |$Integer|)
                                     (|coerceInt|
                                      (|objNew| |val| |$Integer|) |t2|))
                                (|coerceIntAlgebraicConstant| |triple|
                                    |t2|)
                                (|coerceIntX| |val| |t1| |t2|)))))))))))))))))

;coerceSubDomain(val, tSuper, tSub) ==
;  -- Try to coerce from a sub domain to a super domain
;  val = '_$fromCoerceable_$ => nil
;  super := GETDATABASE(first tSub, 'SUPERDOMAIN)
;  superDomain := first super
;  superDomain = tSuper =>
;    coerceImmediateSubDomain(val, tSuper, tSub, CADR super)
;  coerceSubDomain(val, tSuper, superDomain) =>
;    coerceImmediateSubDomain(val, superDomain, tSub, CADR super)
;  nil

(DEFUN |coerceSubDomain| (|val| |tSuper| |tSub|)
  (PROG (|super| |superDomain|)
    (RETURN
      (COND
        ((BOOT-EQUAL |val| '|$fromCoerceable$|) NIL)
        ('T (SPADLET |super| (GETDATABASE (CAR |tSub|) 'SUPERDOMAIN))
         (SPADLET |superDomain| (CAR |super|))
         (COND
           ((BOOT-EQUAL |superDomain| |tSuper|)
            (|coerceImmediateSubDomain| |val| |tSuper| |tSub|
                (CADR |super|)))
           ((|coerceSubDomain| |val| |tSuper| |superDomain|)
            (|coerceImmediateSubDomain| |val| |superDomain| |tSub|
                (CADR |super|)))
           ('T NIL)))))))

;coerceImmediateSubDomain(val, tSuper, tSub, pred) ==
;  predfn := getSubDomainPredicate(tSuper, tSub, pred)
;  FUNCALL(predfn, val, nil) => objNew(val, tSub)
;  nil

(DEFUN |coerceImmediateSubDomain| (|val| |tSuper| |tSub| |pred|)
  (PROG (|predfn|)
    (RETURN
      (PROGN
        (SPADLET |predfn|
                 (|getSubDomainPredicate| |tSuper| |tSub| |pred|))
        (COND
          ((FUNCALL |predfn| |val| NIL) (|objNew| |val| |tSub|))
          ('T NIL))))))

;getSubDomainPredicate(tSuper, tSub, pred) ==
;  $env: local := $InteractiveFrame
;  predfn := HGET($superHash, CONS(tSuper, tSub)) => predfn
;  name := GENSYM()
;  decl := ['_:, name, ['Mapping, $Boolean, tSuper]]
;  interpret(decl, nil)
;  arg := GENSYM()
;  pred' := SUBST(arg, "#1", pred)
;  defn := ['DEF, [name, arg], '(NIL NIL), '(NIL NIL), removeZeroOne pred']
;  interpret(defn, nil)
;  op := mkAtree name
;  transferPropsToNode(name, op)
;  predfn := CADAR selectLocalMms(op, name, [tSuper],$Boolean)
;  HPUT($superHash, CONS(tSuper, tSub), predfn)
;  predfn

(DEFUN |getSubDomainPredicate| (|tSuper| |tSub| |pred|)
  (PROG (|$env| |name| |decl| |arg| |pred'| |defn| |op| |predfn|)
    (DECLARE (SPECIAL |$env| |$superHash| |$Boolean|
                      |$InteractiveFrame|))
    (RETURN
      (PROGN
        (SPADLET |$env| |$InteractiveFrame|)
        (COND
          ((SPADLET |predfn|
                    (HGET |$superHash| (CONS |tSuper| |tSub|)))
           |predfn|)
          ('T (SPADLET |name| (GENSYM))
           (SPADLET |decl|
                    (CONS '|:|
                          (CONS |name|
                                (CONS (CONS '|Mapping|
                                       (CONS |$Boolean|
                                        (CONS |tSuper| NIL)))
                                      NIL))))
           (|interpret| |decl| NIL) (SPADLET |arg| (GENSYM))
           (SPADLET |pred'| (MSUBST |arg| '|#1| |pred|))
           (SPADLET |defn|
                    (CONS 'DEF
                          (CONS (CONS |name| (CONS |arg| NIL))
                                (CONS '(NIL NIL)
                                      (CONS '(NIL NIL)
                                       (CONS (|removeZeroOne| |pred'|)
                                        NIL))))))
           (|interpret| |defn| NIL) (SPADLET |op| (|mkAtree| |name|))
           (|transferPropsToNode| |name| |op|)
           (SPADLET |predfn|
                    (CADAR (|selectLocalMms| |op| |name|
                               (CONS |tSuper| NIL) |$Boolean|)))
           (HPUT |$superHash| (CONS |tSuper| |tSub|) |predfn|)
           |predfn|))))))

;coerceIntX(val,t1, t2) ==
;  -- some experimental things
;  t1 = '(List (None)) =>
;    -- this will almost always be an empty list
;    null unwrap val =>
;      -- try getting a better flavor of List
;      null (t0 := underDomainOf(t2)) => NIL
;      coerceInt(objNewWrap(val,['List,t0]),t2)
;    NIL
;  NIL

(DEFUN |coerceIntX| (|val| |t1| |t2|)
  (PROG (|t0|)
    (RETURN
      (COND
        ((BOOT-EQUAL |t1| '(|List| (|None|)))
         (COND
           ((NULL (|unwrap| |val|))
            (COND
              ((NULL (SPADLET |t0| (|underDomainOf| |t2|))) NIL)
              ('T
               (|coerceInt|
                   (|objNewWrap| |val| (CONS '|List| (CONS |t0| NIL)))
                   |t2|))))
           ('T NIL)))
        ('T NIL)))))

;compareTypeLists(tl1,tl2) ==
;  -- returns true if every type in tl1 is = or is a subdomain of
;  -- the corresponding type in tl2
;  for t1 in tl1 for t2 in tl2 repeat
;    null isEqualOrSubDomain(t1,t2) => return NIL
;  true

(DEFUN |compareTypeLists| (|tl1| |tl2|)
  (PROG ()
    (RETURN
      (SEQ (DO ((G167600 |tl1| (CDR G167600)) (|t1| NIL)
                (G167601 |tl2| (CDR G167601)) (|t2| NIL))
               ((OR (ATOM G167600)
                    (PROGN (SETQ |t1| (CAR G167600)) NIL)
                    (ATOM G167601)
                    (PROGN (SETQ |t2| (CAR G167601)) NIL))
                NIL)
             (SEQ (EXIT (COND
                          ((NULL (|isEqualOrSubDomain| |t1| |t2|))
                           (EXIT (RETURN NIL)))))))
           'T))))

;coerceIntAlgebraicConstant(object,t2) ==
;  -- should use = from domain, but have to check on defaults code
;  t1 := objMode object
;  val := objValUnwrap object
;  ofCategory(t1,'(Monoid)) and ofCategory(t2,'(Monoid)) and
;    val = getConstantFromDomain('(One),t1) =>
;      objNewWrap(getConstantFromDomain('(One),t2),t2)
;  ofCategory(t1,'(AbelianMonoid)) and ofCategory(t2,'(AbelianMonoid)) and
;    val = getConstantFromDomain('(Zero),t1) =>
;      objNewWrap(getConstantFromDomain('(Zero),t2),t2)
;  NIL

(DEFUN |coerceIntAlgebraicConstant| (|object| |t2|)
  (PROG (|t1| |val|)
    (RETURN
      (PROGN
        (SPADLET |t1| (|objMode| |object|))
        (SPADLET |val| (|objValUnwrap| |object|))
        (COND
          ((AND (|ofCategory| |t1| '(|Monoid|))
                (|ofCategory| |t2| '(|Monoid|))
                (BOOT-EQUAL |val|
                    (|getConstantFromDomain| '(|One|) |t1|)))
           (|objNewWrap| (|getConstantFromDomain| '(|One|) |t2|) |t2|))
          ((AND (|ofCategory| |t1| '(|AbelianMonoid|))
                (|ofCategory| |t2| '(|AbelianMonoid|))
                (BOOT-EQUAL |val|
                    (|getConstantFromDomain| '(|Zero|) |t1|)))
           (|objNewWrap| (|getConstantFromDomain| '(|Zero|) |t2|) |t2|))
          ('T NIL))))))

;stripUnionTags doms ==
;  [if dom is [":",.,dom'] then dom' else dom for dom in doms]

(DEFUN |stripUnionTags| (|doms|)
  (PROG (|ISTMP#1| |ISTMP#2| |dom'|)
    (RETURN
      (SEQ (PROG (G167639)
             (SPADLET G167639 NIL)
             (RETURN
               (DO ((G167650 |doms| (CDR G167650)) (|dom| NIL))
                   ((OR (ATOM G167650)
                        (PROGN (SETQ |dom| (CAR G167650)) NIL))
                    (NREVERSE0 G167639))
                 (SEQ (EXIT (SETQ G167639
                                  (CONS (COND
                                          ((AND (CONSP |dom|)
                                            (EQ (QCAR |dom|) '|:|)
                                            (PROGN
                                              (SPADLET |ISTMP#1|
                                               (QCDR |dom|))
                                              (AND (CONSP |ISTMP#1|)
                                               (PROGN
                                                 (SPADLET |ISTMP#2|
                                                  (QCDR |ISTMP#1|))
                                                 (AND (CONSP |ISTMP#2|)
                                                  (EQ (QCDR |ISTMP#2|)
                                                   NIL)
                                                  (PROGN
                                                    (SPADLET |dom'|
                                                     (QCAR |ISTMP#2|))
                                                    'T))))))
                                           |dom'|)
                                          ('T |dom|))
                                        G167639)))))))))))

;isTaggedUnion u ==
;  u is ['Union,:tl] and tl and first tl is [":",.,.] and true

(DEFUN |isTaggedUnion| (|u|)
  (PROG (|tl| |ISTMP#1| |ISTMP#2| |ISTMP#3|)
    (RETURN
      (AND (CONSP |u|) (EQ (QCAR |u|) '|Union|)
           (PROGN (SPADLET |tl| (QCDR |u|)) 'T) |tl|
           (PROGN
             (SPADLET |ISTMP#1| (CAR |tl|))
             (AND (CONSP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) '|:|)
                  (PROGN
                    (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                    (AND (CONSP |ISTMP#2|)
                         (PROGN
                           (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                           (AND (CONSP |ISTMP#3|)
                                (EQ (QCDR |ISTMP#3|) NIL)))))))
           'T))))

;getUnionOrRecordTags u ==
;  tags := nil
;  if u is ['Union, :tl] or u is ['Record, :tl] then
;      for t in tl repeat
;         if t is [":",tag,.] then tags := cons(tag, tags)
;  tags

(DEFUN |getUnionOrRecordTags| (|u|)
  (PROG (|tl| |ISTMP#1| |tag| |ISTMP#2| |tags|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |tags| NIL)
             (COND
               ((OR (AND (CONSP |u|) (EQ (QCAR |u|) '|Union|)
                         (PROGN (SPADLET |tl| (QCDR |u|)) 'T))
                    (AND (CONSP |u|) (EQ (QCAR |u|) '|Record|)
                         (PROGN (SPADLET |tl| (QCDR |u|)) 'T)))
                (DO ((G167701 |tl| (CDR G167701)) (|t| NIL))
                    ((OR (ATOM G167701)
                         (PROGN (SETQ |t| (CAR G167701)) NIL))
                     NIL)
                  (SEQ (EXIT (COND
                               ((AND (CONSP |t|) (EQ (QCAR |t|) '|:|)
                                     (PROGN
                                       (SPADLET |ISTMP#1| (QCDR |t|))
                                       (AND (CONSP |ISTMP#1|)
                                        (PROGN
                                          (SPADLET |tag|
                                           (QCAR |ISTMP#1|))
                                          (SPADLET |ISTMP#2|
                                           (QCDR |ISTMP#1|))
                                          (AND (CONSP |ISTMP#2|)
                                           (EQ (QCDR |ISTMP#2|) NIL))))))
                                (SPADLET |tags| (CONS |tag| |tags|)))
                               ('T NIL)))))))
             |tags|)))))

;coerceUnion2Branch(object) ==
;  [.,:unionDoms] := objMode object
;  doms := orderUnionEntries unionDoms
;  predList:= mkPredList doms
;  doms := stripUnionTags doms
;  val' := objValUnwrap object
;  predicate := NIL
;  targetType:= NIL
;  for typ in doms for pred in predList while ^targetType repeat
;    evalSharpOne(pred,val') =>
;      predicate := pred
;      targetType := typ
;  null targetType => keyedSystemError("S2IC0013",NIL)
;  predicate is ['EQCAR,.,p] => objNewWrap(CDR val',targetType)
;  objNew(objVal object,targetType)

(defun |evalSharpOne| (x |#1|)
 (declare (special |#1|))
 (eval `(let() (declare (special |#1|)) ,x)))

(DEFUN |coerceUnion2Branch| (|object|)
  (PROG (|LETTMP#1| |unionDoms| |predList| |doms| |val'| |predicate|
            |targetType| |ISTMP#1| |ISTMP#2| |p|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |LETTMP#1| (|objMode| |object|))
             (SPADLET |unionDoms| (CDR |LETTMP#1|))
             (SPADLET |doms| (|orderUnionEntries| |unionDoms|))
             (SPADLET |predList| (|mkPredList| |doms|))
             (SPADLET |doms| (|stripUnionTags| |doms|))
             (SPADLET |val'| (|objValUnwrap| |object|))
             (SPADLET |predicate| NIL)
             (SPADLET |targetType| NIL)
             (SEQ (DO ((G167741 |doms| (CDR G167741)) (|typ| NIL)
                       (G167742 |predList| (CDR G167742))
                       (|pred| NIL))
                      ((OR (ATOM G167741)
                           (PROGN (SETQ |typ| (CAR G167741)) NIL)
                           (ATOM G167742)
                           (PROGN (SETQ |pred| (CAR G167742)) NIL)
                           (NULL (NULL |targetType|)))
                       NIL)
                    (SEQ (EXIT (COND
                                 ((|evalSharpOne| |pred| |val'|)
                                  (EXIT (PROGN
                                          (SPADLET |predicate| |pred|)
                                          (SPADLET |targetType| |typ|))))))))
                  (COND
                    ((NULL |targetType|)
                     (|keyedSystemError| 'S2IC0013 NIL))
                    ((AND (CONSP |predicate|)
                          (EQ (QCAR |predicate|) 'EQCAR)
                          (PROGN
                            (SPADLET |ISTMP#1| (QCDR |predicate|))
                            (AND (CONSP |ISTMP#1|)
                                 (PROGN
                                   (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                                   (AND (CONSP |ISTMP#2|)
                                    (EQ (QCDR |ISTMP#2|) NIL)
                                    (PROGN
                                      (SPADLET |p| (QCAR |ISTMP#2|))
                                      'T))))))
                     (|objNewWrap| (CDR |val'|) |targetType|))
                    ('T (|objNew| (|objVal| |object|) |targetType|)))))))))

;coerceBranch2Union(object,union) ==
;  -- assumes type is a member of unionDoms
;  unionDoms := CDR union
;  doms := orderUnionEntries unionDoms
;  predList:= mkPredList doms
;  doms := stripUnionTags doms
;  p := position(objMode object,doms)
;  p = -1 => keyedSystemError("S2IC0014",[objMode object,union])
;  val := objVal object
;  predList.p is ['EQCAR,.,tag] =>
;    objNewWrap([removeQuote tag,:unwrap val],union)
;  objNew(val,union)

(DEFUN |coerceBranch2Union| (|object| |union|)
  (PROG (|unionDoms| |predList| |doms| |p| |val| |ISTMP#1| |ISTMP#2|
            |ISTMP#3| |tag|)
    (RETURN
      (PROGN
        (SPADLET |unionDoms| (CDR |union|))
        (SPADLET |doms| (|orderUnionEntries| |unionDoms|))
        (SPADLET |predList| (|mkPredList| |doms|))
        (SPADLET |doms| (|stripUnionTags| |doms|))
        (SPADLET |p| (|position| (|objMode| |object|) |doms|))
        (COND
          ((BOOT-EQUAL |p| (SPADDIFFERENCE 1))
           (|keyedSystemError| 'S2IC0014
               (CONS (|objMode| |object|) (CONS |union| NIL))))
          ('T (SPADLET |val| (|objVal| |object|))
           (COND
             ((PROGN
                (SPADLET |ISTMP#1| (ELT |predList| |p|))
                (AND (CONSP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) 'EQCAR)
                     (PROGN
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (CONSP |ISTMP#2|)
                            (PROGN
                              (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                              (AND (CONSP |ISTMP#3|)
                                   (EQ (QCDR |ISTMP#3|) NIL)
                                   (PROGN
                                     (SPADLET |tag| (QCAR |ISTMP#3|))
                                     'T)))))))
              (|objNewWrap|
                  (CONS (|removeQuote| |tag|) (|unwrap| |val|))
                  |union|))
             ('T (|objNew| |val| |union|)))))))))

;coerceInt2Union(object,union) ==
;  -- coerces to a Union type, adding numeric tags
;  -- first cut
;  unionDoms := stripUnionTags CDR union
;  t1 := objMode object
;  MEMBER(t1,unionDoms) => coerceBranch2Union(object,union)
;  val := objVal object
;  val' := unwrap val
;  (t1 = $String) and MEMBER(val',unionDoms) =>
;    coerceBranch2Union(objNew(val,val'),union)
;  noCoerce := true
;  val' := nil
;  for d in unionDoms while noCoerce repeat
;    (val' := coerceInt(object,d)) => noCoerce := nil
;  val' => coerceBranch2Union(val',union)
;  NIL

(DEFUN |coerceInt2Union| (|object| |union|)
  (PROG (|unionDoms| |t1| |val| |val'| |noCoerce|)
    (DECLARE (SPECIAL |$String|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |unionDoms| (|stripUnionTags| (CDR |union|)))
             (SPADLET |t1| (|objMode| |object|))
             (COND
               ((|member| |t1| |unionDoms|)
                (|coerceBranch2Union| |object| |union|))
               ('T (SPADLET |val| (|objVal| |object|))
                (SPADLET |val'| (|unwrap| |val|))
                (COND
                  ((AND (BOOT-EQUAL |t1| |$String|)
                        (|member| |val'| |unionDoms|))
                   (|coerceBranch2Union| (|objNew| |val| |val'|)
                       |union|))
                  ('T (SPADLET |noCoerce| 'T) (SPADLET |val'| NIL)
                   (SEQ (DO ((G167805 |unionDoms| (CDR G167805))
                             (|d| NIL))
                            ((OR (ATOM G167805)
                                 (PROGN
                                   (SETQ |d| (CAR G167805))
                                   NIL)
                                 (NULL |noCoerce|))
                             NIL)
                          (SEQ (EXIT (COND
                                       ((SPADLET |val'|
                                         (|coerceInt| |object| |d|))
                                        (EXIT (SPADLET |noCoerce| NIL)))))))
                        (COND
                          (|val'| (EXIT (|coerceBranch2Union| |val'|
                                         |union|))))
                        NIL))))))))))

;coerceIntFromUnion(object,t2) ==
;  -- coerces from a Union type to something else
;  coerceInt(coerceUnion2Branch object,t2)

(DEFUN |coerceIntFromUnion| (|object| |t2|)
  (|coerceInt| (|coerceUnion2Branch| |object|) |t2|))

;coerceIntByMap(triple,t2) ==
;  -- idea is this: if t1 is D U1 and t2 is D U2, then look for
;  -- map: (U1 -> U2, D U1) -> D U2.  If it exists, then create a
;  -- function to do the coercion on the element level and call the
;  -- map function.
;  t1 := objMode triple
;  t2 = t1 => triple
;  u2 := deconstructT t2    -- compute t2 first because of Expression
;  1 = #u2 => NIL           -- no under domain
;  u1 := deconstructT t1
;  1 = #u1 => NIL
;  CAAR u1 ^= CAAR u2 => nil  -- constructors not equal
;  ^valueArgsEqual?(t1, t2) => NIL
;--  CAR u1 ^= CAR u2 => NIL
;  top := CAAR u1
;  u1 := underDomainOf t1
;  u2 := underDomainOf t2
;  -- handle a couple of special cases for subdomains of Integer
;  top in '(List Vector Segment Stream UniversalSegment Array)
;    and isSubDomain(u1,u2) => objNew(objVal triple, t2)
;  args := [['Mapping,u2,u1],t1]
;  if $reportBottomUpFlag then
;    sayFunctionSelection('map,args,t2,NIL,
;      '"coercion facility (map)")
;  mms := selectMms1('map,t2,args,args,NIL)
;  if $reportBottomUpFlag then
;    sayFunctionSelectionResult('map,args,mms)
;  null mms => NIL
;  [[dc,:sig],slot,.]:= CAR mms
;  fun := compiledLookup('map,sig,evalDomain(dc))
;  NULL fun => NIL
;  [fn,:d]:= fun
;  fn = function Undef => NIL
;  -- now compile a function to do the coercion
;  code := ['SPADCALL,['CONS,["function","coerceIntByMapInner"],MKQ [u1,:u2]],
;    wrapped2Quote objVal triple,MKQ fun]
;  -- and apply the function
;  val := CATCH('coerceFailure,timedEvaluate code)
;  (val = $coerceFailure) => NIL
;  objNewWrap(val,t2)

(DEFUN |coerceIntByMap| (|triple| |t2|)
  (PROG (|t1| |top| |u1| |u2| |args| |mms| |LETTMP#1| |dc| |sig| |slot|
              |fun| |fn| |d| |code| |val|)
    (DECLARE (SPECIAL |$coerceFailure| |$reportBottomUpFlag|))
    (RETURN
      (PROGN
        (SPADLET |t1| (|objMode| |triple|))
        (COND
          ((BOOT-EQUAL |t2| |t1|) |triple|)
          ('T (SPADLET |u2| (|deconstructT| |t2|))
           (COND
             ((EQL 1 (|#| |u2|)) NIL)
             ('T (SPADLET |u1| (|deconstructT| |t1|))
              (COND
                ((EQL 1 (|#| |u1|)) NIL)
                ((NEQUAL (CAAR |u1|) (CAAR |u2|)) NIL)
                ((NULL (|valueArgsEqual?| |t1| |t2|)) NIL)
                ('T (SPADLET |top| (CAAR |u1|))
                 (SPADLET |u1| (|underDomainOf| |t1|))
                 (SPADLET |u2| (|underDomainOf| |t2|))
                 (COND
                   ((AND (|member| |top|
                             '(|List| |Vector| |Segment| |Stream|
                                      |UniversalSegment| |Array|))
                         (|isSubDomain| |u1| |u2|))
                    (|objNew| (|objVal| |triple|) |t2|))
                   ('T
                    (SPADLET |args|
                             (CONS (CONS '|Mapping|
                                    (CONS |u2| (CONS |u1| NIL)))
                                   (CONS |t1| NIL)))
                    (COND
                      (|$reportBottomUpFlag|
                          (|sayFunctionSelection| '|map| |args| |t2|
                              NIL
                              "coercion facility (map)")))
                    (SPADLET |mms|
                             (|selectMms1| '|map| |t2| |args| |args|
                                 NIL))
                    (COND
                      (|$reportBottomUpFlag|
                          (|sayFunctionSelectionResult| '|map| |args|
                              |mms|)))
                    (COND
                      ((NULL |mms|) NIL)
                      ('T (SPADLET |LETTMP#1| (CAR |mms|))
                       (SPADLET |dc| (CAAR |LETTMP#1|))
                       (SPADLET |sig| (CDAR |LETTMP#1|))
                       (SPADLET |slot| (CADR |LETTMP#1|))
                       (SPADLET |fun|
                                (|compiledLookup| '|map| |sig|
                                    (|evalDomain| |dc|)))
                       (COND
                         ((NULL |fun|) NIL)
                         ('T (SPADLET |fn| (CAR |fun|))
                          (SPADLET |d| (CDR |fun|))
                          (COND
                            ((BOOT-EQUAL |fn| (|function| |Undef|))
                             NIL)
                            ('T
                             (SPADLET |code|
                                      (CONS 'SPADCALL
                                       (CONS
                                        (CONS 'CONS
                                         (CONS
                                          (CONS '|function|
                                           (CONS '|coerceIntByMapInner|
                                            NIL))
                                          (CONS (MKQ (CONS |u1| |u2|))
                                           NIL)))
                                        (CONS
                                         (|wrapped2Quote|
                                          (|objVal| |triple|))
                                         (CONS (MKQ |fun|) NIL)))))
                             (SPADLET |val|
                                      (CATCH '|coerceFailure|
                                        (|timedEvaluate| |code|)))
                             (COND
                               ((BOOT-EQUAL |val| |$coerceFailure|)
                                NIL)
                              ('T (|objNewWrap| |val| |t2|)))))))))))))))))))))

;coerceIntByMapInner(arg,[u1,:u2]) == coerceOrThrowFailure(arg,u1,u2)

(DEFUN |coerceIntByMapInner| (|arg| G167859)
  (PROG (|u1| |u2|)
    (RETURN
      (PROGN
        (SPADLET |u1| (CAR G167859))
        (SPADLET |u2| (CDR G167859))
        (|coerceOrThrowFailure| |arg| |u1| |u2|)))))

;-- [u1,:u2] gets passed as the "environment", which is why we have this
;-- slightly clumsy locution  JHD 31.July,1990
;valueArgsEqual?(t1, t2) ==
;  -- returns true if the object-valued arguments to t1 and t2 are the same
;  -- under coercion
;  coSig := CDR GETDATABASE(CAR t1, 'COSIG)
;  constrSig := CDR getConstructorSignature CAR t1
;  tl1 := replaceSharps(constrSig, t1)
;  tl2 := replaceSharps(constrSig, t2)
;  not MEMQ(NIL, coSig) => true
;  done := false
;  value := true
;  for a1 in CDR t1 for a2 in CDR t2 for cs in coSig
;    for m1 in tl1 for m2 in tl2 while not done repeat
;          ^cs =>
;            trip := objNewWrap(a1, m1)
;            newVal := coerceInt(trip, m2)
;            null newVal => (done := true; value := false)
;            ^algEqual(a2, objValUnwrap newVal, m2) =>
;              (done := true; value := false)
;  value

(DEFUN |valueArgsEqual?| (|t1| |t2|)
  (PROG (|coSig| |constrSig| |tl1| |tl2| |trip| |newVal| |done|
                 |value|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |coSig| (CDR (GETDATABASE (CAR |t1|) 'COSIG)))
             (SPADLET |constrSig|
                      (CDR (|getConstructorSignature| (CAR |t1|))))
             (SPADLET |tl1| (|replaceSharps| |constrSig| |t1|))
             (SPADLET |tl2| (|replaceSharps| |constrSig| |t2|))
             (COND
               ((NULL (member NIL |coSig|)) 'T)
               ('T (SPADLET |done| NIL) (SPADLET |value| 'T)
                (SEQ (DO ((G167888 (CDR |t1|) (CDR G167888))
                          (|a1| NIL)
                          (G167889 (CDR |t2|) (CDR G167889))
                          (|a2| NIL)
                          (G167890 |coSig| (CDR G167890))
                          (|cs| NIL) (G167891 |tl1| (CDR G167891))
                          (|m1| NIL) (G167892 |tl2| (CDR G167892))
                          (|m2| NIL))
                         ((OR (ATOM G167888)
                              (PROGN (SETQ |a1| (CAR G167888)) NIL)
                              (ATOM G167889)
                              (PROGN (SETQ |a2| (CAR G167889)) NIL)
                              (ATOM G167890)
                              (PROGN (SETQ |cs| (CAR G167890)) NIL)
                              (ATOM G167891)
                              (PROGN (SETQ |m1| (CAR G167891)) NIL)
                              (ATOM G167892)
                              (PROGN (SETQ |m2| (CAR G167892)) NIL)
                              (NULL (NULL |done|)))
                          NIL)
                       (SEQ (EXIT (COND
                                    ((NULL |cs|)
                                     (EXIT
                                      (PROGN
                                        (SPADLET |trip|
                                         (|objNewWrap| |a1| |m1|))
                                        (SPADLET |newVal|
                                         (|coerceInt| |trip| |m2|))
                                        (COND
                                          ((NULL |newVal|)
                                           (SPADLET |done| 'T)
                                           (SPADLET |value| NIL))
                                          ((NULL
                                            (|algEqual| |a2|
                                             (|objValUnwrap| |newVal|)
                                             |m2|))
                                           (SPADLET |done| 'T)
                                           (SPADLET |value| NIL))))))))))
                     (EXIT |value|)))))))))

;coerceIntTower(triple,t2) ==
;  -- tries to find a coercion from top level t2 to somewhere inside t1
;  -- builds new argument type, for which coercion is called recursively
;  x := coerceIntByMap(triple,t2) => x
;  x := coerceIntCommute(triple,t2) => x
;  x := coerceIntPermute(triple,t2) => x
;  x := coerceIntSpecial(triple,t2) => x
;  x := coerceIntTableOrFunction(triple,t2) => x
;  t1 := objMode triple
;  [c1,:arg1]:= deconstructT t1
;  arg1 and
;    TL:= NIL
;    arg:= arg1
;    until x or not arg repeat
;      t:= last arg
;      [c,:arg]:= deconstructT t
;      TL:= [c,arg,:TL]
;      x := arg and coerceIntTest(t,t2) =>
;        CDDR TL =>
;          s := constructT(c1,replaceLast(arg1,bubbleConstructor TL))
;          (null isValidType(s)) => (x := NIL)
;          x := (coerceIntByMap(triple,s) or
;            coerceIntTableOrFunction(triple,s)) =>
;              [c2,:arg2]:= deconstructT last s
;              s:= bubbleConstructor [c2,arg2,c1,arg1]
;              (null isValidType(s)) => (x := NIL)
;              x:= coerceIntCommute(x,s) =>
;                x := (coerceIntByMap(x,t2) or
;                  coerceIntTableOrFunction(x,t2))
;        s:= bubbleConstructor [c,arg,c1,arg1]
;        (null isValidType(s)) => (x := NIL)
;        x:= coerceIntCommute(triple,s) =>
;          x:= (coerceIntByMap(x,t2) or
;            coerceIntTableOrFunction(x,t2))
;    x

(DEFUN |coerceIntTower| (|triple| |t2|)
  (PROG (|t1| |c1| |arg1| |t| |c| |arg| TL |LETTMP#1| |c2| |arg2| |s|
              |x|)
    (RETURN
      (SEQ (COND
             ((SPADLET |x| (|coerceIntByMap| |triple| |t2|)) |x|)
             ((SPADLET |x| (|coerceIntCommute| |triple| |t2|)) |x|)
             ((SPADLET |x| (|coerceIntPermute| |triple| |t2|)) |x|)
             ((SPADLET |x| (|coerceIntSpecial| |triple| |t2|)) |x|)
             ((SPADLET |x| (|coerceIntTableOrFunction| |triple| |t2|))
              |x|)
             ('T (SPADLET |t1| (|objMode| |triple|))
              (SPADLET |LETTMP#1| (|deconstructT| |t1|))
              (SPADLET |c1| (CAR |LETTMP#1|))
              (SPADLET |arg1| (CDR |LETTMP#1|))
              (AND |arg1|
                   (PROGN
                     (SPADLET TL NIL)
                     (SPADLET |arg| |arg1|)
                     (DO ((G167962 NIL (OR |x| (NULL |arg|))))
                         (G167962 NIL)
                       (SEQ (EXIT (PROGN
                                    (SPADLET |t| (|last| |arg|))
                                    (SPADLET |LETTMP#1|
                                     (|deconstructT| |t|))
                                    (SPADLET |c| (CAR |LETTMP#1|))
                                    (SPADLET |arg| (CDR |LETTMP#1|))
                                    (SPADLET TL
                                     (CONS |c| (CONS |arg| TL)))
                                    (COND
                                      ((SPADLET |x|
                                        (AND |arg|
                                         (|coerceIntTest| |t| |t2|)))
                                       (COND
                                         ((CDDR TL)
                                          (SPADLET |s|
                                           (|constructT| |c1|
                                            (|replaceLast| |arg1|
                                             (|bubbleConstructor| TL))))
                                          (COND
                                            ((NULL (|isValidType| |s|))
                                             (SPADLET |x| NIL))
                                            ((SPADLET |x|
                                              (OR
                                               (|coerceIntByMap|
                                                |triple| |s|)
                                               (|coerceIntTableOrFunction|
                                                |triple| |s|)))
                                             (SPADLET |LETTMP#1|
                                              (|deconstructT|
                                               (|last| |s|)))
                                             (SPADLET |c2|
                                              (CAR |LETTMP#1|))
                                             (SPADLET |arg2|
                                              (CDR |LETTMP#1|))
                                             (SPADLET |s|
                                              (|bubbleConstructor|
                                               (CONS |c2|
                                                (CONS |arg2|
                                                 (CONS |c1|
                                                  (CONS |arg1| NIL))))))
                                             (COND
                                               ((NULL
                                                 (|isValidType| |s|))
                                                (SPADLET |x| NIL))
                                               ((SPADLET |x|
                                                 (|coerceIntCommute|
                                                  |x| |s|))
                                                (SPADLET |x|
                                                 (OR
                                                  (|coerceIntByMap| |x|
                                                   |t2|)
                                                  (|coerceIntTableOrFunction|
                                                   |x| |t2|))))))))
                                         ('T
                                          (SPADLET |s|
                                           (|bubbleConstructor|
                                            (CONS |c|
                                             (CONS |arg|
                                              (CONS |c1|
                                               (CONS |arg1| NIL))))))
                                          (COND
                                            ((NULL (|isValidType| |s|))
                                             (SPADLET |x| NIL))
                                            ((SPADLET |x|
                                              (|coerceIntCommute|
                                               |triple| |s|))
                                             (SPADLET |x|
                                              (OR
                                               (|coerceIntByMap| |x|
                                                |t2|)
                                               (|coerceIntTableOrFunction|
                                                |x| |t2|)))))))))))))
                     |x|))))))))

;coerceIntSpecial(triple,t2) ==
;  t1 := objMode triple
;  t2 is ['SimpleAlgebraicExtension,R,U,.] and t1 = R =>
;    null (x := coerceInt(triple,U)) => NIL
;    coerceInt(x,t2)
;  NIL

(DEFUN |coerceIntSpecial| (|triple| |t2|)
  (PROG (|t1| |ISTMP#1| R |ISTMP#2| U |ISTMP#3| |x|)
    (RETURN
      (PROGN
        (SPADLET |t1| (|objMode| |triple|))
        (COND
          ((AND (CONSP |t2|)
                (EQ (QCAR |t2|) '|SimpleAlgebraicExtension|)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |t2|))
                  (AND (CONSP |ISTMP#1|)
                       (PROGN
                         (SPADLET R (QCAR |ISTMP#1|))
                         (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (CONSP |ISTMP#2|)
                              (PROGN
                                (SPADLET U (QCAR |ISTMP#2|))
                                (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                                (AND (CONSP |ISTMP#3|)
                                     (EQ (QCDR |ISTMP#3|) NIL)))))))
                (BOOT-EQUAL |t1| R))
           (COND
             ((NULL (SPADLET |x| (|coerceInt| |triple| U))) NIL)
             ('T (|coerceInt| |x| |t2|))))
          ('T NIL))))))

;coerceIntTableOrFunction(triple,t2) ==
;  -- this function does the actual coercion to t2, but not to an
;  -- argument type of t2
;  null isValidType t2 => NIL  -- added 9-18-85 by RSS
;  null isLegitimateMode(t2,NIL,NIL) => NIL  -- added 6-28-87 by RSS
;  t1 := objMode triple
;  p:= ASSQ(CAR t1,$CoerceTable)
;  p and ASSQ(CAR t2,CDR p) is [.,:[tag,fun]] =>
;    val := objVal triple
;    fun='Identity => objNew(val,t2)
;    tag='total =>
;      coerceByTable(fun,val,t1,t2,'T) or coerceByFunction(triple,t2)
;    coerceByTable(fun,val,t1,t2,NIL) or coerceByFunction(triple,t2)
;  coerceByFunction(triple,t2)

(DEFUN |coerceIntTableOrFunction| (|triple| |t2|)
  (PROG (|t1| |p| |ISTMP#1| |ISTMP#2| |tag| |ISTMP#3| |fun| |val|)
    (DECLARE (SPECIAL |$CoerceTable|))
    (RETURN
      (COND
        ((NULL (|isValidType| |t2|)) NIL)
        ((NULL (|isLegitimateMode| |t2| NIL NIL)) NIL)
        ('T (SPADLET |t1| (|objMode| |triple|))
         (SPADLET |p| (ASSQ (CAR |t1|) |$CoerceTable|))
         (COND
           ((AND |p|
                 (PROGN
                   (SPADLET |ISTMP#1| (ASSQ (CAR |t2|) (CDR |p|)))
                   (AND (CONSP |ISTMP#1|)
                        (PROGN
                          (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                          (AND (CONSP |ISTMP#2|)
                               (PROGN
                                 (SPADLET |tag| (QCAR |ISTMP#2|))
                                 (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                                 (AND (CONSP |ISTMP#3|)
                                      (EQ (QCDR |ISTMP#3|) NIL)
                                      (PROGN
                                        (SPADLET |fun|
                                         (QCAR |ISTMP#3|))
                                        'T))))))))
            (SPADLET |val| (|objVal| |triple|))
            (COND
              ((BOOT-EQUAL |fun| '|Identity|) (|objNew| |val| |t2|))
              ((BOOT-EQUAL |tag| '|total|)
               (OR (|coerceByTable| |fun| |val| |t1| |t2| 'T)
                   (|coerceByFunction| |triple| |t2|)))
              ('T
               (OR (|coerceByTable| |fun| |val| |t1| |t2| NIL)
                   (|coerceByFunction| |triple| |t2|)))))
           ('T (|coerceByFunction| |triple| |t2|))))))))

;coerceCommuteTest(t1,t2) ==
;  null isLegitimateMode(t2,NIL,NIL) => NIL
;  -- sees whether t1 = D1 D2 R and t2 = D2 D1 S
;  null (u1 := underDomainOf t1) => NIL
;  null (u2 := underDomainOf t2) => NIL
;  -- must have underdomains (ie, R and S must be there)
;  null (v1 := underDomainOf u1) => NIL
;  null (v2 := underDomainOf u2) => NIL
;  -- now check that cross of constructors is correct
;  (CAR(deconstructT t1) = CAR(deconstructT u2)) and
;    (CAR(deconstructT t2) = CAR(deconstructT u1))

(DEFUN |coerceCommuteTest| (|t1| |t2|)
  (PROG (|u1| |u2| |v1| |v2|)
    (RETURN
      (COND
        ((NULL (|isLegitimateMode| |t2| NIL NIL)) NIL)
        ((NULL (SPADLET |u1| (|underDomainOf| |t1|))) NIL)
        ((NULL (SPADLET |u2| (|underDomainOf| |t2|))) NIL)
        ((NULL (SPADLET |v1| (|underDomainOf| |u1|))) NIL)
        ((NULL (SPADLET |v2| (|underDomainOf| |u2|))) NIL)
        ('T
         (AND (BOOT-EQUAL (CAR (|deconstructT| |t1|))
                  (CAR (|deconstructT| |u2|)))
              (BOOT-EQUAL (CAR (|deconstructT| |t2|))
                  (CAR (|deconstructT| |u1|)))))))))

;coerceIntCommute(obj,target) ==
;  -- note that the value in obj may be $fromCoerceable$, for canCoerce
;  source := objMode obj
;  null coerceCommuteTest(source,target) => NIL
;  S := underDomainOf source
;  T := underDomainOf target
;  source = T => NIL      -- handle in other ways
;  source is [D,:.] =>
;    fun := GET(D,'coerceCommute) or
;           INTERN STRCONC('"commute",STRINGIMAGE D)
;    functionp fun =>
;      PUT(D,'coerceCommute,fun)
;      u := objValUnwrap obj
;      c := CATCH('coerceFailure,FUNCALL(fun,u,source,S,target,T))
;      (c = $coerceFailure) => NIL
;      u = "$fromCoerceable$" => c
;      objNewWrap(c,target)
;    NIL
;  NIL

(DEFUN |coerceIntCommute| (|obj| |target|)
  (PROG (|source| S T$ D |fun| |u| |c|)
    (DECLARE (SPECIAL |$coerceFailure|))
    (RETURN
      (PROGN
        (SPADLET |source| (|objMode| |obj|))
        (COND
          ((NULL (|coerceCommuteTest| |source| |target|)) NIL)
          ('T (SPADLET S (|underDomainOf| |source|))
           (SPADLET T$ (|underDomainOf| |target|))
           (COND
             ((BOOT-EQUAL |source| T$) NIL)
             ((AND (CONSP |source|)
                   (PROGN (SPADLET D (QCAR |source|)) 'T))
              (SPADLET |fun|
                       (OR (GETL D '|coerceCommute|)
                           (INTERN (STRCONC "commute"
                                    (STRINGIMAGE D)))))
              (COND
                ((|functionp| |fun|) (PUT D '|coerceCommute| |fun|)
                 (SPADLET |u| (|objValUnwrap| |obj|))
                 (SPADLET |c|
                          (CATCH '|coerceFailure|
                            (FUNCALL |fun| |u| |source| S |target| T$)))
                 (COND
                   ((BOOT-EQUAL |c| |$coerceFailure|) NIL)
                   ((BOOT-EQUAL |u| '|$fromCoerceable$|) |c|)
                   ('T (|objNewWrap| |c| |target|))))
                ('T NIL)))
             ('T NIL))))))))

;coerceIntPermute(object,t2) ==
;  t2 in '((Integer) (OutputForm)) => NIL
;  t1 := objMode object
;  towers := computeTTTranspositions(t1,t2)
;  -- at this point, CAR towers = t1 and last towers should be similar
;  -- to t2 in the sense that the components of t1 are in the same order
;  -- as in t2. If length towers = 2 and t2 = last towers, we quit to
;  -- avoid an infinte loop.
;  NULL towers or NULL CDR towers => NIL
;  NULL CDDR towers and t2 = CADR towers => NIL
;  -- do the coercions successively, quitting if any fail
;  ok := true
;  for t in CDR towers while ok repeat
;    null (object := coerceInt(object,t)) => ok := NIL
;  ok => object
;  NIL

(DEFUN |coerceIntPermute| (|object| |t2|)
  (PROG (|t1| |towers| |ok|)
    (RETURN
      (SEQ (COND
             ((|member| |t2| '((|Integer|) (|OutputForm|))) NIL)
             ('T (SPADLET |t1| (|objMode| |object|))
              (SPADLET |towers| (|computeTTTranspositions| |t1| |t2|))
              (COND
                ((OR (NULL |towers|) (NULL (CDR |towers|))) NIL)
                ((AND (NULL (CDDR |towers|))
                      (BOOT-EQUAL |t2| (CADR |towers|)))
                 NIL)
                ('T (SPADLET |ok| 'T)
                 (SEQ (DO ((G168100 (CDR |towers|) (CDR G168100))
                           (|t| NIL))
                          ((OR (ATOM G168100)
                               (PROGN (SETQ |t| (CAR G168100)) NIL)
                               (NULL |ok|))
                           NIL)
                        (SEQ (EXIT (COND
                                     ((NULL
                                       (SPADLET |object|
                                        (|coerceInt| |object| |t|)))
                                      (EXIT (SPADLET |ok| NIL)))))))
                      (COND (|ok| (EXIT |object|))) NIL)))))))))

;computeTTTranspositions(t1,t2) ==
;  -- decompose t1 into its tower parts
;  tl1 := decomposeTypeIntoTower t1
;  tl2 := decomposeTypeIntoTower t2
;  -- if not at least 2 parts, don't bother working here
;  null (rest tl1 and rest tl2) => NIL
;  -- determine the relative order of the parts of t1 in t2
;  p2 := [position(d1,tl2) for d1 in tl1]
;  member(-1,p2) => NIL            -- something not present
;  -- if they are all ascending, this function will do nothing
;  p2' := MSORT p2
;  p2 = p2' => NIL
;  -- if anything is repeated twice, leave
;  p2' ^= MSORT REMDUP p2' => NIL
;  -- create a list of permutations that transform the tower parts
;  -- of t1 into the order they are in in t2
;  n1 := #tl1
;  p2 := LIST2VEC compress(p2,0,# REMDUP tl1) where
;    compress(l,start,len) ==
;      start >= len => l
;      member(start,l) => compress(l,start+1,len)
;      compress([(i < start => i; i - 1) for i in l],start,len)
;  -- p2 now has the same position numbers as p1, we need to determine
;  -- a list of permutations that takes p1 into p2.
;  -- them
;  perms := permuteToOrder(p2,n1-1,0)
;  towers := [tl1]
;  tower := LIST2VEC tl1
;  for perm in perms repeat
;    t := tower.(CAR perm)
;    tower.(CAR perm) := tower.(CDR perm)
;    tower.(CDR perm) := t
;    towers := CONS(VEC2LIST tower,towers)
;  towers := [reassembleTowerIntoType tower for tower in towers]
;  if CAR(towers) ^= t2 then towers := cons(t2,towers)
;  NREVERSE towers

(DEFUN |computeTTTranspositions,compress| (|l| |start| |len|)
  (PROG ()
    (RETURN
      (SEQ (IF (>= |start| |len|) (EXIT |l|))
           (IF (|member| |start| |l|)
               (EXIT (|computeTTTranspositions,compress| |l|
                         (PLUS |start| 1) |len|)))
           (EXIT (|computeTTTranspositions,compress|
                     (PROG (G168121)
                       (SPADLET G168121 NIL)
                       (RETURN
                         (DO ((G168126 |l| (CDR G168126))
                              (|i| NIL))
                             ((OR (ATOM G168126)
                                  (PROGN
                                    (SETQ |i| (CAR G168126))
                                    NIL))
                              (NREVERSE0 G168121))
                           (SEQ (EXIT (SETQ G168121
                                       (CONS
                                        (SEQ
                                         (IF (> |start| |i|)
                                          (EXIT |i|))
                                         (EXIT (SPADDIFFERENCE |i| 1)))
                                        G168121)))))))
                     |start| |len|))))))

(DEFUN |computeTTTranspositions| (|t1| |t2|)
  (PROG (|tl1| |tl2| |p2'| |n1| |p2| |perms| |tower| |t| |towers|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |tl1| (|decomposeTypeIntoTower| |t1|))
             (SPADLET |tl2| (|decomposeTypeIntoTower| |t2|))
             (COND
               ((NULL (AND (CDR |tl1|) (CDR |tl2|))) NIL)
               ('T
                (SPADLET |p2|
                         (PROG (G168143)
                           (SPADLET G168143 NIL)
                           (RETURN
                             (DO ((G168148 |tl1| (CDR G168148))
                                  (|d1| NIL))
                                 ((OR (ATOM G168148)
                                      (PROGN
                                        (SETQ |d1| (CAR G168148))
                                        NIL))
                                  (NREVERSE0 G168143))
                               (SEQ (EXIT
                                     (SETQ G168143
                                      (CONS (|position| |d1| |tl2|)
                                       G168143))))))))
                (COND
                  ((|member| (SPADDIFFERENCE 1) |p2|) NIL)
                  ('T (SPADLET |p2'| (MSORT |p2|))
                   (COND
                     ((BOOT-EQUAL |p2| |p2'|) NIL)
                     ((NEQUAL |p2'| (MSORT (REMDUP |p2'|))) NIL)
                     ('T (SPADLET |n1| (|#| |tl1|))
                      (SPADLET |p2|
                               (LIST2VEC
                                   (|computeTTTranspositions,compress|
                                    |p2| 0 (|#| (REMDUP |tl1|)))))
                      (SPADLET |perms|
                               (|permuteToOrder| |p2|
                                   (SPADDIFFERENCE |n1| 1) 0))
                      (SPADLET |towers| (CONS |tl1| NIL))
                      (SPADLET |tower| (LIST2VEC |tl1|))
                      (DO ((G168161 |perms| (CDR G168161))
                           (|perm| NIL))
                          ((OR (ATOM G168161)
                               (PROGN
                                 (SETQ |perm| (CAR G168161))
                                 NIL))
                           NIL)
                        (SEQ (EXIT (PROGN
                                     (SPADLET |t|
                                      (ELT |tower| (CAR |perm|)))
                                     (SETELT |tower| (CAR |perm|)
                                      (ELT |tower| (CDR |perm|)))
                                     (SETELT |tower| (CDR |perm|) |t|)
                                     (SPADLET |towers|
                                      (CONS (VEC2LIST |tower|)
                                       |towers|))))))
                      (SPADLET |towers|
                               (PROG (G168171)
                                 (SPADLET G168171 NIL)
                                 (RETURN
                                   (DO
                                    ((G168176 |towers|
                                      (CDR G168176))
                                     (|tower| NIL))
                                    ((OR (ATOM G168176)
                                      (PROGN
                                        (SETQ |tower| (CAR G168176))
                                        NIL))
                                     (NREVERSE0 G168171))
                                     (SEQ
                                      (EXIT
                                       (SETQ G168171
                                        (CONS
                                         (|reassembleTowerIntoType|
                                          |tower|)
                                         G168171))))))))
                      (COND
                        ((NEQUAL (CAR |towers|) |t2|)
                         (SPADLET |towers| (CONS |t2| |towers|))))
                      (NREVERSE |towers|))))))))))))

;decomposeTypeIntoTower t ==
;  ATOM t => [t]
;  d := deconstructT t
;  NULL rest d => [t]
;  rd := REVERSE t
;  [reverse QCDR rd,:decomposeTypeIntoTower QCAR rd]

(DEFUN |decomposeTypeIntoTower| (|t|)
  (PROG (|d| |rd|)
    (RETURN
      (COND
        ((ATOM |t|) (CONS |t| NIL))
        ('T (SPADLET |d| (|deconstructT| |t|))
         (COND
           ((NULL (CDR |d|)) (CONS |t| NIL))
           ('T (SPADLET |rd| (REVERSE |t|))
            (CONS (REVERSE (QCDR |rd|))
                  (|decomposeTypeIntoTower| (QCAR |rd|))))))))))

;reassembleTowerIntoType tower ==
;  ATOM tower => tower
;  NULL rest tower => CAR tower
;  [:top,t,s] := tower
;  reassembleTowerIntoType [:top,[:t,s]]

(DEFUN |reassembleTowerIntoType| (|tower|)
  (PROG (|LETTMP#1| |s| |t| |top|)
    (RETURN
      (COND
        ((ATOM |tower|) |tower|)
        ((NULL (CDR |tower|)) (CAR |tower|))
        ('T (SPADLET |LETTMP#1| (REVERSE |tower|))
         (SPADLET |s| (CAR |LETTMP#1|)) (SPADLET |t| (CADR |LETTMP#1|))
         (SPADLET |top| (NREVERSE (CDDR |LETTMP#1|)))
         (|reassembleTowerIntoType|
             (APPEND |top| (CONS (APPEND |t| (CONS |s| NIL)) NIL))))))))

;permuteToOrder(p,n,start) ==
;  -- p is a vector of the numbers 0..n. This function returns a list
;  -- of swaps of adjacent elements so that p will be in order. We only
;  -- begin looking at index start
;  r := n - start
;  r <= 0 => NIL
;  r = 1 =>
;    p.r < p.(r+1) => NIL
;    [[r,:(r+1)]]
;  p.start = start => permuteToOrder(p,n,start+1)
;  -- bubble up element start to the top. Find out where it is
;  stpos := NIL
;  for i in start+1..n while not stpos repeat
;    if p.i = start then stpos := i
;  perms := NIL
;  while stpos ^= start repeat
;    x := stpos - 1
;    perms := [[x,:stpos],:perms]
;    t := p.stpos
;    p.stpos := p.x
;    p.x := t
;    stpos := x
;  APPEND(NREVERSE perms,permuteToOrder(p,n,start+1))

(DEFUN |permuteToOrder| (|p| |n| |start|)
  (PROG (|r| |x| |perms| |t| |stpos|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |r| (SPADDIFFERENCE |n| |start|))
             (COND
               ((<= |r| 0) NIL)
               ((EQL |r| 1)
                (COND
                  ((> (ELT |p| (PLUS |r| 1)) (ELT |p| |r|)) NIL)
                  ('T (CONS (CONS |r| (PLUS |r| 1)) NIL))))
               ((BOOT-EQUAL (ELT |p| |start|) |start|)
                (|permuteToOrder| |p| |n| (PLUS |start| 1)))
               ('T (SPADLET |stpos| NIL)
                (DO ((|i| (PLUS |start| 1) (+ |i| 1)))
                    ((OR (> |i| |n|) (NULL (NULL |stpos|))) NIL)
                  (SEQ (EXIT (COND
                               ((BOOT-EQUAL (ELT |p| |i|) |start|)
                                (SPADLET |stpos| |i|))
                               ('T NIL)))))
                (SPADLET |perms| NIL)
                (DO () ((NULL (NEQUAL |stpos| |start|)) NIL)
                  (SEQ (EXIT (PROGN
                               (SPADLET |x| (SPADDIFFERENCE |stpos| 1))
                               (SPADLET |perms|
                                        (CONS (CONS |x| |stpos|)
                                         |perms|))
                               (SPADLET |t| (ELT |p| |stpos|))
                               (SETELT |p| |stpos| (ELT |p| |x|))
                               (SETELT |p| |x| |t|)
                               (SPADLET |stpos| |x|)))))
                (APPEND (NREVERSE |perms|)
                        (|permuteToOrder| |p| |n| (PLUS |start| 1))))))))))

;coerceIntTest(t1,t2) ==
;  -- looks whether there exists a table entry or a coercion function
;  -- thus the type can be bubbled before coerceIntTableOrFunction is called
;  t1=t2 or
;    b:=
;      p:= ASSQ(CAR t1,$CoerceTable)
;      p and ASSQ(CAR t2,CDR p)
;    b or coerceConvertMmSelection('coerce,t1,t2) or
;      ($useConvertForCoercions and
;        coerceConvertMmSelection('convert,t1,t2))

(DEFUN |coerceIntTest| (|t1| |t2|)
  (PROG (|p| |b|)
    (DECLARE (SPECIAL |$useConvertForCoercions| |$CoerceTable|))
    (RETURN
      (OR (BOOT-EQUAL |t1| |t2|)
          (PROGN
            (SPADLET |b|
                     (PROGN
                       (SPADLET |p| (ASSQ (CAR |t1|) |$CoerceTable|))
                       (AND |p| (ASSQ (CAR |t2|) (CDR |p|)))))
            (OR |b| (|coerceConvertMmSelection| '|coerce| |t1| |t2|)
                (AND |$useConvertForCoercions|
                     (|coerceConvertMmSelection| '|convert| |t1| |t2|))))))))

;coerceByTable(fn,x,t1,t2,isTotalCoerce) ==
;  -- catch point for 'failure in boot coercions
;  t2 = $OutputForm and ^(newType? t1) => NIL
;  isWrapped x =>
;    x:= unwrap x
;    c:= CATCH('coerceFailure,FUNCALL(fn,x,t1,t2))
;    c=$coerceFailure => NIL
;    objNewWrap(c,t2)
;  isTotalCoerce => objNew([fn,x,MKQ t1,MKQ t2],t2)
;  objNew(['catchCoerceFailure,MKQ fn,x,MKQ t1,MKQ t2],t2)

(DEFUN |coerceByTable| (|fn| |x| |t1| |t2| |isTotalCoerce|)
  (PROG (|c|)
    (DECLARE (SPECIAL |$coerceFailure| |$OutputForm|))
    (RETURN
      (COND
        ((equal |t2| |$OutputForm|)
         NIL)
        ((|isWrapped| |x|) (SPADLET |x| (|unwrap| |x|))
         (SPADLET |c|
                  (CATCH '|coerceFailure|
                    (FUNCALL |fn| |x| |t1| |t2|)))
         (COND
           ((BOOT-EQUAL |c| |$coerceFailure|) NIL)
           ('T (|objNewWrap| |c| |t2|))))
        (|isTotalCoerce|
            (|objNew|
                (CONS |fn|
                      (CONS |x|
                            (CONS (MKQ |t1|) (CONS (MKQ |t2|) NIL))))
                |t2|))
        ('T
         (|objNew|
             (CONS '|catchCoerceFailure|
                   (CONS (MKQ |fn|)
                         (CONS |x|
                               (CONS (MKQ |t1|) (CONS (MKQ |t2|) NIL)))))
             |t2|))))))

;catchCoerceFailure(fn,x,t1,t2) ==
;  -- compiles a catchpoint for compiling boot coercions
;  c:= CATCH('coerceFailure,FUNCALL(fn,x,t1,t2))
;  c = $coerceFailure =>
;    throwKeyedMsgCannotCoerceWithValue(wrap unwrap x,t1,t2)
;  c

(DEFUN |catchCoerceFailure| (|fn| |x| |t1| |t2|)
  (PROG (|c|)
    (DECLARE (SPECIAL |$coerceFailure|))
    (RETURN
      (PROGN
        (SPADLET |c|
                 (CATCH '|coerceFailure| (FUNCALL |fn| |x| |t1| |t2|)))
        (COND
          ((BOOT-EQUAL |c| |$coerceFailure|)
           (|throwKeyedMsgCannotCoerceWithValue|
               (|wrap| (|unwrap| |x|)) |t1| |t2|))
          ('T |c|))))))

;coercionFailure() ==
;  -- does the throw on coercion failure
;  THROW('coerceFailure,$coerceFailure)

(DEFUN |coercionFailure| ()
  (DECLARE (SPECIAL |$coerceFailure|))
  (THROW '|coerceFailure| |$coerceFailure|))

;coerceByFunction(T,m2) ==
;  -- using the new modemap selection without coercions
;  -- should not be called by canCoerceFrom
;  x := objVal T
;  x = '_$fromCoerceable_$ => NIL
;  m2 is ['Union,:.] => NIL
;  m1 := objMode T
;  m2 is ['Boolean,:.] and m1 is ['Equation,ud] =>
;    dcVector := evalDomain ud
;    fun :=
;      isWrapped x =>
;        NRTcompiledLookup("=", [$Boolean, '$, '$], dcVector)
;      NRTcompileEvalForm("=", [$Boolean, '$, '$], dcVector)
;    [fn,:d]:= fun
;    isWrapped x =>
;      x:= unwrap x
;      mkObjWrap(SPADCALL(CAR x,CDR x,fun),m2)
;    x isnt ['SPADCALL,a,b,:.] => keyedSystemError("S2IC0015",NIL)
;    code := ['SPADCALL, a, b, fun]
;    objNew(code,$Boolean)
;  -- If more than one function is found, any should suffice, I think -scm
;  if not (mm := coerceConvertMmSelection(funName := 'coerce,m1,m2)) then
;    mm := coerceConvertMmSelection(funName := 'convert,m1,m2)
;  mm =>
;    [[dc,tar,:args],slot,.]:= mm
;    dcVector := evalDomain(dc)
;    fun:=
;      isWrapped x =>
;        NRTcompiledLookup(funName,slot,dcVector)
;      NRTcompileEvalForm(funName,slot,dcVector)
;    [fn,:d]:= fun
;    fn = function Undef => NIL
;    isWrapped x =>
;      $: fluid := dcVector
;      val := CATCH('coerceFailure, SPADCALL(unwrap x,fun))
;      (val = $coerceFailure) => NIL
;      objNewWrap(val,m2)
;    env := fun
;    code := ['failCheck, ['SPADCALL, x, env]]
;--  tar is ['Union,:.] => objNew(['failCheck,code],m2)
;    objNew(code,m2)
;  -- try going back to types like RN instead of QF I
;  m1' := eqType m1
;  m2' := eqType m2
;  (m1 ^= m1') or (m2 ^= m2') => coerceByFunction(objNew(x,m1'),m2')
;  NIL

(DEFUN |coerceByFunction| (T$ |m2|)
  (PROG ($ |m1| |ud| |x| |ISTMP#1| |a| |ISTMP#2| |b| |funName| |mm|
           |dc| |tar| |args| |slot| |dcVector| |fun| |fn| |d| |val|
           |env| |code| |m1'| |m2'|)
    (DECLARE (SPECIAL $ |$coerceFailure| |$Boolean|))
    (RETURN
      (PROGN
        (SPADLET |x| (|objVal| T$))
        (COND
          ((BOOT-EQUAL |x| '|$fromCoerceable$|) NIL)
          ((AND (CONSP |m2|) (EQ (QCAR |m2|) '|Union|)) NIL)
          ('T (SPADLET |m1| (|objMode| T$))
           (COND
             ((AND (CONSP |m2|) (EQ (QCAR |m2|) '|Boolean|)
                   (CONSP |m1|) (EQ (QCAR |m1|) '|Equation|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |m1|))
                     (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (SPADLET |ud| (QCAR |ISTMP#1|)) 'T))))
              (SPADLET |dcVector| (|evalDomain| |ud|))
              (SPADLET |fun|
                       (COND
                         ((|isWrapped| |x|)
                          (|NRTcompiledLookup| '=
                              (CONS |$Boolean| (CONS '$ (CONS '$ NIL)))
                              |dcVector|))
                         ('T
                          (|NRTcompileEvalForm| '=
                              (CONS |$Boolean| (CONS '$ (CONS '$ NIL)))
                              |dcVector|))))
              (SPADLET |fn| (CAR |fun|)) (SPADLET |d| (CDR |fun|))
              (COND
                ((|isWrapped| |x|) (SPADLET |x| (|unwrap| |x|))
                 (|mkObjWrap| (SPADCALL (CAR |x|) (CDR |x|) |fun|)
                     |m2|))
                ((NULL (AND (CONSP |x|) (EQ (QCAR |x|) 'SPADCALL)
                            (PROGN
                              (SPADLET |ISTMP#1| (QCDR |x|))
                              (AND (CONSP |ISTMP#1|)
                                   (PROGN
                                     (SPADLET |a| (QCAR |ISTMP#1|))
                                     (SPADLET |ISTMP#2|
                                      (QCDR |ISTMP#1|))
                                     (AND (CONSP |ISTMP#2|)
                                      (PROGN
                                        (SPADLET |b| (QCAR |ISTMP#2|))
                                        'T)))))))
                 (|keyedSystemError| 'S2IC0015 NIL))
                ('T
                 (SPADLET |code|
                          (CONS 'SPADCALL
                                (CONS |a| (CONS |b| (CONS |fun| NIL)))))
                 (|objNew| |code| |$Boolean|))))
             ('T
              (COND
                ((NULL (SPADLET |mm|
                                (|coerceConvertMmSelection|
                                    (SPADLET |funName| '|coerce|) |m1|
                                    |m2|)))
                 (SPADLET |mm|
                          (|coerceConvertMmSelection|
                              (SPADLET |funName| '|convert|) |m1| |m2|))))
              (COND
                (|mm| (SPADLET |dc| (CAAR |mm|))
                      (SPADLET |tar| (CADAR |mm|))
                      (SPADLET |args| (CDDAR |mm|))
                      (SPADLET |slot| (CADR |mm|))
                      (SPADLET |dcVector| (|evalDomain| |dc|))
                      (SPADLET |fun|
                               (COND
                                 ((|isWrapped| |x|)
                                  (|NRTcompiledLookup| |funName| |slot|
                                      |dcVector|))
                                 ('T
                                  (|NRTcompileEvalForm| |funName|
                                      |slot| |dcVector|))))
                      (SPADLET |fn| (CAR |fun|))
                      (SPADLET |d| (CDR |fun|))
                      (COND
                        ((BOOT-EQUAL |fn| (|function| |Undef|)) NIL)
                        ((|isWrapped| |x|) (SPADLET $ |dcVector|)
                         (SPADLET |val|
                                  (CATCH '|coerceFailure|
                                    (SPADCALL (|unwrap| |x|) |fun|)))
                         (COND
                           ((BOOT-EQUAL |val| |$coerceFailure|) NIL)
                           ('T (|objNewWrap| |val| |m2|))))
                        ('T (SPADLET |env| |fun|)
                         (SPADLET |code|
                                  (CONS '|failCheck|
                                        (CONS
                                         (CONS 'SPADCALL
                                          (CONS |x| (CONS |env| NIL)))
                                         NIL)))
                         (|objNew| |code| |m2|))))
                ('T (SPADLET |m1'| (|eqType| |m1|))
                 (SPADLET |m2'| (|eqType| |m2|))
                 (COND
                   ((OR (NEQUAL |m1| |m1'|) (NEQUAL |m2| |m2'|))
                    (|coerceByFunction| (|objNew| |x| |m1'|) |m2'|))
                   ('T NIL))))))))))))

;hasCorrectTarget(m,sig is [dc,tar,:.]) ==
;  -- tests whether the target of signature sig is either m or a union
;  -- containing m. It also discards TEQ as it is not meant to be
;  -- used at top-level
;  dc is ['TypeEquivalence,:.] => NIL
;  m=tar => 'T
;  tar is ['Union,t,'failed] => t=m
;  tar is ['Union,'failed,t] and t=m

(DEFUN |hasCorrectTarget| (|m| |sig|)
  (PROG (|dc| |tar| |ISTMP#1| |ISTMP#2| |t|)
    (RETURN
      (PROGN
        (SPADLET |dc| (CAR |sig|))
        (SPADLET |tar| (CADR |sig|))
        (COND
          ((AND (CONSP |dc|) (EQ (QCAR |dc|) '|TypeEquivalence|)) NIL)
          ((BOOT-EQUAL |m| |tar|) 'T)
          ((AND (CONSP |tar|) (EQ (QCAR |tar|) '|Union|)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |tar|))
                  (AND (CONSP |ISTMP#1|)
                       (PROGN
                         (SPADLET |t| (QCAR |ISTMP#1|))
                         (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (CONSP |ISTMP#2|)
                              (EQ (QCDR |ISTMP#2|) NIL)
                              (EQ (QCAR |ISTMP#2|) '|failed|))))))
           (BOOT-EQUAL |t| |m|))
          ('T
           (AND (CONSP |tar|) (EQ (QCAR |tar|) '|Union|)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |tar|))
                  (AND (CONSP |ISTMP#1|)
                       (EQ (QCAR |ISTMP#1|) '|failed|)
                       (PROGN
                         (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (CONSP |ISTMP#2|)
                              (EQ (QCDR |ISTMP#2|) NIL)
                              (PROGN
                                (SPADLET |t| (QCAR |ISTMP#2|))
                                'T)))))
                (BOOT-EQUAL |t| |m|))))))))


\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
