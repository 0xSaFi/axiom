\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp i-coerce.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{Coercion conventions}
\begin{verbatim}
Coercion conventions

Coercion involves the  changing of the datatype of an  object.  This
   can be  done for conformality of  operations or, for  example, to
   change the structure of an object  into one that is understood by
   the printing routines.

The actual coercion  is controlled  by the  function "coerce"  which
   takes  and delivers  wrapped operands.   Also  see the  functions
   interpCoerce and coerceInteractive.

Sometimes one  does not  want to  actually change  the datatype  but
   rather wants to determine  whether it is possible to do  so.  The
   controlling function  to do this  is "canCoerceFrom".   The value
   passed   to  specific   coercion  routines   in   this  case   is
   "$fromCoerceable$".   The value returned is  true or false.   See
   specific examples for more info.

The special routines that  do the coercions typically  involve a "2"
   in their  names.   For example, G2E  converts type  "Gaussian" to
   type  "Expression".   These  special  routines take  and  deliver
   unwrapped operands.   The determination of which  special routine
   to  use  is  often  made  by  consulting  the  list  $CoerceTable
   (currently in COT BOOT) and  this is controlled by coerceByTable.
   Note that the special routines are in the file COERCEFN BOOT.
\end{verbatim}
\begin{chunk}{*}
(IN-PACKAGE "BOOT" )

;--%  Functions for Coercion or Else We'll Get Rough
;coerceOrFail(triple,t,mapName) ==
;  -- some code generated for this is in coerceInt0
;  t = $NoValueMode => triple
;  t' := coerceInteractive(triple,t)
;  t' => objValUnwrap(t')
;  sayKeyedMsg("S2IC0004",[mapName,objMode triple,t])
;  '"failed"

(DEFUN |coerceOrFail| (|triple| |t| |mapName|)
  (PROG (|t'|)
    (DECLARE (SPECIAL |$NoValueMode|))
    (RETURN
      (COND
        ((BOOT-EQUAL |t| |$NoValueMode|) |triple|)
        ('T (setq |t'| (|coerceInteractive| |triple| |t|))
         (COND
           (|t'| (|objValUnwrap| |t'|))
           ('T
            (|sayKeyedMsg|
           "Conversion failed in the compiled user function %1 from %2p to %3p"
                (CONS |mapName|
                      (CONS (|objMode| |triple|) (CONS |t| NIL))))
            "failed")))))))

;coerceOrCroak(triple, t, mapName) ==
;  -- this does the coercion and returns the value or dies
;  t = $NoValueMode => triple
;  t' := coerceOrConvertOrRetract(triple,t)
;  t' => objValUnwrap(t')
;  mapName = 'noMapName =>
;    throwKeyedMsgCannotCoerceWithValue(objVal triple,objMode triple, t)
;  sayKeyedMsg("S2IC0005",[mapName])
;  throwKeyedMsgCannotCoerceWithValue(objVal triple,objMode triple, t)

(DEFUN |coerceOrCroak| (|triple| |t| |mapName|)
  (PROG (|t'|)
    (DECLARE (SPECIAL |$NoValueMode|))
    (RETURN
      (COND
        ((BOOT-EQUAL |t| |$NoValueMode|) |triple|)
        ('T (setq |t'| (|coerceOrConvertOrRetract| |triple| |t|))
         (COND
           (|t'| (|objValUnwrap| |t'|))
           ((BOOT-EQUAL |mapName| '|noMapName|)
            (|throwKeyedMsgCannotCoerceWithValue| (|objVal| |triple|)
                (|objMode| |triple|) |t|))
           ('T (|sayKeyedMsg|
                "Conversion failed in the compiled user function %1 ."
                (CONS |mapName| NIL))
            (|throwKeyedMsgCannotCoerceWithValue| (|objVal| |triple|)
                (|objMode| |triple|) |t|))))))))

;--%  Retraction functions

;coerceOrConvertOrRetract(T,m) ==
;  $useConvertForCoercions : local := true
;  coerceOrRetract(T,m)

(DEFUN |coerceOrConvertOrRetract| (T$ |m|)
  (PROG (|$useConvertForCoercions|)
    (DECLARE (SPECIAL |$useConvertForCoercions|))
    (RETURN
      (PROGN
        (setq |$useConvertForCoercions| 'T)
        (|coerceOrRetract| T$ |m|)))))

;--% Coercion utilities
;-- The next function extracts the structural definition of constants
;-- from a given domain. For example, getConstantFromDomain('(One),S)
;-- returns the representation of 1 in the domain S.
;constantInDomain?(form,domainForm) ==
;    opAlist := getOperationAlistFromLisplib first domainForm
;    key := opOf form
;    entryList := LASSOC(key,opAlist)
;    entryList is [[., ., ., type]] and type in '(CONST ASCONST) => true
;    key = "One" => constantInDomain?(["1"], domainForm)
;    key = "Zero" => constantInDomain?(["0"], domainForm)
;    false

(DEFUN |constantInDomain?| (|form| |domainForm|)
  (PROG (|opAlist| |key| |entryList| |ISTMP#1| |ISTMP#2| |ISTMP#3|
                   |ISTMP#4| |type|)
    (RETURN
      (PROGN
        (setq |opAlist|
                 (|getOperationAlistFromLisplib| (CAR |domainForm|)))
        (setq |key| (|opOf| |form|))
        (setq |entryList| (LASSOC |key| |opAlist|))
        (COND
          ((AND (CONSP |entryList|) (EQ (QCDR |entryList|) NIL)
                (PROGN
                  (setq |ISTMP#1| (QCAR |entryList|))
                  (AND (CONSP |ISTMP#1|)
                       (PROGN
                         (setq |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (CONSP |ISTMP#2|)
                              (PROGN
                                (setq |ISTMP#3| (QCDR |ISTMP#2|))
                                (AND (CONSP |ISTMP#3|)
                                     (PROGN
                                       (setq |ISTMP#4|
                                        (QCDR |ISTMP#3|))
                                       (AND (CONSP |ISTMP#4|)
                                        (EQ (QCDR |ISTMP#4|) NIL)
                                        (PROGN
                                          (setq |type|
                                           (QCAR |ISTMP#4|))
                                          'T)))))))))
                (|member| |type| '(CONST ASCONST)))
           'T)
          ((BOOT-EQUAL |key| '|One|)
           (|constantInDomain?| (CONS '|1| NIL) |domainForm|))
          ((BOOT-EQUAL |key| '|Zero|)
           (|constantInDomain?| (CONS '|0| NIL) |domainForm|))
          ('T NIL))))))


\end{chunk}
\section{Function getConstantFromDomain}
[[getConstantFromDomain]] is used to look up the constants $0$ and $1$
from the given [[domainForm]].
\begin{enumerate}
\item if [[isPartialMode]] (see i-funsel.boot) returns true then the
domain modemap contains the constant [[$EmptyMode]] which indicates
that the domain is not fully formed. In this case we return [[NIL]].
\end{enumerate}
\begin{chunk}{*}
;domainOne(domain) == getConstantFromDomain('(One),domain)

(DEFUN |domainOne| (|domain|)
  (|getConstantFromDomain| '(|One|) |domain|))

;domainZero(domain) == getConstantFromDomain('(Zero),domain)

(DEFUN |domainZero| (|domain|)
  (|getConstantFromDomain| '(|Zero|) |domain|))

;equalOne(object, domain) ==
;  -- tries using constant One and "=" from domain
;  -- object should not be wrapped
;  algEqual(object, getConstantFromDomain('(One),domain), domain)

(DEFUN |equalOne| (|object| |domain|)
  (|algEqual| |object| (|getConstantFromDomain| '(|One|) |domain|)
      |domain|))

;equalZero(object, domain) ==
;  -- tries using constant Zero and "=" from domain
;  -- object should not be wrapped
;  algEqual(object, getConstantFromDomain('(Zero),domain), domain)

(DEFUN |equalZero| (|object| |domain|)
  (|algEqual| |object| (|getConstantFromDomain| '(|Zero|) |domain|)
      |domain|))

\end{chunk}
\begin{verbatim}
 main algorithms for canCoerceFrom and coerceInteractive

coerceInteractive and canCoerceFrom are the two coercion functions
for $InteractiveMode. They translate RN, RF and RR to QF I, QF P
and RE RN, respectively, and call coerceInt or canCoerce, which
both work in the same way (e.g. coercion from t1 to t2):
1. they try to coerce t1 to t2 directly (tower coercion), and, if
  this fails, to coerce t1 to the last argument of t2 and embed
  this last argument into t2. These embedding functions are now only
  defined in the algebra code. (RSS 2-27-87)
2. the tower coercion looks whether there is any applicable local
  coercion, which means, one defined in boot or in algebra code.
  If there is an applicable function from a constructor, which is
  inside the type tower of t1, to the top level constructor of t2,
  then this constructor is bubbled up inside t1. This means,
  special coercion functions (defined in boot) are called, which
  commute two constructors in a tower. Then the local coercion is
  called on these constructors, which both are on top level now.
example:
let t1 = A B C D E (short for (A (B (C (D (E))))), where A ... E are
  type constructors), and t2 = F D G H I J
there is no coercion from t1 to t2 directly, so we try to coerce
  t1 to s1 = D G H I J, the last argument of t2
we create the type s2 = A D B C E and call a local coercion A2A
  from t1 to s2, which, by recursively calling coerce, bubbles up
  the constructor D
then we call a commute coerce from s2 to s3 = D A B C E and a local
  coerce D2D from s3 to s1
finally we embed s1 into t2, which completes the coercion t1 to t2
the result of canCoerceFrom is TRUE or NIL
the result of coerceInteractive is a object or NIL (=failed)
all boot coercion functions have the following result:
1. if u=$fromCoerceable$, then TRUE or NIL
2. if the coercion succeeds, the coerced value (this may be NIL)
3. if the coercion fails, they throw to a catch point in
     coerceByFunction

Interpreter Coercion Query Functions
\end{verbatim}
\begin{chunk}{*}
;canCoerce1(t1,t2) ==
;  -- general test for coercion
;  -- the result is NIL if it fails
;  t1 = t2 => true
;  absolutelyCanCoerceByCheating(t1,t2) or t1 = '(None) or t2 = '(Any) or
;    t1 in '((Mode)  (Domain) (SubDomain (Domain))) =>
;      t2 = $OutputForm => true
;      NIL
;    -- next is for tagged union selectors for the time being
;    t1 is ['Variable,=t2] or t2 is ['Variable,=t1] => true
;    STRINGP t1 =>
;      t2 = $String => true
;      t2 = $OutputForm => true
;      t2 is ['Union,:.] => canCoerceUnion(t1,t2)
;      t2 is ['Variable,v] and (t1 = PNAME(v)) => true
;      NIL
;    STRINGP t2 =>
;      t1 is ['Variable,v] and (t2 = PNAME(v)) => true
;      NIL
;    atom t1 or atom t2 => NIL
;    null isValidType(t2) => NIL
;    absolutelyCannotCoerce(t1,t2) => NIL
;    nt1 := CAR t1
;    nt2 := CAR t2
;    EQ(nt1,'Mapping) => EQ(nt2,'Any)
;    EQ(nt2,'Mapping) =>
;      EQ(nt1,'Variable) or EQ(nt1,'FunctionCalled) =>
;        canCoerceExplicit2Mapping(t1,t2)
;      NIL
;    EQ(nt1,'Union) or EQ(nt2,'Union) => canCoerceUnion(t1,t2)
;    -- efficiency hack
;    t1 is ['Segment, s1] and t2 is ['UniversalSegment, s2] and
;        (isEqualOrSubDomain(s1, s2) or canCoerce(s1, s2)) => true
;    t1 is ['Tuple,S] and t2 ^= '(OutputForm) => canCoerce(['List, S], t2)
;    isRingT2 := ofCategory(t2,'(Ring))
;    isRingT2 and isEqualOrSubDomain(t1,$Integer) => true
;    (ans := canCoerceTopMatching(t1,t2,nt1,nt2)) ^= 'maybe => ans
;    t2 = $Integer => canCoerceLocal(t1,t2)   -- is true
;    ans := canCoerceTower(t1,t2) or
;      [.,:arg]:= deconstructT t2
;      arg and
;        t:= last arg
;        canCoerce(t1,t) and canCoerceByFunction(t,t2) and 'T
;    ans or (t1 in '((PositiveInteger) (NonNegativeInteger))
;      and canCoerce($Integer,t2))

(DEFUN |canCoerce1| (|t1| |t2|)
  (PROG (|v| |nt1| |nt2| |s1| |s2| |ISTMP#1| S |isRingT2| |LETTMP#1|
             |arg| |t| |ans|)
    (DECLARE (SPECIAL |$Integer| |$OutputForm| |$String|))
    (RETURN
      (COND
        ((BOOT-EQUAL |t1| |t2|) 'T)
        ('T
         (OR (|absolutelyCanCoerceByCheating| |t1| |t2|)
             (BOOT-EQUAL |t1| '(|None|)) (BOOT-EQUAL |t2| '(|Any|))
             (COND
               ((|member| |t1|
                    '((|Mode|) (|Domain|) (|SubDomain| (|Domain|))))
                (COND ((BOOT-EQUAL |t2| |$OutputForm|) 'T) ('T NIL)))
               ((OR (AND (CONSP |t1|) (EQ (QCAR |t1|) '|Variable|)
                         (PROGN
                           (setq |ISTMP#1| (QCDR |t1|))
                           (AND (CONSP |ISTMP#1|)
                                (EQ (QCDR |ISTMP#1|) NIL)
                                (EQUAL (QCAR |ISTMP#1|) |t2|))))
                    (AND (CONSP |t2|) (EQ (QCAR |t2|) '|Variable|)
                         (PROGN
                           (setq |ISTMP#1| (QCDR |t2|))
                           (AND (CONSP |ISTMP#1|)
                                (EQ (QCDR |ISTMP#1|) NIL)
                                (EQUAL (QCAR |ISTMP#1|) |t1|)))))
                'T)
               ((STRINGP |t1|)
                (COND
                  ((BOOT-EQUAL |t2| |$String|) 'T)
                  ((BOOT-EQUAL |t2| |$OutputForm|) 'T)
                  ((AND (CONSP |t2|) (EQ (QCAR |t2|) '|Union|))
                   (|canCoerceUnion| |t1| |t2|))
                  ((AND (CONSP |t2|) (EQ (QCAR |t2|) '|Variable|)
                        (PROGN
                          (setq |ISTMP#1| (QCDR |t2|))
                          (AND (CONSP |ISTMP#1|)
                               (EQ (QCDR |ISTMP#1|) NIL)
                               (PROGN
                                 (setq |v| (QCAR |ISTMP#1|))
                                 'T)))
                        (BOOT-EQUAL |t1| (PNAME |v|)))
                   'T)
                  ('T NIL)))
               ((STRINGP |t2|)
                (COND
                  ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|Variable|)
                        (PROGN
                          (setq |ISTMP#1| (QCDR |t1|))
                          (AND (CONSP |ISTMP#1|)
                               (EQ (QCDR |ISTMP#1|) NIL)
                               (PROGN
                                 (setq |v| (QCAR |ISTMP#1|))
                                 'T)))
                        (BOOT-EQUAL |t2| (PNAME |v|)))
                   'T)
                  ('T NIL)))
               ((OR (ATOM |t1|) (ATOM |t2|)) NIL)
               ((NULL (|isValidType| |t2|)) NIL)
               ((|absolutelyCannotCoerce| |t1| |t2|) NIL)
               ('T (setq |nt1| (CAR |t1|))
                (setq |nt2| (CAR |t2|))
                (COND
                  ((EQ |nt1| '|Mapping|) (EQ |nt2| '|Any|))
                  ((EQ |nt2| '|Mapping|)
                   (COND
                     ((OR (EQ |nt1| '|Variable|)
                          (EQ |nt1| '|FunctionCalled|))
                      (|canCoerceExplicit2Mapping| |t1| |t2|))
                     ('T NIL)))
                  ((OR (EQ |nt1| '|Union|) (EQ |nt2| '|Union|))
                   (|canCoerceUnion| |t1| |t2|))
                  ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|Segment|)
                        (PROGN
                          (setq |ISTMP#1| (QCDR |t1|))
                          (AND (CONSP |ISTMP#1|)
                               (EQ (QCDR |ISTMP#1|) NIL)
                               (PROGN
                                 (setq |s1| (QCAR |ISTMP#1|))
                                 'T)))
                        (CONSP |t2|)
                        (EQ (QCAR |t2|) '|UniversalSegment|)
                        (PROGN
                          (setq |ISTMP#1| (QCDR |t2|))
                          (AND (CONSP |ISTMP#1|)
                               (EQ (QCDR |ISTMP#1|) NIL)
                               (PROGN
                                 (setq |s2| (QCAR |ISTMP#1|))
                                 'T)))
                        (OR (|isEqualOrSubDomain| |s1| |s2|)
                            (|canCoerce| |s1| |s2|)))
                   'T)
                  ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|Tuple|)
                        (PROGN
                          (setq |ISTMP#1| (QCDR |t1|))
                          (AND (CONSP |ISTMP#1|)
                               (EQ (QCDR |ISTMP#1|) NIL)
                               (PROGN (setq S (QCAR |ISTMP#1|)) 'T)))
                        (NEQUAL |t2| '(|OutputForm|)))
                   (|canCoerce| (CONS '|List| (CONS S NIL)) |t2|))
                  ('T
                   (setq |isRingT2| (|ofCategory| |t2| '(|Ring|)))
                   (COND
                     ((AND |isRingT2|
                           (|isEqualOrSubDomain| |t1| |$Integer|))
                      'T)
                     ((NEQUAL (setq |ans|
                                       (|canCoerceTopMatching| |t1|
                                        |t2| |nt1| |nt2|))
                              '|maybe|)
                      |ans|)
                     ((BOOT-EQUAL |t2| |$Integer|)
                      (|canCoerceLocal| |t1| |t2|))
                     ('T
                      (setq |ans|
                               (OR (|canCoerceTower| |t1| |t2|)
                                   (PROGN
                                     (setq |LETTMP#1|
                                      (|deconstructT| |t2|))
                                     (setq |arg| (CDR |LETTMP#1|))
                                     (AND |arg|
                                      (PROGN
                                        (setq |t| (|last| |arg|))
                                        (AND (|canCoerce| |t1| |t|)
                                         (|canCoerceByFunction| |t|
                                          |t2|)
                                         'T))))))
                      (OR |ans|
                          (AND (|member| |t1|
                                   '((|PositiveInteger|)
                                     (|NonNegativeInteger|)))
                               (|canCoerce| |$Integer| |t2|)))))))))))))))

;canCoerceFrom0(t1,t2) ==
;-- top level test for coercion, which transfers all RN, RF and RR into
;-- equivalent types
;  startTimingProcess 'querycoerce
;  q :=
;    isEqualOrSubDomain(t1,t2) or t1 = '(None) or t2 = '(Any) or
;      if t2 = $OutputForm then (s1 := t1; s2 := t2)
;      else (s1:= equiType(t1); s2:= equiType(t2))
;      -- make sure we are trying to coerce to a legal type
;      -- in particular, polynomials are repeated, etc.
;      null isValidType(t2) => NIL
;      null isLegitimateMode(t2,nil,nil) => NIL
;      t1 = $RationalNumber =>
;        isEqualOrSubDomain(t2,$Integer) => NIL
;        canCoerce(t1,t2) or canCoerce(s1,s2)
;      canCoerce(s1,s2)
;  stopTimingProcess 'querycoerce
;  q

(DEFUN |canCoerceFrom0| (|t1| |t2|)
  (PROG (|s1| |s2| |q|)
    (DECLARE (SPECIAL |$Integer| |$RationalNumber| |$OutputForm|))
    (RETURN
      (PROGN
        (|startTimingProcess| '|querycoerce|)
        (setq |q|
                 (OR (|isEqualOrSubDomain| |t1| |t2|)
                     (BOOT-EQUAL |t1| '(|None|))
                     (BOOT-EQUAL |t2| '(|Any|))
                     (PROGN
                       (COND
                         ((BOOT-EQUAL |t2| |$OutputForm|)
                          (setq |s1| |t1|) (setq |s2| |t2|))
                         ('T (setq |s1| |t1|)
                          (setq |s2| |t2|)))
                       (COND
                         ((NULL (|isValidType| |t2|)) NIL)
                         ((NULL (|isLegitimateMode| |t2| NIL NIL)) NIL)
                         ((BOOT-EQUAL |t1| |$RationalNumber|)
                          (COND
                            ((|isEqualOrSubDomain| |t2| |$Integer|)
                             NIL)
                            ('T
                             (OR (|canCoerce| |t1| |t2|)
                                 (|canCoerce| |s1| |s2|)))))
                         ('T (|canCoerce| |s1| |s2|))))))
        (|stopTimingProcess| '|querycoerce|)
        |q|))))

;isSubTowerOf(t1,t2) ==
;  -- assumes RF and RN stuff has been expanded
;  -- tests whether t1 is somewhere inside t2
;  isEqualOrSubDomain(t1,t2) => true
;  null (u := underDomainOf t2) => nil
;  isSubTowerOf(t1,u)

(DEFUN |isSubTowerOf| (|t1| |t2|)
  (PROG (|u|)
    (RETURN
      (COND
        ((|isEqualOrSubDomain| |t1| |t2|) 'T)
        ((NULL (setq |u| (|underDomainOf| |t2|))) NIL)
        ('T (|isSubTowerOf| |t1| |u|))))))

;canCoerceTopMatching(t1,t2,tt1,tt2) ==
;  -- returns true, nil or maybe
;  -- for example, if t1 = P[x] D1 and t2 = P[y] D2 and x = y then
;  -- canCoerce will only be true if D1 = D2
;  not EQ(tt1,tt2) => 'maybe
;  doms := '(Polynomial List Matrix FiniteSet Vector Stream Gaussian)
;  MEMQ(tt1,doms) => canCoerce(CADR t1, CADR t2)
;  not (member(tt1,$univariateDomains) or MEMQ(tt2,$multivariateDomains)) =>
;    'maybe
;  u2 := deconstructT t2
;  1 = #u2 => NIL
;  u1 := deconstructT t1
;  1 = #u1 => NIL                             -- no under domain
;  first(u1) ^= first(u2) => 'maybe
;  canCoerce(underDomainOf t1, underDomainOf t2)

(DEFUN |canCoerceTopMatching| (|t1| |t2| |tt1| |tt2|)
  (PROG (|doms| |u2| |u1|)
    (DECLARE (SPECIAL |$multivariateDomains| |$univariateDomains|))
    (RETURN
      (COND
        ((NULL (EQ |tt1| |tt2|)) '|maybe|)
        ('T
         (setq |doms|
                  '(|Polynomial| |List| |Matrix| |FiniteSet| |Vector|
                       |Stream| |Gaussian|))
         (COND
           ((member |tt1| |doms|) (|canCoerce| (CADR |t1|) (CADR |t2|)))
           ((NULL (OR (member |tt1| |$univariateDomains|)
                      (member |tt2| |$multivariateDomains|)))
            '|maybe|)
           ('T (setq |u2| (|deconstructT| |t2|))
            (COND
              ((EQL 1 (|#| |u2|)) NIL)
              ('T (setq |u1| (|deconstructT| |t1|))
               (COND
                 ((EQL 1 (|#| |u1|)) NIL)
                 ((NEQUAL (CAR |u1|) (CAR |u2|)) '|maybe|)
                 ('T
                  (|canCoerce| (|underDomainOf| |t1|)
                      (|underDomainOf| |t2|)))))))))))))

;canCoerceExplicit2Mapping(t1,t is ['Mapping,target,:argl]) ==
;  -- determines if there a mapping called var with the given args
;  -- and target
;  $useCoerceOrCroak: local := nil
;  t1 is ['Variable,var] =>
;    null (mms :=selectMms1(var,target,argl,[NIL for a in argl],true)) => NIL
;    mm := CAAR mms
;    mm is [., targ, :.] =>
;      targ = target => true
;      false
;    false
;  t1 is ['FunctionCalled,fun] =>
;    funNode := mkAtreeNode fun
;    transferPropsToNode(fun,funNode)
;    mms := CATCH('coerceOrCroaker, selectLocalMms(funNode,fun,argl,target))
;    CONSP mms =>
;      mms is [[['interpOnly,:.],:.]] => nil
;      mm := CAAR mms
;      mm is [., targ, :.] =>
;        targ = target => true
;        false
;      false
;    NIL
;  NIL

(DEFUN |canCoerceExplicit2Mapping| (|t1| |t|)
  (PROG (|$useCoerceOrCroak| |target| |argl| |var| |fun| |funNode|
            |mms| |ISTMP#2| |mm| |ISTMP#1| |targ|)
    (DECLARE (SPECIAL |$useCoerceOrCroak|))
    (RETURN
      (SEQ (PROGN
             (setq |target| (CADR |t|))
             (setq |argl| (CDDR |t|))
             (setq |$useCoerceOrCroak| NIL)
             (COND
               ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|Variable|)
                     (PROGN
                       (setq |ISTMP#1| (QCDR |t1|))
                       (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN
                              (setq |var| (QCAR |ISTMP#1|))
                              'T))))
                (COND
                  ((NULL (setq |mms|
                                  (|selectMms1| |var| |target| |argl|
                                      (PROG (G166754)
                                        (setq G166754 NIL)
                                        (RETURN
                                          (DO
                                           ((G166759 |argl|
                                             (CDR G166759))
                                            (|a| NIL))
                                           ((OR (ATOM G166759)
                                             (PROGN
                                               (SETQ |a|
                                                (CAR G166759))
                                               NIL))
                                            (NREVERSE0 G166754))
                                            (SEQ
                                             (EXIT
                                              (SETQ G166754
                                               (CONS NIL G166754)))))))
                                      'T)))
                   NIL)
                  ('T (setq |mm| (CAAR |mms|))
                   (COND
                     ((AND (CONSP |mm|)
                           (PROGN
                             (setq |ISTMP#1| (QCDR |mm|))
                             (AND (CONSP |ISTMP#1|)
                                  (PROGN
                                    (setq |targ| (QCAR |ISTMP#1|))
                                    'T))))
                      (COND
                        ((BOOT-EQUAL |targ| |target|) 'T)
                        ('T NIL)))
                     ('T NIL)))))
               ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|FunctionCalled|)
                     (PROGN
                       (setq |ISTMP#1| (QCDR |t1|))
                       (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN
                              (setq |fun| (QCAR |ISTMP#1|))
                              'T))))
                (setq |funNode| (|mkAtreeNode| |fun|))
                (|transferPropsToNode| |fun| |funNode|)
                (setq |mms|
                         (CATCH '|coerceOrCroaker|
                           (|selectLocalMms| |funNode| |fun| |argl|
                               |target|)))
                (COND
                  ((CONSP |mms|)
                   (COND
                     ((AND (CONSP |mms|) (EQ (QCDR |mms|) NIL)
                           (PROGN
                             (setq |ISTMP#1| (QCAR |mms|))
                             (AND (CONSP |ISTMP#1|)
                                  (PROGN
                                    (setq |ISTMP#2|
                                     (QCAR |ISTMP#1|))
                                    (AND (CONSP |ISTMP#2|)
                                     (EQ (QCAR |ISTMP#2|)
                                      '|interpOnly|))))))
                      NIL)
                     ('T (setq |mm| (CAAR |mms|))
                      (COND
                        ((AND (CONSP |mm|)
                              (PROGN
                                (setq |ISTMP#1| (QCDR |mm|))
                                (AND (CONSP |ISTMP#1|)
                                     (PROGN
                                       (setq |targ|
                                        (QCAR |ISTMP#1|))
                                       'T))))
                         (COND
                           ((BOOT-EQUAL |targ| |target|) 'T)
                           ('T NIL)))
                        ('T NIL)))))
                  ('T NIL)))
               ('T NIL)))))))

;canCoerceUnion(t1,t2) ==
;  -- sees if one can coerce to or from a Union Domain
;  -- assumes one of t1 and t2 is one
;  -- get the domains in the union, checking for tagged unions
;  if (isUnion1 := t1 is ['Union,:uds1]) then
;    unionDoms1 :=
;      uds1 and first uds1 is [":",:.] => [t for [.,.,t] in uds1]
;      uds1
;  if (isUnion2 := t2 is ['Union,:uds2]) then
;    unionDoms2 :=
;      uds2 and first uds2 is [":",:.] => [t for [.,.,t] in uds2]
;      uds2
;  isUnion2 =>
;    MEMBER(t1,unionDoms2) => true
;    isUnion1 =>
;      and/[or/[canCoerce(ud1,ud2) for ud2 in unionDoms2]
;        for ud1 in unionDoms1]
;    or/[canCoerce(t1,ud) for ud in unionDoms2]
;  -- next, a little lie
;  t1 is ['Union,d1, ='"failed"] and t2 = d1 => true
;  isUnion1 =>
;    and/[canCoerce(ud,t2) for ud in unionDoms1]
;  keyedSystemError("S2GE0016",['"canCoerceUnion",
;     '"called with 2 non-Unions"])

(DEFUN |canCoerceUnion| (|t1| |t2|)
  (PROG (|uds1| |isUnion1| |unionDoms1| |uds2| |isUnion2| |t|
                |unionDoms2| |ISTMP#1| |d1| |ISTMP#2|)
    (RETURN
      (SEQ (PROGN
             (COND
               ((setq |isUnion1|
                         (AND (CONSP |t1|) (EQ (QCAR |t1|) '|Union|)
                              (PROGN (setq |uds1| (QCDR |t1|)) 'T)))
                (setq |unionDoms1|
                         (COND
                           ((AND |uds1|
                                 (PROGN
                                   (setq |ISTMP#1| (CAR |uds1|))
                                   (AND (CONSP |ISTMP#1|)
                                    (EQ (QCAR |ISTMP#1|) '|:|))))
                            (PROG (G166818)
                              (setq G166818 NIL)
                              (RETURN
                                (DO ((G166824 |uds1| (CDR G166824))
                                     (G166791 NIL))
                                    ((OR (ATOM G166824)
                                      (PROGN
                                        (SETQ G166791
                                         (CAR G166824))
                                        NIL)
                                      (PROGN
                                        (PROGN
                                          (setq |t|
                                           (CADDR G166791))
                                          G166791)
                                        NIL))
                                     (NREVERSE0 G166818))
                                  (SEQ (EXIT
                                        (SETQ G166818
                                         (CONS |t| G166818))))))))
                           ('T |uds1|)))))
             (COND
               ((setq |isUnion2|
                         (AND (CONSP |t2|) (EQ (QCAR |t2|) '|Union|)
                              (PROGN (setq |uds2| (QCDR |t2|)) 'T)))
                (setq |unionDoms2|
                         (COND
                           ((AND |uds2|
                                 (PROGN
                                   (setq |ISTMP#1| (CAR |uds2|))
                                   (AND (CONSP |ISTMP#1|)
                                    (EQ (QCAR |ISTMP#1|) '|:|))))
                            (PROG (G166836)
                              (setq G166836 NIL)
                              (RETURN
                                (DO ((G166842 |uds2| (CDR G166842))
                                     (G166797 NIL))
                                    ((OR (ATOM G166842)
                                      (PROGN
                                        (SETQ G166797
                                         (CAR G166842))
                                        NIL)
                                      (PROGN
                                        (PROGN
                                          (setq |t|
                                           (CADDR G166797))
                                          G166797)
                                        NIL))
                                     (NREVERSE0 G166836))
                                  (SEQ (EXIT
                                        (SETQ G166836
                                         (CONS |t| G166836))))))))
                           ('T |uds2|)))))
             (COND
               (|isUnion2|
                   (COND
                     ((|member| |t1| |unionDoms2|) 'T)
                     (|isUnion1|
                         (PROG (G166849)
                           (setq G166849 'T)
                           (RETURN
                             (DO ((G166855 NIL (NULL G166849))
                                  (G166856 |unionDoms1|
                                      (CDR G166856))
                                  (|ud1| NIL))
                                 ((OR G166855 (ATOM G166856)
                                      (PROGN
                                        (SETQ |ud1| (CAR G166856))
                                        NIL))
                                  G166849)
                               (SEQ (EXIT
                                     (SETQ G166849
                                      (AND G166849
                                       (PROG (G166863)
                                         (setq G166863 NIL)
                                         (RETURN
                                           (DO
                                            ((G166869 NIL G166863)
                                             (G166870 |unionDoms2|
                                              (CDR G166870))
                                             (|ud2| NIL))
                                            ((OR G166869
                                              (ATOM G166870)
                                              (PROGN
                                                (SETQ |ud2|
                                                 (CAR G166870))
                                                NIL))
                                             G166863)
                                             (SEQ
                                              (EXIT
                                               (SETQ G166863
                                                (OR G166863
                                                 (|canCoerce| |ud1|
                                                  |ud2|))))))))))))))))
                     ('T
                      (PROG (G166877)
                        (setq G166877 NIL)
                        (RETURN
                          (DO ((G166883 NIL G166877)
                               (G166884 |unionDoms2| (CDR G166884))
                               (|ud| NIL))
                              ((OR G166883 (ATOM G166884)
                                   (PROGN
                                     (SETQ |ud| (CAR G166884))
                                     NIL))
                               G166877)
                            (SEQ (EXIT (SETQ G166877
                                        (OR G166877
                                         (|canCoerce| |t1| |ud|)))))))))))
               ((AND (CONSP |t1|) (EQ (QCAR |t1|) '|Union|)
                     (PROGN
                       (setq |ISTMP#1| (QCDR |t1|))
                       (AND (CONSP |ISTMP#1|)
                            (PROGN
                              (setq |d1| (QCAR |ISTMP#1|))
                              (setq |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (CONSP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (EQUAL (QCAR |ISTMP#2|) '"failed")))))
                     (BOOT-EQUAL |t2| |d1|))
                'T)
               (|isUnion1|
                   (PROG (G166891)
                     (setq G166891 'T)
                     (RETURN
                       (DO ((G166897 NIL (NULL G166891))
                            (G166898 |unionDoms1| (CDR G166898))
                            (|ud| NIL))
                           ((OR G166897 (ATOM G166898)
                                (PROGN
                                  (SETQ |ud| (CAR G166898))
                                  NIL))
                            G166891)
                         (SEQ (EXIT (SETQ G166891
                                     (AND G166891
                                      (|canCoerce| |ud| |t2|)))))))))
               ('T
                (|keyedSystemError|
                 "Unexpected error or improper call to system function %1: %2"
                    (CONS "canCoerceUnion"
                          (CONS "called with 2 non-Unions" NIL))))))))))

;canCoerceByMap(t1,t2) ==
;  -- idea is this: if t1 is D U1 and t2 is D U2, then look for
;  -- map: (U1 -> U2, D U1) -> D U2.  If it exists, then answer true
;  -- if canCoerceFrom(t1,t2).
;  u2 := deconstructT t2
;  1 = #u2 => NIL
;  u1 := deconstructT t1
;  1 = #u1 => NIL                             -- no under domain
;  CAR(u1) ^= CAR(u2) => NIL
;  top := CAAR u1
;  u1 := underDomainOf t1
;  u2 := underDomainOf t2
;  absolutelyCannotCoerce(u1,u2) => NIL
;  -- save some time for those we know about
;  know := '(List Vector Segment Stream UniversalSegment Array
;    Polynomial UnivariatePolynomial SquareMatrix Matrix)
;  top in know => canCoerce(u1,u2)
;  null selectMms1('map,t2,[['Mapping,u2,u1],t1],
;    [['Mapping,u2,u1],u1],NIL) => NIL
;  -- don't bother checking for Undef, so avoid instantiation
;  canCoerce(u1,u2)

(DEFUN |canCoerceByMap| (|t1| |t2|)
  (PROG (|top| |u1| |u2| |know|)
    (RETURN
      (PROGN
        (setq |u2| (|deconstructT| |t2|))
        (COND
          ((EQL 1 (|#| |u2|)) NIL)
          ('T (setq |u1| (|deconstructT| |t1|))
           (COND
             ((EQL 1 (|#| |u1|)) NIL)
             ((NEQUAL (CAR |u1|) (CAR |u2|)) NIL)
             ('T (setq |top| (CAAR |u1|))
              (setq |u1| (|underDomainOf| |t1|))
              (setq |u2| (|underDomainOf| |t2|))
              (COND
                ((|absolutelyCannotCoerce| |u1| |u2|) NIL)
                ('T
                 (setq |know|
                          '(|List| |Vector| |Segment| |Stream|
                                   |UniversalSegment| |Array|
                                   |Polynomial| |UnivariatePolynomial|
                                   |SquareMatrix| |Matrix|))
                 (COND
                   ((|member| |top| |know|) (|canCoerce| |u1| |u2|))
                   ((NULL (|selectMms1| '|map| |t2|
                              (CONS (CONS '|Mapping|
                                     (CONS |u2| (CONS |u1| NIL)))
                                    (CONS |t1| NIL))
                              (CONS (CONS '|Mapping|
                                     (CONS |u2| (CONS |u1| NIL)))
                                    (CONS |u1| NIL))
                              NIL))
                    NIL)
                   ('T (|canCoerce| |u1| |u2|)))))))))))))

;canCoerceTower(t1,t2) ==
;-- tries to find a coercion between top level t2 and somewhere inside t1
;-- builds new bubbled type, for which coercion is called recursively
;  canCoerceByMap(t1,t2) or newCanCoerceCommute(t1,t2) or
;   canCoerceLocal(t1,t2) or canCoercePermute(t1,t2) or
;    [c1,:arg1]:= deconstructT t1
;    arg1 and
;      TL:= NIL
;      arg:= arg1
;      until x or not arg repeat x:=
;        t:= last arg
;        [c,:arg]:= deconstructT t
;        TL:= [c,arg,:TL]
;        arg and coerceIntTest(t,t2) and
;          CDDR TL =>
;            s:= constructT(c1,replaceLast(arg1,bubbleConstructor TL))
;            canCoerceLocal(t1,s) and
;              [c2,:arg2]:= deconstructT last s
;              s1:= bubbleConstructor [c2,arg2,c1,arg1]
;              canCoerceCommute(s,s1) and canCoerceLocal(s1,t2)
;          s:= bubbleConstructor [c,arg,c1,arg1]
;          newCanCoerceCommute(t1,s) and canCoerceLocal(s,t2)
;      x

(DEFUN |canCoerceTower| (|t1| |t2|)
  (PROG (|c1| |arg1| |t| |c| |arg| TL |LETTMP#1| |c2| |arg2| |s1| |s|
              |x|)
    (RETURN
      (SEQ (OR (|canCoerceByMap| |t1| |t2|)
               (|newCanCoerceCommute| |t1| |t2|)
               (|canCoerceLocal| |t1| |t2|)
               (|canCoercePermute| |t1| |t2|)
               (PROGN
                 (setq |LETTMP#1| (|deconstructT| |t1|))
                 (setq |c1| (CAR |LETTMP#1|))
                 (setq |arg1| (CDR |LETTMP#1|))
                 (AND |arg1|
                      (PROGN
                        (setq TL NIL)
                        (setq |arg| |arg1|)
                        (DO ((G166978 NIL (OR |x| (NULL |arg|))))
                            (G166978 NIL)
                          (SEQ (EXIT (setq |x|
                                      (PROGN
                                        (setq |t| (|last| |arg|))
                                        (setq |LETTMP#1|
                                         (|deconstructT| |t|))
                                        (setq |c| (CAR |LETTMP#1|))
                                        (setq |arg|
                                         (CDR |LETTMP#1|))
                                        (setq TL
                                         (CONS |c| (CONS |arg| TL)))
                                        (AND |arg|
                                         (|coerceIntTest| |t| |t2|)
                                         (COND
                                           ((CDDR TL)
                                            (setq |s|
                                             (|constructT| |c1|
                                              (|replaceLast| |arg1|
                                               (|bubbleConstructor| TL))))
                                            (AND
                                             (|canCoerceLocal| |t1|
                                              |s|)
                                             (PROGN
                                               (setq |LETTMP#1|
                                                (|deconstructT|
                                                 (|last| |s|)))
                                               (setq |c2|
                                                (CAR |LETTMP#1|))
                                               (setq |arg2|
                                                (CDR |LETTMP#1|))
                                               (setq |s1|
                                                (|bubbleConstructor|
                                                 (CONS |c2|
                                                  (CONS |arg2|
                                                   (CONS |c1|
                                                    (CONS |arg1| NIL))))))
                                               (AND
                                                (|canCoerceCommute| |s|
                                                 |s1|)
                                                (|canCoerceLocal| |s1|
                                                 |t2|)))))
                                           ('T
                                            (setq |s|
                                             (|bubbleConstructor|
                                              (CONS |c|
                                               (CONS |arg|
                                                (CONS |c1|
                                                 (CONS |arg1| NIL))))))
                                            (AND
                                             (|newCanCoerceCommute|
                                              |t1| |s|)
                                             (|canCoerceLocal| |s|
                                              |t2|))))))))))
                        |x|))))))))

;canCoerceLocal(t1,t2) ==
;  -- test for coercion on top level
;  p:= ASSQ(CAR t1,$CoerceTable)
;  p and ASSQ(CAR t2,CDR p) is [.,:[tag,fun]] =>
;    tag='partial => NIL
;    tag='total   => true
;    (functionp(fun) and
;       (v:=CATCH('coerceFailure,FUNCALL(fun,'_$fromCoerceable_$,t1,t2)))
;         and v ^= $coerceFailure)  or  canCoerceByFunction(t1,t2)
;  canCoerceByFunction(t1,t2)

(DEFUN |canCoerceLocal| (|t1| |t2|)
  (PROG (|p| |ISTMP#1| |ISTMP#2| |tag| |ISTMP#3| |fun| |v|)
    (DECLARE (SPECIAL |$coerceFailure| |$CoerceTable|))
    (RETURN
      (PROGN
        (setq |p| (ASSQ (CAR |t1|) |$CoerceTable|))
        (COND
          ((AND |p|
                (PROGN
                  (setq |ISTMP#1| (ASSQ (CAR |t2|) (CDR |p|)))
                  (AND (CONSP |ISTMP#1|)
                       (PROGN
                         (setq |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (CONSP |ISTMP#2|)
                              (PROGN
                                (setq |tag| (QCAR |ISTMP#2|))
                                (setq |ISTMP#3| (QCDR |ISTMP#2|))
                                (AND (CONSP |ISTMP#3|)
                                     (EQ (QCDR |ISTMP#3|) NIL)
                                     (PROGN
                                       (setq |fun| (QCAR |ISTMP#3|))
                                       'T))))))))
           (COND
             ((BOOT-EQUAL |tag| '|partial|) NIL)
             ((BOOT-EQUAL |tag| '|total|) 'T)
             ('T
              (OR (AND (canFuncall? |fun|)
                       (setq |v|
                                (CATCH '|coerceFailure|
                                  (FUNCALL |fun| '|$fromCoerceable$|
                                           |t1| |t2|)))
                       (NEQUAL |v| |$coerceFailure|))
                  (|canCoerceByFunction| |t1| |t2|)))))
          ('T (|canCoerceByFunction| |t1| |t2|)))))))

;canCoerceCommute(t1,t2) ==
;-- THIS IS OUT-MODED AND WILL GO AWAY SOON  RSS 2-87
;-- t1 is t2 with the two top level constructors commuted
;-- looks for the existence of a commuting function
;  CAR(t1) in (l := [$QuotientField, 'Gaussian]) and
;    CAR(t2) in l => true
;  p:= ASSQ(CAR t1,$CommuteTable)
;  p and ASSQ(CAR t2,CDR p) is [.,:['commute,.]]

(DEFUN |canCoerceCommute| (|t1| |t2|)
  (PROG (|l| |p| |ISTMP#1| |ISTMP#2| |ISTMP#3|)
    (DECLARE (SPECIAL |$CommuteTable| |$QuotientField|))
    (RETURN
      (COND
        ((AND (|member| (CAR |t1|)
                  (setq |l|
                           (CONS |$QuotientField|
                                 (CONS '|Gaussian| NIL))))
              (|member| (CAR |t2|) |l|))
         'T)
        ('T (setq |p| (ASSQ (CAR |t1|) |$CommuteTable|))
         (AND |p|
              (PROGN
                (setq |ISTMP#1| (ASSQ (CAR |t2|) (CDR |p|)))
                (AND (CONSP |ISTMP#1|)
                     (PROGN
                       (setq |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (CONSP |ISTMP#2|)
                            (EQ (QCAR |ISTMP#2|) '|commute|)
                            (PROGN
                              (setq |ISTMP#3| (QCDR |ISTMP#2|))
                              (AND (CONSP |ISTMP#3|)
                                   (EQ (QCDR |ISTMP#3|) NIL)))))))))))))

;newCanCoerceCommute(t1,t2) ==
;  coerceIntCommute(objNewWrap("$fromCoerceable$",t1),t2)

(DEFUN |newCanCoerceCommute| (|t1| |t2|)
  (|coerceIntCommute| (mkObjWrap '|$fromCoerceable$| |t1|) |t2|))

;canCoercePermute(t1,t2) ==
;  -- try to generate a sequence of transpositions that will convert
;  -- t1 into t2
;  t2 in '((Integer) (OutputForm)) => NIL
;  towers := computeTTTranspositions(t1,t2)
;  -- at this point, CAR towers = t1 and last towers should be similar
;  -- to t2 in the sense that the components of t1 are in the same order
;  -- as in t2. If length towers = 2 and t2 = last towers, we quit to
;  -- avoid an infinte loop.
;  NULL towers or NULL CDR towers => NIL
;  NULL CDDR towers and t2 = CADR towers => NIL
;  -- do the coercions successively, quitting if any fail
;  ok := true
;  for t in CDR towers while ok repeat
;    ok := canCoerce(t1,t)
;    if ok then t1 := t
;  ok

(DEFUN |canCoercePermute| (|t1| |t2|)
  (PROG (|towers| |ok|)
    (RETURN
      (SEQ (COND
             ((|member| |t2| '((|Integer|) (|OutputForm|))) NIL)
             ('T
              (setq |towers| (|computeTTTranspositions| |t1| |t2|))
              (COND
                ((OR (NULL |towers|) (NULL (CDR |towers|))) NIL)
                ((AND (NULL (CDDR |towers|))
                      (BOOT-EQUAL |t2| (CADR |towers|)))
                 NIL)
                ('T (setq |ok| 'T)
                 (DO ((G167071 (CDR |towers|) (CDR G167071))
                      (|t| NIL))
                     ((OR (ATOM G167071)
                          (PROGN (SETQ |t| (CAR G167071)) NIL)
                          (NULL |ok|))
                      NIL)
                   (SEQ (EXIT (PROGN
                                (setq |ok| (|canCoerce| |t1| |t|))
                                (COND
                                  (|ok| (setq |t1| |t|))
                                  ('T NIL))))))
                 |ok|))))))))

;canConvertByFunction(m1,m2) ==
;  null $useConvertForCoercions => NIL
;  canCoerceByFunction1(m1,m2,'convert)

(DEFUN |canConvertByFunction| (|m1| |m2|)
  (DECLARE (SPECIAL |$useConvertForCoercions|))
  (COND
    ((NULL |$useConvertForCoercions|) NIL)
    ('T (|canCoerceByFunction1| |m1| |m2| '|convert|))))

;canCoerceByFunction(m1,m2) == canCoerceByFunction1(m1,m2,'coerce)

(DEFUN |canCoerceByFunction| (|m1| |m2|)
  (|canCoerceByFunction1| |m1| |m2| '|coerce|))

;canCoerceByFunction1(m1,m2,fun) ==
;  -- calls selectMms with $Coerce=NIL and tests for required target=m2
;  $declaredMode:local:= NIL
;  $reportBottomUpFlag:local:= NIL
;  -- have to handle cases where we might have changed from RN to QF I
;  -- make 2 lists of expanded and unexpanded types
;  l1 := REMDUP [m1,eqType m1]
;  l2 := REMDUP [m2,eqType m2]
;  ans  := NIL
;  for t1 in l1 while not ans repeat
;    for t2 in l2 while not ans repeat
;      l := selectMms1(fun,t2,[t1],[t1],NIL)
;      ans := [x for x in l | x is [sig,:.] and CADR sig=t2 and
;       CADDR sig=t1 and
;        CAR(sig) isnt ['TypeEquivalence,:.]] and true
;  ans

(defun |canCoerceByFunction1| (m1 m2 fun)
 (let (|$declaredMode| |$reportBottomUpFlag| l1 l2 l sig ans)
  (declare (special |$declaredMode| |$reportBottomUpFlag|))
  (setq |$declaredMode| nil)
  (setq |$reportBottomUpFlag| nil)
  (setq l (|selectMms1| fun m2 (list m1) (list m1) nil))
  (loop for x in l 
   when (and (equal (cadar x) m2) (equal (caddar x) m1))
   collect x)))

;absolutelyCannotCoerce(t1,t2) ==
;  -- response of true means "definitely cannot coerce"
;  -- this is largely an efficiency hack
;  ATOM(t1) or ATOM(t2) => NIL
;  t2 = '(None) => true
;  n1   := CAR t1
;  n2   := CAR t2
;  QFI  := [$QuotientField, $Integer]
;  int2 := isEqualOrSubDomain(t2,$Integer)
;  scalars := '(BigFloat NewFloat Float DoubleFloat RationalNumber)
;  MEMQ(n1,scalars) and int2 => true
;  (t1 = QFI) and int2       => true
;  num2 := int2 or MEMQ(n2,scalars) or (t2 = QFI)
;  isVar1 := MEMQ(n1,'(Variable Symbol))
;  num2 and isVar1 => true
;  num2 and MEMQ(n1,$univariateDomains) => true
;  num2 and MEMQ(n1,$multivariateDomains) => true
;  miscpols :=  '(Polynomial ElementaryFunction SimpleAlgebraicExtension)
;  num2 and MEMQ(n1,miscpols) => true
;  aggs :=  '(
;    Matrix List Vector Stream Array RectangularMatrix FiniteSet
;       )
;  u1 := underDomainOf t1
;  u2 := underDomainOf t2
;  MEMQ(n1,aggs) and (u1 = t2) => true
;  MEMQ(n2,aggs) and (u2 = t1) => true
;  algs :=  '(
;    SquareMatrix Gaussian RectangularMatrix Quaternion
;       )
;  nonpols := append(aggs,algs)
;  num2 and MEMQ(n1,nonpols) => true
;  isVar1 and MEMQ(n2,nonpols) and
;    absolutelyCannotCoerce(t1,u2) => true
;  (member(n1,scalars) or (t1 = QFI)) and (t2 = '(Polynomial (Integer))) =>
;    true
;  v2 := deconstructT t2
;  1 = #v2 => NIL
;  v1 := deconstructT t1
;  1 = #v1 => NIL
;  CAR(v1) ^= CAR(v2) => NIL
;  absolutelyCannotCoerce(u1,u2)

(DEFUN |absolutelyCannotCoerce| (|t1| |t2|)
  (PROG (|n1| |n2| QFI |int2| |scalars| |num2| |isVar1| |miscpols|
              |aggs| |u1| |u2| |algs| |nonpols| |v2| |v1|)
    (DECLARE (SPECIAL |$multivariateDomains| |$univariateDomains|
                      |$Integer| |$QuotientField|))
    (RETURN
      (COND
        ((OR (ATOM |t1|) (ATOM |t2|)) NIL)
        ((BOOT-EQUAL |t2| '(|None|)) 'T)
        ('T (setq |n1| (CAR |t1|)) (setq |n2| (CAR |t2|))
         (setq QFI (CONS |$QuotientField| (CONS |$Integer| NIL)))
         (setq |int2| (|isEqualOrSubDomain| |t2| |$Integer|))
         (setq |scalars|
                  '(|BigFloat| |NewFloat| |Float| |DoubleFloat|
                       |RationalNumber|))
         (COND
           ((AND (member |n1| |scalars|) |int2|) 'T)
           ((AND (BOOT-EQUAL |t1| QFI) |int2|) 'T)
           ('T
            (setq |num2|
                     (OR |int2| (member |n2| |scalars|)
                         (BOOT-EQUAL |t2| QFI)))
            (setq |isVar1| (member |n1| '(|Variable| |Symbol|)))
            (COND
              ((AND |num2| |isVar1|) 'T)
              ((AND |num2| (member |n1| |$univariateDomains|)) 'T)
              ((AND |num2| (member |n1| |$multivariateDomains|)) 'T)
              ('T
               (setq |miscpols|
                        '(|Polynomial| |ElementaryFunction|
                             |SimpleAlgebraicExtension|))
               (COND
                 ((AND |num2| (member |n1| |miscpols|)) 'T)
                 ('T
                  (setq |aggs|
                           '(|Matrix| |List| |Vector| |Stream| |Array|
                                |RectangularMatrix| |FiniteSet|))
                  (setq |u1| (|underDomainOf| |t1|))
                  (setq |u2| (|underDomainOf| |t2|))
                  (COND
                    ((AND (member |n1| |aggs|) (BOOT-EQUAL |u1| |t2|))
                     'T)
                    ((AND (member |n2| |aggs|) (BOOT-EQUAL |u2| |t1|))
                     'T)
                    ('T
                     (setq |algs|
                              '(|SquareMatrix| |Gaussian|
                                   |RectangularMatrix| |Quaternion|))
                     (setq |nonpols| (APPEND |aggs| |algs|))
                     (COND
                       ((AND |num2| (member |n1| |nonpols|)) 'T)
                       ((AND |isVar1| (member |n2| |nonpols|)
                             (|absolutelyCannotCoerce| |t1| |u2|))
                        'T)
                       ((AND (OR (member |n1| |scalars|)
                                 (BOOT-EQUAL |t1| QFI))
                             (BOOT-EQUAL |t2|
                                 '(|Polynomial| (|Integer|))))
                        'T)
                       ('T (setq |v2| (|deconstructT| |t2|))
                        (COND
                          ((EQL 1 (|#| |v2|)) NIL)
                          ('T (setq |v1| (|deconstructT| |t1|))
                           (COND
                             ((EQL 1 (|#| |v1|)) NIL)
                             ((NEQUAL (CAR |v1|) (CAR |v2|)) NIL)
                    ('T (|absolutelyCannotCoerce| |u1| |u2|))))))))))))))))))))

;typeIsASmallInteger x == (x = $SingleInteger)

(DEFUN |typeIsASmallInteger| (|x|)
  (DECLARE (SPECIAL |$SingleInteger|))
  (BOOT-EQUAL |x| |$SingleInteger|))

;getUnionOrRecordTags u ==
;  tags := nil
;  if u is ['Union, :tl] or u is ['Record, :tl] then
;      for t in tl repeat
;         if t is [":",tag,.] then tags := cons(tag, tags)
;  tags

(DEFUN |getUnionOrRecordTags| (|u|)
  (PROG (|tl| |ISTMP#1| |tag| |ISTMP#2| |tags|)
    (RETURN
      (SEQ (PROGN
             (setq |tags| NIL)
             (COND
               ((OR (AND (CONSP |u|) (EQ (QCAR |u|) '|Union|)
                         (PROGN (setq |tl| (QCDR |u|)) 'T))
                    (AND (CONSP |u|) (EQ (QCAR |u|) '|Record|)
                         (PROGN (setq |tl| (QCDR |u|)) 'T)))
                (DO ((G167701 |tl| (CDR G167701)) (|t| NIL))
                    ((OR (ATOM G167701)
                         (PROGN (SETQ |t| (CAR G167701)) NIL))
                     NIL)
                  (SEQ (EXIT (COND
                               ((AND (CONSP |t|) (EQ (QCAR |t|) '|:|)
                                     (PROGN
                                       (setq |ISTMP#1| (QCDR |t|))
                                       (AND (CONSP |ISTMP#1|)
                                        (PROGN
                                          (setq |tag|
                                           (QCAR |ISTMP#1|))
                                          (setq |ISTMP#2|
                                           (QCDR |ISTMP#1|))
                                          (AND (CONSP |ISTMP#2|)
                                           (EQ (QCDR |ISTMP#2|) NIL))))))
                                (setq |tags| (CONS |tag| |tags|)))
                               ('T NIL)))))))
             |tags|)))))

\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
