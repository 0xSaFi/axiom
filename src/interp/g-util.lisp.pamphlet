\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp g-util.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{chunk}{*}

(IN-PACKAGE "BOOT" )

;PPtoFile(x, fname) ==
;    stream := DEFIOSTREAM([['MODE, :'OUTPUT], ['FILE, :fname]], 80, 0)
;    PRETTYPRINT(x, stream)
;    SHUT stream
;    x

; unused
;(DEFUN |PPtoFile| (|x| |fname|)
;  (PROG (|stream|)
;    (RETURN
;      (PROGN
;        (setq |stream|
;                 (DEFIOSTREAM
;                     (CONS (CONS 'MODE 'OUTPUT)
;                           (CONS (CONS 'FILE |fname|) NIL))
;                     80 0))
;        (PRETTYPRINT |x| |stream|)
;        (SHUT |stream|)
;        |x|))))

;bool x ==
;    NULL NULL x

(DEFUN |bool| (|x|) (NULL (NULL |x|))) 

;Identity x == x

(DEFUN |Identity| (|x|) |x|) 

;length1? l == CONSP l and not CONSP QCDR l

(DEFUN |length1?| (|l|) (AND (CONSP |l|) (NULL (CONSP (QCDR |l|))))) 

;length2? l == CONSP l and CONSP (l := QCDR l) and not CONSP QCDR l

; unused
;(DEFUN |length2?| (|l|)
; (AND (CONSP |l|) (CONSP (setq |l| (QCDR |l|))) (NULL (CONSP (QCDR |l|))))) 

;pairList(u,v) == [[x,:y] for x in u for y in v]

(defun pairList (u v)
 (loop for x in u for y in v collect (cons x y)))

;GETALIST(alist,prop) == CDR assoc(prop,alist)

(defun getalist (alist prop)
 (cdr (assoc prop alist))) 

;PUTALIST(alist,prop,val) ==
;  null alist => [[prop,:val]]
;  pair := assoc(prop,alist) =>
;    CDR pair = val => alist
;    -- else we fall over Lucid's read-only storage feature again
;    QRPLACD(pair,val)
;    alist
;  QRPLACD(LASTPAIR alist,[[prop,:val]])
;  alist

(defun putalist (alist prop val)
 (let (pair)
  (cond
   ((null alist) (list (cons prop val)))
   ((setq pair (assoc prop alist))
     (if (equal (cdr pair) val)
       alist
       (progn
         (qrplacd pair val)
         alist)))
   (t
    (qrplacd (lastpair alist) (list (cons prop val)))
    alist))))

;REMALIST(alist,prop) ==
;  null alist => alist
;  alist is [[ =prop,:.],:r] =>
;    null r => NIL
;    QRPLACA(alist,CAR r)
;    QRPLACD(alist,CDR r)
;    alist
;  null rest alist => alist
;  l := alist
;  ok := true
;  while ok repeat
;    [.,[p,:.],:r] := l
;    p = prop =>
;      ok := NIL
;      QRPLACD(l,r)
;    if null (l := QCDR l) or null rest l then ok := NIL
;  alist

(DEFUN REMALIST (|alist| |prop|)
  (PROG (|ISTMP#1| |p| |r| |l| |ok|)
    (RETURN
      (SEQ (COND
             ((NULL |alist|) |alist|)
             ((AND (CONSP |alist|)
                   (PROGN
                     (setq |ISTMP#1| (QCAR |alist|))
                     (AND (CONSP |ISTMP#1|)
                          (EQUAL (QCAR |ISTMP#1|) |prop|)))
                   (PROGN (setq |r| (QCDR |alist|)) 'T))
              (COND
                ((NULL |r|) NIL)
                ('T (QRPLACA |alist| (CAR |r|))
                 (QRPLACD |alist| (CDR |r|)) |alist|)))
             ((NULL (CDR |alist|)) |alist|)
             ('T (setq |l| |alist|) (setq |ok| 'T)
              (DO () ((NULL |ok|) NIL)
                (SEQ (EXIT (PROGN
                             (setq |p| (CAADR |l|))
                             (setq |r| (CDDR |l|))
                             (COND
                               ((BOOT-EQUAL |p| |prop|)
                                (setq |ok| NIL) (QRPLACD |l| |r|))
                               ((OR (NULL (setq |l| (QCDR |l|)))
                                    (NULL (CDR |l|)))
                                (setq |ok| NIL))
                               ('T NIL))))))
              |alist|))))))

;deleteLassoc(x,y) ==
;  y is [[a,:.],:y'] =>
;    EQ(x,a) => y'
;    [first y,:deleteLassoc(x,y')]
;  y

(DEFUN |deleteLassoc| (|x| |y|)
  (PROG (|ISTMP#1| |a| |y'|)
    (RETURN
      (COND
        ((AND (CONSP |y|)
              (PROGN
                (setq |ISTMP#1| (QCAR |y|))
                (AND (CONSP |ISTMP#1|)
                     (PROGN (setq |a| (QCAR |ISTMP#1|)) 'T)))
              (PROGN (setq |y'| (QCDR |y|)) 'T))
         (COND
           ((EQ |x| |a|) |y'|)
           ('T (CONS (CAR |y|) (|deleteLassoc| |x| |y'|)))))
        ('T |y|)))))

;deleteAssoc(x,y) ==
;  y is [[a,:.],:y'] =>
;   a=x => deleteAssoc(x,y')
;   [first y,:deleteAssoc(x,y')]
;  y

(DEFUN |deleteAssoc| (|x| |y|)
  (PROG (|ISTMP#1| |a| |y'|)
    (RETURN
      (COND
        ((AND (CONSP |y|)
              (PROGN
                (setq |ISTMP#1| (QCAR |y|))
                (AND (CONSP |ISTMP#1|)
                     (PROGN (setq |a| (QCAR |ISTMP#1|)) 'T)))
              (PROGN (setq |y'| (QCDR |y|)) 'T))
         (COND
           ((BOOT-EQUAL |a| |x|) (|deleteAssoc| |x| |y'|))
           ('T (CONS (CAR |y|) (|deleteAssoc| |x| |y'|)))))
        ('T |y|)))))

;deleteAssocWOC(x,y) ==
;  null y => y
;  [[a,:.],:t]:= y
;  x=a => t
;  (fn(x,y);y) where fn(x,y is [h,:t]) ==
;    t is [[a,:.],:t1] =>
;      x=a => RPLACD(y,t1)
;      fn(x,t)
;    nil

(DEFUN |deleteAssocWOC,fn| (|x| |y|)
  (PROG (|h| |t| |ISTMP#1| |a| |t1|)
    (RETURN
      (SEQ (PROGN
             (setq |h| (CAR |y|))
             (setq |t| (CDR |y|))
             |y|
             (SEQ (IF (AND (CONSP |t|)
                           (PROGN
                             (setq |ISTMP#1| (QCAR |t|))
                             (AND (CONSP |ISTMP#1|)
                                  (PROGN
                                    (setq |a| (QCAR |ISTMP#1|))
                                    'T)))
                           (PROGN (setq |t1| (QCDR |t|)) 'T))
                      (EXIT (SEQ (IF (BOOT-EQUAL |x| |a|)
                                     (EXIT (RPLACD |y| |t1|)))
                                 (EXIT (|deleteAssocWOC,fn| |x| |t|)))))
                  (EXIT NIL)))))))

(DEFUN |deleteAssocWOC| (|x| |y|)
  (PROG (|a| |t|)
    (RETURN
      (COND
        ((NULL |y|) |y|)
        ('T (setq |a| (CAAR |y|)) (setq |t| (CDR |y|))
         (COND
           ((BOOT-EQUAL |x| |a|) |t|)
           ('T (|deleteAssocWOC,fn| |x| |y|) |y|)))))))

;insertWOC(x,y) ==
;  null y => [x]
;  (fn(x,y); y) where fn(x,y is [h,:t]) ==
;    x=h => nil
;    null t =>
;      RPLACD(y,[h,:t])
;      RPLACA(y,x)
;    fn(x,t)

(DEFUN |insertWOC,fn| (|x| |y|)
  (PROG (|h| |t|)
    (RETURN
      (SEQ (PROGN
             (setq |h| (CAR |y|))
             (setq |t| (CDR |y|))
             |y|
             (SEQ (IF (BOOT-EQUAL |x| |h|) (EXIT NIL))
                  (IF (NULL |t|)
                      (EXIT (SEQ (RPLACD |y| (CONS |h| |t|))
                                 (EXIT (RPLACA |y| |x|)))))
                  (EXIT (|insertWOC,fn| |x| |t|))))))))

(DEFUN |insertWOC| (|x| |y|)
  (COND ((NULL |y|) (CONS |x| NIL)) ('T (|insertWOC,fn| |x| |y|) |y|)))

;centerString(text,width,fillchar) ==
;  wid := entryWidth text
;  wid >= width => text
;  f := DIVIDE(width - wid,2)
;  fill1 := ""
;  for i in 1..(f.0) repeat
;    fill1 := STRCONC(fillchar,fill1)
;  fill2:= fill1
;  if f.1 ^= 0 then fill1 := STRCONC(fillchar,fill1)
;  [fill1,text,fill2]

(DEFUN |centerString| (|text| |width| |fillchar|)
  (PROG (|wid| |f| |fill2| |fill1|)
    (RETURN
      (SEQ (PROGN
             (setq |wid| (|#| (|atom2String| |text|)))
             (COND
               ((>= |wid| |width|) |text|)
               ('T
                (setq |f| (DIVIDE (- |width| |wid|) 2))
                (setq |fill1| '||)
                (DO ((G1407 (ELT |f| 0)) (|i| 1 (QSADD1 |i|)))
                    ((QSGREATERP |i| G1407) NIL)
                  (SEQ (EXIT (setq |fill1|
                                      (STRCONC |fillchar| |fill1|)))))
                (setq |fill2| |fill1|)
                (COND
                  ((NEQUAL (ELT |f| 1) 0)
                   (setq |fill1| (STRCONC |fillchar| |fill1|))))
                (CONS |fill1| (CONS |text| (CONS |fill2| NIL))))))))))

;stringChar2Integer(str,pos) ==
;  -- replaces GETSTRINGDIGIT in UT LISP
;  -- returns small integer represented by character in position pos
;  -- in string str. Returns NIL if not a digit or other error.
;  if IDENTP str then str := PNAME str
;  null (STRINGP(str) and
;    INTEGERP(pos) and (pos >= 0) and (pos < QCSIZE(str))) => NIL
;  not DIGITP(d := SCHAR(str,pos)) => NIL
;  DIG2FIX d

(DEFUN |stringChar2Integer| (|str| |pos|)
  (PROG (|d|)
    (RETURN
      (PROGN
        (COND ((IDENTP |str|) (setq |str| (PNAME |str|))))
        (COND
          ((NULL (AND (STRINGP |str|) (INTEGERP |pos|) (>= |pos| 0)
                      (> (QCSIZE |str|) |pos|)))
           NIL)
          ((NULL (DIGITP (setq |d| (SCHAR |str| |pos|)))) NIL)
          ('T (DIG2FIX |d|)))))))

;dropLeadingBlanks str ==
;  str := object2String str
;  l := QCSIZE str
;  nb := NIL
;  i := 0
;  while (i < l) and not nb repeat
;    if SCHAR(str,i) ^= " " then nb := i
;    else i := i + 1
;  nb = 0 => str
;  nb => SUBSTRING(str,nb,NIL)
;  '""

;(DEFUN |dropLeadingBlanks| (|str|)
;  (PROG (|l| |nb| |i|)
;    (RETURN
;      (SEQ (PROGN
;             (setq |str| (|object2String| |str|))
;             (setq |l| (QCSIZE |str|))
;             (setq |nb| NIL)
;             (setq |i| 0)
;             (DO () ((NULL (AND (> |l| |i|) (NULL |nb|))) NIL)
;               (SEQ (EXIT (COND
;                            ((NEQUAL (SCHAR |str| |i|) '| |)
;                             (setq |nb| |i|))
;                            ('T (setq |i| (+ |i| 1)))))))
;             (COND
;               ((EQL |nb| 0) |str|)
;               (|nb| (SUBSTRING |str| |nb| NIL))
;               ('T "")))))))

;concat(:l) == concatList l

(DEFUN |concat| (&REST G1408 &AUX |l|)
  (DSETQ |l| G1408)
  (|concatList| |l|))

;concatList [x,:y] ==
;  null y => x
;  null x => concatList y
;  concat1(x,concatList y)

(DEFUN |concatList| (G1409)
  (PROG (|x| |y|)
    (RETURN
      (PROGN
        (setq |x| (CAR G1409))
        (setq |y| (CDR G1409))
        (COND
          ((NULL |y|) |x|)
          ((NULL |x|) (|concatList| |y|))
          ('T (|concat1| |x| (|concatList| |y|))))))))

;concat1(x,y) ==
;  null x => y
;  atom x => (null y => x; atom y => [x,y]; [x,:y])
;  null y => x
;  atom y => [:x,y]
;  [:x,:y]

(DEFUN |concat1| (|x| |y|)
  (COND
    ((NULL |x|) |y|)
    ((ATOM |x|)
     (COND
       ((NULL |y|) |x|)
       ((ATOM |y|) (CONS |x| (CONS |y| NIL)))
       ('T (CONS |x| |y|))))
    ((NULL |y|) |x|)
    ((ATOM |y|) (APPEND |x| (CONS |y| NIL)))
    ('T (APPEND |x| |y|))))

;ravel a == a

;(DEFUN |ravel| (|a|) |a|) 

;reshape(a,b) == a

(DEFUN |reshape| (|a| |b|)
 (declare (ignore |b|))
 |a|) 

;boolODDP x == ODDP x

(DEFUN |boolODDP| (|x|) (ODDP |x|)) 

;freeOfSharpVars x ==
;  atom x => not isSharpVarWithNum x
;  freeOfSharpVars first x and freeOfSharpVars rest x

(DEFUN |freeOfSharpVars| (|x|)
  (COND
    ((ATOM |x|) (NULL (|isSharpVarWithNum| |x|)))
    ('T
     (AND (|freeOfSharpVars| (CAR |x|)) (|freeOfSharpVars| (CDR |x|))))))

;listOfSharpVars x ==
;  atom x => (isSharpVarWithNum x => LIST x; nil)
;  setUnion(listOfSharpVars first x,listOfSharpVars rest x)

(DEFUN |listOfSharpVars| (|x|)
  (COND
    ((ATOM |x|) (COND ((|isSharpVarWithNum| |x|) (LIST |x|)) ('T NIL)))
    ('T
     (|union| (|listOfSharpVars| (CAR |x|))
              (|listOfSharpVars| (CDR |x|))))))

;listOfPatternIds x ==
;  isPatternVar x => [x]
;  atom x => nil
;  x is ['QUOTE,:.] => nil
;  UNIONQ(listOfPatternIds first x,listOfPatternIds rest x)

(DEFUN |listOfPatternIds| (|x|)
  (COND
    ((|isPatternVar| |x|) (CONS |x| NIL))
    ((ATOM |x|) NIL)
    ((AND (CONSP |x|) (EQ (QCAR |x|) 'QUOTE)) NIL)
    ('T
     (UNIONQ (|listOfPatternIds| (CAR |x|))
             (|listOfPatternIds| (CDR |x|))))))

;removeZeroOne x ==
;  -- replace all occurrences of (Zero) and (One) with
;  -- 0 and 1
;  x = $Zero => 0
;  x = $One => 1
;  atom x => x
;  [removeZeroOne first x,:removeZeroOne rest x]

(DEFUN |removeZeroOne| (|x|)
  (DECLARE (SPECIAL |$One| |$Zero|))
  (COND
    ((BOOT-EQUAL |x| |$Zero|) 0)
    ((BOOT-EQUAL |x| |$One|) 1)
    ((ATOM |x|) |x|)
    ('T (CONS (|removeZeroOne| (CAR |x|)) (|removeZeroOne| (CDR |x|))))))

;removeZeroOneDestructively t ==
;  -- replace all occurrences of (Zero) and (One) with
;  -- 0 and 1 destructively
;  t = $Zero => 0
;  t = $One => 1
;  atom t => t
;  RPLNODE(t,removeZeroOneDestructively first t,
;    removeZeroOneDestructively rest t)

(defun |removeZeroOneDestructively| (tt)
 (declare (special |$One| |$Zero|))
 (cond
   ((equal tt |$Zero|) 0)
   ((equal tt |$One|) 1)
   ((atom tt) tt)
   (t
    (rplaca tt (|removeZeroOneDestructively| (car tt)))
    (rplacd tt (|removeZeroOneDestructively| (cdr tt)))
    tt)))

;flattenSexpr s ==
;  null s => s
;  ATOM s => s
;  [f,:r] := s
;  ATOM f => [f,:flattenSexpr r]
;  [:flattenSexpr f,:flattenSexpr r]

(DEFUN |flattenSexpr| (|s|)
  (PROG (|f| |r|)
    (RETURN
      (COND
        ((NULL |s|) |s|)
        ((ATOM |s|) |s|)
        ('T (setq |f| (CAR |s|)) (setq |r| (CDR |s|))
         (COND
           ((ATOM |f|) (CONS |f| (|flattenSexpr| |r|)))
           ('T (APPEND (|flattenSexpr| |f|) (|flattenSexpr| |r|)))))))))

;update() ==
;  OBEY
;    STRCONC('"SPADEDIT ",princ-to-string _/VERSION,'" ",princ-to-string _/WSNAME,'" A")
;  _/UPDATE()

(DEFUN |update| ()
  (declare (special /VERSION /WSNAME))
  (PROGN
    (OBEY (STRCONC "SPADEDIT " (princ-to-string /VERSION) " "
                   (princ-to-string /WSNAME) " A"))
    (/UPDATE)))

;listSort(pred,list,:optional) ==
;   NOT functionp pred => error "listSort: first arg must be a function"
;   NOT LISTP list => error "listSort: second argument must be a list"
;   NULL optional => mergeSort(pred,function Identity,list,LENGTH list)
;   key := CAR optional
;   NOT functionp key => error "listSort: last arg must be a function"
;   mergeSort(pred,key,list,LENGTH list)

(DEFUN |listSort| (&REST G1410 &AUX |optional| LIST |pred|)
  (DSETQ (|pred| LIST . |optional|) G1410)
  (PROG (|key|)
    (RETURN
      (COND
        ((NULL (canFuncall? |pred|))
         (|error| '|listSort: first arg must be a function|))
        ((NULL (LISTP LIST))
         (|error| '|listSort: second argument must be a list|))
        ((NULL |optional|)
         (|mergeSort| |pred| #'|Identity| LIST
             (LENGTH LIST)))
        ('T (setq |key| (CAR |optional|))
         (COND
           ((NULL (canFuncall? |key|))
            (|error| '|listSort: last arg must be a function|))
           ('T (|mergeSort| |pred| |key| LIST (LENGTH LIST)))))))))

;MSORT list == listSort(function GLESSEQP, COPY_-LIST list)

(DEFUN MSORT (LIST)
 (|listSort| #'GLESSEQP (COPY-LIST LIST))) 

;NMSORT list == listSort(function GLESSEQP, list)

(DEFUN NMSORT (LIST) (|listSort| #'GLESSEQP LIST)) 

;orderList l == listSort(function _?ORDER, COPY_-LIST l)

(DEFUN |orderList| (|l|) (|listSort| #'?ORDER (COPY-LIST |l|))) 

;mergeInPlace(f,g,p,q) ==
;   if NULL p then return p
;   if NULL q then return q
;   if FUNCALL(f,FUNCALL(g, QCAR p),FUNCALL(g, QCAR q))
;   then (r := t := p; p := QCDR p)
;   else (r := t := q; q := QCDR q)
;   while not NULL p and not NULL q repeat
;      if FUNCALL(f,FUNCALL(g,QCAR p),FUNCALL(g,QCAR q))
;      then (QRPLACD(t,p); t := p; p := QCDR p)
;      else (QRPLACD(t,q); t := q; q := QCDR q)
;   if NULL p then QRPLACD(t,q) else QRPLACD(t,p)
;   r

(DEFUN |mergeInPlace| (|f| |g| |p| |q|)
  (PROG (|r| |t|)
    (RETURN
      (SEQ (PROGN
             (COND ((NULL |p|) (RETURN |p|)))
             (COND ((NULL |q|) (RETURN |q|)))
             (COND
               ((FUNCALL |f| (FUNCALL |g| (QCAR |p|))
                         (FUNCALL |g| (QCAR |q|)))
                (setq |r| (setq |t| |p|))
                (setq |p| (QCDR |p|)))
               ('T (setq |r| (setq |t| |q|))
                (setq |q| (QCDR |q|))))
             (DO ()
                 ((NULL (AND (NULL (NULL |p|)) (NULL (NULL |q|)))) NIL)
               (SEQ (EXIT (COND
                            ((FUNCALL |f| (FUNCALL |g| (QCAR |p|))
                                      (FUNCALL |g| (QCAR |q|)))
                             (QRPLACD |t| |p|) (setq |t| |p|)
                             (setq |p| (QCDR |p|)))
                            ('T (QRPLACD |t| |q|) (setq |t| |q|)
                             (setq |q| (QCDR |q|)))))))
             (COND
               ((NULL |p|) (QRPLACD |t| |q|))
               ('T (QRPLACD |t| |p|)))
             |r|)))))

;mergeSort(f,g,p,n) ==
;   if EQ(n,2) and FUNCALL(f,FUNCALL(g,QCADR p),FUNCALL(g,QCAR p)) then
;      t := p
;      p := QCDR p
;      QRPLACD(p,t)
;      QRPLACD(t,NIL)
;   if QSLESSP(n,3) then return p
;   -- split the list p into p and q of equal length
;   l := QSQUOTIENT(n,2)
;   t := p
;   for i in 1..l-1 repeat t := QCDR t
;   q := rest t
;   QRPLACD(t,NIL)
;   p := mergeSort(f,g,p,l)
;   q := mergeSort(f,g,q,QSDIFFERENCE(n,l))
;   mergeInPlace(f,g,p,q)

(DEFUN |mergeSort| (|f| |g| |p| |n|)
  (PROG (|l| |t| |q|)
    (RETURN
      (SEQ (PROGN
             (COND
               ((AND (EQ |n| 2)
                     (FUNCALL |f| (FUNCALL |g| (QCADR |p|))
                              (FUNCALL |g| (QCAR |p|))))
                (setq |t| |p|) (setq |p| (QCDR |p|))
                (QRPLACD |p| |t|) (QRPLACD |t| NIL)))
             (COND ((QSLESSP |n| 3) (RETURN |p|)))
             (setq |l| (QSQUOTIENT |n| 2))
             (setq |t| |p|)
             (DO ((G1411 (- |l| 1))
                  (|i| 1 (QSADD1 |i|)))
                 ((QSGREATERP |i| G1411) NIL)
               (SEQ (EXIT (setq |t| (QCDR |t|)))))
             (setq |q| (CDR |t|))
             (QRPLACD |t| NIL)
             (setq |p| (|mergeSort| |f| |g| |p| |l|))
             (setq |q|
                      (|mergeSort| |f| |g| |q| (QSDIFFERENCE |n| |l|)))
             (|mergeInPlace| |f| |g| |p| |q|))))))

;spadThrow() ==
;  if $interpOnly and $mapName then
;    putHist($mapName,'localModemap, nil, $e)
;  THROW("SPAD__READER",nil)

(DEFUN |spadThrow| ()
  (DECLARE (SPECIAL |$e| |$mapName| |$interpOnly|))
  (PROGN
    (COND
      ((AND |$interpOnly| |$mapName|)
       (|putHist| |$mapName| '|localModemap| NIL |$e|)))
    (THROW 'SPAD_READER NIL)))

;spadThrowBrightly x ==
;  sayBrightly x
;  spadThrow()

(DEFUN |spadThrowBrightly| (|x|) (PROGN (|sayBrightly| |x|) (|spadThrow|))) 

;formatUnabbreviatedSig sig ==
;  null sig => ["() -> ()"]
;  [target,:args] := sig
;  target := formatUnabbreviated target
;  null args => ['"() -> ",:target]
;  null rest args => [:formatUnabbreviated QCAR args,'" -> ",:target]
;  args := formatUnabbreviatedTuple args
;  ['"(",:args,'") -> ",:target]

(DEFUN |formatUnabbreviatedSig| (|sig|)
  (PROG (|target| |args|)
    (RETURN
      (COND
        ((NULL |sig|) (CONS '|() -> ()| NIL))
        ('T (setq |target| (CAR |sig|)) (setq |args| (CDR |sig|))
         (setq |target| (|formatUnabbreviated| |target|))
         (COND
           ((NULL |args|) (CONS "() -> " |target|))
           ((NULL (CDR |args|))
            (APPEND (|formatUnabbreviated| (QCAR |args|))
                    (CONS " -> " |target|)))
           ('T (setq |args| (|formatUnabbreviatedTuple| |args|))
            (CONS "("
                  (APPEND |args| (CONS ") -> " |target|))))))))))

;formatUnabbreviatedTuple t ==
;  -- t is a list of types
;  null t => t
;  atom t => [t]
;  t0 := formatUnabbreviated QCAR t
;  null rest t => t0
;  [:t0,'",",:formatUnabbreviatedTuple QCDR t]

;;;     ***       |formatUnabbreviatedTuple| REDEFINED

(DEFUN |formatUnabbreviatedTuple| (|t|)
  (PROG (|t0|)
    (RETURN
      (COND
        ((NULL |t|) |t|)
        ((ATOM |t|) (CONS |t| NIL))
        ('T (setq |t0| (|formatUnabbreviated| (QCAR |t|)))
         (COND
           ((NULL (CDR |t|)) |t0|)
           ('T
            (APPEND |t0|
                    (CONS "," (|formatUnabbreviatedTuple| (QCDR |t|)))))))))))

;formatUnabbreviated t ==
;  atom t =>
;    [t]
;  null t =>
;    ['"()"]
;  t is [p,sel,arg] and p in '(_: ":") =>
;    [sel,'": ",:formatUnabbreviated arg]
;  t is ['Union,:args] =>
;    ['Union,'"(",:formatUnabbreviatedTuple args,'")"]
;  t is ['Mapping,:args] =>
;    formatUnabbreviatedSig args
;  t is ['Record,:args] =>
;    ['Record,'"(",:formatUnabbreviatedTuple args,'")"]
;  t is [arg] =>
;    t
;  t is [arg,arg1] =>
;    [arg,'" ",:formatUnabbreviated arg1]
;  t is [arg,:args] =>
;    [arg,'"(",:formatUnabbreviatedTuple args,'")"]
;  t

(DEFUN |formatUnabbreviated| (|t|)
  (PROG (|p| |sel| |ISTMP#2| |ISTMP#1| |arg1| |arg| |args|)
    (RETURN
      (COND
        ((ATOM |t|) (CONS |t| NIL))
        ((NULL |t|) (CONS "()" NIL))
        ((AND (CONSP |t|)
              (PROGN
                (setq |p| (QCAR |t|))
                (setq |ISTMP#1| (QCDR |t|))
                (AND (CONSP |ISTMP#1|)
                     (PROGN
                       (setq |sel| (QCAR |ISTMP#1|))
                       (setq |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (CONSP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)
                            (PROGN
                              (setq |arg| (QCAR |ISTMP#2|))
                              'T)))))
              (|member| |p| '(|:| ":")))
         (CONS |sel|
               (CONS ": " (|formatUnabbreviated| |arg|))))
        ((AND (CONSP |t|) (EQ (QCAR |t|) '|Union|)
              (PROGN (setq |args| (QCDR |t|)) 'T))
         (CONS '|Union|
               (CONS "("
                     (APPEND (|formatUnabbreviatedTuple| |args|)
                             (CONS ")" NIL)))))
        ((AND (CONSP |t|) (EQ (QCAR |t|) '|Mapping|)
              (PROGN (setq |args| (QCDR |t|)) 'T))
         (|formatUnabbreviatedSig| |args|))
        ((AND (CONSP |t|) (EQ (QCAR |t|) '|Record|)
              (PROGN (setq |args| (QCDR |t|)) 'T))
         (CONS '|Record|
               (CONS "("
                     (APPEND (|formatUnabbreviatedTuple| |args|)
                             (CONS ")" NIL)))))
        ((AND (CONSP |t|) (EQ (QCDR |t|) NIL)
              (PROGN (setq |arg| (QCAR |t|)) 'T))
         |t|)
        ((AND (CONSP |t|)
              (PROGN
                (setq |arg| (QCAR |t|))
                (setq |ISTMP#1| (QCDR |t|))
                (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                     (PROGN (setq |arg1| (QCAR |ISTMP#1|)) 'T))))
         (CONS |arg|
               (CONS " " (|formatUnabbreviated| |arg1|))))
        ((AND (CONSP |t|)
              (PROGN
                (setq |arg| (QCAR |t|))
                (setq |args| (QCDR |t|))
                'T))
         (CONS |arg|
               (CONS "("
                     (APPEND (|formatUnabbreviatedTuple| |args|)
                             (CONS ")" NIL)))))
        ('T |t|)))))

;sublisNQ(al,e) ==
;  atom al => e
;  fn(al,e) where fn(al,e) ==
;    atom e =>
;      for x in al repeat
;        EQ(first x,e) => return (e := rest x)
;      e
;    EQ(a := first e,'QUOTE) => e
;    u := fn(al,a)
;    v := fn(al,rest e)
;    EQ(a,u) and EQ(rest e,v) => e
;    [u,:v]

(DEFUN |sublisNQ,fn| (|al| |e|)
  (PROG (|a| |u| |v|)
    (RETURN
      (SEQ (IF (ATOM |e|)
               (EXIT (SEQ (DO ((G1412 |al| (CDR G1412)) (|x| NIL))
                              ((OR (ATOM G1412)
                                   (PROGN
                                     (SETQ |x| (CAR G1412))
                                     NIL))
                               NIL)
                            (SEQ (EXIT (IF (EQ (CAR |x|) |e|)
                                        (EXIT
                                         (RETURN
                                           (setq |e| (CDR |x|))))))))
                          (EXIT |e|))))
           (IF (EQ (setq |a| (CAR |e|)) 'QUOTE) (EXIT |e|))
           (setq |u| (|sublisNQ,fn| |al| |a|))
           (setq |v| (|sublisNQ,fn| |al| (CDR |e|)))
           (IF (AND (EQ |a| |u|) (EQ (CDR |e|) |v|)) (EXIT |e|))
           (EXIT (CONS |u| |v|))))))

(DEFUN |sublisNQ| (|al| |e|)
  (COND ((ATOM |al|) |e|) ('T (|sublisNQ,fn| |al| |e|))))

;str2Outform s ==
;  parse := ncParseFromString s or systemError '"String for TeX will not parse"
;  parse2Outform parse

(DEFUN |str2Outform| (|s|)
  (PROG (|parse|)
    (RETURN
      (PROGN
        (setq |parse|
                 (OR (|ncParseFromString| |s|)
                     (|systemError|
                         "String for TeX will not parse")))
        (|parse2Outform| |parse|)))))

;parse2Outform x ==
;  x is [op,:argl] =>
;    nargl := [parse2Outform y for y in argl]
;    op = 'construct => ['BRACKET,['ARGLST,:[parse2Outform y for y in argl]]]
;    op = 'brace and nargl is [[BRACKET,:r]] => ['BRACE,:r]
;    [op,:nargl]
;  x

(DEFUN |parse2Outform| (|x|)
  (PROG (|op| |argl| |nargl| |ISTMP#1| BRACKET |r|)
    (RETURN
      (SEQ (COND
             ((AND (CONSP |x|)
                   (PROGN
                     (setq |op| (QCAR |x|))
                     (setq |argl| (QCDR |x|))
                     'T))
              (setq |nargl|
                       (PROG (G1413)
                         (setq G1413 NIL)
                         (RETURN
                           (DO ((G1414 |argl| (CDR G1414))
                                (|y| NIL))
                               ((OR (ATOM G1414)
                                    (PROGN
                                      (SETQ |y| (CAR G1414))
                                      NIL))
                                (NREVERSE0 G1413))
                             (SEQ (EXIT (SETQ G1413
                                         (CONS (|parse2Outform| |y|)
                                          G1413))))))))
              (COND
                ((BOOT-EQUAL |op| '|construct|)
                 (CONS 'BRACKET
                       (CONS (CONS 'ARGLST
                                   (PROG (G1415)
                                     (setq G1415 NIL)
                                     (RETURN
                                       (DO
                                        ((G1416 |argl| (CDR G1416))
                                         (|y| NIL))
                                        ((OR (ATOM G1416)
                                          (PROGN
                                            (SETQ |y| (CAR G1416))
                                            NIL))
                                         (NREVERSE0 G1415))
                                         (SEQ
                                          (EXIT
                                           (SETQ G1415
                                            (CONS (|parse2Outform| |y|)
                                             G1415))))))))
                             NIL)))
                ((AND (BOOT-EQUAL |op| '|brace|) (CONSP |nargl|)
                      (EQ (QCDR |nargl|) NIL)
                      (PROGN
                        (setq |ISTMP#1| (QCAR |nargl|))
                        (AND (CONSP |ISTMP#1|)
                             (PROGN
                               (setq BRACKET (QCAR |ISTMP#1|))
                               (setq |r| (QCDR |ISTMP#1|))
                               'T))))
                 (CONS 'BRACE |r|))
                ('T (CONS |op| |nargl|))))
             ('T |x|))))))

;str2Tex s ==
;  outf := str2Outform s
;  val := coerceInt(mkObj(wrap outf, '(OutputForm)), '(TexFormat))
;  val := objValUnwrap val
;  CAR val.1

(DEFUN |str2Tex| (|s|)
  (PROG (|outf| |val|)
    (RETURN
      (PROGN
        (setq |outf| (|str2Outform| |s|))
        (setq |val|
                 (|coerceInt| (mkObj (|wrap| |outf|) '(|OutputForm|))
                     '(|TexFormat|)))
        (setq |val| (|objValUnwrap| |val|))
        (CAR (ELT |val| 1))))))

;opOf x ==
;  atom x => x
;  first x

(DEFUN |opOf| (|x|) (COND ((ATOM |x|) |x|) ('T (CAR |x|))))


;augProplist(proplist,prop,val) ==
;  $InteractiveMode => augProplistInteractive(proplist,prop,val)
;  while (proplist is [[ =prop,:.],:proplist']) repeat proplist:= proplist'
;  val=(u:= LASSOC(prop,proplist)) => proplist
;  null val =>
;    null u => proplist
;    DELLASOS(prop,proplist)
;  [[prop,:val],:proplist]

(DEFUN |augProplist| (|proplist| |prop| |val|)
  (PROG (|ISTMP#1| |proplist'| |u|)
    (DECLARE (SPECIAL |$InteractiveMode|))
    (RETURN
      (SEQ (COND
             (|$InteractiveMode|
                 (|augProplistInteractive| |proplist| |prop| |val|))
             ('T
              (DO ()
                  ((NULL (AND (CONSP |proplist|)
                              (PROGN
                                (setq |ISTMP#1| (QCAR |proplist|))
                                (AND (CONSP |ISTMP#1|)
                                     (EQUAL (QCAR |ISTMP#1|) |prop|)))
                              (PROGN
                                (setq |proplist'| (QCDR |proplist|))
                                'T)))
                   NIL)
                (SEQ (EXIT (setq |proplist| |proplist'|))))
              (COND
                ((BOOT-EQUAL |val|
                     (setq |u| (LASSOC |prop| |proplist|)))
                 |proplist|)
                ((NULL |val|)
                 (COND
                   ((NULL |u|) |proplist|)
                   ('T (DELLASOS |prop| |proplist|))))
                ('T (CONS (CONS |prop| |val|) |proplist|)))))))))

;augProplistOf(var,prop,val,e) ==
;  proplist:= getProplist(var,e)
;  semchkProplist(var,proplist,prop,val)
;  augProplist(proplist,prop,val)

(DEFUN |augProplistOf| (|var| |prop| |val| |e|)
  (PROG (|proplist|)
    (RETURN
      (PROGN
        (setq |proplist| (|getProplist| |var| |e|))
        (|semchkProplist| |var| |proplist| |prop| |val|)
        (|augProplist| |proplist| |prop| |val|)))))

;semchkProplist(x,proplist,prop,val) ==
;  prop="isLiteral" =>
;    LASSOC("value",proplist) or LASSOC("mode",proplist) => warnLiteral x
;  MEMQ(prop,'(mode value)) =>
;    LASSOC("isLiteral",proplist) => warnLiteral x

;;;     ***       |semchkProplist| REDEFINED

(DEFUN |semchkProplist| (|x| |proplist| |prop| |val|)
  (declare (special |val|))
  (SEQ (COND
         ((BOOT-EQUAL |prop| '|isLiteral|)
          (COND
            ((OR (LASSOC '|value| |proplist|)
                 (LASSOC '|mode| |proplist|))
             (EXIT (|warnLiteral| |x|)))))
         ((member |prop| '(|mode| |value|))
          (COND
            ((LASSOC '|isLiteral| |proplist|)
             (EXIT (|warnLiteral| |x|))))))))


;;;     ***       |addBinding| REDEFINED

;position(x,l) ==
;  posn(x,l,0) where
;    posn(x,l,n) ==
;      null l => -1
;      x=first l => n
;      posn(x,rest l,n+1)

(DEFUN |position,posn| (|x| |l| |n|)
  (SEQ (IF (NULL |l|) (EXIT (- 1)))
       (IF (BOOT-EQUAL |x| (CAR |l|)) (EXIT |n|))
       (EXIT (|position,posn| |x| (CDR |l|) (+ |n| 1)))))

(DEFUN |position| (|x| |l|) (|position,posn| |x| |l| 0)) 

;insert(x,y) ==
;  MEMBER(x,y) => y
;  [x,:y]

(DEFUN |insert| (|x| |y|)
  (COND ((|member| |x| |y|) |y|) ('T (CONS |x| |y|))))

;after(u,v) ==
;  r:= u
;  for x in u for y in v repeat r:= rest r
;  r

(DEFUN |after| (|u| |v|)
  (PROG (|r|)
    (RETURN
      (SEQ (PROGN
             (setq |r| |u|)
             (DO ((G1421 |u| (CDR G1421)) (|x| NIL)
                  (G1422 |v| (CDR G1422)) (|y| NIL))
                 ((OR (ATOM G1421)
                      (PROGN (SETQ |x| (CAR G1421)) NIL)
                      (ATOM G1422)
                      (PROGN (SETQ |y| (CAR G1422)) NIL))
                  NIL)
               (SEQ (EXIT (setq |r| (CDR |r|)))))
             |r|)))))

;trimString s ==
;  leftTrim rightTrim s

(DEFUN |trimString| (|s|) (|leftTrim| (|rightTrim| |s|)))

;leftTrim s ==
;  k := MAXINDEX s
;  k < 0 => s
;  s.0 = $blank =>
;    for i in 0..k while s.i = $blank repeat (j := i)
;    SUBSTRING(s,j + 1,nil)
;  s

(DEFUN |leftTrim| (|s|)
  (PROG (|k| |j|)
    (RETURN
      (SEQ (PROGN
             (setq |k| (MAXINDEX |s|))
             (COND
               ((MINUSP |k|) |s|)
               ((BOOT-EQUAL (ELT |s| 0) #\space)
                (DO ((|i| 0 (QSADD1 |i|)))
                    ((OR (QSGREATERP |i| |k|)
                         (NULL (BOOT-EQUAL (ELT |s| |i|) #\space)))
                     NIL)
                  (SEQ (EXIT (setq |j| |i|))))
                (SUBSTRING |s| (+ |j| 1) NIL))
               ('T |s|)))))))

;rightTrim s ==  -- assumed a non-empty string
;  k := MAXINDEX s
;  k < 0 => s
;  s.k = $blank =>
;    for i in k..0 by -1 while s.i = $blank repeat (j := i)
;    SUBSTRING(s,0,j)
;  s

(DEFUN |rightTrim| (|s|)
  (PROG (|k| |j|)
    (RETURN
      (SEQ (PROGN
             (setq |k| (MAXINDEX |s|))
             (COND
               ((MINUSP |k|) |s|)
               ((BOOT-EQUAL (ELT |s| |k|) #\space)
                (DO ((G1423 (- 1))
                     (|i| |k| (+ |i| G1423)))
                    ((OR (IF (MINUSP G1423) (< |i| 0) (> |i| 0))
                         (NULL (BOOT-EQUAL (ELT |s| |i|) #\space)))
                     NIL)
                  (SEQ (EXIT (setq |j| |i|))))
                (SUBSTRING |s| 0 |j|))
               ('T |s|)))))))

;pp x ==
;  PRETTYPRINT x
;  x

(DEFUN |pp| (|x|) (PROGN (PRETTYPRINT |x|) |x|)) 

;pr x ==
;  F_,PRINT_-ONE x
;  nil

(DEFUN |pr| (|x|) (PROGN (|F,PRINT-ONE| |x|) NIL)) 

;quickAnd(a,b) ==
;  a = true => b
;  b = true => a
;  a = false or b = false => false
;  simpBool ['AND,a,b]

(DEFUN |quickAnd| (|a| |b|)
  (COND
    ((BOOT-EQUAL |a| 'T) |b|)
    ((BOOT-EQUAL |b| 'T) |a|)
    ((OR (NULL |a|) (NULL |b|)) NIL)
    ('T (|simpBool| (CONS 'AND (CONS |a| (CONS |b| NIL)))))))

;quickOr(a,b) ==
;  a = true or b = true => true
;  b = false => a
;  a = false => b
;  simpCatPredicate simpBool ['OR,a,b]

(DEFUN |quickOr| (|a| |b|)
  (COND
    ((OR (BOOT-EQUAL |a| 'T) (BOOT-EQUAL |b| 'T)) 'T)
    ((NULL |b|) |a|)
    ((NULL |a|) |b|)
    ('T
     (|simpCatPredicate|
         (|simpBool| (CONS 'OR (CONS |a| (CONS |b| NIL))))))))

;intern x ==
;  STRINGP x =>
;    DIGITP x.0 => string2Integer x
;    INTERN x
;  x

(DEFUN |intern| (|x|)
  (COND
    ((STRINGP |x|)
     (COND
       ((DIGITP (ELT |x| 0)) (|string2Integer| |x|))
       ('T (INTERN |x|))))
    ('T |x|)))

;$htHash      := MAKE_-HASH_-TABLE()

(setq |$htHash| (MAKE-HASH-TABLE)) 

;$glossHash   := MAKE_-HASH_-TABLE()

(setq |$glossHash| (MAKE-HASH-TABLE)) 

;$lispHash    := MAKE_-HASH_-TABLE()

(setq |$lispHash| (MAKE-HASH-TABLE)) 

;$sysHash     := MAKE_-HASH_-TABLE()

(setq |$sysHash| (MAKE-HASH-TABLE)) 

(defvar |$htSystemCommands|
         '(|clear| |display|
           (|fin| . |development|) |edit| |help| |frame| |history|
           |load| |quit| |read| |set| |show| |synonym| |system| |trace|
           |what|))

;$currentSysList := [opOf x for x in $htSystemCommands] --see ht-root

(setq |$currentSysList|
  (COLLECT (IN |x| |$htSystemCommands|) (|opOf| |x|))) 

;$outStream   := nil

(setq |$outStream| NIL) 

;$recheckingFlag    := false     --see transformAndRecheckComments

(setq |$recheckingFlag| NIL) 

;$exposeFlag        := false     --if true, messages go to $outStream

(setq |$exposeFlag| NIL) 

;$exposeFlagHeading := false     --see htcheck.boot

(setq |$exposeFlagHeading| NIL) 

;$checkingXmptex? := false       --see htcheck.boot

(setq |$checkingXmptex?| NIL) 

;$exposeDocHeading:= nil         --see htcheck.boot

(setq |$exposeDocHeading| NIL) 

;$charFauxNewline    := CODE_-CHAR(25)

(setq |$charFauxNewline| (CODE-CHAR 25)) 

;$stringFauxNewline  := PNAME CODE_-CHAR(25)

(setq |$stringFauxNewline| (PNAME (CODE-CHAR 25))) 

;$charExclusions := [char 'a, char 'A]

(setq |$charExclusions| (CONS #\a (CONS #\A NIL)))

;$checkPrenAlist := [[char '_(,:char '_)],[char '_{,:char '_}],[char '_[,:char '_]]]

(setq |$checkPrenAlist|
         (CONS (CONS #\( #\) )
               (CONS (CONS #\{ #\} )
                     (CONS (CONS #\[ #\] ) NIL))))

;$charEscapeList:= [char '_%,char '_#,$charBack]

(setq |$charEscapeList|
         (CONS #\% (CONS #\# (CONS #\\ NIL))))

;$charIdentifierEndings := [char '__, char '_!, char '_?]

(setq |$charIdentifierEndings|
         (CONS #\_ (CONS #\! (CONS #\? NIL))))

;$charSplitList := [$charComma,$charPeriod,char '_[, char '_],$charLbrace, $charRbrace, char '_(, char '_), char '_$, char '_%]

(setq |$charSplitList|
         (CONS #\,
               (CONS #\.
                     (CONS #\[
                           (CONS #\]
                                 (CONS #\{
                                       (CONS #\}
                                        (CONS #\(
                                         (CONS #\)
                                          (CONS #\$
                                           (CONS #\% NIL)))))))))))

;$charDelimiters := [$charBlank, char '_(, char '_), $charBack]

(setq |$charDelimiters|
         (CONS #\space
               (CONS #\(
                     (CONS #\) (CONS #\\ NIL)))))

;$HTspadmacros := '("\spadtype" "\spadcommand" "\spadop" "\spadfun" "\spadatt" "\spadsyscom" "\spad" "\s")

(setq |$HTspadmacros|
         '("\\spadtype" "\\spadcommand" "\\spadop" "\\spadfun"
           "\\spadatt" "\\spadsyscom" "\\spad" "\\s"))

;$HTmacs := [
;  ['"\beginmenu",$charRbrace,'"menu",$charLbrace,'"\begin"],
;   ['"\endmenu",$charRbrace,'"menu",$charLbrace,'"\end"],
;     ['"\beginitems",$charRbrace,'"items",$charLbrace,'"\begin"],
;       ['"\enditems",$charRbrace,'"items",$charLbrace,'"\end"],
;         ['"\beginscroll",$charRbrace,'"scroll",$charLbrace,'"\begin"],
;           ['"\endscroll",$charRbrace,'"scroll",$charLbrace,'"\end"]]

(setq |$HTmacs|
         (CONS (CONS "\\beginmenu"
                     (CONS #\}
                           (CONS "menu"
                                 (CONS #\{
                                       (CONS "\\begin"
                                        NIL)))))
               (CONS (CONS "\\endmenu"
                           (CONS #\}
                                 (CONS "menu"
                                       (CONS #\{
                                        (CONS "\\end" NIL)))))
                     (CONS (CONS "\\beginitems"
                                 (CONS #\}
                                       (CONS "items"
                                        (CONS #\{
                                         (CONS "\\begin"
                                          NIL)))))
                           (CONS (CONS "\\enditems"
                                       (CONS #\}
                                        (CONS "items"
                                         (CONS #\{
                                          (CONS "\\end"
                                           NIL)))))
                                 (CONS (CONS
                                        "\\beginscroll"
                                        (CONS #\}
                                         (CONS "scroll"
                                          (CONS #\{
                                           (CONS "\\begin"
                                            NIL)))))
                                       (CONS
                                        (CONS
                                         "\\endscroll"
                                         (CONS #\}
                                          (CONS "scroll"
                                           (CONS #\{
                                            (CONS "\\end"
                                             NIL)))))
                                        NIL)))))))

;$HTlinks := '(
;  "\downlink"
;  "\menulink"
;  "\menudownlink"
;  "\menuwindowlink"
;  "\menumemolink")

(setq |$HTlinks|
         '("\\downlink" "\\menulink" "\\menudownlink"
           "\\menuwindowlink" "\\menumemolink"))

;$HTlisplinks := '(
;  "\lispdownlink"
;  "\menulispdownlink"
;  "\menulispwindowlink"
;  "\menulispmemolink"
;  "\lispwindowlink"
;  "\lispmemolink")

(setq |$HTlisplinks|
         '("\\lispdownlink" "\\menulispdownlink" "\\menulispwindowlink"
           "\\menulispmemolink" "\\lispwindowlink" "\\lispmemolink"))

;$beginEndList := '(
;  "page"
;  "items"
;  "menu"
;  "scroll"
;  "verbatim"
;  "detail")

(setq |$beginEndList|
         '("page" "items" "menu" "scroll" "verbatim" "detail"))

;isDefaultPackageName x == (s := PNAME x).(MAXINDEX s) = char '_&

(DEFUN |isDefaultPackageName| (|x|)
  (PROG (|s|)
    (RETURN
      (BOOT-EQUAL (ELT (setq |s| (PNAME |x|)) (MAXINDEX |s|))
          #\&))))


\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
