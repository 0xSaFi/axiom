\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp apply.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{chunk}{*}

(in-package "BOOT" )

;transImplementation(op,map,fn) ==
;--+
;  fn := genDeltaEntry [op,:map]
;  fn is ["XLAM",:.] => [fn]
;  ["call",fn]

(DEFUN |transImplementation| (OP MAP FN)
  (SETQ FN (|genDeltaEntry| (CONS OP MAP)))
  (COND
    ((AND (CONSP FN) (EQ (QCAR FN) 'XLAM)) (CONS FN NIL))
    (T (CONS '|call| (CONS FN NIL)))))

;compApplication(op,argl,m,e,T) ==
;  T.mode is ['Mapping, retm, :argml] =>
;    #argl ^= #argml => nil
;    retm := resolve(m, retm)
;    retm = $Category or isCategoryForm(retm,e) => nil  -- not handled
;    argTl := [[.,.,e] := comp(x,m,e) or return "failed"
;              for x in argl for m in argml]
;    argTl = "failed" => nil
;    form:=
;      not (MEMBER(op,$formalArgList) or MEMBER(T.expr,$formalArgList)) and ATOM T.expr =>
;        nprefix := $prefix or
;        -- following needed for referencing local funs at capsule level
;           getAbbreviation($op,#rest $form)
;        [op',:[a.expr for a in argTl],"$"] where
;          op':= INTERN STRCONC(encodeItem nprefix,";",encodeItem T.expr)
;      ['call, ['applyFun, T.expr], :[a.expr for a in argTl]]
;    coerce([form, retm, e],resolve(retm,m))
;  op = 'elt => nil
;  eltForm := ['elt, op, :argl]
;  comp(eltForm, m, e)

(DEFUN |compApplication| (|op| |argl| |m| |e| T$)
  (PROG (TMP1 TMP2 |argml| |retm| TEMP1 |argTl| |nprefix| |op'| |form|
              |eltForm|)
  (declare (special |$form| |$op| |$prefix| |$formalArgList| |$Category|))
    (RETURN
      (SEQ (COND
             ((PROGN
                (SETQ TMP1 (CADR T$))
                (AND (CONSP TMP1) (EQ (QCAR TMP1) '|Mapping|)
                     (PROGN
                       (SETQ TMP2 (QCDR TMP1))
                       (AND (CONSP TMP2)
                            (PROGN
                              (SETQ |retm| (QCAR TMP2))
                              (SETQ |argml| (QCDR TMP2))
                              T)))))
              (COND
                ((NEQUAL (|#| |argl|) (|#| |argml|)) NIL)
                (T (SETQ |retm| (|resolve| |m| |retm|))
                   (COND
                     ((OR (BOOT-EQUAL |retm| |$Category|)
                          (|isCategoryForm| |retm| |e|))
                      NIL)
                     (T (SETQ |argTl|
                              (PROG (T0)
                                (SETQ T0 NIL)
                                (RETURN
                                  (DO ((T1 |argl| (CDR T1)) (|x| NIL)
                                       (T2 |argml| (CDR T2)) (|m| NIL))
                                      ((OR (ATOM T1)
                                        (PROGN
                                          (SETQ |x| (CAR T1))
                                          NIL)
                                        (ATOM T2)
                                        (PROGN
                                          (SETQ |m| (CAR T2))
                                          NIL))
                                       (NREVERSE0 T0))
                                    (SEQ
                                     (EXIT
                                      (SETQ T0
                                       (CONS
                                        (PROGN
                                          (SETQ TEMP1
                                           (OR (|comp| |x| |m| |e|)
                                            (RETURN '|failed|)))
                                          (SETQ |e| (CADDR TEMP1))
                                          TEMP1)
                                        T0))))))))
                        (COND
                          ((BOOT-EQUAL |argTl| '|failed|) NIL)
                          (T (SETQ |form|
                                   (COND
                                     ((AND
                                       (NULL
                                        (OR
                                         (|member| |op|
                                          |$formalArgList|)
                                         (|member| (CAR T$)
                                          |$formalArgList|)))
                                       (ATOM (CAR T$)))
                                      (SETQ |nprefix|
                                       (OR |$prefix|
                                        (|getAbbreviation| |$op|
                                         (|#| (CDR |$form|)))))
                                      (SETQ |op'|
                                       (INTERN
                                        (STRCONC
                                         (|encodeItem| |nprefix|) '|;|
                                         (|encodeItem| (CAR T$)))))
                                      (CONS |op'|
                                       (APPEND
                                        (PROG (T3)
                                          (SETQ T3 NIL)
                                          (RETURN
                                            (DO
                                             ((T4 |argTl| (CDR T4))
                                              (|a| NIL))
                                             ((OR (ATOM T4)
                                               (PROGN
                                                 (SETQ |a| (CAR T4))
                                                 NIL))
                                              (NREVERSE0 T3))
                                              (SEQ
                                               (EXIT
                                                (SETQ T3
                                                 (CONS (CAR |a|) T3)))))))
                                        (CONS '$ NIL))))
                                     (T
                                      (CONS '|call|
                                       (CONS
                                        (CONS '|applyFun|
                                         (CONS (CAR T$) NIL))
                                        (PROG (T5)
                                          (SETQ T5 NIL)
                                          (RETURN
                                            (DO
                                             ((T6 |argTl| (CDR T6))
                                              (|a| NIL))
                                             ((OR (ATOM T6)
                                               (PROGN
                                                 (SETQ |a| (CAR T6))
                                                 NIL))
                                              (NREVERSE0 T5))
                                              (SEQ
                                               (EXIT
                                                (SETQ T5
                                                 (CONS (CAR |a|) T5))))))))))))
                             (|coerce|
                                 (CONS |form|
                                       (CONS |retm| (CONS |e| NIL)))
                                 (|resolve| |retm| |m|)))))))))
             ((BOOT-EQUAL |op| '|elt|) NIL)
             (T (SETQ |eltForm| (CONS '|elt| (CONS |op| |argl|)))
                (|comp| |eltForm| |m| |e|)))))))

;compFormWithModemap(form is [op,:argl],m,e,modemap) ==
;  [map:= [.,target,:.],[pred,impl]]:= modemap
;  -- this fails if the subsuming modemap is conditional
;  --impl is ['Subsumed,:.] => nil
;  if isCategoryForm(target,e) and isFunctor op then
;    [modemap,e]:= substituteIntoFunctorModemap(argl,modemap,e) or return nil
;    [map:= [.,target,:.],:cexpr]:= modemap
;  sv:=listOfSharpVars map
;  if sv then
;     -- SAY [ "compiling ", op, " in compFormWithModemap,
;     -- mode= ",map," sharp vars=",sv]
;    for x in argl for ss in $FormalMapVariableList repeat
;      if ss in sv then
;        [map:= [.,target,:.],:cexpr]:= modemap :=SUBST(x,ss,modemap)
;        -- SAY ["new map is",map]
;  not (target':= coerceable(target,m,e)) => nil
;  map:= [target',:rest map]
;  [f,Tl,sl]:= compApplyModemap(form,modemap,e,nil) or return nil
;  --generate code; return
;  T:=
;    [x',m',e'] where
;      m':= SUBLIS(sl,map.(1))
;      x':=
;        form':= [f,:[t.expr for t in Tl]]
;        m'=$Category or isCategoryForm(m',e) => form'
;        -- try to deal with new-style Unions where we know the conditions
;        op = "elt" and f is ['XLAM,:.] and IDENTP(z:=CAR argl) and
;          (c:=get(z,'condition,e)) and
;            c is [['case,=z,c1]] and
;              (c1 is ['_:,=(CADR argl),=m] or EQ(c1,CADR argl) ) =>
;-- first is a full tag, as placed by getInverseEnvironment
;-- second is what getSuccessEnvironment will place there
;                ["CDR",z]
;        ["call",:form']
;      e':=
;        Tl => (LAST Tl).env
;        e
;  convert(T,m)

(DEFUN |compFormWithModemap| (|form| |m| |e| |modemap|)
  (PROG (|op| |argl| |pred| |impl| |sv| |target| |cexpr| |target'|
              |map| TEMP1 |f| TRANSIMP |sl| |m'| |form'| |z| |c| TMP3
              |c1| TMP1 TMP2 |x'| |e'| T$)
  (declare (special |$Category| |$FormalMapVariableList|))
    (RETURN
      (SEQ (PROGN
             (SETQ |op| (CAR |form|))
             (SETQ |argl| (CDR |form|))
             (SETQ |map| (CAR |modemap|))
             (SETQ |target| (CADAR |modemap|))
             (SETQ |pred| (CAADR |modemap|))
             (SETQ |impl| (CADADR |modemap|))
             (COND
               ((AND (|isCategoryForm| |target| |e|)
                     (|isFunctor| |op|))
                (SETQ TEMP1
                      (OR (|substituteIntoFunctorModemap| |argl|
                              |modemap| |e|)
                          (RETURN NIL)))
                (SETQ |modemap| (CAR TEMP1)) (SETQ |e| (CADR TEMP1))
                (SETQ |map| (CAR |modemap|))
                (SETQ |target| (CADAR |modemap|))
                (SETQ |cexpr| (CDR |modemap|)) |modemap|))
             (SETQ |sv| (|listOfSharpVars| |map|))
             (COND
               (|sv| (DO ((T0 |argl| (CDR T0)) (|x| NIL)
                          (T1 |$FormalMapVariableList| (CDR T1))
                          (|ss| NIL))
                         ((OR (ATOM T0) (PROGN (SETQ |x| (CAR T0)) NIL)
                              (ATOM T1)
                              (PROGN (SETQ |ss| (CAR T1)) NIL))
                          NIL)
                       (SEQ (EXIT (COND
                                    ((|member| |ss| |sv|)
                                     (SETQ |modemap|
                                      (MSUBST |x| |ss| |modemap|))
                                     (SETQ |map| (CAR |modemap|))
                                     (SETQ |target| (CADAR |modemap|))
                                     (SETQ |cexpr| (CDR |modemap|))
                                     |modemap|)
                                    (T NIL)))))))
             (COND
               ((NULL (SETQ |target'| (|coerceable| |target| |m| |e|)))
                NIL)
               (T (SETQ |map| (CONS |target'| (CDR |map|)))
                  (SETQ TEMP1
                        (OR (|compApplyModemap| |form| |modemap| |e|
                                NIL)
                            (RETURN NIL)))
                  (SETQ |f| (CAR TEMP1)) (SETQ TRANSIMP (CADR TEMP1))
                  (SETQ |sl| (CADDR TEMP1))
                  (SETQ |m'| (SUBLIS |sl| (ELT |map| 1)))
                  (SETQ |x'|
                        (PROGN
                          (SETQ |form'|
                                (CONS |f|
                                      (PROG (T2)
                                        (SETQ T2 NIL)
                                        (RETURN
                                          (DO
                                           ((T3 TRANSIMP (CDR T3))
                                            (|t| NIL))
                                           ((OR (ATOM T3)
                                             (PROGN
                                               (SETQ |t| (CAR T3))
                                               NIL))
                                            (NREVERSE0 T2))
                                            (SEQ
                                             (EXIT
                                              (SETQ T2
                                               (CONS (CAR |t|) T2)))))))))
                          (COND
                            ((OR (BOOT-EQUAL |m'| |$Category|)
                                 (|isCategoryForm| |m'| |e|))
                             |form'|)
                            ((AND (BOOT-EQUAL |op| '|elt|) (CONSP |f|)
                                  (EQ (QCAR |f|) 'XLAM)
                                  (IDENTP (SETQ |z| (CAR |argl|)))
                                  (SETQ |c|
                                        (|get| |z| '|condition| |e|))
                                  (CONSP |c|) (EQ (QCDR |c|) NIL)
                                  (PROGN
                                    (SETQ TMP1 (QCAR |c|))
                                    (AND (CONSP TMP1)
                                     (EQ (QCAR TMP1) '|case|)
                                     (PROGN
                                       (SETQ TMP2 (QCDR TMP1))
                                       (AND (CONSP TMP2)
                                        (EQUAL (QCAR TMP2) |z|)
                                        (PROGN
                                          (SETQ TMP3 (QCDR TMP2))
                                          (AND (CONSP TMP3)
                                           (EQ (QCDR TMP3) NIL)
                                           (PROGN
                                             (SETQ |c1| (QCAR TMP3))
                                             T)))))))
                                  (OR (AND (CONSP |c1|)
                                       (EQ (QCAR |c1|) '|:|)
                                       (PROGN
                                         (SETQ TMP1 (QCDR |c1|))
                                         (AND (CONSP TMP1)
                                          (EQUAL (QCAR TMP1)
                                           (CADR |argl|))
                                          (PROGN
                                            (SETQ TMP2 (QCDR TMP1))
                                            (AND (CONSP TMP2)
                                             (EQ (QCDR TMP2) NIL)
                                             (EQUAL (QCAR TMP2) |m|))))))
                                      (EQ |c1| (CADR |argl|))))
                             (CONS 'CDR (CONS |z| NIL)))
                            (T (CONS '|call| |form'|)))))
                  (SETQ |e'|
                        (COND
                          (TRANSIMP (CADDR (|last| TRANSIMP)))
                          (T |e|)))
                  (SETQ T$ (CONS |x'| (CONS |m'| (CONS |e'| NIL))))
                  (|convert| T$ |m|))))))))

;substituteIntoFunctorModemap(argl,modemap is [[dc,:sig],:.],e) ==
;  #dc^=#sig =>
;    keyedSystemError("S2GE0016",['"substituteIntoFunctorModemap",
;      '"Incompatible maps"])
;  #argl=#rest sig =>
;                        --here, we actually have a functor form
;    sig:= EQSUBSTLIST(argl,rest dc,sig)
;      --make new modemap, subst. actual for formal parametersinto modemap
;    Tl:= [[.,.,e]:= compOrCroak(a,m,e) for a in argl for m in rest sig]
;    substitutionList:= [[x,:T.expr] for x in rest dc for T in Tl]
;    [SUBLIS(substitutionList,modemap),e]
;  nil

(DEFUN |substituteIntoFunctorModemap| (|argl| |modemap| |e|)
  (PROG (|dc| |sig| |LETTMP#1| |Tl| |substitutionList|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |dc| (CAAR |modemap|))
             (SPADLET |sig| (CDAR |modemap|))
             (COND
               ((NEQUAL (|#| |dc|) (|#| |sig|))
                (|keyedSystemError| 'S2GE0016
                    (CONS "substituteIntoFunctorModemap"
                          (CONS "Incompatible maps" NIL))))
               ((BOOT-EQUAL (|#| |argl|) (|#| (CDR |sig|)))
                (SPADLET |sig| (EQSUBSTLIST |argl| (CDR |dc|) |sig|))
                (SPADLET |Tl|
                         (PROG (G167960)
                           (SPADLET G167960 NIL)
                           (RETURN
                             (DO ((G167969 |argl| (CDR G167969))
                                  (|a| NIL)
                                  (G167970 (CDR |sig|)
                                      (CDR G167970))
                                  (|m| NIL))
                                 ((OR (ATOM G167969)
                                      (PROGN
                                        (SETQ |a| (CAR G167969))
                                        NIL)
                                      (ATOM G167970)
                                      (PROGN
                                        (SETQ |m| (CAR G167970))
                                        NIL))
                                  (NREVERSE0 G167960))
                               (SEQ (EXIT
                                     (SETQ G167960
                                      (CONS
                                       (PROGN
                                         (SPADLET |LETTMP#1|
                                          (|compOrCroak| |a| |m| |e|))
                                         (SPADLET |e|
                                          (CADDR |LETTMP#1|))
                                         |LETTMP#1|)
                                       G167960))))))))
                (SPADLET |substitutionList|
                         (PROG (G167984)
                           (SPADLET G167984 NIL)
                           (RETURN
                             (DO ((G167990 (CDR |dc|)
                                      (CDR G167990))
                                  (|x| NIL)
                                  (G167991 |Tl| (CDR G167991))
                                  (T$ NIL))
                                 ((OR (ATOM G167990)
                                      (PROGN
                                        (SETQ |x| (CAR G167990))
                                        NIL)
                                      (ATOM G167991)
                                      (PROGN
                                        (SETQ T$ (CAR G167991))
                                        NIL))
                                  (NREVERSE0 G167984))
                               (SEQ (EXIT
                                     (SETQ G167984
                                      (CONS (CONS |x| (CAR T$))
                                       G167984))))))))
                (CONS (SUBLIS |substitutionList| |modemap|)
                      (CONS |e| NIL)))
               ('T NIL)))))))

;applyMapping([op,:argl],m,e,ml) ==
;  #argl^=#ml-1 => nil
;  isCategoryForm(first ml,e) =>
;                                --is op a functor?
;    pairlis:= [[v,:a] for a in argl for v in $FormalMapVariableList]
;    ml' := SUBLIS(pairlis, ml)
;    argl':=
;      [T.expr for x in argl for m' in rest ml'] where
;        T() == [.,.,e]:= comp(x,m',e) or return "failed"
;    if argl'="failed" then return nil
;    form:= [op,:argl']
;    convert([form,first ml',e],m)
;  argl':=
;    [T.expr for x in argl for m' in rest ml] where
;      T() == [.,.,e]:= comp(x,m',e) or return "failed"
;  if argl'="failed" then return nil
;  form:=
;    not MEMBER(op,$formalArgList) and ATOM op and not get(op,'value,e) =>
;      nprefix := $prefix or
;   -- following needed for referencing local funs at capsule level
;        getAbbreviation($op,#rest $form)
;      [op',:argl',"$"] where
;        op':= INTERN STRCONC(encodeItem nprefix,";",encodeItem op)
;    ['call,['applyFun,op],:argl']
;  pairlis:= [[v,:a] for a in argl' for v in $FormalMapVariableList]
;  convert([form,SUBLIS(pairlis,first ml),e],m)

(DEFUN |applyMapping| (T0 |m| |e| |ml|)
  (PROG (|op| |argl| |ml'| TEMP1 |argl'| |nprefix| |op'| |form| |pairlis|)
  (declare (special |$FormalMapVariableList| |$form| |$op| |$prefix|
                    |$formalArgList|))
    (RETURN
      (SEQ (PROGN
             (SETQ |op| (CAR T0))
             (SETQ |argl| (CDR T0))
             (COND
               ((NEQUAL (|#| |argl|) (SPADDIFFERENCE (|#| |ml|) 1))
                NIL)
               ((|isCategoryForm| (CAR |ml|) |e|)
                (SETQ |pairlis|
                      (PROG (T1)
                        (SETQ T1 NIL)
                        (RETURN
                          (DO ((T2 |argl| (CDR T2)) (|a| NIL)
                               (T3 |$FormalMapVariableList| (CDR T3))
                               (|v| NIL))
                              ((OR (ATOM T2)
                                   (PROGN (SETQ |a| (CAR T2)) NIL)
                                   (ATOM T3)
                                   (PROGN (SETQ |v| (CAR T3)) NIL))
                               (NREVERSE0 T1))
                            (SEQ (EXIT (SETQ T1
                                        (CONS (CONS |v| |a|) T1))))))))
                (SETQ |ml'| (SUBLIS |pairlis| |ml|))
                (SETQ |argl'|
                      (PROG (T4)
                        (SETQ T4 NIL)
                        (RETURN
                          (DO ((T5 |argl| (CDR T5)) (|x| NIL)
                               (T6 (CDR |ml'|) (CDR T6)) (|m'| NIL))
                              ((OR (ATOM T5)
                                   (PROGN (SETQ |x| (CAR T5)) NIL)
                                   (ATOM T6)
                                   (PROGN (SETQ |m'| (CAR T6)) NIL))
                               (NREVERSE0 T4))
                            (SEQ (EXIT (SETQ T4
                                        (CONS
                                         (CAR
                                          (PROGN
                                            (SETQ TEMP1
                                             (OR (|comp| |x| |m'| |e|)
                                              (RETURN '|failed|)))
                                            (SETQ |e| (CADDR TEMP1))
                                            TEMP1))
                                         T4))))))))
                (COND ((BOOT-EQUAL |argl'| '|failed|) (RETURN NIL)))
                (SETQ |form| (CONS |op| |argl'|))
                (|convert|
                    (CONS |form| (CONS (CAR |ml'|) (CONS |e| NIL)))
                    |m|))
               (T (SETQ |argl'|
                        (PROG (T7)
                          (SETQ T7 NIL)
                          (RETURN
                            (DO ((T8 |argl| (CDR T8)) (|x| NIL)
                                 (T9 (CDR |ml|) (CDR T9)) (|m'| NIL))
                                ((OR (ATOM T8)
                                     (PROGN (SETQ |x| (CAR T8)) NIL)
                                     (ATOM T9)
                                     (PROGN (SETQ |m'| (CAR T9)) NIL))
                                 (NREVERSE0 T7))
                              (SEQ (EXIT
                                    (SETQ T7
                                     (CONS
                                      (CAR
                                       (PROGN
                                         (SETQ TEMP1
                                          (OR (|comp| |x| |m'| |e|)
                                           (RETURN '|failed|)))
                                         (SETQ |e| (CADDR TEMP1))
                                         TEMP1))
                                      T7))))))))
                  (COND ((BOOT-EQUAL |argl'| '|failed|) (RETURN NIL)))
                  (SETQ |form|
                        (COND
                          ((AND (NULL (|member| |op| |$formalArgList|))
                                (ATOM |op|)
                                (NULL (|get| |op| '|value| |e|)))
                           (SETQ |nprefix|
                                 (OR |$prefix|
                                     (|getAbbreviation| |$op|
                                      (|#| (CDR |$form|)))))
                           (SETQ |op'|
                                 (INTERN (STRCONC
                                          (|encodeItem| |nprefix|) '|;|
                                          (|encodeItem| |op|))))
                           (CONS |op'| (APPEND |argl'| (CONS '$ NIL))))
                          (T (CONS '|call|
                                   (CONS
                                    (CONS '|applyFun| (CONS |op| NIL))
                                    |argl'|)))))
                  (SETQ |pairlis|
                        (PROG (T10)
                          (SETQ T10 NIL)
                          (RETURN
                            (DO ((T11 |argl'| (CDR T11)) (|a| NIL)
                                 (T12 |$FormalMapVariableList|
                                      (CDR T12))
                                 (|v| NIL))
                                ((OR (ATOM T11)
                                     (PROGN (SETQ |a| (CAR T11)) NIL)
                                     (ATOM T12)
                                     (PROGN (SETQ |v| (CAR T12)) NIL))
                                 (NREVERSE0 T10))
                              (SEQ (EXIT
                                    (SETQ T10
                                     (CONS (CONS |v| |a|) T10))))))))
                  (|convert|
                      (CONS |form|
                            (CONS (SUBLIS |pairlis| (CAR |ml|))
                                  (CONS |e| NIL)))
                      |m|))))))))

;--% APPLY MODEMAPS

;compMapCond(op,mc,$bindings,fnsel) ==
;  or/[compMapCond'(u,op,mc,$bindings) for u in fnsel]

(defun |compMapCond| (op mc |$bindings| fnsel)
 (declare (special |$bindings|))
 (let (t0)
  (do ((t1 nil t0) (t2 fnsel (cdr t2)) (|u| nil))
      ((or t1 (atom t2) (progn (setq |u| (car t2)) nil)) t0)
   (setq t0 (or t0 (|compMapCond'| |u| op mc |$bindings|))))))

;compMapCond'([cexpr,fnexpr],op,dc,bindings) ==
;  compMapCond''(cexpr,dc) => compMapCondFun(fnexpr,op,dc,bindings)
;  stackMessage ["not known that",'%b,dc,'%d,"has",'%b,cexpr,'%d]

(defun |compMapCond'| (t0 op dc bindings)
 (let ((cexpr (car t0)) (fnexpr (cadr t0)))
  (if (|compMapCond''| cexpr dc)
    (|compMapCondFun| fnexpr op dc bindings)
    (|stackMessage| `("not known that" %b ,dc %d "has" %b ,cexpr %d)))))

;compMapCond''(cexpr,dc) ==
;  cexpr=true => true
;  --cexpr = "true" => true
;  cexpr is ["AND",:l] => and/[compMapCond''(u,dc) for u in l]
;  cexpr is ["OR",:l] => or/[compMapCond''(u,dc) for u in l]
;  cexpr is ["not",u] => not compMapCond''(u,dc)
;  cexpr is ["has",name,cat] => (knownInfo cexpr => true; false)
;        --for the time being we'll stop here - shouldn't happen so far
;        --$disregardConditionIfTrue => true
;        --stackSemanticError(("not known that",'%b,name,
;        -- '%d,"has",'%b,cat,'%d),nil)
;  --now it must be an attribute
;  MEMBER(["ATTRIBUTE",dc,cexpr],get("$Information","special",$e)) => true
;  --for the time being we'll stop here - shouldn't happen so far
;  stackMessage ["not known that",'%b,dc,'%d,"has",'%b,cexpr,'%d]
;  false

(defun |compMapCond''| (cexpr dc)
 (let (l u tmp1 tmp2)
 (declare (special |$Information| |$e|))
  (cond
   ((boot-equal cexpr t) t)
   ((and (consp cexpr) 
         (eq (qcar cexpr) 'and)
         (progn (setq l (qcdr cexpr)) t))
     (prog (t0)
      (setq t0 t)
      (return
       (do ((t1 nil (null t0)) (t2 l (cdr t2)) (u nil))
           ((or t1 (atom t2) (progn (setq u (car t2)) nil)) t0)
        (setq t0 (and t0 (|compMapCond''| u dc)))))))
   ((and (consp cexpr) 
         (eq (qcar cexpr) 'or)
         (progn (setq l (qcdr cexpr)) t))
    (prog (t3)
     (setq t3 nil)
     (return
      (do ((t4 nil t3) (t5 l (cdr t5)) (u nil))
          ((or t4 (atom t5) (progn (setq u (car t5)) nil)) t3)
         (setq t3 (or t3 (|compMapCond''| u dc)))))))
   ((and (consp cexpr)
         (eq (qcar cexpr) '|not|)
         (progn 
          (setq tmp1 (qcdr cexpr))
          (and (consp tmp1)
               (eq (qcdr tmp1) nil)
               (progn (setq u (qcar tmp1)) t))))
     (null (|compMapCond''| u dc)))
   ((and (consp cexpr)
         (eq (qcar cexpr) '|has|)
         (progn
          (setq tmp1 (qcdr cexpr))
          (and (consp tmp1)
               (progn
                (setq tmp2 (qcdr tmp1))
                (and (consp tmp2)
                     (eq (qcdr tmp2) nil))))))
     (cond
      ((|knownInfo| cexpr) t)
      (t nil)))
   ((|member| 
      (cons 'attribute (cons dc (cons cexpr nil)))
      (|get| '|$Information| 'special |$e|))
     t)
   (t 
    (|stackMessage| `("not known that" %b ,dc %d "has" %b ,cexpr %d))
    nil))))

;compMapCondFun(fnexpr,op,dc,bindings) == [fnexpr,bindings]

(defun |compMapCondFun| (fnexpr op dc bindings)
 (declare (ignore op) (ignore dc))
 (cons fnexpr (cons bindings nil))) 

\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
