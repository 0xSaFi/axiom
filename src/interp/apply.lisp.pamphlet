\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp apply.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=

(in-package "BOOT" )

;oldCompilerAutoloadOnceTrigger() == nil

(defun |oldCompilerAutoloadOnceTrigger| () nil) 

;compAtomWithModemap(x,m,e,v) ==
;  Tl :=
;    [[transImplementation(x,map,fn),target,e]
;      for map in v | map is [[.,target],[.,fn]]] =>
;                                         --accept only monadic operators
;        T:= or/[t for (t:= [.,target,.]) in Tl | modeEqual(m,target)] => T
;        1=#(Tl:= [y for t in Tl | (y:= convert(t,m))]) => first Tl
;        0<#Tl and m=$NoValueMode => first Tl
;        nil

(DEFUN |compAtomWithModemap| (|x| |m| |e| |v|)
  (PROG (TMP1 TMP2 TMP3 TMP4 TMP5 |fn| |target| T$ |y| TRANSIMP)
  (declare (special |$NoValueMode|))
    (RETURN
      (SEQ (COND
             ((SETQ TRANSIMP
                    (PROG (T0)
                      (SETQ T0 NIL)
                      (RETURN
                        (DO ((T1 |v| (CDR T1)) (|map| NIL))
                            ((OR (ATOM T1)
                                 (PROGN (SETQ |map| (CAR T1)) NIL))
                             (NREVERSE0 T0))
                          (SEQ (EXIT (COND
                                       ((AND (PAIRP |map|)
                                         (PROGN
                                           (SETQ TMP1 (QCAR |map|))
                                           (AND (PAIRP TMP1)
                                            (PROGN
                                              (SETQ TMP2 (QCDR TMP1))
                                              (AND (PAIRP TMP2)
                                               (EQ (QCDR TMP2) NIL)
                                               (PROGN
                                                 (SETQ |target|
                                                  (QCAR TMP2))
                                                 T)))))
                                         (PROGN
                                           (SETQ TMP3 (QCDR |map|))
                                           (AND (PAIRP TMP3)
                                            (EQ (QCDR TMP3) NIL)
                                            (PROGN
                                              (SETQ TMP4 (QCAR TMP3))
                                              (AND (PAIRP TMP4)
                                               (PROGN
                                                 (SETQ TMP5
                                                  (QCDR TMP4))
                                                 (AND (PAIRP TMP5)
                                                  (EQ (QCDR TMP5) NIL)
                                                  (PROGN
                                                    (SETQ |fn|
                                                     (QCAR TMP5))
                                                    T))))))))
                                        (SETQ T0
                                         (CONS
                                          (CONS
                                           (|transImplementation| |x|
                                            |map| |fn|)
                                           (CONS |target|
                                            (CONS |e| NIL)))
                                          T0))))))))))
              (EXIT (COND
                      ((SETQ T$
                             (PROG (T2)
                               (SETQ T2 NIL)
                               (RETURN
                                 (DO ((T3 NIL T2)
                                      (T4 TRANSIMP (CDR T4)) (|t| NIL))
                                     ((OR T3 (ATOM T4)
                                       (PROGN (SETQ |t| (CAR T4)) NIL)
                                       (PROGN
                                         (PROGN
                                           (SETQ |target| (CADR |t|))
                                           |t|)
                                         NIL))
                                      T2)
                                   (SEQ
                                    (EXIT
                                     (COND
                                       ((|modeEqual| |m| |target|)
                                        (SETQ T2 (OR T2 |t|))))))))))
                       T$)
                      ((EQL 1
                            (|#| (SETQ TRANSIMP
                                       (PROG (T5)
                                         (SETQ T5 NIL)
                                         (RETURN
                                           (DO
                                            ((T6 TRANSIMP (CDR T6))
                                             (|t| NIL))
                                            ((OR (ATOM T6)
                                              (PROGN
                                                (SETQ |t| (CAR T6))
                                                NIL))
                                             (NREVERSE0 T5))
                                             (SEQ
                                              (EXIT
                                               (COND
                                                 ((SETQ |y|
                                                   (|convert| |t| |m|))
                                                  (SETQ T5
                                                   (CONS |y| T5))))))))))))
                       (CAR TRANSIMP))
                      ((AND (QSLESSP 0 (|#| TRANSIMP))
                            (BOOT-EQUAL |m| |$NoValueMode|))
                       (CAR TRANSIMP))
                      (T NIL)))))))))

;transImplementation(op,map,fn) ==
;--+
;  fn := genDeltaEntry [op,:map]
;  fn is ["XLAM",:.] => [fn]
;  ["call",fn]

(DEFUN |transImplementation| (OP MAP FN)
  (SETQ FN (|genDeltaEntry| (CONS OP MAP)))
  (COND
    ((AND (PAIRP FN) (EQ (QCAR FN) 'XLAM)) (CONS FN NIL))
    (T (CONS '|call| (CONS FN NIL)))))

;compApply(sig,varl,body,argl,m,e) ==
;  argTl:= [[.,.,e]:= comp(x,$EmptyMode,e) for x in argl]
;  contour:=
;    [Pair(x,[["mode",m'],["value",removeEnv comp(a,m',e)]])
;      for x in varl for m' in sig.source for a in argl]
;  code:= [["LAMBDA",varl,body'],:[T.expr for T in argTl]]
;  m':= resolve(m,sig.target)
;  body':= (comp(body,m',addContour(contour,e))).expr
;  [code,m',e]

(DEFUN |compApply| (SIG VARL BODY ARGL M E)
  (LET (TEMP1 ARGTL CONTOUR CODE MQ BODYQ)
  (declare (special |$EmptyMode|))
    (SETQ ARGTL
          (PROG (T0)
            (SETQ T0 NIL)
            (RETURN
              (DO ((T1 ARGL (CDR T1)) (|x| NIL))
                  ((OR (ATOM T1) (PROGN (SETQ |x| (CAR T1)) NIL))
                   (NREVERSE0 T0))
                (SEQ (EXIT (SETQ T0
                                 (CONS (PROGN
                                         (SETQ TEMP1
                                          (|comp| |x| |$EmptyMode| E))
                                         (SETQ E (CADDR TEMP1))
                                         TEMP1)
                                       T0))))))))
    (SETQ CONTOUR
          (PROG (T2)
            (SETQ T2 NIL)
            (RETURN
              (DO ((T3 VARL (CDR T3)) (|x| NIL) (T4 (CDR SIG) (CDR T4))
                   (MQ NIL) (T5 ARGL (CDR T5)) (|a| NIL))
                  ((OR (ATOM T3) (PROGN (SETQ |x| (CAR T3)) NIL)
                       (ATOM T4) (PROGN (SETQ MQ (CAR T4)) NIL)
                       (ATOM T5) (PROGN (SETQ |a| (CAR T5)) NIL))
                   (NREVERSE0 T2))
                (SETQ T2
                      (CONS (|Pair| |x|
                                    (CONS (CONS '|mode| (CONS MQ NIL))
                                     (CONS
                                      (CONS '|value|
                                       (CONS
                                        (|removeEnv| (|comp| |a| MQ E))
                                        NIL))
                                      NIL)))
                            T2))))))
    (SETQ CODE
          (CONS (CONS 'LAMBDA (CONS VARL (CONS BODYQ NIL)))
                (PROG (T6)
                  (SETQ T6 NIL)
                  (RETURN
                    (DO ((T7 ARGTL (CDR T7)) (T$ NIL))
                        ((OR (ATOM T7) (PROGN (SETQ T$ (CAR T7)) NIL))
                         (NREVERSE0 T6))
                      (SETQ T6 (CONS (CAR T$) T6)))))))
    (SETQ MQ (|resolve| M (CAR SIG)))
    (SETQ BODYQ (CAR (|comp| BODY MQ (|addContour| CONTOUR E))))
    (CONS CODE (CONS MQ (CONS E NIL)))))

;compToApply(op,argl,m,e) ==
;  T:= compNoStacking(op,$EmptyMode,e) or return nil
;  m1:= T.mode
;  T.expr is ["QUOTE", =m1] => nil
;  compApplication(op,argl,m,T.env,T)

(DEFUN |compToApply| (|op| |argl| |m| |e|)
  (PROG (T$ |m1| TMP1 TMP2)
  (declare (special |$EmptyMode|))
    (RETURN
      (PROGN
        (SETQ T$
              (OR (|compNoStacking| |op| |$EmptyMode| |e|)
                  (RETURN NIL)))
        (SETQ |m1| (CADR T$))
        (COND
          ((PROGN
             (SETQ TMP1 (CAR T$))
             (AND (PAIRP TMP1) (EQ (QCAR TMP1) 'QUOTE)
                  (PROGN
                    (SETQ TMP2 (QCDR TMP1))
                    (AND (PAIRP TMP2) (EQ (QCDR TMP2) NIL)
                         (EQUAL (QCAR TMP2) |m1|)))))
           NIL)
          (T (|compApplication| |op| |argl| |m| (CADDR T$) T$)))))))

;compApplication(op,argl,m,e,T) ==
;  T.mode is ['Mapping, retm, :argml] =>
;    #argl ^= #argml => nil
;    retm := resolve(m, retm)
;    retm = $Category or isCategoryForm(retm,e) => nil  -- not handled
;    argTl := [[.,.,e] := comp(x,m,e) or return "failed"
;              for x in argl for m in argml]
;    argTl = "failed" => nil
;    form:=
;      not (MEMBER(op,$formalArgList) or MEMBER(T.expr,$formalArgList)) and ATOM T.expr =>
;        nprefix := $prefix or
;        -- following needed for referencing local funs at capsule level
;           getAbbreviation($op,#rest $form)
;        [op',:[a.expr for a in argTl],"$"] where
;          op':= INTERN STRCONC(encodeItem nprefix,";",encodeItem T.expr)
;      ['call, ['applyFun, T.expr], :[a.expr for a in argTl]]
;    coerce([form, retm, e],resolve(retm,m))
;  op = 'elt => nil
;  eltForm := ['elt, op, :argl]
;  comp(eltForm, m, e)

(DEFUN |compApplication| (|op| |argl| |m| |e| T$)
  (PROG (TMP1 TMP2 |argml| |retm| TEMP1 |argTl| |nprefix| |op'| |form|
              |eltForm|)
  (declare (special |$form| |$op| |$prefix| |$formalArgList| |$Category|))
    (RETURN
      (SEQ (COND
             ((PROGN
                (SETQ TMP1 (CADR T$))
                (AND (PAIRP TMP1) (EQ (QCAR TMP1) '|Mapping|)
                     (PROGN
                       (SETQ TMP2 (QCDR TMP1))
                       (AND (PAIRP TMP2)
                            (PROGN
                              (SETQ |retm| (QCAR TMP2))
                              (SETQ |argml| (QCDR TMP2))
                              T)))))
              (COND
                ((NEQUAL (|#| |argl|) (|#| |argml|)) NIL)
                (T (SETQ |retm| (|resolve| |m| |retm|))
                   (COND
                     ((OR (BOOT-EQUAL |retm| |$Category|)
                          (|isCategoryForm| |retm| |e|))
                      NIL)
                     (T (SETQ |argTl|
                              (PROG (T0)
                                (SETQ T0 NIL)
                                (RETURN
                                  (DO ((T1 |argl| (CDR T1)) (|x| NIL)
                                       (T2 |argml| (CDR T2)) (|m| NIL))
                                      ((OR (ATOM T1)
                                        (PROGN
                                          (SETQ |x| (CAR T1))
                                          NIL)
                                        (ATOM T2)
                                        (PROGN
                                          (SETQ |m| (CAR T2))
                                          NIL))
                                       (NREVERSE0 T0))
                                    (SEQ
                                     (EXIT
                                      (SETQ T0
                                       (CONS
                                        (PROGN
                                          (SETQ TEMP1
                                           (OR (|comp| |x| |m| |e|)
                                            (RETURN '|failed|)))
                                          (SETQ |e| (CADDR TEMP1))
                                          TEMP1)
                                        T0))))))))
                        (COND
                          ((BOOT-EQUAL |argTl| '|failed|) NIL)
                          (T (SETQ |form|
                                   (COND
                                     ((AND
                                       (NULL
                                        (OR
                                         (|member| |op|
                                          |$formalArgList|)
                                         (|member| (CAR T$)
                                          |$formalArgList|)))
                                       (ATOM (CAR T$)))
                                      (SETQ |nprefix|
                                       (OR |$prefix|
                                        (|getAbbreviation| |$op|
                                         (|#| (CDR |$form|)))))
                                      (SETQ |op'|
                                       (INTERN
                                        (STRCONC
                                         (|encodeItem| |nprefix|) '|;|
                                         (|encodeItem| (CAR T$)))))
                                      (CONS |op'|
                                       (APPEND
                                        (PROG (T3)
                                          (SETQ T3 NIL)
                                          (RETURN
                                            (DO
                                             ((T4 |argTl| (CDR T4))
                                              (|a| NIL))
                                             ((OR (ATOM T4)
                                               (PROGN
                                                 (SETQ |a| (CAR T4))
                                                 NIL))
                                              (NREVERSE0 T3))
                                              (SEQ
                                               (EXIT
                                                (SETQ T3
                                                 (CONS (CAR |a|) T3)))))))
                                        (CONS '$ NIL))))
                                     (T
                                      (CONS '|call|
                                       (CONS
                                        (CONS '|applyFun|
                                         (CONS (CAR T$) NIL))
                                        (PROG (T5)
                                          (SETQ T5 NIL)
                                          (RETURN
                                            (DO
                                             ((T6 |argTl| (CDR T6))
                                              (|a| NIL))
                                             ((OR (ATOM T6)
                                               (PROGN
                                                 (SETQ |a| (CAR T6))
                                                 NIL))
                                              (NREVERSE0 T5))
                                              (SEQ
                                               (EXIT
                                                (SETQ T5
                                                 (CONS (CAR |a|) T5))))))))))))
                             (|coerce|
                                 (CONS |form|
                                       (CONS |retm| (CONS |e| NIL)))
                                 (|resolve| |retm| |m|)))))))))
             ((BOOT-EQUAL |op| '|elt|) NIL)
             (T (SETQ |eltForm| (CONS '|elt| (CONS |op| |argl|)))
                (|comp| |eltForm| |m| |e|)))))))

;compFormWithModemap(form is [op,:argl],m,e,modemap) ==
;  [map:= [.,target,:.],[pred,impl]]:= modemap
;  -- this fails if the subsuming modemap is conditional
;  --impl is ['Subsumed,:.] => nil
;  if isCategoryForm(target,e) and isFunctor op then
;    [modemap,e]:= substituteIntoFunctorModemap(argl,modemap,e) or return nil
;    [map:= [.,target,:.],:cexpr]:= modemap
;  sv:=listOfSharpVars map
;  if sv then
;     -- SAY [ "compiling ", op, " in compFormWithModemap,
;     -- mode= ",map," sharp vars=",sv]
;    for x in argl for ss in $FormalMapVariableList repeat
;      if ss in sv then
;        [map:= [.,target,:.],:cexpr]:= modemap :=SUBST(x,ss,modemap)
;        -- SAY ["new map is",map]
;  not (target':= coerceable(target,m,e)) => nil
;  map:= [target',:rest map]
;  [f,Tl,sl]:= compApplyModemap(form,modemap,e,nil) or return nil
;  --generate code; return
;  T:=
;    [x',m',e'] where
;      m':= SUBLIS(sl,map.(1))
;      x':=
;        form':= [f,:[t.expr for t in Tl]]
;        m'=$Category or isCategoryForm(m',e) => form'
;        -- try to deal with new-style Unions where we know the conditions
;        op = "elt" and f is ['XLAM,:.] and IDENTP(z:=CAR argl) and
;          (c:=get(z,'condition,e)) and
;            c is [['case,=z,c1]] and
;              (c1 is ['_:,=(CADR argl),=m] or EQ(c1,CADR argl) ) =>
;-- first is a full tag, as placed by getInverseEnvironment
;-- second is what getSuccessEnvironment will place there
;                ["CDR",z]
;        ["call",:form']
;      e':=
;        Tl => (LAST Tl).env
;        e
;  convert(T,m)

(DEFUN |compFormWithModemap| (|form| |m| |e| |modemap|)
  (PROG (|op| |argl| |pred| |impl| |sv| |target| |cexpr| |target'|
              |map| TEMP1 |f| TRANSIMP |sl| |m'| |form'| |z| |c| TMP3
              |c1| TMP1 TMP2 |x'| |e'| T$)
  (declare (special |$Category| |$FormalMapVariableList|))
    (RETURN
      (SEQ (PROGN
             (SETQ |op| (CAR |form|))
             (SETQ |argl| (CDR |form|))
             (SETQ |map| (CAR |modemap|))
             (SETQ |target| (CADAR |modemap|))
             (SETQ |pred| (CAADR |modemap|))
             (SETQ |impl| (CADADR |modemap|))
             (COND
               ((AND (|isCategoryForm| |target| |e|)
                     (|isFunctor| |op|))
                (SETQ TEMP1
                      (OR (|substituteIntoFunctorModemap| |argl|
                              |modemap| |e|)
                          (RETURN NIL)))
                (SETQ |modemap| (CAR TEMP1)) (SETQ |e| (CADR TEMP1))
                (SETQ |map| (CAR |modemap|))
                (SETQ |target| (CADAR |modemap|))
                (SETQ |cexpr| (CDR |modemap|)) |modemap|))
             (SETQ |sv| (|listOfSharpVars| |map|))
             (COND
               (|sv| (DO ((T0 |argl| (CDR T0)) (|x| NIL)
                          (T1 |$FormalMapVariableList| (CDR T1))
                          (|ss| NIL))
                         ((OR (ATOM T0) (PROGN (SETQ |x| (CAR T0)) NIL)
                              (ATOM T1)
                              (PROGN (SETQ |ss| (CAR T1)) NIL))
                          NIL)
                       (SEQ (EXIT (COND
                                    ((|member| |ss| |sv|)
                                     (SETQ |modemap|
                                      (MSUBST |x| |ss| |modemap|))
                                     (SETQ |map| (CAR |modemap|))
                                     (SETQ |target| (CADAR |modemap|))
                                     (SETQ |cexpr| (CDR |modemap|))
                                     |modemap|)
                                    (T NIL)))))))
             (COND
               ((NULL (SETQ |target'| (|coerceable| |target| |m| |e|)))
                NIL)
               (T (SETQ |map| (CONS |target'| (CDR |map|)))
                  (SETQ TEMP1
                        (OR (|compApplyModemap| |form| |modemap| |e|
                                NIL)
                            (RETURN NIL)))
                  (SETQ |f| (CAR TEMP1)) (SETQ TRANSIMP (CADR TEMP1))
                  (SETQ |sl| (CADDR TEMP1))
                  (SETQ |m'| (SUBLIS |sl| (ELT |map| 1)))
                  (SETQ |x'|
                        (PROGN
                          (SETQ |form'|
                                (CONS |f|
                                      (PROG (T2)
                                        (SETQ T2 NIL)
                                        (RETURN
                                          (DO
                                           ((T3 TRANSIMP (CDR T3))
                                            (|t| NIL))
                                           ((OR (ATOM T3)
                                             (PROGN
                                               (SETQ |t| (CAR T3))
                                               NIL))
                                            (NREVERSE0 T2))
                                            (SEQ
                                             (EXIT
                                              (SETQ T2
                                               (CONS (CAR |t|) T2)))))))))
                          (COND
                            ((OR (BOOT-EQUAL |m'| |$Category|)
                                 (|isCategoryForm| |m'| |e|))
                             |form'|)
                            ((AND (BOOT-EQUAL |op| '|elt|) (PAIRP |f|)
                                  (EQ (QCAR |f|) 'XLAM)
                                  (IDENTP (SETQ |z| (CAR |argl|)))
                                  (SETQ |c|
                                        (|get| |z| '|condition| |e|))
                                  (PAIRP |c|) (EQ (QCDR |c|) NIL)
                                  (PROGN
                                    (SETQ TMP1 (QCAR |c|))
                                    (AND (PAIRP TMP1)
                                     (EQ (QCAR TMP1) '|case|)
                                     (PROGN
                                       (SETQ TMP2 (QCDR TMP1))
                                       (AND (PAIRP TMP2)
                                        (EQUAL (QCAR TMP2) |z|)
                                        (PROGN
                                          (SETQ TMP3 (QCDR TMP2))
                                          (AND (PAIRP TMP3)
                                           (EQ (QCDR TMP3) NIL)
                                           (PROGN
                                             (SETQ |c1| (QCAR TMP3))
                                             T)))))))
                                  (OR (AND (PAIRP |c1|)
                                       (EQ (QCAR |c1|) '|:|)
                                       (PROGN
                                         (SETQ TMP1 (QCDR |c1|))
                                         (AND (PAIRP TMP1)
                                          (EQUAL (QCAR TMP1)
                                           (CADR |argl|))
                                          (PROGN
                                            (SETQ TMP2 (QCDR TMP1))
                                            (AND (PAIRP TMP2)
                                             (EQ (QCDR TMP2) NIL)
                                             (EQUAL (QCAR TMP2) |m|))))))
                                      (EQ |c1| (CADR |argl|))))
                             (CONS 'CDR (CONS |z| NIL)))
                            (T (CONS '|call| |form'|)))))
                  (SETQ |e'|
                        (COND
                          (TRANSIMP (CADDR (|last| TRANSIMP)))
                          (T |e|)))
                  (SETQ T$ (CONS |x'| (CONS |m'| (CONS |e'| NIL))))
                  (|convert| T$ |m|))))))))

;-- This version tends to give problems with #1 and categories
;-- applyMapping([op,:argl],m,e,ml) ==
;--   #argl^=#ml-1 => nil
;--   mappingHasCategoryTarget :=
;--     isCategoryForm(first ml,e) => --is op a functor?
;--       form:= [op,:argl']
;--       pairlis:= [[v,:a] for a in argl for v in $FormalMapVariableList]
;--       ml:= SUBLIS(pairlis,ml)
;--       true
;--     false
;--   argl':=
;--     [T.expr for x in argl for m' in rest ml] where
;--       T() == [.,.,e]:= comp(x,m',e) or return "failed"
;--   if argl'="failed" then return nil
;--   mappingHasCategoryTarget => convert([form,first ml,e],m)
;--   form:=
;--     not MEMBER(op,$formalArgList) and ATOM op =>
;--       [op',:argl',"$"] where
;--         op':= INTERN STRCONC(STRINGIMAGE $prefix,";",STRINGIMAGE op)
;--     ["call",["applyFun",op],:argl']
;--   pairlis:= [[v,:a] for a in argl' for v in $FormalMapVariableList]
;--   convert([form,SUBLIS(pairlis,first ml),e],m)


;applyMapping([op,:argl],m,e,ml) ==
;  #argl^=#ml-1 => nil
;  isCategoryForm(first ml,e) =>
;                                --is op a functor?
;    pairlis:= [[v,:a] for a in argl for v in $FormalMapVariableList]
;    ml' := SUBLIS(pairlis, ml)
;    argl':=
;      [T.expr for x in argl for m' in rest ml'] where
;        T() == [.,.,e]:= comp(x,m',e) or return "failed"
;    if argl'="failed" then return nil
;    form:= [op,:argl']
;    convert([form,first ml',e],m)
;  argl':=
;    [T.expr for x in argl for m' in rest ml] where
;      T() == [.,.,e]:= comp(x,m',e) or return "failed"
;  if argl'="failed" then return nil
;  form:=
;    not MEMBER(op,$formalArgList) and ATOM op and not get(op,'value,e) =>
;      nprefix := $prefix or
;   -- following needed for referencing local funs at capsule level
;        getAbbreviation($op,#rest $form)
;      [op',:argl',"$"] where
;        op':= INTERN STRCONC(encodeItem nprefix,";",encodeItem op)
;    ['call,['applyFun,op],:argl']
;  pairlis:= [[v,:a] for a in argl' for v in $FormalMapVariableList]
;  convert([form,SUBLIS(pairlis,first ml),e],m)

(DEFUN |applyMapping| (T0 |m| |e| |ml|)
  (PROG (|op| |argl| |ml'| TEMP1 |argl'| |nprefix| |op'| |form| |pairlis|)
  (declare (special |$FormalMapVariableList| |$form| |$op| |$prefix|
                    |$formalArgList|))
    (RETURN
      (SEQ (PROGN
             (SETQ |op| (CAR T0))
             (SETQ |argl| (CDR T0))
             (COND
               ((NEQUAL (|#| |argl|) (SPADDIFFERENCE (|#| |ml|) 1))
                NIL)
               ((|isCategoryForm| (CAR |ml|) |e|)
                (SETQ |pairlis|
                      (PROG (T1)
                        (SETQ T1 NIL)
                        (RETURN
                          (DO ((T2 |argl| (CDR T2)) (|a| NIL)
                               (T3 |$FormalMapVariableList| (CDR T3))
                               (|v| NIL))
                              ((OR (ATOM T2)
                                   (PROGN (SETQ |a| (CAR T2)) NIL)
                                   (ATOM T3)
                                   (PROGN (SETQ |v| (CAR T3)) NIL))
                               (NREVERSE0 T1))
                            (SEQ (EXIT (SETQ T1
                                        (CONS (CONS |v| |a|) T1))))))))
                (SETQ |ml'| (SUBLIS |pairlis| |ml|))
                (SETQ |argl'|
                      (PROG (T4)
                        (SETQ T4 NIL)
                        (RETURN
                          (DO ((T5 |argl| (CDR T5)) (|x| NIL)
                               (T6 (CDR |ml'|) (CDR T6)) (|m'| NIL))
                              ((OR (ATOM T5)
                                   (PROGN (SETQ |x| (CAR T5)) NIL)
                                   (ATOM T6)
                                   (PROGN (SETQ |m'| (CAR T6)) NIL))
                               (NREVERSE0 T4))
                            (SEQ (EXIT (SETQ T4
                                        (CONS
                                         (CAR
                                          (PROGN
                                            (SETQ TEMP1
                                             (OR (|comp| |x| |m'| |e|)
                                              (RETURN '|failed|)))
                                            (SETQ |e| (CADDR TEMP1))
                                            TEMP1))
                                         T4))))))))
                (COND ((BOOT-EQUAL |argl'| '|failed|) (RETURN NIL)))
                (SETQ |form| (CONS |op| |argl'|))
                (|convert|
                    (CONS |form| (CONS (CAR |ml'|) (CONS |e| NIL)))
                    |m|))
               (T (SETQ |argl'|
                        (PROG (T7)
                          (SETQ T7 NIL)
                          (RETURN
                            (DO ((T8 |argl| (CDR T8)) (|x| NIL)
                                 (T9 (CDR |ml|) (CDR T9)) (|m'| NIL))
                                ((OR (ATOM T8)
                                     (PROGN (SETQ |x| (CAR T8)) NIL)
                                     (ATOM T9)
                                     (PROGN (SETQ |m'| (CAR T9)) NIL))
                                 (NREVERSE0 T7))
                              (SEQ (EXIT
                                    (SETQ T7
                                     (CONS
                                      (CAR
                                       (PROGN
                                         (SETQ TEMP1
                                          (OR (|comp| |x| |m'| |e|)
                                           (RETURN '|failed|)))
                                         (SETQ |e| (CADDR TEMP1))
                                         TEMP1))
                                      T7))))))))
                  (COND ((BOOT-EQUAL |argl'| '|failed|) (RETURN NIL)))
                  (SETQ |form|
                        (COND
                          ((AND (NULL (|member| |op| |$formalArgList|))
                                (ATOM |op|)
                                (NULL (|get| |op| '|value| |e|)))
                           (SETQ |nprefix|
                                 (OR |$prefix|
                                     (|getAbbreviation| |$op|
                                      (|#| (CDR |$form|)))))
                           (SETQ |op'|
                                 (INTERN (STRCONC
                                          (|encodeItem| |nprefix|) '|;|
                                          (|encodeItem| |op|))))
                           (CONS |op'| (APPEND |argl'| (CONS '$ NIL))))
                          (T (CONS '|call|
                                   (CONS
                                    (CONS '|applyFun| (CONS |op| NIL))
                                    |argl'|)))))
                  (SETQ |pairlis|
                        (PROG (T10)
                          (SETQ T10 NIL)
                          (RETURN
                            (DO ((T11 |argl'| (CDR T11)) (|a| NIL)
                                 (T12 |$FormalMapVariableList|
                                      (CDR T12))
                                 (|v| NIL))
                                ((OR (ATOM T11)
                                     (PROGN (SETQ |a| (CAR T11)) NIL)
                                     (ATOM T12)
                                     (PROGN (SETQ |v| (CAR T12)) NIL))
                                 (NREVERSE0 T10))
                              (SEQ (EXIT
                                    (SETQ T10
                                     (CONS (CONS |v| |a|) T10))))))))
                  (|convert|
                      (CONS |form|
                            (CONS (SUBLIS |pairlis| (CAR |ml|))
                                  (CONS |e| NIL)))
                      |m|))))))))

;--% APPLY MODEMAPS
;compApplyModemap(form,modemap,$e,sl) ==
;  [op,:argl] := form                   --form to be compiled
;  [[mc,mr,:margl],:fnsel] := modemap   --modemap we are testing
;  -- $e     is the current environment
;  -- sl     substitution list, nil means bottom-up, otherwise top-down
;  -- 0.  fail immediately if #argl=#margl
;  if #argl^=#margl then return nil
;  -- 1.  use modemap to evaluate arguments, returning failed if
;  --     not possible
;  lt:=
;    [[.,m',$e]:=
;      comp(y,g,$e) or return "failed" where
;        g:= SUBLIS(sl,m) where
;            sl:= pmatchWithSl(m',m,sl) for y in argl for m in margl]
;  lt="failed" => return nil
;  -- 2.  coerce each argument to final domain, returning failed
;  --     if not possible
;  lt':= [coerce(y,d) or return "failed"
;         for y in lt for d in SUBLIS(sl,margl)]
;  lt'="failed" => return nil
;  -- 3.  obtain domain-specific function, if possible, and return
;  --$bindings is bound by compMapCond
;  [f,$bindings]:= compMapCond(op,mc,sl,fnsel) or return nil
;--+ can no longer trust what the modemap says for a reference into
;--+ an exterior domain (it is calculating the displacement based on view
;--+ information which is no longer valid; thus ignore this index and
;--+ store the signature instead.
;--$NRTflag=true and f is [op1,d,.] and NE(d,'$) and MEMBER(op1,'(ELT CONST)) =>
;  f is [op1,d,.] and MEMBER(op1,'(ELT CONST Subsumed)) =>
;    [genDeltaEntry [op,:modemap],lt',$bindings]
;  [f,lt',$bindings]

(DEFUN |compApplyModemap| (|form| |modemap| |$e| |sl|)
  (DECLARE (SPECIAL |$e|))
  (PROG (|op| |argl| |mc| |mr| |margl| |fnsel| |g| |m'| |lt| |lt'|
              TEMP1 |f| |op1| TMP1 |d| TMP2)
  (declare (special |$bindings| |$e|))
    (RETURN
      (SEQ (PROGN
             (SETQ |op| (CAR |form|))
             (SETQ |argl| (CDR |form|))
             (SETQ |mc| (CAAR |modemap|))
             (SETQ |mr| (CADAR |modemap|))
             (SETQ |margl| (CDDAR |modemap|))
             (SETQ |fnsel| (CDR |modemap|))
             (COND ((NEQUAL (|#| |argl|) (|#| |margl|)) (RETURN NIL)))
             (SETQ |lt|
                   (PROG (T0)
                     (SETQ T0 NIL)
                     (RETURN
                       (DO ((T1 |argl| (CDR T1)) (|y| NIL)
                            (T2 |margl| (CDR T2)) (|m| NIL))
                           ((OR (ATOM T1)
                                (PROGN (SETQ |y| (CAR T1)) NIL)
                                (ATOM T2)
                                (PROGN (SETQ |m| (CAR T2)) NIL))
                            (NREVERSE0 T0))
                         (SEQ (EXIT (SETQ T0
                                     (CONS
                                      (PROGN
                                        (SETQ |sl|
                                         (|pmatchWithSl| |m'| |m| |sl|))
                                        (SETQ |g| (SUBLIS |sl| |m|))
                                        (SETQ TEMP1
                                         (OR (|comp| |y| |g| |$e|)
                                          (RETURN '|failed|)))
                                        (SETQ |m'| (CADR TEMP1))
                                        (SETQ |$e| (CADDR TEMP1))
                                        TEMP1)
                                      T0))))))))
             (COND
               ((BOOT-EQUAL |lt| '|failed|) (RETURN NIL))
               (T (SETQ |lt'|
                        (PROG (T3)
                          (SETQ T3 NIL)
                          (RETURN
                            (DO ((T4 |lt| (CDR T4)) (|y| NIL)
                                 (T5 (SUBLIS |sl| |margl|) (CDR T5))
                                 (|d| NIL))
                                ((OR (ATOM T4)
                                     (PROGN (SETQ |y| (CAR T4)) NIL)
                                     (ATOM T5)
                                     (PROGN (SETQ |d| (CAR T5)) NIL))
                                 (NREVERSE0 T3))
                              (SEQ (EXIT
                                    (SETQ T3
                                     (CONS
                                      (OR (|coerce| |y| |d|)
                                       (RETURN '|failed|))
                                      T3))))))))
                  (COND
                    ((BOOT-EQUAL |lt'| '|failed|) (RETURN NIL))
                    (T (SETQ TEMP1
                             (OR (|compMapCond| |op| |mc| |sl| |fnsel|)
                                 (RETURN NIL)))
                       (SETQ |f| (CAR TEMP1))
                       (SETQ |$bindings| (CADR TEMP1))
                       (COND
                         ((AND (PAIRP |f|)
                               (PROGN
                                 (SETQ |op1| (QCAR |f|))
                                 (SETQ TMP1 (QCDR |f|))
                                 (AND (PAIRP TMP1)
                                      (PROGN
                                        (SETQ |d| (QCAR TMP1))
                                        (SETQ TMP2 (QCDR TMP1))
                                        (AND (PAIRP TMP2)
                                         (EQ (QCDR TMP2) NIL)))))
                               (|member| |op1| '(ELT CONST |Subsumed|)))
                          (CONS (|genDeltaEntry| (CONS |op| |modemap|))
                                (CONS |lt'| (CONS |$bindings| NIL))))
                         (T (CONS |f|
                                (CONS |lt'| (CONS |$bindings| NIL))))))))))))))

;compMapCond(op,mc,$bindings,fnsel) ==
;  or/[compMapCond'(u,op,mc,$bindings) for u in fnsel]

(defun |compMapCond| (op mc |$bindings| fnsel)
 (declare (special |$bindings|))
 (let (t0)
  (do ((t1 nil t0) (t2 fnsel (cdr t2)) (|u| nil))
      ((or t1 (atom t2) (progn (setq |u| (car t2)) nil)) t0)
   (setq t0 (or t0 (|compMapCond'| |u| op mc |$bindings|))))))

;compMapCond'([cexpr,fnexpr],op,dc,bindings) ==
;  compMapCond''(cexpr,dc) => compMapCondFun(fnexpr,op,dc,bindings)
;  stackMessage ["not known that",'%b,dc,'%d,"has",'%b,cexpr,'%d]

(defun |compMapCond'| (t0 op dc bindings)
 (let ((cexpr (car t0)) (fnexpr (cadr t0)))
  (if (|compMapCond''| cexpr dc)
    (|compMapCondFun| fnexpr op dc bindings)
    (|stackMessage| `("not known that" %b ,dc %d "has" %b ,cexpr %d)))))

;compMapCond''(cexpr,dc) ==
;  cexpr=true => true
;  --cexpr = "true" => true
;  cexpr is ["AND",:l] => and/[compMapCond''(u,dc) for u in l]
;  cexpr is ["OR",:l] => or/[compMapCond''(u,dc) for u in l]
;  cexpr is ["not",u] => not compMapCond''(u,dc)
;  cexpr is ["has",name,cat] => (knownInfo cexpr => true; false)
;        --for the time being we'll stop here - shouldn't happen so far
;        --$disregardConditionIfTrue => true
;        --stackSemanticError(("not known that",'%b,name,
;        -- '%d,"has",'%b,cat,'%d),nil)
;  --now it must be an attribute
;  MEMBER(["ATTRIBUTE",dc,cexpr],get("$Information","special",$e)) => true
;  --for the time being we'll stop here - shouldn't happen so far
;  stackMessage ["not known that",'%b,dc,'%d,"has",'%b,cexpr,'%d]
;  false

(defun |compMapCond''| (cexpr dc)
 (let (l u tmp1 tmp2)
 (declare (special |$Information| |$e|))
  (cond
   ((boot-equal cexpr t) t)
   ((and (pairp cexpr) 
         (eq (qcar cexpr) 'and)
         (progn (setq l (qcdr cexpr)) t))
     (prog (t0)
      (setq t0 t)
      (return
       (do ((t1 nil (null t0)) (t2 l (cdr t2)) (u nil))
           ((or t1 (atom t2) (progn (setq u (car t2)) nil)) t0)
        (setq t0 (and t0 (|compMapCond''| u dc)))))))
   ((and (pairp cexpr) 
         (eq (qcar cexpr) 'or)
         (progn (setq l (qcdr cexpr)) t))
    (prog (t3)
     (setq t3 nil)
     (return
      (do ((t4 nil t3) (t5 l (cdr t5)) (u nil))
          ((or t4 (atom t5) (progn (setq u (car t5)) nil)) t3)
         (setq t3 (or t3 (|compMapCond''| u dc)))))))
   ((and (pairp cexpr)
         (eq (qcar cexpr) '|not|)
         (progn 
          (setq tmp1 (qcdr cexpr))
          (and (pairp tmp1)
               (eq (qcdr tmp1) nil)
               (progn (setq u (qcar tmp1)) t))))
     (null (|compMapCond''| u dc)))
   ((and (pairp cexpr)
         (eq (qcar cexpr) '|has|)
         (progn
          (setq tmp1 (qcdr cexpr))
          (and (pairp tmp1)
               (progn
                (setq tmp2 (qcdr tmp1))
                (and (pairp tmp2)
                     (eq (qcdr tmp2) nil))))))
     (cond
      ((|knownInfo| cexpr) t)
      (t nil)))
   ((|member| 
      (cons 'attribute (cons dc (cons cexpr nil)))
      (|get| '|$Information| '|special| |$e|))
     t)
   (t 
    (|stackMessage| `("not known that" %b ,dc %d "has" %b ,cexpr %d))
    nil))))

;compMapCondFun(fnexpr,op,dc,bindings) == [fnexpr,bindings]

(defun |compMapCondFun| (fnexpr op dc bindings)
 (declare (ignore op) (ignore dc))
 (cons fnexpr (cons bindings nil))) 

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
