\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp compiler.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{chunk}{*}

(IN-PACKAGE "BOOT" )

(defvar |$NoValueMode| '|NoValueMode|)
(defvar |$ValueMode| '|ValueMode|)
(defvar |$globalMacroStack| nil)
(defvar |$abbreviationStack| nil)

\end{chunk}
\subsection{compUniquely}
\begin{chunk}{*}
;compUniquely(x,m,e) ==
;  $compUniquelyIfTrue: local:= true
;  CATCH("compUniquely",comp(x,m,e))

(DEFUN |compUniquely| (|x| |m| |e|)
  (PROG (|$compUniquelyIfTrue|)
    (DECLARE (SPECIAL |$compUniquelyIfTrue|))
    (RETURN
      (PROGN
        (SPADLET |$compUniquelyIfTrue| 'T)
        (CATCH '|compUniquely| (|comp| |x| |m| |e|))))))

\end{chunk}
\subsection{tc}
\begin{chunk}{*}
;tc() ==
;  $tripleCache:= nil
;  comp($x,$m,$f)

(DEFUN |tc| ()
  (declare (special |$tripleCache| |$x| |$m| |$f|))
  (PROGN (SPADLET |$tripleCache| NIL) (|comp| |$x| |$m| |$f|)))

\end{chunk}

\subsection{convertOrCroak}
\begin{chunk}{*}
;convertOrCroak(T,m) ==
;  u:= convert(T,m) => u
;  userError ["CANNOT CONVERT: ",T.expr,"%l"," OF MODE: ",T.mode,"%l",
;    " TO MODE: ",m,"%l"]

(DEFUN |convertOrCroak| (T$ |m|)
  (PROG (|u|)
    (RETURN
      (COND
        ((SPADLET |u| (|convert| T$ |m|)) |u|)
        ('T
         (|userError|
             (CONS '|CANNOT CONVERT: |
                   (CONS (CAR T$)
                         (CONS '|%l|
                               (CONS '| OF MODE: |
                                     (CONS (CADR T$)
                                      (CONS '|%l|
                                       (CONS '| TO MODE: |
                                       (CONS |m| (CONS '|%l| NIL)))))))))))))))

\end{chunk}
\subsection{mkUnion}
\begin{chunk}{*}
;mkUnion(a,b) ==
;  b="$" and $Rep is ["Union",:l] => b
;  a is ["Union",:l] =>
;    b is ["Union",:l'] => ["Union",:setUnion(l,l')]
;    ["Union",:setUnion([b],l)]
;  b is ["Union",:l] => ["Union",:setUnion([a],l)]
;  ["Union",a,b]

(DEFUN |mkUnion| (|a| |b|)
  (PROG (|l'| |l|)
  (declare (special |$Rep|))
    (RETURN
      (COND
        ((AND (BOOT-EQUAL |b| '$) (PAIRP |$Rep|)
              (EQ (QCAR |$Rep|) '|Union|)
              (PROGN (SPADLET |l| (QCDR |$Rep|)) 'T))
         |b|)
        ((AND (PAIRP |a|) (EQ (QCAR |a|) '|Union|)
              (PROGN (SPADLET |l| (QCDR |a|)) 'T))
         (COND
           ((AND (PAIRP |b|) (EQ (QCAR |b|) '|Union|)
                 (PROGN (SPADLET |l'| (QCDR |b|)) 'T))
            (CONS '|Union| (|union| |l| |l'|)))
           ('T (CONS '|Union| (|union| (CONS |b| NIL) |l|)))))
        ((AND (PAIRP |b|) (EQ (QCAR |b|) '|Union|)
              (PROGN (SPADLET |l| (QCDR |b|)) 'T))
         (CONS '|Union| (|union| (CONS |a| NIL) |l|)))
        ('T (CONS '|Union| (CONS |a| (CONS |b| NIL))))))))

\end{chunk}
\subsection{maxSuperType}
\begin{chunk}{*}
;maxSuperType(m,e) ==
;  typ:= get(m,"SuperDomain",e) => maxSuperType(typ,e)
;  m

(DEFUN |maxSuperType| (|m| |e|)
  (PROG (|typ|)
    (RETURN
      (COND
        ((SPADLET |typ| (|get| |m| '|SuperDomain| |e|))
         (|maxSuperType| |typ| |e|))
        ('T |m|)))))

\end{chunk}
\subsection{hasType}
\begin{chunk}{*}
;hasType(x,e) ==
;  fn get(x,"condition",e) where
;    fn x ==
;      null x => nil
;      x is [["case",.,y],:.] => y
;      fn rest x

(DEFUN |hasType,fn| (|x|)
  (PROG (|ISTMP#1| |ISTMP#2| |ISTMP#3| |y|)
    (RETURN
      (SEQ (IF (NULL |x|) (EXIT NIL))
           (IF (AND (PAIRP |x|)
                    (PROGN
                      (SPADLET |ISTMP#1| (QCAR |x|))
                      (AND (PAIRP |ISTMP#1|)
                           (EQ (QCAR |ISTMP#1|) '|case|)
                           (PROGN
                             (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (PAIRP |ISTMP#2|)
                                  (PROGN
                                    (SPADLET |ISTMP#3|
                                     (QCDR |ISTMP#2|))
                                    (AND (PAIRP |ISTMP#3|)
                                     (EQ (QCDR |ISTMP#3|) NIL)
                                     (PROGN
                                       (SPADLET |y| (QCAR |ISTMP#3|))
                                       'T))))))))
               (EXIT |y|))
           (EXIT (|hasType,fn| (CDR |x|)))))))

(DEFUN |hasType| (|x| |e|)
  (|hasType,fn| (|get| |x| '|condition| |e|)))

\end{chunk}
\subsection{outputComp}
\begin{chunk}{*}
;outputComp(x,e) ==
;  u:=comp(['_:_:,x,$Expression],$Expression,e) => u
;  x is ['construct,:argl] =>
;    [['LIST,:[([.,.,e]:=outputComp(x,e)).expr for x in argl]],$Expression,e]
;  (v:= get(x,"value",e)) and (v.mode is ['Union,:l]) =>
;    [['coerceUn2E,x,v.mode],$Expression,e]
;  [x,$Expression,e]

(DEFUN |outputComp| (|x| |e|)
  (PROG (|u| |argl| |LETTMP#1| |v| |ISTMP#1| |l|)
  (declare (special |$Expression|))
    (RETURN
      (SEQ (COND
             ((SPADLET |u|
                       (|comp| (CONS '|::|
                                     (CONS |x|
                                      (CONS |$Expression| NIL)))
                               |$Expression| |e|))
              |u|)
             ((AND (PAIRP |x|) (EQ (QCAR |x|) '|construct|)
                   (PROGN (SPADLET |argl| (QCDR |x|)) 'T))
              (CONS (CONS 'LIST
                          (PROG (G167017)
                            (SPADLET G167017 NIL)
                            (RETURN
                              (DO ((G167025 |argl| (CDR G167025))
                                   (|x| NIL))
                                  ((OR (ATOM G167025)
                                    (PROGN
                                      (SETQ |x| (CAR G167025))
                                      NIL))
                                   (NREVERSE0 G167017))
                                (SEQ (EXIT
                                      (SETQ G167017
                                       (CONS
                                        (CAR
                                         (PROGN
                                           (SPADLET |LETTMP#1|
                                            (|outputComp| |x| |e|))
                                           (SPADLET |e|
                                            (CADDR |LETTMP#1|))
                                           |LETTMP#1|))
                                        G167017))))))))
                    (CONS |$Expression| (CONS |e| NIL))))
             ((AND (SPADLET |v| (|get| |x| '|value| |e|))
                   (PROGN
                     (SPADLET |ISTMP#1| (CADR |v|))
                     (AND (PAIRP |ISTMP#1|)
                          (EQ (QCAR |ISTMP#1|) '|Union|)
                          (PROGN (SPADLET |l| (QCDR |ISTMP#1|)) 'T))))
              (CONS (CONS '|coerceUn2E|
                          (CONS |x| (CONS (CADR |v|) NIL)))
                    (CONS |$Expression| (CONS |e| NIL))))
             ('T (CONS |x| (CONS |$Expression| (CONS |e| NIL)))))))))

\end{chunk}
\subsection{compExpressionList}
\begin{chunk}{*}
;compExpressionList(argl,m,e) ==
;  Tl:= [[.,.,e]:= comp(x,$Expression,e) or return "failed" for x in argl]
;  Tl="failed" => nil
;  convert([["LIST",:[y.expr for y in Tl]],$Expression,e],m)

(DEFUN |compExpressionList| (|argl| |m| |e|)
  (PROG (|LETTMP#1| |Tl|)
  (declare (special |$Expression|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |Tl|
                      (PROG (G167221)
                        (SPADLET G167221 NIL)
                        (RETURN
                          (DO ((G167229 |argl| (CDR G167229))
                               (|x| NIL))
                              ((OR (ATOM G167229)
                                   (PROGN
                                     (SETQ |x| (CAR G167229))
                                     NIL))
                               (NREVERSE0 G167221))
                            (SEQ (EXIT (SETQ G167221
                                        (CONS
                                         (PROGN
                                           (SPADLET |LETTMP#1|
                                            (OR
                                             (|comp| |x| |$Expression|
                                              |e|)
                                             (RETURN '|failed|)))
                                           (SPADLET |e|
                                            (CADDR |LETTMP#1|))
                                           |LETTMP#1|)
                                         G167221))))))))
             (COND
               ((BOOT-EQUAL |Tl| '|failed|) NIL)
               ('T
                (|convert|
                    (CONS (CONS 'LIST
                                (PROG (G167239)
                                  (SPADLET G167239 NIL)
                                  (RETURN
                                    (DO
                                     ((G167244 |Tl| (CDR G167244))
                                      (|y| NIL))
                                     ((OR (ATOM G167244)
                                       (PROGN
                                         (SETQ |y| (CAR G167244))
                                         NIL))
                                      (NREVERSE0 G167239))
                                      (SEQ
                                       (EXIT
                                        (SETQ G167239
                                         (CONS (CAR |y|) G167239))))))))
                          (CONS |$Expression| (CONS |e| NIL)))
                    |m|))))))))

\end{chunk}
\subsection{compFormPartiallyBottomUp}
\begin{chunk}{*}
;compFormPartiallyBottomUp(form,m,e,modemapList,partialModeList) ==
;  mmList:= [mm for mm in modemapList | compFormMatch(mm,partialModeList)] =>
;    compForm3(form,m,e,mmList)

(DEFUN |compFormPartiallyBottomUp|
       (|form| |m| |e| |modemapList| |partialModeList|)
  (PROG (|mmList|)
    (RETURN
      (SEQ (COND
             ((SPADLET |mmList|
                       (PROG (G167545)
                         (SPADLET G167545 NIL)
                         (RETURN
                           (DO ((G167551 |modemapList|
                                    (CDR G167551))
                                (|mm| NIL))
                               ((OR (ATOM G167551)
                                    (PROGN
                                      (SETQ |mm| (CAR G167551))
                                      NIL))
                                (NREVERSE0 G167545))
                             (SEQ (EXIT (COND
                                          ((|compFormMatch| |mm|
                                            |partialModeList|)
                                           (SETQ G167545
                                            (CONS |mm| G167545))))))))))
              (EXIT (|compForm3| |form| |m| |e| |mmList|))))))))

\end{chunk}
\subsection{compFormMatch}
\begin{chunk}{*}
;compFormMatch(mm,partialModeList) ==
;  mm is [[.,.,:argModeList],:.] and match(argModeList,partialModeList) where
;    match(a,b) ==
;      null b => true
;      null first b => match(rest a,rest b)
;      first a=first b and match(rest a,rest b)

(DEFUN |compFormMatch,match| (|a| |b|)
  (SEQ (IF (NULL |b|) (EXIT 'T))
       (IF (NULL (CAR |b|))
           (EXIT (|compFormMatch,match| (CDR |a|) (CDR |b|))))
       (EXIT (AND (BOOT-EQUAL (CAR |a|) (CAR |b|))
                  (|compFormMatch,match| (CDR |a|) (CDR |b|))))))

(DEFUN |compFormMatch| (|mm| |partialModeList|)
  (PROG (|ISTMP#1| |ISTMP#2| |argModeList|)
    (RETURN
      (AND (PAIRP |mm|)
           (PROGN
             (SPADLET |ISTMP#1| (QCAR |mm|))
             (AND (PAIRP |ISTMP#1|)
                  (PROGN
                    (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                    (AND (PAIRP |ISTMP#2|)
                         (PROGN
                           (SPADLET |argModeList| (QCDR |ISTMP#2|))
                           'T)))))
           (|compFormMatch,match| |argModeList| |partialModeList|)))))

\end{chunk}
\subsection{compForm3}
\begin{chunk}{*}
;compForm3(form is [op,:argl],m,e,modemapList) ==
;  T:=
;    or/
;      [compFormWithModemap(form,m,e,first (mml:= ml))
;        for ml in tails modemapList]
;  $compUniquelyIfTrue =>
;    or/[compFormWithModemap(form,m,e,mm) for mm in rest mml] =>
;      THROW("compUniquely",nil)
;    T
;  T

(DEFUN |compForm3| (|form| |m| |e| |modemapList|)
  (PROG (|op| |argl| |mml| T$)
  (declare (special |$compUniquelyIfTrue|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |op| (CAR |form|))
             (SPADLET |argl| (CDR |form|))
             (SPADLET T$
                      (PROG (G167599)
                        (SPADLET G167599 NIL)
                        (RETURN
                          (DO ((G167605 NIL G167599)
                               (|ml| |modemapList| (CDR |ml|)))
                              ((OR G167605 (ATOM |ml|)) G167599)
                            (SEQ (EXIT (SETQ G167599
                                        (OR G167599
                                         (|compFormWithModemap| |form|
                                          |m| |e|
                                          (CAR (SPADLET |mml| |ml|)))))))))))
             (COND
               (|$compUniquelyIfTrue|
                   (COND
                     ((PROG (G167610)
                        (SPADLET G167610 NIL)
                        (RETURN
                          (DO ((G167616 NIL G167610)
                               (G167617 (CDR |mml|) (CDR G167617))
                               (|mm| NIL))
                              ((OR G167616 (ATOM G167617)
                                   (PROGN
                                     (SETQ |mm| (CAR G167617))
                                     NIL))
                               G167610)
                            (SEQ (EXIT (SETQ G167610
                                        (OR G167610
                                         (|compFormWithModemap| |form|
                                          |m| |e| |mm|))))))))
                      (THROW '|compUniquely| NIL))
                     ('T T$)))
               ('T T$)))))))

\end{chunk}
\subsection{getFormModemaps}
\begin{chunk}{*}
;getFormModemaps(form is [op,:argl],e) ==
;  op is ["elt",domain,op1] =>
;    [x for x in getFormModemaps([op1,:argl],e) | x is [[ =domain,:.],:.]]
;  null atom op => nil
;  modemapList:= get(op,"modemap",e)
;  if $insideCategoryPackageIfTrue then
;    modemapList := [x for x in modemapList | x is [[dom,:.],:.] and dom ^= '$]
;  if op="elt"
;     then modemapList:= eltModemapFilter(LAST argl,modemapList,e) or return nil
;     else
;      if op="setelt" then modemapList:=
;        seteltModemapFilter(CADR argl,modemapList,e) or return nil
;  nargs:= #argl
;  finalModemapList:= [mm for (mm:= [[.,.,:sig],:.]) in modemapList | #sig=nargs]
;  modemapList and null finalModemapList =>
;    stackMessage ["no modemap for","%b",op,"%d","with ",nargs," arguments"]
;  finalModemapList

(DEFUN |getFormModemaps| (|form| |e|)
  (PROG (|op| |argl| |domain| |ISTMP#2| |op1| |ISTMP#1| |dom|
              |modemapList| |nargs| |sig| |finalModemapList|)
  (declare (special |$insideCategoryPackageIfTrue|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |op| (CAR |form|))
             (SPADLET |argl| (CDR |form|))
             (COND
               ((AND (PAIRP |op|) (EQ (QCAR |op|) '|elt|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |op|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |domain| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (PAIRP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (PROGN
                                     (SPADLET |op1| (QCAR |ISTMP#2|))
                                     'T))))))
                (PROG (G167686)
                  (SPADLET G167686 NIL)
                  (RETURN
                    (DO ((G167692
                             (|getFormModemaps| (CONS |op1| |argl|)
                                 |e|)
                             (CDR G167692))
                         (|x| NIL))
                        ((OR (ATOM G167692)
                             (PROGN (SETQ |x| (CAR G167692)) NIL))
                         (NREVERSE0 G167686))
                      (SEQ (EXIT (COND
                                   ((AND (PAIRP |x|)
                                     (PROGN
                                       (SPADLET |ISTMP#1| (QCAR |x|))
                                       (AND (PAIRP |ISTMP#1|)
                                        (EQUAL (QCAR |ISTMP#1|)
                                         |domain|))))
                                    (SETQ G167686
                                     (CONS |x| G167686))))))))))
               ((NULL (ATOM |op|)) NIL)
               ('T (SPADLET |modemapList| (|get| |op| '|modemap| |e|))
                (COND
                  (|$insideCategoryPackageIfTrue|
                      (SPADLET |modemapList|
                               (PROG (G167703)
                                 (SPADLET G167703 NIL)
                                 (RETURN
                                   (DO
                                    ((G167709 |modemapList|
                                      (CDR G167709))
                                     (|x| NIL))
                                    ((OR (ATOM G167709)
                                      (PROGN
                                        (SETQ |x| (CAR G167709))
                                        NIL))
                                     (NREVERSE0 G167703))
                                     (SEQ
                                      (EXIT
                                       (COND
                                         ((AND (PAIRP |x|)
                                           (PROGN
                                             (SPADLET |ISTMP#1|
                                              (QCAR |x|))
                                             (AND (PAIRP |ISTMP#1|)
                                              (PROGN
                                                (SPADLET |dom|
                                                 (QCAR |ISTMP#1|))
                                                'T)))
                                           (NEQUAL |dom| '$))
                                          (SETQ G167703
                                           (CONS |x| G167703))))))))))))
                (COND
                  ((BOOT-EQUAL |op| '|elt|)
                   (SPADLET |modemapList|
                            (OR (|eltModemapFilter| (|last| |argl|)
                                    |modemapList| |e|)
                                (RETURN NIL))))
                  ((BOOT-EQUAL |op| '|setelt|)
                   (SPADLET |modemapList|
                            (OR (|seteltModemapFilter| (CADR |argl|)
                                    |modemapList| |e|)
                                (RETURN NIL))))
                  ('T NIL))
                (SPADLET |nargs| (|#| |argl|))
                (SPADLET |finalModemapList|
                         (PROG (G167721)
                           (SPADLET G167721 NIL)
                           (RETURN
                             (DO ((G167728 |modemapList|
                                      (CDR G167728))
                                  (|mm| NIL))
                                 ((OR (ATOM G167728)
                                      (PROGN
                                        (SETQ |mm| (CAR G167728))
                                        NIL)
                                      (PROGN
                                        (PROGN
                                          (SPADLET |sig| (CDDAR |mm|))
                                          |mm|)
                                        NIL))
                                  (NREVERSE0 G167721))
                               (SEQ (EXIT
                                     (COND
                                       ((BOOT-EQUAL (|#| |sig|)
                                         |nargs|)
                                        (SETQ G167721
                                         (CONS |mm| G167721))))))))))
                (COND
                  ((AND |modemapList| (NULL |finalModemapList|))
                   (|stackMessage|
                       (CONS '|no modemap for|
                             (CONS '|%b|
                                   (CONS |op|
                                    (CONS '|%d|
                                     (CONS '|with |
                                      (CONS |nargs|
                                       (CONS '| arguments| NIL)))))))))
                  ('T |finalModemapList|)))))))))

\end{chunk}
\subsection{getConstructorFormOfMode}
\begin{chunk}{*}
;getConstructorFormOfMode(m,e) ==
;  isConstructorForm m => m
;  if m="$" then m:= "Rep"
;  atom m and get(m,"value",e) is [v,:.] =>
;    isConstructorForm v => v

(DEFUN |getConstructorFormOfMode| (|m| |e|)
  (PROG (|ISTMP#1| |v|)
    (RETURN
      (SEQ (COND
             ((|isConstructorForm| |m|) |m|)
             ('T (COND ((BOOT-EQUAL |m| '$) (SPADLET |m| '|Rep|)))
              (SEQ (COND
                     ((AND (ATOM |m|)
                           (PROGN
                             (SPADLET |ISTMP#1|
                                      (|get| |m| '|value| |e|))
                             (AND (PAIRP |ISTMP#1|)
                                  (PROGN
                                    (SPADLET |v| (QCAR |ISTMP#1|))
                                    'T))))
                      (COND ((|isConstructorForm| |v|) (EXIT |v|))))))))))))

\end{chunk}
\subsection{getConstructorMode}
\begin{chunk}{*}
;getConstructorMode(x,e) ==
;  atom x => (u:= getmode(x,e) or return nil; getConstructorFormOfMode(u,e))
;  x is ["elt",y,a] =>
;    u:= getConstructorMode(y,e)
;    u is ["Vector",R] or u is ["List",R] =>
;      isConstructorForm R => R
;    u is ["Record",:l] =>
;      (or/[p is [., =a,R] for p in l]) and isConstructorForm R => R

(DEFUN |getConstructorMode| (|x| |e|)
  (PROG (|y| |a| |u| |l| |ISTMP#1| |ISTMP#2| R)
    (RETURN
      (SEQ (COND
             ((ATOM |x|)
              (SPADLET |u| (OR (|getmode| |x| |e|) (RETURN NIL)))
              (|getConstructorFormOfMode| |u| |e|))
             ((AND (PAIRP |x|) (EQ (QCAR |x|) '|elt|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |x|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |y| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (PAIRP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |a| (QCAR |ISTMP#2|))
                                   'T))))))
              (SPADLET |u| (|getConstructorMode| |y| |e|))
              (SEQ (COND
                     ((OR (AND (PAIRP |u|) (EQ (QCAR |u|) '|Vector|)
                               (PROGN
                                 (SPADLET |ISTMP#1| (QCDR |u|))
                                 (AND (PAIRP |ISTMP#1|)
                                      (EQ (QCDR |ISTMP#1|) NIL)
                                      (PROGN
                                        (SPADLET R (QCAR |ISTMP#1|))
                                        'T))))
                          (AND (PAIRP |u|) (EQ (QCAR |u|) '|List|)
                               (PROGN
                                 (SPADLET |ISTMP#1| (QCDR |u|))
                                 (AND (PAIRP |ISTMP#1|)
                                      (EQ (QCDR |ISTMP#1|) NIL)
                                      (PROGN
                                        (SPADLET R (QCAR |ISTMP#1|))
                                        'T)))))
                      (COND ((|isConstructorForm| R) (EXIT R))))
                     ((AND (PAIRP |u|) (EQ (QCAR |u|) '|Record|)
                           (PROGN (SPADLET |l| (QCDR |u|)) 'T))
                      (COND
                        ((AND (PROG (G167805)
                                (SPADLET G167805 NIL)
                                (RETURN
                                  (DO ((G167817 NIL G167805)
                                       (G167818 |l| (CDR G167818))
                                       (|p| NIL))
                                      ((OR G167817 (ATOM G167818)
                                        (PROGN
                                          (SETQ |p| (CAR G167818))
                                          NIL))
                                       G167805)
                                    (SEQ
                                     (EXIT
                                      (SETQ G167805
                                       (OR G167805
                                        (AND (PAIRP |p|)
                                         (PROGN
                                           (SPADLET |ISTMP#1|
                                            (QCDR |p|))
                                           (AND (PAIRP |ISTMP#1|)
                                            (EQUAL (QCAR |ISTMP#1|)
                                             |a|)
                                            (PROGN
                                              (SPADLET |ISTMP#2|
                                               (QCDR |ISTMP#1|))
                                              (AND (PAIRP |ISTMP#2|)
                                               (EQ (QCDR |ISTMP#2|)
                                                NIL)
                                               (PROGN
                                                 (SPADLET R
                                                  (QCAR |ISTMP#2|))
                                                 'T)))))))))))))
                              (|isConstructorForm| R))
                         (EXIT R))))))))))))

\end{chunk}
\subsection{isConstructorForm}
\begin{chunk}{*}
;isConstructorForm u == u is [name,:.] and MEMBER(name,'(Record Vector List))

(DEFUN |isConstructorForm| (|u|)
  (PROG (|name|)
    (RETURN
      (AND (PAIRP |u|) (PROGN (SPADLET |name| (QCAR |u|)) 'T)
           (|member| |name| '(|Record| |Vector| |List|))))))

\end{chunk}
\subsection{eltModemapFilter}
\begin{chunk}{*}
;eltModemapFilter(name,mmList,e) ==
;  isConstantId(name,e) =>
;    l:= [mm for mm in mmList | mm is [[.,.,.,sel,:.],:.] and sel=name] => l
;            --there are elts with extra parameters
;    stackMessage ["selector variable: ",name," is undeclared and unbound"]
;    nil
;  mmList

(DEFUN |eltModemapFilter| (|name| |mmList| |e|)
  (PROG (|ISTMP#1| |ISTMP#2| |ISTMP#3| |ISTMP#4| |sel| |l|)
    (RETURN
      (SEQ (COND
             ((|isConstantId| |name| |e|)
              (COND
                ((SPADLET |l|
                          (PROG (G167882)
                            (SPADLET G167882 NIL)
                            (RETURN
                              (DO ((G167888 |mmList| (CDR G167888))
                                   (|mm| NIL))
                                  ((OR (ATOM G167888)
                                    (PROGN
                                      (SETQ |mm| (CAR G167888))
                                      NIL))
                                   (NREVERSE0 G167882))
                                (SEQ (EXIT
                                      (COND
                                        ((AND (PAIRP |mm|)
                                          (PROGN
                                            (SPADLET |ISTMP#1|
                                             (QCAR |mm|))
                                            (AND (PAIRP |ISTMP#1|)
                                             (PROGN
                                               (SPADLET |ISTMP#2|
                                                (QCDR |ISTMP#1|))
                                               (AND (PAIRP |ISTMP#2|)
                                                (PROGN
                                                  (SPADLET |ISTMP#3|
                                                   (QCDR |ISTMP#2|))
                                                  (AND
                                                   (PAIRP |ISTMP#3|)
                                                   (PROGN
                                                     (SPADLET |ISTMP#4|
                                                      (QCDR |ISTMP#3|))
                                                     (AND
                                                      (PAIRP |ISTMP#4|)
                                                      (PROGN
                                                        (SPADLET |sel|
                                                         (QCAR
                                                          |ISTMP#4|))
                                                        'T)))))))))
                                          (BOOT-EQUAL |sel| |name|))
                                         (SETQ G167882
                                          (CONS |mm| G167882))))))))))
                 |l|)
                ('T
                 (|stackMessage|
                     (CONS '|selector variable: |
                           (CONS |name|
                                 (CONS '| is undeclared and unbound|
                                       NIL))))
                 NIL)))
             ('T |mmList|))))))

\end{chunk}
\subsection{seteltModemapFilter}
\begin{chunk}{*}
;seteltModemapFilter(name,mmList,e) ==
;  isConstantId(name,e) =>
;    l:= [mm for (mm:= [[.,.,.,sel,:.],:.]) in mmList | sel=name] => l
;            --there are setelts with extra parameters
;    stackMessage ["selector variable: ",name," is undeclared and unbound"]
;    nil
;  mmList

(DEFUN |seteltModemapFilter| (|name| |mmList| |e|)
  (PROG (|sel| |l|)
    (RETURN
      (SEQ (COND
             ((|isConstantId| |name| |e|)
              (COND
                ((SPADLET |l|
                          (PROG (G167914)
                            (SPADLET G167914 NIL)
                            (RETURN
                              (DO ((G167921 |mmList| (CDR G167921))
                                   (|mm| NIL))
                                  ((OR (ATOM G167921)
                                    (PROGN
                                      (SETQ |mm| (CAR G167921))
                                      NIL)
                                    (PROGN
                                      (PROGN
                                        (SPADLET |sel|
                                         (CAR (CDDDAR |mm|)))
                                        |mm|)
                                      NIL))
                                   (NREVERSE0 G167914))
                                (SEQ (EXIT
                                      (COND
                                        ((BOOT-EQUAL |sel| |name|)
                                         (SETQ G167914
                                          (CONS |mm| G167914))))))))))
                 |l|)
                ('T
                 (|stackMessage|
                     (CONS '|selector variable: |
                           (CONS |name|
                                 (CONS '| is undeclared and unbound|
                                       NIL))))
                 NIL)))
             ('T |mmList|))))))

\end{chunk}
\subsection{substituteIntoFunctorModemap}
\begin{chunk}{*}
;substituteIntoFunctorModemap(argl,modemap is [[dc,:sig],:.],e) ==
;  #dc^=#sig =>
;    keyedSystemError("S2GE0016",['"substituteIntoFunctorModemap",
;      '"Incompatible maps"])
;  #argl=#rest sig =>
;                        --here, we actually have a functor form
;    sig:= EQSUBSTLIST(argl,rest dc,sig)
;      --make new modemap, subst. actual for formal parametersinto modemap
;    Tl:= [[.,.,e]:= compOrCroak(a,m,e) for a in argl for m in rest sig]
;    substitutionList:= [[x,:T.expr] for x in rest dc for T in Tl]
;    [SUBLIS(substitutionList,modemap),e]
;  nil

(DEFUN |substituteIntoFunctorModemap| (|argl| |modemap| |e|)
  (PROG (|dc| |sig| |LETTMP#1| |Tl| |substitutionList|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |dc| (CAAR |modemap|))
             (SPADLET |sig| (CDAR |modemap|))
             (COND
               ((NEQUAL (|#| |dc|) (|#| |sig|))
                (|keyedSystemError| 'S2GE0016
                    (CONS "substituteIntoFunctorModemap"
                          (CONS "Incompatible maps" NIL))))
               ((BOOT-EQUAL (|#| |argl|) (|#| (CDR |sig|)))
                (SPADLET |sig| (EQSUBSTLIST |argl| (CDR |dc|) |sig|))
                (SPADLET |Tl|
                         (PROG (G167960)
                           (SPADLET G167960 NIL)
                           (RETURN
                             (DO ((G167969 |argl| (CDR G167969))
                                  (|a| NIL)
                                  (G167970 (CDR |sig|)
                                      (CDR G167970))
                                  (|m| NIL))
                                 ((OR (ATOM G167969)
                                      (PROGN
                                        (SETQ |a| (CAR G167969))
                                        NIL)
                                      (ATOM G167970)
                                      (PROGN
                                        (SETQ |m| (CAR G167970))
                                        NIL))
                                  (NREVERSE0 G167960))
                               (SEQ (EXIT
                                     (SETQ G167960
                                      (CONS
                                       (PROGN
                                         (SPADLET |LETTMP#1|
                                          (|compOrCroak| |a| |m| |e|))
                                         (SPADLET |e|
                                          (CADDR |LETTMP#1|))
                                         |LETTMP#1|)
                                       G167960))))))))
                (SPADLET |substitutionList|
                         (PROG (G167984)
                           (SPADLET G167984 NIL)
                           (RETURN
                             (DO ((G167990 (CDR |dc|)
                                      (CDR G167990))
                                  (|x| NIL)
                                  (G167991 |Tl| (CDR G167991))
                                  (T$ NIL))
                                 ((OR (ATOM G167990)
                                      (PROGN
                                        (SETQ |x| (CAR G167990))
                                        NIL)
                                      (ATOM G167991)
                                      (PROGN
                                        (SETQ T$ (CAR G167991))
                                        NIL))
                                  (NREVERSE0 G167984))
                               (SEQ (EXIT
                                     (SETQ G167984
                                      (CONS (CONS |x| (CAR T$))
                                       G167984))))))))
                (CONS (SUBLIS |substitutionList| |modemap|)
                      (CONS |e| NIL)))
               ('T NIL)))))))

\end{chunk}

\subsection{assignError}
\begin{chunk}{*}
;assignError(val,m',form,m) ==
;  message:=
;    val =>
;      ["CANNOT ASSIGN: ",val,"%l","   OF MODE: ",m',"%l","   TO: ",form,"%l",
;        "   OF MODE: ",m]
;    ["CANNOT ASSIGN: ",val,"%l","   TO: ",form,"%l","   OF MODE: ",m]
;  stackMessage message

(DEFUN |assignError| (|val| |m'| |form| |m|)
  (PROG (|message|)
    (RETURN
      (PROGN
        (SPADLET |message|
                 (COND
                   (|val| (CONS '|CANNOT ASSIGN: |
                                (CONS |val|
                                      (CONS '|%l|
                                       (CONS '|   OF MODE: |
                                        (CONS |m'|
                                         (CONS '|%l|
                                          (CONS '|   TO: |
                                           (CONS |form|
                                            (CONS '|%l|
                                             (CONS '|   OF MODE: |
                                              (CONS |m| NIL))))))))))))
                   ('T
                    (CONS '|CANNOT ASSIGN: |
                          (CONS |val|
                                (CONS '|%l|
                                      (CONS '|   TO: |
                                       (CONS |form|
                                        (CONS '|%l|
                                         (CONS '|   OF MODE: |
                                          (CONS |m| NIL)))))))))))
        (|stackMessage| |message|)))))

\end{chunk}
\subsection{setqMultiple}
\begin{chunk}{*}
;setqMultiple(nameList,val,m,e) ==
;  val is ["CONS",:.] and m=$NoValueMode =>
;    setqMultipleExplicit(nameList,uncons val,m,e)
;  val is ["Tuple",:l] and m=$NoValueMode => setqMultipleExplicit(nameList,l,m,e)
;  1 --create a gensym, %add to local environment, compile and assign rhs
;  g:= genVariable()
;  e:= addBinding(g,nil,e)
;  T:= [.,m1,.]:= compSetq1(g,val,$EmptyMode,e) or return nil
;  e:= put(g,"mode",m1,e)
;  [x,m',e]:= convert(T,m) or return nil
;  1.1 --exit if result is a list
;  m1 is ["List",D] =>
;    for y in nameList repeat e:= put(y,"value",[genSomeVariable(),D,$noEnv],e)
;    convert([["PROGN",x,["LET",nameList,g],g],m',e],m)
;  2 --verify that the #nameList = number of parts of right-hand-side
;  selectorModePairs:=
;                                                --list of modes
;    decompose(m1,#nameList,e) or return nil where
;      decompose(t,length,e) ==
;        t is ["Record",:l] => [[name,:mode] for [":",name,mode] in l]
;        comp(t,$EmptyMode,e) is [.,["RecordCategory",:l],.] =>
;          [[name,:mode] for [":",name,mode] in l]
;        stackMessage ["no multiple assigns to mode: ",t]
;  #nameList^=#selectorModePairs =>
;    stackMessage [val," must decompose into ",#nameList," components"]
;  3 --generate code; return
;  assignList:=
;    [([.,.,e]:= compSetq1(x,["elt",g,y],z,e) or return "failed").expr
;      for x in nameList for [y,:z] in selectorModePairs]
;  if assignList="failed" then NIL
;  else [MKPROGN [x,:assignList,g],m',e]

(DEFUN |setqMultiple,decompose| (|t| |length| |e|)
  (declare (ignore |length|))
  (PROG (|ISTMP#1| |ISTMP#2| |ISTMP#3| |l| |ISTMP#4| |name| |mode|)
  (declare (special |$EmptyMode|))
    (RETURN
      (SEQ (IF (AND (PAIRP |t|) (EQ (QCAR |t|) '|Record|)
                    (PROGN (SPADLET |l| (QCDR |t|)) 'T))
               (EXIT (PROG (G168310)
                       (SPADLET G168310 NIL)
                       (RETURN
                         (DO ((G168316 |l| (CDR G168316))
                              (G168272 NIL))
                             ((OR (ATOM G168316)
                                  (PROGN
                                    (SETQ G168272 (CAR G168316))
                                    NIL)
                                  (PROGN
                                    (PROGN
                                      (SPADLET |name| (CADR G168272))
                                      (SPADLET |mode|
                                       (CADDR G168272))
                                      G168272)
                                    NIL))
                              (NREVERSE0 G168310))
                           (SEQ (EXIT (SETQ G168310
                                       (CONS (CONS |name| |mode|)
                                        G168310)))))))))
           (IF (PROGN
                 (SPADLET |ISTMP#1| (|comp| |t| |$EmptyMode| |e|))
                 (AND (PAIRP |ISTMP#1|)
                      (PROGN
                        (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                        (AND (PAIRP |ISTMP#2|)
                             (PROGN
                               (SPADLET |ISTMP#3| (QCAR |ISTMP#2|))
                               (AND (PAIRP |ISTMP#3|)
                                    (EQ (QCAR |ISTMP#3|)
                                     '|RecordCategory|)
                                    (PROGN
                                      (SPADLET |l| (QCDR |ISTMP#3|))
                                      'T)))
                             (PROGN
                               (SPADLET |ISTMP#4| (QCDR |ISTMP#2|))
                               (AND (PAIRP |ISTMP#4|)
                                    (EQ (QCDR |ISTMP#4|) NIL)))))))
               (EXIT (PROG (G168328)
                       (SPADLET G168328 NIL)
                       (RETURN
                         (DO ((G168334 |l| (CDR G168334))
                              (G168300 NIL))
                             ((OR (ATOM G168334)
                                  (PROGN
                                    (SETQ G168300 (CAR G168334))
                                    NIL)
                                  (PROGN
                                    (PROGN
                                      (SPADLET |name| (CADR G168300))
                                      (SPADLET |mode|
                                       (CADDR G168300))
                                      G168300)
                                    NIL))
                              (NREVERSE0 G168328))
                           (SEQ (EXIT (SETQ G168328
                                       (CONS (CONS |name| |mode|)
                                        G168328)))))))))
           (EXIT (|stackMessage|
                     (CONS '|no multiple assigns to mode: |
                           (CONS |t| NIL))))))))


(DEFUN |setqMultiple| (|nameList| |val| |m| |e|)
  (PROG (|l| |g| |m1| T$ |x| |m'| |ISTMP#1| D |selectorModePairs| |y|
             |z| |LETTMP#1| |assignList|)
  (declare (special |$noEnv| |$EmptyMode| |$NoValueMode|))
    (RETURN
      (SEQ (COND
             ((AND (PAIRP |val|) (EQ (QCAR |val|) 'CONS)
                   (BOOT-EQUAL |m| |$NoValueMode|))
              (|setqMultipleExplicit| |nameList| (|uncons| |val|) |m|
                  |e|))
             ((AND (PAIRP |val|) (EQ (QCAR |val|) '|@Tuple|)
                   (PROGN (SPADLET |l| (QCDR |val|)) 'T)
                   (BOOT-EQUAL |m| |$NoValueMode|))
              (|setqMultipleExplicit| |nameList| |l| |m| |e|))
             ('T (SPADLET |g| (|genVariable|))
              (SPADLET |e| (|addBinding| |g| NIL |e|))
              (SPADLET T$
                       (PROGN
                         (SPADLET |LETTMP#1|
                                  (OR (|compSetq1| |g| |val|
                                       |$EmptyMode| |e|)
                                      (RETURN NIL)))
                         (SPADLET |m1| (CADR |LETTMP#1|))
                         |LETTMP#1|))
              (SPADLET |e| (|put| |g| '|mode| |m1| |e|))
              (SPADLET |LETTMP#1| (OR (|convert| T$ |m|) (RETURN NIL)))
              (SPADLET |x| (CAR |LETTMP#1|))
              (SPADLET |m'| (CADR |LETTMP#1|))
              (SPADLET |e| (CADDR |LETTMP#1|))
              (COND
                ((AND (PAIRP |m1|) (EQ (QCAR |m1|) '|List|)
                      (PROGN
                        (SPADLET |ISTMP#1| (QCDR |m1|))
                        (AND (PAIRP |ISTMP#1|)
                             (EQ (QCDR |ISTMP#1|) NIL)
                             (PROGN (SPADLET D (QCAR |ISTMP#1|)) 'T))))
                 (DO ((G168370 |nameList| (CDR G168370)) (|y| NIL))
                     ((OR (ATOM G168370)
                          (PROGN (SETQ |y| (CAR G168370)) NIL))
                      NIL)
                   (SEQ (EXIT (SPADLET |e|
                                       (|put| |y| '|value|
                                        (CONS (|genSomeVariable|)
                                         (CONS D (CONS |$noEnv| NIL)))
                                        |e|)))))
                 (|convert|
                     (CONS (CONS 'PROGN
                                 (CONS |x|
                                       (CONS
                                        (CONS 'LET
                                         (CONS |nameList|
                                          (CONS |g| NIL)))
                                        (CONS |g| NIL))))
                           (CONS |m'| (CONS |e| NIL)))
                     |m|))
                ('T
                 (SPADLET |selectorModePairs|
                          (OR (|setqMultiple,decompose| |m1|
                                  (|#| |nameList|) |e|)
                              (RETURN NIL)))
                 (COND
                   ((NEQUAL (|#| |nameList|) (|#| |selectorModePairs|))
                    (|stackMessage|
                        (CONS |val|
                              (CONS '| must decompose into |
                                    (CONS (|#| |nameList|)
                                     (CONS '| components| NIL))))))
                   ('T
                    (SPADLET |assignList|
                             (PROG (G168385)
                               (SPADLET G168385 NIL)
                               (RETURN
                                 (DO ((G168395 |nameList|
                                       (CDR G168395))
                                      (|x| NIL)
                                      (G168396 |selectorModePairs|
                                       (CDR G168396))
                                      (G168362 NIL))
                                     ((OR (ATOM G168395)
                                       (PROGN
                                         (SETQ |x| (CAR G168395))
                                         NIL)
                                       (ATOM G168396)
                                       (PROGN
                                         (SETQ G168362
                                          (CAR G168396))
                                         NIL)
                                       (PROGN
                                         (PROGN
                                           (SPADLET |y|
                                            (CAR G168362))
                                           (SPADLET |z|
                                            (CDR G168362))
                                           G168362)
                                         NIL))
                                      (NREVERSE0 G168385))
                                   (SEQ
                                    (EXIT
                                     (SETQ G168385
                                      (CONS
                                       (CAR
                                        (PROGN
                                          (SPADLET |LETTMP#1|
                                           (OR
                                            (|compSetq1| |x|
                                             (CONS '|elt|
                                              (CONS |g| (CONS |y| NIL)))
                                             |z| |e|)
                                            (RETURN '|failed|)))
                                          (SPADLET |e|
                                           (CADDR |LETTMP#1|))
                                          |LETTMP#1|))
                                       G168385))))))))
                    (COND
                      ((BOOT-EQUAL |assignList| '|failed|) NIL)
                      ('T
                       (CONS (MKPROGN (CONS |x|
                                       (APPEND |assignList|
                                        (CONS |g| NIL))))
                             (CONS |m'| (CONS |e| NIL)))))))))))))))

\end{chunk}
\subsection{setqMultipleExplicit}
\begin{chunk}{*}
;setqMultipleExplicit(nameList,valList,m,e) ==
;  #nameList^=#valList =>
;    stackMessage ["Multiple assignment error; # of items in: ",nameList,
;      "must = # in: ",valList]
;  gensymList:= [genVariable() for name in nameList]
;  assignList:=
;             --should be fixed to declare genVar when possible
;    [[.,.,e]:= compSetq1(g,val,$EmptyMode,e) or return "failed"
;      for g in gensymList for val in valList]
;  assignList="failed" => nil
;  reAssignList:=
;    [[.,.,e]:= compSetq1(name,g,$EmptyMode,e) or return "failed"
;      for g in gensymList for name in nameList]
;  reAssignList="failed" => nil
;  [["PROGN",:[T.expr for T in assignList],:[T.expr for T in reAssignList]],
;    $NoValueMode, (LAST reAssignList).env]

(DEFUN |setqMultipleExplicit| (|nameList| |valList| |m| |e|)
  (declare (special |m|))
  (PROG (|gensymList| |assignList| |LETTMP#1| |reAssignList|)
  (declare (special |$NoValueMode| |$EmptyMode|))
    (RETURN
      (SEQ (COND
             ((NEQUAL (|#| |nameList|) (|#| |valList|))
              (|stackMessage|
                  (CONS '|Multiple assignment error; # of items in: |
                        (CONS |nameList|
                              (CONS '|must = # in: |
                                    (CONS |valList| NIL))))))
             ('T
              (SPADLET |gensymList|
                       (PROG (G168445)
                         (SPADLET G168445 NIL)
                         (RETURN
                           (DO ((G168450 |nameList| (CDR G168450))
                                (|name| NIL))
                               ((OR (ATOM G168450)
                                    (PROGN
                                      (SETQ |name| (CAR G168450))
                                      NIL))
                                (NREVERSE0 G168445))
                             (SEQ (EXIT (SETQ G168445
                                         (CONS (|genVariable|)
                                          G168445))))))))
              (SPADLET |assignList|
                       (PROG (G168464)
                         (SPADLET G168464 NIL)
                         (RETURN
                           (DO ((G168473 |gensymList|
                                    (CDR G168473))
                                (|g| NIL)
                                (G168474 |valList| (CDR G168474))
                                (|val| NIL))
                               ((OR (ATOM G168473)
                                    (PROGN
                                      (SETQ |g| (CAR G168473))
                                      NIL)
                                    (ATOM G168474)
                                    (PROGN
                                      (SETQ |val| (CAR G168474))
                                      NIL))
                                (NREVERSE0 G168464))
                             (SEQ (EXIT (SETQ G168464
                                         (CONS
                                          (PROGN
                                            (SPADLET |LETTMP#1|
                                             (OR
                                              (|compSetq1| |g| |val|
                                               |$EmptyMode| |e|)
                                              (RETURN '|failed|)))
                                            (SPADLET |e|
                                             (CADDR |LETTMP#1|))
                                            |LETTMP#1|)
                                          G168464))))))))
              (COND
                ((BOOT-EQUAL |assignList| '|failed|) NIL)
                ('T
                 (SPADLET |reAssignList|
                          (PROG (G168491)
                            (SPADLET G168491 NIL)
                            (RETURN
                              (DO ((G168500 |gensymList|
                                    (CDR G168500))
                                   (|g| NIL)
                                   (G168501 |nameList|
                                    (CDR G168501))
                                   (|name| NIL))
                                  ((OR (ATOM G168500)
                                    (PROGN
                                      (SETQ |g| (CAR G168500))
                                      NIL)
                                    (ATOM G168501)
                                    (PROGN
                                      (SETQ |name| (CAR G168501))
                                      NIL))
                                   (NREVERSE0 G168491))
                                (SEQ (EXIT
                                      (SETQ G168491
                                       (CONS
                                        (PROGN
                                          (SPADLET |LETTMP#1|
                                           (OR
                                            (|compSetq1| |name| |g|
                                             |$EmptyMode| |e|)
                                            (RETURN '|failed|)))
                                          (SPADLET |e|
                                           (CADDR |LETTMP#1|))
                                          |LETTMP#1|)
                                        G168491))))))))
                 (COND
                   ((BOOT-EQUAL |reAssignList| '|failed|) NIL)
                   ('T
                    (CONS (CONS 'PROGN
                                (APPEND (PROG (G168514)
                                          (SPADLET G168514 NIL)
                                          (RETURN
                                            (DO
                                             ((G168519 |assignList|
                                               (CDR G168519))
                                              (T$ NIL))
                                             ((OR (ATOM G168519)
                                               (PROGN
                                                 (SETQ T$
                                                  (CAR G168519))
                                                 NIL))
                                              (NREVERSE0 G168514))
                                              (SEQ
                                               (EXIT
                                                (SETQ G168514
                                                 (CONS (CAR T$)
                                                  G168514)))))))
                                        (PROG (G168529)
                                          (SPADLET G168529 NIL)
                                          (RETURN
                                            (DO
                                             ((G168534 |reAssignList|
                                               (CDR G168534))
                                              (T$ NIL))
                                             ((OR (ATOM G168534)
                                               (PROGN
                                                 (SETQ T$
                                                  (CAR G168534))
                                                 NIL))
                                              (NREVERSE0 G168529))
                                              (SEQ
                                               (EXIT
                                                (SETQ G168529
                                                 (CONS (CAR T$)
                                                  G168529)))))))))
                          (CONS |$NoValueMode|
                                (CONS (CADDR (|last| |reAssignList|))
                                      NIL)))))))))))))

\end{chunk}
\subsection{replaceExitEtc}
\begin{chunk}{*}
;replaceExitEtc(x,tag,opFlag,opMode) ==
;  (fn(x,tag,opFlag,opMode); x) where
;    fn(x,tag,opFlag,opMode) ==
;      atom x => nil
;      x is ["QUOTE",:.] => nil
;      x is [ =opFlag,n,t] =>
;        rplac(CAADDR x,replaceExitEtc(CAADDR x,tag,opFlag,opMode))
;        n=0 =>
;          $finalEnv:=
;                  --bound in compSeq1 and compDefineCapsuleFunction
;            $finalEnv => intersectionEnvironment($finalEnv,t.env)
;            t.env
;          rplac(first x,"THROW")
;          rplac(CADR x,tag)
;          rplac(CADDR x,(convertOrCroak(t,opMode)).expr)
;        true => rplac(CADR x,CADR x-1)
;      x is [key,n,t] and MEMQ(key,'(TAGGEDreturn TAGGEDexit)) =>
;        rplac(first t,replaceExitEtc(first t,tag,opFlag,opMode))
;      replaceExitEtc(first x,tag,opFlag,opMode)
;      replaceExitEtc(rest x,tag,opFlag,opMode)

(DEFUN |replaceExitEtc,fn| (|x| |tag| |opFlag| |opMode|)
  (PROG (|key| |ISTMP#1| |n| |ISTMP#2| |t|)
  (declare (special |$finalEnv|))
    (RETURN
      (SEQ (IF (ATOM |x|) (EXIT NIL))
           (IF (AND (PAIRP |x|) (EQ (QCAR |x|) 'QUOTE)) (EXIT NIL))
           (IF (AND (PAIRP |x|) (EQUAL (QCAR |x|) |opFlag|)
                    (PROGN
                      (SPADLET |ISTMP#1| (QCDR |x|))
                      (AND (PAIRP |ISTMP#1|)
                           (PROGN
                             (SPADLET |n| (QCAR |ISTMP#1|))
                             (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (PAIRP |ISTMP#2|)
                                  (EQ (QCDR |ISTMP#2|) NIL)
                                  (PROGN
                                    (SPADLET |t| (QCAR |ISTMP#2|))
                                    'T))))))
               (EXIT (SEQ (|rplac| (CAADDR |x|)
                                   (|replaceExitEtc| (CAADDR |x|) |tag|
                                    |opFlag| |opMode|))
                          (IF (EQL |n| 0)
                              (EXIT (SEQ
                                     (SPADLET |$finalEnv|
                                      (SEQ
                                       (IF |$finalEnv|
                                        (EXIT
                                         (|intersectionEnvironment|
                                          |$finalEnv| (CADDR |t|))))
                                       (EXIT (CADDR |t|))))
                                     (|rplac| (CAR |x|) 'THROW)
                                     (|rplac| (CADR |x|) |tag|)
                                     (EXIT
                                      (|rplac| (CADDR |x|)
                                       (CAR
                                        (|convertOrCroak| |t| |opMode|)))))))
                          (EXIT (IF 'T
                                    (EXIT
                                     (|rplac| (CADR |x|)
                                      (SPADDIFFERENCE (CADR |x|) 1))))))))
           (IF (AND (AND (PAIRP |x|)
                         (PROGN
                           (SPADLET |key| (QCAR |x|))
                           (SPADLET |ISTMP#1| (QCDR |x|))
                           (AND (PAIRP |ISTMP#1|)
                                (PROGN
                                  (SPADLET |n| (QCAR |ISTMP#1|))
                                  (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                                  (AND (PAIRP |ISTMP#2|)
                                       (EQ (QCDR |ISTMP#2|) NIL)
                                       (PROGN
                                         (SPADLET |t| (QCAR |ISTMP#2|))
                                         'T))))))
                    (member |key| '(|TAGGEDreturn| |TAGGEDexit|)))
               (EXIT (|rplac| (CAR |t|)
                              (|replaceExitEtc| (CAR |t|) |tag|
                                  |opFlag| |opMode|))))
           (|replaceExitEtc| (CAR |x|) |tag| |opFlag| |opMode|)
           (EXIT (|replaceExitEtc| (CDR |x|) |tag| |opFlag| |opMode|))))))


(DEFUN |replaceExitEtc| (|x| |tag| |opFlag| |opMode|)
  (PROGN (|replaceExitEtc,fn| |x| |tag| |opFlag| |opMode|) |x|))

\end{chunk}
\subsection{compHasFormat}
\begin{chunk}{*}
;compHasFormat (pred is ["has",olda,b]) ==
;  argl := rest $form
;  formals := TAKE(#argl,$FormalMapVariableList)
;  a := SUBLISLIS(argl,formals,olda)
;  [a,:.] := comp(a,$EmptyMode,$e) or return nil
;  a := SUBLISLIS(formals,argl,a)
;  b is ["ATTRIBUTE",c] => ["HasAttribute",a,["QUOTE",c]]
;  b is ["SIGNATURE",op,sig] =>
;     ["HasSignature",a,
;       mkList [MKQ op,mkList [mkDomainConstructor type for type in sig]]]
;  isDomainForm(b,$EmptyEnvironment) => ["EQUAL",a,b]
;  ["HasCategory",a,mkDomainConstructor b]

(DEFUN |compHasFormat| (|pred|)
  (PROG (|olda| |b| |argl| |formals| |LETTMP#1| |a| |c| |ISTMP#1| |op|
                |ISTMP#2| |sig|)
  (declare (special |$EmptyEnvironment| |$e| |$EmptyMode|
                    |$FormalMapVariableList| |$form|))
    (RETURN
      (SEQ (PROGN
             (COND ((EQ (CAR |pred|) '|has|) (CAR |pred|)))
             (SPADLET |olda| (CADR |pred|))
             (SPADLET |b| (CADDR |pred|))
             (SPADLET |argl| (CDR |$form|))
             (SPADLET |formals|
                      (TAKE (|#| |argl|) |$FormalMapVariableList|))
             (SPADLET |a| (SUBLISLIS |argl| |formals| |olda|))
             (SPADLET |LETTMP#1|
                      (OR (|comp| |a| |$EmptyMode| |$e|) (RETURN NIL)))
             (SPADLET |a| (CAR |LETTMP#1|))
             (SPADLET |a| (SUBLISLIS |formals| |argl| |a|))
             (COND
               ((AND (PAIRP |b|) (EQ (QCAR |b|) 'ATTRIBUTE)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |b|))
                       (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN (SPADLET |c| (QCAR |ISTMP#1|)) 'T))))
                (CONS '|HasAttribute|
                      (CONS |a|
                            (CONS (CONS 'QUOTE (CONS |c| NIL)) NIL))))
               ((AND (PAIRP |b|) (EQ (QCAR |b|) 'SIGNATURE)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |b|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |op| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (PAIRP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (PROGN
                                     (SPADLET |sig| (QCAR |ISTMP#2|))
                                     'T))))))
                (CONS '|HasSignature|
                      (CONS |a|
                            (CONS (|mkList|
                                      (CONS (MKQ |op|)
                                       (CONS
                                        (|mkList|
                                         (PROG (G169224)
                                           (SPADLET G169224 NIL)
                                           (RETURN
                                             (DO
                                              ((G169229 |sig|
                                                (CDR G169229))
                                               (|type| NIL))
                                              ((OR (ATOM G169229)
                                                (PROGN
                                                  (SETQ |type|
                                                   (CAR G169229))
                                                  NIL))
                                               (NREVERSE0 G169224))
                                               (SEQ
                                                (EXIT
                                                 (SETQ G169224
                                                  (CONS
                                                   (|mkDomainConstructor|
                                                    |type|)
                                                   G169224))))))))
                                        NIL)))
                                  NIL))))
               ((|isDomainForm| |b| |$EmptyEnvironment|)
                (CONS 'EQUAL (CONS |a| (CONS |b| NIL))))
               ('T
                (CONS '|HasCategory|
                      (CONS |a| (CONS (|mkDomainConstructor| |b|) NIL))))))))))

\end{chunk}
\subsection{canReturn}
\begin{chunk}{*}
;canReturn(expr,level,exitCount,ValueFlag) ==  --SPAD: exit and friends
;  atom expr => ValueFlag and level=exitCount
;  (op:= first expr)="QUOTE" => ValueFlag and level=exitCount
;  op="TAGGEDexit" =>
;    expr is [.,count,data] => canReturn(data.expr,level,count,count=level)
;  level=exitCount and not ValueFlag => nil
;  op="SEQ" => or/[canReturn(u,level+1,exitCount,false) for u in rest expr]
;  op="TAGGEDreturn" => nil
;  op="CATCH" =>
;    [.,gs,data]:= expr
;    (findThrow(gs,data,level,exitCount,ValueFlag) => true) where
;      findThrow(gs,expr,level,exitCount,ValueFlag) ==
;        atom expr => nil
;        expr is ["THROW", =gs,data] => true
;            --this is pessimistic, but I know of no more accurate idea
;        expr is ["SEQ",:l] =>
;          or/[findThrow(gs,u,level+1,exitCount,ValueFlag) for u in l]
;        or/[findThrow(gs,u,level,exitCount,ValueFlag) for u in rest expr]
;    canReturn(data,level,exitCount,ValueFlag)
;  op = "COND" =>
;    level = exitCount =>
;      or/[canReturn(last u,level,exitCount,ValueFlag) for u in rest expr]
;    or/[or/[canReturn(u,level,exitCount,ValueFlag) for u in v]
;                for v in rest expr]
;  op="IF" =>
;    expr is [.,a,b,c]
;    if not canReturn(a,0,0,true) then
;      SAY "IF statement can not cause consequents to be executed"
;      pp expr
;    canReturn(a,level,exitCount,nil) or canReturn(b,level,exitCount,ValueFlag)
;      or canReturn(c,level,exitCount,ValueFlag)
;  --now we have an ordinary form
;  atom op => and/[canReturn(u,level,exitCount,ValueFlag) for u in expr]
;  op is ["XLAM",args,bods] =>
;    and/[canReturn(u,level,exitCount,ValueFlag) for u in expr]
;  systemErrorHere '"canReturn" --for the time being

(DEFUN |canReturn,findThrow|
       (|gs| |expr| |level| |exitCount| |ValueFlag|)
  (PROG (|ISTMP#1| |ISTMP#2| |data| |l|)
    (RETURN
      (SEQ (IF (ATOM |expr|) (EXIT NIL))
           (IF (AND (PAIRP |expr|) (EQ (QCAR |expr|) 'THROW)
                    (PROGN
                      (SPADLET |ISTMP#1| (QCDR |expr|))
                      (AND (PAIRP |ISTMP#1|)
                           (EQUAL (QCAR |ISTMP#1|) |gs|)
                           (PROGN
                             (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (PAIRP |ISTMP#2|)
                                  (EQ (QCDR |ISTMP#2|) NIL)
                                  (PROGN
                                    (SPADLET |data| (QCAR |ISTMP#2|))
                                    'T))))))
               (EXIT 'T))
           (IF (AND (PAIRP |expr|) (EQ (QCAR |expr|) 'SEQ)
                    (PROGN (SPADLET |l| (QCDR |expr|)) 'T))
               (EXIT (PROG (G169370)
                       (SPADLET G169370 NIL)
                       (RETURN
                         (DO ((G169376 NIL G169370)
                              (G169377 |l| (CDR G169377))
                              (|u| NIL))
                             ((OR G169376 (ATOM G169377)
                                  (PROGN
                                    (SETQ |u| (CAR G169377))
                                    NIL))
                              G169370)
                           (SEQ (EXIT (SETQ G169370
                                       (OR G169370
                                        (|canReturn,findThrow| |gs| |u|
                                         (PLUS |level| 1) |exitCount|
                                         |ValueFlag|))))))))))
           (EXIT (PROG (G169384)
                   (SPADLET G169384 NIL)
                   (RETURN
                     (DO ((G169390 NIL G169384)
                          (G169391 (CDR |expr|) (CDR G169391))
                          (|u| NIL))
                         ((OR G169390 (ATOM G169391)
                              (PROGN (SETQ |u| (CAR G169391)) NIL))
                          G169384)
                       (SEQ (EXIT (SETQ G169384
                                        (OR G169384
                                         (|canReturn,findThrow| |gs|
                                          |u| |level| |exitCount|
                                          |ValueFlag|)))))))))))))

(DEFUN |canReturn| (|expr| |level| |exitCount| |ValueFlag|)
  (PROG (|op| |count| |gs| |data| |a| |b| |ISTMP#3| |c| |ISTMP#1|
              |args| |ISTMP#2| |bods|)
    (RETURN
      (SEQ (COND
             ((ATOM |expr|)
              (AND |ValueFlag| (BOOT-EQUAL |level| |exitCount|)))
             ((BOOT-EQUAL (SPADLET |op| (CAR |expr|)) 'QUOTE)
              (AND |ValueFlag| (BOOT-EQUAL |level| |exitCount|)))
             ((BOOT-EQUAL |op| '|TAGGEDexit|)
              (COND
                ((AND (PAIRP |expr|)
                      (PROGN
                        (SPADLET |ISTMP#1| (QCDR |expr|))
                        (AND (PAIRP |ISTMP#1|)
                             (PROGN
                               (SPADLET |count| (QCAR |ISTMP#1|))
                               (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                               (AND (PAIRP |ISTMP#2|)
                                    (EQ (QCDR |ISTMP#2|) NIL)
                                    (PROGN
                                      (SPADLET |data| (QCAR |ISTMP#2|))
                                      'T))))))
                 (EXIT (|canReturn| (CAR |data|) |level| |count|
                           (BOOT-EQUAL |count| |level|))))))
             ((AND (BOOT-EQUAL |level| |exitCount|) (NULL |ValueFlag|))
              NIL)
             ((BOOT-EQUAL |op| 'SEQ)
              (PROG (G169463)
                (SPADLET G169463 NIL)
                (RETURN
                  (DO ((G169469 NIL G169463)
                       (G169470 (CDR |expr|) (CDR G169470))
                       (|u| NIL))
                      ((OR G169469 (ATOM G169470)
                           (PROGN (SETQ |u| (CAR G169470)) NIL))
                       G169463)
                    (SEQ (EXIT (SETQ G169463
                                     (OR G169463
                                      (|canReturn| |u| (PLUS |level| 1)
                                       |exitCount| NIL)))))))))
             ((BOOT-EQUAL |op| '|TAGGEDreturn|) NIL)
             ((BOOT-EQUAL |op| 'CATCH)
              (PROGN
                (SPADLET |gs| (CADR |expr|))
                (SPADLET |data| (CADDR |expr|))
                (COND
                  ((|canReturn,findThrow| |gs| |data| |level|
                       |exitCount| |ValueFlag|)
                   'T)
                  ('T
                   (|canReturn| |data| |level| |exitCount| |ValueFlag|)))))
             ((BOOT-EQUAL |op| 'COND)
              (COND
                ((BOOT-EQUAL |level| |exitCount|)
                 (PROG (G169477)
                   (SPADLET G169477 NIL)
                   (RETURN
                     (DO ((G169483 NIL G169477)
                          (G169484 (CDR |expr|) (CDR G169484))
                          (|u| NIL))
                         ((OR G169483 (ATOM G169484)
                              (PROGN (SETQ |u| (CAR G169484)) NIL))
                          G169477)
                       (SEQ (EXIT (SETQ G169477
                                        (OR G169477
                                         (|canReturn| (|last| |u|)
                                          |level| |exitCount|
                                          |ValueFlag|)))))))))
                ('T
                 (PROG (G169491)
                   (SPADLET G169491 NIL)
                   (RETURN
                     (DO ((G169497 NIL G169491)
                          (G169498 (CDR |expr|) (CDR G169498))
                          (|v| NIL))
                         ((OR G169497 (ATOM G169498)
                              (PROGN (SETQ |v| (CAR G169498)) NIL))
                          G169491)
                       (SEQ (EXIT (SETQ G169491
                                        (OR G169491
                                         (PROG (G169505)
                                           (SPADLET G169505 NIL)
                                           (RETURN
                                             (DO
                                              ((G169511 NIL
                                                G169505)
                                               (G169512 |v|
                                                (CDR G169512))
                                               (|u| NIL))
                                              ((OR G169511
                                                (ATOM G169512)
                                                (PROGN
                                                  (SETQ |u|
                                                   (CAR G169512))
                                                  NIL))
                                               G169505)
                                               (SEQ
                                                (EXIT
                                                 (SETQ G169505
                                                  (OR G169505
                                                   (|canReturn| |u|
                                                    |level| |exitCount|
                                                    |ValueFlag|))))))))))))))))))
             ((BOOT-EQUAL |op| 'IF)
              (PROGN
                (AND (PAIRP |expr|)
                     (PROGN
                       (SPADLET |ISTMP#1| (QCDR |expr|))
                       (AND (PAIRP |ISTMP#1|)
                            (PROGN
                              (SPADLET |a| (QCAR |ISTMP#1|))
                              (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (PAIRP |ISTMP#2|)
                                   (PROGN
                                     (SPADLET |b| (QCAR |ISTMP#2|))
                                     (SPADLET |ISTMP#3|
                                      (QCDR |ISTMP#2|))
                                     (AND (PAIRP |ISTMP#3|)
                                      (EQ (QCDR |ISTMP#3|) NIL)
                                      (PROGN
                                        (SPADLET |c| (QCAR |ISTMP#3|))
                                        'T))))))))
                (COND
                  ((NULL (|canReturn| |a| 0 0 'T))
                   (SAY                             "IF statement can not cause consequents to be executed")
                   (|pp| |expr|)))
                (OR (|canReturn| |a| |level| |exitCount| NIL)
                    (|canReturn| |b| |level| |exitCount| |ValueFlag|)
                    (|canReturn| |c| |level| |exitCount| |ValueFlag|))))
             ((ATOM |op|)
              (PROG (G169519)
                (SPADLET G169519 'T)
                (RETURN
                  (DO ((G169525 NIL (NULL G169519))
                       (G169526 |expr| (CDR G169526)) (|u| NIL))
                      ((OR G169525 (ATOM G169526)
                           (PROGN (SETQ |u| (CAR G169526)) NIL))
                       G169519)
                    (SEQ (EXIT (SETQ G169519
                                     (AND G169519
                                      (|canReturn| |u| |level|
                                       |exitCount| |ValueFlag|)))))))))
             ((AND (PAIRP |op|) (EQ (QCAR |op|) 'XLAM)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |op|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |args| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (PAIRP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |bods| (QCAR |ISTMP#2|))
                                   'T))))))
              (PROG (G169533)
                (SPADLET G169533 'T)
                (RETURN
                  (DO ((G169539 NIL (NULL G169533))
                       (G169540 |expr| (CDR G169540)) (|u| NIL))
                      ((OR G169539 (ATOM G169540)
                           (PROGN (SETQ |u| (CAR G169540)) NIL))
                       G169533)
                    (SEQ (EXIT (SETQ G169533
                                     (AND G169533
                                      (|canReturn| |u| |level|
                                       |exitCount| |ValueFlag|)))))))))
             ('T (|systemErrorHere| "canReturn")))))))

\end{chunk}
\subsection{compBoolean}
\begin{chunk}{*}
;compBoolean(p,m,E) ==
;  [p',m,E]:= comp(p,m,E) or return nil
;  [p',m,getSuccessEnvironment(p,E),getInverseEnvironment(p,E)]

(DEFUN |compBoolean| (|p| |m| E)
  (PROG (|LETTMP#1| |p'|)
    (RETURN
      (PROGN
        (SPADLET |LETTMP#1| (OR (|comp| |p| |m| E) (RETURN NIL)))
        (SPADLET |p'| (CAR |LETTMP#1|))
        (SPADLET |m| (CADR |LETTMP#1|))
        (SPADLET E (CADDR |LETTMP#1|))
        (CONS |p'|
              (CONS |m|
                    (CONS (|getSuccessEnvironment| |p| E)
                          (CONS (|getInverseEnvironment| |p| E) NIL))))))))

\end{chunk}
\subsection{getSuccessEnvironment}
\begin{chunk}{*}
;getSuccessEnvironment(a,e) ==
;  -- the next four lines try to ensure that explicit special-case tests
;  --  prevent implicit ones from being generated
;  a is ["has",x,m] =>
;    IDENTP x and isDomainForm(m,$EmptyEnvironment) => put(x,"specialCase",m,e)
;    e
;  a is ["is",id,m] =>
;    IDENTP id and isDomainForm(m,$EmptyEnvironment) =>
;         e:=put(id,"specialCase",m,e)
;         currentProplist:= getProplist(id,e)
;         [.,.,e] := T := comp(m,$EmptyMode,e) or return nil -- duplicates compIs
;         newProplist:= consProplistOf(id,currentProplist,"value",[m,:rest removeEnv T])
;         addBinding(id,newProplist,e)
;    e
;  a is ["case",x,m] and IDENTP x =>
;    put(x,"condition",[a,:get(x,"condition",e)],e)
;  e

(DEFUN |getSuccessEnvironment| (|a| |e|)
  (PROG (|id| |currentProplist| T$ |newProplist| |ISTMP#1| |x| |ISTMP#2| |m|)
  (declare (special |$EmptyMode| |$EmptyEnvironment|))
    (RETURN
      (COND
        ((AND (PAIRP |a|) (EQ (QCAR |a|) '|has|)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |a|))
                (AND (PAIRP |ISTMP#1|)
                     (PROGN
                       (SPADLET |x| (QCAR |ISTMP#1|))
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)
                            (PROGN (SPADLET |m| (QCAR |ISTMP#2|)) 'T))))))
         (COND
           ((AND (IDENTP |x|) (|isDomainForm| |m| |$EmptyEnvironment|))
            (|put| |x| '|specialCase| |m| |e|))
           ('T |e|)))
        ((AND (PAIRP |a|) (EQ (QCAR |a|) '|is|)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |a|))
                (AND (PAIRP |ISTMP#1|)
                     (PROGN
                       (SPADLET |id| (QCAR |ISTMP#1|))
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)
                            (PROGN (SPADLET |m| (QCAR |ISTMP#2|)) 'T))))))
         (COND
           ((AND (IDENTP |id|)
                 (|isDomainForm| |m| |$EmptyEnvironment|))
            (SPADLET |e| (|put| |id| '|specialCase| |m| |e|))
            (SPADLET |currentProplist| (|getProplist| |id| |e|))
            (SPADLET T$
                     (OR (|comp| |m| |$EmptyMode| |e|) (RETURN NIL)))
            (SPADLET |e| (CADDR T$))
            (SPADLET |newProplist|
                     (|consProplistOf| |id| |currentProplist| '|value|
                         (CONS |m| (CDR (|removeEnv| T$)))))
            (|addBinding| |id| |newProplist| |e|))
           ('T |e|)))
        ((AND (PAIRP |a|) (EQ (QCAR |a|) '|case|)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |a|))
                (AND (PAIRP |ISTMP#1|)
                     (PROGN
                       (SPADLET |x| (QCAR |ISTMP#1|))
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)
                            (PROGN (SPADLET |m| (QCAR |ISTMP#2|)) 'T)))))
              (IDENTP |x|))
         (|put| |x| '|condition|
                (CONS |a| (|get| |x| '|condition| |e|)) |e|))
        ('T |e|)))))

\end{chunk}
\subsection{getInverseEnvironment}
\begin{chunk}{*}
;getInverseEnvironment(a,E) ==
;  atom a => E
;  [op,:argl]:= a
;-- the next five lines try to ensure that explicit special-case tests
;-- prevent implicit ones from being generated
;  op="has" =>
;    [x,m]:= argl
;    IDENTP x and isDomainForm(m,$EmptyEnvironment) => put(x,"specialCase",m,E)
;    E
;  a is ["case",x,m] and IDENTP x =>
;           --the next two lines are necessary to get 3-branched Unions to work
;           -- old-style unions, that is
;    (get(x,"condition",E) is [["OR",:oldpred]]) and MEMBER(a,oldpred) =>
;      put(x,"condition",LIST MKPF(DELETE(a,oldpred),"OR"),E)
;    getUnionMode(x,E) is ["Union",:l]
;    l':= DELETE(m,l)
;    for u in l' repeat
;       if u is ['_:,=m,:.] then l':=DELETE(u,l')
;    newpred:= MKPF([["case",x,m'] for m' in l'],"OR")
;    put(x,"condition",[newpred,:get(x,"condition",E)],E)
;  E

(DEFUN |getInverseEnvironment| (|a| E)
  (PROG (|op| |argl| |x| |m| |ISTMP#2| |oldpred| |l| |ISTMP#1| |l'| |newpred|)
  (declare (special |$EmptyEnvironment|))
    (RETURN
      (SEQ (COND
             ((ATOM |a|) E)
             ('T (SPADLET |op| (CAR |a|)) (SPADLET |argl| (CDR |a|))
              (COND
                ((BOOT-EQUAL |op| '|has|) (SPADLET |x| (CAR |argl|))
                 (SPADLET |m| (CADR |argl|))
                 (COND
                   ((AND (IDENTP |x|)
                         (|isDomainForm| |m| |$EmptyEnvironment|))
                    (|put| |x| '|specialCase| |m| E))
                   ('T E)))
                ((AND (PAIRP |a|) (EQ (QCAR |a|) '|case|)
                      (PROGN
                        (SPADLET |ISTMP#1| (QCDR |a|))
                        (AND (PAIRP |ISTMP#1|)
                             (PROGN
                               (SPADLET |x| (QCAR |ISTMP#1|))
                               (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                               (AND (PAIRP |ISTMP#2|)
                                    (EQ (QCDR |ISTMP#2|) NIL)
                                    (PROGN
                                      (SPADLET |m| (QCAR |ISTMP#2|))
                                      'T)))))
                      (IDENTP |x|))
                 (COND
                   ((AND (PROGN
                           (SPADLET |ISTMP#1|
                                    (|get| |x| '|condition| E))
                           (AND (PAIRP |ISTMP#1|)
                                (EQ (QCDR |ISTMP#1|) NIL)
                                (PROGN
                                  (SPADLET |ISTMP#2| (QCAR |ISTMP#1|))
                                  (AND (PAIRP |ISTMP#2|)
                                       (EQ (QCAR |ISTMP#2|) 'OR)
                                       (PROGN
                                         (SPADLET |oldpred|
                                          (QCDR |ISTMP#2|))
                                         'T)))))
                         (|member| |a| |oldpred|))
                    (|put| |x| '|condition|
                           (LIST (MKPF (|delete| |a| |oldpred|) 'OR))
                           E))
                   ('T (SPADLET |ISTMP#1| (|getUnionMode| |x| E))
                    (AND (PAIRP |ISTMP#1|)
                         (EQ (QCAR |ISTMP#1|) '|Union|)
                         (PROGN (SPADLET |l| (QCDR |ISTMP#1|)) 'T))
                    (SPADLET |l'| (|delete| |m| |l|))
                    (DO ((G169713 |l'| (CDR G169713)) (|u| NIL))
                        ((OR (ATOM G169713)
                             (PROGN (SETQ |u| (CAR G169713)) NIL))
                         NIL)
                      (SEQ (EXIT (COND
                                   ((AND (PAIRP |u|)
                                     (EQ (QCAR |u|) '|:|)
                                     (PROGN
                                       (SPADLET |ISTMP#1| (QCDR |u|))
                                       (AND (PAIRP |ISTMP#1|)
                                        (EQUAL (QCAR |ISTMP#1|) |m|))))
                                    (SPADLET |l'| (|delete| |u| |l'|)))
                                   ('T NIL)))))
                    (SPADLET |newpred|
                             (MKPF (PROG (G169723)
                                     (SPADLET G169723 NIL)
                                     (RETURN
                                       (DO
                                        ((G169728 |l'|
                                          (CDR G169728))
                                         (|m'| NIL))
                                        ((OR (ATOM G169728)
                                          (PROGN
                                            (SETQ |m'| (CAR G169728))
                                            NIL))
                                         (NREVERSE0 G169723))
                                         (SEQ
                                          (EXIT
                                           (SETQ G169723
                                            (CONS
                                             (CONS '|case|
                                              (CONS |x|
                                               (CONS |m'| NIL)))
                                             G169723)))))))
                                   'OR))
                    (|put| |x| '|condition|
                           (CONS |newpred| (|get| |x| '|condition| E))
                           E))))
                ('T E))))))))

\end{chunk}
\subsection{getUnionMode}
\begin{chunk}{*}
;getUnionMode(x,e) ==
;  m:=
;    atom x => getmode(x,e)
;    return nil
;  isUnionMode(m,e)

(DEFUN |getUnionMode| (|x| |e|)
  (PROG (|m|)
    (RETURN
      (PROGN
        (SPADLET |m|
                 (COND
                   ((ATOM |x|) (|getmode| |x| |e|))
                   ('T (RETURN NIL))))
        (|isUnionMode| |m| |e|)))))

\end{chunk}
\subsection{isUnionMode}
\begin{chunk}{*}
;isUnionMode(m,e) ==
;  m is ["Union",:.] => m
;  (m':= getmode(m,e)) is ["Mapping",["UnionCategory",:.]] => CADR m'
;  v:= get(if m="$" then "Rep" else m,"value",e) =>
;    (v.expr is ["Union",:.] => v.expr; nil)
;  nil

(DEFUN |isUnionMode| (|m| |e|)
  (PROG (|m'| |ISTMP#2| |ISTMP#3| |v| |ISTMP#1|)
    (RETURN
      (COND
        ((AND (PAIRP |m|) (EQ (QCAR |m|) '|Union|)) |m|)
        ((PROGN
           (SPADLET |ISTMP#1| (SPADLET |m'| (|getmode| |m| |e|)))
           (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) '|Mapping|)
                (PROGN
                  (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                  (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)
                       (PROGN
                         (SPADLET |ISTMP#3| (QCAR |ISTMP#2|))
                         (AND (PAIRP |ISTMP#3|)
                              (EQ (QCAR |ISTMP#3|) '|UnionCategory|)))))))
         (CADR |m'|))
        ((SPADLET |v|
                  (|get| (COND ((BOOT-EQUAL |m| '$) '|Rep|) ('T |m|))
                         '|value| |e|))
         (COND
           ((PROGN
              (SPADLET |ISTMP#1| (CAR |v|))
              (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) '|Union|)))
            (CAR |v|))
           ('T NIL)))
        ('T NIL)))))

\end{chunk}
\subsection{compFromIf}
\begin{chunk}{*}
;compFromIf(a,m,E) ==
;  a="noBranch" => ["noBranch",m,E]
;  true => comp(a,m,E)

(DEFUN |compFromIf| (|a| |m| E)
  (COND
    ((BOOT-EQUAL |a| '|noBranch|)
     (CONS '|noBranch| (CONS |m| (CONS E NIL))))
    ('T (|comp| |a| |m| E))))

\end{chunk}
\subsection{quotify}
\begin{chunk}{*}
;quotify x == x

(DEFUN |quotify| (|x|) |x|) 

\end{chunk}
\subsection{unknownTypeError}
\begin{chunk}{*}
;unknownTypeError name ==
;  name:=
;    name is [op,:.] => op
;    name
;  stackSemanticError(["%b",name,"%d","is not a known type"],nil)

(DEFUN |unknownTypeError| (|name|)
  (PROG (|op|)
    (RETURN
      (PROGN
        (SPADLET |name|
                 (COND
                   ((AND (PAIRP |name|)
                         (PROGN (SPADLET |op| (QCAR |name|)) 'T))
                    |op|)
                   ('T |name|)))
        (|stackSemanticError|
            (CONS '|%b|
                  (CONS |name|
                        (CONS '|%d| (CONS '|is not a known type| NIL))))
            NIL)))))

\end{chunk}
\section{Functions for coercion by the compiler}
\subsection{coerce}
The function coerce is used by the old compiler for coercions.
The function coerceInteractive is used by the interpreter.
One should always call the correct function, since the representation 
of basic objects may not be the same.
\begin{chunk}{*}
;coerce(T,m) ==
;  $InteractiveMode =>
;    keyedSystemError("S2GE0016",['"coerce",
;      '"function coerce called from the interpreter."])
;  rplac(CADR T,substitute("$",$Rep,CADR T))
;  T':= coerceEasy(T,m) => T'
;  T':= coerceSubset(T,m) => T'
;  T':= coerceHard(T,m) => T'
;  T.expr = "$fromCoerceable$" or isSomeDomainVariable m => nil
;  stackMessage fn(T.expr,T.mode,m) where
;      -- if from from coerceable, this coerce was just a trial coercion
;      -- from compFormWithModemap to filter through the modemaps
;    fn(x,m1,m2) ==
;      ["Cannot coerce","%b",x,"%d","%l","      of mode","%b",m1,"%d","%l",
;        "      to mode","%b",m2,"%d"]

(DEFUN |coerce,fn| (|x| |m1| |m2|)
  (CONS '|Cannot coerce|
        (CONS '|%b|
              (CONS |x|
                    (CONS '|%d|
                          (CONS '|%l|
                                (CONS '|      of mode|
                                      (CONS '|%b|
                                       (CONS |m1|
                                        (CONS '|%d|
                                         (CONS '|%l|
                                          (CONS '|      to mode|
                                           (CONS '|%b|
                                            (CONS |m2|
                                             (CONS '|%d| NIL)))))))))))))))


(DEFUN |coerce| (T$ |m|)
  (PROG (|T'|)
  (declare (special |$fromCoerceable$| |$Rep| |$InteractiveMode|))
    (RETURN
      (COND
        (|$InteractiveMode|
            (|keyedSystemError| 'S2GE0016
                (CONS "coerce"
                      (CONS                                 "function coerce called from the interpreter."
                            NIL))))
        ('T (|rplac| (CADR T$) (MSUBST '$ |$Rep| (CADR T$)))
         (COND
           ((SPADLET |T'| (|coerceEasy| T$ |m|)) |T'|)
           ((SPADLET |T'| (|coerceSubset| T$ |m|)) |T'|)
           ((SPADLET |T'| (|coerceHard| T$ |m|)) |T'|)
           ((OR (BOOT-EQUAL (CAR T$) '|$fromCoerceable$|)
                (|isSomeDomainVariable| |m|))
            NIL)
           ('T (|stackMessage| (|coerce,fn| (CAR T$) (CADR T$) |m|)))))))))

\end{chunk}
\subsection{coerceEasy}
\begin{chunk}{*}
;coerceEasy(T,m) ==
;  m=$EmptyMode => T
;  m=$NoValueMode or m=$Void => [T.expr,m,T.env]
;  T.mode =m => T
;  T.mode =$NoValueMode => T
;  T.mode =$Exit =>
;      [["PROGN", T.expr, ["userError", '"Did not really exit."]],
;        m,T.env]
;  T.mode=$EmptyMode or modeEqualSubst(T.mode,m,T.env) =>
;    [T.expr,m,T.env]

(DEFUN |coerceEasy| (T$ |m|)
  (declare (special |$EmptyMode| |$Exit| |$NoValueMode| |$Void|))
  (COND
    ((BOOT-EQUAL |m| |$EmptyMode|) T$)
    ((OR (BOOT-EQUAL |m| |$NoValueMode|) (BOOT-EQUAL |m| |$Void|))
     (CONS (CAR T$) (CONS |m| (CONS (CADDR T$) NIL))))
    ((BOOT-EQUAL (CADR T$) |m|) T$)
    ((BOOT-EQUAL (CADR T$) |$NoValueMode|) T$)
    ((BOOT-EQUAL (CADR T$) |$Exit|)
     (CONS (CONS 'PROGN
                 (CONS (CAR T$)
                       (CONS (CONS '|userError|
                                   (CONS
                                    "Did not really exit."
                                    NIL))
                             NIL)))
           (CONS |m| (CONS (CADDR T$) NIL))))
    ((OR (BOOT-EQUAL (CADR T$) |$EmptyMode|)
         (|modeEqualSubst| (CADR T$) |m| (CADDR T$)))
     (CONS (CAR T$) (CONS |m| (CONS (CADDR T$) NIL))))))

\end{chunk}
\subsection{coerceSubset}
\begin{chunk}{*}
;coerceSubset([x,m,e],m') ==
;  isSubset(m,m',e) or m="Rep" and m'="$" => [x,m',e]
;  m is ['SubDomain,=m',:.] => [x,m',e]
;  (pred:= LASSOC(opOf m',get(opOf m,'SubDomain,e))) and INTEGERP x and
;     -- obviously this is temporary
;    eval substitute(x,"#1",pred) => [x,m',e]
;  (pred:= isSubset(m',maxSuperType(m,e),e)) and INTEGERP x -- again temporary
;    and eval substitute(x,"*",pred) =>
;      [x,m',e]
;  nil

(DEFUN |coerceSubset| (G170274 |m'|)
  (PROG (|x| |m| |e| |ISTMP#1| |pred|)
    (RETURN
      (PROGN
        (SPADLET |x| (CAR G170274))
        (SPADLET |m| (CADR G170274))
        (SPADLET |e| (CADDR G170274))
        (COND
          ((OR (|isSubset| |m| |m'| |e|)
               (AND (BOOT-EQUAL |m| '|Rep|) (BOOT-EQUAL |m'| '$)))
           (CONS |x| (CONS |m'| (CONS |e| NIL))))
          ((AND (PAIRP |m|) (EQ (QCAR |m|) '|SubDomain|)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |m|))
                  (AND (PAIRP |ISTMP#1|) (EQUAL (QCAR |ISTMP#1|) |m'|))))
           (CONS |x| (CONS |m'| (CONS |e| NIL))))
          ((AND (SPADLET |pred|
                         (LASSOC (|opOf| |m'|)
                                 (|get| (|opOf| |m|) '|SubDomain| |e|)))
                (INTEGERP |x|) (|eval| (MSUBST |x| '|#1| |pred|)))
           (CONS |x| (CONS |m'| (CONS |e| NIL))))
          ((AND (SPADLET |pred|
                         (|isSubset| |m'| (|maxSuperType| |m| |e|) |e|))
                (INTEGERP |x|) (|eval| (MSUBST |x| '* |pred|)))
           (CONS |x| (CONS |m'| (CONS |e| NIL))))
          ('T NIL))))))

\end{chunk}
\subsection{coerceHard}
\begin{chunk}{*}
;coerceHard(T,m) ==
;  $e: local:= T.env
;  m':= T.mode
;  STRINGP m' and modeEqual(m,$String) => [T.expr,m,$e]
;  modeEqual(m',m) or
;    (get(m',"value",$e) is [m'',:.] or getmode(m',$e) is ["Mapping",m'']) and
;      modeEqual(m'',m) or
;        (get(m,"value",$e) is [m'',:.] or getmode(m,$e) is ["Mapping",m'']) and
;          modeEqual(m'',m') => [T.expr,m,T.env]
;  STRINGP T.expr and T.expr=m => [T.expr,m,$e]
;  isCategoryForm(m,$e) =>
;      $bootStrapMode = true => [T.expr,m,$e]
;      extendsCategoryForm(T.expr,T.mode,m) => [T.expr,m,$e]
;      coerceExtraHard(T,m)
;  coerceExtraHard(T,m)

(DEFUN |coerceHard| (T$ |m|)
  (PROG (|$e| |m'| |ISTMP#1| |ISTMP#2| |m''|)
    (DECLARE (SPECIAL |$e| |$String| |$bootStrapMode|))
    (RETURN
      (PROGN
        (SPADLET |$e| (CADDR T$))
        (SPADLET |m'| (CADR T$))
        (COND
          ((AND (STRINGP |m'|) (|modeEqual| |m| |$String|))
           (CONS (CAR T$) (CONS |m| (CONS |$e| NIL))))
          ((OR (|modeEqual| |m'| |m|)
               (AND (OR (PROGN
                          (SPADLET |ISTMP#1|
                                   (|get| |m'| '|value| |$e|))
                          (AND (PAIRP |ISTMP#1|)
                               (PROGN
                                 (SPADLET |m''| (QCAR |ISTMP#1|))
                                 'T)))
                        (PROGN
                          (SPADLET |ISTMP#1| (|getmode| |m'| |$e|))
                          (AND (PAIRP |ISTMP#1|)
                               (EQ (QCAR |ISTMP#1|) '|Mapping|)
                               (PROGN
                                 (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                                 (AND (PAIRP |ISTMP#2|)
                                      (EQ (QCDR |ISTMP#2|) NIL)
                                      (PROGN
                                        (SPADLET |m''|
                                         (QCAR |ISTMP#2|))
                                        'T))))))
                    (|modeEqual| |m''| |m|))
               (AND (OR (PROGN
                          (SPADLET |ISTMP#1| (|get| |m| '|value| |$e|))
                          (AND (PAIRP |ISTMP#1|)
                               (PROGN
                                 (SPADLET |m''| (QCAR |ISTMP#1|))
                                 'T)))
                        (PROGN
                          (SPADLET |ISTMP#1| (|getmode| |m| |$e|))
                          (AND (PAIRP |ISTMP#1|)
                               (EQ (QCAR |ISTMP#1|) '|Mapping|)
                               (PROGN
                                 (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                                 (AND (PAIRP |ISTMP#2|)
                                      (EQ (QCDR |ISTMP#2|) NIL)
                                      (PROGN
                                        (SPADLET |m''|
                                         (QCAR |ISTMP#2|))
                                        'T))))))
                    (|modeEqual| |m''| |m'|)))
           (CONS (CAR T$) (CONS |m| (CONS (CADDR T$) NIL))))
          ((AND (STRINGP (CAR T$)) (BOOT-EQUAL (CAR T$) |m|))
           (CONS (CAR T$) (CONS |m| (CONS |$e| NIL))))
          ((|isCategoryForm| |m| |$e|)
           (COND
             ((BOOT-EQUAL |$bootStrapMode| 'T)
              (CONS (CAR T$) (CONS |m| (CONS |$e| NIL))))
             ((|extendsCategoryForm| (CAR T$) (CADR T$) |m|)
              (CONS (CAR T$) (CONS |m| (CONS |$e| NIL))))
             ('T (|coerceExtraHard| T$ |m|))))
          ('T (|coerceExtraHard| T$ |m|)))))))

\end{chunk}
\subsection{coerceExtraHard}
\begin{chunk}{*}
;coerceExtraHard(T is [x,m',e],m) ==
;  T':= autoCoerceByModemap(T,m) => T'
;  isUnionMode(m',e) is ["Union",:l] and (t:= hasType(x,e)) and
;    MEMBER(t,l) and (T':= autoCoerceByModemap(T,t)) and
;      (T'':= coerce(T',m)) => T''
;  m' is ['Record,:.] and m = $Expression =>
;      [['coerceRe2E,x,['ELT,COPY m',0]],m,e]
;  nil

(DEFUN |coerceExtraHard| (T$ |m|)
  (PROG (|x| |m'| |e| |ISTMP#1| |l| |t| |T'| |T''|)
  (declare (special |$Expression|))
    (RETURN
      (PROGN
        (SPADLET |x| (CAR T$))
        (SPADLET |m'| (CADR T$))
        (SPADLET |e| (CADDR T$))
        (COND
          ((SPADLET |T'| (|autoCoerceByModemap| T$ |m|)) |T'|)
          ((AND (PROGN
                  (SPADLET |ISTMP#1| (|isUnionMode| |m'| |e|))
                  (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) '|Union|)
                       (PROGN (SPADLET |l| (QCDR |ISTMP#1|)) 'T)))
                (SPADLET |t| (|hasType| |x| |e|)) (|member| |t| |l|)
                (SPADLET |T'| (|autoCoerceByModemap| T$ |t|))
                (SPADLET |T''| (|coerce| |T'| |m|)))
           |T''|)
          ((AND (PAIRP |m'|) (EQ (QCAR |m'|) '|Record|)
                (BOOT-EQUAL |m| |$Expression|))
           (CONS (CONS '|coerceRe2E|
                       (CONS |x|
                             (CONS (CONS 'ELT
                                    (CONS (COPY |m'|) (CONS 0 NIL)))
                                   NIL)))
                 (CONS |m| (CONS |e| NIL))))
          ('T NIL))))))

\end{chunk}
\subsection{coerceable}
\begin{chunk}{*}
;coerceable(m,m',e) ==
;  m=m' => m
;  -- must find any free parameters in m
;  sl:= pmatch(m',m) => SUBLIS(sl,m')
;  coerce(["$fromCoerceable$",m,e],m') => m'
;  nil

(DEFUN |coerceable| (|m| |m'| |e|)
  (PROG (|sl|)
  (declare (special |$fromCoerceable$|))
    (RETURN
      (COND
        ((BOOT-EQUAL |m| |m'|) |m|)
        ((SPADLET |sl| (|pmatch| |m'| |m|)) (SUBLIS |sl| |m'|))
        ((|coerce| (CONS '|$fromCoerceable$| (CONS |m| (CONS |e| NIL)))
             |m'|)
         |m'|)
        ('T NIL)))))

\end{chunk}
\subsection{coerceExit}
\begin{chunk}{*}
;coerceExit([x,m,e],m') ==
;  m':= resolve(m,m')
;  x':= replaceExitEtc(x,catchTag:= MKQ GENSYM(),"TAGGEDexit",$exitMode)
;  coerce([["CATCH",catchTag,x'],m,e],m')

(DEFUN |coerceExit| (G170380 |m'|)
  (PROG (|x| |m| |e| |catchTag| |x'|)
  (declare (special |$exitMode|))
    (RETURN
      (PROGN
        (SPADLET |x| (CAR G170380))
        (SPADLET |m| (CADR G170380))
        (SPADLET |e| (CADDR G170380))
        (SPADLET |m'| (|resolve| |m| |m'|))
        (SPADLET |x'|
                 (|replaceExitEtc| |x|
                     (SPADLET |catchTag| (MKQ (GENSYM))) '|TAGGEDexit|
                     |$exitMode|))
        (|coerce|
            (CONS (CONS 'CATCH (CONS |catchTag| (CONS |x'| NIL)))
                  (CONS |m| (CONS |e| NIL)))
            |m'|)))))

\end{chunk}
\subsection{coerceByModemap}
\begin{chunk}{*}
;coerceByModemap([x,m,e],m') ==
;--+ modified 6/27 for new runtime system
;  u:=
;    [modemap
;      for (modemap:= [map,cexpr]) in getModemapList("coerce",1,e) | map is [.,t,
;        s] and (modeEqual(t,m') or isSubset(t,m',e))
;           and (modeEqual(s,m) or isSubset(m,s,e))] or return nil
;  --mm:= (or/[mm for (mm:=[.,[cond,.]]) in u | cond=true]) or return nil
;  mm:=first u  -- patch for non-trival conditons
;  fn :=
;    genDeltaEntry ['coerce,:mm]
;  [["call",fn,x],m',e]

(DEFUN |coerceByModemap| (G170521 |m'|)
  (PROG (|x| |m| |e| |map| |cexpr| |ISTMP#1| |t| |ISTMP#2| |s| |u| |mm|
             |fn|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |x| (CAR G170521))
             (SPADLET |m| (CADR G170521))
             (SPADLET |e| (CADDR G170521))
             (SPADLET |u|
                      (OR (PROG (G170548)
                            (SPADLET G170548 NIL)
                            (RETURN
                              (DO ((G170555
                                    (|getModemapList| '|coerce| 1 |e|)
                                    (CDR G170555))
                                   (|modemap| NIL))
                                  ((OR (ATOM G170555)
                                    (PROGN
                                      (SETQ |modemap| (CAR G170555))
                                      NIL)
                                    (PROGN
                                      (PROGN
                                        (SPADLET |map| (CAR |modemap|))
                                        (SPADLET |cexpr|
                                         (CADR |modemap|))
                                        |modemap|)
                                      NIL))
                                   (NREVERSE0 G170548))
                                (SEQ (EXIT
                                      (COND
                                        ((AND (PAIRP |map|)
                                          (PROGN
                                            (SPADLET |ISTMP#1|
                                             (QCDR |map|))
                                            (AND (PAIRP |ISTMP#1|)
                                             (PROGN
                                               (SPADLET |t|
                                                (QCAR |ISTMP#1|))
                                               (SPADLET |ISTMP#2|
                                                (QCDR |ISTMP#1|))
                                               (AND (PAIRP |ISTMP#2|)
                                                (EQ (QCDR |ISTMP#2|)
                                                 NIL)
                                                (PROGN
                                                  (SPADLET |s|
                                                   (QCAR |ISTMP#2|))
                                                  'T)))))
                                          (OR (|modeEqual| |t| |m'|)
                                           (|isSubset| |t| |m'| |e|))
                                          (OR (|modeEqual| |s| |m|)
                                           (|isSubset| |m| |s| |e|)))
                                         (SETQ G170548
                                          (CONS |modemap| G170548)))))))))
                          (RETURN NIL)))
             (SPADLET |mm| (CAR |u|))
             (SPADLET |fn| (|genDeltaEntry| (CONS '|coerce| |mm|)))
             (CONS (CONS '|call| (CONS |fn| (CONS |x| NIL)))
                   (CONS |m'| (CONS |e| NIL))))))))

\end{chunk}
\subsection{autoCoerceByModemap}
\begin{chunk}{*}
;autoCoerceByModemap([x,source,e],target) ==
;  u:=
;    [cexpr
;      for (modemap:= [map,cexpr]) in getModemapList("autoCoerce",1,e) | map is [
;        .,t,s] and modeEqual(t,target) and modeEqual(s,source)] or return nil
;  fn:= (or/[selfn for [cond,selfn] in u | cond=true]) or return nil
;  source is ["Union",:l] and MEMBER(target,l) =>
;    (y:= get(x,"condition",e)) and (or/[u is ["case",., =target] for u in y])
;       => [["call",fn,x],target,e]
;    x="$fromCoerceable$" => nil
;    stackMessage ["cannot coerce: ",x,"%l","      of mode: ",source,"%l",
;      "      to: ",target," without a case statement"]
;  [["call",fn,x],target,e]

(DEFUN |autoCoerceByModemap| (G170609 |target|)
  (PROG (|x| |source| |e| |map| |cexpr| |t| |s| |u| |cond| |selfn| |fn|
             |l| |y| |ISTMP#1| |ISTMP#2|)
  (declare (special |$fromCoerceable$|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |x| (CAR G170609))
             (SPADLET |source| (CADR G170609))
             (SPADLET |e| (CADDR G170609))
             (SPADLET |u|
                      (OR (PROG (G170645)
                            (SPADLET G170645 NIL)
                            (RETURN
                              (DO ((G170652
                                    (|getModemapList| '|autoCoerce| 1
                                     |e|)
                                    (CDR G170652))
                                   (|modemap| NIL))
                                  ((OR (ATOM G170652)
                                    (PROGN
                                      (SETQ |modemap| (CAR G170652))
                                      NIL)
                                    (PROGN
                                      (PROGN
                                        (SPADLET |map| (CAR |modemap|))
                                        (SPADLET |cexpr|
                                         (CADR |modemap|))
                                        |modemap|)
                                      NIL))
                                   (NREVERSE0 G170645))
                                (SEQ (EXIT
                                      (COND
                                        ((AND (PAIRP |map|)
                                          (PROGN
                                            (SPADLET |ISTMP#1|
                                             (QCDR |map|))
                                            (AND (PAIRP |ISTMP#1|)
                                             (PROGN
                                               (SPADLET |t|
                                                (QCAR |ISTMP#1|))
                                               (SPADLET |ISTMP#2|
                                                (QCDR |ISTMP#1|))
                                               (AND (PAIRP |ISTMP#2|)
                                                (EQ (QCDR |ISTMP#2|)
                                                 NIL)
                                                (PROGN
                                                  (SPADLET |s|
                                                   (QCAR |ISTMP#2|))
                                                  'T)))))
                                          (|modeEqual| |t| |target|)
                                          (|modeEqual| |s| |source|))
                                         (SETQ G170645
                                          (CONS |cexpr| G170645)))))))))
                          (RETURN NIL)))
             (SPADLET |fn|
                      (OR (PROG (G170659)
                            (SPADLET G170659 NIL)
                            (RETURN
                              (DO ((G170667 NIL G170659)
                                   (G170668 |u| (CDR G170668))
                                   (G170597 NIL))
                                  ((OR G170667 (ATOM G170668)
                                    (PROGN
                                      (SETQ G170597 (CAR G170668))
                                      NIL)
                                    (PROGN
                                      (PROGN
                                        (SPADLET |cond|
                                         (CAR G170597))
                                        (SPADLET |selfn|
                                         (CADR G170597))
                                        G170597)
                                      NIL))
                                   G170659)
                                (SEQ (EXIT
                                      (COND
                                        ((BOOT-EQUAL |cond| 'T)
                                         (SETQ G170659
                                          (OR G170659 |selfn|)))))))))
                          (RETURN NIL)))
             (COND
               ((AND (PAIRP |source|) (EQ (QCAR |source|) '|Union|)
                     (PROGN (SPADLET |l| (QCDR |source|)) 'T)
                     (|member| |target| |l|))
                (COND
                  ((AND (SPADLET |y| (|get| |x| '|condition| |e|))
                        (PROG (G170676)
                          (SPADLET G170676 NIL)
                          (RETURN
                            (DO ((G170686 NIL G170676)
                                 (G170687 |y| (CDR G170687))
                                 (|u| NIL))
                                ((OR G170686 (ATOM G170687)
                                     (PROGN
                                       (SETQ |u| (CAR G170687))
                                       NIL))
                                 G170676)
                              (SEQ (EXIT
                                    (SETQ G170676
                                     (OR G170676
                                      (AND (PAIRP |u|)
                                       (EQ (QCAR |u|) '|case|)
                                       (PROGN
                                         (SPADLET |ISTMP#1| (QCDR |u|))
                                         (AND (PAIRP |ISTMP#1|)
                                          (PROGN
                                            (SPADLET |ISTMP#2|
                                             (QCDR |ISTMP#1|))
                                            (AND (PAIRP |ISTMP#2|)
                                             (EQ (QCDR |ISTMP#2|) NIL)
                                             (EQUAL (QCAR |ISTMP#2|)
                                              |target|))))))))))))))
                   (CONS (CONS '|call| (CONS |fn| (CONS |x| NIL)))
                         (CONS |target| (CONS |e| NIL))))
                  ((BOOT-EQUAL |x| '|$fromCoerceable$|) NIL)
                  ('T
                   (|stackMessage|
                       (CONS '|cannot coerce: |
                             (CONS |x|
                                   (CONS '|%l|
                                    (CONS '|      of mode: |
                                     (CONS |source|
                                      (CONS '|%l|
                                       (CONS '|      to: |
                                        (CONS |target|
                                         (CONS
                                          '| without a case statement|
                                          NIL)))))))))))))
               ('T
                (CONS (CONS '|call| (CONS |fn| (CONS |x| NIL)))
                      (CONS |target| (CONS |e| NIL))))))))))

\end{chunk}
\subsection{resolve}
Very old resolve
should only be used in the old (preWATT) compiler
\begin{chunk}{*}
;resolve(din,dout) ==
;  din=$NoValueMode or dout=$NoValueMode => $NoValueMode
;  dout=$EmptyMode => din
;  din^=dout and (STRINGP din or STRINGP dout) =>
;    modeEqual(dout,$String) => dout
;    modeEqual(din,$String) => nil
;    mkUnion(din,dout)
;  dout

(DEFUN |resolve| (|din| |dout|)
  (declare (special |$String| |$EmptyMode| |$NoValueMode|))
  (COND
    ((OR (BOOT-EQUAL |din| |$NoValueMode|)
         (BOOT-EQUAL |dout| |$NoValueMode|))
     |$NoValueMode|)
    ((BOOT-EQUAL |dout| |$EmptyMode|) |din|)
    ((AND (NEQUAL |din| |dout|) (OR (STRINGP |din|) (STRINGP |dout|)))
     (COND
       ((|modeEqual| |dout| |$String|) |dout|)
       ((|modeEqual| |din| |$String|) NIL)
       ('T (|mkUnion| |din| |dout|))))
    ('T |dout|)))

\end{chunk}
\subsection{modeEqual}
\begin{chunk}{*}
;modeEqual(x,y) ==
;  -- this is the late modeEqual
;  -- orders Unions
;  atom x or atom y => x=y
;  #x ^=#y => nil
;  x is ['Union,:xl] and y is ['Union,:yl] =>
;    for x1 in xl repeat
;      for y1 in yl repeat
;        modeEqual(x1,y1) =>
;          xl := DELETE(x1,xl)
;          yl := DELETE(y1,yl)
;          return nil
;    xl or yl => nil
;    true
;  (and/[modeEqual(u,v) for u in x for v in y])

(DEFUN |modeEqual| (|x| |y|)
  (PROG (|xl| |yl|)
    (RETURN
      (SEQ (COND
             ((OR (ATOM |x|) (ATOM |y|)) (BOOT-EQUAL |x| |y|))
             ((NEQUAL (|#| |x|) (|#| |y|)) NIL)
             ((AND (PAIRP |x|) (EQ (QCAR |x|) '|Union|)
                   (PROGN (SPADLET |xl| (QCDR |x|)) 'T) (PAIRP |y|)
                   (EQ (QCAR |y|) '|Union|)
                   (PROGN (SPADLET |yl| (QCDR |y|)) 'T))
              (SEQ (DO ((G170731 |xl| (CDR G170731)) (|x1| NIL))
                       ((OR (ATOM G170731)
                            (PROGN (SETQ |x1| (CAR G170731)) NIL))
                        NIL)
                     (SEQ (EXIT (DO ((G170743 |yl| (CDR G170743))
                                     (|y1| NIL))
                                    ((OR (ATOM G170743)
                                      (PROGN
                                        (SETQ |y1| (CAR G170743))
                                        NIL))
                                     NIL)
                                  (SEQ (EXIT
                                        (COND
                                          ((|modeEqual| |x1| |y1|)
                                           (EXIT
                                            (PROGN
                                              (SPADLET |xl|
                                               (|delete| |x1| |xl|))
                                              (SPADLET |yl|
                                               (|delete| |y1| |yl|))
                                              (RETURN NIL)))))))))))
                   (COND ((OR |xl| |yl|) NIL) ('T 'T))))
             ('T
              (PROG (G170749)
                (SPADLET G170749 'T)
                (RETURN
                  (DO ((G170756 NIL (NULL G170749))
                       (G170757 |x| (CDR G170757)) (|u| NIL)
                       (G170758 |y| (CDR G170758)) (|v| NIL))
                      ((OR G170756 (ATOM G170757)
                           (PROGN (SETQ |u| (CAR G170757)) NIL)
                           (ATOM G170758)
                           (PROGN (SETQ |v| (CAR G170758)) NIL))
                       G170749)
                    (SEQ (EXIT (SETQ G170749
                                     (AND G170749
                                      (|modeEqual| |u| |v|))))))))))))))

\end{chunk}
\subsection{modeEqualSubst}
\begin{chunk}{*}
;modeEqualSubst(m1,m,e) ==
;  modeEqual(m1, m) => true
;  atom m1 => get(m1,"value",e) is [m',:.] and modeEqual(m',m)
;  m1 is [op,:l1] and m is [=op,:l2]  and # l1 = # l2 =>
;-- Above length test inserted JHD 4:47 on 15/8/86
;-- Otherwise Records can get fouled up - consider expressIdealElt
;-- in the DEFAULTS package
;        and/[modeEqualSubst(xm1,xm2,e) for xm1 in l1 for xm2 in l2]
;  nil

(DEFUN |modeEqualSubst| (|m1| |m| |e|)
  (PROG (|ISTMP#1| |m'| |op| |l1| |l2|)
    (RETURN
      (SEQ (COND
             ((|modeEqual| |m1| |m|) 'T)
             ((ATOM |m1|)
              (AND (PROGN
                     (SPADLET |ISTMP#1| (|get| |m1| '|value| |e|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN (SPADLET |m'| (QCAR |ISTMP#1|)) 'T)))
                   (|modeEqual| |m'| |m|)))
             ((AND (PAIRP |m1|)
                   (PROGN
                     (SPADLET |op| (QCAR |m1|))
                     (SPADLET |l1| (QCDR |m1|))
                     'T)
                   (PAIRP |m|) (EQUAL (QCAR |m|) |op|)
                   (PROGN (SPADLET |l2| (QCDR |m|)) 'T)
                   (BOOT-EQUAL (|#| |l1|) (|#| |l2|)))
              (PROG (G170784)
                (SPADLET G170784 'T)
                (RETURN
                  (DO ((G170791 NIL (NULL G170784))
                       (G170792 |l1| (CDR G170792)) (|xm1| NIL)
                       (G170793 |l2| (CDR G170793)) (|xm2| NIL))
                      ((OR G170791 (ATOM G170792)
                           (PROGN (SETQ |xm1| (CAR G170792)) NIL)
                           (ATOM G170793)
                           (PROGN (SETQ |xm2| (CAR G170793)) NIL))
                       G170784)
                    (SEQ (EXIT (SETQ G170784
                                     (AND G170784
                                      (|modeEqualSubst| |xm1| |xm2|
                                       |e|)))))))))
             ('T NIL))))))

\end{chunk}
\subsection{convertSpadToAsFile}
\begin{chunk}{*}
;convertSpadToAsFile path ==
;    -- can assume path has type = .spad
;    $globalMacroStack : local := nil       -- for spad -> as translator
;    $abbreviationStack: local := nil       -- for spad -> as translator
;    $macrosAlreadyPrinted: local := nil    -- for spad -> as translator
;    SETQ($badStack, nil)                   --ditto  TEMP to check for bad code
;    $newPaths: local := true               --ditto  TEMP
;    $abbreviationsAlreadyPrinted: local := nil    -- for spad -> as translator
;    $convertingSpadFile : local := true
;    $options: local := '((nolib))      -- translator shouldn't create nrlibs
;    SETQ(HT,MAKE_-HASHTABLE 'UEQUAL)
;    newName := fnameMake(pathnameDirectory path, pathnameName path, '"as")
;    canDoIt := true
;    if not fnameWritable? newName then
;        sayKeyedMsg("S2IZ0086", [NAMESTRING newName])
;        newName := fnameMake('".", pathnameName path, '"as")
;        if not fnameWritable? newName then
;            sayKeyedMsg("S2IZ0087", [NAMESTRING newName])
;            canDoIt := false
;    not canDoIt => 'failure
;    sayKeyedMsg("S2IZ0088", [NAMESTRING newName])
;    $outStream :local := MAKE_-OUTSTREAM newName
;    markSay('"#include _"axiom.as_"")
;    markTerpri()
;    CATCH("SPAD__READER",compiler [path])
;    SHUT $outStream
;    mkCheck()
;    'done

(DEFUN |convertSpadToAsFile| (|path|)
  (PROG (|$globalMacroStack| |$abbreviationStack|
            |$macrosAlreadyPrinted| |$newPaths|
            |$abbreviationsAlreadyPrinted| |$convertingSpadFile|
            |$options| |$outStream| |newName| |canDoIt|)
    (DECLARE (SPECIAL |$globalMacroStack| |$abbreviationStack|
                      |$macrosAlreadyPrinted| |$newPaths|
                      |$abbreviationsAlreadyPrinted| |$badStack|
                      |$convertingSpadFile| |$options| |$outStream|))
    (RETURN
      (PROGN
        (SPADLET |$globalMacroStack| NIL)
        (SPADLET |$abbreviationStack| NIL)
        (SPADLET |$macrosAlreadyPrinted| NIL)
        (SETQ |$badStack| NIL)
        (SPADLET |$newPaths| 'T)
        (SPADLET |$abbreviationsAlreadyPrinted| NIL)
        (SPADLET |$convertingSpadFile| 'T)
        (SPADLET |$options| '((|nolib|)))
        (SETQ HT (MAKE-HASHTABLE 'UEQUAL))
        (SPADLET |newName|
                 (|fnameMake| (|pathnameDirectory| |path|)
                     (|pathnameName| |path|) "as"))
        (SPADLET |canDoIt| 'T)
        (COND
          ((NULL (|fnameWritable?| |newName|))
           (|sayKeyedMsg| 'S2IZ0086 (CONS (NAMESTRING |newName|) NIL))
           (SPADLET |newName|
                    (|fnameMake| "."
                        (|pathnameName| |path|) "as"))
           (COND
             ((NULL (|fnameWritable?| |newName|))
              (|sayKeyedMsg| 'S2IZ0087
                  (CONS (NAMESTRING |newName|) NIL))
              (SPADLET |canDoIt| NIL))
             ('T NIL))))
        (COND
          ((NULL |canDoIt|) '|failure|)
          ('T
           (|sayKeyedMsg| 'S2IZ0088 (CONS (NAMESTRING |newName|) NIL))
           (SPADLET |$outStream| (MAKE-OUTSTREAM |newName|))
           (|markSay| "#include \"axiom.as\"")
           (|markTerpri|)
           (CATCH 'SPAD_READER (|compiler| (CONS |path| NIL)))
           (SHUT |$outStream|) (|mkCheck|) '|done|))))))

\end{chunk}
\subsection{compilerDoitWithScreenedLisplib}
\begin{chunk}{*}
;compilerDoitWithScreenedLisplib(constructor, fun) ==
;    EMBED('RWRITE,
;          '(LAMBDA (KEY VALUE STREAM)
;                   (COND ((AND (EQ STREAM $libFile)
;                               (NOT (MEMBER KEY $saveableItems)))
;                          VALUE)
;                         ((NOT NIL)
;                          (RWRITE KEY VALUE STREAM)))) )
;    UNWIND_-PROTECT(compilerDoit(constructor,fun),
;                   SEQ(UNEMBED 'RWRITE))

(DEFUN |compilerDoitWithScreenedLisplib| (|constructor| |fun|)
  (declare (special |$saveableItems| |$libFile|))
  (PROGN
    (EMBED 'RWRITE
           '(LAMBDA (KEY VALUE STREAM)
              (COND
                ((AND (EQ STREAM |$libFile|)
                      (NOT (MEMBER KEY |$saveableItems|)))
                 VALUE)
                ((NOT NIL) (RWRITE KEY VALUE STREAM)))))
    (UNWIND-PROTECT
      (|compilerDoit| |constructor| |fun|)
      (UNEMBED 'RWRITE))))

\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
