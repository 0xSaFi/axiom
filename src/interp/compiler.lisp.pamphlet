\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp compiler.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{chunk}{*}

(IN-PACKAGE "BOOT" )

(defvar |$NoValueMode| '|NoValueMode|)
(defvar |$ValueMode| '|ValueMode|)
(defvar |$globalMacroStack| nil)
(defvar |$abbreviationStack| nil)

\end{chunk}
\subsection{tc}
\begin{chunk}{*}
;tc() ==
;  $tripleCache:= nil
;  comp($x,$m,$f)

;(DEFUN |tc| ()
;  (declare (special |$tripleCache| |$x| |$m| |$f|))
;  (PROGN (SPADLET |$tripleCache| NIL) (|comp| |$x| |$m| |$f|)))

\end{chunk}

\subsection{mkUnion}
\begin{chunk}{*}
;mkUnion(a,b) ==
;  b="$" and $Rep is ["Union",:l] => b
;  a is ["Union",:l] =>
;    b is ["Union",:l'] => ["Union",:setUnion(l,l')]
;    ["Union",:setUnion([b],l)]
;  b is ["Union",:l] => ["Union",:setUnion([a],l)]
;  ["Union",a,b]

(DEFUN |mkUnion| (|a| |b|)
  (PROG (|l'| |l|)
  (declare (special |$Rep|))
    (RETURN
      (COND
        ((AND (BOOT-EQUAL |b| '$) (PAIRP |$Rep|)
              (EQ (QCAR |$Rep|) '|Union|)
              (PROGN (SPADLET |l| (QCDR |$Rep|)) 'T))
         |b|)
        ((AND (PAIRP |a|) (EQ (QCAR |a|) '|Union|)
              (PROGN (SPADLET |l| (QCDR |a|)) 'T))
         (COND
           ((AND (PAIRP |b|) (EQ (QCAR |b|) '|Union|)
                 (PROGN (SPADLET |l'| (QCDR |b|)) 'T))
            (CONS '|Union| (|union| |l| |l'|)))
           ('T (CONS '|Union| (|union| (CONS |b| NIL) |l|)))))
        ((AND (PAIRP |b|) (EQ (QCAR |b|) '|Union|)
              (PROGN (SPADLET |l| (QCDR |b|)) 'T))
         (CONS '|Union| (|union| (CONS |a| NIL) |l|)))
        ('T (CONS '|Union| (CONS |a| (CONS |b| NIL))))))))

\end{chunk}
\subsection{hasType}
\begin{chunk}{*}
;hasType(x,e) ==
;  fn get(x,"condition",e) where
;    fn x ==
;      null x => nil
;      x is [["case",.,y],:.] => y
;      fn rest x

(DEFUN |hasType,fn| (|x|)
  (PROG (|ISTMP#1| |ISTMP#2| |ISTMP#3| |y|)
    (RETURN
      (SEQ (IF (NULL |x|) (EXIT NIL))
           (IF (AND (PAIRP |x|)
                    (PROGN
                      (SPADLET |ISTMP#1| (QCAR |x|))
                      (AND (PAIRP |ISTMP#1|)
                           (EQ (QCAR |ISTMP#1|) '|case|)
                           (PROGN
                             (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (PAIRP |ISTMP#2|)
                                  (PROGN
                                    (SPADLET |ISTMP#3|
                                     (QCDR |ISTMP#2|))
                                    (AND (PAIRP |ISTMP#3|)
                                     (EQ (QCDR |ISTMP#3|) NIL)
                                     (PROGN
                                       (SPADLET |y| (QCAR |ISTMP#3|))
                                       'T))))))))
               (EXIT |y|))
           (EXIT (|hasType,fn| (CDR |x|)))))))

(DEFUN |hasType| (|x| |e|)
  (|hasType,fn| (|get| |x| '|condition| |e|)))

\end{chunk}
\subsection{getConstructorFormOfMode}
\begin{chunk}{*}
;getConstructorFormOfMode(m,e) ==
;  isConstructorForm m => m
;  if m="$" then m:= "Rep"
;  atom m and get(m,"value",e) is [v,:.] =>
;    isConstructorForm v => v

(DEFUN |getConstructorFormOfMode| (|m| |e|)
  (PROG (|ISTMP#1| |v|)
    (RETURN
      (SEQ (COND
             ((|isConstructorForm| |m|) |m|)
             ('T (COND ((BOOT-EQUAL |m| '$) (SPADLET |m| '|Rep|)))
              (SEQ (COND
                     ((AND (ATOM |m|)
                           (PROGN
                             (SPADLET |ISTMP#1|
                                      (|get| |m| '|value| |e|))
                             (AND (PAIRP |ISTMP#1|)
                                  (PROGN
                                    (SPADLET |v| (QCAR |ISTMP#1|))
                                    'T))))
                      (COND ((|isConstructorForm| |v|) (EXIT |v|))))))))))))

\end{chunk}
\subsection{getConstructorMode}
\begin{chunk}{*}
;getConstructorMode(x,e) ==
;  atom x => (u:= getmode(x,e) or return nil; getConstructorFormOfMode(u,e))
;  x is ["elt",y,a] =>
;    u:= getConstructorMode(y,e)
;    u is ["Vector",R] or u is ["List",R] =>
;      isConstructorForm R => R
;    u is ["Record",:l] =>
;      (or/[p is [., =a,R] for p in l]) and isConstructorForm R => R

(DEFUN |getConstructorMode| (|x| |e|)
  (PROG (|y| |a| |u| |l| |ISTMP#1| |ISTMP#2| R)
    (RETURN
      (SEQ (COND
             ((ATOM |x|)
              (SPADLET |u| (OR (|getmode| |x| |e|) (RETURN NIL)))
              (|getConstructorFormOfMode| |u| |e|))
             ((AND (PAIRP |x|) (EQ (QCAR |x|) '|elt|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |x|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN
                            (SPADLET |y| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (PAIRP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |a| (QCAR |ISTMP#2|))
                                   'T))))))
              (SPADLET |u| (|getConstructorMode| |y| |e|))
              (SEQ (COND
                     ((OR (AND (PAIRP |u|) (EQ (QCAR |u|) '|Vector|)
                               (PROGN
                                 (SPADLET |ISTMP#1| (QCDR |u|))
                                 (AND (PAIRP |ISTMP#1|)
                                      (EQ (QCDR |ISTMP#1|) NIL)
                                      (PROGN
                                        (SPADLET R (QCAR |ISTMP#1|))
                                        'T))))
                          (AND (PAIRP |u|) (EQ (QCAR |u|) '|List|)
                               (PROGN
                                 (SPADLET |ISTMP#1| (QCDR |u|))
                                 (AND (PAIRP |ISTMP#1|)
                                      (EQ (QCDR |ISTMP#1|) NIL)
                                      (PROGN
                                        (SPADLET R (QCAR |ISTMP#1|))
                                        'T)))))
                      (COND ((|isConstructorForm| R) (EXIT R))))
                     ((AND (PAIRP |u|) (EQ (QCAR |u|) '|Record|)
                           (PROGN (SPADLET |l| (QCDR |u|)) 'T))
                      (COND
                        ((AND (PROG (G167805)
                                (SPADLET G167805 NIL)
                                (RETURN
                                  (DO ((G167817 NIL G167805)
                                       (G167818 |l| (CDR G167818))
                                       (|p| NIL))
                                      ((OR G167817 (ATOM G167818)
                                        (PROGN
                                          (SETQ |p| (CAR G167818))
                                          NIL))
                                       G167805)
                                    (SEQ
                                     (EXIT
                                      (SETQ G167805
                                       (OR G167805
                                        (AND (PAIRP |p|)
                                         (PROGN
                                           (SPADLET |ISTMP#1|
                                            (QCDR |p|))
                                           (AND (PAIRP |ISTMP#1|)
                                            (EQUAL (QCAR |ISTMP#1|)
                                             |a|)
                                            (PROGN
                                              (SPADLET |ISTMP#2|
                                               (QCDR |ISTMP#1|))
                                              (AND (PAIRP |ISTMP#2|)
                                               (EQ (QCDR |ISTMP#2|)
                                                NIL)
                                               (PROGN
                                                 (SPADLET R
                                                  (QCAR |ISTMP#2|))
                                                 'T)))))))))))))
                              (|isConstructorForm| R))
                         (EXIT R))))))))))))

\end{chunk}
\subsection{isConstructorForm}
\begin{chunk}{*}
;isConstructorForm u == u is [name,:.] and MEMBER(name,'(Record Vector List))

(DEFUN |isConstructorForm| (|u|)
  (PROG (|name|)
    (RETURN
      (AND (PAIRP |u|) (PROGN (SPADLET |name| (QCAR |u|)) 'T)
           (|member| |name| '(|Record| |Vector| |List|))))))

\end{chunk}
\subsection{substituteIntoFunctorModemap}
\begin{chunk}{*}
;substituteIntoFunctorModemap(argl,modemap is [[dc,:sig],:.],e) ==
;  #dc^=#sig =>
;    keyedSystemError("S2GE0016",['"substituteIntoFunctorModemap",
;      '"Incompatible maps"])
;  #argl=#rest sig =>
;                        --here, we actually have a functor form
;    sig:= EQSUBSTLIST(argl,rest dc,sig)
;      --make new modemap, subst. actual for formal parametersinto modemap
;    Tl:= [[.,.,e]:= compOrCroak(a,m,e) for a in argl for m in rest sig]
;    substitutionList:= [[x,:T.expr] for x in rest dc for T in Tl]
;    [SUBLIS(substitutionList,modemap),e]
;  nil

(DEFUN |substituteIntoFunctorModemap| (|argl| |modemap| |e|)
  (PROG (|dc| |sig| |LETTMP#1| |Tl| |substitutionList|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |dc| (CAAR |modemap|))
             (SPADLET |sig| (CDAR |modemap|))
             (COND
               ((NEQUAL (|#| |dc|) (|#| |sig|))
                (|keyedSystemError| 'S2GE0016
                    (CONS "substituteIntoFunctorModemap"
                          (CONS "Incompatible maps" NIL))))
               ((BOOT-EQUAL (|#| |argl|) (|#| (CDR |sig|)))
                (SPADLET |sig| (EQSUBSTLIST |argl| (CDR |dc|) |sig|))
                (SPADLET |Tl|
                         (PROG (G167960)
                           (SPADLET G167960 NIL)
                           (RETURN
                             (DO ((G167969 |argl| (CDR G167969))
                                  (|a| NIL)
                                  (G167970 (CDR |sig|)
                                      (CDR G167970))
                                  (|m| NIL))
                                 ((OR (ATOM G167969)
                                      (PROGN
                                        (SETQ |a| (CAR G167969))
                                        NIL)
                                      (ATOM G167970)
                                      (PROGN
                                        (SETQ |m| (CAR G167970))
                                        NIL))
                                  (NREVERSE0 G167960))
                               (SEQ (EXIT
                                     (SETQ G167960
                                      (CONS
                                       (PROGN
                                         (SPADLET |LETTMP#1|
                                          (|compOrCroak| |a| |m| |e|))
                                         (SPADLET |e|
                                          (CADDR |LETTMP#1|))
                                         |LETTMP#1|)
                                       G167960))))))))
                (SPADLET |substitutionList|
                         (PROG (G167984)
                           (SPADLET G167984 NIL)
                           (RETURN
                             (DO ((G167990 (CDR |dc|)
                                      (CDR G167990))
                                  (|x| NIL)
                                  (G167991 |Tl| (CDR G167991))
                                  (T$ NIL))
                                 ((OR (ATOM G167990)
                                      (PROGN
                                        (SETQ |x| (CAR G167990))
                                        NIL)
                                      (ATOM G167991)
                                      (PROGN
                                        (SETQ T$ (CAR G167991))
                                        NIL))
                                  (NREVERSE0 G167984))
                               (SEQ (EXIT
                                     (SETQ G167984
                                      (CONS (CONS |x| (CAR T$))
                                       G167984))))))))
                (CONS (SUBLIS |substitutionList| |modemap|)
                      (CONS |e| NIL)))
               ('T NIL)))))))

\end{chunk}

\section{Functions for coercion by the compiler}
\subsection{coerceable}
\begin{chunk}{*}
;coerceable(m,m',e) ==
;  m=m' => m
;  -- must find any free parameters in m
;  sl:= pmatch(m',m) => SUBLIS(sl,m')
;  coerce(["$fromCoerceable$",m,e],m') => m'
;  nil

(DEFUN |coerceable| (|m| |m'| |e|)
  (PROG (|sl|)
  (declare (special |$fromCoerceable$|))
    (RETURN
      (COND
        ((BOOT-EQUAL |m| |m'|) |m|)
        ((SPADLET |sl| (|pmatch| |m'| |m|)) (SUBLIS |sl| |m'|))
        ((|coerce| (CONS '|$fromCoerceable$| (CONS |m| (CONS |e| NIL)))
             |m'|)
         |m'|)
        ('T NIL)))))

\end{chunk}
\subsection{coerceExit}
\begin{chunk}{*}
;coerceExit([x,m,e],m') ==
;  m':= resolve(m,m')
;  x':= replaceExitEtc(x,catchTag:= MKQ GENSYM(),"TAGGEDexit",$exitMode)
;  coerce([["CATCH",catchTag,x'],m,e],m')

(DEFUN |coerceExit| (G170380 |m'|)
  (PROG (|x| |m| |e| |catchTag| |x'|)
  (declare (special |$exitMode|))
    (RETURN
      (PROGN
        (SPADLET |x| (CAR G170380))
        (SPADLET |m| (CADR G170380))
        (SPADLET |e| (CADDR G170380))
        (SPADLET |m'| (|resolve| |m| |m'|))
        (SPADLET |x'|
                 (|replaceExitEtc| |x|
                     (SPADLET |catchTag| (MKQ (GENSYM))) '|TAGGEDexit|
                     |$exitMode|))
        (|coerce|
            (CONS (CONS 'CATCH (CONS |catchTag| (CONS |x'| NIL)))
                  (CONS |m| (CONS |e| NIL)))
            |m'|)))))

\end{chunk}
\subsection{coerceByModemap}
\begin{chunk}{*}
;coerceByModemap([x,m,e],m') ==
;--+ modified 6/27 for new runtime system
;  u:=
;    [modemap
;      for (modemap:= [map,cexpr]) in getModemapList("coerce",1,e) | map is [.,t,
;        s] and (modeEqual(t,m') or isSubset(t,m',e))
;           and (modeEqual(s,m) or isSubset(m,s,e))] or return nil
;  --mm:= (or/[mm for (mm:=[.,[cond,.]]) in u | cond=true]) or return nil
;  mm:=first u  -- patch for non-trival conditons
;  fn :=
;    genDeltaEntry ['coerce,:mm]
;  [["call",fn,x],m',e]

(DEFUN |coerceByModemap| (G170521 |m'|)
  (PROG (|x| |m| |e| |map| |cexpr| |ISTMP#1| |t| |ISTMP#2| |s| |u| |mm|
             |fn|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |x| (CAR G170521))
             (SPADLET |m| (CADR G170521))
             (SPADLET |e| (CADDR G170521))
             (SPADLET |u|
                      (OR (PROG (G170548)
                            (SPADLET G170548 NIL)
                            (RETURN
                              (DO ((G170555
                                    (|getModemapList| '|coerce| 1 |e|)
                                    (CDR G170555))
                                   (|modemap| NIL))
                                  ((OR (ATOM G170555)
                                    (PROGN
                                      (SETQ |modemap| (CAR G170555))
                                      NIL)
                                    (PROGN
                                      (PROGN
                                        (SPADLET |map| (CAR |modemap|))
                                        (SPADLET |cexpr|
                                         (CADR |modemap|))
                                        |modemap|)
                                      NIL))
                                   (NREVERSE0 G170548))
                                (SEQ (EXIT
                                      (COND
                                        ((AND (PAIRP |map|)
                                          (PROGN
                                            (SPADLET |ISTMP#1|
                                             (QCDR |map|))
                                            (AND (PAIRP |ISTMP#1|)
                                             (PROGN
                                               (SPADLET |t|
                                                (QCAR |ISTMP#1|))
                                               (SPADLET |ISTMP#2|
                                                (QCDR |ISTMP#1|))
                                               (AND (PAIRP |ISTMP#2|)
                                                (EQ (QCDR |ISTMP#2|)
                                                 NIL)
                                                (PROGN
                                                  (SPADLET |s|
                                                   (QCAR |ISTMP#2|))
                                                  'T)))))
                                          (OR (|modeEqual| |t| |m'|)
                                           (|isSubset| |t| |m'| |e|))
                                          (OR (|modeEqual| |s| |m|)
                                           (|isSubset| |m| |s| |e|)))
                                         (SETQ G170548
                                          (CONS |modemap| G170548)))))))))
                          (RETURN NIL)))
             (SPADLET |mm| (CAR |u|))
             (SPADLET |fn| (|genDeltaEntry| (CONS '|coerce| |mm|)))
             (CONS (CONS '|call| (CONS |fn| (CONS |x| NIL)))
                   (CONS |m'| (CONS |e| NIL))))))))

\end{chunk}
\subsection{autoCoerceByModemap}
\begin{chunk}{*}
;autoCoerceByModemap([x,source,e],target) ==
;  u:=
;    [cexpr
;      for (modemap:= [map,cexpr]) in getModemapList("autoCoerce",1,e) | map is [
;        .,t,s] and modeEqual(t,target) and modeEqual(s,source)] or return nil
;  fn:= (or/[selfn for [cond,selfn] in u | cond=true]) or return nil
;  source is ["Union",:l] and MEMBER(target,l) =>
;    (y:= get(x,"condition",e)) and (or/[u is ["case",., =target] for u in y])
;       => [["call",fn,x],target,e]
;    x="$fromCoerceable$" => nil
;    stackMessage ["cannot coerce: ",x,"%l","      of mode: ",source,"%l",
;      "      to: ",target," without a case statement"]
;  [["call",fn,x],target,e]

(DEFUN |autoCoerceByModemap| (G170609 |target|)
  (PROG (|x| |source| |e| |map| |cexpr| |t| |s| |u| |cond| |selfn| |fn|
             |l| |y| |ISTMP#1| |ISTMP#2|)
  (declare (special |$fromCoerceable$|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |x| (CAR G170609))
             (SPADLET |source| (CADR G170609))
             (SPADLET |e| (CADDR G170609))
             (SPADLET |u|
                      (OR (PROG (G170645)
                            (SPADLET G170645 NIL)
                            (RETURN
                              (DO ((G170652
                                    (|getModemapList| '|autoCoerce| 1
                                     |e|)
                                    (CDR G170652))
                                   (|modemap| NIL))
                                  ((OR (ATOM G170652)
                                    (PROGN
                                      (SETQ |modemap| (CAR G170652))
                                      NIL)
                                    (PROGN
                                      (PROGN
                                        (SPADLET |map| (CAR |modemap|))
                                        (SPADLET |cexpr|
                                         (CADR |modemap|))
                                        |modemap|)
                                      NIL))
                                   (NREVERSE0 G170645))
                                (SEQ (EXIT
                                      (COND
                                        ((AND (PAIRP |map|)
                                          (PROGN
                                            (SPADLET |ISTMP#1|
                                             (QCDR |map|))
                                            (AND (PAIRP |ISTMP#1|)
                                             (PROGN
                                               (SPADLET |t|
                                                (QCAR |ISTMP#1|))
                                               (SPADLET |ISTMP#2|
                                                (QCDR |ISTMP#1|))
                                               (AND (PAIRP |ISTMP#2|)
                                                (EQ (QCDR |ISTMP#2|)
                                                 NIL)
                                                (PROGN
                                                  (SPADLET |s|
                                                   (QCAR |ISTMP#2|))
                                                  'T)))))
                                          (|modeEqual| |t| |target|)
                                          (|modeEqual| |s| |source|))
                                         (SETQ G170645
                                          (CONS |cexpr| G170645)))))))))
                          (RETURN NIL)))
             (SPADLET |fn|
                      (OR (PROG (G170659)
                            (SPADLET G170659 NIL)
                            (RETURN
                              (DO ((G170667 NIL G170659)
                                   (G170668 |u| (CDR G170668))
                                   (G170597 NIL))
                                  ((OR G170667 (ATOM G170668)
                                    (PROGN
                                      (SETQ G170597 (CAR G170668))
                                      NIL)
                                    (PROGN
                                      (PROGN
                                        (SPADLET |cond|
                                         (CAR G170597))
                                        (SPADLET |selfn|
                                         (CADR G170597))
                                        G170597)
                                      NIL))
                                   G170659)
                                (SEQ (EXIT
                                      (COND
                                        ((BOOT-EQUAL |cond| 'T)
                                         (SETQ G170659
                                          (OR G170659 |selfn|)))))))))
                          (RETURN NIL)))
             (COND
               ((AND (PAIRP |source|) (EQ (QCAR |source|) '|Union|)
                     (PROGN (SPADLET |l| (QCDR |source|)) 'T)
                     (|member| |target| |l|))
                (COND
                  ((AND (SPADLET |y| (|get| |x| '|condition| |e|))
                        (PROG (G170676)
                          (SPADLET G170676 NIL)
                          (RETURN
                            (DO ((G170686 NIL G170676)
                                 (G170687 |y| (CDR G170687))
                                 (|u| NIL))
                                ((OR G170686 (ATOM G170687)
                                     (PROGN
                                       (SETQ |u| (CAR G170687))
                                       NIL))
                                 G170676)
                              (SEQ (EXIT
                                    (SETQ G170676
                                     (OR G170676
                                      (AND (PAIRP |u|)
                                       (EQ (QCAR |u|) '|case|)
                                       (PROGN
                                         (SPADLET |ISTMP#1| (QCDR |u|))
                                         (AND (PAIRP |ISTMP#1|)
                                          (PROGN
                                            (SPADLET |ISTMP#2|
                                             (QCDR |ISTMP#1|))
                                            (AND (PAIRP |ISTMP#2|)
                                             (EQ (QCDR |ISTMP#2|) NIL)
                                             (EQUAL (QCAR |ISTMP#2|)
                                              |target|))))))))))))))
                   (CONS (CONS '|call| (CONS |fn| (CONS |x| NIL)))
                         (CONS |target| (CONS |e| NIL))))
                  ((BOOT-EQUAL |x| '|$fromCoerceable$|) NIL)
                  ('T
                   (|stackMessage|
                       (CONS '|cannot coerce: |
                             (CONS |x|
                                   (CONS '|%l|
                                    (CONS '|      of mode: |
                                     (CONS |source|
                                      (CONS '|%l|
                                       (CONS '|      to: |
                                        (CONS |target|
                                         (CONS
                                          '| without a case statement|
                                          NIL)))))))))))))
               ('T
                (CONS (CONS '|call| (CONS |fn| (CONS |x| NIL)))
                      (CONS |target| (CONS |e| NIL))))))))))

\end{chunk}
\subsection{resolve}
Very old resolve
should only be used in the old (preWATT) compiler
\begin{chunk}{*}
;resolve(din,dout) ==
;  din=$NoValueMode or dout=$NoValueMode => $NoValueMode
;  dout=$EmptyMode => din
;  din^=dout and (STRINGP din or STRINGP dout) =>
;    modeEqual(dout,$String) => dout
;    modeEqual(din,$String) => nil
;    mkUnion(din,dout)
;  dout

(DEFUN |resolve| (|din| |dout|)
  (declare (special |$String| |$EmptyMode| |$NoValueMode|))
  (COND
    ((OR (BOOT-EQUAL |din| |$NoValueMode|)
         (BOOT-EQUAL |dout| |$NoValueMode|))
     |$NoValueMode|)
    ((BOOT-EQUAL |dout| |$EmptyMode|) |din|)
    ((AND (NEQUAL |din| |dout|) (OR (STRINGP |din|) (STRINGP |dout|)))
     (COND
       ((|modeEqual| |dout| |$String|) |dout|)
       ((|modeEqual| |din| |$String|) NIL)
       ('T (|mkUnion| |din| |dout|))))
    ('T |dout|)))

\end{chunk}
\subsection{modeEqual}
\begin{chunk}{*}
;modeEqual(x,y) ==
;  -- this is the late modeEqual
;  -- orders Unions
;  atom x or atom y => x=y
;  #x ^=#y => nil
;  x is ['Union,:xl] and y is ['Union,:yl] =>
;    for x1 in xl repeat
;      for y1 in yl repeat
;        modeEqual(x1,y1) =>
;          xl := DELETE(x1,xl)
;          yl := DELETE(y1,yl)
;          return nil
;    xl or yl => nil
;    true
;  (and/[modeEqual(u,v) for u in x for v in y])

(DEFUN |modeEqual| (|x| |y|)
  (PROG (|xl| |yl|)
    (RETURN
      (SEQ (COND
             ((OR (ATOM |x|) (ATOM |y|)) (BOOT-EQUAL |x| |y|))
             ((NEQUAL (|#| |x|) (|#| |y|)) NIL)
             ((AND (PAIRP |x|) (EQ (QCAR |x|) '|Union|)
                   (PROGN (SPADLET |xl| (QCDR |x|)) 'T) (PAIRP |y|)
                   (EQ (QCAR |y|) '|Union|)
                   (PROGN (SPADLET |yl| (QCDR |y|)) 'T))
              (SEQ (DO ((G170731 |xl| (CDR G170731)) (|x1| NIL))
                       ((OR (ATOM G170731)
                            (PROGN (SETQ |x1| (CAR G170731)) NIL))
                        NIL)
                     (SEQ (EXIT (DO ((G170743 |yl| (CDR G170743))
                                     (|y1| NIL))
                                    ((OR (ATOM G170743)
                                      (PROGN
                                        (SETQ |y1| (CAR G170743))
                                        NIL))
                                     NIL)
                                  (SEQ (EXIT
                                        (COND
                                          ((|modeEqual| |x1| |y1|)
                                           (EXIT
                                            (PROGN
                                              (SPADLET |xl|
                                               (|delete| |x1| |xl|))
                                              (SPADLET |yl|
                                               (|delete| |y1| |yl|))
                                              (RETURN NIL)))))))))))
                   (COND ((OR |xl| |yl|) NIL) ('T 'T))))
             ('T
              (PROG (G170749)
                (SPADLET G170749 'T)
                (RETURN
                  (DO ((G170756 NIL (NULL G170749))
                       (G170757 |x| (CDR G170757)) (|u| NIL)
                       (G170758 |y| (CDR G170758)) (|v| NIL))
                      ((OR G170756 (ATOM G170757)
                           (PROGN (SETQ |u| (CAR G170757)) NIL)
                           (ATOM G170758)
                           (PROGN (SETQ |v| (CAR G170758)) NIL))
                       G170749)
                    (SEQ (EXIT (SETQ G170749
                                     (AND G170749
                                      (|modeEqual| |u| |v|))))))))))))))

\end{chunk}
\subsection{modeEqualSubst}
\begin{chunk}{*}
;modeEqualSubst(m1,m,e) ==
;  modeEqual(m1, m) => true
;  atom m1 => get(m1,"value",e) is [m',:.] and modeEqual(m',m)
;  m1 is [op,:l1] and m is [=op,:l2]  and # l1 = # l2 =>
;-- Above length test inserted JHD 4:47 on 15/8/86
;-- Otherwise Records can get fouled up - consider expressIdealElt
;-- in the DEFAULTS package
;        and/[modeEqualSubst(xm1,xm2,e) for xm1 in l1 for xm2 in l2]
;  nil

(DEFUN |modeEqualSubst| (|m1| |m| |e|)
  (PROG (|ISTMP#1| |m'| |op| |l1| |l2|)
    (RETURN
      (SEQ (COND
             ((|modeEqual| |m1| |m|) 'T)
             ((ATOM |m1|)
              (AND (PROGN
                     (SPADLET |ISTMP#1| (|get| |m1| '|value| |e|))
                     (AND (PAIRP |ISTMP#1|)
                          (PROGN (SPADLET |m'| (QCAR |ISTMP#1|)) 'T)))
                   (|modeEqual| |m'| |m|)))
             ((AND (PAIRP |m1|)
                   (PROGN
                     (SPADLET |op| (QCAR |m1|))
                     (SPADLET |l1| (QCDR |m1|))
                     'T)
                   (PAIRP |m|) (EQUAL (QCAR |m|) |op|)
                   (PROGN (SPADLET |l2| (QCDR |m|)) 'T)
                   (BOOT-EQUAL (|#| |l1|) (|#| |l2|)))
              (PROG (G170784)
                (SPADLET G170784 'T)
                (RETURN
                  (DO ((G170791 NIL (NULL G170784))
                       (G170792 |l1| (CDR G170792)) (|xm1| NIL)
                       (G170793 |l2| (CDR G170793)) (|xm2| NIL))
                      ((OR G170791 (ATOM G170792)
                           (PROGN (SETQ |xm1| (CAR G170792)) NIL)
                           (ATOM G170793)
                           (PROGN (SETQ |xm2| (CAR G170793)) NIL))
                       G170784)
                    (SEQ (EXIT (SETQ G170784
                                     (AND G170784
                                      (|modeEqualSubst| |xm1| |xm2|
                                       |e|)))))))))
             ('T NIL))))))

\end{chunk}
\subsection{convertSpadToAsFile}
\begin{chunk}{*}
;convertSpadToAsFile path ==
;    -- can assume path has type = .spad
;    $globalMacroStack : local := nil       -- for spad -> as translator
;    $abbreviationStack: local := nil       -- for spad -> as translator
;    $macrosAlreadyPrinted: local := nil    -- for spad -> as translator
;    SETQ($badStack, nil)                   --ditto  TEMP to check for bad code
;    $newPaths: local := true               --ditto  TEMP
;    $abbreviationsAlreadyPrinted: local := nil    -- for spad -> as translator
;    $convertingSpadFile : local := true
;    $options: local := '((nolib))      -- translator shouldn't create nrlibs
;    SETQ(HT,MAKE_-HASHTABLE 'UEQUAL)
;    newName := fnameMake(pathnameDirectory path, pathnameName path, '"as")
;    canDoIt := true
;    if not fnameWritable? newName then
;        sayKeyedMsg("S2IZ0086", [NAMESTRING newName])
;        newName := fnameMake('".", pathnameName path, '"as")
;        if not fnameWritable? newName then
;            sayKeyedMsg("S2IZ0087", [NAMESTRING newName])
;            canDoIt := false
;    not canDoIt => 'failure
;    sayKeyedMsg("S2IZ0088", [NAMESTRING newName])
;    $outStream :local := MAKE_-OUTSTREAM newName
;    markSay('"#include _"axiom.as_"")
;    markTerpri()
;    CATCH("SPAD__READER",compiler [path])
;    SHUT $outStream
;    mkCheck()
;    'done

(DEFUN |convertSpadToAsFile| (|path|)
  (PROG (|$globalMacroStack| |$abbreviationStack|
            |$macrosAlreadyPrinted| |$newPaths|
            |$abbreviationsAlreadyPrinted| |$convertingSpadFile|
            |$options| |$outStream| |newName| |canDoIt|)
    (DECLARE (SPECIAL |$globalMacroStack| |$abbreviationStack|
                      |$macrosAlreadyPrinted| |$newPaths|
                      |$abbreviationsAlreadyPrinted| |$badStack|
                      |$convertingSpadFile| |$options| |$outStream|))
    (RETURN
      (PROGN
        (SPADLET |$globalMacroStack| NIL)
        (SPADLET |$abbreviationStack| NIL)
        (SPADLET |$macrosAlreadyPrinted| NIL)
        (SETQ |$badStack| NIL)
        (SPADLET |$newPaths| 'T)
        (SPADLET |$abbreviationsAlreadyPrinted| NIL)
        (SPADLET |$convertingSpadFile| 'T)
        (SPADLET |$options| '((|nolib|)))
        (SETQ HT (MAKE-HASHTABLE 'UEQUAL))
        (SPADLET |newName|
                 (|fnameMake| (|pathnameDirectory| |path|)
                     (|pathnameName| |path|) "as"))
        (SPADLET |canDoIt| 'T)
        (COND
          ((NULL (|fnameWritable?| |newName|))
           (|sayKeyedMsg| 'S2IZ0086 (CONS (NAMESTRING |newName|) NIL))
           (SPADLET |newName|
                    (|fnameMake| "."
                        (|pathnameName| |path|) "as"))
           (COND
             ((NULL (|fnameWritable?| |newName|))
              (|sayKeyedMsg| 'S2IZ0087
                  (CONS (NAMESTRING |newName|) NIL))
              (SPADLET |canDoIt| NIL))
             ('T NIL))))
        (COND
          ((NULL |canDoIt|) '|failure|)
          ('T
           (|sayKeyedMsg| 'S2IZ0088 (CONS (NAMESTRING |newName|) NIL))
           (SPADLET |$outStream| (MAKE-OUTSTREAM |newName|))
           (|markSay| "#include \"axiom.as\"")
           (|markTerpri|)
           (CATCH 'SPAD_READER (|compiler| (CONS |path| NIL)))
           (SHUT |$outStream|) (|mkCheck|) '|done|))))))

\end{chunk}
\subsection{compilerDoitWithScreenedLisplib}
\begin{chunk}{*}
;compilerDoitWithScreenedLisplib(constructor, fun) ==
;    EMBED('RWRITE,
;          '(LAMBDA (KEY VALUE STREAM)
;                   (COND ((AND (EQ STREAM $libFile)
;                               (NOT (MEMBER KEY $saveableItems)))
;                          VALUE)
;                         ((NOT NIL)
;                          (RWRITE KEY VALUE STREAM)))) )
;    UNWIND_-PROTECT(compilerDoit(constructor,fun),
;                   SEQ(UNEMBED 'RWRITE))

(DEFUN |compilerDoitWithScreenedLisplib| (|constructor| |fun|)
  (declare (special |$saveableItems| |$libFile|))
  (PROGN
    (EMBED 'RWRITE
           '(LAMBDA (KEY VALUE STREAM)
              (COND
                ((AND (EQ STREAM |$libFile|)
                      (NOT (MEMBER KEY |$saveableItems|)))
                 VALUE)
                ((NOT NIL) (RWRITE KEY VALUE STREAM)))))
    (UNWIND-PROTECT
      (|compilerDoit| |constructor| |fun|)
      (UNEMBED 'RWRITE))))

\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
