\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp cstream.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
The input stream is parsed into a large s-expression by repeated calls
to Delay. Delay takes a function f and an argument x and returns a list
consisting of ("nonnullstream" f x). Eventually multiple calls are made
and a large list structure is created that consists of 
("nonnullstream" f x ("nonnullstream" f1 x1 ("nonnullstream" f2 x2...

This delay structure is given to StreamNull which walks along the
list looking at the head. If the head is "nonnullstream" then the
function is applied to the argument.

So, in effect, the input is "zipped up" into a Delay data structure
which is then evaluated by calling StreamNull. This "zippered stream"
parser was a research project at IBM and Axiom was the testbed (which
explains the strange parsing technique).

@
<<*>>=

(IN-PACKAGE "BOOT")
;
;--% Stream Utilities
; 
;npNull x== StreamNull x
(DEFUN |npNull| (|x|) (PROG NIL (RETURN (|StreamNull| |x|))))

;StreamNull x==
;  null x or EQCAR (x,"nullstream") => true
;  while EQCAR(x,"nonnullstream") repeat
;          st:=APPLY(CADR x,CDDR x)
;          RPLACA(x,CAR st)
;          RPLACD(x,CDR st)
;  EQCAR(x,"nullstream")
(DEFUN |StreamNull| (|x|)
 (PROG (|st|)
  (RETURN 
   (COND
    ((OR (NULL |x|) (EQCAR |x| (QUOTE |nullstream|))) T)
    ((QUOTE T)
     (PROGN
      ((LAMBDA NIL
       (LOOP
        (COND
         ((NOT (EQCAR |x| (QUOTE |nonnullstream|))) (RETURN NIL))
         ((QUOTE T)
          (PROGN
           (SETQ |st| (APPLY (CADR |x|) (CDDR |x|)))
           (RPLACA |x| (CAR |st|))
           (RPLACD |x| (CDR |st|))))))))
      (EQCAR |x| (QUOTE |nullstream|))))))))

;incIgen n==Delay(function incIgen1,[n])
(DEFUN |incIgen| (|n|)
 (PROG NIL
  (RETURN
   (|Delay| (FUNCTION |incIgen1|) (LIST |n|)))))

;incIgen1(:z)==
;        [n]:=z
;        n:=n+1
;        cons(n,incIgen n)
(DEFUN |incIgen1| (&REST |z|)
 (PROG (|n|)
  (RETURN
   (PROGN
    (SETQ |n| (CAR |z|))
    (SETQ |n| (+ |n| 1))
    (CONS |n| (|incIgen| |n|))))))

;incZip(g,f1,f2)==Delay(function incZip1,[g,f1,f2])
(DEFUN |incZip| (|g| |f1| |f2|)
 (PROG NIL
  (RETURN
   (|Delay| (FUNCTION |incZip1|) (LIST |g| |f1| |f2|)))))

;incZip1(:z)==
;     [g,f1,f2]:=z
;     StreamNull f1 => StreamNil
;     StreamNull f2 => StreamNil
;     cons(FUNCALL(g,car f1,car f2),incZip(g,cdr f1,cdr f2))
(DEFUN |incZip1| (&REST |z|)
 (PROG (|f2| |f1| |g|)
  (RETURN
   (PROGN
    (SETQ |g| (CAR |z|))
    (SETQ |f1| (CADR . #0=(|z|)))
    (SETQ |f2| (CADDR . #0#))
    (COND
     ((|StreamNull| |f1|) |StreamNil|)
     ((|StreamNull| |f2|) |StreamNil|)
     ((QUOTE T)
      (CONS
       (FUNCALL |g| (CAR |f1|) (CAR |f2|))
       (|incZip| |g| (CDR |f1|) (CDR |f2|)))))))))

;incAppend(x,y)==Delay(function incAppend1,[x,y])
(DEFUN |incAppend| (|x| |y|)
 (PROG NIL
  (RETURN
   (|Delay| (FUNCTION |incAppend1|) (LIST |x| |y|)))))

;incAppend1(:z)==
;     [x,y]:=z
;     if StreamNull x
;     then if StreamNull y
;          then StreamNil
;          else y
;     else cons(car x,incAppend(cdr x,y))
(DEFUN |incAppend1| (&REST |z|)
 (PROG (|y| |x|)
  (RETURN
   (PROGN 
    (SETQ |x| (CAR |z|))
    (SETQ |y| (CADR |z|))
    (COND
     ((|StreamNull| |x|)
      (COND 
       ((|StreamNull| |y|) |StreamNil|)
       (#0=(QUOTE T) |y|)))
     (#0# (CONS (CAR |x|) (|incAppend| (CDR |x|) |y|))))))))

;next(f,s)==Delay(function next1,[f,s])
(DEFUN |next| (|f| |s|)
 (PROG NIL
  (RETURN
   (|Delay| (FUNCTION |next1|) (LIST |f| |s|)))))

;next1(:z)==
;      [f,s]:=z
;      StreamNull s=> StreamNil
;      h:= APPLY(f, [s])
;      incAppend(car h,next(f,cdr h))
(DEFUN |next1| (&REST |z|)
 (PROG (|h| |s| |f|)
  (RETURN
   (PROGN
    (SETQ |f| (CAR |z|))
    (SETQ |s| (CADR |z|))
    (COND
     ((|StreamNull| |s|) |StreamNil|)
     ((QUOTE T)
      (PROGN
       (SETQ |h| (APPLY |f| (LIST |s|)))
       (|incAppend| (CAR |h|) (|next| |f| (CDR |h|))))))))))

;nextown(f,g,s)==Delay(function nextown1,[f,g,s])
(DEFUN |nextown| (|f| |g| |s|)
 (PROG NIL
  (RETURN
   (|Delay| (FUNCTION |nextown1|) (LIST |f| |g| |s|)))))

;nextown1 (:z)==
;      [f,g,s]:=z
;      StreamNull s=>
;           spadcall1 g
;           StreamNil
;      StreamNull s
;      h:=spadcall2 (f, s)
;      incAppend(car h,nextown(f,g,cdr h))
(DEFUN |nextown1| (&REST |z|)
 (PROG (|h| |s| |g| |f|)
  (RETURN
   (PROGN
    (SETQ |f| (CAR |z|))
    (SETQ |g| (CADR . #0=(|z|)))
    (SETQ |s| (CADDR . #0#))
    (COND
     ((|StreamNull| |s|) (PROGN (|spadcall1| |g|) |StreamNil|))
     ((QUOTE T)
      (PROGN
       (|StreamNull| |s|)
       (SETQ |h| (|spadcall2| |f| |s|))
       (|incAppend| (CAR |h|) (|nextown| |f| |g| (CDR |h|))))))))))

;nextown2(f,g,e,x)==nextown(cons(f,e),cons(g,e),x)
(DEFUN |nextown2| (|f| |g| |e| |x|)
 (PROG NIL
  (RETURN
   (|nextown| (CONS |f| |e|) (CONS |g| |e|) |x|))))

;spadcall1(g)==
;    [impl, :env] := g
;    APPLY(impl, [env])
(DEFUN |spadcall1| (|g|)
 (PROG (|env| |impl|)
  (RETURN
   (PROGN
    (SETQ |impl| (CAR |g|))
    (SETQ |env| (CDR |g|))
    (APPLY |impl| (LIST |env|))))))

;spadcall2(f,args) ==
;    [impl, :env] := f
;    APPLY(impl, [args, env])
(DEFUN |spadcall2| (|f| |args|)
 (PROG (|env| |impl|)
  (RETURN
   (PROGN
    (SETQ |impl| (CAR |f|))
    (SETQ |env| (CDR |f|))
    (APPLY |impl| (LIST |args| |env|))))))

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
