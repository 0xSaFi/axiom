\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp format.boot}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{chunk}{*}
(IN-PACKAGE "BOOT" )

;--% Functions for display formatting system objects
;-- some of these are redundant and should be compacted
;$formatSigAsTeX := 1

(SPADLET |$formatSigAsTeX| 1) 

;--% Formatting modemaps
;sayModemap m ==
;  -- sayMSG formatModemap displayTranModemap m
;  sayMSG formatModemap old2NewModemaps displayTranModemap m

(DEFUN |sayModemap| (|m|)
  (|sayMSG|
      (|formatModemap| (|old2NewModemaps| (|displayTranModemap| |m|)))))

;sayModemapWithNumber(m,n) ==
;  msg := reverse cleanUpSegmentedMsg reverse ["%i","%i",'" ",
;    STRCONC(lbrkSch(),object2String n,rbrkSch()),
;      :formatModemap displayTranModemap m,"%u","%u"]
;  sayMSG flowSegmentedMsg(reverse msg,$LINELENGTH,3)

(DEFUN |sayModemapWithNumber| (|m| |n|)
  (PROG (|msg|)
    (DECLARE (SPECIAL $LINELENGTH))
    (RETURN
      (PROGN
        (SPADLET |msg|
                 (REVERSE (|cleanUpSegmentedMsg|
                              (REVERSE (CONS '|%i|
                                        (CONS '|%i|
                                         (CONS " "
                                          (CONS
                                           (STRCONC (|lbrkSch|)
                                            (|object2String| |n|)
                                            (|rbrkSch|))
                                           (APPEND
                                            (|formatModemap|
                                             (|displayTranModemap| |m|))
                                            (CONS '|%u|
                                             (CONS '|%u| NIL)))))))))))
        (|sayMSG| (|flowSegmentedMsg| (REVERSE |msg|) $LINELENGTH 3))))))

;displayOpModemaps(op,modemaps) ==
;  TERPRI()
;  count:= #modemaps
;  phrase:= (count=1 => 'modemap;'modemaps)
;  sayMSG ['%b,count,'%d,phrase,'" for",'%b,op,'%d,'":"]
;  for modemap in modemaps repeat sayModemap modemap

(DEFUN |displayOpModemaps| (|op| |modemaps|)
  (PROG (|count| |phrase|)
    (RETURN
      (SEQ (PROGN
             (TERPRI)
             (SPADLET |count| (|#| |modemaps|))
             (SPADLET |phrase|
                      (COND
                        ((EQL |count| 1) '|modemap|)
                        ('T '|modemaps|)))
             (|sayMSG|
                 (CONS '|%b|
                       (CONS |count|
                             (CONS '|%d|
                                   (CONS |phrase|
                                    (CONS " for"
                                     (CONS '|%b|
                                      (CONS |op|
                                       (CONS '|%d|
                                        (CONS ":" NIL))))))))))
             (DO ((G166070 |modemaps| (CDR G166070))
                  (|modemap| NIL))
                 ((OR (ATOM G166070)
                      (PROGN (SETQ |modemap| (CAR G166070)) NIL))
                  NIL)
               (SEQ (EXIT (|sayModemap| |modemap|)))))))))

;displayTranModemap (mm is [[x,:sig],[pred,:y],:z]) ==
;  -- The next 8 lines are a HACK to deal with the "partial" definition
;  -- JHD/RSS
;  if pred is ['partial,:pred'] then
;    [b,:c]:=sig
;    sig:=[['Union,b,'"failed"],:c]
;    mm:=[[x,:sig],[pred',:y],:z]
;  else if pred = 'partial then
;    [b,:c]:=sig
;    sig:=[['Union,b,'"failed"],:c]
;    mm:=[[x,:sig],y,:z]
;  mm' := EQSUBSTLIST('(m n p q r s t i j k l),
;    MSORT listOfPredOfTypePatternIds pred,mm)
;  EQSUBSTLIST('(D D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 D11 D12 D13 D14),
;    MSORT listOfPatternIds [sig,[pred,:y]],mm')

(DEFUN |displayTranModemap| (|mm|)
  (PROG (|x| |pred| |y| |z| |pred'| |b| |c| |sig| |mm'|)
    (RETURN
      (PROGN
        (SPADLET |x| (CAAR |mm|))
        (SPADLET |sig| (CDAR |mm|))
        (SPADLET |pred| (CAADR |mm|))
        (SPADLET |y| (CDADR |mm|))
        (SPADLET |z| (CDDR |mm|))
        (COND
          ((AND (CONSP |pred|) (EQ (QCAR |pred|) '|partial|)
                (PROGN (SPADLET |pred'| (QCDR |pred|)) 'T))
           (SPADLET |b| (CAR |sig|)) (SPADLET |c| (CDR |sig|))
           (SPADLET |sig|
                    (CONS (CONS '|Union|
                                (CONS |b|
                                      (CONS "failed" NIL)))
                          |c|))
           (SPADLET |mm|
                    (CONS (CONS |x| |sig|)
                          (CONS (CONS |pred'| |y|) |z|))))
          ((BOOT-EQUAL |pred| '|partial|) (SPADLET |b| (CAR |sig|))
           (SPADLET |c| (CDR |sig|))
           (SPADLET |sig|
                    (CONS (CONS '|Union|
                                (CONS |b|
                                      (CONS "failed" NIL)))
                          |c|))
           (SPADLET |mm| (CONS (CONS |x| |sig|) (CONS |y| |z|))))
          ('T NIL))
        (SPADLET |mm'|
                 (EQSUBSTLIST
                     '(|m| |n| |p| |q| |r| |s| |t| |i| |j| |k| |l|)
                     (MSORT (|listOfPredOfTypePatternIds| |pred|))
                     |mm|))
        (EQSUBSTLIST
            '(D D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 D11 D12 D13 D14)
            (MSORT (|listOfPatternIds|
                       (CONS |sig| (CONS (CONS |pred| |y|) NIL))))
            |mm'|)))))

;listOfPredOfTypePatternIds p ==
;  p is ['AND,:lp] or p is ['OR,:lp] =>
;    UNIONQ([:listOfPredOfTypePatternIds p1 for p1 in lp],NIL)
;  p is [op,a,.] and op = 'ofType =>
;    isPatternVar a => [a]
;    nil
;  nil

(DEFUN |listOfPredOfTypePatternIds| (|p|)
  (PROG (|lp| |op| |ISTMP#1| |a| |ISTMP#2|)
    (RETURN
      (SEQ (COND
             ((OR (AND (CONSP |p|) (EQ (QCAR |p|) 'AND)
                       (PROGN (SPADLET |lp| (QCDR |p|)) 'T))
                  (AND (CONSP |p|) (EQ (QCAR |p|) 'OR)
                       (PROGN (SPADLET |lp| (QCDR |p|)) 'T)))
              (UNIONQ (PROG (G166148)
                        (SPADLET G166148 NIL)
                        (RETURN
                          (DO ((G166153 |lp| (CDR G166153))
                               (|p1| NIL))
                              ((OR (ATOM G166153)
                                   (PROGN
                                     (SETQ |p1| (CAR G166153))
                                     NIL))
                               G166148)
                            (SEQ (EXIT (SETQ G166148
                                        (APPEND G166148
                                         (|listOfPredOfTypePatternIds|
                                          |p1|))))))))
                      NIL))
             ((AND (CONSP |p|)
                   (PROGN
                     (SPADLET |op| (QCAR |p|))
                     (SPADLET |ISTMP#1| (QCDR |p|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (SPADLET |a| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)))))
                   (BOOT-EQUAL |op| '|ofType|))
              (COND ((|isPatternVar| |a|) (CONS |a| NIL)) ('T NIL)))
             ('T NIL))))))

;removeIsDomains pred ==
;  pred is ['isDomain,a,b] => true
;  pred is ['AND,:predl] =>
;    MKPF([x for x in predl | x isnt ['isDomain,:.]],'AND)
;  pred

(DEFUN |removeIsDomains| (|pred|)
  (PROG (|ISTMP#1| |a| |ISTMP#2| |b| |predl|)
    (RETURN
      (SEQ (COND
             ((AND (CONSP |pred|) (EQ (QCAR |pred|) '|isDomain|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |pred|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (SPADLET |a| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |b| (QCAR |ISTMP#2|))
                                   'T))))))
              'T)
             ((AND (CONSP |pred|) (EQ (QCAR |pred|) 'AND)
                   (PROGN (SPADLET |predl| (QCDR |pred|)) 'T))
              (MKPF (PROG (G166191)
                      (SPADLET G166191 NIL)
                      (RETURN
                        (DO ((G166197 |predl| (CDR G166197))
                             (|x| NIL))
                            ((OR (ATOM G166197)
                                 (PROGN
                                   (SETQ |x| (CAR G166197))
                                   NIL))
                             (NREVERSE0 G166191))
                          (SEQ (EXIT (COND
                                       ((NULL
                                         (AND (CONSP |x|)
                                          (EQ (QCAR |x|) '|isDomain|)))
                                        (SETQ G166191
                                         (CONS |x| G166191)))))))))
                    'AND))
             ('T |pred|))))))

;canRemoveIsDomain? pred ==
;  -- returns nil OR an alist for substitutions of domains ordered so that
;  -- after substituting for each pair in turn, no left-hand names remain
;  alist :=
;    pred is ['isDomain,a,b] => [[a,:b],:alist]
;    pred is ['AND,:predl] =>
;      [[a,:b] for pred in predl | pred is ['isDomain,a,b]]
;  findSubstitutionOrder? alist

(DEFUN |canRemoveIsDomain?| (|pred|)
  (PROG (|predl| |ISTMP#1| |a| |ISTMP#2| |b| |alist|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |alist|
                      (COND
                        ((AND (CONSP |pred|)
                              (EQ (QCAR |pred|) '|isDomain|)
                              (PROGN
                                (SPADLET |ISTMP#1| (QCDR |pred|))
                                (AND (CONSP |ISTMP#1|)
                                     (PROGN
                                       (SPADLET |a| (QCAR |ISTMP#1|))
                                       (SPADLET |ISTMP#2|
                                        (QCDR |ISTMP#1|))
                                       (AND (CONSP |ISTMP#2|)
                                        (EQ (QCDR |ISTMP#2|) NIL)
                                        (PROGN
                                          (SPADLET |b|
                                           (QCAR |ISTMP#2|))
                                          'T))))))
                         (CONS (CONS |a| |b|) |alist|))
                        ((AND (CONSP |pred|) (EQ (QCAR |pred|) 'AND)
                              (PROGN
                                (SPADLET |predl| (QCDR |pred|))
                                'T))
                         (PROG (G166251)
                           (SPADLET G166251 NIL)
                           (RETURN
                             (DO ((G166257 |predl| (CDR G166257))
                                  (|pred| NIL))
                                 ((OR (ATOM G166257)
                                      (PROGN
                                        (SETQ |pred| (CAR G166257))
                                        NIL))
                                  (NREVERSE0 G166251))
                               (SEQ (EXIT
                                     (COND
                                       ((AND (CONSP |pred|)
                                         (EQ (QCAR |pred|) '|isDomain|)
                                         (PROGN
                                           (SPADLET |ISTMP#1|
                                            (QCDR |pred|))
                                           (AND (CONSP |ISTMP#1|)
                                            (PROGN
                                              (SPADLET |a|
                                               (QCAR |ISTMP#1|))
                                              (SPADLET |ISTMP#2|
                                               (QCDR |ISTMP#1|))
                                              (AND (CONSP |ISTMP#2|)
                                               (EQ (QCDR |ISTMP#2|)
                                                NIL)
                                               (PROGN
                                                 (SPADLET |b|
                                                  (QCAR |ISTMP#2|))
                                                 'T))))))
                                        (SETQ G166251
                                         (CONS (CONS |a| |b|)
                                          G166251))))))))))))
             (|findSubstitutionOrder?| |alist|))))))

;findSubstitutionOrder? alist == fn(alist,nil) where
;  -- returns NIL or an appropriate substituion order
;  fn(alist,res) ==
;    null alist => NREVERSE res
;    choice := or/[x for (x:=[a,:b]) in alist | null containedRight(a,alist)] =>
;      fn(DELETE(choice,alist),[choice,:res])
;    nil

(DEFUN |findSubstitutionOrder?,fn| (|alist| |res|)
  (PROG (|a| |b| |choice|)
    (RETURN
      (SEQ (IF (NULL |alist|) (EXIT (NREVERSE |res|)))
           (IF (SPADLET |choice|
                        (PROG (G166281)
                          (SPADLET G166281 NIL)
                          (RETURN
                            (DO ((G166289 NIL G166281)
                                 (G166290 |alist| (CDR G166290))
                                 (|x| NIL))
                                ((OR G166289 (ATOM G166290)
                                     (PROGN
                                       (SETQ |x| (CAR G166290))
                                       NIL)
                                     (PROGN
                                       (PROGN
                                         (SPADLET |a| (CAR |x|))
                                         (SPADLET |b| (CDR |x|))
                                         |x|)
                                       NIL))
                                 G166281)
                              (SEQ (EXIT
                                    (COND
                                      ((NULL
                                        (|containedRight| |a| |alist|))
                                       (SETQ G166281
                                        (OR G166281 |x|))))))))))
               (EXIT (|findSubstitutionOrder?,fn|
                         (|delete| |choice| |alist|)
                         (CONS |choice| |res|))))
           (EXIT NIL)))))

(DEFUN |findSubstitutionOrder?| (|alist|)
  (|findSubstitutionOrder?,fn| |alist| NIL))

;containedRight(x,alist)== or/[CONTAINED(x,y) for [.,:y] in alist]

(DEFUN |containedRight| (|x| |alist|)
  (PROG (|y|)
    (RETURN
      (SEQ (PROG (G166312)
             (SPADLET G166312 NIL)
             (RETURN
               (DO ((G166319 NIL G166312)
                    (G166320 |alist| (CDR G166320))
                    (G166309 NIL))
                   ((OR G166319 (ATOM G166320)
                        (PROGN (SETQ G166309 (CAR G166320)) NIL)
                        (PROGN
                          (PROGN
                            (SPADLET |y| (CDR G166309))
                            G166309)
                          NIL))
                    G166312)
                 (SEQ (EXIT (SETQ G166312
                                  (OR G166312 (CONTAINED |x| |y|))))))))))))

;removeIsDomainD pred ==
;  pred is ['isDomain,'D,D] =>
;    [D,nil]
;  pred is ['AND,:preds] =>
;    D := nil
;    for p in preds while not D repeat
;      p is ['isDomain,'D,D1] =>
;        D := D1
;        npreds := DELETE(['isDomain,'D,D1],preds)
;    D =>
;      1 = #npreds => [D,first npreds]
;      [D,['AND,:npreds]]
;    nil
;  nil

(DEFUN |removeIsDomainD| (|pred|)
  (PROG (|preds| |ISTMP#1| |ISTMP#2| D1 D |npreds|)
    (RETURN
      (SEQ (COND
             ((AND (CONSP |pred|) (EQ (QCAR |pred|) '|isDomain|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |pred|))
                     (AND (CONSP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) 'D)
                          (PROGN
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET D (QCAR |ISTMP#2|))
                                   'T))))))
              (CONS D (CONS NIL NIL)))
             ((AND (CONSP |pred|) (EQ (QCAR |pred|) 'AND)
                   (PROGN (SPADLET |preds| (QCDR |pred|)) 'T))
              (SPADLET D NIL)
              (SEQ (DO ((G166369 |preds| (CDR G166369)) (|p| NIL))
                       ((OR (ATOM G166369)
                            (PROGN (SETQ |p| (CAR G166369)) NIL)
                            (NULL (NULL D)))
                        NIL)
                     (SEQ (EXIT (COND
                                  ((AND (CONSP |p|)
                                    (EQ (QCAR |p|) '|isDomain|)
                                    (PROGN
                                      (SPADLET |ISTMP#1| (QCDR |p|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCAR |ISTMP#1|) 'D)
                                       (PROGN
                                         (SPADLET |ISTMP#2|
                                          (QCDR |ISTMP#1|))
                                         (AND (CONSP |ISTMP#2|)
                                          (EQ (QCDR |ISTMP#2|) NIL)
                                          (PROGN
                                            (SPADLET D1
                                             (QCAR |ISTMP#2|))
                                            'T))))))
                                   (EXIT
                                    (PROGN
                                      (SPADLET D D1)
                                      (SPADLET |npreds|
                                       (|delete|
                                        (CONS '|isDomain|
                                         (CONS 'D (CONS D1 NIL)))
                                        |preds|)))))))))
                   (COND
                     (D (EXIT (COND
                                ((EQL 1 (|#| |npreds|))
                                 (CONS D (CONS (CAR |npreds|) NIL)))
                                ('T
                                 (CONS D
                                       (CONS (CONS 'AND |npreds|) NIL)))))))
                   NIL))
             ('T NIL))))))

;formatModemap modemap ==
;  [[dc,target,:sl],pred,:.]:= modemap
;  if alist := canRemoveIsDomain? pred then
;    dc:= substInOrder(alist,dc)
;    pred:= substInOrder(alist,removeIsDomains pred)
;    target:= substInOrder(alist,target)
;    sl:= substInOrder(alist,sl)
;  else if removeIsDomainD pred is [D,npred] then
;    pred := SUBST(D,'D,npred)
;    target := SUBST(D,'D,target)
;    sl := SUBST(D,'D,sl)
;  predPart:= formatIf pred
;  targetPart:= prefix2String target
;  argTypeList:=
;    null sl => nil
;    concat(prefix2String first sl,fn(rest sl)) where
;      fn l ==
;        null l => nil
;        concat(",",prefix2String first l,fn rest l)
;  argPart:=
;    #sl<2 => argTypeList
;    ['"_(",:argTypeList,'"_)"]
;  fromPart:=
;    if dc = 'D and D
;      then concat('%b,'"from",'%d,prefix2String D)
;      else concat('%b,'"from",'%d,prefix2String dc)
;  firstPart:= concat('" ",argPart,'" -> ",targetPart)
;  sayWidth firstPart + sayWidth fromPart > 74 => --allow 5 spaces for " [n]"
;    fromPart:= concat('" ",fromPart)
;    secondPart :=
;      sayWidth fromPart + sayWidth predPart < 75 =>
;        concat(fromPart,predPart)
;      concat(fromPart,'%l,predPart)
;    concat(firstPart,'%l,secondPart)
;  firstPart:= concat(firstPart,fromPart)
;  sayWidth firstPart + sayWidth predPart < 80 =>
;    concat(firstPart,predPart)
;  concat(firstPart,'%l,predPart)

(DEFUN |formatModemap,fn| (|l|)
  (SEQ (IF (NULL |l|) (EXIT NIL))
       (EXIT (|concat| '|,| (|prefix2String| (CAR |l|))
                 (|formatModemap,fn| (CDR |l|))))))

(DEFUN |formatModemap| (|modemap|)
  (PROG (|alist| |dc| |ISTMP#1| D |ISTMP#2| |npred| |pred| |target|
                 |sl| |predPart| |targetPart| |argTypeList| |argPart|
                 |fromPart| |secondPart| |firstPart|)
    (RETURN
      (PROGN
        (SPADLET |dc| (CAAR |modemap|))
        (SPADLET |target| (CADAR |modemap|))
        (SPADLET |sl| (CDDAR |modemap|))
        (SPADLET |pred| (CADR |modemap|))
        (COND
          ((SPADLET |alist| (|canRemoveIsDomain?| |pred|))
           (SPADLET |dc| (|substInOrder| |alist| |dc|))
           (SPADLET |pred|
                    (|substInOrder| |alist| (|removeIsDomains| |pred|)))
           (SPADLET |target| (|substInOrder| |alist| |target|))
           (SPADLET |sl| (|substInOrder| |alist| |sl|)))
          ((PROGN
             (SPADLET |ISTMP#1| (|removeIsDomainD| |pred|))
             (AND (CONSP |ISTMP#1|)
                  (PROGN
                    (SPADLET D (QCAR |ISTMP#1|))
                    (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                    (AND (CONSP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)
                         (PROGN (SPADLET |npred| (QCAR |ISTMP#2|)) 'T)))))
           (SPADLET |pred| (MSUBST D 'D |npred|))
           (SPADLET |target| (MSUBST D 'D |target|))
           (SPADLET |sl| (MSUBST D 'D |sl|)))
          ('T NIL))
        (SPADLET |predPart| (|formatIf| |pred|))
        (SPADLET |targetPart| (|prefix2String| |target|))
        (SPADLET |argTypeList|
                 (COND
                   ((NULL |sl|) NIL)
                   ('T
                    (|concat| (|prefix2String| (CAR |sl|))
                        (|formatModemap,fn| (CDR |sl|))))))
        (SPADLET |argPart|
                 (COND
                   ((QSLESSP (|#| |sl|) 2) |argTypeList|)
                   ('T
                    (CONS "(" (APPEND |argTypeList| (CONS ")" NIL))))))
        (SPADLET |fromPart|
                 (COND
                   ((AND (BOOT-EQUAL |dc| 'D) D)
                    (|concat| '|%b| "from" '|%d|
                        (|prefix2String| D)))
                   ('T
                    (|concat| '|%b| "from" '|%d|
                        (|prefix2String| |dc|)))))
        (SPADLET |firstPart|
                 (|concat| " " |argPart| " -> " |targetPart|))
        (COND
          ((> (PLUS (|sayWidth| |firstPart|) (|sayWidth| |fromPart|))
              74)
           (SPADLET |fromPart| (|concat| " " |fromPart|))
           (SPADLET |secondPart|
                    (COND
                      ((> 75
                          (PLUS (|sayWidth| |fromPart|)
                                (|sayWidth| |predPart|)))
                       (|concat| |fromPart| |predPart|))
                      ('T (|concat| |fromPart| '|%l| |predPart|))))
           (|concat| |firstPart| '|%l| |secondPart|))
          ('T (SPADLET |firstPart| (|concat| |firstPart| |fromPart|))
           (COND
             ((> 80
                 (PLUS (|sayWidth| |firstPart|)
                       (|sayWidth| |predPart|)))
              (|concat| |firstPart| |predPart|))
             ('T (|concat| |firstPart| '|%l| |predPart|)))))))))

;substInOrder(alist,x) ==
;  alist is [[a,:b],:y] => substInOrder(y,SUBST(b,a,x))
;  x

(DEFUN |substInOrder| (|alist| |x|)
  (PROG (|ISTMP#1| |a| |b| |y|)
    (RETURN
      (COND
        ((AND (CONSP |alist|)
              (PROGN
                (SPADLET |ISTMP#1| (QCAR |alist|))
                (AND (CONSP |ISTMP#1|)
                     (PROGN
                       (SPADLET |a| (QCAR |ISTMP#1|))
                       (SPADLET |b| (QCDR |ISTMP#1|))
                       'T)))
              (PROGN (SPADLET |y| (QCDR |alist|)) 'T))
         (|substInOrder| |y| (MSUBST |b| |a| |x|)))
        ('T |x|)))))

;reportOpSymbol op1 ==
;  op := (STRINGP op1 => INTERN op1; op1)
;  modemaps := getAllModemapsFromDatabase(op,nil)
;  null modemaps =>
;    ok := true
;    sayKeyedMsg("S2IF0010",[op1])
;    if SIZE PNAME op1 < 3 then
;      x := UPCASE queryUserKeyedMsg("S2IZ0060",[op1])
;      null MEMQ(STRING2ID_-N(x,1),'(Y YES)) =>
;        ok := nil
;        sayKeyedMsg("S2IZ0061",[op1])
;    ok => apropos [op1]
;  sayNewLine()
;  -- filter modemaps on whether they are exposed
;  mmsE := mmsU := NIL
;  domlist := NIL
;  for mm in modemaps repeat
;    dom := getDomainFromMm(mm)
;    PUSHNEW(dom,domlist)
;    isFreeFunctionFromMm(mm) or isExposedConstructor dom =>
;      mmsE := [mm,:mmsE]
;    mmsU := [mm,:mmsU]
;  if mmsE then
;    sayMms(op,mmsE,'"exposed") where
;      sayMms(op,mms,label) ==
;        m := # mms
;        sayMSG
;          m = 1 =>
;            ['"There is one",:bright label,'"function called",
;              :bright op,'":"]
;          ['"There are ",m,:bright label,'"functions called",
;            :bright op,'":"]
;        for mm in mms for i in 1.. repeat
;          sayModemapWithNumber(mm,i)
;  if mmsU then
;    if mmsE then sayNewLine()
;    sayMms(op,mmsU,'"unexposed")
;  for adom in domlist repeat
;   doc := GETDATABASE(adom,'DOCUMENTATION)
;   docs := CDR(ASSOC(op,doc))
;   sayNewLine()
;   sayBrightly ['"Examples of ",op," from ",adom]
;   sayNewLine()
;   for export in docs repeat
;    SAYEXAMPLE(CADR(export))
;  nil

(DEFUN |reportOpSymbol,sayMms| (|op| |mms| |label|)
  (PROG (|m|)
    (RETURN
      (SEQ (SPADLET |m| (|#| |mms|))
           (|sayMSG|
               (SEQ (IF (EQL |m| 1)
                        (EXIT (CONS "There is one"
                                    (APPEND (|bright| |label|)
                                     (CONS "function called"
                                      (APPEND (|bright| |op|)
                                       (CONS ":" NIL)))))))
                    (EXIT (CONS "There are "
                                (CONS |m|
                                      (APPEND (|bright| |label|)
                                       (CONS "functions called"
                                        (APPEND (|bright| |op|)
                                         (CONS ":" NIL)))))))))
           (EXIT (DO ((G166477 |mms| (CDR G166477)) (|mm| NIL)
                      (|i| 1 (QSADD1 |i|)))
                     ((OR (ATOM G166477)
                          (PROGN (SETQ |mm| (CAR G166477)) NIL))
                      NIL)
                   (SEQ (EXIT (|sayModemapWithNumber| |mm| |i|)))))))))

(DEFUN |reportOpSymbol| (|op1|)
  (PROG (|op| |modemaps| |x| |ok| |domlist| |dom| |mmsE| |mmsU| |doc|
              |docs|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |op|
                      (COND
                        ((STRINGP |op1|) (INTERN |op1|))
                        ('T |op1|)))
             (SPADLET |modemaps|
                      (|getAllModemapsFromDatabase| |op| NIL))
             (COND
               ((NULL |modemaps|) (SPADLET |ok| 'T)
                (|sayKeyedMsg| 'S2IF0010 (CONS |op1| NIL))
                (COND
                  ((> 3 (SIZE (PNAME |op1|)))
                   (SPADLET |x|
                            (UPCASE (|queryUserKeyedMsg| 'S2IZ0060
                                     (CONS |op1| NIL))))
                   (COND
                     ((NULL (member (STRING2ID-N |x| 1) '(Y YES)))
                      (PROGN
                        (SPADLET |ok| NIL)
                        (|sayKeyedMsg| 'S2IZ0061 (CONS |op1| NIL)))))))
                (COND (|ok| (|apropos| (CONS |op1| NIL)))))
               ('T (|sayNewLine|) (SPADLET |mmsE| (SPADLET |mmsU| NIL))
                (SPADLET |domlist| NIL)
                (DO ((G166497 |modemaps| (CDR G166497)) (|mm| NIL))
                    ((OR (ATOM G166497)
                         (PROGN (SETQ |mm| (CAR G166497)) NIL))
                     NIL)
                  (SEQ (EXIT (PROGN
                               (SPADLET |dom| (|getDomainFromMm| |mm|))
                               (PUSHNEW |dom| |domlist|)
                               (COND
                                 ((OR (|isFreeFunctionFromMm| |mm|)
                                      (|isExposedConstructor| |dom|))
                                  (SPADLET |mmsE| (CONS |mm| |mmsE|)))
                                 ('T
                                  (SPADLET |mmsU| (CONS |mm| |mmsU|))))))))
                (COND
                  (|mmsE| (|reportOpSymbol,sayMms| |op| |mmsE|
                              "exposed")))
                (COND
                  (|mmsU| (COND (|mmsE| (|sayNewLine|)))
                          (|reportOpSymbol,sayMms| |op| |mmsU|
                              "unexposed")))
                (DO ((G166512 |domlist| (CDR G166512))
                     (|adom| NIL))
                    ((OR (ATOM G166512)
                         (PROGN (SETQ |adom| (CAR G166512)) NIL))
                     NIL)
                  (SEQ (EXIT (PROGN
                               (SPADLET |doc|
                                        (GETDATABASE |adom|
                                         'DOCUMENTATION))
                               (SPADLET |docs|
                                        (CDR (|assoc| |op| |doc|)))
                               (|sayNewLine|)
                               (|sayBrightly|
                                   (CONS "Examples of "
                                    (CONS |op|
                                     (CONS " from " (CONS |adom| NIL)))))
                               (|sayNewLine|)
                               (DO ((G166521 |docs| (CDR G166521))
                                    (|export| NIL))
                                   ((OR (ATOM G166521)
                                     (PROGN
                                       (SETQ |export| (CAR G166521))
                                       NIL))
                                    NIL)
                                 (SEQ (EXIT
                                       (SAYEXAMPLE (CADR |export|)))))))))
                NIL)))))))

;formatOpType (form:=[op,:argl]) ==
;  null argl => unabbrev op
;  form2String [unabbrev op, :argl]

(DEFUN |formatOpType| (|form|)
  (PROG (|op| |argl|)
    (RETURN
      (PROGN
        (SPADLET |op| (CAR |form|))
        (SPADLET |argl| (CDR |form|))
        (COND
          ((NULL |argl|) (|unabbrev| |op|))
          ('T (|form2String| (CONS (|unabbrev| |op|) |argl|))))))))

;formatOperationAlistEntry (entry:= [op,:modemaps]) ==
;  -- alist has entries of the form: ((op sig) . pred)
;  -- opsig on this list => op is defined only when the predicate is true
;  ans:= nil
;  for [sig,.,:predtail] in modemaps repeat
;    pred := (predtail is [p,:.] => p; 'T)
;    -- operation is always defined
;    ans :=
;      [concat(formatOpSignature(op,sig),formatIf pred),:ans]
;  ans

(DEFUN |formatOperationAlistEntry| (|entry|)
  (PROG (|op| |modemaps| |sig| |predtail| |p| |pred| |ans|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |op| (CAR |entry|))
             (SPADLET |modemaps| (CDR |entry|))
             (SPADLET |ans| NIL)
             (DO ((G166585 |modemaps| (CDR G166585))
                  (G166559 NIL))
                 ((OR (ATOM G166585)
                      (PROGN (SETQ G166559 (CAR G166585)) NIL)
                      (PROGN
                        (PROGN
                          (SPADLET |sig| (CAR G166559))
                          (SPADLET |predtail| (CDDR G166559))
                          G166559)
                        NIL))
                  NIL)
               (SEQ (EXIT (PROGN
                            (SPADLET |pred|
                                     (COND
                                       ((AND (CONSP |predtail|)
                                         (PROGN
                                           (SPADLET |p|
                                            (QCAR |predtail|))
                                           'T))
                                        |p|)
                                       ('T 'T)))
                            (SPADLET |ans|
                                     (CONS
                                      (|concat|
                                       (|formatOpSignature| |op| |sig|)
                                       (|formatIf| |pred|))
                                      |ans|))))))
             |ans|)))))


;formatOperation([[op,sig],.,[fn,.,n]],domain) ==
;  opSigString := formatOpSignature(op,sig)
;  INTEGERP n and Undef = KAR domain.n =>
;    if INTEGERP $commentedOps then $commentedOps := $commentedOps + 1
;    concat(" --",opSigString)
;  opSigString

(DEFUN |formatOperation| (G166605 |domain|)
  (PROG (|op| |sig| |fn| |n| |opSigString|)
    (DECLARE (SPECIAL |$commentedOps|))
    (RETURN
      (PROGN
        (SPADLET |op| (CAAR G166605))
        (SPADLET |sig| (CADAR G166605))
        (SPADLET |fn| (CAADDR G166605))
        (SPADLET |n| (CADR (CDADDR G166605)))
        (SPADLET |opSigString| (|formatOpSignature| |op| |sig|))
        (COND
          ((AND (INTEGERP |n|)
                (BOOT-EQUAL |Undef| (KAR (ELT |domain| |n|))))
           (COND
             ((INTEGERP |$commentedOps|)
              (SPADLET |$commentedOps| (PLUS |$commentedOps| 1))))
           (|concat| '| --| |opSigString|))
          ('T |opSigString|))))))

;formatOpSignature(op,sig) ==
;  concat('%b,formatOpSymbol(op,sig),'%d,": ",formatSignature sig)

(DEFUN |formatOpSignature| (|op| |sig|)
  (|concat| '|%b| (|formatOpSymbol| |op| |sig|) '|%d| '|: |
      (|formatSignature| |sig|)))

;formatOpConstant op ==
;  concat('%b,formatOpSymbol(op,'($)),'%d,'": constant")

(DEFUN |formatOpConstant| (|op|)
  (|concat| '|%b| (|formatOpSymbol| |op| '($)) '|%d|
      ": constant"))

;formatOpSymbol(op,sig) ==
;  if op = 'Zero then op := "0"
;  else if op = 'One then op := "1"
;  null sig => op
;  quad := specialChar 'quad
;  n := #sig
;  (op = 'elt) and (n = 3) =>
;    (CADR(sig) = '_$) =>
;      STRINGP (sel := CADDR(sig)) =>
;        [quad,".",sel]
;      [quad,".",quad]
;    op
;  STRINGP op or GET(op,"Led") or GET(op,"Nud") =>
;    n = 3 =>
;      if op = 'SEGMENT then op := '".."
;      op = 'in => [quad,'" ",op,'" ",quad]
;-- stop exquo from being displayed as infix (since it is not accepted
;-- as such by the interpreter)
;      op = 'exquo => op
;      [quad,op,quad]
;    n = 2 =>
;      not GET(op,"Nud") => [quad,op]
;      [op,quad]
;    op
;  op

(DEFUN |formatOpSymbol| (|op| |sig|)
  (PROG (|quad| |n| |sel|)
    (RETURN
      (PROGN
        (COND
          ((BOOT-EQUAL |op| '|Zero|) (SPADLET |op| '|0|))
          ((BOOT-EQUAL |op| '|One|) (SPADLET |op| '|1|))
          ('T NIL))
        (COND
          ((NULL |sig|) |op|)
          ('T (SPADLET |quad| (|specialChar| '|quad|))
           (SPADLET |n| (|#| |sig|))
           (COND
             ((AND (BOOT-EQUAL |op| '|elt|) (EQL |n| 3))
              (COND
                ((BOOT-EQUAL (CADR |sig|) '$)
                 (COND
                   ((STRINGP (SPADLET |sel| (CADDR |sig|)))
                    (CONS |quad|
                          (CONS (INTERN "." "BOOT") (CONS |sel| NIL))))
                   ('T
                    (CONS |quad|
                          (CONS (INTERN "." "BOOT") (CONS |quad| NIL))))))
                ('T |op|)))
             ((OR (STRINGP |op|) (GETL |op| '|Led|) (GETL |op| '|Nud|))
              (COND
                ((EQL |n| 3)
                 (COND
                   ((BOOT-EQUAL |op| 'SEGMENT)
                    (SPADLET |op| "..")))
                 (COND
                   ((BOOT-EQUAL |op| '|in|)
                    (CONS |quad|
                          (CONS " "
                                (CONS |op|
                                      (CONS " " (CONS |quad| NIL))))))
                   ((BOOT-EQUAL |op| '|exquo|) |op|)
                   ('T (CONS |quad| (CONS |op| (CONS |quad| NIL))))))
                ((EQL |n| 2)
                 (COND
                   ((NULL (GETL |op| '|Nud|))
                    (CONS |quad| (CONS |op| NIL)))
                   ('T (CONS |op| (CONS |quad| NIL)))))
                ('T |op|)))
             ('T |op|))))))))

;formatAttribute x ==
;  atom x => ["  ",x]
;  x is [op,:argl] =>
;    for x in argl repeat
;      argPart:= NCONC(argPart,concat(",",formatAttributeArg x))
;    argPart => concat("  ",op,"_(",rest argPart,"_)")
;    ["  ",op]

(DEFUN |formatAttribute| (|x|)
  (PROG (|op| |argl| |argPart|)
    (RETURN
      (SEQ (COND
             ((ATOM |x|) (CONS '|  | (CONS |x| NIL)))
             ((AND (CONSP |x|)
                   (PROGN
                     (SPADLET |op| (QCAR |x|))
                     (SPADLET |argl| (QCDR |x|))
                     'T))
              (DO ((G166656 |argl| (CDR G166656)) (|x| NIL))
                  ((OR (ATOM G166656)
                       (PROGN (SETQ |x| (CAR G166656)) NIL))
                   NIL)
                (SEQ (EXIT (SPADLET |argPart|
                                    (NCONC |argPart|
                                     (|concat| '|,|
                                      (|formatAttributeArg| |x|)))))))
              (COND
                (|argPart|
                    (|concat| '|  | |op| '|(| (CDR |argPart|) '|)|))
                ('T (CONS '|  | (CONS |op| NIL))))))))))

;formatAttributeArg x ==
;  STRINGP x and x ='"*" => "_"*_""
;  atom x => formatOpSymbol (x,nil)
;  x is [":",op,["Mapping",:sig]] =>
;    concat('%b,formatOpSymbol(op,sig),": ",'%d,formatMapping sig)
;  prefix2String0 x

(DEFUN |formatAttributeArg| (|x|)
  (PROG (|ISTMP#1| |op| |ISTMP#2| |ISTMP#3| |sig|)
    (RETURN
      (COND
        ((AND (STRINGP |x|) (BOOT-EQUAL |x| "*")) '|"*"|)
        ((ATOM |x|) (|formatOpSymbol| |x| NIL))
        ((AND (CONSP |x|) (EQ (QCAR |x|) '|:|)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |x|))
                (AND (CONSP |ISTMP#1|)
                     (PROGN
                       (SPADLET |op| (QCAR |ISTMP#1|))
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (CONSP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)
                            (PROGN
                              (SPADLET |ISTMP#3| (QCAR |ISTMP#2|))
                              (AND (CONSP |ISTMP#3|)
                                   (EQ (QCAR |ISTMP#3|) '|Mapping|)
                                   (PROGN
                                     (SPADLET |sig| (QCDR |ISTMP#3|))
                                     'T))))))))
         (|concat| '|%b| (|formatOpSymbol| |op| |sig|) '|: | '|%d|
             (|formatMapping| |sig|)))
        ('T (|prefix2String0| |x|))))))

;formatMapping sig ==
;  "STRCONC"/concat("Mapping(",formatSignature sig,")")

(DEFUN |formatMapping| (|sig|)
  (PROG ()
    (RETURN
      (SEQ (PROG (G166704)
             (SPADLET G166704 "")
             (RETURN
               (DO ((G166709
                        (|concat| '|Mapping(| (|formatSignature| |sig|)
                            '|)|)
                        (CDR G166709))
                    (G166703 NIL))
                   ((OR (ATOM G166709)
                        (PROGN (SETQ G166703 (CAR G166709)) NIL))
                    G166704)
                 (SEQ (EXIT (SETQ G166704
                                  (STRCONC G166704 G166703)))))))))))

;dollarPercentTran x ==
;    -- Translate $ to %. We actually return %% so that the message
;    -- printer will display a single %
;    x is [y,:z] =>
;        y1 := dollarPercentTran y
;        z1 := dollarPercentTran z
;        EQ(y, y1) and EQ(z, z1) => x
;        [y1, :z1]
;    x = "$" or x = '"$" => "%%"
;    x

(DEFUN |dollarPercentTran| (|x|)
  (PROG (|y| |z| |y1| |z1|)
    (RETURN
      (COND
        ((AND (CONSP |x|)
              (PROGN
                (SPADLET |y| (QCAR |x|))
                (SPADLET |z| (QCDR |x|))
                'T))
         (SPADLET |y1| (|dollarPercentTran| |y|))
         (SPADLET |z1| (|dollarPercentTran| |z|))
         (COND
           ((AND (EQ |y| |y1|) (EQ |z| |z1|)) |x|)
           ('T (CONS |y1| |z1|))))
        ((OR (BOOT-EQUAL |x| '$) (BOOT-EQUAL |x| "$"))
         '%%)
        ('T |x|)))))

;formatSignatureAsTeX sig ==
;  $formatSigAsTeX: local := 2
;  formatSignature0 sig

(DEFUN |formatSignatureAsTeX| (|sig|)
  (PROG (|$formatSigAsTeX|)
    (DECLARE (SPECIAL |$formatSigAsTeX|))
    (RETURN
      (PROGN (SPADLET |$formatSigAsTeX| 2) (|formatSignature0| |sig|)))))

;formatSignature sig ==
;  $formatSigAsTeX: local := 1
;  formatSignature0 sig

(DEFUN |formatSignature| (|sig|)
  (PROG (|$formatSigAsTeX|)
    (DECLARE (SPECIAL |$formatSigAsTeX|))
    (RETURN
      (PROGN (SPADLET |$formatSigAsTeX| 1) (|formatSignature0| |sig|)))))

;formatSignatureArgs sml ==
;  $formatSigAsTeX: local := 1
;  formatSignatureArgs0 sml

(DEFUN |formatSignatureArgs| (|sml|)
  (PROG (|$formatSigAsTeX|)
    (DECLARE (SPECIAL |$formatSigAsTeX|))
    (RETURN
      (PROGN
        (SPADLET |$formatSigAsTeX| 1)
        (|formatSignatureArgs0| |sml|)))))

;formatSignature0 sig ==
;  null sig => "() -> ()"
;  INTEGERP sig => '"hashcode"
;  [tm,:sml] := sig
;  sourcePart:= formatSignatureArgs0 sml
;  targetPart:= prefix2String0 tm
;  dollarPercentTran concat(sourcePart,concat(" -> ",targetPart))

(DEFUN |formatSignature0| (|sig|)
  (PROG (|tm| |sml| |sourcePart| |targetPart|)
    (RETURN
      (COND
        ((NULL |sig|) '|() -> ()|)
        ((INTEGERP |sig|) "hashcode")
        ('T (SPADLET |tm| (CAR |sig|)) (SPADLET |sml| (CDR |sig|))
         (SPADLET |sourcePart| (|formatSignatureArgs0| |sml|))
         (SPADLET |targetPart| (|prefix2String0| |tm|))
         (|dollarPercentTran|
             (|concat| |sourcePart| (|concat| '| -> | |targetPart|))))))))

;formatSignatureArgs0(sml) ==
;-- formats the arguments of a signature
;  null sml => ["_(_)"]
;  null rest sml => prefix2String0 first sml
;  argList:= prefix2String0 first sml
;  for m in rest sml repeat
;    argList:= concat(argList,concat(",",prefix2String0 m))
;  concat("_(",concat(argList,"_)"))

(DEFUN |formatSignatureArgs0| (|sml|)
  (PROG (|argList|)
    (RETURN
      (SEQ (COND
             ((NULL |sml|) (CONS '|()| NIL))
             ((NULL (CDR |sml|)) (|prefix2String0| (CAR |sml|)))
             ('T (SPADLET |argList| (|prefix2String0| (CAR |sml|)))
              (DO ((G166767 (CDR |sml|) (CDR G166767)) (|m| NIL))
                  ((OR (ATOM G166767)
                       (PROGN (SETQ |m| (CAR G166767)) NIL))
                   NIL)
                (SEQ (EXIT (SPADLET |argList|
                                    (|concat| |argList|
                                     (|concat| '|,|
                                      (|prefix2String0| |m|)))))))
              (|concat| '|(| (|concat| |argList| '|)|))))))))

;--% Conversions to string form
;expr2String x ==
;  atom (u:= prefix2String0 x) => u
;  "STRCONC"/[atom2String y for y in u]

(DEFUN |expr2String| (|x|)
  (PROG (|u|)
    (RETURN
      (SEQ (COND
             ((ATOM (SPADLET |u| (|prefix2String0| |x|))) |u|)
             ('T
              (PROG (G166779)
                (SPADLET G166779 "")
                (RETURN
                  (DO ((G166784 |u| (CDR G166784)) (|y| NIL))
                      ((OR (ATOM G166784)
                           (PROGN (SETQ |y| (CAR G166784)) NIL))
                       G166779)
                    (SEQ (EXIT (SETQ G166779
                                     (STRCONC G166779
                                      (|atom2String| |y|))))))))))))))

;-- exports (this is a badly named bit of sillyness)
;prefix2StringAsTeX form ==
;  form2StringAsTeX form

(DEFUN |prefix2StringAsTeX| (|form|) (|form2StringAsTeX| |form|))

;prefix2String form ==
;  form2String form

(DEFUN |prefix2String| (|form|) (|form2String| |form|)) 

;-- local version
;prefix2String0 form ==
;  form2StringLocal form

(DEFUN |prefix2String0| (|form|) (|form2StringLocal| |form|)) 

;--  SUBRP form => formWrapId BPINAME form
;--  atom form =>
;--    form=$EmptyMode or form=$quadSymbol => formWrapId specialChar 'quad
;--    STRINGP form => formWrapId form
;--    IDENTP form =>
;--      constructor? form => app2StringWrap(formWrapId form, [form])
;--      formWrapId form
;--    formWrapId STRINGIMAGE form
;form2StringWithWhere u ==
;  $permitWhere : local := true
;  $whereList: local := nil
;  s:= form2String u
;  $whereList => concat(s,'%b,'"where",'%d,"%i",$whereList,"%u")
;  s

(DEFUN |form2StringWithWhere| (|u|)
  (PROG (|$permitWhere| |$whereList| |s|)
    (DECLARE (SPECIAL |$permitWhere| |$whereList|))
    (RETURN
      (PROGN
        (SPADLET |$permitWhere| 'T)
        (SPADLET |$whereList| NIL)
        (SPADLET |s| (|form2String| |u|))
        (COND
          (|$whereList|
              (|concat| |s| '|%b| "where" '|%d| '|%i| |$whereList|
                  '|%u|))
          ('T |s|))))))

;form2StringWithPrens form ==
;  null (argl := rest form) => [first form]
;  null rest argl => [first form,"(",first argl,")"]
;  form2String form

(DEFUN |form2StringWithPrens| (|form|)
  (PROG (|argl|)
    (RETURN
      (COND
        ((NULL (SPADLET |argl| (CDR |form|))) (CONS (CAR |form|) NIL))
        ((NULL (CDR |argl|))
         (CONS (CAR |form|)
               (CONS '|(| (CONS (CAR |argl|) (CONS '|)| NIL)))))
        ('T (|form2String| |form|))))))

;formString u ==
;  x := form2String u
;  atom x => STRINGIMAGE x
;  "STRCONC"/[STRINGIMAGE y for y in x]

(DEFUN |formString| (|u|)
  (PROG (|x|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |x| (|form2String| |u|))
             (COND
               ((ATOM |x|) (STRINGIMAGE |x|))
               ('T
                (PROG (G166821)
                  (SPADLET G166821 "")
                  (RETURN
                    (DO ((G166826 |x| (CDR G166826)) (|y| NIL))
                        ((OR (ATOM G166826)
                             (PROGN (SETQ |y| (CAR G166826)) NIL))
                         G166821)
                      (SEQ (EXIT (SETQ G166821
                                       (STRCONC G166821
                                        (STRINGIMAGE |y|)))))))))))))))

;form2String u ==
;  $formatSigAsTeX: local := 1
;  form2StringLocal u

(DEFUN |form2String| (|u|)
  (PROG (|$formatSigAsTeX|)
    (DECLARE (SPECIAL |$formatSigAsTeX|))
    (RETURN
      (PROGN (SPADLET |$formatSigAsTeX| 1) (|form2StringLocal| |u|)))))

;form2StringAsTeX u ==
;  $formatSigAsTeX: local := 2
;  form2StringLocal u

(DEFUN |form2StringAsTeX| (|u|)
  (PROG (|$formatSigAsTeX|)
    (DECLARE (SPECIAL |$formatSigAsTeX|))
    (RETURN
      (PROGN (SPADLET |$formatSigAsTeX| 2) (|form2StringLocal| |u|)))))

;form2StringLocal u ==
;--+
;  $NRTmonitorIfTrue : local := nil
;  $fortInts2Floats  : local := nil
;  form2String1 u

(DEFUN |form2StringLocal| (|u|)
  (PROG (|$NRTmonitorIfTrue| |$fortInts2Floats|)
    (DECLARE (SPECIAL |$NRTmonitorIfTrue| |$fortInts2Floats|))
    (RETURN
      (PROGN
        (SPADLET |$NRTmonitorIfTrue| NIL)
        (SPADLET |$fortInts2Floats| NIL)
        (|form2String1| |u|)))))

;constructorName con ==
;  $abbreviateTypes => abbreviate con
;  con

(DEFUN |constructorName| (|con|)
  (DECLARE (SPECIAL |$abbreviateTypes|))
  (COND (|$abbreviateTypes| (|abbreviate| |con|)) ('T |con|)))

;form2String1 u ==
;  ATOM u =>
;    u=$EmptyMode or u=$quadSymbol => formWrapId specialChar 'quad
;    IDENTP u =>
;      constructor? u => app2StringWrap(formWrapId u, [u])
;      u
;    SUBRP u => formWrapId BPINAME u
;    STRINGP u => formWrapId u
;    WRITE_-TO_-STRING formWrapId u
;  u1 := u
;  op := CAR u
;  argl := CDR u
;  op='Join or op= 'mkCategory => formJoin1(op,argl)
;  $InteractiveMode and (u:= constructor? op) =>
;    null argl => app2StringWrap(formWrapId constructorName op, u1)
;    op = "NTuple"  => [ form2String1 first argl, "*"]
;    op = "Map"     => ["(",:formatSignature0 [argl.1,argl.0],")"]
;    op = 'Record => record2String(argl)
;    null (conSig := getConstructorSignature op) =>
;      application2String(constructorName op,[form2String1(a) for a in argl], u1)
;    ml := rest conSig
;    if not freeOfSharpVars ml then
;      ml:=SUBLIS([[pvar,:val] for pvar in $FormalMapVariableList
;        for val in argl], ml)
;    argl:= formArguments2String(argl,ml)
;      -- extra null check to handle mutable domain hack.
;    null argl => constructorName op
;    application2String(constructorName op,argl, u1)
;  op = "Mapping" => ["(",:formatSignature argl,")"]
;  op = "Record" => record2String(argl)
;  op = 'Union  =>
;    application2String(op,[form2String1 x for x in argl], u1)
;  op = ":" =>
;      null argl => [ '":" ]
;      null rest argl => [ '":", form2String1 first argl ]
;      formDecl2String(argl.0,argl.1)
;  op = "#" and CONSP argl and LISTP CAR argl =>
;    STRINGIMAGE SIZE CAR argl
;  op = 'Join => formJoin2String argl
;  op = "ATTRIBUTE" => form2String1 first argl
;  op='Zero => 0
;  op='One => 1
;  op = 'AGGLST => tuple2String argl
;  op = 'BRACKET =>
;    argl' := form2String1 first argl
;    ["[",:(atom argl' => [argl']; argl'),"]"]
;  op = "SIGNATURE" =>
;     [operation,sig] := argl
;     concat(operation,": ",formatSignature sig)
;  op = 'COLLECT => formCollect2String argl
;  op = 'construct =>
;    concat(lbrkSch(),
;           tuple2String [form2String1 x for x in argl],rbrkSch())
;  op = "SEGMENT" =>
;    null argl => '".."
;    lo := form2String1 first argl
;    argl := rest argl
;    (null argl) or null (first argl) => [lo, '".."]
;    [lo, '"..", form2String1 first argl]
;  isBinaryInfix op => fortexp0 [op,:argl]
;  -- COMPILED_-FUNCTION_-P(op) => form2String1 coerceMap2E(u1,NIL)
;  application2String(op,[form2String1 x for x in argl], u1)

(DEFUN |form2String1| (|u|)
  (PROG (|u1| |op| |conSig| |ml| |argl'| |operation| |sig| |lo| |argl|)
    (DECLARE (SPECIAL |$FormalMapVariableList| |$InteractiveMode|
                      |$quadSymbol| |$EmptyMode|))
    (RETURN
      (SEQ (COND
             ((ATOM |u|)
              (COND
                ((OR (BOOT-EQUAL |u| |$EmptyMode|)
                     (BOOT-EQUAL |u| |$quadSymbol|))
                 (|formWrapId| (|specialChar| '|quad|)))
                ((IDENTP |u|)
                 (COND
                   ((|constructor?| |u|)
                    (|app2StringWrap| (|formWrapId| |u|)
                        (CONS |u| NIL)))
                   ('T |u|)))
                ((SUBRP |u|) (|formWrapId| (BPINAME |u|)))
                ((STRINGP |u|) (|formWrapId| |u|))
                ('T (WRITE-TO-STRING (|formWrapId| |u|)))))
             ('T (SPADLET |u1| |u|) (SPADLET |op| (CAR |u|))
              (SPADLET |argl| (CDR |u|))
              (COND
                ((OR (BOOT-EQUAL |op| '|Join|)
                     (BOOT-EQUAL |op| '|mkCategory|))
                 (|formJoin1| |op| |argl|))
                ((AND |$InteractiveMode|
                      (SPADLET |u| (|constructor?| |op|)))
                 (COND
                   ((NULL |argl|)
                    (|app2StringWrap|
                        (|formWrapId| (|constructorName| |op|)) |u1|))
                   ((BOOT-EQUAL |op| '|NTuple|)
                    (CONS (|form2String1| (CAR |argl|)) (CONS '* NIL)))
                   ((BOOT-EQUAL |op| '|Map|)
                    (CONS '|(|
                          (APPEND (|formatSignature0|
                                      (CONS (ELT |argl| 1)
                                       (CONS (ELT |argl| 0) NIL)))
                                  (CONS '|)| NIL))))
                   ((BOOT-EQUAL |op| '|Record|)
                    (|record2String| |argl|))
                   ((NULL (SPADLET |conSig|
                                   (|getConstructorSignature| |op|)))
                    (|application2String| (|constructorName| |op|)
                        (PROG (G166881)
                          (SPADLET G166881 NIL)
                          (RETURN
                            (DO ((G166886 |argl| (CDR G166886))
                                 (|a| NIL))
                                ((OR (ATOM G166886)
                                     (PROGN
                                       (SETQ |a| (CAR G166886))
                                       NIL))
                                 (NREVERSE0 G166881))
                              (SEQ (EXIT
                                    (SETQ G166881
                                     (CONS (|form2String1| |a|)
                                      G166881)))))))
                        |u1|))
                   ('T (SPADLET |ml| (CDR |conSig|))
                    (COND
                      ((NULL (|freeOfSharpVars| |ml|))
                       (SPADLET |ml|
                                (SUBLIS (PROG (G166897)
                                          (SPADLET G166897 NIL)
                                          (RETURN
                                            (DO
                                             ((G166903
                                               |$FormalMapVariableList|
                                               (CDR G166903))
                                              (|pvar| NIL)
                                              (G166904 |argl|
                                               (CDR G166904))
                                              (|val| NIL))
                                             ((OR (ATOM G166903)
                                               (PROGN
                                                 (SETQ |pvar|
                                                  (CAR G166903))
                                                 NIL)
                                               (ATOM G166904)
                                               (PROGN
                                                 (SETQ |val|
                                                  (CAR G166904))
                                                 NIL))
                                              (NREVERSE0 G166897))
                                              (SEQ
                                               (EXIT
                                                (SETQ G166897
                                                 (CONS
                                                  (CONS |pvar| |val|)
                                                  G166897)))))))
                                        |ml|))))
                    (SPADLET |argl|
                             (|formArguments2String| |argl| |ml|))
                    (COND
                      ((NULL |argl|) (|constructorName| |op|))
                      ('T
                       (|application2String| (|constructorName| |op|)
                           |argl| |u1|))))))
                ((BOOT-EQUAL |op| '|Mapping|)
                 (CONS '|(|
                       (APPEND (|formatSignature| |argl|)
                               (CONS '|)| NIL))))
                ((BOOT-EQUAL |op| '|Record|) (|record2String| |argl|))
                ((BOOT-EQUAL |op| '|Union|)
                 (|application2String| |op|
                     (PROG (G166917)
                       (SPADLET G166917 NIL)
                       (RETURN
                         (DO ((G166922 |argl| (CDR G166922))
                              (|x| NIL))
                             ((OR (ATOM G166922)
                                  (PROGN
                                    (SETQ |x| (CAR G166922))
                                    NIL))
                              (NREVERSE0 G166917))
                           (SEQ (EXIT (SETQ G166917
                                       (CONS (|form2String1| |x|)
                                        G166917)))))))
                     |u1|))
                ((BOOT-EQUAL |op| '|:|)
                 (COND
                   ((NULL |argl|) (CONS ":" NIL))
                   ((NULL (CDR |argl|))
                    (CONS ":"
                          (CONS (|form2String1| (CAR |argl|)) NIL)))
                   ('T
                    (|formDecl2String| (ELT |argl| 0) (ELT |argl| 1)))))
                ((AND (BOOT-EQUAL |op| '|#|) (CONSP |argl|)
                      (LISTP (CAR |argl|)))
                 (STRINGIMAGE (SIZE (CAR |argl|))))
                ((BOOT-EQUAL |op| '|Join|) (|formJoin2String| |argl|))
                ((BOOT-EQUAL |op| 'ATTRIBUTE)
                 (|form2String1| (CAR |argl|)))
                ((BOOT-EQUAL |op| '|Zero|) 0)
                ((BOOT-EQUAL |op| '|One|) 1)
                ((BOOT-EQUAL |op| 'AGGLST) (|tuple2String| |argl|))
                ((BOOT-EQUAL |op| 'BRACKET)
                 (SPADLET |argl'| (|form2String1| (CAR |argl|)))
                 (CONS '[
                       (APPEND (COND
                                 ((ATOM |argl'|) (CONS |argl'| NIL))
                                 ('T |argl'|))
                               (CONS '] NIL))))
                ((BOOT-EQUAL |op| 'SIGNATURE)
                 (SPADLET |operation| (CAR |argl|))
                 (SPADLET |sig| (CADR |argl|))
                 (|concat| |operation| '|: | (|formatSignature| |sig|)))
                ((BOOT-EQUAL |op| 'COLLECT)
                 (|formCollect2String| |argl|))
                ((BOOT-EQUAL |op| '|construct|)
                 (|concat| (|lbrkSch|)
                     (|tuple2String|
                         (PROG (G166932)
                           (SPADLET G166932 NIL)
                           (RETURN
                             (DO ((G166937 |argl| (CDR G166937))
                                  (|x| NIL))
                                 ((OR (ATOM G166937)
                                      (PROGN
                                        (SETQ |x| (CAR G166937))
                                        NIL))
                                  (NREVERSE0 G166932))
                               (SEQ (EXIT
                                     (SETQ G166932
                                      (CONS (|form2String1| |x|)
                                       G166932))))))))
                     (|rbrkSch|)))
                ((BOOT-EQUAL |op| 'SEGMENT)
                 (COND
                   ((NULL |argl|) "..")
                   ('T (SPADLET |lo| (|form2String1| (CAR |argl|)))
                    (SPADLET |argl| (CDR |argl|))
                    (COND
                      ((OR (NULL |argl|) (NULL (CAR |argl|)))
                       (CONS |lo| (CONS ".." NIL)))
                      ('T
                       (CONS |lo|
                             (CONS ".."
                                   (CONS (|form2String1| (CAR |argl|))
                                    NIL))))))))
                ((|isBinaryInfix| |op|)
                 (|fortexp0| (CONS |op| |argl|)))
                ('T
                 (|application2String| |op|
                     (PROG (G166947)
                       (SPADLET G166947 NIL)
                       (RETURN
                         (DO ((G166952 |argl| (CDR G166952))
                              (|x| NIL))
                             ((OR (ATOM G166952)
                                  (PROGN
                                    (SETQ |x| (CAR G166952))
                                    NIL))
                              (NREVERSE0 G166947))
                           (SEQ (EXIT (SETQ G166947
                                       (CONS (|form2String1| |x|)
                                        G166947)))))))
                     |u1|)))))))))

;formWrapId id ==
;  $formatSigAsTeX = 1 => id
;  $formatSigAsTeX = 2 =>
;    sep := '"`"
;    FORMAT(NIL,'"\verb~a~a~a",sep, id, sep)
;  error "Bad formatSigValue"

(DEFUN |formWrapId| (|id|)
  (PROG (|sep|)
    (DECLARE (SPECIAL |$formatSigAsTeX|))
    (RETURN
      (COND
        ((EQL |$formatSigAsTeX| 1) |id|)
        ((EQL |$formatSigAsTeX| 2) (SPADLET |sep| "`")
         (FORMAT NIL "\\verb~a~a~a" |sep| |id| |sep|))
        ('T (|error| '|Bad formatSigValue|))))))

;formArguments2String(argl,ml) == [fn(x,m) for x in argl for m in ml] where
;  fn(x,m) ==
;    x=$EmptyMode or x=$quadSymbol => specialChar 'quad
;    STRINGP(x) or IDENTP(x) => x
;    x is [ ='_:,:.] => form2String1 x
;    isValidType(m) and CONSP(m) and
;      (GETDATABASE(first(m),'CONSTRUCTORKIND) = 'domain) =>
;        (x' := coerceInteractive(objNewWrap(x,m),$OutputForm)) =>
;          form2String1 objValUnwrap x'
;        form2String1 x
;    form2String1 x

(DEFUN |formArguments2String,fn| (|x| |m|)
  (PROG (|x'|)
    (DECLARE (SPECIAL |$OutputForm| |$quadSymbol| |$EmptyMode|))
    (RETURN
      (SEQ (IF (OR (BOOT-EQUAL |x| |$EmptyMode|)
                   (BOOT-EQUAL |x| |$quadSymbol|))
               (EXIT (|specialChar| '|quad|)))
           (IF (OR (STRINGP |x|) (IDENTP |x|)) (EXIT |x|))
           (IF (AND (CONSP |x|) (EQUAL (QCAR |x|) '|:|))
               (EXIT (|form2String1| |x|)))
           (IF (AND (AND (|isValidType| |m|) (CONSP |m|))
                    (BOOT-EQUAL
                        (GETDATABASE (CAR |m|) 'CONSTRUCTORKIND)
                        '|domain|))
               (EXIT (SEQ (IF (SPADLET |x'|
                                       (|coerceInteractive|
                                        (|objNewWrap| |x| |m|)
                                        |$OutputForm|))
                              (EXIT (|form2String1|
                                     (|objValUnwrap| |x'|))))
                          (EXIT (|form2String1| |x|)))))
           (EXIT (|form2String1| |x|))))))

(DEFUN |formArguments2String| (|argl| |ml|)
  (PROG ()
    (RETURN
      (SEQ (PROG (G166997)
             (SPADLET G166997 NIL)
             (RETURN
               (DO ((G167003 |argl| (CDR G167003)) (|x| NIL)
                    (G167004 |ml| (CDR G167004)) (|m| NIL))
                   ((OR (ATOM G167003)
                        (PROGN (SETQ |x| (CAR G167003)) NIL)
                        (ATOM G167004)
                        (PROGN (SETQ |m| (CAR G167004)) NIL))
                    (NREVERSE0 G166997))
                 (SEQ (EXIT (SETQ G166997
                                  (CONS (|formArguments2String,fn| |x|
                                         |m|)
                                        G166997)))))))))))

;formDecl2String(left,right) ==
;  $declVar: local := left
;  whereBefore := $whereList
;  ls:= form2StringLocal left
;  rs:= form2StringLocal right
;  NE($whereList,whereBefore) and $permitWhere => ls
;  concat(form2StringLocal ls,'": ",rs)

(DEFUN |formDecl2String| (|left| |right|)
  (PROG (|$declVar| |whereBefore| |ls| |rs|)
    (DECLARE (SPECIAL |$declVar| |$permitWhere| |$whereList|))
    (RETURN
      (PROGN
        (SPADLET |$declVar| |left|)
        (SPADLET |whereBefore| |$whereList|)
        (SPADLET |ls| (|form2StringLocal| |left|))
        (SPADLET |rs| (|form2StringLocal| |right|))
        (COND
          ((AND (NE |$whereList| |whereBefore|) |$permitWhere|) |ls|)
          ('T
           (|concat| (|form2StringLocal| |ls|) ": " |rs|)))))))

;formJoin1(op,u) ==
;  if op = 'Join then [:argl,last] := u else (argl := nil; last := [op,:u])
;  last is [id,.,:r] and id in '(mkCategory CATEGORY) =>
;    $permitWhere = true =>
;      opList:= formatJoinKey(r,id)
;      $whereList:= concat($whereList,"%l",$declVar,": ",
;        formJoin2 argl,'%b,'"with",'%d,"%i",opList,"%u")
;      formJoin2 argl
;    opList:= formatJoinKey(r,id)
;    suffix := concat('%b,'"with",'%d,"%i",opList,"%u")
;    concat(formJoin2 argl,suffix)
;  formJoin2 u

(DEFUN |formJoin1| (|op| |u|)
  (PROG (|LETTMP#1| |argl| |last| |id| |ISTMP#1| |r| |opList| |suffix|)
    (DECLARE (SPECIAL |$declVar| |$whereList| |$permitWhere|))
    (RETURN
      (PROGN
        (COND
          ((BOOT-EQUAL |op| '|Join|) (SPADLET |LETTMP#1| (REVERSE |u|))
           (SPADLET |last| (CAR |LETTMP#1|))
           (SPADLET |argl| (NREVERSE (CDR |LETTMP#1|))) |u|)
          ('T (SPADLET |argl| NIL) (SPADLET |last| (CONS |op| |u|))))
        (COND
          ((AND (CONSP |last|)
                (PROGN
                  (SPADLET |id| (QCAR |last|))
                  (SPADLET |ISTMP#1| (QCDR |last|))
                  (AND (CONSP |ISTMP#1|)
                       (PROGN (SPADLET |r| (QCDR |ISTMP#1|)) 'T)))
                (|member| |id| '(|mkCategory| CATEGORY)))
           (COND
             ((BOOT-EQUAL |$permitWhere| 'T)
              (SPADLET |opList| (|formatJoinKey| |r| |id|))
              (SPADLET |$whereList|
                       (|concat| |$whereList| '|%l| |$declVar| '|: |
                           (|formJoin2| |argl|) '|%b|
                           "with" '|%d| '|%i| |opList|
                           '|%u|))
              (|formJoin2| |argl|))
             ('T (SPADLET |opList| (|formatJoinKey| |r| |id|))
              (SPADLET |suffix|
                       (|concat| '|%b| "with" '|%d| '|%i|
                           |opList| '|%u|))
              (|concat| (|formJoin2| |argl|) |suffix|))))
          ('T (|formJoin2| |u|)))))))

;formatJoinKey(r,key) ==
;  key = 'mkCategory =>
;    r is [opPart,catPart,:.] =>
;      opString :=
;        opPart is [='LIST,:u] =>
;          "append"/[concat("%l",formatOpSignature(op,sig),formatIf pred)
;            for [='QUOTE,[[op,sig],pred]] in u]
;        nil
;      catString :=
;        catPart is [='LIST,:u] =>
;          "append"/[concat("%l",'" ",form2StringLocal con,formatIf pred)
;            for [='QUOTE,[con,pred]] in u]
;        nil
;      concat(opString,catString)
;    '"?? unknown mkCategory format ??"
;  -- otherwise we have the CATEGORY form
;  "append"/[fn for x in r] where fn ==
;    x is ['SIGNATURE,op,sig] => concat("%l",formatOpSignature(op,sig))
;    x is ['ATTRIBUTE,a] => concat("%l",formatAttribute a)
;    x

(DEFUN |formatJoinKey| (|r| |key|)
  (PROG (|opPart| |catPart| |opString| |u| |con| |pred| |catString|
            |op| |ISTMP#2| |sig| |ISTMP#1| |a|)
    (RETURN
      (SEQ (COND
             ((BOOT-EQUAL |key| '|mkCategory|)
              (COND
                ((AND (CONSP |r|)
                      (PROGN
                        (SPADLET |opPart| (QCAR |r|))
                        (SPADLET |ISTMP#1| (QCDR |r|))
                        (AND (CONSP |ISTMP#1|)
                             (PROGN
                               (SPADLET |catPart| (QCAR |ISTMP#1|))
                               'T))))
                 (SPADLET |opString|
                          (COND
                            ((AND (CONSP |opPart|)
                                  (EQUAL (QCAR |opPart|) 'LIST)
                                  (PROGN
                                    (SPADLET |u| (QCDR |opPart|))
                                    'T))
                             (PROG (G167117)
                               (SPADLET G167117 NIL)
                               (RETURN
                                 (DO ((G167123 |u| (CDR G167123))
                                      (G167068 NIL))
                                     ((OR (ATOM G167123)
                                       (PROGN
                                         (SETQ G167068
                                          (CAR G167123))
                                         NIL)
                                       (PROGN
                                         (PROGN
                                           (COND
                                             ((EQUAL 'QUOTE
                                               (CAR G167068))
                                              'QUOTE))
                                           (SPADLET |op|
                                            (CAAADR G167068))
                                           (SPADLET |sig|
                                            (CAR (CDAADR G167068)))
                                           (SPADLET |pred|
                                            (CADADR G167068))
                                           G167068)
                                         NIL))
                                      G167117)
                                   (SEQ
                                    (EXIT
                                     (SETQ G167117
                                      (APPEND G167117
                                       (|concat| '|%l|
                                        (|formatOpSignature| |op|
                                         |sig|)
                                        (|formatIf| |pred|))))))))))
                            ('T NIL)))
                 (SPADLET |catString|
                          (COND
                            ((AND (CONSP |catPart|)
                                  (EQUAL (QCAR |catPart|) 'LIST)
                                  (PROGN
                                    (SPADLET |u| (QCDR |catPart|))
                                    'T))
                             (PROG (G167130)
                               (SPADLET G167130 NIL)
                               (RETURN
                                 (DO ((G167136 |u| (CDR G167136))
                                      (G167075 NIL))
                                     ((OR (ATOM G167136)
                                       (PROGN
                                         (SETQ G167075
                                          (CAR G167136))
                                         NIL)
                                       (PROGN
                                         (PROGN
                                           (COND
                                             ((EQUAL 'QUOTE
                                               (CAR G167075))
                                              'QUOTE))
                                           (SPADLET |con|
                                            (CAADR G167075))
                                           (SPADLET |pred|
                                            (CADADR G167075))
                                           G167075)
                                         NIL))
                                      G167130)
                                   (SEQ
                                    (EXIT
                                     (SETQ G167130
                                      (APPEND G167130
                                       (|concat| '|%l| " "
                                        (|form2StringLocal| |con|)
                                        (|formatIf| |pred|))))))))))
                            ('T NIL)))
                 (|concat| |opString| |catString|))
                ('T "?? unknown mkCategory format ??")))
             ('T
              (PROG (G167143)
                (SPADLET G167143 NIL)
                (RETURN
                  (DO ((G167159 |r| (CDR G167159)) (|x| NIL))
                      ((OR (ATOM G167159)
                           (PROGN (SETQ |x| (CAR G167159)) NIL))
                       G167143)
                    (SEQ (EXIT (SETQ G167143
                                     (APPEND G167143
                                      (COND
                                        ((AND (CONSP |x|)
                                          (EQ (QCAR |x|) 'SIGNATURE)
                                          (PROGN
                                            (SPADLET |ISTMP#1|
                                             (QCDR |x|))
                                            (AND (CONSP |ISTMP#1|)
                                             (PROGN
                                               (SPADLET |op|
                                                (QCAR |ISTMP#1|))
                                               (SPADLET |ISTMP#2|
                                                (QCDR |ISTMP#1|))
                                               (AND (CONSP |ISTMP#2|)
                                                (EQ (QCDR |ISTMP#2|)
                                                 NIL)
                                                (PROGN
                                                  (SPADLET |sig|
                                                   (QCAR |ISTMP#2|))
                                                  'T))))))
                                         (|concat| '|%l|
                                          (|formatOpSignature| |op|
                                           |sig|)))
                                        ((AND (CONSP |x|)
                                          (EQ (QCAR |x|) 'ATTRIBUTE)
                                          (PROGN
                                            (SPADLET |ISTMP#1|
                                             (QCDR |x|))
                                            (AND (CONSP |ISTMP#1|)
                                             (EQ (QCDR |ISTMP#1|) NIL)
                                             (PROGN
                                               (SPADLET |a|
                                                (QCAR |ISTMP#1|))
                                               'T))))
                                         (|concat| '|%l|
                                          (|formatAttribute| |a|)))
                                        ('T |x|)))))))))))))))

;formJoin2 argl ==
;-- argl is a list of categories NOT containing a "with"
;  null argl => '""
;  1=#argl => form2StringLocal argl.0
;  application2String('Join,[form2StringLocal x for x in argl], NIL)

(DEFUN |formJoin2| (|argl|)
  (PROG ()
    (RETURN
      (SEQ (COND
             ((NULL |argl|) "")
             ((EQL 1 (|#| |argl|)) (|form2StringLocal| (ELT |argl| 0)))
             ('T
              (|application2String| '|Join|
                  (PROG (G167194)
                    (SPADLET G167194 NIL)
                    (RETURN
                      (DO ((G167199 |argl| (CDR G167199))
                           (|x| NIL))
                          ((OR (ATOM G167199)
                               (PROGN (SETQ |x| (CAR G167199)) NIL))
                           (NREVERSE0 G167194))
                        (SEQ (EXIT (SETQ G167194
                                    (CONS (|form2StringLocal| |x|)
                                     G167194)))))))
                  NIL)))))))

;formJoin2String (u:=[:argl,last]) ==
;  last is ["CATEGORY",.,:atsigList] =>
;    postString:= concat("_(",formTuple2String atsigList,"_)")
;    #argl=1 => concat(first argl,'" with ",postString)
;    concat(application2String('Join,argl, NIL)," with ",postString)
;  application2String('Join,u, NIL)

(DEFUN |formJoin2String| (|u|)
  (PROG (|LETTMP#1| |last| |argl| |ISTMP#1| |atsigList| |postString|)
    (RETURN
      (PROGN
        (SPADLET |LETTMP#1| (REVERSE |u|))
        (SPADLET |last| (CAR |LETTMP#1|))
        (SPADLET |argl| (NREVERSE (CDR |LETTMP#1|)))
        (COND
          ((AND (CONSP |last|) (EQ (QCAR |last|) 'CATEGORY)
                (PROGN
                  (SPADLET |ISTMP#1| (QCDR |last|))
                  (AND (CONSP |ISTMP#1|)
                       (PROGN
                         (SPADLET |atsigList| (QCDR |ISTMP#1|))
                         'T))))
           (SPADLET |postString|
                    (|concat| '|(| (|formTuple2String| |atsigList|)
                        '|)|))
           (COND
             ((EQL (|#| |argl|) 1)
              (|concat| (CAR |argl|) " with "
                  |postString|))
             ('T
              (|concat| (|application2String| '|Join| |argl| NIL)
                  '| with | |postString|))))
          ('T (|application2String| '|Join| |u| NIL)))))))

;formCollect2String [:itl,body] ==
;  ["_(",body,:"append"/[formIterator2String x for x in itl],"_)"]

(DEFUN |formCollect2String| (G167238)
  (PROG (|LETTMP#1| |body| |itl|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |LETTMP#1| (REVERSE G167238))
             (SPADLET |body| (CAR |LETTMP#1|))
             (SPADLET |itl| (NREVERSE (CDR |LETTMP#1|)))
             (CONS '|(|
                   (CONS |body|
                         (APPEND (PROG (G167249)
                                   (SPADLET G167249 NIL)
                                   (RETURN
                                     (DO
                                      ((G167254 |itl|
                                        (CDR G167254))
                                       (|x| NIL))
                                      ((OR (ATOM G167254)
                                        (PROGN
                                          (SETQ |x| (CAR G167254))
                                          NIL))
                                       G167249)
                                       (SEQ
                                        (EXIT
                                         (SETQ G167249
                                          (APPEND G167249
                                           (|formIterator2String| |x|))))))))
                                 (CONS '|)| NIL)))))))))

;formIterator2String x ==
;  x is ["STEP",y,s,.,:l] =>
;    tail:= (l is [f] => form2StringLocal f; nil)
;    concat("for ",y," in ",s,'"..",tail)
;  x is ["tails",y] => concat("tails ",formatIterator y)
;  x is ["reverse",y] => concat("reverse ",formatIterator y)
;  x is ["|",y,p] => concat(formatIterator y," | ",form2StringLocal p)
;  x is ["until",p] => concat("until ",form2StringLocal p)
;  x is ["while",p] => concat("while ",form2StringLocal p)
;  systemErrorHere "formatIterator"

(DEFUN |formIterator2String| (|x|)
  (PROG (|s| |ISTMP#3| |l| |f| |tail| |y| |ISTMP#2| |ISTMP#1| |p|)
    (RETURN
      (COND
        ((AND (CONSP |x|) (EQ (QCAR |x|) 'STEP)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |x|))
                (AND (CONSP |ISTMP#1|)
                     (PROGN
                       (SPADLET |y| (QCAR |ISTMP#1|))
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (CONSP |ISTMP#2|)
                            (PROGN
                              (SPADLET |s| (QCAR |ISTMP#2|))
                              (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                              (AND (CONSP |ISTMP#3|)
                                   (PROGN
                                     (SPADLET |l| (QCDR |ISTMP#3|))
                                     'T))))))))
         (SPADLET |tail|
                  (COND
                    ((AND (CONSP |l|) (EQ (QCDR |l|) NIL)
                          (PROGN (SPADLET |f| (QCAR |l|)) 'T))
                     (|form2StringLocal| |f|))
                    ('T NIL)))
         (|concat| '|for | |y| '| in | |s| ".." |tail|))
        ((AND (CONSP |x|) (EQ (QCAR |x|) '|tails|)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |x|))
                (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                     (PROGN (SPADLET |y| (QCAR |ISTMP#1|)) 'T))))
         (|concat| '|tails | (|formatIterator| |y|)))
        ((AND (CONSP |x|) (EQ (QCAR |x|) '|reverse|)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |x|))
                (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                     (PROGN (SPADLET |y| (QCAR |ISTMP#1|)) 'T))))
         (|concat| '|reverse | (|formatIterator| |y|)))
        ((AND (CONSP |x|) (EQ (QCAR |x|) '|\||)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |x|))
                (AND (CONSP |ISTMP#1|)
                     (PROGN
                       (SPADLET |y| (QCAR |ISTMP#1|))
                       (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (CONSP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)
                            (PROGN (SPADLET |p| (QCAR |ISTMP#2|)) 'T))))))
         (|concat| (|formatIterator| |y|) '| \| |
             (|form2StringLocal| |p|)))
        ((AND (CONSP |x|) (EQ (QCAR |x|) '|until|)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |x|))
                (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                     (PROGN (SPADLET |p| (QCAR |ISTMP#1|)) 'T))))
         (|concat| '|until | (|form2StringLocal| |p|)))
        ((AND (CONSP |x|) (EQ (QCAR |x|) '|while|)
              (PROGN
                (SPADLET |ISTMP#1| (QCDR |x|))
                (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                     (PROGN (SPADLET |p| (QCAR |ISTMP#1|)) 'T))))
         (|concat| '|while | (|form2StringLocal| |p|)))
        ('T (|systemErrorHere| '|formatIterator|))))))

;tuple2String argl ==
;  null argl => nil
;  string := first argl
;  if string in '("failed" "nil" "prime" "sqfr" "irred")
;    then string := STRCONC('"_"",string,'"_"")
;    else string :=
;      ATOM string => object2String string
;      [f x for x in string] where
;        f x ==
;          ATOM x => object2String x
;          -- [f CAR x,:f CDR x]
;          [f y for y in x]
;  for x in rest argl repeat
;    if x in '("failed" "nil" "prime" "sqfr" "irred") then
;      x := STRCONC('"_"",x,'"_"")
;    string:= concat(string,concat(",",f x))
;  string

(DEFUN |tuple2String,f| (|x|)
  (PROG ()
    (RETURN
      (SEQ (IF (ATOM |x|) (EXIT (|object2String| |x|)))
           (EXIT (PROG (G167364)
                   (SPADLET G167364 NIL)
                   (RETURN
                     (DO ((G167369 |x| (CDR G167369)) (|y| NIL))
                         ((OR (ATOM G167369)
                              (PROGN (SETQ |y| (CAR G167369)) NIL))
                          (NREVERSE0 G167364))
                       (SEQ (EXIT (SETQ G167364
                                        (CONS (|tuple2String,f| |y|)
                                         G167364))))))))))))

(DEFUN |tuple2String| (|argl|)
  (PROG (|string|)
    (RETURN
      (SEQ (COND
             ((NULL |argl|) NIL)
             ('T (SPADLET |string| (CAR |argl|))
              (COND
                ((|member| |string|
                     '("failed" "nil" "prime" "sqfr" "irred"))
                 (SPADLET |string| (STRCONC "\"" |string| "\"")))
                ('T
                 (SPADLET |string|
                          (COND
                            ((ATOM |string|)
                             (|object2String| |string|))
                            ('T
                             (PROG (G167387)
                               (SPADLET G167387 NIL)
                               (RETURN
                                 (DO ((G167392 |string|
                                       (CDR G167392))
                                      (|x| NIL))
                                     ((OR (ATOM G167392)
                                       (PROGN
                                         (SETQ |x| (CAR G167392))
                                         NIL))
                                      (NREVERSE0 G167387))
                                   (SEQ
                                    (EXIT
                                     (SETQ G167387
                                      (CONS (|tuple2String,f| |x|)
                                       G167387))))))))))))
              (DO ((G167403 (CDR |argl|) (CDR G167403)) (|x| NIL))
                  ((OR (ATOM G167403)
                       (PROGN (SETQ |x| (CAR G167403)) NIL))
                   NIL)
                (SEQ (EXIT (PROGN
                             (COND
                               ((|member| |x|
                                    '("failed" "nil" "prime" "sqfr"
                                      "irred"))
                                (SPADLET |x|
                                         (STRCONC "\"" |x|
                                          "\""))))
                             (SPADLET |string|
                                      (|concat| |string|
                                       (|concat| '|,|
                                        (|tuple2String,f| |x|))))))))
              |string|))))))

;script2String s ==
;  null s => '""   -- just to be safe
;  if not CONSP s then s := [s]
;  linearFormatForm(CAR s, CDR s)

(DEFUN |script2String| (|s|)
  (COND
    ((NULL |s|) "")
    ('T (COND ((NULL (CONSP |s|)) (SPADLET |s| (CONS |s| NIL))))
     (|linearFormatForm| (CAR |s|) (CDR |s|)))))

;linearFormatName x ==
;  atom x => x
;  linearFormat x

(DEFUN |linearFormatName| (|x|)
  (COND ((ATOM |x|) |x|) ('T (|linearFormat| |x|))))

;linearFormat x ==
;  atom x => x
;  x is [op,:argl] and atom op =>
;    argPart:=
;      argl is [a,:l] => [a,:"append"/[[",",x] for x in l]]
;      nil
;    [op,"(",:argPart,")"]
;  [linearFormat y for y in x]

(DEFUN |linearFormat| (|x|)
  (PROG (|op| |argl| |a| |l| |argPart|)
    (RETURN
      (SEQ (COND
             ((ATOM |x|) |x|)
             ((AND (CONSP |x|)
                   (PROGN
                     (SPADLET |op| (QCAR |x|))
                     (SPADLET |argl| (QCDR |x|))
                     'T)
                   (ATOM |op|))
              (SPADLET |argPart|
                       (COND
                         ((AND (CONSP |argl|)
                               (PROGN
                                 (SPADLET |a| (QCAR |argl|))
                                 (SPADLET |l| (QCDR |argl|))
                                 'T))
                          (CONS |a|
                                (PROG (G167436)
                                  (SPADLET G167436 NIL)
                                  (RETURN
                                    (DO
                                     ((G167441 |l| (CDR G167441))
                                      (|x| NIL))
                                     ((OR (ATOM G167441)
                                       (PROGN
                                         (SETQ |x| (CAR G167441))
                                         NIL))
                                      G167436)
                                      (SEQ
                                       (EXIT
                                        (SETQ G167436
                                         (APPEND G167436
                                          (CONS '|,| (CONS |x| NIL)))))))))))
                         ('T NIL)))
              (CONS |op|
                    (CONS '|(| (APPEND |argPart| (CONS '|)| NIL)))))
             ('T
              (PROG (G167451)
                (SPADLET G167451 NIL)
                (RETURN
                  (DO ((G167456 |x| (CDR G167456)) (|y| NIL))
                      ((OR (ATOM G167456)
                           (PROGN (SETQ |y| (CAR G167456)) NIL))
                       (NREVERSE0 G167451))
                    (SEQ (EXIT (SETQ G167451
                                     (CONS (|linearFormat| |y|)
                                      G167451)))))))))))))

;numOfSpadArguments id ==
;  char("*") = (s:= PNAME id).0 =>
;      +/[n for i in 1.. while INTEGERP (n:=PARSE_-INTEGER PNAME s.i)]
;  keyedSystemError("S2IF0012",[id])

(DEFUN |numOfSpadArguments| (|id|)
  (PROG (|s| |n|)
    (RETURN
      (SEQ (COND
             ((BOOT-EQUAL (|char| '*)
                  (ELT (SPADLET |s| (PNAME |id|)) 0))
              (PROG (G167473)
                (SPADLET G167473 0)
                (RETURN
                  (DO ((|i| 1 (QSADD1 |i|)))
                      ((NULL (INTEGERP
                                 (SPADLET |n|
                                          (PARSE-INTEGER
                                           (PNAME (ELT |s| |i|))))))
                       G167473)
                    (SEQ (EXIT (SETQ G167473 (PLUS G167473 |n|))))))))
             ('T (|keyedSystemError| 'S2IF0012 (CONS |id| NIL))))))))

;linearFormatForm(op,argl) ==
;  s:= PNAME op
;  indexList:= [PARSE_-INTEGER PNAME d for i in 1.. while
;    (DIGITP (d:= s.(maxIndex:= i)))]
;  cleanOp:= INTERN ("STRCONC"/[PNAME s.i for i in maxIndex..MAXINDEX s])
;  fnArgs:=
;    indexList.0 > 0 =>
;      concat('"(",formatArgList take(-indexList.0,argl),'")")
;    nil
;  if #indexList > 1 then
;    scriptArgs:= formatArgList take(indexList.1,argl)
;    argl := drop(indexList.1,argl)
;    for i in rest rest indexList repeat
;      subArglist:= take(i,argl)
;      argl:= drop(i,argl)
;      scriptArgs:= concat(scriptArgs,";",formatArgList subArglist)
;  scriptArgs:=
;    scriptArgs => concat(specialChar 'lbrk,scriptArgs, specialChar 'rbrk)
;    nil
;  l := [(STRINGP f => f; STRINGIMAGE f) for f in
;       concat(cleanOp,scriptArgs,fnArgs)]
;  "STRCONC"/l

(DEFUN |linearFormatForm| (|op| |argl|)
  (PROG (|s| |maxIndex| |d| |indexList| |cleanOp| |fnArgs| |subArglist|
             |scriptArgs| |l|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |s| (PNAME |op|))
             (SPADLET |indexList|
                      (PROG (G167500)
                        (SPADLET G167500 NIL)
                        (RETURN
                          (DO ((|i| 1 (QSADD1 |i|)))
                              ((NULL (DIGITP
                                      (SPADLET |d|
                                       (ELT |s|
                                        (SPADLET |maxIndex| |i|)))))
                               (NREVERSE0 G167500))
                            (SEQ (EXIT (SETQ G167500
                                        (CONS
                                         (PARSE-INTEGER (PNAME |d|))
                                         G167500))))))))
             (SPADLET |cleanOp|
                      (INTERN (PROG (G167509)
                                (SPADLET G167509 "")
                                (RETURN
                                  (DO ((G167514 (MAXINDEX |s|))
                                       (|i| |maxIndex| (+ |i| 1)))
                                      ((> |i| G167514) G167509)
                                    (SEQ
                                     (EXIT
                                      (SETQ G167509
                                       (STRCONC G167509
                                        (PNAME (ELT |s| |i|)))))))))))
             (SPADLET |fnArgs|
                      (COND
                        ((> (ELT |indexList| 0) 0)
                         (|concat| "("
                             (|formatArgList|
                                 (TAKE (SPADDIFFERENCE
                                        (ELT |indexList| 0))
                                       |argl|))
                             ")"))
                        ('T NIL)))
             (COND
               ((> (|#| |indexList|) 1)
                (SPADLET |scriptArgs|
                         (|formatArgList|
                             (TAKE (ELT |indexList| 1) |argl|)))
                (SPADLET |argl| (DROP (ELT |indexList| 1) |argl|))
                (DO ((G167524 (CDR (CDR |indexList|))
                         (CDR G167524))
                     (|i| NIL))
                    ((OR (ATOM G167524)
                         (PROGN (SETQ |i| (CAR G167524)) NIL))
                     NIL)
                  (SEQ (EXIT (PROGN
                               (SPADLET |subArglist| (TAKE |i| |argl|))
                               (SPADLET |argl| (DROP |i| |argl|))
                               (SPADLET |scriptArgs|
                                        (|concat| |scriptArgs| '|;|
                                         (|formatArgList| |subArglist|)))))))))
             (SPADLET |scriptArgs|
                      (COND
                        (|scriptArgs|
                            (|concat| (|specialChar| '|lbrk|)
                                |scriptArgs| (|specialChar| '|rbrk|)))
                        ('T NIL)))
             (SPADLET |l|
                      (PROG (G167534)
                        (SPADLET G167534 NIL)
                        (RETURN
                          (DO ((G167539
                                   (|concat| |cleanOp| |scriptArgs|
                                    |fnArgs|)
                                   (CDR G167539))
                               (|f| NIL))
                              ((OR (ATOM G167539)
                                   (PROGN
                                     (SETQ |f| (CAR G167539))
                                     NIL))
                               (NREVERSE0 G167534))
                            (SEQ (EXIT (SETQ G167534
                                        (CONS
                                         (COND
                                           ((STRINGP |f|) |f|)
                                           ('T (STRINGIMAGE |f|)))
                                         G167534))))))))
             (PROG (G167545)
               (SPADLET G167545 "")
               (RETURN
                 (DO ((G167550 |l| (CDR G167550)) (G167488 NIL))
                     ((OR (ATOM G167550)
                          (PROGN (SETQ G167488 (CAR G167550)) NIL))
                      G167545)
                   (SEQ (EXIT (SETQ G167545
                                    (STRCONC G167545 G167488))))))))))))

;formatArgList l ==
;  null l => nil
;  acc:= linearFormat first l
;  for x in rest l repeat
;    acc:= concat(acc,",",linearFormat x)
;  acc

(DEFUN |formatArgList| (|l|)
  (PROG (|acc|)
    (RETURN
      (SEQ (COND
             ((NULL |l|) NIL)
             ('T (SPADLET |acc| (|linearFormat| (CAR |l|)))
              (DO ((G167580 (CDR |l|) (CDR G167580)) (|x| NIL))
                  ((OR (ATOM G167580)
                       (PROGN (SETQ |x| (CAR G167580)) NIL))
                   NIL)
                (SEQ (EXIT (SPADLET |acc|
                                    (|concat| |acc| '|,|
                                     (|linearFormat| |x|))))))
              |acc|))))))

;formTuple2String argl ==
;  null argl => nil
;  string:= form2StringLocal first argl
;  for x in rest argl repeat
;    string:= concat(string,concat(",",form2StringLocal x))
;  string

(DEFUN |formTuple2String| (|argl|)
  (PROG (|string|)
    (RETURN
      (SEQ (COND
             ((NULL |argl|) NIL)
             ('T (SPADLET |string| (|form2StringLocal| (CAR |argl|)))
              (DO ((G167595 (CDR |argl|) (CDR G167595)) (|x| NIL))
                  ((OR (ATOM G167595)
                       (PROGN (SETQ |x| (CAR G167595)) NIL))
                   NIL)
                (SEQ (EXIT (SPADLET |string|
                                    (|concat| |string|
                                     (|concat| '|,|
                                      (|form2StringLocal| |x|)))))))
              |string|))))))

;isInternalFunctionName(op) ==
;  (not IDENTP(op)) or (op = "*") or (op = "**") => NIL
;  (1 = SIZE(op':= PNAME op)) or (char("*") ^= op'.0) => NIL
;  -- if there is a semicolon in the name then it is the name of
;  -- a compiled spad function
;  null (e := STRPOS('"_;",op',1,NIL)) => NIL
;  (char(" ") = (y := op'.1)) or (char("*") = y) => NIL
;  table := MAKETRTTABLE('"0123456789",NIL)
;  s := STRPOSL(table,op',1,true)
;  null(s) or s > e => NIL
;  SUBSTRING(op',s,e-s)

(DEFUN |isInternalFunctionName| (|op|)
  (PROG (|op'| |e| |y| |table| |s|)
    (RETURN
      (COND
        ((OR (NULL (IDENTP |op|)) (BOOT-EQUAL |op| '*)
             (BOOT-EQUAL |op| '**))
         NIL)
        ((OR (EQL 1 (SIZE (SPADLET |op'| (PNAME |op|))))
             (NEQUAL (|char| '*) (ELT |op'| 0)))
         NIL)
        ((NULL (SPADLET |e| (STRPOS ";" |op'| 1 NIL)))
         NIL)
        ((OR (BOOT-EQUAL (|char| '| |) (SPADLET |y| (ELT |op'| 1)))
             (BOOT-EQUAL (|char| '*) |y|))
         NIL)
        ('T
         (SPADLET |table| (MAKETRTTABLE "0123456789" NIL))
         (SPADLET |s| (STRPOSL |table| |op'| 1 'T))
         (COND
           ((OR (NULL |s|) (> |s| |e|)) NIL)
           ('T (SUBSTRING |op'| |s| (SPADDIFFERENCE |e| |s|)))))))))

;application2String(op,argl, linkInfo) ==
;  null argl =>
;    (op' := isInternalFunctionName(op)) => op'
;    app2StringWrap(formWrapId op, linkInfo)
;  1=#argl =>
;    first argl is ["<",:.] => concat(op,first argl)
;    concat(app2StringWrap(formWrapId op, linkInfo)," ",first argl)
;--op in '(UP SM) =>
;--  newop:= (op = "UP" => "P";"M")
;--  concat(newop,concat(lbrkSch(),argl.0,rbrkSch(),argl.1))
;--op='RM  =>concat("M",concat(lbrkSch(),
;--                     argl.0,",",argl.1,rbrkSch(),argl.2))
;--op='MP =>concat("P",concat(argl.0,argl.1))
;  op='SEGMENT =>
;    null argl => '".."
;    (null rest argl) or (null first rest argl) =>
;      concat(first argl, '"..")
;    concat(first argl, concat('"..", first rest argl))
;  concat(app2StringWrap(formWrapId op, linkInfo) ,
;                        concat("_(",concat(tuple2String argl,"_)")))

(DEFUN |application2String| (|op| |argl| |linkInfo|)
  (PROG (|op'| |ISTMP#1|)
    (RETURN
      (COND
        ((NULL |argl|)
         (COND
           ((SPADLET |op'| (|isInternalFunctionName| |op|)) |op'|)
           ('T (|app2StringWrap| (|formWrapId| |op|) |linkInfo|))))
        ((EQL 1 (|#| |argl|))
         (COND
           ((PROGN
              (SPADLET |ISTMP#1| (CAR |argl|))
              (AND (CONSP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) '<)))
            (|concat| |op| (CAR |argl|)))
           ('T
            (|concat| (|app2StringWrap| (|formWrapId| |op|) |linkInfo|)
                '| | (CAR |argl|)))))
        ((BOOT-EQUAL |op| 'SEGMENT)
         (COND
           ((NULL |argl|) "..")
           ((OR (NULL (CDR |argl|)) (NULL (CAR (CDR |argl|))))
            (|concat| (CAR |argl|) ".."))
           ('T
            (|concat| (CAR |argl|)
                (|concat| ".." (CAR (CDR |argl|)))))))
        ('T
         (|concat| (|app2StringWrap| (|formWrapId| |op|) |linkInfo|)
             (|concat| '|(| (|concat| (|tuple2String| |argl|) '|)|))))))))

;app2StringConcat0(x,y) ==
;  FORMAT(NIL, '"~a ~a", x, y)

(DEFUN |app2StringConcat0| (|x| |y|) (FORMAT NIL "~a ~a" |x| |y|)) 

;app2StringWrap(string, linkInfo) ==
;  not linkInfo => string
;  $formatSigAsTeX = 1 => string
;  $formatSigAsTeX = 2 =>
;    str2 :=  "app2StringConcat0"/form2Fence linkInfo
;    sep := '"`"
;    FORMAT(NIL, '"\lispLink{\verb!(|conPage| '~a)!}{~a}",
;          str2, string)
;  error "Bad value for $formatSigAsTeX"

(DEFUN |app2StringWrap| (|string| |linkInfo|)
  (PROG (|str2| |sep|)
    (DECLARE (SPECIAL |$formatSigAsTeX|))
    (RETURN
      (SEQ (COND
             ((NULL |linkInfo|) |string|)
             ((EQL |$formatSigAsTeX| 1) |string|)
             ((EQL |$formatSigAsTeX| 2)
              (SPADLET |str2|
                       (PROG (G167632 G167633)
                         (SPADLET G167632 'G167632)
                         (RETURN
                           (DO ((G167640 (|form2Fence| |linkInfo|)
                                    (CDR G167640))
                                (G167629 NIL))
                               ((OR (ATOM G167640)
                                    (PROGN
                                      (SETQ G167629 (CAR G167640))
                                      NIL))
                                (THETACHECK G167632 'G167632
                                    '|app2StringConcat0|))
                             (SEQ (EXIT (PROGN
                                          (SPADLET G167633 G167629)
                                          (SETQ G167632
                                           (COND
                                             ((EQ G167632 'G167632)
                                              G167633)
                                             ('T
                                              (|app2StringConcat0|
                                               G167632 G167633)))))))))))
              (SPADLET |sep| "`")
              (FORMAT NIL "\\lispLink{\\verb!(|conPage| '~a)!}{~a}"
                      |str2| |string|))
             ('T (|error| '|Bad value for $formatSigAsTeX|)))))))

;record2String x ==
;  argPart := NIL
;  for [":",a,b] in x repeat argPart:=
;    concat(argPart,",",a,": ",form2StringLocal b)
;  null argPart => '"Record()"
;  concat("Record_(",rest argPart,"_)")

(DEFUN |record2String| (|x|)
  (PROG (|a| |b| |argPart|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |argPart| NIL)
             (DO ((G167662 |x| (CDR G167662)) (G167653 NIL))
                 ((OR (ATOM G167662)
                      (PROGN (SETQ G167653 (CAR G167662)) NIL)
                      (PROGN
                        (PROGN
                          (SPADLET |a| (CADR G167653))
                          (SPADLET |b| (CADDR G167653))
                          G167653)
                        NIL))
                  NIL)
               (SEQ (EXIT (SPADLET |argPart|
                                   (|concat| |argPart| '|,| |a| '|: |
                                    (|form2StringLocal| |b|))))))
             (COND
               ((NULL |argPart|) "Record()")
               ('T (|concat| '|Record(| (CDR |argPart|) '|)|))))))))

;plural(n,string) ==
;  suffix:=
;    n = 1 => '""
;    '"s"
;  [:bright n,string,suffix]

(DEFUN |plural| (|n| |string|)
  (PROG (|suffix|)
    (RETURN
      (PROGN
        (SPADLET |suffix| (COND ((EQL |n| 1) "") ('T "s")))
        (APPEND (|bright| |n|) (CONS |string| (CONS |suffix| NIL)))))))

;formatIf pred ==
;  not pred => nil
;  pred in '(T (QUOTE T)) => nil
;  concat('%b,'"if",'%d,pred2English pred)

(DEFUN |formatIf| (|pred|)
  (COND
    ((NULL |pred|) NIL)
    ((|member| |pred| '(T 'T)) NIL)
    ('T (|concat| '|%b| "if" '|%d| (|pred2English| |pred|)))))

;formatPredParts s ==
;  s is ['QUOTE,s1] => formatPredParts s1
;  s is ['LIST,:s1] => [formatPredParts s2 for s2 in s1]
;  s is ['devaluate,s1] => formatPredParts s1
;  s is ['getDomainView,s1,.] => formatPredParts s1
;  s is ['SUBST,a,b,c] =>    -- this is a signature
;    s1 := formatPredParts SUBST(formatPredParts a,b,c)
;    s1 isnt [fun,sig] => s1
;    ['SIGNATURE,fun,[formatPredParts(r) for r in sig]]
;  s

(DEFUN |formatPredParts| (|s|)
  (PROG (|a| |ISTMP#2| |b| |ISTMP#3| |c| |s1| |fun| |ISTMP#1| |sig|)
    (RETURN
      (SEQ (COND
             ((AND (CONSP |s|) (EQ (QCAR |s|) 'QUOTE)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |s|))
                     (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (SPADLET |s1| (QCAR |ISTMP#1|)) 'T))))
              (|formatPredParts| |s1|))
             ((AND (CONSP |s|) (EQ (QCAR |s|) 'LIST)
                   (PROGN (SPADLET |s1| (QCDR |s|)) 'T))
              (PROG (G167753)
                (SPADLET G167753 NIL)
                (RETURN
                  (DO ((G167758 |s1| (CDR G167758)) (|s2| NIL))
                      ((OR (ATOM G167758)
                           (PROGN (SETQ |s2| (CAR G167758)) NIL))
                       (NREVERSE0 G167753))
                    (SEQ (EXIT (SETQ G167753
                                     (CONS (|formatPredParts| |s2|)
                                      G167753))))))))
             ((AND (CONSP |s|) (EQ (QCAR |s|) '|devaluate|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |s|))
                     (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (SPADLET |s1| (QCAR |ISTMP#1|)) 'T))))
              (|formatPredParts| |s1|))
             ((AND (CONSP |s|) (EQ (QCAR |s|) '|getDomainView|)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |s|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (SPADLET |s1| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL))))))
              (|formatPredParts| |s1|))
             ((AND (CONSP |s|) (EQ (QCAR |s|) 'SUBST)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |s|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (SPADLET |a| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (PROGN
                                   (SPADLET |b| (QCAR |ISTMP#2|))
                                   (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                                   (AND (CONSP |ISTMP#3|)
                                    (EQ (QCDR |ISTMP#3|) NIL)
                                    (PROGN
                                      (SPADLET |c| (QCAR |ISTMP#3|))
                                      'T))))))))
              (SPADLET |s1|
                       (|formatPredParts|
                           (MSUBST (|formatPredParts| |a|) |b| |c|)))
              (COND
                ((NULL (AND (CONSP |s1|)
                            (PROGN
                              (SPADLET |fun| (QCAR |s1|))
                              (SPADLET |ISTMP#1| (QCDR |s1|))
                              (AND (CONSP |ISTMP#1|)
                                   (EQ (QCDR |ISTMP#1|) NIL)
                                   (PROGN
                                     (SPADLET |sig| (QCAR |ISTMP#1|))
                                     'T)))))
                 |s1|)
                ('T
                 (CONS 'SIGNATURE
                       (CONS |fun|
                             (CONS (PROG (G167768)
                                     (SPADLET G167768 NIL)
                                     (RETURN
                                       (DO
                                        ((G167773 |sig|
                                          (CDR G167773))
                                         (|r| NIL))
                                        ((OR (ATOM G167773)
                                          (PROGN
                                            (SETQ |r| (CAR G167773))
                                            NIL))
                                         (NREVERSE0 G167768))
                                         (SEQ
                                          (EXIT
                                           (SETQ G167768
                                            (CONS
                                             (|formatPredParts| |r|)
                                             G167768)))))))
                                   NIL))))))
             ('T |s|))))))

;pred2English x ==
;  x is ['IF,cond,thenClause,elseClause] =>
;    c := concat('"if ",pred2English cond)
;    t := concat('" then ",pred2English thenClause)
;    e := concat('" else ",pred2English elseClause)
;    concat(c,t,e)
;  x is ['AND,:l] =>
;    tail:="append"/[concat(bright '"and",pred2English x) for x in rest l]
;    concat(pred2English first l,tail)
;  x is ['OR,:l] =>
;    tail:= "append"/[concat(bright '"or",pred2English x) for x in rest l]
;    concat(pred2English first l,tail)
;  x is ['NOT,l] =>
;    concat('"not ",pred2English l)
;  x is [op,a,b] and op in '(has ofCategory) =>
;    concat(pred2English a,'%b,'"has",'%d,form2String abbreviate b)
;  x is [op,a,b] and op in '(HasSignature HasAttribute HasCategory) =>
;    concat(prefix2String0 formatPredParts a,'%b,'"has",'%d,
;      prefix2String0 formatPredParts b)
;  x is [op,a,b] and op in '(ofType getDomainView) =>
;    if b is ['QUOTE,b'] then b := b'
;    concat(pred2English a,'": ",form2String abbreviate b)
;  x is [op,a,b] and op in '(isDomain domainEqual) =>
;    concat(pred2English a,'" = ",form2String abbreviate b)
;  x is [op,:.] and (translation := LASSOC(op,'(
;    (_< . " < ") (_<_= . " <= ")
;      (_> . " > ") (_>_= . " >= ") (_=  . " = ") (_^_= . " _^_= ")))) =>
;        concat(pred2English a,translation,pred2English b)
;  x is ['ATTRIBUTE,form] =>
;    concat("attribute: ",form2String form)
;  form2String x

(DEFUN |pred2English| (|x|)
  (PROG (|cond| |thenClause| |ISTMP#3| |elseClause| |c| |t| |e| |tail|
                |l| |b'| |a| |ISTMP#2| |b| |op| |translation| |ISTMP#1|
                |form|)
    (RETURN
      (SEQ (COND
             ((AND (CONSP |x|) (EQ (QCAR |x|) 'IF)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |x|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (SPADLET |cond| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (PROGN
                                   (SPADLET |thenClause|
                                    (QCAR |ISTMP#2|))
                                   (SPADLET |ISTMP#3| (QCDR |ISTMP#2|))
                                   (AND (CONSP |ISTMP#3|)
                                    (EQ (QCDR |ISTMP#3|) NIL)
                                    (PROGN
                                      (SPADLET |elseClause|
                                       (QCAR |ISTMP#3|))
                                      'T))))))))
              (SPADLET |c| (|concat| "if " (|pred2English| |cond|)))
              (SPADLET |t|
                       (|concat| " then "
                           (|pred2English| |thenClause|)))
              (SPADLET |e|
                       (|concat| " else "
                           (|pred2English| |elseClause|)))
              (|concat| |c| |t| |e|))
             ((AND (CONSP |x|) (EQ (QCAR |x|) 'AND)
                   (PROGN (SPADLET |l| (QCDR |x|)) 'T))
              (SPADLET |tail|
                       (PROG (G167949)
                         (SPADLET G167949 NIL)
                         (RETURN
                           (DO ((G167954 (CDR |l|) (CDR G167954))
                                (|x| NIL))
                               ((OR (ATOM G167954)
                                    (PROGN
                                      (SETQ |x| (CAR G167954))
                                      NIL))
                                G167949)
                             (SEQ (EXIT (SETQ G167949
                                         (APPEND G167949
                                          (|concat| (|bright| "and")
                                           (|pred2English| |x|))))))))))
              (|concat| (|pred2English| (CAR |l|)) |tail|))
             ((AND (CONSP |x|) (EQ (QCAR |x|) 'OR)
                   (PROGN (SPADLET |l| (QCDR |x|)) 'T))
              (SPADLET |tail|
                       (PROG (G167960)
                         (SPADLET G167960 NIL)
                         (RETURN
                           (DO ((G167965 (CDR |l|) (CDR G167965))
                                (|x| NIL))
                               ((OR (ATOM G167965)
                                    (PROGN
                                      (SETQ |x| (CAR G167965))
                                      NIL))
                                G167960)
                             (SEQ (EXIT (SETQ G167960
                                         (APPEND G167960
                                          (|concat| (|bright| "or")
                                           (|pred2English| |x|))))))))))
              (|concat| (|pred2English| (CAR |l|)) |tail|))
             ((AND (CONSP |x|) (EQ (QCAR |x|) 'NOT)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |x|))
                     (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (SPADLET |l| (QCAR |ISTMP#1|)) 'T))))
              (|concat| "not " (|pred2English| |l|)))
             ((AND (CONSP |x|)
                   (PROGN
                     (SPADLET |op| (QCAR |x|))
                     (SPADLET |ISTMP#1| (QCDR |x|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (SPADLET |a| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |b| (QCAR |ISTMP#2|))
                                   'T)))))
                   (|member| |op| '(|has| |ofCategory|)))
              (|concat| (|pred2English| |a|) '|%b| "has"
                  '|%d| (|form2String| (|abbreviate| |b|))))
             ((AND (CONSP |x|)
                   (PROGN
                     (SPADLET |op| (QCAR |x|))
                     (SPADLET |ISTMP#1| (QCDR |x|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (SPADLET |a| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |b| (QCAR |ISTMP#2|))
                                   'T)))))
                   (|member| |op|
                       '(|HasSignature| |HasAttribute| |HasCategory|)))
              (|concat| (|prefix2String0| (|formatPredParts| |a|))
                  '|%b| "has" '|%d|
                  (|prefix2String0| (|formatPredParts| |b|))))
             ((AND (CONSP |x|)
                   (PROGN
                     (SPADLET |op| (QCAR |x|))
                     (SPADLET |ISTMP#1| (QCDR |x|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (SPADLET |a| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |b| (QCAR |ISTMP#2|))
                                   'T)))))
                   (|member| |op| '(|ofType| |getDomainView|)))
              (COND
                ((AND (CONSP |b|) (EQ (QCAR |b|) 'QUOTE)
                      (PROGN
                        (SPADLET |ISTMP#1| (QCDR |b|))
                        (AND (CONSP |ISTMP#1|)
                             (EQ (QCDR |ISTMP#1|) NIL)
                             (PROGN
                               (SPADLET |b'| (QCAR |ISTMP#1|))
                               'T))))
                 (SPADLET |b| |b'|)))
              (|concat| (|pred2English| |a|) ": "
                  (|form2String| (|abbreviate| |b|))))
             ((AND (CONSP |x|)
                   (PROGN
                     (SPADLET |op| (QCAR |x|))
                     (SPADLET |ISTMP#1| (QCDR |x|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (SPADLET |a| (QCAR |ISTMP#1|))
                            (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (SPADLET |b| (QCAR |ISTMP#2|))
                                   'T)))))
                   (|member| |op| '(|isDomain| |domainEqual|)))
              (|concat| (|pred2English| |a|) " = "
                  (|form2String| (|abbreviate| |b|))))
             ((AND (CONSP |x|) (PROGN (SPADLET |op| (QCAR |x|)) 'T)
                   (SPADLET |translation|
                            (LASSOC |op|
                                    '((< . " < ") (<= . " <= ")
                                      (> . " > ") (>= . " >= ")
                                      (= . " = ") (^= . " ^= ")))))
              (|concat| (|pred2English| |a|) |translation|
                  (|pred2English| |b|)))
             ((AND (CONSP |x|) (EQ (QCAR |x|) 'ATTRIBUTE)
                   (PROGN
                     (SPADLET |ISTMP#1| (QCDR |x|))
                     (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (SPADLET |form| (QCAR |ISTMP#1|)) 'T))))
              (|concat| '|attribute: | (|form2String| |form|)))
             ('T (|form2String| |x|)))))))

;object2String x ==
;  STRINGP x => x
;  IDENTP x  => PNAME x
;  NULL x    => '""
;  CONSP  x  => STRCONC(object2String first x, object2String rest x)
;  WRITE_-TO_-STRING x

(DEFUN |object2String| (|x|)
  (COND
    ((STRINGP |x|) |x|)
    ((IDENTP |x|) (PNAME |x|))
    ((NULL |x|) "")
    ((CONSP |x|)
     (STRCONC (|object2String| (CAR |x|)) (|object2String| (CDR |x|))))
    ('T (WRITE-TO-STRING |x|))))

;object2Identifier x ==
;  IDENTP x  => x
;  STRINGP x => INTERN x
;  INTERN WRITE_-TO_-STRING x

(DEFUN |object2Identifier| (|x|)
  (COND
    ((IDENTP |x|) |x|)
    ((STRINGP |x|) (INTERN |x|))
    ('T (INTERN (WRITE-TO-STRING |x|)))))

;blankList x == "append"/[[BLANK,y] for y in x]

(DEFUN |blankList| (|x|)
  (PROG ()
    (RETURN
      (SEQ (PROG (G168026)
             (SPADLET G168026 NIL)
             (RETURN
               (DO ((G168031 |x| (CDR G168031)) (|y| NIL))
                   ((OR (ATOM G168031)
                        (PROGN (SETQ |y| (CAR G168031)) NIL))
                    G168026)
                 (SEQ (EXIT (SETQ G168026
                                  (APPEND G168026
                                          (CONS BLANK (CONS |y| NIL)))))))))))))

;--keyStuff ::= keynumber | [ one or more keySeqs ]
;--keySeq   ::= keynumber optargList optdbn
;--optARgL  ::= [ 0 or more arguments ] | nothing at all
;--optDbn   ::= ['dbN , databaseName ] | nothing at all
;pkey keyStuff ==
;    if not CONSP keyStuff then keyStuff := [keyStuff]
;    allMsgs := ['" "]
;    while not null keyStuff repeat
;        dbN := NIL
;        argL := NIL
;        key := first keyStuff
;        keyStuff := IFCDR keyStuff
;        next := IFCAR keyStuff
;        while CONSP next repeat
;            if CAR next = 'dbN then dbN := CADR next
;            else argL := next
;            keyStuff  := IFCDR keyStuff
;            next      := IFCAR keyStuff
;        oneMsg  := returnStLFromKey(key,argL,dbN)
;        allMsgs := ['" ", :NCONC (oneMsg,allMsgs)]
;    allMsgs

(DEFUN |pkey| (|keyStuff|)
  (PROG (|key| |dbN| |argL| |next| |oneMsg| |allMsgs|)
    (RETURN
      (SEQ (PROGN
             (COND
               ((NULL (CONSP |keyStuff|))
                (SPADLET |keyStuff| (CONS |keyStuff| NIL))))
             (SPADLET |allMsgs| (CONS " " NIL))
             (DO () ((NULL (NULL (NULL |keyStuff|))) NIL)
               (SEQ (EXIT (PROGN
                            (SPADLET |dbN| NIL)
                            (SPADLET |argL| NIL)
                            (SPADLET |key| (CAR |keyStuff|))
                            (SPADLET |keyStuff| (IFCDR |keyStuff|))
                            (SPADLET |next| (IFCAR |keyStuff|))
                            (DO () ((NULL (CONSP |next|)) NIL)
                              (SEQ (EXIT
                                    (PROGN
                                      (COND
                                        ((BOOT-EQUAL (CAR |next|)
                                          '|dbN|)
                                         (SPADLET |dbN| (CADR |next|)))
                                        ('T (SPADLET |argL| |next|)))
                                      (SPADLET |keyStuff|
                                       (IFCDR |keyStuff|))
                                      (SPADLET |next|
                                       (IFCAR |keyStuff|))))))
                            (SPADLET |oneMsg|
                                     (|returnStLFromKey| |key| |argL|
                                      |dbN|))
                            (SPADLET |allMsgs|
                                     (CONS " "
                                      (NCONC |oneMsg| |allMsgs|)))))))
             |allMsgs|)))))

;string2Float s ==
;  -- takes a string, calls the parser on it and returns a float object
;  p := ncParseFromString s
;  p isnt [["$elt", FloatDomain, "float"], x, y, z] =>
;    systemError '"string2Float: did not get a float expression"
;  flt := getFunctionFromDomain("float", FloatDomain,
;    [$Integer, $Integer, $PositiveInteger])
;  SPADCALL(x, y, z, flt)

(DEFUN |string2Float| (|s|)
  (PROG (|p| |ISTMP#1| |ISTMP#2| |FloatDomain| |ISTMP#3| |ISTMP#4| |x|
             |ISTMP#5| |y| |ISTMP#6| |z| |flt|)
    (DECLARE (SPECIAL |$PositiveInteger| |$Integer| |$elt|))
    (RETURN
      (PROGN
        (SPADLET |p| (|ncParseFromString| |s|))
        (COND
          ((NULL (AND (CONSP |p|)
                      (PROGN
                        (SPADLET |ISTMP#1| (QCAR |p|))
                        (AND (CONSP |ISTMP#1|)
                             (EQ (QCAR |ISTMP#1|) '|$elt|)
                             (PROGN
                               (SPADLET |ISTMP#2| (QCDR |ISTMP#1|))
                               (AND (CONSP |ISTMP#2|)
                                    (PROGN
                                      (SPADLET |FloatDomain|
                                       (QCAR |ISTMP#2|))
                                      (SPADLET |ISTMP#3|
                                       (QCDR |ISTMP#2|))
                                      (AND (CONSP |ISTMP#3|)
                                       (EQ (QCDR |ISTMP#3|) NIL)
                                       (EQ (QCAR |ISTMP#3|) '|float|)))))))
                      (PROGN
                        (SPADLET |ISTMP#4| (QCDR |p|))
                        (AND (CONSP |ISTMP#4|)
                             (PROGN
                               (SPADLET |x| (QCAR |ISTMP#4|))
                               (SPADLET |ISTMP#5| (QCDR |ISTMP#4|))
                               (AND (CONSP |ISTMP#5|)
                                    (PROGN
                                      (SPADLET |y| (QCAR |ISTMP#5|))
                                      (SPADLET |ISTMP#6|
                                       (QCDR |ISTMP#5|))
                                      (AND (CONSP |ISTMP#6|)
                                       (EQ (QCDR |ISTMP#6|) NIL)
                                       (PROGN
                                         (SPADLET |z| (QCAR |ISTMP#6|))
                                         'T)))))))))
           (|systemError|
               "string2Float: did not get a float expression"))
          ('T
           (SPADLET |flt|
                    (|getFunctionFromDomain| '|float| |FloatDomain|
                        (CONS |$Integer|
                              (CONS |$Integer|
                                    (CONS |$PositiveInteger| NIL)))))
           (SPADCALL |x| |y| |z| |flt|)))))))

;form2Fence form ==
;  -- body of dbMkEvalable
;  [op, :.] := form
;  kind := GETDATABASE(op,'CONSTRUCTORKIND)
;  kind = 'category => form2Fence1 form
;  form2Fence1 mkEvalable form

(DEFUN |form2Fence| (|form|)
  (PROG (|op| |kind|)
    (RETURN
      (PROGN
        (SPADLET |op| (CAR |form|))
        (SPADLET |kind| (GETDATABASE |op| 'CONSTRUCTORKIND))
        (COND
          ((BOOT-EQUAL |kind| '|category|) (|form2Fence1| |form|))
          ('T (|form2Fence1| (|mkEvalable| |form|))))))))

;form2Fence1 x ==
;  x is [op,:argl] =>
;    op = 'QUOTE => ['"(QUOTE ",:form2FenceQuote first argl,'")"]
;    ['"(", FORMAT(NIL, '"|~a|", op),:"append"/[form2Fence1 y for y in argl],'")"]
;  IDENTP x => FORMAT(NIL, '"|~a|", x)
;--  [x]
;  ['"  ", x]

(DEFUN |form2Fence1| (|x|)
  (PROG (|op| |argl|)
    (RETURN
      (SEQ (COND
             ((AND (CONSP |x|)
                   (PROGN
                     (SPADLET |op| (QCAR |x|))
                     (SPADLET |argl| (QCDR |x|))
                     'T))
              (COND
                ((BOOT-EQUAL |op| 'QUOTE)
                 (CONS "(QUOTE "
                       (APPEND (|form2FenceQuote| (CAR |argl|))
                               (CONS ")" NIL))))
                ('T
                 (CONS "("
                       (CONS (FORMAT NIL "|~a|" |op|)
                             (APPEND (PROG (G168166)
                                       (SPADLET G168166 NIL)
                                       (RETURN
                                         (DO
                                          ((G168171 |argl|
                                            (CDR G168171))
                                           (|y| NIL))
                                          ((OR (ATOM G168171)
                                            (PROGN
                                              (SETQ |y|
                                               (CAR G168171))
                                              NIL))
                                           G168166)
                                           (SEQ
                                            (EXIT
                                             (SETQ G168166
                                              (APPEND G168166
                                               (|form2Fence1| |y|))))))))
                                     (CONS ")" NIL)))))))
             ((IDENTP |x|) (FORMAT NIL "|~a|" |x|))
             ('T (CONS "  " (CONS |x| NIL))))))))

;form2FenceQuote x ==
;  NUMBERP x => [STRINGIMAGE x]
;  SYMBOLP x => [FORMAT(NIL, '"|~a|", x)]
;  atom    x => '"??"
;  ['"(",:form2FenceQuote first x,:form2FenceQuoteTail rest x]

(DEFUN |form2FenceQuote| (|x|)
  (COND
    ((NUMBERP |x|) (CONS (STRINGIMAGE |x|) NIL))
    ((SYMBOLP |x|) (CONS (FORMAT NIL "|~a|" |x|) NIL))
    ((ATOM |x|) "??")
    ('T
     (CONS "("
           (APPEND (|form2FenceQuote| (CAR |x|))
                   (|form2FenceQuoteTail| (CDR |x|)))))))

;form2FenceQuoteTail x ==
;  null x => ['")"]
;  atom x => ['" . ",:form2FenceQuote x,'")"]
;  ['" ",:form2FenceQuote first x,:form2FenceQuoteTail rest x]

(DEFUN |form2FenceQuoteTail| (|x|)
  (COND
    ((NULL |x|) (CONS ")" NIL))
    ((ATOM |x|)
     (CONS " . "
           (APPEND (|form2FenceQuote| |x|) (CONS ")" NIL))))
    ('T
     (CONS " "
           (APPEND (|form2FenceQuote| (CAR |x|))
                   (|form2FenceQuoteTail| (CDR |x|)))))))

;form2StringList u ==
;  atom (r := form2String u) => [r]
;  r

(DEFUN |form2StringList| (|u|)
  (PROG (|r|)
    (RETURN
      (COND
        ((ATOM (SPADLET |r| (|form2String| |u|))) (CONS |r| NIL))
        ('T |r|)))))

\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
