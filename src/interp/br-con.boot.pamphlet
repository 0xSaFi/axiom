\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp br-con.boot}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{License}
<<license>>=
-- Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
-- All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are
-- met:
--
--     - Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--
--     - Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in
--       the documentation and/or other materials provided with the
--       distribution.
--
--     - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--       names of its contributors may be used to endorse or promote products
--       derived from this software without specific prior written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-- IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-- TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-- PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
-- OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-- EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-- PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-- LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-- NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@
<<*>>=
<<license>>

--====================> WAS b-con.boot <================================

--=======================================================================
--              Pages Initiated from HyperDoc Pages
--=======================================================================
--NOTE: This duplicate version was discovered 3/20/94 in br-search.boot
--called from buttons via bcCon, bcAbb, bcConform, dbShowCons1, dbSelectCon
--conPage(a,:b) ==
--  --The next 4 lines allow e.g. MATRIX INT  ==> Matrix Integer (see kPage)
--  $conArgstrings: local :=
--    atom a => b
--    a := conform2OutputForm a
--    [mathform2HtString x for x in rest a]
--  if not atom a then a := first a
--  da := DOWNCASE a
--  pageName := LASSQ(da,'((type . CategoryType)(union . DomainUnion)(record . DomainRecord)(mapping . DomainMapping))) =>
--    downlink pageName              --special jump out for primitive domains
--  line := conPageFastPath a        => kPage line  --lower case name of cons?
--  line := conPageFastPath UPCASE a => kPage line  --upper case an abbr?
--  ySearch a                        --slow search (include default packages)
--

--called from buttons via bcCon, bcAbb, bcConform, dbShowCons1, dbSelectCon
conPage(a,:b) ==
  --The next 4 lines allow e.g. MATRIX INT  ==> Matrix Integer (see kPage)
  form :=
    atom a => [a,:b]
    a
  $conArgstrings: local := [form2HtString x for x in KDR a]
  if not atom a then a := first a
  da := DOWNCASE a
  pageName := LASSQ(da,'((type . CategoryType)(union . DomainUnion)(record . DomainRecord)(mapping . DomainMapping)(enumeration . DomainEnumeration))) =>
    downlink pageName                --special jump out for primitive domains
  line := conPageFastPath da  => kPage(line,form) --lower case name of cons?
  line := conPageFastPath UPCASE a => kPage(line,form) --upper case an abbr?
  ySearch a       --slow search (include default packages)

conPageFastPath x == --called by conPage and constructorSearch
--gets line quickly for constructor name or abbreviation
  s := STRINGIMAGE x
  charPosition(char '_*,s,0) < #s => nil     --quit if name has * in it
  name := (STRINGP x => INTERN x; x)
  entry := HGET($lowerCaseConTb,name) or return nil
  lineNumber := LASSQ('dbLineNumber,CDDR entry) =>
    --'dbLineNumbers property is set by function dbAugmentConstructorDataTable
    dbRead lineNumber --read record for constructor from libdb.text
  conPageConEntry first entry

conPageConEntry entry ==
  $conname: local := nil
  $conform: local := nil
  $exposed?:local := nil
  $doc:     local := nil
  $kind:    local := nil
  buildLibdbConEntry entry

--=======================================================================
--                    Constructor Page
--=======================================================================
-- in br-saturn.boot now
--% kPage(line,:options) == --any cat, dom, package, default package
--% --constructors    Cname\#\E\sig \args   \abb \comments (C is C, D, P, X)
--% ------------------> BRANCH OUT FOR SATURN
--%   true => kPageSaturn(line,options)
--%   parts := dbXParts(line,7,1)
--%   [kind,name,nargs,xflag,sig,args,abbrev,comments] := parts
--%   form := IFCAR options
--%   isFile := null kind
--%   kind := kind or '"package"
--%   RPLACA(parts,kind)
--%   conform         := mkConform(kind,name,args)
--%   conname         := opOf conform
--%   capitalKind     := capitalize kind
--%   signature       := ncParseFromString sig
--%   sourceFileName  := dbSourceFile INTERN name
--%   constrings      :=
--%     KDR form => dbConformGenUnder form
--%     [STRCONC(name,args)]
--%   emString        := ['"{\sf ",:constrings,'"}"]
--%   heading := [capitalKind,'" ",:emString]
--%   if not isExposedConstructor conname then heading := ['"Unexposed ",:heading]
--%   if name=abbrev then abbrev := asyAbbreviation(conname,nargs)
--%   page := htInitPage(heading,nil)
--%   htpSetProperty(page,'isFile,true)
--%   htpSetProperty(page,'parts,parts)
--%   htpSetProperty(page,'heading,heading)
--%   htpSetProperty(page,'kind,kind)
--%   if asharpConstructorName? conname then
--%     htpSetProperty(page,'isAsharpConstructor,true)
--%   htpSetProperty(page,'conform,conform)
--%   htpSetProperty(page,'signature,signature)
--%   kdPageInfo(name,abbrev,nargs,conform,signature,isFile)
--%   htSayStandard  '"\newline"
--%   htBeginMenu(3)
--%   htSayStandard '"\item "
--%   htMakePage [['bcLinks,['"\menuitemstyle{Description}",
--%                 [['text,'"\tab{19}",'"General description"]],'kiPage,nil]]]
--%   satBreak()
--%   htMakePage [['bcLinks,['"\menuitemstyle{Operations}",
--%                 [['text,'"\tab{19}All exported operations"]],'koPage,'"operation"]]]
--%   if not asharpConstructorName? conname then
--%     satBreak()
--%     htMakePage [['bcLinks,['"\menuitemstyle{Attributes}",
--%                 [['text,'"\tab{19}All exported attributes"]],'koPage,'"attribute"]]]
--%   if kind ^= 'category and (pathname := dbHasExamplePage conname) then
--%     satBreak()
--%     htMakePage [['bcLinks,['"\menuitemstyle{Examples}",
--%                 [['text,'"\tab{19}Examples illustrating use"]],'kxPage,pathname]]]
--%   satBreak()
--%   htMakePage [['bcLinks,['"\menuitemstyle{Exports}",
--%     [['text,'"\tab{19}Explicit categories and operations"]],'kePage,nil]]]
--%   satBreak()
--%   htMakePage [['bcLinks,['"\menuitemstyle{Cross Reference}",
--%                 [['text,'"\tab{19}Hierarchy and usage information"]],'kcPage,nil]]]
--%   htEndMenu(3)
--%   if kind ^= 'category and nargs > 0 then addParameterTemplates conform
--%   htShowPage()
--% 
conform2String u ==
  x := form2String u
  atom x => STRINGIMAGE x
  "STRCONC"/[STRINGIMAGE y for y in x]

kxPage(htPage,name) == downlink name

kdPageInfo(name,abbrev,nargs,conform,signature,file?) ==
  htSay("{\sf ",name,'"}")
  if abbrev ^= name then bcHt [" has abbreviation ",abbrev]
  if file? then bcHt ['" is a source file."]
  if nargs = 0 then (if abbrev ^= name then bcHt '".")
    else
      if abbrev ^= name then bcHt '" and"
      bcHt
        nargs = 1 => '" takes one argument:"
        [" takes ",STRINGIMAGE nargs," arguments:"]
  htSaturnBreak()
  htSayStandard '"\indentrel{2}"
  if nargs > 0 then kPageArgs(conform,signature)
  htSayStandard '"\indentrel{-2}"
  if name.(#name-1) = char "&" then name := SUBSEQ(name, 0, #name-1)
--sourceFileName := dbSourceFile INTERN name
  sourceFileName := GETDATABASE(INTERN name,'SOURCEFILE)
  filename := extractFileNameFromPath sourceFileName
  if filename ^= '"" then
    htSayStandard '"\newline{}"
    htSay('"The source code for the constructor is found in ")
  htMakePage [['text,'"\unixcommand{",filename,'"}{_\$AXIOM/lib/SPADEDIT ",
              sourceFileName, '" ", name, '"}"]]
  if nargs ^= 0 then htSay '"."
  htSaturnBreak()

kPageArgs([op,:args],[.,.,:source]) ==
------------------> OBSELETE
  firstTime := true
  coSig := rest GETDATABASE(op,'COSIG)
  for x in args for t in source for pred in coSig repeat
    if not firstTime then htSay '", and"
    htSay('"\newline ")
    typeForm := (t is [":",.,t1] => t1; t)
    if pred = true
      then htMakePage [['bcLinks,[x,'"",'kArgPage,x]]]
      else htSay('"{\em ",x,'"}")
    htSay( '"\tab{",STRINGIMAGE( # PNAME x),'"}, ")
    htSay
      pred => '"a domain of category "
      '"an element of the domain "
    bcConform(typeForm,true)

kArgPage(htPage,arg) ==
  [op,:args] := conform := htpProperty(htPage,'conform)
  domname := htpProperty(htPage,'domname)
  heading := htpProperty(htPage,'heading)
  source := CDDAR getConstructorModemap op
  n := position(arg,args)
  typeForm := sublisFormal(args,source . n)
  domTypeForm := mkDomTypeForm(typeForm,conform,domname)
  descendants := domainDescendantsOf(typeForm,domTypeForm)
  htpSetProperty(htPage,'cAlist,descendants)
  rank :=
    n > 4 => nil
    ('(First Second Third Fourth Fifth)).n
  htpSetProperty(htPage,'rank,rank)
  htpSetProperty(htPage,'thing,'"argument")
--htpSetProperty(htPage,'specialMessage,['reportCategory,conform,typeForm,arg])
  dbShowCons(htPage,'names)

reportCategory(conform,typeForm,arg) ==
  htSay('"Argument {\em ",arg,'"}")
  [conlist,attrlist,:oplist] := categoryParts(conform,typeForm,true)
  htSay '" must "
  if conlist then
    htSay '"belong to "
    if conlist is [u] then
       htSay('"category ")
       bcConform first u
       bcPred rest u
    else
       htSay('"categories:")
       bcConPredTable(conlist,opOf conform)
       htSay '"\newline "
  if attrlist then
    if conlist then htSay '" and "
    reportAO('"attribute",attrlist)
    htSay '"\newline "
  if oplist then
    if conlist or attrlist then htSay '" and "
    reportAO('"operation",oplist)

reportAO(kind,oplist) ==
  htSay('"have ",kind,'":")
  for [op,sig,:pred] in oplist repeat
    htSay '"\newline "
    if #oplist = 1 then htSay '"\centerline{"
    if kind = '"attribute" then
      attr := form2String [op,:sig]
      satDownLink(attr,['"(|attrPage| '|",attr,'"|)"])
    else
      ops  := escapeSpecialChars STRINGIMAGE op
      sigs := form2HtString ['Mapping,:sig]
      satDownLink(ops,['"(|opPage| '|",ops,'"| |",sigs,'"|)"])
      htSay '": "
      bcConform ['Mapping,:sig]
    if #oplist = 1 then htSay '"}"
  htSay '"\newline "

mkDomTypeForm(typeForm,conform,domname) == --called by kargPage
  domname => SUBLISLIS(rest domname,rest conform,typeForm)
  typeForm is ['Join,:r] => ['Join,:[mkDomTypeForm(t,conform,domname) for t in r]]
  null hasIdent typeForm => typeForm
  nil

domainDescendantsOf(conform,domform) == main where --called by kargPage
  main ==
    conform is [op,:r] =>
      op = 'Join => jfn(DELETE('(Type Object),r),DELETE('(Type Object),IFCDR domform))
      op = 'CATEGORY => nil
      domainsOf(conform,domform)
    domainsOf(conform,domform)
  jfn([y,:r],domlist) ==  --keep only those domains that appear in ALL parts of Join
    alist := domainsOf(y,IFCAR domlist)
    for x in r repeat
      domlist := IFCDR domlist
      x is ['CATEGORY,.,:r] => alist := catScreen(r,alist)
      keepList := nil
      for [item,:pred] in domainsOf(x,IFCAR domlist) repeat
        u := ASSOC(item,alist) =>
          keepList := [[item,:quickAnd(CDR u,pred)],:keepList]
      alist := keepList
    for pair in alist repeat RPLACD(pair,simpHasPred CDR pair)
    listSort(function GLESSEQP, alist)
  catScreen(r,alist) ==
    for x in r repeat
      x isnt [op1,:.] and MEMQ(op1,'(ATTRIBUTE SIGNATURE)) => systemError x
      alist := [[item,:npred] for [item,:pred] in alist |
        (pred1 := simpHasPred ['has,item,x]) and (npred := quickAnd(pred1,pred))]
    alist

--=======================================================================
--                   Branches of Constructor Page
--=======================================================================

kiPage(htPage,junk) ==
  [kind,name,nargs,xflag,sig,args,abbrev,comments] := htpProperty(htPage,'parts)
  conform         := mkConform(kind,name,args)
  domname         := kDomainName(htPage,kind,name,nargs)
  domname is ['error,:.] => errorPage(htPage,domname)
  heading := ['"Description of ", capitalize kind,'" {\sf ",name,args,'"}"]
  page := htInitPage(heading,htCopyProplist htPage)
  $conformsAreDomains := domname
  dbShowConsDoc1(htPage,conform,nil)
  htShowPage()

kePage(htPage,junk) ==
  [kind,name,nargs,xflag,sig,args,abbrev,comments] := htpProperty(htPage,'parts)
  constring       := STRCONC(name,args)
  domname         := kDomainName(htPage,kind,name,nargs)
  domname is ['error,:.] => errorPage(htPage,domname)
  htpSetProperty(htPage,'domname,domname)
  $conformsAreDomains: local := domname
  conform         := mkConform(kind,name,args)
  conname         := opOf conform
  heading := [capitalize kind,'" {\sf ",
               (domname => form2HtString(domname,nil,true); constring),'"}"]
  data := sublisFormal(IFCDR domname or rest conform,
                       getConstructorExports((domname or conform),true))
  [conlist,attrlist,:oplist] := data
  if domname then
    for x in conlist repeat  RPLAC(CDR x,simpHasPred CDR x)
    for x in attrlist repeat RPLAC(CDDR x,simpHasPred CDDR x)
    for x in oplist   repeat RPLAC(CDDR x,simpHasPred CDDR x)
  prefix := pluralSay(#conlist + #attrlist + #oplist,'"Export",'"Exports")
  page := htInitPage([:prefix,'" of ",:heading],htCopyProplist htPage)
  htSayStandard '"\beginmenu "
  htpSetProperty(page,'data,data)
  if conlist then
    htMakePage [['bcLinks,[menuButton(),'"",'dbShowCons1,conlist,'names]]]
    htSayStandard '"\tab{2}"
    htSay  '"All attributes and operations from:"
    bcConPredTable(conlist,opOf conform,rest conform)
  if attrlist then
    if conlist then htBigSkip()
    kePageDisplay(page,'"attribute",kePageOpAlist attrlist)
  if oplist then
    if conlist or attrlist then htBigSkip()
    kePageDisplay(page,'"operation",kePageOpAlist oplist)
  htSayStandard '" \endmenu "
  htShowPage()

kePageOpAlist oplist ==
  opAlist := nil
  for [op,sig,:pred] in oplist repeat
    u := LASSOC(op,opAlist)
--was 
--    opAlist := insertAlist(op,[[sig,pred],:u],opAlist)
    opAlist := insertAlist(zeroOneConvert op,[[sig,pred],:u],opAlist)
  opAlist

kePageDisplay(htPage,which,opAlist) ==
  count := #opAlist
  total := +/[#(rest entry) for entry in opAlist]
  count = 0 => nil
  if which = '"operation"
    then htpSetProperty(htPage,'opAlist,opAlist)
    else htpSetProperty(htPage,'attrAlist,opAlist)
  expandProperty :=
    which = '"operation" => 'expandOperations
    'expandAttributes
  htpSetProperty(htPage,expandProperty,'lists)  --mark as unexpanded
  htMakePage [['bcLinks,[menuButton(),'"",'dbShowOps,which,'names]]]
  htSayStandard '"\tab{2}"
  if count ^= total then
    if count = 1
    then htSay('"1 name for ")
    else htSay(STRINGIMAGE count,'" names for ")
  if total > 1
    then htSay(STRINGIMAGE total,'" ",pluralize which,'" are explicitly exported:")
    else htSay('"1 ",which,'" is explicitly exported:")
  htSaySaturn '"\\"
  data := dbGatherData(htPage,opAlist,which,'names)
  dbShowOpItems(which,data,false)

ksPage(htPage,junk) ==
  [kind,name,nargs,xpart,sig,args,abbrev,comments] := htpProperty(htPage,'parts)
  domname         := kDomainName(htPage,kind,name,nargs)
  domname is ['error,:.] => errorPage(htPage,domname)
  heading :=
    null domname => htpProperty(htPage,'heading)
    ['"{\sf ",form2HtString(domname,nil,true),'"}"]
  if domname then
    htpSetProperty(htPage,'domname,domname)
    htpSetProperty(htPage,'heading,heading)
  domain  := (kind = '"category" => nil; EVAL domname)
  conform:= htpProperty(htPage,'conform)
  page := htInitPageNoScroll(htCopyProplist htPage,
                             ['"Search order for ",:heading])
  htSay '"When an operation is not defined by the domain, the following domains are searched in order for a _"default definition"
  htSayStandard '"\beginscroll "
  u := dbSearchOrder(conform,domname,domain)
  htpSetProperty(htPage,'cAlist,u)
  htpSetProperty(htPage,'thing,'"constructor")
  dbShowCons(htPage,'names)

dbSearchOrder(conform,domname,$domain) ==  --domain = nil or set to live domain
  conform := domname or conform
  name:= opOf conform
  $infovec: local := dbInfovec name or return nil  --exit for categories
  u := $infovec.3
  $predvec:=
    $domain => $domain . 3
    GETDATABASE(name,'PREDICATES)
  catpredvec := CAR u
  catinfo    := CADR u
  catvec     := CADDR u
  catforms := [[pakform,:pred] for i in 0..MAXINDEX catvec | test ] where
    test ==
      pred := simpCatPredicate
        p:=SUBLISLIS(rest conform,$FormalMapVariableList,kTestPred catpredvec.i)
        $domain => EVAL p
        p
      if domname and CONTAINED('$,pred) then pred := SUBST(domname,'$,pred)
--    which = '"attribute" => pred    --all categories
      (pak := catinfo . i) and pred   --only those with default packages
    pakform ==
      pak and not IDENTP pak => devaluate pak --in case it has been instantiated
      catform := kFormatSlotDomain catvec . i
--    which = '"attribute" => dbSubConform(rest conform,catform)
      res := dbSubConform(rest conform,[pak,"$",:rest catform])
      if domname then res := SUBST(domname,'$,res)
      res
  [:dbAddChain conform,:catforms]

kcPage(htPage,junk) ==
  [kind,name,nargs,xpart,sig,args,abbrev,comments] := htpProperty(htPage,'parts)
  domname         := kDomainName(htPage,kind,name,nargs)
  domname is ['error,:.] => errorPage(htPage,domname)
--  domain          := (kind = '"category" => nil; EVAL domname)
  conform := htpProperty(htPage,'conform)
  conname := opOf conform
  heading :=
    null domname => htpProperty(htPage,'heading)
    ['"{\sf ",form2HtString(domname,nil,true),'"}"]
  page := htInitPage(['"Cross Reference for ",:heading],htCopyProplist htPage)
  if domname then
    htpSetProperty(htPage,'domname,domname)
    htpSetProperty(htPage,'heading,heading)
  if kind = '"category" and dbpHasDefaultCategory? xpart then
    htSay '"This category has default package "
    bcCon(STRCONC(name,char '_&),'"")
  htSayStandard '"\newline"
  htBeginMenu(3)
  htSayStandard '"\item "
  message :=
    kind = '"category" => ['"Categories it directly extends"]
    ['"Categories the ",(kind = '"default package" => '"package"; kind),'" belongs to by assertion"]
  htMakePage [['bcLinks,['"\menuitemstyle{Parents}",
    [['text,'"\tab{12}",:message]],'kcpPage,nil]]]
  satBreak()
  message :=
    kind = '"category" => ['"All categories it is an extension of"]
    ['"All categories the ",kind,'" belongs to"]
  htMakePage [['bcLinks,['"\menuitemstyle{Ancestors}",
    [['text,'"\tab{12}",:message]],'kcaPage,nil]]]
  if kind = '"category" then
    satBreak()
    htMakePage [['bcLinks,['"\menuitemstyle{Children}",[['text,'"\tab{12}",
      '"Categories which directly extend this category"]],'kccPage,nil]]]

    satBreak()
    htMakePage [['bcLinks,['"\menuitemstyle{Descendants}",[['text,'"\tab{12}",
      '"All categories which extend this category"]],'kcdPage,nil]]]
  if not asharpConstructorName? conname then
    satBreak()
    message := '"Constructors mentioning this as an argument type"
    htMakePage [['bcLinks,['"\menuitemstyle{Dependents}",
      [['text,'"\tab{12}",message]],'kcdePage,nil]]]
  if not asharpConstructorName? conname and kind ^= '"category" then
    satBreak()
    htMakePage [['bcLinks,['"\menuitemstyle{Lineage}",
      '"\tab{12}Constructor hierarchy used for operation lookup",'ksPage,nil]]]
  if not asharpConstructorName? conname then
   if kind = '"category" then
    satBreak()
    htMakePage [['bcLinks,['"\menuitemstyle{Domains}",[['text,'"\tab{12}",
      '"All domains which are of this category"]],'kcdoPage,nil]]]
   if kind ^= '"category" then
    satBreak()
    htMakePage [['bcLinks,['"\menuitemstyle{Clients}",'"\tab{12}Constructors",'kcuPage,nil]]]
    if HGET($defaultPackageNamesHT,conname)
      then htSay('" which {\em may use} this default package")
--  htMakePage [['bcLinks,['"files",'"",'kcuPage,true]]]
      else htSay('" which {\em use} this ",kind)
  if kind ^= '"category" or dbpHasDefaultCategory? xpart then
    satBreak()
    message :=
      kind = '"category" => ['"Constructors {\em used by} its default package"]
      ['"Constructors {\em used by} the ",kind]
    htMakePage [['bcLinks,['"\menuitemstyle{Benefactors}",
      [['text,'"\tab{12}",:message]],'kcnPage,nil]]]
  --to remove "Capsule Information", comment out the next 5 lines
  if not asharpConstructorName? conname and hasNewInfoAlist conname then
    satBreak()
    message := ['"Cross reference for capsule implementation"]
    htMakePage [['bcLinks,['"\menuitemstyle{CapsuleInfo}",
      [['text,'"\tab{12}",:message]],'kciPage,nil]]]
  htEndMenu(3)
  htShowPage()

kcpPage(htPage,junk) ==
  [kind,name,nargs,xpart,sig,args,abbrev,comments] := htpProperty(htPage,'parts)
  domname         := kDomainName(htPage,kind,name,nargs)
  domname is ['error,:.] => errorPage(htPage,domname)
  heading :=
    null domname => htpProperty(htPage,'heading)
    ['"{\sf ",form2HtString(domname,nil,true),'"}"]
  if domname then
    htpSetProperty(htPage,'domname,domname)
    htpSetProperty(htPage,'heading,heading)
  conform := htpProperty(htPage,'conform)
  conname := opOf conform
  page := htInitPage(['"Parents of ",:heading],htCopyProplist htPage)
  parents := parentsOf conname --was listSort(function GLESSEQP, =this)
  if domname then parents := SUBLISLIS(rest domname,rest conform,parents)
  htpSetProperty(htPage,'cAlist,parents)
  htpSetProperty(htPage,'thing,'"parent")
  choice :=
    domname => 'parameters
    'names
  dbShowCons(htPage,choice)

reduceAlistForDomain(alist,domform,conform) == --called from kccPage
  alist := SUBLISLIS(rest domform,rest conform,alist)
  for pair in alist repeat RPLACD(pair,simpHasPred(CDR pair,domform))
  [pair for (pair := [.,:pred]) in alist | pred]

kcaPage(htPage,junk) ==
  kcaPage1(htPage,'"category",'" an ",'"ancestor",function ancestorsOf, false)

kcdPage(htPage,junk) ==
  kcaPage1(htPage,'"category",'" a ",'"descendant",function descendantsOf,true)

kcdoPage(htPage,junk)==
  kcaPage1(htPage,'"domain",'" a ",'"descendant",function domainsOf, false)

kcaPage1(htPage,kind,article,whichever,fn, isCatDescendants?) ==
  [kind,name,nargs,xpart,sig,args,abbrev,comments] := htpProperty(htPage,'parts)
  domname         := kDomainName(htPage,kind,name,nargs)
  domname is ['error,:.] => errorPage(htPage,domname)
  heading :=
    null domname => htpProperty(htPage,'heading)
    ['"{\sf ",form2HtString(domname,nil,true),'"}"]
  if domname and not isCatDescendants? then
    htpSetProperty(htPage,'domname,domname)
    htpSetProperty(htPage,'heading,heading)
  conform := htpProperty(htPage,'conform)
  conname := opOf conform
  ancestors := FUNCALL(fn, conform, domname)
  if whichever ^= '"ancestor" then
    ancestors := augmentHasArgs(ancestors,conform)
  ancestors := listSort(function GLESSEQP,ancestors)
--if domname then ancestors := SUBST(domname,'$,ancestors)
  htpSetProperty(htPage,'cAlist,ancestors)
  htpSetProperty(htPage,'thing,whichever)
  choice :=
--  domname => 'parameters
    'names
  dbShowCons(htPage,choice)

kccPage(htPage,junk) ==
  [kind,name,nargs,xpart,sig,args,abbrev,comments] := htpProperty(htPage,'parts)
  domname         := kDomainName(htPage,kind,name,nargs)
  domname is ['error,:.] => errorPage(htPage,domname)
  heading :=
    null domname => htpProperty(htPage,'heading)
    ['"{\sf ",form2HtString(domname,nil,true),'"}"]
  if domname then
    htpSetProperty(htPage,'domname,domname)
    htpSetProperty(htPage,'heading,heading)
  conform := htpProperty(htPage,'conform)
  conname := opOf conform
  page := htInitPage(['"Children of ",:heading],htCopyProplist htPage)
  children:= augmentHasArgs(childrenOf conform,conform)
  if domname then children := reduceAlistForDomain(children,domname,conform)
  htpSetProperty(htPage,'cAlist,children)
  htpSetProperty(htPage,'thing,'"child")
  dbShowCons(htPage,'names)

augmentHasArgs(alist,conform) ==
  conname := opOf conform
  args    := KDR conform or return alist
  n       := #args
  [[name,:pred] for [name,:p] in alist] where pred ==
     extractHasArgs p is [a,:b] => p
     quickAnd(p,['hasArgs,:TAKE(n,KDR getConstructorForm opOf name)])

kcdePage(htPage,junk) ==
  [kind,name,nargs,xflag,sig,args,abbrev,comments] := htpProperty(htPage,'parts)
  conname         := INTERN name
  constring       := STRCONC(name,args)
  conform         :=
    kind ^= '"default package" => ncParseFromString constring
    [INTERN name,:rest ncParseFromString STRCONC(char 'd,args)]  --because of &
  pakname         :=
--  kind = '"category" => INTERN STRCONC(name,char '_&)
    opOf conform
  domList := getDependentsOfConstructor pakname
  cAlist := [[getConstructorForm x,:true] for x in domList]
  htpSetProperty(htPage,'cAlist,cAlist)
  htpSetProperty(htPage,'thing,'"dependent")
  dbShowCons(htPage,'names)

kcuPage(htPage,junk) ==
  [kind,name,nargs,xflag,sig,args,abbrev,comments] := htpProperty(htPage,'parts)
  conname         := INTERN name
  constring       := STRCONC(name,args)
  conform         :=
    kind ^= '"default package" => ncParseFromString constring
    [INTERN name,:rest ncParseFromString STRCONC(char 'd,args)]  --because of &
  pakname         :=
    kind = '"category" => INTERN STRCONC(name,char '_&)
    opOf conform
  domList := getUsersOfConstructor pakname
  cAlist := [[getConstructorForm x,:true] for x in domList]
  htpSetProperty(htPage,'cAlist,cAlist)
  htpSetProperty(htPage,'thing,'"user")
  dbShowCons(htPage,'names)

kcnPage(htPage,junk) ==
--if reached by a category, that category has a default package
  [kind,name,nargs,xpart,sig,args,abbrev,comments] := htpProperty(htPage,'parts)
  domname         := kDomainName(htPage,kind,name,nargs)
  domname is ['error,:.] => errorPage(htPage,domname)
  heading :=
    null domname => htpProperty(htPage,'heading)
    ['"{\sf ",form2HtString(domname,nil,true),'"}"]
  if domname then
    htpSetProperty(htPage,'domname,domname)
    htpSetProperty(htPage,'heading,heading)
  conform:= htpProperty(htPage,'conform)
  pakname         :=
    kind = '"category" => INTERN STRCONC(PNAME conname,char '_&)
    opOf conform
  domList := getImports pakname
  if domname then
    domList := SUBLISLIS([domname,:rest domname],['$,:rest conform],domList)
  cAlist := [[x,:true] for x in domList]
  htpSetProperty(htPage,'cAlist,cAlist)
  htpSetProperty(htPage,'thing,'"benefactor")
  dbShowCons(htPage,'names)

koPageInputAreaUnchanged?(htPage, nargs) ==
  [htpLabelInputString(htPage,INTERN STRCONC('"*",STRINGIMAGE i)) for i in 1..nargs]
      = htpProperty(htPage,'inputAreaList)

kDomainName(htPage,kind,name,nargs) ==
  htpSetProperty(htPage,'domname,nil)
  inputAreaList :=
    [htpLabelInputString(htPage,var) for i in 1..nargs for var in $PatternVariableList]
  htpSetProperty(htPage,'inputAreaList,inputAreaList)
  conname := INTERN name
  args := [kArgumentCheck(domain?,x) or nil for x in inputAreaList
              for domain? in rest GETDATABASE(conname,'COSIG)]
  or/[null x for x in args] =>
    (n := +/[1 for x in args | x]) > 0 =>
      ['error,nil,'"\centerline{You gave values for only {\em ",n,'" } of the {\em ",#args,'"}}",'"\centerline{parameters of {\sf ",name,'"}}\vspace{1}\centerline{Please enter either {\em all} or {\em none} of the type parameters}"]
    nil
  argString :=
    null args => '"()"
    argTailPart :=
      "STRCONC"/["STRCONC"/ ['",",:x] for x in KDR args]
    "STRCONC"/['"(",:first args,argTailPart,'")"]
  typeForm := CATCH('SPAD__READER, unabbrev mkConform(kind,name,argString)) or
    ['error,'invalidType,STRCONC(name,argString)]
  null (evaluatedTypeForm := kisValidType typeForm) =>
    ['error,'invalidType,STRCONC(name,argString)]
  dbMkEvalable evaluatedTypeForm

kArgumentCheck(domain?,s) ==
  s = '"" => nil
  domain? and (form := conSpecialString? s) =>
    null KDR form => [STRINGIMAGE opOf form]
    form2String form
  [s]

dbMkEvalable form ==
--like mkEvalable except that it does NOT quote domains
--does not do "loadIfNecessary"
  [op,:.] := form
  kind := GETDATABASE(op,'CONSTRUCTORKIND)
  kind = 'category => form
  mkEvalable form

topLevelInterpEval x ==
  $ProcessInteractiveValue: fluid := true
  $noEvalTypeMsg: fluid := true
  processInteractive(x,nil)

kisValidType typeForm ==
  $ProcessInteractiveValue: fluid := true
  $noEvalTypeMsg: fluid := true
  CATCH('SPAD__READER, processInteractive(typeForm,nil))
    is [[h,:.],:t] and MEMBER(h,'(Domain SubDomain)) =>
      kCheckArgumentNumbers t and t
  false

kCheckArgumentNumbers t ==
  [conname,:args] := t
  cosig := KDR GETDATABASE(conname,'COSIG)
  #cosig ^= #args => false
  and/[foo for domain? in cosig for x in args] where foo ==
    domain? => kCheckArgumentNumbers x
    true

parseNoMacroFromString(s) ==
   s := next(function ncloopParse,
        next(function lineoftoks,incString s))
   StreamNull s => nil
   pf2Sex first rest first s
 


mkConform(kind,name,argString) ==
  kind ^= '"default package" =>
    form := STRCONC(name,argString)
    parse := parseNoMacroFromString form
    null parse =>
      sayBrightlyNT '"Won't parse: "
      pp form
      systemError '"Keywords in argument list?"
    ATOM parse => [parse]
    parse
  [INTERN name,:rest ncParseFromString STRCONC(char 'd,argString)]  --& case

--=======================================================================
--           Operation Page for a Domain Form from Scratch
--=======================================================================
conOpPage(htPage,conform) ==
  updown := dbCompositeWithMap htPage
  updown = '"DOWN" =>
    domname := htpProperty(htPage,'domname)
    conOpPage1(dbExtractUnderlyingDomain domname,[['updomain,:domname]])
  domname := htpProperty(htPage,'updomain)
  conOpPage1(domname,nil)

dbCompositeWithMap htPage ==
  htpProperty(htPage,'updomain) => '"UP"
  domain := htpProperty(htPage,'domname)
  null domain => false
  opAlist := htpProperty(htPage,'opAlist)
--not LASSOC('map,opAlist) => false
  dbExtractUnderlyingDomain htpProperty(htPage,'domname) => '"DOWN"
  false

dbExtractUnderlyingDomain domain == or/[x for x in KDR domain | isValidType x]

--conform is atomic if no parameters, otherwise must be valid domain form
conOpPage1(conform,:options) ==
--constructors    Cname\#\E\sig \args   \abb \comments (C is C, D, P, X)
  bindingsAlist := IFCAR options
  conname       := opOf conform
  MEMQ(conname,$Primitives) =>
     dbSpecialOperations conname
  domname         :=                        --> !!note!! <--
    null atom conform => conform
    nil
  line := conPageFastPath conname
  [kind,name,nargs,xflag,sig,args,abbrev,comments]:=parts:= dbXParts(line,7,1)
  isFile := null kind
  kind := kind or '"package"
  RPLACA(parts,kind)
  constring       := STRCONC(name,args)
  conform         := mkConform(kind,name,args)
  capitalKind     := capitalize kind
  signature       := ncParseFromString sig
  sourceFileName  := dbSourceFile INTERN name
  emString        := ['"{\sf ",constring,'"}"]
  heading := [capitalKind,'" ",:emString]
  if not isExposedConstructor conname then heading := ['"Unexposed ",:heading]
  page := htInitPage(heading,nil)
  htpSetProperty(page,'isFile,true)
  htpSetProperty(page,'fromConOpPage1,true)
  htpSetProperty(page,'parts,parts)
  htpSetProperty(page,'heading,heading)
  htpSetProperty(page,'kind,kind)
  htpSetProperty(page,'domname,domname)         --> !!note!! <--
  htpSetProperty(page,'conform,conform)
  htpSetProperty(page,'signature,signature)
  if selectedOperation := LASSOC('selectedOperation,IFCDR options) then
    htpSetProperty(page,'selectedOperation,selectedOperation)
  for [a,:b] in bindingsAlist repeat htpSetProperty(page,a,b)
  koPage(page,'"operation")

--=======================================================================
--           Operation Page from Main Page
--=======================================================================
koPage(htPage,which) ==
  [kind,name,nargs,xflag,sig,args,abbrev,comments] := htpProperty(htPage,'parts)
  constring       := STRCONC(name,args)
  conname         := INTERN name
  domname         :=
    (u := htpProperty(htPage,'domname)) is [=conname,:.]
      and  (htpProperty(htPage,'fromConOpPage1) = true or
             koPageInputAreaUnchanged?(htPage,nargs)) => u
    kDomainName(htPage,kind,name,nargs)
  domname is ['error,:.] => errorPage(htPage,domname)
  htpSetProperty(htPage,'domname,domname)
  headingString :=
    domname => form2HtString(domname,nil,true)
    constring
  heading := [capitalize kind,'" {\sf ",headingString,'"}"]
  htpSetProperty(htPage,'which,which)
  htpSetProperty(htPage,'heading,heading)
  koPageAux(htPage,which,domname,heading)

koPageFromKKPage(htPage,ao) ==
  koPageAux(htPage,ao,htpProperty(htPage,'domname),htpProperty(htPage,'heading))

koPageAux(htPage,which,domname,heading) == --from koPage, koPageFromKKPage
  htpSetProperty(htPage,'which,which)
  domname := htpProperty(htPage,'domname)
  conform := htpProperty(htPage,'conform)
  heading := htpProperty(htPage,'heading)
  opAlist          :=
    which = '"attribute" => koAttrs(conform,domname)
    which = '"general operation" => koOps(conform,domname,true)
    koOps(conform,domname)
  if selectedOperation := htpProperty(htPage,'selectedOperation) then
    opAlist := [ASSOC(selectedOperation,opAlist) or systemError()]
  dbShowOperationsFromConform(htPage,which,opAlist)

koPageAux1(htPage,opAlist) ==
  which   := htpProperty(htPage,'which)
  dbShowOperationsFromConform(htPage,which,opAlist)

koaPageFilterByName(htPage,functionToCall) ==
  htpLabelInputString(htPage,'filter) = '"" =>
    koaPageFilterByCategory(htPage,functionToCall)
  filter := pmTransFilter(dbGetInputString htPage)
--WARNING: this call should check for ['error,:.] returned
  which   := htpProperty(htPage,'which)
  opAlist :=
      [x for x in htpProperty(htPage,'opAlist) | superMatch?(filter,DOWNCASE STRINGIMAGE first x)]
  htpSetProperty(htPage,'opAlist,opAlist)
  FUNCALL(functionToCall,htPage,nil)

--=======================================================================
--                  Get Constructor Documentation
--=======================================================================

dbConstructorDoc(conform,$op,$sig) == fn conform where
  fn (conform := [conname,:$args]) ==
    or/[gn y for y in GETDATABASE(conname,'DOCUMENTATION)]
  gn([op,:alist]) ==
    op = $op and or/[doc or '("") for [sig,:doc] in alist | hn sig]
  hn sig ==
    #$sig = #sig and $sig = SUBLISLIS($args,$FormalMapVariableList,sig)

dbDocTable conform ==
--assumes $docTableHash bound --see dbExpandOpAlistIfNecessary
  table := HGET($docTableHash,conform) => table
  $docTable : local := MAKE_-HASHTABLE 'ID
  --process in reverse order so that closest cover up farthest
  for x in originsInOrder conform repeat dbAddDocTable x
  dbAddDocTable conform
  HPUT($docTableHash,conform,$docTable)
  $docTable

originsInOrder conform ==  --domain = nil or set to live domain
--from dcCats
  [con,:argl] := conform
  GETDATABASE(con,'CONSTRUCTORKIND) = 'category =>
      ASSOCLEFT ancestorsOf(conform,nil)
  acc := ASSOCLEFT parentsOf con
  for x in acc repeat
    for y in originsInOrder x repeat acc := insert(y,acc)
  acc

dbAddDocTable conform ==
  conname := opOf conform
  storedArgs := rest getConstructorForm conname
  for [op,:alist] in SUBLISLIS(["$",:rest conform],
    ["%",:storedArgs],GETDATABASE(opOf conform,'DOCUMENTATION))
      repeat
       op1 :=
         op = '(Zero) => 0
         op = '(One) => 1
         op
       for [sig,doc] in alist repeat
         HPUT($docTable,op1,[[conform,:alist],:HGET($docTable,op1)])
    --note opOf is needed!!! for some reason, One and Zero appear within prens

dbGetDocTable(op,$sig,docTable,$which,aux) == main where
--docTable is [[origin,entry1,...,:code] ...] where
--  each entry is [sig,doc] and code is NIL or else a topic code for op
  main ==
    if null FIXP op and
      DIGITP (s := STRINGIMAGE op).0 then op := string2Integer s
    -- the above hack should be removed after 3/94 when 0 is not |0|
    aux is [[packageName,:.],:pred] =>
      doc := dbConstructorDoc(first aux,$op,$sig)
      origin :=
        pred => ['ifp,:aux]
        first aux
      [origin,:doc]
    or/[gn x for x in HGET(docTable,op)]
  gn u ==  --u is [origin,entry1,...,:code]
    $conform := CAR u              --origin
    if ATOM $conform then $conform := [$conform]
    code     := LASTATOM u         --optional topic code
    comments := or/[p for entry in CDR u | p := hn entry] or return nil
    [$conform,first comments,:code]
  hn [sig,:doc] ==
    $which = '"attribute" => sig is ['attribute,: =$sig] and doc
    pred := #$sig = #sig and
      alteredSig := SUBLISLIS(KDR $conform,$FormalMapVariableList,sig)
      alteredSig = $sig
    pred =>
      doc =>
        doc is ['constant,:r] => r
        doc
      '("")
    false

kTestPred n ==
  n = 0 => true
  $domain => testBitVector($predvec,n)
  simpHasPred $predvec.(n - 1)

dbAddChainDomain conform ==
  [name,:args] := conform
  $infovec := dbInfovec name or return nil  --exit for categories
  template := $infovec . 0
  null (form := template . 5) => nil
  dbSubConform(args,kFormatSlotDomain devaluate form)

dbSubConform(args,u) ==
  atom u =>
    (n := position(u,$FormalMapVariableList)) >= 0 => args . n
    u
  u is ['local,y] => dbSubConform(args,y)
  [dbSubConform(args,x) for x in u]

dbAddChain conform ==
  u := dbAddChainDomain conform =>
    atom u => nil
    [[u,:true],:dbAddChain u]
  nil

--=======================================================================
--                Constructor Page Menu
--=======================================================================
---------> !OBSELETE! <-------------
dbPresentCons(htPage,kind,:exclusions) ==  -- calist is ((catform . pred)...)
  $saturn => dbPresentConsSaturn(htPage,kind,exclusions)
  htSay('"{\em Views:}")
  htpSetProperty(htPage,'exclusion,first exclusions)
  cAlist := htpProperty(htPage,'cAlist)
  empty? := null cAlist
  exposedUnexposedFlag := $includeUnexposed? --used to be star?       4/92
  star?  := true     --always include information on exposed/unexposed   4/92
  htSayStandard(if star? then '"\tab{13}" else '"\tab{9}")
  if empty? or MEMBER('names,exclusions)
    then htSay '"{\em names}"
    else htMakePage [['bcLispLinks,['"names",'"",'dbShowCons,'names]]]
  htSayStandard(if star? then '"\tab{21}" else '"\tab{17}")
  if empty? or MEMBER('kinds,exclusions) or kind ^= 'constructor
    then htSay '"{\em kinds}"
    else htMakePage [['bcLispLinks,['"kinds",'"",'dbShowCons,'kinds]]]
  htSayStandard(if star? then '"\tab{29}" else '"\tab{25}")
  if empty? or MEMBER('parameters,exclusions) or not or/[CDAR x for x in cAlist]
    then htSay '"{\em parameters}"
    else htMakePage [['bcLispLinks,['"parameters",'"",'dbShowCons,'parameters]]]
  if star? then htSayStandard('"\tab{42}") else htSayStandard('"\tab{38}")
  if empty? or null CDR cAlist
    then htSay '"{\em filter}"
    else htMakePage [['bcLinks,['"filter",'"",'dbShowCons,'filter]]]
  htMakePage [['bcStrings, [11,'"",'filter,'EM]]]
  htSay('"\newline")
  if exposedUnexposedFlag then
    if $exposedOnlyIfTrue then
      htMakePage [['bcLinks,['"exposed",'" {\em only}",'dbShowCons,'exposureOff]]]
    else
      htSay('"*{\em =}")
      htMakePage [['bcLinks,['"unexposed",'"",'dbShowCons,'exposureOn]]]
  htSayStandard(if star? then '"\tab{13}" else '"\tab{9}")
  if empty? or MEMBER('abbrs,exclusions)
    then htSay '"{\em abbrs}"
    else htMakePage [['bcLispLinks,['"abbrs",'"",'dbShowCons,'abbrs]]]
  htSayStandard(if star? then '"\tab{21}" else '"\tab{17}")
  if empty? or MEMBER('files,exclusions)
    then htSay '"{\em files}"
    else htMakePage [['bcLispLinks,['"files",'"",'dbShowCons,'files]]]
  htSayStandard(if star? then '"\tab{29}" else '"\tab{25}")
  if empty? or MEMBER('conditions,exclusions) or and/[CDR x = true for x in cAlist]
    then htSay '"{\em conditions}"
    else htMakePage [['bcLispLinks,['"conditions",'"",'dbShowCons,'conditions]]]
  if star? then htSayStandard('"\tab{42}") else htSayStandard('"\tab{38}")
  if empty? or MEMBER('documentation,exclusions)
    then htSay '"{\em descriptions}"
    else htMakePage [['bcLispLinks,['"descriptions",'"",'dbShowCons,'documentation]]]

dbShowCons(htPage,key,:options) ==
  cAlist  := htpProperty(htPage,'cAlist)
  key = 'filter =>
    --if $saturn, IFCAR options is the filter string
    filter := pmTransFilter(IFCAR options or dbGetInputString htPage)
    filter is ['error,:.] => bcErrorPage filter
    abbrev? := htpProperty(htPage,'exclusion) = 'abbrs
    u := [x for x in cAlist | test] where test ==
      conname := CAAR x
      subject := (abbrev? => constructor? conname; conname)
      superMatch?(filter,DOWNCASE STRINGIMAGE subject)
    null u => emptySearchPage('"constructor",filter)
    htPage := htInitPageNoScroll(htCopyProplist htPage)
    htpSetProperty(htPage,'cAlist,u)
    dbShowCons(htPage,htpProperty(htPage,'exclusion))
  if MEMQ(key,'(exposureOn exposureOff)) then
    $exposedOnlyIfTrue :=
      key = 'exposureOn => 'T
      NIL
    key := htpProperty(htPage,'exclusion)
  dbShowCons1(htPage,cAlist,key)

conPageChoose conname ==
  cAlist := [[getConstructorForm conname,:true]]
  dbShowCons1(nil,cAlist,'names)

dbShowCons1(htPage,cAlist,key) ==
  conlist := REMDUP [item for x in cAlist | pred] where
    pred ==
      item := CAR x
      $exposedOnlyIfTrue => isExposedConstructor opOf item
      item
--$searchFirstTime and (conlist is [.]) => conPage first conlist
--$searchFirstTime := false
  conlist is [.] => conPage
    htPage and htpProperty(htPage,'domname) => first conlist
    opOf first conlist
  conlist := [opOf x for x in conlist]
  kinds := "UNION"/[dbConstructorKind x for x in conlist]
  kind :=
    kinds is [a] => a
    'constructor
  proplist :=
    htPage => htCopyProplist htPage
    nil
  page := htInitPageNoScroll(proplist,dbConsHeading(htPage,conlist,key,kind))
  if u := htpProperty(page,'specialMessage) then APPLY(first u,rest u)
  htSayStandard('"\beginscroll ")
  htpSetProperty(page,'cAlist,cAlist)
  $conformsAreDomains: local := htpProperty(page,'domname)
  do
  --key = 'catfilter => dbShowCatFilter(page,key)
    key = 'names => bcNameConTable conlist
    key = 'abbrs =>
      bcAbbTable [getCDTEntry(con,true) for con in conlist]
    key = 'files =>
      flist :=
        [y for con in conlist |
          y := (fn := GETDATABASE(con,'SOURCEFILE))]
      bcUnixTable(listSort(function GLESSEQP,REMDUP flist))
    key = 'documentation   => dbShowConsDoc(page,conlist)
    if $exposedOnlyIfTrue then
      cAlist := [x for x in cAlist | isExposedConstructor opOf CAR x]
    key = 'conditions =>     dbShowConditions(page,cAlist,kind)
    key = 'parameters => bcConTable REMDUP ASSOCLEFT cAlist
    key = 'kinds => dbShowConsKinds cAlist
  dbConsExposureMessage()
  htSayStandard("\endscroll ")
  dbPresentCons(page,kind,key)
  htShowPageNoScroll()


dbConsExposureMessage() ==
  $atLeastOneUnexposed =>
      htSay '"\newline{}-------------\newline{}{\em *} = unexposed"

-- DUPLICATE DEF - ALSO in br-saturn.boot
-- dbShowConsKinds cAlist ==
-- ---------> !OBSELETE! <-------------
--  cats := doms := paks := defs := nil
--  for x in cAlist repeat
--    op := CAAR x
--    kind := dbConstructorKind op
--    kind  = 'category => cats := [x,:cats]
--    kind = 'domain    => doms := [x,:doms]
--    kind = 'package   => paks:= [x,:paks]
--    defs := [x,:defs]
--  lists := [NREVERSE cats,NREVERSE doms,NREVERSE paks,NREVERSE defs]
--  htBeginMenu(2)
--  htSayStandard '"\indent{1}"
--  kinds := +/[1 for x in lists | #x > 0]
--  for kind in '("category" "domain" "package" "default package") for x in lists | #x > 0 repeat
--    htSay('"\item")
--    if kinds = 1 then htSay menuButton() else
--      htMakePage [['bcLinks,[menuButton(),'"",'dbShowConsKindsFilter,[kind,x]]]]
--    htSayStandard '"\tab{1}"
--    htSay  '"{\em "
--    htSay (c := #x)
--    htSay '" "
--    htSay (c > 1 => pluralize kind; kind)
--    htSay '":}"
--    bcConTable REMDUP [CAAR y for y in x]
--  htEndMenu(2)
--  htSay '"\indent{0}"

dbShowConsKindsFilter(htPage,[kind,cAlist]) ==
  htpSetProperty(htPage,'cAlist,cAlist)
  dbShowCons(htPage,htpProperty(htPage,'exclusion))

dbShowConsDoc(htPage,conlist) ==
  null rest conlist => dbShowConsDoc1(htPage,getConstructorForm opOf first conlist,nil)
  cAlist := htpProperty(htPage,'cAlist)
  --the following code is necessary to skip over duplicates on cAlist
  index := 0
  for x in REMDUP conlist repeat
  -- for x in conlist repeat
    dbShowConsDoc1(htPage,getConstructorForm x,i) where i ==
      while CAAAR cAlist ^= x repeat
        index := index + 1
        cAlist := rest cAlist
        null cAlist => systemError ()
      index

dbShowConsDoc1(htPage,conform,indexOrNil) ==
  [conname,:conargs] := conform
  MEMQ(conname,$Primitives) =>
    conname := htpProperty(htPage,'conname)
    [["constructor",["NIL",doc]],:.] := GET(conname,'documentation)
    sig := '((CATEGORY domain) (SetCategory) (SetCategory))
    displayDomainOp(htPage,'"constructor",conform,conname,sig,true,doc,indexOrNil,'dbSelectCon,nil,nil)
  exposeFlag := isExposedConstructor conname
  doc := [getConstructorDocumentation conname]
  signature := getConstructorSignature conname
  sig :=
    GETDATABASE(conname,'CONSTRUCTORKIND) = 'category =>
      SUBLISLIS(conargs,$TriangleVariableList,signature)
    sublisFormal(conargs,signature)
  htSaySaturn '"\begin{description}"
  displayDomainOp(htPage,'"constructor",conform,conname,sig,true,doc,indexOrNil,'dbSelectCon,null exposeFlag,nil)
  htSaySaturn '"\end{description}"
  --NOTE that we pass conform is as "origin"

getConstructorDocumentation conname ==
  LASSOC('constructor,GETDATABASE(conname,'DOCUMENTATION))
    is [[nil,line,:.],:.] and line or '""

dbSelectCon(htPage,which,index) ==
  conPage opOf first htpProperty(htPage,'cAlist) . index

dbShowConditions(htPage,cAlist,kind) ==
  conform := htpProperty(htPage,'conform)
  conname := opOf conform
  article := htpProperty(htPage,'article)
  whichever := htpProperty(htPage,'whichever)
  [consNoPred,:consPred] := splitConTable cAlist
  singular := [kind,'" is"]
  plural   := [pluralize STRINGIMAGE kind,'" are"]
  dbSayItems(#consNoPred,singular,plural,'" unconditional")
  htSaySaturn '"\\"
  bcConPredTable(consNoPred,conname)
  htSayHrule()
  dbSayItems(#consPred,singular,plural,'" conditional")
  htSaySaturn '"\\"
  bcConPredTable(consPred,conname)

dbConsHeading(htPage,conlist,view,kind) ==
  thing := htPage and htpProperty(htPage,'thing) or '"constructor"
  place :=
    htPage => htpProperty(htPage,'domname) or htpProperty(htPage,'conform)
    nil
  count := #(REMDUP conlist)
  -- count := #conlist
  thing = '"benefactor" =>
    [STRINGIMAGE count,'" Constructors Used by ",form2HtString(place,nil,true)]
  modifier :=
    thing = '"argument" =>
      rank := htPage and htpProperty(htPage,'rank)
      ['" Possible ",rank,'" "]
    kind = 'constructor => ['" "]
    ['" ",capitalize STRINGIMAGE kind,'" "]
--  count = 1 =>
--    ['"Select name or a {\em view} at the bottom"]
  exposureWord :=
    $exposedOnlyIfTrue => '(" Exposed ")
    nil
  prefix :=
    count = 1 => [STRINGIMAGE count,:modifier,capitalize thing]
    firstWord := (count = 0 => '"No "; STRINGIMAGE count)
    [firstWord,:exposureWord, :modifier,capitalize pluralize thing]
  placepart :=
    place => ['" of {\em ",form2HtString(place,nil,true),"}"]
    nil
  heading := [:prefix,:placepart]
  connective :=
    MEMBER(view,'(abbrs files kinds)) => '" as "
    '" with "
  if count ^= 0 and MEMBER(view,'(abbrs files parameters conditions)) then heading:= [:heading,'" viewed",connective,'"{\em ",STRINGIMAGE view,'"}"]
  heading

dbShowConstructorLines lines ==
  cAlist := [[getConstructorForm intern dbName line,:true] for line in lines]
  dbShowCons1(nil,listSort(function GLESSEQP,cAlist),'names)

bcUnixTable(u) ==
  htSay '"\newline"
  htBeginTable()
  firstTime := true
  for x in u repeat
    if firstTime then firstTime := false
    else htSaySaturn '"&"
    htSay '"{"
    ft :=
      isAsharpFileName? x => '("AS")
      '("SPAD")
    filename := NAMESTRING $FINDFILE(STRINGIMAGE x, ft)
    htMakePage [['text, '"\unixcommand{",PATHNAME_-NAME x, '"}{$AXIOM/lib/SPADEDIT ", filename, '"} "]]
    htSay '"}"
  htEndTable()

isAsharpFileName? con == false

--=======================================================================
--             Special Code for Union, Mapping, and Record
--=======================================================================

dbSpecialDescription(conname) ==
  conform := getConstructorForm conname
  heading := ['"Description of Domain {\sf ",form2HtString conform,'"}"]
  page := htInitPage(heading,nil)
  htpSetProperty(page,'conname,conname)
  $conformsAreDomains := nil
  dbShowConsDoc1(page,conform,nil)
  htShowPage()

dbSpecialOperations(conname) ==
  page := htInitPage(nil,nil)
  conform := getConstructorForm conname
  opAlist := dbSpecialExpandIfNecessary(conform,rest GET(conname,'documentation))
  fromHeading := ['" from domain {\sf ",form2HtString conform,'"}"]
  htpSetProperty(page,'fromHeading,fromHeading)
  htpSetProperty(page,'conform,conform)
  htpSetProperty(page,'opAlist,opAlist)
  htpSetProperty(page,'noUsage,true)
  htpSetProperty(page,'condition?,'no)
  dbShowOp1(page,opAlist,'"operation",'names)

dbSpecialExports(conname) ==
  conform := getConstructorForm conname
  page := htInitPage(['"Exports of {\sf ",form2HtString conform,'"}"],nil)
  opAlist := dbSpecialExpandIfNecessary(conform,rest GET(conname,'documentation))
  kePageDisplay(page,'"operation",opAlist)
  htShowPage()

dbSpecialExpandIfNecessary(conform,opAlist) ==
  opAlist is [[op,[sig,:r],:.],:.] and rest r => opAlist
  for [op,:u] in opAlist repeat
    for pair in u repeat
      [sig,comments] := pair
      RPLACD(pair,['T,conform,'T,comments]) --[sig,pred,origin,exposeFg,doc]
  opAlist

X := '"{\sf Record(a:A,b:B)} is used to create the class of pairs of objects made up of a value of type {\em A} selected by the symbol {\em a} and a value of type {\em B} selected by the symbol {\em b}. "

Y := '"In general, the {\sf Record} constructor can take any number of arguments and thus can be used to create aggregates of heterogeneous components of arbitrary size selectable by name. "

Z := '"{\sf Record} is a primitive domain of \Language{} which cannot be defined in the \Language{} language."

MESSAGE := STRCONC(X,Y,Z)

PUT('Record,'documentation,SUBST(MESSAGE,'MESSAGE,'(
  (constructor (NIL MESSAGE))
 (_=  (((Boolean) _$ _$)
   "\spad{r = s} tests for equality of two records \spad{r} and \spad{s}"))
 (coerce (((OutputForm) _$)
   "\spad{coerce(r)} returns an representation of \spad{r} as an output form")
         ((_$ (List (Any)))
   "\spad{coerce(u)}, where \spad{u} is the list \spad{[x,y]} for \spad{x} of type \spad{A} and \spad{y} of type \spad{B}, returns the record \spad{[a:x,b:y]}"))
 (elt ((A $ "a")
   "\spad{r . a} returns the value stored in record \spad{r} under selector \spad{a}.")
      ((B $ "b")
   "\spad{r . b} returns the value stored in record \spad{r} under selector \spad{b}."))
 (setelt ((A $ "a" A)
   "\spad{r . a := x} destructively replaces the value stored in record \spad{r} under selector \spad{a} by the value of \spad{x}. Error: if \spad{r} has not been previously assigned a value.")
         ((B $ "b" B)
   "\spad{r . b := y} destructively replaces the value stored in record \spad{r} under selector \spad{b} by the value of \spad{y}. Error: if \spad{r} has not been previously assigned a value."))
   )))

X := '"{\sf Union(A,B)} denotes the class of objects which are which are either members of domain {\em A} or of domain {\em B}. The {\sf Union} constructor can take any number of arguments. "

Y := '"For an alternate form of {\sf Union} with _"tags_", see \downlink{Union(a:A,b:B)}{DomainUnion}. {\sf Union} is a primitive domain of \Language{} which cannot be defined in the \Language{} language."

MESSAGE := STRCONC(X,Y)

PUT('UntaggedUnion,'documentation,SUBST(MESSAGE,'MESSAGE,'(
  (constructor (NIL MESSAGE))
  (_=  (((Boolean) $ $)
    "\spad{u = v} tests if two objects of the union are equal, that is, u and v are hold objects of same branch which are equal."))
  (case (((Boolean) $ "A")
    "\spad{u case A} tests if \spad{u} is of the type \spad{A} branch of the union.")
        (((Boolean) $ "B")
    "\spad{u case B} tests if \spad{u} is of the \spad{B} branch of the union."))
  (coerce ((A $)
    "\spad{coerce(u)} returns \spad{x} of type \spad{A} if \spad{x} is of the \spad{A} branch of the union. Error: if \spad{u} is of the \spad{B} branch of the union.")
          ((B $)
    "\spad{coerce(u)} returns \spad{x} of type \spad{B} if \spad{x} is of the \spad{B} branch of the union. Error: if \spad{u} is of the \spad{A} branch of the union.")
          (($ A)
    "\spad{coerce(x)}, where \spad{x} has type \spad{A}, returns \spad{x} as a union type.")
          (($ B)
    "\spad{coerce(y)}, where \spad{y} has type \spad{B}, returns \spad{y} as a union type."))
  )))

X := '"{\sf Union(a:A,b:B)} denotes the class of objects which are either members of domain {\em A} or of domain {\em B}. "

Y := '"The symbols {\em a} and {\em b} are called _"tags_" and are used to identify the two _"branches_" of the union. "

Z := '"The {\sf Union} constructor can take any number of arguments and has an alternate form without {\em tags} (see \downlink{Union(A,B)}{UntaggedUnion}). "

W := '"This tagged {\sf Union} type is necessary, for example, to disambiguate two branches of a union where {\em A} and {\em B} denote the same type. "

A := '"{\sf Union} is a primitive domain of \Language{} which cannot be defined in the \Language{} language."

MESSAGE := STRCONC(X,Y,Z,W,A)

PUT('Union,'documentation,SUBST(MESSAGE,'MESSAGE,'(
  (constructor (NIL MESSAGE))
  (_=  (((Boolean) $ $)
    "\spad{u = v} tests if two objects of the union are equal, that is, \spad{u} and \spad{v} are objects of same branch which are equal."))
  (case (((Boolean) $ "A")
    "\spad{u case a} tests if \spad{u} is of branch \spad{a} of the union.")
	        (((Boolean) $ "B")
    "\spad{u case b} tests if \spad{u} is of branch \spad{b} of the union."))
  (coerce ((A $)
    "\spad{coerce(u)} returns \spad{x} of type \spad{A} if \spad{x} is of branch \spad{a} of the union. Error: if \spad{u} is of branch \spad{b} of the union.")
          ((B $)
    "\spad{coerce(u)} returns \spad{x} of type \spad{B} if \spad{x} is of branch \spad{b} branch of the union. Error: if \spad{u} is of the \spad{a} branch of the union.")
          (($ A)
    "\spad{coerce(x)}, where \spad{x} has type \spad{A}, returns \spad{x} as a union type.")
          (($ B)
    "\spad{coerce(y)}, where \spad{y} has type \spad{B}, returns \spad{y} as a union type."))
  )))

X := '"{\sf Mapping(T,S,...)} denotes the class of objects which are mappings from a source domain ({\em S,...}) into a target domain {\em T}. The {\sf Mapping} constructor can take any number of arguments."

Y := '" All but the first argument is regarded as part of a source tuple for the mapping. For example, {\sf Mapping(T,A,B)} denotes the class of mappings from {\em (A,B)} into {\em T}. "

Z := '"{\sf Mapping} is a primitive domain of \Language{} which cannot be defined in the \Language{} language."

MESSAGE := STRCONC(X,Y,Z)

PUT('Mapping,'documentation, SUBST(MESSAGE,'MESSAGE,'(
  (constructor (NIL MESSAGE))
  (_=  (((Boolean) $ $)
    "\spad{u = v} tests if mapping objects are equal."))
   )))

X := '"{\em Enumeration(a1, a2 ,..., aN)} creates an object which is exactly one of the N symbols {\em a1}, {\em a2}, ..., or {\em aN}, N > 0. "

Y := '" The {\em Enumeration} can constructor can take any number of symbols as arguments."

MESSAGE := STRCONC(X, Y)

PUT('Enumeration, 'documentation, SUBST(MESSAGE, 'MESSAGE, '(
  (constructor (NIL MESSAGE))
  (_= (((Boolean) _$ _$)
    "\spad{e = f} tests for equality of two enumerations \spad{e} and \spad{f}"))
  (_^_= (((Boolean) _$ _$)
    "\spad{e ^= f} tests that two enumerations \spad{e} and \spad{f} are nont equal"))
  (coerce (((OutputForm) _$)
     "\spad{coerce(e)} returns a representation of enumeration \spad{r} as an output form")
          ((_$ (Symbol))
     "\spad{coerce(s)} converts a symbol \spad{s} into an enumeration which has \spad{s} as a member symbol"))
  )))


mkConArgSublis args ==
  [[arg,:INTERN digits2Names PNAME arg] for arg in args
     | (s := PNAME arg) and or/[DIGITP ELT(s,i) for i in 0..MAXINDEX s]]

digits2Names s ==
--This is necessary since arguments of conforms CANNOT have digits in TechExplorer
  str := '""
  for i in 0..MAXINDEX s repeat
    c := s.i
    segment :=
      n := DIGIT_-CHAR_-P c =>
        ('("Zero" "One" "Two" "Three" "Four" "Five" "Six" "Seven" "Eight" "Nine")).n
      c
    CONCAT(str, segment)
  str

lefts u ==
   [x for x in HKEYS  _*HASCATEGORY_-HASH_* | CDR x = u]



--====================> WAS b-data.boot <================================

--============================================================================
--              Build Library Database (libdb.text,...)
--============================================================================
--Formal for libdb.text:
--  constructors    Cname\#\I\sig \args   \abb \comments (C is C, D, P, X)
--  operations      Op  \#\E\sig \conname\pred\comments (E is one of U/E)
--  attributes      Aname\#\E\args\conname\pred\comments
--  I = <x if exposed><d if category with a default package>
buildLibdb(:options) ==  --called by make-databases (daase.lisp.pamphlet)
  domainList := IFCAR options  --build local libdb if list of domains is given
  $OpLst: local := nil
  $AttrLst: local := nil
  $DomLst : local := nil
  $CatLst : local := nil
  $PakLst : local := nil
  $DefLst : local := nil
  deleteFile '"temp.text"
  $outStream: local := MAKE_-OUTSTREAM '"temp.text"
  if null domainList then
    comments :=
      '"\spad{Union(A,B,...,C)} is a primitive type in AXIOM used to represent objects of type \spad{A} or of type \spad{B} or...or of type \spad{C}."
    writedb
      buildLibdbString ['"dUnion",1,'"x",'"special",'"(A,B,...,C)",'UNION,comments]
    comments :=
      '"\spad{Record(a:A,b:B,...,c:C)} is a primitive type in AXIOM used to represent composite objects made up of objects of type \spad{A}, \spad{B},..., \spad{C} which are indexed by _"keys_" (identifiers) \spad{a},\spad{b},...,\spad{c}."
    writedb
      buildLibdbString ['"dRecord",1,'"x",'"special",'"(a:A,b:B,...,c:C)",'RECORD,comments]
    comments :=
      '"\spad{Mapping(T,S)} is a primitive type in AXIOM used to represent mappings from source type \spad{S} to target type \spad{T}. Similarly, \spad{Mapping(T,A,B)} denotes a mapping from source type \spad{(A,B)} to target type \spad{T}."
    writedb
      buildLibdbString ['"dMapping",1,'"x",'"special",'"(T,S)",'MAPPING,comments]
    comments :=
      '"\spad{Enumeration(a,b,...,c)} is a primitive type in AXIOM used to represent the object composed of the symbols \spad{a},\spad{b},..., and \spad{c}."
    writedb
      buildLibdbString ['"dEnumeration",1,'"x",'"special",'"(a,b,...,c)",'ENUM,comments]
  $conname: local := nil
  $conform: local := nil
  $exposed?:local := nil
  $doc:     local := nil
  $kind:    local := nil
  constructorList := domainList or allConstructors()
  for con in constructorList repeat
    writedb buildLibdbConEntry con
    [attrlist,:oplist] := getConstructorExports $conform
    buildLibOps oplist
    buildLibAttrs attrlist
  SHUT $outStream
  domainList => 'done         --leave new database in temp.text
  OBEY
    $machineType = 'RIOS => '"sort -f -T /tmp -y200 _"temp.text_"  > _"libdb.text_""
    $machineType = 'SPARC => '"sort -f  _"temp.text_"  > _"libdb.text_""
    '"sort  _"temp.text_"  > _"libdb.text_""
  --OBEY '"mv libdb.text olibdb.text"
  RENAME_-FILE('"libdb.text", '"olibdb.text")
  deleteFile '"temp.text"

buildLibdbConEntry conname ==
    NULL GETDATABASE(conname, 'CONSTRUCTORMODEMAP) => nil
    abb:=GETDATABASE(conname,'ABBREVIATION)
    $conname := conname
    conform := GETDATABASE(conname,'CONSTRUCTORFORM) or [conname] --hack for Category,..
    $conform := dbMkForm SUBST('T,"T$",conform)
    null $conform => nil
    $exposed? := (isExposedConstructor conname => '"x"; '"n")
    $doc      := GETDATABASE(conname, 'DOCUMENTATION)
    pname := PNAME conname
    kind  := GETDATABASE(conname,'CONSTRUCTORKIND)
    if kind = 'domain
      and GETDATABASE(conname,'CONSTRUCTORMODEMAP) is [[.,t,:.],:.]
       and t is ['CATEGORY,'package,:.] then kind := 'package
    $kind :=
      pname.(MAXINDEX pname) = char '_& => 'x
      DOWNCASE (PNAME kind).0
    argl := rest $conform
    conComments :=
      LASSOC('constructor,$doc) is [[=nil,:r]] => libdbTrim concatWithBlanks r
      '""
    argpart:= SUBSTRING(form2HtString ['f,:argl],1,nil)
    sigpart:= libConstructorSig $conform
    header := STRCONC($kind,PNAME conname)
    buildLibdbString [header,#argl,$exposed?,sigpart,argpart,abb,conComments]

dbMkForm x == atom x and [x] or x

buildLibdbString [x,:u] ==
  STRCONC(STRINGIMAGE x,"STRCONC"/[STRCONC('"`",STRINGIMAGE y) for y in u])

libConstructorSig [conname,:argl] ==
  [[.,:sig],:.] := GETDATABASE(conname,'CONSTRUCTORMODEMAP)
  formals := TAKE(#argl,$FormalMapVariableList)
  sig := SUBLISLIS(formals,$TriangleVariableList,sig)
  keys := [g(f,sig,i) for f in formals for i in 1..] where
    g(x,u,i) ==  --does x appear in any but i-th element of u?
      or/[CONTAINED(x,y) for y in u for j in 1.. | j ^= i]
  sig := fn SUBLISLIS(argl,$FormalMapVariableList,sig) where
    fn x ==
      atom x => x
      x is ['Join,a,:r] => ['Join,fn a,'etc]
      x is ['CATEGORY,:.] => 'etc
      [fn y for y in x]
  sig := [first sig,:[(k => [":",a,s]; s)
            for a in argl for s in rest sig for k in keys]]
  sigpart:= form2LispString ['Mapping,:sig]
  if null ncParseFromString sigpart then
    sayBrightly ['"Won't parse: ",sigpart]
  sigpart

concatWithBlanks r ==
  r is [head,:tail] =>
    tail => STRCONC(head,'" ",concatWithBlanks tail)
    head
  '""

writedb(u) ==
  not STRINGP u => nil        --skip if not a string
  PRINTEXP(addPatchesToLongLines(u,500),$outStream)
  --positions for tick(1), dashes(2), and address(9), i.e. 12
  TERPRI $outStream

addPatchesToLongLines(s,n) ==
  #s > n => STRCONC(SUBSTRING(s,0,n),
              addPatchesToLongLines(STRCONC('"--",SUBSTRING(s,n,nil)),n))
  s

buildLibOps oplist == for [op,sig,:pred] in oplist repeat buildLibOp(op,sig,pred)

buildLibOp(op,sig,pred) ==
--operations      OKop  \#\sig \conname\pred\comments (K is U or C)
  nsig := SUBLISLIS(rest $conform,$FormalMapVariableList,sig)
  pred := SUBLISLIS(rest $conform,$FormalMapVariableList,pred)
  nsig := SUBST('T,"T$",nsig)   --this ancient artifact causes troubles!
  pred := SUBST('T,"T$",pred)
  sigpart:= form2LispString ['Mapping,:nsig]
  predString := (pred = 'T => '""; form2LispString pred)
  sop :=
    (s := STRINGIMAGE op) = '"One" => '"1"
    s = '"Zero" => '"0"
    s
  header := STRCONC('"o",sop)
  conform:= STRCONC($kind,form2LispString $conform)
  comments:= libdbTrim concatWithBlanks LASSOC(sig,LASSOC(op,$doc))
  checkCommentsForBraces('operation,sop,sigpart,comments)
  writedb
    buildLibdbString [header,# rest sig,$exposed?,sigpart,conform,predString,comments]

libdbTrim s ==
  k := MAXINDEX s
  k < 0 => s
  for i in 0..k repeat
    s.i = $Newline => SETELT(s,i,char '_ )
  trimString s

checkCommentsForBraces(kind,sop,sigpart,comments) ==
  count := 0
  for i in 0..MAXINDEX comments repeat
    c := comments.i
    c = char '_{ => count := count + 1
    c = char '_} =>
      count := count - 1
      count < 0 => missingLeft := true
  if count < 0 or missingLeft then
    tail :=
      kind = 'attribute => [sop,'"(",sigpart,'")"]
      [sop,'": ",sigpart]
    sayBrightly ['"(",$conname,'" documentation) missing left brace--> ",:tail]
  if count > 0 then
    sayBrightly ['"(",$conname,'" documentation) missing right brace--> ",:tail]
  if count ^= 0 or missingLeft then pp comments

buildLibAttrs attrlist ==
  for [name,argl,:pred] in attrlist repeat buildLibAttr(name,argl,pred)

buildLibAttr(name,argl,pred) ==
--attributes      AKname\#\args\conname\pred\comments (K is U or C)
  header := STRCONC('"a",STRINGIMAGE name)
  argPart:= SUBSTRING(form2LispString ['f,:argl],1,nil)
  pred := SUBLISLIS(rest $conform,$FormalMapVariableList,pred)
  predString := (pred = 'T => '""; form2LispString pred)
  header := STRCONC('"a",STRINGIMAGE name)
  conname := STRCONC($kind,form2LispString $conname)
  comments:= concatWithBlanks LASSOC(['attribute,:argl],LASSOC(name,$doc))
  checkCommentsForBraces('attribute,STRINGIMAGE name,argl,comments)
  writedb
    buildLibdbString [header,# argl,$exposed?,argPart,conname,predString,comments]

dbAugmentConstructorDataTable() ==
  instream := MAKE_-INSTREAM '"libdb.text"
  while not EOFP instream repeat
    fp   := FILE_-POSITION instream
    line := READLINE instream
    cname := INTERN dbName line
    entry := getCDTEntry(cname,true) =>  --skip over Mapping, Union, Record
       [name,abb,:.] := entry
       RPLACD(CDR entry,PUTALIST(CDDR entry,'dbLineNumber,fp))
--     if xname := constructorHasExamplePage entry then
--       RPLACD(CDR entry,PUTALIST(CDDR entry,'dbExampleFile,xname))
       args := IFCDR GETDATABASE(name,'CONSTRUCTORFORM)
       if args then RPLACD(CDR entry,PUTALIST(CDDR entry,'constructorArgs,args))
  'done

dbHasExamplePage conname ==
  sname    := STRINGIMAGE conname
  abb      := constructor? conname
  ucname   := UPCASE STRINGIMAGE abb
  pathname :=STRCONC(getEnv '"AXIOM",'"/doc/hypertex/pages/",ucname,'".ht")
  isExistingFile pathname => INTERN STRCONC(sname,'"XmpPage")
  nil

dbRead(n) ==
  instream := MAKE_-INSTREAM STRCONC(getEnv('"AXIOM"), '"/algebra/libdb.text")
  FILE_-POSITION(instream,n)
  line := READLINE instream
  SHUT instream
  line

dbReadComments(n) ==
  n = 0 => '""
  instream := MAKE_-INSTREAM STRCONC(getEnv('"AXIOM"),'"/algebra/comdb.text")
  FILE_-POSITION(instream,n)
  line := READLINE instream
  k := dbTickIndex(line,1,1)
  line := SUBSTRING(line,k + 1,nil)
  while not EOFP instream and (x := READLINE instream) and
    (k := MAXINDEX x) and (j := dbTickIndex(x,1,1)) and (j < k) and
      x.(j := j + 1) = char '_- and x.(j := j + 1) = char '_- repeat
        xtralines := [SUBSTRING(x,j + 1,nil),:xtralines]
  SHUT instream
  STRCONC(line, "STRCONC"/NREVERSE xtralines)

dbSplitLibdb() ==
  instream := MAKE_-INSTREAM  '"olibdb.text"
  outstream:= MAKE_-OUTSTREAM '"libdb.text"
  comstream:= MAKE_-OUTSTREAM '"comdb.text"
  PRINTEXP(0,    comstream)
  PRINTEXP($tick,comstream)
  PRINTEXP('"",  comstream)
  TERPRI(comstream)
  while not EOFP instream repeat
    line := READLINE instream
    outP := FILE_-POSITION outstream
    comP := FILE_-POSITION comstream
    [prefix,:comments] := dbSplit(line,6,1)
    PRINTEXP(prefix,outstream)
    PRINTEXP($tick ,outstream)
    null comments =>
      PRINTEXP(0,outstream)
      TERPRI(outstream)
    PRINTEXP(comP,outstream)
    TERPRI(outstream)
    PRINTEXP(outP  ,comstream)
    PRINTEXP($tick ,comstream)
    PRINTEXP(first comments,comstream)
    TERPRI(comstream)
    for c in rest comments repeat
      PRINTEXP(outP  ,comstream)
      PRINTEXP($tick ,comstream)
      PRINTEXP(c, comstream)
      TERPRI(comstream)
  SHUT instream
  SHUT outstream
  SHUT comstream
  OBEY '"rm olibdb.text"

dbSplit(line,n,k) ==
  k := charPosition($tick,line,k + 1)
  n = 1 => [SUBSTRING(line,0,k),:dbSpreadComments(SUBSTRING(line,k + 1,nil),0)]
  dbSplit(line,n - 1,k)

dbSpreadComments(line,n) ==
  line = '"" => nil
  k := charPosition(char '_-,line,n + 2)
  k >= MAXINDEX line => [SUBSTRING(line,n,nil)]
  line.(k + 1) ^= char '_- =>
    u := dbSpreadComments(line,k)
    [STRCONC(SUBSTRING(line,n,k - n),first u),:rest u]
  [SUBSTRING(line,n,k - n),:dbSpreadComments(SUBSTRING(line,k,nil),0)]

--============================================================================
--                  Build Glossary
--============================================================================
buildGloss() ==  --called by buildDatabase (database.boot)
--starting with gloss.text, build glosskey.text and glossdef.text
  $constructorName : local := nil
  $exposeFlag : local := true
  $outStream: local := MAKE_-OUTSTREAM '"temp.text"
  $x : local := nil
  $attribute? : local := true     --do not surround first word
  pathname := STRCONC(getEnv '"AXIOM",'"/algebra/gloss.text")
  instream := MAKE_-INSTREAM pathname
  keypath  := '"glosskey.text"
  OBEY STRCONC('"rm -f ",keypath)
  outstream:= MAKE_-OUTSTREAM keypath
  htpath   := '"gloss.ht"
  OBEY STRCONC('"rm -f ",htpath)
  htstream:= MAKE_-OUTSTREAM htpath
  defpath  := '"glossdef.text"
  defstream:= MAKE_-OUTSTREAM defpath
  pairs := getGlossLines instream
  PRINTEXP('"\begin{page}{GlossaryPage}{G l o s s a r y}\beginscroll\beginmenu",htstream)
  for [name,:line] in pairs repeat
    outP  := FILE_-POSITION outstream
    defP  := FILE_-POSITION defstream
    lines := spreadGlossText transformAndRecheckComments(name,[line])
    PRINTEXP(name, outstream)
    PRINTEXP($tick,outstream)
    PRINTEXP(defP, outstream)
    TERPRI(outstream)
--  PRINTEXP('"\item\newline{\em \menuitemstyle{}}\tab{0}{\em ",htstream)
    PRINTEXP('"\item\newline{\em \menuitemstyle{}}{\em ",htstream)
    PRINTEXP(name,        htstream)
    PRINTEXP('"}\space{}",htstream)
    TERPRI(htstream)
    for x in lines repeat
      PRINTEXP(outP, defstream)
      PRINTEXP($tick,defstream)
      PRINTEXP(x,    defstream)
      TERPRI defstream
    PRINTEXP("STRCONC"/lines,htstream)
    TERPRI htstream
  PRINTEXP('"\endmenu\endscroll",htstream)
  PRINTEXP('"\lispdownlink{Search}{(|htGloss| _"\stringvalue{pattern}_")} for glossary entry matching \inputstring{pattern}{24}{*}",htstream)
  PRINTEXP('"\end{page}",htstream)
  SHUT instream
  SHUT outstream
  SHUT defstream
  SHUT htstream
  SHUT $outStream

spreadGlossText(line) ==
--this function breaks up a line into chunks
--eventually long line is put into gloss.text as several chunks as follows:
----- key1`this is the first chunk
----- XXX`and this is the second
----- XXX`and this is the third
----- key2`and this is the fourth
--where XXX is the file position of key1
--this is because grepping will only pick up the first 512 characters
  line = '"" => nil
  MAXINDEX line > 500 => [SUBSTRING(line,0,500),:spreadGlossText(SUBSTRING(line,500,nil))]
  [line]

getGlossLines instream ==
--instream has text of the form:
----- key1`this is the first line
----- and this is the second
----- key2'and this is the third
--result is
----- key1'this is the first line and this is the second
----- key2'and this is the third
  keys := nil
  text := nil
  lastLineHadTick := false
  while not EOFP instream repeat
    line := READLINE instream
    #line = 0 => 'skip
    n := charPosition($tick,line,0)
    last := IFCAR text
    n > MAXINDEX line =>  --this line is continuation of previous line; concat it
      fill :=
        #last = 0 =>
          lastLineHadTick => '""
          '"\blankline "
        #last > 0 and last.(MAXINDEX last) ^= $charBlank => $charBlank
        '""
      lastLineHadTick := false
      text := [STRCONC(last,fill,line),:rest text]
    lastLineHadTick := true
    keys := [SUBSTRING(line,0,n),:keys]
    text := [SUBSTRING(line,n + 1,nil),:text]
  ASSOCRIGHT listSort(function GLESSEQP,[[DOWNCASE key,key,:def] for key in keys for def in text])
  --this complication sorts them after lower casing the keys

--============================================================================
--                  Build Users HashTable
-- This database is written out as users.database (database.boot) 
-- and read using function getUsersOfConstructor. See functions 
-- whoUses and kcuPage in browser.
--============================================================================
mkUsersHashTable() ==  --called by make-databases (daase.lisp.pamphlet)
  $usersTb := MAKE_-HASH_-TABLE()
  for x in allConstructors() repeat
    for conform in getImports x repeat
      name := opOf conform
      if not MEMQ(name,'(QUOTE)) then
        HPUT($usersTb,name,insert(x,HGET($usersTb,name)))
  for k in HKEYS $usersTb repeat
    HPUT($usersTb,k,listSort(function GLESSEQP,HGET($usersTb,k)))
  for x in allConstructors() | isDefaultPackageName x repeat
    HPUT($usersTb,x,getDefaultPackageClients x)
  $usersTb

getDefaultPackageClients con ==  --called by mkUsersHashTable
  catname := INTERN SUBSTRING(s := PNAME con,0,MAXINDEX s)
  for [catAncestor,:.] in childrenOf([catname]) repeat
    pakname := INTERN STRCONC(PNAME catAncestor,'"&")
    if getCDTEntry(pakname,true) then acc := [pakname,:acc]
    acc := UNION([CAAR x for x in domainsOf([catAncestor],nil)],acc)
  listSort(function GLESSEQP,acc)

--============================================================================
--               Build Dependents Hashtable
-- This hashtable is written out by database.boot as dependents.DATABASE
-- and read back in by getDependentsOfConstructor (see daase.lisp)
-- This information is used by function kcdePage when a user asks for the
-- dependents of a constructor.
--============================================================================
mkDependentsHashTable() == --called by make-databases (daase.lisp.pamphlet)
  $depTb := MAKE_-HASH_-TABLE()
  for nam in allConstructors() repeat
    for con in getArgumentConstructors nam repeat
      HPUT($depTb,con,[nam,:HGET($depTb,con)])
  for k in HKEYS $depTb repeat
    HPUT($depTb,k,listSort(function GLESSEQP,HGET($depTb,k)))
  $depTb

getArgumentConstructors con == --called by mkDependentsHashTable
  argtypes := IFCDR IFCAR getConstructorModemap con or return nil
  fn argtypes where
    fn(u) == "UNION"/[gn x for x in u]
    gn(x) ==
      atom x => nil
      x is ['Join,:r] => fn(r)
      x is ['CATEGORY,:.] => nil
      constructor? first x => [first x,:fn rest x]
      fn rest x

getImports conname == --called by mkUsersHashTable
  conform := GETDATABASE(conname,'CONSTRUCTORFORM)
  infovec := dbInfovec conname or return nil
  template := infovec.0
  u := [import(i,template)
          for i in 5..(MAXINDEX template) | test]  where
    test == template.i is [op,:.] and IDENTP op
              and not MEMQ(op,'(Mapping Union Record Enumeration CONS QUOTE local))
    import(x,template) ==
      x is [op,:args] =>
        op = 'QUOTE or op = 'NRTEVAL => CAR args
        op = 'local => first args
        op = 'Record =>
          ['Record,:[[":",CADR y,import(CADDR y,template)] for y in args]]

--TTT next three lines: handles some tagged/untagged Union case.
        op = 'Union=>
          args is [['_:,:x1],:x2] =>
--          CAAR args = '_: => -- tagged!
               ['Union,:[[":",CADR y,import(CADDR y,template)] for y in args]]
          [op,:[import(y,template) for y in args]]

        [op,:[import(y,template) for y in args]]
      INTEGERP x => import(template.x,template)
      x = '$ => '$
      x = "$$" => "$$"
      STRINGP x => x
      systemError '"bad argument in template"
  listSort(function GLESSEQP,SUBLISLIS(rest conform,$FormalMapVariableList,u))


--============================================================================
--                 Get Hierarchical Information
--============================================================================
getParentsFor(cname,formalParams,constructorCategory) ==
--called by compDefineFunctor1
  acc := nil
  formals := TAKE(#formalParams,$TriangleVariableList)
  constructorForm := GETDATABASE(cname, 'CONSTRUCTORFORM)
  for x in folks constructorCategory repeat
    x := SUBLISLIS(formalParams,formals,x)
    x := SUBLISLIS(IFCDR constructorForm,formalParams,x)
    x := SUBST('Type,'Object,x)
    acc := [:explodeIfs x,:acc]
  NREVERSE acc

parentsOf con == --called by kcpPage, ancestorsRecur
  if null BOUNDP '$parentsCache then SETQ($parentsCache,MAKE_-HASHTABLE 'ID)
  HGET($parentsCache,con) or
    parents := getParentsForDomain con
    HPUT($parentsCache,con,parents)
    parents

parentsOfForm [op,:argl] ==
  parents := parentsOf op
  null argl or argl = (newArgl := rest GETDATABASE(op,'CONSTRUCTORFORM)) =>
    parents
  SUBLISLIS(argl, newArgl, parents)

getParentsForDomain domname  == --called by parentsOf
  acc := nil
  for x in folks GETDATABASE(domname,'CONSTRUCTORCATEGORY) repeat
    x :=
      GETDATABASE(domname,'CONSTRUCTORKIND) = 'category =>
        sublisFormal(IFCDR getConstructorForm domname,x,$TriangleVariableList)
      sublisFormal(IFCDR getConstructorForm domname,x)
    acc := [:explodeIfs x,:acc]
  NREVERSE acc

explodeIfs x == main where  --called by getParents, getParentsForDomain
  main ==
    x is ['IF,p,a,b] => fn(p,a,b)
    [[x,:true]]
  fn(p,a,b) ==
    [:"append"/[gn(p,y) for y in a],:"append"/[gn(['NOT,p],y) for y in b]]
  gn(p,a) ==
    a is ['IF,q,b,:.] => fn(MKPF([p,q],'AND),b,nil)
    [[a,:p]]

folks u == --called by getParents and getParentsForDomain
  atom u => nil
  u is [op,:v] and MEMQ(op,'(Join PROGN))
    or u is ['CATEGORY,a,:v] => "append"/[folks x for x in v]
  u is ['SIGNATURE,:.] => nil
  u is ['TYPE,:.] => nil
  u is ['ATTRIBUTE,a] =>
    PAIRP a and constructor? opOf a => folks a
    nil
  u is ['IF,p,q,r] =>
    q1 := folks q
    r1 := folks r
    q1 or r1 => [['IF,p,q1,r1]]
    nil
  [u]

descendantsOf(conform,domform) ==  --called by kcdPage
  'category = GETDATABASE((conname := opOf conform),'CONSTRUCTORKIND) =>
    cats := catsOf(conform,domform)
    [op,:argl] := conform
    null argl or argl = (newArgl := rest (GETDATABASE(op,'CONSTRUCTORFORM)))
        => cats
    SUBLISLIS(argl, newArgl, cats)
  'notAvailable

childrenOf conform ==
  [pair for pair in descendantsOf(conform,nil) |
    childAssoc(conform,parentsOfForm first pair)]

childAssoc(form,alist) ==
  null (argl := CDR form) => ASSOC(form,alist)
  u := assocCar(opOf form, alist) => childArgCheck(argl,rest CAR u) and u
  nil

assocCar(x, al) == or/[pair for pair in al | x = CAAR pair]

childArgCheck(argl, nargl) ==
  and/[fn for x in argl for y in nargl for i in 0..] where
    fn ==
      x = y or constructor? opOf y => true
      isSharpVar y => i = POSN1(y, $FormalMapVariableList)
      false

--computeDescendantsOf cat ==
--dynamically generates descendants
--  hash := MAKE_-HASHTABLE 'UEQUAL
--  for [child,:pred] in childrenOf cat repeat
--    childForm := getConstructorForm child
--    HPUT(hash,childForm,pred)
--    for [form,:pred] in descendantsOf(childForm,nil) repeat
--      newPred :=
--        oldPred := HGET(hash,form) => quickOr(oldPred,pred)
--        pred
--      HPUT(hash,form,newPred)
--  mySort [[key,:HGET(hash,key)] for key in HKEYS hash]

ancestorsOf(conform,domform) ==  --called by kcaPage, originsInOrder,...
  'category = GETDATABASE((conname := opOf conform),'CONSTRUCTORKIND) =>
       alist := GETDATABASE(conname,'ANCESTORS)
       argl := IFCDR domform or IFCDR conform
       [pair for [a,:b] in alist | pair] where pair ==
         left :=  sublisFormal(argl,a)
         right := sublisFormal(argl,b)
         if domform then right := simpHasPred right
         null right => false
         [left,:right]
  computeAncestorsOf(conform,domform)

computeAncestorsOf(conform,domform) ==
  $done: local := MAKE_-HASHTABLE 'UEQUAL
  $if:   local := MAKE_-HASHTABLE 'ID
  ancestorsRecur(conform,domform,true,true)
  acc := nil
  for op in listSort(function GLESSEQP,HKEYS $if) repeat
    for pair in HGET($if,op) repeat acc := [pair,:acc]
  NREVERSE acc

ancestorsRecur(conform,domform,pred,firstTime?) == --called by ancestorsOf
  op      := opOf conform
  pred = HGET($done,conform) => nil   --skip if already processed
  parents :=
    firstTime? and ($insideCategoryIfTrue or $insideFunctorIfTrue) =>
      $lisplibParents
    parentsOf op
  originalConform :=
    firstTime? and ($insideCategoryIfTrue or $insideFunctorIfTrue) => $form
    getConstructorForm op
  if conform ^= originalConform then
    parents := SUBLISLIS(IFCDR conform,IFCDR originalConform,parents)
  for [newform,:p] in parents repeat
    if domform and rest domform then
      newdomform := SUBLISLIS(rest domform,rest conform,newform)
      p          := SUBLISLIS(rest domform,rest conform,p)
    newPred := quickAnd(pred,p)
    ancestorsAdd(simpHasPred newPred,newdomform or newform)
    ancestorsRecur(newform,newdomform,newPred,false)
  HPUT($done,conform,pred)                  --mark as already processed

ancestorsAdd(pred,form) == --called by ancestorsRecur
  null pred => nil
  op := IFCAR form or form
  alist := HGET($if,op)
  existingNode := ASSOC(form,alist) =>
    RPLACD(existingNode,quickOr(CDR existingNode,pred))
  HPUT($if,op,[[form,:pred],:alist])

domainsOf(conform,domname,:options) ==
  $hasArgList := IFCAR options
  conname := opOf conform
  u := [key for key in HKEYS _*HASCATEGORY_-HASH_*
    | key is [anc,: =conname]]
  --u is list of pairs (a . b) where b = conname
  --we sort u then replace each b by the predicate for which this is true
  s := listSort(function GLESSEQP,COPY u)
  s := [[CAR pair,:GETDATABASE(pair,'HASCATEGORY)] for pair in s]
  transKCatAlist(conform,domname,listSort(function GLESSEQP,s))

catsOf(conform,domname,:options) ==
  $hasArgList := IFCAR options
  conname := opOf conform
  alist := nil
  for key in allConstructors() repeat
    for item in GETDATABASE(key,'ANCESTORS) | conname = CAAR item repeat
      [[op,:args],:pred] := item
      newItem :=
        args => [[args,:pred],:LASSOC(key,alist)]
        pred
      alist := insertShortAlist(key,newItem,alist)
  transKCatAlist(conform,domname,listSort(function GLESSEQP,alist))

transKCatAlist(conform,domname,s) == main where
  main ==
    domname => --accept only exact matches after substitution
      domargs := rest domname
      acc := nil
      rest conform =>
        for pair in s repeat --pair has form [con,[conargs,:pred],...]]
          leftForm := getConstructorForm CAR pair
          for (ap := [args,:pred]) in CDR pair repeat
            match? :=
              domargs = args => true
              HAS__SHARP__VAR args => domargs = sublisFormal(KDR domname,args)
              nil
            null match? => 'skip
            npred := sublisFormal(KDR leftForm,pred)
            acc := [[leftForm,:npred],:acc]
        NREVERSE acc
      --conform has no arguments so each pair has form [con,:pred]
      for pair in s repeat
        leftForm := getConstructorForm CAR pair or systemError nil
        RPLACA(pair,leftForm)
        RPLACD(pair,sublisFormal(KDR leftForm,CDR pair))
      s
    --no domname, so look for special argument combinations
    acc := nil
    KDR conform =>
      farglist := TAKE(#rest conform,$FormalMapVariableList)
      for pair in s repeat --pair has form [con,[conargs,:pred],...]]
        leftForm := getConstructorForm CAR pair
        for (ap := [args,:pred]) in CDR pair repeat
          hasArgsForm? := args ^= farglist
          npred := sublisFormal(KDR leftForm,pred)
          if hasArgsForm? then
            subargs := sublisFormal(KDR leftForm,args)
            hpred :=
--            $hasArgsList => mkHasArgsPred subargs
              ['hasArgs,:subargs]
            npred := quickAnd(hpred,npred)
          acc := [[leftForm,:npred],:acc]
      NREVERSE acc
    for pair in s repeat --pair has form [con,:pred]
      leftForm := getConstructorForm CAR pair
      RPLACA(pair,leftForm)
      RPLACD(pair,sublisFormal(KDR leftForm,CDR pair))
    s

mkHasArgsPred subargs ==
--$hasArgsList gives arguments of original constructor,e.g. LODO(A,M)
--M is required to be Join(B,...); in looking for the domains of B
--  we can find that if B has special value C, it can
  systemError subargs

sublisFormal(args,exp,:options) == main where
  main ==  --use only on LIST structures; see also sublisFormalAlist
    $formals: local := IFCAR options or $FormalMapVariableList
    null args => exp
    sublisFormal1(args,exp,#args - 1)
  sublisFormal1(args,x,n) ==    --[sublisFormal1(args,y) for y in x]
    x is [.,:.] =>
      acc := nil
      y := x
      while null atom y repeat
        acc := [sublisFormal1(args,QCAR y,n),:acc]
        y := QCDR y
      r := NREVERSE acc
      if y then
        nd := LASTNODE r
        RPLACD(nd,sublisFormal1(args,y,n))
      r
    IDENTP x =>
      j := or/[i for f in $formals for i in 0..n | EQ(f,x)] =>
          args.j
      x
    x

--=======================================================================
--            Build Table of Lower Case Constructor Names
--=======================================================================

buildDefaultPackageNamesHT() ==
  $defaultPackageNamesHT := MAKE_-HASH_-TABLE()
  for nam in allConstructors() | isDefaultPackageName nam repeat
    HPUT($defaultPackageNamesHT,nam,true)
  $defaultPackageNamesHT

$defaultPackageNamesHT := buildDefaultPackageNamesHT()

--=======================================================================
--            Code for Private Libdbs
--=======================================================================
-- $createLocalLibDb := false

extendLocalLibdb conlist ==   --  called by astran
  not $createLocalLibDb => nil
  null conlist => nil
  buildLibdb conlist          --> puts datafile into temp.text
  $newConstructorList := UNION(conlist, $newConstructorList)
  localLibdb := '"libdb.text"
  not PROBE_-FILE '"libdb.text" =>
    RENAME_-FILE('"temp.text",'"libdb.text")
  oldlines := purgeNewConstructorLines(dbReadLines localLibdb, conlist)
  newlines := dbReadLines '"temp.text"
  dbWriteLines(MSORT UNION(oldlines,newlines), '"libdb.text")
  deleteFile '"temp.text"

purgeLocalLibdb() ==   --used for debugging purposes only
  $newConstructorList := nil
  obey '"rm libdb.text"


$returnNowhereFromGoGet := false

showSummary dom ==
  showPredicates dom
  showAttributes dom
  showFrom dom
  showImp dom

--=======================================================================
--          Show Where Functions in Domain are Implemented
--=======================================================================
showImp(dom,:options) ==
  sayBrightly '"-------------Operation summary-----------------"
  missingOnlyFlag := KAR options
  domainForm := devaluate dom
  [nam,:$domainArgs] := domainForm
  $predicateList: local := GETDATABASE(nam,'PREDICATES)
  predVector := dom.3
  u := getDomainOpTable(dom,true)
  --sort into 4 groups: domain exports, unexports, default exports, others
  for (x := [.,.,:key]) in u repeat
    key = domainForm => domexports := [x,:domexports]
    FIXP key => unexports := [x,:unexports]
    isDefaultPackageForm? key => defexports := [x,:defexports]
    key = 'nowhere => nowheres := [x,:nowheres]
    key = 'constant => constants := [x,:constants]
    others := [x,:others]   --add chain domains go here
  sayBrightly
    nowheres => ['"Functions exported but not implemented by",
      :bright form2String domainForm,'":"] 
    [:bright form2String domainForm,'"implements all exported operations"]  
  showDomainsOp1(nowheres,'nowhere)
  missingOnlyFlag => 'done

  --first display those exported by the domain, then add chain guys
  u := [:domexports,:constants,:SORTBY('CDDR,others)]
  while u repeat
    [.,.,:key] := CAR u
    sayBrightly
      key = 'constant => 
        ["Constants implemented by",:bright form2String key,'":"]
      ["Functions implemented by",:bright form2String key,'":"]
    u := showDomainsOp1(u,key)
  u := SORTBY('CDDR,defexports)
  while u repeat
    [.,.,:key] := CAR u
    defop := INTERN(SUBSTRING((s := PNAME CAR key),0,MAXINDEX s))
    domainForm := [defop,:CDDR key]
    sayBrightly ["Default functions from",:bright form2String domainForm,'":"]
    u := showDomainsOp1(u,key)
  u := SORTBY('CDDR,unexports)
  while u repeat
    [.,.,:key] := CAR u
    sayBrightly ["Not exported: "]
    u := showDomainsOp1(u,key)

--=======================================================================
--          Show Information Directly From Domains
--=======================================================================
showFrom(D,:option) ==
  ops := KAR option
  alist := nil
  domainForm := devaluate D
  [nam,:.] := domainForm
  $predicateList: local := GETDATABASE(nam,'PREDICATES)
  for (opSig := [op,sig]) in getDomainSigs1(D,ops) repeat
    u := from?(D,op,sig)
    x := ASSOC(u,alist) => RPLACD(x,[opSig,:rest x])
    alist := [[u,opSig],:alist]
  for [conform,:l] in alist repeat
    sayBrightly concat('"From ",form2String conform,'":")
    for [op,sig] in l repeat sayBrightly ['"   ",:formatOpSignature(op,sig)]
 
--=======================================================================
--               Functions implementing showFrom
--=======================================================================
getDomainOps D ==
  domname := D.0
  conname := CAR domname
  $predicateList: local := GETDATABASE(conname,'PREDICATES)
  REMDUP listSort(function GLESSEQP,ASSOCLEFT getDomainOpTable(D,nil))
 
getDomainSigs(D,:option) ==
  domname := D.0
  conname := CAR domname
  $predicateList: local := GETDATABASE(conname,'PREDICATES)
  getDomainSigs1(D,first option)
  
getDomainSigs1(D,ops) == listSort(function GLESSEQP,u) where
  u == [x for x in getDomainOpTable(D,nil) | null ops or MEMQ(CAR x,ops)]
 
getDomainDocs(D,:option) ==
  domname := D.0
  conname := CAR domname
  $predicateList: local := GETDATABASE(conname,'PREDICATES)
  ops := KAR option
  [[op,sig,:getInheritanceByDoc(D,op,sig)] for [op,sig] in getDomainSigs1(D,ops)]
 
--=======================================================================
--          Getting Inheritance Info from Documentation in Lisplib
--=======================================================================
from?(D,op,sig) == KAR KDR getInheritanceByDoc(D,op,sig)

getExtensionsOfDomain domain ==
  u := getDomainExtensionsOfDomain domain
  cats := getCategoriesOfDomain domain
  for x in u repeat
    cats := UNION(cats,getCategoriesOfDomain EVAL x)
  [:u,:cats]

getDomainExtensionsOfDomain domain ==
  acc := nil
  d := domain
  while (u := devaluateSlotDomain(5,d)) repeat
    acc := [u,:acc]
    d := EVAL u
  acc

devaluateSlotDomain(u,dollar) ==
  u = '$ => devaluate dollar
  FIXP u and VECP (y := dollar.u) => devaluate y
  u is ['NRTEVAL,y] => MKQ eval y
  u is ['QUOTE,y] => u
  u is [op,:argl] => [op,:[devaluateSlotDomain(x,dollar) for x in argl]]
  devaluate evalSlotDomain(u,dollar)
 
getCategoriesOfDomain domain ==
  predkeyVec := domain.4.0
  catforms := CADR domain.4
  [fn for i in 0..MAXINDEX predkeyVec | test] where 
     test == predkeyVec.i and 
       (x := catforms . i) isnt ['DomainSubstitutionMacro,:.]
     fn ==
       VECP x => devaluate x
       devaluateSlotDomain(x,domain)

getInheritanceByDoc(D,op,sig,:options) ==
--gets inheritance and documentation information by looking in the LISPLIB 	
--for each ancestor of the domain
  catList := KAR options or getExtensionsOfDomain D
  getDocDomainForOpSig(op,sig,devaluate D,D) or
    or/[fn for x in catList] or '(NIL NIL)
      where fn == getDocDomainForOpSig(op,sig,substDomainArgs(D,x),D)
 
getDocDomainForOpSig(op,sig,dollar,D) ==
  (u := LASSOC(op,GETDATABASE(CAR dollar,'DOCUMENTATION)))
    and (doc := or/[[d,dollar] for [s,:d] in u | compareSig(sig,s,D,dollar)])
 
--=======================================================================
--               Functions implementing showImp
--=======================================================================
showDomainsOp1(u,key) ==
  while u and CAR u is [op,sig,: =key] repeat
    sayBrightly ['"   ",:formatOpSignature(op,sig)]
    u := rest u
  u

getDomainRefName(dom,nam) ==
  PAIRP nam => [getDomainRefName(dom,x) for x in nam]
  not FIXP nam => nam
  slot := dom.nam
  VECP slot => slot.0
  slot is ['SETELT,:.] => getDomainRefName(dom,getDomainSeteltForm slot)
  slot

getDomainSeteltForm ['SETELT,.,.,form] ==
  form is ['evalSlotDomain,u,d] => devaluateSlotDomain(u,d)
  VECP form => systemError()
  form
 
showPredicates dom ==
  sayBrightly '"--------------------Predicate summary-------------------"
  conname := CAR dom.0
  predvector := dom.3
  predicateList := GETDATABASE(conname,'PREDICATES)
  for i in 1.. for p in predicateList repeat
    prefix := 
      testBitVector(predvector,i) => '"true : "
      '"false: "
    sayBrightly [prefix,:pred2English p]
 
showAttributes dom ==
  sayBrightly '"--------------------Attribute summary-------------------"
  conname := CAR dom.0
  abb := getConstructorAbbreviation conname
  predvector := dom.3
  for [a,:p] in dom.2 repeat
    prefix :=
      testBitVector(predvector,p) => '"true : "
      '"false: "
    sayBrightly concat(prefix,form2String a)

showGoGet dom ==
  numvec := CDDR dom.4
  for i in 6..MAXINDEX dom | (slot := dom.i) is ['newGoGet,dol,index,:op] repeat
    numOfArgs := numvec.index
    whereNumber := numvec.(index := index + 1)
    signumList := 
      [formatLazyDomainForm(dom,numvec.(index + i)) for i in 0..numOfArgs]
    index := index + numOfArgs + 1
    namePart := 
      concat(bright "from",form2String formatLazyDomainForm(dom,whereNumber))
    sayBrightly [i,'": ",:formatOpSignature(op,signumList),:namePart]

formatLazyDomain(dom,x) ==
  VECP x => devaluate x
  x is [dollar,slotNumber,:form] => formatLazyDomainForm(dom,form)
  systemError nil
 
formatLazyDomainForm(dom,x) ==
  x = 0 => ["$"]
  FIXP x => formatLazyDomain(dom,dom.x)
  atom x => x
  x is ['NRTEVAL,y] => (atom y => [y]; y)
  [first x,:[formatLazyDomainForm(dom,y) for y in rest x]]
 

--====================> WAS b-op1.boot <================================

--=======================================================================
--                   Operation Page Menu
--=======================================================================
--opAlist has form [[op,:alist],:.]  where each alist
--        has form [sig,pred,origin,exposeFlag,comments]

dbFromConstructor?(htPage) == htpProperty(htPage,'conform)

dbPresentOps(htPage,which,:exclusions) ==
  true => dbPresentOpsSaturn(htPage,which,exclusions)
--Flags:
--  fromConPage?:    came (originally) from a constructor page
--  usage?:          display usage?
--  star?:           display exposed/*=unexposed
--  implementation?: display implementation?
  htSay('"{\em Views:}")
  asharp? := htpProperty(htPage,'isAsharpConstructor)
  fromConPage? := (conname := opOf htpProperty(htPage,'conform))
  usage? := $UserLevel = 'development and fromConPage? and which = '"operation"
    and not (GETDATABASE(conname,'CONSTRUCTORKIND) = 'category)
      and not asharp?
  star? := not fromConPage? or which = '"package operation"
  implementation? := not asharp? and
    $UserLevel = 'development and $conformsAreDomains 
          --and not $includeUnexposed?
  rightmost? := star? or (implementation? and not $includeUnexposed?)
  tabs :=
    which = '"attribute" => '("12" "12" "25" "40" 13)
    star? => '("12" "19" "31" "43" 10)
    implementation? => '("9" "16" "28" "44" 9)
    '("9" "16" "28" "41" 12)
  if INTEGERP first exclusions then exclusions := ['documentation]
  htpSetProperty(htPage,'exclusion,first exclusions)
  opAlist :=
    which = '"operation" => htpProperty(htPage,'opAlist)
    htpProperty(htPage,'attrAlist)
  empty? := null opAlist
  htTab
   which = '"attribute" => tabs.1
   tabs.0
  if empty? or MEMBER('names,exclusions) or null KDR opAlist
    then htSay '"{\em names}"
    else htMakePage [['bcLispLinks,['"names",'"",'dbShowOps,which,'names]]]
  if which ^= '"attribute" then
    htTab tabs.1
    if empty? or MEMBER('signatures,exclusions)
      then htSay '"{\em signatures}"
      else htMakePage _
         [['bcLispLinks,['"signatures",'"",'dbShowOps,which,'signatures]]]
  htTab tabs.2
  if empty? or MEMBER('parameters,exclusions) --also test for some parameter
      or not dbDoesOneOpHaveParameters? opAlist
    then htSay '"{\em parameters}"
    else htMakePage _
       [['bcLispLinks,['"parameters",'"",'dbShowOps,which,'parameters]]]
  htTab tabs.3
  if not empty? and null IFCDR opAlist and not htpProperty(htPage,'noUsage)
    then
      if htpProperty(htPage,'conform)
      then htMakePage
             [['bcLinks,['"generalise",'"",'dbShowOps,which,'generalise]]]
      else htMakePage
             [['bcLinks,['"all domains",'"",'dbShowOps,which,'allDomains]]]
    else
      if empty? or MEMQ('usage,exclusions) or _
             htpProperty(htPage,'noUsage) then htSay '"{\em filter}" else
        htMakePage [['bcLinks,['"filter",'"",'dbShowOps,which,'filter]]]
      htMakePage [['bcStrings, [tabs.4,'"",'filter,'EM]]]
  htSay('"\newline ")
  if star?
  then
    if $exposedOnlyIfTrue
    then htMakePage
        [['bcLinks,['"exposed",'" {\em only}",'dbShowOps,which,'exposureOff]]]
    else
      htSay('"*{\em =}")
      htMakePage [['bcLinks,['"unexposed",'"",'dbShowOps,which,'exposureOn]]]
--  else if (updown := dbCompositeWithMap htPage)
--       then htMakePage [['bcLispLinks,[updown,'"",'dbShowUpDown,updown]]]
  htTab tabs.0
  if usage? then
      if empty? or MEMBER('usage,exclusions) _
                or GETDATABASE(conname,'CONSTRUCTORKIND) = 'category _
                or HGET($defaultPackageNamesHT,conname) _
                or htpProperty(htPage,'noUsage)
      then htSay '"{\em usage}"
      else htMakePage _
            [['bcLispLinks,['"usage",'"",'whoUsesOperation,which,nil]]]
  htTab tabs.1
  if empty? or MEMBER('origins,exclusions)
    then htSay '"{\em origins}"
    else htMakePage [['bcLispLinks,['"origins",'"",'dbShowOps,which,'origins]]]
  htTab tabs.2
  if implementation? then
    if MEMBER('implementation,exclusions) or which = '"attribute" or
      ((conname := opOf htpProperty(htPage,'conform)) _
           and GETDATABASE(conname,'CONSTRUCTORKIND) = 'category)
    then htSay '"{\em implementation}"
    else htMakePage _
     [['bcLispLinks,['"implementation",'"",'dbShowOps,which,'implementation]]]
  else if empty? or MEMBER('conditions,exclusions) _
                 or (htpProperty(htPage,'condition?) = 'no)
      then htSay '"{\em conditions}"
      else htMakePage _
        [['bcLispLinks,['"conditions",'"",'dbShowOps,which,'conditions]]]
  htTab tabs.3
  if empty? or MEMBER('documentation,exclusions)
    then htSay '"{\em description}"
    else htMakePage _
      [['bcLispLinks,['"description",'"",'dbShowOps,which,'documentation]]]
  htShowPageNoScroll()

htTab s == htSay('"\tab{",s,'"}")

dbDoesOneOpHaveParameters? opAlist ==
  or/[(or/[fn for x in items]) for [op,:items] in opAlist] where fn ==
    STRINGP x => dbPart(x,2,1) ^= '"0"
    KAR x
--============================================================================
--               Master Switch Functions for Operation Views
--============================================================================

dbShowOps(htPage,which,key,:options) ==
  --NEXT LINE SHOULD BE REMOVED if we are sure that which is a string
  which := STRINGIMAGE which
  if MEMQ(key,'(extended basic all)) then
    $groupChoice := key
    key := htpProperty(htPage,'key) or 'names
  opAlist  :=
    which = '"operation" => htpProperty(htPage,'opAlist)
--      al := reduceByGroup(htPage,htpProperty(htPage,'principalOpAlist))
--      htpSetProperty(htPage,'opAlist,al)
--      al
    htpProperty(htPage,'attrAlist)
  key = 'generalise =>
    arg  := STRINGIMAGE CAAR opAlist
    which = '"attribute" => aPage arg
    oPage arg
  key = 'allDomains => dbShowOpAllDomains(htPage,opAlist,which)
  key = 'filter =>
    --if $saturn, IFCAR options contains filter string
    filter := IFCAR options or pmTransFilter(dbGetInputString htPage)
    filter is ['error,:.] => bcErrorPage filter
    opAlist:= _
      [x for x in opAlist | superMatch?(filter,DOWNCASE STRINGIMAGE opOf x)]
    null opAlist => emptySearchPage(which,filter)
    htPage := htInitPageNoScroll(htCopyProplist htPage)
    if which = '"operation"
      then htpSetProperty(htPage,'opAlist,opAlist)
      else htpSetProperty(htPage,'attrAlist,opAlist)
    if not htpProperty(htPage,'condition?) = 'no then
      dbResetOpAlistCondition(htPage,which,opAlist)
    dbShowOps(htPage,which,htpProperty(htPage,'exclusion))
  htpSetProperty(htPage,'key,key)
  if MEMQ(key,'(exposureOn exposureOff)) then
    $exposedOnlyIfTrue :=
       key = 'exposureOn => 'T
       nil
    key := htpProperty(htPage,'exclusion)
  dbShowOp1(htPage,opAlist,which,key)

reduceByGroup(htPage,opAlist) ==
  not dbFromConstructor?(htPage) or null $groupChoice => opAlist
  dbExpandOpAlistIfNecessary(htPage,opAlist,'"operation",true,false)
  bitNumber := HGET($topicHash,$groupChoice)
  res := [[op,:newItems] for [op,:items] in opAlist | newItems] where
    newItems ==
      null bitNumber => items
      [x for x in items | FIXP (code := myLastAtom x) _
                          and LOGBITP(bitNumber,code)]
  res


dbShowOp1(htPage,opAlist,which,key) ==
  --set up for filtering below in dbGatherData
  $which: local := which
  if INTEGERP key then
    opAlist := dbSelectData(htPage,opAlist,key)
    ------> Jump out for constructor names in file <--------
  INTEGERP key and opAlist is [[con,:.]] and htpProperty(htPage,'isFile)
      and constructor? con => return conPageChoose con
  if INTEGERP key then
    htPage := htInitPageNoScroll(htCopyProplist htPage)
    if which = '"operation"
      then htpSetProperty(htPage,'opAlist,opAlist)
      else htpSetProperty(htPage,'attrAlist,opAlist)
    if not htpProperty(htPage,'condition?) = 'no then
      dbResetOpAlistCondition(htPage,which,opAlist)
  dbExpandOpAlistIfNecessary(htPage,opAlist,which,true,false)
  if $exposedOnlyIfTrue and not dbFromConstructor?(htPage) then
  --opAlist is expanded to form 
  -- [[op,[sig,pred,origin,exposed,comments],...],...]
    opAlist:=[item for [op,:items] in opAlist | item] where
      item ==
        acc := nil
        for x in items | x.3 repeat acc:= [x,:acc]
        null acc => nil
        [op,:NREVERSE acc]
  $conformsAreDomains : local := htpProperty(htPage,'domname)
  opCount := opAlistCount(opAlist, which)
  branch :=
    INTEGERP key =>
      opCount <= $opDescriptionThreshold => 'documentation
      'names
    key = 'names and null rest opAlist =>      --means a single op
      opCount <= $opDescriptionThreshold => 'documentation
      'names
    key
  [what,whats,fn] := LASSOC(branch,$OpViewTable)
  data := dbGatherData(htPage,opAlist,which,branch)
  dataCount := +/[1 for x in data | (what = '"Name" and _
                                     $exposedOnlyIfTrue => atom x; true)]
  namedPart :=
    null rest opAlist =>
      ops := escapeSpecialChars STRINGIMAGE CAAR opAlist
      ['" {\em ",ops,'"}"]
    nil
  if what = '"Condition" and null KAR KAR data then dataCount := dataCount - 1
  exposurePart :=
    $exposedOnlyIfTrue => '(" Exposed ")
    nil
  firstPart :=
    opCount = 0 => ['"No ",:exposurePart, pluralize capitalize which]
    dataCount = 1 or dataCount = opCount =>
      opCount = 1 => [:exposurePart, capitalize which,:namedPart]
      [STRINGIMAGE opCount,'" ",:exposurePart,
         pluralize capitalize which,:namedPart]
    prefix := pluralSay(dataCount,what,whats)
    [:prefix,'" for ",STRINGIMAGE opCount,'" ",_
                                    pluralize capitalize which,:namedPart]
  page := htInitPageNoScroll(htCopyProplist htPage)
  ------------>above line used to call htInitPageHoHeading<----------
  htAddHeading dbShowOpHeading([:firstPart,:fromHeading page], branch)
  htpSetProperty(page,'data,data)
  htpSetProperty(page,'branch,branch)
  -- only place where specialMessage property is set seems to be commented. out
  if u := htpProperty(page,'specialMessage) then APPLY(first u,rest u)
  htSayStandard('"\beginscroll ")
  FUNCALL(fn,page,opAlist,which,data) --apply branch function
  dbOpsExposureMessage()
  htSayStandard("\endscroll ")
  dbPresentOps(page,which,branch)
  htShowPageNoScroll()

opAlistCount(opAlist, which) == +/[foo for [op,:items] in opAlist] where foo ==
  null $exposedOnlyIfTrue or which = '"attribute" => #items
  --count if unexpanded---CDDR(w) = nil---or if w.3 = true
  +/[1 for w in items | null (p := CDDR w) or p . 1]

dbShowOpHeading(heading, branch) ==
  suffix :=
--  branch = 'signatures => '" viewed as signatures"
    branch = 'parameters => '" viewed with parameters"
    branch = 'origins    => '" organized by origins"
    branch = 'conditions => '" organized by conditions"
    '""
  [:heading, suffix]

dbOpsExposureMessage() ==
  $atLeastOneUnexposed => htSay '"{\em *} = unexposed"

fromHeading htPage ==
  null htPage => '""
  $pn := [htPage.0,'"}{"]
  updomain := htpProperty(htPage,'updomain) =>
    dnForm  := dbExtractUnderlyingDomain updomain
    dnString:= form2StringList dnForm
    dnFence := form2Fence  dnForm
--  upString:= form2StringList updomain
    upFence := form2Fence  updomain
    upOp    := PNAME opOf  updomain
    ['" {\em from} ",:dbConformGen dnForm,'" {\em under} _
                                     \ops{",upOp,'"}{",:$pn,:upFence,'"}"]
  domname  := htpProperty(htPage,'domname)
  numberOfUnderlyingDomains := #[x for x in rest _
                                     GETDATABASE(opOf domname,'COSIG) | x]
--  numberOfUnderlyingDomains = 1 and
--    KDR domname and (dn := dbExtractUnderlyingDomain domname) =>
--      ['" {\em from} ",:pickitForm(domname,dn)]
  KDR domname => ['" {\em from} ",:dbConformGen domname]
  htpProperty(htPage,'fromHeading)

pickitForm(form,uarg) ==
  conform2StringList(form,FUNCTION dbConform,FUNCTION conformString,uarg)

conformString(form) ==
  KDR form =>
    conform2StringList(form,FUNCTION conname2StringList,_
                                                 FUNCTION conformString,nil)
  form2StringList form

conform2StringList(form,opFn,argFn,exception) ==
  exception := exception or '"%%%nothing%%%"
  [op1,:args] := form
  op := IFCAR HGET($lowerCaseConTb,op1) or op1
  null args => APPLY(opFn,[op])
  special := MEMQ(op,'(Union Record Mapping))
  cosig :=
    special => ['T for x in args]
    rest GETDATABASE(op,'COSIG)
  atypes :=
    special => cosig
    rest CDAR GETDATABASE(op,'CONSTRUCTORMODEMAP)
  sargl := [fn for x in args for atype in atypes for pred in cosig] where fn ==
    keyword :=
      x is [":",y,t] =>
        x := t
        y
      nil
    res :=
      x = exception => dbOpsForm exception
      pred =>
        STRINGP x => [x]
        u := APPLY(argFn,[x])
        atom u and [u] or u
      typ := sublisFormal(args,atype)
      if x is ['QUOTE,a] then x := a
      u := mathform2HtString algCoerceInteractive(x,typ,'(OutputForm)) => [u]
      NUMBERP x or STRINGP x => [x]
      systemError()
    keyword => [keyword,'": ",:res]
    res
  op = 'Mapping => dbMapping2StringList sargl
  head :=
    special => [op]
    APPLY(opFn,[form])
  [:head,'"(",:first sargl,:"append"/[[",",:y] for y in rest sargl],'")"]


dbMapping2StringList [target,:sl] ==
  null sl => target
  restPart :=
    null rest sl => nil
    "append"/[[",",:y] for y in rest sl]
  sourcePart :=
    restPart => ['"(",:first sl,:restPart,'")"]
    first sl
  [:sourcePart,'" -> ",:target]

dbOuttran form ==
  if LISTP form then
    [op,:args] := form
  else
    op := form
    args := nil
  cosig := rest GETDATABASE(op,'COSIG)
  atypes := rest CDAR GETDATABASE(op,'CONSTRUCTORMODEMAP)
  argl := [fn for x in args for atype in atypes for pred in cosig] where fn ==
    pred => x
    typ := sublisFormal(args,atype)
    arg :=
      x is ['QUOTE,a] => a
      x
    res := mathform2HtString algCoerceInteractive(arg,typ,'(OutputForm))
    NUMBERP res or STRINGP res => res
    ['QUOTE,res]
  [op,:argl]

dbOpsForm form ==
--one button for the operations of a type
--1st arg: like "Matrix(Integer)" or "UP('x,Integer)" <---all highlighted
--2nd arg: like (|Matrix| (|Integer|)) and (|U..P..| (QUOTE |x|) (|Integer|))
  ["\ops{",:conform2StringList(form,FUNCTION conname2StringList,_
                FUNCTION conformString,nil),'"}{",:$pn,:form2Fence form,'"}"]

dbConform form ==
--------------------> OBSELETE <--------------------------
--one button for the main constructor page of a type
--NOTE: Next line should be as follows---but form2Fence form will
--      put, e.g. '((2 1 . 0) (0 1 . 0)) instead of x**2 + 1
  $saturn => ["\conf{",:form2StringList opOf form,
     '"}{\lispLink{\verb!{(|conForm| '",:form2Fence dbOuttran form,'")!}}}"]
  ["\conf{",:form2StringList opOf form,'"}{",:form2Fence dbOuttran form,'"}"]
--["\conf{",:form2StringList opOf form,'"}{",:form2Fence opOf form,'"}"]


dbConformGen form == dbConformGen1(form,true)
--many buttons: one for the type and one for each inner type
--NOTE: must only be called on types KNOWN to be correct

dbConformGenUnder form == dbConformGen1(form,false)
--same as above, except buttons only for the inner types

dbConformGen1(form,opButton?) ==
  opFunction :=
    opButton? => FUNCTION dbConform
    FUNCTION conname2StringList
  originalOp := opOf form
  op := unAbbreviateIfNecessary opOf form
  args := IFCDR form
  form :=
    originalOp=op => form
    [op, :args]
  args => conform2StringList(form, opFunction,FUNCTION dbConformGen,nil)
  APPLY(opFunction,[form])

unAbbreviateIfNecessary op == IFCAR HGET($lowerCaseConTb, op) or op

conname2StringList form == [PNAME unAbbreviateIfNecessary opOf form]

--===========================================================================
--               Data Gathering Code
--============================================================================
dbGatherData(htPage,opAlist,which,key) ==
  key = 'implementation => dbGatherDataImplementation(htPage,opAlist)
  dataFunction := LASSOC(key,table) where
    table ==
      $dbDataFunctionAlist or
        ($dbDataFunctionAlist := [
          ['signatures,:function dbMakeSignature],
            ['parameters,:function dbContrivedForm],
              ['origins,:function dbGetOrigin],
                ['domains,:function dbGetOrigin],
                  ['conditions,:function dbGetCondition]])
  null dataFunction =>
    --key= names or filter or documentation; do not expand
    if $exposedOnlyIfTrue and not dbFromConstructor?(htPage) then
      opAlist := --to get indexing correct
         which = '"operation" => htpProperty(htPage,'opAlist)
         htpProperty(htPage,'attrAlist)
    acc := nil
    initialExposure :=
      htPage and htpProperty(htPage,'conform) and which ^= '"package operation"
        => true
      --never star ops from a constructor
      nil
    for [op,:alist] in opAlist repeat
      exposureFlag := initialExposure
      while alist repeat
        item := first alist
        isExposed? :=
          STRINGP item => dbExposed?(item,char 'o)   --unexpanded case
          null (r := rest rest item) => true      --assume true if unexpanded
          r . 1                                   --expanded case
        if isExposed? then return (exposureFlag := true)
        alist := rest alist
      node :=
        exposureFlag => op
        [op,nil]
      acc := [node,:acc]
    NREVERSE acc
  data := nil
  dbExpandOpAlistIfNecessary(htPage,opAlist,which,key in _
                                              '(origins documentation),false)
  --create data, a list of the form ((entry,exposeFlag,:entries)...)
  for [op,:alist] in opAlist repeat
    for item in alist repeat
      entry := FUNCALL(dataFunction,op,item)--get key item
      exposeFlag :=                         --is the current op-sig exposed?
        null (r := rest rest item) => true  --not given, assume yes
        r . 1                               --is  given, use value
      tail :=
        item is [.,'ASCONST,:.] => 'ASCONST
        nil
      newEntry :=
        u := ASSOC(entry,data) =>           --key seen before? look on DATA
          RPLACA(CDR u,CADR u or exposeFlag)--yes, expose if any 1 is exposed
          u
        data := [y := [entry,exposeFlag,:tail],:data]
        y                                   --no, create new entry in DATA
      if MEMBER(key,'(origins conditions)) then
        r := CDDR newEntry
        if atom r then r := nil             --clear out possible 'ASCONST
        RPLACD(CDR newEntry,                --store op/sigs under key if needed
          insert([dbMakeSignature(op,item),exposeFlag,:tail],r))
  if MEMBER(key,'(origins conditions)) then
    for entry in data repeat   --sort list of entries (after the 2nd)
      tail := CDDR entry
      tail :=
        atom tail => tail
        listSort(function LEXLESSEQP,tail)
      RPLACD(CDR entry,tail)
  data := listSort(function LEXLESSEQP,data)
  data

dbGatherDataImplementation(htPage,opAlist) ==
--returns data, of form ((implementor exposed? entry entry...)...
--  where entry has form ((op sig . implementor) . stuff)
  conform := htpProperty(htPage,'conform)
  domainForm  := htpProperty(htPage,'domname)
  dom     := EVAL domainForm
  which   := '"operation"
  [nam,:$domainArgs] := domainForm
  $predicateList: local := GETDATABASE(nam,'PREDICATES)
  predVector := dom.3
  u := getDomainOpTable(dom,true,ASSOCLEFT opAlist)
  --u has form ((op,sig,:implementor)...)
  --sort into 4 groups: domain exports, unexports, default exports, others

  for (x := [.,.,:key]) in u for i in 0.. repeat
    key = domainForm => domexports := [x,:domexports]
    INTEGERP key => unexports := [x,:unexports]
    isDefaultPackageForm? key => defexports := [x,:defexports]
    key = 'nowhere => nowheres := [x,:nowheres]
    key = 'constant =>constants := [x,:constants]
    others := [x,:others]   --add chain domains go here
  fn [nowheres,constants,domexports,SORTBY('CDDR,NREVERSE others),SORTBY('CDDR,
               NREVERSE defexports),SORTBY('CDDR,NREVERSE unexports)] where
    fn l ==
      alist := nil
      for u in l repeat
        while u repeat
          key := CDDAR u  --implementor
          entries :=
           [[CAR u,true],:[u and [CAR u,true] while key = CDDAR (u := rest u)]]
          alist := [[key,gn key,:entries],:alist]
      NREVERSE alist
    gn key ==
      atom key => true
      isExposedConstructor CAR key

dbSelectData(htPage,opAlist,key) ==
  branch := htpProperty(htPage,'branch)
  data   := htpProperty(htPage,'data)
  MEMQ(branch,'(signatures parameters)) =>
    dbReduceOpAlist(opAlist,data.key,branch)
  MEMQ(branch,'(origins conditions implementation)) =>
    key < 8192 => dbReduceOpAlist(opAlist,data.key,branch)
    [newkey,binkey] := DIVIDE(key,8192)  --newkey is 1 too large
    innerData := CDDR data.(newkey - 1)
    dbReduceOpAlist(opAlist,innerData.binkey,'signatures)
  [opAlist . key]

dbReduceOpAlist(opAlist,data,branch) ==
  branch = 'signatures => dbReduceBySignature(opAlist,CAAR data,CADAR data)
  branch = 'origins => dbReduceBySelection(opAlist,CAR data,function CADDR)
  branch = 'conditions => dbReduceBySelection(opAlist,CAR data,function CADR)
  branch = 'implementation => dbReduceByOpSignature(opAlist,CDDR data)
  branch = 'parameters => dbReduceByForm(opAlist,CAR data)
  systemError ['"Unexpected branch: ",branch]

dbReduceByOpSignature(opAlist,datalist) ==
--reduces opAlist by implementation datalist, one of the form
--    (((op,sig,:implementor),:stuff),...)
  ops := [CAAR x for x in datalist] --x is [[op,sig,:implementor],:.]
  acc := nil
  for [op,:alist] in opAlist | MEMQ(op,ops) repeat
    entryList := [entry for (entry := [sig,:.]) in alist | test] where test ==
      or/[x for x in datalist | x is [[=op,=sig,:.],:.]]
    entryList => acc := [[op,:NREVERSE entryList],:acc]
  NREVERSE acc

dbReduceBySignature(opAlist,op,sig) ==
--reduces opAlist to one with a fixed op and sig
  [[op,:[x for x in LASSOC(op,opAlist) | x is [=sig,:.]]]]

dbReduceByForm(opAlist,form) ==
  acc := nil
  for [op,:alist] in opAlist repeat
    items := [x for x in alist | dbContrivedForm(op,x) = form] =>
      acc := [[op,:items],:acc]
  NREVERSE acc

dbReduceBySelection(opAlist,key,fn) ==
  acc := nil
  for [op,:alist] in opAlist repeat
    items := [x for x in alist | FUNCALL(fn,x) = key] =>
      acc := [[op,:items],:acc]
  NREVERSE acc

dbContrivedForm(op,[sig,:.]) ==
  $which = '"attribute" => [op,sig]
  dbMakeContrivedForm(op,sig)

dbMakeSignature(op,[sig,:.]) == [op,sig]  --getDomainOpTable format

dbGetOrigin(op,[.,.,origin,:.]) == origin

dbGetCondition(op,[.,pred,:.]) == pred

--dbInsertOpAlist(op,item,opAlist) ==
--  insertAlist(op,[item,:LASSOC(op,opAlist)],opAlist)

--dbSortOpAlist opAlist ==
--  [[op,:listSort(function LEXLESSEQP,alist)]
--    for [op,:alist] in listSort(function LEXLESSEQP,opAlist)]

--============================================================================
--               Branches of Views
--============================================================================
dbShowOpNames(htPage,opAlist,which,data) ==
  single? := opAlist and null rest data
  single? =>
    ops := escapeSpecialChars STRINGIMAGE CAAR opAlist
    htSayStandard('"Select a view below")
    htSaySaturn '"Select a view with the right mouse button"
  exposedOnly? := $exposedOnlyIfTrue and not dbFromConstructor?(htPage)
  dbShowOpItems(which,data,exposedOnly?)

dbShowOpItems(which,data,exposedOnly?) ==
  htBeginTable()
  firstTime := true
  for i in 0.. for item in data repeat
    if firstTime then firstTime := false
    else htSaySaturn '"&"
    if atom item then
      op := item
      exposeFlag := true
    else
      [op,exposeFlag] := item
    ops := escapeSpecialChars STRINGIMAGE op
    exposeFlag or not exposedOnly? =>
      htSay('"{")
      bcStarSpaceOp(ops,exposeFlag)
      htMakePage [['bcLinks,[ops,'"",'dbShowOps,which,i]]]
      htSay('"}")
  htEndTable()

dbShowOpAllDomains(htPage,opAlist,which) ==
  dbExpandOpAlistIfNecessary(htPage,opAlist,which,true,false)
  catOriginAlist := nil --list of category origins
  domOriginAlist := nil --list of domain origins
  for [op,:items] in opAlist repeat
    for [.,predicate,origin,:.] in items repeat
      conname := CAR origin
      GETDATABASE(conname,'CONSTRUCTORKIND) = 'category =>
        pred := simpOrDumb(predicate,LASSQ(conname,catOriginAlist) or true)
        catOriginAlist := insertAlist(conname,pred,catOriginAlist)
      pred := simpOrDumb(predicate,LASSQ(conname,domOriginAlist) or true)
      domOriginAlist := insertAlist(conname,pred,domOriginAlist)
  --the following is similar to "domainsOf" but do not sort immediately
  u := [COPY key for key in HKEYS _*HASCATEGORY_-HASH_*
          | LASSQ(CDR key,catOriginAlist)]
  for pair in u repeat
    [dom,:cat] := pair
    LASSQ(cat,catOriginAlist) = 'etc => RPLACD(pair,'etc)
    RPLACD(pair,simpOrDumb(GETDATABASE(pair,'HASCATEGORY),true))
  --now add all of the domains
  for [dom,:pred] in domOriginAlist repeat
    u := insertAlist(dom,simpOrDumb(pred,LASSQ(dom,u) or true),u)
  cAlist := listSort(function GLESSEQP,u)
  for pair in cAlist repeat RPLACA(pair,getConstructorForm first pair)
  htpSetProperty(htPage,'cAlist,cAlist)
  htpSetProperty(htPage,'thing,'"constructor")
  htpSetProperty(htPage,'specialHeading,'"hoho")
  dbShowCons(htPage,'names)

simpOrDumb(new,old) ==
  new = 'etc => 'etc
  atom new => old
  'etc

dbShowOpOrigins(htPage,opAlist,which,data) ==
  dbGatherThenShow(htPage,opAlist,which,data,true,_
                   '"from",function bcStarConform)

dbShowOpImplementations(htPage,opAlist,which,data) ==
  dbGatherThenShow(htPage,opAlist,which,data,true,'"by",function bcStarConform)

dbShowOpConditions(htPage,opAlist,which,data) ==
  dbGatherThenShow(htPage,opAlist,which,data,nil,nil,function bcPred)

dbGatherThenShow(htPage,opAlist,which,data,constructorIfTrue,word,fn) ==
-----------------> OBSELETE
  single? := null rest data
  htSay('"\beginmenu ")
  bincount := 0
  for [thing,exposeFlag,:items] in data repeat
    htSay('"\item ")
    if single? then htSay(menuButton())
    else htMakePage [['bcLinks,[menuButton(),'"",'dbShowOps,which,bincount]]]
    htSay '"{\em "
    htSay
      thing = 'nowhere => '"implemented nowhere"
      thing = 'constant => '"constant"
      thing = '_$ => '"by the domain"
      INTEGERP thing => '"unexported"
      constructorIfTrue =>
        htSay word
        atom thing => '" an unknown constructor"
        '""
      atom thing => '"unconditional"
      '""
    htSay '"}"
    if null atom thing then
      if constructorIfTrue then htSay('" {\em ",dbShowKind thing,'"}")
      htSay '" "
      FUNCALL(fn,thing)
    htSay('":\newline ")
    dbShowOpSigList(which,items,(1 + bincount) * 8192)
    bincount := bincount + 1
  htSay '"\endmenu "

dbShowKind conform ==
  conname := CAR conform
  kind := GETDATABASE(conname,'CONSTRUCTORKIND)
  kind = 'domain =>
    (s := PNAME conname).(MAXINDEX s) = '_& => '"default package"
    '"domain"
  PNAME kind

dbShowOpSignatures(htPage,opAlist,which,data) == dbShowOpSigList(which,data,0)

dbShowOpSigList(which,dataItems,count) ==
--dataItems is (((op,sig,:.),exposureFlag,...)
  single? := null rest dataItems
  htBeginTable()
  firstTime := true
  for [[op,sig,:.],exposureFlag,:tail] in dataItems repeat
    if firstTime then firstTime := false
    else htSaySaturn '"&";
    ops := escapeSpecialChars STRINGIMAGE op
    htSay '"{"
--  if single? then htSay('"{\em ",ops,'"}") else.....
    htSayExpose(ops,exposureFlag)
    htMakePage [['bcLinks,[ops,'"",'dbShowOps,which,count]]]
    if which = '"attribute" then htSay args2HtString (sig and [sig]) else
      htSay '": "
      tail = 'ASCONST => bcConform first sig
      bcConform ['Mapping,:sig]
    htSay '"}"
    count := count + 1
  htEndTable()
  count

dbShowOpParameters(htPage,opAlist,which,data) ==
  single? := null rest data
  count := 0
  htBeginTable()
  firstTime := true
  for item in data repeat
    if firstTime then firstTime := false
    else htSaySaturn '"&"
    [opform,exposeFlag,:tail] := item
    op := intern IFCAR opform
    args := IFCDR opform
    ops := escapeSpecialChars STRINGIMAGE op
    htSay '"{"
    htSayExpose(ops,exposeFlag)
    n := #opform
    do
      n = 2 and LASSOC('Nud,PROPLIST op) =>
        dbShowOpParameterJump(ops,which,count,single?)
        htSay('" {\em ",KAR args,'"}")
      n = 3 and LASSOC('Led,PROPLIST op) =>
        htSay('"{\em ",KAR args,'"} ")
        dbShowOpParameterJump(ops,which,count,single?)
        htSay('" {\em ",KAR KDR args,'"}")
      dbShowOpParameterJump(ops,which,count,single?)
      tail = 'ASCONST or MEMBER(op,'(0 1)) or _
                            which = '"attribute" and null IFCAR args => 'skip
      htSay('"(")
      if IFCAR args then htSay('"{\em ",IFCAR args,'"}")
      for x in IFCDR args repeat
        htSay('",{\em ",x,'"}")
      htSay('")")
    htSay '"}"
    count := count + 1
  htEndTable()

dbShowOpParameterJump(ops,which,count,single?) ==
  single? => htSay('"{\em ",ops,'"}")
  htMakePage [['bcLinks,[ops,'"",'dbShowOps,which,count]]]

dbShowOpDocumentation(htPage,opAlist,which,data) ==
  if $exposedOnlyIfTrue and not dbFromConstructor?(htPage) then
    opAlist :=
      which = '"operation" => htpProperty(htPage,'opAlist)
      htpProperty(htPage,'attrAlist)
    --NOTE: this line is necessary to get indexing right.
    --The test below for $exposedOnlyIfTrue causes unexposed items
    --to be skipped.
  newWhich :=
    conform := htpProperty(htPage,'domname) or htpProperty(htPage,'conform)
    which = '"package operation" => '"operation"
    which
  expand := dbExpandOpAlistIfNecessary(htPage,opAlist,which,true,false)
  if expand then
    condata := dbGatherData(htPage,opAlist,which,'conditions)
    htpSetProperty(htPage,'conditionData,condata)
  base := -8192
  exactlyOneOpSig := opAlist is [[.,.]] --checked by displayDomainOp
  htSaySaturn '"\begin{description}"
  for [op,:alist] in opAlist repeat
    base := 8192 + base
    for item in alist for j in 0.. repeat
      [sig,predicate,origin,exposeFlag,comments] := item
      exposeFlag or not $exposedOnlyIfTrue =>
        if comments ^= '"" and STRINGP comments _
                           and (k := string2Integer comments) then
          comments :=
            MEMQ(k,'(0 1)) => '""
            dbReadComments k
          tail := CDDDDR item
          RPLACA(tail,comments)
        doc := (STRINGP comments and comments ^= '"" => comments; nil)
        pred := predicate or true
        index := (exactlyOneOpSig => nil; base + j)
        if which = '"package operation" then
          sig    := SUBST(conform,'_$,sig)
          origin := SUBST(conform,'_$,origin)
        displayDomainOp(htPage,newWhich,origin,op,sig,pred,doc,_
                        index,'dbChooseDomainOp,null exposeFlag,true)
  htSaySaturn '"\end{description}"

dbChooseDomainOp(htPage,which,index) ==
  [opKey,entryKey] := DIVIDE(index,8192)
  opAlist :=
    which = '"operation" => htpProperty(htPage,'opAlist)
    htpProperty(htPage,'attrAlist)
  [op,:entries] := opAlist . opKey
  entry := entries . entryKey
  htPage := htInitPageNoScroll(htCopyProplist htPage)
  if which = '"operation"
    then htpSetProperty(htPage,'opAlist,[[op,entry]])
    else htpSetProperty(htPage,'attrAlist,[[op,entry]])
  if not htpProperty(htPage,'condition?) = 'no then
    dbResetOpAlistCondition(htPage,which,opAlist)
  dbShowOps(htPage,which,'documentation)

htSayExpose(op,flag) ==
  $includeUnexposed? =>
    flag => htBlank()
    op.0 = char '_* => htSay '"{\em *} "
    htSayUnexposed()
  htSay '""
--============================================================================
--               Branch-in From Other Places
--============================================================================
dbShowOperationsFromConform(htPage,which,opAlist) ==  --branch in with lists
  $groupChoice := nil
  conform := htpProperty(htPage,'conform)
  --prepare opAlist for possible filtering of groups
  if null BOUNDP '$topicHash then
    $topicHash := MAKE_-HASHTABLE 'ID
    for [x,:c] in '((extended . 0) (basic . 1) (hidden . 2)) repeat
      HPUT($topicHash,x,c)
  if domform := htpProperty(htPage,'domname) then
    $conformsAreDomains : local := true
    reduceOpAlistForDomain(opAlist,domform,conform)
  conform := domform or conform
  kind := capitalize htpProperty(htPage,'kind)
  exposePart :=
    isExposedConstructor opOf conform => '""
    '" Unexposed "
  fromPart :=
    domform => evalableConstructor2HtString domform
    form2HtString conform
  heading :=
    ['" from ",exposePart,kind,'" {\em ",fromPart,'"}"]
  expandProperty :=
    which = '"operation" => 'expandOperations
    'expandAttributes
  htpSetProperty(htPage,expandProperty,'lists)
  htpSetProperty(htPage,'fromHeading,heading)
  reducedOpAlist :=
    which = '"operation" =>  reduceByGroup(htPage,opAlist)
    opAlist
  if which = '"operation"
    then
      htpSetProperty(htPage,'principalOpAlist,opAlist)
      htpSetProperty(htPage,'opAlist,reducedOpAlist)
    else htpSetProperty(htPage,'attrAlist,opAlist)
  if domform
   then htpSetProperty(htPage,'condition?,'no)
   else dbResetOpAlistCondition(htPage,which,opAlist)
  dbShowOp1(htPage,reducedOpAlist,which,'names)

reduceOpAlistForDomain(opAlist,domform,conform) ==
--destructively simplify all predicates; filter out any that fail
  form1 := [domform,:rest domform]
  form2 := ['$,:rest conform]
  for pair in opAlist repeat
    RPLACD(pair,[test for item in rest pair | test]) where test ==
      [head,:tail] := item
      CAR tail = true => item
      pred := simpHasPred SUBLISLIS(form1,form2,QCAR tail)
      null pred => false
      RPLACD(item,[pred])
      item
  opAlist

dbShowOperationLines(which,linelist) ==  --branch in with lines
  htPage := htInitPage(nil,nil)  --create empty page
  opAlist := nil
  lines := linelist
  while lines repeat
    name := dbName (x := first lines)
    pile := [x]
    while (lines := rest lines) and name = dbName (x := first lines) repeat
      pile := [x,:pile]
    opAlist := [[name,:NREVERSE pile],:opAlist]
  opAlist := listSort(function LEXLESSEQP,NREVERSE opAlist)
  if which = '"operation"
    then htpSetProperty(htPage,'opAlist,opAlist)
    else htpSetProperty(htPage,'attrAlist,opAlist)
  expandProperty :=
    which = '"operation" => 'expandOperations
    'expandAttributes
  htpSetProperty(htPage,expandProperty,'strings)
  dbResetOpAlistCondition(htPage,which,opAlist)
  if which = '"attribute" and BOUNDP '$attributeArgs and $attributeArgs then
    --code needed to handle commutative("*"); called from aPage
    --must completely expand the opAlist then check for those with
    --arguments equal to $attributeArgs
    --here: opAlist is [[op,:itemlist]]
    dbExpandOpAlistIfNecessary(htPage,opAlist,which,false,false)
    opAlist := [[CAAR opAlist,:[item for item in CDAR opAlist | _
                                              first item = $attributeArgs]]]
  dbShowOp1(htPage,opAlist,which,'names)

--============================================================================
--                Code to Expand opAlist
--============================================================================
dbResetOpAlistCondition(htPage,which,opAlist) ==
  value := dbExpandOpAlistIfNecessary(htPage,opAlist,which,false,true)
  htpSetProperty(htPage,'condition?,(value => 'yes; 'no))
  value

dbSetOpAlistCondition(htPage,opAlist,which) ==
--called whenever a new opAlist is needed
--property can only be inherited if 'no (a subset says NO if whole says NO)
  condition := htpProperty(htPage,'condition?)
  MEMQ(condition,'(yes no)) => condition = 'yes
  value := dbExpandOpAlistIfNecessary(htPage,opAlist,which,false,true)
  htpSetProperty(htPage,'condition?,(value => 'yes; 'no))
  value

dbExpandOpAlistIfNecessary(htPage,opAlist,which,needOrigins?,condition?) ==
--if condition? = true, stop when you find a non-trivial predicate
--otherwise, expand in full
--RETURNS:
--  non-trivial predicate, if condition? = true and it finds one
--  nil,                   otherwise
--SIDE-EFFECT: this function references the "expand" property (set elsewhere):
--  'strings, if not fully expanded and it contains strings
--            i.e. opAlist is ((op . (string ...))...) if unexpanded
--  'lists,   if not fully expanded and it contains lists
--            i.e. opAlist is ((op . ((sig pred) ...))...) if unexpanded
    condition? := condition? and not $exposedOnlyIfTrue
    value      := nil  --return value
    expandProperty :=
      which = '"operation" => 'expandOperations
      'expandAttributes
    expandFlag := htpProperty(htPage,expandProperty)
    expandFlag = 'fullyExpanded => nil
    expandFlag = 'strings => --strings are partially expanded
      for pair in opAlist repeat
        [op,:lines] := pair
        acc := nil
        for line in lines repeat
        --NOTE: we must expand all lines here for a given op
        --      since below we will change opAlist
        --Case 1: Already expanded; just cons it onto ACC
          null STRINGP line => --already expanded
            if condition? then --this could have been expanded at a lower level
              if null atom (pred := CADR line) then value := pred
            acc := [line,:acc] --this one is already expanded; record it anyway
        --Case 2: unexpanded; expand it then cons it onto ACC
          [name,nargs,xflag,sigs,conname,pred,comments] := dbParts(line,7,1)
          predicate := ncParseFromString pred
          if condition? and null atom predicate then value := predicate
          sig := ncParseFromString sigs --is (Mapping,:.)
          if which = '"operation" then
            if sig isnt ['Mapping,:.]
            then sayBrightly ['"Unexpected signature for ",name,'": ",sigs]
            else sig := rest sig
          conname := intern dbNewConname line
          origin := [conname,:getConstructorArgs conname]
          exposeFlag := dbExposed?(line,char 'o)
          acc := [[sig,predicate,origin,exposeFlag,comments],:acc]
        --always store the fruits of our labor:
        RPLACD(pair,NREVERSE acc)             --at least partially expand it
        condition? and value => return value  --early exit
      value => value
      condition? => nil
      htpSetProperty(htPage,expandProperty,'fullyExpanded)
    expandFlag = 'lists => --lists are partially expanded
      -- entry is [sig, predicate, origin, exposeFlag, comments]
      $value: local := nil
      $docTableHash := MAKE_-HASHTABLE 'EQUAL
      packageSymbol := false
      domform := htpProperty(htPage,'domname) or htpProperty(htPage,'conform)
      if isDefaultPackageName opOf domform then
         catname := intern SUBSTRING(s := PNAME opOf domform,0,MAXINDEX s)
         packageSymbol := first rest domform
         domform := [catname,:rest rest domform]  --skip first argument ($)
      docTable:= dbDocTable domform
      for [op,:alist] in opAlist repeat
        for [sig,:tail] in alist repeat
          condition? => --the only purpose here is to find a non-trivial pred
            null atom (pred := CAR tail) => return ($value := pred)
            'skip
          u :=
            tail is [.,origin,:.] and origin =>
--  must change any % into $ otherwise we will not pick up comments properly
--  delete the SUBLISLIS when we fix on % or $ 
              dbGetDocTable(op,SUBLISLIS(['$],['%],sig),dbDocTable origin,_
                            which,nil)
            if packageSymbol then sig := SUBST('_$,packageSymbol,sig)
            dbGetDocTable(op,sig,docTable,which,nil)
          origin := IFCAR u or origin
          docCode := IFCDR u   --> (doc . code)
--        if null FIXP CDR docCode then harhar(op) -->
          if null doc and which = '"attribute" then doc := getRegistry(op,sig)
          RPLACD(tail,[origin,isExposedConstructor opOf origin,:docCode])
        $value => return $value
      $value => $value
      condition? => nil
      htpSetProperty(htPage,expandProperty,'fullyExpanded)
    'done

getRegistry(op,sig) ==
  u := GETDATABASE('AttributeRegistry,'DOCUMENTATION)
  v := LASSOC(op,u)
  match := or/[y for y in v | y is [['attribute,: =sig],:.]] => CADR match
  '""

evalableConstructor2HtString domform ==
  if VECP domform then domform := devaluate domform
  conname := first domform
  coSig   := rest GETDATABASE(conname,'COSIG)
  --entries are T for args which are domains; NIL for computational objects
  and/[x for x in coSig] => form2HtString(domform,nil,true)
  arglist := [unquote x for x in rest domform] where
    unquote arg  ==
      arg is [f,:args] =>
        f = 'QUOTE => first args
        [f,:[unquote x for x in args]]
      arg
  fargtypes:=CDDAR GETDATABASE(conname,'CONSTRUCTORMODEMAP)
--argtypes:= sublisFormal(arglist,fargtypes)
  form2HtString([conname,:[fn for arg in arglist for x in coSig
                   for ftype in fargtypes]],nil,true) where
    fn ==
      x => arg
      typ := sublisFormal(arglist,ftype)
      mathform2HtString algCoerceInteractive(arg,typ,'(OutputForm))

mathform2HtString form == escapeString
  $fortInts2Floats: local := false
  form := niladicHack form
  form is ['QUOTE,a] => STRCONC('"'","STRCONC"/fortexp0 a)
  form is ['BRACKET,['AGGLST,:arg]] =>
    if arg is ['construct,:r] then arg := r
    arg :=
      atom arg => [arg]
      [y for x in arg | y := (x is ['QUOTE,a] => a; x)]
    tailPart := "STRCONC"/[STRCONC('",",STRINGIMAGE x) for x in rest arg]
    STRCONC('"[",STRINGIMAGE first arg,tailPart,'"]")
  form is ['BRACKET,['AGGLST,'QUOTE,arg]] =>
    if atom arg then arg := [arg]
    tailPart := "STRCONC"/[STRCONC('",",x) for x in rest arg]
    STRCONC('"[",first arg,tailPart,'"]")
  atom form => form
  "STRCONC"/fortexp0 form

niladicHack form ==
  atom form => form
  form is [x] and GET(x,'NILADIC) => x
  [niladicHack x for x in form]

--============================================================================
--                Getting Operations from Domain
--============================================================================

getDomainOpTable(dom,fromIfTrue,:options) ==
  ops := KAR options
  $predEvalAlist : local := nil
  $returnNowhereFromGoGet: local := true
  domname := dom.0
  conname := CAR domname
  abb := getConstructorAbbreviation conname
  opAlist := getOperationAlistFromLisplib conname
  "append"/[REMDUP [[op1,:fn] for [sig,slot,pred,key,:.] in u
              | key ^= 'Subsumed and ((null ops and (op1 := op)) _
                                 or (op1 := memq(op,ops)))]
                 for [op,:u] in opAlist] where
    memq(op,ops) ==   --dirty trick to get 0 and 1 instead of Zero and One
      MEMQ(op,ops) => op
      EQ(op,'One)  => MEMQ(1,ops) and 1
      EQ(op,'Zero) => MEMQ(0,ops) and 0
      false
    fn ==
      sig1 := sublisFormal(rest domname,sig)
      predValue := evalDomainOpPred(dom,pred)
      info :=
        null predValue =>
          1   -- signifies not exported
        null fromIfTrue => nil
        cell := compiledLookup(op,sig1,dom) =>
          [f,:r] := cell
          f = 'nowhere => 'nowhere           --see replaceGoGetSlot
          f = 'makeSpadConstant => 'constant
          f = function IDENTITY => 'constant
          f = 'newGoGet => SUBST('_$,domname,devaluate CAR r)
          null VECP r => systemError devaluateList r
          SUBST('_$,domname,devaluate r)
        'nowhere
      [sig1,:info]

evalDomainOpPred(dom,pred) == process(dom,pred) where
  process(dom,pred) ==
    u := convert(dom,pred)
    u = 'T => true
    evpred(dom,u)
  convert(dom,pred) ==
    pred is [op,:argl] =>
      MEMQ(op,'(AND and)) => ['AND,:[convert(dom,x) for x in argl]]
      MEMQ(op,'(OR or))   => ['OR,:[convert(dom,x) for x in argl]]
      MEMQ(op,'(NOT not)) => ['NOT,convert(dom,first argl)]
      op = 'has =>
        [arg,p] := argl
        p is ['ATTRIBUTE,a] => ['HasAttribute,arg,MKQ a]
        ['HasCategory,arg,convertCatArg p]
      systemError '"unknown predicate form"
    pred = 'T => true
    systemError nil
  convertCatArg p ==
    atom p or #p = 1 => MKQ p
    ['LIST,MKQ first p,:[convertCatArg x for x in rest p]]
  evpred(dom,pred) ==
    k := POSN1(pred,$predicateList) => testBitVector(dom.3,k + 1)
    evpred1(dom,pred)
  evpred1(dom,pred) ==
    pred is [op,:argl] =>
      MEMQ(op,'(AND and)) => "and"/[evpred1(dom,x) for x in argl]
      MEMQ(op,'(OR or))   =>  "or"/[evpred1(dom,x) for x in argl]
      op = 'NOT => not evpred1(dom,first argl)
      k := POSN1(pred,$predicateList) => testBitVector(dom.3,k + 1)
      op = 'HasAttribute =>
        [arg,[.,a]] := argl
        attPredIndex := LASSOC(a,dom.2)
        null attPredIndex  => nil
        attPredIndex = 0 => true
        testBitVector(dom.3,attPredIndex)
      nil
    pred = 'T => true
    systemError '"unknown atomic predicate form"

--====================> WAS br-op2.boot <================================

--=======================================================================
--		     Operation Description
--=======================================================================

displayDomainOp(htPage,which,origin,op,sig,predicate,
		doc,index,chooseFn,unexposed?,$generalSearch?) ==
-----------------------> OBSELETE
  $saturn =>
    displayDomainOp1(htPage,which,origin,op,sig,predicate,
		doc,index,chooseFn,unexposed?,$generalSearch?)
  $chooseDownCaseOfType : local := true	  --see dbGetContrivedForm
  $whereList  : local := nil
  $NumberList : local := '(i j k l m n i1 j1 k1 l1 m1 n1 i2 j2 k2 l2 m2 n2 _
                           i3 j3 k3 l3 m3 n3 i4 j4 k4 l4 m4 n4 )
  $ElementList: local := '(x y z u v w x1 y1 z1 u1 v1 w1 x2 y2 z2 u2 v2 w2 _
                           x3 y3 z3 u3 v3 w3 x4 y4 z4 u4 v4 w4 )
  $FunctionList:local := '(f g h d e F G H)
  $DomainList:	local := '(D R S E T A B C M N P Q U V W)
  exactlyOneOpSig     := null index
  conform   := htpProperty(htPage,'domname) or htpProperty(htPage,'conform)
		 or origin
  if $generalSearch? then $DomainList := rest $DomainList
  opform :=
    which = '"attribute" =>
      null sig => [op]
      [op,sig]
    which = '"constructor" => origin
    dbGetDisplayFormForOp(op,sig,doc)
  htSay('"\newline")
  if exactlyOneOpSig then htSay('"\menuitemstyle{}")
  else htMakePage [['bcLinks,['"\menuitemstyle{}",'"",chooseFn,which,index]]]
  htSay('"\tab{2}")
  op   := IFCAR opform
  args := IFCDR opform
  ops := escapeSpecialChars STRINGIMAGE op
  n := #sig
  do
    n = 2 and LASSOC('Nud,PROPLIST op) => _
                         htSay(ops,'" {\em ",quickForm2HtString KAR args,'"}")
    n = 3 and LASSOC('Led,PROPLIST op) => _
       htSay('"{\em ",quickForm2HtString KAR args,'"} ",ops,_
             '" {\em ",quickForm2HtString KAR KDR args,'"}")
    if unexposed? and $includeUnexposed? then
      htSayUnexposed()
      htSaySaturn '"\unexposed{{\em "
      htSaySaturn ops
      htSaySaturn '"}"
    htSayStandard(ops)
    predicate='ASCONST or GETDATABASE(op,'NILADIC) _
                       or MEMBER(op,'(0 1)) => 'skip
    which = '"attribute" and null args => 'skip
    htSay('"(")
    if IFCAR args then htSay('"{\em ",quickForm2HtString IFCAR args,'"}")
    for x in IFCDR args repeat
      htSay('",{\em ",quickForm2HtString x,'"}")
    htSay('")")
  constring := form2HtString conform
  conname   := first conform
  $conkind   : local := htpProperty(htPage,'kind) -- a string e.g. "category"
			  or STRINGIMAGE GETDATABASE(conname,'CONSTRUCTORKIND)
  $conlength : local := #constring
  $conform   : local := conform
  $conargs   : local := rest conform
  if which = '"operation" then
    $signature : local :=
      MEMQ(conname,$Primitives) => nil
      CDAR getConstructorModemap conname
    --RDJ: this next line is necessary until compiler bug is fixed
    --that forgets to substitute #variables for t#variables;
    --check the signature for SegmentExpansionCategory, e.g.
    tvarlist := TAKE(# $conargs,$TriangleVariableList)
    $signature := SUBLISLIS($FormalMapVariableList,tvarlist,$signature)
  $sig :=
    which = '"attribute" or which = '"constructor" => sig
    $conkind ^= '"package" => sig
    symbolsUsed := [x for x in rest conform | IDENTP x]
    $DomainList := SETDIFFERENCE($DomainList,symbolsUsed)
    getSubstSigIfPossible sig
  if MEMBER(which,'("operation" "constructor")) then
    $displayReturnValue: local := nil
    if args then
      htSay('"\newline")
      htSayStandard '"\tab{2}"
      htSay '"{\em Arguments:}"
      for a in args for t in rest $sig repeat
	htSayIndentRel(15,true)
	htSay('"{\em ",form2HtString(a),'"}, ")
	htSayValue t
	htSayIndentRel(-15,true)
	htSay('"\newline ")
    if first $sig then
      $displayReturnValue := true
      htSay('"\newline\tab{2}{\em Returns:}")
      htSayIndentRel(15)
      htSayValue first $sig
      htSayIndentRel(-15)
      htSay('"\newline ")
  if origin and ($generalSearch? or origin ^= conform) _
            and opOf(origin)^=op then
    htSay('"\newline\tab{2}{\em Origin:}")
    htSayIndentRel(15)
    if not isExposedConstructor opOf origin and $includeUnexposed? _
       then htSayUnexposed()
    bcConform(origin,true)
    htSayIndentRel(-15)
  if not MEMQ(predicate,'(T ASCONST)) then
    pred := sublisFormal(KDR conform,predicate)
    count := #pred
    htSay('"\newline\tab{2}{\em Conditions:}")
    for p in displayBreakIntoAnds SUBST($conform,"$",pred) repeat
      htSayIndentRel(15,count > 1)
      bcPred(p,$conform,true)
      htSayIndentRel(-15,count > 1)
      htSay('"\newline ")
  if $whereList then
    count := #$whereList
    htSay('"\newline\tab{2}{\em Where:}")
    if ASSOC("$",$whereList) then
      htSayIndentRel(15,true)
      htSayStandard '"{\em \$} is "
      htSaySaturn '"{\em \%} is "
      htSay
	$conkind = '"category" => '"of category "
	'"the domain "
      bcConform(conform,true,true)
      htSayIndentRel(-15,true)
    for [d,key,:t] in $whereList | d ^= "$" repeat
      htSayIndentRel(15,count > 1)
      htSay("{\em ",d,"} is ")
      htSayConstructor(key,sublisFormal(KDR conform,t))
      htSayIndentRel(-15,count > 1)
  if doc and (doc ^= '"" and (doc isnt [d] or d ^= '"")) then
    htSay('"\newline\tab{2}{\em Description:}")
    htSayIndentRel(15)
    if doc = $charFauxNewline then htSay $charNewline
    else
       ndoc:= 
          -- we are confused whether doc is a string or a list of strings
          CONSP doc => _
             [SUBSTITUTE($charNewline, $charFauxNewline, i) for i in doc]
          SUBSTITUTE($charNewline, $charFauxNewline,doc)
       htSay ndoc
    htSayIndentRel(-15)
  if exactlyOneOpSig and (infoAlist := htpProperty(htPage,'infoAlist)) then
    displayInfoOp(htPage,infoAlist,op,sig)


htSayIndentRel(n,:options) ==
-----------------> OBSELETE
  flag := IFCAR options
  m := ABSVAL n
  if flag then m := m + 2
  htSay
    n > 0 =>
      flag => ['"\indent{",STRINGIMAGE m,'"}\tab{-2}"]
      ['"\indent{",STRINGIMAGE m,'"}\tab{0}"]
    n < 0 => ['"\indent{0}\newline "]

htSayConstructor(key,u) ==
  u is ['CATEGORY,kind,:r] =>
    htSay('"a ",kind,'" ")
    htSayExplicitExports(r)
  key = 'is =>
    htSay '"the domain "
    bcConform(u,true)
  htSay
    key = 'is => '"the domain "
    kind := GETDATABASE(opOf u,'CONSTRUCTORKIND)
    kind = 'domain => '"an element of "
    '"a domain of "
  u is ['Join,:middle,r] =>
    rest middle =>
      htSay '"categories "
      bcConform(first middle,true)
      for x in rest middle repeat
	htSay '", "
	bcConform(x,true)
      r is ['CATEGORY,.,:r] =>
	htSay '" and "
	htSayExplicitExports(r)
      htSay '" and "
      bcConform(r,true)
    htSay '"category "
    bcConform(first middle,true)
    r is ['CATEGORY,.,:r] =>
     htSay '" "
     htSayExplicitExports(r)
    htSay '" and "
    bcConform(r,true)
  htSay(kind,'" ")
  bcConform(u,true)

htSayExplicitExports r ==
  htSay '"with explicit exports"
  $displayReturnValue => nil
  htSay '":"
  for x in r repeat
    htSay '"\newline "
    x is ['SIGNATURE,op,sig] =>
      ops := escapeSpecialChars STRINGIMAGE op
      htMakePage [['bcLinks,[ops,'"",'oPage,ops]]]
      htSay '": "
      bcConform ['Mapping,:sig]
    x is ['ATTRIBUTE,a] =>
      s := form2HtString a
      htMakePage [['bcLinks,[ops,'"",'aPage,s]]]
    x is ['IF,:.] =>
      htSay('"{\em if ...}")
    systemError()

displayBreakIntoAnds pred ==
  pred is [op,:u] and MEMBER(op,'(and AND)) => u
  [pred]

htSayValue t ==
  t is ['Mapping,target,:source] =>
      htSay('"a function from ")
      htSayTuple source
      htSay '" to "
      htSayArgument target
  t = '(Category) => htSay('"a category")
  t is [op,:.] and MEMQ(op,'(Join CATEGORY)) or constructor? opOf t =>
    htSayConstructor(nil,t)
  htSay('"an element of domain ")
  htSayArgument t			     --continue for operations

htSayArgument t == --called only for operations not for constructors
  null $signature => htSay ['"{\em ",t,'"}"]
  MEMQ(t, '(_$ _%)) =>
    $conkind = '"category" and $conlength > 20 =>
      $generalSearch? => htSay '"{\em D} of the origin category"
      addWhereList("$",'is,nil)
      htSayStandard '"{\em $}"
      htSaySaturn '"{\em \%}"
    htSayStandard '"{\em $}"
    htSaySaturn '"{\em \%}"
  not IDENTP t => bcConform(t,true)
  k := position(t,$conargs)
  if k > -1 then
    typeOfArg := (rest $signature).k
    addWhereList(t,'member,typeOfArg)
  htSay('"{\em ",t,'"}")

addWhereList(id,kind,typ) ==
  $whereList := insert([id,kind,:typ],$whereList)

htSayTuple t ==
  null t => htSay '"()"
  null rest t => htSayArgument first t
  htSay '"("
  htSayArgument first t
  for d in rest t repeat
    htSay '","
    htSayArgument d
  htSay '")"

dbGetDisplayFormForOp(op,sig,doc) ==
  dbGetFormFromDocumentation(op,sig,doc) or dbGetContrivedForm(op,sig)

dbGetFormFromDocumentation(op,sig,x) ==
  doc := (STRINGP x => x; first x)
  STRINGP doc and
     (stringPrefix?('"\spad{",doc) and (k := 6) or
       stringPrefix?('"\s{",doc) and (k := 3)) =>
    n := charPosition($charRbrace,doc,k)
    s := SUBSTRING(doc,k,n - k)
    parse := ncParseFromString s
    parse is [=op,:.] and #parse = #sig => parse
  nil

dbMakeContrivedForm(op,sig,:options) ==
  $chooseDownCaseOfType : local := IFCAR options
  $NumberList : local := '(i j k l m n i1 j1 k1 l1 m1 n1 i2 j2 k2 l2 m2 n2 _
                           i3 j3 k3 l3 m3 n3 i4 j4 k4 l4 m4 n4 )
  $ElementList: local := '(x y z u v w x1 y1 z1 u1 v1 w1 x2 y2 z2 u2 v2 w2 _
                           x3 y3 z3 u3 v3 w3 x4 y4 z4 u4 v4 w4 )
  $FunctionList:local := '(f g h d e F G H)
  $DomainList:	local := '(R S D E T A B C M N P Q U V W)
  dbGetContrivedForm(op,sig)

dbGetContrivedForm(op,sig) ==
  op = '"0" => [0]
  op = '"1" => [1]
  [op,:[dbChooseOperandName s for s in rest sig]]

dbChooseOperandName(typ) ==
  typ is ['Mapping,:.] =>
    x := first $FunctionList
    $FunctionList := rest $FunctionList
    x
  name := opOf typ
  kind :=
    name = "$" => 'domain
    GETDATABASE(name,'CONSTRUCTORKIND)
  s := PNAME opOf typ
  kind ^= 'category =>
    anySubstring?('"Integer",s,0) or anySubstring?('"Number",s,0) =>
      x := first $NumberList
      $NumberList := rest $NumberList
      x
    x :=
      $chooseDownCaseOfType =>
	y := DOWNCASE typ
	x :=
	  MEMBER(y,$ElementList) => y
	  first $ElementList
      first $ElementList
    $ElementList := DELETE(x,$ElementList)
    x
  x := first $DomainList
  $DomainList := rest $DomainList
  x

getSubstSigIfPossible sig ==
  getSubstSignature sig or sig

--
--  while (u := getSubstSignature sig) repeat
--     sig := u
--  sig

fullSubstitute(x,y,z) ==  --substitutes deeply: x for y in list z
  z = y => x
  atom z => z
  [fullSubstitute(x,y,u) for u in z]

getSubstCandidates sig ==
  candidates := nil
  for x in sig for i in 1.. | x is [.,.,:.] repeat
    getSubstQualify(x,i,sig) => candidates := getSubstInsert(x,candidates)
    y := or/[getSubstQualify(y,i,sig) for y in rest x | y is [.,.,:.]] =>
      candidates := insert(y,candidates)
  candidates

getSubstSignature sig ==
    candidates := getSubstCandidates sig
    null candidates => nil
    D := first $DomainList
    $DomainList := rest $DomainList
    winner := first candidates
    newsig := fullSubstitute(D,winner,sig)
    sig :=
      null rest candidates => newsig
      count := NUMOFNODES newsig
      for x in rest candidates repeat
	trial := fullSubstitute(D,x,sig)
	trialCount := NUMOFNODES trial
	trialCount < count =>
	  newsig := trial
	  count	 := trialCount
	  winner := x
      newsig
    addWhereList(D,'is,winner)
    newsig

getSubstQualify(x,i,sig) ==
    or/[CONTAINED(x,y) for y in sig for j in 1.. | j ^= i] => x
    false

getSubstInsert(x,candidates) ==
    return insert(x,candidates)
    null candidates => [x]
    or/[CONTAINED(x,y) for y in candidates] => candidates
    y := or/[CONTAINED(y,x) for y in candidates] => SUBST(x,y,candidates)
    candidates


--=======================================================================
--			Who Uses
--=======================================================================
whoUsesOperation(htPage,which,key) ==  --see dbPresentOps
  key = 'filter => koaPageFilterByName(htPage,'whoUsesOperation)
  opAlist := htpProperty(htPage,'opAlist)
  conform := htpProperty(htPage,'conform)
  conargs := rest conform
  opl := nil
  for [op,:alist] in opAlist repeat
    for [sig,:.] in alist repeat
      opl := [[op,:SUBLISLIS($FormalMapVariableList,rest conform,sig)],:opl]
  opl := NREVERSE opl
  u := whoUses(opl,conform)
  prefix := pluralSay(#u,'"constructor uses",'"constructors use")
  suffix :=
    opAlist is [[op1,.]] =>
      ['" operation {\em ",escapeSpecialChars STRINGIMAGE op1,_
       '":",form2HtString ['Mapping,:sig],'"}"]
    ['" these operations"]
  page := htInitPage([:prefix,:suffix],htCopyProplist htPage)
  nopAlist := nil
  for [name,:opsigList] in u repeat
    for opsig in opsigList repeat
      sofar    := LASSOC(opsig,nopAlist)
      nopAlist := insertAlist(opsig,[name,:LASSOC(opsig,nopAlist)],nopAlist)
  usedList := nil
  for [(pair := [op,:sig]),:namelist] in nopAlist repeat
    ops := escapeSpecialChars STRINGIMAGE op
    usedList := [pair,:usedList]
    htSay('"Users of {\em ",ops,'": ")
    bcConform ['Mapping,:sublisFormal(conargs,sig)]
    htSay('"}\newline")
    bcConTable listSort(function GLESSEQP,REMDUP namelist)
  noOneUses := SETDIFFERENCE(opl,usedList)
  if #noOneUses > 0 then
    htSay('"No constructor uses the ")
    htSay
      #noOneUses = 1 => '"operation: "
      [#noOneUses,'" operations:"]
    htSay '"\newline "
    for [op,:sig] in noOneUses repeat
      htSay('"\tab{2}{\em ",escapeSpecialChars STRINGIMAGE op,'": ")
      bcConform ['Mapping,:sublisFormal(conargs,sig)]
      htSay('"}\newline")
  htSayStandard '"\endscroll "
  dbPresentOps(page,which,'usage)
  htShowPageNoScroll()

whoUses(opSigList,conform) ==
  opList := REMDUP ASSOCLEFT opSigList
  numOfArgsList := REMDUP [-1 + #sig for [.,:sig] in opSigList]
  acc  := nil
  $conname : local := first conform
  domList := getUsersOfConstructor $conname
  hash := MAKE_-HASH_-TABLE()
  for name in allConstructors() | MEMQ(name,domList) repeat
    $infovec : local := dbInfovec name
    null $infovec => 'skip	     --category
    template := $infovec . 0
    found := false
    opacc := nil
    for i in 7..MAXINDEX template repeat
      item := template . i
      item isnt [n,:op] or not MEMQ(op,opList) => 'skip
      index := n
      numvec := getCodeVector()
      numOfArgs := numvec . index
      null MEMBER(numOfArgs,numOfArgsList) => 'skip
      whereNumber := numvec.(index := index + 1)
      template . whereNumber isnt [= $conname,:.] => 'skip
      signumList := dcSig(numvec,index + 1,numOfArgs)
      opsig := or/[pair for (pair := [op1,:sig]) in opSigList _
                   | op1 = op and whoUsesMatch?(signumList,sig,nil)]
	=> opacc := [opsig,:opacc]
    if opacc then acc := [[name,:opacc],:acc]
  acc

whoUsesMatch?(signumList,sig,al) ==
  #signumList = #sig and whoUsesMatch1?(signumList,sig,al)

whoUsesMatch1?(signumList,sig,al) ==
  signumList is [subject,:r] and sig is [pattern,:s] =>
    x := LASSOC(pattern,al) =>
      x = subject => whoUsesMatch1?(r,s,al)
      false
    pattern = '_$ =>
      subject is [= $conname,:.] => whoUsesMatch1?(r,s,[['_$,:subject],:al])
      false
    whoUsesMatch1?(r,s,[[pattern,:subject],:al])
  true

--=======================================================================
--		     Get Attribute/Operation Alist
--=======================================================================

koAttrs(conform,domname) ==
  [conname,:args] := conform
--asharpConstructorName? conname => nil  --assumed
  'category = GETDATABASE(conname,'CONSTRUCTORKIND) =>
      koCatAttrs(conform,domname)
  $infovec: local := dbInfovec conname or return nil
  $predvec: local :=
    $domain => $domain . 3
    GETDATABASE(conname,'PREDICATES)
  u := [[a,:pred] for [a,:i] in $infovec . 2 _
           | a ^= 'nil and (pred := sublisFormal(args,kTestPred i))]
                                               ---------  CHECK for a = nil
  listSort(function GLESSEQP,fn u) where fn u ==
    alist := nil
    for [a,:pred] in u repeat
      op := opOf a
      args := IFCDR a
      alist := insertAlist(op,insertAlist(args,[pred],LASSOC(op,alist)),alist)
    alist

koOps(conform,domname,:options) == main where
--returns alist of form ((op (sig . pred) ...) ...)
  main ==
    $packageItem: local := nil
--  relatives? := IFCAR options
    ours :=
--    relatives? = 'onlyRelatives => nil
      fn(conform,domname)
--    if relatives? then
--      relatives := relativesOf(conform,domname)
--      if domname then relatives :=
--	SUBLISLIS([domname,:rest domname],['_$,:rest conform],relatives)
--      --kill all relatives that have a sharp variable remaining in them
--      for x in relatives repeat
--	or/[y for y in CDAR x | isSharpVar y] => 'skip
--	acc := [x,:acc]
--      relatives := NREVERSE acc
--      for (pair := [pakform,:.]) in relatives repeat
--	$packageItem := sublisFormal(rest conform,pair)
--	ours := merge(fn(pakform,nil),ours)
    listSort(function GLESSEQP,trim ours)
  trim u == [pair for pair in u | IFCDR pair]
  fn(conform,domname) ==
    conform := domname or conform
    [conname,:args] := conform
    subargs: local := args
    ----------> new <------------------
    u := koCatOps(conform,domname) => u
--    'category = GETDATABASE(conname,'CONSTRUCTORKIND) =>
--	  koCatOps(conform,domname)
    asharpConstructorName? opOf conform => nil
    ----------> new <------------------
    $infovec: local := dbInfovec conname--------> removed 94/10/24
    exposureTail :=
      null $packageItem => '(NIL NIL)
      isExposedConstructor opOf conform => [conform,:'(T)]
      [conform,:'(NIL)]
    for [op,:u] in getOperationAlistFromLisplib conname repeat
      op1 := zeroOneConvert op
      acc :=
       [[op1,:[[sig,npred,:exposureTail] _
             for [sig,slot,pred,key,:.] in sublisFormal(subargs,u) |
	 (key ^= 'Subsumed) and (npred := simpHasPred pred)]],:acc]
    acc
  merge(alist,alist1) == --alist1 takes precedence
    for [op,:al] in alist1 repeat
      u := LASSOC(op,alist) =>
	for [sig,:item] in al | not LASSOC(sig,u) repeat
	  u := insertAlist(sig,item,u)
	alist := insertAlist(op,u,DELASC(op,alist)) --add merge of two alists
      alist := insertAlist(op,al,alist)	 --add the whole inner alist
    alist

zeroOneConvert x ==
  x = 'Zero => 0
  x = 'One  => 1
  x

kFormatSlotDomain x == fn formatSlotDomain x where fn x ==
  atom x => x
  (op := CAR x) = '_$ => '_$
  op = 'local => CADR x
  op = ":" => [":",CADR x,fn CADDR x]
  MEMQ(op,$Primitives) or constructor? op =>
    [fn y for y in x]
  INTEGERP op => op
  op = 'QUOTE and atom CADR x => CADR x
  x

koCatOps(conform,domname) ==
  conname := opOf conform
  oplist := REVERSE GETDATABASE(conname,'OPERATIONALIST)
  oplist := sublisFormal(IFCDR domname or IFCDR conform ,oplist)
  --check below for INTEGERP key to avoid subsumed signatures
  [[zeroOneConvert op,:nalist] for [op,:alist] in oplist _
                                              | nalist := koCatOps1(alist)]

koCatOps1 alist == [x for item in alist | x := pair] where
  pair ==
    [sig,:r] := item
    null r => [sig,true]
    [key,:options] := r
    null (pred := IFCAR options) =>
      IFCAR IFCDR options = 'ASCONST => [sig,'ASCONST]
      [sig,true]
    npred := simpHasPred pred => [sig,npred]
    false

koCatAttrs(catform,domname) ==
  $if: local := MAKE_-HASHTABLE 'ID
  catname   := opOf catform
  koCatAttrsAdd(domname or catform,true)
  ancestors := ancestorsOf(catform,domname)
  for [conform,:pred] in ancestors repeat koCatAttrsAdd(conform,pred)
  hashTable2Alist $if

hashTable2Alist tb ==
  [[op,:HGET(tb,op)] for op in listSort(function GLESSEQP,HKEYS $if)]

koCatAttrsAdd(catform,pred) ==
  for [name,argl,:p] in CAR getConstructorExports catform repeat
    npred  := quickAnd(pred,p)
    exists := HGET($if,name)
    if existingPred := LASSOC(argl,exists)_
        then npred := quickOr(npred,existingPred)
    if not MEMQ(name,'(nil nothing)) _
        then HPUT($if,name,[[argl,simpHasPred npred],:exists])

--=======================================================================
--	      Filter by Category
--=======================================================================

koaPageFilterByCategory(htPage,calledFrom) ==
  opAlist := htpProperty(htPage,'opAlist)
  which	  := htpProperty(htPage,'which)
  page := htInitPageNoScroll(htCopyProplist htPage,
             dbHeading(opAlist,which,htpProperty(htPage,'heading)))
  htSay('"Select a category ancestor below or ")
  htMakePage [['bcLispLinks,['"filter",'"on:",calledFrom,'filter]]]
  htMakePage [['bcStrings, [13,'"",'filter,'EM]]]
  htSay('"\beginscroll ")
  conform := htpProperty(htPage,'conform)
  domname := htpProperty(htPage,'domname)
  ancestors := ASSOCLEFT ancestorsOf(conform,domname)
  htpSetProperty(page,'ancestors,listSort(function GLESSEQP,ancestors))
  bcNameCountTable(ancestors,'form2HtString,'koaPageFilterByCategory1,true)
  htShowPage()

dbHeading(items,which,heading,:options) ==
  names?   := IFCAR options
  count :=
    names? => #items
    +/[#(rest x) for x in items]
  capwhich := capitalize which
  prefix :=
    count < 2 =>
      names? => pluralSay(count,STRCONC(capwhich," Name"),nil)
      pluralSay(count,capwhich,nil)
    names? => pluralSay(count,nil,STRCONC(capwhich," Names"))
    pluralSay(count,nil,pluralize capwhich)
  [:prefix,'" for ",:heading]

koaPageFilterByCategory1(htPage,i) ==
  ancestor := htpProperty(htPage,'ancestors) . i
  ancestorList := [ancestor,:ASSOCLEFT ancestorsOf(ancestor,nil)]
  newOpAlist := nil
  which	   := htpProperty(htPage,'which)
  opAlist  := htpProperty(htPage,'opAlist)
  domname  := htpProperty(htPage,'domname)
  conform  := htpProperty(htPage,'conform)
  heading  := htpProperty(htPage,'heading)
  docTable := dbDocTable(domname or conform)
  for [op,:alist] in opAlist repeat
    nalist := [[origin,:item] for item in alist | split]
      where split ==
	[sig,pred,:aux] := item
	u := dbGetDocTable(op,sig,docTable,which,aux)
	origin := IFCAR u
	doc    := IFCDR u
	true
    for [origin,:item] in nalist | origin repeat
      MEMBER(origin,ancestorList) =>
	newEntry   := [item,:LASSOC(op,newOpAlist)]
	newOpAlist := insertAlist(op,newEntry,newOpAlist)
  falist := nil
  for [op,:alist] in newOpAlist repeat
    falist := [[op,:NREVERSE alist],:falist]
  htpSetProperty(htPage,'fromcat,[_
                         '" from category {\sf ",form2HtString ancestor,'"}"])
  dbShowOperationsFromConform(htPage,which,falist)

--=======================================================================
--	     New code for search operation alist for exact matches
--=======================================================================

opPageFast opAlist == --called by oSearch
  htPage := htInitPage(nil,nil)
  htpSetProperty(htPage,'opAlist,opAlist)
  htpSetProperty(htPage,'expandOperations,'lists)
  which := '"operation"
--dbResetOpAlistCondition(htPage,which,opAlist)
  dbShowOp1(htPage,opAlist,which,'names)

opPageFastPath opstring ==
--return nil
  x := STRINGIMAGE opstring
  charPosition(char '_*,x,0) < #x => nil     --quit if name has * in it
  op := (STRINGP x => INTERN x; x)
  mmList := getAllModemapsFromDatabase(op,nil) or return nil
  opAlist := [[op,:[item for mm in mmList]]] where item ==
    [predList, origin, sig] := modemap2Sig(op, mm)
    predicate := predList and MKPF(predList,'AND)
    exposed? := isExposedConstructor opOf origin
    [sig, predicate, origin, exposed?]
  opAlist

modemap2Sig(op,mm) ==
  [dcSig, conds] := mm
  [dc, :sig] := dcSig
  partial? :=
    conds is ['partial,:r] => conds := r
    false
  condlist := modemap2SigConds conds
  [origin, vlist, flist] := getDcForm(dc, condlist) or return nil
  subcondlist := SUBLISLIS(flist, vlist, condlist)
  [predList,vlist, flist] := getSigSubst(subcondlist, nil, vlist, flist)
  if partial? then
    target := dcSig . 1
    ntarget := ['Union, target, '"failed"]
    dcSig := SUBST(ntarget, target, dcSig)
  alist := findSubstitutionOrder? pairlis(vlist, flist) or systemError()
  predList := substInOrder(alist, predList)
  nsig := substInOrder(alist, sig)
  if hasPatternVar nsig or hasPatternVar predList then
    pp '"--------------"
    pp op
    pp predList
    pp nsig
    pp mm
    $badStack := [[op, mm], :$badStack]
--pause nsig
  [predList, origin, SUBST("%", origin, nsig)]

modemap2SigConds conds ==
  conds is ['OR,:r] => modemap2SigConds first r
  conds is ['AND,:r] => r
  [conds]

hasPatternVar x ==
  IDENTP x and (x ^= "**") => isPatternVar x
  atom x => false
  or/[hasPatternVar y for y in x]

getDcForm(dc, condlist) ==
  [ofWord,id,cform] := or/[x for x in condlist | x is [k,=dc,:.]
     and MEMQ(k, '(ofCategory isDomain))] or return nil
  conform := getConstructorForm opOf cform
  ofWord = 'ofCategory =>
    [conform, ["*1", :rest cform], ["%", :rest conform]]
  ofWord = 'isDomain =>
    [conform, ["*1", :rest cform], ["%", :rest conform]]
  systemError()

getSigSubst(u, pl, vl, fl) ==
  u is [item, :r] =>
    item is ['AND,:s] =>
       [pl, vl, fl] := getSigSubst(s, pl, vl, fl)
       getSigSubst(r, pl, vl, fl)
    [key, v, f] := item
    key = 'isDomain => getSigSubst(r, pl, [v, :vl], [f, :fl])
    key = 'ofCategory => getSigSubst(r, pl, ['D, :vl], [f, :fl])
    key = 'ofType    => getSigSubst(r, pl, vl, fl)
    key = 'has => getSigSubst(r, [item, :pl], vl, fl)
    key = 'not => getSigSubst(r, [item, :pl], vl, fl)
    systemError()
  [pl, vl, fl]


pairlis(u,v) ==
  null u or null v => nil
  [[first u,:first v],:pairlis(rest u, rest v)]


--====================> WAS b-search.boot <================================

--=======================================================================
--              Grepping Database libdb.text
-- Redone 12/95 for Saturn; previous function grep renamed as grepFile
-- This function now either returns a filename or a list of strings
--=======================================================================
grepConstruct(s,key,:options) == --key = a o c d p x k (all) . (aok) w (doc)
--Called from genSearch with key = "." and "w"
--key = "." means a o c d p x
--option1 = true means return the result as a file
--All searches of the database call this function to get relevant lines
--from libdb.text. Returns either a list of lines (usual case) or else
--an alist of the form ((kind . <list of lines for that kind>) ...)
  $localLibdb : local := fnameExists? '"libdb.text" and '"libdb.text"
  lines := grepConstruct1(s,key)
  IFCAR options => grepSplit(lines,key = 'w)    --leave now if a constructor
  MEMQ(key,'(o a)) => dbScreenForDefaultFunctions lines --kill default lines if a/o
  lines

grepConstruct1(s,key) ==
--returns the name of file (WITHOUT .text.$SPADNUM on the end)
  $key     : local := key
  if key = 'k and          --convert 'k to 'y if name contains an "&"
    or/[s . i = char '_& for i in 0..MAXINDEX s] then key := 'y
  filter := pmTransFilter STRINGIMAGE s  --parses and-or-not form
  filter is ['error,:.] => filter        --exit on parser error
  pattern := mkGrepPattern(filter,key)  --create string to pass to "grep"
  grepConstructDo(pattern, key)  --do the "grep"---see b-saturn.boot

grepConstructDo(x, key) ==
  $orCount := 0
--atom x => grepFile(x, key,'i)
  $localLibdb =>
    oldLines := purgeNewConstructorLines(grepf(x,key,false),$newConstructorList)
    newLines := grepf(x,$localLibdb,false)
    UNION(oldLines, newLines)
  grepf(x,key,false)

dbExposed?(line,kind) == -- does line come from an unexposed constructor?
  conname := INTERN
    kind = char 'a or kind = char 'o => dbNewConname line --get conname from middle
    dbName line
  isExposedConstructor conname

dbScreenForDefaultFunctions lines == [x for x in lines | not isDefaultOpAtt x]

isDefaultOpAtt x == x.(1 + dbTickIndex(x,4,0)) = char 'x

grepForAbbrev(s,key) ==
--checks that filter s is not * and is all uppercase; if so, look for abbrevs
  u := HGET($lowerCaseConTb,s) => ['Abbreviations,u]    --try cheap test first
  s := STRINGIMAGE s
  someLowerCaseChar := false
  someUpperCaseChar := false
  for i in 0..MAXINDEX s repeat
    c := s . i
    LOWER_-CASE_-P c => return (someLowerCaseChar := true)
    UPPER_-CASE_-P c => someUpperCaseChar := true
  someLowerCaseChar or not someUpperCaseChar => false
  pattern := DOWNCASE s
  ['Abbreviations ,:[GETDATABASE(x,'CONSTRUCTORFORM)
    for x in allConstructors() | test]] where test ==
         not $includeUnexposed? and not isExposedConstructor x => false
         a := GETDATABASE(x,'ABBREVIATION)
         match?(pattern,PNAME a) and not HGET($defaultPackageNamesHT,x)

applyGrep(x,filename) ==   --OBSELETE with $saturn--> see applyGrepSaturn
  atom x => grepFile(x,filename,'i)
  $localLibdb =>
    a := purgeNewConstructorLines(grepf(x,filename,false),$newConstructorList)
    b := grepf(x,$localLibdb,false)
    grepCombine(a,b)
  grepf(x,filename,false)

grepCombine(a,b) == MSORT UNION(a,b)

grepf(pattern,s,not?) ==  --s=sourceFile or list of strings
  pattern is [op,:argl] =>
    op = "and" =>
      while argl is [arg,:argl] repeat
        s := grepf(arg,s,not?)  -- filter by successive greps
      s
    op = "or" =>
      targetStack := nil
      "UNION"/[grepf(arg,s,not?) for arg in argl]
    op = "not" =>
      not? => grepf(first argl,s,false)
      --could be the first time so have to get all of same $key
      lines := grepf(mkGrepPattern('"*",$key),s,false)
      grepf(first argl,lines,true)
    systemError nil
  option :=
    not? => 'iv
    'i
  source :=
    LISTP s => dbWriteLines s
    s
  grepFile(pattern,source,option)

pmTransFilter s ==
--result is either a string or (op ..) where op= and,or,not and arg are results
  if $browseMixedCase = true then s := DOWNCASE s
  or/[isFilterDelimiter? s.i or s.i = $charUnderscore for i in 0..MAXINDEX s]
    => (parse := pmParseFromString s) and checkPmParse parse or
        ['error,'"Illegal search string",'"\vspace{3}\center{{\em Your search string} ",escapeSpecialChars s,'" {\em has incorrect syntax}}"]
  or/[s . i = char '_* and s.(i + 1) = char '_*
      and (i=0 or s . (i - 1) ^= char $charUnderscore) for i in 0..(MAXINDEX s - 1)]
       => ['error,'"Illegal search string",'"\vspace{3}\center{Consecutive {\em *}'s are not allowed in search patterns}"]
  s

checkPmParse parse ==
  STRINGP parse => parse
  fn parse => parse where fn(u) ==
    u is [op,:args] =>
      MEMQ(op,'(and or not)) and and/[checkPmParse x for x in args]
    STRINGP u => true
    false
  nil

dnForm x ==
  STRINGP x => x
  x is ['not,argl] =>
    argl is ['or,:orargs]=>
       ['and, :[dnForm negate u for u in orargs]] where negate s ==
          s is ['not,argx] => argx
          ['not,s]
    argl is ['and,:andargs]=>
       ['or,:[dnForm negate u for u in andargs]]
    argl is ['not,notargl]=>
       dnForm notargl
    x
  x is ['or,:argl1] => ['or,:[dnForm u for u in argl1]]
  x is ['and,:argl2] => ['and,:[dnForm u for u in argl2]]
  x

pmParseFromString s ==
  u := ncParseFromString pmPreparse s
  dnForm flatten u where flatten s ==
    s is [op,:argl] =>
      STRINGP op => STRCONC(op,"STRCONC"/[STRCONC('" ",x) for x in argl])
      [op,:[flatten x for x in argl]]
    s

pmPreparse s == hn fn(s,0,#s) where--stupid insertion of chars to get correct parse
  hn x == SUBLISLIS('(and or not),'("and" "or" "not"),x)
  fn(s,n,siz) ==  --main function: s is string, n is origin
    n = siz => '""
    i := firstNonDelim(s,n) or return SUBSTRING(s,n,nil)
    j := firstDelim(s,i + 1) or siz
    t := gn(s,i,j - 1)
    middle :=
      MEMBER(t,'("and" "or" "not")) => t
      --the following 2 lines make commutative("*") parse correctly!!!!
      t.0 = char '_" => t
      j < siz - 1 and s.j = char '_( => t
      STRCONC(char '_",t,char '_")
    STRCONC(SUBSTRING(s,n,i - n),middle,fn(s,j,siz))
  gn(s,i,j) ==    --replace each underscore by 4 underscores!
    n := or/[k for k in i..j | s.k = $charUnderscore] =>
      STRCONC(SUBSTRING(s,i,n - i + 1),$charUnderscore,gn(s,n + 1,j))
    SUBSTRING(s,i,j - i + 1)

firstNonDelim(s,n) ==  or/[k for k in n..MAXINDEX s | not isFilterDelimiter? s.k]
firstDelim(s,n) ==  or/[k for k in n..MAXINDEX s | isFilterDelimiter? s.k]

isFilterDelimiter? c == MEMQ(c,$pmFilterDelimiters)

grepSplit(lines,doc?) ==
  if doc? then
    instream2 := OPEN STRCONC(getEnv '"AXIOM",'"/algebra/libdb.text")
  cons := atts := doms := nil
  while lines is [line, :lines] repeat
    if doc? then
        N:=PARSE_-INTEGER dbPart(line,1,-1)
        if NUMBERP N then 
           FILE_-POSITION(instream2,N)
           line := READLINE instream2
    kind := dbKind line
    not $includeUnexposed? and not dbExposed?(line,kind) => 'skip
    (kind = char 'a or kind = char 'o) and isDefaultOpAtt line => 'skip
    PROGN
      kind = char 'c => cats := insert(line,cats)
      kind = char 'd => doms := insert(line,doms)
      kind = char 'x => defs := insert(line,defs)
      kind = char 'p => paks := insert(line,paks)
      kind = char 'a => atts := insert(line,atts)
      kind = char 'o => ops :=  insert(line,ops)
      kind = char '_- => 'skip                --for now
      systemError 'kind
  if doc? then CLOSE instream2
  [['"attribute",:NREVERSE atts],
     ['"operation",:NREVERSE ops],
       ['"category",:NREVERSE cats],
         ['"domain",:NREVERSE doms],
           ['"package",:NREVERSE paks]
--           ['"default_ package",:NREVERSE defs]   -- drop defaults
               ]

mkUpDownPattern s == recurse(s,0,#s) where
  recurse(s,i,n) ==
    i = n => '""
    STRCONC(fixchar(s.i),recurse(s,i + 1,n))
  fixchar(c) ==
    ALPHA_-CHAR_-P c =>
      STRCONC(char '_[,CHAR_-UPCASE c,CHAR_-DOWNCASE c,char '_])
    c

mkGrepPattern(s,key) ==
  --called by grepConstruct1 and grepf
  atom s => mkGrepPattern1(s,key)
  [first s,:[mkGrepPattern(x,key) for x in rest s]]

mkGrepPattern1(x,:options) == --called by mkGrepPattern (and grepConstructName?)
  $options : local := options
  s := STRINGIMAGE x
--s := DOWNCASE STRINGIMAGE x
  addOptions remUnderscores addWilds split(g s,char '_*) where
    addWilds sl ==    --add wild cards (sl is list of parts between *'s)
      IFCAR sl = '"" => h(IFCDR sl,[$wild1])
      h(sl,nil)
    g s  ==    --remove "*"s around pattern for text match
      not MEMQ('w,$options) => s
      if s.0 = char '_* then s := SUBSTRING(s,1,nil)
      if s.(k := MAXINDEX s) = char '_* then s := SUBSTRING(s,0,k)
      s
    h(sl,res) == --helper for wild cards
      sl is [s,:r] => h(r,[$wild1,s,:res])
      res := rest res
      if not MEMQ('w,$options) then
        if first res ^= '"" then res := ['"`",:res]
        else if res is [.,p,:r] and p = $wild1 then res := r
      "STRCONC"/NREVERSE res
    remUnderscores s ==
      (k := charPosition(char $charUnderscore,s,0)) < MAXINDEX s =>
        STRCONC(SUBSTRING(s,0,k),'"[",s.(k + 1),'"]",
                remUnderscores(SUBSTRING(s,k + 2,nil)))
      s
    split(s,char) ==
      max := MAXINDEX s + 1
      f := -1
      [SUBSTRING(s,i,f-i)
        while ((i := f + 1) <= max) and (f := charPosition(char,s,i))]
    charPosition(c,t,startpos) ==  --honors underscores
      n := SIZE t
      if startpos < 0 or startpos > n then error "index out of range"
      k:= startpos
      for i in startpos .. n-1 while c ^= ELT(t,i)
        or i > startpos and ELT(t,i-1) = '__ repeat  (k := k+1)
      k
    addOptions s ==  --add front anchor
      --options a o c d p x   denote standard items
      --options w             means  comments
      --option  t             means  text
      --option  s             means  signature
      --option  n             means  number of arguments
      --option  i             means  predicate
      --option  none          means  NO PREFIX
      one := ($options is [x,:$options] and x => x; '"[^x]")
      tick := '"[^`]*`"
      one = 'w => s
      one = 'none => (s = '"`" => '"^."; STRCONC('"^",s))
      prefix :=
        one = 't => STRCONC(tick,tick,tick,tick,tick,".*")
        one = 'n => tick
        one = 'i => STRCONC(tick,tick,tick,tick)
        one = 's => STRCONC(tick,tick,tick)
--      true => '""    ----> never put on following prefixes
        one = 'k => '"[cdp]"
        one = 'y => '"[cdpx]"
        STRINGIMAGE one
      s = $wild1 => STRCONC('"^",prefix)
      STRCONC('"^",prefix,s)

conform2OutputForm(form) ==
  [op,:args] := form
  null args => form
  cosig := rest GETDATABASE(op,'COSIG)
  atypes := rest CDAR GETDATABASE(op,'CONSTRUCTORMODEMAP)
  sargl := [fn for x in args for atype in atypes for pred in cosig] where fn ==
    pp [x,atype,pred]
    pred => conform2OutputForm x
    typ := sublisFormal(args,atype)
    if x is ['QUOTE,a] then x := a
    algCoerceInteractive(x,typ,'(OutputForm))
  [op,:sargl]

oPage(a,:b) == --called by \spadfun{opname}
  oSearch (IFCAR b or a) --always take slow path

oPageFrom(opname,conname) == --called by \spadfunFrom{opname}{conname}
  htPage := htInitPage(nil,nil) --create empty page and fill in needed properties
  htpSetProperty(htPage,'conform,conform := getConstructorForm conname)
  htpSetProperty(htPage,'kind,STRINGIMAGE GETDATABASE(conname,'CONSTRUCTORKIND))
  itemlist := ASSOC(opname,koOps(conform,nil)) --all operations name "opname"
  null itemlist => systemError [conform,'" has no operation named ",opname]
  opAlist := [itemlist]
  dbShowOperationsFromConform(htPage,'"operation",opAlist)

aPage(a,:b) ==  --called by \spadatt{a}
  $attributeArgs : local := nil
  arg := IFCAR b or a
  s   := pmParseFromString STRINGIMAGE arg
  searchOn :=
    ATOM s => s
    IFCAR s
  $attributeArgs : local := IFCAR IFCDR s
  aSearch searchOn
--must recognize that not all attributes can be found in database
--e.g. constant(deriv) is not but appears in a conditional in LODO

spadType(x) ==  --called by \spadtype{x} from HyperDoc
  s := PNAME x
  form := ncParseFromString s or
            systemError ['"Argument: ",s,'" to spadType won't parse"]
  if atom form then form := [form]
  op    := opOf form
  looksLikeDomainForm form => APPLY(function conPage,form)
  conPage(op)

looksLikeDomainForm x ==
  entry := getCDTEntry(opOf x,true) or return false
  coSig := LASSOC('coSig,CDDR entry)
  k := #coSig
  atom x => k = 1
  k ^= #x => false
  and/[p for key in rest coSig for arg in rest x] where
    p ==
      key => looksLikeDomainForm arg
      not IDENTP arg

spadSys(x) ==   --called by \spadsyscom{x}
  s := PNAME x
  if s.0 = char '_) then s := SUBSTRING(s,1,nil)
  form := ncParseFromString s or
           systemError ['"Argument: ",s,'" to spadType won't parse"]
  htSystemCommands PNAME opOf form

--=======================================================================
--                   Name and General Search
--=======================================================================
aokSearch filter ==  genSearch(filter,true)  --"General" from HD (see man0.ht)
--General search for constructs but NOT documentation

genSearch(filter,:options) == --"Complete" from HD (see man0.ht) and aokSearch
--General + documentation search
  null (filter := checkFilter filter) => nil  --in case of filter error
  filter = '"*" => htErrorStar()
  includeDoc? := not IFCAR options
--give summaries for how many a o c d p x match filter
  regSearchAlist := grepConstruct(STRINGIMAGE filter,".",true)
  regSearchAlist is ['error,:.] => bcErrorPage regSearchAlist
  key := removeSurroundingStars filter
  if includeDoc? then
    docSearchAlist := grepConstruct(key,'w,true)
    docSearchAlist is ['error,:.] => bcErrorPage docSearchAlist
    docSearchAlist := [x for x in docSearchAlist | x.0 ^= char 'x]--drop defaults
  genSearch1(filter,genSearchTran regSearchAlist,genSearchTran docSearchAlist)

genSearchTran alist == [[x,y,:y] for [x,:y] in alist]


genSearch1(filter,reg,doc) ==
  regSearchAlist := searchDropUnexposedLines reg
  docSearchAlist := searchDropUnexposedLines doc
  key := removeSurroundingStars filter
  regCount := searchCount regSearchAlist
  docCount := searchCount docSearchAlist
  count := regCount + docCount
  count = 0 => emptySearchPage('"entry",filter,true)
  count = 1 =>
    alist := (regCount = 1 => regSearchAlist; docSearchAlist)
    showNamedConstruct(or/[x for x in alist | CADR x])
  summarize? :=
    docSearchAlist => true
    nonEmpties := [pair for pair in regSearchAlist | #(CADR pair) > 0]
    not(nonEmpties is [pair])
  not summarize? => showNamedConstruct pair
  -----------generate a summary page---------------------------
  plural :=
    $exposedOnlyIfTrue => '"exposed entries match"
    '"entries match"
  prefix := pluralSay(count,'"", plural)
  emfilter := ['"{\em ",escapeSpecialChars STRINGIMAGE filter,'"}"]
  header := [:prefix,'" ",:emfilter]
  page := htInitPage(header,nil)
  htpSetProperty(page,'regSearchAlist,regSearchAlist)
  htpSetProperty(page,'docSearchAlist,docSearchAlist)
  htpSetProperty(page,'filter,filter)
  if docSearchAlist then
      dbSayItems(['"{\bf Construct Summary:} ",regCount],'"name matches",'"names match")
  for [kind,:pair] in regSearchAlist for i in 0.. | #(first pair) > 0 repeat
    bcHt '"\newline{}"
    htSayStandard '"\tab{2}"
    genSearchSay(pair,summarize?,kind,i,'showConstruct)
  if docSearchAlist then
    htSaySaturn '"\bigskip{}"
    dbSayItems(['"\newline{\bf Documentation Summary:} ",docCount],'"mention",'"mentions",'" of {\em ",key,'"}")
    for [kind,:pair] in docSearchAlist for i in 0.. | #(first pair) > 0 repeat
      bcHt "\newline{}"
      htSayStandard '"\tab{2}"
      genSearchSay(pair,true,kind,i,'showDoc)
  htShowPageStar()
searchDropUnexposedLines alist ==
  [[op,[pred for line in lines | pred],:lines] for [op,.,:lines] in alist] where
    pred ==
      not $exposedOnlyIfTrue or dbExposed?(line,dbKind line) => line
      nil

htShowPageStar() ==
------------> OBSELETE
  htSayStandard '"\endscroll "
  if $exposedOnlyIfTrue then
    htMakePage [['bcLinks,['"Exposed",'" {\em only}",'repeatSearch,NIL]]]
  else
    htSay('"*{\em =}")
    htMakePage [['bcLinks,['"unexposed",'"",'repeatSearch,'T]]]
  htShowPageNoScroll()

repeatSearch(htPage,newValue) ==
  $exposedOnlyIfTrue := newValue
  filter := htpProperty(htPage,'filter)
  reg    := htpProperty(htPage,'regSearchAlist)
  doc    := htpProperty(htPage,'docSearchAlist)
  reg => genSearch1(filter,reg,doc)
  docSearch1(filter,doc)

searchCount u == +/[# y for [x,y,:.] in u]

showDoc(htPage,count) ==
  showIt(htPage,count,htpProperty(htPage,'docSearchAlist))

showConstruct(htPage,count) ==
  showIt(htPage,count,htpProperty(htPage,'regSearchAlist))

showIt(htPage,index,searchAlist) ==
  filter      := htpProperty(htPage,'filter)
  [relativeIndex,n] := DIVIDE(index,8)
  relativeIndex = 0 => showNamedConstruct(searchAlist.n)
  [kind,items,:.] := searchAlist . n
  for j in 1.. while j < relativeIndex repeat items := rest items
  firstName := dbName first items --select name then gather all of same name
  lines := [line for line in items while dbName line = firstName]
  showNamedConstruct [kind,nil,:lines]

showNamedConstruct([kind,.,:lines]) == dbSearch(lines,kind,'"")

genSearchSay(pair,summarize,kind,who,fn) ==
  [u,:fullLineList] := pair
  count := #u
  uniqueCount := genSearchUniqueCount u
  short := summarize and uniqueCount >= $browseCountThreshold
  htMakePage
    [['bcLinks,[menuButton(),'"",'genSearchSayJump,[fullLineList,kind]]]]
  if count = 0 then htSay('"{\em No ",kind,'"} ")
  else if count = 1 then
    htSay('"{\em 1 ",kind,'"} ")
  else
    htSay('"{\em ",count,'" ",pluralize kind,'"} ")
  short => 'done	
  if uniqueCount ^= 1 then
    htSayStandard '"\indent{4}"
    htSay '"\newline "
    htBeginTable()
  lastid := nil
  groups := organizeByName u
  i := 1
  for group in groups repeat
    id := dbGetName first group
    if $includeUnexposed? then
      exposed? := or/[dbExposed?(item,dbKind item) for item in group]
    bcHt '"{"
    if $includeUnexposed? then
        exposed? => htBlank()
        htSayUnexposed()
    htMakePage [['bcLinks, [id,'"",fn,who + 8*i]]]
    i := i + #group
    bcHt '"}"
  if uniqueCount ^= 1 then
     htEndTable()
     htSayStandard '"\indent{0}"

organizeByName u ==
  [[(u := rest u; x) while u and head = dbName (x := first u)]
      while u and (head := dbName first u)]

genSearchSayJump(htPage,[lines,kind]) ==
  filter := htpProperty(htPage,'filter)
  dbSearch(lines,kind,filter)

genSearchUniqueCount(u) ==
--count the unique number of items (if less than $browseCountThreshold)
  count := 0
  lastid := nil
  for item in u while count < $browseCountThreshold repeat
    id := dbGetName item
    if id ^= lastid then
      count := count + 1
      lastid := id
  count

dbGetName line == SUBSTRING(line,1,charPosition($tick,line,1) - 1)

pluralSay(count,singular,plural,:options) ==
  item := (options is [x,:options] => x; '"")
  colon := (IFCAR options => '":"; '"")
  count = 0 => concat('"No ",singular,item)
  count = 1 => concat('"1 ",singular,item,colon)
  concat(count,'" ",plural,item,colon)


--=======================================================================
--                   Documentation Search
--=======================================================================
docSearch filter ==  --"Documentation" from HD (see man0.ht)
  null (filter := checkFilter filter) => nil  --in case of filter error
  filter = '"*" => htErrorStar()
  key := removeSurroundingStars filter
  docSearchAlist := grepConstruct(filter,'w,true)
  docSearchAlist is ['error,:.] => bcErrorPage docSearchAlist
  docSearchAlist := [x for x in docSearchAlist | x.0 ^= char 'x] --drop defaults
  docSearch1(filter,genSearchTran docSearchAlist)

docSearch1(filter,doc) ==
  docSearchAlist := searchDropUnexposedLines doc
  count := searchCount docSearchAlist
  count = 0 => emptySearchPage('"entry",filter,true)
  count = 1 => showNamedConstruct(or/[x for x in docSearchAlist | CADR x],1)
  prefix := pluralSay(count,'"entry matches",'"entries match")
  emfilter := ['"{\em ",escapeSpecialChars STRINGIMAGE filter,'"}"]
  header := [:prefix,'" ",:emfilter]
  page := htInitPage(header,nil)
  htpSetProperty(page,'docSearchAlist,docSearchAlist)
  htpSetProperty(page,'regSearchAlist,nil)
  htpSetProperty(page,'filter,filter)
  dbSayItems(['"\newline Documentation Summary: ",count],'"mention",'"mentions",'" of {\em ",filter,'"}")
  for [kind,:pair] in docSearchAlist for i in 0.. | #(first pair) > 0 repeat
    bcHt '"\newline{}"
    htSayStandard '"\tab{2}"
    genSearchSay(pair,true,kind,i,'showDoc)
  htShowPageStar()

removeSurroundingStars filter ==
  key := STRINGIMAGE filter
  if key.0 = char '_* then key := SUBSTRING(key,1,nil)
  if key.(max := MAXINDEX key) = char '_* then key := SUBSTRING(key,0,max)
  key

showNamedDoc([kind,:lines],index) ==
  dbGather(kind,lines,index - 1,true)

sayDocMessage message ==
  htSay('"{\em ")
  if message is [leftEnd,left,middle,right,rightEnd] then
    htSay(leftEnd,left,'"}")
    if left ^= '"" and left.(MAXINDEX left) = $blank then htBlank()
    htSay middle
    if right ^= '"" and right.0 = $blank then htBlank()
    htSay('"{\em ",right,rightEnd)
  else
    htSay message
  htSay ('"}")

stripOffSegments(s,n) ==
  progress := true
  while n > 0 and progress = true repeat
    n := n - 1
    k := charPosition(char '_`,s,0)
    new := SUBSTRING(s,k + 1,nil)
    #new < #s => s := new
    progress := false
  n = 0 => s
  nil

replaceTicksBySpaces s ==
  n := -1
  max := MAXINDEX s
  while (n := charPosition(char '_`,s,n + 1)) <= max repeat SETELT(s,n,char '_ )
  s

checkFilter filter ==
  filter := STRINGIMAGE filter
  filter = '"" => '"*"
  trimString filter

aSearch filter ==  --called from HD (man0.ht): general attribute search
  null (filter := checkFilter filter) => nil  --in case of filter error
  dbSearch(grepConstruct(filter,'a),'"attribute",filter)

oSearch filter == -- called from HD (man0.ht): operation search
  opAlist := opPageFastPath filter => opPageFast opAlist
  key := 'o
  null (filter := checkFilter filter) => nil  --in case of filter error
  filter = '"*" => grepSearchQuery('"operation",[filter,key,'"operation",'oSearchGrep])
  oSearchGrep(filter,key,'"operation")

oSearchGrep(filter,key,kind) == --called from grepSearchQuery/oSearch
  dbSearch(grepConstruct(filter,'o),kind,filter)

grepSearchQuery(kind,items) ==
  page := htInitPage('"Query Page",nil)
  htpSetProperty(page,'items,items)
  htQuery(['"{\em Do you want a list of {\em all} ",pluralize kind,'"?\vspace{1}}"],'grepSearchJump,true)
  htShowPage()

cSearch filter ==  --called from HD (man0.ht): category search
   constructorSearch(checkFilter filter,'c,'"category")

dSearch filter ==  --called from HD (man0.ht): domain search
   constructorSearch(checkFilter filter,'d,'"domain")

pSearch filter ==  --called from HD (man0.ht): package search
   constructorSearch(checkFilter filter,'p,'"package")

xSearch filter ==  --called from HD (man0.ht): default package search
   constructorSearch(checkFilter filter,'x,'"default package")

kSearch filter ==  --called from HD (man0.ht): constructor search (no defaults)
   constructorSearch(checkFilter filter,'k,'"constructor")

ySearch filter == --called from conPage: like kSearch but defaults included
  constructorSearch(checkFilter filter,'y,'"constructor")

constructorSearch(filter,key,kind) ==
  null filter => nil      --in case of filter error
  (parse := conSpecialString? filter) => conPage parse
  pageName := LASSOC(DOWNCASE filter,'(("union" . DomainUnion)("record" . DomainRecord)("mapping" . DomainMapping) ("enumeration" . DomainEnumeration))) =>
    downlink pageName
  name := (STRINGP filter => INTERN filter; filter)
  if u := HGET($lowerCaseConTb,name) then filter := STRINGIMAGE first u
  line := conPageFastPath DOWNCASE filter =>
    code := dbKind line
    newkind :=
      code = char 'p => '"package"
      code = char 'd => '"domain"
      code = char 'c => '"category"
      nil
    kind = '"constructor" or kind = newkind => kPage line
    page := htInitPage('"Query Page",nil)
    htpSetProperty(page,'line,line)
    message :=
      ['"{\em ",dbName line,'"} is not a {\em ",kind,'"} but a {\em ",
        newkind,'"}. Would you like to view it?\vspace{1}"]
    htQuery(message, 'grepConstructorSearch,true)
    htShowPage()
  filter = '"*" => grepSearchQuery(kind,[filter,key,kind,'constructorSearchGrep])
  constructorSearchGrep(filter,key,kind)

grepConstructorSearch(htPage,yes) == kPage htpProperty(htPage,'line)

conSpecialString?(filter,:options) ==
  secondTime := IFCAR options
  parse :=
    words := string2Words filter is [s] => ncParseFromString s
    and/[not MEMBER(x,'("and" "or" "not")) for x in words] => ncParseFromString filter
    false
  null parse => nil
  form := conLowerCaseConTran parse
  MEMQ(KAR form,'(and or not)) or CONTAINED("*",form) => nil
  filter = '"Mapping" =>nil
  u := kisValidType form => u
  secondTime => false
  u := "STRCONC"/[string2Constructor x for x in dbString2Words filter]
  conSpecialString?(u, true)

dbString2Words l ==
  i := 0
  [w while dbWordFrom(l,i) is [w,i]]

$dbDelimiters := [char " " , char "(", char ")"]

dbWordFrom(l,i) ==
  maxIndex := MAXINDEX l
  while maxIndex >= i and l.i = char " " repeat i := i + 1
  if maxIndex >= i and MEMBER(l.i, $dbDelimiters) then return [l.i, i + 1]
  k := or/[j for j in i..maxIndex | not MEMBER(l.j, $dbDelimiters)] or return nil
  buf := '""
  while k <= maxIndex and not MEMBER(c := l.k, $dbDelimiters) repeat
    ch :=
      c = char '__   => l.(k := 1+k)  --this may exceed bounds
      c
    buf := STRCONC(buf,ch)
    k := k + 1
  [buf,k]

conLowerCaseConTran x ==
  IDENTP x => IFCAR HGET($lowerCaseConTb, x) or x
  atom x   => x
  [conLowerCaseConTran y for y in x]

string2Constructor x ==
  not STRINGP x => x
  IFCAR HGET($lowerCaseConTb, INTERN DOWNCASE x) or x

conLowerCaseConTranTryHarder x ==
  IDENTP x => IFCAR HGET($lowerCaseConTb,DOWNCASE x) or x
  atom x   => x
  [conLowerCaseConTranTryHarder y for y in x]

constructorSearchGrep(filter,key,kind) ==
  dbSearch(grepConstruct(filter,key),kind,filter)

grepSearchJump(htPage,yes) ==
  [filter,key,kind,fn] := htpProperty(htPage,'items)
  FUNCALL(fn,filter,key,kind)

--=======================================================================
--            Branch Functions After Database Search
--=======================================================================
dbSearch(lines,kind,filter) == --called by attribute, operation, constructor search
  lines is ['error,:.] => bcErrorPage lines
  null filter => nil      --means filter error
  lines is ['Abbreviations,:r] => dbSearchAbbrev(lines,kind,filter)
  if MEMBER(kind,'("attribute" "operation")) then --should not be necessary!!
    lines := dbScreenForDefaultFunctions lines
  count := #lines
  count = 0 => emptySearchPage(kind,filter)
  MEMBER(kind,'("attribute" "operation")) => dbShowOperationLines(kind,lines)
  dbShowConstructorLines lines

dbSearchAbbrev([.,:conlist],kind,filter) ==
  null conlist => emptySearchPage('"abbreviation",filter)
  kind := intern kind
  if kind ^= 'constructor then
    conlist := [x for x in conlist | LASSOC('kind,IFCDR IFCDR x) = kind]
  conlist is [[nam,:.]] => conPage DOWNCASE nam
  cAlist := [[con,:true] for con in conlist]
  htPage := htInitPage('"",nil)
  htpSetProperty(htPage,'cAlist,cAlist)
  htpSetProperty(htPage,'thing,nil)
  return dbShowCons(htPage,'names)
  page := htInitPage([#conlist,
    '" Abbreviations Match {\em ",STRINGIMAGE filter,'"}"],nil)
  for [nam,abbr,:r] in conlist repeat
    kind := LASSOC('kind,r)
    htSay('"\newline{\em ",s := STRINGIMAGE abbr)
    htSayStandard '"\tab{10}"
    htSay '"}"
    htSay kind
    htSayStandard '"\tab{19}"
    bcCon nam
  htShowPage()

--=======================================================================
--                   Selectable Search
--=======================================================================
detailedSearch(filter) ==
  page := htInitPage('"Detailed Search with Options",nil)
  filter   := escapeSpecialChars PNAME filter
  bcHt '"Select what you want to search for, then click on {\em Search} below"
  bcHt '"\newline{\it Note:} Logical searches using {\em and}, {\em or}, and {\em not} are not permitted here."
  htSayHrule()
  htMakePage '(
    (text . "\newline")
    (bcRadioButtons which
      (  "\tab{3}{\em Operations}"
         ((text . "\newline\space{3}")
          (text . "name")       (bcStrings (14 "*" opname EM))
          (text . " \#args")    (bcStrings (1  "*" opnargs EM))
          (text . " signature") (bcStrings (14 "*" opsig EM))
          (text . "\vspace{1}\newline "))
         ops)
      (  "\tab{3}{\em Attributes}"
         ((text . "\newline\space{3}")
          (text . "name")       (bcStrings (14 "*" attrname EM))
          (text . " \#args ")   (bcStrings (1  "*" attrnargs EM))
          (text . " arguments ")(bcStrings (14 "*" attrargs EM))
          (text . "\vspace{1}\newline "))
         attrs)
      (  "\tab{3}{\em Constructors}"
         ((text . "\tab{17}")
          (bcButtons (1 cats)) (text . " {\em categories} ")
          (bcButtons (1 doms)) (text . " {\em domains} ")
          (bcButtons (1 paks)) (text . " {\em packages} ")
          (bcButtons (1 defs)) (text . " {\em defaults} ")
          (text . "\newline\tab{3}")
          (text . "name")   (bcStrings (14 "*" conname EM))
          (text . " \#args") (bcStrings (1  "*" connargs EM))
          (text . "signature") (bcStrings (14 "*" consig EM))
          (text . "\vspace{1}\newline "))
          cons)
--      (   "\tab{3}{\em Documentation}"
--          ((text . "\tab{26}key")
--           (bcStrings (28 "*" docfilter EM)))
--          doc)
                )
    (text . "\vspace{1}\newline\center{ ")
    (bcLinks ("\box{Search}" "" generalSearchDo NIL))
    (text . "}"))
  htShowPage()

generalSearchDo(htPage,flag) ==
--$exposedOnlyIfTrue := (flag => 'T; nil)
  $htPage := htPage
  alist := htpInputAreaAlist htPage
  which := htpButtonValue(htPage,'which)
  selectors :=
    which = 'cons => '(conname connargs consig)
    which = 'ops  => '(opname  opnargs  opsig)
    '(attrname attrnargs attrargs)
  name := generalSearchString(htPage,selectors.0)
  nargs:= generalSearchString(htPage,selectors.1)
  npat := standardizeSignature generalSearchString(htPage,selectors.2)
  kindCode :=
    which = 'ops => char 'o
    which = 'attrs => char 'a
    acc := '""
    if htButtonOn?(htPage,'cats) then acc := STRCONC(char 'c,acc)
    if htButtonOn?(htPage,'doms) then acc := STRCONC(char 'd,acc)
    if htButtonOn?(htPage,'paks) then acc := STRCONC(char 'p,acc)
    if htButtonOn?(htPage,'defs) then acc := STRCONC(char 'x,acc)
    n := #acc
    n = 0 or n = 4 => '"[cdpx]"
    n = 1 => acc
    STRCONC(char '_[,acc,char '_])
  form := mkDetailedGrepPattern(kindCode,name,nargs,npat)
  lines := applyGrep(form,'libdb)
--lines := dbReadLines resultFile
  if MEMQ(which,'(ops attrs)) then lines := dbScreenForDefaultFunctions lines
  kind :=
    which = 'cons =>
      n = 1 =>
        htButtonOn?(htPage,'cats) => '"category"
        htButtonOn?(htPage,'doms) => '"domain"
        htButtonOn?(htPage,'paks) => '"package"
        '"default package"
      '"constructor"
    which = 'ops  => '"operation"
    '"attribute"
  null lines => emptySearchPage(kind,nil)
  dbSearch(lines,kind,'"filter")

generalSearchString(htPage,sel) ==
  string := htpLabelInputString(htPage,sel)
  string = '"" => '"*"
  string

htButtonOn?(htPage,key) ==
  LASSOC(key,htpInputAreaAlist htPage) is [a,:.] and a = '" t"

mkDetailedGrepPattern(kind,name,nargs,argOrSig) == main where
  main ==
    nottick := '"[^`]"
    name := replaceGrepStar name
    firstPart :=
      $saturn => STRCONC(char '_^,name)
      STRCONC(char '_^,kind,name)
    nargsPart := replaceGrepStar nargs
    exposedPart := char '_.   --always get exposed/unexposed
    patPart := replaceGrepStar argOrSig
    simp STRCONC(conc(firstPart,conc(nargsPart,conc(exposedPart, patPart))),$tick)
  conc(a,b) ==
    b = '"[^`]*" or b = char '_. => a
    STRCONC(a,$tick,b)
  simp a ==
    m := MAXINDEX a
    m > 6 and a.(m-5) = char '_[ and a.(m-4) = char '_^
      and     a.(m-3) = $tick    and a.(m-2) = char '_]
          and a.(m-1) = char '_* and a.m = $tick
            => simp SUBSTRING(a,0,m-5)
    a

replaceGrepStar s ==
  s = "" => s
  final := MAXINDEX s
  i := charPosition(char '_*,s,0)
  i > final => s
  STRCONC(SUBSTRING(s,0,i),'"[^`]*",replaceGrepStar SUBSTRING(s,i + 1,nil))

standardizeSignature(s) == underscoreDollars
  s.0 = char '_( => s
  k := STRPOS('"->",s,0,nil) or return s --will fail except perhaps on constants
  s.(k - 1) = char '_) => STRCONC(char '_(,s)
  STRCONC(char '_(,SUBSTRING(s,0,k),char '_),SUBSTRING(s,k,nil))

underscoreDollars(s) == fn(s,0,MAXINDEX s) where
  fn(s,i,n) ==
    i > n => '""
    (m := charPosition(char '_$,s,i)) > n => SUBSTRING(s,i,nil)
    STRCONC(SUBSTRING(s,i,m - i),'"___$",fn(s,m + 1,n))

--=======================================================================
--                     Code dependent on $saturn
--=======================================================================

obey x ==
  $saturn and not $aixTestSaturn => nil
  OBEY x

--=======================================================================
--                         I/O Code
--=======================================================================

getTempPath kind ==
  pathname := mkGrepFile kind
  obey STRCONC('"rm -f ", pathname)
  pathname

dbWriteLines(s, :options) ==
  pathname := IFCAR options or getTempPath 'source
  $outStream: local := MAKE_-OUTSTREAM pathname
  for x in s repeat writedb x
  SHUT $outStream
  pathname

dbReadLines target == --AIX only--called by grepFile
  instream := OPEN target
  lines := [READLINE instream while not EOFP instream]
  CLOSE instream
  lines

dbGetCommentOrigin line ==
--Given a comment line in comdb, returns line in libdb pointing to it
--Comment lines have format  [dcpxoa]xxxxxx`ccccc... where
--x's give pointer into libdb, c's are comments
  firstPart := dbPart(line,1,-1)
  key := INTERN SUBSTRING(firstPart,0,1)    --extract this and throw away
  address := SUBSTRING(firstPart, 1, nil)   --address in libdb
  instream := OPEN grepSource key           --this always returns libdb now
  FILE_-POSITION(instream,PARSE_-INTEGER address)
  line := READLINE instream
  CLOSE instream
  line

grepSource key ==
  key = 'libdb   => STRCONC($SPADROOT,'"/algebra/libdb.text")
  key = 'gloss   => STRCONC($SPADROOT,'"/algebra/glosskey.text")
  key = $localLibdb => $localLibdb
  mkGrepTextfile
    MEMQ(key, '(_. a c d k o p x)) => 'libdb
    'comdb

mkGrepTextfile s == STRCONC($SPADROOT,"/algebra/", STRINGIMAGE s, '".text")

mkGrepFile s ==  --called to generate a path name for a temporary grep file
  prefix :=
    $standard or $aixTestSaturn => '"/tmp/"
    STRCONC($SPADROOT,'"/algebra/")
  suffix := getEnv '"SPADNUM"
  STRCONC(prefix, PNAME s,'".txt.", suffix)

--=======================================================================
--                     Grepping Code
--=======================================================================

grepFile(pattern,:options) ==
  key := (x := IFCAR options => (options := rest options; x); nil)
  source := grepSource key
  lines :=
    not PROBE_-FILE source => NIL
    $standard or $aixTestSaturn =>
    -----AIX Version----------
      target := getTempPath 'target
      casepart :=
        MEMQ('iv,options)=> '"-vi"
        '"-i"
      command := STRCONC('"grep ",casepart,'" _'",pattern,'"_' ",source)
      obey
        MEMBER(key,'(a o c d p x)) =>
          STRCONC(command, '" | sed 's/~/", STRINGIMAGE key, '"/' > ", target)
        STRCONC(command, '" > ",target)
      dbReadLines target
    ----Windows Version------
    invert? := MEMQ('iv, options)
    GREP(source, pattern, false, not invert?)
  dbUnpatchLines lines

dbUnpatchLines lines ==  --concatenate long lines together, skip blank lines
  dash := char '_-
  acc := nil
  while lines is [line, :lines] repeat
    #line = 0 => 'skip     --skip blank lines
    acc :=
      line.0 = dash and line.1 = dash =>
        [STRCONC(first acc,SUBSTRING(line,2,nil)),:rest acc]
      [line,:acc]
  -- following call to NREVERSE needed to keep lines properly sorted
  NREVERSE acc  ------> added by BMT 12/95

--====================> WAS b-util.boot <================================

--=======================================================================
--		       AXIOM Browser
-- Initial entry is from man0.ht page to one of these functions:
--   kSearch (cSearch, dSearch, or pSearch), for constructors
--   oSearch, for operations
--   aSearch, for attributes
--   aokSearch, for general search
--   docSearch, for documentation search
--   genSearch, for complete search
--=======================================================================

browserAutoloadOnceTrigger() == nil

----------------------> Global Variables <-----------------------
$includeUnexposed? := true   --default setting
$tick := char '_`	     --field separator for database files
$charUnderscore := ('__)     --needed because of parser bug
$wild1 := '"[^`]*"           --phrase used to convert keys to grep strings
$browseCountThreshold := 10  --the maximum number of names that will display
			     --on a general search
$opDescriptionThreshold := 4 --if <= 4 operations with unique name, give desc
                             --otherwise, give signatures
$browseMixedCase := true     --distinquish case in the browser?
$docTable := nil	     --cache for documentation table
$conArgstrings := nil	     --bound by conPage so that kPage
			     --will display arguments if given
$conformsAreDomains  := false	  --are all arguments of a constructor given?
$returnNowhereFromGoGet := false  --special branch out for goget for browser
$dbDataFunctionAlist := nil	  --set by dbGatherData
$domain	  := nil	     --bound in koOps
$infovec  := nil	     --bound in koOps
$predvec  := nil	     --bound in koOps
$exposedOnlyIfTrue := nil    --see repeatSearch, dbShowOps, dbShowCon
$bcMultipleNames := nil	     --see bcNameConTable
$bcConformBincount := nil    --see bcConform1
$docTableHash := MAKE_-HASHTABLE 'EQUAL	 --see dbExpandOpAlistIfNecessary
$groupChoice := nil  --see dbShowOperationsFromConform

------------------> Initial Settings <---------------------
$pmFilterDelimiters := [char '_(,char '_),char '_ ]
$dbKindAlist :=
  [[char 'a,:'"attribute"],[char 'o,:'"operation"],
    [char 'd,:'"domain"],[char 'p,:'"package"],
      [char 'c,:'"category"],[char 'x,:'"default_ package"]]
$OpViewTable := '(
  (names	   "Name"      "Names"           dbShowOpNames)
  (documentation   "Name"      "Names"           dbShowOpDocumentation)
  (domains	   "Domain"    "Domains"         dbShowOpDomains)
  (signatures	   "Signature" "Signatures"      dbShowOpSignatures)
  (parameters	   "Form"      "Forms"           dbShowOpParameters)
  (origins	   "Origin"    "Origins"         dbShowOpOrigins)
  (implementation  nil	       "Implementation Domains" dbShowOpImplementations)
  (conditions	   "Condition" "Conditions"      dbShowOpConditions))

bcBlankLine() == bcHt '"\vspace{1}\newline "

pluralize k ==
  k = '"child" => '"children"
  k = '"category" => '"categories"
  k = '"entry" => '"entries"
  STRCONC(k,'"s")

capitalize s ==
  LASSOC(s,'(
      ("domain"   . "Domain")
      ("category" . "Category")
      ("package"  . "Package")
      ("default package" . "Default Package"))) or
    res := COPY_-SEQ s
    SETELT(res,0,UPCASE res.0)
    res

escapeSpecialIds u ==	--very expensive function
  x := LASSOC(u,$htCharAlist) => [x]
  #u = 1 =>
    member(u, $htSpecialChars) => [CONCAT('"_\", u)]
    [u]
  c := char u.0
  or/[c = char y for y in $htSpecialChars] =>
    [CONCAT('"_\",u)]
  [u]

escapeString com ==   --this makes changes on single comment lines
-- was htexCom
  look := 0
  while look repeat
    look >= SIZE com => look := []


    look := STRPOSL ('"${}#%", com, look, [])
    if look then
      com := RPLACSTR (com,look,0,'"\")  --note RPLACSTR copies!!!
      look := look + 2
  com

htPred2English(x,:options) ==
  $emList :local := IFCAR options   --list of identifiers to be emphasised
  $precList: local := '((OR 10 . "or") (AND 9 . "and")
     (_< 5) (_<_= 5) (_> 5) (_>_= 5) (_= 5) (_^_= 5) (or 10) (and 9))
  fn(x,100) where
    fn(x,prec) ==
      x is [op,:l] =>
	LASSOC(op,$precList) is [iprec,:rename] =>
	  if iprec > prec then htSay '"("
	  fn(first l,iprec)
	  for y in rest l repeat
	    htSay('" ",rename or op,'" ")
	    fn(y,iprec)
	  if iprec > prec then htSay '")"
	if prec < 5 then htSay '"("
	gn(x,op,l,prec)
	if prec < 5 then htSay '")"
      x = 'etc => htSay '"..."
      IDENTP x and not MEMQ(x,$emList) => htSay escapeSpecialIds PNAME x
      htSay form2HtString(x,$emList)
    gn(x,op,l,prec) ==
      MEMQ(op,'(NOT not)) =>
	htSay('"not ")
	fn(first l,0)
      op = 'HasCategory =>
	bcConform(first l,$emList)
	htSay('" has ")
	bcConform(CADADR l,$emList)
      op = 'HasAttribute =>
	bcConform(first l,$emList)
	htSay('" has ")
	fnAttr CADADR l
      MEMQ(op,'(has ofCategory)) =>
	bcConform(first l,$emList)
	htSay('" has ")
	[a,b] := l
	b is ['ATTRIBUTE,c] and not constructor? c => fnAttr c
	bcConform(b, $emList)
      bcConform(x,$emList)
    fnAttr c ==
      s := form2HtString c
      MEMBER(s,$emList) => htSay('"{\em ",s,'"}")
      satDownLink(s, ['"(|aPage| '|",s,'"|)"])

unMkEvalable u ==
 u is ['QUOTE,a] => a
 u is ['LIST,:r] => [unMkEvalable x for x in r]
 u

lisp2HT u == ['"_'",:fn u] where fn u ==
  IDENTP u => escapeSpecialIds PNAME u
  STRINGP u => escapeString u
  ATOM u => systemError()
  ['"_(",:"append"/[fn x for x in u],'")"]

args2HtString(x,:options) ==
  null x => '""
  emList := IFCAR options
  SUBSTRING(form2HtString(['f,:x],emList),1,nil)

quickForm2HtString(x) ==
  atom x => STRINGIMAGE x
  form2HtString x

form2HtString(x,:options) ==
  $emList:local := IFCAR options   --list of atoms to be emphasized
  $brief: local := IFCAR IFCDR options --see dbShowOperationsFromConform (lib11)
  fn(x) where
    fn x ==
      atom x =>
	MEMQ(x,$FormalMapVariableList) => STRCONC('"\",STRINGIMAGE x)
	u := escapeSpecialChars STRINGIMAGE x
	MEMQ(x,$emList) => STRCONC('"{\em ",u,'"}")
	STRINGP x => STRCONC('"_"",u,'"_"")
	u
      first x = 'QUOTE => STRCONC('"'",sexpr2HtString first rest x)
      first x = ":" => STRCONC(fn first rest x,'": ",fn first rest rest x)
      first x = 'Mapping =>
        STRCONC(fnTail(rest rest x,'"()"),'"->",fn first rest x)
      first x = 'construct => fnTail(rest x,'"[]")
      tail := fnTail(rest x,'"()")
      head := fn first x
--    $brief and #head + #tail > 35 => STRCONC(head,'"(...)")
      STRCONC(head,tail)
    fnTail(x,str) ==
      null x => '""
      STRCONC(str . 0,fn first x,fnTailTail rest x,str . 1)
    fnTailTail x ==
      null x => '""
      STRCONC('",",fn first x,fnTailTail rest x)

sexpr2HtString x ==
  atom x => form2HtString x
  STRCONC('"(",fn x,'")") where fn x ==
    r := rest x
    suffix :=
      null r => '""
      atom r => STRCONC('" . ",form2HtString rest x)
      STRCONC('" ",fn r)
    STRCONC(sexpr2HtString first x,suffix)

form2LispString(x) ==
  atom x =>
    x = '_$ => '"__$"
    MEMQ(x,$FormalMapVariableList) => STRCONC(STRINGIMAGE '__, STRINGIMAGE x)
    STRINGP x => STRCONC('"_"",STRINGIMAGE x,'"_"")
    STRINGIMAGE x
  x is ['QUOTE,a] => STRCONC('"'",sexpr2LispString a)
  x is [":",a,b] => STRCONC(form2LispString a,'":",form2LispString b)
  first x = 'Mapping =>
    null rest (r := rest x) => STRCONC('"()->",form2LispString first r)
    STRCONC(args2LispString rest r,'"->",form2LispString first r)
  STRCONC(form2LispString first x,args2LispString rest x)

sexpr2LispString x ==
  atom x => form2LispString x
  STRCONC('"(",fn x,'")") where fn x ==
    r := rest x
    suffix :=
      null r => '""
      atom r => STRCONC('" . ",form2LispString rest x)
      STRCONC('" ",fn r)
    STRCONC(sexpr2HtString first x,suffix)

args2LispString x ==
  null x => '""
  STRCONC('"(",form2LispString first x,fnTailTail rest x,'")") where
    fnTailTail x ==
      null x => '""
      STRCONC('",",form2LispString first x,fnTailTail rest x)

dbConstructorKind x ==
  target := CADAR GETDATABASE(x,'CONSTRUCTORMODEMAP)
  target = '(Category) => 'category
  target is ['CATEGORY,'package,:.] => 'package
  HGET($defaultPackageNamesHT,x) => 'default_ package
  'domain

getConstructorForm name ==
  name = 'Union	  => '(Union  (_: a A) (_: b B))
  name = 'UntaggedUnion => '(Union A B)
  name = 'Record  => '(Record (_: a A) (_: b B))
  name = 'Mapping => '(Mapping T S)
  name = 'Enumeration => '(Enumeration a b)
  GETDATABASE(name,'CONSTRUCTORFORM)

getConstructorArgs conname == CDR getConstructorForm conname

htSay(x,:options) ==
--if x = $charEscape then x := $charNewline else
--if x = $stringEscape then x := $stringNewline
  bcHt x
  for y in options repeat bcHt y

bcComments(comments,:options) ==
  italics? := not IFCAR options
  STRINGP comments =>
    comments = '"" => nil
    htSay('"\newline ")
    if italics? then htSay '"{\em "
    htSay comments
    if italics? then htSay '"}"
  null comments => nil
  htSay('"\newline ")
  if italics? then htSay "{\em "
  htSay first comments
  for x in rest comments repeat htSay('" ",x)
  if italics? then htSay '"}"

bcConform(form,:options) ==
  $italics?    : local := IFCAR options
  $italicHead? : local := IFCAR IFCDR options
  bcConform1 form

bcConform1 form == main where
-----------------> OBSELETE
  main ==
    form is ['ifp,form1,:pred] =>
      hd form1
      bcPred pred
    hd form
  hd form ==
    atom form =>
      not MEMQ(form,'(Mapping Union Record)) and null constructor? form =>
        s := STRINGIMAGE form
        (s.0 = char '_#) and (n := POSN1(form, $FormalFunctionParameterList)) =>
           htSay form2HtString ($FormalMapVariableList . n)
        htSay form
      s := STRINGIMAGE form
      $italicHead? => htSayItalics s
      $bcMultipleNames =>
        satTypeDownLink(s, ['"(|conPageChoose| '|",s,'"|)"])
      satTypeDownLink(s, ["(|conPage| '|",s,'"|)"])
    (head := QCAR form) = 'QUOTE =>
      htSay('"'")
      hd CADR form
    head = 'SIGNATURE =>
      htSay(CADR form,'": ")
      mapping CADDR form
    head = 'Mapping and rest form => rest form => mapping rest form
    head = ":" =>
      hd CADR form
      htSay '": "
      hd CADDR form
    QCDR form and dbEvalableConstructor? form
       => bcConstructor(form,head)
    hd head
    null (r := QCDR form) => nil
    tl QCDR form
  mapping [target,:source] ==
    tuple source
    bcHt
      $saturn => '" {\ttrarrow} "
      '" -> "
    hd target
  tuple u ==
    null u => bcHt '"()"
    null rest u => hd u
    bcHt '"("
    hd first u
    for x in rest u repeat
      bcHt '","
      hd x
    bcHt '")"
  tl u ==
    bcHt '"("
    firstTime := true
    for x in u repeat
      if not firstTime then bcHt '","
      firstTime := false
      hd x
    bcHt '")"
  say x ==
    if $italics? then bcHt '"{\em "
    if x = 'etc then x := '"..."
    bcHt escapeSpecialIds STRINGIMAGE x
    if $italics? then bcHt '"}"

bcConstructor(form is [op,:arglist],cname) ==  --called only when $conformsAreDomains
  htSayList dbConformGen form

htSayList u ==
  for x in u repeat htSay x

conform2HtString form ==
  for u in form2String form repeat
    htSay u

dbEvalableConstructor? form ==
--form is constructor form; either
--(a) all arguments are specified or (b) none are specified
  form is [op,:argl] =>
    null argl => true
    op = 'QUOTE => 'T     --is a domain valued object
    and/[dbEvalableConstructor? x for x in argl]
  INTEGERP form => true
  false

htSayItalics s == htSay('"{\em ",s,'"}")

bcCon(name,:options) ==
  argString := IFCAR options or '""
  s := STRINGIMAGE name
  bcStar name
  htSayConstructorName(s,s)
  htSay argString

bcAbb(name,abb) ==
  s := STRINGIMAGE name
  a := STRINGIMAGE abb
  bcStar name
  htSayConstructorName(a,s)

bcStar name ==
  if $includeUnexposed? and not isExposedConstructor name then htSayUnexposed()

bcStarSpace name ==
  null $includeUnexposed? => nil
  not isExposedConstructor name => htSayUnexposed()
  htBlank()

bcStarSpaceOp(op,exposed?) ==
  null $includeUnexposed? => nil
  not exposed? =>
    htSayUnexposed()
    if op.0 = char '_* then htSay '" "
  htBlank()

bcStarConform form ==
  bcStar opOf form
  bcConform form

dbSourceFile name ==
  u:= GETDATABASE(name,'SOURCEFILE)
  null u => '""
  n := PATHNAME_-NAME u
  t := PATHNAME_-TYPE u
  STRCONC(n,'".",t)

asharpConstructorName? name ==
  u:= GETDATABASE(name,'SOURCEFILE)
  u and PATHNAME_-TYPE u = '"as"

asharpConstructors() ==
  [x for x in allConstructors() | not asharpConstructorName? x]

extractFileNameFromPath s == fn(s,0,#s) where
  fn(s,i,m) ==
    k := charPosition(char '_/,s,i)
    k = m => SUBSTRING(s,i,nil)
    fn(s,k + 1,m)

bcOpTable(u,fn) ==
  htBeginTable()
  firstTime := true
  for op in u for i in 0.. repeat
    if firstTime then firstTime := false
    else htSaySaturn '"&"
    htSay '"{"
    htMakePage [['bcLinks,[escapeSpecialChars STRINGIMAGE opOf op,'"",fn,i]]]
    htSay '"}"
  htEndTable()

bcNameConTable u ==
  $bcMultipleNames: local := (#u ^= 1)
  bcConTable REMDUP u
  -- bcConTable u

bcConTable u ==
  htBeginTable()
  firstTime := true
  for con in u repeat
    if firstTime then firstTime := false
    else htSaySaturn '"&"
    htSay '"{"
    bcStarSpace opOf con
    bcConform con
    htSay '"}"
  htEndTable()

bcAbbTable u ==
  htBeginTable()
  firstTime := true
  for x in REMDUP u repeat	  --allow x to be NIL meaning "no abbreviation"
  -- for x in u repeat	  --allow x to be NIL meaning "no abbreviation"
    if firstTime then firstTime := false
    else htSaySaturn '"&"
    if x is [con,abb,:.] then
      htSay '"{"
      bcAbb(con,abb)
      htSay '"}"
  htEndTable()

bcConPredTable(u,conname,:options) ==
  italicList := IFCAR options
  htBeginTable()
  firstTime := true
  for [conform,:pred] in u repeat
    if firstTime then firstTime := false
    else htSaySaturn '"&"
    htSay '"{"
    bcStarSpace opOf conform
    form :=
      atom conform => getConstructorForm conform
      conform
    bcConform(form,italicList)
    if extractHasArgs pred is [arglist,:pred] then
      htSay('" {\em of} ")
      bcConform([conname,:arglist],italicList,true)
    if pred ^= 'etc then bcPred(pred,italicList)
    htSay '"}"
  htEndTable()

bcPred(pred,:options) ==
  pred = '"" or pred = true or null pred => 'skip
  italicList := IFCAR options
  if not IFCAR IFCDR options then htSay '" {\em if} "
  htPred2English(pred,italicList)

extractHasArgs pred ==
  x := find pred or return nil where find x ==
    x is [op,:argl] =>
      op = 'hasArgs => x
      MEMQ(op,'(AND OR NOT)) => or/[find y for y in argl]
      nil
    nil
  [rest x,:simpBool SUBST('T,x,pred)]

splitConTable cons ==
  uncond := cond := nil
  for (pair := [con,:pred]) in cons repeat
    null pred => 'skip
    pred = 'T or pred is ['hasArgs,:.]	=> uncond := [pair,:uncond]
    cond := [pair,:cond]
  [NREVERSE uncond,:NREVERSE cond]

bcNameTable(u,fn,:option) ==   --option if * prefix
  htSay '"\newline"
  htBeginTable()
  firstTime := true
  for x in u repeat
    if firstTime then firstTime := false
    else htSaySaturn '"&"
    htSay '"{"
    if IFCAR option then bcStar x
    htMakePage [['bcLinks,[s := escapeSpecialChars STRINGIMAGE x,'"",fn,s]]]
    htSay '"}"
  htEndTable()

bcNameCountTable(u,fn,gn,:options) ==
  linkFunction :=
    IFCAR options => 'bcLispLinks
    'bcLinks
  htSay '"\newline"
  htBeginTable()
  firstTime := true
  for i in 0.. for x in u repeat
    if firstTime then firstTime := false
    else htSaySaturn '"&"
    htSay '"{"
    htMakePage [[linkFunction,[FUNCALL(fn,x),'"",gn,i]]]
    htSay '"}"
  htEndTable()

dbSayItemsItalics(:u) ==
  htSay '"{\em "
  APPLY(function dbSayItems,u)
  htSay '"}"

dbSayItems(countOrPrefix,singular,plural,:options) ==
  bcHt '"\newline "
  count :=
   countOrPrefix is [:prefix,c] =>
     htSay prefix
     c
   countOrPrefix
  if count = 0 then htSay('"No ",singular)
  else if count = 1 then htSay('"1 ",singular)
  else htSay(count,'" ",plural)
  for x in options repeat bcHt x
  if count ^= 0 then bcHt '":"

dbBasicConstructor? conname == MEMBER(dbSourceFile conname,'("catdef" "coerce"))

nothingFoundPage(:options) ==
  htInitPage('"Sorry, no match found",nil)
  htShowPage()

htCopyProplist htPage == [[x,:y] for [x,:y] in htpPropertyList htPage]

dbInfovec name ==
  'category = GETDATABASE(name,'CONSTRUCTORKIND) => nil
  GETDATABASE(name, 'ASHARP?) => nil
  loadLibIfNotLoaded(name)
  u := GET(name,'infovec) => u

emptySearchPage(kind,filter,:options) ==
  skipNamePart := IFCAR options
  heading := ['"No ",capitalize kind,'" Found"]
  htInitPage(heading,nil)
  exposePart :=
    null $includeUnexposed? => '"{\em exposed} "
    '""
  htSay('"\vspace{1}\newline\centerline{There is no ",exposePart,kind,'" matching pattern}\newline\centerline{{\em ")
  if filter then htPred2English filter
  htSay '"}}"
  htShowPage()

isLoaded? conform == GET(constructor? opOf conform,'LOADED)

string2Integer s ==
  and/[DIGIT_-CHAR_-P (s.i) for i in 0..MAXINDEX s] => PARSE_-INTEGER s
  nil

dbGetInputString htPage ==
  s := htpLabelInputString(htPage,'filter)
  null s or s = '"" => '"*"
  s



--=======================================================================
--		     Error Pages
--=======================================================================
bcErrorPage u ==
  u is ['error,:r] =>
    htInitPage(first r,nil)
    bcBlankLine()
    for x in rest r repeat htSay x
    htShowPage()
  systemError '"Unexpected error message"

errorPage(htPage,[heading,kind,:info]) ==
  kind = 'invalidType => kInvalidTypePage first info
  if heading = 'error then htInitPage('"Error",nil) else
			   htInitPage(heading,nil)
  bcBlankLine()
  for x in info repeat htSay x
  htShowPage()

htErrorStar() ==
  errorPage(nil,['"{\em *} not a valid search string",nil,'"\vspace{3}\centerline{{\em *} is not a valid search string for a general search}\centerline{\em {it would match everything!}}"])

htQueryPage(htPage,heading,message,query,fn) ==
  htInitPage(heading,nil)
  htSay message
  htQuery(query,fn)
  htShowPage()

htQuery(question,fn,:options) ==
  upLink? := IFCAR options
  if question then
    htSay('"\vspace{1}\centerline{")
    htSay question
    htSay('"}")
  htSay('"\centerline{")
  htMakePage [['bcLispLinks,['"\fbox{Yes}",'"",fn,'yes]]]
  htBlank 4
  if upLink?
    then htSay('"\downlink{\fbox{No}}{UpPage}")
    else htMakePage [['bcLispLinks,['"\fbox{No}",'"",fn,'no]]]
  htSay('"}")

kInvalidTypePage form ==
  htInitPage('"Error",nil)
  bcBlankLine()
  htSay('"\centerline{You gave an invalid type:}\newline\centerline{{\sf ")
  htSay(form2HtString form,'"}}")
  htShowPage()

dbNotAvailablePage(:options) ==
  htInitPage('"Missing Page",nil)
  bcBlankLine()
  htSay(IFCAR options or '"\centerline{This page is not available yet}")
  htShowPage()

--=======================================================================
--	 Utility Functions for Manipulating Browse Datalines
--=======================================================================
dbpHasDefaultCategory? s ==  #s > 1 and s.1 = char 'x  --s is part 3 of line

dbKind line == line.0

dbKindString kind == LASSOC(kind,$dbKindAlist)

dbName line == escapeString SUBSTRING(line,1,charPosition($tick,line,1) - 1)

dbAttr line == STRCONC(dbName line,escapeString dbPart(line,4,0))

dbPart(line,n,k) ==  --returns part n of line (n=1,..) beginning in column k
  n = 1 => SUBSTRING(line,k + 1,charPosition($tick,line,k + 1) - k - 1)
  dbPart(line,n - 1,charPosition($tick,line,k + 1))

dbXParts(line,n,m) ==
  [.,nargs,:r] := dbParts(line,n,m)
  [dbKindString line.0,dbName line,PARSE_-INTEGER nargs,:r]

dbParts(line,n,m) ==  --split line into n parts beginning in column m
  n = 0 => nil
  [SUBSTRING(line,m,-m + (k := charPosition($tick,line,m))),
    :dbParts(line,n - 1,k + 1)]

dbConname(line) == dbPart(line,5,1)

dbComments line ==  dbReadComments(string2Integer dbPart(line,7,1))

dbNewConname(line) == --dbName line unless kind is 'a or 'o => name in 5th pos.
  (kind := line.0) = char 'a or kind = char 'o =>
    conform := dbPart(line,5,1)
    k := charPosition(char '_(,conform,1)
    SUBSTRING(conform,1,k - 1)
  dbName line

dbTickIndex(line,n,k) == --returns index of nth tick in line starting at k
  n = 1 => charPosition($tick,line,k)
  dbTickIndex(line,n - 1,1 + charPosition($tick,line,k))

mySort u == listSort(function GLESSEQP,u)

--====================> WAS b-prof.boot <================================

--============================================================================
--                Browser Code for Profiling
--============================================================================
kciPage(htPage,junk) ==
  --info alist must have NEW format with [op,:sig] in its CAARs
  which:= '"operation"
  htpSetProperty(htPage,'which,which)
  domname := htpProperty(htPage,'domname)
  conform := htpProperty(htPage,'conform)
  heading := ['"Capsule Cross Reference for ",:htpProperty(htPage,'heading)]
  page := htInitPage(heading,htCopyProplist htPage)
  conname := opOf conform
  htpSetProperty(page,'infoAlist,infoAlist := getInfoAlist conname)
  dbGetExpandedOpAlist page      --expand opAlist "in place"
  opAlist := kciReduceOpAlist(htpProperty(page,'opAlist),infoAlist)
  dbShowOperationsFromConform(page,which,opAlist)

kciReduceOpAlist(opAlist,infoAlist) ==
--count opAlist
  res := [pair for [op,:items] in opAlist | pair] where pair ==
    u := LASSOC(op,infoAlist) =>
      y := [x for x in items
            | x is [sig,:.] and or/[sig = sig1 for [sig1,:.] in u]] => [op,:y]
      nil
    nil
  res

displayInfoOp(htPage,infoAlist,op,sig) ==
  (sigAlist := LASSOC(op,infoAlist)) and (itemlist := LASSOC(sig,sigAlist)) =>
     dbShowInfoOp(htPage,op,sig,itemlist)
  nil

dbShowInfoOp(htPage,op,sig,alist) ==
  heading := htpProperty(htPage,'heading)
  domname := htpProperty(htPage,'domname)
  conform := htpProperty(htPage,'conform)
  opAlist := htpProperty(htPage,'opAlist)
  conname := opOf conform
  kind     := GETDATABASE(conname,'CONSTRUCTORKIND)
  honestConform :=
    kind = 'category =>
      [INTERN STRCONC(PNAME conname,'"&"),"$",:CDR conform]
    conform
  faTypes  := CDDAR GETDATABASE(conname,'CONSTRUCTORMODEMAP)

  conArgTypes :=
    SUBLISLIS(IFCDR conform,TAKE(#faTypes,$FormalMapVariableList),faTypes)
  conform := htpProperty(htPage,'conform)
  conname := opOf conform
--argTypes := REVERSE ASSOCRIGHT LASSOC('arguments,alist)
--sig := or/[sig for [sig,:.] in LASSOC(op,opAlist) | rest sig = argTypes]
  ops := escapeSpecialChars STRINGIMAGE zeroOneConvert op
  oppart := ['"{\em ", ops, '"}"]
  head :=
    sig => [:oppart,'": ",:dbConformGen dbInfoSig sig]
    oppart
  heading := [:head,'" from {\sf ",form2HtString conform,'"}"]
  for u in alist repeat
    [x,:y] := u
    x = 'locals => locals := y
    x = 'arguments => arguments := y
    fromAlist := [[x,:zeroOneConvertAlist y], :fromAlist]
  fromAlist :=
    cons := args := nil
    for (p := [x,:y]) in fromAlist repeat
      x = $ => dollar := [[honestConform,:y]]
      x = 'Rep => rep := [['Rep,:y]]
      IDENTP x => args := [dbInfoFindCat(conform,conArgTypes,p), :args]
      cons := [dbInfoTran(x,y), :cons]
    [:mySort args, :dollar, :rep, :mySort cons]
  sigAlist  := LASSOC(op,opAlist)
  item := or/[x for x in sigAlist | x is [sig1,:.] and sig1 = sig] or
    systemError '"cannot find signature"
  --item is [sig,pred,origin,exposeFlag,comments]
  [sig,pred,origin,exposeFlag,doc] := item
  htpSetProperty(htPage,'fromAlist,fromAlist)
  htSayHline()
  htSay('"\center{Cross Reference for definition of {\em ",ops,'"}}\beginmenu ")
--  if arguments then
--    htSay '"\item\menuitemstyle{}{\em arguments:}\newline"
--    dbShowInfoList(arguments,0,false)
  if locals then
    htSay '"\item\menuitemstyle{}{\em local variables:}\newline"
    dbShowInfoList(locals,8192,false)
  bincount := 2
  for [con,:fns] in fromAlist repeat
    htSay '"\item"
    if IDENTP con then
        htSay '"\menuitemstyle{} {\em calls to} "
        if con ^= 'Rep then htSay '"{\em argument} "
        htSay con
        if and/[fn is ['origin,orig,.] and
          (null origin and (origin := orig) or origin = orig) for fn in fns] then
            htSay '" {\em of type} "
            bcConform orig
        buttonForOp := false
    else
      htMakePage [['bcLinks,['"\menuitemstyle{}",'"",'dbInfoChoose,bincount]]]
      htSay '"{\em calls to} "
      bcConform con
      buttonForOp := true
    htSay('":\newline ")
    dbShowInfoList(fns, bincount * 8192,buttonForOp)
    bincount := bincount + 1
  htSay '"\endmenu "

dbShowInfoList(dataItems,count,buttonForOp?) ==
--dataItems are [op,:sig]
  single? := null rest dataItems
  htSay '"\table{"
  for item in dataItems repeat
    [op,:sig] :=
       item is ['origin,.,s] =>
         buttonForOp? := true
         s
       item
    ops := escapeSpecialChars STRINGIMAGE op
    htSay '"{"
    if count < 16384 or not buttonForOp? then
      htSay [ops,'": "]
      atom sig => bcConform sig
      bcConform dbInfoSig sig
    else
      htMakePage [['bcLinks,[ops,'"",'dbInfoChooseSingle,count]]]
      htSay '": "
      if atom sig then htSay sig else
        bcConform dbInfoSig sig
    htSay '"}"
    count := count + 1
  htSay '"} "
  count

dbInfoFindCat(conform,conArgTypes,u) ==
  [argName,:opSigList] := u
  n := POSITION(argName,IFCDR conform) or systemError()
  t := conArgTypes . n
  [argName,:[dbInfoWrapOrigin(x,t) for x in opSigList]]

dbInfoWrapOrigin(x, t) ==
  [op, :sig] := x
  origin := dbInfoOrigin(op,sig,t) => ['origin, origin, x]
  x

dbInfoOrigin(op,sig,t) ==
  t is ['Join, :r] => or/[dbInfoOrigin(op,sig,x) for x in r]
  t is ['CATEGORY,:.] => false
  [sig = sig1 for [sig1,:.] in LASSOC(op, koOps(t,nil))] => t
  false

dbInfoTran(con,opSigList) == [con,:SUBST("$",con,mySort opSigList)]

zeroOneConvertAlist u == [[zeroOneConvert x,:y] for [x,:y] in u]

dbInfoChoose(htPage,count) ==
  fromAlist := htpProperty(htPage,'fromAlist)
  index := count - 2
  [con, :alist] := fromAlist.index
  dbInfoChoose1(htPage,con,alist)

dbInfoChooseSingle(htPage,count) ==
  fromAlist := htpProperty(htPage,'fromAlist)
  [index, binkey] := DIVIDE(count, 8192)
  [con, :alist] := fromAlist.(index - 2)
  item := alist . binkey
  alist :=
    item is ['origin,origin,s] =>
      con := origin
      [s]
    [item]
  dbInfoChoose1(htPage,con,alist)

dbInfoChoose1(htPage,con,alist) ==
  $conform: local := con
  opAlist := [pair for x in koOps(con,nil) | pair:=dbInfoSigMatch(x,alist)]
  page := htInitPage(nil,nil)
  htpSetProperty(page,'conform,con)
  htpSetProperty(page,'kind,PNAME GETDATABASE(opOf con,'CONSTRUCTORKIND))
  dbShowOperationsFromConform(page,'"operation",opAlist)

dbInfoSigMatch(x,alist) ==
  [op,:sigAlist] := x
  candidates := [sig for [op1,:sig] in alist | op1 = op] or return nil
  sigs := [s for s in sigAlist | "or"/[first s = s1 for s1 in candidates] or
    (s2 := SUBST($conform,"$",s)) and "or"/[first s2 = s1 for s1 in candidates]]
  sigs and [op,:sigs]


dbInfoSig sig ==
  null rest sig => first sig
  ['Mapping,:sig]

--============================================================================
--                Code to Expand opAlist
--============================================================================
dbGetExpandedOpAlist htPage ==
  expand := htpProperty(htPage,'expandOperations)
  if expand ^= 'fullyExpanded then
    if null expand then htpSetProperty(htPage,'expandOperations,'lists)
    opAlist := koOps(htpProperty(htPage,'conform),nil)
    htpSetProperty(htPage,'opAlist,opAlist)
    dbExpandOpAlistIfNecessary(htPage,opAlist,'"operation",false,false)
  htpProperty(htPage,'opAlist)

--============================================================================
--                  Get Info File Alist
--============================================================================
hasNewInfoAlist conname ==
  (u := getInfoAlist conname) and hasNewInfoText u

hasNewInfoText u ==
  and/[ATOM op and and/[item is [sig,:alist] and
    null sig or null atom sig and null atom alist for item in items] for [op,:items] in u]

getInfoAlist conname ==
  cat? := GETDATABASE(conname,'CONSTRUCTORKIND) = 'category
  if cat? then conname := INTERN STRCONC(STRINGIMAGE conname,'"&")
  abb := constructor? conname or return '"not a constructor"
  fs  := STRCONC(PNAME abb,'".nrlib/info")
  inStream :=
    PROBE_-FILE fs => OPEN fs
    filename := STRCONC('"/spad/int/algebra/",PNAME abb,'".nrlib/info")
    PROBE_-FILE filename => OPEN filename
    return nil
  alist := mySort READ inStream
  if cat? then
    [.,dollarName,:.] := GETDATABASE(conname,'CONSTRUCTORFORM)
    alist := SUBST("$",dollarName,alist)
  alist



@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}

