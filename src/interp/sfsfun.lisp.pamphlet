\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp sfsfun.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{verbatim}
NOTEfrom TTT: at least BesselJAsymptOrder needs work

1. This file contains the contents of BWC's original files:
      floaterrors.boot
      floatutils.boot
      rgamma.boot
      cgamma.boot
      rpsi.boot
      cpsi.boot
      f01.boot
      chebf01cmake.boot
      chebevalsf.boot
      besselIJ.boot

2. All declarations have been commented out with "--@@"
   since the boot translator is generating bad lisp code from them.

3. The functions PsiAsymptotic, PsiEps and PsiAsymptoticOrder
   had inconpatible definitions in rpsi.boot and cpsi.boot --
   the local variables were declared float in one file and COMPLEX in
   the other.  The type declarations have been commented out and the
   duplicate definitions have been deleted.

4. BesselIJ was not compiling.  I have modified the code from that
   file to make it compile.  It should be checked for correctness.

SMW June 25, 1991

"Fixes" to BesselJ, B. Char June 14, 1992.  Needs extensive testing and
  further fixes to BesselI and BesselJ.
More fixes to BesselJ, T. Tsikas 24 Feb, 1995.

\end{verbatim}
\begin{chunk}{*}

(IN-PACKAGE "BOOT")

;negintp(x) ==
;        if ZEROP IMAGPART(x) and x<0.0 and ZEROP fracpart(x)
;        then
;                true
;        else
;                false

(defun |negintp| (x)
  (cond
   ((and (zerop (imagpart x)) (< x 0.0)
         (zerop (fracpart x)))
    t)
        (t nil)))

;-- Lisp PI is a long float and causes type errors, here we give
;-- enough digits to have double accuracy even after conversion
;-- to binary
;DEFCONSTANT(dfPi,3.14159265358979323846264338328)

;--- Small float implementation of Gamma function.  Valid for
;--- real arguments.  Maximum error (relative) seems to be
;--- 2-4 ulps for real x 2<x<9, and up to ten ulps for larger x
;--- up to overflow.  See Hart & Cheney.
;--- Bruce Char, April, 1990.

;cbeta(z,w) ==
;        cgamma(z)*cgamma(w)/(cgamma(z+w))

(defun |cbeta| (z w)
  (/ (* (cgammaImpl z) (cgammaImpl w)) (cgammaImpl (+ z w))))

;PsiEps(n,x) ==
;        if n = 0
;        then
;                result := -LOG(x)
;        else
;                result :=  1.0/(float(n)*(x**n))
;        result

(defun |PsiEps| (n x)
  (if (eql n 0)
    (- (log x))
    (/ 1.0 (* (float n) (expt x n)))))

;PsiAsymptoticOrder(n,x,nterms) ==
;        sum := 0
;        xterm := 1.0
;        np1 := n+1
;        for k in 0..nterms repeat
;                xterm := (x+float(k))**np1
;                sum := sum + 1.0/xterm
;        sum

(defun |PsiAsymptoticOrder| (n x nterms)
  (loop for k from 0 to nterms 
   sum (/ 1.0 (expt (+ x (float k)) (+ n 1)))))

;---Code for computation of derivatives of cot(z), necessary for
;--- polygamma reflection formula.  If you want to compute n-th derivatives of
;---cot(Pi*x), you have to multiply the result of cotdiffeval by Pi**n.

;-- MCD: This is defined at the Lisp Level.
;-- COT(z) ==
;--         1.0/TAN(z)

;cotdiffeval(n,z,skipit) ==
;---skip=1 if arg z is known to be an exact multiple of Pi/2
;        a := MAKE_-ARRAY(n+2)
;        SETF(AREF(a,0),0.0)
;        SETF(AREF(a,1),1.0)
;        for i in 2..n repeat
;                SETF(AREF(a,i),0.0)
;        for l in 1..n repeat
;                m := MOD(l+1,2)
;                for k in m..l+1 by 2 repeat
;                        if k<1
;                        then
;                                t1 := 0
;                        else
;                                t1 := -AREF(a,k-1)*(k-1)
;                        if k>l
;                        then
;                                t2 := 0
;                        else
;                                t2 := -AREF(a,k+1)*(k+1)
;                        SETF(AREF(a,k), t1+t2)
;        --- evaluate d^N/dX^N cot(z) via Horner-like rule
;        v := COT(z)
;        sq := v**2
;        s := AREF(a,n+1)
;        for i in (n-1)..0 by -2 repeat
;                s := s*sq + AREF(a,i)
;        m := MOD(n,2)
;        if m=0
;        then
;                s := s*v
;        if skipit=1
;        then
;                if m=0
;                then
;                        return 0
;                else
;                        return AREF(a,0)
;        else
;                return s

(DEFUN |cotdiffeval| (|n| |z| |skipit|)
  (PROG (|s| |sq| |v| |t2| |t1| |m| |a|)
    (RETURN
      (PROGN
        (SETQ |a| (MAKE-ARRAY (+ |n| 2)))
        (SETF (AREF |a| 0) 0.0)
        (SETF (AREF |a| 1) 1.0)
        ((LAMBDA (|i|)
           (LOOP
             (COND
               ((> |i| |n|) (RETURN NIL))
               ('T (SETF (AREF |a| |i|) 0.0)))
             (SETQ |i| (+ |i| 1))))
         2)
        ((LAMBDA (|l|)
           (LOOP
             (COND
               ((> |l| |n|) (RETURN NIL))
               ('T
                (PROGN
                  (SETQ |m| (MOD (+ |l| 1) 2))
                  ((LAMBDA (|bfVar#9| |k|)
                     (LOOP
                       (COND
                         ((> |k| |bfVar#9|) (RETURN NIL))
                         ('T
                          (PROGN
                            (COND
                              ((< |k| 1) (SETQ |t1| 0))
                              ('T
                               (SETQ |t1|
                                     (-
                                      (* (AREF |a| (- |k| 1))
                                       (- |k| 1))))))
                            (COND
                              ((< |l| |k|) (SETQ |t2| 0))
                              ('T
                               (SETQ |t2|
                                     (-
                                      (* (AREF |a| (+ |k| 1))
                                       (+ |k| 1))))))
                            (SETF (AREF |a| |k|) (+ |t1| |t2|)))))
                       (SETQ |k| (+ |k| 2))))
                   (+ |l| 1) |m|))))
             (SETQ |l| (+ |l| 1))))
         1)
        (SETQ |v| (COT |z|))
        (SETQ |sq| (EXPT |v| 2))
        (SETQ |s| (AREF |a| (+ |n| 1)))
        ((LAMBDA (|bfVar#10| |i|)
           (LOOP
             (COND
               ((COND ((MINUSP |bfVar#10|) (< |i| 0)) (T (> |i| 0)))
                (RETURN NIL))
               ('T (SETQ |s| (+ (* |s| |sq|) (AREF |a| |i|)))))
             (SETQ |i| (+ |i| |bfVar#10|))))
         (- 2) (- |n| 1))
        (SETQ |m| (MOD |n| 2))
        (COND ((EQL |m| 0) (SETQ |s| (* |s| |v|))))
        (COND
          ((EQL |skipit| 1)
           (COND ((EQL |m| 0) (RETURN 0)) ('T (RETURN (AREF |a| 0)))))
          ('T (RETURN |s|)))))))

;--- nth derivatives of ln gamma for complex z, n=0,1,...
;--- requires files rpsi (and dependents), floaterrors
;--- currently defined only in right half plane until reflection formula
;--- works

;--- B. Char, June, 1990.

;cPsi(n,z) ==
;        x := REALPART(z)
;        y := IMAGPART(z)
;        if ZEROP y 
;        then    --- call real function if real
;                return rPsi(n,x)
;        if y<0.0
;        then    -- if imagpart(z) negative, take conjugate of conjugate
;                conjresult := cPsi(n,COMPLEX(x,-y))
;                return COMPLEX(REALPART(conjresult),-IMAGPART(conjresult))
;        nterms := 22
;        bound := 10.0
;        if x<0.0 --- and ABS(z)>bound and ABS(y)<bound
;        then
;                FloatError('"Psi implementation can't compute at ~S ",[n,z])
;---             return cpsireflect(n,x,y,z)
;        else if (x>0.0 and ABS(z)>bound ) --- or (x<0.0 and ABS(y)>bound)
;        then
;                return PsiXotic(n,PsiAsymptotic(n,z))
;        else            --- use recursion formula
;                m := CEILING(SQRT(bound*bound - y*y) - x + 1.0)
;                result := COMPLEX(0.0,0.0)
;                for k in 0..(m-1) repeat
;                        result := result + 1.0/((z + float(k))**(n+1))
;                return PsiXotic(n,result+PsiAsymptotic(n,z+m))

(DEFUN |cPsi| (|n| |z|)
  (PROG (|result| |m| |bound| |nterms| |conjresult| |y| |x|)
    (RETURN
      (PROGN
        (SETQ |x| (REALPART |z|))
        (SETQ |y| (IMAGPART |z|))
        (COND ((ZEROP |y|) (RETURN (rPsiImpl |n| |x|))))
        (COND
          ((< |y| 0.0)
           (SETQ |conjresult| (|cPsi| |n| (COMPLEX |x| (- |y|))))
           (RETURN
             (COMPLEX (REALPART |conjresult|)
                      (- (IMAGPART |conjresult|))))))
        (SETQ |nterms| 22)
        (SETQ |bound| 10.0)
        (COND
          ((< |x| 0.0)
           (FloatError "Psi implementation can't compute at ~S "
               (LIST |n| |z|)))
          ((AND (< 0.0 |x|) (< |bound| (ABS |z|)))
           (RETURN (|PsiXotic| |n| (|PsiAsymptotic| |n| |z|))))
          ('T
           (SETQ |m|
                 (CEILING (+ (- (SQRT (- (* |bound| |bound|)
                                       (* |y| |y|)))
                                |x|)
                             1.0)))
           (SETQ |result| (COMPLEX 0.0 0.0))
           ((LAMBDA (|bfVar#11| |k|)
              (LOOP
                (COND
                  ((> |k| |bfVar#11|) (RETURN NIL))
                  ('T
                   (SETQ |result|
                         (+ |result|
                            (/ 1.0
                               (EXPT (+ |z| (float |k|)) (+ |n| 1)))))))
                (SETQ |k| (+ |k| 1))))
            (- |m| 1) 0)
           (RETURN
             (|PsiXotic| |n|
                 (+ |result| (|PsiAsymptotic| |n| (+ |z| |m|)))))))))))

;PsiXotic(n,result) ==
;        rgamma(float(n+1))*(-1)**MOD(n+1,2)*result

(DEFUN |PsiXotic| (|n| |result|)
  (PROG ()
    (RETURN
      (* (* (rgammaImpl (float (+ |n| 1)))
            (EXPT (- 1) (MOD (+ |n| 1) 2)))
         |result|))))

;cpsireflect(n,z) ==
;        m := MOD(n,2)
;        sign := (-1)**m
;        sign*dfPi**(n+1)*cotdiffeval(n,dfPi*z,0) + cPsi(n,1.0-z)

(DEFUN |cpsireflect| (|n| |z|)
  (PROG (|sign| |m|)
    (RETURN
      (PROGN
        (SETQ |m| (MOD |n| 2))
        (SETQ |sign| (EXPT (- 1) |m|))
        (+ (* (* |sign| (EXPT Pi (+ |n| 1)))
              (|cotdiffeval| |n| (* Pi |z|) 0))
           (|cPsi| |n| (- 1.0 |z|)))))))

;--- c parameter to 0F1, possibly complex
;--- z argument to 0F1
;--- Depends on files floaterror, floatutils

;--- Program transcribed from Fortran,, p. 80 Luke 1977

;chebf01 (c,z) ==
;--- w scale factor so that 0<z/w<1
;--- n    n+2 coefficients will be produced stored in an array
;---  indexed from 0 to n+1.
;--- See Luke's books for further explanation
;        n := 75 --- ad hoc decision
;---     if ABS(z)/ABS(c) > 200.0 and ABS(z)>10000.0
;---     then
;---             FloatError('"cheb0F1 not implemented for ~S < 1",[c,z])
;        w := 2.0*z
;--- arr will be used to store the Cheb. series coefficients
;        four:= 4.0
;        start := EXPT(10.0, -200)
;        n1 := n+1
;        n2 := n+2
;        a3 := 0.0
;        a2 := 0.0
;        a1 := start     -- arbitrary starting value
;        z1 := four/w
;        ncount := n1
;        arr := MAKE_-ARRAY(n2)
;        SETF(AREF(arr,ncount) , start)  -- start off
;        x1 := n2
;        c1 := 1.0 - c
;        for ncount in n..0 by -1 repeat
;                divfac := 1.0/x1
;                x1 := x1 -1.0
;                SETF(AREF(arr,ncount) ,_
;                        x1*((divfac+z1*(x1-c1))*a1 +_
;                        (1.0/x1 + z1*(x1+c1+1.0))*a2-divfac*a3))
;                a3 := a2
;                a2 := a1
;                a1 := AREF(arr,ncount)
;        SETF(AREF(arr,0),AREF(arr,0)/2.0)
;--  compute scale factor
;        rho := AREF(arr,0)
;        sum := rho
;        p := 1.0
;        for i in 1..n1 repeat
;                rho := rho - p*AREF(arr,i)
;                sum := sum+AREF(arr,i)
;                p := -p
;        for l in 0..n1 repeat
;                SETF(AREF(arr,l), AREF(arr,l)/rho)
;        sum := sum/rho
;---     Now evaluate array at argument
;        b := 0.0
;        temp := 0.0
;        for i in (n+1)..0 by -1 repeat
;                cc := b
;                b := temp
;                temp := -cc + AREF(arr,i)
;        temp

(DEFUN |chebf01| (|c| |z|)
  (PROG (|cc| |temp| |b| |p| |sum| |rho| |divfac| |c1| |x1| |arr|
              |ncount| |z1| |a1| |a2| |a3| |n2| |n1| |start| |four| |w|
              |n|)
    (RETURN
      (PROGN
        (SETQ |n| 75)
        (SETQ |w| (* 2.0 |z|))
        (SETQ |four| 4.0)
        (SETQ |start| (EXPT 10.0 (- 200)))
        (SETQ |n1| (+ |n| 1))
        (SETQ |n2| (+ |n| 2))
        (SETQ |a3| 0.0)
        (SETQ |a2| 0.0)
        (SETQ |a1| |start|)
        (SETQ |z1| (/ |four| |w|))
        (SETQ |ncount| |n1|)
        (SETQ |arr| (MAKE-ARRAY |n2|))
        (SETF (AREF |arr| |ncount|) |start|)
        (SETQ |x1| |n2|)
        (SETQ |c1| (- 1.0 |c|))
        ((LAMBDA (|bfVar#12| |ncount|)
           (LOOP
             (COND
               ((COND
                  ((MINUSP |bfVar#12|) (< |ncount| 0))
                  (T (> |ncount| 0)))
                (RETURN NIL))
               ('T
                (PROGN
                  (SETQ |divfac| (/ 1.0 |x1|))
                  (SETQ |x1| (- |x1| 1.0))
                  (SETF (AREF |arr| |ncount|)
                        (* |x1|
                           (- (+ (* (+ |divfac| (* |z1| (- |x1| |c1|)))
                                    |a1|)
                                 (* (+ (/ 1.0 |x1|)
                                     (* |z1| (+ (+ |x1| |c1|) 1.0)))
                                    |a2|))
                              (* |divfac| |a3|))))
                  (SETQ |a3| |a2|)
                  (SETQ |a2| |a1|)
                  (SETQ |a1| (AREF |arr| |ncount|)))))
             (SETQ |ncount| (+ |ncount| |bfVar#12|))))
         (- 1) |n|)
        (SETF (AREF |arr| 0) (/ (AREF |arr| 0) 2.0))
        (SETQ |rho| (AREF |arr| 0))
        (SETQ |sum| |rho|)
        (SETQ |p| 1.0)
        ((LAMBDA (|i|)
           (LOOP
             (COND
               ((> |i| |n1|) (RETURN NIL))
               ('T
                (PROGN
                  (SETQ |rho| (- |rho| (* |p| (AREF |arr| |i|))))
                  (SETQ |sum| (+ |sum| (AREF |arr| |i|)))
                  (SETQ |p| (- |p|)))))
             (SETQ |i| (+ |i| 1))))
         1)
        ((LAMBDA (|l|)
           (LOOP
             (COND
               ((> |l| |n1|) (RETURN NIL))
               ('T (SETF (AREF |arr| |l|) (/ (AREF |arr| |l|) |rho|))))
             (SETQ |l| (+ |l| 1))))
         0)
        (SETQ |sum| (/ |sum| |rho|))
        (SETQ |b| 0.0)
        (SETQ |temp| 0.0)
        ((LAMBDA (|bfVar#13| |i|)
           (LOOP
             (COND
               ((COND ((MINUSP |bfVar#13|) (< |i| 0)) (T (> |i| 0)))
                (RETURN NIL))
               ('T
                (PROGN
                  (SETQ |cc| |b|)
                  (SETQ |b| |temp|)
                  (SETQ |temp| (+ (- |cc|) (AREF |arr| |i|))))))
             (SETQ |i| (+ |i| |bfVar#13|))))
         (- 1) (+ |n| 1))
        |temp|))))

;brutef01(c,z) ==
;--  Use series definition.  Won't work well if cancellation occurs
;        term := 1.0
;        sum := term
;        n := 0.0
;        oldsum := 0.0
;        maxnterms := 10000
;        for i in 0..maxnterms until oldsum=sum repeat
;                oldsum := sum
;                term := term*z/(c+n)/(n+1.0)
;                sum := sum + term
;                n := n+1.0
;        sum

(DEFUN |brutef01| (|c| |z|)
  (PROG (|maxnterms| |oldsum| |n| |sum| |term|)
    (RETURN
      (PROGN
        (SETQ |term| 1.0)
        (SETQ |sum| |term|)
        (SETQ |n| 0.0)
        (SETQ |oldsum| 0.0)
        (SETQ |maxnterms| 10000)
        ((LAMBDA (|i| |bfVar#14|)
           (LOOP
             (COND
               ((OR (> |i| |maxnterms|) |bfVar#14|) (RETURN NIL))
               ('T
                (PROGN
                  (SETQ |oldsum| |sum|)
                  (SETQ |term|
                        (/ (/ (* |term| |z|) (+ |c| |n|)) (+ |n| 1.0)))
                  (SETQ |sum| (+ |sum| |term|))
                  (SETQ |n| (+ |n| 1.0)))))
             (SETQ |i| (+ |i| 1))
             (SETQ |bfVar#14| (EQUAL |oldsum| |sum|))))
         0 NIL)
        |sum|))))

;f01(c,z)==
;        if negintp(c)
;        then
;                FloatError('"0F1 not defined for negative integer parameter value ~S",c)
;-- conditions when we'll permit the computation
;        else if ABS(c)<1000.0 and ABS(z)<1000.0
;        then
;                brutef01(c,z)
;        else if ZEROP IMAGPART(z) and ZEROP IMAGPART(c) and z>=0.0 and c>=0.0
;        then
;                brutef01(c,z)
;---     else
;---             t := SQRT(-z)
;---             c1 := c-1.0
;---             p := PHASE(c)
;---             if ABS(c)>10.0*ABS(t) and p>=0.0 and PHASE(c)<.90*dfPi
;---             then BesselJAsymptOrder(c1,2*t)*cgamma(c/(t**(c1)))
;---             else if ABS(t)>10.0*ABS(c) and ABS(t)>50.0
;---             then BesselJAsympt(c1,2*t)*cgamma(c/(t**(c1)))
;---             else
;---                     FloatError('"0F1 not implemented for ~S",[c,z])
;        else if (10.0*ABS(c)>ABS(z)) and ABS(c)<1.0E4 and ABS(z)<1.0E4
;        then
;                brutef01(c,z)
;        else
;                FloatError('"0F1 not implemented for ~S",[c,z])

(DEFUN |f01| (|c| |z|)
  (PROG ()
    (RETURN
      (COND
        ((|negintp| |c|)
         (FloatError
             "0F1 not defined for negative integer parameter value ~S"
             |c|))
        ((AND (< (ABS |c|) 1000.0) (< (ABS |z|) 1000.0))
         (|brutef01| |c| |z|))
        ((AND (ZEROP (IMAGPART |z|)) (ZEROP (IMAGPART |c|))
              (NOT (< |z| 0.0)) (NOT (< |c| 0.0)))
         (|brutef01| |c| |z|))
        ((AND (< (ABS |z|) (* 10.0 (ABS |c|))) (< (ABS |c|) 10000.0)
              (< (ABS |z|) 10000.0))
         (|brutef01| |c| |z|))
        ('T (FloatError "0F1 not implemented for ~S" (LIST |c| |z|)))))))

;--- c parameter to 0F1
;--- w scale factor so that 0<z/w<1
;--- n    n+2 coefficients will be produced stored in an array
;---  indexed from 0 to n+1.
;--- See Luke's books for further explanation

;--- Program transcribed from Fortran,, p. 80 Luke 1977
;chebf01coefmake (c,w,n) ==
;--- arr will be used to store the Cheb. series coefficients
;        four:= 4.0
;        start := EXPT(10.0, -200)
;        n1 := n+1
;        n2 := n+2
;        a3 := 0.0
;        a2 := 0.0
;        a1 := start     -- arbitrary starting value
;        z1 := four/w
;        ncount := n1
;        arr := MAKE_-ARRAY(n2)
;        SETF(AREF(arr,ncount) , start)  -- start off
;        x1 := n2
;        c1 := 1.0 - c
;        for ncount in n..0 by -1 repeat
;                divfac := 1.0/x1
;                x1 := x1 -1.0
;                SETF(AREF(arr,ncount) ,_
;                        x1*((divfac+z1*(x1-c1))*a1 +_
;                        (1.0/x1 + z1*(x1+c1+1.0))*a2-divfac*a3))
;                a3 := a2
;                a2 := a1
;                a1 := AREF(arr,ncount)
;        SETF(AREF(arr,0),AREF(arr,0)/2.0)
;--  compute scale factor
;        rho := AREF(arr,0)
;        sum := rho
;        p := 1.0
;        for i in 1..n1 repeat
;                rho := rho - p*AREF(arr,i)
;                sum := sum+AREF(arr,i)
;                p := -p
;        for l in 0..n1 repeat
;                SETF(AREF(arr,l), AREF(arr,l)/rho)
;        sum := sum/rho
;        return([sum,arr])



;---evaluation of Chebychev series of degree n at x, where the series's
;---coefficients are given by the list in descending order (coef. of highest
;---power first)

;---May be numerically unstable for certain lists of coefficients;
;--- could possibly reverse sequence of coefficients

;--- Cheney and Hart p. 15.

;--- B. Char, March 1990

;chebeval (coeflist,x) ==
;        b := 0;
;        temp := 0;
;        y := 2*x;
;
;        for el in coeflist repeat
;                c := b;
;                b := temp
;                temp := y*b -c + el
;        (temp -c)/2

(DEFUN |chebeval| (|coeflist| |x|)
  (PROG (|c| |y| |temp| |b|)
    (RETURN
      (PROGN
        (SETQ |b| 0)
        (SETQ |temp| 0)
        (SETQ |y| (* 2 |x|))
        ((LAMBDA (|bfVar#16| |el|)
           (LOOP
             (COND
               ((OR (ATOM |bfVar#16|)
                    (PROGN (SETQ |el| (CAR |bfVar#16|)) NIL))
                (RETURN NIL))
               ('T
                (PROGN
                  (SETQ |c| |b|)
                  (SETQ |b| |temp|)
                  (SETQ |temp| (+ (- (* |y| |b|) |c|) |el|)))))
             (SETQ |bfVar#16| (CDR |bfVar#16|))))
         |coeflist| NIL)
        (/ (- |temp| |c|) 2)))))

;chebevalarr(coefarr,x,n) ==
;        b := 0;
;        temp := 0;
;        y := 2*x;
;
;        for i in 1..n repeat
;                c := b;
;                b := temp
;                temp := y*b -c + coefarr.i
;        (temp -c)/2

(DEFUN |chebevalarr| (|coefarr| |x| |n|)
  (PROG (|c| |y| |temp| |b|)
    (RETURN
      (PROGN
        (SETQ |b| 0)
        (SETQ |temp| 0)
        (SETQ |y| (* 2 |x|))
        ((LAMBDA (|i|)
           (LOOP
             (COND
               ((> |i| |n|) (RETURN NIL))
               ('T
                (PROGN
                  (SETQ |c| |b|)
                  (SETQ |b| |temp|)
                  (SETQ |temp|
                        (+ (- (* |y| |b|) |c|) (ELT |coefarr| |i|))))))
             (SETQ |i| (+ |i| 1))))
         1)
        (/ (- |temp| |c|) 2)))))

;--- If plist is a list of coefficients for the Chebychev approximation
;--- of a function f(x), then chebderiveval computes the Chebychev approximation
;--- of f'(x).  See Luke, "Special Functions and their approximations, vol. 1
;--- Academic Press 1969., p. 329 (from Clenshaw and Cooper)

;--- < definition to be supplied>

;--- chebstareval(plist,n) computes a Chebychev approximation from a
;--- coefficient list, using shifted Chebychev polynomials of the first kind
;--- The defining relation is that T*(n,x) = T(n,2*x-1).  Thus the interval
;--- [0,1] of T*n is the interval [-1,1] of Tn.

;chebstareval(coeflist,x) ==          -- evaluation of T*(n,x)
;        b := 0
;        temp := 0
;        y := 2*(2*x-1)
;
;        for el in coeflist repeat
;                c := b;
;                b := temp
;                temp := y*b -c + el
;        temp - y*b/2

(defun |chebstareval| (coeflist x)
 (let (c y (temp 0) (b 0))
  (setq y (* 2 (- (* 2 x) 1)))
  (loop for el in coeflist do
    (setq c b)
    (setq b temp)
    (setq temp (+ (- (* y b) c) el)))
  (- temp (/ (* y b) 2))))

;--Float definitions for Bessel functions I and J.
;--External references:  cgamma, rgamma, chebf01coefmake, chebevalstarsf
;-- floatutils

;---BesselJ works for complex and real values of v and z
;BesselJ(v,z) ==
;---Ad hoc boundaries for approximation
;        B1:= 10
;        B2:= 10
;        n := 50         --- number of terms in Chebychev series.
;        --- tests for negative integer order
;        (FLOATP(v) and ZEROP fracpart(v) and (v<0)) or (COMPLEXP(v) and ZEROP IMAGPART(v) and ZEROP fracpart(REALPART(v)) and REALPART(v)<0.0) =>
;             --- odd or even according to v (9.1.5 A&S)
;             --- $J_{-n}(z)=(-1)^{n} J_{n}(z)$
;             BesselJ(-v,z)*EXPT(-1.0,v)
;        (FLOATP(z) and  (z<0)) or (COMPLEXP(z) and REALPART(z)<0.0) =>
;          --- negative argument (9.1.35 A&S) 
;          --- $J_{\nu}(z e^{m \pi i}) = e^{m \nu \pi i} J_{\nu}(z)$
;             BesselJ(v,-z)*EXPT(-1.0,v)
;        ZEROP z and ((FLOATP(v) and (v>=0.0)) or (COMPLEXP(v) and 
;           ZEROP IMAGPART(v) and REALPART(v)>=0.0)) =>  --- zero arg, pos. real order
;            ZEROP v => 1.0  --- J(0,0)=1
;            0.0  --- J(v,0)=0 for real v>0
;        rv := ABS(v)
;        rz := ABS(z)
;        (rz>B1) and (rz > B2*rv) =>  --- asymptotic argument
;            BesselJAsympt(v,z)
;        (rv>B1) and (rv > B2*rz) => --- asymptotic order
;            BesselJAsymptOrder(v,z)
;        (rz< B1) and (rv<B1) =>       --- small order and argument
;                 arg := -(z*z)/4.0
;                 w := 2.0*arg
;                 vp1 := v+1.0
;                 [sum,arr] := chebf01coefmake(vp1,w,n)
;                 ---if we get NaNs then half n
;                 while not _=(sum,sum) repeat
;                        n:=FLOOR(n/2)
;                        [sum,arr] := chebf01coefmake(vp1,w,n)
;                 ---now n is safe, can we increase it (we know that 2*n is bad)?
;                 chebstarevalarr(arr,arg/w,n)/cgamma(vp1)*EXPT(z/2.0,v)
;        true => BesselJRecur(v,z)
;        FloatError('"BesselJ not implemented for ~S", [v,z])

(DEFUN |BesselJ| (|v| |z|)
  (PROG (|arr| |sum| |LETTMP#1| |vp1| |w| |arg| |rz| |rv| |n| B2 B1)
    (RETURN
      (PROGN
        (SETQ B1 10)
        (SETQ B2 10)
        (SETQ |n| 50)
        (COND
          ((OR (AND (FLOATP |v|) (ZEROP (fracpart |v|)) (MINUSP |v|))
               (AND (COMPLEXP |v|) (ZEROP (IMAGPART |v|))
                    (ZEROP (fracpart (REALPART |v|)))
                    (< (REALPART |v|) 0.0)))
           (* (|BesselJ| (- |v|) |z|) (EXPT (- 1.0) |v|)))
          ((OR (AND (FLOATP |z|) (MINUSP |z|))
               (AND (COMPLEXP |z|) (< (REALPART |z|) 0.0)))
           (* (|BesselJ| |v| (- |z|)) (EXPT (- 1.0) |v|)))
          ((AND (ZEROP |z|)
                (OR (AND (FLOATP |v|) (NOT (< |v| 0.0)))
                    (AND (COMPLEXP |v|) (ZEROP (IMAGPART |v|))
                         (NOT (< (REALPART |v|) 0.0)))))
           (COND ((ZEROP |v|) 1.0) ('T 0.0)))
          ('T
           (PROGN
             (SETQ |rv| (ABS |v|))
             (SETQ |rz| (ABS |z|))
             (COND
               ((AND (< B1 |rz|) (< (* B2 |rv|) |rz|))
                (|BesselJAsympt| |v| |z|))
               ((AND (< B1 |rv|) (< (* B2 |rz|) |rv|))
                (|BesselJAsymptOrder| |v| |z|))
               ((AND (< |rz| B1) (< |rv| B1))
                (PROGN
                  (SETQ |arg| (- (/ (* |z| |z|) 4.0)))
                  (SETQ |w| (* 2.0 |arg|))
                  (SETQ |vp1| (+ |v| 1.0))
                  (SETQ |LETTMP#1| (chebf01coefmake |vp1| |w| |n|))
                  (SETQ |sum| (CAR |LETTMP#1|))
                  (SETQ |arr| (CADR |LETTMP#1|))
                  ((LAMBDA ()
                     (LOOP
                       (COND
                         ((= |sum| |sum|) (RETURN NIL))
                         ('T
                          (PROGN
                            (SETQ |n| (FLOOR (/ |n| 2)))
                            (SETQ |LETTMP#1|
                                  (chebf01coefmake |vp1| |w| |n|))
                            (SETQ |sum| (CAR |LETTMP#1|))
                            (SETQ |arr| (CADR |LETTMP#1|))
                            |LETTMP#1|))))))
                  (* (/ (|chebstarevalarr| |arr| (/ |arg| |w|) |n|)
                        (cgammaImpl |vp1|))
                     (EXPT (/ |z| 2.0) |v|))))
               (T (|BesselJRecur| |v| |z|))
               ('T
                (FloatError "BesselJ not implemented for ~S"
                    (LIST |v| |z|)))))))))))

;BesselJRecur(v,z) ==
;        -- boost order
;        --Numerical.Recipes. suggest so:=v+sqrt(n.s.f.^2*v)
;        so:=15.0*z
;        -- reduce order until non-zero
;        while ZEROP ABS(BesselJAsymptOrder(so,z)) repeat so:=so/2.0 
;        if ABS(so)<ABS(z) then so:=v+18.*SQRT(v)
;        m:= FLOOR(ABS(so-v))+1
;        w:=MAKE_-ARRAY(m)
;        SETF(AREF(w,m-1),BesselJAsymptOrder(v+m-1,z))
;        SETF(AREF(w,m-2),BesselJAsymptOrder(v+m-2,z))
;        for i in m-3 .. 0 by -1 repeat
;          SETF(AREF(w,i), 2.0 * (v+i+1.0) * AREF(w,i+1) /z -AREF(w,i+2)) 
;        AREF(w,0)

(DEFUN |BesselJRecur| (|v| |z|)
  (PROG (|w| |m| |so|)
    (RETURN
      (PROGN
        (SETQ |so| (* 15.0 |z|))
        ((LAMBDA ()
           (LOOP
             (COND
               ((NOT (ZEROP (ABS (|BesselJAsymptOrder| |so| |z|))))
                (RETURN NIL))
               ('T (SETQ |so| (/ |so| 2.0)))))))
        (COND
          ((< (ABS |so|) (ABS |z|))
           (SETQ |so| (+ |v| (* 18.0 (SQRT |v|))))))
        (SETQ |m| (+ (FLOOR (ABS (- |so| |v|))) 1))
        (SETQ |w| (MAKE-ARRAY |m|))
        (SETF (AREF |w| (- |m| 1))
              (|BesselJAsymptOrder| (- (+ |v| |m|) 1) |z|))
        (SETF (AREF |w| (- |m| 2))
              (|BesselJAsymptOrder| (- (+ |v| |m|) 2) |z|))
        ((LAMBDA (|bfVar#19| |i|)
           (LOOP
             (COND
               ((COND ((MINUSP |bfVar#19|) (< |i| 0)) (T (> |i| 0)))
                (RETURN NIL))
               ('T
                (SETF (AREF |w| |i|)
                      (- (/ (* (* 2.0 (+ (+ |v| |i|) 1.0))
                               (AREF |w| (+ |i| 1)))
                            |z|)
                         (AREF |w| (+ |i| 2))))))
             (SETQ |i| (+ |i| |bfVar#19|))))
         (- 1) (- |m| 3))
        (AREF |w| 0)))))

;---Asymptotic functions for large values of z.  See p. 204 Luke 1969 vol. 1.

;--- mu is 4*v**2
;--- zsqr is z**2
;--- zfth is z**4

;BesselasymptA(mu,zsqr,zfth) ==
;        (mu -1)/(16.0*zsqr) * (1 + (mu - 13.0)/(8.0*zsqr) + _
;                (mu**2 - 53.0*mu + 412.0)/(48.0*zfth))

(DEFUN |BesselasymptA| (|mu| |zsqr| |zfth|)
  (PROG ()
    (RETURN
      (* (/ (- |mu| 1) (* 16.0 |zsqr|))
         (+ (+ 1 (/ (- |mu| 13.0) (* 8.0 |zsqr|)))
            (/ (+ (- (EXPT |mu| 2) (* 53.0 |mu|)) 412.0)
               (* 48.0 |zfth|)))))))

;BesselasymptB(mu,z,zsqr,zfth) ==
;        musqr := mu*mu
;        z + (mu-1.0)/(8.0*z) *(1.0 + (mu - 25.0)/(48.0*zsqr) + _
;                (musqr - 114.0*mu + 1073.0)/(640.0*zfth) +_
;                (5.0*mu*musqr - 1535.0*musqr + 54703.0*mu - 375733.0)/(128.0*zsqr*zfth))

(DEFUN |BesselasymptB| (|mu| |z| |zsqr| |zfth|)
  (PROG (|musqr|)
    (RETURN
      (PROGN
        (SETQ |musqr| (* |mu| |mu|))
        (+ |z|
           (* (/ (- |mu| 1.0) (* 8.0 |z|))
              (+ (+ (+ 1.0 (/ (- |mu| 25.0) (* 48.0 |zsqr|)))
                    (/ (+ (- |musqr| (* 114.0 |mu|)) 1073.0)
                       (* 640.0 |zfth|)))
                 (/ (- (+ (- (* (* 5.0 |mu|) |musqr|)
                             (* 1535.0 |musqr|))
                          (* 54703.0 |mu|))
                       375733.0)
                    (* (* 128.0 |zsqr|) |zfth|)))))))))

;--- Asymptotic series only works when |v| < |z|.

;BesselJAsympt (v,z) ==
;        pi := dfPi
;        mu := 4.0*v*v
;        zsqr := z*z
;        zfth := zsqr*zsqr
;        SQRT(2.0/(pi*z))*EXP(BesselasymptA(mu,zsqr,zfth))*_
;                COS(BesselasymptB(mu,z,zsqr,zfth) - pi*v/2.0 - pi/4.0)

(DEFUN |BesselJAsympt| (|v| |z|)
  (PROG (|zfth| |zsqr| |mu| |pi|)
    (RETURN
      (PROGN
        (SETQ |pi| Pi)
        (SETQ |mu| (* (* 4.0 |v|) |v|))
        (SETQ |zsqr| (* |z| |z|))
        (SETQ |zfth| (* |zsqr| |zsqr|))
        (* (* (SQRT (/ 2.0 (* |pi| |z|)))
              (EXP (|BesselasymptA| |mu| |zsqr| |zfth|)))
           (COS (- (- (|BesselasymptB| |mu| |z| |zsqr| |zfth|)
                      (/ (* |pi| |v|) 2.0))
                   (/ |pi| 4.0))))))))

;---Asymptotic series for I.  See Whittaker, p. 373.
;--- valid for -3/2 Pi < arg z < 1/2 Pi

;BesselIAsympt(v,z,n) ==
;        i := COMPLEX(0.0, 1.0)
;        if (REALPART(z) = 0.0)
;        then return EXPT(i,v)*BesselJ(v,-IMAGPART(z))
;        sum1 := 0.0
;        sum2 := 0.0
;        fourvsq := 4.0*v**2
;        two := 2.0
;        eight := 8.0
;        term1 := 1.0
;---             sum1, sum2, fourvsq,two,i,eight,term1])
;        for r in 1..n repeat
;                term1 := -term1 *(fourvsq-(two*float(r)-1.0)**2)/_
;                        (float(r)*eight*z)
;                sum1 := sum1 + term1
;                sum2 := sum2 + ABS(term1)
;        sqrttwopiz := SQRT(two*dfPi*z)
;        EXP(z)/sqrttwopiz*(1.0 + sum1 ) +_
;                EXP(-(float(n)+.5)*dfPi*i)*EXP(-z)/sqrttwopiz*(1.0+ sum2)

(DEFUN |BesselIAsympt| (|v| |z| |n|)
  (PROG (|sqrttwopiz| |term1| |eight| |two| |fourvsq| |sum2| |sum1|
            |i|)
    (RETURN
      (PROGN
        (SETQ |i| (COMPLEX 0.0 1.0))
        (COND
          ((EQUAL (REALPART |z|) 0.0)
           (RETURN
             (* (EXPT |i| |v|) (|BesselJ| |v| (- (IMAGPART |z|)))))))
        (SETQ |sum1| 0.0)
        (SETQ |sum2| 0.0)
        (SETQ |fourvsq| (* 4.0 (EXPT |v| 2)))
        (SETQ |two| 2.0)
        (SETQ |eight| 8.0)
        (SETQ |term1| 1.0)
        ((LAMBDA (|r|)
           (LOOP
             (COND
               ((> |r| |n|) (RETURN NIL))
               ('T
                (PROGN
                  (SETQ |term1|
                        (- (/ (* |term1|
                                 (- |fourvsq|
                                    (EXPT
                                     (- (* |two| (float |r|)) 1.0) 2)))
                              (* (* (float |r|) |eight|) |z|))))
                  (SETQ |sum1| (+ |sum1| |term1|))
                  (SETQ |sum2| (+ |sum2| (ABS |term1|))))))
             (SETQ |r| (+ |r| 1))))
         1)
        (SETQ |sqrttwopiz| (SQRT (* (* |two| Pi) |z|)))
        (+ (* (/ (EXP |z|) |sqrttwopiz|) (+ 1.0 |sum1|))
           (* (/ (* (EXP (- (* (* (+ (float |n|) 0.5) Pi) |i|)))
                    (EXP (- |z|)))
                 |sqrttwopiz|)
              (+ 1.0 |sum2|)))))))

;---Asymptotic formula for BesselJ when order is large comes from
;---Debye (1909).  See Olver, Asymptotics and Special Functions, p. 134.
;---Expansion good for 0<=phase(v)<Pi
;---A&S recommend "uniform expansion" with complicated coefficients and Airy function.
;---Debye's Formula is in 9.3.7,9.3.9,9.3.10 of A&S
;---AXIOM recurrence for u_{k} 
;---f(0)==1::EXPR INT
;---f(n)== (t^2)*(1-t^2)*D(f(n-1),t)/2 + (1/8)*integrate( (1-5*t^2)*f(n-1),t)
;BesselJAsymptOrder(v,z) ==
;        sechalpha := z/v
;        alpha := ACOSH(1.0/sechalpha)
;        tanhalpha := SQRT(1.0-(sechalpha*sechalpha))
;    --  cothalpha := 1.0/tanhalpha
;        ca := 1.0/tanhalpha
;
;        Pi := dfPi
;        ca2:=ca*ca
;        ca4:=ca2*ca2
;        ca8:=ca4*ca4
;        EXP(-v*(alpha-tanhalpha))/SQRT(2.0*Pi*v*tanhalpha)*_
;        (1.0+_
;        horner([              -5.0,                3.0],_
;                                                                ca2)*ca/(v*24.0)+_
;        horner([             385.0,             -462.0,              81.0],_
;                                                                ca2)*ca2/(1152.0*v*v)+_
;        horner([         -425425.0,           765765.0,         -369603.0,             30375.0],_
;                                                                ca2)*ca2*ca/(414720.0*v*v*v)+_
;        horner([       185910725.0,       -446185740.0,       349922430.0,        -94121676.0,         4465125.0],_
;                                                                ca2)*ca4/(39813120.0*v*v*v*v)+_
;        horner([   -188699385875.0,     566098157625.0,   -614135872350.0,     284499769554.0,    -49286948607.0,      1519035525.0],_
;                                                                ca2)*ca4*ca/(6688604160.0*v*v*v*v*v)+_
;        horner([1023694168371875.0,-3685299006138750.0,5104696716244125.0,-3369032068261860.0,1050760774457901.0,-127577298354750.0,2757049477875.0],_
;                                                                ca2)*ca4*ca2/(4815794995200.0*v*v*v*v*v*v))

(DEFUN |BesselJAsymptOrder| (|v| |z|)
  (PROG (|ca8| |ca4| |ca2| |ca| |tanhalpha| |alpha| |sechalpha|)
    (RETURN
      (PROGN
        (SETQ |sechalpha| (/ |z| |v|))
        (SETQ |alpha| (ACOSH (/ 1.0 |sechalpha|)))
        (SETQ |tanhalpha| (SQRT (- 1.0 (* |sechalpha| |sechalpha|))))
        (SETQ |ca| (/ 1.0 |tanhalpha|))
        (SETQ |ca2| (* |ca| |ca|))
        (SETQ |ca4| (* |ca2| |ca2|))
        (SETQ |ca8| (* |ca4| |ca4|))
        (* (/ (EXP (- (* |v| (- |alpha| |tanhalpha|))))
              (SQRT (* (* (* 2.0 Pi) |v|) |tanhalpha|)))
           (+ (+ (+ (+ (+ (+ 1.0
                             (/ (* (horner (LIST (- 5.0) 3.0) |ca2|)
                                   |ca|)
                                (* |v| 24.0)))
                          (/ (* (horner (LIST 385.0 (- 462.0) 81.0)
                                    |ca2|)
                                |ca2|)
                             (* (* 1152.0 |v|) |v|)))
                       (/ (* (* (horner
                                    (LIST (- 425425.0) 765765.0
                                     (- 369603.0) 30375.0)
                                    |ca2|)
                                |ca2|)
                             |ca|)
                          (* (* (* 414720.0 |v|) |v|) |v|)))
                    (/ (* (horner
                              (LIST 1.85910725E8 (- 4.4618574E8)
                                    3.4992243E8 (- 9.4121676E7)
                                    4465125.0)
                              |ca2|)
                          |ca4|)
                       (* (* (* (* 3.981312E7 |v|) |v|) |v|) |v|)))
                 (/ (* (* (horner
                              (LIST (- 1.88699385875E11)
                                    5.66098157625E11
                                    (- 6.1413587235E11)
                                    2.84499769554E11
                                    (- 4.9286948607E10) 1.519035525E9)
                              |ca2|)
                          |ca4|)
                       |ca|)
                    (* (* (* (* (* 6.68860416E9 |v|) |v|) |v|) |v|)
                       |v|)))
              (/ (* (* (horner
                           (LIST 1.023694168371875E15
                                 (- 3.6852990061387505E15)
                                 5.104696716244125E15
                                 (- 3.36903206826186E15)
                                 1.050760774457901E15
                                 (- 1.2757729835475E14)
                                 2.757049477875E12)
                           |ca2|)
                       |ca4|)
                    |ca2|)
                 (* (* (* (* (* (* 4.8157949952E12 |v|) |v|) |v|) |v|)
                       |v|)
                    |v|))))))))


;---  See Olver, p. 376-382.
;BesselIAsymptOrder(v,vz) ==
;        z := vz/v
;        Pi := dfPi
;---     Use reflection formula (Atlas, p. 492)  if v not in right half plane;  Is this always accurate?
;        if REALPART(v)<0.0
;        then return BesselIAsymptOrder(-v,vz) + 2.0/Pi*SIN(-v*Pi)*BesselKAsymptOrder(-v,vz)
;---     Use the reflection formula (Atlas, p. 496) if z not in right half plane;
;        if REALPART(vz) < 0.0
;        then return EXPT(-1.0,v)*BesselIAsymptOrder(v,-vz)
;        vinv := 1.0/v
;        opzsqroh := SQRT(1.0+z*z)
;        eta := opzsqroh + LOG(z/(1.0+opzsqroh))
;        p := 1.0/opzsqroh
;        p2 := p*p
;        p4 := p2*p2
;        u0p := 1.
;        u1p := 1.0/8.0*p-5.0/24.0*p*p2
;        u2p := (9.0/128.0+(-77.0/192.0+385.0/1152.0*p2)*p2)*p2
;        u3p := (75.0/1024.0+(-4563.0/5120.0+(17017.0/9216.0-85085.0/82944.0*p2)_
;                *p2)*p2)*p2*p
;        u4p := (3675.0/32768.0+(-96833.0/40960.0+(144001.0/16384.0+(-7436429.0/663552.0+37182145.0/7962624.0*p2)*p2)*p2)*p2)*p4
;        u5p := (59535.0/262144.0+(-67608983.0/9175040.0+(250881631.0/5898240.0+(-108313205.0/1179648.0+(5391411025.0/63700992.0-5391411025.0/191102976.0*p2)*p2)*p2)*p2)*p2)*p4*p
;        hornerresult := horner([u5p,u4p,u3p,u2p,u1p,u0p],vinv)
;        EXP(v*eta)/(SQRT(2.0*Pi*v)*SQRT(opzsqroh))*hornerresult

(DEFUN |BesselIAsymptOrder| (|v| |vz|)
  (PROG (|hornerresult| |u5p| |u4p| |u3p| |u2p| |u1p| |u0p| |p4| |p2|
            |p| |eta| |opzsqroh| |vinv| |z|)
    (RETURN
      (PROGN
        (SETQ |z| (/ |vz| |v|))
        (COND
          ((< (REALPART |v|) 0.0)
           (RETURN
             (+ (|BesselIAsymptOrder| (- |v|) |vz|)
                (* (* (/ 2.0 Pi) (SIN (- (* |v| Pi))))
                   (|BesselKAsymptOrder| (- |v|) |vz|))))))
        (COND
          ((< (REALPART |vz|) 0.0)
           (RETURN
             (* (EXPT (- 1.0) |v|) (|BesselIAsymptOrder| |v| (- |vz|))))))
        (SETQ |vinv| (/ 1.0 |v|))
        (SETQ |opzsqroh| (SQRT (+ 1.0 (* |z| |z|))))
        (SETQ |eta| (+ |opzsqroh| (LOG (/ |z| (+ 1.0 |opzsqroh|)))))
        (SETQ |p| (/ 1.0 |opzsqroh|))
        (SETQ |p2| (* |p| |p|))
        (SETQ |p4| (* |p2| |p2|))
        (SETQ |u0p| 1.0)
        (SETQ |u1p|
              (- (* (/ 1.0 8.0) |p|) (* (* (/ 5.0 24.0) |p|) |p2|)))
        (SETQ |u2p|
              (* (+ (/ 9.0 128.0)
                    (* (+ (- (/ 77.0 192.0)) (* (/ 385.0 1152.0) |p2|))
                       |p2|))
                 |p2|))
        (SETQ |u3p|
              (* (* (+ (/ 75.0 1024.0)
                       (* (+ (- (/ 4563.0 5120.0))
                             (* (- (/ 17017.0 9216.0)
                                   (* (/ 85085.0 82944.0) |p2|))
                                |p2|))
                          |p2|))
                    |p2|)
                 |p|))
        (SETQ |u4p|
              (* (+ (/ 3675.0 32768.0)
                    (* (+ (- (/ 96833.0 40960.0))
                          (* (+ (/ 144001.0 16384.0)
                                (* (+ (- (/ 7436429.0 663552.0))
                                    (* (/ 3.7182145E7 7962624.0) |p2|))
                                   |p2|))
                             |p2|))
                       |p2|))
                 |p4|))
        (SETQ |u5p|
              (* (* (+ (/ 59535.0 262144.0)
                       (* (+ (- (/ 6.7608983E7 9175040.0))
                             (* (+ (/ 2.50881631E8 5898240.0)
                                   (*
                                    (+ (- (/ 1.08313205E8 1179648.0))
                                     (*
                                      (- (/ 5.391411025E9 6.3700992E7)
                                       (*
                                        (/ 5.391411025E9 1.91102976E8)
                                        |p2|))
                                      |p2|))
                                    |p2|))
                                |p2|))
                          |p2|))
                    |p4|)
                 |p|))
        (SETQ |hornerresult|
              (horner (LIST |u5p| |u4p| |u3p| |u2p| |u1p| |u0p|)
                  |vinv|))
        (* (/ (EXP (* |v| |eta|))
              (* (SQRT (* (* 2.0 Pi) |v|)) (SQRT |opzsqroh|)))
           |hornerresult|)))))

;---See also Olver, pp. 376-382
;BesselKAsymptOrder (v,vz) ==
;  z := vz/v
;  vinv := 1.0/v
;  opzsqroh := SQRT(1.0+z*z)
;  eta := opzsqroh + LOG(z/(1.0+opzsqroh))
;  p := 1.0/opzsqroh
;  p2 := p**2
;  p4 := p2**2
;  u0p := 1.
;  u1p := (1.0/8.0*p-5.0/24.0*p**3)*(-1.0)
;  u2p := (9.0/128.0+(-77.0/192.0+385.0/1152.0*p2)*p2)*p2
;  u3p := ((75.0/1024.0+(-4563.0/5120.0+(17017.0/9216.0-85085.0/82944.0*p2)_
;                *p2)*p2)*p2*p)*(-1.0)
;  u4p := (3675.0/32768.0+(-96833.0/40960.0+(144001.0/16384.0+(-7436429.0/663552.0+37182145.0/7962624.0*p2)*p2)*p2)*p2)*p4
;  u5p := ((59535.0/262144.0+(-67608983.0/9175040.0+(250881631.0/5898240.0+(-108313205.0/1179648.0+(5391411025.0/63700992.0-5391411025.0/191102976.0*p2)*p2)*p2)*p2)*p2)*p4*p)*(-1.0)
;  hornerresult := horner([u5p,u4p,u3p,u2p,u1p,u0p],vinv)
;  SQRT(dfPi/(2.0*v))*EXP(-v*eta)/(SQRT(opzsqroh))*hornerresult

(DEFUN |BesselKAsymptOrder| (|v| |vz|)
  (PROG (|hornerresult| |u5p| |u4p| |u3p| |u2p| |u1p| |u0p| |p4| |p2|
            |p| |eta| |opzsqroh| |vinv| |z|)
    (RETURN
      (PROGN
        (SETQ |z| (/ |vz| |v|))
        (SETQ |vinv| (/ 1.0 |v|))
        (SETQ |opzsqroh| (SQRT (+ 1.0 (* |z| |z|))))
        (SETQ |eta| (+ |opzsqroh| (LOG (/ |z| (+ 1.0 |opzsqroh|)))))
        (SETQ |p| (/ 1.0 |opzsqroh|))
        (SETQ |p2| (EXPT |p| 2))
        (SETQ |p4| (EXPT |p2| 2))
        (SETQ |u0p| 1.0)
        (SETQ |u1p|
              (* (- (* (/ 1.0 8.0) |p|) (* (/ 5.0 24.0) (EXPT |p| 3)))
                 (- 1.0)))
        (SETQ |u2p|
              (* (+ (/ 9.0 128.0)
                    (* (+ (- (/ 77.0 192.0)) (* (/ 385.0 1152.0) |p2|))
                       |p2|))
                 |p2|))
        (SETQ |u3p|
              (* (* (* (+ (/ 75.0 1024.0)
                          (* (+ (- (/ 4563.0 5120.0))
                                (* (- (/ 17017.0 9216.0)
                                    (* (/ 85085.0 82944.0) |p2|))
                                   |p2|))
                             |p2|))
                       |p2|)
                    |p|)
                 (- 1.0)))
        (SETQ |u4p|
              (* (+ (/ 3675.0 32768.0)
                    (* (+ (- (/ 96833.0 40960.0))
                          (* (+ (/ 144001.0 16384.0)
                                (* (+ (- (/ 7436429.0 663552.0))
                                    (* (/ 3.7182145E7 7962624.0) |p2|))
                                   |p2|))
                             |p2|))
                       |p2|))
                 |p4|))
        (SETQ |u5p|
              (* (* (* (+ (/ 59535.0 262144.0)
                          (* (+ (- (/ 6.7608983E7 9175040.0))
                                (* (+ (/ 2.50881631E8 5898240.0)
                                    (*
                                     (+ (- (/ 1.08313205E8 1179648.0))
                                      (*
                                       (- (/ 5.391411025E9 6.3700992E7)
                                        (*
                                         (/ 5.391411025E9 1.91102976E8)
                                         |p2|))
                                       |p2|))
                                     |p2|))
                                   |p2|))
                             |p2|))
                       |p4|)
                    |p|)
                 (- 1.0)))
        (SETQ |hornerresult|
              (horner (LIST |u5p| |u4p| |u3p| |u2p| |u1p| |u0p|)
                  |vinv|))
        (* (/ (* (SQRT (/ Pi (* 2.0 |v|))) (EXP (- (* |v| |eta|))))
              (SQRT |opzsqroh|))
           |hornerresult|)))))

\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
