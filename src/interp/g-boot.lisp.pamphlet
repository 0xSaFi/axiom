\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp g-boot.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{chunk}{*}

(IN-PACKAGE "BOOT" )

;--% BOOT to LISP Translation
;
;-- these supplement those in DEF and MACRO LISP
;
;--% Utilities
;
;
;$LET := 'SPADLET    -- LET is a standard macro in Common Lisp

;(setq $LET 'SPADLET)

;nakedEXIT? c ==
;  ATOM c => NIL
;  [a,:d] := c
;  IDENTP a =>
;    a = 'EXIT  => true
;    a = 'QUOTE => NIL
;    MEMQ(a,'(SEQ PROG LAMBDA MLAMBDA LAM)) => NIL
;    nakedEXIT?(d)
;  nakedEXIT?(a) or nakedEXIT?(d)

;;;     ***       |nakedEXIT?| REDEFINED

(DEFUN |nakedEXIT?| (|c|)
  (PROG (|a| |d|)
    (RETURN
      (SEQ (COND
             ((ATOM |c|) NIL)
             ('T (setq |a| (CAR |c|)) (setq |d| (CDR |c|))
              (COND
                ((IDENTP |a|)
                 (COND
                   ((BOOT-EQUAL |a| 'EXIT) 'T)
                   ((BOOT-EQUAL |a| 'QUOTE) NIL)
                   ((member |a| '(SEQ PROG LAMBDA MLAMBDA LAM)) NIL)
                   ('T (|nakedEXIT?| |d|))))
                ('T (OR (|nakedEXIT?| |a|) (|nakedEXIT?| |d|))))))))))

;mergeableCOND x ==
;  ATOM(x) or x isnt ['COND,:cls] => NIL
;  -- to be mergeable, every result must be an EXIT and the last
;  -- predicate must be a pair
;  ok := true
;  while (cls and ok) repeat
;    [[p,:r],:cls] := cls
;    CONSP QCDR r => ok := NIL
;    CAR(r) isnt ['EXIT,.] => ok := NIL
;    NULL(cls) and ATOM(p) => ok := NIL
;    NULL(cls) and (p = ''T) => ok := NIL
;  ok

;;;     ***       |mergeableCOND| REDEFINED

(DEFUN |mergeableCOND| (|x|)
  (PROG (|LETTMP#1| |p| |r| |cls| |ISTMP#1| |ISTMP#2| |ok|)
    (RETURN
      (SEQ (COND
             ((OR (ATOM |x|)
                  (NULL (AND (CONSP |x|) (EQ (QCAR |x|) 'COND)
                             (PROGN (setq |cls| (QCDR |x|)) 'T))))
              NIL)
             ('T (setq |ok| 'T)
              (DO () ((NULL (AND |cls| |ok|)) NIL)
                (SEQ (EXIT (PROGN
                             (setq |LETTMP#1| |cls|)
                             (setq |p| (CAAR |LETTMP#1|))
                             (setq |r| (CDAR |LETTMP#1|))
                             (setq |cls| (CDR |LETTMP#1|))
                             (COND
                               ((CONSP (QCDR |r|)) (setq |ok| NIL))
                               ((NULL (PROGN
                                        (setq |ISTMP#1| (CAR |r|))
                                        (AND (CONSP |ISTMP#1|)
                                         (EQ (QCAR |ISTMP#1|) 'EXIT)
                                         (PROGN
                                           (setq |ISTMP#2|
                                            (QCDR |ISTMP#1|))
                                           (AND (CONSP |ISTMP#2|)
                                            (EQ (QCDR |ISTMP#2|) NIL))))))
                                (setq |ok| NIL))
                               ((AND (NULL |cls|) (ATOM |p|))
                                (setq |ok| NIL))
                               ((AND (NULL |cls|) (BOOT-EQUAL |p| ''T))
                                (setq |ok| NIL)))))))
              |ok|))))))

;mergeCONDsWithEXITs l ==
;  -- combines things like
;  -- (COND (foo (EXIT a)))
;  -- (COND (bar (EXIT b)))
;  -- into one COND
;  NULL l => NIL
;  ATOM l => l
;  NULL CONSP QCDR l => l
;  a := QCAR l
;  if a is ['COND,:.] then a := flattenCOND a
;  am := mergeableCOND a
;  CDR(l) is [b,:k] and am and mergeableCOND(b) =>
;    b:= flattenCOND b
;    c := ['COND,:QCDR a,:QCDR b]
;    mergeCONDsWithEXITs [flattenCOND c,:k]
;  CDR(l) is [b] and am =>
;    [removeEXITFromCOND flattenCOND ['COND,:QCDR a,[''T,b]]]
;  [a,:mergeCONDsWithEXITs CDR l]

;;;     ***       |mergeCONDsWithEXITs| REDEFINED

(DEFUN |mergeCONDsWithEXITs| (|l|)
  (PROG (|a| |am| |k| |c| |ISTMP#1| |b|)
    (RETURN
      (COND
        ((NULL |l|) NIL)
        ((ATOM |l|) |l|)
        ((NULL (CONSP (QCDR |l|))) |l|)
        ('T (setq |a| (QCAR |l|))
         (COND
           ((AND (CONSP |a|) (EQ (QCAR |a|) 'COND))
            (setq |a| (|flattenCOND| |a|))))
         (setq |am| (|mergeableCOND| |a|))
         (COND
           ((AND (PROGN
                   (setq |ISTMP#1| (CDR |l|))
                   (AND (CONSP |ISTMP#1|)
                        (PROGN
                          (setq |b| (QCAR |ISTMP#1|))
                          (setq |k| (QCDR |ISTMP#1|))
                          'T)))
                 |am| (|mergeableCOND| |b|))
            (setq |b| (|flattenCOND| |b|))
            (setq |c| (CONS 'COND (APPEND (QCDR |a|) (QCDR |b|))))
            (|mergeCONDsWithEXITs| (CONS (|flattenCOND| |c|) |k|)))
           ((AND (PROGN
                   (setq |ISTMP#1| (CDR |l|))
                   (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                        (PROGN (setq |b| (QCAR |ISTMP#1|)) 'T)))
                 |am|)
            (CONS (|removeEXITFromCOND|
                      (|flattenCOND|
                          (CONS 'COND
                                (APPEND (QCDR |a|)
                                        (CONS (CONS ''T (CONS |b| NIL))
                                         NIL)))))
                  NIL))
           ('T (CONS |a| (|mergeCONDsWithEXITs| (CDR |l|))))))))))

;removeEXITFromCOND? c ==
;  -- c is '(COND ...)
;  -- only can do it if every clause simply EXITs
;  ok := true
;  c := CDR c
;  while ok and c repeat
;    [[p,:r],:c] := c
;    nakedEXIT? p => ok := NIL
;    [:f,r1] := r
;    nakedEXIT? f => ok := NIL
;    r1 isnt ['EXIT,r2] => ok := NIL
;    nakedEXIT? r2 => ok := NIL
;  ok

;;;     ***       |removeEXITFromCOND?| REDEFINED

(DEFUN |removeEXITFromCOND?| (|c|)
  (PROG (|p| |r| |LETTMP#1| |r1| |f| |ISTMP#1| |r2| |ok|)
    (RETURN
      (SEQ (PROGN
             (setq |ok| 'T)
             (setq |c| (CDR |c|))
             (DO () ((NULL (AND |ok| |c|)) NIL)
               (SEQ (EXIT (PROGN
                            (setq |LETTMP#1| |c|)
                            (setq |p| (CAAR |LETTMP#1|))
                            (setq |r| (CDAR |LETTMP#1|))
                            (setq |c| (CDR |LETTMP#1|))
                            (COND
                              ((|nakedEXIT?| |p|) (setq |ok| NIL))
                              ('T (setq |LETTMP#1| (REVERSE |r|))
                               (setq |r1| (CAR |LETTMP#1|))
                               (setq |f|
                                        (NREVERSE (CDR |LETTMP#1|)))
                               (COND
                                 ((|nakedEXIT?| |f|)
                                  (setq |ok| NIL))
                                 ((NULL (AND (CONSP |r1|)
                                         (EQ (QCAR |r1|) 'EXIT)
                                         (PROGN
                                           (setq |ISTMP#1|
                                            (QCDR |r1|))
                                           (AND (CONSP |ISTMP#1|)
                                            (EQ (QCDR |ISTMP#1|) NIL)
                                            (PROGN
                                              (setq |r2|
                                               (QCAR |ISTMP#1|))
                                              'T)))))
                                  (setq |ok| NIL))
                                 ((|nakedEXIT?| |r2|)
                                  (setq |ok| NIL)))))))))
             |ok|)))))

;removeEXITFromCOND c ==
;  -- c is '(COND ...)
;  z := NIL
;  for cl in CDR c repeat
;    ATOM cl => z := CONS(cl,z)
;    cond := QCAR cl
;    length1? cl =>
;      CONSP(cond) and EQCAR(cond,'EXIT) =>
;        z := CONS(QCDR cond,z)
;      z := CONS(cl,z)
;    cl' := REVERSE cl
;    lastSE := QCAR cl'
;    ATOM lastSE => z := CONS(cl,z)
;    EQCAR(lastSE,'EXIT) =>
;      z := CONS(REVERSE CONS(CADR lastSE,CDR cl'),z)
;    z := CONS(cl,z)
;  CONS('COND,NREVERSE z)

;;;     ***       |removeEXITFromCOND| REDEFINED

(DEFUN |removeEXITFromCOND| (|c|)
  (PROG (|cond| |cl'| |lastSE| |z|)
    (RETURN
      (SEQ (PROGN
             (setq |z| NIL)
             (DO ((G1988 (CDR |c|) (CDR G1988)) (|cl| NIL))
                 ((OR (ATOM G1988)
                      (PROGN (SETQ |cl| (CAR G1988)) NIL))
                  NIL)
               (SEQ (EXIT (COND
                            ((ATOM |cl|) (setq |z| (CONS |cl| |z|)))
                            ('T (setq |cond| (QCAR |cl|))
                             (COND
                               ((|length1?| |cl|)
                                (COND
                                  ((AND (CONSP |cond|)
                                    (EQCAR |cond| 'EXIT))
                                   (setq |z|
                                    (CONS (QCDR |cond|) |z|)))
                                  ('T (setq |z| (CONS |cl| |z|)))))
                               ('T (setq |cl'| (REVERSE |cl|))
                                (setq |lastSE| (QCAR |cl'|))
                                (COND
                                  ((ATOM |lastSE|)
                                   (setq |z| (CONS |cl| |z|)))
                                  ((EQCAR |lastSE| 'EXIT)
                                   (setq |z|
                                    (CONS
                                     (REVERSE
                                      (CONS (CADR |lastSE|)
                                       (CDR |cl'|)))
                                     |z|)))
                                  ('T (setq |z| (CONS |cl| |z|)))))))))))
             (CONS 'COND (NREVERSE |z|)))))))

;flattenCOND body ==
;  -- transforms nested COND clauses to flat ones, if possible
;  body isnt ['COND,:.] => body
;  ['COND,:extractCONDClauses body]

;;;     ***       |flattenCOND| REDEFINED

(DEFUN |flattenCOND| (|body|)
  (COND
    ((NULL (AND (CONSP |body|) (EQ (QCAR |body|) 'COND))) |body|)
    ('T (CONS 'COND (|extractCONDClauses| |body|)))))

;extractCONDClauses clauses ==
;  -- extracts nested COND clauses into a flat structure
;  clauses is ['COND, [pred1,:act1],:restClauses] =>
;    if act1 is [['PROGN,:acts]] then act1 := acts
;    restClauses is [[''T,restCond]] =>
;      [[pred1,:act1],:extractCONDClauses restCond]
;    [[pred1,:act1],:restClauses]
;  [[''T,clauses]]

;;;     ***       |extractCONDClauses| REDEFINED

(DEFUN |extractCONDClauses| (|clauses|)
  (PROG (|pred1| |restClauses| |acts| |act1| |ISTMP#1| |ISTMP#2|
                 |restCond|)
    (RETURN
      (COND
        ((AND (CONSP |clauses|) (EQ (QCAR |clauses|) 'COND)
              (PROGN
                (setq |ISTMP#1| (QCDR |clauses|))
                (AND (CONSP |ISTMP#1|)
                     (PROGN
                       (setq |ISTMP#2| (QCAR |ISTMP#1|))
                       (AND (CONSP |ISTMP#2|)
                            (PROGN
                              (setq |pred1| (QCAR |ISTMP#2|))
                              (setq |act1| (QCDR |ISTMP#2|))
                              'T)))
                     (PROGN
                       (setq |restClauses| (QCDR |ISTMP#1|))
                       'T))))
         (COND
           ((AND (CONSP |act1|) (EQ (QCDR |act1|) NIL)
                 (PROGN
                   (setq |ISTMP#1| (QCAR |act1|))
                   (AND (CONSP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) 'PROGN)
                        (PROGN (setq |acts| (QCDR |ISTMP#1|)) 'T))))
            (setq |act1| |acts|)))
         (COND
           ((AND (CONSP |restClauses|) (EQ (QCDR |restClauses|) NIL)
                 (PROGN
                   (setq |ISTMP#1| (QCAR |restClauses|))
                   (AND (CONSP |ISTMP#1|) (EQUAL (QCAR |ISTMP#1|) ''T)
                        (PROGN
                          (setq |ISTMP#2| (QCDR |ISTMP#1|))
                          (AND (CONSP |ISTMP#2|)
                               (EQ (QCDR |ISTMP#2|) NIL)
                               (PROGN
                                 (setq |restCond| (QCAR |ISTMP#2|))
                                 'T))))))
            (CONS (CONS |pred1| |act1|)
                  (|extractCONDClauses| |restCond|)))
           ('T (CONS (CONS |pred1| |act1|) |restClauses|))))
        ('T (CONS (CONS ''T (CONS |clauses| NIL)) NIL))))))

;--% COND and IF
;
;bootIF c ==
;  -- handles IF expressions by turning them into CONDs
;  c is [.,p,t] => bootCOND ['COND,[p,t]]
;  [.,p,t,e] := c
;  bootCOND ['COND,[p,t],[''T,e]]

;;;     ***       |bootIF| REDEFINED

(DEFUN |bootIF| (|c|)
  (PROG (|ISTMP#1| |ISTMP#2| |p| |t| |e|)
    (RETURN
      (COND
        ((AND (CONSP |c|)
              (PROGN
                (setq |ISTMP#1| (QCDR |c|))
                (AND (CONSP |ISTMP#1|)
                     (PROGN
                       (setq |p| (QCAR |ISTMP#1|))
                       (setq |ISTMP#2| (QCDR |ISTMP#1|))
                       (AND (CONSP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)
                            (PROGN (setq |t| (QCAR |ISTMP#2|)) 'T))))))
         (|bootCOND| (CONS 'COND (CONS (CONS |p| (CONS |t| NIL)) NIL))))
        ('T (setq |p| (CADR |c|)) (setq |t| (CADDR |c|))
         (setq |e| (CADDDR |c|))
         (|bootCOND|
             (CONS 'COND
                   (CONS (CONS |p| (CONS |t| NIL))
                         (CONS (CONS ''T (CONS |e| NIL)) NIL)))))))))

;bootCOND c ==
;  -- handles COND expressions: c is ['COND,:.]
;  cls := CDR c
;  NULL cls => NIL
;  cls is [[''T,r],:.] => r
;  [:icls,fcls] := cls
;  ncls := NIL
;  for cl in icls repeat
;    [p,:r] := cl
;    ncls :=
;      r is [['PROGN,:r1]] => CONS([p,:r1],ncls)
;      CONS(cl,ncls)
;  fcls := bootPushEXITintoCONDclause fcls
;  ncls :=
;    fcls is [''T,['COND,:mcls]] =>
;      APPEND(REVERSE mcls,ncls)
;    fcls is [''T,['PROGN,:mcls]] =>
;      CONS([''T,:mcls],ncls)
;    CONS(fcls,ncls)
;  ['COND,:REVERSE ncls]

;;;     ***       |bootCOND| REDEFINED

(DEFUN |bootCOND| (|c|)
  (PROG (|cls| |LETTMP#1| |icls| |p| |r| |r1| |fcls| |ISTMP#1|
               |ISTMP#2| |mcls| |ncls|)
    (RETURN
      (SEQ (PROGN
             (setq |cls| (CDR |c|))
             (COND
               ((NULL |cls|) NIL)
               ((AND (CONSP |cls|)
                     (PROGN
                       (setq |ISTMP#1| (QCAR |cls|))
                       (AND (CONSP |ISTMP#1|)
                            (EQUAL (QCAR |ISTMP#1|) ''T)
                            (PROGN
                              (setq |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (CONSP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (PROGN
                                     (setq |r| (QCAR |ISTMP#2|))
                                     'T))))))
                |r|)
               ('T (setq |LETTMP#1| (REVERSE |cls|))
                (setq |fcls| (CAR |LETTMP#1|))
                (setq |icls| (NREVERSE (CDR |LETTMP#1|)))
                (setq |ncls| NIL)
                (DO ((G2144 |icls| (CDR G2144)) (|cl| NIL))
                    ((OR (ATOM G2144)
                         (PROGN (SETQ |cl| (CAR G2144)) NIL))
                     NIL)
                  (SEQ (EXIT (PROGN
                               (setq |p| (CAR |cl|))
                               (setq |r| (CDR |cl|))
                               (setq |ncls|
                                        (COND
                                          ((AND (CONSP |r|)
                                            (EQ (QCDR |r|) NIL)
                                            (PROGN
                                              (setq |ISTMP#1|
                                               (QCAR |r|))
                                              (AND (CONSP |ISTMP#1|)
                                               (EQ (QCAR |ISTMP#1|)
                                                'PROGN)
                                               (PROGN
                                                 (setq |r1|
                                                  (QCDR |ISTMP#1|))
                                                 'T))))
                                           (CONS (CONS |p| |r1|)
                                            |ncls|))
                                          ('T (CONS |cl| |ncls|))))))))
                (setq |fcls| (|bootPushEXITintoCONDclause| |fcls|))
                (setq |ncls|
                         (COND
                           ((AND (CONSP |fcls|)
                                 (EQUAL (QCAR |fcls|) ''T)
                                 (PROGN
                                   (setq |ISTMP#1| (QCDR |fcls|))
                                   (AND (CONSP |ISTMP#1|)
                                    (EQ (QCDR |ISTMP#1|) NIL)
                                    (PROGN
                                      (setq |ISTMP#2|
                                       (QCAR |ISTMP#1|))
                                      (AND (CONSP |ISTMP#2|)
                                       (EQ (QCAR |ISTMP#2|) 'COND)
                                       (PROGN
                                         (setq |mcls|
                                          (QCDR |ISTMP#2|))
                                         'T))))))
                            (APPEND (REVERSE |mcls|) |ncls|))
                           ((AND (CONSP |fcls|)
                                 (EQUAL (QCAR |fcls|) ''T)
                                 (PROGN
                                   (setq |ISTMP#1| (QCDR |fcls|))
                                   (AND (CONSP |ISTMP#1|)
                                    (EQ (QCDR |ISTMP#1|) NIL)
                                    (PROGN
                                      (setq |ISTMP#2|
                                       (QCAR |ISTMP#1|))
                                      (AND (CONSP |ISTMP#2|)
                                       (EQ (QCAR |ISTMP#2|) 'PROGN)
                                       (PROGN
                                         (setq |mcls|
                                          (QCDR |ISTMP#2|))
                                         'T))))))
                            (CONS (CONS ''T |mcls|) |ncls|))
                           ('T (CONS |fcls| |ncls|))))
                (CONS 'COND (REVERSE |ncls|)))))))))

;bootPushEXITintoCONDclause e ==
;  e isnt [''T,['EXIT,['COND,:cls]]] => e
;  ncls := NIL
;  for cl in cls repeat
;    [p,:r] := cl
;    ncls :=
;      r is [['EXIT,:.]] => CONS(cl,ncls)
;      r is [r1]           => CONS([p,['EXIT,r1]],ncls)
;      CONS([p,['EXIT,bootTran ['PROGN,:r]]],ncls)
;  [''T,['COND,:NREVERSE ncls]]

;;;     ***       |bootPushEXITintoCONDclause| REDEFINED

(DEFUN |bootPushEXITintoCONDclause| (|e|)
  (PROG (|ISTMP#2| |ISTMP#3| |ISTMP#4| |cls| |p| |r| |ISTMP#1| |r1|
            |ncls|)
    (RETURN
      (SEQ (COND
             ((NULL (AND (CONSP |e|) (EQUAL (QCAR |e|) ''T)
                         (PROGN
                           (setq |ISTMP#1| (QCDR |e|))
                           (AND (CONSP |ISTMP#1|)
                                (EQ (QCDR |ISTMP#1|) NIL)
                                (PROGN
                                  (setq |ISTMP#2| (QCAR |ISTMP#1|))
                                  (AND (CONSP |ISTMP#2|)
                                       (EQ (QCAR |ISTMP#2|) 'EXIT)
                                       (PROGN
                                         (setq |ISTMP#3|
                                          (QCDR |ISTMP#2|))
                                         (AND (CONSP |ISTMP#3|)
                                          (EQ (QCDR |ISTMP#3|) NIL)
                                          (PROGN
                                            (setq |ISTMP#4|
                                             (QCAR |ISTMP#3|))
                                            (AND (CONSP |ISTMP#4|)
                                             (EQ (QCAR |ISTMP#4|)
                                              'COND)
                                             (PROGN
                                               (setq |cls|
                                                (QCDR |ISTMP#4|))
                                               'T)))))))))))
              |e|)
             ('T (setq |ncls| NIL)
              (DO ((G2220 |cls| (CDR G2220)) (|cl| NIL))
                  ((OR (ATOM G2220)
                       (PROGN (SETQ |cl| (CAR G2220)) NIL))
                   NIL)
                (SEQ (EXIT (PROGN
                             (setq |p| (CAR |cl|))
                             (setq |r| (CDR |cl|))
                             (setq |ncls|
                                      (COND
                                        ((AND (CONSP |r|)
                                          (EQ (QCDR |r|) NIL)
                                          (PROGN
                                            (setq |ISTMP#1|
                                             (QCAR |r|))
                                            (AND (CONSP |ISTMP#1|)
                                             (EQ (QCAR |ISTMP#1|)
                                              'EXIT))))
                                         (CONS |cl| |ncls|))
                                        ((AND (CONSP |r|)
                                          (EQ (QCDR |r|) NIL)
                                          (PROGN
                                            (setq |r1| (QCAR |r|))
                                            'T))
                                         (CONS
                                          (CONS |p|
                                           (CONS
                                            (CONS 'EXIT
                                             (CONS |r1| NIL))
                                            NIL))
                                          |ncls|))
                                        ('T
                                         (CONS
                                          (CONS |p|
                                           (CONS
                                            (CONS 'EXIT
                                             (CONS
                                              (|bootTran|
                                               (CONS 'PROGN |r|))
                                              NIL))
                                            NIL))
                                          |ncls|))))))))
              (CONS ''T (CONS (CONS 'COND (NREVERSE |ncls|)) NIL))))))))

;--% SEQ and PROGN
;
;-- following is a more sophisticated def than that in MACRO LISP
;-- it is used for boot code
;
;tryToRemoveSEQ e ==
;  -- returns e if unsuccessful
;  e isnt ['SEQ,cl,:cls] => NIL
;  nakedEXIT? cl =>
;    cl is ['COND,[p,['EXIT,r]],:ccls] =>
;      nakedEXIT? p or nakedEXIT? r => e
;      null ccls =>
;        bootCOND ['COND,[p,r],[''T,bootSEQ ['SEQ,:cls]]]
;      bootCOND ['COND,[p,r],[''T,bootSEQ ['SEQ,['COND,:ccls],:cls]]]
;    e
;  bootPROGN ['PROGN,cl,bootSEQ ['SEQ,:cls]]

;;;     ***       |tryToRemoveSEQ| REDEFINED

(DEFUN |tryToRemoveSEQ| (|e|)
  (PROG (|cl| |cls| |ISTMP#1| |ISTMP#2| |p| |ISTMP#3| |ISTMP#4|
              |ISTMP#5| |r| |ccls|)
    (RETURN
      (SEQ (COND
             ((NULL (AND (CONSP |e|) (EQ (QCAR |e|) 'SEQ)
                         (PROGN
                           (setq |ISTMP#1| (QCDR |e|))
                           (AND (CONSP |ISTMP#1|)
                                (PROGN
                                  (setq |cl| (QCAR |ISTMP#1|))
                                  (setq |cls| (QCDR |ISTMP#1|))
                                  'T)))))
              NIL)
             ((|nakedEXIT?| |cl|)
              (COND
                ((AND (CONSP |cl|) (EQ (QCAR |cl|) 'COND)
                      (PROGN
                        (setq |ISTMP#1| (QCDR |cl|))
                        (AND (CONSP |ISTMP#1|)
                             (PROGN
                               (setq |ISTMP#2| (QCAR |ISTMP#1|))
                               (AND (CONSP |ISTMP#2|)
                                    (PROGN
                                      (setq |p| (QCAR |ISTMP#2|))
                                      (setq |ISTMP#3|
                                       (QCDR |ISTMP#2|))
                                      (AND (CONSP |ISTMP#3|)
                                       (EQ (QCDR |ISTMP#3|) NIL)
                                       (PROGN
                                         (setq |ISTMP#4|
                                          (QCAR |ISTMP#3|))
                                         (AND (CONSP |ISTMP#4|)
                                          (EQ (QCAR |ISTMP#4|) 'EXIT)
                                          (PROGN
                                            (setq |ISTMP#5|
                                             (QCDR |ISTMP#4|))
                                            (AND (CONSP |ISTMP#5|)
                                             (EQ (QCDR |ISTMP#5|) NIL)
                                             (PROGN
                                               (setq |r|
                                                (QCAR |ISTMP#5|))
                                               'T)))))))))
                             (PROGN
                               (setq |ccls| (QCDR |ISTMP#1|))
                               'T))))
                 (COND
                   ((OR (|nakedEXIT?| |p|) (|nakedEXIT?| |r|)) |e|)
                   ((NULL |ccls|)
                    (|bootCOND|
                        (CONS 'COND
                              (CONS (CONS |p| (CONS |r| NIL))
                                    (CONS
                                     (CONS ''T
                                      (CONS
                                       (|bootSEQ| (CONS 'SEQ |cls|))
                                       NIL))
                                     NIL)))))
                   ('T
                    (|bootCOND|
                        (CONS 'COND
                              (CONS (CONS |p| (CONS |r| NIL))
                                    (CONS
                                     (CONS ''T
                                      (CONS
                                       (|bootSEQ|
                                        (CONS 'SEQ
                                         (CONS (CONS 'COND |ccls|)
                                          |cls|)))
                                       NIL))
                                     NIL)))))))
                ('T |e|)))
             ('T
              (|bootPROGN|
                  (CONS 'PROGN
                        (CONS |cl|
                              (CONS (|bootSEQ| (CONS 'SEQ |cls|)) NIL))))))))))

;bootAbsorbSEQsAndPROGNs e ==
;  -- assume e is a list from a SEQ or a PROGN
;  ATOM e => e
;  [:cls,lcl] := e
;  g := [:flatten(f) for f in cls] where
;    flatten x ==
;      NULL x => NIL
;      IDENTP x =>
;        MEMQ(x,$labelsForGO) => [x]
;        NIL
;      ATOM x => NIL
;      x is ['PROGN,:pcls,lpcl] =>
;        ATOM lpcl => pcls
;        CDR x
;      -- next usually comes about from if foo then bar := zap
;      x is ['COND,y,[''T,'NIL]] => [['COND,y]]
;      [x]
;  while lcl is ['EXIT,f] repeat
;    lcl := f
;  lcl is ['PROGN,:pcls] => APPEND(g,pcls)
;  lcl is ['COND,[''T,:pcls]] => APPEND(g,pcls)
;  lcl is ['COND,[pred,['EXIT,h]]] =>
;    APPEND(g,[['COND,[pred,h]]])
;  APPEND(g,[lcl])

;;;     ***       |bootAbsorbSEQsAndPROGNs,flatten| REDEFINED

(DEFUN |bootAbsorbSEQsAndPROGNs,flatten| (|x|)
  (PROG (|lpcl| |pcls| |ISTMP#1| |y| |ISTMP#2| |ISTMP#3| |ISTMP#4|)
    (DECLARE (SPECIAL |$labelsForGO|))
    (RETURN
      (SEQ (IF (NULL |x|) (EXIT NIL))
           (IF (IDENTP |x|)
               (EXIT (SEQ (IF (member |x| |$labelsForGO|)
                              (EXIT (CONS |x| NIL)))
                          (EXIT NIL))))
           (IF (ATOM |x|) (EXIT NIL))
           (IF (AND (CONSP |x|) (EQ (QCAR |x|) 'PROGN)
                    (PROGN
                      (setq |ISTMP#1| (QCDR |x|))
                      (AND (AND (CONSP |ISTMP#1|)
                                (PROGN
                                  (setq |ISTMP#2|
                                           (REVERSE |ISTMP#1|))
                                  'T))
                           (AND (CONSP |ISTMP#2|)
                                (PROGN
                                  (setq |lpcl| (QCAR |ISTMP#2|))
                                  (setq |pcls| (QCDR |ISTMP#2|))
                                  'T))
                           (PROGN
                             (setq |pcls| (NREVERSE |pcls|))
                             'T))))
               (EXIT (SEQ (IF (ATOM |lpcl|) (EXIT |pcls|))
                          (EXIT (CDR |x|)))))
           (IF (AND (CONSP |x|) (EQ (QCAR |x|) 'COND)
                    (PROGN
                      (setq |ISTMP#1| (QCDR |x|))
                      (AND (CONSP |ISTMP#1|)
                           (PROGN
                             (setq |y| (QCAR |ISTMP#1|))
                             (setq |ISTMP#2| (QCDR |ISTMP#1|))
                             (AND (CONSP |ISTMP#2|)
                                  (EQ (QCDR |ISTMP#2|) NIL)
                                  (PROGN
                                    (setq |ISTMP#3|
                                     (QCAR |ISTMP#2|))
                                    (AND (CONSP |ISTMP#3|)
                                     (EQUAL (QCAR |ISTMP#3|) ''T)
                                     (PROGN
                                       (setq |ISTMP#4|
                                        (QCDR |ISTMP#3|))
                                       (AND (CONSP |ISTMP#4|)
                                        (EQ (QCDR |ISTMP#4|) NIL)
                                        (EQUAL (QCAR |ISTMP#4|) 'NIL))))))))))
               (EXIT (CONS (CONS 'COND (CONS |y| NIL)) NIL)))
           (EXIT (CONS |x| NIL))))))

;;;     ***       |bootAbsorbSEQsAndPROGNs| REDEFINED

(DEFUN |bootAbsorbSEQsAndPROGNs| (|e|)
  (PROG (|LETTMP#1| |cls| |g| |f| |lcl| |pcls| |ISTMP#1| |ISTMP#2|
            |pred| |ISTMP#3| |ISTMP#4| |ISTMP#5| |h|)
    (RETURN
      (SEQ (COND
             ((ATOM |e|) |e|)
             ('T (setq |LETTMP#1| (REVERSE |e|))
              (setq |lcl| (CAR |LETTMP#1|))
              (setq |cls| (NREVERSE (CDR |LETTMP#1|)))
              (setq |g|
                       (PROG (G2445)
                         (setq G2445 NIL)
                         (RETURN
                           (DO ((G2450 |cls| (CDR G2450))
                                (|f| NIL))
                               ((OR (ATOM G2450)
                                    (PROGN
                                      (SETQ |f| (CAR G2450))
                                      NIL))
                                G2445)
                             (SEQ (EXIT (SETQ G2445
                                         (APPEND G2445
                                          (|bootAbsorbSEQsAndPROGNs,flatten|
                                           |f|)))))))))
              (DO ()
                  ((NULL (AND (CONSP |lcl|) (EQ (QCAR |lcl|) 'EXIT)
                              (PROGN
                                (setq |ISTMP#1| (QCDR |lcl|))
                                (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (PROGN
                                       (setq |f| (QCAR |ISTMP#1|))
                                       'T)))))
                   NIL)
                (SEQ (EXIT (setq |lcl| |f|))))
              (COND
                ((AND (CONSP |lcl|) (EQ (QCAR |lcl|) 'PROGN)
                      (PROGN (setq |pcls| (QCDR |lcl|)) 'T))
                 (APPEND |g| |pcls|))
                ((AND (CONSP |lcl|) (EQ (QCAR |lcl|) 'COND)
                      (PROGN
                        (setq |ISTMP#1| (QCDR |lcl|))
                        (AND (CONSP |ISTMP#1|)
                             (EQ (QCDR |ISTMP#1|) NIL)
                             (PROGN
                               (setq |ISTMP#2| (QCAR |ISTMP#1|))
                               (AND (CONSP |ISTMP#2|)
                                    (EQUAL (QCAR |ISTMP#2|) ''T)
                                    (PROGN
                                      (setq |pcls| (QCDR |ISTMP#2|))
                                      'T))))))
                 (APPEND |g| |pcls|))
                ((AND (CONSP |lcl|) (EQ (QCAR |lcl|) 'COND)
                      (PROGN
                        (setq |ISTMP#1| (QCDR |lcl|))
                        (AND (CONSP |ISTMP#1|)
                             (EQ (QCDR |ISTMP#1|) NIL)
                             (PROGN
                               (setq |ISTMP#2| (QCAR |ISTMP#1|))
                               (AND (CONSP |ISTMP#2|)
                                    (PROGN
                                      (setq |pred| (QCAR |ISTMP#2|))
                                      (setq |ISTMP#3|
                                       (QCDR |ISTMP#2|))
                                      (AND (CONSP |ISTMP#3|)
                                       (EQ (QCDR |ISTMP#3|) NIL)
                                       (PROGN
                                         (setq |ISTMP#4|
                                          (QCAR |ISTMP#3|))
                                         (AND (CONSP |ISTMP#4|)
                                          (EQ (QCAR |ISTMP#4|) 'EXIT)
                                          (PROGN
                                            (setq |ISTMP#5|
                                             (QCDR |ISTMP#4|))
                                            (AND (CONSP |ISTMP#5|)
                                             (EQ (QCDR |ISTMP#5|) NIL)
                                             (PROGN
                                               (setq |h|
                                                (QCAR |ISTMP#5|))
                                               'T))))))))))))
                 (APPEND |g|
                         (CONS (CONS 'COND
                                     (CONS (CONS |pred| (CONS |h| NIL))
                                      NIL))
                               NIL)))
                ('T (APPEND |g| (CONS |lcl| NIL))))))))))

;bootSEQ e ==
;  e := ['SEQ,:mergeCONDsWithEXITs bootAbsorbSEQsAndPROGNs CDR e]
;  if e is [.,:cls,lcl] and IDENTP lcl and not MEMQ(lcl,$labelsForGO) then
;    e := ['SEQ,:cls,['EXIT,lcl]]
;  cls := QCDR e
;  cls is [['SEQ,:.]] => tryToRemoveSEQ QCAR cls
;  cls is [['EXIT,body]] =>
;    nakedEXIT? body => bootTran ['SEQ,body]
;    body
;  not (nakedEXIT?(cls) or "or"/[MEMQ(g,$labelsForGO) for g in cls]) =>
;    bootTran ['PROGN,:cls]
;  e is ['SEQ,['COND,[pred,['EXIT,r1]]],:r2] =>
;    nakedEXIT?(pred) or nakedEXIT?(r1) or nakedEXIT?(r2) =>
;      tryToRemoveSEQ e
;    bootTran ['COND,[pred,r1],[''T,:r2]]
;  tryToRemoveSEQ e

;;;     ***       |bootSEQ| REDEFINED

(DEFUN |bootSEQ| (|e|)
  (PROG (|lcl| |cls| |body| |ISTMP#1| |ISTMP#2| |ISTMP#3| |ISTMP#4|
               |pred| |ISTMP#5| |ISTMP#6| |ISTMP#7| |r1| |r2|)
    (DECLARE (SPECIAL |$labelsForGO|))
    (RETURN
      (SEQ (PROGN
             (setq |e|
                      (CONS 'SEQ
                            (|mergeCONDsWithEXITs|
                                (|bootAbsorbSEQsAndPROGNs| (CDR |e|)))))
             (COND
               ((AND (CONSP |e|)
                     (PROGN
                       (setq |ISTMP#1| (QCDR |e|))
                       (AND (CONSP |ISTMP#1|)
                            (PROGN
                              (setq |ISTMP#2| (REVERSE |ISTMP#1|))
                              'T)
                            (CONSP |ISTMP#2|)
                            (PROGN
                              (setq |lcl| (QCAR |ISTMP#2|))
                              (setq |cls| (QCDR |ISTMP#2|))
                              'T)
                            (PROGN
                              (setq |cls| (NREVERSE |cls|))
                              'T)))
                     (IDENTP |lcl|) (NULL (member |lcl| |$labelsForGO|)))
                (setq |e|
                         (CONS 'SEQ
                               (APPEND |cls|
                                       (CONS
                                        (CONS 'EXIT (CONS |lcl| NIL))
                                        NIL))))))
             (setq |cls| (QCDR |e|))
             (COND
               ((AND (CONSP |cls|) (EQ (QCDR |cls|) NIL)
                     (PROGN
                       (setq |ISTMP#1| (QCAR |cls|))
                       (AND (CONSP |ISTMP#1|)
                            (EQ (QCAR |ISTMP#1|) 'SEQ))))
                (|tryToRemoveSEQ| (QCAR |cls|)))
               ((AND (CONSP |cls|) (EQ (QCDR |cls|) NIL)
                     (PROGN
                       (setq |ISTMP#1| (QCAR |cls|))
                       (AND (CONSP |ISTMP#1|)
                            (EQ (QCAR |ISTMP#1|) 'EXIT)
                            (PROGN
                              (setq |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (CONSP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (PROGN
                                     (setq |body| (QCAR |ISTMP#2|))
                                     'T))))))
                (COND
                  ((|nakedEXIT?| |body|)
                   (|bootTran| (CONS 'SEQ (CONS |body| NIL))))
                  ('T |body|)))
               ((NULL (OR (|nakedEXIT?| |cls|)
                          (PROG (G2596)
                            (setq G2596 NIL)
                            (RETURN
                              (DO ((G2602 NIL G2596)
                                   (G2603 |cls| (CDR G2603))
                                   (|g| NIL))
                                  ((OR G2602 (ATOM G2603)
                                    (PROGN
                                      (SETQ |g| (CAR G2603))
                                      NIL))
                                   G2596)
                                (SEQ (EXIT
                                      (SETQ G2596
                                       (OR G2596
                                        (member |g| |$labelsForGO|))))))))))
                (|bootTran| (CONS 'PROGN |cls|)))
               ((AND (CONSP |e|) (EQ (QCAR |e|) 'SEQ)
                     (PROGN
                       (setq |ISTMP#1| (QCDR |e|))
                       (AND (CONSP |ISTMP#1|)
                            (PROGN
                              (setq |ISTMP#2| (QCAR |ISTMP#1|))
                              (AND (CONSP |ISTMP#2|)
                                   (EQ (QCAR |ISTMP#2|) 'COND)
                                   (PROGN
                                     (setq |ISTMP#3|
                                      (QCDR |ISTMP#2|))
                                     (AND (CONSP |ISTMP#3|)
                                      (EQ (QCDR |ISTMP#3|) NIL)
                                      (PROGN
                                        (setq |ISTMP#4|
                                         (QCAR |ISTMP#3|))
                                        (AND (CONSP |ISTMP#4|)
                                         (PROGN
                                           (setq |pred|
                                            (QCAR |ISTMP#4|))
                                           (setq |ISTMP#5|
                                            (QCDR |ISTMP#4|))
                                           (AND (CONSP |ISTMP#5|)
                                            (EQ (QCDR |ISTMP#5|) NIL)
                                            (PROGN
                                              (setq |ISTMP#6|
                                               (QCAR |ISTMP#5|))
                                              (AND (CONSP |ISTMP#6|)
                                               (EQ (QCAR |ISTMP#6|)
                                                'EXIT)
                                               (PROGN
                                                 (setq |ISTMP#7|
                                                  (QCDR |ISTMP#6|))
                                                 (AND (CONSP |ISTMP#7|)
                                                  (EQ (QCDR |ISTMP#7|)
                                                   NIL)
                                                  (PROGN
                                                    (setq |r1|
                                                     (QCAR |ISTMP#7|))
                                                    'T)))))))))))))
                            (PROGN (setq |r2| (QCDR |ISTMP#1|)) 'T))))
                (COND
                  ((OR (|nakedEXIT?| |pred|) (|nakedEXIT?| |r1|)
                       (|nakedEXIT?| |r2|))
                   (|tryToRemoveSEQ| |e|))
                  ('T
                   (|bootTran|
                       (CONS 'COND
                             (CONS (CONS |pred| (CONS |r1| NIL))
                                   (CONS (CONS ''T |r2|) NIL)))))))
               ('T (|tryToRemoveSEQ| |e|))))))))

;bootPROGN e ==
;  e := ['PROGN,:bootAbsorbSEQsAndPROGNs CDR e]
;  [.,:cls] := e
;  NULL cls => NIL
;  cls is [body] => body
;  e

;;;     ***       |bootPROGN| REDEFINED

(DEFUN |bootPROGN| (|e|)
  (PROG (|cls| |body|)
    (RETURN
      (PROGN
        (setq |e|
                 (CONS 'PROGN (|bootAbsorbSEQsAndPROGNs| (CDR |e|))))
        (setq |cls| (CDR |e|))
        (COND
          ((NULL |cls|) NIL)
          ((AND (CONSP |cls|) (EQ (QCDR |cls|) NIL)
                (PROGN (setq |body| (QCAR |cls|)) 'T))
           |body|)
          ('T |e|))))))

;--% OR and AND
;
;bootOR e ==
;  -- flatten any contained ORs.
;  cls := CDR e
;  NULL cls => NIL
;  NULL CDR cls => CAR cls
;  ncls := [:flatten(c) for c in cls] where
;    flatten x ==
;      x is ['OR,:.] => QCDR x
;      [x]
;  ['OR,:ncls]

;;;     ***       |bootOR,flatten| REDEFINED

(DEFUN |bootOR,flatten| (|x|)
  (SEQ (IF (AND (CONSP |x|) (EQ (QCAR |x|) 'OR)) (EXIT (QCDR |x|)))
       (EXIT (CONS |x| NIL))))

;;;     ***       |bootOR| REDEFINED

(DEFUN |bootOR| (|e|)
  (PROG (|cls| |ncls|)
    (RETURN
      (SEQ (PROGN
             (setq |cls| (CDR |e|))
             (COND
               ((NULL |cls|) NIL)
               ((NULL (CDR |cls|)) (CAR |cls|))
               ('T
                (setq |ncls|
                         (PROG (G2934)
                           (setq G2934 NIL)
                           (RETURN
                             (DO ((G2939 |cls| (CDR G2939))
                                  (|c| NIL))
                                 ((OR (ATOM G2939)
                                      (PROGN
                                        (SETQ |c| (CAR G2939))
                                        NIL))
                                  G2934)
                               (SEQ (EXIT
                                     (SETQ G2934
                                      (APPEND G2934
                                       (|bootOR,flatten| |c|)))))))))
                (CONS 'OR |ncls|))))))))

;bootAND e ==
;  -- flatten any contained ANDs.
;  cls := CDR e
;  NULL cls => 'T
;  NULL CDR cls => CAR cls
;  ncls := [:flatten(c) for c in cls] where
;    flatten x ==
;      x is ['AND,:.] => QCDR x
;      [x]
;  ['AND,:ncls]

;;;     ***       |bootAND,flatten| REDEFINED

(DEFUN |bootAND,flatten| (|x|)
  (SEQ (IF (AND (CONSP |x|) (EQ (QCAR |x|) 'AND)) (EXIT (QCDR |x|)))
       (EXIT (CONS |x| NIL))))

;;;     ***       |bootAND| REDEFINED

(DEFUN |bootAND| (|e|)
  (PROG (|cls| |ncls|)
    (RETURN
      (SEQ (PROGN
             (setq |cls| (CDR |e|))
             (COND
               ((NULL |cls|) 'T)
               ((NULL (CDR |cls|)) (CAR |cls|))
               ('T
                (setq |ncls|
                         (PROG (G2957)
                           (setq G2957 NIL)
                           (RETURN
                             (DO ((G2962 |cls| (CDR G2962))
                                  (|c| NIL))
                                 ((OR (ATOM G2962)
                                      (PROGN
                                        (SETQ |c| (CAR G2962))
                                        NIL))
                                  G2957)
                               (SEQ (EXIT
                                     (SETQ G2957
                                      (APPEND G2957
                                       (|bootAND,flatten| |c|)))))))))
                (CONS 'AND |ncls|))))))))

;--% Main Transformation Functions
;
;bootLabelsForGO e ==
;  ATOM e => NIL
;  [head,:tail] := e
;  IDENTP head =>
;    head = 'GO => $labelsForGO := CONS(CAR tail,$labelsForGO)
;    head = 'QUOTE => NIL
;    bootLabelsForGO tail
;  bootLabelsForGO head
;  bootLabelsForGO tail

;;;     ***       |bootLabelsForGO| REDEFINED

(DEFUN |bootLabelsForGO| (|e|)
  (PROG (|head| |tail|)
    (DECLARE (SPECIAL |$labelsForGO|))
    (RETURN
      (COND
        ((ATOM |e|) NIL)
        ('T (setq |head| (CAR |e|)) (setq |tail| (CDR |e|))
         (COND
           ((IDENTP |head|)
            (COND
              ((BOOT-EQUAL |head| 'GO)
               (setq |$labelsForGO|
                        (CONS (CAR |tail|) |$labelsForGO|)))
              ((BOOT-EQUAL |head| 'QUOTE) NIL)
              ('T (|bootLabelsForGO| |tail|))))
           ('T (|bootLabelsForGO| |head|) (|bootLabelsForGO| |tail|))))))))

;bootTran e ==
;  ATOM e => e
;  [head,:tail] := e
;  head = 'QUOTE => e
;  tail := [bootTran t for t in tail]
;  e := [head,:tail]
;  IDENTP head =>
;    head = 'IF    => bootIF e
;    head = 'COND  => bootCOND e
;    head = 'PROGN => bootPROGN  e
;    head = 'SEQ   => bootSEQ  e
;    head = 'OR    => bootOR  e
;    head = 'AND   => bootAND  e
;    e
;  [bootTran head,:QCDR e]

;;;     ***       |bootTran| REDEFINED

(DEFUN |bootTran| (|e|)
  (PROG (|head| |tail|)
    (RETURN
      (SEQ (COND
             ((ATOM |e|) |e|)
             ('T (setq |head| (CAR |e|)) (setq |tail| (CDR |e|))
              (COND
                ((BOOT-EQUAL |head| 'QUOTE) |e|)
                ('T
                 (setq |tail|
                          (PROG (G2994)
                            (setq G2994 NIL)
                            (RETURN
                              (DO ((G2999 |tail| (CDR G2999))
                                   (|t| NIL))
                                  ((OR (ATOM G2999)
                                    (PROGN
                                      (SETQ |t| (CAR G2999))
                                      NIL))
                                   (NREVERSE0 G2994))
                                (SEQ (EXIT
                                      (SETQ G2994
                                       (CONS (|bootTran| |t|) G2994))))))))
                 (setq |e| (CONS |head| |tail|))
                 (COND
                   ((IDENTP |head|)
                    (COND
                      ((BOOT-EQUAL |head| 'IF) (|bootIF| |e|))
                      ((BOOT-EQUAL |head| 'COND) (|bootCOND| |e|))
                      ((BOOT-EQUAL |head| 'PROGN) (|bootPROGN| |e|))
                      ((BOOT-EQUAL |head| 'SEQ) (|bootSEQ| |e|))
                      ((BOOT-EQUAL |head| 'OR) (|bootOR| |e|))
                      ((BOOT-EQUAL |head| 'AND) (|bootAND| |e|))
                      ('T |e|)))
                   ('T (CONS (|bootTran| |head|) (QCDR |e|))))))))))))

;bootTransform e ==
;--NULL $BOOT => e
;  $labelsForGO : local := NIL
;  bootLabelsForGO e
;  bootTran e

;;;     ***       |bootTransform| REDEFINED

(DEFUN |bootTransform| (|e|)
  (PROG (|$labelsForGO|)
    (DECLARE (SPECIAL |$labelsForGO|))
    (RETURN
      (PROGN
        (setq |$labelsForGO| NIL)
        (|bootLabelsForGO| |e|)
        (|bootTran| |e|)))))

\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
