\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp cparse.boot}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=

(IN-PACKAGE "BOOT")

;npList(f,str1,g)== -- always produces a list, g is applied to it
;    if APPLY(f,nil)
;    then
;        if npEqKey str1 and (npEqKey "BACKSET" or true)
;                       and (APPLY(f,nil) or npTrap())
;        then
;          a:=$stack
;          $stack:=nil
;          while npEqKey str1 and (npEqKey "BACKSET" or true) and
;                             (APPLY(f,nil) or npTrap()) repeat 0
;          $stack:=cons(NREVERSE $stack,a)
;          npPush FUNCALL(g,  [npPop3(),npPop2(),:npPop1()])
;        else
;          npPush FUNCALL(g, [npPop1()])
;    else npPush FUNCALL(g, [])
;
(DEFUN |npList| (|f| |str1| |g|)
 (PROG (|a|)
 (DECLARE (SPECIAL |$stack|))
  (RETURN
   (COND
    ((APPLY |f| NIL)
     (COND
      ((AND
         (|npEqKey| |str1|)
         (OR (|npEqKey| (QUOTE BACKSET)) T)
         (OR (APPLY |f| NIL) (|npTrap|)))
        (SETQ |a| |$stack|)
        (SETQ |$stack| NIL)
        ((LAMBDA ()
         (LOOP
          (COND
           ((NOT
             (AND
              (|npEqKey| |str1|)
              (OR (|npEqKey| (QUOTE BACKSET)) T)
              (OR (APPLY |f| NIL) (|npTrap|))))
            (RETURN NIL))
           ((QUOTE T) 0)))))
        (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|))
        (|npPush|
         (FUNCALL |g| (CONS (|npPop3|) (CONS (|npPop2|) (|npPop1|))))))
      (#0=(QUOTE T) (|npPush| (FUNCALL |g| (LIST (|npPop1|)))))))
    (#0# (|npPush| (FUNCALL |g| NIL)))))))


;-- s must transform the head of the stack
;
;npAnyNo s==
;     while APPLY(s,nil) repeat 0
;     true
(DEFUN |npAnyNo| (|s|)
 (PROG NIL
  (RETURN
   (PROGN
    ((LAMBDA ()
     (LOOP
      (COND
       ((NOT (APPLY |s| NIL)) (RETURN NIL))
       ((QUOTE T) 0)))))
    T))))

;npAndOr(keyword,p,f)==
;   npEqKey keyword and (APPLY(p,nil) or npTrap())
;             and npPush FUNCALL(f, npPop1())
(DEFUN |npAndOr| (|keyword| |p| |f|)
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| |keyword|)
    (OR (APPLY |p| NIL) (|npTrap|))
    (|npPush| (FUNCALL |f| (|npPop1|)))))))

;npInfixOp()==
;  EQ(CAAR $stok,"key") and
;    GET($ttok,"INFGENERIC") and npPushId()
(DEFUN |npInfixOp| ()
 (PROG NIL
 (DECLARE (SPECIAL |$ttok| |$stok|))
  (RETURN
   (AND
    (EQ (CAAR |$stok|) (QUOTE |key|))
    (GET |$ttok| (QUOTE INFGENERIC))
    (|npPushId|)))))

;npInfixOperator()== npInfixOp() or
;        a:=npState()
;        b:=$stok
;        npEqKey "'" and npInfixOp() =>
;                npPush pfSymb (npPop1 (),tokPosn b)
;        npRestore a
;        npEqKey "BACKQUOTE" and  npInfixOp() =>
;                a:=npPop1()
;                npPush tokConstruct("idsy",tokPart a,tokPosn a)
;        npRestore a
;        false
(DEFUN |npInfixOperator| ()
 (PROG (|b| |a|)
 (DECLARE (SPECIAL |$stok|))
  (RETURN
   (OR
    (|npInfixOp|)
    (PROGN
     (SETQ |a| (|npState|))
     (SETQ |b| |$stok|)
     (COND
      ((AND (|npEqKey| (QUOTE |'|)) (|npInfixOp|))
       (|npPush| (|pfSymb| (|npPop1|) (|tokPosn| |b|))))
      (#0=(QUOTE T)
       (PROGN
        (|npRestore| |a|)
        (COND
         ((AND (|npEqKey| (QUOTE BACKQUOTE)) (|npInfixOp|))
          (PROGN
           (SETQ |a| (|npPop1|))
           (|npPush|
            (|tokConstruct| (QUOTE |idsy|) (|tokPart| |a|) (|tokPosn| |a|)))))
         (#0# (PROGN (|npRestore| |a|) NIL)))))))))))

;-- Parsing functions

;npTypedForm1(sy,fn) ==
;     npEqKey sy  and (npType() or npTrap()) and
;        npPush FUNCALL(fn,npPop2(),npPop1())
(DEFUN |npTypedForm1| (|sy| |fn|)
 (PROG NIL
  (RETURN 
   (AND
    (|npEqKey| |sy|)
    (OR (|npType|) (|npTrap|))
    (|npPush| (FUNCALL |fn| (|npPop2|) (|npPop1|)))))))

;npTypedForm(sy,fn) ==
;     npEqKey sy  and (npApplication() or npTrap()) and
;        npPush FUNCALL(fn,npPop2(),npPop1())
(DEFUN |npTypedForm| (|sy| |fn|)
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| |sy|)
    (OR (|npApplication|) (|npTrap|))
    (|npPush| (FUNCALL |fn| (|npPop2|) (|npPop1|)))))))

;npRestrict() == npTypedForm("AT",function pfRestrict)
(DEFUN |npRestrict| ()
 (PROG NIL
  (RETURN
   (|npTypedForm| (QUOTE AT) (FUNCTION |pfRestrict|)))))

;npCoerceTo() == npTypedForm("COERCE",function pfCoerceto)
(DEFUN |npCoerceTo| ()
 (PROG NIL
  (RETURN 
   (|npTypedForm| (QUOTE COERCE) (FUNCTION |pfCoerceto|)))))

;npColonQuery() == npTypedForm("ATAT",function pfRetractTo)
(DEFUN |npColonQuery| ()
 (PROG NIL 
  (RETURN 
   (|npTypedForm| (QUOTE ATAT) (FUNCTION |pfRetractTo|)))))

;npPretend() == npTypedForm("PRETEND",function pfPretend)
(DEFUN |npPretend| ()
 (PROG NIL
  (RETURN
   (|npTypedForm| (QUOTE PRETEND) (FUNCTION |pfPretend|)))))

;npTypeStyle()==
; npCoerceTo() or npRestrict() or npPretend() or npColonQuery()
(DEFUN |npTypeStyle| ()
 (PROG NIL
  (RETURN
   (OR (|npCoerceTo|) (|npRestrict|) (|npPretend|) (|npColonQuery|)))))

;npTypified ()==npApplication() and npAnyNo function npTypeStyle
(DEFUN |npTypified| ()
 (PROG NIL
  (RETURN
   (AND (|npApplication|) (|npAnyNo| (FUNCTION |npTypeStyle|))))))

;npTagged() == npTypedForm1("COLON",function pfTagged)
(DEFUN |npTagged| ()
 (PROG NIL
  (RETURN
   (|npTypedForm1| (QUOTE COLON) (FUNCTION |pfTagged|)))))

;npColon () == npTypified() and npAnyNo function npTagged
(DEFUN |npColon| ()
 (PROG NIL
  (RETURN
   (AND (|npTypified|) (|npAnyNo| (FUNCTION |npTagged|))))))

;npPower() == npRightAssoc('(POWER CARAT),function npColon)
(DEFUN |npPower| ()
 (PROG NIL 
  (RETURN 
   (|npRightAssoc| (QUOTE (POWER CARAT)) (FUNCTION |npColon|)))))

;npProduct()==
;    npLeftAssoc('(TIMES SLASH BACKSLASH SLASHSLASH
;       BACKSLASHBACKSLASH SLASHBACKSLASH BACKSLASHSLASH )
;                       ,function npPower)
(DEFUN |npProduct| ()
 (PROG NIL
  (RETURN
   (|npLeftAssoc|
    (QUOTE (TIMES SLASH BACKSLASH SLASHSLASH BACKSLASHBACKSLASH 
            SLASHBACKSLASH BACKSLASHSLASH))
    (FUNCTION |npPower|)))))

;npRemainder()==
;    npLeftAssoc('(REM QUO )  ,function npProduct)
(DEFUN |npRemainder| ()
 (PROG NIL
  (RETURN 
   (|npLeftAssoc| (QUOTE (REM QUO)) (FUNCTION |npProduct|)))))

;npTerm()==
;   npInfGeneric '(MINUS PLUS) and (npRemainder()
;        and npPush(pfApplication(npPop2(),npPop1())) or true)
;             or npRemainder()
(DEFUN |npTerm| ()
 (PROG NIL
  (RETURN
   (OR
    (AND
     (|npInfGeneric| (QUOTE (MINUS PLUS)))
     (OR
      (AND (|npRemainder|) (|npPush| (|pfApplication| (|npPop2|) (|npPop1|))))
      T))
    (|npRemainder|)))))

;
;npSum()==npLeftAssoc('(PLUS MINUS),function npTerm)
(DEFUN |npSum| ()
 (PROG NIL
  (RETURN
   (|npLeftAssoc| (QUOTE (PLUS MINUS)) (FUNCTION |npTerm|)))))

;npArith()==npLeftAssoc('(MOD),function npSum)
(DEFUN |npArith| ()
 (PROG NIL
  (RETURN 
   (|npLeftAssoc| (QUOTE (MOD)) (FUNCTION |npSum|)))))

;npSegment()==  npEqPeek "SEG"  and npPushId() and npFromdom()
(DEFUN |npSegment| ()
 (PROG NIL
  (RETURN
   (AND (|npEqPeek| (QUOTE SEG)) (|npPushId|) (|npFromdom|)))))

;npInterval()==
;  npArith() and
;   (npSegment() and ((npEqPeek "BAR"
;      and npPush(pfApplication(npPop1(),npPop1()))) or
;     (npArith() and npPush(pfInfApplication(npPop2(),npPop2(),npPop1())))
;            or npPush(pfApplication(npPop1(),npPop1()))) or true)
(DEFUN |npInterval| ()
 (PROG NIL
  (RETURN
   (AND
    (|npArith|)
    (OR
     (AND
      (|npSegment|)
      (OR
       (AND
        (|npEqPeek| (QUOTE BAR))
        (|npPush| (|pfApplication| (|npPop1|) (|npPop1|))))
       (AND
        (|npArith|)
        (|npPush| (|pfInfApplication| (|npPop2|) (|npPop2|) (|npPop1|))))
       (|npPush| (|pfApplication| (|npPop1|) (|npPop1|)))))
     T)))))

;npConditionalStatement()==npConditional function npQualifiedDefinition
(DEFUN |npConditionalStatement| ()
 (PROG NIL
  (RETURN
   (|npConditional| (FUNCTION |npQualifiedDefinition|)))))

;npExpress1()==npConditionalStatement() or  npADD()
(DEFUN |npExpress1| ()
 (PROG NIL
  (RETURN
   (OR (|npConditionalStatement|) (|npADD|)))))

;npExpress()==
;     npExpress1() and
;        (npIterators() and
;             npPush pfCollect (npPop2(),pfListOf npPop1()) or true)
(DEFUN |npExpress| ()
 (PROG NIL
  (RETURN
   (AND
    (|npExpress1|)
    (OR
     (AND
      (|npIterators|)
      (|npPush| (|pfCollect| (|npPop2|) (|pfListOf| (|npPop1|)))))
     T)))))

;npZeroOrMore f==
;       APPLY(f,nil)=>
;         a:=$stack
;         $stack:=nil
;         while APPLY(f,nil) repeat 0
;         $stack:=cons(NREVERSE $stack,a)
;         npPush cons(npPop2(),npPop1())
;       npPush nil
;       true
(DEFUN |npZeroOrMore| (|f|)
 (PROG (|a|)
 (DECLARE (SPECIAL |$stack|))
  (RETURN
   (COND
    ((APPLY |f| NIL)
     (PROGN
      (SETQ |a| |$stack|)
      (SETQ |$stack| NIL)
      ((LAMBDA ()
        (LOOP
         (COND 
          ((NOT (APPLY |f| NIL)) (RETURN NIL))
          ((QUOTE T) 0)))))
      (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|))
      (|npPush| (CONS (|npPop2|) (|npPop1|)))))
    ((QUOTE T) (PROGN (|npPush| NIL) T))))))

;npIterators()==
;         npForIn() and npZeroOrMore function npIterator
;             and npPush cons(npPop2(),npPop1())  or
;              npWhile() and (npIterators() and
;                    npPush cons(npPop2(),npPop1()) or npPush [npPop1()])
(DEFUN |npIterators| ()
 (PROG NIL
  (RETURN
   (OR
    (AND
     (|npForIn|)
     (|npZeroOrMore| (FUNCTION |npIterator|))
     (|npPush| (CONS (|npPop2|) (|npPop1|))))
    (AND
     (|npWhile|)
     (OR
      (AND (|npIterators|) (|npPush| (CONS (|npPop2|) (|npPop1|))))
      (|npPush| (LIST (|npPop1|)))))))))

;npIterator()==   npForIn() or npSuchThat() or npWhile()
(DEFUN |npIterator| ()
 (PROG NIL 
  (RETURN 
   (OR
    (|npForIn|)
    (|npSuchThat|)
    (|npWhile|)))))

;npStatement()==
;        npExpress() or
;        npLoop() or
;        npIterate() or
;        npReturn() or
;        npBreak() or
;        npFree() or
;        npImport() or
;        npInline() or
;        npLocal() or
;        npExport() or
;        npTyping() or
;        npVoid()
(DEFUN |npStatement| () 
 (PROG NIL
  (RETURN
   (OR
    (|npExpress|)
    (|npLoop|)
    (|npIterate|)
    (|npReturn|)
    (|npBreak|)
    (|npFree|)
    (|npImport|)
    (|npInline|)
    (|npLocal|)
    (|npExport|)
    (|npTyping|)
    (|npVoid|)))))

;npMDEF()== npBackTrack(function npStatement,"MDEF",function npMDEFinition)
(DEFUN |npMDEF| () 
 (PROG NIL
  (RETURN
   (|npBackTrack| (FUNCTION |npStatement|) 'MDEF (FUNCTION |npMDEFinition|)))))

;npMDEFinition() == npPP function npMdef
(DEFUN |npMDEFinition| ()
 (PROG NIL
  (RETURN
   (|npPP| (FUNCTION |npMdef|)))))

;npAssignVariableName()==npApplication() and
;      a:=npPop1()
;      if pfId? a
;      then
;         (npPush a and npDecl() or npPush pfTyped(npPop1(),pfNothing()))
;      else npPush a
(DEFUN |npAssignVariableName| ()
 (PROG (|a|)
  (RETURN
   (AND
    (|npApplication|)
    (PROGN
     (SETQ |a| (|npPop1|))
     (COND
      ((|pfId?| |a|)
       (OR
        (AND (|npPush| |a|) (|npDecl|))
        (|npPush| (|pfTyped| (|npPop1|) (|pfNothing|)))))
      ((QUOTE T)
       (|npPush| |a|))))))))

;npAssignVariablelist()== npListing function npAssignVariableName
(DEFUN |npAssignVariablelist| ()
 (PROG NIL
  (RETURN
   (|npListing| (FUNCTION |npAssignVariableName|)))))

;npVoid()== npAndOr("DO",function npStatement,function pfNovalue)
(DEFUN |npVoid| ()
 (PROG NIL
  (RETURN
   (|npAndOr| (QUOTE DO) (FUNCTION |npStatement|) (FUNCTION |pfNovalue|)))))

;npReturn()==
;         npEqKey "RETURN" and
;          (npExpress() or npPush pfNothing()) and
;           (npEqKey "FROM" and (npName() or npTrap()) and
;              npPush pfReturn (npPop2(),npPop1()) or
;                npPush pfReturnNoName npPop1())
(DEFUN |npReturn| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE RETURN))
    (OR 
     (|npExpress|)
     (|npPush| (|pfNothing|)))
    (OR
     (AND
      (|npEqKey| (QUOTE FROM))
      (OR (|npName|) (|npTrap|))
      (|npPush| (|pfReturn| (|npPop2|) (|npPop1|))))
     (|npPush| (|pfReturnNoName| (|npPop1|))))))))

;npLoop()==
;     npIterators() and
;      (npCompMissing "REPEAT" and
;         (npAssign() or npTrap()) and
;            npPush pfLp(npPop2(),npPop1()))
;                or
;                  npEqKey "REPEAT" and (npAssign() or npTrap()) and
;                       npPush pfLoop1 npPop1 ()
(DEFUN |npLoop| ()
 (PROG NIL
  (RETURN
   (OR
    (AND 
     (|npIterators|)
     (|npCompMissing| (QUOTE REPEAT))
     (OR (|npAssign|) (|npTrap|))
     (|npPush| (|pfLp| (|npPop2|) (|npPop1|))))
    (AND
     (|npEqKey| (QUOTE REPEAT))
     (OR (|npAssign|) (|npTrap|))
     (|npPush| (|pfLoop1| (|npPop1|))))))))

;npSuchThat()==npAndOr("BAR",function npLogical,function pfSuchthat)
(DEFUN |npSuchThat| ()
 (PROG NIL
  (RETURN
   (|npAndOr| (QUOTE BAR) (FUNCTION |npLogical|) (FUNCTION |pfSuchthat|)))))

;npWhile()==npAndOr ("WHILE",function npLogical,function pfWhile)
(DEFUN |npWhile| ()
 (PROG NIL
  (RETURN 
   (|npAndOr| (QUOTE WHILE) (FUNCTION |npLogical|) (FUNCTION |pfWhile|)))))

;npForIn()==
;  npEqKey "FOR" and (npVariable() or npTrap()) and (npCompMissing "IN")
;      and ((npBy()  or npTrap()) and
;         npPush pfForin(npPop2(),npPop1()))
(DEFUN |npForIn| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE FOR))
    (OR (|npVariable|) (|npTrap|))
    (|npCompMissing| (QUOTE IN))
    (OR (|npBy|) (|npTrap|))
    (|npPush| (|pfForin| (|npPop2|) (|npPop1|)))))))

;npBreak()==
;     npEqKey "BREAK" and  npPush pfBreak pfNothing ()
(DEFUN |npBreak| ()
 (PROG NIL
  (RETURN
   (AND (|npEqKey| (QUOTE BREAK)) (|npPush| (|pfBreak| (|pfNothing|)))))))

;npIterate()==
;     npEqKey "ITERATE" and  npPush pfIterate pfNothing ()
(DEFUN |npIterate| ()
 (PROG NIL
  (RETURN
   (AND (|npEqKey| (QUOTE ITERATE)) (|npPush| (|pfIterate| (|pfNothing|)))))))

;npQualType()==
;     npType() and
;            npPush pfQualType(npPop1(),pfNothing())
(DEFUN |npQualType| () 
 (PROG NIL
  (RETURN
   (AND
    (|npType|)
    (|npPush| (|pfQualType| (|npPop1|) (|pfNothing|)))))))

;npSQualTypelist()== npListing function npQualType
;                and npPush pfParts npPop1 ()
(DEFUN |npSQualTypelist| ()
 (PROG NIL
  (RETURN
   (AND
    (|npListing| (FUNCTION |npQualType|))
    (|npPush| (|pfParts| (|npPop1|)))))))

;npQualTypelist()== npPC function npSQualTypelist
;                             and npPush pfUnSequence npPop1 ()
(DEFUN |npQualTypelist| ()
 (PROG NIL
  (RETURN
   (AND
    (|npPC| (FUNCTION |npSQualTypelist|))
    (|npPush| (|pfUnSequence| (|npPop1|)))))))

;npInline()==npAndOr("INLINE",function npQualTypelist,function pfInline)
(DEFUN |npInline| () 
 (PROG NIL
  (RETURN
   (|npAndOr| 'INLINE (FUNCTION |npQualTypelist|) (FUNCTION |pfInline|)))))

;npLocalDecl()== npEqKey "COLON" and (npType() or npTrap()) and
;             npPush pfSpread (pfParts npPop2(),npPop1()) or
;              npPush pfSpread (pfParts npPop1(),pfNothing())
(DEFUN |npLocalDecl| ()
 (PROG NIL
  (RETURN
   (OR
    (AND
     (|npEqKey| (QUOTE COLON))
     (OR (|npType|) (|npTrap|))
     (|npPush| (|pfSpread| (|pfParts| (|npPop2|)) (|npPop1|))))
    (|npPush| (|pfSpread| (|pfParts| (|npPop1|)) (|pfNothing|)))))))

;npLocalItem()==npTypeVariable() and  npLocalDecl()
(DEFUN |npLocalItem| ()
 (PROG NIL
  (RETURN
   (AND
    (|npTypeVariable|)
    (|npLocalDecl|)))))

;npLocalItemlist()== npPC function npSLocalItem
;                             and npPush pfUnSequence npPop1 ()
(DEFUN |npLocalItemlist| ()
 (PROG NIL
  (RETURN
   (AND
    (|npPC| (FUNCTION |npSLocalItem|))
    (|npPush| (|pfUnSequence| (|npPop1|)))))))

;npSLocalItem()== npListing function npLocalItem
;        and npPush  pfAppend pfParts npPop1()
(DEFUN |npSLocalItem| ()
 (PROG NIL
  (RETURN
   (AND
    (|npListing| (FUNCTION |npLocalItem|))
    (|npPush| (|pfAppend| (|pfParts| (|npPop1|))))))))

;npFree()== npEqKey "FREE" and (npLocalItemlist() or npTrap())
;     and npPush pfFree npPop1()
(DEFUN |npFree| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE FREE))
    (OR (|npLocalItemlist|) (|npTrap|))
    (|npPush| (|pfFree| (|npPop1|)))))))

;npLocal()== npEqKey "local" and (npLocalItemlist() or npTrap())
;     and npPush pfLocal npPop1()
(DEFUN |npLocal| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE |local|))
    (OR (|npLocalItemlist|) (|npTrap|))
    (|npPush| (|pfLocal| (|npPop1|)))))))

;npExport()== npEqKey "EXPORT" and (npLocalItemlist() or npTrap())
;     and npPush pfExport npPop1()
(DEFUN |npExport| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE EXPORT))
    (OR (|npLocalItemlist|) (|npTrap|))
    (|npPush| (|pfExport| (|npPop1|)))))))

;npFix()== npEqKey "FIX" and  npPP function npDef
;               and npPush pfFix npPop1 ()
(DEFUN |npFix| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE FIX))
    (|npPP| (FUNCTION |npDef|))
    (|npPush| (|pfFix| (|npPop1|)))))))

;npMacro()== npEqKey "MACRO" and  npPP function npMdef
(DEFUN |npMacro| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE MACRO))
    (|npPP| (FUNCTION |npMdef|))))))

;npAdd(extra)==
;     npEqKey "ADD" and
;       a:=npState()
;       npDefinitionOrStatement() or npTrap()
;       npEqPeek "IN" =>
;               npRestore a
;               (npVariable() or npTrap()) and
;                     npCompMissing "IN"  and
;                         (npDefinitionOrStatement() or npTrap()) and
;                            npPush pfAdd(npPop2(),npPop1(),extra)
;       npPush pfAdd(pfNothing(),npPop1(),extra)
(DEFUN |npAdd| (|extra|)
 (PROG (|a|)
  (RETURN
   (AND
    (|npEqKey| (QUOTE ADD))
    (PROGN
     (SETQ |a| (|npState|))
     (OR (|npDefinitionOrStatement|) (|npTrap|))
     (COND
      ((|npEqPeek| (QUOTE IN))
       (PROGN
        (|npRestore| |a|)
        (AND
         (OR (|npVariable|) (|npTrap|))
         (|npCompMissing| (QUOTE IN))
         (OR (|npDefinitionOrStatement|) (|npTrap|))
         (|npPush| (|pfAdd| (|npPop2|) (|npPop1|) |extra|)))))
      ((QUOTE T)
       (|npPush| (|pfAdd| (|pfNothing|) (|npPop1|) |extra|)))))))))

;npSignatureDefinee()==
;   npName() or npInfixOperator() or npPrefixColon()
(DEFUN |npSignatureDefinee| ()
 (PROG NIL
  (RETURN
   (OR (|npName|) (|npInfixOperator|) (|npPrefixColon|)))))

;
;npSigDecl()== npEqKey "COLON" and (npType() or npTrap()) and
;           npPush pfSpread (pfParts npPop2(),npPop1())
(DEFUN |npSigDecl| () 
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE COLON))
    (OR (|npType|) (|npTrap|))
    (|npPush| (|pfSpread| (|pfParts| (|npPop2|)) (|npPop1|)))))))

;npSigItem()==npTypeVariable() and  (npSigDecl() or npTrap())
(DEFUN |npSigItem| ()
 (PROG NIL
  (RETURN
   (AND (|npTypeVariable|) (OR (|npSigDecl|) (|npTrap|))))))

;npSigItemlist()== npListing function npSigItem
;        and npPush pfListOf pfAppend pfParts npPop1()
(DEFUN |npSigItemlist| ()
 (PROG NIL
  (RETURN
   (AND
    (|npListing| (FUNCTION |npSigItem|))
    (|npPush| (|pfListOf| (|pfAppend| (|pfParts| (|npPop1|)))))))))

;npSignature()==
;    npSigItemlist() and
;            npPush pfWDec(pfNothing(),npPop1())
(DEFUN |npSignature| ()
 (PROG NIL
  (RETURN
   (AND (|npSigItemlist|) (|npPush| (|pfWDec| (|pfNothing|) (|npPop1|)))))))

;npDecl()== npEqKey "COLON" and (npType() or npTrap()) and
;           npPush pfTyped (npPop2(),npPop1())
(DEFUN |npDecl| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE COLON))
    (OR (|npType|) (|npTrap|))
    (|npPush| (|pfTyped| (|npPop2|) (|npPop1|)))))))

;npVariableName()==npName() and
;      (npDecl() or npPush pfTyped(npPop1(),pfNothing()))
(DEFUN |npVariableName| ()
 (PROG NIL
  (RETURN
   (AND
    (|npName|)
    (OR (|npDecl|) (|npPush| (|pfTyped| (|npPop1|) (|pfNothing|))))))))

;npVariablelist()== npListing function npVariableName
(DEFUN |npVariablelist| ()
 (PROG NIL
  (RETURN
   (|npListing| (FUNCTION |npVariableName|)))))

;npListing (p)==npList(p,"COMMA",function pfListOf)
(DEFUN |npListing| (|p|)
 (PROG NIL
  (RETURN
   (|npList| |p| (QUOTE COMMA) (FUNCTION |pfListOf|)))))

;npQualified(f)==
;    if FUNCALL f
;    then
;     while npEqKey "WHERE" and (npDefinition() or npTrap()) repeat
;             npPush pfWhere(npPop1(),npPop1())
;     true
;    else  npLetQualified  f
(DEFUN |npQualified| (|f|)
 (PROG NIL
  (RETURN
   (COND
    ((FUNCALL |f|)
     ((LAMBDA NIL
      (LOOP
       (COND
        ((NOT (AND (|npEqKey| (QUOTE WHERE)) (OR (|npDefinition|) (|npTrap|))))
         (RETURN NIL))
        ((QUOTE T)
         (|npPush| (|pfWhere| (|npPop1|) (|npPop1|)))))))) T)
    ((QUOTE T) (|npLetQualified| |f|))))))

;npQualifiedDefinition()==
;       npQualified function npDefinitionOrStatement
(DEFUN |npQualifiedDefinition| ()
 (PROG NIL
  (RETURN
   (|npQualified| (FUNCTION |npDefinitionOrStatement|)))))

;npTuple (p)==
;    npListofFun(p,function npCommaBackSet,function pfTupleListOf)
(DEFUN |npTuple| (|p|)
 (PROG NIL
  (RETURN
   (|npListofFun| |p|
    (FUNCTION |npCommaBackSet|)
    (FUNCTION |pfTupleListOf|)))))

;npComma()==  npTuple function npQualifiedDefinition
(DEFUN |npComma| ()
 (PROG NIL
  (RETURN
   (|npTuple| (FUNCTION |npQualifiedDefinition|)))))

;npQualDef()== npComma() and npPush [npPop1()]
(DEFUN |npQualDef| ()
 (PROG NIL
  (RETURN
   (AND
    (|npComma|)
    (|npPush| (LIST (|npPop1|)))))))

;npPDefinition ()==
;     npParenthesized function npDefinitionlist and
;                 npPush pfEnSequence npPop1()
(DEFUN |npPDefinition| ()
 (PROG NIL
  (RETURN
   (AND
    (|npParenthesized| (FUNCTION |npDefinitionlist|))
    (|npPush| (|pfEnSequence| (|npPop1|)))))))

;npTypeVariable()== npParenthesized function npTypeVariablelist or
;           npSignatureDefinee() and npPush pfListOf [npPop1()]
(DEFUN |npTypeVariable| ()
 (PROG NIL
  (RETURN
   (OR
    (|npParenthesized| (FUNCTION |npTypeVariablelist|))
    (AND (|npSignatureDefinee|) (|npPush| (|pfListOf| (LIST (|npPop1|)))))))))

;npTypeVariablelist()== npListing function npSignatureDefinee
(DEFUN |npTypeVariablelist| ()
 (PROG NIL
  (RETURN
   (|npListing| (FUNCTION |npSignatureDefinee|)))))

;npTyping()==
;      npEqKey "DEFAULT" and  (npDefaultItemlist() or npTrap())
;                and npPush pfTyping npPop1()
(DEFUN |npTyping| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE DEFAULT))
    (OR (|npDefaultItemlist|) (|npTrap|))
    (|npPush| (|pfTyping| (|npPop1|)))))))

;npDefaultItemlist()== npPC function npSDefaultItem
;                             and npPush pfUnSequence npPop1 ()
(DEFUN |npDefaultItemlist| ()
 (PROG NIL
  (RETURN
   (AND
    (|npPC| (FUNCTION |npSDefaultItem|))
    (|npPush| (|pfUnSequence| (|npPop1|)))))))

;npDefaultDecl()== npEqKey "COLON" and (npType() or npTrap()) and
;           npPush pfSpread (pfParts npPop2(),npPop1())
(DEFUN |npDefaultDecl| ()
 (PROG NIL 
  (RETURN
   (AND
    (|npEqKey| (QUOTE COLON))
    (OR (|npType|) (|npTrap|))
    (|npPush| (|pfSpread| (|pfParts| (|npPop2|)) (|npPop1|)))))))

;npDefaultItem()==npTypeVariable() and (npDefaultDecl() or npTrap())
(DEFUN |npDefaultItem| ()
 (PROG NIL
  (RETURN
   (AND
    (|npTypeVariable|)
    (OR (|npDefaultDecl|) (|npTrap|))))))

;npSDefaultItem()== npListing function npDefaultItem
;        and npPush pfAppend pfParts npPop1()
(DEFUN |npSDefaultItem| ()
 (PROG NIL
  (RETURN
   (AND
    (|npListing| (FUNCTION |npDefaultItem|))
    (|npPush| (|pfAppend| (|pfParts| (|npPop1|))))))))

;npDef()==
;    npMatch() =>
;         [op,arg,rt]:=  pfCheckItOut(npPop1())
;         npDefTail() or npTrap()
;         body:=npPop1()
;         null arg => npPush pfDefinition (op,body)
;         npPush pfDefinition (op,pfPushBody(rt,arg,body))
;    false

;npMdef()==
;    npQuiver() =>
;         [op,arg]:=  pfCheckMacroOut(npPop1())
;         npDefTail() or npTrap()
;         body:=npPop1()
;         null arg => npPush pfMacro (op,body)
;         npPush pfMacro (op,pfPushMacroBody(arg,body))
;    false
(DEFUN |npMdef| ()
 (PROG (|body| |arg| |op| |LETTMP#1|)
  (RETURN
   (COND
    ((|npQuiver|)
     (PROGN
      (SETQ |LETTMP#1| (|pfCheckMacroOut| (|npPop1|)))
      (SETQ |op| (CAR |LETTMP#1|))
      (SETQ |arg| (CADR |LETTMP#1|))
      (OR (|npDefTail|) (|npTrap|))
      (SETQ |body| (|npPop1|))
      (COND
       ((NULL |arg|)
        (|npPush| (|pfMacro| |op| |body|)))
       (#0=(QUOTE T)
        (|npPush| (|pfMacro| |op| (|pfPushMacroBody| |arg| |body|)))))))
    (#0# NIL)))))

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
