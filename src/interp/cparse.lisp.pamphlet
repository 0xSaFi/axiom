\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp cparse.boot}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=

(IN-PACKAGE "BOOT")

;-- Parsing functions

;npTypedForm1(sy,fn) ==
;     npEqKey sy  and (npType() or npTrap()) and
;        npPush FUNCALL(fn,npPop2(),npPop1())
(DEFUN |npTypedForm1| (|sy| |fn|)
 (PROG NIL
  (RETURN 
   (AND
    (|npEqKey| |sy|)
    (OR (|npType|) (|npTrap|))
    (|npPush| (FUNCALL |fn| (|npPop2|) (|npPop1|)))))))

;npTypedForm(sy,fn) ==
;     npEqKey sy  and (npApplication() or npTrap()) and
;        npPush FUNCALL(fn,npPop2(),npPop1())
(DEFUN |npTypedForm| (|sy| |fn|)
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| |sy|)
    (OR (|npApplication|) (|npTrap|))
    (|npPush| (FUNCALL |fn| (|npPop2|) (|npPop1|)))))))

;npRestrict() == npTypedForm("AT",function pfRestrict)
(DEFUN |npRestrict| ()
 (PROG NIL
  (RETURN
   (|npTypedForm| (QUOTE AT) (FUNCTION |pfRestrict|)))))

;npCoerceTo() == npTypedForm("COERCE",function pfCoerceto)
(DEFUN |npCoerceTo| ()
 (PROG NIL
  (RETURN 
   (|npTypedForm| (QUOTE COERCE) (FUNCTION |pfCoerceto|)))))

;npColonQuery() == npTypedForm("ATAT",function pfRetractTo)
(DEFUN |npColonQuery| ()
 (PROG NIL 
  (RETURN 
   (|npTypedForm| (QUOTE ATAT) (FUNCTION |pfRetractTo|)))))

;npPretend() == npTypedForm("PRETEND",function pfPretend)
(DEFUN |npPretend| ()
 (PROG NIL
  (RETURN
   (|npTypedForm| (QUOTE PRETEND) (FUNCTION |pfPretend|)))))

;npTypeStyle()==
; npCoerceTo() or npRestrict() or npPretend() or npColonQuery()
(DEFUN |npTypeStyle| ()
 (PROG NIL
  (RETURN
   (OR (|npCoerceTo|) (|npRestrict|) (|npPretend|) (|npColonQuery|)))))

;npTypified ()==npApplication() and npAnyNo function npTypeStyle
(DEFUN |npTypified| ()
 (PROG NIL
  (RETURN
   (AND (|npApplication|) (|npAnyNo| (FUNCTION |npTypeStyle|))))))

;npTagged() == npTypedForm1("COLON",function pfTagged)
(DEFUN |npTagged| ()
 (PROG NIL
  (RETURN
   (|npTypedForm1| (QUOTE COLON) (FUNCTION |pfTagged|)))))

;npPower() == npRightAssoc('(POWER CARAT),function npColon)
(DEFUN |npPower| ()
 (PROG NIL 
  (RETURN 
   (|npRightAssoc| (QUOTE (POWER CARAT)) (FUNCTION |npColon|)))))

;npProduct()==
;    npLeftAssoc('(TIMES SLASH BACKSLASH SLASHSLASH
;       BACKSLASHBACKSLASH SLASHBACKSLASH BACKSLASHSLASH )
;                       ,function npPower)
(DEFUN |npProduct| ()
 (PROG NIL
  (RETURN
   (|npLeftAssoc|
    (QUOTE (TIMES SLASH BACKSLASH SLASHSLASH BACKSLASHBACKSLASH 
            SLASHBACKSLASH BACKSLASHSLASH))
    (FUNCTION |npPower|)))))

;npRemainder()==
;    npLeftAssoc('(REM QUO )  ,function npProduct)
(DEFUN |npRemainder| ()
 (PROG NIL
  (RETURN 
   (|npLeftAssoc| (QUOTE (REM QUO)) (FUNCTION |npProduct|)))))

;npTerm()==
;   npInfGeneric '(MINUS PLUS) and (npRemainder()
;        and npPush(pfApplication(npPop2(),npPop1())) or true)
;             or npRemainder()
(DEFUN |npTerm| ()
 (PROG NIL
  (RETURN
   (OR
    (AND
     (|npInfGeneric| (QUOTE (MINUS PLUS)))
     (OR
      (AND (|npRemainder|) (|npPush| (|pfApplication| (|npPop2|) (|npPop1|))))
      T))
    (|npRemainder|)))))

;
;npSum()==npLeftAssoc('(PLUS MINUS),function npTerm)
(DEFUN |npSum| ()
 (PROG NIL
  (RETURN
   (|npLeftAssoc| (QUOTE (PLUS MINUS)) (FUNCTION |npTerm|)))))

;npArith()==npLeftAssoc('(MOD),function npSum)
(DEFUN |npArith| ()
 (PROG NIL
  (RETURN 
   (|npLeftAssoc| (QUOTE (MOD)) (FUNCTION |npSum|)))))

;npSegment()==  npEqPeek "SEG"  and npPushId() and npFromdom()
(DEFUN |npSegment| ()
 (PROG NIL
  (RETURN
   (AND (|npEqPeek| (QUOTE SEG)) (|npPushId|) (|npFromdom|)))))

;npConditionalStatement()==npConditional function npQualifiedDefinition
(DEFUN |npConditionalStatement| ()
 (PROG NIL
  (RETURN
   (|npConditional| (FUNCTION |npQualifiedDefinition|)))))

;npExpress1()==npConditionalStatement() or  npADD()
(DEFUN |npExpress1| ()
 (PROG NIL
  (RETURN
   (OR (|npConditionalStatement|) (|npADD|)))))

;npExpress()==
;     npExpress1() and
;        (npIterators() and
;             npPush pfCollect (npPop2(),pfListOf npPop1()) or true)
(DEFUN |npExpress| ()
 (PROG NIL
  (RETURN
   (AND
    (|npExpress1|)
    (OR
     (AND
      (|npIterators|)
      (|npPush| (|pfCollect| (|npPop2|) (|pfListOf| (|npPop1|)))))
     T)))))

;npZeroOrMore f==
;       APPLY(f,nil)=>
;         a:=$stack
;         $stack:=nil
;         while APPLY(f,nil) repeat 0
;         $stack:=cons(NREVERSE $stack,a)
;         npPush cons(npPop2(),npPop1())
;       npPush nil
;       true
(DEFUN |npZeroOrMore| (|f|)
 (PROG (|a|)
 (DECLARE (SPECIAL |$stack|))
  (RETURN
   (COND
    ((APPLY |f| NIL)
     (PROGN
      (SETQ |a| |$stack|)
      (SETQ |$stack| NIL)
      ((LAMBDA ()
        (LOOP
         (COND 
          ((NOT (APPLY |f| NIL)) (RETURN NIL))
          ((QUOTE T) 0)))))
      (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|))
      (|npPush| (CONS (|npPop2|) (|npPop1|)))))
    ((QUOTE T) (PROGN (|npPush| NIL) T))))))

;npIterators()==
;         npForIn() and npZeroOrMore function npIterator
;             and npPush cons(npPop2(),npPop1())  or
;              npWhile() and (npIterators() and
;                    npPush cons(npPop2(),npPop1()) or npPush [npPop1()])
(DEFUN |npIterators| ()
 (PROG NIL
  (RETURN
   (OR
    (AND
     (|npForIn|)
     (|npZeroOrMore| (FUNCTION |npIterator|))
     (|npPush| (CONS (|npPop2|) (|npPop1|))))
    (AND
     (|npWhile|)
     (OR
      (AND (|npIterators|) (|npPush| (CONS (|npPop2|) (|npPop1|))))
      (|npPush| (LIST (|npPop1|)))))))))

;npIterator()==   npForIn() or npSuchThat() or npWhile()
(DEFUN |npIterator| ()
 (PROG NIL 
  (RETURN 
   (OR
    (|npForIn|)
    (|npSuchThat|)
    (|npWhile|)))))

;npMDEF()== npBackTrack(function npStatement,"MDEF",function npMDEFinition)
(DEFUN |npMDEF| () 
 (PROG NIL
  (RETURN
   (|npBackTrack| (FUNCTION |npStatement|) 'MDEF (FUNCTION |npMDEFinition|)))))

;npMDEFinition() == npPP function npMdef
(DEFUN |npMDEFinition| ()
 (PROG NIL
  (RETURN
   (|npPP| (FUNCTION |npMdef|)))))

;npAssignVariableName()==npApplication() and
;      a:=npPop1()
;      if pfId? a
;      then
;         (npPush a and npDecl() or npPush pfTyped(npPop1(),pfNothing()))
;      else npPush a
(DEFUN |npAssignVariableName| ()
 (PROG (|a|)
  (RETURN
   (AND
    (|npApplication|)
    (PROGN
     (SETQ |a| (|npPop1|))
     (COND
      ((|pfId?| |a|)
       (OR
        (AND (|npPush| |a|) (|npDecl|))
        (|npPush| (|pfTyped| (|npPop1|) (|pfNothing|)))))
      ((QUOTE T)
       (|npPush| |a|))))))))

;npAssignVariablelist()== npListing function npAssignVariableName
(DEFUN |npAssignVariablelist| ()
 (PROG NIL
  (RETURN
   (|npListing| (FUNCTION |npAssignVariableName|)))))

;npVoid()== npAndOr("DO",function npStatement,function pfNovalue)
(DEFUN |npVoid| ()
 (PROG NIL
  (RETURN
   (|npAndOr| (QUOTE DO) (FUNCTION |npStatement|) (FUNCTION |pfNovalue|)))))

;npReturn()==
;         npEqKey "RETURN" and
;          (npExpress() or npPush pfNothing()) and
;           (npEqKey "FROM" and (npName() or npTrap()) and
;              npPush pfReturn (npPop2(),npPop1()) or
;                npPush pfReturnNoName npPop1())
(DEFUN |npReturn| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE RETURN))
    (OR 
     (|npExpress|)
     (|npPush| (|pfNothing|)))
    (OR
     (AND
      (|npEqKey| (QUOTE FROM))
      (OR (|npName|) (|npTrap|))
      (|npPush| (|pfReturn| (|npPop2|) (|npPop1|))))
     (|npPush| (|pfReturnNoName| (|npPop1|))))))))

;npLoop()==
;     npIterators() and
;      (npCompMissing "REPEAT" and
;         (npAssign() or npTrap()) and
;            npPush pfLp(npPop2(),npPop1()))
;                or
;                  npEqKey "REPEAT" and (npAssign() or npTrap()) and
;                       npPush pfLoop1 npPop1 ()
(DEFUN |npLoop| ()
 (PROG NIL
  (RETURN
   (OR
    (AND 
     (|npIterators|)
     (|npCompMissing| (QUOTE REPEAT))
     (OR (|npAssign|) (|npTrap|))
     (|npPush| (|pfLp| (|npPop2|) (|npPop1|))))
    (AND
     (|npEqKey| (QUOTE REPEAT))
     (OR (|npAssign|) (|npTrap|))
     (|npPush| (|pfLoop1| (|npPop1|))))))))

;npSuchThat()==npAndOr("BAR",function npLogical,function pfSuchthat)
(DEFUN |npSuchThat| ()
 (PROG NIL
  (RETURN
   (|npAndOr| (QUOTE BAR) (FUNCTION |npLogical|) (FUNCTION |pfSuchthat|)))))

;npWhile()==npAndOr ("WHILE",function npLogical,function pfWhile)
(DEFUN |npWhile| ()
 (PROG NIL
  (RETURN 
   (|npAndOr| (QUOTE WHILE) (FUNCTION |npLogical|) (FUNCTION |pfWhile|)))))

;npForIn()==
;  npEqKey "FOR" and (npVariable() or npTrap()) and (npCompMissing "IN")
;      and ((npBy()  or npTrap()) and
;         npPush pfForin(npPop2(),npPop1()))
(DEFUN |npForIn| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE FOR))
    (OR (|npVariable|) (|npTrap|))
    (|npCompMissing| (QUOTE IN))
    (OR (|npBy|) (|npTrap|))
    (|npPush| (|pfForin| (|npPop2|) (|npPop1|)))))))

;npBreak()==
;     npEqKey "BREAK" and  npPush pfBreak pfNothing ()
(DEFUN |npBreak| ()
 (PROG NIL
  (RETURN
   (AND (|npEqKey| (QUOTE BREAK)) (|npPush| (|pfBreak| (|pfNothing|)))))))

;npIterate()==
;     npEqKey "ITERATE" and  npPush pfIterate pfNothing ()
(DEFUN |npIterate| ()
 (PROG NIL
  (RETURN
   (AND (|npEqKey| (QUOTE ITERATE)) (|npPush| (|pfIterate| (|pfNothing|)))))))

;npQualType()==
;     npType() and
;            npPush pfQualType(npPop1(),pfNothing())
(DEFUN |npQualType| () 
 (PROG NIL
  (RETURN
   (AND
    (|npType|)
    (|npPush| (|pfQualType| (|npPop1|) (|pfNothing|)))))))

;npSQualTypelist()== npListing function npQualType
;                and npPush pfParts npPop1 ()
(DEFUN |npSQualTypelist| ()
 (PROG NIL
  (RETURN
   (AND
    (|npListing| (FUNCTION |npQualType|))
    (|npPush| (|pfParts| (|npPop1|)))))))

;npQualTypelist()== npPC function npSQualTypelist
;                             and npPush pfUnSequence npPop1 ()
(DEFUN |npQualTypelist| ()
 (PROG NIL
  (RETURN
   (AND
    (|npPC| (FUNCTION |npSQualTypelist|))
    (|npPush| (|pfUnSequence| (|npPop1|)))))))

;npInline()==npAndOr("INLINE",function npQualTypelist,function pfInline)
(DEFUN |npInline| () 
 (PROG NIL
  (RETURN
   (|npAndOr| 'INLINE (FUNCTION |npQualTypelist|) (FUNCTION |pfInline|)))))

;npLocalDecl()== npEqKey "COLON" and (npType() or npTrap()) and
;             npPush pfSpread (pfParts npPop2(),npPop1()) or
;              npPush pfSpread (pfParts npPop1(),pfNothing())
(DEFUN |npLocalDecl| ()
 (PROG NIL
  (RETURN
   (OR
    (AND
     (|npEqKey| (QUOTE COLON))
     (OR (|npType|) (|npTrap|))
     (|npPush| (|pfSpread| (|pfParts| (|npPop2|)) (|npPop1|))))
    (|npPush| (|pfSpread| (|pfParts| (|npPop1|)) (|pfNothing|)))))))

;npLocalItem()==npTypeVariable() and  npLocalDecl()
(DEFUN |npLocalItem| ()
 (PROG NIL
  (RETURN
   (AND
    (|npTypeVariable|)
    (|npLocalDecl|)))))

;npLocalItemlist()== npPC function npSLocalItem
;                             and npPush pfUnSequence npPop1 ()
(DEFUN |npLocalItemlist| ()
 (PROG NIL
  (RETURN
   (AND
    (|npPC| (FUNCTION |npSLocalItem|))
    (|npPush| (|pfUnSequence| (|npPop1|)))))))

;npSLocalItem()== npListing function npLocalItem
;        and npPush  pfAppend pfParts npPop1()
(DEFUN |npSLocalItem| ()
 (PROG NIL
  (RETURN
   (AND
    (|npListing| (FUNCTION |npLocalItem|))
    (|npPush| (|pfAppend| (|pfParts| (|npPop1|))))))))

;npFree()== npEqKey "FREE" and (npLocalItemlist() or npTrap())
;     and npPush pfFree npPop1()
(DEFUN |npFree| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE FREE))
    (OR (|npLocalItemlist|) (|npTrap|))
    (|npPush| (|pfFree| (|npPop1|)))))))

;npLocal()== npEqKey "local" and (npLocalItemlist() or npTrap())
;     and npPush pfLocal npPop1()
(DEFUN |npLocal| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE |local|))
    (OR (|npLocalItemlist|) (|npTrap|))
    (|npPush| (|pfLocal| (|npPop1|)))))))

;npExport()== npEqKey "EXPORT" and (npLocalItemlist() or npTrap())
;     and npPush pfExport npPop1()
(DEFUN |npExport| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE EXPORT))
    (OR (|npLocalItemlist|) (|npTrap|))
    (|npPush| (|pfExport| (|npPop1|)))))))

;npSignatureDefinee()==
;   npName() or npInfixOperator() or npPrefixColon()
(DEFUN |npSignatureDefinee| ()
 (PROG NIL
  (RETURN
   (OR (|npName|) (|npInfixOperator|) (|npPrefixColon|)))))

;npDecl()== npEqKey "COLON" and (npType() or npTrap()) and
;           npPush pfTyped (npPop2(),npPop1())
(DEFUN |npDecl| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE COLON))
    (OR (|npType|) (|npTrap|))
    (|npPush| (|pfTyped| (|npPop2|) (|npPop1|)))))))

;npQualified(f)==
;    if FUNCALL f
;    then
;     while npEqKey "WHERE" and (npDefinition() or npTrap()) repeat
;             npPush pfWhere(npPop1(),npPop1())
;     true
;    else  npLetQualified  f
(DEFUN |npQualified| (|f|)
 (PROG NIL
  (RETURN
   (COND
    ((FUNCALL |f|)
     ((LAMBDA NIL
      (LOOP
       (COND
        ((NOT (AND (|npEqKey| (QUOTE WHERE)) (OR (|npDefinition|) (|npTrap|))))
         (RETURN NIL))
        ((QUOTE T)
         (|npPush| (|pfWhere| (|npPop1|) (|npPop1|)))))))) T)
    ((QUOTE T) (|npLetQualified| |f|))))))

;npQualifiedDefinition()==
;       npQualified function npDefinitionOrStatement
(DEFUN |npQualifiedDefinition| ()
 (PROG NIL
  (RETURN
   (|npQualified| (FUNCTION |npDefinitionOrStatement|)))))

;npTuple (p)==
;    npListofFun(p,function npCommaBackSet,function pfTupleListOf)
(DEFUN |npTuple| (|p|)
 (PROG NIL
  (RETURN
   (|npListofFun| |p|
    (FUNCTION |npCommaBackSet|)
    (FUNCTION |pfTupleListOf|)))))

;npComma()==  npTuple function npQualifiedDefinition
(DEFUN |npComma| ()
 (PROG NIL
  (RETURN
   (|npTuple| (FUNCTION |npQualifiedDefinition|)))))

;npQualDef()== npComma() and npPush [npPop1()]
(DEFUN |npQualDef| ()
 (PROG NIL
  (RETURN
   (AND
    (|npComma|)
    (|npPush| (LIST (|npPop1|)))))))

;npPDefinition ()==
;     npParenthesized function npDefinitionlist and
;                 npPush pfEnSequence npPop1()
(DEFUN |npPDefinition| ()
 (PROG NIL
  (RETURN
   (AND
    (|npParenthesized| (FUNCTION |npDefinitionlist|))
    (|npPush| (|pfEnSequence| (|npPop1|)))))))

;npTypeVariable()== npParenthesized function npTypeVariablelist or
;           npSignatureDefinee() and npPush pfListOf [npPop1()]
(DEFUN |npTypeVariable| ()
 (PROG NIL
  (RETURN
   (OR
    (|npParenthesized| (FUNCTION |npTypeVariablelist|))
    (AND (|npSignatureDefinee|) (|npPush| (|pfListOf| (LIST (|npPop1|)))))))))

;npTypeVariablelist()== npListing function npSignatureDefinee
(DEFUN |npTypeVariablelist| ()
 (PROG NIL
  (RETURN
   (|npListing| (FUNCTION |npSignatureDefinee|)))))

;npTyping()==
;      npEqKey "DEFAULT" and  (npDefaultItemlist() or npTrap())
;                and npPush pfTyping npPop1()
(DEFUN |npTyping| ()
 (PROG NIL
  (RETURN
   (AND
    (|npEqKey| (QUOTE DEFAULT))
    (OR (|npDefaultItemlist|) (|npTrap|))
    (|npPush| (|pfTyping| (|npPop1|)))))))

;npDefaultItemlist()== npPC function npSDefaultItem
;                             and npPush pfUnSequence npPop1 ()
(DEFUN |npDefaultItemlist| ()
 (PROG NIL
  (RETURN
   (AND
    (|npPC| (FUNCTION |npSDefaultItem|))
    (|npPush| (|pfUnSequence| (|npPop1|)))))))

;npDefaultDecl()== npEqKey "COLON" and (npType() or npTrap()) and
;           npPush pfSpread (pfParts npPop2(),npPop1())
(DEFUN |npDefaultDecl| ()
 (PROG NIL 
  (RETURN
   (AND
    (|npEqKey| (QUOTE COLON))
    (OR (|npType|) (|npTrap|))
    (|npPush| (|pfSpread| (|pfParts| (|npPop2|)) (|npPop1|)))))))

;npDefaultItem()==npTypeVariable() and (npDefaultDecl() or npTrap())
(DEFUN |npDefaultItem| ()
 (PROG NIL
  (RETURN
   (AND
    (|npTypeVariable|)
    (OR (|npDefaultDecl|) (|npTrap|))))))

;npSDefaultItem()== npListing function npDefaultItem
;        and npPush pfAppend pfParts npPop1()
(DEFUN |npSDefaultItem| ()
 (PROG NIL
  (RETURN
   (AND
    (|npListing| (FUNCTION |npDefaultItem|))
    (|npPush| (|pfAppend| (|pfParts| (|npPop1|))))))))

;npDef()==
;    npMatch() =>
;         [op,arg,rt]:=  pfCheckItOut(npPop1())
;         npDefTail() or npTrap()
;         body:=npPop1()
;         null arg => npPush pfDefinition (op,body)
;         npPush pfDefinition (op,pfPushBody(rt,arg,body))
;    false

;npMdef()==
;    npQuiver() =>
;         [op,arg]:=  pfCheckMacroOut(npPop1())
;         npDefTail() or npTrap()
;         body:=npPop1()
;         null arg => npPush pfMacro (op,body)
;         npPush pfMacro (op,pfPushMacroBody(arg,body))
;    false
(DEFUN |npMdef| ()
 (PROG (|body| |arg| |op| |LETTMP#1|)
  (RETURN
   (COND
    ((|npQuiver|)
     (PROGN
      (SETQ |LETTMP#1| (|pfCheckMacroOut| (|npPop1|)))
      (SETQ |op| (CAR |LETTMP#1|))
      (SETQ |arg| (CADR |LETTMP#1|))
      (OR (|npDefTail|) (|npTrap|))
      (SETQ |body| (|npPop1|))
      (COND
       ((NULL |arg|)
        (|npPush| (|pfMacro| |op| |body|)))
       (#0=(QUOTE T)
        (|npPush| (|pfMacro| |op| (|pfPushMacroBody| |arg| |body|)))))))
    (#0# NIL)))))

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
