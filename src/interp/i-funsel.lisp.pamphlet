\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp i-funsel.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{Functions}
\begin{chunk}{*}

(IN-PACKAGE "BOOT" )

;SETANDFILEQ($constructorExposureList, '(Boolean Integer String))

(SETANDFILEQ |$constructorExposureList| (QUOTE (|Boolean| |Integer| |String|))) 
;sayFunctionSelection(op,args,target,dc,func) ==
;  $abbreviateTypes : local := true
;  startTimingProcess 'debug
;  fsig := formatSignatureArgs args
;  if not LISTP fsig then fsig := LIST fsig
;  if func then func := bright ['"by ",func]
;  sayMSG concat ['%l,:bright '"Function Selection for",op,:func,'%l,
;    '"      Arguments:",:bright fsig]
;  if target then sayMSG concat ['"      Target type:",
;    :bright prefix2String target]
;  if dc then sayMSG concat ['"      From:     ", :bright prefix2String dc]
;  stopTimingProcess 'debug

; NO UNIT TEST
(DEFUN |sayFunctionSelection| (|op| |args| |target| |dc| |func|)
  (PROG (|$abbreviateTypes| |fsig|)
    (DECLARE (SPECIAL |$abbreviateTypes|))
    (RETURN
      (PROGN
        (setq |$abbreviateTypes| t)
        (|startTimingProcess| '|debug|)
        (setq |fsig| (|formatSignatureArgs| |args|))
        (COND ((NULL (LISTP |fsig|)) (setq |fsig| (LIST |fsig|))))
        (COND
          (|func| (setq |func|
                           (|bright|
                               (CONS  "by "
                                     (CONS |func| NIL))))))
        (|sayMSG|
            (|concat|
                (CONS '|%l|
                      (APPEND (|bright|
                                  "Function Selection for")
                              (CONS |op|
                                    (APPEND |func|
                                     (CONS '|%l|
                                      (CONS
                                        "      Arguments:"
                                       (|bright| |fsig|)))))))))
        (COND
          (|target|
              (|sayMSG|
                  (|concat|
                      (CONS  "      Target type:"
                            (|bright| (|prefix2String| |target|)))))))
        (COND
          (|dc| (|sayMSG|
                    (|concat|
                        (CONS  "      From:     "
                              (|bright| (|prefix2String| |dc|)))))))
        (|stopTimingProcess| '|debug|)))))

;sayFunctionSelectionResult(op,args,mmS) ==
;  $abbreviateTypes : local := true
;  startTimingProcess 'debug
;  if mmS then printMms mmS
;  else sayMSG concat ['"   -> no function",:bright op,
;    '"found for arguments",:bright formatSignatureArgs args]
;  stopTimingProcess 'debug

; NO UNIT TEST
(DEFUN |sayFunctionSelectionResult| (|op| |args| |mmS|)
  (PROG (|$abbreviateTypes|)
    (DECLARE (SPECIAL |$abbreviateTypes|))
    (RETURN
      (PROGN
        (setq |$abbreviateTypes| t)
        (|startTimingProcess| '|debug|)
        (COND
          (|mmS| (|printMms| |mmS|))
          (t
           (|sayMSG|
               (|concat|
                   (CONS  "   -> no function"
                         (APPEND (|bright| |op|)
                                 (CONS 
                                        "found for arguments"
                                       (|bright|
                                        (|formatSignatureArgs| |args|)))))))))
        (|stopTimingProcess| '|debug|)))))

;selectMms(op,args,$declaredMode) ==
;  -- selects applicable modemaps for node op and arguments args
;  -- if there is no local modemap, and it is not a package call, then
;  --   the cached function selectMms1 is called
;  startTimingProcess 'modemaps
;  n:= getUnname op
;  val := getValue op
;  opMode := objMode val
;  -- see if we have a functional parameter
;  ((isSharpVarWithNum(n) and opMode) or (val and opMode)) and
;      opMode is ['Mapping,:ta] =>
;        imp :=
;          val => wrapped2Quote objVal val
;          n
;        [[['local,:ta], imp , NIL]]
;  ((isSharpVarWithNum(n) and opMode) or (val and opMode)) and
;      opMode is ['Variable,f] =>
;         emptyAtree op
;         op.0 := f
;         selectMms(op,args,$declaredMode)
;  isSharpVarWithNum(n) and opMode is ['FunctionCalled,f] =>
;         op.0 := f
;         selectMms(op,args,$declaredMode)
;  types1 := getOpArgTypes(n,args)
;  numArgs := #args
;  MEMBER('(SubDomain (Domain)),types1) => NIL
;  MEMBER('(Domain),types1) => NIL
;  MEMBER($EmptyMode,types1) => NIL
;  tar := getTarget op
;  dc  := getAtree(op,'dollar)
;  null dc and val and objMode(val) = $AnonymousFunction =>
;      tree := mkAtree objValUnwrap getValue op
;      putTarget(tree,['Mapping,tar,:types1])
;      bottomUp tree
;      val := getValue tree
;      [[['local,:rest objMode val], wrapped2Quote objVal val, NIL]]
;  if (n = 'map) and (first types1 = $AnonymousFunction)
;    then
;      tree := mkAtree objValUnwrap getValue first args
;      ut :=
;        tar => underDomainOf tar
;        NIL
;      ua := [underDomainOf x for x in rest types1]
;      member(NIL,ua) => NIL
;      putTarget(tree,['Mapping,ut,:ua])
;      bottomUp tree
;      val := getValue tree
;      types1 := [objMode val,:rest types1]
;      RPLACA(args,tree)
;  if numArgs = 1 and (n = "numer" or n = "denom") and
;    isEqualOrSubDomain(first types1,$Integer) and null dc then
;      dc := ['Fraction, $Integer]
;      putAtree(op, 'dollar, dc)
;  if $reportBottomUpFlag then sayFunctionSelection(n,types1,tar,dc,NIL)
;  identType := 'Variable
;  for x in types1 while not $declaredMode repeat
;      not EQCAR(x,identType) => $declaredMode:= x
;  types2 := [altTypeOf(x,y,$declaredMode) for x in types1 for y in args]
;  mmS:=
;    dc => selectDollarMms(dc,n,types1,types2)
;    if n = "/" and tar = $Integer then
;      tar := $RationalNumber
;      putTarget(op,tar)
;    -- now to speed up some standard selections
;    if not tar then
;      tar := defaultTarget(op,n,#types1,types1)
;      if tar and $reportBottomUpFlag then
;        sayMSG concat ['"      Default target type:",
;          :bright prefix2String tar]
;    selectLocalMms(op,n,types1,tar) or
;      (VECTORP op and selectMms1(n,tar,types1,types2,t))
;  if $reportBottomUpFlag then sayFunctionSelectionResult(n,types1,mmS)
;  stopTimingProcess 'modemaps
;  mmS

(DEFUN |selectMms| (|op| |args| |$declaredMode|)
  (DECLARE (SPECIAL |$declaredMode|))
  (PROG (|n| |opMode| |ta| |imp| |ISTMP#1| |f| |numArgs| |tree| |ut|
             |ua| |val| |types1| |dc| |identType| |types2| |tar| |mmS|)
   (declare (special |$AnonymousFunction| |$reportBottomUpFlag| |$EmptyMode|
                     |$RationalNumber| |$Integer| |$declaredMode|))
    (RETURN
      (SEQ (PROGN
             (|startTimingProcess| '|modemaps|)
             (setq |n| (|getUnname| |op|))
             (setq |val| (|getValue| |op|))
             (setq |opMode| (|objMode| |val|))
             (COND
               ((AND (OR (AND (|isSharpVarWithNum| |n|) |opMode|)
                         (AND |val| |opMode|))
                     (CONSP |opMode|) (EQ (QCAR |opMode|) '|Mapping|)
                     (PROGN (setq |ta| (QCDR |opMode|)) t))
                (setq |imp|
                         (COND
                           (|val| (|wrapped2Quote| (|objVal| |val|)))
                           (t |n|)))
                (CONS (CONS (CONS '|local| |ta|)
                            (CONS |imp| (CONS NIL NIL)))
                      NIL))
               ((AND (OR (AND (|isSharpVarWithNum| |n|) |opMode|)
                         (AND |val| |opMode|))
                     (CONSP |opMode|) (EQ (QCAR |opMode|) '|Variable|)
                     (PROGN
                       (setq |ISTMP#1| (QCDR |opMode|))
                       (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN (setq |f| (QCAR |ISTMP#1|)) t))))
                (|emptyAtree| |op|) (SETELT |op| 0 |f|)
                (|selectMms| |op| |args| |$declaredMode|))
               ((AND (|isSharpVarWithNum| |n|) (CONSP |opMode|)
                     (EQ (QCAR |opMode|) '|FunctionCalled|)
                     (PROGN
                       (setq |ISTMP#1| (QCDR |opMode|))
                       (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                            (PROGN (setq |f| (QCAR |ISTMP#1|)) t))))
                (SETELT |op| 0 |f|)
                (|selectMms| |op| |args| |$declaredMode|))
               (t (setq |types1| (|getOpArgTypes| |n| |args|))
                (setq |numArgs| (|#| |args|))
                (COND
                  ((|member| '(|SubDomain| (|Domain|)) |types1|) NIL)
                  ((|member| '(|Domain|) |types1|) NIL)
                  ((|member| |$EmptyMode| |types1|) NIL)
                  (t (setq |tar| (|getTarget| |op|))
                   (setq |dc| (|getAtree| |op| '|dollar|))
                   (COND
                     ((AND (NULL |dc|) |val|
                           (BOOT-EQUAL (|objMode| |val|)
                               |$AnonymousFunction|))
                      (setq |tree|
                               (|mkAtree|
                                   (|objValUnwrap| (|getValue| |op|))))
                      (|putTarget| |tree|
                          (CONS '|Mapping| (CONS |tar| |types1|)))
                      (|bottomUp| |tree|)
                      (setq |val| (|getValue| |tree|))
                      (CONS (CONS (CONS '|local|
                                        (CDR (|objMode| |val|)))
                                  (CONS (|wrapped2Quote|
                                         (|objVal| |val|))
                                        (CONS NIL NIL)))
                            NIL))
                     (t
                      (COND
                        ((AND (BOOT-EQUAL |n| '|map|)
                              (BOOT-EQUAL (CAR |types1|)
                                  |$AnonymousFunction|))
                         (setq |tree|
                                  (|mkAtree|
                                      (|objValUnwrap|
                                       (|getValue| (CAR |args|)))))
                         (setq |ut|
                                  (COND
                                    (|tar| (|underDomainOf| |tar|))
                                    (t NIL)))
                         (setq |ua|
                                  (PROG (G166098)
                                    (setq G166098 NIL)
                                    (RETURN
                                      (DO
                                       ((G166103 (CDR |types1|)
                                         (CDR G166103))
                                        (|x| NIL))
                                       ((OR (ATOM G166103)
                                         (PROGN
                                           (SETQ |x| (CAR G166103))
                                           NIL))
                                        (NREVERSE0 G166098))
                                        (SEQ
                                         (EXIT
                                          (SETQ G166098
                                           (CONS (|underDomainOf| |x|)
                                            G166098))))))))
                         (COND
                           ((|member| NIL |ua|) NIL)
                           (t
                            (|putTarget| |tree|
                                (CONS '|Mapping| (CONS |ut| |ua|)))
                            (|bottomUp| |tree|)
                            (setq |val| (|getValue| |tree|))
                            (setq |types1|
                                     (CONS (|objMode| |val|)
                                      (CDR |types1|)))
                            (RPLACA |args| |tree|)))))
                      (COND
                        ((AND (EQL |numArgs| 1)
                              (OR (BOOT-EQUAL |n| '|numer|)
                                  (BOOT-EQUAL |n| '|denom|))
                              (|isEqualOrSubDomain| (CAR |types1|)
                                  |$Integer|)
                              (NULL |dc|))
                         (setq |dc|
                                  (CONS '|Fraction|
                                        (CONS |$Integer| NIL)))
                         (|putAtree| |op| '|dollar| |dc|)))
                      (COND
                        (|$reportBottomUpFlag|
                            (|sayFunctionSelection| |n| |types1| |tar|
                                |dc| NIL)))
                      (setq |identType| '|Variable|)
                      (SEQ (DO ((G166113 |types1| (CDR G166113))
                                (|x| NIL))
                               ((OR (ATOM G166113)
                                    (PROGN
                                      (SETQ |x| (CAR G166113))
                                      NIL)
                                    (NULL (NULL |$declaredMode|)))
                                NIL)
                             (SEQ (EXIT (COND
                                          ((NULL
                                            (EQCAR |x| |identType|))
                                           (EXIT
                                            (setq |$declaredMode|
                                             |x|)))))))
                           (setq |types2|
                                    (PROG (G166125)
                                      (setq G166125 NIL)
                                      (RETURN
                                        (DO
                                         ((G166131 |types1|
                                           (CDR G166131))
                                          (|x| NIL)
                                          (G166132 |args|
                                           (CDR G166132))
                                          (|y| NIL))
                                         ((OR (ATOM G166131)
                                           (PROGN
                                             (SETQ |x| (CAR G166131))
                                             NIL)
                                           (ATOM G166132)
                                           (PROGN
                                             (SETQ |y| (CAR G166132))
                                             NIL))
                                          (NREVERSE0 G166125))
                                          (SEQ
                                           (EXIT
                                            (SETQ G166125
                                             (CONS
                                              (|altTypeOf| |x| |y|
                                               |$declaredMode|)
                                              G166125))))))))
                           (setq |mmS|
                                    (COND
                                      (|dc|
                                       (|selectDollarMms| |dc| |n|
                                        |types1| |types2|))
                                      (t
                                       (COND
                                         ((AND (BOOT-EQUAL |n| '/)
                                           (BOOT-EQUAL |tar|
                                            |$Integer|))
                                          (setq |tar|
                                           |$RationalNumber|)
                                          (|putTarget| |op| |tar|)))
                                       (COND
                                         ((NULL |tar|)
                                          (setq |tar|
                                           (|defaultTarget| |op| |n|
                                            (|#| |types1|) |types1|))
                                          (COND
                                            ((AND |tar|
                                              |$reportBottomUpFlag|)
                                             (|sayMSG|
                                              (|concat|
                                               (CONS
                                                 "      Default target type:"
                                                (|bright|
                                                 (|prefix2String|
                                                  |tar|))))))
                                            (t NIL))))
                                       (OR
                                        (|selectLocalMms| |op| |n|
                                         |types1| |tar|)
                                        (AND (VECTORP |op|)
                                         (|selectMms1| |n| |tar|
                                          |types1| |types2| t))))))
                           (COND
                             (|$reportBottomUpFlag|
                                 (|sayFunctionSelectionResult| |n|
                                     |types1| |mmS|)))
                           (|stopTimingProcess| '|modemaps|)
                           (EXIT |mmS|)))))))))))))

;-- selectMms1 is in clammed.boot
;selectMms2(op,tar,args1,args2,$Coerce) ==
;  -- decides whether to find functions from a domain or package
;  --   or by general modemap evaluation
;  or/[STRINGP arg for arg in args1] => NIL
;  if tar = $EmptyMode then tar := NIL
;  nargs := #args1
;  mmS := NIL
;  mmS :=
;    -- special case map for the time being
;    $Coerce and (op = 'map) and (2 = nargs) and
;      (first(args1) is ['Variable,fun]) =>
;        null (ud := underDomainOf CADR args1) => NIL
;        if tar then ut := underDomainOf(tar)
;        else ut := nil
;        null (mapMms := selectMms1(fun,ut,[ud],[NIL],true)) => NIL
;        mapMm := CDAAR mapMms
;        selectMms1(op,tar,[['Mapping,:mapMm],CADR args1],
;          [NIL,CADR args2],$Coerce)
;    $Coerce and (op = 'map) and (2 = nargs) and
;      (first(args1) is ['FunctionCalled,fun]) =>
;        null (ud := underDomainOf CADR args1) => NIL
;        if tar then ut := underDomainOf(tar)
;        else ut := nil
;        funNode := mkAtreeNode fun
;        transferPropsToNode(fun,funNode)
;        null (mapMms := selectLocalMms(funNode,fun,[ud],NIL)) => NIL
;        mapMm := CDAAR mapMms
;        selectMms1(op,tar,[['Mapping,:mapMm],CADR args1],
;          [NIL,CADR args2],$Coerce)
;    -- get the argument domains and the target
;    a := nil
;    for x in args1 repeat if x then a := cons(x,a)
;    for x in args2 repeat if x then a := cons(x,a)
;    if tar and not isPartialMode tar then a := cons(tar,a)
;    -- for typically homogeneous functions, throw in resolve too
;    if op in '(_= _+ _* _- ) then
;      r := resolveTypeList a
;      if r ^= nil then a := cons(r,a)
;    if tar and not isPartialMode tar then
;      if xx := underDomainOf(tar) then a := cons(xx,a)
;    for x in args1 repeat
;      CONSP(x) and CAR(x) in '(List Vector Stream FiniteSet Array) =>
;        xx := underDomainOf(x) => a := cons(xx,a)
;    -- now extend this list with those from the arguments to
;    -- any Unions, Mapping or Records
;    a' := nil
;    a := nreverse REMDUP a
;    for x in a repeat
;      null x => 'iterate
;      x = '(RationalRadicals) => a' := cons($RationalNumber,a')
;      x is ['Union,:l] =>
;        -- check if we have a tagged union
;        l and first l is [":",:.] =>
;          for [.,.,t] in l repeat
;            a' := cons(t,a')
;        a' := append(reverse l,a')
;      x is ['Mapping,:l] => a' := append(reverse l,a')
;      x is ['Record,:l] =>
;        a' := append(reverse [CADDR s for s in l],a')
;      x is ['FunctionCalled,name] =>
;        (xm := get(name,'mode,$e)) and not isPartialMode xm =>
;          a' := cons(xm,a')
;    a := append(a,REMDUP a')
;    a := [x for x in a | CONSP(x)]
;    -- step 1. see if we have one without coercing
;    a' := a
;    while a repeat
;      x:= CAR a
;      a:= CDR a
;      ATOM x => 'iterate
;      mmS := append(mmS, findFunctionInDomain(op,x,tar,args1,args2,NIL,NIL))
;    -- step 2. if we didn't get one, trying coercing (if we are
;    --         suppose to)
;    if null(mmS) and $Coerce then
;      a := a'
;      while a repeat
;        x:= CAR a
;        a:= CDR a
;        ATOM x => 'iterate
;        mmS := append(mmS,
;          findFunctionInDomain(op,x,tar,args1,args2,$Coerce,NIL))
;    mmS or selectMmsGen(op,tar,args1,args2)
;  mmS and orderMms(op, mmS,args1,args2,tar)

(DEFUN |selectMms2| (|op| |tar| |args1| |args2| |$Coerce|)
  (DECLARE (SPECIAL |$Coerce|))
  (PROG (|nargs| |ISTMP#2| |fun| |ud| |ut| |funNode| |mapMms| |mapMm|
                 |r| |xx| |t| |l| |ISTMP#1| |name| |xm| |a'| |x| |a|
                 |mmS|)
  (declare (special |$e| |$RationalNumber| |$EmptyMode|))
    (RETURN
      (SEQ (COND
             ((PROG (G166213)
                (setq G166213 NIL)
                (RETURN
                  (DO ((G166219 NIL G166213)
                       (G166220 |args1| (CDR G166220)) (|arg| NIL))
                      ((OR G166219 (ATOM G166220)
                           (PROGN (SETQ |arg| (CAR G166220)) NIL))
                       G166213)
                    (SEQ (EXIT (SETQ G166213
                                     (OR G166213 (STRINGP |arg|))))))))
              NIL)
             (t
              (COND
                ((BOOT-EQUAL |tar| |$EmptyMode|) (setq |tar| NIL)))
              (setq |nargs| (|#| |args1|)) (setq |mmS| NIL)
              (setq |mmS|
                       (COND
                         ((AND |$Coerce| (BOOT-EQUAL |op| '|map|)
                               (EQL 2 |nargs|)
                               (PROGN
                                 (setq |ISTMP#1| (CAR |args1|))
                                 (AND (CONSP |ISTMP#1|)
                                      (EQ (QCAR |ISTMP#1|) '|Variable|)
                                      (PROGN
                                        (setq |ISTMP#2|
                                         (QCDR |ISTMP#1|))
                                        (AND (CONSP |ISTMP#2|)
                                         (EQ (QCDR |ISTMP#2|) NIL)
                                         (PROGN
                                           (setq |fun|
                                            (QCAR |ISTMP#2|))
                                           t))))))
                          (COND
                            ((NULL (setq |ud|
                                    (|underDomainOf| (CADR |args1|))))
                             NIL)
                            (t
                             (COND
                               (|tar| (setq |ut|
                                       (|underDomainOf| |tar|)))
                               (t (setq |ut| NIL)))
                             (COND
                               ((NULL (setq |mapMms|
                                       (|selectMms1| |fun| |ut|
                                        (CONS |ud| NIL) (CONS NIL NIL)
                                        t)))
                                NIL)
                               (t (setq |mapMm| (CDAAR |mapMms|))
                                (|selectMms1| |op| |tar|
                                    (CONS (CONS '|Mapping| |mapMm|)
                                     (CONS (CADR |args1|) NIL))
                                    (CONS NIL
                                     (CONS (CADR |args2|) NIL))
                                    |$Coerce|))))))
                         ((AND |$Coerce| (BOOT-EQUAL |op| '|map|)
                               (EQL 2 |nargs|)
                               (PROGN
                                 (setq |ISTMP#1| (CAR |args1|))
                                 (AND (CONSP |ISTMP#1|)
                                      (EQ (QCAR |ISTMP#1|)
                                       '|FunctionCalled|)
                                      (PROGN
                                        (setq |ISTMP#2|
                                         (QCDR |ISTMP#1|))
                                        (AND (CONSP |ISTMP#2|)
                                         (EQ (QCDR |ISTMP#2|) NIL)
                                         (PROGN
                                           (setq |fun|
                                            (QCAR |ISTMP#2|))
                                           t))))))
                          (COND
                            ((NULL (setq |ud|
                                    (|underDomainOf| (CADR |args1|))))
                             NIL)
                            (t
                             (COND
                               (|tar| (setq |ut|
                                       (|underDomainOf| |tar|)))
                               (t (setq |ut| NIL)))
                             (setq |funNode| (|mkAtreeNode| |fun|))
                             (|transferPropsToNode| |fun| |funNode|)
                             (COND
                               ((NULL (setq |mapMms|
                                       (|selectLocalMms| |funNode|
                                        |fun| (CONS |ud| NIL) NIL)))
                                NIL)
                               (t (setq |mapMm| (CDAAR |mapMms|))
                                (|selectMms1| |op| |tar|
                                    (CONS (CONS '|Mapping| |mapMm|)
                                     (CONS (CADR |args1|) NIL))
                                    (CONS NIL
                                     (CONS (CADR |args2|) NIL))
                                    |$Coerce|))))))
                         (t (setq |a| NIL)
                          (DO ((G166230 |args1| (CDR G166230))
                               (|x| NIL))
                              ((OR (ATOM G166230)
                                   (PROGN
                                     (SETQ |x| (CAR G166230))
                                     NIL))
                               NIL)
                            (SEQ (EXIT (COND
                                         (|x|
                                          (setq |a| (CONS |x| |a|)))
                                         (t NIL)))))
                          (DO ((G166239 |args2| (CDR G166239))
                               (|x| NIL))
                              ((OR (ATOM G166239)
                                   (PROGN
                                     (SETQ |x| (CAR G166239))
                                     NIL))
                               NIL)
                            (SEQ (EXIT (COND
                                         (|x|
                                          (setq |a| (CONS |x| |a|)))
                                         (t NIL)))))
                          (COND
                            ((AND |tar| (NULL (|isPartialMode| |tar|)))
                             (setq |a| (CONS |tar| |a|))))
                          (COND
                            ((|member| |op| '(= + * -))
                             (setq |r| (|resolveTypeList| |a|))
                             (COND
                               ((NEQUAL |r| NIL)
                                (setq |a| (CONS |r| |a|)))
                               (t NIL))))
                          (COND
                            ((AND |tar| (NULL (|isPartialMode| |tar|)))
                             (COND
                               ((setq |xx| (|underDomainOf| |tar|))
                                (setq |a| (CONS |xx| |a|)))
                               (t NIL))))
                          (SEQ (DO ((G166248 |args1| (CDR G166248))
                                    (|x| NIL))
                                   ((OR (ATOM G166248)
                                     (PROGN
                                       (SETQ |x| (CAR G166248))
                                       NIL))
                                    NIL)
                                 (SEQ (EXIT
                                       (COND
                                         ((AND (CONSP |x|)
                                           (|member| (CAR |x|)
                                            '(|List| |Vector| |Stream|
                                              |FiniteSet| |Array|)))
                                          (EXIT
                                           (COND
                                             ((setq |xx|
                                               (|underDomainOf| |x|))
                                              (EXIT
                                               (setq |a|
                                                (CONS |xx| |a|)))))))))))
                               (setq |a'| NIL)
                               (setq |a| (NREVERSE (REMDUP |a|)))
                               (DO ((G166271 |a| (CDR G166271))
                                    (|x| NIL))
                                   ((OR (ATOM G166271)
                                     (PROGN
                                       (SETQ |x| (CAR G166271))
                                       NIL))
                                    NIL)
                                 (SEQ (COND
                                        ((NULL |x|) '|iterate|)
                                        ((BOOT-EQUAL |x|
                                          '(|RationalRadicals|))
                                         (setq |a'|
                                          (CONS |$RationalNumber| |a'|)))
                                        ((AND (CONSP |x|)
                                          (EQ (QCAR |x|) '|Union|)
                                          (PROGN
                                            (setq |l| (QCDR |x|))
                                            t))
                                         (COND
                                           ((AND |l|
                                             (PROGN
                                               (setq |ISTMP#1|
                                                (CAR |l|))
                                               (AND (CONSP |ISTMP#1|)
                                                (EQ (QCAR |ISTMP#1|)
                                                 '|:|))))
                                            (DO
                                             ((G166281 |l|
                                               (CDR G166281))
                                              (G166199 NIL))
                                             ((OR (ATOM G166281)
                                               (PROGN
                                                 (SETQ G166199
                                                  (CAR G166281))
                                                 NIL)
                                               (PROGN
                                                 (PROGN
                                                   (setq |t|
                                                    (CADDR G166199))
                                                   G166199)
                                                 NIL))
                                              NIL)
                                              (SEQ
                                               (EXIT
                                                (setq |a'|
                                                 (CONS |t| |a'|))))))
                                           (t
                                            (setq |a'|
                                             (APPEND (REVERSE |l|)
                                              |a'|)))))
                                        ((AND (CONSP |x|)
                                          (EQ (QCAR |x|) '|Mapping|)
                                          (PROGN
                                            (setq |l| (QCDR |x|))
                                            t))
                                         (setq |a'|
                                          (APPEND (REVERSE |l|) |a'|)))
                                        ((AND (CONSP |x|)
                                          (EQ (QCAR |x|) '|Record|)
                                          (PROGN
                                            (setq |l| (QCDR |x|))
                                            t))
                                         (setq |a'|
                                          (APPEND
                                           (REVERSE
                                            (PROG (G166292)
                                              (setq G166292 NIL)
                                              (RETURN
                                                (DO
                                                 ((G166297 |l|
                                                   (CDR G166297))
                                                  (|s| NIL))
                                                 ((OR (ATOM G166297)
                                                   (PROGN
                                                     (SETQ |s|
                                                      (CAR G166297))
                                                     NIL))
                                                  (NREVERSE0 G166292))
                                                  (SEQ
                                                   (EXIT
                                                    (SETQ G166292
                                                     (CONS (CADDR |s|)
                                                      G166292))))))))
                                           |a'|)))
                                        ((AND (CONSP |x|)
                                          (EQ (QCAR |x|)
                                           '|FunctionCalled|)
                                          (PROGN
                                            (setq |ISTMP#1|
                                             (QCDR |x|))
                                            (AND (CONSP |ISTMP#1|)
                                             (EQ (QCDR |ISTMP#1|) NIL)
                                             (PROGN
                                               (setq |name|
                                                (QCAR |ISTMP#1|))
                                               t))))
                                         (COND
                                           ((AND
                                             (setq |xm|
                                              (|get| |name| '|mode|
                                               |$e|))
                                             (NULL
                                              (|isPartialMode| |xm|)))
                                            (EXIT
                                             (setq |a'|
                                              (CONS |xm| |a'|)))))))))
                               (setq |a| (APPEND |a| (REMDUP |a'|)))
                               (setq |a|
                                        (PROG (G166308)
                                          (setq G166308 NIL)
                                          (RETURN
                                            (DO
                                             ((G166314 |a|
                                               (CDR G166314))
                                              (|x| NIL))
                                             ((OR (ATOM G166314)
                                               (PROGN
                                                 (SETQ |x|
                                                  (CAR G166314))
                                                 NIL))
                                              (NREVERSE0 G166308))
                                              (SEQ
                                               (EXIT
                                                (COND
                                                  ((CONSP |x|)
                                                   (SETQ G166308
                                                    (CONS |x|
                                                     G166308))))))))))
                               (setq |a'| |a|)
                               (DO () ((NULL |a|) NIL)
                                 (SEQ (EXIT
                                       (PROGN
                                         (setq |x| (CAR |a|))
                                         (setq |a| (CDR |a|))
                                         (COND
                                           ((ATOM |x|) '|iterate|)
                                           (t
                                            (setq |mmS|
                                             (APPEND |mmS|
                                              (|findFunctionInDomain|
                                               |op| |x| |tar| |args1|
                                               |args2| NIL NIL)))))))))
                               (COND
                                 ((AND (NULL |mmS|) |$Coerce|)
                                  (setq |a| |a'|)
                                  (DO () ((NULL |a|) NIL)
                                    (SEQ
                                     (EXIT
                                      (PROGN
                                        (setq |x| (CAR |a|))
                                        (setq |a| (CDR |a|))
                                        (COND
                                          ((ATOM |x|) '|iterate|)
                                          (t
                                           (setq |mmS|
                                            (APPEND |mmS|
                                             (|findFunctionInDomain|
                                              |op| |x| |tar| |args1|
                                              |args2| |$Coerce| NIL)))))))))))
                               (OR |mmS|
                                   (|selectMmsGen| |op| |tar| |args1|
                                    |args2|))))))
              (AND |mmS| (|orderMms| |op| |mmS| |args1| |args2| |tar|))))))))

;isAVariableType t ==
;    t is ['Variable,.] or t = $Symbol or t is ['OrderedVariableList,.]

(defun |isAVariableType| (arg)
 (let (tmp1)
 (declare (special |$Symbol|))
  (or 
   (and (consp arg)
        (eq (qcar arg) '|Variable|)
        (progn
         (setq tmp1 (qcdr arg))
         (and (consp tmp1) (eq (qcdr tmp1) nil))))
   (boot-equal arg |$Symbol|)
   (and (consp arg)
        (eq (qcar arg) '|OrderedVariableList|)
        (progn
          (setq tmp1 (qcdr arg))
          (and (consp tmp1) (eq (qcdr tmp1) nil)))))))

;defaultTarget(opNode,op,nargs,args) ==
;  -- this is for efficiency. Chooses standard targets for operations
;  -- when no target exists.
;  target := nil
;  nargs = 0 =>
;    op = 'nil =>
;      putTarget(opNode, target := '(List (None)))
;      target
;    op = 'true  or op = 'false =>
;      putTarget(opNode, target := $Boolean)
;      target
;    op = 'pi =>
;      putTarget(opNode, target := ['Pi])
;      target
;    op = 'infinity =>
;      putTarget(opNode, target := ['OnePointCompletion, $Integer])
;      target
;    member(op, '(plusInfinity minusInfinity)) =>
;      putTarget(opNode, target := ['OrderedCompletion, $Integer])
;      target
;    target
;  a1 := CAR args
;  ATOM a1 => target
;  a1f := QCAR a1
;  nargs = 1 =>
;    op = 'kernel =>
;      putTarget(opNode, target := ['Kernel, ['Expression, $Integer]])
;      target
;    op = 'list =>
;      putTarget(opNode, target := ['List, a1])
;      target
;    target
;  a2 := CADR args
;  nargs >= 2 and op = "draw" and a1 is ['FunctionCalled,sym] and a2 is ['Segment,.] =>
;    -- this clears up some confusion over 2D and 3D graphics
;    symNode := mkAtreeNode sym
;    transferPropsToNode(sym,symNode)
;    nargs >= 3 and CADDR args is ['Segment,.] =>
;      selectLocalMms(symNode,sym,[$DoubleFloat, $DoubleFloat],NIL)
;      putTarget(opNode, target := '(ThreeDimensionalViewport))
;      target
;    (mms := selectLocalMms(symNode,sym,[$DoubleFloat],NIL)) =>
;      [.,targ,:.] := CAAR mms
;      targ = $DoubleFloat =>
;          putTarget(opNode, target := '(TwoDimensionalViewport))
;          target
;      targ = ['Point, $DoubleFloat] =>
;          putTarget(opNode, target := '(ThreeDimensionalViewport))
;          target
;      target
;    target
;  nargs >= 2 and op = "makeObject" and a1 is ['FunctionCalled,sym] and a2 is ['Segment,.] =>
;    -- we won't actually bother to put a target on makeObject
;    -- this is just to figure out what the first arg is
;    symNode := mkAtreeNode sym
;    transferPropsToNode(sym,symNode)
;    nargs >= 3 and CADDR args is ['Segment,.] =>
;      selectLocalMms(symNode,sym,[$DoubleFloat, $DoubleFloat],NIL)
;      target
;    selectLocalMms(symNode,sym,[$DoubleFloat],NIL)
;    target
;  nargs = 2 =>
;    op = "elt" =>
;        a1 = '(BasicOperator) and a2 is ['List, ['OrderedVariableList, .]] =>
;           ['Expression, $Integer]
;        target
;    op = "eval" =>
;        a1 is ['Expression,b1] and a2 is ['Equation, ['Polynomial,b2]] =>
;            target :=
;              canCoerce(b2, a1) => a1
;              t := resolveTT(b1, b2)
;              (not t) or (t = $Any) => nil
;              resolveTT(a1, t)
;            if target then putTarget(opNode, target)
;            target
;        a1 is ['Equation, .] and a2 is ['Equation, .] =>
;            target := resolveTT(a1, a2)
;            if target and not (target = $Any) then putTarget(opNode,target)
;            else target := nil
;            target
;        a1 is ['Equation, .] and a2 is ['List, a2e] and a2e is ['Equation, .] =>
;            target := resolveTT(a1, a2e)
;            if target and not (target = $Any) then putTarget(opNode,target)
;            else target := nil
;            target
;        a2 is ['Equation, a2e] or a2 is ['List, ['Equation, a2e]] =>
;            target := resolveTT(a1, a2e)
;            if target and not (target = $Any) then putTarget(opNode,target)
;            else target := nil
;            target
;    op = "**" or op = "^" =>
;      a2 = $Integer =>
;        if (target := resolveTCat(a1,'(Field))) then
;          putTarget(opNode,target)
;        target
;      a1 = '(AlgebraicNumber) and (a2 = $Float or a2 = $DoubleFloat) =>
;          target := ['Expression, a2]
;          putTarget(opNode,target)
;          target
;      a1 = '(AlgebraicNumber) and a2 is ['Complex, a3] and (a3 = $Float or a3 = $DoubleFloat) =>
;          target := ['Expression, a3]
;          putTarget(opNode,target)
;          target
;      ((a2 = $RationalNumber) and
;        (typeIsASmallInteger(a1) or isEqualOrSubDomain(a1,$Integer))) =>
;            putTarget(opNode, target := '(AlgebraicNumber))
;            target
;      ((a2 = $RationalNumber) and (isAVariableType(a1)
;          or a1 is ['Polynomial,.] or a1 is ['RationalFunction,.])) =>
;            putTarget(opNode, target := defaultTargetFE a1)
;            target
;      isAVariableType(a1) and (a2 = $PositiveInteger or a2 = $NonNegativeInteger) =>
;          putTarget(opNode, target := '(Polynomial (Integer)))
;          target
;      isAVariableType(a2) =>
;        putTarget(opNode, target := defaultTargetFE a1)
;        target
;      a2 is ['Polynomial, D] =>
;        (a1 = a2) or isAVariableType(a1)
;         or ((a1 is ['RationalFunction, D1]) and (D1 = D)) or (a1 = D)
;          or ((a1 is [=$QuotientField, D1]) and (D1 = a1)) =>
;            putTarget(opNode, target := defaultTargetFE a2)
;            target
;        target
;      a2 is ['RationalFunction, D] =>
;        (a1 = a2) or isAVariableType(a1)
;         or ((a1 is ['RationalFunction, D1]) and (D1 = D)) or (a1 = D)
;          or ((a1 is [=$QuotientField, D1]) and (D1 = a1)) =>
;            putTarget(opNode, target := defaultTargetFE a2)
;            target
;        target
;      target
;    op = '_/ =>
;      isEqualOrSubDomain(a1, $Integer) and isEqualOrSubDomain(a2, $Integer) =>
;        putTarget(opNode, target := $RationalNumber)
;        target
;      a1 = a2 =>
;        if (target := resolveTCat(CAR args,'(Field))) then
;          putTarget(opNode,target)
;        target
;      a1 is ['Variable,.] and a2 is ['Variable,.] =>
;        putTarget(opNode,target := mkRationalFunction  '(Integer))
;        target
;      isEqualOrSubDomain(a1,$Integer) and a2 is ['Variable,.] =>
;        putTarget(opNode,target := mkRationalFunction '(Integer))
;        target
;      a1 is ['Variable,.] and
;        a2 is ['Polynomial,D] =>
;          putTarget(opNode,target := mkRationalFunction D)
;          target
;        target
;      a2 is ['Variable,.] and
;        a1 is ['Polynomial,D] =>
;          putTarget(opNode,target := mkRationalFunction D)
;          target
;        target
;      a2 is ['Polynomial,D] and (a1 = D) =>
;        putTarget(opNode,target := mkRationalFunction D)
;        target
;      target
;  a3 := CADDR args
;  nargs = 3 =>
;    op = "eval" =>
;        a3 is ['List, a3e] =>
;            target := resolveTT(a1, a3e)
;            if not (target = $Any) then putTarget(opNode,target)
;            else target := nil
;            target
;        target := resolveTT(a1, a3)
;        if not (target = $Any) then putTarget(opNode,target)
;        else target := nil
;        target
;  target

(DEFUN |defaultTarget| (|opNode| |op| |nargs| |args|)
  (PROG (|a1| |a1f| |a2| |mms| |LETTMP#1| |targ| |sym| |symNode| |b1|
              |b2| |t| |ISTMP#2| |ISTMP#3| |a2e| D1 D |a3| |ISTMP#1|
              |a3e| |target|)
  (declare (special |$Any| |$Integer| |$RationalNumber| |$QuotientField|
                    |$NonNegativeInteger| |$PositiveInteger| |$DoubleFloat|
                    |$Float| |$Boolean|))
    (RETURN
      (SEQ (PROGN
             (setq |target| NIL)
             (COND
               ((EQL |nargs| 0)
                (COND
                  ((BOOT-EQUAL |op| '|nil|)
                   (|putTarget| |opNode|
                       (setq |target| '(|List| (|None|))))
                   |target|)
                  ((OR (BOOT-EQUAL |op| '|true|)
                       (BOOT-EQUAL |op| '|false|))
                   (|putTarget| |opNode| (setq |target| |$Boolean|))
                   |target|)
                  ((BOOT-EQUAL |op| '|pi|)
                   (|putTarget| |opNode|
                       (setq |target| (CONS '|Pi| NIL)))
                   |target|)
                  ((BOOT-EQUAL |op| '|infinity|)
                   (|putTarget| |opNode|
                       (setq |target|
                                (CONS '|OnePointCompletion|
                                      (CONS |$Integer| NIL))))
                   |target|)
                  ((|member| |op| '(|plusInfinity| |minusInfinity|))
                   (|putTarget| |opNode|
                       (setq |target|
                                (CONS '|OrderedCompletion|
                                      (CONS |$Integer| NIL))))
                   |target|)
                  (t |target|)))
               (t (setq |a1| (CAR |args|))
                (COND
                  ((ATOM |a1|) |target|)
                  (t (setq |a1f| (QCAR |a1|))
                   (COND
                     ((EQL |nargs| 1)
                      (COND
                        ((BOOT-EQUAL |op| '|kernel|)
                         (|putTarget| |opNode|
                             (setq |target|
                                      (CONS '|Kernel|
                                       (CONS
                                        (CONS '|Expression|
                                         (CONS |$Integer| NIL))
                                        NIL))))
                         |target|)
                        ((BOOT-EQUAL |op| '|list|)
                         (|putTarget| |opNode|
                             (setq |target|
                                      (CONS '|List| (CONS |a1| NIL))))
                         |target|)
                        (t |target|)))
                     (t (setq |a2| (CADR |args|))
                      (COND
                        ((AND (>= |nargs| 2) (BOOT-EQUAL |op| '|draw|)
                              (CONSP |a1|)
                              (EQ (QCAR |a1|) '|FunctionCalled|)
                              (PROGN
                                (setq |ISTMP#1| (QCDR |a1|))
                                (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (PROGN
                                       (setq |sym| (QCAR |ISTMP#1|))
                                       t)))
                              (CONSP |a2|) (EQ (QCAR |a2|) '|Segment|)
                              (PROGN
                                (setq |ISTMP#1| (QCDR |a2|))
                                (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL))))
                         (setq |symNode| (|mkAtreeNode| |sym|))
                         (|transferPropsToNode| |sym| |symNode|)
                         (COND
                           ((AND (>= |nargs| 3)
                                 (PROGN
                                   (setq |ISTMP#1| (CADDR |args|))
                                   (AND (CONSP |ISTMP#1|)
                                    (EQ (QCAR |ISTMP#1|) '|Segment|)
                                    (PROGN
                                      (setq |ISTMP#2|
                                       (QCDR |ISTMP#1|))
                                      (AND (CONSP |ISTMP#2|)
                                       (EQ (QCDR |ISTMP#2|) NIL))))))
                            (|selectLocalMms| |symNode| |sym|
                                (CONS |$DoubleFloat|
                                      (CONS |$DoubleFloat| NIL))
                                NIL)
                            (|putTarget| |opNode|
                                (setq |target|
                                         '(|ThreeDimensionalViewport|)))
                            |target|)
                           ((setq |mms|
                                     (|selectLocalMms| |symNode| |sym|
                                      (CONS |$DoubleFloat| NIL) NIL))
                            (setq |LETTMP#1| (CAAR |mms|))
                            (setq |targ| (CADR |LETTMP#1|))
                            (COND
                              ((BOOT-EQUAL |targ| |$DoubleFloat|)
                               (|putTarget| |opNode|
                                   (setq |target|
                                    '(|TwoDimensionalViewport|)))
                               |target|)
                              ((BOOT-EQUAL |targ|
                                   (CONS '|Point|
                                    (CONS |$DoubleFloat| NIL)))
                               (|putTarget| |opNode|
                                   (setq |target|
                                    '(|ThreeDimensionalViewport|)))
                               |target|)
                              (t |target|)))
                           (t |target|)))
                        ((AND (>= |nargs| 2)
                              (BOOT-EQUAL |op| '|makeObject|)
                              (CONSP |a1|)
                              (EQ (QCAR |a1|) '|FunctionCalled|)
                              (PROGN
                                (setq |ISTMP#1| (QCDR |a1|))
                                (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL)
                                     (PROGN
                                       (setq |sym| (QCAR |ISTMP#1|))
                                       t)))
                              (CONSP |a2|) (EQ (QCAR |a2|) '|Segment|)
                              (PROGN
                                (setq |ISTMP#1| (QCDR |a2|))
                                (AND (CONSP |ISTMP#1|)
                                     (EQ (QCDR |ISTMP#1|) NIL))))
                         (setq |symNode| (|mkAtreeNode| |sym|))
                         (|transferPropsToNode| |sym| |symNode|)
                         (COND
                           ((AND (>= |nargs| 3)
                                 (PROGN
                                   (setq |ISTMP#1| (CADDR |args|))
                                   (AND (CONSP |ISTMP#1|)
                                    (EQ (QCAR |ISTMP#1|) '|Segment|)
                                    (PROGN
                                      (setq |ISTMP#2|
                                       (QCDR |ISTMP#1|))
                                      (AND (CONSP |ISTMP#2|)
                                       (EQ (QCDR |ISTMP#2|) NIL))))))
                            (|selectLocalMms| |symNode| |sym|
                                (CONS |$DoubleFloat|
                                      (CONS |$DoubleFloat| NIL))
                                NIL)
                            |target|)
                           (t
                            (|selectLocalMms| |symNode| |sym|
                                (CONS |$DoubleFloat| NIL) NIL)
                            |target|)))
                        ((EQL |nargs| 2)
                         (COND
                           ((BOOT-EQUAL |op| '|elt|)
                            (COND
                              ((AND (BOOT-EQUAL |a1|
                                     '(|BasicOperator|))
                                    (CONSP |a2|)
                                    (EQ (QCAR |a2|) '|List|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a2|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)
                                       (PROGN
                                         (setq |ISTMP#2|
                                          (QCAR |ISTMP#1|))
                                         (AND (CONSP |ISTMP#2|)
                                          (EQ (QCAR |ISTMP#2|)
                                           '|OrderedVariableList|)
                                          (PROGN
                                            (setq |ISTMP#3|
                                             (QCDR |ISTMP#2|))
                                            (AND (CONSP |ISTMP#3|)
                                             (EQ (QCDR |ISTMP#3|) NIL))))))))
                               (CONS '|Expression|
                                     (CONS |$Integer| NIL)))
                              (t |target|)))
                           ((BOOT-EQUAL |op| '|eval|)
                            (COND
                              ((AND (CONSP |a1|)
                                    (EQ (QCAR |a1|) '|Expression|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a1|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)
                                       (PROGN
                                         (setq |b1|
                                          (QCAR |ISTMP#1|))
                                         t)))
                                    (CONSP |a2|)
                                    (EQ (QCAR |a2|) '|Equation|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a2|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)
                                       (PROGN
                                         (setq |ISTMP#2|
                                          (QCAR |ISTMP#1|))
                                         (AND (CONSP |ISTMP#2|)
                                          (EQ (QCAR |ISTMP#2|)
                                           '|Polynomial|)
                                          (PROGN
                                            (setq |ISTMP#3|
                                             (QCDR |ISTMP#2|))
                                            (AND (CONSP |ISTMP#3|)
                                             (EQ (QCDR |ISTMP#3|) NIL)
                                             (PROGN
                                               (setq |b2|
                                                (QCAR |ISTMP#3|))
                                               t))))))))
                               (setq |target|
                                        (COND
                                          ((|canCoerce| |b2| |a1|)
                                           |a1|)
                                          (t
                                           (setq |t|
                                            (|resolveTT| |b1| |b2|))
                                           (COND
                                             ((OR (NULL |t|)
                                               (BOOT-EQUAL |t| |$Any|))
                                              NIL)
                                             (t
                                              (|resolveTT| |a1| |t|))))))
                               (COND
                                 (|target|
                                     (|putTarget| |opNode| |target|)))
                               |target|)
                              ((AND (CONSP |a1|)
                                    (EQ (QCAR |a1|) '|Equation|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a1|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)))
                                    (CONSP |a2|)
                                    (EQ (QCAR |a2|) '|Equation|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a2|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL))))
                               (setq |target|
                                        (|resolveTT| |a1| |a2|))
                               (COND
                                 ((AND |target|
                                       (NULL
                                        (BOOT-EQUAL |target| |$Any|)))
                                  (|putTarget| |opNode| |target|))
                                 (t (setq |target| NIL)))
                               |target|)
                              ((AND (CONSP |a1|)
                                    (EQ (QCAR |a1|) '|Equation|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a1|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)))
                                    (CONSP |a2|)
                                    (EQ (QCAR |a2|) '|List|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a2|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)
                                       (PROGN
                                         (setq |a2e|
                                          (QCAR |ISTMP#1|))
                                         t)))
                                    (CONSP |a2e|)
                                    (EQ (QCAR |a2e|) '|Equation|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a2e|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL))))
                               (setq |target|
                                        (|resolveTT| |a1| |a2e|))
                               (COND
                                 ((AND |target|
                                       (NULL
                                        (BOOT-EQUAL |target| |$Any|)))
                                  (|putTarget| |opNode| |target|))
                                 (t (setq |target| NIL)))
                               |target|)
                              ((OR (AND (CONSP |a2|)
                                    (EQ (QCAR |a2|) '|Equation|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a2|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)
                                       (PROGN
                                         (setq |a2e|
                                          (QCAR |ISTMP#1|))
                                         t))))
                                   (AND (CONSP |a2|)
                                    (EQ (QCAR |a2|) '|List|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a2|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)
                                       (PROGN
                                         (setq |ISTMP#2|
                                          (QCAR |ISTMP#1|))
                                         (AND (CONSP |ISTMP#2|)
                                          (EQ (QCAR |ISTMP#2|)
                                           '|Equation|)
                                          (PROGN
                                            (setq |ISTMP#3|
                                             (QCDR |ISTMP#2|))
                                            (AND (CONSP |ISTMP#3|)
                                             (EQ (QCDR |ISTMP#3|) NIL)
                                             (PROGN
                                               (setq |a2e|
                                                (QCAR |ISTMP#3|))
                                               t)))))))))
                               (PROGN
                                 (setq |target|
                                          (|resolveTT| |a1| |a2e|))
                                 (COND
                                   ((AND |target|
                                     (NULL
                                      (BOOT-EQUAL |target| |$Any|)))
                                    (|putTarget| |opNode| |target|))
                                   (t (setq |target| NIL)))
                                 |target|))))
                           ((OR (BOOT-EQUAL |op| '**)
                                (BOOT-EQUAL |op| '^))
                            (COND
                              ((BOOT-EQUAL |a2| |$Integer|)
                               (COND
                                 ((setq |target|
                                           (|resolveTCat| |a1|
                                            '(|Field|)))
                                  (|putTarget| |opNode| |target|)))
                               |target|)
                              ((AND (BOOT-EQUAL |a1|
                                     '(|AlgebraicNumber|))
                                    (OR (BOOT-EQUAL |a2| |$Float|)
                                     (BOOT-EQUAL |a2| |$DoubleFloat|)))
                               (setq |target|
                                        (CONS '|Expression|
                                         (CONS |a2| NIL)))
                               (|putTarget| |opNode| |target|)
                               |target|)
                              ((AND (BOOT-EQUAL |a1|
                                     '(|AlgebraicNumber|))
                                    (CONSP |a2|)
                                    (EQ (QCAR |a2|) '|Complex|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a2|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)
                                       (PROGN
                                         (setq |a3|
                                          (QCAR |ISTMP#1|))
                                         t)))
                                    (OR (BOOT-EQUAL |a3| |$Float|)
                                     (BOOT-EQUAL |a3| |$DoubleFloat|)))
                               (setq |target|
                                        (CONS '|Expression|
                                         (CONS |a3| NIL)))
                               (|putTarget| |opNode| |target|)
                               |target|)
                              ((AND (BOOT-EQUAL |a2| |$RationalNumber|)
                                    (OR (|typeIsASmallInteger| |a1|)
                                     (|isEqualOrSubDomain| |a1|
                                      |$Integer|)))
                               (|putTarget| |opNode|
                                   (setq |target|
                                    '(|AlgebraicNumber|)))
                               |target|)
                              ((AND (BOOT-EQUAL |a2| |$RationalNumber|)
                                    (OR (|isAVariableType| |a1|)
                                     (AND (CONSP |a1|)
                                      (EQ (QCAR |a1|) '|Polynomial|)
                                      (PROGN
                                        (setq |ISTMP#1| (QCDR |a1|))
                                        (AND (CONSP |ISTMP#1|)
                                         (EQ (QCDR |ISTMP#1|) NIL))))
                                     (AND (CONSP |a1|)
                                      (EQ (QCAR |a1|)
                                       '|RationalFunction|)
                                      (PROGN
                                        (setq |ISTMP#1| (QCDR |a1|))
                                        (AND (CONSP |ISTMP#1|)
                                         (EQ (QCDR |ISTMP#1|) NIL))))))
                               (|putTarget| |opNode|
                                   (setq |target|
                                    (|defaultTargetFE| |a1|)))
                               |target|)
                              ((AND (|isAVariableType| |a1|)
                                    (OR
                                     (BOOT-EQUAL |a2|
                                      |$PositiveInteger|)
                                     (BOOT-EQUAL |a2|
                                      |$NonNegativeInteger|)))
                               (|putTarget| |opNode|
                                   (setq |target|
                                    '(|Polynomial| (|Integer|))))
                               |target|)
                              ((|isAVariableType| |a2|)
                               (|putTarget| |opNode|
                                   (setq |target|
                                    (|defaultTargetFE| |a1|)))
                               |target|)
                              ((AND (CONSP |a2|)
                                    (EQ (QCAR |a2|) '|Polynomial|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a2|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)
                                       (PROGN
                                         (setq D (QCAR |ISTMP#1|))
                                         t))))
                               (COND
                                 ((OR (BOOT-EQUAL |a1| |a2|)
                                      (|isAVariableType| |a1|)
                                      (AND (CONSP |a1|)
                                       (EQ (QCAR |a1|)
                                        '|RationalFunction|)
                                       (PROGN
                                         (setq |ISTMP#1|
                                          (QCDR |a1|))
                                         (AND (CONSP |ISTMP#1|)
                                          (EQ (QCDR |ISTMP#1|) NIL)
                                          (PROGN
                                            (setq D1
                                             (QCAR |ISTMP#1|))
                                            t)))
                                       (BOOT-EQUAL D1 D))
                                      (BOOT-EQUAL |a1| D)
                                      (AND (CONSP |a1|)
                                       (EQUAL (QCAR |a1|)
                                        |$QuotientField|)
                                       (PROGN
                                         (setq |ISTMP#1|
                                          (QCDR |a1|))
                                         (AND (CONSP |ISTMP#1|)
                                          (EQ (QCDR |ISTMP#1|) NIL)
                                          (PROGN
                                            (setq D1
                                             (QCAR |ISTMP#1|))
                                            t)))
                                       (BOOT-EQUAL D1 |a1|)))
                                  (|putTarget| |opNode|
                                      (setq |target|
                                       (|defaultTargetFE| |a2|)))
                                  |target|)
                                 (t |target|)))
                              ((AND (CONSP |a2|)
                                    (EQ (QCAR |a2|)
                                     '|RationalFunction|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a2|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)
                                       (PROGN
                                         (setq D (QCAR |ISTMP#1|))
                                         t))))
                               (COND
                                 ((OR (BOOT-EQUAL |a1| |a2|)
                                      (|isAVariableType| |a1|)
                                      (AND (CONSP |a1|)
                                       (EQ (QCAR |a1|)
                                        '|RationalFunction|)
                                       (PROGN
                                         (setq |ISTMP#1|
                                          (QCDR |a1|))
                                         (AND (CONSP |ISTMP#1|)
                                          (EQ (QCDR |ISTMP#1|) NIL)
                                          (PROGN
                                            (setq D1
                                             (QCAR |ISTMP#1|))
                                            t)))
                                       (BOOT-EQUAL D1 D))
                                      (BOOT-EQUAL |a1| D)
                                      (AND (CONSP |a1|)
                                       (EQUAL (QCAR |a1|)
                                        |$QuotientField|)
                                       (PROGN
                                         (setq |ISTMP#1|
                                          (QCDR |a1|))
                                         (AND (CONSP |ISTMP#1|)
                                          (EQ (QCDR |ISTMP#1|) NIL)
                                          (PROGN
                                            (setq D1
                                             (QCAR |ISTMP#1|))
                                            t)))
                                       (BOOT-EQUAL D1 |a1|)))
                                  (|putTarget| |opNode|
                                      (setq |target|
                                       (|defaultTargetFE| |a2|)))
                                  |target|)
                                 (t |target|)))
                              (t |target|)))
                           ((BOOT-EQUAL |op| '/)
                            (COND
                              ((AND (|isEqualOrSubDomain| |a1|
                                     |$Integer|)
                                    (|isEqualOrSubDomain| |a2|
                                     |$Integer|))
                               (|putTarget| |opNode|
                                   (setq |target| |$RationalNumber|))
                               |target|)
                              ((BOOT-EQUAL |a1| |a2|)
                               (COND
                                 ((setq |target|
                                           (|resolveTCat| (CAR |args|)
                                            '(|Field|)))
                                  (|putTarget| |opNode| |target|)))
                               |target|)
                              ((AND (CONSP |a1|)
                                    (EQ (QCAR |a1|) '|Variable|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a1|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)))
                                    (CONSP |a2|)
                                    (EQ (QCAR |a2|) '|Variable|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a2|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL))))
                               (|putTarget| |opNode|
                                   (setq |target|
                                    (|mkRationalFunction| '(|Integer|))))
                               |target|)
                              ((AND (|isEqualOrSubDomain| |a1|
                                     |$Integer|)
                                    (CONSP |a2|)
                                    (EQ (QCAR |a2|) '|Variable|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a2|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL))))
                               (|putTarget| |opNode|
                                   (setq |target|
                                    (|mkRationalFunction| '(|Integer|))))
                               |target|)
                              (t
                               (AND (CONSP |a1|)
                                    (EQ (QCAR |a1|) '|Variable|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a1|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)))
                                    (COND
                                      ((AND (CONSP |a2|)
                                        (EQ (QCAR |a2|) '|Polynomial|)
                                        (PROGN
                                          (setq |ISTMP#1|
                                           (QCDR |a2|))
                                          (AND (CONSP |ISTMP#1|)
                                           (EQ (QCDR |ISTMP#1|) NIL)
                                           (PROGN
                                             (setq D
                                              (QCAR |ISTMP#1|))
                                             t))))
                                       (|putTarget| |opNode|
                                        (setq |target|
                                         (|mkRationalFunction| D)))
                                       |target|)
                                      (t |target|)))
                               (AND (CONSP |a2|)
                                    (EQ (QCAR |a2|) '|Variable|)
                                    (PROGN
                                      (setq |ISTMP#1| (QCDR |a2|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCDR |ISTMP#1|) NIL)))
                                    (COND
                                      ((AND (CONSP |a1|)
                                        (EQ (QCAR |a1|) '|Polynomial|)
                                        (PROGN
                                          (setq |ISTMP#1|
                                           (QCDR |a1|))
                                          (AND (CONSP |ISTMP#1|)
                                           (EQ (QCDR |ISTMP#1|) NIL)
                                           (PROGN
                                             (setq D
                                              (QCAR |ISTMP#1|))
                                             t))))
                                       (|putTarget| |opNode|
                                        (setq |target|
                                         (|mkRationalFunction| D)))
                                       |target|)
                                      (t |target|)))
                               (COND
                                 ((AND (CONSP |a2|)
                                       (EQ (QCAR |a2|) '|Polynomial|)
                                       (PROGN
                                         (setq |ISTMP#1|
                                          (QCDR |a2|))
                                         (AND (CONSP |ISTMP#1|)
                                          (EQ (QCDR |ISTMP#1|) NIL)
                                          (PROGN
                                            (setq D
                                             (QCAR |ISTMP#1|))
                                            t)))
                                       (BOOT-EQUAL |a1| D))
                                  (|putTarget| |opNode|
                                      (setq |target|
                                       (|mkRationalFunction| D)))
                                  |target|)
                                 (t |target|)))))))
                        (t (setq |a3| (CADDR |args|))
                         (SEQ (COND
                                ((EQL |nargs| 3)
                                 (COND
                                   ((BOOT-EQUAL |op| '|eval|)
                                    (EXIT
                                     (COND
                                       ((AND (CONSP |a3|)
                                         (EQ (QCAR |a3|) '|List|)
                                         (PROGN
                                           (setq |ISTMP#1|
                                            (QCDR |a3|))
                                           (AND (CONSP |ISTMP#1|)
                                            (EQ (QCDR |ISTMP#1|) NIL)
                                            (PROGN
                                              (setq |a3e|
                                               (QCAR |ISTMP#1|))
                                              t))))
                                        (setq |target|
                                         (|resolveTT| |a1| |a3e|))
                                        (COND
                                          ((NULL
                                            (BOOT-EQUAL |target|
                                             |$Any|))
                                           (|putTarget| |opNode|
                                            |target|))
                                          (t (setq |target| NIL)))
                                        |target|)
                                       (t
                                        (setq |target|
                                         (|resolveTT| |a1| |a3|))
                                        (COND
                                          ((NULL
                                            (BOOT-EQUAL |target|
                                             |$Any|))
                                           (|putTarget| |opNode|
                                            |target|))
                                          (t (setq |target| NIL)))
                                        |target|))))))
                                (t |target|))))))))))))))))

;mkRationalFunction D ==  ['Fraction, ['Polynomial, D]]

(defun |mkRationalFunction| (d)
 `(|Fraction| (|Polynomial| ,d)))

;altTypeOf(type,val,$declaredMode) ==
;  (EQCAR(type,'Symbol) or EQCAR(type,'Variable)) and
;    (a := getMinimalVarMode(objValUnwrap getValue(val),$declaredMode)) =>
;      a
;  type is ['OrderedVariableList,vl] and
;    INTEGERP(val1 := objValUnwrap getValue(val)) and
;      (a := getMinimalVarMode(vl.(val1 - 1),$declaredMode)) =>
;        a
;  type = $PositiveInteger    => $Integer
;  type = $NonNegativeInteger => $Integer
;  type = '(List (PositiveInteger)) => '(List (Integer))
;  NIL

(defun |altTypeOf| (type val |$declaredMode|)
 (declare (special |$declaredMode|))
 (let (tmp1 vl val1 a)
 (declare (special |$Integer| |$NonNegativeInteger| |$PositiveInteger|
                    |$declaredMode|))
  (cond
   ((and 
     (or (eqcar type '|Symbol|) (eqcar type '|Variable|))
     (setq a (|getMinimalVarMode| (|objValUnwrap| (|getValue| val))
                           |$declaredMode|)))
     a)
   ((and 
     (consp type) 
     (eq (qcar type) '|OrderedVariableList|)
     (progn
      (setq tmp1 (qcdr type))
      (and (consp tmp1) 
           (eq (qcdr tmp1) nil)
           (progn (setq vl (qcar tmp1)) t)))
     (integerp (setq val1 (|objValUnwrap| (|getValue| val))))
     (setq a (|getMinimalVarMode| (elt vl (- val1 1)) |$declaredMode|)))
    a)
   ((BOOT-EQUAL type |$PositiveInteger|) |$Integer|)
   ((BOOT-EQUAL type |$NonNegativeInteger|) |$Integer|)
   ((BOOT-EQUAL type '(|List| (|PositiveInteger|))) '(|List| (|Integer|)))
   (t nil))))

;getOpArgTypes(opname, args) ==
;  l := getOpArgTypes1(opname, args)
;  [f(a,opname) for a in l] where
;    f(x,op) ==
;      x is ['FunctionCalled,g] and op ^= 'name =>
;        m := get(g,'mode,$e) =>
;          m is ['Mapping,:.] => m
;          x
;        x
;      x

(defun |getOpArgTypes,f| (x op)
 (let ( m (result x))
 (declare (special |$e|))
  (if (and (eq (car x) '|FunctionCalled|) (not (eq op '|name|)))
   (if (and (cdr x) (setq m (|get| (cdr x) '|mode| |$e|)))
    (if (eq (car m) '|Mapping|)     
     (setq result m))))
  result))

(defun |getOpArgTypes| (opname args)
 (let (l g1)
  (setq l (|getOpArgTypes1| opname args))
  (do ((g2 l (cdr g2)) (a nil))
      ((or (atom g2) (progn (setq a (car g2)) nil))
        (nreverse0 g1))
      (setq g1 (cons (|getOpArgTypes,f| a opname) g1)))))

;getOpArgTypes1(opname, args) ==
;  null args => NIL
;  -- special cases first
;  opname = 'coef and args is [b,n] =>
;    [CAR getModeSet b, CAR getModeSetUseSubdomain n]
;  opname = 'monom and args is [d,c] =>
;    [CAR getModeSetUseSubdomain d,CAR getModeSet c]
;  opname = 'monom and args is [v,d,c] =>
;    [CAR getModeSet v,CAR getModeSetUseSubdomain d,CAR getModeSet c]
;  (opname = 'cons) and (2 = #args) and (CADR(args) = 'nil) =>
;    ms := [CAR getModeSet x for x in args]
;    if CADR(ms) = '(List (None)) then
;      ms := [first ms,['List,first ms]]
;    ms
;  nargs := #args
;  v := argCouldBelongToSubdomain(opname,nargs)
;  mss := NIL
;  for i in 0..(nargs-1) for x in args repeat
;    ms :=
;      v.i = 0 => CAR getModeSet x
;      CAR getModeSetUseSubdomain x
;    mss := [ms,:mss]
;  nreverse mss

(DEFUN |getOpArgTypes1| (|opname| |args|)
  (PROG (|b| |n| |ISTMP#1| |d| |ISTMP#2| |c| |nargs| |v| |ms| |mss|)
    (RETURN
      (SEQ (COND
             ((NULL |args|) NIL)
             ((AND (BOOT-EQUAL |opname| '|coef|) (CONSP |args|)
                   (PROGN
                     (setq |b| (QCAR |args|))
                     (setq |ISTMP#1| (QCDR |args|))
                     (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (setq |n| (QCAR |ISTMP#1|)) t))))
              (CONS (CAR (|getModeSet| |b|))
                    (CONS (CAR (|getModeSetUseSubdomain| |n|)) NIL)))
             ((AND (BOOT-EQUAL |opname| '|monom|) (CONSP |args|)
                   (PROGN
                     (setq |d| (QCAR |args|))
                     (setq |ISTMP#1| (QCDR |args|))
                     (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (setq |c| (QCAR |ISTMP#1|)) t))))
              (CONS (CAR (|getModeSetUseSubdomain| |d|))
                    (CONS (CAR (|getModeSet| |c|)) NIL)))
             ((AND (BOOT-EQUAL |opname| '|monom|) (CONSP |args|)
                   (PROGN
                     (setq |v| (QCAR |args|))
                     (setq |ISTMP#1| (QCDR |args|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (setq |d| (QCAR |ISTMP#1|))
                            (setq |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (setq |c| (QCAR |ISTMP#2|))
                                   t))))))
              (CONS (CAR (|getModeSet| |v|))
                    (CONS (CAR (|getModeSetUseSubdomain| |d|))
                          (CONS (CAR (|getModeSet| |c|)) NIL))))
             ((AND (BOOT-EQUAL |opname| '|cons|) (EQL 2 (|#| |args|))
                   (BOOT-EQUAL (CADR |args|) '|nil|))
              (setq |ms|
                       (PROG (G166858)
                         (setq G166858 NIL)
                         (RETURN
                           (DO ((G166863 |args| (CDR G166863))
                                (|x| NIL))
                               ((OR (ATOM G166863)
                                    (PROGN
                                      (SETQ |x| (CAR G166863))
                                      NIL))
                                (NREVERSE0 G166858))
                             (SEQ (EXIT (SETQ G166858
                                         (CONS (CAR (|getModeSet| |x|))
                                          G166858))))))))
              (COND
                ((BOOT-EQUAL (CADR |ms|) '(|List| (|None|)))
                 (setq |ms|
                          (CONS (CAR |ms|)
                                (CONS (CONS '|List|
                                       (CONS (CAR |ms|) NIL))
                                      NIL)))))
              |ms|)
             (t (setq |nargs| (|#| |args|))
              (setq |v|
                       (|argCouldBelongToSubdomain| |opname| |nargs|))
              (setq |mss| NIL)
              (DO ((G166875 (SPADDIFFERENCE |nargs| 1))
                   (|i| 0 (QSADD1 |i|))
                   (G166876 |args| (CDR G166876)) (|x| NIL))
                  ((OR (QSGREATERP |i| G166875) (ATOM G166876)
                       (PROGN (SETQ |x| (CAR G166876)) NIL))
                   NIL)
                (SEQ (EXIT (PROGN
                             (setq |ms|
                                      (COND
                                        ((EQL (ELT |v| |i|) 0)
                                         (CAR (|getModeSet| |x|)))
                                        (t
                                         (CAR
                                          (|getModeSetUseSubdomain|
                                           |x|)))))
                             (setq |mss| (CONS |ms| |mss|))))))
              (NREVERSE |mss|)))))))

;argCouldBelongToSubdomain(op, nargs) ==
;  -- this returns a vector containing 0 or ^0 for each argument.
;  -- if ^0, this indicates that there exists a modemap for the
;  -- op that needs a subdomain in that position
;  nargs = 0 => NIL
;  v := GETZEROVEC nargs
;  isMap(op) => v
;  mms := getModemapsFromDatabase(op,nargs)
;  null mms => v
;  nargs:=nargs-1
;  -- each signature has form
;  -- [domain of implementation, target, arg1, arg2, ...]
;  for [sig,cond,:.] in mms repeat
;    for t in CDDR sig for i in 0..(nargs) repeat
;      CONTAINEDisDomain(t,cond) =>
;          v.i := 1 + v.i
;  v

(DEFUN |argCouldBelongToSubdomain| (|op| |nargs|)
  (PROG (|v| |mms| |sig| |cond|)
    (RETURN
      (SEQ (COND
             ((EQL |nargs| 0) NIL)
             (t (setq |v| (GETZEROVEC |nargs|))
              (COND
                ((|isMap| |op|) |v|)
                (t
                 (setq |mms|
                          (|getModemapsFromDatabase| |op| |nargs|))
                 (COND
                   ((NULL |mms|) |v|)
                   (t (setq |nargs| (SPADDIFFERENCE |nargs| 1))
                    (SEQ (DO ((G166914 |mms| (CDR G166914))
                              (G166905 NIL))
                             ((OR (ATOM G166914)
                                  (PROGN
                                    (SETQ G166905 (CAR G166914))
                                    NIL)
                                  (PROGN
                                    (PROGN
                                      (setq |sig| (CAR G166905))
                                      (setq |cond| (CADR G166905))
                                      G166905)
                                    NIL))
                              NIL)
                           (SEQ (EXIT (DO
                                       ((G166925 (CDDR |sig|)
                                         (CDR G166925))
                                        (|t| NIL) (|i| 0 (QSADD1 |i|)))
                                       ((OR (ATOM G166925)
                                         (PROGN
                                           (SETQ |t| (CAR G166925))
                                           NIL)
                                         (QSGREATERP |i| |nargs|))
                                        NIL)
                                        (SEQ
                                         (EXIT
                                          (COND
                                            ((|CONTAINEDisDomain| |t|
                                              |cond|)
                                             (EXIT
                                              (SETELT |v| |i|
                                               (PLUS 1 (ELT |v| |i|))))))))))))
                         (EXIT |v|))))))))))))

;CONTAINEDisDomain(symbol,cond) ==
;-- looks for [isSubDomain,symbol,[domain]] in cond: returning T or NIL
;-- with domain being one of PositiveInteger and NonNegativeInteger
;   ATOM cond => false
;   MEMQ(QCAR cond,'(AND OR and or)) =>
;       or/[CONTAINEDisDomain(symbol, u) for u in QCDR cond]
;   EQ(QCAR cond,'isDomain) =>
;       EQ(symbol,CADR cond) and CONSP(dom:=CADDR cond) and
;         MEMQ(dom,'(PositiveInteger NonNegativeInteger))
;   false

(DEFUN |CONTAINEDisDomain| (|symbol| |cond|)
  (PROG (|dom|)
    (RETURN
      (SEQ (COND
             ((ATOM |cond|) NIL)
             ((member (QCAR |cond|) '(AND OR |and| |or|))
              (PROG (G166941)
                (setq G166941 NIL)
                (RETURN
                  (DO ((G166947 NIL G166941)
                       (G166948 (QCDR |cond|) (CDR G166948))
                       (|u| NIL))
                      ((OR G166947 (ATOM G166948)
                           (PROGN (SETQ |u| (CAR G166948)) NIL))
                       G166941)
                    (SEQ (EXIT (SETQ G166941
                                     (OR G166941
                                      (|CONTAINEDisDomain| |symbol|
                                       |u|)))))))))
             ((EQ (QCAR |cond|) '|isDomain|)
              (AND (EQ |symbol| (CADR |cond|))
                   (CONSP (setq |dom| (CADDR |cond|)))
                   (member |dom|
                         '(|PositiveInteger| |NonNegativeInteger|))))
             (t NIL))))))

;selectDollarMms(dc,name,types1,types2) ==
;  -- finds functions for name in domain dc
;  isPartialMode dc => throwKeyedMsg("S2IF0001",NIL)
;  mmS := findFunctionInDomain(name,dc,NIL,types1,types2,t,t) =>
;    orderMms(name, mmS,types1,types2,NIL)
;  if $reportBottomUpFlag then sayMSG
;    ["%b",'"          function not found in ",prefix2String dc,"%d","%l"]
;  NIL

(defun |selectDollarMms| (dc name types1 types2)
 (let (mmS)
 (declare (special |$reportBottomUpFlag|))
  (cond
   ((|isPartialMode| dc) 
    (|throwKeyedMsg| 'S2IF0001 nil))
   ((setq mmS (|findFunctionInDomain| name dc nil types1 types2 t t))
    (|orderMms| name mmS types1 types2 nil))
   (t
    (when |$reportBottomUpFlag|
     (|sayMSG| 
      `(|%b| "          function not found in " 
         ,(|prefix2String| dc) |%d| |%l|)))
    nil))))

;selectLocalMms(op,name,types,tar) ==
;  -- partial rewrite, looks now for exact local modemap
;  mmS:= getLocalMms(name,types,tar) => mmS
;  obj := getValue op
;  obj and (objVal obj is ['MAP,:mapDef]) and
;    analyzeMap(op,types,mapDef,tar) and getLocalMms(name,types,tar)

(defun |selectLocalMms| (op name types tar)
 (let (mmS obj tmp1 mapDef)
  (cond
   ((setq mmS (|getLocalMms| name types tar)) mmS)
   (t (setq obj (|getValue| op))
      (and obj
       (progn
        (setq tmp1 (|objVal| obj))
                (and (consp tmp1) 
                     (eq (qcar tmp1) 'map)
                     (progn (setq mapDef (qcdr tmp1)) t)))
       (|analyzeMap| op types mapDef tar)
       (|getLocalMms| name types tar))))))

;-- next defn may be better, test when more time. RSS 3/11/94
;-- selectLocalMms(op,name,types,tar) ==
;--  mmS := getLocalMms(name,types,tar)
;--  -- if no target, just return what we got
;--  mmS and null tar => mmS
;--  matchingMms := nil
;--  for mm in mmS repeat
;--    [., targ, :.] := mm
;--    if tar = targ then matchingMms := cons(mm, matchingMms)
;--  -- if we got some exact matchs on the target, return them
;--  matchingMms => nreverse matchingMms
;--
;--  obj := getValue op
;--  obj and (objVal obj is ['MAP,:mapDef]) and
;--    analyzeMap(op,types,mapDef,tar) and getLocalMms(name,types,tar)
;getLocalMms(name,types,tar) ==
;  -- looks for exact or subsumed local modemap in $e
;  mmS := NIL
;  for  (mm:=[dcSig,:.]) in get(name,'localModemap,$e) repeat
;    -- check format and destructure
;    dcSig isnt [dc,result,:args] => NIL
;    -- make number of args is correct
;    #types ^= #args => NIL
;    -- check for equal or subsumed arguments
;    subsume := (not $useIntegerSubdomain) or (tar = result) or
;      get(name,'recursive,$e)
;    acceptableArgs :=
;      and/[f(b,a,subsume) for a in args for b in types] where
;        f(x,y,subsume) ==
;          if subsume
;            then isEqualOrSubDomain(x,y)
;            else x = y
;    not acceptableArgs =>
;      -- interpreted maps are ok
;      dc = 'interpOnly and not($Coerce)=> mmS := [mm,:mmS]
;      NIL
;    mmS := [mm,:mmS]
;  nreverse mmS

(defun |getLocalMms,f| (x y subsume)
 (if subsume
  (|isEqualOrSubDomain| x y)
  (BOOT-EQUAL x y)))

(DEFUN |getLocalMms| (|name| |types| |tar|)
  (PROG (|dcSig| |dc| |ISTMP#1| |result| |args| |subsume|
                 |acceptableArgs| |mmS|)
  (declare (special |$Coerce| |$e| |$useIntegerSubdomain|))
    (RETURN
      (SEQ (PROGN
             (setq |mmS| NIL)
             (DO ((G167010 (|get| |name| '|localModemap| |$e|)
                             (CDR G167010))
                  (|mm| NIL))
                 ((OR (ATOM G167010)
                      (PROGN (SETQ |mm| (CAR G167010)) NIL)
                      (PROGN
                        (PROGN (setq |dcSig| (CAR |mm|)) |mm|)
                        NIL))
                  NIL)
               (SEQ (EXIT (COND
                            ((NULL (AND (CONSP |dcSig|)
                                    (PROGN
                                      (setq |dc| (QCAR |dcSig|))
                                      (setq |ISTMP#1|
                                       (QCDR |dcSig|))
                                      (AND (CONSP |ISTMP#1|)
                                       (PROGN
                                         (setq |result|
                                          (QCAR |ISTMP#1|))
                                         (setq |args|
                                          (QCDR |ISTMP#1|))
                                         t)))))
                             NIL)
                            ((NEQUAL (|#| |types|) (|#| |args|)) NIL)
                            (t
                             (setq |subsume|
                                      (OR (NULL |$useIntegerSubdomain|)
                                       (BOOT-EQUAL |tar| |result|)
                                       (|get| |name| '|recursive| |$e|)))
                             (setq |acceptableArgs|
                                      (PROG (G167017)
                                        (setq G167017 t)
                                        (RETURN
                                          (DO
                                           ((G167024 NIL
                                             (NULL G167017))
                                            (G167025 |args|
                                             (CDR G167025))
                                            (|a| NIL)
                                            (G167026 |types|
                                             (CDR G167026))
                                            (|b| NIL))
                                           ((OR G167024
                                             (ATOM G167025)
                                             (PROGN
                                               (SETQ |a|
                                                (CAR G167025))
                                               NIL)
                                             (ATOM G167026)
                                             (PROGN
                                               (SETQ |b|
                                                (CAR G167026))
                                               NIL))
                                            G167017)
                                            (SEQ
                                             (EXIT
                                              (SETQ G167017
                                               (AND G167017
                                                (|getLocalMms,f| |b|
                                                 |a| |subsume|)))))))))
                             (COND
                               ((NULL |acceptableArgs|)
                                (COND
                                  ((AND (BOOT-EQUAL |dc| '|interpOnly|)
                                    (NULL |$Coerce|))
                                   (setq |mmS| (CONS |mm| |mmS|)))
                                  (t NIL)))
                               (t (setq |mmS| (CONS |mm| |mmS|)))))))))
             (NREVERSE |mmS|))))))

\end{chunk}
mmCost assigns a penalty to each signature according to the following
formula:
\begin{verbatim}
  10000*n + 1000*domainDepth(res) + hitListOfTargets(res)
\end{verbatim}
where:
\begin{itemize}
\item {\bf n} is a penalty taking into account the number of coercions
necessary to coerce the types of the given arguments to those of the
signature under consideration.
\item {\bf res} is the codomain of the signature
\item {\bf hitListOfTarget} assigns a penalty between 1 and 1600 using
a short list of constructors: Polynomial (300), List (400), 500 is the
default, UniversalSegment (501), RationalFunction (900), Matrix (910),
Union (999), Expression (1600). Note that RationalFunction is actually
not a domain, so it should never happen.
\item {\bf domainDepth} calculates the maximal depth of the type
\item {\bf finally} the preference order of PI, NNI, and DFLOAT as
targets is done at the very end.
\end{itemize}
In particular, note that if we have two signatures taking types A and B,
and the given argument does not match exactly but has to be coerced, then
the types A and B themselves are not sorted by preference. 
\begin{chunk}{*}
;mmCost(name, sig,cond,tar,args1,args2) ==
;  cost := mmCost0(name, sig,cond,tar,args1,args2)
;  res := CADR sig
;  res = $PositiveInteger => cost - 2
;  res = $NonNegativeInteger => cost - 1
;  res = $DoubleFloat => cost + 1
;  if $reportBottomUpFlag then
;    sayMSG ['"cost=",prefix2String cost,'" for ", name,'": ",_
;            :formatSignature CDR sig]
;  cost

(DEFUN |mmCost| (|name| |sig| |cond| |tar| |args1| |args2|)
  (PROG (|cost| |res|)
  (declare (special |$reportBottomUpFlag| |$DoubleFloat| |$PositiveInteger|
                    |$NonNegativeInteger|))
    (RETURN
      (PROGN
        (setq |cost|
                 (|mmCost0| |name| |sig| |cond| |tar| |args1| |args2|))
        (setq |res| (CADR |sig|))
        (COND
          ((BOOT-EQUAL |res| |$PositiveInteger|)
           (SPADDIFFERENCE |cost| 2))
          ((BOOT-EQUAL |res| |$NonNegativeInteger|)
           (SPADDIFFERENCE |cost| 1))
          ((BOOT-EQUAL |res| |$DoubleFloat|) (PLUS |cost| 1))
          (t
           (COND
             (|$reportBottomUpFlag|
                 (|sayMSG|
                     (CONS  "cost="
                           (CONS (|prefix2String| |cost|)
                                 (CONS  " for "
                                       (CONS |name|
                                        (CONS  ": "
                                         (|formatSignature|
                                          (CDR |sig|))))))))))
           |cost|))))))

;mmCost0(name, sig,cond,tar,args1,args2) ==
;  sigArgs := CDDR sig
;  n:=
;    null cond => 1
;    not (or/cond) => 1
;    0
;  -- try to favor homogeneous multiplication
;--if name = "*" and 2 = #sigArgs and first sigArgs ^= first rest sigArgs then n := n + 1
;  -- because of obscure problem in evalMm, sometimes we will have extra
;  -- modemaps with the wrong number of arguments if we want to the one
;  -- with no arguments and the name is overloaded. Thus check for this.
;  if args1 then
;    for x1 in args1 for x2 in args2 for x3 in sigArgs repeat
;      n := n +
;        isEqualOrSubDomain(x1,x3) => 0
;        topcon := first deconstructT x1
;        topcon2 := first deconstructT x3
;        topcon = topcon2 => 3
;        CAR topcon2 = 'Mapping => 2
;        4
;  else if sigArgs then n := n + 100000000000
;  res := CADR sig
;  res=tar => 10000*n
;  10000*n + 1000*domainDepth(res) + hitListOfTarget(res)

(DEFUN |mmCost0| (|name| |sig| |cond| |tar| |args1| |args2|)
  (declare (ignore |name|))
  (PROG (|sigArgs| |topcon| |topcon2| |n| |res|)
    (RETURN
      (SEQ (PROGN
             (setq |sigArgs| (CDDR |sig|))
             (setq |n|
                      (COND
                        ((NULL |cond|) 1)
                        ((NULL (PROG (G167060)
                                 (setq G167060 NIL)
                                 (RETURN
                                   (DO
                                    ((G167066 NIL G167060)
                                     (G167067 |cond| (CDR G167067))
                                     (G167056 NIL))
                                    ((OR G167066 (ATOM G167067)
                                      (PROGN
                                        (SETQ G167056
                                         (CAR G167067))
                                        NIL))
                                     G167060)
                                     (SEQ
                                      (EXIT
                                       (SETQ G167060
                                        (OR G167060 G167056))))))))
                         1)
                        (t 0)))
             (COND
               (|args1| (DO ((G167079 |args1| (CDR G167079))
                             (|x1| NIL)
                             (G167080 |args2| (CDR G167080))
                             (|x2| NIL)
                             (G167081 |sigArgs| (CDR G167081))
                             (|x3| NIL))
                            ((OR (ATOM G167079)
                                 (PROGN
                                   (SETQ |x1| (CAR G167079))
                                   NIL)
                                 (ATOM G167080)
                                 (PROGN
                                   (SETQ |x2| (CAR G167080))
                                   NIL)
                                 (ATOM G167081)
                                 (PROGN
                                   (SETQ |x3| (CAR G167081))
                                   NIL))
                             NIL)
                          (SEQ (EXIT (setq |n|
                                      (PLUS |n|
                                       (COND
                                         ((|isEqualOrSubDomain| |x1|
                                           |x3|)
                                          0)
                                         (t
                                          (setq |topcon|
                                           (CAR (|deconstructT| |x1|)))
                                          (setq |topcon2|
                                           (CAR (|deconstructT| |x3|)))
                                          (COND
                                            ((BOOT-EQUAL |topcon|
                                              |topcon2|)
                                             3)
                                            ((BOOT-EQUAL
                                              (CAR |topcon2|)
                                              '|Mapping|)
                                             2)
                                            (t 4))))))))))
               (|sigArgs| (setq |n| (PLUS |n| 100000000000)))
               (t NIL))
             (setq |res| (CADR |sig|))
             (COND
               ((BOOT-EQUAL |res| |tar|) (TIMES 10000 |n|))
               (t
                (PLUS (PLUS (TIMES 10000 |n|)
                            (TIMES 1000 (|domainDepth| |res|)))
                      (|hitListOfTarget| |res|)))))))))

;orderMms(name, mmS,args1,args2,tar) ==
;  -- it counts the number of necessary coercions of the argument types
;  -- if this isn't enough, it compares the target types
;  mmS and null rest mmS => mmS
;  mS:= NIL
;  N:= NIL
;  for mm in MSORT mmS repeat
;    [sig,.,cond]:= mm
;    b:= t
;    p:= CONS(m := mmCost(name, sig,cond,tar,args1,args2),mm)
;    mS:=
;      null mS => list p
;      m < CAAR mS => CONS(p,mS)
;      S:= mS
;      until b repeat
;        b:= null CDR S or m < CAADR S =>
;          RPLACD(S,CONS(p,CDR S))
;        S:= CDR S
;      mS
;  mmS and [CDR p for p in mS]

(DEFUN |orderMms| (|name| |mmS| |args1| |args2| |tar|)
  (PROG (N |sig| |cond| |m| |p| |b| S |mS|)
    (RETURN
      (SEQ (COND
             ((AND |mmS| (NULL (CDR |mmS|))) |mmS|)
             (t (setq |mS| NIL) (setq N NIL)
              (DO ((G167119 (MSORT |mmS|) (CDR G167119))
                   (|mm| NIL))
                  ((OR (ATOM G167119)
                       (PROGN (SETQ |mm| (CAR G167119)) NIL))
                   NIL)
                (SEQ (EXIT (PROGN
                             (setq |sig| (CAR |mm|))
                             (setq |cond| (CADDR |mm|))
                             (setq |b| t)
                             (setq |p|
                                      (CONS
                                       (setq |m|
                                        (|mmCost| |name| |sig| |cond|
                                         |tar| |args1| |args2|))
                                       |mm|))
                             (setq |mS|
                                      (COND
                                        ((NULL |mS|) (LIST |p|))
                                        ((> (CAAR |mS|) |m|)
                                         (CONS |p| |mS|))
                                        (t (setq S |mS|)
                                         (DO ((G167128 NIL |b|))
                                          (G167128 NIL)
                                           (SEQ
                                            (EXIT
                                             (COND
                                               ((setq |b|
                                                 (OR (NULL (CDR S))
                                                  (> (CAADR S) |m|)))
                                                (RPLACD S
                                                 (CONS |p| (CDR S))))
                                               (t (setq S (CDR S)))))))
                                         |mS|)))))))
              (AND |mmS|
                   (PROG (G167136)
                     (setq G167136 NIL)
                     (RETURN
                       (DO ((G167141 |mS| (CDR G167141)) (|p| NIL))
                           ((OR (ATOM G167141)
                                (PROGN (SETQ |p| (CAR G167141)) NIL))
                            (NREVERSE0 G167136))
                         (SEQ (EXIT (SETQ G167136
                                     (CONS (CDR |p|) G167136))))))))))))))

;domainDepth(d) ==
;  -- computes the depth of lisp structure d
;  atom d => 0
;  MAX(domainDepth(CAR d)+1,domainDepth(CDR d))

(defun |domainDepth| (d)
 (if (atom d)
  0
  (max (+ (|domainDepth| (car d)) 1) (|domainDepth| (cdr d)))))

;hitListOfTarget(t) ==
;  -- assigns a number between 1 and 998 to a type t
;  -- want to make it hard to go to Polynomial Pi
;  t = '(Polynomial (Pi)) => 90000
;  EQ(CAR t, 'Polynomial) => 300
;  EQ(CAR t, 'List) => 400
;  EQ(CAR t,'Matrix) => 910
;  EQ(CAR t,'UniversalSegment) => 501
;  EQ(CAR t,'RationalFunction) => 900
;  EQ(CAR t,'Union) => 999
;  EQ(CAR t,'Expression) => 1600
;  500

(defun |hitListOfTarget| (arg)
 (cond
  ((BOOT-EQUAL arg '(|Polynomial| (|Pi|))) 90000)
  ((eq (car arg) '|Polynomial|) 300)
  ((eq (car arg) '|List|) 400)
  ((eq (car arg) '|Matrix|) 910)
  ((eq (car arg) '|UniversalSegment|) 501)
  ((eq (car arg) '|RationalFunction|) 900)
  ((eq (car arg) '|Union|) 999)
  ((eq (car arg) '|Expression|) 1600)
  (t 500)))

;getFunctionFromDomain(op,dc,args) ==
;  -- finds the function op with argument types args in dc
;  -- complains, if no function or ambiguous
;  $reportBottomUpFlag:local:= NIL
;  MEMBER(CAR dc,$nonLisplibDomains) =>
;    throwKeyedMsg("S2IF0002",[CAR dc])
;  not constructor? CAR dc =>
;    throwKeyedMsg("S2IF0003",[CAR dc])
;  p:= findFunctionInDomain(op,dc,NIL,args,args,NIL,NIL) =>
;    domain := evalDomain dc
;    for mm in nreverse p until b repeat
;      [[.,:osig],nsig,:.] := mm
;      b := compiledLookup(op,nsig,domain)
;    b or  throwKeyedMsg("S2IS0023",[op,dc])
;  throwKeyedMsg("S2IF0004",[op,dc])

(DEFUN |getFunctionFromDomain| (|op| |dc| |args|)
  (PROG (|$reportBottomUpFlag| |p| |domain| |osig| |nsig| |b|)
    (DECLARE (SPECIAL |$reportBottomUpFlag| |$nonLisplibDomains|))
    (RETURN
      (SEQ (PROGN
             (setq |$reportBottomUpFlag| NIL)
             (COND
               ((|member| (CAR |dc|) |$nonLisplibDomains|)
                (|throwKeyedMsg| 'S2IF0002 (CONS (CAR |dc|) NIL)))
               ((NULL (|constructor?| (CAR |dc|)))
                (|throwKeyedMsg| 'S2IF0003 (CONS (CAR |dc|) NIL)))
               ((setq |p|
                         (|findFunctionInDomain| |op| |dc| NIL |args|
                             |args| NIL NIL))
                (setq |domain| (|evalDomain| |dc|))
                (DO ((G167183 (NREVERSE |p|) (CDR G167183))
                     (|mm| NIL) (G167184 NIL |b|))
                    ((OR (ATOM G167183)
                         (PROGN (SETQ |mm| (CAR G167183)) NIL)
                         G167184)
                     NIL)
                  (SEQ (EXIT (PROGN
                               (setq |osig| (CDAR |mm|))
                               (setq |nsig| (CADR |mm|))
                               (setq |b|
                                        (|compiledLookup| |op| |nsig|
                                         |domain|))))))
                (OR |b|
                    (|throwKeyedMsg| 'S2IS0023
                        (CONS |op| (CONS |dc| NIL)))))
               (t
                (|throwKeyedMsg| 'S2IF0004 (CONS |op| (CONS |dc| NIL))))))))))

;isOpInDomain(opName,dom,nargs) ==
;  -- returns true only if there is an op in the given domain with
;  -- the given number of arguments
;  mmList := ASSQ(opName,getOperationAlistFromLisplib CAR dom)
;  mmList := subCopy(mmList,constructSubst dom)
;  null mmList => NIL
;  gotOne := NIL
;  nargs := nargs + 1
;  for mm in CDR mmList while not gotOne repeat
;    nargs = #CAR mm => gotOne := [mm, :gotOne]
;  gotOne

(DEFUN |isOpInDomain| (|opName| |dom| |nargs|)
  (PROG (|mmList| |gotOne|)
    (RETURN
      (SEQ (PROGN
             (setq |mmList|
                      (ASSQ |opName|
                            (|getOperationAlistFromLisplib|
                                (CAR |dom|))))
             (setq |mmList|
                      (|subCopy| |mmList| (|constructSubst| |dom|)))
             (COND
               ((NULL |mmList|) NIL)
               (t (setq |gotOne| NIL)
                (setq |nargs| (PLUS |nargs| 1))
                (SEQ (DO ((G167207 (CDR |mmList|) (CDR G167207))
                          (|mm| NIL))
                         ((OR (ATOM G167207)
                              (PROGN (SETQ |mm| (CAR G167207)) NIL)
                              (NULL (NULL |gotOne|)))
                          NIL)
                       (SEQ (EXIT (COND
                                    ((BOOT-EQUAL |nargs|
                                      (|#| (CAR |mm|)))
                                     (EXIT
                                      (setq |gotOne|
                                       (CONS |mm| |gotOne|))))))))
                     (EXIT |gotOne|)))))))))

;findCommonSigInDomain(opName,dom,nargs) ==
;  -- this looks at all signatures in dom with given opName and nargs
;  -- number of arguments. If no matches, returns NIL. Otherwise returns
;  -- a "signature" where a type position is non-NIL only if all
;  -- signatures shares that type .
;  CAR(dom) in '(Union Record Mapping) => NIL
;  mmList := ASSQ(opName,getOperationAlistFromLisplib CAR dom)
;  mmList := subCopy(mmList,constructSubst dom)
;  null mmList => NIL
;  gotOne := NIL
;  nargs := nargs + 1
;  vec := NIL
;  for mm in CDR mmList repeat
;    nargs = #CAR mm =>
;      null vec  => vec := LIST2VEC CAR mm
;      for i in 0.. for x in CAR mm repeat
;        if vec.i and vec.i ^= x then vec.i := NIL
;  VEC2LIST vec

(DEFUN |findCommonSigInDomain| (|opName| |dom| |nargs|)
  (PROG (|mmList| |gotOne| |vec|)
    (RETURN
      (SEQ (COND
             ((|member| (CAR |dom|) '(|Union| |Record| |Mapping|)) NIL)
             (t
              (setq |mmList|
                       (ASSQ |opName|
                             (|getOperationAlistFromLisplib|
                                 (CAR |dom|))))
              (setq |mmList|
                       (|subCopy| |mmList| (|constructSubst| |dom|)))
              (COND
                ((NULL |mmList|) NIL)
                (t (setq |gotOne| NIL)
                 (setq |nargs| (PLUS |nargs| 1)) (setq |vec| NIL)
                 (SEQ (DO ((G167227 (CDR |mmList|) (CDR G167227))
                           (|mm| NIL))
                          ((OR (ATOM G167227)
                               (PROGN (SETQ |mm| (CAR G167227)) NIL))
                           NIL)
                        (SEQ (EXIT (COND
                                     ((BOOT-EQUAL |nargs|
                                       (|#| (CAR |mm|)))
                                      (EXIT
                                       (COND
                                         ((NULL |vec|)
                                          (setq |vec|
                                           (LIST2VEC (CAR |mm|))))
                                         (t
                                          (DO
                                           ((|i| 0 (QSADD1 |i|))
                                            (G167237 (CAR |mm|)
                                             (CDR G167237))
                                            (|x| NIL))
                                           ((OR (ATOM G167237)
                                             (PROGN
                                               (SETQ |x|
                                                (CAR G167237))
                                               NIL))
                                            NIL)
                                            (SEQ
                                             (EXIT
                                              (COND
                                                ((AND (ELT |vec| |i|)
                                                  (NEQUAL
                                                   (ELT |vec| |i|) |x|))
                                                 (SETELT |vec| |i| NIL))
                                                (t NIL)))))))))))))
                      (VEC2LIST |vec|))))))))))

;findUniqueOpInDomain(op,opName,dom) ==
;  -- return function named op in domain dom if unique, choose one if not
;  mmList := ASSQ(opName,getOperationAlistFromLisplib CAR dom)
;  mmList := subCopy(mmList,constructSubst dom)
;  null mmList =>
;    throwKeyedMsg("S2IS0021",[opName,dom])
;  if #CDR mmList > 1 then
;    mm := selectMostGeneralMm CDR mmList
;    sayKeyedMsg("S2IS0022",[opName,dom,['Mapping,:CAR mm]])
;  else mm := CADR mmList
;  [sig,slot,:.] := mm
;  fun :=
;--+
;      $genValue =>
;         compiledLookupCheck(opName,sig,evalDomain dom)
;      NRTcompileEvalForm(opName, sig, evalDomain dom)
;  NULL(fun) or NULL(CONSP(fun)) => NIL
;  CAR fun = function(Undef) => throwKeyedMsg("S2IS0023",[opName,dom])
;  binVal :=
;    $genValue => wrap fun
;    fun
;  putValue(op,objNew(binVal,m:=['Mapping,:sig]))
;  putModeSet(op,[m])

(DEFUN |findUniqueOpInDomain| (|op| |opName| |dom|)
  (PROG (|mmList| |mm| |sig| |slot| |fun| |binVal| |m|)
  (declare (special |$genValue|))
    (RETURN
      (PROGN
        (setq |mmList|
                 (ASSQ |opName|
                       (|getOperationAlistFromLisplib| (CAR |dom|))))
        (setq |mmList|
                 (|subCopy| |mmList| (|constructSubst| |dom|)))
        (COND
          ((NULL |mmList|)
           (|throwKeyedMsg| 'S2IS0021 (CONS |opName| (CONS |dom| NIL))))
          (t
           (COND
             ((> (|#| (CDR |mmList|)) 1)
              (setq |mm| (|selectMostGeneralMm| (CDR |mmList|)))
              (|sayKeyedMsg| 'S2IS0022
                  (CONS |opName|
                        (CONS |dom|
                              (CONS (CONS '|Mapping| (CAR |mm|)) NIL)))))
             (t (setq |mm| (CADR |mmList|))))
           (setq |sig| (CAR |mm|)) (setq |slot| (CADR |mm|))
           (setq |fun|
                    (COND
                      (|$genValue|
                          (|compiledLookupCheck| |opName| |sig|
                              (|evalDomain| |dom|)))
                      (t
                       (|NRTcompileEvalForm| |opName| |sig|
                           (|evalDomain| |dom|)))))
           (COND
             ((OR (NULL |fun|) (NULL (CONSP |fun|))) NIL)
             ((BOOT-EQUAL (CAR |fun|) (|function| |Undef|))
              (|throwKeyedMsg| 'S2IS0023
                  (CONS |opName| (CONS |dom| NIL))))
             (t
              (setq |binVal|
                       (COND (|$genValue| (|wrap| |fun|)) (t |fun|)))
              (|putValue| |op|
                  (|objNew| |binVal|
                      (setq |m| (CONS '|Mapping| |sig|))))
              (|putModeSet| |op| (CONS |m| NIL))))))))))

;selectMostGeneralMm mmList ==
;  -- selects the modemap in mmList with arguments all the other
;  -- argument types can be coerced to
;  -- also selects function with #args closest to 2
;  min := 100
;  mml := mmList
;  while mml repeat
;    [mm,:mml] := mml
;    sz := #CAR mm
;    if (met := ABS(sz - 3)) < min then
;      min := met
;      fsz := sz
;  mmList := [mm for mm in mmList | (#CAR mm) = fsz]
;  mml := CDR mmList
;  genMm := CAR mmList
;  while mml repeat
;    [mm,:mml] := mml
;    and/[canCoerceFrom(genMmArg,mmArg) for mmArg in CDAR mm
;      for genMmArg in CDAR genMm] => genMm := mm
;  genMm

; NO UNIT TEST
(DEFUN |selectMostGeneralMm| (|mmList|)
  (PROG (|sz| |met| |min| |fsz| |LETTMP#1| |mm| |mml| |genMm|)
    (RETURN
      (SEQ (PROGN
             (setq |min| 100)
             (setq |mml| |mmList|)
             (DO () ((NULL |mml|) NIL)
               (SEQ (EXIT (PROGN
                            (setq |LETTMP#1| |mml|)
                            (setq |mm| (CAR |LETTMP#1|))
                            (setq |mml| (CDR |LETTMP#1|))
                            (setq |sz| (|#| (CAR |mm|)))
                            (COND
                              ((> |min|
                                  (setq |met|
                                           (ABS
                                            (SPADDIFFERENCE |sz| 3))))
                               (setq |min| |met|)
                               (setq |fsz| |sz|))
                              (t NIL))))))
             (setq |mmList|
                      (PROG (G167305)
                        (setq G167305 NIL)
                        (RETURN
                          (DO ((G167311 |mmList| (CDR G167311))
                               (|mm| NIL))
                              ((OR (ATOM G167311)
                                   (PROGN
                                     (SETQ |mm| (CAR G167311))
                                     NIL))
                               (NREVERSE0 G167305))
                            (SEQ (EXIT (COND
                                         ((BOOT-EQUAL (|#| (CAR |mm|))
                                           |fsz|)
                                          (SETQ G167305
                                           (CONS |mm| G167305))))))))))
             (setq |mml| (CDR |mmList|))
             (setq |genMm| (CAR |mmList|))
             (DO () ((NULL |mml|) NIL)
               (SEQ (EXIT (PROGN
                            (setq |LETTMP#1| |mml|)
                            (setq |mm| (CAR |LETTMP#1|))
                            (setq |mml| (CDR |LETTMP#1|))
                            (COND
                              ((PROG (G167327)
                                 (setq G167327 t)
                                 (RETURN
                                   (DO
                                    ((G167334 NIL (NULL G167327))
                                     (G167335 (CDAR |mm|)
                                      (CDR G167335))
                                     (|mmArg| NIL)
                                     (G167336 (CDAR |genMm|)
                                      (CDR G167336))
                                     (|genMmArg| NIL))
                                    ((OR G167334 (ATOM G167335)
                                      (PROGN
                                        (SETQ |mmArg| (CAR G167335))
                                        NIL)
                                      (ATOM G167336)
                                      (PROGN
                                        (SETQ |genMmArg|
                                         (CAR G167336))
                                        NIL))
                                     G167327)
                                     (SEQ
                                      (EXIT
                                       (SETQ G167327
                                        (AND G167327
                                         (|canCoerceFrom| |genMmArg|
                                          |mmArg|))))))))
                               (setq |genMm| |mm|)))))))
             |genMm|)))))

;findFunctionInDomain(op,dc,tar,args1,args2,$Coerce,$SubDom) ==
;  -- looks for a modemap for op with signature  args1 -> tar
;  --   in the domain of computation dc
;  -- tar may be NIL (= unknown)
;  null isLegitimateMode(tar, nil, nil) => nil
;  dcName:= CAR dc
;  member(dcName,'(Union Record Mapping Enumeration)) =>
;    -- First cut code that ignores args2, $Coerce and $SubDom
;    -- When domains no longer have to have Set, the hard coded 6 and 7
;    -- should go.
;    op = '_= =>
;        #args1 ^= 2 or args1.0 ^= dc or args1.1 ^= dc => NIL
;        tar and tar ^= '(Boolean) => NIL
;        [[[dc, '(Boolean), dc, dc], ['(Boolean),'$,'$], [NIL, NIL]]]
;    op = 'coerce =>
;        dcName='Enumeration and (args1.0=$Symbol or tar=dc)=>
;           [[[dc, dc, $Symbol], ['$,$Symbol], [NIL, NIL]]]
;        args1.0 ^= dc => NIL
;        tar and tar ^= $Expression => NIL
;        [[[dc, $Expression, dc], [$Expression,'$], [NIL, NIL]]]
;    member(dcName,'(Record Union)) =>
;      findFunctionInCategory(op,dc,tar,args1,args2,$Coerce,$SubDom)
;    NIL
;  fun:= NIL
;  ( p := ASSQ(op,getOperationAlistFromLisplib dcName) ) and
;    SL := constructSubst dc
;    -- if the arglist is homogeneous, first look for homogeneous
;    -- functions. If we don't find any, look at remaining ones
;    if isHomogeneousList args1 then
;      q := NIL
;      r := NIL
;      for mm in CDR p repeat
;        -- CDAR of mm is the signature argument list
;        if isHomogeneousList CDAR mm then q := [mm,:q]
;        else r := [mm,:r]
;      q := allOrMatchingMms(q,args1,tar,dc)
;      for mm in q repeat
;        fun:= nconc(fun,findFunctionInDomain1(mm,op,tar,args1,args2,SL))
;      r := reverse r
;    else r := CDR p
;    r := allOrMatchingMms(r,args1,tar,dc)
;    if not fun then    -- consider remaining modemaps
;      for mm in r repeat
;        fun:= nconc(fun,findFunctionInDomain1(mm,op,tar,args1,args2,SL))
;  if not fun and $reportBottomUpFlag then
;    sayMSG concat
;      ['"   -> no appropriate",:bright op,'"found in",
;        :bright prefix2String dc]
;  fun

(DEFUN |findFunctionInDomain|
       (|op| |dc| |tar| |args1| |args2| |$Coerce| |$SubDom|)
  (DECLARE (SPECIAL |$Coerce| |$SubDom|))
  (PROG (|dcName| |p| SL |q| |r| |fun|)
  (declare (special |$reportBottomUpFlag| |$SubDom| |$Coerce| |$Expression|
                    |$Symbol|))
    (RETURN
      (SEQ (COND
             ((NULL (|isLegitimateMode| |tar| NIL NIL)) NIL)
             (t (setq |dcName| (CAR |dc|))
              (COND
                ((|member| |dcName|
                     '(|Union| |Record| |Mapping| |Enumeration|))
                 (COND
                   ((BOOT-EQUAL |op| '=)
                    (COND
                      ((OR (NEQUAL (|#| |args1|) 2)
                           (NEQUAL (ELT |args1| 0) |dc|)
                           (NEQUAL (ELT |args1| 1) |dc|))
                       NIL)
                      ((AND |tar| (NEQUAL |tar| '(|Boolean|))) NIL)
                      (t
                       (CONS (CONS (CONS |dc|
                                    (CONS '(|Boolean|)
                                     (CONS |dc| (CONS |dc| NIL))))
                                   (CONS
                                    (CONS '(|Boolean|)
                                     (CONS '$ (CONS '$ NIL)))
                                    (CONS (CONS NIL (CONS NIL NIL))
                                     NIL)))
                             NIL))))
                   ((BOOT-EQUAL |op| '|coerce|)
                    (COND
                      ((AND (BOOT-EQUAL |dcName| '|Enumeration|)
                            (OR (BOOT-EQUAL (ELT |args1| 0) |$Symbol|)
                                (BOOT-EQUAL |tar| |dc|)))
                       (CONS (CONS (CONS |dc|
                                    (CONS |dc| (CONS |$Symbol| NIL)))
                                   (CONS (CONS '$ (CONS |$Symbol| NIL))
                                    (CONS (CONS NIL (CONS NIL NIL))
                                     NIL)))
                             NIL))
                      ((NEQUAL (ELT |args1| 0) |dc|) NIL)
                      ((AND |tar| (NEQUAL |tar| |$Expression|)) NIL)
                      (t
                       (CONS (CONS (CONS |dc|
                                    (CONS |$Expression|
                                     (CONS |dc| NIL)))
                                   (CONS
                                    (CONS |$Expression| (CONS '$ NIL))
                                    (CONS (CONS NIL (CONS NIL NIL))
                                     NIL)))
                             NIL))))
                   ((|member| |dcName| '(|Record| |Union|))
                    (|findFunctionInCategory| |op| |dc| |tar| |args1|
                        |args2| |$Coerce| |$SubDom|))
                   (t NIL)))
                (t (setq |fun| NIL)
                 (AND (setq |p|
                               (ASSQ |op|
                                     (|getOperationAlistFromLisplib|
                                      |dcName|)))
                      (PROGN
                        (setq SL (|constructSubst| |dc|))
                        (COND
                          ((|isHomogeneousList| |args1|)
                           (setq |q| NIL) (setq |r| NIL)
                           (DO ((G167376 (CDR |p|) (CDR G167376))
                                (|mm| NIL))
                               ((OR (ATOM G167376)
                                    (PROGN
                                      (SETQ |mm| (CAR G167376))
                                      NIL))
                                NIL)
                             (SEQ (EXIT (COND
                                          ((|isHomogeneousList|
                                            (CDAR |mm|))
                                           (setq |q|
                                            (CONS |mm| |q|)))
                                          (t
                                           (setq |r|
                                            (CONS |mm| |r|)))))))
                           (setq |q|
                                    (|allOrMatchingMms| |q| |args1|
                                     |tar| |dc|))
                           (DO ((G167385 |q| (CDR G167385))
                                (|mm| NIL))
                               ((OR (ATOM G167385)
                                    (PROGN
                                      (SETQ |mm| (CAR G167385))
                                      NIL))
                                NIL)
                             (SEQ (EXIT (setq |fun|
                                         (NCONC |fun|
                                          (|findFunctionInDomain1| |mm|
                                           |op| |tar| |args1| |args2|
                                           SL))))))
                           (setq |r| (REVERSE |r|)))
                          (t (setq |r| (CDR |p|))))
                        (setq |r|
                                 (|allOrMatchingMms| |r| |args1| |tar|
                                     |dc|))
                        (COND
                          ((NULL |fun|)
                           (DO ((G167394 |r| (CDR G167394))
                                (|mm| NIL))
                               ((OR (ATOM G167394)
                                    (PROGN
                                      (SETQ |mm| (CAR G167394))
                                      NIL))
                                NIL)
                             (SEQ (EXIT (setq |fun|
                                         (NCONC |fun|
                                          (|findFunctionInDomain1| |mm|
                                           |op| |tar| |args1| |args2|
                                           SL)))))))
                          (t NIL))))
                 (COND
                   ((AND (NULL |fun|) |$reportBottomUpFlag|)
                    (|sayMSG|
                        (|concat|
                            (CONS  "   -> no appropriate"
                                  (APPEND (|bright| |op|)
                                          (CONS  "found in"
                                           (|bright|
                                            (|prefix2String| |dc|)))))))))
                 |fun|))))))))

;allOrMatchingMms(mms,args1,tar,dc) ==
;  -- if there are exact matches on the arg types, return them
;  -- otherwise return the original list
;  null mms or null rest mms => mms
;  x := NIL
;  for mm in mms repeat
;    [sig,:.] := mm
;    [res,:args] := MSUBSTQ(dc,"$",sig)
;    args ^= args1 => nil
;    x := CONS(mm,x)
;  if x then x
;  else mms

(DEFUN |allOrMatchingMms| (|mms| |args1| |tar| |dc|)
  (declare (ignore |tar|))
  (PROG (|sig| |LETTMP#1| |res| |args| |x|)
    (RETURN
      (SEQ (COND
             ((OR (NULL |mms|) (NULL (CDR |mms|))) |mms|)
             (t (setq |x| NIL)
              (DO ((G167437 |mms| (CDR G167437)) (|mm| NIL))
                  ((OR (ATOM G167437)
                       (PROGN (SETQ |mm| (CAR G167437)) NIL))
                   NIL)
                (SEQ (EXIT (PROGN
                             (setq |sig| (CAR |mm|))
                             (setq |LETTMP#1|
                                      (MSUBSTQ |dc| '$ |sig|))
                             (setq |res| (CAR |LETTMP#1|))
                             (setq |args| (CDR |LETTMP#1|))
                             (COND
                               ((NEQUAL |args| |args1|) NIL)
                               (t (setq |x| (CONS |mm| |x|))))))))
              (COND (|x| |x|) (t |mms|))))))))

;isHomogeneousList y ==
;  y is [x] => true
;  y and rest y =>
;    z := CAR y
;    "and"/[x = z for x in CDR y]
;  NIL

(defun |isHomogeneousList| (y)
 (let (x)
  (if (and (listp y) (= (length y) 1))
   t
   (progn
    (setq x (car y))
    (every #'(lambda (z) (BOOT-EQUAL x z)) (cdr y))))))

;findFunctionInDomain1(omm,op,tar,args1,args2,SL) ==
;  dc:= CDR (dollarPair := ASSQ('$,SL))
;  -- need to drop '$ from SL
;  mm:= subCopy(omm, SL)
;  -- tests whether modemap mm is appropriate for the function
;  -- defined by op, target type tar and argument types args
;  $RTC:local:= NIL
;  -- $RTC is a list of run-time checks to be performed
;  [sig,slot,cond,y] := mm
;  [osig,:.]  := omm
;  osig := subCopy(osig, SUBSTQ(CONS('$,'$), dollarPair, SL))
;  if CONTAINED('_#, sig) or CONTAINED('construct, sig) then
;    sig := [replaceSharpCalls t for t in sig]
;  matchMmCond cond and matchMmSig(mm,tar,args1,args2) and
;    EQ(y,'Subsumed) and
;      -- hmmmm: do Union check in following because (as in DP)
;      -- Unions are subsumed by total modemaps which are in the
;      -- mm list in findFunctionInDomain.
;      y := 'ELT      -- if subsumed fails try it again
;      not $SubDom and CAR sig isnt ['Union,:.] and slot is [tar,:args] and
;        (f := findFunctionInDomain(op,dc,tar,args,args,NIL,NIL)) => f
;    EQ(y,'ELT) => [[CONS(dc,sig),osig,nreverse $RTC]]
;    EQ(y,'CONST) => [[CONS(dc,sig),osig,nreverse $RTC]]
;    EQ(y,'ASCONST) => [[CONS(dc,sig),osig,nreverse $RTC]]
;    y is ['XLAM,:.] => [[CONS(dc,sig),y,nreverse $RTC]]
;    sayKeyedMsg("S2IF0006",[y])
;    NIL

(DEFUN |findFunctionInDomain1| (|omm| |op| |tar| |args1| |args2| SL)
  (PROG ($RTC |dollarPair| |dc| |mm| |slot| |cond| |osig| |sig| |y|
              |ISTMP#1| |args| |f|)
    (DECLARE (SPECIAL $RTC |$SubDom|))
    (RETURN
      (SEQ (PROGN
             (setq |dc| (CDR (setq |dollarPair| (ASSQ '$ SL))))
             (setq |mm| (|subCopy| |omm| SL))
             (setq $RTC NIL)
             (setq |sig| (CAR |mm|))
             (setq |slot| (CADR |mm|))
             (setq |cond| (CADDR |mm|))
             (setq |y| (CADDDR |mm|))
             (setq |osig| (CAR |omm|))
             (setq |osig|
                      (|subCopy| |osig|
                          (SUBSTQ (CONS '$ '$) |dollarPair| SL)))
             (COND
               ((OR (CONTAINED '|#| |sig|)
                    (CONTAINED '|construct| |sig|))
                (setq |sig|
                         (PROG (G167493)
                           (setq G167493 NIL)
                           (RETURN
                             (DO ((G167498 |sig| (CDR G167498))
                                  (|t| NIL))
                                 ((OR (ATOM G167498)
                                      (PROGN
                                        (SETQ |t| (CAR G167498))
                                        NIL))
                                  (NREVERSE0 G167493))
                               (SEQ (EXIT
                                     (SETQ G167493
                                      (CONS (|replaceSharpCalls| |t|)
                                       G167493))))))))))
             (AND (|matchMmCond| |cond|)
                  (|matchMmSig| |mm| |tar| |args1| |args2|)
                  (PROGN
                    (AND (EQ |y| '|Subsumed|)
                         (PROGN
                           (setq |y| 'ELT)
                           (COND
                             ((AND (NULL |$SubDom|)
                                   (NULL
                                    (PROGN
                                      (setq |ISTMP#1| (CAR |sig|))
                                      (AND (CONSP |ISTMP#1|)
                                       (EQ (QCAR |ISTMP#1|) '|Union|))))
                                   (CONSP |slot|)
                                   (PROGN
                                     (setq |tar| (QCAR |slot|))
                                     (setq |args| (QCDR |slot|))
                                     t)
                                   (setq |f|
                                    (|findFunctionInDomain| |op| |dc|
                                     |tar| |args| |args| NIL NIL)))
                              |f|))))
                    (COND
                      ((EQ |y| 'ELT)
                       (CONS (CONS (CONS |dc| |sig|)
                                   (CONS |osig|
                                    (CONS (NREVERSE $RTC) NIL)))
                             NIL))
                      ((EQ |y| 'CONST)
                       (CONS (CONS (CONS |dc| |sig|)
                                   (CONS |osig|
                                    (CONS (NREVERSE $RTC) NIL)))
                             NIL))
                      ((EQ |y| 'ASCONST)
                       (CONS (CONS (CONS |dc| |sig|)
                                   (CONS |osig|
                                    (CONS (NREVERSE $RTC) NIL)))
                             NIL))
                      ((AND (CONSP |y|) (EQ (QCAR |y|) 'XLAM))
                       (CONS (CONS (CONS |dc| |sig|)
                                   (CONS |y|
                                    (CONS (NREVERSE $RTC) NIL)))
                             NIL))
                      (t (|sayKeyedMsg| 'S2IF0006 (CONS |y| NIL)) NIL)))))))))

;findFunctionInCategory(op,dc,tar,args1,args2,$Coerce,$SubDom) ==
;  -- looks for a modemap for op with signature  args1 -> tar
;  --   in the domain of computation dc
;  -- tar may be NIL (= unknown)
;  dcName:= CAR dc
;  not MEMQ(dcName,'(Record Union Enumeration)) => NIL
;  fun:= NIL
; --  cat := constructorCategory dc
;  makeFunc := GET(dcName,"makeFunctionList") or
;      systemErrorHere '"findFunctionInCategory"
;  [funlist,.] := FUNCALL(makeFunc,"$",dc,$CategoryFrame)
;  -- get list of implementations and remove sharps
;  maxargs := -1
;  impls := nil
;  for [a,b,d] in funlist repeat
;    not EQ(a,op) => nil
;    d is ['XLAM,xargs,:.] =>
;      if CONSP(xargs) then maxargs := MAX(maxargs,#xargs)
;      else maxargs := MAX(maxargs,1)
;      impls := cons([b,nil,true,d],impls)
;    impls := cons([b,d,true,d],impls)
;  impls := NREVERSE impls
;  if maxargs ^= -1 then
;    SL:= NIL
;    for i in 1..maxargs repeat
;      impls := SUBSTQ(GENSYM(),INTERNL('"#",STRINGIMAGE i),impls)
;  impls and
;    SL:= constructSubst dc
;    for mm in impls repeat
;      fun:= nconc(fun,findFunctionInDomain1(mm,op,tar,args1,args2,SL))
;  if not fun and $reportBottomUpFlag then
;    sayMSG concat
;      ['"   -> no appropriate",:bright op,'"found in",
;        :bright prefix2String dc]
;  fun

(DEFUN |findFunctionInCategory|
       (|op| |dc| |tar| |args1| |args2| |$Coerce| |$SubDom|)
  (DECLARE (SPECIAL |$Coerce| |$SubDom|))
  (PROG (|dcName| |makeFunc| |LETTMP#1| |funlist| |a| |b| |d| |ISTMP#1|
            |xargs| |maxargs| |impls| SL |fun|)
  (declare (special |$reportBottomUpFlag| |$CategoryFrame|))
    (RETURN
      (SEQ (PROGN
             (setq |dcName| (CAR |dc|))
             (COND
               ((NULL (member |dcName| '(|Record| |Union| |Enumeration|)))
                NIL)
               (t (setq |fun| NIL)
                (setq |makeFunc|
                         (OR (GETL |dcName| '|makeFunctionList|)
                             (|systemErrorHere|
                                  "findFunctionInCategory")))
                (setq |LETTMP#1|
                         (FUNCALL |makeFunc| '$ |dc| |$CategoryFrame|))
                (setq |funlist| (CAR |LETTMP#1|))
                (setq |maxargs| (SPADDIFFERENCE 1))
                (setq |impls| NIL)
                (DO ((G167553 |funlist| (CDR G167553))
                     (G167537 NIL))
                    ((OR (ATOM G167553)
                         (PROGN (SETQ G167537 (CAR G167553)) NIL)
                         (PROGN
                           (PROGN
                             (setq |a| (CAR G167537))
                             (setq |b| (CADR G167537))
                             (setq |d| (CADDR G167537))
                             G167537)
                           NIL))
                     NIL)
                  (SEQ (EXIT (COND
                               ((NULL (EQ |a| |op|)) NIL)
                               ((AND (CONSP |d|) (EQ (QCAR |d|) 'XLAM)
                                     (PROGN
                                       (setq |ISTMP#1| (QCDR |d|))
                                       (AND (CONSP |ISTMP#1|)
                                        (PROGN
                                          (setq |xargs|
                                           (QCAR |ISTMP#1|))
                                          t))))
                                (COND
                                  ((CONSP |xargs|)
                                   (setq |maxargs|
                                    (MAX |maxargs| (|#| |xargs|))))
                                  (t
                                   (setq |maxargs|
                                    (MAX |maxargs| 1))))
                                (setq |impls|
                                         (CONS
                                          (CONS |b|
                                           (CONS NIL
                                            (CONS t (CONS |d| NIL))))
                                          |impls|)))
                               (t
                                (setq |impls|
                                         (CONS
                                          (CONS |b|
                                           (CONS |d|
                                            (CONS t (CONS |d| NIL))))
                                          |impls|)))))))
                (setq |impls| (NREVERSE |impls|))
                (COND
                  ((NEQUAL |maxargs| (SPADDIFFERENCE 1))
                   (setq SL NIL)
                   (DO ((|i| 1 (QSADD1 |i|)))
                       ((QSGREATERP |i| |maxargs|) NIL)
                     (SEQ (EXIT (setq |impls|
                                         (SUBSTQ (GENSYM)
                                          (INTERNL  "#"
                                           (STRINGIMAGE |i|))
                                          |impls|)))))))
                (AND |impls|
                     (PROGN
                       (setq SL (|constructSubst| |dc|))
                       (DO ((G167569 |impls| (CDR G167569))
                            (|mm| NIL))
                           ((OR (ATOM G167569)
                                (PROGN
                                  (SETQ |mm| (CAR G167569))
                                  NIL))
                            NIL)
                         (SEQ (EXIT (setq |fun|
                                     (NCONC |fun|
                                      (|findFunctionInDomain1| |mm|
                                       |op| |tar| |args1| |args2| SL))))))))
                (COND
                  ((AND (NULL |fun|) |$reportBottomUpFlag|)
                   (|sayMSG|
                       (|concat|
                           (CONS  "   -> no appropriate"
                                 (APPEND (|bright| |op|)
                                         (CONS  "found in"
                                          (|bright|
                                           (|prefix2String| |dc|)))))))))
                |fun|)))))))

;matchMmCond(cond) ==
;  -- tests the condition, which comes with a modemap
;  -- cond is t or a list, but I hate to test for t (ALBI)
;  $domPvar: local := nil
;  atom cond or
;    cond is ['AND,:conds] or cond is ['and,:conds] =>
;      and/[matchMmCond c for c in conds]
;    cond is ['OR,:conds] or cond is ['or,:conds] =>
;      or/[matchMmCond c for c in conds]
;    cond is ['has,dom,x] =>
;      hasCaty(dom,x,NIL) ^= 'failed
;    cond is ['not,cond1] => not matchMmCond cond1
;    keyedSystemError("S2GE0016",
;      ['"matchMmCond",'"unknown form of condition"])

(DEFUN |matchMmCond| (|cond|)
  (PROG (|$domPvar| |conds| |dom| |ISTMP#2| |x| |ISTMP#1| |cond1|)
    (DECLARE (SPECIAL |$domPvar|))
    (RETURN
      (SEQ (PROGN
             (setq |$domPvar| NIL)
             (OR (ATOM |cond|)
                 (COND
                   ((OR (AND (CONSP |cond|) (EQ (QCAR |cond|) 'AND)
                             (PROGN
                               (setq |conds| (QCDR |cond|))
                               t))
                        (AND (CONSP |cond|) (EQ (QCAR |cond|) '|and|)
                             (PROGN
                               (setq |conds| (QCDR |cond|))
                               t)))
                    (PROG (G167622)
                      (setq G167622 t)
                      (RETURN
                        (DO ((G167628 NIL (NULL G167622))
                             (G167629 |conds| (CDR G167629))
                             (|c| NIL))
                            ((OR G167628 (ATOM G167629)
                                 (PROGN
                                   (SETQ |c| (CAR G167629))
                                   NIL))
                             G167622)
                          (SEQ (EXIT (SETQ G167622
                                      (AND G167622
                                       (|matchMmCond| |c|)))))))))
                   ((OR (AND (CONSP |cond|) (EQ (QCAR |cond|) 'OR)
                             (PROGN
                               (setq |conds| (QCDR |cond|))
                               t))
                        (AND (CONSP |cond|) (EQ (QCAR |cond|) '|or|)
                             (PROGN
                               (setq |conds| (QCDR |cond|))
                               t)))
                    (PROG (G167636)
                      (setq G167636 NIL)
                      (RETURN
                        (DO ((G167642 NIL G167636)
                             (G167643 |conds| (CDR G167643))
                             (|c| NIL))
                            ((OR G167642 (ATOM G167643)
                                 (PROGN
                                   (SETQ |c| (CAR G167643))
                                   NIL))
                             G167636)
                          (SEQ (EXIT (SETQ G167636
                                      (OR G167636
                                       (|matchMmCond| |c|)))))))))
                   ((AND (CONSP |cond|) (EQ (QCAR |cond|) '|has|)
                         (PROGN
                           (setq |ISTMP#1| (QCDR |cond|))
                           (AND (CONSP |ISTMP#1|)
                                (PROGN
                                  (setq |dom| (QCAR |ISTMP#1|))
                                  (setq |ISTMP#2| (QCDR |ISTMP#1|))
                                  (AND (CONSP |ISTMP#2|)
                                       (EQ (QCDR |ISTMP#2|) NIL)
                                       (PROGN
                                         (setq |x| (QCAR |ISTMP#2|))
                                         t))))))
                    (NEQUAL (|hasCaty| |dom| |x| NIL) '|failed|))
                   ((AND (CONSP |cond|) (EQ (QCAR |cond|) '|not|)
                         (PROGN
                           (setq |ISTMP#1| (QCDR |cond|))
                           (AND (CONSP |ISTMP#1|)
                                (EQ (QCDR |ISTMP#1|) NIL)
                                (PROGN
                                  (setq |cond1| (QCAR |ISTMP#1|))
                                  t))))
                    (NULL (|matchMmCond| |cond1|)))
                   (t
                    (|keyedSystemError| 'S2GE0016
                        (CONS  "matchMmCond"
                              (CONS  "unknown form of condition"
                                    NIL)))))))))))

;matchMmSig(mm,tar,args1,args2) ==
;  -- matches the modemap signature against  args1 -> tar
;  -- if necessary, runtime checks are created for subdomains
;  -- then the modemap condition is evaluated
;  [sig,:.]:= mm
;  if CONTAINED('_#, sig) then
;    sig := [replaceSharpCalls COPY t for t in sig]
;  null args1 => matchMmSigTar(tar,CAR sig)
;  a:= CDR sig
;  arg:= NIL
;  for i in 1.. while args1 and args2 and a until not b repeat
;    x1:= CAR args1
;    args1:= CDR args1
;    x2:= CAR args2
;    args2:= CDR args2
;    x:= CAR a
;    a:= CDR a
;    rtc:= NIL
;    if x is ['SubDomain,y,:.] then x:= y
;    b := isEqualOrSubDomain(x1,x) or
;      (STRINGP(x) and (x1 is ['Variable,v]) and (x = PNAME v)) or
;        $SubDom and isSubDomain(x,x1) => rtc:= t
;        $Coerce => x2=x or canCoerceFrom(x1,x)
;        x1 is ['Variable,:.] and x = '(Symbol)
;    $RTC:= CONS(rtc,$RTC)
;  null args1 and null a and b and matchMmSigTar(tar,CAR sig)

(DEFUN |matchMmSig| (|mm| |tar| |args1| |args2|)
  (PROG (|sig| |arg| |x1| |x2| |a| |y| |x| |ISTMP#1| |v| |rtc| |b|)
  (declare (special $RTC |$Coerce| |$SubDom|))
    (RETURN
      (SEQ (PROGN
             (setq |sig| (CAR |mm|))
             (COND
               ((CONTAINED '|#| |sig|)
                (setq |sig|
                         (PROG (G167685)
                           (setq G167685 NIL)
                           (RETURN
                             (DO ((G167690 |sig| (CDR G167690))
                                  (|t| NIL))
                                 ((OR (ATOM G167690)
                                      (PROGN
                                        (SETQ |t| (CAR G167690))
                                        NIL))
                                  (NREVERSE0 G167685))
                               (SEQ (EXIT
                                     (SETQ G167685
                                      (CONS
                                       (|replaceSharpCalls| (COPY |t|))
                                       G167685))))))))))
             (COND
               ((NULL |args1|) (|matchMmSigTar| |tar| (CAR |sig|)))
               (t (setq |a| (CDR |sig|)) (setq |arg| NIL)
                (DO ((|i| 1 (QSADD1 |i|)) (G167719 NIL (NULL |b|)))
                    ((OR (NULL (AND |args1| |args2| |a|)) G167719)
                     NIL)
                  (SEQ (EXIT (PROGN
                               (setq |x1| (CAR |args1|))
                               (setq |args1| (CDR |args1|))
                               (setq |x2| (CAR |args2|))
                               (setq |args2| (CDR |args2|))
                               (setq |x| (CAR |a|))
                               (setq |a| (CDR |a|))
                               (setq |rtc| NIL)
                               (COND
                                 ((AND (CONSP |x|)
                                       (EQ (QCAR |x|) '|SubDomain|)
                                       (PROGN
                                         (setq |ISTMP#1| (QCDR |x|))
                                         (AND (CONSP |ISTMP#1|)
                                          (PROGN
                                            (setq |y|
                                             (QCAR |ISTMP#1|))
                                            t))))
                                  (setq |x| |y|)))
                               (setq |b|
                                        (OR
                                         (|isEqualOrSubDomain| |x1|
                                          |x|)
                                         (AND (STRINGP |x|)
                                          (CONSP |x1|)
                                          (EQ (QCAR |x1|) '|Variable|)
                                          (PROGN
                                            (setq |ISTMP#1|
                                             (QCDR |x1|))
                                            (AND (CONSP |ISTMP#1|)
                                             (EQ (QCDR |ISTMP#1|) NIL)
                                             (PROGN
                                               (setq |v|
                                                (QCAR |ISTMP#1|))
                                               t)))
                                          (BOOT-EQUAL |x| (PNAME |v|)))
                                         (COND
                                           ((AND |$SubDom|
                                             (|isSubDomain| |x| |x1|))
                                            (setq |rtc| t))
                                           (|$Coerce|
                                            (OR (BOOT-EQUAL |x2| |x|)
                                             (|canCoerceFrom| |x1| |x|)))
                                           (t
                                            (AND (CONSP |x1|)
                                             (EQ (QCAR |x1|)
                                              '|Variable|)
                                             (BOOT-EQUAL |x|
                                              '(|Symbol|)))))))
                               (setq $RTC (CONS |rtc| $RTC))))))
                (AND (NULL |args1|) (NULL |a|) |b|
                     (|matchMmSigTar| |tar| (CAR |sig|))))))))))

;matchMmSigTar(t1,t2) ==
;  -- t1 is a target type specified by :: or by a declared variable
;  -- t2 is the target of a modemap signature
;  null t1 or
;    isEqualOrSubDomain(t2,t1) => true
;    if t2 is ['Union,a,b] then
;      if a='"failed" then return matchMmSigTar(t1, b)
;      if b='"failed" then return matchMmSigTar(t1, a)
;    $Coerce and
;      isPartialMode t1 => resolveTM(t2,t1)
;-- I think this should be true  -SCM
;--    true
;      canCoerceFrom(t2,t1)

(DEFUN |matchMmSigTar| (|t1| |t2|)
  (PROG (|ISTMP#1| |a| |ISTMP#2| |b|)
  (declare (special |$Coerce|))
    (RETURN
      (OR (NULL |t1|)
          (COND
            ((|isEqualOrSubDomain| |t2| |t1|) t)
            (t
             (COND
               ((AND (CONSP |t2|) (EQ (QCAR |t2|) '|Union|)
                     (PROGN
                       (setq |ISTMP#1| (QCDR |t2|))
                       (AND (CONSP |ISTMP#1|)
                            (PROGN
                              (setq |a| (QCAR |ISTMP#1|))
                              (setq |ISTMP#2| (QCDR |ISTMP#1|))
                              (AND (CONSP |ISTMP#2|)
                                   (EQ (QCDR |ISTMP#2|) NIL)
                                   (PROGN
                                     (setq |b| (QCAR |ISTMP#2|))
                                     t))))))
                (COND
                  ((BOOT-EQUAL |a|  "failed")
                   (RETURN (|matchMmSigTar| |t1| |b|))))
                (COND
                  ((BOOT-EQUAL |b| "failed")
                   (RETURN (|matchMmSigTar| |t1| |a|)))
                  (t NIL))))
             (AND |$Coerce|
                  (COND
                    ((|isPartialMode| |t1|) (|resolveTM| |t2| |t1|))
                    (t (|canCoerceFrom| |t2| |t1|))))))))))

;filterModemapsFromPackages(mms, names, op) ==
;  -- mms is a list of modemaps
;  -- names is a list of domain constructors
;  -- this returns a 2-list containing those modemaps that have one
;  -- of the names in the package source of the modemap and all the
;  -- rest of the modemaps in the second element.
;  good := NIL
;  bad  := NIL
;  -- hack to speed up factorization choices for mpolys and to overcome
;  -- some poor naming of packages
;  mpolys := '("Polynomial" "MultivariatePolynomial"
;   "DistributedMultivariatePolynomial"
;      "HomogeneousDistributedMultivariatePolynomial")
;  mpacks := '("MFactorize" "MRationalFactorize")
;  for mm in mms repeat
;    isFreeFunctionFromMm(mm) => bad := cons(mm, bad)
;    type := getDomainFromMm mm
;    null type => bad := cons(mm,bad)
;    if CONSP type then type := first type
;    GETDATABASE(type,'CONSTRUCTORKIND) = 'category => bad := cons(mm,bad)
;    name := object2String type
;    found := nil
;    for n in names while not found repeat
;      STRPOS(n,name,0,NIL) => found := true
;      -- hack, hack
;      (op = 'factor) and member(n,mpolys) and member(name,mpacks) =>
;        found := true
;    if found
;      then good := cons(mm, good)
;      else bad := cons(mm,bad)
;  [good,bad]

(DEFUN |filterModemapsFromPackages| (|mms| |names| |op|)
  (PROG (|mpolys| |mpacks| |type| |name| |found| |good| |bad|)
    (RETURN
      (SEQ (PROGN
             (setq |good| NIL)
             (setq |bad| NIL)
             (setq |mpolys|
                      '("Polynomial" "MultivariatePolynomial"
                        "DistributedMultivariatePolynomial"
                        "HomogeneousDistributedMultivariatePolynomial"))
             (setq |mpacks| '("MFactorize" "MRationalFactorize"))
             (DO ((G167795 |mms| (CDR G167795)) (|mm| NIL))
                 ((OR (ATOM G167795)
                      (PROGN (SETQ |mm| (CAR G167795)) NIL))
                  NIL)
               (SEQ (EXIT (COND
                            ((|isFreeFunctionFromMm| |mm|)
                             (setq |bad| (CONS |mm| |bad|)))
                            (t
                             (setq |type| (|getDomainFromMm| |mm|))
                             (COND
                               ((NULL |type|)
                                (setq |bad| (CONS |mm| |bad|)))
                               (t
                                (COND
                                  ((CONSP |type|)
                                   (setq |type| (CAR |type|))))
                                (COND
                                  ((BOOT-EQUAL
                                    (GETDATABASE |type|
                                     'CONSTRUCTORKIND)
                                    '|category|)
                                   (setq |bad| (CONS |mm| |bad|)))
                                  (t
                                   (setq |name|
                                    (|object2String| |type|))
                                   (setq |found| NIL)
                                   (DO
                                    ((G167805 |names|
                                      (CDR G167805))
                                     (|n| NIL))
                                    ((OR (ATOM G167805)
                                      (PROGN
                                        (SETQ |n| (CAR G167805))
                                        NIL)
                                      (NULL (NULL |found|)))
                                     NIL)
                                     (SEQ
                                      (EXIT
                                       (COND
                                         ((STRPOS |n| |name| 0 NIL)
                                          (setq |found| t))
                                         ((AND
                                           (BOOT-EQUAL |op| '|factor|)
                                           (|member| |n| |mpolys|)
                                           (|member| |name| |mpacks|))
                                          (setq |found| t))))))
                                   (COND
                                     (|found|
                                      (setq |good|
                                       (CONS |mm| |good|)))
                                     (t
                                   (setq |bad| (CONS |mm| |bad|)))))))))))))
             (CONS |good| (CONS |bad| NIL)))))))

;isFreeFunctionFromMm mm ==
;  -- This returns true is the modemap represents a free function, ie,
;  -- one not coming from a domain or category.
;  [., cond] := mm
;  isFreeFunctionFromMmCond cond

(DEFUN |isFreeFunctionFromMm| (|mm|)
  (PROG (|cond|)
    (RETURN
      (PROGN
        (SPADLET |cond| (CADR |mm|))
        (|isFreeFunctionFromMmCond| |cond|)))))

;isFreeFunctionFromMmCond cond ==
;  -- This returns true is the modemap represents a free function, ie,
;  -- one not coming from a domain or category.
;  if cond is ['partial, :c] then cond := c
;  condList :=
;    cond is ['AND, :cl] => cl
;    cond is ['OR, ['AND, :cl],:.] => cl  --all cl's should give same info
;    [cond]
;  iff := false
;  for condition in condList while not iff repeat
;      if condition is ['isFreeFunction, :.] then iff := true
;  iff

(DEFUN |isFreeFunctionFromMmCond| (|cond|)
  (PROG (|c| |ISTMP#1| |ISTMP#2| |cl| |condList| |iff|)
    (RETURN
      (SEQ (PROGN
             (COND
               ((AND (CONSP |cond|) (EQ (QCAR |cond|) '|partial|)
                     (PROGN (SPADLET |c| (QCDR |cond|)) 'T))
                (SPADLET |cond| |c|)))
             (SPADLET |condList|
                      (COND
                        ((AND (CONSP |cond|) (EQ (QCAR |cond|) 'AND)
                              (PROGN (SPADLET |cl| (QCDR |cond|)) 'T))
                         |cl|)
                        ((AND (CONSP |cond|) (EQ (QCAR |cond|) 'OR)
                              (PROGN
                                (SPADLET |ISTMP#1| (QCDR |cond|))
                                (AND (CONSP |ISTMP#1|)
                                     (PROGN
                                       (SPADLET |ISTMP#2|
                                        (QCAR |ISTMP#1|))
                                       (AND (CONSP |ISTMP#2|)
                                        (EQ (QCAR |ISTMP#2|) 'AND)
                                        (PROGN
                                          (SPADLET |cl|
                                           (QCDR |ISTMP#2|))
                                          'T))))))
                         |cl|)
                        ('T (CONS |cond| NIL))))
             (SPADLET |iff| NIL)
             (DO ((G167407 |condList| (CDR G167407))
                  (|condition| NIL))
                 ((OR (ATOM G167407)
                      (PROGN (SETQ |condition| (CAR G167407)) NIL)
                      (NULL (NULL |iff|)))
                  NIL)
               (SEQ (EXIT (COND
                            ((AND (CONSP |condition|)
                                  (EQ (QCAR |condition|)
                                      '|isFreeFunction|))
                             (SPADLET |iff| 'T))
                            ('T NIL)))))
             |iff|)))))

(defun |getDomainFromMm| (mm)
 (let (c cond condList val)
  (setq cond (cadr mm))
  (when (and (consp cond) (eq (qcar cond) '|partial|))
    (setq cond (qcdr cond)))
  (setq condList
   (cond
    ((and (consp cond) (eq (qcar cond) 'and))
      (qcdr cond))
    ((and (consp cond) (eq (qcar cond) 'or)
          (consp (qcdr cond)) (consp (qcar (qcdr cond)))
          (eq (qcar (qcar (qcdr cond))) 'and))
      (qcdr (qcar (qcdr cond))))
    (t (list cond))))
  (setq val
   (dolist (condition condList)
    (when
      (and (consp condition) 
           (or (eq (qcar condition) '|isDomain|)
               (eq (qcar condition) '|ofCategory|))
           (consp (qcdr condition))
           (eq (qcar (qcdr condition)) '*1)
           (consp (qcdr (qcdr condition)))
           (eq (qcdr (qcdr (qcdr condition))) nil))
      (return (|opOf| (caddr condition))))))
   (cond
    ((null val)
     (|keyedSystemError| 'S2GE0016
      (list "getDomainFromMm" "Can't find domain in modemap condition")))
    (t val))))

;isTowerWithSubdomain(towerType,elem) ==
;  not CONSP towerType => NIL
;  dt := deconstructT towerType
;  2 ^= #dt => NIL
;  s := underDomainOf(towerType)
;  isEqualOrSubDomain(s,elem) and constructM(first dt,[elem])

(defun |isTowerWithSubdomain| (towerType elem)
 (let (dt s)
  (when (consp towerType)
    (setq dt (|deconstructT| towerType))
    (when (= (|#| dt) 2)
      (setq s (|underDomainOf| towerType))
      (and (|isEqualOrSubDomain| s elem)
           (|constructM| (car dt) (cons elem nil)))))))

;selectMmsGen(op,tar,args1,args2) ==
;  -- general modemap evaluation of op with argument types args1
;  -- evaluates the condition and looks for the slot number
;  -- returns all functions which are applicable
;  -- args2 is a list of polynomial types for symbols
;  $Subst: local := NIL
;  $SymbolType: local := NIL
;  null (S := getModemapsFromDatabase(op,QLENGTH args1)) => NIL
;  if (op = 'map) and (2 = #args1) and
;    (CAR(args1) is ['Mapping,., elem]) and
;      (a := isTowerWithSubdomain(CADR args1,elem))
;        then args1 := [CAR args1,a]
;  -- we first split the modemaps into two groups:
;  --   haves:    these are from packages that have one of the top level
;  --             constructor names in the package name
;  --   havenots: everything else
;  -- get top level constructor names for constructors with parameters
;  conNames := nil
;  if op = 'reshape then args := APPEND(rest args1, rest args2)
;  else args := APPEND(args1,args2)
;  if tar then args := [tar,:args]
;  -- for common aggregates, use under domain also
;  for a in REMDUP args repeat
;    a =>
;      atom a => nil
;      fa := QCAR a
;      fa in '(Record Union) => NIL
;      conNames := insert(STRINGIMAGE fa, conNames)
;  if conNames
;    then [haves,havenots] := filterModemapsFromPackages(S,conNames,op)
;    else
;      haves := NIL
;      havenots := S
;  mmS := NIL
;  if $reportBottomUpFlag then
;    sayMSG ['%l,:bright '"Modemaps from Associated Packages"]
;  if haves then
;    [havesExact,havesInexact] := exact?(haves,tar,args1) where
;      exact?(mmS,tar,args) ==
;        ex := inex := NIL
;        for (mm := [sig,[mmC,:.],:.]) in mmS repeat
;          [c,t,:a] := sig
;          ok := true
;          for pat in a for arg in args while ok repeat
;            not CONTAINED(['isDomain,pat,arg],mmC) => ok := NIL
;          ok => ex := CONS(mm,ex)
;          inex := CONS(mm,inex)
;        [ex,inex]
;    if $reportBottomUpFlag then
;      for mm in APPEND(havesExact,havesInexact) for i in 1.. repeat
;        sayModemapWithNumber(mm,i)
;    if havesExact then
;      mmS := matchMms(havesExact,op,tar,args1,args2) where
;        matchMms(mmaps,op,tar,args1,args2) ==
;          mmS := NIL
;          for [sig,mmC] in mmaps repeat
;            -- sig is [dc,result,:args]
;            $Subst :=
;              tar and not isPartialMode tar =>
;                -- throw in the target if it is not the same as one
;                -- of the arguments
;                res := CADR sig
;                member(res,CDDR sig) => NIL
;                [[res,:tar]]
;              NIL
;            [c,t,:a] := sig
;            if a then matchTypes(a,args1,args2)
;            not EQ($Subst,'failed) =>
;              mmS := nconc(evalMm(op,tar,sig,mmC),mmS)
;          mmS
;      if mmS then
;        if $reportBottomUpFlag then
;          sayMSG '"   found an exact match!"
;        return mmS
;    mmS := matchMms(havesInexact,op,tar,args1,args2)
;  else if $reportBottomUpFlag then sayMSG '"   no modemaps"
;  mmS => mmS
;  if $reportBottomUpFlag then
;    sayMSG ['%l,:bright '"Remaining General Modemaps"]
;  --  for mm in havenots for i in 1.. repeat sayModemapWithNumber(mm,i)
;  if havenots then
;    [havesNExact,havesNInexact] := exact?(havenots,tar,args1)
;    if $reportBottomUpFlag then
;      for mm in APPEND(havesNExact,havesNInexact) for i in 1.. repeat
;        sayModemapWithNumber(mm,i)
;    if havesNExact then
;      mmS := matchMms(havesNExact,op,tar,args1,args2)
;      if mmS then
;        if $reportBottomUpFlag then
;          sayMSG '"   found an exact match!"
;        return mmS
;    mmS := matchMms(havesNInexact,op,tar,args1,args2)
;  else if $reportBottomUpFlag then sayMSG '"   no modemaps"
;  mmS

(DEFUN |selectMmsGen,exact?| (|mmS| |tar| |args|)
  (declare (ignore |tar|))
  (PROG (|sig| |mmC| |c| |t| |a| |ok| |ex| |inex|)
    (RETURN
      (SEQ (setq |ex| (setq |inex| NIL))
           (DO ((G167880 |mmS| (CDR G167880)) (|mm| NIL))
               ((OR (ATOM G167880)
                    (PROGN (SETQ |mm| (CAR G167880)) NIL)
                    (PROGN
                      (PROGN
                        (setq |sig| (CAR |mm|))
                        (setq |mmC| (CAADR |mm|))
                        |mm|)
                      NIL))
                NIL)
             (SEQ (PROGN
                    (setq |c| (CAR |sig|))
                    (setq |t| (CADR |sig|))
                    (setq |a| (CDDR |sig|))
                    |sig|)
                  (setq |ok| t)
                  (DO ((G167892 |a| (CDR G167892)) (|pat| NIL)
                       (G167893 |args| (CDR G167893)) (|arg| NIL))
                      ((OR (ATOM G167892)
                           (PROGN (SETQ |pat| (CAR G167892)) NIL)
                           (ATOM G167893)
                           (PROGN (SETQ |arg| (CAR G167893)) NIL)
                           (NULL |ok|))
                       NIL)
                    (SEQ (EXIT (IF (NULL
                                    (CONTAINED
                                     (CONS '|isDomain|
                                      (CONS |pat| (CONS |arg| NIL)))
                                     |mmC|))
                                   (EXIT (setq |ok| NIL))))))
                  (IF |ok| (EXIT (setq |ex| (CONS |mm| |ex|))))
                  (EXIT (setq |inex| (CONS |mm| |inex|)))))
           (EXIT (CONS |ex| (CONS |inex| NIL)))))))

(DEFUN |selectMmsGen,matchMms| (|mmaps| |op| |tar| |args1| |args2|)
  (PROG (|sig| |mmC| |res| |c| |t| |a| |mmS|)
  (declare (special |$Subst|))
    (RETURN
      (SEQ (setq |mmS| NIL)
           (DO ((G167949 |mmaps| (CDR G167949)) (G167936 NIL))
               ((OR (ATOM G167949)
                    (PROGN (SETQ G167936 (CAR G167949)) NIL)
                    (PROGN
                      (PROGN
                        (setq |sig| (CAR G167936))
                        (setq |mmC| (CADR G167936))
                        G167936)
                      NIL))
                NIL)
             (SEQ (setq |$Subst|
                           (SEQ (IF (AND |tar|
                                     (NULL (|isPartialMode| |tar|)))
                                    (EXIT
                                     (SEQ (setq |res| (CADR |sig|))
                                      (IF (|member| |res| (CDDR |sig|))
                                       (EXIT NIL))
                                      (EXIT
                                       (CONS (CONS |res| |tar|) NIL)))))
                                (EXIT NIL)))
                  (PROGN
                    (setq |c| (CAR |sig|))
                    (setq |t| (CADR |sig|))
                    (setq |a| (CDDR |sig|))
                    |sig|)
                  (IF |a| (|matchTypes| |a| |args1| |args2|) NIL)
                  (EXIT (IF (NULL (EQ |$Subst| '|failed|))
                            (EXIT (setq |mmS|
                                           (NCONC
                                            (|evalMm| |op| |tar| |sig|
                                             |mmC|)
                                            |mmS|)))))))
           (EXIT |mmS|)))))

(DEFUN |selectMmsGen| (|op| |tar| |args1| |args2|)
  (PROG (|$Subst| |$SymbolType| S |ISTMP#1| |ISTMP#2| |ISTMP#3| |elem|
            |a| |args| |fa| |conNames| |haves| |havenots| |havesExact|
            |havesInexact| |LETTMP#1| |havesNExact| |havesNInexact|
            |mmS|)
    (DECLARE (SPECIAL |$Subst| |$SymbolType| |$reportBottomUpFlag|))
    (RETURN
      (SEQ (PROGN
             (setq |$Subst| NIL)
             (setq |$SymbolType| NIL)
             (COND
               ((NULL (setq S
                               (|getModemapsFromDatabase| |op|
                                   (QLENGTH |args1|))))
                NIL)
               (t
                (COND
                  ((AND (BOOT-EQUAL |op| '|map|) (EQL 2 (|#| |args1|))
                        (PROGN
                          (setq |ISTMP#1| (CAR |args1|))
                          (AND (CONSP |ISTMP#1|)
                               (EQ (QCAR |ISTMP#1|) '|Mapping|)
                               (PROGN
                                 (setq |ISTMP#2| (QCDR |ISTMP#1|))
                                 (AND (CONSP |ISTMP#2|)
                                      (PROGN
                                        (setq |ISTMP#3|
                                         (QCDR |ISTMP#2|))
                                        (AND (CONSP |ISTMP#3|)
                                         (EQ (QCDR |ISTMP#3|) NIL)
                                         (PROGN
                                           (setq |elem|
                                            (QCAR |ISTMP#3|))
                                           t)))))))
                        (setq |a|
                                 (|isTowerWithSubdomain| (CADR |args1|)
                                     |elem|)))
                   (setq |args1|
                            (CONS (CAR |args1|) (CONS |a| NIL)))))
                (setq |conNames| NIL)
                (COND
                  ((BOOT-EQUAL |op| '|reshape|)
                   (setq |args|
                            (APPEND (CDR |args1|) (CDR |args2|))))
                  (t (setq |args| (APPEND |args1| |args2|))))
                (COND (|tar| (setq |args| (CONS |tar| |args|))))
                (SEQ (DO ((G167986 (REMDUP |args|) (CDR G167986))
                          (|a| NIL))
                         ((OR (ATOM G167986)
                              (PROGN (SETQ |a| (CAR G167986)) NIL))
                          NIL)
                       (SEQ (EXIT (COND
                                    (|a|
                                     (EXIT
                                      (COND
                                        ((ATOM |a|) NIL)
                                        (t (setq |fa| (QCAR |a|))
                                         (COND
                                           ((|member| |fa|
                                             '(|Record| |Union|))
                                            NIL)
                                           (t
                                            (setq |conNames|
                                             (|insert|
                                              (STRINGIMAGE |fa|)
                                              |conNames|))))))))))))
                     (COND
                       (|conNames|
                           (setq |LETTMP#1|
                                    (|filterModemapsFromPackages| S
                                     |conNames| |op|))
                           (setq |haves| (CAR |LETTMP#1|))
                           (setq |havenots| (CADR |LETTMP#1|))
                           |LETTMP#1|)
                       (t (setq |haves| NIL)
                        (setq |havenots| S)))
                     (setq |mmS| NIL)
                     (COND
                       (|$reportBottomUpFlag|
                           (|sayMSG|
                               (CONS '|%l|
                                     (|bright|
                                      "Modemaps from Associated Packages")))))
                     (COND
                       (|haves| (setq |LETTMP#1|
                                         (|selectMmsGen,exact?| |haves|
                                          |tar| |args1|))
                                (setq |havesExact| (CAR |LETTMP#1|))
                                (setq |havesInexact|
                                         (CADR |LETTMP#1|))
                                (COND
                                  (|$reportBottomUpFlag|
                                      (DO
                                       ((G167996
                                         (APPEND |havesExact|
                                          |havesInexact|)
                                         (CDR G167996))
                                        (|mm| NIL)
                                        (|i| 1 (QSADD1 |i|)))
                                       ((OR (ATOM G167996)
                                         (PROGN
                                           (SETQ |mm| (CAR G167996))
                                           NIL))
                                        NIL)
                                        (SEQ
                                         (EXIT
                                          (|sayModemapWithNumber| |mm|
                                           |i|))))))
                                (COND
                                  (|havesExact|
                                      (setq |mmS|
                                       (|selectMmsGen,matchMms|
                                        |havesExact| |op| |tar| |args1|
                                        |args2|))
                                      (COND
                                        (|mmS|
                                         (COND
                                           (|$reportBottomUpFlag|
                                            (|sayMSG|
                                              "   found an exact match!")))
                                         (RETURN |mmS|))
                                        (t NIL))))
                                (setq |mmS|
                                         (|selectMmsGen,matchMms|
                                          |havesInexact| |op| |tar|
                                          |args1| |args2|)))
                       (|$reportBottomUpFlag|
                           (|sayMSG|  "   no modemaps"))
                       (t NIL))
                     (COND (|mmS| (EXIT |mmS|)))
                     (COND
                       (|$reportBottomUpFlag|
                           (|sayMSG|
                               (CONS '|%l|
                                     (|bright|
                                       "Remaining General Modemaps")))))
                     (COND
                       (|havenots|
                           (setq |LETTMP#1|
                                    (|selectMmsGen,exact?| |havenots|
                                     |tar| |args1|))
                           (setq |havesNExact| (CAR |LETTMP#1|))
                           (setq |havesNInexact| (CADR |LETTMP#1|))
                           (COND
                             (|$reportBottomUpFlag|
                                 (DO ((G168006
                                       (APPEND |havesNExact|
                                        |havesNInexact|)
                                       (CDR G168006))
                                      (|mm| NIL) (|i| 1 (QSADD1 |i|)))
                                     ((OR (ATOM G168006)
                                       (PROGN
                                         (SETQ |mm| (CAR G168006))
                                         NIL))
                                      NIL)
                                   (SEQ
                                    (EXIT
                                     (|sayModemapWithNumber| |mm| |i|))))))
                           (COND
                             (|havesNExact|
                                 (setq |mmS|
                                          (|selectMmsGen,matchMms|
                                           |havesNExact| |op| |tar|
                                           |args1| |args2|))
                                 (COND
                                   (|mmS|
                                    (COND
                                      (|$reportBottomUpFlag|
                                       (|sayMSG|
                                         "   found an exact match!")))
                                    (RETURN |mmS|))
                                   (t NIL))))
                           (setq |mmS|
                                    (|selectMmsGen,matchMms|
                                     |havesNInexact| |op| |tar| |args1|
                                     |args2|)))
                       (|$reportBottomUpFlag|
                           (|sayMSG|  "   no modemaps"))
                       (t NIL))
                     (EXIT |mmS|)))))))))

;matchTypes(pm,args1,args2) ==
;  -- pm is a list of pattern variables, args1 a list of argument types,
;  --   args2 a list of polynomial types for symbols
;  -- the result is a match from pm to args, if one exists
;  for v in pm for t1 in args1 for t2 in args2 until $Subst='failed repeat
;    p:= ASSQ(v,$Subst) =>
;      t:= CDR p
;      t=t1 => $Coerce and EQCAR(t1,'Symbol) and
;        (q := ASSQ(v,$SymbolType)) and t2 and
;          (t3 := resolveTT(CDR q, t2)) and
;            RPLACD(q, t3)
;      $Coerce =>
;        if EQCAR(t,'Symbol) and (q := ASSQ(v,$SymbolType)) then
;          t := CDR q
;        if EQCAR(t1,'Symbol) and t2 then t1:= t2
;        t0 := resolveTT(t,t1) => RPLACD(p,t0)
;        $Subst:= 'failed
;      $Subst:= 'failed
;    $Subst:= CONS(CONS(v,t1),$Subst)
;    if EQCAR(t1,'Symbol) and t2 then $SymbolType:= CONS(CONS(v,t2),$SymbolType)

(DEFUN |matchTypes| (|pm| |args1| |args2|)
  (PROG (|p| |t3| |q| |t| |t0|)
  (declare (special |$SymbolType| |$Subst| |$Coerce|))
    (RETURN
      (SEQ (DO ((G168059 |pm| (CDR G168059)) (|v| NIL)
                (G168060 |args1| (CDR G168060)) (|t1| NIL)
                (G168061 |args2| (CDR G168061)) (|t2| NIL)
                (G168062 NIL (BOOT-EQUAL |$Subst| '|failed|)))
               ((OR (ATOM G168059)
                    (PROGN (SETQ |v| (CAR G168059)) NIL)
                    (ATOM G168060)
                    (PROGN (SETQ |t1| (CAR G168060)) NIL)
                    (ATOM G168061)
                    (PROGN (SETQ |t2| (CAR G168061)) NIL) G168062)
                NIL)
             (SEQ (EXIT (COND
                          ((setq |p| (ASSQ |v| |$Subst|))
                           (setq |t| (CDR |p|))
                           (COND
                             ((BOOT-EQUAL |t| |t1|)
                              (AND |$Coerce| (EQCAR |t1| '|Symbol|)
                                   (setq |q|
                                    (ASSQ |v| |$SymbolType|))
                                   |t2|
                                   (setq |t3|
                                    (|resolveTT| (CDR |q|) |t2|))
                                   (RPLACD |q| |t3|)))
                             (|$Coerce|
                                 (COND
                                   ((AND (EQCAR |t| '|Symbol|)
                                     (setq |q|
                                      (ASSQ |v| |$SymbolType|)))
                                    (setq |t| (CDR |q|))))
                                 (COND
                                   ((AND (EQCAR |t1| '|Symbol|) |t2|)
                                    (setq |t1| |t2|)))
                                 (COND
                                   ((setq |t0|
                                     (|resolveTT| |t| |t1|))
                                    (RPLACD |p| |t0|))
                                   (t (setq |$Subst| '|failed|))))
                             (t (setq |$Subst| '|failed|))))
                          (t
                           (setq |$Subst|
                                    (CONS (CONS |v| |t1|) |$Subst|))
                           (COND
                             ((AND (EQCAR |t1| '|Symbol|) |t2|)
                              (setq |$SymbolType|
                                       (CONS (CONS |v| |t2|)
                                        |$SymbolType|)))
                             (t NIL)))))))))))

;evalMm(op,tar,sig,mmC) ==
;  -- evaluates a modemap with signature sig and condition mmC
;  -- the result is a list of lists [sig,slot,cond] or NIL
;  --if $Coerce is NIL, tar has to be the same as the computed target type
;--if CONTAINED('LinearlyExplicitRingOver,mmC) then hohoho()
;  mS:= NIL
;  for st in evalMmStack mmC repeat
;    SL:= evalMmCond(op,sig,st)
;    not EQ(SL,'failed) =>
;      SL := fixUpTypeArgs SL
;      sig:= [subCopy(deepSubCopy(x,SL),$Subst) for x in sig]
;      not containsVars sig =>
;        isFreeFunctionFromMmCond mmC and (m := evalMmFreeFunction(op,tar,sig,mmC)) =>
;           mS:= nconc(m,mS)
;        "or"/[^isValidType(arg) for arg in sig] => nil
;        [dc,t,:args]:= sig
;        $Coerce or null tar or tar=t =>
;          mS:= nconc(findFunctionInDomain(op,dc,t,args,args,NIL,t),mS)
;  mS

(DEFUN |evalMm| (|op| |tar| |sig| |mmC|)
  (PROG (SL |m| |dc| |t| |args| |mS|)
  (declare (special |$Coerce| |$Subst|))
    (RETURN
      (SEQ (PROGN
             (setq |mS| NIL)
             (DO ((G168106 (|evalMmStack| |mmC|) (CDR G168106))
                  (|st| NIL))
                 ((OR (ATOM G168106)
                      (PROGN (SETQ |st| (CAR G168106)) NIL))
                  NIL)
               (SEQ (EXIT (PROGN
                            (setq SL (|evalMmCond| |op| |sig| |st|))
                            (COND
                              ((NULL (EQ SL '|failed|))
                               (PROGN
                                 (setq SL (|fixUpTypeArgs| SL))
                                 (setq |sig|
                                          (PROG (G168116)
                                            (setq G168116 NIL)
                                            (RETURN
                                              (DO
                                               ((G168121 |sig|
                                                 (CDR G168121))
                                                (|x| NIL))
                                               ((OR (ATOM G168121)
                                                 (PROGN
                                                   (SETQ |x|
                                                    (CAR G168121))
                                                   NIL))
                                                (NREVERSE0 G168116))
                                                (SEQ
                                                 (EXIT
                                                  (SETQ G168116
                                                   (CONS
                                                    (|subCopy|
                                                     (|deepSubCopy| |x|
                                                      SL)
                                                     |$Subst|)
                                                    G168116))))))))
                                 (COND
                                   ((NULL (|containsVars| |sig|))
                                    (COND
                                      ((AND
                                        (|isFreeFunctionFromMmCond|
                                         |mmC|)
                                        (setq |m|
                                         (|evalMmFreeFunction| |op|
                                          |tar| |sig| |mmC|)))
                                       (setq |mS| (NCONC |m| |mS|)))
                                      ((PROG (G168127)
                                         (setq G168127 NIL)
                                         (RETURN
                                           (DO
                                            ((G168133 NIL G168127)
                                             (G168134 |sig|
                                              (CDR G168134))
                                             (|arg| NIL))
                                            ((OR G168133
                                              (ATOM G168134)
                                              (PROGN
                                                (SETQ |arg|
                                                 (CAR G168134))
                                                NIL))
                                             G168127)
                                             (SEQ
                                              (EXIT
                                               (SETQ G168127
                                                (OR G168127
                                                 (NULL
                                                  (|isValidType| |arg|)))))))))
                                       NIL)
                                      (t (setq |dc| (CAR |sig|))
                                       (setq |t| (CADR |sig|))
                                       (setq |args| (CDDR |sig|))
                                       (COND
                                         ((OR |$Coerce| (NULL |tar|)
                                           (BOOT-EQUAL |tar| |t|))
                                          (setq |mS|
                                           (NCONC
                                            (|findFunctionInDomain|
                                             |op| |dc| |t| |args|
                                             |args| NIL t)
                                            |mS|)))))))))))))))
             |mS|)))))

;evalMmFreeFunction(op,tar,sig,mmC) ==
;  [dc,t,:args]:= sig
;  $Coerce or null tar or tar=t =>
;     nilArgs := nil
;     for a in args repeat nilArgs := [NIL,:nilArgs]
;     [[[["__FreeFunction__",:dc],t,:args], [t, :args], nilArgs]]
;  nil

; NO UNIT TEST
(DEFUN |evalMmFreeFunction| (|op| |tar| |sig| |mmC|)
  (declare (ignore |op| |mmC|))
  (PROG (|dc| |t| |args| |nilArgs|)
  (declare (special |$Coerce|))
    (RETURN
      (SEQ (PROGN
             (setq |dc| (CAR |sig|))
             (setq |t| (CADR |sig|))
             (setq |args| (CDDR |sig|))
             (COND
               ((OR |$Coerce| (NULL |tar|) (BOOT-EQUAL |tar| |t|))
                (setq |nilArgs| NIL)
                (DO ((G168165 |args| (CDR G168165)) (|a| NIL))
                    ((OR (ATOM G168165)
                         (PROGN (SETQ |a| (CAR G168165)) NIL))
                     NIL)
                  (SEQ (EXIT (setq |nilArgs| (CONS NIL |nilArgs|)))))
                (CONS (CONS (CONS (CONS '|_FreeFunction_| |dc|)
                                  (CONS |t| |args|))
                            (CONS (CONS |t| |args|)
                                  (CONS |nilArgs| NIL)))
                      NIL))
               (t NIL)))))))

;evalMmStack(mmC) ==
;  -- translates the modemap condition mmC into a list of stacks
;  mmC is ['AND,:a] =>
;    ["NCONC"/[evalMmStackInner cond for cond in a]]
;  mmC is ['OR,:args] => [:evalMmStack a for a in args]
;  mmC is ['partial,:mmD] => evalMmStack mmD
;  mmC is ['ofCategory,pvar,cat] and cat is ['Join,:args] =>
;    evalMmStack CONS('AND,[['ofCategory,pvar,c] for c in args])
;  mmC is ['ofType,:.] => [NIL]
;  mmC is ['has,pat,x] =>
;    MEMQ(x,'(ATTRIBUTE SIGNATURE)) =>
;      [[['ofCategory,pat,['CATEGORY,'unknown,x]]]]
;    [['ofCategory,pat,x]]
;  [[mmC]]

(DEFUN |evalMmStack| (|mmC|)
  (PROG (|a| |mmD| |pvar| |cat| |args| |ISTMP#1| |pat| |ISTMP#2| |x|)
    (RETURN
      (SEQ (COND
             ((AND (CONSP |mmC|) (EQ (QCAR |mmC|) 'AND)
                   (PROGN (setq |a| (QCDR |mmC|)) t))
              (CONS (PROG (G168213)
                      (setq G168213 NIL)
                      (RETURN
                        (DO ((G168218 |a| (CDR G168218))
                             (|cond| NIL))
                            ((OR (ATOM G168218)
                                 (PROGN
                                   (SETQ |cond| (CAR G168218))
                                   NIL))
                             G168213)
                          (SEQ (EXIT (SETQ G168213
                                      (NCONC G168213
                                       (|evalMmStackInner| |cond|))))))))
                    NIL))
             ((AND (CONSP |mmC|) (EQ (QCAR |mmC|) 'OR)
                   (PROGN (setq |args| (QCDR |mmC|)) t))
              (PROG (G168224)
                (setq G168224 NIL)
                (RETURN
                  (DO ((G168229 |args| (CDR G168229)) (|a| NIL))
                      ((OR (ATOM G168229)
                           (PROGN (SETQ |a| (CAR G168229)) NIL))
                       G168224)
                    (SEQ (EXIT (SETQ G168224
                                     (APPEND G168224
                                      (|evalMmStack| |a|)))))))))
             ((AND (CONSP |mmC|) (EQ (QCAR |mmC|) '|partial|)
                   (PROGN (setq |mmD| (QCDR |mmC|)) t))
              (|evalMmStack| |mmD|))
             ((AND (CONSP |mmC|) (EQ (QCAR |mmC|) '|ofCategory|)
                   (PROGN
                     (setq |ISTMP#1| (QCDR |mmC|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (setq |pvar| (QCAR |ISTMP#1|))
                            (setq |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (setq |cat| (QCAR |ISTMP#2|))
                                   t)))))
                   (CONSP |cat|) (EQ (QCAR |cat|) '|Join|)
                   (PROGN (setq |args| (QCDR |cat|)) t))
              (|evalMmStack|
                  (CONS 'AND
                        (PROG (G168239)
                          (setq G168239 NIL)
                          (RETURN
                            (DO ((G168244 |args| (CDR G168244))
                                 (|c| NIL))
                                ((OR (ATOM G168244)
                                     (PROGN
                                       (SETQ |c| (CAR G168244))
                                       NIL))
                                 (NREVERSE0 G168239))
                              (SEQ (EXIT
                                    (SETQ G168239
                                     (CONS
                                      (CONS '|ofCategory|
                                       (CONS |pvar| (CONS |c| NIL)))
                                      G168239))))))))))
             ((AND (CONSP |mmC|) (EQ (QCAR |mmC|) '|ofType|))
              (CONS NIL NIL))
             ((AND (CONSP |mmC|) (EQ (QCAR |mmC|) '|has|)
                   (PROGN
                     (setq |ISTMP#1| (QCDR |mmC|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (setq |pat| (QCAR |ISTMP#1|))
                            (setq |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (setq |x| (QCAR |ISTMP#2|))
                                   t))))))
              (COND
                ((member |x| '(ATTRIBUTE SIGNATURE))
                 (CONS (CONS (CONS '|ofCategory|
                                   (CONS |pat|
                                    (CONS
                                     (CONS 'CATEGORY
                                      (CONS '|unknown| (CONS |x| NIL)))
                                     NIL)))
                             NIL)
                       NIL))
                (t
                 (CONS (CONS '|ofCategory| (CONS |pat| (CONS |x| NIL)))
                       NIL))))
             (t (CONS (CONS |mmC| NIL) NIL)))))))

;evalMmStackInner(mmC) ==
;  mmC is ['OR,:args] =>
;    keyedSystemError("S2GE0016",
;      ['"evalMmStackInner",'"OR condition nested inside an AND"])
;  mmC is ['partial,:mmD] => evalMmStackInner mmD
;  mmC is ['ofCategory,pvar,cat] and cat is ['Join,:args] =>
;    [['ofCategory, pvar, c] for c in args]
;  mmC is ['ofType,:.] => NIL
;  mmC is ['isAsConstant] => NIL
;  mmC is ['has,pat,x] =>
;    MEMQ(x,'(ATTRIBUTE SIGNATURE)) =>
;      [['ofCategory,pat,['CATEGORY,'unknown,x]]]
;    [['ofCategory,pat,x]]
;  [mmC]

(DEFUN |evalMmStackInner| (|mmC|)
  (PROG (|mmD| |pvar| |cat| |args| |ISTMP#1| |pat| |ISTMP#2| |x|)
    (RETURN
      (SEQ (COND
             ((AND (CONSP |mmC|) (EQ (QCAR |mmC|) 'OR)
                   (PROGN (setq |args| (QCDR |mmC|)) t))
              (|keyedSystemError| 'S2GE0016
                  (CONS  "evalMmStackInner"
                        (CONS  "OR condition nested inside an AND"
                              NIL))))
             ((AND (CONSP |mmC|) (EQ (QCAR |mmC|) '|partial|)
                   (PROGN (setq |mmD| (QCDR |mmC|)) t))
              (|evalMmStackInner| |mmD|))
             ((AND (CONSP |mmC|) (EQ (QCAR |mmC|) '|ofCategory|)
                   (PROGN
                     (setq |ISTMP#1| (QCDR |mmC|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (setq |pvar| (QCAR |ISTMP#1|))
                            (setq |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (setq |cat| (QCAR |ISTMP#2|))
                                   t)))))
                   (CONSP |cat|) (EQ (QCAR |cat|) '|Join|)
                   (PROGN (setq |args| (QCDR |cat|)) t))
              (PROG (G168306)
                (setq G168306 NIL)
                (RETURN
                  (DO ((G168311 |args| (CDR G168311)) (|c| NIL))
                      ((OR (ATOM G168311)
                           (PROGN (SETQ |c| (CAR G168311)) NIL))
                       (NREVERSE0 G168306))
                    (SEQ (EXIT (SETQ G168306
                                     (CONS
                                      (CONS '|ofCategory|
                                       (CONS |pvar| (CONS |c| NIL)))
                                      G168306))))))))
             ((AND (CONSP |mmC|) (EQ (QCAR |mmC|) '|ofType|)) NIL)
             ((AND (CONSP |mmC|) (EQ (QCDR |mmC|) NIL)
                   (EQ (QCAR |mmC|) '|isAsConstant|))
              NIL)
             ((AND (CONSP |mmC|) (EQ (QCAR |mmC|) '|has|)
                   (PROGN
                     (setq |ISTMP#1| (QCDR |mmC|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (setq |pat| (QCAR |ISTMP#1|))
                            (setq |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (EQ (QCDR |ISTMP#2|) NIL)
                                 (PROGN
                                   (setq |x| (QCAR |ISTMP#2|))
                                   t))))))
              (COND
                ((member |x| '(ATTRIBUTE SIGNATURE))
                 (CONS (CONS '|ofCategory|
                             (CONS |pat|
                                   (CONS
                                    (CONS 'CATEGORY
                                     (CONS '|unknown| (CONS |x| NIL)))
                                    NIL)))
                       NIL))
                (t
                 (CONS (CONS '|ofCategory| (CONS |pat| (CONS |x| NIL)))
                       NIL))))
             (t (CONS |mmC| NIL)))))))

;evalMmCond(op,sig,st) ==
;  $insideEvalMmCondIfTrue : local := true
;  evalMmCond0(op,sig,st)

(defun |evalMmCond| (op sig st)
 (let (|$insideEvalMmCondIfTrue|)
 (declare (special |$insideEvalMmCondIfTrue|))
  (setq |$insideEvalMmCondIfTrue| t)
  (|evalMmCond0| op sig st)))

;evalMmCond0(op,sig,st) ==
;  -- evaluates the nonempty list of modemap conditions st
;  -- the result is either 'failed or a substitution list
;  SL:= evalMmDom st
;  SL='failed => 'failed
;  for p in SL until p1 and not b repeat b:=
;    p1:= ASSQ(CAR p,$Subst)
;    p1 and
;      t1:= CDR p1
;      t:= CDR p
;      t=t1 or
;        containsVars t =>
;          if $Coerce and EQCAR(t1,'Symbol) then t1:= getSymbolType CAR p
;          resolveTM1(t1,t)
;        $Coerce and
;          -- if we are looking at the result of a function, the coerce
;          -- goes the opposite direction
;          (t1 = $AnonymousFunction and t is ['Mapping, :.]) => t
;          CAR p = CADR sig and not member(CAR p, CDDR sig) =>
;            canCoerceFrom(t,t1) => t
;            NIL
;          canCoerceFrom(t1,t) => t
;          isSubDomain(t,t1) => RPLACD(p,t1)
;          EQCAR(t1,'Symbol) and canCoerceFrom(getSymbolType CAR p,t)
;  ( SL and p1 and not b and 'failed ) or evalMmCat(op,sig,st,SL)

(DEFUN |evalMmCond0| (|op| |sig| |st|)
  (PROG (SL |p1| |t| |t1| |b|)
  (declare (special |$AnonymousFunction| |$Coerce| |$Subst|))
    (RETURN
      (SEQ (PROGN
             (setq SL (|evalMmDom| |st|))
             (COND
               ((BOOT-EQUAL SL '|failed|) '|failed|)
               (t
                (DO ((G168355 SL (CDR G168355)) (|p| NIL)
                     (G168356 NIL (AND |p1| (NULL |b|))))
                    ((OR (ATOM G168355)
                         (PROGN (SETQ |p| (CAR G168355)) NIL)
                         G168356)
                     NIL)
                  (SEQ (EXIT (setq |b|
                                      (PROGN
                                        (setq |p1|
                                         (ASSQ (CAR |p|) |$Subst|))
                                        (AND |p1|
                                         (PROGN
                                           (setq |t1| (CDR |p1|))
                                           (setq |t| (CDR |p|))
                                           (OR (BOOT-EQUAL |t| |t1|)
                                            (COND
                                              ((|containsVars| |t|)
                                               (COND
                                                 ((AND |$Coerce|
                                                   (EQCAR |t1|
                                                    '|Symbol|))
                                                  (setq |t1|
                                                   (|getSymbolType|
                                                    (CAR |p|)))))
                                               (|resolveTM1| |t1| |t|))
                                              (t
                                               (AND |$Coerce|
                                                (COND
                                                  ((AND
                                                    (BOOT-EQUAL |t1|
                                                     |$AnonymousFunction|)
                                                    (CONSP |t|)
                                                    (EQ (QCAR |t|)
                                                     '|Mapping|))
                                                   |t|)
                                                  ((AND
                                                    (BOOT-EQUAL
                                                     (CAR |p|)
                                                     (CADR |sig|))
                                                    (NULL
                                                     (|member|
                                                      (CAR |p|)
                                                      (CDDR |sig|))))
                                                   (COND
                                                     ((|canCoerceFrom|
                                                       |t| |t1|)
                                                      t)
                                                     (t NIL)))
                                                  ((|canCoerceFrom|
                                                    |t1| |t|)
                                                   t)
                                                  ((|isSubDomain| |t|
                                                    |t1|)
                                                   (RPLACD |p| |t1|))
                                                  (t
                                                   (AND
                                                    (EQCAR |t1|
                                                     '|Symbol|)
                                                    (|canCoerceFrom|
                                                     (|getSymbolType|
                                                      (CAR |p|))
                                                     |t|)))))))))))))))
                (OR (AND SL |p1| (NULL |b|) '|failed|)
                    (|evalMmCat| |op| |sig| |st| SL)))))))))

;fixUpTypeArgs SL ==
;  for (p := [v, :t2]) in SL repeat
;    t1 := LASSOC(v, $Subst)
;    null t1 => RPLACD(p,replaceSharpCalls t2)
;    RPLACD(p, coerceTypeArgs(t1, t2, SL))
;  SL

(DEFUN |fixUpTypeArgs| (SL)
  (PROG (|v| |t2| |t1|)
  (declare (special |$Subst|))
    (RETURN
      (SEQ (PROGN
             (DO ((G168383 SL (CDR G168383)) (|p| NIL))
                 ((OR (ATOM G168383)
                      (PROGN (SETQ |p| (CAR G168383)) NIL)
                      (PROGN
                        (PROGN
                          (setq |v| (CAR |p|))
                          (setq |t2| (CDR |p|))
                          |p|)
                        NIL))
                  NIL)
               (SEQ (EXIT (PROGN
                            (setq |t1| (LASSOC |v| |$Subst|))
                            (COND
                              ((NULL |t1|)
                               (RPLACD |p| (|replaceSharpCalls| |t2|)))
                              (t
                               (RPLACD |p|
                                       (|coerceTypeArgs| |t1| |t2| SL))))))))
             SL)))))

;replaceSharpCalls t ==
;  noSharpCallsHere t => t
;  doReplaceSharpCalls t

(defun |replaceSharpCalls| (arg)
 (if (|noSharpCallsHere| arg) 
  arg
  (|doReplaceSharpCalls| arg)))

;doReplaceSharpCalls t ==
;  ATOM t => t
;  t is ['_#, l] => #l
;  t is ['construct,: l] => EVAL ['LIST,:l]
;  [CAR t,:[ doReplaceSharpCalls u for u in CDR t]]

(DEFUN |doReplaceSharpCalls| (|t|)
  (PROG (|ISTMP#1| |l|)
    (RETURN
      (SEQ (COND
             ((ATOM |t|) |t|)
             ((AND (CONSP |t|) (EQ (QCAR |t|) '|#|)
                   (PROGN
                     (setq |ISTMP#1| (QCDR |t|))
                     (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                          (PROGN (setq |l| (QCAR |ISTMP#1|)) t))))
              (|#| |l|))
             ((AND (CONSP |t|) (EQ (QCAR |t|) '|construct|)
                   (PROGN (setq |l| (QCDR |t|)) t))
              (EVAL (CONS 'LIST |l|)))
             (t
              (CONS (CAR |t|)
                    (PROG (G168409)
                      (setq G168409 NIL)
                      (RETURN
                        (DO ((G168414 (CDR |t|) (CDR G168414))
                             (|u| NIL))
                            ((OR (ATOM G168414)
                                 (PROGN
                                   (SETQ |u| (CAR G168414))
                                   NIL))
                             (NREVERSE0 G168409))
                          (SEQ (EXIT (SETQ G168409
                                      (CONS (|doReplaceSharpCalls| |u|)
                                       G168409))))))))))))))

;noSharpCallsHere t ==
;  t isnt [con, :args] => true
;  MEMQ(con,'(construct _#)) => NIL
;  and/[noSharpCallsHere u for u in args]

(DEFUN |noSharpCallsHere| (|t|)
  (PROG (|con| |args|)
    (RETURN
      (SEQ (COND
             ((NULL (AND (CONSP |t|)
                         (PROGN
                           (setq |con| (QCAR |t|))
                           (setq |args| (QCDR |t|))
                           t)))
              t)
             ((member |con| '(|construct| |#|)) NIL)
             (t
              (PROG (G168431)
                (setq G168431 t)
                (RETURN
                  (DO ((G168437 NIL (NULL G168431))
                       (G168438 |args| (CDR G168438)) (|u| NIL))
                      ((OR G168437 (ATOM G168438)
                           (PROGN (SETQ |u| (CAR G168438)) NIL))
                       G168431)
                    (SEQ (EXIT (SETQ G168431
                                     (AND G168431
                                      (|noSharpCallsHere| |u|))))))))))))))

;coerceTypeArgs(t1, t2, SL) ==
;  -- if the type t has type-valued arguments, coerce them to the new types,
;  -- if needed.
;  t1 isnt [con1, :args1] or t2 isnt [con2, :args2] => t2
;  con1 ^= con2 => t2
;  coSig := CDR GETDATABASE(CAR t1, 'COSIG)
;  and/coSig => t2
;  csub1 := constructSubst t1
;  csub2 := constructSubst t2
;  cs1 := CDR getConstructorSignature con1
;  cs2 := CDR getConstructorSignature con2
;  [con1, :
;    [makeConstrArg(arg1, arg2, constrArg(c1,csub1,SL),
;      constrArg(c2,csub2,SL), cs)
;       for arg1 in args1 for arg2 in args2 for c1 in cs1 for c2 in cs2
;         for cs in coSig]]

(DEFUN |coerceTypeArgs| (|t1| |t2| SL)
  (PROG (|con1| |args1| |con2| |args2| |coSig| |csub1| |csub2| |cs1|
                |cs2|)
    (RETURN
      (SEQ (COND
             ((OR (NULL (AND (CONSP |t1|)
                             (PROGN
                               (setq |con1| (QCAR |t1|))
                               (setq |args1| (QCDR |t1|))
                               t)))
                  (NULL (AND (CONSP |t2|)
                             (PROGN
                               (setq |con2| (QCAR |t2|))
                               (setq |args2| (QCDR |t2|))
                               t))))
              |t2|)
             ((NEQUAL |con1| |con2|) |t2|)
             (t
              (setq |coSig| (CDR (GETDATABASE (CAR |t1|) 'COSIG)))
              (COND
                ((PROG (G168459)
                   (setq G168459 t)
                   (RETURN
                     (DO ((G168465 NIL (NULL G168459))
                          (G168466 |coSig| (CDR G168466))
                          (G168451 NIL))
                         ((OR G168465 (ATOM G168466)
                              (PROGN
                                (SETQ G168451 (CAR G168466))
                                NIL))
                          G168459)
                       (SEQ (EXIT (SETQ G168459
                                        (AND G168459 G168451)))))))
                 |t2|)
                (t (setq |csub1| (|constructSubst| |t1|))
                 (setq |csub2| (|constructSubst| |t2|))
                 (setq |cs1|
                          (CDR (|getConstructorSignature| |con1|)))
                 (setq |cs2|
                          (CDR (|getConstructorSignature| |con2|)))
                 (CONS |con1|
                       (PROG (G168481)
                         (setq G168481 NIL)
                         (RETURN
                           (DO ((G168490 |args1| (CDR G168490))
                                (|arg1| NIL)
                                (G168491 |args2| (CDR G168491))
                                (|arg2| NIL)
                                (G168492 |cs1| (CDR G168492))
                                (|c1| NIL)
                                (G168493 |cs2| (CDR G168493))
                                (|c2| NIL)
                                (G168494 |coSig| (CDR G168494))
                                (|cs| NIL))
                               ((OR (ATOM G168490)
                                    (PROGN
                                      (SETQ |arg1| (CAR G168490))
                                      NIL)
                                    (ATOM G168491)
                                    (PROGN
                                      (SETQ |arg2| (CAR G168491))
                                      NIL)
                                    (ATOM G168492)
                                    (PROGN
                                      (SETQ |c1| (CAR G168492))
                                      NIL)
                                    (ATOM G168493)
                                    (PROGN
                                      (SETQ |c2| (CAR G168493))
                                      NIL)
                                    (ATOM G168494)
                                    (PROGN
                                      (SETQ |cs| (CAR G168494))
                                      NIL))
                                (NREVERSE0 G168481))
                             (SEQ (EXIT (SETQ G168481
                                         (CONS
                                          (|makeConstrArg| |arg1|
                                           |arg2|
                                           (|constrArg| |c1| |csub1|
                                            SL)
                                           (|constrArg| |c2| |csub2|
                                            SL)
                                           |cs|)
                                          G168481))))))))))))))))

;constrArg(v,sl,SL) ==
;  x := LASSOC(v,sl) =>
;    y := LASSOC(x,SL) => y
;    y := LASSOC(x, $Subst) => y
;    x
;  y := LASSOC(x, $Subst) => y
;  v

(defun |constrArg| (v sl sl1)
 (let (x y)
 (declare (special |$Subst|))
  (cond
   ((setq x (LASSOC v sl))
    (cond
     ((setq y (LASSOC x sl1)) y)
     ((setq y (LASSOC x |$Subst|)) y)
     (t x)))
   ((setq y (LASSOC x |$Subst|)) y)
   (t v))))

;makeConstrArg(arg1, arg2, t1, t2, cs) ==
;  if arg1 is ['_#, l] then arg1 := # l
;  if arg2 is ['_#, l] then arg2 := # l
;  cs => arg2
;  t1 = t2 => arg2
;  obj1 := objNewWrap(arg1, t1)
;  obj2 := coerceInt(obj1, t2)
;  null obj2 => throwKeyedMsgCannotCoerceWithValue(wrap arg1,t1,t2)
;  objValUnwrap obj2

(DEFUN |makeConstrArg| (|arg1| |arg2| |t1| |t2| |cs|)
  (PROG (|ISTMP#1| |l| |obj1| |obj2|)
    (RETURN
      (PROGN
        (COND
          ((AND (CONSP |arg1|) (EQ (QCAR |arg1|) '|#|)
                (PROGN
                  (setq |ISTMP#1| (QCDR |arg1|))
                  (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                       (PROGN (setq |l| (QCAR |ISTMP#1|)) t))))
           (setq |arg1| (|#| |l|))))
        (COND
          ((AND (CONSP |arg2|) (EQ (QCAR |arg2|) '|#|)
                (PROGN
                  (setq |ISTMP#1| (QCDR |arg2|))
                  (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                       (PROGN (setq |l| (QCAR |ISTMP#1|)) t))))
           (setq |arg2| (|#| |l|))))
        (COND
          (|cs| |arg2|)
          ((BOOT-EQUAL |t1| |t2|) |arg2|)
          (t (setq |obj1| (|objNewWrap| |arg1| |t1|))
           (setq |obj2| (|coerceInt| |obj1| |t2|))
           (COND
             ((NULL |obj2|)
              (|throwKeyedMsgCannotCoerceWithValue| (|wrap| |arg1|)
                  |t1| |t2|))
             (t (|objValUnwrap| |obj2|)))))))))

;evalMmDom(st) ==
;  -- evals all isDomain(v,d) of st
;  SL:= NIL
;  for mmC in st until SL='failed repeat
;    mmC is ['isDomain,v,d] =>
;      STRINGP d => SL:= 'failed
;      p:= ASSQ(v,SL) and not (d=CDR p) => SL:= 'failed
;      d1:= subCopy(d,SL)
;      CONSP(d1) and MEMQ(v,d1) => SL:= 'failed
;      SL:= augmentSub(v,d1,SL)
;    mmC is ['isFreeFunction,v,fun] =>
;      SL:= augmentSub(v,subCopy(fun,SL),SL)
;  SL

(DEFUN |evalMmDom| (|st|)
  (PROG (|d| |p| |d1| |ISTMP#1| |v| |ISTMP#2| |fun| SL)
    (RETURN
      (SEQ (PROGN
             (setq SL NIL)
             (DO ((G168608 |st| (CDR G168608)) (|mmC| NIL)
                  (G168609 NIL (BOOT-EQUAL SL '|failed|)))
                 ((OR (ATOM G168608)
                      (PROGN (SETQ |mmC| (CAR G168608)) NIL)
                      G168609)
                  NIL)
               (SEQ (EXIT (COND
                            ((AND (CONSP |mmC|)
                                  (EQ (QCAR |mmC|) '|isDomain|)
                                  (PROGN
                                    (setq |ISTMP#1| (QCDR |mmC|))
                                    (AND (CONSP |ISTMP#1|)
                                     (PROGN
                                       (setq |v| (QCAR |ISTMP#1|))
                                       (setq |ISTMP#2|
                                        (QCDR |ISTMP#1|))
                                       (AND (CONSP |ISTMP#2|)
                                        (EQ (QCDR |ISTMP#2|) NIL)
                                        (PROGN
                                          (setq |d|
                                           (QCAR |ISTMP#2|))
                                          t))))))
                             (COND
                               ((STRINGP |d|) (setq SL '|failed|))
                               ((setq |p|
                                         (AND (ASSQ |v| SL)
                                          (NULL
                                           (BOOT-EQUAL |d| (CDR |p|)))))
                                (setq SL '|failed|))
                               (t (setq |d1| (|subCopy| |d| SL))
                                (COND
                                  ((AND (CONSP |d1|) (member |v| |d1|))
                                   (setq SL '|failed|))
                                  (t
                                   (setq SL
                                    (|augmentSub| |v| |d1| SL)))))))
                            ((AND (CONSP |mmC|)
                                  (EQ (QCAR |mmC|) '|isFreeFunction|)
                                  (PROGN
                                    (setq |ISTMP#1| (QCDR |mmC|))
                                    (AND (CONSP |ISTMP#1|)
                                     (PROGN
                                       (setq |v| (QCAR |ISTMP#1|))
                                       (setq |ISTMP#2|
                                        (QCDR |ISTMP#1|))
                                       (AND (CONSP |ISTMP#2|)
                                        (EQ (QCDR |ISTMP#2|) NIL)
                                        (PROGN
                                          (setq |fun|
                                           (QCAR |ISTMP#2|))
                                          t))))))
                             (setq SL
                                      (|augmentSub| |v|
                                       (|subCopy| |fun| SL) SL)))))))
             SL)))))

;orderMmCatStack st ==
;  -- tries to reorder stack so that free pattern variables appear
;  -- as parameters first
;  null(st) or null rest(st) => st
;  vars := DELETE_-DUPLICATES [CADR(s) for s in st | isPatternVar(CADR(s))]
;  null vars => st
;  havevars := nil
;  haventvars := nil
;  for s in st repeat
;    cat := CADDR s
;    mem := nil
;    for v in vars while not mem repeat
;      if MEMQ(v,cat) then
;        mem := true
;        havevars := cons(s,havevars)
;    if not mem then haventvars := cons(s,haventvars)
;  null havevars => st
;  st := nreverse nconc(haventvars,havevars)
;  SORT(st, function mmCatComp)

(DEFUN |orderMmCatStack| (|st|)
  (PROG (|vars| |cat| |mem| |havevars| |haventvars|)
    (RETURN
      (SEQ (COND
             ((OR (NULL |st|) (NULL (CDR |st|))) |st|)
             (t
              (setq |vars|
                       (DELETE-DUPLICATES
                           (PROG (G168643)
                             (setq G168643 NIL)
                             (RETURN
                               (DO ((G168649 |st| (CDR G168649))
                                    (|s| NIL))
                                   ((OR (ATOM G168649)
                                     (PROGN
                                       (SETQ |s| (CAR G168649))
                                       NIL))
                                    (NREVERSE0 G168643))
                                 (SEQ (EXIT
                                       (COND
                                         ((|isPatternVar| (CADR |s|))
                                          (SETQ G168643
                                           (CONS (CADR |s|) G168643)))))))))))
              (COND
                ((NULL |vars|) |st|)
                (t (setq |havevars| NIL) (setq |haventvars| NIL)
                 (DO ((G168662 |st| (CDR G168662)) (|s| NIL))
                     ((OR (ATOM G168662)
                          (PROGN (SETQ |s| (CAR G168662)) NIL))
                      NIL)
                   (SEQ (EXIT (PROGN
                                (setq |cat| (CADDR |s|))
                                (setq |mem| NIL)
                                (DO ((G168672 |vars| (CDR G168672))
                                     (|v| NIL))
                                    ((OR (ATOM G168672)
                                      (PROGN
                                        (SETQ |v| (CAR G168672))
                                        NIL)
                                      (NULL (NULL |mem|)))
                                     NIL)
                                  (SEQ (EXIT
                                        (COND
                                          ((member |v| |cat|)
                                           (setq |mem| t)
                                           (setq |havevars|
                                            (CONS |s| |havevars|)))
                                          (t NIL)))))
                                (COND
                                  ((NULL |mem|)
                                   (setq |haventvars|
                                    (CONS |s| |haventvars|)))
                                  (t NIL))))))
                 (COND
                   ((NULL |havevars|) |st|)
                   (t
                    (setq |st|
                             (NREVERSE (NCONC |haventvars| |havevars|)))
                    (SORT |st| (|function| |mmCatComp|))))))))))))

;mmCatComp(c1, c2) ==
;  b1 := ASSQ(CADR c1, $Subst)
;  b2 := ASSQ(CADR c2, $Subst)
;  b1 and null(b2) => true
;  false

(defun |mmCatComp| (c1 c2)
 (declare (special |$Subst|))
  (and (assq (cadr c1) |$Subst|) (null (assq (cadr c2) |$Subst|))))

;evalMmCat(op,sig,stack,SL) ==
;  -- evaluates all ofCategory's of stack as soon as possible
;  $hope:local:= NIL
;  numConds:= #stack
;  stack:= orderMmCatStack [mmC for mmC in stack | EQCAR(mmC,'ofCategory)]
;  while stack until not makingProgress repeat
;    st := stack
;    stack := NIL
;    makingProgress := NIL
;    for mmC in st repeat
;      S:= evalMmCat1(mmC,op, SL)
;      S='failed and $hope =>
;        stack:= CONS(mmC,stack)
;      S = 'failed => return S
;      not atom S =>
;        makingProgress:= t
;        SL:= mergeSubs(S,SL)
;  if stack or S='failed then 'failed else SL

(DEFUN |evalMmCat| (|op| |sig| |stack| SL)
  (declare (ignore |sig|))
  (PROG (|$hope| |numConds| |st| S |makingProgress|)
    (DECLARE (SPECIAL |$hope|))
    (RETURN
      (SEQ (PROGN
             (setq |$hope| NIL)
             (setq |numConds| (|#| |stack|))
             (setq |stack|
                      (|orderMmCatStack|
                          (PROG (G168707)
                            (setq G168707 NIL)
                            (RETURN
                              (DO ((G168713 |stack| (CDR G168713))
                                   (|mmC| NIL))
                                  ((OR (ATOM G168713)
                                    (PROGN
                                      (SETQ |mmC| (CAR G168713))
                                      NIL))
                                   (NREVERSE0 G168707))
                                (SEQ (EXIT
                                      (COND
                                        ((EQCAR |mmC| '|ofCategory|)
                                         (SETQ G168707
                                          (CONS |mmC| G168707)))))))))))
             (DO ((G168731 NIL (NULL |makingProgress|)))
                 ((OR (NULL |stack|) G168731) NIL)
               (SEQ (EXIT (PROGN
                            (setq |st| |stack|)
                            (setq |stack| NIL)
                            (setq |makingProgress| NIL)
                            (DO ((G168743 |st| (CDR G168743))
                                 (|mmC| NIL))
                                ((OR (ATOM G168743)
                                     (PROGN
                                       (SETQ |mmC| (CAR G168743))
                                       NIL))
                                 NIL)
                              (SEQ (EXIT
                                    (PROGN
                                      (setq S
                                       (|evalMmCat1| |mmC| |op| SL))
                                      (COND
                                        ((AND (BOOT-EQUAL S '|failed|)
                                          |$hope|)
                                         (setq |stack|
                                          (CONS |mmC| |stack|)))
                                        ((BOOT-EQUAL S '|failed|)
                                         (RETURN S))
                                        ((NULL (ATOM S))
                                         (PROGN
                                           (setq |makingProgress|
                                            t)
                                           (setq SL
                                            (|mergeSubs| S SL)))))))))))))
             (COND
               ((OR |stack| (BOOT-EQUAL S '|failed|)) '|failed|)
               (t SL)))))))

;evalMmCat1(mmC is ['ofCategory,d,c],op, SL) ==
;  -- evaluates mmC using information from the lisplib
;  -- d may contain variables, and the substitution list $Subst is used
;  -- the result is a substitution or failed
;  $domPvar: local := NIL
;  $hope:= NIL
;  NSL:= hasCate(d,c,SL)
;  NSL='failed and isPatternVar d and $Coerce and ( p:= ASSQ(d,$Subst) )
;    and (EQCAR(CDR p,'Variable) or EQCAR(CDR p,'Symbol)) =>
;      RPLACD(p,getSymbolType d)
;      hasCate(d,c,SL)
;  NSL='failed and isPatternVar d =>
;    -- following is hack to take care of the case where we have a
;    -- free substitution variable with a category condition on it.
;    -- This would arise, for example, where a package has an argument
;    -- that is not in a needed modemap.  After making the following
;    -- dummy substitutions, the package can be instantiated and the
;    -- modemap used.       RSS 12-22-85
;    -- If c is not Set, Ring or Field then the more general mechanism
;    dom := defaultTypeForCategory(c, SL)
;    null dom =>
;      op ^= 'coerce => 'failed -- evalMmCatLastChance(d,c,SL)
;    null (p := ASSQ(d,$Subst)) =>
;      dom =>
;        NSL := [CONS(d,dom)]
;      op ^= 'coerce => 'failed -- evalMmCatLastChance(d,c,SL)
;    if containsVars dom then dom := resolveTM(CDR p, dom)
;    $Coerce and canCoerce(CDR p, dom) =>
;      NSL := [CONS(d,dom)]
;    op ^= 'coerce => 'failed -- evalMmCatLastChance(d,c,SL)
;  NSL

(DEFUN |evalMmCat1| (|mmC| |op| SL)
  (PROG (|$domPvar| |d| |c| |p| |dom| NSL)
    (DECLARE (SPECIAL |$domPvar| |$Coerce| |$Subst| |$hope| |$domPvar|))
    (RETURN
      (SEQ (PROGN
             (setq |d| (CADR |mmC|))
             (setq |c| (CADDR |mmC|))
             (setq |$domPvar| NIL)
             (setq |$hope| NIL)
             (setq NSL (|hasCate| |d| |c| SL))
             (COND
               ((AND (BOOT-EQUAL NSL '|failed|) (|isPatternVar| |d|)
                     |$Coerce| (setq |p| (ASSQ |d| |$Subst|))
                     (OR (EQCAR (CDR |p|) '|Variable|)
                         (EQCAR (CDR |p|) '|Symbol|)))
                (RPLACD |p| (|getSymbolType| |d|))
                (|hasCate| |d| |c| SL))
               ((AND (BOOT-EQUAL NSL '|failed|) (|isPatternVar| |d|))
                (setq |dom| (|defaultTypeForCategory| |c| SL))
                (SEQ (COND
                       ((NULL |dom|)
                        (EXIT (COND
                                ((NEQUAL |op| '|coerce|)
                                 (EXIT '|failed|)))))
                       ((NULL (setq |p| (ASSQ |d| |$Subst|)))
                        (EXIT (COND
                                (|dom| (setq NSL
                                        (CONS (CONS |d| |dom|) NIL)))
                                ((NEQUAL |op| '|coerce|) '|failed|)))))
                     (COND
                       ((|containsVars| |dom|)
                        (setq |dom| (|resolveTM| (CDR |p|) |dom|))))
                     (COND
                       ((AND |$Coerce| (|canCoerce| (CDR |p|) |dom|))
                        (setq NSL (CONS (CONS |d| |dom|) NIL)))
                       ((NEQUAL |op| '|coerce|) '|failed|))))
               (t NSL)))))))

;printMms(mmS) ==
;  -- mmS a list of modemap signatures
;  sayMSG '" "
;  for [sig,imp,.] in mmS for i in 1.. repeat
;    istr := STRCONC('"[",STRINGIMAGE i,'"]")
;    if QCSIZE(istr) = 3 then istr := STRCONC(istr,'" ")
;    sayMSG [:bright istr,'"signature:   ",:formatSignature CDR sig]
;    CAR sig='local =>
;      sayMSG ['"      implemented: local function ",imp]
;    imp is ['XLAM,:.] =>
;      sayMSG concat('"      implemented: XLAM from ",
;        prefix2String CAR sig)
;    sayMSG concat('"      implemented: slot ",imp,
;      '" from ",prefix2String CAR sig)
;  sayMSG '" "

; NO UNIT TEST
(DEFUN |printMms| (|mmS|)
  (PROG (|sig| |imp| |istr|)
    (RETURN
      (SEQ (PROGN
             (|sayMSG|  " ")
             (DO ((G169736 |mmS| (CDR G169736)) (G169722 NIL)
                  (|i| 1 (QSADD1 |i|)))
                 ((OR (ATOM G169736)
                      (PROGN (SETQ G169722 (CAR G169736)) NIL)
                      (PROGN
                        (PROGN
                          (setq |sig| (CAR G169722))
                          (setq |imp| (CADR G169722))
                          G169722)
                        NIL))
                  NIL)
               (SEQ (EXIT (PROGN
                            (setq |istr|
                                     (STRCONC  "["
                                      (STRINGIMAGE |i|)
                                       "]"))
                            (COND
                              ((EQL (QCSIZE |istr|) 3)
                               (setq |istr|
                                        (STRCONC |istr|
                                          " "))))
                            (|sayMSG|
                                (APPEND (|bright| |istr|)
                                        (CONS
                                          "signature:   "
                                         (|formatSignature|
                                          (CDR |sig|)))))
                            (COND
                              ((BOOT-EQUAL (CAR |sig|) '|local|)
                               (|sayMSG|
                                   (CONS
                                     "      implemented: local function "
                                    (CONS |imp| NIL))))
                              ((AND (CONSP |imp|)
                                    (EQ (QCAR |imp|) 'XLAM))
                               (|sayMSG|
                                   (|concat|
                                     "      implemented: XLAM from "
                                    (|prefix2String| (CAR |sig|)))))
                              (t
                               (|sayMSG|
                                   (|concat|
                                     "      implemented: slot "
                                    |imp|  " from "
                                    (|prefix2String| (CAR |sig|))))))))))
             (|sayMSG|  " "))))))

;containsVars(t) ==
;  -- tests whether term t contains a * variable
;  atom t => isPatternVar t
;  containsVars1(t)

(defun |containsVars| (arg)
 (if (atom arg)
  (|isPatternVar| arg)
  (|containsVars1| arg)))

;containsVars1(t) ==
;  -- recursive version, which works on a list
;  [t1,:t2]:= t
;  atom t1 =>
;    isPatternVar t1 or
;      atom t2 => isPatternVar t2
;      containsVars1(t2)
;  containsVars1(t1) or
;    atom t2 => isPatternVar t2
;    containsVars1(t2)

(defun |containsVars1| (arg)
 (let ((t1 (car arg)) (t2 (cdr arg)))
  (if (atom t1)
     (or (|isPatternVar| t1)
         (if (atom t2) (|isPatternVar| t2) (|containsVars1| t2)))
     (or (|containsVars1| t1)
         (if (atom t2)  (|isPatternVar| t2) (|containsVars1| t2))))))

;getSymbolType var ==
;-- var is a pattern variable
;  p:= ASSQ(var,$SymbolType) => CDR p
;  t:= '(Polynomial (Integer))
;  $SymbolType:= CONS(CONS(var,t),$SymbolType)
;  t

(defun |getSymbolType| (var)
 (let (p tmp)
 (declare (special |$SymbolType|))
  (if (setq p (assq var |$SymbolType|))
   (cdr p)
   (progn
    (setq tmp '(|Polynomial| (|Integer|)))
    (setq |$SymbolType| (cons (cons var tmp) |$SymbolType|))
    tmp))))

;isEqualOrSubDomain(d1,d2) ==
;  -- last 2 parts are for tagged unions (hack for now, RSS)
;  (d1=d2) or isSubDomain(d1,d2) or
;    (atom(d1) and ((d2 is ['Variable,=d1]) or (d2 is [=d1])))
;     or (atom(d2) and ((d1 is ['Variable,=d2]) or (d1 is [=d2])))

(DEFUN |isEqualOrSubDomain| (|d1| |d2|)
  (PROG (|ISTMP#1|)
    (RETURN
      (OR (BOOT-EQUAL |d1| |d2|) (|isSubDomain| |d1| |d2|)
          (AND (ATOM |d1|)
               (OR (AND (CONSP |d2|) (EQ (QCAR |d2|) '|Variable|)
                        (PROGN
                          (setq |ISTMP#1| (QCDR |d2|))
                          (AND (CONSP |ISTMP#1|)
                               (EQ (QCDR |ISTMP#1|) NIL)
                               (EQUAL (QCAR |ISTMP#1|) |d1|))))
                   (AND (CONSP |d2|) (EQ (QCDR |d2|) NIL)
                        (EQUAL (QCAR |d2|) |d1|))))
          (AND (ATOM |d2|)
               (OR (AND (CONSP |d1|) (EQ (QCAR |d1|) '|Variable|)
                        (PROGN
                          (setq |ISTMP#1| (QCDR |d1|))
                          (AND (CONSP |ISTMP#1|)
                               (EQ (QCDR |ISTMP#1|) NIL)
                               (EQUAL (QCAR |ISTMP#1|) |d2|))))
                   (AND (CONSP |d1|) (EQ (QCDR |d1|) NIL)
                        (EQUAL (QCAR |d1|) |d2|))))))))

;defaultTypeForCategory(cat, SL) ==
;  -- this function returns a domain belonging to cat
;  -- note that it is important to note that in some contexts one
;  -- might not want to use this result. For example, evalMmCat1
;  -- calls this and should possibly fail in some cases.
;  cat := subCopy(cat, SL)
;  c := CAR cat
;  d := GETDATABASE(c, 'DEFAULTDOMAIN)
;  d => [d, :CDR cat]
;  cat is [c] =>
;    c = 'Field => $RationalNumber
;    c in '(Ring IntegralDomain EuclideanDomain GcdDomain
;      OrderedRing DifferentialRing) => '(Integer)
;    c = 'OrderedSet => $Symbol
;    c = 'FloatingPointSystem => '(Float)
;    NIL
;  cat is [c,p1] =>
;    c = 'FiniteLinearAggregate => ['Vector, p1]
;    c = 'VectorCategory => ['Vector, p1]
;    c = 'SetAggregate => ['Set, p1]
;    c = 'SegmentCategory => ['Segment, p1]
;    NIL
;  cat is [c,p1,p2] =>
;    NIL
;  cat is [c,p1,p2,p3] =>
;    cat is ['MatrixCategory, d, ['Vector, =d], ['Vector, =d]] =>
;      ['Matrix, d]
;    NIL
;  NIL

(DEFUN |defaultTypeForCategory| (|cat| SL)
  (PROG (|c| |p1| |p2| |p3| |ISTMP#1| |d| |ISTMP#2| |ISTMP#3| |ISTMP#4|
             |ISTMP#5| |ISTMP#6| |ISTMP#7|)
  (declare (special |$Symbol| |$RationalNumber|))
    (RETURN
      (PROGN
        (setq |cat| (|subCopy| |cat| SL))
        (setq |c| (CAR |cat|))
        (setq |d| (GETDATABASE |c| 'DEFAULTDOMAIN))
        (COND
          (|d| (CONS |d| (CDR |cat|)))
          ((AND (CONSP |cat|) (EQ (QCDR |cat|) NIL)
                (PROGN (setq |c| (QCAR |cat|)) t))
           (COND
             ((BOOT-EQUAL |c| '|Field|) |$RationalNumber|)
             ((|member| |c|
                  '(|Ring| |IntegralDomain| |EuclideanDomain|
                           |GcdDomain| |OrderedRing|
                           |DifferentialRing|))
              '(|Integer|))
             ((BOOT-EQUAL |c| '|OrderedSet|) |$Symbol|)
             ((BOOT-EQUAL |c| '|FloatingPointSystem|) '(|Float|))
             (t NIL)))
          ((AND (CONSP |cat|)
                (PROGN
                  (setq |c| (QCAR |cat|))
                  (setq |ISTMP#1| (QCDR |cat|))
                  (AND (CONSP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)
                       (PROGN (setq |p1| (QCAR |ISTMP#1|)) t))))
           (COND
             ((BOOT-EQUAL |c| '|FiniteLinearAggregate|)
              (CONS '|Vector| (CONS |p1| NIL)))
             ((BOOT-EQUAL |c| '|VectorCategory|)
              (CONS '|Vector| (CONS |p1| NIL)))
             ((BOOT-EQUAL |c| '|SetAggregate|)
              (CONS '|Set| (CONS |p1| NIL)))
             ((BOOT-EQUAL |c| '|SegmentCategory|)
              (CONS '|Segment| (CONS |p1| NIL)))
             (t NIL)))
          ((AND (CONSP |cat|)
                (PROGN
                  (setq |c| (QCAR |cat|))
                  (setq |ISTMP#1| (QCDR |cat|))
                  (AND (CONSP |ISTMP#1|)
                       (PROGN
                         (setq |p1| (QCAR |ISTMP#1|))
                         (setq |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (CONSP |ISTMP#2|)
                              (EQ (QCDR |ISTMP#2|) NIL)
                              (PROGN
                                (setq |p2| (QCAR |ISTMP#2|))
                                t))))))
           NIL)
          ((AND (CONSP |cat|)
                (PROGN
                  (setq |c| (QCAR |cat|))
                  (setq |ISTMP#1| (QCDR |cat|))
                  (AND (CONSP |ISTMP#1|)
                       (PROGN
                         (setq |p1| (QCAR |ISTMP#1|))
                         (setq |ISTMP#2| (QCDR |ISTMP#1|))
                         (AND (CONSP |ISTMP#2|)
                              (PROGN
                                (setq |p2| (QCAR |ISTMP#2|))
                                (setq |ISTMP#3| (QCDR |ISTMP#2|))
                                (AND (CONSP |ISTMP#3|)
                                     (EQ (QCDR |ISTMP#3|) NIL)
                                     (PROGN
                                       (setq |p3| (QCAR |ISTMP#3|))
                                       t))))))))
           (COND
             ((AND (CONSP |cat|) (EQ (QCAR |cat|) '|MatrixCategory|)
                   (PROGN
                     (setq |ISTMP#1| (QCDR |cat|))
                     (AND (CONSP |ISTMP#1|)
                          (PROGN
                            (setq |d| (QCAR |ISTMP#1|))
                            (setq |ISTMP#2| (QCDR |ISTMP#1|))
                            (AND (CONSP |ISTMP#2|)
                                 (PROGN
                                   (setq |ISTMP#3| (QCAR |ISTMP#2|))
                                   (AND (CONSP |ISTMP#3|)
                                    (EQ (QCAR |ISTMP#3|) '|Vector|)
                                    (PROGN
                                      (setq |ISTMP#4|
                                       (QCDR |ISTMP#3|))
                                      (AND (CONSP |ISTMP#4|)
                                       (EQ (QCDR |ISTMP#4|) NIL)
                                       (EQUAL (QCAR |ISTMP#4|) |d|)))))
                                 (PROGN
                                   (setq |ISTMP#5| (QCDR |ISTMP#2|))
                                   (AND (CONSP |ISTMP#5|)
                                    (EQ (QCDR |ISTMP#5|) NIL)
                                    (PROGN
                                      (setq |ISTMP#6|
                                       (QCAR |ISTMP#5|))
                                      (AND (CONSP |ISTMP#6|)
                                       (EQ (QCAR |ISTMP#6|) '|Vector|)
                                       (PROGN
                                         (setq |ISTMP#7|
                                          (QCDR |ISTMP#6|))
                                         (AND (CONSP |ISTMP#7|)
                                          (EQ (QCDR |ISTMP#7|) NIL)
                                        (EQUAL (QCAR |ISTMP#7|) |d|))))))))))))
              (CONS '|Matrix| (CONS |d| NIL)))
             (t NIL)))
          (t NIL))))))

\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
