\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp i-output.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject

\section{CHARYBDIS by Jonathan K. Millen}
\subsection{Introduction}

From Millen\cite{Mill68} we paraphrase:

CHARYBDIS (from CHARacter-composed sYmBolic DISplay) is a LISP program
to display mathematical expressions on typewriter-like devices such as
line printers, teletypes, and scopes which display lines of
characters, as well as typewriters.

There are two features of LISP which are essential to this
program. First is the fact that the data expressions in LISP are
lists, i.e., tree structures composed ultimately of atomic symbols,
which include variables, numbers, and in particular,
characters. Second, but at least as important, is the power of
recursion.

The kind of expression accepted as an input by CHARYBDIS is a list
structure in a prefix notation which serves as the common internal
form. The output of CHARYBDIS, that is, the display of a mathematical
expression, is described in the next section. Later we discuss the
structure of the program, emphasizing the way it can be expanded to
include more mathematical displays, or even arbitrary displays which
either are not too large or are amenable to recursive techniques.

\subsection{Descriptoin of the Displays}

CHARYBDIS assumes a character set containing the upper case alphabet,
the decimal digits, and these additional symbols:
$+ - = / . , : ( ) *$. We notice immediately that the capital sigma
representing summation, and other common mathematical operators, are
missing; but even more basic problems exist. What about the horizontal
bar in a quotient? Where are exponents and subscripts, and tall
parentheses (to match the size of the parenthesized expression)?
CHARYBDIS' solution to some of these problems are illustrated
shortly. With a little reflection, it becomes evident that there is
really only one possible way to handle most of these initial
problems. The resulting displays are somewhat alien at first glance,
but they are readable and easy to get used to.

In MATHLAB\cite{ENGE65}, 
which reads expressions in a FORTRAN-like form, but prints
them out using CHARYBDIS. A complete explanation of the commands and
replies shown would be too lengthy to include here, but the
conversation is not hard to follow, even without the explanation.
\begin{verbatim}
  MATHLAB NIL

  V : 1/(X*(X**2 + B*X + 1)) $

           1
   -----------------
       2
    X(X  + B*X + 1)

   INTEGRATE('V,X) $

   IS THE EXPRESSION

    2
   B  - 4

   TO BE CONSIDERED POSITIVE NEGATIVE OR ZERO

  NEGATIVE


                 - 1      2
       LOG(X) + -----LOG(X  + B*X +1)
                  2
    +

                 B                  2X + B
       - ----------------ARCTAN(----------------)
                  2                      2
          SQRT(- B  + 4)         SQRT(- B  + 4)
\end{verbatim}

Tall parentheses can be simulated as follows:
\begin{verbatim}
            (                                       1/2)
         T  (     (                T G  + T   G    )   )
          0 (     (           2     1 1    TAU TAU )   )
   2R   ----(G  + ((G  + G   )  + -----------------)   )
     EQ  T  ( 1   (( 1    TAU)           R         )   )
          S (     (                       EQ       )   )
\end{verbatim}
The same expression can also be displayed with the parentheses always
single. The CHARYBDIS user has his choice, made known to the program
by setting a switch (the global variable TALLPAR).

Expressions too long for a single line are a problem for any display
program using a device with a fixed line length, in fact, they are a
problem even for textbooks. CHARYBDIS splits such expressions over
several lines in an unconventional way, for example:
\begin{verbatim}

                                           B
                                        - ----X
                                           2A
              (Y(0)A + (B + C)Y(0) - 1)E
           *
                   1               2
              COS(----SQRT(4C*A - B )X)
                   2A
         +
            X
           E
       *
                      2
         SQRT(4C*A - B )
     +
                   2
            2DY(0)A  + (B*Y(0) + (2B + 2C)DY(0) - 2)A
         +
              2
            (B  + C*B)Y(0) - B
       *
             B
          - ----X
             2A       1               2
         E       SIN(----SQRT(4C*A - B )X)
                      2A
   /

                             2
     (A + B + C)SQRT(4C*A - B )
\end{verbatim}
The expression shown is the solution, as computed by MATHLAB, of the
differential equation $Ay^{\prime\prime}+By^{\prime}+Cy=e^x$.

The algorithm for splitting the expression is as follows. If the
expression is a quotient, exponential, or equation, the two
subexpressions are displayed, indented by three spaces above and below
the connective: $/$, $**$, or $=$, respectively. If the expression is
a sum or product, it is split into as many parts as necessary, and the
parts displayed one after another, indented three spaces, separated by
the main connective $+$ or $*$ on intervening lines.

In all other cases the operator name and the subexpressions are
displayed on separate lines. Future development of the program should
include more sophisticated splitting of some expressions currently in
the ``in all other cases'' category.

If any of the parts which are to be displayed is still too long, the
process is applied recursively to split the part. The net effect is
that the expression is spread out into a tree-like structure, with its
root at the left. Looking again at the example, and reading from the
$/$ at the left, we see that the expression is a quotient whose
denominator is $(a+b+c)(4ca-b^2)^{\frac{1}{2}}$, and whose numerator
is the sum of two products, etc.

Let us return to the less immediate but more vexing difficulty of
displaying expressions requiring special characters, such as the sigma
of extended summation. A natural approach is to draw the symbol using
characters like periods or asterisks. For example:
\begin{verbatim}
   CHARYBDIS((EQUAL(EXPT(SUB C N)2)(PLUS(EXT(SIGMA)K ) N I N
   (QUOTIENT(EXPT(SUB A X)2)(EXPT(SUB SIGMA X)2)))(EXT
   (SIGMA)X(PLUS N 1)(QUOTIENT(TIMES 3 N)2)(QUOTIENT(EXPT
   (SUB B K)2)(EXPT(SUB SIGMA K)2))))) 1 60)

                   3N
                  ----
         N         2       2         2
         * * *   A        * * *    B
     2    *       K        *        K
   C   =   *  --------- +   *    ---------
    N     *          2     *             2
         * * * SIGMA     * * *    SIGMA
         K=1        K    K=N + 1       K
\end{verbatim}

Heated arguments occur over just how the symbols ought to be
drawn. Even in the case of the sigma, which is pretty straightforward,
it has been suggested that another parameter be included in order to
adjust its height. Here we are venturing into regions where the
original author of the display program is not the proper
arbiter. Provisions must, and do exist for the `system programmer'
(i.e. the LISP-acquainted person whose concern is the maintenance and
expansion of the symbolic manipulation program) to make and
incorporate his own decisions concerning the appearance of displays
for new kinds of symbolic expressions, as they are added to the
vocabulary of his system.

The class of displays which CHARYBDIS is capable of handling is
broader than the term ``mathematical expressions'' and the preceding
examples might lead us to believe. By way of illustration here is a
display of a more general nature produced by CHARYBDIS.
\begin{verbatim}
   CHARYBDIS((TREE S(TREE NP(TREE GP(ART THE)(G WRITING))(TREE PP
   (P OF)(TREE NP(N FUNCTIONS)(TREE IP(TREE I TO(VT HANDLE))(TREE
   NP(ADJ RARE)(N CASES))))))(TREE VP(TREE PI(VA CAN)(VL BE))(PA
   POSTPONED))) I 60)

                         .ART(THE)
                     .GP.
                    .    .G(WRITING)
                .NP.
               .    .    .P(OF)
              .      .PP.
             .           .    .N(FUNCTIONS)
            .             .NP.
           .                  .          .TO
          .                    .      .I.
         .                      .    .   .VT(HANDLE)
        .                        .IP.
       .                             .    .ADJ(RARE)
      .                               .NP.
     .                                    .N(CASES)
   S.
     .           .VA(CAN)
      .      .PI.
       .    .    .VL(BE)
        .VP.
            .PA(POSTPONED)
\end{verbatim}

\subsection{Program Structure}

This section contains a discussion of the global structure of the
program, a summary of its conceptual basis, and an example of the
addition of a kind of display to CHARYBDIS. Woven through it is the
story of how additions (or changes) are made, culminating in the
example at the end.

There are two steps to the display of an expression. First, a list is
built up of the atomic symbols making up the display, together with
the Cartesian coordinates of their initial characters. Then this list,
the {\sl display list}, is handed line by line to SCYLLA, a function
which writes it out onto the device referenced by the system function
PRIN1.

If the expression is wider than the line length permits, then not one,
but a succession of display lists is created and written.

CHARYBDIS, the main function, contains the algorithm for splitting
expressions over several lines and the loop which sends the
{\sl display list} to SCYLLA. CHARYBDIS enters the function APP to
obtain the display list.

APP, which is the doorway to the rest of the program, has no other
responsibility than the creation of a display list. APP is one of the
four functions in the `executive module,' which include APP, WIDTH,
SUPERSPAN, and SUBSPAN.

Every module is a set of four functions, just like the executive
module. Each `individual module' handles one kind of expression:
product, quotient, etc. In fact, the `executive module' is nothing
more than a multiposition switch, which handles an arbitrary
expression by determining its type (from the prefix) and calling upon
the appropriate individual module (except for the trivial case of
atomic symbols, which it takes care of itself).

If no other individual module applies, an ``otherwise'' module is
used; it puts the expression in conventional functional form, the
prefix being the function name, SIN, LOG, SQRT, and other familiar
functions are treated this way, as well as those which are truly
unexpected. It is worth noting that the display program needs no other
individual module than this one to work. In fact, LISP programmers
will recognize the stripped-down program as a ``pretty-print''
function for list structures

We present here a conceptual framework of which CHARYBDIS is the
implementation, for the description of a display. The step from a
description of a display in these terms to the required LISP functions
is, by design, a short one.

The framework comprises the definitions of four terms:
\begin{enumerate}
\item The {\sl origin} is a distinguished location within a display,
whose coordinates are restricted as follows. The abscissa of the
origin is that of the leftmost character in the display, and the
ordinate of the origin is neither greater than that of the highest
character in the display nor less than that of the lowest. The choice
of ordinate is otherwise arbitrary.
\item The {\sl width} of a display is the number of columns from the
extreme left of the display (the origin, in fact) to its extreme
right.
\item The {\sl superspan} of a display is the number of lines it
extends above the origin
\item The {\sl subspan} of a display is the number of lines it extends
below the origin
\end{enumerate}
\begin{verbatim}
             |              2
   superspan |           - X
      (5)    |          E
             | ALPHA + -------
             |           PI
   origin    +-----------------
             |      N + 1
   subspan   |    MU
     (2)
             +-----------------+
                 width (17)
\end{verbatim}

Most mathematical displays have in common the property that a certain
natural choice for the ordinate of the origin, consistently made,
simplifies their descriptions considerably. The natural ordinate for
the origin of a sum, for example, is that of (all) its plus signs; for
a quotient, that of the horizontal bar.

The four functions which constitute an individual module for handling
expressions of a particular type are:
\begin{enumerate}
\item a function whose four arguments are an expression, the two
coordinates $x$ and $y$ of the desired origin, and a partial display
list; and whose value is the new display list obtained from the one
given by appending to it the atomic symbols (with their coordinates)
making up the display of the input expression (This function does not
work for APP, which derives its name from the fact that it appends to
the display list)
\item a function of one argument whose value is the width of its
argument
\item a function of one argument whose value is its superspan
\item a function of one argument whose value is its subspan.
\end{enumerate}

\noindent
{\bf Example}

Let us suppose that we wish to specify the display of a sum of two
terms, whose input expression is: (SUM term$_1$ term$_2$). The sum is
made up out of two variable subexpressions -- the terms -- and a plus
sign. The plus sign is a character, {\sl a fortiori} an atom, and may
be viewed as just another subexpression. Our job is to specify the
positions of these three subexpressions relative to one another, and
place the whole at some given location. Restated in our conceptual
framework, the task is as follows: given the coordinates $(x,y)$ of
the origin of the whole expression, specify the coordinates of the
origins of the subexpressions, in terms of the attributes of
expressions defined above.

Let us place the origin of the first term at $(x,y)$, the plus sign at
$(x+w,y)$ where $w$ is the width of the first term, and the second
term at $(x+w+1,y)$.

Having specified the display abstractly, we can now write the four
LISP functions to handle the jobs of APP. WIDTH, SUPERSPAN, and
SUBSPAN. Note the parallel between the definition of the APP and the
description of the display given above.
\begin{verbatim}
   appsum[u; x; y; d] = prog[[newd; w];
                         w := width[cadr[u]];
                         newd := app[cadr[u]; x; y; d];
                         newd := app(pluss; x+w; y; newd];
                         newd := app[caddr[y]; x+w+1; y; newd];
                         return [newd]]
   widthsum[u] = width[cadr[u]] + 1 + width[caddr[u]]
   superspansum[u] = max[superspan[cadr[u]]; superspan[caddr[u]]]
   subspansum[u] = max[subspan[cadr[u]]; subspan[caddr[u]]]
\end{verbatim}

In this example, the number of subexpressions was known in
advance. When this is not the case, as in the actual version of this
kind of expression (with prefix PLUS) in CHARYBDIS, the functions in
the individual module contain loops or are more highly recursive and
fragmented. In any case, the complexity of the functions only reflects
the complexity of the display itself.

\begin{chunk}{*}
(IN-PACKAGE "BOOT" )

(defun charybdis (u start linelength)
  (cond
    ((and (eq (keyp u) 'equatnum) (null (cddr u)))
     (charybdis (cons 'paren (cons (elt u 1) nil)) start
         linelength))
    (t (charyTop u start linelength))))

;charyTop(u,start,linelength) ==
;  u is ['SC,:l] or u is [['SC,:.],:l] =>
;    for a in l repeat charyTop(a,start,linelength)
;    '" "
;  u is [['CONCATB,:.],:m,[['SC,:.],:l]] =>
;    charyTop(['CONCATB,:m],start,linelength)
;    charyTop(['SC,:l],start+2,linelength-2)
;  u is ['CENTER,a] =>
;    b := charyTopWidth a
;    (w := WIDTH(b)) > linelength-start => charyTop(a,start,linelength)
;    charyTop(b,(linelength-start-w)/2,linelength)
;  v := charyTopWidth u
;  EQ(keyp u,'ELSE) => charyElse(u,v,start,linelength)
;  WIDTH(v) > linelength => charyTrouble(u,v,start,linelength)
;  d := APP(v,start,0,nil)
;  n := superspan v
;  m := - subspan v
;-->
;  $testOutputLineFlag =>
;    $testOutputLineList :=
;      [:ASSOCRIGHT SORTBY('CAR,d),:$testOutputLineList]
;  until n < m repeat
;    scylla(n,d)
;    n := n - 1
;  '" "

(defun charyTop (u start linelength)
  (prog (tmp1 tmp2 tmp3 tmp4 tmp5 |l| a b w v d m n)
    (declare (special |$testOutputLineList| |$testOutputLineFlag|))
    (return
      (seq (cond
             ((or (and (consp u) (eq (qcar u) 'SC)
                       (progn (setq |l| (qcdr u)) t))
                  (and (consp u)
                       (progn
                         (setq tmp1 (qcar u))
                         (and (consp tmp1)
                              (eq (qcar tmp1) 'SC)))
                       (progn (setq |l| (qcdr u)) t)))
              (do ((G169131 |l| (CDR G169131)) (a nil))
                  ((or (atom G169131)
                       (progn (setq a (car G169131)) nil))
                   nil)
                (seq (exit (charyTop a start linelength))))
              " ")
             ((and (consp u)
                   (progn
                     (setq tmp1 (qcar u))
                     (and (consp tmp1)
                          (eq (qcar tmp1) 'CONCATB)))
                   (progn
                     (setq tmp2 (qcdr u))
                     (and (consp tmp2)
                          (progn
                            (setq tmp3 (reverse tmp2))
                            t)
                          (consp tmp3)
                          (progn
                            (setq tmp4 (qcar tmp3))
                            (and (consp tmp4)
                                 (progn
                                   (setq tmp5 (qcar tmp4))
                                   (and (consp tmp5)
                                    (eq (qcar tmp5) 'SC)))
                                 (progn
                                   (setq |l| (qcdr tmp4))
                                   t)))
                          (progn (setq m (qcdr tmp3)) t)
                          (progn (setq m (nreverse m)) t))))
              (charyTop (cons 'CONCATB m) start linelength)
              (charyTop (cons 'SC |l|) (+ start 2)
                          (- linelength 2)))
             ((and (consp u) (eq (qcar u) 'CENTER)
                   (progn
                     (setq tmp1 (qcdr u))
                     (and (consp tmp1) (eq (qcdr tmp1) nil)
                          (progn (setq a (qcar tmp1)) t))))
              (setq b (charyTopWidth a))
              (cond
                ((> (setq w (width b))
                    (- linelength start))
                 (charyTop a start linelength))
                (t
                 (charyTop b
                     (QUOTIENT
                         (-
                             (- linelength start) w)
                         2)
                     linelength))))
             (t (setq v (charyTopWidth u))
              (cond
                ((eq (keyp u) 'ELSE)
                 (charyElse u v start linelength))
                ((> (width v) linelength)
                 (charyTrouble u v start linelength))
                (t (setq d (APP v start 0 nil))
                 (setq n (|superspan| v))
                 (setq m (- (|subspan| v)))
                 (cond
                   (|$testOutputLineFlag|
                       (setq |$testOutputLineList|
                                (APPEND (ASSOCRIGHT (SORTBY 'CAR d))
                                        |$testOutputLineList|)))
                   (t
                    (do ((G169142 NIL (> m n))) (G169142 nil)
                      (seq (exit (progn
                                   (scylla n d)
                                   (setq n (- n 1))))))
                    " "))))))))))

(defun sayALGEBRA (x) "Prints on Algebra output stream."
  (when x (sayBrightly1 x |$algebraOutputStream|)))
 
(defun sayMSGNT (x)
  (when x (sayBrightlyNT1 x |$algebraOutputStream|)))
 
(defvar |$collectOutput| nil) 

;specialChar(symbol) ==
;  null (code := IFCDR ASSQ(symbol,$specialCharacterAlist)) => '"?"
;  ELT($specialCharacters,code)

(defun |rbrkSch| () (pname (|specialChar| '|rbrk|)))

(defun |lbrkSch| () (pname (|specialChar| '|lbrk|)))

(defun |quadSch| () (pname (|specialChar| '|quad|)))

(defun |isBinaryInfix| (x)
  (|member| x '(= + - * / ** ^ "=" "+" "-" "*" "/" "**" "^")))

(defun |stringApp| (g1 x y d)
  (declare (special |$DoubleQuote|))
  (appChar
    (strconc |$DoubleQuote| (|atom2String| (cadr g1)) |$DoubleQuote|)
             x y d))

(defun |stringWidth| (u)
 (if (and (consp u) (consp (cdr u)) (eq (cddr u) nil))
   (+ 2 (|#| (cadr u)))
   (THROW '|outputFailure| '|outputFailure|)))

;obj2String o ==
;  atom o =>
;    STRINGP o => o
;    o = " " => '" "
;    o = ")" => '")"
;    o = "(" => '"("
;    princ-to-string o
;  APPLY('STRCONC,[obj2String o' for o' in o])

(defun obj2String (arg1)
 (let (result)
   (cond
     ((atom arg1)
       (cond
         ((stringp arg1) arg1)
         ((eq arg1 '| |) " ")
         ((eq arg1 '|)|) ")")
         ((eq arg1 '|(|) "(")
         (t (princ-to-string arg1))))
     (t
       (apply 'concat
         (dolist (tmp1 arg1 (nreverse result))
           (push (obj2String tmp1) result)))))))

;APP(u,x,y,d) ==
;  atom u => appChar(atom2String u,x,y,d)
;  u is [[op,:.],a] and (s:= GET(op,'PREFIXOP)) =>
;    GET(op,'isSuffix) => appChar(s,x+WIDTH a,y,APP(a,x,y,d))
;    APP(a,x+#s,y,appChar(s,x,y,d))
;  u is [[id,:.],:.] =>
;    fn := GET(id,'APP) => FUNCALL(fn,u,x,y,d)
;    not NUMBERP id and (d':= appInfix(u,x,y,d))=> d'
;    appelse(u,x,y,d)
;  appelse(u,x,y,d)

(defun APP (u x y d)
  (prog (|op| tmp2 a |s| tmp1 |id| |fn| |d'|)
    (return
      (cond
        ((atom u) (appChar (|atom2String| u) x y d))
        ((and (consp u)
              (progn
                (setq tmp1 (qcar u))
                (and (consp tmp1)
                     (progn (setq |op| (qcar tmp1)) t)))
              (progn
                (setq tmp2 (qcdr u))
                (and (consp tmp2) (eq (qcdr tmp2) nil)
                     (progn (setq a (qcar tmp2)) t)))
              (setq |s| (GETL |op| 'PREFIXOP)))
         (cond
           ((GETL |op| '|isSuffix|)
            (appChar |s| (+ x (width a)) y
                (APP a x y d)))
           (t
            (APP a (+ x (|#| |s|)) y
                 (appChar |s| x y d)))))
        ((and (consp u)
              (progn
                (setq tmp1 (qcar u))
                (and (consp tmp1)
                     (progn (setq |id| (qcar tmp1)) t))))
         (cond
           ((setq |fn| (GETL |id| 'APP))
            (FUNCALL |fn| u x y d))
           ((and (NULL (NUMBERP |id|))
                 (setq |d'| (appInfix u x y d)))
            |d'|)
           (t (appelse u x y d))))
        (t (appelse u x y d))))))

(defun atom2string (x)
  "Give me the string which would be printed out to denote an atom."
  (cond ((atom x) (symbol-name x))
        ((stringp x) x)
        ((write-to-string x))))

;;; WARNING redefined in vmlisp
(defun |atom2String| (x)
  (cond
    ((identp x) (pname x))
    ((stringp x) x)
    (t (stringer x))))

\end{chunk}
\begin{verbatim}
General convention in the ``app...'' functions:
Added from an attempt to fix bugs by JHD: 2 Aug 89
The arguments are:
\begin{itemize}
\item what has to be printed
\item - x - is the horizontal distance along the page at which to start
\item - y - is some vertical hacking control
\item - d - is the "layout" so far
\end{itemize}
these functions return an updated ``layout so far'' in general
\end{verbatim}
\begin{chunk}{*}
;appChar(string,x,y,d) ==
;  if CHARP string then string := PNAME string
;  line:= LASSOC(y,d) =>
;    if MAXINDEX string = 1 and char(string.0) = "%" then
;      string.1="b" =>
;        bumpDeltaIfTrue:= true
;        string.0:= EBCDIC 29
;        string.1:= EBCDIC 200
;      string.1="d" =>
;        bumpDeltaIfTrue:= true
;        string.0:= EBCDIC 29
;        string.1:= EBCDIC 65
;    shiftedX:= (y=0 => x+$highlightDelta; x)
;      --shift x for brightening characters -- presently only if y=0
;    RPLACSTR(line,shiftedX,n:=#string,string,0,n)
;    if bumpDeltaIfTrue=true then $highlightDelta:= $highlightDelta+1
;    d
;  appChar(string,x,y,nconc(d,[[y,:GETFULLSTR(10+$LINELENGTH+$MARGIN," ")]]))

(defun appChar (|string| x y d)
  (prog (|line| |bumpDeltaIfTrue| |shiftedX| n)
    (declare (special $LINELENGTH $MARGIN |$highlightDelta|))
    (return
      (progn
        (cond ((CHARP |string|) (setq |string| (PNAME |string|))))
        (cond
          ((setq |line| (LASSOC y d))
           (cond
             ((and (EQL (MAXINDEX |string|) 1)
                   (char= (character (ELT |string| 0)) #\%))
              (cond
                ((eq (elt |string| 1) 'b)
                 (setq |bumpDeltaIfTrue| t)
                 (setelt |string| 0 (EBCDIC 29))
                 (setelt |string| 1 (EBCDIC 200)))
                ((eq (elt |string| 1) 'd)
                 (setq |bumpDeltaIfTrue| t)
                 (setelt |string| 0 (EBCDIC 29))
                 (setelt |string| 1 (EBCDIC 65))))))
           (setq |shiftedX|
                    (cond
                      ((EQL y 0) (+ x |$highlightDelta|))
                      (t x)))
           (RPLACSTR |line| |shiftedX| (setq n (|#| |string|))
               |string| 0 n)
           (when  |bumpDeltaIfTrue|
              (setq |$highlightDelta| (+ |$highlightDelta| 1)))
           d)
          (t
           (appChar |string| x y
               (NCONC d
                      (cons (cons y
                                  (make-full-cvec
                                      (+ (+ 10 $LINELENGTH)
                                       $MARGIN)
                                      '| |))
                            nil)))))))))

;print(x,domain) ==
;  dom:= devaluate domain
;  $InteractiveMode: local:= true
;  $dontDisplayEquatnum: local:= true
;  output(x,dom)

(defun |print| (x |domain|)
  (prog (|$InteractiveMode| |$dontDisplayEquatnum| |dom|)
    (declare (special |$InteractiveMode| |$dontDisplayEquatnum|))
    (return
      (progn
        (setq |dom| (|devaluate| |domain|))
        (setq |$InteractiveMode| t)
        (setq |$dontDisplayEquatnum| t)
        (|output| x |dom|)))))

;mathprintWithNumber x ==
;  x:= outputTran x
;  maprin
;    $IOindex => ['EQUATNUM,$IOindex,x]
;    x

(defun mathprintWithNumber (x)
  (declare (special |$IOindex|))
  (progn
    (setq x (|outputTran| x))
    (maprin2 (cond
                (|$IOindex|
                    (cons 'EQUATNUM (cons |$IOindex| (cons x nil))))
                (t x)))))

(defun |mathprint| (x)
  (progn
    (setq x (|outputTran| x))
    (maprin2 x)))

;sayMath u ==
;  for x in u repeat acc:= concat(acc,linearFormatName x)
;  sayALGEBRA acc

(defun |sayMath| (u)
  (prog (|acc|)
    (return
      (seq (progn
             (do ((G166189 u (CDR G166189)) (x nil))
                 ((or (atom G166189)
                      (progn (setq x (car G166189)) nil))
                  nil)
               (seq (exit (setq |acc|
                                   (|concat| |acc|
                                    (|linearFormatName| x))))))
             (sayALGEBRA |acc|))))))

;--% Output transformations
;outputTran x ==
;  x in '("failed" "nil" "prime" "sqfr" "irred") =>
;    STRCONC('"_"",x,'"_"")
;  STRINGP x => x
;  VECP x =>
;    outputTran ['BRACKET,['AGGLST,:[x.i for i in 0..MAXINDEX x]]]
;  NUMBERP x =>
;    MINUSP x => ["-",MINUS x]
;    x
;  atom x =>
;    x=$EmptyMode => specialChar 'quad
;    x
;  x is [c,var,mode] and c in '(_pretend _: _:_: _@) =>
;    var := outputTran var
;    if CONSP var then var := ['PAREN,var]
;    ['CONCATB,var,c,obj2String prefix2String mode]
;  x is ['ADEF,vars,.,.,body] =>
;    vars :=
;        vars is [x] => x
;        ['Tuple,:vars]
;    outputTran ["+->", vars, body]
;  x is ['MATRIX,:m] => outputTranMatrix m
;  x is ['matrix,['construct,c]] and
;    c is ['COLLECT,:m,d] and d is ['construct,e] and e is ['COLLECT,:.] =>
;      outputTran ['COLLECT,:m,e]
;  x is ['LIST,:l] => outputTran ['BRACKET,['AGGLST,:l]]
;  x is ['MAP,:l] => outputMapTran l
;  x is ['brace, :l]    =>
;    ['BRACE,  ['AGGLST,:[outputTran y for y in l]]]
;  x is ['return,l] => ['return,outputTran l]
;  x is ['return,.,:l] => ['return,:outputTran l]
;  x is ['construct,:l] =>
;    ['BRACKET,['AGGLST,:[outputTran y for y in l]]]
;  x is [["$elt",domain,"float"], x, y, z] and (domain = $DoubleFloat or
;    domain is ['Float]) and INTEGERP x and INTEGERP y and INTEGERP z and
;        z > 0  and (float := getFunctionFromDomain("float",domain,[$Integer,$Integer,$PositiveInteger])) =>
;            f := SPADCALL(x,y,z,float)
;            o := coerceInteractive(mkObjWrap(f, domain), '(OutputForm))
;            objValUnwrap o
;  [op,:l]:= flattenOps x
;  --needed since "op" is string in some spad code
;  if STRINGP op then (op := INTERN op; x:= [op,:l])
;  op = 'LAMBDA_-CLOSURE => 'Closure
;  x is ['break,:.] => 'break
;  x is ['SEGMENT,a] =>
;    a' := outputTran a
;    if LISTP a' then a' := ['PAREN,a']
;    ['SEGMENT,a']
;  x is ['SEGMENT,a,b] =>
;    a' := outputTran a
;    b' := outputTran b
;    if LISTP a' then a' := ['PAREN,a']
;    if LISTP b' then b' := ['PAREN,b']
;    ['SEGMENT,a',b']
;  op is ["$elt",targ,fun] or not $InteractiveMode and op is ["elt",targ,fun] =>
;    -- l has the args
;    targ' := obj2String prefix2String targ
;    if 2 = #targ then targ' := ['PAREN,targ']
;    ['CONCAT,outputTran [fun,:l],'"$",targ']
;  x is ["$elt",targ,c] or not $InteractiveMode and x is ["elt",targ,c] =>
;    targ' := obj2String prefix2String targ
;    if 2 = #targ then targ' := ['PAREN,targ']
;    ['CONCAT,outputTran c,'"$",targ']
;  x is ["-",a,b] =>
;    a := outputTran a
;    b := outputTran b
;    INTEGERP b =>
;      b < 0 => ["+",a,-b]
;      ["+",a,["-",b]]
;    b is ["-",c] => ["+",a,c]
;    ["+",a,["-",b]]
;  -- next stuff translates exp(log(foo4)/foo3) into ROOT(foo4,foo3)
;  (x is ["**", ='"%e",foo1]) and (foo1 is [ ='"/",foo2, foo3]) and
;    INTEGERP(foo3) and (foo2 is ['log,foo4]) =>
;       foo3 = 2 => ['ROOT,outputTran foo4]
;       ['ROOT,outputTran foo4,outputTran foo3]
;  (x is ["**", ='"%e",foo1]) and (foo1 is [op',foo2, foo3]) and
;    (op' = '"*") and ((foo3 is ['log,foo4]) or (foo2 is ['log,foo4])) =>
;       foo3 is ['log,foo4] =>
;         ["**", outputTran foo4, outputTran foo2]
;       foo4 := CADR foo2
;       ["**", outputTran foo4, outputTran foo3]
;  op = 'IF       => outputTranIf x
;  op = 'COLLECT  => outputTranCollect x
;  op = 'REDUCE   => outputTranReduce x
;  op = 'REPEAT   => outputTranRepeat x
;  op = 'SEQ      => outputTranSEQ x
;  op in '(cons nconc) => outputConstructTran x
;  l:= [outputTran y for y in l]
;  op = "*" =>
;     l is [a] => outputTran a
;     l is [["-",a],:b] =>
;       -- now this is tricky because we've already outputTran the list
;       -- expect trouble when outputTran hits b again
;       -- some things object to being outputTran twice ,e.g.matrices
;       -- same thing a bit lower down for "/"
;       a=1 => outputTran ["-",[op,:b]]
;       outputTran ["-",[op,a,:b]]
;     [op,:"append"/[(ss is ["*",:ll] => ll; [ss]) for ss in l]]
;  op = "+" =>
;     l is [a] => outputTran a
;     [op,:"append"/[(ss is ["+",:ll] => ll; [ss]) for ss in l]]
;  op = "/" =>
;    $fractionDisplayType = 'horizontal =>
;       op := 'SLASH
;       l is [a, b] =>
;         a:=
;           ATOM(a) => a
;           ['PAREN, a]
;         b:=
;           ATOM(b) => b
;           ['PAREN, b]
;         [outputTran op, a, b]
;       BREAK()
;    op := 'OVER
;    l is [["-",a],:b] => outputTran ["-",[op,a,:b]]
;    [outputTran op,:l]
;  op="|" and l is [["Tuple",:u],pred] =>
;    ['PAREN,["|",['AGGLST,:l],pred]]
;  op='Tuple  => ['PAREN,['AGGLST,:l]]
;  op='LISTOF => ['AGGLST,:l]
;  IDENTP op and ^(op in '(_* _*_*) ) and char("*") = (PNAME op).0 =>
;    mkSuperSub(op,l)
;  [outputTran op,:l]

(defun |outputTran| (x)
  (prog (|mode| |var| |body| |vars| d m |e| |domain| tmp3
                tmp4 tmp5 y tmp6 |z| |float| |f| |o|
                |LETTMP#1| |a'| |b'| |fun| |targ| |targ'| |c| |foo1|
                |op'| |foo2| |foo3| |foo4| |l| |ll| |op| a b
                tmp1 u tmp2 |pred|)
    (declare (special |$fractionDisplayType| |$InteractiveMode|
                      |$Integer| |$PositiveInteger| |$DoubleFloat|
                      |$EmptyMode|))
    (return
      (seq (cond
             ((|member| x '("failed" "nil" "prime" "sqfr" "irred"))
              (STRCONC "\"" x "\""))
             ((STRINGP x) x)
             ((VECP x)
              (|outputTran|
                  (cons 'BRACKET
                        (cons (cons 'AGGLST
                                    (prog (G166608)
                                      (setq G166608 nil)
                                      (return
                                        (DO
                                         ((G166613 (MAXINDEX x))
                                          (|i| 0 (QSADD1 |i|)))
                                         ((QSGREATERP |i| G166613)
                                          (NREVERSE0 G166608))
                                          (SEQ
                                           (EXIT
                                            (setq G166608
                                             (cons (elt x |i|)
                                              G166608))))))))
                              nil))))
             ((NUMBERP x)
              (cond
                ((MINUSP x) (cons '- (cons (MINUS x) nil)))
                (t x)))
             ((atom x)
              (cond
                ((equal x |$EmptyMode|) (|specialChar| '|quad|))
                (t x)))
             ((and (consp x)
                   (progn
                     (setq |c| (qcar x))
                     (setq tmp1 (qcdr x))
                     (and (consp tmp1)
                          (progn
                            (setq |var| (qcar tmp1))
                            (setq tmp2 (qcdr tmp1))
                            (and (consp tmp2)
                                 (eq (qcdr tmp2) nil)
                                 (progn
                                   (setq |mode| (qcar tmp2))
                                   t)))))
                   (|member| |c| '(|pretend| |:| |::| @)))
              (setq |var| (|outputTran| |var|))
              (cond
                ((consp |var|)
                 (setq |var| (cons 'PAREN (cons |var| nil)))))
              (cons 'CONCATB
                    (cons |var|
                          (cons |c|
                                (cons (obj2String
                                       (|prefix2String| |mode|))
                                      nil)))))
             ((and (consp x) (eq (qcar x) 'ADEF)
                   (progn
                     (setq tmp1 (qcdr x))
                     (and (consp tmp1)
                          (progn
                            (setq |vars| (qcar tmp1))
                            (setq tmp2 (qcdr tmp1))
                            (and (consp tmp2)
                                 (progn
                                   (setq tmp3 (qcdr tmp2))
                                   (and (consp tmp3)
                                    (progn
                                      (setq tmp4
                                       (qcdr tmp3))
                                      (and (consp tmp4)
                                       (eq (qcdr tmp4) nil)
                                       (progn
                                         (setq |body|
                                          (qcar tmp4))
                                         t))))))))))
              (setq |vars|
                       (cond
                         ((and (consp |vars|) (eq (qcdr |vars|) nil)
                               (progn (setq x (qcar |vars|)) t))
                          x)
                         (t (cons '|Tuple| |vars|))))
              (|outputTran|
                  (cons '+-> (cons |vars| (cons |body| nil)))))
             ((and (consp x) (eq (qcar x) 'MATRIX)
                   (progn (setq m (qcdr x)) t))
              (outputTranMatrix m))
             ((and (consp x) (eq (qcar x) '|matrix|)
                   (progn
                     (setq tmp1 (qcdr x))
                     (and (consp tmp1) (eq (qcdr tmp1) nil)
                          (progn
                            (setq tmp2 (qcar tmp1))
                            (and (consp tmp2)
                                 (eq (qcar tmp2) '|construct|)
                                 (progn
                                   (setq tmp3 (qcdr tmp2))
                                   (and (consp tmp3)
                                    (eq (qcdr tmp3) nil)
                                    (progn
                                      (setq |c| (qcar tmp3))
                                      t)))))))
                   (consp |c|) (eq (qcar |c|) 'COLLECT)
                   (progn
                     (setq tmp1 (qcdr |c|))
                     (and (consp tmp1)
                          (progn
                            (setq tmp2 (reverse tmp1))
                            t)
                          (consp tmp2)
                          (progn
                            (setq d (qcar tmp2))
                            (setq m (qcdr tmp2))
                            t)
                          (progn (setq m (nreverse m)) t)))
                   (consp d) (eq (qcar d) '|construct|)
                   (progn
                     (setq tmp1 (qcdr d))
                     (and (consp tmp1) (eq (qcdr tmp1) nil)
                          (progn (setq |e| (qcar tmp1)) t)))
                   (consp |e|) (eq (qcar |e|) 'COLLECT))
              (|outputTran|
                  (cons 'COLLECT (APPEND m (cons |e| nil)))))
             ((and (consp x) (eq (qcar x) 'LIST)
                   (progn (setq |l| (qcdr x)) t))
              (|outputTran|
                  (cons 'BRACKET (cons (cons 'AGGLST |l|) nil))))
             ((and (consp x) (eq (qcar x) 'MAP)
                   (progn (setq |l| (qcdr x)) t))
              (outputMapTran |l|))
             ((and (consp x) (eq (qcar x) '|brace|)
                   (progn (setq |l| (qcdr x)) t))
              (cons 'BRACE
                    (cons (cons 'AGGLST
                                (prog (G166621)
                                  (setq G166621 nil)
                                  (return
                                    (DO
                                     ((G166626 |l| (CDR G166626))
                                      (y nil))
                                     ((or (atom G166626)
                                       (progn
                                         (setq y (car G166626))
                                         nil))
                                      (NREVERSE0 G166621))
                                      (SEQ
                                       (EXIT
                                        (setq G166621
                                         (cons (|outputTran| y)
                                          G166621))))))))
                          nil)))
             ((and (consp x) (eq (qcar x) '|return|)
                   (progn
                     (setq tmp1 (qcdr x))
                     (and (consp tmp1) (eq (qcdr tmp1) nil)
                          (progn (setq |l| (qcar tmp1)) t))))
              (cons '|return| (cons (|outputTran| |l|) nil)))
             ((and (consp x) (eq (qcar x) '|return|)
                   (progn
                     (setq tmp1 (qcdr x))
                     (and (consp tmp1)
                          (progn (setq |l| (qcdr tmp1)) t))))
              (cons '|return| (|outputTran| |l|)))
             ((and (consp x) (eq (qcar x) '|construct|)
                   (progn (setq |l| (qcdr x)) t))
              (cons 'BRACKET
                    (cons (cons 'AGGLST
                                (prog (G166636)
                                  (setq G166636 nil)
                                  (return
                                    (DO
                                     ((G166641 |l| (CDR G166641))
                                      (y nil))
                                     ((or (atom G166641)
                                       (progn
                                         (setq y (car G166641))
                                         nil))
                                      (NREVERSE0 G166636))
                                      (SEQ
                                       (EXIT
                                        (setq G166636
                                         (cons (|outputTran| y)
                                          G166636))))))))
                          nil)))
             ((and (consp x)
                   (progn
                     (setq tmp1 (qcar x))
                     (and (consp tmp1)
                          (eq (qcar tmp1) '|$elt|)
                          (progn
                            (setq tmp2 (qcdr tmp1))
                            (and (consp tmp2)
                                 (progn
                                   (setq |domain| (qcar tmp2))
                                   (setq tmp3 (qcdr tmp2))
                                   (and (consp tmp3)
                                    (eq (qcdr tmp3) nil)
                                    (eq (qcar tmp3) '|float|)))))))
                   (progn
                     (setq tmp4 (qcdr x))
                     (and (consp tmp4)
                          (progn
                            (setq x (qcar tmp4))
                            (setq tmp5 (qcdr tmp4))
                            (and (consp tmp5)
                                 (progn
                                   (setq y (qcar tmp5))
                                   (setq tmp6 (qcdr tmp5))
                                   (and (consp tmp6)
                                    (eq (qcdr tmp6) nil)
                                    (progn
                                      (setq |z| (qcar tmp6))
                                      t)))))))
                   (or (equal |domain| |$DoubleFloat|)
                       (and (consp |domain|) (eq (qcdr |domain|) nil)
                            (eq (qcar |domain|) '|Float|)))
                   (INTEGERP x) (INTEGERP y) (INTEGERP |z|)
                   (> |z| 0)
                   (setq |float|
                            (|getFunctionFromDomain| '|float| |domain|
                                (cons |$Integer|
                                      (cons |$Integer|
                                       (cons |$PositiveInteger| nil))))))
              (setq |f| (SPADCALL x y |z| |float|))
              (setq |o|
                       (|coerceInteractive| (mkObjWrap |f| |domain|)
                           '(|OutputForm|)))
              (|objValUnwrap| |o|))
             (t (setq |LETTMP#1| (flattenOps x))
              (setq |op| (car |LETTMP#1|))
              (setq |l| (CDR |LETTMP#1|))
              (cond
                ((STRINGP |op|) (setq |op| (INTERN |op|))
                 (setq x (cons |op| |l|))))
              (cond
                ((eq |op| 'LAMBDA-CLOSURE) '|Closure|)
                ((and (consp x) (eq (qcar x) '|break|)) '|break|)
                ((and (consp x) (eq (qcar x) 'SEGMENT)
                      (progn
                        (setq tmp1 (qcdr x))
                        (and (consp tmp1)
                             (eq (qcdr tmp1) nil)
                             (progn (setq a (qcar tmp1)) t))))
                 (setq |a'| (|outputTran| a))
                 (cond
                   ((LISTP |a'|)
                    (setq |a'| (cons 'PAREN (cons |a'| nil)))))
                 (cons 'SEGMENT (cons |a'| nil)))
                ((and (consp x) (eq (qcar x) 'SEGMENT)
                      (progn
                        (setq tmp1 (qcdr x))
                        (and (consp tmp1)
                             (progn
                               (setq a (qcar tmp1))
                               (setq tmp2 (qcdr tmp1))
                               (and (consp tmp2)
                                    (eq (qcdr tmp2) nil)
                                    (progn
                                      (setq b (qcar tmp2))
                                      t))))))
                 (setq |a'| (|outputTran| a))
                 (setq |b'| (|outputTran| b))
                 (cond
                   ((LISTP |a'|)
                    (setq |a'| (cons 'PAREN (cons |a'| nil)))))
                 (cond
                   ((LISTP |b'|)
                    (setq |b'| (cons 'PAREN (cons |b'| nil)))))
                 (cons 'SEGMENT (cons |a'| (cons |b'| nil))))
                ((or (and (consp |op|) (eq (qcar |op|) '|$elt|)
                          (progn
                            (setq tmp1 (qcdr |op|))
                            (and (consp tmp1)
                                 (progn
                                   (setq |targ| (qcar tmp1))
                                   (setq tmp2 (qcdr tmp1))
                                   (and (consp tmp2)
                                    (eq (qcdr tmp2) nil)
                                    (progn
                                      (setq |fun| (qcar tmp2))
                                      t))))))
                     (and (NULL |$InteractiveMode|) (consp |op|)
                          (eq (qcar |op|) '|elt|)
                          (progn
                            (setq tmp1 (qcdr |op|))
                            (and (consp tmp1)
                                 (progn
                                   (setq |targ| (qcar tmp1))
                                   (setq tmp2 (qcdr tmp1))
                                   (and (consp tmp2)
                                    (eq (qcdr tmp2) nil)
                                    (progn
                                      (setq |fun| (qcar tmp2))
                                      t)))))))
                 (setq |targ'|
                          (obj2String (|prefix2String| |targ|)))
                 (cond
                   ((EQL 2 (|#| |targ|))
                    (setq |targ'| (cons 'PAREN (cons |targ'| nil)))))
                 (cons 'CONCAT
                       (cons (|outputTran| (cons |fun| |l|))
                             (cons "$" (cons |targ'| nil)))))
                ((or (and (consp x) (eq (qcar x) '|$elt|)
                          (progn
                            (setq tmp1 (qcdr x))
                            (and (consp tmp1)
                                 (progn
                                   (setq |targ| (qcar tmp1))
                                   (setq tmp2 (qcdr tmp1))
                                   (and (consp tmp2)
                                    (eq (qcdr tmp2) nil)
                                    (progn
                                      (setq |c| (qcar tmp2))
                                      t))))))
                     (and (NULL |$InteractiveMode|) (consp x)
                          (eq (qcar x) '|elt|)
                          (progn
                            (setq tmp1 (qcdr x))
                            (and (consp tmp1)
                                 (progn
                                   (setq |targ| (qcar tmp1))
                                   (setq tmp2 (qcdr tmp1))
                                   (and (consp tmp2)
                                    (eq (qcdr tmp2) nil)
                                    (progn
                                      (setq |c| (qcar tmp2))
                                      t)))))))
                 (setq |targ'|
                          (obj2String (|prefix2String| |targ|)))
                 (cond
                   ((EQL 2 (|#| |targ|))
                    (setq |targ'| (cons 'PAREN (cons |targ'| nil)))))
                 (cons 'CONCAT
                       (cons (|outputTran| |c|)
                             (cons "$" (cons |targ'| nil)))))
                ((and (consp x) (eq (qcar x) '-)
                      (progn
                        (setq tmp1 (qcdr x))
                        (and (consp tmp1)
                             (progn
                               (setq a (qcar tmp1))
                               (setq tmp2 (qcdr tmp1))
                               (and (consp tmp2)
                                    (eq (qcdr tmp2) nil)
                                    (progn
                                      (setq b (qcar tmp2))
                                      t))))))
                 (setq a (|outputTran| a))
                 (setq b (|outputTran| b))
                 (cond
                   ((INTEGERP b)
                    (cond
                      ((MINUSP b)
                       (cons '+
                             (cons a (cons (- b) nil))))
                      (t
                       (cons '+
                             (cons a
                                   (cons (cons '- (cons b nil)) nil))))))
                   ((and (consp b) (eq (qcar b) '-)
                         (progn
                           (setq tmp1 (qcdr b))
                           (and (consp tmp1)
                                (eq (qcdr tmp1) nil)
                                (progn
                                  (setq |c| (qcar tmp1))
                                  t))))
                    (cons '+ (cons a (cons |c| nil))))
                   (t
                    (cons '+
                          (cons a
                                (cons (cons '- (cons b nil)) nil))))))
                ((and (consp x) (eq (qcar x) '**)
                      (progn
                        (setq tmp1 (qcdr x))
                        (and (consp tmp1)
                             (EQUAL (qcar tmp1) '"%e")
                             (progn
                               (setq tmp2 (qcdr tmp1))
                               (and (consp tmp2)
                                    (eq (qcdr tmp2) nil)
                                    (progn
                                      (setq |foo1| (qcar tmp2))
                                      t)))))
                      (consp |foo1|) (EQUAL (qcar |foo1|) '"/")
                      (progn
                        (setq tmp1 (qcdr |foo1|))
                        (and (consp tmp1)
                             (progn
                               (setq |foo2| (qcar tmp1))
                               (setq tmp2 (qcdr tmp1))
                               (and (consp tmp2)
                                    (eq (qcdr tmp2) nil)
                                    (progn
                                      (setq |foo3| (qcar tmp2))
                                      t)))))
                      (INTEGERP |foo3|) (consp |foo2|)
                      (eq (qcar |foo2|) '|log|)
                      (progn
                        (setq tmp1 (qcdr |foo2|))
                        (and (consp tmp1)
                             (eq (qcdr tmp1) nil)
                             (progn
                               (setq |foo4| (qcar tmp1))
                               t))))
                 (cond
                   ((EQL |foo3| 2)
                    (cons 'ROOT (cons (|outputTran| |foo4|) nil)))
                   (t
                    (cons 'ROOT
                          (cons (|outputTran| |foo4|)
                                (cons (|outputTran| |foo3|) nil))))))
                ((and (consp x) (eq (qcar x) '**)
                      (progn
                        (setq tmp1 (qcdr x))
                        (and (consp tmp1)
                             (EQUAL (qcar tmp1) '"%e")
                             (progn
                               (setq tmp2 (qcdr tmp1))
                               (and (consp tmp2)
                                    (eq (qcdr tmp2) nil)
                                    (progn
                                      (setq |foo1| (qcar tmp2))
                                      t)))))
                      (consp |foo1|)
                      (progn
                        (setq |op'| (qcar |foo1|))
                        (setq tmp1 (qcdr |foo1|))
                        (and (consp tmp1)
                             (progn
                               (setq |foo2| (qcar tmp1))
                               (setq tmp2 (qcdr tmp1))
                               (and (consp tmp2)
                                    (eq (qcdr tmp2) nil)
                                    (progn
                                      (setq |foo3| (qcar tmp2))
                                      t)))))
                      (string= |op'| "*")
                      (or (and (consp |foo3|) (eq (qcar |foo3|) '|log|)
                               (progn
                                 (setq tmp1 (qcdr |foo3|))
                                 (and (consp tmp1)
                                      (eq (qcdr tmp1) nil)
                                      (progn
                                        (setq |foo4|
                                         (qcar tmp1))
                                        t))))
                          (and (consp |foo2|) (eq (qcar |foo2|) '|log|)
                               (progn
                                 (setq tmp1 (qcdr |foo2|))
                                 (and (consp tmp1)
                                      (eq (qcdr tmp1) nil)
                                      (progn
                                        (setq |foo4|
                                         (qcar tmp1))
                                        t))))))
                 (cond
                   ((and (consp |foo3|) (eq (qcar |foo3|) '|log|)
                         (progn
                           (setq tmp1 (qcdr |foo3|))
                           (and (consp tmp1)
                                (eq (qcdr tmp1) nil)
                                (progn
                                  (setq |foo4| (qcar tmp1))
                                  t))))
                    (cons '**
                          (cons (|outputTran| |foo4|)
                                (cons (|outputTran| |foo2|) nil))))
                   (t (setq |foo4| (CADR |foo2|))
                    (cons '**
                          (cons (|outputTran| |foo4|)
                                (cons (|outputTran| |foo3|) nil))))))
                ((eq |op| 'IF) (outputTranIf x))
                ((eq |op| 'COLLECT) (outputTranCollect x))
                ((eq |op| 'REDUCE) (outputTranReduce x))
                ((eq |op| 'REPEAT) (outputTranRepeat x))
                ((eq |op| 'SEQ) (outputTranSEQ x))
                ((|member| |op| '(|cons| |nconc|))
                 (outputConstructTran x))
                (t
                 (setq |l|
                          (prog (G166651)
                            (setq G166651 nil)
                            (return
                              (do ((G166656 |l| (CDR G166656))
                                   (y nil))
                                  ((or (atom G166656)
                                    (progn
                                      (setq y (car G166656))
                                      nil))
                                   (NREVERSE0 G166651))
                                (seq (EXIT
                                      (setq G166651
                                       (cons (|outputTran| y)
                                        G166651))))))))
                 (cond
                   ((eq |op| '*)
                    (cond
                      ((and (consp |l|) (eq (qcdr |l|) nil)
                            (progn (setq a (qcar |l|)) t))
                       (|outputTran| a))
                      ((and (consp |l|)
                            (progn
                              (setq tmp1 (qcar |l|))
                              (and (consp tmp1)
                                   (eq (qcar tmp1) '-)
                                   (progn
                                     (setq tmp2
                                      (qcdr tmp1))
                                     (and (consp tmp2)
                                      (eq (qcdr tmp2) nil)
                                      (progn
                                        (setq a (qcar tmp2))
                                        t)))))
                            (progn (setq b (qcdr |l|)) t))
                       (cond
                         ((EQL a 1)
                          (|outputTran|
                              (cons '- (cons (cons |op| b) nil))))
                         (t
                          (|outputTran|
                              (cons '-
                                    (cons (cons |op| (cons a b))
                                     nil))))))
                      (t
                       (cons |op|
                             (prog (G166662)
                               (setq G166662 nil)
                               (return
                                 (do ((G166669 |l| (CDR G166669))
                                      (|ss| nil))
                                     ((or (atom G166669)
                                       (progn
                                         (setq |ss| (car G166669))
                                         nil))
                                      G166662)
                                   (SEQ
                                    (EXIT
                                     (setq G166662
                                      (APPEND G166662
                                       (cond
                                         ((and (consp |ss|)
                                           (eq (qcar |ss|) '*)
                                           (progn
                                             (setq |ll| (qcdr |ss|))
                                             t))
                                          |ll|)
                                         (t (cons |ss| nil))))))))))))))
                   ((eq |op| '+)
                    (cond
                      ((and (consp |l|) (eq (qcdr |l|) nil)
                            (progn (setq a (qcar |l|)) t))
                       (|outputTran| a))
                      (t
                       (cons |op|
                             (prog (G166675)
                               (setq G166675 nil)
                               (return
                                 (do ((G166682 |l| (CDR G166682))
                                      (|ss| nil))
                                     ((or (atom G166682)
                                       (progn
                                         (setq |ss| (car G166682))
                                         nil))
                                      G166675)
                                   (SEQ
                                    (EXIT
                                     (setq G166675
                                      (APPEND G166675
                                       (cond
                                         ((and (consp |ss|)
                                           (eq (qcar |ss|) '+)
                                           (progn
                                             (setq |ll| (qcdr |ss|))
                                             t))
                                          |ll|)
                                         (t (cons |ss| nil))))))))))))))
                   ((eq |op| '/)
                    (cond
                      ((eq |$fractionDisplayType|
                           '|horizontal|)
                       (setq |op| 'SLASH)
                       (cond
                         ((and (consp |l|)
                               (progn
                                 (setq a (qcar |l|))
                                 (setq tmp1 (qcdr |l|))
                                 (and (consp tmp1)
                                      (eq (qcdr tmp1) nil)
                                      (progn
                                        (setq b (qcar tmp1))
                                        t))))
                          (setq a
                                   (cond
                                     ((atom a) a)
                                     (t (cons 'PAREN (cons a nil)))))
                          (setq b
                                   (cond
                                     ((atom b) b)
                                     (t (cons 'PAREN (cons b nil)))))
                          (cons (|outputTran| |op|)
                                (cons a (cons b nil))))
                         (t (BREAK))))
                      (t (setq |op| 'OVER)
                       (cond
                         ((and (consp |l|)
                               (progn
                                 (setq tmp1 (qcar |l|))
                                 (and (consp tmp1)
                                      (eq (qcar tmp1) '-)
                                      (progn
                                        (setq tmp2
                                         (qcdr tmp1))
                                        (and (consp tmp2)
                                         (eq (qcdr tmp2) nil)
                                         (progn
                                           (setq a
                                            (qcar tmp2))
                                           t)))))
                               (progn (setq b (qcdr |l|)) t))
                          (|outputTran|
                              (cons '-
                                    (cons (cons |op| (cons a b))
                                     nil))))
                         (t (cons (|outputTran| |op|) |l|))))))
                   ((and (eq |op| '|\||) (consp |l|)
                         (progn
                           (setq tmp1 (qcar |l|))
                           (and (consp tmp1)
                                (eq (qcar tmp1) '|Tuple|)
                                (progn
                                  (setq u (qcdr tmp1))
                                  t)))
                         (progn
                           (setq tmp2 (qcdr |l|))
                           (and (consp tmp2)
                                (eq (qcdr tmp2) nil)
                                (progn
                                  (setq |pred| (qcar tmp2))
                                  t))))
                    (cons 'PAREN
                          (cons (cons '|\||
                                      (cons (cons 'AGGLST |l|)
                                       (cons |pred| nil)))
                                nil)))
                   ((eq |op| '|Tuple|)
                    (cons 'PAREN (cons (cons 'AGGLST |l|) nil)))
                   ((eq |op| 'LISTOF) (cons 'AGGLST |l|))
                   ((and (IDENTP |op|) (NULL (|member| |op| '(* **)))
                         (char= #\* (elt (PNAME |op|) 0)))
                    (mkSuperSub |op| |l|))
                   (t (cons (|outputTran| |op|) |l|)))))))))))

\end{chunk}
The next two functions are designed to replace successive instances of
binary functions with the n-ary equivalent, cutting down on recursion
in outputTran and in partciular allowing big polynomials to be printed
without stack overflow.  MCD.
\begin{chunk}{*}
;flattenOps l ==
;  [op, :args ] := l
;  op in ['"+",'"*","+","*"] =>
;    [op,:checkArgs(op,args)]
;  l

(defun flattenOps (|l|)
  (prog (|op| |args|)
    (return
      (progn
        (setq |op| (car |l|))
        (setq |args| (CDR |l|))
        (cond
          ((|member| |op|
               (cons "+" (cons "*" (cons '+ (cons '* nil)))))
           (cons |op| (|checkArgs| |op| |args|)))
          (t |l|))))))

;checkArgs(op,tail) ==
;  head := []
;  while tail repeat
;    term := first tail
;    atom term =>
;      head := [term,:head]
;      tail := rest tail
;    not LISTP term => -- never happens?
;      head := [term,:head]
;      tail := rest tail
;    op=first term =>
;      tail := [:rest term,:rest tail]
;    head := [term,:head]
;    tail := rest tail
;  REVERSE head

(defun |checkArgs| (|op| |tail|)
  (prog (|term| |head|)
    (return
      (seq (progn
             (setq |head| nil)
             (do () ((NULL |tail|) nil)
               (seq (exit (progn
                            (setq |term| (car |tail|))
                            (cond
                              ((atom |term|)
                               (setq |head| (cons |term| |head|))
                               (setq |tail| (CDR |tail|)))
                              ((NULL (LISTP |term|))
                               (setq |head| (cons |term| |head|))
                               (setq |tail| (CDR |tail|)))
                              ((equal |op| (car |term|))
                               (setq |tail|
                                        (APPEND (CDR |term|)
                                         (CDR |tail|))))
                              (t (setq |head| (cons |term| |head|))
                               (setq |tail| (CDR |tail|))))))))
             (reverse |head|))))))

;outputTranSEQ ['SEQ,:l,exitform] ==
;  if exitform is ['exit,.,a] then exitform := a
;  ['SC,:[outputTran x for x in l],outputTran exitform]

(defun outputTranSEQ (G166882)
  (prog (|LETTMP#1| |l| tmp1 tmp2 a |exitform|)
    (return
      (seq (progn
             (setq |LETTMP#1| (reverse (CDR G166882)))
             (setq |exitform| (car |LETTMP#1|))
             (setq |l| (nreverse (CDR |LETTMP#1|)))
             (cond
               ((and (consp |exitform|) (eq (qcar |exitform|) '|exit|)
                     (progn
                       (setq tmp1 (qcdr |exitform|))
                       (and (consp tmp1)
                            (progn
                              (setq tmp2 (qcdr tmp1))
                              (and (consp tmp2)
                                   (eq (qcdr tmp2) nil)
                                   (progn
                                     (setq a (qcar tmp2))
                                     t))))))
                (setq |exitform| a)))
             (cons 'SC
                   (APPEND (prog (G166903)
                             (setq G166903 nil)
                             (return
                               (do ((G166908 |l| (CDR G166908))
                                    (x nil))
                                   ((or (atom G166908)
                                     (progn
                                       (setq x (car G166908))
                                       nil))
                                    (NREVERSE0 G166903))
                                 (seq (EXIT
                                       (setq G166903
                                        (cons (|outputTran| x)
                                         G166903)))))))
                           (cons (|outputTran| |exitform|) nil))))))))

;outputTranIf ['IF,x,y,z] ==
;  y = 'noBranch =>
;    ['CONCATB,'if,['CONCATB,'not,outputTran x],'then,outputTran z]
;  z = 'noBranch =>
;    ['CONCATB,'if,outputTran x,'then,outputTran y]
;  y' := outputTran y
;  z' := outputTran z
;--y' is ['SC,:.] or z' is ['SC,:.] =>
;-- ['CONCATB,'if,outputTran x,
;--   ['SC,['CONCATB,'then,y'],['CONCATB,'else,z']]]
;--['CONCATB,'if,outputTran x,'then,outputTran y,'else,outputTran z]
;  ['CONCATB,'if,outputTran x,
;    ['SC,['CONCATB,'then,y'],['CONCATB,'else,z']]]

(defun outputTranIf (G166926)
  (prog (x y |z| |y'| |z'|)
    (return
      (progn
        (setq x (CADR G166926))
        (setq y (CADDR G166926))
        (setq |z| (CADDDR G166926))
        (cond
          ((eq y '|noBranch|)
           (cons 'CONCATB
                 (cons '|if|
                       (cons (cons 'CONCATB
                                   (cons '|not|
                                    (cons (|outputTran| x) nil)))
                             (cons '|then|
                                   (cons (|outputTran| |z|) nil))))))
          ((eq |z| '|noBranch|)
           (cons 'CONCATB
                 (cons '|if|
                       (cons (|outputTran| x)
                             (cons '|then|
                                   (cons (|outputTran| y) nil))))))
          (t (setq |y'| (|outputTran| y))
           (setq |z'| (|outputTran| |z|))
           (cons 'CONCATB
                 (cons '|if|
                       (cons (|outputTran| x)
                             (cons (cons 'SC
                                    (CONS
                                     (cons 'CONCATB
                                      (cons '|then| (cons |y'| nil)))
                                     (CONS
                                      (cons 'CONCATB
                                       (cons '|else| (cons |z'| nil)))
                                      nil)))
                                   nil))))))))))

;outputMapTran l ==
;  null l => NIL         -- should not happen
;  -- display subscripts linearly
;  $linearFormatScripts : local := true
;  -- get the real names of the parameters
;  alias := get($op,'alias,$InteractiveFrame)
;  rest l =>             -- if multiple forms, call repeatedly
;    ['SC,:[outputMapTran0(ll,alias) for ll in l]]
;  outputMapTran0(first l,alias)

(defun outputMapTran (|l|)
  (prog (|$linearFormatScripts| |alias|)
    (declare (special |$linearFormatScripts| |$InteractiveFrame| |$op|))
    (return
      (seq (cond
             ((NULL |l|) nil)
             (t (setq |$linearFormatScripts| t)
              (setq |alias|
                       (|get| |$op| '|alias| |$InteractiveFrame|))
              (cond
                ((CDR |l|)
                 (cons 'SC
                       (prog (G166950)
                         (setq G166950 nil)
                         (return
                           (do ((G166955 |l| (CDR G166955)) (|ll| nil))
                               ((or (atom G166955)
                                    (progn
                                      (setq |ll| (car G166955))
                                      nil))
                                (NREVERSE0 G166950))
                             (seq (exit (setq G166950
                                         (CONS
                                          (outputMapTran0 |ll|
                                           |alias|)
                                          G166950)))))))))
                (t (outputMapTran0 (car |l|) |alias|)))))))))

;outputMapTran0(argDef,alias) ==
;  arg := first argDef
;  def := rest  argDef
;  [arg',:def'] := simplifyMapPattern(argDef,alias)
;  arg' := outputTran arg'
;  if null arg' then arg' := '"()"
;  ['CONCATB,$op,outputTran arg',"==",outputTran def']

(defun outputMapTran0 (|argDef| |alias|)
  (prog (|arg| |def| |LETTMP#1| |def'| |arg'|)
    (declare (special |$op|))
    (return
      (progn
        (setq |arg| (car |argDef|))
        (setq |def| (CDR |argDef|))
        (setq |LETTMP#1| (|simplifyMapPattern| |argDef| |alias|))
        (setq |arg'| (car |LETTMP#1|))
        (setq |def'| (CDR |LETTMP#1|))
        (setq |arg'| (|outputTran| |arg'|))
        (cond ((NULL |arg'|) (setq |arg'| "()")))
        (cons 'CONCATB
              (cons |$op|
                    (cons (|outputTran| |arg'|)
                          (cons '== (cons (|outputTran| |def'|) nil)))))))))

;outputTranReduce ['REDUCE,op,.,body] ==
;  ['CONCAT,op,"/",outputTran body]

(defun outputTranReduce (G166987)
  (prog (|op| |body|)
    (return
      (progn
        (setq |op| (CADR G166987))
        (setq |body| (CADDDR G166987))
        (cons 'CONCAT
              (cons |op| (cons '/ (cons (|outputTran| |body|) nil))))))))

;outputTranRepeat ["REPEAT",:itl,body] ==
;  body' := outputTran body
;  itl =>
;    itlist:= outputTranIteration itl
;    ['CONCATB,itlist,'repeat,body']
;  ['CONCATB,'repeat,body']

(defun outputTranRepeat (G167003)
  (prog (|LETTMP#1| |body| |itl| |body'| |itlist|)
    (return
      (progn
        (cond ((eq (car G167003) 'REPEAT) (car G167003)))
        (setq |LETTMP#1| (reverse (CDR G167003)))
        (setq |body| (car |LETTMP#1|))
        (setq |itl| (nreverse (CDR |LETTMP#1|)))
        (setq |body'| (|outputTran| |body|))
        (cond
          (|itl| (setq |itlist| (outputTranIteration |itl|))
                 (cons 'CONCATB
                       (cons |itlist|
                             (cons '|repeat| (cons |body'| nil)))))
          (t (cons 'CONCATB (cons '|repeat| (cons |body'| nil)))))))))

;outputTranCollect [.,:itl,body] ==
;  itlist:= outputTranIteration itl
;  ['BRACKET,['CONCATB,outputTran body,itlist]]

(defun outputTranCollect (G167025)
  (prog (|LETTMP#1| |body| |itl| |itlist|)
    (return
      (progn
        (setq |LETTMP#1| (reverse (CDR G167025)))
        (setq |body| (car |LETTMP#1|))
        (setq |itl| (nreverse (CDR |LETTMP#1|)))
        (setq |itlist| (outputTranIteration |itl|))
        (cons 'BRACKET
              (cons (cons 'CONCATB
                          (cons (|outputTran| |body|)
                                (cons |itlist| nil)))
                    nil))))))

;outputTranIteration itl ==
;  null rest itl => outputTranIterate first itl
;  ['CONCATB,outputTranIterate first itl,outputTranIteration rest itl]

(defun outputTranIteration (|itl|)
  (cond
    ((NULL (CDR |itl|)) (outputTranIterate (car |itl|)))
    (t
     (cons 'CONCATB
           (cons (outputTranIterate (car |itl|))
                 (cons (outputTranIteration (CDR |itl|)) nil))))))

;outputTranIterate x ==
;  x is ['STEP,n,init,step,:final] =>
;    init' := outputTran init
;    if LISTP init then init' := ['PAREN,init']
;    final' :=
;      final =>
;        LISTP first final => [['PAREN,outputTran first final]]
;        [outputTran first final]
;      NIL
;    ['STEP,outputTran n,init',outputTran step,:final']
;  x is ["IN",n,s] => ["IN",outputTran n,outputTran s]
;  x is [op,p] and op in '(_| UNTIL WHILE) =>
;    op:= DOWNCASE op
;    ['CONCATB,op,outputTran p]
;  throwKeyedMsg("S2IX0008",['outputTranIterate,['"illegal iterate: ",x]])

(defun outputTranIterate (x)
  (prog (|init| tmp3 |step| |final| |init'| |final'| n tmp2
                |s| tmp1 |p| |op|)
    (return
      (cond
        ((and (consp x) (eq (qcar x) 'STEP)
              (progn
                (setq tmp1 (qcdr x))
                (and (consp tmp1)
                     (progn
                       (setq n (qcar tmp1))
                       (setq tmp2 (qcdr tmp1))
                       (and (consp tmp2)
                            (progn
                              (setq |init| (qcar tmp2))
                              (setq tmp3 (qcdr tmp2))
                              (and (consp tmp3)
                                   (progn
                                     (setq |step| (qcar tmp3))
                                     (setq |final| (qcdr tmp3))
                                     t))))))))
         (setq |init'| (|outputTran| |init|))
         (cond
           ((LISTP |init|)
            (setq |init'| (cons 'PAREN (cons |init'| nil)))))
         (setq |final'|
                  (cond
                    (|final| (cond
                               ((LISTP (car |final|))
                                (cons (cons 'PAREN
                                       (CONS
                                        (|outputTran| (car |final|))
                                        nil))
                                      nil))
                               (t
                                (cons (|outputTran| (car |final|)) nil))))
                    (t nil)))
         (cons 'STEP
               (cons (|outputTran| n)
                     (cons |init'|
                           (cons (|outputTran| |step|) |final'|)))))
        ((and (consp x) (eq (qcar x) 'IN)
              (progn
                (setq tmp1 (qcdr x))
                (and (consp tmp1)
                     (progn
                       (setq n (qcar tmp1))
                       (setq tmp2 (qcdr tmp1))
                       (and (consp tmp2) (eq (qcdr tmp2) nil)
                            (progn (setq |s| (qcar tmp2)) t))))))
         (cons 'IN
               (cons (|outputTran| n) (cons (|outputTran| |s|) nil))))
        ((and (consp x)
              (progn
                (setq |op| (qcar x))
                (setq tmp1 (qcdr x))
                (and (consp tmp1) (eq (qcdr tmp1) nil)
                     (progn (setq |p| (qcar tmp1)) t)))
              (|member| |op| '(|\|| UNTIL WHILE)))
         (setq |op| (DOWNCASE |op|))
         (cons 'CONCATB (cons |op| (cons (|outputTran| |p|) nil))))
        (t
         (|throwKeyedMsg|
           "Internal system problem in function %1 : %2"
             (cons 'outputTranIterate
                   (cons (cons "illegal iterate: " (cons x nil)) nil))))))))

;outputConstructTran x ==
;  x is [op,a,b] =>
;    a:= outputTran a
;    b:= outputTran b
;    op="cons" =>
;      b is ['construct,:l] => ['construct,a,:l]
;      ['BRACKET,['AGGLST,:[a,[":",b]]]]
;    op="nconc" =>
;      aPart :=
;        a is ['construct,c] and c is ['SEGMENT,:.] => c
;        [":",a]
;      b is ['construct,:l] => ['construct,aPart,:l]
;      ['BRACKET,['AGGLST,aPart,[":",b]]]
;    [op,a,b]
;  atom x => x
;  [outputTran first x,:outputConstructTran rest x]

(defun outputConstructTran (x)
  (prog (|op| tmp2 a b tmp1 |c| |aPart| |l|)
    (return
      (cond
        ((and (consp x)
              (progn
                (setq |op| (qcar x))
                (setq tmp1 (qcdr x))
                (and (consp tmp1)
                     (progn
                       (setq a (qcar tmp1))
                       (setq tmp2 (qcdr tmp1))
                       (and (consp tmp2) (eq (qcdr tmp2) nil)
                            (progn (setq b (qcar tmp2)) t))))))
         (setq a (|outputTran| a))
         (setq b (|outputTran| b))
         (cond
           ((eq |op| '|cons|)
            (cond
              ((and (consp b) (eq (qcar b) '|construct|)
                    (progn (setq |l| (qcdr b)) t))
               (cons '|construct| (cons a |l|)))
              (t
               (cons 'BRACKET
                     (cons (cons 'AGGLST
                                 (cons a
                                       (cons (cons '|:| (cons b nil))
                                        nil)))
                           nil)))))
           ((eq |op| '|nconc|)
            (setq |aPart|
                     (cond
                       ((and (consp a) (eq (qcar a) '|construct|)
                             (progn
                               (setq tmp1 (qcdr a))
                               (and (consp tmp1)
                                    (eq (qcdr tmp1) nil)
                                    (progn
                                      (setq |c| (qcar tmp1))
                                      t)))
                             (consp |c|) (eq (qcar |c|) 'SEGMENT))
                        |c|)
                       (t (cons '|:| (cons a nil)))))
            (cond
              ((and (consp b) (eq (qcar b) '|construct|)
                    (progn (setq |l| (qcdr b)) t))
               (cons '|construct| (cons |aPart| |l|)))
              (t
               (cons 'BRACKET
                     (cons (cons 'AGGLST
                                 (cons |aPart|
                                       (cons (cons '|:| (cons b nil))
                                        nil)))
                           nil)))))
           (t (cons |op| (cons a (cons b nil))))))
        ((atom x) x)
        (t
         (cons (|outputTran| (car x))
               (outputConstructTran (CDR x))))))))

;outputTranMatrix x ==
;  not VECP x =>
;    -- assume that the only reason is that we've been done before
;    ["MATRIX",:x]
;    --keyedSystemError("S2GE0016",['"outputTranMatrix",
;    -- '"improper internal form for matrix found in output routines"])
;  ["MATRIX",nil,:[outtranRow x.i for i in 0..MAXINDEX x]] where
;    outtranRow x ==
;      not VECP x =>
;        keyedSystemError("S2GE0016",['"outputTranMatrix",
;          '"improper internal form for matrix found in output routines"])
;      ["ROW",:[outputTran x.i for i in 0..MAXINDEX x]]

(defun outputTranMatrixOuttranRow (x)
  (prog ()
    (return
      (seq (IF (NULL (VECP x))
               (exit (|keyedSystemError|
                "Unexpected error or improper call to system function %1: %2"
                         (cons "outputTranMatrix"
             (cons "improper internal form for matrix found in output routines"
                                     nil)))))
           (exit (cons 'ROW
                       (prog (G167193)
                         (setq G167193 nil)
                         (return
                           (do ((G167198 (MAXINDEX x))
                                (|i| 0 (QSADD1 |i|)))
                               ((QSGREATERP |i| G167198)
                                (NREVERSE0 G167193))
                             (seq (exit (setq G167193
                                         (CONS
                                          (|outputTran| (elt x |i|))
                                          G167193)))))))))))))

(defun outputTranMatrix (x)
  (prog ()
    (return
      (seq (cond
             ((NULL (VECP x)) (cons 'MATRIX x))
             (t
              (cons 'MATRIX
                    (cons NIL
                          (prog (G167212)
                            (setq G167212 nil)
                            (return
                              (do ((G167217 (MAXINDEX x))
                                   (|i| 0 (QSADD1 |i|)))
                                  ((QSGREATERP |i| G167217)
                                   (NREVERSE0 G167212))
                                (seq (EXIT
                                      (setq G167212
                                       (CONS
                                        (outputTranMatrixOuttranRow
                                         (elt x |i|))
                                        G167212)))))))))))))))

;mkSuperSub(op,argl) ==
;  $linearFormatScripts => linearFormatForm(op,argl)
;--  l := [(STRINGP f => f; princ-to-string f)
;--    for f in linearFormatForm(op,argl)]
;--  "STRCONC"/l
;  s:= PNAME op
;  indexList:= [PARSE_-INTEGER PNAME d for i in 1.. while
;    (DIGITP (d:= s.(maxIndex:= i)))]
;  cleanOp:= INTERN ("STRCONC"/[PNAME s.i for i in maxIndex..MAXINDEX s])
;  -- if there is just a subscript use the SUB special form
;  #indexList=2 =>
;    subPart:= ['SUB,cleanOp,:take(indexList.1,argl)]
;    l:= drop(indexList.1,argl) => [subPart,:l]
;    subPart
;  -- otherwise use the SUPERSUB form
;  superSubPart := NIL
;  for i in rest indexList repeat
;    scripts :=
;      this:= take(i,argl)
;      argl:= drop(i,argl)
;      i=0 => ['AGGLST]
;      i=1 => first this
;      ['AGGLST,:this]
;    superSubPart := cons(scripts,superSubPart)
;  superSub := ['SUPERSUB,cleanOp,:reverse superSubPart]
;  argl => [superSub,:argl]
;  superSub

(defun mkSuperSub (|op| |argl|)
  (prog (|s| |maxIndex| d |indexList| |cleanOp| |subPart| |l| |this|
             |scripts| |superSubPart| |superSub|)
    (declare (special |$linearFormatScripts|))
    (return
      (seq (cond
             (|$linearFormatScripts| (|linearFormatForm| |op| |argl|))
             (t (setq |s| (PNAME |op|))
              (setq |indexList|
                       (prog (G167234)
                         (setq G167234 nil)
                         (return
                           (do ((|i| 1 (QSADD1 |i|)))
                               ((NULL (DIGITP
                                       (setq d
                                        (elt |s|
                                         (setq |maxIndex| |i|)))))
                                (NREVERSE0 G167234))
                             (seq (exit (setq G167234
                                         (CONS
                                          (PARSE-INTEGER (PNAME d))
                                          G167234))))))))
              (setq |cleanOp|
                       (INTERN (prog (G167243)
                                 (setq G167243 "")
                                 (return
                                   (DO
                                    ((G167248 (MAXINDEX |s|))
                                     (|i| |maxIndex| (+ |i| 1)))
                                    ((> |i| G167248) G167243)
                                     (SEQ
                                      (EXIT
                                       (setq G167243
                                        (STRCONC G167243
                                         (PNAME (elt |s| |i|)))))))))))
              (cond
                ((EQL (|#| |indexList|) 2)
                 (setq |subPart|
                          (cons 'SUB
                                (cons |cleanOp|
                                      (TAKE (elt |indexList| 1) |argl|))))
                 (cond
                   ((setq |l| (DROP (elt |indexList| 1) |argl|))
                    (cons |subPart| |l|))
                   (t |subPart|)))
                (t (setq |superSubPart| nil)
                 (do ((G167260 (CDR |indexList|) (CDR G167260))
                      (|i| nil))
                     ((or (atom G167260)
                          (progn (setq |i| (car G167260)) nil))
                      nil)
                   (seq (exit (progn
                                (setq |scripts|
                                         (progn
                                           (setq |this|
                                            (TAKE |i| |argl|))
                                           (setq |argl|
                                            (DROP |i| |argl|))
                                           (cond
                                             ((EQL |i| 0)
                                              (cons 'AGGLST nil))
                                             ((EQL |i| 1) (car |this|))
                                             (t (cons 'AGGLST |this|)))))
                                (setq |superSubPart|
                                         (cons |scripts|
                                          |superSubPart|))))))
                 (setq |superSub|
                          (cons 'SUPERSUB
                                (cons |cleanOp|
                                      (reverse |superSubPart|))))
                 (cond
                   (|argl| (cons |superSub| |argl|))
                   (t |superSub|))))))))))

;timesApp(u,x,y,d) ==
;  rightPrec:= getOpBindingPower("*","Led","right")
;  firstTime:= true
;  for arg in rest u repeat
;    op:= keyp arg
;    if ^firstTime and (needBlankForRoot(lastOp,op,arg) or
;       needStar(wasSimple,wasQuotient,wasNumber,arg,op) or
;        wasNumber and op = 'ROOT and subspan arg = 1) then
;      d:= APP(BLANK,x,y,d)
;      x:= x+1
;    [d,x]:= appInfixArg(arg,x,y,d,rightPrec,"left",nil) --app in a right arg
;    wasSimple:= atom arg and not NUMBERP arg or isRationalNumber arg
;    wasQuotient:= isQuotient op
;    wasNumber:= NUMBERP arg
;    lastOp := op
;    firstTime:= nil
;  d

(defun |timesApp| (u x y d)
  (prog (|rightPrec| |op| |LETTMP#1| |wasSimple| |wasQuotient|
            |wasNumber| |lastOp| |firstTime|)
    (return
      (seq (progn
             (setq |rightPrec|
                      (getOpBindingPower '* '|Led| '|right|))
             (setq |firstTime| t)
             (do ((G167307 (CDR u) (CDR G167307)) (|arg| nil))
                 ((or (atom G167307)
                      (progn (setq |arg| (car G167307)) nil))
                  nil)
               (seq (exit (progn
                            (setq |op| (keyp |arg|))
                            (cond
                              ((and (NULL |firstTime|)
                                    (OR
                                     (needBlankForRoot |lastOp| |op|
                                      |arg|)
                                     (needStar |wasSimple|
                                      |wasQuotient| |wasNumber| |arg|
                                      |op|)
                                     (and |wasNumber|
                                      (eq |op| 'ROOT)
                                      (EQL (|subspan| |arg|) 1))))
                               (setq d (APP BLANK x y d))
                               (setq x (+ x 1))))
                            (setq |LETTMP#1|
                                     (appInfixArg |arg| x y d
                                      |rightPrec| '|left| nil))
                            (setq d (car |LETTMP#1|))
                            (setq x (CADR |LETTMP#1|))
                            (setq |wasSimple|
                                     (OR
                                      (and (atom |arg|)
                                       (NULL (NUMBERP |arg|)))
                                      (isRationalNumber |arg|)))
                            (setq |wasQuotient| (isQuotient |op|))
                            (setq |wasNumber| (NUMBERP |arg|))
                            (setq |lastOp| |op|)
                            (setq |firstTime| nil)))))
             d)))))

;needBlankForRoot(lastOp,op,arg) ==
;  lastOp ^= "^" and lastOp ^= "**" and not(subspan(arg)>0) => false
;  op = "**" and keyp CADR arg = 'ROOT => true
;  op = "^" and keyp CADR arg = 'ROOT => true
;  op = 'ROOT and CDDR arg => true
;  false

(defun needBlankForRoot (|lastOp| |op| |arg|)
  (cond
    ((and (NEQUAL |lastOp| '^) (NEQUAL |lastOp| '**)
          (NULL (> (|subspan| |arg|) 0)))
     nil)
    ((and (eq |op| '**)
          (eq (keyp (CADR |arg|)) 'ROOT))
     t)
    ((and (eq |op| '^)
          (eq (keyp (CADR |arg|)) 'ROOT))
     t)
    ((and (eq |op| 'ROOT) (CDDR |arg|)) t)
    (t nil)))

;stepApp([.,a,init,one,:optFinal],x,y,d) ==
;  d:= appChar('"for ",x,y,d)
;  d:= APP(a,w:=x+4,y,d)
;  d:= appChar('" in ",w:=w+WIDTH a,y,d)
;  d:= APP(init,w:=w+4,y,d)
;  d:= APP('"..",w:=w+WIDTH init,y,d)
;  if optFinal then d:= APP(first optFinal,w+2,y,d)
;  d

(defun |stepApp| (G167334 x y d)
  (prog (a |init| |one| |optFinal| w)
    (return
      (progn
        (setq a (CADR G167334))
        (setq |init| (CADDR G167334))
        (setq |one| (CADDDR G167334))
        (setq |optFinal| (CDDDDR G167334))
        (setq d (appChar "for " x y d))
        (setq d (APP a (setq w (+ x 4)) y d))
        (setq d
                 (appChar " in " (setq w (+ w (width a)))
                     y d))
        (setq d (APP |init| (setq w (+ w 4)) y d))
        (setq d
                 (APP ".." (setq w (+ w (width |init|))) y
                      d))
        (cond
          (|optFinal|
              (setq d (APP (car |optFinal|) (+ w 2) y d))))
        d))))

;stepSub [.,a,init,one,:optFinal] ==
;  m:= MAX(subspan a,subspan init)
;  optFinal => MAX(m,subspan first optFinal)
;  m

(defun |stepSub| (G167365)
  (prog (a |init| |one| |optFinal| m)
    (return
      (progn
        (setq a (CADR G167365))
        (setq |init| (CADDR G167365))
        (setq |one| (CADDDR G167365))
        (setq |optFinal| (CDDDDR G167365))
        (setq m (MAX (|subspan| a) (|subspan| |init|)))
        (cond
          (|optFinal| (MAX m (|subspan| (car |optFinal|))))
          (t m))))))

;stepSuper [.,a,init,one,:optFinal] ==
;  m:= MAX(superspan a,superspan init)
;  optFinal => MAX(m,superspan first optFinal)
;  m

(defun |stepSuper| (G167387)
  (prog (a |init| |one| |optFinal| m)
    (return
      (progn
        (setq a (CADR G167387))
        (setq |init| (CADDR G167387))
        (setq |one| (CADDDR G167387))
        (setq |optFinal| (CDDDDR G167387))
        (setq m (MAX (|superspan| a) (|superspan| |init|)))
        (cond
          (|optFinal| (MAX m (|superspan| (car |optFinal|))))
          (t m))))))

;stepWidth [.,a,init,one,:optFinal] ==
;   10+WIDTH a+WIDTH init+(optFinal => WIDTH first optFinal; 0)

(defun |stepWidth| (G167409)
  (prog (a |init| |one| |optFinal|)
    (return
      (progn
        (setq a (CADR G167409))
        (setq |init| (CADDR G167409))
        (setq |one| (CADDDR G167409))
        (setq |optFinal| (CDDDDR G167409))
        (+ (+ (+ 10 (width a)) (width |init|))
              (cond (|optFinal| (width (car |optFinal|))) (t 0)))))))

;inApp([.,a,s],x,y,d) ==  --for [IN,a,s]
;  d:= appChar('"for ",x,y,d)
;  d:= APP(a,x+4,y,d)
;  d:= appChar('" in ",x+WIDTH a+4,y,d)
;  APP(s,x+WIDTH a+8,y,d)

(defun |inApp| (G167430 x y d)
  (prog (a |s|)
    (return
      (progn
        (setq a (CADR G167430))
        (setq |s| (CADDR G167430))
        (setq d (appChar "for " x y d))
        (setq d (APP a (+ x 4) y d))
        (setq d
                 (appChar " in " (+ (+ x (width a)) 4) y
                     d))
        (APP |s| (+ (+ x (width a)) 8) y d)))))

;inSub [.,a,s] == MAX(subspan a,subspan s)

(defun |inSub| (G167447)
  (prog (a |s|)
    (return
      (progn
        (setq a (CADR G167447))
        (setq |s| (CADDR G167447))
        (MAX (|subspan| a) (|subspan| |s|))))))

;inSuper [.,a,s] == MAX(superspan a,superspan s)

(defun |inSuper| (G167461)
  (prog (a |s|)
    (return
      (progn
        (setq a (CADR G167461))
        (setq |s| (CADDR G167461))
        (MAX (|superspan| a) (|superspan| |s|))))))

;inWidth [.,a,s] == 8+WIDTH a+WIDTH s

(defun |inWidth| (G167475)
  (prog (a |s|)
    (return
      (progn
        (setq a (CADR G167475))
        (setq |s| (CADDR G167475))
        (+ (+ 8 (width a)) (width |s|))))))

;centerApp([.,u],x,y,d) ==
;  d := APP(u,x,y,d)

(defun |centerApp| (G167489 x y d)
  (prog (u)
    (return
      (progn
        (setq u (CADR G167489))
        (setq d (APP u x y d))))))

;concatApp([.,:l],x,y,d) == concatApp1(l,x,y,d,0)

(defun |concatApp| (G167501 x y d)
  (prog (|l|)
    (return
      (progn
        (setq |l| (CDR G167501))
        (concatApp1 |l| x y d 0)))))

;concatbApp([.,:l],x,y,d) == concatApp1(l,x,y,d,1)

(defun |concatbApp| (G167512 x y d)
  (prog (|l|)
    (return
      (progn
        (setq |l| (CDR G167512))
        (concatApp1 |l| x y d 1)))))

;concatApp1(l,x,y,d,n) ==
;  for u in l repeat
;    d:= APP(u,x,y,d)
;    x:=x+WIDTH u+n
;  d

(defun concatApp1 (|l| x y d n)
  (seq (progn
         (do ((G167530 |l| (CDR G167530)) (u nil))
             ((or (atom G167530) (progn (setq u (car G167530)) nil))
              nil)
           (seq (exit (progn
                        (setq d (APP u x y d))
                        (setq x (+ (+ x (width u)) n))))))
         d)))

;concatSub [.,:l] == "MAX"/[subspan x for x in l]

(defun |concatSub| (G167541)
  (prog (|l|)
    (return
      (seq (progn
             (setq |l| (CDR G167541))
             (prog (G167548)
               (setq G167548 -999999)
               (return
                 (do ((G167553 |l| (CDR G167553)) (x nil))
                     ((or (atom G167553)
                          (progn (setq x (car G167553)) nil))
                      G167548)
                   (seq (exit (setq G167548
                                    (MAX G167548 (|subspan| x)))))))))))))

;concatSuper [.,:l] == "MAX"/[superspan x for x in l]

(defun |concatSuper| (G167564)
  (prog (|l|)
    (return
      (seq (progn
             (setq |l| (CDR G167564))
             (prog (G167571)
               (setq G167571 -999999)
               (return
                 (do ((G167576 |l| (CDR G167576)) (x nil))
                     ((or (atom G167576)
                          (progn (setq x (car G167576)) nil))
                      G167571)
                   (seq (exit (setq G167571
                                    (MAX G167571 (|superspan| x)))))))))))))

;concatWidth [.,:l] == +/[WIDTH x for x in l]

(defun |concatWidth| (G167587)
  (prog (|l|)
    (return
      (seq (progn
             (setq |l| (CDR G167587))
             (prog (G167594)
               (setq G167594 0)
               (return
                 (do ((G167599 |l| (CDR G167599)) (x nil))
                     ((or (atom G167599)
                          (progn (setq x (car G167599)) nil))
                      G167594)
                 (seq (exit (setq G167594 (+ G167594 (width x)))))))))))))

;concatbWidth [.,:l] == +/[1+WIDTH x for x in l]-1

(defun |concatbWidth| (G167610)
  (prog (|l|)
    (return
      (seq (progn
             (setq |l| (CDR G167610))
             (-
                 (prog (G167617)
                   (setq G167617 0)
                   (return
                     (do ((G167622 |l| (CDR G167622)) (x nil))
                         ((or (atom G167622)
                              (progn (setq x (car G167622)) nil))
                          G167617)
                       (seq (exit (setq G167617
                                        (+ G167617
                                         (+ 1 (width x)))))))))
                 1))))))

;exptApp([.,a,b],x,y,d) ==
;  pren:= exptNeedsPren a
;  d:=
;    pren => appparu(a,x,y,d)
;    APP(a,x,y,d)
;  x':= x+WIDTH a+(pren => 2;0)
;  y':= 1+y+superspan a+subspan b + (0=superspan a => 0; -1)
;  APP(b,x',y',d)

(defun |exptApp| (G167637 x y d)
  (prog (a b |pren| |x'| |y'|)
    (return
      (progn
        (setq a (CADR G167637))
        (setq b (CADDR G167637))
        (setq |pren| (exptNeedsPren a))
        (setq d
                 (cond
                   (|pren| (|appparu| a x y d))
                   (t (APP a x y d))))
        (setq |x'|
                 (+ (+ x (width a)) (cond (|pren| 2) (t 0))))
        (setq |y'|
                 (+ (+ (+ (+ 1 y) (|superspan| a))
                             (|subspan| b))
                       (cond
                         ((EQL 0 (|superspan| a)) 0)
                         (t (- 1)))))
        (APP b |x'| |y'| d)))))

;exptNeedsPren a ==
;  atom a and null (INTEGERP a and a < 0)  => false
;  key:= keyp a
;  key = "OVER" => true  -- added JHD 2/Aug/90
;  (key="SUB") or (null GET(key,"Nud") and null GET(key,"Led")) => false
;  true

(defun exptNeedsPren (a)
  (prog (|key|)
    (return
      (cond
        ((and (atom a) (NULL (and (INTEGERP a) (MINUSP a)))) nil)
        (t (setq |key| (keyp a))
         (cond
           ((eq |key| 'OVER) t)
           ((or (eq |key| 'SUB)
                (and (NULL (GETL |key| '|Nud|))
                     (NULL (GETL |key| '|Led|))))
            nil)
           (t t)))))))

;exptSub u == subspan CADR u

(defun |exptSub| (u) (|subspan| (CADR u)))

;exptSuper [.,a,b] == superspan a+height b+(superspan a=0 => 0;-1)

(defun |exptSuper| (G167664)
  (prog (a b)
    (return
      (progn
        (setq a (CADR G167664))
        (setq b (CADDR G167664))
        (+ (+ (|superspan| a) (|height| b))
              (cond
                ((EQL (|superspan| a) 0) 0)
                (t (- 1))))))))

;exptWidth [.,a,b] == WIDTH a+WIDTH b+(exptNeedsPren a => 2;0)

(defun |exptWidth| (G167679)
  (prog (a b)
    (return
      (progn
        (setq a (CADR G167679))
        (setq b (CADDR G167679))
        (+ (+ (width a) (width b))
              (cond ((exptNeedsPren a) 2) (t 0)))))))

;needStar(wasSimple,wasQuotient,wasNumber,cur,op) ==
;  wasQuotient or isQuotient op => true
;  wasSimple =>
;    atom cur or keyp cur="SUB" or isRationalNumber cur or op="**" or op = "^" or
;      (atom op and ^NUMBERP op and ^GET(op,"APP"))
;  wasNumber =>
;    NUMBERP(cur) or isRationalNumber cur or
;        ((op="**" or op ="^") and NUMBERP(CADR cur))

(defun needStar (|wasSimple| |wasQuotient| |wasNumber| |cur| |op|)
  (cond
    ((or |wasQuotient| (isQuotient |op|)) t)
    (|wasSimple|
        (or (atom |cur|) (eq (keyp |cur|) 'SUB)
            (isRationalNumber |cur|) (eq |op| '**)
            (eq |op| '^)
            (and (atom |op|) (NULL (NUMBERP |op|))
                 (NULL (GETL |op| 'APP)))))
    (|wasNumber|
        (or (NUMBERP |cur|) (isRationalNumber |cur|)
            (and (or (eq |op| '**) (eq |op| '^))
                 (NUMBERP (CADR |cur|)))))))

;isQuotient op ==
;  op="/" or op="OVER"

(defun isQuotient (|op|)
  (or (eq |op| '/) (eq |op| 'OVER)))

;timesWidth u ==
;  rightPrec:= getOpBindingPower("*","Led","right")
;  firstTime:= true
;  w:= 0
;  for arg in rest u repeat
;    op:= keyp arg
;    if ^firstTime and needStar(wasSimple,wasQuotient,wasNumber,arg,op) then
;      w:= w+1
;    if infixArgNeedsParens(arg, rightPrec, "left") then w:= w+2
;    w:= w+WIDTH arg
;    wasSimple:= atom arg and not NUMBERP arg --or isRationalNumber arg
;    wasQuotient:= isQuotient op
;    wasNumber:= NUMBERP arg
;    firstTime:= nil
;  w

(defun |timesWidth| (u)
  (prog (|rightPrec| |op| w |wasSimple| |wasQuotient| |wasNumber|
            |firstTime|)
    (return
      (seq (progn
             (setq |rightPrec|
                      (getOpBindingPower '* '|Led| '|right|))
             (setq |firstTime| t)
             (setq w 0)
             (do ((G167713 (CDR u) (CDR G167713)) (|arg| nil))
                 ((or (atom G167713)
                      (progn (setq |arg| (car G167713)) nil))
                  nil)
               (seq (exit (progn
                            (setq |op| (keyp |arg|))
                            (cond
                              ((and (NULL |firstTime|)
                                    (needStar |wasSimple|
                                     |wasQuotient| |wasNumber| |arg|
                                     |op|))
                               (setq w (+ w 1))))
                            (cond
                              ((infixArgNeedsParens |arg| |rightPrec|
                                   '|left|)
                               (setq w (+ w 2))))
                            (setq w (+ w (width |arg|)))
                            (setq |wasSimple|
                                     (and (atom |arg|)
                                      (NULL (NUMBERP |arg|))))
                            (setq |wasQuotient| (isQuotient |op|))
                            (setq |wasNumber| (NUMBERP |arg|))
                            (setq |firstTime| nil)))))
             w)))))

;plusApp([.,frst,:rst],x,y,d) ==
;  appSum(rst,x+WIDTH frst,y,APP(frst,x,y,d))

(defun |plusApp| (G167733 x y d)
  (prog (|frst| |rst|)
    (return
      (progn
        (setq |frst| (CADR G167733))
        (setq |rst| (CDDR G167733))
        (appSum |rst| (+ x (width |frst|)) y
            (APP |frst| x y d))))))

;appSum(u,x,y,d) ==
;  for arg in u repeat
;    infixOp:=
;      syminusp arg => "-"
;      "+"
;    opString:= GET(infixOp,"INFIXOP") or '","
;    d:= APP(opString,x,y,d)
;    x:= x+WIDTH opString
;    arg:= absym arg --negate a neg. number or remove leading "-"
;    rightPrec:= getOpBindingPower(infixOp,"Led","right")
;    if infixOp = "-" then rightPrec:=rightPrec  +1
;    -- that +1 added JHD 2 Aug 89 to prevent x-(y+z) printing as x-y+z
;    -- Sutor found the example:
;    -- )cl all
;    -- p : P[x] P I := x - y - z
;    -- p :: P[x] FR P I
;    -- trailingCoef %
;    [d,x]:= appInfixArg(arg,x,y,d,rightPrec,"left",nil) --app in a right arg
;  d

(defun appSum (u x y d)
  (prog (|infixOp| |opString| |rightPrec| |LETTMP#1|)
    (return
      (seq (progn
             (do ((G167771 u (CDR G167771)) (|arg| nil))
                 ((or (atom G167771)
                      (progn (setq |arg| (car G167771)) nil))
                  nil)
               (seq (exit (progn
                            (setq |infixOp|
                                     (cond
                                       ((syminusp |arg|) '-)
                                       (t '+)))
                            (setq |opString|
                                     (or (GETL |infixOp| 'INFIXOP)
                                      ","))
                            (setq d (APP |opString| x y d))
                            (setq x (+ x (width |opString|)))
                            (setq |arg| (absym |arg|))
                            (setq |rightPrec|
                                     (getOpBindingPower |infixOp|
                                      '|Led| '|right|))
                            (cond
                              ((eq |infixOp| '-)
                               (setq |rightPrec|
                                        (+ |rightPrec| 1))))
                            (setq |LETTMP#1|
                                     (appInfixArg |arg| x y d
                                      |rightPrec| '|left| nil))
                            (setq d (car |LETTMP#1|))
                            (setq x (CADR |LETTMP#1|))
                            |LETTMP#1|))))
             d)))))

;appInfix(e,x,y,d) ==
;  op := keyp e
;  leftPrec:= getOpBindingPower(op,"Led","left")
;  leftPrec = 1000 => return nil --no infix operator is allowed default value
;  rightPrec:= getOpBindingPower(op,"Led","right")
;  #e < 2 => throwKeyedMsg("S2IX0008",['appInfix,
;      '"fewer than 2 arguments to an infix function"])
;  opString:= GET(op,"INFIXOP") or '","
;  opWidth:= WIDTH opString
;  [.,frst,:rst]:= e
;  null rst =>
;    GET(op,"isSuffix") =>
;      [d,x]:= appInfixArg(frst,x,y,d,leftPrec,"right",opString)
;      d:= appChar(opString,x,y,d)
;    THROW('outputFailure,'outputFailure)
;  [d,x]:= appInfixArg(frst,x,y,d,leftPrec,"right",opString) --app in left arg
;  for arg in rst repeat
;    d:= appChar(opString,x,y,d) --app in the infix operator
;    x:= x+opWidth
;    [d,x]:= appInfixArg(arg,x,y,d,rightPrec,"left",opString) --app in right arg
;  d

(defun appInfix (|e| x y d)
  (prog (|op| |leftPrec| |rightPrec| |opString| opWidth |frst| |rst|
              |LETTMP#1|)
    (return
      (seq (progn
             (setq |op| (keyp |e|))
             (setq |leftPrec|
                      (getOpBindingPower |op| '|Led| '|left|))
             (cond
               ((EQL |leftPrec| 1000) (return nil))
               (t
                (setq |rightPrec|
                         (getOpBindingPower |op| '|Led| '|right|))
                (cond
                  ((QSLESSP (|#| |e|) 2)
                   (|throwKeyedMsg| 
                     "Internal system problem in function %1 : %2"
                       (cons 'appInfix
                             (cons "fewer than 2 arguments to an infix function"
                                   nil))))
                  (t
                   (setq |opString|
                            (or (GETL |op| 'INFIXOP) ","))
                   (setq opWidth (width |opString|))
                   (setq |frst| (CADR |e|))
                   (setq |rst| (CDDR |e|))
                   (cond
                     ((NULL |rst|)
                      (cond
                        ((GETL |op| '|isSuffix|)
                         (setq |LETTMP#1|
                                  (appInfixArg |frst| x y d
                                      |leftPrec| '|right| |opString|))
                         (setq d (car |LETTMP#1|))
                         (setq x (CADR |LETTMP#1|))
                         (setq d
                                  (appChar |opString| x y d)))
                        (t (THROW '|outputFailure| '|outputFailure|))))
                     (t
                      (setq |LETTMP#1|
                               (appInfixArg |frst| x y d
                                   |leftPrec| '|right| |opString|))
                      (setq d (car |LETTMP#1|))
                      (setq x (CADR |LETTMP#1|))
                      (do ((G167827 |rst| (CDR G167827)) (|arg| nil))
                          ((or (atom G167827)
                               (progn (setq |arg| (car G167827)) nil))
                           nil)
                        (seq (exit (progn
                                     (setq d
                                      (appChar |opString| x y
                                       d))
                                     (setq x (+ x opWidth))
                                     (setq |LETTMP#1|
                                      (appInfixArg |arg| x y d
                                       |rightPrec| '|left| |opString|))
                                     (setq d (car |LETTMP#1|))
                                     (setq x (CADR |LETTMP#1|))
                                     |LETTMP#1|))))
                      d)))))))))))

(defun appconc (d x y w)
  (NCONC d (cons (cons (cons x y) w) nil)))

;infixArgNeedsParens(arg, prec, leftOrRight) ==
;  prec > getBindingPowerOf(leftOrRight, arg) + 1

(defun infixArgNeedsParens (|arg| |prec| |leftOrRight|)
  (> |prec| (+ (getBindingPowerOf |leftOrRight| |arg|) 1)))

;appInfixArg(u,x,y,d,prec,leftOrRight,string) ==
;  insertPrensIfTrue:= infixArgNeedsParens(u,prec,leftOrRight)
;  d:=
;    insertPrensIfTrue => appparu(u,x,y,d)
;    APP(u,x,y,d)
;  x:= x+WIDTH u
;  if string then d:= appconc(d,x,y,string)
;  [d,(insertPrensIfTrue => x+2; x)]

(defun appInfixArg (u x y d |prec| |leftOrRight| |string|)
  (prog (|insertPrensIfTrue|)
    (return
      (progn
        (setq |insertPrensIfTrue|
                 (infixArgNeedsParens u |prec| |leftOrRight|))
        (setq d
                 (cond
                   (|insertPrensIfTrue| (|appparu| u x y d))
                   (t (APP u x y d))))
        (setq x (+ x (width u)))
        (cond
          (|string| (setq d (appconc d x y |string|))))
        (cons d
              (cons (cond (|insertPrensIfTrue| (+ x 2)) (t x))
                    nil))))))

;getBindingPowerOf(key,x) ==
;  --binding powers can be found in file NEWAUX LISP
;  x is ['REDUCE,:.] => (key='left => 130; key='right => 0)
;  x is ["REPEAT",:.] => (key="left" => 130; key="right" => 0)
;  x is ["COND",:.] => (key="left" => 130; key="right" => 0)
;  x is [op,:argl] =>
;    if op is [a,:.] then op:= a
;    op = 'SLASH => getBindingPowerOf(key,["/",:argl]) - 1
;    op = 'OVER  => getBindingPowerOf(key,["/",:argl])
;    (n:= #argl)=1 =>
;      key="left" and (m:= getOpBindingPower(op,"Nud","left")) => m
;      key="right" and (m:= getOpBindingPower(op,"Nud","right")) => m
;      1000
;    n>1 =>
;      key="left" and (m:= getOpBindingPower(op,"Led","left")) => m
;      key="right" and (m:= getOpBindingPower(op,"Led","right")) => m
;      op="ELT" => 1002
;      1000
;    1000
;  1002

(defun getBindingPowerOf (|key| x)
  (prog (|argl| a |op| n m)
    (return
      (cond
        ((and (consp x) (eq (qcar x) 'REDUCE))
         (cond
           ((eq |key| '|left|) 130)
           ((eq |key| '|right|) 0)))
        ((and (consp x) (eq (qcar x) 'REPEAT))
         (cond
           ((eq |key| '|left|) 130)
           ((eq |key| '|right|) 0)))
        ((and (consp x) (eq (qcar x) 'COND))
         (cond
           ((eq |key| '|left|) 130)
           ((eq |key| '|right|) 0)))
        ((and (consp x)
              (progn
                (setq |op| (qcar x))
                (setq |argl| (qcdr x))
                t))
         (cond
           ((and (consp |op|) (progn (setq a (qcar |op|)) t))
            (setq |op| a)))
         (cond
           ((eq |op| 'SLASH)
            (-
                (getBindingPowerOf |key| (cons '/ |argl|)) 1))
           ((eq |op| 'OVER)
            (getBindingPowerOf |key| (cons '/ |argl|)))
           ((EQL (setq n (|#| |argl|)) 1)
            (cond
              ((and (eq |key| '|left|)
                    (setq m
                             (getOpBindingPower |op| '|Nud| '|left|)))
               m)
              ((and (eq |key| '|right|)
                    (setq m
                             (getOpBindingPower |op| '|Nud| '|right|)))
               m)
              (t 1000)))
           ((> n 1)
            (cond
              ((and (eq |key| '|left|)
                    (setq m
                             (getOpBindingPower |op| '|Led| '|left|)))
               m)
              ((and (eq |key| '|right|)
                    (setq m
                             (getOpBindingPower |op| '|Led| '|right|)))
               m)
              ((eq |op| 'ELT) 1002)
              (t 1000)))
           (t 1000)))
        (t 1002)))))

;getOpBindingPower(op,LedOrNud,leftOrRight) ==
;  if op in '(SLASH OVER) then op := "/"
;  exception:=
;    leftOrRight="left" => 0
;    105
;  bp:=
;    leftOrRight="left" => leftBindingPowerOf(op,LedOrNud)
;    rightBindingPowerOf(op,LedOrNud)
;  bp^=exception => bp
;  1000

(defun getOpBindingPower (|op| |LedOrNud| |leftOrRight|)
  (prog (|exception| |bp|)
    (return
      (progn
        (cond ((|member| |op| '(SLASH OVER)) (setq |op| '/)))
        (setq |exception|
                 (cond
                   ((eq |leftOrRight| '|left|) 0)
                   (t 105)))
        (setq |bp|
                 (cond
                   ((eq |leftOrRight| '|left|)
                    (|leftBindingPowerOf| |op| |LedOrNud|))
                   (t (|rightBindingPowerOf| |op| |LedOrNud|))))
        (cond ((NEQUAL |bp| |exception|) |bp|) (t 1000))))))

;--% Brackets
;bracketApp(u,x,y,d) ==
;  u is [.,u] or THROW('outputFailure,'outputFailure)
;  d:= appChar(specialChar 'lbrk,x,y,d)
;  d:=APP(u,x+1,y,d)
;  appChar(specialChar 'rbrk,x+1+WIDTH u,y,d)

(defun |bracketApp| (u x y d)
  (prog (tmp1)
    (return
      (progn
        (or (and (consp u)
                 (progn
                   (setq tmp1 (qcdr u))
                   (and (consp tmp1) (eq (qcdr tmp1) nil)
                        (progn (setq u (qcar tmp1)) t))))
            (THROW '|outputFailure| '|outputFailure|))
        (setq d (appChar (|specialChar| '|lbrk|) x y d))
        (setq d (APP u (+ x 1) y d))
        (appChar (|specialChar| '|rbrk|)
            (+ (+ x 1) (width u)) y d)))))

;--% Braces
;braceApp(u,x,y,d) ==
;  u is [.,u] or THROW('outputFailure,'outputFailure)
;  d:= appChar(specialChar 'lbrc,x,y,d)
;  d:=APP(u,x+1,y,d)
;  appChar(specialChar 'rbrc,x+1+WIDTH u,y,d)

(defun |braceApp| (u x y d)
  (prog (tmp1)
    (return
      (progn
        (or (and (consp u)
                 (progn
                   (setq tmp1 (qcdr u))
                   (and (consp tmp1) (eq (qcdr tmp1) nil)
                        (progn (setq u (qcar tmp1)) t))))
            (THROW '|outputFailure| '|outputFailure|))
        (setq d (appChar (|specialChar| '|lbrc|) x y d))
        (setq d (APP u (+ x 1) y d))
        (appChar (|specialChar| '|rbrc|)
            (+ (+ x 1) (width u)) y d)))))

;--% Aggregates
;aggWidth u ==
;  rest u is [a,:l] => WIDTH a + +/[1+WIDTH x for x in l]
;  0

(defun |aggWidth| (u)
  (prog (tmp1 a |l|)
    (return
      (seq (cond
             ((progn
                (setq tmp1 (CDR u))
                (and (consp tmp1)
                     (progn
                       (setq a (qcar tmp1))
                       (setq |l| (qcdr tmp1))
                       t)))
              (+ (width a)
                    (prog (G167935)
                      (setq G167935 0)
                      (return
                        (do ((G167940 |l| (CDR G167940)) (x nil))
                            ((or (atom G167940)
                                 (progn (setq x (car G167940)) nil))
                             G167935)
                          (seq (exit (setq G167935
                                      (+ G167935
                                       (+ 1 (width x)))))))))))
             (t 0))))))

;aggSub u == subspan rest u

(defun |aggSub| (u) (|subspan| (CDR u)))

;aggSuper u == superspan rest u

(defun |aggSuper| (u) (|superspan| (CDR u)))

;aggApp(u,x,y,d) == aggregateApp(rest u,x,y,d,",")

(defun |aggApp| (u x y d)
  (aggregateApp (CDR u) x y d '|,|))

;aggregateApp(u,x,y,d,s) ==
;  if u is [a,:l] then
;    d:= APP(a,x,y,d)
;    x:= x+WIDTH a
;    for b in l repeat
;      d:= APP(s,x,y,d)
;      d:= APP(b,x+1,y,d)
;      x:= x+1+WIDTH b
;  d

(defun aggregateApp (u x y d |s|)
  (prog (a |l|)
    (return
      (seq (progn
             (cond
               ((and (consp u)
                     (progn
                       (setq a (qcar u))
                       (setq |l| (qcdr u))
                       t))
                (setq d (APP a x y d))
                (setq x (+ x (width a)))
                (do ((G167974 |l| (CDR G167974)) (b nil))
                    ((or (atom G167974)
                         (progn (setq b (car G167974)) nil))
                     nil)
                  (seq (exit (progn
                               (setq d (APP |s| x y d))
                               (setq d
                                        (APP b (+ x 1) y d))
                               (setq x
                                        (+ (+ x 1) (width b)))))))))
             d)))))

;--% Function to compute Width
;outformWidth u ==  --WIDTH as called from OUTFORM to do a COPY
;  STRINGP u =>
;    u = $EmptyString => 0
;    u.0="%" and ((u.1 = char 'b) or (u.1 = char 'd)) => 1
;    #u
;  atom u => # atom2String u
;  WIDTH COPY u

(defun |outformWidth| (u)
  (declare (special |$EmptyString|))
  (cond
    ((STRINGP u)
     (cond
       ((equal u |$EmptyString|) 0)
       ((and (eq (elt u 0) '%)
             (or (char= (elt u 1) #\b)
                 (char= (elt u 1) #\d)))
        1)
       (t (|#| u))))
    ((atom u) (|#| (|atom2String| u)))
    (t (width (COPY u)))))

;The purpose of the following function is to calculate the number of
;digits in the radix $B$ expansion of an arbitrary Lisp integer $n$.
;The width of an integer can be determined rapidly when the radix is a
;power of two, otherwise an approach based on successive divisions is
;used.
;
;We have a subfunction called ``power-of-two-width''.
;When the radix $B$ is of the form $2^b$, $b$ bits are needed to
;represent one radix $B$ digit. The radix $B$ width of $n$ is obtained
;by dividing the width of the binary representation of $n$ by $b$, and
;incrementing the result when the remainder is non-zero.
;
;We have a subfunction called ``digits-by-radix''.
;When the radix is not a power of two, we choose a power $p$ of the
;radix $B$ and use $B^p$ as a divisor.  Each division counts as $p$
;digits in the radix $B$ expansion.  The power, bound to the variable
;[[digits]] below, is chosen so that $B^p <$
;\texttt{most-positive-long-float}. This allows use of [[log]] to
;compute $p$ without concern for floating point overflow.  Once a
;quotient is produced which is smaller than the divisor, we complete
;the calculation by repeated divisions using the radix itself.

(defun digits-by-radix (n &optional (radix 10))
  (flet (
   (power-of-two-width (n radix)
    (let ((bits (integer-length n))
          (radix-bits (1- (integer-length radix))))
      (multiple-value-bind (quo rem) (floor bits radix-bits)
        (if (zerop rem) quo (1+ quo)))))
   (iterative-width (n radix)
     (multiple-value-bind (q width)
         (let* ((target (if (< n most-positive-long-float)
                            (values n)
                            (values most-positive-long-float)))
                (digits (let ((d (floor (log target radix))))
                          (if (zerop d) 1 d)))
                (div (expt radix digits)))
           (loop for q = n then (floor q div)
                 until (< q div) sum digits into width
                 finally (return (values q width))))
       (+ width (loop for r = q then (floor r radix)
                      until (zerop r) count t))))
      )
    (assert (>= radix 2) (radix) 
            "Bad radix ~D < 2 given to DIGITS-BY-RADIX." radix)
    (setq n (abs n))
    (cond
      ((zerop n) (values 1))
      ((zerop (logand radix (1- radix))) (power-of-two-width n radix))
      (t (iterative-width n radix)))))

;WIDTH u ==
;  STRINGP u =>
;    u = $EmptyString => 0
;    u.0="%" and ((u.1 = char 'b) or (u.1 = char 'd)) => 1
;    #u
;  INTEGERP u =>
;    u = 0 => 1
;    if (u < 1) then
;      negative := 1
;    else
;      negative := 0
;    DIGITS_-BY_-RADIX(u, 10) + negative
;  atom u => # atom2String u
;  putWidth u is [[.,:n],:.] => n
;  THROW('outputFailure,'outputFailure)

(defun width (u)
  (prog (|negative| tmp1 tmp2 n)
    (declare (special |$EmptyString|))
    (return
      (cond
        ((STRINGP u)
         (cond
           ((eq u |$EmptyString|) 0)
           ((and (eq (elt u 0) '%)
                 (or (char= (elt u 1) #\b)
                     (char= (elt u 1) #\d)))
            1)
           (t (|#| u))))
        ((INTEGERP u)
         (cond
           ((EQL u 0) 1)
           (t
            (cond
              ((> 1 u) (setq |negative| 1))
              (t (setq |negative| 0)))
            (+ (digits-by-radix u 10) |negative|))))
        ((atom u) (|#| (|atom2String| u)))
        ((progn
           (setq tmp1 (putWidth u))
           (and (consp tmp1)
                (progn
                  (setq tmp2 (qcar tmp1))
                  (and (consp tmp2)
                       (progn (setq n (qcdr tmp2)) t)))))
         n)
        (t (THROW '|outputFailure| '|outputFailure|))))))

;putWidth u ==
;  atom u or u is [[.,:n],:.] and NUMBERP n => u
;  op:= keyp u
;--NUMBERP op => nil
;  leftPrec:= getBindingPowerOf("left",u)
;  rightPrec:= getBindingPowerOf("right",u)
;  [firstEl,:l] := u
;  interSpace:=
;    GET(firstEl,"INFIXOP") => 0
;    1
;  argsWidth:=
;    l is [firstArg,:restArg] =>
;      RPLACA(rest u,putWidth firstArg)
;      for y in tails restArg repeat RPLACA(y,putWidth first y)
;      widthFirstArg:=
;        0=interSpace and infixArgNeedsParens(firstArg,leftPrec,"right")=>
;          2+WIDTH firstArg
;        WIDTH firstArg
;      widthFirstArg + +/[interSpace+w for x in restArg] where w ==
;        0=interSpace and infixArgNeedsParens(x, rightPrec, "left") =>
;          2+WIDTH x
;        WIDTH x
;    0
;  newFirst:=
;    atom (oldFirst:= first u) =>
;      fn:= GET(oldFirst,"WIDTH") =>
;        [oldFirst,:FUNCALL(fn,[oldFirst,:l])]
;      if l then ll := rest l else ll := nil
;      [oldFirst,:opWidth(oldFirst,ll)+argsWidth]
;    [putWidth oldFirst,:2+WIDTH oldFirst+argsWidth]
;  RPLACA(u,newFirst)
;  u

(defun putWidth (u)
  (prog (tmp1 n |op| |leftPrec| |rightPrec| |firstEl| |l|
            |interSpace| |firstArg| |restArg| |widthFirstArg|
            |argsWidth| |oldFirst| |fn| |ll| |newFirst|)
    (return
      (seq (cond
             ((or (atom u)
                  (and (consp u)
                       (progn
                         (setq tmp1 (qcar u))
                         (and (consp tmp1)
                              (progn
                                (setq n (qcdr tmp1))
                                t)))
                       (NUMBERP n)))
              u)
             (t (setq |op| (keyp u))
              (setq |leftPrec| (getBindingPowerOf '|left| u))
              (setq |rightPrec| (getBindingPowerOf '|right| u))
              (setq |firstEl| (car u)) (setq |l| (CDR u))
              (setq |interSpace|
                       (cond ((GETL |firstEl| 'INFIXOP) 0) (t 1)))
              (setq |argsWidth|
                       (cond
                         ((and (consp |l|)
                               (progn
                                 (setq |firstArg| (qcar |l|))
                                 (setq |restArg| (qcdr |l|))
                                 t))
                          (RPLACA (CDR u) (putWidth |firstArg|))
                          (do ((y |restArg| (CDR y)))
                              ((atom y) nil)
                            (seq (exit (RPLACA y
                                        (putWidth (car y))))))
                          (setq |widthFirstArg|
                                   (cond
                                     ((and (EQL 0 |interSpace|)
                                       (infixArgNeedsParens
                                        |firstArg| |leftPrec| '|right|))
                                      (+ 2 (width |firstArg|)))
                                     (t (width |firstArg|))))
                          (+ |widthFirstArg|
                                (prog (G168041)
                                  (setq G168041 0)
                                  (return
                                    (DO
                                     ((G168046 |restArg| (CDR G168046))
                                      (x nil))
                                     ((or (atom G168046)
                                       (progn
                                         (setq x (car G168046))
                                         nil))
                                      G168041)
                                      (SEQ
                                       (EXIT
                                        (setq G168041
                                         (+ G168041
                                          (+ |interSpace|
                                           (cond
                                             ((and (EQL 0 |interSpace|)
                                               (infixArgNeedsParens
                                                x |rightPrec|
                                                '|left|))
                                              (+ 2 (width x)))
                                             (t (width x)))))))))))))
                         (t 0)))
              (setq |newFirst|
                       (cond
                         ((atom (setq |oldFirst| (car u)))
                          (cond
                            ((setq |fn| (GETL |oldFirst| 'WIDTH))
                             (cons |oldFirst|
                                   (FUNCALL |fn| (cons |oldFirst| |l|))))
                            (t
                             (cond
                               (|l| (setq |ll| (CDR |l|)))
                               (t (setq |ll| nil)))
                             (cons |oldFirst|
                                   (+ (opWidth |oldFirst| |ll|)
                                    |argsWidth|)))))
                         (t
                          (cons (putWidth |oldFirst|)
                                (+ (+ 2 (width |oldFirst|))
                                      |argsWidth|)))))
              (RPLACA u |newFirst|) u))))))

;opWidth(op,has2Arguments) ==
;  op = "EQUATNUM" => 4
;  NUMBERP op => 2+SIZE princ-to-string op
;  null has2Arguments =>
;    a:= GET(op,"PREFIXOP") => SIZE a
;    2+SIZE PNAME op
;  a:= GET(op,"INFIXOP") => SIZE a
;  2+SIZE PNAME op

(defun opWidth (|op| |has2Arguments|)
  (prog (a)
    (return
      (cond
        ((eq |op| 'EQUATNUM) 4)
        ((NUMBERP |op|) (+ 2 (SIZE (princ-to-string |op|))))
        ((NULL |has2Arguments|)
         (cond
           ((setq a (GETL |op| 'PREFIXOP)) (SIZE a))
           (t (+ 2 (SIZE (PNAME |op|))))))
        ((setq a (GETL |op| 'INFIXOP)) (SIZE a))
        (t (+ 2 (SIZE (PNAME |op|))))))))

;matrixBorder(x,y1,y2,d,leftOrRight) ==
;  y1 = y2 =>
;    c :=
;      leftOrRight = 'left => specialChar('lbrk)
;      specialChar('rbrk)
;    APP(c,x,y1,d)
;  for y in y1..y2 repeat
;    c :=
;      y = y1 =>
;        leftOrRight = 'left => specialChar('llc)
;        specialChar('lrc)
;      y = y2 =>
;        leftOrRight = 'left => specialChar('ulc)
;        specialChar('urc)
;      specialChar('vbar)
;    d := APP(c,x,y,d)
;  d

(defun matrixBorder (x |y1| |y2| d |leftOrRight|)
  (prog (|c|)
    (return
      (seq (cond
             ((equal |y1| |y2|)
              (setq |c|
                       (cond
                         ((eq |leftOrRight| '|left|)
                          (|specialChar| '|lbrk|))
                         (t (|specialChar| '|rbrk|))))
              (APP |c| x |y1| d))
             (t
              (do ((y |y1| (+ y 1))) ((> y |y2|) nil)
                (seq (exit (progn
                             (setq |c|
                                      (cond
                                        ((equal y |y1|)
                                         (cond
                                           ((eq |leftOrRight|
                                             '|left|)
                                            (|specialChar| '|llc|))
                                           (t (|specialChar| '|lrc|))))
                                        ((equal y |y2|)
                                         (cond
                                           ((eq |leftOrRight|
                                             '|left|)
                                            (|specialChar| '|ulc|))
                                           (t (|specialChar| '|urc|))))
                                        (t (|specialChar| '|vbar|))))
                             (setq d (APP |c| x y d))))))
              d))))))

;isRationalNumber x == nil

(defun isRationalNumber (x)
 (declare (ignore x))
 nil) 

;widthSC u == 10000

(defun |widthSC| (u)
 (declare (ignore u))
 10000) 

;--% The over-large matrix package
;maprinSpecial(x,$MARGIN,$LINELENGTH) == maprin0 x

(defun |maprinSpecial| (x $MARGIN $LINELENGTH)
  (declare (special $MARGIN $LINELENGTH))
  (maprin0 x))

(defun maprin2 (x)
  (declare (special |$demoFlag|))
    (when |$demoFlag| (|recordOrCompareDemoResult| x))
    (catch '|output| (maprin0 x)))

;maprin0 x ==
;  $MatrixCount:local :=0
;  $MatrixList:local :=nil
;  maprinChk x
;  if $MatrixList then maprinRows $MatrixList

(defun maprin0 (x)
  (prog (|$MatrixCount| |$MatrixList|)
    (declare (special |$MatrixCount| |$MatrixList|))
    (return
      (progn
        (setq |$MatrixCount| 0)
        (setq |$MatrixList| nil)
        (maprinChk x)
        (cond (|$MatrixList| (maprinRows |$MatrixList|)) (t nil))))))

;maprinChk x ==
;  null $MatrixList => maPrin x
;  ATOM x and (u:= ASSOC(x,$MatrixList)) =>
;    $MatrixList := delete(u,$MatrixList)
;    maPrin deMatrix CDR u
;  x is ["=",arg,y]  =>     --case for tracing with )math and printing matrices
;    u:=ASSOC(y,$MatrixList) =>
;      -- we don't want to print matrix1 = matrix2 ...
;      $MatrixList := delete(u,$MatrixList)
;      maPrin ["=",arg, deMatrix CDR u]
;    maPrin x
;  x is ['EQUATNUM,n,y] =>
;    $MatrixList is [[name,:value]] and y=name =>
;      $MatrixList:=[]   -- we are pulling this one off
;      maPrin ['EQUATNUM,n, deMatrix value]
;    IDENTP y => --------this part is never called
;      -- Not true: JHD 28/2/93
;      -- m:=[[1,2,3],[4,5,6],[7,8,9]]
;      -- mm:=[[m,1,0],[0,m,1],[0,1,m]]
;      -- and try to print mm**5
;      u := ASSOC(y,$MatrixList)
;      --$MatrixList := deleteAssoc(first u,$MatrixList)
;      -- deleteAssoc no longer exists
;      $MatrixList := delete(u,$MatrixList)
;      maPrin ['EQUATNUM,n,rest u]
;      if ^$collectOutput then TERPRI $algebraOutputStream
;    maPrin x
;  maPrin x

(defun maprinChk (x)
  (prog (|arg| n tmp2 y tmp1 |name| |value| u)
    (declare (special |$algebraOutputStream| |$collectOutput|
                      |$MatrixList|))
    (return
      (cond
        ((NULL |$MatrixList|) (maPrin x))
        ((and (atom x) (setq u (|assoc| x |$MatrixList|)))
         (setq |$MatrixList| (|delete| u |$MatrixList|))
         (maPrin (deMatrix (CDR u))))
        ((and (consp x) (eq (qcar x) '=)
              (progn
                (setq tmp1 (qcdr x))
                (and (consp tmp1)
                     (progn
                       (setq |arg| (qcar tmp1))
                       (setq tmp2 (qcdr tmp1))
                       (and (consp tmp2) (eq (qcdr tmp2) nil)
                            (progn (setq y (qcar tmp2)) t))))))
         (cond
           ((setq u (|assoc| y |$MatrixList|))
            (setq |$MatrixList| (|delete| u |$MatrixList|))
            (maPrin
                (cons '=
                      (cons |arg| (cons (deMatrix (CDR u)) nil)))))
           (t (maPrin x))))
        ((and (consp x) (eq (qcar x) 'EQUATNUM)
              (progn
                (setq tmp1 (qcdr x))
                (and (consp tmp1)
                     (progn
                       (setq n (qcar tmp1))
                       (setq tmp2 (qcdr tmp1))
                       (and (consp tmp2) (eq (qcdr tmp2) nil)
                            (progn (setq y (qcar tmp2)) t))))))
         (cond
           ((and (consp |$MatrixList|) (eq (qcdr |$MatrixList|) nil)
                 (progn
                   (setq tmp1 (qcar |$MatrixList|))
                   (and (consp tmp1)
                        (progn
                          (setq |name| (qcar tmp1))
                          (setq |value| (qcdr tmp1))
                          t)))
                 (equal y |name|))
            (setq |$MatrixList| nil)
            (maPrin
                (cons 'EQUATNUM
                      (cons n (cons (deMatrix |value|) nil)))))
           ((IDENTP y) (setq u (|assoc| y |$MatrixList|))
            (setq |$MatrixList| (|delete| u |$MatrixList|))
            (maPrin (cons 'EQUATNUM (cons n (cons (CDR u) nil))))
            (cond
              ((NULL |$collectOutput|) (TERPRI |$algebraOutputStream|))
              (t nil)))
           (t (maPrin x))))
        (t (maPrin x))))))

;maprinRows matrixList ==
;  if ^$collectOutput then TERPRI($algebraOutputStream)
;  while matrixList repeat
;    y:=NREVERSE matrixList
;    --Makes the matrices come out in order, since CONSed on backwards
;    matrixList:=nil
;    firstName := first first y
;    for [name,:m] in y for n in 0.. repeat
;      if ^$collectOutput then TERPRI($algebraOutputStream)
;      andWhere := (name = firstName => '"where "; '"and ")
;      line := STRCONC(andWhere, PNAME name)
;      maprinChk ["=",line,m]

(defun maprinRows (|matrixList|)
  (prog (y |firstName| |name| m |andWhere| |line|)
    (declare (special |$algebraOutputStream| |$collectOutput|))
    (return
      (seq (progn
             (cond
               ((NULL |$collectOutput|)
                (TERPRI |$algebraOutputStream|)))
             (do () ((NULL |matrixList|) nil)
               (seq (exit (progn
                            (setq y (nreverse |matrixList|))
                            (setq |matrixList| nil)
                            (setq |firstName| (car (car y)))
                            (do ((G168227 y (CDR G168227))
                                 (G168195 nil) (n 0 (QSADD1 n)))
                                ((or (atom G168227)
                                     (progn
                                       (setq G168195 (car G168227))
                                       nil)
                                     (progn
                                       (progn
                                         (setq |name| (car G168195))
                                         (setq m (CDR G168195))
                                         G168195)
                                       nil))
                                 nil)
                              (seq (EXIT
                                    (progn
                                      (cond
                                        ((NULL |$collectOutput|)
                                         (TERPRI
                                          |$algebraOutputStream|)))
                                      (setq |andWhere|
                                       (cond
                                         ((equal |name|
                                           |firstName|)
                                          "where ")
                                         (t "and ")))
                                      (setq |line|
                                       (STRCONC |andWhere|
                                        (PNAME |name|)))
                                      (maprinChk
                                       (cons '=
                                    (cons |line| (cons m nil)))))))))))))))))

; -- note that this could place a new element on $MatrixList, hence the loop

;deMatrix m ==
;    ['BRACKET,['AGGLST,
;        :[['BRACKET,['AGGLST,:rest row]] for row in CDDR m]]]

(defun deMatrix (m)
  (prog ()
    (return
      (seq (cons 'BRACKET
                 (cons (cons 'AGGLST
                             (prog (G168248)
                               (setq G168248 nil)
                               (return
                                 (do ((G168253 (CDDR m)
                                       (CDR G168253))
                                      (|row| nil))
                                     ((or (atom G168253)
                                       (progn
                                         (setq |row| (car G168253))
                                         nil))
                                      (NREVERSE0 G168248))
                                   (SEQ
                                    (EXIT
                                     (setq G168248
                                      (CONS
                                       (cons 'BRACKET
                                        (CONS
                                         (cons 'AGGLST (CDR |row|))
                                         nil))
                                       G168248))))))))
                       nil))))))

;LargeMatrixp(u,width, dist) ==
;  --  sees if there is a matrix wider than 'width' in the next 'dist'
;  --  part of u, a sized charybdis structure.
;  --  NIL if not, first such matrix if there is one
;  ATOM u => nil
;  CDAR u <= width => nil
;       --CDAR is the width of a charybdis structure
;  op:=CAAR u
;  op = 'MATRIX => largeMatrixAlist u
;         --We already know the structure is more than 'width' wide
;  MEMQ(op,'(LET RARROW SEGMENT _- CONCAT CONCATB PAREN BRACKET BRACE)) =>
;      --Each of these prints the arguments in a width 3 smaller
;    dist:=dist-3
;    width:=width-3
;    ans:=
;      for v in CDR u repeat
;        (ans:=LargeMatrixp(v,width,dist)) => return largeMatrixAlist ans
;        dist:=dist - WIDTH v
;        dist<0 => return nil
;    ans
;      --Relying that falling out of a loop gives nil
;  MEMQ(op,'(_+ _* )) =>
;      --Each of these prints the first argument in a width 3 smaller
;    (ans:=LargeMatrixp(CADR u,width-3,dist)) => largeMatrixAlist ans
;    n:=3+WIDTH CADR u
;    dist:=dist-n
;    ans:=
;      for v in CDDR u repeat
;        (ans:=LargeMatrixp(v,width,dist)) => return largeMatrixAlist ans
;        dist:=dist - WIDTH v
;        dist<0 => return nil
;    ans
;      --Relying that falling out of a loop gives nil
;  ans:=
;    for v in CDR u repeat
;      (ans:=LargeMatrixp(v,width,dist)) => return largeMatrixAlist ans
;      dist:=dist - WIDTH v
;      dist<0 => return nil
;  ans

(defun LargeMatrixp (u width |dist|)
  (prog (|op| n |ans|)
    (return
      (seq (cond
             ((atom u) nil)
             ((<= (CDAR u) width) nil)
             (t (setq |op| (CAAR u))
              (cond
                ((eq |op| 'MATRIX) (largeMatrixAlist u))
                ((member |op|
                       '(LET RARROW
                          SEGMENT
                          -
                          CONCAT
                          CONCATB
                          PAREN
                          BRACKET
                          BRACE))
                 (setq |dist| (- |dist| 3))
                 (setq width (- width 3))
                 (setq |ans|
                          (do ((G168272 (CDR u) (CDR G168272))
                               (v nil))
                              ((or (atom G168272)
                                   (progn
                                     (setq v (car G168272))
                                     nil))
                               nil)
                            (seq (exit (cond
                                         ((setq |ans|
                                           (LargeMatrixp v width
                                            |dist|))
                                          (return
                                            (largeMatrixAlist |ans|)))
                                         (t
                                          (setq |dist|
                                           (- |dist|
                                            (width v)))
                                          (cond
                                            ((MINUSP |dist|)
                                             (return nil)))))))))
                 |ans|)
                ((member |op| '(+ *))
                 (cond
                   ((setq |ans|
                             (LargeMatrixp (CADR u)
                                 (- width 3) |dist|))
                    (largeMatrixAlist |ans|))
                   (t (setq n (+ 3 (width (CADR u))))
                    (setq |dist| (- |dist| n))
                    (setq |ans|
                             (do ((G168281 (CDDR u) (CDR G168281))
                                  (v nil))
                                 ((or (atom G168281)
                                      (progn
                                        (setq v (car G168281))
                                        nil))
                                  nil)
                               (seq (EXIT
                                     (cond
                                       ((setq |ans|
                                         (LargeMatrixp v width
                                          |dist|))
                                        (return
                                          (largeMatrixAlist |ans|)))
                                       (t
                                        (setq |dist|
                                         (- |dist|
                                          (width v)))
                                        (cond
                                          ((MINUSP |dist|)
                                           (return nil)))))))))
                    |ans|)))
                (t
                 (setq |ans|
                          (do ((G168290 (CDR u) (CDR G168290))
                               (v nil))
                              ((or (atom G168290)
                                   (progn
                                     (setq v (car G168290))
                                     nil))
                               nil)
                            (seq (exit (cond
                                         ((setq |ans|
                                           (LargeMatrixp v width
                                            |dist|))
                                          (return
                                            (largeMatrixAlist |ans|)))
                                         (t
                                          (setq |dist|
                                           (- |dist|
                                            (width v)))
                                          (cond
                                            ((MINUSP |dist|)
                                             (return nil)))))))))
                 |ans|))))))))

;    --Relying that falling out of a loop gives nil
;largeMatrixAlist u ==
;  u is [op,:r] =>
;    op is ['MATRIX,:.] => deMatrix u
;    largeMatrixAlist op or largeMatrixAlist r
;  nil

(defun largeMatrixAlist (u)
  (prog (|op| |r|)
    (return
      (cond
        ((and (consp u)
              (progn
                (setq |op| (qcar u))
                (setq |r| (qcdr u))
                t))
         (cond
           ((and (consp |op|) (eq (qcar |op|) 'MATRIX))
            (deMatrix u))
           (t (or (largeMatrixAlist |op|) (largeMatrixAlist |r|)))))
        (t nil)))))

;PushMatrix m ==
;    --Adds the matrix to the look-aside list, and returns a name for it
;  name:=
;    for v in $MatrixList repeat
;        EQUAL(m,CDR v) => return CAR v
;  name => name
;  name:=INTERNL('"matrix",princ-to-string($MatrixCount:=$MatrixCount+1))
;  $MatrixList:=[[name,:m],:$MatrixList]
;  name

(defun PushMatrix (m)
  (prog (|name|)
    (declare (special |$MatrixList| |$MatrixCount|))
    (return
      (seq (setq |name|
                    (do ((G168328 |$MatrixList| (CDR G168328))
                         (v nil))
                        ((or (atom G168328)
                             (progn (setq v (car G168328)) nil))
                         nil)
                      (seq (exit (cond
                                   ((equal m (CDR v))
                                    (exit (return (car v)))))))))
           (cond (|name| (exit |name|)))
           (setq |name|
                    (INTERNL "matrix"
                             (princ-to-string
                                 (setq |$MatrixCount|
                                          (+ |$MatrixCount| 1)))))
           (setq |$MatrixList|
                    (cons (cons |name| m) |$MatrixList|))
           (exit |name|)))))

;quoteApp([.,a],x,y,d) == APP(a,x+1,y,appChar(PNAME "'",x,y,d))

(defun |quoteApp| (G168341 x y d)
  (prog (a)
    (return
      (progn
        (setq a (CADR G168341))
        (APP a (+ x 1) y (appChar (PNAME '|'|) x y d))))))

;quoteSub [.,a] == subspan a

(defun |quoteSub| (G168352)
  (prog (a)
    (return (progn (setq a (CADR G168352)) (|subspan| a)))))

;quoteSuper [.,a] == superspan a

(defun |quoteSuper| (G168363)
  (prog (a)
    (return (progn (setq a (CADR G168363)) (|superspan| a)))))

;quoteWidth [.,a] == 1 + WIDTH a

(defun |quoteWidth| (G168374)
  (prog (a)
    (return (progn (setq a (CADR G168374)) (+ 1 (width a))))))

;SubstWhileDesizing(u,m) ==
;    -- arg. m is always nil (historical: EU directive to increase argument lists 1991/XGII)
;    --Replaces all occurrences of matrix m by name in u
;    --Taking out any outdated size information as it goes
;  ATOM u => u
;  [[op,:n],:l]:=u
;  --name := RASSOC(u,$MatrixList) => name
;  -- doesn't work since RASSOC seems to use an EQ test, and returns the
;  -- pair anyway. JHD 28/2/93
;  op = 'MATRIX =>
;    l':=SubstWhileDesizingList(CDR l,m)
;    u :=
;      -- CDR l=l' => u
;      -- this was a CONS-saving optimisation, but it doesn't work JHD 28/2/93
;      [op,nil,:l']
;    PushMatrix u
;  l':=SubstWhileDesizingList(l,m)
;  -- [op,:l']
;  ATOM op => [op,:l']
;  [SubstWhileDesizing(op,m),:l']

(defun SubstWhileDesizing (u m)
  (prog (|op| n |l| |l'|)
    (return
      (cond
        ((atom u) u)
        (t (setq |op| (CAAR u)) (setq n (CDAR u))
         (setq |l| (CDR u))
         (cond
           ((eq |op| 'MATRIX)
            (setq |l'| (SubstWhileDesizingList (CDR |l|) m))
            (setq u (cons |op| (cons NIL |l'|)))
            (PushMatrix u))
           (t (setq |l'| (SubstWhileDesizingList |l| m))
            (cond
              ((atom |op|) (cons |op| |l'|))
              (t (cons (SubstWhileDesizing |op| m) |l'|))))))))))

;--;SubstWhileDesizingList(u,m) ==
;--;  -- m is always nil (historical)
;--;  u is [a,:b] =>
;--;    a':=SubstWhileDesizing(a,m)
;--;    b':=SubstWhileDesizingList(b,m)
;--;-- MCD & TTT think that this test is unnecessary and expensive
;--;--    a=a' and b=b' => u
;--;    [a',:b']
;--;  u
;SubstWhileDesizingList(u,m) ==
;   u is [a,:b] =>
;     res:=
;       ATOM a => [a]
;       [SubstWhileDesizing(a,m)]
;     tail:=res
;     for i in b repeat
;        if ATOM i then  RPLACD(tail,[i]) else RPLACD(tail,[SubstWhileDesizing(i,m)])
;        tail:=CDR tail
;     res
;   u

(defun SubstWhileDesizingList (u m)
  (prog (a b |res| |tail|)
    (return
      (seq (cond
             ((and (consp u)
                   (progn
                     (setq a (qcar u))
                     (setq b (qcdr u))
                     t))
              (setq |res|
                       (cond
                         ((atom a) (cons a nil))
                         (t (cons (SubstWhileDesizing a m) nil))))
              (setq |tail| |res|)
              (do ((G168412 b (CDR G168412)) (|i| nil))
                  ((or (atom G168412)
                       (progn (setq |i| (car G168412)) nil))
                   nil)
                (seq (exit (progn
                             (cond
                               ((atom |i|)
                                (RPLACD |tail| (cons |i| nil)))
                               (t
                                (RPLACD |tail|
                                        (CONS
                                         (SubstWhileDesizing |i| m)
                                         nil))))
                             (setq |tail| (CDR |tail|))))))
              |res|)
             (t u))))))

;--% Printing of Sigmas , Pis and Intsigns
;sigmaSub u ==
;       --The depth function for sigmas with lower limit only
;  MAX(1 + height CADR u, subspan CADDR u)

(defun |sigmaSub| (u)
  (MAX (+ 1 (|height| (CADR u))) (|subspan| (CADDR u))))

;sigmaSup u ==
;       --The height function for sigmas with lower limit only
;  MAX(1, superspan CADDR u)

(defun |sigmaSup| (u) (MAX 1 (|superspan| (CADDR u))))

;sigmaApp(u,x,y,d) ==
;  u is [.,bot,arg] or THROW('outputFailure,'outputFailure)
;  bigopAppAux(bot,nil,arg,x,y,d,'sigma)

(defun |sigmaApp| (u x y d)
  (prog (tmp1 |bot| tmp2 |arg|)
    (return
      (progn
        (or (and (consp u)
                 (progn
                   (setq tmp1 (qcdr u))
                   (and (consp tmp1)
                        (progn
                          (setq |bot| (qcar tmp1))
                          (setq tmp2 (qcdr tmp1))
                          (and (consp tmp2)
                               (eq (qcdr tmp2) nil)
                               (progn
                                 (setq |arg| (qcar tmp2))
                                 t))))))
            (THROW '|outputFailure| '|outputFailure|))
        (bigopAppAux |bot| NIL |arg| x y d '|sigma|)))))

;sigma2App(u,x,y,d) ==
;  [.,bot,top,arg]:=u
;  bigopAppAux(bot,top,arg,x,y,d,'sigma)

(defun |sigma2App| (u x y d)
  (prog (|bot| |top| |arg|)
    (return
      (progn
        (setq |bot| (CADR u))
        (setq |top| (CADDR u))
        (setq |arg| (CADDDR u))
        (bigopAppAux |bot| |top| |arg| x y d '|sigma|)))))

;bigopWidth(bot,top,arg,kind) ==
;  kindWidth := (kind = 'pi => 5; 3)
;  MAX(kindWidth,WIDTH bot,(top => WIDTH top; 0)) + 2 + WIDTH arg

(defun bigopWidth (|bot| |top| |arg| |kind|)
  (prog (|kindWidth|)
    (return
      (progn
        (setq |kindWidth|
                 (cond ((eq |kind| '|pi|) 5) (t 3)))
        (+ (+ (MAX |kindWidth| (width |bot|)
                         (cond (|top| (width |top|)) (t 0)))
                    2)
              (width |arg|))))))

;bigopAppAux(bot,top,arg,x,y,d,kind) ==
;  botWidth := (bot => WIDTH bot; 0)
;  topWidth := WIDTH top
;  opWidth :=
;    kind = 'pi => 5
;    3
;  maxWidth := MAX(opWidth,botWidth,topWidth)
;  xCenter := (maxWidth-1)/ 2 + x
;  d:=APP(arg,x+2+maxWidth,y,d)
;  d:=
;      atom bot and SIZE atom2String bot = 1 => APP(bot,xCenter,y-2,d)
;      APP(bot,x + (maxWidth - botWidth)/2,y-2-superspan bot,d)
;  if top then
;    d:=
;      atom top and SIZE atom2String top = 1 => APP(top,xCenter,y+2,d)
;      APP(top,x + (maxWidth - topWidth)/2,y+2+subspan top,d)
;  delta := (kind = 'pi => 2; 1)
;  opCode :=
;    kind = 'sigma =>
;      [['(0 .  0),:'">"],_
;       ['(0 .  1),:specialChar('hbar)],_
;       ['(0 . -1),:specialChar('hbar)],_
;       ['(1 .  1),:specialChar('hbar)],_
;       ['(1 . -1),:specialChar('hbar)],_
;       ['(2 .  1),:specialChar('urc )],_
;       ['(2 . -1),:specialChar('lrc )]]
;    kind = 'pi =>
;      [['(0 .  1),:specialChar('ulc )],_
;       ['(1 .  0),:specialChar('vbar)],_
;       ['(1 .  1),:specialChar('ttee)],_
;       ['(1 . -1),:specialChar('vbar)],_
;       ['(2 .  1),:specialChar('hbar)],_
;       ['(3 .  0),:specialChar('vbar)],_
;       ['(3 .  1),:specialChar('ttee)],_
;       ['(3 . -1),:specialChar('vbar)],_
;       ['(4 .  1),:specialChar('urc )]]
;    THROW('outputFailure,'outputFailure)
;  xLate(opCode,xCenter - delta,y,d)

(defun bigopAppAux (|bot| |top| |arg| x y d |kind|)
  (prog (|botWidth| |topWidth| opWidth |maxWidth| |xCenter| |delta|
            |opCode|)
    (return
      (progn
        (setq |botWidth| (cond (|bot| (width |bot|)) (t 0)))
        (setq |topWidth| (width |top|))
        (setq opWidth (cond ((eq |kind| '|pi|) 5) (t 3)))
        (setq |maxWidth| (MAX opWidth |botWidth| |topWidth|))
        (setq |xCenter|
                 (+ (QUOTIENT (- |maxWidth| 1) 2) x))
        (setq d
                 (APP |arg| (+ (+ x 2) |maxWidth|) y d))
        (setq d
                 (cond
                   ((and (atom |bot|)
                         (EQL (SIZE (|atom2String| |bot|)) 1))
                    (APP |bot| |xCenter| (- y 2) d))
                   (t
                    (APP |bot|
                         (+ x
                               (QUOTIENT
                                   (- |maxWidth|
                                    |botWidth|)
                                   2))
                         (- (- y 2)
                             (|superspan| |bot|))
                         d))))
        (cond
          (|top| (setq d
                          (cond
                            ((and (atom |top|)
                                  (EQL (SIZE (|atom2String| |top|)) 1))
                             (APP |top| |xCenter| (+ y 2) d))
                            (t
                             (APP |top|
                                  (+ x
                                        (QUOTIENT
                                         (- |maxWidth|
                                          |topWidth|)
                                         2))
                                  (+ (+ y 2) (|subspan| |top|))
                                  d))))))
        (setq |delta| (cond ((eq |kind| '|pi|) 2) (t 1)))
        (setq |opCode|
                 (cond
                   ((eq |kind| '|sigma|)
                    (cons (cons '(0 . 0) ">")
                          (cons (cons '(0 . 1) (|specialChar| '|hbar|))
                                (cons (cons '(0 . -1)
                                       (|specialChar| '|hbar|))
                                      (CONS
                                       (cons '(1 . 1)
                                        (|specialChar| '|hbar|))
                                       (CONS
                                        (cons '(1 . -1)
                                         (|specialChar| '|hbar|))
                                        (CONS
                                         (cons '(2 . 1)
                                          (|specialChar| '|urc|))
                                         (CONS
                                          (cons '(2 . -1)
                                           (|specialChar| '|lrc|))
                                          nil))))))))
                   ((eq |kind| '|pi|)
                    (cons (cons '(0 . 1) (|specialChar| '|ulc|))
                          (cons (cons '(1 . 0) (|specialChar| '|vbar|))
                                (cons (cons '(1 . 1)
                                       (|specialChar| '|ttee|))
                                      (CONS
                                       (cons '(1 . -1)
                                        (|specialChar| '|vbar|))
                                       (CONS
                                        (cons '(2 . 1)
                                         (|specialChar| '|hbar|))
                                        (CONS
                                         (cons '(3 . 0)
                                          (|specialChar| '|vbar|))
                                         (CONS
                                          (cons '(3 . 1)
                                           (|specialChar| '|ttee|))
                                          (CONS
                                           (cons '(3 . -1)
                                            (|specialChar| '|vbar|))
                                           (CONS
                                            (cons '(4 . 1)
                                             (|specialChar| '|urc|))
                                            nil))))))))))
                   (t (THROW '|outputFailure| '|outputFailure|))))
        (xLate |opCode| (- |xCenter| |delta|) y d)))))

;sigmaWidth [.,bot,arg] == bigopWidth(bot,nil,arg,'sigma)

(defun |sigmaWidth| (G168494)
  (prog (|bot| |arg|)
    (return
      (progn
        (setq |bot| (CADR G168494))
        (setq |arg| (CADDR G168494))
        (bigopWidth |bot| NIL |arg| '|sigma|)))))

;sigma2Width [.,bot,top,arg] == bigopWidth(bot,top,arg,'sigma)

(defun |sigma2Width| (G168508)
  (prog (|bot| |top| |arg|)
    (return
      (progn
        (setq |bot| (CADR G168508))
        (setq |top| (CADDR G168508))
        (setq |arg| (CADDDR G168508))
        (bigopWidth |bot| |top| |arg| '|sigma|)))))

;sigma2Sub u ==
;       --The depth function for sigmas with 2 limits
;  MAX(1 + height CADR u, subspan CADDDR u)

(defun |sigma2Sub| (u)
  (MAX (+ 1 (|height| (CADR u))) (|subspan| (CADDDR u))))

;sigma2Sup u ==
;       --The depth function for sigmas with 2 limits
;  MAX(1 + height CADDR u, superspan CADDDR u)

(defun |sigma2Sup| (u)
  (MAX (+ 1 (|height| (CADDR u))) (|superspan| (CADDDR u))))

;piSub u ==
;       --The depth function for pi's (products)
;  MAX(1 + height CADR u, subspan CADDR u)

(defun |piSub| (u)
  (MAX (+ 1 (|height| (CADR u))) (|subspan| (CADDR u))))

;piSup u ==
;       --The height function for pi's (products)
;  MAX(1, superspan CADDR u)

(defun |piSup| (u) (MAX 1 (|superspan| (CADDR u))))

;piApp(u,x,y,d) ==
;  u is [.,bot,arg] or THROW('outputFailure,'outputFailure)
;  bigopAppAux(bot,nil,arg,x,y,d,'pi)

(defun |piApp| (u x y d)
  (prog (tmp1 |bot| tmp2 |arg|)
    (return
      (progn
        (or (and (consp u)
                 (progn
                   (setq tmp1 (qcdr u))
                   (and (consp tmp1)
                        (progn
                          (setq |bot| (qcar tmp1))
                          (setq tmp2 (qcdr tmp1))
                          (and (consp tmp2)
                               (eq (qcdr tmp2) nil)
                               (progn
                                 (setq |arg| (qcar tmp2))
                                 t))))))
            (THROW '|outputFailure| '|outputFailure|))
        (bigopAppAux |bot| NIL |arg| x y d '|pi|)))))

;piWidth [.,bot,arg] == bigopWidth(bot,nil,arg,'pi)

(defun |piWidth| (G168561)
  (prog (|bot| |arg|)
    (return
      (progn
        (setq |bot| (CADR G168561))
        (setq |arg| (CADDR G168561))
        (bigopWidth |bot| NIL |arg| '|pi|)))))

;pi2Width [.,bot,top,arg] == bigopWidth(bot,top,arg,'pi)

(defun |pi2Width| (G168575)
  (prog (|bot| |top| |arg|)
    (return
      (progn
        (setq |bot| (CADR G168575))
        (setq |top| (CADDR G168575))
        (setq |arg| (CADDDR G168575))
        (bigopWidth |bot| |top| |arg| '|pi|)))))

;pi2Sub u ==
;       --The depth function for pi's with 2 limits
;  MAX(1 + height CADR u, subspan CADDDR u)

(defun |pi2Sub| (u)
  (MAX (+ 1 (|height| (CADR u))) (|subspan| (CADDDR u))))

;pi2Sup u ==
;       --The depth function for pi's with 2 limits
;  MAX(1 + height CADDR u, superspan CADDDR u)

(defun |pi2Sup| (u)
  (MAX (+ 1 (|height| (CADDR u))) (|superspan| (CADDDR u))))

;pi2App(u,x,y,d) ==
;  [.,bot,top,arg]:=u
;  bigopAppAux(bot,top,arg,x,y,d,'pi)

(defun |pi2App| (u x y d)
  (prog (|bot| |top| |arg|)
    (return
      (progn
        (setq |bot| (CADR u))
        (setq |top| (CADDR u))
        (setq |arg| (CADDDR u))
        (bigopAppAux |bot| |top| |arg| x y d '|pi|)))))

;overlabelSuper [.,a,b] == 1 + height a + superspan b

(defun |overlabelSuper| (G168609)
  (prog (a b)
    (return
      (progn
        (setq a (CADR G168609))
        (setq b (CADDR G168609))
        (+ (+ 1 (|height| a)) (|superspan| b))))))

;overlabelWidth [.,a,b] == WIDTH b

(defun |overlabelWidth| (G168623)
  (prog (a b)
    (return
      (progn
        (setq a (CADR G168623))
        (setq b (CADDR G168623))
        (width b)))))

;overlabelApp([.,a,b], x, y, d) ==
;  underApp:= APP(b,x,y,d)
;  endPoint := x + WIDTH b - 1
;  middle := QUOTIENT(x + endPoint,2)
;  h := y + superspan b + 1
;  d := APP(a,middle,h + 1,d)
;  apphor(x,x+WIDTH b-1,y+superspan b+1,d,"|")

(defun |overlabelApp| (G168638 x y d)
  (prog (a b |underApp| |endPoint| |middle| |h|)
    (return
      (progn
        (setq a (CADR G168638))
        (setq b (CADDR G168638))
        (setq |underApp| (APP b x y d))
        (setq |endPoint| (- (+ x (width b)) 1))
        (setq |middle| (QUOTIENT (+ x |endPoint|) 2))
        (setq |h| (+ (+ y (|superspan| b)) 1))
        (setq d (APP a |middle| (+ |h| 1) d))
        (apphor x (- (+ x (width b)) 1)
            (+ (+ y (|superspan| b)) 1) d '|\||)))))

;overbarSuper u == 1 + superspan u.1

(defun |overbarSuper| (u) (+ 1 (|superspan| (elt u 1))))

;overbarWidth u == WIDTH u.1

(defun |overbarWidth| (u) (width (elt u 1)))

;overbarApp(u,x,y,d) ==
;  underApp:= APP(u.1,x,y,d)
;  apphor(x,x+WIDTH u.1-1,y+superspan u.1+1,d,UNDERBAR)

(defun |overbarApp| (u x y d)
  (prog (|underApp|)
    (return
      (progn
        (setq |underApp| (APP (elt u 1) x y d))
        (apphor x (- (+ x (width (elt u 1))) 1)
            (+ (+ y (|superspan| (elt u 1))) 1) d UNDERBAR)))))

;indefIntegralSub u ==
;   -- form is INDEFINTEGRAL(expr,dx)
;   MAX(1,subspan u.1,subspan u.2)

(defun |indefIntegralSub| (u)
  (MAX 1 (|subspan| (elt u 1)) (|subspan| (elt u 2))))

;indefIntegralSup u ==
;   -- form is INDEFINTEGRAL(expr,dx)
;   MAX(1,superspan u.1,superspan u.2)

(defun |indefIntegralSup| (u)
  (MAX 1 (|superspan| (elt u 1)) (|superspan| (elt u 2))))

;indefIntegralApp(u,x,y,d) ==
;   -- form is INDEFINTEGRAL(expr,dx)
;  [.,expr,dx]:=u
;  d := APP(expr,x+4,y,d)
;  d := APP(dx,x+5+WIDTH expr,y,d)
;  xLate( [['(0 . -1),:specialChar('llc) ],_
;          ['(1 . -1),:specialChar('lrc) ],_
;          ['(1 .  0),:specialChar('vbar)],_
;          ['(1 .  1),:specialChar('ulc) ],_
;          ['(2 .  1),:specialChar('urc) ]], x,y,d)

(defun |indefIntegralApp| (u x y d)
  (prog (|expr| |dx|)
    (return
      (progn
        (setq |expr| (CADR u))
        (setq |dx| (CADDR u))
        (setq d (APP |expr| (+ x 4) y d))
        (setq d
                 (APP |dx| (+ (+ x 5) (width |expr|)) y d))
        (xLate (cons (cons '(0 . -1) (|specialChar| '|llc|))
                       (cons (cons '(1 . -1) (|specialChar| '|lrc|))
                             (cons (cons '(1 . 0)
                                    (|specialChar| '|vbar|))
                                   (CONS
                                    (cons '(1 . 1)
                                     (|specialChar| '|ulc|))
                                    (CONS
                                     (cons '(2 . 1)
                                      (|specialChar| '|urc|))
                                     nil)))))
                 x y d)))))

;indefIntegralWidth u ==
;  -- form is INDEFINTEGRAL(expr,dx)
;  # u ^= 3 => THROW('outputFailure,'outputFailure)
;  5 + WIDTH u.1 + WIDTH u.2

(defun |indefIntegralWidth| (u)
  (cond
    ((NEQUAL (|#| u) 3) (THROW '|outputFailure| '|outputFailure|))
    (t (+ (+ 5 (width (elt u 1))) (width (elt u 2))))))

;intSub u ==
;   MAX(1 + height u.1, subspan u.3)

(defun |intSub| (u)
  (MAX (+ 1 (|height| (elt u 1))) (|subspan| (elt u 3))))

;intSup u ==
;   MAX(1 + height u.2, superspan u.3)

(defun |intSup| (u)
  (MAX (+ 1 (|height| (elt u 2))) (|superspan| (elt u 3))))

;intApp(u,x,y,d) ==
;  [.,bot,top,arg]:=u
;  d:=APP(arg,x+4+MAX(-4 + WIDTH bot, WIDTH top),y,d)
;  d:=APP(bot,x,y-2-superspan bot,d)
;  d:=APP(top,x+3,y+2+subspan top,d)
;  xLate( [['(0 . -1),:specialChar('llc) ],_
;          ['(1 . -1),:specialChar('lrc) ],_
;          ['(1 .  0),:specialChar('vbar)],_
;          ['(1 .  1),:specialChar('ulc) ],_
;          ['(2 .  1),:specialChar('urc) ]], x,y,d)

(defun |intApp| (u x y d)
  (prog (|bot| |top| |arg|)
    (return
      (progn
        (setq |bot| (CADR u))
        (setq |top| (CADDR u))
        (setq |arg| (CADDDR u))
        (setq d
                 (APP |arg|
                      (+ (+ x 4)
                            (MAX (+ (- 4)
                                       (width |bot|))
                                 (width |top|)))
                      y d))
        (setq d
                 (APP |bot| x
                      (- (- y 2)
                          (|superspan| |bot|))
                      d))
        (setq d
                 (APP |top| (+ x 3)
                      (+ (+ y 2) (|subspan| |top|)) d))
        (xLate (cons (cons '(0 . -1) (|specialChar| '|llc|))
                       (cons (cons '(1 . -1) (|specialChar| '|lrc|))
                             (cons (cons '(1 . 0)
                                    (|specialChar| '|vbar|))
                                   (CONS
                                    (cons '(1 . 1)
                                     (|specialChar| '|ulc|))
                                    (CONS
                                     (cons '(2 . 1)
                                      (|specialChar| '|urc|))
                                     nil)))))
                 x y d)))))

;intWidth u ==
;  # u < 4 => THROW('outputFailure,'outputFailure)
;  MAX(-4 + WIDTH u.1, WIDTH u.2) + WIDTH u.3 + 5

(defun |intWidth| (u)
  (cond
    ((QSLESSP (|#| u) 4) (THROW '|outputFailure| '|outputFailure|))
    (t
     (+ (+ (MAX (+ (- 4) (width (elt u 1)))
                      (width (elt u 2)))
                 (width (elt u 3)))
           5))))

;xLate(l,x,y,d) ==
;  for [[a,:b],:c] in l repeat
;    d:= appChar(c,x+a,y+b,d)
;  d

(defun xLate (|l| x y d)
  (prog (a b |c|)
    (return
      (seq (progn
             (do ((G168723 |l| (CDR G168723)) (G168713 nil))
                 ((or (atom G168723)
                      (progn (setq G168713 (car G168723)) nil)
                      (progn
                        (progn
                          (setq a (CAAR G168713))
                          (setq b (CDAR G168713))
                          (setq |c| (CDR G168713))
                          G168713)
                        nil))
                  nil)
               (seq (exit (setq d
                                   (appChar |c| (+ x a)
                                    (+ y b) d)))))
             d)))))

;concatTrouble(u,d,start,lineLength,$addBlankIfTrue) ==
;  [x,:l] := splitConcat(u,lineLength,true)
;  null l =>
;    sayALGEBRA ['%l,'%b,'"  Too wide to Print",'%d]
;    THROW('output,nil)
;  charybdis(fixUp x,start,lineLength)
;  for y in l repeat
;    if d then prnd(start,d)
;    if lineLength > 2 then
;       charybdis(fixUp y,start+2,lineLength-2) -- JHD needs this to avoid lunacy
;      else charybdis(fixUp y,start,1) -- JHD needs this to avoid lunacy
;  BLANK
; where
;  fixUp x ==
;    rest x =>
;      $addBlankIfTrue => ['CONCATB,:x]
;      ["CONCAT",:x]
;    first x

(defun concatTroubleFixUp (x)
  (declare (special |$addBlankIfTrue|))
  (seq (IF (CDR x)
           (exit (seq (IF |$addBlankIfTrue| (exit (cons 'CONCATB x)))
                      (exit (cons 'CONCAT x)))))
       (exit (car x))))

(defun concatTrouble (u d start linelength |$addBlankIfTrue|)
  (declare (special |$addBlankIfTrue|))
  (prog (|LETTMP#1| x |l|)
    (return
      (seq (progn
             (setq |LETTMP#1| (splitConcat u linelength t))
             (setq x (car |LETTMP#1|))
             (setq |l| (CDR |LETTMP#1|))
             (cond
               ((NULL |l|)
                (sayALGEBRA
                    (cons '|%l|
                                (cons "  Too wide to Print" nil)))
                (THROW '|output| nil))
               (t
                (charybdis (concatTroubleFixUp x) start
                    linelength)
                (do ((G168762 |l| (CDR G168762)) (y nil))
                    ((or (atom G168762)
                         (progn (setq y (car G168762)) nil))
                     nil)
                  (seq (exit (progn
                               (cond (d (prnd start d)))
                               (cond
                                 ((> linelength 2)
                                  (charybdis
                                      (concatTroubleFixUp y)
                                      (+ start 2)
                                      (- linelength 2)))
                                 (t
                                  (charybdis
                                      (concatTroubleFixUp y)
                                      start 1)))))))
                BLANK)))))))

;splitConcat(list,maxWidth,firstTimeIfTrue) ==
;  null list => nil
;  -- split list l into a list of n lists, each of which
;  -- has width < maxWidth
;  totalWidth:= 0
;  oneOrZero := ($addBlankIfTrue => 1; 0)
;  l := list
;  maxW:= (firstTimeIfTrue => maxWidth; maxWidth-2)
;  maxW < 1 => [[x] for x in l] -- JHD 22.8.95, otherwise things can break
;  for x in tails l
;    while (width := oneOrZero + WIDTH first x + totalWidth) < maxW repeat
;      l:= x
;      totalWidth:= width
;  x:= rest l
;  RPLAC(rest l,nil)
;  [list,:splitConcat(x,maxWidth,nil)]

(defun splitConcat (LIST |maxWidth| |firstTimeIfTrue|)
  (prog (|oneOrZero| |maxW| width |l| |totalWidth| x)
    (declare (special |$addBlankIfTrue|))
    (return
      (seq (cond
             ((NULL LIST) nil)
             (t (setq |totalWidth| 0)
              (setq |oneOrZero| (cond (|$addBlankIfTrue| 1) (t 0)))
              (setq |l| LIST)
              (setq |maxW|
                       (cond
                         (|firstTimeIfTrue| |maxWidth|)
                         (t (- |maxWidth| 2))))
              (cond
                ((> 1 |maxW|)
                 (prog (G168783)
                   (setq G168783 nil)
                   (return
                     (do ((G168788 |l| (CDR G168788)) (x nil))
                         ((or (atom G168788)
                              (progn (setq x (car G168788)) nil))
                          (NREVERSE0 G168783))
                       (seq (exit (setq G168783
                                        (cons (cons x nil) G168783))))))))
                (t
                 (do ((x |l| (CDR x)))
                     ((or (atom x)
                          (NULL (> |maxW|
                                   (setq width
                                    (+
                                     (+ |oneOrZero|
                                      (width (car x)))
                                     |totalWidth|)))))
                      nil)
                   (seq (exit (progn
                                (setq |l| x)
                                (setq |totalWidth| width)))))
                 (setq x (CDR |l|)) (RPLAC (CDR |l|) nil)
                 (cons LIST (splitConcat x |maxWidth| nil))))))))))

;spadPrint(x,m) ==
;  m = $NoValueMode => x
;  if ^$collectOutput then TERPRI $algebraOutputStream
;  output(x,m)
;  if ^$collectOutput then TERPRI $algebraOutputStream

(defun |spadPrint| (x m)
  (declare (special |$algebraOutputStream| |$collectOutput|
                    |$NoValueMode|))
  (cond
    ((equal m |$NoValueMode|) x)
    (t
     (cond ((NULL |$collectOutput|) (TERPRI |$algebraOutputStream|)))
     (|output| x m)
     (cond
       ((NULL |$collectOutput|) (TERPRI |$algebraOutputStream|))
       (t nil)))))

;formulaFormat expr ==
;  sff := '(ScriptFormulaFormat)
;  formatFn := getFunctionFromDomain("coerce",sff,[$OutputForm])
;  displayFn := getFunctionFromDomain("display",sff,[sff])
;  SPADCALL(SPADCALL(expr,formatFn),displayFn)
;  if ^$collectOutput then
;    TERPRI $algebraOutputStream
;    FORCE_-OUTPUT $formulaOutputStream
;  NIL

(defun formulaFormat (|expr|)
  (prog (|sff| |formatFn| |displayFn|)
    (declare (special |$formulaOutputStream| |$algebraOutputStream|
                      |$collectOutput| |$OutputForm|))
    (return
      (progn
        (setq |sff| '(|ScriptFormulaFormat|))
        (setq |formatFn|
                 (|getFunctionFromDomain| '|coerce| |sff|
                     (cons |$OutputForm| nil)))
        (setq |displayFn|
                 (|getFunctionFromDomain| '|display| |sff|
                     (cons |sff| nil)))
        (SPADCALL (SPADCALL |expr| |formatFn|) |displayFn|)
        (cond
          ((NULL |$collectOutput|) (TERPRI |$algebraOutputStream|)
           (FORCE-OUTPUT |$formulaOutputStream|)))
        nil))))

;texFormat expr ==
;  tf := '(TexFormat)
;  formatFn :=
;    getFunctionFromDomain("convert",tf,[$OutputForm,$Integer])
;  displayFn := getFunctionFromDomain("display",tf,[tf])
;  SPADCALL(SPADCALL(expr,$IOindex,formatFn),displayFn)
;  TERPRI $texOutputStream
;  FORCE_-OUTPUT $texOutputStream
;  NIL

(defun texFormat (|expr|)
  (prog (|tf| |formatFn| |displayFn|)
    (declare (special |$texOutputStream| |$IOindex| |$Integer|
                      |$OutputForm|))
    (return
      (progn
        (setq |tf| '(|TexFormat|))
        (setq |formatFn|
                 (|getFunctionFromDomain| '|convert| |tf|
                     (cons |$OutputForm| (cons |$Integer| nil))))
        (setq |displayFn|
                 (|getFunctionFromDomain| '|display| |tf|
                     (cons |tf| nil)))
        (SPADCALL (SPADCALL |expr| |$IOindex| |formatFn|) |displayFn|)
        (TERPRI |$texOutputStream|)
        (FORCE-OUTPUT |$texOutputStream|)
        nil))))


;mathmlFormat expr ==
;  mml := '(MathMLFormat)
;  mmlrep := '(String)
;  formatFn := getFunctionFromDomain("coerce",mml,[$OutputForm])
;  displayFn := getFunctionFromDomain("display",mml,[mmlrep])
;  SPADCALL(SPADCALL(expr,formatFn),displayFn)
;  TERPRI $mathmlOutputStream
;  FORCE_-OUTPUT $mathmlOutputStream
;  NIL

(defun mathmlFormat (|expr|)
  (prog (|mml| |mmlrep| |formatFn| |displayFn|)
    (declare (special |$mathmlOutputStream| |$OutputForm|))
    (return
      (progn
        (setq |mml| '(|MathMLFormat|))
        (setq |mmlrep| '(|String|))
        (setq |formatFn|
                 (|getFunctionFromDomain| '|coerce| |mml|
                     (cons |$OutputForm| nil)))
        (setq |displayFn|
                 (|getFunctionFromDomain| '|display| |mml|
                     (cons |mmlrep| nil)))
        (SPADCALL (SPADCALL |expr| |formatFn|) |displayFn|)
        (TERPRI |$mathmlOutputStream|)
        (FORCE-OUTPUT |$mathmlOutputStream|)
        nil))))

(defun htmlFormat (expr)
 "Output the expression using HTML format"
 (let (ht htrep formatFn displayFn)
 (declare (special |$htmlOutputStream| |$OutputForm|))
  (setq ht '(|HTMLFormat|))
  (setq htrep '(|String|))
  (setq formatFn
    (|getFunctionFromDomain| '|coerce| ht (cons |$OutputForm| nil)))
  (setq displayFn (|getFunctionFromDomain| '|display| ht (cons htrep nil)))
  (spadcall (spadcall expr formatFn) displayFn)
  (terpri |$htmlOutputStream|)
  (force-output |$htmlOutputStream|)
  nil))

;output(expr,domain) ==
;  if isWrapped expr then expr := unwrap expr
;  isMapExpr expr =>
;    if $formulaFormat then formulaFormat expr
;    if $texFormat     then texFormat expr
;    if $algebraFormat then mathprintWithNumber expr
;    if $mathmlFormat  then mathmlFormat expr
;  categoryForm? domain or domain in '((Mode) (Domain) (SubDomain (Domain))) =>
;    if $algebraFormat then
;      mathprintWithNumber outputDomainConstructor expr
;    if $texFormat     then
;      texFormat outputDomainConstructor expr
;  T := coerceInteractive(objNewWrap(expr,domain),$OutputForm) =>
;    x := objValUnwrap T
;    if $formulaFormat then formulaFormat x
;    if $fortranFormat then
;      dispfortexp x
;      if ^$collectOutput then TERPRI $fortranOutputStream
;      FORCE_-OUTPUT $fortranOutputStream
;    if $algebraFormat then
;      mathprintWithNumber x
;    if $texFormat     then texFormat x
;    if $mathmlFormat  then mathmlFormat x
;  (FUNCTIONP(opOf domain)) and (not (SYMBOLP(opOf domain))) and
;    (printfun := _
;      compiledLookup("<<",'(TextWriter TextWriter $), evalDomain domain))
;       and (textwrit := compiledLookup("print", '($), TextWriter())) =>
;     sayMSGNT [:bright '"AXIOM-XL",'"output:   "]
;     SPADCALL(SPADCALL textwrit, expr, printfun)
;     sayMSGNT '%l
;  -- big hack for tuples for new compiler
;  domain is ['Tuple, S] => output(asTupleAsList expr, ['List, S])
;  sayALGEBRA [:bright '"LISP",'"output:",'%l,expr or '"NIL"]

(defun |output| (|expr| |domain|)
  (prog (T$ x |printfun| |textwrit| tmp1 S)
    (declare (special |$mathmlFormat| |$texFormat| |$algebraFormat|
                      |$fortranOutputStream| |$collectOutput|
                      |$fortranFormat| |$formulaFormat| |$OutputForm|
                      |$htmlFormat|))
    (return
      (progn
        (cond
          ((|isWrapped| |expr|) (setq |expr| (|unwrap| |expr|))))
        (cond
          ((|isMapExpr| |expr|)
           (when |$formulaFormat| (formulaFormat |expr|))
           (when |$texFormat|     (texFormat |expr|))
           (when |$algebraFormat| (mathprintWithNumber |expr|))
           (when |$htmlFormat|    (htmlFormat |expr|))
           (when |$mathmlFormat|  (mathmlFormat |expr|)))
          ((or (|categoryForm?| |domain|)
               (|member| |domain|
                   '((|Mode|) (|Domain|) (|SubDomain| (|Domain|)))))
           (cond
             (|$algebraFormat|
                 (mathprintWithNumber
                     (|outputDomainConstructor| |expr|))))
           (cond
             (|$texFormat|
                 (texFormat (|outputDomainConstructor| |expr|)))
             (t nil)))
          ((setq T$
                    (|coerceInteractive| (mkObjWrap |expr| |domain|)
                        |$OutputForm|))
           (setq x (|objValUnwrap| T$))
           (cond (|$formulaFormat| (formulaFormat x)))
           (cond
             (|$fortranFormat| (|dispfortexp| x)
                 (cond
                   ((NULL |$collectOutput|)
                    (TERPRI |$fortranOutputStream|)))
                 (FORCE-OUTPUT |$fortranOutputStream|)))
           (when |$algebraFormat| (mathprintWithNumber x))
           (when |$texFormat| (texFormat x))
           (when |$htmlFormat| (htmlFormat x))
           (when |$mathmlFormat| (mathmlFormat x)))
          ((and (FUNCTIONP (|opOf| |domain|))
                (NULL (SYMBOLP (|opOf| |domain|)))
                (setq |printfun|
                         (|compiledLookup| '<<
                             '(|TextWriter| |TextWriter| $)
                             (|evalDomain| |domain|)))
                (setq |textwrit|
                         (|compiledLookup| '|print| '($)
                             (|TextWriter|))))
           (sayMSGNT
               (APPEND (|bright| "AXIOM-XL")
                       (cons "output:   " nil)))
           (SPADCALL (SPADCALL |textwrit|) |expr| |printfun|)
           (sayMSGNT '|%l|))
          ((and (consp |domain|) (eq (qcar |domain|) '|Tuple|)
                (progn
                  (setq tmp1 (qcdr |domain|))
                  (and (consp tmp1) (eq (qcdr tmp1) nil)
                       (progn (setq S (qcar tmp1)) t))))
           (|output| (|asTupleAsList| |expr|)
               (cons '|List| (cons S nil))))
          (t
           (sayALGEBRA
               (APPEND (|bright| "LISP")
                       (cons "output:"
                             (cons '|%l|
                                   (cons (or |expr| "NIL")
                                    nil)))))))))))

;outputNumber(start,linelength,num) ==
;  if start > 1 then blnks := fillerSpaces(start-1,'" ")
;  else blnks := '""
;  under:='"__"
;  firsttime:=(linelength>3)
;  if linelength>2 then
;     linelength:=linelength-1
;  while SIZE(num) > linelength repeat
;    if $collectOutput then
;       $outputLines := [CONCAT(blnks, SUBSTRING(num,0,linelength),under),
;                        :$outputLines]
;    else
;      sayALGEBRA [blnks,
;                  SUBSTRING(num,0,linelength),under]
;    num := SUBSTRING(num,linelength,NIL)
;    if firsttime then
;         blnks:=CONCAT(blnks,'" ")
;         linelength:=linelength-1
;         firsttime:=NIL
;  if $collectOutput then
;    $outputLines := [CONCAT(blnks, num), :$outputLines]
;  else
;    sayALGEBRA [blnks, num]

(defun outputNumber (start linelength |num|)
  (prog (|under| |blnks| |firsttime|)
    (declare (special |$outputLines| |$collectOutput|))
    (return
      (seq (progn
             (cond
               ((> start 1)
                (setq |blnks|
                         (|fillerSpaces| (- start 1)
                             " ")))
               (t (setq |blnks| "")))
             (setq |under| "_")
             (setq |firsttime| (> linelength 3))
             (cond
               ((> linelength 2)
                (setq linelength (- linelength 1))))
             (do () ((NULL (> (SIZE |num|) linelength)) nil)
               (seq (exit (progn
                            (cond
                              (|$collectOutput|
                                  (setq |$outputLines|
                                           (CONS
                                            (CONCAT |blnks|
                                             (SUBSTRING |num| 0
                                              linelength)
                                             |under|)
                                            |$outputLines|)))
                              (t
                               (sayALGEBRA
                                   (cons |blnks|
                                    (CONS
                                     (SUBSTRING |num| 0 linelength)
                                     (cons |under| nil))))))
                            (setq |num|
                                     (SUBSTRING |num| linelength nil))
                            (cond
                              (|firsttime|
                                  (setq |blnks|
                                           (CONCAT |blnks|
                                            " "))
                                  (setq linelength
                                           (- linelength
                                            1))
                                  (setq |firsttime| nil))
                              (t nil))))))
             (cond
               (|$collectOutput|
                   (setq |$outputLines|
                            (cons (CONCAT |blnks| |num|)
                                  |$outputLines|)))
               (t (sayALGEBRA (cons |blnks| (cons |num| nil))))))))))

;  if start > 1 then blnks := fillerSpaces(start-1,'" ")
;  else blnks := '""
;  while SIZE(str) > linelength repeat
;    if $collectOutput then
;       $outputLines := [CONCAT(blnks, SUBSTRING(str,0,linelength)),
;                        :$outputLines]
;    else
;      sayALGEBRA [blnks, SUBSTRING(str,0,linelength)]
;    str := SUBSTRING(str,linelength,NIL)
;  if $collectOutput then
;    $outputLines := [CONCAT(blnks, str), :$outputLines]
;  else
;    sayALGEBRA [blnks, str]

(defun outputString (start linelength |str|)
  (prog (|blnks|)
    (declare (special |$outputLines| |$collectOutput|))
    (return
      (seq (progn
             (cond
               ((> start 1)
                (setq |blnks|
                         (|fillerSpaces| (- start 1)
                             " ")))
               (t (setq |blnks| "")))
             (do () ((NULL (> (SIZE |str|) linelength)) nil)
               (seq (exit (progn
                            (cond
                              (|$collectOutput|
                                  (setq |$outputLines|
                                           (CONS
                                            (CONCAT |blnks|
                                             (SUBSTRING |str| 0
                                              linelength))
                                            |$outputLines|)))
                              (t
                               (sayALGEBRA
                                   (cons |blnks|
                                    (CONS
                                     (SUBSTRING |str| 0 linelength)
                                     nil)))))
                            (setq |str|
                                     (SUBSTRING |str| linelength nil))))))
             (cond
               (|$collectOutput|
                   (setq |$outputLines|
                            (cons (CONCAT |blnks| |str|)
                                  |$outputLines|)))
               (t (sayALGEBRA (cons |blnks| (cons |str| nil))))))))))

;outputDomainConstructor form ==
;  if VECTORP CAR form then form := devaluate form
;  atom (u:= prefix2String form) => u
;  v:= [object2String(x) for x in u]
;  return INTERNL eval ['STRCONC,:v]

(defun |outputDomainConstructor| (|form|)
  (prog (u v)
    (return
      (seq (progn
             (cond
               ((VECTORP (car |form|))
                (setq |form| (|devaluate| |form|))))
             (cond
               ((atom (setq u (|prefix2String| |form|))) u)
               (t
                (setq v
                         (prog (G168919)
                           (setq G168919 nil)
                           (return
                             (do ((G168924 u (CDR G168924))
                                  (x nil))
                                 ((or (atom G168924)
                                      (progn
                                        (setq x (car G168924))
                                        nil))
                                  (NREVERSE0 G168919))
                               (seq (EXIT
                                     (setq G168919
                                      (cons (|object2String| x)
                                       G168919))))))))
                (return (INTERNL (|eval| (cons 'STRCONC v)))))))))))

;printMap1(x,initialFlag) ==
;  initialFlag => printBasic CADR x
;  if CDAR x then printBasic first x else printBasic CAAR x
;  printBasic " E "
;  printBasic CADR x

(defun printMap1 (x |initialFlag|)
  (cond
    (|initialFlag| (printBasic (CADR x)))
    (t
     (cond
       ((CDAR x) (printBasic (car x)))
       (t (printBasic (CAAR x))))
     (printBasic '| E |) (printBasic (CADR x)))))

;printBasic x ==
;  x='(One) => PRIN1(1,$algebraOutputStream)
;  x='(Zero) => PRIN1(0,$algebraOutputStream)
;  IDENTP x => PRINC(PNAME x,$algebraOutputStream)
;  atom x => PRIN1(x,$algebraOutputStream)
;  PRIN1(x,$algebraOutputStream)

(defun printBasic (x)
  (declare (special |$algebraOutputStream|))
  (cond
    ((equal x '(|One|)) (PRIN1 1 |$algebraOutputStream|))
    ((equal x '(|Zero|)) (PRIN1 0 |$algebraOutputStream|))
    ((IDENTP x) (PRINC (PNAME x) |$algebraOutputStream|))
    ((atom x) (PRIN1 x |$algebraOutputStream|))
    (t (PRIN1 x |$algebraOutputStream|))))

(defun charyTopWidth (u)
  (cond
    ((atom u) u)
    ((atom (car u)) (putWidth u))
    ((NUMBERP (CDAR u)) u)
    (t (putWidth u))))

(defun charyTrouble (u v start linelength)
  (prog (|al|)
    (return
      (cond
        ((setq |al|
                  (LargeMatrixp u linelength
                      (TIMES 2 linelength)))
         (setq u (SubstWhileDesizing u nil))
         (maprinChk u))
        (t (charyTrouble1 u v start linelength))))))

;sublisMatAlist(m,m1,u) ==
;  u is [op,:r] =>
;    op is ['MATRIX,:.] and u=m => m1
;    op1 := sublisMatAlist(m,m1,op)
;    r1 := [sublisMatAlist(m,m1,s) for s in r]
;    op = op1 and r1 = r => u
;    [op1,:r1]
;  u

(defun sublisMatAlist (m |m1| u)
  (prog (|op| |r| |op1| |r1|)
    (return
      (seq (cond
             ((and (consp u)
                   (progn
                     (setq |op| (qcar u))
                     (setq |r| (qcdr u))
                     t))
              (cond
                ((and (consp |op|) (eq (qcar |op|) 'MATRIX)
                      (equal u m))
                 |m1|)
                (t (setq |op1| (sublisMatAlist m |m1| |op|))
                 (setq |r1|
                          (prog (G169190)
                            (setq G169190 nil)
                            (return
                              (do ((G169195 |r| (CDR G169195))
                                   (|s| nil))
                                  ((or (atom G169195)
                                    (progn
                                      (setq |s| (car G169195))
                                      nil))
                                   (NREVERSE0 G169190))
                                (seq (EXIT
                                      (setq G169190
                                       (CONS
                                        (sublisMatAlist m |m1| |s|)
                                        G169190))))))))
                 (cond
                   ((and (equal |op| |op1|) (equal |r1| |r|))
                    u)
                   (t (cons |op1| |r1|))))))
             (t u))))))

;charyTrouble1(u,v,start,linelength) ==
;  NUMBERP u => outputNumber(start,linelength,atom2String u)
;  atom u => outputString(start,linelength,atom2String u)
;  EQ(x:= keyp u,'_-) => charyMinus(u,v,start,linelength)
;  MEMQ(x,'(_+ _* AGGLST)) => charySplit(u,v,start,linelength)
;  EQ(x,'EQUATNUM) => charyEquatnum(u,v,start,linelength)
;  d := GET(x,'INFIXOP) => charyBinary(d,u,v,start,linelength)
;  x = 'OVER  =>
;    charyBinary(GET("/",'INFIXOP),u,v,start,linelength)
;  EQ(3,LENGTH u) and GET(x,'Led) =>
;    d:= PNAME first GET(x,'Led)
;    charyBinary(d,u,v,start,linelength)
;  EQ(x,'CONCAT) =>
;    concatTrouble(rest v,d,start,linelength,nil)
;  EQ(x,'CONCATB) =>
;    (rest v) is [loop, 'repeat, body] =>
;      charyTop(['CONCATB,loop,'repeat],start,linelength)
;      charyTop(body,start+2,linelength-2)
;    (rest v) is [wu, loop, 'repeat, body] and
;      (keyp wu) is ['CONCATB,wu',.] and wu' in '(while until) =>
;        charyTop(['CONCATB,wu,loop,'repeat],start,linelength)
;        charyTop(body,start+2,linelength-2)
;    concatTrouble(rest v,d,start,linelength,true)
;  GET(x,'INFIXOP) => charySplit(u,v,start,linelength)
;  EQ(x,'PAREN) and
;    (EQ(keyp u.1,'AGGLST) and (v:= ",") or EQ(keyp u.1,'AGGSET) and
;      (v:= ";")) => bracketagglist(rest u.1,start,linelength,v,"_(","_)")
;  EQ(x,'PAREN) and EQ(keyp u.1,'CONCATB) =>
;    bracketagglist(rest u.1,start,linelength," ","_(","_)")
;  EQ(x,'BRACKET) and (EQ(keyp u.1,'AGGLST) and (v:= ",")) =>
;    bracketagglist(rest u.1,start,linelength,v,
;                   specialChar 'lbrk, specialChar 'rbrk)
;  EQ(x,'BRACE) and (EQ(keyp u.1,'AGGLST) and (v:= ",")) =>
;    bracketagglist(rest u.1,start,linelength,v,
;                   specialChar 'lbrc, specialChar 'rbrc)
;  EQ(x,'EXT) => longext(u,start,linelength)
;  EQ(x,'MATRIX) => MATUNWND()
;  EQ(x,'ELSE) => charyElse(u,v,start,linelength)
;  EQ(x,'SC) => charySemiColon(u,v,start,linelength)
;  charybdis(x,start,linelength)
;  if rest u then charybdis(['ELSE,:rest u],start,linelength)
;  -- changed from charybdis(...) by JHD 2 Aug 89, since rest u might be null
;  '" "

(defun charyTrouble1 (u v start linelength)
  (prog (x d |wu| |loop| tmp4 |body| tmp1 tmp2 |wu'|
             tmp3)
    (return
      (cond
        ((NUMBERP u)
         (outputNumber start linelength (|atom2String| u)))
        ((atom u)
         (outputString start linelength (|atom2String| u)))
        ((eq (setq x (keyp u)) '-)
         (charyMinus u v start linelength))
        ((member x '(+ * AGGLST))
         (charySplit u v start linelength))
        ((eq x 'EQUATNUM)
         (charyEquatnum u v start linelength))
        ((setq d (GETL x 'INFIXOP))
         (charyBinary d u v start linelength))
        ((eq x 'OVER)
         (charyBinary (GETL '/ 'INFIXOP) u v start
             linelength))
        ((and (eq 3 (LENGTH u)) (GETL x '|Led|))
         (setq d (PNAME (car (GETL x '|Led|))))
         (charyBinary d u v start linelength))
        ((eq x 'CONCAT)
         (concatTrouble (CDR v) d start linelength nil))
        ((eq x 'CONCATB)
         (cond
           ((progn
              (setq tmp1 (CDR v))
              (and (consp tmp1)
                   (progn
                     (setq |loop| (qcar tmp1))
                     (setq tmp2 (qcdr tmp1))
                     (and (consp tmp2)
                          (eq (qcar tmp2) '|repeat|)
                          (progn
                            (setq tmp3 (qcdr tmp2))
                            (and (consp tmp3)
                                 (eq (qcdr tmp3) nil)
                                 (progn
                                   (setq |body| (qcar tmp3))
                                   t)))))))
            (charyTop
                (cons 'CONCATB (cons |loop| (cons '|repeat| nil)))
                start linelength)
            (charyTop |body| (+ start 2)
                (- linelength 2)))
           ((and (progn
                   (setq tmp1 (CDR v))
                   (and (consp tmp1)
                        (progn
                          (setq |wu| (qcar tmp1))
                          (setq tmp2 (qcdr tmp1))
                          (and (consp tmp2)
                               (progn
                                 (setq |loop| (qcar tmp2))
                                 (setq tmp3 (qcdr tmp2))
                                 (and (consp tmp3)
                                      (eq (qcar tmp3) '|repeat|)
                                      (progn
                                        (setq tmp4
                                         (qcdr tmp3))
                                        (and (consp tmp4)
                                         (eq (qcdr tmp4) nil)
                                         (progn
                                           (setq |body|
                                            (qcar tmp4))
                                           t)))))))))
                 (progn
                   (setq tmp1 (keyp |wu|))
                   (and (consp tmp1)
                        (eq (qcar tmp1) 'CONCATB)
                        (progn
                          (setq tmp2 (qcdr tmp1))
                          (and (consp tmp2)
                               (progn
                                 (setq |wu'| (qcar tmp2))
                                 (setq tmp3 (qcdr tmp2))
                                 (and (consp tmp3)
                                      (eq (qcdr tmp3) nil)))))))
                 (|member| |wu'| '(|while| |until|)))
            (charyTop
                (cons 'CONCATB
                      (cons |wu| (cons |loop| (cons '|repeat| nil))))
                start linelength)
            (charyTop |body| (+ start 2)
                (- linelength 2)))
           (t (concatTrouble (CDR v) d start linelength t))))
        ((GETL x 'INFIXOP)
         (charySplit u v start linelength))
        ((and (eq x 'PAREN)
              (or (and (eq (keyp (elt u 1)) 'AGGLST)
                       (setq v '|,|))
                  (and (eq (keyp (elt u 1)) 'AGGSET)
                       (setq v '|;|))))
         (bracketagglist (CDR (elt u 1)) start linelength v
             '|(| '|)|))
        ((and (eq x 'PAREN) (eq (keyp (elt u 1)) 'CONCATB))
         (bracketagglist (CDR (elt u 1)) start linelength '| |
             '|(| '|)|))
        ((and (eq x 'BRACKET) (eq (keyp (elt u 1)) 'AGGLST)
              (setq v '|,|))
         (bracketagglist (CDR (elt u 1)) start linelength v
             (|specialChar| '|lbrk|) (|specialChar| '|rbrk|)))
        ((and (eq x 'BRACE) (eq (keyp (elt u 1)) 'AGGLST)
              (setq v '|,|))
         (bracketagglist (CDR (elt u 1)) start linelength v
             (|specialChar| '|lbrc|) (|specialChar| '|rbrc|)))
        ((eq x 'EXT) (longext u start linelength))
        ((eq x 'MATRIX) (MATUNWND))
        ((eq x 'ELSE) (charyElse u v start linelength))
        ((eq x 'SC) (charySemiColon u v start linelength))
        (t (charybdis x start linelength)
         (cond
           ((CDR u)
            (charybdis (cons 'ELSE (CDR u)) start linelength)))
         " ")))))

;charySemiColon(u,v,start,linelength) ==
;  for a in rest u repeat
;    charyTop(a,start,linelength)
;  nil

(defun charySemiColon (u v start linelength)
  (declare (ignore v))
  (seq (progn
         (do ((G169335 (CDR u) (CDR G169335)) (a nil))
             ((or (atom G169335) (progn (setq a (car G169335)) nil))
              nil)
           (seq (exit (charyTop a start linelength))))
         nil)))

(defun charyMinus (u v start linelength)
  (declare (ignore u))
  (progn
    (charybdis "-" start linelength)
    (charybdis (elt v 1) (+ start 3)
        (- linelength 3))
    " "))

(defun charyBinary (d u v start linelength)
  (declare (ignore u))
  (cond
    ((|member| d '(" := " "= "))
     (charybdis (cons 'CONCATB (cons (elt v 1) (cons d nil)))
         start linelength)
     (charybdis (elt v 2) (+ start 2)
         (- linelength 2))
     " ")
    (t
     (charybdis (elt v 1) (+ start 2)
         (- linelength 2))
     (cond (d (prnd start d)))
     (charybdis (elt v 2) (+ start 2)
         (- linelength 2))
     " ")))

(defun charyEquatnum (u v start linelength)
  (declare (ignore v))
  (progn
    (charybdis (cons 'PAREN (cons (elt u 1) nil)) start
        linelength)
    (charybdis (elt u 2) start linelength)
    " "))

;charySplit(u,v,start,linelength) ==
;  v:= [first v.0,:rest v]
;  m:= rest v
;  WIDTH v.1 > linelength-2 =>
;    charybdis(v.1,start+2,linelength-2)
;    ^(CDDR v) => '" "
;    dm:= CDDR v
;    ddm:= rest dm
;    split2(u,dm,ddm,start,linelength)
;  for i in 0.. repeat
;    dm := rest m
;    ddm := rest dm
;    RPLACD(dm,nil)
;    WIDTH v > linelength - 2 => return nil
;    RPLAC(first v, first v.0)
;    RPLACD(dm,ddm)
;    m := rest m
;  RPLAC(first v,first v.0)
;  RPLACD(m,nil)
;  charybdis(v,start + 2,linelength - 2)
;  split2(u,dm,ddm,start,linelength)

(defun charySplit (u v start linelength)
  (prog (|dm| |ddm| m)
    (return
      (seq (progn
             (setq v (cons (car (elt v 0)) (CDR v)))
             (setq m (CDR v))
             (cond
               ((> (width (elt v 1)) (- linelength 2))
                (charybdis (elt v 1) (+ start 2)
                    (- linelength 2))
                (cond
                  ((NULL (CDDR v)) " ")
                  (t (setq |dm| (CDDR v))
                   (setq |ddm| (CDR |dm|))
                   (split2 u |dm| |ddm| start linelength))))
               (t
                (do ((|i| 0 (QSADD1 |i|))) (NIL nil)
                  (seq (exit (progn
                               (setq |dm| (CDR m))
                               (setq |ddm| (CDR |dm|))
                               (RPLACD |dm| nil)
                               (cond
                                 ((> (width v)
                                     (- linelength 2))
                                  (return nil))
                                 (t
                                  (RPLAC (car v) (car (elt v 0)))
                                  (RPLACD |dm| |ddm|)
                                  (setq m (CDR m))))))))
                (RPLAC (car v) (car (elt v 0))) (RPLACD m nil)
                (charybdis v (+ start 2)
                    (- linelength 2))
                (split2 u |dm| |ddm| start linelength))))))))

(defun split2 (u |dm| |ddm| start linelength)
  (prog (d m)
    (return
      (progn
        (prnd start
                (cond
                  ((setq d (GETL (keyp u) 'INFIXOP)) d)
                  (t ",")))
        (RPLACD |dm| |ddm|)
        (setq m
                 (> (- linelength 2)
                    (width (cons (keyp u) |dm|))))
        (charybdis (cons (keyp u) |dm|)
            (cond (m (+ start 2)) (t start))
            (cond
              (m (- linelength 2))
              (t linelength)))
        " "))))

(defun charyElse (u v start linelength)
  (progn
    (charybdis (elt v 1) (+ start 3)
        (- linelength 3))
    (cond
      ((NULL (CDDR u)) " ")
      (t (prnd start ",")
       (charybdis (cons 'ELSE (CDDR v)) start linelength)
       " "))))

(defun scylla (n v)
  (prog (y)
    (declare (special |$algebraOutputStream| |$outputLines|
                      |$collectOutput|))
    (return
      (progn
        (setq y (LASSOC n v))
        (cond
          ((NULL y) nil)
          (t
           (cond
             ((STRINGP y)
              (setq y (string-right-trim " " (COPY y)))))
           (cond
             (|$collectOutput|
                 (setq |$outputLines| (cons y |$outputLines|)))
             (t (PRINC y |$algebraOutputStream|)
              (TERPRI |$algebraOutputStream|)))
           nil))))))

;keyp(u) ==
;  atom u => nil
;  atom first u => first u
;  CAAR u

(defun keyp (u)
  (cond ((atom u) nil) ((atom (car u)) (car u)) (t (CAAR u))))

;absym x ==
;  (NUMBERP x) and (MINUSP x) => -x
;  ^(atom x) and (keyp(x) = '_-) => CADR x
;  x

(defun absym (x)
  (cond
    ((and (NUMBERP x) (MINUSP x)) (- x))
    ((and (NULL (atom x)) (eq (keyp x) '-)) (CADR x))
    (t x)))

;agg(n,u) ==
;  (n = 1) => CADR u
;  agg(n - 1, rest u)

(defun agg (n u)
  (cond
    ((EQL n 1) (CADR u))
    (t (agg (- n 1) (CDR u)))))

;aggwidth u ==
;  null u => 0
;  null rest u => WIDTH first u
;  1 + (WIDTH first u) + (aggwidth rest u)

(defun |aggwidth| (u)
  (cond
    ((NULL u) 0)
    ((NULL (CDR u)) (width (car u)))
    (t (+ (+ 1 (width (car u))) (|aggwidth| (CDR u))))))

;argsapp(u,x,y,d) == appargs(rest u,x,y,d)

(defun |argsapp| (u x y d) (appargs (CDR u) x y d)) 

;subspan u ==
;  atom u => 0
;  NUMBERP rest u => subspan first u
;  (not atom first u             and_
;   atom CAAR u           and_
;   not NUMBERP CAAR u    and_
;   GET(CAAR u, 'SUBSPAN)    )    =>
;   APPLX(GET(CAAR u, 'SUBSPAN), LIST u)
;  MAX(subspan first u, subspan rest u)

(defun |subspan| (u)
  (cond
    ((atom u) 0)
    ((NUMBERP (CDR u)) (|subspan| (car u)))
    ((and (NULL (atom (car u))) (atom (CAAR u))
          (NULL (NUMBERP (CAAR u))) (GETL (CAAR u) 'SUBSPAN))
     (apply (GETL (CAAR u) 'SUBSPAN) (LIST u)))
    (t (MAX (|subspan| (car u)) (|subspan| (CDR u))))))

;agggsub u == subspan rest u

(defun |agggsub| (u) (|subspan| (CDR u))) 

;superspan u ==
;  atom u => 0
;  NUMBERP rest u => superspan first u
;  (not atom first u               and_
;   atom CAAR u             and_
;   not NUMBERP CAAR u      and_
;   GET(CAAR u, 'SUPERSPAN)    )    =>
;   APPLX(GET(CAAR u, 'SUPERSPAN), LIST u)
;  MAX(superspan first u, superspan rest u)

(defun |superspan| (u)
  (cond
    ((atom u) 0)
    ((NUMBERP (CDR u)) (|superspan| (car u)))
    ((and (NULL (atom (car u))) (atom (CAAR u))
          (NULL (NUMBERP (CAAR u))) (GETL (CAAR u) 'SUPERSPAN))
     (apply (GETL (CAAR u) 'SUPERSPAN) (LIST u)))
    (t (MAX (|superspan| (car u)) (|superspan| (CDR u))))))

;agggsuper u == superspan rest u

(defun |agggsuper| (u) (|superspan| (CDR u))) 

;agggwidth u == aggwidth rest u

(defun |agggwidth| (u) (|aggwidth| (CDR u))) 

;appagg(u,x,y,d) == appagg1(u,x,y,d,'",")

(defun appagg (u x y d)
 (appagg1 u x y d ",")) 

;appagg1(u,x,y,d,s) ==
;  null u => d
;  null rest u => APP(first u,x,y,d)
;  temp := x + WIDTH first u
;  temparg1 := APP(first u,x,y,d)
;  temparg2 := APP(s,temp,y,temparg1)
;  appagg1(rest u, 1 + temp, y, temparg2,s)

(defun appagg1 (u x y d |s|)
  (prog (|temp| |temparg1| |temparg2|)
    (return
      (cond
        ((NULL u) d)
        ((NULL (CDR u)) (APP (car u) x y d))
        (t (setq |temp| (+ x (width (car u))))
         (setq |temparg1| (APP (car u) x y d))
         (setq |temparg2| (APP |s| |temp| y |temparg1|))
         (appagg1 (CDR u) (+ 1 |temp|) y |temparg2| |s|))))))

;--Note the similarity between the definition below of appargs and above
;--of appagg. (why?)
;appargs(u,x,y,d) == appargs1(u,x,y,d,'";")

(defun appargs (u x y d)
  (appargs1 u x y d ";"))

;--Note that the definition of appargs1 below is identical to that of
;--appagg1 above except that the former calls appargs and the latter
;--calls appagg.
;appargs1(u,x,y,d,s) ==
;  null u => d
;  null rest u => APP(first u,x,y,d)
;  temp := x + WIDTH first u
;  temparg1 := APP(first u,x,y,d)
;  temparg2 := APP(s,temp,y,temparg1)
;  true => appargs(rest u, 1 + temp, y, temparg2)

(defun appargs1 (u x y d |s|)
  (prog (|temp| |temparg1| |temparg2|)
    (return
      (cond
        ((NULL u) d)
        ((NULL (CDR u)) (APP (car u) x y d))
        (t (setq |temp| (+ x (width (car u))))
         (setq |temparg1| (APP (car u) x y d))
         (setq |temparg2| (APP |s| |temp| y |temparg1|))
         (appargs (CDR u) (+ 1 |temp|) y |temparg2|))))))

;apprpar(x, y, y1, y2, d) ==
;  (^(_*TALLPAR) or (y2 - y1 < 2)) => APP('")", x, y, d)
;  true => APP('")", x, y2, apprpar1(x, y, y1, y2 - 1, d))

(defun apprpar (x y |y1| |y2| d)
  (cond
    ((or (NULL *TALLPAR) (> 2 (- |y2| |y1|)))
     (APP ")" x y d))
    (t
     (APP ")" x |y2|
          (apprpar1 x y |y1| (- |y2| 1) d)))))

;apprpar1(x, y, y1, y2, d) ==
;  (y1 = y2) => APP('")", x, y2, d)
;  true => APP('")", x, y2, apprpar1(x, y, y1, y2 - 1, d))

(defun apprpar1 (x y |y1| |y2| d)
  (cond
    ((equal |y1| |y2|) (APP ")" x |y2| d))
    (t
     (APP ")" x |y2|
          (apprpar1 x y |y1| (- |y2| 1) d)))))

;applpar(x, y, y1, y2, d) ==
;  (^(_*TALLPAR) or (y2 - y1 < 2)) => APP('"(", x, y, d)
;  true => APP('"(", x, y2, applpar1(x, y, y1, y2 - 1, d))

(defun applpar (x y |y1| |y2| d)
  (cond
    ((or (NULL *TALLPAR) (> 2 (- |y2| |y1|)))
     (APP "(" x y d))
    (t
     (APP "(" x |y2|
          (applpar1 x y |y1| (- |y2| 1) d)))))

;applpar1(x, y, y1, y2, d) ==
;  (y1 = y2) => APP('"(", x, y2, d)
;  true => APP('"(", x, y2, applpar1(x, y, y1, y2 - 1, d))

(defun applpar1 (x y |y1| |y2| d)
  (cond
    ((equal |y1| |y2|) (APP "(" x |y2| d))
    (t
     (APP "(" x |y2|
          (applpar1 x y |y1| (- |y2| 1) d)))))

;--The body of the function appelse assigns 6 local variables.
;--It then finishes by calling apprpar.
;appelse(u,x,y,d) ==
;  w := WIDTH CAAR u
;  b := y - subspan rest u
;  p := y + superspan rest u
;  temparg1 := APP(keyp u, x, y, d)
;  temparg2 := applpar(x + w, y, b, p, temparg1)
;  temparg3 := appagg(rest u, x + 1 + w, y, temparg2)
;  apprpar(x + 1 + w + aggwidth rest u, y, b, p, temparg3)

(defun appelse (u x y d)
  (prog (w b |p| |temparg1| |temparg2| |temparg3|)
    (return
      (progn
        (setq w (width (CAAR u)))
        (setq b (- y (|subspan| (CDR u))))
        (setq |p| (+ y (|superspan| (CDR u))))
        (setq |temparg1| (APP (keyp u) x y d))
        (setq |temparg2|
                 (applpar (+ x w) y b |p| |temparg1|))
        (setq |temparg3|
                 (appagg (CDR u) (+ (+ x 1) w) y
                     |temparg2|))
        (apprpar
            (+ (+ (+ x 1) w) (|aggwidth| (CDR u))) y
            b |p| |temparg3|)))))

;appext(u,x,y,d) ==
;  xptr := x
;  yptr := y - (subspan CADR u + superspan agg(3,u) + 1)
;  d := APP(CADR u,x,y,d)
;  d := APP(agg(2,u),xptr,yptr,d)
;  xptr := xptr + WIDTH agg(2,u)
;  d := APP('"=", xptr, yptr,d)
;  d := APP(agg(3,u), 1 + xptr, yptr, d)
;  yptr := y + 1 + superspan CADR u + SUBSPAD agg(4,u)
;  d := APP(agg(4,u), x, yptr, d)
;  temp := 1 + WIDTH agg(2,u) +  WIDTH agg(3,u)
;  n := MAX(WIDTH CADR u, WIDTH agg(4,u), temp)
;  if EQCAR(first(z := agg(5,u)), 'EXT) and
;   (EQ(n,3) or (n > 3 and ^(atom z)) ) then
;     n := 1 + n
;  d := APP(z, x + n, y, d)

(defun |appext| (u x y d)
  (prog (|xptr| |yptr| |temp| |z| n)
    (return
      (progn
        (setq |xptr| x)
        (setq |yptr|
                 (- y
                     (+ (+ (|subspan| (CADR u))
                                 (|superspan| (agg 3 u)))
                           1)))
        (setq d (APP (CADR u) x y d))
        (setq d (APP (agg 2 u) |xptr| |yptr| d))
        (setq |xptr| (+ |xptr| (width (agg 2 u))))
        (setq d (APP "=" |xptr| |yptr| d))
        (setq d (APP (agg 3 u) (+ 1 |xptr|) |yptr| d))
        (setq |yptr|
                 (+ (+ (+ y 1) (|superspan| (CADR u)))
                       (SUBSPAD (agg 4 u))))
        (setq d (APP (agg 4 u) x |yptr| d))
        (setq |temp|
                 (+ (+ 1 (width (agg 2 u)))
                       (width (agg 3 u))))
        (setq n
                 (MAX (width (CADR u)) (width (agg 4 u)) |temp|))
        (cond
          ((and (EQCAR (car (setq |z| (agg 5 u))) 'EXT)
                (or (eq n 3) (and (> n 3) (NULL (atom |z|)))))
           (setq n (+ 1 n))))
        (setq d (APP |z| (+ x n) y d))))))

;apphor(x1,x2,y,d,char) ==
;  temp := (x1 = x2 => d; apphor(x1, x2 - 1, y, d,char))
;  APP(char, x2, y, temp)

(defun apphor (|x1| |x2| y d |char|)
  (prog (|temp|)
    (return
      (progn
        (setq |temp|
                 (cond
                   ((equal |x1| |x2|) d)
                   (t
                    (apphor |x1| (- |x2| 1) y d
                        |char|))))
        (APP |char| |x2| y |temp|)))))

;syminusp x ==
;  NUMBERP x => MINUSP x
;  ^(atom x) and EQ(keyp x,'_-)

(defun syminusp (x)
  (cond
    ((NUMBERP x) (MINUSP x))
    (t (and (NULL (atom x)) (eq (keyp x) '-)))))

;appsum(u, x, y, d) ==
;  null u => d
;  ac := absym first u
;  sc :=
;    syminusp first u => '"-"
;    true => '"+"
;  dp := MEMBER(keyp absym first u, '(_+ _-))
;  tempx := x + WIDTH ac + (dp => 5; true => 3)
;  tempdblock :=
;    temparg1 := APP(sc, x + 1, y, d)
;    dp =>
;      bot := y - subspan ac
;      top := y + superspan ac
;      temparg2 := applpar(x + 3, y, bot, top, temparg1)
;      temparg3 := APP(ac, x + 4, y, temparg2)
;      apprpar(x + 4 + WIDTH ac, y, bot, top, temparg3)
;    true => APP(ac, x + 3, y, temparg1)
;  appsum(rest u, tempx, y, tempdblock)

(defun appsumx (u x y d)
  (prog (|ac| |sc| |dp| |tempx| |temparg1| |bot| |top| |temparg2|
              |temparg3| |tempdblock|)
    (return
      (cond
        ((NULL u) d)
        (t (setq |ac| (absym (car u)))
         (setq |sc|
                  (cond
                    ((syminusp (car u)) "-")
                    (t "+")))
         (setq |dp| (|member| (keyp (absym (car u))) '(+ -)))
         (setq |tempx|
                  (+ (+ x (width |ac|)) (cond (|dp| 5) (t 3))))
         (setq |tempdblock|
                  (progn
                    (setq |temparg1|
                             (APP |sc| (+ x 1) y d))
                    (cond
                      (|dp| (setq |bot|
                                     (- y
                                      (|subspan| |ac|)))
                            (setq |top|
                                     (+ y (|superspan| |ac|)))
                            (setq |temparg2|
                                     (applpar (+ x 3) y |bot|
                                      |top| |temparg1|))
                            (setq |temparg3|
                                     (APP |ac| (+ x 4) y
                                      |temparg2|))
                            (apprpar (+ (+ x 4) (width |ac|))
                                y |bot| |top| |temparg3|))
                      (t (APP |ac| (+ x 3) y |temparg1|)))))
         (appsumx (CDR u) |tempx| y |tempdblock|))))))

;appneg(u, x, y, d) ==
;  appsum(LIST u, x - 1, y, d)

(defun |appneg| (u x y d)
 (appsumx (LIST u) (- x 1) y d)) 

;appparu(u, x, y, d) ==
;  bot := y - subspan u
;  top := y + superspan u
;  temparg1 := applpar(x, y, bot, top, d)
;  temparg2 := APP(u, x + 1, y, temparg1)
;  apprpar(x + 1 + WIDTH u, y, bot, top, temparg2)

(defun |appparu| (u x y d)
  (prog (|bot| |top| |temparg1| |temparg2|)
    (return
      (progn
        (setq |bot| (- y (|subspan| u)))
        (setq |top| (+ y (|superspan| u)))
        (setq |temparg1| (applpar x y |bot| |top| d))
        (setq |temparg2| (APP u (+ x 1) y |temparg1|))
        (apprpar (+ (+ x 1) (width u)) y |bot| |top|
            |temparg2|)))))

;appparu1(u, x, y, d) ==
;  appparu(CADR u, x, y, d)

(defun |appparu1| (u x y d)
  (|appparu| (CADR u) x y d))

;appsc(u, x, y, d) ==
;  appagg1(rest u, x, y, d, '";")

(defun |appsc| (u x y d)
  (appagg1 (CDR u) x y d ";"))

;appsetq(u, x, y, d) ==
;  w := WIDTH first u
;  temparg1 := APP(CADR u, x, y, d)
;  temparg2 := APP('":", x + w, y, temparg1)
;  APP(CADR rest u, x + 2 + w, y, temparg2)

(defun |appsetq| (u x y d)
  (prog (w |temparg1| |temparg2|)
    (return
      (progn
        (setq w (width (car u)))
        (setq |temparg1| (APP (CADR u) x y d))
        (setq |temparg2|
                 (APP ":" (+ x w) y |temparg1|))
        (APP (CADR (CDR u)) (+ (+ x 2) w) y |temparg2|)))))

;appsub(u, x, y, d) ==
;  temparg1 := x + WIDTH CADR u
;  temparg2 := y - 1 - superspan CDDR u
;  temparg3 := APP(CADR u, x, y, d)
;  appagg(CDDR u, temparg1, temparg2, temparg3)

(defun |appsub| (u x y d)
  (prog (|temparg1| |temparg2| |temparg3|)
    (return
      (progn
        (setq |temparg1| (+ x (width (CADR u))))
        (setq |temparg2|
                 (- (- y 1)
                     (|superspan| (CDDR u))))
        (setq |temparg3| (APP (CADR u) x y d))
        (appagg (CDDR u) |temparg1| |temparg2| |temparg3|)))))

;eq0(u) == 0

(defun |eq0| (u)
 (declare (ignore u))
 0) 

;height(u) ==
;  superspan(u) + 1 + subspan(u)

(defun |height| (u)
  (+ (+ (|superspan| u) 1) (|subspan| u)))

;extsub(u) ==
;  MAX(subspan agg(5, u), height(agg(3, u)), subspan CADR u  )

(defun |extsub| (u)
  (MAX (|subspan| (agg 5 u)) (|height| (agg 3 u))
       (|subspan| (CADR u))))

;extsuper(u) ==
;  MAX(superspan CADR u + height agg(4, u), superspan agg(5, u) )

(defun |extsuper| (u)
  (MAX (+ (|superspan| (CADR u)) (|height| (agg 4 u)))
       (|superspan| (agg 5 u))))

;extwidth(u) ==
;  n := MAX(WIDTH CADR u,
;           WIDTH agg(4, u),
;           1 + WIDTH agg(2, u) + WIDTH agg(3, u) )
;  nil or
;         (EQCAR(first(z := agg(5, u)), 'EXT) and _
;          (EQ(n, 3) or ((n > 3) and null atom z) )  =>
;          n := 1 + n)
;  true => n + WIDTH agg(5, u)

(defun |extwidth| (u)
  (prog (|z| n)
    (return
      (seq (progn
             (setq n
                      (MAX (width (CADR u)) (width (agg 4 u))
                           (+ (+ 1 (width (agg 2 u)))
                                 (width (agg 3 u)))))
             (seq (or NIL
                      (cond
                        ((and (EQCAR (car (setq |z| (agg 5 u)))
                                     'EXT)
                              (or (eq n 3)
                                  (and (> n 3) (NULL (atom |z|)))))
                         (exit (setq n (+ 1 n))))))
                  (+ n (width (agg 5 u)))))))))

;appfrac(u, x, y, d) ==
;  -- Added "1+" to both QUOTIENT statements so that when exact centering is
;  -- not possible, expressions are offset to the right rather than left.
;  -- MCD 16-8-95
;  w := WIDTH u
;  tempx := x + QUOTIENT(1+w - WIDTH CADR rest u, 2)
;  tempy := y - superspan CADR rest u - 1
;  temparg3 := APP(CADR rest u, tempx, tempy, d)
;  temparg4 := apphor(x, x + w - 1, y, temparg3,specialChar('hbar))
;  APP(CADR u,
;        x + QUOTIENT(1+w - WIDTH CADR u, 2),
;          y + 1 + subspan CADR u,
;            temparg4)

(defun |appfrac| (u x y d)
  (prog (w |tempx| |tempy| |temparg3| |temparg4|)
    (return
      (progn
        (setq w (width u))
        (setq |tempx|
                 (+ x
                       (QUOTIENT
                           (- (+ 1 w)
                               (width (CADR (CDR u))))
                           2)))
        (setq |tempy|
                 (-
                     (- y
                         (|superspan| (CADR (CDR u))))
                     1))
        (setq |temparg3| (APP (CADR (CDR u)) |tempx| |tempy| d))
        (setq |temparg4|
                 (apphor x (- (+ x w) 1) y
                     |temparg3| (|specialChar| '|hbar|)))
        (APP (CADR u)
             (+ x
                   (QUOTIENT
                       (- (+ 1 w) (width (CADR u)))
                       2))
             (+ (+ y 1) (|subspan| (CADR u))) |temparg4|)))))

;fracsub(u) == height CADR rest u

(defun |fracsub| (u)
 (|height| (CADR (CDR u)))) 

;fracsuper(u) == height CADR u

(defun |fracsuper| (u)
 (|height| (CADR u))) 

;fracwidth(u) ==
;  numw := WIDTH (num := CADR u)
;  denw := WIDTH (den := CADDR u)
;  if num is [[op,:.],:.] and op = 'OVER then numw := numw + 2
;  if den is [[op,:.],:.] and op = 'OVER then denw := denw + 2
;  MAX(numw,denw)

(defun |fracwidth| (u)
  (prog (|num| |den| |numw| tmp1 |op| |denw|)
    (return
      (progn
        (setq |numw| (width (setq |num| (CADR u))))
        (setq |denw| (width (setq |den| (CADDR u))))
        (cond
          ((and (consp |num|)
                (progn
                  (setq tmp1 (qcar |num|))
                  (and (consp tmp1)
                       (progn (setq |op| (qcar tmp1)) t)))
                (eq |op| 'OVER))
           (setq |numw| (+ |numw| 2))))
        (cond
          ((and (consp |den|)
                (progn
                  (setq tmp1 (qcar |den|))
                  (and (consp tmp1)
                       (progn (setq |op| (qcar tmp1)) t)))
                (eq |op| 'OVER))
           (setq |denw| (+ |denw| 2))))
        (MAX |numw| |denw|)))))

;slashSub u ==
;  MAX(1,subspan(CADR u),subspan(CADR rest u))

(defun |slashSub| (u)
 (MAX 1 (|subspan| (CADR u)) (|subspan| (CADR (CDR u))))) 

;slashSuper u ==
;  MAX(1,superspan(CADR u),superspan(CADR rest u))

(defun |slashSuper| (u)
 (MAX 1 (|superspan| (CADR u)) (|superspan| (CADR (CDR u))))) 

;slashApp(u, x, y, d) ==
;  -- to print things as a/b as opposed to
;  --      a
;  --      -
;  --      b
;  temparg1 := APP(CADR u, x, y, d)
;  temparg2 := APP('"/", x + WIDTH CADR u, y, temparg1)
;  APP(CADR rest u,
;     x + 1 + WIDTH CADR u, y, temparg2)

(defun |slashApp| (u x y d)
  (prog (|temparg1| |temparg2|)
    (return
      (progn
        (setq |temparg1| (APP (CADR u) x y d))
        (setq |temparg2|
                 (APP "/" (+ x (width (CADR u)))
                      y |temparg1|))
        (APP (CADR (CDR u)) (+ (+ x 1) (width (CADR u)))
             y |temparg2|)))))

;slashWidth(u) ==
;  -- to print things as a/b as opposed to
;  --      a
;  --      -
;  --      b
;  1 + WIDTH CADR u + WIDTH CADR rest u

(defun |slashWidth| (u)
 (+ (+ 1 (width (CADR u))) (width (CADR (CDR u))))) 

(defun longext (u |i| n)
  (prog (x y)
    (declare (special |$algebraOutputStream| |$collectOutput|))
    (return
      (progn
        (setq x (reverse u))
        (setq y (car x))
        (setq u
                 (remWidth
                     (REVERSEWOC (cons " " (CDR x)))))
        (charybdis u |i| n)
        (cond
          ((NULL |$collectOutput|) (TERPRI |$algebraOutputStream|)))
        (charybdis (cons 'ELSE (LIST y)) |i| n)
        " "))))

;appvertline(char, x, yl, yu, d) ==
;  yu < yl => d
;  temparg :=  appvertline(char, x, yl, yu - 1, d)
;  true => APP(char, x, yu, temparg)

(defun appvertline (|char| x |yl| |yu| d)
  (prog (|temparg|)
    (return
      (cond
        ((> |yl| |yu|) d)
        (t
         (setq |temparg|
                  (appvertline |char| x |yl|
                      (- |yu| 1) d))
         (APP |char| x |yu| |temparg|))))))

;appHorizLine(xl, xu, y, d) ==
;  xu < xl => d
;  temparg :=  appHorizLine(xl, xu - 1, y, d)
;  true => APP("*", xu, y, temparg)

(defun appHorizLine (|xl| |xu| y d)
  (prog (|temparg|)
    (return
      (cond
        ((> |xl| |xu|) d)
        (t
         (setq |temparg|
                  (appHorizLine |xl| (- |xu| 1) y d))
         (APP "*" |xu| y |temparg|))))))

;rootApp(u, x, y, d) ==
;  widB := WIDTH u.1
;  supB := superspan u.1
;  subB := subspan u.1
;  if #u > 2 then
;    widR := WIDTH u.2
;    subR := subspan u.2
;    d    := APP(u.2,  x, y - subB + 1 + subR, d)
;  else
;    widR := 1
;  d := APP(u.1, x + widR + 1, y, d)
;  d := apphor(x+widR+1, x+widR+widB, y+supB+1, d, specialChar('hbar))
;  d := appvertline(specialChar('vbar), x+widR, y - subB, y + supB, d)
;  d := APP(specialChar('ulc), x+widR, y + supB+1, d)
;  d := APP(specialChar('urc), x + widR + widB + 1, y + supB+1, d)
;  d := APP(specialChar('bslash), x + widR - 1, y - subB, d)

 (defun |rootApp| (u x y d)
  (prog (|widB| |supB| |subB| |subR| |widR|)
    (return
      (progn
        (setq |widB| (width (elt u 1)))
        (setq |supB| (|superspan| (elt u 1)))
        (setq |subB| (|subspan| (elt u 1)))
        (cond
          ((> (|#| u) 2) (setq |widR| (width (elt u 2)))
           (setq |subR| (|subspan| (elt u 2)))
           (setq d
                    (APP (elt u 2) x
                         (+ (+ (- y |subB|) 1)
                               |subR|)
                         d)))
          (t (setq |widR| 1)))
        (setq d
                 (APP (elt u 1) (+ (+ x |widR|) 1) y d))
        (setq d
                 (apphor (+ (+ x |widR|) 1)
                     (+ (+ x |widR|) |widB|)
                     (+ (+ y |supB|) 1) d
                     (|specialChar| '|hbar|)))
        (setq d
                 (appvertline (|specialChar| '|vbar|)
                     (+ x |widR|) (- y |subB|)
                     (+ y |supB|) d))
        (setq d
                 (APP (|specialChar| '|ulc|) (+ x |widR|)
                      (+ (+ y |supB|) 1) d))
        (setq d
                 (APP (|specialChar| '|urc|)
                      (+ (+ (+ x |widR|) |widB|) 1)
                      (+ (+ y |supB|) 1) d))
        (setq d
                 (APP (|specialChar| '|bslash|)
                      (- (+ x |widR|) 1)
                      (- y |subB|) d))))))

;boxApp(u, x, y, d) ==
;  CDDR u => boxLApp(u, x, y, d)
;  a := 1 + superspan u.1
;  b := 1 + subspan u.1
;  w := 2 + WIDTH u.1
;  d := appvertline(specialChar('vbar), x,y - b + 1, y + a - 1, d)
;  d := appvertline(specialChar('vbar), x + w + 1, y - b,y + a,d)
;  d := apphor(x + 1, x + w, y - b, d, specialChar('hbar))
;  d := apphor(x + 1, x + w, y + a, d, specialChar('hbar))
;  d := APP(specialChar('ulc), x,         y + a, d)
;  d := APP(specialChar('urc), x + w + 1, y + a, d)
;  d := APP(specialChar('llc), x,         y - b, d)
;  d := APP(specialChar('lrc), x + w + 1, y - b, d)
;  d := APP(u.1, 2 + x, y, d)

(defun |boxApp| (u x y d)
  (prog (a b w)
    (return
      (cond
        ((CDDR u) (boxLApp u x y d))
        (t (setq a (+ 1 (|superspan| (elt u 1))))
         (setq b (+ 1 (|subspan| (elt u 1))))
         (setq w (+ 2 (width (elt u 1))))
         (setq d
                  (appvertline (|specialChar| '|vbar|) x
                      (+ (- y b) 1)
                      (- (+ y a) 1) d))
         (setq d
                  (appvertline (|specialChar| '|vbar|)
                      (+ (+ x w) 1) (- y b)
                      (+ y a) d))
         (setq d
                  (apphor (+ x 1) (+ x w)
                      (- y b) d
                      (|specialChar| '|hbar|)))
         (setq d
                  (apphor (+ x 1) (+ x w) (+ y a)
                      d (|specialChar| '|hbar|)))
         (setq d
                  (APP (|specialChar| '|ulc|) x (+ y a) d))
         (setq d
                  (APP (|specialChar| '|urc|) (+ (+ x w) 1)
                       (+ y a) d))
         (setq d
                  (APP (|specialChar| '|llc|) x
                       (- y b) d))
         (setq d
                  (APP (|specialChar| '|lrc|) (+ (+ x w) 1)
                       (- y b) d))
         (setq d (APP (elt u 1) (+ 2 x) y d)))))))

;boxLApp(u, x, y, d) ==
;  la := superspan u.2
;  lb := subspan u.2
;  lw := 2 + WIDTH u.2
;  lh := 2 + la + lb
;  a := superspan u.1+1
;  b := subspan u.1+1
;  w := MAX(lw, 2 + WIDTH u.1)
;  -- next line used to have h instead of lh
;  top := y + a + lh
;  d := appvertline("*", x, y - b, top, d)
;  d := appHorizLine(x + 1, x + w, top, d)
;  d := APP(u.2, 2 + x, y + a + lb + 1, d)
;  d := appHorizLine(x + 1, x + lw, y + a, d)
;  nil or
;     lw < w => d := appvertline("*", x + lw + 1, y + a, top - 1, d)
;  d := APP(u.1, 2 + x, y, d)
;  d := appHorizLine(x + 1, x + w, y - b, top, d)
;  d := appvertline("*", x + w + 1, y - b, top, d)

(defun boxLApp (u x y d)
  (prog (|la| |lb| |lw| |lh| a b w |top|)
    (return
      (progn
        (setq |la| (|superspan| (elt u 2)))
        (setq |lb| (|subspan| (elt u 2)))
        (setq |lw| (+ 2 (width (elt u 2))))
        (setq |lh| (+ (+ 2 |la|) |lb|))
        (setq a (+ (|superspan| (elt u 1)) 1))
        (setq b (+ (|subspan| (elt u 1)) 1))
        (setq w (MAX |lw| (+ 2 (width (elt u 1)))))
        (setq |top| (+ (+ y a) |lh|))
        (setq d
                 (appvertline "*" x (- y b)
                     |top| d))
        (setq d
                 (appHorizLine (+ x 1) (+ x w) |top| d))
        (setq d
                 (APP (elt u 2) (+ 2 x)
                      (+ (+ (+ y a) |lb|) 1) d))
        (setq d
                 (appHorizLine (+ x 1) (+ x |lw|)
                     (+ y a) d))
        (cond
          ((or NIL (> w |lw|))
           (setq d
                    (appvertline "*" (+ (+ x |lw|) 1)
                        (+ y a) (- |top| 1) d)))
          (t (setq d (APP (elt u 1) (+ 2 x) y d))
           (setq d
                    (appHorizLine (+ x 1) (+ x w)
                        (- y b) |top| d))
           (setq d
                    (appvertline "*" (+ (+ x w) 1)
                        (- y b) |top| d))))))))

;boxSub(x) ==
;  subspan x.1+1

(defun |boxSub| (x)
 (+ (|subspan| (elt x 1)) 1)) 

;boxSuper(x) ==
;  null CDR x => 0
;  hl :=
;    null CDDR x => 0
;    true => 2 + subspan x.2 + superspan x.2
;  true => hl+1 + superspan x.1

(defun |boxSuper| (x)
  (prog (|hl|)
    (return
      (cond
        ((NULL (CDR x)) 0)
        (t
         (setq |hl|
                  (cond
                    ((NULL (CDDR x)) 0)
                    (t
                     (+ (+ 2 (|subspan| (elt x 2)))
                           (|superspan| (elt x 2))))))
         (+ (+ |hl| 1) (|superspan| (elt x 1))))))))

;boxWidth(x) ==
;  null CDR x => 0
;  wl :=
;    null CDDR x => 0
;    true => WIDTH x.2
;  true => 4 + MAX(wl, WIDTH x.1)

(defun |boxWidth| (x)
  (prog (|wl|)
    (return
      (cond
        ((NULL (CDR x)) 0)
        (t
         (setq |wl|
                  (cond
                    ((NULL (CDDR x)) 0)
                    (t (width (elt x 2)))))
         (+ 4 (MAX |wl| (width (elt x 1)))))))))

;nothingWidth x ==
;    0

(defun |nothingWidth| (x)
 (declare (ignore x))
 0) 

;nothingSuper x ==
;    0

(defun |nothingSuper| (x)
 (declare (ignore x))
 0) 

;nothingSub x ==
;    0

(defun |nothingSub| (x)
 (declare (ignore x))
 0) 

;nothingApp(u, x, y, d) ==
;    d

(defun |nothingApp| (u x y d)
 (declare (ignore u x y))
 d) 

;zagApp(u, x, y, d) ==
;    w := WIDTH u
;    denx := x + QUOTIENT(w - WIDTH CADR rest u, 2)
;    deny := y - superspan CADR rest u - 1
;    d    := APP(CADR rest u, denx, deny, d)
;    numx := x + QUOTIENT(w - WIDTH CADR u, 2)
;    numy := y+1 + subspan CADR u
;    d    := APP(CADR u, numx, numy, d)
;    a := 1 + zagSuper u
;    b := 1 + zagSub u
;    d := appvertline(specialChar('vbar), x,         y - b, y - 1, d)
;    d := appvertline(specialChar('vbar), x + w - 1, y + 1, y + a, d)
;    d := apphor(x, x + w - 2, y, d, specialChar('hbar))
;    d := APP(specialChar('ulc), x, y, d)
;    d := APP(specialChar('lrc), x + w - 1, y, d)

(defun |zagApp| (u x y d)
  (prog (w |denx| |deny| |numx| |numy| a b)
    (return
      (progn
        (setq w (width u))
        (setq |denx|
                 (+ x
                       (QUOTIENT
                           (- w
                               (width (CADR (CDR u))))
                           2)))
        (setq |deny|
                 (-
                     (- y
                         (|superspan| (CADR (CDR u))))
                     1))
        (setq d (APP (CADR (CDR u)) |denx| |deny| d))
        (setq |numx|
                 (+ x
                       (QUOTIENT
                           (- w (width (CADR u))) 2)))
        (setq |numy| (+ (+ y 1) (|subspan| (CADR u))))
        (setq d (APP (CADR u) |numx| |numy| d))
        (setq a (+ 1 (|zagSuper| u)))
        (setq b (+ 1 (|zagSub| u)))
        (setq d
                 (appvertline (|specialChar| '|vbar|) x
                     (- y b) (- y 1)
                     d))
        (setq d
                 (appvertline (|specialChar| '|vbar|)
                     (- (+ x w) 1) (+ y 1)
                     (+ y a) d))
        (setq d
                 (apphor x (- (+ x w) 2) y
                     d (|specialChar| '|hbar|)))
        (setq d (APP (|specialChar| '|ulc|) x y d))
        (setq d
                 (APP (|specialChar| '|lrc|)
                      (- (+ x w) 1) y d))))))

;zagSub(u) ==
;    height CADR rest u

(defun |zagSub| (u)
 (|height| (CADR (CDR u)))) 

;zagSuper(u) ==
;    height CADR u

(defun |zagSuper| (u)
 (|height| (CADR u))) 

;zagWidth(x) ==
;   #x = 1 => 0
;   #x = 2 => 4 + WIDTH x.1
;   4 + MAX(WIDTH x.1, WIDTH x.2)

(defun |zagWidth| (x)
  (cond
    ((EQL (|#| x) 1) 0)
    ((EQL (|#| x) 2) (+ 4 (width (elt x 1))))
    (t (+ 4 (MAX (width (elt x 1)) (width (elt x 2)))))))

;rootWidth(x) ==
;   #x <= 2 => 3 + WIDTH x.1
;   2 + WIDTH x.1 + WIDTH x.2

(defun |rootWidth| (x)
  (cond
    ((<= (|#| x) 2) (+ 3 (width (elt x 1))))
    (t (+ (+ 2 (width (elt x 1))) (width (elt x 2))))))

;rootSub(x) ==
;   subspan x.1

(defun |rootSub| (x)
 (|subspan| (elt x 1))) 

;rootSuper(x) ==
;   normal := 1 + superspan x.1
;   #x <= 2 => normal
;   (radOver := height x.2 - height x.1) < 0 => normal
;   normal + radOver

(defun |rootSuper| (x)
  (prog (|normal| |radOver|)
    (return
      (progn
        (setq |normal| (+ 1 (|superspan| (elt x 1))))
        (cond
          ((<= (|#| x) 2) |normal|)
          ((MINUSP (setq |radOver|
                            (- (|height| (elt x 2))
                                (|height| (elt x 1)))))
           |normal|)
          (t (+ |normal| |radOver|)))))))

;appmat(u, x, y, d) ==
;   rows := CDDR u
;   p := matSuper u
;   q := matSub u
;   d := matrixBorder(x, y - q, y + p, d, 'left)
;   x := 1 + x
;   yc := 1 + y + p
;   w := CADR u
;   wl := CDAR w
;   subl := rest CADR w
;   superl := rest CADR rest w
;   repeat
;      null rows => return(matrixBorder(x + WIDTH u - 2,
;                                       y - q,
;                                       y + p,
;                                       d,
;                                       'right))
;      xc := x
;      yc := yc - 1 - first superl
;      w := wl
;      row := CDAR rows
;      repeat
;            if flag = '"ON" then
;               flag := '"OFF"
;               return(nil)
;            null row =>
;                  repeat
;                     yc := yc - 1 - first subl
;                     subl := rest subl
;                     superl := rest superl
;                     rows := rest rows
;                     return(flag  := '"ON"; nil)
;            d := APP(first row,
;                     xc + QUOTIENT(first w - WIDTH first row, 2),
;                     yc,
;                     d)
;            xc := xc + 2 + first w
;            row := rest row
;            w := rest w

(defun |appmat| (u x y d)
  (prog (|p| |q| |wl| |yc| |subl| |superl| |rows| |flag| |xc| |row|
             w)
    (return
      (seq (progn
             (setq |rows| (CDDR u))
             (setq |p| (|matSuper| u))
             (setq |q| (|matSub| u))
             (setq d
                      (matrixBorder x (- y |q|)
                          (+ y |p|) d '|left|))
             (setq x (+ 1 x))
             (setq |yc| (+ (+ 1 y) |p|))
             (setq w (CADR u))
             (setq |wl| (CDAR w))
             (setq |subl| (CDR (CADR w)))
             (setq |superl| (CDR (CADR (CDR w))))
             (do () (NIL nil)
               (seq (exit (cond
                            ((NULL |rows|)
                             (return
                               (matrixBorder
                                   (-
                                    (+ x (width u)) 2)
                                   (- y |q|)
                                   (+ y |p|) d '|right|)))
                            (t (setq |xc| x)
                             (setq |yc|
                                      (-
                                       (- |yc| 1)
                                       (car |superl|)))
                             (setq w |wl|)
                             (setq |row| (CDAR |rows|))
                             (do () (NIL nil)
                               (seq (EXIT
                                     (progn
                                       (cond
                                         ((string= |flag|
                                           "ON")
                                          (setq |flag|
                                           "OFF")
                                          (return nil)))
                                       (cond
                                         ((NULL |row|)
                                          (do () (NIL nil)
                                            (SEQ
                                             (EXIT
                                              (progn
                                                (setq |yc|
                                                 (-
                                                  (- |yc|
                                                   1)
                                                  (car |subl|)))
                                                (setq |subl|
                                                 (CDR |subl|))
                                                (setq |superl|
                                                 (CDR |superl|))
                                                (setq |rows|
                                                 (CDR |rows|))
                                                (return
                                                  (progn
                                                    (setq |flag|
                                                     "ON")
                                                    nil)))))))
                                         (t
                                          (setq d
                                           (APP (car |row|)
                                            (+ |xc|
                                             (QUOTIENT
                                              (- (car w)
                                               (width (car |row|)))
                                              2))
                                            |yc| d))
                                          (setq |xc|
                                           (+ (+ |xc| 2)
                                            (car w)))
                                          (setq |row| (CDR |row|))
                                        (setq w (CDR w))))))))))))))))))

;matSuper(x) ==
;  (x := x.1) => -1 + QUOTIENT(first x.1 + first x.2, 2)
;  true => ERROR('MAT)

(defun |matSuper| (x)
  (cond
    ((setq x (elt x 1))
     (+ (- 1)
           (QUOTIENT (+ (car (elt x 1)) (car (elt x 2))) 2)))
    (t (ERROR 'MAT))))

;matSub(x) ==
;  (x := x.1) => QUOTIENT(-1 + first x.1 + first x.2, 2)
;  true => ERROR('MAT)

(defun |matSub| (x)
  (cond
    ((setq x (elt x 1))
     (QUOTIENT
         (+ (+ (- 1) (car (elt x 1)))
               (car (elt x 2)))
         2))
    (t (ERROR 'MAT))))

;matWidth(x) ==
;  y := CDDR x  -- list of rows, each of form ((ROW . w) element element ...)
;  numOfColumns := LENGTH CDAR y
;  widthList := matLSum2 matWList(y, NLIST(numOfColumns, 0))
;    --returns ["max width of entries in column i" for i in 1..numberOfRows]
;  subspanList := matLSum matSubList y
;  superspanList := matLSum matSuperList y
;  RPLAC(x.1,[widthList, subspanList, superspanList])
;  CAAR x.1

(defun |matWidth| (x)
  (prog (y |numOfColumns| |widthList| |subspanList| |superspanList|)
    (return
      (progn
        (setq y (CDDR x))
        (setq |numOfColumns| (LENGTH (CDAR y)))
        (setq |widthList|
                 (matLSum2 (matWList y (NLIST |numOfColumns| 0))))
        (setq |subspanList| (matLSum (matSubList y)))
        (setq |superspanList| (matLSum (matSuperList y)))
        (RPLAC (elt x 1)
               (cons |widthList|
                     (cons |subspanList| (cons |superspanList| nil))))
        (CAAR (elt x 1))))))

;matLSum(x) ==
;  CONS(sumoverlist x + LENGTH x, x)

(defun matLSum (x)
 (cons (+ (sumoverlist x) (LENGTH x)) x)) 

;matLSum2(x) ==
;  CONS(sumoverlist x + 2*(LENGTH x), x)

(defun matLSum2 (x)
 (cons (+ (sumoverlist x) (TIMES 2 (LENGTH x))) x)) 

;matWList(x, y) ==
;  null x => y
;  true => matWList(rest x, matWList1(CDAR x, y) )

(defun matWList (x y)
  (cond
    ((NULL x) y)
    (t (matWList (CDR x) (matWList1 (CDAR x) y)))))

;matWList1(x, y) ==
;  null x => nil
;  true => CONS(MAX(WIDTH first x, first y), matWList1(rest x, rest y) )

(defun matWList1 (x y)
  (cond
    ((NULL x) nil)
    (t
     (cons (MAX (width (car x)) (car y))
           (matWList1 (CDR x) (CDR y))))))

;matSubList(x) ==  --computes the max/[subspan(e) for e in "row named x"]
;  null x => nil
;  true => CONS(matSubList1(CDAR x, 0), matSubList(rest x) )

(defun matSubList (x)
  (cond
    ((NULL x) nil)
    (t (cons (matSubList1 (CDAR x) 0) (matSubList (CDR x))))))

;matSubList1(x, y) ==
;  null x => y
;  true => matSubList1(rest x, MAX(y, subspan first x) )

(defun matSubList1 (x y)
  (cond
    ((NULL x) y)
    (t (matSubList1 (CDR x) (MAX y (|subspan| (car x)))))))

;matSuperList(x) ==  --computes the max/[superspan(e) for e in "row named x"]
;  null x => nil
;  true => CONS(matSuperList1(CDAR x, 0), matSuperList(rest x) )

(defun matSuperList (x)
  (cond
    ((NULL x) nil)
    (t
     (cons (matSuperList1 (CDAR x) 0) (matSuperList (CDR x))))))

;matSuperList1(x, y) ==
;  null x => y
;  true => matSuperList1(rest x, MAX(y, superspan first x) )

(defun matSuperList1 (x y)
  (cond
    ((NULL x) y)
    (t (matSuperList1 (CDR x) (MAX y (|superspan| (car x)))))))

;minusWidth(u) ==
;  -1 + sumWidthA rest u

(defun |minusWidth| (u)
 (+ (- 1) (sumWidthA (CDR u)))) 

;-- opSrch(name, x) ==
;--   LASSOC(name, x) or '","
;bracketagglist(u, start, linelength, tchr, open, close) ==
;  u := CONS(LIST('CONCAT, open, first u),
;            [LIST('CONCAT, '" ", y) for y in rest u] )
;  repeat
;    s := 0
;    for x in tails u repeat
;             lastx := x
;             ((s := s + WIDTH first x + 1) >= linelength) => return(s)
;             null rest x => return(s := -1)
;    nil or
;       EQ(s, -1) => (nextu := nil)
;       EQ(lastx, u) => ((nextu := rest u); RPLACD(u, nil) )
;       true => ((nextu := lastx); RPLACD(PREDECESSOR(lastx, u), nil))
;    for x in tails u repeat
;           RPLACA(x, LIST('CONCAT, first x, tchr))
;    if null nextu then RPLACA(CDDR LAST u, close)
;    x := ASSOCIATER('CONCAT, CONS(ichr, u))
;    charybdis(ASSOCIATER('CONCAT, u), start, linelength)
;    if $collectOutput then TERPRI $algebraOutputStream
;    ichr := '" "
;    u := nextu
;    null u => return(nil)

(defun associater (FN LST)
  (cond ((NULL LST) nil)
        ((NULL (CDR LST)) (car LST))
        ((LIST FN (car LST) (associater FN (CDR LST))))))

(defun bracketagglist (u start linelength |tchr| |open| |close|)
  (prog (|lastx| |s| |nextu| x |ichr|)
  (declare (special |$algebraOutputStream| |$collectOutput|))
    (return
      (seq (progn
             (setq u
                      (cons (LIST 'CONCAT |open| (car u))
                            (prog (G169906)
                              (setq G169906 nil)
                              (return
                                (do ((G169911 (CDR u)
                                      (CDR G169911))
                                     (y nil))
                                    ((or (atom G169911)
                                      (progn
                                        (setq y (car G169911))
                                        nil))
                                     (NREVERSE0 G169906))
                                  (seq (EXIT
                                        (setq G169906
                                         (CONS
                                          (LIST 'CONCAT
                                           " " y)
                                          G169906)))))))))
             (do () (NIL nil)
               (seq (exit (progn
                            (setq |s| 0)
                            (do ((x u (CDR x))) ((atom x) nil)
                              (seq (EXIT
                                    (progn
                                      (setq |lastx| x)
                                      (cond
                                        ((>=
                                          (setq |s|
                                           (+
                                            (+ |s|
                                             (width (car x)))
                                            1))
                                          linelength)
                                         (return |s|))
                                        ((NULL (CDR x))
                                         (return
                                           (setq |s|
                                            (- 1)))))))))
                            (or NIL
                                (cond
                                  ((eq |s| (- 1))
                                   (setq |nextu| nil))
                                  ((eq |lastx| u)
                                   (setq |nextu| (CDR u))
                                   (RPLACD u nil))
                                  (t (setq |nextu| |lastx|)
                                   (RPLACD (PREDECESSOR |lastx| u)
                                    nil))))
                            (do ((x u (CDR x))) ((atom x) nil)
                              (seq (EXIT
                                    (RPLACA x
                                     (LIST 'CONCAT (car x) |tchr|)))))
                            (cond
                              ((NULL |nextu|)
                               (RPLACA (CDDR (|last| u)) |close|)))
                            (setq x
                                     (associater 'CONCAT
                                      (cons |ichr| u)))
                            (charybdis (associater 'CONCAT u)
                                start linelength)
                            (cond
                              (|$collectOutput|
                                  (TERPRI |$algebraOutputStream|)))
                            (setq |ichr| " ")
                            (setq u |nextu|)
                            (cond ((NULL u) (return nil))))))))))))


;prnd(start, op) ==
;-->
;  $testOutputLineFlag =>
;    string := STRCONC(fillerSpaces MAX(0,start - 1),op)
;    $testOutputLineList := [string,:$testOutputLineList]
;  PRINC(fillerSpaces MAX(0,start - 1),$algebraOutputStream)
;  $collectOutput =>
;    string := STRCONC(fillerSpaces MAX(0,start - 1),op)
;    $outputLines := [string, :$outputLines]
;  PRINC(op,$algebraOutputStream)
;  TERPRI $algebraOutputStream

(defun prnd (start |op|)
  (prog (|string|)
  (declare (special |$algebraOutputStream| |$outputLines| |$collectOutput|
                    |$testOutputLineList| |$testOutputLineFlag|))
    (return
      (cond
        (|$testOutputLineFlag|
            (setq |string|
                     (STRCONC (|fillerSpaces|
                                  (MAX 0 (- start 1)))
                              |op|))
            (setq |$testOutputLineList|
                     (cons |string| |$testOutputLineList|)))
        (t
         (PRINC (|fillerSpaces| (MAX 0 (- start 1)))
             |$algebraOutputStream|)
         (cond
           (|$collectOutput|
               (setq |string|
                        (STRCONC (|fillerSpaces|
                                     (MAX 0 (- start 1)))
                                 |op|))
               (setq |$outputLines| (cons |string| |$outputLines|)))
           (t (PRINC |op| |$algebraOutputStream|)
            (TERPRI |$algebraOutputStream|))))))))

;qTSub(u) ==
;  subspan CADR u

(defun |qTSub| (u) (|subspan| (CADR u))) 

;qTSuper(u) ==
;  superspan CADR u

(defun |qTSuper| (u) (|superspan| (CADR u))) 

;qTWidth(u) ==
;  2 + WIDTH CADR u

(defun |qTWidth| (u) (+ 2 (width (CADR u)))) 

;remWidth(x) ==
;  atom x => x
;  true => CONS( (atom first x => first x; true => CAAR x),
;                MMAPCAR(remWidth, rest x) )

(defun remWidth (x)
  (cond
    ((atom x) x)
    (t
     (cons (cond ((atom (car x)) (car x)) (t (CAAR x)))
           (MMAPCAR #'remWidth (CDR x))))))

;subSub(u) ==
;  height CDDR u

(defun |subSub| (u) (|height| (CDDR u))) 

;subSuper u ==
;  superspan u.1

(defun |subSuper| (u) (|superspan| (elt u 1))) 

;letWidth u ==
;  5 + WIDTH u.1 + WIDTH u.2

(defun |letWidth| (u)
 (+ (+ 5 (width (elt u 1))) (width (elt u 2)))) 

;sumoverlist(u) == +/[x for x in u]

(defun sumoverlist (u)
  (prog ()
    (return
      (seq (prog (G169996)
             (setq G169996 0)
             (return
               (do ((G170001 u (CDR G170001)) (x nil))
                   ((or (atom G170001)
                        (progn (setq x (car G170001)) nil))
                    G169996)
                 (seq (exit (setq G169996 (+ G169996 x)))))))))))

;sumWidth u ==
;  WIDTH u.1 + sumWidthA CDDR u

(defun |sumWidth| (u)
 (+ (width (elt u 1)) (sumWidthA (CDDR u)))) 

;sumWidthA u ==
;  ^u => 0
;  ( MEMBER(keyp absym first u,'(_+ _-)) => 5; true => 3) +
;    WIDTH absym first u +
;      sumWidthA rest u

(defun sumWidthA (u)
  (cond
    ((NULL u) 0)
    (t
     (+ (+ (cond
                   ((|member| (keyp (absym (car u))) '(+ -)) 5)
                   (t 3))
                 (width (absym (car u))))
           (sumWidthA (CDR u))))))

;superSubApp(u, x, y, di) ==
;  a := first (u := rest u)
;  b := first (u := rest u)
;  c := first (u := KDR u) or '((NOTHING . 0))
;  d := KAR   (u := KDR u) or '((NOTHING . 0))
;  e := KADR  u            or '((NOTHING . 0))
;  aox := MAX(wd := WIDTH d, we := WIDTH e)
;  ar := superspan a
;  ab := subspan a
;  aw := WIDTH a
;  di := APP(d, x + (aox - wd), 1 + ar + y + subspan d, di)
;  di := APP(a, x + aox, y, di)
;  di := APP(c, aox + aw + x, 1 + y + ar + subspan c, di)
;  di := APP(e, x + (aox - we), y - 1 - MAX(superspan e, ab), di)
;  di := APP(b, aox + aw + x, y - 1 - MAX(ab, superspan b), di)
;  return di

(defun |superSubApp| (u x y |di|)
  (prog (a b |c| d |e| |wd| |we| |aox| |ar| |ab| |aw|)
    (return
      (progn
        (setq a (car (setq u (CDR u))))
        (setq b (car (setq u (CDR u))))
        (setq |c|
                 (or (car (setq u (IFCDR u))) '((NOTHING . 0))))
        (setq d
                 (or (ifcar (setq u (IFCDR u))) '((NOTHING . 0))))
        (setq |e| (or (ifcar (ifcdr u)) '((NOTHING . 0))))
        (setq |aox|
                 (MAX (setq |wd| (width d))
                      (setq |we| (width |e|))))
        (setq |ar| (|superspan| a))
        (setq |ab| (|subspan| a))
        (setq |aw| (width a))
        (setq |di|
                 (APP d (+ x (- |aox| |wd|))
                      (+ (+ (+ 1 |ar|) y) (|subspan| d))
                      |di|))
        (setq |di| (APP a (+ x |aox|) y |di|))
        (setq |di|
                 (APP |c| (+ (+ |aox| |aw|) x)
                      (+ (+ (+ 1 y) |ar|) (|subspan| |c|))
                      |di|))
        (setq |di|
                 (APP |e| (+ x (- |aox| |we|))
                      (- (- y 1)
                          (MAX (|superspan| |e|) |ab|))
                      |di|))
        (setq |di|
                 (APP b (+ (+ |aox| |aw|) x)
                      (- (- y 1)
                          (MAX |ab| (|superspan| b)))
                      |di|))
        (return |di|)))))

;stringer x ==
;  STRINGP x => x
;  EQ('_|, FETCHCHAR(s:= princ-to-string x, 0)) =>
;    RPLACSTR(s, 0, 1, "", nil, nil)
;  s

(defun stringer (x)
  (prog (|s|)
    (return
      (cond
        ((STRINGP x) x)
        ((eq '|\|| (char (setq |s| (princ-to-string x)) 0))
         (RPLACSTR |s| 0 1 '|| NIL nil))
        (t |s|)))))

;superSubSub u ==
;  a:= first (u:= rest u)
;  b:= KAR (u := KDR u)
;  e:= KAR KDR KDR KDR u
;  return subspan a + MAX(height b, height e)

(defun |superSubSub| (u)
  (prog (a b |e|)
    (return
      (progn
        (setq a (car (setq u (CDR u))))
        (setq b (ifcar (setq u (IFCDR u))))
        (setq |e| (ifcar (IFCDR (IFCDR (IFCDR u)))))
        (return
          (+ (|subspan| a) (MAX (|height| b) (|height| |e|))))))))

;binomApp(u,x,y,d) ==
;  [num,den] := rest u
;  ysub := y - 1 - superspan den
;  ysup := y + 1 + subspan num
;  wden := WIDTH den
;  wnum := WIDTH num
;  w := MAX(wden,wnum)
;  d := APP(den,x+1+(w - wden)/2,ysub,d)
;  d := APP(num,x+1+(w - wnum)/2,ysup,d)
;  hnum := height num
;  hden := height den
;  w := 1 + w
;  for j in 0..(hnum - 1) repeat
;    d := appChar(specialChar 'vbar,x,y + j,d)
;    d := appChar(specialChar 'vbar,x + w,y + j,d)
;  for j in 1..(hden - 1) repeat
;    d := appChar(specialChar 'vbar,x,y - j,d)
;    d := appChar(specialChar 'vbar,x + w,y - j,d)
;  d := appChar(specialChar 'ulc,x,y + hnum,d)
;  d := appChar(specialChar 'urc,x + w,y + hnum,d)
;  d := appChar(specialChar 'llc,x,y - hden,d)
;  d := appChar(specialChar 'lrc,x + w,y - hden,d)

(defun |binomApp| (u x y d)
  (prog (|LETTMP#1| |num| |den| |ysub| |ysup| |wden| |wnum| |hnum|
            |hden| w)
    (return
      (seq (progn
             (setq |LETTMP#1| (CDR u))
             (setq |num| (car |LETTMP#1|))
             (setq |den| (CADR |LETTMP#1|))
             (setq |ysub|
                      (- (- y 1)
                          (|superspan| |den|)))
             (setq |ysup| (+ (+ y 1) (|subspan| |num|)))
             (setq |wden| (width |den|))
             (setq |wnum| (width |num|))
             (setq w (MAX |wden| |wnum|))
             (setq d
                      (APP |den|
                           (+ (+ x 1)
                                 (QUOTIENT (- w |wden|)
                                     2))
                           |ysub| d))
             (setq d
                      (APP |num|
                           (+ (+ x 1)
                                 (QUOTIENT (- w |wnum|)
                                     2))
                           |ysup| d))
             (setq |hnum| (|height| |num|))
             (setq |hden| (|height| |den|))
             (setq w (+ 1 w))
             (do ((G170072 (- |hnum| 1))
                  (|j| 0 (QSADD1 |j|)))
                 ((QSGREATERP |j| G170072) nil)
               (seq (exit (progn
                            (setq d
                                     (appChar (|specialChar| '|vbar|)
                                      x (+ y |j|) d))
                            (setq d
                                     (appChar (|specialChar| '|vbar|)
                                      (+ x w) (+ y |j|)
                                      d))))))
             (do ((G170081 (- |hden| 1))
                  (|j| 1 (QSADD1 |j|)))
                 ((QSGREATERP |j| G170081) nil)
               (seq (exit (progn
                            (setq d
                                     (appChar (|specialChar| '|vbar|)
                                      x (- y |j|) d))
                            (setq d
                                     (appChar (|specialChar| '|vbar|)
                                      (+ x w)
                                      (- y |j|) d))))))
             (setq d
                      (appChar (|specialChar| '|ulc|) x
                          (+ y |hnum|) d))
             (setq d
                      (appChar (|specialChar| '|urc|) (+ x w)
                          (+ y |hnum|) d))
             (setq d
                      (appChar (|specialChar| '|llc|) x
                          (- y |hden|) d))
             (setq d
                      (appChar (|specialChar| '|lrc|) (+ x w)
                          (- y |hden|) d)))))))

;binomSub u == height CADDR u

(defun |binomSub| (u) (|height| (CADDR u))) 

;binomSuper u == height CADR u

(defun |binomSuper| (u) (|height| (CADR u))) 

;binomWidth u == 2 + MAX(WIDTH CADR u, WIDTH CADDR u)

(defun |binomWidth| (u)
 (+ 2 (MAX (width (CADR u)) (width (CADDR u))))) 

;altSuperSubApp(u, x, y, di) ==
;  a  := first (u := rest u)
;  ar := superspan a
;  ab := subspan a
;  aw := WIDTH a
;  di := APP(a, x, y, di)
;  x  := x + aw
;  sublist := everyNth(u := rest u, 2)
;  suplist := everyNth(IFCDR u, 2)
;  ysub := y - 1 - APPLY('MAX, [ab, :[superspan s for s in sublist]])
;  ysup := y + 1 + APPLY('MAX, [ar, :[subspan   s for s in sublist]])
;  for sub in sublist for sup in suplist repeat
;      wsub := WIDTH sub
;      wsup := WIDTH sup
;      di := APP(sub, x, ysub, di)
;      di := APP(sup, x, ysup, di)
;      x := x + 1 + MAX(wsub, wsup)
;  di

(defun |altSuperSubApp| (u x y |di|)
  (prog (a |ar| |ab| |aw| |sublist| |suplist| |ysub| |ysup| |wsub|
             |wsup|)
    (return
      (seq (progn
             (setq a (car (setq u (CDR u))))
             (setq |ar| (|superspan| a))
             (setq |ab| (|subspan| a))
             (setq |aw| (width a))
             (setq |di| (APP a x y |di|))
             (setq x (+ x |aw|))
             (setq |sublist| (everyNth (setq u (CDR u)) 2))
             (setq |suplist| (everyNth (IFCDR u) 2))
             (setq |ysub|
                      (- (- y 1)
                          (APPLY 'MAX
                                 (cons |ab|
                                       (prog (G170124)
                                         (setq G170124 nil)
                                         (return
                                           (DO
                                            ((G170129 |sublist|
                                              (CDR G170129))
                                             (|s| nil))
                                            ((or (atom G170129)
                                              (progn
                                                (setq |s|
                                                 (car G170129))
                                                nil))
                                             (NREVERSE0 G170124))
                                             (SEQ
                                              (EXIT
                                               (setq G170124
                                                (cons (|superspan| |s|)
                                                 G170124)))))))))))
             (setq |ysup|
                      (+ (+ y 1)
                            (APPLY 'MAX
                                   (cons |ar|
                                    (prog (G170139)
                                      (setq G170139 nil)
                                      (return
                                        (DO
                                         ((G170144 |sublist|
                                           (CDR G170144))
                                          (|s| nil))
                                         ((or (atom G170144)
                                           (progn
                                             (setq |s| (car G170144))
                                             nil))
                                          (NREVERSE0 G170139))
                                          (SEQ
                                           (EXIT
                                            (setq G170139
                                             (cons (|subspan| |s|)
                                              G170139)))))))))))
             (do ((G170159 |sublist| (CDR G170159)) (|sub| nil)
                  (G170160 |suplist| (CDR G170160)) (|sup| nil))
                 ((or (atom G170159)
                      (progn (setq |sub| (car G170159)) nil)
                      (atom G170160)
                      (progn (setq |sup| (car G170160)) nil))
                  nil)
               (seq (exit (progn
                            (setq |wsub| (width |sub|))
                            (setq |wsup| (width |sup|))
                            (setq |di| (APP |sub| x |ysub| |di|))
                            (setq |di| (APP |sup| x |ysup| |di|))
                            (setq x
                                     (+ (+ x 1)
                                      (MAX |wsub| |wsup|)))))))
             |di|)))))

;everyNth(l, n) ==
;    [(e := l.0; for i in 1..n while l repeat l := rest l; e) while l]

(defun everyNth (|l| n)
  (prog (|e|)
    (return
      (seq (prog (G170199)
             (setq G170199 nil)
             (return
               (do () ((NULL |l|) (NREVERSE0 G170199))
                 (seq (exit (setq G170199
                                  (cons (progn
                                          (setq |e| (elt |l| 0))
                                          (do ((|i| 1 (QSADD1 |i|)))
                                           ((or (QSGREATERP |i| n)
                                             (NULL |l|))
                                            nil)
                                            (SEQ
                                             (EXIT
                                              (setq |l| (CDR |l|)))))
                                          |e|)
                                        G170199)))))))))))

;altSuperSubSub u ==
;  span := subspan CADR u
;  sublist := everyNth(CDDR u, 2)
;  for sub in sublist repeat
;      h := height sub
;      if h > span then span := h
;  span

(defun |altSuperSubSub| (u)
  (prog (|sublist| |h| |span|)
    (return
      (seq (progn
             (setq |span| (|subspan| (CADR u)))
             (setq |sublist| (everyNth (CDDR u) 2))
             (do ((G170231 |sublist| (CDR G170231)) (|sub| nil))
                 ((or (atom G170231)
                      (progn (setq |sub| (car G170231)) nil))
                  nil)
               (seq (exit (progn
                            (setq |h| (|height| |sub|))
                            (cond
                              ((> |h| |span|) (setq |span| |h|))
                              (t nil))))))
             |span|)))))

;altSuperSubSuper u ==
;  span := superspan CADR u
;  suplist := everyNth(IFCDR CDDR u, 2)
;  for sup in suplist repeat
;      h := height sup
;      if h > span then span := h
;  span

(defun |altSuperSubSuper| (u)
  (prog (|suplist| |h| |span|)
    (return
      (seq (progn
             (setq |span| (|superspan| (CADR u)))
             (setq |suplist| (everyNth (IFCDR (CDDR u)) 2))
             (do ((G170251 |suplist| (CDR G170251)) (|sup| nil))
                 ((or (atom G170251)
                      (progn (setq |sup| (car G170251)) nil))
                  nil)
               (seq (exit (progn
                            (setq |h| (|height| |sup|))
                            (cond
                              ((> |h| |span|) (setq |span| |h|))
                              (t nil))))))
             |span|)))))

;altSuperSubWidth u ==
;  w := WIDTH CADR u
;  suplist := everyNth(IFCDR CDDR u, 2)
;  sublist := everyNth(CDDR u, 2)
;  for sup in suplist for sub in sublist repeat
;      wsup := WIDTH sup
;      wsub := WIDTH sub
;      w := w + 1 + MAX(wsup, wsub)
;  w

(defun |altSuperSubWidth| (u)
  (prog (|suplist| |sublist| |wsup| |wsub| w)
    (return
      (seq (progn
             (setq w (width (CADR u)))
             (setq |suplist| (everyNth (IFCDR (CDDR u)) 2))
             (setq |sublist| (everyNth (CDDR u) 2))
             (do ((G170273 |suplist| (CDR G170273)) (|sup| nil)
                  (G170274 |sublist| (CDR G170274)) (|sub| nil))
                 ((or (atom G170273)
                      (progn (setq |sup| (car G170273)) nil)
                      (atom G170274)
                      (progn (setq |sub| (car G170274)) nil))
                  nil)
               (seq (exit (progn
                            (setq |wsup| (width |sup|))
                            (setq |wsub| (width |sub|))
                            (setq w
                                     (+ (+ w 1)
                                      (MAX |wsup| |wsub|)))))))
             w)))))

;superSubWidth u ==
;  a := first (u := rest u)
;  b := first (u := rest u)
;  c := first (u := KDR u) or '((NOTHING . 0))
;  d := KAR   (u := KDR u) or '((NOTHING . 0))
;  e := KADR  u            or '((NOTHING . 0))
;  return MAX(WIDTH d, WIDTH e) + MAX(WIDTH b, WIDTH c) + WIDTH a

(defun |superSubWidth| (u)
  (prog (a b |c| d |e|)
    (return
      (progn
        (setq a (car (setq u (CDR u))))
        (setq b (car (setq u (CDR u))))
        (setq |c|
                 (or (car (setq u (IFCDR u))) '((NOTHING . 0))))
        (setq d
                 (or (ifcar (setq u (IFCDR u))) '((NOTHING . 0))))
        (setq |e| (or (ifcar (ifcdr u)) '((NOTHING . 0))))
        (return
          (+ (+ (MAX (width d) (width |e|))
                      (MAX (width b) (width |c|)))
                (width a)))))))

;superSubSuper u ==
;  a:= first (u := rest u)
;  c:= KAR (u := KDR KDR u)
;  d:= KADR u
;  return superspan a + MAX(height c, height d)

(defun |superSubSuper| (u)
  (prog (a |c| d)
    (return
      (progn
        (setq a (car (setq u (CDR u))))
        (setq |c| (ifcar (setq u (IFCDR (IFCDR u)))))
        (setq d (ifcar (ifcdr u)))
        (return
          (+ (|superspan| a) (MAX (|height| |c|) (|height| d))))))))

;suScWidth u ==
;  WIDTH u.1 + aggwidth CDDR u

(defun |suScWidth| (u)
 (+ (width (elt u 1)) (|aggwidth| (CDDR u)))) 

;transcomparg(x) ==
;  y := first x
;  args := first _*NTH(STANDARGLIST, 1 + LENGTH y)
;  repeat
;    if true then
;       null y => return(nil)
;       (atom first y) and MEMBER(first y, FRLIS_*) =>
;            conds := CONS(LIST('EQUAL1, first args, first y), conds)
;            y := SUBST(first args, first y, y)
;            x := SUBST(first args, first y, x)
;       (first y = first args) => nil
;       true => conds := CONS(LIST('EQUAL1, first args, first y), conds)
;    y := rest y
;    args := rest args
;  conds :=
;       null conds => rest CADR x
;       ANDSIMP(CONS('AND, APPEND(REVERSEWOC conds,
;                                         LIST(rest CADR x) ) ) )
;  LIST((conds => conds; true => 1), CADR rest x)

(defun transcomparg (x)
  (prog (y |args| |conds|)
    (return
      (seq (progn
             (setq y (car x))
             (setq |args|
                      (car (*NTH STANDARGLIST (+ 1 (LENGTH y)))))
             (do () (NIL nil)
               (seq (exit (progn
                            (cond
                              ((NULL y) (return nil))
                              ((and (atom (car y))
                                    (|member| (car y) FRLIS*))
                               (setq |conds|
                                        (CONS
                                         (LIST 'EQUAL1 (car |args|)
                                          (car y))
                                         |conds|))
                               (setq y
                                        (MSUBST (car |args|) (car y)
                                         y))
                               (setq x
                                        (MSUBST (car |args|) (car y)
                                         x)))
                              ((equal (car y) (car |args|)) nil)
                              (t
                               (setq |conds|
                                        (CONS
                                         (LIST 'EQUAL1 (car |args|)
                                          (car y))
                                         |conds|))))
                            (setq y (CDR y))
                            (setq |args| (CDR |args|))))))
             (setq |conds|
                      (cond
                        ((NULL |conds|) (CDR (CADR x)))
                        (t
                         (ANDSIMP (cons 'AND
                                        (APPEND (REVERSEWOC |conds|)
                                         (LIST (CDR (CADR x)))))))))
             (LIST (cond (|conds| |conds|) (t 1)) (CADR (CDR x))))))))

;vconcatapp(u, x, y, d) ==
;  w := vConcatWidth u
;  y := y + superspan u.1 + 1
;  for a in rest u repeat
;      y := y - superspan a - 1
;      xoff := QUOTIENT(w - WIDTH a, 2)
;      d := APP(a, x + xoff, y, d)
;      y := y - subspan a
;  d

(defun |vconcatapp| (u x y d)
  (prog (w |xoff|)
    (return
      (seq (progn
             (setq w (|vConcatWidth| u))
             (setq y
                      (+ (+ y (|superspan| (elt u 1))) 1))
             (do ((G170351 (CDR u) (CDR G170351)) (a nil))
                 ((or (atom G170351)
                      (progn (setq a (car G170351)) nil))
                  nil)
               (seq (exit (progn
                            (setq y
                                     (-
                                      (- y
                                       (|superspan| a))
                                      1))
                            (setq |xoff|
                                     (QUOTIENT
                                      (- w (width a))
                                      2))
                            (setq d
                                     (APP a (+ x |xoff|) y
                                      d))
                            (setq y
                                     (- y
                                      (|subspan| a)))))))
             d)))))

;binomialApp(u, x, y, d) ==
;  [.,b,a] := u
;  w := vConcatWidth u
;  d := APP('"(",x,y,d)
;  x := x + 1
;  y1 := y - height a
;  xoff := QUOTIENT(w - WIDTH a, 2)
;  d := APP(a, x + xoff, y1, d)
;  y2 := y + height b
;  xoff := QUOTIENT(w - WIDTH b, 2)
;  d := APP(b, x + xoff, y2, d)
;  x := x + w
;  APP('")",x,y,d)

(defun |binomialApp| (u x y d)
  (prog (b a w |y1| |y2| |xoff|)
    (return
      (progn
        (setq b (CADR u))
        (setq a (CADDR u))
        (setq w (|vConcatWidth| u))
        (setq d (APP "(" x y d))
        (setq x (+ x 1))
        (setq |y1| (- y (|height| a)))
        (setq |xoff| (QUOTIENT (- w (width a)) 2))
        (setq d (APP a (+ x |xoff|) |y1| d))
        (setq |y2| (+ y (|height| b)))
        (setq |xoff| (QUOTIENT (- w (width b)) 2))
        (setq d (APP b (+ x |xoff|) |y2| d))
        (setq x (+ x w))
        (APP ")" x y d)))))

;vConcatSub u ==
;  subspan u.1 + +/[height a for a in CDDR u]

(defun |vConcatSub| (u)
  (prog ()
    (return
      (seq (+ (|subspan| (elt u 1))
                 (prog (G170385)
                   (setq G170385 0)
                   (return
                     (do ((G170390 (CDDR u) (CDR G170390))
                          (a nil))
                         ((or (atom G170390)
                              (progn (setq a (car G170390)) nil))
                          G170385)
                       (seq (exit (setq G170385
                                    (+ G170385 (|height| a)))))))))))))

;vConcatSuper u ==
;  superspan u.1

(defun |vConcatSuper| (u) (|superspan| (elt u 1))) 

;vConcatWidth u ==
;  w := 0
;  for a in rest u repeat if (wa := WIDTH a) > w then w := wa
;  w

(defun |vConcatWidth| (u)
  (prog (|wa| w)
    (return
      (seq (progn
             (setq w 0)
             (do ((G170407 (CDR u) (CDR G170407)) (a nil))
                 ((or (atom G170407)
                      (progn (setq a (car G170407)) nil))
                  nil)
               (seq (exit (cond
                            ((> (setq |wa| (width a)) w)
                             (setq w |wa|))
                            (t nil)))))
             w)))))

;binomialSub u ==  height u.2 + 1

(defun |binomialSub| (u) (+ (|height| (elt u 2)) 1)) 

;binomialSuper u == height u.1 + 1

(defun |binomialSuper| (u) (+ (|height| (elt u 1)) 1)) 

;binomialWidth u == 2 + MAX(WIDTH u.1, WIDTH u.2)

(defun |binomialWidth| (u)
 (+ 2 (MAX (width (elt u 1)) (width (elt u 2))))) 

;mathPrint u ==
;  if ^$collectOutput then TERPRI $algebraOutputStream
;  (u := STRINGP mathPrint1(mathPrintTran u, nil) =>
;   PSTRING u; nil)

(defun |mathPrint| (u)
  (declare (special |$algebraOutputStream| |$collectOutput|))
  (progn
    (cond ((NULL |$collectOutput|) (TERPRI |$algebraOutputStream|)))
    (cond
      ((setq u (STRINGP (mathPrint1 (mathPrintTran u) nil)))
       (PSTRING u))
      (t nil))))

;mathPrintTran u ==
;  atom u => u
;  true =>
;    for x in tails u repeat
;          RPLAC(first x, mathPrintTran first x)
;    u

(defun mathPrintTran (u)
  (seq (cond
         ((atom u) u)
         (t
          (do ((x u (CDR x))) ((atom x) nil)
            (seq (exit (RPLAC (car x) (mathPrintTran (car x))))))
          u))))

;mathPrint1(x,fg) ==
;  if fg and ^$collectOutput then TERPRI $algebraOutputStream
;  maPrin x
;  if fg and ^$collectOutput then TERPRI $algebraOutputStream

(defun mathPrint1 (x |fg|)
  (declare (special |$algebraOutputStream| |$collectOutput|))
  (progn
    (cond
      ((and |fg| (NULL |$collectOutput|))
       (TERPRI |$algebraOutputStream|)))
    (maPrin x)
    (cond
      ((and |fg| (NULL |$collectOutput|))
       (TERPRI |$algebraOutputStream|))
      (t nil))))

;maPrin u ==
;  null u => nil
;-->
;  if $runTestFlag or $mkTestFlag then
;    $mkTestOutputStack := [COPY u, :$mkTestOutputStack]
;  $highlightDelta := 0
;  c := CATCH('outputFailure,charybdis(u, $MARGIN, $LINELENGTH))
;  c ^= 'outputFailure => c
;  sayKeyedMsg("S2IX0009",NIL)
;  u is ['EQUATNUM,num,form] or u is [['EQUATNUM,:.],num,form] =>
;    charybdis(['EQUATNUM,num], $MARGIN, $LINELENGTH)
;    if ^$collectOutput then
;      TERPRI $algebraOutputStream
;      PRETTYPRINT(form,$algebraOutputStream)
;    form
;  if ^$collectOutput then PRETTYPRINT(u,$algebraOutputStream)
;  nil

(defun maPrin (u)
  (prog (|c| tmp1 tmp2 |num| tmp3 |form|)
  (declare (special |$algebraOutputStream| |$collectOutput| $LINELENGTH
                    $MARGIN |$highlightDelta| |$mkTestOutputStack|
                    |$mkTestFlag| |$runTestFlag|))
    (return
      (cond
        ((NULL u) nil)
        (t
         (cond
           ((or |$runTestFlag| |$mkTestFlag|)
            (setq |$mkTestOutputStack|
                     (cons (COPY u) |$mkTestOutputStack|))))
         (setq |$highlightDelta| 0)
         (setq |c|
                  (CATCH '|outputFailure|
                    (charybdis u $MARGIN $LINELENGTH)))
         (cond
           ((NEQUAL |c| '|outputFailure|) |c|)
           (t (|sayKeyedMsg|
                (format nil
                 "The system cannot print your result. It will be lisp ~
                  pretty-printed: %l")
                  nil)
            (cond
              ((or (and (consp u) (eq (qcar u) 'EQUATNUM)
                        (progn
                          (setq tmp1 (qcdr u))
                          (and (consp tmp1)
                               (progn
                                 (setq |num| (qcar tmp1))
                                 (setq tmp2 (qcdr tmp1))
                                 (and (consp tmp2)
                                      (eq (qcdr tmp2) nil)
                                      (progn
                                        (setq |form|
                                         (qcar tmp2))
                                        t))))))
                   (and (consp u)
                        (progn
                          (setq tmp1 (qcar u))
                          (and (consp tmp1)
                               (eq (qcar tmp1) 'EQUATNUM)))
                        (progn
                          (setq tmp2 (qcdr u))
                          (and (consp tmp2)
                               (progn
                                 (setq |num| (qcar tmp2))
                                 (setq tmp3 (qcdr tmp2))
                                 (and (consp tmp3)
                                      (eq (qcdr tmp3) nil)
                                      (progn
                                        (setq |form|
                                         (qcar tmp3))
                                        t)))))))
               (charybdis (cons 'EQUATNUM (cons |num| nil)) $MARGIN
                   $LINELENGTH)
               (cond
                 ((NULL |$collectOutput|)
                  (TERPRI |$algebraOutputStream|)
                  (PRETTYPRINT |form| |$algebraOutputStream|)))
               |form|)
              (t
               (cond
                 ((NULL |$collectOutput|)
                  (PRETTYPRINT u |$algebraOutputStream|)))
               nil)))))))))


\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
