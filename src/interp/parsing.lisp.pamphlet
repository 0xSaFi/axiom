\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp parsing.lisp}
\author{Timothy Daly}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject

<<*>>=
(in-package "BOOT")

@
\chapter{META/LISP Parser Generator and Lexical Analysis Utilities (Parsing)}
\section{Current I/O Stream definition}
<<*>>=
(defun IOStreams-Show ()
  (format t "~&Input is coming from ~A, and output is going to ~A.~%"
           (or (streamp in-stream) "the keyboard")
           (or (streamp out-stream) "the screen"))
  (format t 
    "~:[~;The current input stream is logically closed.~%~]~%" File-Closed))

(defmacro IOStreams-Set (input output)
 `(setq in-stream ,input out-stream ,output))

(defmacro IOStreams-Clear (&optional (in t) (out t))
  `(progn (and (streamp in-stream) (close in-stream))
          (and (streamp out-stream) (close out-stream))
          (setq File-Closed nil)
          (IOStreams-Set ,in ,out)))

@
\section{Data structure declarations (defstructs) for parsing objects}
<<*>>=

(defstruct Line "Line of input file to parse."
           (Buffer (make-string 0) :type string)
           (Current-Char #\Return :type character)
           (Current-Index 1 :type fixnum)
           (Last-Index 0 :type fixnum)
           (Number 0 :type fixnum))

(defun Line-Print (line)
  (format out-stream "~&~5D> ~A~%" (Line-Number line) (Line-Buffer Line))
  (format out-stream "~v@T^~%" (+ 7 (Line-Current-Index line))))

(defmacro Line-Clear (line)
  `(let ((l ,line))
     (setf (Line-Buffer l) (make-string 0))
     (setf (Line-Current-Char l) #\Return)
     (setf (Line-Current-Index l) 1)
     (setf (Line-Last-Index l) 0)
     (setf (Line-Number l) 0)))

(defun Line-Current-Segment (line)
  "Buffer from current index to last index."
  (if (line-at-end-p line) 
   (make-string 0)
   (subseq (Line-Buffer line)
           (Line-Current-Index line)
           (Line-Last-Index line))))

(defun Line-Advance-Char (line)
  (setf (Line-Current-Char line)
        (elt (Line-Buffer line) (incf (Line-Current-Index line)))))

(defun Line-Next-Char (line)
  (elt (Line-Buffer line) (1+ (Line-Current-Index line))))

(defun Line-Past-End-P (line)
  "Tests if line is empty or positioned past the last character."
  (> (line-current-index line) (line-last-index line)))

(defun Line-At-End-P (line)
  "Tests if line is empty or positioned past the last character."
  (>= (line-current-index line) (line-last-index line)))

@
\subsection{Stack}
<<*>>=
(defstruct Stack                "A stack"
           (Store nil)          ; contents of the stack
           (Size 0)             ; number of elements in Store
           (Top nil)            ; first element of Store

           (Updated nil)        ; whether something has been pushed on the stack
                                ; since this flag was last set to NIL
)

(defun stack-load (list stack)
  (setf (stack-store stack) list)
  (setf (stack-size stack) (length list))
  (setf (stack-top stack) (car list)))

(defun stack-clear (stack)
  (setf (stack-store stack) nil)
  (setf (stack-size stack) 0)
  (setf (stack-top stack) nil)
  (setf (stack-updated stack) nil))

(defmacro stack-/-empty (stack) `(> (stack-size ,stack) 0))

(defun stack-push (x stack)
  (push x (stack-store stack))
  (setf (stack-top stack) x)
  (setf (stack-updated stack) t)
  (incf (stack-size stack))
  x)

(defun stack-pop (stack)
  (let ((y (pop (stack-store stack))))
    (decf (stack-size stack))
    (setf (stack-top stack)
          (if (stack-/-empty stack) (car (stack-store stack))))
    y))

@
\subsection{Token}
<<*>>=
(defstruct Token
  "A token is a Symbol with a Type.
   The type is either NUMBER, IDENTIFIER or SPECIAL-CHAR.
   NonBlank is true if the token is not preceded by a blank."
  (Symbol nil)
  (Type nil)
  (NonBlank t))

(defparameter Prior-Token (make-token) "What did I see last")

(defparameter nonblank t "Is there no blank in front of the current token.")

(defparameter Current-Token (make-token) "Token at head of input stream.")

(defparameter Next-Token (make-token) "Next token in input stream.")

(defparameter Valid-Tokens 0 "Number of tokens in buffer (0, 1 or 2)")

(defun Token-Install (symbol type token &optional (nonblank t))
  (setf (token-symbol token) symbol)
  (setf (token-type token) type)
  (setf (token-nonblank token) nonblank)
  token)

(defun Token-Print (token)
  (format out-stream "(token (symbol ~S) (type ~S))~%"
          (Token-Symbol token) (Token-Type token)))

@
\subsection{Reduction}
<<*>>=
(defstruct (Reduction (:type list))
  "A reduction of a rule is any S-Expression the rule chooses to stack."
  (Rule nil)            ; Name of rule
  (Value nil))

@
\section{Recursive descent parsing support routines}
<<*>>=
@
\subsection{Stacking and retrieving reductions of rules.}
<<*>>=
(defparameter Reduce-Stack (make-stack) "Stack of results of reduced productions.")

(defun reduce-stack-show ()
 (let ((store (stack-store reduce-stack)) (*print-pretty* t))
  (if store
   (progn
    (format t "~%Reduction stack contains:~%")
    (mapcar #'(lambda (x) 
               (if (eq (type-of x) 'token)
                 (describe x)
                 (print x)))
            (stack-store reduce-stack)))
   (format t "~%There is nothing on the reduction stack.~%"))))

(defmacro reduce-stack-clear () `(stack-load nil reduce-stack))

(defun Pop-Reduction () (stack-pop Reduce-Stack))

(defmacro pop-stack-1 () '(reduction-value (Pop-Reduction)))

(defmacro pop-stack-2 ()
  `(let* ((top (Pop-Reduction)) (next (Pop-Reduction)))
     (stack-push top Reduce-Stack)
     (reduction-value next)))

(defmacro pop-stack-3 ()
  `(let* ((top (Pop-Reduction)) (next (Pop-Reduction)) (nnext (Pop-Reduction)))
     (stack-push next Reduce-Stack)
     (stack-push top Reduce-Stack)
     (reduction-value nnext)))

(defmacro pop-stack-4 ()
  `(let* ((top (Pop-Reduction))
          (next (Pop-Reduction))
          (nnext (Pop-Reduction))
          (nnnext (Pop-Reduction)))
     (stack-push nnext Reduce-Stack)
     (stack-push next Reduce-Stack)
     (stack-push top Reduce-Stack)
     (reduction-value nnnext)))

(defmacro nth-stack (x)
  `(reduction-value (nth (1- ,x) (stack-store Reduce-Stack))))

@

<<*>>=
(defmacro sequence (subrules &optional (actions nil))
  `(and ,(pop subrules) .
        ,(append (mapcar #'(lambda (x) (list 'must x)) subrules)
                   (if actions `((progn . ,(append actions '(t))))))))

@
\section{Routines for handling lexical scanning}
Lexical scanning of tokens is performed off of the current line.  No
token can span more than 1 line.  All real I/O is handled in a line-oriented
fashion (in a slight paradox) below the character level.  All character
routines implicitly assume the parameter Current-Line.  We do not make
Current-Line an explicit optional parameter for reasons of efficiency.
<<*>>=
(defparameter Current-Line (make-line)  "Current input line.")

@
\subsection{Manipulating the token stack and reading tokens}
This section is broken up into 3 levels:
\begin{itemize}
\item String grabbing:    Match String, Match Advance String
\item Token handling:     Current Token, Next Token, Advance Token
\item Character handling: Current Char, Next Char, Advance Char
\item Line handling:      Next Line, Print Next Line
\item Random Stuff
\end{itemize}
\subsubsection{String grabbing}
<<*>>=
@
\subsubsection{Token handling}
Tokens are acquired from a stream of characters.  Lexical analysis is performed
by the functiond Get Token. One-token lookahead is maintained in variables
Current-Token and Next-Token by procedures Current Token, Next Token, and
Advance Token. The functions Match Current Token and Match Next Token recognize
classes of tokens, by type, or by type and symbol.  The current and next tokens
can be shoved back on the input stream (to the current line) with Unget-Tokens.
<<*>>=
(defmacro Defun-Parse-Token (token)
 `(defun ,(intern (concatenate 'string "PARSE-" (string token))) ()
   (let* ((tok (match-current-token ',token))
          (symbol (if tok (token-symbol tok))))
    (when tok 
     (Push-Reduction ',(intern (concatenate 'string (string token) "-TOKEN"))
                      (copy-tree symbol))
     (advance-token)
     t))))

(defun token-stack-show ()
  (if (= Valid-Tokens 0) 
   (format t "~%There are no valid tokens.~%")
   (format t "~%The number of valid tokens is ~S.~%" Valid-Tokens))
  (when (> Valid-Tokens 0)
   (format t "The current token is~%")
   (describe current-token))
  (when (> Valid-Tokens 1)
   (format t "The next token is~%")
   (describe next-token))
  (when (token-type prior-token)
   (format t "The prior token was~%")
   (describe prior-token)))

(defmacro token-stack-clear ()
 `(progn 
   (setq valid-tokens 0)
   (token-install nil nil current-token nil)
   (token-install nil nil next-token nil)
   (token-install nil nil prior-token nil)))

@
\subsubsection{Character handling}
<<*>>=
(defun Advance-Char ()
  "Advances IN-STREAM, invoking Next Line if necessary."
 (loop
  (cond
   ((not (Line-At-End-P Current-Line))
    (return (Line-Advance-Char Current-Line)))
   ((next-line in-stream) 
    (return (current-char)))
   ((return nil)))))

@
\subsubsection{Line handling}
<<*>>=

(defparameter Printer-Line-Stack (make-stack)
  "Stack of output listing lines waiting to print. [local to PRINT-NEW-LINE]")

(defparameter Read-Quietly nil
  "Whether or not to produce an output listing. [local to PRINT-NEW-LINE]")

(defun Print-New-Line (string &optional (strm *terminal-io*))
  "Makes output listings."
 (if Read-Quietly 
  (stack-push (copy-tree string) Printer-Line-Stack)
  (progn
   (mapc #'(lambda (x) (format strm "; ~A~%" x) (terpri))
         (nreverse (stack-store Printer-Line-Stack)))
   (stack-clear Printer-Line-Stack)
   (format strm "~&; ~A~%" string))))

@

\subsection{Error handling}
<<*>>=
(defparameter errcol nil)

(defparameter line nil)

(defparameter count nil)

(defun conversation (x y)
 (prog (u)
a
  (reduce-stack-clear)
  (setq u (namederrset 'spad_reader (conversation1 x y)))
  (cond
   (*eof* (return nil))
   ((atom u) (go a))
   ((return (car u))))))

(defparameter ulcasefg nil)

(defun conversation1 (firstfun procfun)
 (prog nil
top
  (cond
   ((not (Current-Char)) (return nil))
   ((and (current-token) (next-token)) (go top))
   ((compfin) (return 't))
   ((and (funcall firstfun) (or (funcall procfun (pop-stack-1)))) (go top))
   ((compfin) (return 't)) )
  (meta-syntax-error)
  (go top)))

(defun termchr ()
  "Is CHR a terminating character?"
  (position (current-char) " *,;<>()[]/\\"))

(defun compfin ()
 (or (match-string ")fin") (match-string ".FIN")))

(defparameter Meta_Errors_Occurred nil  "Did any errors occur")

@
\subsection{Constructing parsing procedures}
<<*>>=
; (MAKEPROP 'PROGN 'NARY T)       ; Setting for Make-Parse-Function
(eval-when (eval load)
 (setf (get 'progn 'nary) t))

(defun make-parse-function (l op)
 (when (flagp op 'nary) (setq l (make-parse-func-flatten-1 l op nil)))
 (make-parse-function1 l op))

(defun make-parse-func-flatten (x op)
 (cond
  ((atom x) 
   x)
  ((eq (car x) op)
   (cons op (make-parse-func-flatten-1 (cdr x) op nil)))
  (t
   (cons 
    (make-parse-func-flatten (car x) op)
    (make-parse-func-flatten (cdr x) op)))))

(defun make-parse-func-flatten-1 (l op r)
 (let (x)
  (if (null l)
   r
   (make-parse-func-flatten-1
     (cdr l) op
     (append r 
      (if (eqcar (setq x (make-parse-func-flatten (car l) op)) op)
       (cdr x)
       (list x)))))))

(defun make-parse-function1 (l op)
 (let (x)
  (case op
   (plus
    (cond
     ((eq 0 (setq x (length (setq l (s- l '(0 (zero))))))) 0)
     ((eq 1 x) (car l))
     (t `(+ . ,l))))
   (times
    (cond
     ((s* l '(0 (zero))) 0)
     ((eq 0 (setq x (length (setq l (s- l '(1 (one))))))) 1)
     ((eq 1 x) (car l))
     (t `(times . ,l)) ))
   (quotient
    (cond
     ((> (length l) 2) (fail))
     ((eq 0 (car l)) 0)
     ((eq (cadr l) 1) (car l))
     (t `(quotient . ,l)) ))
   (minus
    (cond
     ((cdr l) (fail))
     ((numberp (setq x (car l))) (minus x))
     ((eqcar x 'minus) (cadr x))
     (t `(minus . ,l))  ))
   (-
    (cond
     ((> (length l) 2) (fail))
     ((equal (car l) (cadr l)) '(zero))
     ((member (car l) '(0 (zero))) (make-parse-function (cdr l) 'minus))
     ((member (cadr l) '(0 (zero))) (car l))
     ((eqcar (cadr l) 'minus)
       (make-parse-function (list (car l) (cadadr l)) 'plus))
     (t `(- . ,l)) ))
   (expt
    (cond
     ((> (length l) 2) (fail))
     ((eq 0 (cadr l)) 1)
     ((eq 1 (cadr l)) (car l))
     ((member (car l) '(0 1 (zero) (one))) (car l))
     (t `(expt . ,l)) ))
   (or
    (cond
     ((member 't l) ''t)
     ((eq 0 (setq x (length (setq l (delete nil l))))) nil)
     ((eq 1 x) (car l))
     (t `(or . ,l)) ))
   (|or|
    (cond
     ((member 't l) 't)
     ((eq 0 (setq x (length (setq l (delete nil l))))) nil)
     ((eq 1 x) (car l))
     (t `(|or| . ,l)) ))
   (null
    (cond
     ((cdr l) (fail))
     ((eqcar (car l) 'null) (cadar l))
     ((eq (car l) 't) nil)
     ((null (car l)) ''t)
     (t `(null . ,l))))
   (|and|
    (cond
     ((eq 0 (setq x (length (setq l (delete 't (delete 'true l)))))) 't)
     ((eq 1 x) (car l))
     (t `(|and| . ,l)) ))
   (and
    (cond
     ((eq 0 (setq x (length (setq l (delete 't (delete 'true l)))))) ''t)
     ((eq 1 x) (car l))
     (t `(and . ,l)) ))
   (progn
    (cond
     ((and (not (atom l)) (null (last l)))
       (cond
        ((cdr l) `(progn . ,l))
        (t (car l))))
     ((null (setq l (delete nil l))) nil)
     ((cdr l) `(progn . ,l))
     (t (car l)) ))
   (seq
    (cond
     ((eqcar (car l) 'exit) (cadar l))
     ((cdr l) `(seq . ,l))
     (t (car l))   ))
   (list
    (cond 
     ((null l) nil)
     (t `(list . ,l))))
   (cons
    (cond
     ((cdr l) `(cons . ,l))
     (t (car l)) ))
   (t
    (cons op l) ))))

(defparameter /genvarlst nil "??")

(defparameter /gensymlist nil
   "List of rule local variables generated by getgensym.")

(defun getgensym (n)
  "Used to create unique numerically indexed local variables for the use 
   of rules."
 (loop
  (let ((m (length /gensymlist)))
   (if (< m n)
    (setq /gensymlist
     (nconc /gensymlist `(,(intern (format nil "G~D" (1+ m))))))
    (return (nth (1- n) /gensymlist))))))

@
\subsection{Managing rule sets}
<<*>>=
(defparameter bac nil)

(defparameter keyfn nil)

(defparameter /metaoption "")

(defparameter tline nil)

(defparameter rs nil)

(defun getrulefunlists  (rootfun rs)
 (let* ((metapfx (or (get rootfun 'metapfx) ""))
        (mainfun (internl metapfx (pname rootfun)))
        (mainfunstr (pname mainfun))
        (flnam (internl mainfunstr "FUN"))
        (pfx-funlist
         (union
          (cons mainfun (if (atom (eval flnam)) nil (eval flnam)))
          (mapcar #'(lambda (x) (internl metapfx (pname x)))
                  (assocleft rs))))
         n unpfx-funlist)
  (set flnam pfx-funlist)
  (if (not (lessp (setq n (length metapfx)) 0))
   (setq unpfx-funlist
    (mapcar #'(lambda (x) (intern (subseq (copy-symbol (pname x)) n)))
            pfx-funlist)))
  (if unpfx-funlist (list pfx-funlist unpfx-funlist))))

@
\section{Tracing routines}
<<*>>=
(defparameter debugmode 'yes "Can be either YES or NO")

(defun reduction-print (y rule)
 (format t "~&")
 (cond
  ((eq y t) (|sayBrightly| `(|%b| ,rule |%d| " reduced")))
  (y (|sayBrightlyNT| `(|%b| ,rule |%d|)) (format t " reduced ~A~%" y)))
 y)

(defparameter /depth 0 "Used in Debug.lisp.")

(defun /embed-1 (x y)
 (princ (strconc (pname x) " embedded"))
 (terpri)
 (/embed-q x y))

(defun /embed-q (x y)
 (setq /embednames (cons x /embednames))
 (embed x
  (cond
   ((eqcar y 'lambda) y)
   ((eqcar y 'before)
     `(lambda ,(cadr y)
       (prog2 ,(caddr y) ,(cons 'funcall (cons x (cadr y))))))
   ((eqcar y 'after)
     `(lambda ,(cadr y)
       (prog1 ,(cons 'funcall (cons x (cadr y))) ,(caddr y))))))
 (/embedreply))

(defun /embedreply ()
  (if (atom (embedded))
   '(|none| |embedded|)
   (append (embedded) (list '|embedded|))))

(defun numofargs (fn) (numberofargs (car (/mdef (cons fn '(x))))))

(defparameter mdeftrace nil)

(defun /mdef (x)
 (let (u)
  (cond
   ((atom x) x)
   ((or (null (atom (car x))) (not (mbpip (car x)))) (mapcar #'/mdef x))
   ((equal x (setq u (mdef (car x) x))) x)
   (mdeftrace (print x) (princ " --> ") (print u) (/mdef u))
   ((/mdef u)))))

(defun trargprint (l) (mapc #'(lambda (x) (princ " / ") (prin1 x)) l))

(defun trblanks (n) (do ((i 1 (1+ i))) ((> i n)) (princ " ")))

@
\section{Routines for inspecting and resetting total I/O system state}
The package largely assumes that:
\begin{itemize}
\item One I/O stream pair is in effect at any moment.
\item There is a Current Line
\item There is a Current Token and a Next Token
\item There is a Reduction Stack
\end{itemize}
This state may be examined and reset with the procedures IOSTAT and IOCLEAR.

<<*>>=
(defun IOStat ()
  "Tell me what the current state of the parsing world is."
  ;(IOStreams-show)
  (if (line-past-end-p Current-Line)
    (format t "~&The current line is empty.~%")
    (progn
     (format t "~&The current line is:~%~%")
     (Line-Print Current-Line)))
  (if (or $BOOT $SPAD) (next-lines-show))
  (token-stack-show)
  ;(reduce-stack-show)
  nil)

(defun IOClear (&optional (in t) (out t))
  ;(IOStreams-clear in out)
  (setq Current-Fragment nil)
  (Line-Clear Current-Line)
  (token-stack-clear)
  (reduce-stack-clear)
  (if (or $BOOT $SPAD) (next-lines-clear))
  nil)

@

<<*>>=

;; auxiliary functions needed by the parser

@
bootlex
<<*>>=

(defun Next-Lines-Show ()
  (and Boot-Line-Stack (format t "Currently preparsed lines are:~%~%"))
  (mapcar #'(lambda (line)
              (format t "~&~5D> ~A~%" (car line) (cdr Line)))
          Boot-Line-Stack))

; *** 1. BOOT file handling

(defmacro test (x &rest y)
  `(progn
     (setq spaderrorstream t)
     (in-boot)
     (initialize-preparse *terminal-io*)
     (,(intern (strconc "PARSE-" x)) . ,y)))

(defun |oldParserAutoloadOnceTrigger| () nil)

(defun print-defun (name body)
   (let* ((sp (assoc 'vmlisp::compiler-output-stream vmlisp::optionlist))
          (st (if sp (cdr sp) *standard-output*)))
     (if (and (is-console st) (symbolp name) (fboundp name)
              (not (compiled-function-p (symbol-function name))))
         (compile name))
     (when (or |$PrettyPrint| (not (is-console st)))
           (print-full body st) (force-output st))))

(defun boot-parse-1 (in-stream
              &aux
             (Echo-Meta nil)
             (current-fragment nil)
             ($INDEX 0)
             ($LineList nil)
             ($EchoLineStack nil)
             ($preparse-last-line nil)
             ($BOOT T)
             (*EOF* NIL)
             (OPTIONLIST NIL))
  (declare (special echo-meta *comp370-apply* *EOF* File-Closed
                    $index $linelist $echolinestack $preparse-last-line))
  (init-boot/spad-reader)
  (let* ((Boot-Line-Stack (PREPARSE in-stream))
         (parseout (prog2 (|PARSE-Expression|) (pop-stack-1)) ) )
    ;(setq parseout (|new2OldLisp| parseout))
    ; (setq parseout (DEF-RENAME parseout))
    ; (DEF-PROCESS parseout)
    parseout))

;; note that this is no longer called or used. Boot has been removed.
(defun boot (&optional
              (*boot-input-file* nil)
              (*boot-output-file* nil)
             &aux
             (Echo-Meta t)
             ($BOOT T)
             (|$InteractiveMode| NIL)
             (File-Closed NIL)
             (*EOF* NIL)
             (OPTIONLIST NIL)
             (*fileactq-apply* (function print-defun))
             (*comp370-apply* (function print-defun)))
  (declare (special echo-meta *comp370-apply* *EOF* File-Closed))
  (init-boot/spad-reader)
  (with-open-stream
    (in-stream (if *boot-input-file* (open *boot-input-file* :direction :input)
                    *standard-input*))
    (initialize-preparse in-stream)
    (with-open-stream
      (out-stream (if *boot-output-file*
                      (open *boot-output-file* :direction :output)
                      #-:cmulisp (make-broadcast-stream *standard-output*)
                      #+:cmulisp *standard-output*
                      ))
      (when *boot-output-file*
         (format out-stream "~&;;; -*- Mode:Lisp; Package:Boot  -*-~%~%")
         (print-package "BOOT"))
      (loop (if (and (not File-Closed)
                     (setq Boot-Line-Stack (PREPARSE in-stream)))
                (progn
                       (|PARSE-Expression|)
                       (let ((parseout (pop-stack-1)) )
                         (setq parseout (|new2OldLisp| parseout))
                         (setq parseout (DEF-RENAME parseout))
                         (let ((*standard-output* out-stream))
                           (DEF-PROCESS parseout))
                         (format out-stream "~&")
                         (if (null parseout) (ioclear)) ))
                (return nil)))
      (if *boot-input-file*
          (format out-stream ";;;Boot translation finished for ~a~%"
                  (namestring *boot-input-file*)))
      (IOClear in-stream out-stream)))
  T)

;  *** 2. BOOT Line Handling ***

; See the file PREPARSE.LISP for the hard parts of BOOT line processing.

(defun next-BOOT-line (&optional (in-stream t))

  "Get next line, trimming trailing blanks and trailing comments.
One trailing blank is added to a non-blank line to ease between-line
processing for Next Token (i.e., blank takes place of return).        Returns T
if it gets a non-blank line, and NIL at end of stream."

  (if Boot-Line-Stack
      (let ((Line-Number (caar Boot-Line-Stack))
            (Line-Buffer (suffix #\Space (cdar Boot-Line-Stack))))
        (pop Boot-Line-Stack)
        (Line-New-Line Line-Buffer Current-Line Line-Number)
        (setq |$currentLine| (setq LINE Line-Buffer))
        Line-Buffer)))

;  *** 3. BOOT Token Handling ***

(defun get-BOOT-token (token)

  "If you have an _, go to the next line.
If you have a . followed by an integer, get a floating point number.
Otherwise, get a .. identifier."

  (if (not (boot-skip-blanks))
      nil
      (let ((token-type (boot-token-lookahead-type (current-char))))
        (case token-type
          (eof                        (token-install nil '*eof token nonblank))
          (escape                (advance-char)
                                (get-boot-identifier-token token t))
          (argument-designator        (get-argument-designator-token token))
          (id                        (get-boot-identifier-token token))
          (num                        (get-number-token token))
          (string                (get-SPADSTRING-token token))
          (special-char                (get-special-token token))
          (t                        (get-gliph-token token token-type))))))

(defun boot-skip-blanks ()
  (setq nonblank t)
  (loop (let ((cc (current-char)))
          (if (not cc) (return nil))
          (if (eq (boot-token-lookahead-type cc) 'white)
              (progn (setq nonblank nil) (if (not (advance-char)) (return nil)))
              (return t)))))

(defun boot-token-lookahead-type (char)
  "Predicts the kind of token to follow, based on the given initial character."
  (cond ((not char)                                           'eof)
        ((char= char #\_)                                   'escape)
        ((and (char= char #\#) (digitp (next-char)))           'argument-designator)
        ((digitp char)                                           'num)
        ((and (char= char #\$) $boot
              (alpha-char-p (next-char)))                   'id)
        ((or (char= char #\%) (char= char #\?)
             (char= char #\!) (alpha-char-p char))           'id)
        ((char= char #\")                                  'string)
        ((member char
                 '(#\Space #\Tab #\Return)
                 :test #'char=)                                   'white)
        ((get (intern (string char)) 'Gliph))
        (t                                                   'special-char)))

(defun get-argument-designator-token (token)
  (advance-char)
  (get-number-token token)
  (token-install (intern (strconc "#" (format nil "~D" (token-symbol token))))
                 'argument-designator token nonblank))

(defvar Keywords '(|or| |and| |isnt| |is| |otherwise| |when| |where|
                  |has| |with| |add| |case| |in| |by| |pretend| |mod|
                  |exquo| |div| |quo| |else| |rem| |then| |suchthat|
                  |if| |yield| |iterate| |from| |exit| |leave| |return|
                  |not| |unless| |repeat| |until| |while| |for| |import|)



"Alphabetic literal strings occurring in the New Meta code constitute
keywords.   These are recognized specifically by the AnyId production,
GET-BOOT-IDENTIFIER will recognize keywords but flag them
as keywords.")

(defun get-boot-identifier-token (token &optional (escaped? nil))
  "An identifier consists of an escape followed by any character, a %, ?,
or an alphabetic, followed by any number of escaped characters, digits,
or the chracters ?, !, ' or %"
  (prog ((buf (make-adjustable-string 0))
         (default-package NIL))
      (suffix (current-char) buf)
      (advance-char)
   id (let ((cur-char (current-char)))
         (cond ((char= cur-char #\_)
                (if (not (advance-char)) (go bye))
                (suffix (current-char) buf)
                (setq escaped? t)
                (if (not (advance-char)) (go bye))
                (go id))
               ((and (null default-package)
                     (char= cur-char #\'))
                (setq default-package buf)
                (setq buf (make-adjustable-string 0))
                (if (not (advance-char)) (go bye))
                (go id))
               ((or (alpha-char-p cur-char)
                    (digitp cur-char)
                    (member cur-char '(#\% #\' #\? #\!) :test #'char=))
                (suffix (current-char) buf)
                (if (not (advance-char)) (go bye))
                (go id))))
  bye (if (and (stringp default-package)
               (or (not (find-package default-package))         ;; not a package name
                   (every #'(lambda (x) (eql x #\')) buf))) ;;token ends with ''
          (setq buf (concatenate 'string default-package "'" buf)
                default-package nil))
      (setq buf (intern buf (or default-package "BOOT")))
      (return (token-install
                buf
                (if (and (not escaped?)
                         (member buf Keywords :test #'eq))
                    'keyword 'identifier)
                token
                nonblank))))

(defun get-gliph-token (token gliph-list)
  (prog ((buf (make-adjustable-string 0)))
        (suffix (current-char) buf)
        (advance-char)
   loop (setq gliph-list (assoc (intern (string (current-char))) gliph-list))
        (if gliph-list
            (progn (suffix (current-char) buf)
                   (pop gliph-list)
                   (advance-char)
                   (go loop))
            (let ((new-token (intern buf)))
              (return (token-install (or (get new-token 'renametok) new-token)
                                     'gliph token nonblank))))))

(defun get-SPADSTRING-token (token)
   "With TOK=\" and ABC\" on IN-STREAM, extracts and stacks string ABC"
  (PROG ((BUF (make-adjustable-string 0)))
        (if (char/= (current-char) #\") (RETURN NIL) (advance-char))
        (loop
         (if (char= (current-char) #\") (return nil))
         (SUFFIX (if (char= (current-char) #\_)
                     (advance-char)
                   (current-char))
                 BUF)
         (if (null  (advance-char)) ;;end of line
             (PROGN (|sayBrightly| "Close quote inserted") (RETURN nil)))
         )
        (advance-char)
        (return (token-install (copy-seq buf) ;should make a simple string
                               'spadstring token))))

; **** 4. BOOT token parsing actions

; Parsing of operator tokens depends on tables initialized by BOTTOMUP.LISP

(defmacro defun-parse-token (token)
  `(defun ,(intern (concatenate 'string "PARSE-" (string token))) ()
     (let* ((tok (match-current-token ',token))
            (symbol (if tok (token-symbol tok))))
       (if tok (progn (push-reduction
                        ',(intern (concatenate 'string (string token)
                                               "-TOKEN"))
                        (copy-tree symbol))
                      (advance-token)
                      t)))))

(defun-parse-token SPADSTRING)
(defun-parse-token KEYWORD)
(defun-parse-token ARGUMENT-DESIGNATOR)

(defun TRANSLABEL (X AL) (TRANSLABEL1 X AL) X)

(defun TRANSLABEL1 (X AL)
 "Transforms X according to AL = ((<label> . Sexpr) ..)."
  (COND ((REFVECP X)
         (do ((i 0 (1+ i))
              (k (maxindex x)))
             ((> i k))
           (if (LET ((Y (LASSOC (ELT X I) AL))) (SETELT X I Y))
               (TRANSLABEL1 (ELT X I) AL))))
        ((ATOM X) NIL)
        ((LET ((Y (LASSOC (FIRST X) AL)))
           (if Y (setf (FIRST X) Y) (TRANSLABEL1 (CDR X) AL))))
        ((TRANSLABEL1 (FIRST X) AL) (TRANSLABEL1 (CDR X) AL))))

; **** 5. BOOT Error Handling

(defun SPAD-SYNTAX-ERROR (&rest byebye)
  "Print syntax error indication, underline character, scrub line."
  (BUMPERRORCOUNT '|syntax|)
  (COND ((AND (EQ DEBUGMODE 'YES) (NOT(CONSOLEINPUTP IN-STREAM)))
         (SPAD_LONG_ERROR))
        ((SPAD_SHORT_ERROR)))
  (IOClear)
  (throw 'spad_reader nil))

(defun SPAD_LONG_ERROR ()
  (SPAD_ERROR_LOC SPADERRORSTREAM)
  (iostat)
  (unless (EQUAL OUT-STREAM SPADERRORSTREAM)
    (SPAD_ERROR_LOC OUT-STREAM)
    (TERPRI OUT-STREAM)))

(defun SPAD_SHORT_ERROR ()
 (if (line-past-end-p Current-Line)
    (format t "~&The current line is empty.~%")
    (progn
     (format t "~&The current line is:~%~%")
     (Line-Print Current-Line))))

(defun SPAD_ERROR_LOC (STR)
  (format str "******** Boot Syntax Error detected ********"))

(defun BUMPERRORCOUNT (KIND)
  (unless |$InteractiveMode|
          (LET ((INDEX (case KIND
                         (|syntax| 0)
                         (|precompilation| 1)
                         (|semantic| 2)
                         (T (ERROR "BUMPERRORCOUNT")))))
            (SETELT $SPAD_ERRORS INDEX (1+ (ELT $SPAD_ERRORS INDEX))))))


@
<<*>>=

; NAME:     Def
; PURPOSE:  Defines BOOT code


;;; Common Block

(defparameter deftran nil)
(defparameter $macroassoc nil)
(defparameter $ne nil)

(defparameter $op nil
"$OP is globalized for construction of local function names, e.g.
foo defined inside of fum gets renamed as fum,foo.")

(defparameter $opassoc nil
"$OPASSOC is a renaming accumulator to be used with SUBLIS.")

(defparameter $BODY nil)

; We are making shallow binding cells for these functions as well

(mapcar #'(lambda (x) (MAKEPROP (FIRST X) 'DEF-TRAN (SECOND X)))
         '((\: DEF-\:) (\:\: DEF-\:\:) (ELT DEF-ELT)
           (SETELT DEF-SETELT) (SPADLET DEF-LET)
           (SEQ DEF-SEQ) (COLLECT DEF-COLLECT)
           (REPEAT DEF-REPEAT) (TRACE-LET DEF-TRACE-LET)
           (CATEGORY DEF-CATEGORY) (EQUAL DEF-EQUAL)
           (|is| DEF-IS) (|isnt| DEF-ISNT) (|where| DEF-WHERE)))

(defun DEF-EQUAL (X)
  (COND ((NOT (CDR X)) (CONS 'EQUAL X))
        ((OR (MEMBER '(|One|) X) (MEMBER '(|Zero|) X)
             (integerp (FIRST X)) (integerp (SECOND X))) (CONS 'EQL X))
       ; ((AND (EQCAR (FIRST X) 'QUOTE) (IDENTP (CADAR X))) (CONS 'EQ X))
        ((NOT (FIRST X)) (LIST 'NULL (SECOND X)))
        ((NOT (SECOND X)) (LIST 'NULL (FIRST X)))
       ; ((AND (EQCAR (SECOND X) 'QUOTE) (IDENTP (CADADR X))) (CONS 'EQ X))
        ($BOOT (CONS 'BOOT-EQUAL X))
        ((CONS 'EQUAL X))))
 
(defun DEF-LESSP (x)
  (cond ((null (cdr x)) (cons '< x))
        ((eq (cadr x) 0) (list 'minusp (car x)))
        ((and (smint-able (car x)) (smint-able (cadr x)))
         (cons 'qslessp x))
        ('t (list '> (CADR x) (CAR x)))))

(defun smint-able (x)
  (or (typep x 'fixnum)
      (and (pairp x) (member (car x)
                       '(|One| |Zero| LENGTH \# QCSIZE QVSIZE QLENGTH)))))

(defun B-MDEF (FORM SIGNATURE $BODY)
  (declare (ignore SIGNATURE))
 (let* ($OpAssoc
        ($op (first form)) (argl (cdr form))
        (GARGL (MAPCAR '(LAMBDA (X) (GENSYM)) ARGL))
        ($BODY (SUBLISLIS GARGL ARGL (|bootTransform| (DEFTRAN $BODY))))
        ($BODY (LIST 'SUBLISLIS (CONS 'LIST GARGL) (LIST 'QUOTE GARGL)
                     (LIST 'QUOTE $BODY))))
   (COMP (SUBLIS $OPASSOC
                 (LIST (LIST $OP (LIST 'MLAMBDA (CONS () GARGL) $BODY)))))))

(defun MKPROGN (L) (MKPF L 'PROGN))

(mapcar #'(lambda (x) (MAKEPROP (CAR X) 'RENAME (CDR X)))
        '((|true| 'T) (|otherwise| 'T) (|false| NIL)
          (|and| AND) (|or| OR) (|is| IS)
          (|list| LIST) (|cons| CONS) (|car| CAR) (|cdr| CDR)
          (|setDifference| SETDIFFERENCE) (INTERSECTION |intersection|)
          (|setIntersection| |intersection|) (|setUnion| |union|)
          (UNION |union|) (REMOVE |remove|) (MEMBER |member|) (ASSOC |assoc|)
          (READ VMREAD) (READ-LINE |read-line|)
          (|apply| APPLY) (|lastNode| LASTPAIR) (LAST |last|)
          (|in| |member|) (|strconc| STRCONC) (|append| APPEND)
          (|copy| COPY) (DELETE |delete|) (RASSOC |rassoc|)
          (|size| SIZE) (|nconc| NCONC)
          (|setPart| SETELT) (|where| WHERE)
          (|first| CAR) (|rest| CDR) (|substitute| MSUBST)
          (|removeDuplicates| REMDUP) (|reverse| REVERSE) (|nreverse| NREVERSE)
          (|drop| DROP) (|take| TAKE) (|croak| CROAK) (|genvar| GENVAR)
          (|mkpf| MKPF) (^= NEQUAL) (= EQUAL) (- SPADDIFFERENCE)
          (+ PLUS) (* TIMES) (/ QUOTIENT)
          (** EXPT) (|return| RETURN) (|exit| EXIT) (\| SUCHTHAT)
          (^ NULL) (|not| NULL) (NOT NULL) (REDUCE spadReduce) (DO spadDo)
          (|atom| ATOM) (|nil| NIL) (|null| NULL) (GET GETL)
          (T T$)))

(defun DEF-SEQ (U) (SEQOPT (CONS 'SEQ U)))

(defun |DEF-:| (X &aux Y)
       (DCQ (x y) x)
       `(SPADLET ,(if (or (eq y '|fluid|)
                          (and (identp x) (char= #\$ (ELT (PNAME X) 0))))
                      `(FLUID ,X) X)
                 NIL))

(defmacro |DEF-::| (X)
  (let ((expr (first x)) (type (second x)))
    (if (EQUAL TYPE '(|Triple|)) EXPR (ERRHUH))))

(defun DEF-select (L)
  (cond ((IDENTP (FIRST L)) (DEF-select1 (FIRST L) (SECOND L)))
        ((LET* ((G (GENSYM))
                (U (DEF-select1 G (SECOND L))))
           (LIST 'PROGN (LIST 'SPADLET G (FIRST L)) U)))))

(defun DEF-select1 (X Y)
  (if (EQCAR Y 'SEQ)
      (CONS 'COND (DEF-select2 X (CDR Y)))
      (MOAN (format nil "Unexpected CASE body: ~S" Y))))

(defun DEF-select2 (X Y)
  (let (u v)
    (COND ((NOT Y) (MOAN "Unexpected CASE clause termination"))
          ((EQCAR (setq U (FIRST Y)) 'EXIT)
           (LIST (LIST ''T (SECOND U))))
          ((AND (EQCAR U 'COND) (NOT (CDDR U))
                (EQCAR (SECOND (setq V (SECOND U))) 'EXIT))
           (CONS (LIST (DEF-IS (LIST X (FIRST V))) (CADADR V))
                 (DEF-select2 X (CDR Y))))
          ((MOAN (format nil "Unexpected CASE clause: ~S" (FIRST Y)))))))

(defun MK_LEFORM (U)
  (COND ((IDENTP U) (PNAME U))
        ((STRINGP U) U)
        ((ATOM U) (STRINGIMAGE U))
        ((MEMBER (FIRST U) '(VCONS CONS) :test #'eq)
         (STRCONC "(" (MK_LEFORM-CONS U) ")") )
        ((EQ (FIRST U) 'LIST) (STRCONC "(" (MK_LEFORM (SECOND U)) ")") )
        ((EQ (FIRST U) 'APPEND) (STRCONC "(" (MK_LEFORM-CONS U) ")") )
        ((EQ (FIRST U) 'QUOTE) (MK_LEFORM (SECOND U)))
        ((EQ (FIRST U) 'EQUAL) (STRCONC "=" (MK_LEFORM (SECOND U)) ))
        ((EQ (FIRST U) 'SPADLET) (MK_LEFORM (THIRD U)))
        ((ERRHUH))))

(defun MK_LEFORM-CONS (U)
  (COND ((ATOM U) (STRCONC ":" (MK_LEFORM U)))
        ((EQ (FIRST U) 'APPEND)
         (STRCONC ":" (MK_LEFORM (SECOND U)) "\," (MK_LEFORM-CONS (THIRD U)) ))
        ((EQ (THIRD U) NIL) (MK_LEFORM (SECOND U)))
        ((STRCONC (MK_LEFORM (SECOND U)) "\," (MK_LEFORM-CONS (THIRD U))))))

(defun LET_ERROR (FORM VAL)
  (|systemError| (format nil "~S is not matched by structure ~S~%" FORM VAL)))

(defun DEF-ISNT (X) (DEFTRAN (LIST 'NULL (CONS 'IS X))))

(defun IS-GENSYM ()
  (if (NOT (CDR $IS-GENSYMLIST)) (RPLACD $IS-GENSYMLIST (LIST (GENSYM))))
  (pop $IS-GENSYMLIST))

(defun LIST2CONS (X)
"Produces LISP code for constructing a list, involving only CONS."
 (LIST2CONS-1 (CDR X)))

(defun LIST2CONS-1 (X)
  (if (NOT X) NIL (LIST 'CONS (FIRST X) (LIST2CONS-1 (CDR X)))))

(defun WHDEF (X Y)
  "Returns no value -- side effect is to do a compilation or modify a global."
  (prog ((XP (if (ATOM X) (LIST X) X)) Op)
    (COND ((NOT (CDR XP))
           (RETURN (PUSH (CONS (FIRST XP) Y) $MACROASSOC))))
    (setq OP (INTERNL (PNAME $OP) "\," (FIRST XP)))
    (SETQ $OPASSOC (PUSH (CONS (FIRST XP) OP) $OPASSOC))
    (SETQ $DEFSTACK (CONS (LIST (CONS OP (CDR XP)) Y) $DEFSTACK))
    NIL))

(mapcar #'(lambda (x) (MAKEPROP (first X) 'SEL\,FUNCTION (second X)))
        '((|aTree| 0)           (|aMode| 1)
          (|aValue| 2)          (|aModeSet| 3)
          (|aGeneral| 4)        (|expr| CAR)
          (|mode| CADR)         (|env| CADDR)
          (|mmDC| CAAR)         (|cacheName| CADR)
          (|cacheType| CADDR)   (|cacheReset| CADDDR)
          (|cacheCount| CADDDDR)(|mmSignature| CDAR)
          (|mmTarget| CADAR)    (|mmCondition| CAADR)
          (|mmImplementation| CADADR)
          (|streamName| CADR)   (|streamDef| CADDR)
          (|streamCode| CADDDR) (|opSig| CADR)
          (|attributes| CADDR)  (|op| CAR)
          (|opcode| CADR)       (|sig| CDDR)
          (|source| CDR)        (|target| CAR)
          (|first| CAR)         (|rest| CDR)))

(defun DEF-ELT (args)
  (let ((EXPR (car args)) (SEL (cadr args)))
    (let (Y)
      (COND ((and (symbolp sel) (setq Y (GET SEL 'SEL\,FUNCTION)))
             (COND ((integerp Y) (LIST 'ELT EXPR Y))
                   ((LIST Y EXPR))))
            ((LIST 'ELT EXPR SEL))))))

(defun DEF-SETELT (args)
  (let ((VAR (first args)) (SEL (second args)) (EXPR (third args)))
    (let ((y (and (symbolp sel) (get sel 'sel\,function))))
      (COND (y (COND ((integerp Y) (LIST 'SETELT VAR Y EXPR))
                     ((LIST 'RPLAC (LIST Y VAR) EXPR))))
            ((LIST 'SETELT VAR SEL EXPR))))))

(defun DEF-CATEGORY (L)
  (let (siglist atlist)
    (mapcar #'(lambda (x) (if (EQCAR (KADR X) 'Signature)
                              (PUSH X SIGLIST)
                              (PUSH X ATLIST)))
            L)
    (LIST 'CATEGORY (MKQ (NREVERSE SIGLIST)) (MKQ (NREVERSE ATLIST)))))


(defun LIST2STRING (X)
"Converts a list to a string which looks like a printed list,
except that elements are separated by commas."
  (COND ((ATOM X) (STRINGIMAGE X))
        ((STRCONC "(" (LIST2STRING (FIRST X)) (LIST2STRING1 (CDR X)) ")"))))

(defun LIST2STRING1 (X)
  (COND
    ((NOT X) "")
    ((STRCONC "\," (LIST2STRING (FIRST X)) (LIST2STRING1 (CDR X))))))

(defvar |$new2OldRenameAssoc|
        '((\QUAD . \.) (\' . QUOTE) (|nil| . NIL) (|append| . APPEND)
          (|union| . UNION) (|cons| . CONS)))

(defun |new2OldLisp| (x) (|new2OldTran| (|postTransform| x)))

(defun |new2OldTran| (x)
  (PROG (G10463 a b G10465 G10466 G10467 G10469 d G10470 c)
        (RETURN
          (prog nil
                (if (atom x)
                    (RETURN (let ((y (ASSOC x |$new2OldRenameAssoc|)))
                              (if y (cdr y) x))))
                (if (AND (dcq (g10463 a b . g10465) x)
                         (null G10465)
                         (EQ G10463 '|where|)
                         (dcq (g10466 . g10467) b)
                         (dcq ((g10469 d . g10470) . c) (reverse g10467))
                         (null G10470)
                         (EQ G10469 '|exit|)
                         (EQ G10466 'SEQ)
                         (OR (setq c (NREVERSE c)) 'T))
                    (RETURN
                      `(|where| ,(|new2OldTran| a) ,@(|new2OldTran| c)
                                ,(|new2OldTran| d))))
                (return
                  (case (car x)
                      (QUOTE x)
                      (DEF (|newDef2Def| x))
                      (IF (|newIf2Cond| x))
                      (|construct| (|newConstruct| (|new2OldTran| (cdr x))))
                      (T `(,(|new2OldTran| (CAR x)) .
                           ,(|new2OldTran| (CDR x))))))))))

(defun |newDef2Def| (DEF-EXPR)
  (if (not (AND (= (length def-expr) 5) (eq (car def-expr) 'DEF)))
      (LET_ERROR "(DEF,form,a,b,c)" DEF-EXPR)
      (let ((form (second def-expr))
            (a (third def-expr))
            (b (fourth def-expr))
            (c (fifth def-expr)))
        `(DEF ,(|new2OldDefForm|  form) ,(|new2OldTran| a)
           ,(|new2OldTran| b) ,(|new2OldTran| c)))))

(defun |new2OldDefForm| (x)
  (cond ((ATOM x) (|new2OldTran| x))
        ((and (listp x)
              (listp (car x))
              (eq (caar x) '|is|)
              (= (length (car x)) 3))
         (let ((a (second (car x))) (b (third (car x))) (y (cdr x)))
              (|new2OldDefForm| `((SPADLET ,a ,b) ,@y))))
        ((CONS (|new2OldTran| (CAR x)) (|new2OldDefForm| (CDR x))))))

(defun |newIf2Cond| (COND-EXPR)
       (if (not (AND (= (length cond-expr) 4) (EQ (car cond-expr) 'IF)))
           (LET_ERROR "(IF,a,b,c)" COND-EXPR))
       (let ((a (second COND-EXPR))
             (b (third COND-EXPR))
             (c (fourth COND-EXPR)))
         (setq a (|new2OldTran| a) b (|new2OldTran| b) c (|new2OldTran| c))
         (cond ((EQ c '|noBranch|) `(if ,a ,b))
               (t  `(if ,a ,b ,c)))))

(defun |newConstruct| (l)
  (if (ATOM l) l
      `(CONS  ,(CAR l) ,(|newConstruct| (CDR l)))))
@
metalex
<<*>>=

; NAME:         MetaLex.lisp
; PURPOSE:      Parsing support routines for Meta code
; CONTENTS:
;
;               1. META File Handling
;               2. META Line Handling
;               3. META Token Handling
;               4. META Token Parsing Actions
;               5. META Error Handling
 
(in-package "BOOT")
 
; *** 2. META Line Handling
 
(defun next-META-line (&optional (in-stream t))
 
"Get next line, trimming trailing blanks and trailing comments.
One trailing blank is added to a non-blank line to ease between-line
processing for Next Token (i.e., blank takes place of return).  Returns T
if it gets a non-blank line, and NIL at end of stream."
 
  (prog (string)
empty (if File-Closed (return nil))
      (setq string (kill-trailing-blanks (kill-comments
                                          (get-a-line in-stream))))
      (if (= (length string) 0) (go empty))
      (Line-New-Line (suffix #\Space string) Current-Line)
      (if Echo-Meta (Print-New-Line (Line-Buffer Current-Line) out-stream))
      (return t)))
 
(defparameter Comment-Character #\% "Delimiter of comments in Meta code.")
 
(defun kill-comments (string)
  "Deletes from comment character % to end of STRING."
  (subseq string 0
          (let ((mi (maxindex string)))
            (do ((i 0 (1+ i)))
                ((> i mi) i)
              (if (and (char= (elt string i) Comment-Character)
                       (or (eq i 0) (char/= (elt string (1- i)) #\\)))
                  (return i))))))
 
(defun kill-trailing-blanks (string)
 
  "Remove white space from end of STRING."
 
  ; Coding note: yes, I know, use string-trim --  but it is broken
  ; in Symbolics Common Lisp for short strings
 
  (let* ((sl (length string))
         (right (if (= sl 0) -1
                    (or
                      (position-if-not
                        #'(lambda (x)
                            (member x '(#\Space #\Tab #\Newline) :test #'char=))
                        string :from-end t)
                      -1))))
    (if (>= right 0) (subseq string 0 (1+ right)) (make-string 0))))
 
; *** 3. META Token Handling
 
; STRING: "'"  { Chars - "'" }* "'"
; BSTRING: "[" ... "]*"
; ID: letters, _ and then numbers
; NUMBER: digits, ., digits, e, +-, digits
 
(defun-parse-token STRING)
(defun-parse-token BSTRING)
(defun-parse-token IDENTIFIER)
(defun-parse-token NUMBER)
 
; Meta tokens fall into the following categories:
;
;               Number
;               Identifier
;               Dollar-sign
;               Special character
;
; Special characters are represented as characters, numbers as numbers, and
; identifiers as strings.  The reason identifiers are represented as strings is
; that the full print-name of the intern of a string depends on the package you
; are currently executing in; this can lead to very confusing results!
 
(defun get-META-token (token)
  (prog nil
   loop (if (not (skip-blanks)) (return nil))
        (case (token-lookahead-type (current-char))
          (id           (return (get-identifier-token token)))
          (num          (return (get-number-token token)))
          (string       (return (get-string-token token)))
          (bstring      (return (get-bstring-token token)))
;         (dollar       (return (get-identifier-token token)))
          (special-char (return (get-special-token token)))
          (eof          (return nil)))))
 
(defun skip-blanks ()
  (loop (let ((cc (current-char)))
          (if (not cc) (return nil))
          (if (eq (token-lookahead-type cc) 'white)
              (if (not (advance-char)) (return nil))
              (return t)))))
 
(defparameter Escape-Character #\\ "Superquoting character.")
 
(defun token-lookahead-type (char)
  "Predicts the kind of token to follow, based on the given initial character."
  (cond ((not char)                                             'eof)
        ((or (char= char Escape-Character) (alpha-char-p char)) 'id)
        ((digitp char)                                          'num)
        ((char= char #\')                                       'string)
        ((char= char #\[)                                       'bstring)
;       ((char= char #\$) (advance-char)                        'dollar)
        ((member char '(#\Space #\Tab #\Return) :test #'char=)  'white)
        (t                                                      'special-char)))
 
(defun make-adjustable-string (n)
  (make-array (list n) :element-type 'string-char :adjustable t))

(defun get-identifier-token (token)
  "Take an identifier off the input stream."
  (prog ((buf (make-adjustable-string 0)))
   id (let ((cur-char (current-char)))
         (cond ((equal cur-char Escape-Character)
                (if (not (advance-char)) (go bye))
                (suffix (current-char) buf)
                (if (not (advance-char)) (go bye))
                (go id))
               ((or (alpha-char-p cur-char)
                    (char= cur-char #\-)
                    (digitp cur-char)
                    (char= cur-char #\_))
                (suffix (current-char) buf)
                (if (not (advance-char)) (go bye))
                (go id))))
  bye (return (token-install (intern buf) 'identifier token))))
 
(defun get-string-token (token)
  "With 'ABC' on IN-STREAM, extracts and stacks String 'ABC'."
  (let ((buf (make-adjustable-string 0)))
    (if (char= (current-char) #\')
        (progn (advance-char)
               (loop (case (current-char)
                       (#\' (advance-char)
                        (return (token-install buf 'string token)))
                       (#\\ (advance-char)
                        (suffix (current-char) buf)
                        (advance-char))
                       (#\Return
                        (moan "String should fit on one line!")
                        (advance-char)
                        (meta-syntax-error)
                        (return nil))
                       (t (suffix (current-char) buf)
                          (advance-char))))))))
 
(defun get-bstring-token (token)
  "With ABC]* on in-stream, extracts and stacks string ABC."
  (let ((buf (make-adjustable-string 0)))
    (if (char= (current-char) #\[)
        (progn (advance-char)
               (loop (case (current-char)
                       (#\] (if (char= (next-char) #\*)
                                (progn (advance-char)
                                       (advance-char)
                                       (return (token-install buf 'bstring token)))
                                (progn (suffix (current-char) buf)
                                       (advance-char))))
                       (#\\ (advance-char)
                        (suffix (current-char) buf)
                        (advance-char))
                       (#\Return
                        (moan "String should fit on one line!")
                        (advance-char)
                        (meta-syntax-error)
                        (return nil))
                       (t (suffix (current-char) buf)
                          (advance-char))))))))
 
(defun get-special-token (token)
  "Take a special character off the input stream.  We let the type name of each
special character be the atom whose print name is the character itself."
  (let ((symbol (current-char)))
    (advance-char)
    (token-install symbol 'special-char token)))
 
(defun get-number-token (token)
  "Take a number off the input stream."
  (prog ((buf (make-adjustable-string 0)))
    nu1 (suffix (current-char) buf)                     ; Integer part
        (let ((next-chr (next-char)))
          (cond ((digitp next-chr)
                 (advance-char)
                 (go nu1))))
        (advance-char) 
 formint(return (token-install
                 (read-from-string buf)
                  'number token
                  (size buf) ;used to keep track of digit count
                  ))))
 
; *** 4. META Auxiliary Parsing Actions
 
(defun make-defun (nametok vars body)
  (let ((name (INTERN (STRCONC |META_PREFIX| nametok))))
    (if vars
        `(DEFUN ,name ,vars (declare (special . ,vars)) ,body)
        `(DEFUN ,name ,vars ,body))))
 
(defun print-fluids (fluids)
  (terpri out-stream)
  (mapcar #'(lambda (x) (format out-stream "~&(DEFPARAMETER ~S NIL)~%" x)) fluids)
  (terpri out-stream))
 
(defun print-package (package)
  (format out-stream "~&~%(IN-PACKAGE ~S )~%~%" package))
 
(defparameter Meta_Prefix nil)
 
(defun set-prefix (prefix)  (setq META_PREFIX prefix))
 
(defun print-rule (x)  (print x out-stream) (format out-stream "~%~%"))
 
; *** 5. META Error Handling
 
(defun meta-meta-error-handler (&optional (wanted nil) (parsing nil))
  "Print syntax error indication, underline character, scrub line."
  (format out-stream "~&% MetaLanguage syntax error: ")
  (if (Line-Past-End-P Current-Line)
      (cond ((and wanted parsing)
             (format out-stream "wanted ~A while parsing ~A.~%"
                     wanted parsing))
            (wanted (format out-stream "wanted ~A.~%" wanted))
            (parsing (format out-stream "while parsing ~A.~%" parsing)))
      (progn (format out-stream "~:[here~;wanted ~A here~]" wanted wanted)
             (format out-stream "~:[~; while parsing ~A~]:~%" parsing parsing)
             (Line-Print Current-Line)
             (Line-Clear Current-Line)
             (current-token)
             (incf $num_of_meta_errors)
             (setq Meta_Errors_Occurred t)))
   nil)

@
preparse
<<*>>=
; Global storage
 
(defparameter $preparseReportIfTrue NIL         "Should we print listings?")
(defparameter $IOIndex 0                        "Number of latest terminal input line.")
 
(defmacro pptest () `(/rp ">scratchpad>test.boot"))
 
(defun /RP (&optional (*boot-input-file* nil) (*boot-output-file* nil)
                      ($preparseReportIfTrue t))
  (with-open-stream
    (in-stream (or (and *boot-input-file* (open *boot-input-file* :direction :input))
                   *terminal-io*))
    (declare (special in-stream))
    (with-open-stream
      (out-stream (if *boot-output-file*
                      (open *boot-output-file* :direction :output)
                      *terminal-io*))
      (declare (special out-stream))
      (initialize-preparse in-stream)
      (do ((lines (PREPARSE in-stream) (PREPARSE in-stream))) ((null lines)))))
  T)
 
(DEFUN SKIP-IFBLOCK (X)
   (PROG (LINE IND)
     (DCQ (IND . LINE) (preparseReadLine1))
      (IF (NOT (STRINGP LINE))  (RETURN (CONS IND LINE)))
      (IF (ZEROP (SIZE LINE)) (RETURN (SKIP-IFBLOCK X)))
      (COND ((CHAR= (ELT LINE 0) #\) )
          (COND
            ((INITIAL-SUBSTRING ")if" LINE)
                (COND ((EVAL (|string2BootTree| (STOREBLANKS LINE 3)))
                       (RETURN (preparseReadLine X)))
                      ('T (RETURN (SKIP-IFBLOCK X)))))
            ((INITIAL-SUBSTRING ")elseif" LINE)
                (COND ((EVAL (|string2BootTree| (STOREBLANKS LINE 7)))
                       (RETURN (preparseReadLine X)))
                      ('T (RETURN (SKIP-IFBLOCK X)))))
            ((INITIAL-SUBSTRING ")else" LINE)
             (RETURN (preparseReadLine X)))
            ((INITIAL-SUBSTRING ")endif" LINE)
             (RETURN (preparseReadLine X)))
            ((INITIAL-SUBSTRING ")fin" LINE)
             (RETURN (CONS IND NIL))))))
      (RETURN (SKIP-IFBLOCK X)) ) )
 
 
@
parse
<<*>>=
;parseUpArrow u ==  parseTran ["**",:u]

;;;     ***       |parseUpArrow| REDEFINED

(DEFUN |parseUpArrow| (|u|) (|parseTran| (CONS (QUOTE **) |u|))) 
;
;parseLeftArrow u == parseTran ["LET",:u]

;;;     ***       |parseLeftArrow| REDEFINED

(DEFUN |parseLeftArrow| (|u|) (|parseTran| (CONS (QUOTE LET) |u|))) 
;
;
;transIs u ==
;  isListConstructor u => ['construct,:transIs1 u]
;  u

;;;     ***       |transIs| REDEFINED

(DEFUN |transIs| (|u|) (COND ((|isListConstructor| |u|) (CONS (QUOTE |construct|) (|transIs1| |u|))) ((QUOTE T) |u|))) 
;
;isListConstructor u == u is [op,:.] and op in '(construct append cons)

;;;     ***       |isListConstructor| REDEFINED

(DEFUN |isListConstructor| (|u|) (PROG (|op|) (RETURN (AND (PAIRP |u|) (PROGN (SPADLET |op| (QCAR |u|)) (QUOTE T)) (|member| |op| (QUOTE (|construct| |append| |cons|))))))) 
;
;transIs1 u ==
;  u is ['construct,:l] => [transIs x for x in l]
;  u is ['append,x,y] =>
;    h:= [":",transIs x]
;    (v:= transIs1 y) is [":",z] => [h,z]
;    v="nil" => first rest h
;    atom v => [h,[":",v]]
;    [h,:v]
;  u is ['cons,x,y] =>
;    h:= transIs x
;    (v:= transIs1 y) is [":",z] => [h,z]
;    v="nil" => [h]
;    atom v => [h,[":",v]]
;    [h,:v]
;  u

;;;     ***       |transIs1| REDEFINED

(DEFUN |transIs1| (|u|) (PROG (|l| |x| |y| |h| |v| |ISTMP#1| |ISTMP#2| |z|) (RETURN (SEQ (COND ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |construct|)) (PROGN (SPADLET |l| (QCDR |u|)) (QUOTE T))) (PROG (#0=#:G166255) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G166260 |l| (CDR #1#)) (|x| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (|transIs| |x|) #0#)))))))) ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |append|)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |x| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#2|)) (QUOTE T))))))) (SPADLET |h| (CONS (QUOTE |:|) (CONS (|transIs| |x|) NIL))) (COND ((PROGN (SPADLET |ISTMP#1| (SPADLET |v| (|transIs1| |y|))) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |z| (QCAR |ISTMP#2|)) (QUOTE T)))))) (CONS |h| (CONS |z| NIL))) ((BOOT-EQUAL |v| (QUOTE |nil|)) (CAR (CDR |h|))) ((ATOM |v|) (CONS |h| (CONS (CONS (QUOTE |:|) (CONS |v| NIL)) NIL))) ((QUOTE T) (CONS |h| |v|)))) ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |cons|)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |x| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#2|)) (QUOTE T))))))) (SPADLET |h| (|transIs| |x|)) (COND ((PROGN (SPADLET |ISTMP#1| (SPADLET |v| (|transIs1| |y|))) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |z| (QCAR |ISTMP#2|)) (QUOTE T)))))) (CONS |h| (CONS |z| NIL))) ((BOOT-EQUAL |v| (QUOTE |nil|)) (CONS |h| NIL)) ((ATOM |v|) (CONS |h| (CONS (CONS (QUOTE |:|) (CONS |v| NIL)) NIL))) ((QUOTE T) (CONS |h| |v|)))) ((QUOTE T) |u|)))))) 
;
;
;
;parseBigelt [typ,consForm] ==
;  [['elt,typ,'makeRecord],:transUnCons consForm]

;;;     ***       |parseBigelt| REDEFINED

(DEFUN |parseBigelt| (#0=#:G166338) (PROG (|typ| |consForm|) (RETURN (PROGN (SPADLET |typ| (CAR #0#)) (SPADLET |consForm| (CADR #0#)) (CONS (CONS (QUOTE |elt|) (CONS |typ| (CONS (QUOTE |makeRecord|) NIL))) (|transUnCons| |consForm|)))))) 
;
;transUnCons u ==
;  atom u => systemErrorHere '"transUnCons"
;  u is ["APPEND",x,y] =>
;    null y => x
;    systemErrorHere '"transUnCons"
;  u is ["CONS",x,y] =>
;    atom y => [x,:y]
;    [x,:transUnCons y]

;;;     ***       |transUnCons| REDEFINED

(DEFUN |transUnCons| (|u|) (PROG (|ISTMP#1| |x| |ISTMP#2| |y|) (RETURN (COND ((ATOM |u|) (|systemErrorHere| "transUnCons")) ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE APPEND)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |x| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#2|)) (QUOTE T))))))) (COND ((NULL |y|) |x|) ((QUOTE T) (|systemErrorHere| "transUnCons")))) ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE CONS)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |x| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#2|)) (QUOTE T))))))) (COND ((ATOM |y|) (CONS |x| |y|)) ((QUOTE T) (CONS |x| (|transUnCons| |y|))))))))) 
;
;
;
;
;parseType x ==
;  x := substitute($EmptyMode,$quadSymbol,x)
;  x is ['typeOf,val] => ['typeOf,parseTran val]
;  x

;;;     ***       |parseType| REDEFINED

(defun |parseType| (x)
 (let (tmp1 val)
  (setq x (msubst |$EmptyMode| |$quadSymbol| x))
  (cond
   ((and (pairp x) 
         (eq (qcar x) '|typeOf|)
         (progn
          (setq tmp1 (qcdr x))
          (and (pairp tmp1) 
               (eq (qcdr tmp1) nil)
               (progn 
                (spadlet val (qcar tmp1))
                t))))
     (cons '|typeOf| (cons (|parseTran| val) nil)))
   (t x))))

;
;parseTypeEvaluate form ==
;  form is [op,:argl] =>
;    newType? op => form
;    $op: local:= op
;    op = 'Mapping =>
;      [op,:[parseTypeEvaluate a for a in argl]]
;    op = 'Union =>
;      isTaggedUnion form =>
;        [op,:[['_:,sel,parseTypeEvaluate type] for
;          ['_:,sel,type] in argl]]
;      [op,:[parseTypeEvaluate a for a in argl]]
;    op = 'Record =>
;      [op,:[['_:,sel,parseTypeEvaluate type] for ['_:,sel,type] in argl]]
;    cmm :=
;      fn := constructor? op =>
;        p := pathname [fn,$spadLibFT,'"*"] =>
;          isExistingFile p => getConstructorModemap(abbreviation? fn)
;          nil
;      nil
;    cmm is [[.,.,:argml],:.] => [op,:parseTypeEvaluateArgs(argl,argml)]
;    throwKeyedMsg("S2IL0015",[op])
;  form

;;;     ***       |parseTypeEvaluate| REDEFINED

(DEFUN |parseTypeEvaluate| (|form|) (PROG (|$op| |op| |argl| |sel| |type| |fn| |p| |cmm| |ISTMP#1| |ISTMP#2| |argml|) (DECLARE (SPECIAL |$op|)) (RETURN (SEQ (COND ((AND (PAIRP |form|) (PROGN (SPADLET |op| (QCAR |form|)) (SPADLET |argl| (QCDR |form|)) (QUOTE T))) (COND ((|newType?| |op|) |form|) ((QUOTE T) (SPADLET |$op| |op|) (COND ((BOOT-EQUAL |op| (QUOTE |Mapping|)) (CONS |op| (PROG (#0=#:G166484) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G166489 |argl| (CDR #1#)) (|a| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |a| (CAR #1#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (|parseTypeEvaluate| |a|) #0#))))))))) ((BOOT-EQUAL |op| (QUOTE |Union|)) (COND ((|isTaggedUnion| |form|) (CONS |op| (PROG (#2=#:G166500) (SPADLET #2# NIL) (RETURN (DO ((#3=#:G166506 |argl| (CDR #3#)) (#4=#:G166457 NIL)) ((OR (ATOM #3#) (PROGN (SETQ #4# (CAR #3#)) NIL) (PROGN (PROGN (SPADLET |sel| (CADR #4#)) (SPADLET |type| (CADDR #4#)) #4#) NIL)) (NREVERSE0 #2#)) (SEQ (EXIT (SETQ #2# (CONS (CONS (QUOTE |:|) (CONS |sel| (CONS (|parseTypeEvaluate| |type|) NIL))) #2#))))))))) ((QUOTE T) (CONS |op| (PROG (#5=#:G166517) (SPADLET #5# NIL) (RETURN (DO ((#6=#:G166522 |argl| (CDR #6#)) (|a| NIL)) ((OR (ATOM #6#) (PROGN (SETQ |a| (CAR #6#)) NIL)) (NREVERSE0 #5#)) (SEQ (EXIT (SETQ #5# (CONS (|parseTypeEvaluate| |a|) #5#))))))))))) ((BOOT-EQUAL |op| (QUOTE |Record|)) (CONS |op| (PROG (#7=#:G166533) (SPADLET #7# NIL) (RETURN (DO ((#8=#:G166539 |argl| (CDR #8#)) (#9=#:G166462 NIL)) ((OR (ATOM #8#) (PROGN (SETQ #9# (CAR #8#)) NIL) (PROGN (PROGN (SPADLET |sel| (CADR #9#)) (SPADLET |type| (CADDR #9#)) #9#) NIL)) (NREVERSE0 #7#)) (SEQ (EXIT (SETQ #7# (CONS (CONS (QUOTE |:|) (CONS |sel| (CONS (|parseTypeEvaluate| |type|) NIL))) #7#))))))))) ((QUOTE T) (SPADLET |cmm| (SEQ (COND ((SPADLET |fn| (|constructor?| |op|)) (COND ((SPADLET |p| (|pathname| (CONS |fn| (CONS |$spadLibFT| (CONS "*" NIL))))) (EXIT (COND ((|isExistingFile| |p|) (|getConstructorModemap| (|abbreviation?| |fn|))) ((QUOTE T) NIL)))))) ((QUOTE T) NIL)))) (COND ((AND (PAIRP |cmm|) (PROGN (SPADLET |ISTMP#1| (QCAR |cmm|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (PROGN (SPADLET |argml| (QCDR |ISTMP#2|)) (QUOTE T))))))) (CONS |op| (|parseTypeEvaluateArgs| |argl| |argml|))) ((QUOTE T) (|throwKeyedMsg| (QUOTE S2IL0015) (CONS |op| NIL))))))))) ((QUOTE T) |form|)))))) 
;
;parseTypeEvaluateArgs(argl,argml) ==
;  [argVal for arg in argl for md in argml for i in 1..] where argVal ==
;      isCategoryForm(md,$CategoryFrame) => parseTypeEvaluate arg
;      arg

;;;     ***       |parseTypeEvaluateArgs| REDEFINED

(DEFUN |parseTypeEvaluateArgs| (|argl| |argml|) (PROG NIL (RETURN (SEQ (PROG (#0=#:G166576) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G166583 |argl| (CDR #1#)) (|arg| NIL) (#2=#:G166584 |argml| (CDR #2#)) (|md| NIL) (|i| 1 (QSADD1 |i|))) ((OR (ATOM #1#) (PROGN (SETQ |arg| (CAR #1#)) NIL) (ATOM #2#) (PROGN (SETQ |md| (CAR #2#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (COND ((|isCategoryForm| |md| |$CategoryFrame|) (|parseTypeEvaluate| |arg|)) ((QUOTE T) |arg|)) #0#))))))))))) 
;
;
;parseTypeError(x,md,i) == throwKeyedMsg("S2IP0003",[i,$op,md])

;;;     ***       |parseTypeError| REDEFINED

(DEFUN |parseTypeError| (|x| |md| |i|) (|throwKeyedMsg| (QUOTE S2IP0003) (CONS |i| (CONS |$op| (CONS |md| NIL))))) 
;
;specialModeTran form ==
;  form is [op,:argl] =>
;    not ATOM op => form --added 10/5/84 by SCM
;    (s0:= (sop:= PNAME op).0) = "*" =>
;      n:= #sop
;      n=1=> form
;      argKey:= sop.1
;      numArgs:= #argl - (argKey="1" => 1; 0)
;      zeroOrOne:= argKey="0" or argKey="1"
;      isDmp :=
;        numArgs < 10 =>
;          n=6 and ('"DMP"=SUBSTRING(sop,3,3)) and zeroOrOne
;        true =>
;          n=7 and ('"DMP"=SUBSTRING(sop,4,3)) and zeroOrOne
;      isDmp =>
;        if argKey="0" then
;          extraDomain:= $EmptyMode
;          vl:= argl
;         else
;          [:vl,extraDomain] := argl
;        ['DistributedMultivariatePolynomial,['construct,:vl],
;            specialModeTran extraDomain]
;      n=4 and (s3:= sop.3) = "M" and zeroOrOne =>
;        specialModeTran
;          extraDomain:= (argKey="0" => [$EmptyMode]; nil)
;          (n:= PARSE_-INTEGER PNAME sop.2)=1 =>
;            ['SquareMatrix,:argl,:extraDomain]
;          n=2 => ['RectangularMatrix,:argl,:extraDomain]
;          form
;      isUpOrMp :=
;        numArgs < 10 =>
;          n=4 and (s3:= sop.3) = 'P and zeroOrOne or
;            n=5 and (s3:= sop.3)='R and sop.4='F and zeroOrOne
;        true =>
;          n=5 and (s3:= sop.4) = 'P and zeroOrOne or
;            n=6 and (s3:= sop.4)='R and sop.5='F and zeroOrOne
;      isUpOrMp =>
;        polyForm:=
;          domainPart:= (argKey="0" => $EmptyMode; last argl)
;          argPart:= (argKey="0" => argl; drop(-1,argl))
;          numArgs < 10 and (n:= PARSE_-INTEGER PNAME sop.2)=1
;            => ['UP,:argPart,domainPart]
;          ['MP,['construct,:argPart],domainPart]
;        specialModeTran
;          s3 = 'R => [$QuotientField,polyForm]
;          polyForm
;      [first form,:[specialModeTran x for x in rest form]]
;    [first form,:[specialModeTran x for x in rest form]]
;  form

;;;     ***       |specialModeTran| REDEFINED

(DEFUN |specialModeTran| (|form|) (PROG (|op| |argl| |sop| |s0| |argKey| |numArgs| |zeroOrOne| |isDmp| |LETTMP#1| |vl| |extraDomain| |s3| |isUpOrMp| |domainPart| |argPart| |n| |polyForm|) (RETURN (SEQ (COND ((AND (PAIRP |form|) (PROGN (SPADLET |op| (QCAR |form|)) (SPADLET |argl| (QCDR |form|)) (QUOTE T))) (COND ((NULL (ATOM |op|)) |form|) ((BOOT-EQUAL (SPADLET |s0| (ELT (SPADLET |sop| (PNAME |op|)) 0)) (QUOTE *)) (SPADLET |n| (|#| |sop|)) (COND ((EQL |n| 1) |form|) ((QUOTE T) (SPADLET |argKey| (ELT |sop| 1)) (SPADLET |numArgs| (SPADDIFFERENCE (|#| |argl|) (COND ((BOOT-EQUAL |argKey| (QUOTE |1|)) 1) ((QUOTE T) 0)))) (SPADLET |zeroOrOne| (OR (BOOT-EQUAL |argKey| (QUOTE |0|)) (BOOT-EQUAL |argKey| (QUOTE |1|)))) (SPADLET |isDmp| (COND ((> 10 |numArgs|) (AND (EQL |n| 6) (BOOT-EQUAL "DMP" (SUBSTRING |sop| 3 3)) |zeroOrOne|)) ((QUOTE T) (AND (EQL |n| 7) (BOOT-EQUAL "DMP" (SUBSTRING |sop| 4 3)) |zeroOrOne|)))) (COND (|isDmp| (COND ((BOOT-EQUAL |argKey| (QUOTE |0|)) (SPADLET |extraDomain| |$EmptyMode|) (SPADLET |vl| |argl|)) ((QUOTE T) (SPADLET |LETTMP#1| (REVERSE |argl|)) (SPADLET |extraDomain| (CAR |LETTMP#1|)) (SPADLET |vl| (NREVERSE (CDR |LETTMP#1|))) |argl|)) (CONS (QUOTE |DistributedMultivariatePolynomial|) (CONS (CONS (QUOTE |construct|) |vl|) (CONS (|specialModeTran| |extraDomain|) NIL)))) ((AND (EQL |n| 4) (BOOT-EQUAL (SPADLET |s3| (ELT |sop| 3)) (QUOTE M)) |zeroOrOne|) (|specialModeTran| (PROGN (SPADLET |extraDomain| (COND ((BOOT-EQUAL |argKey| (QUOTE |0|)) (CONS |$EmptyMode| NIL)) ((QUOTE T) NIL))) (COND ((EQL (SPADLET |n| (PARSE-INTEGER (PNAME (ELT |sop| 2)))) 1) (CONS (QUOTE |SquareMatrix|) (APPEND |argl| |extraDomain|))) ((EQL |n| 2) (CONS (QUOTE |RectangularMatrix|) (APPEND |argl| |extraDomain|))) ((QUOTE T) |form|))))) ((QUOTE T) (SPADLET |isUpOrMp| (COND ((> 10 |numArgs|) (OR (AND (EQL |n| 4) (BOOT-EQUAL (SPADLET |s3| (ELT |sop| 3)) (QUOTE P)) |zeroOrOne|) (AND (EQL |n| 5) (BOOT-EQUAL (SPADLET |s3| (ELT |sop| 3)) (QUOTE R)) (BOOT-EQUAL (ELT |sop| 4) (QUOTE F)) |zeroOrOne|))) ((QUOTE T) (OR (AND (EQL |n| 5) (BOOT-EQUAL (SPADLET |s3| (ELT |sop| 4)) (QUOTE P)) |zeroOrOne|) (AND (EQL |n| 6) (BOOT-EQUAL (SPADLET |s3| (ELT |sop| 4)) (QUOTE R)) (BOOT-EQUAL (ELT |sop| 5) (QUOTE F)) |zeroOrOne|))))) (COND (|isUpOrMp| (SPADLET |polyForm| (PROGN (SPADLET |domainPart| (COND ((BOOT-EQUAL |argKey| (QUOTE |0|)) |$EmptyMode|) ((QUOTE T) (|last| |argl|)))) (SPADLET |argPart| (COND ((BOOT-EQUAL |argKey| (QUOTE |0|)) |argl|) ((QUOTE T) (DROP (SPADDIFFERENCE 1) |argl|)))) (COND ((AND (> 10 |numArgs|) (EQL (SPADLET |n| (PARSE-INTEGER (PNAME (ELT |sop| 2)))) 1)) (CONS (QUOTE UP) (APPEND |argPart| (CONS |domainPart| NIL)))) ((QUOTE T) (CONS (QUOTE MP) (CONS (CONS (QUOTE |construct|) |argPart|) (CONS |domainPart| NIL))))))) (|specialModeTran| (COND ((BOOT-EQUAL |s3| (QUOTE R)) (CONS |$QuotientField| (CONS |polyForm| NIL))) ((QUOTE T) |polyForm|)))) ((QUOTE T) (CONS (CAR |form|) (PROG (#0=#:G166626) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G166631 (CDR |form|) (CDR #1#)) (|x| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (|specialModeTran| |x|) #0#))))))))))))))) ((QUOTE T) (CONS (CAR |form|) (PROG (#2=#:G166641) (SPADLET #2# NIL) (RETURN (DO ((#3=#:G166646 (CDR |form|) (CDR #3#)) (|x| NIL)) ((OR (ATOM #3#) (PROGN (SETQ |x| (CAR #3#)) NIL)) (NREVERSE0 #2#)) (SEQ (EXIT (SETQ #2# (CONS (|specialModeTran| |x|) #2#))))))))))) ((QUOTE T) |form|)))))) 
;
;
;parseHasRhs u ==   --$InteractiveMode = true
;  get(u,'value,$CategoryFrame) is [D,m,.]
;    and m in '((Mode) (Domain) (SubDomain (Domain))) => m
;  y := abbreviation? u =>
;    loadIfNecessary y => [unabbrevAndLoad y]
;    [['ATTRIBUTE,u]]
;  [['ATTRIBUTE,u]]

;;;     ***       |parseHasRhs| REDEFINED

(DEFUN |parseHasRhs| (|u|) (PROG (|ISTMP#1| D |ISTMP#2| |m| |ISTMP#3| |y|) (RETURN (COND ((AND (PROGN (SPADLET |ISTMP#1| (|get| |u| (QUOTE |value|) |$CategoryFrame|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET D (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (PROGN (SPADLET |m| (QCAR |ISTMP#2|)) (SPADLET |ISTMP#3| (QCDR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (EQ (QCDR |ISTMP#3|) NIL))))))) (|member| |m| (QUOTE ((|Mode|) (|Domain|) (|SubDomain| (|Domain|)))))) |m|) ((SPADLET |y| (|abbreviation?| |u|)) (COND ((|loadIfNecessary| |y|) (CONS (|unabbrevAndLoad| |y|) NIL)) ((QUOTE T) (CONS (CONS (QUOTE ATTRIBUTE) (CONS |u| NIL)) NIL)))) ((QUOTE T) (CONS (CONS (QUOTE ATTRIBUTE) (CONS |u| NIL)) NIL)))))) 
;
;
;parseLhs x ==
;  atom x => parseTran x
;  atom first x => [parseTran first x,:[transIs parseTran y for y in rest x]]
;  parseTran x

;;;     ***       |parseLhs| REDEFINED

(DEFUN |parseLhs| (|x|) (PROG NIL (RETURN (SEQ (COND ((ATOM |x|) (|parseTran| |x|)) ((ATOM (CAR |x|)) (CONS (|parseTran| (CAR |x|)) (PROG (#0=#:G166888) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G166893 (CDR |x|) (CDR #1#)) (|y| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |y| (CAR #1#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (|transIs| (|parseTran| |y|)) #0#))))))))) ((QUOTE T) (|parseTran| |x|))))))) 
;
;
;parseTranCheckForRecord(x,op) ==
;  (x:= parseTran x) is ['Record,:l] =>
;    or/[y for y in l | y isnt [":",.,.]] =>
;      postError ['"   Constructor",:bright x,'"has missing label"]
;    x
;  x

;;;     ***       |parseTranCheckForRecord| REDEFINED

(DEFUN |parseTranCheckForRecord| (|x| |op|) (PROG (|l| |ISTMP#1| |ISTMP#2|) (RETURN (SEQ (COND ((PROGN (SPADLET |ISTMP#1| (SPADLET |x| (|parseTran| |x|))) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |Record|)) (PROGN (SPADLET |l| (QCDR |ISTMP#1|)) (QUOTE T)))) (COND ((PROG (#0=#:G166937) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G166944 NIL #0#) (#2=#:G166945 |l| (CDR #2#)) (|y| NIL)) ((OR #1# (ATOM #2#) (PROGN (SETQ |y| (CAR #2#)) NIL)) #0#) (SEQ (EXIT (COND ((NULL (AND (PAIRP |y|) (EQ (QCAR |y|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#1| (QCDR |y|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL))))))) (SETQ #0# (OR #0# |y|))))))))) (|postError| (CONS "   Constructor" (APPEND (|bright| |x|) (CONS "has missing label" NIL))))) ((QUOTE T) |x|))) ((QUOTE T) |x|)))))) 
;
;parseCases [expr,ifClause] ==
;  casefn(expr,ifClause) where
;    casefn(x,ifExpr) ==
;      ifExpr='noBranch => ['ifClauseError,x]
;      ifExpr is ['IF,a,b,c] => ['IF,parseTran a,parseTran b,casefn(x,c)]
;      postError ['"   CASES format error: cases ",x," of ",ifExpr]

;;;     ***       |parseCases,casefn| REDEFINED

(DEFUN |parseCases,casefn| (|x| |ifExpr|) (PROG (|ISTMP#1| |a| |ISTMP#2| |b| |ISTMP#3| |c|) (RETURN (SEQ (IF (BOOT-EQUAL |ifExpr| (QUOTE |noBranch|)) (EXIT (CONS (QUOTE |ifClauseError|) (CONS |x| NIL)))) (IF (AND (PAIRP |ifExpr|) (EQ (QCAR |ifExpr|) (QUOTE IF)) (PROGN (SPADLET |ISTMP#1| (QCDR |ifExpr|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (PROGN (SPADLET |b| (QCAR |ISTMP#2|)) (SPADLET |ISTMP#3| (QCDR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (EQ (QCDR |ISTMP#3|) NIL) (PROGN (SPADLET |c| (QCAR |ISTMP#3|)) (QUOTE T))))))))) (EXIT (CONS (QUOTE IF) (CONS (|parseTran| |a|) (CONS (|parseTran| |b|) (CONS (|parseCases,casefn| |x| |c|) NIL)))))) (EXIT (|postError| (CONS "   CASES format error: cases " (CONS |x| (CONS (QUOTE | of |) (CONS |ifExpr| NIL)))))))))) 

;;;     ***       |parseCases| REDEFINED

(DEFUN |parseCases| (#0=#:G167006) (PROG (|expr| |ifClause|) (RETURN (PROGN (SPADLET |expr| (CAR #0#)) (SPADLET |ifClause| (CADR #0#)) (|parseCases,casefn| |expr| |ifClause|))))) 
;
;
;parseDropAssertions x ==
;--note: the COPY of this list is necessary-- do not replace by RPLACing version
;  x is [y,:r] =>
;    y is ['IF,'asserted,:.] => parseDropAssertions r
;    [y,:parseDropAssertions r]
;  x

;;;     ***       |parseDropAssertions| REDEFINED

(DEFUN |parseDropAssertions| (|x|) (PROG (|y| |r| |ISTMP#1|) (RETURN (COND ((AND (PAIRP |x|) (PROGN (SPADLET |y| (QCAR |x|)) (SPADLET |r| (QCDR |x|)) (QUOTE T))) (COND ((AND (PAIRP |y|) (EQ (QCAR |y|) (QUOTE IF)) (PROGN (SPADLET |ISTMP#1| (QCDR |y|)) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |asserted|))))) (|parseDropAssertions| |r|)) ((QUOTE T) (CONS |y| (|parseDropAssertions| |r|))))) ((QUOTE T) |x|))))) 
;
;

;
;
;
;

;
;
;parseExclusiveOr [a,b] == parseIf [a,parseIf [b,:'(false true)],b]

;;;     ***       |parseExclusiveOr| REDEFINED

;(DEFUN |parseExclusiveOr| (#0=#:G167140) (PROG (|a| |b|) (RETURN (PROGN (SPADLET |a| (CAR #0#)) (SPADLET |b| (CADR #0#)) (|parseIf| (CONS |a| (CONS (|parseIf| (CONS |b| (QUOTE (|false| |true|)))) (CONS |b| NIL)))))))) 
;

;
;
;
;
;
;
;makeSimplePredicateOrNil p ==
;  isSimple p => nil
;  u:= isAlmostSimple p => u
;  true => wrapSEQExit [['LET,g:= GENSYM(),p],g]

;;;     ***       |makeSimplePredicateOrNil| REDEFINED

(DEFUN |makeSimplePredicateOrNil| (|p|) (PROG (|u| |g|) (RETURN (COND ((|isSimple| |p|) NIL) ((SPADLET |u| (|isAlmostSimple| |p|)) |u|) ((QUOTE T) (|wrapSEQExit| (CONS (CONS (QUOTE LET) (CONS (SPADLET |g| (GENSYM)) (CONS |p| NIL))) (CONS |g| NIL)))))))) 
;
;
;
;
;transSeq l ==
;  null l => nil
;  null rest l => decExitLevel first l
;  [item,:tail]:= l
;  item is ['SEQ,:l,['exit,1,['IF,p,['exit, =2,q],'noBranch]]] and
;    (and/[x is ['LET,:.] for x in l]) =>
;      ['SEQ,:[decExitLevel x for x in l],['exit,1,['IF,decExitLevel p,
;        decExitLevel q,transSeq tail]]]
;  item is ['IF,a,['exit,1,b],'noBranch] =>
;    ['IF,decExitLevel a,decExitLevel b,transSeq tail]
;  item is ['IF,a,'noBranch,['exit,1,b]] =>
;    ['IF,decExitLevel a,transSeq tail,decExitLevel b]
;  (y:= transSeq tail) is ['SEQ,:s] => ['SEQ,item,:s]
;  ['SEQ,item,['exit,1,incExitLevel y]]

;;;     ***       |transSeq| REDEFINED

(DEFUN |transSeq| (|l|) (PROG (|item| |tail| |ISTMP#7| |p| |ISTMP#8| |ISTMP#9| |ISTMP#10| |ISTMP#11| |q| |ISTMP#12| |a| |ISTMP#2| |ISTMP#3| |ISTMP#4| |ISTMP#5| |ISTMP#6| |b| |y| |ISTMP#1| |s|) (RETURN (SEQ (COND ((NULL |l|) NIL) ((NULL (CDR |l|)) (|decExitLevel| (CAR |l|))) ((QUOTE T) (SPADLET |item| (CAR |l|)) (SPADLET |tail| (CDR |l|)) (COND ((AND (PAIRP |item|) (EQ (QCAR |item|) (QUOTE SEQ)) (PROGN (SPADLET |ISTMP#1| (QCDR |item|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ISTMP#2| (REVERSE |ISTMP#1|)) (QUOTE T)) (PAIRP |ISTMP#2|) (PROGN (SPADLET |ISTMP#3| (QCAR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (EQ (QCAR |ISTMP#3|) (QUOTE |exit|)) (PROGN (SPADLET |ISTMP#4| (QCDR |ISTMP#3|)) (AND (PAIRP |ISTMP#4|) (EQUAL (QCAR |ISTMP#4|) 1) (PROGN (SPADLET |ISTMP#5| (QCDR |ISTMP#4|)) (AND (PAIRP |ISTMP#5|) (EQ (QCDR |ISTMP#5|) NIL) (PROGN (SPADLET |ISTMP#6| (QCAR |ISTMP#5|)) (AND (PAIRP |ISTMP#6|) (EQ (QCAR |ISTMP#6|) (QUOTE IF)) (PROGN (SPADLET |ISTMP#7| (QCDR |ISTMP#6|)) (AND (PAIRP |ISTMP#7|) (PROGN (SPADLET |p| (QCAR |ISTMP#7|)) (SPADLET |ISTMP#8| (QCDR |ISTMP#7|)) (AND (PAIRP |ISTMP#8|) (PROGN (SPADLET |ISTMP#9| (QCAR |ISTMP#8|)) (AND (PAIRP |ISTMP#9|) (EQ (QCAR |ISTMP#9|) (QUOTE |exit|)) (PROGN (SPADLET |ISTMP#10| (QCDR |ISTMP#9|)) (AND (PAIRP |ISTMP#10|) (EQUAL (QCAR |ISTMP#10|) 2) (PROGN (SPADLET |ISTMP#11| (QCDR |ISTMP#10|)) (AND (PAIRP |ISTMP#11|) (EQ (QCDR |ISTMP#11|) NIL) (PROGN (SPADLET |q| (QCAR |ISTMP#11|)) (QUOTE T)))))))) (PROGN (SPADLET |ISTMP#12| (QCDR |ISTMP#8|)) (AND (PAIRP |ISTMP#12|) (EQ (QCDR |ISTMP#12|) NIL) (EQ (QCAR |ISTMP#12|) (QUOTE |noBranch|)))))))))))))))) (PROGN (SPADLET |l| (QCDR |ISTMP#2|)) (QUOTE T)) (PROGN (SPADLET |l| (NREVERSE |l|)) (QUOTE T)))) (PROG (#0=#:G168041) (SPADLET #0# (QUOTE T)) (RETURN (DO ((#1=#:G168047 NIL (NULL #0#)) (#2=#:G168048 |l| (CDR #2#)) (|x| NIL)) ((OR #1# (ATOM #2#) (PROGN (SETQ |x| (CAR #2#)) NIL)) #0#) (SEQ (EXIT (SETQ #0# (AND #0# (AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE LET))))))))))) (CONS (QUOTE SEQ) (APPEND (PROG (#3=#:G168059) (SPADLET #3# NIL) (RETURN (DO ((#4=#:G168064 |l| (CDR #4#)) (|x| NIL)) ((OR (ATOM #4#) (PROGN (SETQ |x| (CAR #4#)) NIL)) (NREVERSE0 #3#)) (SEQ (EXIT (SETQ #3# (CONS (|decExitLevel| |x|) #3#))))))) (CONS (CONS (QUOTE |exit|) (CONS 1 (CONS (CONS (QUOTE IF) (CONS (|decExitLevel| |p|) (CONS (|decExitLevel| |q|) (CONS (|transSeq| |tail|) NIL)))) NIL))) NIL)))) ((AND (PAIRP |item|) (EQ (QCAR |item|) (QUOTE IF)) (PROGN (SPADLET |ISTMP#1| (QCDR |item|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (PROGN (SPADLET |ISTMP#3| (QCAR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (EQ (QCAR |ISTMP#3|) (QUOTE |exit|)) (PROGN (SPADLET |ISTMP#4| (QCDR |ISTMP#3|)) (AND (PAIRP |ISTMP#4|) (EQUAL (QCAR |ISTMP#4|) 1) (PROGN (SPADLET |ISTMP#5| (QCDR |ISTMP#4|)) (AND (PAIRP |ISTMP#5|) (EQ (QCDR |ISTMP#5|) NIL) (PROGN (SPADLET |b| (QCAR |ISTMP#5|)) (QUOTE T)))))))) (PROGN (SPADLET |ISTMP#6| (QCDR |ISTMP#2|)) (AND (PAIRP |ISTMP#6|) (EQ (QCDR |ISTMP#6|) NIL) (EQ (QCAR |ISTMP#6|) (QUOTE |noBranch|))))))))) (CONS (QUOTE IF) (CONS (|decExitLevel| |a|) (CONS (|decExitLevel| |b|) (CONS (|transSeq| |tail|) NIL))))) ((AND (PAIRP |item|) (EQ (QCAR |item|) (QUOTE IF)) (PROGN (SPADLET |ISTMP#1| (QCDR |item|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCAR |ISTMP#2|) (QUOTE |noBranch|)) (PROGN (SPADLET |ISTMP#3| (QCDR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (EQ (QCDR |ISTMP#3|) NIL) (PROGN (SPADLET |ISTMP#4| (QCAR |ISTMP#3|)) (AND (PAIRP |ISTMP#4|) (EQ (QCAR |ISTMP#4|) (QUOTE |exit|)) (PROGN (SPADLET |ISTMP#5| (QCDR |ISTMP#4|)) (AND (PAIRP |ISTMP#5|) (EQUAL (QCAR |ISTMP#5|) 1) (PROGN (SPADLET |ISTMP#6| (QCDR |ISTMP#5|)) (AND (PAIRP |ISTMP#6|) (EQ (QCDR |ISTMP#6|) NIL) (PROGN (SPADLET |b| (QCAR |ISTMP#6|)) (QUOTE T))))))))))))))) (CONS (QUOTE IF) (CONS (|decExitLevel| |a|) (CONS (|transSeq| |tail|) (CONS (|decExitLevel| |b|) NIL))))) ((PROGN (SPADLET |ISTMP#1| (SPADLET |y| (|transSeq| |tail|))) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE SEQ)) (PROGN (SPADLET |s| (QCDR |ISTMP#1|)) (QUOTE T)))) (CONS (QUOTE SEQ) (CONS |item| |s|))) ((QUOTE T) (CONS (QUOTE SEQ) (CONS |item| (CONS (CONS (QUOTE |exit|) (CONS 1 (CONS (|incExitLevel| |y|) NIL))) NIL))))))))))) 
;
;transCategoryItem x ==
;  x is ['SIGNATURE,lhs,rhs] =>
;    lhs is ['LISTOF,:y] =>
;      "append" /[transCategoryItem ['SIGNATURE,z,rhs] for z in y]
;    atom lhs =>
;      if STRINGP lhs then lhs:= INTERN lhs
;      rhs is ['Mapping,:m] =>
;        m is [.,'constant] => LIST ['SIGNATURE,lhs,[first m],'constant]
;        LIST ['SIGNATURE,lhs,m]
;      $transCategoryAssoc:= [[lhs,:rhs],:$transCategoryAssoc]
;      NIL
;    [op,:argl]:= lhs
;    extra:= nil
;    if rhs is ['Mapping,:m] then
;      if rest m then extra:= rest m
;                 --should only be 'constant' or 'variable'
;      rhs:= first m
;    LIST ['SIGNATURE,op,[rhs,:SUBLIS($transCategoryAssoc,argl)],:extra]
;  LIST x

;;;     ***       |transCategoryItem| REDEFINED

(DEFUN |transCategoryItem| (|x|) (PROG (|ISTMP#2| |y| |lhs| |ISTMP#1| |op| |argl| |m| |extra| |rhs|) (RETURN (SEQ (COND ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE SIGNATURE)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |lhs| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |rhs| (QCAR |ISTMP#2|)) (QUOTE T))))))) (COND ((AND (PAIRP |lhs|) (EQ (QCAR |lhs|) (QUOTE LISTOF)) (PROGN (SPADLET |y| (QCDR |lhs|)) (QUOTE T))) (PROG (#0=#:G168138) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G168143 |y| (CDR #1#)) (|z| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |z| (CAR #1#)) NIL)) #0#) (SEQ (EXIT (SETQ #0# (APPEND #0# (|transCategoryItem| (CONS (QUOTE SIGNATURE) (CONS |z| (CONS |rhs| NIL)))))))))))) ((ATOM |lhs|) (COND ((STRINGP |lhs|) (SPADLET |lhs| (INTERN |lhs|)))) (COND ((AND (PAIRP |rhs|) (EQ (QCAR |rhs|) (QUOTE |Mapping|)) (PROGN (SPADLET |m| (QCDR |rhs|)) (QUOTE T))) (COND ((AND (PAIRP |m|) (PROGN (SPADLET |ISTMP#1| (QCDR |m|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (EQ (QCAR |ISTMP#1|) (QUOTE |constant|))))) (LIST (CONS (QUOTE SIGNATURE) (CONS |lhs| (CONS (CONS (CAR |m|) NIL) (CONS (QUOTE |constant|) NIL)))))) ((QUOTE T) (LIST (CONS (QUOTE SIGNATURE) (CONS |lhs| (CONS |m| NIL))))))) ((QUOTE T) (SPADLET |$transCategoryAssoc| (CONS (CONS |lhs| |rhs|) |$transCategoryAssoc|)) NIL))) ((QUOTE T) (SPADLET |op| (CAR |lhs|)) (SPADLET |argl| (CDR |lhs|)) (SPADLET |extra| NIL) (COND ((AND (PAIRP |rhs|) (EQ (QCAR |rhs|) (QUOTE |Mapping|)) (PROGN (SPADLET |m| (QCDR |rhs|)) (QUOTE T))) (COND ((CDR |m|) (SPADLET |extra| (CDR |m|)))) (SPADLET |rhs| (CAR |m|)))) (LIST (CONS (QUOTE SIGNATURE) (CONS |op| (CONS (CONS |rhs| (SUBLIS |$transCategoryAssoc| |argl|)) |extra|))))))) ((QUOTE T) (LIST |x|))))))) 
;
;superSub(name,x) ==
;  for u in x repeat y:= [:y,:u]
;  code:=
;    x is [[u]] => $quadSymbol
;    STRCONC("_(",scriptTranRow first x,scriptTran rest x,"_)")
;  [INTERNL(PNAME name,"$",code),:y]

;;;     ***       |superSub| REDEFINED

(DEFUN |superSub| (|name| |x|) (PROG (|y| |ISTMP#1| |u| |code|) (RETURN (SEQ (PROGN (DO ((#0=#:G168177 |x| (CDR #0#)) (|u| NIL)) ((OR (ATOM #0#) (PROGN (SETQ |u| (CAR #0#)) NIL)) NIL) (SEQ (EXIT (SPADLET |y| (APPEND |y| |u|))))) (SPADLET |code| (COND ((AND (PAIRP |x|) (EQ (QCDR |x|) NIL) (PROGN (SPADLET |ISTMP#1| (QCAR |x|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |u| (QCAR |ISTMP#1|)) (QUOTE T))))) |$quadSymbol|) ((QUOTE T) (STRCONC (QUOTE |(|) (|scriptTranRow| (CAR |x|)) (|scriptTran| (CDR |x|)) (QUOTE |)|))))) (CONS (INTERNL (PNAME |name|) (QUOTE $) |code|) |y|)))))) 
;
;scriptTran x ==
;  null x => ""
;  STRCONC(";",scriptTranRow first x,scriptTran rest x)

;;;     ***       |scriptTran| REDEFINED

(DEFUN |scriptTran| (|x|) (COND ((NULL |x|) (QUOTE ||)) ((QUOTE T) (STRCONC (QUOTE |;|) (|scriptTranRow| (CAR |x|)) (|scriptTran| (CDR |x|)))))) 
;
;scriptTranRow x ==
;  null x => ""
;  STRCONC($quadSymbol,scriptTranRow1 rest x)

;;;     ***       |scriptTranRow| REDEFINED

(DEFUN |scriptTranRow| (|x|) (COND ((NULL |x|) (QUOTE ||)) ((QUOTE T) (STRCONC |$quadSymbol| (|scriptTranRow1| (CDR |x|)))))) 
;
;scriptTranRow1 x ==
;  null x => ""
;  STRCONC(",",$quadSymbol,scriptTranRow1 rest x)

;;;     ***       |scriptTranRow1| REDEFINED

(DEFUN |scriptTranRow1| (|x|) (COND ((NULL |x|) (QUOTE ||)) ((QUOTE T) (STRCONC (QUOTE |,|) |$quadSymbol| (|scriptTranRow1| (CDR |x|)))))) 
;
;;;Boot translation finished for parse.boot

;displayPreCompilationErrors() ==
;  n:= #($postStack:= REMDUP NREVERSE $postStack)
;  n=0 => nil
;  errors:=
;    1<n => '"errors"
;    '"error"
;  if $InteractiveMode
;    then sayBrightly ['"   Semantic ",errors,'" detected: "]
;    else
;      heading:=
;        $topOp ^= '$topOp => ['"   ",$topOp,'" has"]
;        ['"   You have"]
;      sayBrightly [:heading,'%b,n,'%d,'"precompilation ",errors,'":"]
;  if 1<n then
;    (for x in $postStack for i in 1.. repeat sayMath ['"   ",i,'"_) ",:x])
;    else sayMath ['"    ",:first $postStack]
;  TERPRI()

;;;     ***       |displayPreCompilationErrors| REDEFINED

(DEFUN |displayPreCompilationErrors| NIL (PROG (|n| |errors| |heading|) (RETURN (SEQ (PROGN (SPADLET |n| (|#| (SPADLET |$postStack| (REMDUP (NREVERSE |$postStack|))))) (COND ((EQL |n| 0) NIL) ((QUOTE T) (SPADLET |errors| (COND ((> |n| 1) "errors") ((QUOTE T) "error"))) (COND (|$InteractiveMode| (|sayBrightly| (CONS "   Semantic " (CONS |errors| (CONS " detected: " NIL))))) ((QUOTE T) (SPADLET |heading| (COND ((NEQUAL |$topOp| (QUOTE |$topOp|)) (CONS "   " (CONS |$topOp| (CONS " has" NIL)))) ((QUOTE T) (CONS "   You have" NIL)))) (|sayBrightly| (APPEND |heading| (CONS (QUOTE |%b|) (CONS |n| (CONS (QUOTE |%d|) (CONS "precompilation " (CONS |errors| (CONS ":" NIL)))))))))) (COND ((> |n| 1) (DO ((#0=#:G166154 |$postStack| (CDR #0#)) (|x| NIL) (|i| 1 (QSADD1 |i|))) ((OR (ATOM #0#) (PROGN (SETQ |x| (CAR #0#)) NIL)) NIL) (SEQ (EXIT (|sayMath| (CONS "   " (CONS |i| (CONS ") " |x|)))))))) ((QUOTE T) (|sayMath| (CONS "    " (CAR |$postStack|))))) (TERPRI)))))))) 

;checkWarning msg == postError concat('"Parsing error: ",msg)

;;;     ***       |checkWarning| REDEFINED

(DEFUN |checkWarning| (|msg|) (|postError| (|concat| "Parsing error: " |msg|))) 
;
;checkWarningIndentation() ==
;  checkWarning ['"Apparent indentation error following",:bright "add"]

;;;     ***       |checkWarningIndentation| REDEFINED

(DEFUN |checkWarningIndentation| NIL (|checkWarning| (CONS "Apparent indentation error following" (|bright| (QUOTE |add|))))) 
;postCapsule x ==
;  x isnt [op,:.] => checkWarningIndentation()
;  INTEGERP op or op = "==" => ['CAPSULE,postBlockItem x]
;  op = ";" => ['CAPSULE,:postBlockItemList postFlatten(x,";")]
;  op = "if" => ['CAPSULE,postBlockItem x]
;  checkWarningIndentation()

;;;     ***       |postCapsule| REDEFINED

(DEFUN |postCapsule| (|x|) (PROG (|op|) (RETURN (COND ((NULL (AND (PAIRP |x|) (PROGN (SPADLET |op| (QCAR |x|)) (QUOTE T)))) (|checkWarningIndentation|)) ((OR (integerp |op|) (BOOT-EQUAL |op| (QUOTE ==))) (CONS (QUOTE CAPSULE) (CONS (|postBlockItem| |x|) NIL))) ((BOOT-EQUAL |op| (QUOTE |;|)) (CONS (QUOTE CAPSULE) (|postBlockItemList| (|postFlatten| |x| (QUOTE |;|))))) ((BOOT-EQUAL |op| (QUOTE |if|)) (CONS (QUOTE CAPSULE) (CONS (|postBlockItem| |x|) NIL))) ((QUOTE T) (|checkWarningIndentation|)))))) 
;postMakeCons l ==
;  null l => 'nil
;  l is [[":",a],:l'] =>
;    l' => ['append,postTran a,postMakeCons l']
;    postTran a
;  ['cons,postTran first l,postMakeCons rest l]

;;;     ***       |postMakeCons| REDEFINED

(DEFUN |postMakeCons| (|l|) (PROG (|ISTMP#1| |ISTMP#2| |a| |l'|) (RETURN (COND ((NULL |l|) (QUOTE |nil|)) ((AND (PAIRP |l|) (PROGN (SPADLET |ISTMP#1| (QCAR |l|)) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |a| (QCAR |ISTMP#2|)) (QUOTE T)))))) (PROGN (SPADLET |l'| (QCDR |l|)) (QUOTE T))) (COND (|l'| (CONS (QUOTE |append|) (CONS (|postTran| |a|) (CONS (|postMakeCons| |l'|) NIL)))) ((QUOTE T) (|postTran| |a|)))) ((QUOTE T) (CONS (QUOTE |cons|) (CONS (|postTran| (CAR |l|)) (CONS (|postMakeCons| (CDR |l|)) NIL)))))))) 

;postBlock ['Block,:l,x] ==
;  ['SEQ,:postBlockItemList l,['exit,postTran x]]

;;;     ***       |postBlock| REDEFINED

(DEFUN |postBlock| (#0=#:G166455) (PROG (|LETTMP#1| |x| |l|) (RETURN (PROGN (SPADLET |LETTMP#1| (REVERSE (CDR #0#))) (SPADLET |x| (CAR |LETTMP#1|)) (SPADLET |l| (NREVERSE (CDR |LETTMP#1|))) (CONS (QUOTE SEQ) (APPEND (|postBlockItemList| |l|) (CONS (CONS (QUOTE |exit|) (CONS (|postTran| |x|) NIL)) NIL))))))) 
;postBlockItemList l == [postBlockItem x for x in l]

;;;     ***       |postBlockItemList| REDEFINED

(DEFUN |postBlockItemList| (|l|) (PROG NIL (RETURN (SEQ (PROG (#0=#:G166476) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G166481 |l| (CDR #1#)) (|x| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (|postBlockItem| |x|) #0#))))))))))) 
;postBlockItem x ==
;  x:= postTran x
;  x is ['Tuple,:l,[":",y,t]] and (and/[IDENTP x for x in l]) =>
;    [":",['LISTOF,:l,y],t]
;  x

;;;     ***       |postBlockItem| REDEFINED

(DEFUN |postBlockItem| (|x|) (PROG (|ISTMP#1| |ISTMP#2| |ISTMP#3| |ISTMP#4| |y| |ISTMP#5| |t| |l|) (RETURN (SEQ (PROGN (SPADLET |x| (|postTran| |x|)) (COND ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |@Tuple|)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ISTMP#2| (REVERSE |ISTMP#1|)) (QUOTE T)) (PAIRP |ISTMP#2|) (PROGN (SPADLET |ISTMP#3| (QCAR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (EQ (QCAR |ISTMP#3|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#4| (QCDR |ISTMP#3|)) (AND (PAIRP |ISTMP#4|) (PROGN (SPADLET |y| (QCAR |ISTMP#4|)) (SPADLET |ISTMP#5| (QCDR |ISTMP#4|)) (AND (PAIRP |ISTMP#5|) (EQ (QCDR |ISTMP#5|) NIL) (PROGN (SPADLET |t| (QCAR |ISTMP#5|)) (QUOTE T)))))))) (PROGN (SPADLET |l| (QCDR |ISTMP#2|)) (QUOTE T)) (PROGN (SPADLET |l| (NREVERSE |l|)) (QUOTE T)))) (PROG (#0=#:G166534) (SPADLET #0# (QUOTE T)) (RETURN (DO ((#1=#:G166540 NIL (NULL #0#)) (#2=#:G166541 |l| (CDR #2#)) (|x| NIL)) ((OR #1# (ATOM #2#) (PROGN (SETQ |x| (CAR #2#)) NIL)) #0#) (SEQ (EXIT (SETQ #0# (AND #0# (IDENTP |x|))))))))) (CONS (QUOTE |:|) (CONS (CONS (QUOTE LISTOF) (APPEND |l| (CONS |y| NIL))) (CONS |t| NIL)))) ((QUOTE T) |x|))))))) 
;postDefArgs argl ==
;  null argl => argl
;  argl is [[":",a],:b] =>
;    b => postError
;      ['"   Argument",:bright a,'"of indefinite length must be last"]
;    atom a or a is ['QUOTE,:.] => a
;    postError
;      ['"   Argument",:bright a,'"of indefinite length must be a name"]
;  [first argl,:postDefArgs rest argl]

;;;     ***       |postDefArgs| REDEFINED

(DEFUN |postDefArgs| (|argl|) (PROG (|ISTMP#1| |ISTMP#2| |a| |b|) (RETURN (COND ((NULL |argl|) |argl|) ((AND (PAIRP |argl|) (PROGN (SPADLET |ISTMP#1| (QCAR |argl|)) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |a| (QCAR |ISTMP#2|)) (QUOTE T)))))) (PROGN (SPADLET |b| (QCDR |argl|)) (QUOTE T))) (COND (|b| (|postError| (CONS "   Argument" (APPEND (|bright| |a|) (CONS "of indefinite length must be last" NIL))))) ((OR (ATOM |a|) (AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE QUOTE)))) |a|) ((QUOTE T) (|postError| (CONS "   Argument" (APPEND (|bright| |a|) (CONS "of indefinite length must be a name" NIL))))))) ((QUOTE T) (CONS (CAR |argl|) (|postDefArgs| (CDR |argl|)))))))) 
;postElt (u is [.,a,b]) ==
;  a:= postTran a
;  b is ['Sequence,:.] => [['elt,a,'makeRecord],:postTranList rest b]
;  ['elt,a,postTran b]

;;;     ***       |postElt| REDEFINED

(DEFUN |postElt| (|u|) (PROG (|b| |a|) (RETURN (PROGN (SPADLET |a| (CADR |u|)) (SPADLET |b| (CADDR |u|)) (SPADLET |a| (|postTran| |a|)) (COND ((AND (PAIRP |b|) (EQ (QCAR |b|) (QUOTE |Sequence|))) (CONS (CONS (QUOTE |elt|) (CONS |a| (CONS (QUOTE |makeRecord|) NIL))) (|postTranList| (CDR |b|)))) ((QUOTE T) (CONS (QUOTE |elt|) (CONS |a| (CONS (|postTran| |b|) NIL))))))))) 
;postFlatten(x,op) ==
;  x is [ =op,a,b] => [:postFlatten(a,op),:postFlatten(b,op)]
;  LIST x

;;;     ***       |postFlatten| REDEFINED

(DEFUN |postFlatten| (|x| |op|) (PROG (|ISTMP#1| |a| |ISTMP#2| |b|) (RETURN (COND ((AND (PAIRP |x|) (EQUAL (QCAR |x|) |op|) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |b| (QCAR |ISTMP#2|)) (QUOTE T))))))) (APPEND (|postFlatten| |a| |op|) (|postFlatten| |b| |op|))) ((QUOTE T) (LIST |x|)))))) 
;postForm (u is [op,:argl]) ==
;  x:=
;    atom op =>
;      argl':= postTranList argl
;      op':=
;        true=> op
;        $BOOT => op
;        GET(op,'Led) or GET(op,'Nud) or op = 'IN => op
;        numOfArgs:= (argl' is [['Tuple,:l]] => #l; 1)
;        INTERNL("*",STRINGIMAGE numOfArgs,PNAME op)
;      [op',:argl']
;    op is ['Scripts,:.] => [:postTran op,:postTranList argl]
;    u:= postTranList u
;    if u is [['Tuple,:.],:.] then
;      postError ['"  ",:bright u,
;        '"is illegal because tuples cannot be applied!",'%l,
;          '"   Did you misuse infix dot?"]
;    u
;  x is [.,['Tuple,:y]] => [first x,:y]
;  x

;;;     ***       |postForm| REDEFINED

;postQuote [.,a] == ['QUOTE,a]

;;;     ***       |postQuote| REDEFINED

;(DEFUN |postQuote| (#0=#:G167035) (PROG (|a|) (RETURN (PROGN (SPADLET |a| (CADR #0#)) (CONS (QUOTE QUOTE) (CONS |a| NIL)))))) 
;postSEGMENT ['SEGMENT,a,b] ==
;  key:= [a,'"..",:(b => [b]; nil)]
;  postError ['"   Improper placement of segment",:bright key]

;;;     ***       |postSEGMENT| REDEFINED

(DEFUN |postSEGMENT| (#0=#:G167266) (PROG (|a| |b| |key|) (RETURN (PROGN (SPADLET |a| (CADR #0#)) (SPADLET |b| (CADDR #0#)) (SPADLET |key| (CONS |a| (CONS ".." (COND (|b| (CONS |b| NIL)) ((QUOTE T) NIL))))) (|postError| (CONS "   Improper placement of segment" (|bright| |key|))))))) 
;postCollect [constructOp,:m,x] ==
;  x is [['elt,D,'construct],:y] =>
;    postCollect [['elt,D,'COLLECT],:m,['construct,:y]]
;  itl:= postIteratorList m
;  x:= (x is ['construct,r] => r; x)  --added 84/8/31
;  y:= postTran x
;  finish(constructOp,itl,y) where
;    finish(op,itl,y) ==
;      y is [":",a] => ['REDUCE,'append,0,[op,:itl,a]]
;      y is ['Tuple,:l] =>
;        newBody:=
;          or/[x is [":",y] for x in l] => postMakeCons l
;          or/[x is ['SEGMENT,:.] for x in l] => tuple2List l
;          ['construct,:postTranList l]
;        ['REDUCE,'append,0,[op,:itl,newBody]]
;      [op,:itl,y]

;postIteratorList x ==
;  x is [p,:l] =>
;    (p:= postTran p) is ['IN,y,u] =>
;      u is ["|",a,b] => [['IN,y,postInSeq a],["|",b],:postIteratorList l]
;      [['IN,y,postInSeq u],:postIteratorList l]
;    [p,:postIteratorList l]
;  x

;;;     ***       |postIteratorList| REDEFINED

(DEFUN |postIteratorList| (|x|) (PROG (|l| |p| |y| |ISTMP#3| |u| |ISTMP#1| |a| |ISTMP#2| |b|) (RETURN (COND ((AND (PAIRP |x|) (PROGN (SPADLET |p| (QCAR |x|)) (SPADLET |l| (QCDR |x|)) (QUOTE T))) (COND ((PROGN (SPADLET |ISTMP#1| (SPADLET |p| (|postTran| |p|))) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE IN)) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (PROGN (SPADLET |y| (QCAR |ISTMP#2|)) (SPADLET |ISTMP#3| (QCDR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (EQ (QCDR |ISTMP#3|) NIL) (PROGN (SPADLET |u| (QCAR |ISTMP#3|)) (QUOTE T)))))))) (COND ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |\||)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |b| (QCAR |ISTMP#2|)) (QUOTE T))))))) (CONS (CONS (QUOTE IN) (CONS |y| (CONS (|postInSeq| |a|) NIL))) (CONS (CONS (QUOTE |\||) (CONS |b| NIL)) (|postIteratorList| |l|)))) ((QUOTE T) (CONS (CONS (QUOTE IN) (CONS |y| (CONS (|postInSeq| |u|) NIL))) (|postIteratorList| |l|))))) ((QUOTE T) (CONS |p| (|postIteratorList| |l|))))) ((QUOTE T) |x|))))) 
;postInSeq seq ==
;  seq is ['SEGMENT,p,q] => postTranSegment(p,q)
;  seq is ['Tuple,:l] => tuple2List l
;  postTran seq

;;;     ***       |postInSeq| REDEFINED

(DEFUN |postInSeq| (|seq|) (PROG (|ISTMP#1| |p| |ISTMP#2| |q| |l|) (RETURN (COND ((AND (PAIRP |seq|) (EQ (QCAR |seq|) (QUOTE SEGMENT)) (PROGN (SPADLET |ISTMP#1| (QCDR |seq|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |p| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |q| (QCAR |ISTMP#2|)) (QUOTE T))))))) (|postTranSegment| |p| |q|)) ((AND (PAIRP |seq|) (EQ (QCAR |seq|) (QUOTE |@Tuple|)) (PROGN (SPADLET |l| (QCDR |seq|)) (QUOTE T))) (|tuple2List| |l|)) ((QUOTE T) (|postTran| |seq|)))))) 
;postTranSegment(p,q) == ['SEGMENT,postTran p,(q => postTran q; nil)]

;;;     ***       |postTranSegment| REDEFINED

(DEFUN |postTranSegment| (|p| |q|) (CONS (QUOTE SEGMENT) (CONS (|postTran| |p|) (CONS (COND (|q| (|postTran| |q|)) ((QUOTE T) NIL)) NIL)))) 
;tuple2List l ==
;  l is [a,:l'] =>
;    u:= tuple2List l'
;    a is ['SEGMENT,p,q] =>
;      null u => ['construct,postTranSegment(p,q)]
;      $InteractiveMode and null $BOOT =>
;        ['append,['construct,postTranSegment(p,q)],tuple2List l']
;      ["nconc",['construct,postTranSegment(p,q)],tuple2List l']
;    null u => ['construct,postTran a]
;    ["cons",postTran a,tuple2List l']
;  nil

;;;     ***       |tuple2List| REDEFINED

(DEFUN |tuple2List| (|l|) (PROG (|a| |l'| |u| |ISTMP#1| |p| |ISTMP#2| |q|) (RETURN (COND ((AND (PAIRP |l|) (PROGN (SPADLET |a| (QCAR |l|)) (SPADLET |l'| (QCDR |l|)) (QUOTE T))) (SPADLET |u| (|tuple2List| |l'|)) (COND ((AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE SEGMENT)) (PROGN (SPADLET |ISTMP#1| (QCDR |a|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |p| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |q| (QCAR |ISTMP#2|)) (QUOTE T))))))) (COND ((NULL |u|) (CONS (QUOTE |construct|) (CONS (|postTranSegment| |p| |q|) NIL))) ((AND |$InteractiveMode| (NULL $BOOT)) (CONS (QUOTE |append|) (CONS (CONS (QUOTE |construct|) (CONS (|postTranSegment| |p| |q|) NIL)) (CONS (|tuple2List| |l'|) NIL)))) ((QUOTE T) (CONS (QUOTE |nconc|) (CONS (CONS (QUOTE |construct|) (CONS (|postTranSegment| |p| |q|) NIL)) (CONS (|tuple2List| |l'|) NIL)))))) ((NULL |u|) (CONS (QUOTE |construct|) (CONS (|postTran| |a|) NIL))) ((QUOTE T) (CONS (QUOTE |cons|) (CONS (|postTran| |a|) (CONS (|tuple2List| |l'|) NIL)))))) ((QUOTE T) NIL))))) 
;SEGMENT(a,b) == [i for i in a..b]

;;;     ***       SEGMENT REDEFINED

(DEFUN SEGMENT (|a| |b|) (PROG NIL (RETURN (SEQ (PROG (#0=#:G167597) (SPADLET #0# NIL) (RETURN (DO ((|i| |a| (+ |i| 1))) ((> |i| |b|) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS |i| #0#))))))))))) 
;postFlattenLeft(x,op) ==--
;  x is [ =op,a,b] => [:postFlattenLeft(a,op),b]
;  [x]

;;;     ***       |postFlattenLeft| REDEFINED

(DEFUN |postFlattenLeft| (|x| |op|) (PROG (|ISTMP#1| |a| |ISTMP#2| |b|) (RETURN (COND ((AND (PAIRP |x|) (EQUAL (QCAR |x|) |op|) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |b| (QCAR |ISTMP#2|)) (QUOTE T))))))) (APPEND (|postFlattenLeft| |a| |op|) (CONS |b| NIL))) ((QUOTE T) (CONS |x| NIL)))))) 
;postSequence ['Sequence,:l] == ['(elt $ makeRecord),:postTranList l]

;;;     ***       |postSequence| REDEFINED

(DEFUN |postSequence| (#0=#:G167652) (PROG (|l|) (RETURN (PROGN (SPADLET |l| (CDR #0#)) (CONS (QUOTE (|elt| $ |makeRecord|)) (|postTranList| |l|)))))) 
;--------------------> NEW DEFINITION (see br-saturn.boot.pamphlet)
;killColons x ==
;  atom x => x
;  x is ['Record,:.] => x
;  x is ['Union,:.] => x
;  x is [":",.,y] => killColons y
;  [killColons first x,:killColons rest x]

;;;     ***       |killColons| REDEFINED

(DEFUN |killColons| (|x|) (PROG (|ISTMP#1| |ISTMP#2| |y|) (RETURN (COND ((ATOM |x|) |x|) ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |Record|))) |x|) ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |Union|))) |x|) ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#2|)) (QUOTE T))))))) (|killColons| |y|)) ((QUOTE T) (CONS (|killColons| (CAR |x|)) (|killColons| (CDR |x|)))))))) 
;removeSuperfluousMapping sig1 ==
;  --get rid of this asap
;  sig1 is [x,:y] and x is ['Mapping,:.] => [rest x,:y]
;  sig1

;;;     ***       |removeSuperfluousMapping| REDEFINED

(DEFUN |removeSuperfluousMapping| (|sig1|) (PROG (|x| |y|) (RETURN (COND ((AND (PAIRP |sig1|) (PROGN (SPADLET |x| (QCAR |sig1|)) (SPADLET |y| (QCDR |sig1|)) (QUOTE T)) (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |Mapping|))) (CONS (CDR |x|) |y|)) ((QUOTE T) |sig1|))))) 
;postType typ ==
;  typ is ["->",source,target] =>
;    source="constant" => [LIST postTran target,"constant"]
;    LIST ['Mapping,postTran target,:unTuple postTran source]
;  typ is ["->",target] => LIST ['Mapping,postTran target]
;  LIST postTran typ

;;;     ***       |postType| REDEFINED

(DEFUN |postType| (|typ|) (PROG (|source| |ISTMP#2| |ISTMP#1| |target|) (RETURN (COND ((AND (PAIRP |typ|) (EQ (QCAR |typ|) (QUOTE ->)) (PROGN (SPADLET |ISTMP#1| (QCDR |typ|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |source| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |target| (QCAR |ISTMP#2|)) (QUOTE T))))))) (COND ((BOOT-EQUAL |source| (QUOTE |constant|)) (CONS (LIST (|postTran| |target|)) (CONS (QUOTE |constant|) NIL))) ((QUOTE T) (LIST (CONS (QUOTE |Mapping|) (CONS (|postTran| |target|) (|unTuple| (|postTran| |source|)))))))) ((AND (PAIRP |typ|) (EQ (QCAR |typ|) (QUOTE ->)) (PROGN (SPADLET |ISTMP#1| (QCDR |typ|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |target| (QCAR |ISTMP#1|)) (QUOTE T))))) (LIST (CONS (QUOTE |Mapping|) (CONS (|postTran| |target|) NIL)))) ((QUOTE T) (LIST (|postTran| |typ|))))))) 
;--u is ['Tuple,:l,a] => (--a:= postTran a; ['Tuple,:postTranList rest u])
;    --RDJ: don't understand need for above statement that is commented out
;isPackageType x == not CONTAINED("$",x)

;;;     ***       |isPackageType| REDEFINED

(DEFUN |isPackageType| (|x|) (NULL (CONTAINED (QUOTE $) |x|))) 
;--% APL TRANSFORMATION OF INPUT
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
