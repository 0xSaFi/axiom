\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp modemap.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{chunk}{*}

(IN-PACKAGE "BOOT" )

;-- next definition RPLACs, and hence causes problems.
;-- In ptic., SubResGcd in SparseUnivariatePolynomial is miscompiled
;--mergeModemap(entry:=((mc,:sig),:.),modemapList,e) ==
;--    for (mmtail:= (((mc',:sig'),:.),:.)) in tails modemapList do
;--       mc=mc' or isSuperDomain(mc',mc,e)  =>
;--         RPLACD(mmtail,(first mmtail,: rest mmtail))
;--         RPLACA(mmtail,entry)
;--         entry := nil
;--         return modemapList
;--     if entry then (:modemapList,entry) else modemapList
;
;isSuperDomain(domainForm,domainForm',e) ==
;  isSubset(domainForm',domainForm,e) => true
;  domainForm='Rep and domainForm'="$" => true --regard $ as a subdomain of Rep
;  LASSOC(opOf domainForm',get(domainForm,"SubDomain",e))

(DEFUN |isSuperDomain| (|domainForm| |domainForm'| |e|)
  (COND
    ((|isSubset| |domainForm'| |domainForm| |e|) 'T)
    ((AND (BOOT-EQUAL |domainForm| '|Rep|)
          (BOOT-EQUAL |domainForm'| '$))
     'T)
    ('T
     (LASSOC (|opOf| |domainForm'|)
             (|get| |domainForm| '|SubDomain| |e|)))))

;--substituteForRep(entry is [[mc,:sig],:.],curModemapList) ==
;--  --change 'Rep to "$" unless the resulting signature is already in $
;--  MEMBER(entry':= substitute("$",'Rep,entry),curModemapList) =>
;--    [entry,:curModemapList]
;--  [entry,entry',:curModemapList]
;
;addNewDomain(domain,e) ==
;  augModemapsFromDomain(domain,domain,e)

(DEFUN |addNewDomain| (|domain| |e|)
  (|augModemapsFromDomain| |domain| |domain| |e|))

;augModemapsFromDomain(name,functorForm,e) ==
;  MEMBER(KAR name or name,$DummyFunctorNames) => e
;  name=$Category or isCategoryForm(name,e) => e
;  MEMBER(name,curDomainsInScope:= getDomainsInScope e) => e
;  if u:= GETDATABASE(opOf functorForm,'SUPERDOMAIN) then
;    e:= addNewDomain(first u,e)
;    --need code to handle parameterized SuperDomains
;  if innerDom:= listOrVectorElementMode name then e:= addDomain(innerDom,e)
;  if name is ["Union",:dl] then for d in stripUnionTags dl
;                         repeat e:= addDomain(d,e)
;  augModemapsFromDomain1(name,functorForm,e)

(DEFUN |augModemapsFromDomain| (|name| |functorForm| |e|)
  (PROG (|curDomainsInScope| |u| |innerDom| |dl|)
  (declare (special |$Category| |$DummyFunctorNames|))
    (RETURN
      (SEQ (COND
             ((|member| (OR (KAR |name|) |name|) |$DummyFunctorNames|)
              |e|)
             ((OR (BOOT-EQUAL |name| |$Category|)
                  (|isCategoryForm| |name| |e|))
              |e|)
             ((|member| |name|
                  (SPADLET |curDomainsInScope|
                           (|getDomainsInScope| |e|)))
              |e|)
             ('T
              (COND
                ((SPADLET |u|
                          (GETDATABASE (|opOf| |functorForm|)
                              'SUPERDOMAIN))
                 (SPADLET |e| (|addNewDomain| (CAR |u|) |e|))))
              (COND
                ((SPADLET |innerDom|
                          (|listOrVectorElementMode| |name|))
                 (SPADLET |e| (|addDomain| |innerDom| |e|))))
              (COND
                ((AND (PAIRP |name|) (EQ (QCAR |name|) '|Union|)
                      (PROGN (SPADLET |dl| (QCDR |name|)) 'T))
                 (DO ((G166400 (|stripUnionTags| |dl|)
                          (CDR G166400))
                      (|d| NIL))
                     ((OR (ATOM G166400)
                          (PROGN (SETQ |d| (CAR G166400)) NIL))
                      NIL)
                   (SEQ (EXIT (SPADLET |e| (|addDomain| |d| |e|)))))))
              (|augModemapsFromDomain1| |name| |functorForm| |e|)))))))

;     --see LISPLIB BOOT
;
;substituteCategoryArguments(argl,catform) ==
;  argl:= substitute("$$","$",argl)
;  arglAssoc:= [[INTERNL("#",STRINGIMAGE i),:a] for i in 1.. for a in argl]
;  SUBLIS(arglAssoc,catform)

(DEFUN |substituteCategoryArguments| (|argl| |catform|)
  (PROG (|arglAssoc|)
    (RETURN
      (SEQ (PROGN
             (SPADLET |argl| (MSUBST '$$ '$ |argl|))
             (SPADLET |arglAssoc|
                      (PROG (G166422)
                        (SPADLET G166422 NIL)
                        (RETURN
                          (DO ((|i| 1 (QSADD1 |i|))
                               (G166428 |argl| (CDR G166428))
                               (|a| NIL))
                              ((OR (ATOM G166428)
                                   (PROGN
                                     (SETQ |a| (CAR G166428))
                                     NIL))
                               (NREVERSE0 G166422))
                            (SEQ (EXIT (SETQ G166422
                                        (CONS
                                         (CONS
                                          (INTERNL '|#|
                                           (STRINGIMAGE |i|))
                                          |a|)
                                         G166422))))))))
             (SUBLIS |arglAssoc| |catform|))))))

;addConstructorModemaps(name,form is [functorName,:.],e) ==
;  $InteractiveMode: local:= nil
;  e:= putDomainsInScope(name,e) --frame
;  fn := GET(functorName,"makeFunctionList")
;  [funList,e]:= FUNCALL(fn,name,form,e)
;  for [op,sig,opcode] in funList repeat
;    if opcode is [sel,dc,n] and sel='ELT then
;          nsig := substitute("$$$",name,sig)
;          nsig := substitute('$,"$$$",substitute("$$",'$,nsig))
;          opcode := [sel,dc,nsig]
;    e:= addModemap(op,name,sig,true,opcode,e)
;  e

(DEFUN |addConstructorModemaps| (|name| |form| |e|)
  (PROG (|$InteractiveMode| |functorName| |fn| |LETTMP#1| |funList|
            |op| |sig| |sel| |ISTMP#1| |dc| |ISTMP#2| |n| |nsig|
            |opcode|)
    (DECLARE (SPECIAL |$InteractiveMode|))
    (RETURN
      (SEQ (PROGN
             (SPADLET |functorName| (CAR |form|))
             (SPADLET |$InteractiveMode| NIL)
             (SPADLET |e| (|putDomainsInScope| |name| |e|))
             (SPADLET |fn| (GETL |functorName| '|makeFunctionList|))
             (SPADLET |LETTMP#1| (FUNCALL |fn| |name| |form| |e|))
             (SPADLET |funList| (CAR |LETTMP#1|))
             (SPADLET |e| (CADR |LETTMP#1|))
             (DO ((G166774 |funList| (CDR G166774))
                  (G166732 NIL))
                 ((OR (ATOM G166774)
                      (PROGN (SETQ G166732 (CAR G166774)) NIL)
                      (PROGN
                        (PROGN
                          (SPADLET |op| (CAR G166732))
                          (SPADLET |sig| (CADR G166732))
                          (SPADLET |opcode| (CADDR G166732))
                          G166732)
                        NIL))
                  NIL)
               (SEQ (EXIT (PROGN
                            (COND
                              ((AND (PAIRP |opcode|)
                                    (PROGN
                                      (SPADLET |sel| (QCAR |opcode|))
                                      (SPADLET |ISTMP#1|
                                       (QCDR |opcode|))
                                      (AND (PAIRP |ISTMP#1|)
                                       (PROGN
                                         (SPADLET |dc|
                                          (QCAR |ISTMP#1|))
                                         (SPADLET |ISTMP#2|
                                          (QCDR |ISTMP#1|))
                                         (AND (PAIRP |ISTMP#2|)
                                          (EQ (QCDR |ISTMP#2|) NIL)
                                          (PROGN
                                            (SPADLET |n|
                                             (QCAR |ISTMP#2|))
                                            'T)))))
                                    (BOOT-EQUAL |sel| 'ELT))
                               (SPADLET |nsig|
                                        (MSUBST '$$$ |name| |sig|))
                               (SPADLET |nsig|
                                        (MSUBST '$ '$$$
                                         (MSUBST '$$ '$ |nsig|)))
                               (SPADLET |opcode|
                                        (CONS |sel|
                                         (CONS |dc| (CONS |nsig| NIL))))))
                            (SPADLET |e|
                                     (|addModemap| |op| |name| |sig| 'T
                                      |opcode| |e|))))))
             |e|)))))

;--The way XLAMs work:
;--  ((XLAM ($1 $2 $3) (SETELT $1 0 $3)) X "c" V) ==> (SETELT X 0 V)
;
;getDomainsInScope e ==
;  $insideCapsuleFunctionIfTrue=true => $CapsuleDomainsInScope
;  get("$DomainsInScope","special",e)

(DEFUN |getDomainsInScope| (|e|)
  (declare (special |$CapsuleDomainsInScope| |$insideCapsuleFunctionIfTrue|))
  (COND
    ((BOOT-EQUAL |$insideCapsuleFunctionIfTrue| 'T)
     |$CapsuleDomainsInScope|)
    ('T (|get| '|$DomainsInScope| 'special |e|))))

;putDomainsInScope(x,e) ==
;  l:= getDomainsInScope e
;  if MEMBER(x,l) then SAY("****** Domain: ",x," already in scope")
;  newValue:= [x,:DELETE(x,l)]
;  $insideCapsuleFunctionIfTrue => ($CapsuleDomainsInScope:= newValue; e)
;  put("$DomainsInScope","special",newValue,e)
;

(DEFUN |putDomainsInScope| (|x| |e|)
  (PROG (|l| |newValue|)
  (declare (special |$CapsuleDomainsInScope| |$insideCapsuleFunctionIfTrue|))
    (RETURN
      (PROGN
        (SPADLET |l| (|getDomainsInScope| |e|))
        (COND
          ((|member| |x| |l|)
           (SAY "****** Domain: " |x|
                " already in scope")))
        (SPADLET |newValue| (CONS |x| (|delete| |x| |l|)))
        (COND
          (|$insideCapsuleFunctionIfTrue|
              (SPADLET |$CapsuleDomainsInScope| |newValue|) |e|)
          ('T (|put| '|$DomainsInScope| 'special |newValue| |e|)))))))

\end{chunk}
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
