\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp Makefile}
\author{Timothy Daly}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{Notes}
Notes for understanding this makefile:

IMPORTANT: all source file names in this Makefile must be lowercase
This is for cross-platform compatibility and also makes getting
them into Lisp much easier at the Makefile level.

\section{The Environment}
We define 4 directories for this build. The first three are
the traditional {\bf IN}, which is where the source pamphlets are,
{\bf MID} which is where we will put the compiled intermediates and
{\bf OUT} which is where we will put the binaries.

In this case the {\bf IN} files are usually written in {\bf boot} \cite{2}.
These will be compiled in a {\bf BOOTSYS} image to translate from
{\bf boot} to Common Lisp. Since the Common Lisp code is 
system independent and machine generated code the {\bf MID} directory
is built in the {\bf \$SPAD/int} subtree. See the 
{\bf \$SPAD/Makefile.pamphlet} \cite{1} file for more details.

The Common Lisp code will be compiled from the {\bf MID} directory
into the {\bf OUT} directory. This is system-dependent,
machine-generated code and belongs in the {\bf \$SPAD/obj} subtree.

The dvi files will be generated from the pamphlet files in the
final ship doc/src/ directory. Since they are system independent 
but machine generated and part of the final ship they will exist 
in {\bf \$SPAD/mnt/sys/doc/src/interp}.

<<environment>>=
IN=${SRC}/interp
MID=${INT}/interp
OUT=${OBJ}/${SYS}/interp
DOC=${MNT}/${SYS}/doc/src/interp
BOOK=${MNT}/${SYS}/doc
HELP=${MNT}/${SYS}/doc/spadhelp
BOOKSRC=${SPD}/books/bookvol5.pamphlet

@
<<environment>>=
SPADHELP=\
abbreviations.help assignment.help blocks.help   boot.help      \
browse.help        cd.help         clear.help    clef.help      \
close.help         collection.help compiler.help copyright.help \
display.help       edit.help       fin.help      for.help       \
frame.help         help.help       history.help  if.help        \
include.help       iterate.help    leave.help    library.help   \
lisp.help          load.help       ltrace.help   parallel.help  \
pquit.help         quit.help       read.help     repeat.help    \
savesystem.help    set.help        show.help     spool.help     \
suchthat.help      summary.help    synonym.help  syntax.help    \
system.help        trace.help      undo.help     what.help      \
while.help with.help
@

This creates all of the help files in the SPADHELP list from the
interpreter book (volume 5).
<<spadhelp>>=
spadhelp:
	@echo 9 making ${HELP} files from ${BOOKSRC}
	@(mkdir -p ${HELP} ; \
          cd ${HELP} ; \
          for i in ${SPADHELP} ; do \
            ${TANGLE} -R"$$i" ${BOOKSRC} >$$i ; \
          done ; \
          cat ${INT}/doc/help.helplist >>help.help ; \
          ls *.help >spadhelp.files )

@

In order to minimize the size of the Axiom image at load time
we put some of the compiled files into a separate directory
that will be autoloaded on demand. This directory of code
will be shipped with the final system and so it belongs in
the {\bf \$SPAD/mnt} subtree.
<<environment>>=
AUTO=${MNT}/${SYS}/autoload

@

We need a raw lisp image that we can use as a base to construct
the other images. This is called {\bf LISPSYS} and is 
system-dependent and machine-generated.
It belongs in the {\bf \$SPAD/obj} subtree.
<<environment>>=
LISPSYS= ${OBJ}/${SYS}/bin/lisp

@

Most of the interpreter is written in {\bf boot} \cite{2}.
Thus we need a program to translate {\bf boot} to Common
Lisp. This is called the {\bf BOOTSYS} image (because the
translator is written in {\bf boot} and needs to translate
itself to bootstrap the system). This image is assumed to
have been built by a previous step in the make process.
<<environment>>=
BOOTSYS= ${OBJ}/${SYS}/bin/bootsys    

@

Some of the Common Lisp code we compile uses macros which
are assumed to be available at compile time. The {\bf DEPSYS}
image is created to contain the compile time environment
and saved. We pipe compile commands into this environment
to compile from Common Lisp to machine dependent code.

<<environment>>=
DEPSYS=	${OBJ}/${SYS}/bin/depsys

@
The {\bf DEP} variable contains the list of files that
will be loaded into {\bf DEPSYS}. Notice that these files
are loaded in interpreted form. We are not concerned about
the compile time performance so we can use interpreted code.
We do, however, care about the macros as these will be
expanded in later compiles. All macros are assumed to be
in this list of files.
<<environment>>=
DEP= ${MID}/vmlisp.lisp    \
     ${MID}/foam_l.lisp \
     ${MID}/axext_l.lisp

@

Once we've compile all of the Common Lisp files we fire up
a clean lisp image called {\bf LOADSYS}, load all of the
final executable code and save it out as {\bf SAVESYS}.
The {\bf SAVESYS} image is copied to the [[${MNT}/${SYS}/bin]]
subdirectory and becomes the axiom executable image.
<<environment>>=
LOADSYS= ${OBJ}/${SYS}/bin/lisp
SAVESYS= ${OBJ}/${SYS}/bin/interpsys
AXIOMSYS= ${MNT}/${SYS}/bin/AXIOMsys

@
Occasionally we need to really get into the system internals.
The best way to do this is to run almost all of the lisp code
interpreted rather than compiled (note that cfuns.lisp and sockio.lisp
still need to be loaded in compiled form as they depend on the 
loader to link with lisp internals). This image is nothing more
than a load of the file src/interp/debugsys.lisp.pamphlet. If
you need to make test modifications you can add code to that
file and it will show up here.
<<environment>>=
DEBUGSYS=${OBJ}/${SYS}/bin/debugsys

@

These are the files that need to be compiled (in {\bf BOOTSYS}),
loaded into a clean lisp image ({\bf LOADSYS}) and saved as
a runnable Axiom interpreter ({\bf SAVESYS}) usually named
{\bf interpsys}. Most of these files
are translated from {\bf boot} to Common Lisp and then 
compiled. There are two exceptions, {\bf bootfuns.lisp}
and {\bf setq.lisp}. The {\bf bootfuns.lisp} \cite{3} file
contains forward references for {\bf boot} code. The {\bf setq.lisp}
file contains constant initialization code which gains nothing
by being compiled.

The file http.lisp contains code to enable browser-based hyperdoc
and graphics.
<<environment>>=
OBJS= ${OUT}/vmlisp.${O}      \
      ${OUT}/astr.${O}        \
      ${OUT}/alql.${O}        ${OUT}/buildom.${O} \
      ${OUT}/cattable.${O}    \
      ${OUT}/cformat.${O}     ${OUT}/cfuns.${O} \
      ${OUT}/clam.${O}        ${OUT}/clammed.${O} \
      ${OUT}/compat.${O}      ${OUT}/compress.${O} \
      ${OUT}/cparse.${O}      ${OUT}/cstream.${O} \
      ${OUT}/database.${O} \
      ${OUT}/dq.${O}  \
      ${OUT}/fname.${O}       ${OUT}/format.${O} \
      ${OUT}/g-boot.${O}      ${OUT}/g-cndata.${O} \
      ${OUT}/g-error.${O}     ${OUT}/g-opt.${O} \
      ${OUT}/g-timer.${O}     ${OUT}/g-util.${O} \
      ${OUT}/http.${O} \
      ${OUT}/hypertex.${O}    ${OUT}/i-analy.${O} \
      ${OUT}/i-code.${O}      ${OUT}/i-coerce.${O} \
      ${OUT}/i-coerfn.${O}    ${OUT}/i-eval.${O} \
      ${OUT}/i-funsel.${O}    ${OUT}/bookvol5.${O} \
      ${OUT}/bookvol9.${O} \
      ${OUT}/i-intern.${O}    ${OUT}/i-map.${O} \
      ${OUT}/i-output.${O}    ${OUT}/i-resolv.${O} \
      ${OUT}/i-spec1.${O}    \
      ${OUT}/i-spec2.${O}     ${OUT}/i-syscmd.${O} \
      ${OUT}/i-toplev.${O}    ${OUT}/i-util.${O} \
      ${OUT}/incl.${O}        ${OUT}/int-top.${O} \
      ${OUT}/intfile.${O}    \
      ${OUT}/lisplib.${O}     ${OUT}/macex.${O} \
      ${OUT}/match.${O}    \
      ${OUT}/monitor.${O}     ${OUT}/msg.${O}  \
      ${OUT}/msgdb.${O}       ${OUT}/nci.${O}  \
      ${OUT}/newaux.${O}      ${OUT}/newfort.${O} \
      ${OUT}/nrunfast.${O} \
      ${OUT}/nrungo.${O}      ${OUT}/nrunopt.${O} \
      ${OUT}/nruntime.${O}    ${OUT}/osyscmd.${O} \
      ${OUT}/packtran.${O}    ${OUT}/pathname.${O} \
      ${OUT}/pf2sex.${O}      ${OUT}/pile.${O} \
      ${OUT}/posit.${O}       \
      ${OUT}/ptrees.${O}      ${OUT}/ptrop.${O} \
      ${OUT}/record.${O}      ${OUT}/regress.${O} \
      ${OUT}/rulesets.${O} \
      ${OUT}/scan.${O}        ${OUT}/serror.${O} \
      ${OUT}/server.${O}    \
      ${OUT}/sfsfun-l.${O}    ${OUT}/sfsfun.${O} \
      ${OUT}/simpbool.${O}    ${OUT}/slam.${O} \
      ${OUT}/sockio.${O}      \
      ${OUT}/template.${O}    ${OUT}/termrw.${O} \
      ${OUT}/daase.${O}   \
      ${OUT}/fortcall.${O} \
      ${OUT}/parsing.${O} ${OUT}/fnewmeta.${O} \
      ${OUT}/postprop.${LISP}	\
      ${OUT}/apply.${O}	      ${OUT}/c-doc.${O}    \
      ${OUT}/c-util.${O}      ${OUT}/profile.${O}  \
      ${OUT}/category.${O}    ${OUT}/compiler.${O} \
      ${OUT}/define.${O}      ${OUT}/functor.${O}  \
      ${OUT}/info.${O}        ${OUT}/iterator.${O} \
      ${OUT}/modemap.${O}     ${OUT}/nruncomp.${O} \
      ${OUT}/package.${O}     ${OUT}/htcheck.${O}


@

Before we save the {\bf SAVESYS} image we need to run some
initialization code. These files perform initialization
for various parts of the system. The {\bf patches.lisp} \cite{5}
file contains last-minute changes to various functions and
constants.
<<environment>>=
INOBJS=	${OUT}/varini.${O}	${OUT}/parini.${O}	\
	${OUT}/intint.${O}	\
        ${OUT}/interop.${O}     ${OUT}/patches.${O}

@

Certain functions do not need to be in the running system.
If the running image never calls the compiler or does not
use the hypertex browser we will never call the functions
in these files. The code that calls these functions in the
running system will autoload the appropriate files the
first time they are called. Loading the files overwrites
the autoload function call and re-calls the function. 
Any subsequent calls will run the compiled code.

The {\bf OPOBJS} list contains files from the old parser. The use of
``old'' is something of a subtle concept as there were several
generations of ``old'' and all meaning of the term is lost.

<<environment>>=
# These are autloaded old parser files
OPOBJS=	
@

The {\bf OCOBJS} list contains files from the old compiler. Again,
``old'' is meaningless. These files should probably be autoloaded.
<<environment>>=
OCOBJS=	
@

The {\bf BROBJS} list contains files only used by the hypertex
browser. These files should probably be autoloaded.
<<environment>>=
BROBJS=	${AUTO}/bc-matrix.${O}				\
	${AUTO}/ht-util.${O}	\
	${AUTO}/br-con.${O}	\
	${AUTO}/topics.${O}     

@
The {\bf TRANOBJS} list contains files only used by the {\bf boot}
to Common Lisp translator and are probably never used by anyone
but the developers. These files should probably be autoloaded.
<<environment>>=
TRANOBJS= ${AUTO}/wi1.${O} ${AUTO}/wi2.${O} ${AUTO}/pspad1.${O} \
	  ${AUTO}/pspad2.${O} ${AUTO}/mark.${O} ${AUTO}/nspadaux.${O} 
	  
@

The {\bf NAGBROBJS} list contains files used to access the 
Numerical Algorithms Group (NAG) fortran libraries. 
These files should probably be autoloaded.
Note that [[${AUTO}/nag-e02a.${O}]] is not included in this
list as it is a subset of [[${AUTO}/nag-e02.${O}]].
<<environment>>=
NAGBROBJS= ${AUTO}/nag-c02.${O}   ${AUTO}/nag-c05.${O} \
           ${AUTO}/nag-c06.${O}   ${AUTO}/nag-d01.${O} \
           ${AUTO}/nag-d02.${O}   ${AUTO}/nag-d03.${O} \
           ${AUTO}/nag-e01.${O}   ${AUTO}/nag-e02.${O} \
           ${AUTO}/nag-e04.${O}   ${AUTO}/nag-f01.${O} \
           ${AUTO}/nag-f02.${O}   ${AUTO}/nag-f04.${O} \
           ${AUTO}/nag-f07.${O}   ${AUTO}/nag-s.${O} 

@
The {\bf ASCOMP} list contains files used by the {\bf Aldor}
\cite{5} compiler. These files should probably be autoloaded.
<<environment>>=
ASCOMP= ${OUT}/hashcode.${O} ${OUT}/as.${O} \
	${OUT}/foam_l.${O} ${OUT}/axext_l.${O}

@
The {\bf ASAUTO} list contains files used by the {\bf Aldor}
\cite{5} compiler. These files are autoloaded as needed.
<<environment>>=
ASAUTO= ${AUTO}/ax.${O}

@

Axiom versions are given as a string of the form:
"Sunday September 21, 2003 at 20:38:05 "
which describe the day, date, and time of the build.
This is used for reporting bugs. It is only partially useful
in identifying which source code was used. Ideally we could create
a tar file of all of the date/time stamps of all of the source files
and use the MD5 hash of that file as the version stamp. Ultimately
though, this would be chasing the elusive "perfect information" idea.

A new variable [[boot::*build-version*]] is set and used by the
{\tt yearweek} function to display the version number of the Axiom build.
This information is set by hand in the top level Makefile.
<<environment>>=
TIMESTAMP=${MNT}/${SYS}/timestamp
YEARWEEK=(progn (setq timestamp "${TIMESTAMP}") \
                (setq boot::*build-version* "${VERSION}") \
                (yearweek))

@
The {\bf .PRECIOUS} setting will keep make from deleting these
images if the build is stopped. Since once they are built they
are likely to be useable we don't need to redo the work if they
exist.
<<environment>>=

.PRECIOUS:	${BOOTSYS}
.PRECIOUS:	${DEPSYS}
.PRECIOUS:	${SAVESYS}
.PRECIOUS:	${AXIOMSYS}

@
\section{Proclaim optimization}
GCL, and possibly other common lisps, can generate much better
code if the function argument types and return values are proclaimed.

In theory what we should do is scan all of the functions in the system
and create a file of proclaim definitions. These proclaim definitions
should be loaded into the image before we do any compiles so they can
allow the compiler to optimize function calling.

GCL has an approximation to this scanning which we use here. 

The first step is to build a version of GCL that includes [[gcl_collectfn]].
This file contains code that enhances the lisp compiler and creates a
hash table of structs. Each struct in the hash table describes information
that about the types of the function being compiled and the types of its
arguments. At the end of the compile-file this hash table is written out
to a ".fn" file. 

The second step is to build axiom images (depsys, interpsys, AXIOMsys)
which contain the [[gcl_collectfn]] code.

The third step is to build the system. This generates a .fn file for 
each lisp file that gets compiled.

The fourth step is to build the proclaims.lisp files. There is one
proclaims.lisp file for 
boot (boot-proclaims.lisp), 
interp (interp-proclaims.lisp), and 
algebra (algebra-proclaims.lisp).

To build the proclaims file (e.g. for interp) we:
\begin{verbatim}
(a) cd to obj/linux/interp
(b) (yourpath)/axiom/obj/linux/bin/lisp
(c) (load "sys-pkg.lsp") 
(d) (mapcar #'load (directory "*.fn"))
(e) (with-open-file 
     (out "interp-proclaims.lisp" :direction :output) 
      (compiler::make-proclaims out))
\end{verbatim}
Note that step (c) is only used for interp, not for boot.

The fifth step is to copy the newly constructed proclaims file back
into the src/interp diretory (or boot, algebra).

In order for this information to be used during compiles we define
<<environment>>=
PROCLAIMS=(progn (load "${OUT}/sys-pkg.lsp") \
                 (load "${IN}/interp-proclaims.lisp"))

@

\section{The warm.data file}
This is a file of commands that will be loaded into interpsys
at the last minute. It execute functions that will likely be
used in a running system so all of the required routines will
be in the lisp image thus minimizing their startup time.
<<warm.data.stanza>>=
${INT}/algebra/warm.data: 
	@ echo 2 building warm.data
	@ ${TANGLE} -Rwarm.data ${IN}/Makefile.pamphlet >${INT}/algebra/warm.data

@
<<warm.data>>=
(in-package 'boot)
(setq |$topicHash| (make-hash-table))
(setf (gethash '|basic| |$topicHash|) 2)
(setf (gethash '|algebraic| |$topicHash|) 4)
(setf (gethash '|miscellaneous| |$topicHash|) 13)
(setf (gethash '|extraction| |$topicHash|) 6)
(setf (gethash '|conversion| |$topicHash|) 7)
(setf (gethash '|hidden| |$topicHash|) 3)
(setf (gethash '|extended| |$topicHash|) 1)
(setf (gethash '|destructive| |$topicHash|) 5)
(setf (gethash '|transformation| |$topicHash|) 10)
(setf (gethash '|hyperbolic| |$topicHash|) 12)
(setf (gethash '|construct| |$topicHash|) 9)
(setf (gethash '|predicate| |$topicHash|) 8)
(setf (gethash '|trignometric| |$topicHash|) 11)

@
\section{Building DEPSYS}
The depsys image proceeds all else. it is the compile-time environment
for all interpreter code. 

The ``:oldboot'' symbol is pushed on the features list 
because there is a function
in util.lisp that emulates the new boot parser command BOOTTOCL. since
we eventually plan to move to the new boot parser this function (and
the push) should disappear.

The load of postpar and parse (without extensions) allows the 
\verb+.${LISP}+
form to be loaded in a virgin system. However, if depsys is recreated then
the compiled form will get loaded.

This file contained the only mention of the AKCLDIR variable which
gives the path to the version of AKCL. Now that the system is running
on GCL this variable has been renamed to GCLDIR. This cannot be eliminated
entirely because the system uses this variable to look up a file 
called collectfn.lsp which is part of the GCL distribution. This
file lookup is in conditional lisp code so other lisps will not 
see the file load. The collectfn.lsp code is used by GCL to generate
the ``.fn'' files which are used to optimize function calling.

\subsection{save depsys image}
Once the appropriate commands are in the [[${OUT}/makedep.lisp]] file
we can load the file into a fresh image and save it. At least that's
how it used to work. In freebsd we cannot do this so we have to use
a much more complicated procedure.
This code used to read:
\begin{verbatim}
<<save depsys image>>=
	@ (cd ${MNT}/${SYS}/bin ; \
	   echo '(progn (load "${OUT}/makedep.lisp")' \
                '(spad-save "${DEPSYS}"))' | ${LISPSYS})
@
\end{verbatim}

Now game is much more difficult. 
\begin{verbatim}

 '(progn \

\end{verbatim}

[[si::*collect-binary-modules*]] instructs GCL to build a list of 
binary object modules loaded into the current session with (load ...)
The list will be stored in [[si::*binary-modules*]].
\begin{verbatim}

	       (setq si::*collect-binary-modules* t) \
	       (load "${OUT}/makedep.lisp") \

\end{verbatim}

[[compiler::link]] is a lisp interface to the ``ld'' C-based system linker.
The first argumet is a list of [[.o]] binary object modules to link into a
fresh gcl image. The second argument is the name of the new output
image.  The third argument is a string containing an initialization
command to run in the new image to reinitialize the heap.  The fourth
argument is a list of external C libraries, either static or dynamic,
that one wishes to link into the fresh image.  The last argument is a
flag which indicates whether GCL should initialize all of the freshly
linked in new lisp modules, or whether it should transparently
redirect load calls in the new image to initialization calls for the
already linked in module.

Some lisp systems, such as acl2, have a complex heap initialization,
in which load calls must be interspersed with other form evaluation
comprising the logic of the heap construction.  Others, such as
maxima, have no such complex initialization sequence.
\begin{verbatim}
  (compiler::link \
\end{verbatim}
[[si::*binary-modules*]] here has the list of compiled lisp binary module
.o files loaded by makedep.lsp above.
\begin{verbatim}
   (remove-duplicates si::*binary-modules* \
                      :test (quote equal)) \
\end{verbatim}

The name of the output image.
\begin{verbatim}
   "$(DEPSYS)" \
\end{verbatim}

This will be run in the newly linked sub-image.
\begin{verbatim}
    (format nil "\
\end{verbatim}

Collect loaded binary modules again to make sure that there are none,
as all should be already linked in via ld.  For error checking
purposes.
\begin{verbatim}
     (setq si::*collect-binary-modules* t) \
\end{verbatim}

We need to find [[gcl_collectfn.lsp]], so set the [[*load-path*]], and make
sure the source, not the binary, form is loaded here, as we're only
using this entire sequence on machines which cannot load binary object
modules and preserve them in saved images.
\begin{verbatim}
     (let ((si::*load-path* (cons ~S si::*load-path*))\
           (si::*load-types* ~S))\
\end{verbatim}

Turn on function analyzation and autoload thereby [[gcl_collectfn.lsp]].
\begin{verbatim}
      (compiler::emit-fn t))\
\end{verbatim}

Load the heap creation sequence again in the fresh new image, this
time transparently redirecting all calls to load of binary modules
invoked thereby into initialization calls for the already linkned in
module.

Load has code in it to recognize when a module is already linked in,
and to forgo in this case the actual load and replace with a mere
initialization call instead.
\begin{verbatim}
      (load \"$(OUT)/makedep.lisp\")\
      (gbc t)\
\end{verbatim}

It is an error to load a binary module. Calling load will not
reload them but only run initialization.
Throw an error if we've actually loaded any binary modules.
\begin{verbatim}
     (when si::*binary-modules* \
       (error si::*binary-modules*))\
\end{verbatim}

Unset the binary module collection flags.
\begin{verbatim}
    (setq si::collect-binary-modules* nil \xo
          si::*binary-modules* nil)\
    (gbc t)\
\end{verbatim}

Turn on SGC (Stratified Garbage Collection) in the final image.  This
is a optional gbc algorithm which is suitable for images which will
not grow much further.  It marks a large fraction of the heap
read-only, eliminating such pages from the time-consuming gbc
processing.  When writes are actually made to such pages, a segfault
is triggered which is handled by a function which remarks the pages
read-write and continues.
\begin{verbatim}
   (when (fboundp (quote si::sgc-on)) (si::sgc-on t))\
\end{verbatim}

This is a flag which instructs the GCL compiler to make unique
initialzation function C names.  This is necessary when using ld, as
all function names must be unique.
\begin{verbatim}
   (setq compiler::*default-system-p* t)\
\end{verbatim}
si::*system-directory* goes into the *load-path*, and .lsp in the *load-types*.
\begin{verbatim}
 " si::*system-directory* (quote (list ".lsp")))\
\end{verbatim}
No C libraries to link in here.
\begin{verbatim}
   "" \
\end{verbatim}

Do not run the initialization code for the newly linked in lisp
modules ``by hand'', but rather rely on the transparent load redirection
described above to initialize at the proper moment in the heap
initialization sequence.
\begin{verbatim}
     nil))' | $(LISPSYS))
\end{verbatim}

The [[save depsys image]] was supposed to read:
\begin{verbatim}
 @ (cd ${OBJ}/${SYS}/bin ; \
   echo '(progn' \
    '(setq si::*collect-binary-modules* t)' \
    '(load "${OUT}/makedep.lisp")' \
    '(compiler::link' \
      '(remove-duplicates si::*binary-modules*' \
                        ':test (quote equal))' \
      '"$(DEPSYS)"' \
      '(format nil' \
	 '"(setq si::*collect-binary-modules* t)' \
	  '(let ((si::*load-path* (cons ~S si::*load-path*))' \
	          '(si::*load-types* ~S))' \
	  	  '(compiler::emit-fn t))' \
	  '(load \"$(OUT)/makedep.lisp\")' \
	  '(gbc t)' \
	  '(when si::*binary-modules*' \
                '(error si::*binary-modules*))' \
	  '(setq si::collect-binary-modules* nil' \
                'si::*binary-modules* nil)' \
	  '(gbc t)' \
	  '(when (fboundp (quote si::sgc-on)) (si::sgc-on t))' \
	  '(setq compiler::*default-system-p* t)"' \
         'si::*system-directory* (quote (list ".lsp")))'\
       '""' \
       'nil))' | $(LISPSYS))
\end{verbatim}

This scheme does not work. It fails during loading with multiple messages
of the form:
\begin{verbatim}
/home/axiom33/obj/linux/interp/parse.o(.text+0x5660): 
 In function `init_code':
  : multiple definition of `init_code'
/home/axiom33/obj/linux/interp/postpar.o(.text+0x4e78): 
  first defined here
\end{verbatim}
<<depsys>>=
${DEPSYS}:	${DEP} ${OUT}/sys-pkg.${LISP} ${OUT}/nocompil.${LISP} \
	        ${OUT}/bookvol5.${LISP} ${OUT}/util.${LISP} \
	        ${OUT}/parsing.${LISP} ${OUT}/fnewmeta.${LISP} \
	        ${OUT}/newaux.${LISP} \
	        ${OUT}/postprop.lisp \
	        ${OUT}/g-boot.lisp ${OUT}/c-util.lisp \
	        ${OUT}/g-util.lisp \
	        ${OUT}/clam.lisp \
	        ${OUT}/slam.lisp ${LOADSYS}
	@ echo 3 making ${DEPSYS} 
	@ echo '${PROCLAIMS}' > ${OUT}/makedep.lisp
	@ echo '(push :oldboot *features*)' >>${OUT}/makedep.lisp
	@ echo '(load "${OUT}/nocompil")' >> ${OUT}/makedep.lisp
	@ echo '(load "${OUT}/bookvol5")' >> ${OUT}/makedep.lisp
	@ echo '(load "${OUT}/util")' >> ${OUT}/makedep.lisp
	@ echo '(in-package "BOOT")' >> ${OUT}/makedep.lisp
	@ echo '(build-depsys (quote ($(patsubst %, "%", ${DEP})))' \
          '"${SPAD}" "${GCLDIR}" "${SRC}" "${INT}" "${OBJ}" "${MNT}"' \
          '"${SYS}")' >> ${OUT}/makedep.lisp
	@ echo '(unless (probe-file "${OUT}/parsing.${O}")' \
          '(compile-file "${OUT}/parsing.${LISP}"' \
          ':output-file "${OUT}/parsing.${O}"))' >> ${OUT}/makedep.lisp
	@ echo '(load "${OUT}/parsing")' >> ${OUT}/makedep.lisp
	@ echo '(unless (probe-file "${OUT}/fnewmeta.${O}")' \
          '(compile-file "${OUT}/fnewmeta.${LISP}"' \
          ':output-file "${OUT}/fnewmeta.${O}"))' >> ${OUT}/makedep.lisp
	@ echo '(load "${OUT}/fnewmeta")' >> ${OUT}/makedep.lisp
	@ echo '(unless (probe-file "${OUT}/newaux.${O}")' \
          '(compile-file "${OUT}/newaux.${LISP}"' \
          ':output-file "${OUT}/newaux.${O}"))' >> ${OUT}/makedep.lisp
	@ echo '(load "${OUT}/newaux")' >> ${OUT}/makedep.lisp
	@ echo '(unless (probe-file "${OUT}/postprop.${O}")' \
          '(compile-file "${OUT}/postprop.lisp"' \
          ':output-file "${OUT}/postprop.${O}"))' >> ${OUT}/makedep.lisp
	@ echo '(load "${OUT}/postprop")' >> ${OUT}/makedep.lisp
	@ echo '(unless (probe-file "${OUT}/clam.${O}")' \
          '(compile-file "${OUT}/clam.lisp"' \
          ':output-file "${OUT}/clam.${O}"))' >> ${OUT}/makedep.lisp
	@ echo '(load "${OUT}/clam")' >> ${OUT}/makedep.lisp
	@ echo '(unless (probe-file "${OUT}/slam.${O}")' \
          '(compile-file "${OUT}/slam.lisp"' \
          ':output-file "${OUT}/slam.${O}"))' >> ${OUT}/makedep.lisp
	@ echo '(load "${OUT}/slam")' >> ${OUT}/makedep.lisp
	@ echo '(unless (probe-file "${OUT}/g-boot.${O}")' \
          '(compile-file "${OUT}/g-boot.lisp"' \
          ':output-file "${OUT}/g-boot.${O}"))' >> ${OUT}/makedep.lisp
	@ echo '(load "${OUT}/g-boot")' >> ${OUT}/makedep.lisp
	@ echo '(unless (probe-file "${OUT}/c-util.${O}")' \
          '(compile-file "${OUT}/c-util.lisp"' \
          ':output-file "${OUT}/c-util.${O}"))' >> ${OUT}/makedep.lisp
	@ echo '(load "${OUT}/c-util")' >> ${OUT}/makedep.lisp
	@ echo '(unless (probe-file "${OUT}/g-util.${O}")' \
          '(compile-file "${OUT}/g-util.lisp"' \
          ':output-file "${OUT}/g-util.${O}"))' >> ${OUT}/makedep.lisp
	@ echo '(load "${OUT}/g-util")' >> ${OUT}/makedep.lisp
<<save depsys image>>
	@ echo 4 ${DEPSYS} created

@
\section{Building SAVESYS and AXIOMSYS}
GCL likes to tell you when it has replaced a function call by a 
tail-recursive call. This happens when the last form in a function
is a call to the same function. In general, we don't care so we set
compiler::*suppress-compiler-notes* to true in order to reduce the noise.
<<savesys>>=
${SAVESYS}:	${DEPSYS} ${OBJS} ${OUT}/bookvol5.${O} ${OUT}/util.${O} \
                ${OUT}/nocompil.${LISP} ${OUT}/sys-pkg.${LISP} \
	        ${OUTINTERP} ${BROBJS} ${OUT}/obey.${O} \
		${OUT}/database.date ${INOBJS} ${ASCOMP} ${ASAUTO} \
		${NAGBROBJS} ${TRANOBJS} \
	        ${LOADSYS} \
		${MNT}/${SYS}/algebra/exposed.${O} \
		${SRC}/doc/msgs/s2-us.msgs \
	        ${INT}/algebra/warm.data
	@ echo 5 invoking make in `pwd` with parms:
	@ echo SYS= ${SYS} 
	@ echo LSP= ${LSP} 
	@ echo PART= ${PART} 
	@ echo SPAD= ${SPAD} 
	@ echo SRC= ${SRC} 
	@ echo INT= ${INT}
	@ echo MID= ${MID} 
	@ echo OUT= ${OUT}
	@ echo OBJ= ${OBJ} 
	@ echo MNT= ${MNT} 
	@ echo O=${O} LISP=${LISP} BYE=${BYE}
	@ cp -p ${OUT}/*.fn ${MID}
	@ cp -p ${SRC}/doc/msgs/s2-us.msgs ${SPAD}/doc/msgs
#	@ cp -p ${SRC}/doc/msgs/co-eng.msgs ${SPAD}/doc/msgs
	@ echo '${PROCLAIMS}' > ${OUT}/makeint.lisp
	@ echo '(load "${OUT}/nocompil")' >> ${OUT}/makeint.lisp
	@ echo '(load "${OUT}/bookvol5")' >> ${OUT}/makeint.lisp
	@ echo '(load "${OUT}/util")' >> ${OUT}/makeint.lisp
	@ echo '(in-package "BOOT")' >> ${OUT}/makeint.lisp
	@ touch ${TIMESTAMP}
	@ echo '${YEARWEEK}' >> ${OUT}/makeint.lisp
	@ echo '(build-interpsys (append' \
          '(quote ($(patsubst %, "%", ${OBJS})))'  \
          '(quote ($(patsubst %, "%", ${ASCOMP})))'  \
          '(quote ($(patsubst %, "%", ${INOBJS}))))' \
          nil \
          nil \
          '(quote ($(patsubst %, "%", ${BROBJS})))'  \
          '(quote ($(patsubst %, "%", ${TRANOBJS})))'  \
          '(quote ($(patsubst %, "%", ${NAGBROBJS})))'  \
          '(quote ($(patsubst %, "%", ${ASAUTO})))'  \
          '"${SPAD}"  "${LSP}" "${SRC}" "${INT}"' \
          '"${OBJ}" "${MNT}" "${SYS}")' >> ${OUT}/makeint.lisp
	@ echo '(in-package "SCRATCHPAD-COMPILER")' >> ${OUT}/makeint.lisp
#	@ echo '(|shoeInternFile| "${MNT}/${SYS}/doc/msgs/co-eng.msgs")' \
#                >> ${OUT}/makeint.lisp
	@ echo '(boot::set-restart-hook)' >> ${OUT}/makeint.lisp
	@ echo '(in-package "BOOT")' >> ${OUT}/makeint.lisp
	@ echo '(load "${INT}/algebra/warm.data")' >> ${OUT}/makeint.lisp
	@ echo '(|clearClams|)' >> ${OUT}/makeint.lisp
	@ echo '(load "${OUT}/obey")' >> ${OUT}/makeint.lisp
#	@ echo '#+:akcl (si::multiply-bignum-stack 10)' >> ${OUT}/makeint.lisp
	@ echo '#+:akcl (setq compiler::*suppress-compiler-notes* t)' \
                >> ${OUT}/makeint.lisp
	@ echo '#+:akcl (si::gbc-time 0)' >> ${OUT}/makeint.lisp
	@ echo '#+:akcl (setq si::*system-directory* "${SPAD}/bin/")' \
               >> ${OUT}/makeint.lisp
	@ (cd ${OBJ}/${SYS}/bin ; \
	  echo '(progn (gbc t) (load "${OUT}/makeint.lisp")' \
                 '(gbc t) (user::spad-save "${SAVESYS}"))' | ${LISPSYS} )
	@ echo 6 ${SAVESYS} created
	@ cp ${SAVESYS} ${AXIOMSYS}
	@ echo 6a ${AXIOMSYS} created

@

\section{Building debugsys}
Note that we assume you've already built interpsys so all of the
files are known to exist and be up to date. We don't list any of
the preconditions here. 
<<debugsys>>=
${DEBUGSYS}: ${MID}/debugsys.lisp
	@ echo 7 building debugsys
	@ (cd ${OBJ}/${SYS}/bin ; \
	  echo '(progn (gbc t) (load "${MID}/debugsys.lisp")' \
                 '(user::spad-save "${DEBUGSYS}"))' | ${LISPSYS} )
	@ echo 8 ${DEBUGSYS} created

@

\section{The Interpreter files}

<<apply.o (OUT from MID)>>=
${OUT}/apply.${O}: ${MID}/apply.lisp 
	@ echo 10 making ${OUT}/apply.${O} from ${MID}/apply.lisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/apply.lisp"' \
             ':output-file "${OUT}/apply.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/apply.lisp"' \
             ':output-file "${OUT}/apply.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<apply.lisp (MID from IN)>>=
${MID}/apply.lisp: ${IN}/apply.lisp.pamphlet
	@ echo 11 making ${MID}/apply.lisp from ${IN}/apply.lisp.pamphlet
	@( cd ${MID} ; \
	   ${TANGLE} ${IN}/apply.lisp.pamphlet >apply.lisp )

@

\subsection{cfuns.lisp \cite{10}}
<<cfuns.o (OUT from MID)>>=
${OUT}/cfuns.${O}: ${MID}/cfuns.lisp
	@ echo 24 making ${OUT}/cfuns.${O} from ${MID}/cfuns.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/cfuns.lisp"' \
              ':output-file "${OUT}/cfuns.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/cfuns.lisp"' \
              ':output-file "${OUT}/cfuns.${O}") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi )

@
<<cfuns.lisp (MID from IN)>>=
${MID}/cfuns.lisp: ${IN}/cfuns.lisp.pamphlet
	@ echo 25 making ${MID}/cfuns.lisp from ${IN}/cfuns.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/cfuns.lisp.pamphlet >cfuns.lisp )

@

\subsection{construc.lisp \cite{12}}
<<construc.o (OUT from MID)>>=
${OUT}/construc.${O}: ${MID}/construc.lisp
	@ echo 30 making ${OUT}/construc.${O} from ${MID}/construc.lisp
	@ ( cd ${MID} ; \
	   echo '(progn  (compile-file "${MID}/construc.lisp"' \
            ':output-file "${OUT}/construc.${O}") (${BYE}))' | ${DEPSYS}  )

@
<<construc.lisp (MID from IN)>>=
${MID}/construc.lisp: ${IN}/construc.lisp.pamphlet
	@ echo 31 making ${MID}/construc.lisp from ${IN}/construc.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/construc.lisp.pamphlet >construc.lisp )

@

\subsection{daase.lisp \cite{13}}
<<daase.o (OUT from MID)>>=
${OUT}/daase.${O}: ${MID}/daase.lisp
	@ echo 33 making ${OUT}/daase.${O} from ${MID}/daase.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/daase.lisp"' \
            ':output-file "${OUT}/daase.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/daase.lisp"' \
            ':output-file "${OUT}/daase.${O}") (${BYE}))' | ${DEPSYS} \
            >${TMP}/trace ; \
	  fi )

@
<<daase.lisp (MID from IN)>>=
${MID}/daase.lisp: ${IN}/daase.lisp.pamphlet
	@ echo 34 making ${MID}/daase.lisp from ${IN}/daase.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/daase.lisp.pamphlet >daase.lisp )

@

\subsection{debugsys.lisp \cite{14}}
The {\bf debugsys.lisp} file is used to create a {\bf debugsys} runnable image.
This image contains almost all of the lisp code that make up the axiom
interpreter in lisp form. It is useful for deep system debugging but
otherwise worthless. This file is certain to drift over time as changes
are made elsewhere to add or remove files. It is assumed that you know
what you are doing if you change this file or use debugsys.

This file is basically the same as the one created during the build of
interpsys. See the echo lines in the {\bf SAVESYS} block above. These
are echoed into a temporary file which gets loaded into the lisp image.
We simply captured that temporary file, replaced the .o files with .lisp
files (or .lsp or .clisp) and saved it here.
<<debugsys.lisp (MID from IN)>>=
${MID}/debugsys.lisp: ${IN}/debugsys.lisp.pamphlet
	@ echo 39 making ${MID}/debugsys.lisp from ${IN}/debugsys.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/debugsys.lisp.pamphlet >debugsys.lisp )

@

\subsection{fname.lisp \cite{17}}
<<fname.o (OUT from MID)>>=
${OUT}/fname.${O}: ${MID}/fname.lisp
	@ echo 46 making ${OUT}/fname.${O} from ${MID}/fname.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/fname.lisp"' \
            ':output-file "${OUT}/fname.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/fname.lisp"' \
            ':output-file "${OUT}/fname.${O}") (${BYE}))' | ${DEPSYS} \
            >${TMP}/trace ; \
	  fi )

@
<<fname.lisp (MID from IN)>>=
${MID}/fname.lisp: ${IN}/fname.lisp.pamphlet
	@ echo 47 making ${MID}/fname.lisp from ${IN}/fname.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/fname.lisp.pamphlet >fname.lisp )

@

\subsection{fnewmeta.lisp \cite{18}}
<<fnewmeta.o (AUTO from OUT)>>=
${AUTO}/fnewmeta.${O}: ${OUT}/fnewmeta.${O}
	@ echo 49 making ${AUTO}/fnewmeta.${O} from ${OUT}/fnewmeta.${O}
	@ cp ${OUT}/fnewmeta.${O} ${AUTO}

@
<<fnewmeta.o (OUT from MID)>>=
${OUT}/fnewmeta.${O}: ${MID}/fnewmeta.lisp 
	@ echo 50 making ${OUT}/fnewmeta.${O} from ${MID}/fnewmeta.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/fnewmeta.lisp"' \
            ':output-file "${OUT}/fnewmeta.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/fnewmeta.lisp"' \
            ':output-file "${OUT}/fnewmeta.${O}") (${BYE}))' | ${DEPSYS} \
            >${TMP}/trace ; \
	  fi )
	  
@
<<fnewmeta.lisp (OUT from IN)>>=
${OUT}/fnewmeta.${LISP}: ${IN}/fnewmeta.lisp.pamphlet
	@ echo 51 making ${OUT}/fnewmeta.${LISP} \
                  from ${MID}/fnewmeta.lisp.pamphlet
	@ rm -f ${OUT}/fnewmeta.${O}
	@ ( cd ${OUT} ; \
	  ${TANGLE} ${IN}/fnewmeta.lisp.pamphlet >fnewmeta.${LISP} )

@
<<fnewmeta.lisp (MID from IN)>>=
${MID}/fnewmeta.lisp: ${IN}/fnewmeta.lisp.pamphlet
	@ echo 52 making ${MID}/fnewmeta.lisp from ${IN}/fnewmeta.lisp.pamphlet
	@ ( cd ${MID} ; \
	  ${TANGLE} ${IN}/fnewmeta.lisp.pamphlet >fnewmeta.lisp )
	  
@

\subsection{fortcall.lisp}
<<fortcall.o (OUT from MID)>>=
${OUT}/fortcall.${O}: ${MID}/fortcall.lisp
	@ echo 136 making ${OUT}/fortcall.${O} from ${MID}/fortcall.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/fortcall.lisp"' \
             ':output-file "${OUT}/fortcall.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/fortcall.lisp"' \
             ':output-file "${OUT}/fortcall.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<fortcall.lisp (MID from IN)>>=
${MID}/fortcall.lisp: ${IN}/fortcall.lisp.pamphlet
	@ echo 137 making ${MID}/fortcall.lisp from \
           ${IN}/fortcall.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/fortcall.lisp.pamphlet >fortcall.lisp )

@
\subsection{hypertex.lisp}
<<hypertex.o (OUT from MID)>>=
${OUT}/hypertex.${O}: ${MID}/hypertex.lisp
	@ echo 136 making ${OUT}/hypertex.${O} from ${MID}/hypertex.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/hypertex.lisp"' \
             ':output-file "${OUT}/hypertex.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/hypertex.lisp"' \
             ':output-file "${OUT}/hypertex.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<hypertex.lisp (MID from IN)>>=
${MID}/hypertex.lisp: ${IN}/hypertex.lisp.pamphlet
	@ echo 137 making ${MID}/hypertex.lisp from \
           ${IN}/hypertex.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/hypertex.lisp.pamphlet >hypertex.lisp )

@

\subsection{monitor.lisp \cite{24}}
<<monitor.o (OUT from MID)>>=
${OUT}/monitor.${O}: ${MID}/monitor.lisp
	@ echo 76 making ${OUT}/monitor.${O} from ${MID}/monitor.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/monitor.lisp"' \
             ':output-file "${OUT}/monitor.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/monitor.lisp"' \
             ':output-file "${OUT}/monitor.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<monitor.lisp (MID from IN)>>=
${MID}/monitor.lisp: ${IN}/monitor.lisp.pamphlet
	@ echo 77 making ${MID}/monitor.lisp from ${IN}/monitor.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/monitor.lisp.pamphlet >monitor.lisp )

@

\subsection{newaux.lisp \cite{25}}
<<newaux.o (OUT from MID)>>=
${OUT}/newaux.${O}: ${MID}/newaux.lisp
	@ echo 79 making ${OUT}/newaux.${O} from ${MID}/newaux.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/newaux.lisp"' \
             ':output-file "${OUT}/newaux.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/newaux.lisp"' \
             ':output-file "${OUT}/newaux.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<newaux.lisp (OUT from MID)>>=
${OUT}/newaux.${LISP}: ${MID}/newaux.lisp
	@ echo 80 making ${OUT}/newaux.${LISP} from ${MID}/newaux.lisp
	@cp ${MID}/newaux.lisp ${OUT}/newaux.${LISP}

@
<<newaux.lisp (MID from IN)>>=
${MID}/newaux.lisp: ${IN}/newaux.lisp.pamphlet
	@ echo 81 making ${MID}/newaux.lisp from ${IN}/newaux.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/newaux.lisp.pamphlet >newaux.lisp )

@

\subsection{nocompil.lisp \cite{27}}
<<nocompil.lisp (OUT from MID)>>=
${OUT}/nocompil.${LISP}: ${MID}/nocompil.lisp 
	@ echo 86 making ${OUT}/nocompil.${LISP} from ${MID}/nocompil.lisp
	@ cp ${MID}/nocompil.lisp ${OUT}/nocompil.${LISP}

@
<<nocompil.lisp (MID from IN)>>=
${MID}/nocompil.lisp: ${IN}/nocompil.lisp.pamphlet
	@ echo 87 making ${MID}/nocompil.lisp from ${IN}/nocompil.lisp.pamphlet
	@ ( cd ${MID} ; \
	${TANGLE} ${IN}/nocompil.lisp.pamphlet >nocompil.lisp )

@

\subsection{nspadaux.lisp \cite{28}}
<<nspadaux.o (AUTO from OUT)>>=
${AUTO}/nspadaux.${O}: ${OUT}/nspadaux.${O}
	@ echo 89 making ${AUTO}/nspadaux.${O} from ${OUT}/nspadaux.${O}
	@ cp ${OUT}/nspadaux.${O} ${AUTO}

@
<<nspadaux.o (OUT from MID)>>=
${OUT}/nspadaux.${O}: ${MID}/nspadaux.lisp 
	@ echo 90 making ${OUT}/nspadaux.${O} from ${MID}/nspadaux.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/nspadaux.lisp"' \
             ':output-file "${OUT}/nspadaux.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/nspadaux.lisp"' \
             ':output-file "${OUT}/nspadaux.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )
	  
@
<<nspadaux.lisp (OUT from MID)>>=
${OUT}/nspadaux.${LISP}: ${MID}/nspadaux.lisp
	@ echo 91 making ${OUT}/nspadaux.${LISP} from ${MID}/nspadaux.lisp
	@cp ${MID}/nspadaux.lisp ${OUT}/nspadaux.${LISP}

@
<<nspadaux.lisp (MID from IN)>>=
${MID}/nspadaux.lisp: ${IN}/nspadaux.lisp.pamphlet
	@ echo 92 making ${MID}/nspadaux.lisp from ${IN}/nspadaux.lisp.pamphlet
	@ ( cd ${MID} ; \
	  ${TANGLE} ${IN}/nspadaux.lisp.pamphlet >nspadaux.lisp )
	  
@

\subsection{parsing.lisp \cite{29}}
<<parsing.o (AUTO from OUT)>>=
${AUTO}/parsing.${O}: ${OUT}/parsing.${O}
	@ echo 94 making ${AUTO}/parsing.${O} from ${OUT}/parsing.${O}
	@ cp ${OUT}/parsing.${O} ${AUTO}

@
<<parsing.o (OUT from MID)>>=
${OUT}/parsing.${O}: ${MID}/parsing.lisp 
	@ echo 95 making ${OUT}/parsing.${O} from ${MID}/parsing.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/parsing.lisp"' \
             ':output-file "${OUT}/parsing.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/parsing.lisp"' \
             ':output-file "${OUT}/parsing.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )
	  
@
<<parsing.lisp (OUT from MID)>>=
${OUT}/parsing.${LISP}: ${MID}/parsing.lisp
	@ echo 96 making ${OUT}/parsing.${LISP} from ${MID}/parsing.lisp
	@cp ${MID}/parsing.lisp ${OUT}/parsing.${LISP}

@
<<parsing.lisp (MID from IN)>>=
${MID}/parsing.lisp: ${IN}/parsing.lisp.pamphlet
	@ echo 97 making ${MID}/parsing.lisp from ${IN}/parsing.lisp.pamphlet
	@ ( cd ${MID} ; \
	  ${TANGLE} ${IN}/parsing.lisp.pamphlet >parsing.lisp )
	  
@

\subsection{patches.lisp \cite{5}}
<<patches.o (OUT from MID)>>=
${OUT}/patches.${O}: ${MID}/patches.lisp
	@ echo 99 making ${OUT}/patches.${O} from ${MID}/patches.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/patches.lisp"' \
             ':output-file "${OUT}/patches.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/patches.lisp"' \
             ':output-file "${OUT}/patches.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<patches.lisp (MID from IN)>>=
${MID}/patches.lisp: ${IN}/patches.lisp.pamphlet
	@ echo 100 making ${MID}/patches.lisp from ${IN}/patches.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/patches.lisp.pamphlet >patches.lisp )

@

\subsection{postprop.lisp \cite{30}}
<<postprop.lisp (AUTO from OUT)>>=
${AUTO}/postprop.lisp: ${OUT}/postprop.lisp
	@ echo 102 making ${AUTO}/postprop.lisp from ${OUT}/postprop.lisp
	@ cp ${OUT}/postprop.lisp ${AUTO}

@
<<postprop.lisp (OUT from MID)>>=
${OUT}/postprop.lisp: ${MID}/postprop.lisp
	@ echo 103 making ${OUT}/postprop.lisp from ${MID}/postprop.lisp
	@ rm -f ${OUT}/postprop.${O}
	@ cp ${MID}/postprop.lisp ${OUT}/postprop.${LISP}

@
<<postprop.lisp (MID from IN)>>=
${MID}/postprop.lisp: ${IN}/postprop.lisp.pamphlet
	@ echo 104 making ${MID}/postprop.lisp \
                   from ${IN}/postprop.lisp.pamphlet
	@ (cd ${MID} ; \
	${TANGLE} ${IN}/postprop.lisp.pamphlet >postprop.lisp )

@

\subsection{sockio.lisp \cite{33}}
<<sockio.o (OUT from MID)>>=
${OUT}/sockio.${O}: ${MID}/sockio.lisp
	@ echo 117 making ${OUT}/sockio.${O} from ${MID}/sockio.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/sockio.lisp"' \
             ':output-file "${OUT}/sockio.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/sockio.lisp"' \
             ':output-file "${OUT}/sockio.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<sockio.lisp (MID from IN)>>=
${MID}/sockio.lisp: ${IN}/sockio.lisp.pamphlet
	@ echo 118 making ${MID}/sockio.lisp from ${IN}/sockio.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/sockio.lisp.pamphlet >sockio.lisp )

@

\subsection{sys-pkg.lisp \cite{36}}
<<sys-pkg.lisp (OUT from MID)>>=
${OUT}/sys-pkg.${LISP}: ${MID}/sys-pkg.lisp 
	@ echo 126 making ${OUT}/sys-pkg.${LISP} from ${MID}/sys-pkg.lisp
	@ cp ${MID}/sys-pkg.lisp ${OUT}/sys-pkg.${LISP}

@
<<sys-pkg.lisp (MID from IN)>>=
${MID}/sys-pkg.lisp: ${IN}/sys-pkg.lisp.pamphlet
	@ echo 127 making ${MID}/sys-pkg.lisp from ${IN}/sys-pkg.lisp.pamphlet
	@ ( cd ${MID} ; \
	${TANGLE} ${IN}/sys-pkg.lisp.pamphlet >sys-pkg.lisp )

@

\subsection{util.lisp \cite{38}}
<<util.o (OUT from MID)>>=
${OUT}/util.${O}: ${MID}/util.lisp
	@ echo 132 making ${OUT}/util.${O} from ${MID}/util.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/util.lisp"' \
             ':output-file "${OUT}/util.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/util.lisp"' \
             ':output-file "${OUT}/util.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<util.lisp (OUT from MID)>>=
${OUT}/util.${LISP}: ${MID}/util.lisp
	@ echo 133 making ${OUT}/util.${LISP} from ${MID}/util.lisp
	@cp ${MID}/util.lisp ${OUT}/util.${LISP}

@
<<util.lisp (MID from IN)>>=
${MID}/util.lisp: ${IN}/util.lisp.pamphlet
	@ echo 134 making ${MID}/util.lisp from ${IN}/util.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/util.lisp.pamphlet >util.lisp )

@

\subsection{vmlisp.lisp \cite{39}}
<<vmlisp.o (OUT from MID)>>=
${OUT}/vmlisp.${O}: ${MID}/vmlisp.lisp
	@ echo 136 making ${OUT}/vmlisp.${O} from ${MID}/vmlisp.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/vmlisp.lisp"' \
             ':output-file "${OUT}/vmlisp.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/vmlisp.lisp"' \
             ':output-file "${OUT}/vmlisp.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<vmlisp.lisp (MID from IN)>>=
${MID}/vmlisp.lisp: ${IN}/vmlisp.lisp.pamphlet
	@ echo 137 making ${MID}/vmlisp.lisp from ${IN}/vmlisp.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/vmlisp.lisp.pamphlet >vmlisp.lisp )

@

\subsection{alql.lisp}
<<alql.o (OUT from MID)>>=
${OUT}/alql.${O}: ${MID}/alql.lisp
	@ echo 136 making ${OUT}/alql.${O} from ${MID}/alql.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/alql.lisp"' \
             ':output-file "${OUT}/alql.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/alql.lisp"' \
             ':output-file "${OUT}/alql.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<alql.lisp (MID from IN)>>=
${MID}/alql.lisp: ${IN}/alql.lisp.pamphlet
	@ echo 137 making ${MID}/alql.lisp from ${IN}/alql.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/alql.lisp.pamphlet >alql.lisp )

@

\subsection{buildom.lisp}
<<buildom.o (OUT from MID)>>=
${OUT}/buildom.${O}: ${MID}/buildom.lisp
	@ echo 136 making ${OUT}/buildom.${O} from ${MID}/buildom.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/buildom.lisp"' \
             ':output-file "${OUT}/buildom.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/buildom.lisp"' \
             ':output-file "${OUT}/buildom.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<buildom.lisp (MID from IN)>>=
${MID}/buildom.lisp: ${IN}/buildom.lisp.pamphlet
	@ echo 137 making ${MID}/buildom.lisp from ${IN}/buildom.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/buildom.lisp.pamphlet >buildom.lisp )

@

\subsection{c-util.lisp}
<<c-util.o (OUT from MID)>>=
${OUT}/c-util.${O}: ${MID}/c-util.lisp
	@ echo 136 making ${OUT}/c-util.${O} from ${MID}/c-util.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/c-util.lisp"' \
             ':output-file "${OUT}/c-util.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/c-util.lisp"' \
             ':output-file "${OUT}/c-util.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<c-util.lisp (MID from IN)>>=
${MID}/c-util.lisp: ${IN}/c-util.lisp.pamphlet
	@ echo 137 making ${MID}/c-util.lisp from ${IN}/c-util.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/c-util.lisp.pamphlet >c-util.lisp )

@
<<c-util.lisp (OUT from IN)>>=
${OUT}/c-util.lisp: ${IN}/c-util.lisp.pamphlet
	@ echo 221 making ${OUT}/c-util.lisp from ${IN}/c-util.boot.pamphlet
	@ rm -f ${OUT}/c-util.${O}
	@( cd ${OUT} ; \
	   ${TANGLE} ${IN}/c-util.lisp.pamphlet >c-util.lisp )

@

\subsection{nag-c02.boot \cite{43}}
<<nag-c02.o (AUTO from OUT)>>=
${AUTO}/nag-c02.${O}: ${OUT}/nag-c02.${O}
	@ echo 150 making${AUTO}/nag-c02.${O} from ${OUT}/nag-c02.${O}
	@ cp ${OUT}/nag-c02.${O} ${AUTO}

@
<<nag-c02.o (OUT from MID)>>=
${OUT}/nag-c02.${O}: ${MID}/nag-c02.clisp
	@ echo 151 making ${OUT}/nag-c02.${O} from ${MID}/nag-c02.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "${MID}/nag-c02.clisp"' \
             ':output-file "${OUT}/nag-c02.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "${MID}/nag-c02.clisp"' \
             ':output-file "${OUT}/nag-c02.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nag-c02.clisp (MID from IN)>>=
${MID}/nag-c02.clisp: ${IN}/nag-c02.boot.pamphlet
	@ echo 152 making ${MID}/nag-c02.clisp from ${IN}/nag-c02.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-c02.boot.pamphlet >nag-c02.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
             '(boottran::boottocl "nag-c02.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
             '(boottran::boottocl "nag-c02.boot") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi ; \
	  rm nag-c02.boot )

@

\subsection{nag-c05.boot \cite{44}}
<<nag-c05.o (AUTO from OUT)>>=
${AUTO}/nag-c05.${O}: ${OUT}/nag-c05.${O}
	@ echo 154 making ${AUTO}/nag-c05.${O} from ${OUT}/nag-c05.${O}
	@ cp ${OUT}/nag-c05.${O} ${AUTO}

@
<<nag-c05.o (OUT from MID)>>=
${OUT}/nag-c05.${O}: ${MID}/nag-c05.clisp
	@ echo 155 making ${OUT}/nag-c05.${O} from ${MID}/nag-c05.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/nag-c05.clisp"' \
            ':output-file "${OUT}/nag-c05.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/nag-c05.clisp"' \
            ':output-file "${OUT}/nag-c05.${O}") (${BYE}))' | ${DEPSYS} \
            >${TMP}/trace ; \
	  fi )

@
<<nag-c05.clisp (MID from IN)>>=
${MID}/nag-c05.clisp: ${IN}/nag-c05.boot.pamphlet
	@ echo 156 making ${MID}/nag-c05.clisp from ${IN}/nag-c05.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-c05.boot.pamphlet >nag-c05.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-c05.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-c05.boot") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi ; \
	  rm nag-c05.boot )

@

\subsection{nag-c06.boot \cite{45}}
<<nag-c06.o (AUTO from OUT)>>=
${AUTO}/nag-c06.${O}: ${OUT}/nag-c06.${O}
	@ echo 158 making${AUTO}/nag-c06.${O} from ${OUT}/nag-c06.${O}
	@ cp ${OUT}/nag-c06.${O} ${AUTO}

@
<<nag-c06.o (OUT from MID)>>=
${OUT}/nag-c06.${O}: ${MID}/nag-c06.clisp
	@ echo 159 making ${OUT}/nag-c06.${O} from ${MID}/nag-c06.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/nag-c06.clisp"' \
             ':output-file "${OUT}/nag-c06.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/nag-c06.clisp"' \
             ':output-file "${OUT}/nag-c06.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nag-c06.clisp (MID from IN)>>=
${MID}/nag-c06.clisp: ${IN}/nag-c06.boot.pamphlet
	@ echo 160 making ${MID}/nag-c06.clisp from ${IN}/nag-c06.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-c06.boot.pamphlet >nag-c06.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-c06.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-c06.boot") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi ; \
	  rm nag-c06.boot )

@

\subsection{nag-d01.boot \cite{46}}
<<nag-d01.o (AUTO from OUT)>>=
${AUTO}/nag-d01.${O}: ${OUT}/nag-d01.${O}
	@ echo 162 making${AUTO}/nag-d01.${O} from ${OUT}/nag-d01.${O}
	@ cp ${OUT}/nag-d01.${O} ${AUTO}

@
<<nag-d01.o (OUT from MID)>>=
${OUT}/nag-d01.${O}: ${MID}/nag-d01.clisp
	@ echo 163 making ${OUT}/nag-d01.${O} from ${MID}/nag-d01.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/nag-d01.clisp"' \
             ':output-file "${OUT}/nag-d01.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/nag-d01.clisp"' \
             ':output-file "${OUT}/nag-d01.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nag-d01.clisp (MID from IN)>>=
${MID}/nag-d01.clisp: ${IN}/nag-d01.boot.pamphlet
	@ echo 164 making ${MID}/nag-d01.clisp from ${IN}/nag-d01.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-d01.boot.pamphlet >nag-d01.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-d01.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-d01.boot") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi ; \
	  rm nag-d01.boot )

@

\subsection{nag-d02.boot \cite{47}}
<<nag-d02.o (AUTO from OUT)>>=
${AUTO}/nag-d02.${O}: ${OUT}/nag-d02.${O}
	@ echo 166 making${AUTO}/nag-d02.${O} from ${OUT}/nag-d02.${O}
	@ cp ${OUT}/nag-d02.${O} ${AUTO}

@
<<nag-d02.o (OUT from MID)>>=
${OUT}/nag-d02.${O}: ${MID}/nag-d02.clisp
	@ echo 167 making ${OUT}/nag-d02.${O} from ${MID}/nag-d02.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "${MID}/nag-d02.clisp"' \
             ':output-file "${OUT}/nag-d02.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "${MID}/nag-d02.clisp"' \
             ':output-file "${OUT}/nag-d02.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nag-d02.clisp (MID from IN)>>=
${MID}/nag-d02.clisp: ${IN}/nag-d02.boot.pamphlet
	@ echo 168 making ${MID}/nag-d02.clisp from ${IN}/nag-d02.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-d02.boot.pamphlet >nag-d02.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-d02.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-d02.boot") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi ; \
	  rm nag-d02.boot )

@

\subsection{nag-d03.boot \cite{48}}
<<nag-d03.o (AUTO from OUT)>>=
${AUTO}/nag-d03.${O}: ${OUT}/nag-d03.${O}
	@ echo 170 making${AUTO}/nag-d03.${O} from ${OUT}/nag-d03.${O}
	@ cp ${OUT}/nag-d03.${O} ${AUTO}

@
<<nag-d03.o (OUT from MID)>>=
${OUT}/nag-d03.${O}: ${MID}/nag-d03.clisp
	@ echo 171 making ${OUT}/nag-d03.${O} from ${MID}/nag-d03.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "${MID}/nag-d03.clisp"' \
             ':output-file "${OUT}/nag-d03.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "${MID}/nag-d03.clisp"' \
             ':output-file "${OUT}/nag-d03.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nag-d03.clisp (MID from IN)>>=
${MID}/nag-d03.clisp: ${IN}/nag-d03.boot.pamphlet
	@ echo 172 making ${MID}/nag-d03.clisp from ${IN}/nag-d03.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-d03.boot.pamphlet >nag-d03.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-d03.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-d03.boot") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi ; \
	  rm nag-d03.boot )

@

\subsection{nag-e01.boot \cite{49}}
<<nag-e01.o (AUTO from OUT)>>=
${AUTO}/nag-e01.${O}: ${OUT}/nag-e01.${O}
	@ echo 174 making ${AUTO}/nag-e01.${O} from ${OUT}/nag-e01.${O}
	@ cp ${OUT}/nag-e01.${O} ${AUTO}

@
<<nag-e01.o (OUT from MID)>>=
${OUT}/nag-e01.${O}: ${MID}/nag-e01.clisp
	@ echo 175 making ${OUT}/nag-e01.${O} from ${MID}/nag-e01.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/nag-e01.clisp"' \
             ':output-file "${OUT}/nag-e01.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/nag-e01.clisp"' \
             ':output-file "${OUT}/nag-e01.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nag-e01.clisp (MID from IN)>>=
${MID}/nag-e01.clisp: ${IN}/nag-e01.boot.pamphlet
	@ echo 176 making ${MID}/nag-e01.clisp from ${IN}/nag-e01.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-e01.boot.pamphlet >nag-e01.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-e01.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-e01.boot") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi ; \
	  rm nag-e01.boot )

@

\subsection{nag-e02.boot \cite{51}}
<<nag-e02.o (AUTO from OUT)>>=
${AUTO}/nag-e02.${O}: ${OUT}/nag-e02.${O}
	@ echo 182 making ${AUTO}/nag-e02.${O} from ${OUT}/nag-e02.${O}
	@ cp ${OUT}/nag-e02.${O} ${AUTO}

@
<<nag-e02.o (OUT from MID)>>=
${OUT}/nag-e02.${O}: ${MID}/nag-e02.clisp
	@ echo 183 making ${OUT}/nag-e02.${O} from ${MID}/nag-e02.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/nag-e02.clisp"' \
             ':output-file "${OUT}/nag-e02.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/nag-e02.clisp"' \
             ':output-file "${OUT}/nag-e02.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nag-e02.clisp (MID from IN)>>=
${MID}/nag-e02.clisp: ${IN}/nag-e02.boot.pamphlet
	@ echo 184 making ${MID}/nag-e02.clisp from ${IN}/nag-e02.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-e02.boot.pamphlet >nag-e02.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-e02.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-e02.boot") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi ; \
	  rm nag-e02.boot )

@

\subsection{nag-e04.boot \cite{52}}
<<nag-e04.o (AUTO from OUT)>>=
${AUTO}/nag-e04.${O}: ${OUT}/nag-e04.${O}
	@ echo 186 making ${AUTO}/nag-e04.${O} from ${OUT}/nag-e04.${O}
	@ cp ${OUT}/nag-e04.${O} ${AUTO}

@
<<nag-e04.o (OUT from MID)>>=
${OUT}/nag-e04.${O}: ${MID}/nag-e04.clisp
	@ echo 187 making ${OUT}/nag-e04.${O} from ${MID}/nag-e04.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "${MID}/nag-e04.clisp"' \
             ':output-file "${OUT}/nag-e04.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "${MID}/nag-e04.clisp"' \
             ':output-file "${OUT}/nag-e04.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nag-e04.clisp (MID from IN)>>=
${MID}/nag-e04.clisp: ${IN}/nag-e04.boot.pamphlet
	@ echo 188 making ${MID}/nag-e04.clisp from ${IN}/nag-e04.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-e04.boot.pamphlet >nag-e04.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-e04.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-e04.boot") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi ; \
	  rm nag-e04.boot )

@

\subsection{nag-f01.boot \cite{53}}
<<nag-f01.o (AUTO from OUT)>>=
${AUTO}/nag-f01.${O}: ${OUT}/nag-f01.${O}
	@ echo 190 making ${AUTO}/nag-f01.${O} from ${OUT}/nag-f01.${O}
	@ cp ${OUT}/nag-f01.${O} ${AUTO}

@
<<nag-f01.o (OUT from MID)>>=
${OUT}/nag-f01.${O}: ${MID}/nag-f01.clisp
	@ echo 191 making ${OUT}/nag-f01.${O} from ${MID}/nag-f01.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "${MID}/nag-f01.clisp"' \
             ':output-file "${OUT}/nag-f01.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "${MID}/nag-f01.clisp"' \
             ':output-file "${OUT}/nag-f01.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nag-f01.clisp (MID from IN)>>=
${MID}/nag-f01.clisp: ${IN}/nag-f01.boot.pamphlet
	@ echo 192 making ${MID}/nag-f01.clisp from ${IN}/nag-f01.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-f01.boot.pamphlet >nag-f01.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-f01.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-f01.boot") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi ; \
	  rm nag-f01.boot )

@

\subsection{nag-f02.boot \cite{54}}
<<nag-f02.o (AUTO from OUT)>>=
${AUTO}/nag-f02.${O}: ${OUT}/nag-f02.${O}
	@ echo 194 making ${AUTO}/nag-f02.${O} from ${OUT}/nag-f02.${O}
	@ cp ${OUT}/nag-f02.${O} ${AUTO}

@
<<nag-f02.o (OUT from MID)>>=
${OUT}/nag-f02.${O}: ${MID}/nag-f02.clisp
	@ echo 195 making ${OUT}/nag-f02.${O} from ${MID}/nag-f02.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "${MID}/nag-f02.clisp"' \
             ':output-file "${OUT}/nag-f02.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "${MID}/nag-f02.clisp"' \
             ':output-file "${OUT}/nag-f02.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nag-f02.clisp (MID from IN)>>=
${MID}/nag-f02.clisp: ${IN}/nag-f02.boot.pamphlet
	@ echo 196 making ${MID}/nag-f02.clisp from ${IN}/nag-f02.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-f02.boot.pamphlet >nag-f02.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-f02.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-f02.boot") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi ; \
	  rm nag-f02.boot )

@

\subsection{nag-f04.boot \cite{55}}
<<nag-f04.o (AUTO from OUT)>>=
${AUTO}/nag-f04.${O}: ${OUT}/nag-f04.${O}
	@ echo 198 making ${AUTO}/nag-f04.${O} from ${OUT}/nag-f04.${O}
	@ cp ${OUT}/nag-f04.${O} ${AUTO}

@
<<nag-f04.o (OUT from MID)>>=
${OUT}/nag-f04.${O}: ${MID}/nag-f04.clisp
	@ echo 199 making ${OUT}/nag-f04.${O} from ${MID}/nag-f04.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/nag-f04.clisp"' \
             ':output-file "${OUT}/nag-f04.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/nag-f04.clisp"' \
             ':output-file "${OUT}/nag-f04.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nag-f04.clisp (MID from IN)>>=
${MID}/nag-f04.clisp: ${IN}/nag-f04.boot.pamphlet
	@ echo 200 making ${MID}/nag-f04.clisp from ${IN}/nag-f04.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-f04.boot.pamphlet >nag-f04.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-f04.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-f04.boot") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi ; \
	  rm nag-f04.boot )

@

\subsection{nag-f07.boot \cite{56}}
<<nag-f07.o (AUTO from OUT)>>=
${AUTO}/nag-f07.${O}: ${OUT}/nag-f07.${O}
	@ echo 202 making ${AUTO}/nag-f07.${O} from ${OUT}/nag-f07.${O}
	@ cp ${OUT}/nag-f07.${O} ${AUTO}

@
<<nag-f07.o (OUT from MID)>>=
${OUT}/nag-f07.${O}: ${MID}/nag-f07.clisp
	@ echo 203 making ${OUT}/nag-f07.${O} from ${MID}/nag-f07.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "${MID}/nag-f07.clisp"' \
             ':output-file "${OUT}/nag-f07.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "${MID}/nag-f07.clisp"' \
             ':output-file "${OUT}/nag-f07.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nag-f07.clisp (MID from IN)>>=
${MID}/nag-f07.clisp: ${IN}/nag-f07.boot.pamphlet
	@ echo 204 making ${MID}/nag-f07.clisp from ${IN}/nag-f07.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-f07.boot.pamphlet >nag-f07.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-f07.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-f07.boot") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi ; \
	  rm nag-f07.boot )

@

\subsection{nag-s.boot \cite{57}}
<<nag-s.o (AUTO from OUT)>>=
${AUTO}/nag-s.${O}: ${OUT}/nag-s.${O}
	@ echo 206 making ${AUTO}/nag-s.${O} from ${OUT}/nag-s.${O}
	@ cp ${OUT}/nag-s.${O} ${AUTO}

@
<<nag-s.o (OUT from MID)>>=
${OUT}/nag-s.${O}: ${MID}/nag-s.clisp
	@ echo 207 making ${OUT}/nag-s.${O} from ${MID}/nag-s.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/nag-s.clisp"' \
             ':output-file "${OUT}/nag-s.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/nag-s.clisp"' \
             ':output-file "${OUT}/nag-s.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nag-s.clisp (MID from IN)>>=
${MID}/nag-s.clisp: ${IN}/nag-s.boot.pamphlet
	@ echo 208 making ${MID}/nag-s.clisp from ${IN}/nag-s.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nag-s.boot.pamphlet >nag-s.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-s.boot") (${BYE}))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${SPAD}")' \
              '(boottran::boottocl "nag-s.boot") (${BYE}))' | ${DEPSYS} \
              >${TMP}/trace ; \
	  fi ; \
	  rm nag-s.boot )

@

\subsection{category.lisp}
<<category.o (OUT from MID)>>=
${OUT}/category.${O}: ${MID}/category.lisp
	@ echo 136 making ${OUT}/category.${O} from ${MID}/category.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/category.lisp"' \
             ':output-file "${OUT}/category.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/category.lisp"' \
             ':output-file "${OUT}/category.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<category.lisp (MID from IN)>>=
${MID}/category.lisp: ${IN}/category.lisp.pamphlet
	@ echo 137 making ${MID}/category.lisp from \
           ${IN}/category.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/category.lisp.pamphlet >category.lisp )

@

\subsection{cattable.lisp}
<<cattable.o (OUT from MID)>>=
${OUT}/cattable.${O}: ${MID}/cattable.lisp
	@ echo 136 making ${OUT}/cattable.${O} from ${MID}/cattable.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/cattable.lisp"' \
             ':output-file "${OUT}/cattable.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/cattable.lisp"' \
             ':output-file "${OUT}/cattable.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<cattable.lisp (MID from IN)>>=
${MID}/cattable.lisp: ${IN}/cattable.lisp.pamphlet
	@ echo 137 making ${MID}/cattable.lisp from \
                   ${IN}/cattable.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/cattable.lisp.pamphlet >cattable.lisp )

@

\subsection{c-doc.lisp}
<<c-doc.o (OUT from MID)>>=
${OUT}/c-doc.${O}: ${MID}/c-doc.lisp
	@ echo 136 making ${OUT}/c-doc.${O} from ${MID}/c-doc.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/c-doc.lisp"' \
             ':output-file "${OUT}/c-doc.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/c-doc.lisp"' \
             ':output-file "${OUT}/c-doc.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<c-doc.lisp (MID from IN)>>=
${MID}/c-doc.lisp: ${IN}/c-doc.lisp.pamphlet
	@ echo 137 making ${MID}/c-doc.lisp from ${IN}/c-doc.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/c-doc.lisp.pamphlet >c-doc.lisp )

@

\subsection{clam.lisp}
<<clam.o (OUT from MID)>>=
${OUT}/clam.${O}: ${MID}/clam.lisp
	@ echo 136 making ${OUT}/clam.${O} from ${MID}/clam.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/clam.lisp"' \
             ':output-file "${OUT}/clam.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/clam.lisp"' \
             ':output-file "${OUT}/clam.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<clam.lisp (MID from IN)>>=
${MID}/clam.lisp: ${IN}/clam.lisp.pamphlet
	@ echo 137 making ${MID}/clam.lisp from ${IN}/clam.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/clam.lisp.pamphlet >clam.lisp )

@
<<clam.lisp (OUT from IN)>>=
${OUT}/clam.lisp: ${IN}/clam.lisp.pamphlet
	@ echo 221 making ${OUT}/clam.lisp from ${IN}/clam.boot.pamphlet
	@ rm -f ${OUT}/clam.${O}
	@( cd ${OUT} ; \
	   ${TANGLE} ${IN}/clam.lisp.pamphlet >clam.lisp )

@

\subsection{clammed.lisp}
<<clammed.o (OUT from MID)>>=
${OUT}/clammed.${O}: ${MID}/clammed.lisp
	@ echo 136 making ${OUT}/clammed.${O} from ${MID}/clammed.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/clammed.lisp"' \
             ':output-file "${OUT}/clammed.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/clammed.lisp"' \
             ':output-file "${OUT}/clammed.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<clammed.lisp (MID from IN)>>=
${MID}/clammed.lisp: ${IN}/clammed.lisp.pamphlet
	@ echo 137 making ${MID}/clammed.lisp from ${IN}/clammed.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/clammed.lisp.pamphlet >clammed.lisp )

@

\subsection{compat.lisp}
<<compat.o (OUT from MID)>>=
${OUT}/compat.${O}: ${MID}/compat.lisp
	@ echo 136 making ${OUT}/compat.${O} from ${MID}/compat.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/compat.lisp"' \
             ':output-file "${OUT}/compat.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/compat.lisp"' \
             ':output-file "${OUT}/compat.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<compat.lisp (MID from IN)>>=
${MID}/compat.lisp: ${IN}/compat.lisp.pamphlet
	@ echo 137 making ${MID}/compat.lisp from ${IN}/compat.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/compat.lisp.pamphlet >compat.lisp )

@

\subsection{compiler.lisp}
<<compiler.o (OUT from MID)>>=
${OUT}/compiler.${O}: ${MID}/compiler.lisp
	@ echo 136 making ${OUT}/compiler.${O} from ${MID}/compiler.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/compiler.lisp"' \
             ':output-file "${OUT}/compiler.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/compiler.lisp"' \
             ':output-file "${OUT}/compiler.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<compiler.lisp (MID from IN)>>=
${MID}/compiler.lisp: ${IN}/compiler.lisp.pamphlet
	@ echo 137 making ${MID}/compiler.lisp from \
           ${IN}/compiler.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/compiler.lisp.pamphlet >compiler.lisp )

@

\subsection{profile.lisp}
<<profile.o (OUT from MID)>>=
${OUT}/profile.${O}: ${MID}/profile.lisp
	@ echo 136 making ${OUT}/profile.${O} from ${MID}/profile.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/profile.lisp"' \
             ':output-file "${OUT}/profile.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/profile.lisp"' \
             ':output-file "${OUT}/profile.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<profile.lisp (MID from IN)>>=
${MID}/profile.lisp: ${IN}/profile.lisp.pamphlet
	@ echo 137 making ${MID}/profile.lisp from ${IN}/profile.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/profile.lisp.pamphlet >profile.lisp )

@

\subsection{compress.lisp}
<<compress.o (OUT from MID)>>=
${OUT}/compress.${O}: ${MID}/compress.lisp
	@ echo 136 making ${OUT}/compress.${O} from ${MID}/compress.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/compress.lisp"' \
             ':output-file "${OUT}/compress.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/compress.lisp"' \
             ':output-file "${OUT}/compress.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<compress.lisp (MID from IN)>>=
${MID}/compress.lisp: ${IN}/compress.lisp.pamphlet
	@ echo 137 making ${MID}/compress.lisp from \
                   ${IN}/compress.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/compress.lisp.pamphlet >compress.lisp )

@

\subsection{database.lisp}
<<database.o (OUT from MID)>>=
${OUT}/database.${O}: ${MID}/database.lisp
	@ echo 136 making ${OUT}/database.${O} from ${MID}/database.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/database.lisp"' \
             ':output-file "${OUT}/database.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/database.lisp"' \
             ':output-file "${OUT}/database.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<database.lisp (MID from IN)>>=
${MID}/database.lisp: ${IN}/database.lisp.pamphlet
	@ echo 137 making ${MID}/database.lisp from \
           ${IN}/database.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/database.lisp.pamphlet >database.lisp )

@

\subsection{define.lisp}
<<define.o (OUT from MID)>>=
${OUT}/define.${O}: ${MID}/define.lisp
	@ echo 136 making ${OUT}/define.${O} from ${MID}/define.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/define.lisp"' \
             ':output-file "${OUT}/define.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/define.lisp"' \
             ':output-file "${OUT}/define.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<define.lisp (MID from IN)>>=
${MID}/define.lisp: ${IN}/define.lisp.pamphlet
	@ echo 137 making ${MID}/define.lisp from ${IN}/define.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/define.lisp.pamphlet >define.lisp )

@

\subsection{format.lisp}
<<format.o (OUT from MID)>>=
${OUT}/format.${O}: ${MID}/format.lisp
	@ echo 136 making ${OUT}/format.${O} from ${MID}/format.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/format.lisp"' \
             ':output-file "${OUT}/format.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/format.lisp"' \
             ':output-file "${OUT}/format.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<format.lisp (MID from IN)>>=
${MID}/format.lisp: ${IN}/format.lisp.pamphlet
	@ echo 137 making ${MID}/format.lisp from ${IN}/format.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/format.lisp.pamphlet >format.lisp )

@

\subsection{functor.lisp}
<<functor.o (OUT from MID)>>=
${OUT}/functor.${O}: ${MID}/functor.lisp
	@ echo 136 making ${OUT}/functor.${O} from ${MID}/functor.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/functor.lisp"' \
             ':output-file "${OUT}/functor.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/functor.lisp"' \
             ':output-file "${OUT}/functor.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<functor.lisp (MID from IN)>>=
${MID}/functor.lisp: ${IN}/functor.lisp.pamphlet
	@ echo 137 making ${MID}/functor.lisp from ${IN}/functor.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/functor.lisp.pamphlet >functor.lisp )

@

\subsection{g-boot.lisp}
<<g-boot.o (OUT from MID)>>=
${OUT}/g-boot.${O}: ${MID}/g-boot.lisp
	@ echo 136 making ${OUT}/g-boot.${O} from ${MID}/g-boot.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/g-boot.lisp"' \
             ':output-file "${OUT}/g-boot.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/g-boot.lisp"' \
             ':output-file "${OUT}/g-boot.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<g-boot.lisp (MID from IN)>>=
${MID}/g-boot.lisp: ${IN}/g-boot.lisp.pamphlet
	@ echo 137 making ${MID}/g-boot.lisp from ${IN}/g-boot.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/g-boot.lisp.pamphlet >g-boot.lisp )

@
<<g-boot.lisp (OUT from IN)>>=
${OUT}/g-boot.lisp: ${IN}/g-boot.lisp.pamphlet
	@ echo 221 making ${OUT}/g-boot.lisp from ${IN}/g-boot.boot.pamphlet
	@ rm -f ${OUT}/g-boot.${O}
	@( cd ${OUT} ; \
	   ${TANGLE} ${IN}/g-boot.lisp.pamphlet >g-boot.lisp )

@

\subsection{g-cndata.lisp}
<<g-cndata.o (OUT from MID)>>=
${OUT}/g-cndata.${O}: ${MID}/g-cndata.lisp
	@ echo 136 making ${OUT}/g-cndata.${O} from ${MID}/g-cndata.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/g-cndata.lisp"' \
             ':output-file "${OUT}/g-cndata.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/g-cndata.lisp"' \
             ':output-file "${OUT}/g-cndata.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<g-cndata.lisp (MID from IN)>>=
${MID}/g-cndata.lisp: ${IN}/g-cndata.lisp.pamphlet
	@ echo 137 making ${MID}/g-cndata.lisp from \
           ${IN}/g-cndata.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/g-cndata.lisp.pamphlet >g-cndata.lisp )

@

\subsection{g-error.lisp}
<<g-error.o (OUT from MID)>>=
${OUT}/g-error.${O}: ${MID}/g-error.lisp
	@ echo 136 making ${OUT}/g-error.${O} from ${MID}/g-error.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/g-error.lisp"' \
             ':output-file "${OUT}/g-error.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/g-error.lisp"' \
             ':output-file "${OUT}/g-error.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<g-error.lisp (MID from IN)>>=
${MID}/g-error.lisp: ${IN}/g-error.lisp.pamphlet
	@ echo 137 making ${MID}/g-error.lisp from ${IN}/g-error.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/g-error.lisp.pamphlet >g-error.lisp )

@

\subsection{g-opt.lisp}
<<g-opt.o (OUT from MID)>>=
${OUT}/g-opt.${O}: ${MID}/g-opt.lisp
	@ echo 136 making ${OUT}/g-opt.${O} from ${MID}/g-opt.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/g-opt.lisp"' \
             ':output-file "${OUT}/g-opt.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/g-opt.lisp"' \
             ':output-file "${OUT}/g-opt.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<g-opt.lisp (MID from IN)>>=
${MID}/g-opt.lisp: ${IN}/g-opt.lisp.pamphlet
	@ echo 137 making ${MID}/g-opt.lisp from ${IN}/g-opt.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/g-opt.lisp.pamphlet >g-opt.lisp )

@

\subsection{g-timer.lisp}
<<g-timer.o (OUT from MID)>>=
${OUT}/g-timer.${O}: ${MID}/g-timer.lisp
	@ echo 136 making ${OUT}/g-timer.${O} from ${MID}/g-timer.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/g-timer.lisp"' \
             ':output-file "${OUT}/g-timer.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/g-timer.lisp"' \
             ':output-file "${OUT}/g-timer.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<g-timer.lisp (MID from IN)>>=
${MID}/g-timer.lisp: ${IN}/g-timer.lisp.pamphlet
	@ echo 137 making ${MID}/g-timer.lisp from ${IN}/g-timer.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/g-timer.lisp.pamphlet >g-timer.lisp )

@

\subsection{g-util.lisp}
<<g-util.o (OUT from MID)>>=
${OUT}/g-util.${O}: ${MID}/g-util.lisp
	@ echo 136 making ${OUT}/g-util.${O} from ${MID}/g-util.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/g-util.lisp"' \
             ':output-file "${OUT}/g-util.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/g-util.lisp"' \
             ':output-file "${OUT}/g-util.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<g-util.lisp (MID from IN)>>=
${MID}/g-util.lisp: ${IN}/g-util.lisp.pamphlet
	@ echo 137 making ${MID}/g-util.lisp from ${IN}/g-util.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/g-util.lisp.pamphlet >g-util.lisp )

@
<<g-util.lisp (OUT from IN)>>=
${OUT}/g-util.lisp: ${IN}/g-util.lisp.pamphlet
	@ echo 221 making ${OUT}/g-util.lisp from ${IN}/g-util.boot.pamphlet
	@ rm -f ${OUT}/g-util.${O}
	@( cd ${OUT} ; \
	   ${TANGLE} ${IN}/g-util.lisp.pamphlet >g-util.lisp )

@

\subsection{http.lisp}
<<http.o (OUT from MID)>>=
${OUT}/http.${O}: ${MID}/http.lisp
	@ echo 367 making ${OUT}/http.${O} from ${MID}/http.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/http.lisp"' \
             ':output-file "${OUT}/http.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/http.lisp"' \
             ':output-file "${OUT}/http.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<http.lisp (MID from IN)>>=
${MID}/http.lisp: ${IN}/http.lisp
	@ echo 368 making ${MID}/http.lisp from ${IN}/http.lisp
	@( cp ${IN}/http.lisp ${MID}/http.lisp )

@

\subsection{i-analy.lisp}
<<i-analy.o (OUT from MID)>>=
${OUT}/i-analy.${O}: ${MID}/i-analy.lisp
	@ echo 136 making ${OUT}/i-analy.${O} from ${MID}/i-analy.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-analy.lisp"' \
             ':output-file "${OUT}/i-analy.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-analy.lisp"' \
             ':output-file "${OUT}/i-analy.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-analy.lisp (MID from IN)>>=
${MID}/i-analy.lisp: ${IN}/i-analy.lisp.pamphlet
	@ echo 137 making ${MID}/i-analy.lisp from ${IN}/i-analy.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-analy.lisp.pamphlet >i-analy.lisp )

@

\subsection{i-code.lisp}
<<i-code.o (OUT from MID)>>=
${OUT}/i-code.${O}: ${MID}/i-code.lisp
	@ echo 136 making ${OUT}/i-code.${O} from ${MID}/i-code.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-code.lisp"' \
             ':output-file "${OUT}/i-code.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-code.lisp"' \
             ':output-file "${OUT}/i-code.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-code.lisp (MID from IN)>>=
${MID}/i-code.lisp: ${IN}/i-code.lisp.pamphlet
	@ echo 137 making ${MID}/i-code.lisp from ${IN}/i-code.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-code.lisp.pamphlet >i-code.lisp )

@

\subsection{i-coerce.lisp}
<<i-coerce.o (OUT from MID)>>=
${OUT}/i-coerce.${O}: ${MID}/i-coerce.lisp
	@ echo 136 making ${OUT}/i-coerce.${O} from ${MID}/i-coerce.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-coerce.lisp"' \
             ':output-file "${OUT}/i-coerce.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-coerce.lisp"' \
             ':output-file "${OUT}/i-coerce.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-coerce.lisp (MID from IN)>>=
${MID}/i-coerce.lisp: ${IN}/i-coerce.lisp.pamphlet
	@ echo 137 making ${MID}/i-coerce.lisp from \
          ${IN}/i-coerce.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-coerce.lisp.pamphlet >i-coerce.lisp )

@

\subsection{i-coerfn.lisp}
<<i-coerfn.o (OUT from MID)>>=
${OUT}/i-coerfn.${O}: ${MID}/i-coerfn.lisp
	@ echo 136 making ${OUT}/i-coerfn.${O} from ${MID}/i-coerfn.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-coerfn.lisp"' \
             ':output-file "${OUT}/i-coerfn.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-coerfn.lisp"' \
             ':output-file "${OUT}/i-coerfn.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-coerfn.lisp (MID from IN)>>=
${MID}/i-coerfn.lisp: ${IN}/i-coerfn.lisp.pamphlet
	@ echo 137 making ${MID}/i-coerfn.lisp from \
          ${IN}/i-coerfn.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-coerfn.lisp.pamphlet >i-coerfn.lisp )

@

\subsection{i-eval.lisp}
<<i-eval.o (OUT from MID)>>=
${OUT}/i-eval.${O}: ${MID}/i-eval.lisp
	@ echo 136 making ${OUT}/i-eval.${O} from ${MID}/i-eval.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-eval.lisp"' \
             ':output-file "${OUT}/i-eval.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-eval.lisp"' \
             ':output-file "${OUT}/i-eval.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-eval.lisp (MID from IN)>>=
${MID}/i-eval.lisp: ${IN}/i-eval.lisp.pamphlet
	@ echo 137 making ${MID}/i-eval.lisp from \
          ${IN}/i-eval.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-eval.lisp.pamphlet >i-eval.lisp )

@

\subsection{i-funsel.lisp}
<<i-funsel.o (OUT from MID)>>=
${OUT}/i-funsel.${O}: ${MID}/i-funsel.lisp
	@ echo 136 making ${OUT}/i-funsel.${O} from ${MID}/i-funsel.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-funsel.lisp"' \
             ':output-file "${OUT}/i-funsel.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-funsel.lisp"' \
             ':output-file "${OUT}/i-funsel.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-funsel.lisp (MID from IN)>>=
${MID}/i-funsel.lisp: ${IN}/i-funsel.lisp.pamphlet
	@ echo 137 making ${MID}/i-funsel.lisp from \
          ${IN}/i-funsel.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-funsel.lisp.pamphlet >i-funsel.lisp )

@

\subsection{bookvol5.lsp}
<<bookvol5.o (OUT from MID)>>=
${OUT}/bookvol5.${O}: ${MID}/bookvol5.${LISP}
	@ echo 297 making ${OUT}/bookvol5.${O} from ${MID}/bookvol5.${LISP}
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/bookvol5.${LISP}"' \
             ':output-file "${OUT}/bookvol5.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/bookvol5.${LISP}"' \
             ':output-file "${OUT}/bookvol5.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<bookvol5.lsp (OUT from MID)>>=
${OUT}/bookvol5.${LISP}: ${MID}/bookvol5.${LISP}
	@ echo 133 making ${OUT}/bookvol5.${LISP} from ${MID}/bookvol5.${LISP}
	@cp ${MID}/bookvol5.${LISP} ${OUT}/bookvol5.${LISP}

@
<<bookvol5.lsp (MID from IN)>>=
${MID}/bookvol5.${LISP}: ${IN}/bookvol5.pamphlet
	@ echo 298 making ${MID}/bookvol5.${LISP} from ${IN}/bookvol5.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} -RInterpreter ${IN}/bookvol5.pamphlet >bookvol5.${LISP} )

@
\subsection{bookvol9.lsp}
<<bookvol9.o (OUT from MID)>>=
${OUT}/bookvol9.${O}: ${MID}/bookvol9.${LISP}
	@ echo 297 making ${OUT}/bookvol9.${O} from ${MID}/bookvol9.${LISP}
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/bookvol9.${LISP}"' \
             ':output-file "${OUT}/bookvol9.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/bookvol9.${LISP}"' \
             ':output-file "${OUT}/bookvol9.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<bookvol9.lsp (OUT from MID)>>=
${OUT}/bookvol9.${LISP}: ${MID}/bookvol9.${LISP}
	@ echo 133 making ${OUT}/bookvol9.${LISP} from ${MID}/bookvol9.${LISP}
	@cp ${MID}/bookvol9.${LISP} ${OUT}/bookvol9.${LISP}

@
<<bookvol9.lsp (MID from IN)>>=
${MID}/bookvol9.${LISP}: ${IN}/bookvol9.pamphlet
	@ echo 298 making ${MID}/bookvol9.${LISP} from ${IN}/bookvol9.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} -RCompiler ${IN}/bookvol9.pamphlet >bookvol9.${LISP} )

@
\subsection{i-intern.lisp}
<<i-intern.o (OUT from MID)>>=
${OUT}/i-intern.${O}: ${MID}/i-intern.lisp
	@ echo 136 making ${OUT}/i-intern.${O} from ${MID}/i-intern.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-intern.lisp"' \
             ':output-file "${OUT}/i-intern.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-intern.lisp"' \
             ':output-file "${OUT}/i-intern.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-intern.lisp (MID from IN)>>=
${MID}/i-intern.lisp: ${IN}/i-intern.lisp.pamphlet
	@ echo 137 making ${MID}/i-intern.lisp from \
          ${IN}/i-intern.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-intern.lisp.pamphlet >i-intern.lisp )

@

\subsection{i-map.lisp}
<<i-map.o (OUT from MID)>>=
${OUT}/i-map.${O}: ${MID}/i-map.lisp
	@ echo 136 making ${OUT}/i-map.${O} from ${MID}/i-map.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-map.lisp"' \
             ':output-file "${OUT}/i-map.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-map.lisp"' \
             ':output-file "${OUT}/i-map.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-map.lisp (MID from IN)>>=
${MID}/i-map.lisp: ${IN}/i-map.lisp.pamphlet
	@ echo 137 making ${MID}/i-map.lisp from \
          ${IN}/i-map.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-map.lisp.pamphlet >i-map.lisp )

@

\subsection{i-output.lisp}
<<i-output.o (OUT from MID)>>=
${OUT}/i-output.${O}: ${MID}/i-output.lisp
	@ echo 136 making ${OUT}/i-output.${O} from ${MID}/i-output.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-output.lisp"' \
             ':output-file "${OUT}/i-output.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-output.lisp"' \
             ':output-file "${OUT}/i-output.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-output.lisp (MID from IN)>>=
${MID}/i-output.lisp: ${IN}/i-output.lisp.pamphlet
	@ echo 137 making ${MID}/i-output.lisp from \
          ${IN}/i-output.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-output.lisp.pamphlet >i-output.lisp )

@

\subsection{i-resolv.lisp}
<<i-resolv.o (OUT from MID)>>=
${OUT}/i-resolv.${O}: ${MID}/i-resolv.lisp
	@ echo 136 making ${OUT}/i-resolv.${O} from ${MID}/i-resolv.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-resolv.lisp"' \
             ':output-file "${OUT}/i-resolv.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-resolv.lisp"' \
             ':output-file "${OUT}/i-resolv.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-resolv.lisp (MID from IN)>>=
${MID}/i-resolv.lisp: ${IN}/i-resolv.lisp.pamphlet
	@ echo 137 making ${MID}/i-resolv.lisp from \
          ${IN}/i-resolv.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-resolv.lisp.pamphlet >i-resolv.lisp )

@

\subsection{i-spec1.lisp}
<<i-spec1.o (OUT from MID)>>=
${OUT}/i-spec1.${O}: ${MID}/i-spec1.lisp
	@ echo 136 making ${OUT}/i-spec1.${O} from ${MID}/i-spec1.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-spec1.lisp"' \
             ':output-file "${OUT}/i-spec1.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-spec1.lisp"' \
             ':output-file "${OUT}/i-spec1.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-spec1.lisp (MID from IN)>>=
${MID}/i-spec1.lisp: ${IN}/i-spec1.lisp.pamphlet
	@ echo 137 making ${MID}/i-spec1.lisp from \
          ${IN}/i-spec1.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-spec1.lisp.pamphlet >i-spec1.lisp )

@

\subsection{i-spec2.lisp}
<<i-spec2.o (OUT from MID)>>=
${OUT}/i-spec2.${O}: ${MID}/i-spec2.lisp
	@ echo 136 making ${OUT}/i-spec2.${O} from ${MID}/i-spec2.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-spec2.lisp"' \
             ':output-file "${OUT}/i-spec2.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-spec2.lisp"' \
             ':output-file "${OUT}/i-spec2.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-spec2.lisp (MID from IN)>>=
${MID}/i-spec2.lisp: ${IN}/i-spec2.lisp.pamphlet
	@ echo 137 making ${MID}/i-spec2.lisp from \
          ${IN}/i-spec2.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-spec2.lisp.pamphlet >i-spec2.lisp )

@

\subsection{i-syscmd.lisp}
<<i-syscmd.o (OUT from MID)>>=
${OUT}/i-syscmd.${O}: ${MID}/i-syscmd.lisp
	@ echo 136 making ${OUT}/i-syscmd.${O} from ${MID}/i-syscmd.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-syscmd.lisp"' \
             ':output-file "${OUT}/i-syscmd.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-syscmd.lisp"' \
             ':output-file "${OUT}/i-syscmd.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-syscmd.lisp (MID from IN)>>=
${MID}/i-syscmd.lisp: ${IN}/i-syscmd.lisp.pamphlet
	@ echo 137 making ${MID}/i-syscmd.lisp from \
          ${IN}/i-syscmd.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-syscmd.lisp.pamphlet >i-syscmd.lisp )

@

\subsection{i-toplev.lisp}
<<i-toplev.o (OUT from MID)>>=
${OUT}/i-toplev.${O}: ${MID}/i-toplev.lisp
	@ echo 136 making ${OUT}/i-toplev.${O} from ${MID}/i-toplev.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-toplev.lisp"' \
             ':output-file "${OUT}/i-toplev.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-toplev.lisp"' \
             ':output-file "${OUT}/i-toplev.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-toplev.lisp (MID from IN)>>=
${MID}/i-toplev.lisp: ${IN}/i-toplev.lisp.pamphlet
	@ echo 137 making ${MID}/i-toplev.lisp from \
          ${IN}/i-toplev.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-toplev.lisp.pamphlet >i-toplev.lisp )

@

\subsection{i-util.lisp}
<<i-util.o (OUT from MID)>>=
${OUT}/i-util.${O}: ${MID}/i-util.lisp
	@ echo 136 making ${OUT}/i-util.${O} from ${MID}/i-util.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/i-util.lisp"' \
             ':output-file "${OUT}/i-util.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/i-util.lisp"' \
             ':output-file "${OUT}/i-util.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<i-util.lisp (MID from IN)>>=
${MID}/i-util.lisp: ${IN}/i-util.lisp.pamphlet
	@ echo 137 making ${MID}/i-util.lisp from \
          ${IN}/i-util.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/i-util.lisp.pamphlet >i-util.lisp )

@

\subsection{info.lisp}
<<info.o (OUT from MID)>>=
${OUT}/info.${O}: ${MID}/info.lisp
	@ echo 136 making ${OUT}/info.${O} from ${MID}/info.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/info.lisp"' \
             ':output-file "${OUT}/info.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/info.lisp"' \
             ':output-file "${OUT}/info.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<info.lisp (MID from IN)>>=
${MID}/info.lisp: ${IN}/info.lisp.pamphlet
	@ echo 137 making ${MID}/info.lisp from ${IN}/info.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/info.lisp.pamphlet >info.lisp )

@

\subsection{iterator.lisp}
<<iterator.o (OUT from MID)>>=
${OUT}/iterator.${O}: ${MID}/iterator.lisp
	@ echo 136 making ${OUT}/iterator.${O} from ${MID}/iterator.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/iterator.lisp"' \
             ':output-file "${OUT}/iterator.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/iterator.lisp"' \
             ':output-file "${OUT}/iterator.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<iterator.lisp (MID from IN)>>=
${MID}/iterator.lisp: ${IN}/iterator.lisp.pamphlet
	@ echo 137 making ${MID}/iterator.lisp from \
           ${IN}/iterator.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/iterator.lisp.pamphlet >iterator.lisp )

@

\subsection{lisplib.lisp}
<<lisplib.o (OUT from MID)>>=
${OUT}/lisplib.${O}: ${MID}/lisplib.lisp
	@ echo 136 making ${OUT}/lisplib.${O} from ${MID}/lisplib.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/lisplib.lisp"' \
             ':output-file "${OUT}/lisplib.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/lisplib.lisp"' \
             ':output-file "${OUT}/lisplib.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<lisplib.lisp (MID from IN)>>=
${MID}/lisplib.lisp: ${IN}/lisplib.lisp.pamphlet
	@ echo 137 making ${MID}/lisplib.lisp from ${IN}/lisplib.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/lisplib.lisp.pamphlet >lisplib.lisp )

@

\subsection{match.lisp}
<<match.o (OUT from MID)>>=
${OUT}/match.${O}: ${MID}/match.lisp
	@ echo 136 making ${OUT}/match.${O} from ${MID}/match.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/match.lisp"' \
             ':output-file "${OUT}/match.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/match.lisp"' \
             ':output-file "${OUT}/match.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<match.lisp (MID from IN)>>=
${MID}/match.lisp: ${IN}/match.lisp.pamphlet
	@ echo 137 making ${MID}/match.lisp from ${IN}/match.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/match.lisp.pamphlet >match.lisp )

@

\subsection{modemap.lisp}
<<modemap.o (OUT from MID)>>=
${OUT}/modemap.${O}: ${MID}/modemap.lisp
	@ echo 136 making ${OUT}/modemap.${O} from ${MID}/modemap.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/modemap.lisp"' \
             ':output-file "${OUT}/modemap.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/modemap.lisp"' \
             ':output-file "${OUT}/modemap.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<modemap.lisp (MID from IN)>>=
${MID}/modemap.lisp: ${IN}/modemap.lisp.pamphlet
	@ echo 137 making ${MID}/modemap.lisp from ${IN}/modemap.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/modemap.lisp.pamphlet >modemap.lisp )

@

\subsection{msgdb.lisp}
<<msgdb.o (OUT from MID)>>=
${OUT}/msgdb.${O}: ${MID}/msgdb.lisp
	@ echo 136 making ${OUT}/msgdb.${O} from ${MID}/msgdb.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/msgdb.lisp"' \
             ':output-file "${OUT}/msgdb.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/msgdb.lisp"' \
             ':output-file "${OUT}/msgdb.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<msgdb.lisp (MID from IN)>>=
${MID}/msgdb.lisp: ${IN}/msgdb.lisp.pamphlet
	@ echo 137 making ${MID}/msgdb.lisp from ${IN}/msgdb.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/msgdb.lisp.pamphlet >msgdb.lisp )

@

\subsection{newfort.lisp}
<<newfort.o (OUT from MID)>>=
${OUT}/newfort.${O}: ${MID}/newfort.lisp
	@ echo 136 making ${OUT}/newfort.${O} from ${MID}/newfort.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/newfort.lisp"' \
             ':output-file "${OUT}/newfort.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/newfort.lisp"' \
             ':output-file "${OUT}/newfort.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<newfort.lisp (MID from IN)>>=
${MID}/newfort.lisp: ${IN}/newfort.lisp.pamphlet
	@ echo 137 making ${MID}/newfort.lisp from ${IN}/newfort.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/newfort.lisp.pamphlet >newfort.lisp )

@

\subsection{nruncomp.boot}
<<nruncomp.o (AUTO from OUT)>>=
${AUTO}/nruncomp.${O}: ${OUT}/nruncomp.${O}
	@ echo 351 making ${AUTO}/nruncomp.${O} from ${OUT}/nruncomp.${O}
	@ cp ${OUT}/nruncomp.${O} ${AUTO}

@
<<nruncomp.o (OUT from MID)>>=
${OUT}/nruncomp.${O}: ${MID}/nruncomp.clisp 
	@ echo 352 making ${OUT}/nruncomp.${O} from ${MID}/nruncomp.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/nruncomp.clisp"' \
             ':output-file "${OUT}/nruncomp.${O}") (${BYE}))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/nruncomp.clisp"' \
             ':output-file "${OUT}/nruncomp.${O}") (${BYE}))' |  ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nruncomp.clisp (MID from IN)>>=
${MID}/nruncomp.clisp: ${IN}/nruncomp.boot.pamphlet
	@ echo 353 making ${MID}/nruncomp.clisp \
                   from ${IN}/nruncomp.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/nruncomp.boot.pamphlet >nruncomp.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "nruncomp.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "nruncomp.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm nruncomp.boot )

@

\subsection{nrunfast.lisp}
<<nrunfast.o (OUT from MID)>>=
${OUT}/nrunfast.${O}: ${MID}/nrunfast.lisp
	@ echo 136 making ${OUT}/nrunfast.${O} from ${MID}/nrunfast.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/nrunfast.lisp"' \
             ':output-file "${OUT}/nrunfast.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/nrunfast.lisp"' \
             ':output-file "${OUT}/nrunfast.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nrunfast.lisp (MID from IN)>>=
${MID}/nrunfast.lisp: ${IN}/nrunfast.lisp.pamphlet
	@ echo 137 making ${MID}/nrunfast.lisp from \
           ${IN}/nrunfast.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/nrunfast.lisp.pamphlet >nrunfast.lisp )

@

\subsection{nrungo.lisp}
<<nrungo.o (OUT from MID)>>=
${OUT}/nrungo.${O}: ${MID}/nrungo.lisp
	@ echo 136 making ${OUT}/nrungo.${O} from ${MID}/nrungo.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/nrungo.lisp"' \
             ':output-file "${OUT}/nrungo.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/nrungo.lisp"' \
             ':output-file "${OUT}/nrungo.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nrungo.lisp (MID from IN)>>=
${MID}/nrungo.lisp: ${IN}/nrungo.lisp.pamphlet
	@ echo 137 making ${MID}/nrungo.lisp from ${IN}/nrungo.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/nrungo.lisp.pamphlet >nrungo.lisp )

@

\subsection{nruntime.lisp}
<<nruntime.o (OUT from MID)>>=
${OUT}/nruntime.${O}: ${MID}/nruntime.lisp
	@ echo 136 making ${OUT}/nruntime.${O} from ${MID}/nruntime.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/nruntime.lisp"' \
             ':output-file "${OUT}/nruntime.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/nruntime.lisp"' \
             ':output-file "${OUT}/nruntime.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nruntime.lisp (MID from IN)>>=
${MID}/nruntime.lisp: ${IN}/nruntime.lisp.pamphlet
	@ echo 137 making ${MID}/nruntime.lisp from \
             ${IN}/nruntime.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/nruntime.lisp.pamphlet >nruntime.lisp )

@

\subsection{nrunopt.lisp}
<<nrunopt.o (OUT from MID)>>=
${OUT}/nrunopt.${O}: ${MID}/nrunopt.lisp
	@ echo 136 making ${OUT}/nrunopt.${O} from ${MID}/nrunopt.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/nrunopt.lisp"' \
             ':output-file "${OUT}/nrunopt.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/nrunopt.lisp"' \
             ':output-file "${OUT}/nrunopt.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<nrunopt.lisp (MID from IN)>>=
${MID}/nrunopt.lisp: ${IN}/nrunopt.lisp.pamphlet
	@ echo 137 making ${MID}/nrunopt.lisp from ${IN}/nrunopt.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/nrunopt.lisp.pamphlet >nrunopt.lisp )

@

\subsection{obey.lisp}
<<obey.o (OUT from MID)>>=
${OUT}/obey.${O}: ${MID}/obey.${LISP}
	@ echo 367 making ${OUT}/obey.${O} from ${MID}/obey.${LISP}
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/obey.${LISP}"' \
             ':output-file "${OUT}/obey.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/obey.${LISP}"' \
             ':output-file "${OUT}/obey.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<obey.lisp (MID from IN)>>=
${MID}/obey.${LISP}: ${IN}/obey.lisp.pamphlet
	@ echo 368 making ${MID}/obey.${LISP} from ${IN}/obey.lisp.pamphlet
	@(cd ${MID} ; \
	${TANGLE} ${IN}/obey.lisp.pamphlet >obey.${LISP} )

@

\subsection{package.lisp}
<<package.o (OUT from MID)>>=
${OUT}/package.${O}: ${MID}/package.lisp
	@ echo 136 making ${OUT}/package.${O} from ${MID}/package.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/package.lisp"' \
             ':output-file "${OUT}/package.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/package.lisp"' \
             ':output-file "${OUT}/package.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<package.lisp (MID from IN)>>=
${MID}/package.lisp: ${IN}/package.lisp.pamphlet
	@ echo 137 making ${MID}/package.lisp from ${IN}/package.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/package.lisp.pamphlet >package.lisp )

@

\subsection{pathname.lisp}
<<pathname.o (OUT from MID)>>=
${OUT}/pathname.${O}: ${MID}/pathname.lisp
	@ echo 136 making ${OUT}/pathname.${O} from ${MID}/pathname.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/pathname.lisp"' \
             ':output-file "${OUT}/pathname.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/pathname.lisp"' \
             ':output-file "${OUT}/pathname.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<pathname.lisp (MID from IN)>>=
${MID}/pathname.lisp: ${IN}/pathname.lisp.pamphlet
	@ echo 137 making ${MID}/pathname.lisp from \
           ${IN}/pathname.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/pathname.lisp.pamphlet >pathname.lisp )

@

\subsection{regress.lisp}
<<regress.o (OUT from MID)>>=
${OUT}/regress.${O}: ${MID}/regress.${LISP}
	@ echo 367 making ${OUT}/regress.${O} from ${MID}/regress.${LISP}
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/regress.${LISP}"' \
             ':output-file "${OUT}/regress.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/regress.${LISP}"' \
             ':output-file "${OUT}/regress.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<regress.lisp (MID from IN)>>=
${MID}/regress.${LISP}: ${IN}/regress.lisp.pamphlet
	@ echo 368 making ${MID}/regress.${LISP} from \
                          ${IN}/regress.lisp.pamphlet
	@(cd ${MID} ; \
	${TANGLE} ${IN}/regress.lisp.pamphlet >regress.${LISP} )

@

\subsection{rulesets.lisp}
<<rulesets.o (OUT from MID)>>=
${OUT}/rulesets.${O}: ${MID}/rulesets.lisp
	@ echo 136 making ${OUT}/rulesets.${O} from ${MID}/rulesets.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/rulesets.lisp"' \
             ':output-file "${OUT}/rulesets.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/rulesets.lisp"' \
             ':output-file "${OUT}/rulesets.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<rulesets.lisp (MID from IN)>>=
${MID}/rulesets.lisp: ${IN}/rulesets.lisp.pamphlet
	@ echo 137 making ${MID}/rulesets.lisp from \
           ${IN}/rulesets.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/rulesets.lisp.pamphlet >rulesets.lisp )

@

\subsection{server.lisp}
<<server.o (OUT from MID)>>=
${OUT}/server.${O}: ${MID}/server.lisp
	@ echo 136 making ${OUT}/server.${O} from ${MID}/server.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/server.lisp"' \
             ':output-file "${OUT}/server.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/server.lisp"' \
             ':output-file "${OUT}/server.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<server.lisp (MID from IN)>>=
${MID}/server.lisp: ${IN}/server.lisp.pamphlet
	@ echo 137 making ${MID}/server.lisp from ${IN}/server.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/server.lisp.pamphlet >server.lisp )

@

\subsection{simpbool.lisp}
<<simpbool.o (OUT from MID)>>=
${OUT}/simpbool.${O}: ${MID}/simpbool.lisp
	@ echo 136 making ${OUT}/simpbool.${O} from ${MID}/simpbool.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/simpbool.lisp"' \
             ':output-file "${OUT}/simpbool.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/simpbool.lisp"' \
             ':output-file "${OUT}/simpbool.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<simpbool.lisp (MID from IN)>>=
${MID}/simpbool.lisp: ${IN}/simpbool.lisp.pamphlet
	@ echo 137 making ${MID}/simpbool.lisp from \
           ${IN}/simpbool.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/simpbool.lisp.pamphlet >simpbool.lisp )

@

\subsection{slam.lisp \cite{30}}
<<slam.lisp (AUTO from OUT)>>=
${AUTO}/slam.lisp: ${OUT}/slam.lisp
	@ echo 102 making ${AUTO}/slam.lisp from ${OUT}/slam.lisp
	@ cp ${OUT}/slam.lisp ${AUTO}

@
<<slam.lisp (OUT from MID)>>=
${OUT}/slam.lisp: ${MID}/slam.lisp
	@ echo 103 making ${OUT}/slam.lisp from ${MID}/slam.lisp
	@ rm -f ${OUT}/slam.${O}
	@ cp ${MID}/slam.lisp ${OUT}/slam.lisp

@
<<slam.lisp (MID from IN)>>=
${MID}/slam.lisp: ${IN}/slam.lisp.pamphlet
	@ echo 104 making ${MID}/slam.lisp \
                   from ${IN}/slam.lisp.pamphlet
	@ (cd ${MID} ; \
	${TANGLE} ${IN}/slam.lisp.pamphlet >slam.lisp )

@

\subsection{template.lisp}
<<template.o (OUT from MID)>>=
${OUT}/template.${O}: ${MID}/template.lisp
	@ echo 136 making ${OUT}/template.${O} from ${MID}/template.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/template.lisp"' \
             ':output-file "${OUT}/template.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/template.lisp"' \
             ':output-file "${OUT}/template.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<template.lisp (MID from IN)>>=
${MID}/template.lisp: ${IN}/template.lisp.pamphlet
	@ echo 137 making ${MID}/template.lisp from \
           ${IN}/template.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/template.lisp.pamphlet >template.lisp )

@

\subsection{termrw.lisp}
<<termrw.o (OUT from MID)>>=
${OUT}/termrw.${O}: ${MID}/termrw.lisp
	@ echo 136 making ${OUT}/termrw.${O} from ${MID}/termrw.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/termrw.lisp"' \
             ':output-file "${OUT}/termrw.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/termrw.lisp"' \
             ':output-file "${OUT}/termrw.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<termrw.lisp (MID from IN)>>=
${MID}/termrw.lisp: ${IN}/termrw.lisp.pamphlet
	@ echo 137 making ${MID}/termrw.lisp from ${IN}/termrw.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/termrw.lisp.pamphlet >termrw.lisp )

@

\subsection{as.boot}
<<as.o (OUT from MID)>>=
${OUT}/as.${O}: ${MID}/as.clisp 
	@ echo 416 making ${OUT}/as.${O} from ${MID}/as.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/as.clisp"' \
             ':output-file "${OUT}/as.${O}") (${BYE}))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/as.clisp"' \
             ':output-file "${OUT}/as.${O}") (${BYE}))' |  ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<as.clisp (MID from IN)>>=
${MID}/as.clisp: ${IN}/as.boot.pamphlet
	@ echo 417 making ${MID}/as.clisp from ${IN}/as.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/as.boot.pamphlet >as.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "as.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "as.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm as.boot )

@

\subsection{bc-matrix.boot}
<<bc-matrix.o (AUTO from OUT)>>=
${AUTO}/bc-matrix.${O}: ${OUT}/bc-matrix.${O}
	@ echo 422 making ${AUTO}/bc-matrix.${O} from ${OUT}/bc-matrix.${O}
	@ cp ${OUT}/bc-matrix.${O} ${AUTO}

@
<<bc-matrix.o (OUT from MID)>>=
${OUT}/bc-matrix.${O}: ${MID}/bc-matrix.clisp 
	@ echo 423 making ${OUT}/bc-matrix.${O} from ${MID}/bc-matrix.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/bc-matrix.clisp"' \
             ':output-file "${OUT}/bc-matrix.${O}") (${BYE}))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/bc-matrix.clisp"' \
             ':output-file "${OUT}/bc-matrix.${O}") (${BYE}))' |  ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<bc-matrix.clisp (MID from IN)>>=
${MID}/bc-matrix.clisp: ${IN}/bc-matrix.boot.pamphlet
	@ echo 424 making ${MID}/bc-matrix.clisp \
                   from ${IN}/bc-matrix.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/bc-matrix.boot.pamphlet >bc-matrix.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "bc-matrix.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "bc-matrix.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm bc-matrix.boot )

@

\subsection{ht-util.boot}
<<ht-util.o (AUTO from OUT)>>=
${AUTO}/ht-util.${O}: ${OUT}/ht-util.${O}
	@ echo 438 making ${AUTO}/ht-util.${O} from ${OUT}/ht-util.${O}
	@ cp ${OUT}/ht-util.${O} ${AUTO}

@
<<ht-util.o (OUT from MID)>>=
${OUT}/ht-util.${O}: ${MID}/ht-util.clisp 
	@ echo 439 making ${OUT}/ht-util.${O} from ${MID}/ht-util.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/ht-util.clisp"' \
             ':output-file "${OUT}/ht-util.${O}") (${BYE}))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/ht-util.clisp"' \
             ':output-file "${OUT}/ht-util.${O}") (${BYE}))' |  ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<ht-util.clisp (MID from IN)>>=
${MID}/ht-util.clisp: ${IN}/ht-util.boot.pamphlet
	@ echo 440 making ${MID}/ht-util.clisp from ${IN}/ht-util.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/ht-util.boot.pamphlet >ht-util.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "ht-util.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "ht-util.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm ht-util.boot )

@

\subsection{record.lisp}
<<record.o (OUT from MID)>>=
${OUT}/record.${O}: ${MID}/record.lisp
	@ echo 136 making ${OUT}/record.${O} from ${MID}/record.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/record.lisp"' \
             ':output-file "${OUT}/record.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/record.lisp"' \
             ':output-file "${OUT}/record.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<record.lisp (MID from IN)>>=
${MID}/record.lisp: ${IN}/record.lisp.pamphlet
	@ echo 137 making ${MID}/record.lisp from ${IN}/record.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/record.lisp.pamphlet >record.lisp )

@

\subsection{htcheck.lisp}
<<htcheck.o (OUT from MID)>>=
${OUT}/htcheck.${O}: ${MID}/htcheck.lisp
	@ echo 136 making ${OUT}/htcheck.${O} from ${MID}/htcheck.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/htcheck.lisp"' \
             ':output-file "${OUT}/htcheck.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/htcheck.lisp"' \
             ':output-file "${OUT}/htcheck.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<htcheck.lisp (MID from IN)>>=
${MID}/htcheck.lisp: ${IN}/htcheck.lisp.pamphlet
	@ echo 137 making ${MID}/htcheck.lisp from ${IN}/htcheck.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/htcheck.lisp.pamphlet >htcheck.lisp )

@

\subsection{ax.boot}
<<ax.o (AUTO from OUT)>>=
${AUTO}/ax.${O}: ${OUT}/ax.${O}
	@ echo 461 making ${AUTO}/ax.${O} from ${OUT}/ax.${O}
	@ cp ${OUT}/ax.${O} ${AUTO}

@
<<ax.o (OUT from MID)>>=
${OUT}/ax.${O}: ${MID}/ax.clisp 
	@ echo 462 making ${OUT}/ax.${O} from ${MID}/ax.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/ax.clisp"' \
             ':output-file "${OUT}/ax.${O}") (${BYE}))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/ax.clisp"' \
             ':output-file "${OUT}/ax.${O}") (${BYE}))' |  ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<ax.clisp (MID from IN)>>=
${MID}/ax.clisp: ${IN}/ax.boot.pamphlet
	@ echo 463 making ${MID}/ax.clisp from ${IN}/ax.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/ax.boot.pamphlet >ax.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "ax.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "ax.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm ax.boot )

@

\subsection{br-con.boot}
<<br-con.o (AUTO from OUT)>>=
${AUTO}/br-con.${O}: ${OUT}/br-con.${O}
	@ echo 465 making ${AUTO}/br-con.${O} from ${OUT}/br-con.${O}
	@ cp ${OUT}/br-con.${O} ${AUTO}

@
<<br-con.o (OUT from MID)>>=
${OUT}/br-con.${O}: ${MID}/br-con.clisp 
	@ echo 466 making ${OUT}/br-con.${O} from ${MID}/br-con.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/br-con.clisp"' \
             ':output-file "${OUT}/br-con.${O}") (${BYE}))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/br-con.clisp"' \
             ':output-file "${OUT}/br-con.${O}") (${BYE}))' |  ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<br-con.clisp (MID from IN)>>=
${MID}/br-con.clisp: ${IN}/br-con.boot.pamphlet
	@ echo 467 making ${MID}/br-con.clisp from ${IN}/br-con.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/br-con.boot.pamphlet >br-con.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-con.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-con.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm br-con.boot )

@

\subsection{topics.boot}
<<topics.o (AUTO from OUT)>>=
${AUTO}/topics.${O}: ${OUT}/topics.${O}
	@ echo 493 making ${AUTO}/topics.${O} from ${OUT}/topics.${O}
	@ cp ${OUT}/topics.${O} ${AUTO}

@
<<topics.o (OUT from MID)>>=
${OUT}/topics.${O}: ${MID}/topics.clisp 
	@ echo 494 making ${OUT}/topics.${O} from ${MID}/topics.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/topics.clisp"' \
             ':output-file "${OUT}/topics.${O}") (${BYE}))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/topics.clisp"' \
             ':output-file "${OUT}/topics.${O}") (${BYE}))' |  ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<topics.clisp (MID from IN)>>=
${MID}/topics.clisp: ${IN}/topics.boot.pamphlet
	@ echo 495 making ${MID}/topics.clisp from ${IN}/topics.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/topics.boot.pamphlet >topics.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "topics.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "topics.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm topics.boot )

@

\subsection{incl.lisp}
<<incl.o (OUT from MID)>>=
${OUT}/incl.${O}: ${MID}/incl.lisp
	@ echo 136 making ${OUT}/incl.${O} from ${MID}/incl.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/incl.lisp"' \
             ':output-file "${OUT}/incl.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/incl.lisp"' \
             ':output-file "${OUT}/incl.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<incl.lisp (MID from IN)>>=
${MID}/incl.lisp: ${IN}/incl.lisp.pamphlet
	@ echo 137 making ${MID}/incl.lisp from ${IN}/incl.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/incl.lisp.pamphlet >incl.lisp )

@

\subsection{scan.lisp}
<<scan.o (OUT from MID)>>=
${OUT}/scan.${O}: ${MID}/scan.lisp
	@ echo 136 making ${OUT}/scan.${O} from ${MID}/scan.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/scan.lisp"' \
             ':output-file "${OUT}/scan.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/scan.lisp"' \
             ':output-file "${OUT}/scan.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<scan.lisp (MID from IN)>>=
${MID}/scan.lisp: ${IN}/scan.lisp.pamphlet
	@ echo 137 making ${MID}/scan.lisp from ${IN}/scan.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/scan.lisp.pamphlet >scan.lisp )

@

\subsection{pile.lisp}
<<pile.o (OUT from MID)>>=
${OUT}/pile.${O}: ${MID}/pile.lisp
	@ echo 136 making ${OUT}/pile.${O} from ${MID}/pile.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/pile.lisp"' \
             ':output-file "${OUT}/pile.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/pile.lisp"' \
             ':output-file "${OUT}/pile.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<pile.lisp (MID from IN)>>=
${MID}/pile.lisp: ${IN}/pile.lisp.pamphlet
	@ echo 137 making ${MID}/pile.lisp from ${IN}/pile.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/pile.lisp.pamphlet >pile.lisp )

@

\subsection{cparse.lisp}
<<cparse.o (OUT from MID)>>=
${OUT}/cparse.${O}: ${MID}/cparse.lisp
	@ echo 136 making ${OUT}/cparse.${O} from ${MID}/cparse.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/cparse.lisp"' \
             ':output-file "${OUT}/cparse.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/cparse.lisp"' \
             ':output-file "${OUT}/cparse.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<cparse.lisp (MID from IN)>>=
${MID}/cparse.lisp: ${IN}/cparse.lisp.pamphlet
	@ echo 137 making ${MID}/cparse.lisp from ${IN}/cparse.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/cparse.lisp.pamphlet >cparse.lisp )

@

\subsection{macex.lisp}
<<macex.o (OUT from MID)>>=
${OUT}/macex.${O}: ${MID}/macex.lisp
	@ echo 136 making ${OUT}/macex.${O} from ${MID}/macex.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/macex.lisp"' \
             ':output-file "${OUT}/macex.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/macex.lisp"' \
             ':output-file "${OUT}/macex.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<macex.lisp (MID from IN)>>=
${MID}/macex.lisp: ${IN}/macex.lisp.pamphlet
	@ echo 137 making ${MID}/macex.lisp from ${IN}/macex.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/macex.lisp.pamphlet >macex.lisp )

@

\subsection{ptrees.lisp}
<<ptrees.o (OUT from MID)>>=
${OUT}/ptrees.${O}: ${MID}/ptrees.lisp
	@ echo 136 making ${OUT}/ptrees.${O} from ${MID}/ptrees.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/ptrees.lisp"' \
             ':output-file "${OUT}/ptrees.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/ptrees.lisp"' \
             ':output-file "${OUT}/ptrees.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<ptrees.lisp (MID from IN)>>=
${MID}/ptrees.lisp: ${IN}/ptrees.lisp.pamphlet
	@ echo 137 making ${MID}/ptrees.lisp from ${IN}/ptrees.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/ptrees.lisp.pamphlet >ptrees.lisp )

@

\subsection{ptrop.lisp}
<<ptrop.o (OUT from MID)>>=
${OUT}/ptrop.${O}: ${MID}/ptrop.lisp
	@ echo 136 making ${OUT}/ptrop.${O} from ${MID}/ptrop.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/ptrop.lisp"' \
             ':output-file "${OUT}/ptrop.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/ptrop.lisp"' \
             ':output-file "${OUT}/ptrop.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<ptrop.lisp (MID from IN)>>=
${MID}/ptrop.lisp: ${IN}/ptrop.lisp.pamphlet
	@ echo 137 making ${MID}/ptrop.lisp from ${IN}/ptrop.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/ptrop.lisp.pamphlet >ptrop.lisp )

@

\subsection{dq.lisp}
<<dq.o (OUT from MID)>>=
${OUT}/dq.${O}: ${MID}/dq.lisp
	@ echo 531 making ${OUT}/dq.${O} from ${MID}/dq.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/dq.lisp"' \
             ':output-file "${OUT}/dq.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/dq.lisp"' \
             ':output-file "${OUT}/dq.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<dq.lisp (MID from IN)>>=
${MID}/dq.lisp: ${IN}/dq.lisp.pamphlet
	@ echo 532 making ${MID}/dq.lisp from ${IN}/dq.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/dq.lisp.pamphlet >dq.lisp )

@

\subsection{cstream.lisp}
<<cstream.o (OUT from MID)>>=
${OUT}/cstream.${O}: ${MID}/cstream.lisp
	@ echo 136 making ${OUT}/cstream.${O} from ${MID}/cstream.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/cstream.lisp"' \
             ':output-file "${OUT}/cstream.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/cstream.lisp"' \
             ':output-file "${OUT}/cstream.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<cstream.lisp (MID from IN)>>=
${MID}/cstream.lisp: ${IN}/cstream.lisp.pamphlet
	@ echo 137 making ${MID}/cstream.lisp from ${IN}/cstream.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/cstream.lisp.pamphlet >cstream.lisp )

@

\subsection{astr.lisp}
<<astr.o (OUT from MID)>>=
${OUT}/astr.${O}: ${MID}/astr.lisp
	@ echo 531 making ${OUT}/astr.${O} from ${MID}/astr.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/astr.lisp"' \
             ':output-file "${OUT}/astr.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/astr.lisp"' \
             ':output-file "${OUT}/astr.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<astr.lisp (MID from IN)>>=
${MID}/astr.lisp: ${IN}/astr.lisp.pamphlet
	@ echo 532 making ${MID}/astr.lisp from ${IN}/astr.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/astr.lisp.pamphlet >astr.lisp )

@

\subsection{msg.lisp}
<<msg.o (OUT from MID)>>=
${OUT}/msg.${O}: ${MID}/msg.lisp
	@ echo 136 making ${OUT}/msg.${O} from ${MID}/msg.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/msg.lisp"' \
             ':output-file "${OUT}/msg.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/msg.lisp"' \
             ':output-file "${OUT}/msg.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<msg.lisp (MID from IN)>>=
${MID}/msg.lisp: ${IN}/msg.lisp.pamphlet
	@ echo 137 making ${MID}/msg.lisp from ${IN}/msg.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/msg.lisp.pamphlet >msg.lisp )

@

\subsection{serror.lisp}
<<serror.o (OUT from MID)>>=
${OUT}/serror.${O}: ${MID}/serror.lisp
	@ echo 136 making ${OUT}/serror.${O} from ${MID}/serror.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/serror.lisp"' \
             ':output-file "${OUT}/serror.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/serror.lisp"' \
             ':output-file "${OUT}/serror.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<serror.lisp (MID from IN)>>=
${MID}/serror.lisp: ${IN}/serror.lisp.pamphlet
	@ echo 137 making ${MID}/serror.lisp from ${IN}/serror.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/serror.lisp.pamphlet >serror.lisp )

@

\subsection{posit.lisp}
<<posit.o (OUT from MID)>>=
${OUT}/posit.${O}: ${MID}/posit.lisp
	@ echo 136 making ${OUT}/posit.${O} from ${MID}/posit.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/posit.lisp"' \
             ':output-file "${OUT}/posit.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/posit.lisp"' \
             ':output-file "${OUT}/posit.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<posit.lisp (MID from IN)>>=
${MID}/posit.lisp: ${IN}/posit.lisp.pamphlet
	@ echo 137 making ${MID}/posit.lisp from ${IN}/posit.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/posit.lisp.pamphlet >posit.lisp )

@

\subsection{cformat.lisp}
<<cformat.o (OUT from MID)>>=
${OUT}/cformat.${O}: ${MID}/cformat.lisp
	@ echo 136 making ${OUT}/cformat.${O} from ${MID}/cformat.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/cformat.lisp"' \
             ':output-file "${OUT}/cformat.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/cformat.lisp"' \
             ':output-file "${OUT}/cformat.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<cformat.lisp (MID from IN)>>=
${MID}/cformat.lisp: ${IN}/cformat.lisp.pamphlet
	@ echo 137 making ${MID}/cformat.lisp from ${IN}/cformat.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/cformat.lisp.pamphlet >cformat.lisp )

@

\subsection{varini.boot}
<<varini.o (OUT from MID)>>=
${OUT}/varini.${O}: ${MID}/varini.clisp 
	@ echo 546 making ${OUT}/varini.${O} from ${MID}/varini.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (compile-file "${MID}/varini.clisp"' \
             ':output-file "${OUT}/varini.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (compile-file "${MID}/varini.clisp"' \
             ':output-file "${OUT}/varini.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi

@
<<varini.clisp  (MID from IN)>>=
${MID}/varini.clisp: ${IN}/varini.boot.pamphlet
	@ echo 547 making ${MID}/varini.clisp from ${IN}/varini.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/varini.boot.pamphlet >varini.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "${MID}/varini.boot") (${BYE}))' \
                | ${BOOTSYS}  ; \
	  else \
	   echo '(progn (boottran::boottocl "${MID}/varini.boot") (${BYE}))' \
                | ${BOOTSYS} >${TMP}/trace ; \
	  fi ; \
	  rm varini.boot )

@

\subsection{parini.boot}
<<parini.o (OUT from MID)>>=
${OUT}/parini.${O}: ${MID}/parini.clisp 
	@ echo 549 making ${OUT}/parini.${O} from ${MID}/parini.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (compile-file "${MID}/parini.clisp"' \
             ':output-file "${OUT}/parini.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (compile-file "${MID}/parini.clisp"' \
             ':output-file "${OUT}/parini.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi

@
<<parini.clisp (MID from IN)>>=
${MID}/parini.clisp: ${IN}/parini.boot.pamphlet
	@ echo 550 making ${MID}/parini.clisp from ${IN}/parini.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/parini.boot.pamphlet >parini.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "${MID}/parini.boot") (${BYE}))' \
                | ${BOOTSYS}  ; \
	  else \
	   echo '(progn (boottran::boottocl "${MID}/parini.boot") (${BYE}))' \
                | ${BOOTSYS} >${TMP}/trace ; \
	  fi ; \
	  rm parini.boot )

@

\subsection{intfile.lisp}
<<intfile.o (OUT from MID)>>=
${OUT}/intfile.${O}: ${MID}/intfile.lisp
	@ echo 136 making ${OUT}/intfile.${O} from ${MID}/intfile.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/intfile.lisp"' \
             ':output-file "${OUT}/intfile.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/intfile.lisp"' \
             ':output-file "${OUT}/intfile.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<intfile.lisp (MID from IN)>>=
${MID}/intfile.lisp: ${IN}/intfile.lisp.pamphlet
	@ echo 137 making ${MID}/intfile.lisp from ${IN}/intfile.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/intfile.lisp.pamphlet >intfile.lisp )

@

\subsection{intint.lisp}
this is the code that links the new parser to the interpreter
<<intint.o (OUT from MID)>>=
${OUT}/intint.${O}: ${MID}/intint.lisp
	@ echo 555 making ${OUT}/intint.${O} from ${MID}/intint.lisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (compile-file "${MID}/intint.lisp"' \
             ':output-file "${OUT}/intint.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (compile-file "${MID}/intint.lisp"' \
             ':output-file "${OUT}/intint.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi

@
<<intint.lisp (MID from IN)>>=
${MID}/intint.lisp: ${IN}/intint.lisp.pamphlet
	@ echo 556 making ${MID}/intint.lisp from ${IN}/intint.lisp.pamphlet
	@(cd ${MID} ; \
	${TANGLE} ${IN}/intint.lisp.pamphlet >intint.lisp )

@

\subsection{nci.lisp}
<<nci.o (OUT from MID)>>=
${OUT}/nci.${O}: ${MID}/nci.lisp
	@ echo 558 making ${OUT}/nci.${O} from ${MID}/nci.lisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (compile-file "${MID}/nci.lisp"' \
            ':output-file "${OUT}/nci.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (compile-file "${MID}/nci.lisp"' \
            ':output-file "${OUT}/nci.${O}") (${BYE}))' | ${DEPSYS} \
            >${TMP}/trace ; \
	  fi

@
<<nci.lisp (MID from IN)>>=
${MID}/nci.lisp: ${IN}/nci.lisp.pamphlet
	@ echo 559 making ${MID}/nci.lisp from ${IN}/nci.lisp.pamphlet
	@(cd ${MID} ; \
	${TANGLE} ${IN}/nci.lisp.pamphlet >nci.lisp )

@

\subsection{sfsfun-l.lisp}
<<sfsfun-l.o (OUT from MID)>>=
${OUT}/sfsfun-l.${O}: ${MID}/sfsfun-l.lisp
	@ echo 561 making ${OUT}/sfsfun-l.${O} from ${MID}/sfsfun-l.lisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (compile-file "${MID}/sfsfun-l.lisp"' \
             ':output-file "${OUT}/sfsfun-l.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (compile-file "${MID}/sfsfun-l.lisp"' \
             ':output-file "${OUT}/sfsfun-l.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi

@
<<sfsfun-l.lisp (MID from IN)>>=
${MID}/sfsfun-l.lisp: ${IN}/sfsfun-l.lisp.pamphlet
	@ echo 562 making ${MID}/sfsfun-l.lisp \
                   from ${IN}/sfsfun-l.lisp.pamphlet
	@(cd ${MID} ; \
	${TANGLE} ${IN}/sfsfun-l.lisp.pamphlet >sfsfun-l.lisp )

@

\subsection{int-top.lisp}
<<int-top.o (OUT from MID)>>=
${OUT}/int-top.${O}: ${MID}/int-top.lisp
	@ echo 136 making ${OUT}/int-top.${O} from ${MID}/int-top.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/int-top.lisp"' \
             ':output-file "${OUT}/int-top.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/int-top.lisp"' \
             ':output-file "${OUT}/int-top.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<int-top.lisp (MID from IN)>>=
${MID}/int-top.lisp: ${IN}/int-top.lisp.pamphlet
	@ echo 137 making ${MID}/int-top.lisp from ${IN}/int-top.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/int-top.lisp.pamphlet >int-top.lisp )

@

\subsection{osyscmd.lisp}
<<osyscmd.o (OUT from MID)>>=
${OUT}/osyscmd.${O}: ${MID}/osyscmd.lisp
	@ echo 136 making ${OUT}/osyscmd.${O} from ${MID}/osyscmd.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/osyscmd.lisp"' \
             ':output-file "${OUT}/osyscmd.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/osyscmd.lisp"' \
             ':output-file "${OUT}/osyscmd.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<osyscmd.lisp (MID from IN)>>=
${MID}/osyscmd.lisp: ${IN}/osyscmd.lisp.pamphlet
	@ echo 137 making ${MID}/osyscmd.lisp from ${IN}/osyscmd.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/osyscmd.lisp.pamphlet >osyscmd.lisp )

@

\subsection{packtran.lisp}
<<packtran.o (OUT from MID)>>=
${OUT}/packtran.${O}: ${MID}/packtran.lisp
	@ echo 136 making ${OUT}/packtran.${O} from ${MID}/packtran.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/packtran.lisp"' \
             ':output-file "${OUT}/packtran.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/packtran.lisp"' \
             ':output-file "${OUT}/packtran.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<packtran.lisp (MID from IN)>>=
${MID}/packtran.lisp: ${IN}/packtran.lisp.pamphlet
	@ echo 137 making ${MID}/packtran.lisp from \
           ${IN}/packtran.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/packtran.lisp.pamphlet >packtran.lisp )

@

\subsection{pf2sex.lisp}
<<pf2sex.o (OUT from MID)>>=
${OUT}/pf2sex.${O}: ${MID}/pf2sex.lisp
	@ echo 136 making ${OUT}/pf2sex.${O} from ${MID}/pf2sex.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/pf2sex.lisp"' \
             ':output-file "${OUT}/pf2sex.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/pf2sex.lisp"' \
             ':output-file "${OUT}/pf2sex.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<pf2sex.lisp (MID from IN)>>=
${MID}/pf2sex.lisp: ${IN}/pf2sex.lisp.pamphlet
	@ echo 137 making ${MID}/pf2sex.lisp from ${IN}/pf2sex.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/pf2sex.lisp.pamphlet >pf2sex.lisp )

@

\subsection{sfsfun.lisp}
<<sfsfun.o (OUT from MID)>>=
${OUT}/sfsfun.${O}: ${MID}/sfsfun.lisp
	@ echo 136 making ${OUT}/sfsfun.${O} from ${MID}/sfsfun.lisp
	@ ( cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/sfsfun.lisp"' \
             ':output-file "${OUT}/sfsfun.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/sfsfun.lisp"' \
             ':output-file "${OUT}/sfsfun.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<sfsfun.lisp (MID from IN)>>=
${MID}/sfsfun.lisp: ${IN}/sfsfun.lisp.pamphlet
	@ echo 137 making ${MID}/sfsfun.lisp from ${IN}/sfsfun.lisp.pamphlet
	@ (cd ${MID} ; \
	   ${TANGLE} ${IN}/sfsfun.lisp.pamphlet >sfsfun.lisp )

@

\subsection{hashcode.boot}
files for the new compiler
<<hashcode.o (OUT from MID)>>=

${OUT}/hashcode.${O}: ${MID}/hashcode.clisp 
	@ echo 583 making ${OUT}/hashcode.${O} from ${MID}/hashcode.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/hashcode.clisp"' \
             ':output-file "${OUT}/hashcode.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/hashcode.clisp"' \
             ':output-file "${OUT}/hashcode.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<hashcode.clisp (MID from IN)>>=
${MID}/hashcode.clisp: ${IN}/hashcode.boot.pamphlet
	@ echo 584 making ${MID}/hashcode.clisp \
                   from ${IN}/hashcode.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/hashcode.boot.pamphlet >hashcode.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "hashcode.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "hashcode.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm hashcode.boot )

@

\subsection{interop.boot}
<<interop.o (OUT from MID)>>=
${OUT}/interop.${O}: ${MID}/interop.clisp
	@ echo 586 making ${OUT}/interop.${O} from ${MID}/interop.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/interop.clisp"' \
             ':output-file "${OUT}/interop.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/interop.clisp"' \
             ':output-file "${OUT}/interop.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<interop.clisp (MID from IN)>>=
${MID}/interop.clisp: ${IN}/interop.boot.pamphlet
	@ echo 587 making ${MID}/interop.clisp from ${IN}/interop.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/interop.boot.pamphlet >interop.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "interop.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "interop.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm interop.boot )

@

\subsection{wi1.boot}
translate files
<<wi1.o (AUTO from MID)>>=
${AUTO}/wi1.${O}: ${MID}/wi1.clisp 
	@ echo 592 making ${AUTO}/wi1.${O} from ${MID}/wi1.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/wi1.clisp"' \
             ':output-file "${AUTO}/wi1.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/wi1.clisp"' \
             ':output-file "${AUTO}/wi1.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<wi1.clisp (MID from IN)>>=
${MID}/wi1.clisp: ${IN}/wi1.boot.pamphlet
	@ echo 593 making ${MID}/wi1.clisp from ${IN}/wi1.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/wi1.boot.pamphlet >wi1.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "wi1.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "wi1.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm wi1.boot )

@

\subsection{wi2.boot}
<<wi2.o (AUTO from MID)>>=
${AUTO}/wi2.${O}: ${MID}/wi2.clisp 
	@ echo 595 making ${AUTO}/wi2.${O} from ${MID}/wi2.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/wi2.clisp"' \
             ':output-file "${AUTO}/wi2.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/wi2.clisp"' \
             ':output-file "${AUTO}/wi2.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<wi2.clisp (MID from IN)>>=
${MID}/wi2.clisp: ${IN}/wi2.boot.pamphlet
	@ echo 596 making ${MID}/wi2.clisp from ${IN}/wi2.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/wi2.boot.pamphlet >wi2.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "wi2.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "wi2.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm wi2.boot )

@

\subsection{pspad1.boot}
<<pspad1.o (AUTO from MID)>>=
${AUTO}/pspad1.${O}: ${MID}/pspad1.clisp 
	@ echo 598 making ${AUTO}/pspad1.${O} from ${MID}/pspad1.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/pspad1.clisp"' \
             ':output-file "${AUTO}/pspad1.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/pspad1.clisp"' \
             ':output-file "${AUTO}/pspad1.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<pspad1.clisp (MID from IN)>>=
${MID}/pspad1.clisp: ${IN}/pspad1.boot.pamphlet
	@ echo 599 making ${MID}/pspad1.clisp from ${IN}/pspad1.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/pspad1.boot.pamphlet >pspad1.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "pspad1.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "pspad1.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm pspad1.boot )

@

\subsection{pspad2.boot}
<<pspad2.o (AUTO from MID)>>=
${AUTO}/pspad2.${O}: ${MID}/pspad2.clisp 
	@ echo 601 making ${AUTO}/pspad2.${O} from ${MID}/pspad2.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/pspad2.clisp"' \
             ':output-file "${AUTO}/pspad2.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/pspad2.clisp"' \
             ':output-file "${AUTO}/pspad2.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<pspad2.clisp (MID from IN)>>=
${MID}/pspad2.clisp: ${IN}/pspad2.boot.pamphlet
	@ echo 602 making ${MID}/pspad2.clisp from ${IN}/pspad2.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/pspad2.boot.pamphlet >pspad2.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "pspad2.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "pspad2.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm pspad2.boot )

@

\subsection{mark.boot}
<<mark.o (AUTO from MID)>>=
${AUTO}/mark.${O}: ${MID}/mark.clisp 
	@ echo 604 making ${AUTO}/mark.${O} from ${MID}/mark.clisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/mark.clisp"' \
             ':output-file "${AUTO}/mark.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/mark.clisp"' \
             ':output-file "${AUTO}/mark.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<mark.clisp (MID from IN)>>=
${MID}/mark.clisp: ${IN}/mark.boot.pamphlet
	@ echo 605 making ${MID}/mark.clisp from ${IN}/mark.boot.pamphlet
	@ (cd ${MID} ; \
	  ${TANGLE} ${IN}/mark.boot.pamphlet >mark.boot ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "mark.boot") (${BYE}))' \
                | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "mark.boot") (${BYE}))' \
                | ${DEPSYS} >${TMP}/trace ; \
	  fi ; \
	  rm mark.boot )

@

\subsection{axext\_l.lisp}
<<axext\_l.o (OUT from MID)>>=
# .lisp files for AXIOM-XL support

${OUT}/axext_l.${O}: ${MID}/axext_l.lisp
	@ echo 607 making ${OUT}/axext_l.${O} from ${MID}/axext_l.lisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/axext_l.lisp"' \
             ':output-file "${OUT}/axext_l.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/axext_l.lisp"' \
             ':output-file "${OUT}/axext_l.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<axext\_l.lisp (MID from IN)>>=
${MID}/axext_l.lisp: ${IN}/axext_l.lisp.pamphlet
	@ echo 608 making ${MID}/axext_l.lisp from ${IN}/axext_l.lisp.pamphlet
	@(cd ${MID} ; \
	${TANGLE} ${IN}/axext_l.lisp.pamphlet >axext_l.lisp )

@

\subsection{foam\_l.lisp}
Note that this code links the interpreter with the Aldor compiler.
<<foam\_l.o (OUT from MID)>>=
${OUT}/foam_l.${O}: ${MID}/foam_l.lisp
	@ echo 610 making ${OUT}/foam_l.${O} from ${MID}/foam_l.lisp
	@ (cd ${MID} ; \
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "foam_l.lisp"' \
             ':output-file "${OUT}/foam_l.${O}") (${BYE}))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "foam_l.lisp"' \
             ':output-file "${OUT}/foam_l.${O}") (${BYE}))' | ${DEPSYS} \
             >${TMP}/trace ; \
	  fi )

@
<<foam\_l.lisp (MID from IN)>>=
${MID}/foam_l.lisp: ${IN}/foam_l.lisp.pamphlet
	@ echo 611 making ${MID}/foam_l.lisp from ${IN}/foam_l.lisp.pamphlet
	@(cd ${MID} ; \
	${TANGLE} ${IN}/foam_l.lisp.pamphlet >foam_l.lisp )

@

\section{The databases}
\subsection{autoload dependencies}
If you are adding a file which is to be autoloaded the following step
information is useful. There are 2 cases:
\begin{enumerate}
\item adding files to currently autoloaded parts\\
(as of 2/92: browser old parser and old compiler)
\item adding new files
\begin{itemize}
\item case 1:
\begin{itemize}
\item [(a)] you have to add the file to the list of files currently there
(e.g. see BROBJS above)
\item [(b)] add an autolaod rule
(e.g. ${AUTO}/parsing.${O}: ${OUT}/parsing.${O})
\item [(c)] edit util.lisp to add the 'external' function (those that
should trigger the autoload
\end{itemize}
\item case 2:\\
     build-interpsys (in util.lisp) needs an extra argument for the
     new autoload things and several functions in util.lisp need hacking.
\end{itemize}
\end{enumerate}
database.date is a marker file used to force a rebuild of interpsys if the
database is rebuilt (src/algebra/Makefile).
<<databases>>=
${MID}/exposed.lsp: ${SRC}/algebra/exposed.lsp.pamphlet
	@ echo 615 making ${MID}/exposed.lsp \
                   from ${SRC}/algebra/exposed.lsp.pamphlet
	@(cd ${MID} ; \
	${TANGLE} ${SRC}/algebra/exposed.lsp.pamphlet >exposed.lsp )

${MNT}/${SYS}/algebra/exposed.${O} : ${MID}/exposed.lsp ${LISPSYS}
	@ echo 616 making ${MNT}/${SYS}/algebra/exposed.${O} \
                   from ${MID}/exposed.lsp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "${MID}/exposed.lsp"' \
             ':output-file "${MNT}/${SYS}/algebra/exposed.${O}") (${BYE}))' \
             | ${LISPSYS} ; \
	  else \
	   echo '(progn  (compile-file "${MID}/exposed.lsp"' \
             ':output-file "${MNT}/${SYS}/algebra/exposed.${O}") (${BYE}))' \
             | ${LISPSYS} >${TMP}/trace ; \
	  fi

${OUT}/database.date:
	@ echo 617 the database was updated...remaking interpsys
	@ touch ${OUT}/database.date

@

\section{The Makefile}
<<*>>=

<<environment>>

all: ${SAVESYS} spadhelp # ${DEBUGSYS} 
	@echo 618 finished ${IN}

clean:
	@echo 619 cleaning ${SRC}/interp

<<savesys>>
<<depsys>>
<<debugsys>>
<<databases>>
<<spadhelp>>

<<alql.o (OUT from MID)>>
<<alql.lisp (MID from IN)>>

<<apply.o (OUT from MID)>>
<<apply.lisp (MID from IN)>>

<<as.o (OUT from MID)>>
<<as.clisp (MID from IN)>>

<<astr.o (OUT from MID)>>
<<astr.lisp (MID from IN)>>

<<ax.o (AUTO from OUT)>>
<<ax.o (OUT from MID)>>
<<ax.clisp (MID from IN)>>

<<axext\_l.o (OUT from MID)>>
<<axext\_l.lisp (MID from IN)>>

<<bc-matrix.o (AUTO from OUT)>>
<<bc-matrix.o (OUT from MID)>>
<<bc-matrix.clisp (MID from IN)>>

<<br-con.o (AUTO from OUT)>>
<<br-con.o (OUT from MID)>>
<<br-con.clisp (MID from IN)>>

<<buildom.o (OUT from MID)>>
<<buildom.lisp (MID from IN)>>

<<category.o (OUT from MID)>>
<<category.lisp (MID from IN)>>

<<cattable.o (OUT from MID)>>
<<cattable.lisp (MID from IN)>>

<<c-doc.o (OUT from MID)>>
<<c-doc.lisp (MID from IN)>>

<<cformat.o (OUT from MID)>>
<<cformat.lisp (MID from IN)>>

<<cfuns.o (OUT from MID)>>
<<cfuns.lisp (MID from IN)>>

<<clam.lisp (OUT from IN)>>
<<clam.o (OUT from MID)>>
<<clam.lisp (MID from IN)>>

<<clammed.o (OUT from MID)>>
<<clammed.lisp (MID from IN)>>

<<compat.o (OUT from MID)>>
<<compat.lisp (MID from IN)>>

<<compiler.o (OUT from MID)>>
<<compiler.lisp (MID from IN)>>

<<compress.o (OUT from MID)>>
<<compress.lisp (MID from IN)>>

<<construc.o (OUT from MID)>>
<<construc.lisp (MID from IN)>>

<<cparse.o (OUT from MID)>>
<<cparse.lisp (MID from IN)>>

<<cstream.o (OUT from MID)>>
<<cstream.lisp (MID from IN)>>

<<c-util.lisp (OUT from IN)>>
<<c-util.o (OUT from MID)>>
<<c-util.lisp (MID from IN)>>

<<daase.o (OUT from MID)>>
<<daase.lisp (MID from IN)>>

<<database.o (OUT from MID)>>
<<database.lisp (MID from IN)>>

<<debugsys.lisp (MID from IN)>>

<<define.o (OUT from MID)>>
<<define.lisp (MID from IN)>>

<<dq.o (OUT from MID)>>
<<dq.lisp (MID from IN)>>

<<fname.o (OUT from MID)>>
<<fname.lisp (MID from IN)>>

<<fnewmeta.o (AUTO from OUT)>>
<<fnewmeta.o (OUT from MID)>>
<<fnewmeta.lisp (OUT from IN)>>
<<fnewmeta.lisp (MID from IN)>>

<<format.o (OUT from MID)>>
<<format.lisp (MID from IN)>>

<<fortcall.o (OUT from MID)>>
<<fortcall.lisp (MID from IN)>>

<<foam\_l.o (OUT from MID)>>
<<foam\_l.lisp (MID from IN)>>

<<functor.o (OUT from MID)>>
<<functor.lisp (MID from IN)>>

<<g-boot.lisp (OUT from IN)>>
<<g-boot.o (OUT from MID)>>
<<g-boot.lisp (MID from IN)>>

<<g-cndata.o (OUT from MID)>>
<<g-cndata.lisp (MID from IN)>>

<<g-error.o (OUT from MID)>>
<<g-error.lisp (MID from IN)>>

<<g-opt.o (OUT from MID)>>
<<g-opt.lisp (MID from IN)>>

<<g-timer.o (OUT from MID)>>
<<g-timer.lisp (MID from IN)>>

<<g-util.lisp (OUT from IN)>>
<<g-util.o (OUT from MID)>>
<<g-util.lisp (MID from IN)>>

<<http.o (OUT from MID)>>
<<http.lisp (MID from IN)>>

<<hashcode.o (OUT from MID)>>
<<hashcode.clisp (MID from IN)>>

<<htcheck.o (OUT from MID)>>
<<htcheck.lisp (MID from IN)>>

<<ht-util.o (AUTO from OUT)>>
<<ht-util.o (OUT from MID)>>
<<ht-util.clisp (MID from IN)>>

<<hypertex.o (OUT from MID)>>
<<hypertex.lisp (MID from IN)>>

<<i-analy.o (OUT from MID)>>
<<i-analy.lisp (MID from IN)>>

<<i-code.o (OUT from MID)>>
<<i-code.lisp (MID from IN)>>

<<i-coerce.o (OUT from MID)>>
<<i-coerce.lisp (MID from IN)>>

<<i-coerfn.o (OUT from MID)>>
<<i-coerfn.lisp (MID from IN)>>

<<i-eval.o (OUT from MID)>>
<<i-eval.lisp (MID from IN)>>

<<i-funsel.o (OUT from MID)>>
<<i-funsel.lisp (MID from IN)>>

<<bookvol5.o (OUT from MID)>>
<<bookvol5.lsp (OUT from MID)>>
<<bookvol5.lsp (MID from IN)>>

<<bookvol9.o (OUT from MID)>>
<<bookvol9.lsp (OUT from MID)>>
<<bookvol9.lsp (MID from IN)>>

<<i-intern.o (OUT from MID)>>
<<i-intern.lisp (MID from IN)>>

<<interop.o (OUT from MID)>>
<<interop.clisp (MID from IN)>>

<<i-map.o (OUT from MID)>>
<<i-map.lisp (MID from IN)>>

<<incl.o (OUT from MID)>>
<<incl.lisp (MID from IN)>>

<<info.o (OUT from MID)>>
<<info.lisp (MID from IN)>>

<<intfile.o (OUT from MID)>>
<<intfile.lisp (MID from IN)>>

<<intint.o (OUT from MID)>>
<<intint.lisp (MID from IN)>>

<<int-top.o (OUT from MID)>>
<<int-top.lisp (MID from IN)>>

<<i-output.o (OUT from MID)>>
<<i-output.lisp (MID from IN)>>

<<i-resolv.o (OUT from MID)>>
<<i-resolv.lisp (MID from IN)>>

<<i-spec1.o (OUT from MID)>>
<<i-spec1.lisp (MID from IN)>>

<<i-spec2.o (OUT from MID)>>
<<i-spec2.lisp (MID from IN)>>

<<i-syscmd.o (OUT from MID)>>
<<i-syscmd.lisp (MID from IN)>>

<<iterator.o (OUT from MID)>>
<<iterator.lisp (MID from IN)>>

<<i-toplev.o (OUT from MID)>>
<<i-toplev.lisp (MID from IN)>>

<<i-util.o (OUT from MID)>>
<<i-util.lisp (MID from IN)>>

<<lisplib.o (OUT from MID)>>
<<lisplib.lisp (MID from IN)>>

<<macex.o (OUT from MID)>>
<<macex.lisp (MID from IN)>>

<<mark.o (AUTO from MID)>>
<<mark.clisp (MID from IN)>>

<<match.o (OUT from MID)>>
<<match.lisp (MID from IN)>>

<<modemap.o (OUT from MID)>>
<<modemap.lisp (MID from IN)>>

<<monitor.o (OUT from MID)>>
<<monitor.lisp (MID from IN)>>

<<msg.o (OUT from MID)>>
<<msg.lisp (MID from IN)>>

<<msgdb.o (OUT from MID)>>
<<msgdb.lisp (MID from IN)>>

<<nag-c02.o (AUTO from OUT)>>
<<nag-c02.o (OUT from MID)>>
<<nag-c02.clisp (MID from IN)>>

<<nag-c05.o (AUTO from OUT)>>
<<nag-c05.o (OUT from MID)>>
<<nag-c05.clisp (MID from IN)>>

<<nag-c06.o (AUTO from OUT)>>
<<nag-c06.o (OUT from MID)>>
<<nag-c06.clisp (MID from IN)>>

<<nag-d01.o (AUTO from OUT)>>
<<nag-d01.o (OUT from MID)>>
<<nag-d01.clisp (MID from IN)>>

<<nag-d02.o (AUTO from OUT)>>
<<nag-d02.o (OUT from MID)>>
<<nag-d02.clisp (MID from IN)>>

<<nag-d03.o (AUTO from OUT)>>
<<nag-d03.o (OUT from MID)>>
<<nag-d03.clisp (MID from IN)>>

<<nag-e01.o (AUTO from OUT)>>
<<nag-e01.o (OUT from MID)>>
<<nag-e01.clisp (MID from IN)>>

<<nag-e02.o (AUTO from OUT)>>
<<nag-e02.o (OUT from MID)>>
<<nag-e02.clisp (MID from IN)>>

<<nag-e04.o (AUTO from OUT)>>
<<nag-e04.o (OUT from MID)>>
<<nag-e04.clisp (MID from IN)>>

<<nag-f01.o (AUTO from OUT)>>
<<nag-f01.o (OUT from MID)>>
<<nag-f01.clisp (MID from IN)>>

<<nag-f02.o (AUTO from OUT)>>
<<nag-f02.o (OUT from MID)>>
<<nag-f02.clisp (MID from IN)>>

<<nag-f04.o (AUTO from OUT)>>
<<nag-f04.o (OUT from MID)>>
<<nag-f04.clisp (MID from IN)>>

<<nag-f07.o (AUTO from OUT)>>
<<nag-f07.o (OUT from MID)>>
<<nag-f07.clisp (MID from IN)>>

<<nag-s.o (AUTO from OUT)>>
<<nag-s.o (OUT from MID)>>
<<nag-s.clisp (MID from IN)>>

<<nci.o (OUT from MID)>>
<<nci.lisp (MID from IN)>>

<<newaux.o (OUT from MID)>>
<<newaux.lisp (OUT from MID)>>
<<newaux.lisp (MID from IN)>>

<<newfort.o (OUT from MID)>>
<<newfort.lisp (MID from IN)>>

<<nocompil.lisp (OUT from MID)>>
<<nocompil.lisp (MID from IN)>>

<<nruncomp.o (AUTO from OUT)>>
<<nruncomp.o (OUT from MID)>>
<<nruncomp.clisp (MID from IN)>>

<<nrunfast.o (OUT from MID)>>
<<nrunfast.lisp (MID from IN)>>

<<nrungo.o (OUT from MID)>>
<<nrungo.lisp (MID from IN)>>

<<nruntime.o (OUT from MID)>>
<<nruntime.lisp (MID from IN)>>

<<nrunopt.o (OUT from MID)>>
<<nrunopt.lisp (MID from IN)>>

<<nspadaux.o (AUTO from OUT)>>
<<nspadaux.o (OUT from MID)>>
<<nspadaux.lisp (OUT from MID)>>
<<nspadaux.lisp (MID from IN)>>

<<obey.o (OUT from MID)>>
<<obey.lisp (MID from IN)>>

<<osyscmd.o (OUT from MID)>>
<<osyscmd.lisp (MID from IN)>>

<<package.o (OUT from MID)>>
<<package.lisp (MID from IN)>>

<<packtran.o (OUT from MID)>>
<<packtran.lisp (MID from IN)>>

<<parini.o (OUT from MID)>>
<<parini.clisp (MID from IN)>>

<<parsing.o (AUTO from OUT)>>
<<parsing.o (OUT from MID)>>
<<parsing.lisp (OUT from MID)>>
<<parsing.lisp (MID from IN)>>

<<patches.o (OUT from MID)>>
<<patches.lisp (MID from IN)>>

<<pathname.o (OUT from MID)>>
<<pathname.lisp (MID from IN)>>

<<pf2sex.o (OUT from MID)>>
<<pf2sex.lisp (MID from IN)>>

<<pile.o (OUT from MID)>>
<<pile.lisp (MID from IN)>>

<<posit.o (OUT from MID)>>
<<posit.lisp (MID from IN)>>

<<postprop.lisp (AUTO from OUT)>>
<<postprop.lisp (OUT from MID)>>
<<postprop.lisp (MID from IN)>>

<<profile.o (OUT from MID)>>
<<profile.lisp (MID from IN)>>

<<pspad1.o (AUTO from MID)>>
<<pspad1.clisp (MID from IN)>>

<<pspad2.o (AUTO from MID)>>
<<pspad2.clisp (MID from IN)>>

<<ptrees.o (OUT from MID)>>
<<ptrees.lisp (MID from IN)>>

<<ptrop.o (OUT from MID)>>
<<ptrop.lisp (MID from IN)>>

<<record.o (OUT from MID)>>
<<record.lisp (MID from IN)>>

<<regress.o (OUT from MID)>>
<<regress.lisp (MID from IN)>>

<<rulesets.o (OUT from MID)>>
<<rulesets.lisp (MID from IN)>>

<<scan.o (OUT from MID)>>
<<scan.lisp (MID from IN)>>

<<serror.o (OUT from MID)>>
<<serror.lisp (MID from IN)>>

<<server.o (OUT from MID)>>
<<server.lisp (MID from IN)>>

<<sfsfun.o (OUT from MID)>>
<<sfsfun.lisp (MID from IN)>>

<<sfsfun-l.o (OUT from MID)>>
<<sfsfun-l.lisp (MID from IN)>>

<<simpbool.o (OUT from MID)>>
<<simpbool.lisp (MID from IN)>>

<<slam.lisp (AUTO from OUT)>>
<<slam.lisp (OUT from MID)>>
<<slam.lisp (MID from IN)>>

<<sockio.o (OUT from MID)>>
<<sockio.lisp (MID from IN)>>

<<sys-pkg.lisp (OUT from MID)>>
<<sys-pkg.lisp (MID from IN)>>

<<template.o (OUT from MID)>>
<<template.lisp (MID from IN)>>

<<termrw.o (OUT from MID)>>
<<termrw.lisp (MID from IN)>>

<<topics.o (AUTO from OUT)>>
<<topics.o (OUT from MID)>>
<<topics.clisp (MID from IN)>>

<<util.o (OUT from MID)>>
<<util.lisp (OUT from MID)>>
<<util.lisp (MID from IN)>>

<<varini.o (OUT from MID)>>
<<varini.clisp  (MID from IN)>>

<<vmlisp.o (OUT from MID)>>
<<vmlisp.lisp (MID from IN)>>

<<warm.data.stanza>>

<<wi1.o (AUTO from MID)>>
<<wi1.clisp (MID from IN)>>

<<wi2.o (AUTO from MID)>>
<<wi2.clisp (MID from IN)>>

@
pp
\eject
\begin{thebibliography}{99}
\end{thebibliography}
\end{document}
