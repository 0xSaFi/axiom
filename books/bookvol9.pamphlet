\documentclass[dvipdfm]{book}
\usepackage{hyperref}
\usepackage{axiom}
\usepackage{makeidx}
\makeindex
\usepackage{graphicx}
\begin{document}
\begin{titlepage}
\center{\includegraphics{ps/axiomfront.ps}}
\vskip 0.1in
\includegraphics{ps/bluebayou.ps}\\
\vskip 0.1in
{\Huge{The 30 Year Horizon}}
\vskip 0.1in
$$
\begin{array}{lll}
Manuel\ Bronstein      & William\ Burge   & Timothy\ Daly \\
James\ Davenport       & Michael\ Dewar   & Martin\ Dunstan \\
Albrecht\ Fortenbacher & Patrizia\ Gianni & Johannes\ Grabmeier \\
Jocelyn\ Guidry        & Richard\ Jenks   & Larry\ Lambe \\
Michael\ Monagan       & Scott\ Morrison  & William\ Sit \\
Jonathan\ Steinbach    & Robert\ Sutor    & Barry\ Trager \\
Stephen\ Watt          & Jim\ Wen         & Clifton\ Williamson
\end{array}
$$
\center{\large{Volume 9: Axiom Compiler}}
\end{titlepage}
\pagenumbering{roman}
\begin{verbatim}
Portions Copyright (c) 2005 Timothy Daly

The Blue Bayou image Copyright (c) 2004 Jocelyn Guidry

Portions Copyright (c) 2004 Martin Dunstan

Portions Copyright (c) 1991-2002, 
The Numerical ALgorithms Group Ltd.
All rights reserved.

This book and the Axiom software is licensed as follows:

Redistribution and use in source and binary forms, with or 
without modification, are permitted provided that the following 
conditions are
met:

    - Redistributions of source code must retain the above 
      copyright notice, this list of conditions and the 
      following disclaimer.

    - Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the 
      following disclaimer in the documentation and/or other 
      materials provided with the distribution.

    - Neither the name of The Numerical ALgorithms Group Ltd. 
      nor the names of its contributors may be used to endorse 
      or promote products derived from this software without 
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.

\end{verbatim}

Inclusion of names in the list of credits is based on historical
information and is as accurate as possible. Inclusion of names
does not in any way imply an endorsement but represents historical
influence on Axiom development.
\vfill
\eject
\begin{tabular}{lll}
Cyril Alberga         & Roy Adler             & Richard Anderson\\
George Andrews        & Henry Baker           & Stephen Balzac\\
Yurij Baransky        & David R. Barton       & Gerald Baumgartner\\
Gilbert Baumslag      & Fred Blair            & Vladimir Bondarenko\\
Mark Botch            & Alexandre Bouyer      & Peter A. Broadbery\\
Martin Brock          & Manuel Bronstein      & Florian Bundschuh\\
William Burge         & Quentin Carpent       & Bob Caviness\\
Bruce Char            & Cheekai Chin          & David V. Chudnovsky\\
Gregory V. Chudnovsky & Josh Cohen            & Christophe Conil\\
Don Coppersmith       & George Corliss        & Robert Corless\\
Gary Cornell          & Meino Cramer          & Claire Di Crescenzo\\
Timothy Daly Sr.      & Timothy Daly Jr.      & James H. Davenport\\
Jean Della Dora       & Gabriel Dos Reis      & Michael Dewar\\
Claire DiCrescendo    & Sam Dooley            & Lionel Ducos\\
Martin Dunstan        & Brian Dupee           & Dominique Duval\\
Robert Edwards        & Heow Eide-Goodman     & Lars Erickson\\
Richard Fateman       & Bertfried Fauser      & Stuart Feldman\\
Brian Ford            & Albrecht Fortenbacher & George Frances\\
Constantine Frangos   & Timothy Freeman       & Korrinn Fu\\
Marc Gaetano          & Rudiger Gebauer       & Kathy Gerber\\
Patricia Gianni       & Holger Gollan         & Teresa Gomez-Diaz\\
Laureano Gonzalez-Vega& Stephen Gortler       & Johannes Grabmeier\\
Matt Grayson          & James Griesmer        & Vladimir Grinberg\\
Oswald Gschnitzer     & Jocelyn Guidry        & Steve Hague\\
Vilya Harvey          & Satoshi Hamaguchi     & Martin Hassner\\
Ralf Hemmecke         & Henderson             & Antoine Hersen\\
Pietro Iglio          & Richard Jenks         & Kai Kaminski\\
Grant Keady           & Tony Kennedy          & Paul Kosinski\\
Klaus Kusche          & Bernhard Kutzler      & Larry Lambe\\
Frederic Lehobey      & Michel Levaud         & Howard Levy\\
Rudiger Loos          & Michael Lucks         & Richard Luczak\\
Camm Maguire          & Bob McElrath          & Michael McGettrick\\
Ian Meikle            & David Mentre          & Victor S. Miller\\
Gerard Milmeister     & Mohammed Mobarak      & H. Michael Moeller\\
Michael Monagan       & Marc Moreno-Maza      & Scott Morrison\\
Mark Murray           & William Naylor        & C. Andrew Neff\\
John Nelder           & Godfrey Nolan         & Arthur Norman\\
Jinzhong Niu          & Michael O'Connor      & Kostas Oikonomou\\
Julian A. Padget      & Bill Page             & Jaap Weel\\
Susan Pelzel          & Michel Petitot        & Didier Pinchon\\
Claude Quitte         & Norman Ramsey         & Michael Richardson\\
Renaud Rioboo         & Jean Rivlin           & Nicolas Robidoux\\
Simon Robinson        & Michael Rothstein     & Martin Rubey\\
Philip Santas         & Alfred Scheerhorn     & William Schelter\\
Gerhard Schneider     & Martin Schoenert      & Marshall Schor\\
Fritz Schwarz         & Nick Simicich         & William Sit\\
Elena Smirnova        & Jonathan Steinbach    & Christine Sundaresan\\
Robert Sutor          & Moss E. Sweedler      & Eugene Surowitz\\
James Thatcher        & Baldir Thomas         & Mike Thomas\\
Dylan Thurston        & Barry Trager          & Themos T. Tsikas\\
Gregory Vanuxem       & Bernhard Wall         & Stephen Watt\\
Juergen Weiss         & M. Weller             & Mark Wegman\\
James Wen             & Thorsten Werther      & Michael Wester\\
John M. Wiley         & Berhard Will          & Clifton J. Williamson\\
Stephen Wilson        & Shmuel Winograd       & Robert Wisbauer\\
Sandra Wityak         & Waldemar Wiwianka     & Knut Wolf\\
Clifford Yapp         & David Yun             & Richard Zippel\\
Evelyn Zoernack       & Bruno Zuercher        & Dan Zwillinger 
\end{tabular}
\eject
\tableofcontents
\vfill
\eject
\setlength{\parindent}{0em}
\setlength{\parskip}{1ex}
{\Large{\bf New Foreword}}
\vskip .25in

On October 1, 2001 Axiom was withdrawn from the market and ended
life as a commercial product.
On September 3, 2002 Axiom was released under the Modified BSD
license, including this document.
On August 27, 2003 Axiom was released as free and open source
software available for download from the Free Software Foundation's
website, Savannah.

Work on Axiom has had the generous support of the Center for 
Algorithms and Interactive Scientific Computation (CAISS) at
City College of New York. Special thanks go to Dr. Gilbert 
Baumslag for his support of the long term goal.

The online version of this documentation is roughly 1000 pages.
In order to make printed versions we've broken it up into three
volumes. The first volume is tutorial in nature. The second volume
is for programmers. The third volume is reference material. We've
also added a fourth volume for developers. All of these changes
represent an experiment in print-on-demand delivery of documentation.
Time will tell whether the experiment succeeded.

Axiom has been in existence for over thirty years. It is estimated to
contain about three hundred man-years of research and has, as of
September 3, 2003, 143 people listed in the credits. All of these
people have contributed directly or indirectly to making Axiom
available.  Axiom is being passed to the next generation. I'm looking
forward to future milestones.

With that in mind I've introduced the theme of the ``30 year horizon''.
We must invent the tools that support the Computational Mathematician
working 30 years from now. How will research be done when every bit of
mathematical knowledge is online and instantly available? What happens
when we scale Axiom by a factor of 100, giving us 1.1 million domains?
How can we integrate theory with code? How will we integrate theorems
and proofs of the mathematics with space-time complexity proofs and
running code? What visualization tools are needed? How do we support
the conceptual structures and semantics of mathematics in effective
ways? How do we support results from the sciences? How do we teach
the next generation to be effective Computational Mathematicians?

The ``30 year horizon'' is much nearer than it appears.

\vskip .25in
%\noindent
Tim Daly\\
CAISS, City College of New York\\
November 10, 2003 ((iHy))
\vfill
\eject
\pagenumbering{arabic}
\setcounter{chapter}{0} % Chapter 1
\section{Makefile}
This book is actually a literate program\cite{2} and can contain 
executable source code. In particular, the Makefile for this book
is part of the source of the book and is included below. Axiom 
uses the ``noweb'' literate programming system by Norman Ramsey\cite{6}.
\chapter{Compiler top level}
\section{)compile}
This is the implementation of the )compile command.

You use this command to invoke the new Axiom library compiler or the
old Axiom system compiler.  The {\tt )compile} system command is
actually a combination of Axiom processing and a call to the Aldor
compiler.  It is performing double-duty, acting as a front-end to both
the Aldor compiler and the old Axiom system compiler.  (The old Axiom
system compiler was written in Lisp and was an integral part of the
Axiom environment.  The Aldor compiler is written in C and executed by
the operating system when called from within Axiom.)

\par\noindent{\bf User Level Required:} compiler

\par\noindent{\bf Command Syntax:}

\begin{list}{}
\item {\tt )compile}
\item {\tt )compile {\it fileName}}
\item {\tt )compile {\it fileName}.spad}
\item {\tt )compile {\it directory/fileName}.spad}
\item {\tt )compile {\it fileName} )old}
\item {\tt )compile {\it fileName} )translate}
\item {\tt )compile {\it fileName} )quiet}
\item {\tt )compile {\it fileName} )noquiet}
\item {\tt )compile {\it fileName} )moreargs}
\item {\tt )compile {\it fileName} )onlyargs}
\item {\tt )compile {\it fileName} )break}
\item {\tt )compile {\it fileName} )nobreak}
\item {\tt )compile {\it fileName} )library}
\item {\tt )compile {\it fileName} )nolibrary}
\item {\tt )compile {\it fileName} )vartrace}
\item {\tt )compile {\it fileName} )constructor} {\it nameOrAbbrev}
\end{list}

These command forms invoke the Aldor compiler.
\begin{list}{}
\item {\tt )compile {\it fileName}.as}
\item {\tt )compile {\it directory/fileName}.as}
\item {\tt )compile {\it fileName}.ao}
\item {\tt )compile {\it directory/fileName}.ao}
\item {\tt )compile {\it fileName}.al}
\item {\tt )compile {\it directory/fileName}.al}
\item {\tt )compile {\it fileName}.lsp}
\item {\tt )compile {\it directory/fileName}.lsp}
\item {\tt )compile {\it fileName} )new}
\end{list}

\par\noindent{\bf Command Description:}

The first thing {\tt )compile} does is look for a source code
filename among its arguments.
Thus
\begin{verbatim}
)compile mycode.spad
)compile /u/jones/mycode.spad
)compile mycode
\end{verbatim}
all invoke {\tt )compiler} on the file {\tt
/u/jones/mycode.spad} if the current Axiom working
directory is {\tt /u/jones.} (Recall that you can set the
working directory via the {\tt )cd} command. If you don't set it
explicitly, it is the directory from which you started
Axiom.)

If you omit the file extension, the command looks to see if you have
specified the {\tt )new} or {\tt )old} option.  If you have given one
of these options, the corresponding compiler is used.

The command first looks in the standard system directories for files
with extension {\it .as, .ao} and {\it .al} and then files with
extension {\it .spad}.  The first file found has the appropriate
compiler invoked on it.  If the command cannot find a matching file,
an error message is displayed and the command terminates.

The first thing {\tt )compile} does is look for a source code
filename among its arguments.
Thus
\begin{verbatim}
)compile mycode
)co mycode
)co mycode.spad
\end{verbatim}
all invoke {\tt )compiler} on the file {\tt
/u/jones/mycode.spad} if the current Axiom working
directory is {\tt /u/jones.} Recall that you can set the
working directory via the {\tt )cd} command. If you don't set it
explicitly, it is the directory from which you started
Axiom.

This is frequently all you need to compile your file.

This simple command:
\begin{enumerate}
\item Invokes the Spad compiler and produces Lisp output.
\item Calls the Lisp compiler if the compilation was successful.
\item Uses the {\tt )library} command to tell Axiom about
the contents of your compiled file and arrange to have those
contents loaded on demand.
\end{enumerate}

Should you not want the {\tt )library} command automatically
invoked, call {\tt )compile} with the {\tt )nolibrary} option.
For example,
\begin{verbatim}
)compile mycode )nolibrary
\end{verbatim}

By default, the {\tt )library} system command {\it exposes} all
domains and categories it processes.
This means that the Axiom intepreter will consider those domains and 
categories when it is trying to resolve a reference to a function.
Sometimes domains and categories should not be exposed.
For example, a domain may just be used privately by another
domain and may not be meant for top-level use.
The {\tt )library} command should still be used, though, so that
the code will be loaded on demand.
In this case, you should use the {\tt )nolibrary} option on {\tt
)compile} and the {\tt )noexpose} option in the {\tt )library}
command. For example,
\begin{verbatim}
)compile mycode )nolibrary
)library mycode )noexpose
\end{verbatim}

Once you have established your own collection of compiled code,
you may find it handy to use the {\tt )dir} option on the
{\tt )library} command.
This causes {\tt )library} to process all compiled code in the
specified directory. For example,
\begin{verbatim}
)library )dir /u/jones/quantum
\end{verbatim}
You must give an explicit directory after {\tt )dir}, even if you
want all compiled code in the current working directory
processed, e.g.
\begin{verbatim}
)library )dir .
\end{verbatim}

\subsection{Spad compiler}
This command compiles files with file extension {\tt .spad}
with the Spad system compiler.  

The {\tt )translate} option is used to invoke a special version of the
old system compiler that will translate a {\it .spad} file to a {\it
.as} file.  That is, the {\it .spad} file will be parsed and analyzed
and a file using the new syntax will be created.

By default, the {\it .as} file is created in the same directory as the
{\it .spad} file. If that directory is not writable, the current
directory is used. If the current directory is not writable, an error
message is given and the command terminates.  Note that {\tt )translate} 
implies the {\tt )old} option so the file extension can
safely be omitted. If {\tt )translate} is given, all other options are
ignored.  Please be aware that the translation is not necessarily one
hundred percent complete or correct.  You should attempt to compile
the output with the Aldor compiler and make any necessary corrections.

You can compile category, domain, and package constructors contained
in files with file extension {\it .spad}.  You can compile individual
constructors or every constructor in a file.

The full filename is remembered between invocations of this command and
{\tt )edit} commands. The sequence of commands
\begin{verbatim}
)compile matrix.spad
)edit
)compile
\end{verbatim}
will call the compiler, edit, and then call the compiler again on the
file {\bf matrix.spad.}  If you do not specify a {\it directory,} the
working current directory is searched for the file.  If the file is
not found, the standard system directories are searched.

If you do not give any options, all constructors within a file are
compiled.  Each constructor should have an {\tt )abbreviation} command
in the file in which it is defined.  We suggest that you place the
{\tt )abbreviation} commands at the top of the file in the order in
which the constructors are defined.

The {\tt )library} option causes directories containing the compiled
code for each constructor to be created in the working current
directory.  The name of such a directory consists of the constructor
abbreviation and the {\bf .nrlib} file extension.  For example, the
directory containing the compiled code for the {\tt MATRIX}
constructor is called {\bf MATRIX.nrlib.}  The {\tt )nolibrary} option
says that such files should not be created.  The default is 
{\tt )library.}  Note that the semantics of {\tt )library} and 
{\tt )nolibrary} for the new Aldor compiler and for the old system 
compiler are completely different.

The {\tt )vartrace} option causes the compiler to generate
extra code for the constructor to support conditional tracing of
variable assignments. (see 
\ref{ugSysCmdtrace} on page~\pageref{ugSysCmdtrace}). Without
this option, this code is suppressed and one cannot use
the {\tt )vars} option for the trace command.

The {\tt )constructor} option is used to
specify a particular constructor to compile.
All other constructors in the file are ignored.
The constructor name or abbreviation follows {\tt )constructor.}
Thus either
\begin{verbatim}
)compile matrix.spad )constructor RectangularMatrix
\end{verbatim}
or
\begin{verbatim}
)compile matrix.spad )constructor RMATRIX
\end{verbatim}
compiles  the {\tt RectangularMatrix} constructor
defined in {\bf matrix.spad.}

The {\tt )break} and {\tt )nobreak} options determine what
the spad compiler does when it encounters an error.
{\tt )break} is the default and it indicates that processing
should stop at the first error.
The value of the {\tt )set break} variable then controls what happens.

\chapter{The Parser}
\section{EQ.spad}
We will explain the compilation function using the file {\tt EQ.spad}.
We trace the execution of the various functions to understand the actual
call parameters and results returned. The {\tt EQ.spad} file is:
\begin{verbatim}
)abbrev domain EQ Equation
--FOR THE BENEFIT  OF LIBAX0 GENERATION
++ Author: Stephen M. Watt, enhancements by Johannes Grabmeier
++ Date Created: April 1985
++ Date Last Updated: June 3, 1991; September 2, 1992
++ Basic Operations: =
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++ Equations as mathematical objects.  All properties of the basis domain,
++ e.g. being an abelian group are carried over the equation domain, by
++ performing the structural operations on the left and on the
++ right hand side.
--   The interpreter translates "=" to "equation".  Otherwise, it will
--   find a modemap for "=" in the domain of the arguments.

Equation(S: Type): public == private where
  Ex ==> OutputForm
  public ==> Type with
    "=": (S, S) -> $
        ++ a=b creates an equation.
    equation: (S, S) -> $
        ++ equation(a,b) creates an equation.
    swap: $ -> $
        ++ swap(eq) interchanges left and right hand side of equation eq.
    lhs: $ -> S
        ++ lhs(eqn) returns the left hand side of equation eqn.
    rhs: $ -> S
        ++ rhs(eqn) returns the right hand side of equation eqn.
    map: (S -> S, $) -> $
        ++ map(f,eqn) constructs a new equation by applying f to both
        ++ sides of eqn.
    if S has InnerEvalable(Symbol,S) then
             InnerEvalable(Symbol,S)
    if S has SetCategory then
        SetCategory
        CoercibleTo Boolean
        if S has Evalable(S) then
           eval: ($, $) -> $
               ++ eval(eqn, x=f) replaces x by f in equation eqn.
           eval: ($, List $) -> $
               ++ eval(eqn, [x1=v1, ... xn=vn]) replaces xi by vi in equation eqn.
    if S has AbelianSemiGroup then
        AbelianSemiGroup
        "+": (S, $) -> $
            ++ x+eqn produces a new equation by adding x to both sides of
            ++ equation eqn.
        "+": ($, S) -> $
            ++ eqn+x produces a new equation by adding x to  both sides of
            ++ equation eqn.
    if S has AbelianGroup then
        AbelianGroup
        leftZero : $ -> $
          ++ leftZero(eq) subtracts the left hand side.
        rightZero : $ -> $
          ++ rightZero(eq) subtracts the right hand side.
        "-": (S, $) -> $
            ++ x-eqn produces a new equation by subtracting both sides of
            ++ equation eqn from x.
        "-": ($, S) -> $
            ++ eqn-x produces a new equation by subtracting x from  both sides of
            ++ equation eqn.
    if S has SemiGroup then
        SemiGroup
        "*": (S, $) -> $
            ++ x*eqn produces a new equation by multiplying both sides of
            ++ equation eqn by x.
        "*": ($, S) -> $
            ++ eqn*x produces a new equation by multiplying both sides of
            ++ equation eqn by x.
    if S has Monoid then
        Monoid
        leftOne : $ -> Union($,"failed")
          ++ leftOne(eq) divides by the left hand side, if possible.
        rightOne : $ -> Union($,"failed")
          ++ rightOne(eq) divides by the right hand side, if possible.
    if S has Group then
        Group
        leftOne : $ -> Union($,"failed")
          ++ leftOne(eq) divides by the left hand side.
        rightOne : $ -> Union($,"failed")
          ++ rightOne(eq) divides by the right hand side.
    if S has Ring then
      Ring
      BiModule(S,S)
    if S has CommutativeRing then
      Module(S)
      --Algebra(S)
    if S has IntegralDomain then
      factorAndSplit : $ -> List $
        ++ factorAndSplit(eq) make the right hand side 0 and
        ++ factors the new left hand side. Each factor is equated
        ++ to 0 and put into the resulting list without repetitions.
    if S has PartialDifferentialRing(Symbol) then
      PartialDifferentialRing(Symbol)
    if S has Field then
      VectorSpace(S)
      "/": ($, $) -> $
          ++ e1/e2 produces a new equation by dividing the left and right
          ++ hand sides of equations e1 and e2.
      inv: $ -> $
          ++ inv(x) returns the multiplicative inverse of x.
    if S has ExpressionSpace then
        subst: ($, $) -> $
             ++ subst(eq1,eq2) substitutes eq2 into both sides of eq1
             ++ the lhs of eq2 should be a kernel

  private ==> add
    Rep := Record(lhs: S, rhs: S)
    eq1,eq2: $
    s : S
    if S has IntegralDomain then
        factorAndSplit eq ==
          (S has factor : S -> Factored S) =>
            eq0 := rightZero eq
            [equation(rcf.factor,0) for rcf in factors factor lhs eq0]
          [eq]
    l:S = r:S      == [l, r]
    equation(l, r) == [l, r]    -- hack!  See comment above.
    lhs eqn        == eqn.lhs
    rhs eqn        == eqn.rhs
    swap eqn     == [rhs eqn, lhs eqn]
    map(fn, eqn)   == equation(fn(eqn.lhs), fn(eqn.rhs))

    if S has InnerEvalable(Symbol,S) then
        s:Symbol
        ls:List Symbol
        x:S
        lx:List S
        eval(eqn,s,x) == eval(eqn.lhs,s,x) = eval(eqn.rhs,s,x)
        eval(eqn,ls,lx) == eval(eqn.lhs,ls,lx) = eval(eqn.rhs,ls,lx)
    if S has Evalable(S) then
        eval(eqn1:$, eqn2:$):$ ==
           eval(eqn1.lhs, eqn2 pretend Equation S) =
               eval(eqn1.rhs, eqn2 pretend Equation S)
        eval(eqn1:$, leqn2:List $):$ ==
           eval(eqn1.lhs, leqn2 pretend List Equation S) =
               eval(eqn1.rhs, leqn2 pretend List Equation S)
    if S has SetCategory then
        eq1 = eq2 == (eq1.lhs = eq2.lhs)@Boolean and
                     (eq1.rhs = eq2.rhs)@Boolean
        coerce(eqn:$):Ex == eqn.lhs::Ex = eqn.rhs::Ex
        coerce(eqn:$):Boolean == eqn.lhs = eqn.rhs
    if S has AbelianSemiGroup then
        eq1 + eq2 == eq1.lhs + eq2.lhs = eq1.rhs + eq2.rhs
        s + eq2 == [s,s] + eq2
        eq1 + s == eq1 + [s,s]
    if S has AbelianGroup then
        - eq == (- lhs eq) = (-rhs eq)
        s - eq2 == [s,s] - eq2
        eq1 - s == eq1 - [s,s]
        leftZero eq == 0 = rhs eq - lhs eq
        rightZero eq == lhs eq - rhs eq = 0
        0 == equation(0$S,0$S)
        eq1 - eq2 == eq1.lhs - eq2.lhs = eq1.rhs - eq2.rhs
    if S has SemiGroup then
        eq1:$ * eq2:$ == eq1.lhs * eq2.lhs = eq1.rhs * eq2.rhs
        l:S   * eqn:$ == l       * eqn.lhs = l       * eqn.rhs
        l:S * eqn:$  ==  l * eqn.lhs    =    l * eqn.rhs
        eqn:$ * l:S  ==  eqn.lhs * l    =    eqn.rhs * l
        -- We have to be a bit careful here: raising to a +ve integer is OK
        -- (since it's the equivalent of repeated multiplication)
        -- but other powers may cause contradictions
        -- Watch what else you add here! JHD 2/Aug 1990
    if S has Monoid then
        1 == equation(1$S,1$S)
        recip eq ==
          (lh := recip lhs eq) case "failed" => "failed"
          (rh := recip rhs eq) case "failed" => "failed"
          [lh :: S, rh :: S]
        leftOne eq ==
          (re := recip lhs eq) case "failed" => "failed"
          1 = rhs eq * re
        rightOne eq ==
          (re := recip rhs eq) case "failed" => "failed"
          lhs eq * re = 1
    if S has Group then
        inv eq == [inv lhs eq, inv rhs eq]
        leftOne eq == 1 = rhs eq * inv rhs eq
        rightOne eq == lhs eq * inv rhs eq = 1
    if S has Ring then
        characteristic() == characteristic()$S
        i:Integer * eq:$ == (i::S) * eq
    if S has IntegralDomain then
        factorAndSplit eq ==
          (S has factor : S -> Factored S) =>
            eq0 := rightZero eq
            [equation(rcf.factor,0) for rcf in factors factor lhs eq0]
          (S has Polynomial Integer) =>
            eq0 := rightZero eq
            MF ==> MultivariateFactorize(Symbol, IndexedExponents Symbol, _
               Integer, Polynomial Integer)
            p : Polynomial Integer := (lhs eq0) pretend Polynomial Integer
            [equation((rcf.factor) pretend S,0) for rcf in factors factor(p)$MF]
          [eq]
    if S has PartialDifferentialRing(Symbol) then
        differentiate(eq:$, sym:Symbol):$ ==
           [differentiate(lhs eq, sym), differentiate(rhs eq, sym)]
    if S has Field then
        dimension() == 2 :: CardinalNumber
        eq1:$ / eq2:$ == eq1.lhs / eq2.lhs = eq1.rhs / eq2.rhs
        inv eq == [inv lhs eq, inv rhs eq]
    if S has ExpressionSpace then
        subst(eq1,eq2) ==
            eq3 := eq2 pretend Equation S
            [subst(lhs eq1,eq3),subst(rhs eq1,eq3)]

\end{verbatim}

<<initvars>>=
(defvar $index 0 "File line number of most recently read line")

@

<<initvars>>=
(defvar $linelist nil "Stack of preparsed lines")

@

<<initvars>>=
(defvar $echolinestack nil "Stack of lines to list")

@

<<initvars>>=
(defvar $preparse-last-line nil "Most recently read line")

@

\section{Parsing routines}
The {\bf initialize-preparse} expects to be called before the {\bf preparse}
function. It initializes the state, in particular, it reads a single line
from the input stream and stores it in {\tt \verb|$preparse-last-line|}.
The caller gives a stream and the {\tt \verb|$preparse-last-line|} variable
is initialized as:
\begin{verbatim}
    2> (INITIALIZE-PREPARSE #<input stream "/tmp/EQ.spad">)
    <2 (INITIALIZE-PREPARSE ")abbrev domain EQ Equation")
\end{verbatim}
\defun{initialize-preparse}{initialize-preparse}
\calls{initialize-preparse}{get-a-line}
\usesdollar{initialize-preparse}{index}
\usesdollar{initialize-preparse}{linelist}
\usesdollar{initialize-preparse}{echolinestack}
\usesdollar{initialize-preparse}{preparse-last-line}
<<defun initialize-preparse>>=
(defun initialize-preparse (strm)
  (setq $index 0)
  (setq $linelist nil)
  (setq $echolinestack nil)
  (setq $preparse-last-line (get-a-line strm)))

@

The {\bf preparse} function returns a list of pairs of the form:
( (linenumber . linestring) .... (linenumber . linestring))
For instance, for the file {\tt EQ.spad}, we get:
\begin{verbatim}
    2> (PREPARSE #<input stream "/tmp/EQ.spad">)
      3> (PREPARSE1 (")abbrev domain EQ Equation"))
        4> (|doSystemCommand| "abbrev domain EQ Equation")
        <4 (|doSystemCommand| NIL)
      <3 (PREPARSE1 ( ...[snip]... )
     <2 (PREPARSE (
 (19 . "Equation(S: Type): public == private where")
 (20 . " (Ex ==> OutputForm;")
 (21 . "  public ==> Type with")
 (22 . "   (\"=\": (S, S) -> $;")
 (24 . "    equation: (S, S) -> $;")
 (26 . "    swap: $ -> $;")
 (28 . "    lhs: $ -> S;")
 (30 . "    rhs: $ -> S;")
 (32 . "    map: (S -> S, $) -> $;")
 (35 . "    if S has InnerEvalable(Symbol,S) then")
 (36 . "             InnerEvalable(Symbol,S);")
 (37 . "    if S has SetCategory then")
 (38 . "       (SetCategory;")
 (39 . "        CoercibleTo Boolean;")
 (40 . "        if S has Evalable(S) then")
 (41 . "          (eval: ($, $) -> $;")
 (43 . "           eval: ($, List $) -> $));")
 (45 . "    if S has AbelianSemiGroup then")
 (46 . "       (AbelianSemiGroup;")
 (47 . "        \"+\": (S, $) -> $;")
 (50 . "        \"+\": ($, S) -> $);")
 (53 . "    if S has AbelianGroup then")
 (54 . "       (AbelianGroup;")
 (55 . "        leftZero : $ -> $;")
 (57 . "        rightZero : $ -> $;")
 (59 . "        \"-\": (S, $) -> $;")
 (62 . "        \"-\": ($, S) -> $);")
 (65 . "    if S has SemiGroup then")
 (66 . "       (SemiGroup;")
 (67 . "        \"*\": (S, $) -> $;")
 (70 . "        \"*\": ($, S) -> $);")
 (73 . "    if S has Monoid then")
 (74 . "       (Monoid;")
 (75 . "        leftOne : $ -> Union($,\"failed\");")
 (77 . "        rightOne : $ -> Union($,\"failed\"));")
 (79 . "    if S has Group then")
 (80 . "       (Group;")
 (81 . "        leftOne : $ -> Union($,\"failed\");")
 (83 . "        rightOne : $ -> Union($,\"failed\"));")
 (85 . "    if S has Ring then")
 (86 . "     (Ring;")
 (87 . "      BiModule(S,S));")
 (88 . "    if S has CommutativeRing then")
 (89 . "      Module(S);")
 (91 . "    if S has IntegralDomain then")
 (92 . "      factorAndSplit : $ -> List $;")
 (96 . "    if S has PartialDifferentialRing(Symbol) then")
 (97 . "      PartialDifferentialRing(Symbol);")
 (98 . "    if S has Field then")
 (99 . "     (VectorSpace(S);")
 (100 . "      \"/\": ($, $) -> $;")
 (103 . "      inv: $ -> $);")
 (105 . "    if S has ExpressionSpace then")
 (106 . "        subst: ($, $) -> $);")
 (109 . "  private ==> add")
 (110 . "   (Rep := Record(lhs: S, rhs: S);")
 (111 . "    eq1,eq2: $;")
 (112 . "    s : S;")
 (113 . "    if S has IntegralDomain then")
 (114 . "        factorAndSplit eq ==")
 (115 . "         ((S has factor : S -> Factored S) =>")
 (116 . "           (eq0 := rightZero eq;")
 (117 . "            [equation(rcf.factor,0) 
                       for rcf in factors factor lhs eq0]);")
 (118 . "          [eq]);")
 (119 . "    l:S = r:S      == [l, r];")
 (120 . "    equation(l, r) == [l, r];")
 (121 . "    lhs eqn        == eqn.lhs;")
 (122 . "    rhs eqn        == eqn.rhs;")
 (123 . "    swap eqn     == [rhs eqn, lhs eqn];")
 (124 . "    map(fn, eqn)   == equation(fn(eqn.lhs), fn(eqn.rhs));")
 (125 . "    if S has InnerEvalable(Symbol,S) then")
 (126 . "       (s:Symbol;")
 (127 . "        ls:List Symbol;")
 (128 . "        x:S;")
 (129 . "        lx:List S;")
 (130 . "        eval(eqn,s,x) == eval(eqn.lhs,s,x) = eval(eqn.rhs,s,x);")
 (131 . "        eval(eqn,ls,lx) == eval(eqn.lhs,ls,lx) = 
                                     eval(eqn.rhs,ls,lx));")
 (132 . "    if S has Evalable(S) then")
 (133 . "       (eval(eqn1:$, eqn2:$):$ ==")
 (134 . "           eval(eqn1.lhs, eqn2 pretend Equation S) =")
 (135 . "               eval(eqn1.rhs, eqn2 pretend Equation S);")
 (136 . "        eval(eqn1:$, leqn2:List $):$ ==")
 (137 . "           eval(eqn1.lhs, leqn2 pretend List Equation S) =")
 (138 . "               eval(eqn1.rhs, leqn2 pretend List Equation S));")
 (139 . "    if S has SetCategory then")
 (140 . "       (eq1 = eq2 == (eq1.lhs = eq2.lhs)@Boolean and")
 (141 . "                     (eq1.rhs = eq2.rhs)@Boolean;")
 (142 . "        coerce(eqn:$):Ex == eqn.lhs::Ex = eqn.rhs::Ex;")
 (143 . "        coerce(eqn:$):Boolean == eqn.lhs = eqn.rhs);")
 (144 . "    if S has AbelianSemiGroup then")
 (145 . "       (eq1 + eq2 == eq1.lhs + eq2.lhs = eq1.rhs + eq2.rhs;")
 (146 . "        s + eq2 == [s,s] + eq2;")
 (147 . "        eq1 + s == eq1 + [s,s]);")
 (148 . "    if S has AbelianGroup then")
 (149 . "       (- eq == (- lhs eq) = (-rhs eq);")
 (150 . "        s - eq2 == [s,s] - eq2;")
 (151 . "        eq1 - s == eq1 - [s,s];")
 (152 . "        leftZero eq == 0 = rhs eq - lhs eq;")
 (153 . "        rightZero eq == lhs eq - rhs eq = 0;")
 (154 . "        0 == equation(0$S,0$S);")
 (155 . "        eq1 - eq2 == eq1.lhs - eq2.lhs = eq1.rhs - eq2.rhs);")
 (156 . "    if S has SemiGroup then")
 (157 . "       (eq1:$ * eq2:$ == eq1.lhs * eq2.lhs = eq1.rhs * eq2.rhs;")
 (158 . "        l:S   * eqn:$ == l       * eqn.lhs = l       * eqn.rhs;")
 (159 . "        l:S * eqn:$  ==  l * eqn.lhs    =    l * eqn.rhs;")
 (160 . "        eqn:$ * l:S  ==  eqn.lhs * l    =    eqn.rhs * l);")
 (165 . "    if S has Monoid then")
 (166 . "       (1 == equation(1$S,1$S);")
 (167 . "        recip eq ==")
 (168 . "         ((lh := recip lhs eq) case \"failed\" => \"failed\";")
 (169 . "          (rh := recip rhs eq) case \"failed\" => \"failed\";")
 (170 . "          [lh :: S, rh :: S]);")
 (171 . "        leftOne eq ==")
 (172 . "         ((re := recip lhs eq) case \"failed\" => \"failed\";")
 (173 . "          1 = rhs eq * re);")
 (174 . "        rightOne eq ==")
 (175 . "         ((re := recip rhs eq) case \"failed\" => \"failed\";")
 (176 . "          lhs eq * re = 1));")
 (177 . "    if S has Group then")
 (178 . "       (inv eq == [inv lhs eq, inv rhs eq];")
 (179 . "        leftOne eq == 1 = rhs eq * inv rhs eq;")
 (180 . "        rightOne eq == lhs eq * inv rhs eq = 1);")
 (181 . "    if S has Ring then")
 (182 . "       (characteristic() == characteristic()$S;")
 (183 . "        i:Integer * eq:$ == (i::S) * eq);")
 (184 . "    if S has IntegralDomain then")
 (185 . "        factorAndSplit eq ==")
 (186 . "         ((S has factor : S -> Factored S) =>")
 (187 . "           (eq0 := rightZero eq;")
 (188 . "            [equation(rcf.factor,0) 
                         for rcf in factors factor lhs eq0]);")
 (189 . "          (S has Polynomial Integer) =>")
 (190 . "           (eq0 := rightZero eq;")
 (191 . "            MF ==> MultivariateFactorize(Symbol, 
                                IndexedExponents Symbol,
                                Integer, Polynomial Integer);")
 (193 . "            p : Polynomial Integer := 
                           (lhs eq0) pretend Polynomial Integer;")
 (194 . "            [equation((rcf.factor) pretend S,0) 
                           for rcf in factors factor(p)$MF]);")
 (195 . "          [eq]);")
 (196 . "    if S has PartialDifferentialRing(Symbol) then")
 (197 . "        differentiate(eq:$, sym:Symbol):$ ==")
 (198 . "           [differentiate(lhs eq, sym), differentiate(rhs eq, sym)];")
 (199 . "    if S has Field then")
 (200 . "       (dimension() == 2 :: CardinalNumber;")
 (201 . "        eq1:$ / eq2:$ == eq1.lhs / eq2.lhs = eq1.rhs / eq2.rhs;")
 (202 . "        inv eq == [inv lhs eq, inv rhs eq]);")
 (203 . "    if S has ExpressionSpace then")
 (204 . "        subst(eq1,eq2) ==")
 (205 . "           (eq3 := eq2 pretend Equation S;")
 (206 . "            [subst(lhs eq1,eq3),subst(rhs eq1,eq3)])))")))
\end{verbatim}

\defun{preparse}{preparse}
\calls{preparse}{preparse}
\calls{preparse}{preparse1}
\calls{preparse}{parseprint}
\calls{preparse}{ifcar}
\usesdollar{preparse}{comblocklist}
\usesdollar{preparse}{skipme}
\usesdollar{preparse}{preparse-last-line}
\usesdollar{preparse}{index}
\usesdollar{preparse}{docList}
\usesdollar{preparse}{preparseReportIfTrue}
\usesdollar{preparse}{headerDocumentation}
\usesdollar{preparse}{maxSignatureLineNumber}
\usesdollar{preparse}{constructorLineNumber}
<<defun preparse>>=
(defun preparse (strm &aux (stack ()))
 (declare (special $comblocklist $skipme $preparse-last-line $index |$docList|
            $preparseReportIfTrue |$headerDocumentation|
            |$maxSignatureLineNumber| |$constructorLineNumber|))
  (setq $comblocklist nil)
  (setq $skipme nil)
  (when $preparse-last-line
   (if (pairp $preparse-last-line)
    (setq stack $preparse-last-line)
    (push $preparse-last-line stack))
   (setq $index (- $index (length stack))))
  (let ((u (preparse1 stack)))
   (if $skipme 
    (preparse strm)
    (progn
      (when $preparseReportIfTrue (parseprint u))
      (setq |$headerDocumentation| nil)
      (setq |$docList| nil)
      (setq |$maxSignatureLineNumber| 0)
      (setq |$constructorLineNumber| (ifcar (ifcar u)))
      u))))

@

The {\bf preparse} function returns a list of pairs of the form:
( (linenumber . linestring) .... (linenumber . linestring))
For instance, for the file {\tt EQ.spad}, we get:
\begin{verbatim}
    2> (PREPARSE #<input stream "/tmp/EQ.spad">)
      3> (PREPARSE1 (")abbrev domain EQ Equation"))
        4> (|doSystemCommand| "abbrev domain EQ Equation")
        <4 (|doSystemCommand| NIL)
      <3 (PREPARSE1 (
 (19 . "Equation(S: Type): public == private where")
 (20 . " (Ex ==> OutputForm;")
 (21 . "  public ==> Type with")
 (22 . "   (\"=\": (S, S) -> $;")
 (24 . "    equation: (S, S) -> $;")
 (26 . "    swap: $ -> $;")
 (28 . "    lhs: $ -> S;")
 (30 . "    rhs: $ -> S;")
 (32 . "    map: (S -> S, $) -> $;")
 (35 . "    if S has InnerEvalable(Symbol,S) then")
 (36 . "             InnerEvalable(Symbol,S);")
 (37 . "    if S has SetCategory then")
 (38 . "       (SetCategory;")
 (39 . "        CoercibleTo Boolean;")
 (40 . "        if S has Evalable(S) then")
 (41 . "          (eval: ($, $) -> $;")
 (43 . "           eval: ($, List $) -> $));")
 (45 . "    if S has AbelianSemiGroup then")
 (46 . "       (AbelianSemiGroup;")
 (47 . "        \"+\": (S, $) -> $;")
 (50 . "        \"+\": ($, S) -> $);")
 (53 . "    if S has AbelianGroup then")
 (54 . "       (AbelianGroup;")
 (55 . "        leftZero : $ -> $;")
 (57 . "        rightZero : $ -> $;")
 (59 . "        \"-\": (S, $) -> $;")
 (62 . "        \"-\": ($, S) -> $);")
 (65 . "    if S has SemiGroup then")
 (66 . "       (SemiGroup;")
 (67 . "        \"*\": (S, $) -> $;")
 (70 . "        \"*\": ($, S) -> $);")
 (73 . "    if S has Monoid then")
 (74 . "       (Monoid;")
 (75 . "        leftOne : $ -> Union($,\"failed\");")
 (77 . "        rightOne : $ -> Union($,\"failed\"));")
 (79 . "    if S has Group then")
 (80 . "       (Group;")
 (81 . "        leftOne : $ -> Union($,\"failed\");")
 (83 . "        rightOne : $ -> Union($,\"failed\"));")
 (85 . "    if S has Ring then")
 (86 . "     (Ring;")
 (87 . "      BiModule(S,S));")
 (88 . "    if S has CommutativeRing then")
 (89 . "      Module(S);")
 (91 . "    if S has IntegralDomain then")
 (92 . "      factorAndSplit : $ -> List $;")
 (96 . "    if S has PartialDifferentialRing(Symbol) then")
 (97 . "      PartialDifferentialRing(Symbol);")
 (98 . "    if S has Field then")
 (99 . "     (VectorSpace(S);")
 (100 . "      \"/\": ($, $) -> $;")
 (103 . "      inv: $ -> $);")
 (105 . "    if S has ExpressionSpace then")
 (106 . "        subst: ($, $) -> $);")
 (109 . "  private ==> add")
 (110 . "   (Rep := Record(lhs: S, rhs: S);")
 (111 . "    eq1,eq2: $;")
 (112 . "    s : S;")
 (113 . "    if S has IntegralDomain then")
 (114 . "        factorAndSplit eq ==")
 (115 . "         ((S has factor : S -> Factored S) =>")
 (116 . "           (eq0 := rightZero eq;")
 (117 . "            [equation(rcf.factor,0) 
                       for rcf in factors factor lhs eq0]);")
 (118 . "          [eq]);")
 (119 . "    l:S = r:S      == [l, r];")
 (120 . "    equation(l, r) == [l, r];")
 (121 . "    lhs eqn        == eqn.lhs;")
 (122 . "    rhs eqn        == eqn.rhs;")
 (123 . "    swap eqn     == [rhs eqn, lhs eqn];")
 (124 . "    map(fn, eqn)   == equation(fn(eqn.lhs), fn(eqn.rhs));")
 (125 . "    if S has InnerEvalable(Symbol,S) then")
 (126 . "       (s:Symbol;")
 (127 . "        ls:List Symbol;")
 (128 . "        x:S;")
 (129 . "        lx:List S;")
 (130 . "        eval(eqn,s,x) == eval(eqn.lhs,s,x) = eval(eqn.rhs,s,x);")
 (131 . "        eval(eqn,ls,lx) == eval(eqn.lhs,ls,lx) = 
                                     eval(eqn.rhs,ls,lx));")
 (132 . "    if S has Evalable(S) then")
 (133 . "       (eval(eqn1:$, eqn2:$):$ ==")
 (134 . "           eval(eqn1.lhs, eqn2 pretend Equation S) =")
 (135 . "               eval(eqn1.rhs, eqn2 pretend Equation S);")
 (136 . "        eval(eqn1:$, leqn2:List $):$ ==")
 (137 . "           eval(eqn1.lhs, leqn2 pretend List Equation S) =")
 (138 . "               eval(eqn1.rhs, leqn2 pretend List Equation S));")
 (139 . "    if S has SetCategory then")
 (140 . "       (eq1 = eq2 == (eq1.lhs = eq2.lhs)@Boolean and")
 (141 . "                     (eq1.rhs = eq2.rhs)@Boolean;")
 (142 . "        coerce(eqn:$):Ex == eqn.lhs::Ex = eqn.rhs::Ex;")
 (143 . "        coerce(eqn:$):Boolean == eqn.lhs = eqn.rhs);")
 (144 . "    if S has AbelianSemiGroup then")
 (145 . "       (eq1 + eq2 == eq1.lhs + eq2.lhs = eq1.rhs + eq2.rhs;")
 (146 . "        s + eq2 == [s,s] + eq2;")
 (147 . "        eq1 + s == eq1 + [s,s]);")
 (148 . "    if S has AbelianGroup then")
 (149 . "       (- eq == (- lhs eq) = (-rhs eq);")
 (150 . "        s - eq2 == [s,s] - eq2;")
 (151 . "        eq1 - s == eq1 - [s,s];")
 (152 . "        leftZero eq == 0 = rhs eq - lhs eq;")
 (153 . "        rightZero eq == lhs eq - rhs eq = 0;")
 (154 . "        0 == equation(0$S,0$S);")
 (155 . "        eq1 - eq2 == eq1.lhs - eq2.lhs = eq1.rhs - eq2.rhs);")
 (156 . "    if S has SemiGroup then")
 (157 . "       (eq1:$ * eq2:$ == eq1.lhs * eq2.lhs = eq1.rhs * eq2.rhs;")
 (158 . "        l:S   * eqn:$ == l       * eqn.lhs = l       * eqn.rhs;")
 (159 . "        l:S * eqn:$  ==  l * eqn.lhs    =    l * eqn.rhs;")
 (160 . "        eqn:$ * l:S  ==  eqn.lhs * l    =    eqn.rhs * l);")
 (165 . "    if S has Monoid then")
 (166 . "       (1 == equation(1$S,1$S);")
 (167 . "        recip eq ==")
 (168 . "         ((lh := recip lhs eq) case \"failed\" => \"failed\";")
 (169 . "          (rh := recip rhs eq) case \"failed\" => \"failed\";")
 (170 . "          [lh :: S, rh :: S]);")
 (171 . "        leftOne eq ==")
 (172 . "         ((re := recip lhs eq) case \"failed\" => \"failed\";")
 (173 . "          1 = rhs eq * re);")
 (174 . "        rightOne eq ==")
 (175 . "         ((re := recip rhs eq) case \"failed\" => \"failed\";")
 (176 . "          lhs eq * re = 1));")
 (177 . "    if S has Group then")
 (178 . "       (inv eq == [inv lhs eq, inv rhs eq];")
 (179 . "        leftOne eq == 1 = rhs eq * inv rhs eq;")
 (180 . "        rightOne eq == lhs eq * inv rhs eq = 1);")
 (181 . "    if S has Ring then")
 (182 . "       (characteristic() == characteristic()$S;")
 (183 . "        i:Integer * eq:$ == (i::S) * eq);")
 (184 . "    if S has IntegralDomain then")
 (185 . "        factorAndSplit eq ==")
 (186 . "         ((S has factor : S -> Factored S) =>")
 (187 . "           (eq0 := rightZero eq;")
 (188 . "            [equation(rcf.factor,0) 
                         for rcf in factors factor lhs eq0]);")
 (189 . "          (S has Polynomial Integer) =>")
 (190 . "           (eq0 := rightZero eq;")
 (191 . "            MF ==> MultivariateFactorize(Symbol, 
                                IndexedExponents Symbol,
                                Integer, Polynomial Integer);")
 (193 . "            p : Polynomial Integer := 
                           (lhs eq0) pretend Polynomial Integer;")
 (194 . "            [equation((rcf.factor) pretend S,0) 
                           for rcf in factors factor(p)$MF]);")
 (195 . "          [eq]);")
 (196 . "    if S has PartialDifferentialRing(Symbol) then")
 (197 . "        differentiate(eq:$, sym:Symbol):$ ==")
 (198 . "           [differentiate(lhs eq, sym), differentiate(rhs eq, sym)];")
 (199 . "    if S has Field then")
 (200 . "       (dimension() == 2 :: CardinalNumber;")
 (201 . "        eq1:$ / eq2:$ == eq1.lhs / eq2.lhs = eq1.rhs / eq2.rhs;")
 (202 . "        inv eq == [inv lhs eq, inv rhs eq]);")
 (203 . "    if S has ExpressionSpace then")
 (204 . "        subst(eq1,eq2) ==")
 (205 . "           (eq3 := eq2 pretend Equation S;")
 (206 . "            [subst(lhs eq1,eq3),subst(rhs eq1,eq3)])))")))
\end{verbatim}

\defun{preparse1}{Build the lines from the input for piles}
\calls{preparse1}{preparseReadLine}
\calls{preparse1}{preparse-echo}
\calls{preparse1}{fincomblock}
\calls{preparse1}{parsepiles}
\calls{preparse1}{doSystemCommand}
\calls{preparse1}{escaped}
\calls{preparse1}{instring}
\calls{preparse1}{indent-pos}
\calls{preparse1}{getfullstr}
\calls{preparse1}{maxindex}
\calls{preparse1}{strposl}
\calls{preparse1}{is-console}
\catches{preparse1}{spad-reader}
\usesdollar{preparse1}{linelist}
\usesdollar{preparse1}{echolinestack}
\usesdollar{preparse1}{byConstructors}
\usesdollar{preparse1}{skipme}
\usesdollar{preparse1}{constructorsSeen}
\usesdollar{preparse1}{preparse-last-line}
<<defun preparse1>>=
(defun preparse1 (linelist)
 (prog (($linelist linelist) $echolinestack num a i l psloc
        instring pcount comsym strsym oparsym cparsym n ncomsym
        (sloc -1) (continue nil)  (parenlev 0) (ncomblock ())
        (lines ()) (locs ()) (nums ()) functor)
 (declare (special $linelist $echolinestack |$byConstructors| $skipme
           |$constructorsSeen| $preparse-last-line))
READLOOP 
  (dcq (num . a) (preparseReadLine linelist))
  (unless (stringp a)
    (preparse-echo linelist)
    (cond 
     ((null lines) (return nil))
     (ncomblock    (fincomblock nil nums locs ncomblock nil)))
    (return
     (pair (nreverse nums) (parsepiles (nreverse locs) (nreverse lines)))))
  ; this is a command line, don't parse it
  (when (and (null lines) (> (length a) 0) (eq (char a 0) #\) ))
    (preparse-echo linelist)
    (setq $preparse-last-line nil) ;don't reread this line
    (setq line a)
    (catch 'spad_reader (|doSystemCommand| (subseq line 1)))
    (go READLOOP))
  (setq l (length a))
  ; if we get a null line, read the next line
  (when (eq l 0) (go READLOOP))
  ; otherwise we have to parse this line
  (setq psloc sloc)
  (setq i 0)
  (setq instring nil)
  (setq pcount 0)
STRLOOP ;; handle things that need ignoring, quoting, or grouping
  ; are we in a comment, quoting, or grouping situation?
  (setq strsym (or (position #\" a :start i ) l))
  (setq comsym (or (search "--" a :start2 i ) l))
  (setq ncomsym (or (search "++" a :start2 i ) l))
  (setq oparsym (or (position #\( a :start i ) l))
  (setq cparsym (or (position #\) a :start i ) l))
  (setq n (min strsym comsym ncomsym oparsym cparsym))
  (cond 
   ; nope, we found no comment, quoting, or grouping
   ((= n l) (go NOCOMS))
   ((escaped a n))
   ; scan until we hit the end of the string
   ((= n strsym) (setq instring (not instring)))
   (instring)
   ;; handle -- comments by ignoring them
   ((= n comsym)
    (setq a (subseq a 0 n))
    (go NOCOMS)) ; discard trailing comment
   ;; handle ++ comments by chunking them together
   ((= n ncomsym)
    (setq sloc (indent-pos a))
    (cond
     ((= sloc n)
      (when (and ncomblock (not (= n (car ncomblock))))
       (fincomblock num nums locs ncomblock linelist)
       (setq ncomblock nil))
      (setq ncomblock (cons n (cons a (ifcdr ncomblock))))
      (setq a ""))
     (t 
      (push (strconc (getfullstr n " ") (substring a n ())) $linelist)
      (setq $index (1- $index))
      (setq a (subseq a 0 n))))
    (go NOCOMS))
   ; know how deep we are into parens
   ((= n oparsym) (setq pcount (1+ pcount)))
   ((= n cparsym) (setq pcount (1- pcount))))
  (setq i (1+ n))
  (go STRLOOP)
NOCOMS 
  ; remember the indentation level
  (setq sloc (indent-pos a))
  (setq a (string-right-trim " " a))
  (when (null sloc)
   (setq sloc psloc)
   (go READLOOP))
  ; handle line that ends in a continuation character
  (cond
   ((eq (elt a (maxindex a)) xcape)
    (setq continue t)
    (setq a (subseq a (maxindex a))))
   ((setq continue nil)))
  ; test for skipping constructors
  (when (and (null lines) (= sloc 0))
    (if (and |$byConstructors|
             (null (search "==>" a))
             (not 
              (member 
               (setq functor 
                (intern (substring a 0 (strposl ": (=" a 0 nil))))
                |$byConstructors|)))
       (setq $skipme 't)
       (progn
        (push functor |$constructorsSeen|)
        (setq $skipme nil))))
  ; is this thing followed by ++ comments?
  (when (and lines (eql sloc 0))
   (when (and ncomblock (not (zerop (car ncomblock))))
    (fincomblock num nums locs ncomblock linelist))
   (when (not (is-console in-stream))
    (setq $preparse-last-line (nreverse $echolinestack)))
   (return
    (pair (nreverse nums) (parsepiles (nreverse locs) (nreverse lines)))))
  (when (> parenlev 0)
   (push nil locs)
   (setq sloc psloc)
   (go REREAD))
  (when ncomblock
   (fincomblock num nums locs ncomblock linelist)
   (setq ncomblock ()))
  (push sloc locs)
REREAD 
  (preparse-echo linelist)
  (push a lines)
  (push num nums)
  (setq parenlev (+ parenlev pcount))
  (when (and (is-console in-stream) (not continue))
   (setq $preparse-last-line nil)
   (return
    (pair (nreverse nums) (parsepiles (nreverse locs) (nreverse lines)))))
  (go READLOOP)))

@

\defun{parsepiles}{parsepiles}
Add parens and semis to lines to aid parsing.
\calls{parsepiles}{add-parens-and-semis-to-line}
<<defun parsepiles>>=
(defun parsepiles (locs lines)
  (mapl #'add-parens-and-semis-to-line
    (nconc lines '(" ")) (nconc locs '(nil)))
  lines)

@
 
\defun{add-parens-and-semis-to-line}{add-parens-and-semis-to-line}
The line to be worked on is (CAR SLINES).  It's indentation is (CAR SLOCS).
There is a notion of current indentation. Then:
\begin{itemize}
\item Add open paren to beginning of following line if following line's 
indentation is greater than current, and add close paren to end of 
last succeeding line with following line's indentation.
\item Add semicolon to end of line if following line's indentation is the same.
\item If the entire line consists of the single keyword then or else, 
leave it alone."
\end{itemize}
\calls{add-parens-and-semis-to-line}{infixtok}
\calls{add-parens-and-semis-to-line}{drop}
\calls{add-parens-and-semis-to-line}{addclose}
\calls{add-parens-and-semis-to-line}{nonblankloc}
<<defun add-parens-and-semis-to-line>>=
(defun add-parens-and-semis-to-line (slines slocs)
 (let ((start-column (car slocs)))
  (when (and start-column (> start-column 0))
   (let ((count 0) (i 0))
    (seq
     (mapl #'(lambda (next-lines nlocs)
              (let ((next-line (car next-lines)) (next-column (car nlocs)))
               (incf i)
               (when next-column
                (setq next-column (abs next-column))
                (when (< next-column start-column) (exit nil))
                (cond
                 ((and (eq next-column start-column)
                       (rplaca nlocs (- (car nlocs)))
                       (not (infixtok next-line)))
                   (setq next-lines (drop (1- i) slines))
                   (rplaca next-lines (addclose (car next-lines) #\;))
                   (setq count (1+ count)))))))
                 (cdr slines) (cdr slocs)))
     (when (> count 0)
      (setf (char (car slines) (1- (nonblankloc (car slines)))) #\( )
      (setq slines (drop (1- i) slines))
      (rplaca slines (addclose (car slines) #\) )))))))
 
@\defun{preparseReadLine}{preparseReadLine}
\calls{preparseReadLine}{dcq}
\calls{preparseReadLine}{preparseReadLine1}
\calls{preparseReadLine}{initial-substring}
\calls{preparseReadLine}{string2BootTree}
\calls{preparseReadLine}{storeblanks}
\calls{preparseReadLine}{skip-to-endif}
\calls{preparseReadLine}{preparseReadLine}
<<defun preparseReadLine>>=
(defun preparseReadLine (x)
 (let (line ind)
  (dcq (ind . line) (preparseReadLine1 x))
  (cond
   ((not (stringp line)) (cons ind line))
   ((zerop (size line))  (cons ind line))
   ((char= (elt line 0) #\) )
    (cond
     ((initial-substring ")if" line)
      (if (eval (|string2BootTree| (storeblanks line 3)))
       (preparseReadLine x)
       (skip-ifblock x)))
     ((initial-substring ")elseif" line) (skip-to-endif x))
     ((initial-substring ")else" line)   (skip-to-endif x))
     ((initial-substring ")endif" line)  (preparseReadLine x))
     ((initial-substring ")fin" line)
      (setq *eof* t)
      (cons ind nil)))))
  (cons ind line)))
 
@

\defun{preparseReadLine1}{preparseReadLine1}
\calls{preparseReadLine1}{get-a-line}
\calls{preparseReadLine1}{expand-tabs}
\calls{preparseReadLine1}{maxindex}
\calls{preparseReadLine1}{strconc}
\calls{preparseReadLine1}{preparseReadLine1}
\usesdollar{preparseReadLine1}{linelist}
\usesdollar{preparseReadLine1}{preparse-last-line}
\usesdollar{preparseReadLine1}{index}
\usesdollar{preparseReadLine1}{EchoLineStack}
<<defun preparseReadLine1>>=
(defun preparseReadLine1 (x)
 (let (line ind)
 (declare (special $linelist $preparse-last-line $index $EchoLineStack))
  (setq line
   (if $linelist
    (pop $linelist)
    (expand-tabs (get-a-line in-stream))))
  (setq $preparse-last-line line)
  (if (stringp line)
   (progn
    (incf $index)
    (setq line (string-right-trim " " line))
    (push (copy-seq line) $EchoLineStack)
    (cons $index
     (if (and (> (setq ind (maxindex line)) -1) (char= (elt line ind) #\_))
      (setq $preparse-last-line
        (strconc (substring line 0 ind) (cdr (preparseReadLine1 x))))
      line)))
    (cons $index line))))
 
@

\section{I/O Handling}
\defun{preparse-echo}{preparse-echo}
\uses{preparse-echo}{Echo-Meta}
\usesdollar{preparse-echo}{EchoLineStack}
<<defun preparse-echo>>=
(defun preparse-echo (linelist)
 (declare (special $EchoLineStack Echo-Meta))
 (if Echo-Meta 
  (dolist (x (reverse $EchoLineStack))
   (format out-stream "~&;~A~%" x)))
 (setq $EchoLineStack ()))

@

<<initvars>>=
(defparameter Current-Fragment nil
  "A string containing remaining chars from readline; needed because
Symbolics read-line returns embedded newlines in a c-m-Y.")

@

\defun{read-a-line}{read-a-line}
\calls{read-a-line}{subseq}
\calls{read-a-line}{Line-New-Line}
\calls{read-a-line}{read-a-line}
\uses{read-a-line}{*eof*}
<<defun read-a-line>>=
(defun read-a-line (&optional (stream t))
 (let (cp)
 (declare (special *eof*))
  (if (and Current-Fragment (> (length Current-Fragment) 0))
   (let ((line (with-input-from-string
                 (s Current-Fragment :index cp :start 0)
                 (read-line s nil nil))))
    (setq Current-Fragment (subseq Current-Fragment cp))
    line)
   (prog nil
    (when (stream-eof in-stream)
      (setq File-Closed t)
      (setq *eof* t)
      (Line-New-Line (make-string 0) Current-Line)
      (return nil))
    (when (setq Current-Fragment (read-line stream))
     (return (read-a-line stream)))))))

@

\section{Line Handling}

\defun{storeblanks}{storeblanks}
<<defun storeblanks>>=
(defun storeblanks (line n)
 (do ((i 0 (1+ i)))
     ((= i n) line)
  (setf (char line i) #\ )))

@
 
\defun{initial-substring}{initial-substring}
\calls{initial-substring}{mismatch}
<<defun initial-substring>>=
(defun initial-substring (pattern line)
   (let ((ind (mismatch pattern line)))
     (or (null ind) (eql ind (size pattern)))))

@
 
\defun{get-a-line}{get-a-line}
\calls{get-a-line}{is-console}
\calls{get-a-line}{mkprompt}
\calls{get-a-line}{read-a-line}
\calls{get-a-line}{make-string-adjustable}
<<defun get-a-line>>=
(defun get-a-line (stream)
 (when (is-console stream) (princ (mkprompt)))
 (let ((ll (read-a-line stream)))
  (if (stringp ll)
   (make-string-adjustable ll)
   ll)))

@

\defun{make-string-adjustable}{make-string-adjustable}
<<defun make-string-adjustable>>=
(defun make-string-adjustable (s)
 (if (adjustable-array-p s) 
  s
  (make-array (array-dimensions s) :element-type 'string-char
                  :adjustable t :initial-contents s)))

@

\chapter{Transformers}
\defun{postTransform}{postTransform}
\calls{postTransform}{postTran}
\calls{postTransform}{identp}
\calls{postTransform}{postTransformCheck}
\calls{postTransform}{aplTran}
<<defun postTransform>>=
(defun |postTransform| (y)
 (let (x tmp1 tmp2 tmp3 tmp4 tmp5 tt l u)
  (setq x y)
  (setq u (|postTran| x))
  (when
   (and (pairp u) (eq (qcar u) '|@Tuple|)
        (progn
         (setq tmp1 (qcdr u))
         (and (pairp tmp1)
              (progn (setq tmp2 (reverse tmp1)) t)
              (pairp tmp2)
              (progn
               (setq tmp3 (qcar tmp2))
               (and (pairp tmp3)
                    (eq (qcar tmp3) '|:|)
                    (progn
                     (setq tmp4 (qcdr tmp3))
                     (and (pairp tmp4)
                          (progn
                           (setq y (qcar tmp4))
                           (setq tmp5 (qcdr tmp4))
                           (and (pairp tmp5)
                                (eq (qcdr tmp5) nil)
                                (progn (setq tt (qcar tmp5)) t)))))))
                        (progn (setq l (qcdr tmp2)) t)
                        (progn (setq l (nreverse l)) t)))
              (dolist (x l t) (unless (identp x) (return nil))))
    (setq u (list '|:| (cons 'listof (append l (list y))) tt)))
  (|postTransformCheck| u)
  (|aplTran| u)))

@

\begin{postTran}{postTran}
\calls{postTran}{postAtom}
\calls{postTran}{postTran}
\calls{postTran}{pairp}
\calls{postTran}{qcar}
\calls{postTran}{qcdr}
\calls{postTran}{unTuple}
\calls{postTran}{postTranList}
\calls{postTran}{postForm}
\calls{postTran}{postOp}
\calls{postTran}{postScriptsForm}
<<defun postTran>>=
(defun |postTran| (x)
 (let (op f tmp1 a tmp2 tmp3 b y)
  (if (atom x)
   (|postAtom| x)
   (progn
    (setq op (car x))
    (cond
     ((and (atom op) (setq f (getl op '|postTran|)))
      (funcall f x))
     ((and (pairp op) (eq (qcar op) '|elt|)
           (progn
            (setq tmp1 (qcdr op))
            (and (pairp tmp1)
                 (progn
                   (setq a (qcar tmp1))
                   (setq tmp2 (qcdr tmp1))
                   (and (pairp tmp2)
                        (eq (qcdr tmp2) nil)
                        (progn (setq b (qcar tmp2)) t))))))
      (cons (|postTran| op) (cdr (|postTran| (cons b (cdr x))))))
     ((and (pairp op) (eq (qcar op) '|Scripts|))
      (|postScriptsForm| op
       (dolist (y (rest x) tmp3)
        (setq tmp3 (append tmp3 (|unTuple| (|postTran| y)))))))
     ((nequal op (setq y (|postOp| op)))
      (cons y (|postTranList| (cdr x))))
     (t (|postForm| x)))))))

@

\defun{postAtom}{postAtom}
\usesdollar{postAtom}{boot}
<<defun postAtom>>=
(defun |postAtom| (x)
 (declare (special $boot))
  (cond
    ($boot x)
    ((eql x 0) '(|Zero|))
    ((eql x 1) '(|One|))
    ((eq x t) 't$)
    ((and (identp x) (getdatabase x 'niladic)) (list x))
    (t x)))

@

\defun{postTranList}{postTranList}
\calls{postTranList}{postTran}
<<defun postTranList>>=
(defun |postTranList| (x)
 (loop for y in x collect (|postTran| y)))

@

\defun{postScriptsForm}{postScriptsForm}
\calls{postScriptsForm}{getScriptName}
\calls{postScriptsForm}{length}
\calls{postScriptsForm}{postTranScripts}
<<defun postScriptsForm>>=
(defun |postScriptsForm| (arg0 argl)
 (let ((op (second arg0)) (a (third arg0)))
  (cons (|getScriptName| op a (|#| argl))
        (append (|postTranScripts| a) argl))))

@

\chapter{The Compiler}

\section{Compiling EQ.spad}
Given the top level command:
\begin{verbatim}
)co EQ
\end{verbatim}
The default call chain looks like:
\begin{verbatim}
1> (|compiler| ...)
 2> (|compileSpad2Cmd| ...)
   Compiling AXIOM source code from file /tmp/A.spad using old system 
      compiler.
  3> (|compilerDoit| ...)
   4> (|/RQ,LIB|)
    5> (/RF-1 ...)
     6> (SPAD ...)
   AXSERV abbreviates package AxiomServer 
      7> (S-PROCESS ...)
       8> (|compTopLevel| ...)
        9> (|compOrCroak| ...)
         10> (|compOrCroak1| ...)
          11> (|comp| ...)
           12> (|compNoStacking| ...)
            13> (|comp2| ...)
             14> (|comp3| ...)
              15> (|compExpression| ...)
*              16> (|compWhere| ...)
                17> (|comp| ...)
                 18> (|compNoStacking| ...)
                  19> (|comp2| ...)
                   20> (|comp3| ...)
                    21> (|compExpression| ...)
                     22> (|compSeq| ...)
                      23> (|compSeq1| ...)
                       24> (|compSeqItem| ...)
                        25> (|comp| ...)
                         26> (|compNoStacking| ...)
                          27> (|comp2| ...)
                           28> (|comp3| ...)
                            29> (|compExpression| ...)
                            <29 (|compExpression| ...)
                           <28 (|comp3| ...)
                          <27 (|comp2| ...)
                         <26 (|compNoStacking| ...)
                        <25 (|comp| ...)
                       <24 (|compSeqItem| ...)
                       24> (|compSeqItem| ...)
                        25> (|comp| ...)
                         26> (|compNoStacking| ...)
                          27> (|comp2| ...)
                           28> (|comp3| ...)
                            29> (|compExpression| ...)
                             30> (|compExit| ...)
                              31> (|comp| ...)
                               32> (|compNoStacking| ...)
                                33> (|comp2| ...)
                                 34> (|comp3| ...)
                                  35> (|compExpression| ...)
                                  <35 (|compExpression| ...)
                                 <34 (|comp3| ...)
                                <33 (|comp2| ...)
                               <32 (|compNoStacking| ...)
                              <31 (|comp| ...)
                              31> (|modifyModeStack| ...)
                              <31 (|modifyModeStack| ...)
                             <30 (|compExit| ...)
                            <29 (|compExpression| ...)
                           <28 (|comp3| ...)
                          <27 (|comp2| ...)
                         <26 (|compNoStacking| ...)
                        <25 (|comp| ...)
                       <24 (|compSeqItem| ...)
                       24> (|replaceExitEtc| ...)
                        25> (|replaceExitEtc,fn| ...)
                         26> (|replaceExitEtc| ...)
                          27> (|replaceExitEtc,fn| ...)
                           28> (|replaceExitEtc| ...)
                            29> (|replaceExitEtc,fn| ...)
                            <29 (|replaceExitEtc,fn| ...)
                           <28 (|replaceExitEtc| ...)
                           28> (|replaceExitEtc| ...)
                            29> (|replaceExitEtc,fn| ...)
                            <29 (|replaceExitEtc,fn| ...)
                           <28 (|replaceExitEtc| ...)
                          <27 (|replaceExitEtc,fn| ...)
                         <26 (|replaceExitEtc| ...)
                         26> (|replaceExitEtc| ...)
                          27> (|replaceExitEtc,fn| ...)
                           28> (|replaceExitEtc| ...)
                            29> (|replaceExitEtc,fn| ...)
                             30> (|replaceExitEtc| ...)
                              31> (|replaceExitEtc,fn| ...)
                               32> (|replaceExitEtc| ...)
                                33> (|replaceExitEtc,fn| ...)
                                <33 (|replaceExitEtc,fn| ...)
                               <32 (|replaceExitEtc| ...)
                               32> (|replaceExitEtc| ...)
                                33> (|replaceExitEtc,fn| ...)
                                <33 (|replaceExitEtc,fn| ...)
                               <32 (|replaceExitEtc| ...)
                              <31 (|replaceExitEtc,fn| ...)
                             <30 (|replaceExitEtc| ...)
                             30> (|convertOrCroak| ...)
                              31> (|convert| ...)
                              <31 (|convert| ...)
                             <30 (|convertOrCroak| ...)
                            <29 (|replaceExitEtc,fn| ...)
                           <28 (|replaceExitEtc| ...)
                           28> (|replaceExitEtc| ...)
                            29> (|replaceExitEtc,fn| ...)
                            <29 (|replaceExitEtc,fn| ...)
                           <28 (|replaceExitEtc| ...)
                          <27 (|replaceExitEtc,fn| ...)
                         <26 (|replaceExitEtc| ...)
                        <25 (|replaceExitEtc,fn| ...)
                       <24 (|replaceExitEtc| ...)
                      <23 (|compSeq1| ...)
                     <22 (|compSeq| ...)
                    <21 (|compExpression| ...)
                   <20 (|comp3| ...)
                  <19 (|comp2| ...)
                 <18 (|compNoStacking| ...)
                <17 (|comp| ...)
                17> (|comp| ...)
                 18> (|compNoStacking| ...)
                  19> (|comp2| ...)
                   20> (|comp3| ...)
                    21> (|compExpression| ...)
                     22> (|comp| ...)
                      23> (|compNoStacking| ...)
                       24> (|comp2| ...)
                        25> (|comp3| ...)
                         26> (|compColon| ...)
                         <26 (|compColon| ...)
                        <25 (|comp3| ...)
                       <24 (|comp2| ...)
                      <23 (|compNoStacking| ...)
                     <22 (|comp| ...)
\end{verbatim}

In order to explain the compiler we will walk through the compilation of
EQ.spad, which handles equations as mathematical objects. We start the
system. Most of the structure in Axiom are circular so we have to the
\verb|*print-cycle*| to true.
\begin{verbatim}
root@spiff:/tmp# axiom -nox

(1) -> )lisp (setq *print-circle* t)

Value = T
\end{verbatim}

We trace the function we find interesting:
\begin{verbatim}
(1) -> )lisp (trace |compiler|)

Value = (|compiler|)
\end{verbatim}

\defunsec{compiler}{The top level compiler command}
We compile the spad file. We can see that the {\bf compiler} function gets
a list 
\begin{verbatim}
(1) -> )co EQ

  1> (|compiler| (EQ))
\end{verbatim}
In order to find this file, the {\bf pathname} and {\bf pathnameType} 
functions are used to find the location and pathname to the file. They
{\bf pathnameType} function eventually returns the fact that this is
a spad source file. Once that is known we call the {\bf compileSpad2Cmd}
function with a list containing the full pathname as a string.
\begin{verbatim}
  1> (|compiler| (EQ))
    2> (|pathname| (EQ))
    <2 (|pathname| #p"EQ")
    2> (|pathnameType| #p"EQ")
      3> (|pathname| #p"EQ")
      <3 (|pathname| #p"EQ")
    <2 (|pathnameType| NIL)
    2> (|pathnameType| "/tmp/EQ.spad")
      3> (|pathname| "/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|pathnameType| "spad")
    2> (|pathnameType| "/tmp/EQ.spad")
      3> (|pathname| "/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|pathnameType| "spad")
    2> (|pathnameType| "/tmp/EQ.spad")
      3> (|pathname| "/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|pathnameType| "spad")
    2> (|compileSpad2Cmd| ("/tmp/EQ.spad"))
\end{verbatim}

\calls{compiler}{helpSpad2Cmd(5)}
\calls{compiler}{selectOptionLC(5)}
\calls{compiler}{pathname(5)}
\calls{compiler}{mergePathnames(5)}
\calls{compiler}{pathnameType(5)}
\calls{compiler}{namestring(5)}
\calls{compiler}{throwKeyedMsg}
\calls{compiler}{findfile}
\calls{compiler}{compileSpad2Cmd}
\calls{compiler}{compileSpadLispCmd}
\usesdollar{compiler}{newConlist}
\usesdollar{compiler}{options}
\uses{compiler}{/editfile}
<<defun compiler>>=
(defun |compiler| (args)
 "The top level compiler command"
 (let (|$newConlist| optlist optname optargs havenew haveold aft ef af af1)
  (declare (special |$newConlist| |$options| /editfile))
  (setq |$newConlist| nil)
  (cond
   ((and (null args) (null |$options|) (null /editfile))
     (|helpSpad2Cmd| '(|compiler|)))
   (t
    (cond ((null args) (setq args (cons /editfile nil))))
    (setq optlist '(|new| |old| |translate| |constructor|))
    (setq havenew nil)
    (setq haveold nil)
    (do ((t0 |$options| (cdr t0)) (opt nil))
        ((or (atom t0) 
             (progn (setq opt (car t0)) nil)
             (null (null (and havenew haveold))))
          nil)
     (setq optname (car opt))
     (setq optargs (cdr opt))
     (case (|selectOptionLC| optname optlist nil)
      (|new|         (setq havenew t))
      (|translate|   (setq haveold t))
      (|constructor| (setq haveold t))
      (|old|         (setq haveold t))))
    (cond
     ((and havenew haveold) (|throwKeyedMsg| 's2iz0081 nil))
     (t
      (setq af (|pathname| args))
      (setq aft (|pathnameType| af))
      (cond
       ((or haveold (string= aft "spad"))
        (if (null (setq af1 ($findfile af '(|spad|))))
           (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
           (|compileSpad2Cmd| (cons af1 nil))))
       ((string= aft "nrlib")
        (if (null (setq af1 ($findfile af '(|nrlib|))))
          (|throwKeyedMsg| 'S2IL0003 (cons (namestring af) nil))
          (|compileSpadLispCmd| (cons af1 nil))))
       (t
        (setq af1 ($findfile af '(|spad|)))
        (cond
         ((and af1 (string= (|pathnameType| af1) "spad"))
          (|compileSpad2Cmd| (cons af1 nil)))
         (t
          (setq ef (|pathname| /editfile))
          (setq ef (|mergePathnames| af ef))
          (cond
           ((boot-equal ef af) (|throwKeyedMsg| 's2iz0039 nil))
           (t
            (setq af ef)
            (cond
             ((string= (|pathnameType| af) "spad")
              (|compileSpad2Cmd| args))
             (t
              (setq af1 ($findfile af '(|spad|)))
              (cond
               ((and af1 (string= (|pathnameType| af1) "spad"))
                 (|compileSpad2Cmd| (cons af1 nil)))
               (t (|throwKeyedMsg| 's2iz0039 nil)))))))))))))))))

@

\defunsec{compileSpad2Cmd}{The Spad compiler top level function}
The argument to this function, as noted above, is a list containing
the string pathname to the file.
\begin{verbatim}
    2> (|compileSpad2Cmd| ("/tmp/EQ.spad"))
\end{verbatim}
There is a fair bit of redundant work to find the full filename and pathname
of the file. This needs to be eliminated.

The trace of the functions in this routines is:
\begin{verbatim}
  1> (|selectOptionLC| "compiler" (|abbreviations| |boot| |browse| |cd| |clear| |close| |compiler| |copyright| |credits| |describe| |display| |edit| |fin| |frame| |help| |history| |lisp| |library| |load| |ltrace| |pquit| |quit| |read| |savesystem| |set| |show| |spool| |summary| |synonym| |system| |trace| |trademark| |undo| |what| |with| |workfiles| |zsystemdevelopment|) |commandErrorIfAmbiguous|)
  <1 (|selectOptionLC| |compiler|)
  1> (|selectOptionLC| |compiler| (|abbreviations| |boot| |browse| |cd| |clear| |close| |compiler| |copyright| |credits| |describe| |display| |edit| |fin| |frame| |help| |history| |lisp| |library| |load| |ltrace| |pquit| |quit| |read| |savesystem| |set| |show| |spool| |summary| |synonym| |system| |trace| |trademark| |undo| |what| |with| |workfiles| |zsystemdevelopment|) |commandError|)
  <1 (|selectOptionLC| |compiler|)
  1> (|pathname| (EQ))
  <1 (|pathname| #p"EQ")
  1> (|pathnameType| #p"EQ")
    2> (|pathname| #p"EQ")
    <2 (|pathname| #p"EQ")
  <1 (|pathnameType| NIL)
  1> (|pathnameType| "/tmp/EQ.spad")
    2> (|pathname| "/tmp/EQ.spad")
    <2 (|pathname| #p"/tmp/EQ.spad")
  <1 (|pathnameType| "spad")
  1> (|pathnameType| "/tmp/EQ.spad")
    2> (|pathname| "/tmp/EQ.spad")
    <2 (|pathname| #p"/tmp/EQ.spad")
  <1 (|pathnameType| "spad")
  1> (|pathnameType| "/tmp/EQ.spad")
    2> (|pathname| "/tmp/EQ.spad")
    <2 (|pathname| #p"/tmp/EQ.spad")
  <1 (|pathnameType| "spad")
  1> (|compileSpad2Cmd| ("/tmp/EQ.spad"))
    2> (|pathname| ("/tmp/EQ.spad"))
    <2 (|pathname| #p"/tmp/EQ.spad")
    2> (|pathnameType| #p"/tmp/EQ.spad")
      3> (|pathname| #p"/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|pathnameType| "spad")
    2> (|updateSourceFiles| #p"/tmp/EQ.spad")
      3> (|pathname| #p"/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
      3> (|pathname| #p"/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
      3> (|pathnameType| #p"/tmp/EQ.spad")
        4> (|pathname| #p"/tmp/EQ.spad")
        <4 (|pathname| #p"/tmp/EQ.spad")
      <3 (|pathnameType| "spad")
      3> (|pathname| ("EQ" "spad" "*"))
      <3 (|pathname| #p"EQ.spad")
      3> (|pathnameType| #p"EQ.spad")
        4> (|pathname| #p"EQ.spad")
        <4 (|pathname| #p"EQ.spad")
      <3 (|pathnameType| "spad")
    <2 (|updateSourceFiles| #p"EQ.spad")
    2> (|namestring| ("/tmp/EQ.spad"))
      3> (|pathname| ("/tmp/EQ.spad"))
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|namestring| "/tmp/EQ.spad")
   Compiling AXIOM source code from file /tmp/EQ.spad using old system 
      compiler.
\end{verbatim}

Again we find a lot of redundant work. We finally end up calling
{\bf compilerDoit} with a constructed argument list:
\begin{verbatim}
    2> (|compilerDoit| NIL (|rq| |lib|))
\end{verbatim}


\calls{compileSpad2Cmd}{pathname(5)}
\calls{compileSpad2Cmd}{pathnameType(5)}
\calls{compileSpad2Cmd}{namestring(5)}
\calls{compileSpad2Cmd}{updateSourceFiles(5)}
\calls{compileSpad2Cmd}{selectOptionLC(5)}
\calls{compileSpad2Cmd}{terminateSystemCommand(5)}
\calls{compileSpad2Cmd}{nequal}
\calls{compileSpad2Cmd}{throwKeyedMsg}
\calls{compileSpad2Cmd}{sayKeyedMsg}
\calls{compileSpad2Cmd}{error}
\calls{compileSpad2Cmd}{strconc}
\calls{compileSpad2Cmd}{object2String}
\calls{compileSpad2Cmd}{oldParserAutoloadOnceTrigger}
\calls{compileSpad2Cmd}{browserAutoloadOnceTrigger}
\calls{compileSpad2Cmd}{spad2AsTranslatorAutoloadOnceTrigger}
\calls{compileSpad2Cmd}{convertSpadToAsFile}
\calls{compileSpad2Cmd}{compilerDoitWithScreenedLisplib}
\calls{compileSpad2Cmd}{compilerDoit}
\calls{compileSpad2Cmd}{extendLocalLibdb}
\calls{compileSpad2Cmd}{spadPrompt}
\usesdollar{compileSpad2Cmd}{newComp}
\usesdollar{compileSpad2Cmd}{scanIfTrue}
\usesdollar{compileSpad2Cmd}{compileOnlyCertainItems}
\usesdollar{compileSpad2Cmd}{f}
\usesdollar{compileSpad2Cmd}{m}
\usesdollar{compileSpad2Cmd}{QuickLet}
\usesdollar{compileSpad2Cmd}{QuickCode}
\usesdollar{compileSpad2Cmd}{sourceFileTypes}
\usesdollar{compileSpad2Cmd}{InteractiveMode}
\usesdollar{compileSpad2Cmd}{options}
\usesdollar{compileSpad2Cmd}{newConlist}
\uses{compileSpad2Cmd}{/editfile}
<<defun compileSpad2Cmd>>=
(defun |compileSpad2Cmd| (args)
 (let (|$newComp| |$scanIfTrue| 
       |$compileOnlyCertainItems| |$f| |$m| |$QuickLet| |$QuickCode| 
       |$sourceFileTypes| |$InteractiveMode| path optlist fun optname 
       optargs fullopt constructor)
  (declare (special |$newComp| |$scanIfTrue| 
       |$compileOnlyCertainItems| |$f| |$m| |$QuickLet| |$QuickCode| 
       |$sourceFileTypes| |$InteractiveMode| /editfile |$options|
       |$newConlist|)) 
   (setq path (|pathname| args))
   (cond
    ((nequal (|pathnameType| path) "spad") (|throwKeyedMsg| 's2iz0082 nil))
    ((null (probe-file path))
     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
    (t
     (setq /editfile path)
     (|updateSourceFiles| path)
     (|sayKeyedMsg| 's2iz0038 (list (|namestring| args)))
     (setq optlist '(|break| |constructor| |functions| |library| |lisp|
         |new| |old| |nobreak| |nolibrary| |noquiet| |vartrace| |quiet|
         |translate|))
     (setq |$QuickLet| t)
     (setq |$QuickCode| t)
     (setq fun '(|rq| |lib|))
     (setq |$sourceFileTypes| '("SPAD"))
     (dolist (opt |$options|)
      (setq optname (car opt))
      (setq optargs (cdr opt))
      (setq fullopt (|selectOptionLC| optname optlist nil))
      (case fullopt
       (|old| nil)
       (|library| (setelt fun 1 '|lib|))
       (|nolibrary| (setelt fun 1 '|nolib|))
       (|quiet| (when (nequal (elt fun 0) '|c|) (setelt fun 0 '|rq|)))
       (|noquiet| (when (nequal (elt fun 0) '|c|) (setelt fun 0 '|rf|)))
       (|nobreak| (setq |$scanIfTrue| t))
       (|break| (setq |$scanIfTrue| nil))
       (|vartrace| (setq |$QuickLet| nil))
       (|lisp| (|throwKeyedMsg| 's2iz0036 (list ")lisp")))
       (|functions|
        (if (null optargs) 
         (|throwKeyedMsg| 's2iz0037 (list ")functions"))
         (setq |$compileOnlyCertainItems| optargs)))
       (|constructor|
        (if (null optargs)
         (|throwKeyedMsg| 's2iz0037 (list ")constructor"))
         (progn
          (setelt fun 0 '|c|)
          (setq constructor (mapcar #'|unabbrev| optargs)))))
       (t
        (|throwKeyedMsg| 's2iz0036 
         (list (strconc ")" (|object2String| optname)))))))
    (setq |$InteractiveMode| nil)
    (cond
     (|$compileOnlyCertainItems|
      (if (null constructor)
       (|sayKeyedMsg| 's2iz0040 nil)
       (|compilerDoitWithScreenedLisplib| constructor fun)))
     (t (|compilerDoit| constructor fun)))
    (|extendLocalLibdb| |$newConlist|)
    (|terminateSystemCommand|)
    (|spadPrompt|)))))

@

This trivial function cases on the second argument to decide which 
combination of operations was requested. For this case we see:
\begin{verbatim}
(1) -> )co EQ
   Compiling AXIOM source code from file /tmp/EQ.spad using old system 
      compiler.
  1> (|compilerDoit| NIL (|rq| |lib|))
    2> (|/RQ,LIB|)

... [snip]...

    <2 (|/RQ,LIB| T)
  <1 (|compilerDoit| T)
(1) -> 
\end{verbatim}

\defun{compilerDoit}{compilerDoit}
\calls{compilerDoit}{/rq(5)}
\calls{compilerDoit}{/rf(5)}
\calls{compilerDoit}{member(5)}
\calls{compilerDoit}{sayBrightly}
\usesdollar{compilerDoit}{byConstructors}
\usesdollar{compilerDoit}{constructorsSeen}
<<defun compilerDoit>>=
(defun |compilerDoit| (constructor fun)
 (let (|$byConstructors| |$constructorsSeen|)
 (declare (special |$byConstructors| |$constructorsSeen|))
  (cond
   ((equal fun '(|rf| |lib|))   (|/RQ,LIB|))   ; Ignore "noquiet"
   ((equal fun '(|rf| |nolib|)) (/rf))
   ((equal fun '(|rq| |lib|))   (|/RQ,LIB|))
   ((equal fun '(|rq| |nolib|)) (/rq))
   ((equal fun '(|c| |lib|))
    (setq |$byConstructors| (loop for x in constructor collect (|opOf| x)))
    (|/RQ,LIB|)
    (dolist (x |$byConstructors|)
     (unless (|member| x |$constructorsSeen|)
      (|sayBrightly| `(">>> Warning " |%b| ,x |%d| " was not found"))))))))

@

This function simply calls {\bf \verb|/rf-1|}. 
\begin{verbatim}
(2) -> )co EQ
   Compiling AXIOM source code from file /tmp/EQ.spad using old system 
      compiler.
  1> (|compilerDoit| NIL (|rq| |lib|))
    2> (|/RQ,LIB|)
      3> (/RF-1 NIL)
...[snip]...
      <3 (/RF-1 T)
    <2 (|/RQ,LIB| T)
  <1 (|compilerDoit| T)
\end{verbatim}

\defun{/RQ,LIB}{/RQ,LIB}
\calls{/RQ,LIB}{/rf-1(5)}
\uses{/RQ,LIB}{echo-meta(5)}
\usesdollar{/RQ,LIB}{lisplib}
<<defun /RQ,LIB>>=
(defun |/RQ,LIB| (&rest foo &aux (echo-meta nil) ($lisplib t))
 (declare (special echo-meta $lisplib))
  (/rf-1 nil))

@
 
Since this function is called with nil we fall directly into the
call to the function {\bf spad}:
\begin{verbatim}
(2) -> )co EQ
   Compiling AXIOM source code from file /tmp/EQ.spad using old system 
      compiler.
  1> (|compilerDoit| NIL (|rq| |lib|))
    2> (|/RQ,LIB|)
      3> (/RF-1 NIL)
        4> (SPAD "/tmp/EQ.spad")
...[snip]...
        <4 (SPAD T)
      <3 (/RF-1 T)
    <2 (|/RQ,LIB| T)
  <1 (|compilerDoit| T)
\end{verbatim}

\defun{/rf-1}{/rf-1}
\calls{/rf-1}{makeInputFilename(5)}
\calls{/rf-1}{ncINTERPFILE}
\calls{/rf-1}{spad}
\uses{/rf-1}{/editfile}
\uses{/rf-1}{echo-meta}
<<defun /rf-1>>=
(defun /rf-1 (ignore)
 (declare (ignore ignore))
 (let* ((input-file (makeInputFilename /editfile))
        (type (pathname-type input-file)))
 (declare (special echo-meta /editfile))
 (cond
  ((string= type "lisp") (load input-file))
  ((string= type "input") (|ncINTERPFILE| input-file echo-meta))
  (t (spad input-file)))))

@

Here we begin the actual compilation process. 
\begin{verbatim}
  1> (SPAD "/tmp/EQ.spad")
    2> (|makeInitialModemapFrame|)
    <2 (|makeInitialModemapFrame| ((NIL)))
    2> (INIT-BOOT/SPAD-READER)
    <2 (INIT-BOOT/SPAD-READER NIL)
    2> (OPEN "/tmp/EQ.spad" :DIRECTION :INPUT)
    <2 (OPEN #<input stream "/tmp/EQ.spad">)
    2> (INITIALIZE-PREPARSE #<input stream "/tmp/EQ.spad">)
    <2 (INITIALIZE-PREPARSE ")abbrev domain EQ Equation")
    2> (PREPARSE #<input stream "/tmp/EQ.spad">)
   EQ abbreviates domain Equation 
    <2 (PREPARSE (# # # # # # # # ...))
    2> (|PARSE-NewExpr|)
    <2 (|PARSE-NewExpr| T)
    2> (S-PROCESS (|where| # #))
...[snip]...
      3> (OPEN "/tmp/EQ.erlib/info" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.erlib/info">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.lsp")
      <3 (OPEN #<input stream "/tmp/EQ.nrlib/EQ.lsp">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.data" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.data">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.c" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.c">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.h" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.h">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.fn" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.fn">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.o" :DIRECTION :OUTPUT :IF-EXISTS :APPEND)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.o">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.data")
      <3 (OPEN #<input stream "/tmp/EQ.nrlib/EQ.data">)
      3> (OPEN "/tmp/EQ.nrlib/index.kaf")
      <3 (OPEN #<input stream "/tmp/EQ.nrlib/index.kaf">)
    <2 (S-PROCESS NIL)
  <1 (SPAD T)
  1> (OPEN "temp.text" :DIRECTION :OUTPUT)
  <1 (OPEN #<output stream "temp.text">)
  1> (OPEN "libdb.text")
  <1 (OPEN #<input stream "libdb.text">)
  1> (OPEN "temp.text")
  <1 (OPEN #<input stream "temp.text">)
  1> (OPEN "libdb.text" :DIRECTION :OUTPUT)
  <1 (OPEN #<output stream "libdb.text">)
\end{verbatim}

The major steps in this process involve the {\bf preparse} function.
(See book volume 5 for more details).
The {\bf preparse} function  returns a list of pairs of the form:
( (linenumber . linestring) .... (linenumber . linestring))
For instance, for the file {\tt EQ.spad}, we get:
\begin{verbatim}
    <2 (PREPARSE (
 (19 . "Equation(S: Type): public == private where")
 (20 . " (Ex ==> OutputForm;")
 (21 . "  public ==> Type with")
 (22 . "   (\"=\": (S, S) -> $;")
...[skip]...
 (202 . "        inv eq == [inv lhs eq, inv rhs eq]);")
 (203 . "    if S has ExpressionSpace then")
 (204 . "        subst(eq1,eq2) ==")
 (205 . "           (eq3 := eq2 pretend Equation S;")
 (206 . "            [subst(lhs eq1,eq3),subst(rhs eq1,eq3)])))")))
\end{verbatim}

And the {\bf s-process} function which returns a parsed version of the input.
\begin{verbatim}
    2> (S-PROCESS
(|where|
 (== (|:| (|Equation| (|:| S |Type|)) |public|) |private|)
 (|;|
  (|;|
   (==> |Ex| |OutputForm|)
   (==> |public|
    (|Join| |Type|
     (|with|
      (CATEGORY
       (|Signature| "=" (-> (|,| S S) $))
       (|Signature| |equation| (-> (|,| S S) $))
       (|Signature| |swap| (-> $ $))
       (|Signature| |lhs| (-> $ S))
       (|Signature| |rhs| (-> $ S))
       (|Signature| |map| (-> (|,| (-> S S) $) $))
       (|if| (|has| S (|InnerEvalable| (|,| |Symbol| S)))
        (|Attribute| (|InnerEvalable| (|,| |Symbol| S)))
        NIL)
       (|if| (|has| S |SetCategory|)
        (CATEGORY 
         (|Attribute| |SetCategory|)
         (|Attribute| (|CoercibleTo| |Boolean|))
         (|if| (|has| S (|Evalable| S))
          (CATEGORY
           (|Signature| |eval| (-> (|,| $ $) $))
           (|Signature| |eval| (-> (|,| $ (|List| $)) $)))
          NIL))
        NIL) 
       (|if| (|has| S |AbelianSemiGroup|)
        (CATEGORY
         (|Attribute| |AbelianSemiGroup|)
         (|Signature| "+" (-> (|,| S $) $))
         (|Signature| "+" (-> (|,| $ S) $)))
         NIL)
       (|if| (|has| S |AbelianGroup|)
        (CATEGORY
         (|Attribute| |AbelianGroup|)
         (|Signature| |leftZero| (-> $ $))
         (|Signature| |rightZero| (-> $ $))
         (|Signature| "-" (-> (|,| S $) $))
         (|Signature| "-" (-> (|,| $ S) $))) NIL)
       (|if| (|has| S |SemiGroup|)
        (CATEGORY
         (|Attribute| |SemiGroup|)
         (|Signature| "*" (-> (|,| S $) $))
         (|Signature| "*" (-> (|,| $ S) $)))
        NIL)
       (|if| (|has| S |Monoid|)
        (CATEGORY
         (|Attribute| |Monoid|)
         (|Signature| |leftOne| (-> $ (|Union| (|,| $ "failed"))))
         (|Signature| |rightOne| (-> $ (|Union| (|,| $ "failed")))))
        NIL)
       (|if| (|has| S |Group|)
        (CATEGORY
         (|Attribute| |Group|)
         (|Signature| |leftOne| (-> $ (|Union| (|,| $ "failed"))))
         (|Signature| |rightOne| (-> $ (|Union| (|,| $ "failed")))))
         NIL)
       (|if| (|has| S |Ring|)
        (CATEGORY
         (|Attribute| |Ring|)
         (|Attribute| (|BiModule| (|,| S S))))
        NIL)
       (|if| (|has| S |CommutativeRing|)
        (|Attribute| (|Module| S))
        NIL)
       (|if| (|has| S |IntegralDomain|)
        (|Signature| |factorAndSplit| (-> $ (|List| $)))
        NIL)
       (|if| (|has| S (|PartialDifferentialRing| |Symbol|))
        (|Attribute| (|PartialDifferentialRing| |Symbol|))
        NIL)
       (|if| (|has| S |Field|)
        (CATEGORY
         (|Attribute| (|VectorSpace| S))
         (|Signature| "/" (-> (|,| $ $) $))
         (|Signature| |inv| (-> $ $)))
        NIL)
       (|if| (|has| S |ExpressionSpace|)
        (|Signature| |subst| (-> (|,| $ $) $))
        NIL)
    )))))
  (==> |private|
   (|add|
    (|;|
     (|;|
      (|;|
       (|;|
        (|;|
         (|;|
          (|;|
           (|;|
            (|;|
             (|;|
              (|;|
               (|;|
                (|;|
                 (|;|
                  (|;|
                   (|;|
                    (|;|
                     (|;|
                      (|;|
                       (|;|
                        (|;|
                         (|;|
                          (|:=| |Rep|
                           (|Record| (|,| (|:| |lhs| S) (|:| |rhs| S))))
                          (|,| |eq1| (|:| |eq2| $)))
                         (|:| |s| S))
                        (|if| (|has| S |IntegralDomain|)
                         (==
                          (|factorAndSplit| |eq|)
                          (|;|
                           (=> (|has| S (|:| |factor| (-> S (|Factored| S))))
                            (|;|
                             (|:=| |eq0| (|rightZero| |eq|))
                             (COLLECT
                              (IN |rcf| (|factors| (|factor| (|lhs| |eq0|))))
                              (|construct|
                               (|equation| (|,| (|rcf| |factor|) 0))))))
                           (|construct| |eq|)))
                         NIL))
                       (==
                        (= (|:| |l| S) (|:| |r| S))
                        (|construct| (|,| |l| |r|))))
                      (==
                       (|equation| (|,| |l| |r|))
                       (|construct| (|,| |l| |r|))))
                     (== (|lhs| |eqn|) (|eqn| |lhs|)))
                    (== (|rhs| |eqn|) (|eqn| |rhs|)))
                   (== 
                    (|swap| |eqn|)
                    (|construct| (|,| (|rhs| |eqn|) (|lhs| |eqn|)))))
                  (==
                   (|map| (|,| |fn| |eqn|))
                   (|equation|
                    (|,| (|fn| (|eqn| |lhs|)) (|fn| (|eqn| |rhs|))))))
                 (|if| (|has| S (|InnerEvalable| (|,| |Symbol| S)))
                  (|;|
                   (|;|
                    (|;|
                     (|;|
                      (|;| (|:| |s| |Symbol|) (|:| |ls| (|List| |Symbol|)))
                      (|:| |x| S))
                     (|:| |lx| (|List| S)))
                    (== 
                     (|eval| (|,| (|,| |eqn| |s|) |x|))
                     (= 
                      (|eval| (|,| (|,| (|eqn| |lhs|) |s|) |x|))
                      (|eval| (|,| (|,| (|eqn| |rhs|) |s|) |x|)))))
                   (==
                    (|eval| (|,| (|,| |eqn| |ls|) |lx|))
                    (=
                     (|eval| (|,| (|,| (|eqn| |lhs|) |ls|) |lx|))
                     (|eval| (|,| (|,| (|eqn| |rhs|) |ls|) |lx|)))))
                  NIL))
                (|if| (|has| S (|Evalable| S))
                 (|;|
                  (==
                   (|:| (|eval| (|,| (|:| |eqn1| $) (|:| |eqn2| $))) $)
                   (=
                    (|eval| 
                     (|,| (|eqn1| |lhs|) (|pretend| |eqn2| (|Equation| S))))
                    (|eval| 
                     (|,| (|eqn1| |rhs|) (|pretend| |eqn2| (|Equation| S))))))
                  (==
                   (|:| 
                    (|eval| (|,| (|:| |eqn1| $) (|:| |leqn2| (|List| $)))) $)
                   (=
                    (|eval|
                     (|,| 
                      (|eqn1| |lhs|)
                      (|pretend| |leqn2| (|List| (|Equation| S)))))
                    (|eval| 
                     (|,|
                      (|eqn1| |rhs|)
                      (|pretend| |leqn2| (|List| (|Equation| S))))))))
                 NIL))
               (|if| (|has| S |SetCategory|)
                (|;|
                 (|;|
                  (==
                   (= |eq1| |eq2|)
                   (|and|
                    (@ (= (|eq1| |lhs|) (|eq2| |lhs|)) |Boolean|)
                    (@ (= (|eq1| |rhs|) (|eq2| |rhs|)) |Boolean|)))
                  (==
                   (|:| (|coerce| (|:| |eqn| $)) |Ex|)
                   (= (|::| (|eqn| |lhs|) |Ex|) (|::| (|eqn| |rhs|) |Ex|))))
                 (==
                  (|:| (|coerce| (|:| |eqn| $)) |Boolean|)
                  (= (|eqn| |lhs|) (|eqn| |rhs|))))
                NIL))
              (|if| (|has| S |AbelianSemiGroup|)
               (|;|
                (|;|
                 (==
                  (+ |eq1| |eq2|)
                  (= 
                   (+ (|eq1| |lhs|) (|eq2| |lhs|))
                   (+ (|eq1| |rhs|) (|eq2| |rhs|))))
                 (== (+ |s| |eq2|) (+ (|construct| (|,| |s| |s|)) |eq2|)))
                (== (+ |eq1| |s|) (+ |eq1| (|construct| (|,| |s| |s|)))))
               NIL))
             (|if| (|has| S |AbelianGroup|)
              (|;|
               (|;|
                (|;|
                 (|;|
                  (|;|
                   (|;|
                    (== (- |eq|) (= (- (|lhs| |eq|)) (- (|rhs| |eq|))))
                    (== (- |s| |eq2|) (- (|construct| (|,| |s| |s|)) |eq2|)))
                   (== (- |eq1| |s|) (- |eq1| (|construct| (|,| |s| |s|)))))
                  (== (|leftZero| |eq|) (= 0 (- (|rhs| |eq|) (|lhs| |eq|)))))
                 (== (|rightZero| |eq|) (= (- (|lhs| |eq|) (|rhs| |eq|)) 0)))
                (== 0 (|equation| (|,| (|elt| S 0) (|elt| S 0)))))
               (==
                (- |eq1| |eq2|)
                (=
                 (- (|eq1| |lhs|) (|eq2| |lhs|))
                 (- (|eq1| |rhs|) (|eq2| |rhs|)))))
              NIL))
            (|if| (|has| S |SemiGroup|)
             (|;|
              (|;|
               (|;|
                (==
                 (* (|:| |eq1| $) (|:| |eq2| $))
                 (=
                  (* (|eq1| |lhs|) (|eq2| |lhs|))
                  (* (|eq1| |rhs|) (|eq2| |rhs|))))
                (==
                 (* (|:| |l| S) (|:| |eqn| $))
                 (= (* |l| (|eqn| |lhs|)) (* |l| (|eqn| |rhs|)))))
               (==
                (* (|:| |l| S) (|:| |eqn| $))
                (= (* |l| (|eqn| |lhs|)) (* |l| (|eqn| |rhs|)))))
              (==
               (* (|:| |eqn| $) (|:| |l| S))
               (= (* (|eqn| |lhs|) |l|) (* (|eqn| |rhs|) |l|))))
             NIL))
           (|if| (|has| S |Monoid|)
            (|;|
             (|;|
              (|;|
               (== 1 (|equation| (|,| (|elt| S 1) (|elt| S 1))))
               (==
                (|recip| |eq|)
                (|;|
                 (|;|
                  (=> (|case| (|:=| |lh| (|recip| (|lhs| |eq|))) "failed")
                      "failed")
                  (=> (|case| (|:=| |rh| (|recip| (|rhs| |eq|))) "failed")
                      "failed"))
                 (|construct| (|,| (|::| |lh| S) (|::| |rh| S))))))
              (==
               (|leftOne| |eq|)
               (|;|
                (=> (|case| (|:=| |re| (|recip| (|lhs| |eq|))) "failed") 
                    "failed")
                (= 1 (* (|rhs| |eq|) |re|)))))
             (==
              (|rightOne| |eq|)
              (|;|
               (=> (|case| (|:=| |re| (|recip| (|rhs| |eq|))) "failed")
                   "failed")
               (= (* (|lhs| |eq|) |re|) 1))))
            NIL))
          (|if| (|has| S |Group|)
           (|;|
            (|;|
             (==
              (|inv| |eq|)
              (|construct| (|,| (|inv| (|lhs| |eq|)) (|inv| (|rhs| |eq|)))))
             (== (|leftOne| |eq|) (= 1 (* (|rhs| |eq|) (|inv| (|rhs| |eq|))))))
            (== (|rightOne| |eq|) (= (* (|lhs| |eq|) (|inv| (|rhs| |eq|))) 1)))
           NIL))
         (|if| (|has| S |Ring|)
          (|;|
           (==
            (|characteristic| (|@Tuple|))
            ((|elt| S |characteristic|) (|@Tuple|)))
           (== (* (|:| |i| |Integer|) (|:| |eq| $)) (* (|::| |i| S) |eq|)))
          NIL))
        (|if| (|has| S |IntegralDomain|)
         (==
          (|factorAndSplit| |eq|)
          (|;|
           (|;|
            (=>
             (|has| S (|:| |factor| (-> S (|Factored| S))))
             (|;|
              (|:=| |eq0| (|rightZero| |eq|))
              (COLLECT
               (IN |rcf| (|factors| (|factor| (|lhs| |eq0|))))
               (|construct| (|equation| (|,| (|rcf| |factor|) 0))))))
            (=>
             (|has| S (|Polynomial| |Integer|))
             (|;|
              (|;|
               (|;|
                (|:=| |eq0| (|rightZero| |eq|))
                (==> MF
                 (|MultivariateFactorize|
                  (|,|
                   (|,| (|,| |Symbol| (|IndexedExponents| |Symbol|)) |Integer|)
                  (|Polynomial| |Integer|)))))
               (|:=|
                (|:| |p| (|Polynomial| |Integer|))
                (|pretend| (|lhs| |eq0|) (|Polynomial| |Integer|))))
              (COLLECT
               (IN |rcf| (|factors| ((|elt| MF |factor|) |p|)))
               (|construct|
                (|equation| (|,| (|pretend| (|rcf| |factor|) S) 0)))))))
           (|construct| |eq|)))
         NIL))
       (|if| (|has| S (|PartialDifferentialRing| |Symbol|))
        (==
         (|:| (|differentiate| (|,| (|:| |eq| $) (|:| |sym| |Symbol|))) $)
         (|construct|
          (|,|
           (|differentiate| (|,| (|lhs| |eq|) |sym|))
           (|differentiate| (|,| (|rhs| |eq|) |sym|)))))
        NIL))
      (|if| (|has| S |Field|)
       (|;|
        (|;|
         (== (|dimension| (|@Tuple|)) (|::| 2 |CardinalNumber|))
         (==
          (/ (|:| |eq1| $) (|:| |eq2| $))
          (= (/ (|eq1| |lhs|) (|eq2| |lhs|)) (/ (|eq1| |rhs|) (|eq2| |rhs|)))))
        (==
         (|inv| |eq|)
         (|construct| (|,| (|inv| (|lhs| |eq|)) (|inv| (|rhs| |eq|))))))
       NIL))
     (|if| (|has| S |ExpressionSpace|)
      (==
       (|subst| (|,| |eq1| |eq2|))
       (|;|
        (|:=| |eq3| (|pretend| |eq2| (|Equation| S)))
        (|construct|
         (|,|
          (|subst| (|,| (|lhs| |eq1|) |eq3|))
          (|subst| (|,| (|rhs| |eq1|) |eq3|))))))
      NIL)))))))

\end{verbatim}

\defun{spad}{spad}
\catches{spad}{spad-reader}
\calls{spad}{addBinding}
\calls{spad}{makeInitialModemapFrame}
\calls{spad}{init-boot/spad-reader}
\calls{spad}{initialize-preparse}
\calls{spad}{preparse}
\calls{spad}{PARSE-NewExpr}
\calls{spad}{pop-stack-1}
\calls{spad}{s-process}
\calls{spad}{ioclear}
\calls{spad}{shut}
\usesdollar{spad}{noSubsumption}
\usesdollar{spad}{InteractiveFrame}
\usesdollar{spad}{InitialDomainsInScope}
\usesdollar{spad}{InteractiveMode}
\uses{spad}{line}
\uses{spad}{echo-meta}
\uses{spad}{/editfile}
\uses{spad}{*comp370-apply*}
\uses{spad}{*eof*}
\uses{spad}{file-closed}
\uses{spad}{xcape}
\catches{spad}{spad-reader}
<<defun spad>>=
(defun spad (&optional (*spad-input-file* nil) (*spad-output-file* nil)
             &aux (*comp370-apply* #'print-defun)
                  (*fileactq-apply* #'print-defun)
                 ($spad t) ($boot nil) (xcape #\_) (optionlist nil) (*eof* nil)
                 (file-closed nil) (/editfile *spad-input-file*)
                (|$noSubsumption| |$noSubsumption|) in-stream out-stream)
  (declare (special echo-meta /editfile *comp370-apply* *eof*
                    file-closed xcape |$noSubsumption| |$InteractiveFrame|
                    |$InteractiveMode| |$InitialDomainsInScope|))
  ;; only rebind |$InteractiveFrame| if compiling
  (progv (if (not |$InteractiveMode|) '(|$InteractiveFrame|))
         (if (not |$InteractiveMode|)
             (list (|addBinding| '|$DomainsInScope|
                    `((fluid . |true|)
                      (|special| . ,(copy-tree |$InitialDomainsInScope|)))
                   (|addBinding| '|$Information| nil
                      (|makeInitialModemapFrame|)))))
  (init-boot/spad-reader)
  (unwind-protect
    (progn
      (setq in-stream (if *spad-input-file*
                        (open *spad-input-file* :direction :input)
                         *standard-input*))
      (initialize-preparse in-stream)
      (setq out-stream (if *spad-output-file*
                        (open *spad-output-file* :direction :output)
                         *standard-output*))
      (when *spad-output-file*
         (format out-stream "~&;;; -*- Mode:Lisp; Package:Boot  -*-~%~%")
         (print-package "BOOT"))
      (setq curoutstream out-stream)
      (loop
       (if (or *eof* file-closed) (return nil))
       (catch 'spad_reader
         (if (setq boot-line-stack (preparse in-stream))
             (let ((line (cdar boot-line-stack)))
               (declare (special line))
               (|PARSE-NewExpr|)
               (let ((parseout (pop-stack-1)) )
                 (when parseout
                       (let ((*standard-output* out-stream))
                         (s-process parseout))
                       (format out-stream "~&")))
               )))
      (ioclear in-stream out-stream)))
    (if *spad-input-file* (shut in-stream))
    (if *spad-output-file* (shut out-stream)))
  t))

@

\defun{s-process}{Interpreter interface to the compiler}
\calls{s-process}{curstrm}
\calls{s-process}{def-rename}
\calls{s-process}{new2OldLisp}
\calls{s-process}{parseTransform}
\calls{s-process}{postTransform}
\calls{s-process}{displayPreCompilationErrors}
\calls{s-process}{prettyprint}
\calls{s-process}{processInteractive}
\calls{s-process}{compTopLevel}
\calls{s-process}{def-process}
\calls{s-process}{displaySemanticErrors}
\calls{s-process}{terpri}
\calls{s-process}{get-internal-run-time}
\usesdollar{s-process}{Index}
\usesdollar{s-process}{macroassoc}
\usesdollar{s-process}{newspad}
\usesdollar{s-process}{PolyMode}
\usesdollar{s-process}{EmptyMode}
\usesdollar{s-process}{compUniquelyIfTrue}
\usesdollar{s-process}{currentFunction}
\usesdollar{s-process}{postStack}
\usesdollar{s-process}{topOp}
\usesdollar{s-process}{semanticErrorStack}
\usesdollar{s-process}{warningStack}
\usesdollar{s-process}{exitMode}
\usesdollar{s-process}{exitModeStack}
\usesdollar{s-process}{returnMode}
\usesdollar{s-process}{leaveMode}
\usesdollar{s-process}{leaveLevelStack}
\usesdollar{s-process}{top-level}
\usesdollar{s-process}{insideFunctorIfTrue}
\usesdollar{s-process}{insideExpressionIfTrue}
\usesdollar{s-process}{insideCoerceInteractiveHardIfTrue}
\usesdollar{s-process}{insideWhereIfTrue}
\usesdollar{s-process}{insideCategoryIfTrue}
\usesdollar{s-process}{insideCapsuleFunctionIfTrue}
\usesdollar{s-process}{form}
\usesdollar{s-process}{DomainFrame}
\usesdollar{s-process}{e}
\usesdollar{s-process}{EmptyEnvironment}
\usesdollar{s-process}{genFVar}
\usesdollar{s-process}{genSDVar}
\usesdollar{s-process}{VariableCount}
\usesdollar{s-process}{previousTime}
\usesdollar{s-process}{LocalFrame}
\uses{s-process}{curoutstream}
<<defun s-process>>=
(defun s-process (x)
 (prog ((|$Index| 0)
        ($macroassoc ())
        ($newspad t)
        (|$PolyMode| |$EmptyMode|)
        (|$compUniquelyIfTrue| nil)
        |$currentFunction|
        (|$postStack| nil)
        |$topOp|
        (|$semanticErrorStack| ())
        (|$warningStack| ())
        (|$exitMode| |$EmptyMode|)
        (|$exitModeStack| ())
        (|$returnMode| |$EmptyMode|)
        (|$leaveMode| |$EmptyMode|)
        (|$leaveLevelStack| ())
        $top_level |$insideFunctorIfTrue| |$insideExpressionIfTrue|
        |$insideCoerceInteractiveHardIfTrue| |$insideWhereIfTrue|
        |$insideCategoryIfTrue| |$insideCapsuleFunctionIfTrue| |$form|
        (|$DomainFrame| '((NIL)))
        (|$e| |$EmptyEnvironment|)
        (|$genFVar| 0)
        (|$genSDVar| 0)
        (|$VariableCount| 0)
        (|$previousTime| (get-internal-run-time))
        (|$LocalFrame| '((NIL)))
        (curstrm curoutstream) |$s| |$x| |$m| u)
  (declare (special |$Index| $macroassoc $newspad |$PolyMode| |$EmptyMode|
            |$compUniquelyIfTrue| |$currentFunction| |$postStack| |$topOp|
            |$semanticErrorStack| |$warningStack| |$exitMode| |$exitModeStack|
            |$returnMode| |$leaveMode| |$leaveLevelStack| $top_level 
            |$insideFunctorIfTrue| |$insideExpressionIfTrue|
            |$insideCoerceInteractiveHardIfTrue| |$insideWhereIfTrue|
            |$insideCategoryIfTrue| |$insideCapsuleFunctionIfTrue| |$form|
            |$DomainFrame| |$e| |$EmptyEnvironment| |$genFVar| |$genSDVar| 
            |$VariableCount| |$previousTime| |$LocalFrame|
            curstrm |$s| |$x| |$m| curoutstream $traceflag))
   (setq $traceflag t)
   (if (not x) (return nil))
   (if $boot
     (setq x (def-rename (|new2OldLisp| x)))
     (setq x (|parseTransform| (|postTransform| x))))
   (when |$TranslateOnly| (return (setq |$Translation| x)))
   (when |$postStack| (|displayPreCompilationErrors|) (return nil))
   (when |$PrintOnly|
        (format t "~S   =====>~%" |$currentLine|)
        (return (prettyprint x)))
   (if (not $boot)
    (if |$InteractiveMode|
      (|processInteractive| x nil)
      (when (setq u (|compTopLevel| x |$EmptyMode| |$InteractiveFrame|))
        (setq |$InteractiveFrame| (third u))))
    (def-process x))
   (when |$semanticErrorStack| (|displaySemanticErrors|))
   (terpri)))

@

\defun{compTopLevel}{compTopLevel}
\calls{compTopLevel}{newComp}
\calls{compTopLevel}{compOrCroak}
\usesdollar{compTopLevel}{NRTderivedTargetIfTrue}
\usesdollar{compTopLevel}{killOptimizeIfTrue}
\usesdollar{compTopLevel}{forceAdd}
\usesdollar{compTopLevel}{compTimeSum}
\usesdollar{compTopLevel}{resolveTimeSum}
\usesdollar{compTopLevel}{packagesUsed}
\usesdollar{compTopLevel}{envHashTable}
<<defun compTopLevel>>=
(defun |compTopLevel| (x m e)
 (let (|$NRTderivedTargetIfTrue| |$killOptimizeIfTrue| |$forceAdd|
       |$compTimeSum| |$resolveTimeSum| |$packagesUsed| |$envHashTable|
        t1 t2 t3 val mode)
 (declare (special |$NRTderivedTargetIfTrue| |$killOptimizeIfTrue|
                   |$forceAdd| |$compTimeSum| |$resolveTimeSum|
                   |$packagesUsed| |$envHashTable| ))
   (setq |$NRTderivedTargetIfTrue| nil)
   (setq |$killOptimizeIfTrue| nil)
   (setq |$forceAdd| nil)
   (setq |$compTimeSum| 0)
   (setq |$resolveTimeSum| 0)
   (setq |$packagesUsed| NIL)
   (setq |$envHashTable| (make-hashtable 'equal))
   (dolist (u (car (car e)))
    (dolist (v (cdr u))
     (hput |$envHashTable| (cons (car u) (cons (car v) nil)) t)))
   (cond
    ((or (and (pairp x) (eq (qcar x) 'def))
         (and (pairp x) (eq (qcar x) '|where|)
              (progn
                (setq t1 (qcdr x))
                (and (pairp t1)
                (progn
                 (setq t2 (qcar t1))
                 (and (pairp t2) (eq (qcar t2) 'def)))))))
      (setq t3 (|compOrCroak| x m e))
      (setq val (car t3))
      (setq mode (second t3))
      (cons val (cons mode (cons e nil))))
    (t (|compOrCroak| x m e)))))

@
Given:
\begin{verbatim}
CohenCategory(): Category == SetCategory with

  kind:(CExpr)->Boolean
  operand:(CExpr,Integer)->CExpr
  numberOfOperand:(CExpr)->Integer
  construct:(CExpr,CExpr)->CExpr

\end{verbatim}
the resulting call looks like:
\begin{verbatim}
 (|compOrCroak|
       (DEF (|CohenCategory|)
        ((|Category|))
        (NIL)
        (|Join|
         (|SetCategory|)
         (CATEGORY |package|
          (SIGNATURE |kind| ((|Boolean|) |CExpr|))
          (SIGNATURE |operand| (|CExpr| |CExpr| (|Integer|)))
          (SIGNATURE |numberOfOperand| ((|Integer|) |CExpr|))
          (SIGNATURE |construct| (|CExpr| |CExpr| |CExpr|)))))
        |$EmptyMode|
        (((
           (|$DomainsInScope| 
            (FLUID . |true|)
            (|special| |$EmptyMode| |$NoValueMode|))))))
\end{verbatim}

This compiler call expects the first argument {\tt x} 
to be a {\tt DEF} form to compile,
The second argument, {\tt m}, is the mode.
The third argument, {\tt e}, is the environment.

\defun{compOrCroak}{compOrCroak}
\calls{compOrCroak}{compOrCroak1}
<<defun compOrCroak>>=
(defun |compOrCroak| (x m e)
  (|compOrCroak1| x m e nil nil))

@

This results in a call to the inner function with
\begin{verbatim}
(|compOrCroak1|
          (DEF (|CohenCategory|)
           ((|Category|))
           (NIL)
           (|Join|
            (|SetCategory|)
            (CATEGORY |package|
             (SIGNATURE |kind| ((|Boolean|) |CExpr|))
             (SIGNATURE |operand| (|CExpr| |CExpr| (|Integer|)))
             (SIGNATURE |numberOfOperand| ((|Integer|) |CExpr|))
             (SIGNATURE |construct| (|CExpr| |CExpr| |CExpr|)))))
          |$EmptyMode|
          ((((
              |$DomainsInScope|
              (FLUID . |true|)
              (|special| |$EmptyMode| |$NoValueMode|)))))
          NIL 
          NIL 
          |comp|)
\end{verbatim}
The inner function augments the environment with information
from the compiler stack {\tt \$compStack} and
{\tt \$compErrorMessageStack}. Note that these variables are passed
in the argument list so they get preserved on the call stack. The
calling function gets called for every inner form so we use this
implicit stacking to retain the information.

\defun{compOrCroak1}{compOrCroak1}
\calls{compOrCroak1}{comp}
\calls{compOrCroak1}{compOrCroak1,compactify}
\calls{compOrCroak1}{stackSemanticError}
\calls{compOrCroak1}{mkErrorExpr}
\calls{compOrCroak1}{displaySemanticErrors}
\calls{compOrCroak1}{say}
\calls{compOrCroak1}{displayComp}
\calls{compOrCroak1}{userError}
\usesdollar{compOrCroak1}{compStack}
\usesdollar{compOrCroak1}{compErrorMessageStack}
\usesdollar{compOrCroak1}{level}
\usesdollar{compOrCroak1}{s}
\usesdollar{compOrCroak1}{scanIfTrue}
\usesdollar{compOrCroak1}{exitModeStack}
\catches{compOrCroak1}{compOrCroak}
<<defun compOrCroak1>>=
(defun |compOrCroak1| (x m e |$compStack| |$compErrorMessageStack|)
 (declare (special |$compStack| |$compErrorMessageStack|))
 (let (td errorMessage)
  (declare (special |$level| |$s| |$scanIfTrue| |$exitModeStack|))
  (cond
   ((setq td (catch '|compOrCroak| (|comp| x m e))) td)
   (t
     (setq |$compStack| (cons (list x m e |$exitModeStack|) |$compStack|))
     (setq |$s| (|compOrCroak1,compactify| |$compStack|))
     (setq |$level| (|#| |$s|))
     (setq errorMessage
       (if |$compErrorMessageStack|
         (car |$compErrorMessageStack|)
         '|unspecified error|))
     (cond 
      (|$scanIfTrue|
        (|stackSemanticError| errorMessage (|mkErrorExpr| |$level|))
        (list '|failedCompilation| m e ))
      (t
       (|displaySemanticErrors|)
       (say "****** comp fails at level " |$level| " with expression: ******")
       (|displayComp| |$level|)
       (|userError| errorMessage)))))))

@

\defun{comp}{comp}
\calls{comp}{compNoStacking}
\usesdollar{comp}{compStack}
\usesdollar{comp}{exitModeStack}
<<defun comp>>=
(defun |comp| (x m e)
 (let (td)
 (declare (special |$compStack| |$exitModeStack|))
  (if (setq td (|compNoStacking| x m e))
    (setq |$compStack| nil) 
    (push (list x m e |$exitModeStack|) |$compStack|))
  td))

@

\defun{compNoStacking}{compNoStacking}
\verb|$Representation| is bound in compDefineFunctor, set by doIt.
This hack says that when something is undeclared, \$ is
preferred to the underlying representation -- RDJ 9/12/83
\calls{compNoStacking}{comp2}
\calls{compNoStacking}{compNoStacking1}
\usesdollar{compNoStacking}{compStack}
\usesdollar{compNoStacking}{Representation}
\usesdollar{compNoStacking}{EmptyMode}
<<defun compNoStacking>>=
(defun |compNoStacking| (x m e)
 (let (td)
 (declare (special |$compStack| |$Representation| |$EmptyMode|))
  (if (setq td (|comp2| x m e))
    (if (and (equal m |$EmptyMode|) (equal (second td) |$Representation|))
      (list (car td) '$ (third td))
      td)
   (|compNoStacking1| x m e |$compStack|))))

@

\defun{compNoStacking1}{compNoStacking1}
\calls{compNoStacking1}{get}
\calls{compNoStacking1}{comp2}
\usesdollar{compNoStacking1}{compStack}
<<defun compNoStacking1>>=
(defun |compNoStacking1| (x m e |$compStack|)
 (declare (special |$compStack|))
 (let (u td)
  (if (setq u (|get| (if (eq m '$) '|Rep| m) '|value| e))
    (if (setq td (|comp2| x (car u) e))
      (list (car td) m (third td))
      nil)
    nil)))

@

\defun{comp2}{comp2}
\calls{comp2}{comp3}
\calls{comp2}{isDomainForm}
\calls{comp2}{isFunctor}
\calls{comp2}{insert}
\calls{comp2}{opOf}
\calls{comp2}{nequal}
\calls{comp2}{addDomain}
\usesdollar{comp2}{bootStrapMode}
\usesdollar{comp2}{packagesUsed}
\usesdollar{comp2}{lisplib}
<<defun comp2>>=
(defun |comp2| (x m e)
 (let (tmp1)
  (declare (special |$bootStrapMode| |$packagesUsed| $lisplib))
   (when (setq tmp1 (|comp3| x m e))
    (destructuring-bind (y mprime e) tmp1
     (when (and $lisplib (|isDomainForm| x e) (|isFunctor| x))
       (setq |$packagesUsed| (|insert| (list (|opOf| x)) |$packagesUsed|)))
     ; isDomainForm test needed to prevent error while compiling Ring
     ; $bootStrapMode-test necessary for compiling Ring in $bootStrapMode
     (if (and (nequal m mprime)
              (or |$bootStrapMode| (|isDomainForm| mprime e)))
       (list y mprime (|addDomain| mprime e))
       (list y mprime e))))))

@

\defun{comp3}{comp3}
\begin{verbatim}
;comp3(x,m,$e) ==
;  --returns a Triple or %else nil to signalcan't do'
;  $e:= addDomain(m,$e)
;  e:= $e --for debugging purposes
;  m is ["Mapping",:.] => compWithMappingMode(x,m,e)
;  m is ["QUOTE",a] => (x=a => [x,m,$e]; nil)
;  STRINGP m => (atom x => (m=x or m=STRINGIMAGE x => [m,m,e]; nil); nil)
;  ^x or atom x => compAtom(x,m,e)
;  op:= first x
;  getmode(op,e) is ["Mapping",:ml] and (u:= applyMapping(x,m,e,ml)) => u
;  op is ["KAPPA",sig,varlist,body] => compApply(sig,varlist,body,rest x,m,e)
;  op=":" => compColon(x,m,e)
;  op="::" => compCoerce(x,m,e)
;  not ($insideCompTypeOf=true) and stringPrefix?('"TypeOf",PNAME op) =>
;    compTypeOf(x,m,e)
;  t:= compExpression(x,m,e)
;  t is [x',m',e'] and not MEMBER(m',getDomainsInScope e') =>
;    [x',m',addDomain(m',e')]
;  t
\end{verbatim}
\calls{comp3}{addDomain}
\calls{comp3}{compWithMappingMode}
\calls{comp3}{stringimage}
\calls{comp3}{compAtom}
\calls{comp3}{getmode}
\calls{comp3}{applyMapping}
\calls{comp3}{compApply}
\calls{comp3}{compColon}
\calls{comp3}{compCoerce}
\calls{comp3}{stringPrefix?}
\calls{comp3}{pname}
\calls{comp3}{compTypeOf}
\calls{comp3}{compExpression}
\calls{comp3}{member}
\calls{comp3}{getDomainsInScope}
\usesdollar{comp3}{e}
\usesdollar{comp3}{insideCompTypeOf}
<<defun comp3>>=
(defun |comp3| (x m |$e|)
 (declare (special |$e|))
 (let (e a op ml u sig varlist tmp3 body tt xprime tmp1 mprime tmp2 eprime)
 (declare (special |$insideCompTypeOf|))
  (setq |$e| (|addDomain| m |$e|))
  (setq e |$e|)
  (cond
   ((and (pairp m) (eq (qcar m) '|Mapping|)) (|compWithMappingMode| x m e))
   ((and (pairp m) (eq (qcar m) 'quote)
         (progn
          (setq tmp1 (qcdr m))
          (and (pairp tmp1) (eq (qcdr tmp1) nil)
          (progn (setq a (qcar tmp1)) t))))
    (when (equal x a) (list x m |$e|)))
   ((stringp m)
    (when (and (atom x) (or (equal m x) (equal m (stringimage x))))
     (list m m e )))
   ((or (null x) (atom x)) (|compAtom| x m e))
   (t 
    (setq op (car x))
    (cond
     ((and (progn
            (setq tmp1 (|getmode| op e))
            (and (pairp tmp1)
                 (eq (qcar tmp1) '|Mapping|)
                 (progn (setq ml (qcdr tmp1)) t)))
            (setq u (|applyMapping| x m e ml)))
        u)
     ((and (pairp op) (eq (qcar op) 'kappa)
           (progn
            (setq tmp1 (qcdr op))
            (and (pairp tmp1)
                 (progn
                  (setq sig (qcar tmp1))
                   (setq tmp2 (qcdr tmp1))
                   (and (pairp tmp2)
                        (progn
                         (setq varlist (qcar tmp2))
                         (setq tmp3 (qcdr tmp2))
                         (and (pairp tmp3)
                              (eq (qcdr tmp3) nil)
                              (progn
                                (setq body (qcar tmp3))
                                t))))))))
       (|compApply| sig varlist body (cdr x) m e))
     ((eq op '|:|)  (|compColon| x m e))
     ((eq op '|::|) (|compCoerce| x m e))
     ((and (null (eq |$insideCompTypeOf| t))
           (|stringPrefix?| "TypeOf" (pname op)))
       (|compTypeOf| x m e))
      (t
       (setq tt (|compExpression| x m e))
       (cond
        ((and (pairp tt)
              (progn
               (setq xprime (qcar tt))
               (setq tmp1 (qcdr tt))
               (and (pairp tmp1)
                    (progn
                     (setq mprime (qcar tmp1))
                     (setq tmp2 (qcdr tmp1))
                     (and (pairp tmp2)
                          (eq (qcdr tmp2) nil)
                          (progn
                            (setq eprime (qcar tmp2))
                            t)))))
                     (null (|member| mprime (|getDomainsInScope| eprime))))
         (list xprime mprime (|addDomain| mprime eprime)))
        (t tt))))))))

@

\defun{compTypeOf}{compTypeOf}
\calls{compTypeOf}{eqsubstlist}
\calls{compTypeOf}{get}
\calls{compTypeOf}{put}
\calls{compTypeOf}{comp3}
\usesdollar{compTypeOf}{insideCompTypeOf}
\usesdollar{compTypeOf}{FormalMapVariableList}
<<defun compTypeOf>>=
(defun |compTypeOf| (x m e)
 (let (|$insideCompTypeOf| op argl newModemap)
 (declare (special |$insideCompTypeOf| |$FormalMapVariableList|))
  (setq op (car x))
  (setq argl (cdr x))
  (setq |$insideCompTypeOf| t)
  (setq newModemap
    (eqsubstlist argl |$FormalMapVariableList| (|get| op '|modemap| e)))
  (setq e (|put| op '|modemap| newModemap e))
  (|comp3| x m e)))

@

\defun{compColon}{compColon}
\begin{verbatim}
;compColon([":",f,t],m,e) ==
;  $insideExpressionIfTrue=true => compColonInside(f,m,e,t)
;    --if inside an expression, ":" means to convert to m "on faith"
;  $lhsOfColon: local:= f
;  t:=
;    atom t and (t':= ASSOC(t,getDomainsInScope e)) => t'
;    isDomainForm(t,e) and not $insideCategoryIfTrue =>
;      (if not MEMBER(t,getDomainsInScope e) then e:= addDomain(t,e); t)
;    isDomainForm(t,e) or isCategoryForm(t,e) => t
;    t is ["Mapping",m',:r] => t
;    unknownTypeError t
;    t
;  f is ["LISTOF",:l] =>
;    (for x in l repeat T:= [.,.,e]:= compColon([":",x,t],m,e); T)
;  e:=
;    f is [op,:argl] and not (t is ["Mapping",:.]) =>
;      --for MPOLY--replace parameters by formal arguments: RDJ 3/83
;      newTarget:= EQSUBSTLIST(take(#argl,$FormalMapVariableList),
;        [(x is [":",a,m] => a; x) for x in argl],t)
;      signature:=
;        ["Mapping",newTarget,:
;          [(x is [":",a,m] => m;
;              getmode(x,e) or systemErrorHere '"compColonOld") for x in argl]]
;      put(op,"mode",signature,e)
;    put(f,"mode",t,e)
;  if not $bootStrapMode and $insideFunctorIfTrue and
;    makeCategoryForm(t,e) is [catform,e] then
;        e:= put(f,"value",[genSomeVariable(),t,$noEnv],e)
;  ["/throwAway",getmode(f,e),e]
\end{verbatim}
\calls{compColon}{compColonInside}
\calls{compColon}{assoc}
\calls{compColon}{getDomainsInScope}
\calls{compColon}{isDomainForm}
\calls{compColon}{member}
\calls{compColon}{addDomain}
\calls{compColon}{isDomainForm}
\calls{compColon}{isCategoryForm}
\calls{compColon}{unknownTypeError}
\calls{compColon}{compColon}
\calls{compColon}{eqsubstlist}
\calls{compColon}{take}
\calls{compColon}{length}
\calls{compColon}{nreverse0}
\calls{compColon}{getmode}
\calls{compColon}{systemErrorHere}
\calls{compColon}{put}
\calls{compColon}{makeCategoryForm}
\calls{compColon}{genSomeVariable}
\usesdollar{compColon}{lhsOfColon}
\usesdollar{compColon}{noEnv}
\usesdollar{compColon}{insideFunctorIfTrue}
\usesdollar{compColon}{bootStrapMode}
\usesdollar{compColon}{FormalMapVariableList}
\usesdollar{compColon}{insideCategoryIfTrue}
\usesdollar{compColon}{insideExpressionIfTrue}
<<defun compColon>>=
(defun |compColon| (arg0 m e)
  (let (|$lhsOfColon| argf argt tprime mprime r td op argl newTarget a 
        signature tmp2 catform tmp3 g2 g5)
  (declare (special |$lhsOfColon| |$noEnv| |$insideFunctorIfTrue|
                    |$bootStrapMode| |$FormalMapVariableList|
                    |$insideCategoryIfTrue| |$insideExpressionIfTrue|))
    (setq argf (second arg0))
    (setq argt (third arg0))
    (if |$insideExpressionIfTrue|
      (|compColonInside| argf m e argt)
      (progn
        (setq |$lhsOfColon| argf)
        (setq argt
         (cond
          ((and (atom argt)
                (setq tprime (|assoc| argt (|getDomainsInScope| e))))
            tprime)
          ((and (|isDomainForm| argt e) (null |$insideCategoryIfTrue|))
            (unless (|member| argt (|getDomainsInScope| e))
               (setq e (|addDomain| argt e)))
            argt)
          ((or (|isDomainForm| argt e) (|isCategoryForm| argt e))
            argt)
          ((and (pairp argt) (eq (qcar argt) '|Mapping|)
                (progn
                  (setq tmp2 (qcdr argt))
                  (and (pairp tmp2)
                       (progn
                        (setq mprime (qcar tmp2))
                        (setq r (qcdr tmp2))
                        t))))
            argt)
          (t
            (|unknownTypeError| argt)
            argt)))
        (cond
         ((eq (car argf) 'listof)
           (dolist (x (cdr argf) td)
             (setq td (|compColon| (list '|:| x argt) m e))
             (setq e (third td))))
         (t
          (setq e
           (cond
            ((and (pairp argf)
                  (progn
                   (setq op (qcar argf))
                   (setq argl (qcdr argf))
                   t)
                  (null (and (pairp argt) (eq (qcar argt) '|Mapping|))))
             (setq newTarget
              (eqsubstlist (take (|#| argl) |$FormalMapVariableList|)
              (dolist (x argl (nreverse0 g2))
                (setq g2
                 (cons
                  (cond
                   ((and (pairp x) (eq (qcar x) '|:|)
                         (progn
                          (setq tmp2 (qcdr x))
                          (and (pairp tmp2)
                               (progn
                                (setq a (qcar tmp2))
                                (setq tmp3 (qcdr tmp2))
                                (and (pairp tmp3)
                                     (eq (qcdr tmp3) nil)
                                     (progn
                                      (setq m (qcar tmp3))
                                      t))))))
                       a)
                      (t x))
               g2)))
              argt))
             (setq signature
              (cons '|Mapping|
               (cons newTarget
                (dolist (x argl (nreverse0 g5))
                  (setq g5
                   (cons
                    (cond
                     ((and (pairp x) (eq (qcar x) '|:|)
                      (progn
                       (setq tmp2 (qcdr x))
                       (and (pairp tmp2)
                            (progn
                             (setq a (qcar tmp2))
                             (setq tmp3 (qcdr tmp2))
                             (and (pairp tmp3)
                                  (eq (qcdr tmp3) nil)
                                  (progn
                                   (setq m (qcar tmp3))
                                   t))))))
                       m)
                     (t
                      (or (|getmode| x e)
                          (|systemErrorHere| "compColonOld"))))
                     g5))))))
             (|put| op '|mode| signature e))
            (t (|put| argf '|mode| argt e))))
         (cond
           ((and (null |$bootStrapMode|) |$insideFunctorIfTrue|
                 (progn
                  (setq tmp2 (|makeCategoryForm| argt e))
                  (and (pairp tmp2)
                       (progn
                        (setq catform (qcar tmp2))
                        (setq tmp3 (qcdr tmp2))
                        (and (pairp tmp3)
                             (eq (qcdr tmp3) nil)
                             (progn
                               (setq e (qcar tmp3))
                                       t))))))
            (setq e 
             (|put| argf '|value| (list (|genSomeVariable|) argt |$noEnv|)
              e))))
         (list '|/throwAway| (|getmode| argf e) e )))))))

@

\defun{compColonInside}{compColonInside}
\calls{compColonInside}{addDomain}
\calls{compColonInside}{comp}
\calls{compColonInside}{coerce}
\calls{compColonInside}{stackWarning}
\calls{compColonInside}{opOf}
\calls{compColonInside}{stackSemanticError}
\usesdollar{compColonInside}{newCompilerUnionFlag}
\usesdollar{compColonInside}{EmptyMode}
<<defun compColonInside>>=
(defun |compColonInside| (x m e mprime)
 (let (mpp warningMessage td tprime)
 (declare (special |$newCompilerUnionFlag| |$EmptyMode|))
    (setq e (|addDomain| mprime e))
    (when (setq td (|comp| x |$EmptyMode| e))
     (cond
      ((equal (setq mpp (second td)) mprime)
       (setq warningMessage
        (list '|:| mprime '| -- should replace by @|))))
     (setq td (list (car td) mprime (third td)))
     (when (setq tprime (|coerce| td m))
      (cond
       (warningMessage (|stackWarning| warningMessage))
       ((and |$newCompilerUnionFlag| (eq (|opOf| mpp) '|Union|))
        (setq tprime
         (|stackSemanticError|
          (list '|cannot pretend | x '| of mode | mpp '| to mode | mprime )
          nil)))
       (t
        (|stackWarning|
         (list '|:| mprime '| -- should replace by pretend|))))
      tprime))))

@

\defun{compAtom}{compAtom}
\begin{verbatim}
;compAtom(x,m,e) ==
;  T:= compAtomWithModemap(x,m,e,get(x,"modemap",e)) => T
;  x="nil" =>
;    T:=
;      modeIsAggregateOf('List,m,e) is [.,R]=> compList(x,['List,R],e)
;      modeIsAggregateOf('Vector,m,e) is [.,R]=> compVector(x,['Vector,R],e)
;    T => convert(T,m)
;  t:=
;    isSymbol x =>
;      compSymbol(x,m,e) or return nil
;    m = $Expression and primitiveType x => [x,m,e]
;    STRINGP x => [x,x,e]
;    [x,primitiveType x or return nil,e]
;  convert(t,m)
\end{verbatim}
\calls{compAtom}{compAtomWithModemap}
\calls{compAtom}{get}
\calls{compAtom}{modeIsAggregateOf}
\calls{compAtom}{compList}
\calls{compAtom}{compVector}
\calls{compAtom}{convert}
\calls{compAtom}{isSymbol}
\calls{compAtom}{compSymbol}
\calls{compAtom}{primitiveType}
\calls{compAtom}{primitiveType}
\usesdollar{compAtom}{Expression}
<<defun compAtom>>=
(defun |compAtom| (x m e)
 (prog (tmp1 tmp2 r td tt)
  (declare (special |$Expression|))
   (return
   (cond
    ((setq td (|compAtomWithModemap| x m e (|get| x '|modemap| e))) td)
    ((eq x '|nil|)
     (setq td
      (cond
       ((progn
         (setq tmp1 (|modeIsAggregateOf| '|List| m e))
         (and (pairp tmp1)
              (progn
               (setq tmp2 (qcdr tmp1))
               (and (pairp tmp2)
                    (eq (qcdr tmp2) nil)
                    (progn
                      (setq r (qcar tmp2)) t)))))
         (|compList| x (list '|List| r) e))
       ((progn
         (setq tmp1 (|modeIsAggregateOf| '|Vector| m e))
         (and (pairp tmp1)
              (progn
               (setq tmp2 (qcdr tmp1))
               (and (pairp tmp2) (eq (qcdr tmp2) nil)
               (progn
                 (setq r (qcar tmp2)) t)))))
         (|compVector| x (list '|Vector| r) e))))
      (when td (|convert| td m)))
    (t
     (setq tt
      (cond
       ((|isSymbol| x) (or (|compSymbol| x m e) (return nil)))
       ((and (equal m |$Expression|) (|primitiveType| x)) (list x m e ))
       ((stringp x) (list x x e ))
       (t (list x (or (|primitiveType| x) (return nil)) e ))))
     (|convert| tt m))))))

@

\defun{convert}{convert}
\calls{convert}{resolve}
\calls{convert}{coerce}
<<defun convert>>=
(defun |convert| (td m)
 (let (res)
  (when (setq res (|resolve| (second td) m))
   (|coerce| td res))))

@
\defun{primitiveType}{primitiveType}
\usesdollar{primitiveType}{DoubleFloat}
\usesdollar{primitiveType}{NegativeInteger}
\usesdollar{primitiveType}{PositiveInteger}
\usesdollar{primitiveType}{NonNegativeInteger}
\usesdollar{primitiveType}{String}
\usesdollar{primitiveType}{EmptyMode}
<<defun primitiveType>>=
(defun |primitiveType| (x)
  (declare (special |$DoubleFloat| |$NegativeInteger| |$PositiveInteger|
                     |$NonNegativeInteger| |$String| |$EmptyMode|))
  (cond
    ((null x) |$EmptyMode|)
    ((stringp x) |$String|)
    ((integerp x)
     (cond
       ((eql x 0) |$NonNegativeInteger|)
       ((> x 0) |$PositiveInteger|)
       (t |$NegativeInteger|)))
    ((floatp x) |$DoubleFloat|)
    (t nil)))

@
\defun{compSymbol}{compSymbol}
\calls{compSymbol}{getmode}
\calls{compSymbol}{get}
\calls{compSymbol}{NRTgetLocalIndex}
\calls{compSymbol}{member}
\calls{compSymbol}{isFunction}
\calls{compSymbol}{errorRef}
\calls{compSymbol}{stackMessage}
\usesdollar{compSymbol}{Symbol}
\usesdollar{compSymbol}{Expression}
\usesdollar{compSymbol}{FormalMapVariableList}
\usesdollar{compSymbol}{compForModeIfTrue}
\usesdollar{compSymbol}{formalArgList}
\usesdollar{compSymbol}{NoValueMode}
\usesdollar{compSymbol}{functorLocalParameters}
\usesdollar{compSymbol}{Boolean}
\usesdollar{compSymbol}{NoValue}
<<defun compSymbol>>=
(defun |compSymbol| (s m e)
 (let (v mprime mode)
  (declare (special |$Symbol| |$Expression| |$FormalMapVariableList|
                    |$compForModeIfTrue| |$formalArgList| |$NoValueMode|
                    |$functorLocalParameters| |$Boolean| |$NoValue|))
   (cond
     ((eq s '|$NoValue|) (list '|$NoValue| |$NoValueMode| e ))
     ((|isFluid| s)
      (setq mode (|getmode| s e))
      (when mode (list s (|getmode| s e) e)))
     ((eq s '|true|) (list '(quote t) |$Boolean| e ))
     ((eq s '|false|) (list nil |$Boolean| e ))
     ((or (equal s m) (|get| s '|isLiteral| e)) (list (list 'quote s) s e))
     ((setq v (|get| s '|value| e))
      (cond
        ((member s |$functorLocalParameters|)
         ; s will be replaced by an ELT form in beforeCompile
         (|NRTgetLocalIndex| s) 
         (list s (second v) e))
        (t
         ; s has been SETQd
         (list s (second v) e))))
     ((setq mprime (|getmode| s e))
      (cond
        ((and (null (|member| s |$formalArgList|))
              (null (member s |$FormalMapVariableList|))
              (null (|isFunction| s e))
              (null (eq |$compForModeIfTrue| t)))
         (|errorRef| s)))
      (list s mprime e ))
     ((member s |$FormalMapVariableList|)
      (|stackMessage| (list '|no mode found for| s )))
     ((or (equal m |$Expression|) (equal m |$Symbol|))
      (list (list 'quote s) m e ))
     ((null (|isFunction| s e)) (|errorRef| s)))))

@

\defun{compList}{compList}
\begin{verbatim}
;compList(l,m is ["List",mUnder],e) ==
;  null l => [NIL,m,e]
;  Tl:= [[.,mUnder,e]:= comp(x,mUnder,e) or return "failed" for x in l]
;  Tl="failed" => nil
;  T:= [["LIST",:[T.expr for T in Tl]],["List",mUnder],e]
\end{verbatim}
\calls{compList}{comp}
<<defun compList>>=
(defun |compList| (l m e)
 (let (tmp1 tmp2 t0 failed (mUnder (second m)))
  (if (null l)
   (list nil m e)
   (progn
    (setq t0
     (do ((t3 l (cdr t3)) (x nil))
         ((or (atom t3) failed) (unless failed (nreverse0 tmp2)))
       (setq x (car t3))
       (if (setq tmp1 (|comp| x mUnder e))
        (progn
         (setq mUnder (second tmp1))
         (setq e (third tmp1))
         (push tmp1 tmp2))
        (setq failed t))))
    (unless failed
     (cons 
       (cons 'list (loop for texpr in t0 collect (car texpr)))
       (list (list '|List| mUnder) e)))))))

@

\defun{compVector}{compVector}
\begin{verbatim}
;  null l => [$EmptyVector,m,e]
;  Tl:= [[.,mUnder,e]:= comp(x,mUnder,e) or return "failed" for x in l]
;  Tl="failed" => nil
;  [["VECTOR",:[T.expr for T in Tl]],m,e]
\end{verbatim}
\calls{compVector}{comp}
\usesdollar{compVector}{EmptyVector}
<<defun compVector>>=
(defun |compVector| (l m e)
 (let (tmp1 tmp2 t0 failed (mUnder (second m)))
  (declare (special |$EmptyVector|))
   (if (null l)
    (list |$EmptyVector| m e)
    (progn
     (setq t0
      (do ((t3 l (cdr t3)) (x nil))
          ((or (atom t3) failed) (unless failed (nreverse0 tmp2)))
        (setq x (car t3))
        (if (setq tmp1 (|comp| x mUnder e))
          (progn
           (setq mUnder (second tmp1))
           (setq e (third tmp1))
           (push tmp1 tmp2))
          (setq failed t))))
     (unless failed      
      (list (cons 'vector (loop for texpr in t0 collect (car texpr))) m e))))))

@
\defun{compExpression}{compExpression}
\calls{compExpression}{getl}
\calls{compExpression}{compForm}
\usesdollar{compExpression}{insideExpressionIfTrue}
<<defun compExpression>>=
(defun |compExpression| (x m e)
 (let (|$insideExpressionIfTrue| fn)
 (declare (special |$insideExpressionIfTrue|))
  (setq |$insideExpressionIfTrue| t)
  (if (and (atom (car x)) (setq fn (getl (car x) 'special)))
    (funcall fn x m e)
    (|compForm| x m e))))

@

\defun{compForm}{compForm}
\calls{compForm}{compForm1}
\calls{compForm}{compArgumentsAndTryAgain}
\calls{compForm}{stackMessageIfNone}
<<defun compForm>>=
(defun |compForm| (form m e)
 (cond
  ((|compForm1| form m e))
  ((|compArgumentsAndTryAgain| form m e))
  (t (|stackMessageIfNone| (list '|cannot compile| '|%b| form '|%d| )))))

@

\defun{compForm1}{compForm1}
\calls{compForm1}{length}
\calls{compForm1}{outputComp}
\calls{compForm1}{compOrCroak}
\calls{compForm1}{compExpressionList}
\calls{compForm1}{coerceable}
\calls{compForm1}{comp}
\calls{compForm1}{coerce}
\calls{compForm1}{compForm2}
\calls{compForm1}{augModemapsFromDomain1}
\calls{compForm1}{getFormModemaps}
\calls{compForm1}{nreverse0}
\calls{compForm1}{addDomain}
\calls{compForm1}{compToApply}
\usesdollar{compForm1}{NumberOfArgsIfInteger}
\usesdollar{compForm1}{Expression}
\usesdollar{compForm1}{EmptyMode}
<<defun compForm1>>=
(defun |compForm1| (form m e)
 (let (|$NumberOfArgsIfInteger| op argl domain tmp1 opprime ans mmList td 
       tmp2 tmp3 tmp4 tmp5 tmp6 tmp7)
 (declare (special |$NumberOfArgsIfInteger| |$Expression| |$EmptyMode|))
    (setq op (car form))
    (setq argl (cdr form))
    (setq |$NumberOfArgsIfInteger| (|#| argl))
    (cond
     ((eq op '|error|)
      (list
       (cons op
        (dolist (x argl (nreverse0 tmp4))
          (setq tmp2 (|outputComp| x e))
          (setq e (third tmp2))
          (push (car tmp2) tmp4)))
       m e))
     ((and (pairp op) (eq (qcar op) '|elt|)
           (progn
            (setq tmp3 (qcdr op))
            (and (pairp tmp3)
                 (progn
                  (setq domain (qcar tmp3))
                  (setq tmp1 (qcdr tmp3))
                  (and (pairp tmp1)
                       (eq (qcdr tmp1) nil)
                       (progn
                        (setq opprime (qcar tmp1))
                        t))))))
       (cond
        ((eq domain '|Lisp|)
          (list 
           (cons opprime
            (dolist (x argl (nreverse tmp7))
             (setq tmp2 (|compOrCroak| x |$EmptyMode| e))
             (setq e (third tmp2))
             (push (car tmp2) tmp7)))
           m e))
        ((and (equal domain |$Expression|) (eq opprime '|construct|))
          (|compExpressionList| argl m e))
        ((and (eq opprime 'collect) (|coerceable| domain m e))
          (when (setq td (|comp| (cons opprime argl) domain e))
           (|coerce| td m)))
        ((and (pairp domain) (eq (qcar domain) '|Mapping|)
              (setq ans
               (|compForm2| (cons opprime argl) m
                (setq e (|augModemapsFromDomain1| domain domain e))
                (dolist (x (|getFormModemaps| (cons opprime argl) e)
                                          (nreverse0 tmp6))
                 (when
                  (and (pairp x)
                       (and (pairp (qcar x)) (equal (qcar (qcar x)) domain)))
                    (push x tmp6))))))
          ans)
        ((setq ans
          (|compForm2| (cons opprime argl) m
           (setq e (|addDomain| domain e))
           (dolist (x (|getFormModemaps| (cons opprime argl) e)
                   (nreverse0 tmp5))
             (when
               (and (pairp x)
                    (and (pairp (qcar x)) (equal (qcar (qcar x)) domain)))
                (push x tmp5)))))
          ans)
        ((and (eq opprime '|construct|) (|coerceable| domain m e))
          (when (setq td (|comp| (cons opprime argl) domain e))
           (|coerce| td m)))
        (t nil)))
     (t
      (setq e (|addDomain| m e))
      (cond
       ((and (setq mmList (|getFormModemaps| form e))
             (setq td (|compForm2| form m e mmList)))
         td)
       (t
         (|compToApply| op argl m e)))))))

@

\defun{compForm2}{compForm2}
\calls{compForm2}{take}
\calls{compForm2}{length}
\calls{compForm2}{nreverse0}
\calls{compForm2}{sublis}
\calls{compForm2}{assoc}
\calls{compForm2}{PredImplies}
\calls{compForm2}{isSimple}
\calls{compForm2}{compUniquely}
\calls{compForm2}{compFormPartiallyBottomUp}
\calls{compForm2}{compForm3}
\usesdollar{compForm2}{EmptyMode}
\usesdollar{compForm2}{TriangleVariableList}
<<defun compForm2>>=
(defun |compForm2| (form m e modemapList)
 (let (op argl sargl aList dc cond nsig v ncond deleteList newList td tl
       partialModeList tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7)
 (declare (special |$EmptyMode| |$TriangleVariableList|))
  (setq op (car form))
  (setq argl (cdr form))
  (setq sargl (take (|#| argl) |$TriangleVariableList|))
  (setq aList (mapcar #'(lambda (x y) (cons x y)) sargl argl))
  (setq modemaplist (sublis aList modemapList))
  ; now delete any modemaps that are subsumed by something else, provided 
  ; the conditions are right (i.e. subsumer true whenever subsumee true)
  (dolist (u modemapList)
   (cond
    ((and (pairp u)
          (progn
           (setq tmp6 (qcar u))
           (and (pairp tmp6) (progn (setq dc (qcar tmp6)) t)))
          (progn
           (setq tmp7 (qcdr u))
           (and (pairp tmp7) (eq (qcdr tmp7) nil)
                (progn
                 (setq tmp1 (qcar tmp7))
                 (and (pairp tmp1)
                      (progn
                       (setq cond (qcar tmp1))
                       (setq tmp2 (qcdr tmp1))
                       (and (pairp tmp2) (eq (qcdr tmp2) nil)
                            (progn
                             (setq tmp3 (qcar tmp2))
                             (and (pairp tmp3) (eq (qcar tmp3) '|Subsumed|)
                                  (progn
                                   (setq tmp4 (qcdr tmp3))
                                   (and (pairp tmp4)
                                        (progn
                                         (setq tmp5 (qcdr tmp4))
                                         (and (pairp tmp5) 
                                              (eq (qcdr tmp5) nil)
                                              (progn
                                               (setq nsig (qcar tmp5))
                                               t)))))))))))))
          (setq v (|assoc| (cons dc nsig) modemapList))
          (pairp v)
          (progn
           (setq tmp6 (qcdr v))
           (and (pairp tmp6) (eq (qcdr tmp6) nil)
                (progn
                 (setq tmp7 (qcar tmp6))
                 (and (pairp tmp7)
                      (progn
                       (setq ncond (qcar tmp7))
                       t))))))
      (setq deleteList (cons u deleteList))
      (unless  (|PredImplies| ncond cond)
         (setq newList (push `(,(car u) (,cond (elt ,dc nil))) newList))))))
  (when deleteList
   (setq modemapList 
    (remove-if #'(lambda (x) (member x deletelist)) modemapList)))
  ; it is important that subsumed ops (newList) be considered last
  (when newList (setq modemapList (append modemapList newList)))
  (setq tl
   (loop for x in argl 
         while (and (|isSimple| x)
                    (setq td (|compUniquely| x |$EmptyMode| e)))
         collect td
         do (setq e (third td))))
  (cond
   ((some #'identity tl)
     (setq partialModeList (loop for x in tl collect (when x (second x))))
     (or (|compFormPartiallyBottomUp| form m e modemapList partialModeList)
         (|compForm3| form m e modemapList)))
   (t (|compForm3| form m e modemapList)))))

@

\defun{compArgumentsAndTryAgain}{compArgumentsAndTryAgain}
\calls{compArgumentsAndTryAgain}{comp}
\calls{compArgumentsAndTryAgain}{compForm1}
\usesdollar{compArgumentsAndTryAgain}{EmptyMode}
<<defun compArgumentsAndTryAgain>>=
(defun |compArgumentsAndTryAgain| (form m e)
 (let (argl tmp1 a tmp2 tmp3 u)
 (declare (special |$EmptyMode|))
  (setq argl (cdr form))
  (cond
   ((and (pairp form) (eq (qcar form) '|elt|)
         (progn
           (setq tmp1 (qcdr form))
           (and (pairp tmp1)
                (progn
                 (setq a (qcar tmp1))
                 (setq tmp2 (qcdr tmp1))
                 (and (pairp tmp2) (eq (qcdr tmp2) nil))))))
    (when (setq tmp3 (|comp| a |$EmptyMode| e))
      (setq e (third tmp3))
      (|compForm1| form m e)))
   (t
     (setq u
      (dolist (x argl)
       (setq tmp3 (or (|comp| x |$EmptyMode| e) (return '|failed|)))
       (setq e (third tmp3))
       tmp3))
     (unless (eq u '|failed|)
       (|compForm1| form m e))))))

@
\defun{compWithMappingMode}{compWithMappingMode}
\calls{compWithMappingMode}{compWithMappingMode1}
\usesdollar{compWithMappingMode}{formalArgList}
<<defun compWithMappingMode>>=
(defun |compWithMappingMode| (x m oldE)
  (declare (special |$formalArgList|))
  (|compWithMappingMode1| x m oldE |$formalArgList|))

@

\defun{compWithMappingMode1}{compWithMappingMode1}
\begin{verbatim}
;compWithMappingMode1(x,m is ["Mapping",m',:sl],oldE,$formalArgList) ==
;  $killOptimizeIfTrue: local:= true
;  e:= oldE
;  isFunctor x =>
;    if get(x,"modemap",$CategoryFrame) is [[[.,target,:argModeList],.],:.] and
;     (and/[extendsCategoryForm("$",s,mode) for mode in argModeList for s in sl]
;       ) and extendsCategoryForm("$",target,m') then return [x,m,e]
;  if STRINGP x then x:= INTERN x
;  ress:=nil
;  old_style:=true
;  if x is ["+->",vl,nx] then
;    old_style:=false
;    vl is [":",:.] =>
;      ress:=compLambda(x,m,oldE)
;      ress
;    vl:=
;      vl is ["Tuple",:vl1] => vl1
;      vl
;    vl:=
;      SYMBOLP(vl) => [vl]
;      LISTP(vl) and (and/[SYMBOLP(v) for v in vl]) => vl
;      stackAndThrow ["bad +-> arguments:",vl]
;    $formatArgList:=[:vl,:$formalArgList]
;    x:=nx
;  else
;    vl:=take(#sl,$FormalMapVariableList)
;  ress => ress
;  for m in sl for v in vl repeat
;    [.,.,e]:= compMakeDeclaration([":",v,m],$EmptyMode,e)
;  old_style and not null vl and not hasFormalMapVariable(x, vl) => return
;    [u,.,.] := comp([x,:vl],m',e) or return nil
;    extractCodeAndConstructTriple(u, m, oldE)
;  null vl and (t := comp([x], m', e)) => return
;    [u,.,.] := t
;    extractCodeAndConstructTriple(u, m, oldE)
;  [u,.,.]:= comp(x,m',e) or return nil
;  uu:=optimizeFunctionDef [nil,['LAMBDA,vl,u]]
;  --  At this point, we have a function that we would like to pass.
;  --  Unfortunately, it makes various free variable references outside
;  --  itself.  So we build a mini-vector that contains them all, and
;  --  pass this as the environment to our inner function.
;  $FUNNAME :local := nil
;  $FUNNAME__TAIL :local := [nil]
;  expandedFunction:=COMP_-TRAN CADR uu
;  frees:=freelist(expandedFunction,vl,nil,e)
;    where freelist(u,bound,free,e) ==
;      atom u =>
;        not IDENTP u => free
;        MEMQ(u,bound) => free
;        v:=ASSQ(u,free) =>
;          RPLACD(v,1+CDR v)
;          free
;        not getmode(u, e) => free
;        [[u,:1],:free]
;      op:=CAR u
;      MEMQ(op, '(QUOTE GO function)) => free
;      EQ(op,'LAMBDA) =>
;        bound:=UNIONQ(bound,CADR u)
;        for v in CDDR u repeat
;          free:=freelist(v,bound,free,e)
;        free
;      EQ(op,'PROG) =>
;        bound:=UNIONQ(bound,CADR u)
;        for v in CDDR u | NOT ATOM v repeat
;          free:=freelist(v,bound,free,e)
;        free
;      EQ(op,'SEQ) =>
;        for v in CDR u | NOT ATOM v repeat
;          free:=freelist(v,bound,free,e)
;        free
;      EQ(op,'COND) =>
;        for v in CDR u repeat
;          for vv in v repeat
;            free:=freelist(vv,bound,free,e)
;        free
;      if ATOM op then u:=CDR u  --Atomic functions aren't descended
;      for v in u repeat
;        free:=freelist(v,bound,free,e)
;      free
;  expandedFunction :=
;            --One free can go by itself, more than one needs a vector
;         --An A-list name . number of times used
;    #frees = 0 => ['LAMBDA,[:vl,"$$"], :CDDR expandedFunction]
;    #frees = 1 =>
;      vec:=first first frees
;      ['LAMBDA,[:vl,vec], :CDDR expandedFunction]
;    scode:=nil
;    vec:=nil
;    locals:=nil
;    i:=-1
;    for v in frees repeat
;      i:=i+1
;      vec:=[first v,:vec]
;      scode:=[['SETQ,first v,[($QuickCode => 'QREFELT;'ELT),"$$",i]],:scode]
;      locals:=[first v,:locals]
;    body:=CDDR expandedFunction
;    if locals then
;      if body is [['DECLARE,:.],:.] then
;        body:=[CAR body,['PROG,locals,:scode,['RETURN,['PROGN,:CDR body]]]]
;      else body:=[['PROG,locals,:scode,['RETURN,['PROGN,:body]]]]
;    vec:=['VECTOR,:NREVERSE vec]
;    ['LAMBDA,[:vl,"$$"],:body]
;  fname:=['CLOSEDFN,expandedFunction]
;         --Like QUOTE, but gets compiled
;  uu:=
;    frees => ['CONS,fname,vec]
;    ['LIST,fname]
;  [uu,m,oldE]
\end{verbatim}
\calls{compWithMappingMode1}{isFunctor}
\calls{compWithMappingMode1}{get}
\calls{compWithMappingMode1}{qcar}
\calls{compWithMappingMode1}{qcdr}
\calls{compWithMappingMode1}{extendsCategoryForm}
\calls{compWithMappingMode1}{compLambda}
\calls{compWithMappingMode1}{stackAndThrow}
\calls{compWithMappingMode1}{take}
\calls{compWithMappingMode1}{compMakeDeclaration}
\calls{compWithMappingMode1}{hasFormalMapVariable}
\calls{compWithMappingMode1}{comp}
\calls{compWithMappingMode1}{extractCodeAndConstructTriple}
\calls{compWithMappingMode1}{optimizeFunctionDef}
\calls{compWithMappingMode1}{comp-tran}
\calls{compWithMappingMode1}{freelist}
\usesdollar{compWithMappingMode1}{formalArgList}
\usesdollar{compWithMappingMode1}{killOptimizeIfTrue}
\usesdollar{compWithMappingMode1}{funname}
\usesdollar{compWithMappingMode1}{funnameTail}
\usesdollar{compWithMappingMode1}{QuickCode}
\usesdollar{compWithMappingMode1}{EmptyMode}
\usesdollar{compWithMappingMode1}{FormalMapVariableList}
\usesdollar{compWithMappingMode1}{CategoryFrame}
\usesdollar{compWithMappingMode1}{formatArgList}
<<defun compWithMappingMode1>>=
(defun |compWithMappingMode1| (x m oldE |$formalArgList|)
 (declare (special |$formalArgList|))
  (prog (|$killOptimizeIfTrue| $funname $funnameTail mprime sl tmp1 tmp2 
         tmp3 tmp4 tmp5 tmp6 target argModeList nx oldstyle ress vl1 vl e tt
             u frees i scode locals body vec expandedFunction fname uu)
  (declare (special |$killOptimizeIfTrue| $funname $funnameTail
                    |$QuickCode| |$EmptyMode| |$FormalMapVariableList|
                    |$CategoryFrame| |$formatArgList|))
   (return
    (seq
     (progn
      (setq mprime (second m))
      (setq sl (cddr m))
      (setq |$killOptimizeIfTrue| t)
      (setq e oldE)
      (cond
       ((|isFunctor| x)
        (cond
         ((and (progn
                (setq tmp1 (|get| x '|modemap| |$CategoryFrame|))
                (and (pairp tmp1)
                     (progn
                      (setq tmp2 (qcar tmp1))
                      (and (pairp tmp2)
                           (progn
                            (setq tmp3 (qcar tmp2))
                            (and (pairp tmp3)
                                 (progn
                                  (setq tmp4 (qcdr tmp3))
                                  (and (pairp tmp4)
                                       (progn 
                                        (setq target (qcar tmp4))
                                        (setq argModeList (qcdr tmp4))
                                        t)))))
                           (progn
                            (setq tmp5 (qcdr tmp2))
                            (and (pairp tmp5) (eq (qcdr tmp5) nil)))))))
               (prog (t1)
                (setq t1 t)
                (return
                 (do ((t2 nil (null t1))
                      (t3 argModeList (cdr t3))
                      (mode nil)
                      (t4 sl (cdr t4))
                      (s nil))
                    ((or t2 (atom t3)
                         (progn (setq mode (car t3)) nil)
                         (atom t4)
                         (progn (setq s (car t4)) nil))
                        t1)
                   (seq (exit
                     (setq t1 
                      (and t1 (|extendsCategoryForm| '$ s mode))))))))
                        (|extendsCategoryForm| '$ target mprime))
               (return (list x m e )))
         (t nil)))
       (t 
        (when (stringp x) (setq x (intern x)))
        (setq ress nil) 
        (setq oldstyle t)
        (cond
         ((and (pairp x) 
               (eq (qcar x) '+->)
               (progn
                (setq tmp1 (qcdr x))
                (and (pairp tmp1)
                     (progn
                      (setq vl (qcar tmp1))
                      (setq tmp2 (qcdr tmp1))
                      (and (pairp tmp2)
                           (eq (qcdr tmp2) nil)
                           (progn (setq nx (qcar tmp2)) t))))))
            (setq oldstyle nil)
            (cond
             ((and (pairp vl) (eq (qcar vl) '|:|))
               (setq ress (|compLambda| x m oldE))
               ress)
             (t
              (setq vl
               (cond
                ((and (pairp vl)
                      (eq (qcar vl) '|@Tuple|)
                      (progn (setq vl1 (qcdr vl)) t))
                  vl1)
                (t vl)))
              (setq vl
               (cond
                ((symbolp vl) (cons vl nil))
                ((and 
                  (listp vl)
                  (prog (t5)
                   (setq t5 t)
                   (return
                    (do ((t7 nil (null t5))
                         (t6 vl (cdr t6))
                         (v nil))
                       ((or t7 (atom t6) (progn (setq v (car t6)) nil)) t5)
                      (seq
                       (exit
                        (setq t5 (and t5 (symbolp v)))))))))
                  vl)
                (t
                 (|stackAndThrow| (cons '|bad +-> arguments:| (list vl ))))))
              (setq |$formatArgList| (append vl |$formalArgList|))
              (setq x nx))))
         (t
          (setq vl (take (|#| sl) |$FormalMapVariableList|))))
        (cond
         (ress ress)
         (t
          (do ((t8 sl (cdr t8)) (m nil) (t9 vl (cdr t9)) (v nil))
              ((or (atom t8)
                   (progn (setq m (car t8)) nil)
                   (atom t9)
                   (progn (setq v (car t9)) nil))
                 nil)
              (seq (exit (progn
               (setq tmp6 
                (|compMakeDeclaration| (list '|:| v m ) |$EmptyMode| e))
               (setq e (third tmp6))
               tmp6))))
          (cond
           ((and oldstyle 
                 (null (null vl))
                 (null (|hasFormalMapVariable| x vl)))
            (return
             (progn
              (setq tmp6 (or (|comp| (cons x vl) mprime e) (return nil)))
              (setq u (car tmp6))
              (|extractCodeAndConstructTriple| u m oldE))))
           ((and (null vl) (setq tt (|comp| (cons x nil) mprime e)))
            (return
             (progn
               (setq u (car tt))
               (|extractCodeAndConstructTriple| u m oldE))))
           (t
            (setq tmp6 (or (|comp| x mprime e) (return nil)))
            (setq u (car tmp6))
            (setq uu (|optimizeFunctionDef| `(nil (lambda ,vl ,u))))
;  --  At this point, we have a function that we would like to pass.
;  --  Unfortunately, it makes various free variable references outside
;  --  itself.  So we build a mini-vector that contains them all, and
;  --  pass this as the environment to our inner function.
            (setq $funname nil)
            (setq $funnameTail (list nil))
            (setq expandedFunction (comp-tran (second uu)))
            (setq frees (freelist expandedFunction vl nil e))
            (setq expandedFunction
             (cond
              ((eql (|#| frees) 0)
               (cons 'lambda (cons (append vl (list '$$))
                                         (cddr expandedFunction))))
              ((eql (|#| frees) 1)
               (setq vec (caar frees))
                (cons 'lambda (cons (append vl (list vec))
                                         (cddr expandedFunction))))
              (t 
               (setq scode nil)
               (setq vec nil)
               (setq locals nil)
               (setq i -1)
               (do ((t0 frees (cdr t0)) (v nil))
                   ((or (atom t0) (progn (setq v (car t0)) nil)) nil)
                 (seq
                  (exit
                   (progn
                    (setq i (plus i 1))
                    (setq vec (cons (car v) vec))
                    (setq scode
                     (cons
                      (cons 'setq 
                       (cons (car v) 
                        (cons
                         (cons
                          (cond
                           (|$QuickCode| 'qrefelt)
                           (t 'elt))
                          (cons '$$ (cons i nil)))
                         nil)))
                       scode))
                    (setq locals (cons (car v) locals))))))
               (setq body (cddr expandedFunction))
               (cond
                (locals
                 (cond
                  ((and (pairp body)
                        (progn
                         (setq tmp1 (qcar body))
                         (and (pairp tmp1)
                              (eq (qcar tmp1) 'declare))))
                    (setq body
                     (cons (car body)
                      (cons
                       (cons 'prog
                        (cons locals
                         (append scode
                          (cons
                           (cons 'return
                            (cons
                             (cons 'progn
                              (cdr body))
                             nil))
                           nil))))
                        nil))))
                  (t
                   (setq body
                    (cons
                     (cons 'prog
                      (cons locals
                       (append scode
                        (cons
                         (cons 'return
                          (cons
                           (cons 'progn body)
                           nil))
                         nil))))
                     nil))))))
               (setq vec (cons 'vector (nreverse vec)))
               (cons 'lambda (cons (append vl (list '$$)) body)))))
            (setq fname (list 'closedfn expandedFunction))
            (setq uu
             (cond
              (frees (list 'cons fname vec))
              (t (list 'list fname))))
            (list uu m oldE))))))))))))

@

\defun{extractCodeAndConstructTriple}{extractCodeAndConstructTriple}
<<defun extractCodeAndConstructTriple>>=
(defun |extractCodeAndConstructTriple| (u m oldE)
 (let (tmp1 a fn op env)
  (cond
   ((and (pairp u) (eq (qcar u) '|call|)
         (progn
          (setq tmp1 (qcdr u))
          (and (pairp tmp1)
               (progn (setq fn (qcar tmp1)) t))))
    (cond
     ((and (pairp fn) (eq (qcar fn) '|applyFun|)
           (progn
            (setq tmp1 (qcdr fn))
            (and (pairp tmp1) (eq (qcdr tmp1) nil)
                 (progn (setq a (qcar tmp1)) t))))
            (setq fn a)))
    (list fn m oldE))
   (t
    (setq op (car u))
    (setq env (car (reverse (cdr u))))
    (list (list 'cons  (list '|function| op) env) m oldE)))))

@

\defun{hasFormalMapVariable}{hasFormalMapVariable}
\calls{hasFormalMapVariable}{ScanOrPairVec}
\usesdollar{hasFormalMapVariable}{formalMapVariables}
<<defun hasFormalMapVariable>>=
(defun |hasFormalMapVariable| (x vl)
 (let (|$formalMapVariables|)
 (declare (special |$formalMapVariables|))
 (when (setq |$formalMapVariables| vl)
  (|ScanOrPairVec| #'(lambda (y) (member y |$formalMapVariables|)) x))))

@
\defun{compLambda}{compLambda}
\calls{compLambda}{qcar}
\calls{compLambda}{qcdr}
\calls{compLambda}{argsToSig}
\calls{compLambda}{compAtSign}
\calls{compLambda}{stackAndThrow}
<<defun compLambda>>=
(defun |compLambda| (x m e)
 (let (vl body tmp1 tmp2 tmp3 target args arg1 sig1 ress)
  (setq vl (second x))
  (setq body (third x))
  (cond
   ((and (pairp vl) (eq (qcar vl) '|:|)
         (progn
          (setq tmp1 (qcdr vl))
          (and (pairp tmp1)
               (progn
                (setq args (qcar tmp1))
                (setq tmp2 (qcdr tmp1))
                (and (pairp tmp2)
                     (eq (qcdr tmp2) nil)
                     (progn
                      (setq target (qcar tmp2))
                      t))))))
     (when (and (pairp args) (eq (qcar args) '|@Tuple|))
      (setq args (qcdr args)))       
     (cond
      ((listp args)
       (setq tmp3 (|argsToSig| args))
       (setq arg1 (CAR tmp3))
       (setq sig1 (second tmp3))
       (cond
        (sig1 
         (setq ress
          (|compAtSign|
           (list '@
            (list '+-> arg1 body)
            (cons '|Mapping| (cons target sig1))) m e))
          ress)
        (t (|stackAndThrow| (list '|compLambda| x )))))
      (t (|stackAndThrow| (list '|compLambda| x )))))
    (t (|stackAndThrow| (list '|compLambda| x ))))))

@

\defun{compAtSign}{compAtSign}
\calls{compAtSign}{addDomain}
\calls{compAtSign}{comp}
\calls{compAtSign}{coerce}
<<defun compAtSign>>=
(defun |compAtSign| (arg1 m e)
  (let ((x (second arg1)) (mprime (third arg1)) tmp)
   (setq e (|addDomain| mprime e))
   (when (setq tmp (|comp| x mprime e)) (|coerce| tmp m))))

@

\defun{compWhere}{compWhere}
\calls{compWhere}{comp}
\calls{compWhere}{macroExpand}
\calls{compWhere}{deltaContour}
\calls{compWhere}{addContour}
\usesdollar{compWhere}{insideExpressionIfTrue}
\usesdollar{compWhere}{insideWhereIfTrue}
\usesdollar{compWhere}{EmptyMode}
<<defun compWhere>>=
(defun |compWhere| (arg0 m eInit)
 (let (|$insideExpressionIfTrue| |$insideWhereIfTrue| form exprList e 
       eBefore tmp1 x eAfter del eFinal)
 (declare (special |$insideExpressionIfTrue| |$insideWhereIfTrue|
                   |$EmptyMode|))
  (setq form (second arg0))
  (setq exprlist (cddr arg0))
  (setq |$insideExpressionIfTrue| nil)
  (setq |$insideWhereIfTrue| t)
  (setq e eInit)
  (when (dolist (item exprList t)
          (setq tmp1 (|comp| item |$EmptyMode| e))
          (unless tmp1 (return nil))
          (setq e (third tmp1)))
  (setq |$insideWhereIfTrue| nil)
  (setq tmp1 (|comp| (|macroExpand| form (setq eBefore e)) m e))
  (when tmp1
    (setq x (first tmp1))
    (setq m (second tmp1))
    (setq eAfter (third tmp1))
    (setq del (|deltaContour| eAfter eBefore))
    (if del
      (setq eFinal (|addContour| del eInit))
      (setq eFinal eInit))
    (list x m eFinal)))))

@

\defun{compSeq}{compSeq}
\calls{compSeq}{compSeq1}
\usesdollar{compSeq}{exitModeStack}
<<defun compSeq>>=
(defun |compSeq| (arg0 m e)
 (declare (special |$exitModeStack|))
 (|compSeq1| (cdr arg0) (cons m |$exitModeStack|) e))

@

\defun{compSeq1}{compSeq1}
\calls{compSeq1}{nreverse0}
\calls{compSeq1}{compSeqItem}
\calls{compSeq1}{mkq}
\calls{compSeq1}{replaceExitEtc}
\usesdollar{compSeq1}{exitModeStack}
\usesdollar{compSeq1}{insideExpressionIfTrue}
\usesdollar{compSeq1}{finalEnv}
\usesdollar{compSeq1}{NoValueMode}
<<defun compSeq1>>=
(defun |compSeq1| (l |$exitModeStack| e)
 (declare (special |$exitModeStack|))
 (let (|$insideExpressionIfTrue| |$finalEnv| tmp1 tmp2 c catchTag form)
 (declare (special |$insideExpressionIfTrue| |$finalEnv| |$NoValueMode|))
  (setq |$insideExpressionIfTrue| nil)
  (setq |$finalEnv| nil)
  (when
    (setq c (dolist (x l (nreverse0 tmp2))
             (setq |$insideExpressionIfTrue| nil)
             (setq tmp1 (|compSeqItem| x |$NoValueMode| e))
             (unless tmp1 (return nil))
             (setq e (third tmp1))
             (push (first tmp1) tmp2)))
   (setq catchTag (mkq (gensym)))
   (setq form
    (cons 'seq
     (|replaceExitEtc| c catchTag '|TAGGEDexit| (elt |$exitModeStack| 0))))
   (list (list 'catch catchTag form) (elt |$exitModeStack| 0) |$finalEnv|))))

@

\defun{compSeqItem}{compSeqItem}
\calls{compSeqItem}{comp}
\calls{compSeqItem}{macroExpand}
<<defun compSeqItem>>=
(defun |compSeqItem| (x m e)
  (|comp| (|macroExpand| x e) m e))

@

\defun{argsToSig}{argsToSig}
<<defun argsToSig>>=
(defun |argsToSig| (args)
 (let (tmp1 v tmp2 tt sig1 arg1 bad)
  (cond
   ((and (pairp args) (eq (qcar args) '|:|)
         (progn
          (setq tmp1 (qcdr args))
          (and (pairp tmp1)
               (progn
                (setq v (qcar tmp1))
                (setq tmp2 (qcdr tmp1))
                (and (pairp tmp2)
                     (eq (qcdr tmp2) nil)
                     (progn
                      (setq tt (qcar tmp2))
                      t))))))
    (list (list v) (list tt)))
   (t 
    (setq sig1 nil) 
    (setq arg1 nil)
    (setq bad nil)
    (dolist (arg args)
      (cond
       ((and (pairp arg) (eq (qcar arg) '|:|)
             (progn
              (setq tmp1 (qcdr arg))
              (and (pairp tmp1)
                   (progn
                    (setq v (qcar tmp1))
                    (setq tmp2 (qcdr tmp1))
                    (and (pairp tmp2) (eq (qcdr tmp2) nil)
                         (progn
                          (setq tt (qcar tmp2))
                          t))))))
         (setq sig1 (cons tt sig1))
         (setq arg1 (cons v arg1)))
        (t (setq bad t))))
    (cond
     (bad (list nil nil ))
     (t (list (reverse arg1) (reverse sig1))))))))

@

\defun{compMakeDeclaration}{compMakeDeclaration}
\calls{compMakeDeclaration}{compColon}
\usesdollar{compMakeDeclaration}{insideExpressionIfTrue}
<<defun compMakeDeclaration>>=
(defun |compMakeDeclaration| (x m e)
 (let (|$insideExpressionIfTrue|)
 (declare (special |$insideExpressionIfTrue|))
  (setq |$insideExpressionIfTrue| nil)
  (|compColon| x m e)))

@

\defun{compExit}{compExit}
\calls{compExit}{comp}
\calls{compExit}{modifyModeStack}
\calls{compExit}{stackMessageIfNone}
\usesdollar{compExit}{exitModeStack}
<<defun compExit>>=
(defun |compExit| (arg0 m e)
 (let (x index m1 u)
 (declare (special |$exitModeStack|))
  (setq index (1- (second arg0)))
  (setq x (third arg0))
  (cond
   ((null |$exitModeStack|)
    (|comp| x m e))
   (t
    (setq m1 (elt |$exitModeStack| index))
    (setq u (|comp| x m1 e))
    (cond
     (u
      (|modifyModeStack| (second u) index)
      (list (list '|TAGGEDexit| index u) m e))
     (t
       (|stackMessageIfNone|
        (list '|cannot compile exit expression| x '|in mode| m1))))))))

@
\defun{modifyModeStack}{modifyModeStack}
\calls{modifyModeStack}{say}
\calls{modifyModeStack}{copy}
\calls{modifyModeStack}{setelt}
\calls{modifyModeStack}{resolve}
\usesdollar{modifyModeStack}{reportExitModeStack}
\usesdollar{modifyModeStack}{exitModeStack}
<<defun modifyModeStack>>=
(defun |modifyModeStack| (|m| |index|)
 (declare (special |$exitModeStack| |$reportExitModeStack|))
 (if |$reportExitModeStack|
   (say "exitModeStack: " (copy |$exitModeStack|)
    " ====> "
    (progn
     (setelt |$exitModeStack| |index|
      (|resolve| |m| (elt |$exitModeStack| |index|)))
     |$exitModeStack|))
   (setelt |$exitModeStack| |index|
      (|resolve| |m| (elt |$exitModeStack| |index|)))))

@

\defun{freelist}{Create a list of unbound symbols}
We walk argument u looking for symbols that are unbound. If we find a
symbol we add it to the free list. If it occurs in a prog then it is
bound and we remove it from the free list. Multiple instances of a single
symbol in the free list are represented by the alist (symbol . count)
\calls{freelist}{freelist}
\calls{freelist}{assq}
\calls{freelist}{identp}
\calls{freelist}{getmode}
\calls{freelist}{unionq}
<<defun freelist>>=
(defun freelist (u bound free e)
 (let (v op)
  (if (atom u)
   (cond
    ((null (identp u)) free)
    ((member u bound) free)
    ; more than 1 free becomes alist (name . number)
    ((setq v (assq u free)) (rplacd v (+ 1 (cdr v))) free)
    ((null (|getmode| u e)) free)
    (t (cons (cons u 1) free)))
   (progn
    (setq op (car u))
    (cond
     ((member op '(quote go |function|)) free)
     ((eq op 'lambda) ; lambdas bind symbols
      (setq bound (unionq bound (second u)))
      (dolist (v (cddr u))
       (setq free (freelist v bound free e))))
     ((eq op 'prog) ; progs bind symbols
      (setq bound (unionq bound (second u)))
      (dolist (v (cddr u))
       (unless (atom v)
        (setq free (freelist v bound free e)))))
     ((eq op 'seq)
      (dolist (v (cdr u))
       (unless (atom v)
        (setq free (freelist v bound free e)))))
     ((eq op 'cond)
      (dolist (v (cdr u))
       (dolist (vv v)
        (setq free (freelist vv bound free e)))))
     (t
      (when (atom op) (setq u (cdr u))) ; atomic functions aren't descended
      (dolist (v u)
       (setq free (freelist v bound free e)))))
    free))))

@

\defun{compOrCroak1,compactify}{compOrCroak1,compactify}
\calls{compOrCroak1,compactify}{compOrCroak1,compactify}
\calls{compOrCroak1,compactify}{lassoc}
<<defun compOrCroak1,compactify>>=
(defun |compOrCroak1,compactify| (al)
 (cond
  ((null al) nil)
  ((lassoc (caar al) (cdr al)) (|compOrCroak1,compactify| (cdr al)))
  (t (cons (car al) (|compOrCroak1,compactify| (cdr al))))))

@

\defun{ncINTERPFILE}{Compiler/Interpreter interface}
\calls{ncINTERPFILE}{SpadInterpretStream(5)}
\usesdollar{ncINTERPFILE}{EchoLines}
\usesdollar{ncINTERPFILE}{ReadingFile}
<<defun ncINTERPFILE>>=
(defun |ncINTERPFILE| (file echo)
 (let ((|$EchoLines| echo) (|$ReadingFile| t))
 (declare (special |$EchoLines| |$ReadingFile|))
  (|SpadInterpretStream| 1 file nil)))

@

\defun{compileSpadLispCmd}{compileSpadLispCmd}
\calls{compileSpadLispCmd}{pathname(5)}
\calls{compileSpadLispCmd}{pathnameType(5)}
\calls{compileSpadLispCmd}{selectOptionLC(5)}
\calls{compileSpadLispCmd}{namestring(5)}
\calls{compileSpadLispCmd}{terminateSystemCommand(5)}
\calls{compileSpadLispCmd}{fnameMake(5)}
\calls{compileSpadLispCmd}{pathnameDirectory(5)}
\calls{compileSpadLispCmd}{pathnameName(5)}
\calls{compileSpadLispCmd}{fnameReadable?(5)}
\calls{compileSpadLispCmd}{localdatabase(5)}
\calls{compileSpadLispCmd}{throwKeyedMsg}
\calls{compileSpadLispCmd}{object2String}
\calls{compileSpadLispCmd}{sayKeyedMsg}
\calls{compileSpadLispCmd}{recompile-lib-file-if-necessary}
\calls{compileSpadLispCmd}{spadPrompt}
\usesdollar{compileSpadLispCmd}{options}
<<defun compileSpadLispCmd>>=
(defun |compileSpadLispCmd| (args)
 (let (path optlist optname optargs beQuiet dolibrary lsp)
  (declare (special |$options|))
  (setq path (|pathname| (|fnameMake| (car args) "code" "lsp")))
  (cond
   ((null (probe-file path))
     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
   (t
    (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
    (setq beQuiet nil)
    (setq dolibrary t)
    (dolist (opt |$options|)
      (setq optname (car opt))
      (setq optargs (cdr opt))
      (case (|selectOptionLC| optname optlist nil)
         (|quiet|     (setq beQuiet t))
         (|noquiet|   (setq beQuiet nil))
         (|library|   (setq dolibrary t))
         (|nolibrary| (setq dolibrary nil))
         (t
          (|throwKeyedMsg| 's2iz0036
           (list (strconc ")" (|object2String| optname)))))))
    (setq lsp
     (|fnameMake|
      (|pathnameDirectory| path)
      (|pathnameName| path)
      (|pathnameType| path)))
    (cond
     ((|fnameReadable?| lsp)
      (unless beQuiet (|sayKeyedMsg| 's2iz0089 (list (|namestring| lsp))))
       (recompile-lib-file-if-necessary lsp))
     (t
      (|sayKeyedMsg| 's2il0003 (list (|namestring| lsp)))))
    (cond
     (dolibrary
      (unless beQuiet (|sayKeyedMsg| 's2iz0090 (list (|pathnameName| path))))
      (localdatabase (list (|pathnameName| (car args))) nil))
     ((null beQuiet) (|sayKeyedMsg| 's2iz0084 nil))
     (t nil))
    (|terminateSystemCommand|)
    (|spadPrompt|)))))

@

\defun{recompile-lib-file-if-necessary}{recompile-lib-file-if-necessary}
\calls{recompile-lib-file-if-necessary}{compile-lib-file}
\uses{recompile-lib-file-if-necessary}{*lisp-bin-filetype*}
<<defun recompile-lib-file-if-necessary>>=
(defun recompile-lib-file-if-necessary (lfile)
 (let* ((bfile (make-pathname :type *lisp-bin-filetype* :defaults lfile))
        (bdate (and (probe-file bfile) (file-write-date bfile)))
        (ldate (and (probe-file lfile) (file-write-date lfile))))
  (unless (and ldate bdate (> bdate ldate))
   (compile-lib-file lfile)
   (list bfile))))

@

\defun{spad-fixed-arg}{spad-fixed-arg}
<<defun spad-fixed-arg>>=
(defun spad-fixed-arg (fname )
 (and (equal (symbol-package fname) (find-package "BOOT"))
      (not (get fname 'compiler::spad-var-arg))
      (search ";" (symbol-name fname))
      (or (get fname 'compiler::fixed-args)
          (setf (get fname 'compiler::fixed-args) t)))
   nil)

@

\defun{compile-lib-file}{compile-lib-file}
<<defun compile-lib-file>>=
(defun compile-lib-file (fn &rest opts)
 (unwind-protect
  (progn
   (trace (compiler::fast-link-proclaimed-type-p
           :exitcond nil
           :entrycond (spad-fixed-arg (car system::arglist))))
   (trace (compiler::t1defun 
           :exitcond nil
           :entrycond (spad-fixed-arg (caar system::arglist))))
   (apply #'compile-file fn opts))
  (untrace compiler::fast-link-proclaimed-type-p compiler::t1defun)))

@

\defun{compileFileQuietly}{compileFileQuietly}
if \verb|$InteractiveMode| then use a null outputstream 
\usesdollar{compileFileQuietly}{InteractiveMode}
\uses{compileFileQuietly}{*standard-output*}
<<defun compileFileQuietly>>=
(defun |compileFileQuietly| (fn) 
  (let (
         (*standard-output*
         (if |$InteractiveMode| (make-broadcast-stream)
           *standard-output*)))
  (declare (special *standard-output* |$InteractiveMode|))
  (compile-file fn)))

@
\defdollar{byConstructors}
<<initvars>>=
(defvar |$byConstructors| () "list of constructors to be compiled")

@
\defdollar{constructorsSeen}
<<initvars>>=
(defvar |$constructorsSeen| () "list of constructors found")

@

<<Compiler>>=
(in-package "BOOT")

<<initvars>>

<<defun add-parens-and-semis-to-line>>
<<defun argsToSig>>

<<defun comp>>
<<defun comp2>>
<<defun comp3>>
<<defun compArgumentsAndTryAgain>>
<<defun compAtom>>
<<defun compAtSign>>
<<defun compColon>>
<<defun compColonInside>>
<<defun compExit>>
<<defun compExpression>>
<<defun compForm>>
<<defun compForm1>>
<<defun compForm2>>
<<defun compLambda>>
<<defun compileFileQuietly>>
<<defun compile-lib-file>>
<<defun compiler>>
<<defun compilerDoit>>
<<defun compileSpad2Cmd>>
<<defun compileSpadLispCmd>>
<<defun compList>>
<<defun compMakeDeclaration>>
<<defun compNoStacking>>
<<defun compNoStacking1>>
<<defun compOrCroak>>
<<defun compOrCroak1>>
<<defun compOrCroak1,compactify>>
<<defun compSeq>>
<<defun compSeqItem>>
<<defun compSeq1>>
<<defun compSymbol>>
<<defun compTopLevel>>
<<defun compTypeOf>>
<<defun compVector>>
<<defun compWhere>>
<<defun compWithMappingMode>>
<<defun compWithMappingMode1>>
<<defun convert>>

<<defun extractCodeAndConstructTriple>>

<<defun freelist>>

<<defun get-a-line>>

<<defun hasFormalMapVariable>>

<<defun initialize-preparse>>
<<defun initial-substring>>

<<defun make-string-adjustable>>
<<defun modifyModeStack>>

<<defun ncINTERPFILE>>

<<defun parsepiles>>
<<defun postAtom>>
<<defun postScriptsForm>>
<<defun postTran>>
<<defun postTranList>>
<<defun postTransform>>
<<defun preparse>>
<<defun preparse1>>
<<defun preparse-echo>>
<<defun preparseReadLine>>
<<defun preparseReadLine1>>
<<defun primitiveType>>

<<defun read-a-line>>
<<defun recompile-lib-file-if-necessary>>
<<defun /rf-1>>
<<defun /RQ,LIB>>

<<defun spad>>
<<defun spad-fixed-arg>>
<<defun storeblanks>>
<<defun s-process>>

@
\eject
\begin{thebibliography}{99}
\bibitem{1} Jenks, R.J. and Sutor, R.S. 
``Axiom -- The Scientific Computation System''
Springer-Verlag New York (1992)
ISBN 0-387-97855-0
\bibitem{2} Knuth, Donald E., ``Literate Programming''
Center for the Study of Language and Information
ISBN 0-937073-81-4
Stanford CA (1992) 
\bibitem{3} Daly, Timothy, ``The Axiom Wiki Website''\\
{\bf http://axiom.axiom-developer.org}
\bibitem{4} Watt, Stephen, ``Aldor'',\\
{\bf http://www.aldor.org}
\bibitem{5} Lamport, Leslie, ``Latex -- A Document Preparation System'',
Addison-Wesley, New York ISBN 0-201-52983-1
\bibitem{6} Ramsey, Norman ``Noweb -- A Simple, Extensible Tool for
Literate Programming''\\
{\bf http://www.eecs.harvard.edu/ $\tilde{}$nr/noweb}
\bibitem{7} Daly, Timothy, "The Axiom Literate Documentation"\\
{\bf http://axiom.axiom-developer.org/axiom-website/documentation.html}
\end{thebibliography}
\chapter{Index}
\printindex
\end{document}
