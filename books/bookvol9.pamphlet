\documentclass[dvipdfm]{book}
\usepackage{hyperref}
\usepackage{axiom}
\usepackage{makeidx}
\makeindex
\usepackage{graphicx}
\begin{document}
\begin{titlepage}
\center{\includegraphics{ps/axiomfront.ps}}
\vskip 0.1in
\includegraphics{ps/bluebayou.ps}\\
\vskip 0.1in
{\Huge{The 30 Year Horizon}}
\vskip 0.1in
$$
\begin{array}{lll}
Manuel\ Bronstein      & William\ Burge   & Timothy\ Daly \\
James\ Davenport       & Michael\ Dewar   & Martin\ Dunstan \\
Albrecht\ Fortenbacher & Patrizia\ Gianni & Johannes\ Grabmeier \\
Jocelyn\ Guidry        & Richard\ Jenks   & Larry\ Lambe \\
Michael\ Monagan       & Scott\ Morrison  & William\ Sit \\
Jonathan\ Steinbach    & Robert\ Sutor    & Barry\ Trager \\
Stephen\ Watt          & Jim\ Wen         & Clifton\ Williamson
\end{array}
$$
\center{\large{Volume 9: Axiom Compiler}}
\end{titlepage}
\pagenumbering{roman}
\begin{verbatim}
Portions Copyright (c) 2005 Timothy Daly

The Blue Bayou image Copyright (c) 2004 Jocelyn Guidry

Portions Copyright (c) 2004 Martin Dunstan

Portions Copyright (c) 1991-2002, 
The Numerical ALgorithms Group Ltd.
All rights reserved.

This book and the Axiom software is licensed as follows:

Redistribution and use in source and binary forms, with or 
without modification, are permitted provided that the following 
conditions are
met:

    - Redistributions of source code must retain the above 
      copyright notice, this list of conditions and the 
      following disclaimer.

    - Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the 
      following disclaimer in the documentation and/or other 
      materials provided with the distribution.

    - Neither the name of The Numerical ALgorithms Group Ltd. 
      nor the names of its contributors may be used to endorse 
      or promote products derived from this software without 
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.

\end{verbatim}

Inclusion of names in the list of credits is based on historical
information and is as accurate as possible. Inclusion of names
does not in any way imply an endorsement but represents historical
influence on Axiom development.
\vfill
\eject
\begin{tabular}{lll}
Cyril Alberga         & Roy Adler             & Richard Anderson\\
George Andrews        & Henry Baker           & Stephen Balzac\\
Yurij Baransky        & David R. Barton       & Gerald Baumgartner\\
Gilbert Baumslag      & Fred Blair            & Vladimir Bondarenko\\
Mark Botch            & Alexandre Bouyer      & Peter A. Broadbery\\
Martin Brock          & Manuel Bronstein      & Florian Bundschuh\\
William Burge         & Quentin Carpent       & Bob Caviness\\
Bruce Char            & Cheekai Chin          & David V. Chudnovsky\\
Gregory V. Chudnovsky & Josh Cohen            & Christophe Conil\\
Don Coppersmith       & George Corliss        & Robert Corless\\
Gary Cornell          & Meino Cramer          & Claire Di Crescenzo\\
Timothy Daly Sr.      & Timothy Daly Jr.      & James H. Davenport\\
Jean Della Dora       & Gabriel Dos Reis      & Michael Dewar\\
Claire DiCrescendo    & Sam Dooley            & Lionel Ducos\\
Martin Dunstan        & Brian Dupee           & Dominique Duval\\
Robert Edwards        & Heow Eide-Goodman     & Lars Erickson\\
Richard Fateman       & Bertfried Fauser      & Stuart Feldman\\
Brian Ford            & Albrecht Fortenbacher & George Frances\\
Constantine Frangos   & Timothy Freeman       & Korrinn Fu\\
Marc Gaetano          & Rudiger Gebauer       & Kathy Gerber\\
Patricia Gianni       & Holger Gollan         & Teresa Gomez-Diaz\\
Laureano Gonzalez-Vega& Stephen Gortler       & Johannes Grabmeier\\
Matt Grayson          & James Griesmer        & Vladimir Grinberg\\
Oswald Gschnitzer     & Jocelyn Guidry        & Steve Hague\\
Vilya Harvey          & Satoshi Hamaguchi     & Martin Hassner\\
Ralf Hemmecke         & Henderson             & Antoine Hersen\\
Pietro Iglio          & Richard Jenks         & Kai Kaminski\\
Grant Keady           & Tony Kennedy          & Paul Kosinski\\
Klaus Kusche          & Bernhard Kutzler      & Larry Lambe\\
Frederic Lehobey      & Michel Levaud         & Howard Levy\\
Rudiger Loos          & Michael Lucks         & Richard Luczak\\
Camm Maguire          & Bob McElrath          & Michael McGettrick\\
Ian Meikle            & David Mentre          & Victor S. Miller\\
Gerard Milmeister     & Mohammed Mobarak      & H. Michael Moeller\\
Michael Monagan       & Marc Moreno-Maza      & Scott Morrison\\
Mark Murray           & William Naylor        & C. Andrew Neff\\
John Nelder           & Godfrey Nolan         & Arthur Norman\\
Jinzhong Niu          & Michael O'Connor      & Kostas Oikonomou\\
Julian A. Padget      & Bill Page             & Jaap Weel\\
Susan Pelzel          & Michel Petitot        & Didier Pinchon\\
Claude Quitte         & Norman Ramsey         & Michael Richardson\\
Renaud Rioboo         & Jean Rivlin           & Nicolas Robidoux\\
Simon Robinson        & Michael Rothstein     & Martin Rubey\\
Philip Santas         & Alfred Scheerhorn     & William Schelter\\
Gerhard Schneider     & Martin Schoenert      & Marshall Schor\\
Fritz Schwarz         & Nick Simicich         & William Sit\\
Elena Smirnova        & Jonathan Steinbach    & Christine Sundaresan\\
Robert Sutor          & Moss E. Sweedler      & Eugene Surowitz\\
James Thatcher        & Baldir Thomas         & Mike Thomas\\
Dylan Thurston        & Barry Trager          & Themos T. Tsikas\\
Gregory Vanuxem       & Bernhard Wall         & Stephen Watt\\
Juergen Weiss         & M. Weller             & Mark Wegman\\
James Wen             & Thorsten Werther      & Michael Wester\\
John M. Wiley         & Berhard Will          & Clifton J. Williamson\\
Stephen Wilson        & Shmuel Winograd       & Robert Wisbauer\\
Sandra Wityak         & Waldemar Wiwianka     & Knut Wolf\\
Clifford Yapp         & David Yun             & Richard Zippel\\
Evelyn Zoernack       & Bruno Zuercher        & Dan Zwillinger 
\end{tabular}
\eject
\tableofcontents
\vfill
\eject
\setlength{\parindent}{0em}
\setlength{\parskip}{1ex}
{\Large{\bf New Foreword}}
\vskip .25in

On October 1, 2001 Axiom was withdrawn from the market and ended
life as a commercial product.
On September 3, 2002 Axiom was released under the Modified BSD
license, including this document.
On August 27, 2003 Axiom was released as free and open source
software available for download from the Free Software Foundation's
website, Savannah.

Work on Axiom has had the generous support of the Center for 
Algorithms and Interactive Scientific Computation (CAISS) at
City College of New York. Special thanks go to Dr. Gilbert 
Baumslag for his support of the long term goal.

The online version of this documentation is roughly 1000 pages.
In order to make printed versions we've broken it up into three
volumes. The first volume is tutorial in nature. The second volume
is for programmers. The third volume is reference material. We've
also added a fourth volume for developers. All of these changes
represent an experiment in print-on-demand delivery of documentation.
Time will tell whether the experiment succeeded.

Axiom has been in existence for over thirty years. It is estimated to
contain about three hundred man-years of research and has, as of
September 3, 2003, 143 people listed in the credits. All of these
people have contributed directly or indirectly to making Axiom
available.  Axiom is being passed to the next generation. I'm looking
forward to future milestones.

With that in mind I've introduced the theme of the ``30 year horizon''.
We must invent the tools that support the Computational Mathematician
working 30 years from now. How will research be done when every bit of
mathematical knowledge is online and instantly available? What happens
when we scale Axiom by a factor of 100, giving us 1.1 million domains?
How can we integrate theory with code? How will we integrate theorems
and proofs of the mathematics with space-time complexity proofs and
running code? What visualization tools are needed? How do we support
the conceptual structures and semantics of mathematics in effective
ways? How do we support results from the sciences? How do we teach
the next generation to be effective Computational Mathematicians?

The ``30 year horizon'' is much nearer than it appears.

\vskip .25in
%\noindent
Tim Daly\\
CAISS, City College of New York\\
November 10, 2003 ((iHy))
\vfill
\eject
\pagenumbering{arabic}
\setcounter{chapter}{0} % Chapter 1
\section{Makefile}
This book is actually a literate program\cite{2} and can contain 
executable source code. In particular, the Makefile for this book
is part of the source of the book and is included below. Axiom 
uses the ``noweb'' literate programming system by Norman Ramsey\cite{6}.
\chapter{Compiler top level}
\section{)compile}
This is the implementation of the )compile command.

You use this command to invoke the new Axiom library compiler or the
old Axiom system compiler.  The {\tt )compile} system command is
actually a combination of Axiom processing and a call to the Aldor
compiler.  It is performing double-duty, acting as a front-end to both
the Aldor compiler and the old Axiom system compiler.  (The old Axiom
system compiler was written in Lisp and was an integral part of the
Axiom environment.  The Aldor compiler is written in C and executed by
the operating system when called from within Axiom.)

\par\noindent{\bf User Level Required:} compiler

\par\noindent{\bf Command Syntax:}

\begin{list}{}
\item {\tt )compile}
\item {\tt )compile {\it fileName}}
\item {\tt )compile {\it fileName}.spad}
\item {\tt )compile {\it directory/fileName}.spad}
\item {\tt )compile {\it fileName} )old}
\item {\tt )compile {\it fileName} )translate}
\item {\tt )compile {\it fileName} )quiet}
\item {\tt )compile {\it fileName} )noquiet}
\item {\tt )compile {\it fileName} )moreargs}
\item {\tt )compile {\it fileName} )onlyargs}
\item {\tt )compile {\it fileName} )break}
\item {\tt )compile {\it fileName} )nobreak}
\item {\tt )compile {\it fileName} )library}
\item {\tt )compile {\it fileName} )nolibrary}
\item {\tt )compile {\it fileName} )vartrace}
\item {\tt )compile {\it fileName} )constructor} {\it nameOrAbbrev}
\end{list}

These command forms invoke the Aldor compiler.
\begin{list}{}
\item {\tt )compile {\it fileName}.as}
\item {\tt )compile {\it directory/fileName}.as}
\item {\tt )compile {\it fileName}.ao}
\item {\tt )compile {\it directory/fileName}.ao}
\item {\tt )compile {\it fileName}.al}
\item {\tt )compile {\it directory/fileName}.al}
\item {\tt )compile {\it fileName}.lsp}
\item {\tt )compile {\it directory/fileName}.lsp}
\item {\tt )compile {\it fileName} )new}
\end{list}

\par\noindent{\bf Command Description:}

The first thing {\tt )compile} does is look for a source code
filename among its arguments.
Thus
\begin{verbatim}
)compile mycode.spad
)compile /u/jones/mycode.spad
)compile mycode
\end{verbatim}
all invoke {\tt )compiler} on the file {\tt
/u/jones/mycode.spad} if the current Axiom working
directory is {\tt /u/jones.} (Recall that you can set the
working directory via the {\tt )cd} command. If you don't set it
explicitly, it is the directory from which you started
Axiom.)

If you omit the file extension, the command looks to see if you have
specified the {\tt )new} or {\tt )old} option.  If you have given one
of these options, the corresponding compiler is used.

The command first looks in the standard system directories for files
with extension {\it .as, .ao} and {\it .al} and then files with
extension {\it .spad}.  The first file found has the appropriate
compiler invoked on it.  If the command cannot find a matching file,
an error message is displayed and the command terminates.

The first thing {\tt )compile} does is look for a source code
filename among its arguments.
Thus
\begin{verbatim}
)compile mycode
)co mycode
)co mycode.spad
\end{verbatim}
all invoke {\tt )compiler} on the file {\tt
/u/jones/mycode.spad} if the current Axiom working
directory is {\tt /u/jones.} Recall that you can set the
working directory via the {\tt )cd} command. If you don't set it
explicitly, it is the directory from which you started
Axiom.

This is frequently all you need to compile your file.

This simple command:
\begin{enumerate}
\item Invokes the Spad compiler and produces Lisp output.
\item Calls the Lisp compiler if the compilation was successful.
\item Uses the {\tt )library} command to tell Axiom about
the contents of your compiled file and arrange to have those
contents loaded on demand.
\end{enumerate}

Should you not want the {\tt )library} command automatically
invoked, call {\tt )compile} with the {\tt )nolibrary} option.
For example,
\begin{verbatim}
)compile mycode )nolibrary
\end{verbatim}

By default, the {\tt )library} system command {\it exposes} all
domains and categories it processes.
This means that the Axiom intepreter will consider those domains and 
categories when it is trying to resolve a reference to a function.
Sometimes domains and categories should not be exposed.
For example, a domain may just be used privately by another
domain and may not be meant for top-level use.
The {\tt )library} command should still be used, though, so that
the code will be loaded on demand.
In this case, you should use the {\tt )nolibrary} option on {\tt
)compile} and the {\tt )noexpose} option in the {\tt )library}
command. For example,
\begin{verbatim}
)compile mycode )nolibrary
)library mycode )noexpose
\end{verbatim}

Once you have established your own collection of compiled code,
you may find it handy to use the {\tt )dir} option on the
{\tt )library} command.
This causes {\tt )library} to process all compiled code in the
specified directory. For example,
\begin{verbatim}
)library )dir /u/jones/quantum
\end{verbatim}
You must give an explicit directory after {\tt )dir}, even if you
want all compiled code in the current working directory
processed, e.g.
\begin{verbatim}
)library )dir .
\end{verbatim}

\subsection{Spad compiler}
This command compiles files with file extension {\tt .spad}
with the Spad system compiler.  

The {\tt )translate} option is used to invoke a special version of the
old system compiler that will translate a {\it .spad} file to a {\it
.as} file.  That is, the {\it .spad} file will be parsed and analyzed
and a file using the new syntax will be created.

By default, the {\it .as} file is created in the same directory as the
{\it .spad} file. If that directory is not writable, the current
directory is used. If the current directory is not writable, an error
message is given and the command terminates.  Note that {\tt )translate} 
implies the {\tt )old} option so the file extension can
safely be omitted. If {\tt )translate} is given, all other options are
ignored.  Please be aware that the translation is not necessarily one
hundred percent complete or correct.  You should attempt to compile
the output with the Aldor compiler and make any necessary corrections.

You can compile category, domain, and package constructors contained
in files with file extension {\it .spad}.  You can compile individual
constructors or every constructor in a file.

The full filename is remembered between invocations of this command and
{\tt )edit} commands. The sequence of commands
\begin{verbatim}
)compile matrix.spad
)edit
)compile
\end{verbatim}
will call the compiler, edit, and then call the compiler again on the
file {\bf matrix.spad.}  If you do not specify a {\it directory,} the
working current directory is searched for the file.  If the file is
not found, the standard system directories are searched.

If you do not give any options, all constructors within a file are
compiled.  Each constructor should have an {\tt )abbreviation} command
in the file in which it is defined.  We suggest that you place the
{\tt )abbreviation} commands at the top of the file in the order in
which the constructors are defined.

The {\tt )library} option causes directories containing the compiled
code for each constructor to be created in the working current
directory.  The name of such a directory consists of the constructor
abbreviation and the {\bf .nrlib} file extension.  For example, the
directory containing the compiled code for the {\tt MATRIX}
constructor is called {\bf MATRIX.nrlib.}  The {\tt )nolibrary} option
says that such files should not be created.  The default is 
{\tt )library.}  Note that the semantics of {\tt )library} and 
{\tt )nolibrary} for the new Aldor compiler and for the old system 
compiler are completely different.

The {\tt )vartrace} option causes the compiler to generate
extra code for the constructor to support conditional tracing of
variable assignments. (see 
\ref{ugSysCmdtrace} on page~\pageref{ugSysCmdtrace}). Without
this option, this code is suppressed and one cannot use
the {\tt )vars} option for the trace command.

The {\tt )constructor} option is used to
specify a particular constructor to compile.
All other constructors in the file are ignored.
The constructor name or abbreviation follows {\tt )constructor.}
Thus either
\begin{verbatim}
)compile matrix.spad )constructor RectangularMatrix
\end{verbatim}
or
\begin{verbatim}
)compile matrix.spad )constructor RMATRIX
\end{verbatim}
compiles  the {\tt RectangularMatrix} constructor
defined in {\bf matrix.spad.}

The {\tt )break} and {\tt )nobreak} options determine what
the spad compiler does when it encounters an error.
{\tt )break} is the default and it indicates that processing
should stop at the first error.
The value of the {\tt )set break} variable then controls what happens.

Given the top level command:
\begin{verbatim}
)co PR
\end{verbatim}
The default call chain looks like:
\begin{verbatim}
  1> (|compiler| (PR))
    2> (|compileSpad2Cmd| ("/research/test/int/algebra/PR.spad"))
      3> (|compilerDoit| NIL (|rq| |lib|))
        4> (/RF-1 NIL)
          5> (SPAD "/research/test/int/algebra/PR.spad")
            6> (S-PROCESS (|where| ...
              7> (|compTopLevel| (|where| (DEF ...
                8> (|compOrCroak| (|where| (DEF ...
                  9> (|compOrCroak| (CATEGORY |domain| ...
                  <9 (|compOrCroak| ((|DomainSubstitutionMacro| # #) ...
...
                    10> (|compOrCroak| (|FreeModule| R E) |$EmptyMode| ((#)))
                    <10 (|compOrCroak| ((|FreeModule| R E) (|Join| # # #) (#)))
...
                    11> (|compOrCroak| (|construct| (|construct| # #)) $ ((#)))
                    <11 (|compOrCroak| ((LIST #) $ (#)))
...
                  <9 (|compOrCroak| ((PROGN ... $) #1=(|Join| # #) (#)))
                <8 (|compOrCroak| (|PolynomialRing| (|Mapping| ...
              <7 (|compTopLevel| (|PolynomialRing| ...
            <6 (S-PROCESS NIL)
          <5 (SPAD T)
        <4 (/RF-1 T)
      <3 (|compilerDoit| T)
(1) -> 
\end{verbatim}

\subsection{Aldor compiler}
This command compiles files with file extensions {\it .as, .ao} and
{\it .al} with the Aldor compiler. It also can compile files
with file extension {\it .lsp}. These are assumed to be Lisp files
genererated by the Aldor compiler.  

The general description of Aldor command line arguments is in
the Aldor documentation.
The default options used by the {\tt )compile} command can be
viewed and set using the {\tt )set compiler args} Axiom
system command.
The current defaults are
\begin{verbatim}
-O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom
\end{verbatim}
These options mean:
\begin{itemize}
\item {\tt -O}: perform all optimizations,
\item {\tt -Fasy}: generate a {\tt .asy} file,
\item {\tt -Fao}: generate a {\tt .ao} file,
\item {\tt -Flsp}: generate a {\tt .lsp} (Lisp) file,
\item {\tt -laxiom}: use the {\tt axiom} library {\tt libaxiom.al},
\item {\tt -Mno-AXL\_W\_WillObsolete}: do not display messages
about older generated files becoming obsolete, and
\item {\tt -DAxiom}: define the global assertion {\tt Axiom} so that the
Aldor libraries for generating stand-alone code
are not accidentally used with Axiom.
\end{itemize}

To supplement these default arguments, use the {\tt )moreargs} option on
{\tt )compile.}
For example,
\begin{verbatim}
)compile mycode.as )moreargs "-v"
\end{verbatim}
uses the default arguments and appends the {\tt -v} (verbose)
argument flag.
The additional argument specification {\bf must be enclosed in
double quotes.}

To completely replace these default arguments for a particular
use of {\tt )compile}, use the {\tt )onlyargs} option.
For example,
\begin{verbatim}
)compile mycode.as )onlyargs "-v -O"
\end{verbatim}
only uses the {\tt -v} (verbose) and {\tt -O} (optimize)
arguments.
The argument specification {\bf must be enclosed in double quotes.}
In this example, Lisp code is not produced and so the compilation
output will not be available to Axiom.

To completely replace the default arguments for all calls to {\tt
)compile} within your Axiom session, use {\tt )set compiler args.}
For example, to use the above arguments for all compilations, issue
\begin{verbatim}
)set compiler args "-v -O"
\end{verbatim}
Make sure you include the necessary {\tt -l} and {\tt -Y}
arguments along with those needed for Lisp file creation.
As above, {\bf the argument specification must be enclosed in double
quotes.}

The {\tt )compile} command works with several file extensions. We saw
above what happens when it is invoked on a file with extension {\tt
.as.} A {\tt .ao} file is a portable binary compiled version of a
{\tt .as} file, and {\tt )compile} simply passes the {\tt .ao} file
onto Aldor. The generated Lisp file is compiled and {\tt )library}
is automatically called, just as if you had specified a {\tt .as} file.

A {\tt .al} file is an archive file containing {\tt .ao} files. The
archive is created (on Unix systems) with the {\tt ar} program. When
{\tt )compile} is given a {\tt .al} file, it creates a directory whose
name is based on that of the archive. For example, if you issue
\begin{verbatim}
)compile mylib.al
\end{verbatim}
the directory {\tt mylib.axldir} is created. All members of the
archive are unarchived into the directory and {\tt )compile} is called
on each {\tt .ao} file found. It is your responsibility to remove the
directory and its contents, if you choose to do so.

A {\tt .lsp} file is a Lisp source file, generated by Aldor
when called with the {\tt -Flsp} option. When {\tt )compile} is used
with a {\tt .lsp} file, the Lisp file is compiled and {\tt )library}
is called. For Aldor, You must also have present a {\tt .asy}
generated from the same source file.

\defunsec{compiler}{The top level compiler command}
\calls{compiler}{helpSpad2Cmd(5)}
\calls{compiler}{selectOptionLC(5)}
\calls{compiler}{pathname(5)}
\calls{compiler}{mergePathnames(5)}
\calls{compiler}{pathnameType(5)}
\calls{compiler}{namestring(5)}
\calls{compiler}{throwKeyedMsg}
\calls{compiler}{findfile}
\calls{compiler}{compileSpad2Cmd}
\calls{compiler}{compileAsharpLispCmd}
\calls{compiler}{compileSpadLispCmd}
\calls{compiler}{compileAsharpCmd}
\calls{compiler}{compileAsharpArchiveCmd}
\usesdollar{compiler}{newConlist}
\usesdollar{compiler}{options}
\uses{compiler}{/editfile}
<<defun compiler>>=
(defun |compiler| (args)
 "The top level compiler command"
 (let (|$newConlist| optlist optname optargs havenew haveold aft ef af af1)
  (declare (special |$newConlist| |$options| /editfile))
  (setq |$newConlist| nil)
  (cond
   ((and (null args) (null |$options|) (null /editfile))
     (|helpSpad2Cmd| '(|compiler|)))
   (t
    (cond ((null args) (setq args (cons /editfile nil))))
    (setq optlist '(|new| |old| |translate| |constructor|))
    (setq havenew nil)
    (setq haveold nil)
    (do ((t0 |$options| (cdr t0)) (opt nil))
        ((or (atom t0) 
             (progn (setq opt (car t0)) nil)
             (null (null (and havenew haveold))))
          nil)
     (setq optname (car opt))
     (setq optargs (cdr opt))
     (case (|selectOptionLC| optname optlist nil)
      (|new|         (setq havenew t))
      (|translate|   (setq haveold t))
      (|constructor| (setq haveold t))
      (|old|         (setq haveold t))))
    (cond
     ((and havenew haveold) (|throwKeyedMsg| 's2iz0081 nil))
     (t
      (setq af (|pathname| args))
      (setq aft (|pathnameType| af))
      (cond
       ((or havenew (string= aft "as"))
        (if (null (setq af1 ($findfile af '(|as|))))
          (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
          (|compileAsharpCmd| (cons af1 nil))))
       ((or haveold (string= aft "spad"))
        (if (null (setq af1 ($findfile af '(|spad|))))
           (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
           (|compileSpad2Cmd| (cons af1 nil))))
       ((string= aft "lsp")
        (if (null (setq af1 ($findfile af '(|lsp|))))
          (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
          (|compileAsharpLispCmd| (cons af1 nil))))
       ((string= aft "nrlib")
        (if (null (setq af1 ($findfile af '(|nrlib|))))
          (|throwKeyedMsg| 'S2IL0003 (cons (namestring af) nil))
          (|compileSpadLispCmd| (cons af1 nil))))
       ((string= aft "ao")
        (if (null (setq af1 ($findfile af '(|ao|))))
          (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
         (|compileAsharpCmd| (cons af1 nil))))
       ((string= aft "al")
        (if (null (setq af1 ($findfile af '(|al|))))
          (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
          (|compileAsharpArchiveCmd| (cons af1 nil))))
       (t
        (setq af1 ($findfile af '(|as| |spad| |ao| |asy|)))
        (cond
         ((and af1 (string= (|pathnameType| af1) "as"))
          (|compileAsharpCmd| (cons af1 nil)))
         ((and af1 (string= (|pathnameType| af1) "ao"))
          (|compileAsharpCmd| (cons af1 nil)))
         ((and af1 (string= (|pathnameType| af1) "spad"))
          (|compileSpad2Cmd| (cons af1 nil)))
         ((and af1 (string= (|pathnameType| af1) "asy"))
          (|compileAsharpArchiveCmd| (cons af1 nil)))
         (t
          (setq ef (|pathname| /editfile))
          (setq ef (|mergePathnames| af ef))
          (cond
           ((boot-equal ef af) (|throwKeyedMsg| 's2iz0039 nil))
           (t
            (setq af ef)
            (cond
             ((string= (|pathnameType| af) "as")
              (|compileAsharpCmd| args))
             ((string= (|pathnameType| af) "ao")
              (|compileAsharpCmd| args))
             ((string= (|pathnameType| af) "spad")
              (|compileSpad2Cmd| args))
             (t
              (setq af1 ($findfile af '(|as| |spad| |ao| |asy|)))
              (cond
               ((and af1 (string= (|pathnameType| af1) "as"))
                 (|compileAsharpCmd| (cons af1 nil)))
               ((and af1 (string= (|pathnameType| af1) "ao"))
                 (|compileAsharpCmd| (cons af1 nil)))
               ((and af1 (string= (|pathnameType| af1) "spad"))
                 (|compileSpad2Cmd| (cons af1 nil)))
               ((and af1 (string= (|pathnameType| af1) "asy"))
                (|compileAsharpArchiveCmd| (cons af1 nil)))
               (t (|throwKeyedMsg| 's2iz0039 nil)))))))))))))))))

@
\defunsec{compileSpad2Cmd}{The Spad compiler top level function}
This is the old compiler.
Assume we entered from the "compiler" function, so args is 
a file with file extension .spad.

The \verb|$f| and \verb|$m| are compiler variables, probably function
and mode.
\calls{compileSpad2Cmd}{pathname(5)}
\calls{compileSpad2Cmd}{pathnameType(5)}
\calls{compileSpad2Cmd}{namestring(5)}
\calls{compileSpad2Cmd}{updateSourceFiles(5)}
\calls{compileSpad2Cmd}{selectOptionLC(5)}
\calls{compileSpad2Cmd}{terminateSystemCommand(5)}
\calls{compileSpad2Cmd}{nequal}
\calls{compileSpad2Cmd}{throwKeyedMsg}
\calls{compileSpad2Cmd}{sayKeyedMsg}
\calls{compileSpad2Cmd}{error}
\calls{compileSpad2Cmd}{strconc}
\calls{compileSpad2Cmd}{object2String}
\calls{compileSpad2Cmd}{oldParserAutoloadOnceTrigger}
\calls{compileSpad2Cmd}{browserAutoloadOnceTrigger}
\calls{compileSpad2Cmd}{spad2AsTranslatorAutoloadOnceTrigger}
\calls{compileSpad2Cmd}{convertSpadToAsFile}
\calls{compileSpad2Cmd}{compilerDoitWithScreenedLisplib}
\calls{compileSpad2Cmd}{compilerDoit}
\calls{compileSpad2Cmd}{extendLocalLibdb}
\calls{compileSpad2Cmd}{spadPrompt}
\usesdollar{compileSpad2Cmd}{newComp}
\usesdollar{compileSpad2Cmd}{scanIfTrue}
\usesdollar{compileSpad2Cmd}{compileOnlyCertainItems}
\usesdollar{compileSpad2Cmd}{f}
\usesdollar{compileSpad2Cmd}{m}
\usesdollar{compileSpad2Cmd}{QuickLet}
\usesdollar{compileSpad2Cmd}{QuickCode}
\usesdollar{compileSpad2Cmd}{sourceFileTypes}
\usesdollar{compileSpad2Cmd}{InteractiveMode}
\usesdollar{compileSpad2Cmd}{options}
\usesdollar{compileSpad2Cmd}{newConlist}
\uses{compileSpad2Cmd}{/editfile}
<<defun compileSpad2Cmd>>=
(defun |compileSpad2Cmd| (args)
 (let (|$newComp| |$scanIfTrue| 
       |$compileOnlyCertainItems| |$f| |$m| |$QuickLet| |$QuickCode| 
       |$sourceFileTypes| |$InteractiveMode| path optlist fun optname 
       optargs fullopt translateoldtonew constructor)
  (declare (special |$newComp| |$scanIfTrue| 
       |$compileOnlyCertainItems| |$f| |$m| |$QuickLet| |$QuickCode| 
       |$sourceFileTypes| |$InteractiveMode| /editfile |$options|
       |$newConlist|)) 
   (setq path (|pathname| args))
   (cond
    ((nequal (|pathnameType| path) "spad") (|throwKeyedMsg| 's2iz0082 nil))
    ((null (probe-file path))
     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
    (t
     (setq /editfile path)
     (|updateSourceFiles| path)
     (|sayKeyedMsg| 's2iz0038 (list (|namestring| args)))
     (setq optlist '(|break| |constructor| |functions| |library| |lisp|
         |new| |old| |nobreak| |nolibrary| |noquiet| |vartrace| |quiet|
         |translate|))
     (setq |$QuickLet| t)
     (setq |$QuickCode| t)
     (setq fun '(|rq| |lib|))
     (setq |$sourceFileTypes| '("SPAD"))
     (dolist (opt |$options|)
      (setq optname (car opt))
      (setq optargs (cdr opt))
      (setq fullopt (|selectOptionLC| optname optlist nil))
      (case fullopt
       (|new| (|error| '|Internal error: compileSpad2Cmd got )new|))
       (|old| nil)
       (|translate| (setq translateoldtonew t))
       (|library| (setelt fun 1 '|lib|))
       (|nolibrary| (setelt fun 1 '|nolib|))
       (|quiet| (when (nequal (elt fun 0) '|c|) (setelt fun 0 '|rq|)))
       (|noquiet| (when (nequal (elt fun 0) '|c|) (setelt fun 0 '|rf|)))
       (|nobreak| (setq |$scanIfTrue| t))
       (|break| (setq |$scanIfTrue| nil))
       (|vartrace| (setq |$QuickLet| nil))
       (|lisp| (|throwKeyedMsg| 's2iz0036 (list ")lisp")))
       (|functions|
        (if (null optargs) 
         (|throwKeyedMsg| 's2iz0037 (list ")functions"))
         (setq |$compileOnlyCertainItems| optargs)))
       (|constructor|
        (if (null optargs)
         (|throwKeyedMsg| 's2iz0037 (list ")constructor"))
         (progn
          (setelt fun 0 '|c|)
          (setq constructor (mapcar #'|unabbrev| optargs)))))
       (t
        (|throwKeyedMsg| 's2iz0036 
         (list (strconc ")" (|object2String| optname)))))))
    (setq |$InteractiveMode| nil)
    (cond
     (translateoldtonew
      (|oldParserAutoloadOnceTrigger|)
      (|browserAutoloadOnceTrigger|)
      (|spad2AsTranslatorAutoloadOnceTrigger|)
      (|sayKeyedMsg| 's2iz0085 nil)
      (|convertSpadToAsFile| path))
     (|$compileOnlyCertainItems|
      (if (null constructor)
       (|sayKeyedMsg| 's2iz0040 nil)
       (|compilerDoitWithScreenedLisplib| constructor fun)))
     (t (|compilerDoit| constructor fun)))
    (|extendLocalLibdb| |$newConlist|)
    (|terminateSystemCommand|)
    (|spadPrompt|)))))

@
\defun{compilerDoit}{compilerDoit}
\calls{compilerDoit}{/rq(5)}
\calls{compilerDoit}{/rf(5)}
\calls{compilerDoit}{member(5)}
\calls{compilerDoit}{sayBrightly}
\usesdollar{compilerDoit}{byConstructors}
\usesdollar{compilerDoit}{constructorsSeen}
<<defun compilerDoit>>=
(defun |compilerDoit| (constructor fun)
 (let (|$byConstructors| |$constructorsSeen|)
 (declare (special |$byConstructors| |$constructorsSeen|))
  (cond
   ((equal fun '(|rf| |lib|))   (|/RQ,LIB|))   ; Ignore "noquiet"
   ((equal fun '(|rf| |nolib|)) (/rf))
   ((equal fun '(|rq| |lib|))   (|/RQ,LIB|))
   ((equal fun '(|rq| |nolib|)) (/rq))
   ((equal fun '(|c| |lib|))
    (setq |$byConstructors| (loop for x in constructor collect (|opOf| x)))
    (|/RQ,LIB|)
    (dolist (x |$byConstructors|)
     (unless (|member| x |$constructorsSeen|)
      (|sayBrightly| `(">>> Warning " |%b| ,x |%d| " was not found"))))))))

@

\defun{/rf-1}{/rf-1}
\calls{/rf-1}{makeInputFilename(5)}
\calls{/rf-1}{ncINTERPFILE}
\calls{/rf-1}{spad}
\uses{/rf-1}{/editfile}
\uses{/rf-1}{echo-meta}
<<defun /rf-1>>=
(defun /rf-1 (ignore)
 (declare (ignore ignore))
 (let* ((input-file (makeInputFilename /editfile))
        (type (pathname-type input-file)))
 (declare (special echo-meta /editfile))
 (cond
  ((string= type "lisp") (load input-file))
  ((string= type "input") (|ncINTERPFILE| input-file echo-meta))
  (t (spad input-file)))))

@

\defun{spad}{spad}
\catches{spad}{spad-reader}
\calls{spad}{addBinding}
\calls{spad}{makeInitialModemapFrame}
\calls{spad}{init-boot/spad-reader}
\calls{spad}{initialize-preparse}
\calls{spad}{preparse}
\calls{spad}{PARSE-NewExpr}
\calls{spad}{pop-stack-1}
\calls{spad}{s-process}
\calls{spad}{ioclear}
\calls{spad}{shut}
\usesdollar{spad}{noSubsumption}
\usesdollar{spad}{InteractiveFrame}
\usesdollar{spad}{InitialDomainsInScope}
\usesdollar{spad}{InteractiveMode}
\uses{spad}{line}
\uses{spad}{echo-meta}
\uses{spad}{/editfile}
\uses{spad}{*comp370-apply*}
\uses{spad}{*eof*}
\uses{spad}{file-closed}
\uses{spad}{xcape}
\catches{spad}{spad-reader}
<<defun spad>>=
(defun spad (&optional (*spad-input-file* nil) (*spad-output-file* nil)
             &aux (*comp370-apply* #'print-defun)
                  (*fileactq-apply* #'print-defun)
                 ($spad t) ($boot nil) (xcape #\_) (optionlist nil) (*eof* nil)
                 (file-closed nil) (/editfile *spad-input-file*)
                (|$noSubsumption| |$noSubsumption|) in-stream out-stream)
  (declare (special echo-meta /editfile *comp370-apply* *eof*
                    file-closed xcape |$noSubsumption| |$InteractiveFrame|
                    |$InteractiveMode| |$InitialDomainsInScope|))
  ;; only rebind |$InteractiveFrame| if compiling
  (progv (if (not |$InteractiveMode|) '(|$InteractiveFrame|))
         (if (not |$InteractiveMode|)
             (list (|addBinding| '|$DomainsInScope|
                    `((fluid . |true|)
                      (|special| . ,(copy-tree |$InitialDomainsInScope|)))
                   (|addBinding| '|$Information| nil
                      (|makeInitialModemapFrame|)))))
  (init-boot/spad-reader)
  (unwind-protect
    (progn
      (setq in-stream (if *spad-input-file*
                        (open *spad-input-file* :direction :input)
                         *standard-input*))
      (initialize-preparse in-stream)
      (setq out-stream (if *spad-output-file*
                        (open *spad-output-file* :direction :output)
                         *standard-output*))
      (when *spad-output-file*
         (format out-stream "~&;;; -*- Mode:Lisp; Package:Boot  -*-~%~%")
         (print-package "BOOT"))
      (setq curoutstream out-stream)
      (loop
       (if (or *eof* file-closed) (return nil))
       (catch 'spad_reader
         (if (setq boot-line-stack (preparse in-stream))
             (let ((line (cdar boot-line-stack)))
               (declare (special line))
               (|PARSE-NewExpr|)
               (let ((parseout (pop-stack-1)) )
                 (when parseout
                       (let ((*standard-output* out-stream))
                         (s-process parseout))
                       (format out-stream "~&")))
               )))
      (ioclear in-stream out-stream)))
    (if *spad-input-file* (shut in-stream))
    (if *spad-output-file* (shut out-stream)))
  t))

@

\defun{s-process}{Interpreter interface to the compiler}
\calls{s-process}{curstrm}
\calls{s-process}{def-rename}
\calls{s-process}{new2OldLisp}
\calls{s-process}{parseTransform}
\calls{s-process}{postTransform}
\calls{s-process}{displayPreCompilationErrors}
\calls{s-process}{prettyprint}
\calls{s-process}{processInteractive}
\calls{s-process}{compTopLevel}
\calls{s-process}{def-process}
\calls{s-process}{displaySemanticErrors}
\calls{s-process}{terpri}
\calls{s-process}{get-internal-run-time}
\usesdollar{s-process}{Index}
\usesdollar{s-process}{macroassoc}
\usesdollar{s-process}{newspad}
\usesdollar{s-process}{PolyMode}
\usesdollar{s-process}{EmptyMode}
\usesdollar{s-process}{compUniquelyIfTrue}
\usesdollar{s-process}{currentFunction}
\usesdollar{s-process}{postStack}
\usesdollar{s-process}{topOp}
\usesdollar{s-process}{semanticErrorStack}
\usesdollar{s-process}{warningStack}
\usesdollar{s-process}{exitMode}
\usesdollar{s-process}{exitModeStack}
\usesdollar{s-process}{returnMode}
\usesdollar{s-process}{leaveMode}
\usesdollar{s-process}{leaveLevelStack}
\usesdollar{s-process}{top-level}
\usesdollar{s-process}{insideFunctorIfTrue}
\usesdollar{s-process}{insideExpressionIfTrue}
\usesdollar{s-process}{insideCoerceInteractiveHardIfTrue}
\usesdollar{s-process}{insideWhereIfTrue}
\usesdollar{s-process}{insideCategoryIfTrue}
\usesdollar{s-process}{insideCapsuleFunctionIfTrue}
\usesdollar{s-process}{form}
\usesdollar{s-process}{DomainFrame}
\usesdollar{s-process}{e}
\usesdollar{s-process}{EmptyEnvironment}
\usesdollar{s-process}{genFVar}
\usesdollar{s-process}{genSDVar}
\usesdollar{s-process}{VariableCount}
\usesdollar{s-process}{previousTime}
\usesdollar{s-process}{LocalFrame}
\uses{s-process}{curoutstream}
<<defun s-process>>=
(defun s-process (x)
 (prog ((|$Index| 0)
        ($macroassoc ())
        ($newspad t)
        (|$PolyMode| |$EmptyMode|)
        (|$compUniquelyIfTrue| nil)
        |$currentFunction|
        (|$postStack| nil)
        |$topOp|
        (|$semanticErrorStack| ())
        (|$warningStack| ())
        (|$exitMode| |$EmptyMode|)
        (|$exitModeStack| ())
        (|$returnMode| |$EmptyMode|)
        (|$leaveMode| |$EmptyMode|)
        (|$leaveLevelStack| ())
        $top_level |$insideFunctorIfTrue| |$insideExpressionIfTrue|
        |$insideCoerceInteractiveHardIfTrue| |$insideWhereIfTrue|
        |$insideCategoryIfTrue| |$insideCapsuleFunctionIfTrue| |$form|
        (|$DomainFrame| '((NIL)))
        (|$e| |$EmptyEnvironment|)
        (|$genFVar| 0)
        (|$genSDVar| 0)
        (|$VariableCount| 0)
        (|$previousTime| (get-internal-run-time))
        (|$LocalFrame| '((NIL)))
        (curstrm curoutstream) |$s| |$x| |$m| u)
  (declare (special |$Index| $macroassoc $newspad |$PolyMode| |$EmptyMode|
            |$compUniquelyIfTrue| |$currentFunction| |$postStack| |$topOp|
            |$semanticErrorStack| |$warningStack| |$exitMode| |$exitModeStack|
            |$returnMode| |$leaveMode| |$leaveLevelStack| $top_level 
            |$insideFunctorIfTrue| |$insideExpressionIfTrue|
            |$insideCoerceInteractiveHardIfTrue| |$insideWhereIfTrue|
            |$insideCategoryIfTrue| |$insideCapsuleFunctionIfTrue| |$form|
            |$DomainFrame| |$e| |$EmptyEnvironment| |$genFVar| |$genSDVar| 
            |$VariableCount| |$previousTime| |$LocalFrame|
            curstrm |$s| |$x| |$m| curoutstream $traceflag))
   (setq $traceflag t)
   (if (not x) (return nil))
   (if $boot
     (setq x (def-rename (|new2OldLisp| x)))
     (setq x (|parseTransform| (|postTransform| x))))
   (when |$TranslateOnly| (return (setq |$Translation| x)))
   (when |$postStack| (|displayPreCompilationErrors|) (return nil))
   (when |$PrintOnly|
        (format t "~S   =====>~%" |$currentLine|)
        (return (prettyprint x)))
   (if (not $boot)
    (if |$InteractiveMode|
      (|processInteractive| x nil)
      (when (setq u (|compTopLevel| x |$EmptyMode| |$InteractiveFrame|))
        (setq |$InteractiveFrame| (third u))))
    (def-process x))
   (when |$semanticErrorStack| (|displaySemanticErrors|))
   (terpri)))

@

\defun{compTopLevel}{compTopLevel}
\calls{compTopLevel}{newComp}
\calls{compTopLevel}{compOrCroak}
\usesdollar{compTopLevel}{NRTderivedTargetIfTrue}
\usesdollar{compTopLevel}{killOptimizeIfTrue}
\usesdollar{compTopLevel}{forceAdd}
\usesdollar{compTopLevel}{compTimeSum}
\usesdollar{compTopLevel}{resolveTimeSum}
\usesdollar{compTopLevel}{packagesUsed}
\usesdollar{compTopLevel}{envHashTable}
<<defun compTopLevel>>=
(defun |compTopLevel| (x m e)
 (let (|$NRTderivedTargetIfTrue| |$killOptimizeIfTrue| |$forceAdd|
       |$compTimeSum| |$resolveTimeSum| |$packagesUsed| |$envHashTable|
        t1 t2 t3 val mode)
 (declare (special |$NRTderivedTargetIfTrue| |$killOptimizeIfTrue|
                   |$forceAdd| |$compTimeSum| |$resolveTimeSum|
                   |$packagesUsed| |$envHashTable| ))
   (setq |$NRTderivedTargetIfTrue| nil)
   (setq |$killOptimizeIfTrue| nil)
   (setq |$forceAdd| nil)
   (setq |$compTimeSum| 0)
   (setq |$resolveTimeSum| 0)
   (setq |$packagesUsed| NIL)
   (setq |$envHashTable| (make-hashtable 'equal))
   (dolist (u (car (car e)))
    (dolist (v (cdr u))
     (hput |$envHashTable| (cons (car u) (cons (car v) nil)) t)))
   (cond
    ((or (and (pairp x) (eq (qcar x) 'def))
         (and (pairp x) (eq (qcar x) '|where|)
              (progn
                (setq t1 (qcdr x))
                (and (pairp t1)
                (progn
                 (setq t2 (qcar t1))
                 (and (pairp t2) (eq (qcar t2) 'def)))))))
      (setq t3 (|compOrCroak| x m e))
      (setq val (car t3))
      (setq mode (cadr t3))
      (cons val (cons mode (cons e nil))))
    (t (|compOrCroak| x m e)))))

@
Given:
\begin{verbatim}
CohenCategory(): Category == SetCategory with

  kind:(CExpr)->Boolean
  operand:(CExpr,Integer)->CExpr
  numberOfOperand:(CExpr)->Integer
  construct:(CExpr,CExpr)->CExpr

\end{verbatim}
the resulting call looks like:
\begin{verbatim}
 (|compOrCroak|
       (DEF (|CohenCategory|)
        ((|Category|))
        (NIL)
        (|Join|
         (|SetCategory|)
         (CATEGORY |package|
          (SIGNATURE |kind| ((|Boolean|) |CExpr|))
          (SIGNATURE |operand| (|CExpr| |CExpr| (|Integer|)))
          (SIGNATURE |numberOfOperand| ((|Integer|) |CExpr|))
          (SIGNATURE |construct| (|CExpr| |CExpr| |CExpr|)))))
        |$EmptyMode|
        (((
           (|$DomainsInScope| 
            (FLUID . |true|)
            (|special| |$EmptyMode| |$NoValueMode|))))))
\end{verbatim}

This compiler call expects the first argument {\tt x} 
to be a {\tt DEF} form to compile,
The second argument, {\tt m}, is the mode.
The third argument, {\tt e}, is the environment.

\defun{compOrCroak}{compOrCroak}
\calls{compOrCroak}{compOrCroak1}
<<defun compOrCroak>>=
(defun |compOrCroak| (x m e)
  (|compOrCroak1| x m e nil nil))

@

This results in a call to the inner function with
\begin{verbatim}
(|compOrCroak1|
          (DEF (|CohenCategory|)
           ((|Category|))
           (NIL)
           (|Join|
            (|SetCategory|)
            (CATEGORY |package|
             (SIGNATURE |kind| ((|Boolean|) |CExpr|))
             (SIGNATURE |operand| (|CExpr| |CExpr| (|Integer|)))
             (SIGNATURE |numberOfOperand| ((|Integer|) |CExpr|))
             (SIGNATURE |construct| (|CExpr| |CExpr| |CExpr|)))))
          |$EmptyMode|
          ((((
              |$DomainsInScope|
              (FLUID . |true|)
              (|special| |$EmptyMode| |$NoValueMode|)))))
          NIL 
          NIL 
          |comp|)
\end{verbatim}
The inner function augments the environment with information
from the compiler stack {\tt \$compStack} and
{\tt \$compErrorMessageStack}. Note that these variables are passed
in the argument list so they get preserved on the call stack. The
calling function gets called for every inner form so we use this
implicit stacking to retain the information.

\defun{compOrCroak1}{compOrCroak1}
\calls{compOrCroak1}{comp}
\calls{compOrCroak1}{compOrCroak1,compactify}
\calls{compOrCroak1}{stackSemanticError}
\calls{compOrCroak1}{mkErrorExpr}
\calls{compOrCroak1}{displaySemanticErrors}
\calls{compOrCroak1}{say}
\calls{compOrCroak1}{displayComp}
\calls{compOrCroak1}{userError}
\usesdollar{compOrCroak1}{compStack}
\usesdollar{compOrCroak1}{compErrorMessageStack}
\usesdollar{compOrCroak1}{level}
\usesdollar{compOrCroak1}{s}
\usesdollar{compOrCroak1}{scanIfTrue}
\usesdollar{compOrCroak1}{exitModeStack}
\catches{compOrCroak1}{compOrCroak}
<<defun compOrCroak1>>=
(defun |compOrCroak1| (x m e |$compStack| |$compErrorMessageStack|)
 (declare (special |$compStack| |$compErrorMessageStack|))
 (let (td errorMessage)
  (declare (special |$level| |$s| |$scanIfTrue| |$exitModeStack|))
  (cond
   ((setq td (catch '|compOrCroak| (|comp| x m e))) td)
   (t
     (setq |$compStack| (cons (list x m e |$exitModeStack|) |$compStack|))
     (setq |$s| (|compOrCroak1,compactify| |$compStack|))
     (setq |$level| (|#| |$s|))
     (setq errorMessage
       (if |$compErrorMessageStack|
         (car |$compErrorMessageStack|)
         '|unspecified error|))
     (cond 
      (|$scanIfTrue|
        (|stackSemanticError| errorMessage (|mkErrorExpr| |$level|))
        (list '|failedCompilation| m e ))
      (t
       (|displaySemanticErrors|)
       (say "****** comp fails at level " |$level| " with expression: ******")
       (|displayComp| |$level|)
       (|userError| errorMessage)))))))

@

\defun{comp}{comp}
\calls{comp}{compNoStacking}
\usesdollar{comp}{compStack}
\usesdollar{comp}{exitModeStack}
<<defun comp>>=
(defun |comp| (x m e)
 (let (td)
 (declare (special |$compStack| |$exitModeStack|))
  (if (setq td (|compNoStacking| x m e))
    (setq |$compStack| nil) 
    (push (list x m e |$exitModeStack|) |$compStack|))
  td))

@

\defun{compNoStacking}{compNoStacking}
\verb|$Representation| is bound in compDefineFunctor, set by doIt.
This hack says that when something is undeclared, \$ is
preferred to the underlying representation -- RDJ 9/12/83
\calls{compNoStacking}{comp2}
\calls{compNoStacking}{compNoStacking1}
\usesdollar{compNoStacking}{compStack}
\usesdollar{compNoStacking}{Representation}
\usesdollar{compNoStacking}{EmptyMode}
<<defun compNoStacking>>=
(defun |compNoStacking| (x m e)
 (let (td)
 (declare (special |$compStack| |$Representation| |$EmptyMode|))
  (if (setq td (|comp2| x m e))
    (if (and (equal m |$EmptyMode|) (equal (cadr td) |$Representation|))
      (list (car td) '$ (caddr td))
      td)
   (|compNoStacking1| x m e |$compStack|))))

@

\defun{compNoStacking1}{compNoStacking1}
\calls{compNoStacking1}{get}
\calls{compNoStacking1}{comp2}
\usesdollar{compNoStacking1}{compStack}
<<defun compNoStacking1>>=
(defun |compNoStacking1| (x m e |$compStack|)
 (declare (special |$compStack|))
 (let (u td)
  (if (setq u (|get| (if (eq m '$) '|Rep| m) '|value| e))
    (if (setq td (|comp2| x (car u) e))
      (list (car td) m (caddr td))
      nil)
    nil)))

@

\defun{comp2}{comp2}
\calls{comp2}{comp3}
\calls{comp2}{isDomainForm}
\calls{comp2}{isFunctor}
\calls{comp2}{insert}
\calls{comp2}{opOf}
\calls{comp2}{nequal}
\calls{comp2}{addDomain}
\usesdollar{comp2}{bootStrapMode}
\usesdollar{comp2}{packagesUsed}
\usesdollar{comp2}{lisplib}
<<defun comp2>>=
(defun |comp2| (x m e)
 (let (tmp1)
  (declare (special |$bootStrapMode| |$packagesUsed| $lisplib))
   (when (setq tmp1 (|comp3| x m e))
    (destructuring-bind (y mprime e) tmp1
     (when (and $lisplib (|isDomainForm| x e) (|isFunctor| x))
       (setq |$packagesUsed| (|insert| (list (|opOf| x)) |$packagesUsed|)))
     ; isDomainForm test needed to prevent error while compiling Ring
     ; $bootStrapMode-test necessary for compiling Ring in $bootStrapMode
     (if (and (nequal m mprime)
              (or |$bootStrapMode| (|isDomainForm| mprime e)))
       (list y mprime (|addDomain| mprime e))
       (list y mprime e))))))

@

\defun{comp3}{comp3}
\begin{verbatim}
;comp3(x,m,$e) ==
;  --returns a Triple or %else nil to signalcan't do'
;  $e:= addDomain(m,$e)
;  e:= $e --for debugging purposes
;  m is ["Mapping",:.] => compWithMappingMode(x,m,e)
;  m is ["QUOTE",a] => (x=a => [x,m,$e]; nil)
;  STRINGP m => (atom x => (m=x or m=STRINGIMAGE x => [m,m,e]; nil); nil)
;  ^x or atom x => compAtom(x,m,e)
;  op:= first x
;  getmode(op,e) is ["Mapping",:ml] and (u:= applyMapping(x,m,e,ml)) => u
;  op is ["KAPPA",sig,varlist,body] => compApply(sig,varlist,body,rest x,m,e)
;  op=":" => compColon(x,m,e)
;  op="::" => compCoerce(x,m,e)
;  not ($insideCompTypeOf=true) and stringPrefix?('"TypeOf",PNAME op) =>
;    compTypeOf(x,m,e)
;  t:= compExpression(x,m,e)
;  t is [x',m',e'] and not MEMBER(m',getDomainsInScope e') =>
;    [x',m',addDomain(m',e')]
;  t
\end{verbatim}
\calls{comp3}{addDomain}
\calls{comp3}{compWithMappingMode}
\calls{comp3}{stringimage}
\calls{comp3}{compAtom}
\calls{comp3}{getmode}
\calls{comp3}{applyMapping}
\calls{comp3}{compApply}
\calls{comp3}{compColon}
\calls{comp3}{compCoerce}
\calls{comp3}{stringPrefix?}
\calls{comp3}{pname}
\calls{comp3}{compTypeOf}
\calls{comp3}{compExpression}
\calls{comp3}{member}
\calls{comp3}{getDomainsInScope}
\usesdollar{comp3}{e}
\usesdollar{comp3}{insideCompTypeOf}
<<defun comp3>>=
(defun |comp3| (x m |$e|)
 (declare (special |$e|))
 (let (e a op ml u sig varlist tmp3 body tt xprime tmp1 mprime tmp2 eprime)
 (declare (special |$insideCompTypeOf|))
  (setq |$e| (|addDomain| m |$e|))
  (setq e |$e|)
  (cond
   ((and (pairp m) (eq (qcar m) '|Mapping|)) (|compWithMappingMode| x m e))
   ((and (pairp m) (eq (qcar m) 'quote)
         (progn
          (setq tmp1 (qcdr m))
          (and (pairp tmp1) (eq (qcdr tmp1) nil)
          (progn (setq a (qcar tmp1)) t))))
    (when (equal x a) (list x m |$e|)))
   ((stringp m)
    (when (and (atom x) (or (equal m x) (equal m (stringimage x))))
     (list m m e )))
   ((or (null x) (atom x)) (|compAtom| x m e))
   (t 
    (setq op (car x))
    (cond
     ((and (progn
            (setq tmp1 (|getmode| op e))
            (and (pairp tmp1)
                 (eq (qcar tmp1) '|Mapping|)
                 (progn (setq ml (qcdr tmp1)) t)))
            (setq u (|applyMapping| x m e ml)))
        u)
     ((and (pairp op) (eq (qcar op) 'kappa)
           (progn
            (setq tmp1 (qcdr op))
            (and (pairp tmp1)
                 (progn
                  (setq sig (qcar tmp1))
                   (setq tmp2 (qcdr tmp1))
                   (and (pairp tmp2)
                        (progn
                         (setq varlist (qcar tmp2))
                         (setq tmp3 (qcdr tmp2))
                         (and (pairp tmp3)
                              (eq (qcdr tmp3) nil)
                              (progn
                                (setq body (qcar tmp3))
                                t))))))))
       (|compApply| sig varlist body (cdr x) m e))
     ((eq op '|:|)  (|compColon| x m e))
     ((eq op '|::|) (|compCoerce| x m e))
     ((and (null (eq |$insideCompTypeOf| t))
           (|stringPrefix?| "TypeOf" (pname op)))
       (|compTypeOf| x m e))
      (t
       (setq tt (|compExpression| x m e))
       (cond
        ((and (pairp tt)
              (progn
               (setq xprime (qcar tt))
               (setq tmp1 (qcdr tt))
               (and (pairp tmp1)
                    (progn
                     (setq mprime (qcar tmp1))
                     (setq tmp2 (qcdr tmp1))
                     (and (pairp tmp2)
                          (eq (qcdr tmp2) nil)
                          (progn
                            (setq eprime (qcar tmp2))
                            t)))))
                     (null (|member| mprime (|getDomainsInScope| eprime))))
         (list xprime mprime (|addDomain| mprime eprime)))
        (t tt))))))))

@

\defun{compColon}{compColon}
\begin{verbatim}
;compColon([":",f,t],m,e) ==
;  $insideExpressionIfTrue=true => compColonInside(f,m,e,t)
;    --if inside an expression, ":" means to convert to m "on faith"
;  $lhsOfColon: local:= f
;  t:=
;    atom t and (t':= ASSOC(t,getDomainsInScope e)) => t'
;    isDomainForm(t,e) and not $insideCategoryIfTrue =>
;      (if not MEMBER(t,getDomainsInScope e) then e:= addDomain(t,e); t)
;    isDomainForm(t,e) or isCategoryForm(t,e) => t
;    t is ["Mapping",m',:r] => t
;    unknownTypeError t
;    t
;  f is ["LISTOF",:l] =>
;    (for x in l repeat T:= [.,.,e]:= compColon([":",x,t],m,e); T)
;  e:=
;    f is [op,:argl] and not (t is ["Mapping",:.]) =>
;      --for MPOLY--replace parameters by formal arguments: RDJ 3/83
;      newTarget:= EQSUBSTLIST(take(#argl,$FormalMapVariableList),
;        [(x is [":",a,m] => a; x) for x in argl],t)
;      signature:=
;        ["Mapping",newTarget,:
;          [(x is [":",a,m] => m;
;              getmode(x,e) or systemErrorHere '"compColonOld") for x in argl]]
;      put(op,"mode",signature,e)
;    put(f,"mode",t,e)
;  if not $bootStrapMode and $insideFunctorIfTrue and
;    makeCategoryForm(t,e) is [catform,e] then
;        e:= put(f,"value",[genSomeVariable(),t,$noEnv],e)
;  ["/throwAway",getmode(f,e),e]
\end{verbatim}
\calls{compColon}{compColonInside}
\calls{compColon}{assoc}
\calls{compColon}{getDomainsInScope}
\calls{compColon}{isDomainForm}
\calls{compColon}{member}
\calls{compColon}{addDomain}
\calls{compColon}{isDomainForm}
\calls{compColon}{isCategoryForm}
\calls{compColon}{unknownTypeError}
\calls{compColon}{compColon}
\calls{compColon}{eqsubstlist}
\calls{compColon}{take}
\calls{compColon}{length}
\calls{compColon}{nreverse0}
\calls{compColon}{getmode}
\calls{compColon}{systemErrorHere}
\calls{compColon}{put}
\calls{compColon}{makeCategoryForm}
\calls{compColon}{genSomeVariable}
\usesdollar{compColon}{lhsOfColon}
\usesdollar{compColon}{noEnv}
\usesdollar{compColon}{insideFunctorIfTrue}
\usesdollar{compColon}{bootStrapMode}
\usesdollar{compColon}{FormalMapVariableList}
\usesdollar{compColon}{insideCategoryIfTrue}
\usesdollar{compColon}{insideExpressionIfTrue}
<<defun compColon>>=
(defun |compColon| (arg0 m e)
  (let (|$lhsOfColon| argf argt tprime mprime r l tmp1 td op argl newTarget a 
        signature tmp2 catform tmp3 g2 g5)
  (declare (special |$lhsOfColon| |$noEnv| |$insideFunctorIfTrue|
                    |$bootStrapMode| |$FormalMapVariableList|
                    |$insideCategoryIfTrue| |$insideExpressionIfTrue|))
    (setq argf (cadr arg0))
    (setq argt (caddr arg0))
    (if |$insideExpressionIfTrue|
      (|compColonInside| argf m e argt)
      (progn
        (setq |$lhsOfColon| argf)
        (setq argt
         (cond
          ((and (atom argt)
                (setq tprime (|assoc| argt (|getDomainsInScope| e))))
            tprime)
          ((and (|isDomainForm| argt e) (null |$insideCategoryIfTrue|))
            (unless (|member| argt (|getDomainsInScope| e))
               (setq e (|addDomain| argt e)))
            argt)
          ((or (|isDomainForm| argt e) (|isCategoryForm| argt e))
            argt)
          ((and (pairp argt) (eq (qcar argt) '|Mapping|)
                (progn
                  (setq tmp2 (qcdr argt))
                  (and (pairp tmp2)
                       (progn
                        (setq mprime (qcar tmp2))
                        (setq r (qcdr tmp2))
                        t))))
            argt)
          (t
            (|unknownTypeError| argt)
            argt)))
        (cond
         ((eq (car argf) 'listof)
           (dolist (x (cdr argf) td)
             (setq td (|compColon| (list '|:| x argt) m e))
             (setq e (caddr td))))
         (t
          (setq e
           (cond
            ((and (pairp argf)
                  (progn
                   (setq op (qcar argf))
                   (setq argl (qcdr argf))
                   t)
                  (null (and (pairp argt) (eq (qcar argt) '|Mapping|))))
             (setq newTarget
              (eqsubstlist (take (|#| argl) |$FormalMapVariableList|)
              (dolist (x argl (nreverse0 g2))
                (setq g2
                 (cons
                  (cond
                   ((and (pairp x) (eq (qcar x) '|:|)
                         (progn
                          (setq tmp2 (qcdr x))
                          (and (pairp tmp2)
                               (progn
                                (setq a (qcar tmp2))
                                (setq tmp3 (qcdr tmp2))
                                (and (pairp tmp3)
                                     (eq (qcdr tmp3) nil)
                                     (progn
                                      (setq m (qcar tmp3))
                                      t))))))
                       a)
                      (t x))
               g2)))
              argt))
             (setq signature
              (cons '|Mapping|
               (cons newTarget
                (dolist (x argl (nreverse0 g5))
                  (setq g5
                   (cons
                    (cond
                     ((and (pairp x) (eq (qcar x) '|:|)
                      (progn
                       (setq tmp2 (qcdr x))
                       (and (pairp tmp2)
                            (progn
                             (setq a (qcar tmp2))
                             (setq tmp3 (qcdr tmp2))
                             (and (pairp tmp3)
                                  (eq (qcdr tmp3) nil)
                                  (progn
                                   (setq m (qcar tmp3))
                                   t))))))
                       m)
                     (t
                      (or (|getmode| x e)
                          (|systemErrorHere| "compColonOld"))))
                     g5))))))
             (|put| op '|mode| signature e))
            (t (|put| argf '|mode| argt e))))
         (cond
           ((and (null |$bootStrapMode|) |$insideFunctorIfTrue|
                 (progn
                  (setq tmp2 (|makeCategoryForm| argt e))
                  (and (pairp tmp2)
                       (progn
                        (setq catform (qcar tmp2))
                        (setq tmp3 (qcdr tmp2))
                        (and (pairp tmp3)
                             (eq (qcdr tmp3) nil)
                             (progn
                               (setq e (qcar tmp3))
                                       t))))))
            (setq e 
             (|put| argf '|value| (list (|genSomeVariable|) argt |$noEnv|)
              e))))
         (list '|/throwAway| (|getmode| argf e) e )))))))

@

\defun{compColonInside}{compColonInside}
\calls{compColonInside}{addDomain}
\calls{compColonInside}{comp}
\calls{compColonInside}{coerce}
\calls{compColonInside}{stackWarning}
\calls{compColonInside}{opOf}
\calls{compColonInside}{stackSemanticError}
\usesdollar{compColonInside}{newCompilerUnionFlag}
\usesdollar{compColonInside}{EmptyMode}
<<defun compColonInside>>=
(defun |compColonInside| (x m e mprime)
 (let (mpp warningMessage td tprime failed)
 (declare (special |$newCompilerUnionFlag| |$EmptyMode|))
    (setq e (|addDomain| mprime e))
    (when (setq td (|comp| x |$EmptyMode| e))
     (cond
      ((equal (setq mpp (CADR td)) mprime)
       (setq warningMessage
        (list '|:| mprime '| -- should replace by @|))))
     (setq td (list (car td) mprime (caddr td)))
     (when (setq tprime (|coerce| td m))
      (cond
       (warningMessage (|stackWarning| warningMessage))
       ((and |$newCompilerUnionFlag| (eq (|opOf| mpp) '|Union|))
        (setq tprime
         (|stackSemanticError|
          (list '|cannot pretend | x '| of mode | mpp '| to mode | mprime )
          nil)))
       (t
        (|stackWarning|
         (list '|:| mprime '| -- should replace by pretend|))))
      tprime))))

@

\defun{compAtom}{compAtom}
\begin{verbatim}
;compAtom(x,m,e) ==
;  T:= compAtomWithModemap(x,m,e,get(x,"modemap",e)) => T
;  x="nil" =>
;    T:=
;      modeIsAggregateOf('List,m,e) is [.,R]=> compList(x,['List,R],e)
;      modeIsAggregateOf('Vector,m,e) is [.,R]=> compVector(x,['Vector,R],e)
;    T => convert(T,m)
;  t:=
;    isSymbol x =>
;      compSymbol(x,m,e) or return nil
;    m = $Expression and primitiveType x => [x,m,e]
;    STRINGP x => [x,x,e]
;    [x,primitiveType x or return nil,e]
;  convert(t,m)
\end{verbatim}
\calls{compAtom}{compAtomWithModemap}
\calls{compAtom}{get}
\calls{compAtom}{modeIsAggregateOf}
\calls{compAtom}{compList}
\calls{compAtom}{compVector}
\calls{compAtom}{convert}
\calls{compAtom}{isSymbol}
\calls{compAtom}{compSymbol}
\calls{compAtom}{primitiveType}
\calls{compAtom}{primitiveType}
\usesdollar{compAtom}{Expression}
<<defun compAtom>>=
(defun |compAtom| (x m e)
 (prog (tmp1 tmp2 r td tt)
  (declare (special |$Expression|))
   (return
   (cond
    ((setq td (|compAtomWithModemap| x m e (|get| x '|modemap| e))) td)
    ((eq x '|nil|)
     (setq td
      (cond
       ((progn
         (setq tmp1 (|modeIsAggregateOf| '|List| m e))
         (and (pairp tmp1)
              (progn
               (setq tmp2 (qcdr tmp1))
               (and (pairp tmp2)
                    (eq (qcdr tmp2) nil)
                    (progn
                      (setq r (qcar tmp2)) t)))))
         (|compList| x (list '|List| r) e))
       ((progn
         (setq tmp1 (|modeIsAggregateOf| '|Vector| m e))
         (and (pairp tmp1)
              (progn
               (setq tmp2 (qcdr tmp1))
               (and (pairp tmp2) (eq (qcdr tmp2) nil)
               (progn
                 (setq r (qcar tmp2)) t)))))
         (|compVector| x (list '|Vector| r) e))))
      (when td (|convert| td m)))
    (t
     (setq tt
      (cond
       ((|isSymbol| x) (or (|compSymbol| x m e) (return nil)))
       ((and (equal m |$Expression|) (|primitiveType| x)) (list x m e ))
       ((stringp x) (list x x e ))
       (t (list x (or (|primitiveType| x) (return nil)) e ))))
     (|convert| tt m))))))

@

\defun{compSymbol}{compSymbol}
\calls{compSymbol}{getmode}
\calls{compSymbol}{get}
\calls{compSymbol}{NRTgetLocalIndex}
\calls{compSymbol}{member}
\calls{compSymbol}{isFunction}
\calls{compSymbol}{errorRef}
\calls{compSymbol}{stackMessage}
\usesdollar{compSymbol}{Symbol}
\usesdollar{compSymbol}{Expression}
\usesdollar{compSymbol}{FormalMapVariableList}
\usesdollar{compSymbol}{compForModeIfTrue}
\usesdollar{compSymbol}{formalArgList}
\usesdollar{compSymbol}{NoValueMode}
\usesdollar{compSymbol}{functorLocalParameters}
\usesdollar{compSymbol}{Boolean}
\usesdollar{compSymbol}{NoValue}
<<defun compSymbol>>=
(defun |compSymbol| (s m e)
 (let (v mprime)
  (declare (special |$Symbol| |$Expression| |$FormalMapVariableList|
                    |$compForModeIfTrue| |$formalArgList| |$NoValueMode|
                    |$functorLocalParameters| |$Boolean| |$NoValue|))
   (cond
     ((eq s '|$NoValue|) (list '|$NoValue| |$NoValueMode| e ))
     ((|isFluid| s)
      (setq mode (|getmode| s e))
      (when mode (list s (|getmode| s e) e)))
     ((eq s '|true|) (list '(quote t) |$Boolean| e ))
     ((eq s '|false|) (list nil |$Boolean| e ))
     ((or (equal s m) (|get| s '|isLiteral| e)) (list (list 'quote s) s e))
     ((setq v (|get| s '|value| e))
      (cond
        ((member s |$functorLocalParameters|)
         ; s will be replaced by an ELT form in beforeCompile
         (|NRTgetLocalIndex| s) 
         (list s (cadr v) e))
        (t
         ; s has been SETQd
         (list s (cadr v) e))))
     ((setq mprime (|getmode| s e))
      (cond
        ((and (null (|member| s |$formalArgList|))
              (null (member s |$FormalMapVariableList|))
              (null (|isFunction| s e))
              (null (eq |$compForModeIfTrue| t)))
         (|errorRef| s)))
      (list s mprime e ))
     ((member s |$FormalMapVariableList|)
      (|stackMessage| (list '|no mode found for| s )))
     ((or (equal m |$Expression|) (equal m |$Symbol|))
      (list (list 'quote s) m e ))
     ((null (|isFunction| s e)) (|errorRef| s)))))

@

\defun{compList}{compList}
\begin{verbatim}
;compList(l,m is ["List",mUnder],e) ==
;  null l => [NIL,m,e]
;  Tl:= [[.,mUnder,e]:= comp(x,mUnder,e) or return "failed" for x in l]
;  Tl="failed" => nil
;  T:= [["LIST",:[T.expr for T in Tl]],["List",mUnder],e]
\end{verbatim}
\calls{compList}{comp}
<<defun compList>>=
(defun |compList| (l m e)
 (let (tmp1 tmp2 t0 failed (mUnder (cadr m)))
  (if (null l)
   (list nil m e)
   (progn
    (setq t0
     (do ((t3 l (cdr t3)) (x nil))
         ((or (atom t3) failed) (unless failed (nreverse0 tmp2)))
       (setq x (car t3))
       (if (setq tmp1 (|comp| x mUnder e))
        (progn
         (setq mUnder (cadr tmp1))
         (setq e (caddr tmp1))
         (push tmp1 tmp2))
        (setq failed t))))
    (unless failed
     (cons 
       (cons 'list (loop for texpr in t0 collect (car texpr)))
       (list (list '|List| mUnder) e)))))))

@

\defun{compVector}{compVector}
\begin{verbatim}
;  null l => [$EmptyVector,m,e]
;  Tl:= [[.,mUnder,e]:= comp(x,mUnder,e) or return "failed" for x in l]
;  Tl="failed" => nil
;  [["VECTOR",:[T.expr for T in Tl]],m,e]
\end{verbatim}
\calls{compVector}{comp}
\usesdollar{compVector}{EmptyVector}
<<defun compVector>>=
(defun |compVector| (l m e)
 (let (tmp1 tmp2 t0 failed (mUnder (cadr m)))
  (declare (special |$EmptyVector|))
   (if (null l)
    (list |$EmptyVector| m e)
    (progn
     (setq t0
      (do ((t3 l (cdr t3)) (x nil))
          ((or (atom t3) failed) (unless failed (nreverse0 tmp2)))
        (setq x (car t3))
        (if (setq tmp1 (|comp| x mUnder e))
          (progn
           (setq mUnder (cadr tmp1))
           (setq e (caddr tmp1))
           (push tmp1 tmp2))
          (setq failed t))))
     (unless failed      
      (list (cons 'vector (loop for texpr in t0 collect (car texpr))) m e))))))

@
\defun{compExpression}{compExpression}
\calls{compExpression}{getl}
\calls{compExpression}{compForm}
\usesdollar{compExpression}{insideExpressionIfTrue}
<<defun compExpression>>=
(defun |compExpression| (x m e)
 (let (|$insideExpressionIfTrue| fn)
 (declare (special |$insideExpressionIfTrue|))
  (setq |$insideExpressionIfTrue| t)
  (if (and (atom (car x)) (setq fn (getl (car x) 'special)))
    (funcall fn x m e)
    (|compForm| x m e))))

@

\defun{compForm}{compForm}
\calls{compForm}{compForm1}
\calls{compForm}{compArgumentsAndTryAgain}
\calls{compForm}{stackMessageIfNone}
<<defun compForm>>=
(defun |compForm| (form m e)
 (cond
  ((|compForm1| form m e))
  ((|compArgumentsAndTryAgain| form m e))
  (t (|stackMessageIfNone| (list '|cannot compile| '|%b| form '|%d| )))))

@

\defun{compWithMappingMode}{compWithMappingMode}
\calls{compWithMappingMode}{compWithMappingMode1}
\usesdollar{compWithMappingMode}{formalArgList}
<<defun compWithMappingMode>>=
(defun |compWithMappingMode| (x m oldE)
  (declare (special |$formalArgList|))
  (|compWithMappingMode1| x m oldE |$formalArgList|))

@

\defun{compWithMappingMode1}{compWithMappingMode1}
\begin{verbatim}
;compWithMappingMode1(x,m is ["Mapping",m',:sl],oldE,$formalArgList) ==
;  $killOptimizeIfTrue: local:= true
;  e:= oldE
;  isFunctor x =>
;    if get(x,"modemap",$CategoryFrame) is [[[.,target,:argModeList],.],:.] and
;     (and/[extendsCategoryForm("$",s,mode) for mode in argModeList for s in sl]
;       ) and extendsCategoryForm("$",target,m') then return [x,m,e]
;  if STRINGP x then x:= INTERN x
;  ress:=nil
;  old_style:=true
;  if x is ["+->",vl,nx] then
;    old_style:=false
;    vl is [":",:.] =>
;      ress:=compLambda(x,m,oldE)
;      ress
;    vl:=
;      vl is ["Tuple",:vl1] => vl1
;      vl
;    vl:=
;      SYMBOLP(vl) => [vl]
;      LISTP(vl) and (and/[SYMBOLP(v) for v in vl]) => vl
;      stackAndThrow ["bad +-> arguments:",vl]
;    $formatArgList:=[:vl,:$formalArgList]
;    x:=nx
;  else
;    vl:=take(#sl,$FormalMapVariableList)
;  ress => ress
;  for m in sl for v in vl repeat
;    [.,.,e]:= compMakeDeclaration([":",v,m],$EmptyMode,e)
;  old_style and not null vl and not hasFormalMapVariable(x, vl) => return
;    [u,.,.] := comp([x,:vl],m',e) or return nil
;    extractCodeAndConstructTriple(u, m, oldE)
;  null vl and (t := comp([x], m', e)) => return
;    [u,.,.] := t
;    extractCodeAndConstructTriple(u, m, oldE)
;  [u,.,.]:= comp(x,m',e) or return nil
;  uu:=optimizeFunctionDef [nil,['LAMBDA,vl,u]]
;  --  At this point, we have a function that we would like to pass.
;  --  Unfortunately, it makes various free variable references outside
;  --  itself.  So we build a mini-vector that contains them all, and
;  --  pass this as the environment to our inner function.
;  $FUNNAME :local := nil
;  $FUNNAME__TAIL :local := [nil]
;  expandedFunction:=COMP_-TRAN CADR uu
;  frees:=freelist(expandedFunction,vl,nil,e)
;    where freelist(u,bound,free,e) ==
;      atom u =>
;        not IDENTP u => free
;        MEMQ(u,bound) => free
;        v:=ASSQ(u,free) =>
;          RPLACD(v,1+CDR v)
;          free
;        not getmode(u, e) => free
;        [[u,:1],:free]
;      op:=CAR u
;      MEMQ(op, '(QUOTE GO function)) => free
;      EQ(op,'LAMBDA) =>
;        bound:=UNIONQ(bound,CADR u)
;        for v in CDDR u repeat
;          free:=freelist(v,bound,free,e)
;        free
;      EQ(op,'PROG) =>
;        bound:=UNIONQ(bound,CADR u)
;        for v in CDDR u | NOT ATOM v repeat
;          free:=freelist(v,bound,free,e)
;        free
;      EQ(op,'SEQ) =>
;        for v in CDR u | NOT ATOM v repeat
;          free:=freelist(v,bound,free,e)
;        free
;      EQ(op,'COND) =>
;        for v in CDR u repeat
;          for vv in v repeat
;            free:=freelist(vv,bound,free,e)
;        free
;      if ATOM op then u:=CDR u  --Atomic functions aren't descended
;      for v in u repeat
;        free:=freelist(v,bound,free,e)
;      free
;  expandedFunction :=
;            --One free can go by itself, more than one needs a vector
;         --An A-list name . number of times used
;    #frees = 0 => ['LAMBDA,[:vl,"$$"], :CDDR expandedFunction]
;    #frees = 1 =>
;      vec:=first first frees
;      ['LAMBDA,[:vl,vec], :CDDR expandedFunction]
;    scode:=nil
;    vec:=nil
;    locals:=nil
;    i:=-1
;    for v in frees repeat
;      i:=i+1
;      vec:=[first v,:vec]
;      scode:=[['SETQ,first v,[($QuickCode => 'QREFELT;'ELT),"$$",i]],:scode]
;      locals:=[first v,:locals]
;    body:=CDDR expandedFunction
;    if locals then
;      if body is [['DECLARE,:.],:.] then
;        body:=[CAR body,['PROG,locals,:scode,['RETURN,['PROGN,:CDR body]]]]
;      else body:=[['PROG,locals,:scode,['RETURN,['PROGN,:body]]]]
;    vec:=['VECTOR,:NREVERSE vec]
;    ['LAMBDA,[:vl,"$$"],:body]
;  fname:=['CLOSEDFN,expandedFunction]
;         --Like QUOTE, but gets compiled
;  uu:=
;    frees => ['CONS,fname,vec]
;    ['LIST,fname]
;  [uu,m,oldE]
\end{verbatim}
\calls{compWithMappingMode1}{isFunctor}
\calls{compWithMappingMode1}{get}
\calls{compWithMappingMode1}{qcar}
\calls{compWithMappingMode1}{qcdr}
\calls{compWithMappingMode1}{extendsCategoryForm}
\calls{compWithMappingMode1}{compLambda}
\calls{compWithMappingMode1}{stackAndThrow}
\calls{compWithMappingMode1}{take}
\calls{compWithMappingMode1}{compMakeDeclaration}
\calls{compWithMappingMode1}{hasFormalMapVariable}
\calls{compWithMappingMode1}{comp}
\calls{compWithMappingMode1}{extractCodeAndConstructTriple}
\calls{compWithMappingMode1}{optimizeFunctionDef}
\calls{compWithMappingMode1}{comp-tran}
\calls{compWithMappingMode1}{freelist}
\usesdollar{compWithMappingMode1}{formalArgList}
\usesdollar{compWithMappingMode1}{killOptimizeIfTrue}
\usesdollar{compWithMappingMode1}{funname}
\usesdollar{compWithMappingMode1}{funnameTail}
\usesdollar{compWithMappingMode1}{QuickCode}
\usesdollar{compWithMappingMode1}{EmptyMode}
\usesdollar{compWithMappingMode1}{FormalMapVariableList}
\usesdollar{compWithMappingMode1}{CategoryFrame}
<<defun compWithMappingMode1>>=
(defun |compWithMappingMode1| (x m oldE |$formalArgList|)
 (declare (special |$formalArgList|))
  (prog (|$killOptimizeIfTrue| $funname $funnameTail mprime sl tmp1 tmp2 
         tmp3 tmp4 tmp5 tmp6 target argModeList nx oldstyle ress vl1 vl e tt
             u frees i scode locals body vec expandedFunction fname uu)
  (declare (special |$killOptimizeIfTrue| $funname $funnameTail
                    |$QuickCode| |$EmptyMode| |$FormalMapVariableList|
                    |$CategoryFrame|))
   (return
    (seq
     (progn
      (setq mprime (cadr m))
      (setq sl (cddr m))
      (setq |$killOptimizeIfTrue| t)
      (setq e oldE)
      (cond
       ((|isFunctor| x)
        (cond
         ((and (progn
                (setq tmp1 (|get| x '|modemap| |$CategoryFrame|))
                (and (pairp tmp1)
                     (progn
                      (setq tmp2 (qcar tmp1))
                      (and (pairp tmp2)
                           (progn
                            (setq tmp3 (qcar tmp2))
                            (and (pairp tmp3)
                                 (progn
                                  (setq tmp4 (qcdr tmp3))
                                  (and (pairp tmp4)
                                       (progn 
                                        (setq target (qcar tmp4))
                                        (setq argModeList (qcdr tmp4))
                                        t)))))
                           (progn
                            (setq tmp5 (qcdr tmp2))
                            (and (pairp tmp5) (eq (qcdr tmp5) nil)))))))
               (prog (t1)
                (setq t1 t)
                (return
                 (do ((t2 nil (null t1))
                      (t3 argModeList (cdr t3))
                      (mode nil)
                      (t4 sl (cdr t4))
                      (s nil))
                    ((or t2 (atom t3)
                         (progn (setq mode (car t3)) nil)
                         (atom t4)
                         (progn (setq s (car t4)) nil))
                        t1)
                   (seq (exit
                     (setq t1 
                      (and t1 (|extendsCategoryForm| '$ s mode))))))))
                        (|extendsCategoryForm| '$ target mprime))
               (return (list x m e )))
         (t nil)))
       (t 
        (when (stringp x) (setq x (intern x)))
        (setq ress nil) 
        (setq oldstyle t)
        (cond
         ((and (pairp x) 
               (eq (qcar x) '+->)
               (progn
                (setq tmp1 (qcdr x))
                (and (pairp tmp1)
                     (progn
                      (setq vl (qcar tmp1))
                      (setq tmp2 (qcdr tmp1))
                      (and (pairp tmp2)
                           (eq (qcdr tmp2) nil)
                           (progn (setq nx (qcar tmp2)) t))))))
            (setq oldstyle nil)
            (cond
             ((and (pairp vl) (eq (qcar vl) '|:|))
               (setq ress (|compLambda| x m oldE))
               ress)
             (t
              (setq vl
               (cond
                ((and (pairp vl)
                      (eq (qcar vl) '|@Tuple|)
                      (progn (setq vl1 (qcdr vl)) t))
                  vl1)
                (t vl)))
              (setq vl
               (cond
                ((symbolp vl) (cons vl nil))
                ((and 
                  (listp vl)
                  (prog (t5)
                   (setq t5 t)
                   (return
                    (do ((t7 nil (null t5))
                         (t6 vl (cdr t6))
                         (v nil))
                       ((or t7 (atom t6) (progn (setq v (car t6)) nil)) t5)
                      (seq
                       (exit
                        (setq t5 (and t5 (symbolp v)))))))))
                  vl)
                (t
                 (|stackAndThrow| (cons '|bad +-> arguments:| (list vl ))))))
              (setq |$formatArgList| (append vl |$formalArgList|))
              (setq x nx))))
         (t
          (setq vl (take (|#| sl) |$FormalMapVariableList|))))
        (cond
         (ress ress)
         (t
          (do ((t8 sl (cdr t8)) (m nil) (t9 vl (cdr t9)) (v nil))
              ((or (atom t8)
                   (progn (setq m (car t8)) nil)
                   (atom t9)
                   (progn (setq v (car t9)) nil))
                 nil)
              (seq (exit (progn
               (setq tmp6 
                (|compMakeDeclaration| (list '|:| v m ) |$EmptyMode| e))
               (setq e (caddr tmp6))
               tmp6))))
          (cond
           ((and oldstyle 
                 (null (null vl))
                 (null (|hasFormalMapVariable| x vl)))
            (return
             (progn
              (setq tmp6 (or (|comp| (cons x vl) mprime e) (return nil)))
              (setq u (car tmp6))
              (|extractCodeAndConstructTriple| u m oldE))))
           ((and (null vl) (setq tt (|comp| (cons x nil) mprime e)))
            (return
             (progn
               (setq u (car tt))
               (|extractCodeAndConstructTriple| u m oldE))))
           (t
            (setq tmp6 (or (|comp| x mprime e) (return nil)))
            (setq u (car tmp6))
            (setq uu (|optimizeFunctionDef| `(nil (lambda ,vl ,u))))
;  --  At this point, we have a function that we would like to pass.
;  --  Unfortunately, it makes various free variable references outside
;  --  itself.  So we build a mini-vector that contains them all, and
;  --  pass this as the environment to our inner function.
            (setq $funname nil)
            (setq $funnameTail (list nil))
            (setq expandedFunction (comp-tran (cadr uu)))
            (setq frees (freelist expandedFunction vl nil e))
            (setq expandedFunction
             (cond
              ((eql (|#| frees) 0)
               (cons 'lambda (cons (append vl (list '$$))
                                         (cddr expandedFunction))))
              ((eql (|#| frees) 1)
               (setq vec (caar frees))
                (cons 'lambda (cons (append vl (list vec))
                                         (cddr expandedFunction))))
              (t 
               (setq scode nil)
               (setq vec nil)
               (setq locals nil)
               (setq i -1)
               (do ((t0 frees (cdr t0)) (v nil))
                   ((or (atom t0) (progn (setq v (car t0)) nil)) nil)
                 (seq
                  (exit
                   (progn
                    (setq i (plus i 1))
                    (setq vec (cons (car v) vec))
                    (setq scode
                     (cons
                      (cons 'setq 
                       (cons (car v) 
                        (cons
                         (cons
                          (cond
                           (|$QuickCode| 'qrefelt)
                           (t 'elt))
                          (cons '$$ (cons i nil)))
                         nil)))
                       scode))
                    (setq locals (cons (car v) locals))))))
               (setq body (cddr expandedFunction))
               (cond
                (locals
                 (cond
                  ((and (pairp body)
                        (progn
                         (setq tmp1 (qcar body))
                         (and (pairp tmp1)
                              (eq (qcar tmp1) 'declare))))
                    (setq body
                     (cons (car body)
                      (cons
                       (cons 'prog
                        (cons locals
                         (append scode
                          (cons
                           (cons 'return
                            (cons
                             (cons 'progn
                              (cdr body))
                             nil))
                           nil))))
                        nil))))
                  (t
                   (setq body
                    (cons
                     (cons 'prog
                      (cons locals
                       (append scode
                        (cons
                         (cons 'return
                          (cons
                           (cons 'progn body)
                           nil))
                         nil))))
                     nil))))))
               (setq vec (cons 'vector (nreverse vec)))
               (cons 'lambda (cons (append vl (list '$$)) body)))))
            (setq fname (list 'closedfn expandedFunction))
            (setq uu
             (cond
              (frees (list 'cons fname vec))
              (t (list 'list fname))))
            (list uu m oldE))))))))))))

@

\defun{hasFormalMapVariable}{hasFormalMapVariable}
\calls{hasFormalMapVariable}{ScanOrPairVec}
\usesdollar{hasFormalMapVariable}{formalMapVariables}
<<defun hasFormalMapVariable>>=
(defun |hasFormalMapVariable| (x vl)
 (let (|$formalMapVariables|)
 (declare (special |$formalMapVariables|))
 (when (setq |$formalMapVariables| vl)
  (|ScanOrPairVec| #'(lambda (y) (member y |$formalMapVariables|)) x))))

@
\defun{compLambda}{compLambda}
\calls{compLambda}{qcar}
\calls{compLambda}{qcdr}
\calls{compLambda}{argsToSig}
\calls{compLambda}{compAtSign}
\calls{compLambda}{stackAndThrow}
<<defun compLambda>>=
(defun |compLambda| (x m e)
 (let (vl body tmp1 tmp2 tmp3 target a1 args arg1 sig1 ress)
  (setq vl (cadr x))
  (setq body (caddr x))
  (cond
   ((and (pairp vl) (eq (qcar vl) '|:|)
         (progn
          (setq tmp1 (qcdr vl))
          (and (pairp tmp1)
               (progn
                (setq args (qcar tmp1))
                (setq tmp2 (qcdr tmp1))
                (and (pairp tmp2)
                     (eq (qcdr tmp2) nil)
                     (progn
                      (setq target (qcar tmp2))
                      t))))))
     (when (and (pairp args) (eq (qcar args) '|@Tuple|))
      (setq args (qcdr args)))       
     (cond
      ((listp args)
       (setq tmp3 (|argsToSig| args))
       (setq arg1 (CAR tmp3))
       (setq sig1 (CADR tmp3))
       (cond
        (sig1 
         (setq ress
          (|compAtSign|
           (list '@
            (list '+-> arg1 body)
            (cons '|Mapping| (cons target sig1))) m e))
          (format t "TPDHERE4~%") 
          ress)
        (t (format t "TPDHERE1~%") (|stackAndThrow| (list '|compLambda| x )))))
      (t (format t "TPDHERE2~%") (|stackAndThrow| (list '|compLambda| x )))))
    (t (format t "TPDHERE3~%") (|stackAndThrow| (list '|compLambda| x ))))))

@

\defun{argsToSig}{argsToSig}
<<defun argsToSig>>=
(defun |argsToSig| (args)
 (let (tmp1 v tmp2 tt sig1 arg1 bad)
  (cond
   ((and (pairp args) (eq (qcar args) '|:|)
         (progn
          (setq tmp1 (qcdr args))
          (and (pairp tmp1)
               (progn
                (setq v (qcar tmp1))
                (setq tmp2 (qcdr tmp1))
                (and (pairp tmp2)
                     (eq (qcdr tmp2) nil)
                     (progn
                      (setq tt (qcar tmp2))
                      t))))))
    (list (list v) (list tt)))
   (t 
    (setq sig1 nil) 
    (setq arg1 nil)
    (setq bad nil)
    (dolist (arg args)
      (cond
       ((and (pairp arg) (eq (qcar arg) '|:|)
             (progn
              (setq tmp1 (qcdr arg))
              (and (pairp tmp1)
                   (progn
                    (setq v (qcar tmp1))
                    (setq tmp2 (qcdr tmp1))
                    (and (pairp tmp2) (eq (qcdr tmp2) nil)
                         (progn
                          (setq tt (qcar tmp2))
                          t))))))
         (setq sig1 (cons tt sig1))
         (setq arg1 (cons v arg1)))
        (t (setq bad t))))
    (cond
     (bad (list nil nil ))
     (t (list (reverse arg1) (reverse sig1))))))))

@

\defun{compMakeDeclaration}{compMakeDeclaration}
\calls{compMakeDeclaration}{compColon}
\usesdollar{compMakeDeclaration}{insideExpressionIfTrue}
<<defun compMakeDeclaration>>=
(defun |compMakeDeclaration| (x m e)
 (let (|$insideExpressionIfTrue|)
 (declare (special |$insideExpressionIfTrue|))
  (setq |$insideExpressionIfTrue| nil)
  (|compColon| x m e)))

@

\defun{freelist}{Create a list of unbound symbols}
We walk argument u looking for symbols that are unbound. If we find a
symbol we add it to the free list. If it occurs in a prog then it is
bound and we remove it from the free list. Multiple instances of a single
symbol in the free list are represented by the alist (symbol . count)
\calls{freelist}{freelist}
\calls{freelist}{assq}
\calls{freelist}{identp}
\calls{freelist}{getmode}
\calls{freelist}{unionq}
<<defun freelist>>=
(defun freelist (u bound free e)
 (let (v op)
  (if (atom u)
   (cond
    ((null (identp u)) free)
    ((member u bound) free)
    ; more than 1 free becomes alist (name . number)
    ((setq v (assq u free)) (rplacd v (+ 1 (cdr v))) free)
    ((null (|getmode| u e)) free)
    (t (cons (cons u 1) free)))
   (progn
    (setq op (car u))
    (cond
     ((member op '(quote go |function|)) free)
     ((eq op 'lambda) ; lambdas bind symbols
      (setq bound (unionq bound (cadr u)))
      (dolist (v (cddr u))
       (setq free (freelist v bound free e))))
     ((eq op 'prog) ; progs bind symbols
      (setq bound (unionq bound (cadr u)))
      (dolist (v (cddr u))
       (unless (atom v)
        (setq free (freelist v bound free e)))))
     ((eq op 'seq)
      (dolist (v (cdr u))
       (unless (atom v)
        (setq free (freelist v bound free e)))))
     ((eq op 'cond)
      (dolist (v (cdr u))
       (dolist (vv v)
        (setq free (freelist vv bound free e)))))
     (t
      (when (atom op) (setq u (cdr u))) ; atomic functions aren't descended
      (dolist (v u)
       (setq free (freelist v bound free e)))))
    free))))

@

\defun{compOrCroak1,compactify}{compOrCroak1,compactify}
\calls{compOrCroak1,compactify}{compOrCroak1,compactify}
\calls{compOrCroak1,compactify}{lassoc}
<<defun compOrCroak1,compactify>>=
(defun |compOrCroak1,compactify| (al)
 (cond
  ((null al) nil)
  ((lassoc (caar al) (cdr al)) (|compOrCroak1,compactify| (cdr al)))
  (t (cons (car al) (|compOrCroak1,compactify| (cdr al))))))

@

\defun{ncINTERPFILE}{Compiler/Interpreter interface}
\calls{ncINTERPFILE}{SpadInterpretStream(5)}
\usesdollar{ncINTERPFILE}{EchoLines}
\usesdollar{ncINTERPFILE}{ReadingFile}
<<defun ncINTERPFILE>>=
(defun |ncINTERPFILE| (file echo)
 (let ((|$EchoLines| echo) (|$ReadingFile| t))
 (declare (special |$EchoLines| |$ReadingFile|))
  (|SpadInterpretStream| 1 file nil)))

@

\defun{/RQ,LIB}{/RQ,LIB}
Compile a library quietly
\calls{/RQ,LIB}{/rf-1(5)}
\uses{/RQ,LIB}{echo-meta(5)}
\usesdollar{/RQ,LIB}{lisplib}
<<defun /RQ,LIB>>=
(defun |/RQ,LIB| (&rest foo &aux (echo-meta nil) ($lisplib t))
 (declare (special echo-meta $lisplib))
  (/rf-1 nil))

@

\defun{compileSpadLispCmd}{compileSpadLispCmd}
\calls{compileSpadLispCmd}{pathname(5)}
\calls{compileSpadLispCmd}{pathnameType(5)}
\calls{compileSpadLispCmd}{selectOptionLC(5)}
\calls{compileSpadLispCmd}{namestring(5)}
\calls{compileSpadLispCmd}{terminateSystemCommand(5)}
\calls{compileSpadLispCmd}{fnameMake(5)}
\calls{compileSpadLispCmd}{pathnameDirectory(5)}
\calls{compileSpadLispCmd}{pathnameName(5)}
\calls{compileSpadLispCmd}{fnameReadable?(5)}
\calls{compileSpadLispCmd}{localdatabase(5)}
\calls{compileSpadLispCmd}{throwKeyedMsg}
\calls{compileSpadLispCmd}{object2String}
\calls{compileSpadLispCmd}{sayKeyedMsg}
\calls{compileSpadLispCmd}{recompile-lib-file-if-necessary}
\calls{compileSpadLispCmd}{spadPrompt}
\usesdollar{compileSpadLispCmd}{options}
<<defun compileSpadLispCmd>>=
(defun |compileSpadLispCmd| (args)
 (let (path optlist optname optargs beQuiet dolibrary lsp)
  (declare (special |$options|))
  (setq path (|pathname| (|fnameMake| (car args) "code" "lsp")))
  (cond
   ((null (probe-file path))
     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
   (t
    (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
    (setq beQuiet nil)
    (setq dolibrary t)
    (dolist (opt |$options|)
      (setq optname (car opt))
      (setq optargs (cdr opt))
      (case (|selectOptionLC| optname optlist nil)
         (|quiet|     (setq beQuiet t))
         (|noquiet|   (setq beQuiet nil))
         (|library|   (setq dolibrary t))
         (|nolibrary| (setq dolibrary nil))
         (t
          (|throwKeyedMsg| 's2iz0036
           (list (strconc ")" (|object2String| optname)))))))
    (setq lsp
     (|fnameMake|
      (|pathnameDirectory| path)
      (|pathnameName| path)
      (|pathnameType| path)))
    (cond
     ((|fnameReadable?| lsp)
      (unless beQuiet (|sayKeyedMsg| 's2iz0089 (list (|namestring| lsp))))
       (recompile-lib-file-if-necessary lsp))
     (t
      (|sayKeyedMsg| 's2il0003 (list (|namestring| lsp)))))
    (cond
     (dolibrary
      (unless beQuiet (|sayKeyedMsg| 's2iz0090 (list (|pathnameName| path))))
      (localdatabase (list (|pathnameName| (car args))) nil))
     ((null beQuiet) (|sayKeyedMsg| 's2iz0084 nil))
     (t nil))
    (|terminateSystemCommand|)
    (|spadPrompt|)))))

@

\defun{recompile-lib-file-if-necessary}{recompile-lib-file-if-necessary}
\calls{recompile-lib-file-if-necessary}{compile-lib-file}
\uses{recompile-lib-file-if-necessary}{*lisp-bin-filetype*}
<<defun recompile-lib-file-if-necessary>>=
(defun recompile-lib-file-if-necessary (lfile)
 (let* ((bfile (make-pathname :type *lisp-bin-filetype* :defaults lfile))
        (bdate (and (probe-file bfile) (file-write-date bfile)))
        (ldate (and (probe-file lfile) (file-write-date lfile))))
  (unless (and ldate bdate (> bdate ldate))
   (compile-lib-file lfile)
   (list bfile))))

@

\defun{spad-fixed-arg}{spad-fixed-arg}
<<defun spad-fixed-arg>>=
(defun spad-fixed-arg (fname )
 (and (equal (symbol-package fname) (find-package "BOOT"))
      (not (get fname 'compiler::spad-var-arg))
      (search ";" (symbol-name fname))
      (or (get fname 'compiler::fixed-args)
          (setf (get fname 'compiler::fixed-args) t)))
   nil)

@

\defun{compile-lib-file}{compile-lib-file}
<<defun compile-lib-file>>=
(defun compile-lib-file (fn &rest opts)
 (unwind-protect
  (progn
   (trace (compiler::fast-link-proclaimed-type-p
           :exitcond nil
           :entrycond (spad-fixed-arg (car system::arglist))))
   (trace (compiler::t1defun 
           :exitcond nil
           :entrycond (spad-fixed-arg (caar system::arglist))))
   (apply #'compile-file fn opts))
  (untrace compiler::fast-link-proclaimed-type-p compiler::t1defun)))

@

\defun{compileAsharpCmd}{compileAsharpCmd}
<<defun compileAsharpCmd>>=
(defun |compileAsharpCmd| (args)
 (error "compileAsharpCmd is no longer supported"))

@

\defun{compileAsharpCmd1}{compileAsharpCmd1}
<<defun compileAsharpCmd1>>=
(defun |compileAsharpCmd1| (args)
 (error "compileAsharpCmd1 is no longer supported"))

@

\defun{compileAsharpArchiveCmd}{compileAsharpArchiveCmd}
<<defun compileAsharpArchiveCmd>>=
(defun |compileAsharpArchiveCmd| (args)
 (error "compileAsharpArchiveCmd is no longer supported"))

@

\defun{compileAsharpLispCmd}{compileAsharpLispCmd}
\calls{compileAsharpLispCmd}{error}
<<defun compileAsharpLispCmd>>=
(defun |compileAsharpLispCmd| (args)
 (error "compileAsharpLispCmd is no longer supported"))

@

\defun{withAsharpCmd}{withAsharpCmd}
<<defun withAsharpCmd>>=
(defun |withAsharpCmd| (args)
 (error "withAsharpCmd is no longer supported"))

@

\defun{compileFileQuietly}{compileFileQuietly}
if \verb|$InteractiveMode| then use a null outputstream 
\usesdollar{compileFileQuietly}{InteractiveMode}
\uses{compileFileQuietly}{*standard-output*}
<<defun compileFileQuietly>>=
(defun |compileFileQuietly| (fn) 
  (let (
         (*standard-output*
         (if |$InteractiveMode| (make-broadcast-stream)
           *standard-output*)))
  (declare (special *standard-output* |$InteractiveMode|))
  (compile-file fn)))

@
\defdollar{byConstructors}
<<initvars>>=
(defvar |$byConstructors| () "list of constructors to be compiled")

@
\defdollar{constructorsSeen}
<<initvars>>=
(defvar |$constructorsSeen| () "list of constructors found")

@
\chapter{The Compiler}
<<Compiler>>=
(in-package "BOOT")

<<initvars>>

<<defun argsToSig>>
<<defun comp>>
<<defun comp2>>
<<defun comp3>>
<<defun compAtom>>
<<defun compColon>>
<<defun compColonInside>>
<<defun compExpression>>
<<defun compForm>>
<<defun compLambda>>
<<defun compileAsharpArchiveCmd>>
<<defun compileAsharpCmd>>
<<defun compileAsharpCmd1>>
<<defun compileAsharpLispCmd>>
<<defun compileFileQuietly>>
<<defun compile-lib-file>>
<<defun compiler>>
<<defun compilerDoit>>
<<defun compileSpad2Cmd>>
<<defun compileSpadLispCmd>>
<<defun compList>>
<<defun compMakeDeclaration>>
<<defun compNoStacking>>
<<defun compNoStacking1>>
<<defun compOrCroak>>
<<defun compOrCroak1>>
<<defun compOrCroak1,compactify>>
<<defun compSymbol>>
<<defun compTopLevel>>
<<defun compVector>>
<<defun compWithMappingMode>>
<<defun compWithMappingMode1>>

<<defun freelist>>

<<defun hasFormalMapVariable>>

<<defun ncINTERPFILE>>

<<defun recompile-lib-file-if-necessary>>
<<defun /rf-1>>
<<defun /RQ,LIB>>

<<defun spad>>
<<defun spad-fixed-arg>>
<<defun s-process>>

<<defun withAsharpCmd>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} Jenks, R.J. and Sutor, R.S. 
``Axiom -- The Scientific Computation System''
Springer-Verlag New York (1992)
ISBN 0-387-97855-0
\bibitem{2} Knuth, Donald E., ``Literate Programming''
Center for the Study of Language and Information
ISBN 0-937073-81-4
Stanford CA (1992) 
\bibitem{3} Daly, Timothy, ``The Axiom Wiki Website''\\
{\bf http://axiom.axiom-developer.org}
\bibitem{4} Watt, Stephen, ``Aldor'',\\
{\bf http://www.aldor.org}
\bibitem{5} Lamport, Leslie, ``Latex -- A Document Preparation System'',
Addison-Wesley, New York ISBN 0-201-52983-1
\bibitem{6} Ramsey, Norman ``Noweb -- A Simple, Extensible Tool for
Literate Programming''\\
{\bf http://www.eecs.harvard.edu/ $\tilde{}$nr/noweb}
\bibitem{7} Daly, Timothy, "The Axiom Literate Documentation"\\
{\bf http://axiom.axiom-developer.org/axiom-website/documentation.html}
\end{thebibliography}
\chapter{Index}
\printindex
\end{document}
