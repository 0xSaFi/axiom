\documentclass[dvipdfm]{book}
\usepackage{hyperref}
\usepackage{axiom}
\usepackage{makeidx}
\makeindex
\usepackage{graphicx}
\begin{document}
\begin{titlepage}
\center{\includegraphics{ps/axiomfront.ps}}
\vskip 0.1in
\includegraphics{ps/bluebayou.ps}\\
\vskip 0.1in
{\Huge{The 30 Year Horizon}}
\vskip 0.1in
$$
\begin{array}{lll}
Manuel\ Bronstein      & William\ Burge   & Timothy\ Daly \\
James\ Davenport       & Michael\ Dewar   & Martin\ Dunstan \\
Albrecht\ Fortenbacher & Patrizia\ Gianni & Johannes\ Grabmeier \\
Jocelyn\ Guidry        & Richard\ Jenks   & Larry\ Lambe \\
Michael\ Monagan       & Scott\ Morrison  & William\ Sit \\
Jonathan\ Steinbach    & Robert\ Sutor    & Barry\ Trager \\
Stephen\ Watt          & Jim\ Wen         & Clifton\ Williamson
\end{array}
$$
\center{\large{Volume 9: Axiom Compiler}}
\end{titlepage}
\pagenumbering{roman}
\begin{verbatim}
Portions Copyright (c) 2005 Timothy Daly

The Blue Bayou image Copyright (c) 2004 Jocelyn Guidry

Portions Copyright (c) 2004 Martin Dunstan

Portions Copyright (c) 1991-2002, 
The Numerical ALgorithms Group Ltd.
All rights reserved.

This book and the Axiom software is licensed as follows:

Redistribution and use in source and binary forms, with or 
without modification, are permitted provided that the following 
conditions are
met:

    - Redistributions of source code must retain the above 
      copyright notice, this list of conditions and the 
      following disclaimer.

    - Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the 
      following disclaimer in the documentation and/or other 
      materials provided with the distribution.

    - Neither the name of The Numerical ALgorithms Group Ltd. 
      nor the names of its contributors may be used to endorse 
      or promote products derived from this software without 
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.

\end{verbatim}

Inclusion of names in the list of credits is based on historical
information and is as accurate as possible. Inclusion of names
does not in any way imply an endorsement but represents historical
influence on Axiom development.
\vfill
\eject
\begin{tabular}{lll}
Cyril Alberga         & Roy Adler             & Richard Anderson\\
George Andrews        & Henry Baker           & Stephen Balzac\\
Yurij Baransky        & David R. Barton       & Gerald Baumgartner\\
Gilbert Baumslag      & Fred Blair            & Vladimir Bondarenko\\
Mark Botch            & Alexandre Bouyer      & Peter A. Broadbery\\
Martin Brock          & Manuel Bronstein      & Florian Bundschuh\\
William Burge         & Quentin Carpent       & Bob Caviness\\
Bruce Char            & Cheekai Chin          & David V. Chudnovsky\\
Gregory V. Chudnovsky & Josh Cohen            & Christophe Conil\\
Don Coppersmith       & George Corliss        & Robert Corless\\
Gary Cornell          & Meino Cramer          & Claire Di Crescenzo\\
Timothy Daly Sr.      & Timothy Daly Jr.      & James H. Davenport\\
Jean Della Dora       & Gabriel Dos Reis      & Michael Dewar\\
Claire DiCrescendo    & Sam Dooley            & Lionel Ducos\\
Martin Dunstan        & Brian Dupee           & Dominique Duval\\
Robert Edwards        & Heow Eide-Goodman     & Lars Erickson\\
Richard Fateman       & Bertfried Fauser      & Stuart Feldman\\
Brian Ford            & Albrecht Fortenbacher & George Frances\\
Constantine Frangos   & Timothy Freeman       & Korrinn Fu\\
Marc Gaetano          & Rudiger Gebauer       & Kathy Gerber\\
Patricia Gianni       & Holger Gollan         & Teresa Gomez-Diaz\\
Laureano Gonzalez-Vega& Stephen Gortler       & Johannes Grabmeier\\
Matt Grayson          & James Griesmer        & Vladimir Grinberg\\
Oswald Gschnitzer     & Jocelyn Guidry        & Steve Hague\\
Vilya Harvey          & Satoshi Hamaguchi     & Martin Hassner\\
Ralf Hemmecke         & Henderson             & Antoine Hersen\\
Pietro Iglio          & Richard Jenks         & Kai Kaminski\\
Grant Keady           & Tony Kennedy          & Paul Kosinski\\
Klaus Kusche          & Bernhard Kutzler      & Larry Lambe\\
Frederic Lehobey      & Michel Levaud         & Howard Levy\\
Rudiger Loos          & Michael Lucks         & Richard Luczak\\
Camm Maguire          & Bob McElrath          & Michael McGettrick\\
Ian Meikle            & David Mentre          & Victor S. Miller\\
Gerard Milmeister     & Mohammed Mobarak      & H. Michael Moeller\\
Michael Monagan       & Marc Moreno-Maza      & Scott Morrison\\
Mark Murray           & William Naylor        & C. Andrew Neff\\
John Nelder           & Godfrey Nolan         & Arthur Norman\\
Jinzhong Niu          & Michael O'Connor      & Kostas Oikonomou\\
Julian A. Padget      & Bill Page             & Jaap Weel\\
Susan Pelzel          & Michel Petitot        & Didier Pinchon\\
Claude Quitte         & Norman Ramsey         & Michael Richardson\\
Renaud Rioboo         & Jean Rivlin           & Nicolas Robidoux\\
Simon Robinson        & Michael Rothstein     & Martin Rubey\\
Philip Santas         & Alfred Scheerhorn     & William Schelter\\
Gerhard Schneider     & Martin Schoenert      & Marshall Schor\\
Fritz Schwarz         & Nick Simicich         & William Sit\\
Elena Smirnova        & Jonathan Steinbach    & Christine Sundaresan\\
Robert Sutor          & Moss E. Sweedler      & Eugene Surowitz\\
James Thatcher        & Baldir Thomas         & Mike Thomas\\
Dylan Thurston        & Barry Trager          & Themos T. Tsikas\\
Gregory Vanuxem       & Bernhard Wall         & Stephen Watt\\
Juergen Weiss         & M. Weller             & Mark Wegman\\
James Wen             & Thorsten Werther      & Michael Wester\\
John M. Wiley         & Berhard Will          & Clifton J. Williamson\\
Stephen Wilson        & Shmuel Winograd       & Robert Wisbauer\\
Sandra Wityak         & Waldemar Wiwianka     & Knut Wolf\\
Clifford Yapp         & David Yun             & Richard Zippel\\
Evelyn Zoernack       & Bruno Zuercher        & Dan Zwillinger 
\end{tabular}
\eject
\tableofcontents
\vfill
\eject
\setlength{\parindent}{0em}
\setlength{\parskip}{1ex}
{\Large{\bf New Foreword}}
\vskip .25in

On October 1, 2001 Axiom was withdrawn from the market and ended
life as a commercial product.
On September 3, 2002 Axiom was released under the Modified BSD
license, including this document.
On August 27, 2003 Axiom was released as free and open source
software available for download from the Free Software Foundation's
website, Savannah.

Work on Axiom has had the generous support of the Center for 
Algorithms and Interactive Scientific Computation (CAISS) at
City College of New York. Special thanks go to Dr. Gilbert 
Baumslag for his support of the long term goal.

The online version of this documentation is roughly 1000 pages.
In order to make printed versions we've broken it up into three
volumes. The first volume is tutorial in nature. The second volume
is for programmers. The third volume is reference material. We've
also added a fourth volume for developers. All of these changes
represent an experiment in print-on-demand delivery of documentation.
Time will tell whether the experiment succeeded.

Axiom has been in existence for over thirty years. It is estimated to
contain about three hundred man-years of research and has, as of
September 3, 2003, 143 people listed in the credits. All of these
people have contributed directly or indirectly to making Axiom
available.  Axiom is being passed to the next generation. I'm looking
forward to future milestones.

With that in mind I've introduced the theme of the ``30 year horizon''.
We must invent the tools that support the Computational Mathematician
working 30 years from now. How will research be done when every bit of
mathematical knowledge is online and instantly available? What happens
when we scale Axiom by a factor of 100, giving us 1.1 million domains?
How can we integrate theory with code? How will we integrate theorems
and proofs of the mathematics with space-time complexity proofs and
running code? What visualization tools are needed? How do we support
the conceptual structures and semantics of mathematics in effective
ways? How do we support results from the sciences? How do we teach
the next generation to be effective Computational Mathematicians?

The ``30 year horizon'' is much nearer than it appears.

\vskip .25in
%\noindent
Tim Daly\\
CAISS, City College of New York\\
November 10, 2003 ((iHy))
\vfill
\eject
\pagenumbering{arabic}
\setcounter{chapter}{0} % Chapter 1
\section{Makefile}
This book is actually a literate program\cite{2} and can contain 
executable source code. In particular, the Makefile for this book
is part of the source of the book and is included below. Axiom 
uses the ``noweb'' literate programming system by Norman Ramsey\cite{6}.
\chapter{Compiler top level}
\section{)compile}
This is the implementation of the )compile command.

You use this command to invoke the new Axiom library compiler or the
old Axiom system compiler.  The {\tt )compile} system command is
actually a combination of Axiom processing and a call to the Aldor
compiler.  It is performing double-duty, acting as a front-end to both
the Aldor compiler and the old Axiom system compiler.  (The old Axiom
system compiler was written in Lisp and was an integral part of the
Axiom environment.  The Aldor compiler is written in C and executed by
the operating system when called from within Axiom.)

\par\noindent{\bf User Level Required:} compiler

\par\noindent{\bf Command Syntax:}

\begin{list}{}
\item {\tt )compile}
\item {\tt )compile {\it fileName}}
\item {\tt )compile {\it fileName}.spad}
\item {\tt )compile {\it directory/fileName}.spad}
\item {\tt )compile {\it fileName} )old}
\item {\tt )compile {\it fileName} )translate}
\item {\tt )compile {\it fileName} )quiet}
\item {\tt )compile {\it fileName} )noquiet}
\item {\tt )compile {\it fileName} )moreargs}
\item {\tt )compile {\it fileName} )onlyargs}
\item {\tt )compile {\it fileName} )break}
\item {\tt )compile {\it fileName} )nobreak}
\item {\tt )compile {\it fileName} )library}
\item {\tt )compile {\it fileName} )nolibrary}
\item {\tt )compile {\it fileName} )vartrace}
\item {\tt )compile {\it fileName} )constructor} {\it nameOrAbbrev}
\end{list}

These command forms invoke the Aldor compiler.
\begin{list}{}
\item {\tt )compile {\it fileName}.as}
\item {\tt )compile {\it directory/fileName}.as}
\item {\tt )compile {\it fileName}.ao}
\item {\tt )compile {\it directory/fileName}.ao}
\item {\tt )compile {\it fileName}.al}
\item {\tt )compile {\it directory/fileName}.al}
\item {\tt )compile {\it fileName}.lsp}
\item {\tt )compile {\it directory/fileName}.lsp}
\item {\tt )compile {\it fileName} )new}
\end{list}

\par\noindent{\bf Command Description:}

The first thing {\tt )compile} does is look for a source code
filename among its arguments.
Thus
\begin{verbatim}
)compile mycode.spad
)compile /u/jones/mycode.spad
)compile mycode
\end{verbatim}
all invoke {\tt )compiler} on the file {\tt
/u/jones/mycode.spad} if the current Axiom working
directory is {\tt /u/jones.} (Recall that you can set the
working directory via the {\tt )cd} command. If you don't set it
explicitly, it is the directory from which you started
Axiom.)

If you omit the file extension, the command looks to see if you have
specified the {\tt )new} or {\tt )old} option.  If you have given one
of these options, the corresponding compiler is used.

The command first looks in the standard system directories for files
with extension {\it .as, .ao} and {\it .al} and then files with
extension {\it .spad}.  The first file found has the appropriate
compiler invoked on it.  If the command cannot find a matching file,
an error message is displayed and the command terminates.

The first thing {\tt )compile} does is look for a source code
filename among its arguments.
Thus
\begin{verbatim}
)compile mycode
)co mycode
)co mycode.spad
\end{verbatim}
all invoke {\tt )compiler} on the file {\tt
/u/jones/mycode.spad} if the current Axiom working
directory is {\tt /u/jones.} Recall that you can set the
working directory via the {\tt )cd} command. If you don't set it
explicitly, it is the directory from which you started
Axiom.

This is frequently all you need to compile your file.

This simple command:
\begin{enumerate}
\item Invokes the Spad compiler and produces Lisp output.
\item Calls the Lisp compiler if the compilation was successful.
\item Uses the {\tt )library} command to tell Axiom about
the contents of your compiled file and arrange to have those
contents loaded on demand.
\end{enumerate}

Should you not want the {\tt )library} command automatically
invoked, call {\tt )compile} with the {\tt )nolibrary} option.
For example,
\begin{verbatim}
)compile mycode )nolibrary
\end{verbatim}

By default, the {\tt )library} system command {\it exposes} all
domains and categories it processes.
This means that the Axiom intepreter will consider those domains and 
categories when it is trying to resolve a reference to a function.
Sometimes domains and categories should not be exposed.
For example, a domain may just be used privately by another
domain and may not be meant for top-level use.
The {\tt )library} command should still be used, though, so that
the code will be loaded on demand.
In this case, you should use the {\tt )nolibrary} option on {\tt
)compile} and the {\tt )noexpose} option in the {\tt )library}
command. For example,
\begin{verbatim}
)compile mycode )nolibrary
)library mycode )noexpose
\end{verbatim}

Once you have established your own collection of compiled code,
you may find it handy to use the {\tt )dir} option on the
{\tt )library} command.
This causes {\tt )library} to process all compiled code in the
specified directory. For example,
\begin{verbatim}
)library )dir /u/jones/quantum
\end{verbatim}
You must give an explicit directory after {\tt )dir}, even if you
want all compiled code in the current working directory
processed, e.g.
\begin{verbatim}
)library )dir .
\end{verbatim}

\subsection{Spad compiler}
This command compiles files with file extension {\tt .spad}
with the Spad system compiler.  

The {\tt )translate} option is used to invoke a special version of the
old system compiler that will translate a {\it .spad} file to a {\it
.as} file.  That is, the {\it .spad} file will be parsed and analyzed
and a file using the new syntax will be created.

By default, the {\it .as} file is created in the same directory as the
{\it .spad} file. If that directory is not writable, the current
directory is used. If the current directory is not writable, an error
message is given and the command terminates.  Note that {\tt )translate} 
implies the {\tt )old} option so the file extension can
safely be omitted. If {\tt )translate} is given, all other options are
ignored.  Please be aware that the translation is not necessarily one
hundred percent complete or correct.  You should attempt to compile
the output with the Aldor compiler and make any necessary corrections.

You can compile category, domain, and package constructors contained
in files with file extension {\it .spad}.  You can compile individual
constructors or every constructor in a file.

The full filename is remembered between invocations of this command and
{\tt )edit} commands. The sequence of commands
\begin{verbatim}
)compile matrix.spad
)edit
)compile
\end{verbatim}
will call the compiler, edit, and then call the compiler again on the
file {\bf matrix.spad.}  If you do not specify a {\it directory,} the
working current directory is searched for the file.  If the file is
not found, the standard system directories are searched.

If you do not give any options, all constructors within a file are
compiled.  Each constructor should have an {\tt )abbreviation} command
in the file in which it is defined.  We suggest that you place the
{\tt )abbreviation} commands at the top of the file in the order in
which the constructors are defined.

The {\tt )library} option causes directories containing the compiled
code for each constructor to be created in the working current
directory.  The name of such a directory consists of the constructor
abbreviation and the {\bf .nrlib} file extension.  For example, the
directory containing the compiled code for the {\tt MATRIX}
constructor is called {\bf MATRIX.nrlib.}  The {\tt )nolibrary} option
says that such files should not be created.  The default is 
{\tt )library.}  Note that the semantics of {\tt )library} and 
{\tt )nolibrary} for the new Aldor compiler and for the old system 
compiler are completely different.

The {\tt )vartrace} option causes the compiler to generate
extra code for the constructor to support conditional tracing of
variable assignments. (see 
\ref{ugSysCmdtrace} on page~\pageref{ugSysCmdtrace}). Without
this option, this code is suppressed and one cannot use
the {\tt )vars} option for the trace command.

The {\tt )constructor} option is used to
specify a particular constructor to compile.
All other constructors in the file are ignored.
The constructor name or abbreviation follows {\tt )constructor.}
Thus either
\begin{verbatim}
)compile matrix.spad )constructor RectangularMatrix
\end{verbatim}
or
\begin{verbatim}
)compile matrix.spad )constructor RMATRIX
\end{verbatim}
compiles  the {\tt RectangularMatrix} constructor
defined in {\bf matrix.spad.}

The {\tt )break} and {\tt )nobreak} options determine what
the spad compiler does when it encounters an error.
{\tt )break} is the default and it indicates that processing
should stop at the first error.
The value of the {\tt )set break} variable then controls what happens.

\chapter{The Parser}
\section{EQ.spad}
We will explain the compilation function using the file {\tt EQ.spad}.
We trace the execution of the various functions to understand the actual
call parameters and results returned. The {\tt EQ.spad} file is:
\begin{verbatim}
)abbrev domain EQ Equation
--FOR THE BENEFIT  OF LIBAX0 GENERATION
++ Author: Stephen M. Watt, enhancements by Johannes Grabmeier
++ Date Created: April 1985
++ Date Last Updated: June 3, 1991; September 2, 1992
++ Basic Operations: =
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++ Equations as mathematical objects.  All properties of the basis domain,
++ e.g. being an abelian group are carried over the equation domain, by
++ performing the structural operations on the left and on the
++ right hand side.
--   The interpreter translates "=" to "equation".  Otherwise, it will
--   find a modemap for "=" in the domain of the arguments.

Equation(S: Type): public == private where
  Ex ==> OutputForm
  public ==> Type with
    "=": (S, S) -> $
        ++ a=b creates an equation.
    equation: (S, S) -> $
        ++ equation(a,b) creates an equation.
    swap: $ -> $
        ++ swap(eq) interchanges left and right hand side of equation eq.
    lhs: $ -> S
        ++ lhs(eqn) returns the left hand side of equation eqn.
    rhs: $ -> S
        ++ rhs(eqn) returns the right hand side of equation eqn.
    map: (S -> S, $) -> $
        ++ map(f,eqn) constructs a new equation by applying f to both
        ++ sides of eqn.
    if S has InnerEvalable(Symbol,S) then
             InnerEvalable(Symbol,S)
    if S has SetCategory then
        SetCategory
        CoercibleTo Boolean
        if S has Evalable(S) then
           eval: ($, $) -> $
               ++ eval(eqn, x=f) replaces x by f in equation eqn.
           eval: ($, List $) -> $
               ++ eval(eqn, [x1=v1, ... xn=vn]) replaces xi by vi in equation eqn.
    if S has AbelianSemiGroup then
        AbelianSemiGroup
        "+": (S, $) -> $
            ++ x+eqn produces a new equation by adding x to both sides of
            ++ equation eqn.
        "+": ($, S) -> $
            ++ eqn+x produces a new equation by adding x to  both sides of
            ++ equation eqn.
    if S has AbelianGroup then
        AbelianGroup
        leftZero : $ -> $
          ++ leftZero(eq) subtracts the left hand side.
        rightZero : $ -> $
          ++ rightZero(eq) subtracts the right hand side.
        "-": (S, $) -> $
            ++ x-eqn produces a new equation by subtracting both sides of
            ++ equation eqn from x.
        "-": ($, S) -> $
            ++ eqn-x produces a new equation by subtracting x from  both sides of
            ++ equation eqn.
    if S has SemiGroup then
        SemiGroup
        "*": (S, $) -> $
            ++ x*eqn produces a new equation by multiplying both sides of
            ++ equation eqn by x.
        "*": ($, S) -> $
            ++ eqn*x produces a new equation by multiplying both sides of
            ++ equation eqn by x.
    if S has Monoid then
        Monoid
        leftOne : $ -> Union($,"failed")
          ++ leftOne(eq) divides by the left hand side, if possible.
        rightOne : $ -> Union($,"failed")
          ++ rightOne(eq) divides by the right hand side, if possible.
    if S has Group then
        Group
        leftOne : $ -> Union($,"failed")
          ++ leftOne(eq) divides by the left hand side.
        rightOne : $ -> Union($,"failed")
          ++ rightOne(eq) divides by the right hand side.
    if S has Ring then
      Ring
      BiModule(S,S)
    if S has CommutativeRing then
      Module(S)
      --Algebra(S)
    if S has IntegralDomain then
      factorAndSplit : $ -> List $
        ++ factorAndSplit(eq) make the right hand side 0 and
        ++ factors the new left hand side. Each factor is equated
        ++ to 0 and put into the resulting list without repetitions.
    if S has PartialDifferentialRing(Symbol) then
      PartialDifferentialRing(Symbol)
    if S has Field then
      VectorSpace(S)
      "/": ($, $) -> $
          ++ e1/e2 produces a new equation by dividing the left and right
          ++ hand sides of equations e1 and e2.
      inv: $ -> $
          ++ inv(x) returns the multiplicative inverse of x.
    if S has ExpressionSpace then
        subst: ($, $) -> $
             ++ subst(eq1,eq2) substitutes eq2 into both sides of eq1
             ++ the lhs of eq2 should be a kernel

  private ==> add
    Rep := Record(lhs: S, rhs: S)
    eq1,eq2: $
    s : S
    if S has IntegralDomain then
        factorAndSplit eq ==
          (S has factor : S -> Factored S) =>
            eq0 := rightZero eq
            [equation(rcf.factor,0) for rcf in factors factor lhs eq0]
          [eq]
    l:S = r:S      == [l, r]
    equation(l, r) == [l, r]    -- hack!  See comment above.
    lhs eqn        == eqn.lhs
    rhs eqn        == eqn.rhs
    swap eqn     == [rhs eqn, lhs eqn]
    map(fn, eqn)   == equation(fn(eqn.lhs), fn(eqn.rhs))

    if S has InnerEvalable(Symbol,S) then
        s:Symbol
        ls:List Symbol
        x:S
        lx:List S
        eval(eqn,s,x) == eval(eqn.lhs,s,x) = eval(eqn.rhs,s,x)
        eval(eqn,ls,lx) == eval(eqn.lhs,ls,lx) = eval(eqn.rhs,ls,lx)
    if S has Evalable(S) then
        eval(eqn1:$, eqn2:$):$ ==
           eval(eqn1.lhs, eqn2 pretend Equation S) =
               eval(eqn1.rhs, eqn2 pretend Equation S)
        eval(eqn1:$, leqn2:List $):$ ==
           eval(eqn1.lhs, leqn2 pretend List Equation S) =
               eval(eqn1.rhs, leqn2 pretend List Equation S)
    if S has SetCategory then
        eq1 = eq2 == (eq1.lhs = eq2.lhs)@Boolean and
                     (eq1.rhs = eq2.rhs)@Boolean
        coerce(eqn:$):Ex == eqn.lhs::Ex = eqn.rhs::Ex
        coerce(eqn:$):Boolean == eqn.lhs = eqn.rhs
    if S has AbelianSemiGroup then
        eq1 + eq2 == eq1.lhs + eq2.lhs = eq1.rhs + eq2.rhs
        s + eq2 == [s,s] + eq2
        eq1 + s == eq1 + [s,s]
    if S has AbelianGroup then
        - eq == (- lhs eq) = (-rhs eq)
        s - eq2 == [s,s] - eq2
        eq1 - s == eq1 - [s,s]
        leftZero eq == 0 = rhs eq - lhs eq
        rightZero eq == lhs eq - rhs eq = 0
        0 == equation(0$S,0$S)
        eq1 - eq2 == eq1.lhs - eq2.lhs = eq1.rhs - eq2.rhs
    if S has SemiGroup then
        eq1:$ * eq2:$ == eq1.lhs * eq2.lhs = eq1.rhs * eq2.rhs
        l:S   * eqn:$ == l       * eqn.lhs = l       * eqn.rhs
        l:S * eqn:$  ==  l * eqn.lhs    =    l * eqn.rhs
        eqn:$ * l:S  ==  eqn.lhs * l    =    eqn.rhs * l
        -- We have to be a bit careful here: raising to a +ve integer is OK
        -- (since it's the equivalent of repeated multiplication)
        -- but other powers may cause contradictions
        -- Watch what else you add here! JHD 2/Aug 1990
    if S has Monoid then
        1 == equation(1$S,1$S)
        recip eq ==
          (lh := recip lhs eq) case "failed" => "failed"
          (rh := recip rhs eq) case "failed" => "failed"
          [lh :: S, rh :: S]
        leftOne eq ==
          (re := recip lhs eq) case "failed" => "failed"
          1 = rhs eq * re
        rightOne eq ==
          (re := recip rhs eq) case "failed" => "failed"
          lhs eq * re = 1
    if S has Group then
        inv eq == [inv lhs eq, inv rhs eq]
        leftOne eq == 1 = rhs eq * inv rhs eq
        rightOne eq == lhs eq * inv rhs eq = 1
    if S has Ring then
        characteristic() == characteristic()$S
        i:Integer * eq:$ == (i::S) * eq
    if S has IntegralDomain then
        factorAndSplit eq ==
          (S has factor : S -> Factored S) =>
            eq0 := rightZero eq
            [equation(rcf.factor,0) for rcf in factors factor lhs eq0]
          (S has Polynomial Integer) =>
            eq0 := rightZero eq
            MF ==> MultivariateFactorize(Symbol, IndexedExponents Symbol, _
               Integer, Polynomial Integer)
            p : Polynomial Integer := (lhs eq0) pretend Polynomial Integer
            [equation((rcf.factor) pretend S,0) for rcf in factors factor(p)$MF]
          [eq]
    if S has PartialDifferentialRing(Symbol) then
        differentiate(eq:$, sym:Symbol):$ ==
           [differentiate(lhs eq, sym), differentiate(rhs eq, sym)]
    if S has Field then
        dimension() == 2 :: CardinalNumber
        eq1:$ / eq2:$ == eq1.lhs / eq2.lhs = eq1.rhs / eq2.rhs
        inv eq == [inv lhs eq, inv rhs eq]
    if S has ExpressionSpace then
        subst(eq1,eq2) ==
            eq3 := eq2 pretend Equation S
            [subst(lhs eq1,eq3),subst(rhs eq1,eq3)]

\end{verbatim}

<<initvars>>=
(defvar $index 0 "File line number of most recently read line")

@

<<initvars>>=
(defvar $linelist nil "Stack of preparsed lines")

@

<<initvars>>=
(defvar $echolinestack nil "Stack of lines to list")

@

<<initvars>>=
(defvar $preparse-last-line nil "Most recently read line")

@

\section{Parsing routines}
The {\bf initialize-preparse} expects to be called before the {\bf preparse}
function. It initializes the state, in particular, it reads a single line
from the input stream and stores it in {\tt \verb|$preparse-last-line|}.
The caller gives a stream and the {\tt \verb|$preparse-last-line|} variable
is initialized as:
\begin{verbatim}
    2> (INITIALIZE-PREPARSE #<input stream "/tmp/EQ.spad">)
    <2 (INITIALIZE-PREPARSE ")abbrev domain EQ Equation")
\end{verbatim}
\defun{initialize-preparse}{initialize-preparse}
\calls{initialize-preparse}{get-a-line}
\usesdollar{initialize-preparse}{index}
\usesdollar{initialize-preparse}{linelist}
\usesdollar{initialize-preparse}{echolinestack}
\usesdollar{initialize-preparse}{preparse-last-line}
<<defun initialize-preparse>>=
(defun initialize-preparse (strm)
  (setq $index 0)
  (setq $linelist nil)
  (setq $echolinestack nil)
  (setq $preparse-last-line (get-a-line strm)))

@

The {\bf preparse} function returns a list of pairs of the form:
( (linenumber . linestring) .... (linenumber . linestring))
For instance, for the file {\tt EQ.spad}, we get:
\begin{verbatim}
    2> (PREPARSE #<input stream "/tmp/EQ.spad">)
      3> (PREPARSE1 (")abbrev domain EQ Equation"))
        4> (|doSystemCommand| "abbrev domain EQ Equation")
        <4 (|doSystemCommand| NIL)
      <3 (PREPARSE1 ( ...[snip]... )
     <2 (PREPARSE (
 (19 . "Equation(S: Type): public == private where")
 (20 . " (Ex ==> OutputForm;")
 (21 . "  public ==> Type with")
 (22 . "   (\"=\": (S, S) -> $;")
 (24 . "    equation: (S, S) -> $;")
 (26 . "    swap: $ -> $;")
 (28 . "    lhs: $ -> S;")
 (30 . "    rhs: $ -> S;")
 (32 . "    map: (S -> S, $) -> $;")
 (35 . "    if S has InnerEvalable(Symbol,S) then")
 (36 . "             InnerEvalable(Symbol,S);")
 (37 . "    if S has SetCategory then")
 (38 . "       (SetCategory;")
 (39 . "        CoercibleTo Boolean;")
 (40 . "        if S has Evalable(S) then")
 (41 . "          (eval: ($, $) -> $;")
 (43 . "           eval: ($, List $) -> $));")
 (45 . "    if S has AbelianSemiGroup then")
 (46 . "       (AbelianSemiGroup;")
 (47 . "        \"+\": (S, $) -> $;")
 (50 . "        \"+\": ($, S) -> $);")
 (53 . "    if S has AbelianGroup then")
 (54 . "       (AbelianGroup;")
 (55 . "        leftZero : $ -> $;")
 (57 . "        rightZero : $ -> $;")
 (59 . "        \"-\": (S, $) -> $;")
 (62 . "        \"-\": ($, S) -> $);")
 (65 . "    if S has SemiGroup then")
 (66 . "       (SemiGroup;")
 (67 . "        \"*\": (S, $) -> $;")
 (70 . "        \"*\": ($, S) -> $);")
 (73 . "    if S has Monoid then")
 (74 . "       (Monoid;")
 (75 . "        leftOne : $ -> Union($,\"failed\");")
 (77 . "        rightOne : $ -> Union($,\"failed\"));")
 (79 . "    if S has Group then")
 (80 . "       (Group;")
 (81 . "        leftOne : $ -> Union($,\"failed\");")
 (83 . "        rightOne : $ -> Union($,\"failed\"));")
 (85 . "    if S has Ring then")
 (86 . "     (Ring;")
 (87 . "      BiModule(S,S));")
 (88 . "    if S has CommutativeRing then")
 (89 . "      Module(S);")
 (91 . "    if S has IntegralDomain then")
 (92 . "      factorAndSplit : $ -> List $;")
 (96 . "    if S has PartialDifferentialRing(Symbol) then")
 (97 . "      PartialDifferentialRing(Symbol);")
 (98 . "    if S has Field then")
 (99 . "     (VectorSpace(S);")
 (100 . "      \"/\": ($, $) -> $;")
 (103 . "      inv: $ -> $);")
 (105 . "    if S has ExpressionSpace then")
 (106 . "        subst: ($, $) -> $);")
 (109 . "  private ==> add")
 (110 . "   (Rep := Record(lhs: S, rhs: S);")
 (111 . "    eq1,eq2: $;")
 (112 . "    s : S;")
 (113 . "    if S has IntegralDomain then")
 (114 . "        factorAndSplit eq ==")
 (115 . "         ((S has factor : S -> Factored S) =>")
 (116 . "           (eq0 := rightZero eq;")
 (117 . "            [equation(rcf.factor,0) 
                       for rcf in factors factor lhs eq0]);")
 (118 . "          [eq]);")
 (119 . "    l:S = r:S      == [l, r];")
 (120 . "    equation(l, r) == [l, r];")
 (121 . "    lhs eqn        == eqn.lhs;")
 (122 . "    rhs eqn        == eqn.rhs;")
 (123 . "    swap eqn     == [rhs eqn, lhs eqn];")
 (124 . "    map(fn, eqn)   == equation(fn(eqn.lhs), fn(eqn.rhs));")
 (125 . "    if S has InnerEvalable(Symbol,S) then")
 (126 . "       (s:Symbol;")
 (127 . "        ls:List Symbol;")
 (128 . "        x:S;")
 (129 . "        lx:List S;")
 (130 . "        eval(eqn,s,x) == eval(eqn.lhs,s,x) = eval(eqn.rhs,s,x);")
 (131 . "        eval(eqn,ls,lx) == eval(eqn.lhs,ls,lx) = 
                                     eval(eqn.rhs,ls,lx));")
 (132 . "    if S has Evalable(S) then")
 (133 . "       (eval(eqn1:$, eqn2:$):$ ==")
 (134 . "           eval(eqn1.lhs, eqn2 pretend Equation S) =")
 (135 . "               eval(eqn1.rhs, eqn2 pretend Equation S);")
 (136 . "        eval(eqn1:$, leqn2:List $):$ ==")
 (137 . "           eval(eqn1.lhs, leqn2 pretend List Equation S) =")
 (138 . "               eval(eqn1.rhs, leqn2 pretend List Equation S));")
 (139 . "    if S has SetCategory then")
 (140 . "       (eq1 = eq2 == (eq1.lhs = eq2.lhs)@Boolean and")
 (141 . "                     (eq1.rhs = eq2.rhs)@Boolean;")
 (142 . "        coerce(eqn:$):Ex == eqn.lhs::Ex = eqn.rhs::Ex;")
 (143 . "        coerce(eqn:$):Boolean == eqn.lhs = eqn.rhs);")
 (144 . "    if S has AbelianSemiGroup then")
 (145 . "       (eq1 + eq2 == eq1.lhs + eq2.lhs = eq1.rhs + eq2.rhs;")
 (146 . "        s + eq2 == [s,s] + eq2;")
 (147 . "        eq1 + s == eq1 + [s,s]);")
 (148 . "    if S has AbelianGroup then")
 (149 . "       (- eq == (- lhs eq) = (-rhs eq);")
 (150 . "        s - eq2 == [s,s] - eq2;")
 (151 . "        eq1 - s == eq1 - [s,s];")
 (152 . "        leftZero eq == 0 = rhs eq - lhs eq;")
 (153 . "        rightZero eq == lhs eq - rhs eq = 0;")
 (154 . "        0 == equation(0$S,0$S);")
 (155 . "        eq1 - eq2 == eq1.lhs - eq2.lhs = eq1.rhs - eq2.rhs);")
 (156 . "    if S has SemiGroup then")
 (157 . "       (eq1:$ * eq2:$ == eq1.lhs * eq2.lhs = eq1.rhs * eq2.rhs;")
 (158 . "        l:S   * eqn:$ == l       * eqn.lhs = l       * eqn.rhs;")
 (159 . "        l:S * eqn:$  ==  l * eqn.lhs    =    l * eqn.rhs;")
 (160 . "        eqn:$ * l:S  ==  eqn.lhs * l    =    eqn.rhs * l);")
 (165 . "    if S has Monoid then")
 (166 . "       (1 == equation(1$S,1$S);")
 (167 . "        recip eq ==")
 (168 . "         ((lh := recip lhs eq) case \"failed\" => \"failed\";")
 (169 . "          (rh := recip rhs eq) case \"failed\" => \"failed\";")
 (170 . "          [lh :: S, rh :: S]);")
 (171 . "        leftOne eq ==")
 (172 . "         ((re := recip lhs eq) case \"failed\" => \"failed\";")
 (173 . "          1 = rhs eq * re);")
 (174 . "        rightOne eq ==")
 (175 . "         ((re := recip rhs eq) case \"failed\" => \"failed\";")
 (176 . "          lhs eq * re = 1));")
 (177 . "    if S has Group then")
 (178 . "       (inv eq == [inv lhs eq, inv rhs eq];")
 (179 . "        leftOne eq == 1 = rhs eq * inv rhs eq;")
 (180 . "        rightOne eq == lhs eq * inv rhs eq = 1);")
 (181 . "    if S has Ring then")
 (182 . "       (characteristic() == characteristic()$S;")
 (183 . "        i:Integer * eq:$ == (i::S) * eq);")
 (184 . "    if S has IntegralDomain then")
 (185 . "        factorAndSplit eq ==")
 (186 . "         ((S has factor : S -> Factored S) =>")
 (187 . "           (eq0 := rightZero eq;")
 (188 . "            [equation(rcf.factor,0) 
                         for rcf in factors factor lhs eq0]);")
 (189 . "          (S has Polynomial Integer) =>")
 (190 . "           (eq0 := rightZero eq;")
 (191 . "            MF ==> MultivariateFactorize(Symbol, 
                                IndexedExponents Symbol,
                                Integer, Polynomial Integer);")
 (193 . "            p : Polynomial Integer := 
                           (lhs eq0) pretend Polynomial Integer;")
 (194 . "            [equation((rcf.factor) pretend S,0) 
                           for rcf in factors factor(p)$MF]);")
 (195 . "          [eq]);")
 (196 . "    if S has PartialDifferentialRing(Symbol) then")
 (197 . "        differentiate(eq:$, sym:Symbol):$ ==")
 (198 . "           [differentiate(lhs eq, sym), differentiate(rhs eq, sym)];")
 (199 . "    if S has Field then")
 (200 . "       (dimension() == 2 :: CardinalNumber;")
 (201 . "        eq1:$ / eq2:$ == eq1.lhs / eq2.lhs = eq1.rhs / eq2.rhs;")
 (202 . "        inv eq == [inv lhs eq, inv rhs eq]);")
 (203 . "    if S has ExpressionSpace then")
 (204 . "        subst(eq1,eq2) ==")
 (205 . "           (eq3 := eq2 pretend Equation S;")
 (206 . "            [subst(lhs eq1,eq3),subst(rhs eq1,eq3)])))")))
\end{verbatim}

\defun{preparse}{preparse}
\calls{preparse}{preparse}
\calls{preparse}{preparse1}
\calls{preparse}{parseprint}
\calls{preparse}{ifcar}
\usesdollar{preparse}{comblocklist}
\usesdollar{preparse}{skipme}
\usesdollar{preparse}{preparse-last-line}
\usesdollar{preparse}{index}
\usesdollar{preparse}{docList}
\usesdollar{preparse}{preparseReportIfTrue}
\usesdollar{preparse}{headerDocumentation}
\usesdollar{preparse}{maxSignatureLineNumber}
\usesdollar{preparse}{constructorLineNumber}
<<defun preparse>>=
(defun preparse (strm &aux (stack ()))
 (declare (special $comblocklist $skipme $preparse-last-line $index |$docList|
            $preparseReportIfTrue |$headerDocumentation|
            |$maxSignatureLineNumber| |$constructorLineNumber|))
  (setq $comblocklist nil)
  (setq $skipme nil)
  (when $preparse-last-line
   (if (pairp $preparse-last-line)
    (setq stack $preparse-last-line)
    (push $preparse-last-line stack))
   (setq $index (- $index (length stack))))
  (let ((u (preparse1 stack)))
   (if $skipme 
    (preparse strm)
    (progn
      (when $preparseReportIfTrue (parseprint u))
      (setq |$headerDocumentation| nil)
      (setq |$docList| nil)
      (setq |$maxSignatureLineNumber| 0)
      (setq |$constructorLineNumber| (ifcar (ifcar u)))
      u))))

@

The {\bf preparse} function returns a list of pairs of the form:
( (linenumber . linestring) .... (linenumber . linestring))
For instance, for the file {\tt EQ.spad}, we get:
\begin{verbatim}
    2> (PREPARSE #<input stream "/tmp/EQ.spad">)
      3> (PREPARSE1 (")abbrev domain EQ Equation"))
        4> (|doSystemCommand| "abbrev domain EQ Equation")
        <4 (|doSystemCommand| NIL)
      <3 (PREPARSE1 (
 (19 . "Equation(S: Type): public == private where")
 (20 . " (Ex ==> OutputForm;")
 (21 . "  public ==> Type with")
 (22 . "   (\"=\": (S, S) -> $;")
 (24 . "    equation: (S, S) -> $;")
 (26 . "    swap: $ -> $;")
 (28 . "    lhs: $ -> S;")
 (30 . "    rhs: $ -> S;")
 (32 . "    map: (S -> S, $) -> $;")
 (35 . "    if S has InnerEvalable(Symbol,S) then")
 (36 . "             InnerEvalable(Symbol,S);")
 (37 . "    if S has SetCategory then")
 (38 . "       (SetCategory;")
 (39 . "        CoercibleTo Boolean;")
 (40 . "        if S has Evalable(S) then")
 (41 . "          (eval: ($, $) -> $;")
 (43 . "           eval: ($, List $) -> $));")
 (45 . "    if S has AbelianSemiGroup then")
 (46 . "       (AbelianSemiGroup;")
 (47 . "        \"+\": (S, $) -> $;")
 (50 . "        \"+\": ($, S) -> $);")
 (53 . "    if S has AbelianGroup then")
 (54 . "       (AbelianGroup;")
 (55 . "        leftZero : $ -> $;")
 (57 . "        rightZero : $ -> $;")
 (59 . "        \"-\": (S, $) -> $;")
 (62 . "        \"-\": ($, S) -> $);")
 (65 . "    if S has SemiGroup then")
 (66 . "       (SemiGroup;")
 (67 . "        \"*\": (S, $) -> $;")
 (70 . "        \"*\": ($, S) -> $);")
 (73 . "    if S has Monoid then")
 (74 . "       (Monoid;")
 (75 . "        leftOne : $ -> Union($,\"failed\");")
 (77 . "        rightOne : $ -> Union($,\"failed\"));")
 (79 . "    if S has Group then")
 (80 . "       (Group;")
 (81 . "        leftOne : $ -> Union($,\"failed\");")
 (83 . "        rightOne : $ -> Union($,\"failed\"));")
 (85 . "    if S has Ring then")
 (86 . "     (Ring;")
 (87 . "      BiModule(S,S));")
 (88 . "    if S has CommutativeRing then")
 (89 . "      Module(S);")
 (91 . "    if S has IntegralDomain then")
 (92 . "      factorAndSplit : $ -> List $;")
 (96 . "    if S has PartialDifferentialRing(Symbol) then")
 (97 . "      PartialDifferentialRing(Symbol);")
 (98 . "    if S has Field then")
 (99 . "     (VectorSpace(S);")
 (100 . "      \"/\": ($, $) -> $;")
 (103 . "      inv: $ -> $);")
 (105 . "    if S has ExpressionSpace then")
 (106 . "        subst: ($, $) -> $);")
 (109 . "  private ==> add")
 (110 . "   (Rep := Record(lhs: S, rhs: S);")
 (111 . "    eq1,eq2: $;")
 (112 . "    s : S;")
 (113 . "    if S has IntegralDomain then")
 (114 . "        factorAndSplit eq ==")
 (115 . "         ((S has factor : S -> Factored S) =>")
 (116 . "           (eq0 := rightZero eq;")
 (117 . "            [equation(rcf.factor,0) 
                       for rcf in factors factor lhs eq0]);")
 (118 . "          [eq]);")
 (119 . "    l:S = r:S      == [l, r];")
 (120 . "    equation(l, r) == [l, r];")
 (121 . "    lhs eqn        == eqn.lhs;")
 (122 . "    rhs eqn        == eqn.rhs;")
 (123 . "    swap eqn     == [rhs eqn, lhs eqn];")
 (124 . "    map(fn, eqn)   == equation(fn(eqn.lhs), fn(eqn.rhs));")
 (125 . "    if S has InnerEvalable(Symbol,S) then")
 (126 . "       (s:Symbol;")
 (127 . "        ls:List Symbol;")
 (128 . "        x:S;")
 (129 . "        lx:List S;")
 (130 . "        eval(eqn,s,x) == eval(eqn.lhs,s,x) = eval(eqn.rhs,s,x);")
 (131 . "        eval(eqn,ls,lx) == eval(eqn.lhs,ls,lx) = 
                                     eval(eqn.rhs,ls,lx));")
 (132 . "    if S has Evalable(S) then")
 (133 . "       (eval(eqn1:$, eqn2:$):$ ==")
 (134 . "           eval(eqn1.lhs, eqn2 pretend Equation S) =")
 (135 . "               eval(eqn1.rhs, eqn2 pretend Equation S);")
 (136 . "        eval(eqn1:$, leqn2:List $):$ ==")
 (137 . "           eval(eqn1.lhs, leqn2 pretend List Equation S) =")
 (138 . "               eval(eqn1.rhs, leqn2 pretend List Equation S));")
 (139 . "    if S has SetCategory then")
 (140 . "       (eq1 = eq2 == (eq1.lhs = eq2.lhs)@Boolean and")
 (141 . "                     (eq1.rhs = eq2.rhs)@Boolean;")
 (142 . "        coerce(eqn:$):Ex == eqn.lhs::Ex = eqn.rhs::Ex;")
 (143 . "        coerce(eqn:$):Boolean == eqn.lhs = eqn.rhs);")
 (144 . "    if S has AbelianSemiGroup then")
 (145 . "       (eq1 + eq2 == eq1.lhs + eq2.lhs = eq1.rhs + eq2.rhs;")
 (146 . "        s + eq2 == [s,s] + eq2;")
 (147 . "        eq1 + s == eq1 + [s,s]);")
 (148 . "    if S has AbelianGroup then")
 (149 . "       (- eq == (- lhs eq) = (-rhs eq);")
 (150 . "        s - eq2 == [s,s] - eq2;")
 (151 . "        eq1 - s == eq1 - [s,s];")
 (152 . "        leftZero eq == 0 = rhs eq - lhs eq;")
 (153 . "        rightZero eq == lhs eq - rhs eq = 0;")
 (154 . "        0 == equation(0$S,0$S);")
 (155 . "        eq1 - eq2 == eq1.lhs - eq2.lhs = eq1.rhs - eq2.rhs);")
 (156 . "    if S has SemiGroup then")
 (157 . "       (eq1:$ * eq2:$ == eq1.lhs * eq2.lhs = eq1.rhs * eq2.rhs;")
 (158 . "        l:S   * eqn:$ == l       * eqn.lhs = l       * eqn.rhs;")
 (159 . "        l:S * eqn:$  ==  l * eqn.lhs    =    l * eqn.rhs;")
 (160 . "        eqn:$ * l:S  ==  eqn.lhs * l    =    eqn.rhs * l);")
 (165 . "    if S has Monoid then")
 (166 . "       (1 == equation(1$S,1$S);")
 (167 . "        recip eq ==")
 (168 . "         ((lh := recip lhs eq) case \"failed\" => \"failed\";")
 (169 . "          (rh := recip rhs eq) case \"failed\" => \"failed\";")
 (170 . "          [lh :: S, rh :: S]);")
 (171 . "        leftOne eq ==")
 (172 . "         ((re := recip lhs eq) case \"failed\" => \"failed\";")
 (173 . "          1 = rhs eq * re);")
 (174 . "        rightOne eq ==")
 (175 . "         ((re := recip rhs eq) case \"failed\" => \"failed\";")
 (176 . "          lhs eq * re = 1));")
 (177 . "    if S has Group then")
 (178 . "       (inv eq == [inv lhs eq, inv rhs eq];")
 (179 . "        leftOne eq == 1 = rhs eq * inv rhs eq;")
 (180 . "        rightOne eq == lhs eq * inv rhs eq = 1);")
 (181 . "    if S has Ring then")
 (182 . "       (characteristic() == characteristic()$S;")
 (183 . "        i:Integer * eq:$ == (i::S) * eq);")
 (184 . "    if S has IntegralDomain then")
 (185 . "        factorAndSplit eq ==")
 (186 . "         ((S has factor : S -> Factored S) =>")
 (187 . "           (eq0 := rightZero eq;")
 (188 . "            [equation(rcf.factor,0) 
                         for rcf in factors factor lhs eq0]);")
 (189 . "          (S has Polynomial Integer) =>")
 (190 . "           (eq0 := rightZero eq;")
 (191 . "            MF ==> MultivariateFactorize(Symbol, 
                                IndexedExponents Symbol,
                                Integer, Polynomial Integer);")
 (193 . "            p : Polynomial Integer := 
                           (lhs eq0) pretend Polynomial Integer;")
 (194 . "            [equation((rcf.factor) pretend S,0) 
                           for rcf in factors factor(p)$MF]);")
 (195 . "          [eq]);")
 (196 . "    if S has PartialDifferentialRing(Symbol) then")
 (197 . "        differentiate(eq:$, sym:Symbol):$ ==")
 (198 . "           [differentiate(lhs eq, sym), differentiate(rhs eq, sym)];")
 (199 . "    if S has Field then")
 (200 . "       (dimension() == 2 :: CardinalNumber;")
 (201 . "        eq1:$ / eq2:$ == eq1.lhs / eq2.lhs = eq1.rhs / eq2.rhs;")
 (202 . "        inv eq == [inv lhs eq, inv rhs eq]);")
 (203 . "    if S has ExpressionSpace then")
 (204 . "        subst(eq1,eq2) ==")
 (205 . "           (eq3 := eq2 pretend Equation S;")
 (206 . "            [subst(lhs eq1,eq3),subst(rhs eq1,eq3)])))")))
\end{verbatim}

\defun{preparse1}{Build the lines from the input for piles}
\calls{preparse1}{preparseReadLine}
\calls{preparse1}{preparse-echo}
\calls{preparse1}{fincomblock}
\calls{preparse1}{parsepiles}
\calls{preparse1}{doSystemCommand}
\calls{preparse1}{escaped}
\calls{preparse1}{instring}
\calls{preparse1}{indent-pos}
\calls{preparse1}{getfullstr}
\calls{preparse1}{maxindex}
\calls{preparse1}{strposl}
\calls{preparse1}{is-console}
\catches{preparse1}{spad-reader}
\usesdollar{preparse1}{linelist}
\usesdollar{preparse1}{echolinestack}
\usesdollar{preparse1}{byConstructors}
\usesdollar{preparse1}{skipme}
\usesdollar{preparse1}{constructorsSeen}
\usesdollar{preparse1}{preparse-last-line}
<<defun preparse1>>=
(defun preparse1 (linelist)
 (prog (($linelist linelist) $echolinestack num a i l psloc
        instring pcount comsym strsym oparsym cparsym n ncomsym
        (sloc -1) (continue nil)  (parenlev 0) (ncomblock ())
        (lines ()) (locs ()) (nums ()) functor)
 (declare (special $linelist $echolinestack |$byConstructors| $skipme
           |$constructorsSeen| $preparse-last-line))
READLOOP 
  (dcq (num . a) (preparseReadLine linelist))
  (unless (stringp a)
    (preparse-echo linelist)
    (cond 
     ((null lines) (return nil))
     (ncomblock    (fincomblock nil nums locs ncomblock nil)))
    (return
     (pair (nreverse nums) (parsepiles (nreverse locs) (nreverse lines)))))
  ; this is a command line, don't parse it
  (when (and (null lines) (> (length a) 0) (eq (char a 0) #\) ))
    (preparse-echo linelist)
    (setq $preparse-last-line nil) ;don't reread this line
    (setq line a)
    (catch 'spad_reader (|doSystemCommand| (subseq line 1)))
    (go READLOOP))
  (setq l (length a))
  ; if we get a null line, read the next line
  (when (eq l 0) (go READLOOP))
  ; otherwise we have to parse this line
  (setq psloc sloc)
  (setq i 0)
  (setq instring nil)
  (setq pcount 0)
STRLOOP ;; handle things that need ignoring, quoting, or grouping
  ; are we in a comment, quoting, or grouping situation?
  (setq strsym (or (position #\" a :start i ) l))
  (setq comsym (or (search "--" a :start2 i ) l))
  (setq ncomsym (or (search "++" a :start2 i ) l))
  (setq oparsym (or (position #\( a :start i ) l))
  (setq cparsym (or (position #\) a :start i ) l))
  (setq n (min strsym comsym ncomsym oparsym cparsym))
  (cond 
   ; nope, we found no comment, quoting, or grouping
   ((= n l) (go NOCOMS))
   ((escaped a n))
   ; scan until we hit the end of the string
   ((= n strsym) (setq instring (not instring)))
   (instring)
   ;; handle -- comments by ignoring them
   ((= n comsym)
    (setq a (subseq a 0 n))
    (go NOCOMS)) ; discard trailing comment
   ;; handle ++ comments by chunking them together
   ((= n ncomsym)
    (setq sloc (indent-pos a))
    (cond
     ((= sloc n)
      (when (and ncomblock (not (= n (car ncomblock))))
       (fincomblock num nums locs ncomblock linelist)
       (setq ncomblock nil))
      (setq ncomblock (cons n (cons a (ifcdr ncomblock))))
      (setq a ""))
     (t 
      (push (strconc (getfullstr n " ") (substring a n ())) $linelist)
      (setq $index (1- $index))
      (setq a (subseq a 0 n))))
    (go NOCOMS))
   ; know how deep we are into parens
   ((= n oparsym) (setq pcount (1+ pcount)))
   ((= n cparsym) (setq pcount (1- pcount))))
  (setq i (1+ n))
  (go STRLOOP)
NOCOMS 
  ; remember the indentation level
  (setq sloc (indent-pos a))
  (setq a (string-right-trim " " a))
  (when (null sloc)
   (setq sloc psloc)
   (go READLOOP))
  ; handle line that ends in a continuation character
  (cond
   ((eq (elt a (maxindex a)) xcape)
    (setq continue t)
    (setq a (subseq a (maxindex a))))
   ((setq continue nil)))
  ; test for skipping constructors
  (when (and (null lines) (= sloc 0))
    (if (and |$byConstructors|
             (null (search "==>" a))
             (not 
              (member 
               (setq functor 
                (intern (substring a 0 (strposl ": (=" a 0 nil))))
                |$byConstructors|)))
       (setq $skipme 't)
       (progn
        (push functor |$constructorsSeen|)
        (setq $skipme nil))))
  ; is this thing followed by ++ comments?
  (when (and lines (eql sloc 0))
   (when (and ncomblock (not (zerop (car ncomblock))))
    (fincomblock num nums locs ncomblock linelist))
   (when (not (is-console in-stream))
    (setq $preparse-last-line (nreverse $echolinestack)))
   (return
    (pair (nreverse nums) (parsepiles (nreverse locs) (nreverse lines)))))
  (when (> parenlev 0)
   (push nil locs)
   (setq sloc psloc)
   (go REREAD))
  (when ncomblock
   (fincomblock num nums locs ncomblock linelist)
   (setq ncomblock ()))
  (push sloc locs)
REREAD 
  (preparse-echo linelist)
  (push a lines)
  (push num nums)
  (setq parenlev (+ parenlev pcount))
  (when (and (is-console in-stream) (not continue))
   (setq $preparse-last-line nil)
   (return
    (pair (nreverse nums) (parsepiles (nreverse locs) (nreverse lines)))))
  (go READLOOP)))

@

\defun{parsepiles}{parsepiles}
Add parens and semis to lines to aid parsing.
\calls{parsepiles}{add-parens-and-semis-to-line}
<<defun parsepiles>>=
(defun parsepiles (locs lines)
  (mapl #'add-parens-and-semis-to-line
    (nconc lines '(" ")) (nconc locs '(nil)))
  lines)

@
 
\defun{add-parens-and-semis-to-line}{add-parens-and-semis-to-line}
The line to be worked on is (CAR SLINES).  It's indentation is (CAR SLOCS).
There is a notion of current indentation. Then:
\begin{itemize}
\item Add open paren to beginning of following line if following line's 
indentation is greater than current, and add close paren to end of 
last succeeding line with following line's indentation.
\item Add semicolon to end of line if following line's indentation is the same.
\item If the entire line consists of the single keyword then or else, 
leave it alone."
\end{itemize}
\calls{add-parens-and-semis-to-line}{infixtok}
\calls{add-parens-and-semis-to-line}{drop}
\calls{add-parens-and-semis-to-line}{addclose}
\calls{add-parens-and-semis-to-line}{nonblankloc}
<<defun add-parens-and-semis-to-line>>=
(defun add-parens-and-semis-to-line (slines slocs)
 (let ((start-column (car slocs)))
  (when (and start-column (> start-column 0))
   (let ((count 0) (i 0))
    (seq
     (mapl #'(lambda (next-lines nlocs)
              (let ((next-line (car next-lines)) (next-column (car nlocs)))
               (incf i)
               (when next-column
                (setq next-column (abs next-column))
                (when (< next-column start-column) (exit nil))
                (cond
                 ((and (eq next-column start-column)
                       (rplaca nlocs (- (car nlocs)))
                       (not (infixtok next-line)))
                   (setq next-lines (drop (1- i) slines))
                   (rplaca next-lines (addclose (car next-lines) #\;))
                   (setq count (1+ count)))))))
                 (cdr slines) (cdr slocs)))
     (when (> count 0)
      (setf (char (car slines) (1- (nonblankloc (car slines)))) #\( )
      (setq slines (drop (1- i) slines))
      (rplaca slines (addclose (car slines) #\) )))))))
 
@\defun{preparseReadLine}{preparseReadLine}
\calls{preparseReadLine}{dcq}
\calls{preparseReadLine}{preparseReadLine1}
\calls{preparseReadLine}{initial-substring}
\calls{preparseReadLine}{string2BootTree}
\calls{preparseReadLine}{storeblanks}
\calls{preparseReadLine}{skip-to-endif}
\calls{preparseReadLine}{preparseReadLine}
<<defun preparseReadLine>>=
(defun preparseReadLine (x)
 (let (line ind)
  (dcq (ind . line) (preparseReadLine1 x))
  (cond
   ((not (stringp line)) (cons ind line))
   ((zerop (size line))  (cons ind line))
   ((char= (elt line 0) #\) )
    (cond
     ((initial-substring ")if" line)
      (if (eval (|string2BootTree| (storeblanks line 3)))
       (preparseReadLine x)
       (skip-ifblock x)))
     ((initial-substring ")elseif" line) (skip-to-endif x))
     ((initial-substring ")else" line)   (skip-to-endif x))
     ((initial-substring ")endif" line)  (preparseReadLine x))
     ((initial-substring ")fin" line)
      (setq *eof* t)
      (cons ind nil)))))
  (cons ind line)))
 
@

\defun{preparseReadLine1}{preparseReadLine1}
\calls{preparseReadLine1}{get-a-line}
\calls{preparseReadLine1}{expand-tabs}
\calls{preparseReadLine1}{maxindex}
\calls{preparseReadLine1}{strconc}
\calls{preparseReadLine1}{preparseReadLine1}
\usesdollar{preparseReadLine1}{linelist}
\usesdollar{preparseReadLine1}{preparse-last-line}
\usesdollar{preparseReadLine1}{index}
\usesdollar{preparseReadLine1}{EchoLineStack}
<<defun preparseReadLine1>>=
(defun preparseReadLine1 (x)
 (let (line ind)
 (declare (special $linelist $preparse-last-line $index $EchoLineStack))
  (setq line
   (if $linelist
    (pop $linelist)
    (expand-tabs (get-a-line in-stream))))
  (setq $preparse-last-line line)
  (if (stringp line)
   (progn
    (incf $index)
    (setq line (string-right-trim " " line))
    (push (copy-seq line) $EchoLineStack)
    (cons $index
     (if (and (> (setq ind (maxindex line)) -1) (char= (elt line ind) #\_))
      (setq $preparse-last-line
        (strconc (substring line 0 ind) (cdr (preparseReadLine1 x))))
      line)))
    (cons $index line))))
 
@

\section{I/O Handling}
\defun{preparse-echo}{preparse-echo}
\uses{preparse-echo}{Echo-Meta}
\usesdollar{preparse-echo}{EchoLineStack}
<<defun preparse-echo>>=
(defun preparse-echo (linelist)
 (declare (special $EchoLineStack Echo-Meta) (ignore linelist))
 (if Echo-Meta 
  (dolist (x (reverse $EchoLineStack))
   (format out-stream "~&;~A~%" x)))
 (setq $EchoLineStack ()))

@

<<initvars>>=
(defparameter Current-Fragment nil
  "A string containing remaining chars from readline; needed because
Symbolics read-line returns embedded newlines in a c-m-Y.")

@

\defun{read-a-line}{read-a-line}
\calls{read-a-line}{subseq}
\calls{read-a-line}{Line-New-Line}
\calls{read-a-line}{read-a-line}
\uses{read-a-line}{*eof*}
<<defun read-a-line>>=
(defun read-a-line (&optional (stream t))
 (let (cp)
 (declare (special *eof*))
  (if (and Current-Fragment (> (length Current-Fragment) 0))
   (let ((line (with-input-from-string
                 (s Current-Fragment :index cp :start 0)
                 (read-line s nil nil))))
    (setq Current-Fragment (subseq Current-Fragment cp))
    line)
   (prog nil
    (when (stream-eof in-stream)
      (setq File-Closed t)
      (setq *eof* t)
      (Line-New-Line (make-string 0) Current-Line)
      (return nil))
    (when (setq Current-Fragment (read-line stream))
     (return (read-a-line stream)))))))

@

\section{Line Handling}

\subsection{Line Buffer}
The philosophy of lines is that
\begin{itemize}
\item NEXT LINE will always return a non-blank line or fail.
\item Every line is terminated by a blank character.
\end{itemize}
Hence there is always a current character, because there is never a 
non-blank line, and there is always a separator character between tokens 
on separate lines. Also, when a line is read, the character pointer is 
always positioned ON the first character.
\defstruct{Line}
<<initvars>>=
;(defstruct Line "Line of input file to parse."
;           (Buffer (make-string 0) :type string)
;           (Current-Char #\Return :type character)
;           (Current-Index 1 :type fixnum)
;           (Last-Index 0 :type fixnum)
;           (Number 0 :type fixnum))

@

\defun{Line-New-Line}{Line-New-Line}
\usesstruct{Line-New-Line}{Line}
<<defun Line-New-Line>>=
(defun Line-New-Line (string line &optional (linenum nil))
  "Sets string to be the next line stored in line."
  (setf (Line-Last-Index line) (1- (length string)))
  (setf (Line-Current-Index line) 0)
  (setf (Line-Current-Char line)
        (or (and (> (length string) 0) (elt string 0)) #\Return))
  (setf (Line-Buffer line) string)
  (setf (Line-Number line) (or linenum (1+ (Line-Number line)))))

@

\defun{next-line}{next-line}
<<defun next-line>>=
(defun next-line (&optional (in-stream t))
 (funcall Line-Handler in-stream))

@

\defun{storeblanks}{storeblanks}
<<defun storeblanks>>=
(defun storeblanks (line n)
 (do ((i 0 (1+ i)))
     ((= i n) line)
  (setf (char line i) #\ )))

@
 
\defun{initial-substring}{initial-substring}
\calls{initial-substring}{mismatch}
<<defun initial-substring>>=
(defun initial-substring (pattern line)
   (let ((ind (mismatch pattern line)))
     (or (null ind) (eql ind (size pattern)))))

@
 
\defun{get-a-line}{get-a-line}
\calls{get-a-line}{is-console}
\calls{get-a-line}{mkprompt}
\calls{get-a-line}{read-a-line}
\calls{get-a-line}{make-string-adjustable}
<<defun get-a-line>>=
(defun get-a-line (stream)
 (when (is-console stream) (princ (mkprompt)))
 (let ((ll (read-a-line stream)))
  (if (stringp ll)
   (make-string-adjustable ll)
   ll)))

@

\defun{make-string-adjustable}{make-string-adjustable}
<<defun make-string-adjustable>>=
(defun make-string-adjustable (s)
 (if (adjustable-array-p s) 
  s
  (make-array (array-dimensions s) :element-type 'string-char
                  :adjustable t :initial-contents s)))

@

\chapter{Parse Transformers}
\section{Direct called parse routines}
\defun{parseTransform}{parseTransform}
\calls{parseTransform}{msubst}
\calls{parseTransform}{parseTran}
\usesdollar{parseTransform}{defOp}
<<defun parseTransform>>=
(defun |parseTransform| (x)
 (let (|$defOp|)
 (declare (special |$defOp|))
  (setq |$defOp| nil)
  (setq x (msubst '$ '% x)) ; for new compiler compatibility
  (|parseTran| x)))

@


\defun{parseTran}{parseTran}
\calls{parseTran}{parseAtom}
\calls{parseTran}{parseConstruct}
\calls{parseTran}{parseTran}
\calls{parseTran}{parseTranList}
\calls{parseTran}{getl}
\usesdollar{parseTran}{op}
<<defun parseTran>>=
(defun |parseTran| (x)
 (labels (
  (g (op)
   (let (tmp1 tmp2 x)
    (seq
     (if (and (pairp op) (eq (qcar op) '|elt|)
         (progn
          (setq tmp1 (qcdr op))
          (and (pairp tmp1)
               (progn
                (setq op (qcar tmp1))
                (setq tmp2 (qcdr tmp1))
                (and (pairp tmp2)
                     (eq (qcdr tmp2) nil)
                         (progn (setq x (qcar tmp2)) t))))))
        (exit (g x)))
     (exit op)))))
 (let (|$op| argl u r fn)
 (declare (special |$op|))
  (setq |$op| nil)
  (if (atom x) 
   (|parseAtom| x)
   (progn
    (setq |$op| (car x)) 
    (setq argl (cdr x))
    (setq u (g |$op|))
    (cond
     ((eq u '|construct|)
       (setq r (|parseConstruct| argl))
       (if (and (pairp |$op|) (eq (qcar |$op|) '|elt|))
        (cons (|parseTran| |$op|) (cdr r))
        r))
     ((and (atom u) (setq fn (getl u '|parseTran|)))
       (funcall fn argl))
     (t (cons (|parseTran| |$op|) (|parseTranList| argl)))))))))

@

\defun{parseAtom}{parseAtom}
\calls{parseAtom}{parseLeave}
\usesdollar{parseAtom}{NoValue}
<<defun parseAtom>>=
(defun |parseAtom| (x)
 (declare (special |$NoValue|))
 (if (eq x '|break|)
  (|parseLeave| (list '|$NoValue|))
  x))

@

\defun{parseTranList}{parseTranList}
\calls{parseTranList}{parseTran}
\calls{parseTranList}{parseTranList}
<<defun parseTranList>>=
(defun |parseTranList| (x)
 (if (atom x)
  (|parseTran| x)
  (cons (|parseTran| (car x)) (|parseTranList| (cdr x)))))

@

\defun{parseConstruct}{parseConstruct}
\calls{parseConstruct}{parseTranList}
\usesdollar{parseConstruct}{insideConstructIfTrue}
<<defun parseConstruct>>=
(defun |parseConstruct| (u)
 (let (|$insideConstructIfTrue| x)
 (declare (special |$insideConstructIfTrue|))
  (setq |$insideConstructIfTrue| t)
  (setq x (|parseTranList| u))
  (cons '|construct| x)))

@

\section{Indirect called parse routines}

\defplist{parseTran}{parseLeave}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|leave| '|parseTran|) '|parseLeave|))

@
\defun{parseLeave}{parseLeave}
\calls{parseLeave}{parseTran}
<<defun parseLeave>>=
(defun |parseLeave| (arg)
 (let (a b)
    (setq a (|parseTran| (car arg)))
    (setq b (|parseTran| (cdr arg)))
    (cond
     (b
      (cond
       ((null (integerp a))
        (moan "first arg " a " for 'leave' must be integer")
        (list '|leave| 1 a))
       (t (cons '|leave| (cons a b)))))
     (t (list '|leave| 1 a)))))

@

\chapter{Post Transformers}
\section{Direct called postparse routines}
\defun{postTransform}{postTransform}
\calls{postTransform}{postTran}
\calls{postTransform}{identp}
\calls{postTransform}{postTransformCheck}
\calls{postTransform}{aplTran}
<<defun postTransform>>=
(defun |postTransform| (y)
 (let (x tmp1 tmp2 tmp3 tmp4 tmp5 tt l u)
  (setq x y)
  (setq u (|postTran| x))
  (when
   (and (pairp u) (eq (qcar u) '|@Tuple|)
        (progn
         (setq tmp1 (qcdr u))
         (and (pairp tmp1)
              (progn (setq tmp2 (reverse tmp1)) t)
              (pairp tmp2)
              (progn
               (setq tmp3 (qcar tmp2))
               (and (pairp tmp3)
                    (eq (qcar tmp3) '|:|)
                    (progn
                     (setq tmp4 (qcdr tmp3))
                     (and (pairp tmp4)
                          (progn
                           (setq y (qcar tmp4))
                           (setq tmp5 (qcdr tmp4))
                           (and (pairp tmp5)
                                (eq (qcdr tmp5) nil)
                                (progn (setq tt (qcar tmp5)) t)))))))
                        (progn (setq l (qcdr tmp2)) t)
                        (progn (setq l (nreverse l)) t)))
              (dolist (x l t) (unless (identp x) (return nil))))
    (setq u (list '|:| (cons 'listof (append l (list y))) tt)))
  (|postTransformCheck| u)
  (|aplTran| u)))

@

\defun{postTran}{postTran}
\calls{postTran}{postAtom}
\calls{postTran}{postTran}
\calls{postTran}{pairp}
\calls{postTran}{qcar}
\calls{postTran}{qcdr}
\calls{postTran}{unTuple}
\calls{postTran}{postTranList}
\calls{postTran}{postForm}
\calls{postTran}{postOp}
\calls{postTran}{postScriptsForm}
<<defun postTran>>=
(defun |postTran| (x)
 (let (op f tmp1 a tmp2 tmp3 b y)
  (if (atom x)
   (|postAtom| x)
   (progn
    (setq op (car x))
    (cond
     ((and (atom op) (setq f (getl op '|postTran|)))
      (funcall f x))
     ((and (pairp op) (eq (qcar op) '|elt|)
           (progn
            (setq tmp1 (qcdr op))
            (and (pairp tmp1)
                 (progn
                   (setq a (qcar tmp1))
                   (setq tmp2 (qcdr tmp1))
                   (and (pairp tmp2)
                        (eq (qcdr tmp2) nil)
                        (progn (setq b (qcar tmp2)) t))))))
      (cons (|postTran| op) (cdr (|postTran| (cons b (cdr x))))))
     ((and (pairp op) (eq (qcar op) '|Scripts|))
      (|postScriptsForm| op
       (dolist (y (rest x) tmp3)
        (setq tmp3 (append tmp3 (|unTuple| (|postTran| y)))))))
     ((nequal op (setq y (|postOp| op)))
      (cons y (|postTranList| (cdr x))))
     (t (|postForm| x)))))))

@

\defun{postOp}{postOp}
<<defun postOp>>=
(defun |postOp| (x)
 (declare (special $boot))
 (cond
  ((eq x '|:=|) (if $boot 'spadlet 'let))
  ((eq x '|:-|) 'letd)
  ((eq x '|Attribute|) 'attribute)
  (t x)))

@


\defun{postAtom}{postAtom}
\usesdollar{postAtom}{boot}
<<defun postAtom>>=
(defun |postAtom| (x)
 (declare (special $boot))
  (cond
    ($boot x)
    ((eql x 0) '(|Zero|))
    ((eql x 1) '(|One|))
    ((eq x t) 't$)
    ((and (identp x) (getdatabase x 'niladic)) (list x))
    (t x)))

@

\defun{postTranList}{postTranList}
\calls{postTranList}{postTran}
<<defun postTranList>>=
(defun |postTranList| (x)
 (loop for y in x collect (|postTran| y)))

@

\defun{postScriptsForm}{postScriptsForm}
\calls{postScriptsForm}{getScriptName}
\calls{postScriptsForm}{length}
\calls{postScriptsForm}{postTranScripts}
<<defun postScriptsForm>>=
(defun |postScriptsForm| (arg0 argl)
 (let ((op (second arg0)) (a (third arg0)))
  (cons (|getScriptName| op a (|#| argl))
        (append (|postTranScripts| a) argl))))

@

\defun{postTranScripts}{postTranScripts}
\calls{postTranScripts}{postTranScripts}
\calls{postTranScripts}{postTran}
<<defun postTranScripts>>=
(defun |postTranScripts| (a)
 (labels (
  (fn (x) 
   (if (and (pairp x) (eq (qcar x) '|@Tuple|))
    (qcdr x)
    (list x))))
 (let (tmp1 tmp2 tmp3)
  (cond
   ((and (pairp a) (eq (qcar a) '|PrefixSC|)
         (progn
          (setq tmp1 (qcdr a))
          (and (pairp tmp1) (eq (qcdr tmp1) nil))))
     (|postTranScripts| (qcar tmp1)))
   ((and (pairp a) (eq (qcar a) '|;|))
    (dolist (y (qcdr a) tmp2)
     (setq tmp2 (append tmp2 (|postTranScripts| y)))))
   ((and (pairp a) (eq (qcar a) '|,|))
    (dolist (y (qcdr a) tmp3)
     (setq tmp3 (append tmp3 (fn (|postTran| y))))))
   (t (list (|postTran| a)))))))

@

\defun{postTransformCheck}{postTransformCheck}
\calls{postTransformCheck}{postcheck}
\usesdollar{postTransformCheck}{defOp}
<<defun postTransformCheck>>=
(defun |postTransformCheck| (x)
 (let (|$defOp|)
 (declare (special |$defOp|))
  (setq |$defOp| nil)
  (|postcheck| x)))

@

\defun{postcheck}{postcheck}
\calls{postcheck}{setDefOp}
\calls{postcheck}{postcheck}
<<defun postcheck>>=
(defun |postcheck| (x)
 (cond
  ((atom x) nil)
  ((and (pairp x) (eq (qcar x) 'def) (pairp (qcdr x)))
   (|setDefOp|  (qcar (qcdr x)))
   (|postcheck| (qcdr (qcdr x))))
  ((and (pairp x) (eq (qcar x) 'quote)) nil)
  (t (|postcheck| (car x)) (|postcheck| (cdr x)))))

@

\defun{postError}{postError}
\calls{postError}{nequal}
\calls{postError}{bumperrorcount}
\usesdollar{postError}{defOp}
% \usesdollar{postError}{InteractiveMode} original source code bug
\usesdollar{postError}{postStack}
<<defun postError>>=
(defun |postError| (msg)
 (let (xmsg)
  (declare (special |$defOp| |$postStack|))
  (bumperrorcount '|precompilation|)
  (setq xmsg
   (if (and (nequal |$defOp| '|$defOp|) (null |InteractiveMode|))
    (cons |$defOp| (cons ": " msg))
    msg))
  (push xmsg |$postStack|)
  nil))

@

\defun{postForm}{postForm}
\calls{postForm}{postTranList}
\calls{postForm}{internl}
\calls{postForm}{postTran}
\calls{postForm}{postError}
\calls{postForm}{bright}
\usesdollar{postForm}{boot}
<<defun postForm>>=
(defun |postForm| (u)
 (let (op argl arglp numOfArgs opp x)
 (declare (special $boot))
  (seq
   (setq op (car u))
   (setq argl (cdr u))
   (setq x
    (cond
     ((atom op)
       (setq arglp (|postTranList| argl))
       (setq opp
         (seq 
          (exit op)
          (when $boot (exit op))
          (when (or (getl op '|Led|)  (getl op '|Nud|) (eq op 'in)) (exit op))
          (setq numOfArgs
           (cond
            ((and (pairp arglp) (eq (qcdr arglp) nil) (pairp (qcar arglp)) 
                  (eq (qcar (qcar arglp)) '|@Tuple|))
              (|#| (qcdr (qcar arglp))))
            (t 1)))
          (internl '* (stringimage numOfArgs) (pname op))))
       (cons opp arglp))
     ((and (pairp op) (eq (qcar op) '|Scripts|))
       (append (|postTran| op) (|postTranList| argl)))
     (t
      (setq u (|postTranList| u))
      (cond
       ((and (pairp u) (pairp (qcar u)) (eq (qcar (qcar u)) '|@Tuple|))
         (|postError|
          (cons "  "
           (append (|bright| u)
            (list "is illegal because tuples cannot be applied!" '|%l| 
                  "   Did you misuse infix dot?"))))))
       u)))
   (cond
    ((and (pairp x) (pairp (qcdr x)) (eq (qcdr (qcdr x)) nil)
          (pairp (qcar (qcdr x))) (eq (qcar (qcar (qcdr x))) '|@Tuple|))
     (cons (car x) (qcdr (qcar (qcdr x)))))
    (t x)))))

@

\section{Indirect called postparse routines}
In the {\bf postTran} function there is the code:
\begin{verbatim}
     ((and (atom op) (setq f (getl op '|postTran|)))
      (funcall f x))
\end{verbatim}

The functions in this section are called through the symbol-plist
of the symbol being parsed. The original list read:

\begin{verbatim}
  add            postAdd
  @              postAtSign
  :BF:           postBigFloat
  Block          postBlock
  CATEGORY       postCategory
  COLLECT        postCollect
  :              postColon
  ::             postColonColon
  ,              postComma
  construct      postConstruct
  ==             postDef
  =>             postExit
  if             postIf
  in             postin       ;" the infix operator version of in"
  IN             postIn       ;" the iterator form of in"
  Join           postJoin
  ->             postMapping
  ==>            postMDef
  pretend        postPretend
  QUOTE          postQUOTE
  Reduce         postReduce
  REPEAT         postRepeat
  Scripts        postScripts
  ;              postSemiColon
  Signature      postSignature
  /              postSlash
  @Tuple         postTuple
  TupleCollect   postTupleCollect
  where          postWhere
  with           postWith
\end{verbatim}

@

\defplist{add}{postAdd}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|add| '|postTran|) '|postAdd|))

@

\defun{postAdd}{postAdd}
\calls{postAdd}{postTran}
\calls{postAdd}{postCapsule}
<<defun postAdd>>=
(defun |postAdd| (arg)
 (if (null (cddr arg))
  (|postCapsule| (second arg))
  (list '|add| (|postTran| (second arg)) (|postCapsule| (third arg)))))

@

\defplist{@}{postAtSign}
<<postvars>>=
(eval-when (eval load)
 (setf (get '@ '|postTran|) '|postAtSign|))

@

\defun{postAtSign}{postAtSign}
\calls{postAtSign}{postTran}
\calls{postAtSign}{postType}
<<defun postAtSign>>=
(defun |postAtSign| (arg)
 (cons '@ (cons (|postTran| (second arg)) (|postType| (third arg)))))

@

\defplist{:BF:}{postBigFloat}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|:BF:| '|postTran|) '|postBigFloat|))

@

\defun{postBigFloat}{postBigFloat}
\calls{postBigFloat}{postTran}
\usesdollar{postBigFloat}{boot}
\usesdollar{postBigFloat}{InteractiveMode}
<<defun postBigFloat>>=
(defun |postBigFloat| (arg)
 (let (mant expon eltword)
  (declare (special $boot |$InteractiveMode|))
  (setq mant (second arg))
  (setq expon (cddr arg))
  (if $boot 
   (times (float mant) (expt (float 10) expon))
   (progn
    (setq eltword (if |$InteractiveMode| '|$elt| '|elt|))
    (|postTran|
     (list (list eltword '(|Float|) '|float|)
       (list '|,| (list '|,| mant expon) 10)))))))

@

\defplist{Block}{postBlock}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|Block| '|postTran|) '|postBlock|))

@

\defun{postBlock}{postBlock}
\calls{postBlock}{postBlockItemList}
\calls{postBlock}{postTran}
<<defun postBlock>>=
(defun |postBlock| (arg)
 (let (tmp1 x y)
  (setq tmp1 (reverse (cdr arg)))
  (setq x (car tmp1))
  (setq y (nreverse (cdr tmp1)))
  (cons 'seq
   (append (|postBlockItemList| y) (list (list '|exit| (|postTran| x)))))))

@

\defplist{category}{postCategory}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'category '|postTran|) '|postCategory|))

@

\defun{postCategory}{postCategory}
\calls{postCategory}{postTran}
\calls{postCategory}{nreverse0}
\usesdollar{postCategory}{insidePostCategoryIfTrue}
<<defun postCategory>>=
(defun |postCategory| (u)
 (labels (
  (fn (arg)
   (let (|$insidePostCategoryIfTrue|)
   (declare (special |$insidePostCategoryIfTrue|))
    (setq |$insidePostCategoryIfTrue| t)
    (|postTran| arg))) )
 (let ((z (cdr u)) op tmp1)
  (if (null z)
   u
   (progn
     (setq op (if |$insidePostCategoryIfTrue| 'progn 'category))
     (cons op (dolist (x z (nreverse0 tmp1)) (push (fn x) tmp1))))))))

@

\defun{postCollect,finish}{postCollect,finish}
<<defun postCollect,finish>>=
(defun |postCollect,finish| (op itl y)
 (let (tmp2 tmp5 newBody)
  (cond
   ((and (pairp y) (eq (qcar y) '|:|)
         (pairp (qcdr y)) (eq (qcdr (qcdr y)) nil))
    (list 'reduce '|append| 0 (cons op (append itl (list (qcar (qcdr y)))))))
   ((and (pairp y) (eq (qcar y) '|Tuple|))
    (setq newBody
     (cond
      ((dolist (x (qcdr y) tmp2)
        (setq tmp2
         (or tmp2 (and (pairp x) (eq (qcar x) '|:|)
                       (pairp (qcdr x)) (eq (qcdr (qcdr x)) nil)))))
       (|postMakeCons| (qcdr y)))
      ((dolist (x (qcdr y) tmp5)
         (setq tmp5 (or tmp5 (and (pairp x) (eq (qcar x) 'segment)))))
        (|tuple2List| (qcdr y)))
      (t (cons '|construct| (|postTranList| l)))))
     (list 'reduce '|append| 0 (cons op (append itl (list newBody)))))
   (t (cons op (append itl (list y)))))))

@

\defplist{collect}{postCollect}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'collect '|postTran|) '|postCollect|))

@

\defun{postCollect}{postCollect}
\calls{postCollect}{postCollect,finish}
\calls{postCollect}{postCollect}
\calls{postCollect}{postIteratorList}
\calls{postCollect}{postTran}
<<defun postCollect>>=
(defun |postCollect| (arg)
 (let (constructOp tmp3 m d itl x)
  (setq constructOp (car arg))
  (setq tmp3 (reverse (cdr arg)))
  (setq x (car tmp3))
  (setq m (nreverse (cdr tmp3)))
  (cond
   ((and (pairp x) (pairp (qcar x)) (eq (qcar (qcar x)) '|elt|)
         (pairp (qcdr (qcar x))) (pairp (qcdr (qcdr (qcar x))))
         (eq (qcdr (qcdr (qcdr (qcar x)))) nil)
         (eq (qcar (qcdr (qcdr (qcar x)))) '|construct|))
    (|postCollect|
     (cons (list '|elt| (qcar (qcdr (qcar x))) 'collect)
      (append m (list (cons '|construct| (qcdr x)))))))
   (t
    (setq itl (|postIteratorList| m))
    (setq x
     (if (and (pairp x) (eq (qcar x) '|construct|)
              (pairp (qcdr x)) (eq (qcdr (qcdr x)) nil))
       (qcar (qcdr x))
       x))
    (|postCollect,finish| constructOp itl (|postTran| x))))))

@

\defplist{:}{postColon}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|:| '|postTran|) '|postColon|))

@

\defun{postColon}{postColon}
\calls{postColon}{postTran}
\calls{postColon}{postType}
<<defun postColon>>=
(defun |postColon| (u)
 (cond
  ((and (pairp u) (eq (qcar u) '|:|)
        (pairp (qcdr u)) (eq (qcdr (qcdr u)) nil))
    (list '|:| (|postTran| (qcar (qcdr u)))))
  ((and (pairp u) (eq (qcar u) '|:|) (pairp (qcdr u))
        (pairp (qcdr (qcdr u))) (eq (qcdr (qcdr (qcdr u))) nil))
   (cons '|:| (cons (|postTran| (second u)) (|postType| (third u)))))))

@

\defplist{::}{postColonColon}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|::| '|postTran|) '|postColonColon|))

@

\defun{postColonColon}{postColonColon}
\calls{postColonColon}{stringimage}
\calls{postColonColon}{postForm}
\usesdollar{postColonColon}{boot}
<<defun postColonColon>>=
(defun |postColonColon| (u)
  (if (and $boot (pairp u) (eq (qcar u) '|::|) (pairp (qcdr u))
           (pairp (qcdr (qcdr u))) (eq (qcdr (qcdr (qcdr u))) nil))
   (intern (stringimage (third u)) (second u))
   (|postForm| u)))

@

\defplist{,}{postComma}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|,| '|postTran|) '|postComma|))

@

\defun{postComma}{postComma}
\calls{postComma}{postTuple}
\calls{postComma}{comma2Tuple}
<<defun postComma>>=
(defun |postComma| (u)
 (|postTuple| (|comma2Tuple| u))) 

@

\defun{comma2Tuple}{comma2Tuple}
\calls{comma2Tuple}{postFlatten}
<<defun comma2Tuple>>=
(defun |comma2Tuple| (u)
 (cons '|@Tuple| (|postFlatten| u '|,|))) 

@

\defplist{construct}{postConstruct}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|construct| '|postTran|) '|postConstruct|))

@

\defun{postConstruct}{postConstruct}
\calls{postConstruct}{comma2Tuple}
\calls{postConstruct}{postTranSegment}
\calls{postConstruct}{postMakeCons}
\calls{postConstruct}{tuple2List}
\calls{postConstruct}{postTranList}
\calls{postConstruct}{postTran}
<<defun postConstruct>>=
(defun |postConstruct| (u)
 (let (b a tmp4 tmp7)
  (cond
   ((and (pairp u) (eq (qcar u) '|construct|)
         (pairp (qcdr u)) (eq (qcdr (qcdr u)) nil))
     (setq b (qcar (qcdr u)))
     (setq a
      (if (and (pairp b) (eq (qcar b) '|,|)) 
       (|comma2Tuple| b)
       b))
     (cond
      ((and (pairp a) (eq (qcar a) 'segment) (pairp (qcdr a))
            (pairp (qcdr (qcdr a))) (eq (qcdr (qcdr (qcdr a))) nil))
       (list '|construct| (|postTranSegment| (second a) (third a))))
      ((and (pairp a) (eq (qcar a) '|@Tuple|))
        (cond
         ((dolist (x (qcdr a) tmp4)
           (setq tmp4
            (or tmp4
             (and (pairp x) (eq (qcar x) '|:|)
                  (pairp (qcdr x)) (eq (qcdr (qcdr x)) nil)))))
          (|postMakeCons| (qcdr a)))
         ((dolist (x (qcdr a) tmp7)
            (setq tmp7 (or tmp7 (and (pairp x) (eq (qcar x) 'segment)))))
          (|tuple2List| (qcdr a)))
         (t (cons '|construct| (|postTranList| (qcdr a))))))
      (t (list '|construct| (|postTran| a)))))
   (t u))))

@

\defplist{==}{postDef}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|==| '|postTran|) '|postDef|))

@

\defun{postDef}{postDef}
\calls{postDef}{postMDef}
\calls{postDef}{recordHeaderDocumentation}
\calls{postDef}{nequal}
\calls{postDef}{postTran}
\calls{postDef}{postDefArgs}
\calls{postDef}{nreverse0}
\usesdollar{postDef}{boot}
\usesdollar{postDef}{maxSignatureLineNumber}
\usesdollar{postDef}{headerDocumentation}
\usesdollar{postDef}{docList}
\usesdollar{postDef}{InteractiveMode}
<<defun postDef>>=
(defun |postDef| (arg)
 (let (defOp rhs name lhs targetType a tmp1 op argl newLhs 
       argTypeList typeList form specialCaseForm tmp4 tmp6 tmp8)
 (declare (special $boot |$maxSignatureLineNumber| |$headerDocumentation|
                   |$docList| |$InteractiveMode|))
  (setq defOp (car arg))
  (setq lhs (second arg))
  (setq rhs (third arg))
  (if (and (pairp lhs) (eq (qcar lhs) '|macro|)
           (pairp (qcdr lhs)) (eq (qcdr (qcdr lhs)) nil))
   (|postMDef| (list '==> (second lhs) rhs))
   (progn
    (unless $boot (|recordHeaderDocumentation| nil))
    (when (nequal |$maxSignatureLineNumber| 0)
      (setq |$docList|
       (cons (cons '|constructor| |$headerDocumentation|) |$docList|))
      (setq |$maxSignatureLineNumber| 0))
    (setq lhs (|postTran| lhs))
    (setq tmp1
     (if (and (pairp lhs) (eq (qcar lhs) '|:|)) (cdr lhs) (list lhs nil)))
    (setq form (car tmp1))
    (setq targetType (second tmp1))
    (when (and (null |$InteractiveMode|) (atom form)) (setq form (list form)))
    (setq newLhs
     (if (atom form) 
      form
      (progn
       (setq tmp1
        (dolist (x form (nreverse0 tmp4))
         (push
           (if (and (pairp x) (eq (qcar x) '|:|) (pairp (qcdr x))
                    (pairp (qcdr (qcdr x))) (eq (qcdr (qcdr (qcdr x))) nil))
            (qcar (qcdr x))
            x)
           tmp4)))
       (setq op (car tmp1))
       (setq argl (cdr tmp1))
       (cons op (|postDefArgs| argl)))))
    (setq argTypeList
     (unless (atom form)
      (dolist (x (cdr form) (nreverse0 tmp6))
       (push
         (when (and (pairp x) (eq (qcar x) '|:|) (pairp (qcdr x))
               (pairp (qcdr (qcdr x))) (eq (qcdr (qcdr (qcdr x))) nil))
           (third x))
         tmp6))))
    (setq typeList (cons targetType argTypeList))
    (when (atom form) (setq form (list form)))
    (setq specialCaseForm
     (dolist (x form (nreverse tmp8))
      (setq tmp8 (cons nil tmp8))))
    (list 'def newLhs typeList specialCaseForm (|postTran| rhs))))))

@

\defplist{with}{postWith}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|with| '|postTran|) '|postWith|))

@

\defun{postWith}{postWith}
\calls{postWith}{postTran}
\usesdollar{postWith}{insidePostCategoryIfTrue}
<<defun postWith>>=
(defun |postWith| (arg)
 (let (|$insidePostCategoryIfTrue| a)
 (declare (special |$insidePostCategoryIfTrue|))
  (setq |$insidePostCategoryIfTrue| t)
  (setq a (|postTran| (second arg)))
  (cond
   ((and (pairp a) (member (qcar a) '(signature attribute if)))
     (list 'category a))
   ((and (pairp a) (eq (qcar a) 'progn))
     (cons 'category (qcdr a)))
   (t a))))

@


\section{Support routines}
\defun{setDefOp}{setDefOp}
\usesdollar{setDefOp}{defOp}
\usesdollar{setDefOp}{topOp}
<<defun setDefOp>>=
(defun |setDefOp| (f)
 (let (tmp1)
  (declare (special |$defOp| |$topOp|))
  (when (and (pairp f) (eq (qcar f) '|:|)
             (pairp (setq tmp1 (qcdr f))))
    (setq f (qcar tmp1)))
  (unless (atom f) (setq f (car f)))
  (if |$topOp| 
   (setq |$defOp| f)
   (setq |$topOp| f))))

@

\defun{aplTran}{aplTran}
\calls{aplTran}{aplTran1}
\calls{aplTran}{containsBang}
\usesdollar{aplTran}{genno}
\usesdollar{aplTran}{boot}
<<defun aplTran>>=
(defun |aplTran| (x)
 (let ($genno u)
 (declare (special $genno $boot))
  (cond
   ($boot x)
   (t
    (setq $genno 0)
    (setq u (|aplTran1| x))
    (cond
     ((|containsBang| u) (|throwKeyedMsg| 's2ip0002 nil))
     (t u))))))

@

\defun{aplTran1}{aplTran1}
\calls{aplTran1}{aplTranList}
\calls{aplTran1}{aplTran1}
\calls{aplTran1}{hasAplExtension}
\calls{aplTran1}{nreverse0}
\calls{aplTran1}{}
\usesdollar{aplTran1}{boot}
<<defun aplTran1>>=
(defun |aplTran1| (x)
 (let (op argl1 argl f y opprime yprime tmp1 arglAssoc futureArgl g)
 (declare (special $boot))
  (if (atom x)
   x
   (progn
    (setq op (car x))
    (setq argl1 (cdr x))
    (setq argl (|aplTranList| argl1))
    (cond
     ((eq op '!)
      (cond
       ((and (pairp argl)
             (progn
              (setq f (qcar argl))
              (setq tmp1 (qcdr argl))
              (and (pairp tmp1)
                   (eq (qcdr tmp1) nil)
                   (progn
                    (setq y (qcar tmp1))
                    t))))
         (cond
          ((and (pairp y)
                (progn
                 (setq opprime (qcar y))
                 (setq yprime (qcdr y))
                 t)
                (eq opprime '!))
            (|aplTran1| (cons op (cons op (cons f yprime)))))
          ($boot 
           (cons 'collect
            (cons
             (list 'in (setq g (genvar)) (|aplTran1| y))
              (list (list f g ) ))))
          (t
           (list '|map| f (|aplTran1| y) ))))
       (t x)))
     ((progn
       (setq tmp1 (|hasAplExtension| argl))
       (and (pairp tmp1)
            (progn
             (setq arglAssoc (qcar tmp1))
             (setq futureArgl (qcdr tmp1))
             t)))
       (cons '|reshape|
        (cons
         (cons 'collect
          (append
           (do ((tmp3 arglAssoc (cdr tmp3)) (tmp4 nil))
               ((or (atom tmp3)
                    (progn (setq tmp4 (car tmp3)) nil)
                    (progn
                      (setq g (car tmp4))
                      (setq a (cdr tmp4))
                      nil))
                   (nreverse0 tmp2))
              (push (list 'in g (list '|ravel| a))) tmp2))
          (list (|aplTran1| (cons op futureArgl)))))
         (list (cdar arglAssoc))))
     (t (cons op argl)))))))

@

\defun{aplTranList}{aplTranList}
\calls{aplTranList}{aplTran1}
\calls{aplTranList}{aplTranList}
<<defun aplTranList>>=
(defun |aplTranList| (x)
 (if (atom x) 
  x
  (cons (|aplTran1| (car x)) (|aplTranList| (cdr x)))))

@

\defun{hasAplExtension}{hasAplExtension}
\calls{hasAplExtension}{nreverse0}
\calls{hasAplExtension}{deepestExpression}
\calls{hasAplExtension}{genvar}
\calls{hasAplExtension}{aplTran1}
\calls{hasAplExtension}{msubst}
<<defun hasAplExtension>>=
(defun |hasAplExtension| (argl)
 (let (tmp2 tmp3 y z g arglAssoc u)
  (when
   (dolist (x argl tmp2)
      (setq tmp2 (or tmp2 (and (pairp x) (eq (qcar x) '!)))))
    (setq u
     (dolist (x argl (nreverse0 tmp3))
      (push
        (if (and (pairp x) (eq (qcar x) '!)
                 (pairp (qcdr x)) (eq (qcdr (qcdr x)) nil))
         (progn
           (setq y (qcar (qcdr x)))
           (setq z (|deepestExpression| y))
           (setq arglAssoc
            (cons (cons (setq g (genvar)) (|aplTran1| z)) arglAssoc))
           (msubst g z y))
          x)
         tmp3)))
    (cons arglAssoc u))))

@

\defun{deepestExpression}{deepestExpression}
\calls{deepestExpression}{deepestExpression}
<<defun deepestExpression>>=
(defun |deepestExpression| (x)
 (if (and (pairp x) (eq (qcar x) '!)
          (pairp (qcdr x)) (eq (qcdr (qcdr x)) nil))
   (|deepestExpression| (qcar (qcdr x)))
   x))

@

\defun{containsBang}{containsBang}
\calls{containsBang}{containsBang}
<<defun containsBang>>=
(defun |containsBang| (u)
 (let (tmp2)
  (cond
   ((atom u) (eq u '!))
   ((and (pairp u) (equal (qcar u) 'quote)
         (pairp (qcdr u)) (eq (qcdr (qcdr u)) nil))
     nil)
   (t
     (dolist (x u tmp2)
       (setq tmp2 (or tmp2 (|containsBang| x))))))))

@

\defun{getScriptName}{getScriptName}
\calls{getScriptName}{identp}
\calls{getScriptName}{postError}
\calls{getScriptName}{internl}
\calls{getScriptName}{stringimage}
\calls{getScriptName}{decodeScripts}
\calls{getScriptName}{pname}
<<defun getScriptName>>=
(defun |getScriptName| (op a numberOfFunctionalArgs)
 (when (null (identp op))
   (|postError| (list "   " op " cannot have scripts" )))
 (internl '* (stringimage numberOfFunctionalArgs)
             (|decodeScripts| a) (pname op)))

@

\defun{decodeScripts}{decodeScripts}
\calls{decodeScripts}{qcar}
\calls{decodeScripts}{qcdr}
\calls{decodeScripts}{strconc}
\calls{decodeScripts}{stringimage}
\calls{decodeScripts}{decodeScripts}
<<defun decodeScripts>>=
(defun |decodeScripts| (a)
 (labels (
  (fn (a)
   (let ((tmp1 0))
    (if (and (pairp a) (eq (qcar a) '|,|))
     (dolist (x (qcdr a) tmp1) (setq tmp1 (+ tmp1 (fn x))))
     1))))
  (cond
   ((and (pairp a) (eq (qcar a) '|PrefixSC|)
         (pairp (qcdr a)) (eq (qcdr (qcdr a)) nil))
    (strconc (stringimage 0) (|decodeScripts| (qcar (qcdr a)))))
   ((and (pairp a) (eq (qcar a) '|;|))
    (apply 'strconc (loop for x in (qcdr a) collect (|decodeScripts| x))))
   ((and (pairp a) (eq (qcar a) '|,|))
    (stringimage (fn a)))
   (t
    (stringimage 1)))))

@


\chapter{DEF forms}

\defun{def}{def}
\calls{def}{deftran}
\calls{def}{def-insert-let}
\calls{def}{def-stringtoquote}
\calls{def}{bootTransform}
\calls{def}{comp}
\calls{def}{sublis}
\usesdollar{def}{body}
\usesdollar{def}{opassoc}
\usesdollar{def}{op}
<<defun def>>=
(defun def (form signature $body)
 (declare (ignore signature))
 (let* ($opassoc
        ($op (first form))
        (argl (rest form))
        ($body (deftran $body))
        (argl (def-insert-let argl))
        (arglp (def-stringtoquote argl))
        ($body (|bootTransform| $body)))
  (declare (special $body $opassoc $op))
  (comp (sublis $opassoc (list (list $op (list 'lam arglp $body)))))))

@

\defun{deftran}{deftran}
This two-level call allows DEF-RENAME to be locally bound to do
nothing (see boot2Lisp) yet still allow function call (lisp2BootAndComp).
\calls{deftran}{}
\usesdollar{deftran}{macroassoc}
<<defun deftran>>=
(defun deftran (x)
 (let (op y)
  (cond
   ((stringp x) (def-string x))
   ((identp x) (cond ((lassoc x $macroassoc)) (x)))
   ((atom x) x)
   ((eq (setq op (first x)) 'where) (def-where (cdr x)))
   ((eq op 'repeat) (def-repeat (cdr x)))
   ((eq op 'collect) (def-collect (cdr x)))
   ((eq op 'makestring)
          (cond ((stringp (second x)) x)
                ((eqcar (second x) 'quote)
                 (list 'makestring (stringimage (cadadr x))))
                ((list 'makestring (deftran (second x))))))
   ((eq op 'quote)
          (if (stringp (setq y (second x))) (list 'makestring y)
             (if (and (identp y) (char= (elt (pname y) 0) #\.))
                 `(intern ,(pname y) ,(package-name *package*)) x)))
   ((eq op 'is) (|defIS| (second x) (third x)))
   ((eq op 'spadlet) (def-let (second x) (third x)))
   ((eq op 'dcq) (list 'dcq (second x) (deftran (third x))))
   ((eq op 'cond) (cons 'cond (def-cond (cdr x))))
   ((member (first x) '(|sayBrightly| say moan croak) :test #'eq)
          (def-message x))
   ((setq y (getl (first x) 'def-tran))
          (funcall y (mapcar #'deftran (cdr x))))
   ((mapcar #'deftran x)))))

@
\defun{def-process}{def-process}
\calls{def-process}{def}
\calls{def-process}{b-mdef}
\calls{def-process}{eqcar}
\calls{def-process}{def-process}
\calls{def-process}{is-console}
\calls{def-process}{say}
\calls{def-process}{deftran}
\calls{def-process}{print-full}
\calls{def-process}{deftran}
\usesdollar{def-process}{macroassoc}
<<defun def-process>>=
(defun def-process (x &aux $macroassoc)
 (cond
  ((eqcar x 'def)
   (def (second x) (third x) (first (cddddr x))))
  ((eqcar x 'mdef)
   (b-mdef (second x) (third x) (first (cddddr x))))
  ((and (eqcar x 'where) (eqcar (second x) 'def))
   (let* ((u (second x)) (y (cdr u)))
    (def-process
     (list 'def
      (car y)
      (car (setq y (cdr y)))
      (car (setq y (cdr y)))
      (cons 'where (cons (car (setq y (cdr y))) (cddr x)))))))
  ((is-console *standard-output*)
   (say "  VALUE = " (eval (deftran x))))
  ((print-full (deftran x)))))

@

\defun{def-rename}{def-rename}
\calls{def-rename}{def-rename1}
<<defun def-rename>>=
(defun def-rename (x)
 (def-rename1 x))

@

\defun{def-rename1}{def-rename1}
\calls{def-rename1}{def-rename1}
<<defun def-rename1>>=
(defun def-rename1 (x)
 (cond
  ((symbolp x)
   (let ((y (get x 'rename))) (if y (first y) x)))
  ((and (listp x) x)
   (if (eqcar x 'quote)
       x
       (cons (def-rename1 (first x)) (def-rename1 (cdr x)))))
  (x)))

@

\defun{def-insert-let}{def-insert-let}
\calls{def-insert-let}{def-insert-let}
\calls{def-insert-let}{deftran}
\calls{def-insert-let}{def-let}
\calls{def-insert-let}{errhuh}
<<defun def-insert-let>>=
(defun def-insert-let (x)
 (labels (
  (insert-let1 (y)
   (declare (special $body))
    (if (and (consp y) (eq (qcar y) 'spadlet))
     (cond 
      ((identp (second y))
       (setq $body (cons 'progn (list (def-let (third y) (second y)) $body)))
       (setq y (second y)))
      ((identp (third y))
       (setq $body (cons 'progn (list (deftran y) $body))) (setq y (third y)))
      ((errhuh)))
     y)))
 (if (atom x) 
  x
  (cons (insert-let1 (first x)) (def-insert-let (cdr x))))))

@

\defun{def-let}{def-let}
\calls{def-let}{deftran}
\calls{def-let}{defLET}
<<defun def-let>>=
(defun def-let (form rhs)
 (let (f1 f2)
  (unless (and (consp form) (eq (qcar form) '\:))
   (setq form (macroexpand form)))
  (cond
   ((and (consp form) (eq (qcar form) '\:))
    (setq f1 (deftran form))
    (setq f2 (deftran (list 'spadlet (second form) rhs)))
    (if (and (eq (car f2) 'spadlet) (equal (second f2) (second form)))
      (list 'spadlet (second f1) (third f2))
      (list 'progn f1 f2)))
   ((and (consp form) (eq (qcar form) 'elt))
     (deftran (list 'setelt (second form) (third form) rhs)))
   (t 
     (|defLET| form (deftran rhs))))))

@

\defun{defLET}{defLET}
\calls{defLET}{defLET1}
\usesdollar{defLET}{letGenVarCounter}
\usesdollar{defLET}{inDefLET}
<<defun defLET>>=
(defun |defLET| (lhs rhs)
 (let (|$letGenVarCounter| |$inDefLET|)
 (declare (special |$letGenVarCounter| |$inDefLET|))
  (setq |$letGenVarCounter| 1)
  (setq |$inDefLET| t)
  (|defLET1| lhs rhs)))

@

\defun{defLET1}{defLET1}
\calls{defLET1}{identp}
\calls{defLET1}{defLetForm}
\calls{defLET1}{contained}
\calls{defLET1}{defLET2}
\calls{defLET1}{mkprogn}
\calls{defLET1}{defLET1}
\calls{defLET1}{strconc}
\calls{defLET1}{stringimage}
\usesdollar{defLET1}{let}
\usesdollar{defLET1}{letGenVarCounter}
<<defun defLET1>>=
(defun |defLET1| (lhs rhs)
 (let (name l1 l2 g rhsprime letprime)
 (declare (special $let |$letGenVarCounter|))
  (cond
   ((identp lhs) (|defLetForm| lhs rhs))
   ((and (pairp lhs) (eq (qcar lhs) 'fluid)
         (pairp (qcdr lhs)) (eq (qcdr (qcdr lhs)) nil))
     (|defLetForm| lhs rhs))
   ((and (identp rhs) (null (contained rhs lhs)))
    (setq rhsprime (|defLET2| lhs rhs))
    (cond
     ((and (consp rhsprime) (eql (qcar rhsprime) $let))
       (mkprogn (list rhsprime rhs)))
     ((and (consp rhsprime) (eq (qcar rhsprime) 'progn))
      (append rhsprime (list rhs)))
     (t
      (when (identp (car rhsprime)) (setq rhsprime (list rhsprime)))
      (mkprogn (append rhsprime (list rhs))))))
   ((and (pairp rhs) (eqcar rhs $let) (identp (setq name (cadr rhs))))
     (setq l1 (|defLET1| name (third rhs)))
     (setq l2 (|defLET1| lhs name))
     (if (and (consp l2) (eq (qcar l2) 'progn))
      (mkprogn (cons l1 (cdr l2)))
      (progn
        (when (identp (car l2)) (setq l2 (list l2)))
        (mkprogn (cons l1 (append l2 (list name)))))))
   (t
    (setq g (intern (strconc "LETTMP#" (stringimage |$letGenVarCounter|))))
    (setq |$letGenVarCounter| (1+ |$letGenVarCounter|))
    (setq rhsprime (list $let g rhs))
    (setq letprime (|defLET1| lhs g))
    (if (and (consp letprime) (eq (qcar letprime) 'progn))
     (mkprogn (cons rhsprime (cdr letprime)))
     (progn
      (when (identp (car letprime)) (setq letprime (list letprime)))
      (mkprogn (cons rhsprime (append letprime (list g))))))))))


@

\defun{defLET2}{defLET2}
\calls{defLET2}{identp}
\calls{defLET2}{defLetForm}
\calls{defLET2}{qcar}
\calls{defLET2}{qcdr}
\calls{defLET2}{defLET2}
\calls{defLET2}{addCARorCDR}
\calls{defLET2}{defISReverse}
\calls{defLET2}{strconc}
\calls{defLET2}{stringimage}
\calls{defLET2}{defIS1}
\calls{defLET2}{defIS}
\usesdollar{defLET2}{inDefIS}
\usesdollar{defLET2}{let}
\usesdollar{defLET2}{letGenVarCounter}
<<defun defLET2>>=
(defun |defLET2| (lhs rhs)
 (let (a b l1 var2 patrev rev g l2 val1 var1 isPred)
 (declare (special |$inDefIS| $let |$letGenVarCounter|))
  (cond
   ((identp lhs) (|defLetForm| lhs rhs))
   ((null lhs) nil)
   ((and (pairp lhs) (eq (qcar lhs) 'fluid)
         (pairp (qcdr lhs)) (eq (qcdr (qcdr lhs)) nil))
     (|defLetForm| lhs rhs))
   ((and (pairp lhs) (equal (qcar lhs) $let)
         (pairp (qcdr lhs)) (pairp (qcdr (qcdr lhs))) 
         (eq (qcdr (qcdr (qcdr lhs))) nil))
     (setq a (|defLET2| (qcar (qcdr lhs)) rhs))
     (setq b (qcar (qcdr (qcdr lhs))))
     (cond
      ((null (setq b (|defLET2| b rhs))) a)
      ((atom b) (list a b))
      ((pairp (qcar b)) (cons a b))
      (t (list a b))))
   ((and (pairp lhs) (eq (qcar lhs) 'cons)
         (pairp (qcdr lhs)) (pairp (qcdr (qcdr lhs)))
         (eq (qcdr (qcdr (qcdr lhs))) nil))
     (setq var1 (qcar (qcdr lhs)))
     (setq var2 (qcar (qcdr (qcdr lhs))))
     (if (or (eq var1 (intern "." "BOOT"))
         (and (pairp var1) (eqcar var1 'quote)))
      (|defLET2| var2 (|addCARorCDR| 'cdr rhs))
      (progn
       (setq l1 (|defLET2| var1 (|addCARorCDR| 'car rhs)))
       (if (member var2 '(nil |.|)) 
        l1
        (progn
         (when (and (pairp l1) (atom (car l1))) (setq l1 (cons l1 nil)))
         (if (identp var2)
          (append l1 (cons (|defLetForm| var2 (|addCARorCDR| 'cdr rhs)) nil))
          (progn
           (setq l2 (|defLET2| var2 (|addCARorCDR| 'cdr rhs)))
           (when (and (pairp l2) (atom (car l2))) (setq l2 (cons l2 nil)))
           (append l1 l2))))))))
   ((and (pairp lhs) (eq (qcar lhs) 'append)
         (pairp (qcdr lhs)) (pairp (qcdr (qcdr lhs)))
         (eq (qcdr (qcdr (qcdr lhs))) nil))
     (setq var1 (qcar (qcdr lhs)))
     (setq var2 (qcar (qcdr (qcdr lhs))))
     (setq patrev (|defISReverse| var2 var1))
     (setq rev (list 'reverse rhs))
     (setq g (intern (strconc "LETTMP#" (stringimage |$letGenVarCounter|))))
     (setq |$letGenVarCounter| (1+ |$letGenVarCounter|))
     (setq l2 (|defLET2| patrev g))
     (when (and (pairp l2) (atom (car l2))) (setq l2 (cons l2 nil)))
     (cond
      ((eq var1 (intern "." "BOOT"))
       (cons (list $LET g rev) l2))
      ((and (pairp (|last| l2)) (equal (qcar (|last| l2)) $let)
            (pairp (qcdr (|last| l2)))
            (equal (qcar (qcdr (|last| l2))) var1)
            (pairp (qcdr (qcdr (|last| l2))))
            (eq (qcdr (qcdr (qcdr (|last| l2)))) nil))
        (setq val1 (qcar (qcdr (qcdr (|last| l2)))))
        (cons
         (list $let g rev)
         (append 
          (reverse (cdr (reverse l2)))
          (list (|defLetForm| var1 (list 'nreverse val1))))))
      (t
       (cons
        (list $let g rev)
        (append l2 (list (|defLetForm| var1 (list 'nreverse var1))))))))
   ((and (pairp lhs) (eq (qcar lhs) 'equal)
         (pairp (qcdr lhs)) (eq (qcdr (qcdr lhs)) nil))
     (setq var1 (qcar (qcdr lhs)))
     (list 'cond (list (list 'equal var1 rhs) var1)))
   (t
    (setq isPred
     (if |$inDefIS| 
      (|defIS1| rhs lhs)
      (|defIS| rhs lhs)))
    (list 'cond (list isPred rhs))))))

@

\defun{defLetForm}{defLetForm}
\usesdollar{defLetForm}{let}
<<defun defLetForm>>=
(defun |defLetForm| (lhs rhs)
 (declare (special $let))
 (list $let lhs rhs))

@

\defdollar{defstack}
<<initvars>>=
(defparameter $defstack nil)

@
\defun{def-where}{def-where}
\calls{def-where}{def-whereclauselist}
\calls{def-where}{def-inner}
\calls{def-where}{sublis}
\calls{def-where}{mkprogn}
\calls{def-where}{deftran}
\usesdollar{def-where}{defstack}
\usesdollar{def-where}{opassoc}
<<defun def-where>>=
(defun def-where (args)
 (let ((x (car args)) (y (cdr args)) $defstack)
 (declare (special $defstack $opassoc))
  (let ((u (def-whereclauselist y)))
   (mapc #'(lambda (X) (def-inner (first x) nil (sublis $opassoc (second x))))
         $defstack)
   (mkprogn (nconc u (list (deftran x)))))))

@

\defun{def-whereclauselist}{def-whereclauselist}
\calls{def-whereclauselist}{def-whereclause}
\calls{def-whereclauselist}{deftran}
<<defun def-whereclauselist>>=
(defun def-whereclauselist (l)
 (if (not (cdr l))
  (def-whereclause (deftran (first l)))
  (reduce #'append (mapcar #'(lambda (u) (def-whereclause (deftran u))) l))))

@

\defun{def-whereclause}{def-whereclause}
\calls{def-whereclause}{eqcar}
\calls{def-whereclause}{def-whereclause}
\calls{def-whereclause}{whdef}
<<defun def-whereclause>>=
(defun def-whereclause (x)
 (cond 
  ((or (eqcar x 'seq) (eqcar x 'progn))
   (reduce #'append (mapcar #'def-whereclause (cdr x))))
  ((eqcar x 'def)
   (whdef (second x) (first (cddddr x))) nil)
  ((and (eqcar x '|exit|) (eqcar (second x) 'def))
   (whdef (cadadr x) (first (cddddr (second x)) )) nil)
  ((list x))))

@

\defun{def-message}{def-message}
\calls{def-message}{def-message1}
<<defun def-message>>=
(defun def-message (u)
 (cons (first u) (mapcar #'def-message1 (cdr u))))

@

\defun{def-message1}{def-message1}
\calls{def-message1}{eqcar}
\calls{def-message1}{def-message1}
\calls{def-message1}{deftran}
<<defun def-message1>>=
(defun def-message1 (v)
 (cond
  ((and (stringp v) (> (size v) 0) (not (eq (elt v 0) '\%)))
   (list 'makestring v))
  ((eqcar v 'cons)
   (list 'cons (def-message1 (second v)) (def-message1 (third v))))
  ((deftran v))))

@

\defun{def-in2on}{def-in2on}
\calls{def-in2on}{eqcar}
<<defun def-in2on>>=
(defun def-in2on (it)
 (mapcar 
  #'(lambda (x) (let (u)
     (cond
      ((and (eqcar x 'in) (eqcar (third x) '|tails|))
       (list 'on (second x) (second (third x))))
      ((and (eqcar x 'in) (eqcar (setq u (third x)) 'segment))
       (cond
        ((third u) (list 'step (second x) (second u) 1 (third u)))
        ((list 'step (second x) (second u) 1))))
      ((and (eqcar x 'inby) (eqcar (setq u (third x)) 'segment))
       (cond
        ((third u) (list 'step (second x) (second u) (|last| x) (third u)))
        ((list 'step (second x) (second u) (|last| x)))))
      (x))))
    it))

@

\defun{def-cond}{def-cond}
\calls{def-cond}{deftran}
\calls{def-cond}{def-cond}
<<defun def-cond>>=
(defun def-cond (l)
 (cond
  ((not l) nil)
  ((cons (mapcar #'deftran (first l)) (def-cond (cdr l))))))

@

\defdollar{is-spill}
<<initvars>>=
(defvar $is-spill nil)

@

\defdollar{is-spill-list}
<<initvars>>=
(defvar $is-spill-list nil)

@

\defun{def-is-eqlist}{def-is-eqlist}
\calls{def-is-eqlist}{}
\usesdollar{def-is-eqlist}{is-eqlist}
\usesdollar{def-is-eqlist}{is-spill-list}
<<defun def-is-eqlist>>=
(defun def-is-eqlist (str)
 (let (g e)
  (declare (special $is-eqlist $is-spill-list))
  (cond
   ((not str) (push `(eq ,(setq g (is-gensym)) nil) $is-eqlist) g)
   ((eq str '\.) (is-gensym))
   ((identp str) str)
   ((stringp str)
     (setq e (def-string str))
     (push (list (if (atom (second e)) 'eq 'equal)
                 (setq g (is-gensym)) e)
        $is-eqlist)
     g)
   ((or (numberp str) (member str '((|Zero|) (|One|))))
    (push (list 'eq (setq g (is-gensym)) str) $is-eqlist)
    g)
   ((atom str) (errhuh))
   ((eqcar str 'spadlet)
    (cond
     ((identp (second str))
      (push (def-is2 (second str) (third str)) $is-spill-list)
      (second str))
     ((identp (third str))
       (push (deftran str) $is-spill-list) (third str))
     ((errhuh))))
   ((eqcar str 'quote)
    (push (list (cond ((atom (second str)) 'eq) ('equal))
                (setq g (is-gensym)) str) 
          $is-eqlist) 
     g)
   ((eqcar str 'list) (def-is-eqlist (list2cons str)))
   ((or (eqcar str 'cons) (eqcar str 'vcons))
     (cons (def-is-eqlist (second str)) (def-is-eqlist (third str))))
   ((eqcar str 'append)
     (unless (identp (second str)) (error "CANT!"))
     (push (def-is2 (list 'reverse (setq g (is-gensym)))
                    (def-is-rev (third str) (second str)))
       $is-eqlist)
     (cond ((eq (second str) '\.) ''t)
      ((push (subst (second str) 'l '(or (setq l (nreverse l)) t))
         $is-spill-list)))
     g)
   ((errhuh)))))

@

\defdollar{vl}
<<initvars>>=
(defparameter $vl nil)

@

\defun{def-is-remdup}{def-is-remdup}
\calls{def-is-remdup}{def-is-remdup1}
\usesdollar{def-is-remdup}{vl}
<<defun def-is-remdup>>=
(defun def-is-remdup (x)
 (let ($vl)
  (def-is-remdup1 x)))

@

\defun{def-is-remdup1}{def-is-remdup1}
\calls{def-is-remdup1}{is-gensym}
\calls{def-is-remdup1}{eqcar}
\calls{def-is-remdup1}{def-is-remdup1}
\calls{def-is-remdup1}{errhuh}
\usesdollar{def-is-remdup1}{vl}
\usesdollar{def-is-remdup1}{is-eqlist}
<<defun def-is-remdup1>>=
(defun def-is-remdup1 (x)
 (let (rhs lhs g)
 (declare (special $vl $is-eqlist))
  (cond
   ((not x) nil)
   ((eq x '\.) x)
   ((identp x)
    (cond
     ((member x $vl)
      (push (list 'equal (setq g (is-gensym)) x) $is-eqlist)
      g)
     ((push x $vl)
      x)))
   ((member x '((|Zero|) (|One|))) x)
   ((atom x) x)
   ((eqcar x 'spadlet)
     (setq rhs (def-is-remdup1 (third x)))
     (setq lhs (def-is-remdup1 (second x)))
     (list 'spadlet lhs rhs))
   ((eqcar x 'let)
     (setq rhs (def-is-remdup1 (third x)))
     (setq lhs (def-is-remdup1 (second x)))
     (list 'let lhs rhs))
   ((eqcar x 'quote) x)
   ((and (eqcar x 'equal) (not (cddr x)))
     (push (list 'equal (setq g (is-gensym)) (second x)) $is-eqlist)
     g)
   ((member (first x) '(list append cons vcons))
    (cons
     (cond ((eq (first x) 'vcons) 'cons) ( (first x)))
     (mapcar #'def-is-remdup1 (cdr x))))
   ((errhuh)))))

@

\defun{addCARorCDR}{addCARorCDR}
\calls{addCARorCDR}{eqcar}
\calls{addCARorCDR}{qcdr}
\calls{addCARorCDR}{qcar}
<<defun addCARorCDR>>=
(defun |addCARorCDR| (acc expr)
 (let (funs p funsA funsR)
  (cond
   ((null (pairp expr)) (list acc expr))
   ((and (eq acc 'car) (eqcar expr 'reverse)) (cons '|last| (qcdr expr)))
   (t
    (setq funs
     '(car cdr caar cdar cadr cddr caaar cadar caadr caddr
       cdaar cddar cdadr cdddr))
    (setq p (position (qcar expr) funs))
    (if (null p)
     (list acc expr)
     (progn
      (setq funsA
       '(caar cadr caaar cadar caadr caddr caaaar caadar caaadr caaddr
         cadaar caddar cadadr cadddr))
      (setq funsR
       '(cdar cddr cdaar cddar cdadr cdddr cdaaar cdadar cdaadr cdaddr
         cddaar cdddar cddadr cddddr))
      (if (eq acc 'car)
       (cons (elt funsA p) (qcdr expr))
       (cons (elt funsR p) (qcdr expr)))))))))

@

<<initvars>>=
(defparameter $IS-GENSYMLIST nil)

@

<<initvars>>=
(defparameter Initial-Gensym (list (gensym)))

@

\subsection{IS}
\defun{def-is}{def-is}
\calls{def-is}{def-is2}
\usesdollar{def-is}{is-gensymlist}
\uses{def-is}{Initial-Gensym}
<<defun def-is>>=
(defun def-is (x)
 (let (($is-gensymlist Initial-Gensym))
  (declare (special is-gensymlist Initial-Gensym))
  (def-is2 (first X) (second x))))

@

\defdollar{is-eqlist}
<<initvars>>=
(defparameter $is-eqlist nil)

@

\defun{def-is2}{def-is2}
\calls{def-is2}{eqcar}
\calls{def-is2}{moan}
\calls{def-is2}{def-is-eqlist}
\calls{def-is2}{def-is-remdup}
\calls{def-is2}{mkpf}
\calls{def-is2}{subst}
\calls{def-is2}{dcq}
\calls{def-is2}{listofatoms}
\calls{def-is2}{/tracelet-print}
\usesdollar{def-is2}{is-eqlist}
\usesdollar{def-is2}{is-spill-list}
<<defun def-is2>>=
(defun def-is2 (form struct)
 (let ($is-eqlist $is-spill-list (form (deftran form)))
  (when (eqcar struct '|@Tuple|)
   (moan "you must use square brackets around right arg. to" '%b "is" '%d))
  (let* ((x (def-is-eqlist (def-is-remdup struct)))
         (code (if (identp x)
                     (mkpf (subst form x $is-eqlist) 'and)
                     (mkpf `((dcq ,x ,form) . ,$is-eqlist) 'and))))
   (let ((code (mkpf `(,code . ,$is-spill-list) 'and)))
    (if $traceletflag
     (let ((l (remove-if #'gensymp (listofatoms x))))
      `(prog1 ,code ,@(mapcar #'(lambda (y) `(/tracelet-print ,y ,y)) L)))
     code)))))

@

\defun{defIS}{defIS}
\calls{defIS}{deftran}
\calls{defIS}{defIS1}
\usesdollar{defIS}{isGenVarCounter}
\usesdollar{defIS}{inDefIS}
<<defun defIS>>=
(defun |defIS| (lhs rhs)
 (let (|$isGenVarCounter| |$inDefIS|)
 (declare (special |$isGenVarCounter| |$inDefIS|))
  (setq |$isGenVarCounter| 1)
  (setq |$inDefIS| t)
  (|defIS1| (deftran lhs) rhs)))

@

\defun{defIS1}{defIS1}
\calls{defIS1}{defLetForm}
\calls{defIS1}{defLET1}
\calls{defIS1}{defLET}
\calls{defIS1}{defIS1}
\calls{defIS1}{mkprogn}
\calls{defIS1}{strconc}
\calls{defIS1}{stringimage}
\calls{defIS1}{qcar}
\calls{defIS1}{qcdr}
\calls{defIS1}{defISReverse}
\calls{defIS1}{say}
\calls{defIS1}{def-is}
\usesdollar{defIS1}{let}
\usesdollar{defIS1}{isGenVarCounter}
\usesdollar{defIS1}{inDefLET}
<<defun defIS1>>=
(defun |defIS1| (lhs rhs)
 (let (d l a1 b1 c cls a b patrev g rev l2)
 (declare (special $let |$isGenVarCounter| |$inDefLET|))
 (cond
  ((null rhs) (list 'null lhs))
  ((stringp rhs) (list 'eq lhs (list 'quote (intern rhs))))
  ((numberp rhs) (list 'equal lhs rhs))
  ((atom rhs) (list 'progn (|defLetForm| rhs lhs) 't))
  ((and (pairp rhs) (eq (qcar rhs) 'quote)
        (pairp (qcdr rhs)) (eq (qcdr (qcdr rhs)) nil))
    (if (identp (qcar (qcdr rhs)))
     (list 'eq lhs rhs)
     (list 'equal lhs rhs)))
  ((and (pairp rhs) (equal (qcar rhs) $let)
         (pairp (qcdr rhs)) (pairp (qcdr (qcdr rhs)))
         (eq (qcdr (qcdr (qcdr rhs))) nil))
    (setq c (qcar (qcdr rhs)))
    (setq d (qcar (qcdr (qcdr rhs))))
    (setq l
     (if |$inDefLET|
      (|defLET1| c lhs)
      (|defLET| c lhs)))
    (list 'and (|defIS1| lhs d) (mkprogn (list l t))))
  ((and (pairp rhs) (eq (qcar rhs) 'equal)
        (pairp (qcdr rhs)) (eq (qcdr (qcdr rhs)) nil))
   (setq a (qcar (qcdr rhs)))
   (list 'equal lhs a ))
  ((pairp lhs)
   (setq g (intern (strconc "ISTMP#" (stringimage |$isGenVarCounter|))))
   (setq |$isGenVarCounter| (1+ |$isGenVarCounter|))
   (mkprogn (list (list $let g lhs) (|defIS1| g rhs))))
  ((and (pairp rhs) (eq (qcar rhs) 'cons) (pairp (qcdr rhs))
        (pairp (qcdr (qcdr rhs))) (eq (qcdr (qcdr (qcdr rhs))) nil))
    (setq a (qcar (qcdr rhs)))
    (setq b (qcar (qcdr (qcdr rhs))))
    (cond
     ((eq a (intern "." "BOOT"))
      (if (null b)
       (list 'and (list 'pairp lhs) (list 'eq (list 'qcdr lhs) nil))
       (list 'and (list 'pairp lhs) (|defIS1| (list 'qcdr lhs) b))))
     ((null b)
      (list 'and (list 'pairp lhs) 
                 (list 'eq (list 'qcdr lhs) nil)
                 (|defIS1| (list 'qcar lhs) a)))
     ((eq b (intern "." "BOOT"))
       (list 'and (list 'pairp lhs) (|defIS1| (list 'qcar lhs) a)))
     (t
      (setq a1 (|defIS1| (list 'qcar lhs) a))
      (setq b1 (|defIS1| (list 'qcdr lhs) b))
      (cond
       ((and (pairp a1) (eq (qcar a1) 'progn)
             (pairp (qcdr a1)) (pairp (qcdr (qcdr a1)))
             (eq (qcdr (qcdr (qcdr a1))) nil)
             (equal (qcar (qcdr (qcdr a1))) t)
             (pairp b1) (eq (qcar b1) 'progn))
         (setq c (qcar (qcdr a1)))
         (setq cls (qcdr b1))
         (list 'and (list 'pairp lhs) (mkprogn (cons c cls))))
       (t
        (list 'and (list 'pairp lhs) a1 b1))))))
  ((and (pairp rhs) (eq (qcar rhs) 'append) (pairp (qcdr rhs))
        (pairp (qcdr (qcdr rhs))) (eq (qcdr (qcdr (qcdr rhs))) nil))
    (setq a (qcar (qcdr rhs)))
    (setq b (qcar (qcdr (qcdr rhs))))
    (setq patrev (|defISReverse| b a))
    (setq g (intern (strconc "ISTMP#" (stringimage |$isGenVarCounter|))))
    (setq |$isGenVarCounter| (1+ |$isGenVarCounter|))
    (setq rev
     (list 'and
       (list 'pairp lhs)
       (list 'progn (list $let g  (list 'reverse lhs)) t)))
    (setq l2 (|defIS1| g patrev))
    (when  (and (pairp l2) (atom (car l2))) (setq l2 (list l2)))
    (cond
     ((eq a (intern "." "BOOT"))
      (cons 'and (cons rev l2)))
     (t
      (cons 'and
       (cons rev
        (append l2
         (list
          (list 'progn (list (|defLetForm| a (list 'nreverse a )) t)))))))))
  (t
   (say "WARNING (defIS1): possibly bad IS code being generated")
   (def-is (list lhs rhs))))))

@

\defun{def-is-rev}{def-is-rev}
\calls{def-is-rev}{def-is-rev}
\calls{def-is-rev}{errhuh}
<<defun def-is-rev>>=
(defun def-is-rev (x a)
 (let (y)
  (if (eq (first x) 'cons)
   (cond
    ((not (third x)) (list 'cons (second x) a))
    ((setq y (def-is-rev (third x) nil))
      (setf (third y) (list 'cons (second x) a))
      y))
   (errhuh))))

@

\defun{defISReverse}{defISReverse}
This reverses forms coming from APPENDs in patterns. 
It is pretty much just a translation of DEF-IS-REV
\calls{defISReverse}{defISReverse}
\calls{defISReverse}{errhuh}
<<defun defISReverse>>=
(defun |defISReverse| (x a)
 (let (y)
  (if (and (pairp x) (eq (qcar x) 'cons))
   (if (null (caddr x))
     (list 'cons (cadr x) a)
     (progn 
      (setq y (|defISReverse| (caddr x) nil))
      (rplac (caddr y) (list 'cons (cadr x) a))
      y))
   (errhuh))))

@

\defun{def-collect}{def-collect}
\calls{def-collect}{def-it}
\calls{def-collect}{deftran}
\calls{def-collect}{hackforis}
<<defun def-collect>>=
(defun def-collect (l)
 (def-it 'collect (mapcar #'deftran (hackforis l))))

@

\defun{def-it}{def-it}
\calls{def-it}{def-in2on}
\calls{def-it}{deftran}
\calls{def-it}{reset}
\calls{def-it}{def-let}
\calls{def-it}{errhuh}
<<defun def-it>>=
(defun def-it (fn l)
 (setq l (reverse l))
 (let ((b (first l)))
  (let ((it (def-in2on (nreverse (rest l)))))
   (let ((itp
          (apply #'append
           (mapcar
             #'(lambda (x &aux op y g)
                (if (and (member (setq op (first x)) '(in on))
                         (not (atom (second x))))
                  (if (eqcar (setq y (second x)) 'spadlet)
                   (if (atom (setq g (second y)))
                    (list 
                     `(,op ,g ,(deftran (third x)))
                     `(reset ,(def-let (deftran (third y)) g)))
                    (errhuh))
                   (list
                    `(,op ,(setq g (gensym)) ,(deftran (third x)))
                    `(reset ,(def-let (deftran (second x)) g))))
                  `(,x)))
            it))))
    (cons fn (nconc itp (list b)))))))

@

\defun{def-repeat}{def-repeat}
\calls{def-repeat}{def-it}
\calls{def-repeat}{deftran}
\calls{def-repeat}{hackforis}
<<defun def-repeat>>=
(defun def-repeat (l)
 (def-it 'repeat (mapcar #'deftran (hackforis l))))

@

\defun{def-string}{def-string}
\calls{def-string}{deftran}
\uses{def-string}{*package*}
<<defun def-string>>=
(defun def-string (x)
 ;; following patches needed to fix reader bug in Lucid Common Lisp
  (if (and (> (size x) 0) (or (char= (elt x 0) #\.) (char= (elt x 0) #\Page)))
   `(intern ,X ,(package-name *package*))
   `(quote ,(deftran (intern x)))))

@

\defun{def-stringtoquote}{def-stringtoquote}
\calls{def-stringtoquote}{def-addlet}
\calls{def-stringtoquote}{def-stringtoquote}
<<defun def-stringtoquote>>=
(defun def-stringtoquote (x)
 (cond
  ((stringp x) (list 'quote (intern x)))
  ((atom x) x)
  ((cons (def-addlet (first x)) (def-stringtoquote (cdr x))))))

@

\defun{def-addlet}{def-addlet}
\calls{def-addlet}{mkprogn}
\calls{def-addlet}{def-let}
\calls{def-addlet}{compfluidize}
\usesdollar{def-addlet}{body}
<<defun def-addlet>>=
(defun def-addlet (x)
 (declare (special $body))
 (if (atom x)
  (if (stringp x) `(quote ,(intern x))  x)
  (let ((g (gensym)))
   (setq $body (mkprogn (list (def-let (compfluidize x) g) $body)))
   g)))

@

\defun{def-inner}{def-inner}
\calls{def-inner}{def-insert-let}
\calls{def-inner}{def-stringtoquote}
\calls{def-inner}{sublis}
\calls{def-inner}{comp}
\usesdollar{def-inner}{body}
\usesdollar{def-inner}{OpAssoc}
\usesdollar{def-inner}{op}
<<defun def-inner>>=
(defun def-inner (form signature $body)
  "Same as DEF but assumes body has already been DEFTRANned"
 (declare (special $body) (ignore signature))
 (let ($OpAssoc ($op (first form)) (argl (rest form)))
 (declare (special $OpAssoc $op))
   (let* ((argl (def-insert-let argl))
          (arglp (def-stringtoquote argl)))
    (comp (sublis $opassoc `((,$op (lam ,arglp ,$body))))))))

\defun{hackforis}{hackforis}
\calls{hackforis}{hackforis1}
<<defun hackforis>>=
(defun hackforis (l) (mapcar #'hackforis1 L))

@

\defun{hackforis1}{hackforis1}
\calls{hackforis1}{kar}
\calls{hackforis1}{eqcar}
<<defun hackforis1>>=
(defun hackforis1 (x)
 (if (and (member (kar x) '(in on)) (eqcar (second x) 'is))
  (cons (first x) (cons (cons 'spadlet (cdadr x)) (cddr x)))
  x))

@

\defun{unTuple}{unTuple}
<<defun unTuple>>=
(defun |unTuple| (x)
 (if (and (pairp x) (eq (qcar x) '|@Tuple|))
  (qcdr x)
  (list x)))

@

\defun{errhuh}{errhuh}
\calls{errhuh}{systemError}
<<defun errhuh>>=
(defun errhuh ()
 (|systemError| "problem with BOOT to LISP translation"))

@

\chapter{PARSE forms}
\section{The original meta specification}
This package provides routines to support the Metalanguage
translator writing system.   Metalanguage is described
in META/LISP, R.D. Jenks, Tech Report, 
IBM T.J. Watson Research Center, 1969.  
Familiarity with this document is assumed.

Note that META/LISP and the meta parser/generator were removed from Axiom.
This information is only for documentation purposes.

\begin{verbatim}
%       Scratchpad II Boot Language Grammar, Common Lisp Version
%       IBM Thomas J. Watson Research Center
%       Summer, 1986
%
%       NOTE: Substantially different from VM/LISP version, due to
%             different parser and attempt to render more within META proper.

.META(New NewExpr Process)
.PACKAGE 'BOOT'
.DECLARE(tmptok TOK ParseMode DEFINITION-NAME LABLASOC)
.PREFIX 'PARSE-'

NewExpr:        =')' .(processSynonyms) Command
              / .(SETQ DEFINITION-NAME (CURRENT-SYMBOL)) Statement ;

Command:        ')' SpecialKeyWord SpecialCommand +() ;

SpecialKeyWord: =(MATCH-CURRENT-TOKEN "IDENTIFIER)
                .(SETF (TOKEN-SYMBOL (CURRENT-TOKEN)) (unAbbreviateKeyword (CURRENT-SYMBOL))) ;

SpecialCommand: 'show' <'?' / Expression>! +(show #1) CommandTail
              / ?(MEMBER (CURRENT-SYMBOL) \$noParseCommands)
                 .(FUNCALL (CURRENT-SYMBOL))
              / ?(MEMBER (CURRENT-SYMBOL) \$tokenCommands) TokenList
                  TokenCommandTail
              / PrimaryOrQM* CommandTail ;

TokenList:      (^?(isTokenDelimiter) +=(CURRENT-SYMBOL) .(ADVANCE-TOKEN))* ;

TokenCommandTail:
                <TokenOption*>! ?(atEndOfLine) +(#2 -#1) .(systemCommand #1) ;

TokenOption:    ')' TokenList ;

CommandTail:    <Option*>! ?(atEndOfLine) +(#2 -#1) .(systemCommand #1) ;

PrimaryOrQM:    '?' +\? / Primary ;

Option:         ')' PrimaryOrQM* ;

Statement:      Expr{0} <(',' Expr{0})* +(Series #2 -#1)>;

InfixWith:      With +(Join #2 #1) ;

With:           'with' Category +(with #1) ;

Category:      'if' Expression 'then' Category <'else' Category>! +(if #3 #2 #1)
              / '(' Category <(';' Category)*>! ')' +(CATEGORY #2 -#1)
              / .(SETQ $1 (LINE-NUMBER CURRENT-LINE)) Application 
                   ( ':' Expression +(Signature #2 #1)
                             .(recordSignatureDocumentation ##1 $1)
                           / +(Attribute #1)
                             .(recordAttributeDocumentation ##1 $1));

Expression:   Expr{(PARSE-rightBindingPowerOf (MAKE-SYMBOL-OF PRIOR-TOKEN) ParseMode)}
                +#1 ;

Import:         'import' Expr{1000} <(',' Expr{1000})*>! +(import #2 -#1) ;

Infix:          =TRUE +=(CURRENT-SYMBOL) .(ADVANCE-TOKEN) <TokTail>
                Expression +(#2 #2 #1) ;

Prefix:         =TRUE +=(CURRENT-SYMBOL) .(ADVANCE-TOKEN) <TokTail>
                Expression +(#2 #1) ;

Suffix:         +=(CURRENT-SYMBOL) .(ADVANCE-TOKEN) <TokTail> +(#1 #1) ;

TokTail:        ?(AND (NULL \$BOOT) (EQ (CURRENT-SYMBOL) "\$)
                      (OR (ALPHA-CHAR-P (CURRENT-CHAR))
                          (CHAR-EQ (CURRENT-CHAR) '$')
                          (CHAR-EQ (CURRENT-CHAR) '\%')
                          (CHAR-EQ (CURRENT-CHAR) '(')))
                .(SETQ $1 (COPY-TOKEN PRIOR-TOKEN)) Qualification
                .(SETQ PRIOR-TOKEN $1) ;

Qualification:  '$' Primary1 +=(dollarTran #1 #1) ;

SemiColon:      ';' (Expr{82} / + \/throwAway) +(\; #2 #1) ;

Return:         'return' Expression +(return #1) ;

Exit:           'exit' (Expression / +\$NoValue) +(exit #1) ;

Leave:          'leave' ( Expression / +\$NoValue )
                ('from' Label +(leaveFrom #1 #1) / +(leave #1)) ;

Seg:            GliphTok{"\.\.} <Expression>! +(SEGMENT #2 #1) ;

Conditional:    'if' Expression 'then' Expression <'else' ElseClause>!
                   +(if #3 #2 #1) ;

ElseClause:     ?(EQ (CURRENT-SYMBOL) "if) Conditional / Expression ;

Loop:           Iterator* 'repeat' Expr{110} +(REPEAT -#2 #1)
              / 'repeat' Expr{110} +(REPEAT #1) ;

Iterator:       'for' Primary 'in' Expression
                ( 'by' Expr{200} +(INBY #3 #2 #1) / +(IN #2 #1) )
                < '\|' Expr{111} +(\| #1) >
              / 'while' Expr{190} +(WHILE #1)
              / 'until' Expr{190} +(UNTIL #1) ;

Expr{RBP}:      NudPart{RBP} <LedPart{RBP}>* +#1;

LabelExpr:      Label Expr{120} +(LABEL #2 #1) ;

Label:          '@<<' Name '>>' ;

LedPart{RBP}:   Operation{"Led RBP} +#1;

NudPart{RBP}:   (Operation{"Nud RBP} / Reduction / Form) +#1 ;

Operation{ParseMode RBP}:
        ^?(MATCH-CURRENT-TOKEN "IDENTIFIER)
        ?(GETL (SETQ tmptok (CURRENT-SYMBOL)) ParseMode)
        ?(LT RBP (PARSE-leftBindingPowerOf tmptok ParseMode))
        .(SETQ RBP (PARSE-rightBindingPowerOf tmptok ParseMode))
        getSemanticForm{tmptok ParseMode (ELEMN (GETL tmptok ParseMode) 5 NIL)} ;

% Binding powers stored under the Led and Red properties of an operator
% are set up by the file BOTTOMUP.LISP.  The format for a Led property
% is <Operator Left-Power Right-Power>, and the same for a Nud, except that
% it may also have a fourth component <Special-Handler>. ELEMN attempts to
% get the Nth indicator, counting from 1.

leftBindingPowerOf{X IND}: =(LET ((Y (GETL X IND))) (IF Y (ELEMN Y 3 0) 0)) ;

rightBindingPowerOf{X IND}: =(LET ((Y (GETL X IND))) (IF Y (ELEMN Y 4 105) 105)) ;

getSemanticForm{X IND Y}:
                ?(AND Y (EVAL Y)) / ?(EQ IND "Nud) Prefix / ?(EQ IND "Led) Infix ;


Reduction:      ReductionOp Expr{1000} +(Reduce #2 #1) ;

ReductionOp:    ?(AND (GETL (CURRENT-SYMBOL) "Led)
                      (MATCH-NEXT-TOKEN "SPECIAL-CHAR (CODE-CHAR 47))) % Forgive me!
                +=(CURRENT-SYMBOL) .(ADVANCE-TOKEN) .(ADVANCE-TOKEN) ;

Form:           'iterate' < 'from' Label +(#1) >! +(iterate -#1)
              / 'yield' Application +(yield #1)
              / Application ;

Application: Primary <Selector>* <Application +(#2 #1)>;

Selector: ?NONBLANK ?(EQ (CURRENT-SYMBOL) "\.) ?(CHAR-NE (CURRENT-CHAR) "\ )
                 '.' PrimaryNoFloat (=\$BOOT +(ELT #2 #1)/ +(#2 #1))
          / (Float /'.' Primary) (=\$BOOT +(ELT #2 #1)/ +(#2 #1));

PrimaryNoFloat: Primary1 <TokTail> ;

Primary: Float /PrimaryNoFloat ;

Primary1: VarForm <=(AND NONBLANK (EQ (CURRENT-SYMBOL) "\()) Primary1 +(#2 #1)>
        /Quad
        /String
        /IntegerTok
        /FormalParameter
        /='\'' (?\$BOOT Data / '\'' Expr{999} +(QUOTE #1))
        /Sequence
        /Enclosure ;

Float: FloatBase (?NONBLANK FloatExponent / +0) +=(MAKE-FLOAT #4 #2 #2 #1) ;

FloatBase: ?(FIXP (CURRENT-SYMBOL)) ?(CHAR-EQ (CURRENT-CHAR) '.')
           ?(CHAR-NE (NEXT-CHAR) '.')
              IntegerTok FloatBasePart
          /?(FIXP (CURRENT-SYMBOL)) ?(CHAR-EQ (CHAR-UPCASE (CURRENT-CHAR)) "E)
              IntegerTok +0 +0
         /?(DIGITP (CURRENT-CHAR)) ?(EQ (CURRENT-SYMBOL) "\.)
              +0 FloatBasePart ;

FloatBasePart: '.'
  (?(DIGITP (CURRENT-CHAR)) +=(TOKEN-NONBLANK (CURRENT-TOKEN)) IntegerTok
  / +0 +0);


FloatExponent: =(AND (MEMBER (CURRENT-SYMBOL) "(E e))
                     (FIND (CURRENT-CHAR) '+-'))
                 .(ADVANCE-TOKEN)
        (IntegerTok/'+' IntegerTok/'-' IntegerTok +=(MINUS #1)/+0)
       /?(IDENTP (CURRENT-SYMBOL)) =(SETQ $1 (FLOATEXPID (CURRENT-SYMBOL)))
       .(ADVANCE-TOKEN) +=$1 ;

Enclosure:      '(' ( Expr{6} ')' / ')' +(Tuple) )
              / '{' ( Expr{6} '}' +(brace (construct #1)) / '}' +(brace)) ;

IntegerTok:     NUMBER ;

FloatTok:       NUMBER +=(IF \$BOOT #1 (BFP- #1)) ;

FormalParameter: FormalParameterTok ;

FormalParameterTok: ARGUMENT-DESIGNATOR ;

Quad:           '$' +\$ / ?\$BOOT GliphTok{"\.} +\. ;

String:         SPADSTRING ;

VarForm:        Name <Scripts +(Scripts #2 #1) > +#1 ;

Scripts:        ?NONBLANK '[' ScriptItem ']' ;

ScriptItem:     Expr{90} <(';' ScriptItem)* +(\; #2 -#1)>
              / ';' ScriptItem +(PrefixSC #1) ;

Name:           IDENTIFIER +#1 ;

Data:           .(SETQ LABLASOC NIL) Sexpr +(QUOTE =(TRANSLABEL #1 LABLASOC)) ;

Sexpr:          .(ADVANCE-TOKEN) Sexpr1 ;

Sexpr1:       AnyId
              < NBGliphTok{"\=} Sexpr1
                 .(SETQ LABLASOC (CONS (CONS #2 ##1) LABLASOC))>
              / '\'' Sexpr1 +(QUOTE #1)
              / IntegerTok
              / '-' IntegerTok +=(MINUS #1)
              / String
              / '<' <Sexpr1*>! '>' +=(LIST2VEC #1)
              / '(' <Sexpr1* <GliphTok{"\.} Sexpr1 +=(NCONC #2 #1)>>! ')' ;

NBGliphTok{tok}:   ?(AND (MATCH-CURRENT-TOKEN "GLIPH tok) NONBLANK)
                    .(ADVANCE-TOKEN) ;

GliphTok{tok}:     ?(MATCH-CURRENT-TOKEN "GLIPH tok) .(ADVANCE-TOKEN) ;

AnyId:          IDENTIFIER
              / (='$' +=(CURRENT-SYMBOL) .(ADVANCE-TOKEN) / KEYWORD) ;

Sequence:       OpenBracket Sequence1 ']'
              / OpenBrace Sequence1 '}' +(brace #1) ;

Sequence1:     (Expression +(#2 #1) / +(#1)) <IteratorTail +(COLLECT -#1 #1)>  ;

OpenBracket:    =(EQ (getToken (SETQ $1 (CURRENT-SYMBOL))) "\[ )
                      (=(EQCAR $1 "elt) +(elt =(CADR $1) construct)
                        / +construct) .(ADVANCE-TOKEN) ;

OpenBrace:      =(EQ (getToken (SETQ $1 (CURRENT-SYMBOL))) "\{ )
                      (=(EQCAR $1 "elt) +(elt =(CADR $1) brace)
                        / +construct) .(ADVANCE-TOKEN) ;

IteratorTail:   ('repeat' <Iterator*>! / Iterator*) ;

.FIN ;

\end{verbatim}
\section{The PARSE code}

\defvar{tmptok}
<<initvars>>=
(defvar |tmptok| nil)

@

\defvar{tok}
<<initvars>>=
(defvar tok nil)

@

\defvar{ParseMode}
<<initvars>>=
(defvar |ParseMode| nil)

@

\defvar{definition-name}
<<initvars>>=
(defvar definition-name nil)

@

\defvar{lablasoc}
<<initvars>>=
(defvar lablasoc nil)

@
\defun{PARSE-NewExpr}{PARSE-NewExpr}
\calls{PARSE-NewExpr}{match-string}
\calls{PARSE-NewExpr}{action}
\calls{PARSE-NewExpr}{processSynonyms}
\calls{PARSE-NewExpr}{must}
\calls{PARSE-NewExpr}{current-symbol}
\calls{PARSE-NewExpr}{PARSE-Statement}
\uses{PARSE-NewExpr}{definition-name}
<<defun PARSE-NewExpr>>=
(defun |PARSE-NewExpr| ()
 (or (and (match-string ")") (action (|processSynonyms|))
          (must (|PARSE-Command|)))
     (and (action (setq definition-name (current-symbol)))
          (|PARSE-Statement|))))

@

\defun{PARSE-Command}{PARSE-Command}
\calls{PARSE-Command}{match-advance-string}
\calls{PARSE-Command}{must}
\calls{PARSE-Command}{PARSE-SpecialKeyWord}
\calls{PARSE-Command}{PARSE-SpecialCommand}
\calls{PARSE-Command}{push-reduction}
<<defun PARSE-Command>>=
(defun |PARSE-Command| ()
 (and (match-advance-string ")") (must (|PARSE-SpecialKeyWord|))
      (must (|PARSE-SpecialCommand|))
      (push-reduction '|PARSE-Command| nil)))

@

\defun{PARSE-SpecialKeyWord}{PARSE-SpecialKeyWord}
\calls{PARSE-SpecialKeyWord}{match-current-token}
\calls{PARSE-SpecialKeyWord}{action}
\calls{PARSE-SpecialKeyWord}{token-symbol}
\calls{PARSE-SpecialKeyWord}{current-token}
\calls{PARSE-SpecialKeyWord}{unAbbreviateKeyword}
\calls{PARSE-SpecialKeyWord}{current-symbol}
<<defun PARSE-SpecialKeyWord>>=
(defun |PARSE-SpecialKeyWord| ()
 (and (match-current-token 'identifier)
      (action (setf (token-symbol (current-token))
                    (|unAbbreviateKeyword| (current-symbol))))))

@

\defun{PARSE-SpecialCommand}{PARSE-SpecialCommand}
\calls{PARSE-SpecialCommand}{match-advance-string}
\calls{PARSE-SpecialCommand}{bang}
\calls{PARSE-SpecialCommand}{optional}
\calls{PARSE-SpecialCommand}{PARSE-Expression}
\calls{PARSE-SpecialCommand}{push-reduction}
\calls{PARSE-SpecialCommand}{PARSE-SpecialCommand}
\calls{PARSE-SpecialCommand}{pop-stack-1}
\calls{PARSE-SpecialCommand}{PARSE-CommandTail}
\calls{PARSE-SpecialCommand}{must}
\calls{PARSE-SpecialCommand}{current-symbol}
\calls{PARSE-SpecialCommand}{action}
\calls{PARSE-SpecialCommand}{PARSE-TokenList}
\calls{PARSE-SpecialCommand}{PARSE-TokenCommandTail}
\calls{PARSE-SpecialCommand}{star}
\calls{PARSE-SpecialCommand}{PARSE-PrimaryOrQM}
\calls{PARSE-SpecialCommand}{PARSE-CommandTail}
\usesdollar{PARSE-SpecialCommand}{noParseCommands}
\usesdollar{PARSE-SpecialCommand}{tokenCommands}
<<defun PARSE-SpecialCommand>>=
(defun |PARSE-SpecialCommand| ()
 (declare (special $noParseCommands $tokenCommands))
 (or (and (match-advance-string "show")
          (bang fil_test
                (optional
                    (or (match-advance-string "?")
                        (|PARSE-Expression|))))
          (push-reduction '|PARSE-SpecialCommand|
              (list '|show| (pop-stack-1)))
          (must (|PARSE-CommandTail|)))
     (and (member (current-symbol) |$noParseCommands|)
          (action (funcall (current-symbol))))
     (and (member (current-symbol) |$tokenCommands|)
          (|PARSE-TokenList|) (must (|PARSE-TokenCommandTail|)))
     (and (star repeator (|PARSE-PrimaryOrQM|))
          (must (|PARSE-CommandTail|)))))

@

\defun{PARSE-TokenCommandTail}{PARSE-TokenCommandTail}
\calls{PARSE-TokenCommandTail}{bang}
\calls{PARSE-TokenCommandTail}{optional}
\calls{PARSE-TokenCommandTail}{star}
\calls{PARSE-TokenCommandTail}{PARSE-TokenOption}
\calls{PARSE-TokenCommandTail}{atEndOfLine}
\calls{PARSE-TokenCommandTail}{push-reduction}
\calls{PARSE-TokenCommandTail}{PARSE-TokenCommandTail}
\calls{PARSE-TokenCommandTail}{pop-stack-2}
\calls{PARSE-TokenCommandTail}{pop-stack-1}
\calls{PARSE-TokenCommandTail}{action}
\calls{PARSE-TokenCommandTail}{systemCommand}
<<defun PARSE-TokenCommandTail>>=
(defun |PARSE-TokenCommandTail| ()
 (and (bang fil_test (optional (star repeator (|PARSE-TokenOption|))))
      (|atEndOfLine|)
      (push-reduction '|PARSE-TokenCommandTail|
          (cons (pop-stack-2) (append (pop-stack-1) nil)))
      (action (|systemCommand| (pop-stack-1)))))

@


\defun{PARSE-TokenOption}{PARSE-TokenOption}
\calls{PARSE-TokenOption}{match-advance-string}
\calls{PARSE-TokenOption}{must}
\calls{PARSE-TokenOption}{PARSE-TokenList}
<<defun PARSE-TokenOption>>=
(defun |PARSE-TokenOption| ()
 (and (match-advance-string ")") (must (|PARSE-TokenList|))))

@

\defun{PARSE-TokenList}{PARSE-TokenList}
\calls{PARSE-TokenList}{star}
\calls{PARSE-TokenList}{isTokenDelimiter}
\calls{PARSE-TokenList}{push-reduction}
\calls{PARSE-TokenList}{current-symbol}
\calls{PARSE-TokenList}{action}
\calls{PARSE-TokenList}{advance-token}
<<defun PARSE-TokenList>>=
(defun |PARSE-TokenList| ()
 (star repeator
  (and (not (|isTokenDelimiter|))
       (push-reduction '|PARSE-TokenList| (current-symbol))
       (action (advance-token)))))

@

\defun{PARSE-CommandTail}{PARSE-CommandTail}
\calls{PARSE-CommandTail}{bang}
\calls{PARSE-CommandTail}{optional}
\calls{PARSE-CommandTail}{star}
\calls{PARSE-CommandTail}{push-reduction}
\calls{PARSE-CommandTail}{PARSE-Option}
\calls{PARSE-CommandTail}{PARSE-CommandTail}
\calls{PARSE-CommandTail}{pop-stack-2}
\calls{PARSE-CommandTail}{pop-stack-1}
\calls{PARSE-CommandTail}{action}
\calls{PARSE-CommandTail}{systemCommand}
<<defun PARSE-CommandTail>>=
(defun |PARSE-CommandTail| ()
 (and (bang fil_test (optional (star repeator (|PARSE-Option|))))
      (|atEndOfLine|)
      (push-reduction '|PARSE-CommandTail|
          (cons (pop-stack-2) (append (pop-stack-1) nil)))
      (action (|systemCommand| (pop-stack-1)))))

@

\defun{PARSE-PrimaryOrQM}{PARSE-PrimaryOrQM}
\calls{PARSE-PrimaryOrQM}{match-advance-string}
\calls{PARSE-PrimaryOrQM}{push-reduction}
\calls{PARSE-PrimaryOrQM}{PARSE-PrimaryOrQM}
\calls{PARSE-PrimaryOrQM}{PARSE-Primary}
<<defun PARSE-PrimaryOrQM>>=
(defun |PARSE-PrimaryOrQM| ()
 (or (and (match-advance-string "?")
          (push-reduction '|PARSE-PrimaryOrQM| '?))
     (|PARSE-Primary|)))

@

\defun{PARSE-Option}{PARSE-Option}
\calls{PARSE-Option}{match-advance-string}
\calls{PARSE-Option}{must}
\calls{PARSE-Option}{star}
\calls{PARSE-Option}{PARSE-PrimaryOrQM}
<<defun PARSE-Option>>=
(defun |PARSE-Option| ()
 (and (match-advance-string ")")
      (must (star repeator (|PARSE-PrimaryOrQM|)))))

@

\defun{PARSE-Statement}{PARSE-Statement}
\calls{PARSE-Statement}{PARSE-Expr}
\calls{PARSE-Statement}{optional}
\calls{PARSE-Statement}{star}
\calls{PARSE-Statement}{match-advance-string}
\calls{PARSE-Statement}{must}
\calls{PARSE-Statement}{push-reduction}
\calls{PARSE-Statement}{pop-stack-2}
\calls{PARSE-Statement}{pop-stack-1}
<<defun PARSE-Statement>>=
(defun |PARSE-Statement| ()
  (and (|PARSE-Expr| 0)
       (optional
           (and (star repeator
                      (and (match-advance-string ",")
                           (must (|PARSE-Expr| 0))))
                (push-reduction '|PARSE-Statement|
                    (cons '|Series|
                          (cons (pop-stack-2)
                                (append (pop-stack-1) nil))))))))

@

\defun{PARSE-InfixWith}{PARSE-InfixWith}
\calls{PARSE-InfixWith}{PARSE-With}
\calls{PARSE-InfixWith}{push-reduction}
\calls{PARSE-InfixWith}{pop-stack-2}
\calls{PARSE-InfixWith}{pop-stack-1}
<<defun PARSE-InfixWith>>=
(defun |PARSE-InfixWith| ()
  (and (|PARSE-With|)
       (push-reduction '|PARSE-InfixWith|
           (list '|Join| (pop-stack-2) (pop-stack-1)))))

@

\defun{PARSE-With}{PARSE-With}
\calls{PARSE-With}{match-advance-string}
\calls{PARSE-With}{must}
\calls{PARSE-With}{push-reduction}
\calls{PARSE-With}{pop-stack-1}
<<defun PARSE-With>>=
(defun |PARSE-With| ()
  (and (match-advance-string "with") (must (|PARSE-Category|))
       (push-reduction '|PARSE-With|
           (cons '|with| (cons (pop-stack-1) nil)))))

@

\defun{PARSE-Category}{PARSE-Category}
\calls{PARSE-Category}{match-advance-string}
\calls{PARSE-Category}{must}
\calls{PARSE-Category}{bang}
\calls{PARSE-Category}{optional}
\calls{PARSE-Category}{push-reduction}
\calls{PARSE-Category}{PARSE-Expression}
\calls{PARSE-Category}{PARSE-Category}
\calls{PARSE-Category}{pop-stack-3}
\calls{PARSE-Category}{pop-stack-2}
\calls{PARSE-Category}{pop-stack-1}
\calls{PARSE-Category}{star}
\calls{PARSE-Category}{line-number}
\calls{PARSE-Category}{PARSE-Application}
\calls{PARSE-Category}{action}
\calls{PARSE-Category}{recordSignatureDocumentation}
\calls{PARSE-Category}{nth-stack}
\calls{PARSE-Category}{recordAttributeDocumentation}
\uses{PARSE-Category}{current-line}
<<defun PARSE-Category>>=
(defun |PARSE-Category| ()
 (let (g1)
  (or (and (match-advance-string "if") (must (|PARSE-Expression|))
           (must (match-advance-string "then"))
           (must (|PARSE-Category|))
           (bang fil_test
                 (optional
                     (and (match-advance-string "else")
                          (must (|PARSE-Category|)))))
           (push-reduction '|PARSE-Category|
             (list '|if| (pop-stack-3) (pop-stack-2) (pop-stack-1))))
      (and (match-advance-string "(") (must (|PARSE-Category|))
           (bang fil_test
                 (optional
                     (star repeator
                           (and (match-advance-string ";")
                                (must (|PARSE-Category|))))))
           (must (match-advance-string ")"))
           (push-reduction '|PARSE-Category|
               (cons 'category
                     (cons (pop-stack-2)
                           (append (pop-stack-1) nil)))))
      (and (action (setq g1 (line-number current-line)))
           (|PARSE-Application|)
           (must (or (and (match-advance-string ":")
                          (must (|PARSE-Expression|))
                          (push-reduction '|PARSE-Category|
                           (list '|Signature| (pop-stack-2) (pop-stack-1) ))
                          (action (|recordSignatureDocumentation|
                                   (nth-stack 1) g1)))
                     (and (push-reduction '|PARSE-Category|
                            (list '|Attribute| (pop-stack-1) ))
                          (action (|recordAttributeDocumentation|
                                   (nth-stack 1) g1)))))))))

@

\defun{PARSE-Expression}{PARSE-Expression}
\calls{PARSE-Expression}{PARSE-Expr}
\calls{PARSE-Expression}{PARSE-rightBindingPowerOf}
\calls{PARSE-Expression}{make-symbol-of}
\calls{PARSE-Expression}{push-reduction}
\calls{PARSE-Expression}{pop-stack-1}
\uses{PARSE-Expression}{ParseMode}
\uses{PARSE-Expression}{prior-token}
<<defun PARSE-Expression>>=
(defun |PARSE-Expression| ()
 (declare (special prior-token))
 (and (|PARSE-Expr|
          (|PARSE-rightBindingPowerOf| (make-symbol-of prior-token)
              |ParseMode|))
      (push-reduction '|PARSE-Expression| (pop-stack-1))))

@

\defun{PARSE-Import}{PARSE-Import}
\calls{PARSE-Import}{match-advance-string}
\calls{PARSE-Import}{must}
\calls{PARSE-Import}{PARSE-Expr}
\calls{PARSE-Import}{bang}
\calls{PARSE-Import}{optional}
\calls{PARSE-Import}{star}
\calls{PARSE-Import}{push-reduction}
\calls{PARSE-Import}{pop-stack-2}
\calls{PARSE-Import}{pop-stack-1}
<<defun PARSE-Import>>=
(defun |PARSE-Import| ()
  (and (match-advance-string "import") (must (|PARSE-Expr| 1000))
       (bang fil_test
             (optional
                 (star repeator
                       (and (match-advance-string ",")
                            (must (|PARSE-Expr| 1000))))))
       (push-reduction '|PARSE-Import|
           (cons '|import|
                 (cons (pop-stack-2) (append (pop-stack-1) nil))))))

@

\defun{PARSE-Expr}{PARSE-Expr}
\calls{PARSE-Expr}{PARSE-NudPart}
\calls{PARSE-Expr}{PARSE-LedPart}
\calls{PARSE-Expr}{optional}
\calls{PARSE-Expr}{star}
\calls{PARSE-Expr}{push-reduction}
\calls{PARSE-Expr}{pop-stack-1}
<<defun PARSE-Expr>>=
(defun |PARSE-Expr| (rbp)
 (declare (special rbp))
 (and (|PARSE-NudPart| rbp)
      (optional (star opt_expr (|PARSE-LedPart| rbp)))
      (push-reduction '|PARSE-Expr| (pop-stack-1))))

@

\defun{PARSE-LedPart}{PARSE-LedPart}
\calls{PARSE-LedPart}{PARSE-Operation}
\calls{PARSE-LedPart}{push-reduction}
\calls{PARSE-LedPart}{pop-stack-1}
<<defun PARSE-LedPart>>=
(defun |PARSE-LedPart| (rbp)
  (declare (special rbp))
  (and (|PARSE-Operation| '|Led| rbp)
       (push-reduction '|PARSE-LedPart| (pop-stack-1))))

@

\defun{PARSE-NudPart}{PARSE-NudPart}
\calls{PARSE-NudPart}{PARSE-Operation}
\calls{PARSE-NudPart}{PARSE-Reduction}
\calls{PARSE-NudPart}{PARSE-Form}
\calls{PARSE-NudPart}{push-reduction}
\calls{PARSE-NudPart}{pop-stack-1}
\uses{PARSE-NudPart}{rbp}
<<defun PARSE-NudPart>>=
(defun |PARSE-NudPart| (rbp)
  (declare (special rbp))
  (and (or (|PARSE-Operation| '|Nud| rbp) (|PARSE-Reduction|)
           (|PARSE-Form|))
       (push-reduction '|PARSE-NudPart| (pop-stack-1))))

@

\defun{PARSE-Operation}{PARSE-Operation}
\calls{PARSE-Operation}{match-current-token}
\calls{PARSE-Operation}{current-symbol}
\calls{PARSE-Operation}{PARSE-leftBindingPowerOf}
\calls{PARSE-Operation}{lt}
\calls{PARSE-Operation}{getl}
\calls{PARSE-Operation}{action}
\calls{PARSE-Operation}{PARSE-rightBindingPowerOf}
\calls{PARSE-Operation}{PARSE-getSemanticForm}
\calls{PARSE-Operation}{elemn}
\uses{PARSE-Operation}{ParseMode}
\uses{PARSE-Operation}{rbp}
\uses{PARSE-Operation}{tmptok}
<<defun PARSE-Operation>>=
(defun |PARSE-Operation| (|ParseMode| rbp)
 (declare (special |ParseMode| rbp |tmptok|))
 (and (not (match-current-token 'identifier))
      (getl (setq |tmptok| (current-symbol)) |ParseMode|)
      (lt rbp (|PARSE-leftBindingPowerOf| |tmptok| |ParseMode|))
      (action (setq rbp (|PARSE-rightBindingPowerOf| |tmptok| |ParseMode|)))
      (|PARSE-getSemanticForm| |tmptok| |ParseMode|
          (elemn (getl |tmptok| |ParseMode|) 5 nil))))

@

\defun{PARSE-leftBindingPowerOf}{PARSE-leftBindingPowerOf}
\calls{PARSE-leftBindingPowerOf}{getl}
\calls{PARSE-leftBindingPowerOf}{elemn}
<<defun PARSE-leftBindingPowerOf>>=
(defun |PARSE-leftBindingPowerOf| (x ind)
 (declare (special x ind))
 (let ((y (getl x ind))) (if y (elemn y 3 0) 0)))

@

\defun{PARSE-rightBindingPowerOf}{PARSE-rightBindingPowerOf}
\calls{PARSE-rightBindingPowerOf}{getl}
\calls{PARSE-rightBindingPowerOf}{elemn}
<<defun PARSE-rightBindingPowerOf>>=
(defun |PARSE-rightBindingPowerOf| (x ind)
  (declare (special x ind))
  (let ((y (getl x ind))) (if y (elemn y 4 105) 105)))

@

\defun{PARSE-getSemanticForm}{PARSE-getSemanticForm}
\calls{PARSE-getSemanticForm}{PARSE-Prefix}
\calls{PARSE-getSemanticForm}{PARSE-Infix}
<<defun PARSE-getSemanticForm>>=
(defun |PARSE-getSemanticForm| (x ind y)
  (declare (special x ind y))
  (or (and y (eval y)) (and (eq ind '|Nud|) (|PARSE-Prefix|))
      (and (eq ind '|Led|) (|PARSE-Infix|))))

@

\defun{PARSE-Prefix}{PARSE-Prefix}
\calls{PARSE-Prefix}{push-reduction}
\calls{PARSE-Prefix}{current-symbol}
\calls{PARSE-Prefix}{action}
\calls{PARSE-Prefix}{advance-token}
\calls{PARSE-Prefix}{optional}
\calls{PARSE-Prefix}{PARSE-TokTail}
\calls{PARSE-Prefix}{must}
\calls{PARSE-Prefix}{PARSE-Expression}
\calls{PARSE-Prefix}{push-reduction}
\calls{PARSE-Prefix}{pop-stack-2}
\calls{PARSE-Prefix}{pop-stack-1}
<<defun PARSE-Prefix>>=
(defun |PARSE-Prefix| ()
  (and (push-reduction '|PARSE-Prefix| (current-symbol))
       (action (advance-token)) (optional (|PARSE-TokTail|))
       (must (|PARSE-Expression|))
       (push-reduction '|PARSE-Prefix|
           (list (pop-stack-2) (pop-stack-1)))))

@

\defun{PARSE-Infix}{PARSE-Infix}
\calls{PARSE-Infix}{push-reduction}
\calls{PARSE-Infix}{current-symbol}
\calls{PARSE-Infix}{action}
\calls{PARSE-Infix}{advance-token}
\calls{PARSE-Infix}{optional}
\calls{PARSE-Infix}{PARSE-TokTail}
\calls{PARSE-Infix}{must}
\calls{PARSE-Infix}{PARSE-Expression}
\calls{PARSE-Infix}{pop-stack-2}
\calls{PARSE-Infix}{pop-stack-1}
<<defun PARSE-Infix>>=
(defun |PARSE-Infix| ()
  (and (push-reduction '|PARSE-Infix| (current-symbol))
       (action (advance-token)) (optional (|PARSE-TokTail|))
       (must (|PARSE-Expression|))
       (push-reduction '|PARSE-Infix|
           (list (pop-stack-2) (pop-stack-2) (pop-stack-1) ))))

@

\defun{PARSE-TokTail}{PARSE-TokTail}
\calls{PARSE-TokTail}{current-symbol}
\calls{PARSE-TokTail}{current-char}
\calls{PARSE-TokTail}{char-eq}
\calls{PARSE-TokTail}{copy-token}
\calls{PARSE-TokTail}{action}
\calls{PARSE-TokTail}{PARSE-Qualification}
\usesdollar{PARSE-TokTail}{boot}
<<defun PARSE-TokTail>>=
(defun |PARSE-TokTail| ()
 (let (g1)
  (and (null $boot) (eq (current-symbol) '$)
       (or (alpha-char-p (current-char))
           (char-eq (current-char) "$")
           (char-eq (current-char) "%")
           (char-eq (current-char) "("))
       (action (setq g1 (copy-token prior-token)))
       (|PARSE-Qualification|) (action (setq prior-token g1)))))

@

\defun{PARSE-Qualification}{PARSE-Qualification}
\calls{PARSE-Qualification}{match-advance-string}
\calls{PARSE-Qualification}{must}
\calls{PARSE-Qualification}{PARSE-Primary1}
\calls{PARSE-Qualification}{push-reduction}
\calls{PARSE-Qualification}{dollarTran}
\calls{PARSE-Qualification}{pop-stack-1}
<<defun PARSE-Qualification>>=
(defun |PARSE-Qualification| ()
  (and (match-advance-string "$") (must (|PARSE-Primary1|))
       (push-reduction '|PARSE-Qualification|
           (|dollarTran| (pop-stack-1) (pop-stack-1)))))

@

\defun{PARSE-Reduction}{PARSE-Reduction}
\calls{PARSE-Reduction}{PARSE-ReductionOp}
\calls{PARSE-Reduction}{must}
\calls{PARSE-Reduction}{PARSE-Expr}
\calls{PARSE-Reduction}{push-reduction}
\calls{PARSE-Reduction}{pop-stack-2}
\calls{PARSE-Reduction}{pop-stack-1}
<<defun PARSE-Reduction>>=
(defun |PARSE-Reduction| ()
 (and (|PARSE-ReductionOp|) (must (|PARSE-Expr| 1000))
      (push-reduction '|PARSE-Reduction|
          (list '|Reduce| (pop-stack-2) (pop-stack-1) ))))

@

\defun{PARSE-ReductionOp}{PARSE-ReductionOp}
\calls{PARSE-ReductionOp}{getl}
\calls{PARSE-ReductionOp}{current-symbol}
\calls{PARSE-ReductionOp}{match-next-token}
\calls{PARSE-ReductionOp}{action}
\calls{PARSE-ReductionOp}{advance-token}
<<defun PARSE-ReductionOp>>=
(defun |PARSE-ReductionOp| ()
  (and (getl (current-symbol) '|Led|)
       (match-next-token 'special-char (code-char 47))
       (push-reduction '|PARSE-ReductionOp| (current-symbol))
       (action (advance-token)) (action (advance-token))))

@

\defun{PARSE-Form}{PARSE-Form}
\calls{PARSE-Form}{match-advance-string}
\calls{PARSE-Form}{bang}
\calls{PARSE-Form}{optional}
\calls{PARSE-Form}{must}
\calls{PARSE-Form}{push-reduction}
\calls{PARSE-Form}{pop-stack-1}
\calls{PARSE-Form}{PARSE-Application}
<<defun PARSE-Form>>=
(defun |PARSE-Form| ()
  (or (and (match-advance-string "iterate")
           (bang fil_test
                 (optional
                     (and (match-advance-string "from")
                          (must (|PARSE-Label|))
                          (push-reduction '|PARSE-Form|
                             (list (pop-stack-1))))))
           (push-reduction '|PARSE-Form|
               (cons '|iterate| (append (pop-stack-1) nil))))
      (and (match-advance-string "yield") (must (|PARSE-Application|))
           (push-reduction '|PARSE-Form|
               (list '|yield| (pop-stack-1))))
      (|PARSE-Application|)))

@

\defun{PARSE-Application}{PARSE-Application}
\calls{PARSE-Application}{PARSE-Primary}
\calls{PARSE-Application}{optional}
\calls{PARSE-Application}{star}
\calls{PARSE-Application}{PARSE-Selector}
\calls{PARSE-Application}{PARSE-Application}
\calls{PARSE-Application}{push-reduction}
\calls{PARSE-Application}{pop-stack-2}
\calls{PARSE-Application}{pop-stack-1}
<<defun PARSE-Application>>=
(defun |PARSE-Application| ()
 (and (|PARSE-Primary|) (optional (star opt_expr (|PARSE-Selector|)))
      (optional
          (and (|PARSE-Application|)
               (push-reduction '|PARSE-Application|
                   (list (pop-stack-2) (pop-stack-1)))))))

@

\defun{PARSE-Label}{PARSE-Label}
\calls{PARSE-Label}{match-advance-string}
\calls{PARSE-Label}{must}
\calls{PARSE-Label}{PARSE-Name}
<<defun PARSE-Label>>=
(defun |PARSE-Label| ()
  (and (match-advance-string "<<") (must (|PARSE-Name|))
       (must (match-advance-string ">>"))))

@

\defun{PARSE-Selector}{PARSE-Selector}
\calls{PARSE-Selector}{current-symbol}
\calls{PARSE-Selector}{char-ne}
\calls{PARSE-Selector}{current-char}
\calls{PARSE-Selector}{match-advance-string}
\calls{PARSE-Selector}{must}
\calls{PARSE-Selector}{PARSE-PrimaryNoFloat}
\calls{PARSE-Selector}{push-reduction}
\calls{PARSE-Selector}{pop-stack-2}
\calls{PARSE-Selector}{pop-stack-1}
\calls{PARSE-Selector}{PARSE-Float}
\calls{PARSE-Selector}{PARSE-Primary}
\usesdollar{PARSE-Selector}{boot}
<<defun PARSE-Selector>>=
(defun |PARSE-Selector| ()
  (declare (special $boot))
  (or (and nonblank (eq (current-symbol) '|.|)
           (char-ne (current-char) '| |) (match-advance-string ".")
           (must (|PARSE-PrimaryNoFloat|))
           (must (or (and $boot
                          (push-reduction '|PARSE-Selector|
                              (list 'elt (pop-stack-2) (pop-stack-1))))
                     (push-reduction '|PARSE-Selector|
                         (list (pop-stack-2) (pop-stack-1))))))
      (and (or (|PARSE-Float|)
               (and (match-advance-string ".")
                    (must (|PARSE-Primary|))))
           (must (or (and $boot
                          (push-reduction '|PARSE-Selector|
                              (list 'elt (pop-stack-2) (pop-stack-1))))
                     (push-reduction '|PARSE-Selector|
                         (list (pop-stack-2) (pop-stack-1))))))))

@

\defun{PARSE-PrimaryNoFloat}{PARSE-PrimaryNoFloat}
\calls{PARSE-PrimaryNoFloat}{PARSE-Primary1}
\calls{PARSE-PrimaryNoFloat}{optional}
\calls{PARSE-PrimaryNoFloat}{PARSE-TokTail}
<<defun PARSE-PrimaryNoFloat>>=
(defun |PARSE-PrimaryNoFloat| ()
  (and (|PARSE-Primary1|) (optional (|PARSE-TokTail|))))

@

\defun{PARSE-Primary}{PARSE-Primary}
\calls{PARSE-Primary}{}
\calls{PARSE-Primary}{}
<<defun PARSE-Primary>>=
(defun |PARSE-Primary| ()
  (or (|PARSE-Float|) (|PARSE-PrimaryNoFloat|)))

@

\defun{PARSE-Primary1}{PARSE-Primary1}
\calls{PARSE-Primary1}{PARSE-VarForm}
\calls{PARSE-Primary1}{optional}
\calls{PARSE-Primary1}{current-symbol}
\calls{PARSE-Primary1}{PARSE-Primary1}
\calls{PARSE-Primary1}{must}
\calls{PARSE-Primary1}{pop-stack-2}
\calls{PARSE-Primary1}{pop-stack-1}
\calls{PARSE-Primary1}{push-reduction}
\calls{PARSE-Primary1}{PARSE-Quad}
\calls{PARSE-Primary1}{PARSE-String}
\calls{PARSE-Primary1}{PARSE-IntegerTok}
\calls{PARSE-Primary1}{PARSE-FormalParameter}
\calls{PARSE-Primary1}{match-string}
\calls{PARSE-Primary1}{PARSE-Data}
\calls{PARSE-Primary1}{match-advance-string}
\calls{PARSE-Primary1}{PARSE-Expr}
\calls{PARSE-Primary1}{PARSE-Sequence}
\calls{PARSE-Primary1}{PARSE-Enclosure}
\usesdollar{PARSE-Primary1}{boot}
<<defun PARSE-Primary1>>=
(defun |PARSE-Primary1| ()
  (or (and (|PARSE-VarForm|)
           (optional
               (and nonblank (eq (current-symbol) '|(|)
                    (must (|PARSE-Primary1|))
                    (push-reduction '|PARSE-Primary1|
                        (list (pop-stack-2) (pop-stack-1))))))
      (|PARSE-Quad|) (|PARSE-String|) (|PARSE-IntegerTok|)
      (|PARSE-FormalParameter|)
      (and (match-string "'")
           (must (or (and $boot (|PARSE-Data|))
                     (and (match-advance-string "'")
                          (must (|PARSE-Expr| 999))
                          (push-reduction '|PARSE-Primary1|
                              (list 'quote (pop-stack-1)))))))
      (|PARSE-Sequence|) (|PARSE-Enclosure|))) 

@

\defun{PARSE-Float}{PARSE-Float}
\calls{PARSE-Float}{PARSE-FloatBase}
\calls{PARSE-Float}{must}
\calls{PARSE-Float}{PARSE-FloatExponent}
\calls{PARSE-Float}{push-reduction}
\calls{PARSE-Float}{make-float}
\calls{PARSE-Float}{pop-stack-4}
\calls{PARSE-Float}{pop-stack-3}
\calls{PARSE-Float}{pop-stack-2}
\calls{PARSE-Float}{pop-stack-1}
<<defun PARSE-Float>>=
(defun |PARSE-Float| ()
  (and (|PARSE-FloatBase|)
       (must (or (and nonblank (|PARSE-FloatExponent|))
                 (push-reduction '|PARSE-Float| 0)))
       (push-reduction '|PARSE-Float|
           (make-float (pop-stack-4) (pop-stack-2) (pop-stack-2)
               (pop-stack-1)))))

@

\defun{PARSE-FloatBase}{PARSE-FloatBase}
\calls{PARSE-FloatBase}{current-symbol}
\calls{PARSE-FloatBase}{char-eq}
\calls{PARSE-FloatBase}{current-char}
\calls{PARSE-FloatBase}{char-ne}
\calls{PARSE-FloatBase}{next-char}
\calls{PARSE-FloatBase}{PARSE-IntegerTok}
\calls{PARSE-FloatBase}{must}
\calls{PARSE-FloatBase}{PARSE-FloatBasePart}
\calls{PARSE-FloatBase}{PARSE-IntegerTok}
\calls{PARSE-FloatBase}{push-reduction}
\calls{PARSE-FloatBase}{digitp}
<<defun PARSE-FloatBase>>=
(defun |PARSE-FloatBase| ()
  (or (and (integerp (current-symbol)) (char-eq (current-char) ".")
           (char-ne (next-char) ".") (|PARSE-IntegerTok|)
           (must (|PARSE-FloatBasePart|)))
      (and (integerp (current-symbol))
           (char-eq (char-upcase (current-char)) 'e)
           (|PARSE-IntegerTok|) (push-reduction '|PARSE-FloatBase| 0)
           (push-reduction '|PARSE-FloatBase| 0))
      (and (digitp (current-char)) (eq (current-symbol) '|.|)
           (push-reduction '|PARSE-FloatBase| 0)
           (|PARSE-FloatBasePart|))))

@

\defun{PARSE-FloatBasePart}{PARSE-FloatBasePart}
\calls{PARSE-FloatBasePart}{match-advance-string}
\calls{PARSE-FloatBasePart}{must}
\calls{PARSE-FloatBasePart}{digitp}
\calls{PARSE-FloatBasePart}{current-char}
\calls{PARSE-FloatBasePart}{push-reduction}
\calls{PARSE-FloatBasePart}{token-nonblank}
\calls{PARSE-FloatBasePart}{current-token}
\calls{PARSE-FloatBasePart}{PARSE-IntegerTok}
<<defun PARSE-FloatBasePart>>=
(defun |PARSE-FloatBasePart| ()
  (and (match-advance-string ".")
       (must (or (and (digitp (current-char))
                      (push-reduction '|PARSE-FloatBasePart|
                          (token-nonblank (current-token)))
                      (|PARSE-IntegerTok|))
                 (and (push-reduction '|PARSE-FloatBasePart| 0)
                      (push-reduction '|PARSE-FloatBasePart| 0))))))

@

\defun{PARSE-FloatExponent}{PARSE-FloatExponent}
\calls{PARSE-FloatExponent}{current-symbol}
\calls{PARSE-FloatExponent}{current-char}
\calls{PARSE-FloatExponent}{action}
\calls{PARSE-FloatExponent}{advance-token}
\calls{PARSE-FloatExponent}{PARSE-IntegerTok}
\calls{PARSE-FloatExponent}{match-advance-string}
\calls{PARSE-FloatExponent}{must}
\calls{PARSE-FloatExponent}{push-reduction}
\calls{PARSE-FloatExponent}{identp}
\calls{PARSE-FloatExponent}{floatexpid}
<<defun PARSE-FloatExponent>>=
(defun |PARSE-FloatExponent| ()
 (let (g1)
  (or (and (member (current-symbol) '(e |e|))
           (find (current-char) "+-") (action (advance-token))
           (must (or (|PARSE-IntegerTok|)
                     (and (match-advance-string "+")
                          (must (|PARSE-IntegerTok|)))
                     (and (match-advance-string "-")
                          (must (|PARSE-IntegerTok|))
                          (push-reduction '|PARSE-FloatExponent|
                              (- (pop-stack-1))))
                     (push-reduction '|PARSE-FloatExponent| 0))))
      (and (identp (current-symbol))
           (setq g1 (floatexpid (current-symbol)))
           (action (advance-token))
           (push-reduction '|PARSE-FloatExponent| g1)))))

@

\defun{PARSE-Enclosure}{PARSE-Enclosure}
\calls{PARSE-Enclosure}{match-advance-string}
\calls{PARSE-Enclosure}{must}
\calls{PARSE-Enclosure}{PARSE-Expr}
\calls{PARSE-Enclosure}{push-reduction}
\calls{PARSE-Enclosure}{pop-stack-1}
<<defun PARSE-Enclosure>>=
(defun |PARSE-Enclosure| ()
  (or (and (match-advance-string "(")
           (must (or (and (|PARSE-Expr| 6)
                          (must (match-advance-string ")")))
                     (and (match-advance-string ")")
                          (push-reduction '|PARSE-Enclosure|
                              (list '|@Tuple|))))))
      (and (match-advance-string "{")
           (must (or (and (|PARSE-Expr| 6)
                          (must (match-advance-string "}"))
                          (push-reduction '|PARSE-Enclosure|
                              (cons '|brace|
                               (list (list '|construct| (pop-stack-1))))))
                     (and (match-advance-string "}")
                          (push-reduction '|PARSE-Enclosure|
                              (list '|brace|))))))))

@

\defun{PARSE-IntegerTok}{PARSE-IntegerTok}
\calls{PARSE-IntegerTok}{parse-number}
<<defun PARSE-IntegerTok>>=
(defun |PARSE-IntegerTok| () (parse-number))

@

\defun{PARSE-FormalParameter}{PARSE-FormalParameter}
\calls{PARSE-FormalParameter}{PARSE-FormalParameterTok}
<<defun PARSE-FormalParameter>>=
(defun |PARSE-FormalParameter| () (|PARSE-FormalParameterTok|))

@

\defun{PARSE-FormalParameterTok}{PARSE-FormalParameterTok}
\calls{PARSE-FormalParameterTok}{parse-argument-designator}
<<defun PARSE-FormalParameterTok>>=
(defun |PARSE-FormalParameterTok| () (parse-argument-designator))

@

\defun{PARSE-Quad}{PARSE-Quad}
\calls{PARSE-Quad}{match-advance-string}
\calls{PARSE-Quad}{push-reduction}
\calls{PARSE-Quad}{PARSE-GliphTok}
\usesdollar{PARSE-Quad}{boot}
<<defun PARSE-Quad>>=
(defun |PARSE-Quad| ()
 (or (and (match-advance-string "$")
          (push-reduction '|PARSE-Quad| '$))
     (and $boot (|PARSE-GliphTok| '|.|)
          (push-reduction '|PARSE-Quad| '|.|))))

@

\defun{PARSE-String}{PARSE-String}
\calls{PARSE-String}{parse-spadstring}
<<defun PARSE-String>>=
(defun |PARSE-String| () (parse-spadstring))

@

\defun{PARSE-VarForm}{PARSE-VarForm}
\calls{PARSE-VarForm}{PARSE-Name}
\calls{PARSE-VarForm}{optional}
\calls{PARSE-VarForm}{PARSE-Scripts}
\calls{PARSE-VarForm}{push-reduction}
\calls{PARSE-VarForm}{pop-stack-2}
\calls{PARSE-VarForm}{pop-stack-1}
<<defun PARSE-VarForm>>=
(defun |PARSE-VarForm| ()
  (and (|PARSE-Name|)
       (optional
           (and (|PARSE-Scripts|)
                (push-reduction '|PARSE-VarForm|
                    (list '|Scripts| (pop-stack-2) (pop-stack-1)))))
       (push-reduction '|PARSE-VarForm| (pop-stack-1))))

@

\defun{PARSE-Scripts}{PARSE-Scripts}
\calls{PARSE-Scripts}{match-advance-string}
\calls{PARSE-Scripts}{must}
\calls{PARSE-Scripts}{PARSE-ScriptItem}
<<defun PARSE-Scripts>>=
(defun |PARSE-Scripts| ()
 (and nonblank (match-advance-string "[") (must (|PARSE-ScriptItem|))
      (must (match-advance-string "]"))))

@

\defun{PARSE-ScriptItem}{PARSE-ScriptItem}
\calls{PARSE-ScriptItem}{PARSE-Expr}
\calls{PARSE-ScriptItem}{optional}
\calls{PARSE-ScriptItem}{star}
\calls{PARSE-ScriptItem}{match-advance-string}
\calls{PARSE-ScriptItem}{must}
\calls{PARSE-ScriptItem}{PARSE-ScriptItem}
\calls{PARSE-ScriptItem}{push-reduction}
\calls{PARSE-ScriptItem}{pop-stack-2}
\calls{PARSE-ScriptItem}{pop-stack-1}
<<defun PARSE-ScriptItem>>=
(defun |PARSE-ScriptItem| ()
  (or (and (|PARSE-Expr| 90)
           (optional
               (and (star repeator
                          (and (match-advance-string ";")
                               (must (|PARSE-ScriptItem|))))
                    (push-reduction '|PARSE-ScriptItem|
                        (cons '|;|
                              (cons (pop-stack-2)
                                    (append (pop-stack-1) nil)))))))
      (and (match-advance-string ";") (must (|PARSE-ScriptItem|))
           (push-reduction '|PARSE-ScriptItem|
               (list '|PrefixSC| (pop-stack-1))))))

@

\defun{PARSE-Name}{PARSE-Name}
\calls{PARSE-Name}{parse-identifier}
\calls{PARSE-Name}{push-reduction}
\calls{PARSE-Name}{pop-stack-1}
<<defun PARSE-Name>>=
(defun |PARSE-Name| ()
  (and (parse-identifier) (push-reduction '|PARSE-Name| (pop-stack-1))))

@

\defun{PARSE-Data}{PARSE-Data}
\calls{PARSE-Data}{action}
\calls{PARSE-Data}{PARSE-Sexpr}
\calls{PARSE-Data}{push-reduction}
\calls{PARSE-Data}{translabel}
\calls{PARSE-Data}{pop-stack-1}
\uses{PARSE-Data}{labasoc}
<<defun PARSE-Data>>=
(defun |PARSE-Data| ()
  (declare (special lablasoc))
  (and (action (setq lablasoc nil)) (|PARSE-Sexpr|)
       (push-reduction '|PARSE-Data|
           (list 'quote (translabel (pop-stack-1) lablasoc)))))

@

\defun{PARSE-Sexpr}{PARSE-Sexpr}
\calls{PARSE-Sexpr}{PARSE-Sexpr1}
<<defun PARSE-Sexpr>>=
(defun |PARSE-Sexpr| ()
  (and (action (advance-token)) (|PARSE-Sexpr1|)))

@

\defun{PARSE-Sexpr1}{PARSE-Sexpr1}
\calls{PARSE-Sexpr1}{PARSE-AnyId}
\calls{PARSE-Sexpr1}{optional}
\calls{PARSE-Sexpr1}{PARSE-NBGliphTok}
\calls{PARSE-Sexpr1}{must}
\calls{PARSE-Sexpr1}{PARSE-Sexpr1}
\calls{PARSE-Sexpr1}{action}
\calls{PARSE-Sexpr1}{pop-stack-2}
\calls{PARSE-Sexpr1}{nth-stack}
\calls{PARSE-Sexpr1}{match-advance-string}
\calls{PARSE-Sexpr1}{push-reduction}
\calls{PARSE-Sexpr1}{PARSE-IntegerTok}
\calls{PARSE-Sexpr1}{pop-stack-1}
\calls{PARSE-Sexpr1}{PARSE-String}
\calls{PARSE-Sexpr1}{bang}
\calls{PARSE-Sexpr1}{star}
\calls{PARSE-Sexpr1}{PARSE-GliphTok}
<<defun PARSE-Sexpr1>>=
(defun |PARSE-Sexpr1| ()
  (or (and (|PARSE-AnyId|)
           (optional
               (and (|PARSE-NBGliphTok| '=) (must (|PARSE-Sexpr1|))
                    (action (setq lablasoc
                                  (cons (cons (pop-stack-2)
                                         (nth-stack 1))
                                        lablasoc))))))
      (and (match-advance-string "'") (must (|PARSE-Sexpr1|))
           (push-reduction '|PARSE-Sexpr1|
               (list 'quote (pop-stack-1))))
      (|PARSE-IntegerTok|)
      (and (match-advance-string "-") (must (|PARSE-IntegerTok|))
           (push-reduction '|PARSE-Sexpr1| (- (pop-stack-1))))
      (|PARSE-String|)
      (and (match-advance-string "<")
           (bang fil_test (optional (star repeator (|PARSE-Sexpr1|))))
           (must (match-advance-string ">"))
           (push-reduction '|PARSE-Sexpr1| (list2vec (pop-stack-1))))
      (and (match-advance-string "(")
           (bang fil_test
                 (optional
                     (and (star repeator (|PARSE-Sexpr1|))
                          (optional
                              (and (|PARSE-GliphTok| '|.|)
                                   (must (|PARSE-Sexpr1|))
                                   (push-reduction '|PARSE-Sexpr1|
                                    (nconc (pop-stack-2) (pop-stack-1))))))))
           (must (match-advance-string ")")))))

@

\defun{PARSE-NBGliphTok}{PARSE-NBGliphTok}
\calls{PARSE-NBGliphTok}{match-current-token}
\calls{PARSE-NBGliphTok}{action}
\calls{PARSE-NBGliphTok}{advance-token}
\uses{PARSE-NBGliphTok}{tok}
<<defun PARSE-NBGliphTok>>=
(defun |PARSE-NBGliphTok| (|tok|)
 (declare (special |tok|))
 (and (match-current-token 'gliph |tok|) nonblank (action (advance-token))))

@

\defun{PARSE-GliphTok}{PARSE-GliphTok}
\calls{PARSE-GliphTok}{match-current-token}
\calls{PARSE-GliphTok}{action}
\calls{PARSE-GliphTok}{advance-token}
\uses{PARSE-GliphTok}{tok}
<<defun PARSE-GliphTok>>=
(defun |PARSE-GliphTok| (|tok|)
 (declare (special |tok|))
 (and (match-current-token 'gliph |tok|) (action (advance-token))))

@

\defun{PARSE-AnyId}{PARSE-AnyId}
\calls{PARSE-AnyId}{parse-identifier}
\calls{PARSE-AnyId}{match-string}
\calls{PARSE-AnyId}{push-reduction}
\calls{PARSE-AnyId}{current-symbol}
\calls{PARSE-AnyId}{action}
\calls{PARSE-AnyId}{advance-token}
\calls{PARSE-AnyId}{parse-keyword}
<<defun PARSE-AnyId>>=
(defun |PARSE-AnyId| ()
  (or (parse-identifier)
      (or (and (match-string "$")
               (push-reduction '|PARSE-AnyId| (current-symbol))
               (action (advance-token)))
          (parse-keyword))))

@

\defun{PARSE-Sequence}{PARSE-Sequence}
\calls{PARSE-Sequence}{PARSE-OpenBracket}
\calls{PARSE-Sequence}{must}
\calls{PARSE-Sequence}{PARSE-Sequence1}
\calls{PARSE-Sequence}{match-advance-string}
\calls{PARSE-Sequence}{PARSE-OpenBrace}
\calls{PARSE-Sequence}{push-reduction}
\calls{PARSE-Sequence}{pop-stack-1}
<<defun PARSE-Sequence>>=
(defun |PARSE-Sequence| ()
  (or (and (|PARSE-OpenBracket|) (must (|PARSE-Sequence1|))
           (must (match-advance-string "]")))
      (and (|PARSE-OpenBrace|) (must (|PARSE-Sequence1|))
           (must (match-advance-string "}"))
           (push-reduction '|PARSE-Sequence|
               (list '|brace| (pop-stack-1))))))

@

\defun{PARSE-Sequence1}{PARSE-Sequence1}
\calls{PARSE-Sequence1}{PARSE-Expression}
\calls{PARSE-Sequence1}{push-reduction}
\calls{PARSE-Sequence1}{pop-stack-2}
\calls{PARSE-Sequence1}{pop-stack-1}
\calls{PARSE-Sequence1}{optional}
\calls{PARSE-Sequence1}{PARSE-IteratorTail}
<<defun PARSE-Sequence1>>=
(defun |PARSE-Sequence1| ()
  (and (or (and (|PARSE-Expression|)
                (push-reduction '|PARSE-Sequence1|
                    (list (pop-stack-2) (pop-stack-1))))
           (push-reduction '|PARSE-Sequence1| (list (pop-stack-1))))
       (optional
           (and (|PARSE-IteratorTail|)
                (push-reduction '|PARSE-Sequence1|
                    (cons 'collect
                          (append (pop-stack-1)
                                  (list (pop-stack-1)))))))))

@

\defun{PARSE-OpenBracket}{PARSE-OpenBracket}
\calls{PARSE-OpenBracket}{getToken}
\calls{PARSE-OpenBracket}{current-symbol}
\calls{PARSE-OpenBracket}{eqcar}
\calls{PARSE-OpenBracket}{push-reduction}
\calls{PARSE-OpenBracket}{action}
\calls{PARSE-OpenBracket}{advance-token}
<<defun PARSE-OpenBracket>>=
(defun |PARSE-OpenBracket| ()
 (let (g1)
  (and (eq (|getToken| (setq g1 (current-symbol))) '[)
       (must (or (and (eqcar g1 '|elt|)
                      (push-reduction '|PARSE-OpenBracket|
                          (list '|elt| (second g1) '|construct|)))
                 (push-reduction '|PARSE-OpenBracket| '|construct|)))
       (action (advance-token)))))) 

@

\defun{PARSE-OpenBrace}{PARSE-OpenBrace}
\calls{PARSE-OpenBrace}{getToken}
\calls{PARSE-OpenBrace}{current-symbol}
\calls{PARSE-OpenBrace}{eqcar}
\calls{PARSE-OpenBrace}{push-reduction}
\calls{PARSE-OpenBrace}{action}
\calls{PARSE-OpenBrace}{advance-token}
<<defun PARSE-OpenBrace>>=
(defun |PARSE-OpenBrace| ()
 (let (g1)
  (and (eq (|getToken| (setq g1 (current-symbol))) '{)
       (must (or (and (eqcar g1 '|elt|)
                      (push-reduction '|PARSE-OpenBrace|
                          (list '|elt| (second g1) '|brace|)))
                 (push-reduction '|PARSE-OpenBrace| '|construct|)))
       (action (advance-token)))))) 

@

\defun{PARSE-IteratorTail}{PARSE-IteratorTail}
\calls{PARSE-IteratorTail}{match-advance-string}
\calls{PARSE-IteratorTail}{bang}
\calls{PARSE-IteratorTail}{optional}
\calls{PARSE-IteratorTail}{star}
\calls{PARSE-IteratorTail}{PARSE-Iterator}
<<defun PARSE-IteratorTail>>=
(defun |PARSE-IteratorTail| ()
 (or (and (match-advance-string "repeat")
          (bang fil_test (optional (star repeator (|PARSE-Iterator|)))))
     (star repeator (|PARSE-Iterator|))))

@

\defun{PARSE-Iterator}{PARSE-Iterator}
\calls{PARSE-Iterator}{match-advance-string}
\calls{PARSE-Iterator}{must}
\calls{PARSE-Iterator}{PARSE-Primary}
\calls{PARSE-Iterator}{PARSE-Expression}
\calls{PARSE-Iterator}{PARSE-Expr}
\calls{PARSE-Iterator}{pop-stack-3}
\calls{PARSE-Iterator}{pop-stack-2}
\calls{PARSE-Iterator}{pop-stack-1}
\calls{PARSE-Iterator}{optional}
<<defun PARSE-Iterator>>=
(defun |PARSE-Iterator| ()
  (or (and (match-advance-string "for") (must (|PARSE-Primary|))
           (must (match-advance-string "in"))
           (must (|PARSE-Expression|))
           (must (or (and (match-advance-string "by")
                          (must (|PARSE-Expr| 200))
                          (push-reduction '|PARSE-Iterator|
                           (list 'inby (pop-stack-3)
                                       (pop-stack-2) (pop-stack-1))))
                     (push-reduction '|PARSE-Iterator|
                         (list 'in (pop-stack-2) (pop-stack-1)))))
           (optional
               (and (match-advance-string "|")
                    (must (|PARSE-Expr| 111))
                    (push-reduction '|PARSE-Iterator|
                        (list '|\|| (pop-stack-1))))))
      (and (match-advance-string "while") (must (|PARSE-Expr| 190))
           (push-reduction '|PARSE-Iterator|
               (list 'while (pop-stack-1))))
      (and (match-advance-string "until") (must (|PARSE-Expr| 190))
           (push-reduction '|PARSE-Iterator|
               (list 'until (pop-stack-1))))))

@
\subsection{The PARSE implicit routines}
These symbols are not explicitly referenced in the source.
Nevertheless, they are called during runtime. For example,
PARSE-SemiColon is called in the chain:
\begin{verbatim}
  PARSE-Enclosure {loc0=nil,loc1="(V  ==> Vector; "} [ihs=35]
   PARSE-Expr
    PARSE-LedPart
     PARSE-Operation
      PARSE-getSemanticForm
       PARSE-SemiColon
\end{verbatim}
so there is a bit of indirection involved in the call.

\defun{PARSE-Suffix}{PARSE-Suffix}
\calls{PARSE-Suffix}{push-reduction}
\calls{PARSE-Suffix}{current-symbol}
\calls{PARSE-Suffix}{action}
\calls{PARSE-Suffix}{advance-token}
\calls{PARSE-Suffix}{optional}
\calls{PARSE-Suffix}{PARSE-TokTail}
\calls{PARSE-Suffix}{pop-stack-1}
<<defun PARSE-Suffix>>=
(defun |PARSE-Suffix| ()
  (and (push-reduction '|PARSE-Suffix| (current-symbol))
       (action (advance-token)) (optional (|PARSE-TokTail|))
       (push-reduction '|PARSE-Suffix|
           (list (pop-stack-1) (pop-stack-1)))))

@

\defun{PARSE-SemiColon}{PARSE-SemiColon}
\calls{PARSE-SemiColon}{match-advance-string}
\calls{PARSE-SemiColon}{must}
\calls{PARSE-SemiColon}{PARSE-Expr}
\calls{PARSE-SemiColon}{push-reduction}
\calls{PARSE-SemiColon}{pop-stack-2}
\calls{PARSE-SemiColon}{pop-stack-1}
<<defun PARSE-SemiColon>>=
(defun |PARSE-SemiColon| ()
  (and (match-advance-string ";")
       (must (or (|PARSE-Expr| 82)
                 (push-reduction '|PARSE-SemiColon| '|/throwAway|)))
       (push-reduction '|PARSE-SemiColon|
           (list '|;| (pop-stack-2) (pop-stack-1)))))

@

\defun{PARSE-Return}{PARSE-Return}
\calls{PARSE-Return}{match-advance-string}
\calls{PARSE-Return}{must}
\calls{PARSE-Return}{PARSE-Expression}
\calls{PARSE-Return}{push-reduction}
\calls{PARSE-Return}{pop-stack-1}
<<defun PARSE-Return>>=
(defun |PARSE-Return| ()
  (and (match-advance-string "return") (must (|PARSE-Expression|))
       (push-reduction '|PARSE-Return|
           (list '|return| (pop-stack-1)))))

@

\defun{PARSE-Exit}{PARSE-Exit}
\calls{PARSE-Exit}{match-advance-string}
\calls{PARSE-Exit}{must}
\calls{PARSE-Exit}{PARSE-Expression}
\calls{PARSE-Exit}{push-reduction}
\calls{PARSE-Exit}{pop-stack-1}
<<defun PARSE-Exit>>=
(defun |PARSE-Exit| ()
  (and (match-advance-string "exit")
       (must (or (|PARSE-Expression|)
                 (push-reduction '|PARSE-Exit| '|$NoValue|)))
       (push-reduction '|PARSE-Exit|
           (list '|exit| (pop-stack-1)))))

@

\defun{PARSE-Leave}{PARSE-Leave}
\calls{PARSE-Leave}{match-advance-string}
\calls{PARSE-Leave}{PARSE-Expression}
\calls{PARSE-Leave}{must}
\calls{PARSE-Leave}{push-reduction}
\calls{PARSE-Leave}{PARSE-Label}
\calls{PARSE-Leave}{pop-stack-1}
<<defun PARSE-Leave>>=
(defun |PARSE-Leave| ()
  (and (match-advance-string "leave")
       (must (or (|PARSE-Expression|)
                 (push-reduction '|PARSE-Leave| '|$NoValue|)))
       (must (or (and (match-advance-string "from")
                      (must (|PARSE-Label|))
                      (push-reduction '|PARSE-Leave|
                          (list '|leaveFrom| (pop-stack-1) (pop-stack-1))))
                 (push-reduction '|PARSE-Leave|
                     (list '|leave| (pop-stack-1)))))))

@

\defun{PARSE-Seg}{PARSE-Seg}
\calls{PARSE-Seg}{PARSE-GliphTok}
\calls{PARSE-Seg}{bang}
\calls{PARSE-Seg}{optional}
\calls{PARSE-Seg}{PARSE-Expression}
\calls{PARSE-Seg}{push-reduction}
\calls{PARSE-Seg}{pop-stack-2}
\calls{PARSE-Seg}{pop-stack-1}
<<defun PARSE-Seg>>=
(defun |PARSE-Seg| ()
  (and (|PARSE-GliphTok| '|..|)
       (bang fil_test (optional (|PARSE-Expression|)))
       (push-reduction '|PARSE-Seg|
           (list 'segment (pop-stack-2) (pop-stack-1)))))

@

\defun{PARSE-Conditional}{PARSE-Conditional}
\calls{PARSE-Conditional}{match-advance-string}
\calls{PARSE-Conditional}{must}
\calls{PARSE-Conditional}{PARSE-Expression}
\calls{PARSE-Conditional}{bang}
\calls{PARSE-Conditional}{optional}
\calls{PARSE-Conditional}{PARSE-ElseClause}
\calls{PARSE-Conditional}{push-reduction}
\calls{PARSE-Conditional}{pop-stack-3}
\calls{PARSE-Conditional}{pop-stack-2}
\calls{PARSE-Conditional}{pop-stack-1}
<<defun PARSE-Conditional>>=
(defun |PARSE-Conditional| ()
  (and (match-advance-string "if") (must (|PARSE-Expression|))
       (must (match-advance-string "then")) (must (|PARSE-Expression|))
       (bang fil_test
             (optional
                 (and (match-advance-string "else")
                      (must (|PARSE-ElseClause|)))))
       (push-reduction '|PARSE-Conditional|
           (list '|if| (pop-stack-3) (pop-stack-2) (pop-stack-1)))))

@

\defun{PARSE-ElseClause}{PARSE-ElseClause}
\calls{PARSE-ElseClause}{current-symbol}
\calls{PARSE-ElseClause}{PARSE-Conditional}
\calls{PARSE-ElseClause}{PARSE-Expression}
<<defun PARSE-ElseClause>>=
(defun |PARSE-ElseClause| ()
  (or (and (eq (current-symbol) '|if|) (|PARSE-Conditional|))
      (|PARSE-Expression|)))

@

\defun{PARSE-Loop}{PARSE-Loop}
\calls{PARSE-Loop}{star}
\calls{PARSE-Loop}{PARSE-Iterator}
\calls{PARSE-Loop}{must}
\calls{PARSE-Loop}{match-advance-string}
\calls{PARSE-Loop}{PARSE-Expr}
\calls{PARSE-Loop}{push-reduction}
\calls{PARSE-Loop}{pop-stack-2}
\calls{PARSE-Loop}{pop-stack-1}
<<defun PARSE-Loop>>=
(defun |PARSE-Loop| ()
  (or (and (star repeator (|PARSE-Iterator|))
           (must (match-advance-string "repeat"))
           (must (|PARSE-Expr| 110))
           (push-reduction '|PARSE-Loop|
               (cons 'repeat
                     (append (pop-stack-2) (list (pop-stack-1))))))
      (and (match-advance-string "repeat") (must (|PARSE-Expr| 110))
           (push-reduction '|PARSE-Loop|
               (list 'repeat (pop-stack-1))))))

@

\defun{PARSE-LabelExpr}{PARSE-LabelExpr}
\calls{PARSE-LabelExpr}{PARSE-Label}
\calls{PARSE-LabelExpr}{must}
\calls{PARSE-LabelExpr}{PARSE-Expr}
\calls{PARSE-LabelExpr}{push-reduction}
\calls{PARSE-LabelExpr}{pop-stack-2}
\calls{PARSE-LabelExpr}{pop-stack-1}
<<defun PARSE-LabelExpr>>=
(defun |PARSE-LabelExpr| ()
  (and (|PARSE-Label|) (must (|PARSE-Expr| 120))
       (push-reduction '|PARSE-LabelExpr|
           (list 'label (pop-stack-2) (pop-stack-1)))))

@

\defun{PARSE-FloatTok}{PARSE-FloatTok}
\calls{PARSE-FloatTok}{parse-number}
\calls{PARSE-FloatTok}{push-reduction}
\calls{PARSE-FloatTok}{pop-stack-1}
\calls{PARSE-FloatTok}{bfp-}
\usesdollar{PARSE-FloatTok}{boot}
<<defun PARSE-FloatTok>>=
(defun |PARSE-FloatTok| ()
  (and (parse-number)
       (push-reduction '|PARSE-FloatTok|
           (if $boot (pop-stack-1) (bfp- (pop-stack-1))))))

@


\section{The PARSE support routines}
This section is broken up into 3 levels:
\begin{itemize}
\item String grabbing:    Match String, Match Advance String
\item Token handling:     Current Token, Next Token, Advance Token
\item Character handling: Current Char, Next Char, Advance Char
\item Line handling:      Next Line, Print Next Line
\item Error Handling
\item Floating Point Support
\item Dollar Translation
\end{itemize}
\subsection{String grabbing}
String grabbing is the art of matching initial segments of the current
line, and removing them from the line before the get tokenized if they
match (or removing the corresponding current tokens).

\defun{match-string}{match-string}
The match-string function returns length of X 
if X matches initial segment of inputstream.
\calls{match-string}{unget-tokens}
\calls{match-string}{skip-blanks}
\calls{match-string}{line-past-end-p}
\calls{match-string}{current-char}
\calls{match-string}{initial-substring-p}
\calls{match-string}{subseq}
\calls{match-string}{line-buffer}
\calls{match-string}{line-current-index}
\uses{match-string}{line}
<<defun match-string>>=
(defun match-string (x)
  (unget-tokens) ; So we don't get out of synch with token stream
  (skip-blanks)
  (if (and (not (line-past-end-p current-line)) (current-char) )
    (initial-substring-p x
     (subseq (line-buffer current-line) (line-current-index current-line)))))

@

\defun{match-advance-string}{match-advance-string}
The match-string function returns length of X 
if X matches initial segment of inputstream.
If it is successful, advance inputstream past X.
\calls{match-advance-string}{quote-if-string}
\calls{match-advance-string}{current-token}
\calls{match-advance-string}{match-string}
\calls{match-advance-string}{line-current-index}
\calls{match-advance-string}{line-past-end-p}
\calls{match-advance-string}{line-current-char}
\calls{match-advance-string}{line-buffer}
\calls{match-advance-string}{make-token}
\calls{match-advance-string}{}
\calls{match-advance-string}{}
\usesstruct{match-advance-string}{token}
\usesstruct{match-advance-string}{line}
<<defun match-advance-string>>=
(defun match-advance-string (x)
  (let ((y (if (>= (length (string x))
                   (length (string (quote-if-string (current-token)))))
               (match-string x)
               nil))) ; must match at least the current token
    (when y
      (incf (line-current-index current-line) y)
      (if (not (line-past-end-p current-line))
       (setf (line-current-char current-line)
             (elt (line-buffer current-line)
                  (line-current-index current-line)))
       (setf (line-current-char current-line) #\space))
      (setq prior-token
       (make-token :symbol (intern (string x))
                   :type 'identifier
                   :nonblank nonblank))
      t)))

@

\defun{initial-substring-p}{initial-substring-p}
\calls{initial-substring-p}{string-not-greaterp}
<<defun initial-substring-p>>=
(defun initial-substring-p (part whole)
  "Returns length of part if part matches initial segment of whole."
  (let ((x (string-not-greaterp part whole)))
    (and x (= x (length part)) x)))

@

\defun{quote-if-string}{quote-if-string}
\calls{quote-if-string}{token-type}
\calls{quote-if-string}{strconc}
\calls{quote-if-string}{token-symbol}
\calls{quote-if-string}{underscore}
\calls{quote-if-string}{token-nonblank}
\calls{quote-if-string}{pack}
\calls{quote-if-string}{escape-keywords}
\usesdollar{quote-if-string}{boot}
\usesdollar{quote-if-string}{spad}
<<defun quote-if-string>>=
(defun quote-if-string (token)
 (declare (special $boot $spad))
 (when token   ;only use token-type on non-null tokens
  (case (token-type token)
   (bstring      (strconc "[" (token-symbol token) "]*"))
   (string       (strconc "'" (token-symbol token) "'"))
   (spadstring   (strconc "\"" (underscore (token-symbol token)) "\""))
   (number       (format nil "~v,'0D" (token-nonblank token)
                                (token-symbol token)))
   (special-char (string (token-symbol token)))
   (identifier   (let ((id (symbol-name (token-symbol token)))
                           (pack (package-name (symbol-package
                                                (token-symbol token)))))
                  (if (or $boot $spad)
                   (if (string= pack "BOOT")
                    (escape-keywords (underscore id) (token-symbol token))
                    (concatenate 'string
                      (underscore pack) "'" (underscore id)))
                   id)))
   (t            (token-symbol token)))))

@

\defun{escape-keywords}{escape-keywords}
\calls{escape-keywords}{}
<<defun escape-keywords>>=
(defun escape-keywords (pname id)
  (if (member id keywords)
   (concatenate 'string "_" pname)
   pname))

@

\defun{underscore}{underscore}
\calls{underscore}{}
<<defun underscore>>=
(defun underscore (string)
 (if (every #'alpha-char-p string) 
  string
  (let* ((size (length string))
         (out-string (make-array (* 2 size)
                                 :element-type 'string-char
                                 :fill-pointer 0))
         next-char)
   (dotimes (i size)
    (setq next-char (char string i))
    (unless (alpha-char-p next-char) (vector-push #\_ out-string))
    (vector-push next-char out-string))
   out-string)))

@

\subsection{Token Handling}

\defun{getToken}{getToken}
\calls{getToken}{eqcar}
<<defun getToken>>=
(defun |getToken| (x)
 (if (eqcar x '|elt|) (third x) x))

@

\defun{unget-tokens}{unget-tokens}
\calls{unget-tokens}{quote-if-string}
\calls{unget-tokens}{line-current-segment}
\calls{unget-tokens}{strconc}
\calls{unget-tokens}{line-number}
\calls{unget-tokens}{token-nonblank}
\calls{unget-tokens}{line-new-line}
\calls{unget-tokens}{line-number}
\uses{unget-tokens}{valid-tokens}
<<defun unget-tokens>>=
(defun unget-tokens ()
 (case valid-tokens
  (0 t)
  (1 (let* ((cursym (quote-if-string current-token))
            (curline (line-current-segment current-line))
            (revised-line (strconc cursym curline (copy-seq " "))))
         (line-new-line revised-line current-line (line-number current-line))
         (setq nonblank (token-nonblank current-token))
         (setq valid-tokens 0)))
  (2 (let* ((cursym (quote-if-string current-token))
            (nextsym (quote-if-string next-token))
            (curline (line-current-segment Current-Line))
            (revised-line
             (strconc (if (token-nonblank current-token) "" " ")
                      cursym
                      (if (token-nonblank next-token) "" " ")
                      nextsym curline " ")))
      (setq nonblank (token-nonblank current-token))
      (line-new-line revised-line current-line (line-number current-line))
      (setq valid-tokens 0)))
  (t (error "How many tokens do you think you have?"))))

@

\defun{match-current-token}{match-current-token}
This returns the current token if it has EQ type and (optionally) equal symbol.
\calls{match-current-token}{current-token}
\calls{match-current-token}{match-token}
<<defun match-current-token>>=
(defun match-current-token (type &optional (symbol nil))
  (match-token (current-token) type symbol))

@

\defun{match-token}{match-token}
\calls{match-token}{token-type}
\calls{match-token}{token-symbol}
<<defun match-token>>=
(defun match-token (token type &optional (symbol nil))
  (when (and token (eq (token-type token) type))
   (if symbol
    (when (equal symbol (token-symbol token)) token)
    token)))

@

\defun{match-next-token}{match-next-token}
This returns the next token if it has equal type and (optionally) equal symbol.
\calls{match-next-token}{next-token}
\calls{match-next-token}{match-token}
<<defun match-next-token>>=
(defun match-next-token (type &optional (symbol nil))
  (match-token (next-token) type symbol))

@

\defun{current-symbol}{current-symbol}
\calls{current-symbol}{make-symbol-of}
\calls{current-symbol}{current-token}
<<defun current-symbol>>=
(defun current-symbol ()
 (make-symbol-of (current-token)))

@

\defun{make-symbol-of}{make-symbol-of}
\calls{make-symbol-of}{token-symbol}
<<defun make-symbol-of>>=
(defun make-symbol-of (token)
 (let ((u (and token (token-symbol token))))
  (cond
   ((not u) nil)
   ((characterp u) (intern (string u)))
   (u))))

@

\defun{current-token}{current-token}
This returns the current token getting a new one if necessary.
\calls{current-token}{try-get-token}
\uses{current-token}{valid-tokens}
\uses{current-token}{current-token}
<<defun current-token>>=
(defun current-token ()
 (declare (special valid-tokens current-token))
 (if (> valid-tokens 0)
  current-token
  (try-get-token current-token)))

@

\defun{try-get-token}{try-get-token}
\calls{try-get-token}{get-token}
\uses{try-get-token}{valid-tokens}
<<defun try-get-token>>=
(defun try-get-token (token)
 (declare (special valid-tokens))
 (let ((tok (get-token token)))
  (when tok
   (incf valid-tokens)
   token)))

@

\defun{next-token}{next-token}
This returns the token after the current token, or NIL if there is none after.
\calls{next-token}{try-get-token}
\calls{next-token}{current-token}
\uses{next-token}{valid-tokens}
\uses{next-token}{next-token}
<<defun next-token>>=
(defun next-token ()
 (declare (special valid-tokens next-token))
 (current-token)
 (if (> valid-tokens 1)
  next-token
  (try-get-token next-token)))

@

\defun{advance-token}{advance-token}
This makes the next token be the current token.
\calls{advance-token}{current-token}
\calls{advance-token}{copy-token}
\calls{advance-token}{try-get-token}
\uses{advance-token}{valid-tokens}
\uses{advance-token}{current-token}
<<defun advance-token>>=
(defun advance-token ()
  (current-token)                        ;don't know why this is needed
  (case valid-tokens
    (0 (try-get-token (current-token)))
    (1 (decf valid-tokens)
       (setq prior-token (copy-token current-token))
       (try-get-token current-token))
    (2 (setq prior-token (copy-token current-token))
       (setq current-token (copy-token next-token))
       (decf valid-tokens))))

@

\defvar{XTokenReader}
<<initvars>>=
(defvar XTokenReader 'get-meta-token "Name of tokenizing function")

@

\defun{get-token}{get-token}
\calls{get-token}{XTokenReader}
\uses{get-token}{XTokenReader}
<<defun get-token>>=
(defun get-token (token)
 (funcall XTokenReader token))

@

\subsection{Character handling}

\defun{current-char}{current-char}
This returns the current character of the line, initially blank for an 
unread line.
\calls{current-char}{line-past-end-p}
\calls{current-char}{line-current-char}
\uses{current-char}{current-line}
<<defun current-char>>=
(defun current-char ()
  (if (line-past-end-p current-line)
   #\return
   (line-current-char current-line)))

@

\defun{next-char}{next-char}
This returns the character after the current character, blank if at
end of line.  The blank-at-end-of-line assumption is allowable because
we assume that end-of-line is a token separator, which blank is
equivalent to.
\calls{next-char}{line-at-end-p}
\calls{next-char}{line-next-char}
\uses{next-char}{current-line}
<<defun next-char>>=
(defun next-char ()
 (if (line-at-end-p current-line) 
  #\return 
  (line-next-char current-line)))

@

\defun{char-eq}{char-eq}
<<defun char-eq>>=
(defun char-eq (x y)
 (char= (character x) (character y)))

@

\defun{char-ne}{char-ne}
<<defun char-ne>>=
(defun char-ne (x y)
 (char/= (character x) (character y)))

@

\subsection{Error handling}
\defvar{meta-error-handler}
<<initvars>>=
(defvar meta-error-handler 'meta-meta-error-handler)

@

\defun{meta-syntax-error}{meta-syntax-error}
\calls{meta-syntax-error}{meta-error-handler}
\uses{meta-syntax-error}{meta-error-handler}
<<defun meta-syntax-error>>=
(defun meta-syntax-error (&optional (wanted nil) (parsing nil))
  (funcall meta-error-handler wanted parsing))

@

\subsection{Floating Point Support}

\defun{floatexpid}{floatexpid}
\calls{floatexpid}{identp}
\calls{floatexpid}{pname}
\calls{floatexpid}{spadreduce}
\calls{floatexpid}{collect}
\calls{floatexpid}{step}
\calls{floatexpid}{maxindex}
\calls{floatexpid}{digitp}
<<defun floatexpid>>=
(defun floatexpid (x &aux s)
 (when (and (identp x) (char= (char-upcase (elt (setq s (pname x)) 0)) #\E)
            (> (length s) 1)
            (spadreduce and 0 (collect (step i 1 1 (maxindex s))
                                       (digitp (elt s i)))))
   (read-from-string s t nil :start 1)))

@

\subsection{Dollar Translation}

\defun{dollarTran}{dollarTran}
\usesdollar{dollarTran}{InteractiveMode}
<<defun dollarTran>>=
(defun |dollarTran| (dom rand)
 (let ((eltWord (if |$InteractiveMode| '|$elt| '|elt|)))
  (declare (special |$InteractiveMode|))
  (if (and (not (atom rand)) (cdr rand))
   (cons (list eltWord dom (car rand)) (cdr rand))
   (list eltWord dom rand))))

@

\subsection{Applying metagrammatical elements of a production (e.g., Star).}
\begin{itemize}
\item {\bf must} means that if it is not present in the token stream, 
it is a syntax error.
\item {\bf optional} means that if it is present in the token stream, 
that is a good thing, otherwise don't worry (like [ foo ] in BNF notation).
\item {\bf action} is something we do as a consequence of successful 
parsing; it is inserted at the end of the conjunction of requirements 
for a successful parse, and so should return T.
\item {\bf sequence} consists of a head, which if recognized implies that the
tail must follow.   Following tail are actions, which
are performed upon recognizing the head and tail.
\end{itemize}
\defmacro{Bang}
If the execution of prod does not result in an increase in the size of
the stack, then stack a NIL. Return the value of prod.
<<defmacro bang>>=
(defmacro bang (lab prod)
 `(progn
   (setf (stack-updated reduce-stack) nil)
   (let* ((prodvalue ,prod) (updated (stack-updated reduce-stack)))
    (unless updated (push-reduction ',lab nil))
    prodvalue)))

@

\defmacro{must}
<<defmacro must>>=
(defmacro must (dothis &optional (this-is nil) (in-rule nil))
  `(or ,dothis (meta-syntax-error ,this-is ,in-rule)))

@

\defun{action}{action}
<<defun action>>=
(defun action (dothis) (or dothis t))

@

\defun{optional}{optional}
<<defun optional>>=
(defun optional (dothis) (or dothis t))

@

\defmacro{star}
Succeeds if there are one or more of PROD, stacking as one unit
the sub-reductions of PROD and labelling them with LAB.
E.G., {\tt (Star IDs (parse-id))} with A B C will stack (3 IDs (A B C)),
where (parse-id) would stack (1 ID (A)) when applied once.
\calls{star}{stack-size}
\calls{star}{push-reduction}
\calls{star}{push}
\calls{star}{pop-stack-1}
<<defmacro star>>=
(defmacro star (lab prod)
  `(prog ((oldstacksize (stack-size reduce-stack)))
     (if (not ,prod) (return nil))
loop
     (if (not ,prod)
      (let* ((newstacksize (stack-size reduce-stack))
             (number-of-new-reductions (- newstacksize oldstacksize)))
        (if (> number-of-new-reductions 0)
         (return (do ((i 0 (1+ i)) (accum nil))
                     ((= i number-of-new-reductions)
                       (push-reduction ',lab accum)
                       (return t))
                   (push (pop-stack-1) accum)))
         (return t)))
      (go loop))))

@
\subsection{Stacking and retrieving reductions of rules.}

\defun{push-reduction}{push-reduction}
\calls{push-reduction}{stack-push}
\calls{push-reduction}{make-reduction}
\uses{push-reduction}{reduce-stack}
<<defun push-reduction>>=
(defun push-reduction (rule redn)
  (stack-push (make-reduction :rule rule :value redn) reduce-stack))

@

\chapter{The Compiler}

\section{Compiling EQ.spad}
Given the top level command:
\begin{verbatim}
)co EQ
\end{verbatim}
The default call chain looks like:
\begin{verbatim}
1> (|compiler| ...)
 2> (|compileSpad2Cmd| ...)
   Compiling AXIOM source code from file /tmp/A.spad using old system 
      compiler.
  3> (|compilerDoit| ...)
   4> (|/RQ,LIB|)
    5> (/RF-1 ...)
     6> (SPAD ...)
   AXSERV abbreviates package AxiomServer 
      7> (S-PROCESS ...)
       8> (|compTopLevel| ...)
        9> (|compOrCroak| ...)
         10> (|compOrCroak1| ...)
          11> (|comp| ...)
           12> (|compNoStacking| ...)
            13> (|comp2| ...)
             14> (|comp3| ...)
              15> (|compExpression| ...)
*              16> (|compWhere| ...)
                17> (|comp| ...)
                 18> (|compNoStacking| ...)
                  19> (|comp2| ...)
                   20> (|comp3| ...)
                    21> (|compExpression| ...)
                     22> (|compSeq| ...)
                      23> (|compSeq1| ...)
                       24> (|compSeqItem| ...)
                        25> (|comp| ...)
                         26> (|compNoStacking| ...)
                          27> (|comp2| ...)
                           28> (|comp3| ...)
                            29> (|compExpression| ...)
                            <29 (|compExpression| ...)
                           <28 (|comp3| ...)
                          <27 (|comp2| ...)
                         <26 (|compNoStacking| ...)
                        <25 (|comp| ...)
                       <24 (|compSeqItem| ...)
                       24> (|compSeqItem| ...)
                        25> (|comp| ...)
                         26> (|compNoStacking| ...)
                          27> (|comp2| ...)
                           28> (|comp3| ...)
                            29> (|compExpression| ...)
                             30> (|compExit| ...)
                              31> (|comp| ...)
                               32> (|compNoStacking| ...)
                                33> (|comp2| ...)
                                 34> (|comp3| ...)
                                  35> (|compExpression| ...)
                                  <35 (|compExpression| ...)
                                 <34 (|comp3| ...)
                                <33 (|comp2| ...)
                               <32 (|compNoStacking| ...)
                              <31 (|comp| ...)
                              31> (|modifyModeStack| ...)
                              <31 (|modifyModeStack| ...)
                             <30 (|compExit| ...)
                            <29 (|compExpression| ...)
                           <28 (|comp3| ...)
                          <27 (|comp2| ...)
                         <26 (|compNoStacking| ...)
                        <25 (|comp| ...)
                       <24 (|compSeqItem| ...)
                       24> (|replaceExitEtc| ...)
                        25> (|replaceExitEtc,fn| ...)
                         26> (|replaceExitEtc| ...)
                          27> (|replaceExitEtc,fn| ...)
                           28> (|replaceExitEtc| ...)
                            29> (|replaceExitEtc,fn| ...)
                            <29 (|replaceExitEtc,fn| ...)
                           <28 (|replaceExitEtc| ...)
                           28> (|replaceExitEtc| ...)
                            29> (|replaceExitEtc,fn| ...)
                            <29 (|replaceExitEtc,fn| ...)
                           <28 (|replaceExitEtc| ...)
                          <27 (|replaceExitEtc,fn| ...)
                         <26 (|replaceExitEtc| ...)
                         26> (|replaceExitEtc| ...)
                          27> (|replaceExitEtc,fn| ...)
                           28> (|replaceExitEtc| ...)
                            29> (|replaceExitEtc,fn| ...)
                             30> (|replaceExitEtc| ...)
                              31> (|replaceExitEtc,fn| ...)
                               32> (|replaceExitEtc| ...)
                                33> (|replaceExitEtc,fn| ...)
                                <33 (|replaceExitEtc,fn| ...)
                               <32 (|replaceExitEtc| ...)
                               32> (|replaceExitEtc| ...)
                                33> (|replaceExitEtc,fn| ...)
                                <33 (|replaceExitEtc,fn| ...)
                               <32 (|replaceExitEtc| ...)
                              <31 (|replaceExitEtc,fn| ...)
                             <30 (|replaceExitEtc| ...)
                             30> (|convertOrCroak| ...)
                              31> (|convert| ...)
                              <31 (|convert| ...)
                             <30 (|convertOrCroak| ...)
                            <29 (|replaceExitEtc,fn| ...)
                           <28 (|replaceExitEtc| ...)
                           28> (|replaceExitEtc| ...)
                            29> (|replaceExitEtc,fn| ...)
                            <29 (|replaceExitEtc,fn| ...)
                           <28 (|replaceExitEtc| ...)
                          <27 (|replaceExitEtc,fn| ...)
                         <26 (|replaceExitEtc| ...)
                        <25 (|replaceExitEtc,fn| ...)
                       <24 (|replaceExitEtc| ...)
                      <23 (|compSeq1| ...)
                     <22 (|compSeq| ...)
                    <21 (|compExpression| ...)
                   <20 (|comp3| ...)
                  <19 (|comp2| ...)
                 <18 (|compNoStacking| ...)
                <17 (|comp| ...)
                17> (|comp| ...)
                 18> (|compNoStacking| ...)
                  19> (|comp2| ...)
                   20> (|comp3| ...)
                    21> (|compExpression| ...)
                     22> (|comp| ...)
                      23> (|compNoStacking| ...)
                       24> (|comp2| ...)
                        25> (|comp3| ...)
                         26> (|compColon| ...)
                         <26 (|compColon| ...)
                        <25 (|comp3| ...)
                       <24 (|comp2| ...)
                      <23 (|compNoStacking| ...)
                     <22 (|comp| ...)
\end{verbatim}

In order to explain the compiler we will walk through the compilation of
EQ.spad, which handles equations as mathematical objects. We start the
system. Most of the structure in Axiom are circular so we have to the
\verb|*print-cycle*| to true.
\begin{verbatim}
root@spiff:/tmp# axiom -nox

(1) -> )lisp (setq *print-circle* t)

Value = T
\end{verbatim}

We trace the function we find interesting:
\begin{verbatim}
(1) -> )lisp (trace |compiler|)

Value = (|compiler|)
\end{verbatim}

\defunsec{compiler}{The top level compiler command}
We compile the spad file. We can see that the {\bf compiler} function gets
a list 
\begin{verbatim}
(1) -> )co EQ

  1> (|compiler| (EQ))
\end{verbatim}
In order to find this file, the {\bf pathname} and {\bf pathnameType} 
functions are used to find the location and pathname to the file. They
{\bf pathnameType} function eventually returns the fact that this is
a spad source file. Once that is known we call the {\bf compileSpad2Cmd}
function with a list containing the full pathname as a string.
\begin{verbatim}
  1> (|compiler| (EQ))
    2> (|pathname| (EQ))
    <2 (|pathname| #p"EQ")
    2> (|pathnameType| #p"EQ")
      3> (|pathname| #p"EQ")
      <3 (|pathname| #p"EQ")
    <2 (|pathnameType| NIL)
    2> (|pathnameType| "/tmp/EQ.spad")
      3> (|pathname| "/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|pathnameType| "spad")
    2> (|pathnameType| "/tmp/EQ.spad")
      3> (|pathname| "/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|pathnameType| "spad")
    2> (|pathnameType| "/tmp/EQ.spad")
      3> (|pathname| "/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|pathnameType| "spad")
    2> (|compileSpad2Cmd| ("/tmp/EQ.spad"))
\end{verbatim}

\calls{compiler}{helpSpad2Cmd(5)}
\calls{compiler}{selectOptionLC(5)}
\calls{compiler}{pathname(5)}
\calls{compiler}{mergePathnames(5)}
\calls{compiler}{pathnameType(5)}
\calls{compiler}{namestring(5)}
\calls{compiler}{throwKeyedMsg}
\calls{compiler}{findfile}
\calls{compiler}{compileSpad2Cmd}
\calls{compiler}{compileSpadLispCmd}
\usesdollar{compiler}{newConlist}
\usesdollar{compiler}{options}
\uses{compiler}{/editfile}
<<defun compiler>>=
(defun |compiler| (args)
 "The top level compiler command"
 (let (|$newConlist| optlist optname optargs havenew haveold aft ef af af1)
  (declare (special |$newConlist| |$options| /editfile))
  (setq |$newConlist| nil)
  (cond
   ((and (null args) (null |$options|) (null /editfile))
     (|helpSpad2Cmd| '(|compiler|)))
   (t
    (cond ((null args) (setq args (cons /editfile nil))))
    (setq optlist '(|new| |old| |translate| |constructor|))
    (setq havenew nil)
    (setq haveold nil)
    (do ((t0 |$options| (cdr t0)) (opt nil))
        ((or (atom t0) 
             (progn (setq opt (car t0)) nil)
             (null (null (and havenew haveold))))
          nil)
     (setq optname (car opt))
     (setq optargs (cdr opt))
     (case (|selectOptionLC| optname optlist nil)
      (|new|         (setq havenew t))
      (|translate|   (setq haveold t))
      (|constructor| (setq haveold t))
      (|old|         (setq haveold t))))
    (cond
     ((and havenew haveold) (|throwKeyedMsg| 's2iz0081 nil))
     (t
      (setq af (|pathname| args))
      (setq aft (|pathnameType| af))
      (cond
       ((or haveold (string= aft "spad"))
        (if (null (setq af1 ($findfile af '(|spad|))))
           (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
           (|compileSpad2Cmd| (cons af1 nil))))
       ((string= aft "nrlib")
        (if (null (setq af1 ($findfile af '(|nrlib|))))
          (|throwKeyedMsg| 'S2IL0003 (cons (namestring af) nil))
          (|compileSpadLispCmd| (cons af1 nil))))
       (t
        (setq af1 ($findfile af '(|spad|)))
        (cond
         ((and af1 (string= (|pathnameType| af1) "spad"))
          (|compileSpad2Cmd| (cons af1 nil)))
         (t
          (setq ef (|pathname| /editfile))
          (setq ef (|mergePathnames| af ef))
          (cond
           ((boot-equal ef af) (|throwKeyedMsg| 's2iz0039 nil))
           (t
            (setq af ef)
            (cond
             ((string= (|pathnameType| af) "spad")
              (|compileSpad2Cmd| args))
             (t
              (setq af1 ($findfile af '(|spad|)))
              (cond
               ((and af1 (string= (|pathnameType| af1) "spad"))
                 (|compileSpad2Cmd| (cons af1 nil)))
               (t (|throwKeyedMsg| 's2iz0039 nil)))))))))))))))))

@

\defunsec{compileSpad2Cmd}{The Spad compiler top level function}
The argument to this function, as noted above, is a list containing
the string pathname to the file.
\begin{verbatim}
    2> (|compileSpad2Cmd| ("/tmp/EQ.spad"))
\end{verbatim}
There is a fair bit of redundant work to find the full filename and pathname
of the file. This needs to be eliminated.

The trace of the functions in this routines is:
\begin{verbatim}
  1> (|selectOptionLC| "compiler" (|abbreviations| |boot| |browse| |cd| |clear| |close| |compiler| |copyright| |credits| |describe| |display| |edit| |fin| |frame| |help| |history| |lisp| |library| |load| |ltrace| |pquit| |quit| |read| |savesystem| |set| |show| |spool| |summary| |synonym| |system| |trace| |trademark| |undo| |what| |with| |workfiles| |zsystemdevelopment|) |commandErrorIfAmbiguous|)
  <1 (|selectOptionLC| |compiler|)
  1> (|selectOptionLC| |compiler| (|abbreviations| |boot| |browse| |cd| |clear| |close| |compiler| |copyright| |credits| |describe| |display| |edit| |fin| |frame| |help| |history| |lisp| |library| |load| |ltrace| |pquit| |quit| |read| |savesystem| |set| |show| |spool| |summary| |synonym| |system| |trace| |trademark| |undo| |what| |with| |workfiles| |zsystemdevelopment|) |commandError|)
  <1 (|selectOptionLC| |compiler|)
  1> (|pathname| (EQ))
  <1 (|pathname| #p"EQ")
  1> (|pathnameType| #p"EQ")
    2> (|pathname| #p"EQ")
    <2 (|pathname| #p"EQ")
  <1 (|pathnameType| NIL)
  1> (|pathnameType| "/tmp/EQ.spad")
    2> (|pathname| "/tmp/EQ.spad")
    <2 (|pathname| #p"/tmp/EQ.spad")
  <1 (|pathnameType| "spad")
  1> (|pathnameType| "/tmp/EQ.spad")
    2> (|pathname| "/tmp/EQ.spad")
    <2 (|pathname| #p"/tmp/EQ.spad")
  <1 (|pathnameType| "spad")
  1> (|pathnameType| "/tmp/EQ.spad")
    2> (|pathname| "/tmp/EQ.spad")
    <2 (|pathname| #p"/tmp/EQ.spad")
  <1 (|pathnameType| "spad")
  1> (|compileSpad2Cmd| ("/tmp/EQ.spad"))
    2> (|pathname| ("/tmp/EQ.spad"))
    <2 (|pathname| #p"/tmp/EQ.spad")
    2> (|pathnameType| #p"/tmp/EQ.spad")
      3> (|pathname| #p"/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|pathnameType| "spad")
    2> (|updateSourceFiles| #p"/tmp/EQ.spad")
      3> (|pathname| #p"/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
      3> (|pathname| #p"/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
      3> (|pathnameType| #p"/tmp/EQ.spad")
        4> (|pathname| #p"/tmp/EQ.spad")
        <4 (|pathname| #p"/tmp/EQ.spad")
      <3 (|pathnameType| "spad")
      3> (|pathname| ("EQ" "spad" "*"))
      <3 (|pathname| #p"EQ.spad")
      3> (|pathnameType| #p"EQ.spad")
        4> (|pathname| #p"EQ.spad")
        <4 (|pathname| #p"EQ.spad")
      <3 (|pathnameType| "spad")
    <2 (|updateSourceFiles| #p"EQ.spad")
    2> (|namestring| ("/tmp/EQ.spad"))
      3> (|pathname| ("/tmp/EQ.spad"))
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|namestring| "/tmp/EQ.spad")
   Compiling AXIOM source code from file /tmp/EQ.spad using old system 
      compiler.
\end{verbatim}

Again we find a lot of redundant work. We finally end up calling
{\bf compilerDoit} with a constructed argument list:
\begin{verbatim}
    2> (|compilerDoit| NIL (|rq| |lib|))
\end{verbatim}


\calls{compileSpad2Cmd}{pathname(5)}
\calls{compileSpad2Cmd}{pathnameType(5)}
\calls{compileSpad2Cmd}{namestring(5)}
\calls{compileSpad2Cmd}{updateSourceFiles(5)}
\calls{compileSpad2Cmd}{selectOptionLC(5)}
\calls{compileSpad2Cmd}{terminateSystemCommand(5)}
\calls{compileSpad2Cmd}{nequal}
\calls{compileSpad2Cmd}{throwKeyedMsg}
\calls{compileSpad2Cmd}{sayKeyedMsg}
\calls{compileSpad2Cmd}{error}
\calls{compileSpad2Cmd}{strconc}
\calls{compileSpad2Cmd}{object2String}
\calls{compileSpad2Cmd}{oldParserAutoloadOnceTrigger}
\calls{compileSpad2Cmd}{browserAutoloadOnceTrigger}
\calls{compileSpad2Cmd}{spad2AsTranslatorAutoloadOnceTrigger}
\calls{compileSpad2Cmd}{convertSpadToAsFile}
\calls{compileSpad2Cmd}{compilerDoitWithScreenedLisplib}
\calls{compileSpad2Cmd}{compilerDoit}
\calls{compileSpad2Cmd}{extendLocalLibdb}
\calls{compileSpad2Cmd}{spadPrompt}
\usesdollar{compileSpad2Cmd}{newComp}
\usesdollar{compileSpad2Cmd}{scanIfTrue}
\usesdollar{compileSpad2Cmd}{compileOnlyCertainItems}
\usesdollar{compileSpad2Cmd}{f}
\usesdollar{compileSpad2Cmd}{m}
\usesdollar{compileSpad2Cmd}{QuickLet}
\usesdollar{compileSpad2Cmd}{QuickCode}
\usesdollar{compileSpad2Cmd}{sourceFileTypes}
\usesdollar{compileSpad2Cmd}{InteractiveMode}
\usesdollar{compileSpad2Cmd}{options}
\usesdollar{compileSpad2Cmd}{newConlist}
\uses{compileSpad2Cmd}{/editfile}
<<defun compileSpad2Cmd>>=
(defun |compileSpad2Cmd| (args)
 (let (|$newComp| |$scanIfTrue| 
       |$compileOnlyCertainItems| |$f| |$m| |$QuickLet| |$QuickCode| 
       |$sourceFileTypes| |$InteractiveMode| path optlist fun optname 
       optargs fullopt constructor)
  (declare (special |$newComp| |$scanIfTrue| 
       |$compileOnlyCertainItems| |$f| |$m| |$QuickLet| |$QuickCode| 
       |$sourceFileTypes| |$InteractiveMode| /editfile |$options|
       |$newConlist|)) 
   (setq path (|pathname| args))
   (cond
    ((nequal (|pathnameType| path) "spad") (|throwKeyedMsg| 's2iz0082 nil))
    ((null (probe-file path))
     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
    (t
     (setq /editfile path)
     (|updateSourceFiles| path)
     (|sayKeyedMsg| 's2iz0038 (list (|namestring| args)))
     (setq optlist '(|break| |constructor| |functions| |library| |lisp|
         |new| |old| |nobreak| |nolibrary| |noquiet| |vartrace| |quiet|
         |translate|))
     (setq |$QuickLet| t)
     (setq |$QuickCode| t)
     (setq fun '(|rq| |lib|))
     (setq |$sourceFileTypes| '("SPAD"))
     (dolist (opt |$options|)
      (setq optname (car opt))
      (setq optargs (cdr opt))
      (setq fullopt (|selectOptionLC| optname optlist nil))
      (case fullopt
       (|old| nil)
       (|library| (setelt fun 1 '|lib|))
       (|nolibrary| (setelt fun 1 '|nolib|))
       (|quiet| (when (nequal (elt fun 0) '|c|) (setelt fun 0 '|rq|)))
       (|noquiet| (when (nequal (elt fun 0) '|c|) (setelt fun 0 '|rf|)))
       (|nobreak| (setq |$scanIfTrue| t))
       (|break| (setq |$scanIfTrue| nil))
       (|vartrace| (setq |$QuickLet| nil))
       (|lisp| (|throwKeyedMsg| 's2iz0036 (list ")lisp")))
       (|functions|
        (if (null optargs) 
         (|throwKeyedMsg| 's2iz0037 (list ")functions"))
         (setq |$compileOnlyCertainItems| optargs)))
       (|constructor|
        (if (null optargs)
         (|throwKeyedMsg| 's2iz0037 (list ")constructor"))
         (progn
          (setelt fun 0 '|c|)
          (setq constructor (mapcar #'|unabbrev| optargs)))))
       (t
        (|throwKeyedMsg| 's2iz0036 
         (list (strconc ")" (|object2String| optname)))))))
    (setq |$InteractiveMode| nil)
    (cond
     (|$compileOnlyCertainItems|
      (if (null constructor)
       (|sayKeyedMsg| 's2iz0040 nil)
       (|compilerDoitWithScreenedLisplib| constructor fun)))
     (t (|compilerDoit| constructor fun)))
    (|extendLocalLibdb| |$newConlist|)
    (|terminateSystemCommand|)
    (|spadPrompt|)))))

@

This trivial function cases on the second argument to decide which 
combination of operations was requested. For this case we see:
\begin{verbatim}
(1) -> )co EQ
   Compiling AXIOM source code from file /tmp/EQ.spad using old system 
      compiler.
  1> (|compilerDoit| NIL (|rq| |lib|))
    2> (|/RQ,LIB|)

... [snip]...

    <2 (|/RQ,LIB| T)
  <1 (|compilerDoit| T)
(1) -> 
\end{verbatim}

\defun{compilerDoit}{compilerDoit}
\calls{compilerDoit}{/rq(5)}
\calls{compilerDoit}{/rf(5)}
\calls{compilerDoit}{member(5)}
\calls{compilerDoit}{sayBrightly}
\usesdollar{compilerDoit}{byConstructors}
\usesdollar{compilerDoit}{constructorsSeen}
<<defun compilerDoit>>=
(defun |compilerDoit| (constructor fun)
 (let (|$byConstructors| |$constructorsSeen|)
 (declare (special |$byConstructors| |$constructorsSeen|))
  (cond
   ((equal fun '(|rf| |lib|))   (|/RQ,LIB|))   ; Ignore "noquiet"
   ((equal fun '(|rf| |nolib|)) (/rf))
   ((equal fun '(|rq| |lib|))   (|/RQ,LIB|))
   ((equal fun '(|rq| |nolib|)) (/rq))
   ((equal fun '(|c| |lib|))
    (setq |$byConstructors| (loop for x in constructor collect (|opOf| x)))
    (|/RQ,LIB|)
    (dolist (x |$byConstructors|)
     (unless (|member| x |$constructorsSeen|)
      (|sayBrightly| `(">>> Warning " |%b| ,x |%d| " was not found"))))))))

@

This function simply calls {\bf \verb|/rf-1|}. 
\begin{verbatim}
(2) -> )co EQ
   Compiling AXIOM source code from file /tmp/EQ.spad using old system 
      compiler.
  1> (|compilerDoit| NIL (|rq| |lib|))
    2> (|/RQ,LIB|)
      3> (/RF-1 NIL)
...[snip]...
      <3 (/RF-1 T)
    <2 (|/RQ,LIB| T)
  <1 (|compilerDoit| T)
\end{verbatim}

\defun{/RQ,LIB}{/RQ,LIB}
\calls{/RQ,LIB}{/rf-1(5)}
\uses{/RQ,LIB}{echo-meta(5)}
\usesdollar{/RQ,LIB}{lisplib}
<<defun /RQ,LIB>>=
(defun |/RQ,LIB| (&rest foo &aux (echo-meta nil) ($lisplib t))
 (declare (special echo-meta $lisplib) (ignore foo))
  (/rf-1 nil))

@
 
Since this function is called with nil we fall directly into the
call to the function {\bf spad}:
\begin{verbatim}
(2) -> )co EQ
   Compiling AXIOM source code from file /tmp/EQ.spad using old system 
      compiler.
  1> (|compilerDoit| NIL (|rq| |lib|))
    2> (|/RQ,LIB|)
      3> (/RF-1 NIL)
        4> (SPAD "/tmp/EQ.spad")
...[snip]...
        <4 (SPAD T)
      <3 (/RF-1 T)
    <2 (|/RQ,LIB| T)
  <1 (|compilerDoit| T)
\end{verbatim}

\defun{/rf-1}{/rf-1}
\calls{/rf-1}{makeInputFilename(5)}
\calls{/rf-1}{ncINTERPFILE}
\calls{/rf-1}{spad}
\uses{/rf-1}{/editfile}
\uses{/rf-1}{echo-meta}
<<defun /rf-1>>=
(defun /rf-1 (ignore)
 (declare (ignore ignore))
 (let* ((input-file (makeInputFilename /editfile))
        (type (pathname-type input-file)))
 (declare (special echo-meta /editfile))
 (cond
  ((string= type "lisp") (load input-file))
  ((string= type "input") (|ncINTERPFILE| input-file echo-meta))
  (t (spad input-file)))))

@

Here we begin the actual compilation process. 
\begin{verbatim}
  1> (SPAD "/tmp/EQ.spad")
    2> (|makeInitialModemapFrame|)
    <2 (|makeInitialModemapFrame| ((NIL)))
    2> (INIT-BOOT/SPAD-READER)
    <2 (INIT-BOOT/SPAD-READER NIL)
    2> (OPEN "/tmp/EQ.spad" :DIRECTION :INPUT)
    <2 (OPEN #<input stream "/tmp/EQ.spad">)
    2> (INITIALIZE-PREPARSE #<input stream "/tmp/EQ.spad">)
    <2 (INITIALIZE-PREPARSE ")abbrev domain EQ Equation")
    2> (PREPARSE #<input stream "/tmp/EQ.spad">)
   EQ abbreviates domain Equation 
    <2 (PREPARSE (# # # # # # # # ...))
    2> (|PARSE-NewExpr|)
    <2 (|PARSE-NewExpr| T)
    2> (S-PROCESS (|where| # #))
...[snip]...
      3> (OPEN "/tmp/EQ.erlib/info" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.erlib/info">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.lsp")
      <3 (OPEN #<input stream "/tmp/EQ.nrlib/EQ.lsp">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.data" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.data">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.c" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.c">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.h" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.h">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.fn" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.fn">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.o" :DIRECTION :OUTPUT :IF-EXISTS :APPEND)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.o">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.data")
      <3 (OPEN #<input stream "/tmp/EQ.nrlib/EQ.data">)
      3> (OPEN "/tmp/EQ.nrlib/index.kaf")
      <3 (OPEN #<input stream "/tmp/EQ.nrlib/index.kaf">)
    <2 (S-PROCESS NIL)
  <1 (SPAD T)
  1> (OPEN "temp.text" :DIRECTION :OUTPUT)
  <1 (OPEN #<output stream "temp.text">)
  1> (OPEN "libdb.text")
  <1 (OPEN #<input stream "libdb.text">)
  1> (OPEN "temp.text")
  <1 (OPEN #<input stream "temp.text">)
  1> (OPEN "libdb.text" :DIRECTION :OUTPUT)
  <1 (OPEN #<output stream "libdb.text">)
\end{verbatim}

The major steps in this process involve the {\bf preparse} function.
(See book volume 5 for more details).
The {\bf preparse} function  returns a list of pairs of the form:
( (linenumber . linestring) .... (linenumber . linestring))
For instance, for the file {\tt EQ.spad}, we get:
\begin{verbatim}
    <2 (PREPARSE (
 (19 . "Equation(S: Type): public == private where")
 (20 . " (Ex ==> OutputForm;")
 (21 . "  public ==> Type with")
 (22 . "   (\"=\": (S, S) -> $;")
...[skip]...
 (202 . "        inv eq == [inv lhs eq, inv rhs eq]);")
 (203 . "    if S has ExpressionSpace then")
 (204 . "        subst(eq1,eq2) ==")
 (205 . "           (eq3 := eq2 pretend Equation S;")
 (206 . "            [subst(lhs eq1,eq3),subst(rhs eq1,eq3)])))")))
\end{verbatim}

And the {\bf s-process} function which returns a parsed version of the input.
\begin{verbatim}
    2> (S-PROCESS
(|where|
 (== (|:| (|Equation| (|:| S |Type|)) |public|) |private|)
 (|;|
  (|;|
   (==> |Ex| |OutputForm|)
   (==> |public|
    (|Join| |Type|
     (|with|
      (CATEGORY
       (|Signature| "=" (-> (|,| S S) $))
       (|Signature| |equation| (-> (|,| S S) $))
       (|Signature| |swap| (-> $ $))
       (|Signature| |lhs| (-> $ S))
       (|Signature| |rhs| (-> $ S))
       (|Signature| |map| (-> (|,| (-> S S) $) $))
       (|if| (|has| S (|InnerEvalable| (|,| |Symbol| S)))
        (|Attribute| (|InnerEvalable| (|,| |Symbol| S)))
        NIL)
       (|if| (|has| S |SetCategory|)
        (CATEGORY 
         (|Attribute| |SetCategory|)
         (|Attribute| (|CoercibleTo| |Boolean|))
         (|if| (|has| S (|Evalable| S))
          (CATEGORY
           (|Signature| |eval| (-> (|,| $ $) $))
           (|Signature| |eval| (-> (|,| $ (|List| $)) $)))
          NIL))
        NIL) 
       (|if| (|has| S |AbelianSemiGroup|)
        (CATEGORY
         (|Attribute| |AbelianSemiGroup|)
         (|Signature| "+" (-> (|,| S $) $))
         (|Signature| "+" (-> (|,| $ S) $)))
         NIL)
       (|if| (|has| S |AbelianGroup|)
        (CATEGORY
         (|Attribute| |AbelianGroup|)
         (|Signature| |leftZero| (-> $ $))
         (|Signature| |rightZero| (-> $ $))
         (|Signature| "-" (-> (|,| S $) $))
         (|Signature| "-" (-> (|,| $ S) $))) NIL)
       (|if| (|has| S |SemiGroup|)
        (CATEGORY
         (|Attribute| |SemiGroup|)
         (|Signature| "*" (-> (|,| S $) $))
         (|Signature| "*" (-> (|,| $ S) $)))
        NIL)
       (|if| (|has| S |Monoid|)
        (CATEGORY
         (|Attribute| |Monoid|)
         (|Signature| |leftOne| (-> $ (|Union| (|,| $ "failed"))))
         (|Signature| |rightOne| (-> $ (|Union| (|,| $ "failed")))))
        NIL)
       (|if| (|has| S |Group|)
        (CATEGORY
         (|Attribute| |Group|)
         (|Signature| |leftOne| (-> $ (|Union| (|,| $ "failed"))))
         (|Signature| |rightOne| (-> $ (|Union| (|,| $ "failed")))))
         NIL)
       (|if| (|has| S |Ring|)
        (CATEGORY
         (|Attribute| |Ring|)
         (|Attribute| (|BiModule| (|,| S S))))
        NIL)
       (|if| (|has| S |CommutativeRing|)
        (|Attribute| (|Module| S))
        NIL)
       (|if| (|has| S |IntegralDomain|)
        (|Signature| |factorAndSplit| (-> $ (|List| $)))
        NIL)
       (|if| (|has| S (|PartialDifferentialRing| |Symbol|))
        (|Attribute| (|PartialDifferentialRing| |Symbol|))
        NIL)
       (|if| (|has| S |Field|)
        (CATEGORY
         (|Attribute| (|VectorSpace| S))
         (|Signature| "/" (-> (|,| $ $) $))
         (|Signature| |inv| (-> $ $)))
        NIL)
       (|if| (|has| S |ExpressionSpace|)
        (|Signature| |subst| (-> (|,| $ $) $))
        NIL)
    )))))
  (==> |private|
   (|add|
    (|;|
     (|;|
      (|;|
       (|;|
        (|;|
         (|;|
          (|;|
           (|;|
            (|;|
             (|;|
              (|;|
               (|;|
                (|;|
                 (|;|
                  (|;|
                   (|;|
                    (|;|
                     (|;|
                      (|;|
                       (|;|
                        (|;|
                         (|;|
                          (|:=| |Rep|
                           (|Record| (|,| (|:| |lhs| S) (|:| |rhs| S))))
                          (|,| |eq1| (|:| |eq2| $)))
                         (|:| |s| S))
                        (|if| (|has| S |IntegralDomain|)
                         (==
                          (|factorAndSplit| |eq|)
                          (|;|
                           (=> (|has| S (|:| |factor| (-> S (|Factored| S))))
                            (|;|
                             (|:=| |eq0| (|rightZero| |eq|))
                             (COLLECT
                              (IN |rcf| (|factors| (|factor| (|lhs| |eq0|))))
                              (|construct|
                               (|equation| (|,| (|rcf| |factor|) 0))))))
                           (|construct| |eq|)))
                         NIL))
                       (==
                        (= (|:| |l| S) (|:| |r| S))
                        (|construct| (|,| |l| |r|))))
                      (==
                       (|equation| (|,| |l| |r|))
                       (|construct| (|,| |l| |r|))))
                     (== (|lhs| |eqn|) (|eqn| |lhs|)))
                    (== (|rhs| |eqn|) (|eqn| |rhs|)))
                   (== 
                    (|swap| |eqn|)
                    (|construct| (|,| (|rhs| |eqn|) (|lhs| |eqn|)))))
                  (==
                   (|map| (|,| |fn| |eqn|))
                   (|equation|
                    (|,| (|fn| (|eqn| |lhs|)) (|fn| (|eqn| |rhs|))))))
                 (|if| (|has| S (|InnerEvalable| (|,| |Symbol| S)))
                  (|;|
                   (|;|
                    (|;|
                     (|;|
                      (|;| (|:| |s| |Symbol|) (|:| |ls| (|List| |Symbol|)))
                      (|:| |x| S))
                     (|:| |lx| (|List| S)))
                    (== 
                     (|eval| (|,| (|,| |eqn| |s|) |x|))
                     (= 
                      (|eval| (|,| (|,| (|eqn| |lhs|) |s|) |x|))
                      (|eval| (|,| (|,| (|eqn| |rhs|) |s|) |x|)))))
                   (==
                    (|eval| (|,| (|,| |eqn| |ls|) |lx|))
                    (=
                     (|eval| (|,| (|,| (|eqn| |lhs|) |ls|) |lx|))
                     (|eval| (|,| (|,| (|eqn| |rhs|) |ls|) |lx|)))))
                  NIL))
                (|if| (|has| S (|Evalable| S))
                 (|;|
                  (==
                   (|:| (|eval| (|,| (|:| |eqn1| $) (|:| |eqn2| $))) $)
                   (=
                    (|eval| 
                     (|,| (|eqn1| |lhs|) (|pretend| |eqn2| (|Equation| S))))
                    (|eval| 
                     (|,| (|eqn1| |rhs|) (|pretend| |eqn2| (|Equation| S))))))
                  (==
                   (|:| 
                    (|eval| (|,| (|:| |eqn1| $) (|:| |leqn2| (|List| $)))) $)
                   (=
                    (|eval|
                     (|,| 
                      (|eqn1| |lhs|)
                      (|pretend| |leqn2| (|List| (|Equation| S)))))
                    (|eval| 
                     (|,|
                      (|eqn1| |rhs|)
                      (|pretend| |leqn2| (|List| (|Equation| S))))))))
                 NIL))
               (|if| (|has| S |SetCategory|)
                (|;|
                 (|;|
                  (==
                   (= |eq1| |eq2|)
                   (|and|
                    (@ (= (|eq1| |lhs|) (|eq2| |lhs|)) |Boolean|)
                    (@ (= (|eq1| |rhs|) (|eq2| |rhs|)) |Boolean|)))
                  (==
                   (|:| (|coerce| (|:| |eqn| $)) |Ex|)
                   (= (|::| (|eqn| |lhs|) |Ex|) (|::| (|eqn| |rhs|) |Ex|))))
                 (==
                  (|:| (|coerce| (|:| |eqn| $)) |Boolean|)
                  (= (|eqn| |lhs|) (|eqn| |rhs|))))
                NIL))
              (|if| (|has| S |AbelianSemiGroup|)
               (|;|
                (|;|
                 (==
                  (+ |eq1| |eq2|)
                  (= 
                   (+ (|eq1| |lhs|) (|eq2| |lhs|))
                   (+ (|eq1| |rhs|) (|eq2| |rhs|))))
                 (== (+ |s| |eq2|) (+ (|construct| (|,| |s| |s|)) |eq2|)))
                (== (+ |eq1| |s|) (+ |eq1| (|construct| (|,| |s| |s|)))))
               NIL))
             (|if| (|has| S |AbelianGroup|)
              (|;|
               (|;|
                (|;|
                 (|;|
                  (|;|
                   (|;|
                    (== (- |eq|) (= (- (|lhs| |eq|)) (- (|rhs| |eq|))))
                    (== (- |s| |eq2|) (- (|construct| (|,| |s| |s|)) |eq2|)))
                   (== (- |eq1| |s|) (- |eq1| (|construct| (|,| |s| |s|)))))
                  (== (|leftZero| |eq|) (= 0 (- (|rhs| |eq|) (|lhs| |eq|)))))
                 (== (|rightZero| |eq|) (= (- (|lhs| |eq|) (|rhs| |eq|)) 0)))
                (== 0 (|equation| (|,| (|elt| S 0) (|elt| S 0)))))
               (==
                (- |eq1| |eq2|)
                (=
                 (- (|eq1| |lhs|) (|eq2| |lhs|))
                 (- (|eq1| |rhs|) (|eq2| |rhs|)))))
              NIL))
            (|if| (|has| S |SemiGroup|)
             (|;|
              (|;|
               (|;|
                (==
                 (* (|:| |eq1| $) (|:| |eq2| $))
                 (=
                  (* (|eq1| |lhs|) (|eq2| |lhs|))
                  (* (|eq1| |rhs|) (|eq2| |rhs|))))
                (==
                 (* (|:| |l| S) (|:| |eqn| $))
                 (= (* |l| (|eqn| |lhs|)) (* |l| (|eqn| |rhs|)))))
               (==
                (* (|:| |l| S) (|:| |eqn| $))
                (= (* |l| (|eqn| |lhs|)) (* |l| (|eqn| |rhs|)))))
              (==
               (* (|:| |eqn| $) (|:| |l| S))
               (= (* (|eqn| |lhs|) |l|) (* (|eqn| |rhs|) |l|))))
             NIL))
           (|if| (|has| S |Monoid|)
            (|;|
             (|;|
              (|;|
               (== 1 (|equation| (|,| (|elt| S 1) (|elt| S 1))))
               (==
                (|recip| |eq|)
                (|;|
                 (|;|
                  (=> (|case| (|:=| |lh| (|recip| (|lhs| |eq|))) "failed")
                      "failed")
                  (=> (|case| (|:=| |rh| (|recip| (|rhs| |eq|))) "failed")
                      "failed"))
                 (|construct| (|,| (|::| |lh| S) (|::| |rh| S))))))
              (==
               (|leftOne| |eq|)
               (|;|
                (=> (|case| (|:=| |re| (|recip| (|lhs| |eq|))) "failed") 
                    "failed")
                (= 1 (* (|rhs| |eq|) |re|)))))
             (==
              (|rightOne| |eq|)
              (|;|
               (=> (|case| (|:=| |re| (|recip| (|rhs| |eq|))) "failed")
                   "failed")
               (= (* (|lhs| |eq|) |re|) 1))))
            NIL))
          (|if| (|has| S |Group|)
           (|;|
            (|;|
             (==
              (|inv| |eq|)
              (|construct| (|,| (|inv| (|lhs| |eq|)) (|inv| (|rhs| |eq|)))))
             (== (|leftOne| |eq|) (= 1 (* (|rhs| |eq|) (|inv| (|rhs| |eq|))))))
            (== (|rightOne| |eq|) (= (* (|lhs| |eq|) (|inv| (|rhs| |eq|))) 1)))
           NIL))
         (|if| (|has| S |Ring|)
          (|;|
           (==
            (|characteristic| (|@Tuple|))
            ((|elt| S |characteristic|) (|@Tuple|)))
           (== (* (|:| |i| |Integer|) (|:| |eq| $)) (* (|::| |i| S) |eq|)))
          NIL))
        (|if| (|has| S |IntegralDomain|)
         (==
          (|factorAndSplit| |eq|)
          (|;|
           (|;|
            (=>
             (|has| S (|:| |factor| (-> S (|Factored| S))))
             (|;|
              (|:=| |eq0| (|rightZero| |eq|))
              (COLLECT
               (IN |rcf| (|factors| (|factor| (|lhs| |eq0|))))
               (|construct| (|equation| (|,| (|rcf| |factor|) 0))))))
            (=>
             (|has| S (|Polynomial| |Integer|))
             (|;|
              (|;|
               (|;|
                (|:=| |eq0| (|rightZero| |eq|))
                (==> MF
                 (|MultivariateFactorize|
                  (|,|
                   (|,| (|,| |Symbol| (|IndexedExponents| |Symbol|)) |Integer|)
                  (|Polynomial| |Integer|)))))
               (|:=|
                (|:| |p| (|Polynomial| |Integer|))
                (|pretend| (|lhs| |eq0|) (|Polynomial| |Integer|))))
              (COLLECT
               (IN |rcf| (|factors| ((|elt| MF |factor|) |p|)))
               (|construct|
                (|equation| (|,| (|pretend| (|rcf| |factor|) S) 0)))))))
           (|construct| |eq|)))
         NIL))
       (|if| (|has| S (|PartialDifferentialRing| |Symbol|))
        (==
         (|:| (|differentiate| (|,| (|:| |eq| $) (|:| |sym| |Symbol|))) $)
         (|construct|
          (|,|
           (|differentiate| (|,| (|lhs| |eq|) |sym|))
           (|differentiate| (|,| (|rhs| |eq|) |sym|)))))
        NIL))
      (|if| (|has| S |Field|)
       (|;|
        (|;|
         (== (|dimension| (|@Tuple|)) (|::| 2 |CardinalNumber|))
         (==
          (/ (|:| |eq1| $) (|:| |eq2| $))
          (= (/ (|eq1| |lhs|) (|eq2| |lhs|)) (/ (|eq1| |rhs|) (|eq2| |rhs|)))))
        (==
         (|inv| |eq|)
         (|construct| (|,| (|inv| (|lhs| |eq|)) (|inv| (|rhs| |eq|))))))
       NIL))
     (|if| (|has| S |ExpressionSpace|)
      (==
       (|subst| (|,| |eq1| |eq2|))
       (|;|
        (|:=| |eq3| (|pretend| |eq2| (|Equation| S)))
        (|construct|
         (|,|
          (|subst| (|,| (|lhs| |eq1|) |eq3|))
          (|subst| (|,| (|rhs| |eq1|) |eq3|))))))
      NIL)))))))

\end{verbatim}

\defun{spad}{spad}
\catches{spad}{spad-reader}
\calls{spad}{addBinding}
\calls{spad}{makeInitialModemapFrame}
\calls{spad}{init-boot/spad-reader}
\calls{spad}{initialize-preparse}
\calls{spad}{preparse}
\calls{spad}{PARSE-NewExpr}
\calls{spad}{pop-stack-1}
\calls{spad}{s-process}
\calls{spad}{ioclear}
\calls{spad}{shut}
\usesdollar{spad}{noSubsumption}
\usesdollar{spad}{InteractiveFrame}
\usesdollar{spad}{InitialDomainsInScope}
\usesdollar{spad}{InteractiveMode}
\uses{spad}{line}
\uses{spad}{echo-meta}
\uses{spad}{/editfile}
\uses{spad}{*comp370-apply*}
\uses{spad}{*eof*}
\uses{spad}{file-closed}
\uses{spad}{xcape}
\catches{spad}{spad-reader}
<<defun spad>>=
(defun spad (&optional (*spad-input-file* nil) (*spad-output-file* nil)
             &aux (*comp370-apply* #'print-defun)
                  (*fileactq-apply* #'print-defun)
                 ($spad t) ($boot nil) (xcape #\_) (optionlist nil) (*eof* nil)
                 (file-closed nil) (/editfile *spad-input-file*)
                (|$noSubsumption| |$noSubsumption|) in-stream out-stream)
  (declare (special echo-meta /editfile *comp370-apply* *eof*
                    file-closed xcape |$noSubsumption| |$InteractiveFrame|
                    |$InteractiveMode| |$InitialDomainsInScope|))
  ;; only rebind |$InteractiveFrame| if compiling
  (progv (if (not |$InteractiveMode|) '(|$InteractiveFrame|))
         (if (not |$InteractiveMode|)
             (list (|addBinding| '|$DomainsInScope|
                    `((fluid . |true|)
                      (|special| . ,(copy-tree |$InitialDomainsInScope|)))
                   (|addBinding| '|$Information| nil
                      (|makeInitialModemapFrame|)))))
  (init-boot/spad-reader)
  (unwind-protect
    (progn
      (setq in-stream (if *spad-input-file*
                        (open *spad-input-file* :direction :input)
                         *standard-input*))
      (initialize-preparse in-stream)
      (setq out-stream (if *spad-output-file*
                        (open *spad-output-file* :direction :output)
                         *standard-output*))
      (when *spad-output-file*
         (format out-stream "~&;;; -*- Mode:Lisp; Package:Boot  -*-~%~%")
         (print-package "BOOT"))
      (setq curoutstream out-stream)
      (loop
       (if (or *eof* file-closed) (return nil))
       (catch 'spad_reader
         (if (setq boot-line-stack (preparse in-stream))
             (let ((line (cdar boot-line-stack)))
               (declare (special line))
               (|PARSE-NewExpr|)
               (let ((parseout (pop-stack-1)) )
                 (when parseout
                       (let ((*standard-output* out-stream))
                         (s-process parseout))
                       (format out-stream "~&")))
               )))
      (ioclear in-stream out-stream)))
    (if *spad-input-file* (shut in-stream))
    (if *spad-output-file* (shut out-stream)))
  t))

@

\defun{s-process}{Interpreter interface to the compiler}
\calls{s-process}{curstrm}
\calls{s-process}{def-rename}
\calls{s-process}{new2OldLisp}
\calls{s-process}{parseTransform}
\calls{s-process}{postTransform}
\calls{s-process}{displayPreCompilationErrors}
\calls{s-process}{prettyprint}
\calls{s-process}{processInteractive}
\calls{s-process}{compTopLevel}
\calls{s-process}{def-process}
\calls{s-process}{displaySemanticErrors}
\calls{s-process}{terpri}
\calls{s-process}{get-internal-run-time}
\usesdollar{s-process}{Index}
\usesdollar{s-process}{macroassoc}
\usesdollar{s-process}{newspad}
\usesdollar{s-process}{PolyMode}
\usesdollar{s-process}{EmptyMode}
\usesdollar{s-process}{compUniquelyIfTrue}
\usesdollar{s-process}{currentFunction}
\usesdollar{s-process}{postStack}
\usesdollar{s-process}{topOp}
\usesdollar{s-process}{semanticErrorStack}
\usesdollar{s-process}{warningStack}
\usesdollar{s-process}{exitMode}
\usesdollar{s-process}{exitModeStack}
\usesdollar{s-process}{returnMode}
\usesdollar{s-process}{leaveMode}
\usesdollar{s-process}{leaveLevelStack}
\usesdollar{s-process}{top-level}
\usesdollar{s-process}{insideFunctorIfTrue}
\usesdollar{s-process}{insideExpressionIfTrue}
\usesdollar{s-process}{insideCoerceInteractiveHardIfTrue}
\usesdollar{s-process}{insideWhereIfTrue}
\usesdollar{s-process}{insideCategoryIfTrue}
\usesdollar{s-process}{insideCapsuleFunctionIfTrue}
\usesdollar{s-process}{form}
\usesdollar{s-process}{DomainFrame}
\usesdollar{s-process}{e}
\usesdollar{s-process}{EmptyEnvironment}
\usesdollar{s-process}{genFVar}
\usesdollar{s-process}{genSDVar}
\usesdollar{s-process}{VariableCount}
\usesdollar{s-process}{previousTime}
\usesdollar{s-process}{LocalFrame}
\usesdollar{s-process}{Translation}
\uses{s-process}{curoutstream}
<<defun s-process>>=
(defun s-process (x)
 (prog ((|$Index| 0)
        ($macroassoc ())
        ($newspad t)
        (|$PolyMode| |$EmptyMode|)
        (|$compUniquelyIfTrue| nil)
        |$currentFunction|
        (|$postStack| nil)
        |$topOp|
        (|$semanticErrorStack| ())
        (|$warningStack| ())
        (|$exitMode| |$EmptyMode|)
        (|$exitModeStack| ())
        (|$returnMode| |$EmptyMode|)
        (|$leaveMode| |$EmptyMode|)
        (|$leaveLevelStack| ())
        $top_level |$insideFunctorIfTrue| |$insideExpressionIfTrue|
        |$insideCoerceInteractiveHardIfTrue| |$insideWhereIfTrue|
        |$insideCategoryIfTrue| |$insideCapsuleFunctionIfTrue| |$form|
        (|$DomainFrame| '((NIL)))
        (|$e| |$EmptyEnvironment|)
        (|$genFVar| 0)
        (|$genSDVar| 0)
        (|$VariableCount| 0)
        (|$previousTime| (get-internal-run-time))
        (|$LocalFrame| '((NIL)))
        (curstrm curoutstream) |$s| |$x| |$m| u)
  (declare (special |$Index| $macroassoc $newspad |$PolyMode| |$EmptyMode|
            |$compUniquelyIfTrue| |$currentFunction| |$postStack| |$topOp|
            |$semanticErrorStack| |$warningStack| |$exitMode| |$exitModeStack|
            |$returnMode| |$leaveMode| |$leaveLevelStack| $top_level 
            |$insideFunctorIfTrue| |$insideExpressionIfTrue|
            |$insideCoerceInteractiveHardIfTrue| |$insideWhereIfTrue|
            |$insideCategoryIfTrue| |$insideCapsuleFunctionIfTrue| |$form|
            |$DomainFrame| |$e| |$EmptyEnvironment| |$genFVar| |$genSDVar| 
            |$VariableCount| |$previousTime| |$LocalFrame|
            curstrm |$s| |$x| |$m| curoutstream $traceflag |$Translation|))
   (setq $traceflag t)
   (if (not x) (return nil))
   (if $boot
     (setq x (def-rename (|new2OldLisp| x)))
     (setq x (|parseTransform| (|postTransform| x))))
   (when |$TranslateOnly| (return (setq |$Translation| x)))
   (when |$postStack| (|displayPreCompilationErrors|) (return nil))
   (when |$PrintOnly|
        (format t "~S   =====>~%" |$currentLine|)
        (return (prettyprint x)))
   (if (not $boot)
    (if |$InteractiveMode|
      (|processInteractive| x nil)
      (when (setq u (|compTopLevel| x |$EmptyMode| |$InteractiveFrame|))
        (setq |$InteractiveFrame| (third u))))
    (def-process x))
   (when |$semanticErrorStack| (|displaySemanticErrors|))
   (terpri)))

@

\defun{compTopLevel}{compTopLevel}
\calls{compTopLevel}{newComp}
\calls{compTopLevel}{compOrCroak}
\usesdollar{compTopLevel}{NRTderivedTargetIfTrue}
\usesdollar{compTopLevel}{killOptimizeIfTrue}
\usesdollar{compTopLevel}{forceAdd}
\usesdollar{compTopLevel}{compTimeSum}
\usesdollar{compTopLevel}{resolveTimeSum}
\usesdollar{compTopLevel}{packagesUsed}
\usesdollar{compTopLevel}{envHashTable}
<<defun compTopLevel>>=
(defun |compTopLevel| (x m e)
 (let (|$NRTderivedTargetIfTrue| |$killOptimizeIfTrue| |$forceAdd|
       |$compTimeSum| |$resolveTimeSum| |$packagesUsed| |$envHashTable|
        t1 t2 t3 val mode)
 (declare (special |$NRTderivedTargetIfTrue| |$killOptimizeIfTrue|
                   |$forceAdd| |$compTimeSum| |$resolveTimeSum|
                   |$packagesUsed| |$envHashTable| ))
   (setq |$NRTderivedTargetIfTrue| nil)
   (setq |$killOptimizeIfTrue| nil)
   (setq |$forceAdd| nil)
   (setq |$compTimeSum| 0)
   (setq |$resolveTimeSum| 0)
   (setq |$packagesUsed| NIL)
   (setq |$envHashTable| (make-hashtable 'equal))
   (dolist (u (car (car e)))
    (dolist (v (cdr u))
     (hput |$envHashTable| (cons (car u) (cons (car v) nil)) t)))
   (cond
    ((or (and (pairp x) (eq (qcar x) 'def))
         (and (pairp x) (eq (qcar x) '|where|)
              (progn
                (setq t1 (qcdr x))
                (and (pairp t1)
                (progn
                 (setq t2 (qcar t1))
                 (and (pairp t2) (eq (qcar t2) 'def)))))))
      (setq t3 (|compOrCroak| x m e))
      (setq val (car t3))
      (setq mode (second t3))
      (cons val (cons mode (cons e nil))))
    (t (|compOrCroak| x m e)))))

@
Given:
\begin{verbatim}
CohenCategory(): Category == SetCategory with

  kind:(CExpr)->Boolean
  operand:(CExpr,Integer)->CExpr
  numberOfOperand:(CExpr)->Integer
  construct:(CExpr,CExpr)->CExpr

\end{verbatim}
the resulting call looks like:
\begin{verbatim}
 (|compOrCroak|
       (DEF (|CohenCategory|)
        ((|Category|))
        (NIL)
        (|Join|
         (|SetCategory|)
         (CATEGORY |package|
          (SIGNATURE |kind| ((|Boolean|) |CExpr|))
          (SIGNATURE |operand| (|CExpr| |CExpr| (|Integer|)))
          (SIGNATURE |numberOfOperand| ((|Integer|) |CExpr|))
          (SIGNATURE |construct| (|CExpr| |CExpr| |CExpr|)))))
        |$EmptyMode|
        (((
           (|$DomainsInScope| 
            (FLUID . |true|)
            (|special| |$EmptyMode| |$NoValueMode|))))))
\end{verbatim}

This compiler call expects the first argument {\tt x} 
to be a {\tt DEF} form to compile,
The second argument, {\tt m}, is the mode.
The third argument, {\tt e}, is the environment.

\defun{compOrCroak}{compOrCroak}
\calls{compOrCroak}{compOrCroak1}
<<defun compOrCroak>>=
(defun |compOrCroak| (x m e)
  (|compOrCroak1| x m e nil nil))

@

This results in a call to the inner function with
\begin{verbatim}
(|compOrCroak1|
          (DEF (|CohenCategory|)
           ((|Category|))
           (NIL)
           (|Join|
            (|SetCategory|)
            (CATEGORY |package|
             (SIGNATURE |kind| ((|Boolean|) |CExpr|))
             (SIGNATURE |operand| (|CExpr| |CExpr| (|Integer|)))
             (SIGNATURE |numberOfOperand| ((|Integer|) |CExpr|))
             (SIGNATURE |construct| (|CExpr| |CExpr| |CExpr|)))))
          |$EmptyMode|
          ((((
              |$DomainsInScope|
              (FLUID . |true|)
              (|special| |$EmptyMode| |$NoValueMode|)))))
          NIL 
          NIL 
          |comp|)
\end{verbatim}
The inner function augments the environment with information
from the compiler stack {\tt \$compStack} and
{\tt \$compErrorMessageStack}. Note that these variables are passed
in the argument list so they get preserved on the call stack. The
calling function gets called for every inner form so we use this
implicit stacking to retain the information.

\defun{compOrCroak1}{compOrCroak1}
\calls{compOrCroak1}{comp}
\calls{compOrCroak1}{compOrCroak1,compactify}
\calls{compOrCroak1}{stackSemanticError}
\calls{compOrCroak1}{mkErrorExpr}
\calls{compOrCroak1}{displaySemanticErrors}
\calls{compOrCroak1}{say}
\calls{compOrCroak1}{displayComp}
\calls{compOrCroak1}{userError}
\usesdollar{compOrCroak1}{compStack}
\usesdollar{compOrCroak1}{compErrorMessageStack}
\usesdollar{compOrCroak1}{level}
\usesdollar{compOrCroak1}{s}
\usesdollar{compOrCroak1}{scanIfTrue}
\usesdollar{compOrCroak1}{exitModeStack}
\catches{compOrCroak1}{compOrCroak}
<<defun compOrCroak1>>=
(defun |compOrCroak1| (x m e |$compStack| |$compErrorMessageStack|)
 (declare (special |$compStack| |$compErrorMessageStack|))
 (let (td errorMessage)
  (declare (special |$level| |$s| |$scanIfTrue| |$exitModeStack|))
  (cond
   ((setq td (catch '|compOrCroak| (|comp| x m e))) td)
   (t
     (setq |$compStack| (cons (list x m e |$exitModeStack|) |$compStack|))
     (setq |$s| (|compOrCroak1,compactify| |$compStack|))
     (setq |$level| (|#| |$s|))
     (setq errorMessage
       (if |$compErrorMessageStack|
         (car |$compErrorMessageStack|)
         '|unspecified error|))
     (cond 
      (|$scanIfTrue|
        (|stackSemanticError| errorMessage (|mkErrorExpr| |$level|))
        (list '|failedCompilation| m e ))
      (t
       (|displaySemanticErrors|)
       (say "****** comp fails at level " |$level| " with expression: ******")
       (|displayComp| |$level|)
       (|userError| errorMessage)))))))

@

\defun{comp}{comp}
\calls{comp}{compNoStacking}
\usesdollar{comp}{compStack}
\usesdollar{comp}{exitModeStack}
<<defun comp>>=
(defun |comp| (x m e)
 (let (td)
 (declare (special |$compStack| |$exitModeStack|))
  (if (setq td (|compNoStacking| x m e))
    (setq |$compStack| nil) 
    (push (list x m e |$exitModeStack|) |$compStack|))
  td))

@

\defun{compNoStacking}{compNoStacking}
\verb|$Representation| is bound in compDefineFunctor, set by doIt.
This hack says that when something is undeclared, \$ is
preferred to the underlying representation -- RDJ 9/12/83
\calls{compNoStacking}{comp2}
\calls{compNoStacking}{compNoStacking1}
\usesdollar{compNoStacking}{compStack}
\usesdollar{compNoStacking}{Representation}
\usesdollar{compNoStacking}{EmptyMode}
<<defun compNoStacking>>=
(defun |compNoStacking| (x m e)
 (let (td)
 (declare (special |$compStack| |$Representation| |$EmptyMode|))
  (if (setq td (|comp2| x m e))
    (if (and (equal m |$EmptyMode|) (equal (second td) |$Representation|))
      (list (car td) '$ (third td))
      td)
   (|compNoStacking1| x m e |$compStack|))))

@

\defun{compNoStacking1}{compNoStacking1}
\calls{compNoStacking1}{get}
\calls{compNoStacking1}{comp2}
\usesdollar{compNoStacking1}{compStack}
<<defun compNoStacking1>>=
(defun |compNoStacking1| (x m e |$compStack|)
 (declare (special |$compStack|))
 (let (u td)
  (if (setq u (|get| (if (eq m '$) '|Rep| m) '|value| e))
    (if (setq td (|comp2| x (car u) e))
      (list (car td) m (third td))
      nil)
    nil)))

@

\defun{comp2}{comp2}
\calls{comp2}{comp3}
\calls{comp2}{isDomainForm}
\calls{comp2}{isFunctor}
\calls{comp2}{insert}
\calls{comp2}{opOf}
\calls{comp2}{nequal}
\calls{comp2}{addDomain}
\usesdollar{comp2}{bootStrapMode}
\usesdollar{comp2}{packagesUsed}
\usesdollar{comp2}{lisplib}
<<defun comp2>>=
(defun |comp2| (x m e)
 (let (tmp1)
  (declare (special |$bootStrapMode| |$packagesUsed| $lisplib))
   (when (setq tmp1 (|comp3| x m e))
    (destructuring-bind (y mprime e) tmp1
     (when (and $lisplib (|isDomainForm| x e) (|isFunctor| x))
       (setq |$packagesUsed| (|insert| (list (|opOf| x)) |$packagesUsed|)))
     ; isDomainForm test needed to prevent error while compiling Ring
     ; $bootStrapMode-test necessary for compiling Ring in $bootStrapMode
     (if (and (nequal m mprime)
              (or |$bootStrapMode| (|isDomainForm| mprime e)))
       (list y mprime (|addDomain| mprime e))
       (list y mprime e))))))

@

\defun{comp3}{comp3}
\begin{verbatim}
;comp3(x,m,$e) ==
;  --returns a Triple or %else nil to signalcan't do'
;  $e:= addDomain(m,$e)
;  e:= $e --for debugging purposes
;  m is ["Mapping",:.] => compWithMappingMode(x,m,e)
;  m is ["QUOTE",a] => (x=a => [x,m,$e]; nil)
;  STRINGP m => (atom x => (m=x or m=STRINGIMAGE x => [m,m,e]; nil); nil)
;  ^x or atom x => compAtom(x,m,e)
;  op:= first x
;  getmode(op,e) is ["Mapping",:ml] and (u:= applyMapping(x,m,e,ml)) => u
;  op is ["KAPPA",sig,varlist,body] => compApply(sig,varlist,body,rest x,m,e)
;  op=":" => compColon(x,m,e)
;  op="::" => compCoerce(x,m,e)
;  not ($insideCompTypeOf=true) and stringPrefix?('"TypeOf",PNAME op) =>
;    compTypeOf(x,m,e)
;  t:= compExpression(x,m,e)
;  t is [x',m',e'] and not MEMBER(m',getDomainsInScope e') =>
;    [x',m',addDomain(m',e')]
;  t
\end{verbatim}
\calls{comp3}{addDomain}
\calls{comp3}{compWithMappingMode}
\calls{comp3}{stringimage}
\calls{comp3}{compAtom}
\calls{comp3}{getmode}
\calls{comp3}{applyMapping}
\calls{comp3}{compApply}
\calls{comp3}{compColon}
\calls{comp3}{compCoerce}
\calls{comp3}{stringPrefix?}
\calls{comp3}{pname}
\calls{comp3}{compTypeOf}
\calls{comp3}{compExpression}
\calls{comp3}{member}
\calls{comp3}{getDomainsInScope}
\usesdollar{comp3}{e}
\usesdollar{comp3}{insideCompTypeOf}
<<defun comp3>>=
(defun |comp3| (x m |$e|)
 (declare (special |$e|))
 (let (e a op ml u sig varlist tmp3 body tt xprime tmp1 mprime tmp2 eprime)
 (declare (special |$insideCompTypeOf|))
  (setq |$e| (|addDomain| m |$e|))
  (setq e |$e|)
  (cond
   ((and (pairp m) (eq (qcar m) '|Mapping|)) (|compWithMappingMode| x m e))
   ((and (pairp m) (eq (qcar m) 'quote)
         (progn
          (setq tmp1 (qcdr m))
          (and (pairp tmp1) (eq (qcdr tmp1) nil)
          (progn (setq a (qcar tmp1)) t))))
    (when (equal x a) (list x m |$e|)))
   ((stringp m)
    (when (and (atom x) (or (equal m x) (equal m (stringimage x))))
     (list m m e )))
   ((or (null x) (atom x)) (|compAtom| x m e))
   (t 
    (setq op (car x))
    (cond
     ((and (progn
            (setq tmp1 (|getmode| op e))
            (and (pairp tmp1)
                 (eq (qcar tmp1) '|Mapping|)
                 (progn (setq ml (qcdr tmp1)) t)))
            (setq u (|applyMapping| x m e ml)))
        u)
     ((and (pairp op) (eq (qcar op) 'kappa)
           (progn
            (setq tmp1 (qcdr op))
            (and (pairp tmp1)
                 (progn
                  (setq sig (qcar tmp1))
                   (setq tmp2 (qcdr tmp1))
                   (and (pairp tmp2)
                        (progn
                         (setq varlist (qcar tmp2))
                         (setq tmp3 (qcdr tmp2))
                         (and (pairp tmp3)
                              (eq (qcdr tmp3) nil)
                              (progn
                                (setq body (qcar tmp3))
                                t))))))))
       (|compApply| sig varlist body (cdr x) m e))
     ((eq op '|:|)  (|compColon| x m e))
     ((eq op '|::|) (|compCoerce| x m e))
     ((and (null (eq |$insideCompTypeOf| t))
           (|stringPrefix?| "TypeOf" (pname op)))
       (|compTypeOf| x m e))
      (t
       (setq tt (|compExpression| x m e))
       (cond
        ((and (pairp tt)
              (progn
               (setq xprime (qcar tt))
               (setq tmp1 (qcdr tt))
               (and (pairp tmp1)
                    (progn
                     (setq mprime (qcar tmp1))
                     (setq tmp2 (qcdr tmp1))
                     (and (pairp tmp2)
                          (eq (qcdr tmp2) nil)
                          (progn
                            (setq eprime (qcar tmp2))
                            t)))))
                     (null (|member| mprime (|getDomainsInScope| eprime))))
         (list xprime mprime (|addDomain| mprime eprime)))
        (t tt))))))))

@

\defun{compTypeOf}{compTypeOf}
\calls{compTypeOf}{eqsubstlist}
\calls{compTypeOf}{get}
\calls{compTypeOf}{put}
\calls{compTypeOf}{comp3}
\usesdollar{compTypeOf}{insideCompTypeOf}
\usesdollar{compTypeOf}{FormalMapVariableList}
<<defun compTypeOf>>=
(defun |compTypeOf| (x m e)
 (let (|$insideCompTypeOf| op argl newModemap)
 (declare (special |$insideCompTypeOf| |$FormalMapVariableList|))
  (setq op (car x))
  (setq argl (cdr x))
  (setq |$insideCompTypeOf| t)
  (setq newModemap
    (eqsubstlist argl |$FormalMapVariableList| (|get| op '|modemap| e)))
  (setq e (|put| op '|modemap| newModemap e))
  (|comp3| x m e)))

@

\defun{compColon}{compColon}
\begin{verbatim}
;compColon([":",f,t],m,e) ==
;  $insideExpressionIfTrue=true => compColonInside(f,m,e,t)
;    --if inside an expression, ":" means to convert to m "on faith"
;  $lhsOfColon: local:= f
;  t:=
;    atom t and (t':= ASSOC(t,getDomainsInScope e)) => t'
;    isDomainForm(t,e) and not $insideCategoryIfTrue =>
;      (if not MEMBER(t,getDomainsInScope e) then e:= addDomain(t,e); t)
;    isDomainForm(t,e) or isCategoryForm(t,e) => t
;    t is ["Mapping",m',:r] => t
;    unknownTypeError t
;    t
;  f is ["LISTOF",:l] =>
;    (for x in l repeat T:= [.,.,e]:= compColon([":",x,t],m,e); T)
;  e:=
;    f is [op,:argl] and not (t is ["Mapping",:.]) =>
;      --for MPOLY--replace parameters by formal arguments: RDJ 3/83
;      newTarget:= EQSUBSTLIST(take(#argl,$FormalMapVariableList),
;        [(x is [":",a,m] => a; x) for x in argl],t)
;      signature:=
;        ["Mapping",newTarget,:
;          [(x is [":",a,m] => m;
;              getmode(x,e) or systemErrorHere '"compColonOld") for x in argl]]
;      put(op,"mode",signature,e)
;    put(f,"mode",t,e)
;  if not $bootStrapMode and $insideFunctorIfTrue and
;    makeCategoryForm(t,e) is [catform,e] then
;        e:= put(f,"value",[genSomeVariable(),t,$noEnv],e)
;  ["/throwAway",getmode(f,e),e]
\end{verbatim}
\calls{compColon}{compColonInside}
\calls{compColon}{assoc}
\calls{compColon}{getDomainsInScope}
\calls{compColon}{isDomainForm}
\calls{compColon}{member}
\calls{compColon}{addDomain}
\calls{compColon}{isDomainForm}
\calls{compColon}{isCategoryForm}
\calls{compColon}{unknownTypeError}
\calls{compColon}{compColon}
\calls{compColon}{eqsubstlist}
\calls{compColon}{take}
\calls{compColon}{length}
\calls{compColon}{nreverse0}
\calls{compColon}{getmode}
\calls{compColon}{systemErrorHere}
\calls{compColon}{put}
\calls{compColon}{makeCategoryForm}
\calls{compColon}{genSomeVariable}
\usesdollar{compColon}{lhsOfColon}
\usesdollar{compColon}{noEnv}
\usesdollar{compColon}{insideFunctorIfTrue}
\usesdollar{compColon}{bootStrapMode}
\usesdollar{compColon}{FormalMapVariableList}
\usesdollar{compColon}{insideCategoryIfTrue}
\usesdollar{compColon}{insideExpressionIfTrue}
<<defun compColon>>=
(defun |compColon| (arg0 m e)
  (let (|$lhsOfColon| argf argt tprime mprime r td op argl newTarget a 
        signature tmp2 catform tmp3 g2 g5)
  (declare (special |$lhsOfColon| |$noEnv| |$insideFunctorIfTrue|
                    |$bootStrapMode| |$FormalMapVariableList|
                    |$insideCategoryIfTrue| |$insideExpressionIfTrue|))
    (setq argf (second arg0))
    (setq argt (third arg0))
    (if |$insideExpressionIfTrue|
      (|compColonInside| argf m e argt)
      (progn
        (setq |$lhsOfColon| argf)
        (setq argt
         (cond
          ((and (atom argt)
                (setq tprime (|assoc| argt (|getDomainsInScope| e))))
            tprime)
          ((and (|isDomainForm| argt e) (null |$insideCategoryIfTrue|))
            (unless (|member| argt (|getDomainsInScope| e))
               (setq e (|addDomain| argt e)))
            argt)
          ((or (|isDomainForm| argt e) (|isCategoryForm| argt e))
            argt)
          ((and (pairp argt) (eq (qcar argt) '|Mapping|)
                (progn
                  (setq tmp2 (qcdr argt))
                  (and (pairp tmp2)
                       (progn
                        (setq mprime (qcar tmp2))
                        (setq r (qcdr tmp2))
                        t))))
            argt)
          (t
            (|unknownTypeError| argt)
            argt)))
        (cond
         ((eq (car argf) 'listof)
           (dolist (x (cdr argf) td)
             (setq td (|compColon| (list '|:| x argt) m e))
             (setq e (third td))))
         (t
          (setq e
           (cond
            ((and (pairp argf)
                  (progn
                   (setq op (qcar argf))
                   (setq argl (qcdr argf))
                   t)
                  (null (and (pairp argt) (eq (qcar argt) '|Mapping|))))
             (setq newTarget
              (eqsubstlist (take (|#| argl) |$FormalMapVariableList|)
              (dolist (x argl (nreverse0 g2))
                (setq g2
                 (cons
                  (cond
                   ((and (pairp x) (eq (qcar x) '|:|)
                         (progn
                          (setq tmp2 (qcdr x))
                          (and (pairp tmp2)
                               (progn
                                (setq a (qcar tmp2))
                                (setq tmp3 (qcdr tmp2))
                                (and (pairp tmp3)
                                     (eq (qcdr tmp3) nil)
                                     (progn
                                      (setq m (qcar tmp3))
                                      t))))))
                       a)
                      (t x))
               g2)))
              argt))
             (setq signature
              (cons '|Mapping|
               (cons newTarget
                (dolist (x argl (nreverse0 g5))
                  (setq g5
                   (cons
                    (cond
                     ((and (pairp x) (eq (qcar x) '|:|)
                      (progn
                       (setq tmp2 (qcdr x))
                       (and (pairp tmp2)
                            (progn
                             (setq a (qcar tmp2))
                             (setq tmp3 (qcdr tmp2))
                             (and (pairp tmp3)
                                  (eq (qcdr tmp3) nil)
                                  (progn
                                   (setq m (qcar tmp3))
                                   t))))))
                       m)
                     (t
                      (or (|getmode| x e)
                          (|systemErrorHere| "compColonOld"))))
                     g5))))))
             (|put| op '|mode| signature e))
            (t (|put| argf '|mode| argt e))))
         (cond
           ((and (null |$bootStrapMode|) |$insideFunctorIfTrue|
                 (progn
                  (setq tmp2 (|makeCategoryForm| argt e))
                  (and (pairp tmp2)
                       (progn
                        (setq catform (qcar tmp2))
                        (setq tmp3 (qcdr tmp2))
                        (and (pairp tmp3)
                             (eq (qcdr tmp3) nil)
                             (progn
                               (setq e (qcar tmp3))
                                       t))))))
            (setq e 
             (|put| argf '|value| (list (|genSomeVariable|) argt |$noEnv|)
              e))))
         (list '|/throwAway| (|getmode| argf e) e )))))))

@

\defun{compColonInside}{compColonInside}
\calls{compColonInside}{addDomain}
\calls{compColonInside}{comp}
\calls{compColonInside}{coerce}
\calls{compColonInside}{stackWarning}
\calls{compColonInside}{opOf}
\calls{compColonInside}{stackSemanticError}
\usesdollar{compColonInside}{newCompilerUnionFlag}
\usesdollar{compColonInside}{EmptyMode}
<<defun compColonInside>>=
(defun |compColonInside| (x m e mprime)
 (let (mpp warningMessage td tprime)
 (declare (special |$newCompilerUnionFlag| |$EmptyMode|))
    (setq e (|addDomain| mprime e))
    (when (setq td (|comp| x |$EmptyMode| e))
     (cond
      ((equal (setq mpp (second td)) mprime)
       (setq warningMessage
        (list '|:| mprime '| -- should replace by @|))))
     (setq td (list (car td) mprime (third td)))
     (when (setq tprime (|coerce| td m))
      (cond
       (warningMessage (|stackWarning| warningMessage))
       ((and |$newCompilerUnionFlag| (eq (|opOf| mpp) '|Union|))
        (setq tprime
         (|stackSemanticError|
          (list '|cannot pretend | x '| of mode | mpp '| to mode | mprime )
          nil)))
       (t
        (|stackWarning|
         (list '|:| mprime '| -- should replace by pretend|))))
      tprime))))

@

\defun{compAtom}{compAtom}
\begin{verbatim}
;compAtom(x,m,e) ==
;  T:= compAtomWithModemap(x,m,e,get(x,"modemap",e)) => T
;  x="nil" =>
;    T:=
;      modeIsAggregateOf('List,m,e) is [.,R]=> compList(x,['List,R],e)
;      modeIsAggregateOf('Vector,m,e) is [.,R]=> compVector(x,['Vector,R],e)
;    T => convert(T,m)
;  t:=
;    isSymbol x =>
;      compSymbol(x,m,e) or return nil
;    m = $Expression and primitiveType x => [x,m,e]
;    STRINGP x => [x,x,e]
;    [x,primitiveType x or return nil,e]
;  convert(t,m)
\end{verbatim}
\calls{compAtom}{compAtomWithModemap}
\calls{compAtom}{get}
\calls{compAtom}{modeIsAggregateOf}
\calls{compAtom}{compList}
\calls{compAtom}{compVector}
\calls{compAtom}{convert}
\calls{compAtom}{isSymbol}
\calls{compAtom}{compSymbol}
\calls{compAtom}{primitiveType}
\calls{compAtom}{primitiveType}
\usesdollar{compAtom}{Expression}
<<defun compAtom>>=
(defun |compAtom| (x m e)
 (prog (tmp1 tmp2 r td tt)
  (declare (special |$Expression|))
   (return
   (cond
    ((setq td (|compAtomWithModemap| x m e (|get| x '|modemap| e))) td)
    ((eq x '|nil|)
     (setq td
      (cond
       ((progn
         (setq tmp1 (|modeIsAggregateOf| '|List| m e))
         (and (pairp tmp1)
              (progn
               (setq tmp2 (qcdr tmp1))
               (and (pairp tmp2)
                    (eq (qcdr tmp2) nil)
                    (progn
                      (setq r (qcar tmp2)) t)))))
         (|compList| x (list '|List| r) e))
       ((progn
         (setq tmp1 (|modeIsAggregateOf| '|Vector| m e))
         (and (pairp tmp1)
              (progn
               (setq tmp2 (qcdr tmp1))
               (and (pairp tmp2) (eq (qcdr tmp2) nil)
               (progn
                 (setq r (qcar tmp2)) t)))))
         (|compVector| x (list '|Vector| r) e))))
      (when td (|convert| td m)))
    (t
     (setq tt
      (cond
       ((|isSymbol| x) (or (|compSymbol| x m e) (return nil)))
       ((and (equal m |$Expression|) (|primitiveType| x)) (list x m e ))
       ((stringp x) (list x x e ))
       (t (list x (or (|primitiveType| x) (return nil)) e ))))
     (|convert| tt m))))))

@

\defun{convert}{convert}
\calls{convert}{resolve}
\calls{convert}{coerce}
<<defun convert>>=
(defun |convert| (td m)
 (let (res)
  (when (setq res (|resolve| (second td) m))
   (|coerce| td res))))

@
\defun{primitiveType}{primitiveType}
\usesdollar{primitiveType}{DoubleFloat}
\usesdollar{primitiveType}{NegativeInteger}
\usesdollar{primitiveType}{PositiveInteger}
\usesdollar{primitiveType}{NonNegativeInteger}
\usesdollar{primitiveType}{String}
\usesdollar{primitiveType}{EmptyMode}
<<defun primitiveType>>=
(defun |primitiveType| (x)
  (declare (special |$DoubleFloat| |$NegativeInteger| |$PositiveInteger|
                     |$NonNegativeInteger| |$String| |$EmptyMode|))
  (cond
    ((null x) |$EmptyMode|)
    ((stringp x) |$String|)
    ((integerp x)
     (cond
       ((eql x 0) |$NonNegativeInteger|)
       ((> x 0) |$PositiveInteger|)
       (t |$NegativeInteger|)))
    ((floatp x) |$DoubleFloat|)
    (t nil)))

@
\defun{compSymbol}{compSymbol}
\calls{compSymbol}{getmode}
\calls{compSymbol}{get}
\calls{compSymbol}{NRTgetLocalIndex}
\calls{compSymbol}{member}
\calls{compSymbol}{isFunction}
\calls{compSymbol}{errorRef}
\calls{compSymbol}{stackMessage}
\usesdollar{compSymbol}{Symbol}
\usesdollar{compSymbol}{Expression}
\usesdollar{compSymbol}{FormalMapVariableList}
\usesdollar{compSymbol}{compForModeIfTrue}
\usesdollar{compSymbol}{formalArgList}
\usesdollar{compSymbol}{NoValueMode}
\usesdollar{compSymbol}{functorLocalParameters}
\usesdollar{compSymbol}{Boolean}
\usesdollar{compSymbol}{NoValue}
<<defun compSymbol>>=
(defun |compSymbol| (s m e)
 (let (v mprime mode)
  (declare (special |$Symbol| |$Expression| |$FormalMapVariableList|
                    |$compForModeIfTrue| |$formalArgList| |$NoValueMode|
                    |$functorLocalParameters| |$Boolean| |$NoValue|))
   (cond
     ((eq s '|$NoValue|) (list '|$NoValue| |$NoValueMode| e ))
     ((|isFluid| s)
      (setq mode (|getmode| s e))
      (when mode (list s (|getmode| s e) e)))
     ((eq s '|true|) (list '(quote t) |$Boolean| e ))
     ((eq s '|false|) (list nil |$Boolean| e ))
     ((or (equal s m) (|get| s '|isLiteral| e)) (list (list 'quote s) s e))
     ((setq v (|get| s '|value| e))
      (cond
        ((member s |$functorLocalParameters|)
         ; s will be replaced by an ELT form in beforeCompile
         (|NRTgetLocalIndex| s) 
         (list s (second v) e))
        (t
         ; s has been SETQd
         (list s (second v) e))))
     ((setq mprime (|getmode| s e))
      (cond
        ((and (null (|member| s |$formalArgList|))
              (null (member s |$FormalMapVariableList|))
              (null (|isFunction| s e))
              (null (eq |$compForModeIfTrue| t)))
         (|errorRef| s)))
      (list s mprime e ))
     ((member s |$FormalMapVariableList|)
      (|stackMessage| (list '|no mode found for| s )))
     ((or (equal m |$Expression|) (equal m |$Symbol|))
      (list (list 'quote s) m e ))
     ((null (|isFunction| s e)) (|errorRef| s)))))

@

\defun{compList}{compList}
\begin{verbatim}
;compList(l,m is ["List",mUnder],e) ==
;  null l => [NIL,m,e]
;  Tl:= [[.,mUnder,e]:= comp(x,mUnder,e) or return "failed" for x in l]
;  Tl="failed" => nil
;  T:= [["LIST",:[T.expr for T in Tl]],["List",mUnder],e]
\end{verbatim}
\calls{compList}{comp}
<<defun compList>>=
(defun |compList| (l m e)
 (let (tmp1 tmp2 t0 failed (mUnder (second m)))
  (if (null l)
   (list nil m e)
   (progn
    (setq t0
     (do ((t3 l (cdr t3)) (x nil))
         ((or (atom t3) failed) (unless failed (nreverse0 tmp2)))
       (setq x (car t3))
       (if (setq tmp1 (|comp| x mUnder e))
        (progn
         (setq mUnder (second tmp1))
         (setq e (third tmp1))
         (push tmp1 tmp2))
        (setq failed t))))
    (unless failed
     (cons 
       (cons 'list (loop for texpr in t0 collect (car texpr)))
       (list (list '|List| mUnder) e)))))))

@

\defun{compVector}{compVector}
\begin{verbatim}
;  null l => [$EmptyVector,m,e]
;  Tl:= [[.,mUnder,e]:= comp(x,mUnder,e) or return "failed" for x in l]
;  Tl="failed" => nil
;  [["VECTOR",:[T.expr for T in Tl]],m,e]
\end{verbatim}
\calls{compVector}{comp}
\usesdollar{compVector}{EmptyVector}
<<defun compVector>>=
(defun |compVector| (l m e)
 (let (tmp1 tmp2 t0 failed (mUnder (second m)))
  (declare (special |$EmptyVector|))
   (if (null l)
    (list |$EmptyVector| m e)
    (progn
     (setq t0
      (do ((t3 l (cdr t3)) (x nil))
          ((or (atom t3) failed) (unless failed (nreverse0 tmp2)))
        (setq x (car t3))
        (if (setq tmp1 (|comp| x mUnder e))
          (progn
           (setq mUnder (second tmp1))
           (setq e (third tmp1))
           (push tmp1 tmp2))
          (setq failed t))))
     (unless failed      
      (list (cons 'vector (loop for texpr in t0 collect (car texpr))) m e))))))

@
\defun{compExpression}{compExpression}
\calls{compExpression}{getl}
\calls{compExpression}{compForm}
\usesdollar{compExpression}{insideExpressionIfTrue}
<<defun compExpression>>=
(defun |compExpression| (x m e)
 (let (|$insideExpressionIfTrue| fn)
 (declare (special |$insideExpressionIfTrue|))
  (setq |$insideExpressionIfTrue| t)
  (if (and (atom (car x)) (setq fn (getl (car x) 'special)))
    (funcall fn x m e)
    (|compForm| x m e))))

@

\defun{compForm}{compForm}
\calls{compForm}{compForm1}
\calls{compForm}{compArgumentsAndTryAgain}
\calls{compForm}{stackMessageIfNone}
<<defun compForm>>=
(defun |compForm| (form m e)
 (cond
  ((|compForm1| form m e))
  ((|compArgumentsAndTryAgain| form m e))
  (t (|stackMessageIfNone| (list '|cannot compile| '|%b| form '|%d| )))))

@

\defun{compForm1}{compForm1}
\calls{compForm1}{length}
\calls{compForm1}{outputComp}
\calls{compForm1}{compOrCroak}
\calls{compForm1}{compExpressionList}
\calls{compForm1}{coerceable}
\calls{compForm1}{comp}
\calls{compForm1}{coerce}
\calls{compForm1}{compForm2}
\calls{compForm1}{augModemapsFromDomain1}
\calls{compForm1}{getFormModemaps}
\calls{compForm1}{nreverse0}
\calls{compForm1}{addDomain}
\calls{compForm1}{compToApply}
\usesdollar{compForm1}{NumberOfArgsIfInteger}
\usesdollar{compForm1}{Expression}
\usesdollar{compForm1}{EmptyMode}
<<defun compForm1>>=
(defun |compForm1| (form m e)
 (let (|$NumberOfArgsIfInteger| op argl domain tmp1 opprime ans mmList td 
       tmp2 tmp3 tmp4 tmp5 tmp6 tmp7)
 (declare (special |$NumberOfArgsIfInteger| |$Expression| |$EmptyMode|))
    (setq op (car form))
    (setq argl (cdr form))
    (setq |$NumberOfArgsIfInteger| (|#| argl))
    (cond
     ((eq op '|error|)
      (list
       (cons op
        (dolist (x argl (nreverse0 tmp4))
          (setq tmp2 (|outputComp| x e))
          (setq e (third tmp2))
          (push (car tmp2) tmp4)))
       m e))
     ((and (pairp op) (eq (qcar op) '|elt|)
           (progn
            (setq tmp3 (qcdr op))
            (and (pairp tmp3)
                 (progn
                  (setq domain (qcar tmp3))
                  (setq tmp1 (qcdr tmp3))
                  (and (pairp tmp1)
                       (eq (qcdr tmp1) nil)
                       (progn
                        (setq opprime (qcar tmp1))
                        t))))))
       (cond
        ((eq domain '|Lisp|)
          (list 
           (cons opprime
            (dolist (x argl (nreverse tmp7))
             (setq tmp2 (|compOrCroak| x |$EmptyMode| e))
             (setq e (third tmp2))
             (push (car tmp2) tmp7)))
           m e))
        ((and (equal domain |$Expression|) (eq opprime '|construct|))
          (|compExpressionList| argl m e))
        ((and (eq opprime 'collect) (|coerceable| domain m e))
          (when (setq td (|comp| (cons opprime argl) domain e))
           (|coerce| td m)))
        ((and (pairp domain) (eq (qcar domain) '|Mapping|)
              (setq ans
               (|compForm2| (cons opprime argl) m
                (setq e (|augModemapsFromDomain1| domain domain e))
                (dolist (x (|getFormModemaps| (cons opprime argl) e)
                                          (nreverse0 tmp6))
                 (when
                  (and (pairp x)
                       (and (pairp (qcar x)) (equal (qcar (qcar x)) domain)))
                    (push x tmp6))))))
          ans)
        ((setq ans
          (|compForm2| (cons opprime argl) m
           (setq e (|addDomain| domain e))
           (dolist (x (|getFormModemaps| (cons opprime argl) e)
                   (nreverse0 tmp5))
             (when
               (and (pairp x)
                    (and (pairp (qcar x)) (equal (qcar (qcar x)) domain)))
                (push x tmp5)))))
          ans)
        ((and (eq opprime '|construct|) (|coerceable| domain m e))
          (when (setq td (|comp| (cons opprime argl) domain e))
           (|coerce| td m)))
        (t nil)))
     (t
      (setq e (|addDomain| m e))
      (cond
       ((and (setq mmList (|getFormModemaps| form e))
             (setq td (|compForm2| form m e mmList)))
         td)
       (t
         (|compToApply| op argl m e)))))))

@

\defun{compForm2}{compForm2}
\calls{compForm2}{take}
\calls{compForm2}{length}
\calls{compForm2}{nreverse0}
\calls{compForm2}{sublis}
\calls{compForm2}{assoc}
\calls{compForm2}{PredImplies}
\calls{compForm2}{isSimple}
\calls{compForm2}{compUniquely}
\calls{compForm2}{compFormPartiallyBottomUp}
\calls{compForm2}{compForm3}
\usesdollar{compForm2}{EmptyMode}
\usesdollar{compForm2}{TriangleVariableList}
<<defun compForm2>>=
(defun |compForm2| (form m e modemapList)
 (let (op argl sargl aList dc cond nsig v ncond deleteList newList td tl
       partialModeList tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7)
 (declare (special |$EmptyMode| |$TriangleVariableList|))
  (setq op (car form))
  (setq argl (cdr form))
  (setq sargl (take (|#| argl) |$TriangleVariableList|))
  (setq aList (mapcar #'(lambda (x y) (cons x y)) sargl argl))
  (setq modemaplist (sublis aList modemapList))
  ; now delete any modemaps that are subsumed by something else, provided 
  ; the conditions are right (i.e. subsumer true whenever subsumee true)
  (dolist (u modemapList)
   (cond
    ((and (pairp u)
          (progn
           (setq tmp6 (qcar u))
           (and (pairp tmp6) (progn (setq dc (qcar tmp6)) t)))
          (progn
           (setq tmp7 (qcdr u))
           (and (pairp tmp7) (eq (qcdr tmp7) nil)
                (progn
                 (setq tmp1 (qcar tmp7))
                 (and (pairp tmp1)
                      (progn
                       (setq cond (qcar tmp1))
                       (setq tmp2 (qcdr tmp1))
                       (and (pairp tmp2) (eq (qcdr tmp2) nil)
                            (progn
                             (setq tmp3 (qcar tmp2))
                             (and (pairp tmp3) (eq (qcar tmp3) '|Subsumed|)
                                  (progn
                                   (setq tmp4 (qcdr tmp3))
                                   (and (pairp tmp4)
                                        (progn
                                         (setq tmp5 (qcdr tmp4))
                                         (and (pairp tmp5) 
                                              (eq (qcdr tmp5) nil)
                                              (progn
                                               (setq nsig (qcar tmp5))
                                               t)))))))))))))
          (setq v (|assoc| (cons dc nsig) modemapList))
          (pairp v)
          (progn
           (setq tmp6 (qcdr v))
           (and (pairp tmp6) (eq (qcdr tmp6) nil)
                (progn
                 (setq tmp7 (qcar tmp6))
                 (and (pairp tmp7)
                      (progn
                       (setq ncond (qcar tmp7))
                       t))))))
      (setq deleteList (cons u deleteList))
      (unless  (|PredImplies| ncond cond)
         (setq newList (push `(,(car u) (,cond (elt ,dc nil))) newList))))))
  (when deleteList
   (setq modemapList 
    (remove-if #'(lambda (x) (member x deletelist)) modemapList)))
  ; it is important that subsumed ops (newList) be considered last
  (when newList (setq modemapList (append modemapList newList)))
  (setq tl
   (loop for x in argl 
         while (and (|isSimple| x)
                    (setq td (|compUniquely| x |$EmptyMode| e)))
         collect td
         do (setq e (third td))))
  (cond
   ((some #'identity tl)
     (setq partialModeList (loop for x in tl collect (when x (second x))))
     (or (|compFormPartiallyBottomUp| form m e modemapList partialModeList)
         (|compForm3| form m e modemapList)))
   (t (|compForm3| form m e modemapList)))))

@

\defun{compArgumentsAndTryAgain}{compArgumentsAndTryAgain}
\calls{compArgumentsAndTryAgain}{comp}
\calls{compArgumentsAndTryAgain}{compForm1}
\usesdollar{compArgumentsAndTryAgain}{EmptyMode}
<<defun compArgumentsAndTryAgain>>=
(defun |compArgumentsAndTryAgain| (form m e)
 (let (argl tmp1 a tmp2 tmp3 u)
 (declare (special |$EmptyMode|))
  (setq argl (cdr form))
  (cond
   ((and (pairp form) (eq (qcar form) '|elt|)
         (progn
           (setq tmp1 (qcdr form))
           (and (pairp tmp1)
                (progn
                 (setq a (qcar tmp1))
                 (setq tmp2 (qcdr tmp1))
                 (and (pairp tmp2) (eq (qcdr tmp2) nil))))))
    (when (setq tmp3 (|comp| a |$EmptyMode| e))
      (setq e (third tmp3))
      (|compForm1| form m e)))
   (t
     (setq u
      (dolist (x argl)
       (setq tmp3 (or (|comp| x |$EmptyMode| e) (return '|failed|)))
       (setq e (third tmp3))
       tmp3))
     (unless (eq u '|failed|)
       (|compForm1| form m e))))))

@
\defun{compWithMappingMode}{compWithMappingMode}
\calls{compWithMappingMode}{compWithMappingMode1}
\usesdollar{compWithMappingMode}{formalArgList}
<<defun compWithMappingMode>>=
(defun |compWithMappingMode| (x m oldE)
  (declare (special |$formalArgList|))
  (|compWithMappingMode1| x m oldE |$formalArgList|))

@

\defun{compWithMappingMode1}{compWithMappingMode1}
\begin{verbatim}
;compWithMappingMode1(x,m is ["Mapping",m',:sl],oldE,$formalArgList) ==
;  $killOptimizeIfTrue: local:= true
;  e:= oldE
;  isFunctor x =>
;    if get(x,"modemap",$CategoryFrame) is [[[.,target,:argModeList],.],:.] and
;     (and/[extendsCategoryForm("$",s,mode) for mode in argModeList for s in sl]
;       ) and extendsCategoryForm("$",target,m') then return [x,m,e]
;  if STRINGP x then x:= INTERN x
;  ress:=nil
;  old_style:=true
;  if x is ["+->",vl,nx] then
;    old_style:=false
;    vl is [":",:.] =>
;      ress:=compLambda(x,m,oldE)
;      ress
;    vl:=
;      vl is ["Tuple",:vl1] => vl1
;      vl
;    vl:=
;      SYMBOLP(vl) => [vl]
;      LISTP(vl) and (and/[SYMBOLP(v) for v in vl]) => vl
;      stackAndThrow ["bad +-> arguments:",vl]
;    $formatArgList:=[:vl,:$formalArgList]
;    x:=nx
;  else
;    vl:=take(#sl,$FormalMapVariableList)
;  ress => ress
;  for m in sl for v in vl repeat
;    [.,.,e]:= compMakeDeclaration([":",v,m],$EmptyMode,e)
;  old_style and not null vl and not hasFormalMapVariable(x, vl) => return
;    [u,.,.] := comp([x,:vl],m',e) or return nil
;    extractCodeAndConstructTriple(u, m, oldE)
;  null vl and (t := comp([x], m', e)) => return
;    [u,.,.] := t
;    extractCodeAndConstructTriple(u, m, oldE)
;  [u,.,.]:= comp(x,m',e) or return nil
;  uu:=optimizeFunctionDef [nil,['LAMBDA,vl,u]]
;  --  At this point, we have a function that we would like to pass.
;  --  Unfortunately, it makes various free variable references outside
;  --  itself.  So we build a mini-vector that contains them all, and
;  --  pass this as the environment to our inner function.
;  $FUNNAME :local := nil
;  $FUNNAME__TAIL :local := [nil]
;  expandedFunction:=COMP_-TRAN CADR uu
;  frees:=freelist(expandedFunction,vl,nil,e)
;    where freelist(u,bound,free,e) ==
;      atom u =>
;        not IDENTP u => free
;        MEMQ(u,bound) => free
;        v:=ASSQ(u,free) =>
;          RPLACD(v,1+CDR v)
;          free
;        not getmode(u, e) => free
;        [[u,:1],:free]
;      op:=CAR u
;      MEMQ(op, '(QUOTE GO function)) => free
;      EQ(op,'LAMBDA) =>
;        bound:=UNIONQ(bound,CADR u)
;        for v in CDDR u repeat
;          free:=freelist(v,bound,free,e)
;        free
;      EQ(op,'PROG) =>
;        bound:=UNIONQ(bound,CADR u)
;        for v in CDDR u | NOT ATOM v repeat
;          free:=freelist(v,bound,free,e)
;        free
;      EQ(op,'SEQ) =>
;        for v in CDR u | NOT ATOM v repeat
;          free:=freelist(v,bound,free,e)
;        free
;      EQ(op,'COND) =>
;        for v in CDR u repeat
;          for vv in v repeat
;            free:=freelist(vv,bound,free,e)
;        free
;      if ATOM op then u:=CDR u  --Atomic functions aren't descended
;      for v in u repeat
;        free:=freelist(v,bound,free,e)
;      free
;  expandedFunction :=
;            --One free can go by itself, more than one needs a vector
;         --An A-list name . number of times used
;    #frees = 0 => ['LAMBDA,[:vl,"$$"], :CDDR expandedFunction]
;    #frees = 1 =>
;      vec:=first first frees
;      ['LAMBDA,[:vl,vec], :CDDR expandedFunction]
;    scode:=nil
;    vec:=nil
;    locals:=nil
;    i:=-1
;    for v in frees repeat
;      i:=i+1
;      vec:=[first v,:vec]
;      scode:=[['SETQ,first v,[($QuickCode => 'QREFELT;'ELT),"$$",i]],:scode]
;      locals:=[first v,:locals]
;    body:=CDDR expandedFunction
;    if locals then
;      if body is [['DECLARE,:.],:.] then
;        body:=[CAR body,['PROG,locals,:scode,['RETURN,['PROGN,:CDR body]]]]
;      else body:=[['PROG,locals,:scode,['RETURN,['PROGN,:body]]]]
;    vec:=['VECTOR,:NREVERSE vec]
;    ['LAMBDA,[:vl,"$$"],:body]
;  fname:=['CLOSEDFN,expandedFunction]
;         --Like QUOTE, but gets compiled
;  uu:=
;    frees => ['CONS,fname,vec]
;    ['LIST,fname]
;  [uu,m,oldE]
\end{verbatim}
\calls{compWithMappingMode1}{isFunctor}
\calls{compWithMappingMode1}{get}
\calls{compWithMappingMode1}{qcar}
\calls{compWithMappingMode1}{qcdr}
\calls{compWithMappingMode1}{extendsCategoryForm}
\calls{compWithMappingMode1}{compLambda}
\calls{compWithMappingMode1}{stackAndThrow}
\calls{compWithMappingMode1}{take}
\calls{compWithMappingMode1}{compMakeDeclaration}
\calls{compWithMappingMode1}{hasFormalMapVariable}
\calls{compWithMappingMode1}{comp}
\calls{compWithMappingMode1}{extractCodeAndConstructTriple}
\calls{compWithMappingMode1}{optimizeFunctionDef}
\calls{compWithMappingMode1}{comp-tran}
\calls{compWithMappingMode1}{freelist}
\usesdollar{compWithMappingMode1}{formalArgList}
\usesdollar{compWithMappingMode1}{killOptimizeIfTrue}
\usesdollar{compWithMappingMode1}{funname}
\usesdollar{compWithMappingMode1}{funnameTail}
\usesdollar{compWithMappingMode1}{QuickCode}
\usesdollar{compWithMappingMode1}{EmptyMode}
\usesdollar{compWithMappingMode1}{FormalMapVariableList}
\usesdollar{compWithMappingMode1}{CategoryFrame}
\usesdollar{compWithMappingMode1}{formatArgList}
<<defun compWithMappingMode1>>=
(defun |compWithMappingMode1| (x m oldE |$formalArgList|)
 (declare (special |$formalArgList|))
  (prog (|$killOptimizeIfTrue| $funname $funnameTail mprime sl tmp1 tmp2 
         tmp3 tmp4 tmp5 tmp6 target argModeList nx oldstyle ress vl1 vl e tt
             u frees i scode locals body vec expandedFunction fname uu)
  (declare (special |$killOptimizeIfTrue| $funname $funnameTail
                    |$QuickCode| |$EmptyMode| |$FormalMapVariableList|
                    |$CategoryFrame| |$formatArgList|))
   (return
    (seq
     (progn
      (setq mprime (second m))
      (setq sl (cddr m))
      (setq |$killOptimizeIfTrue| t)
      (setq e oldE)
      (cond
       ((|isFunctor| x)
        (cond
         ((and (progn
                (setq tmp1 (|get| x '|modemap| |$CategoryFrame|))
                (and (pairp tmp1)
                     (progn
                      (setq tmp2 (qcar tmp1))
                      (and (pairp tmp2)
                           (progn
                            (setq tmp3 (qcar tmp2))
                            (and (pairp tmp3)
                                 (progn
                                  (setq tmp4 (qcdr tmp3))
                                  (and (pairp tmp4)
                                       (progn 
                                        (setq target (qcar tmp4))
                                        (setq argModeList (qcdr tmp4))
                                        t)))))
                           (progn
                            (setq tmp5 (qcdr tmp2))
                            (and (pairp tmp5) (eq (qcdr tmp5) nil)))))))
               (prog (t1)
                (setq t1 t)
                (return
                 (do ((t2 nil (null t1))
                      (t3 argModeList (cdr t3))
                      (mode nil)
                      (t4 sl (cdr t4))
                      (s nil))
                    ((or t2 (atom t3)
                         (progn (setq mode (car t3)) nil)
                         (atom t4)
                         (progn (setq s (car t4)) nil))
                        t1)
                   (seq (exit
                     (setq t1 
                      (and t1 (|extendsCategoryForm| '$ s mode))))))))
                        (|extendsCategoryForm| '$ target mprime))
               (return (list x m e )))
         (t nil)))
       (t 
        (when (stringp x) (setq x (intern x)))
        (setq ress nil) 
        (setq oldstyle t)
        (cond
         ((and (pairp x) 
               (eq (qcar x) '+->)
               (progn
                (setq tmp1 (qcdr x))
                (and (pairp tmp1)
                     (progn
                      (setq vl (qcar tmp1))
                      (setq tmp2 (qcdr tmp1))
                      (and (pairp tmp2)
                           (eq (qcdr tmp2) nil)
                           (progn (setq nx (qcar tmp2)) t))))))
            (setq oldstyle nil)
            (cond
             ((and (pairp vl) (eq (qcar vl) '|:|))
               (setq ress (|compLambda| x m oldE))
               ress)
             (t
              (setq vl
               (cond
                ((and (pairp vl)
                      (eq (qcar vl) '|@Tuple|)
                      (progn (setq vl1 (qcdr vl)) t))
                  vl1)
                (t vl)))
              (setq vl
               (cond
                ((symbolp vl) (cons vl nil))
                ((and 
                  (listp vl)
                  (prog (t5)
                   (setq t5 t)
                   (return
                    (do ((t7 nil (null t5))
                         (t6 vl (cdr t6))
                         (v nil))
                       ((or t7 (atom t6) (progn (setq v (car t6)) nil)) t5)
                      (seq
                       (exit
                        (setq t5 (and t5 (symbolp v)))))))))
                  vl)
                (t
                 (|stackAndThrow| (cons '|bad +-> arguments:| (list vl ))))))
              (setq |$formatArgList| (append vl |$formalArgList|))
              (setq x nx))))
         (t
          (setq vl (take (|#| sl) |$FormalMapVariableList|))))
        (cond
         (ress ress)
         (t
          (do ((t8 sl (cdr t8)) (m nil) (t9 vl (cdr t9)) (v nil))
              ((or (atom t8)
                   (progn (setq m (car t8)) nil)
                   (atom t9)
                   (progn (setq v (car t9)) nil))
                 nil)
              (seq (exit (progn
               (setq tmp6 
                (|compMakeDeclaration| (list '|:| v m ) |$EmptyMode| e))
               (setq e (third tmp6))
               tmp6))))
          (cond
           ((and oldstyle 
                 (null (null vl))
                 (null (|hasFormalMapVariable| x vl)))
            (return
             (progn
              (setq tmp6 (or (|comp| (cons x vl) mprime e) (return nil)))
              (setq u (car tmp6))
              (|extractCodeAndConstructTriple| u m oldE))))
           ((and (null vl) (setq tt (|comp| (cons x nil) mprime e)))
            (return
             (progn
               (setq u (car tt))
               (|extractCodeAndConstructTriple| u m oldE))))
           (t
            (setq tmp6 (or (|comp| x mprime e) (return nil)))
            (setq u (car tmp6))
            (setq uu (|optimizeFunctionDef| `(nil (lambda ,vl ,u))))
;  --  At this point, we have a function that we would like to pass.
;  --  Unfortunately, it makes various free variable references outside
;  --  itself.  So we build a mini-vector that contains them all, and
;  --  pass this as the environment to our inner function.
            (setq $funname nil)
            (setq $funnameTail (list nil))
            (setq expandedFunction (comp-tran (second uu)))
            (setq frees (freelist expandedFunction vl nil e))
            (setq expandedFunction
             (cond
              ((eql (|#| frees) 0)
               (cons 'lambda (cons (append vl (list '$$))
                                         (cddr expandedFunction))))
              ((eql (|#| frees) 1)
               (setq vec (caar frees))
                (cons 'lambda (cons (append vl (list vec))
                                         (cddr expandedFunction))))
              (t 
               (setq scode nil)
               (setq vec nil)
               (setq locals nil)
               (setq i -1)
               (do ((t0 frees (cdr t0)) (v nil))
                   ((or (atom t0) (progn (setq v (car t0)) nil)) nil)
                 (seq
                  (exit
                   (progn
                    (setq i (plus i 1))
                    (setq vec (cons (car v) vec))
                    (setq scode
                     (cons
                      (cons 'setq 
                       (cons (car v) 
                        (cons
                         (cons
                          (cond
                           (|$QuickCode| 'qrefelt)
                           (t 'elt))
                          (cons '$$ (cons i nil)))
                         nil)))
                       scode))
                    (setq locals (cons (car v) locals))))))
               (setq body (cddr expandedFunction))
               (cond
                (locals
                 (cond
                  ((and (pairp body)
                        (progn
                         (setq tmp1 (qcar body))
                         (and (pairp tmp1)
                              (eq (qcar tmp1) 'declare))))
                    (setq body
                     (cons (car body)
                      (cons
                       (cons 'prog
                        (cons locals
                         (append scode
                          (cons
                           (cons 'return
                            (cons
                             (cons 'progn
                              (cdr body))
                             nil))
                           nil))))
                        nil))))
                  (t
                   (setq body
                    (cons
                     (cons 'prog
                      (cons locals
                       (append scode
                        (cons
                         (cons 'return
                          (cons
                           (cons 'progn body)
                           nil))
                         nil))))
                     nil))))))
               (setq vec (cons 'vector (nreverse vec)))
               (cons 'lambda (cons (append vl (list '$$)) body)))))
            (setq fname (list 'closedfn expandedFunction))
            (setq uu
             (cond
              (frees (list 'cons fname vec))
              (t (list 'list fname))))
            (list uu m oldE))))))))))))

@

\defun{extractCodeAndConstructTriple}{extractCodeAndConstructTriple}
<<defun extractCodeAndConstructTriple>>=
(defun |extractCodeAndConstructTriple| (u m oldE)
 (let (tmp1 a fn op env)
  (cond
   ((and (pairp u) (eq (qcar u) '|call|)
         (progn
          (setq tmp1 (qcdr u))
          (and (pairp tmp1)
               (progn (setq fn (qcar tmp1)) t))))
    (cond
     ((and (pairp fn) (eq (qcar fn) '|applyFun|)
           (progn
            (setq tmp1 (qcdr fn))
            (and (pairp tmp1) (eq (qcdr tmp1) nil)
                 (progn (setq a (qcar tmp1)) t))))
            (setq fn a)))
    (list fn m oldE))
   (t
    (setq op (car u))
    (setq env (car (reverse (cdr u))))
    (list (list 'cons  (list '|function| op) env) m oldE)))))

@

\defun{hasFormalMapVariable}{hasFormalMapVariable}
\calls{hasFormalMapVariable}{ScanOrPairVec}
\usesdollar{hasFormalMapVariable}{formalMapVariables}
<<defun hasFormalMapVariable>>=
(defun |hasFormalMapVariable| (x vl)
 (let (|$formalMapVariables|)
 (declare (special |$formalMapVariables|))
 (when (setq |$formalMapVariables| vl)
  (|ScanOrPairVec| #'(lambda (y) (member y |$formalMapVariables|)) x))))

@
\defun{compLambda}{compLambda}
\calls{compLambda}{qcar}
\calls{compLambda}{qcdr}
\calls{compLambda}{argsToSig}
\calls{compLambda}{compAtSign}
\calls{compLambda}{stackAndThrow}
<<defun compLambda>>=
(defun |compLambda| (x m e)
 (let (vl body tmp1 tmp2 tmp3 target args arg1 sig1 ress)
  (setq vl (second x))
  (setq body (third x))
  (cond
   ((and (pairp vl) (eq (qcar vl) '|:|)
         (progn
          (setq tmp1 (qcdr vl))
          (and (pairp tmp1)
               (progn
                (setq args (qcar tmp1))
                (setq tmp2 (qcdr tmp1))
                (and (pairp tmp2)
                     (eq (qcdr tmp2) nil)
                     (progn
                      (setq target (qcar tmp2))
                      t))))))
     (when (and (pairp args) (eq (qcar args) '|@Tuple|))
      (setq args (qcdr args)))       
     (cond
      ((listp args)
       (setq tmp3 (|argsToSig| args))
       (setq arg1 (CAR tmp3))
       (setq sig1 (second tmp3))
       (cond
        (sig1 
         (setq ress
          (|compAtSign|
           (list '@
            (list '+-> arg1 body)
            (cons '|Mapping| (cons target sig1))) m e))
          ress)
        (t (|stackAndThrow| (list '|compLambda| x )))))
      (t (|stackAndThrow| (list '|compLambda| x )))))
    (t (|stackAndThrow| (list '|compLambda| x ))))))

@

\defun{compAtSign}{compAtSign}
\calls{compAtSign}{addDomain}
\calls{compAtSign}{comp}
\calls{compAtSign}{coerce}
<<defun compAtSign>>=
(defun |compAtSign| (arg1 m e)
  (let ((x (second arg1)) (mprime (third arg1)) tmp)
   (setq e (|addDomain| mprime e))
   (when (setq tmp (|comp| x mprime e)) (|coerce| tmp m))))

@

\defun{compWhere}{compWhere}
\calls{compWhere}{comp}
\calls{compWhere}{macroExpand}
\calls{compWhere}{deltaContour}
\calls{compWhere}{addContour}
\usesdollar{compWhere}{insideExpressionIfTrue}
\usesdollar{compWhere}{insideWhereIfTrue}
\usesdollar{compWhere}{EmptyMode}
<<defun compWhere>>=
(defun |compWhere| (arg0 m eInit)
 (let (|$insideExpressionIfTrue| |$insideWhereIfTrue| form exprList e 
       eBefore tmp1 x eAfter del eFinal)
 (declare (special |$insideExpressionIfTrue| |$insideWhereIfTrue|
                   |$EmptyMode|))
  (setq form (second arg0))
  (setq exprlist (cddr arg0))
  (setq |$insideExpressionIfTrue| nil)
  (setq |$insideWhereIfTrue| t)
  (setq e eInit)
  (when (dolist (item exprList t)
          (setq tmp1 (|comp| item |$EmptyMode| e))
          (unless tmp1 (return nil))
          (setq e (third tmp1)))
  (setq |$insideWhereIfTrue| nil)
  (setq tmp1 (|comp| (|macroExpand| form (setq eBefore e)) m e))
  (when tmp1
    (setq x (first tmp1))
    (setq m (second tmp1))
    (setq eAfter (third tmp1))
    (setq del (|deltaContour| eAfter eBefore))
    (if del
      (setq eFinal (|addContour| del eInit))
      (setq eFinal eInit))
    (list x m eFinal)))))

@

\defun{compSeq}{compSeq}
\calls{compSeq}{compSeq1}
\usesdollar{compSeq}{exitModeStack}
<<defun compSeq>>=
(defun |compSeq| (arg0 m e)
 (declare (special |$exitModeStack|))
 (|compSeq1| (cdr arg0) (cons m |$exitModeStack|) e))

@

\defun{compSeq1}{compSeq1}
\calls{compSeq1}{nreverse0}
\calls{compSeq1}{compSeqItem}
\calls{compSeq1}{mkq}
\calls{compSeq1}{replaceExitEtc}
\usesdollar{compSeq1}{exitModeStack}
\usesdollar{compSeq1}{insideExpressionIfTrue}
\usesdollar{compSeq1}{finalEnv}
\usesdollar{compSeq1}{NoValueMode}
<<defun compSeq1>>=
(defun |compSeq1| (l |$exitModeStack| e)
 (declare (special |$exitModeStack|))
 (let (|$insideExpressionIfTrue| |$finalEnv| tmp1 tmp2 c catchTag form)
 (declare (special |$insideExpressionIfTrue| |$finalEnv| |$NoValueMode|))
  (setq |$insideExpressionIfTrue| nil)
  (setq |$finalEnv| nil)
  (when
    (setq c (dolist (x l (nreverse0 tmp2))
             (setq |$insideExpressionIfTrue| nil)
             (setq tmp1 (|compSeqItem| x |$NoValueMode| e))
             (unless tmp1 (return nil))
             (setq e (third tmp1))
             (push (first tmp1) tmp2)))
   (setq catchTag (mkq (gensym)))
   (setq form
    (cons 'seq
     (|replaceExitEtc| c catchTag '|TAGGEDexit| (elt |$exitModeStack| 0))))
   (list (list 'catch catchTag form) (elt |$exitModeStack| 0) |$finalEnv|))))

@

\defun{compSeqItem}{compSeqItem}
\calls{compSeqItem}{comp}
\calls{compSeqItem}{macroExpand}
<<defun compSeqItem>>=
(defun |compSeqItem| (x m e)
  (|comp| (|macroExpand| x e) m e))

@

\defun{argsToSig}{argsToSig}
<<defun argsToSig>>=
(defun |argsToSig| (args)
 (let (tmp1 v tmp2 tt sig1 arg1 bad)
  (cond
   ((and (pairp args) (eq (qcar args) '|:|)
         (progn
          (setq tmp1 (qcdr args))
          (and (pairp tmp1)
               (progn
                (setq v (qcar tmp1))
                (setq tmp2 (qcdr tmp1))
                (and (pairp tmp2)
                     (eq (qcdr tmp2) nil)
                     (progn
                      (setq tt (qcar tmp2))
                      t))))))
    (list (list v) (list tt)))
   (t 
    (setq sig1 nil) 
    (setq arg1 nil)
    (setq bad nil)
    (dolist (arg args)
      (cond
       ((and (pairp arg) (eq (qcar arg) '|:|)
             (progn
              (setq tmp1 (qcdr arg))
              (and (pairp tmp1)
                   (progn
                    (setq v (qcar tmp1))
                    (setq tmp2 (qcdr tmp1))
                    (and (pairp tmp2) (eq (qcdr tmp2) nil)
                         (progn
                          (setq tt (qcar tmp2))
                          t))))))
         (setq sig1 (cons tt sig1))
         (setq arg1 (cons v arg1)))
        (t (setq bad t))))
    (cond
     (bad (list nil nil ))
     (t (list (reverse arg1) (reverse sig1))))))))

@

\defun{compMakeDeclaration}{compMakeDeclaration}
\calls{compMakeDeclaration}{compColon}
\usesdollar{compMakeDeclaration}{insideExpressionIfTrue}
<<defun compMakeDeclaration>>=
(defun |compMakeDeclaration| (x m e)
 (let (|$insideExpressionIfTrue|)
 (declare (special |$insideExpressionIfTrue|))
  (setq |$insideExpressionIfTrue| nil)
  (|compColon| x m e)))

@

\defun{compExit}{compExit}
\calls{compExit}{comp}
\calls{compExit}{modifyModeStack}
\calls{compExit}{stackMessageIfNone}
\usesdollar{compExit}{exitModeStack}
<<defun compExit>>=
(defun |compExit| (arg0 m e)
 (let (x index m1 u)
 (declare (special |$exitModeStack|))
  (setq index (1- (second arg0)))
  (setq x (third arg0))
  (cond
   ((null |$exitModeStack|)
    (|comp| x m e))
   (t
    (setq m1 (elt |$exitModeStack| index))
    (setq u (|comp| x m1 e))
    (cond
     (u
      (|modifyModeStack| (second u) index)
      (list (list '|TAGGEDexit| index u) m e))
     (t
       (|stackMessageIfNone|
        (list '|cannot compile exit expression| x '|in mode| m1))))))))

@
\defun{modifyModeStack}{modifyModeStack}
\calls{modifyModeStack}{say}
\calls{modifyModeStack}{copy}
\calls{modifyModeStack}{setelt}
\calls{modifyModeStack}{resolve}
\usesdollar{modifyModeStack}{reportExitModeStack}
\usesdollar{modifyModeStack}{exitModeStack}
<<defun modifyModeStack>>=
(defun |modifyModeStack| (|m| |index|)
 (declare (special |$exitModeStack| |$reportExitModeStack|))
 (if |$reportExitModeStack|
   (say "exitModeStack: " (copy |$exitModeStack|)
    " ====> "
    (progn
     (setelt |$exitModeStack| |index|
      (|resolve| |m| (elt |$exitModeStack| |index|)))
     |$exitModeStack|))
   (setelt |$exitModeStack| |index|
      (|resolve| |m| (elt |$exitModeStack| |index|)))))

@

\defun{freelist}{Create a list of unbound symbols}
We walk argument u looking for symbols that are unbound. If we find a
symbol we add it to the free list. If it occurs in a prog then it is
bound and we remove it from the free list. Multiple instances of a single
symbol in the free list are represented by the alist (symbol . count)
\calls{freelist}{freelist}
\calls{freelist}{assq}
\calls{freelist}{identp}
\calls{freelist}{getmode}
\calls{freelist}{unionq}
<<defun freelist>>=
(defun freelist (u bound free e)
 (let (v op)
  (if (atom u)
   (cond
    ((null (identp u)) free)
    ((member u bound) free)
    ; more than 1 free becomes alist (name . number)
    ((setq v (assq u free)) (rplacd v (+ 1 (cdr v))) free)
    ((null (|getmode| u e)) free)
    (t (cons (cons u 1) free)))
   (progn
    (setq op (car u))
    (cond
     ((member op '(quote go |function|)) free)
     ((eq op 'lambda) ; lambdas bind symbols
      (setq bound (unionq bound (second u)))
      (dolist (v (cddr u))
       (setq free (freelist v bound free e))))
     ((eq op 'prog) ; progs bind symbols
      (setq bound (unionq bound (second u)))
      (dolist (v (cddr u))
       (unless (atom v)
        (setq free (freelist v bound free e)))))
     ((eq op 'seq)
      (dolist (v (cdr u))
       (unless (atom v)
        (setq free (freelist v bound free e)))))
     ((eq op 'cond)
      (dolist (v (cdr u))
       (dolist (vv v)
        (setq free (freelist vv bound free e)))))
     (t
      (when (atom op) (setq u (cdr u))) ; atomic functions aren't descended
      (dolist (v u)
       (setq free (freelist v bound free e)))))
    free))))

@

\defun{compOrCroak1,compactify}{compOrCroak1,compactify}
\calls{compOrCroak1,compactify}{compOrCroak1,compactify}
\calls{compOrCroak1,compactify}{lassoc}
<<defun compOrCroak1,compactify>>=
(defun |compOrCroak1,compactify| (al)
 (cond
  ((null al) nil)
  ((lassoc (caar al) (cdr al)) (|compOrCroak1,compactify| (cdr al)))
  (t (cons (car al) (|compOrCroak1,compactify| (cdr al))))))

@

\defun{ncINTERPFILE}{Compiler/Interpreter interface}
\calls{ncINTERPFILE}{SpadInterpretStream(5)}
\usesdollar{ncINTERPFILE}{EchoLines}
\usesdollar{ncINTERPFILE}{ReadingFile}
<<defun ncINTERPFILE>>=
(defun |ncINTERPFILE| (file echo)
 (let ((|$EchoLines| echo) (|$ReadingFile| t))
 (declare (special |$EchoLines| |$ReadingFile|))
  (|SpadInterpretStream| 1 file nil)))

@

\defun{compileSpadLispCmd}{compileSpadLispCmd}
\calls{compileSpadLispCmd}{pathname(5)}
\calls{compileSpadLispCmd}{pathnameType(5)}
\calls{compileSpadLispCmd}{selectOptionLC(5)}
\calls{compileSpadLispCmd}{namestring(5)}
\calls{compileSpadLispCmd}{terminateSystemCommand(5)}
\calls{compileSpadLispCmd}{fnameMake(5)}
\calls{compileSpadLispCmd}{pathnameDirectory(5)}
\calls{compileSpadLispCmd}{pathnameName(5)}
\calls{compileSpadLispCmd}{fnameReadable?(5)}
\calls{compileSpadLispCmd}{localdatabase(5)}
\calls{compileSpadLispCmd}{throwKeyedMsg}
\calls{compileSpadLispCmd}{object2String}
\calls{compileSpadLispCmd}{sayKeyedMsg}
\calls{compileSpadLispCmd}{recompile-lib-file-if-necessary}
\calls{compileSpadLispCmd}{spadPrompt}
\usesdollar{compileSpadLispCmd}{options}
<<defun compileSpadLispCmd>>=
(defun |compileSpadLispCmd| (args)
 (let (path optlist optname optargs beQuiet dolibrary lsp)
  (declare (special |$options|))
  (setq path (|pathname| (|fnameMake| (car args) "code" "lsp")))
  (cond
   ((null (probe-file path))
     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
   (t
    (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
    (setq beQuiet nil)
    (setq dolibrary t)
    (dolist (opt |$options|)
      (setq optname (car opt))
      (setq optargs (cdr opt))
      (case (|selectOptionLC| optname optlist nil)
         (|quiet|     (setq beQuiet t))
         (|noquiet|   (setq beQuiet nil))
         (|library|   (setq dolibrary t))
         (|nolibrary| (setq dolibrary nil))
         (t
          (|throwKeyedMsg| 's2iz0036
           (list (strconc ")" (|object2String| optname)))))))
    (setq lsp
     (|fnameMake|
      (|pathnameDirectory| path)
      (|pathnameName| path)
      (|pathnameType| path)))
    (cond
     ((|fnameReadable?| lsp)
      (unless beQuiet (|sayKeyedMsg| 's2iz0089 (list (|namestring| lsp))))
       (recompile-lib-file-if-necessary lsp))
     (t
      (|sayKeyedMsg| 's2il0003 (list (|namestring| lsp)))))
    (cond
     (dolibrary
      (unless beQuiet (|sayKeyedMsg| 's2iz0090 (list (|pathnameName| path))))
      (localdatabase (list (|pathnameName| (car args))) nil))
     ((null beQuiet) (|sayKeyedMsg| 's2iz0084 nil))
     (t nil))
    (|terminateSystemCommand|)
    (|spadPrompt|)))))

@

\defun{recompile-lib-file-if-necessary}{recompile-lib-file-if-necessary}
\calls{recompile-lib-file-if-necessary}{compile-lib-file}
\uses{recompile-lib-file-if-necessary}{*lisp-bin-filetype*}
<<defun recompile-lib-file-if-necessary>>=
(defun recompile-lib-file-if-necessary (lfile)
 (let* ((bfile (make-pathname :type *lisp-bin-filetype* :defaults lfile))
        (bdate (and (probe-file bfile) (file-write-date bfile)))
        (ldate (and (probe-file lfile) (file-write-date lfile))))
  (unless (and ldate bdate (> bdate ldate))
   (compile-lib-file lfile)
   (list bfile))))

@

\defun{spad-fixed-arg}{spad-fixed-arg}
<<defun spad-fixed-arg>>=
(defun spad-fixed-arg (fname )
 (and (equal (symbol-package fname) (find-package "BOOT"))
      (not (get fname 'compiler::spad-var-arg))
      (search ";" (symbol-name fname))
      (or (get fname 'compiler::fixed-args)
          (setf (get fname 'compiler::fixed-args) t)))
   nil)

@

\defun{compile-lib-file}{compile-lib-file}
<<defun compile-lib-file>>=
(defun compile-lib-file (fn &rest opts)
 (unwind-protect
  (progn
   (trace (compiler::fast-link-proclaimed-type-p
           :exitcond nil
           :entrycond (spad-fixed-arg (car system::arglist))))
   (trace (compiler::t1defun 
           :exitcond nil
           :entrycond (spad-fixed-arg (caar system::arglist))))
   (apply #'compile-file fn opts))
  (untrace compiler::fast-link-proclaimed-type-p compiler::t1defun)))

@

\defun{compileFileQuietly}{compileFileQuietly}
if \verb|$InteractiveMode| then use a null outputstream 
\usesdollar{compileFileQuietly}{InteractiveMode}
\uses{compileFileQuietly}{*standard-output*}
<<defun compileFileQuietly>>=
(defun |compileFileQuietly| (fn) 
  (let (
         (*standard-output*
         (if |$InteractiveMode| (make-broadcast-stream)
           *standard-output*)))
  (declare (special *standard-output* |$InteractiveMode|))
  (compile-file fn)))

@
\defdollar{byConstructors}
<<initvars>>=
(defvar |$byConstructors| () "list of constructors to be compiled")

@
\defdollar{constructorsSeen}
<<initvars>>=
(defvar |$constructorsSeen| () "list of constructors found")

@

<<Compiler>>=
(in-package "BOOT")

<<initvars>>

<<defmacro bang>>
<<defmacro must>>
<<defmacro star>>

<<defun action>>
<<defun addCARorCDR>>
<<defun add-parens-and-semis-to-line>>
<<defun advance-token>>
<<defun aplTran>>
<<defun aplTran1>>
<<defun aplTranList>>
<<defun argsToSig>>

<<defun char-eq>>
<<defun char-ne>>
<<defun comma2Tuple>>
<<defun comp>>
<<defun comp2>>
<<defun comp3>>
<<defun compArgumentsAndTryAgain>>
<<defun compAtom>>
<<defun compAtSign>>
<<defun compColon>>
<<defun compColonInside>>
<<defun compExit>>
<<defun compExpression>>
<<defun compForm>>
<<defun compForm1>>
<<defun compForm2>>
<<defun compLambda>>
<<defun compileFileQuietly>>
<<defun compile-lib-file>>
<<defun compiler>>
<<defun compilerDoit>>
<<defun compileSpad2Cmd>>
<<defun compileSpadLispCmd>>
<<defun compList>>
<<defun compMakeDeclaration>>
<<defun compNoStacking>>
<<defun compNoStacking1>>
<<defun compOrCroak>>
<<defun compOrCroak1>>
<<defun compOrCroak1,compactify>>
<<defun compSeq>>
<<defun compSeqItem>>
<<defun compSeq1>>
<<defun compSymbol>>
<<defun compTopLevel>>
<<defun compTypeOf>>
<<defun compVector>>
<<defun compWhere>>
<<defun compWithMappingMode>>
<<defun compWithMappingMode1>>
<<defun containsBang>>
<<defun convert>>
<<defun current-char>>
<<defun current-symbol>>
<<defun current-token>>

<<defun decodeScripts>>
<<defun deepestExpression>>
<<defun def>>
<<defun def-addlet>>
<<defun def-collect>>
<<defun def-cond>>
<<defun def-inner>>
<<defun def-insert-let>>
<<defun def-in2on>>
<<defun def-is>>
<<defun def-is2>>
<<defun def-is-eqlist>>
<<defun defIS>>
<<defun defIS1>>
<<defun defISReverse>>
<<defun def-is-remdup>>
<<defun def-is-remdup1>>
<<defun def-is-rev>>
<<defun def-it>>
<<defun def-let>>
<<defun defLET>>
<<defun defLET1>>
<<defun defLET2>>
<<defun defLetForm>>
<<defun def-message>>
<<defun def-message1>>
<<defun def-process>>
<<defun def-rename>>
<<defun def-rename1>>
<<defun def-repeat>>
<<defun def-string>>
<<defun def-stringtoquote>>
<<defun deftran>>
<<defun def-where>>
<<defun def-whereclause>>
<<defun def-whereclauselist>>
<<defun dollarTran>>

<<defun errhuh>>
<<defun escape-keywords>>
<<defun extractCodeAndConstructTriple>>

<<defun floatexpid>>
<<defun freelist>>

<<defun get-a-line>>
<<defun getScriptName>>
<<defun get-token>>
<<defun getToken>>

<<defun hackforis>>
<<defun hackforis1>>
<<defun hasAplExtension>>
<<defun hasFormalMapVariable>>

<<defun initialize-preparse>>
<<defun initial-substring>>
<<defun initial-substring-p>>

<<defun Line-New-Line>>

<<defun make-string-adjustable>>
<<defun make-symbol-of>>
<<defun match-advance-string>>
<<defun match-current-token>>
<<defun match-next-token>>
<<defun match-string>>
<<defun match-token>>
<<defun meta-syntax-error>>
<<defun modifyModeStack>>

<<defun next-char>>
<<defun next-line>>
<<defun next-token>>
<<defun ncINTERPFILE>>

<<defun optional>>

<<defun PARSE-AnyId>>
<<defun PARSE-Application>>
<<defun PARSE-Category>>
<<defun PARSE-Command>>
<<defun PARSE-CommandTail>>
<<defun PARSE-Conditional>>
<<defun PARSE-Data>>
<<defun PARSE-ElseClause>>
<<defun PARSE-Enclosure>>
<<defun PARSE-Exit>>
<<defun PARSE-Expr>>
<<defun PARSE-Expression>>
<<defun PARSE-Float>>
<<defun PARSE-FloatBase>>
<<defun PARSE-FloatBasePart>>
<<defun PARSE-FloatExponent>>
<<defun PARSE-FloatTok>>
<<defun PARSE-Form>>
<<defun PARSE-FormalParameter>>
<<defun PARSE-FormalParameterTok>>
<<defun PARSE-getSemanticForm>>
<<defun PARSE-GliphTok>>
<<defun PARSE-Import>>
<<defun PARSE-Infix>>
<<defun PARSE-InfixWith>>
<<defun PARSE-IntegerTok>>
<<defun PARSE-Iterator>>
<<defun PARSE-IteratorTail>>
<<defun PARSE-Label>>
<<defun PARSE-LabelExpr>>
<<defun PARSE-Leave>>
<<defun PARSE-LedPart>>
<<defun PARSE-leftBindingPowerOf>>
<<defun PARSE-Loop>>
<<defun PARSE-Name>>
<<defun PARSE-NBGliphTok>>
<<defun PARSE-NewExpr>>
<<defun PARSE-NudPart>>
<<defun PARSE-OpenBrace>>
<<defun PARSE-OpenBracket>>
<<defun PARSE-Operation>>
<<defun PARSE-Option>>
<<defun PARSE-Prefix>>
<<defun PARSE-Primary>>
<<defun PARSE-Primary1>>
<<defun PARSE-PrimaryNoFloat>>
<<defun PARSE-PrimaryOrQM>>
<<defun PARSE-Qualification>>
<<defun PARSE-Quad>>
<<defun PARSE-Reduction>>
<<defun PARSE-ReductionOp>>
<<defun PARSE-Return>>
<<defun PARSE-rightBindingPowerOf>>
<<defun PARSE-ScriptItem>>
<<defun PARSE-Scripts>>
<<defun PARSE-Seg>>
<<defun PARSE-Selector>>
<<defun PARSE-SemiColon>>
<<defun PARSE-Sequence>>
<<defun PARSE-Sequence1>>
<<defun PARSE-Sexpr>>
<<defun PARSE-Sexpr1>>
<<defun PARSE-SpecialCommand>>
<<defun PARSE-SpecialKeyWord>>
<<defun PARSE-Statement>>
<<defun PARSE-String>>
<<defun PARSE-Suffix>>
<<defun PARSE-TokenCommandTail>>
<<defun PARSE-TokenList>>
<<defun PARSE-TokenOption>>
<<defun PARSE-TokTail>>
<<defun PARSE-VarForm>>
<<defun PARSE-With>>
<<defun parsepiles>>
<<defun parseAtom>>
<<defun parseConstruct>>
<<defun postForm>>
<<defun parseLeave>>
<<defun parseTran>>
<<defun parseTranList>>
<<defun parseTransform>>
<<defun postAdd>>
<<defun postAtom>>
<<defun postAtSign>>
<<defun postBigFloat>>
<<defun postBlock>>
<<defun postCategory>>
<<defun postcheck>>
<<defun postCollect>>
<<defun postCollect,finish>>
<<defun postColon>>
<<defun postColonColon>>
<<defun postComma>>
<<defun postConstruct>>
<<defun postDef>>
<<defun postError>>
<<defun postOp>>
<<defun postScriptsForm>>
<<defun postTran>>
<<defun postTranList>>
<<defun postTranScripts>>
<<defun postTransform>>
<<defun postTransformCheck>>
<<defun postWith>>
<<defun preparse>>
<<defun preparse1>>
<<defun preparse-echo>>
<<defun preparseReadLine>>
<<defun preparseReadLine1>>
<<defun primitiveType>>
<<defun push-reduction>>

<<defun quote-if-string>>

<<defun read-a-line>>
<<defun recompile-lib-file-if-necessary>>
<<defun /rf-1>>
<<defun /RQ,LIB>>

<<defun setDefOp>>
<<defun spad>>
<<defun spad-fixed-arg>>
<<defun storeblanks>>
<<defun s-process>>

<<defun try-get-token>>

<<defun underscore>>
<<defun unget-tokens>>
<<defun unTuple>>

<<postvars>>

@
\eject
\begin{thebibliography}{99}
\bibitem{1} Jenks, R.J. and Sutor, R.S. 
``Axiom -- The Scientific Computation System''
Springer-Verlag New York (1992)
ISBN 0-387-97855-0
\bibitem{2} Knuth, Donald E., ``Literate Programming''
Center for the Study of Language and Information
ISBN 0-937073-81-4
Stanford CA (1992) 
\bibitem{3} Daly, Timothy, ``The Axiom Wiki Website''\\
{\bf http://axiom.axiom-developer.org}
\bibitem{4} Watt, Stephen, ``Aldor'',\\
{\bf http://www.aldor.org}
\bibitem{5} Lamport, Leslie, ``Latex -- A Document Preparation System'',
Addison-Wesley, New York ISBN 0-201-52983-1
\bibitem{6} Ramsey, Norman ``Noweb -- A Simple, Extensible Tool for
Literate Programming''\\
{\bf http://www.eecs.harvard.edu/ $\tilde{}$nr/noweb}
\bibitem{7} Daly, Timothy, "The Axiom Literate Documentation"\\
{\bf http://axiom.axiom-developer.org/axiom-website/documentation.html}
\end{thebibliography}
\chapter{Index}
\printindex
\end{document}
