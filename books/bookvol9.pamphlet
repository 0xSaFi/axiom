\documentclass[dvipdfm]{book}
\usepackage{hyperref}
\usepackage{axiom}
\usepackage{makeidx}
\makeindex
\usepackage{graphicx}
\begin{document}
\begin{titlepage}
\center{\includegraphics{ps/axiomfront.ps}}
\vskip 0.1in
\includegraphics{ps/bluebayou.ps}\\
\vskip 0.1in
{\Huge{The 30 Year Horizon}}
\vskip 0.1in
$$
\begin{array}{lll}
Manuel\ Bronstein      & William\ Burge   & Timothy\ Daly \\
James\ Davenport       & Michael\ Dewar   & Martin\ Dunstan \\
Albrecht\ Fortenbacher & Patrizia\ Gianni & Johannes\ Grabmeier \\
Jocelyn\ Guidry        & Richard\ Jenks   & Larry\ Lambe \\
Michael\ Monagan       & Scott\ Morrison  & William\ Sit \\
Jonathan\ Steinbach    & Robert\ Sutor    & Barry\ Trager \\
Stephen\ Watt          & Jim\ Wen         & Clifton\ Williamson
\end{array}
$$
\center{\large{Volume 9: Axiom Compiler}}
\end{titlepage}
\pagenumbering{roman}
\begin{verbatim}
Portions Copyright (c) 2005 Timothy Daly

The Blue Bayou image Copyright (c) 2004 Jocelyn Guidry

Portions Copyright (c) 2004 Martin Dunstan

Portions Copyright (c) 1991-2002, 
The Numerical ALgorithms Group Ltd.
All rights reserved.

This book and the Axiom software is licensed as follows:

Redistribution and use in source and binary forms, with or 
without modification, are permitted provided that the following 
conditions are
met:

    - Redistributions of source code must retain the above 
      copyright notice, this list of conditions and the 
      following disclaimer.

    - Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the 
      following disclaimer in the documentation and/or other 
      materials provided with the distribution.

    - Neither the name of The Numerical ALgorithms Group Ltd. 
      nor the names of its contributors may be used to endorse 
      or promote products derived from this software without 
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.

\end{verbatim}

Inclusion of names in the list of credits is based on historical
information and is as accurate as possible. Inclusion of names
does not in any way imply an endorsement but represents historical
influence on Axiom development.
\vfill
\eject
\begin{tabular}{lll}
Cyril Alberga         & Roy Adler             & Richard Anderson\\
George Andrews        & Henry Baker           & Stephen Balzac\\
Yurij Baransky        & David R. Barton       & Gerald Baumgartner\\
Gilbert Baumslag      & Fred Blair            & Vladimir Bondarenko\\
Mark Botch            & Alexandre Bouyer      & Peter A. Broadbery\\
Martin Brock          & Manuel Bronstein      & Florian Bundschuh\\
William Burge         & Quentin Carpent       & Bob Caviness\\
Bruce Char            & Cheekai Chin          & David V. Chudnovsky\\
Gregory V. Chudnovsky & Josh Cohen            & Christophe Conil\\
Don Coppersmith       & George Corliss        & Robert Corless\\
Gary Cornell          & Meino Cramer          & Claire Di Crescenzo\\
Timothy Daly Sr.      & Timothy Daly Jr.      & James H. Davenport\\
Jean Della Dora       & Gabriel Dos Reis      & Michael Dewar\\
Claire DiCrescendo    & Sam Dooley            & Lionel Ducos\\
Martin Dunstan        & Brian Dupee           & Dominique Duval\\
Robert Edwards        & Heow Eide-Goodman     & Lars Erickson\\
Richard Fateman       & Bertfried Fauser      & Stuart Feldman\\
Brian Ford            & Albrecht Fortenbacher & George Frances\\
Constantine Frangos   & Timothy Freeman       & Korrinn Fu\\
Marc Gaetano          & Rudiger Gebauer       & Kathy Gerber\\
Patricia Gianni       & Holger Gollan         & Teresa Gomez-Diaz\\
Laureano Gonzalez-Vega& Stephen Gortler       & Johannes Grabmeier\\
Matt Grayson          & James Griesmer        & Vladimir Grinberg\\
Oswald Gschnitzer     & Jocelyn Guidry        & Steve Hague\\
Vilya Harvey          & Satoshi Hamaguchi     & Martin Hassner\\
Ralf Hemmecke         & Henderson             & Antoine Hersen\\
Pietro Iglio          & Richard Jenks         & Kai Kaminski\\
Grant Keady           & Tony Kennedy          & Paul Kosinski\\
Klaus Kusche          & Bernhard Kutzler      & Larry Lambe\\
Frederic Lehobey      & Michel Levaud         & Howard Levy\\
Rudiger Loos          & Michael Lucks         & Richard Luczak\\
Camm Maguire          & Bob McElrath          & Michael McGettrick\\
Ian Meikle            & David Mentre          & Victor S. Miller\\
Gerard Milmeister     & Mohammed Mobarak      & H. Michael Moeller\\
Michael Monagan       & Marc Moreno-Maza      & Scott Morrison\\
Mark Murray           & William Naylor        & C. Andrew Neff\\
John Nelder           & Godfrey Nolan         & Arthur Norman\\
Jinzhong Niu          & Michael O'Connor      & Kostas Oikonomou\\
Julian A. Padget      & Bill Page             & Jaap Weel\\
Susan Pelzel          & Michel Petitot        & Didier Pinchon\\
Claude Quitte         & Norman Ramsey         & Michael Richardson\\
Renaud Rioboo         & Jean Rivlin           & Nicolas Robidoux\\
Simon Robinson        & Michael Rothstein     & Martin Rubey\\
Philip Santas         & Alfred Scheerhorn     & William Schelter\\
Gerhard Schneider     & Martin Schoenert      & Marshall Schor\\
Fritz Schwarz         & Nick Simicich         & William Sit\\
Elena Smirnova        & Jonathan Steinbach    & Christine Sundaresan\\
Robert Sutor          & Moss E. Sweedler      & Eugene Surowitz\\
James Thatcher        & Baldir Thomas         & Mike Thomas\\
Dylan Thurston        & Barry Trager          & Themos T. Tsikas\\
Gregory Vanuxem       & Bernhard Wall         & Stephen Watt\\
Juergen Weiss         & M. Weller             & Mark Wegman\\
James Wen             & Thorsten Werther      & Michael Wester\\
John M. Wiley         & Berhard Will          & Clifton J. Williamson\\
Stephen Wilson        & Shmuel Winograd       & Robert Wisbauer\\
Sandra Wityak         & Waldemar Wiwianka     & Knut Wolf\\
Clifford Yapp         & David Yun             & Richard Zippel\\
Evelyn Zoernack       & Bruno Zuercher        & Dan Zwillinger 
\end{tabular}
\eject
\tableofcontents
\vfill
\eject
\setlength{\parindent}{0em}
\setlength{\parskip}{1ex}
{\Large{\bf New Foreword}}
\vskip .25in

On October 1, 2001 Axiom was withdrawn from the market and ended
life as a commercial product.
On September 3, 2002 Axiom was released under the Modified BSD
license, including this document.
On August 27, 2003 Axiom was released as free and open source
software available for download from the Free Software Foundation's
website, Savannah.

Work on Axiom has had the generous support of the Center for 
Algorithms and Interactive Scientific Computation (CAISS) at
City College of New York. Special thanks go to Dr. Gilbert 
Baumslag for his support of the long term goal.

The online version of this documentation is roughly 1000 pages.
In order to make printed versions we've broken it up into three
volumes. The first volume is tutorial in nature. The second volume
is for programmers. The third volume is reference material. We've
also added a fourth volume for developers. All of these changes
represent an experiment in print-on-demand delivery of documentation.
Time will tell whether the experiment succeeded.

Axiom has been in existence for over thirty years. It is estimated to
contain about three hundred man-years of research and has, as of
September 3, 2003, 143 people listed in the credits. All of these
people have contributed directly or indirectly to making Axiom
available.  Axiom is being passed to the next generation. I'm looking
forward to future milestones.

With that in mind I've introduced the theme of the ``30 year horizon''.
We must invent the tools that support the Computational Mathematician
working 30 years from now. How will research be done when every bit of
mathematical knowledge is online and instantly available? What happens
when we scale Axiom by a factor of 100, giving us 1.1 million domains?
How can we integrate theory with code? How will we integrate theorems
and proofs of the mathematics with space-time complexity proofs and
running code? What visualization tools are needed? How do we support
the conceptual structures and semantics of mathematics in effective
ways? How do we support results from the sciences? How do we teach
the next generation to be effective Computational Mathematicians?

The ``30 year horizon'' is much nearer than it appears.

\vskip .25in
%\noindent
Tim Daly\\
CAISS, City College of New York\\
November 10, 2003 ((iHy))
\vfill
\eject
\pagenumbering{arabic}
\setcounter{chapter}{0} % Chapter 1
\section{Makefile}
This book is actually a literate program\cite{2} and contains
executable source code. In particular, the Makefile for this book
is part of the source of the book and is included below. Axiom 
uses the ``noweb'' literate programming system by Norman Ramsey\cite{6}.

\chapter{Overview}
The Spad language is a mathematically oriented language intended for
writing computational mathematics. It derives its logical structure
from abstract algebra. It features ideas that are still not available
in general purpose programming languages, such as selecting overloaded
procedures based on the return type as well as the types of the arguments.

The Spad language is heavily influenced by Barbara Liskov's work.
It features encapsulation (aka objects), inheritance, and overloading.
It has categories which are defined by the exports. Categories are
parameterized functors that take arguments which define their behavior.

More details on the language and its high level concepts is available
in the Programmers Guide, Volume 3.

The Spad compiler accepts the Spad language and generates a set of
files used by the interpreter, detailed in Volume 5.

The compiler does not produce stand-alone executable code. 
It assumes that it will run inside the interpreter and that
the code it generates will be loaded into the interpreter.

Some of the routines are common to both the compiler and the
interpreter. Where this happens we have favored the interpreter
volume (Volume 5) as the official source location. In each case
we will make reference to that volume and the code in it. Thus,
the compiler volume should be considered as an extension of the
interpreter document.

This volume will go into painful detail of every aspect of compiling
Spad code. We will start by defining the input to, and output from the
compiler so we know what we are trying to achieve.

Next we will look at the top level data structures used by the compiler.
Unfortunately, the compiler uses a large number of ``global variables''
to pass information and alter control flow. Some of these are used by
many routines and some of these are very local to a small subset or a
recursion. We will cover the minor ones as they arise.

Next we examine the Pratt parser idea and the Led and Nud concepts,
which is used to drive the low level parsing.

Following that we journey deep into the code, trying our best not to
get lost in the details. The code is introduced based on ``motivation''
rather than in strict execution order or related concept order. We do
this to try to make the compiler a ``readable novel'' rather than a
mud-march through the code. The goal is to keep the reader's interest
while trying to be exact. Sometimes this will require detours to 
discuss subtopics. 

``Motivating'' a piece of software is a not-very-well established form
of narrative writing so we assume your forgiveness if we get it wrong.
Worse yet, some of the pieces of the system are ``legacy'', in that they
are no longer used and should be removed. Other parts of the system may
have very weak descriptions because we simply do not understand them 
either. Since this is a living document and the code for the system is
actually the code you are reading we will expand parts as we go.


\section{The Input}
\begin{verbatim}
)abbrev domain EQ Equation
--FOR THE BENEFIT  OF LIBAX0 GENERATION
++ Author: Stephen M. Watt, enhancements by Johannes Grabmeier
++ Date Created: April 1985
++ Date Last Updated: June 3, 1991; September 2, 1992
++ Basic Operations: =
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++ Equations as mathematical objects.  All properties of the basis domain,
++ e.g. being an abelian group are carried over the equation domain, by
++ performing the structural operations on the left and on the
++ right hand side.
--   The interpreter translates "=" to "equation".  Otherwise, it will
--   find a modemap for "=" in the domain of the arguments.

Equation(S: Type): public == private where
  Ex ==> OutputForm
  public ==> Type with
    "=": (S, S) -> $
        ++ a=b creates an equation.
    equation: (S, S) -> $
        ++ equation(a,b) creates an equation.
    swap: $ -> $
        ++ swap(eq) interchanges left and right hand side of equation eq.
    lhs: $ -> S
        ++ lhs(eqn) returns the left hand side of equation eqn.
    rhs: $ -> S
        ++ rhs(eqn) returns the right hand side of equation eqn.
    map: (S -> S, $) -> $
        ++ map(f,eqn) constructs a new equation by applying f to both
        ++ sides of eqn.
    if S has InnerEvalable(Symbol,S) then
             InnerEvalable(Symbol,S)
    if S has SetCategory then
        SetCategory
        CoercibleTo Boolean
        if S has Evalable(S) then
           eval: ($, $) -> $
            ++ eval(eqn, x=f) replaces x by f in equation eqn.
           eval: ($, List $) -> $
            ++ eval(eqn, [x1=v1, ... xn=vn]) replaces xi by vi in equation eqn.
    if S has AbelianSemiGroup then
        AbelianSemiGroup
        "+": (S, $) -> $
            ++ x+eqn produces a new equation by adding x to both sides of
            ++ equation eqn.
        "+": ($, S) -> $
            ++ eqn+x produces a new equation by adding x to  both sides of
            ++ equation eqn.
    if S has AbelianGroup then
        AbelianGroup
        leftZero : $ -> $
          ++ leftZero(eq) subtracts the left hand side.
        rightZero : $ -> $
          ++ rightZero(eq) subtracts the right hand side.
        "-": (S, $) -> $
            ++ x-eqn produces a new equation by subtracting both sides of
            ++ equation eqn from x.
        "-": ($, S) -> $
            ++ eqn-x produces a new equation by subtracting x from  
            ++ both sides of equation eqn.
    if S has SemiGroup then
        SemiGroup
        "*": (S, $) -> $
            ++ x*eqn produces a new equation by multiplying both sides of
            ++ equation eqn by x.
        "*": ($, S) -> $
            ++ eqn*x produces a new equation by multiplying both sides of
            ++ equation eqn by x.
    if S has Monoid then
        Monoid
        leftOne : $ -> Union($,"failed")
          ++ leftOne(eq) divides by the left hand side, if possible.
        rightOne : $ -> Union($,"failed")
          ++ rightOne(eq) divides by the right hand side, if possible.
    if S has Group then
        Group
        leftOne : $ -> Union($,"failed")
          ++ leftOne(eq) divides by the left hand side.
        rightOne : $ -> Union($,"failed")
          ++ rightOne(eq) divides by the right hand side.
    if S has Ring then
      Ring
      BiModule(S,S)
    if S has CommutativeRing then
      Module(S)
      --Algebra(S)
    if S has IntegralDomain then
      factorAndSplit : $ -> List $
        ++ factorAndSplit(eq) make the right hand side 0 and
        ++ factors the new left hand side. Each factor is equated
        ++ to 0 and put into the resulting list without repetitions.
    if S has PartialDifferentialRing(Symbol) then
      PartialDifferentialRing(Symbol)
    if S has Field then
      VectorSpace(S)
      "/": ($, $) -> $
          ++ e1/e2 produces a new equation by dividing the left and right
          ++ hand sides of equations e1 and e2.
      inv: $ -> $
          ++ inv(x) returns the multiplicative inverse of x.
    if S has ExpressionSpace then
        subst: ($, $) -> $
             ++ subst(eq1,eq2) substitutes eq2 into both sides of eq1
             ++ the lhs of eq2 should be a kernel

  private ==> add
    Rep := Record(lhs: S, rhs: S)
    eq1,eq2: $
    s : S
    if S has IntegralDomain then
        factorAndSplit eq ==
          (S has factor : S -> Factored S) =>
            eq0 := rightZero eq
            [equation(rcf.factor,0) for rcf in factors factor lhs eq0]
          [eq]
    l:S = r:S      == [l, r]
    equation(l, r) == [l, r]    -- hack!  See comment above.
    lhs eqn        == eqn.lhs
    rhs eqn        == eqn.rhs
    swap eqn     == [rhs eqn, lhs eqn]
    map(fn, eqn)   == equation(fn(eqn.lhs), fn(eqn.rhs))

    if S has InnerEvalable(Symbol,S) then
        s:Symbol
        ls:List Symbol
        x:S
        lx:List S
        eval(eqn,s,x) == eval(eqn.lhs,s,x) = eval(eqn.rhs,s,x)
        eval(eqn,ls,lx) == eval(eqn.lhs,ls,lx) = eval(eqn.rhs,ls,lx)
    if S has Evalable(S) then
        eval(eqn1:$, eqn2:$):$ ==
           eval(eqn1.lhs, eqn2 pretend Equation S) =
               eval(eqn1.rhs, eqn2 pretend Equation S)
        eval(eqn1:$, leqn2:List $):$ ==
           eval(eqn1.lhs, leqn2 pretend List Equation S) =
               eval(eqn1.rhs, leqn2 pretend List Equation S)
    if S has SetCategory then
        eq1 = eq2 == (eq1.lhs = eq2.lhs)@Boolean and
                     (eq1.rhs = eq2.rhs)@Boolean
        coerce(eqn:$):Ex == eqn.lhs::Ex = eqn.rhs::Ex
        coerce(eqn:$):Boolean == eqn.lhs = eqn.rhs
    if S has AbelianSemiGroup then
        eq1 + eq2 == eq1.lhs + eq2.lhs = eq1.rhs + eq2.rhs
        s + eq2 == [s,s] + eq2
        eq1 + s == eq1 + [s,s]
    if S has AbelianGroup then
        - eq == (- lhs eq) = (-rhs eq)
        s - eq2 == [s,s] - eq2
        eq1 - s == eq1 - [s,s]
        leftZero eq == 0 = rhs eq - lhs eq
        rightZero eq == lhs eq - rhs eq = 0
        0 == equation(0$S,0$S)
        eq1 - eq2 == eq1.lhs - eq2.lhs = eq1.rhs - eq2.rhs
    if S has SemiGroup then
        eq1:$ * eq2:$ == eq1.lhs * eq2.lhs = eq1.rhs * eq2.rhs
        l:S   * eqn:$ == l       * eqn.lhs = l       * eqn.rhs
        l:S * eqn:$  ==  l * eqn.lhs    =    l * eqn.rhs
        eqn:$ * l:S  ==  eqn.lhs * l    =    eqn.rhs * l
        -- We have to be a bit careful here: raising to a +ve integer is OK
        -- (since it's the equivalent of repeated multiplication)
        -- but other powers may cause contradictions
        -- Watch what else you add here! JHD 2/Aug 1990
    if S has Monoid then
        1 == equation(1$S,1$S)
        recip eq ==
          (lh := recip lhs eq) case "failed" => "failed"
          (rh := recip rhs eq) case "failed" => "failed"
          [lh :: S, rh :: S]
        leftOne eq ==
          (re := recip lhs eq) case "failed" => "failed"
          1 = rhs eq * re
        rightOne eq ==
          (re := recip rhs eq) case "failed" => "failed"
          lhs eq * re = 1
    if S has Group then
        inv eq == [inv lhs eq, inv rhs eq]
        leftOne eq == 1 = rhs eq * inv rhs eq
        rightOne eq == lhs eq * inv rhs eq = 1
    if S has Ring then
        characteristic() == characteristic()$S
        i:Integer * eq:$ == (i::S) * eq
    if S has IntegralDomain then
        factorAndSplit eq ==
          (S has factor : S -> Factored S) =>
            eq0 := rightZero eq
            [equation(rcf.factor,0) for rcf in factors factor lhs eq0]
          (S has Polynomial Integer) =>
            eq0 := rightZero eq
            MF ==> MultivariateFactorize(Symbol, IndexedExponents Symbol, _
               Integer, Polynomial Integer)
            p : Polynomial Integer := (lhs eq0) pretend Polynomial Integer
            [equation((rcf.factor) pretend S,0) for rcf in factors factor(p)$MF]
          [eq]
    if S has PartialDifferentialRing(Symbol) then
        differentiate(eq:$, sym:Symbol):$ ==
           [differentiate(lhs eq, sym), differentiate(rhs eq, sym)]
    if S has Field then
        dimension() == 2 :: CardinalNumber
        eq1:$ / eq2:$ == eq1.lhs / eq2.lhs = eq1.rhs / eq2.rhs
        inv eq == [inv lhs eq, inv rhs eq]
    if S has ExpressionSpace then
        subst(eq1,eq2) ==
            eq3 := eq2 pretend Equation S
            [subst(lhs eq1,eq3),subst(rhs eq1,eq3)]

\end{verbatim}

\section{The Output, the EQ.nrlib directory}
The Spad compiler generates several files in a directory named after
the input abbreviation. The input file contains an abbreviation line:
\begin{verbatim}
)abbrev domain EQ Equation
\end{verbatim}
for each category, domain, or package. The abbreviation line has 3 parts.
\begin{itemize}
\item one of ``category'', ``domain'', or ``package''
\item the abbreviation for this domain (8 Uppercase Characters maximum)
\item the name of this domain
\end{itemize}

Since the abbreviation for the Equation domain is EQ, the compiler will
put all of its output into a subdirectory called ``EQ.nrlib''. The ``nrlib''
is a port of a very old VMLisp file format, simulated with directories.

For the EQ input file, the compiler will create the following output files,
each of which we will explain in detail below.

\begin{verbatim}
  /research/test/int/algebra/EQ.nrlib:
  used 216 available 4992900
  drwxr-xr-x    2 root root  4096 2010-12-09 11:20 .
  drwxr-xr-x 1259 root root 73728 2010-12-09 11:43 ..
  -rw-r--r--    1 root root 19228 2010-12-09 11:20 code.lsp
  -rw-r--r--    1 root root 34074 2010-12-09 11:20 code.o
  -rw-r--r--    1 root root 13543 2010-12-09 11:20 EQ.fn
  -rw-r--r--    1 root root 19228 2010-12-09 11:20 EQ.lsp
  -rw-r--r--    1 root root 36148 2010-12-09 11:20 index.kaf
  -rw-r--r--    1 root root  6236 2010-12-09 11:20 info
\end{verbatim}

\section{The code.lsp and EQ.lsp files}
\begin{verbatim}

(/VERSIONCHECK 2) 

(DEFUN |EQ;factorAndSplit;$L;1| (|eq| $)
  (PROG (|eq0| #:G1403 |rcf| #:G1404)
    (RETURN
      (SEQ (COND
             ((|HasSignature| (QREFELT $ 6)
                  (LIST '|factor|
                        (LIST (LIST '|Factored|
                                    (|devaluate| (QREFELT $ 6)))
                              (|devaluate| (QREFELT $ 6)))))
              (SEQ (LETT |eq0| (SPADCALL |eq| (QREFELT $ 8))
                         |EQ;factorAndSplit;$L;1|)
                   (EXIT (PROGN
                           (LETT #:G1403 NIL |EQ;factorAndSplit;$L;1|)
                           (SEQ (LETT |rcf| NIL
                                      |EQ;factorAndSplit;$L;1|)
                                (LETT #:G1404
                                      (SPADCALL
                                       (SPADCALL
                                        (SPADCALL |eq0| (QREFELT $ 9))
                                        (QREFELT $ 11))
                                       (QREFELT $ 15))
                                      |EQ;factorAndSplit;$L;1|)
                                G190
                                (COND
                                  ((OR (ATOM #:G1404)
                                    (PROGN
                                      (LETT |rcf| (CAR #:G1404)
                                       |EQ;factorAndSplit;$L;1|)
                                      NIL))
                                   (GO G191)))
                                (SEQ (EXIT
                                      (LETT #:G1403
                                       (CONS
                                        (SPADCALL (QCAR |rcf|)
                                         (|spadConstant| $ 16)
                                         (QREFELT $ 17))
                                        #:G1403)
                                       |EQ;factorAndSplit;$L;1|)))
                                (LETT #:G1404 (CDR #:G1404)
                                      |EQ;factorAndSplit;$L;1|)
                                (GO G190) G191
                                (EXIT (NREVERSE0 #:G1403)))))))
             ('T (LIST |eq|)))))))

(PUT (QUOTE |EQ;=;2S$;2|) (QUOTE |SPADreplace|) (QUOTE CONS)) 

(DEFUN |EQ;=;2S$;2| (|l| |r| $) (CONS |l| |r|)) 

(PUT (QUOTE |EQ;equation;2S$;3|) (QUOTE |SPADreplace|) (QUOTE CONS)) 

(DEFUN |EQ;equation;2S$;3| (|l| |r| $) (CONS |l| |r|)) 

(PUT (QUOTE |EQ;lhs;$S;4|) (QUOTE |SPADreplace|) (QUOTE QCAR)) 

(DEFUN |EQ;lhs;$S;4| (|eqn| $) (QCAR |eqn|)) 

(PUT (QUOTE |EQ;rhs;$S;5|) (QUOTE |SPADreplace|) (QUOTE QCDR)) 

(DEFUN |EQ;rhs;$S;5| (|eqn| $) (QCDR |eqn|)) 

(DEFUN |EQ;swap;2$;6| (|eqn| $) (CONS (SPADCALL |eqn| (QREFELT $ 21))
 (SPADCALL |eqn| (QREFELT $ 9)))) 

(DEFUN |EQ;map;M2$;7| (|fn| |eqn| $)
 (SPADCALL
  (SPADCALL (QCAR |eqn|) |fn|)
  (SPADCALL (QCDR |eqn|) |fn|)
  (QREFELT $ 17))) 

(DEFUN |EQ;eval;$SS$;8| (|eqn| |s| |x| $)
 (SPADCALL
  (SPADCALL (QCAR |eqn|) |s| |x| (QREFELT $ 26))
  (SPADCALL (QCDR |eqn|) |s| |x| (QREFELT $ 26))
  (QREFELT $ 20))) 

(DEFUN |EQ;eval;$LL$;9| (|eqn| |ls| |lx| $)
 (SPADCALL
  (SPADCALL (QCAR |eqn|) |ls| |lx| (QREFELT $ 30))
  (SPADCALL (QCDR |eqn|) |ls| |lx| (QREFELT $ 30))
  (QREFELT $ 20))) 

(DEFUN |EQ;eval;3$;10| (|eqn1| |eqn2| $)
 (SPADCALL
  (SPADCALL (QCAR |eqn1|) |eqn2| (QREFELT $ 33))
  (SPADCALL (QCDR |eqn1|) |eqn2| (QREFELT $ 33))
  (QREFELT $ 20))) 

(DEFUN |EQ;eval;$L$;11| (|eqn1| |leqn2| $)
 (SPADCALL
  (SPADCALL (QCAR |eqn1|) |leqn2| (QREFELT $ 36))
  (SPADCALL (QCDR |eqn1|) |leqn2| (QREFELT $ 36))
  (QREFELT $ 20))) 

(DEFUN |EQ;=;2$B;12| (|eq1| |eq2| $)
 (COND
  ((SPADCALL (QCAR |eq1|) (QCAR |eq2|) (QREFELT $ 39))
   (SPADCALL (QCDR |eq1|) (QCDR |eq2|) (QREFELT $ 39)))
  ((QUOTE T) (QUOTE NIL)))) 

(DEFUN |EQ;coerce;$Of;13| (|eqn| $)
 (SPADCALL
  (SPADCALL (QCAR |eqn|) (QREFELT $ 42))
  (SPADCALL (QCDR |eqn|) (QREFELT $ 42))
  (QREFELT $ 43))) 

(DEFUN |EQ;coerce;$B;14| (|eqn| $)
 (SPADCALL (QCAR |eqn|) (QCDR |eqn|) (QREFELT $ 39))) 

(DEFUN |EQ;+;3$;15| (|eq1| |eq2| $)
 (SPADCALL
  (SPADCALL (QCAR |eq1|) (QCAR |eq2|) (QREFELT $ 46))
  (SPADCALL (QCDR |eq1|) (QCDR |eq2|) (QREFELT $ 46))
  (QREFELT $ 20))) 

(DEFUN |EQ;+;S2$;16| (|s| |eq2| $)
 (SPADCALL (CONS |s| |s|) |eq2| (QREFELT $ 47))) 

(DEFUN |EQ;+;$S$;17| (|eq1| |s| $)
 (SPADCALL |eq1| (CONS |s| |s|) (QREFELT $ 47))) 

(DEFUN |EQ;-;2$;18| (|eq| $)
 (SPADCALL
  (SPADCALL (SPADCALL |eq| (QREFELT $ 9)) (QREFELT $ 50))
  (SPADCALL (SPADCALL |eq| (QREFELT $ 21)) (QREFELT $ 50))
  (QREFELT $ 20))) 

(DEFUN |EQ;-;S2$;19| (|s| |eq2| $)
 (SPADCALL (CONS |s| |s|) |eq2| (QREFELT $ 52))) 

(DEFUN |EQ;-;$S$;20| (|eq1| |s| $)
 (SPADCALL |eq1| (CONS |s| |s|) (QREFELT $ 52))) 

(DEFUN |EQ;leftZero;2$;21| (|eq| $)
 (SPADCALL
  (|spadConstant| $ 16)
  (SPADCALL
   (SPADCALL |eq| (QREFELT $ 21))
   (SPADCALL |eq| (QREFELT $ 9))
   (QREFELT $ 56))
  (QREFELT $ 20))) 

(DEFUN |EQ;rightZero;2$;22| (|eq| $)
 (SPADCALL
  (SPADCALL
   (SPADCALL |eq| (QREFELT $ 9))
   (SPADCALL |eq| (QREFELT $ 21))
   (QREFELT $ 56))
  (|spadConstant| $ 16)
  (QREFELT $ 20))) 

(DEFUN |EQ;Zero;$;23| ($)
 (SPADCALL (|spadConstant| $ 16) (|spadConstant| $ 16) (QREFELT $ 17))) 

(DEFUN |EQ;-;3$;24| (|eq1| |eq2| $)
 (SPADCALL
  (SPADCALL (QCAR |eq1|) (QCAR |eq2|) (QREFELT $ 56))
  (SPADCALL (QCDR |eq1|) (QCDR |eq2|) (QREFELT $ 56))
  (QREFELT $ 20))) 

(DEFUN |EQ;*;3$;25| (|eq1| |eq2| $)
 (SPADCALL
  (SPADCALL (QCAR |eq1|) (QCAR |eq2|) (QREFELT $ 58))
  (SPADCALL (QCDR |eq1|) (QCDR |eq2|) (QREFELT $ 58))
  (QREFELT $ 20))) 

(DEFUN |EQ;*;S2$;26| (|l| |eqn| $)
 (SPADCALL
  (SPADCALL |l| (QCAR |eqn|) (QREFELT $ 58))
  (SPADCALL |l| (QCDR |eqn|) (QREFELT $ 58))
  (QREFELT $ 20))) 

(DEFUN |EQ;*;S2$;27| (|l| |eqn| $)
 (SPADCALL
  (SPADCALL |l| (QCAR |eqn|) (QREFELT $ 58))
  (SPADCALL |l| (QCDR |eqn|) (QREFELT $ 58))
  (QREFELT $ 20))) 

(DEFUN |EQ;*;$S$;28| (|eqn| |l| $)
 (SPADCALL
  (SPADCALL (QCAR |eqn|) |l| (QREFELT $ 58))
  (SPADCALL (QCDR |eqn|) |l| (QREFELT $ 58))
  (QREFELT $ 20))) 

(DEFUN |EQ;One;$;29| ($)
 (SPADCALL (|spadConstant| $ 62) (|spadConstant| $ 62) (QREFELT $ 17))) 

(DEFUN |EQ;recip;$U;30| (|eq| $)
 (PROG (|lh| |rh|)
  (RETURN
   (SEQ
    (LETT |lh|
     (SPADCALL (SPADCALL |eq| (QREFELT $ 9)) (QREFELT $ 65))
     |EQ;recip;$U;30|)
    (EXIT
     (COND
      ((QEQCAR |lh| 1) (CONS 1 "failed"))
      ('T
       (SEQ
        (LETT |rh|
         (SPADCALL (SPADCALL |eq| (QREFELT $ 21)) (QREFELT $ 65))
         |EQ;recip;$U;30|)
        (EXIT
         (COND
          ((QEQCAR |rh| 1) (CONS 1 "failed"))
          ('T
            (CONS 0
             (CONS (QCDR |lh|) (QCDR |rh|))))))))))))))

(DEFUN |EQ;leftOne;$U;31| (|eq| $)
 (PROG (|re|)
  (RETURN
   (SEQ
    (LETT |re|
     (SPADCALL (SPADCALL |eq| (QREFELT $ 9)) (QREFELT $ 65))
     |EQ;leftOne;$U;31|)
    (EXIT
     (COND
      ((QEQCAR |re| 1) (CONS 1 "failed"))
      ('T
       (CONS 0
        (SPADCALL
         (|spadConstant| $ 62)
         (SPADCALL (SPADCALL |eq| (QREFELT $ 21)) (QCDR |re|) (QREFELT $ 58))
         (QREFELT $ 20))))))))))



(DEFUN |EQ;rightOne;$U;32| (|eq| $)
 (PROG (|re|)
  (RETURN
   (SEQ
    (LETT |re|
     (SPADCALL (SPADCALL |eq| (QREFELT $ 21)) (QREFELT $ 65))
     |EQ;rightOne;$U;32|)
    (EXIT
     (COND
      ((QEQCAR |re| 1) (CONS 1 "failed"))
      ('T
       (CONS 0
        (SPADCALL
         (SPADCALL (SPADCALL |eq| (QREFELT $ 9)) (QCDR |re|) (QREFELT $ 58))
         (|spadConstant| $ 62)
         (QREFELT $ 20))))))))))


(DEFUN |EQ;inv;2$;33| (|eq| $)
  (CONS (SPADCALL (SPADCALL |eq| (QREFELT $ 9)) (QREFELT $ 69))
        (SPADCALL (SPADCALL |eq| (QREFELT $ 21)) (QREFELT $ 69))))

(DEFUN |EQ;leftOne;$U;34| (|eq| $)
  (CONS 0
        (SPADCALL (|spadConstant| $ 62)
            (SPADCALL (SPADCALL |eq| (QREFELT $ 21))
                (SPADCALL (SPADCALL |eq| (QREFELT $ 21))
                    (QREFELT $ 69))
                (QREFELT $ 58))
            (QREFELT $ 20))))

(DEFUN |EQ;rightOne;$U;35| (|eq| $)
  (CONS 0
        (SPADCALL
            (SPADCALL (SPADCALL |eq| (QREFELT $ 9))
                (SPADCALL (SPADCALL |eq| (QREFELT $ 21))
                    (QREFELT $ 69))
                (QREFELT $ 58))
            (|spadConstant| $ 62) (QREFELT $ 20))))

(DEFUN |EQ;characteristic;Nni;36| ($) (SPADCALL (QREFELT $ 72))) 

(DEFUN |EQ;*;I2$;37| (|i| |eq| $)
 (SPADCALL (SPADCALL |i| (QREFELT $ 75)) |eq| (QREFELT $ 60))) 

(DEFUN |EQ;factorAndSplit;$L;38| (|eq| $)
  (PROG (#:G1488 #:G1489 |eq0| |p| #:G1490 |rcf| #:G1491)
    (RETURN
      (SEQ (COND
             ((|HasSignature| (QREFELT $ 6)
                  (LIST '|factor|
                        (LIST (LIST '|Factored|
                                    (|devaluate| (QREFELT $ 6)))
                              (|devaluate| (QREFELT $ 6)))))
              (SEQ (LETT |eq0| (SPADCALL |eq| (QREFELT $ 8))
                         |EQ;factorAndSplit;$L;38|)
                   (EXIT (PROGN
                           (LETT #:G1488 NIL |EQ;factorAndSplit;$L;38|)
                           (SEQ (LETT |rcf| NIL
                                      |EQ;factorAndSplit;$L;38|)
                                (LETT #:G1489
                                      (SPADCALL
                                       (SPADCALL
                                        (SPADCALL |eq0| (QREFELT $ 9))
                                        (QREFELT $ 11))
                                       (QREFELT $ 15))
                                      |EQ;factorAndSplit;$L;38|)
                                G190
                                (COND
                                  ((OR (ATOM #:G1489)
                                    (PROGN
                                      (LETT |rcf| (CAR #:G1489)
                                       |EQ;factorAndSplit;$L;38|)
                                      NIL))
                                   (GO G191)))
                                (SEQ (EXIT
                                      (LETT #:G1488
                                       (CONS
                                        (SPADCALL (QCAR |rcf|)
                                         (|spadConstant| $ 16)
                                         (QREFELT $ 17))
                                        #:G1488)
                                       |EQ;factorAndSplit;$L;38|)))
                                (LETT #:G1489 (CDR #:G1489)
                                      |EQ;factorAndSplit;$L;38|)
                                (GO G190) G191
                                (EXIT (NREVERSE0 #:G1488)))))))
             ((EQUAL (QREFELT $ 6) (|Polynomial| (|Integer|)))
              (SEQ (LETT |eq0| (SPADCALL |eq| (QREFELT $ 8))
                         |EQ;factorAndSplit;$L;38|)
                   (LETT |p| (SPADCALL |eq0| (QREFELT $ 9))
                         |EQ;factorAndSplit;$L;38|)
                   (EXIT (PROGN
                           (LETT #:G1490 NIL |EQ;factorAndSplit;$L;38|)
                           (SEQ (LETT |rcf| NIL
                                      |EQ;factorAndSplit;$L;38|)
                                (LETT #:G1491
                                      (SPADCALL
                                       (SPADCALL |p| (QREFELT $ 80))
                                       (QREFELT $ 83))
                                      |EQ;factorAndSplit;$L;38|)
                                G190
                                (COND
                                  ((OR (ATOM #:G1491)
                                    (PROGN
                                      (LETT |rcf| (CAR #:G1491)
                                       |EQ;factorAndSplit;$L;38|)
                                      NIL))
                                   (GO G191)))
                                (SEQ (EXIT
                                      (LETT #:G1490
                                       (CONS
                                        (SPADCALL (QCAR |rcf|)
                                         (|spadConstant| $ 16)
                                         (QREFELT $ 17))
                                        #:G1490)
                                       |EQ;factorAndSplit;$L;38|)))
                                (LETT #:G1491 (CDR #:G1491)
                                      |EQ;factorAndSplit;$L;38|)
                                (GO G190) G191
                                (EXIT (NREVERSE0 #:G1490)))))))
             ('T (LIST |eq|)))))))

(DEFUN |EQ;differentiate;$S$;39| (|eq| |sym| $)
  (CONS (SPADCALL (SPADCALL |eq| (QREFELT $ 9)) |sym| (QREFELT $ 84))
        (SPADCALL (SPADCALL |eq| (QREFELT $ 21)) |sym| (QREFELT $ 84))))


(DEFUN |EQ;dimension;Cn;40| ($) (SPADCALL 2 (QREFELT $ 87))) 

(DEFUN |EQ;/;3$;41| (|eq1| |eq2| $)
  (SPADCALL (SPADCALL (QCAR |eq1|) (QCAR |eq2|) (QREFELT $ 89))
      (SPADCALL (QCDR |eq1|) (QCDR |eq2|) (QREFELT $ 89))
      (QREFELT $ 20)))

(DEFUN |EQ;inv;2$;42| (|eq| $)
  (CONS (SPADCALL (SPADCALL |eq| (QREFELT $ 9)) (QREFELT $ 69))
        (SPADCALL (SPADCALL |eq| (QREFELT $ 21)) (QREFELT $ 69))))

(DEFUN |EQ;subst;3$;43| (|eq1| |eq2| $)
  (PROG (|eq3|)
    (RETURN
      (SEQ (LETT |eq3| |eq2| |EQ;subst;3$;43|)
           (EXIT (CONS (SPADCALL (SPADCALL |eq1| (QREFELT $ 9)) |eq3|
                           (QREFELT $ 92))
                       (SPADCALL (SPADCALL |eq1| (QREFELT $ 21)) |eq3|
                           (QREFELT $ 92))))))))

(DEFUN |Equation| (#:G1503)
 (PROG ()
  (RETURN
   (PROG (#:G1504)
    (RETURN
     (COND
      ((LETT #:G1504
        (|lassocShiftWithFunction|
          (LIST (|devaluate| #:G1503))
          (HGET |$ConstructorCache| '|Equation|)
          '|domainEqualList|)
        |Equation|)
       (|CDRwithIncrement| #:G1504))
      ('T
       (UNWIND-PROTECT
        (PROG1 (|Equation;| #:G1503)
         (LETT #:G1504 T |Equation|))
        (COND
         ((NOT #:G1504) (HREM |$ConstructorCache| '|Equation|)))))))))))

(DEFUN |Equation;| (|#1|)
  (PROG (DV$1 |dv$| $ #:G1502 #:G1501 #:G1500 #:G1499 #:G1498 |pv$|)
    (RETURN
      (PROGN
        (LETT DV$1 (|devaluate| |#1|) |Equation|)
        (LETT |dv$| (LIST '|Equation| DV$1) |Equation|)
        (LETT $ (GETREFV 98) |Equation|)
        (QSETREFV $ 0 |dv$|)
        (QSETREFV $ 3
            (LETT |pv$|
                  (|buildPredVector| 0 0
                      (LIST (|HasCategory| |#1| '(|Field|))
                            (|HasCategory| |#1| '(|SetCategory|))
                            (|HasCategory| |#1| '(|Ring|))
                            (|HasCategory| |#1|
                                '(|PartialDifferentialRing| (|Symbol|)))
                            (OR (|HasCategory| |#1|
                                    '(|PartialDifferentialRing|
                                      (|Symbol|)))
                                (|HasCategory| |#1| '(|Ring|)))
                            (|HasCategory| |#1| '(|Group|))
                            (|HasCategory| |#1|
                                (LIST '|InnerEvalable| '(|Symbol|)
                                      (|devaluate| |#1|)))
                            (AND (|HasCategory| |#1|
                                     (LIST '|Evalable|
                                      (|devaluate| |#1|)))
                                 (|HasCategory| |#1| '(|SetCategory|)))
                            (|HasCategory| |#1| '(|IntegralDomain|))
                            (|HasCategory| |#1| '(|ExpressionSpace|))
                            (OR (|HasCategory| |#1| '(|Field|))
                                (|HasCategory| |#1| '(|Group|)))
                            (OR (|HasCategory| |#1| '(|Group|))
                                (|HasCategory| |#1| '(|Ring|)))
                            (LETT #:G1502
                                  (|HasCategory| |#1|
                                      '(|CommutativeRing|))
                                  |Equation|)
                            (OR #:G1502 (|HasCategory| |#1| '(|Field|))
                                (|HasCategory| |#1| '(|Ring|)))
                            (OR #:G1502
                                (|HasCategory| |#1| '(|Field|)))
                            (LETT #:G1501
                                  (|HasCategory| |#1| '(|Monoid|))
                                  |Equation|)
                            (OR (|HasCategory| |#1| '(|Group|))
                                #:G1501)
                            (LETT #:G1500
                                  (|HasCategory| |#1| '(|SemiGroup|))
                                  |Equation|)
                            (OR (|HasCategory| |#1| '(|Group|)) #:G1501
                                #:G1500)
                            (LETT #:G1499
                                  (|HasCategory| |#1|
                                      '(|AbelianGroup|))
                                  |Equation|)
                            (OR (|HasCategory| |#1|
                                    '(|PartialDifferentialRing|
                                      (|Symbol|)))
                                #:G1499 #:G1502
                                (|HasCategory| |#1| '(|Field|))
                                (|HasCategory| |#1| '(|Ring|)))
                            (OR #:G1499 #:G1501)
                            (LETT #:G1498
                                  (|HasCategory| |#1|
                                      '(|AbelianSemiGroup|))
                                  |Equation|)
                            (OR (|HasCategory| |#1|
                                    '(|PartialDifferentialRing|
                                      (|Symbol|)))
                                #:G1499 #:G1498 #:G1502
                                (|HasCategory| |#1| '(|Field|))
                                (|HasCategory| |#1| '(|Ring|)))
                            (OR (|HasCategory| |#1|
                                    '(|PartialDifferentialRing|
                                      (|Symbol|)))
                                #:G1499 #:G1498 #:G1502
                                (|HasCategory| |#1| '(|Field|))
                                (|HasCategory| |#1| '(|Group|)) #:G1501
                                (|HasCategory| |#1| '(|Ring|)) #:G1500
                                (|HasCategory| |#1| '(|SetCategory|)))))
                  |Equation|))
        (|haddProp| |$ConstructorCache| '|Equation| (LIST DV$1)
            (CONS 1 $))
        (|stuffDomainSlots| $)
        (QSETREFV $ 6 |#1|)
        (QSETREFV $ 7 (|Record| (|:| |lhs| |#1|) (|:| |rhs| |#1|)))
        (COND
          ((|testBitVector| |pv$| 9)
           (QSETREFV $ 19
               (CONS (|dispatchFunction| |EQ;factorAndSplit;$L;1|) $))))
        (COND
          ((|testBitVector| |pv$| 7)
           (PROGN
             (QSETREFV $ 27
                 (CONS (|dispatchFunction| |EQ;eval;$SS$;8|) $))
             (QSETREFV $ 31
                 (CONS (|dispatchFunction| |EQ;eval;$LL$;9|) $)))))
        (COND
          ((|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
           (PROGN
             (QSETREFV $ 34
                 (CONS (|dispatchFunction| |EQ;eval;3$;10|) $))
             (QSETREFV $ 37
                 (CONS (|dispatchFunction| |EQ;eval;$L$;11|) $)))))
        (COND
          ((|testBitVector| |pv$| 2)
           (PROGN
             (QSETREFV $ 40
                 (CONS (|dispatchFunction| |EQ;=;2$B;12|) $))
             (QSETREFV $ 44
                 (CONS (|dispatchFunction| |EQ;coerce;$Of;13|) $))
             (QSETREFV $ 45
                 (CONS (|dispatchFunction| |EQ;coerce;$B;14|) $)))))
        (COND
          ((|testBitVector| |pv$| 23)
           (PROGN
             (QSETREFV $ 47 (CONS (|dispatchFunction| |EQ;+;3$;15|) $))
             (QSETREFV $ 48
                 (CONS (|dispatchFunction| |EQ;+;S2$;16|) $))
             (QSETREFV $ 49
                 (CONS (|dispatchFunction| |EQ;+;$S$;17|) $)))))
        (COND
          ((|testBitVector| |pv$| 20)
           (PROGN
             (QSETREFV $ 51 (CONS (|dispatchFunction| |EQ;-;2$;18|) $))
             (QSETREFV $ 53
                 (CONS (|dispatchFunction| |EQ;-;S2$;19|) $))
             (QSETREFV $ 54
                 (CONS (|dispatchFunction| |EQ;-;$S$;20|) $))
             (QSETREFV $ 57
                 (CONS (|dispatchFunction| |EQ;leftZero;2$;21|) $))
             (QSETREFV $ 8
                 (CONS (|dispatchFunction| |EQ;rightZero;2$;22|) $))
             (QSETREFV $ 55
                 (CONS IDENTITY
                       (FUNCALL (|dispatchFunction| |EQ;Zero;$;23|) $)))
             (QSETREFV $ 52 (CONS (|dispatchFunction| |EQ;-;3$;24|) $)))))
        (COND
          ((|testBitVector| |pv$| 18)
           (PROGN
             (QSETREFV $ 59 (CONS (|dispatchFunction| |EQ;*;3$;25|) $))
             (QSETREFV $ 60
                 (CONS (|dispatchFunction| |EQ;*;S2$;26|) $))
             (QSETREFV $ 60
                 (CONS (|dispatchFunction| |EQ;*;S2$;27|) $))
             (QSETREFV $ 61
                 (CONS (|dispatchFunction| |EQ;*;$S$;28|) $)))))
        (COND
          ((|testBitVector| |pv$| 16)
           (PROGN
             (QSETREFV $ 63
                 (CONS IDENTITY
                       (FUNCALL (|dispatchFunction| |EQ;One;$;29|) $)))
             (QSETREFV $ 66
                 (CONS (|dispatchFunction| |EQ;recip;$U;30|) $))
             (QSETREFV $ 67
                 (CONS (|dispatchFunction| |EQ;leftOne;$U;31|) $))
             (QSETREFV $ 68
                 (CONS (|dispatchFunction| |EQ;rightOne;$U;32|) $)))))
        (COND
          ((|testBitVector| |pv$| 6)
           (PROGN
             (QSETREFV $ 70
                 (CONS (|dispatchFunction| |EQ;inv;2$;33|) $))
             (QSETREFV $ 67
                 (CONS (|dispatchFunction| |EQ;leftOne;$U;34|) $))
             (QSETREFV $ 68
                 (CONS (|dispatchFunction| |EQ;rightOne;$U;35|) $)))))
        (COND
          ((|testBitVector| |pv$| 3)
           (PROGN
             (QSETREFV $ 73
                 (CONS (|dispatchFunction| |EQ;characteristic;Nni;36|)
                       $))
             (QSETREFV $ 76
                 (CONS (|dispatchFunction| |EQ;*;I2$;37|) $)))))
        (COND
          ((|testBitVector| |pv$| 9)
           (QSETREFV $ 19
               (CONS (|dispatchFunction| |EQ;factorAndSplit;$L;38|) $))))
        (COND
          ((|testBitVector| |pv$| 4)
           (QSETREFV $ 85
               (CONS (|dispatchFunction| |EQ;differentiate;$S$;39|) $))))
        (COND
          ((|testBitVector| |pv$| 1)
           (PROGN
             (QSETREFV $ 88
                 (CONS (|dispatchFunction| |EQ;dimension;Cn;40|) $))
             (QSETREFV $ 90 (CONS (|dispatchFunction| |EQ;/;3$;41|) $))
             (QSETREFV $ 70
                 (CONS (|dispatchFunction| |EQ;inv;2$;42|) $)))))
        (COND
          ((|testBitVector| |pv$| 10)
           (QSETREFV $ 93
               (CONS (|dispatchFunction| |EQ;subst;3$;43|) $))))
        $))))

(MAKEPROP '|Equation| '|infovec|
    (LIST '#(NIL NIL NIL NIL NIL NIL (|local| |#1|) '|Rep|
             (0 . |rightZero|) |EQ;lhs;$S;4| (|Factored| $)
             (5 . |factor|)
             (|Record| (|:| |factor| 6) (|:| |exponent| 74))
             (|List| 12) (|Factored| 6) (10 . |factors|) (15 . |Zero|)
             |EQ;equation;2S$;3| (|List| $) (19 . |factorAndSplit|)
             |EQ;=;2S$;2| |EQ;rhs;$S;5| |EQ;swap;2$;6| (|Mapping| 6 6)
             |EQ;map;M2$;7| (|Symbol|) (24 . |eval|) (31 . |eval|)
             (|List| 25) (|List| 6) (38 . |eval|) (45 . |eval|)
             (|Equation| 6) (52 . |eval|) (58 . |eval|) (|List| 32)
             (64 . |eval|) (70 . |eval|) (|Boolean|) (76 . =) (82 . =)
             (|OutputForm|) (88 . |coerce|) (93 . =) (99 . |coerce|)
             (104 . |coerce|) (109 . +) (115 . +) (121 . +) (127 . +)
             (133 . -) (138 . -) (143 . -) (149 . -) (155 . -)
             (161 . |Zero|) (165 . -) (171 . |leftZero|) (176 . *)
             (182 . *) (188 . *) (194 . *) (200 . |One|) (204 . |One|)
             (|Union| $ '"failed") (208 . |recip|) (213 . |recip|)
             (218 . |leftOne|) (223 . |rightOne|) (228 . |inv|)
             (233 . |inv|) (|NonNegativeInteger|)
             (238 . |characteristic|) (242 . |characteristic|)
             (|Integer|) (246 . |coerce|) (251 . *) (|Factored| 78)
             (|Polynomial| 74)
             (|MultivariateFactorize| 25 (|IndexedExponents| 25) 74 78)
             (257 . |factor|)
             (|Record| (|:| |factor| 78) (|:| |exponent| 74))
             (|List| 81) (262 . |factors|) (267 . |differentiate|)
             (273 . |differentiate|) (|CardinalNumber|)
             (279 . |coerce|) (284 . |dimension|) (288 . /) (294 . /)
             (|Equation| $) (300 . |subst|) (306 . |subst|)
             (|PositiveInteger|) (|List| 71) (|SingleInteger|)
             (|String|))
          '#(~= 312 |zero?| 318 |swap| 323 |subtractIfCan| 328 |subst|
             334 |sample| 340 |rightZero| 344 |rightOne| 349 |rhs| 354
             |recip| 359 |one?| 364 |map| 369 |lhs| 375 |leftZero| 380
             |leftOne| 385 |latex| 390 |inv| 395 |hash| 400
             |factorAndSplit| 405 |eval| 410 |equation| 436 |dimension|
             442 |differentiate| 446 |conjugate| 472 |commutator| 478
             |coerce| 484 |characteristic| 499 ^ 503 |Zero| 521 |One|
             525 D 529 = 555 / 567 - 579 + 602 ** 620 * 638)
          '((|unitsKnown| . 12) (|rightUnitary| . 3)
            (|leftUnitary| . 3))
          (CONS (|makeByteWordVec2| 25
                    '(1 15 4 14 5 14 3 5 3 21 21 6 21 17 24 19 25 0 2
                      25 2 7))
                (CONS '#(|VectorSpace&| |Module&|
                         |PartialDifferentialRing&| NIL |Ring&| NIL NIL
                         NIL NIL |AbelianGroup&| NIL |Group&|
                         |AbelianMonoid&| |Monoid&| |AbelianSemiGroup&|
                         |SemiGroup&| |SetCategory&| NIL NIL
                         |BasicType&| NIL |InnerEvalable&|)
                      (CONS '#((|VectorSpace| 6) (|Module| 6)
                               (|PartialDifferentialRing| 25)
                               (|BiModule| 6 6) (|Ring|)
                               (|LeftModule| 6) (|RightModule| 6)
                               (|Rng|) (|LeftModule| $$)
                               (|AbelianGroup|)
                               (|CancellationAbelianMonoid|) (|Group|)
                               (|AbelianMonoid|) (|Monoid|)
                               (|AbelianSemiGroup|) (|SemiGroup|)
                               (|SetCategory|) (|Type|)
                               (|CoercibleTo| 41) (|BasicType|)
                               (|CoercibleTo| 38)
                               (|InnerEvalable| 25 6))
                            (|makeByteWordVec2| 97
                                '(1 0 0 0 8 1 6 10 0 11 1 14 13 0 15 0
                                  6 0 16 1 0 18 0 19 3 6 0 0 25 6 26 3
                                  0 0 0 25 6 27 3 6 0 0 28 29 30 3 0 0
                                  0 28 29 31 2 6 0 0 32 33 2 0 0 0 0 34
                                  2 6 0 0 35 36 2 0 0 0 18 37 2 6 38 0
                                  0 39 2 0 38 0 0 40 1 6 41 0 42 2 41 0
                                  0 0 43 1 0 41 0 44 1 0 38 0 45 2 6 0
                                  0 0 46 2 0 0 0 0 47 2 0 0 6 0 48 2 0
                                  0 0 6 49 1 6 0 0 50 1 0 0 0 51 2 0 0
                                  0 0 52 2 0 0 6 0 53 2 0 0 0 6 54 0 0
                                  0 55 2 6 0 0 0 56 1 0 0 0 57 2 6 0 0
                                  0 58 2 0 0 0 0 59 2 0 0 6 0 60 2 0 0
                                  0 6 61 0 6 0 62 0 0 0 63 1 6 64 0 65
                                  1 0 64 0 66 1 0 64 0 67 1 0 64 0 68 1
                                  6 0 0 69 1 0 0 0 70 0 6 71 72 0 0 71
                                  73 1 6 0 74 75 2 0 0 74 0 76 1 79 77
                                  78 80 1 77 82 0 83 2 6 0 0 25 84 2 0
                                  0 0 25 85 1 86 0 71 87 0 0 86 88 2 6
                                  0 0 0 89 2 0 0 0 0 90 2 6 0 0 91 92 2
                                  0 0 0 0 93 2 2 38 0 0 1 1 20 38 0 1 1
                                  0 0 0 22 2 20 64 0 0 1 2 10 0 0 0 93
                                  0 22 0 1 1 20 0 0 8 1 16 64 0 68 1 0
                                  6 0 21 1 16 64 0 66 1 16 38 0 1 2 0 0
                                  23 0 24 1 0 6 0 9 1 20 0 0 57 1 16 64
                                  0 67 1 2 97 0 1 1 11 0 0 70 1 2 96 0
                                  1 1 9 18 0 19 2 8 0 0 0 34 2 8 0 0 18
                                  37 3 7 0 0 25 6 27 3 7 0 0 28 29 31 2
                                  0 0 6 6 17 0 1 86 88 2 4 0 0 28 1 2 4
                                  0 0 25 85 3 4 0 0 28 95 1 3 4 0 0 25
                                  71 1 2 6 0 0 0 1 2 6 0 0 0 1 1 3 0 74
                                  1 1 2 41 0 44 1 2 38 0 45 0 3 71 73 2
                                  6 0 0 74 1 2 16 0 0 71 1 2 18 0 0 94
                                  1 0 20 0 55 0 16 0 63 2 4 0 0 28 1 2
                                  4 0 0 25 1 3 4 0 0 28 95 1 3 4 0 0 25
                                  71 1 2 2 38 0 0 40 2 0 0 6 6 20 2 11
                                  0 0 0 90 2 1 0 0 6 1 1 20 0 0 51 2 20
                                  0 0 0 52 2 20 0 6 0 53 2 20 0 0 6 54
                                  2 23 0 0 0 47 2 23 0 6 0 48 2 23 0 0
                                  6 49 2 6 0 0 74 1 2 16 0 0 71 1 2 18
                                  0 0 94 1 2 20 0 71 0 1 2 20 0 74 0 76
                                  2 23 0 94 0 1 2 18 0 0 0 59 2 18 0 0
                                  6 61 2 18 0 6 0 60)))))
          '|lookupComplete|))

\end{verbatim}

\section{The code.o file}
The Spad compiler translates the Spad language into Common Lisp.
It eventually invokes the Common Lisp ``compile-file'' command to
output files in binary. Depending on the lisp system this filename
can vary (e.g ``code.fasl''). The details of how these are used
depends on the Common Lisp in use.

By default, Axiom uses Gnu Common Lisp (GCL), which generates ``.o'' files.

\section{The info file}
\begin{verbatim}

((* (($ $ $) (|arguments| (|eq2| . $) (|eq1| . $)) (S (* S S S))
     ($ (= $ S S)))
    (($ $ S) (|arguments| (|l| . S) (|eqn| . $)) (S (* S S S))
     ($ (= $ S S)))
    (($ #0=(|Integer|) $) (|arguments| (|i| . #0#) (|eq| . $))
     (S (|coerce| S (|Integer|))) ($ (* $ S $)))
    (($ S $) (|arguments| (|l| . S) (|eqn| . $)) (S (* S S S))
     ($ (= $ S S))))
 (+ (($ $ $) (|arguments| (|eq2| . $) (|eq1| . $)) (S (+ S S S))
     ($ (= $ S S)))
    (($ $ S) (|arguments| (|s| . S) (|eq1| . $)) ($ (+ $ $ $)))
    (($ S $) (|arguments| (|s| . S) (|eq2| . $)) ($ (+ $ $ $))))
 (- (($ $ $) (|arguments| (|eq2| . $) (|eq1| . $)) (S (- S S S))
     ($ (= $ S S)))
    (($ $ S) (|arguments| (|s| . S) (|eq1| . $)) ($ (- $ $ $)))
    (($ $) (|arguments| (|eq| . $)) (S (- S S))
     ($ (|rhs| S $) (|lhs| S $) (= $ S S)))
    (($ S $) (|arguments| (|s| . S) (|eq2| . $)) ($ (- $ $ $))))
 (/ (($ $ $) (|arguments| (|eq2| . $) (|eq1| . $)) (S (/ S S S))
     ($ (= $ S S))))
 (= (($ S S) (|arguments| (|r| . S) (|l| . S)))
    (((|Boolean|) $ $) ((|Boolean|) (|false| (|Boolean|)))
     (|locals| (#:G1393 |Boolean|))
     (|arguments| (|eq2| . $) (|eq1| . $)) (S (= (|Boolean|) S S))))
 (|One| (($) (S (|One| S)) ($ (|equation| $ S S))))
 (|Zero| (($) (S (|Zero| S)) ($ (|equation| $ S S))))
 (|characteristic|
     (((|NonNegativeInteger|))
      (S (|characteristic| (|NonNegativeInteger|)))))
 (|coerce|
     (((|Boolean|) $) (|arguments| (|eqn| . $))
      (S (= (|Boolean|) S S)))
     (((|OutputForm|) $)
      ((|OutputForm|) (= (|OutputForm|) (|OutputForm|) (|OutputForm|)))
      (|arguments| (|eqn| . $)) (S (|coerce| (|OutputForm|) S))))
 (|constructor|
     (NIL (|locals|
              (|Rep| |Join| (|SetCategory|)
                     (CATEGORY |domain|
                         (SIGNATURE |construct|
                             ((|Record| (|:| |lhs| S) (|:| |rhs| S)) S
                              S))
                         (SIGNATURE |coerce|
                             ((|OutputForm|)
                              (|Record| (|:| |lhs| S) (|:| |rhs| S))))
                         (SIGNATURE |elt|
                             (S (|Record| (|:| |lhs| S) (|:| |rhs| S))
                                "lhs"))
                         (SIGNATURE |elt|
                             (S (|Record| (|:| |lhs| S) (|:| |rhs| S))
                                "rhs"))
                         (SIGNATURE |setelt|
                             (S (|Record| (|:| |lhs| S) (|:| |rhs| S))
                                "lhs" S))
                         (SIGNATURE |setelt|
                             (S (|Record| (|:| |lhs| S) (|:| |rhs| S))
                                "rhs" S))
                         (SIGNATURE |copy|
                             ((|Record| (|:| |lhs| S) (|:| |rhs| S))
                              (|Record| (|:| |lhs| S) (|:| |rhs| S)))))))))
 (|differentiate|
     (($ $ #1=(|Symbol|)) (|arguments| (|sym| . #1#) (|eq| . $))
      (S (|differentiate| S S (|Symbol|))) ($ (|rhs| S $) (|lhs| S $))))
 (|dimension|
     ((#2=(|CardinalNumber|))
      (#2# (|coerce| (|CardinalNumber|) (|NonNegativeInteger|)))))
 (|equation| (($ S S) (|arguments| (|r| . S) (|l| . S))))
 (|eval| (($ $ $) (|arguments| (|eqn2| . $) (|eqn1| . $))
          (S (|eval| S S (|Equation| S))) ($ (= $ S S)))
         (($ $ #3=(|List| $))
          (|arguments| (|leqn2| . #3#) (|eqn1| . $))
          (S (|eval| S S (|List| (|Equation| S)))) ($ (= $ S S)))
         (($ $ #4=(|List| #5=(|Symbol|)) #6=(|List| S))
          (|arguments| (|lx| . #6#) (|ls| . #4#) (|eqn| . $))
          (S (|eval| S S (|List| (|Symbol|)) (|List| S)))
          ($ (= $ S S)))
         (($ $ #5# S) (|arguments| (|x| . S) (|s| . #5#) (|eqn| . $))
          (S (|eval| S S (|Symbol|) S)) ($ (= $ S S))))
 (|factorAndSplit|
     (((|List| $) $)
      ((|MultivariateFactorize| (|Symbol|)
           (|IndexedExponents| (|Symbol|)) (|Integer|)
           (|Polynomial| (|Integer|)))
       (|factor| (|Factored| (|Polynomial| (|Integer|)))
           (|Polynomial| (|Integer|))))
      ((|Factored| S)
       (|factors|
           (|List| (|Record| (|:| |factor| S)
                       (|:| |exponent| (|Integer|))))
           (|Factored| S)))
      ((|Factored| (|Polynomial| (|Integer|)))
       (|factors|
           (|List| (|Record| (|:| |factor| (|Polynomial| (|Integer|)))
                       (|:| |exponent| (|Integer|))))
           (|Factored| (|Polynomial| (|Integer|)))))
      (|locals| (|p| |Polynomial| (|Integer|)) (|eq0| . $))
      (|arguments| (|eq| . $))
      (S (|factor| (|Factored| S) S) (|Zero| S))
      ($ (|rightZero| $ $) (|lhs| S $) (|equation| $ S S))))
 (|inv| (($ $) (|arguments| (|eq| . $)) (S (|inv| S S))
         ($ (|rhs| S $) (|lhs| S $))))
 (|leftOne|
     (((|Union| $ "failed") $) (|locals| (|re| |Union| S "failed"))
      (|arguments| (|eq| . $))
      (S (|recip| (|Union| S "failed") S) (|inv| S S) (|One| S)
         (* S S S))
      ($ (|rhs| S $) (|lhs| S $) (|One| $) (= $ S S))))
 (|leftZero|
     (($ $) (|arguments| (|eq| . $)) (S (|Zero| S) (- S S S))
      ($ (|rhs| S $) (|lhs| S $) (|Zero| $) (= $ S S))))
 (|lhs| ((S $) (|arguments| (|eqn| . $))))
 (|map| (($ #7=(|Mapping| S S) $)
         (|arguments| (|fn| . #7#) (|eqn| . $)) ($ (|equation| $ S S))))
 (|recip| (((|Union| $ "failed") $)
           (|locals| (|rh| |Union| S "failed")
               (|lh| |Union| S "failed"))
           (|arguments| (|eq| . $))
           (S (|recip| (|Union| S "failed") S))
           ($ (|rhs| S $) (|lhs| S $))))
 (|rhs| ((S $) (|arguments| (|eqn| . $))))
 (|rightOne|
     (((|Union| $ "failed") $) (|locals| (|re| |Union| S "failed"))
      (|arguments| (|eq| . $))
      (S (|recip| (|Union| S "failed") S) (|inv| S S) (|One| S)
         (* S S S))
      ($ (|rhs| S $) (|lhs| S $) (= $ S S))))
 (|rightZero|
     (($ $) (|arguments| (|eq| . $)) (S (|Zero| S) (- S S S))
      ($ (|rhs| S $) (|lhs| S $) (= $ S S))))
 (|subst| (($ $ $) (|locals| (|eq3| |Equation| S))
           (|arguments| (|eq2| . $) (|eq1| . $))
           (S (|subst| S S (|Equation| S)))
           ($ (|rhs| S $) (|lhs| S $))))
 (|swap| (($ $) (|arguments| (|eqn| . $)) ($ (|rhs| S $) (|lhs| S $))))) 
\end{verbatim}

\section{The EQ.fn file}
\begin{verbatim}
(in-package 'compiler)(init-fn)
(ADD-FN-DATA '(
#S(FN NAME BOOT::|EQ;*;S2$;26| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;rightOne;$U;32| DEF DEFUN VALUE-TYPE T FUN-VALUES
      NIL CALLEES
      (BOOT::|spadConstant| VMLISP:QCDR CONS VMLISP:QCAR EQL
          BOOT::QEQCAR COND VMLISP:EXIT CDR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL BOOT::LETT VMLISP:SEQ RETURN)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (BOOT::|spadConstant| VMLISP:QCDR VMLISP:QCAR BOOT::QEQCAR COND
          VMLISP:EXIT VMLISP:QREFELT BOOT:SPADCALL BOOT::LETT
          VMLISP:SEQ RETURN)) 
#S(FN NAME BOOT::|EQ;lhs;$S;4| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES (CAR VMLISP:QCAR) RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT
      NIL MACROS (VMLISP:QCAR)) 
#S(FN NAME BOOT::|EQ;+;3$;15| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;dimension;Cn;40| DEF DEFUN VALUE-TYPE T FUN-VALUES
      NIL CALLEES (CDR CAR SVREF VMLISP:QREFELT BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T) NO-EMIT NIL MACROS
      (VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;rightZero;2$;22| DEF DEFUN VALUE-TYPE T FUN-VALUES
      NIL CALLEES
      (BOOT::|spadConstant| CDR CAR SVREF VMLISP:QREFELT BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (BOOT::|spadConstant| VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;coerce;$Of;13| DEF DEFUN VALUE-TYPE T FUN-VALUES
      NIL CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;One;$;29| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (CDR BOOT::|spadConstant| CAR SVREF VMLISP:QREFELT BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T) NO-EMIT NIL MACROS
      (BOOT::|spadConstant| VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;inv;2$;42| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES (CDR CAR SVREF VMLISP:QREFELT BOOT:SPADCALL CONS)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;-;$S$;20| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES (CDR CONS CAR SVREF VMLISP:QREFELT BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;=;2$B;12| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL COND)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL COND)) 
#S(FN NAME BOOT::|EQ;/;3$;41| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;recip;$U;30| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR LIST* CONS VMLISP:QCAR EQL BOOT::QEQCAR COND
          VMLISP:EXIT CDR CAR SVREF VMLISP:QREFELT BOOT:SPADCALL
          BOOT::LETT VMLISP:SEQ RETURN)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR BOOT::QEQCAR COND VMLISP:EXIT
          VMLISP:QREFELT BOOT:SPADCALL BOOT::LETT VMLISP:SEQ RETURN)) 
#S(FN NAME BOOT::|EQ;-;3$;24| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;eval;$L$;11| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;leftZero;2$;21| DEF DEFUN VALUE-TYPE T FUN-VALUES
      NIL CALLEES
      (CDR BOOT::|spadConstant| CAR SVREF VMLISP:QREFELT BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (BOOT::|spadConstant| VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;*;S2$;27| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;*;I2$;37| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES (CDR CAR SVREF VMLISP:QREFELT BOOT:SPADCALL) RETURN-TYPE
      NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;eval;3$;10| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;eval;$SS$;8| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;factorAndSplit;$L;38| DEF DEFUN VALUE-TYPE T
      FUN-VALUES NIL CALLEES
      (BOOT:|Integer| BOOT:|Polynomial| EQUAL BOOT:NREVERSE0
          BOOT::|spadConstant| VMLISP:QCAR CONS ATOM VMLISP:EXIT CDR
          CAR BOOT:SPADCALL BOOT::LETT BOOT::|devaluate| LIST SVREF
          VMLISP:QREFELT BOOT::|HasSignature| COND VMLISP:SEQ RETURN)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (BOOT::|spadConstant| VMLISP:QCAR VMLISP:EXIT BOOT:SPADCALL
          BOOT::LETT VMLISP:QREFELT COND VMLISP:SEQ RETURN)) 
#S(FN NAME BOOT::|EQ;differentiate;$S$;39| DEF DEFUN VALUE-TYPE T
      FUN-VALUES NIL CALLEES
      (CDR CAR SVREF VMLISP:QREFELT BOOT:SPADCALL CONS) RETURN-TYPE NIL
      ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;eval;$LL$;9| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;leftOne;$U;34| DEF DEFUN VALUE-TYPE T FUN-VALUES
      NIL CALLEES
      (CDR BOOT::|spadConstant| CAR SVREF VMLISP:QREFELT BOOT:SPADCALL
           CONS)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (BOOT::|spadConstant| VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;map;M2$;7| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;-;S2$;19| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES (CDR CONS CAR SVREF VMLISP:QREFELT BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;equation;2S$;3| DEF DEFUN VALUE-TYPE T FUN-VALUES
      NIL CALLEES (CONS) RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL
      MACROS NIL) 
#S(FN NAME BOOT::|EQ;+;$S$;17| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES (CDR CONS CAR SVREF VMLISP:QREFELT BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;factorAndSplit;$L;1| DEF DEFUN VALUE-TYPE T
      FUN-VALUES NIL CALLEES
      (BOOT:NREVERSE0 BOOT::|spadConstant| VMLISP:QCAR CONS ATOM
          VMLISP:EXIT CDR CAR BOOT:SPADCALL BOOT::LETT
          BOOT::|devaluate| LIST SVREF VMLISP:QREFELT
          BOOT::|HasSignature| COND VMLISP:SEQ RETURN)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (BOOT::|spadConstant| VMLISP:QCAR VMLISP:EXIT BOOT:SPADCALL
          BOOT::LETT VMLISP:QREFELT COND VMLISP:SEQ RETURN)) 
#S(FN NAME BOOT::|EQ;*;3$;25| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;Zero;$;23| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (CDR BOOT::|spadConstant| CAR SVREF VMLISP:QREFELT BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T) NO-EMIT NIL MACROS
      (BOOT::|spadConstant| VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;characteristic;Nni;36| DEF DEFUN VALUE-TYPE T
      FUN-VALUES NIL CALLEES
      (CDR CAR SVREF VMLISP:QREFELT BOOT:SPADCALL) RETURN-TYPE NIL
      ARG-TYPES (T) NO-EMIT NIL MACROS (VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;leftOne;$U;31| DEF DEFUN VALUE-TYPE T FUN-VALUES
      NIL CALLEES
      (VMLISP:QCDR BOOT::|spadConstant| CONS VMLISP:QCAR EQL
          BOOT::QEQCAR COND VMLISP:EXIT CDR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL BOOT::LETT VMLISP:SEQ RETURN)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR BOOT::|spadConstant| VMLISP:QCAR BOOT::QEQCAR COND
          VMLISP:EXIT VMLISP:QREFELT BOOT:SPADCALL BOOT::LETT
          VMLISP:SEQ RETURN)) 
#S(FN NAME BOOT::|EQ;swap;2$;6| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES (CDR CAR SVREF VMLISP:QREFELT BOOT:SPADCALL CONS)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;-;2$;18| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES (CDR CAR SVREF VMLISP:QREFELT BOOT:SPADCALL) RETURN-TYPE
      NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;subst;3$;43| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (CDR CAR SVREF VMLISP:QREFELT BOOT:SPADCALL CONS VMLISP:EXIT
           BOOT::LETT VMLISP:SEQ RETURN)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QREFELT BOOT:SPADCALL VMLISP:EXIT BOOT::LETT VMLISP:SEQ
          RETURN)) 
#S(FN NAME BOOT::|EQ;=;2S$;2| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES (CONS) RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL
      MACROS NIL) 
#S(FN NAME BOOT::|EQ;*;$S$;28| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (VMLISP:QCDR CDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
          BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;+;S2$;16| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES (CDR CONS CAR SVREF VMLISP:QREFELT BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T T) NO-EMIT NIL MACROS
      (VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|Equation;| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES
      (BOOT::|EQ;One;$;29| BOOT::|EQ;Zero;$;23|
          BOOT::|dispatchFunction| BOOT::|testBitVector| COND
          BOOT::|Record0| BOOT::|Record| BOOT::|stuffDomainSlots| CONS
          BOOT::|haddProp| BOOT::|HasCategory| BOOT::|buildPredVector|
          SYSTEM:SVSET SETF VMLISP:QSETREFV VMLISP:GETREFV LIST
          BOOT::|devaluate| BOOT::LETT RETURN)
      RETURN-TYPE NIL ARG-TYPES (T) NO-EMIT NIL MACROS
      (BOOT::|dispatchFunction| COND BOOT::|Record| SETF
          VMLISP:QSETREFV BOOT::LETT RETURN)) 
#S(FN NAME BOOT::|EQ;coerce;$B;14| DEF DEFUN VALUE-TYPE T FUN-VALUES
      NIL CALLEES
      (CDR VMLISP:QCDR VMLISP:QCAR CAR SVREF VMLISP:QREFELT
           BOOT:SPADCALL)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (VMLISP:QCDR VMLISP:QCAR VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;rhs;$S;5| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES (CDR VMLISP:QCDR) RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT
      NIL MACROS (VMLISP:QCDR)) 
#S(FN NAME OTHER-FORM DEF NIL VALUE-TYPE NIL FUN-VALUES NIL CALLEES NIL
      RETURN-TYPE NIL ARG-TYPES NIL NO-EMIT NIL MACROS NIL) 
#S(FN NAME BOOT::|EQ;inv;2$;33| DEF DEFUN VALUE-TYPE T FUN-VALUES NIL
      CALLEES (CDR CAR SVREF VMLISP:QREFELT BOOT:SPADCALL CONS)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|EQ;rightOne;$U;35| DEF DEFUN VALUE-TYPE T FUN-VALUES
      NIL CALLEES
      (BOOT::|spadConstant| CDR CAR SVREF VMLISP:QREFELT BOOT:SPADCALL
          CONS)
      RETURN-TYPE NIL ARG-TYPES (T T) NO-EMIT NIL MACROS
      (BOOT::|spadConstant| VMLISP:QREFELT BOOT:SPADCALL)) 
#S(FN NAME BOOT::|Equation| DEF DEFUN VALUE-TYPE T FUN-VALUES
      (SINGLE-VALUE) CALLEES
      (REMHASH VMLISP:HREM BOOT::|Equation;| PROG1
               BOOT::|CDRwithIncrement| GETHASH VMLISP:HGET
               BOOT::|devaluate| LIST BOOT::|lassocShiftWithFunction|
               BOOT::LETT COND RETURN)
      RETURN-TYPE NIL ARG-TYPES (T) NO-EMIT NIL MACROS
      (VMLISP:HREM PROG1 VMLISP:HGET BOOT::LETT COND RETURN)) ))\end{verbatim}

\section{The index.kaf file}

Each constructor (e.g. EQ) had one library directory (e.g. EQ.nrlib). 
This directory contained a random access file called the index.kaf file. 
These files contain runtime information such as the operationAlist and
the ConstructorModemap. At system build time we merge all of these 
.nrlib/index.kaf files into one database, INTERP.daase.  Requests to 
get information from this database are cached so that multiple 
references do not cause additional disk i/o.

Before getting into the contents, we need to understand the format of
an {\index index.kaf} file.  The kaf file is a random access file,
originally used as a database. In the current system we make a pass to
combine these files at build time to construct the various {\index daase} 
files.

This is just a file of lisp objects, one after another, in (read) format.

A kaf file starts with an integer, in this case, 35695. This integer gives 
the byte offset to the index. Due to the way the file is constructed, the
index is at the end of the file. To read a kaf file, first read the
integer, then seek to that location in the file, and do a (read).
This will return the index, in this case:
\begin{verbatim}
(("slot1Info" 0 32444)
 ("documentation" 0 29640)
 ("ancestors" 0 28691)
 ("parents" 0 28077)
 ("abbreviation" 0 28074)
 ("predicates" 0 25442)
 ("attributes" 0 25304)
 ("signaturesAndLocals" 0 23933)
 ("superDomain" 0 NIL)
 ("operationAlist" 0 20053)
 ("modemaps" 0 17216)
 ("sourceFile" 0 17179)
 ("constructorCategory" 0 15220)
 ("constructorModemap" 0 13215)
 ("constructorKind" 0 13206)
 ("constructorForm" 0 13191)
 ("compilerInfo" 0 4433)
 ("loadTimeStuff" 0 20))
\end{verbatim}

This is a list of triples. The first item in each triple is a string
that is used as a lookup key (e.g. ``operationAlist''). The second
element is no longer used. The third element is the byte offset from
the beginning of the file.

So to read the ``operationAlist'' from this file you would:
\begin{enumerate}
\item open the index.kaf file
\item (read) the integer
\item (seek) to the integer offset from the beginning of the file
\item (read) the index of triples
\item find the keyword (e.g. ``operationAlist'') triple
\item select the third element, an integer
\item (seek) to the integer offset from the beginning of the file
\item (read) the ``operationAlist''
\end{enumerate}

Note that the information below has been reformatted to fit this 
document. In order to save space the index.kaf file is does not use
prettyprint since it is normally only read by machine. 

\subsection{The index offset byte}
\begin{verbatim}
35695
\end{verbatim}

\subsection{The ``loadTimeStuff''}
\begin{verbatim}
(MAKEPROP '|Equation| '|infovec|
    (LIST '#(NIL NIL NIL NIL NIL NIL (|local| |#1|) '|Rep|
             (0 . |rightZero|) |EQ;lhs;$S;4| (|Factored| $)
             (5 . |factor|)
             (|Record| (|:| |factor| 6) (|:| |exponent| 74))
             (|List| 12) (|Factored| 6) (10 . |factors|) (15 . |Zero|)
             |EQ;equation;2S$;3| (|List| $) (19 . |factorAndSplit|)
             |EQ;=;2S$;2| |EQ;rhs;$S;5| |EQ;swap;2$;6| (|Mapping| 6 6)
             |EQ;map;M2$;7| (|Symbol|) (24 . |eval|) (31 . |eval|)
             (|List| 25) (|List| 6) (38 . |eval|) (45 . |eval|)
             (|Equation| 6) (52 . |eval|) (58 . |eval|) (|List| 32)
             (64 . |eval|) (70 . |eval|) (|Boolean|) (76 . =) (82 . =)
             (|OutputForm|) (88 . |coerce|) (93 . =) (99 . |coerce|)
             (104 . |coerce|) (109 . +) (115 . +) (121 . +) (127 . +)
             (133 . -) (138 . -) (143 . -) (149 . -) (155 . -)
             (161 . |Zero|) (165 . -) (171 . |leftZero|) (176 . *)
             (182 . *) (188 . *) (194 . *) (200 . |One|) (204 . |One|)
             (|Union| $ '"failed") (208 . |recip|) (213 . |recip|)
             (218 . |leftOne|) (223 . |rightOne|) (228 . |inv|)
             (233 . |inv|) (|NonNegativeInteger|)
             (238 . |characteristic|) (242 . |characteristic|)
             (|Integer|) (246 . |coerce|) (251 . *) (|Factored| 78)
             (|Polynomial| 74)
             (|MultivariateFactorize| 25 (|IndexedExponents| 25) 74 78)
             (257 . |factor|)
             (|Record| (|:| |factor| 78) (|:| |exponent| 74))
             (|List| 81) (262 . |factors|) (267 . |differentiate|)
             (273 . |differentiate|) (|CardinalNumber|)
             (279 . |coerce|) (284 . |dimension|) (288 . /) (294 . /)
             (|Equation| $) (300 . |subst|) (306 . |subst|)
             (|PositiveInteger|) (|List| 71) (|SingleInteger|)
             (|String|))
          '#(~= 312 |zero?| 318 |swap| 323 |subtractIfCan| 328 |subst|
             334 |sample| 340 |rightZero| 344 |rightOne| 349 |rhs| 354
             |recip| 359 |one?| 364 |map| 369 |lhs| 375 |leftZero| 380
             |leftOne| 385 |latex| 390 |inv| 395 |hash| 400
             |factorAndSplit| 405 |eval| 410 |equation| 436 |dimension|
             442 |differentiate| 446 |conjugate| 472 |commutator| 478
             |coerce| 484 |characteristic| 499 ^ 503 |Zero| 521 |One|
             525 D 529 = 555 / 567 - 579 + 602 ** 620 * 638)
          '((|unitsKnown| . 12) (|rightUnitary| . 3)
            (|leftUnitary| . 3))
          (CONS (|makeByteWordVec2| 25
                    '(1 15 4 14 5 14 3 5 3 21 21 6 21 17 24 19 25 0 2
                      25 2 7))
                (CONS '#(|VectorSpace&| |Module&|
                         |PartialDifferentialRing&| NIL |Ring&| NIL NIL
                         NIL NIL |AbelianGroup&| NIL |Group&|
                         |AbelianMonoid&| |Monoid&| |AbelianSemiGroup&|
                         |SemiGroup&| |SetCategory&| NIL NIL
                         |BasicType&| NIL |InnerEvalable&|)
                      (CONS '#((|VectorSpace| 6) (|Module| 6)
                               (|PartialDifferentialRing| 25)
                               (|BiModule| 6 6) (|Ring|)
                               (|LeftModule| 6) (|RightModule| 6)
                               (|Rng|) (|LeftModule| $$)
                               (|AbelianGroup|)
                               (|CancellationAbelianMonoid|) (|Group|)
                               (|AbelianMonoid|) (|Monoid|)
                               (|AbelianSemiGroup|) (|SemiGroup|)
                               (|SetCategory|) (|Type|)
                               (|CoercibleTo| 41) (|BasicType|)
                               (|CoercibleTo| 38)
                               (|InnerEvalable| 25 6))
                            (|makeByteWordVec2| 97
                                '(1 0 0 0 8 1 6 10 0 11 1 14 13 0 15 0
                                  6 0 16 1 0 18 0 19 3 6 0 0 25 6 26 3
                                  0 0 0 25 6 27 3 6 0 0 28 29 30 3 0 0
                                  0 28 29 31 2 6 0 0 32 33 2 0 0 0 0 34
                                  2 6 0 0 35 36 2 0 0 0 18 37 2 6 38 0
                                  0 39 2 0 38 0 0 40 1 6 41 0 42 2 41 0
                                  0 0 43 1 0 41 0 44 1 0 38 0 45 2 6 0
                                  0 0 46 2 0 0 0 0 47 2 0 0 6 0 48 2 0
                                  0 0 6 49 1 6 0 0 50 1 0 0 0 51 2 0 0
                                  0 0 52 2 0 0 6 0 53 2 0 0 0 6 54 0 0
                                  0 55 2 6 0 0 0 56 1 0 0 0 57 2 6 0 0
                                  0 58 2 0 0 0 0 59 2 0 0 6 0 60 2 0 0
                                  0 6 61 0 6 0 62 0 0 0 63 1 6 64 0 65
                                  1 0 64 0 66 1 0 64 0 67 1 0 64 0 68 1
                                  6 0 0 69 1 0 0 0 70 0 6 71 72 0 0 71
                                  73 1 6 0 74 75 2 0 0 74 0 76 1 79 77
                                  78 80 1 77 82 0 83 2 6 0 0 25 84 2 0
                                  0 0 25 85 1 86 0 71 87 0 0 86 88 2 6
                                  0 0 0 89 2 0 0 0 0 90 2 6 0 0 91 92 2
                                  0 0 0 0 93 2 2 38 0 0 1 1 20 38 0 1 1
                                  0 0 0 22 2 20 64 0 0 1 2 10 0 0 0 93
                                  0 22 0 1 1 20 0 0 8 1 16 64 0 68 1 0
                                  6 0 21 1 16 64 0 66 1 16 38 0 1 2 0 0
                                  23 0 24 1 0 6 0 9 1 20 0 0 57 1 16 64
                                  0 67 1 2 97 0 1 1 11 0 0 70 1 2 96 0
                                  1 1 9 18 0 19 2 8 0 0 0 34 2 8 0 0 18
                                  37 3 7 0 0 25 6 27 3 7 0 0 28 29 31 2
                                  0 0 6 6 17 0 1 86 88 2 4 0 0 28 1 2 4
                                  0 0 25 85 3 4 0 0 28 95 1 3 4 0 0 25
                                  71 1 2 6 0 0 0 1 2 6 0 0 0 1 1 3 0 74
                                  1 1 2 41 0 44 1 2 38 0 45 0 3 71 73 2
                                  6 0 0 74 1 2 16 0 0 71 1 2 18 0 0 94
                                  1 0 20 0 55 0 16 0 63 2 4 0 0 28 1 2
                                  4 0 0 25 1 3 4 0 0 28 95 1 3 4 0 0 25
                                  71 1 2 2 38 0 0 40 2 0 0 6 6 20 2 11
                                  0 0 0 90 2 1 0 0 6 1 1 20 0 0 51 2 20
                                  0 0 0 52 2 20 0 6 0 53 2 20 0 0 6 54
                                  2 23 0 0 0 47 2 23 0 6 0 48 2 23 0 0
                                  6 49 2 6 0 0 74 1 2 16 0 0 71 1 2 18
                                  0 0 94 1 2 20 0 71 0 1 2 20 0 74 0 76
                                  2 23 0 94 0 1 2 18 0 0 0 59 2 18 0 0
                                  6 61 2 18 0 6 0 60)))))
          '|lookupComplete|))
\end{verbatim}

\subsection{The ``compilerInfo''}
\begin{verbatim}
(SETQ |$CategoryFrame|
      (|put| '|Equation| '|isFunctor|
             '(((|eval| ($ $ (|List| (|Symbol|)) (|List| |#1|)))
                (|has| |#1| (|InnerEvalable| (|Symbol|) |#1|))
                (ELT $ 31))
               ((|eval| ($ $ (|Symbol|) |#1|))
                (|has| |#1| (|InnerEvalable| (|Symbol|) |#1|))
                (ELT $ 27))
               ((~= ((|Boolean|) $ $)) (|has| |#1| (|SetCategory|))
                (ELT $ NIL))
               ((= ((|Boolean|) $ $)) (|has| |#1| (|SetCategory|))
                (ELT $ 40))
               ((|coerce| ((|OutputForm|) $))
                (|has| |#1| (|SetCategory|)) (ELT $ 44))
               ((|hash| ((|SingleInteger|) $))
                (|has| |#1| (|SetCategory|)) (ELT $ NIL))
               ((|latex| ((|String|) $)) (|has| |#1| (|SetCategory|))
                (ELT $ NIL))
               ((|coerce| ((|Boolean|) $)) (|has| |#1| (|SetCategory|))
                (ELT $ 45))
               ((+ ($ $ $)) (|has| |#1| (|AbelianSemiGroup|))
                (ELT $ 47))
               ((* ($ (|PositiveInteger|) $))
                (|has| |#1| (|AbelianSemiGroup|)) (ELT $ NIL))
               ((|Zero| ($)) (|has| |#1| (|AbelianGroup|))
                (CONST $ 55))
               ((|sample| ($))
                (OR (|has| |#1| (|AbelianGroup|))
                    (|has| |#1| (|Monoid|)))
                (CONST $ NIL))
               ((|zero?| ((|Boolean|) $)) (|has| |#1| (|AbelianGroup|))
                (ELT $ NIL))
               ((* ($ (|NonNegativeInteger|) $))
                (|has| |#1| (|AbelianGroup|)) (ELT $ NIL))
               ((|subtractIfCan| ((|Union| $ "failed") $ $))
                (|has| |#1| (|AbelianGroup|)) (ELT $ NIL))
               ((- ($ $)) (|has| |#1| (|AbelianGroup|)) (ELT $ 51))
               ((- ($ $ $)) (|has| |#1| (|AbelianGroup|)) (ELT $ 52))
               ((* ($ (|Integer|) $)) (|has| |#1| (|AbelianGroup|))
                (ELT $ 76))
               ((* ($ $ $)) (|has| |#1| (|SemiGroup|)) (ELT $ 59))
               ((** ($ $ (|PositiveInteger|)))
                (|has| |#1| (|SemiGroup|)) (ELT $ NIL))
               ((^ ($ $ (|PositiveInteger|)))
                (|has| |#1| (|SemiGroup|)) (ELT $ NIL))
               ((|One| ($)) (|has| |#1| (|Monoid|)) (CONST $ 63))
               ((|one?| ((|Boolean|) $)) (|has| |#1| (|Monoid|))
                (ELT $ NIL))
               ((** ($ $ (|NonNegativeInteger|)))
                (|has| |#1| (|Monoid|)) (ELT $ NIL))
               ((^ ($ $ (|NonNegativeInteger|)))
                (|has| |#1| (|Monoid|)) (ELT $ NIL))
               ((|recip| ((|Union| $ "failed") $))
                (|has| |#1| (|Monoid|)) (ELT $ 66))
               ((|inv| ($ $))
                (OR (|has| |#1| (|Field|)) (|has| |#1| (|Group|)))
                (ELT $ 70))
               ((/ ($ $ $))
                (OR (|has| |#1| (|Field|)) (|has| |#1| (|Group|)))
                (ELT $ 90))
               ((** ($ $ (|Integer|))) (|has| |#1| (|Group|))
                (ELT $ NIL))
               ((^ ($ $ (|Integer|))) (|has| |#1| (|Group|))
                (ELT $ NIL))
               ((|conjugate| ($ $ $)) (|has| |#1| (|Group|))
                (ELT $ NIL))
               ((|commutator| ($ $ $)) (|has| |#1| (|Group|))
                (ELT $ NIL))
               ((|characteristic| ((|NonNegativeInteger|)))
                (|has| |#1| (|Ring|)) (ELT $ 73))
               ((|coerce| ($ (|Integer|))) (|has| |#1| (|Ring|))
                (ELT $ NIL))
               ((* ($ |#1| $)) (|has| |#1| (|SemiGroup|)) (ELT $ 60))
               ((* ($ $ |#1|)) (|has| |#1| (|SemiGroup|)) (ELT $ 61))
               ((|differentiate| ($ $ (|Symbol|)))
                (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))
                (ELT $ 85))
               ((|differentiate| ($ $ (|List| (|Symbol|))))
                (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))
                (ELT $ NIL))
               ((|differentiate|
                    ($ $ (|Symbol|) (|NonNegativeInteger|)))
                (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))
                (ELT $ NIL))
               ((|differentiate|
                    ($ $ (|List| (|Symbol|))
                       (|List| (|NonNegativeInteger|))))
                (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))
                (ELT $ NIL))
               ((D ($ $ (|Symbol|)))
                (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))
                (ELT $ NIL))
               ((D ($ $ (|List| (|Symbol|))))
                (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))
                (ELT $ NIL))
               ((D ($ $ (|Symbol|) (|NonNegativeInteger|)))
                (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))
                (ELT $ NIL))
               ((D ($ $ (|List| (|Symbol|))
                      (|List| (|NonNegativeInteger|))))
                (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))
                (ELT $ NIL))
               ((/ ($ $ |#1|)) (|has| |#1| (|Field|)) (ELT $ NIL))
               ((|dimension| ((|CardinalNumber|)))
                (|has| |#1| (|Field|)) (ELT $ 88))
               ((|subst| ($ $ $)) (|has| |#1| (|ExpressionSpace|))
                (ELT $ 93))
               ((|factorAndSplit| ((|List| $) $))
                (|has| |#1| (|IntegralDomain|)) (ELT $ 19))
               ((|rightOne| ((|Union| $ "failed") $))
                (|has| |#1| (|Monoid|)) (ELT $ 68))
               ((|leftOne| ((|Union| $ "failed") $))
                (|has| |#1| (|Monoid|)) (ELT $ 67))
               ((- ($ $ |#1|)) (|has| |#1| (|AbelianGroup|))
                (ELT $ 54))
               ((- ($ |#1| $)) (|has| |#1| (|AbelianGroup|))
                (ELT $ 53))
               ((|rightZero| ($ $)) (|has| |#1| (|AbelianGroup|))
                (ELT $ 8))
               ((|leftZero| ($ $)) (|has| |#1| (|AbelianGroup|))
                (ELT $ 57))
               ((+ ($ $ |#1|)) (|has| |#1| (|AbelianSemiGroup|))
                (ELT $ 49))
               ((+ ($ |#1| $)) (|has| |#1| (|AbelianSemiGroup|))
                (ELT $ 48))
               ((|eval| ($ $ (|List| $)))
                (AND (|has| |#1| (|Evalable| |#1|))
                     (|has| |#1| (|SetCategory|)))
                (ELT $ 37))
               ((|eval| ($ $ $))
                (AND (|has| |#1| (|Evalable| |#1|))
                     (|has| |#1| (|SetCategory|)))
                (ELT $ 34))
               ((|map| ($ (|Mapping| |#1| |#1|) $)) T (ELT $ 24))
               ((|rhs| (|#1| $)) T (ELT $ 21))
               ((|lhs| (|#1| $)) T (ELT $ 9))
               ((|swap| ($ $)) T (ELT $ 22))
               ((|equation| ($ |#1| |#1|)) T (ELT $ 17))
               ((= ($ |#1| |#1|)) T (ELT $ 20)))
             (|addModemap| '|Equation| '(|Equation| |#1|)
                 '((|Join| (|Type|)
                           (CATEGORY |domain|
                               (SIGNATURE = ($ |#1| |#1|))
                               (SIGNATURE |equation| ($ |#1| |#1|))
                               (SIGNATURE |swap| ($ $))
                               (SIGNATURE |lhs| (|#1| $))
                               (SIGNATURE |rhs| (|#1| $))
                               (SIGNATURE |map|
                                   ($ (|Mapping| |#1| |#1|) $))
                               (IF (|has| |#1|
                                    (|InnerEvalable| (|Symbol|) |#1|))
                                   (ATTRIBUTE
                                    (|InnerEvalable| (|Symbol|) |#1|))
                                   |noBranch|)
                               (IF (|has| |#1| (|SetCategory|))
                                   (PROGN
                                     (ATTRIBUTE (|SetCategory|))
                                     (ATTRIBUTE
                                      (|CoercibleTo| (|Boolean|)))
                                     (IF (|has| |#1| (|Evalable| |#1|))
                                      (PROGN
                                        (SIGNATURE |eval| ($ $ $))
                                        (SIGNATURE |eval|
                                         ($ $ (|List| $))))
                                      |noBranch|))
                                   |noBranch|)
                               (IF (|has| |#1| (|AbelianSemiGroup|))
                                   (PROGN
                                     (ATTRIBUTE (|AbelianSemiGroup|))
                                     (SIGNATURE + ($ |#1| $))
                                     (SIGNATURE + ($ $ |#1|)))
                                   |noBranch|)
                               (IF (|has| |#1| (|AbelianGroup|))
                                   (PROGN
                                     (ATTRIBUTE (|AbelianGroup|))
                                     (SIGNATURE |leftZero| ($ $))
                                     (SIGNATURE |rightZero| ($ $))
                                     (SIGNATURE - ($ |#1| $))
                                     (SIGNATURE - ($ $ |#1|)))
                                   |noBranch|)
                               (IF (|has| |#1| (|SemiGroup|))
                                   (PROGN
                                     (ATTRIBUTE (|SemiGroup|))
                                     (SIGNATURE * ($ |#1| $))
                                     (SIGNATURE * ($ $ |#1|)))
                                   |noBranch|)
                               (IF (|has| |#1| (|Monoid|))
                                   (PROGN
                                     (ATTRIBUTE (|Monoid|))
                                     (SIGNATURE |leftOne|
                                      ((|Union| $ "failed") $))
                                     (SIGNATURE |rightOne|
                                      ((|Union| $ "failed") $)))
                                   |noBranch|)
                               (IF (|has| |#1| (|Group|))
                                   (PROGN
                                     (ATTRIBUTE (|Group|))
                                     (SIGNATURE |leftOne|
                                      ((|Union| $ "failed") $))
                                     (SIGNATURE |rightOne|
                                      ((|Union| $ "failed") $)))
                                   |noBranch|)
                               (IF (|has| |#1| (|Ring|))
                                   (PROGN
                                     (ATTRIBUTE (|Ring|))
                                     (ATTRIBUTE (|BiModule| |#1| |#1|)))
                                   |noBranch|)
                               (IF (|has| |#1| (|CommutativeRing|))
                                   (ATTRIBUTE (|Module| |#1|))
                                   |noBranch|)
                               (IF (|has| |#1| (|IntegralDomain|))
                                   (SIGNATURE |factorAndSplit|
                                    ((|List| $) $))
                                   |noBranch|)
                               (IF (|has| |#1|
                                    (|PartialDifferentialRing|
                                     (|Symbol|)))
                                   (ATTRIBUTE
                                    (|PartialDifferentialRing|
                                     (|Symbol|)))
                                   |noBranch|)
                               (IF (|has| |#1| (|Field|))
                                   (PROGN
                                     (ATTRIBUTE (|VectorSpace| |#1|))
                                     (SIGNATURE / ($ $ $))
                                     (SIGNATURE |inv| ($ $)))
                                   |noBranch|)
                               (IF (|has| |#1| (|ExpressionSpace|))
                                   (SIGNATURE |subst| ($ $ $))
                                   |noBranch|)))
                   (|Type|))
                 T '|Equation|
                 (|put| '|Equation| '|mode|
                        '(|Mapping|
                             (|Join| (|Type|)
                                     (CATEGORY |domain|
                                      (SIGNATURE = ($ |#1| |#1|))
                                      (SIGNATURE |equation|
                                       ($ |#1| |#1|))
                                      (SIGNATURE |swap| ($ $))
                                      (SIGNATURE |lhs| (|#1| $))
                                      (SIGNATURE |rhs| (|#1| $))
                                      (SIGNATURE |map|
                                       ($ (|Mapping| |#1| |#1|) $))
                                      (IF
                                       (|has| |#1|
                                        (|InnerEvalable| (|Symbol|)
                                         |#1|))
                                       (ATTRIBUTE
                                        (|InnerEvalable| (|Symbol|)
                                         |#1|))
                                       |noBranch|)
                                      (IF (|has| |#1| (|SetCategory|))
                                       (PROGN
                                         (ATTRIBUTE (|SetCategory|))
                                         (ATTRIBUTE
                                          (|CoercibleTo| (|Boolean|)))
                                         (IF
                                          (|has| |#1|
                                           (|Evalable| |#1|))
                                          (PROGN
                                            (SIGNATURE |eval| ($ $ $))
                                            (SIGNATURE |eval|
                                             ($ $ (|List| $))))
                                          |noBranch|))
                                       |noBranch|)
                                      (IF
                                       (|has| |#1|
                                        (|AbelianSemiGroup|))
                                       (PROGN
                                         (ATTRIBUTE
                                          (|AbelianSemiGroup|))
                                         (SIGNATURE + ($ |#1| $))
                                         (SIGNATURE + ($ $ |#1|)))
                                       |noBranch|)
                                      (IF (|has| |#1| (|AbelianGroup|))
                                       (PROGN
                                         (ATTRIBUTE (|AbelianGroup|))
                                         (SIGNATURE |leftZero| ($ $))
                                         (SIGNATURE |rightZero| ($ $))
                                         (SIGNATURE - ($ |#1| $))
                                         (SIGNATURE - ($ $ |#1|)))
                                       |noBranch|)
                                      (IF (|has| |#1| (|SemiGroup|))
                                       (PROGN
                                         (ATTRIBUTE (|SemiGroup|))
                                         (SIGNATURE * ($ |#1| $))
                                         (SIGNATURE * ($ $ |#1|)))
                                       |noBranch|)
                                      (IF (|has| |#1| (|Monoid|))
                                       (PROGN
                                         (ATTRIBUTE (|Monoid|))
                                         (SIGNATURE |leftOne|
                                          ((|Union| $ "failed") $))
                                         (SIGNATURE |rightOne|
                                          ((|Union| $ "failed") $)))
                                       |noBranch|)
                                      (IF (|has| |#1| (|Group|))
                                       (PROGN
                                         (ATTRIBUTE (|Group|))
                                         (SIGNATURE |leftOne|
                                          ((|Union| $ "failed") $))
                                         (SIGNATURE |rightOne|
                                          ((|Union| $ "failed") $)))
                                       |noBranch|)
                                      (IF (|has| |#1| (|Ring|))
                                       (PROGN
                                         (ATTRIBUTE (|Ring|))
                                         (ATTRIBUTE
                                          (|BiModule| |#1| |#1|)))
                                       |noBranch|)
                                      (IF
                                       (|has| |#1| (|CommutativeRing|))
                                       (ATTRIBUTE (|Module| |#1|))
                                       |noBranch|)
                                      (IF
                                       (|has| |#1| (|IntegralDomain|))
                                       (SIGNATURE |factorAndSplit|
                                        ((|List| $) $))
                                       |noBranch|)
                                      (IF
                                       (|has| |#1|
                                        (|PartialDifferentialRing|
                                         (|Symbol|)))
                                       (ATTRIBUTE
                                        (|PartialDifferentialRing|
                                         (|Symbol|)))
                                       |noBranch|)
                                      (IF (|has| |#1| (|Field|))
                                       (PROGN
                                         (ATTRIBUTE
                                          (|VectorSpace| |#1|))
                                         (SIGNATURE / ($ $ $))
                                         (SIGNATURE |inv| ($ $)))
                                       |noBranch|)
                                      (IF
                                       (|has| |#1| (|ExpressionSpace|))
                                       (SIGNATURE |subst| ($ $ $))
                                       |noBranch|)))
                             (|Type|))
                        |$CategoryFrame|))))
\end{verbatim}

\subsection{The ``constructorForm''}
\begin{verbatim}
(|Equation| S)
\end{verbatim}

\subsection{The ``constructorKind''}
\begin{verbatim}
|domain|
\end{verbatim}

\subsection{The ``constructorModemap''}
\begin{verbatim}
(((|Equation| |#1|)
  (|Join| (|Type|)
          (CATEGORY |domain| (SIGNATURE = ($ |#1| |#1|))
              (SIGNATURE |equation| ($ |#1| |#1|))
              (SIGNATURE |swap| ($ $)) (SIGNATURE |lhs| (|#1| $))
              (SIGNATURE |rhs| (|#1| $))
              (SIGNATURE |map| ($ (|Mapping| |#1| |#1|) $))
              (IF (|has| |#1| (|InnerEvalable| (|Symbol|) |#1|))
                  (ATTRIBUTE (|InnerEvalable| (|Symbol|) |#1|))
                  |noBranch|)
              (IF (|has| |#1| (|SetCategory|))
                  (PROGN
                    (ATTRIBUTE (|SetCategory|))
                    (ATTRIBUTE (|CoercibleTo| (|Boolean|)))
                    (IF (|has| |#1| (|Evalable| |#1|))
                        (PROGN
                          (SIGNATURE |eval| ($ $ $))
                          (SIGNATURE |eval| ($ $ (|List| $))))
                        |noBranch|))
                  |noBranch|)
              (IF (|has| |#1| (|AbelianSemiGroup|))
                  (PROGN
                    (ATTRIBUTE (|AbelianSemiGroup|))
                    (SIGNATURE + ($ |#1| $))
                    (SIGNATURE + ($ $ |#1|)))
                  |noBranch|)
              (IF (|has| |#1| (|AbelianGroup|))
                  (PROGN
                    (ATTRIBUTE (|AbelianGroup|))
                    (SIGNATURE |leftZero| ($ $))
                    (SIGNATURE |rightZero| ($ $))
                    (SIGNATURE - ($ |#1| $))
                    (SIGNATURE - ($ $ |#1|)))
                  |noBranch|)
              (IF (|has| |#1| (|SemiGroup|))
                  (PROGN
                    (ATTRIBUTE (|SemiGroup|))
                    (SIGNATURE * ($ |#1| $))
                    (SIGNATURE * ($ $ |#1|)))
                  |noBranch|)
              (IF (|has| |#1| (|Monoid|))
                  (PROGN
                    (ATTRIBUTE (|Monoid|))
                    (SIGNATURE |leftOne| ((|Union| $ "failed") $))
                    (SIGNATURE |rightOne| ((|Union| $ "failed") $)))
                  |noBranch|)
              (IF (|has| |#1| (|Group|))
                  (PROGN
                    (ATTRIBUTE (|Group|))
                    (SIGNATURE |leftOne| ((|Union| $ "failed") $))
                    (SIGNATURE |rightOne| ((|Union| $ "failed") $)))
                  |noBranch|)
              (IF (|has| |#1| (|Ring|))
                  (PROGN
                    (ATTRIBUTE (|Ring|))
                    (ATTRIBUTE (|BiModule| |#1| |#1|)))
                  |noBranch|)
              (IF (|has| |#1| (|CommutativeRing|))
                  (ATTRIBUTE (|Module| |#1|)) |noBranch|)
              (IF (|has| |#1| (|IntegralDomain|))
                  (SIGNATURE |factorAndSplit| ((|List| $) $))
                  |noBranch|)
              (IF (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))
                  (ATTRIBUTE (|PartialDifferentialRing| (|Symbol|)))
                  |noBranch|)
              (IF (|has| |#1| (|Field|))
                  (PROGN
                    (ATTRIBUTE (|VectorSpace| |#1|))
                    (SIGNATURE / ($ $ $))
                    (SIGNATURE |inv| ($ $)))
                  |noBranch|)
              (IF (|has| |#1| (|ExpressionSpace|))
                  (SIGNATURE |subst| ($ $ $)) |noBranch|)))
  (|Type|))
 (T |Equation|))
\end{verbatim}

\subsection{The ``constructorCategory''}
\begin{verbatim}
(|Join| (|Type|)
        (CATEGORY |domain| (SIGNATURE = ($ |#1| |#1|))
            (SIGNATURE |equation| ($ |#1| |#1|))
            (SIGNATURE |swap| ($ $)) (SIGNATURE |lhs| (|#1| $))
            (SIGNATURE |rhs| (|#1| $))
            (SIGNATURE |map| ($ (|Mapping| |#1| |#1|) $))
            (IF (|has| |#1| (|InnerEvalable| (|Symbol|) |#1|))
                (ATTRIBUTE (|InnerEvalable| (|Symbol|) |#1|))
                |noBranch|)
            (IF (|has| |#1| (|SetCategory|))
                (PROGN
                  (ATTRIBUTE (|SetCategory|))
                  (ATTRIBUTE (|CoercibleTo| (|Boolean|)))
                  (IF (|has| |#1| (|Evalable| |#1|))
                      (PROGN
                        (SIGNATURE |eval| ($ $ $))
                        (SIGNATURE |eval| ($ $ (|List| $))))
                      |noBranch|))
                |noBranch|)
            (IF (|has| |#1| (|AbelianSemiGroup|))
                (PROGN
                  (ATTRIBUTE (|AbelianSemiGroup|))
                  (SIGNATURE + ($ |#1| $))
                  (SIGNATURE + ($ $ |#1|)))
                |noBranch|)
            (IF (|has| |#1| (|AbelianGroup|))
                (PROGN
                  (ATTRIBUTE (|AbelianGroup|))
                  (SIGNATURE |leftZero| ($ $))
                  (SIGNATURE |rightZero| ($ $))
                  (SIGNATURE - ($ |#1| $))
                  (SIGNATURE - ($ $ |#1|)))
                |noBranch|)
            (IF (|has| |#1| (|SemiGroup|))
                (PROGN
                  (ATTRIBUTE (|SemiGroup|))
                  (SIGNATURE * ($ |#1| $))
                  (SIGNATURE * ($ $ |#1|)))
                |noBranch|)
            (IF (|has| |#1| (|Monoid|))
                (PROGN
                  (ATTRIBUTE (|Monoid|))
                  (SIGNATURE |leftOne| ((|Union| $ "failed") $))
                  (SIGNATURE |rightOne| ((|Union| $ "failed") $)))
                |noBranch|)
            (IF (|has| |#1| (|Group|))
                (PROGN
                  (ATTRIBUTE (|Group|))
                  (SIGNATURE |leftOne| ((|Union| $ "failed") $))
                  (SIGNATURE |rightOne| ((|Union| $ "failed") $)))
                |noBranch|)
            (IF (|has| |#1| (|Ring|))
                (PROGN
                  (ATTRIBUTE (|Ring|))
                  (ATTRIBUTE (|BiModule| |#1| |#1|)))
                |noBranch|)
            (IF (|has| |#1| (|CommutativeRing|))
                (ATTRIBUTE (|Module| |#1|)) |noBranch|)
            (IF (|has| |#1| (|IntegralDomain|))
                (SIGNATURE |factorAndSplit| ((|List| $) $)) |noBranch|)
            (IF (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))
                (ATTRIBUTE (|PartialDifferentialRing| (|Symbol|)))
                |noBranch|)
            (IF (|has| |#1| (|Field|))
                (PROGN
                  (ATTRIBUTE (|VectorSpace| |#1|))
                  (SIGNATURE / ($ $ $))
                  (SIGNATURE |inv| ($ $)))
                |noBranch|)
            (IF (|has| |#1| (|ExpressionSpace|))
                (SIGNATURE |subst| ($ $ $)) |noBranch|)))
\end{verbatim}

\subsection{The ``sourceFile''}
\begin{verbatim}
"/research/test/int/algebra/EQ.spad"
\end{verbatim}

\subsection{The ``modemaps''}
\begin{verbatim}
((= (*1 *1 *2 *2)
    (AND (|isDomain| *1 (|Equation| *2)) (|ofCategory| *2 (|Type|))))
 (|equation| (*1 *1 *2 *2)
     (AND (|isDomain| *1 (|Equation| *2)) (|ofCategory| *2 (|Type|))))
 (|swap| (*1 *1 *1)
         (AND (|isDomain| *1 (|Equation| *2))
              (|ofCategory| *2 (|Type|))))
 (|lhs| (*1 *2 *1)
        (AND (|isDomain| *1 (|Equation| *2))
             (|ofCategory| *2 (|Type|))))
 (|rhs| (*1 *2 *1)
        (AND (|isDomain| *1 (|Equation| *2))
             (|ofCategory| *2 (|Type|))))
 (|map| (*1 *1 *2 *1)
        (AND (|isDomain| *2 (|Mapping| *3 *3))
             (|ofCategory| *3 (|Type|))
             (|isDomain| *1 (|Equation| *3))))
 (|eval| (*1 *1 *1 *1)
         (AND (|ofCategory| *2 (|Evalable| *2))
              (|ofCategory| *2 (|SetCategory|))
              (|ofCategory| *2 (|Type|))
              (|isDomain| *1 (|Equation| *2))))
 (|eval| (*1 *1 *1 *2)
         (AND (|isDomain| *2 (|List| (|Equation| *3)))
              (|ofCategory| *3 (|Evalable| *3))
              (|ofCategory| *3 (|SetCategory|))
              (|ofCategory| *3 (|Type|))
              (|isDomain| *1 (|Equation| *3))))
 (+ (*1 *1 *2 *1)
    (AND (|isDomain| *1 (|Equation| *2))
         (|ofCategory| *2 (|AbelianSemiGroup|))
         (|ofCategory| *2 (|Type|))))
 (+ (*1 *1 *1 *2)
    (AND (|isDomain| *1 (|Equation| *2))
         (|ofCategory| *2 (|AbelianSemiGroup|))
         (|ofCategory| *2 (|Type|))))
 (|leftZero| (*1 *1 *1)
     (AND (|isDomain| *1 (|Equation| *2))
          (|ofCategory| *2 (|AbelianGroup|))
          (|ofCategory| *2 (|Type|))))
 (|rightZero| (*1 *1 *1)
     (AND (|isDomain| *1 (|Equation| *2))
          (|ofCategory| *2 (|AbelianGroup|))
          (|ofCategory| *2 (|Type|))))
 (- (*1 *1 *2 *1)
    (AND (|isDomain| *1 (|Equation| *2))
         (|ofCategory| *2 (|AbelianGroup|)) (|ofCategory| *2 (|Type|))))
 (- (*1 *1 *1 *2)
    (AND (|isDomain| *1 (|Equation| *2))
         (|ofCategory| *2 (|AbelianGroup|)) (|ofCategory| *2 (|Type|))))
 (|leftOne| (*1 *1 *1)
     (|partial| AND (|isDomain| *1 (|Equation| *2))
         (|ofCategory| *2 (|Monoid|)) (|ofCategory| *2 (|Type|))))
 (|rightOne| (*1 *1 *1)
     (|partial| AND (|isDomain| *1 (|Equation| *2))
         (|ofCategory| *2 (|Monoid|)) (|ofCategory| *2 (|Type|))))
 (|factorAndSplit| (*1 *2 *1)
     (AND (|isDomain| *2 (|List| (|Equation| *3)))
          (|isDomain| *1 (|Equation| *3))
          (|ofCategory| *3 (|IntegralDomain|))
          (|ofCategory| *3 (|Type|))))
 (|subst| (*1 *1 *1 *1)
          (AND (|isDomain| *1 (|Equation| *2))
               (|ofCategory| *2 (|ExpressionSpace|))
               (|ofCategory| *2 (|Type|))))
 (* (*1 *1 *1 *2)
    (AND (|isDomain| *1 (|Equation| *2))
         (|ofCategory| *2 (|SemiGroup|)) (|ofCategory| *2 (|Type|))))
 (* (*1 *1 *2 *1)
    (AND (|isDomain| *1 (|Equation| *2))
         (|ofCategory| *2 (|SemiGroup|)) (|ofCategory| *2 (|Type|))))
 (/ (*1 *1 *1 *1)
    (OR (AND (|isDomain| *1 (|Equation| *2))
             (|ofCategory| *2 (|Field|)) (|ofCategory| *2 (|Type|)))
        (AND (|isDomain| *1 (|Equation| *2))
             (|ofCategory| *2 (|Group|)) (|ofCategory| *2 (|Type|)))))
 (|inv| (*1 *1 *1)
        (OR (AND (|isDomain| *1 (|Equation| *2))
                 (|ofCategory| *2 (|Field|))
                 (|ofCategory| *2 (|Type|)))
            (AND (|isDomain| *1 (|Equation| *2))
                 (|ofCategory| *2 (|Group|))
                 (|ofCategory| *2 (|Type|))))))
\end{verbatim}

\subsection{The ``operationAlist''}
\begin{verbatim}
((~= (((|Boolean|) $ $) NIL (|has| |#1| (|SetCategory|))))
 (|zero?| (((|Boolean|) $) NIL (|has| |#1| (|AbelianGroup|))))
 (|swap| (($ $) 22))
 (|subtractIfCan|
     (((|Union| $ "failed") $ $) NIL (|has| |#1| (|AbelianGroup|))))
 (|subst| (($ $ $) 93 (|has| |#1| (|ExpressionSpace|))))
 (|sample|
     (($) NIL
      (OR (|has| |#1| (|AbelianGroup|)) (|has| |#1| (|Monoid|))) CONST))
 (|rightZero| (($ $) 8 (|has| |#1| (|AbelianGroup|))))
 (|rightOne| (((|Union| $ "failed") $) 68 (|has| |#1| (|Monoid|))))
 (|rhs| ((|#1| $) 21))
 (|recip| (((|Union| $ "failed") $) 66 (|has| |#1| (|Monoid|))))
 (|one?| (((|Boolean|) $) NIL (|has| |#1| (|Monoid|))))
 (|map| (($ (|Mapping| |#1| |#1|) $) 24)) (|lhs| ((|#1| $) 9))
 (|leftZero| (($ $) 57 (|has| |#1| (|AbelianGroup|))))
 (|leftOne| (((|Union| $ "failed") $) 67 (|has| |#1| (|Monoid|))))
 (|latex| (((|String|) $) NIL (|has| |#1| (|SetCategory|))))
 (|inv| (($ $) 70 (OR (|has| |#1| (|Field|)) (|has| |#1| (|Group|)))))
 (|hash| (((|SingleInteger|) $) NIL (|has| |#1| (|SetCategory|))))
 (|factorAndSplit| (((|List| $) $) 19 (|has| |#1| (|IntegralDomain|))))
 (|eval| (($ $ $) 34
          (AND (|has| |#1| (|Evalable| |#1|))
               (|has| |#1| (|SetCategory|))))
         (($ $ (|List| $)) 37
          (AND (|has| |#1| (|Evalable| |#1|))
               (|has| |#1| (|SetCategory|))))
         (($ $ (|Symbol|) |#1|) 27
          (|has| |#1| (|InnerEvalable| (|Symbol|) |#1|)))
         (($ $ (|List| (|Symbol|)) (|List| |#1|)) 31
          (|has| |#1| (|InnerEvalable| (|Symbol|) |#1|))))
 (|equation| (($ |#1| |#1|) 17))
 (|dimension| (((|CardinalNumber|)) 88 (|has| |#1| (|Field|))))
 (|differentiate|
     (($ $ (|List| (|Symbol|)) (|List| (|NonNegativeInteger|))) NIL
      (|has| |#1| (|PartialDifferentialRing| (|Symbol|))))
     (($ $ (|Symbol|) (|NonNegativeInteger|)) NIL
      (|has| |#1| (|PartialDifferentialRing| (|Symbol|))))
     (($ $ (|List| (|Symbol|))) NIL
      (|has| |#1| (|PartialDifferentialRing| (|Symbol|))))
     (($ $ (|Symbol|)) 85
      (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))))
 (|conjugate| (($ $ $) NIL (|has| |#1| (|Group|))))
 (|commutator| (($ $ $) NIL (|has| |#1| (|Group|))))
 (|coerce| (($ (|Integer|)) NIL (|has| |#1| (|Ring|)))
     (((|Boolean|) $) 45 (|has| |#1| (|SetCategory|)))
     (((|OutputForm|) $) 44 (|has| |#1| (|SetCategory|))))
 (|characteristic| (((|NonNegativeInteger|)) 73 (|has| |#1| (|Ring|))))
 (^ (($ $ (|Integer|)) NIL (|has| |#1| (|Group|)))
    (($ $ (|NonNegativeInteger|)) NIL (|has| |#1| (|Monoid|)))
    (($ $ (|PositiveInteger|)) NIL (|has| |#1| (|SemiGroup|))))
 (|Zero| (($) 55 (|has| |#1| (|AbelianGroup|)) CONST))
 (|One| (($) 63 (|has| |#1| (|Monoid|)) CONST))
 (D (($ $ (|List| (|Symbol|)) (|List| (|NonNegativeInteger|))) NIL
     (|has| |#1| (|PartialDifferentialRing| (|Symbol|))))
    (($ $ (|Symbol|) (|NonNegativeInteger|)) NIL
     (|has| |#1| (|PartialDifferentialRing| (|Symbol|))))
    (($ $ (|List| (|Symbol|))) NIL
     (|has| |#1| (|PartialDifferentialRing| (|Symbol|))))
    (($ $ (|Symbol|)) NIL
     (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))))
 (= (($ |#1| |#1|) 20)
    (((|Boolean|) $ $) 40 (|has| |#1| (|SetCategory|))))
 (/ (($ $ |#1|) NIL (|has| |#1| (|Field|)))
    (($ $ $) 90 (OR (|has| |#1| (|Field|)) (|has| |#1| (|Group|)))))
 (- (($ |#1| $) 53 (|has| |#1| (|AbelianGroup|)))
    (($ $ |#1|) 54 (|has| |#1| (|AbelianGroup|)))
    (($ $ $) 52 (|has| |#1| (|AbelianGroup|)))
    (($ $) 51 (|has| |#1| (|AbelianGroup|))))
 (+ (($ |#1| $) 48 (|has| |#1| (|AbelianSemiGroup|)))
    (($ $ |#1|) 49 (|has| |#1| (|AbelianSemiGroup|)))
    (($ $ $) 47 (|has| |#1| (|AbelianSemiGroup|))))
 (** (($ $ (|Integer|)) NIL (|has| |#1| (|Group|)))
     (($ $ (|NonNegativeInteger|)) NIL (|has| |#1| (|Monoid|)))
     (($ $ (|PositiveInteger|)) NIL (|has| |#1| (|SemiGroup|))))
 (* (($ $ |#1|) 61 (|has| |#1| (|SemiGroup|)))
    (($ |#1| $) 60 (|has| |#1| (|SemiGroup|)))
    (($ $ $) 59 (|has| |#1| (|SemiGroup|)))
    (($ (|Integer|) $) 76 (|has| |#1| (|AbelianGroup|)))
    (($ (|NonNegativeInteger|) $) NIL (|has| |#1| (|AbelianGroup|)))
    (($ (|PositiveInteger|) $) NIL (|has| |#1| (|AbelianSemiGroup|)))))
\end{verbatim}

\subsection{The ``superDomain''}

\subsection{The ``signaturesAndLocals''}
\begin{verbatim}
((|EQ;subst;3$;43| ($ $ $)) (|EQ;inv;2$;42| ($ $))
 (|EQ;/;3$;41| ($ $ $)) (|EQ;dimension;Cn;40| ((|CardinalNumber|)))
 (|EQ;differentiate;$S$;39| ($ $ (|Symbol|)))
 (|EQ;factorAndSplit;$L;38| ((|List| $) $))
 (|EQ;*;I2$;37| ($ (|Integer|) $))
 (|EQ;characteristic;Nni;36| ((|NonNegativeInteger|)))
 (|EQ;rightOne;$U;35| ((|Union| $ "failed") $))
 (|EQ;leftOne;$U;34| ((|Union| $ "failed") $)) (|EQ;inv;2$;33| ($ $))
 (|EQ;rightOne;$U;32| ((|Union| $ "failed") $))
 (|EQ;leftOne;$U;31| ((|Union| $ "failed") $))
 (|EQ;recip;$U;30| ((|Union| $ "failed") $)) (|EQ;One;$;29| ($))
 (|EQ;*;$S$;28| ($ $ S)) (|EQ;*;S2$;27| ($ S $))
 (|EQ;*;S2$;26| ($ S $)) (|EQ;*;3$;25| ($ $ $)) (|EQ;-;3$;24| ($ $ $))
 (|EQ;Zero;$;23| ($)) (|EQ;rightZero;2$;22| ($ $))
 (|EQ;leftZero;2$;21| ($ $)) (|EQ;-;$S$;20| ($ $ S))
 (|EQ;-;S2$;19| ($ S $)) (|EQ;-;2$;18| ($ $)) (|EQ;+;$S$;17| ($ $ S))
 (|EQ;+;S2$;16| ($ S $)) (|EQ;+;3$;15| ($ $ $))
 (|EQ;coerce;$B;14| ((|Boolean|) $))
 (|EQ;coerce;$Of;13| ((|OutputForm|) $))
 (|EQ;=;2$B;12| ((|Boolean|) $ $)) (|EQ;eval;$L$;11| ($ $ (|List| $)))
 (|EQ;eval;3$;10| ($ $ $))
 (|EQ;eval;$LL$;9| ($ $ (|List| (|Symbol|)) (|List| S)))
 (|EQ;eval;$SS$;8| ($ $ (|Symbol|) S))
 (|EQ;map;M2$;7| ($ (|Mapping| S S) $)) (|EQ;swap;2$;6| ($ $))
 (|EQ;rhs;$S;5| (S $)) (|EQ;lhs;$S;4| (S $))
 (|EQ;equation;2S$;3| ($ S S)) (|EQ;=;2S$;2| ($ S S))
 (|EQ;factorAndSplit;$L;1| ((|List| $) $)))
\end{verbatim}

\subsection{The ``attributes''}
\begin{verbatim}
((|unitsKnown| OR (|has| |#1| (|Ring|)) (|has| |#1| (|Group|)))
 (|rightUnitary| |has| |#1| (|Ring|))
 (|leftUnitary| |has| |#1| (|Ring|)))
\end{verbatim}

\subsection{The ``predicates''}
\begin{verbatim}
((|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|SetCategory|))
 (|HasCategory| |#1| '(|Ring|))
 (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
 (OR (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|Group|))
 (|HasCategory| |#1|
     (LIST '|InnerEvalable| '(|Symbol|) (|devaluate| |#1|)))
 (AND (|HasCategory| |#1| (LIST '|Evalable| (|devaluate| |#1|)))
      (|HasCategory| |#1| '(|SetCategory|)))
 (|HasCategory| |#1| '(|IntegralDomain|))
 (|HasCategory| |#1| '(|ExpressionSpace|))
 (OR (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|Group|)))
 (OR (|HasCategory| |#1| '(|Group|)) (|HasCategory| |#1| '(|Ring|)))
 (|HasCategory| |#1| '(|CommutativeRing|))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|Field|)))
 (|HasCategory| |#1| '(|Monoid|))
 (OR (|HasCategory| |#1| '(|Group|)) (|HasCategory| |#1| '(|Monoid|)))
 (|HasCategory| |#1| '(|SemiGroup|))
 (OR (|HasCategory| |#1| '(|Group|)) (|HasCategory| |#1| '(|Monoid|))
     (|HasCategory| |#1| '(|SemiGroup|)))
 (|HasCategory| |#1| '(|AbelianGroup|))
 (OR (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|Monoid|)))
 (|HasCategory| |#1| '(|AbelianSemiGroup|))
 (OR (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|AbelianSemiGroup|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|Ring|)))
 (OR (|HasCategory| |#1| (LIST '|PartialDifferentialRing| '(|Symbol|)))
     (|HasCategory| |#1| '(|AbelianGroup|))
     (|HasCategory| |#1| '(|AbelianSemiGroup|))
     (|HasCategory| |#1| '(|CommutativeRing|))
     (|HasCategory| |#1| '(|Field|)) (|HasCategory| |#1| '(|Group|))
     (|HasCategory| |#1| '(|Monoid|)) (|HasCategory| |#1| '(|Ring|))
     (|HasCategory| |#1| '(|SemiGroup|))
     (|HasCategory| |#1| '(|SetCategory|))))
\end{verbatim}

\subsection{The ``abbreviation''}
\begin{verbatim}
EQ
\end{verbatim}

\subsection{The ``parents''}
\begin{verbatim}
(((|Type|) . T)
 ((|InnerEvalable| (|Symbol|) S) |has| S
  (|InnerEvalable| (|Symbol|) S))
 ((|CoercibleTo| (|Boolean|)) |has| S (|SetCategory|))
 ((|SetCategory|) |has| S (|SetCategory|))
 ((|AbelianSemiGroup|) |has| S (|AbelianSemiGroup|))
 ((|AbelianGroup|) |has| S (|AbelianGroup|))
 ((|SemiGroup|) |has| S (|SemiGroup|)) ((|Monoid|) |has| S (|Monoid|))
 ((|Group|) |has| S (|Group|)) ((|BiModule| S S) |has| S (|Ring|))
 ((|Ring|) |has| S (|Ring|)) ((|Module| S) |has| S (|CommutativeRing|))
 ((|PartialDifferentialRing| (|Symbol|)) |has| S
  (|PartialDifferentialRing| (|Symbol|)))
 ((|VectorSpace| S) |has| S (|Field|)))
\end{verbatim}

\subsection{The ``ancestors''}
\begin{verbatim}
(((|AbelianGroup|) |has| S (|AbelianGroup|))
 ((|AbelianMonoid|) |has| S (|AbelianGroup|))
 ((|AbelianSemiGroup|) |has| S (|AbelianSemiGroup|))
 ((|BasicType|) |has| S (|SetCategory|))
 ((|BiModule| S S) |has| S (|Ring|))
 ((|CancellationAbelianMonoid|) |has| S (|AbelianGroup|))
 ((|CoercibleTo| (|OutputForm|)) |has| S (|SetCategory|))
 ((|CoercibleTo| (|Boolean|)) |has| S (|SetCategory|))
 ((|Group|) |has| S (|Group|))
 ((|InnerEvalable| (|Symbol|) S) |has| S
  (|InnerEvalable| (|Symbol|) S))
 ((|LeftModule| $) |has| S (|Ring|))
 ((|LeftModule| S) |has| S (|Ring|))
 ((|Module| S) |has| S (|CommutativeRing|))
 ((|Monoid|) |has| S (|Monoid|))
 ((|PartialDifferentialRing| (|Symbol|)) |has| S
  (|PartialDifferentialRing| (|Symbol|)))
 ((|RightModule| S) |has| S (|Ring|)) ((|Ring|) |has| S (|Ring|))
 ((|Rng|) |has| S (|Ring|)) ((|SemiGroup|) |has| S (|SemiGroup|))
 ((|SetCategory|) |has| S (|SetCategory|)) ((|Type|) . T)
 ((|VectorSpace| S) |has| S (|Field|)))
\end{verbatim}

\subsection{The ``documentation''}
\begin{verbatim}
((|constructor|
     (NIL "Equations as mathematical objects. All properties of the basis 
           domain,{} \\spadignore{e.g.} being an abelian group are carried 
           over the equation domain,{} by performing the structural operations
            on the left and on the right hand side."))
 (|subst| (($ $ $)
           "\\spad{subst(eq1,{}eq2)} substitutes \\spad{eq2} into both sides 
           of \\spad{eq1} the \\spad{lhs} of \\spad{eq2} should be a kernel"))
 (|inv| (($ $)
         "\\spad{inv(x)} returns the multiplicative inverse of \\spad{x}."))
 (/ (($ $ $)
     "\\spad{e1/e2} produces a new equation by dividing the left and right 
      hand sides of equations \\spad{e1} and \\spad{e2}."))
 (|factorAndSplit|
     (((|List| $) $)
      "\\spad{factorAndSplit(eq)} make the right hand side 0 and factors the 
       new left hand side. Each factor is equated to 0 and put into the 
       resulting list without repetitions."))
 (|rightOne|
     (((|Union| $ "failed") $)
      "\\spad{rightOne(eq)} divides by the right hand side.")
     (((|Union| $ "failed") $)
      "\\spad{rightOne(eq)} divides by the right hand side,{} if possible."))
 (|leftOne|
     (((|Union| $ "failed") $)
      "\\spad{leftOne(eq)} divides by the left hand side.")
     (((|Union| $ "failed") $)
      "\\spad{leftOne(eq)} divides by the left hand side,{} if possible."))
 (* (($ $ |#1|)
     "\\spad{eqn*x} produces a new equation by multiplying both sides of 
      equation eqn by \\spad{x}.")
    (($ |#1| $)
     "\\spad{x*eqn} produces a new equation by multiplying both sides of 
      equation eqn by \\spad{x}."))
 (- (($ $ |#1|)
     "\\spad{eqn-x} produces a new equation by subtracting \\spad{x} from 
      both sides of equation eqn.")
    (($ |#1| $)
     "\\spad{x-eqn} produces a new equation by subtracting both sides of 
      equation eqn from \\spad{x}."))
 (|rightZero|
     (($ $) "\\spad{rightZero(eq)} subtracts the right hand side."))
 (|leftZero|
     (($ $) "\\spad{leftZero(eq)} subtracts the left hand side."))
 (+ (($ $ |#1|)
     "\\spad{eqn+x} produces a new equation by adding \\spad{x} to both 
     sides of equation eqn.")
    (($ |#1| $)
     "\\spad{x+eqn} produces a new equation by adding \\spad{x} to both 
     sides of equation eqn."))
 (|eval| (($ $ (|List| $))
          "\\spad{eval(eqn,{} [x1=v1,{} ... xn=vn])} replaces \\spad{xi} 
          by \\spad{vi} in equation \\spad{eqn}.")
         (($ $ $)
          "\\spad{eval(eqn,{} x=f)} replaces \\spad{x} by \\spad{f} in 
          equation \\spad{eqn}."))
 (|map| (($ (|Mapping| |#1| |#1|) $)
         "\\spad{map(f,{}eqn)} constructs a new equation by applying 
          \\spad{f} to both sides of \\spad{eqn}."))
 (|rhs| ((|#1| $)
         "\\spad{rhs(eqn)} returns the right hand side of equation 
          \\spad{eqn}."))
 (|lhs| ((|#1| $)
         "\\spad{lhs(eqn)} returns the left hand side of equation 
          \\spad{eqn}."))
 (|swap| (($ $)
          "\\spad{swap(eq)} interchanges left and right hand side of 
           equation \\spad{eq}."))
 (|equation|
     (($ |#1| |#1|) "\\spad{equation(a,{}b)} creates an equation."))
 (= (($ |#1| |#1|) "\\spad{a=b} creates an equation.")))
\end{verbatim}

\subsection{The ``slotInfo''}
\begin{verbatim}
(|Equation|
    (NIL (~= ((38 0 0) NIL (|has| |#1| (|SetCategory|))))
         (|zero?| ((38 0) NIL (|has| |#1| (|AbelianGroup|))))
         (|swap| ((0 0) 22))
         (|subtractIfCan| ((64 0 0) NIL (|has| |#1| (|AbelianGroup|))))
         (|subst| ((0 0 0) 93 (|has| |#1| (|ExpressionSpace|))))
         (|sample|
             ((0) NIL
              (OR (|has| |#1| (|AbelianGroup|))
                  (|has| |#1| (|Monoid|)))
              CONST))
         (|rightZero| ((0 0) 8 (|has| |#1| (|AbelianGroup|))))
         (|rightOne| ((64 0) 68 (|has| |#1| (|Monoid|))))
         (|rhs| ((6 0) 21))
         (|recip| ((64 0) 66 (|has| |#1| (|Monoid|))))
         (|one?| ((38 0) NIL (|has| |#1| (|Monoid|))))
         (|map| ((0 23 0) 24)) (|lhs| ((6 0) 9))
         (|leftZero| ((0 0) 57 (|has| |#1| (|AbelianGroup|))))
         (|leftOne| ((64 0) 67 (|has| |#1| (|Monoid|))))
         (|latex| ((97 0) NIL (|has| |#1| (|SetCategory|))))
         (|inv| ((0 0) 70
                 (OR (|has| |#1| (|Field|)) (|has| |#1| (|Group|)))))
         (|hash| ((96 0) NIL (|has| |#1| (|SetCategory|))))
         (|factorAndSplit| ((18 0) 19 (|has| |#1| (|IntegralDomain|))))
         (|eval| ((0 0 28 29) 31
                  (|has| |#1| (|InnerEvalable| (|Symbol|) |#1|)))
                 ((0 0 25 6) 27
                  (|has| |#1| (|InnerEvalable| (|Symbol|) |#1|)))
                 ((0 0 18) 37
                  (AND (|has| |#1| (|Evalable| |#1|))
                       (|has| |#1| (|SetCategory|))))
                 ((0 0 0) 34
                  (AND (|has| |#1| (|Evalable| |#1|))
                       (|has| |#1| (|SetCategory|)))))
         (|equation| ((0 6 6) 17))
         (|dimension| ((86) 88 (|has| |#1| (|Field|))))
         (|differentiate|
             ((0 0 25 71) NIL
              (|has| |#1| (|PartialDifferentialRing| (|Symbol|))))
             ((0 0 28 95) NIL
              (|has| |#1| (|PartialDifferentialRing| (|Symbol|))))
             ((0 0 25) 85
              (|has| |#1| (|PartialDifferentialRing| (|Symbol|))))
             ((0 0 28) NIL
              (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))))
         (|conjugate| ((0 0 0) NIL (|has| |#1| (|Group|))))
         (|commutator| ((0 0 0) NIL (|has| |#1| (|Group|))))
         (|coerce| ((38 0) 45 (|has| |#1| (|SetCategory|)))
             ((41 0) 44 (|has| |#1| (|SetCategory|)))
             ((0 74) NIL (|has| |#1| (|Ring|))))
         (|characteristic| ((71) 73 (|has| |#1| (|Ring|))))
         (^ ((0 0 94) NIL (|has| |#1| (|SemiGroup|)))
            ((0 0 71) NIL (|has| |#1| (|Monoid|)))
            ((0 0 74) NIL (|has| |#1| (|Group|))))
         (|Zero| ((0) 55 (|has| |#1| (|AbelianGroup|)) CONST))
         (|One| ((0) 63 (|has| |#1| (|Monoid|)) CONST))
         (D ((0 0 25 71) NIL
             (|has| |#1| (|PartialDifferentialRing| (|Symbol|))))
            ((0 0 28 95) NIL
             (|has| |#1| (|PartialDifferentialRing| (|Symbol|))))
            ((0 0 25) NIL
             (|has| |#1| (|PartialDifferentialRing| (|Symbol|))))
            ((0 0 28) NIL
             (|has| |#1| (|PartialDifferentialRing| (|Symbol|)))))
         (= ((0 6 6) 20) ((38 0 0) 40 (|has| |#1| (|SetCategory|))))
         (/ ((0 0 6) NIL (|has| |#1| (|Field|)))
            ((0 0 0) 90
             (OR (|has| |#1| (|Field|)) (|has| |#1| (|Group|)))))
         (- ((0 0 6) 54 (|has| |#1| (|AbelianGroup|)))
            ((0 6 0) 53 (|has| |#1| (|AbelianGroup|)))
            ((0 0 0) 52 (|has| |#1| (|AbelianGroup|)))
            ((0 0) 51 (|has| |#1| (|AbelianGroup|))))
         (+ ((0 0 6) 49 (|has| |#1| (|AbelianSemiGroup|)))
            ((0 6 0) 48 (|has| |#1| (|AbelianSemiGroup|)))
            ((0 0 0) 47 (|has| |#1| (|AbelianSemiGroup|))))
         (** ((0 0 94) NIL (|has| |#1| (|SemiGroup|)))
             ((0 0 71) NIL (|has| |#1| (|Monoid|)))
             ((0 0 74) NIL (|has| |#1| (|Group|))))
         (* ((0 6 0) 60 (|has| |#1| (|SemiGroup|)))
            ((0 0 6) 61 (|has| |#1| (|SemiGroup|)))
            ((0 0 0) 59 (|has| |#1| (|SemiGroup|)))
            ((0 94 0) NIL (|has| |#1| (|AbelianSemiGroup|)))
            ((0 74 0) 76 (|has| |#1| (|AbelianGroup|)))
            ((0 71 0) NIL (|has| |#1| (|AbelianGroup|))))))
\end{verbatim}

\subsection{The ``index''}
\begin{verbatim}
(("slot1Info" 0 32444) ("documentation" 0 29640) ("ancestors" 0 28691)
 ("parents" 0 28077) ("abbreviation" 0 28074) ("predicates" 0 25442)
 ("attributes" 0 25304) ("signaturesAndLocals" 0 23933)
 ("superDomain" 0 NIL) ("operationAlist" 0 20053) ("modemaps" 0 17216)
 ("sourceFile" 0 17179) ("constructorCategory" 0 15220)
 ("constructorModemap" 0 13215) ("constructorKind" 0 13206)
 ("constructorForm" 0 13191) ("compilerInfo" 0 4433)
 ("loadTimeStuff" 0 20))

\end{verbatim}

\chapter{Compiler top level}
\section{Global Data Structures}
\section{Pratt Parsing}
Parsing involves understanding the association of symbols and operators.
Vaughn Pratt \cite{8} poses the question ``Given a substring AEB where A 
takes a right argument, B a left, and E is an expression, does E associate
with A or B?''.

Floyd \cite{9} associates a precedence with operators, storing them
in a table, called ``binding powers''. The expression E would associate
with the argument position having the highest binding power. This leads
to a large set of numbers, one for every situation.

Pratt assigns data types to ``classes'' and then creates a total order
on the classes. He lists, in ascending order, Outcomes, Booleans, 
Graphs (trees, lists, etc), Strings, Algebraics (e.g. Integer, complex 
numbers, polynomials, real arrays) and references (e.g. the left hand
side of assignments). Thus, Strings < References. The key restriction
is ``that the class of the type at any argument that might participate
in an association problem not be less than the class of the data type
of the result of the function taking that argument''.

For a less-than comparision (``$<$'') the argument types are Algebraics
but the result type is Boolean. Since Algebraics are greater than Boolean
we can associate the Algebraics together and apply them as arguments to
the Boolean.

In more detail, there an ``association'' is a function of 4 types:
\begin{itemize}
\item $a_A$ -- The data type of the right argument
\item $r_A$ -- The return type of the right argument
\item $a_B$ -- The data type of the left argument
\item $r_B$ -- The return type of the left argument
\end{itemize}
Note that the return types might depend on the type of the expression E.
If all 4 are of the same class then the association is to the left.

Using these ideas and given the restriction above, Pratt proves that
every association problem has at most one solution consistant with the
data types of the associated operators.

Pratt proves that there exists an assignment of integers to the argument
positions of each token in the language such that the correct association,
if any, is always in the direction of the argument position with the
larger number, with ties being broken to the left. 

To construct the proper numbers, first assign even integers to the data
type classes. Then to each argument position assign an integer lying
strictly (where possible) between the integers corresponding to the
classes of the argument and result types.

For tokens like ``and'', ``or'', $+$, $*$, and $^{}$ the Booleans
and Algebraics can be subdivided into pseudo-classes so that

terms $<$ factors $<$ primaries

Then $+$ is defined over terms, $*$ over factors, and $^{}$ over
primaries with coercions allowed from primaries to factors to terms.
To be consistent with Algol, the primaries should be a right associative
class (e.g. x$^{}$y$^{}$z)

\section{)compile}
This is the implementation of the )compile command.

You use this command to invoke the new Axiom library compiler or the
old Axiom system compiler.  The {\tt )compile} system command is
actually a combination of Axiom processing and a call to the Aldor
compiler.  It is performing double-duty, acting as a front-end to both
the Aldor compiler and the old Axiom system compiler.  (The old Axiom
system compiler was written in Lisp and was an integral part of the
Axiom environment.  The Aldor compiler is written in C and executed by
the operating system when called from within Axiom.)

\par\noindent{\bf User Level Required:} compiler

\par\noindent{\bf Command Syntax:}

\begin{list}{}
\item {\tt )compile}
\item {\tt )compile {\it fileName}}
\item {\tt )compile {\it fileName}.spad}
\item {\tt )compile {\it directory/fileName}.spad}
\item {\tt )compile {\it fileName} )old}
\item {\tt )compile {\it fileName} )translate}
\item {\tt )compile {\it fileName} )quiet}
\item {\tt )compile {\it fileName} )noquiet}
\item {\tt )compile {\it fileName} )moreargs}
\item {\tt )compile {\it fileName} )onlyargs}
\item {\tt )compile {\it fileName} )break}
\item {\tt )compile {\it fileName} )nobreak}
\item {\tt )compile {\it fileName} )library}
\item {\tt )compile {\it fileName} )nolibrary}
\item {\tt )compile {\it fileName} )vartrace}
\item {\tt )compile {\it fileName} )constructor} {\it nameOrAbbrev}
\end{list}

These command forms invoke the Aldor compiler.
\begin{list}{}
\item {\tt )compile {\it fileName}.as}
\item {\tt )compile {\it directory/fileName}.as}
\item {\tt )compile {\it fileName}.ao}
\item {\tt )compile {\it directory/fileName}.ao}
\item {\tt )compile {\it fileName}.al}
\item {\tt )compile {\it directory/fileName}.al}
\item {\tt )compile {\it fileName}.lsp}
\item {\tt )compile {\it directory/fileName}.lsp}
\item {\tt )compile {\it fileName} )new}
\end{list}

\par\noindent{\bf Command Description:}

The first thing {\tt )compile} does is look for a source code
filename among its arguments.
Thus
\begin{verbatim}
)compile mycode.spad
)compile /u/jones/mycode.spad
)compile mycode
\end{verbatim}
all invoke {\tt )compiler} on the file {\tt
/u/jones/mycode.spad} if the current Axiom working
directory is {\tt /u/jones.} (Recall that you can set the
working directory via the {\tt )cd} command. If you don't set it
explicitly, it is the directory from which you started
Axiom.)

If you omit the file extension, the command looks to see if you have
specified the {\tt )new} or {\tt )old} option.  If you have given one
of these options, the corresponding compiler is used.

The command first looks in the standard system directories for files
with extension {\it .as, .ao} and {\it .al} and then files with
extension {\it .spad}.  The first file found has the appropriate
compiler invoked on it.  If the command cannot find a matching file,
an error message is displayed and the command terminates.

The first thing {\tt )compile} does is look for a source code
filename among its arguments.
Thus
\begin{verbatim}
)compile mycode
)co mycode
)co mycode.spad
\end{verbatim}
all invoke {\tt )compiler} on the file {\tt
/u/jones/mycode.spad} if the current Axiom working
directory is {\tt /u/jones.} Recall that you can set the
working directory via the {\tt )cd} command. If you don't set it
explicitly, it is the directory from which you started
Axiom.

This is frequently all you need to compile your file.

This simple command:
\begin{enumerate}
\item Invokes the Spad compiler and produces Lisp output.
\item Calls the Lisp compiler if the compilation was successful.
\item Uses the {\tt )library} command to tell Axiom about
the contents of your compiled file and arrange to have those
contents loaded on demand.
\end{enumerate}

Should you not want the {\tt )library} command automatically
invoked, call {\tt )compile} with the {\tt )nolibrary} option.
For example,
\begin{verbatim}
)compile mycode )nolibrary
\end{verbatim}

By default, the {\tt )library} system command {\it exposes} all
domains and categories it processes.
This means that the Axiom intepreter will consider those domains and 
categories when it is trying to resolve a reference to a function.
Sometimes domains and categories should not be exposed.
For example, a domain may just be used privately by another
domain and may not be meant for top-level use.
The {\tt )library} command should still be used, though, so that
the code will be loaded on demand.
In this case, you should use the {\tt )nolibrary} option on {\tt
)compile} and the {\tt )noexpose} option in the {\tt )library}
command. For example,
\begin{verbatim}
)compile mycode )nolibrary
)library mycode )noexpose
\end{verbatim}

Once you have established your own collection of compiled code,
you may find it handy to use the {\tt )dir} option on the
{\tt )library} command.
This causes {\tt )library} to process all compiled code in the
specified directory. For example,
\begin{verbatim}
)library )dir /u/jones/quantum
\end{verbatim}
You must give an explicit directory after {\tt )dir}, even if you
want all compiled code in the current working directory
processed, e.g.
\begin{verbatim}
)library )dir .
\end{verbatim}

\subsection{Spad compiler}
This command compiles files with file extension {\tt .spad}
with the Spad system compiler.  

The {\tt )translate} option is used to invoke a special version of the
old system compiler that will translate a {\it .spad} file to a {\it
.as} file.  That is, the {\it .spad} file will be parsed and analyzed
and a file using the new syntax will be created.

By default, the {\it .as} file is created in the same directory as the
{\it .spad} file. If that directory is not writable, the current
directory is used. If the current directory is not writable, an error
message is given and the command terminates.  Note that {\tt )translate} 
implies the {\tt )old} option so the file extension can
safely be omitted. If {\tt )translate} is given, all other options are
ignored.  Please be aware that the translation is not necessarily one
hundred percent complete or correct.  You should attempt to compile
the output with the Aldor compiler and make any necessary corrections.

You can compile category, domain, and package constructors contained
in files with file extension {\it .spad}.  You can compile individual
constructors or every constructor in a file.

The full filename is remembered between invocations of this command and
{\tt )edit} commands. The sequence of commands
\begin{verbatim}
)compile matrix.spad
)edit
)compile
\end{verbatim}
will call the compiler, edit, and then call the compiler again on the
file {\bf matrix.spad.}  If you do not specify a {\it directory,} the
working current directory is searched for the file.  If the file is
not found, the standard system directories are searched.

If you do not give any options, all constructors within a file are
compiled.  Each constructor should have an {\tt )abbreviation} command
in the file in which it is defined.  We suggest that you place the
{\tt )abbreviation} commands at the top of the file in the order in
which the constructors are defined.

The {\tt )library} option causes directories containing the compiled
code for each constructor to be created in the working current
directory.  The name of such a directory consists of the constructor
abbreviation and the {\bf .nrlib} file extension.  For example, the
directory containing the compiled code for the {\tt MATRIX}
constructor is called {\bf MATRIX.nrlib.}  The {\tt )nolibrary} option
says that such files should not be created.  The default is 
{\tt )library.}  Note that the semantics of {\tt )library} and 
{\tt )nolibrary} for the new Aldor compiler and for the old system 
compiler are completely different.

The {\tt )vartrace} option causes the compiler to generate extra code
for the constructor to support conditional tracing of variable
assignments. Without this option, this code is suppressed and one
cannot use the {\tt )vars} option for the trace command.

The {\tt )constructor} option is used to
specify a particular constructor to compile.
All other constructors in the file are ignored.
The constructor name or abbreviation follows {\tt )constructor.}
Thus either
\begin{verbatim}
)compile matrix.spad )constructor RectangularMatrix
\end{verbatim}
or
\begin{verbatim}
)compile matrix.spad )constructor RMATRIX
\end{verbatim}
compiles  the {\tt RectangularMatrix} constructor
defined in {\bf matrix.spad.}

The {\tt )break} and {\tt )nobreak} options determine what
the spad compiler does when it encounters an error.
{\tt )break} is the default and it indicates that processing
should stop at the first error.
The value of the {\tt )set break} variable then controls what happens.

\section{Operator Precedence Table Initialization} 
\begin{verbatim}
; PURPOSE: This file sets up properties which are used by the Boot lexical
;          analyzer for bottom-up recognition of operators.  Also certain
;          other character-class definitions are included, as well as
;          table accessing functions.
;
; ORGANIZATION: Each section is organized in terms of Creation and Access code.
;
;               1. Led and Nud Tables
;               2. GLIPH  Table
;               3. RENAMETOK Table
;               4. GENERIC Table
;               5. Character syntax class predicates
\end{verbatim}
\subsection{LED and NUD Tables}
\begin{verbatim}
; **** 1. LED and NUD Tables
 
; ** TABLE PURPOSE
 
; Led and Nud have to do with operators. An operator with a Led property takes
; an operand on its left (infix/suffix operator).
 
; An operator with a Nud takes no operand on its left (prefix/nilfix).
; Some have both (e.g. - ).  This terminology is from the Pratt parser.
; The translator for Scratchpad II is a modification of the Pratt parser which
; branches to special handlers when it is most convenient and practical to
; do so (Pratt's scheme cannot handle local contexts very easily).
 
; Both LEDs and NUDs have right and left binding powers.  This is meaningful 
; for prefix and infix operators.  These powers are stored as the values of 
; the LED and NUD properties of an atom, if the atom has such a property. 
; The format is:
 
;       <Operator Left-Binding-Power  Right-Binding-Power <Special-Handler>>
 
; where the Special-Handler is the name of a function to be evaluated when that
; keyword is encountered.
 
; The default values of Left and Right Binding-Power are NIL.  NIL is a 
; legitimate value signifying no precedence.  If the Special-Handler is NIL,
; this is just an ordinary operator (as opposed to a surfix operator like 
; if-then-else).
;
; The Nud value gives the precedence when the operator is a prefix op.
; The Led value gives the precedence when the operator is an infix op.
; Each op has 2 priorities, left and right. 
; If the right priority of the first is greater than or equal to the
; left priority of the second then collect the second operator into
; the right argument of the first operator. 
 
\end{verbatim}
<<LEDNUDTables>>=
; ** TABLE CREATION
 
(defun makenewop (x y) (makeop x y '|PARSE-NewKEY|))
 
(defun makeop (x y keyname)
  (if (or (not (cdr x)) (numberp (second x)))
      (setq x (cons (first x) x)))
  (if (and (alpha-char-p (elt (stringimage (first x)) 0))
           (not (member (first x) (eval keyname))))
      (set keyname (cons (first x) (eval keyname))))
  (makeprop (first x) y x)
  (second x))
 
(setq |PARSE-NewKEY| nil) ;;list of keywords
 
(mapcar #'(LAMBDA(J) (MAKENEWOP J '|Led|))
        '((* 800 801)   (|rem| 800 801)   (|mod| 800 801)
          (|quo| 800 801)   (|div| 800 801)
          (/ 800 801)    (** 900 901)  (^ 900 901)
          (|exquo| 800 801) (+ 700 701)
          (\- 700 701)    (\-\> 1001 1002)  (\<\- 1001 1002)
          (\: 996 997)    (\:\: 996 997)
          (\@ 996 997)    (|pretend| 995 996)
          (\.)            (\! \! 1002 1001)
          (\, 110 111)
          (\; 81 82 (|PARSE-SemiColon|))
          (\< 400 400)    (\> 400 400)
          (\<\< 400 400)  (\>\> 400 400)
          (\<= 400 400)   (\>= 400 400)
          (= 400 400)     (^= 400 400)
          (\~= 400 400)
          (|in| 400 400)    (|case| 400 400)
          (|add| 400 120)   (|with| 2000 400 (|PARSE-InfixWith|))
          (|has| 400 400)
          (|where| 121 104)     ; must be 121 for SPAD, 126 for boot--> nboot
          (|when| 112 190)
          (|otherwise| 119 190 (|PARSE-Suffix|))
          (|is| 400 400)    (|isnt| 400 400)
          (|and| 250 251)   (|or| 200 201)
          (/\\ 250 251)   (\\/ 200 201)
          (\.\. SEGMENT 401 699 (|PARSE-Seg|))
          (=\> 123 103)
          (+-\> 995 112)
          (== DEF 122 121)
          (==\> MDEF 122 121)
          (\| 108 111)                          ;was 190 190
          (\:- LETD 125 124) (\:= LET 125 124)))
 
(mapcar #'(LAMBDA (J) (MAKENEWOP J `|Nud|))
        '((|for| 130 350 (|PARSE-Loop|))
          (|while| 130 190 (|PARSE-Loop|))
          (|until| 130 190 (|PARSE-Loop|))
          (|repeat| 130 190 (|PARSE-Loop|))
          (|import| 120 0 (|PARSE-Import|) )
          (|unless|)
          (|add| 900 120)
          (|with| 1000 300 (|PARSE-With|))
          (|has| 400 400)
          (\- 701 700)  ; right-prec. wants to be -1 + left-prec
;;        (\+ 701 700)
          (\# 999 998)
          (\! 1002 1001)
          (\' 999 999 (|PARSE-Data|))
          (\<\< 122 120 (|PARSE-LabelExpr|))
          (\>\>)
          (^ 260 259 NIL)
          (\-\> 1001 1002)
          (\: 194 195)
          (|not| 260 259 NIL)
          (\~ 260 259 nil)
          (\= 400 700)
          (|return| 202 201 (|PARSE-Return|))
          (|leave| 202 201 (|PARSE-Leave|))
          (|exit| 202 201 (|PARSE-Exit|))
          (|from|)
          (|iterate|)
          (|yield|)
          (|if| 130 0 (|PARSE-Conditional|))    ; was 130
          (\| 0 190)
          (|suchthat|)
          (|then| 0 114)
          (|else| 0 114)))

@ 
\section{Gliph Table}
Gliphs are symbol clumps. The gliph property of a symbol gives
the tree describing the tokens which begin with that symbol.
The token reader uses the gliph property to determine the longest token.
Thus [[:=]] is read as one token not as [[:]] followed by [[=]].
 
<<GLIPHTable>>=
(mapcar #'(lambda (x) (makeprop (car x) 'gliph (cdr x)))
        `(
          ( \| (\))        )
          ( *  (*)         )
          ( \( (<) (\|)    )
          ( +  (- (>))     )
          ( -  (>)         )
          ( <  (=) (<)     )
     ;;     ( /  (\\)        ) breaks */xxx
          ( \\ (/)         )
          ( >  (=) (>) (\)))
          ( =  (= (>)) (>) )
          ( \. (\.)        )
          ( ^  (=)         )
          ( \~ (=)         )
          ( \: (=) (-) (\:))))
 
@
\subsection{Rename Token Table} 
RENAMETOK defines alternate token strings which can be used for different
keyboards which define equivalent tokens.
<<RENAMETOKTable>>=
(mapcar 
  #'(lambda (x) (makeprop (car x) 'renametok (cadr x)) (makenewop x nil))
        '((\(\| \[)                     ; (| |) means []
          (\|\) \])
          (\(< \{)                      ; (< >) means {}
          (>\) \})))
 
@
\subsection{Generic function table}
GENERIC operators be suffixed by [[$]] qualifications in SPAD code.  
[[$]] is then followed by a domain label, such as I for Integer, which 
signifies which domain the operator refers to.  For example [[+$Integer]] 
is [[+]] for Integers.
<<GENERICTable>>=
(mapcar #'(lambda (x) (makeprop x 'generic 'true))
        '(- = * |rem| |mod| |quo| |div| / ** |exquo| + - < > <= >= ^= ))

@  

\section{Giant steps, Baby steps}
We will walk through the compiler with the EQ.spad example using a
Giant-steps, Baby-steps approach. That is, we will show the large
scale (Giant) transformations at each stage of compilation and discuss the
details (Baby) in subsequent chapters.
\chapter{The Parser}
\section{EQ.spad}
We will explain the compilation function using the file {\tt EQ.spad}.
We trace the execution of the various functions to understand the actual
call parameters and results returned. The {\tt EQ.spad} file is:
\begin{verbatim}
)abbrev domain EQ Equation
--FOR THE BENEFIT  OF LIBAX0 GENERATION
++ Author: Stephen M. Watt, enhancements by Johannes Grabmeier
++ Date Created: April 1985
++ Date Last Updated: June 3, 1991; September 2, 1992
++ Basic Operations: =
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++ Equations as mathematical objects.  All properties of the basis domain,
++ e.g. being an abelian group are carried over the equation domain, by
++ performing the structural operations on the left and on the
++ right hand side.
--   The interpreter translates "=" to "equation".  Otherwise, it will
--   find a modemap for "=" in the domain of the arguments.

Equation(S: Type): public == private where
  Ex ==> OutputForm
  public ==> Type with
    "=": (S, S) -> $
        ++ a=b creates an equation.
    equation: (S, S) -> $
        ++ equation(a,b) creates an equation.
    swap: $ -> $
        ++ swap(eq) interchanges left and right hand side of equation eq.
    lhs: $ -> S
        ++ lhs(eqn) returns the left hand side of equation eqn.
    rhs: $ -> S
        ++ rhs(eqn) returns the right hand side of equation eqn.
    map: (S -> S, $) -> $
        ++ map(f,eqn) constructs a new equation by applying f to both
        ++ sides of eqn.
    if S has InnerEvalable(Symbol,S) then
             InnerEvalable(Symbol,S)
    if S has SetCategory then
        SetCategory
        CoercibleTo Boolean
        if S has Evalable(S) then
           eval: ($, $) -> $
               ++ eval(eqn, x=f) replaces x by f in equation eqn.
           eval: ($, List $) -> $
               ++ eval(eqn, [x1=v1, ... xn=vn]) replaces xi by vi in equation eqn.
    if S has AbelianSemiGroup then
        AbelianSemiGroup
        "+": (S, $) -> $
            ++ x+eqn produces a new equation by adding x to both sides of
            ++ equation eqn.
        "+": ($, S) -> $
            ++ eqn+x produces a new equation by adding x to  both sides of
            ++ equation eqn.
    if S has AbelianGroup then
        AbelianGroup
        leftZero : $ -> $
          ++ leftZero(eq) subtracts the left hand side.
        rightZero : $ -> $
          ++ rightZero(eq) subtracts the right hand side.
        "-": (S, $) -> $
            ++ x-eqn produces a new equation by subtracting both sides of
            ++ equation eqn from x.
        "-": ($, S) -> $
            ++ eqn-x produces a new equation by subtracting x from  both sides of
            ++ equation eqn.
    if S has SemiGroup then
        SemiGroup
        "*": (S, $) -> $
            ++ x*eqn produces a new equation by multiplying both sides of
            ++ equation eqn by x.
        "*": ($, S) -> $
            ++ eqn*x produces a new equation by multiplying both sides of
            ++ equation eqn by x.
    if S has Monoid then
        Monoid
        leftOne : $ -> Union($,"failed")
          ++ leftOne(eq) divides by the left hand side, if possible.
        rightOne : $ -> Union($,"failed")
          ++ rightOne(eq) divides by the right hand side, if possible.
    if S has Group then
        Group
        leftOne : $ -> Union($,"failed")
          ++ leftOne(eq) divides by the left hand side.
        rightOne : $ -> Union($,"failed")
          ++ rightOne(eq) divides by the right hand side.
    if S has Ring then
      Ring
      BiModule(S,S)
    if S has CommutativeRing then
      Module(S)
      --Algebra(S)
    if S has IntegralDomain then
      factorAndSplit : $ -> List $
        ++ factorAndSplit(eq) make the right hand side 0 and
        ++ factors the new left hand side. Each factor is equated
        ++ to 0 and put into the resulting list without repetitions.
    if S has PartialDifferentialRing(Symbol) then
      PartialDifferentialRing(Symbol)
    if S has Field then
      VectorSpace(S)
      "/": ($, $) -> $
          ++ e1/e2 produces a new equation by dividing the left and right
          ++ hand sides of equations e1 and e2.
      inv: $ -> $
          ++ inv(x) returns the multiplicative inverse of x.
    if S has ExpressionSpace then
        subst: ($, $) -> $
             ++ subst(eq1,eq2) substitutes eq2 into both sides of eq1
             ++ the lhs of eq2 should be a kernel

  private ==> add
    Rep := Record(lhs: S, rhs: S)
    eq1,eq2: $
    s : S
    if S has IntegralDomain then
        factorAndSplit eq ==
          (S has factor : S -> Factored S) =>
            eq0 := rightZero eq
            [equation(rcf.factor,0) for rcf in factors factor lhs eq0]
          [eq]
    l:S = r:S      == [l, r]
    equation(l, r) == [l, r]    -- hack!  See comment above.
    lhs eqn        == eqn.lhs
    rhs eqn        == eqn.rhs
    swap eqn     == [rhs eqn, lhs eqn]
    map(fn, eqn)   == equation(fn(eqn.lhs), fn(eqn.rhs))

    if S has InnerEvalable(Symbol,S) then
        s:Symbol
        ls:List Symbol
        x:S
        lx:List S
        eval(eqn,s,x) == eval(eqn.lhs,s,x) = eval(eqn.rhs,s,x)
        eval(eqn,ls,lx) == eval(eqn.lhs,ls,lx) = eval(eqn.rhs,ls,lx)
    if S has Evalable(S) then
        eval(eqn1:$, eqn2:$):$ ==
           eval(eqn1.lhs, eqn2 pretend Equation S) =
               eval(eqn1.rhs, eqn2 pretend Equation S)
        eval(eqn1:$, leqn2:List $):$ ==
           eval(eqn1.lhs, leqn2 pretend List Equation S) =
               eval(eqn1.rhs, leqn2 pretend List Equation S)
    if S has SetCategory then
        eq1 = eq2 == (eq1.lhs = eq2.lhs)@Boolean and
                     (eq1.rhs = eq2.rhs)@Boolean
        coerce(eqn:$):Ex == eqn.lhs::Ex = eqn.rhs::Ex
        coerce(eqn:$):Boolean == eqn.lhs = eqn.rhs
    if S has AbelianSemiGroup then
        eq1 + eq2 == eq1.lhs + eq2.lhs = eq1.rhs + eq2.rhs
        s + eq2 == [s,s] + eq2
        eq1 + s == eq1 + [s,s]
    if S has AbelianGroup then
        - eq == (- lhs eq) = (-rhs eq)
        s - eq2 == [s,s] - eq2
        eq1 - s == eq1 - [s,s]
        leftZero eq == 0 = rhs eq - lhs eq
        rightZero eq == lhs eq - rhs eq = 0
        0 == equation(0$S,0$S)
        eq1 - eq2 == eq1.lhs - eq2.lhs = eq1.rhs - eq2.rhs
    if S has SemiGroup then
        eq1:$ * eq2:$ == eq1.lhs * eq2.lhs = eq1.rhs * eq2.rhs
        l:S   * eqn:$ == l       * eqn.lhs = l       * eqn.rhs
        l:S * eqn:$  ==  l * eqn.lhs    =    l * eqn.rhs
        eqn:$ * l:S  ==  eqn.lhs * l    =    eqn.rhs * l
        -- We have to be a bit careful here: raising to a +ve integer is OK
        -- (since it's the equivalent of repeated multiplication)
        -- but other powers may cause contradictions
        -- Watch what else you add here! JHD 2/Aug 1990
    if S has Monoid then
        1 == equation(1$S,1$S)
        recip eq ==
          (lh := recip lhs eq) case "failed" => "failed"
          (rh := recip rhs eq) case "failed" => "failed"
          [lh :: S, rh :: S]
        leftOne eq ==
          (re := recip lhs eq) case "failed" => "failed"
          1 = rhs eq * re
        rightOne eq ==
          (re := recip rhs eq) case "failed" => "failed"
          lhs eq * re = 1
    if S has Group then
        inv eq == [inv lhs eq, inv rhs eq]
        leftOne eq == 1 = rhs eq * inv rhs eq
        rightOne eq == lhs eq * inv rhs eq = 1
    if S has Ring then
        characteristic() == characteristic()$S
        i:Integer * eq:$ == (i::S) * eq
    if S has IntegralDomain then
        factorAndSplit eq ==
          (S has factor : S -> Factored S) =>
            eq0 := rightZero eq
            [equation(rcf.factor,0) for rcf in factors factor lhs eq0]
          (S has Polynomial Integer) =>
            eq0 := rightZero eq
            MF ==> MultivariateFactorize(Symbol, IndexedExponents Symbol, _
               Integer, Polynomial Integer)
            p : Polynomial Integer := (lhs eq0) pretend Polynomial Integer
            [equation((rcf.factor) pretend S,0) for rcf in factors factor(p)$MF]
          [eq]
    if S has PartialDifferentialRing(Symbol) then
        differentiate(eq:$, sym:Symbol):$ ==
           [differentiate(lhs eq, sym), differentiate(rhs eq, sym)]
    if S has Field then
        dimension() == 2 :: CardinalNumber
        eq1:$ / eq2:$ == eq1.lhs / eq2.lhs = eq1.rhs / eq2.rhs
        inv eq == [inv lhs eq, inv rhs eq]
    if S has ExpressionSpace then
        subst(eq1,eq2) ==
            eq3 := eq2 pretend Equation S
            [subst(lhs eq1,eq3),subst(rhs eq1,eq3)]

\end{verbatim}

\section{preparse}

The first large transformation of this input occurs in the function
preparse \index{preparse}. The preparse function reads the source file
and breaks the input into a list of pairs. The first part of the pair
is the line number of the input file and the second part of the pair
is the actual source text as a string. 

One feature that is the added semicolons at the end of the strings
where the ``pile'' structure of the code has been converted to a
semicolon delimited form.

\defdollar{index}
<<initvars>>=
(defvar $index 0 "File line number of most recently read line")

@

\defdollar{linelist}
<<initvars>>=
(defvar $linelist nil "Stack of preparsed lines")

@

\defdollar{echolinestack}
<<initvars>>=
(defvar $echolinestack nil "Stack of lines to list")

@

\defdollar{preparse-last-line}
<<initvars>>=
(defvar $preparse-last-line nil "Most recently read line")

@

\section{Parsing routines}
The {\bf initialize-preparse} expects to be called before the {\bf preparse}
function. It initializes the state, in particular, it reads a single line
from the input stream and stores it in {\tt \verb|$preparse-last-line|}.
The caller gives a stream and the {\tt \verb|$preparse-last-line|} variable
is initialized as:
\begin{verbatim}
    2> (INITIALIZE-PREPARSE #<input stream "/tmp/EQ.spad">)
    <2 (INITIALIZE-PREPARSE ")abbrev domain EQ Equation")
\end{verbatim}
\defun{initialize-preparse}{initialize-preparse}
\calls{initialize-preparse}{get-a-line}
\usesdollar{initialize-preparse}{index}
\usesdollar{initialize-preparse}{linelist}
\usesdollar{initialize-preparse}{echolinestack}
\usesdollar{initialize-preparse}{preparse-last-line}
<<defun initialize-preparse>>=
(defun initialize-preparse (strm)
  (setq $index 0)
  (setq $linelist nil)
  (setq $echolinestack nil)
  (setq $preparse-last-line (get-a-line strm)))

@

The {\bf preparse} function returns a list of pairs of the form:
( (linenumber . linestring) .... (linenumber . linestring))
For instance, for the file {\tt EQ.spad}, we get:
\begin{verbatim}
    2> (PREPARSE #<input stream "/tmp/EQ.spad">)
      3> (PREPARSE1 (")abbrev domain EQ Equation"))
        4> (|doSystemCommand| "abbrev domain EQ Equation")
        <4 (|doSystemCommand| NIL)
      <3 (PREPARSE1 ( ...[snip]... )
     <2 (PREPARSE (
 (19 . "Equation(S: Type): public == private where")
 (20 . " (Ex ==> OutputForm;")
 (21 . "  public ==> Type with")
 (22 . "   (\"=\": (S, S) -> $;")
 (24 . "    equation: (S, S) -> $;")
 (26 . "    swap: $ -> $;")
 (28 . "    lhs: $ -> S;")
 (30 . "    rhs: $ -> S;")
 (32 . "    map: (S -> S, $) -> $;")
 (35 . "    if S has InnerEvalable(Symbol,S) then")
 (36 . "             InnerEvalable(Symbol,S);")
 (37 . "    if S has SetCategory then")
 (38 . "       (SetCategory;")
 (39 . "        CoercibleTo Boolean;")
 (40 . "        if S has Evalable(S) then")
 (41 . "          (eval: ($, $) -> $;")
 (43 . "           eval: ($, List $) -> $));")
 (45 . "    if S has AbelianSemiGroup then")
 (46 . "       (AbelianSemiGroup;")
 (47 . "        \"+\": (S, $) -> $;")
 (50 . "        \"+\": ($, S) -> $);")
 (53 . "    if S has AbelianGroup then")
 (54 . "       (AbelianGroup;")
 (55 . "        leftZero : $ -> $;")
 (57 . "        rightZero : $ -> $;")
 (59 . "        \"-\": (S, $) -> $;")
 (62 . "        \"-\": ($, S) -> $);")
 (65 . "    if S has SemiGroup then")
 (66 . "       (SemiGroup;")
 (67 . "        \"*\": (S, $) -> $;")
 (70 . "        \"*\": ($, S) -> $);")
 (73 . "    if S has Monoid then")
 (74 . "       (Monoid;")
 (75 . "        leftOne : $ -> Union($,\"failed\");")
 (77 . "        rightOne : $ -> Union($,\"failed\"));")
 (79 . "    if S has Group then")
 (80 . "       (Group;")
 (81 . "        leftOne : $ -> Union($,\"failed\");")
 (83 . "        rightOne : $ -> Union($,\"failed\"));")
 (85 . "    if S has Ring then")
 (86 . "     (Ring;")
 (87 . "      BiModule(S,S));")
 (88 . "    if S has CommutativeRing then")
 (89 . "      Module(S);")
 (91 . "    if S has IntegralDomain then")
 (92 . "      factorAndSplit : $ -> List $;")
 (96 . "    if S has PartialDifferentialRing(Symbol) then")
 (97 . "      PartialDifferentialRing(Symbol);")
 (98 . "    if S has Field then")
 (99 . "     (VectorSpace(S);")
 (100 . "      \"/\": ($, $) -> $;")
 (103 . "      inv: $ -> $);")
 (105 . "    if S has ExpressionSpace then")
 (106 . "        subst: ($, $) -> $);")
 (109 . "  private ==> add")
 (110 . "   (Rep := Record(lhs: S, rhs: S);")
 (111 . "    eq1,eq2: $;")
 (112 . "    s : S;")
 (113 . "    if S has IntegralDomain then")
 (114 . "        factorAndSplit eq ==")
 (115 . "         ((S has factor : S -> Factored S) =>")
 (116 . "           (eq0 := rightZero eq;")
 (117 . "            [equation(rcf.factor,0) 
                       for rcf in factors factor lhs eq0]);")
 (118 . "          [eq]);")
 (119 . "    l:S = r:S      == [l, r];")
 (120 . "    equation(l, r) == [l, r];")
 (121 . "    lhs eqn        == eqn.lhs;")
 (122 . "    rhs eqn        == eqn.rhs;")
 (123 . "    swap eqn     == [rhs eqn, lhs eqn];")
 (124 . "    map(fn, eqn)   == equation(fn(eqn.lhs), fn(eqn.rhs));")
 (125 . "    if S has InnerEvalable(Symbol,S) then")
 (126 . "       (s:Symbol;")
 (127 . "        ls:List Symbol;")
 (128 . "        x:S;")
 (129 . "        lx:List S;")
 (130 . "        eval(eqn,s,x) == eval(eqn.lhs,s,x) = eval(eqn.rhs,s,x);")
 (131 . "        eval(eqn,ls,lx) == eval(eqn.lhs,ls,lx) = 
                                     eval(eqn.rhs,ls,lx));")
 (132 . "    if S has Evalable(S) then")
 (133 . "       (eval(eqn1:$, eqn2:$):$ ==")
 (134 . "           eval(eqn1.lhs, eqn2 pretend Equation S) =")
 (135 . "               eval(eqn1.rhs, eqn2 pretend Equation S);")
 (136 . "        eval(eqn1:$, leqn2:List $):$ ==")
 (137 . "           eval(eqn1.lhs, leqn2 pretend List Equation S) =")
 (138 . "               eval(eqn1.rhs, leqn2 pretend List Equation S));")
 (139 . "    if S has SetCategory then")
 (140 . "       (eq1 = eq2 == (eq1.lhs = eq2.lhs)@Boolean and")
 (141 . "                     (eq1.rhs = eq2.rhs)@Boolean;")
 (142 . "        coerce(eqn:$):Ex == eqn.lhs::Ex = eqn.rhs::Ex;")
 (143 . "        coerce(eqn:$):Boolean == eqn.lhs = eqn.rhs);")
 (144 . "    if S has AbelianSemiGroup then")
 (145 . "       (eq1 + eq2 == eq1.lhs + eq2.lhs = eq1.rhs + eq2.rhs;")
 (146 . "        s + eq2 == [s,s] + eq2;")
 (147 . "        eq1 + s == eq1 + [s,s]);")
 (148 . "    if S has AbelianGroup then")
 (149 . "       (- eq == (- lhs eq) = (-rhs eq);")
 (150 . "        s - eq2 == [s,s] - eq2;")
 (151 . "        eq1 - s == eq1 - [s,s];")
 (152 . "        leftZero eq == 0 = rhs eq - lhs eq;")
 (153 . "        rightZero eq == lhs eq - rhs eq = 0;")
 (154 . "        0 == equation(0$S,0$S);")
 (155 . "        eq1 - eq2 == eq1.lhs - eq2.lhs = eq1.rhs - eq2.rhs);")
 (156 . "    if S has SemiGroup then")
 (157 . "       (eq1:$ * eq2:$ == eq1.lhs * eq2.lhs = eq1.rhs * eq2.rhs;")
 (158 . "        l:S   * eqn:$ == l       * eqn.lhs = l       * eqn.rhs;")
 (159 . "        l:S * eqn:$  ==  l * eqn.lhs    =    l * eqn.rhs;")
 (160 . "        eqn:$ * l:S  ==  eqn.lhs * l    =    eqn.rhs * l);")
 (165 . "    if S has Monoid then")
 (166 . "       (1 == equation(1$S,1$S);")
 (167 . "        recip eq ==")
 (168 . "         ((lh := recip lhs eq) case \"failed\" => \"failed\";")
 (169 . "          (rh := recip rhs eq) case \"failed\" => \"failed\";")
 (170 . "          [lh :: S, rh :: S]);")
 (171 . "        leftOne eq ==")
 (172 . "         ((re := recip lhs eq) case \"failed\" => \"failed\";")
 (173 . "          1 = rhs eq * re);")
 (174 . "        rightOne eq ==")
 (175 . "         ((re := recip rhs eq) case \"failed\" => \"failed\";")
 (176 . "          lhs eq * re = 1));")
 (177 . "    if S has Group then")
 (178 . "       (inv eq == [inv lhs eq, inv rhs eq];")
 (179 . "        leftOne eq == 1 = rhs eq * inv rhs eq;")
 (180 . "        rightOne eq == lhs eq * inv rhs eq = 1);")
 (181 . "    if S has Ring then")
 (182 . "       (characteristic() == characteristic()$S;")
 (183 . "        i:Integer * eq:$ == (i::S) * eq);")
 (184 . "    if S has IntegralDomain then")
 (185 . "        factorAndSplit eq ==")
 (186 . "         ((S has factor : S -> Factored S) =>")
 (187 . "           (eq0 := rightZero eq;")
 (188 . "            [equation(rcf.factor,0) 
                         for rcf in factors factor lhs eq0]);")
 (189 . "          (S has Polynomial Integer) =>")
 (190 . "           (eq0 := rightZero eq;")
 (191 . "            MF ==> MultivariateFactorize(Symbol, 
                                IndexedExponents Symbol,
                                Integer, Polynomial Integer);")
 (193 . "            p : Polynomial Integer := 
                           (lhs eq0) pretend Polynomial Integer;")
 (194 . "            [equation((rcf.factor) pretend S,0) 
                           for rcf in factors factor(p)$MF]);")
 (195 . "          [eq]);")
 (196 . "    if S has PartialDifferentialRing(Symbol) then")
 (197 . "        differentiate(eq:$, sym:Symbol):$ ==")
 (198 . "           [differentiate(lhs eq, sym), differentiate(rhs eq, sym)];")
 (199 . "    if S has Field then")
 (200 . "       (dimension() == 2 :: CardinalNumber;")
 (201 . "        eq1:$ / eq2:$ == eq1.lhs / eq2.lhs = eq1.rhs / eq2.rhs;")
 (202 . "        inv eq == [inv lhs eq, inv rhs eq]);")
 (203 . "    if S has ExpressionSpace then")
 (204 . "        subst(eq1,eq2) ==")
 (205 . "           (eq3 := eq2 pretend Equation S;")
 (206 . "            [subst(lhs eq1,eq3),subst(rhs eq1,eq3)])))")))
\end{verbatim}

\defun{preparse}{preparse}
\calls{preparse}{preparse}
\calls{preparse}{preparse1}
\calls{preparse}{parseprint}
\calls{preparse}{ifcar}
\usesdollar{preparse}{comblocklist}
\usesdollar{preparse}{skipme}
\usesdollar{preparse}{preparse-last-line}
\usesdollar{preparse}{index}
\usesdollar{preparse}{docList}
\usesdollar{preparse}{preparseReportIfTrue}
\usesdollar{preparse}{headerDocumentation}
\usesdollar{preparse}{maxSignatureLineNumber}
\usesdollar{preparse}{constructorLineNumber}
<<defun preparse>>=
(defun preparse (strm &aux (stack ()))
 (declare (special $comblocklist $skipme $preparse-last-line $index |$docList|
            $preparseReportIfTrue |$headerDocumentation|
            |$maxSignatureLineNumber| |$constructorLineNumber|))
  (setq $comblocklist nil)
  (setq $skipme nil)
  (when $preparse-last-line
   (if (pairp $preparse-last-line)
    (setq stack $preparse-last-line)
    (push $preparse-last-line stack))
   (setq $index (- $index (length stack))))
  (let ((u (preparse1 stack)))
   (if $skipme 
    (preparse strm)
    (progn
      (when $preparseReportIfTrue (parseprint u))
      (setq |$headerDocumentation| nil)
      (setq |$docList| nil)
      (setq |$maxSignatureLineNumber| 0)
      (setq |$constructorLineNumber| (ifcar (ifcar u)))
      u))))

@

The {\bf preparse} function returns a list of pairs of the form:
( (linenumber . linestring) .... (linenumber . linestring))
For instance, for the file {\tt EQ.spad}, we get:
\begin{verbatim}
    2> (PREPARSE #<input stream "/tmp/EQ.spad">)
      3> (PREPARSE1 (")abbrev domain EQ Equation"))
        4> (|doSystemCommand| "abbrev domain EQ Equation")
        <4 (|doSystemCommand| NIL)
      <3 (PREPARSE1 (
 (19 . "Equation(S: Type): public == private where")
 (20 . " (Ex ==> OutputForm;")
 (21 . "  public ==> Type with")
 (22 . "   (\"=\": (S, S) -> $;")
 (24 . "    equation: (S, S) -> $;")
 (26 . "    swap: $ -> $;")
 (28 . "    lhs: $ -> S;")
 (30 . "    rhs: $ -> S;")
 (32 . "    map: (S -> S, $) -> $;")
 (35 . "    if S has InnerEvalable(Symbol,S) then")
 (36 . "             InnerEvalable(Symbol,S);")
 (37 . "    if S has SetCategory then")
 (38 . "       (SetCategory;")
 (39 . "        CoercibleTo Boolean;")
 (40 . "        if S has Evalable(S) then")
 (41 . "          (eval: ($, $) -> $;")
 (43 . "           eval: ($, List $) -> $));")
 (45 . "    if S has AbelianSemiGroup then")
 (46 . "       (AbelianSemiGroup;")
 (47 . "        \"+\": (S, $) -> $;")
 (50 . "        \"+\": ($, S) -> $);")
 (53 . "    if S has AbelianGroup then")
 (54 . "       (AbelianGroup;")
 (55 . "        leftZero : $ -> $;")
 (57 . "        rightZero : $ -> $;")
 (59 . "        \"-\": (S, $) -> $;")
 (62 . "        \"-\": ($, S) -> $);")
 (65 . "    if S has SemiGroup then")
 (66 . "       (SemiGroup;")
 (67 . "        \"*\": (S, $) -> $;")
 (70 . "        \"*\": ($, S) -> $);")
 (73 . "    if S has Monoid then")
 (74 . "       (Monoid;")
 (75 . "        leftOne : $ -> Union($,\"failed\");")
 (77 . "        rightOne : $ -> Union($,\"failed\"));")
 (79 . "    if S has Group then")
 (80 . "       (Group;")
 (81 . "        leftOne : $ -> Union($,\"failed\");")
 (83 . "        rightOne : $ -> Union($,\"failed\"));")
 (85 . "    if S has Ring then")
 (86 . "     (Ring;")
 (87 . "      BiModule(S,S));")
 (88 . "    if S has CommutativeRing then")
 (89 . "      Module(S);")
 (91 . "    if S has IntegralDomain then")
 (92 . "      factorAndSplit : $ -> List $;")
 (96 . "    if S has PartialDifferentialRing(Symbol) then")
 (97 . "      PartialDifferentialRing(Symbol);")
 (98 . "    if S has Field then")
 (99 . "     (VectorSpace(S);")
 (100 . "      \"/\": ($, $) -> $;")
 (103 . "      inv: $ -> $);")
 (105 . "    if S has ExpressionSpace then")
 (106 . "        subst: ($, $) -> $);")
 (109 . "  private ==> add")
 (110 . "   (Rep := Record(lhs: S, rhs: S);")
 (111 . "    eq1,eq2: $;")
 (112 . "    s : S;")
 (113 . "    if S has IntegralDomain then")
 (114 . "        factorAndSplit eq ==")
 (115 . "         ((S has factor : S -> Factored S) =>")
 (116 . "           (eq0 := rightZero eq;")
 (117 . "            [equation(rcf.factor,0) 
                       for rcf in factors factor lhs eq0]);")
 (118 . "          [eq]);")
 (119 . "    l:S = r:S      == [l, r];")
 (120 . "    equation(l, r) == [l, r];")
 (121 . "    lhs eqn        == eqn.lhs;")
 (122 . "    rhs eqn        == eqn.rhs;")
 (123 . "    swap eqn     == [rhs eqn, lhs eqn];")
 (124 . "    map(fn, eqn)   == equation(fn(eqn.lhs), fn(eqn.rhs));")
 (125 . "    if S has InnerEvalable(Symbol,S) then")
 (126 . "       (s:Symbol;")
 (127 . "        ls:List Symbol;")
 (128 . "        x:S;")
 (129 . "        lx:List S;")
 (130 . "        eval(eqn,s,x) == eval(eqn.lhs,s,x) = eval(eqn.rhs,s,x);")
 (131 . "        eval(eqn,ls,lx) == eval(eqn.lhs,ls,lx) = 
                                     eval(eqn.rhs,ls,lx));")
 (132 . "    if S has Evalable(S) then")
 (133 . "       (eval(eqn1:$, eqn2:$):$ ==")
 (134 . "           eval(eqn1.lhs, eqn2 pretend Equation S) =")
 (135 . "               eval(eqn1.rhs, eqn2 pretend Equation S);")
 (136 . "        eval(eqn1:$, leqn2:List $):$ ==")
 (137 . "           eval(eqn1.lhs, leqn2 pretend List Equation S) =")
 (138 . "               eval(eqn1.rhs, leqn2 pretend List Equation S));")
 (139 . "    if S has SetCategory then")
 (140 . "       (eq1 = eq2 == (eq1.lhs = eq2.lhs)@Boolean and")
 (141 . "                     (eq1.rhs = eq2.rhs)@Boolean;")
 (142 . "        coerce(eqn:$):Ex == eqn.lhs::Ex = eqn.rhs::Ex;")
 (143 . "        coerce(eqn:$):Boolean == eqn.lhs = eqn.rhs);")
 (144 . "    if S has AbelianSemiGroup then")
 (145 . "       (eq1 + eq2 == eq1.lhs + eq2.lhs = eq1.rhs + eq2.rhs;")
 (146 . "        s + eq2 == [s,s] + eq2;")
 (147 . "        eq1 + s == eq1 + [s,s]);")
 (148 . "    if S has AbelianGroup then")
 (149 . "       (- eq == (- lhs eq) = (-rhs eq);")
 (150 . "        s - eq2 == [s,s] - eq2;")
 (151 . "        eq1 - s == eq1 - [s,s];")
 (152 . "        leftZero eq == 0 = rhs eq - lhs eq;")
 (153 . "        rightZero eq == lhs eq - rhs eq = 0;")
 (154 . "        0 == equation(0$S,0$S);")
 (155 . "        eq1 - eq2 == eq1.lhs - eq2.lhs = eq1.rhs - eq2.rhs);")
 (156 . "    if S has SemiGroup then")
 (157 . "       (eq1:$ * eq2:$ == eq1.lhs * eq2.lhs = eq1.rhs * eq2.rhs;")
 (158 . "        l:S   * eqn:$ == l       * eqn.lhs = l       * eqn.rhs;")
 (159 . "        l:S * eqn:$  ==  l * eqn.lhs    =    l * eqn.rhs;")
 (160 . "        eqn:$ * l:S  ==  eqn.lhs * l    =    eqn.rhs * l);")
 (165 . "    if S has Monoid then")
 (166 . "       (1 == equation(1$S,1$S);")
 (167 . "        recip eq ==")
 (168 . "         ((lh := recip lhs eq) case \"failed\" => \"failed\";")
 (169 . "          (rh := recip rhs eq) case \"failed\" => \"failed\";")
 (170 . "          [lh :: S, rh :: S]);")
 (171 . "        leftOne eq ==")
 (172 . "         ((re := recip lhs eq) case \"failed\" => \"failed\";")
 (173 . "          1 = rhs eq * re);")
 (174 . "        rightOne eq ==")
 (175 . "         ((re := recip rhs eq) case \"failed\" => \"failed\";")
 (176 . "          lhs eq * re = 1));")
 (177 . "    if S has Group then")
 (178 . "       (inv eq == [inv lhs eq, inv rhs eq];")
 (179 . "        leftOne eq == 1 = rhs eq * inv rhs eq;")
 (180 . "        rightOne eq == lhs eq * inv rhs eq = 1);")
 (181 . "    if S has Ring then")
 (182 . "       (characteristic() == characteristic()$S;")
 (183 . "        i:Integer * eq:$ == (i::S) * eq);")
 (184 . "    if S has IntegralDomain then")
 (185 . "        factorAndSplit eq ==")
 (186 . "         ((S has factor : S -> Factored S) =>")
 (187 . "           (eq0 := rightZero eq;")
 (188 . "            [equation(rcf.factor,0) 
                         for rcf in factors factor lhs eq0]);")
 (189 . "          (S has Polynomial Integer) =>")
 (190 . "           (eq0 := rightZero eq;")
 (191 . "            MF ==> MultivariateFactorize(Symbol, 
                                IndexedExponents Symbol,
                                Integer, Polynomial Integer);")
 (193 . "            p : Polynomial Integer := 
                           (lhs eq0) pretend Polynomial Integer;")
 (194 . "            [equation((rcf.factor) pretend S,0) 
                           for rcf in factors factor(p)$MF]);")
 (195 . "          [eq]);")
 (196 . "    if S has PartialDifferentialRing(Symbol) then")
 (197 . "        differentiate(eq:$, sym:Symbol):$ ==")
 (198 . "           [differentiate(lhs eq, sym), differentiate(rhs eq, sym)];")
 (199 . "    if S has Field then")
 (200 . "       (dimension() == 2 :: CardinalNumber;")
 (201 . "        eq1:$ / eq2:$ == eq1.lhs / eq2.lhs = eq1.rhs / eq2.rhs;")
 (202 . "        inv eq == [inv lhs eq, inv rhs eq]);")
 (203 . "    if S has ExpressionSpace then")
 (204 . "        subst(eq1,eq2) ==")
 (205 . "           (eq3 := eq2 pretend Equation S;")
 (206 . "            [subst(lhs eq1,eq3),subst(rhs eq1,eq3)])))")))
\end{verbatim}

\defun{preparse1}{Build the lines from the input for piles}
The READLOOP calls preparseReadLine which returns a pair of the form
\begin{verbatim}
(number . string)
\end{verbatim}
\calls{preparse1}{preparseReadLine}
\calls{preparse1}{preparse-echo}
\calls{preparse1}{fincomblock}
\calls{preparse1}{parsepiles}
\calls{preparse1}{doSystemCommand}
\calls{preparse1}{escaped}
\calls{preparse1}{indent-pos}
\calls{preparse1}{make-full-cvec}
\calls{preparse1}{maxindex}
\calls{preparse1}{strposl}
\calls{preparse1}{is-console}
\catches{preparse1}{spad-reader}
\usesdollar{preparse1}{linelist}
\usesdollar{preparse1}{echolinestack}
\usesdollar{preparse1}{byConstructors}
\usesdollar{preparse1}{skipme}
\usesdollar{preparse1}{constructorsSeen}
\usesdollar{preparse1}{preparse-last-line}
<<defun preparse1>>=
(defun preparse1 (linelist)
 (labels (
  (isSystemCommand (line lines)
    (and (> (length line) 0) (eq (char line 0) #\) )))
  (executeSystemCommand (line)
   (catch 'spad_reader (|doSystemCommand| (subseq line 1))))
 )
 (prog (($linelist linelist) $echolinestack num line i l psloc
        instring pcount comsym strsym oparsym cparsym n ncomsym
        (sloc -1) continue (parenlev 0) ncomblock lines locs nums functor)
 (declare (special $linelist $echolinestack |$byConstructors| $skipme
           |$constructorsSeen| $preparse-last-line))
READLOOP 
  (dcq (num . line) (preparseReadLine linelist))
  (unless (stringp line)
    (preparse-echo linelist)
    (cond 
     ((null lines) (return nil))
     (ncomblock    (fincomblock nil nums locs ncomblock nil)))
    (return 
     (pair (nreverse nums) (parsepiles (nreverse locs) (nreverse lines)))))
  (when (and (null lines) (isSystemCommand line lines))
    (preparse-echo linelist)
    (setq $preparse-last-line nil) ;don't reread this line
    (executeSystemCommand line)
    (go READLOOP))
  (setq l (length line))
  ; if we get a null line, read the next line
  (when (eq l 0) (go READLOOP))
  ; otherwise we have to parse this line
  (setq psloc sloc)
  (setq i 0)
  (setq instring nil)
  (setq pcount 0)
STRLOOP ;; handle things that need ignoring, quoting, or grouping
  ; are we in a comment, quoting, or grouping situation?
  (setq strsym  (or (position #\" line :start  i ) l))
  (setq comsym  (or (search "--"  line :start2 i ) l))
  (setq ncomsym (or (search "++"  line :start2 i ) l))
  (setq oparsym (or (position #\( line :start  i ) l))
  (setq cparsym (or (position #\) line :start  i ) l))
  (setq n (min strsym comsym ncomsym oparsym cparsym))
  (cond 
   ; nope, we found no comment, quoting, or grouping
   ((= n l) (go NOCOMS))
   ((escaped line n))
   ; scan until we hit the end of the string
   ((= n strsym) (setq instring (not instring)))
   ; we are in a string, just continue looping
   (instring)
   ;; handle -- comments by ignoring them
   ((= n comsym)
    (setq line (subseq line 0 n))
    (go NOCOMS)) ; discard trailing comment
   ;; handle ++ comments by chunking them together
   ((= n ncomsym)
    (setq sloc (indent-pos line))
    (cond
     ((= sloc n)
      (when (and ncomblock (not (= n (car ncomblock))))
       (fincomblock num nums locs ncomblock linelist)
       (setq ncomblock nil))
      (setq ncomblock (cons n (cons line (ifcdr ncomblock))))
      (setq line ""))
     (t 
      (push (strconc (make-full-cvec n " ") (substring line n ())) $linelist)
      (setq $index (1- $index))
      (setq line (subseq line 0 n))))
    (go NOCOMS))
   ; know how deep we are into parens
   ((= n oparsym) (setq pcount (1+ pcount)))
   ((= n cparsym) (setq pcount (1- pcount))))
  (setq i (1+ n))
  (go STRLOOP)
NOCOMS 
  ; remember the indentation level
  (setq sloc (indent-pos line))
  (setq line (string-right-trim " " line))
  (when (null sloc)
   (setq sloc psloc)
   (go READLOOP))
  ; handle line that ends in a continuation character
  (cond
   ((eq (elt line (maxindex line)) #\_)
    (setq continue t)
    (setq line (subseq line (maxindex line))))
   ((setq continue nil)))
  ; test for skipping constructors
  (when (and (null lines) (= sloc 0))
    (if (and |$byConstructors|
             (null (search "==>" line))
             (not 
              (member 
               (setq functor 
                (intern (substring line 0 (strposl ": (=" line 0 nil))))
                |$byConstructors|)))
       (setq $skipme 't)
       (progn
        (push functor |$constructorsSeen|)
        (setq $skipme nil))))
  ; is this thing followed by ++ comments?
  (when (and lines (eql sloc 0))
   (when (and ncomblock (not (zerop (car ncomblock))))
    (fincomblock num nums locs ncomblock linelist))
   (when (not (is-console in-stream))
    (setq $preparse-last-line (nreverse $echolinestack)))
   (return
    (pair (nreverse nums) (parsepiles (nreverse locs) (nreverse lines)))))
  (when (> parenlev 0)
   (push nil locs)
   (setq sloc psloc)
   (go REREAD))
  (when ncomblock
   (fincomblock num nums locs ncomblock linelist)
   (setq ncomblock ()))
  (push sloc locs)
REREAD 
  (preparse-echo linelist)
  (push line lines)
  (push num nums)
  (setq parenlev (+ parenlev pcount))
  (when (and (is-console in-stream) (not continue))
   (setq $preparse-last-line nil)
   (return
    (pair (nreverse nums) (parsepiles (nreverse locs) (nreverse lines)))))
  (go READLOOP))))

;(defun preparse1 (linelist)
; (prog (($linelist linelist) $echolinestack num a i l psloc
;        instring pcount comsym strsym oparsym cparsym n ncomsym
;        (sloc -1) (continue nil)  (parenlev 0) (ncomblock ())
;        (lines ()) (locs ()) (nums ()) functor)
; (declare (special $linelist $echolinestack |$byConstructors| $skipme
;           |$constructorsSeen| $preparse-last-line))
;READLOOP 
;  (dcq (num . a) (preparseReadLine linelist))
;  (unless (stringp a)
;    (preparse-echo linelist)
;    (cond 
;     ((null lines) (return nil))
;     (ncomblock    (fincomblock nil nums locs ncomblock nil)))
;    (return
;     (pair (nreverse nums) (parsepiles (nreverse locs) (nreverse lines)))))
;  ; this is a command line, don't parse it
;  (when (and (null lines) (> (length a) 0) (eq (char a 0) #\) ))
;    (preparse-echo linelist)
;    (setq $preparse-last-line nil) ;don't reread this line
;    (setq line a)
;    (catch 'spad_reader (|doSystemCommand| (subseq line 1)))
;    (go READLOOP))
;  (setq l (length a))
;  ; if we get a null line, read the next line
;  (when (eq l 0) (go READLOOP))
;  ; otherwise we have to parse this line
;  (setq psloc sloc)
;  (setq i 0)
;  (setq instring nil)
;  (setq pcount 0)
;STRLOOP ;; handle things that need ignoring, quoting, or grouping
;  ; are we in a comment, quoting, or grouping situation?
;  (setq strsym (or (position #\" a :start i ) l))
;  (setq comsym (or (search "--" a :start2 i ) l))
;  (setq ncomsym (or (search "++" a :start2 i ) l))
;  (setq oparsym (or (position #\( a :start i ) l))
;  (setq cparsym (or (position #\) a :start i ) l))
;  (setq n (min strsym comsym ncomsym oparsym cparsym))
;  (cond 
;   ; nope, we found no comment, quoting, or grouping
;   ((= n l) (go NOCOMS))
;   ((escaped a n))
;   ; scan until we hit the end of the string
;   ((= n strsym) (setq instring (not instring)))
;   (instring)
;   ;; handle -- comments by ignoring them
;   ((= n comsym)
;    (setq a (subseq a 0 n))
;    (go NOCOMS)) ; discard trailing comment
;   ;; handle ++ comments by chunking them together
;   ((= n ncomsym)
;    (setq sloc (indent-pos a))
;    (cond
;     ((= sloc n)
;      (when (and ncomblock (not (= n (car ncomblock))))
;       (fincomblock num nums locs ncomblock linelist)
;       (setq ncomblock nil))
;      (setq ncomblock (cons n (cons a (ifcdr ncomblock))))
;      (setq a ""))
;     (t 
;      (push (strconc (make-full-cvec n " ") (substring a n ())) $linelist)
;      (setq $index (1- $index))
;      (setq a (subseq a 0 n))))
;    (go NOCOMS))
;   ; know how deep we are into parens
;   ((= n oparsym) (setq pcount (1+ pcount)))
;   ((= n cparsym) (setq pcount (1- pcount))))
;  (setq i (1+ n))
;  (go STRLOOP)
;NOCOMS 
;  ; remember the indentation level
;  (setq sloc (indent-pos a))
;  (setq a (string-right-trim " " a))
;  (when (null sloc)
;   (setq sloc psloc)
;   (go READLOOP))
;  ; handle line that ends in a continuation character
;  (cond
;   ((eq (elt a (maxindex a)) #\_)
;    (setq continue t)
;    (setq a (subseq a (maxindex a))))
;   ((setq continue nil)))
;  ; test for skipping constructors
;  (when (and (null lines) (= sloc 0))
;    (if (and |$byConstructors|
;             (null (search "==>" a))
;             (not 
;              (member 
;               (setq functor 
;                (intern (substring a 0 (strposl ": (=" a 0 nil))))
;                |$byConstructors|)))
;       (setq $skipme 't)
;       (progn
;        (push functor |$constructorsSeen|)
;        (setq $skipme nil))))
;  ; is this thing followed by ++ comments?
;  (when (and lines (eql sloc 0))
;   (when (and ncomblock (not (zerop (car ncomblock))))
;    (fincomblock num nums locs ncomblock linelist))
;   (when (not (is-console in-stream))
;    (setq $preparse-last-line (nreverse $echolinestack)))
;   (return
;    (pair (nreverse nums) (parsepiles (nreverse locs) (nreverse lines)))))
;  (when (> parenlev 0)
;   (push nil locs)
;   (setq sloc psloc)
;   (go REREAD))
;  (when ncomblock
;   (fincomblock num nums locs ncomblock linelist)
;   (setq ncomblock ()))
;  (push sloc locs)
;REREAD 
;  (preparse-echo linelist)
;  (push a lines)
;  (push num nums)
;  (setq parenlev (+ parenlev pcount))
;  (when (and (is-console in-stream) (not continue))
;   (setq $preparse-last-line nil)
;   (return
;    (pair (nreverse nums) (parsepiles (nreverse locs) (nreverse lines)))))
;  (go READLOOP)))

@

\defun{parsepiles}{parsepiles}
Add parens and semis to lines to aid parsing.
\calls{parsepiles}{add-parens-and-semis-to-line}
<<defun parsepiles>>=
(defun parsepiles (locs lines)
  (mapl #'add-parens-and-semis-to-line
    (nconc lines '(" ")) (nconc locs '(nil)))
  lines)

@
 
\defun{add-parens-and-semis-to-line}{add-parens-and-semis-to-line}
The line to be worked on is (CAR SLINES).  It's indentation is (CAR SLOCS).
There is a notion of current indentation. Then:
\begin{itemize}
\item Add open paren to beginning of following line if following line's 
indentation is greater than current, and add close paren to end of 
last succeeding line with following line's indentation.
\item Add semicolon to end of line if following line's indentation is the same.
\item If the entire line consists of the single keyword then or else, 
leave it alone."
\end{itemize}
\calls{add-parens-and-semis-to-line}{infixtok}
\calls{add-parens-and-semis-to-line}{drop}
\calls{add-parens-and-semis-to-line}{addclose}
\calls{add-parens-and-semis-to-line}{nonblankloc}
<<defun add-parens-and-semis-to-line>>=
(defun add-parens-and-semis-to-line (slines slocs)
 (let ((start-column (car slocs)))
  (when (and start-column (> start-column 0))
   (let ((count 0) (i 0))
    (seq
     (mapl #'(lambda (next-lines nlocs)
              (let ((next-line (car next-lines)) (next-column (car nlocs)))
               (incf i)
               (when next-column
                (setq next-column (abs next-column))
                (when (< next-column start-column) (exit nil))
                (cond
                 ((and (eq next-column start-column)
                       (rplaca nlocs (- (car nlocs)))
                       (not (infixtok next-line)))
                   (setq next-lines (drop (1- i) slines))
                   (rplaca next-lines (addclose (car next-lines) #\;))
                   (setq count (1+ count)))))))
                 (cdr slines) (cdr slocs)))
     (when (> count 0)
      (setf (char (car slines) (1- (nonblankloc (car slines)))) #\( )
      (setq slines (drop (1- i) slines))
      (rplaca slines (addclose (car slines) #\) )))))))
 
@

\defun{preparseReadLine}{preparseReadLine}
\calls{preparseReadLine}{dcq}
\calls{preparseReadLine}{preparseReadLine1}
\calls{preparseReadLine}{initial-substring}
\calls{preparseReadLine}{string2BootTree}
\calls{preparseReadLine}{storeblanks}
\calls{preparseReadLine}{skip-to-endif}
\calls{preparseReadLine}{preparseReadLine}
<<defun preparseReadLine>>=
(defun preparseReadLine (x)
 (let (line ind)
  (dcq (ind . line) (preparseReadLine1))
  (cond
   ((not (stringp line)) (cons ind line))
   ((zerop (size line))  (cons ind line))
   ((char= (elt line 0) #\) )
    (cond
     ((initial-substring ")if" line)
      (if (eval (|string2BootTree| (storeblanks line 3)))
       (preparseReadLine x)
       (skip-ifblock x)))
     ((initial-substring ")elseif" line) (skip-to-endif x))
     ((initial-substring ")else" line)   (skip-to-endif x))
     ((initial-substring ")endif" line)  (preparseReadLine x))
     ((initial-substring ")fin" line)
      (setq *eof* t)
      (cons ind nil)))))
  (cons ind line)))
 
@

\defun{preparseReadLine1}{preparseReadLine1}
\calls{preparseReadLine1}{get-a-line}
\calls{preparseReadLine1}{expand-tabs}
\calls{preparseReadLine1}{maxindex}
\calls{preparseReadLine1}{strconc}
\calls{preparseReadLine1}{preparseReadLine1}
\usesdollar{preparseReadLine1}{linelist}
\usesdollar{preparseReadLine1}{preparse-last-line}
\usesdollar{preparseReadLine1}{index}
\usesdollar{preparseReadLine1}{EchoLineStack}
<<defun preparseReadLine1>>=
(defun preparseReadLine1 ()
 (labels (
  (accumulateLinesWithTrailingEscape (line)
   (let (ind)
   (declare (special $preparse-last-line))
     (if (and (> (setq ind (maxindex line)) -1) (char= (elt line ind) #\_))
      (setq $preparse-last-line
        (strconc (substring line 0 ind) (cdr (preparseReadLine1))))
      line))))
 (let (line)
 (declare (special $linelist $preparse-last-line $index $EchoLineStack))
  (setq line
   (if $linelist
    (pop $linelist)
    (expand-tabs (get-a-line in-stream))))
  (setq $preparse-last-line line)
  (if (stringp line)
   (progn
    (incf $index)   ;; $index is the current line number
    (setq line (string-right-trim " " line))
    (push (copy-seq line) $EchoLineStack)
    (cons $index (accumulateLinesWithTrailingEscape line)))
   (cons $index line)))))
 
@

\section{I/O Handling}
\defun{preparse-echo}{preparse-echo}
\uses{preparse-echo}{Echo-Meta}
\usesdollar{preparse-echo}{EchoLineStack}
<<defun preparse-echo>>=
(defun preparse-echo (linelist)
 (declare (special $EchoLineStack Echo-Meta) (ignore linelist))
 (if Echo-Meta 
  (dolist (x (reverse $EchoLineStack))
   (format out-stream "~&;~A~%" x)))
 (setq $EchoLineStack ()))

@

<<initvars>>=
(defparameter Current-Fragment nil
  "A string containing remaining chars from readline; needed because
Symbolics read-line returns embedded newlines in a c-m-Y.")

@

\defun{read-a-line}{read-a-line}
\calls{read-a-line}{subseq}
\calls{read-a-line}{Line-New-Line}
\calls{read-a-line}{read-a-line}
\uses{read-a-line}{*eof*}
<<defun read-a-line>>=
(defun read-a-line (&optional (stream t))
 (let (cp)
 (declare (special *eof*))
  (if (and Current-Fragment (> (length Current-Fragment) 0))
   (let ((line (with-input-from-string
                 (s Current-Fragment :index cp :start 0)
                 (read-line s nil nil))))
    (setq Current-Fragment (subseq Current-Fragment cp))
    line)
   (prog nil
    (when (stream-eof in-stream)
      (setq File-Closed t)
      (setq *eof* t)
      (Line-New-Line (make-string 0) Current-Line)
      (return nil))
    (when (setq Current-Fragment (read-line stream))
     (return (read-a-line stream)))))))

@

\section{Line Handling}

\subsection{Line Buffer}
The philosophy of lines is that
\begin{itemize}
\item NEXT LINE will always return a non-blank line or fail.
\item Every line is terminated by a blank character.
\end{itemize}
Hence there is always a current character, because there is never a 
non-blank line, and there is always a separator character between tokens 
on separate lines. Also, when a line is read, the character pointer is 
always positioned ON the first character.
\defstruct{Line}
<<initvars>>=
;(defstruct Line "Line of input file to parse."
;           (Buffer (make-string 0) :type string)
;           (Current-Char #\Return :type character)
;           (Current-Index 1 :type fixnum)
;           (Last-Index 0 :type fixnum)
;           (Number 0 :type fixnum))

@

\defun{Line-New-Line}{Line-New-Line}
\usesstruct{Line-New-Line}{Line}
<<defun Line-New-Line>>=
(defun Line-New-Line (string line &optional (linenum nil))
  "Sets string to be the next line stored in line."
  (setf (Line-Last-Index line) (1- (length string)))
  (setf (Line-Current-Index line) 0)
  (setf (Line-Current-Char line)
        (or (and (> (length string) 0) (elt string 0)) #\Return))
  (setf (Line-Buffer line) string)
  (setf (Line-Number line) (or linenum (1+ (Line-Number line)))))

@

\defun{next-line}{next-line}
<<defun next-line>>=
(defun next-line (&optional (in-stream t))
 (funcall Line-Handler in-stream))

@

\defun{storeblanks}{storeblanks}
<<defun storeblanks>>=
(defun storeblanks (line n)
 (do ((i 0 (1+ i)))
     ((= i n) line)
  (setf (char line i) #\ )))

@
 
\defun{initial-substring}{initial-substring}
\calls{initial-substring}{mismatch}
<<defun initial-substring>>=
(defun initial-substring (pattern line)
   (let ((ind (mismatch pattern line)))
     (or (null ind) (eql ind (size pattern)))))

@
 
\defun{get-a-line}{get-a-line}
\calls{get-a-line}{is-console}
\calls{get-a-line}{mkprompt}
\calls{get-a-line}{read-a-line}
\calls{get-a-line}{make-string-adjustable}
<<defun get-a-line>>=
(defun get-a-line (stream)
 (when (is-console stream) (princ (mkprompt)))
 (let ((ll (read-a-line stream)))
  (if (stringp ll)
   (make-string-adjustable ll)
   ll)))

@

\defun{make-string-adjustable}{make-string-adjustable}
<<defun make-string-adjustable>>=
(defun make-string-adjustable (s)
 (if (adjustable-array-p s) 
  s
  (make-array (array-dimensions s) :element-type 'string-char
                  :adjustable t :initial-contents s)))

@

\chapter{Parse Transformers}
\section{Direct called parse routines}
\defun{parseTransform}{parseTransform}
\calls{parseTransform}{msubst}
\calls{parseTransform}{parseTran}
\usesdollar{parseTransform}{defOp}
<<defun parseTransform>>=
(defun |parseTransform| (x)
 (let (|$defOp|)
 (declare (special |$defOp|))
  (setq |$defOp| nil)
  (setq x (msubst '$ '% x)) ; for new compiler compatibility
  (|parseTran| x)))

@


\defun{parseTran}{parseTran}
\calls{parseTran}{parseAtom}
\calls{parseTran}{parseConstruct}
\calls{parseTran}{parseTran}
\calls{parseTran}{parseTranList}
\calls{parseTran}{getl}
\usesdollar{parseTran}{op}
<<defun parseTran>>=
(defun |parseTran| (x)
 (labels (
  (g (op)
   (let (tmp1 tmp2 x)
    (seq
     (if (and (pairp op) (eq (qcar op) '|elt|)
         (progn
          (setq tmp1 (qcdr op))
          (and (pairp tmp1)
               (progn
                (setq op (qcar tmp1))
                (setq tmp2 (qcdr tmp1))
                (and (pairp tmp2)
                     (eq (qcdr tmp2) nil)
                         (progn (setq x (qcar tmp2)) t))))))
        (exit (g x)))
     (exit op)))))
 (let (|$op| argl u r fn)
 (declare (special |$op|))
  (setq |$op| nil)
  (if (atom x) 
   (|parseAtom| x)
   (progn
    (setq |$op| (car x)) 
    (setq argl (cdr x))
    (setq u (g |$op|))
    (cond
     ((eq u '|construct|)
       (setq r (|parseConstruct| argl))
       (if (and (pairp |$op|) (eq (qcar |$op|) '|elt|))
        (cons (|parseTran| |$op|) (cdr r))
        r))
     ((and (atom u) (setq fn (getl u '|parseTran|)))
       (funcall fn argl))
     (t (cons (|parseTran| |$op|) (|parseTranList| argl)))))))))

@

\defun{parseAtom}{parseAtom}
\calls{parseAtom}{parseLeave}
\usesdollar{parseAtom}{NoValue}
<<defun parseAtom>>=
(defun |parseAtom| (x)
 (declare (special |$NoValue|))
 (if (eq x '|break|)
  (|parseLeave| (list '|$NoValue|))
  x))

@

\defun{parseTranList}{parseTranList}
\calls{parseTranList}{parseTran}
\calls{parseTranList}{parseTranList}
<<defun parseTranList>>=
(defun |parseTranList| (x)
 (if (atom x)
  (|parseTran| x)
  (cons (|parseTran| (car x)) (|parseTranList| (cdr x)))))

@

\defplist{construct}{parseConstruct}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|construct| '|parseTran|) '|parseConstruct|))

@

\defun{parseConstruct}{parseConstruct}
\calls{parseConstruct}{parseTranList}
\usesdollar{parseConstruct}{insideConstructIfTrue}
<<defun parseConstruct>>=
(defun |parseConstruct| (u)
 (let (|$insideConstructIfTrue| x)
 (declare (special |$insideConstructIfTrue|))
  (setq |$insideConstructIfTrue| t)
  (setq x (|parseTranList| u))
  (cons '|construct| x)))

@

\section{Indirect called parse routines}
In the {\bf parseTran} function there is the code:
\begin{verbatim}
     ((and (atom u) (setq fn (getl u '|parseTran|)))
       (funcall fn argl))
\end{verbatim}

The functions in this section are called through the symbol-plist
of the symbol being parsed. The original list read:

\begin{verbatim}
  and          parseAnd
  @            parseAtSign
  CATEGORY     parseCategory
  ::           parseCoerce
  \:           parseColon
  construct    parseConstruct
  DEF          parseDEF
  $<=          parseDollarLessEqual
  $>           parseDollarGreaterThan
  $>=          parseDollarGreaterEqual
  $^=          parseDollarNotEqual
  eqv          parseEquivalence
;;xor          parseExclusiveOr
  exit         parseExit
  >            parseGreaterThan
  >=           parseGreaterEqual
  has          parseHas
  IF           parseIf
  implies      parseImplies
  IN           parseIn
  INBY         parseInBy
  is           parseIs
  isnt         parseIsnt
  Join         parseJoin
  leave        parseLeave
;;control-H    parseLeftArrow
  <=           parseLessEqual
  LET          parseLET
  LETD         parseLETD
  MDEF         parseMDEF
  ^            parseNot
  not          parseNot
  ^=           parseNotEqual
  or           parseOr
  pretend      parsePretend
  return       parseReturn
  SEGMENT      parseSegment
  SEQ          parseSeq
;;control-V    parseUpArrow
  VCONS        parseVCONS
  where        parseWhere
\end{verbatim}


\defplist{and}{parseAnd}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|and| '|parseTran|) '|parseAnd|))

@

\defun{parseAnd}{parseAnd}
\calls{parseAnd}{parseTran}
\calls{parseAnd}{parseAnd}
\calls{parseAnd}{parseTranList}
\calls{parseAnd}{parseIf}
\usesdollar{parseAnd}{InteractiveMode}
<<defun parseAnd>>=
(defun |parseAnd| (arg)
 (cond
  (|$InteractiveMode| (cons '|and| (|parseTranList| arg)))
  ((null arg) '|true|)
  ((null (cdr arg)) (car arg))
  (t
   (|parseIf|
    (list (|parseTran| (car arg)) (|parseAnd| (CDR arg)) '|false| )))))

@

\defplist{@}{parseAtSign}
<<postvars>>=
(eval-when (eval load)
 (setf (get '@ '|parseTran|) '|parseAtSign|))

@

\defun{parseAtSign}{parseAtSign}
\calls{parseAtSign}{parseTran}
\calls{parseAtSign}{parseType}
\usesdollar{parseAtSign}{InteractiveMode}
<<defun parseAtSign>>=
(defun |parseAtSign| (arg)
 (declare (special |$InteractiveMode|))
 (if |$InteractiveMode|
  (list '@ (|parseTran| (first arg)) (|parseTran| (|parseType| (second arg))))
  (list '@ (|parseTran| (first arg)) (|parseTran| (second arg)))))

@

\defplist{category}{parseCategory}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'category '|parseTran|) '|parseCategory|))

@

\defun{parseCategory}{parseCategory}
\calls{parseCategory}{parseTranList}
\calls{parseCategory}{parseDropAssertions}
\calls{parseCategory}{contained}
<<defun parseCategory>>=
(defun |parseCategory| (arg)
 (let (z key)
  (setq z (|parseTranList| (|parseDropAssertions| arg)))
  (setq key (if (contained '$ z) '|domain| '|package|))
  (cons 'category (cons key z))))

@

\defplist{::}{parseCoerce}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|::| '|parseTran|) '|parseCoerce|))

@

\defun{parseCoerce}{parseCoerce}
\calls{parseCoerce}{parseType}
\calls{parseCoerce}{parseTran}
\usesdollar{parseCoerce}{InteractiveMode}
<<defun parseCoerce>>=
(defun |parseCoerce| (arg)
 (if |$InteractiveMode|
  (list '|::|
    (|parseTran| (first arg)) (|parseTran| (|parseType| (second arg))))
  (list '|::| (|parseTran| (first arg)) (|parseTran| (second arg)))))

@

\defplist{:}{parseColon}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|:| '|parseTran|) '|parseColon|))

@

\defun{parseColon}{parseColon}
\calls{parseColon}{parseTran}
\calls{parseColon}{parseType}
\usesdollar{parseColon}{InteractiveMode}
\usesdollar{parseColon}{insideConstructIfTrue}
<<defun parseColon>>=
(defun |parseColon| (arg)
 (cond
  ((and (pairp arg) (eq (qcdr arg) nil))
   (list '|:| (|parseTran| (first arg))))
  ((and (pairp arg) (pairp (qcdr arg)) (eq (qcdr (qcdr arg)) nil))
    (if |$InteractiveMode|
      (if |$insideConstructIfTrue|
        (list 'tag (|parseTran| (first arg))
                   (|parseTran| (second arg)))
        (list '|:| (|parseTran| (first arg))
                   (|parseTran| (|parseType| (second arg)))))
      (list '|:| (|parseTran| (first arg))
                 (|parseTran| (second arg)))))))

@

\defplist{def}{parseDEF}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'def '|parseTran|) '|parseDEF|))

@

\defun{parseDEF}{parseDEF}
\calls{parseDEF}{setDefOp}
\calls{parseDEF}{parseLhs}
\calls{parseDEF}{parseTranList}
\calls{parseDEF}{parseTranCheckForRecord}
\calls{parseDEF}{opFf}
\usesdollar{parseDEF}{lhs}
<<defun parseDEF>>=
(defun |parseDEF| (arg)
 (let (|$lhs| tList specialList body)
 (declare (special |$lhs|))
  (setq |$lhs| (first arg))
  (setq tList (second arg))
  (setq specialList (third arg))
  (setq body (fourth arg))
  (|setDefOp| |$lhs|)
  (list 'def (|parseLhs| |$lhs|)
             (|parseTranList| tList)
             (|parseTranList| specialList)
             (|parseTranCheckForRecord| body (|opOf| |$lhs|)))))

@

\defplist{dollargreaterthan}{parseDollarGreaterthan}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|$>| '|parseTran|) '|parseDollarGreaterThan|))

@

\defun{parseDollarGreaterThan}{parseDollarGreaterThan}
\calls{parseDollarGreaterThan}{msubst}
\calls{parseDollarGreaterThan}{parseTran}
\usesdollar{parseDollarGreaterThan}{op}
<<defun parseDollarGreaterThan>>=
(defun |parseDollarGreaterThan| (arg)
 (declare (special |$op|))
  (list (msubst '$< '$> |$op|)
        (|parseTran| (second arg))
        (|parseTran| (first arg))))

@

\defplist{dollargreaterequal}{parseDollarGreaterEqual}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|$>=| '|parseTran|) '|parseDollarGreaterEqual|))

@

\defun{parseDollarGreaterEqual}{parseDollarGreaterEqual}
\calls{parseDollarGreaterEqual}{msubst}
\calls{parseDollarGreaterEqual}{parseTran}
\usesdollar{parseDollarGreaterEqual}{op}
<<defun parseDollarGreaterEqual>>=
(defun |parseDollarGreaterEqual| (arg)
 (declare (special |$op|))
  (|parseTran| (list '|not| (cons (msubst '$< '$>= |$op|) arg))))

@

%\defplist{dollarlessequal}{parseDollarLessEqual}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|$<=| '|parseTran|) '|parseDollarLessEqual|))

@

\defun{parseDollarLessEqual}{parseDollarLessEqual}
\calls{parseDollarLessEqual}{msubst}
\calls{parseDollarLessEqual}{parseTran}
\usesdollar{parseDollarLessEqual}{op}
<<defun parseDollarLessEqual>>=
(defun |parseDollarLessEqual| (arg)
 (declare (special |$op|))
  (|parseTran| (list '|not| (cons (msubst '$> '$<= |$op|) arg))))

@

\defplist{dollarnotequal}{parseDollarNotEqual}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|$^=| '|parseTran|) '|parseDollarNotEqual|))

@

\defun{parseDollarNotEqual}{parseDollarNotEqual}
\calls{parseDollarNotEqual}{parseTran}
\calls{parseDollarNotEqual}{msubst}
\usesdollar{parseDollarNotEqual}{op}
<<defun parseDollarNotEqual>>=
(defun |parseDollarNotEqual| (arg)
 (declare (special |$op|))
 (|parseTran| (list '|not| (cons (msubst '$= '$^= |$op|) arg))))

@

\defplist{eqv}{parseEquivalence}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|eqv| '|parseTran|) '|parseEquivalence|))

@

\defun{parseEquivalence}{parseEquivalence}
\calls{parseEquivalence}{parseIf}
<<defun parseEquivalence>>=
(defun |parseEquivalence| (arg)
  (|parseIf|
   (list (first arg) (second arg)
     (|parseIf| (cons (second arg) '(|false| |true|))))))

@

\defplist{$>=$}{parseExit}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|exit| '|parseTran|) '|parseExit|))

@

\defun{parseExit}{parseExit}
\calls{parseExit}{parseTran}
\calls{parseExit}{moan}
<<defun parseExit>>=
(defun |parseExit| (arg)
 (let (a b)
  (setq a (|parseTran| (car arg)))
  (setq b (|parseTran| (cdr arg)))
  (if b
    (cond
     ((null (integerp a))
       (moan "first arg " a " for exit must be integer")
       (list '|exit| 1 a ))
     (t
      (cons '|exit| (cons a b))))
    (list '|exit| 1 a ))))

@

\defplist{$>=$}{parseGreaterEqual}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|>=| '|parseTran|) '|parseGreaterEqual|))

@

\defun{parseGreaterEqual}{parseGreaterEqual}
\calls{parseGreaterEqual}{parseTran}
\usesdollar{parseGreaterEqual}{op}
<<defun parseGreaterEqual>>=
(defun |parseGreaterEqual| (arg)
 (declare (special |$op|))
 (|parseTran| (list '|not| (cons (msubst '< '>= |$op|) arg))))

@

\defplist{$>$}{parseGreaterThan}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|>| '|parseTran|) '|parseGreaterThan|))

@

\defun{parseGreaterThan}{parseGreaterThan}
\calls{parseGreaterThan}{parseTran}
\usesdollar{parseGreaterThan}{op}
<<defun parseGreaterThan>>=
(defun |parseGreaterThan| (arg)
 (declare (special |$op|))
 (list (msubst '< '> |$op|)
  (|parseTran| (second arg)) (|parseTran| (first arg))))

@

\defplist{has}{parseHas}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|has| '|parseTran|) '|parseHas|))

@

<<defun parseHas>>=
(defun |parseHas| (arg)
 (labels (
  (fn (arg)
   (let (tmp4 tmp6 map op kk)
   (declare (special |$InteractiveMode|))
    (when |$InteractiveMode| (setq arg (|unabbrevAndLoad| arg)))
    (cond
     ((and (pairp arg) (eq (qcar arg) '|:|) (pairp (qcdr arg))
               (pairp (qcdr (qcdr arg))) (eq (qcdr (qcdr (qcdr arg))) nil)
               (pairp (qcar (qcdr (qcdr arg))))
               (eq (qcar (qcar (qcdr (qcdr arg)))) '|Mapping|))
        (setq map (rest (third arg)))
        (setq op (second arg))
        (setq op (if (stringp op) (intern op) op))
        (list (list 'signature op map)))
     ((and (pairp arg) (eq (qcar arg) '|Join|))
        (dolist (z (rest arg) tmp4)
         (setq tmp4 (append tmp4 (fn z)))))
     ((and (pairp arg) (eq (qcar arg) 'category))
        (dolist (z (rest arg) tmp6)
          (setq tmp6 (append tmp6 (fn z)))))
     (t
      (setq kk (getdatabase (|opOf| arg) 'constructorkind))
      (cond
       ((or (eq kk '|domain|) (eq kk '|category|))
         (list (|makeNonAtomic| arg)))
       ((and (pairp arg) (eq (qcar arg) 'attribute))
         (list arg))
      ((and (pairp arg) (eq (qcar arg) 'signature))
        (list arg))
      (|$InteractiveMode|
        (|parseHasRhs| arg))
      (t
        (list (list 'attribute arg)))))))))
 (let (tmp1 tmp2 tmp3 x)
 (declare (special |$InteractiveMode| |$CategoryFrame|))
  (setq x (first arg))
  (setq tmp1 (|get| x '|value| |$CategoryFrame|))
  (when |$InteractiveMode|
   (setq x
     (if (and (pairp tmp1) (pairp (qcdr tmp1)) (pairp (qcdr (qcdr tmp1)))
            (eq (qcdr (qcdr (qcdr tmp1))) nil)
            (|member| (second tmp1)
             '((|Mode|) (|Domain|) (|SubDomain| (|Domain|)))))
       (first tmp1)
       (|parseType| x))))
  (setq tmp2 
   (dolist (u (fn (second arg)) (nreverse0 tmp3))
     (push (list '|has| x u ) tmp3)))
  (if (and (pairp tmp2) (eq (qcdr tmp2) nil))
   (qcar tmp2)
   (cons '|and| tmp2)))))



@

\defun{parseIf,ifTran}{parseIf,ifTran}
\calls{parseIf,ifTran}{parseIf,ifTran}
\calls{parseIf,ifTran}{incExitLevel}
\calls{parseIf,ifTran}{makeSimplePredicateOrNil}
\calls{parseIf,ifTran}{incExitLevel}
\calls{parseIf,ifTran}{parseTran}
\usesdollar{parseIf,ifTran}{InteractiveMode}
<<defun parseIf,ifTran>>=
(defun |parseIf,ifTran| (p a b)
 (let (pp z ap bp tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 val s)
 (declare (special |$InteractiveMode|))
   (cond
    ((and (null |$InteractiveMode|) (eq p '|true|))
     a)
    ((and (null |$InteractiveMode|) (eq p '|false|))
     b)
    ((and (pairp p) (eq (qcar p) '|not|)
          (pairp (qcdr p)) (eq (qcdr (qcdr p)) nil))
     (|parseIf,ifTran| (second p) b a))
    ((and (pairp p) (eq (qcar p) 'if)
             (progn
              (setq tmp1 (qcdr p))
              (and (pairp tmp1)
                   (progn
                    (setq pp (qcar tmp1))
                    (setq tmp2 (qcdr tmp1))
                    (and (pairp tmp2)
                         (progn
                          (setq ap (qcar tmp2))
                          (setq tmp3 (qcdr tmp2))
                          (and (pairp tmp3)
                               (eq (qcdr tmp3) nil)
                               (progn (setq bp (qcar tmp3)) t))))))))
     (|parseIf,ifTran| pp
       (|parseIf,ifTran| ap (copy a) (copy b))
       (|parseIf,ifTran| bp a b)))
    ((and (pairp p) (eq (qcar p) 'seq)
          (pairp (qcdr p)) (progn (setq tmp2 (reverse (qcdr p))) t)
          (and (pairp tmp2)
               (pairp (qcar tmp2))
               (eq (qcar (qcar tmp2)) '|exit|)
               (progn
                  (setq tmp4 (qcdr (qcar tmp2)))
                  (and (pairp tmp4)
                       (equal (qcar tmp4) 1)
                       (progn
                        (setq tmp5 (qcdr tmp4))
                        (and (pairp tmp5)
                             (eq (qcdr tmp5) nil)
                             (progn (setq pp (qcar tmp5)) t)))))
               (progn (setq z (qcdr tmp2)) t))
          (progn (setq z (nreverse z)) t))
     (cons 'seq
       (append z
        (list
         (list '|exit| 1 (|parseIf,ifTran| pp
                           (|incExitLevel| a)
                            (|incExitLevel| b)))))))
    ((and (pairp a) (eq (qcar a) 'if) (pairp (qcdr a))
          (equal (qcar (qcdr a)) p) (pairp (qcdr (qcdr a)))
          (pairp (qcdr (qcdr (qcdr a))))
          (eq (qcdr (qcdr (qcdr (qcdr a)))) nil))
     (list 'if p (third a) b))
    ((and (pairp b) (eq (qcar b) 'if)
          (pairp (qcdr b)) (equal (qcar (qcdr b)) p)
          (pairp (qcdr (qcdr b)))
          (pairp (qcdr (qcdr (qcdr b))))
          (eq (qcdr (qcdr (qcdr (qcdr b)))) nil))
     (list 'if p a (fourth b)))
    ((progn
      (setq tmp1 (|makeSimplePredicateOrNil| p))
      (and (pairp tmp1) (eq (qcar tmp1) 'seq)
           (progn
            (setq tmp2 (qcdr tmp1))
            (and (and (pairp tmp2)
                 (progn (setq tmp3 (reverse tmp2)) t))
                 (and (pairp tmp3)
                      (progn 
                       (setq tmp4 (qcar tmp3))
                       (and (pairp tmp4) (eq (qcar tmp4) '|exit|)
                            (progn
                             (setq tmp5 (qcdr tmp4))
                             (and (pairp tmp5) (equal (qcar tmp5) 1)
                                  (progn
                                   (setq tmp6 (qcdr tmp5))
                                   (and (pairp tmp6) (eq (qcdr tmp6) nil)
                                        (progn (setq val (qcar tmp6)) t)))))))
                                  (progn (setq s (qcdr tmp3)) t))))))
     (setq s (nreverse s))
     (|parseTran|
      (cons 'seq
       (append s
        (list (list '|exit| 1 (|incExitLevel| (list 'if val a b))))))))
    (t
     (list 'if p a b )))))

@

\defplist{if}{parseIf}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'if '|parseTran|) '|parseIf|))

@

\defun{parseIf}{parseIf}
\calls{parseIf}{parseIf,ifTran}
\calls{parseIf}{parseTran}
<<defun parseIf>>=
(defun |parseIf| (arg)
  (if (null (and (pairp arg) (pairp (qcdr arg))
                 (pairp (qcdr (qcdr arg))) (eq (qcdr (qcdr (qcdr arg))) nil)))
    arg
    (|parseIf,ifTran|
      (|parseTran| (first arg))
      (|parseTran| (second arg))
      (|parseTran| (third arg)))))

@

\defplist{implies}{parseImplies}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|implies| '|parseTran|) '|parseImplies|))

@

\defun{parseImplies}{parseImplies}
\calls{parseImplies}{parseIf}
<<defun parseImplies>>=
(defun |parseImplies| (arg)
 (|parseIf| (list (first arg) (second arg) '|true|)))

@

\defplist{in}{parseIn}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'in '|parseTran|) '|parseIn|))

@

\defun{parseIn}{parseIn}
\calls{parseIn}{parseTran}
\calls{parseIn}{postError}
<<defun parseIn>>=
(defun |parseIn| (arg)
 (let (i n)
  (setq i (|parseTran| (first arg)))
  (setq n (|parseTran| (second arg)))
  (cond
   ((and (pairp n) (eq (qcar n) 'segment)
         (pairp (qcdr n)) (eq (qcdr (qcdr n)) nil))
    (list 'step i (second n) 1))
   ((and (pairp n) (eq (qcar n) '|reverse|)
         (pairp (qcdr n)) (eq (qcdr (qcdr n)) nil)
         (pairp (qcar (qcdr n))) (eq (qcar (qcar (qcdr n))) 'segment)
         (pairp (qcdr (qcar (qcdr n))))
         (eq (qcdr (qcdr (qcar (qcdr n)))) nil))
    (|postError| (list "  You cannot reverse an infinite sequence." )))
   ((and (pairp n) (eq (qcar n) 'segment)
         (pairp (qcdr n)) (pairp (qcdr (qcdr n)))
         (eq (qcdr (qcdr (qcdr n))) nil))
    (if (third n)
     (list 'step i (second n) 1 (third n))
     (list 'step i (second n) 1)))
   ((and (pairp n) (eq (qcar n) '|reverse|)
         (pairp (qcdr n)) (eq (qcdr (qcdr n)) nil)
         (pairp (qcar (qcdr n))) (eq (qcar (qcar (qcdr n))) 'segment)
         (pairp (qcdr (qcar (qcdr n))))
         (pairp (qcdr (qcdr (qcar (qcdr n)))))
         (eq (qcdr (qcdr (qcdr (qcar (qcdr n))))) nil))
    (if (third (second n))
     (list 'step i (third (second n)) -1 (second (second n)))
     (|postError| (list "  You cannot reverse an infinite sequence."))))
   ((and (pairp n) (eq (qcar n) '|tails|)
         (pairp (qcdr n)) (eq (qcdr (qcdr n)) nil))
    (list 'on i (second n)))
   (t
    (list 'in i n)))))

@

\defplist{inby}{parseInBy}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'inby '|parseTran|) '|parseInBy|))

@

\defun{parseInBy}{parseInBy}
\calls{parseInBy}{postError}
\calls{parseInBy}{parseTran}
\calls{parseInBy}{bright}
\calls{parseInBy}{parseIn}
<<defun parseInBy>>=
(defun |parseInBy| (arg)
 (let (i n inc u)
  (setq i (first arg))
  (setq n (second arg))
  (setq inc (third arg))
  (setq u (|parseIn| (list i n)))
  (cond
   ((null (and (pairp u) (eq (qcar u) 'step)
               (pairp (qcdr u))
               (pairp (qcdr (qcdr u)))
               (pairp (qcdr (qcdr (qcdr u))))))
    (|postError|
     (cons '|   You cannot use|
      (append (|bright| "by")
       (list "except for an explicitly indexed sequence.")))))
   (t 
    (setq inc (|parseTran| inc))
    (cons 'step
     (cons (second u)
      (cons (third u) 
       (cons (|parseTran| inc) (cddddr u)))))))))

@

\defplist{is}{parseIs}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|is| '|parseTran|) '|parseIs|))

@

\defun{parseIs}{parseIs}
\calls{parseIs}{parseTran}
\calls{parseIs}{transIs}
<<defun parseIs>>=
(defun |parseIs| (arg)
 (list '|is| (|parseTran| (first arg)) (|transIs| (|parseTran| (second arg)))))

@

\defplist{isnt}{parseIsnt}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|isnt| '|parseTran|) '|parseIsnt|))

@

\defun{parseIsnt}{parseIsnt}
\calls{parseIsnt}{parseTran}
\calls{parseIsnt}{transIs}
<<defun parseIsnt>>=
(defun |parseIsnt| (arg)
 (list '|isnt|
   (|parseTran| (first arg))
   (|transIs| (|parseTran| (second arg)))))

@

\defplist{Join}{parseJoin}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|Join| '|parseTran|) '|parseJoin|))

@

\defun{parseJoin}{parseJoin}
\calls{parseJoin}{parseTranList}
<<defun parseJoin>>=
(defun |parseJoin| (thejoin)
 (labels (
  (fn (arg)
   (cond
    ((null arg)
      nil)
    ((and (pairp arg) (pairp (qcar arg)) (eq (qcar (qcar arg)) '|Join|))
     (append (cdar arg) (fn (rest arg))))
    (t
     (cons (first arg) (fn (rest arg))))))
 )
 (cons '|Join| (fn (|parseTranList| thejoin)))))

@

\defplist{leave}{parseLeave}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|leave| '|parseTran|) '|parseLeave|))

@

\defun{parseLeave}{parseLeave}
\calls{parseLeave}{parseTran}
<<defun parseLeave>>=
(defun |parseLeave| (arg)
 (let (a b)
    (setq a (|parseTran| (car arg)))
    (setq b (|parseTran| (cdr arg)))
    (cond
     (b
      (cond
       ((null (integerp a))
        (moan "first arg " a " for 'leave' must be integer")
        (list '|leave| 1 a))
       (t (cons '|leave| (cons a b)))))
     (t (list '|leave| 1 a)))))

@

\defplist{$<=$}{parseLessEqual}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|<=| '|parseTran|) '|parseLessEqual|))

@

\defun{parseLessEqual}{parseLessEqual}
\calls{parseLessEqual}{parseTran}
\usesdollar{parseLessEqual}{op}
<<defun parseLessEqual>>=
(defun |parseLessEqual| (arg)
 (declare (special |$op|))
 (|parseTran| (list '|not| (cons (msubst '> '<= |$op|) arg))))

@

\defplist{let}{parseLET}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'let '|parseTran|) '|parseLET|))

@

\defun{parseLET}{parseLET}
\calls{parseLET}{parseTran}
\calls{parseLET}{parseTranCheckForRecord}
\calls{parseLET}{opOf}
\calls{parseLET}{transIs}
<<defun parseLET>>=
(defun |parseLET| (arg)
 (let (p)
  (setq p
   (list 'let (|parseTran| (first arg))
     (|parseTranCheckForRecord| (second arg) (|opOf| (first arg)))))
  (if (eq (|opOf| (first arg)) '|cons|)
    (list 'let (|transIs| (second p)) (third p))
    p)))

@

\defplist{letd}{parseLETD}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'letd '|parseTran|) '|parseLETD|))

@

\defun{parseLETD}{parseLETD}
\calls{parseLETD}{parseTran}
\calls{parseLETD}{parseType}
<<defun parseLETD>>=
(defun |parseLETD| (arg)
 (list 'letd
   (|parseTran| (first arg))
   (|parseTran| (|parseType| (second arg)))))

@

\defplist{mdef}{parseMDEF}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'mdef '|parseTran|) '|parseMDEF|))

@

\defun{parseMDEF}{parseMDEF}
\calls{parseMDEF}{parseTran}
\calls{parseMDEF}{parseTranList}
\calls{parseMDEF}{parseTranCheckForRecord}
\calls{parseMDEF}{opOf}
\usesdollar{parseMDEF}{lhs}
<<defun parseMDEF>>=
(defun |parseMDEF| (arg)
 (let (|$lhs|)
 (declare (special |$lhs|))
  (setq |$lhs| (first arg))
  (list 'mdef
    (|parseTran| |$lhs|)
    (|parseTranList| (second arg)) 
    (|parseTranList| (third arg)) 
    (|parseTranCheckForRecord| (fourth arg) (|opOf| |$lhs|)))))

@

\defplist{not}{parseNot}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|not| '|parseTran|) '|parseNot|))

@

\defplist{not}{parseNot}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|^| '|parseTran|) '|parseNot|))

@

\defun{parseNot}{parseNot}
\calls{parseNot}{parseTran}
\usesdollar{parseNot}{InteractiveMode}
<<defun parseNot>>=
(defun |parseNot| (arg)
 (declare (special |$InteractiveMode|))
 (if |$InteractiveMode|
  (list '|not| (|parseTran| (car arg)))
  (|parseTran| (cons 'if (cons (car arg) '(|false| |true|))))))

@

\defplist{notequal}{parseNotEqual}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|^=| '|parseTran|) '|parseNotEqual|))

@

\defun{parseNotEqual}{parseNotEqual}
\calls{parseNotEqual}{parseTran}
\calls{parseNotEqual}{msubst}
\usesdollar{parseNotEqual}{op}
<<defun parseNotEqual>>=
(defun |parseNotEqual| (arg)
 (declare (special |$op|))
 (|parseTran| (list '|not| (cons (msubst '= '^= |$op|) arg))))

@

\defplist{or}{parseOr}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|or| '|parseTran|) '|parseOr|))

@

\defun{parseOr}{parseOr}
\calls{parseOr}{parseTran}
\calls{parseOr}{parseTranList}
\calls{parseOr}{parseIf}
\calls{parseOr}{parseOr}
<<defun parseOr>>=
(defun |parseOr| (arg)
 (let (x)
  (setq x (|parseTran| (car arg)))
  (cond
   (|$InteractiveMode| (cons '|or| (|parseTranList| arg)))
   ((null arg) '|false|)
   ((null (cdr arg)) (car arg))
   ((and (pairp x) (eq (qcar x) '|not|)
         (pairp (qcdr x)) (eq (qcdr (qcdr x)) nil))
     (|parseIf| (list (second x) (|parseOr| (cdr arg)) '|true|)))
   (t
     (|parseIf| (list x '|true| (|parseOr| (cdr arg))))))))

@

\defplist{pretend}{parsePretend}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|pretend| '|parseTran|) '|parsePretend|))

@

\defun{parsePretend}{parsePretend}
\calls{parsePretend}{parseTran}
\calls{parsePretend}{parseType}
<<defun parsePretend>>=
(defun |parsePretend| (arg)
 (if |$InteractiveMode|
  (list '|pretend|
         (|parseTran| (first arg))
         (|parseTran| (|parseType| (second arg))))
  (list '|pretend|
          (|parseTran| (first arg))
          (|parseTran| (second arg)))))

@

\defplist{return}{parseReturn}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|return| '|parseTran|) '|parseReturn|))

@

\defun{parseReturn}{parseReturn}
\calls{parseReturn}{parseTran}
\calls{parseReturn}{moan}
<<defun parseReturn>>=
(defun |parseReturn| (arg)
 (let (a b)
  (setq a (|parseTran| (car arg)))
  (setq b (|parseTran| (cdr arg)))
  (cond
   (b 
    (when (nequal a 1) (moan "multiple-level 'return' not allowed"))
    (cons '|return| (cons 1 b)))
   (t (list '|return| 1 a)))))

@

\defplist{segment}{parseSegment}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'segment '|parseTran|) '|parseSegment|))

@

\defun{parseSegment}{parseSegment}
\calls{parseSegment}{parseTran}
<<defun parseSegment>>=
(defun |parseSegment| (arg)
  (if (and (pairp arg) (pairp (qcdr arg)) (eq (qcdr (qcdr arg)) nil))
   (if (second arg)
    (list 'segment (|parseTran| (first arg)) (|parseTran| (second arg)))
    (list 'segment (|parseTran| (first arg))))
   (cons 'segment arg)))

@

\defplist{segment}{parseSeq}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'seq '|parseTran|) '|parseSeq|))

@

\defun{parseSeq}{parseSeq}
\calls{parseSeq}{postError}
\calls{parseSeq}{transSeq}
\calls{parseSeq}{mapInto}
\calls{parseSeq}{last}
<<defun parseSeq>>=
(defun |parseSeq| (arg)
 (let (tmp1)
  (when (pairp arg) (setq tmp1 (reverse arg)))
  (if (null (and (pairp arg) (pairp tmp1)
                 (pairp (qcar tmp1)) (eq (qcar (qcar tmp1)) '|exit|)))
    (|postError| (list "   Invalid ending to block: " (|last| arg)))
    (|transSeq| (|mapInto| arg '|parseTran|)))))

@

\defplist{vcons}{parseVCONS}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'vcons '|parseTran|) '|parseVCONS|))

@

\defun{parseVCONS}{parseVCONS}
\calls{parseVCONS}{parseTranList}
<<defun parseVCONS>>=
(defun |parseVCONS| (arg)
 (cons 'vector (|parseTranList| arg)))

@

\defplist{where}{parseWhere}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|where| '|parseTran|) '|parseWhere|))

@

\defun{parseWhere}{parseWhere}
\calls{parseWhere}{mapInto}
<<defun parseWhere>>=
(defun |parseWhere| (arg)
  (cons '|where| (|mapInto| arg '|parseTran|)))

@

\chapter{Compile Transformers}
\section{Direct called comp routines}
\section{Indirect called comp routines}
In the {\bf compExpression} function there is the code:
\begin{verbatim}
  (if (and (atom (car x)) (setq fn (getl (car x) 'special)))
    (funcall fn x m e)
    (|compForm| x m e))))
\end{verbatim}

The functions in this section are called through the symbol-plist
of the symbol being parsed. The original list read:

\begin{verbatim}
          (|add|    |compAdd|)
;          (\@       |compAtSign|)
          (CAPSULE  |compCapsule|)
          (|case|   |compCase|)
          (|Mapping| |compCat|)
          (|Record| |compCat|)
          (|Union|  |compCat|)
          (CATEGORY |compCategory|)
          (\:\:     |compCoerce|)
          (COLLECTV |compCollectV|)
;          (\:       |compColon|)
          (CONS     |compCons|)
          (|ListCategory| |compConstructorCategory|)
          (|RecordCategory| |compConstructorCategory|)
          (|UnionCategory| |compConstructorCategory|)
          (|VectorCategory| |compConstructorCategory|)
          (|construct| |compConstruct|)
          (DEF      |compDefine|)
          (|elt|    |compElt|)
          (|exit|   |compExit|)
          (|has|    |compHas|)
          (IF       |compIf|)
          (|import| |compImport|)
          (|is|     |compIs|)
          (|Join|   |compJoin|)
          (|+->|    |compLambda|)
          (|leave|  |compLeave|)
          (MDEF     |compMacro|)
          (QUOTE    |compQuote|)
          (|pretend| |compPretend|)
          (REDUCE   |compReduce|)
          (COLLECT  |compRepeatOrCollect|)
          (REPEAT   |compRepeatOrCollect|)
          (|return| |compReturn|)
          (LET      |compSetq|)      
          (SETQ     |compSetq|)
;          (SEQ      |compSeq|)
          (|String| |compString|)
          (|SubDomain| |compSubDomain|)
          (|SubsetCategory| |compSubsetCategory|)
          (\|       |compSuchthat|)
;          (VECTOR   |compVector|)
;          (|where|  |compWhere|)
\end{verbatim}

\defplist{@}{compAtSign}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|add| 'special) '|compAdd|))

@

\defun{compAdd}{compAdd}
\calls{compAdd}{comp}
\calls{compAdd}{qcdr}
\calls{compAdd}{qcar}
\calls{compAdd}{compSubDomain1}
\calls{compAdd}{pairp}
\calls{compAdd}{nreverse0}
\calls{compAdd}{NRTgetLocalIndex}
\calls{compAdd}{compTuple2Record}
\calls{compAdd}{compOrCroak}
\calls{compAdd}{compCapsule}
\uses{compAdd}{/editfile}
\usesdollar{compAdd}{addForm}
\usesdollar{compAdd}{addFormLhs}
\usesdollar{compAdd}{EmptyMode}
\usesdollar{compAdd}{NRTaddForm}
\usesdollar{compAdd}{packagesUsed}
\usesdollar{compAdd}{functorForm}
\usesdollar{compAdd}{bootStrapMode}
<<defun compAdd>>=
(defun |compAdd| (arg m e)
 (let (|$addForm| |$addFormLhs| code domainForm predicate tmp3 tmp4)
 (declare (special |$addForm| |$addFormLhs| |$EmptyMode| |$NRTaddForm|
                   |$packagesUsed| |$functorForm| |$bootStrapMode| /editfile))
  (setq |$addForm| (second arg))
  (cond
   ((eq |$bootStrapMode| t)
    (cond
     ((and (pairp |$addForm|) (eq (qcar |$addForm|) '|@Tuple|))
       (setq code nil))
     (t
       (setq tmp3 (|comp| |$addForm| m e))
       (setq code (first tmp3))
       (setq m (second tmp3))
       (setq e (third tmp3)) tmp3))
    (list
      (list 'cond
        (list '|$bootStrapMode| code)
         (list 't
          (list '|systemError|
           (list 'list ''|%b| (mkq (car |$functorForm|)) ''|%d| "from"
                 ''|%b| (mkq (|namestring| /editfile)) ''|%d|
                 "needs to be compiled"))))
         m e))
   (t
    (setq |$addFormLhs| |$addForm|)
    (cond
     ((and (pairp |$addForm|) (eq (qcar |$addForm|) '|SubDomain|)
           (pairp (qcdr |$addForm|)) (pairp (qcdr (qcdr |$addForm|)))
           (eq (qcdr (qcdr (qcdr |$addForm|))) nil))
       (setq domainForm (second |$addForm|))
       (setq predicate (third |$addForm|))
       (setq |$packagesUsed| (cons domainForm |$packagesUsed|))
       (setq |$NRTaddForm| domainForm)
       (|NRTgetLocalIndex| domainForm)
       ; need to generate slot for add form since all $ go-get
       ; slots will need to access it
       (setq tmp3 (|compSubDomain1| domainForm predicate m e))
       (setq |$addForm| (first tmp3))
       (setq e (third tmp3)) tmp3)
     (t
      (setq |$packagesUsed|
       (if (and (pairp |$addForm|) (eq (qcar |$addForm|) '|@Tuple|))
         (append (qcdr |$addForm|) |$packagesUsed|)
         (cons |$addForm| |$packagesUsed|)))
      (setq |$NRTaddForm| |$addForm|)
      (setq tmp3
       (cond
        ((and (pairp |$addForm|) (eq (qcar |$addForm|) '|@Tuple|))
         (setq |$NRTaddForm|
          (cons '|@Tuple|
           (dolist (x (cdr |$addForm|) (nreverse0 tmp4))
            (push (|NRTgetLocalIndex| x) tmp4))))
         (|compOrCroak| (|compTuple2Record| |$addForm|) |$EmptyMode| e))
        (t 
        (|compOrCroak| |$addForm| |$EmptyMode| e))))
      (setq |$addForm| (first tmp3))
      (setq e (third tmp3))
      tmp3))
    (|compCapsule| (third arg) m e)))))

@

\defplist{@}{compAtSign}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|@| 'special) '|compAtSign|))

@

\defun{compAtSign}{compAtSign}
\calls{compAtSign}{addDomain}
\calls{compAtSign}{comp}
\calls{compAtSign}{coerce}
<<defun compAtSign>>=
(defun |compAtSign| (arg1 m e)
  (let ((x (second arg1)) (mprime (third arg1)) tmp)
   (setq e (|addDomain| mprime e))
   (when (setq tmp (|comp| x mprime e)) (|coerce| tmp m))))

@

\defplist{capsule}{compCapsule}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'capsule 'special) '|compCapsule|))

@

\defun{compCapsule}{compCapsule}
\calls{compCapsule}{bootStrapError}
\calls{compCapsule}{compCapsuleInner}
\calls{compCapsule}{addDomain}
\uses{compCapsule}{editfile}
\usesdollar{compCapsule}{insideExpressionIfTrue}
\usesdollar{compCapsule}{functorForm}
\usesdollar{compCapsule}{bootStrapMode}
<<defun compCapsule>>=
(defun |compCapsule| (arg m e)
 (let (|$insideExpressionIfTrue| itemList)
 (declare (special |$insideExpressionIfTrue| |$functorForm| /editfile
                   |$bootStrapMode|))
  (setq itemList (cdr arg))
  (cond
   ((eq |$bootStrapMode| t)
     (list (|bootStrapError| |$functorForm| /editfile) m e))
   (t
    (setq |$insideExpressionIfTrue| nil)
    (|compCapsuleInner| itemList m (|addDomain| '$ e))))))

@

\defun{compCapsuleInner}{compCapsuleInner}
\calls{compCapsuleInner}{addInformation}
\calls{compCapsuleInner}{compCapsuleItems}
\calls{compCapsuleInner}{processFunctorOrPackage}
\calls{compCapsuleInner}{mkpf}
\usesdollar{compCapsuleInner}{getDomainCode}
\usesdollar{compCapsuleInner}{signature}
\usesdollar{compCapsuleInner}{form}
\usesdollar{compCapsuleInner}{addForm}
\usesdollar{compCapsuleInner}{insideCategoryPackageIfTrue}
\usesdollar{compCapsuleInner}{insideCategoryIfTrue}
\usesdollar{compCapsuleInner}{functorLocalParameters}
<<defun compCapsuleInner>>=
(defun |compCapsuleInner| (itemList m e)
 (let (localParList data code)
 (declare (special |$getDomainCode| |$signature| |$form| |$addForm|
                   |$insideCategoryPackageIfTrue| |$insideCategoryIfTrue|
                   |$functorLocalParameters|))
  (setq e (|addInformation| m e))
  (setq data (cons 'progn itemList))
  (setq e (|compCapsuleItems| itemList nil e))
  (setq localParList |$functorLocalParameters|)
  (when |$addForm| (setq data (list '|add| |$addForm| data)))
  (setq code
   (if (and |$insideCategoryIfTrue| (null |$insideCategoryPackageIfTrue|))
    data
    (|processFunctorOrPackage| |$form| |$signature| data localParList m e)))
  (cons (mkpf (append |$getDomainCode| (list code)) 'progn) (list m e))))

@

\defplist{case}{compCase}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|case| 'special) '|compCase|))

@

\defun{compCase}{compCase}
Will the jerk who commented out these two functions please NOT do so
again.  These functions ARE needed, and case can NOT be done by
modemap alone.  The reason is that A case B requires to take A
evaluated, but B unevaluated.  Therefore a special function is
required.  You may have thought that you had tested this on ``failed''
etc., but ``failed'' evaluates to it's own mode.  Try it on x case \$
next time.

An angry JHD - August 15th., 1984
\calls{compCase}{addDomain}
\calls{compCase}{compCase1}
\calls{compCase}{coerce}
<<defun compCase>>=
(defun |compCase| (arg m e)
 (let (mp td)
  (setq mp (third arg))
  (setq e (|addDomain| mp e))
  (when (setq td (|compCase1| (second arg) mp e)) (|coerce| td m))))

@

\defun{compCase1}{compCase1}
\calls{compCase1}{comp}
\calls{compCase1}{getModemapList}
\calls{compCase1}{nreverse0}
\calls{compCase1}{modeEqual}
\usesdollar{compCase1}{Boolean}
\usesdollar{compCase1}{EmptyMode}
<<defun compCase1>>=
(defun |compCase1| (x m e)
 (let (xp mp ep map tmp3 tmp5 tmp6 u fn)
 (declare (special |$Boolean| |$EmptyMode|))
  (when (setq tmp3 (|comp| x |$EmptyMode| e))
   (setq xp (first tmp3))
   (setq mp (second tmp3))
   (setq ep (third tmp3))
   (when 
    (setq u
     (dolist (modemap (|getModemapList| '|case| 2 ep) (nreverse0 tmp5))
        (setq map (first modemap))
        (when
          (and (pairp map) (pairp (qcdr map)) (pairp (qcdr (qcdr map)))
                (pairp (qcdr (qcdr (qcdr map))))
                (eq (qcdr (qcdr (qcdr (qcdr map)))) nil)
                (|modeEqual| (fourth map) m)
                (|modeEqual| (third map) mp))
            (push (second modemap) tmp5))))
    (when
     (setq fn
      (dolist (onepair u tmp6)
        (when (first onepair) (setq tmp6 (or tmp6 (second onepair))))))
      (list (list '|call| fn xp) |$Boolean| ep))))))

@

\defplist{Record}{compCat}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|Record| 'special) '|compCat|))

@

\defplist{Mapping}{compCat}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|Mapping| 'special) '|compCat|))

@

\defplist{Union}{compCat}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|Union| 'special) '|compCat|))

@

\defun{compCat}{compCat}
\calls{compCat}{getl}
<<defun compCat>>=
(defun |compCat| (form m e)
 (declare (ignore m))
 (let (functorName fn tmp1 tmp2 funList op sig catForm)
  (setq functorName (first form))
  (when (setq fn (getl functorName '|makeFunctionList|))
   (setq tmp1 (funcall fn form form e))
   (setq funList (first tmp1))
   (setq e (second tmp1))
   (setq catForm
    (list '|Join| '(|SetCategory|)
     (cons 'category
      (cons '|domain|
       (dolist (item funList (nreverse0 tmp2))
        (setq op (first item))
        (setq sig (second item))
        (unless (eq op '=) (push (list 'signature op sig) tmp2)))))))
   (list form catForm e))))

@

\defplist{category}{compCategory}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'category 'special) '|compCategory|))

@

\defun{compCategory}{compCategory}
\calls{compCategory}{resolve}
\calls{compCategory}{qcar}
\calls{compCategory}{qcdr}
\calls{compCategory}{compCategoryItem}
\calls{compCategory}{mkExplicitCategoryFunction}
\calls{compCategory}{systemErrorHere}
<<defun compCategory>>=
(defun |compCategory| (x m e)
 (let ($top_level |$sigList| |$atList| domainOrPackage z rep)
 (declare (special $top_level |$sigList| |$atList|))
  (setq $top_level t)
  (cond
   ((and 
      (equal (setq m (|resolve| m (list '|Category|))) (list '|Category|))
      (pairp x)
      (eq (qcar x) 'category)
      (pairp (qcdr x)))
    (setq domainOrPackage (second x))
    (setq z (qcdr (qcdr x)))
    (setq |$sigList| nil)
    (setq |$atList| nil)
    (setq |$sigList| nil) 
    (setq |$atList| nil)
    (dolist (x z) (|compCategoryItem| x nil))
    (setq rep
      (|mkExplicitCategoryFunction| domainOrPackage |$sigList| |$atList|))
    (list rep m e))
   (t
    (|systemErrorHere| "compCategory")))))

@

\defplist{::}{compCoerce}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|::| 'special) '|compCoerce|))

@

\defun{compCoerce}{compCoerce}
\calls{compCoerce}{addDomain}
\calls{compCoerce}{getmode}
\calls{compCoerce}{compCoerce1}
\calls{compCoerce}{coerce}
<<defun compCoerce>>=
(defun |compCoerce| (arg m e)
 (let (x mp tmp1 tmp4 z td)
  (setq x (second arg))
  (setq mp (third arg))
  (setq e (|addDomain| mp e))
  (setq tmp1 (|getmode| mp e))
  (cond
   ((setq td (|compCoerce1| x mp e))
    (|coerce| td m))
   ((and (pairp tmp1) (eq (qcar tmp1) '|Mapping|)
         (pairp (qcdr tmp1)) (eq (qcdr (qcdr tmp1)) nil)
         (pairp (qcar (qcdr tmp1)))
         (eq (qcar (qcar (qcdr tmp1))) '|UnionCategory|))
    (setq z (qcdr (qcar (qcdr tmp1))))
    (when
     (setq td
      (dolist (m1 z tmp4) (setq tmp4 (or tmp4 (|compCoerce1| x m1 e)))))
     (|coerce| (list (car td) mp (third td)) m))))))

@

\defun{compCoerce1}{compCoerce1}
\calls{compCoerce1}{comp}
\calls{compCoerce1}{resolve}
\calls{compCoerce1}{coerce}
\calls{compCoerce1}{coerceByModemap}
\calls{compCoerce1}{msubst}
\calls{compCoerce1}{mkq}
<<defun compCoerce1>>=
(defun |compCoerce1| (x mp e)
 (let (m1 td tp gg pred code)
 (declare (special |$String| |$EmptyMode|))
  (when (setq td (or (|comp| x mp e) (|comp| x |$EmptyMode| e)))
    (setq m1 (if (stringp (second td)) |$String| (second td)))
    (setq mp (|resolve| m1 mp))
    (setq td (list (car td) m1 (third td)))
    (cond
     ((setq tp (|coerce| td mp)) tp)
     ((setq tp (|coerceByModemap| td mp)) tp)
     ((setq pred (|isSubset| mp (second td) e))
       (setq gg (gensym))
       (setq pred (msubst gg '* pred))
       (setq code
        (list 'prog1
         (list 'let gg (first td))
          (cons '|check-subtype| (cons pred (list (mkq mp) gg)))))
       (list code mp (third td)))))))

@

\defplist{:}{compColon}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|:| 'special) '|compColon|))

@

\defun{compColon}{compColon}
\begin{verbatim}
;compColon([":",f,t],m,e) ==
;  $insideExpressionIfTrue=true => compColonInside(f,m,e,t)
;    --if inside an expression, ":" means to convert to m "on faith"
;  $lhsOfColon: local:= f
;  t:=
;    atom t and (t':= ASSOC(t,getDomainsInScope e)) => t'
;    isDomainForm(t,e) and not $insideCategoryIfTrue =>
;      (if not MEMBER(t,getDomainsInScope e) then e:= addDomain(t,e); t)
;    isDomainForm(t,e) or isCategoryForm(t,e) => t
;    t is ["Mapping",m',:r] => t
;    unknownTypeError t
;    t
;  f is ["LISTOF",:l] =>
;    (for x in l repeat T:= [.,.,e]:= compColon([":",x,t],m,e); T)
;  e:=
;    f is [op,:argl] and not (t is ["Mapping",:.]) =>
;      --for MPOLY--replace parameters by formal arguments: RDJ 3/83
;      newTarget:= EQSUBSTLIST(take(#argl,$FormalMapVariableList),
;        [(x is [":",a,m] => a; x) for x in argl],t)
;      signature:=
;        ["Mapping",newTarget,:
;          [(x is [":",a,m] => m;
;              getmode(x,e) or systemErrorHere '"compColonOld") for x in argl]]
;      put(op,"mode",signature,e)
;    put(f,"mode",t,e)
;  if not $bootStrapMode and $insideFunctorIfTrue and
;    makeCategoryForm(t,e) is [catform,e] then
;        e:= put(f,"value",[genSomeVariable(),t,$noEnv],e)
;  ["/throwAway",getmode(f,e),e]
\end{verbatim}
\calls{compColon}{compColonInside}
\calls{compColon}{assoc}
\calls{compColon}{getDomainsInScope}
\calls{compColon}{isDomainForm}
\calls{compColon}{member}
\calls{compColon}{addDomain}
\calls{compColon}{isDomainForm}
\calls{compColon}{isCategoryForm}
\calls{compColon}{unknownTypeError}
\calls{compColon}{compColon}
\calls{compColon}{eqsubstlist}
\calls{compColon}{take}
\calls{compColon}{length}
\calls{compColon}{nreverse0}
\calls{compColon}{getmode}
\calls{compColon}{systemErrorHere}
\calls{compColon}{put}
\calls{compColon}{makeCategoryForm}
\calls{compColon}{genSomeVariable}
\usesdollar{compColon}{lhsOfColon}
\usesdollar{compColon}{noEnv}
\usesdollar{compColon}{insideFunctorIfTrue}
\usesdollar{compColon}{bootStrapMode}
\usesdollar{compColon}{FormalMapVariableList}
\usesdollar{compColon}{insideCategoryIfTrue}
\usesdollar{compColon}{insideExpressionIfTrue}
<<defun compColon>>=
(defun |compColon| (arg0 m e)
  (let (|$lhsOfColon| argf argt tprime mprime r td op argl newTarget a 
        signature tmp2 catform tmp3 g2 g5)
  (declare (special |$lhsOfColon| |$noEnv| |$insideFunctorIfTrue|
                    |$bootStrapMode| |$FormalMapVariableList|
                    |$insideCategoryIfTrue| |$insideExpressionIfTrue|))
    (setq argf (second arg0))
    (setq argt (third arg0))
    (if |$insideExpressionIfTrue|
      (|compColonInside| argf m e argt)
      (progn
        (setq |$lhsOfColon| argf)
        (setq argt
         (cond
          ((and (atom argt)
                (setq tprime (|assoc| argt (|getDomainsInScope| e))))
            tprime)
          ((and (|isDomainForm| argt e) (null |$insideCategoryIfTrue|))
            (unless (|member| argt (|getDomainsInScope| e))
               (setq e (|addDomain| argt e)))
            argt)
          ((or (|isDomainForm| argt e) (|isCategoryForm| argt e))
            argt)
          ((and (pairp argt) (eq (qcar argt) '|Mapping|)
                (progn
                  (setq tmp2 (qcdr argt))
                  (and (pairp tmp2)
                       (progn
                        (setq mprime (qcar tmp2))
                        (setq r (qcdr tmp2))
                        t))))
            argt)
          (t
            (|unknownTypeError| argt)
            argt)))
        (cond
         ((eq (car argf) 'listof)
           (dolist (x (cdr argf) td)
             (setq td (|compColon| (list '|:| x argt) m e))
             (setq e (third td))))
         (t
          (setq e
           (cond
            ((and (pairp argf)
                  (progn
                   (setq op (qcar argf))
                   (setq argl (qcdr argf))
                   t)
                  (null (and (pairp argt) (eq (qcar argt) '|Mapping|))))
             (setq newTarget
              (eqsubstlist (take (|#| argl) |$FormalMapVariableList|)
              (dolist (x argl (nreverse0 g2))
                (setq g2
                 (cons
                  (cond
                   ((and (pairp x) (eq (qcar x) '|:|)
                         (progn
                          (setq tmp2 (qcdr x))
                          (and (pairp tmp2)
                               (progn
                                (setq a (qcar tmp2))
                                (setq tmp3 (qcdr tmp2))
                                (and (pairp tmp3)
                                     (eq (qcdr tmp3) nil)
                                     (progn
                                      (setq m (qcar tmp3))
                                      t))))))
                       a)
                      (t x))
               g2)))
              argt))
             (setq signature
              (cons '|Mapping|
               (cons newTarget
                (dolist (x argl (nreverse0 g5))
                  (setq g5
                   (cons
                    (cond
                     ((and (pairp x) (eq (qcar x) '|:|)
                      (progn
                       (setq tmp2 (qcdr x))
                       (and (pairp tmp2)
                            (progn
                             (setq a (qcar tmp2))
                             (setq tmp3 (qcdr tmp2))
                             (and (pairp tmp3)
                                  (eq (qcdr tmp3) nil)
                                  (progn
                                   (setq m (qcar tmp3))
                                   t))))))
                       m)
                     (t
                      (or (|getmode| x e)
                          (|systemErrorHere| "compColonOld"))))
                     g5))))))
             (|put| op '|mode| signature e))
            (t (|put| argf '|mode| argt e))))
         (cond
           ((and (null |$bootStrapMode|) |$insideFunctorIfTrue|
                 (progn
                  (setq tmp2 (|makeCategoryForm| argt e))
                  (and (pairp tmp2)
                       (progn
                        (setq catform (qcar tmp2))
                        (setq tmp3 (qcdr tmp2))
                        (and (pairp tmp3)
                             (eq (qcdr tmp3) nil)
                             (progn
                               (setq e (qcar tmp3))
                                       t))))))
            (setq e 
             (|put| argf '|value| (list (|genSomeVariable|) argt |$noEnv|)
              e))))
         (list '|/throwAway| (|getmode| argf e) e )))))))

@

\defplist{cons}{compCons}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'cons 'special) '|compCons|))

@

\defun{compCons}{compCons}
\calls{compCons}{compCons1}
\calls{compCons}{compForm}
<<defun compCons>>=
(defun |compCons| (form m e)
  (or (|compCons1| form m e) (|compForm| form m e)))

@

\defun{compCons1}{compCons1}
\calls{compCons1}{comp}
\calls{compCons1}{convert}
\calls{compCons1}{pairp}
\calls{compCons1}{qcar}
\calls{compCons1}{qcdr}
\usesdollar{compCons1}{EmptyMode}
<<defun compCons1>>=
(defun |compCons1| (arg m e)
 (let (mx y my yt mp mr ytp tmp1 x td)
 (declare (special |$EmptyMode|))
  (setq x (second arg))
  (setq y (third arg))
  (when (setq tmp1 (|comp| x |$EmptyMode| e))
   (setq x (first tmp1))
   (setq mx (second tmp1))
   (setq e (third tmp1))
   (cond
    ((null y)
     (|convert| (list (list 'list x) (list '|List| mx) e ) m))
    (t
     (when (setq yt (|comp| y |$EmptyMode| e))
      (setq y (first yt))
      (setq my (second yt))
      (setq e (third yt))
      (setq td
       (cond
        ((and (pairp my) (eq (qcar my) '|List|) (pairp (qcdr my)))
          (setq mp (second my))
          (when (setq mr (list '|List| (|resolve| mp mx)))
           (when (setq ytp (|convert| yt mr))
            (when (setq tmp1 (|convert| (list x mx (third ytp)) (second mr)))
             (setq x (first tmp1))
             (setq e (third tmp1))
             (cond
              ((and (pairp (car ytp)) (eq (qcar (car ytp)) 'list))
               (list (cons 'list (cons x (cdr (car ytp)))) mr e))
              (t
               (list (list 'cons x (car ytp)) mr e)))))))
        (t
         (list (list 'cons x y) (list '|Pair| mx my) e ))))
      (|convert| td m)))))))

@

\defplist{ListCategory}{compConstructorCategory}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|ListCategory| 'special) '|compConstructorCategory|))

@

\defplist{RecordCategory}{compConstructorCategory}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|RecordCategory| 'special) '|compConstructorCategory|))

@

\defplist{UnionCategory}{compConstructorCategory}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|UnionCategory| 'special) '|compConstructorCategory|))

@

\defplist{VectorCategory}{compConstructorCategory}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|VectorCategory| 'special) '|compConstructorCategory|))

@

\defun{compConstructorCategory}{compConstructorCategory}
\calls{compConstructorCategory}{resolve}
\usesdollar{compConstructorCategory}{Category}
<<defun compConstructorCategory>>=
(defun |compConstructorCategory| (x m e)
 (declare (special |$Category|))
 (list x (|resolve| |$Category| m) e))

@

\defplist{construct}{compConstruct}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|construct| 'special) '|compConstruct|))

@

\defun{compConstruct}{compConstruct}
\calls{compConstruct}{modeIsAggregateOf}
\calls{compConstruct}{compList}
\calls{compConstruct}{convert}
\calls{compConstruct}{compForm}
\calls{compConstruct}{compVector}
\calls{compConstruct}{getDomainsInScope}
<<defun compConstruct>>=
(defun |compConstruct| (form m e)
 (let (z y td tp)
  (setq z (cdr form))
  (cond
   ((setq y (|modeIsAggregateOf| '|List| m e))
    (if (setq td (|compList| z (list '|List| (cadr y)) e))
      (|convert| td m)
      (|compForm| form m e)))
   ((setq y (|modeIsAggregateOf| '|Vector| m e))
    (if (setq td (|compVector| z (list '|Vector| (cadr y)) e))
      (|convert| td m)
      (|compForm| form m e)))
   ((setq td (|compForm| form m e)) td)
   (t
    (dolist (d (|getDomainsInScope| e))
     (cond
      ((and (setq y (|modeIsAggregateOf| '|List| D e))
            (setq td (|compList| z (list '|List| (cadr y)) e))
            (setq tp (|convert| td m)))
       (return tp))
      ((and (setq y (|modeIsAggregateOf| '|Vector| D e))
            (setq td (|compVector| z (list '|Vector| (cadr y)) e))
            (setq tp (|convert| td m)))
        (return tp))))))))

@

\defplist{def}{compDefine}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'def 'special) '|compDefine|))

@

\defun{compDefine}{compDefine}
\calls{compDefine}{compDefine1}
\usesdollar{compDefine}{tripleCache}
\usesdollar{compDefine}{tripleHits}
\usesdollar{compDefine}{macroIfTrue}
\usesdollar{compDefine}{packagesUsed}
<<defun compDefine>>=
(defun |compDefine| (form m e)
 (let (|$tripleCache| |$tripleHits| |$macroIfTrue| |$packagesUsed|)
 (declare (special |$tripleCache| |$tripleHits| |$macroIfTrue|
                    |$packagesUsed|))
  (setq |$tripleCache| nil)
  (setq |$tripleHits| 0)
  (setq |$macroIfTrue| nil)
  (setq |$packagesUsed| nil)
  (|compDefine1| form m e)))

@

\defun{compDefine1}{compDefine1}
\calls{compDefine1}{macroExpand}
\calls{compDefine1}{isMacro}
\calls{compDefine1}{getSignatureFromMode}
\calls{compDefine1}{compDefine1}
\calls{compDefine1}{compInternalFunction}
\calls{compDefine1}{compDefineAddSignature}
\calls{compDefine1}{compDefWhereClause}
\calls{compDefine1}{compDefineCategory}
\calls{compDefine1}{isDomainForm}
\calls{compDefine1}{getTargetFromRhs}
\calls{compDefine1}{giveFormalParametersValues}
\calls{compDefine1}{addEmptyCapsuleIfNecessary}
\calls{compDefine1}{compDefineFunctor}
\calls{compDefine1}{stackAndThrow}
\calls{compDefine1}{strconc}
\calls{compDefine1}{getAbbreviation}
\calls{compDefine1}{length}
\calls{compDefine1}{compDefineCapsuleFunction}
\usesdollar{compDefine1}{insideExpressionIfTrue}
\usesdollar{compDefine1}{formalArgList}
\usesdollar{compDefine1}{form}
\usesdollar{compDefine1}{op}
\usesdollar{compDefine1}{prefix}
\usesdollar{compDefine1}{insideFunctorIfTrue}
\usesdollar{compDefine1}{Category}
\usesdollar{compDefine1}{insideCategoryIfTrue}
\usesdollar{compDefine1}{insideCapsuleFunctionIfTrue}
\usesdollar{compDefine1}{ConstructorNames}
\usesdollar{compDefine1}{NoValueMode}
\usesdollar{compDefine1}{EmptyMode}
\usesdollar{compDefine1}{insideWhereIfTrue}
\usesdollar{compDefine1}{insideExpressionIfTrue}
<<defun compDefine1>>=
(defun |compDefine1| (form m e)
 (let (|$insideExpressionIfTrue| lhs specialCases sig signature rhs newPrefix
       (tmp1 t))
 (declare (special |$insideExpressionIfTrue| |$formalArgList| |$form| 
                   |$op| |$prefix| |$insideFunctorIfTrue| |$Category|
                   |$insideCategoryIfTrue| |$insideCapsuleFunctionIfTrue|
                   |$ConstructorNames| |$NoValueMode| |$EmptyMode|
                   |$insideWhereIfTrue| |$insideExpressionIfTrue|))
  (setq |$insideExpressionIfTrue| nil)
  (setq form (|macroExpand| form e))
  (setq lhs (second form))
  (setq signature (third form))
  (setq specialCases (fourth form))
  (setq rhs (fifth form))
  (cond
   ((and |$insideWhereIfTrue| 
         (|isMacro| form e)
         (or (equal m |$EmptyMode|) (equal m |$NoValueMode|)))
     (list lhs m (|put| (car lhs) '|macro| rhs e)))
   ((and (null (car signature)) (consp rhs)
         (null (member (qcar rhs) |$ConstructorNames|))
         (setq sig (|getSignatureFromMode| lhs e)))
    (|compDefine1|
      (list 'def lhs (cons (car sig) (cdr signature)) specialCases rhs) m e))
   (|$insideCapsuleFunctionIfTrue| (|compInternalFunction| form m e))
   (t
    (when (equal (car signature) |$Category|) (setq |$insideCategoryIfTrue| t))
    (setq e (|compDefineAddSignature| lhs signature e))
    (cond
     ((null (dolist (x (rest signature) tmp1) (setq tmp1 (and tmp1 (null x)))))
      (|compDefWhereClause| form m e))
     ((equal (car signature) |$Category|)
      (|compDefineCategory| form m e nil |$formalArgList|))
     ((and (|isDomainForm| rhs e) (null |$insideFunctorIfTrue|))
      (when (null (car signature))
        (setq signature
         (cons (|getTargetFromRhs| lhs rhs
                 (|giveFormalParametersValues| (cdr lhs) e))
               (cdr signature))))
      (setq rhs (|addEmptyCapsuleIfNecessary| (car signature) rhs))
      (|compDefineFunctor|
        (list 'def lhs signature specialCases rhs) m e NIL |$formalArgList|))
     ((null |$form|)
      (|stackAndThrow| (list "bad == form " form)))
     (t
      (setq newPrefix
       (if |$prefix|
         (intern (strconc (|encodeItem| |$prefix|) "," (|encodeItem| |$op|)))
         (|getAbbreviation| |$op| (|#| (cdr |$form|)))))
      (|compDefineCapsuleFunction| form m e newPrefix |$formalArgList|)))))))

@

\defplist{elt}{compElt}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|elt| 'special) '|compElt|))

@

\defun{compElt}{compElt}
\calls{compElt}{compForm}
\calls{compElt}{isDomainForm}
\calls{compElt}{addDomain}
\calls{compElt}{getModemapListFromDomain}
\calls{compElt}{length}
\calls{compElt}{stackMessage}
\calls{compElt}{stackWarning}
\calls{compElt}{convert}
\calls{compElt}{opOf}
\calls{compElt}{getDeltaEntry}
\calls{compElt}{nequal}
\usesdollar{compElt}{One}
\usesdollar{compElt}{Zero}
<<defun compElt>>=
(defun |compElt| (form m e)
 (let (aDomain anOp mmList n modemap sig pred val)
 (declare (special |$One| |$Zero|))
 (setq anOp (third form))
 (setq aDomain (second form))
 (cond
  ((null (and (pairp form) (eq (qcar form) '|elt|)
              (pairp (qcdr form)) (pairp (qcdr (qcdr form)))
              (eq (qcdr (qcdr (qcdr form))) nil)))
   (|compForm| form m e))
  ((eq aDomain '|Lisp|)
   (list (cond
          ((equal anOp |$Zero|) 0)
          ((equal anOp |$One|) 1)
          (t anOp))
      m e))
  ((|isDomainForm| aDomain e)
   (setq e (|addDomain| aDomain e))
   (setq mmList (|getModemapListFromDomain| anOp 0 aDomain e))
   (setq modemap
    (progn
     (setq n (|#| mmList))
     (cond
      ((eql 1 n) (elt mmList 0))
      ((eql 0 n)
        (|stackMessage|
          (list "Operation " '|%b| anOp '|%d| "missing from domain: " 
                aDomain nil))
        nil)
      (t
       (|stackWarning|
        (list "more than 1 modemap for: " anOp " with dc=" 
               aDomain " ===>" mmList ))
        (elt mmList 0)))))
   (when modemap
    (setq sig (first modemap))
    (setq pred (caadr modemap))
    (setq val (cadadr modemap))
    (unless (and (nequal (|#| sig) 2)
                 (null (and (pairp val) (eq (qcar val) '|elt|))))
       (setq val (|genDeltaEntry| (cons (|opOf| anOp) modemap)))
       (|convert| (list (list '|call| val) (second sig) e) m))))
  (t
    (|compForm| form m e)))))

@

\defplist{exit}{compExit}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|exit| 'special) '|compExit|))

@

\defun{compExit}{compExit}
\calls{compExit}{comp}
\calls{compExit}{modifyModeStack}
\calls{compExit}{stackMessageIfNone}
\usesdollar{compExit}{exitModeStack}
<<defun compExit>>=
(defun |compExit| (arg0 m e)
 (let (x index m1 u)
 (declare (special |$exitModeStack|))
  (setq index (1- (second arg0)))
  (setq x (third arg0))
  (cond
   ((null |$exitModeStack|)
    (|comp| x m e))
   (t
    (setq m1 (elt |$exitModeStack| index))
    (setq u (|comp| x m1 e))
    (cond
     (u
      (|modifyModeStack| (second u) index)
      (list (list '|TAGGEDexit| index u) m e))
     (t
       (|stackMessageIfNone|
        (list '|cannot compile exit expression| x '|in mode| m1))))))))

@

\defplist{has}{compHas}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|has| 'special) '|compHas|))

@

\defun{compHas}{compHas}
\calls{compHas}{chaseInferences}
\calls{compHas}{compHasFormat}
\calls{compHas}{coerce}
\usesdollar{compHas}{e}
<<defun compHas>>=
(defun |compHas| (pred m |$e|)
 (declare (special |$e|))
 (let (a b predCode)
  (setq a (second pred))
  (setq b (third pred))
  (setq |$e| (|chaseInferences| pred |$e|))
  (setq predCode (|compHasFormat| pred))
  (|coerce| (list predCode |$Boolean| |$e|) m)))

@

\defplist{if}{compIf}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'if 'special) '|compIf|))

@

\defun{compIf}{compIf}
\calls{compIf}{canReturn}
\calls{compIf}{intersectionEnvironment}
\calls{compIf}{compBoolean}
\calls{compIf}{compFromIf}
\calls{compIf}{resolve}
\calls{compIf}{coerce}
\calls{compIf}{quotify}
\usesdollar{compIf}{Boolean}
<<defun compIf>>=
(defun |compIf| (arg m e)
 (labels (
  (env (bEnv cEnv b c e)
   (cond
    ((|canReturn| b 0 0 t)
     (if (|canReturn| c 0 0 t) (|intersectionEnvironment| bEnv cEnv) bEnv))
    ((|canReturn| c 0 0 t) cEnv)
    (t e))))
  (let (a b c tmp1 xa ma Ea Einv Tb xb mb Eb Tc xc mc Ec xbp x returnEnv)
  (declare (special |$Boolean|))
   (setq a (second arg))
   (setq b (third arg))
   (setq c (fourth arg))
   (when  (setq tmp1 (|compBoolean| a |$Boolean| e))
    (setq xa (first tmp1))
    (setq ma (second tmp1))
    (setq Ea (third tmp1))
    (setq Einv (fourth tmp1))
    (when (setq Tb (|compFromIf| b m Ea))
     (setq xb (first Tb))
     (setq mb (second Tb))
     (setq Eb (third Tb))
     (when (setq Tc (|compFromIf| c (|resolve| mb m) Einv))
      (setq xc (first Tc))
      (setq mc (second Tc))
      (setq Ec (third Tc))
      (when (setq xbp (|coerce| Tb mc))
       (setq x (list 'if xa (|quotify| (first xbp)) (|quotify| xc)))
       (setq returnEnv (env (third xbp) Ec (first xbp) xc e))
       (list x mc returnEnv))))))))

@

\defplist{import}{compImport}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|import| 'special) '|compImport|))

@

\defun{compImport}{compImport}
\calls{compImport}{addDomain}
\usesdollar{compImport}{NoValueMode}
<<defun compImport>>=
(defun |compImport| (arg m e)
 (declare (ignore m))
 (declare (special |$NoValueMode|))
  (dolist (dom (cdr arg)) (setq e (|addDomain| dom e)))
  (list '|/throwAway| |$NoValueMode| e))

@

\defplist{is}{compIs}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|is| 'special) '|compIs|))

@

\defun{compIs}{compIs}
\calls{compIs}{comp}
\calls{compIs}{coerce}
\usesdollar{compIs}{Boolean}
\usesdollar{compIs}{EmptyMode}
<<defun compIs>>=
(defun |compIs| (arg m e)
 (let (a b aval am tmp1 bval bm td)
 (declare (special |$Boolean| |$EmptyMode|))
  (setq a (CADR arg))
  (setq b (CADDR arg))
  (when (setq tmp1 (|comp| a |$EmptyMode| e))
   (setq aval (CAR tmp1))
   (setq am (CADR tmp1))
   (setq e (CADDR tmp1))
   (when (setq tmp1 (|comp| b |$EmptyMode| e))
    (setq bval (CAR tmp1))
    (setq bm (CADR tmp1))
    (setq e (CADDR tmp1))
    (setq td (list (list '|domainEqual| aval bval) |$Boolean| e ))
    (|coerce| td m)))))

@

\defplist{Join}{compJoin}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|Join| 'special) '|compJoin|))

@

\defun{compJoin}{compJoin}
\calls{compJoin}{nreverse0}
\calls{compJoin}{compForMode}
\calls{compJoin}{stackSemanticError}
\calls{compJoin}{nreverse0}
\calls{compJoin}{isCategoryForm}
\calls{compJoin}{union}
\calls{compJoin}{compJoin,getParms}
\calls{compJoin}{pairp}
\calls{compJoin}{qcar}
\calls{compJoin}{qcdr}
\calls{compJoin}{wrapDomainSub}
\calls{compJoin}{convert}
\usesdollar{compJoin}{Category}
<<defun compJoin>>=
(defun |compJoin| (arg m e)
 (labels (
  (getParms (y e)
   (cond
    ((atom y)
     (when (|isDomainForm| y e) (list y)))
    ((and (pairp y) (eq (qcar y) 'length)
          (pairp (qcdr y)) (eq (qcdr (qcdr y)) nil))
     (list y (second y)))
    (t (list y)))) )
 (let (argl catList pl tmp3 tmp4 tmp5 body parameters catListp td)
 (declare (special |$Category|))
  (setq argl (cdr arg))
  (setq catList
   (dolist (x argl (nreverse0 tmp3))
    (push (car (or (|compForMode| x |$Category| e) (return '|failed|)))
       tmp3)))
  (cond
   ((eq catList '|failed|)
    (|stackSemanticError| (list '|cannot form Join of: | argl) nil))
   (t
    (setq catListp
     (dolist (x catList (nreverse0 tmp4))
       (setq tmp4
        (cons
         (cond
          ((|isCategoryForm| x e)
           (setq parameters
            (|union|
              (dolist (y (cdr x) tmp5)
               (setq tmp5 (append tmp5 (getParms y e))))
              parameters))
           x)
          ((and (pairp x) (eq (qcar x) '|DomainSubstitutionMacro|)
                (pairp (qcdr x)) (pairp (qcdr (qcdr x)))
                (eq (qcdr (qcdr (qcdr x))) nil))
           (setq pl (second x))
           (setq body (third x))
           (setq parameters (|union| pl parameters)) body)
          ((and (pairp x) (eq (qcar x) '|mkCategory|))
            x)
          ((and (atom x) (equal (|getmode| x e) |$Category|))
            x)
          (t
           (|stackSemanticError| (list '|invalid argument to Join: | x) nil)
           x))
         tmp4))))
    (setq td (list (|wrapDomainSub| parameters (cons '|Join| catListp))
               |$Category| e))
    (|convert| td m))))))

@

\defplist{$+->$}{compLambda}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|+->| 'special) '|compLambda|))

@

\defun{compLambda}{compLambda}
\calls{compLambda}{qcar}
\calls{compLambda}{qcdr}
\calls{compLambda}{argsToSig}
\calls{compLambda}{compAtSign}
\calls{compLambda}{stackAndThrow}
<<defun compLambda>>=
(defun |compLambda| (x m e)
 (let (vl body tmp1 tmp2 tmp3 target args arg1 sig1 ress)
  (setq vl (second x))
  (setq body (third x))
  (cond
   ((and (pairp vl) (eq (qcar vl) '|:|)
         (progn
          (setq tmp1 (qcdr vl))
          (and (pairp tmp1)
               (progn
                (setq args (qcar tmp1))
                (setq tmp2 (qcdr tmp1))
                (and (pairp tmp2)
                     (eq (qcdr tmp2) nil)
                     (progn
                      (setq target (qcar tmp2))
                      t))))))
     (when (and (pairp args) (eq (qcar args) '|@Tuple|))
      (setq args (qcdr args)))       
     (cond
      ((listp args)
       (setq tmp3 (|argsToSig| args))
       (setq arg1 (CAR tmp3))
       (setq sig1 (second tmp3))
       (cond
        (sig1 
         (setq ress
          (|compAtSign|
           (list '@
            (list '+-> arg1 body)
            (cons '|Mapping| (cons target sig1))) m e))
          ress)
        (t (|stackAndThrow| (list '|compLambda| x )))))
      (t (|stackAndThrow| (list '|compLambda| x )))))
    (t (|stackAndThrow| (list '|compLambda| x ))))))

@

\defplist{leave}{compLeave}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|leave| 'special) '|compLeave|))

@

\defun{compLeave}{compLeave}
\calls{compLeave}{comp}
\calls{compLeave}{modifyModeStack}
\usesdollar{compLeave}{exitModeStack}
\usesdollar{compLeave}{leaveLevelStack}
<<defun compLeave>>=
(defun |compLeave| (arg m e)
 (let (level x index u)
  (declare (special |$exitModeStack| |$leaveLevelStack|))
   (setq level (second arg))
   (setq x (third arg))
   (setq index 
     (- (1- (|#| |$exitModeStack|)) (elt |$leaveLevelStack| (1- level))))
   (when (setq u (|comp| x (elt |$exitModeStack| index) e))
    (|modifyModeStack| (second u) index)
    (list (list '|TAGGEDexit| index u) m e ))))

@

\defplist{mdef}{compMacro}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'mdef 'special) '|compMacro|))

@

\defun{compMacro}{compMacro}
\calls{compMacro}{qcar}
\calls{compMacro}{formatUnabbreviated}
\calls{compMacro}{sayBrightly}
\calls{compMacro}{put}
\calls{compMacro}{macroExpand}
\usesdollar{compMacro}{macroIfTrue}
\usesdollar{compMacro}{NoValueMode}
\usesdollar{compMacro}{EmptyMode}
<<defun compMacro>>=
(defun |compMacro| (form m e)
 (let (|$macroIfTrue| lhs signature specialCases rhs prhs)
 (declare (special |$macroIfTrue| |$NoValueMode| |$EmptyMode|))
  (setq |$macroIfTrue| t)
  (setq lhs (second form))
  (setq signature (third form))
  (setq specialCases (fourth form))
  (setq rhs (fifth form))
  (setq prhs
   (cond
    ((and (pairp rhs) (eq (qcar rhs) 'category))
      (list "-- the constructor category"))
    ((and (pairp rhs) (eq (qcar rhs) '|Join|))
      (list "-- the constructor category"))
    ((and (pairp rhs) (eq (qcar rhs) 'capsule))
      (list "-- the constructor capsule"))
    ((and (pairp rhs) (eq (qcar rhs) '|add|))
      (list "-- the constructor capsule"))
    (t (|formatUnabbreviated| rhs))))
  (|sayBrightly|
   (cons "   processing macro definition"
    (cons '|%b|
     (append (|formatUnabbreviated| lhs)
      (cons " ==> "
       (append prhs (list '|%d|)))))))
  (when (or (equal m |$EmptyMode|) (equal m |$NoValueMode|))
    (list '|/throwAway| |$NoValueMode| 
     (|put| (CAR lhs) '|macro| (|macroExpand| rhs e) e)))))

@

\defplist{pretend}{compPretend}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|pretend| 'special) '|compPretend|))

@

\defun{compPretend}{compPretend}
\calls{compPretend}{addDomain}
\calls{compPretend}{comp}
\calls{compPretend}{opOf}
\calls{compPretend}{nequal}
\calls{compPretend}{stackSemanticError}
\calls{compPretend}{stackWarning}
\usesdollar{compPretend}{newCompilerUnionFlag}
\usesdollar{compPretend}{EmptyMode}
<<defun compPretend>>=
(defun |compPretend| (arg m e)
 (let (x tt warningMessage td tp)
 (declare (special |$newCompilerUnionFlag| |$EmptyMode|))
  (setq x (second arg))
  (setq tt (third arg))
  (setq e (|addDomain| tt e))
  (when (setq td (or (|comp| x tt e) (|comp| x |$EmptyMode| e)))
   (when (equal (second td) tt)
    (setq warningMessage (list '|pretend| tt '| -- should replace by @|)))
   (cond
     ((and |$newCompilerUnionFlag|
           (eq (|opOf| (second td)) '|Union|)
           (nequal (|opOf| m) '|Union|))
       (|stackSemanticError|
        (list '|cannot pretend | x '| of mode | (second td) '| to mode | m)
         nil))
     (t
      (setq td (list (first td) tt (third td)))
      (when (setq tp (|coerce| td m))
        (when warningMessage (|stackWarning| warningMessage))
        tp))))))

@

\defplist{quote}{compQuote}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'quote 'special) '|compQuote|))

@

\defun{compQuote}{compQuote}
<<defun compQuote>>=
(defun |compQuote| (expr m e)
 (list expr m e))

@

\defplist{collect}{compRepeatOrCollect}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'collect 'special) '|compRepeatOrCollect|))

@

\defplist{repeat}{compRepeatOrCollect}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'repeat 'special) '|compRepeatOrCollect|))

@

\defun{compRepeatOrCollect}{compRepeatOrCollect}
\calls{compRepeatOrCollect}{length}
\calls{compRepeatOrCollect}{compIterator}
\calls{compRepeatOrCollect}{modeIsAggregateOf}
\calls{compRepeatOrCollect}{stackMessage}
\calls{compRepeatOrCollect}{compOrCroak}
\calls{compRepeatOrCollect}{comp}
\calls{compRepeatOrCollect}{msubst}
\calls{compRepeatOrCollect}{coerceExit}
\calls{compRepeatOrCollect}{}
\calls{compRepeatOrCollect}{}
\usesdollar{compRepeatOrCollect}{until}
\usesdollar{compRepeatOrCollect}{Boolean}
\usesdollar{compRepeatOrCollect}{NoValueMode}
\usesdollar{compRepeatOrCollect}{exitModeStack}
\usesdollar{compRepeatOrCollect}{leaveLevelStack}
\usesdollar{compRepeatOrCollect}{formalArgList}
<<defun compRepeatOrCollect>>=
(defun |compRepeatOrCollect| (form m e)
 (labels (
  (fn (form |$exitModeStack| |$leaveLevelStack| |$formalArgList| e)
  (declare (special |$exitModeStack| |$leaveLevelStack| |$formalArgList|))
  (let (|$until| body itl xp targetMode repeatOrCollect bodyMode bodyp mp tmp1 
         untilCode ep itlp formp u mpp tmp2)
  (declare (special  |$Boolean| |$until| |$NoValueMode| ))
   (setq |$until| nil)
   (setq repeatOrCollect (car form))
   (setq tmp1 (reverse (cdr form)))
   (setq body (car tmp1))
   (setq itl (nreverse (cdr tmp1)))
   (setq itlp
    (dolist (x itl (nreverse0 tmp2))
     (setq tmp1 (or (|compIterator| x e) (return '|failed|)))
     (setq xp (first tmp1))
     (setq e (second tmp1))
     (push xp tmp2)))
   (unless (eq itlp '|failed|)
    (setq targetMode (car |$exitModeStack|))
    (setq bodyMode
      (if (eq repeatOrCollect 'collect)
       (cond
        ((eq targetMode '|$EmptyMode|)
          '|$EmptyMode|)
        ((setq u (|modeIsAggregateOf| '|List| targetMode e))
          (second u))
        ((setq u (|modeIsAggregateOf| '|PrimitiveArray| targetMode e))
         (setq repeatOrCollect 'collectv) 
         (second u))
        ((setq u (|modeIsAggregateOf| '|Vector| targetMode e))
         (setq repeatOrCollect 'collectvec)
         (second u))
        (t
         (|stackMessage| "Invalid collect bodytype")
         '|failed|))
        |$NoValueMode|))
     (unless (eq bodyMode '|failed|)
      (when (setq tmp1 (|compOrCroak| body bodyMode e))
       (setq bodyp (first tmp1))
       (setq mp (second tmp1))
       (setq ep (third tmp1))
       (when |$until|
         (setq tmp1 (|comp| |$until| |$Boolean| ep))
         (setq untilCode (first tmp1))
         (setq ep (third tmp1))
         (setq itlp (msubst (list 'until untilCode) '|$until| itlp)))
       (setq formp (cons repeatOrCollect (append itlp (list bodyp))))
       (setq mpp
        (cond
         ((eq repeatOrCollect 'collect)
           (if (setq u (|modeIsAggregateOf| '|List| targetMode e))
             (car u)
             (list '|List| mp)))
         ((eq repeatOrCollect 'collectv)
           (if (setq u (|modeIsAggregateOf| '|PrimitiveArray| targetMode e))
             (car u)
             (list '|PrimitiveArray| mp)))
         ((eq repeatOrCollect 'collectvec)
           (if (setq u (|modeIsAggregateOf| '|Vector| targetMode e))
             (car u)
             (list '|Vector| mp)))
         (t mp)))
       (|coerceExit| (list formp  mpp ep) targetMode)))))) )
 (declare (special |$exitModeStack| |$leaveLevelStack| |$formalArgList|))
 (fn form
   (cons m |$exitModeStack|)
   (cons (|#| |$exitModeStack|) |$leaveLevelStack|)
   |$formalArgList|
   e)))


@

\defplist{reduce}{compReduce}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'reduce 'special) '|compReduce|))

@

\defun{compReduce}{compReduce}
\calls{compReduce}{compReduce1}
\usesdollar{compReduce}{formalArgList}
<<defun compReduce>>=
(defun |compReduce| (form m e)
  (declare (special |$formalArgList|))
  (|compReduce1| form m e |$formalArgList|))

@

\defun{compReduce1}{compReduce1}
\calls{compReduce1}{systemError}
\calls{compReduce1}{nreverse0}
\calls{compReduce1}{compIterator}
\calls{compReduce1}{comp}
\calls{compReduce1}{parseTran}
\calls{compReduce1}{getIdentity}
\calls{compReduce1}{msubst}
\usesdollar{compReduce1}{sideEffectsList}
\usesdollar{compReduce1}{until}
\usesdollar{compReduce1}{initList}
\usesdollar{compReduce1}{Boolean}
\usesdollar{compReduce1}{e}
\usesdollar{compReduce1}{endTestList}
<<defun compReduce1>>=
(defun |compReduce1| (form m e |$formalArgList|)
 (declare (special |$formalArgList|))
 (let (|$sideEffectsList| |$until| |$initList| |$endTestList| collectForm 
       collectOp body op itl acc afterFirst bodyVal part1 part2 part3 id
       identityCode untilCode finalCode tmp1 tmp2)
 (declare (special |$sideEffectsList| |$until| |$initList| |$Boolean| |$e|
                   |$endTestList|))
  (setq op (second form))
  (setq collectForm (fourth form))
  (setq collectOp (first collectForm))
  (setq tmp1 (reverse (cdr collectForm)))
  (setq body (first tmp1))
  (setq itl (nreverse (cdr tmp1)))
  (when (stringp op) (setq op (intern op)))
  (cond
   ((null (member collectOp '(collect collectv collectvec)))
    (|systemError| (list '|illegal reduction form:| form)))
   (t 
    (setq |$sideEffectsList| nil)
    (setq |$until| nil)
    (setq |$initList| nil)
    (setq |$endTestList| nil)
    (setq |$e| e)
    (setq itl
     (dolist (x itl (nreverse0 tmp2))
      (setq tmp1 (or (|compIterator| x |$e|) (return '|failed|)))
      (setq |$e| (second tmp1))
      (push (elt tmp1 0) tmp2)))
    (unless (eq itl '|failed|)
     (setq e |$e|)
     (setq acc (gensym))
     (setq afterFirst (gensym))
     (setq bodyVal (gensym))
     (when (setq tmp1 (|comp| (list 'let bodyVal body ) m e))
      (setq part1 (first tmp1))
      (setq m (second tmp1))
      (setq e (third tmp1))
      (when (setq tmp1 (|comp| (list 'let acc bodyVal) m e))
       (setq part2 (first tmp1))
       (setq e (third tmp1))
       (when (setq tmp1 
              (|comp| (list 'let acc (|parseTran| (list op acc bodyVal))) m e))
        (setq part3 (first tmp1))
        (setq e (third tmp1))
        (when (setq identityCode
               (if (setq id (|getIdentity| op e)) 
                (car (|comp| id m e))
                (list '|IdentityError| (mkq op))))
         (setq finalCode
          (cons 'progn
           (cons (list 'let afterFirst nil)
            (cons
             (cons 'repeat
              (append itl
               (list
                (list 'progn part1
                 (list 'if afterFirst part3 
                  (list 'progn part2 (list 'let afterFirst (mkq t)))) nil))))
                   (list (list 'if afterFirst acc identityCode ))))))
         (when |$until|
          (setq tmp1 (|comp| |$until| |$Boolean| e))
          (setq untilCode (first tmp1))
          (setq e (third tmp1))
          (setq finalCode
           (msubst (list 'until untilCode) '|$until| finalCode)))
          (list finalCode m e ))))))))))

@

\defplist{return}{compReturn}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|return| 'special) '|compReturn|))

@

\defun{compReturn}{compReturn}
\calls{compReturn}{stackSemanticError}
\calls{compReturn}{nequal}
\calls{compReturn}{userError}
\calls{compReturn}{resolve}
\calls{compReturn}{comp}
\calls{compReturn}{modifyModeStack}
\usesdollar{compReturn}{exitModeStack}
\usesdollar{compReturn}{returnMode}
<<defun compReturn>>=
(defun |compReturn| (arg m e)
 (let (level x index u xp mp ep)
 (declare (special |$returnMode| |$exitModeStack|))
  (setq level (second arg))
  (setq x (third arg))
  (cond
   ((null |$exitModeStack|)
    (|stackSemanticError|
      (list '|the return before| '|%b| x '|%d| '|is unneccessary|) nil)
    nil)
   ((nequal level 1)
     (|userError| "multi-level returns not supported"))
   (t
    (setq index (max 0 (1- (|#| |$exitModeStack|))))
    (when (>= index 0)
      (setq |$returnMode|
       (|resolve| (elt |$exitModeStack| index) |$returnMode|)))
    (when (setq u (|comp| x |$returnMode| e))
     (setq xp (first u))
     (setq mp (second u))
     (setq ep (third u))
     (when (>= index 0)
       (setq |$returnMode| (|resolve| mp |$returnMode|))
       (|modifyModeStack| mp index))
     (list (list '|TAGGEDreturn| 0 u) m ep))))))

@

\defplist{seq}{compSeq}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'seq 'special) '|compSeq|))

@

\defun{compSeq}{compSeq}
\calls{compSeq}{compSeq1}
\usesdollar{compSeq}{exitModeStack}
<<defun compSeq>>=
(defun |compSeq| (arg0 m e)
 (declare (special |$exitModeStack|))
 (|compSeq1| (cdr arg0) (cons m |$exitModeStack|) e))

@

\defun{compSeq1}{compSeq1}
\calls{compSeq1}{nreverse0}
\calls{compSeq1}{compSeqItem}
\calls{compSeq1}{mkq}
\calls{compSeq1}{replaceExitEtc}
\usesdollar{compSeq1}{exitModeStack}
\usesdollar{compSeq1}{insideExpressionIfTrue}
\usesdollar{compSeq1}{finalEnv}
\usesdollar{compSeq1}{NoValueMode}
<<defun compSeq1>>=
(defun |compSeq1| (l |$exitModeStack| e)
 (declare (special |$exitModeStack|))
 (let (|$insideExpressionIfTrue| |$finalEnv| tmp1 tmp2 c catchTag form)
 (declare (special |$insideExpressionIfTrue| |$finalEnv| |$NoValueMode|))
  (setq |$insideExpressionIfTrue| nil)
  (setq |$finalEnv| nil)
  (when
    (setq c (dolist (x l (nreverse0 tmp2))
             (setq |$insideExpressionIfTrue| nil)
             (setq tmp1 (|compSeqItem| x |$NoValueMode| e))
             (unless tmp1 (return nil))
             (setq e (third tmp1))
             (push (first tmp1) tmp2)))
   (setq catchTag (mkq (gensym)))
   (setq form
    (cons 'seq
     (|replaceExitEtc| c catchTag '|TAGGEDexit| (elt |$exitModeStack| 0))))
   (list (list 'catch catchTag form) (elt |$exitModeStack| 0) |$finalEnv|))))

@

\defun{compSeqItem}{compSeqItem}
\calls{compSeqItem}{comp}
\calls{compSeqItem}{macroExpand}
<<defun compSeqItem>>=
(defun |compSeqItem| (x m e)
  (|comp| (|macroExpand| x e) m e))

@

\defplist{let}{compSetq}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'let 'special) '|compSetq|))

@

\defplist{setq}{compSetq}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'setq 'special) '|compSetq|))

@

\defun{compSetq}{compSetq}
\calls{compSetq}{compSetq1}
<<defun compSetq>>=
(defun |compSetq| (arg m e)
 (|compSetq1| (second arg) (third arg) m e))

@

\defun{compSetq1}{compSetq1}
\calls{compSetq1}{setqSingle}
\calls{compSetq1}{identp}
\calls{compSetq1}{compMakeDeclaration}
\calls{compSetq1}{compSetq}
\calls{compSetq1}{qcar}
\calls{compSetq1}{qcdr}
\calls{compSetq1}{setqMultiple}
\calls{compSetq1}{setqSetelt}
\usesdollar{compSetq1}{EmptyMode}
<<defun compSetq1>>=
(defun |compSetq1| (form val m e)
 (let (x y ep op z)
 (declare (special |$EmptyMode|))
 (cond
  ((identp form) (|setqSingle| form val m e))
  ((and (pairp form) (eq (qcar form) '|:|) (pairp (qcdr form))
        (pairp (qcdr (qcdr form))) (eq (qcdr (qcdr (qcdr form))) nil))
    (setq x (second form))
    (setq y (third form))
    (setq ep (third (|compMakeDeclaration| form |$EmptyMode| e)))
    (|compSetq| (list 'let x val) m ep))
  ((pairp form)
    (setq op (qcar form))
    (setq z (qcdr form))
    (cond
     ((eq op 'cons)     (|setqMultiple| (|uncons| form) val m e))
     ((eq op '|@Tuple|) (|setqMultiple| z val m e))
     (t                 (|setqSetelt| form val m e)))))))

@

\defun{setqSetelt}{setqSetelt}
\calls{setqSetelt}{comp}
<<defun setqSetelt>>=
(defun |setqSetelt| (arg val m e)
 (|comp| (cons '|setelt| (cons (car arg) (append (cdr arg) (list val)))) m e))

@

\defun{setqSingle}{setqSingle}
\calls{setqSingle}{getProplist}
\calls{setqSingle}{getmode}
\calls{setqSingle}{get}
\calls{setqSingle}{nequal}
\calls{setqSingle}{maxSuperType}
\calls{setqSingle}{comp}
\calls{setqSingle}{getmode}
\calls{setqSingle}{assignError}
\calls{setqSingle}{convert}
\calls{setqSingle}{identp}
\calls{setqSingle}{profileRecord}
\calls{setqSingle}{consProplistOf}
\calls{setqSingle}{removeEnv}
\calls{setqSingle}{addBinding}
\calls{setqSingle}{isDomainForm}
\calls{setqSingle}{isDomainInScope}
\calls{setqSingle}{stackWarning}
\calls{setqSingle}{augModemapsFromDomain1}
\calls{setqSingle}{NRTassocIndex}
\calls{setqSingle}{isDomainForm}
\calls{setqSingle}{outputComp}
\usesdollar{setqSingle}{insideSetqSingleIfTrue}
\usesdollar{setqSingle}{QuickLet}
\usesdollar{setqSingle}{form}
\usesdollar{setqSingle}{profileCompiler}
\usesdollar{setqSingle}{EmptyMode}
\usesdollar{setqSingle}{NoValueMode}
<<defun setqSingle>>=
(defun |setqSingle| (id val m e)
 (let (|$insideSetqSingleIfTrue| currentProplist mpp maxmpp td x mp tp key 
       newProplist ep k form)
 (declare (special |$insideSetqSingleIfTrue| |$QuickLet| |$form|
                   |$profileCompiler| |$EmptyMode| |$NoValueMode|))
  (setq |$insideSetqSingleIfTrue| t)
  (setq currentProplist (|getProplist| id e))
  (setq mpp
   (or (|get| id '|mode| e) (|getmode| id e)
       (if (equal m |$NoValueMode|) |$EmptyMode| m)))
  (when (setq td
         (cond
          ((setq td (|comp| val mpp e)) 
           td)
          ((and (null (|get| id '|mode| e))
                (nequal mpp (setq maxmpp (|maxSuperType| mpp e)))
                (setq td (|comp| val maxmpp e)))
           td)
          ((and (setq td (|comp| val |$EmptyMode| e))
                (|getmode| (second td) e))
           (|assignError| val (second td) id mpp))))
   (when (setq tp (|convert| td m))
    (setq x (first tp))
    (setq mp (second tp))
    (setq ep (third tp))
    (when (and |$profileCompiler| (identp id))
      (setq key (if (member id (cdr |$form|)) '|arguments| '|locals|))
      (|profileRecord| key id (second td)))
    (setq newProplist
     (|consProplistOf| id currentProplist '|value|
      (|removeEnv| (cons val (cdr td)))))
    (setq ep (if (pairp id) ep (|addBinding| id newProplist ep)))
    (when (|isDomainForm| val ep)
     (when (|isDomainInScope| id ep)
      (|stackWarning|
       (list '|domain valued variable| '|%b| id '|%d| 
              '|has been reassigned within its scope| )))
      (setq ep (|augModemapsFromDomain1| id val ep)))
    (if (setq k (|NRTassocIndex| id))
      (setq form (list 'setelt '$ k x))
      (setq form
       (if |$QuickLet| 
        (list 'let id x)
        (list 'let id x
          (if (|isDomainForm| x ep) 
            (list 'elt id 0)
            (car (|outputComp| id ep)))))))
    (list form mp ep)))))

@

\defplist{String}{compString}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|String| 'special) '|compString|))

@

\defun{compString}{compString}
\calls{compString}{resolve}
\usesdollar{compString}{StringCategory}
<<defun compString>>=
(defun |compString| (x m e)
 (declare (special |$StringCategory|))
 (list x (|resolve| |$StringCategory| m) e))

@

\defplist{SubDomain}{compSubDomain}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|SubDomain| 'special) '|compSubDomain|))

@

\defun{compSubDomain}{compSubDomain}
\calls{compSubDomain}{compSubDomain1}
\calls{compSubDomain}{compCapsule}
\usesdollar{compSubDomain}{addFormLhs}
\usesdollar{compSubDomain}{NRTaddForm}
\usesdollar{compSubDomain}{addForm}
\usesdollar{compSubDomain}{addFormLhs}
<<defun compSubDomain>>=
(defun |compSubDomain| (arg m e)
 (let (|$addFormLhs| |$addForm| domainForm predicate tmp1)
 (declare (special |$addFormLhs| |$addForm| |$NRTaddForm| |$addFormLhs|))
  (setq domainForm (second arg))
  (setq predicate (third arg))
  (setq |$addFormLhs| domainForm)
  (setq |$addForm| nil)
  (setq |$NRTaddForm| domainForm)
  (setq tmp1 (|compSubDomain1| domainForm predicate m e))
  (setq |$addForm| (first tmp1))
  (setq e (third tmp1))
  (|compCapsule| (list 'capsule) m e)))

@

\defun{compSubDomain1}{compSubDomain1}
\calls{compSubDomain1}{compMakeDeclaration}
\calls{compSubDomain1}{addDomain}
\calls{compSubDomain1}{compOrCroak}
\calls{compSubDomain1}{stackSemanticError}
\calls{compSubDomain1}{lispize}
\calls{compSubDomain1}{evalAndRwriteLispForm}
\usesdollar{compSubDomain1}{CategoryFrame}
\usesdollar{compSubDomain1}{op}
\usesdollar{compSubDomain1}{lisplibSuperDomain}
\usesdollar{compSubDomain1}{Boolean}
\usesdollar{compSubDomain1}{EmptyMode}
<<defun compSubDomain1>>=
(defun |compSubDomain1| (domainForm predicate m e)
 (let (u prefixPredicate opp dFp)
 (declare (special |$CategoryFrame| |$op| |$lisplibSuperDomain| |$Boolean|
                   |$EmptyMode|))
  (setq e (third
   (|compMakeDeclaration| (list '|:| '|#1| domainForm)
     |$EmptyMode| (|addDomain| domainForm e))))
   (setq u (|compOrCroak| predicate |$Boolean| e))
   (unless u
    (|stackSemanticError|
     (list '|predicate: | predicate 
           '| cannot be interpreted with #1: | domainForm) nil))
   (setq prefixPredicate (|lispize| (first u)))
   (setq |$lisplibSuperDomain| (list domainForm predicate))
   (|evalAndRwriteLispForm| '|evalOnLoad2|
    (list 'setq '|$CategoryFrame|
     (list '|put|
      (setq opp (list 'quote |$op|))
       ''|SuperDomain|
        (setq dFp (list 'quote domainForm))
         (list '|put| dFp ''|SubDomain|
          (list 'cons (list 'quote (cons |$op| prefixPredicate))
          (list 'delasc opp (list '|get| dFp ''|SubDomain| '|$CategoryFrame|)))
          '|$CategoryFrame|))))
   (list domainForm m e)))

@

\defplist{SubsetCategory}{compSubsetCategory}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|SubsetCategory| 'special) '|compSubsetCategory|))

@

\defun{compSubsetCategory}{compSubsetCategory}
\calls{compSubsetCategory}{put}
\calls{compSubsetCategory}{comp}
\calls{compSubsetCategory}{msubst}
\usesdollar{compSubsetCategory}{lhsOfColon}
<<defun compSubsetCategory>>=
(defun |compSubsetCategory| (arg m e)
 (let (cat r)
 (declare (special |$lhsOfColon|))
  (setq cat (second arg))
  (setq r (third arg))
  ;  --1. put "Subsets" property on R to allow directly coercion to subset;
  ;  --   allow automatic coercion from subset to R but not vice versa
  (setq e (|put| r '|Subsets| (list (list |$lhsOfColon| '|isFalse|)) e))
  ;  --2. give the subset domain modemaps of cat plus 3 new functions
  (|comp|
    (list '|Join| cat
      (msubst |$lhsOfColon| '$
             (list 'category '|domain|
              (list 'signature '|coerce| (list r '$))
               (list 'signature '|lift| (list r '$))
                (list 'signature '|reduce| (list '$ r)))))
     m e)))

@

\defplist{|}{compSuchthat}
<<postvars>>=
(eval-when (eval load)
 (setf (get '\| 'special) '|compSuchthat|))

@

\defun{compSuchthat}{compSuchthat}
\calls{compSuchthat}{comp}
\calls{compSuchthat}{put}
\usesdollar{compSuchthat}{Boolean}
<<defun compSuchthat>>=
(defun |compSuchthat| (arg m e)
 (let (x p xp mp tmp1 pp)
 (declare (special |$Boolean|))
  (setq x (second arg))
  (setq p (third arg))
  (when (setq tmp1 (|comp| x m e))
   (setq xp (first tmp1))
   (setq mp (second tmp1))
   (setq e (third tmp1))
   (when (setq tmp1 (|comp| p |$Boolean| e))
    (setq pp (first tmp1))
    (setq e (third tmp1))
    (setq e (|put| xp '|condition| pp e))
    (list xp mp e)))))

@

\defplist{vector}{compVector}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'vector 'special) '|compVector|))

@

\defun{compVector}{compVector}
\begin{verbatim}
;  null l => [$EmptyVector,m,e]
;  Tl:= [[.,mUnder,e]:= comp(x,mUnder,e) or return "failed" for x in l]
;  Tl="failed" => nil
;  [["VECTOR",:[T.expr for T in Tl]],m,e]
\end{verbatim}
\calls{compVector}{comp}
\usesdollar{compVector}{EmptyVector}
<<defun compVector>>=
(defun |compVector| (l m e)
 (let (tmp1 tmp2 t0 failed (mUnder (second m)))
  (declare (special |$EmptyVector|))
   (if (null l)
    (list |$EmptyVector| m e)
    (progn
     (setq t0
      (do ((t3 l (cdr t3)) (x nil))
          ((or (atom t3) failed) (unless failed (nreverse0 tmp2)))
        (setq x (car t3))
        (if (setq tmp1 (|comp| x mUnder e))
          (progn
           (setq mUnder (second tmp1))
           (setq e (third tmp1))
           (push tmp1 tmp2))
          (setq failed t))))
     (unless failed      
      (list (cons 'vector (loop for texpr in t0 collect (car texpr))) m e))))))

@

\defplist{where}{compWhere}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|where| 'special) '|compWhere|))

@

\defun{compWhere}{compWhere}
\calls{compWhere}{comp}
\calls{compWhere}{macroExpand}
\calls{compWhere}{deltaContour}
\calls{compWhere}{addContour}
\usesdollar{compWhere}{insideExpressionIfTrue}
\usesdollar{compWhere}{insideWhereIfTrue}
\usesdollar{compWhere}{EmptyMode}
<<defun compWhere>>=
(defun |compWhere| (arg0 m eInit)
 (let (|$insideExpressionIfTrue| |$insideWhereIfTrue| form exprList e 
       eBefore tmp1 x eAfter del eFinal)
 (declare (special |$insideExpressionIfTrue| |$insideWhereIfTrue|
                   |$EmptyMode|))
  (setq form (second arg0))
  (setq exprlist (cddr arg0))
  (setq |$insideExpressionIfTrue| nil)
  (setq |$insideWhereIfTrue| t)
  (setq e eInit)
  (when (dolist (item exprList t)
          (setq tmp1 (|comp| item |$EmptyMode| e))
          (unless tmp1 (return nil))
          (setq e (third tmp1)))
  (setq |$insideWhereIfTrue| nil)
  (setq tmp1 (|comp| (|macroExpand| form (setq eBefore e)) m e))
  (when tmp1
    (setq x (first tmp1))
    (setq m (second tmp1))
    (setq eAfter (third tmp1))
    (setq del (|deltaContour| eAfter eBefore))
    (if del
      (setq eFinal (|addContour| del eInit))
      (setq eFinal eInit))
    (list x m eFinal)))))

@

\chapter{Post Transformers}
\section{Direct called postparse routines}
\defun{postTransform}{postTransform}
\calls{postTransform}{postTran}
\calls{postTransform}{identp}
\calls{postTransform}{postTransformCheck}
\calls{postTransform}{aplTran}
<<defun postTransform>>=
(defun |postTransform| (y)
 (let (x tmp1 tmp2 tmp3 tmp4 tmp5 tt l u)
  (setq x y)
  (setq u (|postTran| x))
  (when
   (and (pairp u) (eq (qcar u) '|@Tuple|)
        (progn
         (setq tmp1 (qcdr u))
         (and (pairp tmp1)
              (progn (setq tmp2 (reverse tmp1)) t)
              (pairp tmp2)
              (progn
               (setq tmp3 (qcar tmp2))
               (and (pairp tmp3)
                    (eq (qcar tmp3) '|:|)
                    (progn
                     (setq tmp4 (qcdr tmp3))
                     (and (pairp tmp4)
                          (progn
                           (setq y (qcar tmp4))
                           (setq tmp5 (qcdr tmp4))
                           (and (pairp tmp5)
                                (eq (qcdr tmp5) nil)
                                (progn (setq tt (qcar tmp5)) t)))))))
                        (progn (setq l (qcdr tmp2)) t)
                        (progn (setq l (nreverse l)) t)))
              (dolist (x l t) (unless (identp x) (return nil))))
    (setq u (list '|:| (cons 'listof (append l (list y))) tt)))
  (|postTransformCheck| u)
  (|aplTran| u)))

@

\defun{postTran}{postTran}
\calls{postTran}{postAtom}
\calls{postTran}{postTran}
\calls{postTran}{pairp}
\calls{postTran}{qcar}
\calls{postTran}{qcdr}
\calls{postTran}{unTuple}
\calls{postTran}{postTranList}
\calls{postTran}{postForm}
\calls{postTran}{postOp}
\calls{postTran}{postScriptsForm}
<<defun postTran>>=
(defun |postTran| (x)
 (let (op f tmp1 a tmp2 tmp3 b y)
  (if (atom x)
   (|postAtom| x)
   (progn
    (setq op (car x))
    (cond
     ((and (atom op) (setq f (getl op '|postTran|)))
      (funcall f x))
     ((and (pairp op) (eq (qcar op) '|elt|)
           (progn
            (setq tmp1 (qcdr op))
            (and (pairp tmp1)
                 (progn
                   (setq a (qcar tmp1))
                   (setq tmp2 (qcdr tmp1))
                   (and (pairp tmp2)
                        (eq (qcdr tmp2) nil)
                        (progn (setq b (qcar tmp2)) t))))))
      (cons (|postTran| op) (cdr (|postTran| (cons b (cdr x))))))
     ((and (pairp op) (eq (qcar op) '|Scripts|))
      (|postScriptsForm| op
       (dolist (y (rest x) tmp3)
        (setq tmp3 (append tmp3 (|unTuple| (|postTran| y)))))))
     ((nequal op (setq y (|postOp| op)))
      (cons y (|postTranList| (cdr x))))
     (t (|postForm| x)))))))

@

\defun{postOp}{postOp}
<<defun postOp>>=
(defun |postOp| (x)
 (declare (special $boot))
 (cond
  ((eq x '|:=|) (if $boot 'spadlet 'let))
  ((eq x '|:-|) 'letd)
  ((eq x '|Attribute|) 'attribute)
  (t x)))

@


\defun{postAtom}{postAtom}
\usesdollar{postAtom}{boot}
<<defun postAtom>>=
(defun |postAtom| (x)
 (declare (special $boot))
  (cond
    ($boot x)
    ((eql x 0) '(|Zero|))
    ((eql x 1) '(|One|))
    ((eq x t) 't$)
    ((and (identp x) (getdatabase x 'niladic)) (list x))
    (t x)))

@

\defun{postTranList}{postTranList}
\calls{postTranList}{postTran}
<<defun postTranList>>=
(defun |postTranList| (x)
 (loop for y in x collect (|postTran| y)))

@

\defun{postScriptsForm}{postScriptsForm}
\calls{postScriptsForm}{getScriptName}
\calls{postScriptsForm}{length}
\calls{postScriptsForm}{postTranScripts}
<<defun postScriptsForm>>=
(defun |postScriptsForm| (arg0 argl)
 (let ((op (second arg0)) (a (third arg0)))
  (cons (|getScriptName| op a (|#| argl))
        (append (|postTranScripts| a) argl))))

@

\defun{postTranScripts}{postTranScripts}
\calls{postTranScripts}{postTranScripts}
\calls{postTranScripts}{postTran}
<<defun postTranScripts>>=
(defun |postTranScripts| (a)
 (labels (
  (fn (x) 
   (if (and (pairp x) (eq (qcar x) '|@Tuple|))
    (qcdr x)
    (list x))))
 (let (tmp1 tmp2 tmp3)
  (cond
   ((and (pairp a) (eq (qcar a) '|PrefixSC|)
         (progn
          (setq tmp1 (qcdr a))
          (and (pairp tmp1) (eq (qcdr tmp1) nil))))
     (|postTranScripts| (qcar tmp1)))
   ((and (pairp a) (eq (qcar a) '|;|))
    (dolist (y (qcdr a) tmp2)
     (setq tmp2 (append tmp2 (|postTranScripts| y)))))
   ((and (pairp a) (eq (qcar a) '|,|))
    (dolist (y (qcdr a) tmp3)
     (setq tmp3 (append tmp3 (fn (|postTran| y))))))
   (t (list (|postTran| a)))))))

@

\defun{postTransformCheck}{postTransformCheck}
\calls{postTransformCheck}{postcheck}
\usesdollar{postTransformCheck}{defOp}
<<defun postTransformCheck>>=
(defun |postTransformCheck| (x)
 (let (|$defOp|)
 (declare (special |$defOp|))
  (setq |$defOp| nil)
  (|postcheck| x)))

@

\defun{postcheck}{postcheck}
\calls{postcheck}{setDefOp}
\calls{postcheck}{postcheck}
<<defun postcheck>>=
(defun |postcheck| (x)
 (cond
  ((atom x) nil)
  ((and (pairp x) (eq (qcar x) 'def) (pairp (qcdr x)))
   (|setDefOp|  (qcar (qcdr x)))
   (|postcheck| (qcdr (qcdr x))))
  ((and (pairp x) (eq (qcar x) 'quote)) nil)
  (t (|postcheck| (car x)) (|postcheck| (cdr x)))))

@

\defun{postError}{postError}
\calls{postError}{nequal}
\calls{postError}{bumperrorcount}
\usesdollar{postError}{defOp}
\usesdollar{postError}{InteractiveMode} 
\usesdollar{postError}{postStack}
<<defun postError>>=
(defun |postError| (msg)
 (let (xmsg)
  (declare (special |$defOp| |$postStack| |$InteractiveMode|))
  (bumperrorcount '|precompilation|)
  (setq xmsg
   (if (and (nequal |$defOp| '|$defOp|) (null |$InteractiveMode|))
    (cons |$defOp| (cons ": " msg))
    msg))
  (push xmsg |$postStack|)
  nil))

@

\defun{postForm}{postForm}
\calls{postForm}{postTranList}
\calls{postForm}{internl}
\calls{postForm}{postTran}
\calls{postForm}{postError}
\calls{postForm}{bright}
\usesdollar{postForm}{boot}
<<defun postForm>>=
(defun |postForm| (u)
 (let (op argl arglp numOfArgs opp x)
 (declare (special $boot))
  (seq
   (setq op (car u))
   (setq argl (cdr u))
   (setq x
    (cond
     ((atom op)
       (setq arglp (|postTranList| argl))
       (setq opp
         (seq 
          (exit op)
          (when $boot (exit op))
          (when (or (getl op '|Led|)  (getl op '|Nud|) (eq op 'in)) (exit op))
          (setq numOfArgs
           (cond
            ((and (pairp arglp) (eq (qcdr arglp) nil) (pairp (qcar arglp)) 
                  (eq (qcar (qcar arglp)) '|@Tuple|))
              (|#| (qcdr (qcar arglp))))
            (t 1)))
          (internl '* (stringimage numOfArgs) (pname op))))
       (cons opp arglp))
     ((and (pairp op) (eq (qcar op) '|Scripts|))
       (append (|postTran| op) (|postTranList| argl)))
     (t
      (setq u (|postTranList| u))
      (cond
       ((and (pairp u) (pairp (qcar u)) (eq (qcar (qcar u)) '|@Tuple|))
         (|postError|
          (cons "  "
           (append (|bright| u)
            (list "is illegal because tuples cannot be applied!" '|%l| 
                  "   Did you misuse infix dot?"))))))
       u)))
   (cond
    ((and (pairp x) (pairp (qcdr x)) (eq (qcdr (qcdr x)) nil)
          (pairp (qcar (qcdr x))) (eq (qcar (qcar (qcdr x))) '|@Tuple|))
     (cons (car x) (qcdr (qcar (qcdr x)))))
    (t x)))))

@

\section{Indirect called postparse routines}
In the {\bf postTran} function there is the code:
\begin{verbatim}
     ((and (atom op) (setq f (getl op '|postTran|)))
      (funcall f x))
\end{verbatim}

The functions in this section are called through the symbol-plist
of the symbol being parsed. The original list read:

\begin{verbatim}
  add            postAdd
  @              postAtSign
  :BF:           postBigFloat
  Block          postBlock
  CATEGORY       postCategory
  COLLECT        postCollect
  :              postColon
  ::             postColonColon
  ,              postComma
  construct      postConstruct
  ==             postDef
  =>             postExit
  if             postIf
  in             postin       ;" the infix operator version of in"
  IN             postIn       ;" the iterator form of in"
  Join           postJoin
  ->             postMapping
  ==>            postMDef
  pretend        postPretend
  QUOTE          postQUOTE
  Reduce         postReduce
  REPEAT         postRepeat
  Scripts        postScripts
  ;              postSemiColon
  Signature      postSignature
  /              postSlash
  @Tuple         postTuple
  TupleCollect   postTupleCollect
  where          postWhere
  with           postWith
\end{verbatim}

@

\defplist{add}{postAdd}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|add| '|postTran|) '|postAdd|))

@

\defun{postAdd}{postAdd}
\calls{postAdd}{postTran}
\calls{postAdd}{postCapsule}
<<defun postAdd>>=
(defun |postAdd| (arg)
 (if (null (cddr arg))
  (|postCapsule| (second arg))
  (list '|add| (|postTran| (second arg)) (|postCapsule| (third arg)))))

@

\defplist{@}{postAtSign}
<<postvars>>=
(eval-when (eval load)
 (setf (get '@ '|postTran|) '|postAtSign|))

@

\defun{postAtSign}{postAtSign}
\calls{postAtSign}{postTran}
\calls{postAtSign}{postType}
<<defun postAtSign>>=
(defun |postAtSign| (arg)
 (cons '@ (cons (|postTran| (second arg)) (|postType| (third arg)))))

@

\defplist{:BF:}{postBigFloat}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|:BF:| '|postTran|) '|postBigFloat|))

@

\defun{postBigFloat}{postBigFloat}
\calls{postBigFloat}{postTran}
\usesdollar{postBigFloat}{boot}
\usesdollar{postBigFloat}{InteractiveMode}
<<defun postBigFloat>>=
(defun |postBigFloat| (arg)
 (let (mant expon eltword)
  (declare (special $boot |$InteractiveMode|))
  (setq mant (second arg))
  (setq expon (cddr arg))
  (if $boot 
   (times (float mant) (expt (float 10) expon))
   (progn
    (setq eltword (if |$InteractiveMode| '|$elt| '|elt|))
    (|postTran|
     (list (list eltword '(|Float|) '|float|)
       (list '|,| (list '|,| mant expon) 10)))))))

@

\defplist{Block}{postBlock}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|Block| '|postTran|) '|postBlock|))

@

\defun{postBlock}{postBlock}
\calls{postBlock}{postBlockItemList}
\calls{postBlock}{postTran}
<<defun postBlock>>=
(defun |postBlock| (arg)
 (let (tmp1 x y)
  (setq tmp1 (reverse (cdr arg)))
  (setq x (car tmp1))
  (setq y (nreverse (cdr tmp1)))
  (cons 'seq
   (append (|postBlockItemList| y) (list (list '|exit| (|postTran| x)))))))

@

\defplist{category}{postCategory}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'category '|postTran|) '|postCategory|))

@

\defun{postCategory}{postCategory}
\calls{postCategory}{postTran}
\calls{postCategory}{nreverse0}
\usesdollar{postCategory}{insidePostCategoryIfTrue}
<<defun postCategory>>=
(defun |postCategory| (u)
 (declare (special |$insidePostCategoryIfTrue|))
 (labels (
  (fn (arg)
   (let (|$insidePostCategoryIfTrue|)
   (declare (special |$insidePostCategoryIfTrue|))
    (setq |$insidePostCategoryIfTrue| t)
    (|postTran| arg))) )
 (let ((z (cdr u)) op tmp1)
  (if (null z)
   u
   (progn
     (setq op (if |$insidePostCategoryIfTrue| 'progn 'category))
     (cons op (dolist (x z (nreverse0 tmp1)) (push (fn x) tmp1))))))))

@

\defun{postCollect,finish}{postCollect,finish}
<<defun postCollect,finish>>=
(defun |postCollect,finish| (op itl y)
 (let (tmp2 tmp5 newBody)
  (cond
   ((and (pairp y) (eq (qcar y) '|:|)
         (pairp (qcdr y)) (eq (qcdr (qcdr y)) nil))
    (list 'reduce '|append| 0 (cons op (append itl (list (qcar (qcdr y)))))))
   ((and (pairp y) (eq (qcar y) '|Tuple|))
    (setq newBody
     (cond
      ((dolist (x (qcdr y) tmp2)
        (setq tmp2
         (or tmp2 (and (pairp x) (eq (qcar x) '|:|)
                       (pairp (qcdr x)) (eq (qcdr (qcdr x)) nil)))))
       (|postMakeCons| (qcdr y)))
      ((dolist (x (qcdr y) tmp5)
         (setq tmp5 (or tmp5 (and (pairp x) (eq (qcar x) 'segment)))))
        (|tuple2List| (qcdr y)))
      (t (cons '|construct| (|postTranList| (qcdr y))))))
     (list 'reduce '|append| 0 (cons op (append itl (list newBody)))))
   (t (cons op (append itl (list y)))))))

@

\defplist{collect}{postCollect}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'collect '|postTran|) '|postCollect|))

@

\defun{postCollect}{postCollect}
\calls{postCollect}{postCollect,finish}
\calls{postCollect}{postCollect}
\calls{postCollect}{postIteratorList}
\calls{postCollect}{postTran}
<<defun postCollect>>=
(defun |postCollect| (arg)
 (let (constructOp tmp3 m itl x)
  (setq constructOp (car arg))
  (setq tmp3 (reverse (cdr arg)))
  (setq x (car tmp3))
  (setq m (nreverse (cdr tmp3)))
  (cond
   ((and (pairp x) (pairp (qcar x)) (eq (qcar (qcar x)) '|elt|)
         (pairp (qcdr (qcar x))) (pairp (qcdr (qcdr (qcar x))))
         (eq (qcdr (qcdr (qcdr (qcar x)))) nil)
         (eq (qcar (qcdr (qcdr (qcar x)))) '|construct|))
    (|postCollect|
     (cons (list '|elt| (qcar (qcdr (qcar x))) 'collect)
      (append m (list (cons '|construct| (qcdr x)))))))
   (t
    (setq itl (|postIteratorList| m))
    (setq x
     (if (and (pairp x) (eq (qcar x) '|construct|)
              (pairp (qcdr x)) (eq (qcdr (qcdr x)) nil))
       (qcar (qcdr x))
       x))
    (|postCollect,finish| constructOp itl (|postTran| x))))))

@

\defplist{:}{postColon}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|:| '|postTran|) '|postColon|))

@

\defun{postColon}{postColon}
\calls{postColon}{postTran}
\calls{postColon}{postType}
<<defun postColon>>=
(defun |postColon| (u)
 (cond
  ((and (pairp u) (eq (qcar u) '|:|)
        (pairp (qcdr u)) (eq (qcdr (qcdr u)) nil))
    (list '|:| (|postTran| (qcar (qcdr u)))))
  ((and (pairp u) (eq (qcar u) '|:|) (pairp (qcdr u))
        (pairp (qcdr (qcdr u))) (eq (qcdr (qcdr (qcdr u))) nil))
   (cons '|:| (cons (|postTran| (second u)) (|postType| (third u)))))))

@

\defplist{::}{postColonColon}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|::| '|postTran|) '|postColonColon|))

@

\defun{postColonColon}{postColonColon}
\calls{postColonColon}{stringimage}
\calls{postColonColon}{postForm}
\usesdollar{postColonColon}{boot}
<<defun postColonColon>>=
(defun |postColonColon| (u)
  (if (and $boot (pairp u) (eq (qcar u) '|::|) (pairp (qcdr u))
           (pairp (qcdr (qcdr u))) (eq (qcdr (qcdr (qcdr u))) nil))
   (intern (stringimage (third u)) (second u))
   (|postForm| u)))

@

\defplist{,}{postComma}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|,| '|postTran|) '|postComma|))

@

\defun{postComma}{postComma}
\calls{postComma}{postTuple}
\calls{postComma}{comma2Tuple}
<<defun postComma>>=
(defun |postComma| (u)
 (|postTuple| (|comma2Tuple| u))) 

@

\defun{comma2Tuple}{comma2Tuple}
\calls{comma2Tuple}{postFlatten}
<<defun comma2Tuple>>=
(defun |comma2Tuple| (u)
 (cons '|@Tuple| (|postFlatten| u '|,|))) 

@

\defplist{construct}{postConstruct}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|construct| '|postTran|) '|postConstruct|))

@

\defun{postConstruct}{postConstruct}
\calls{postConstruct}{comma2Tuple}
\calls{postConstruct}{postTranSegment}
\calls{postConstruct}{postMakeCons}
\calls{postConstruct}{tuple2List}
\calls{postConstruct}{postTranList}
\calls{postConstruct}{postTran}
<<defun postConstruct>>=
(defun |postConstruct| (u)
 (let (b a tmp4 tmp7)
  (cond
   ((and (pairp u) (eq (qcar u) '|construct|)
         (pairp (qcdr u)) (eq (qcdr (qcdr u)) nil))
     (setq b (qcar (qcdr u)))
     (setq a
      (if (and (pairp b) (eq (qcar b) '|,|)) 
       (|comma2Tuple| b)
       b))
     (cond
      ((and (pairp a) (eq (qcar a) 'segment) (pairp (qcdr a))
            (pairp (qcdr (qcdr a))) (eq (qcdr (qcdr (qcdr a))) nil))
       (list '|construct| (|postTranSegment| (second a) (third a))))
      ((and (pairp a) (eq (qcar a) '|@Tuple|))
        (cond
         ((dolist (x (qcdr a) tmp4)
           (setq tmp4
            (or tmp4
             (and (pairp x) (eq (qcar x) '|:|)
                  (pairp (qcdr x)) (eq (qcdr (qcdr x)) nil)))))
          (|postMakeCons| (qcdr a)))
         ((dolist (x (qcdr a) tmp7)
            (setq tmp7 (or tmp7 (and (pairp x) (eq (qcar x) 'segment)))))
          (|tuple2List| (qcdr a)))
         (t (cons '|construct| (|postTranList| (qcdr a))))))
      (t (list '|construct| (|postTran| a)))))
   (t u))))

@

\defplist{==}{postDef}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|==| '|postTran|) '|postDef|))

@

\defun{postDef}{postDef}
\calls{postDef}{postMDef}
\calls{postDef}{recordHeaderDocumentation}
\calls{postDef}{nequal}
\calls{postDef}{postTran}
\calls{postDef}{postDefArgs}
\calls{postDef}{nreverse0}
\usesdollar{postDef}{boot}
\usesdollar{postDef}{maxSignatureLineNumber}
\usesdollar{postDef}{headerDocumentation}
\usesdollar{postDef}{docList}
\usesdollar{postDef}{InteractiveMode}
<<defun postDef>>=
(defun |postDef| (arg)
 (let (defOp rhs lhs targetType tmp1 op argl newLhs 
       argTypeList typeList form specialCaseForm tmp4 tmp6 tmp8)
 (declare (special $boot |$maxSignatureLineNumber| |$headerDocumentation|
                   |$docList| |$InteractiveMode|))
  (setq defOp (first arg))
  (setq lhs (second arg))
  (setq rhs (third arg))
  (if (and (pairp lhs) (eq (qcar lhs) '|macro|)
           (pairp (qcdr lhs)) (eq (qcdr (qcdr lhs)) nil))
   (|postMDef| (list '==> (second lhs) rhs))
   (progn
    (unless $boot (|recordHeaderDocumentation| nil))
    (when (nequal |$maxSignatureLineNumber| 0)
      (setq |$docList|
       (cons (cons '|constructor| |$headerDocumentation|) |$docList|))
      (setq |$maxSignatureLineNumber| 0))
    (setq lhs (|postTran| lhs))
    (setq tmp1
     (if (and (pairp lhs) (eq (qcar lhs) '|:|)) (cdr lhs) (list lhs nil)))
    (setq form (first tmp1))
    (setq targetType (second tmp1))
    (when (and (null |$InteractiveMode|) (atom form)) (setq form (list form)))
    (setq newLhs
     (if (atom form) 
      form
      (progn
       (setq tmp1
        (dolist (x form (nreverse0 tmp4))
         (push
           (if (and (pairp x) (eq (qcar x) '|:|) (pairp (qcdr x))
                    (pairp (qcdr (qcdr x))) (eq (qcdr (qcdr (qcdr x))) nil))
            (second x)
            x)
           tmp4)))
       (setq op (car tmp1))
       (setq argl (cdr tmp1))
       (cons op (|postDefArgs| argl)))))
    (setq argTypeList
     (unless (atom form)
      (dolist (x (cdr form) (nreverse0 tmp6))
       (push
         (when (and (pairp x) (eq (qcar x) '|:|) (pairp (qcdr x))
               (pairp (qcdr (qcdr x))) (eq (qcdr (qcdr (qcdr x))) nil))
           (third x))
         tmp6))))
    (setq typeList (cons targetType argTypeList))
    (when (atom form) (setq form (list form)))
    (setq specialCaseForm (dolist (x form (nreverse tmp8)) (push nil tmp8)))
    (list 'def newLhs typeList specialCaseForm (|postTran| rhs))))))

@

\defplist{$=>$}{postExit}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|=>| '|postTran|) '|postExit|))

@

\defun{postExit}{postExit}
\calls{postExit}{postTran}
<<defun postExit>>=
(defun |postExit| (arg)
 (list 'if (|postTran| (second arg))
  (list '|exit| (|postTran| (third arg)))
   '|noBranch|))

@

\defplist{if}{postIf}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|if| '|postTran|) '|postIf|))

@

\defun{postIf}{postIf}
\calls{postIf}{nreverse0}
\calls{postIf}{postTran}
\usesdollar{postIf}{boot}
<<defun postIf>>=
(defun |postIf| (arg)
 (let (tmp1)
  (if (null (and (pairp arg) (eq (qcar arg) '|if|)))
   arg
   (cons 'if
    (dolist (x (qcdr arg) (nreverse0 tmp1))
     (push
       (if (and (null (setq x (|postTran| x))) (null $boot)) '|noBranch| x)
       tmp1))))))

@

\defplist{in}{postin}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|in| '|postTran|) '|postin|))

@

\defun{postin}{postin}
\calls{postin}{systemErrorHere}
\calls{postin}{postTran}
\calls{postin}{postInSeq}
<<defun postin>>=
(defun |postin| (arg)
 (if (null (and (pairp arg) (eq (qcar arg) '|in|) (pairp (qcdr arg))
                (pairp (qcdr (qcdr arg))) (eq (qcdr (qcdr (qcdr arg))) nil)))
   (|systemErrorHere| "postin")
   (list '|in| (|postTran| (second arg)) (|postInSeq| (third arg)))))

@

\defplist{In}{postIn}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'in '|postTran|) '|postIn|))

@

\defun{postIn}{postIn}
\calls{postIn}{systemErrorHere}
\calls{postIn}{postTran}
\calls{postIn}{postInSeq}
<<defun postIn>>=
(defun |postIn| (arg)
  (if (null (and (pairp arg) (eq (qcar arg) 'in) (pairp (qcdr arg))
                 (pairp (qcdr (qcdr arg))) (eq (qcdr (qcdr (qcdr arg))) nil)))
    (|systemErrorHere| "postIn")
    (list 'in (|postTran| (second arg)) (|postInSeq| (third arg)))))

@

\defplist{Join}{postJoin}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|Join| '|postTran|) '|postJoin|))

@

\defun{postJoin}{postJoin}
\calls{postJoin}{postTran}
\calls{postJoin}{postTranList}
<<defun postJoin>>=
(defun |postJoin| (arg)
 (let (a l al)
  (setq a (|postTran| (cadr arg)))
  (setq l (|postTranList| (cddr arg)))
  (when (and (pairp l) (eq (qcdr l) nil) (pairp (qcar l))
             (member (qcar (qcar l)) '(attribute signature)))
    (setq l (list (list 'category (qcar l)))))
  (setq al (if (and (pairp a) (eq (qcar a) '|@Tuple|)) (qcdr a) (list a)))
  (cons '|Join| (append al l))))

@

\defplist{$->$}{postMapping}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|->| '|postTran|) '|postMapping|))

@

\defun{postMapping}{postMapping}
\calls{postMapping}{postTran}
\calls{postMapping}{unTuple}
<<defun postMapping>>=
(defun |postMapping| (u)
 (if (null (and (pairp u) (eq (qcar u) '->) (pairp (qcdr u))
           (pairp (qcdr (qcdr u))) (eq (qcdr (qcdr (qcdr u))) nil)))
   u
   (cons '|Mapping|
    (cons (|postTran| (third u))
          (|unTuple| (|postTran| (second u)))))))

@

\defplist{$==>$}{postMDef}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|==>| '|postTran|) '|postMDef|))

@

\defun{postMDef}{postMDef}
\calls{postMDef}{postTran}
\calls{postMDef}{throwkeyedmsg}
\calls{postMDef}{nreverse0}
\usesdollar{postMDef}{InteractiveMode}
\usesdollar{postMDef}{boot}
<<defun postMDef>>=
(defun |postMDef| (arg)
 (let (rhs lhs tmp1 targetType form newLhs typeList tmp4 tmp5 tmp8)
 (declare (special |$InteractiveMode| $boot))
  (setq lhs (second arg))
  (setq rhs (third arg))
  (cond
   ((and |$InteractiveMode| (null $boot))
    (setq lhs (|postTran| lhs))
    (if (null (identp lhs))
      (|throwkeyedmsg| 's2ip0001 nil)
      (list 'mdef lhs nil nil (|postTran| rhs))))
   (t
    (setq lhs (|postTran| lhs))
    (setq tmp1
     (if (and (pairp lhs) (eq (qcar lhs) '|:|)) (cdr lhs) (list lhs nil)))
    (setq form (first tmp1))
    (setq targetType (second tmp1))
    (setq form (if (atom form) (list form) form))
    (setq newLhs
     (dolist (x form (nreverse0 tmp4))
      (push
       (if (and (pairp x) (eq (qcar x) '|:|) (pairp (qcdr x))) (second x) x)
       tmp4)))
    (setq typeList
     (cons targetType
      (dolist (x (qcdr form) (nreverse0 tmp5))
       (push
         (when (and (pairp x) (eq (qcar x) '|:|) (pairp (qcdr x))
                    (pairp (qcdr (qcdr x))) (eq (qcdr (qcdr (qcdr x))) nil))
            (third x))
          tmp5))))
    (list 'mdef newLhs typeList 
     (dolist (x form (nreverse0 tmp8)) (push nil tmp8))
     (|postTran| rhs))))))

@

\defplist{pretend}{postPretend}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|pretend| '|postTran|) '|postPretend|))

@

\defun{postPretend}{postPretend}
\calls{postPretend}{postTran}
\calls{postPretend}{postType}
<<defun postPretend>>=
(defun |postPretend| (arg)
 (cons '|pretend| (cons (|postTran| (second arg)) (|postType| (third arg)))))

@

\defplist{quote}{postQUOTE}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'quote '|postTran|) '|postQUOTE|))

@

\defun{postQUOTE}{postQUOTE}
<<defun postQUOTE>>=
(defun |postQUOTE| (arg) arg) 

@

\defplist{reduce}{postReduce}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|Reduce| '|postTran|) '|postReduce|))

@

\defun{postReduce}{postReduce}
\calls{postReduce}{postTran}
\calls{postReduce}{postReduce}
\usesdollar{postReduce}{InteractiveMode}
<<defun postReduce>>=
(defun |postReduce| (arg)
 (let (op expr g)
  (setq op (second arg))
  (setq expr (third arg))
  (if (or |$InteractiveMode| (and (pairp expr) (eq (qcar expr) 'collect)))
    (list 'reduce op 0 (|postTran| expr))
    (|postReduce|
     (list '|Reduce| op
      (list 'collect
       (list 'in (setq g (gensym)) expr)
        (list '|construct| g)))))))

@

\defplist{repeat}{postRepeat}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'repeat '|postTran|) '|postRepeat|))

@

\defun{postRepeat}{postRepeat}
\calls{postRepeat}{postIteratorList}
\calls{postRepeat}{postTran}
<<defun postRepeat>>=
(defun |postRepeat| (arg)
 (let (tmp1 x m)
  (setq tmp1 (reverse (cdr arg)))
  (setq x (car tmp1))
  (setq m (nreverse (cdr tmp1)))
  (cons 'repeat (append (|postIteratorList| m) (list (|postTran| x))))))

@

\defplist{Scripts}{postScripts}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|Scripts| '|postTran|) '|postScripts|))

@

\defun{postScripts}{postScripts}
\calls{postScripts}{getScriptName}
\calls{postScripts}{postTranScripts}
<<defun postScripts>>=
(defun |postScripts| (arg)
 (cons (|getScriptName| (second arg) (third arg) 0)
       (|postTranScripts| (third arg))))

@

\defplist{;}{postSemiColon}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|;| '|postTran|) '|postSemiColon|))

@

\defun{postSemiColon}{postSemiColon}
\calls{postSemiColon}{postBlock}
\calls{postSemiColon}{postFlattenLeft}
<<defun postSemiColon>>=
(defun |postSemiColon| (u)
 (|postBlock| (cons '|Block| (|postFlattenLeft| u '|;|))))

@


\defplist{Signature}{postSignature}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|Signature| '|postTran|) '|postSignature|))

@

\defun{postSignature}{postSignature}
\calls{postSignature}{pairp}
\calls{postSignature}{postType}
\calls{postSignature}{removeSuperfluousMapping}
\calls{postSignature}{killColons}
<<defun postSignature>>=
(defun |postSignature| (arg)
 (let (sig sig1 op)
  (setq op (second arg))
  (setq sig (third arg))
  (when (and (pairp sig) (eq (qcar sig) '->))
    (setq sig1 (|postType| sig))
    (setq op (|postAtom| (if (stringp op) (setq op (intern op)) op)))
    (cons 'signature 
     (cons op (|removeSuperfluousMapping| (|killColons| sig1)))))))

@

\defplist{/}{postSlash}
<<postvars>>=
(eval-when (eval load)
 (setf (get '/ '|postTran|) '|postSlash|))

@

\defun{postSlash}{postSlash}
\calls{postSlash}{postTran}
<<defun postSlash>>=
(defun |postSlash| (arg)
  (if (stringp (second arg))
   (|postTran| (list '|Reduce| (intern (second arg)) (third arg) ))
   (list '/ (|postTran| (second arg)) (|postTran| (third arg)))))

@

\defplist{@Tuple}{postTuple}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|@Tuple| '|postTran|) '|postTuple|))

@

\defun{postTuple}{postTuple}
\calls{postTuple}{postTranList}
<<defun postTuple>>=
(defun |postTuple| (arg)
 (cond
  ((and (pairp arg) (eq (qcdr arg) nil) (eq (qcar arg) '|@Tuple|))
   arg)
  ((and (pairp arg) (eq (qcar arg) '|@Tuple|) (pairp (qcdr arg)))
   (cons '|@Tuple| (|postTranList| (cdr arg))))))

@

\defplist{TupleCollect}{postTupleCollect}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|TupleCollect| '|postTran|) '|postTupleCollect|))

@

\defun{postTupleCollect}{postTupleCollect}
\calls{postTupleCollect}{postCollect}
<<defun postTupleCollect>>=
(defun |postTupleCollect| (arg)
 (let (constructOp tmp1 x m)
  (setq constructOp (car arg))
  (setq tmp1 (reverse (cdr arg)))
  (setq x (car tmp1))
  (setq m (nreverse (cdr tmp1)))
  (|postCollect| (cons constructOp (append m (list (list '|construct| x)))))))

@

\defplist{where}{postWhere}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|where| '|postTran|) '|postWhere|))

@

\defun{postWhere}{postWhere}
\calls{postWhere}{postTran}
\calls{postWhere}{postTranList}
<<defun postWhere>>=
(defun |postWhere| (arg)
 (let (b x)
  (setq b (third arg))
  (setq x (if (and (pairp b) (eq (qcar b) '|Block|)) (qcdr b) (list b)))
  (cons '|where| (cons (|postTran| (second arg)) (|postTranList| x)))))

@

\defplist{with}{postWith}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|with| '|postTran|) '|postWith|))

@

\defun{postWith}{postWith}
\calls{postWith}{postTran}
\usesdollar{postWith}{insidePostCategoryIfTrue}
<<defun postWith>>=
(defun |postWith| (arg)
 (let (|$insidePostCategoryIfTrue| a)
 (declare (special |$insidePostCategoryIfTrue|))
  (setq |$insidePostCategoryIfTrue| t)
  (setq a (|postTran| (second arg)))
  (cond
   ((and (pairp a) (member (qcar a) '(signature attribute if)))
     (list 'category a))
   ((and (pairp a) (eq (qcar a) 'progn))
     (cons 'category (qcdr a)))
   (t a))))

@


\section{Support routines}
\defun{setDefOp}{setDefOp}
\usesdollar{setDefOp}{defOp}
\usesdollar{setDefOp}{topOp}
<<defun setDefOp>>=
(defun |setDefOp| (f)
 (let (tmp1)
  (declare (special |$defOp| |$topOp|))
  (when (and (pairp f) (eq (qcar f) '|:|)
             (pairp (setq tmp1 (qcdr f))))
    (setq f (qcar tmp1)))
  (unless (atom f) (setq f (car f)))
  (if |$topOp| 
   (setq |$defOp| f)
   (setq |$topOp| f))))

@

\defun{aplTran}{aplTran}
\calls{aplTran}{aplTran1}
\calls{aplTran}{containsBang}
\usesdollar{aplTran}{genno}
\usesdollar{aplTran}{boot}
<<defun aplTran>>=
(defun |aplTran| (x)
 (let ($genno u)
 (declare (special $genno $boot))
  (cond
   ($boot x)
   (t
    (setq $genno 0)
    (setq u (|aplTran1| x))
    (cond
     ((|containsBang| u) (|throwKeyedMsg| 's2ip0002 nil))
     (t u))))))

@

\defun{aplTran1}{aplTran1}
\calls{aplTran1}{aplTranList}
\calls{aplTran1}{aplTran1}
\calls{aplTran1}{hasAplExtension}
\calls{aplTran1}{nreverse0}
\calls{aplTran1}{}
\usesdollar{aplTran1}{boot}
<<defun aplTran1>>=
(defun |aplTran1| (x)
 (let (op argl1 argl f y opprime yprime tmp1 arglAssoc futureArgl g)
 (declare (special $boot))
  (if (atom x)
   x
   (progn
    (setq op (car x))
    (setq argl1 (cdr x))
    (setq argl (|aplTranList| argl1))
    (cond
     ((eq op '!)
      (cond
       ((and (pairp argl)
             (progn
              (setq f (qcar argl))
              (setq tmp1 (qcdr argl))
              (and (pairp tmp1)
                   (eq (qcdr tmp1) nil)
                   (progn
                    (setq y (qcar tmp1))
                    t))))
         (cond
          ((and (pairp y)
                (progn
                 (setq opprime (qcar y))
                 (setq yprime (qcdr y))
                 t)
                (eq opprime '!))
            (|aplTran1| (cons op (cons op (cons f yprime)))))
          ($boot 
           (cons 'collect
            (cons
             (list 'in (setq g (genvar)) (|aplTran1| y))
              (list (list f g ) ))))
          (t
           (list '|map| f (|aplTran1| y) ))))
       (t x)))
     ((progn
       (setq tmp1 (|hasAplExtension| argl))
       (and (pairp tmp1)
            (progn
             (setq arglAssoc (qcar tmp1))
             (setq futureArgl (qcdr tmp1))
             t)))
       (cons '|reshape|
        (cons
         (cons 'collect
          (append
           (do ((tmp3 arglAssoc (cdr tmp3)) (tmp4 nil))
               ((or (atom tmp3)
                    (progn (setq tmp4 (car tmp3)) nil)
                    (progn
                      (setq g (car tmp4))
                      (setq a (cdr tmp4))
                      nil))
                   (nreverse0 tmp2))
              (push (list 'in g (list '|ravel| a))) tmp2))
          (list (|aplTran1| (cons op futureArgl)))))
         (list (cdar arglAssoc))))
     (t (cons op argl)))))))

@

\defun{aplTranList}{aplTranList}
\calls{aplTranList}{aplTran1}
\calls{aplTranList}{aplTranList}
<<defun aplTranList>>=
(defun |aplTranList| (x)
 (if (atom x) 
  x
  (cons (|aplTran1| (car x)) (|aplTranList| (cdr x)))))

@

\defun{hasAplExtension}{hasAplExtension}
\calls{hasAplExtension}{nreverse0}
\calls{hasAplExtension}{deepestExpression}
\calls{hasAplExtension}{genvar}
\calls{hasAplExtension}{aplTran1}
\calls{hasAplExtension}{msubst}
<<defun hasAplExtension>>=
(defun |hasAplExtension| (argl)
 (let (tmp2 tmp3 y z g arglAssoc u)
  (when
   (dolist (x argl tmp2)
      (setq tmp2 (or tmp2 (and (pairp x) (eq (qcar x) '!)))))
    (setq u
     (dolist (x argl (nreverse0 tmp3))
      (push
        (if (and (pairp x) (eq (qcar x) '!)
                 (pairp (qcdr x)) (eq (qcdr (qcdr x)) nil))
         (progn
           (setq y (qcar (qcdr x)))
           (setq z (|deepestExpression| y))
           (setq arglAssoc
            (cons (cons (setq g (genvar)) (|aplTran1| z)) arglAssoc))
           (msubst g z y))
          x)
         tmp3)))
    (cons arglAssoc u))))

@

\defun{deepestExpression}{deepestExpression}
\calls{deepestExpression}{deepestExpression}
<<defun deepestExpression>>=
(defun |deepestExpression| (x)
 (if (and (pairp x) (eq (qcar x) '!)
          (pairp (qcdr x)) (eq (qcdr (qcdr x)) nil))
   (|deepestExpression| (qcar (qcdr x)))
   x))

@

\defun{containsBang}{containsBang}
\calls{containsBang}{containsBang}
<<defun containsBang>>=
(defun |containsBang| (u)
 (let (tmp2)
  (cond
   ((atom u) (eq u '!))
   ((and (pairp u) (equal (qcar u) 'quote)
         (pairp (qcdr u)) (eq (qcdr (qcdr u)) nil))
     nil)
   (t
     (dolist (x u tmp2)
       (setq tmp2 (or tmp2 (|containsBang| x))))))))

@

\defun{getScriptName}{getScriptName}
\calls{getScriptName}{identp}
\calls{getScriptName}{postError}
\calls{getScriptName}{internl}
\calls{getScriptName}{stringimage}
\calls{getScriptName}{decodeScripts}
\calls{getScriptName}{pname}
<<defun getScriptName>>=
(defun |getScriptName| (op a numberOfFunctionalArgs)
 (when (null (identp op))
   (|postError| (list "   " op " cannot have scripts" )))
 (internl '* (stringimage numberOfFunctionalArgs)
             (|decodeScripts| a) (pname op)))

@

\defun{decodeScripts}{decodeScripts}
\calls{decodeScripts}{qcar}
\calls{decodeScripts}{qcdr}
\calls{decodeScripts}{strconc}
\calls{decodeScripts}{stringimage}
\calls{decodeScripts}{decodeScripts}
<<defun decodeScripts>>=
(defun |decodeScripts| (a)
 (labels (
  (fn (a)
   (let ((tmp1 0))
    (if (and (pairp a) (eq (qcar a) '|,|))
     (dolist (x (qcdr a) tmp1) (setq tmp1 (+ tmp1 (fn x))))
     1))))
  (cond
   ((and (pairp a) (eq (qcar a) '|PrefixSC|)
         (pairp (qcdr a)) (eq (qcdr (qcdr a)) nil))
    (strconc (stringimage 0) (|decodeScripts| (qcar (qcdr a)))))
   ((and (pairp a) (eq (qcar a) '|;|))
    (apply 'strconc (loop for x in (qcdr a) collect (|decodeScripts| x))))
   ((and (pairp a) (eq (qcar a) '|,|))
    (stringimage (fn a)))
   (t
    (stringimage 1)))))

@


\chapter{DEF forms}

\defun{def}{def}
\calls{def}{deftran}
\calls{def}{def-insert-let}
\calls{def}{def-stringtoquote}
\calls{def}{bootTransform}
\calls{def}{comp}
\calls{def}{sublis}
\usesdollar{def}{body}
\usesdollar{def}{opassoc}
\usesdollar{def}{op}
<<defun def>>=
(defun def (form signature $body)
 (declare (ignore signature))
 (let* ($opassoc
        ($op (first form))
        (argl (rest form))
        ($body (deftran $body))
        (argl (def-insert-let argl))
        (arglp (def-stringtoquote argl))
        ($body (|bootTransform| $body)))
  (declare (special $body $opassoc $op))
  (comp (sublis $opassoc (list (list $op (list 'lam arglp $body)))))))

@

\defun{def-process}{def-process}
\calls{def-process}{def}
\calls{def-process}{b-mdef}
\calls{def-process}{eqcar}
\calls{def-process}{def-process}
\calls{def-process}{is-console}
\calls{def-process}{say}
\calls{def-process}{deftran}
\calls{def-process}{print-full}
\calls{def-process}{deftran}
\usesdollar{def-process}{macroassoc}
<<defun def-process>>=
(defun def-process (x &aux $macroassoc)
 (cond
  ((eqcar x 'def)
   (def (second x) (third x) (first (cddddr x))))
  ((eqcar x 'mdef)
   (b-mdef (second x) (third x) (first (cddddr x))))
  ((and (eqcar x 'where) (eqcar (second x) 'def))
   (let* ((u (second x)) (y (cdr u)))
    (def-process
     (list 'def
      (car y)
      (car (setq y (cdr y)))
      (car (setq y (cdr y)))
      (cons 'where (cons (car (setq y (cdr y))) (cddr x)))))))
  ((is-console *standard-output*)
   (say "  VALUE = " (eval (deftran x))))
  ((print-full (deftran x)))))

@

\defun{def-rename}{def-rename}
\calls{def-rename}{def-rename1}
<<defun def-rename>>=
(defun def-rename (x)
 (def-rename1 x))

@

\defun{def-rename1}{def-rename1}
\calls{def-rename1}{def-rename1}
<<defun def-rename1>>=
(defun def-rename1 (x)
 (cond
  ((symbolp x)
   (let ((y (get x 'rename))) (if y (first y) x)))
  ((and (listp x) x)
   (if (eqcar x 'quote)
       x
       (cons (def-rename1 (first x)) (def-rename1 (cdr x)))))
  (x)))

@

\defun{def-insert-let}{def-insert-let}
\calls{def-insert-let}{def-insert-let}
\calls{def-insert-let}{deftran}
\calls{def-insert-let}{def-let}
\calls{def-insert-let}{errhuh}
<<defun def-insert-let>>=
(defun def-insert-let (x)
 (labels (
  (insert-let1 (y)
   (declare (special $body))
    (if (and (consp y) (eq (qcar y) 'spadlet))
     (cond 
      ((identp (second y))
       (setq $body (cons 'progn (list (def-let (third y) (second y)) $body)))
       (setq y (second y)))
      ((identp (third y))
       (setq $body (cons 'progn (list (deftran y) $body))) (setq y (third y)))
      ((errhuh)))
     y)))
 (if (atom x) 
  x
  (cons (insert-let1 (first x)) (def-insert-let (cdr x))))))

@

\defun{defLET}{defLET}
\calls{defLET}{defLET1}
\usesdollar{defLET}{letGenVarCounter}
\usesdollar{defLET}{inDefLET}
<<defun defLET>>=
(defun |defLET| (lhs rhs)
 (let (|$letGenVarCounter| |$inDefLET|)
 (declare (special |$letGenVarCounter| |$inDefLET|))
  (setq |$letGenVarCounter| 1)
  (setq |$inDefLET| t)
  (|defLET1| lhs rhs)))

@

\defun{defLET1}{defLET1}
\calls{defLET1}{identp}
\calls{defLET1}{defLetForm}
\calls{defLET1}{contained}
\calls{defLET1}{defLET2}
\calls{defLET1}{mkprogn}
\calls{defLET1}{defLET1}
\calls{defLET1}{strconc}
\calls{defLET1}{stringimage}
\usesdollar{defLET1}{let}
\usesdollar{defLET1}{letGenVarCounter}
<<defun defLET1>>=
(defun |defLET1| (lhs rhs)
 (let (name l1 l2 g rhsprime letprime)
 (declare (special $let |$letGenVarCounter|))
  (cond
   ((identp lhs) (|defLetForm| lhs rhs))
   ((and (pairp lhs) (eq (qcar lhs) 'fluid)
         (pairp (qcdr lhs)) (eq (qcdr (qcdr lhs)) nil))
     (|defLetForm| lhs rhs))
   ((and (identp rhs) (null (contained rhs lhs)))
    (setq rhsprime (|defLET2| lhs rhs))
    (cond
     ((and (consp rhsprime) (eql (qcar rhsprime) $let))
       (mkprogn (list rhsprime rhs)))
     ((and (consp rhsprime) (eq (qcar rhsprime) 'progn))
      (append rhsprime (list rhs)))
     (t
      (when (identp (car rhsprime)) (setq rhsprime (list rhsprime)))
      (mkprogn (append rhsprime (list rhs))))))
   ((and (pairp rhs) (eqcar rhs $let) (identp (setq name (cadr rhs))))
     (setq l1 (|defLET1| name (third rhs)))
     (setq l2 (|defLET1| lhs name))
     (if (and (consp l2) (eq (qcar l2) 'progn))
      (mkprogn (cons l1 (cdr l2)))
      (progn
        (when (identp (car l2)) (setq l2 (list l2)))
        (mkprogn (cons l1 (append l2 (list name)))))))
   (t
    (setq g (intern (strconc "LETTMP#" (stringimage |$letGenVarCounter|))))
    (setq |$letGenVarCounter| (1+ |$letGenVarCounter|))
    (setq rhsprime (list $let g rhs))
    (setq letprime (|defLET1| lhs g))
    (if (and (consp letprime) (eq (qcar letprime) 'progn))
     (mkprogn (cons rhsprime (cdr letprime)))
     (progn
      (when (identp (car letprime)) (setq letprime (list letprime)))
      (mkprogn (cons rhsprime (append letprime (list g))))))))))


@

\defun{defLET2}{defLET2}
\calls{defLET2}{identp}
\calls{defLET2}{defLetForm}
\calls{defLET2}{qcar}
\calls{defLET2}{qcdr}
\calls{defLET2}{defLET2}
\calls{defLET2}{addCARorCDR}
\calls{defLET2}{defISReverse}
\calls{defLET2}{strconc}
\calls{defLET2}{stringimage}
\calls{defLET2}{defIS1}
\calls{defLET2}{defIS}
\usesdollar{defLET2}{inDefIS}
\usesdollar{defLET2}{let}
\usesdollar{defLET2}{letGenVarCounter}
<<defun defLET2>>=
(defun |defLET2| (lhs rhs)
 (let (a b l1 var2 patrev rev g l2 val1 var1 isPred)
 (declare (special |$inDefIS| $let |$letGenVarCounter|))
  (cond
   ((identp lhs) (|defLetForm| lhs rhs))
   ((null lhs) nil)
   ((and (pairp lhs) (eq (qcar lhs) 'fluid)
         (pairp (qcdr lhs)) (eq (qcdr (qcdr lhs)) nil))
     (|defLetForm| lhs rhs))
   ((and (pairp lhs) (equal (qcar lhs) $let)
         (pairp (qcdr lhs)) (pairp (qcdr (qcdr lhs))) 
         (eq (qcdr (qcdr (qcdr lhs))) nil))
     (setq a (|defLET2| (qcar (qcdr lhs)) rhs))
     (setq b (qcar (qcdr (qcdr lhs))))
     (cond
      ((null (setq b (|defLET2| b rhs))) a)
      ((atom b) (list a b))
      ((pairp (qcar b)) (cons a b))
      (t (list a b))))
   ((and (pairp lhs) (eq (qcar lhs) 'cons)
         (pairp (qcdr lhs)) (pairp (qcdr (qcdr lhs)))
         (eq (qcdr (qcdr (qcdr lhs))) nil))
     (setq var1 (qcar (qcdr lhs)))
     (setq var2 (qcar (qcdr (qcdr lhs))))
     (if (or (eq var1 (intern "." "BOOT"))
         (and (pairp var1) (eqcar var1 'quote)))
      (|defLET2| var2 (|addCARorCDR| 'cdr rhs))
      (progn
       (setq l1 (|defLET2| var1 (|addCARorCDR| 'car rhs)))
       (if (member var2 '(nil |.|)) 
        l1
        (progn
         (when (and (pairp l1) (atom (car l1))) (setq l1 (cons l1 nil)))
         (if (identp var2)
          (append l1 (cons (|defLetForm| var2 (|addCARorCDR| 'cdr rhs)) nil))
          (progn
           (setq l2 (|defLET2| var2 (|addCARorCDR| 'cdr rhs)))
           (when (and (pairp l2) (atom (car l2))) (setq l2 (cons l2 nil)))
           (append l1 l2))))))))
   ((and (pairp lhs) (eq (qcar lhs) 'append)
         (pairp (qcdr lhs)) (pairp (qcdr (qcdr lhs)))
         (eq (qcdr (qcdr (qcdr lhs))) nil))
     (setq var1 (qcar (qcdr lhs)))
     (setq var2 (qcar (qcdr (qcdr lhs))))
     (setq patrev (|defISReverse| var2 var1))
     (setq rev (list 'reverse rhs))
     (setq g (intern (strconc "LETTMP#" (stringimage |$letGenVarCounter|))))
     (setq |$letGenVarCounter| (1+ |$letGenVarCounter|))
     (setq l2 (|defLET2| patrev g))
     (when (and (pairp l2) (atom (car l2))) (setq l2 (cons l2 nil)))
     (cond
      ((eq var1 (intern "." "BOOT"))
       (cons (list $LET g rev) l2))
      ((and (pairp (|last| l2)) (equal (qcar (|last| l2)) $let)
            (pairp (qcdr (|last| l2)))
            (equal (qcar (qcdr (|last| l2))) var1)
            (pairp (qcdr (qcdr (|last| l2))))
            (eq (qcdr (qcdr (qcdr (|last| l2)))) nil))
        (setq val1 (qcar (qcdr (qcdr (|last| l2)))))
        (cons
         (list $let g rev)
         (append 
          (reverse (cdr (reverse l2)))
          (list (|defLetForm| var1 (list 'nreverse val1))))))
      (t
       (cons
        (list $let g rev)
        (append l2 (list (|defLetForm| var1 (list 'nreverse var1))))))))
   ((and (pairp lhs) (eq (qcar lhs) 'equal)
         (pairp (qcdr lhs)) (eq (qcdr (qcdr lhs)) nil))
     (setq var1 (qcar (qcdr lhs)))
     (list 'cond (list (list 'equal var1 rhs) var1)))
   (t
    (setq isPred
     (if |$inDefIS| 
      (|defIS1| rhs lhs)
      (|defIS| rhs lhs)))
    (list 'cond (list isPred rhs))))))

@

\defun{defLetForm}{defLetForm}
\usesdollar{defLetForm}{let}
<<defun defLetForm>>=
(defun |defLetForm| (lhs rhs)
 (declare (special $let))
 (list $let lhs rhs))

@

\defdollar{defstack}
<<initvars>>=
(defparameter $defstack nil)

@

\defun{def-whereclauselist}{def-whereclauselist}
\calls{def-whereclauselist}{def-whereclause}
\calls{def-whereclauselist}{deftran}
<<defun def-whereclauselist>>=
(defun def-whereclauselist (l)
 (if (not (cdr l))
  (def-whereclause (deftran (first l)))
  (reduce #'append (mapcar #'(lambda (u) (def-whereclause (deftran u))) l))))

@

\defun{def-whereclause}{def-whereclause}
\calls{def-whereclause}{eqcar}
\calls{def-whereclause}{def-whereclause}
\calls{def-whereclause}{whdef}
<<defun def-whereclause>>=
(defun def-whereclause (x)
 (cond 
  ((or (eqcar x 'seq) (eqcar x 'progn))
   (reduce #'append (mapcar #'def-whereclause (cdr x))))
  ((eqcar x 'def)
   (whdef (second x) (first (cddddr x))) nil)
  ((and (eqcar x '|exit|) (eqcar (second x) 'def))
   (whdef (cadadr x) (first (cddddr (second x)) )) nil)
  ((list x))))

@

\defun{def-message}{def-message}
\calls{def-message}{def-message1}
<<defun def-message>>=
(defun def-message (u)
 (cons (first u) (mapcar #'def-message1 (cdr u))))

@

\defun{def-message1}{def-message1}
\calls{def-message1}{eqcar}
\calls{def-message1}{def-message1}
\calls{def-message1}{deftran}
<<defun def-message1>>=
(defun def-message1 (v)
 (cond
  ((and (stringp v) (> (size v) 0) (not (eq (elt v 0) '\%)))
   (list 'makestring v))
  ((eqcar v 'cons)
   (list 'cons (def-message1 (second v)) (def-message1 (third v))))
  ((deftran v))))

@

\defun{def-in2on}{def-in2on}
\calls{def-in2on}{eqcar}
<<defun def-in2on>>=
(defun def-in2on (it)
 (mapcar 
  #'(lambda (x) (let (u)
     (cond
      ((and (eqcar x 'in) (eqcar (third x) '|tails|))
       (list 'on (second x) (second (third x))))
      ((and (eqcar x 'in) (eqcar (setq u (third x)) 'segment))
       (cond
        ((third u) (list 'step (second x) (second u) 1 (third u)))
        ((list 'step (second x) (second u) 1))))
      ((and (eqcar x 'inby) (eqcar (setq u (third x)) 'segment))
       (cond
        ((third u) (list 'step (second x) (second u) (|last| x) (third u)))
        ((list 'step (second x) (second u) (|last| x)))))
      (x))))
    it))

@

\defun{def-cond}{def-cond}
\calls{def-cond}{deftran}
\calls{def-cond}{def-cond}
<<defun def-cond>>=
(defun def-cond (l)
 (cond
  ((not l) nil)
  ((cons (mapcar #'deftran (first l)) (def-cond (cdr l))))))

@

\defdollar{is-spill}
<<initvars>>=
(defvar $is-spill nil)

@

\defdollar{is-spill-list}
<<initvars>>=
(defvar $is-spill-list nil)

@

\defun{def-is-eqlist}{def-is-eqlist}
\calls{def-is-eqlist}{}
\usesdollar{def-is-eqlist}{is-eqlist}
\usesdollar{def-is-eqlist}{is-spill-list}
<<defun def-is-eqlist>>=
(defun def-is-eqlist (str)
 (let (g e)
  (declare (special $is-eqlist $is-spill-list))
  (cond
   ((not str) (push `(eq ,(setq g (is-gensym)) nil) $is-eqlist) g)
   ((eq str '\.) (is-gensym))
   ((identp str) str)
   ((stringp str)
     (setq e (def-string str))
     (push (list (if (atom (second e)) 'eq 'equal)
                 (setq g (is-gensym)) e)
        $is-eqlist)
     g)
   ((or (numberp str) (member str '((|Zero|) (|One|))))
    (push (list 'eq (setq g (is-gensym)) str) $is-eqlist)
    g)
   ((atom str) (errhuh))
   ((eqcar str 'spadlet)
    (cond
     ((identp (second str))
      (push (def-is2 (second str) (third str)) $is-spill-list)
      (second str))
     ((identp (third str))
       (push (deftran str) $is-spill-list) (third str))
     ((errhuh))))
   ((eqcar str 'quote)
    (push (list (cond ((atom (second str)) 'eq) ('equal))
                (setq g (is-gensym)) str) 
          $is-eqlist) 
     g)
   ((eqcar str 'list) (def-is-eqlist (list2cons str)))
   ((or (eqcar str 'cons) (eqcar str 'vcons))
     (cons (def-is-eqlist (second str)) (def-is-eqlist (third str))))
   ((eqcar str 'append)
     (unless (identp (second str)) (error "CANT!"))
     (push (def-is2 (list 'reverse (setq g (is-gensym)))
                    (def-is-rev (third str) (second str)))
       $is-eqlist)
     (cond ((eq (second str) '\.) ''t)
      ((push (subst (second str) 'l '(or (setq l (nreverse l)) t))
         $is-spill-list)))
     g)
   ((errhuh)))))

@

\defdollar{vl}
<<initvars>>=
(defparameter $vl nil)

@

\defun{def-is-remdup}{def-is-remdup}
\calls{def-is-remdup}{def-is-remdup1}
\usesdollar{def-is-remdup}{vl}
<<defun def-is-remdup>>=
(defun def-is-remdup (x)
 (let ($vl)
  (def-is-remdup1 x)))

@

\defun{def-is-remdup1}{def-is-remdup1}
\calls{def-is-remdup1}{is-gensym}
\calls{def-is-remdup1}{eqcar}
\calls{def-is-remdup1}{def-is-remdup1}
\calls{def-is-remdup1}{errhuh}
\usesdollar{def-is-remdup1}{vl}
\usesdollar{def-is-remdup1}{is-eqlist}
<<defun def-is-remdup1>>=
(defun def-is-remdup1 (x)
 (let (rhs lhs g)
 (declare (special $vl $is-eqlist))
  (cond
   ((not x) nil)
   ((eq x '\.) x)
   ((identp x)
    (cond
     ((member x $vl)
      (push (list 'equal (setq g (is-gensym)) x) $is-eqlist)
      g)
     ((push x $vl)
      x)))
   ((member x '((|Zero|) (|One|))) x)
   ((atom x) x)
   ((eqcar x 'spadlet)
     (setq rhs (def-is-remdup1 (third x)))
     (setq lhs (def-is-remdup1 (second x)))
     (list 'spadlet lhs rhs))
   ((eqcar x 'let)
     (setq rhs (def-is-remdup1 (third x)))
     (setq lhs (def-is-remdup1 (second x)))
     (list 'let lhs rhs))
   ((eqcar x 'quote) x)
   ((and (eqcar x 'equal) (not (cddr x)))
     (push (list 'equal (setq g (is-gensym)) (second x)) $is-eqlist)
     g)
   ((member (first x) '(list append cons vcons))
    (cons
     (cond ((eq (first x) 'vcons) 'cons) ( (first x)))
     (mapcar #'def-is-remdup1 (cdr x))))
   ((errhuh)))))

@

\defun{addCARorCDR}{addCARorCDR}
\calls{addCARorCDR}{eqcar}
\calls{addCARorCDR}{qcdr}
\calls{addCARorCDR}{qcar}
<<defun addCARorCDR>>=
(defun |addCARorCDR| (acc expr)
 (let (funs p funsA funsR)
  (cond
   ((null (pairp expr)) (list acc expr))
   ((and (eq acc 'car) (eqcar expr 'reverse)) (cons '|last| (qcdr expr)))
   (t
    (setq funs
     '(car cdr caar cdar cadr cddr caaar cadar caadr caddr
       cdaar cddar cdadr cdddr))
    (setq p (position (qcar expr) funs))
    (if (null p)
     (list acc expr)
     (progn
      (setq funsA
       '(caar cadr caaar cadar caadr caddr caaaar caadar caaadr caaddr
         cadaar caddar cadadr cadddr))
      (setq funsR
       '(cdar cddr cdaar cddar cdadr cdddr cdaaar cdadar cdaadr cdaddr
         cddaar cdddar cddadr cddddr))
      (if (eq acc 'car)
       (cons (elt funsA p) (qcdr expr))
       (cons (elt funsR p) (qcdr expr)))))))))

@

<<initvars>>=
(defparameter $IS-GENSYMLIST nil)

@

<<initvars>>=
(defparameter Initial-Gensym (list (gensym)))

@

\defdollar{is-eqlist}
<<initvars>>=
(defparameter $is-eqlist nil)

@

\defun{defIS}{defIS}
\calls{defIS}{deftran}
\calls{defIS}{defIS1}
\usesdollar{defIS}{isGenVarCounter}
\usesdollar{defIS}{inDefIS}
<<defun defIS>>=
(defun |defIS| (lhs rhs)
 (let (|$isGenVarCounter| |$inDefIS|)
 (declare (special |$isGenVarCounter| |$inDefIS|))
  (setq |$isGenVarCounter| 1)
  (setq |$inDefIS| t)
  (|defIS1| (deftran lhs) rhs)))

@

\defun{defIS1}{defIS1}
\calls{defIS1}{defLetForm}
\calls{defIS1}{defLET1}
\calls{defIS1}{defLET}
\calls{defIS1}{defIS1}
\calls{defIS1}{mkprogn}
\calls{defIS1}{strconc}
\calls{defIS1}{stringimage}
\calls{defIS1}{qcar}
\calls{defIS1}{qcdr}
\calls{defIS1}{defISReverse}
\calls{defIS1}{say}
\calls{defIS1}{def-is}
\usesdollar{defIS1}{let}
\usesdollar{defIS1}{isGenVarCounter}
\usesdollar{defIS1}{inDefLET}
<<defun defIS1>>=
(defun |defIS1| (lhs rhs)
 (let (d l a1 b1 c cls a b patrev g rev l2)
 (declare (special $let |$isGenVarCounter| |$inDefLET|))
 (cond
  ((null rhs) (list 'null lhs))
  ((stringp rhs) (list 'eq lhs (list 'quote (intern rhs))))
  ((numberp rhs) (list 'equal lhs rhs))
  ((atom rhs) (list 'progn (|defLetForm| rhs lhs) 't))
  ((and (pairp rhs) (eq (qcar rhs) 'quote)
        (pairp (qcdr rhs)) (eq (qcdr (qcdr rhs)) nil))
    (if (identp (qcar (qcdr rhs)))
     (list 'eq lhs rhs)
     (list 'equal lhs rhs)))
  ((and (pairp rhs) (equal (qcar rhs) $let)
         (pairp (qcdr rhs)) (pairp (qcdr (qcdr rhs)))
         (eq (qcdr (qcdr (qcdr rhs))) nil))
    (setq c (qcar (qcdr rhs)))
    (setq d (qcar (qcdr (qcdr rhs))))
    (setq l
     (if |$inDefLET|
      (|defLET1| c lhs)
      (|defLET| c lhs)))
    (list 'and (|defIS1| lhs d) (mkprogn (list l t))))
  ((and (pairp rhs) (eq (qcar rhs) 'equal)
        (pairp (qcdr rhs)) (eq (qcdr (qcdr rhs)) nil))
   (setq a (qcar (qcdr rhs)))
   (list 'equal lhs a ))
  ((pairp lhs)
   (setq g (intern (strconc "ISTMP#" (stringimage |$isGenVarCounter|))))
   (setq |$isGenVarCounter| (1+ |$isGenVarCounter|))
   (mkprogn (list (list $let g lhs) (|defIS1| g rhs))))
  ((and (pairp rhs) (eq (qcar rhs) 'cons) (pairp (qcdr rhs))
        (pairp (qcdr (qcdr rhs))) (eq (qcdr (qcdr (qcdr rhs))) nil))
    (setq a (qcar (qcdr rhs)))
    (setq b (qcar (qcdr (qcdr rhs))))
    (cond
     ((eq a (intern "." "BOOT"))
      (if (null b)
       (list 'and (list 'pairp lhs) (list 'eq (list 'qcdr lhs) nil))
       (list 'and (list 'pairp lhs) (|defIS1| (list 'qcdr lhs) b))))
     ((null b)
      (list 'and (list 'pairp lhs) 
                 (list 'eq (list 'qcdr lhs) nil)
                 (|defIS1| (list 'qcar lhs) a)))
     ((eq b (intern "." "BOOT"))
       (list 'and (list 'pairp lhs) (|defIS1| (list 'qcar lhs) a)))
     (t
      (setq a1 (|defIS1| (list 'qcar lhs) a))
      (setq b1 (|defIS1| (list 'qcdr lhs) b))
      (cond
       ((and (pairp a1) (eq (qcar a1) 'progn)
             (pairp (qcdr a1)) (pairp (qcdr (qcdr a1)))
             (eq (qcdr (qcdr (qcdr a1))) nil)
             (equal (qcar (qcdr (qcdr a1))) t)
             (pairp b1) (eq (qcar b1) 'progn))
         (setq c (qcar (qcdr a1)))
         (setq cls (qcdr b1))
         (list 'and (list 'pairp lhs) (mkprogn (cons c cls))))
       (t
        (list 'and (list 'pairp lhs) a1 b1))))))
  ((and (pairp rhs) (eq (qcar rhs) 'append) (pairp (qcdr rhs))
        (pairp (qcdr (qcdr rhs))) (eq (qcdr (qcdr (qcdr rhs))) nil))
    (setq a (qcar (qcdr rhs)))
    (setq b (qcar (qcdr (qcdr rhs))))
    (setq patrev (|defISReverse| b a))
    (setq g (intern (strconc "ISTMP#" (stringimage |$isGenVarCounter|))))
    (setq |$isGenVarCounter| (1+ |$isGenVarCounter|))
    (setq rev
     (list 'and
       (list 'pairp lhs)
       (list 'progn (list $let g  (list 'reverse lhs)) t)))
    (setq l2 (|defIS1| g patrev))
    (when  (and (pairp l2) (atom (car l2))) (setq l2 (list l2)))
    (cond
     ((eq a (intern "." "BOOT"))
      (cons 'and (cons rev l2)))
     (t
      (cons 'and
       (cons rev
        (append l2
         (list
          (list 'progn (list (|defLetForm| a (list 'nreverse a )) t)))))))))
  (t
   (say "WARNING (defIS1): possibly bad IS code being generated")
   (def-is (list lhs rhs))))))

@

\defun{def-is-rev}{def-is-rev}
\calls{def-is-rev}{def-is-rev}
\calls{def-is-rev}{errhuh}
<<defun def-is-rev>>=
(defun def-is-rev (x a)
 (let (y)
  (if (eq (first x) 'cons)
   (cond
    ((not (third x)) (list 'cons (second x) a))
    ((setq y (def-is-rev (third x) nil))
      (setf (third y) (list 'cons (second x) a))
      y))
   (errhuh))))

@

\defun{defISReverse}{defISReverse}
This reverses forms coming from APPENDs in patterns. 
It is pretty much just a translation of DEF-IS-REV
\calls{defISReverse}{defISReverse}
\calls{defISReverse}{errhuh}
<<defun defISReverse>>=
(defun |defISReverse| (x a)
 (let (y)
  (if (and (pairp x) (eq (qcar x) 'cons))
   (if (null (caddr x))
     (list 'cons (cadr x) a)
     (progn 
      (setq y (|defISReverse| (caddr x) nil))
      (rplac (caddr y) (list 'cons (cadr x) a))
      y))
   (errhuh))))

@

\defun{def-it}{def-it}
\calls{def-it}{def-in2on}
\calls{def-it}{deftran}
\calls{def-it}{reset}
\calls{def-it}{def-let}
\calls{def-it}{errhuh}
<<defun def-it>>=
(defun def-it (fn l)
 (setq l (reverse l))
 (let ((b (first l)))
  (let ((it (def-in2on (nreverse (rest l)))))
   (let ((itp
          (apply #'append
           (mapcar
             #'(lambda (x &aux op y g)
                (if (and (member (setq op (first x)) '(in on))
                         (not (atom (second x))))
                  (if (eqcar (setq y (second x)) 'spadlet)
                   (if (atom (setq g (second y)))
                    (list 
                     `(,op ,g ,(deftran (third x)))
                     `(reset ,(def-let (deftran (third y)) g)))
                    (errhuh))
                   (list
                    `(,op ,(setq g (gensym)) ,(deftran (third x)))
                    `(reset ,(def-let (deftran (second x)) g))))
                  `(,x)))
            it))))
    (cons fn (nconc itp (list b)))))))

@

\defun{def-string}{def-string}
\calls{def-string}{deftran}
\uses{def-string}{*package*}
<<defun def-string>>=
(defun def-string (x)
 ;; following patches needed to fix reader bug in Lucid Common Lisp
  (if (and (> (size x) 0) (or (char= (elt x 0) #\.) (char= (elt x 0) #\Page)))
   `(intern ,X ,(package-name *package*))
   `(quote ,(deftran (intern x)))))

@

\defun{def-stringtoquote}{def-stringtoquote}
\calls{def-stringtoquote}{def-addlet}
\calls{def-stringtoquote}{def-stringtoquote}
<<defun def-stringtoquote>>=
(defun def-stringtoquote (x)
 (cond
  ((stringp x) (list 'quote (intern x)))
  ((atom x) x)
  ((cons (def-addlet (first x)) (def-stringtoquote (cdr x))))))

@

\defun{def-addlet}{def-addlet}
\calls{def-addlet}{mkprogn}
\calls{def-addlet}{def-let}
\calls{def-addlet}{compfluidize}
\usesdollar{def-addlet}{body}
<<defun def-addlet>>=
(defun def-addlet (x)
 (declare (special $body))
 (if (atom x)
  (if (stringp x) `(quote ,(intern x))  x)
  (let ((g (gensym)))
   (setq $body (mkprogn (list (def-let (compfluidize x) g) $body)))
   g)))

@

\defun{def-inner}{def-inner}
\calls{def-inner}{def-insert-let}
\calls{def-inner}{def-stringtoquote}
\calls{def-inner}{sublis}
\calls{def-inner}{comp}
\usesdollar{def-inner}{body}
\usesdollar{def-inner}{OpAssoc}
\usesdollar{def-inner}{op}
<<defun def-inner>>=
(defun def-inner (form signature $body)
  "Same as DEF but assumes body has already been DEFTRANned"
 (declare (special $body) (ignore signature))
 (let ($OpAssoc ($op (first form)) (argl (rest form)))
 (declare (special $OpAssoc $op))
   (let* ((argl (def-insert-let argl))
          (arglp (def-stringtoquote argl)))
    (comp (sublis $opassoc `((,$op (lam ,arglp ,$body))))))))

@

\defun{hackforis}{hackforis}
\calls{hackforis}{hackforis1}
<<defun hackforis>>=
(defun hackforis (l) (mapcar #'hackforis1 L))

@

\defun{hackforis1}{hackforis1}
\calls{hackforis1}{kar}
\calls{hackforis1}{eqcar}
<<defun hackforis1>>=
(defun hackforis1 (x)
 (if (and (member (kar x) '(in on)) (eqcar (second x) 'is))
  (cons (first x) (cons (cons 'spadlet (cdadr x)) (cddr x)))
  x))

@

\defun{unTuple}{unTuple}
<<defun unTuple>>=
(defun |unTuple| (x)
 (if (and (pairp x) (eq (qcar x) '|@Tuple|))
  (qcdr x)
  (list x)))

@

\defun{errhuh}{errhuh}
\calls{errhuh}{systemError}
<<defun errhuh>>=
(defun errhuh ()
 (|systemError| "problem with BOOT to LISP translation"))

@

\section{The def-tran table}
\begin{verbatim}
  |:|       |DEF-:|
  |::|      |DEF-::|
  CATEGORY  DEF-CATEGORY
  COLLECT   DEF-COLLECT
  ELT       DEF-ELT
  EQUAL     DEF-EQUAL
  |is|      DEF-IS
  |isnt|    DEF-ISNT
  LESSP     DEF-LESSP
  |<|       DEF-LESSP
  SPADLET   DEF-LET
  LET       DEF-LET
  REPEAT    DEF-REPEAT
  SEQ       DEF-SEQ
  SETELT    DEF-SETELT
  |where|   DEF-WHERE
\end{verbatim}

\defun{deftran}{deftran}
This two-level call allows DEF-RENAME to be locally bound to do
nothing (see boot2Lisp) yet still allow function call (lisp2BootAndComp).
\calls{deftran}{}
\usesdollar{deftran}{macroassoc}
<<defun deftran>>=
(defun deftran (x)
 (let (op y)
  (cond
   ((stringp x) (def-string x))
   ((identp x) (cond ((lassoc x $macroassoc)) (x)))
   ((atom x) x)
   ((eq (setq op (first x)) 'where) (def-where (cdr x)))
   ((eq op 'repeat) (def-repeat (cdr x)))
   ((eq op 'collect) (def-collect (cdr x)))
   ((eq op 'makestring)
          (cond ((stringp (second x)) x)
                ((eqcar (second x) 'quote)
                 (list 'makestring (stringimage (cadadr x))))
                ((list 'makestring (deftran (second x))))))
   ((eq op 'quote)
          (if (stringp (setq y (second x))) (list 'makestring y)
             (if (and (identp y) (char= (elt (pname y) 0) #\.))
                 `(intern ,(pname y) ,(package-name *package*)) x)))
   ((eq op 'is) (|defIS| (second x) (third x)))
   ((eq op 'spadlet) (def-let (second x) (third x)))
   ((eq op 'dcq) (list 'dcq (second x) (deftran (third x))))
   ((eq op 'cond) (cons 'cond (def-cond (cdr x))))
   ((member (first x) '(|sayBrightly| say moan croak) :test #'eq)
          (def-message x))
   ((setq y (getl (first x) 'def-tran))
          (funcall y (mapcar #'deftran (cdr x))))
   ((mapcar #'deftran x)))))

@

\defplist{def-:}{def-:}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|:| 'def-tran) '|DEF-:|))

@

\defun{def-:}{def-:}
\calls{def-:}{dcq}
<<defun def-:>>=
(defun |DEF-:| (x &aux y)
 (dcq (x y) x)
  `(spadlet
     ,(if (or (eq y '|fluid|)
              (and (identp x) (char= #\$ (elt (pname x) 0))))
       `(fluid ,x) x)
        nil))

@

\defplist{def-::}{def-::}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|::| 'def-tran) '|DEF-::|))

@

\defmacro{def-::}
<<defmacro def-::>>=
(defmacro |def-::| (x)
  (let ((expr (first x)) (type (second x)))
    (if (equal type '(|Triple|)) expr (errhuh))))

@

\defplist{category}{def-category}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'category 'def-tran) 'def-category))

@

\defun{def-category}{def-category}
\calls{def-category}{eqcar}
\calls{def-category}{kadr}
<<defun def-category>>=
(defun def-category (l)
 (let (siglist atlist)
  (mapcar #'(lambda (x)
             (if (eqcar (kadr X) 'signature)
              (push x siglist)
              (push x atlist)))
          l)
  (list 'category (mkq (nreverse siglist)) (mkq (nreverse atlist)))))

@

\defplist{collect}{def-collect}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'collect 'def-tran) 'def-collect))

@

\defun{def-collect}{def-collect}
\calls{def-collect}{def-it}
\calls{def-collect}{deftran}
\calls{def-collect}{hackforis}
<<defun def-collect>>=
(defun def-collect (l)
 (def-it 'collect (mapcar #'deftran (hackforis l))))

@

\defplist{elt}{def-elt}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'elt 'def-tran) 'def-elt))

@

\defun{def-elt}{def-elt}
<<defun def-elt>>=
(defun def-elt (args)
 (let ((expr (car args)) (sel (cadr args)) y)
  (if (and (symbolp sel) (setq y (get sel 'sel\,function)))
   (if (integerp y) 
     (list 'elt expr y)
     (list y expr))
   (list 'elt expr sel))))

@

\defplist{equal}{def-equal}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'equal 'def-tran) 'def-equal))

@

\defun{def-equal}{def-equal}
\usesdollar{def-equal}{boot}
<<defun def-equal>>=
(defun def-equal (x)
 (declare (special $boot))
 (cond
  ((not (cdr x)) (cons 'equal x))
  ((or (member '(|One|) X) (member '(|Zero|) X)
    (integerp (first x)) (integerp (second x))) (cons 'eql x))
  ((not (first x)) (list 'null (second x)))
  ((not (second x)) (list 'null (first x)))
  ($boot (cons 'boot-equal x))
  ((cons 'equal x))))
 
@

\defplist{lessp}{def-lessp}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'lessp 'def-tran) 'def-lessp))

@

\defplist{$<$}{def-lessp}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|<| 'def-tran) 'def-lessp))

@

\defun{def-lessp}{def-lessp}
<<defun def-lessp>>=
(defun def-lessp (x)
 (labels (
  (smint-able (x)
   (or (typep x 'fixnum)
       (and (pairp x)
            (member (car x) '(|One| |Zero| length \# qcsize qvsize qlength)))))
 )
 (cond
  ((null (cdr x)) (cons '< x))
  ((eq (cadr x) 0) (list 'minusp (car x)))
  ((and (smint-able (car x)) (smint-able (cadr x))) (cons 'qslessp x))
  ('t (list '> (cadr x) (car x))))))

@

\defplist{spadlet}{def-let}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'spadlet 'def-tran) 'def-let))

@

\defplist{let}{def-let}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'let 'def-tran) 'def-let))

@

\defun{def-let}{def-let}
\calls{def-let}{deftran}
\calls{def-let}{defLET}
<<defun def-let>>=
(defun def-let (form rhs)
 (let (f1 f2)
  (unless (and (consp form) (eq (qcar form) '\:))
   (setq form (macroexpand form)))
  (cond
   ((and (consp form) (eq (qcar form) '\:))
    (setq f1 (deftran form))
    (setq f2 (deftran (list 'spadlet (second form) rhs)))
    (if (and (eq (car f2) 'spadlet) (equal (second f2) (second form)))
      (list 'spadlet (second f1) (third f2))
      (list 'progn f1 f2)))
   ((and (consp form) (eq (qcar form) 'elt))
     (deftran (list 'setelt (second form) (third form) rhs)))
   (t 
     (|defLET| form (deftran rhs))))))

@

\defplist{is}{def-is}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|is| 'def-tran) 'def-is))

@

\defun{def-is}{def-is}
\calls{def-is}{def-is2}
\usesdollar{def-is}{is-gensymlist}
\uses{def-is}{Initial-Gensym}
<<defun def-is>>=
(defun def-is (x)
 (let (($is-gensymlist Initial-Gensym))
  (declare (special is-gensymlist Initial-Gensym))
  (def-is2 (first X) (second x))))

@

\defun{def-is2}{def-is2}
\calls{def-is2}{eqcar}
\calls{def-is2}{moan}
\calls{def-is2}{def-is-eqlist}
\calls{def-is2}{def-is-remdup}
\calls{def-is2}{mkpf}
\calls{def-is2}{subst}
\calls{def-is2}{dcq}
\calls{def-is2}{listofatoms}
\calls{def-is2}{/tracelet-print}
\usesdollar{def-is2}{is-eqlist}
\usesdollar{def-is2}{is-spill-list}
<<defun def-is2>>=
(defun def-is2 (form struct)
 (let ($is-eqlist $is-spill-list (form (deftran form)))
  (when (eqcar struct '|@Tuple|)
   (moan "you must use square brackets around right arg. to" '%b "is" '%d))
  (let* ((x (def-is-eqlist (def-is-remdup struct)))
         (code (if (identp x)
                     (mkpf (subst form x $is-eqlist) 'and)
                     (mkpf `((dcq ,x ,form) . ,$is-eqlist) 'and))))
   (let ((code (mkpf `(,code . ,$is-spill-list) 'and)))
    (if $traceletflag
     (let ((l (remove-if #'gensymp (listofatoms x))))
      `(prog1 ,code ,@(mapcar #'(lambda (y) `(/tracelet-print ,y ,y)) L)))
     code)))))

@

\defplist{isnt}{def-isnt}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|isnt| 'def-tran) 'def-isnt))

@

\defun{def-isnt}{def-isnt}
\calls{def-isnt}{deftran}
<<defun def-isnt>>=
(defun def-isnt (x)
 (deftran (list 'null (cons 'is x))))

@

\defplist{repeat}{def-repeat}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'repeat 'def-tran) 'def-repeat))

@

\defun{def-repeat}{def-repeat}
\calls{def-repeat}{def-it}
\calls{def-repeat}{deftran}
\calls{def-repeat}{hackforis}
<<defun def-repeat>>=
(defun def-repeat (l)
 (def-it 'repeat (mapcar #'deftran (hackforis l))))

@

\defplist{setelt}{def-setelt}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'setelt 'def-tran) 'def-setelt))

@

\defun{def-setelt}{def-setelt}
<<defun def-setelt>>=
(defun def-setelt (args)
 (let ((var (first args)) (sel (second args)) (expr (third args)))
  (let ((y (and (symbolp sel) (get sel 'sel\,function))))
   (if y
    (if (integerp y)
     (list 'setelt var y expr)
     (list 'rplac (list y var) expr))
    (list 'setelt var sel expr)))))

@

\defplist{seq}{def-seq}
<<postvars>>=
(eval-when (eval load)
 (setf (get 'seq 'def-tran) 'def-seq))

@

\defun{def-seq}{def-seq}
\calls{def-seq}{eqcar}
<<defun def-seq>>=
(defun def-seq (u)
 (labels (
  (seqoptimize (u)
   (if (and (eqcar (cadr u) 'exit) (eqcar (cadadr u) 'seq))
       (cadadr u)
       u)))
  (seqoptimize (cons 'seq u))))

@

\defplist{where}{def-where}
<<postvars>>=
(eval-when (eval load)
 (setf (get '|where| 'def-tran) 'def-where))

@

\defun{def-where}{def-where}
\calls{def-where}{def-whereclauselist}
\calls{def-where}{def-inner}
\calls{def-where}{sublis}
\calls{def-where}{mkprogn}
\calls{def-where}{deftran}
\usesdollar{def-where}{defstack}
\usesdollar{def-where}{opassoc}
<<defun def-where>>=
(defun def-where (args)
 (let ((x (car args)) (y (cdr args)) $defstack)
 (declare (special $defstack $opassoc))
  (let ((u (def-whereclauselist y)))
   (mapc #'(lambda (X) (def-inner (first x) nil (sublis $opassoc (second x))))
         $defstack)
   (mkprogn (nconc u (list (deftran x)))))))

@

\chapter{PARSE forms}
\section{The original meta specification}
This package provides routines to support the Metalanguage
translator writing system.   Metalanguage is described
in META/LISP, R.D. Jenks, Tech Report, 
IBM T.J. Watson Research Center, 1969.  
Familiarity with this document is assumed.

Note that META/LISP and the meta parser/generator were removed from Axiom.
This information is only for documentation purposes.

\begin{verbatim}
%       Scratchpad II Boot Language Grammar, Common Lisp Version
%       IBM Thomas J. Watson Research Center
%       Summer, 1986
%
%       NOTE: Substantially different from VM/LISP version, due to
%             different parser and attempt to render more within META proper.

.META(New NewExpr Process)
.PACKAGE 'BOOT'
.DECLARE(tmptok TOK ParseMode DEFINITION-NAME LABLASOC)
.PREFIX 'PARSE-'

NewExpr:        =')' .(processSynonyms) Command
              / .(SETQ DEFINITION-NAME (CURRENT-SYMBOL)) Statement ;

Command:        ')' SpecialKeyWord SpecialCommand +() ;

SpecialKeyWord: =(MATCH-CURRENT-TOKEN "IDENTIFIER)
                .(SETF (TOKEN-SYMBOL (CURRENT-TOKEN)) (unAbbreviateKeyword (CURRENT-SYMBOL))) ;

SpecialCommand: 'show' <'?' / Expression>! +(show #1) CommandTail
              / ?(MEMBER (CURRENT-SYMBOL) \$noParseCommands)
                 .(FUNCALL (CURRENT-SYMBOL))
              / ?(MEMBER (CURRENT-SYMBOL) \$tokenCommands) TokenList
                  TokenCommandTail
              / PrimaryOrQM* CommandTail ;

TokenList:      (^?(isTokenDelimiter) +=(CURRENT-SYMBOL) .(ADVANCE-TOKEN))* ;

TokenCommandTail:
                <TokenOption*>! ?(atEndOfLine) +(#2 -#1) .(systemCommand #1) ;

TokenOption:    ')' TokenList ;

CommandTail:    <Option*>! ?(atEndOfLine) +(#2 -#1) .(systemCommand #1) ;

PrimaryOrQM:    '?' +\? / Primary ;

Option:         ')' PrimaryOrQM* ;

Statement:      Expr{0} <(',' Expr{0})* +(Series #2 -#1)>;

InfixWith:      With +(Join #2 #1) ;

With:           'with' Category +(with #1) ;

Category:      'if' Expression 'then' Category <'else' Category>! +(if #3 #2 #1)
              / '(' Category <(';' Category)*>! ')' +(CATEGORY #2 -#1)
              / .(SETQ $1 (LINE-NUMBER CURRENT-LINE)) Application 
                   ( ':' Expression +(Signature #2 #1)
                             .(recordSignatureDocumentation ##1 $1)
                           / +(Attribute #1)
                             .(recordAttributeDocumentation ##1 $1));

Expression:   Expr{(PARSE-rightBindingPowerOf (MAKE-SYMBOL-OF PRIOR-TOKEN) ParseMode)}
                +#1 ;

Import:         'import' Expr{1000} <(',' Expr{1000})*>! +(import #2 -#1) ;

Infix:          =TRUE +=(CURRENT-SYMBOL) .(ADVANCE-TOKEN) <TokTail>
                Expression +(#2 #2 #1) ;

Prefix:         =TRUE +=(CURRENT-SYMBOL) .(ADVANCE-TOKEN) <TokTail>
                Expression +(#2 #1) ;

Suffix:         +=(CURRENT-SYMBOL) .(ADVANCE-TOKEN) <TokTail> +(#1 #1) ;

TokTail:        ?(AND (NULL \$BOOT) (EQ (CURRENT-SYMBOL) "\$)
                      (OR (ALPHA-CHAR-P (CURRENT-CHAR))
                          (CHAR-EQ (CURRENT-CHAR) '$')
                          (CHAR-EQ (CURRENT-CHAR) '\%')
                          (CHAR-EQ (CURRENT-CHAR) '(')))
                .(SETQ $1 (COPY-TOKEN PRIOR-TOKEN)) Qualification
                .(SETQ PRIOR-TOKEN $1) ;

Qualification:  '$' Primary1 +=(dollarTran #1 #1) ;

SemiColon:      ';' (Expr{82} / + \/throwAway) +(\; #2 #1) ;

Return:         'return' Expression +(return #1) ;

Exit:           'exit' (Expression / +\$NoValue) +(exit #1) ;

Leave:          'leave' ( Expression / +\$NoValue )
                ('from' Label +(leaveFrom #1 #1) / +(leave #1)) ;

Seg:            GliphTok{"\.\.} <Expression>! +(SEGMENT #2 #1) ;

Conditional:    'if' Expression 'then' Expression <'else' ElseClause>!
                   +(if #3 #2 #1) ;

ElseClause:     ?(EQ (CURRENT-SYMBOL) "if) Conditional / Expression ;

Loop:           Iterator* 'repeat' Expr{110} +(REPEAT -#2 #1)
              / 'repeat' Expr{110} +(REPEAT #1) ;

Iterator:       'for' Primary 'in' Expression
                ( 'by' Expr{200} +(INBY #3 #2 #1) / +(IN #2 #1) )
                < '\|' Expr{111} +(\| #1) >
              / 'while' Expr{190} +(WHILE #1)
              / 'until' Expr{190} +(UNTIL #1) ;

Expr{RBP}:      NudPart{RBP} <LedPart{RBP}>* +#1;

LabelExpr:      Label Expr{120} +(LABEL #2 #1) ;

Label:          '@<<' Name '>>' ;

LedPart{RBP}:   Operation{"Led RBP} +#1;

NudPart{RBP}:   (Operation{"Nud RBP} / Reduction / Form) +#1 ;

Operation{ParseMode RBP}:
        ^?(MATCH-CURRENT-TOKEN "IDENTIFIER)
        ?(GETL (SETQ tmptok (CURRENT-SYMBOL)) ParseMode)
        ?(LT RBP (PARSE-leftBindingPowerOf tmptok ParseMode))
        .(SETQ RBP (PARSE-rightBindingPowerOf tmptok ParseMode))
        getSemanticForm{tmptok ParseMode (ELEMN (GETL tmptok ParseMode) 5 NIL)} ;

% Binding powers stored under the Led and Red properties of an operator
% are set up by the file BOTTOMUP.LISP.  The format for a Led property
% is <Operator Left-Power Right-Power>, and the same for a Nud, except that
% it may also have a fourth component <Special-Handler>. ELEMN attempts to
% get the Nth indicator, counting from 1.

leftBindingPowerOf{X IND}: =(LET ((Y (GETL X IND))) (IF Y (ELEMN Y 3 0) 0)) ;

rightBindingPowerOf{X IND}: =(LET ((Y (GETL X IND))) (IF Y (ELEMN Y 4 105) 105)) ;

getSemanticForm{X IND Y}:
                ?(AND Y (EVAL Y)) / ?(EQ IND "Nud) Prefix / ?(EQ IND "Led) Infix ;


Reduction:      ReductionOp Expr{1000} +(Reduce #2 #1) ;

ReductionOp:    ?(AND (GETL (CURRENT-SYMBOL) "Led)
                      (MATCH-NEXT-TOKEN "SPECIAL-CHAR (CODE-CHAR 47))) % Forgive me!
                +=(CURRENT-SYMBOL) .(ADVANCE-TOKEN) .(ADVANCE-TOKEN) ;

Form:           'iterate' < 'from' Label +(#1) >! +(iterate -#1)
              / 'yield' Application +(yield #1)
              / Application ;

Application: Primary <Selector>* <Application +(#2 #1)>;

Selector: ?NONBLANK ?(EQ (CURRENT-SYMBOL) "\.) ?(CHAR-NE (CURRENT-CHAR) "\ )
                 '.' PrimaryNoFloat (=\$BOOT +(ELT #2 #1)/ +(#2 #1))
          / (Float /'.' Primary) (=\$BOOT +(ELT #2 #1)/ +(#2 #1));

PrimaryNoFloat: Primary1 <TokTail> ;

Primary: Float /PrimaryNoFloat ;

Primary1: VarForm <=(AND NONBLANK (EQ (CURRENT-SYMBOL) "\()) Primary1 +(#2 #1)>
        /Quad
        /String
        /IntegerTok
        /FormalParameter
        /='\'' (?\$BOOT Data / '\'' Expr{999} +(QUOTE #1))
        /Sequence
        /Enclosure ;

Float: FloatBase (?NONBLANK FloatExponent / +0) +=(MAKE-FLOAT #4 #2 #2 #1) ;

FloatBase: ?(FIXP (CURRENT-SYMBOL)) ?(CHAR-EQ (CURRENT-CHAR) '.')
           ?(CHAR-NE (NEXT-CHAR) '.')
              IntegerTok FloatBasePart
          /?(FIXP (CURRENT-SYMBOL)) ?(CHAR-EQ (CHAR-UPCASE (CURRENT-CHAR)) "E)
              IntegerTok +0 +0
         /?(DIGITP (CURRENT-CHAR)) ?(EQ (CURRENT-SYMBOL) "\.)
              +0 FloatBasePart ;

FloatBasePart: '.'
  (?(DIGITP (CURRENT-CHAR)) +=(TOKEN-NONBLANK (CURRENT-TOKEN)) IntegerTok
  / +0 +0);


FloatExponent: =(AND (MEMBER (CURRENT-SYMBOL) "(E e))
                     (FIND (CURRENT-CHAR) '+-'))
                 .(ADVANCE-TOKEN)
        (IntegerTok/'+' IntegerTok/'-' IntegerTok +=(MINUS #1)/+0)
       /?(IDENTP (CURRENT-SYMBOL)) =(SETQ $1 (FLOATEXPID (CURRENT-SYMBOL)))
       .(ADVANCE-TOKEN) +=$1 ;

Enclosure:      '(' ( Expr{6} ')' / ')' +(Tuple) )
              / '{' ( Expr{6} '}' +(brace (construct #1)) / '}' +(brace)) ;

IntegerTok:     NUMBER ;

FloatTok:       NUMBER +=(IF \$BOOT #1 (BFP- #1)) ;

FormalParameter: FormalParameterTok ;

FormalParameterTok: ARGUMENT-DESIGNATOR ;

Quad:           '$' +\$ / ?\$BOOT GliphTok{"\.} +\. ;

String:         SPADSTRING ;

VarForm:        Name <Scripts +(Scripts #2 #1) > +#1 ;

Scripts:        ?NONBLANK '[' ScriptItem ']' ;

ScriptItem:     Expr{90} <(';' ScriptItem)* +(\; #2 -#1)>
              / ';' ScriptItem +(PrefixSC #1) ;

Name:           IDENTIFIER +#1 ;

Data:           .(SETQ LABLASOC NIL) Sexpr +(QUOTE =(TRANSLABEL #1 LABLASOC)) ;

Sexpr:          .(ADVANCE-TOKEN) Sexpr1 ;

Sexpr1:       AnyId
              < NBGliphTok{"\=} Sexpr1
                 .(SETQ LABLASOC (CONS (CONS #2 ##1) LABLASOC))>
              / '\'' Sexpr1 +(QUOTE #1)
              / IntegerTok
              / '-' IntegerTok +=(MINUS #1)
              / String
              / '<' <Sexpr1*>! '>' +=(LIST2VEC #1)
              / '(' <Sexpr1* <GliphTok{"\.} Sexpr1 +=(NCONC #2 #1)>>! ')' ;

NBGliphTok{tok}:   ?(AND (MATCH-CURRENT-TOKEN "GLIPH tok) NONBLANK)
                    .(ADVANCE-TOKEN) ;

GliphTok{tok}:     ?(MATCH-CURRENT-TOKEN "GLIPH tok) .(ADVANCE-TOKEN) ;

AnyId:          IDENTIFIER
              / (='$' +=(CURRENT-SYMBOL) .(ADVANCE-TOKEN) / KEYWORD) ;

Sequence:       OpenBracket Sequence1 ']'
              / OpenBrace Sequence1 '}' +(brace #1) ;

Sequence1:     (Expression +(#2 #1) / +(#1)) <IteratorTail +(COLLECT -#1 #1)>  ;

OpenBracket:    =(EQ (getToken (SETQ $1 (CURRENT-SYMBOL))) "\[ )
                      (=(EQCAR $1 "elt) +(elt =(CADR $1) construct)
                        / +construct) .(ADVANCE-TOKEN) ;

OpenBrace:      =(EQ (getToken (SETQ $1 (CURRENT-SYMBOL))) "\{ )
                      (=(EQCAR $1 "elt) +(elt =(CADR $1) brace)
                        / +construct) .(ADVANCE-TOKEN) ;

IteratorTail:   ('repeat' <Iterator*>! / Iterator*) ;

.FIN ;

\end{verbatim}
\section{The PARSE code}

\defvar{tmptok}
<<initvars>>=
(defvar |tmptok| nil)

@

\defvar{tok}
<<initvars>>=
(defvar tok nil)

@

\defvar{ParseMode}
<<initvars>>=
(defvar |ParseMode| nil)

@

\defvar{definition-name}
<<initvars>>=
(defvar definition-name nil)

@

\defvar{lablasoc}
<<initvars>>=
(defvar lablasoc nil)

@
\defun{PARSE-NewExpr}{PARSE-NewExpr}
\calls{PARSE-NewExpr}{match-string}
\calls{PARSE-NewExpr}{action}
\calls{PARSE-NewExpr}{processSynonyms}
\calls{PARSE-NewExpr}{must}
\calls{PARSE-NewExpr}{current-symbol}
\calls{PARSE-NewExpr}{PARSE-Statement}
\uses{PARSE-NewExpr}{definition-name}
<<defun PARSE-NewExpr>>=
(defun |PARSE-NewExpr| ()
 (or (and (match-string ")") (action (|processSynonyms|))
          (must (|PARSE-Command|)))
     (and (action (setq definition-name (current-symbol)))
          (|PARSE-Statement|))))

@

\defun{PARSE-Command}{PARSE-Command}
\calls{PARSE-Command}{match-advance-string}
\calls{PARSE-Command}{must}
\calls{PARSE-Command}{PARSE-SpecialKeyWord}
\calls{PARSE-Command}{PARSE-SpecialCommand}
\calls{PARSE-Command}{push-reduction}
<<defun PARSE-Command>>=
(defun |PARSE-Command| ()
 (and (match-advance-string ")") (must (|PARSE-SpecialKeyWord|))
      (must (|PARSE-SpecialCommand|))
      (push-reduction '|PARSE-Command| nil)))

@

\defun{PARSE-SpecialKeyWord}{PARSE-SpecialKeyWord}
\calls{PARSE-SpecialKeyWord}{match-current-token}
\calls{PARSE-SpecialKeyWord}{action}
\calls{PARSE-SpecialKeyWord}{token-symbol}
\calls{PARSE-SpecialKeyWord}{current-token}
\calls{PARSE-SpecialKeyWord}{unAbbreviateKeyword}
\calls{PARSE-SpecialKeyWord}{current-symbol}
<<defun PARSE-SpecialKeyWord>>=
(defun |PARSE-SpecialKeyWord| ()
 (and (match-current-token 'identifier)
      (action (setf (token-symbol (current-token))
                    (|unAbbreviateKeyword| (current-symbol))))))

@

\defun{PARSE-SpecialCommand}{PARSE-SpecialCommand}
\calls{PARSE-SpecialCommand}{match-advance-string}
\calls{PARSE-SpecialCommand}{bang}
\calls{PARSE-SpecialCommand}{optional}
\calls{PARSE-SpecialCommand}{PARSE-Expression}
\calls{PARSE-SpecialCommand}{push-reduction}
\calls{PARSE-SpecialCommand}{PARSE-SpecialCommand}
\calls{PARSE-SpecialCommand}{pop-stack-1}
\calls{PARSE-SpecialCommand}{PARSE-CommandTail}
\calls{PARSE-SpecialCommand}{must}
\calls{PARSE-SpecialCommand}{current-symbol}
\calls{PARSE-SpecialCommand}{action}
\calls{PARSE-SpecialCommand}{PARSE-TokenList}
\calls{PARSE-SpecialCommand}{PARSE-TokenCommandTail}
\calls{PARSE-SpecialCommand}{star}
\calls{PARSE-SpecialCommand}{PARSE-PrimaryOrQM}
\calls{PARSE-SpecialCommand}{PARSE-CommandTail}
\usesdollar{PARSE-SpecialCommand}{noParseCommands}
\usesdollar{PARSE-SpecialCommand}{tokenCommands}
<<defun PARSE-SpecialCommand>>=
(defun |PARSE-SpecialCommand| ()
 (declare (special $noParseCommands $tokenCommands))
 (or (and (match-advance-string "show")
          (bang fil_test
                (optional
                    (or (match-advance-string "?")
                        (|PARSE-Expression|))))
          (push-reduction '|PARSE-SpecialCommand|
              (list '|show| (pop-stack-1)))
          (must (|PARSE-CommandTail|)))
     (and (member (current-symbol) |$noParseCommands|)
          (action (funcall (current-symbol))))
     (and (member (current-symbol) |$tokenCommands|)
          (|PARSE-TokenList|) (must (|PARSE-TokenCommandTail|)))
     (and (star repeator (|PARSE-PrimaryOrQM|))
          (must (|PARSE-CommandTail|)))))

@

\defun{PARSE-TokenCommandTail}{PARSE-TokenCommandTail}
\calls{PARSE-TokenCommandTail}{bang}
\calls{PARSE-TokenCommandTail}{optional}
\calls{PARSE-TokenCommandTail}{star}
\calls{PARSE-TokenCommandTail}{PARSE-TokenOption}
\calls{PARSE-TokenCommandTail}{atEndOfLine}
\calls{PARSE-TokenCommandTail}{push-reduction}
\calls{PARSE-TokenCommandTail}{PARSE-TokenCommandTail}
\calls{PARSE-TokenCommandTail}{pop-stack-2}
\calls{PARSE-TokenCommandTail}{pop-stack-1}
\calls{PARSE-TokenCommandTail}{action}
\calls{PARSE-TokenCommandTail}{systemCommand}
<<defun PARSE-TokenCommandTail>>=
(defun |PARSE-TokenCommandTail| ()
 (and (bang fil_test (optional (star repeator (|PARSE-TokenOption|))))
      (|atEndOfLine|)
      (push-reduction '|PARSE-TokenCommandTail|
          (cons (pop-stack-2) (append (pop-stack-1) nil)))
      (action (|systemCommand| (pop-stack-1)))))

@


\defun{PARSE-TokenOption}{PARSE-TokenOption}
\calls{PARSE-TokenOption}{match-advance-string}
\calls{PARSE-TokenOption}{must}
\calls{PARSE-TokenOption}{PARSE-TokenList}
<<defun PARSE-TokenOption>>=
(defun |PARSE-TokenOption| ()
 (and (match-advance-string ")") (must (|PARSE-TokenList|))))

@

\defun{PARSE-TokenList}{PARSE-TokenList}
\calls{PARSE-TokenList}{star}
\calls{PARSE-TokenList}{isTokenDelimiter}
\calls{PARSE-TokenList}{push-reduction}
\calls{PARSE-TokenList}{current-symbol}
\calls{PARSE-TokenList}{action}
\calls{PARSE-TokenList}{advance-token}
<<defun PARSE-TokenList>>=
(defun |PARSE-TokenList| ()
 (star repeator
  (and (not (|isTokenDelimiter|))
       (push-reduction '|PARSE-TokenList| (current-symbol))
       (action (advance-token)))))

@

\defun{PARSE-CommandTail}{PARSE-CommandTail}
\calls{PARSE-CommandTail}{bang}
\calls{PARSE-CommandTail}{optional}
\calls{PARSE-CommandTail}{star}
\calls{PARSE-CommandTail}{push-reduction}
\calls{PARSE-CommandTail}{PARSE-Option}
\calls{PARSE-CommandTail}{PARSE-CommandTail}
\calls{PARSE-CommandTail}{pop-stack-2}
\calls{PARSE-CommandTail}{pop-stack-1}
\calls{PARSE-CommandTail}{action}
\calls{PARSE-CommandTail}{systemCommand}
<<defun PARSE-CommandTail>>=
(defun |PARSE-CommandTail| ()
 (and (bang fil_test (optional (star repeator (|PARSE-Option|))))
      (|atEndOfLine|)
      (push-reduction '|PARSE-CommandTail|
          (cons (pop-stack-2) (append (pop-stack-1) nil)))
      (action (|systemCommand| (pop-stack-1)))))

@

\defun{PARSE-PrimaryOrQM}{PARSE-PrimaryOrQM}
\calls{PARSE-PrimaryOrQM}{match-advance-string}
\calls{PARSE-PrimaryOrQM}{push-reduction}
\calls{PARSE-PrimaryOrQM}{PARSE-PrimaryOrQM}
\calls{PARSE-PrimaryOrQM}{PARSE-Primary}
<<defun PARSE-PrimaryOrQM>>=
(defun |PARSE-PrimaryOrQM| ()
 (or (and (match-advance-string "?")
          (push-reduction '|PARSE-PrimaryOrQM| '?))
     (|PARSE-Primary|)))

@

\defun{PARSE-Option}{PARSE-Option}
\calls{PARSE-Option}{match-advance-string}
\calls{PARSE-Option}{must}
\calls{PARSE-Option}{star}
\calls{PARSE-Option}{PARSE-PrimaryOrQM}
<<defun PARSE-Option>>=
(defun |PARSE-Option| ()
 (and (match-advance-string ")")
      (must (star repeator (|PARSE-PrimaryOrQM|)))))

@

\defun{PARSE-Statement}{PARSE-Statement}
\calls{PARSE-Statement}{PARSE-Expr}
\calls{PARSE-Statement}{optional}
\calls{PARSE-Statement}{star}
\calls{PARSE-Statement}{match-advance-string}
\calls{PARSE-Statement}{must}
\calls{PARSE-Statement}{push-reduction}
\calls{PARSE-Statement}{pop-stack-2}
\calls{PARSE-Statement}{pop-stack-1}
<<defun PARSE-Statement>>=
(defun |PARSE-Statement| ()
  (and (|PARSE-Expr| 0)
       (optional
           (and (star repeator
                      (and (match-advance-string ",")
                           (must (|PARSE-Expr| 0))))
                (push-reduction '|PARSE-Statement|
                    (cons '|Series|
                          (cons (pop-stack-2)
                                (append (pop-stack-1) nil))))))))

@

\defun{PARSE-InfixWith}{PARSE-InfixWith}
\calls{PARSE-InfixWith}{PARSE-With}
\calls{PARSE-InfixWith}{push-reduction}
\calls{PARSE-InfixWith}{pop-stack-2}
\calls{PARSE-InfixWith}{pop-stack-1}
<<defun PARSE-InfixWith>>=
(defun |PARSE-InfixWith| ()
  (and (|PARSE-With|)
       (push-reduction '|PARSE-InfixWith|
           (list '|Join| (pop-stack-2) (pop-stack-1)))))

@

\defun{PARSE-With}{PARSE-With}
\calls{PARSE-With}{match-advance-string}
\calls{PARSE-With}{must}
\calls{PARSE-With}{push-reduction}
\calls{PARSE-With}{pop-stack-1}
<<defun PARSE-With>>=
(defun |PARSE-With| ()
  (and (match-advance-string "with") (must (|PARSE-Category|))
       (push-reduction '|PARSE-With|
           (cons '|with| (cons (pop-stack-1) nil)))))

@

\defun{PARSE-Category}{PARSE-Category}
\calls{PARSE-Category}{match-advance-string}
\calls{PARSE-Category}{must}
\calls{PARSE-Category}{bang}
\calls{PARSE-Category}{optional}
\calls{PARSE-Category}{push-reduction}
\calls{PARSE-Category}{PARSE-Expression}
\calls{PARSE-Category}{PARSE-Category}
\calls{PARSE-Category}{pop-stack-3}
\calls{PARSE-Category}{pop-stack-2}
\calls{PARSE-Category}{pop-stack-1}
\calls{PARSE-Category}{star}
\calls{PARSE-Category}{line-number}
\calls{PARSE-Category}{PARSE-Application}
\calls{PARSE-Category}{action}
\calls{PARSE-Category}{recordSignatureDocumentation}
\calls{PARSE-Category}{nth-stack}
\calls{PARSE-Category}{recordAttributeDocumentation}
\uses{PARSE-Category}{current-line}
<<defun PARSE-Category>>=
(defun |PARSE-Category| ()
 (let (g1)
  (or (and (match-advance-string "if") (must (|PARSE-Expression|))
           (must (match-advance-string "then"))
           (must (|PARSE-Category|))
           (bang fil_test
                 (optional
                     (and (match-advance-string "else")
                          (must (|PARSE-Category|)))))
           (push-reduction '|PARSE-Category|
             (list '|if| (pop-stack-3) (pop-stack-2) (pop-stack-1))))
      (and (match-advance-string "(") (must (|PARSE-Category|))
           (bang fil_test
                 (optional
                     (star repeator
                           (and (match-advance-string ";")
                                (must (|PARSE-Category|))))))
           (must (match-advance-string ")"))
           (push-reduction '|PARSE-Category|
               (cons 'category
                     (cons (pop-stack-2)
                           (append (pop-stack-1) nil)))))
      (and (action (setq g1 (line-number current-line)))
           (|PARSE-Application|)
           (must (or (and (match-advance-string ":")
                          (must (|PARSE-Expression|))
                          (push-reduction '|PARSE-Category|
                           (list '|Signature| (pop-stack-2) (pop-stack-1) ))
                          (action (|recordSignatureDocumentation|
                                   (nth-stack 1) g1)))
                     (and (push-reduction '|PARSE-Category|
                            (list '|Attribute| (pop-stack-1) ))
                          (action (|recordAttributeDocumentation|
                                   (nth-stack 1) g1)))))))))

@

\defun{PARSE-Expression}{PARSE-Expression}
\calls{PARSE-Expression}{PARSE-Expr}
\calls{PARSE-Expression}{PARSE-rightBindingPowerOf}
\calls{PARSE-Expression}{make-symbol-of}
\calls{PARSE-Expression}{push-reduction}
\calls{PARSE-Expression}{pop-stack-1}
\uses{PARSE-Expression}{ParseMode}
\uses{PARSE-Expression}{prior-token}
<<defun PARSE-Expression>>=
(defun |PARSE-Expression| ()
 (declare (special prior-token))
 (and (|PARSE-Expr|
          (|PARSE-rightBindingPowerOf| (make-symbol-of prior-token)
              |ParseMode|))
      (push-reduction '|PARSE-Expression| (pop-stack-1))))

@

\defun{PARSE-Import}{PARSE-Import}
\calls{PARSE-Import}{match-advance-string}
\calls{PARSE-Import}{must}
\calls{PARSE-Import}{PARSE-Expr}
\calls{PARSE-Import}{bang}
\calls{PARSE-Import}{optional}
\calls{PARSE-Import}{star}
\calls{PARSE-Import}{push-reduction}
\calls{PARSE-Import}{pop-stack-2}
\calls{PARSE-Import}{pop-stack-1}
<<defun PARSE-Import>>=
(defun |PARSE-Import| ()
  (and (match-advance-string "import") (must (|PARSE-Expr| 1000))
       (bang fil_test
             (optional
                 (star repeator
                       (and (match-advance-string ",")
                            (must (|PARSE-Expr| 1000))))))
       (push-reduction '|PARSE-Import|
           (cons '|import|
                 (cons (pop-stack-2) (append (pop-stack-1) nil))))))

@

\defun{PARSE-Expr}{PARSE-Expr}
\calls{PARSE-Expr}{PARSE-NudPart}
\calls{PARSE-Expr}{PARSE-LedPart}
\calls{PARSE-Expr}{optional}
\calls{PARSE-Expr}{star}
\calls{PARSE-Expr}{push-reduction}
\calls{PARSE-Expr}{pop-stack-1}
<<defun PARSE-Expr>>=
(defun |PARSE-Expr| (rbp)
 (declare (special rbp))
 (and (|PARSE-NudPart| rbp)
      (optional (star opt_expr (|PARSE-LedPart| rbp)))
      (push-reduction '|PARSE-Expr| (pop-stack-1))))

@

\defun{PARSE-LedPart}{PARSE-LedPart}
\calls{PARSE-LedPart}{PARSE-Operation}
\calls{PARSE-LedPart}{push-reduction}
\calls{PARSE-LedPart}{pop-stack-1}
<<defun PARSE-LedPart>>=
(defun |PARSE-LedPart| (rbp)
  (declare (special rbp))
  (and (|PARSE-Operation| '|Led| rbp)
       (push-reduction '|PARSE-LedPart| (pop-stack-1))))

@

\defun{PARSE-NudPart}{PARSE-NudPart}
\calls{PARSE-NudPart}{PARSE-Operation}
\calls{PARSE-NudPart}{PARSE-Reduction}
\calls{PARSE-NudPart}{PARSE-Form}
\calls{PARSE-NudPart}{push-reduction}
\calls{PARSE-NudPart}{pop-stack-1}
\uses{PARSE-NudPart}{rbp}
<<defun PARSE-NudPart>>=
(defun |PARSE-NudPart| (rbp)
  (declare (special rbp))
  (and (or (|PARSE-Operation| '|Nud| rbp) (|PARSE-Reduction|)
           (|PARSE-Form|))
       (push-reduction '|PARSE-NudPart| (pop-stack-1))))

@

\defun{PARSE-Operation}{PARSE-Operation}
\calls{PARSE-Operation}{match-current-token}
\calls{PARSE-Operation}{current-symbol}
\calls{PARSE-Operation}{PARSE-leftBindingPowerOf}
\calls{PARSE-Operation}{lt}
\calls{PARSE-Operation}{getl}
\calls{PARSE-Operation}{action}
\calls{PARSE-Operation}{PARSE-rightBindingPowerOf}
\calls{PARSE-Operation}{PARSE-getSemanticForm}
\calls{PARSE-Operation}{elemn}
\uses{PARSE-Operation}{ParseMode}
\uses{PARSE-Operation}{rbp}
\uses{PARSE-Operation}{tmptok}
<<defun PARSE-Operation>>=
(defun |PARSE-Operation| (|ParseMode| rbp)
 (declare (special |ParseMode| rbp |tmptok|))
 (and (not (match-current-token 'identifier))
      (getl (setq |tmptok| (current-symbol)) |ParseMode|)
      (lt rbp (|PARSE-leftBindingPowerOf| |tmptok| |ParseMode|))
      (action (setq rbp (|PARSE-rightBindingPowerOf| |tmptok| |ParseMode|)))
      (|PARSE-getSemanticForm| |tmptok| |ParseMode|
          (elemn (getl |tmptok| |ParseMode|) 5 nil))))

@

\defun{PARSE-leftBindingPowerOf}{PARSE-leftBindingPowerOf}
\calls{PARSE-leftBindingPowerOf}{getl}
\calls{PARSE-leftBindingPowerOf}{elemn}
<<defun PARSE-leftBindingPowerOf>>=
(defun |PARSE-leftBindingPowerOf| (x ind)
 (declare (special x ind))
 (let ((y (getl x ind))) (if y (elemn y 3 0) 0)))

@

\defun{PARSE-rightBindingPowerOf}{PARSE-rightBindingPowerOf}
\calls{PARSE-rightBindingPowerOf}{getl}
\calls{PARSE-rightBindingPowerOf}{elemn}
<<defun PARSE-rightBindingPowerOf>>=
(defun |PARSE-rightBindingPowerOf| (x ind)
  (declare (special x ind))
  (let ((y (getl x ind))) (if y (elemn y 4 105) 105)))

@

\defun{PARSE-getSemanticForm}{PARSE-getSemanticForm}
\calls{PARSE-getSemanticForm}{PARSE-Prefix}
\calls{PARSE-getSemanticForm}{PARSE-Infix}
<<defun PARSE-getSemanticForm>>=
(defun |PARSE-getSemanticForm| (x ind y)
  (declare (special x ind y))
  (or (and y (eval y)) (and (eq ind '|Nud|) (|PARSE-Prefix|))
      (and (eq ind '|Led|) (|PARSE-Infix|))))

@

\defun{PARSE-Prefix}{PARSE-Prefix}
\calls{PARSE-Prefix}{push-reduction}
\calls{PARSE-Prefix}{current-symbol}
\calls{PARSE-Prefix}{action}
\calls{PARSE-Prefix}{advance-token}
\calls{PARSE-Prefix}{optional}
\calls{PARSE-Prefix}{PARSE-TokTail}
\calls{PARSE-Prefix}{must}
\calls{PARSE-Prefix}{PARSE-Expression}
\calls{PARSE-Prefix}{push-reduction}
\calls{PARSE-Prefix}{pop-stack-2}
\calls{PARSE-Prefix}{pop-stack-1}
<<defun PARSE-Prefix>>=
(defun |PARSE-Prefix| ()
  (and (push-reduction '|PARSE-Prefix| (current-symbol))
       (action (advance-token)) (optional (|PARSE-TokTail|))
       (must (|PARSE-Expression|))
       (push-reduction '|PARSE-Prefix|
           (list (pop-stack-2) (pop-stack-1)))))

@

\defun{PARSE-Infix}{PARSE-Infix}
\calls{PARSE-Infix}{push-reduction}
\calls{PARSE-Infix}{current-symbol}
\calls{PARSE-Infix}{action}
\calls{PARSE-Infix}{advance-token}
\calls{PARSE-Infix}{optional}
\calls{PARSE-Infix}{PARSE-TokTail}
\calls{PARSE-Infix}{must}
\calls{PARSE-Infix}{PARSE-Expression}
\calls{PARSE-Infix}{pop-stack-2}
\calls{PARSE-Infix}{pop-stack-1}
<<defun PARSE-Infix>>=
(defun |PARSE-Infix| ()
  (and (push-reduction '|PARSE-Infix| (current-symbol))
       (action (advance-token)) (optional (|PARSE-TokTail|))
       (must (|PARSE-Expression|))
       (push-reduction '|PARSE-Infix|
           (list (pop-stack-2) (pop-stack-2) (pop-stack-1) ))))

@

\defun{PARSE-TokTail}{PARSE-TokTail}
\calls{PARSE-TokTail}{current-symbol}
\calls{PARSE-TokTail}{current-char}
\calls{PARSE-TokTail}{char-eq}
\calls{PARSE-TokTail}{copy-token}
\calls{PARSE-TokTail}{action}
\calls{PARSE-TokTail}{PARSE-Qualification}
\usesdollar{PARSE-TokTail}{boot}
<<defun PARSE-TokTail>>=
(defun |PARSE-TokTail| ()
 (let (g1)
  (and (null $boot) (eq (current-symbol) '$)
       (or (alpha-char-p (current-char))
           (char-eq (current-char) "$")
           (char-eq (current-char) "%")
           (char-eq (current-char) "("))
       (action (setq g1 (copy-token prior-token)))
       (|PARSE-Qualification|) (action (setq prior-token g1)))))

@

\defun{PARSE-Qualification}{PARSE-Qualification}
\calls{PARSE-Qualification}{match-advance-string}
\calls{PARSE-Qualification}{must}
\calls{PARSE-Qualification}{PARSE-Primary1}
\calls{PARSE-Qualification}{push-reduction}
\calls{PARSE-Qualification}{dollarTran}
\calls{PARSE-Qualification}{pop-stack-1}
<<defun PARSE-Qualification>>=
(defun |PARSE-Qualification| ()
  (and (match-advance-string "$") (must (|PARSE-Primary1|))
       (push-reduction '|PARSE-Qualification|
           (|dollarTran| (pop-stack-1) (pop-stack-1)))))

@

\defun{PARSE-Reduction}{PARSE-Reduction}
\calls{PARSE-Reduction}{PARSE-ReductionOp}
\calls{PARSE-Reduction}{must}
\calls{PARSE-Reduction}{PARSE-Expr}
\calls{PARSE-Reduction}{push-reduction}
\calls{PARSE-Reduction}{pop-stack-2}
\calls{PARSE-Reduction}{pop-stack-1}
<<defun PARSE-Reduction>>=
(defun |PARSE-Reduction| ()
 (and (|PARSE-ReductionOp|) (must (|PARSE-Expr| 1000))
      (push-reduction '|PARSE-Reduction|
          (list '|Reduce| (pop-stack-2) (pop-stack-1) ))))

@

\defun{PARSE-ReductionOp}{PARSE-ReductionOp}
\calls{PARSE-ReductionOp}{getl}
\calls{PARSE-ReductionOp}{current-symbol}
\calls{PARSE-ReductionOp}{match-next-token}
\calls{PARSE-ReductionOp}{action}
\calls{PARSE-ReductionOp}{advance-token}
<<defun PARSE-ReductionOp>>=
(defun |PARSE-ReductionOp| ()
  (and (getl (current-symbol) '|Led|)
       (match-next-token 'special-char (code-char 47))
       (push-reduction '|PARSE-ReductionOp| (current-symbol))
       (action (advance-token)) (action (advance-token))))

@

\defun{PARSE-Form}{PARSE-Form}
\calls{PARSE-Form}{match-advance-string}
\calls{PARSE-Form}{bang}
\calls{PARSE-Form}{optional}
\calls{PARSE-Form}{must}
\calls{PARSE-Form}{push-reduction}
\calls{PARSE-Form}{pop-stack-1}
\calls{PARSE-Form}{PARSE-Application}
<<defun PARSE-Form>>=
(defun |PARSE-Form| ()
  (or (and (match-advance-string "iterate")
           (bang fil_test
                 (optional
                     (and (match-advance-string "from")
                          (must (|PARSE-Label|))
                          (push-reduction '|PARSE-Form|
                             (list (pop-stack-1))))))
           (push-reduction '|PARSE-Form|
               (cons '|iterate| (append (pop-stack-1) nil))))
      (and (match-advance-string "yield") (must (|PARSE-Application|))
           (push-reduction '|PARSE-Form|
               (list '|yield| (pop-stack-1))))
      (|PARSE-Application|)))

@

\defun{PARSE-Application}{PARSE-Application}
\calls{PARSE-Application}{PARSE-Primary}
\calls{PARSE-Application}{optional}
\calls{PARSE-Application}{star}
\calls{PARSE-Application}{PARSE-Selector}
\calls{PARSE-Application}{PARSE-Application}
\calls{PARSE-Application}{push-reduction}
\calls{PARSE-Application}{pop-stack-2}
\calls{PARSE-Application}{pop-stack-1}
<<defun PARSE-Application>>=
(defun |PARSE-Application| ()
 (and (|PARSE-Primary|) (optional (star opt_expr (|PARSE-Selector|)))
      (optional
          (and (|PARSE-Application|)
               (push-reduction '|PARSE-Application|
                   (list (pop-stack-2) (pop-stack-1)))))))

@

\defun{PARSE-Label}{PARSE-Label}
\calls{PARSE-Label}{match-advance-string}
\calls{PARSE-Label}{must}
\calls{PARSE-Label}{PARSE-Name}
<<defun PARSE-Label>>=
(defun |PARSE-Label| ()
  (and (match-advance-string "<<") (must (|PARSE-Name|))
       (must (match-advance-string ">>"))))

@

\defun{PARSE-Selector}{PARSE-Selector}
\calls{PARSE-Selector}{current-symbol}
\calls{PARSE-Selector}{char-ne}
\calls{PARSE-Selector}{current-char}
\calls{PARSE-Selector}{match-advance-string}
\calls{PARSE-Selector}{must}
\calls{PARSE-Selector}{PARSE-PrimaryNoFloat}
\calls{PARSE-Selector}{push-reduction}
\calls{PARSE-Selector}{pop-stack-2}
\calls{PARSE-Selector}{pop-stack-1}
\calls{PARSE-Selector}{PARSE-Float}
\calls{PARSE-Selector}{PARSE-Primary}
\usesdollar{PARSE-Selector}{boot}
<<defun PARSE-Selector>>=
(defun |PARSE-Selector| ()
  (declare (special $boot))
  (or (and nonblank (eq (current-symbol) '|.|)
           (char-ne (current-char) '| |) (match-advance-string ".")
           (must (|PARSE-PrimaryNoFloat|))
           (must (or (and $boot
                          (push-reduction '|PARSE-Selector|
                              (list 'elt (pop-stack-2) (pop-stack-1))))
                     (push-reduction '|PARSE-Selector|
                         (list (pop-stack-2) (pop-stack-1))))))
      (and (or (|PARSE-Float|)
               (and (match-advance-string ".")
                    (must (|PARSE-Primary|))))
           (must (or (and $boot
                          (push-reduction '|PARSE-Selector|
                              (list 'elt (pop-stack-2) (pop-stack-1))))
                     (push-reduction '|PARSE-Selector|
                         (list (pop-stack-2) (pop-stack-1))))))))

@

\defun{PARSE-PrimaryNoFloat}{PARSE-PrimaryNoFloat}
\calls{PARSE-PrimaryNoFloat}{PARSE-Primary1}
\calls{PARSE-PrimaryNoFloat}{optional}
\calls{PARSE-PrimaryNoFloat}{PARSE-TokTail}
<<defun PARSE-PrimaryNoFloat>>=
(defun |PARSE-PrimaryNoFloat| ()
  (and (|PARSE-Primary1|) (optional (|PARSE-TokTail|))))

@

\defun{PARSE-Primary}{PARSE-Primary}
\calls{PARSE-Primary}{PARSE-Float}
\calls{PARSE-Primary}{PARSE-PrimaryNoFloat}
<<defun PARSE-Primary>>=
(defun |PARSE-Primary| ()
  (or (|PARSE-Float|) (|PARSE-PrimaryNoFloat|)))

@

\defun{PARSE-Primary1}{PARSE-Primary1}
\calls{PARSE-Primary1}{PARSE-VarForm}
\calls{PARSE-Primary1}{optional}
\calls{PARSE-Primary1}{current-symbol}
\calls{PARSE-Primary1}{PARSE-Primary1}
\calls{PARSE-Primary1}{must}
\calls{PARSE-Primary1}{pop-stack-2}
\calls{PARSE-Primary1}{pop-stack-1}
\calls{PARSE-Primary1}{push-reduction}
\calls{PARSE-Primary1}{PARSE-Quad}
\calls{PARSE-Primary1}{PARSE-String}
\calls{PARSE-Primary1}{PARSE-IntegerTok}
\calls{PARSE-Primary1}{PARSE-FormalParameter}
\calls{PARSE-Primary1}{match-string}
\calls{PARSE-Primary1}{PARSE-Data}
\calls{PARSE-Primary1}{match-advance-string}
\calls{PARSE-Primary1}{PARSE-Expr}
\calls{PARSE-Primary1}{PARSE-Sequence}
\calls{PARSE-Primary1}{PARSE-Enclosure}
\usesdollar{PARSE-Primary1}{boot}
<<defun PARSE-Primary1>>=
(defun |PARSE-Primary1| ()
  (or (and (|PARSE-VarForm|)
           (optional
               (and nonblank (eq (current-symbol) '|(|)
                    (must (|PARSE-Primary1|))
                    (push-reduction '|PARSE-Primary1|
                        (list (pop-stack-2) (pop-stack-1))))))
      (|PARSE-Quad|) (|PARSE-String|) (|PARSE-IntegerTok|)
      (|PARSE-FormalParameter|)
      (and (match-string "'")
           (must (or (and $boot (|PARSE-Data|))
                     (and (match-advance-string "'")
                          (must (|PARSE-Expr| 999))
                          (push-reduction '|PARSE-Primary1|
                              (list 'quote (pop-stack-1)))))))
      (|PARSE-Sequence|) (|PARSE-Enclosure|))))

@

\defun{PARSE-Float}{PARSE-Float}
\calls{PARSE-Float}{PARSE-FloatBase}
\calls{PARSE-Float}{must}
\calls{PARSE-Float}{PARSE-FloatExponent}
\calls{PARSE-Float}{push-reduction}
\calls{PARSE-Float}{make-float}
\calls{PARSE-Float}{pop-stack-4}
\calls{PARSE-Float}{pop-stack-3}
\calls{PARSE-Float}{pop-stack-2}
\calls{PARSE-Float}{pop-stack-1}
<<defun PARSE-Float>>=
(defun |PARSE-Float| ()
  (and (|PARSE-FloatBase|)
       (must (or (and nonblank (|PARSE-FloatExponent|))
                 (push-reduction '|PARSE-Float| 0)))
       (push-reduction '|PARSE-Float|
           (make-float (pop-stack-4) (pop-stack-2) (pop-stack-2)
               (pop-stack-1)))))

@

\defun{PARSE-FloatBase}{PARSE-FloatBase}
\calls{PARSE-FloatBase}{current-symbol}
\calls{PARSE-FloatBase}{char-eq}
\calls{PARSE-FloatBase}{current-char}
\calls{PARSE-FloatBase}{char-ne}
\calls{PARSE-FloatBase}{next-char}
\calls{PARSE-FloatBase}{PARSE-IntegerTok}
\calls{PARSE-FloatBase}{must}
\calls{PARSE-FloatBase}{PARSE-FloatBasePart}
\calls{PARSE-FloatBase}{PARSE-IntegerTok}
\calls{PARSE-FloatBase}{push-reduction}
\calls{PARSE-FloatBase}{digitp}
<<defun PARSE-FloatBase>>=
(defun |PARSE-FloatBase| ()
  (or (and (integerp (current-symbol)) (char-eq (current-char) ".")
           (char-ne (next-char) ".") (|PARSE-IntegerTok|)
           (must (|PARSE-FloatBasePart|)))
      (and (integerp (current-symbol))
           (char-eq (char-upcase (current-char)) 'e)
           (|PARSE-IntegerTok|) (push-reduction '|PARSE-FloatBase| 0)
           (push-reduction '|PARSE-FloatBase| 0))
      (and (digitp (current-char)) (eq (current-symbol) '|.|)
           (push-reduction '|PARSE-FloatBase| 0)
           (|PARSE-FloatBasePart|))))

@

\defun{PARSE-FloatBasePart}{PARSE-FloatBasePart}
\calls{PARSE-FloatBasePart}{match-advance-string}
\calls{PARSE-FloatBasePart}{must}
\calls{PARSE-FloatBasePart}{digitp}
\calls{PARSE-FloatBasePart}{current-char}
\calls{PARSE-FloatBasePart}{push-reduction}
\calls{PARSE-FloatBasePart}{token-nonblank}
\calls{PARSE-FloatBasePart}{current-token}
\calls{PARSE-FloatBasePart}{PARSE-IntegerTok}
<<defun PARSE-FloatBasePart>>=
(defun |PARSE-FloatBasePart| ()
  (and (match-advance-string ".")
       (must (or (and (digitp (current-char))
                      (push-reduction '|PARSE-FloatBasePart|
                          (token-nonblank (current-token)))
                      (|PARSE-IntegerTok|))
                 (and (push-reduction '|PARSE-FloatBasePart| 0)
                      (push-reduction '|PARSE-FloatBasePart| 0))))))

@

\defun{PARSE-FloatExponent}{PARSE-FloatExponent}
\calls{PARSE-FloatExponent}{current-symbol}
\calls{PARSE-FloatExponent}{current-char}
\calls{PARSE-FloatExponent}{action}
\calls{PARSE-FloatExponent}{advance-token}
\calls{PARSE-FloatExponent}{PARSE-IntegerTok}
\calls{PARSE-FloatExponent}{match-advance-string}
\calls{PARSE-FloatExponent}{must}
\calls{PARSE-FloatExponent}{push-reduction}
\calls{PARSE-FloatExponent}{identp}
\calls{PARSE-FloatExponent}{floatexpid}
<<defun PARSE-FloatExponent>>=
(defun |PARSE-FloatExponent| ()
 (let (g1)
  (or (and (member (current-symbol) '(e |e|))
           (find (current-char) "+-") (action (advance-token))
           (must (or (|PARSE-IntegerTok|)
                     (and (match-advance-string "+")
                          (must (|PARSE-IntegerTok|)))
                     (and (match-advance-string "-")
                          (must (|PARSE-IntegerTok|))
                          (push-reduction '|PARSE-FloatExponent|
                              (- (pop-stack-1))))
                     (push-reduction '|PARSE-FloatExponent| 0))))
      (and (identp (current-symbol))
           (setq g1 (floatexpid (current-symbol)))
           (action (advance-token))
           (push-reduction '|PARSE-FloatExponent| g1)))))

@

\defun{PARSE-Enclosure}{PARSE-Enclosure}
\calls{PARSE-Enclosure}{match-advance-string}
\calls{PARSE-Enclosure}{must}
\calls{PARSE-Enclosure}{PARSE-Expr}
\calls{PARSE-Enclosure}{push-reduction}
\calls{PARSE-Enclosure}{pop-stack-1}
<<defun PARSE-Enclosure>>=
(defun |PARSE-Enclosure| ()
  (or (and (match-advance-string "(")
           (must (or (and (|PARSE-Expr| 6)
                          (must (match-advance-string ")")))
                     (and (match-advance-string ")")
                          (push-reduction '|PARSE-Enclosure|
                              (list '|@Tuple|))))))
      (and (match-advance-string "{")
           (must (or (and (|PARSE-Expr| 6)
                          (must (match-advance-string "}"))
                          (push-reduction '|PARSE-Enclosure|
                              (cons '|brace|
                               (list (list '|construct| (pop-stack-1))))))
                     (and (match-advance-string "}")
                          (push-reduction '|PARSE-Enclosure|
                              (list '|brace|))))))))

@

\defun{PARSE-IntegerTok}{PARSE-IntegerTok}
\calls{PARSE-IntegerTok}{parse-number}
<<defun PARSE-IntegerTok>>=
(defun |PARSE-IntegerTok| () (parse-number))

@

\defun{PARSE-FormalParameter}{PARSE-FormalParameter}
\calls{PARSE-FormalParameter}{PARSE-FormalParameterTok}
<<defun PARSE-FormalParameter>>=
(defun |PARSE-FormalParameter| () (|PARSE-FormalParameterTok|))

@

\defun{PARSE-FormalParameterTok}{PARSE-FormalParameterTok}
\calls{PARSE-FormalParameterTok}{parse-argument-designator}
<<defun PARSE-FormalParameterTok>>=
(defun |PARSE-FormalParameterTok| () (parse-argument-designator))

@

\defun{PARSE-Quad}{PARSE-Quad}
\calls{PARSE-Quad}{match-advance-string}
\calls{PARSE-Quad}{push-reduction}
\calls{PARSE-Quad}{PARSE-GliphTok}
\usesdollar{PARSE-Quad}{boot}
<<defun PARSE-Quad>>=
(defun |PARSE-Quad| ()
 (or (and (match-advance-string "$")
          (push-reduction '|PARSE-Quad| '$))
     (and $boot (|PARSE-GliphTok| '|.|)
          (push-reduction '|PARSE-Quad| '|.|))))

@

\defun{PARSE-String}{PARSE-String}
\calls{PARSE-String}{parse-spadstring}
<<defun PARSE-String>>=
(defun |PARSE-String| () (parse-spadstring))

@

\defun{PARSE-VarForm}{PARSE-VarForm}
\calls{PARSE-VarForm}{PARSE-Name}
\calls{PARSE-VarForm}{optional}
\calls{PARSE-VarForm}{PARSE-Scripts}
\calls{PARSE-VarForm}{push-reduction}
\calls{PARSE-VarForm}{pop-stack-2}
\calls{PARSE-VarForm}{pop-stack-1}
<<defun PARSE-VarForm>>=
(defun |PARSE-VarForm| ()
  (and (|PARSE-Name|)
       (optional
           (and (|PARSE-Scripts|)
                (push-reduction '|PARSE-VarForm|
                    (list '|Scripts| (pop-stack-2) (pop-stack-1)))))
       (push-reduction '|PARSE-VarForm| (pop-stack-1))))

@

\defun{PARSE-Scripts}{PARSE-Scripts}
\calls{PARSE-Scripts}{match-advance-string}
\calls{PARSE-Scripts}{must}
\calls{PARSE-Scripts}{PARSE-ScriptItem}
<<defun PARSE-Scripts>>=
(defun |PARSE-Scripts| ()
 (and nonblank (match-advance-string "[") (must (|PARSE-ScriptItem|))
      (must (match-advance-string "]"))))

@

\defun{PARSE-ScriptItem}{PARSE-ScriptItem}
\calls{PARSE-ScriptItem}{PARSE-Expr}
\calls{PARSE-ScriptItem}{optional}
\calls{PARSE-ScriptItem}{star}
\calls{PARSE-ScriptItem}{match-advance-string}
\calls{PARSE-ScriptItem}{must}
\calls{PARSE-ScriptItem}{PARSE-ScriptItem}
\calls{PARSE-ScriptItem}{push-reduction}
\calls{PARSE-ScriptItem}{pop-stack-2}
\calls{PARSE-ScriptItem}{pop-stack-1}
<<defun PARSE-ScriptItem>>=
(defun |PARSE-ScriptItem| ()
  (or (and (|PARSE-Expr| 90)
           (optional
               (and (star repeator
                          (and (match-advance-string ";")
                               (must (|PARSE-ScriptItem|))))
                    (push-reduction '|PARSE-ScriptItem|
                        (cons '|;|
                              (cons (pop-stack-2)
                                    (append (pop-stack-1) nil)))))))
      (and (match-advance-string ";") (must (|PARSE-ScriptItem|))
           (push-reduction '|PARSE-ScriptItem|
               (list '|PrefixSC| (pop-stack-1))))))

@

\defun{PARSE-Name}{PARSE-Name}
\calls{PARSE-Name}{parse-identifier}
\calls{PARSE-Name}{push-reduction}
\calls{PARSE-Name}{pop-stack-1}
<<defun PARSE-Name>>=
(defun |PARSE-Name| ()
  (and (parse-identifier) (push-reduction '|PARSE-Name| (pop-stack-1))))

@

\defun{PARSE-Data}{PARSE-Data}
\calls{PARSE-Data}{action}
\calls{PARSE-Data}{PARSE-Sexpr}
\calls{PARSE-Data}{push-reduction}
\calls{PARSE-Data}{translabel}
\calls{PARSE-Data}{pop-stack-1}
\uses{PARSE-Data}{labasoc}
<<defun PARSE-Data>>=
(defun |PARSE-Data| ()
  (declare (special lablasoc))
  (and (action (setq lablasoc nil)) (|PARSE-Sexpr|)
       (push-reduction '|PARSE-Data|
           (list 'quote (translabel (pop-stack-1) lablasoc)))))

@

\defun{PARSE-Sexpr}{PARSE-Sexpr}
\calls{PARSE-Sexpr}{PARSE-Sexpr1}
<<defun PARSE-Sexpr>>=
(defun |PARSE-Sexpr| ()
  (and (action (advance-token)) (|PARSE-Sexpr1|)))

@

\defun{PARSE-Sexpr1}{PARSE-Sexpr1}
\calls{PARSE-Sexpr1}{PARSE-AnyId}
\calls{PARSE-Sexpr1}{optional}
\calls{PARSE-Sexpr1}{PARSE-NBGliphTok}
\calls{PARSE-Sexpr1}{must}
\calls{PARSE-Sexpr1}{PARSE-Sexpr1}
\calls{PARSE-Sexpr1}{action}
\calls{PARSE-Sexpr1}{pop-stack-2}
\calls{PARSE-Sexpr1}{nth-stack}
\calls{PARSE-Sexpr1}{match-advance-string}
\calls{PARSE-Sexpr1}{push-reduction}
\calls{PARSE-Sexpr1}{PARSE-IntegerTok}
\calls{PARSE-Sexpr1}{pop-stack-1}
\calls{PARSE-Sexpr1}{PARSE-String}
\calls{PARSE-Sexpr1}{bang}
\calls{PARSE-Sexpr1}{star}
\calls{PARSE-Sexpr1}{PARSE-GliphTok}
<<defun PARSE-Sexpr1>>=
(defun |PARSE-Sexpr1| ()
  (or (and (|PARSE-AnyId|)
           (optional
               (and (|PARSE-NBGliphTok| '=) (must (|PARSE-Sexpr1|))
                    (action (setq lablasoc
                                  (cons (cons (pop-stack-2)
                                         (nth-stack 1))
                                        lablasoc))))))
      (and (match-advance-string "'") (must (|PARSE-Sexpr1|))
           (push-reduction '|PARSE-Sexpr1|
               (list 'quote (pop-stack-1))))
      (|PARSE-IntegerTok|)
      (and (match-advance-string "-") (must (|PARSE-IntegerTok|))
           (push-reduction '|PARSE-Sexpr1| (- (pop-stack-1))))
      (|PARSE-String|)
      (and (match-advance-string "<")
           (bang fil_test (optional (star repeator (|PARSE-Sexpr1|))))
           (must (match-advance-string ">"))
           (push-reduction '|PARSE-Sexpr1| (list2vec (pop-stack-1))))
      (and (match-advance-string "(")
           (bang fil_test
                 (optional
                     (and (star repeator (|PARSE-Sexpr1|))
                          (optional
                              (and (|PARSE-GliphTok| '|.|)
                                   (must (|PARSE-Sexpr1|))
                                   (push-reduction '|PARSE-Sexpr1|
                                    (nconc (pop-stack-2) (pop-stack-1))))))))
           (must (match-advance-string ")")))))

@

\defun{PARSE-NBGliphTok}{PARSE-NBGliphTok}
\calls{PARSE-NBGliphTok}{match-current-token}
\calls{PARSE-NBGliphTok}{action}
\calls{PARSE-NBGliphTok}{advance-token}
\uses{PARSE-NBGliphTok}{tok}
<<defun PARSE-NBGliphTok>>=
(defun |PARSE-NBGliphTok| (|tok|)
 (declare (special |tok|))
 (and (match-current-token 'gliph |tok|) nonblank (action (advance-token))))

@

\defun{PARSE-GliphTok}{PARSE-GliphTok}
\calls{PARSE-GliphTok}{match-current-token}
\calls{PARSE-GliphTok}{action}
\calls{PARSE-GliphTok}{advance-token}
\uses{PARSE-GliphTok}{tok}
<<defun PARSE-GliphTok>>=
(defun |PARSE-GliphTok| (|tok|)
 (declare (special |tok|))
 (and (match-current-token 'gliph |tok|) (action (advance-token))))

@

\defun{PARSE-AnyId}{PARSE-AnyId}
\calls{PARSE-AnyId}{parse-identifier}
\calls{PARSE-AnyId}{match-string}
\calls{PARSE-AnyId}{push-reduction}
\calls{PARSE-AnyId}{current-symbol}
\calls{PARSE-AnyId}{action}
\calls{PARSE-AnyId}{advance-token}
\calls{PARSE-AnyId}{parse-keyword}
<<defun PARSE-AnyId>>=
(defun |PARSE-AnyId| ()
  (or (parse-identifier)
      (or (and (match-string "$")
               (push-reduction '|PARSE-AnyId| (current-symbol))
               (action (advance-token)))
          (parse-keyword))))

@

\defun{PARSE-Sequence}{PARSE-Sequence}
\calls{PARSE-Sequence}{PARSE-OpenBracket}
\calls{PARSE-Sequence}{must}
\calls{PARSE-Sequence}{PARSE-Sequence1}
\calls{PARSE-Sequence}{match-advance-string}
\calls{PARSE-Sequence}{PARSE-OpenBrace}
\calls{PARSE-Sequence}{push-reduction}
\calls{PARSE-Sequence}{pop-stack-1}
<<defun PARSE-Sequence>>=
(defun |PARSE-Sequence| ()
  (or (and (|PARSE-OpenBracket|) (must (|PARSE-Sequence1|))
           (must (match-advance-string "]")))
      (and (|PARSE-OpenBrace|) (must (|PARSE-Sequence1|))
           (must (match-advance-string "}"))
           (push-reduction '|PARSE-Sequence|
               (list '|brace| (pop-stack-1))))))

@

\defun{PARSE-Sequence1}{PARSE-Sequence1}
\calls{PARSE-Sequence1}{PARSE-Expression}
\calls{PARSE-Sequence1}{push-reduction}
\calls{PARSE-Sequence1}{pop-stack-2}
\calls{PARSE-Sequence1}{pop-stack-1}
\calls{PARSE-Sequence1}{optional}
\calls{PARSE-Sequence1}{PARSE-IteratorTail}
<<defun PARSE-Sequence1>>=
(defun |PARSE-Sequence1| ()
  (and (or (and (|PARSE-Expression|)
                (push-reduction '|PARSE-Sequence1|
                    (list (pop-stack-2) (pop-stack-1))))
           (push-reduction '|PARSE-Sequence1| (list (pop-stack-1))))
       (optional
           (and (|PARSE-IteratorTail|)
                (push-reduction '|PARSE-Sequence1|
                    (cons 'collect
                          (append (pop-stack-1)
                                  (list (pop-stack-1)))))))))

@

\defun{PARSE-OpenBracket}{PARSE-OpenBracket}
\calls{PARSE-OpenBracket}{getToken}
\calls{PARSE-OpenBracket}{current-symbol}
\calls{PARSE-OpenBracket}{eqcar}
\calls{PARSE-OpenBracket}{push-reduction}
\calls{PARSE-OpenBracket}{action}
\calls{PARSE-OpenBracket}{advance-token}
<<defun PARSE-OpenBracket>>=
(defun |PARSE-OpenBracket| ()
 (let (g1)
  (and (eq (|getToken| (setq g1 (current-symbol))) '[)
       (must (or (and (eqcar g1 '|elt|)
                      (push-reduction '|PARSE-OpenBracket|
                          (list '|elt| (second g1) '|construct|)))
                 (push-reduction '|PARSE-OpenBracket| '|construct|)))
       (action (advance-token)))))) 

@

\defun{PARSE-OpenBrace}{PARSE-OpenBrace}
\calls{PARSE-OpenBrace}{getToken}
\calls{PARSE-OpenBrace}{current-symbol}
\calls{PARSE-OpenBrace}{eqcar}
\calls{PARSE-OpenBrace}{push-reduction}
\calls{PARSE-OpenBrace}{action}
\calls{PARSE-OpenBrace}{advance-token}
<<defun PARSE-OpenBrace>>=
(defun |PARSE-OpenBrace| ()
 (let (g1)
  (and (eq (|getToken| (setq g1 (current-symbol))) '{)
       (must (or (and (eqcar g1 '|elt|)
                      (push-reduction '|PARSE-OpenBrace|
                          (list '|elt| (second g1) '|brace|)))
                 (push-reduction '|PARSE-OpenBrace| '|construct|)))
       (action (advance-token)))))) 

@

\defun{PARSE-IteratorTail}{PARSE-IteratorTail}
\calls{PARSE-IteratorTail}{match-advance-string}
\calls{PARSE-IteratorTail}{bang}
\calls{PARSE-IteratorTail}{optional}
\calls{PARSE-IteratorTail}{star}
\calls{PARSE-IteratorTail}{PARSE-Iterator}
<<defun PARSE-IteratorTail>>=
(defun |PARSE-IteratorTail| ()
 (or (and (match-advance-string "repeat")
          (bang fil_test (optional (star repeator (|PARSE-Iterator|)))))
     (star repeator (|PARSE-Iterator|))))

@

\defun{PARSE-Iterator}{PARSE-Iterator}
\calls{PARSE-Iterator}{match-advance-string}
\calls{PARSE-Iterator}{must}
\calls{PARSE-Iterator}{PARSE-Primary}
\calls{PARSE-Iterator}{PARSE-Expression}
\calls{PARSE-Iterator}{PARSE-Expr}
\calls{PARSE-Iterator}{pop-stack-3}
\calls{PARSE-Iterator}{pop-stack-2}
\calls{PARSE-Iterator}{pop-stack-1}
\calls{PARSE-Iterator}{optional}
<<defun PARSE-Iterator>>=
(defun |PARSE-Iterator| ()
  (or (and (match-advance-string "for") (must (|PARSE-Primary|))
           (must (match-advance-string "in"))
           (must (|PARSE-Expression|))
           (must (or (and (match-advance-string "by")
                          (must (|PARSE-Expr| 200))
                          (push-reduction '|PARSE-Iterator|
                           (list 'inby (pop-stack-3)
                                       (pop-stack-2) (pop-stack-1))))
                     (push-reduction '|PARSE-Iterator|
                         (list 'in (pop-stack-2) (pop-stack-1)))))
           (optional
               (and (match-advance-string "|")
                    (must (|PARSE-Expr| 111))
                    (push-reduction '|PARSE-Iterator|
                        (list '|\|| (pop-stack-1))))))
      (and (match-advance-string "while") (must (|PARSE-Expr| 190))
           (push-reduction '|PARSE-Iterator|
               (list 'while (pop-stack-1))))
      (and (match-advance-string "until") (must (|PARSE-Expr| 190))
           (push-reduction '|PARSE-Iterator|
               (list 'until (pop-stack-1))))))

@
\subsection{The PARSE implicit routines}
These symbols are not explicitly referenced in the source.
Nevertheless, they are called during runtime. For example,
PARSE-SemiColon is called in the chain:
\begin{verbatim}
  PARSE-Enclosure {loc0=nil,loc1="(V  ==> Vector; "} [ihs=35]
   PARSE-Expr
    PARSE-LedPart
     PARSE-Operation
      PARSE-getSemanticForm
       PARSE-SemiColon
\end{verbatim}
so there is a bit of indirection involved in the call.

\defun{PARSE-Suffix}{PARSE-Suffix}
\calls{PARSE-Suffix}{push-reduction}
\calls{PARSE-Suffix}{current-symbol}
\calls{PARSE-Suffix}{action}
\calls{PARSE-Suffix}{advance-token}
\calls{PARSE-Suffix}{optional}
\calls{PARSE-Suffix}{PARSE-TokTail}
\calls{PARSE-Suffix}{pop-stack-1}
<<defun PARSE-Suffix>>=
(defun |PARSE-Suffix| ()
  (and (push-reduction '|PARSE-Suffix| (current-symbol))
       (action (advance-token)) (optional (|PARSE-TokTail|))
       (push-reduction '|PARSE-Suffix|
           (list (pop-stack-1) (pop-stack-1)))))

@

\defun{PARSE-SemiColon}{PARSE-SemiColon}
\calls{PARSE-SemiColon}{match-advance-string}
\calls{PARSE-SemiColon}{must}
\calls{PARSE-SemiColon}{PARSE-Expr}
\calls{PARSE-SemiColon}{push-reduction}
\calls{PARSE-SemiColon}{pop-stack-2}
\calls{PARSE-SemiColon}{pop-stack-1}
<<defun PARSE-SemiColon>>=
(defun |PARSE-SemiColon| ()
  (and (match-advance-string ";")
       (must (or (|PARSE-Expr| 82)
                 (push-reduction '|PARSE-SemiColon| '|/throwAway|)))
       (push-reduction '|PARSE-SemiColon|
           (list '|;| (pop-stack-2) (pop-stack-1)))))

@

\defun{PARSE-Return}{PARSE-Return}
\calls{PARSE-Return}{match-advance-string}
\calls{PARSE-Return}{must}
\calls{PARSE-Return}{PARSE-Expression}
\calls{PARSE-Return}{push-reduction}
\calls{PARSE-Return}{pop-stack-1}
<<defun PARSE-Return>>=
(defun |PARSE-Return| ()
  (and (match-advance-string "return") (must (|PARSE-Expression|))
       (push-reduction '|PARSE-Return|
           (list '|return| (pop-stack-1)))))

@

\defun{PARSE-Exit}{PARSE-Exit}
\calls{PARSE-Exit}{match-advance-string}
\calls{PARSE-Exit}{must}
\calls{PARSE-Exit}{PARSE-Expression}
\calls{PARSE-Exit}{push-reduction}
\calls{PARSE-Exit}{pop-stack-1}
<<defun PARSE-Exit>>=
(defun |PARSE-Exit| ()
  (and (match-advance-string "exit")
       (must (or (|PARSE-Expression|)
                 (push-reduction '|PARSE-Exit| '|$NoValue|)))
       (push-reduction '|PARSE-Exit|
           (list '|exit| (pop-stack-1)))))

@

\defun{PARSE-Leave}{PARSE-Leave}
\calls{PARSE-Leave}{match-advance-string}
\calls{PARSE-Leave}{PARSE-Expression}
\calls{PARSE-Leave}{must}
\calls{PARSE-Leave}{push-reduction}
\calls{PARSE-Leave}{PARSE-Label}
\calls{PARSE-Leave}{pop-stack-1}
<<defun PARSE-Leave>>=
(defun |PARSE-Leave| ()
  (and (match-advance-string "leave")
       (must (or (|PARSE-Expression|)
                 (push-reduction '|PARSE-Leave| '|$NoValue|)))
       (must (or (and (match-advance-string "from")
                      (must (|PARSE-Label|))
                      (push-reduction '|PARSE-Leave|
                          (list '|leaveFrom| (pop-stack-1) (pop-stack-1))))
                 (push-reduction '|PARSE-Leave|
                     (list '|leave| (pop-stack-1)))))))

@

\defun{PARSE-Seg}{PARSE-Seg}
\calls{PARSE-Seg}{PARSE-GliphTok}
\calls{PARSE-Seg}{bang}
\calls{PARSE-Seg}{optional}
\calls{PARSE-Seg}{PARSE-Expression}
\calls{PARSE-Seg}{push-reduction}
\calls{PARSE-Seg}{pop-stack-2}
\calls{PARSE-Seg}{pop-stack-1}
<<defun PARSE-Seg>>=
(defun |PARSE-Seg| ()
  (and (|PARSE-GliphTok| '|..|)
       (bang fil_test (optional (|PARSE-Expression|)))
       (push-reduction '|PARSE-Seg|
           (list 'segment (pop-stack-2) (pop-stack-1)))))

@

\defun{PARSE-Conditional}{PARSE-Conditional}
\calls{PARSE-Conditional}{match-advance-string}
\calls{PARSE-Conditional}{must}
\calls{PARSE-Conditional}{PARSE-Expression}
\calls{PARSE-Conditional}{bang}
\calls{PARSE-Conditional}{optional}
\calls{PARSE-Conditional}{PARSE-ElseClause}
\calls{PARSE-Conditional}{push-reduction}
\calls{PARSE-Conditional}{pop-stack-3}
\calls{PARSE-Conditional}{pop-stack-2}
\calls{PARSE-Conditional}{pop-stack-1}
<<defun PARSE-Conditional>>=
(defun |PARSE-Conditional| ()
  (and (match-advance-string "if") (must (|PARSE-Expression|))
       (must (match-advance-string "then")) (must (|PARSE-Expression|))
       (bang fil_test
             (optional
                 (and (match-advance-string "else")
                      (must (|PARSE-ElseClause|)))))
       (push-reduction '|PARSE-Conditional|
           (list '|if| (pop-stack-3) (pop-stack-2) (pop-stack-1)))))

@

\defun{PARSE-ElseClause}{PARSE-ElseClause}
\calls{PARSE-ElseClause}{current-symbol}
\calls{PARSE-ElseClause}{PARSE-Conditional}
\calls{PARSE-ElseClause}{PARSE-Expression}
<<defun PARSE-ElseClause>>=
(defun |PARSE-ElseClause| ()
  (or (and (eq (current-symbol) '|if|) (|PARSE-Conditional|))
      (|PARSE-Expression|)))

@

\defun{PARSE-Loop}{PARSE-Loop}
\calls{PARSE-Loop}{star}
\calls{PARSE-Loop}{PARSE-Iterator}
\calls{PARSE-Loop}{must}
\calls{PARSE-Loop}{match-advance-string}
\calls{PARSE-Loop}{PARSE-Expr}
\calls{PARSE-Loop}{push-reduction}
\calls{PARSE-Loop}{pop-stack-2}
\calls{PARSE-Loop}{pop-stack-1}
<<defun PARSE-Loop>>=
(defun |PARSE-Loop| ()
  (or (and (star repeator (|PARSE-Iterator|))
           (must (match-advance-string "repeat"))
           (must (|PARSE-Expr| 110))
           (push-reduction '|PARSE-Loop|
               (cons 'repeat
                     (append (pop-stack-2) (list (pop-stack-1))))))
      (and (match-advance-string "repeat") (must (|PARSE-Expr| 110))
           (push-reduction '|PARSE-Loop|
               (list 'repeat (pop-stack-1))))))

@

\defun{PARSE-LabelExpr}{PARSE-LabelExpr}
\calls{PARSE-LabelExpr}{PARSE-Label}
\calls{PARSE-LabelExpr}{must}
\calls{PARSE-LabelExpr}{PARSE-Expr}
\calls{PARSE-LabelExpr}{push-reduction}
\calls{PARSE-LabelExpr}{pop-stack-2}
\calls{PARSE-LabelExpr}{pop-stack-1}
<<defun PARSE-LabelExpr>>=
(defun |PARSE-LabelExpr| ()
  (and (|PARSE-Label|) (must (|PARSE-Expr| 120))
       (push-reduction '|PARSE-LabelExpr|
           (list 'label (pop-stack-2) (pop-stack-1)))))

@

\defun{PARSE-FloatTok}{PARSE-FloatTok}
\calls{PARSE-FloatTok}{parse-number}
\calls{PARSE-FloatTok}{push-reduction}
\calls{PARSE-FloatTok}{pop-stack-1}
\calls{PARSE-FloatTok}{bfp-}
\usesdollar{PARSE-FloatTok}{boot}
<<defun PARSE-FloatTok>>=
(defun |PARSE-FloatTok| ()
  (and (parse-number)
       (push-reduction '|PARSE-FloatTok|
           (if $boot (pop-stack-1) (bfp- (pop-stack-1))))))

@


\section{The PARSE support routines}
This section is broken up into 3 levels:
\begin{itemize}
\item String grabbing:    Match String, Match Advance String
\item Token handling:     Current Token, Next Token, Advance Token
\item Character handling: Current Char, Next Char, Advance Char
\item Line handling:      Next Line, Print Next Line
\item Error Handling
\item Floating Point Support
\item Dollar Translation
\end{itemize}
\subsection{String grabbing}
String grabbing is the art of matching initial segments of the current
line, and removing them from the line before the get tokenized if they
match (or removing the corresponding current tokens).

\defun{match-string}{match-string}
The match-string function returns length of X 
if X matches initial segment of inputstream.
\calls{match-string}{unget-tokens}
\calls{match-string}{skip-blanks}
\calls{match-string}{line-past-end-p}
\calls{match-string}{current-char}
\calls{match-string}{initial-substring-p}
\calls{match-string}{subseq}
\usesstruct{match-string}{line}
\uses{match-string}{line}
<<defun match-string>>=
(defun match-string (x)
  (unget-tokens) ; So we don't get out of synch with token stream
  (skip-blanks)
  (if (and (not (line-past-end-p current-line)) (current-char) )
    (initial-substring-p x
     (subseq (line-buffer current-line) (line-current-index current-line)))))

@

\defun{match-advance-string}{match-advance-string}
The match-string function returns length of X 
if X matches initial segment of inputstream.
If it is successful, advance inputstream past X.
\calls{match-advance-string}{quote-if-string}
\calls{match-advance-string}{current-token}
\calls{match-advance-string}{match-string}
\calls{match-advance-string}{line-current-index}
\calls{match-advance-string}{line-past-end-p}
\calls{match-advance-string}{line-current-char}
\usesstruct{match-advance-string}{token}
\usesstruct{match-advance-string}{line}
<<defun match-advance-string>>=
(defun match-advance-string (x)
  (let ((y (if (>= (length (string x))
                   (length (string (quote-if-string (current-token)))))
               (match-string x)
               nil))) ; must match at least the current token
    (when y
      (incf (line-current-index current-line) y)
      (if (not (line-past-end-p current-line))
       (setf (line-current-char current-line)
             (elt (line-buffer current-line)
                  (line-current-index current-line)))
       (setf (line-current-char current-line) #\space))
      (setq prior-token
       (make-token :symbol (intern (string x))
                   :type 'identifier
                   :nonblank nonblank))
      t)))

@

\defun{initial-substring-p}{initial-substring-p}
\calls{initial-substring-p}{string-not-greaterp}
<<defun initial-substring-p>>=
(defun initial-substring-p (part whole)
  "Returns length of part if part matches initial segment of whole."
  (let ((x (string-not-greaterp part whole)))
    (and x (= x (length part)) x)))

@

\defun{quote-if-string}{quote-if-string}
\calls{quote-if-string}{token-type}
\calls{quote-if-string}{strconc}
\calls{quote-if-string}{token-symbol}
\calls{quote-if-string}{underscore}
\calls{quote-if-string}{token-nonblank}
\calls{quote-if-string}{pack}
\calls{quote-if-string}{escape-keywords}
\usesdollar{quote-if-string}{boot}
\usesdollar{quote-if-string}{spad}
<<defun quote-if-string>>=
(defun quote-if-string (token)
 (declare (special $boot $spad))
 (when token   ;only use token-type on non-null tokens
  (case (token-type token)
   (bstring      (strconc "[" (token-symbol token) "]*"))
   (string       (strconc "'" (token-symbol token) "'"))
   (spadstring   (strconc "\"" (underscore (token-symbol token)) "\""))
   (number       (format nil "~v,'0D" (token-nonblank token)
                                (token-symbol token)))
   (special-char (string (token-symbol token)))
   (identifier   (let ((id (symbol-name (token-symbol token)))
                           (pack (package-name (symbol-package
                                                (token-symbol token)))))
                  (if (or $boot $spad)
                   (if (string= pack "BOOT")
                    (escape-keywords (underscore id) (token-symbol token))
                    (concatenate 'string
                      (underscore pack) "'" (underscore id)))
                   id)))
   (t            (token-symbol token)))))

@

\defun{escape-keywords}{escape-keywords}
<<defun escape-keywords>>=
(defun escape-keywords (pname id)
  (if (member id keywords)
   (concatenate 'string "_" pname)
   pname))

@

\defun{isTokenDelimiter}{isTokenDelimiter}
NIL needed below since END\_UNIT is not generated by current parser
\calls{isTokenDelimiter}{current-symbol}
<<defun isTokenDelimiter>>=
(defun |isTokenDelimiter| ()
 (member (current-symbol) '(\) end\_unit nil)))

@

\defun{underscore}{underscore}
\calls{underscore}{vector-push}
<<defun underscore>>=
(defun underscore (string)
 (if (every #'alpha-char-p string) 
  string
  (let* ((size (length string))
         (out-string (make-array (* 2 size)
                                 :element-type 'string-char
                                 :fill-pointer 0))
         next-char)
   (dotimes (i size)
    (setq next-char (char string i))
    (unless (alpha-char-p next-char) (vector-push #\_ out-string))
    (vector-push next-char out-string))
   out-string)))

@

\subsection{Token Handling}

\defun{getToken}{getToken}
\calls{getToken}{eqcar}
<<defun getToken>>=
(defun |getToken| (x)
 (if (eqcar x '|elt|) (third x) x))

@

\defun{unget-tokens}{unget-tokens}
\calls{unget-tokens}{quote-if-string}
\calls{unget-tokens}{line-current-segment}
\calls{unget-tokens}{strconc}
\calls{unget-tokens}{line-number}
\calls{unget-tokens}{token-nonblank}
\calls{unget-tokens}{line-new-line}
\calls{unget-tokens}{line-number}
\uses{unget-tokens}{valid-tokens}
<<defun unget-tokens>>=
(defun unget-tokens ()
 (case valid-tokens
  (0 t)
  (1 (let* ((cursym (quote-if-string current-token))
            (curline (line-current-segment current-line))
            (revised-line (strconc cursym curline (copy-seq " "))))
         (line-new-line revised-line current-line (line-number current-line))
         (setq nonblank (token-nonblank current-token))
         (setq valid-tokens 0)))
  (2 (let* ((cursym (quote-if-string current-token))
            (nextsym (quote-if-string next-token))
            (curline (line-current-segment Current-Line))
            (revised-line
             (strconc (if (token-nonblank current-token) "" " ")
                      cursym
                      (if (token-nonblank next-token) "" " ")
                      nextsym curline " ")))
      (setq nonblank (token-nonblank current-token))
      (line-new-line revised-line current-line (line-number current-line))
      (setq valid-tokens 0)))
  (t (error "How many tokens do you think you have?"))))

@

\defun{match-current-token}{match-current-token}
This returns the current token if it has EQ type and (optionally) equal symbol.
\calls{match-current-token}{current-token}
\calls{match-current-token}{match-token}
<<defun match-current-token>>=
(defun match-current-token (type &optional (symbol nil))
  (match-token (current-token) type symbol))

@

\defun{match-token}{match-token}
\calls{match-token}{token-type}
\calls{match-token}{token-symbol}
<<defun match-token>>=
(defun match-token (token type &optional (symbol nil))
  (when (and token (eq (token-type token) type))
   (if symbol
    (when (equal symbol (token-symbol token)) token)
    token)))

@

\defun{match-next-token}{match-next-token}
This returns the next token if it has equal type and (optionally) equal symbol.
\calls{match-next-token}{next-token}
\calls{match-next-token}{match-token}
<<defun match-next-token>>=
(defun match-next-token (type &optional (symbol nil))
  (match-token (next-token) type symbol))

@

\defun{current-symbol}{current-symbol}
\calls{current-symbol}{make-symbol-of}
\calls{current-symbol}{current-token}
<<defun current-symbol>>=
(defun current-symbol ()
 (make-symbol-of (current-token)))

@

\defun{make-symbol-of}{make-symbol-of}
\usesstruct{make-symbol-of}{token}
<<defun make-symbol-of>>=
(defun make-symbol-of (token)
 (let ((u (and token (token-symbol token))))
  (cond
   ((not u) nil)
   ((characterp u) (intern (string u)))
   (u))))

@

\defun{current-token}{current-token}
This returns the current token getting a new one if necessary.
\calls{current-token}{try-get-token}
\uses{current-token}{valid-tokens}
\uses{current-token}{current-token}
<<defun current-token>>=
(defun current-token ()
 (declare (special valid-tokens current-token))
 (if (> valid-tokens 0)
  current-token
  (try-get-token current-token)))

@

\defun{try-get-token}{try-get-token}
\calls{try-get-token}{get-token}
\uses{try-get-token}{valid-tokens}
<<defun try-get-token>>=
(defun try-get-token (token)
 (declare (special valid-tokens))
 (let ((tok (get-token token)))
  (when tok
   (incf valid-tokens)
   token)))

@

\defun{next-token}{next-token}
This returns the token after the current token, or NIL if there is none after.
\calls{next-token}{try-get-token}
\calls{next-token}{current-token}
\uses{next-token}{valid-tokens}
\uses{next-token}{next-token}
<<defun next-token>>=
(defun next-token ()
 (declare (special valid-tokens next-token))
 (current-token)
 (if (> valid-tokens 1)
  next-token
  (try-get-token next-token)))

@

\defun{advance-token}{advance-token}
This makes the next token be the current token.
\calls{advance-token}{current-token}
\calls{advance-token}{copy-token}
\calls{advance-token}{try-get-token}
\uses{advance-token}{valid-tokens}
\uses{advance-token}{current-token}
<<defun advance-token>>=
(defun advance-token ()
  (current-token)                        ;don't know why this is needed
  (case valid-tokens
    (0 (try-get-token (current-token)))
    (1 (decf valid-tokens)
       (setq prior-token (copy-token current-token))
       (try-get-token current-token))
    (2 (setq prior-token (copy-token current-token))
       (setq current-token (copy-token next-token))
       (decf valid-tokens))))

@

\defvar{XTokenReader}
<<initvars>>=
(defvar XTokenReader 'get-meta-token "Name of tokenizing function")

@

\defun{get-token}{get-token}
\calls{get-token}{XTokenReader}
\uses{get-token}{XTokenReader}
<<defun get-token>>=
(defun get-token (token)
 (funcall XTokenReader token))

@

\subsection{Character handling}

\defun{current-char}{current-char}
This returns the current character of the line, initially blank for an 
unread line.
\usesstruct{current-char}{line}
\uses{current-char}{current-line}
<<defun current-char>>=
(defun current-char ()
  (if (line-past-end-p current-line)
   #\return
   (line-current-char current-line)))

@

\defun{next-char}{next-char}
This returns the character after the current character, blank if at
end of line.  The blank-at-end-of-line assumption is allowable because
we assume that end-of-line is a token separator, which blank is
equivalent to.
\calls{next-char}{line-at-end-p}
\calls{next-char}{line-next-char}
\uses{next-char}{current-line}
<<defun next-char>>=
(defun next-char ()
 (if (line-at-end-p current-line) 
  #\return 
  (line-next-char current-line)))

@

\defun{char-eq}{char-eq}
<<defun char-eq>>=
(defun char-eq (x y)
 (char= (character x) (character y)))

@

\defun{char-ne}{char-ne}
<<defun char-ne>>=
(defun char-ne (x y)
 (char/= (character x) (character y)))

@

\subsection{Error handling}
\defvar{meta-error-handler}
<<initvars>>=
(defvar meta-error-handler 'meta-meta-error-handler)

@

\defun{meta-syntax-error}{meta-syntax-error}
\calls{meta-syntax-error}{meta-error-handler}
\uses{meta-syntax-error}{meta-error-handler}
<<defun meta-syntax-error>>=
(defun meta-syntax-error (&optional (wanted nil) (parsing nil))
  (declare (special meta-error-handler))
  (funcall meta-error-handler wanted parsing))

@

\subsection{Floating Point Support}

\defun{floatexpid}{floatexpid}
\calls{floatexpid}{identp}
\calls{floatexpid}{pname}
\calls{floatexpid}{spadreduce}
\calls{floatexpid}{collect}
\calls{floatexpid}{step}
\calls{floatexpid}{maxindex}
\calls{floatexpid}{digitp}
<<defun floatexpid>>=
(defun floatexpid (x &aux s)
 (when (and (identp x) (char= (char-upcase (elt (setq s (pname x)) 0)) #\E)
            (> (length s) 1)
            (spadreduce and 0 (collect (step i 1 1 (maxindex s))
                                       (digitp (elt s i)))))
   (read-from-string s t nil :start 1)))

@

\subsection{Dollar Translation}

\defun{dollarTran}{dollarTran}
\usesdollar{dollarTran}{InteractiveMode}
<<defun dollarTran>>=
(defun |dollarTran| (dom rand)
 (let ((eltWord (if |$InteractiveMode| '|$elt| '|elt|)))
  (declare (special |$InteractiveMode|))
  (if (and (not (atom rand)) (cdr rand))
   (cons (list eltWord dom (car rand)) (cdr rand))
   (list eltWord dom rand))))

@

\subsection{Applying metagrammatical elements of a production (e.g., Star).}
\begin{itemize}
\item {\bf must} means that if it is not present in the token stream, 
it is a syntax error.
\item {\bf optional} means that if it is present in the token stream, 
that is a good thing, otherwise don't worry (like [ foo ] in BNF notation).
\item {\bf action} is something we do as a consequence of successful 
parsing; it is inserted at the end of the conjunction of requirements 
for a successful parse, and so should return T.
\item {\bf sequence} consists of a head, which if recognized implies that the
tail must follow.   Following tail are actions, which
are performed upon recognizing the head and tail.
\end{itemize}
\defmacro{Bang}
If the execution of prod does not result in an increase in the size of
the stack, then stack a NIL. Return the value of prod.
<<defmacro bang>>=
(defmacro bang (lab prod)
 `(progn
   (setf (stack-updated reduce-stack) nil)
   (let* ((prodvalue ,prod) (updated (stack-updated reduce-stack)))
    (unless updated (push-reduction ',lab nil))
    prodvalue)))

@

\defmacro{must}
\calls{must}{meta-syntax-error}
<<defmacro must>>=
(defmacro must (dothis &optional (this-is nil) (in-rule nil))
  `(or ,dothis (meta-syntax-error ,this-is ,in-rule)))

@

\defun{action}{action}
<<defun action>>=
(defun action (dothis) (or dothis t))

@

\defun{optional}{optional}
<<defun optional>>=
(defun optional (dothis) (or dothis t))

@

\defmacro{star}
Succeeds if there are one or more of PROD, stacking as one unit
the sub-reductions of PROD and labelling them with LAB.
E.G., {\tt (Star IDs (parse-id))} with A B C will stack (3 IDs (A B C)),
where (parse-id) would stack (1 ID (A)) when applied once.
\calls{star}{stack-size}
\calls{star}{push-reduction}
\calls{star}{pop-stack-1}
<<defmacro star>>=
(defmacro star (lab prod)
  `(prog ((oldstacksize (stack-size reduce-stack)))
     (if (not ,prod) (return nil))
loop
     (if (not ,prod)
      (let* ((newstacksize (stack-size reduce-stack))
             (number-of-new-reductions (- newstacksize oldstacksize)))
        (if (> number-of-new-reductions 0)
         (return (do ((i 0 (1+ i)) (accum nil))
                     ((= i number-of-new-reductions)
                       (push-reduction ',lab accum)
                       (return t))
                   (push (pop-stack-1) accum)))
         (return t)))
      (go loop))))

@
\subsection{Stacking and retrieving reductions of rules.}

\defun{push-reduction}{push-reduction}
\calls{push-reduction}{stack-push}
\calls{push-reduction}{make-reduction}
\uses{push-reduction}{reduce-stack}
<<defun push-reduction>>=
(defun push-reduction (rule redn)
  (stack-push (make-reduction :rule rule :value redn) reduce-stack))

@

\chapter{Utility Functions}

\defun{addclose}{addclose}
\calls{addclose}{suffix}
<<defun addclose>>=
(defun addclose (line char)
 (cond
  ((char= (char line (maxindex line)) #\; )
    (setelt line (maxindex line) char)
    (if (char= char #\;) line (suffix #\; line)))
  ((suffix char line))))

@

\defun{blankp}{blankp}
<<defun blankp>>=
(defun blankp (char)
 (or (eq char #\Space) (eq char #\tab)))

@

\defun{drop}{drop}
Return a pointer to the Nth cons of X, counting 0 as the first cons.
\calls{drop}{drop}
\calls{drop}{take}
\calls{drop}{croak}
<<defun drop>>=
(defun drop (n x &aux m)
 (cond
  ((eql n 0) x)
  ((> n 0) (drop (1- n) (cdr x)))
  ((>= (setq m (+ (length x) n)) 0) (take m x))
  ((croak (list "Bad args to DROP" n x)))))

@
 
\defun{escaped}{escaped}
<<defun escaped>>=
(defun escaped (str n)
 (and (> n 0) (eq (char str (1- n)) #\_)))

@

\defdollar{comblocklist}
<<initvars>>=
(defvar $comblocklist nil "a dynamic lists of comments for this block")

@
 
\defun{fincomblock}{fincomblock}
\begin{itemize}
\item NUM is the line number of the current line
\item OLDNUMS is the list of line numbers of previous lines
\item OLDLOCS is the list of previous indentation locations
\item NCBLOCK is the current comment block
\end{itemize}
\calls{fincomblock}{preparse-echo}
\usesdollar{fincomblock}{comblocklist}
\usesdollar{fincomblock}{EchoLineStack}
<<defun fincomblock>>=
(defun fincomblock (num oldnums oldlocs ncblock linelist)
 (declare (special $EchoLineStack $comblocklist))
 (push
  (cond 
   ((eql (car ncblock) 0) (cons (1- num) (reverse (cdr ncblock))))
    ;; comment for constructor itself paired with 1st line -1
   (t
    (when $EchoLineStack
     (setq num (pop $EchoLineStack))
     (preparse-echo linelist)
     (setq $EchoLineStack (list num)))
    (cons            ;; scan backwards for line to left of current
     (do ((onums oldnums (cdr onums))
          (olocs oldlocs (cdr olocs))
          (sloc (car ncblock)))
         ((null onums) nil)
       (when (and (numberp (car olocs)) (<= (car olocs) sloc))
         (return (car onums))))
     (reverse (cdr ncblock)))))
   $comblocklist))

@
 
\defun{indent-pos}{indent-pos}
<<defun indent-pos>>=
(defun indent-pos (str)
  (do ((i 0 (1+ i)) (pos 0))
      ((>= i (length str)) nil)
   (case (char str i)
    (#\space (incf pos))
    (#\tab (setq pos (next-tab-loc pos)))
    (otherwise (return pos)))))

@

\defun{infixtok}{infixtok}
\calls{infixtok}{string2id-n}
<<defun infixtok>>=
(defun infixtok (s)
 (member (string2id-n s 1) '(|then| |else|) :test #'eq))

@
 
\defun{is-console}{is-console}
\calls{is-console}{fp-output-stream}
\uses{is-console}{*terminal-io*}
<<defun is-console>>=
(defun is-console (stream)
  (and (streamp stream) (output-stream-p stream)
       (eq (system:fp-output-stream stream)
           (system:fp-output-stream *terminal-io*))))

@

\defun{next-tab-loc}{next-tab-loc}
<<defun next-tab-loc>>=
(defun next-tab-loc (i)
 (* (1+ (truncate i 8)) 8))

@

\defun{nonblankloc}{nonblankloc}
\calls{nonblankloc}{blankp}
<<defun nonblankloc>>=
(defun nonblankloc (str)
 (position-if-not #'blankp str))

@
 
\defun{parseprint}{parseprint}
<<defun parseprint>>=
(defun parseprint (l)
 (when l
  (format t "~&~%       ***       PREPARSE      ***~%~%")
  (dolist (x l) (format t "~5d. ~a~%" (car x) (cdr x)))
  (format t "~%")))
 
@

\defun{skip-to-endif}{skip-to-endif}
\calls{skip-to-endif}{initial-substring}
\calls{skip-to-endif}{preparseReadLine}
\calls{skip-to-endif}{preparseReadLine1}
\calls{skip-to-endif}{skip-to-endif}
<<defun skip-to-endif>>=
(defun skip-to-endif (x)
 (let (line ind)
  (dcq (ind . line) (preparseReadLine1))
  (cond
   ((not (stringp line)) (cons ind line))
   ((initial-substring line ")endif") (preparseReadLine x))
   ((initial-substring line ")fin") (cons ind nil))
   (t (skip-to-endif x)))))

@
 
\chapter{The Compiler}

\section{Compiling EQ.spad}
Given the top level command:
\begin{verbatim}
)co EQ
\end{verbatim}
The default call chain looks like:
\begin{verbatim}
1> (|compiler| ...)
 2> (|compileSpad2Cmd| ...)
   Compiling AXIOM source code from file /tmp/A.spad using old system 
      compiler.
  3> (|compilerDoit| ...)
   4> (|/RQ,LIB|)
    5> (/RF-1 ...)
     6> (SPAD ...)
   AXSERV abbreviates package AxiomServer 
      7> (S-PROCESS ...)
       8> (|compTopLevel| ...)
        9> (|compOrCroak| ...)
         10> (|compOrCroak1| ...)
          11> (|comp| ...)
           12> (|compNoStacking| ...)
            13> (|comp2| ...)
             14> (|comp3| ...)
              15> (|compExpression| ...)
*              16> (|compWhere| ...)
                17> (|comp| ...)
                 18> (|compNoStacking| ...)
                  19> (|comp2| ...)
                   20> (|comp3| ...)
                    21> (|compExpression| ...)
                     22> (|compSeq| ...)
                      23> (|compSeq1| ...)
                       24> (|compSeqItem| ...)
                        25> (|comp| ...)
                         26> (|compNoStacking| ...)
                          27> (|comp2| ...)
                           28> (|comp3| ...)
                            29> (|compExpression| ...)
                            <29 (|compExpression| ...)
                           <28 (|comp3| ...)
                          <27 (|comp2| ...)
                         <26 (|compNoStacking| ...)
                        <25 (|comp| ...)
                       <24 (|compSeqItem| ...)
                       24> (|compSeqItem| ...)
                        25> (|comp| ...)
                         26> (|compNoStacking| ...)
                          27> (|comp2| ...)
                           28> (|comp3| ...)
                            29> (|compExpression| ...)
                             30> (|compExit| ...)
                              31> (|comp| ...)
                               32> (|compNoStacking| ...)
                                33> (|comp2| ...)
                                 34> (|comp3| ...)
                                  35> (|compExpression| ...)
                                  <35 (|compExpression| ...)
                                 <34 (|comp3| ...)
                                <33 (|comp2| ...)
                               <32 (|compNoStacking| ...)
                              <31 (|comp| ...)
                              31> (|modifyModeStack| ...)
                              <31 (|modifyModeStack| ...)
                             <30 (|compExit| ...)
                            <29 (|compExpression| ...)
                           <28 (|comp3| ...)
                          <27 (|comp2| ...)
                         <26 (|compNoStacking| ...)
                        <25 (|comp| ...)
                       <24 (|compSeqItem| ...)
                       24> (|replaceExitEtc| ...)
                        25> (|replaceExitEtc,fn| ...)
                         26> (|replaceExitEtc| ...)
                          27> (|replaceExitEtc,fn| ...)
                           28> (|replaceExitEtc| ...)
                            29> (|replaceExitEtc,fn| ...)
                            <29 (|replaceExitEtc,fn| ...)
                           <28 (|replaceExitEtc| ...)
                           28> (|replaceExitEtc| ...)
                            29> (|replaceExitEtc,fn| ...)
                            <29 (|replaceExitEtc,fn| ...)
                           <28 (|replaceExitEtc| ...)
                          <27 (|replaceExitEtc,fn| ...)
                         <26 (|replaceExitEtc| ...)
                         26> (|replaceExitEtc| ...)
                          27> (|replaceExitEtc,fn| ...)
                           28> (|replaceExitEtc| ...)
                            29> (|replaceExitEtc,fn| ...)
                             30> (|replaceExitEtc| ...)
                              31> (|replaceExitEtc,fn| ...)
                               32> (|replaceExitEtc| ...)
                                33> (|replaceExitEtc,fn| ...)
                                <33 (|replaceExitEtc,fn| ...)
                               <32 (|replaceExitEtc| ...)
                               32> (|replaceExitEtc| ...)
                                33> (|replaceExitEtc,fn| ...)
                                <33 (|replaceExitEtc,fn| ...)
                               <32 (|replaceExitEtc| ...)
                              <31 (|replaceExitEtc,fn| ...)
                             <30 (|replaceExitEtc| ...)
                             30> (|convertOrCroak| ...)
                              31> (|convert| ...)
                              <31 (|convert| ...)
                             <30 (|convertOrCroak| ...)
                            <29 (|replaceExitEtc,fn| ...)
                           <28 (|replaceExitEtc| ...)
                           28> (|replaceExitEtc| ...)
                            29> (|replaceExitEtc,fn| ...)
                            <29 (|replaceExitEtc,fn| ...)
                           <28 (|replaceExitEtc| ...)
                          <27 (|replaceExitEtc,fn| ...)
                         <26 (|replaceExitEtc| ...)
                        <25 (|replaceExitEtc,fn| ...)
                       <24 (|replaceExitEtc| ...)
                      <23 (|compSeq1| ...)
                     <22 (|compSeq| ...)
                    <21 (|compExpression| ...)
                   <20 (|comp3| ...)
                  <19 (|comp2| ...)
                 <18 (|compNoStacking| ...)
                <17 (|comp| ...)
                17> (|comp| ...)
                 18> (|compNoStacking| ...)
                  19> (|comp2| ...)
                   20> (|comp3| ...)
                    21> (|compExpression| ...)
                     22> (|comp| ...)
                      23> (|compNoStacking| ...)
                       24> (|comp2| ...)
                        25> (|comp3| ...)
                         26> (|compColon| ...)
                         <26 (|compColon| ...)
                        <25 (|comp3| ...)
                       <24 (|comp2| ...)
                      <23 (|compNoStacking| ...)
                     <22 (|comp| ...)
\end{verbatim}

In order to explain the compiler we will walk through the compilation of
EQ.spad, which handles equations as mathematical objects. We start the
system. Most of the structure in Axiom are circular so we have to the
\verb|*print-cycle*| to true.
\begin{verbatim}
root@spiff:/tmp# axiom -nox

(1) -> )lisp (setq *print-circle* t)

Value = T
\end{verbatim}

We trace the function we find interesting:
\begin{verbatim}
(1) -> )lisp (trace |compiler|)

Value = (|compiler|)
\end{verbatim}

\defunsec{compiler}{The top level compiler command}
We compile the spad file. We can see that the {\bf compiler} function gets
a list 
\begin{verbatim}
(1) -> )co EQ

  1> (|compiler| (EQ))
\end{verbatim}
In order to find this file, the {\bf pathname} and {\bf pathnameType} 
functions are used to find the location and pathname to the file. They
{\bf pathnameType} function eventually returns the fact that this is
a spad source file. Once that is known we call the {\bf compileSpad2Cmd}
function with a list containing the full pathname as a string.
\begin{verbatim}
  1> (|compiler| (EQ))
    2> (|pathname| (EQ))
    <2 (|pathname| #p"EQ")
    2> (|pathnameType| #p"EQ")
      3> (|pathname| #p"EQ")
      <3 (|pathname| #p"EQ")
    <2 (|pathnameType| NIL)
    2> (|pathnameType| "/tmp/EQ.spad")
      3> (|pathname| "/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|pathnameType| "spad")
    2> (|pathnameType| "/tmp/EQ.spad")
      3> (|pathname| "/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|pathnameType| "spad")
    2> (|pathnameType| "/tmp/EQ.spad")
      3> (|pathname| "/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|pathnameType| "spad")
    2> (|compileSpad2Cmd| ("/tmp/EQ.spad"))
\end{verbatim}

\calls{compiler}{helpSpad2Cmd(5)}
\calls{compiler}{selectOptionLC(5)}
\calls{compiler}{pathname(5)}
\calls{compiler}{mergePathnames(5)}
\calls{compiler}{pathnameType(5)}
\calls{compiler}{namestring(5)}
\calls{compiler}{throwKeyedMsg}
\calls{compiler}{findfile}
\calls{compiler}{compileSpad2Cmd}
\calls{compiler}{compileSpadLispCmd}
\usesdollar{compiler}{newConlist}
\usesdollar{compiler}{options}
\uses{compiler}{/editfile}
<<defun compiler>>=
(defun |compiler| (args)
 "The top level compiler command"
 (let (|$newConlist| optlist optname optargs havenew haveold aft ef af af1)
  (declare (special |$newConlist| |$options| /editfile))
  (setq |$newConlist| nil)
  (cond
   ((and (null args) (null |$options|) (null /editfile))
     (|helpSpad2Cmd| '(|compiler|)))
   (t
    (cond ((null args) (setq args (cons /editfile nil))))
    (setq optlist '(|new| |old| |translate| |constructor|))
    (setq havenew nil)
    (setq haveold nil)
    (do ((t0 |$options| (cdr t0)) (opt nil))
        ((or (atom t0) 
             (progn (setq opt (car t0)) nil)
             (null (null (and havenew haveold))))
          nil)
     (setq optname (car opt))
     (setq optargs (cdr opt))
     (case (|selectOptionLC| optname optlist nil)
      (|new|         (setq havenew t))
      (|translate|   (setq haveold t))
      (|constructor| (setq haveold t))
      (|old|         (setq haveold t))))
    (cond
     ((and havenew haveold) (|throwKeyedMsg| 's2iz0081 nil))
     (t
      (setq af (|pathname| args))
      (setq aft (|pathnameType| af))
      (cond
       ((or haveold (string= aft "spad"))
        (if (null (setq af1 ($findfile af '(|spad|))))
           (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
           (|compileSpad2Cmd| (cons af1 nil))))
       ((string= aft "nrlib")
        (if (null (setq af1 ($findfile af '(|nrlib|))))
          (|throwKeyedMsg| 'S2IL0003 (cons (namestring af) nil))
          (|compileSpadLispCmd| (cons af1 nil))))
       (t
        (setq af1 ($findfile af '(|spad|)))
        (cond
         ((and af1 (string= (|pathnameType| af1) "spad"))
          (|compileSpad2Cmd| (cons af1 nil)))
         (t
          (setq ef (|pathname| /editfile))
          (setq ef (|mergePathnames| af ef))
          (cond
           ((boot-equal ef af) (|throwKeyedMsg| 's2iz0039 nil))
           (t
            (setq af ef)
            (cond
             ((string= (|pathnameType| af) "spad")
              (|compileSpad2Cmd| args))
             (t
              (setq af1 ($findfile af '(|spad|)))
              (cond
               ((and af1 (string= (|pathnameType| af1) "spad"))
                 (|compileSpad2Cmd| (cons af1 nil)))
               (t (|throwKeyedMsg| 's2iz0039 nil)))))))))))))))))

@

\defunsec{compileSpad2Cmd}{The Spad compiler top level function}
The argument to this function, as noted above, is a list containing
the string pathname to the file.
\begin{verbatim}
    2> (|compileSpad2Cmd| ("/tmp/EQ.spad"))
\end{verbatim}
There is a fair bit of redundant work to find the full filename and pathname
of the file. This needs to be eliminated.

The trace of the functions in this routines is:
\begin{verbatim}
  1> (|selectOptionLC| "compiler" (|abbreviations| |boot| |browse| |cd| |clear| |close| |compiler| |copyright| |credits| |describe| |display| |edit| |fin| |frame| |help| |history| |lisp| |library| |load| |ltrace| |pquit| |quit| |read| |savesystem| |set| |show| |spool| |summary| |synonym| |system| |trace| |trademark| |undo| |what| |with| |workfiles| |zsystemdevelopment|) |commandErrorIfAmbiguous|)
  <1 (|selectOptionLC| |compiler|)
  1> (|selectOptionLC| |compiler| (|abbreviations| |boot| |browse| |cd| |clear| |close| |compiler| |copyright| |credits| |describe| |display| |edit| |fin| |frame| |help| |history| |lisp| |library| |load| |ltrace| |pquit| |quit| |read| |savesystem| |set| |show| |spool| |summary| |synonym| |system| |trace| |trademark| |undo| |what| |with| |workfiles| |zsystemdevelopment|) |commandError|)
  <1 (|selectOptionLC| |compiler|)
  1> (|pathname| (EQ))
  <1 (|pathname| #p"EQ")
  1> (|pathnameType| #p"EQ")
    2> (|pathname| #p"EQ")
    <2 (|pathname| #p"EQ")
  <1 (|pathnameType| NIL)
  1> (|pathnameType| "/tmp/EQ.spad")
    2> (|pathname| "/tmp/EQ.spad")
    <2 (|pathname| #p"/tmp/EQ.spad")
  <1 (|pathnameType| "spad")
  1> (|pathnameType| "/tmp/EQ.spad")
    2> (|pathname| "/tmp/EQ.spad")
    <2 (|pathname| #p"/tmp/EQ.spad")
  <1 (|pathnameType| "spad")
  1> (|pathnameType| "/tmp/EQ.spad")
    2> (|pathname| "/tmp/EQ.spad")
    <2 (|pathname| #p"/tmp/EQ.spad")
  <1 (|pathnameType| "spad")
  1> (|compileSpad2Cmd| ("/tmp/EQ.spad"))
    2> (|pathname| ("/tmp/EQ.spad"))
    <2 (|pathname| #p"/tmp/EQ.spad")
    2> (|pathnameType| #p"/tmp/EQ.spad")
      3> (|pathname| #p"/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|pathnameType| "spad")
    2> (|updateSourceFiles| #p"/tmp/EQ.spad")
      3> (|pathname| #p"/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
      3> (|pathname| #p"/tmp/EQ.spad")
      <3 (|pathname| #p"/tmp/EQ.spad")
      3> (|pathnameType| #p"/tmp/EQ.spad")
        4> (|pathname| #p"/tmp/EQ.spad")
        <4 (|pathname| #p"/tmp/EQ.spad")
      <3 (|pathnameType| "spad")
      3> (|pathname| ("EQ" "spad" "*"))
      <3 (|pathname| #p"EQ.spad")
      3> (|pathnameType| #p"EQ.spad")
        4> (|pathname| #p"EQ.spad")
        <4 (|pathname| #p"EQ.spad")
      <3 (|pathnameType| "spad")
    <2 (|updateSourceFiles| #p"EQ.spad")
    2> (|namestring| ("/tmp/EQ.spad"))
      3> (|pathname| ("/tmp/EQ.spad"))
      <3 (|pathname| #p"/tmp/EQ.spad")
    <2 (|namestring| "/tmp/EQ.spad")
   Compiling AXIOM source code from file /tmp/EQ.spad using old system 
      compiler.
\end{verbatim}

Again we find a lot of redundant work. We finally end up calling
{\bf compilerDoit} with a constructed argument list:
\begin{verbatim}
    2> (|compilerDoit| NIL (|rq| |lib|))
\end{verbatim}


\calls{compileSpad2Cmd}{pathname(5)}
\calls{compileSpad2Cmd}{pathnameType(5)}
\calls{compileSpad2Cmd}{namestring(5)}
\calls{compileSpad2Cmd}{updateSourceFiles(5)}
\calls{compileSpad2Cmd}{selectOptionLC(5)}
\calls{compileSpad2Cmd}{terminateSystemCommand(5)}
\calls{compileSpad2Cmd}{nequal}
\calls{compileSpad2Cmd}{throwKeyedMsg}
\calls{compileSpad2Cmd}{sayKeyedMsg}
\calls{compileSpad2Cmd}{error}
\calls{compileSpad2Cmd}{strconc}
\calls{compileSpad2Cmd}{object2String}
\calls{compileSpad2Cmd}{oldParserAutoloadOnceTrigger}
\calls{compileSpad2Cmd}{browserAutoloadOnceTrigger}
\calls{compileSpad2Cmd}{spad2AsTranslatorAutoloadOnceTrigger}
\calls{compileSpad2Cmd}{convertSpadToAsFile}
\calls{compileSpad2Cmd}{compilerDoitWithScreenedLisplib}
\calls{compileSpad2Cmd}{compilerDoit}
\calls{compileSpad2Cmd}{extendLocalLibdb}
\calls{compileSpad2Cmd}{spadPrompt}
\usesdollar{compileSpad2Cmd}{newComp}
\usesdollar{compileSpad2Cmd}{scanIfTrue}
\usesdollar{compileSpad2Cmd}{compileOnlyCertainItems}
\usesdollar{compileSpad2Cmd}{f}
\usesdollar{compileSpad2Cmd}{m}
\usesdollar{compileSpad2Cmd}{QuickLet}
\usesdollar{compileSpad2Cmd}{QuickCode}
\usesdollar{compileSpad2Cmd}{sourceFileTypes}
\usesdollar{compileSpad2Cmd}{InteractiveMode}
\usesdollar{compileSpad2Cmd}{options}
\usesdollar{compileSpad2Cmd}{newConlist}
\uses{compileSpad2Cmd}{/editfile}
<<defun compileSpad2Cmd>>=
(defun |compileSpad2Cmd| (args)
 (let (|$newComp| |$scanIfTrue| 
       |$compileOnlyCertainItems| |$f| |$m| |$QuickLet| |$QuickCode| 
       |$sourceFileTypes| |$InteractiveMode| path optlist fun optname 
       optargs fullopt constructor)
  (declare (special |$newComp| |$scanIfTrue| 
       |$compileOnlyCertainItems| |$f| |$m| |$QuickLet| |$QuickCode| 
       |$sourceFileTypes| |$InteractiveMode| /editfile |$options|
       |$newConlist|)) 
   (setq path (|pathname| args))
   (cond
    ((nequal (|pathnameType| path) "spad") (|throwKeyedMsg| 's2iz0082 nil))
    ((null (probe-file path))
     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
    (t
     (setq /editfile path)
     (|updateSourceFiles| path)
     (|sayKeyedMsg| 's2iz0038 (list (|namestring| args)))
     (setq optlist '(|break| |constructor| |functions| |library| |lisp|
         |new| |old| |nobreak| |nolibrary| |noquiet| |vartrace| |quiet|
         |translate|))
     (setq |$QuickLet| t)
     (setq |$QuickCode| t)
     (setq fun '(|rq| |lib|))
     (setq |$sourceFileTypes| '("SPAD"))
     (dolist (opt |$options|)
      (setq optname (car opt))
      (setq optargs (cdr opt))
      (setq fullopt (|selectOptionLC| optname optlist nil))
      (case fullopt
       (|old| nil)
       (|library| (setelt fun 1 '|lib|))
       (|nolibrary| (setelt fun 1 '|nolib|))
       (|quiet| (when (nequal (elt fun 0) '|c|) (setelt fun 0 '|rq|)))
       (|noquiet| (when (nequal (elt fun 0) '|c|) (setelt fun 0 '|rf|)))
       (|nobreak| (setq |$scanIfTrue| t))
       (|break| (setq |$scanIfTrue| nil))
       (|vartrace| (setq |$QuickLet| nil))
       (|lisp| (|throwKeyedMsg| 's2iz0036 (list ")lisp")))
       (|functions|
        (if (null optargs) 
         (|throwKeyedMsg| 's2iz0037 (list ")functions"))
         (setq |$compileOnlyCertainItems| optargs)))
       (|constructor|
        (if (null optargs)
         (|throwKeyedMsg| 's2iz0037 (list ")constructor"))
         (progn
          (setelt fun 0 '|c|)
          (setq constructor (mapcar #'|unabbrev| optargs)))))
       (t
        (|throwKeyedMsg| 's2iz0036 
         (list (strconc ")" (|object2String| optname)))))))
    (setq |$InteractiveMode| nil)
    (cond
     (|$compileOnlyCertainItems|
      (if (null constructor)
       (|sayKeyedMsg| 's2iz0040 nil)
       (|compilerDoitWithScreenedLisplib| constructor fun)))
     (t (|compilerDoit| constructor fun)))
    (|extendLocalLibdb| |$newConlist|)
    (|terminateSystemCommand|)
    (|spadPrompt|)))))

@

This trivial function cases on the second argument to decide which 
combination of operations was requested. For this case we see:
\begin{verbatim}
(1) -> )co EQ
   Compiling AXIOM source code from file /tmp/EQ.spad using old system 
      compiler.
  1> (|compilerDoit| NIL (|rq| |lib|))
    2> (|/RQ,LIB|)

... [snip]...

    <2 (|/RQ,LIB| T)
  <1 (|compilerDoit| T)
(1) -> 
\end{verbatim}

\defun{compilerDoit}{compilerDoit}
\calls{compilerDoit}{/rq}
\calls{compilerDoit}{/rf(5)}
\calls{compilerDoit}{member(5)}
\calls{compilerDoit}{sayBrightly}
\calls{compilerDoit}{opOf}
\calls{compilerDoit}{/RQ,LIB}
\usesdollar{compilerDoit}{byConstructors}
\usesdollar{compilerDoit}{constructorsSeen}
<<defun compilerDoit>>=
(defun |compilerDoit| (constructor fun)
 (let (|$byConstructors| |$constructorsSeen|)
 (declare (special |$byConstructors| |$constructorsSeen|))
  (cond
   ((equal fun '(|rf| |lib|))   (|/RQ,LIB|))   ; Ignore "noquiet"
   ((equal fun '(|rf| |nolib|)) (/rf))
   ((equal fun '(|rq| |lib|))   (|/RQ,LIB|))
   ((equal fun '(|rq| |nolib|)) (/rq))
   ((equal fun '(|c| |lib|))
    (setq |$byConstructors| (loop for x in constructor collect (|opOf| x)))
    (|/RQ,LIB|)
    (dolist (x |$byConstructors|)
     (unless (|member| x |$constructorsSeen|)
      (|sayBrightly| `(">>> Warning " |%b| ,x |%d| " was not found"))))))))

@

This function simply calls {\bf \verb|/rf-1|}. 
\begin{verbatim}
(2) -> )co EQ
   Compiling AXIOM source code from file /tmp/EQ.spad using old system 
      compiler.
  1> (|compilerDoit| NIL (|rq| |lib|))
    2> (|/RQ,LIB|)
      3> (/RF-1 NIL)
...[snip]...
      <3 (/RF-1 T)
    <2 (|/RQ,LIB| T)
  <1 (|compilerDoit| T)
\end{verbatim}

\defun{/RQ,LIB}{/RQ,LIB}
\calls{/RQ,LIB}{/rf-1}
\uses{/RQ,LIB}{echo-meta(5)}
\usesdollar{/RQ,LIB}{lisplib}
<<defun /RQ,LIB>>=
(defun |/RQ,LIB| (&rest foo &aux (echo-meta nil) ($lisplib t))
 (declare (special echo-meta $lisplib) (ignore foo))
  (/rf-1 nil))

@
 
Since this function is called with nil we fall directly into the
call to the function {\bf spad}:
\begin{verbatim}
(2) -> )co EQ
   Compiling AXIOM source code from file /tmp/EQ.spad using old system 
      compiler.
  1> (|compilerDoit| NIL (|rq| |lib|))
    2> (|/RQ,LIB|)
      3> (/RF-1 NIL)
        4> (SPAD "/tmp/EQ.spad")
...[snip]...
        <4 (SPAD T)
      <3 (/RF-1 T)
    <2 (|/RQ,LIB| T)
  <1 (|compilerDoit| T)
\end{verbatim}

\defun{/rf-1}{/rf-1}
\calls{/rf-1}{makeInputFilename(5)}
\calls{/rf-1}{ncINTERPFILE}
\calls{/rf-1}{spad}
\uses{/rf-1}{/editfile}
\uses{/rf-1}{echo-meta}
<<defun /rf-1>>=
(defun /rf-1 (ignore)
 (declare (ignore ignore))
 (let* ((input-file (makeInputFilename /editfile))
        (type (pathname-type input-file)))
 (declare (special echo-meta /editfile))
 (cond
  ((string= type "lisp") (load input-file))
  ((string= type "input") (|ncINTERPFILE| input-file echo-meta))
  (t (spad input-file)))))

@

Here we begin the actual compilation process. 
\begin{verbatim}
  1> (SPAD "/tmp/EQ.spad")
    2> (|makeInitialModemapFrame|)
    <2 (|makeInitialModemapFrame| ((NIL)))
    2> (INIT-BOOT/SPAD-READER)
    <2 (INIT-BOOT/SPAD-READER NIL)
    2> (OPEN "/tmp/EQ.spad" :DIRECTION :INPUT)
    <2 (OPEN #<input stream "/tmp/EQ.spad">)
    2> (INITIALIZE-PREPARSE #<input stream "/tmp/EQ.spad">)
    <2 (INITIALIZE-PREPARSE ")abbrev domain EQ Equation")
    2> (PREPARSE #<input stream "/tmp/EQ.spad">)
   EQ abbreviates domain Equation 
    <2 (PREPARSE (# # # # # # # # ...))
    2> (|PARSE-NewExpr|)
    <2 (|PARSE-NewExpr| T)
    2> (S-PROCESS (|where| # #))
...[snip]...
      3> (OPEN "/tmp/EQ.erlib/info" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.erlib/info">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.lsp")
      <3 (OPEN #<input stream "/tmp/EQ.nrlib/EQ.lsp">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.data" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.data">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.c" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.c">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.h" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.h">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.fn" :DIRECTION :OUTPUT)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.fn">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.o" :DIRECTION :OUTPUT :IF-EXISTS :APPEND)
      <3 (OPEN #<output stream "/tmp/EQ.nrlib/EQ.o">)
      3> (OPEN #p"/tmp/EQ.nrlib/EQ.data")
      <3 (OPEN #<input stream "/tmp/EQ.nrlib/EQ.data">)
      3> (OPEN "/tmp/EQ.nrlib/index.kaf")
      <3 (OPEN #<input stream "/tmp/EQ.nrlib/index.kaf">)
    <2 (S-PROCESS NIL)
  <1 (SPAD T)
  1> (OPEN "temp.text" :DIRECTION :OUTPUT)
  <1 (OPEN #<output stream "temp.text">)
  1> (OPEN "libdb.text")
  <1 (OPEN #<input stream "libdb.text">)
  1> (OPEN "temp.text")
  <1 (OPEN #<input stream "temp.text">)
  1> (OPEN "libdb.text" :DIRECTION :OUTPUT)
  <1 (OPEN #<output stream "libdb.text">)
\end{verbatim}

The major steps in this process involve the {\bf preparse} function.
(See book volume 5 for more details).
The {\bf preparse} function  returns a list of pairs of the form:
( (linenumber . linestring) .... (linenumber . linestring))
For instance, for the file {\tt EQ.spad}, we get:
\begin{verbatim}
    <2 (PREPARSE (
 (19 . "Equation(S: Type): public == private where")
 (20 . " (Ex ==> OutputForm;")
 (21 . "  public ==> Type with")
 (22 . "   (\"=\": (S, S) -> $;")
...[skip]...
 (202 . "        inv eq == [inv lhs eq, inv rhs eq]);")
 (203 . "    if S has ExpressionSpace then")
 (204 . "        subst(eq1,eq2) ==")
 (205 . "           (eq3 := eq2 pretend Equation S;")
 (206 . "            [subst(lhs eq1,eq3),subst(rhs eq1,eq3)])))")))
\end{verbatim}

And the {\bf s-process} function which returns a parsed version of the input.
\begin{verbatim}
    2> (S-PROCESS
(|where|
 (== (|:| (|Equation| (|:| S |Type|)) |public|) |private|)
 (|;|
  (|;|
   (==> |Ex| |OutputForm|)
   (==> |public|
    (|Join| |Type|
     (|with|
      (CATEGORY
       (|Signature| "=" (-> (|,| S S) $))
       (|Signature| |equation| (-> (|,| S S) $))
       (|Signature| |swap| (-> $ $))
       (|Signature| |lhs| (-> $ S))
       (|Signature| |rhs| (-> $ S))
       (|Signature| |map| (-> (|,| (-> S S) $) $))
       (|if| (|has| S (|InnerEvalable| (|,| |Symbol| S)))
        (|Attribute| (|InnerEvalable| (|,| |Symbol| S)))
        NIL)
       (|if| (|has| S |SetCategory|)
        (CATEGORY 
         (|Attribute| |SetCategory|)
         (|Attribute| (|CoercibleTo| |Boolean|))
         (|if| (|has| S (|Evalable| S))
          (CATEGORY
           (|Signature| |eval| (-> (|,| $ $) $))
           (|Signature| |eval| (-> (|,| $ (|List| $)) $)))
          NIL))
        NIL) 
       (|if| (|has| S |AbelianSemiGroup|)
        (CATEGORY
         (|Attribute| |AbelianSemiGroup|)
         (|Signature| "+" (-> (|,| S $) $))
         (|Signature| "+" (-> (|,| $ S) $)))
         NIL)
       (|if| (|has| S |AbelianGroup|)
        (CATEGORY
         (|Attribute| |AbelianGroup|)
         (|Signature| |leftZero| (-> $ $))
         (|Signature| |rightZero| (-> $ $))
         (|Signature| "-" (-> (|,| S $) $))
         (|Signature| "-" (-> (|,| $ S) $))) NIL)
       (|if| (|has| S |SemiGroup|)
        (CATEGORY
         (|Attribute| |SemiGroup|)
         (|Signature| "*" (-> (|,| S $) $))
         (|Signature| "*" (-> (|,| $ S) $)))
        NIL)
       (|if| (|has| S |Monoid|)
        (CATEGORY
         (|Attribute| |Monoid|)
         (|Signature| |leftOne| (-> $ (|Union| (|,| $ "failed"))))
         (|Signature| |rightOne| (-> $ (|Union| (|,| $ "failed")))))
        NIL)
       (|if| (|has| S |Group|)
        (CATEGORY
         (|Attribute| |Group|)
         (|Signature| |leftOne| (-> $ (|Union| (|,| $ "failed"))))
         (|Signature| |rightOne| (-> $ (|Union| (|,| $ "failed")))))
         NIL)
       (|if| (|has| S |Ring|)
        (CATEGORY
         (|Attribute| |Ring|)
         (|Attribute| (|BiModule| (|,| S S))))
        NIL)
       (|if| (|has| S |CommutativeRing|)
        (|Attribute| (|Module| S))
        NIL)
       (|if| (|has| S |IntegralDomain|)
        (|Signature| |factorAndSplit| (-> $ (|List| $)))
        NIL)
       (|if| (|has| S (|PartialDifferentialRing| |Symbol|))
        (|Attribute| (|PartialDifferentialRing| |Symbol|))
        NIL)
       (|if| (|has| S |Field|)
        (CATEGORY
         (|Attribute| (|VectorSpace| S))
         (|Signature| "/" (-> (|,| $ $) $))
         (|Signature| |inv| (-> $ $)))
        NIL)
       (|if| (|has| S |ExpressionSpace|)
        (|Signature| |subst| (-> (|,| $ $) $))
        NIL)
    )))))
  (==> |private|
   (|add|
    (|;|
     (|;|
      (|;|
       (|;|
        (|;|
         (|;|
          (|;|
           (|;|
            (|;|
             (|;|
              (|;|
               (|;|
                (|;|
                 (|;|
                  (|;|
                   (|;|
                    (|;|
                     (|;|
                      (|;|
                       (|;|
                        (|;|
                         (|;|
                          (|:=| |Rep|
                           (|Record| (|,| (|:| |lhs| S) (|:| |rhs| S))))
                          (|,| |eq1| (|:| |eq2| $)))
                         (|:| |s| S))
                        (|if| (|has| S |IntegralDomain|)
                         (==
                          (|factorAndSplit| |eq|)
                          (|;|
                           (=> (|has| S (|:| |factor| (-> S (|Factored| S))))
                            (|;|
                             (|:=| |eq0| (|rightZero| |eq|))
                             (COLLECT
                              (IN |rcf| (|factors| (|factor| (|lhs| |eq0|))))
                              (|construct|
                               (|equation| (|,| (|rcf| |factor|) 0))))))
                           (|construct| |eq|)))
                         NIL))
                       (==
                        (= (|:| |l| S) (|:| |r| S))
                        (|construct| (|,| |l| |r|))))
                      (==
                       (|equation| (|,| |l| |r|))
                       (|construct| (|,| |l| |r|))))
                     (== (|lhs| |eqn|) (|eqn| |lhs|)))
                    (== (|rhs| |eqn|) (|eqn| |rhs|)))
                   (== 
                    (|swap| |eqn|)
                    (|construct| (|,| (|rhs| |eqn|) (|lhs| |eqn|)))))
                  (==
                   (|map| (|,| |fn| |eqn|))
                   (|equation|
                    (|,| (|fn| (|eqn| |lhs|)) (|fn| (|eqn| |rhs|))))))
                 (|if| (|has| S (|InnerEvalable| (|,| |Symbol| S)))
                  (|;|
                   (|;|
                    (|;|
                     (|;|
                      (|;| (|:| |s| |Symbol|) (|:| |ls| (|List| |Symbol|)))
                      (|:| |x| S))
                     (|:| |lx| (|List| S)))
                    (== 
                     (|eval| (|,| (|,| |eqn| |s|) |x|))
                     (= 
                      (|eval| (|,| (|,| (|eqn| |lhs|) |s|) |x|))
                      (|eval| (|,| (|,| (|eqn| |rhs|) |s|) |x|)))))
                   (==
                    (|eval| (|,| (|,| |eqn| |ls|) |lx|))
                    (=
                     (|eval| (|,| (|,| (|eqn| |lhs|) |ls|) |lx|))
                     (|eval| (|,| (|,| (|eqn| |rhs|) |ls|) |lx|)))))
                  NIL))
                (|if| (|has| S (|Evalable| S))
                 (|;|
                  (==
                   (|:| (|eval| (|,| (|:| |eqn1| $) (|:| |eqn2| $))) $)
                   (=
                    (|eval| 
                     (|,| (|eqn1| |lhs|) (|pretend| |eqn2| (|Equation| S))))
                    (|eval| 
                     (|,| (|eqn1| |rhs|) (|pretend| |eqn2| (|Equation| S))))))
                  (==
                   (|:| 
                    (|eval| (|,| (|:| |eqn1| $) (|:| |leqn2| (|List| $)))) $)
                   (=
                    (|eval|
                     (|,| 
                      (|eqn1| |lhs|)
                      (|pretend| |leqn2| (|List| (|Equation| S)))))
                    (|eval| 
                     (|,|
                      (|eqn1| |rhs|)
                      (|pretend| |leqn2| (|List| (|Equation| S))))))))
                 NIL))
               (|if| (|has| S |SetCategory|)
                (|;|
                 (|;|
                  (==
                   (= |eq1| |eq2|)
                   (|and|
                    (@ (= (|eq1| |lhs|) (|eq2| |lhs|)) |Boolean|)
                    (@ (= (|eq1| |rhs|) (|eq2| |rhs|)) |Boolean|)))
                  (==
                   (|:| (|coerce| (|:| |eqn| $)) |Ex|)
                   (= (|::| (|eqn| |lhs|) |Ex|) (|::| (|eqn| |rhs|) |Ex|))))
                 (==
                  (|:| (|coerce| (|:| |eqn| $)) |Boolean|)
                  (= (|eqn| |lhs|) (|eqn| |rhs|))))
                NIL))
              (|if| (|has| S |AbelianSemiGroup|)
               (|;|
                (|;|
                 (==
                  (+ |eq1| |eq2|)
                  (= 
                   (+ (|eq1| |lhs|) (|eq2| |lhs|))
                   (+ (|eq1| |rhs|) (|eq2| |rhs|))))
                 (== (+ |s| |eq2|) (+ (|construct| (|,| |s| |s|)) |eq2|)))
                (== (+ |eq1| |s|) (+ |eq1| (|construct| (|,| |s| |s|)))))
               NIL))
             (|if| (|has| S |AbelianGroup|)
              (|;|
               (|;|
                (|;|
                 (|;|
                  (|;|
                   (|;|
                    (== (- |eq|) (= (- (|lhs| |eq|)) (- (|rhs| |eq|))))
                    (== (- |s| |eq2|) (- (|construct| (|,| |s| |s|)) |eq2|)))
                   (== (- |eq1| |s|) (- |eq1| (|construct| (|,| |s| |s|)))))
                  (== (|leftZero| |eq|) (= 0 (- (|rhs| |eq|) (|lhs| |eq|)))))
                 (== (|rightZero| |eq|) (= (- (|lhs| |eq|) (|rhs| |eq|)) 0)))
                (== 0 (|equation| (|,| (|elt| S 0) (|elt| S 0)))))
               (==
                (- |eq1| |eq2|)
                (=
                 (- (|eq1| |lhs|) (|eq2| |lhs|))
                 (- (|eq1| |rhs|) (|eq2| |rhs|)))))
              NIL))
            (|if| (|has| S |SemiGroup|)
             (|;|
              (|;|
               (|;|
                (==
                 (* (|:| |eq1| $) (|:| |eq2| $))
                 (=
                  (* (|eq1| |lhs|) (|eq2| |lhs|))
                  (* (|eq1| |rhs|) (|eq2| |rhs|))))
                (==
                 (* (|:| |l| S) (|:| |eqn| $))
                 (= (* |l| (|eqn| |lhs|)) (* |l| (|eqn| |rhs|)))))
               (==
                (* (|:| |l| S) (|:| |eqn| $))
                (= (* |l| (|eqn| |lhs|)) (* |l| (|eqn| |rhs|)))))
              (==
               (* (|:| |eqn| $) (|:| |l| S))
               (= (* (|eqn| |lhs|) |l|) (* (|eqn| |rhs|) |l|))))
             NIL))
           (|if| (|has| S |Monoid|)
            (|;|
             (|;|
              (|;|
               (== 1 (|equation| (|,| (|elt| S 1) (|elt| S 1))))
               (==
                (|recip| |eq|)
                (|;|
                 (|;|
                  (=> (|case| (|:=| |lh| (|recip| (|lhs| |eq|))) "failed")
                      "failed")
                  (=> (|case| (|:=| |rh| (|recip| (|rhs| |eq|))) "failed")
                      "failed"))
                 (|construct| (|,| (|::| |lh| S) (|::| |rh| S))))))
              (==
               (|leftOne| |eq|)
               (|;|
                (=> (|case| (|:=| |re| (|recip| (|lhs| |eq|))) "failed") 
                    "failed")
                (= 1 (* (|rhs| |eq|) |re|)))))
             (==
              (|rightOne| |eq|)
              (|;|
               (=> (|case| (|:=| |re| (|recip| (|rhs| |eq|))) "failed")
                   "failed")
               (= (* (|lhs| |eq|) |re|) 1))))
            NIL))
          (|if| (|has| S |Group|)
           (|;|
            (|;|
             (==
              (|inv| |eq|)
              (|construct| (|,| (|inv| (|lhs| |eq|)) (|inv| (|rhs| |eq|)))))
             (== (|leftOne| |eq|) (= 1 (* (|rhs| |eq|) (|inv| (|rhs| |eq|))))))
            (== (|rightOne| |eq|) (= (* (|lhs| |eq|) (|inv| (|rhs| |eq|))) 1)))
           NIL))
         (|if| (|has| S |Ring|)
          (|;|
           (==
            (|characteristic| (|@Tuple|))
            ((|elt| S |characteristic|) (|@Tuple|)))
           (== (* (|:| |i| |Integer|) (|:| |eq| $)) (* (|::| |i| S) |eq|)))
          NIL))
        (|if| (|has| S |IntegralDomain|)
         (==
          (|factorAndSplit| |eq|)
          (|;|
           (|;|
            (=>
             (|has| S (|:| |factor| (-> S (|Factored| S))))
             (|;|
              (|:=| |eq0| (|rightZero| |eq|))
              (COLLECT
               (IN |rcf| (|factors| (|factor| (|lhs| |eq0|))))
               (|construct| (|equation| (|,| (|rcf| |factor|) 0))))))
            (=>
             (|has| S (|Polynomial| |Integer|))
             (|;|
              (|;|
               (|;|
                (|:=| |eq0| (|rightZero| |eq|))
                (==> MF
                 (|MultivariateFactorize|
                  (|,|
                   (|,| (|,| |Symbol| (|IndexedExponents| |Symbol|)) |Integer|)
                  (|Polynomial| |Integer|)))))
               (|:=|
                (|:| |p| (|Polynomial| |Integer|))
                (|pretend| (|lhs| |eq0|) (|Polynomial| |Integer|))))
              (COLLECT
               (IN |rcf| (|factors| ((|elt| MF |factor|) |p|)))
               (|construct|
                (|equation| (|,| (|pretend| (|rcf| |factor|) S) 0)))))))
           (|construct| |eq|)))
         NIL))
       (|if| (|has| S (|PartialDifferentialRing| |Symbol|))
        (==
         (|:| (|differentiate| (|,| (|:| |eq| $) (|:| |sym| |Symbol|))) $)
         (|construct|
          (|,|
           (|differentiate| (|,| (|lhs| |eq|) |sym|))
           (|differentiate| (|,| (|rhs| |eq|) |sym|)))))
        NIL))
      (|if| (|has| S |Field|)
       (|;|
        (|;|
         (== (|dimension| (|@Tuple|)) (|::| 2 |CardinalNumber|))
         (==
          (/ (|:| |eq1| $) (|:| |eq2| $))
          (= (/ (|eq1| |lhs|) (|eq2| |lhs|)) (/ (|eq1| |rhs|) (|eq2| |rhs|)))))
        (==
         (|inv| |eq|)
         (|construct| (|,| (|inv| (|lhs| |eq|)) (|inv| (|rhs| |eq|))))))
       NIL))
     (|if| (|has| S |ExpressionSpace|)
      (==
       (|subst| (|,| |eq1| |eq2|))
       (|;|
        (|:=| |eq3| (|pretend| |eq2| (|Equation| S)))
        (|construct|
         (|,|
          (|subst| (|,| (|lhs| |eq1|) |eq3|))
          (|subst| (|,| (|rhs| |eq1|) |eq3|))))))
      NIL)))))))

\end{verbatim}

\defun{spad}{spad}
\catches{spad}{spad-reader}
\calls{spad}{addBinding}
\calls{spad}{makeInitialModemapFrame}
\calls{spad}{init-boot/spad-reader}
\calls{spad}{initialize-preparse}
\calls{spad}{preparse}
\calls{spad}{PARSE-NewExpr}
\calls{spad}{pop-stack-1}
\calls{spad}{s-process}
\calls{spad}{ioclear}
\calls{spad}{shut}
\usesdollar{spad}{noSubsumption}
\usesdollar{spad}{InteractiveFrame}
\usesdollar{spad}{InitialDomainsInScope}
\usesdollar{spad}{InteractiveMode}
\uses{spad}{line}
\uses{spad}{echo-meta}
\uses{spad}{/editfile}
\uses{spad}{*comp370-apply*}
\uses{spad}{*eof*}
\uses{spad}{file-closed}
\catches{spad}{spad-reader}
<<defun spad>>=
(defun spad (&optional (*spad-input-file* nil) (*spad-output-file* nil)
             &aux (*comp370-apply* #'print-defun)
                  (*fileactq-apply* #'print-defun)
                 ($spad t) ($boot nil) (optionlist nil) (*eof* nil)
                 (file-closed nil) (/editfile *spad-input-file*)
                (|$noSubsumption| |$noSubsumption|) in-stream out-stream)
  (declare (special echo-meta /editfile *comp370-apply* *eof*
                    file-closed |$noSubsumption| |$InteractiveFrame|
                    |$InteractiveMode| |$InitialDomainsInScope|))
  ;; only rebind |$InteractiveFrame| if compiling
  (progv (if (not |$InteractiveMode|) '(|$InteractiveFrame|))
         (if (not |$InteractiveMode|)
             (list (|addBinding| '|$DomainsInScope|
                    `((fluid . |true|)
                      (special . ,(copy-tree |$InitialDomainsInScope|)))
                   (|addBinding| '|$Information| nil
                      (|makeInitialModemapFrame|)))))
  (init-boot/spad-reader)
  (unwind-protect
    (progn
      (setq in-stream (if *spad-input-file*
                        (open *spad-input-file* :direction :input)
                         *standard-input*))
      (initialize-preparse in-stream)
      (setq out-stream (if *spad-output-file*
                        (open *spad-output-file* :direction :output)
                         *standard-output*))
      (when *spad-output-file*
         (format out-stream "~&;;; -*- Mode:Lisp; Package:Boot  -*-~%~%")
         (print-package "BOOT"))
      (setq curoutstream out-stream)
      (loop
       (if (or *eof* file-closed) (return nil))
       (catch 'spad_reader
         (if (setq boot-line-stack (preparse in-stream))
             (let ((line (cdar boot-line-stack)))
               (declare (special line))
               (|PARSE-NewExpr|)
               (let ((parseout (pop-stack-1)) )
                 (when parseout
                       (let ((*standard-output* out-stream))
                         (s-process parseout))
                       (format out-stream "~&")))
               )))
      (ioclear in-stream out-stream)))
    (if *spad-input-file* (shut in-stream))
    (if *spad-output-file* (shut out-stream)))
  t))

@

\defun{s-process}{Interpreter interface to the compiler}
\calls{s-process}{curstrm}
\calls{s-process}{def-rename}
\calls{s-process}{new2OldLisp}
\calls{s-process}{parseTransform}
\calls{s-process}{postTransform}
\calls{s-process}{displayPreCompilationErrors}
\calls{s-process}{prettyprint}
\calls{s-process}{processInteractive}
\calls{s-process}{compTopLevel}
\calls{s-process}{def-process}
\calls{s-process}{displaySemanticErrors}
\calls{s-process}{terpri}
\calls{s-process}{get-internal-run-time}
\usesdollar{s-process}{Index}
\usesdollar{s-process}{macroassoc}
\usesdollar{s-process}{newspad}
\usesdollar{s-process}{PolyMode}
\usesdollar{s-process}{EmptyMode}
\usesdollar{s-process}{compUniquelyIfTrue}
\usesdollar{s-process}{currentFunction}
\usesdollar{s-process}{postStack}
\usesdollar{s-process}{topOp}
\usesdollar{s-process}{semanticErrorStack}
\usesdollar{s-process}{warningStack}
\usesdollar{s-process}{exitMode}
\usesdollar{s-process}{exitModeStack}
\usesdollar{s-process}{returnMode}
\usesdollar{s-process}{leaveMode}
\usesdollar{s-process}{leaveLevelStack}
\usesdollar{s-process}{top-level}
\usesdollar{s-process}{insideFunctorIfTrue}
\usesdollar{s-process}{insideExpressionIfTrue}
\usesdollar{s-process}{insideCoerceInteractiveHardIfTrue}
\usesdollar{s-process}{insideWhereIfTrue}
\usesdollar{s-process}{insideCategoryIfTrue}
\usesdollar{s-process}{insideCapsuleFunctionIfTrue}
\usesdollar{s-process}{form}
\usesdollar{s-process}{DomainFrame}
\usesdollar{s-process}{e}
\usesdollar{s-process}{EmptyEnvironment}
\usesdollar{s-process}{genFVar}
\usesdollar{s-process}{genSDVar}
\usesdollar{s-process}{VariableCount}
\usesdollar{s-process}{previousTime}
\usesdollar{s-process}{LocalFrame}
\usesdollar{s-process}{Translation}
\uses{s-process}{curoutstream}
<<defun s-process>>=
(defun s-process (x)
 (prog ((|$Index| 0)
        ($macroassoc ())
        ($newspad t)
        (|$PolyMode| |$EmptyMode|)
        (|$compUniquelyIfTrue| nil)
        |$currentFunction|
        (|$postStack| nil)
        |$topOp|
        (|$semanticErrorStack| ())
        (|$warningStack| ())
        (|$exitMode| |$EmptyMode|)
        (|$exitModeStack| ())
        (|$returnMode| |$EmptyMode|)
        (|$leaveMode| |$EmptyMode|)
        (|$leaveLevelStack| ())
        $top_level |$insideFunctorIfTrue| |$insideExpressionIfTrue|
        |$insideCoerceInteractiveHardIfTrue| |$insideWhereIfTrue|
        |$insideCategoryIfTrue| |$insideCapsuleFunctionIfTrue| |$form|
        (|$DomainFrame| '((NIL)))
        (|$e| |$EmptyEnvironment|)
        (|$genFVar| 0)
        (|$genSDVar| 0)
        (|$VariableCount| 0)
        (|$previousTime| (get-internal-run-time))
        (|$LocalFrame| '((NIL)))
        (curstrm curoutstream) |$s| |$x| |$m| u)
  (declare (special |$Index| $macroassoc $newspad |$PolyMode| |$EmptyMode|
            |$compUniquelyIfTrue| |$currentFunction| |$postStack| |$topOp|
            |$semanticErrorStack| |$warningStack| |$exitMode| |$exitModeStack|
            |$returnMode| |$leaveMode| |$leaveLevelStack| $top_level 
            |$insideFunctorIfTrue| |$insideExpressionIfTrue|
            |$insideCoerceInteractiveHardIfTrue| |$insideWhereIfTrue|
            |$insideCategoryIfTrue| |$insideCapsuleFunctionIfTrue| |$form|
            |$DomainFrame| |$e| |$EmptyEnvironment| |$genFVar| |$genSDVar| 
            |$VariableCount| |$previousTime| |$LocalFrame|
            curstrm |$s| |$x| |$m| curoutstream $traceflag |$Translation|))
   (setq $traceflag t)
   (if (not x) (return nil))
   (if $boot
     (setq x (def-rename (|new2OldLisp| x)))
     (setq x (|parseTransform| (|postTransform| x))))
   (when |$TranslateOnly| (return (setq |$Translation| x)))
   (when |$postStack| (|displayPreCompilationErrors|) (return nil))
   (when |$PrintOnly|
        (format t "~S   =====>~%" |$currentLine|)
        (return (prettyprint x)))
   (if (not $boot)
    (if |$InteractiveMode|
      (|processInteractive| x nil)
      (when (setq u (|compTopLevel| x |$EmptyMode| |$InteractiveFrame|))
        (setq |$InteractiveFrame| (third u))))
    (def-process x))
   (when |$semanticErrorStack| (|displaySemanticErrors|))
   (terpri)))

@

\defun{compTopLevel}{compTopLevel}
\calls{compTopLevel}{newComp}
\calls{compTopLevel}{compOrCroak}
\usesdollar{compTopLevel}{NRTderivedTargetIfTrue}
\usesdollar{compTopLevel}{killOptimizeIfTrue}
\usesdollar{compTopLevel}{forceAdd}
\usesdollar{compTopLevel}{compTimeSum}
\usesdollar{compTopLevel}{resolveTimeSum}
\usesdollar{compTopLevel}{packagesUsed}
\usesdollar{compTopLevel}{envHashTable}
<<defun compTopLevel>>=
(defun |compTopLevel| (x m e)
 (let (|$NRTderivedTargetIfTrue| |$killOptimizeIfTrue| |$forceAdd|
       |$compTimeSum| |$resolveTimeSum| |$packagesUsed| |$envHashTable|
        t1 t2 t3 val mode)
 (declare (special |$NRTderivedTargetIfTrue| |$killOptimizeIfTrue|
                   |$forceAdd| |$compTimeSum| |$resolveTimeSum|
                   |$packagesUsed| |$envHashTable| ))
   (setq |$NRTderivedTargetIfTrue| nil)
   (setq |$killOptimizeIfTrue| nil)
   (setq |$forceAdd| nil)
   (setq |$compTimeSum| 0)
   (setq |$resolveTimeSum| 0)
   (setq |$packagesUsed| NIL)
   (setq |$envHashTable| (make-hashtable 'equal))
   (dolist (u (car (car e)))
    (dolist (v (cdr u))
     (hput |$envHashTable| (cons (car u) (cons (car v) nil)) t)))
   (cond
    ((or (and (pairp x) (eq (qcar x) 'def))
         (and (pairp x) (eq (qcar x) '|where|)
              (progn
                (setq t1 (qcdr x))
                (and (pairp t1)
                (progn
                 (setq t2 (qcar t1))
                 (and (pairp t2) (eq (qcar t2) 'def)))))))
      (setq t3 (|compOrCroak| x m e))
      (setq val (car t3))
      (setq mode (second t3))
      (cons val (cons mode (cons e nil))))
    (t (|compOrCroak| x m e)))))

@
Given:
\begin{verbatim}
CohenCategory(): Category == SetCategory with

  kind:(CExpr)->Boolean
  operand:(CExpr,Integer)->CExpr
  numberOfOperand:(CExpr)->Integer
  construct:(CExpr,CExpr)->CExpr

\end{verbatim}
the resulting call looks like:
\begin{verbatim}
 (|compOrCroak|
       (DEF (|CohenCategory|)
        ((|Category|))
        (NIL)
        (|Join|
         (|SetCategory|)
         (CATEGORY |package|
          (SIGNATURE |kind| ((|Boolean|) |CExpr|))
          (SIGNATURE |operand| (|CExpr| |CExpr| (|Integer|)))
          (SIGNATURE |numberOfOperand| ((|Integer|) |CExpr|))
          (SIGNATURE |construct| (|CExpr| |CExpr| |CExpr|)))))
        |$EmptyMode|
        (((
           (|$DomainsInScope| 
            (FLUID . |true|)
            (special |$EmptyMode| |$NoValueMode|))))))
\end{verbatim}

This compiler call expects the first argument {\tt x} 
to be a {\tt DEF} form to compile,
The second argument, {\tt m}, is the mode.
The third argument, {\tt e}, is the environment.

\defun{compOrCroak}{compOrCroak}
\calls{compOrCroak}{compOrCroak1}
<<defun compOrCroak>>=
(defun |compOrCroak| (x m e)
  (|compOrCroak1| x m e nil nil))

@

This results in a call to the inner function with
\begin{verbatim}
(|compOrCroak1|
          (DEF (|CohenCategory|)
           ((|Category|))
           (NIL)
           (|Join|
            (|SetCategory|)
            (CATEGORY |package|
             (SIGNATURE |kind| ((|Boolean|) |CExpr|))
             (SIGNATURE |operand| (|CExpr| |CExpr| (|Integer|)))
             (SIGNATURE |numberOfOperand| ((|Integer|) |CExpr|))
             (SIGNATURE |construct| (|CExpr| |CExpr| |CExpr|)))))
          |$EmptyMode|
          ((((
              |$DomainsInScope|
              (FLUID . |true|)
              (special |$EmptyMode| |$NoValueMode|)))))
          NIL 
          NIL 
          |comp|)
\end{verbatim}
The inner function augments the environment with information
from the compiler stack {\tt \$compStack} and
{\tt \$compErrorMessageStack}. Note that these variables are passed
in the argument list so they get preserved on the call stack. The
calling function gets called for every inner form so we use this
implicit stacking to retain the information.

\defun{compOrCroak1}{compOrCroak1}
\calls{compOrCroak1}{comp}
\calls{compOrCroak1}{compOrCroak1,compactify}
\calls{compOrCroak1}{stackSemanticError}
\calls{compOrCroak1}{mkErrorExpr}
\calls{compOrCroak1}{displaySemanticErrors}
\calls{compOrCroak1}{say}
\calls{compOrCroak1}{displayComp}
\calls{compOrCroak1}{userError}
\usesdollar{compOrCroak1}{compStack}
\usesdollar{compOrCroak1}{compErrorMessageStack}
\usesdollar{compOrCroak1}{level}
\usesdollar{compOrCroak1}{s}
\usesdollar{compOrCroak1}{scanIfTrue}
\usesdollar{compOrCroak1}{exitModeStack}
\catches{compOrCroak1}{compOrCroak}
<<defun compOrCroak1>>=
(defun |compOrCroak1| (x m e |$compStack| |$compErrorMessageStack|)
 (declare (special |$compStack| |$compErrorMessageStack|))
 (let (td errorMessage)
  (declare (special |$level| |$s| |$scanIfTrue| |$exitModeStack|))
  (cond
   ((setq td (catch '|compOrCroak| (|comp| x m e))) td)
   (t
     (setq |$compStack| (cons (list x m e |$exitModeStack|) |$compStack|))
     (setq |$s| (|compOrCroak1,compactify| |$compStack|))
     (setq |$level| (|#| |$s|))
     (setq errorMessage
       (if |$compErrorMessageStack|
         (car |$compErrorMessageStack|)
         '|unspecified error|))
     (cond 
      (|$scanIfTrue|
        (|stackSemanticError| errorMessage (|mkErrorExpr| |$level|))
        (list '|failedCompilation| m e ))
      (t
       (|displaySemanticErrors|)
       (say "****** comp fails at level " |$level| " with expression: ******")
       (|displayComp| |$level|)
       (|userError| errorMessage)))))))

@

\defun{comp}{comp}
\calls{comp}{compNoStacking}
\usesdollar{comp}{compStack}
\usesdollar{comp}{exitModeStack}
<<defun comp>>=
(defun |comp| (x m e)
 (let (td)
 (declare (special |$compStack| |$exitModeStack|))
  (if (setq td (|compNoStacking| x m e))
    (setq |$compStack| nil) 
    (push (list x m e |$exitModeStack|) |$compStack|))
  td))

@

\defun{compNoStacking}{compNoStacking}
\verb|$Representation| is bound in compDefineFunctor, set by doIt.
This hack says that when something is undeclared, \$ is
preferred to the underlying representation -- RDJ 9/12/83
\calls{compNoStacking}{comp2}
\calls{compNoStacking}{compNoStacking1}
\usesdollar{compNoStacking}{compStack}
\usesdollar{compNoStacking}{Representation}
\usesdollar{compNoStacking}{EmptyMode}
<<defun compNoStacking>>=
(defun |compNoStacking| (x m e)
 (let (td)
 (declare (special |$compStack| |$Representation| |$EmptyMode|))
  (if (setq td (|comp2| x m e))
    (if (and (equal m |$EmptyMode|) (equal (second td) |$Representation|))
      (list (car td) '$ (third td))
      td)
   (|compNoStacking1| x m e |$compStack|))))

@

\defun{compNoStacking1}{compNoStacking1}
\calls{compNoStacking1}{get}
\calls{compNoStacking1}{comp2}
\usesdollar{compNoStacking1}{compStack}
<<defun compNoStacking1>>=
(defun |compNoStacking1| (x m e |$compStack|)
 (declare (special |$compStack|))
 (let (u td)
  (if (setq u (|get| (if (eq m '$) '|Rep| m) '|value| e))
    (if (setq td (|comp2| x (car u) e))
      (list (car td) m (third td))
      nil)
    nil)))

@

\defun{comp2}{comp2}
\calls{comp2}{comp3}
\calls{comp2}{isDomainForm}
\calls{comp2}{isFunctor}
\calls{comp2}{insert}
\calls{comp2}{opOf}
\calls{comp2}{nequal}
\calls{comp2}{addDomain}
\usesdollar{comp2}{bootStrapMode}
\usesdollar{comp2}{packagesUsed}
\usesdollar{comp2}{lisplib}
<<defun comp2>>=
(defun |comp2| (x m e)
 (let (tmp1)
  (declare (special |$bootStrapMode| |$packagesUsed| $lisplib))
   (when (setq tmp1 (|comp3| x m e))
    (destructuring-bind (y mprime e) tmp1
     (when (and $lisplib (|isDomainForm| x e) (|isFunctor| x))
       (setq |$packagesUsed| (|insert| (list (|opOf| x)) |$packagesUsed|)))
     ; isDomainForm test needed to prevent error while compiling Ring
     ; $bootStrapMode-test necessary for compiling Ring in $bootStrapMode
     (if (and (nequal m mprime)
              (or |$bootStrapMode| (|isDomainForm| mprime e)))
       (list y mprime (|addDomain| mprime e))
       (list y mprime e))))))

@

\defun{comp3}{comp3}
\begin{verbatim}
;comp3(x,m,$e) ==
;  --returns a Triple or %else nil to signalcan't do'
;  $e:= addDomain(m,$e)
;  e:= $e --for debugging purposes
;  m is ["Mapping",:.] => compWithMappingMode(x,m,e)
;  m is ["QUOTE",a] => (x=a => [x,m,$e]; nil)
;  STRINGP m => (atom x => (m=x or m=STRINGIMAGE x => [m,m,e]; nil); nil)
;  ^x or atom x => compAtom(x,m,e)
;  op:= first x
;  getmode(op,e) is ["Mapping",:ml] and (u:= applyMapping(x,m,e,ml)) => u
;  op is ["KAPPA",sig,varlist,body] => compApply(sig,varlist,body,rest x,m,e)
;  op=":" => compColon(x,m,e)
;  op="::" => compCoerce(x,m,e)
;  not ($insideCompTypeOf=true) and stringPrefix?('"TypeOf",PNAME op) =>
;    compTypeOf(x,m,e)
;  t:= compExpression(x,m,e)
;  t is [x',m',e'] and not MEMBER(m',getDomainsInScope e') =>
;    [x',m',addDomain(m',e')]
;  t
\end{verbatim}
\calls{comp3}{addDomain}
\calls{comp3}{compWithMappingMode}
\calls{comp3}{stringimage}
\calls{comp3}{compAtom}
\calls{comp3}{getmode}
\calls{comp3}{applyMapping}
\calls{comp3}{compApply}
\calls{comp3}{compColon}
\calls{comp3}{compCoerce}
\calls{comp3}{stringPrefix?}
\calls{comp3}{pname}
\calls{comp3}{compTypeOf}
\calls{comp3}{compExpression}
\calls{comp3}{member}
\calls{comp3}{getDomainsInScope}
\usesdollar{comp3}{e}
\usesdollar{comp3}{insideCompTypeOf}
<<defun comp3>>=
(defun |comp3| (x m |$e|)
 (declare (special |$e|))
 (let (e a op ml u sig varlist tmp3 body tt xprime tmp1 mprime tmp2 eprime)
 (declare (special |$insideCompTypeOf|))
  (setq |$e| (|addDomain| m |$e|))
  (setq e |$e|)
  (cond
   ((and (pairp m) (eq (qcar m) '|Mapping|)) (|compWithMappingMode| x m e))
   ((and (pairp m) (eq (qcar m) 'quote)
         (progn
          (setq tmp1 (qcdr m))
          (and (pairp tmp1) (eq (qcdr tmp1) nil)
          (progn (setq a (qcar tmp1)) t))))
    (when (equal x a) (list x m |$e|)))
   ((stringp m)
    (when (and (atom x) (or (equal m x) (equal m (stringimage x))))
     (list m m e )))
   ((or (null x) (atom x)) (|compAtom| x m e))
   (t 
    (setq op (car x))
    (cond
     ((and (progn
            (setq tmp1 (|getmode| op e))
            (and (pairp tmp1)
                 (eq (qcar tmp1) '|Mapping|)
                 (progn (setq ml (qcdr tmp1)) t)))
            (setq u (|applyMapping| x m e ml)))
        u)
     ((and (pairp op) (eq (qcar op) 'kappa)
           (progn
            (setq tmp1 (qcdr op))
            (and (pairp tmp1)
                 (progn
                  (setq sig (qcar tmp1))
                   (setq tmp2 (qcdr tmp1))
                   (and (pairp tmp2)
                        (progn
                         (setq varlist (qcar tmp2))
                         (setq tmp3 (qcdr tmp2))
                         (and (pairp tmp3)
                              (eq (qcdr tmp3) nil)
                              (progn
                                (setq body (qcar tmp3))
                                t))))))))
       (|compApply| sig varlist body (cdr x) m e))
     ((eq op '|:|)  (|compColon| x m e))
     ((eq op '|::|) (|compCoerce| x m e))
     ((and (null (eq |$insideCompTypeOf| t))
           (|stringPrefix?| "TypeOf" (pname op)))
       (|compTypeOf| x m e))
      (t
       (setq tt (|compExpression| x m e))
       (cond
        ((and (pairp tt)
              (progn
               (setq xprime (qcar tt))
               (setq tmp1 (qcdr tt))
               (and (pairp tmp1)
                    (progn
                     (setq mprime (qcar tmp1))
                     (setq tmp2 (qcdr tmp1))
                     (and (pairp tmp2)
                          (eq (qcdr tmp2) nil)
                          (progn
                            (setq eprime (qcar tmp2))
                            t)))))
                     (null (|member| mprime (|getDomainsInScope| eprime))))
         (list xprime mprime (|addDomain| mprime eprime)))
        (t tt))))))))

@

\defun{compTypeOf}{compTypeOf}
\calls{compTypeOf}{eqsubstlist}
\calls{compTypeOf}{get}
\calls{compTypeOf}{put}
\calls{compTypeOf}{comp3}
\usesdollar{compTypeOf}{insideCompTypeOf}
\usesdollar{compTypeOf}{FormalMapVariableList}
<<defun compTypeOf>>=
(defun |compTypeOf| (x m e)
 (let (|$insideCompTypeOf| op argl newModemap)
 (declare (special |$insideCompTypeOf| |$FormalMapVariableList|))
  (setq op (car x))
  (setq argl (cdr x))
  (setq |$insideCompTypeOf| t)
  (setq newModemap
    (eqsubstlist argl |$FormalMapVariableList| (|get| op '|modemap| e)))
  (setq e (|put| op '|modemap| newModemap e))
  (|comp3| x m e)))

@

\defun{compColonInside}{compColonInside}
\calls{compColonInside}{addDomain}
\calls{compColonInside}{comp}
\calls{compColonInside}{coerce}
\calls{compColonInside}{stackWarning}
\calls{compColonInside}{opOf}
\calls{compColonInside}{stackSemanticError}
\usesdollar{compColonInside}{newCompilerUnionFlag}
\usesdollar{compColonInside}{EmptyMode}
<<defun compColonInside>>=
(defun |compColonInside| (x m e mprime)
 (let (mpp warningMessage td tprime)
 (declare (special |$newCompilerUnionFlag| |$EmptyMode|))
    (setq e (|addDomain| mprime e))
    (when (setq td (|comp| x |$EmptyMode| e))
     (cond
      ((equal (setq mpp (second td)) mprime)
       (setq warningMessage
        (list '|:| mprime '| -- should replace by @|))))
     (setq td (list (car td) mprime (third td)))
     (when (setq tprime (|coerce| td m))
      (cond
       (warningMessage (|stackWarning| warningMessage))
       ((and |$newCompilerUnionFlag| (eq (|opOf| mpp) '|Union|))
        (setq tprime
         (|stackSemanticError|
          (list '|cannot pretend | x '| of mode | mpp '| to mode | mprime )
          nil)))
       (t
        (|stackWarning|
         (list '|:| mprime '| -- should replace by pretend|))))
      tprime))))

@

\defun{compAtom}{compAtom}
\begin{verbatim}
;compAtom(x,m,e) ==
;  T:= compAtomWithModemap(x,m,e,get(x,"modemap",e)) => T
;  x="nil" =>
;    T:=
;      modeIsAggregateOf('List,m,e) is [.,R]=> compList(x,['List,R],e)
;      modeIsAggregateOf('Vector,m,e) is [.,R]=> compVector(x,['Vector,R],e)
;    T => convert(T,m)
;  t:=
;    isSymbol x =>
;      compSymbol(x,m,e) or return nil
;    m = $Expression and primitiveType x => [x,m,e]
;    STRINGP x => [x,x,e]
;    [x,primitiveType x or return nil,e]
;  convert(t,m)
\end{verbatim}
\calls{compAtom}{compAtomWithModemap}
\calls{compAtom}{get}
\calls{compAtom}{modeIsAggregateOf}
\calls{compAtom}{compList}
\calls{compAtom}{compVector}
\calls{compAtom}{convert}
\calls{compAtom}{isSymbol}
\calls{compAtom}{compSymbol}
\calls{compAtom}{primitiveType}
\calls{compAtom}{primitiveType}
\usesdollar{compAtom}{Expression}
<<defun compAtom>>=
(defun |compAtom| (x m e)
 (prog (tmp1 tmp2 r td tt)
  (declare (special |$Expression|))
   (return
   (cond
    ((setq td (|compAtomWithModemap| x m e (|get| x '|modemap| e))) td)
    ((eq x '|nil|)
     (setq td
      (cond
       ((progn
         (setq tmp1 (|modeIsAggregateOf| '|List| m e))
         (and (pairp tmp1)
              (progn
               (setq tmp2 (qcdr tmp1))
               (and (pairp tmp2)
                    (eq (qcdr tmp2) nil)
                    (progn
                      (setq r (qcar tmp2)) t)))))
         (|compList| x (list '|List| r) e))
       ((progn
         (setq tmp1 (|modeIsAggregateOf| '|Vector| m e))
         (and (pairp tmp1)
              (progn
               (setq tmp2 (qcdr tmp1))
               (and (pairp tmp2) (eq (qcdr tmp2) nil)
               (progn
                 (setq r (qcar tmp2)) t)))))
         (|compVector| x (list '|Vector| r) e))))
      (when td (|convert| td m)))
    (t
     (setq tt
      (cond
       ((|isSymbol| x) (or (|compSymbol| x m e) (return nil)))
       ((and (equal m |$Expression|) (|primitiveType| x)) (list x m e ))
       ((stringp x) (list x x e ))
       (t (list x (or (|primitiveType| x) (return nil)) e ))))
     (|convert| tt m))))))

@

\defun{convert}{convert}
\calls{convert}{resolve}
\calls{convert}{coerce}
<<defun convert>>=
(defun |convert| (td m)
 (let (res)
  (when (setq res (|resolve| (second td) m))
   (|coerce| td res))))

@
\defun{primitiveType}{primitiveType}
\usesdollar{primitiveType}{DoubleFloat}
\usesdollar{primitiveType}{NegativeInteger}
\usesdollar{primitiveType}{PositiveInteger}
\usesdollar{primitiveType}{NonNegativeInteger}
\usesdollar{primitiveType}{String}
\usesdollar{primitiveType}{EmptyMode}
<<defun primitiveType>>=
(defun |primitiveType| (x)
  (declare (special |$DoubleFloat| |$NegativeInteger| |$PositiveInteger|
                     |$NonNegativeInteger| |$String| |$EmptyMode|))
  (cond
    ((null x) |$EmptyMode|)
    ((stringp x) |$String|)
    ((integerp x)
     (cond
       ((eql x 0) |$NonNegativeInteger|)
       ((> x 0) |$PositiveInteger|)
       (t |$NegativeInteger|)))
    ((floatp x) |$DoubleFloat|)
    (t nil)))

@
\defun{compSymbol}{compSymbol}
\calls{compSymbol}{getmode}
\calls{compSymbol}{get}
\calls{compSymbol}{NRTgetLocalIndex}
\calls{compSymbol}{member}
\calls{compSymbol}{isFunction}
\calls{compSymbol}{errorRef}
\calls{compSymbol}{stackMessage}
\usesdollar{compSymbol}{Symbol}
\usesdollar{compSymbol}{Expression}
\usesdollar{compSymbol}{FormalMapVariableList}
\usesdollar{compSymbol}{compForModeIfTrue}
\usesdollar{compSymbol}{formalArgList}
\usesdollar{compSymbol}{NoValueMode}
\usesdollar{compSymbol}{functorLocalParameters}
\usesdollar{compSymbol}{Boolean}
\usesdollar{compSymbol}{NoValue}
<<defun compSymbol>>=
(defun |compSymbol| (s m e)
 (let (v mprime mode)
  (declare (special |$Symbol| |$Expression| |$FormalMapVariableList|
                    |$compForModeIfTrue| |$formalArgList| |$NoValueMode|
                    |$functorLocalParameters| |$Boolean| |$NoValue|))
   (cond
     ((eq s '|$NoValue|) (list '|$NoValue| |$NoValueMode| e ))
     ((|isFluid| s)
      (setq mode (|getmode| s e))
      (when mode (list s (|getmode| s e) e)))
     ((eq s '|true|) (list '(quote t) |$Boolean| e ))
     ((eq s '|false|) (list nil |$Boolean| e ))
     ((or (equal s m) (|get| s '|isLiteral| e)) (list (list 'quote s) s e))
     ((setq v (|get| s '|value| e))
      (cond
        ((member s |$functorLocalParameters|)
         ; s will be replaced by an ELT form in beforeCompile
         (|NRTgetLocalIndex| s) 
         (list s (second v) e))
        (t
         ; s has been SETQd
         (list s (second v) e))))
     ((setq mprime (|getmode| s e))
      (cond
        ((and (null (|member| s |$formalArgList|))
              (null (member s |$FormalMapVariableList|))
              (null (|isFunction| s e))
              (null (eq |$compForModeIfTrue| t)))
         (|errorRef| s)))
      (list s mprime e ))
     ((member s |$FormalMapVariableList|)
      (|stackMessage| (list '|no mode found for| s )))
     ((or (equal m |$Expression|) (equal m |$Symbol|))
      (list (list 'quote s) m e ))
     ((null (|isFunction| s e)) (|errorRef| s)))))

@

\defun{compList}{compList}
\begin{verbatim}
;compList(l,m is ["List",mUnder],e) ==
;  null l => [NIL,m,e]
;  Tl:= [[.,mUnder,e]:= comp(x,mUnder,e) or return "failed" for x in l]
;  Tl="failed" => nil
;  T:= [["LIST",:[T.expr for T in Tl]],["List",mUnder],e]
\end{verbatim}
\calls{compList}{comp}
<<defun compList>>=
(defun |compList| (l m e)
 (let (tmp1 tmp2 t0 failed (mUnder (second m)))
  (if (null l)
   (list nil m e)
   (progn
    (setq t0
     (do ((t3 l (cdr t3)) (x nil))
         ((or (atom t3) failed) (unless failed (nreverse0 tmp2)))
       (setq x (car t3))
       (if (setq tmp1 (|comp| x mUnder e))
        (progn
         (setq mUnder (second tmp1))
         (setq e (third tmp1))
         (push tmp1 tmp2))
        (setq failed t))))
    (unless failed
     (cons 
       (cons 'list (loop for texpr in t0 collect (car texpr)))
       (list (list '|List| mUnder) e)))))))

@

\defun{compExpression}{compExpression}
\calls{compExpression}{getl}
\calls{compExpression}{compForm}
\usesdollar{compExpression}{insideExpressionIfTrue}
<<defun compExpression>>=
(defun |compExpression| (x m e)
 (let (|$insideExpressionIfTrue| fn)
 (declare (special |$insideExpressionIfTrue|))
  (setq |$insideExpressionIfTrue| t)
  (if (and (atom (car x)) (setq fn (getl (car x) 'special)))
    (funcall fn x m e)
    (|compForm| x m e))))

@

\defun{compForm}{compForm}
\calls{compForm}{compForm1}
\calls{compForm}{compArgumentsAndTryAgain}
\calls{compForm}{stackMessageIfNone}
<<defun compForm>>=
(defun |compForm| (form m e)
 (cond
  ((|compForm1| form m e))
  ((|compArgumentsAndTryAgain| form m e))
  (t (|stackMessageIfNone| (list '|cannot compile| '|%b| form '|%d| )))))

@

\defun{compForm1}{compForm1}
\calls{compForm1}{length}
\calls{compForm1}{outputComp}
\calls{compForm1}{compOrCroak}
\calls{compForm1}{compExpressionList}
\calls{compForm1}{coerceable}
\calls{compForm1}{comp}
\calls{compForm1}{coerce}
\calls{compForm1}{compForm2}
\calls{compForm1}{augModemapsFromDomain1}
\calls{compForm1}{getFormModemaps}
\calls{compForm1}{nreverse0}
\calls{compForm1}{addDomain}
\calls{compForm1}{compToApply}
\usesdollar{compForm1}{NumberOfArgsIfInteger}
\usesdollar{compForm1}{Expression}
\usesdollar{compForm1}{EmptyMode}
<<defun compForm1>>=
(defun |compForm1| (form m e)
 (let (|$NumberOfArgsIfInteger| op argl domain tmp1 opprime ans mmList td 
       tmp2 tmp3 tmp4 tmp5 tmp6 tmp7)
 (declare (special |$NumberOfArgsIfInteger| |$Expression| |$EmptyMode|))
    (setq op (car form))
    (setq argl (cdr form))
    (setq |$NumberOfArgsIfInteger| (|#| argl))
    (cond
     ((eq op '|error|)
      (list
       (cons op
        (dolist (x argl (nreverse0 tmp4))
          (setq tmp2 (|outputComp| x e))
          (setq e (third tmp2))
          (push (car tmp2) tmp4)))
       m e))
     ((and (pairp op) (eq (qcar op) '|elt|)
           (progn
            (setq tmp3 (qcdr op))
            (and (pairp tmp3)
                 (progn
                  (setq domain (qcar tmp3))
                  (setq tmp1 (qcdr tmp3))
                  (and (pairp tmp1)
                       (eq (qcdr tmp1) nil)
                       (progn
                        (setq opprime (qcar tmp1))
                        t))))))
       (cond
        ((eq domain '|Lisp|)
          (list 
           (cons opprime
            (dolist (x argl (nreverse tmp7))
             (setq tmp2 (|compOrCroak| x |$EmptyMode| e))
             (setq e (third tmp2))
             (push (car tmp2) tmp7)))
           m e))
        ((and (equal domain |$Expression|) (eq opprime '|construct|))
          (|compExpressionList| argl m e))
        ((and (eq opprime 'collect) (|coerceable| domain m e))
          (when (setq td (|comp| (cons opprime argl) domain e))
           (|coerce| td m)))
        ((and (pairp domain) (eq (qcar domain) '|Mapping|)
              (setq ans
               (|compForm2| (cons opprime argl) m
                (setq e (|augModemapsFromDomain1| domain domain e))
                (dolist (x (|getFormModemaps| (cons opprime argl) e)
                                          (nreverse0 tmp6))
                 (when
                  (and (pairp x)
                       (and (pairp (qcar x)) (equal (qcar (qcar x)) domain)))
                    (push x tmp6))))))
          ans)
        ((setq ans
          (|compForm2| (cons opprime argl) m
           (setq e (|addDomain| domain e))
           (dolist (x (|getFormModemaps| (cons opprime argl) e)
                   (nreverse0 tmp5))
             (when
               (and (pairp x)
                    (and (pairp (qcar x)) (equal (qcar (qcar x)) domain)))
                (push x tmp5)))))
          ans)
        ((and (eq opprime '|construct|) (|coerceable| domain m e))
          (when (setq td (|comp| (cons opprime argl) domain e))
           (|coerce| td m)))
        (t nil)))
     (t
      (setq e (|addDomain| m e))
      (cond
       ((and (setq mmList (|getFormModemaps| form e))
             (setq td (|compForm2| form m e mmList)))
         td)
       (t
         (|compToApply| op argl m e)))))))

@

\defun{compForm2}{compForm2}
\calls{compForm2}{take}
\calls{compForm2}{length}
\calls{compForm2}{nreverse0}
\calls{compForm2}{sublis}
\calls{compForm2}{assoc}
\calls{compForm2}{PredImplies}
\calls{compForm2}{isSimple}
\calls{compForm2}{compUniquely}
\calls{compForm2}{compFormPartiallyBottomUp}
\calls{compForm2}{compForm3}
\usesdollar{compForm2}{EmptyMode}
\usesdollar{compForm2}{TriangleVariableList}
<<defun compForm2>>=
(defun |compForm2| (form m e modemapList)
 (let (op argl sargl aList dc cond nsig v ncond deleteList newList td tl
       partialModeList tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7)
 (declare (special |$EmptyMode| |$TriangleVariableList|))
  (setq op (car form))
  (setq argl (cdr form))
  (setq sargl (take (|#| argl) |$TriangleVariableList|))
  (setq aList (mapcar #'(lambda (x y) (cons x y)) sargl argl))
  (setq modemaplist (sublis aList modemapList))
  ; now delete any modemaps that are subsumed by something else, provided 
  ; the conditions are right (i.e. subsumer true whenever subsumee true)
  (dolist (u modemapList)
   (cond
    ((and (pairp u)
          (progn
           (setq tmp6 (qcar u))
           (and (pairp tmp6) (progn (setq dc (qcar tmp6)) t)))
          (progn
           (setq tmp7 (qcdr u))
           (and (pairp tmp7) (eq (qcdr tmp7) nil)
                (progn
                 (setq tmp1 (qcar tmp7))
                 (and (pairp tmp1)
                      (progn
                       (setq cond (qcar tmp1))
                       (setq tmp2 (qcdr tmp1))
                       (and (pairp tmp2) (eq (qcdr tmp2) nil)
                            (progn
                             (setq tmp3 (qcar tmp2))
                             (and (pairp tmp3) (eq (qcar tmp3) '|Subsumed|)
                                  (progn
                                   (setq tmp4 (qcdr tmp3))
                                   (and (pairp tmp4)
                                        (progn
                                         (setq tmp5 (qcdr tmp4))
                                         (and (pairp tmp5) 
                                              (eq (qcdr tmp5) nil)
                                              (progn
                                               (setq nsig (qcar tmp5))
                                               t)))))))))))))
          (setq v (|assoc| (cons dc nsig) modemapList))
          (pairp v)
          (progn
           (setq tmp6 (qcdr v))
           (and (pairp tmp6) (eq (qcdr tmp6) nil)
                (progn
                 (setq tmp7 (qcar tmp6))
                 (and (pairp tmp7)
                      (progn
                       (setq ncond (qcar tmp7))
                       t))))))
      (setq deleteList (cons u deleteList))
      (unless  (|PredImplies| ncond cond)
         (setq newList (push `(,(car u) (,cond (elt ,dc nil))) newList))))))
  (when deleteList
   (setq modemapList 
    (remove-if #'(lambda (x) (member x deletelist)) modemapList)))
  ; it is important that subsumed ops (newList) be considered last
  (when newList (setq modemapList (append modemapList newList)))
  (setq tl
   (loop for x in argl 
         while (and (|isSimple| x)
                    (setq td (|compUniquely| x |$EmptyMode| e)))
         collect td
         do (setq e (third td))))
  (cond
   ((some #'identity tl)
     (setq partialModeList (loop for x in tl collect (when x (second x))))
     (or (|compFormPartiallyBottomUp| form m e modemapList partialModeList)
         (|compForm3| form m e modemapList)))
   (t (|compForm3| form m e modemapList)))))

@

\defun{compArgumentsAndTryAgain}{compArgumentsAndTryAgain}
\calls{compArgumentsAndTryAgain}{comp}
\calls{compArgumentsAndTryAgain}{compForm1}
\usesdollar{compArgumentsAndTryAgain}{EmptyMode}
<<defun compArgumentsAndTryAgain>>=
(defun |compArgumentsAndTryAgain| (form m e)
 (let (argl tmp1 a tmp2 tmp3 u)
 (declare (special |$EmptyMode|))
  (setq argl (cdr form))
  (cond
   ((and (pairp form) (eq (qcar form) '|elt|)
         (progn
           (setq tmp1 (qcdr form))
           (and (pairp tmp1)
                (progn
                 (setq a (qcar tmp1))
                 (setq tmp2 (qcdr tmp1))
                 (and (pairp tmp2) (eq (qcdr tmp2) nil))))))
    (when (setq tmp3 (|comp| a |$EmptyMode| e))
      (setq e (third tmp3))
      (|compForm1| form m e)))
   (t
     (setq u
      (dolist (x argl)
       (setq tmp3 (or (|comp| x |$EmptyMode| e) (return '|failed|)))
       (setq e (third tmp3))
       tmp3))
     (unless (eq u '|failed|)
       (|compForm1| form m e))))))

@
\defun{compWithMappingMode}{compWithMappingMode}
\calls{compWithMappingMode}{compWithMappingMode1}
\usesdollar{compWithMappingMode}{formalArgList}
<<defun compWithMappingMode>>=
(defun |compWithMappingMode| (x m oldE)
  (declare (special |$formalArgList|))
  (|compWithMappingMode1| x m oldE |$formalArgList|))

@

\defun{compWithMappingMode1}{compWithMappingMode1}
\begin{verbatim}
;compWithMappingMode1(x,m is ["Mapping",m',:sl],oldE,$formalArgList) ==
;  $killOptimizeIfTrue: local:= true
;  e:= oldE
;  isFunctor x =>
;    if get(x,"modemap",$CategoryFrame) is [[[.,target,:argModeList],.],:.] and
;     (and/[extendsCategoryForm("$",s,mode) for mode in argModeList for s in sl]
;       ) and extendsCategoryForm("$",target,m') then return [x,m,e]
;  if STRINGP x then x:= INTERN x
;  ress:=nil
;  old_style:=true
;  if x is ["+->",vl,nx] then
;    old_style:=false
;    vl is [":",:.] =>
;      ress:=compLambda(x,m,oldE)
;      ress
;    vl:=
;      vl is ["Tuple",:vl1] => vl1
;      vl
;    vl:=
;      SYMBOLP(vl) => [vl]
;      LISTP(vl) and (and/[SYMBOLP(v) for v in vl]) => vl
;      stackAndThrow ["bad +-> arguments:",vl]
;    $formatArgList:=[:vl,:$formalArgList]
;    x:=nx
;  else
;    vl:=take(#sl,$FormalMapVariableList)
;  ress => ress
;  for m in sl for v in vl repeat
;    [.,.,e]:= compMakeDeclaration([":",v,m],$EmptyMode,e)
;  old_style and not null vl and not hasFormalMapVariable(x, vl) => return
;    [u,.,.] := comp([x,:vl],m',e) or return nil
;    extractCodeAndConstructTriple(u, m, oldE)
;  null vl and (t := comp([x], m', e)) => return
;    [u,.,.] := t
;    extractCodeAndConstructTriple(u, m, oldE)
;  [u,.,.]:= comp(x,m',e) or return nil
;  uu:=optimizeFunctionDef [nil,['LAMBDA,vl,u]]
;  --  At this point, we have a function that we would like to pass.
;  --  Unfortunately, it makes various free variable references outside
;  --  itself.  So we build a mini-vector that contains them all, and
;  --  pass this as the environment to our inner function.
;  $FUNNAME :local := nil
;  $FUNNAME__TAIL :local := [nil]
;  expandedFunction:=COMP_-TRAN CADR uu
;  frees:=freelist(expandedFunction,vl,nil,e)
;    where freelist(u,bound,free,e) ==
;      atom u =>
;        not IDENTP u => free
;        MEMQ(u,bound) => free
;        v:=ASSQ(u,free) =>
;          RPLACD(v,1+CDR v)
;          free
;        not getmode(u, e) => free
;        [[u,:1],:free]
;      op:=CAR u
;      MEMQ(op, '(QUOTE GO function)) => free
;      EQ(op,'LAMBDA) =>
;        bound:=UNIONQ(bound,CADR u)
;        for v in CDDR u repeat
;          free:=freelist(v,bound,free,e)
;        free
;      EQ(op,'PROG) =>
;        bound:=UNIONQ(bound,CADR u)
;        for v in CDDR u | NOT ATOM v repeat
;          free:=freelist(v,bound,free,e)
;        free
;      EQ(op,'SEQ) =>
;        for v in CDR u | NOT ATOM v repeat
;          free:=freelist(v,bound,free,e)
;        free
;      EQ(op,'COND) =>
;        for v in CDR u repeat
;          for vv in v repeat
;            free:=freelist(vv,bound,free,e)
;        free
;      if ATOM op then u:=CDR u  --Atomic functions aren't descended
;      for v in u repeat
;        free:=freelist(v,bound,free,e)
;      free
;  expandedFunction :=
;            --One free can go by itself, more than one needs a vector
;         --An A-list name . number of times used
;    #frees = 0 => ['LAMBDA,[:vl,"$$"], :CDDR expandedFunction]
;    #frees = 1 =>
;      vec:=first first frees
;      ['LAMBDA,[:vl,vec], :CDDR expandedFunction]
;    scode:=nil
;    vec:=nil
;    locals:=nil
;    i:=-1
;    for v in frees repeat
;      i:=i+1
;      vec:=[first v,:vec]
;      scode:=[['SETQ,first v,[($QuickCode => 'QREFELT;'ELT),"$$",i]],:scode]
;      locals:=[first v,:locals]
;    body:=CDDR expandedFunction
;    if locals then
;      if body is [['DECLARE,:.],:.] then
;        body:=[CAR body,['PROG,locals,:scode,['RETURN,['PROGN,:CDR body]]]]
;      else body:=[['PROG,locals,:scode,['RETURN,['PROGN,:body]]]]
;    vec:=['VECTOR,:NREVERSE vec]
;    ['LAMBDA,[:vl,"$$"],:body]
;  fname:=['CLOSEDFN,expandedFunction]
;         --Like QUOTE, but gets compiled
;  uu:=
;    frees => ['CONS,fname,vec]
;    ['LIST,fname]
;  [uu,m,oldE]
\end{verbatim}
\calls{compWithMappingMode1}{isFunctor}
\calls{compWithMappingMode1}{get}
\calls{compWithMappingMode1}{qcar}
\calls{compWithMappingMode1}{qcdr}
\calls{compWithMappingMode1}{extendsCategoryForm}
\calls{compWithMappingMode1}{compLambda}
\calls{compWithMappingMode1}{stackAndThrow}
\calls{compWithMappingMode1}{take}
\calls{compWithMappingMode1}{compMakeDeclaration}
\calls{compWithMappingMode1}{hasFormalMapVariable}
\calls{compWithMappingMode1}{comp}
\calls{compWithMappingMode1}{extractCodeAndConstructTriple}
\calls{compWithMappingMode1}{optimizeFunctionDef}
\calls{compWithMappingMode1}{comp-tran}
\calls{compWithMappingMode1}{freelist}
\usesdollar{compWithMappingMode1}{formalArgList}
\usesdollar{compWithMappingMode1}{killOptimizeIfTrue}
\usesdollar{compWithMappingMode1}{funname}
\usesdollar{compWithMappingMode1}{funnameTail}
\usesdollar{compWithMappingMode1}{QuickCode}
\usesdollar{compWithMappingMode1}{EmptyMode}
\usesdollar{compWithMappingMode1}{FormalMapVariableList}
\usesdollar{compWithMappingMode1}{CategoryFrame}
\usesdollar{compWithMappingMode1}{formatArgList}
<<defun compWithMappingMode1>>=
(defun |compWithMappingMode1| (x m oldE |$formalArgList|)
 (declare (special |$formalArgList|))
  (prog (|$killOptimizeIfTrue| $funname $funnameTail mprime sl tmp1 tmp2 
         tmp3 tmp4 tmp5 tmp6 target argModeList nx oldstyle ress vl1 vl e tt
             u frees i scode locals body vec expandedFunction fname uu)
  (declare (special |$killOptimizeIfTrue| $funname $funnameTail
                    |$QuickCode| |$EmptyMode| |$FormalMapVariableList|
                    |$CategoryFrame| |$formatArgList|))
   (return
    (seq
     (progn
      (setq mprime (second m))
      (setq sl (cddr m))
      (setq |$killOptimizeIfTrue| t)
      (setq e oldE)
      (cond
       ((|isFunctor| x)
        (cond
         ((and (progn
                (setq tmp1 (|get| x '|modemap| |$CategoryFrame|))
                (and (pairp tmp1)
                     (progn
                      (setq tmp2 (qcar tmp1))
                      (and (pairp tmp2)
                           (progn
                            (setq tmp3 (qcar tmp2))
                            (and (pairp tmp3)
                                 (progn
                                  (setq tmp4 (qcdr tmp3))
                                  (and (pairp tmp4)
                                       (progn 
                                        (setq target (qcar tmp4))
                                        (setq argModeList (qcdr tmp4))
                                        t)))))
                           (progn
                            (setq tmp5 (qcdr tmp2))
                            (and (pairp tmp5) (eq (qcdr tmp5) nil)))))))
               (prog (t1)
                (setq t1 t)
                (return
                 (do ((t2 nil (null t1))
                      (t3 argModeList (cdr t3))
                      (mode nil)
                      (t4 sl (cdr t4))
                      (s nil))
                    ((or t2 (atom t3)
                         (progn (setq mode (car t3)) nil)
                         (atom t4)
                         (progn (setq s (car t4)) nil))
                        t1)
                   (seq (exit
                     (setq t1 
                      (and t1 (|extendsCategoryForm| '$ s mode))))))))
                        (|extendsCategoryForm| '$ target mprime))
               (return (list x m e )))
         (t nil)))
       (t 
        (when (stringp x) (setq x (intern x)))
        (setq ress nil) 
        (setq oldstyle t)
        (cond
         ((and (pairp x) 
               (eq (qcar x) '+->)
               (progn
                (setq tmp1 (qcdr x))
                (and (pairp tmp1)
                     (progn
                      (setq vl (qcar tmp1))
                      (setq tmp2 (qcdr tmp1))
                      (and (pairp tmp2)
                           (eq (qcdr tmp2) nil)
                           (progn (setq nx (qcar tmp2)) t))))))
            (setq oldstyle nil)
            (cond
             ((and (pairp vl) (eq (qcar vl) '|:|))
               (setq ress (|compLambda| x m oldE))
               ress)
             (t
              (setq vl
               (cond
                ((and (pairp vl)
                      (eq (qcar vl) '|@Tuple|)
                      (progn (setq vl1 (qcdr vl)) t))
                  vl1)
                (t vl)))
              (setq vl
               (cond
                ((symbolp vl) (cons vl nil))
                ((and 
                  (listp vl)
                  (prog (t5)
                   (setq t5 t)
                   (return
                    (do ((t7 nil (null t5))
                         (t6 vl (cdr t6))
                         (v nil))
                       ((or t7 (atom t6) (progn (setq v (car t6)) nil)) t5)
                      (seq
                       (exit
                        (setq t5 (and t5 (symbolp v)))))))))
                  vl)
                (t
                 (|stackAndThrow| (cons '|bad +-> arguments:| (list vl ))))))
              (setq |$formatArgList| (append vl |$formalArgList|))
              (setq x nx))))
         (t
          (setq vl (take (|#| sl) |$FormalMapVariableList|))))
        (cond
         (ress ress)
         (t
          (do ((t8 sl (cdr t8)) (m nil) (t9 vl (cdr t9)) (v nil))
              ((or (atom t8)
                   (progn (setq m (car t8)) nil)
                   (atom t9)
                   (progn (setq v (car t9)) nil))
                 nil)
              (seq (exit (progn
               (setq tmp6 
                (|compMakeDeclaration| (list '|:| v m ) |$EmptyMode| e))
               (setq e (third tmp6))
               tmp6))))
          (cond
           ((and oldstyle 
                 (null (null vl))
                 (null (|hasFormalMapVariable| x vl)))
            (return
             (progn
              (setq tmp6 (or (|comp| (cons x vl) mprime e) (return nil)))
              (setq u (car tmp6))
              (|extractCodeAndConstructTriple| u m oldE))))
           ((and (null vl) (setq tt (|comp| (cons x nil) mprime e)))
            (return
             (progn
               (setq u (car tt))
               (|extractCodeAndConstructTriple| u m oldE))))
           (t
            (setq tmp6 (or (|comp| x mprime e) (return nil)))
            (setq u (car tmp6))
            (setq uu (|optimizeFunctionDef| `(nil (lambda ,vl ,u))))
;  --  At this point, we have a function that we would like to pass.
;  --  Unfortunately, it makes various free variable references outside
;  --  itself.  So we build a mini-vector that contains them all, and
;  --  pass this as the environment to our inner function.
            (setq $funname nil)
            (setq $funnameTail (list nil))
            (setq expandedFunction (comp-tran (second uu)))
            (setq frees (freelist expandedFunction vl nil e))
            (setq expandedFunction
             (cond
              ((eql (|#| frees) 0)
               (cons 'lambda (cons (append vl (list '$$))
                                         (cddr expandedFunction))))
              ((eql (|#| frees) 1)
               (setq vec (caar frees))
                (cons 'lambda (cons (append vl (list vec))
                                         (cddr expandedFunction))))
              (t 
               (setq scode nil)
               (setq vec nil)
               (setq locals nil)
               (setq i -1)
               (do ((t0 frees (cdr t0)) (v nil))
                   ((or (atom t0) (progn (setq v (car t0)) nil)) nil)
                 (seq
                  (exit
                   (progn
                    (setq i (plus i 1))
                    (setq vec (cons (car v) vec))
                    (setq scode
                     (cons
                      (cons 'setq 
                       (cons (car v) 
                        (cons
                         (cons
                          (cond
                           (|$QuickCode| 'qrefelt)
                           (t 'elt))
                          (cons '$$ (cons i nil)))
                         nil)))
                       scode))
                    (setq locals (cons (car v) locals))))))
               (setq body (cddr expandedFunction))
               (cond
                (locals
                 (cond
                  ((and (pairp body)
                        (progn
                         (setq tmp1 (qcar body))
                         (and (pairp tmp1)
                              (eq (qcar tmp1) 'declare))))
                    (setq body
                     (cons (car body)
                      (cons
                       (cons 'prog
                        (cons locals
                         (append scode
                          (cons
                           (cons 'return
                            (cons
                             (cons 'progn
                              (cdr body))
                             nil))
                           nil))))
                        nil))))
                  (t
                   (setq body
                    (cons
                     (cons 'prog
                      (cons locals
                       (append scode
                        (cons
                         (cons 'return
                          (cons
                           (cons 'progn body)
                           nil))
                         nil))))
                     nil))))))
               (setq vec (cons 'vector (nreverse vec)))
               (cons 'lambda (cons (append vl (list '$$)) body)))))
            (setq fname (list 'closedfn expandedFunction))
            (setq uu
             (cond
              (frees (list 'cons fname vec))
              (t (list 'list fname))))
            (list uu m oldE))))))))))))

@

\defun{extractCodeAndConstructTriple}{extractCodeAndConstructTriple}
<<defun extractCodeAndConstructTriple>>=
(defun |extractCodeAndConstructTriple| (u m oldE)
 (let (tmp1 a fn op env)
  (cond
   ((and (pairp u) (eq (qcar u) '|call|)
         (progn
          (setq tmp1 (qcdr u))
          (and (pairp tmp1)
               (progn (setq fn (qcar tmp1)) t))))
    (cond
     ((and (pairp fn) (eq (qcar fn) '|applyFun|)
           (progn
            (setq tmp1 (qcdr fn))
            (and (pairp tmp1) (eq (qcdr tmp1) nil)
                 (progn (setq a (qcar tmp1)) t))))
            (setq fn a)))
    (list fn m oldE))
   (t
    (setq op (car u))
    (setq env (car (reverse (cdr u))))
    (list (list 'cons  (list '|function| op) env) m oldE)))))

@

\defun{hasFormalMapVariable}{hasFormalMapVariable}
\calls{hasFormalMapVariable}{ScanOrPairVec}
\usesdollar{hasFormalMapVariable}{formalMapVariables}
<<defun hasFormalMapVariable>>=
(defun |hasFormalMapVariable| (x vl)
 (let (|$formalMapVariables|)
 (declare (special |$formalMapVariables|))
 (when (setq |$formalMapVariables| vl)
  (|ScanOrPairVec| #'(lambda (y) (member y |$formalMapVariables|)) x))))

@

\defun{argsToSig}{argsToSig}
<<defun argsToSig>>=
(defun |argsToSig| (args)
 (let (tmp1 v tmp2 tt sig1 arg1 bad)
  (cond
   ((and (pairp args) (eq (qcar args) '|:|)
         (progn
          (setq tmp1 (qcdr args))
          (and (pairp tmp1)
               (progn
                (setq v (qcar tmp1))
                (setq tmp2 (qcdr tmp1))
                (and (pairp tmp2)
                     (eq (qcdr tmp2) nil)
                     (progn
                      (setq tt (qcar tmp2))
                      t))))))
    (list (list v) (list tt)))
   (t 
    (setq sig1 nil) 
    (setq arg1 nil)
    (setq bad nil)
    (dolist (arg args)
      (cond
       ((and (pairp arg) (eq (qcar arg) '|:|)
             (progn
              (setq tmp1 (qcdr arg))
              (and (pairp tmp1)
                   (progn
                    (setq v (qcar tmp1))
                    (setq tmp2 (qcdr tmp1))
                    (and (pairp tmp2) (eq (qcdr tmp2) nil)
                         (progn
                          (setq tt (qcar tmp2))
                          t))))))
         (setq sig1 (cons tt sig1))
         (setq arg1 (cons v arg1)))
        (t (setq bad t))))
    (cond
     (bad (list nil nil ))
     (t (list (reverse arg1) (reverse sig1))))))))

@

\defun{compMakeDeclaration}{compMakeDeclaration}
\calls{compMakeDeclaration}{compColon}
\usesdollar{compMakeDeclaration}{insideExpressionIfTrue}
<<defun compMakeDeclaration>>=
(defun |compMakeDeclaration| (x m e)
 (let (|$insideExpressionIfTrue|)
 (declare (special |$insideExpressionIfTrue|))
  (setq |$insideExpressionIfTrue| nil)
  (|compColon| x m e)))

@

\defun{modifyModeStack}{modifyModeStack}
\calls{modifyModeStack}{say}
\calls{modifyModeStack}{copy}
\calls{modifyModeStack}{setelt}
\calls{modifyModeStack}{resolve}
\usesdollar{modifyModeStack}{reportExitModeStack}
\usesdollar{modifyModeStack}{exitModeStack}
<<defun modifyModeStack>>=
(defun |modifyModeStack| (|m| |index|)
 (declare (special |$exitModeStack| |$reportExitModeStack|))
 (if |$reportExitModeStack|
   (say "exitModeStack: " (copy |$exitModeStack|)
    " ====> "
    (progn
     (setelt |$exitModeStack| |index|
      (|resolve| |m| (elt |$exitModeStack| |index|)))
     |$exitModeStack|))
   (setelt |$exitModeStack| |index|
      (|resolve| |m| (elt |$exitModeStack| |index|)))))

@

\defun{freelist}{Create a list of unbound symbols}
We walk argument u looking for symbols that are unbound. If we find a
symbol we add it to the free list. If it occurs in a prog then it is
bound and we remove it from the free list. Multiple instances of a single
symbol in the free list are represented by the alist (symbol . count)
\calls{freelist}{freelist}
\calls{freelist}{assq}
\calls{freelist}{identp}
\calls{freelist}{getmode}
\calls{freelist}{unionq}
<<defun freelist>>=
(defun freelist (u bound free e)
 (let (v op)
  (if (atom u)
   (cond
    ((null (identp u)) free)
    ((member u bound) free)
    ; more than 1 free becomes alist (name . number)
    ((setq v (assq u free)) (rplacd v (+ 1 (cdr v))) free)
    ((null (|getmode| u e)) free)
    (t (cons (cons u 1) free)))
   (progn
    (setq op (car u))
    (cond
     ((member op '(quote go |function|)) free)
     ((eq op 'lambda) ; lambdas bind symbols
      (setq bound (unionq bound (second u)))
      (dolist (v (cddr u))
       (setq free (freelist v bound free e))))
     ((eq op 'prog) ; progs bind symbols
      (setq bound (unionq bound (second u)))
      (dolist (v (cddr u))
       (unless (atom v)
        (setq free (freelist v bound free e)))))
     ((eq op 'seq)
      (dolist (v (cdr u))
       (unless (atom v)
        (setq free (freelist v bound free e)))))
     ((eq op 'cond)
      (dolist (v (cdr u))
       (dolist (vv v)
        (setq free (freelist vv bound free e)))))
     (t
      (when (atom op) (setq u (cdr u))) ; atomic functions aren't descended
      (dolist (v u)
       (setq free (freelist v bound free e)))))
    free))))

@

\defun{compOrCroak1,compactify}{compOrCroak1,compactify}
\calls{compOrCroak1,compactify}{compOrCroak1,compactify}
\calls{compOrCroak1,compactify}{lassoc}
<<defun compOrCroak1,compactify>>=
(defun |compOrCroak1,compactify| (al)
 (cond
  ((null al) nil)
  ((lassoc (caar al) (cdr al)) (|compOrCroak1,compactify| (cdr al)))
  (t (cons (car al) (|compOrCroak1,compactify| (cdr al))))))

@

\defun{ncINTERPFILE}{Compiler/Interpreter interface}
\calls{ncINTERPFILE}{SpadInterpretStream(5)}
\usesdollar{ncINTERPFILE}{EchoLines}
\usesdollar{ncINTERPFILE}{ReadingFile}
<<defun ncINTERPFILE>>=
(defun |ncINTERPFILE| (file echo)
 (let ((|$EchoLines| echo) (|$ReadingFile| t))
 (declare (special |$EchoLines| |$ReadingFile|))
  (|SpadInterpretStream| 1 file nil)))

@

\defun{compileSpadLispCmd}{compileSpadLispCmd}
\calls{compileSpadLispCmd}{pathname(5)}
\calls{compileSpadLispCmd}{pathnameType(5)}
\calls{compileSpadLispCmd}{selectOptionLC(5)}
\calls{compileSpadLispCmd}{namestring(5)}
\calls{compileSpadLispCmd}{terminateSystemCommand(5)}
\calls{compileSpadLispCmd}{fnameMake(5)}
\calls{compileSpadLispCmd}{pathnameDirectory(5)}
\calls{compileSpadLispCmd}{pathnameName(5)}
\calls{compileSpadLispCmd}{fnameReadable?(5)}
\calls{compileSpadLispCmd}{localdatabase(5)}
\calls{compileSpadLispCmd}{throwKeyedMsg}
\calls{compileSpadLispCmd}{object2String}
\calls{compileSpadLispCmd}{sayKeyedMsg}
\calls{compileSpadLispCmd}{recompile-lib-file-if-necessary}
\calls{compileSpadLispCmd}{spadPrompt}
\usesdollar{compileSpadLispCmd}{options}
<<defun compileSpadLispCmd>>=
(defun |compileSpadLispCmd| (args)
 (let (path optlist optname optargs beQuiet dolibrary lsp)
  (declare (special |$options|))
  (setq path (|pathname| (|fnameMake| (car args) "code" "lsp")))
  (cond
   ((null (probe-file path))
     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
   (t
    (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
    (setq beQuiet nil)
    (setq dolibrary t)
    (dolist (opt |$options|)
      (setq optname (car opt))
      (setq optargs (cdr opt))
      (case (|selectOptionLC| optname optlist nil)
         (|quiet|     (setq beQuiet t))
         (|noquiet|   (setq beQuiet nil))
         (|library|   (setq dolibrary t))
         (|nolibrary| (setq dolibrary nil))
         (t
          (|throwKeyedMsg| 's2iz0036
           (list (strconc ")" (|object2String| optname)))))))
    (setq lsp
     (|fnameMake|
      (|pathnameDirectory| path)
      (|pathnameName| path)
      (|pathnameType| path)))
    (cond
     ((|fnameReadable?| lsp)
      (unless beQuiet (|sayKeyedMsg| 's2iz0089 (list (|namestring| lsp))))
       (recompile-lib-file-if-necessary lsp))
     (t
      (|sayKeyedMsg| 's2il0003 (list (|namestring| lsp)))))
    (cond
     (dolibrary
      (unless beQuiet (|sayKeyedMsg| 's2iz0090 (list (|pathnameName| path))))
      (localdatabase (list (|pathnameName| (car args))) nil))
     ((null beQuiet) (|sayKeyedMsg| 's2iz0084 nil))
     (t nil))
    (|terminateSystemCommand|)
    (|spadPrompt|)))))

@

\defun{recompile-lib-file-if-necessary}{recompile-lib-file-if-necessary}
\calls{recompile-lib-file-if-necessary}{compile-lib-file}
\uses{recompile-lib-file-if-necessary}{*lisp-bin-filetype*}
<<defun recompile-lib-file-if-necessary>>=
(defun recompile-lib-file-if-necessary (lfile)
 (let* ((bfile (make-pathname :type *lisp-bin-filetype* :defaults lfile))
        (bdate (and (probe-file bfile) (file-write-date bfile)))
        (ldate (and (probe-file lfile) (file-write-date lfile))))
  (unless (and ldate bdate (> bdate ldate))
   (compile-lib-file lfile)
   (list bfile))))

@

\defun{spad-fixed-arg}{spad-fixed-arg}
<<defun spad-fixed-arg>>=
(defun spad-fixed-arg (fname )
 (and (equal (symbol-package fname) (find-package "BOOT"))
      (not (get fname 'compiler::spad-var-arg))
      (search ";" (symbol-name fname))
      (or (get fname 'compiler::fixed-args)
          (setf (get fname 'compiler::fixed-args) t)))
   nil)

@

\defun{compile-lib-file}{compile-lib-file}
<<defun compile-lib-file>>=
(defun compile-lib-file (fn &rest opts)
 (unwind-protect
  (progn
   (trace (compiler::fast-link-proclaimed-type-p
           :exitcond nil
           :entrycond (spad-fixed-arg (car system::arglist))))
   (trace (compiler::t1defun 
           :exitcond nil
           :entrycond (spad-fixed-arg (caar system::arglist))))
   (apply #'compile-file fn opts))
  (untrace compiler::fast-link-proclaimed-type-p compiler::t1defun)))

@

\defun{compileFileQuietly}{compileFileQuietly}
if \verb|$InteractiveMode| then use a null outputstream 
\usesdollar{compileFileQuietly}{InteractiveMode}
\uses{compileFileQuietly}{*standard-output*}
<<defun compileFileQuietly>>=
(defun |compileFileQuietly| (fn) 
  (let (
         (*standard-output*
         (if |$InteractiveMode| (make-broadcast-stream)
           *standard-output*)))
  (declare (special *standard-output* |$InteractiveMode|))
  (compile-file fn)))

@
\defdollar{byConstructors}
<<initvars>>=
(defvar |$byConstructors| () "list of constructors to be compiled")

@
\defdollar{constructorsSeen}
<<initvars>>=
(defvar |$constructorsSeen| () "list of constructors found")

@

<<Compiler>>=
(in-package "BOOT")

<<initvars>>

<<LEDNUDTables>>
<<GLIPHTable>>
<<RENAMETOKTable>>
<<GENERICTable>>

<<defmacro bang>>
<<defmacro def-::>>
<<defmacro must>>
<<defmacro star>>

<<defun action>>
<<defun addCARorCDR>>
<<defun addclose>>
<<defun add-parens-and-semis-to-line>>
<<defun advance-token>>
<<defun aplTran>>
<<defun aplTran1>>
<<defun aplTranList>>
<<defun argsToSig>>

<<defun blankp>>

<<defun char-eq>>
<<defun char-ne>>
<<defun comma2Tuple>>
<<defun comp>>
<<defun comp2>>
<<defun comp3>>
<<defun compAdd>>
<<defun compArgumentsAndTryAgain>>
<<defun compAtom>>
<<defun compAtSign>>
<<defun compCapsule>>
<<defun compCapsuleInner>>
<<defun compCase>>
<<defun compCase1>>
<<defun compCat>>
<<defun compCategory>>
<<defun compCoerce>>
<<defun compCoerce1>>
<<defun compColon>>
<<defun compColonInside>>
<<defun compCons>>
<<defun compCons1>>
<<defun compConstruct>>
<<defun compConstructorCategory>>
<<defun compDefine>>
<<defun compDefine1>>
<<defun compElt>>
<<defun compExit>>
<<defun compExpression>>
<<defun compForm>>
<<defun compForm1>>
<<defun compForm2>>
<<defun compHas>>
<<defun compIf>>
<<defun compileFileQuietly>>
<<defun compile-lib-file>>
<<defun compiler>>
<<defun compilerDoit>>
<<defun compileSpad2Cmd>>
<<defun compileSpadLispCmd>>
<<defun compImport>>
<<defun compIs>>
<<defun compJoin>>
<<defun compLambda>>
<<defun compLeave>>
<<defun compList>>
<<defun compMacro>>
<<defun compMakeDeclaration>>
<<defun compNoStacking>>
<<defun compNoStacking1>>
<<defun compOrCroak>>
<<defun compOrCroak1>>
<<defun compOrCroak1,compactify>>
<<defun compPretend>>
<<defun compQuote>>
<<defun compRepeatOrCollect>>
<<defun compReduce>>
<<defun compReduce1>>
<<defun compReturn>>
<<defun compSeq>>
<<defun compSeqItem>>
<<defun compSeq1>>
<<defun setqSetelt>>
<<defun setqSingle>>
<<defun compSetq>>
<<defun compSetq1>>
<<defun compString>>
<<defun compSubDomain>>
<<defun compSubDomain1>>
<<defun compSymbol>>
<<defun compSubsetCategory>>
<<defun compSuchthat>>
<<defun compTopLevel>>
<<defun compTypeOf>>
<<defun compVector>>
<<defun compWhere>>
<<defun compWithMappingMode>>
<<defun compWithMappingMode1>>
<<defun containsBang>>
<<defun convert>>
<<defun current-char>>
<<defun current-symbol>>
<<defun current-token>>

<<defun decodeScripts>>
<<defun deepestExpression>>
<<defun def>>
<<defun def-:>>
<<defun def-addlet>>
<<defun def-category>>
<<defun def-collect>>
<<defun def-cond>>
<<defun def-elt>>
<<defun def-equal>>
<<defun def-lessp>>
<<defun def-inner>>
<<defun def-insert-let>>
<<defun def-in2on>>
<<defun def-is>>
<<defun def-is2>>
<<defun def-is-eqlist>>
<<defun defIS>>
<<defun defIS1>>
<<defun def-isnt>>
<<defun defISReverse>>
<<defun def-is-remdup>>
<<defun def-is-remdup1>>
<<defun def-is-rev>>
<<defun def-it>>
<<defun def-let>>
<<defun defLET>>
<<defun defLET1>>
<<defun defLET2>>
<<defun defLetForm>>
<<defun def-message>>
<<defun def-message1>>
<<defun def-process>>
<<defun def-rename>>
<<defun def-rename1>>
<<defun def-repeat>>
<<defun def-setelt>>
<<defun def-seq>>
<<defun def-string>>
<<defun def-stringtoquote>>
<<defun deftran>>
<<defun def-where>>
<<defun def-whereclause>>
<<defun def-whereclauselist>>
<<defun dollarTran>>
<<defun drop>>

<<defun errhuh>>
<<defun escape-keywords>>
<<defun escaped>>
<<defun extractCodeAndConstructTriple>>

<<defun fincomblock>>
<<defun floatexpid>>
<<defun freelist>>

<<defun get-a-line>>
<<defun getScriptName>>
<<defun get-token>>
<<defun getToken>>

<<defun hackforis>>
<<defun hackforis1>>
<<defun hasAplExtension>>
<<defun hasFormalMapVariable>>

<<defun indent-pos>>
<<defun infixtok>>
<<defun initialize-preparse>>
<<defun initial-substring>>
<<defun initial-substring-p>>
<<defun is-console>>
<<defun isTokenDelimiter>>

<<defun Line-New-Line>>

<<defun make-string-adjustable>>
<<defun make-symbol-of>>
<<defun match-advance-string>>
<<defun match-current-token>>
<<defun match-next-token>>
<<defun match-string>>
<<defun match-token>>
<<defun meta-syntax-error>>
<<defun modifyModeStack>>

<<defun next-char>>
<<defun next-line>>
<<defun next-tab-loc>>
<<defun next-token>>
<<defun ncINTERPFILE>>
<<defun nonblankloc>>

<<defun optional>>

<<defun PARSE-AnyId>>
<<defun PARSE-Application>>
<<defun PARSE-Category>>
<<defun PARSE-Command>>
<<defun PARSE-CommandTail>>
<<defun PARSE-Conditional>>
<<defun PARSE-Data>>
<<defun PARSE-ElseClause>>
<<defun PARSE-Enclosure>>
<<defun PARSE-Exit>>
<<defun PARSE-Expr>>
<<defun PARSE-Expression>>
<<defun PARSE-Float>>
<<defun PARSE-FloatBase>>
<<defun PARSE-FloatBasePart>>
<<defun PARSE-FloatExponent>>
<<defun PARSE-FloatTok>>
<<defun PARSE-Form>>
<<defun PARSE-FormalParameter>>
<<defun PARSE-FormalParameterTok>>
<<defun PARSE-getSemanticForm>>
<<defun PARSE-GliphTok>>
<<defun PARSE-Import>>
<<defun PARSE-Infix>>
<<defun PARSE-InfixWith>>
<<defun PARSE-IntegerTok>>
<<defun PARSE-Iterator>>
<<defun PARSE-IteratorTail>>
<<defun PARSE-Label>>
<<defun PARSE-LabelExpr>>
<<defun PARSE-Leave>>
<<defun PARSE-LedPart>>
<<defun PARSE-leftBindingPowerOf>>
<<defun PARSE-Loop>>
<<defun PARSE-Name>>
<<defun PARSE-NBGliphTok>>
<<defun PARSE-NewExpr>>
<<defun PARSE-NudPart>>
<<defun PARSE-OpenBrace>>
<<defun PARSE-OpenBracket>>
<<defun PARSE-Operation>>
<<defun PARSE-Option>>
<<defun PARSE-Prefix>>
<<defun PARSE-Primary>>
<<defun PARSE-Primary1>>
<<defun PARSE-PrimaryNoFloat>>
<<defun PARSE-PrimaryOrQM>>
<<defun PARSE-Qualification>>
<<defun PARSE-Quad>>
<<defun PARSE-Reduction>>
<<defun PARSE-ReductionOp>>
<<defun PARSE-Return>>
<<defun PARSE-rightBindingPowerOf>>
<<defun PARSE-ScriptItem>>
<<defun PARSE-Scripts>>
<<defun PARSE-Seg>>
<<defun PARSE-Selector>>
<<defun PARSE-SemiColon>>
<<defun PARSE-Sequence>>
<<defun PARSE-Sequence1>>
<<defun PARSE-Sexpr>>
<<defun PARSE-Sexpr1>>
<<defun PARSE-SpecialCommand>>
<<defun PARSE-SpecialKeyWord>>
<<defun PARSE-Statement>>
<<defun PARSE-String>>
<<defun PARSE-Suffix>>
<<defun PARSE-TokenCommandTail>>
<<defun PARSE-TokenList>>
<<defun PARSE-TokenOption>>
<<defun PARSE-TokTail>>
<<defun PARSE-VarForm>>
<<defun PARSE-With>>
<<defun parsepiles>>
<<defun parseAnd>>
<<defun parseAtom>>
<<defun parseAtSign>>
<<defun parseCategory>>
<<defun parseCoerce>>
<<defun parseColon>>
<<defun parseConstruct>>
<<defun parseDEF>>
<<defun parseDollarGreaterEqual>>
<<defun parseDollarGreaterThan>>
<<defun parseDollarLessEqual>>
<<defun parseDollarNotEqual>>
<<defun parseEquivalence>>
<<defun parseExit>>
<<defun postForm>>
<<defun parseGreaterEqual>>
<<defun parseGreaterThan>>
<<defun parseHas>>
<<defun parseIf>>
<<defun parseIf,ifTran>>
<<defun parseImplies>>
<<defun parseIn>>
<<defun parseInBy>>
<<defun parseIs>>
<<defun parseIsnt>>
<<defun parseJoin>>
<<defun parseLeave>>
<<defun parseLessEqual>>
<<defun parseLET>>
<<defun parseLETD>>
<<defun parseMDEF>>
<<defun parseNot>>
<<defun parseNotEqual>>
<<defun parseOr>>
<<defun parsePretend>>
<<defun parseprint>>
<<defun parseReturn>>
<<defun parseSegment>>
<<defun parseSeq>>
<<defun parseTran>>
<<defun parseTranList>>
<<defun parseTransform>>
<<defun parseVCONS>>
<<defun parseWhere>>
<<defun postAdd>>
<<defun postAtom>>
<<defun postAtSign>>
<<defun postBigFloat>>
<<defun postBlock>>
<<defun postCategory>>
<<defun postcheck>>
<<defun postCollect>>
<<defun postCollect,finish>>
<<defun postColon>>
<<defun postColonColon>>
<<defun postComma>>
<<defun postConstruct>>
<<defun postDef>>
<<defun postError>>
<<defun postExit>>
<<defun postIf>>
<<defun postin>>
<<defun postIn>>
<<defun postJoin>>
<<defun postMapping>>
<<defun postMDef>>
<<defun postOp>>
<<defun postPretend>>
<<defun postQUOTE>>
<<defun postReduce>>
<<defun postRepeat>>
<<defun postScripts>>
<<defun postScriptsForm>>
<<defun postSemiColon>>
<<defun postSignature>>
<<defun postSlash>>
<<defun postTran>>
<<defun postTranList>>
<<defun postTranScripts>>
<<defun postTransform>>
<<defun postTransformCheck>>
<<defun postTuple>>
<<defun postTupleCollect>>
<<defun postWhere>>
<<defun postWith>>
<<defun preparse>>
<<defun preparse1>>
<<defun preparse-echo>>
<<defun preparseReadLine>>
<<defun preparseReadLine1>>
<<defun primitiveType>>
<<defun push-reduction>>

<<defun quote-if-string>>

<<defun read-a-line>>
<<defun recompile-lib-file-if-necessary>>
<<defun /rf-1>>
<<defun /RQ,LIB>>

<<defun setDefOp>>
<<defun skip-to-endif>>
<<defun spad>>
<<defun spad-fixed-arg>>
<<defun storeblanks>>
<<defun s-process>>

<<defun try-get-token>>

<<defun underscore>>
<<defun unget-tokens>>
<<defun unTuple>>

<<postvars>>

@
\eject
\begin{thebibliography}{99}
\bibitem{1} Jenks, R.J. and Sutor, R.S. 
``Axiom -- The Scientific Computation System''
Springer-Verlag New York (1992)
ISBN 0-387-97855-0
\bibitem{2} Knuth, Donald E., ``Literate Programming''
Center for the Study of Language and Information
ISBN 0-937073-81-4
Stanford CA (1992) 
\bibitem{3} Daly, Timothy, ``The Axiom Wiki Website''\\
{\bf http://axiom.axiom-developer.org}
\bibitem{4} Watt, Stephen, ``Aldor'',\\
{\bf http://www.aldor.org}
\bibitem{5} Lamport, Leslie, ``Latex -- A Document Preparation System'',
Addison-Wesley, New York ISBN 0-201-52983-1
\bibitem{6} Ramsey, Norman ``Noweb -- A Simple, Extensible Tool for
Literate Programming''\\
{\bf http://www.eecs.harvard.edu/ $\tilde{}$nr/noweb}
\bibitem{7} Daly, Timothy, "The Axiom Literate Documentation"\\
{\bf http://axiom.axiom-developer.org/axiom-website/documentation.html}
\bibitem{8} Pratt, Vaughn ``Top down operator precedence''
POPL '73 Proceedings of the 1st annual ACM SIGACT-SIGPLAN symposium on
Principles of programming languages 
\verb|hall.org.ua/halls/wizzard/pdf/Vaughan.Pratt.TDOP.pdf|
\bibitem{9} Floyd, R. W. ``Semantic Analysis and Operator Precedence''
JACM 10, 3, 316-333 (1963)
\end{thebibliography}
\chapter{Index}
\printindex
\end{document}
