\documentclass[dvipdfm]{book}
\newcommand{\VolumeName}{Volume 13: Proving Axiom Correct}
\usepackage{bbold}
\input{bookheader.tex}
\mainmatter
\setcounter{chapter}{0} % Chapter 1
Ultimately we would like Axiom to be able to prove that an
algorithm generates correct results. There are many steps
between here and that goal, including proving one Axiom
algorithm correct through all of the levels from Spad code,
to the Lisp code, to the C code, to the machine code; a 
daunting task of its own. 

The proof of a single Axiom algorithm is done with an eye toward
automating the process. Automated machine proofs are not possible
in general but will certainly exist for known algorithms. 
Bressoud said:

\begin{quote}
{\bf Writing is nature's way of letting you know how sloppy your
thinking is
} -- Guindon\cite{Lamp02}
\end{quote}

\begin{quote}
{\bf Mathematics is nature's way of letting you know how sloppy
your writing is.
} -- Leslie Lamport\cite{Lamp02}
\end{quote}

\begin{quote}
{\bf 
The existence of the computer is giving impetus to the discovery of
algorithms that generate proofs. I can still hear the echos of the
collective sigh of relief that greeted the announcement in 1970 that
there is no general algorithm to test for integer solutions to
polynomial Diophantine equations; Hilbert's tenth problem has no
solution. Yet, as I look at my own field, I see that creating
algorithms that generate proofs constitutes some of the most important
mathematics being done. The all-purpose proof machine may be dead, but
tightly targeted machines are thriving.}
-- Dave Bressoud \cite{Bres93}
\end{quote}

\begin{quote}
{\bf In contrast to humans, computers are good at performing formal
processes. There are people working hard on the project of actually
formalizing parts of mathematics by computer, with actual formally
correct formal deductions. I think this is a very big but very
worthwhile project, and I am confident that we will learn a lot from
it. The process will help simplify and clarify mathematics. In not too
many years, I expect that we will have interactive computer programs
that can help people compile significant chunks of formally complete
and correct mathematics (based on a few perhaps shaky but at least
explicit assumptions) and that they will become part of the standard
mathematicians's working environment.}
-- William P. Thurston \cite{Thur94}
\end{quote}

\begin{quote}
{\bf Our basic premise is that the ability to construct and modify programs
will not improve without a new and comprehensive look at the entire
programming process. Past theoretical research, say, in the logic of
programs, has tended to focus on methods for reasoning about
individual programs; little has been done, it seems to us, to develop
a sound understanding of the process of programming -- the process by
which programs evolve in concept and in practice. At present, we lack
the means to describe the techniques of program construction and
improvement in ways that properly link verification, documentation and
adaptability.}

-- Scherlis and Scott (1983) in \cite{Maso86}
\end{quote}

\begin{quote}
{\bf ...constructive mathematics provides a way of viewing the language of
logical propositions as a {\sl specification} language for
programs. An ongoing thrust of work in computer science has been to
develop program specification languages and formalisms for
systematically deriving programs from specifications. For constructive
mathematics to provide such a methodology, techniques are needed for
systematically extracting programs from constructive proofs. Early work
in this field includes that of Bishop and Constable. What
distinguished Martin-L\"of's '82 type theory was that the method it
suggested for program synthesis was exceptionally simple: a direct
correspondence was set up between the constructs of mathematical
logic, and the constructs of a functional programming
language. Specifically, every proposition was considered to be
isomorphic to a type expression, and the proof of a proposition would
suggest precisely how to construct an inhabitant of the type, which
would be a term in a functional programming language. The term that
inhabits the type corresponding to a proposition is often referred to as
the {\sl computational content} of the proposition.}

-- Paul Bernard Jackson\cite{Jack95}

\end{quote}

\chapter{Here is a problem}
The goal is to prove that Axiom's implementation of 
the Euclidean GCD algorithm is correct.

From category EuclideanDomain (EUCDOM) we find the implementation of 
the Euclidean GCD algorithm:
\begin{verbatim}
      gcd(x,y) ==                --Euclidean Algorithm
         x:=unitCanonical x
         y:=unitCanonical y
         while not zero? y repeat
            (x,y):= (y,x rem y)
            y:=unitCanonical y   -- this doesn't affect the
                                 -- correctness of Euclid's algorithm,
                                 -- but
                                 -- a) may improve performance
                                 -- b) ensures gcd(x,y)=gcd(y,x)
                                 --    if canonicalUnitNormal
         x
\end{verbatim}
The unitCanonical function comes from the category IntegralDomain (INTDOM)
where we find:
\begin{verbatim}
    unitNormal: % -> Record(unit:%,canonical:%,associate:%)
        ++ unitNormal(x) tries to choose a canonical element
        ++ from the associate class of x.
        ++ The attribute canonicalUnitNormal, if asserted, means that
        ++ the "canonical" element is the same across all associates of x
        ++ if \spad{unitNormal(x) = [u,c,a]} then
        ++ \spad{u*c = x}, \spad{a*u = 1}.
    unitCanonical: % -> %
        ++ \spad{unitCanonical(x)} returns \spad{unitNormal(x).canonical}.
\end{verbatim}
implemented as
\begin{verbatim}
      UCA ==> Record(unit:%,canonical:%,associate:%)
      if not (% has Field) then
        unitNormal(x) == [1$%,x,1$%]$UCA -- the non-canonical definition
      unitCanonical(x) == unitNormal(x).canonical -- always true
      recip(x) == if zero? x then "failed" else _exquo(1$%,x)
      unit?(x) == (recip x case "failed" => false; true)
      if % has canonicalUnitNormal then
         associates?(x,y) ==
           (unitNormal x).canonical = (unitNormal y).canonical
       else
         associates?(x,y) ==
           zero? x => zero? y
           zero? y => false
           x exquo y case "failed" => false
           y exquo x case "failed" => false
           true
\end{verbatim}

\section{Mathematics}

From Buchberger\cite{Buch97},

Define ``divides''
\[ t\vert a \Longleftrightarrow \exists u (t \cdot u = a)\]

Define ``greatest common divisor''
\[ {\rm GCD}(a,b) = \forall t\ max(t\vert a \land t\vert b)\]

Theorem:
\[ (t\vert a \land t\vert b) \Longleftrightarrow t\vert (a-b) \land t\vert b\]

Euclids' Algorithm
\[ a > b \Rightarrow {\rm GCD}(a,b) = {\rm GCD}(a-b,b)\]

By the definition of GCD we need to show that
\[\forall t\ max(t\vert a \land t\vert b) =
  \forall t\ max(t\vert (a-b) \land t\vert b)\]

Thus we need to show that
\[(t\vert a \land t\vert b) \Longleftrightarrow (t\vert (a-b) \land t\vert b)\]

Let $t$ be arbitrary but fixed and assume
\begin{equation}\label{eq1}(t\vert a \land t\vert b)\end{equation}

We have to show
\begin{equation}\label{eq2}t\vert (a-b)\end{equation}

and
\begin{equation}\label{eq3}t\vert b\end{equation}

Equation \ref{eq3} follows propositionally. For equation \ref{eq2},
by definition of ``divides'', we have to find a $w$ such that
\begin{equation}\label{eq4}t \cdot w = a-b\end{equation}

From \ref{eq1}, by definition of ``divides'', we know that for certain
$u$ and $v$
\[t \cdot u = a\]

and
\[t \cdot v - b\]

Hence,
\[ a-b = t \cdot u - t \cdot v\]

But
\[t \cdot u - t \cdot v = t \cdot (u - v)\]

So we need to find
\[w = u - v\]

and 
\[\textrm{Find w such that }t \cdot u - t \cdot v = t \cdot w\]


\section{Approaches}
There are several systems that could be applied to approach the proof.

The plan is to initially look at Coq and ACL2.  Coq seems to be
applicable at the Spad level. ACL2 seems to be applicable at the Lisp
level. Both levels are necessary for a proper proof.

Coq is very close to Spad in spirit so we can use it for the
high-level proofs.

ACL2 is a Lisp-level proof technology which can be used to prove
the Spad-to-Lisp level.

There is an LLVM to ACL2 translator which can be used to move from
the GCL Lisp level to the hardware since GCL compiles to C.
In particular, the "Vellvm: Verifying the LLVM" \cite{Zdan14}
project is important.

Quoting from Hardin \cite{Hard14}
\begin{quote}
LLVM is a register-based intermediate in Static Single Assignment
(SSA) form. As such, LLVM supports any number of registers, each of
which is only assigned once, statically (dynamically, of course, a
given register can be assigned any number of times). Appel has
observed that ``SSA form is a kind of functional programming''; this
observation, in turn, inspired us to build a translator from LLVM to
the applicative subset of Common Lisp accepted by the ACL2 theorem
prover. Our translator produces an executable ACL2 specification that
is able to efficiently support validation via testing, as the
generated ACL2 code features tail recursion, as well as in-place
updates via ACL2's single-threaded object (stobj) mechanism. In order
to ease the process of proving properties about these translated
functions, we have also developed a technique for reasoning about
tail-recursive ACL2 functions that execute in-place, utilizing a
formally proven ``bridge'' to primitive-recursive versions of those
functions operating on lists.
\end{quote}

{\center{\includegraphics{ps/v13llvmtoacl2.eps}}}

Hardin \cite{Hard13} describes the toolchain thus:
\begin{quote}
Our translation toolchain architecture is shown in Figure 1. The left
side of tthe figure depicts a typical compiler frontend producing LLVM
intermediate code. LLVM output can be produced either as a binary
``bitcode'' (.bc) file, or as text (.ll file). We chose to parse the
text form, producing an abstract syntax tree (AST) representation of
the LLVM program. Our translator then converts the AST to ACL2
source. The ACL2 source file can then be admitted into an ACL2
session, along with conjectures that one wishes to prove about the
code, which ACL2 processes mostly automatically. In addition to
proving theorems about the translated LLVM code, ACL2 can also be used
to execute test vectors at reasonable speed.
\end{quote}

Note that you can see the intermediate form from clang with
\begin{verbatim}
clang -O4 -S -emit-llvm foo.c
\end{verbatim}

Both Coq and the Hardin translator use OCAML \cite{OCAM14} so we will have to
learn that language.

\chapter{Theory}
The proof of the Euclidean algorithm has been known since Euclid.
We need to study an existing proof and use it to guide our use of
Coq along the same lines, if possible. Some of the ``obvious''
natural language statements may require Coq lemmas.

From WikiProof \cite{Wiki14a} we quote:

Let \[a, b \in \Z\] and $a \ne 0$ or $b \ne 0$.

The steps of the algorithm are:
\begin{enumerate}
\item Start with $(a,b)$ such that $\abs{a} \ge \abs{b}$.
If $b = 0$ then the task is complete and the GCD is $a$.
\item if $b \ne 0$ then you take the remainder $r$ of $a/b$.
\item set $a \leftarrow b$, $b \leftarrow r$ (and thus
$\abs{a} \ge \abs{b}$ again).
\item repeat these steps until $b = 0$
\end{enumerate}
Thus the GCD of $a$ and $b$ is the value of the variable $a$ 
at the end of the algorithm.

The proof is:

Suppose \[a, b \in \Z\] and $a or b \ne 0$.

From the {\bf division theorem}, $a = qb + r$ 
where $0 \le r \le \abs{b}$

From {\bf GCD with Remainder}, the GCD of $a$ and $b$ is also the GCD
of $b$ and $r$.

Therefore we may search instead for the $gcd(b,r)$.

Since $\abs{r} \ge \abs{b}$ and \[b \in \Z\],
we will reach $r = 0$ after finitely many steps.

At this point, $gcd(r,0) = r$ from {\bf GCD with Zero}.

We quote the {\bf Division Theorem} proof \cite{Wiki14b}:

For every pair of integers $a$, $b$ where $b \ne 0$, there exist unique
integers $q,r$ such that $a = qb + r$ and $0 \le r \le \abs{b}$.

\section{The Division Algorithm}
From Judson \cite{Juds15},

An Application of the Principle of Well-Ordering that we will use
often is the division algorithm.

{\bf Theorem 2.9 Division Algorithm} Let $a$ and $b$ be integers, with
$b > 0$. Then there exists unique integers $q$ and $r$ such that
\[a=bq+r\]
where $0 \le r < b$.

{\bf Proof}

Let $a$ and $b$ be integers. If $b = ak$ for some integer $k$, we write
$a \vert b$. An integer $d$ is called a {\sl common divisor} of $a$ and
\index{common divisor}
$b$ if $d \vert a$ and $d \vert b$. The {\sl greatest common divisor}
\index{greatest common divisor}
of integers $a$ and $b$ is a positive integer $d$ such that $d$ is
a common divisor of $a$ and $b$ and if $d^{'}$ is any other common
divisor of $a$ and $b$, then $d^{'} \vert d$. We write $d=gcd(a,b)$;
for example, $gcd(24,36)=12$ and $gcd(120,102)=6$. We say that two
integers $a$ and $b$ are {\sl relatively prime} if $gcd(a,b)=1$.
\index{relatively prime}

{\bf Theorem 2.10} Let $a$ and $b$ be nonzero integers. Then there
exist integers $r$ and $s$ such that
\[gcd(a,b)=ar+bs\]
Furthermore, the greatest common divisor of $a$ and $b$ is unique.

{\bf Proof}

{\bf Collary 2.11} Let $a$ and $b$ be two integers that are relatively
prime. Then there exist integers $r$ and $s$ such that
\[ar+bs=1\]

{\bf The Euclidean Algorithm}
\index{The Euclidean Algorithm}

Among other things, Theorem 2.10 allows us to compute the greatest 
common divisor of two integers.

{\bf Example 2.1.2} Let us compute the greatest common divisor of 945 and
2415. First observe that
\[
\begin{array}{rcl}
2415 & = & 945 \cdot 2 + 525\\
945 & = & 525 \cdot 1 + 420\\
525 & = & 420 \cdot 1 + 105\\
420 & = & 105 \cdot 4 + 0\\
\end{array}
\]

Reversing our steps, 105 divides 420, 105 divides 525, 105 divides 945,
and 105 divides 2415. Hence, 105 divides both 945 and 2415. If $d$ were
another common divisor of 945 and 2415, then $d$ would also have to
divide 105. Therefore, $gcd(945,2415)=105$.

If we work backward through the above sequence of equations, we can also
obtain numbers $r$ and $s$ such that
\[945r + 2415s = 105\]

\[
\begin{array}{rcl}
105 & = & 525 + (-1)\cdot 420\\
105 & = & 525 + (-1)\cdot [945+(-1)\cdot 525]\\
105 & = & 2\cdot 525+(-1)\cdot 945\\
105 & = & 2\cdot[2415+(-2)\cdot 945]+(-1)\cdot 945\\
105 & = & 2*2415+(-5)\cdot 945
\end{array}
\]
So $r=-5$ and $s-2$. Notice the $r$ and $s$ are not unique, since
$r=41$ and $s=-16$ would also work.

To compute $gcd(a,b)=d$, we are using repeated divisions to obtain
a decreasing sequence of positive integers
$r_1 > r_2 > \ldots > r_n = d$; that is

\[
\begin{array}{rcl}
b & = & aq_1+r_1\\
a & = & r_1q_2+r_2\\
r_1 & = & r_2q_3+r_3\\
\vdots\\
r_{n-2} & = & r_{n-1}q_n+r_n\\
r_{n-1} & = & r_nq_{n+1}
\end{array}
\]

To find $r$ and $s$ such that $ar+bs=d$, we begin with the last equation
and substitute results obtained from the previous equations:

\[
\begin{array}{rcl}
d & = & r_n\\
d & = & r_{n-2} - r_{n-1}q_n\\
d & = & r_{n-2} - q_n(r_{n-3}-q_{n-1}r_{n-2}\\
d & = & -q_nr_{n-3}+(1+q_nq_{n-1})r_{n-2}\\
\vdots\\
d & = & ra+sb
\end{array}
\]

\chapter{Software Details}
\section{Installed Software}
Install CLANG, LLVM
\begin{verbatim}
http://llvm.org/releases/download.html
\end{verbatim}
Install OCAML
\begin{verbatim}
sudo apt-get install ocaml
\end{verbatim}

An OCAML version of gcd would be written 
\begin{verbatim}
let rec gcd a b = if b = 0 then a else gcd b (a mod b)
val gcd : int -> int -> int = <fun>
\end{verbatim}

\chapter{Temporal Logic of Actions (TLA) \cite{TLA16}}
\begin{quote}
{\bf Sloppiness is easier than precision and rigor}
-- Leslie Lamport\cite{Lamp14a}
\end{quote}

Leslie Lamport\cite{Lamp14} on $21^{st}$ Century Proofs.

A method of writing proofs is described that makes it harder to prove
things that are not true. The method, based on hierarchical
structuring, is simple and practical. The author's twenty years of
experience writing such proofs is discussed.

Lamport points out that proofs need rigor and precision.
Structure and Naming are important. Every step of the proof
names the facts it uses. 

Quoting from \cite{TLA16}:

Broadly speaking, a TLA+ proof is a collection of {\sl claims},
arranged in a hierarchical structure which we describe below, where
each claim has an {\sl assertion} tht is either {\sl unjustified} or
justified by a collection of {\sl cited facts}. The purpose of TLAPS
is to check the user-provided proofs of theorems, that is, to check
that the hierarchy of claims indeed establishes the truth of the theorem
if the claims were true, and then to check that the assertion of every
justified claim indeed is implied {\sl by} its cited facts. If a TLA+
theorem has a proof with no unjustified claims, then, as a result of
checking the proof, TLAPS verifies the truth of the theorem.

\section{The algorithm}

The well-known Euclidean algorithm can be written in the PlusCal 
language as follows:
\begin{verbatim}
--algorithm Euclid {
  variables x \in 1..M, y \in 1..N, x0 = x, y0 = y;
  {
    while (x # y) {
      if (x < y) { y := y - x; }
      else { x := x-y; }
    };
    assert x = GCD(x0, y0) /\ y = GCD(x0, y0)
  }
\end{verbatim}

The PlusCal translator translates this algorithm into a TLA+ specification
that we could prove correct. However, in this tutorial, we shall write a
somewhat simpler specification of Euclid's algorithm directly in TLA+.

\subsection{Creating a new TLA+ module}

In order to get the definitions of arithmetic operators ($+$, $-$, etc.),
we shall make this specification {\sl extend} the {\tt Integers} 
standard module.

\begin{verbatim}
--------------------- Module Euclid ----------------------
EXTENDS Integers
\end{verbatim}

\subsection{Definitions}

We shall then define the GCD of two integers. For that purpose, let us
define the predicate ``p divides q'' as follows: p divides q iff there
exists some integer d in the interval 1..q such that q is equal to p
times d.

\begin{verbatim}
p | q == \E d \in 1..q : q = p * d
\end{verbatim}

We then define the set of divisors of an integer q as the sets of integers
which both belong to the interval 1..q and divide q:
\begin{verbatim}
Divisors(q) == {d \in 1..q : d | q}
\end{verbatim}

We define the maximum of a set S as one of the elements of this set which
is greater than or equal to all the other elements:
\begin{verbatim}
Maximum(S) == CHOOSE x \in S : \A y \in S : x >= y
\end{verbatim}

And finally, we define the GCD of two integers p and q to be the maximum
of the intersection of Divisors(p) and Divisors(a):
\begin{verbatim}
GCD(p,q) == Maximum(Divisors(p) \cap Divisors(q))
\end{verbatim}

For convenience, we shall also define the set of all positive integers as:
\begin{verbatim}
Number = Nat \ {0}
\end{verbatim}

\subsection{Constants and variables}
We then define the two constants and two variables needed to describe
the Euclidean algorithm, where M and N are the values whose GCD is to
be computed:
\begin{verbatim}
CONSTANTS M, N
VARIABLES x, y
\end{verbatim}

\subsection{The specification}
We define the initial state of the Euclidean algorithm as follows:
\begin{verbatim}
Init == (x = M) /\ (y = N)
\end{verbatim}

In the Euclidean algorithm, two actions can be performed:
\begin{itemize}
\item set the value of y to y - x if x $<$ y
\item set the value of x to x - y if x $>$ y
\end{itemize}

These actions are again written as a definition of {\tt Next}, which
specifies the next-state relation. In TLA+, a primed variable refers
to its value at the next state of the algorithm.
\begin{verbatim}
Next == \/ /\ x < y
           /\ y' = y - x
           /\ x' = x
        \/ /\ y < x
           /\ x' = x-y
           /\ y' = y
\end{verbatim}

The specification of the algorithm asserts that the variables have the
correct initial values and, in each execution step, either a {\tt Next}
action is performed or x and y keep the same values:
\begin{verbatim}
Spec == Init /\ [][Next]_<<x,y>>
\end{verbatim}

(For reasons that are irrelevant to this algorithm, TLA specifications
always allow {\sl stuttering steps} that leave all the variables
unchanged.)

We want to prove that the algorithm always satisfies the following
property:
\begin{verbatim}
ResultCorrect == (x = y) => x = GCD(M, N)
\end{verbatim}

Hence we want to prove the following theorem named Correctness:
\begin{verbatim}
THEOREM Correctness == Spec => []ResultCorrect
\end{verbatim}

\subsection{Summary}

\begin{verbatim}
--------------------- Module Euclid ----------------------
EXTENDS Integers

p | q == \E d \in 1..q : q = p * d
Divisors(q) == {d \in 1..q : d | q}
Maximum(S) == CHOOSE x \in S : \A y \in S : x >= y
GCD(p,q) == Maximum(Divisors(p) \cap Divisors(q))
Number == Nat \ {0}

CONSTANTS M, N
VARIABLES x, y

Init == (x = M) /\ (y = N)

Next == \/ /\ x < y
           /\ y' = y - x
           /\ x' = x
        \/ /\ y < x
           /\ x' = x-y
           /\ y' = y

Spec == Init /\ [][Next]_<<x,y>>

ResultCorrect == (x = y) => x = GCD(M,N)

THEOREM Correctness == Spec => []ResultCorrect
\end{verbatim}

\section{A simple proof}
\subsection{The invariant}

Intuitively, the theorem Correctness holds because the implementation
guarantees the following {\sl invariant}
\begin{verbatim}
InductiveInvariant == /\ x \in Number
                      /\ y \in Number
                      /\ GCD(x, y) = GCD(M, N)
\end{verbatim}

That is, {\tt InductiveInvariant} holds for the initial state (i.e.,
the state specified by {\tt Init}) and is preserved by the 
next-state relation {\tt [Next]\_}$<<x,y>>$

\subsection{Checking proofs}

First we need to assume that constants M and N are not equal to zero
\begin{verbatim}
ASSUME NumberAssumption == M \in Number /\ N \in Number
\end{verbatim}

Let us then prove that {\tt InductiveInvariant} holds for the initial state.
\begin{verbatim}
THEOREM InitProperty == Init => InductiveInvariant
\end{verbatim}

To check whether TLAPS can prove that theorem by itself, we declare
its proof obvious.
\begin{verbatim}
THEOREM InitProperty == Init => InductiveInvariant
  OBVIOUS
\end{verbatim}

We now ask TLAPS to prove that theorem. But TLAPS does not know how to
prove the proof obligation corresponding to that proof. It prints
that obligation and reports failures to three backends, Zenon, Isabelle,
and SMT. The default behavior of TLAPS is to send obligations first to
an SMT solver (by default CVC3), then if that fails to the automatic
prover Zenon, then if Zenon fails to Isabelle (with the tactic ``auto'').

\subsection{Using facts and definitions}
The obligation cannot be proved because TLAPS treats the symbols
{\tt Init} and {\tt InductiveInvariant} as opaque identifiers unless
it is explicitly instructed to expand their definitions using the
directive {\tt DEF}. The main purpose of this treantment of definitions
is to make proof-checking tractable, because expanding definitions can
arbitrarily increase the size of expressions. Explicit use of definitions
is also a good hint to the (human) reader to look only at the listed
definitions to understand a proof step. In tha precise case, we can ask
TLAPS to expand definitions of {\tt Init} and {\tt InductiveInvariant},
by replacing the proof {\tt OBVIOUS} by the proof\\
{\tt BY DEF Init, InductiveInvariant}. In the obligations sent to the
backends, the definitions of {\tt Init} and {\tt InductiveInvariant}
have been expanded. 

Unfortunately, none of the back-ends could prove that obligation. As with
{\tt definitions}, we have to specify which facts are {\sl usable}. In this
case, we have to make the fact {\tt NumberAssumption} usable by changing
the proof to
\begin{verbatim}
THEOREM InitProperty == Init => InductiveInvariant
  BY NumberAssumption DEF Init, InductiveInvariant
\end{verbatim}

The general form of a {\tt BY} proof is:
\[ {\tt BY\ } e_1,\ldots,e_m {\tt \ DEF\ } d_1,\ldots,d_n\]
which claims that the assertion follows by assuming $e_1,\ldots,e_m$
and expanding the definitions $d_1,\ldots,d_n$. It is the job of TLAPS
to then check this claim, and also to check that the cited facts
$e_1,\ldots,e_m$ are indeed true. 

Finally, SMT succeeds in proving that obligation.
\begin{verbatim}
--------------------- Module Euclid ----------------------
EXTENDS Integers

p | q == \E d \in 1..q : q = p * d
Divisors(q) == {d \in 1..q : d | q}
Maximum(S) == CHOOSE x \in S : \A y \in S : x >= y
GCD(p,q) == Maximum(Divisors(p) \cap Divisors(q))
Number == Nat \ {0}

CONSTANTS M, N
VARIABLES x, y

Init == (x = M) /\ (y = N)

Next == \/ /\ x < y
           /\ y' = y - x
           /\ x' = x
        \/ /\ y < x
           /\ x' = x-y
           /\ y' = y

Spec == Init /\ [][Next]_<<x,y>>

ResultCorrect == (x = y) => x = GCD(M,N)

InductiveInvariant == /\ x \in Number
                      /\ y \in Number
                      /\ GCD(x, y) = GCD(M, N)

ASSUME NumberAssumption == M \in Number /\ N \in Number

THEOREM InitProperty == Init => InductiveInvariant
  BY NumberAssumption DEF Init, InductiveInvariant

THEOREM Correctness == Spec => []ResultCorrect
\end{verbatim}


\chapter{Other Ideas to Explore}
Computerising Mathematical Text\cite{Kama15} explores various ways of 
capturing mathematical reasoning. 

Chlipala\cite{Chli15} gives a pragmatic approach to COQ.

Medina-Bulo et al.\cite{Bulo04} gives a formal verification of
Buchberger's algorithm using ACL2 and Common Lisp.

Th\'ery\cite{Ther01} used COQ to check an implementation of Buchberger's
algorithm.

Pierce\cite{Pier15} has a Software Foundations course in COQ with
downloaded files in Pier15.tgz.

\addcontentsline{toc}{chapter}{Bibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{axiom}
\bibliography{axiom}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\addcontentsline{toc}{chapter}{Index}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\printindex
\end{document}
